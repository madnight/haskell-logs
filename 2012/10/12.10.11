00:25:00 <startling> how do I put a typeclass restriction on a Type or TypeQ in Template Haskell?
00:25:25 <startling> I've got "x :: X -> y" right now. I want "x :: SomeClass y => X -> y"
00:30:25 <fmap> startling: I'm not an expert, but `forallT' has `CxtQ' field, see http://hackage.haskell.org/packages/archive/template-haskell/2.8.0.0/doc/html/Language-Haskell-TH-Lib.html#v:forallT
00:32:40 <startling> fmap: that doesn't seem like what I want, though?
00:32:51 <startling> oh wait
00:32:58 <startling> do type variables have implicit foralls?
00:33:33 <shachaf> Declarations usually do.
00:34:38 <startling> fmap: thanks, looks promising
00:35:08 <akamaus> can exceptions be catched in StateT s IO ?
00:45:43 <saep> akamaus: Yes.
00:46:41 <akamaus> saep, but how? catch and co works with IO according to documentation
00:47:43 <saep> you have to use 'liftIO'
00:48:24 <akamaus> saep, I want to run an action which uses a stored state an run a finalizer after it
00:49:10 <akamaus> saep, on what? the problem is finally :: IO a -> IO b -> IO a
00:49:25 <akamaus> seems I can't run my monadic action with it
00:50:01 <shachaf> saep: You need more than liftIO for things like exceptions.
00:50:49 <shachaf> There are a bunch of packages that provide vaguely what you want, like MonadCatchIO and MonadControl and what not.
00:50:58 <shachaf> I've never used any of those so I can't tell you which are good, if any.
00:51:20 <akamaus> shachaf, thanks, I'll look at them
00:53:06 <saep> MonadCatchIO works pretty much like the standard exceptions. You just have to define/derive an instance for MonadCatchIO.
00:53:53 <saep> With a state-transformer monad, you just need to use GeneralizedNewtypeDeriving.
00:54:37 <akamaus> saep, would it work with async exceptions?
00:55:51 <saep> I don't know that expression refers to :S
01:03:14 <saep> i suppose it works for all exceptions
01:22:05 <kaos`> I'm receiving a datastructure with around 20 attributes each a 'primitive' value over a stream, and I can choose to parse it into either into a Map or create a record for it. Is it safe to assume that the record will have much faster lookups even though the Map would be small?
01:32:01 * hackagebot keter 0.3.0.1 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-0.3.0.1 (MichaelSnoyman)
01:37:36 <ClaudiusMaximus> kaos`: depends - a (value strict) Map is probably easier/saner to deal with for 20 attributes, but a strict unpacked record will be more memory efficient and faster due to fewer indirections/comparisons
01:38:17 <ClaudiusMaximus> kaos`: i'd start with Map, then document the process of converting to record if it proves to be a bottleneck
01:38:34 <ClaudiusMaximus> kaos`: and write a fancy blog post with profiling graphs etc
01:44:02 <kamekura> hi all. I found this little function useful to me, but it doesn't seem to be in the std libraries:  myConcat = liftM concat . sequence
01:44:15 <kamekura> is there a standard way of doing the same thing?
01:44:44 <ClaudiusMaximus> :t liftM concat . sequence
01:44:46 <lambdabot> forall a (m :: * -> *). (Monad m) => [m [a]] -> m [a]
01:45:05 <ClaudiusMaximus> @hoogle [m [a]] -> m [a]
01:45:05 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
01:45:05 <lambdabot> Data.Foldable concat :: Foldable t => t [a] -> [a]
01:45:06 <lambdabot> Prelude concat :: [[a]] -> [a]
01:45:21 <ClaudiusMaximus> @hoogle+
01:45:21 <lambdabot> Data.List concat :: [[a]] -> [a]
01:45:22 <lambdabot> Data.Typeable gcast1 :: (Typeable1 t, Typeable1 t') => c (t a) -> Maybe (c (t' a))
01:45:22 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
01:45:24 <kamekura> in my case I only care about when the result is String... so I dont mind if it's not fully polymorphic
01:46:35 <ClaudiusMaximus> kamekura: there's probably nothing better, really - what is your specific Monad?
01:46:49 <kamekura> currently it's just a Reader monad
01:47:05 <kamekura> though it might change
01:47:48 <kamekura> maybe I'll rewrite as a Reader + Writer so this concat will go away
01:48:25 <ClaudiusMaximus> sure - well, i've probably written something very similar in some code, but it's no big deal to define it - it's just one line, and the import would be one line too (and possibly add a library dependency)
01:48:46 <kamekura> cool, thanks
01:49:55 <ClaudiusMaximus> > msum [return "foo", return "bar"] :: Maybe String
01:49:56 <lambdabot>   Just "foo"
01:50:56 <ClaudiusMaximus> > asum [return "foo", return "bar"] :: Maybe String
01:50:57 <lambdabot>   Not in scope: `asum'
01:51:13 <ClaudiusMaximus> > Data.Foldable.asum [return "foo", return "bar"] :: Maybe String
01:51:14 <lambdabot>   Just "foo"
01:51:25 <kamekura> I started my code with something like: "myConf <- ask;  foo' <- foo (fooFlag myConf);  bar <- bar (barFlag myConf) ; return (foo ++ bar)"
01:51:45 <t7> > msum [ return 1, Nothing ]
01:51:46 <lambdabot>   Just 1
01:51:50 <t7> :O
01:52:00 <t7> > msum [ Nothing, return 1, Nothing ]
01:52:01 <lambdabot>   Just 1
01:52:05 <t7> :O
01:52:07 <ClaudiusMaximus> > mconcat [return "foo", return "bar"] :: Maybe String  -- maybe Monoid stuff would work
01:52:08 <lambdabot>   Just "foobar"
01:53:00 <ClaudiusMaximus> > runReader (mconcat [return "foo", return "bar"] :: Reader () String) ()
01:53:01 <lambdabot>   No instance for (Data.Monoid.Monoid
01:53:01 <lambdabot>                     (Control.Monad.Tran...
01:54:17 <kamekura> but mconcat [Just "foo", ...]  is the same as concat ["foo", ...]
01:55:08 <ClaudiusMaximus> not quite, there#'s a Just wrapping the result
01:55:23 <ClaudiusMaximus> :t mconcat
01:55:24 <lambdabot> forall a. (Monoid a) => [a] -> a
01:55:28 <kamekura> I guess if I showed the whole code my question would make more sense... it's not just the last line but the way this pattern appears :  "myConf <- ask;  foo' <- foo (fooFlag myConf);  bar <- bar (barFlag myConf) ; return (foo ++ bar)"
01:56:16 <quicksilver> "ask" ing just so you can pass it twice seems odd
01:56:35 <quicksilver> why aren't "fooFlag" and "barFlag" actions in the reader?
01:56:58 <kamekura> yeah, it's just an example, it's sometimes more than twice
01:57:35 <quicksilver> well as a general rule you hope not to have to use 'ask' and then  pass 'myConf' all over the place
01:57:40 <quicksilver> that's rather the point of the monad
01:57:45 <quicksilver> to make myConf implicit
01:57:47 <kamekura> quicksilver: can you give an example?
01:58:39 <quicksilver> foo' <- foo =<< fooFlagX
01:58:51 <quicksilver> bar' <- bar =<< barFlagX
01:59:05 <quicksilver> where fooFlagX and barFlagX are 'reader' versions of fooFlag and barFlag
01:59:16 <kamekura> ok
01:59:38 <kamekura> actually I'm loooking at the code again and I only "ask" for using in non-monadic let bindings
01:59:48 <ClaudiusMaximus> fooFlagX = liftM fooFlag ask   -- untested, still not caffeinated enough
02:00:15 <kamekura> "myConf <- ask;  let foo = getFoo (fooFlag myConf) " etc
02:00:39 <ClaudiusMaximus> or even   fooFlagX = asks fooFlag  -- because it's so common there's a Reader function for this pattern
02:00:42 <ClaudiusMaximus> :t asks
02:00:44 <lambdabot> forall r a (m :: * -> *). (MonadReader r m) => (r -> a) -> m a
02:01:34 <kamekura> I see
02:01:48 <quicksilver> kamekura: better would be "foo <- getFoo <$> fooFlagX"
02:02:07 <quicksilver> or foo <- getFoo <$> asks fooFlag
02:02:12 <quicksilver> as ClaudiusMaximus points out.
02:02:24 <quicksilver> I mean. I say "better". It's not like what you had before was hideous :)
02:02:35 <kamekura> thnx
02:02:35 <quicksilver> you shouldn't be scared of doing things explicitly if it makes it clear to yourself.
02:02:47 <quicksilver> but on the other hand - this is what the reader monad is supposed to be about
02:02:51 <kamekura> I'm still at the point of writing down things very explicitly and then refactoring them manually
02:03:00 <quicksilver> making the conf implicit so you don't have to keep fetching it / passing it
02:04:34 <ClaudiusMaximus> @@ @pl @undo do { f <- getFoo <$> asks fooFlag ; b <- getBar <$> asks barFlag ; return (f ++ b) }     -- might turn out insane, pl is that way
02:04:34 <lambdabot>  (`fmap` (getBar <$> asks barFlag)) . (++) =<< getFoo <$> asks fooFlag
02:04:45 <ClaudiusMaximus> yes, don't use that
02:04:57 <t7> @check \x y z -> (x :: Integer) * y + x * z == x * ( y + z)
02:04:59 <lambdabot>   "OK, passed 500 tests."
02:06:39 <t7> how can i prove that?
02:06:47 <t7> gimme a hint
02:06:49 <t7> dont tell me
02:06:54 <quicksilver> induction.
02:07:04 <t7> oh do i have to ? :(
02:07:21 <quicksilver> most things about natural numbers start with induction
02:07:39 <quicksilver> you could alternatively prove it from some other theorems you consider "obvious"
02:07:50 <quicksilver> (but those theorems would probably be proven by induction)
02:08:26 <kamekura> I guess you could prove it "geometrically" too
02:08:31 <ClaudiusMaximus> @check \x y z -> (x :: Int16) * y + x * z == x * ( y + z)  -- curious
02:08:32 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary GHC.Int.Int16)
02:08:33 <lambdabot>    arising from a...
02:08:37 <ClaudiusMaximus> meh
02:08:38 <kamekura> if you don't mind an informal proof
02:09:40 <t7> what does a real inductive proof look like? (not agda)
02:10:13 <kamekura> you can't do induction on reals :)
02:10:52 <quicksilver> yes the geometric proof of that is pretty obvious
02:11:20 <quicksilver> but arguably not fundamental
02:11:35 * frerich does a mental note to google what a 'geometric proof' is - something with graphs?
02:13:49 <t7> kamekura: :P
02:14:29 <quicksilver> frerich: you can draw a simple picture with two rectangles, which makes this proof "simply" the observation that two rectangles with a common side form a larger rectangle.
02:15:11 <quicksilver> but a number theorist probably wouldn't accept that proof because it relies on all kinds of higher axioms of geometry to form it
02:21:14 <sm0ke> guys what vim colorscheme do i use to get this type of coloring http://learnyouahaskell.com/syntax-in-functions#guards-guards?
02:23:27 <ClaudiusMaximus> sm0ke: view the page source, search for "script" tags, see what those scripts are (because that's how the colouring appears to be done on that page)
02:23:58 <ClaudiusMaximus> sm0ke: alternatively, HsColour can do it in various output modes
02:24:18 <dmwit> I doubt there's a ready-made color scheme with those exact colors, if that's what you're asking.
02:24:23 <ClaudiusMaximus> sm0ke: http://hackage.haskell.org/package/hscolour
02:24:27 <dmwit> ClaudiusMaximus: Maybe you missed the "vim" in his question?
02:24:54 <ClaudiusMaximus> dmwit: oops, exactly
02:28:39 <dmwit> That said, darkblue is my personal favorite colorscheme.
02:29:56 <identity> ClaudiusMaximus: hmm, thanks for that, didn't know about that.
02:30:09 <identity> though zenburn is a really nice colorscheme and I'm probably just going to stick with that
02:32:10 * hackagebot const-math-ghc-plugin 0.2.0.0 - Compiler plugin for constant math elimination  http://hackage.haskell.org/package/const-math-ghc-plugin-0.2.0.0 (ConradParker)
02:33:25 <sm0ke> that website guy says he hangs out here
02:33:31 <sm0ke> but no reply yet i see
02:33:58 <dmwit> Haven't seen him in a long time.
02:34:07 <identity> sm0ke: Of course, the author couldn't possibly have anything else to do but hang out in irc at all times, forever.
02:34:10 <identity> but yes, what dmwit said.
02:34:22 <sm0ke> :)
02:37:32 <t7> @check \a b c -> a * b + (c + a * c) ≡ c + a * (b + c :: Integer)
02:37:33 <lambdabot>   Not in scope: `
02:37:39 <t7> @check \a b c -> a * b + (c + a * c) == c + a * (b + c :: Integer)
02:37:40 <lambdabot>   "OK, passed 500 tests."
02:38:56 <t7> ok this is not an easy proof :(
02:39:16 <t7> i need a new hobby
02:39:28 <dmwit> That particular equality looks like it has a relatively easy proof.
02:40:16 <dmwit> Commutativity and associativity of (+) and distributivity of (*) over (+) are all pretty common things to prove, and that equality follows in like a line or two from those.
02:40:51 <quicksilver> dmwit: "follows from" ?
02:41:01 <quicksilver> oh, I see, second one.
02:41:11 <quicksilver> earlier t7 was proving distributivity
02:41:25 <dobblego> is there a non-associative, commutative operation?
02:41:28 <quicksilver> once you've proved distributivity then that one is simple yes
02:42:10 * hackagebot simple-log 0.1.5 - Simple log for Haskell  http://hackage.haskell.org/package/simple-log-0.1.5 (AlexandrRuchkin)
02:43:07 <quicksilver> dobblego: wikipedia suggests rock paper scissors :)
02:43:25 <dobblego> quicksilver: link?
02:43:41 <dmwit> dobblego: How about nand?
02:43:49 <dmwit> nand a b = not a && not b
02:43:53 <dobblego> I once went hunting for a proof, but I think I used the wrong search terms
02:44:49 <quicksilver> dobblego: http://en.wikipedia.org/wiki/Example_of_a_commutative_non-associative_magma
02:45:20 <dmwit> > let uni = [False, True]; nand a b = not a && not b in (and [nand a b == nand b a | a <- uni, b <- uni], and [nand a (nand b c) == nand (nand a b) c | a <- uni, b <- uni, c <- uni])
02:45:22 <lambdabot>   (True,False)
02:45:29 <dobblego> @check let commutative op a b = op a b == op b a; associative op a b = ((a `op` b) `op` c) == (a `op` (b `op` c)); nand a b = not a && not b in commutative
02:45:30 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t -> a)
02:45:30 <lambdabot>    arising from a use...
02:45:38 <dobblego> quaestor: ta
02:45:40 <dobblego> quicksilver: ta
02:45:50 <quicksilver> hmm - http://bramcohen.livejournal.com/30780.html
02:46:59 <Okasu> >2006-03-18
02:47:10 <Okasu> are you serious :/
02:47:27 <basdirks_> can I declare project-wide compiler flags in my .cabal file?
02:47:29 <shajen> hi
02:47:53 <dobblego> basdirks_: sure why not?
02:48:03 <shajen> i need to write a function with type (a) -> (b) can anyone help me how to do it?
02:48:19 <basdirks_> how would I do that dobblego? or where can I read more?
02:48:34 <dobblego> shajen: it is not possible, why do you need to do that?
02:48:45 <frerich> shajen: That function cannot be realized, I think.
02:48:54 <dobblego> basdirks_: maybe I don't understand your question — can you not just specify the appropriate cabal field?
02:49:18 <shajen> dobblego: i'm sure it's possible, this is my task
02:49:33 <dobblego> shajen: I'm quite sure it is not — perhaps you can show the wording of your task?
02:50:06 <shajen> Write any function of type 'a ->' b
02:50:31 <dobblego> shajen: do you mean for a specific a and b?
02:50:45 <quicksilver> 'a makes me think of ML
02:50:47 <shajen> i dont know
02:51:12 <Jafet> Must be another project euler problem.
02:51:20 <dobblego> quicksilver: I thought that too, but there is a typo, so I guessed it was just misplaced quotes
02:51:40 <dobblego> shajen: if you wrote a function that takes an integer and adds 10, would this be sufficient?
02:52:40 <dmwit> shajen: Are you extra-sure you're telling us the exact wording of the problem, capitalization and all?
02:52:54 <kamekura>  @@ @pl foo xs = xs ++ "a"
02:53:00 <frerich> Maybe the actual expected answer to the problem is that you explain why the function cannot be realized.
02:53:10 <kamekura> how do I use lambdabot to get point free ?
02:53:20 <dmwit> ?pl foo xs = xs ++ "a"
02:53:20 <lambdabot> foo = (++ "a")
02:53:26 <kamekura> thanks
02:53:35 <dmwit> @@ @pl foo xs = xs ++ "a"
02:53:36 <lambdabot>  foo = (++ "a")
02:53:45 <dmwit> Yours was fine, too, you just had an extra space at the front.
02:53:56 <kamekura> ?pl unlines' xs = unlines xs ++ "unlines' xs = unlines xs ++ "\n"\n"
02:53:56 <lambdabot> (line 1, column 59):
02:53:56 <lambdabot> unexpected "\\"
02:53:56 <lambdabot> expecting variable, "(", operator, ":", "++", "<+>" or end of input
02:54:05 <kamekura> unlines' xs = unlines xs ++ "a"
02:54:14 <kamekura> ?pl unlines' xs = unlines xs ++ "a"
02:54:15 <lambdabot> unlines' = (++ "a") . unlines
02:54:36 <hpaste> t7 pasted “is this allowed?” at http://hpaste.org/76120
02:54:58 <Jafet> > ap (++) show "ap (++) show "
02:55:00 <lambdabot>   "ap (++) show \"ap (++) show \""
02:55:50 <dmwit> t7: Depends how multiplication is defined.
02:55:56 <dmwit> But the answer is "probably, yeah".
02:57:09 <akamaus> shachaf, in case you interested, MonadCatchIO-mtl looks to be the right package
02:57:37 <dmwit> Also: starting induction at 1? What is this?
02:57:50 <t7> thats what some webpage said
02:58:23 <frerich> Maybe that web page provde something for a function which is not defined for values < 1 :-)
02:59:57 <Jafet> "Proving" trivial things is meaningless without knowing the basic definitions.
03:00:36 <Jafet> For example, how do you know that ab + b = (a + 1)b.
03:03:01 <quicksilver> t7:  don't prove equalities by manipulating *both* sides at once
03:03:17 <quicksilver> start from one side and make steps towards the other.
03:03:52 <quicksilver> 1(b+c) = b + c = 1b + 1c
03:04:44 <Rc43> Hi, guys.
03:05:20 <dmwit> quicksilver: I dunno. The unspoken rule of mathematics is that you can do anything you want as long as you can expand it to something more principled at will.
03:05:36 <Rc43> Where EDSLs and plain libraries differ? In that EDSLs use specific notation?
03:05:57 <dmwit> "library" isn't as awesome a buzzword
03:08:56 <Jafet> Libraries are like loanwords; an embedded language is like pig latin.
03:09:18 <quicksilver> Rc43: there is no hard line.
03:09:43 <quicksilver> EDSLs encourage you to construct "terms" (just expressions really) using the vocabulary (just exported names, really) they give you.
03:11:05 <Rc43> quicksilver, so EDSL is a way for creation descriptions and libraries provide processing itself; right?
03:11:20 <Rc43> *creating
03:15:45 <quicksilver> perhaps, Rc43, yes
03:39:31 <donri> what is the term for things like, `read . show = id`?
03:41:23 <timthelion> Where are the binarry haskell-platform downloads these days?  http://www.haskell.org/platform/linux.html wants me to build from source
03:41:57 <zomg> timthelion: click one of the icons for the distributions
03:42:13 * hackagebot haddock 2.13.0 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-2.13.0 (SimonHengel)
03:42:17 <zomg> if you're on some other distro then I guess you'll need to build from source
03:43:16 <timthelion> zomg: well here on arch. We cannot have multiple versions of the platform installed. And since I'm in a time critical project and don't have time to fight with broken libraries I want to use the previos platform version.  It used to be, that there was a binarry link to that on that page.  It's gone :(
03:43:25 <ClaudiusMaximus> > sqrt 90000
03:43:26 <lambdabot>   300.0
03:43:39 * ClaudiusMaximus should be better at mental arithmetic :S
03:43:49 <zomg> timthelion: did you check "prior releases"?
03:45:13 <timthelion> zomg: also doesn't have binaries for linux...
03:45:47 <zomg> Not familiar with arch really but I'd imagine you would be able to download the older versions of the binaries and install them manually somehow
03:46:06 <zomg> Besides that, out of luck then I guess
03:52:24 <yitz> timthelion: i usually download the generic ghc linux binary from the ghc site. then when you "build" the haskell platform, it just installs all the haskell packages.
03:53:36 <timthelion> yitz: and does it take 3 days and the sacrifice of goats to build the platform?
03:55:10 <timthelion> yitz: that's basically what I'm trying to do.  I uninstalled everything, found the old packages for the old ghc and cabal and am trying to let everything build manual.
04:02:13 * hackagebot haddock 2.13.1 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-2.13.1 (SimonHengel)
04:07:13 * hackagebot rdtsc-enolan 0.0 - Binding to sources of high-efficiency, high-precision, monotonically  increasing relative time.  http://hackage.haskell.org/package/rdtsc-enolan-0.0 (EchoNolan)
04:12:14 * hackagebot BNFC-meta 0.4 - Deriving Parsers and Quasi-Quoters from BNF Grammars  http://hackage.haskell.org/package/BNFC-meta-0.4 (JonasDuregard)
04:15:39 <KBme> hi
04:15:57 <KBme> if I have a type IO a, and need a type a what do I do? isn't this what lift is supposed to do?
04:19:35 <Lemmih> KBme: Nope, you want 'bind'.
04:20:05 <Lemmih> KBme: do a <- yourAction; doSomethingWith a
04:24:38 <hpc> KBme: very roughly speaking, instead of trying to take things out of IO, you take the computation into IO
04:24:53 <KBme> ok. thanks
04:25:34 <hpc> IO actions are computations that depend on the state of the real world; taking a value out of IO is roughly analogous to trying to get a number out of the addition function ;)
04:26:39 <strebe> I chose 3.14!
04:28:25 <timthelion> I thought discussing IO was forbidden on this channel.
04:28:39 <timthelion> We should create #haskell-IO for all of that nonsense.
04:32:15 * hackagebot yesod-core 1.1.3 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.1.3 (MichaelSnoyman)
04:53:21 <KitB_> Is there an easy way to set up ghc7 on Debian Squeeze?
04:54:20 <zomg> compile from source seemed to work pretty easily for me
04:54:37 <KitB_> I'd rather keep it managed with apt
04:54:48 <KitB_> This is on a server
04:55:33 <zomg> I'd imagine you may have trouble with all the dependencies for it
04:55:41 <KitB_> Unfortunately I can't seem to set up lambdabot with ghc6
04:55:43 <zomg> but not really that pro with apt stuff so perhaps there's some trick to it
04:56:02 <KitB_> I suppose the real question is "is there an easy way to set up lambdabot on Debian Squeeze?"
04:56:11 <zomg> dist-upgrade
04:56:13 <zomg> :P
04:56:20 <KitB_> :P
05:00:56 <strebe> KitB_: compiled from source, followed by using checkinstall, is often a nice option
05:01:52 <strebe> http://en.wikipedia.org/wiki/Checkinstall - it'll give you a deb package which you can manage with apt
05:02:13 <Jafet> If you install lambdabot from hackage, you should be able to use ghc6.
05:02:35 <hpaste> Jafet annotated “is this allowed?” with “this is allowed” at http://hpaste.org/76120#a76128
05:02:50 <Jafet> Oops
05:03:50 <fmap> Jafet: Is it coq?
05:04:05 <Jafet> I wish, it's isar-script
05:04:49 <fmap> nice
05:07:08 <t7> needs moar unicode and less english
05:11:53 <cornihilio> is thre any easy way to reverse the endianness of a bytestring?
05:12:16 * hackagebot couchdb-conduit 0.10.5 - Couch DB client library using http-conduit and aeson  http://hackage.haskell.org/package/couchdb-conduit-0.10.5 (AlexanderDorofeev)
05:12:28 <Jafet> Bytestrings don't have endianness.
05:12:59 <Botje> Data.Serialize has nice getWord32le methods
05:13:16 <Jafet> You probably want to combine one Binary.get and one Binary.put.
05:13:25 <cornihilio> okay, thank you!
05:13:50 <cornihilio> also, is it possible to put an attoparsec parser within a second attoparsec parser?
05:14:04 <hpc> "within" how?
05:14:10 <cornihilio> the first parser finds the length of a packet, and I want the second parser to only run on the packet contents
05:14:17 <cornihilio> hpc: I'm not sure myself...
05:14:20 <hpc> ah
05:14:21 <t7> there should be some gui tool for manipulating equations with the mouse/touchscreen
05:14:24 <hpc> so something like
05:14:25 <cornihilio> but it's a lazy bytestring
05:14:31 <hpc> packet = do
05:14:31 <Botje> cornihilio: just eat $SIZE bytes, and run attoparsec on the second parser.
05:14:37 <hpc>   len <- parseLength
05:14:40 <hpc>   contents len
05:14:44 <Botje> alternatively, parameterize your second parser with a maximum length.
05:15:19 <cornihilio> hpc: parseLength?
05:15:37 <cornihilio> what function is that and what is it's type?
05:15:40 <hpc> cornihilio: supposing you have already written parseLength and contents
05:16:02 <hpc> which would parse the header for the length of the packet, and the packet contents repsectively
05:17:59 <cornihilio> right
05:22:16 * hackagebot wai-middleware-cache 0.3.6 - Caching middleware for WAI.  http://hackage.haskell.org/package/wai-middleware-cache-0.3.6 (AlexanderDorofeev)
05:22:19 * hackagebot wai-middleware-catch 0.3.6 - Wai error catching middleware  http://hackage.haskell.org/package/wai-middleware-catch-0.3.6 (AlexanderDorofeev)
05:24:47 <KitB_> Jafet: perhaps it's not a ghc6 problem that's causing my builds to fail then
05:27:04 <identity> Is there a function in Control.Arrow that works similarly to second, but it takes two tuples and applys a function to both second elements?
05:27:25 <identity> I would just hoogle the type, but given the whole "a b c" arrow types, I can't really figure out what I'd need
05:27:33 <quicksilver> takes two tuples?
05:27:43 <quicksilver> how would you expect an arrow function to take two tuples?
05:27:52 <identity> quicksilver: I don't really understand arrows, I guess
05:28:03 <identity> I've just been using them for convenience when dealing with tuples
05:28:28 <quicksilver> you want (a,b) -> (a,b) -> (b -> c) -> ((a,c),(a,c)) ?
05:28:36 <dobblego> (a, x) -> (b, x) -> (x -> y) -> ((a, y), (b, y)) ?
05:28:39 <identity> basically: f (_, 2) (_, 1) (+) = 3
05:28:40 <identity> eh
05:28:51 <identity> yes, 3
05:28:52 <identity> sorry
05:29:06 <ClaudiusMaximus> :t (+) `on` snd
05:29:08 <lambdabot> forall a b. (Num b) => (a, b) -> (a, b) -> b
05:29:08 <quicksilver> oh it's a binary function
05:29:13 <identity> huh.
05:29:29 <identity> ClaudiusMaximus: That is indeed smart
05:29:38 <ClaudiusMaximus> :)
05:29:57 <identity> ClaudiusMaximus: thanks!
05:34:56 <t7> @hoogle 1024 / 8
05:34:57 <lambdabot> Parse error:
05:34:57 <lambdabot>   1024 / 8
05:34:57 <lambdabot>   ^
05:35:04 <t7> > 1024 / 8
05:35:05 <lambdabot>   128.0
05:37:59 <cornihilio> can someone point me to an example of nested if's in haskell? specifically, is there an example where the first statement is an if statement?
05:38:27 <merijn> cornihilio: Haskell doesn't have it statements, only if expressions
05:39:15 <Philippa> though it'd be nice if it did have them in do notation
05:39:28 <hpaste> merijn pasted “nested if?” at http://hpaste.org/76132
05:39:28 <Philippa> except, not really because it buggers up the binding structure
05:39:57 <merijn> cornihilio: Not really sure what you mean, though? Does that hpaste answer your question?
05:40:19 <merijn> cornihilio: Although generally you'd write that using guards...
05:40:47 <ion> I have never needed nested ifs in Haskell.
05:41:44 <hpaste> merijn annotated “nested if?” with “nested if? (annotation)” at http://hpaste.org/76132#a76133
05:41:52 <merijn> ion: Me neither
05:43:23 <cornihilio> merijn: yup! thank you!
05:43:57 <merijn> cornihilio: In most cases (all cases?) you should prefer the guard notation I just showed you
05:44:44 <merijn> cornihilio: In haskell if/then/else is just an expression you can use anywhere expressions are valid (i.e. they're more like the ?: ternary operator in C/Java than if statements)
05:45:30 <merijn> > (if True then 2 else -1) + 3
05:45:31 <lambdabot>   5
05:45:34 <Leif_Bork> When functions are inlined, will polymorphic types be changed to something ... less general ... when possible, to optimize?
05:46:08 <merijn> Leif_Bork: Define polymorphic? Are you talking about typeclasses? Or "id :: a -> a" type polymorphic?
05:46:30 <Leif_Bork> merijn: Yep
05:46:37 <Leif_Bork> The last one
05:46:47 <merijn> There's not really anything to specialise there
05:47:01 <merijn> So specialising doesn't really optimise anything
05:47:37 <merijn> Leif_Bork: Let's take "id :: a -> a" as example, what would you expect it to do as optimisation?
05:48:06 <merijn> You could make it "id :: Int -> Int", but types don't exist at runtime anyway, so there's nothing to gain from it
05:49:29 <identity> merijn: I'm guessing he's referring to the resulting code that is created when using, for example, Integer vs Int
05:49:39 <identity> in which case Int will be faster
05:49:52 <Leif_Bork> merijn: If we don't take id, and instead a function that does some numerical stuff, and is defined using some general types that would be slow compared to Int or Double
05:50:23 <Leif_Bork> Yep
05:50:34 <merijn> Leif_Bork: Ah, but numerical stuff uses typeclasses
05:51:06 <Leif_Bork> merijn: Aah, oki
05:51:11 <merijn> It doesn't specialise Integer to Int, though. Since it can't know whether Int is big enough or not
05:51:35 <merijn> Oh, no time to explain the dictionary inlining, have to run. Maybe someone else can explain for me :p
05:52:02 <Leif_Bork> Okay, see you! Thanks!
05:53:46 <quicksilver> the short answer is yes.
05:53:55 <quicksilver> inlined functions will specialise
05:54:03 <quicksilver> if they are inlined into a monomorphic context.
06:02:20 * hackagebot DSH 0.8.1.0 - Database Supported Haskell  http://hackage.haskell.org/package/DSH-0.8.1.0 (GeorgeGiorgidze)
06:11:01 <klr> i figured it out last night :D, well, not the math stuff, but the examples ..
06:12:10 <cornihilio> should I be working with bytestrings if I am going to be working with/storing all valid hex valus?
06:12:18 <cornihilio> values*
06:12:23 <cornihilio> or should I be using Data.Binary?
06:16:40 <cornihilio> or is that an incredibly stupid question?
06:21:08 <snhmib> cornihilio: it's a bit like saying "should i use integers for decimal values?"
06:22:08 <dropdrive> Does anyone know if the code from Augustsspn's "Making EDSLs Fly" talk is posted?
06:22:55 <Bagus> good night
06:24:32 <cornihilio> well in my mind, a bytestring is just for storing/looking at hex values
06:24:36 <snhmib> cornihilio: use bytestrings if you want untranslated byte thingies as your data..
06:24:40 <cornihilio> why should I assume data be lost?
06:25:20 <snhmib> bytestrings are for storing bytes, just because a byte maps good to 2 hex digits doesn't make them related
06:26:31 <absence> cornihilio: Data.Binary is for parsing binary data stored in bytestrings
06:26:34 <absence> or the other way
06:27:01 <absence> cornihilio: so you might want to use both :)
06:28:58 <Attic> Does Microsoft have any connection to Haskell? Or do a few of the top Haskell developers work at Microsoft Research for themselves?
06:31:56 <typoclass> Attic: yes, afaik simon marlow and simon peyton jones work at ms research (two top ghc compiler guys). and no, microsoft has no special connection to haskell as far as i know
06:32:20 <ppseafield> Attic: http://research.microsoft.com/en-us/people/simonmar/ and http://research.microsoft.com/en-us/people/simonpj/
06:32:47 <Attic> Hmm I see, I wouldn't really like it if Microsoft took over Haskell lol. But since they don't really have a connection that wouldn't be the case I think
06:33:42 <ppseafield> Attic: IIRC they tried to port haskell to .NET/CIL but because of the difficulty eventually opted to create F# based on OCaml
06:33:46 <osfameron> it's funded some research into haskell hasn't it?
06:34:38 <ppseafield> plus some stuff that haskell has done has made it into F# (like workflows)
06:35:25 <typoclass> well, ghc is released under a bsd license. i guess that's the important thing
06:36:15 <Attic> I guess if it's under BSD right now it'll stay in it's freedom state I guess
06:45:05 <nand`> dmwit: ‘nand a b = not a && not b’ surely you mean ‘not a || not b’?
06:47:27 <Puffton> nand`, or ‘not (a && b)‘ ? ;)
06:48:16 <copumpkin> @djinn Not (a, b) -> Either (Not a) (Not b)
06:48:17 <lambdabot> -- f cannot be realized.
06:48:19 <copumpkin> nope, clearly false
06:48:47 <Eduard_Munteanu> Constructive thinking. :P
06:48:47 <copumpkin> or not true, at least
06:48:55 <copumpkin> I'm known for my constructive criticism
06:49:05 <nand`> copumpkin: haha
06:56:27 <fmap> @djinn Not (Either a b) -> (Not a, Not b)
06:56:28 <lambdabot> f a = (\ b -> a (Left b), \ c -> a (Right c))
06:59:34 <fmap> that feel when I forgot why only one of De Morgan laws is true in constructive logic
07:00:49 <ski> @djinn Not (a, b) -> NotNot (Either (Not a) (Not b))
07:00:49 <lambdabot> f a b = void (b (Right (\ c -> void (b (Left (\ d -> a (d, c)))))))
07:04:12 <copumpkin> fmap: it's easy to remember which one, because it's the only one that produces an Either
07:04:32 <copumpkin> and producing Eithers from polymorphic functions can be tricky :)
07:05:01 <copumpkin> although not impossible, I guess
07:05:08 <Jo__> .
07:05:31 <ski> producing an `Either .. ..' means producing a bit of information
07:05:37 <ion> What’s NotNot?
07:05:40 <copumpkin> Not . Not
07:05:49 <ski> you can't extract any bits of information from `Not ..'
07:05:57 <ion> id?
07:05:57 <copumpkin> damn Nots
07:06:00 <bgamari> Is there any good reason why Haskell doesn't enable you to pattern match against a limited class of expressions (not just constructors; kind of like  defining a data constructor synonym)
07:06:01 <ski> <ski> @djinn-add type NotNot a = Not (Not a)
07:06:05 <copumpkin> ion: only classically
07:06:38 <copumpkin> bgamari: how would it work? it would need to know what is injective and have an easy way of testing it
07:06:43 <bgamari> e.g. If I have, data Sign = Pos | Neg; data Quadrant = Q (Sign,Sign); ne = Q (Pos, Pos);
07:06:51 <bgamari> it would be nice to pattern match against ne
07:07:24 <bgamari> copumpkin, So I suppose the answer is "yes, because it's nontrivial"
07:07:31 <bgamari> a shame
07:07:47 <strebe> hm, are you familiar with guards?
07:07:55 <bgamari> strebe, Sure
07:08:00 <copumpkin> there is generally a notion of pattern synonyms
07:08:05 <copumpkin> I think SHE supports them
07:08:24 <bgamari> but they still aren't as succinct as pattern matching
07:08:31 <bgamari> copton, SHE?
07:08:41 <bgamari> ahh
07:08:48 <ski> @where SHE
07:08:48 <lambdabot> http://personal.cis.strath.ac.uk/~conor/pub/she/
07:09:34 <edwardk> bgamari: you can always use view patterns
07:09:37 <Hylas> @djinn Either a (Not a) -> Either b (Not b)-> Not (a,b) -> (Either (Not a) (Not b))
07:09:37 <lambdabot> f a b c =
07:09:38 <lambdabot>     case a of
07:09:38 <lambdabot>     Left d -> case b of
07:09:38 <lambdabot>               Left e -> void (c (d, e))
07:09:38 <lambdabot>               Right _ -> Right (\ f -> c (d, f))
07:09:40 <lambdabot>     Right g -> Left g
07:09:52 <ski> fmap : the issue is that intuitionistic disjunction is solely additive, while intuitionistic conjunction can be used both additively and multiplicatively
07:10:41 <bgamari> edwardk, Good point; Thanks!
07:11:18 <copumpkin> <ski> blah blah blah. blah blah blah!
07:11:53 <copumpkin> :)
07:12:00 <ski> i'm glad you liked it :)
07:12:05 <ski> @djinn (Either a (Not a) -> Not b) -> Not b
07:12:05 <lambdabot> f a b = void (a (Right (\ c -> a (Left c) b)) b)
07:12:50 <ski> (when proving a negative statement, you can freely assume principle of omniscience)
07:12:53 <Hylas> djinn does your coq homework for you!
07:14:25 <Cale> Trivial.
07:16:21 <Abraxas> in hutton's deduction of fusion he writes: h (g x ( fold g w xs)) = f x (h ( fold g w xs)) <== h (g x y) = f x (h y)
07:16:30 <Abraxas> why is this not an equivalence?
07:17:13 <Abraxas> if anything, i would think the implication is the other way around
07:18:32 <Abraxas> it's on page 5, here: http://eprints.nottingham.ac.uk/224/1/fold.pdf
07:19:14 <Saizan> i assume y is universally quantified in h (g x y) = f x (h y)
07:19:34 <Saizan> if so you can just take y = fold g w xs to derive the conclusion
07:20:59 <Abraxas> but the other way around it's just a replacement of the fold expression with a fresh variable y...and that cannot be implied?
07:21:31 <Saizan> no, because the truth of that equation might depend on the exact value of fold g w xs
07:22:25 * hackagebot hat 2.7.0.1 - The Haskell tracer, generating and viewing Haskell execution traces  http://hackage.haskell.org/package/hat-2.7.0.1 (OlafChitil)
07:22:46 <Saizan> you could derive "exists y. h (g x y) = f x (h y)" from it
07:22:55 <Saizan> but not "forall y. h (g x y) = f x (h y)"
07:23:24 <xterm5443> Hello, I have problem with ¨how to write¨ definition for unary operator with Parsec. I need help how to write :). I will post source.
07:23:36 <Abraxas> so, if i replace the fold term with a variable, i only produce an implication backwards? wasn't aware of that
07:23:36 <hpaste> xterm5443 pasted “[Text.Parsec] Problem with unary operator” at http://hpaste.org/76139
07:23:39 <Abraxas> that's dangerous
07:23:55 <Abraxas> that direction seemed safe to me
07:24:04 <kstt> hello !
07:24:48 <Saizan> Abraxas: it all the depends on the (maybe implicit) quantifiers
07:25:35 <Abraxas> well, if it's true for this function, it doesn't have to be true for any function...that's what the forward implication would say, though
07:25:54 <Abraxas> if i spell it out like that, i can see it
07:26:05 <Abraxas> i turn it around in my head somehow :D
07:26:12 <Saizan> :)
07:26:37 <bgamari> Here is the proposal for pattern synonyms in ghc, http://hackage.haskell.org/trac/ghc/ticket/5144#comment:7
07:27:24 <mapf`> xterm5443: uop = Neg <$> spaced (string "~" >> someexpr)
07:27:35 <mapf`> xterm5443: nope?
07:28:21 <xterm5443> mapf: Thank you. I try your suggestion.
07:29:54 <mapf`> xterm5443: well, you would like to write type annotations on top-level else you got "WTF WTF WTF!!"
07:30:37 <xterm5443> I know but I would like to minimalistic code :).
07:32:44 <doomlord> which editor/ide  has the best haskell support available at the minute
07:32:49 <mapf`> so type mismatch is because you "return (Neg)" but i guess you want   "return (Neg subexpr)"
07:33:54 <Cale> bgamari: I think I like this proposal, at least, if used tastefully, it could be very nice. :)
07:34:44 <Cale> (Abuses could get pretty scary, but that's already true of most Haskell features :)
07:35:23 <merijn> What's the "proper" etiquette for hijacking someone's package on Hackage? :p
07:35:38 <Cale> merijn: Don't be a dick?
07:35:57 <Cale> merijn: I guess sending them an email would be a good first step.
07:36:09 <merijn> i.e some guy is maintaining a package I need/want to extend modify and he's not very responsive so I'm thinking of just forking him and uploading my own version until he responds
07:36:23 <Cale> I say go for it.
07:36:40 <merijn> Cale: Well, I send him an e-mail a couple days ago, but I don't plan to be blocked by him not responding
07:36:54 <merijn> It just means I need to figure out where to put it in the module namespace
07:37:06 <merijn> I suspect using the same module name will break things?
07:37:19 <xterm5443> mapf: Are you sure that ¨uop¨ definition is wrong? I think that its ok ... but I think that problem is in ¨expr1¨ and ¨chainl1¨ (¨chainl1¨ is only for binary operators...?)
07:37:42 <Cale> merijn: You can define the same module in multiple packages.
07:38:14 <Cale> merijn: It makes things hard for people who want both, but there is source-level syntax for disambiguating which package you want.
07:38:44 <merijn> Cale: Well, it seems unlikely you want multiple bindings for the same networking library in one program ;)
07:39:05 <merijn> So if using the same names doesn't break anything I'll just reuse the module names
07:39:15 <Cale> yeah, might as well
07:40:42 <quicksilver> I think using the same module names is quite sensible if it's intended to be a drop-in replacement
07:40:45 <quicksilver> or nearly so
07:42:39 <shapr> doomlord: I'm fond of emacs, some like vim, but I've heard eclipse has some nice Haskell support as well. Do you prefer any one editor?
07:42:45 <mapf`> xterm5443: backtracking for binary operators will fail. but unary operators we can parse just as you parse Var
07:44:05 <doomlord> i'm trying delving into emacs at the minute; i've never enjoyed vim. usually for c++ i use  visual-studio or other gui ide
07:44:54 <merijn> quicksilver: Well, I want to add some missing bindings, provide a monad transformer interface, add some type family convenience stuff, that sorta thing.
07:45:26 <merijn> Speaking of which, is it possible to conditionally expose modules? i.e. based on whether compiler versions support them?
07:45:36 <ski>   pattern viewPat (f :: a -> b) :: b -> a
07:45:36 <ski>   pattern viewPat f y = (f -> y)
07:45:47 <doomlord> does the emacs haskell integration support jumping to symbol definitions ;
07:45:51 <ski> might be a way to pass expressions to pattern synonyms
07:46:14 <Hylas> doomlord, yes, ghci can create TAGS tables and
07:46:20 <Hylas> -and
07:48:19 <kstt> I am diving into the foul world of ms windows. That's truely painful. I managed to install HP 2012.2, yeah. I also managed to install cabal-dev, through MinGW/MSYS, yeah yeah ! My warp-based HTTP application builds fine but does not run properly, with the following error : "threadWaitRead requires -threaded on Windows, or use System.IO.hWaitForInput."
07:49:02 <kstt> compiling with -threaded suppresses the message, but the app still does not reply to requests. Is there a known issue on windows with this kind of application please ?
07:49:34 <quuuux> is it accepting connections at all?
07:50:02 <mapf`> Hylas: it is possible to get TAGS without any  module check and sort of things?
07:50:03 <kstt> how to know ? It does not look to accept anything
07:50:10 <quuuux> telnet localhost -p 80
07:50:20 <quuuux> see if that fails immediately
07:50:55 <mapf`> for exsample i need just positions of top level-functions
07:51:42 <mapf`> :etags in ghci do imported module cheking
07:51:51 <Hylas> mapf`, I don't know.
07:52:17 <shapr> tags does a module check? huh?
07:52:26 <kstt> quuuux: yes, it does accept connections
07:52:33 <kstt> but then nothing happens
07:52:36 <mapf`> shapr: nope, ghci does
07:52:42 <Cale> kstt: Maybe try hand-typing an HTTP request?
07:53:22 <kstt> Cale: thanks. Any idea about the threadWaitRead error ?
07:53:29 <Cale> (though something like Chrome's dev tools will also show you all the guts of the requests that it makes)
07:53:29 <shapr> mapf`: I don't understand, what module check?
07:53:52 <Cale> Well, the solution there is just to build with -threaded
07:54:06 <Cale> I think that whatever remaining problem you have is separate
07:54:17 <mapf`> shapr: if i import HAHAHA in module Test and "$ echo ":etags" | ghci -v0 test.hs" it says can't find such module HAHAHA
07:55:50 <mapf`> actually i need a reliable method to extract SCC annotations
07:56:11 <mapf`> but it seems to be problematic
07:57:03 <ClaudiusMaximus> mapf`: https://gitorious.org/prof2pretty/prof2pretty/blobs/master/src/sccpragmabomb.hs
07:57:22 <kstt> Cale: once built with -threaded, I can type in the telnet client, but 1) there is no echo (don't know if it is normal for windows telnet) and 2) nothing comes back from the server
07:57:29 <donri> dreixel: i don't quite understand how to use conName, specifically what to pass as an argument?
07:58:12 <ClaudiusMaximus> mapf`: that program essentially strips all SCC pragmas, and adds new ones all over the place
07:59:19 <ClaudiusMaximus> mapf`: there's a monadic version of transformBi iirc, that you could use to collate your required info
07:59:50 <kstt> oh, there was a recent change there
08:00:07 <kstt> I'll try to use an other release of warp to see if that helps
08:00:34 <ClaudiusMaximus> mapf`: http://hackage.haskell.org/packages/archive/uniplate/latest/doc/html/Data-Generics-Uniplate-Operations.html#v:transformBiM
08:01:06 <doomlord> is it "hstags" that generates the tags file ... i dont appear to have it; .. where does one get it
08:01:44 <Leif_Bork> What are the reasons that one should use IntMap instead of the unordered containers hashmaps for integer keys?
08:02:35 <quicksilver> better sharing
08:02:40 <quicksilver> I think.
08:02:55 <Puffton> In which cases cannot foldl' be used, and only foldl works?
08:02:57 <quicksilver> you modify an IntMap slightly most of it is shared with the old version.
08:03:10 <solarus> doomlord: I believe you can do it from ghci
08:03:12 <quicksilver> good for undo history etc
08:03:38 <ClaudiusMaximus> doomlord: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-commands.html ":ctags filename / :etags filename"  with "all modules must be interpreted" caveat
08:03:59 <mapf`> ClaudiusMaximus: i don't know what is Generics
08:04:08 <doomlord> thanks
08:04:38 <dreixel> donri: a C thing
08:04:51 <ClaudiusMaximus> mapf`: a library to make traversing / manipulating large data structures really easy
08:05:01 <dreixel> donri: so it's to be used while defining generic functions. Alternatively, you can use conNames: http://hackage.haskell.org/packages/archive/generic-deriving/1.2.2/doc/html/Generics-Deriving-ConNames.html
08:05:07 <ClaudiusMaximus> mapf`: i don't know how it works, but it's clever
08:05:36 <klr> eh, cabal is a build system, but cabal-install is a package manager, am i correct? why doesn't it have remove/uninstall if so...
08:05:40 <donri> dreixel: but where do I get the C from? the C type is in M1 but not as a value
08:06:41 <mapf`> ClaudiusMaximus: how sccpragmabomb adds pragmas?
08:07:51 <mapf`> ah
08:08:06 <ClaudiusMaximus> mapf`: it calls a magic generics thingy that applies a function on all appropriate nodes in the syntax tree
08:08:27 <quuuux> klr: sort of. 'ghc-pkg hide' and 'ghc-pkg unregister' may be of interest to you
08:08:31 <ClaudiusMaximus> mapf`: the function i pass it strips all existing SCC and replaces them with one based on source code location
08:10:13 <quuuux> klr: the answer to your actual question is that ghc maintains a package database itself, cabal is a build/installation system, and cabal-install makes installing packages + their dependencies easier
08:11:01 <klr> quuuux: okey, hmm, i may be trying to code cabal-remove when i've learned more haskell when :D
08:11:21 <hpaste> donri pasted “dreixel: conName” at http://hpaste.org/76140
08:12:52 <Leif_Bork> quicksilver: Thanks
08:12:59 <mapf`> i'll try it. but what is sense to use sccpragmabomb?
08:13:26 <mapf`> so why we can't just -auto-all of -caf-all of something
08:15:31 <mapf`> hm, i understand now. but i can't to force user to pass some args to ghc unfortunately. i need to think about it
08:16:25 <mapf`> ClaudiusMaximus: thanks, i'll try it
08:16:35 <dreixel> donri: conName (M1 x) should work, I think
08:16:42 <dreixel> you will need a Constructor constraint, though
08:16:44 <ceezer> hello, how can you check what symbols such as <$> mean in haskell syntax?
08:17:10 <S11001001> @hoogle (<$>)
08:17:11 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
08:17:11 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
08:17:36 <S11001001> ceezer: symbols are just names for ordinary functions/values in haskell
08:17:44 <ClaudiusMaximus> mapf`: i just gave it as a simple example of parsing haskell and traversing syntax tree for SCC pragmas (but I'm not sure what you need to do)
08:17:47 <doomlord> using ghci, on attempting to build tags (:etags) it keeps telling me "one of my modules is not interpreted" ... what could cause that; does ghci only support a subset of the compiled syntax or something
08:18:08 <S11001001> ceezer: search them in hoogle just as you would a function with an ordinary name; the main trick is to wrap in parens as I have done above
08:18:22 <S11001001> ceezer: you can also check your REPL exactly like this:
08:18:23 <ClaudiusMaximus> doomlord: ghci uses any existing .hi/.o files if they exist
08:18:26 <fmap> @hoogle <$>
08:18:26 <S11001001> :t (<$>)
08:18:27 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
08:18:27 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
08:18:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:18:36 <donri> dreixel: hm, where does the constraint go?
08:18:38 <S11001001> fmap: oh, I didn't know
08:18:40 <otters> Data.Functor and Control.Applicative? huh?
08:18:41 <doomlord> ok i'll rebuild..
08:18:48 <S11001001> otters: reexport
08:18:49 <ClaudiusMaximus> doomlord: no, you should clean
08:18:56 <ClaudiusMaximus> doomlord: or force interpreted mode
08:18:57 <otters> S11001001: why is one Data and one is Control
08:18:59 <otters> dat don't make sense
08:19:21 <n-dolio> "Data" and "Control" are meaningless, anyway.
08:19:36 <ceezer> S11001001: Excellent. Exactly what I was looking for.
08:19:37 <otters> yeah
08:19:47 <n-dolio> Just places to throw things because people only want like 7 top-level name spaces for some reason.
08:19:47 <quicksilver> all words are meaningless
08:19:55 <monochrom> Control.Maybe and Data.Monad.Writer :)
08:20:16 <donri> dreixel: nevermind
08:20:20 <dreixel> donri: on that instance
08:20:21 <doomlord> ah sucess, thanks
08:20:24 <dreixel> but GHC should tell you
08:20:35 * monochrom has a cunning plan!
08:20:42 <monochrom> Data.Functor and Spock.Monad :)
08:20:48 <quicksilver> I think Data and Control *do* mean something, it's just there is no sensible way of deciding between them. haskell data structures *are* control structures.
08:20:51 <ClaudiusMaximus> doomlord: hooray
08:21:08 <donri> seems to have done it: instance (GPathInfo a, Constructor c) => GPathInfo (C1 c a) where
08:21:15 <donri> thanks :)
08:23:30 <mapf`> ClaudiusMaximus: well, i have a report and some sources but maybe not all, and maybe sources not correct at all (e.g. not typecheck, maybe even not correct syntax). my task is find in all sources all positions of records from report in source files
08:23:47 <dreixel> donri: looks good
08:24:26 <donri> now to figure out gfrom... where I need to do the inverse... o_O
08:24:38 <ClaudiusMaximus> mapf`: ok - then i'd use basic text search tools
08:24:50 <mapf`> i won't restrict user at all
08:25:31 <mysticc> @hoogle astypeof
08:25:31 <lambdabot> Prelude asTypeOf :: a -> a -> a
08:26:03 <mapf`> ClaudiusMaximus: so just exstract "basename" from cost centre name and search by regexp "^basename" lol
08:26:20 <donri> dreixel: any pointers? hm is this even possible? selecting a constructor by name at runtime (a la Read)
08:27:24 <mapf`> it will work acceptable but some comments may break it
08:27:30 <ClaudiusMaximus> mapf`: yeah, maybe using http://hackage.haskell.org/package/matchers or similar
08:28:18 <ClaudiusMaximus> (well, that one is undocumented, so maybe pick one that has documentation)
08:28:27 <quuuux> hmm. Porting code to use Data.Text has made some modules take aeons to compile
08:28:32 <mapf`> ClaudiusMaximus: i do it in elisp ^_^
08:30:11 <klr>  may i ask why ghc is so huge? is it just me that got completly wrong info or is really ghc 61 mb compressed and gcc only 18 mb(exaclty same compression ofc) ?
08:30:47 <donri> statically link *all* the things!
08:31:00 <ClaudiusMaximus> klr: 3 versions of libraries (normal, profiling, shared), if you're talking binaries - if you're talking source, then i dunno
08:31:43 <klr> ClaudiusMaximus: okey, doesn't really matter, i have only 1 game and linux kernel taking up disk space :)
08:31:44 <strebe> http://ftp.gnu.org/gnu/gcc/gcc-4.7.2/ - gcc is a lot bigger than that, more like 102M for the .tar.gz of this particular version
08:32:00 <klr> strebe: binaries, not src
08:32:04 <strebe> ahh
08:33:54 <quuuux> does GCC dynamically link a lot of its stuff?
08:34:03 <dreixel> donri: I'm not entirely sure about what you're trying to do, but generic read is certainly possible
08:35:19 <klr> what's the difference between staticly and dynamic linking?
08:36:22 <ClaudiusMaximus> klr: putting it all in one executable file (static) or making the executable refer to shared libraries that multiple executables can use (dynamic)
08:36:32 <justicefries> what's the most recommended haskell book rihgt now?
08:36:53 <Clint> lyah
08:37:21 <strebe> justicefries: I don't know, but I certainly like "Real World Haskell". Have you done functional programming before? If not, Clint's suggestion of "Learn you a haskell" might be a good idea
08:37:27 <justicefries> i have.
08:37:28 * hackagebot yesod-pure 0.1.0.0 - Yesod in pure Haskell: no Template Haskell or QuasiQuotes  http://hackage.haskell.org/package/yesod-pure-0.1.0.0 (MichaelSnoyman)
08:37:36 <klr> ClaudiusMaximus: okey, dynamic seem better, but many people say it's bad and they only made it in solaris(which it was introduced?) due to the demand, not effectiveness
08:38:07 <strebe> justicefries: http://book.realworldhaskell.org/read/
08:38:18 <ClaudiusMaximus> klr: static is bloaty but convenient for sending random people binaries that'll "just work" without package managers, dynamic is arguably better for package maintainance sanity and security reasons (you can upgrade fixed libraries independently from however many programs use it)
08:38:59 <Botje> klr: dynamic also allows your OS to share several instances of the same library in the same memory space
08:39:13 <klr> ClaudiusMaximus: this is what some unix/plan9 hackers say about dynamic linking: http://harmful.cat-v.org/software/dynamic-linking/
08:39:17 <justicefries> awesome, thanks.
08:39:21 <companion_cube> but everything being linked dynamically against libc makes systems fragile :/
08:39:22 <klr> okey
08:39:51 <ClaudiusMaximus> klr: this is a bit off topic for this channel, though, unless you have something to say about linking policies in haskell context :)
08:40:23 <klr> ClaudiusMaximus: oh, sry, i dont wanna start flame war! ignore what i sent :)
08:40:35 <klr> i dont even know which better/worse xd
08:40:53 <ClaudiusMaximus> just don't mention LGPL and you should be fine
08:40:59 * ClaudiusMaximus runs away
08:41:01 <klr> ClaudiusMaximus: okey
08:41:08 <klr> lgpl(kidding :P )
08:52:29 * hackagebot dates 0.2.1.0 - Small library for parsing different dates formats.  http://hackage.haskell.org/package/dates-0.2.1.0 (IlyaPortnov)
08:57:40 <afiqius> hello
08:58:04 <afiqius> Why should I learn Haskell?
08:58:26 <shachaf> You shouldn't.
08:58:38 * shachaf not a moralist.
08:58:42 <shachaf> @where faq
08:58:42 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
08:58:44 <osfameron> you should only learn something if you want to learn it
08:58:54 <osfameron> or if your boss is telling you to learn it
08:59:40 <afiqius> I want to learn it, but I haven't enough reasons to conclude my question, so I thought of asking around
09:00:04 <byorgey> afiqius: because it will reveal another tiny fraction of the universe's mysteries.
09:00:26 <byorgey> afiqius: the real answer depends on what motivates you, of course.
09:00:30 <afiqius> so why do you learn Haskell anyway?
09:00:34 <quicksilver> because it will grant you transcendantal peace
09:00:38 <quicksilver> and, also, the ability to fly.
09:00:42 <afiqius> byorgey, like your answer
09:00:46 <quuuux> I thought that was Python
09:00:49 <shachaf> osfameron: What if my boss is telling me to want to learn it?
09:00:53 <monochrom> I learned haskell because I wanted to. no more reason necessary.
09:01:11 <hvr> monochrom: but why did you want to? ;)
09:01:18 <afiqius> I want to, but it seems that I don't desire it enough...
09:01:24 <monochrom> I don't know about you, so I can't give you an advice. upload your brain for a FREE analysis.
09:01:26 <khourne> Can't we reach nirvana with haskell?
09:01:31 <byorgey> afiqius: my first answer was actually serious. =)  Haskell is quite mind-blowing.
09:01:47 <osfameron> shachaf: then you could just smile and nod and pretend?
09:02:29 * hackagebot rdtsc-enolan 0.1 - Binding to sources of high-efficiency, high-precision, monotonically  increasing relative time.  http://hackage.haskell.org/package/rdtsc-enolan-0.1 (EchoNolan)
09:02:52 <afiqius> byorgey: yes, but your answer is more like an invitation to enter the Haskell world. I don't think there is any objective answer to how it could really disclose the world's mystery
09:03:27 <shachaf> @google t0rch why learn haskell
09:03:28 <lambdabot> http://ugcs.net/~keegan/talks/why-learn-haskell/talk.pdf
09:03:28 <lambdabot> Title: Why learn Haskell?
09:03:31 <shachaf> afiqius: There's that.
09:03:37 <shachaf> And there's the FAQ I linked to -- did you read it?
09:03:55 <afiqius> perhaps, I just should start putting my hands on it and see how it 'feels'
09:04:04 <Boreeas> It is also great for codegolf
09:04:04 <shachaf> People come into this channel quite a lot asking this same question, so it might be worth it looking up what answers it's gotten before.
09:04:17 <afiqius> I'll read it. Thanks lambadot and shachaf
09:04:34 <lambdabot> afiqius: no problem
09:05:11 <afiqius> thanks for your time, all
09:05:20 <afiqius> have a nice day. =)
09:06:34 <kdridi> hi
09:06:48 <hpaste> narens pasted “Injectivity problem” at http://hpaste.org/76144
09:07:07 <narens> Question: I have a question I've just posted
09:07:29 * hackagebot exception-transformers 0.3.0.3 - Type classes and monads for unchecked extensible exceptions.  http://hackage.haskell.org/package/exception-transformers-0.3.0.3 (GeoffreyMainland)
09:07:31 * hackagebot warp 1.3.3.3 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.3.3 (MichaelSnoyman)
09:08:18 <Boreeas> Oh god, Map.insert returns a new map every time? That's horribly inefficient
09:08:32 <bitonic> Boreeas: no
09:08:44 <Saizan> narens: something like "empty :: Proxy m -> Event m -> Bool" is possible
09:08:45 <bitonic> or was that a joke?
09:09:00 <hvr> Boreeas: see /persistent data-structures/
09:09:01 <Saizan> narens: given data Proxy (m :: * -> *) = Proxy
09:09:05 <Boreeas> bitonic: A quote from "Learn you a haskell", actually
09:09:11 <Boreeas> "insert takes a key, a value and a map and returns a new map that's just like the old one, only with the key and value inserted."
09:09:16 <narens> Saizan: ooo.. so add a phantom argument?
09:09:21 <Boreeas> hvr: Thanks
09:09:28 <Saizan> narens: yeah
09:09:38 <bitonic> Boreeas: read up on what hvr said and sharing
09:09:41 <narens> Saizan: but what do I pass to it?
09:10:56 <Saizan> narens: (Proxy :: Proxy m), with the right m, in the case of func you'll have to use ScopedTypeVariables
09:11:03 <ski> Boreeas : because of immutability, most of the old map can be shared with the new one
09:11:05 <Saizan> narens: another options is to use tagged
09:11:15 <Saizan> narens: from hackage
09:11:23 <hvr> Boreeas: and fwiw, Clojure also uses persistent-datastructures, you might find some talk by Hickey explaining how they are implemetned in Clojure
09:11:25 <narens> Saizan: Sorry, i'm unfamiliar with these... can you provide a link please?
09:11:53 <Saizan> narens: look into the language extensions in the GHC manual
09:12:30 * hackagebot exception-mtl 0.3.0.3 - Exception monad transformer instances for mtl2 classes.  http://hackage.haskell.org/package/exception-mtl-0.3.0.3 (GeoffreyMainland)
09:12:31 <jix> Boreeas: basically everything that did not change in the map is using the same memory for both maps... so it is neither using more memory than needed nor processing/copying/whatever more data than needed
09:13:26 <Saizan> you'd need less if you didn't have to keep the old map potentially accessible
09:13:27 <Boreeas> Ah, that's handy
09:13:59 <jamy23> Hello! Is there a similar command as "sleep" in haskell?
09:14:15 <ClaudiusMaximus> @hoogle delay
09:14:15 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
09:14:16 <lambdabot> GHC.Conc.IO threadDelay :: Int -> IO ()
09:14:16 <lambdabot> GHC.Conc threadDelay :: Int -> IO ()
09:14:29 <ski> Boreeas : in case things were mutable, one'd have to copy everything just in case someone changes the original parts behind our back (even if that's not that common) -- with immutability, we know this can't happen, so it's safe to share
09:14:46 <ClaudiusMaximus> jamy23: note it uses different units, so multiply by 1000 a few times if you think it doesn't do anything
09:15:04 <jamy23> without monads
09:15:19 <ski> jamy23 : no
09:15:59 <ski> (there couldn't be one)
09:16:02 <Lammer> Pblw Pblw
09:16:12 <ClaudiusMaximus> > last [1..10000000] `seq` "sleep"
09:16:16 <lambdabot>   mueval-core: Time limit exceeded
09:16:53 <ClaudiusMaximus> (note that uses CPU time evaluating stuff, instead of sleeping idly)
09:17:02 * ski passes ClaudiusMaximus through a spinlock
09:17:07 <ClaudiusMaximus> ouch!
09:19:41 <jamy23> If I correctly understood, to get a sleep, you need to get the CPU to consider somewhat  unnecessary?
09:22:08 <jix> jamy23: can you explain why you would need to sleep outside of the IO monad?
09:22:31 * hackagebot exception-monads-tf 0.3.0.2 - Exception monad transformer instances for monads-tf classes.  http://hackage.haskell.org/package/exception-monads-tf-0.3.0.2 (GeoffreyMainland)
09:22:33 * hackagebot ref-fd 0.3.0.3 - A type class for monads with references using functional  dependencies.  http://hackage.haskell.org/package/ref-fd-0.3.0.3 (GeoffreyMainland)
09:22:41 <Abraxas> is there a pattern that you can intuitively recognize whenever the tuple rule for folds has to be used? or is it trial-and-error?
09:22:54 <ski> jamy23 : to delay the I/O interaction with the rest of the computer, you need to specify where in the "list" of I/O interactions you want this delay to happen
09:23:44 <Abraxas> when transforming a function into a fold and it's only possible via the tuple rule, i mean
09:24:43 <jix> the only valid reason I can think of to sleep without IO (think of a sleeping id function) would be a debugging hack to get a feeling for the performance impact of some pure function
09:25:35 <jamy23> And if i am want that one function evaluating always after some other function
09:26:18 <Abraxas> in each case that needs more than one part of something to be stored
09:26:55 <jix> jamy23: also you shouldn't be able to observe the difference in evaluation order unless you're doing something else unsafe
09:27:00 <ClaudiusMaximus> Abraxas: tuple rule?
09:27:31 * hackagebot ref-tf 0.3.0.2 - A type class for monads with references using type families.  http://hackage.haskell.org/package/ref-tf-0.3.0.2 (GeoffreyMainland)
09:27:34 * hackagebot gray-code 0.2.2 - Gray code encoder/decoder.  http://hackage.haskell.org/package/gray-code-0.2.2 (SergeyAstanin)
09:27:36 <rwbarton> if you "want that one function evaluating always after some other function" (why?) then a sleep is not going to guarantee it
09:28:16 <Abraxas> page 8 of hutton's paper on folds: http://eprints.nottingham.ac.uk/224/1/fold.pdf
09:29:04 <Abraxas> the problem with a simple transformation is that variables end up unbound
09:30:07 <narens> Saizan: It its not too much trouble could I press you for an example of how to use this Proxy thing? I can't seem to figure it out
09:30:07 <monochrom> how do you even observe "evaluate e1 after e0" as opposed to "evaluate e0 after e1"?
09:30:16 <jamy23> If repeat delay until work condition, then guarantees
09:31:56 <rwbarton> are you using threads?
09:32:04 <rwbarton> by "evaluate a function" do you mean execute an IO action?
09:32:07 <ClaudiusMaximus> Abraxas: i get error 500 internal server error
09:32:17 <rwbarton> why not just use a synchronization mechanism?
09:32:22 <ClaudiusMaximus> Abraxas: maybe i need to be in nottingham intranet..
09:32:25 <rwbarton> how do you know whether "work condition" anyways?
09:32:51 <Abraxas> no, i am not in that intranet
09:32:55 <Abraxas> hm
09:32:58 <ClaudiusMaximus> Abraxas: ah, works with wget
09:33:57 <Abraxas> section 4
09:35:14 <hpaste> Saizan annotated “Injectivity problem” with “Injectivity problem (annotation)” at http://hpaste.org/76144#a76147
09:35:29 <Saizan> narens: ^^^
09:35:43 <ClaudiusMaximus> Abraxas: ok - i tend to do that kind of thing in practice with Monoid and mconcat to do one pass processing instead of multiple passes over potentially long lists (which tends to keep them in memory unnecessarily)
09:36:07 <ClaudiusMaximus> @src mconcat
09:36:07 <lambdabot> Source not found. Sorry.
09:36:25 <ClaudiusMaximus> mconcat = foldr mempty mappend -- probably
09:36:29 <jamy23> I did what you said about IO. I say without monads. I dont need output or input anything. I only need stop evaluating function for a while condition is false
09:36:31 <notdan> Hey guys
09:36:36 <narens> Saizan: brilliant! thanks... why does this work?
09:36:52 <notdan> What is the recommended way for upgrading cabal-install if I am using Haskell platform?
09:37:03 <rwbarton> jamy23: what is the condition
09:37:15 <notdan> I've installed it locally, in my user dir, but there is still cabal in /usr/local/bin
09:37:27 <ClaudiusMaximus> Abraxas: but maybe someone else has more interesting thoughts
09:37:35 <Saizan> narens: Proxy is a type constructor so it's injective
09:37:57 <jamy23> while(foo == boo) sleep
09:38:08 <rwbarton> are you sure you are writing a Haskell program?
09:38:21 <narens> Saizan :: So, this is what the Proxy in the tagged package does?
09:38:44 <rwbarton> if you're not in IO how can the condition ever change.....
09:38:54 <jamy23> i am just starting...
09:39:09 <Saizan> narens: yeah
09:39:33 <narens> Saizan: thanks a bunch!
09:40:19 <jamy23> rwbarton: by the reference
09:40:59 <rwbarton> like IORef?
09:41:05 <jamy23> yep
09:41:14 <rwbarton> but... you need to be in IO to read an IORef
09:41:18 <rwbarton> so...
09:41:23 <Abraxas> ClaudiusMaximus: you mean, mconcat implies the use of this rule? for instance
09:41:26 <ClaudiusMaximus> jamy23: main = newEmptyMVar >>= \done -> forkIO (someStuff >> putMVar done ()) >> forkIO (otherStuff >> putMVar done ()) >> takeMVar done  -- the main thread waits until the first (temporally) stuff finishes, and then exits ungracefully
09:41:34 <ClaudiusMaximus> @instances Monoid
09:41:34 <rwbarton> if foo and boo are IORefs than "foo == boo" tests if foo and boo are the SAME IORef
09:41:34 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
09:41:41 <rwbarton> which can never change
09:42:32 * hackagebot network 2.3.2.0 - Low-level networking interface  http://hackage.haskell.org/package/network-2.3.2.0 (JohanTibell)
09:42:40 <ClaudiusMaximus> > mconcat . map (\x -> (Sum x, Product x)) $ [1..10]
09:42:42 <lambdabot>   (Sum {getSum = 55},Product {getProduct = 3628800})
09:43:26 <ClaudiusMaximus> > mconcat . map (\x -> (Sum x, Product x, Last x)) $ [1..10]
09:43:27 <lambdabot>   No instances for (GHC.Num.Num (Data.Maybe.Maybe a),
09:43:27 <lambdabot>                    GHC....
09:43:32 <ClaudiusMaximus> > mconcat . map (\x -> (Sum x, Product x, Last (Just x))) $ [1..10]
09:43:34 <lambdabot>   (Sum {getSum = 55},Product {getProduct = 3628800},Last {getLast = Just 10})
09:43:43 <ClaudiusMaximus> etc
09:44:40 <ClaudiusMaximus> Abraxas: but the paper seems to be about theory, whereas i'm more practical...
09:46:04 <Abraxas> yeah
09:47:00 <Abraxas> i thought the reason you need the rule for transforming dropwhile into fold is because you need to keep track of two lists at once, one of them recursively
09:47:25 <Abraxas> so you need the reference to the non-recursive list, that is, the tail
09:48:04 <Abraxas> but not sure i am not talking nonsense :D
09:48:24 <Abraxas> i stared at this for a while and i start to confuse myself
09:48:42 <jamy23> Ok. Forexample: If i am has a function which if got argument = "True" then nothing to do 1 sec and then call some other function, else if they got argument = false then call some other function immediately?
09:48:44 <monochrom> rwbarton: I'm wondering which one closes the case faster: "I don't understand the question", or, "use unsafePerformIO" :)
09:50:20 <ClaudiusMaximus> Abraxas: i'd start by looking at the summary result on page 9 and work backwards, because i like to know where i want to get to when i start out on a journey (and i know where i am)
09:50:49 <ClaudiusMaximus> but that's just my way of thinking
09:51:38 <mcstar> is there a way to 'override' and instance declaration for a type?
09:52:02 <Abraxas> i usually do it that way, too
09:52:29 <mcstar> i.e. Set is a member of Eq,Ord, and in my code, i want different behavior when i compare Sets
09:52:32 * hackagebot network 2.3.1.1 - Low-level networking interface  http://hackage.haskell.org/package/network-2.3.1.1 (JohanTibell)
09:52:34 * hackagebot srcloc 0.3.0 - Data types for managing source code locations.  http://hackage.haskell.org/package/srcloc-0.3.0 (GeoffreyMainland)
09:52:51 <ClaudiusMaximus> mcstar: you mean like instance Baz a => Foo a where foo = genericFoo ; instance Foo Int where foo = intFoo  -- then no
09:52:59 <ski> Abraxas : `dropWhile' is a paramorphism
09:53:01 <monochrom> can't override. look for a workaround
09:53:10 <ClaudiusMaximus> newtype!
09:53:22 <Abraxas> i work from the top and the bottom until the parts in the middle either end up being the same or i try to get them to be the same as a next step
09:53:27 <jamy23> me who is responsible?
09:53:27 <mcstar> but with newtype, i cant use those handy functions that come with Set
09:53:28 <monochrom> yeah newtype is one way. another way is just don't use == and >=
09:53:56 <mcstar> monochrom: but, i want that set put into a priority queue
09:53:57 <ClaudiusMaximus> there's a newtype package iirc, that makes it easier to do the wrapping/unwrapping
09:54:05 <mcstar> now the queue, uses Eq and Ord
09:54:11 <ski> hm, `Set a' is in `Ord' ?
09:54:14 <Abraxas> "eats its argument and keeps it too" heh
09:54:26 <mcstar> ski: you can compare sets, yes
09:54:30 <Abraxas> this could be connected to what i was just thinking about
09:54:36 <ski> mcstar : yeah, but which order does it use ?
09:54:51 <mcstar> ski: compares elements in ascending order
09:54:55 <monochrom> then it's newtype
09:54:58 <ClaudiusMaximus> > compare (S.fromList "hello") (S.fromList "world")
09:54:59 <lambdabot>   GT
09:55:39 <ClaudiusMaximus> > comparing (nub . sort) "hello" "world"
09:55:41 <lambdabot>   GT
09:55:42 <ski> mcstar : there's at least three common partial orders on (sub)sets -- i'm not sure about total orders, though
09:55:43 <mcstar> i want my comparison to be based on the size of the set
09:55:54 <Abraxas> i mean, the simple transformation into fold is always like this: you get the step of the recursive definition and the corresponding one from the universal transformation
09:55:58 <ClaudiusMaximus> > comparing length "hello" "world"
09:55:59 <lambdabot>   EQ
09:56:12 <ski> (mcstar : "compares elements in ascending order" doesn't tell me anything)
09:56:23 <mcstar> ClaudiusMaximus: the priority queue doesnt take a comparison function
09:56:30 <Abraxas> then use the definition of the function to transform and generalise the parts on both sides of the equation
09:56:31 <mcstar> maybe i should use one, that does
09:56:43 <rwbarton> it's just the normal ord on toList I think
09:56:53 <jamy23> If i am has a function which if got argument = "True" then nothing to do 1 sec and then call some other function, else if they got argument = false then call some other function immediately?
09:57:01 <Abraxas> and during generalisation the variable you need later on is "eaten" by the replacement
09:57:03 <ski> > sortBy (comparing length `mappend` compare) (words "The quick brown fox jumps over the lazy dog")
09:57:04 <lambdabot>   ["The","dog","fox","the","lazy","over","brown","jumps","quick"]
09:57:14 <mcstar> ski: flatten the sets to ascending lists, now compare those element by element
09:57:22 <Abraxas> so you have to carry it around in a separate parameter
09:57:24 <ski> using lexicographic ordering ?
09:57:40 <Abraxas> does that sound right?
09:58:05 <strebe> I keep running into a very basic thing which confuses me. In ghci, I do something like "import Data.Map as M", M.fromList seems to work, and then when I try M.mergeWith I getFailed to load interface for `M'. This kind of thing happens with a lot of modules. What am I doing wrong?
09:58:17 <jpcooper> hello
09:58:21 <ski> Abraxas : i suppose so
09:58:32 <Abraxas> in the case of dropwhile the tail of the list you need later on is eaten by the replacement variable y
09:58:35 <ClaudiusMaximus> mcstar: you make a newtype SetWithMyOrd a = BySizeThenRegular (Set a) deriving (Read, Show, Eq, ...) ; instance Ord a => Ord (SetWithMyOrd a) where compare = compare `mappend` comparing S.size -- or something that typechecks
09:58:42 <rwbarton> strebe: well there is no mergeWith
09:58:47 <Abraxas> y = dropwhile p xs
09:58:51 <ski> Abraxas : yes, so you need primitive recursion rather than just structural recursion
09:59:07 <jpcooper> does anyone know a library which can give an integer solution to integer linear equations of the form xM(x^T)=1 in Haskell?
09:59:10 <rwbarton> strebe: so I guess it is looking for an M.hs that contains mergeWith
09:59:17 <jamy23> me that no one hears?
09:59:44 <strebe> rwbarton: hm, ah. Interesting. (and yes, I'd meant unionWith - oops)
09:59:52 <quuuux> strebe: are you looking for mergeWithKey?
09:59:56 <mcstar> ClaudiusMaximus: i know that, already did that once, but that requires for me to write utility functions that translate to the ones of the original Set tyep
10:00:17 <Abraxas> ski: that would be next in the paper
10:00:22 <rwbarton> jamy23: we hear you but can't understand
10:00:26 <ClaudiusMaximus> mcstar: http://hackage.haskell.org/packages/archive/newtype/0.2/doc/html/Control-Newtype.html
10:00:33 <ski> Abraxas : cf. for naturals `primRec :: o -> (Nat -> o -> o) -> (Nat -> o); primRec base step Zero = base; primRec base step (Succ n) = step n (primRec base step n)'
10:00:41 <rwbarton> jamy23: if you want to sleep for one second use IO
10:00:50 <mcstar> "Primarly"
10:00:59 <rwbarton> jamy23: if you want to sleep for one second but don't want to use IO then you are doing something wrong (or thinking wrong)
10:01:07 <monochrom> this must be The Hour of Self-Conflicting Questions
10:01:54 <monochrom> question 1: I want the program to sleep and then writeIORef, but it must not be in IO
10:01:54 <mcstar> his computer must be overheating, so he needs the pauses
10:01:59 <rwbarton> hehe
10:02:32 <monochrom> question 2: I want to do something that requires newtype, but I refuse newtype
10:03:24 <jamy23> rwbarton: ok. How i can transfer function throw IO which need run after sleep? IO lost the scope?
10:03:25 <mcstar> thats not fair
10:03:38 <ClaudiusMaximus> mcstar: my solution for that is   cpufreq-set -c 0 --max 1MHz   # until i get around to declogging the gunk from the heatsinks and fans
10:03:50 <jpcooper> or at least, does anyone know some library for integer solutions to integer linear equations? I know that the LinSolv algorithm gives rational solutions, but I haven't found anything else.
10:04:04 <mcstar> ClaudiusMaximus: i run mine with the powersave governor
10:04:16 <narens> jpcooper: use glpk it does Mixed integer programming
10:04:17 <rwbarton> jamy23, I don't understand
10:04:34 <jpcooper> thanks narens, I'll have a look
10:04:38 <Ferdirand> integer linear equations... in which field ?
10:04:55 <jpcooper> what exactly does the "mixed" imply, though?
10:05:25 <narens> jpcooper: general integer and non-integer variables... but you can specify just integers
10:05:25 <Abraxas> ski: that looks similar to fold which is why that works?
10:05:39 <narens> jpcooper: I've used the glpk-hs library and its easy to use... works well
10:05:39 <Abraxas> *foldr
10:05:42 <clahey> edwardk: So, I have questions about how to do character parsing.
10:05:43 <jpcooper> great
10:05:50 <edwardk> okay
10:05:55 <jamy23> rwbarton: haskell doesn't have side effects/ Right?
10:06:09 <rwbarton> haskell has effects
10:06:13 <rwbarton> it calls them values of type IO a
10:06:17 <edwardk> jamy23: sure it does, we just shove them under the rug most of the time
10:06:25 <clahey> edwardk: The spec calls for things like: char = ['/x0'..] - nonCharacters.
10:06:39 <ski> Abraxas : the corresponding fold is `foldNat :: o -> (o -> o) -> (Nat -> o); foldNat zero succ Zero = zero; foldNat zero succ (Succ n) = succ (foldNat zero succ n)' ..
10:06:44 <clahey> nonCharacters = ['\x1' .. '\x10'] and the like.
10:06:53 <clahey> Those numbers are made up, but you get what I mean.
10:07:12 <edwardk> clahey: so what is the problem?
10:07:14 <clahey> So I could write out complicated noneOf and anyOf expressions.
10:07:23 <ski> Abraxas : these are almost the same. the difference is that `step' also gets `n' as argument, while `succ' only gets the recursive result
10:07:27 <edwardk> *nods*
10:07:40 <user`> guys could i ask a quick question, im trying to define a function but I cant quite get the syntax right. I want to pass a string to a numeric list. country :: String -> [Num]
10:07:41 <user`> country "Argentina" = [1827,1890,1951,1956,1982,1989,2002,2003,2004,2005]
10:07:41 <user`> country x = "Unknown Country" but its not working.
10:07:43 <typoclass> edwardk: well, the rug brings them in order and keeps track of them
10:07:51 <edwardk> typoclass: its a nice rug
10:08:09 <typoclass> yeah. it's a very structured rug
10:08:12 <clahey> edwardk: I don't want to write out complicated noneOf and anyOf.
10:08:26 <ski> user` : `[Num]' is wrong, perhaps you wanted `country :: String -> [Integer]' or `country :: Num n => String -> [n]' ?
10:08:30 <clahey> edwardk: One of the goals is to make the code look like the specification, right?
10:08:37 <clahey> edwardk: So some degree?
10:08:41 <edwardk> sure
10:08:47 <clahey> To some degree*
10:08:58 <clahey> So I started writing them out as Sets.
10:09:02 <mizu_no_oto> user`: (country x = "Unknown Country") :: a -> String
10:09:06 <rwbarton> user`: you can't have 'country' return a list of integers on some input and a string on other input
10:09:07 <ski> user` : also, the first equation for `country' returns a list of numbers, the second a string -- you have to decide which you want, you can't have both
10:09:15 <clahey> But then I realized that S.fromList ['/x0'..] is going to take up a lot of space.
10:09:18 <rwbarton> mizu_no_oto: wat
10:09:20 <ski> user` : perhaps you wanted a call to `error' in the second case ?
10:09:32 <clahey> And not be all that fast.
10:09:41 <edwardk> clahey: actually oneOfSet is _really_ fast
10:09:46 <clahey> I started writing them as Sets with satisfy (memberOf set)
10:09:47 <edwardk> remember it builds it once
10:09:51 <user`> i wanted the last option to be the defult
10:10:06 <typoclass> user`: the first line is good (country "Argentina" = ...), in the second line you probably forgot an 'error': «country _ = error "Unkown ..."»
10:10:08 <user`> but yea main thing i want to do is return a list of int's
10:10:09 <edwardk> http://hackage.haskell.org/packages/archive/trifecta/0.53/doc/html/Text-Trifecta-Parser-Char.html#v:oneOfSet
10:10:12 <Abraxas> ski: oh and that's why the foldr has to be tupled, it only takes the recursive result, but we also need the n? or do i make false connections, now?
10:10:12 <clahey> edwardk: So it's order log 2 number of elements?
10:10:16 <edwardk> yes
10:10:21 <edwardk> so is oneOf
10:10:35 <rwbarton> mizu_no_oto: oh i think i see. that is a horribly confusing way to write though
10:10:37 <clahey> Does oneOf build a Set internally?
10:10:37 <edwardk> it builds a set behind your back. ideally if you use it over and over it'll keep using the same generated set
10:10:47 <typoclass> user`: erm sorry, then i misunderstood ('error' will abort your program)
10:10:50 <ski> Abraxas : yes, that's the reason -- the tupling simulates a paramorphism from the catamorphism
10:10:56 <edwardk> clahey: http://hackage.haskell.org/packages/archive/trifecta/0.53/doc/html/src/Text-Trifecta-Parser-Char.html#oneOf
10:11:11 <clahey> edwardk: Cool.
10:11:37 <edwardk> The CharSet stuff is optimized to check if the set is entirely ascii and shortcircuit decoding, etc.
10:11:37 <ski> (Abraxas : a "catamorphism" is the same as a "fold" -- note that `foldl' in Haskell is a different beast, though)
10:11:49 <mizu_no_oto> user': Consider returning a Maybe [Int] instead.
10:11:51 <Abraxas> ski: ah, nice =)
10:11:57 <clahey> edwardk: I see that.
10:12:12 <edwardk> also, the complement of the set takes the same space as the original set
10:12:23 <jamy23> So how to save function "A" if B(bool, A) -> IO ???
10:12:24 <clahey> So, wouldn't it still be 20 lookups if the set has 2^20 elements?
10:12:52 <clahey> Oh, I'm starting to see it.
10:12:55 <user`> thanks guys
10:13:19 <edwardk> if you have a set that covers almost the entire char set range, its better to complement a very small set ;)
10:13:57 <edwardk> in practice almost all sets are < 1k characters or > 2^21 - 1k
10:14:04 <edwardk> just empirically
10:14:12 <clahey> edwardk: Let me look.
10:14:28 <edwardk> but overall, its a pretty cost effective implementation
10:14:30 <clahey> I was dumbly using Set Char instead of CharSet.
10:14:49 <edwardk> i have an even faster one, but its painfully complicated to implement so i haven't
10:14:51 <ski> Abraxas : as another example, consider `data Tree n l = Leaf l | Node Int n (Tree n l) (Tree n l)', we get `cataTree :: (l -> o) -> (Int -> n -> o -> o -> o) -> (Tree n l -> o)', but `paraTree :: (l -> o) -> (Int -> n -> Tree n l -> o -> Tree n l -> o -> o) -> (Tree n l -> o)' (implementation left as an exercise)
10:14:54 <jamy23> rwbarton: So how to save function "A" if B(bool, A) -> IO ???
10:15:02 <rwbarton> sorry
10:15:04 <rwbarton> i cannot help you
10:15:06 <clahey> This may be the one issue: [#xF900-#xEFFFF]
10:15:54 <typoclass> jamy23: try to put your question into different words. people didn't understand what you're asking
10:15:54 <Abraxas> ski: hm, ok ;)
10:16:01 <edwardk> then just implement that with satisfy (\n -> fromEnum n > 0xf900)
10:16:14 <edwardk> er >=
10:16:21 <edwardk> thats O(1) =P
10:16:37 <edwardk> all of these are O(1) technically since the set size is bounded, but thats being pedantic
10:16:58 <edwardk> @hpaste
10:16:58 <lambdabot> Haskell pastebin: http://hpaste.org/
10:17:12 <hpaste> edwardk pasted “UnicodeSet sketch” at http://hpaste.org/76151
10:17:26 <edwardk> the code i just hpasted was how i was thinking about doing it, but its a rats nest of special cases.
10:17:45 <jamy23> I was saying that I do not need a monads. Moreover, much CPU time is spent in monads
10:17:53 <edwardk> it _is_ however, particularly dense and quickly queried for utf-8 text, because the structure of the HAMT is builds mirrors the shape of UTF-8
10:19:01 <stepkut> I'm using pandoc. Trying to figure out how to make something bold and monospace. Basically bold inside a verbatim block..
10:19:22 <clahey> edwardk: So, when I diff two CharSets, is it still efficient?
10:20:07 <edwardk> its as efficient as the resulting set written out longhand would be
10:20:21 <ski> Abraxas : btw, <http://comonad.com/reader/2009/recursion-schemes/> might be interesting
10:20:29 <edwardk> in practice i wouldn't worry about the efficiency of these ;)
10:20:35 <edwardk> you'll have other bottlenecks
10:20:46 <edwardk> get it implemented and then check to see if its fast enough, then optimize
10:20:56 <edwardk> torturing yourself now is a great way to get paralyzed
10:21:25 <clahey> It's mostly implemented.  I just simplified the character sets.
10:21:29 <clahey> The rest already works.
10:21:42 <clahey> The thing that's going to be hard is to make a lenient version.
10:22:16 <edwardk> how big are the files you are working with?
10:22:43 <clahey> Tiny so far.
10:22:50 <edwardk> and in the end?
10:22:56 <ski> jamy23 : `foo (b,a) = do when b (threadDelay 42); evaluate a' ? maybe ?
10:23:10 <clahey> In the end it's meant to be librarized.
10:23:27 <clahey> So, comparable to xml.
10:23:30 <jamy23> I wanted to ask that how to tell this monad (GHC.Conc threadDelay :: Int -> IO ()) which function he should run after timeout time ends
10:23:39 <clahey> The term microxml refers to the size of the spec, not the size of the documents.
10:23:48 <clahey> Though I wouldn't be surprised if they tend to be a little shorter.
10:24:21 <clahey> I've read the definition of CharSet.  Looks perfect.
10:24:31 <clahey> Except for that one which I may special case.
10:25:11 <edwardk> my goal for it was to have it be fast for most use cases
10:25:20 <jamy23> ski: Maybe. Its seems to true
10:25:32 <edwardk> with no degenerate cases that are _too_ bad
10:26:06 <ski> jamy23 : `foo :: (Bool,a) -> IO a', of course
10:26:10 <clahey> @pl /x -> a x + b x
10:26:11 <lambdabot> (line 1, column 1):
10:26:11 <lambdabot> unexpected "/"
10:26:11 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
10:26:17 <clahey> @pl \x -> a x + b x
10:26:17 <lambdabot> liftM2 (+) a b
10:27:03 <clahey> @pl \x -> a x + b x + c x
10:27:03 <lambdabot> ap ((+) . liftM2 (+) a b) c
10:27:14 <copumpkin> lol
10:27:15 <clahey> Ick.
10:27:31 <maukd> :t liftM3
10:27:33 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
10:27:43 <jamy23> ski: No! "a" = function and not = IO
10:27:46 <copumpkin> :t sum . sequence [f, g, h]
10:27:47 <lambdabot> forall a (f :: * -> *). (Num a, SimpleReflect.FromExpr (f a), Monad f, Functor f) => f a
10:27:56 <copumpkin> :t sum .: sequence
10:27:58 <lambdabot> forall a (g :: * -> *). (Num a, Monad g, Functor g) => [g a] -> g a
10:28:04 <clahey> .:?
10:28:14 <clahey> :t .:
10:28:15 <lambdabot> parse error on input `.:'
10:28:18 <clahey> :t (.:)
10:28:19 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
10:28:26 <copumpkin> just double composition
10:28:30 <maukd> > (f .: g) x y :: Expr
10:28:32 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:28:32 <lambdabot>    `SimpleReflect.FromExpr ...
10:28:38 <maukd> oh well, I've tried
10:28:38 <ski> jamy23 : there's no way around `IO' in the result. if you want to have user-visible delay, you have to use `IO'
10:28:53 <ski> jamy23 : not sure what you mean by "\"a\" = function"
10:28:53 <jfischoff> @src (.:)
10:28:54 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
10:29:05 <ski>   (f .: g) a b = f (g a b)
10:29:10 <ski>   (.:) = (.) . (.)
10:29:16 <copumpkin> :t \x y -> sum (sequence x y)
10:29:17 <lambdabot> forall t a. (Monad ((->) t), Num a) => [t -> a] -> t -> a
10:29:20 <maukd> ∴
10:29:21 <ski>   infixr 9 .:
10:29:32 <copumpkin> nice monad dependency
10:29:46 <quuuux> :t (…)
10:29:48 <lambdabot> parse error (possibly incorrect indentation)
10:29:49 <shachaf> maukd: "g" is a one-argument function, sadly.
10:29:53 <jamy23> :t IO
10:29:53 <maukd> @let (∴) x = (.:) x
10:29:54 <lambdabot> Not in scope: data constructor `IO'
10:29:56 <lambdabot>  Defined.
10:30:08 <shachaf> @let (…) = (.:)
10:30:10 <lambdabot>  Defined.
10:30:12 <jamy23> :t fun
10:30:13 <lambdabot> forall a. (SimpleReflect.FromExpr a) => String -> a
10:30:21 <maukd> > (f ∴ (g :: Expr -> Expr -> Expr)) x y :: Expr
10:30:24 <lambdabot>   f (g x y)
10:30:29 <shachaf> Oh, unless you specify it.
10:30:34 <maukd> shachaf: g is a varargs function, sadly
10:30:40 <maukd> which is why it requires an explicit annotation
10:30:47 <shachaf> Right.
10:30:56 <ski> > ((f :: Expr -> Expr) .: g) a b
10:30:58 <lambdabot>   f (g a b)
10:31:02 <clahey> > (sqrt .: +) 5 7
10:31:03 <lambdabot>   <no location info>: parse error on input `+'
10:31:09 <clahey> > (sqrt .: (+)) 5 7
10:31:11 <jamy23> Ok. Thanks! I have to go. Bye!
10:31:11 <lambdabot>   3.4641016151377544
10:31:17 <ski> jamy23 : bye ..
10:31:18 <clahey> > (sqrt .: (+)) 5 11
10:31:20 <lambdabot>   4.0
10:31:25 <clahey> I've been looking for that.
10:31:29 <clahey> :t (..:)
10:31:31 <lambdabot> Not in scope: `..:'
10:31:33 <clahey> :t (.::)
10:31:35 <lambdabot> Not in scope: `.::'
10:31:42 <ski> clahey : `(.::) = (.) . (.) . (.)', yes
10:31:42 <clahey> Worth checking.  :)
10:31:57 <clahey> Oh, but lamdbabot just doesn't know it.
10:32:06 <ski> (the name comes from the number of dots)
10:32:19 <clahey> :t (&&) .: (&&)
10:32:20 <shachaf> @let (.….) = (.::)
10:32:20 <lambdabot> Bool -> Bool -> Bool -> Bool
10:32:21 <lambdabot>  <local>:3:8: Not in scope: `.::'
10:32:24 <quuuux> @pl \ f g -> f >>= maybe g (return . Just)
10:32:24 <lambdabot> (. flip maybe (return . Just)) . (>>=)
10:33:36 <ski> clahey : happy you find my pointless combinators useful :)
10:34:03 <clahey> It's actually ([#xF900-#xEFFFF] - nonCharacterCodePoint), but I'll make nonCharacterCodePointSet and then have that rule be satisfy (liftM3 ((&&) .: (&&)) (>'\xF900') (<'\xEFFFF') (flip notMember nonCharacterCodePointSet)
10:34:07 <clahey> )
10:34:10 <clahey> That should be super fast.
10:34:38 <clahey> And honestly, most of the time it will have matched by then because that's proceeded by yet another CharSet that will match most of the time.
10:35:12 <clahey> Actually, that's not quite true since it'll have to fail for when there isn't a name there.  That's true.
10:35:21 <clahey> But still pretty dang fast.
10:36:01 <clahey> I do love that I was able to write a working parser in a night and that it mostly looks just like the spec.
10:36:43 <shachaf> clahey: Like https://github.com/orenbenkiki/yamlreference/blob/master/Text/Yaml/Reference.bnf ?
10:36:53 <clahey> I'll fix it up to use CharSet and post it to hpaste next time I'm not at work.
10:37:42 <clahey> shachaf: Similar.  I left the stuff from the spec in there too.
10:37:45 <clahey> What is this?
10:37:53 <clahey> c_printable {- 1 -} = '\x9' / '\xA' / '\xD' / ('\x20', '\x7E')
10:37:54 <clahey>                     / '\x85' / ('\xA0', '\xD7FF') / ('\xE000', '\xFFFD')
10:37:54 <clahey>                     / ('\x10000', '\x10FFFF')
10:38:10 <shachaf> I think ('a','b') is a character range.
10:38:24 <clahey> That looks very different from the haskell parsers I've seen.
10:38:41 <rwbarton> > ".bnf" == ".hs"
10:38:41 <clahey> I suppose .bnf probably doesn't mean it's haskell, eh?  :)
10:38:43 <lambdabot>   False
10:38:50 <shachaf> rwbarton: That's Haskell code.
10:39:02 <shachaf> It's #included into a .hs file.
10:39:08 <c_wraith> I mean, that does look like haskell.
10:39:16 <c_wraith> it just depends on a \ operator being defiend
10:39:22 <c_wraith> or defined
10:39:26 <c_wraith> in case it is a fiend
10:40:09 <strebe> I suspect I'm missing something obvious, but I can't find it via hoogle: is there a shorter way to write (\x -> [x]) (that is, a function which makes a one-element list out of its argument)?
10:40:11 <c_wraith> err, the operator is (/).  man, I can't read.  I feel like someone who gives urls on tv and says "backslash"
10:40:20 <c_wraith> strebe: (:[])
10:40:28 <shachaf> \kick c_wraith
10:40:38 <c_wraith> strebe: often called the robot monkey function. :)
10:40:44 <S11001001> c_wraith: I thought that mostly stopped now
10:40:45 <shachaf> @quote eat.a.comment
10:40:45 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
10:40:46 <strebe> c_wraith: ahh, thanks you. I was trying various things with : and [] but didn't think to combine them like that :-)
10:40:52 <strebe> *thank
10:41:12 <maukd> strebe: pure
10:41:15 <shachaf> "pure" does the same thing as (:[]) and is one character shorter.
10:41:24 <c_wraith> but it's not a robot monkey
10:41:28 <c_wraith> also, it requires more imports
10:41:36 <maukd> return
10:42:01 <rwbarton> there should really just be a Data.List.singleton
10:42:02 <quuuux> @pl (\ ma f -> maybe f (return . Just) ma)
10:42:03 <lambdabot> flip (flip maybe (return . Just))
10:42:20 <typoclass> > length "import Control.Applicative"
10:42:22 <lambdabot>   26
10:42:24 <byorgey> shachaf: however, robot monkey can be applied to an argument with no intervening space, whereas pure requires one.
10:42:36 <byorgey> well, depending on the argument.
10:42:37 <rwbarton> pretty much ever other data structure has a singleton function
10:42:39 <S11001001> use Just, apply natural transform to []
10:42:41 <rwbarton> every other, even
10:42:48 <shachaf> byorgey: pure also requires a type annotation occasionally.
10:42:53 <typoclass> shachaf: i think it'll have amortized itself after 26 uses :-) in one source file
10:42:55 <shachaf> But sometime it's shorter!
10:43:02 <strebe> maukd: thank you, good to know about
10:43:21 <shachaf> @let purée = pure
10:43:23 <lambdabot>  Defined.
10:43:34 <byorgey> hehe
10:43:45 <shachaf> @brain elliott
10:43:46 <lambdabot> Promise me something, Pinky. Never breed.
10:57:23 <stepkut> when using Crypto.Hash.SHA1 the ByteString it returns contains a bunch of non printable characters like, "@\189\NUL\NAKc\b_\195Qe2\158\161\255\\^\203\219\190\239"
10:57:46 <stepkut> how do I turn that into something like the output of sha1sum??
10:57:57 <c_wraith> stepkut: as it should.  You need the binary representation for using it as a primitive.
10:57:59 <clahey> stepkut: What is the output of sha1sum?
10:58:05 <c_wraith> base16 encode, I think
10:58:35 <rwbarton> > concatMap (printf "%02x") "@\189\NUL\NAKc\b_\195Qe2\158\161\255\\^\203\219\190\239"
10:58:36 <lambdabot>   Ambiguous type variable `b' in the constraints:
10:58:36 <lambdabot>    `GHC.Show.Show b'
10:58:36 <lambdabot>      a...
10:58:39 <rwbarton> augh
10:58:48 <rwbarton> oh
10:58:53 <rwbarton> > concatMap (printf "%02x" . ord) "@\189\NUL\NAKc\b_\195Qe2\158\161\255\\^\203\219\190\239"
10:58:54 <lambdabot>   Ambiguous type variable `b' in the constraints:
10:58:55 <lambdabot>    `GHC.Show.Show b'
10:58:55 <lambdabot>      a...
10:59:01 <rwbarton> > concatMap (printf "%02x" . ord) "@\189\NUL\NAKc\b_\195Qe2\158\161\255\\^\203\219\190\239" :: String
10:59:03 <lambdabot>   "40bd001563085fc35165329ea1ff5c5ecbdbbeef"
10:59:11 <c_wraith> beef
10:59:18 <rwbarton> dunno whether that would match sha1sum though, better test
10:59:26 <mcstar> it does
10:59:42 <clahey> Oooh, printf.
10:59:47 <clahey> :t printf
10:59:48 <lambdabot> forall r. (PrintfType r) => String -> r
10:59:57 <shachaf> Kind of annoying that the main way to do a lot of useful formatting with the standard library is to use an unsafe function. :-(
10:59:58 <c_wraith> hah.  printf involves crazy type hackery
11:00:06 <elliott> FSVO unsafe
11:00:11 <elliott> printf is type-safe AFAIK
11:00:27 <clahey> FSVO?
11:00:31 <rwbarton> I think there are other ways
11:00:46 <rwbarton> this is just the one I can remember because I learned it as a kid ;)
11:00:56 <shachaf> There are showIntAtBase and all those, in this case. But they have their own problems.
11:01:10 <stepkut> awesome, thanks!
11:01:16 <ski> > printf "" "" :: String
11:01:17 <lambdabot>   "*Exception: Printf.printf: formatting string ended prematurely
11:01:25 <shachaf> rwbarton: Complete with concatMap, right?
11:01:40 <typoclass> shachaf: printf is unsafe? i thought it needed oleg-level funk, but was basically safe
11:01:47 <clahey> :t Data.ByteString.foldr (liftM2 (+) (* 16) ord)
11:01:48 <lambdabot>     Couldn't match expected type `a -> a' against inferred type `Word8'
11:01:49 <lambdabot>     In the second argument of `liftM2', namely `(* 16)'
11:01:49 <lambdabot>     In the first argument of `BS.foldr', namely
11:01:49 <typoclass> clahey: "for some value of"
11:01:50 * shachaf doesn't think of Printf as crazy type-hackery anymore.
11:02:31 <typoclass> shachaf: i believe the technically correct term is 'oleg-level funk'
11:02:46 <rwbarton> printf is about as "type unsafe" as sqrt
11:02:49 <clahey> @pl \x a b -> a * 16 + ord b
11:02:50 <lambdabot> const ((. ord) . (+) . (16 *))
11:02:52 <shachaf> typoclass: Isn't it "augustss-level funk"?
11:03:04 <rwbarton> it may fail at runtime if you give it the wrong format string, but it's not gonna unsafeCoerce your stuff
11:03:06 <clahey> :t Data.ByteString.foldr ((. ord) . (+) . (16 *))
11:03:07 <lambdabot>     Couldn't match expected type `Char' against inferred type `Int'
11:03:07 <lambdabot>     In the first argument of `(.)', namely `(+)'
11:03:07 <lambdabot>     In the second argument of `(.)', namely `(+) . (16 *)'
11:03:38 <clahey> :t foldr
11:03:39 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
11:03:50 <clahey> @pl \x a b -> b * 16 + ord a
11:03:51 <lambdabot> const ((. (16 *)) . (+) . ord)
11:03:57 <clahey> @pl \x a b -> ord a + b * 16
11:03:58 <lambdabot> const ((. (16 *)) . (+) . ord)
11:04:16 <clahey> :t Data.ByteString.foldr ((. (16 *)) . (+) . ord)
11:04:17 <lambdabot>     Couldn't match expected type `Word8' against inferred type `Char'
11:04:18 <lambdabot>     In the second argument of `(.)', namely `ord'
11:04:18 <lambdabot>     In the second argument of `(.)', namely `(+) . ord'
11:04:30 <shachaf> I guess we need multiple levels of unsafety.
11:04:32 <clahey> :t Data.ByteString.foldr ((. (16 *)) . (+))
11:04:33 <lambdabot> Word8 -> BSC.ByteString -> Word8
11:04:38 <clahey> :t Data.ByteString.foldr ((. (16 *)) . (+)) 0
11:04:39 <lambdabot> BSC.ByteString -> Word8
11:04:53 <clahey> :t Data.ByteString.foldr ((. (16 *)) . (+) . fromIntegral) 0
11:04:54 <lambdabot> forall a. (Num a) => BSC.ByteString -> a
11:05:00 <Cale> rwbarton: But you can say that it's definitely less typesafe than using show or specific pretty printing functions and concatenation.
11:05:18 <clahey> Oh.  I've implemented the opposite.  Oops.
11:05:19 <rwbarton> naturally, however, those specific functions are less memory-safe
11:05:26 <clahey> :t Data.ByteString.foldr ((. (16 *)) . (+) . intFromDigit) 0
11:05:28 <rwbarton> it's a tradeoff
11:05:28 <lambdabot> Not in scope: `intFromDigit'
11:05:33 <clahey> :t Data.ByteString.foldr ((. (16 *)) . (+) . digitToInt) 0
11:05:34 <lambdabot>     Couldn't match expected type `Word8' against inferred type `Char'
11:05:35 <lambdabot>     In the second argument of `(.)', namely `digitToInt'
11:05:35 <lambdabot>     In the second argument of `(.)', namely `(+) . digitToInt'
11:05:56 <clahey> :t Data.ByteString.foldr ((. (16 *)) . (+) . digitToInt . chr) 0
11:05:57 <lambdabot>     Couldn't match expected type `Word8' against inferred type `Int'
11:05:57 <lambdabot>     In the second argument of `(.)', namely `chr'
11:05:57 <lambdabot>     In the second argument of `(.)', namely `digitToInt . chr'
11:06:14 <clahey> :t Data.ByteString.foldr ((. (16 *)) . (+) . fromIntegral . digitToInt . chr . fromIntegral) 0
11:06:16 <lambdabot> forall a. (Num a) => BSC.ByteString -> a
11:06:19 <clahey> Ugly.
11:06:27 <Cale> rwbarton: Hm?
11:06:37 <clahey> Also, wrong.  What am I talking about?
11:06:39 <rwbarton> me trying to remember the name of those other functions is likely to fail at runtime
11:07:05 <clahey> So, I've answered totally the wrong question.
11:07:06 <shachaf> It's possible to make a type-safe printf.
11:07:35 <clahey> shachaf: By during recursion on the formatting string?
11:07:37 <clahey> doing*
11:07:57 <Cale> rwbarton: In what way is using printf more safe than explicitly constructing the string you're after?
11:08:13 <rwbarton> it wastes less of my time
11:08:30 <clahey> So, is my code that I've written there close to the right code for doing the opposite conversion of what stepkut is asking for?
11:08:38 <clahey> (And next time I'll do it in /msg.  Sorry about that.)
11:08:48 <clahey> Or is there a simpler way?
11:08:58 <rwbarton> hmm
11:09:00 <rwbarton> > read "0xf"
11:09:01 <lambdabot>   *Exception: Prelude.read: no parse
11:09:05 <rwbarton> > read "0xf" :: Integer
11:09:06 <lambdabot>   15
11:09:16 <clahey> read "0xfd38" :: Integer
11:09:22 <clahey> > read "0xfd38" :: Integer
11:09:24 <lambdabot>   64824
11:09:27 <rwbarton> but that just gives you a giant integer which doesn't really solve your problem
11:09:38 <clahey> Actually, that's what I was looking for.
11:10:02 <clahey> Right, cause the opposite to what he's asking for would be to turn it into a ByteString.
11:10:06 <clahey> I've written that one before.
11:10:28 <clahey> But read . ("0x" ++) will work pretty dang well.
11:10:43 <user`> got a question, i have a list and i would like to return the number of times an int occurs in the list, whats the function that does that?
11:10:58 <shachaf> length . filter (==myInt)
11:11:15 <typoclass> > filter isUpper "LolCats" -- user`, this should get you started
11:11:16 <lambdabot>   "LC"
11:11:43 <shachaf> clahey: There's readHex.
11:11:52 <user`> thanks
11:12:34 <cornihilio> is there an easy way to use something like getWord32le in an Attoparsec Parse function?
11:12:47 <Eduard_Munteanu> Anybody got an idea how much of arrows does bikleisli cover? Any particular, important class of arrows?
11:13:04 <cornihilio> sorry, in an function of :: Attoparsec.Parser
11:13:32 <edwardk> i'm generally underwhelmed by BiKleisli's utility
11:14:02 <edwardk> It looks like a good idea at first, but when you go to actually use it you notice that you are just using the same effects over and over and over and its getting slower and slower.
11:14:27 <edwardk> i'm MUCH happier with a comonad that lives in the kleisli category of some monad, or a monad that lives in the cokleisli category of a comonad.
11:14:56 <edwardk> than I am with a distributive law that all it can do is ensure that things are 'maximally terrible' in terms of how much work you do
11:15:53 <typoclass> @remember edwardk i'm MUCH happier with a comonad that lives in the kleisli category of some monad, or a monad that lives in the cokleisli category of a comonad, than I am with a distributive law that all it can do is ensure that things are 'maximally terrible' in terms of how much work you do
11:15:54 <lambdabot> It is stored.
11:16:36 <ski> > (readHex :: ReadS Integer) "fd38"
11:16:37 <lambdabot>   [(64824,"")]
11:17:14 <edwardk> Eduard_Munteanu: an example is you can make a memoizing store comonad that lives in Kleisli IO which records what experiments have been tried and stores the answer. BiKleisli offers you nothing like this. It only offers you pain. ;)
11:17:17 <Eduard_Munteanu> edwardk: hm, even so, how much do those combined monads+comonads subsume wrt arrows?
11:17:40 <edwardk> not sure. i've yet to find a useful combination of monad + comonad in the BiKleisli sense
11:18:00 <edwardk> I can say that it is 'less useless than a dyad' but thats about it
11:18:01 <clahey> ski: That is nice, but I think I'll just use read.  Since the context is: chr . read <$> many (satisfy isHexDigit)
11:18:20 <clahey> ski: I'm pretty sure it's safe to assume that what's being passed in is a string of hex digits.
11:18:33 <edwardk> of course, thats because dyads are completely useless. ;)
11:18:55 <c_wraith> more useless than magmas?
11:19:00 <edwardk> http://wwwhome.ewi.utwente.nl/~fokkinga/mmf94c.pdf   -- there _aren't_ any dyads that aren't a pure monad or comonad. ಠ_ಠ
11:19:52 <clahey> ski: Add a . ("0x" ++)
11:19:55 <shachaf> What about dryads?
11:20:36 <edwardk> shachaf: They have it tough. Its not easy being green.
11:20:46 <typoclass> so, parsec lets you use monad transformers, while attoparsec doesn't? do i have that right?
11:21:04 <clahey> Although chr . fst . (!! 0) . readHex might be faster and just as safe.
11:21:13 <Eduard_Munteanu> edwardk: ah, I was hoping / investigating whether such combinations (including those involving monads on cokleisli categories etc.) cover any particula\r subset of arrows.
11:21:23 <Eduard_Munteanu> s/particular/interesting/
11:21:50 <edwardk> typoclass: actually parsec is a monad transformer but it doesn't let you apply transformers to _it_
11:22:13 <edwardk> typoclass: trifecta lets you apply transformers to a parser monad and yields another valid parser monad
11:22:29 <typoclass> edwardk: yes, i meant parsec allows its ParserT to be bolted onto other monads
11:22:36 * hackagebot lio 0.9.1.1 - Labeled IO Information Flow Control Library  http://hackage.haskell.org/package/lio-0.9.1.1 (AmitLevy)
11:22:51 <edwardk> typoclass: yes
11:23:12 <typoclass> since someone was asking about attoparsec and using it simultaneously with the Get monad from binary, or something
11:24:03 <typoclass> cornihilio: ^^
11:24:46 <Eduard_Munteanu> BTW, regarding theoretical aspects of (co)monad transformers, where do I look?
11:25:21 <Eduard_Munteanu> I looked at something that treated monad transformers as monoid homomorphisms (and monads as monoids of course).
11:26:14 <Cale> Eduard_Munteanu: A monad transformer is actually kind of an interesting thing category-theoretically, because it is a mapping which "creates" functors
11:27:01 <edwardk> The comonad transformers I have were derived by a rigorous process of trial and error and 'ehhhh, that looks right'
11:27:41 <Eduard_Munteanu> Cale: mm, so they could be arrows in the category of monads (for a certain category), or something like that?
11:28:10 <ski> Philippa : such buggered-up binding structure would be quite useful, ihmo
11:28:17 <nand`> wait wait
11:28:18 <Cale> Eduard_Munteanu: So a monad transformer T for a category C would be a mapping sending each monad M on C to a monad TM on C, together with a natural transformation lift_M: M -> TM
11:28:30 <Eduard_Munteanu> edwardk: does it even make sense to apply a comonad transformer to say, a monad?
11:28:30 <nand`> Haskell was named after Haskell Curry's first name because the last name had too many puns?
11:28:33 <ski> Eduard_Munteanu : more like a functor on that category ?
11:28:36 <nand`> that's a first
11:28:50 <Cale> and moreover, lift_M needs to be natural in the choice of M
11:29:17 <Eduard_Munteanu> I see.
11:29:34 <rwbarton> some instances of MonadTrans aren't functors though (I'm looking at you ContT)
11:29:37 <edwardk> Eduard_Munteanu: did you see my post on how you can use any comonad to derive a monad transformer?
11:30:03 <Eduard_Munteanu> edwardk: yeah, I remember reading it. IIRC, you can't do it the other way around.
11:30:21 <Cale> let's see, what should that mean...
11:30:22 <edwardk> nand`: So sayeth the wise Alondo
11:30:27 <ski> (Eduard_Munteanu : a monad morphism from a monad `m' to a monad `n' is a function `f :: forall a. m a -> n a' such that `f . return = return' and `f . join = join . f . liftM f')
11:30:29 <Philippa> ski: ...huh?
11:30:35 <edwardk> Eduard_Munteanu: yep
11:30:43 <Philippa> (I'm missing scrollback and large chunks of context)
11:31:05 <Philippa> (sounds like something I made reference to at some point, but it's been a long week and it's going to carry on being one)
11:31:45 <edwardk> er I meant Alonzo, guess that doesn't work
11:32:39 <Cale> So for any natural transformation M -> N, we need there to be some sense in which this commutes with lifting
11:33:00 <ski> Philippa : `do if blah then {...; x <- foo; ...; y <- bar; ...} else {...; x <- baz; ...; y <- quux; ...}; ..x..y..' instead of `do (x,y) <- if blah then {...; x <- foo; ...; y <- bar; ...; return (x,y)} else {...; x <- baz; ...; y <- quux; ...; return (x,y)}; ..x..y..'
11:33:10 <Cale> but what natural map TM -> TN do we have?
11:33:36 <Philippa> ski: ah, right. Yeah, I want it sometimes, you just get some awkward requirements when you typecheck
11:33:48 <rwbarton> for most MonadTrans instances there happens to be such a map
11:33:48 <Eduard_Munteanu> Cale: Tf, where that f is your M -> N?
11:33:50 <Philippa> anyway, was on a train when I wrote that with an intensely shitty and unstable connection :-)
11:34:01 <Cale> Eduard_Munteanu: well...
11:34:12 <Philippa> okay, brb
11:34:15 <rwbarton> which you can just see by noting that the 'm' appears only in positive position in 'FooT m a'
11:34:28 <Cale> Eduard_Munteanu: I didn't actually say that T was a functor, but maybe there's some sense in which it needs to be a functor
11:34:50 <clahey> So, I'm randomly reading about category theory.  Types are like categories, functions are morphisms and functors are functors.  Is that about right?  fmap is the function mapping morphisms and ? is the function mapping objects?
11:35:04 <Cale> Eduard_Munteanu: In Haskell at least, we're *not* assuming that monad transformers are functorial in this way.
11:35:22 <Eduard_Munteanu> Hm.
11:35:31 <rwbarton> clahey, the type constructor itself is the function mapping objects
11:35:51 <rwbarton> fmap means "the fmap defined in instance Functor F for some particular F"
11:35:56 <rwbarton> and that F is the functor
11:35:58 <shachaf> clahey: Types are objects, not categories.
11:35:59 <Cale> There's no  tmap :: (MonadTrans t, Monad m, Monad n) => (forall a. m a -> n a) -> (forall a. t m a -> t n a)
11:36:30 <clahey> rwbarton: Why not have pure be part of functor instead of Applicative?
11:36:38 <rwbarton> because that's not what a functor is
11:36:39 <ski> @type mapReaderT
11:36:40 <lambdabot> forall (m :: * -> *) a (n :: * -> *) b r. (m a -> n b) -> ReaderT r m a -> ReaderT r n b
11:36:43 <ski> @type mapWriterT
11:36:44 <lambdabot> forall (m :: * -> *) a w (n :: * -> *) b w'. (m (a, w) -> n (b, w')) -> WriterT w m a -> WriterT w' n b
11:36:46 <rwbarton> "because Mac Lane says so"
11:36:46 <ski> @type mapStateT
11:36:47 <lambdabot> forall (m :: * -> *) a s (n :: * -> *) b. (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
11:36:59 <Cale> We tend to have these things hanging around
11:37:05 <Eduard_Munteanu> Cale: ah, so I guess you need lift_N . f = f . lift_M or something like that?
11:37:08 <ski> though could sortof be abstracted into `tmap'
11:37:26 <Philippa> re
11:37:31 <ski> Philippa : Erlang does have this, probably due to Prolog heritage
11:37:34 <Philippa> I keep forgetting how much faster this machine boots these days!
11:37:38 <Philippa> ski: yep, makes sense there
11:37:39 <Cale> Eduard_Munteanu: well, you see, if alpha: M -> N is a natural transformation, then lift_N . alpha is well-typed
11:38:36 <Cale> but, we don't seem to have a map lift_alpha: TM -> TN so that we can write lift_alpha . lift_M = lift_N . alpha
11:38:59 <Philippa> ski: it's only 'screwy' in the sense that it's a PITA to write the elaborator for and a much bigger one if you're not thinking about typechecking that way
11:39:05 <Cale> Maybe this ought to exist?
11:39:10 <Eduard_Munteanu> Oh, right.
11:39:25 <Philippa> (it's not even that big a PITA for an elaborator, but still)
11:39:52 <shachaf> @remember Saizan it must be weird getting less votes than the answer citing your thesis
11:39:52 <lambdabot> I will remember.
11:40:06 <rwbarton> so MonadTrans is like a pointed endofunctor on the category of monads, except without the functor part
11:40:16 <ski> clahey : defining `data IOReadRef a = forall b. IORR (IORef b) (b -> a)', `IOReadRef' is a functor (you can define `fmap'), but it's not possible to define `pure'
11:40:22 <Cale> Eduard_Munteanu: There's *something* which parametric polymorphism is giving us here which is a little tricky (at least for me!) to write in terms of standard categorical constructions.
11:40:37 <Eduard_Munteanu> rwbarton: you mean it's got pure, but not fmap?
11:40:43 <rwbarton> yes
11:40:47 <Cale> Maybe it ought to also really be a functor.
11:40:49 <rwbarton> I guess
11:41:01 <n-dolio> Not all transformers are covariant in the monad.
11:41:02 <Cale> and we're just not recognising that potential structure?
11:41:03 <rwbarton> if you take away "functor" you need to be careful about "pointed"
11:41:05 <Cale> hmm
11:41:30 <ski> Philippa : well, this wouldn't require having arbitrary expressions bind variables .. it's just an expansion of the commands accepted in `do'
11:41:37 <ski> (Philippa : or did i misunderstand you ?)
11:41:51 <Philippa> ski: oh, sure
11:42:06 <Eduard_Munteanu> n-dolio: mm, in the sense some of them could be modeled as "functors" from the opposite category?
11:42:09 <rwbarton> actually I don't know in what sense the identity functor is "point-like" in End(Monads) anyways
11:42:16 <Philippa> ski: you understood me fine :-)
11:42:19 <n-dolio> Eduard_Munteanu: No.
11:42:27 <rwbarton> @unmtl ContT r m a
11:42:27 <lambdabot> (a -> m r) -> m r
11:42:32 <n-dolio> Some are neither covariant nor contravariant.
11:42:36 <ski> Philippa : i assume the PITA you're thinking of is making sure all branches bind the same variables ?
11:42:41 <Philippa> yeah
11:42:59 <ski> invariant
11:43:01 <Eduard_Munteanu> So not functors at any rate?
11:43:15 <Philippa> (I /really/ want the version of zip that tells you if the lists don't match in size in the standard libs!)
11:43:31 * Eduard_Munteanu wonders what an invariant functor would mean
11:43:52 <Botje> Philippa: so something like zip [] (_:_) = error "lists are of inequal size" ?
11:43:53 <Eduard_Munteanu> Oh, nevermind.
11:43:55 <n-dolio> ContT is the one I'm thinking of.
11:44:17 <Eduard_Munteanu> They don't have to be covariant like Hom(X, -) or contravariant.
11:44:20 <n-dolio> There you need to consider a category where hom(M, N) gives you both a transformation M -> N and a transformation N -> M.
11:44:37 <n-dolio> Then it's probably a functor from that category.
11:44:43 <Botje> (just asking, i'm curious what such a thing would look like)
11:44:50 <rwbarton> or split the positive and negative occurrences of m into two variables
11:44:58 <n-dolio> No.
11:45:09 <clahey> ski: I don't quite understand that definition.
11:45:19 <Philippa> Botje: Nah. The Maybe-returning version, or an Either-returning one that tells you which one was bigger in the Left case
11:45:33 <Philippa> Botje: "tells you", not crashes :-)
11:45:45 <Eduard_Munteanu> rwbarton: and you'd get something like... Ran?
11:45:45 <Philippa> this crops up a lot if you're typechecking n-ary anything
11:45:47 <ski> sometimes i wonder if it would be good to use `forall a b. (a -> b) -> (f a -> g b)' instead of `forall a. f a -> g a' (when we don't know whether `f' is a functor, nor whether `g' is one)
11:45:50 <n-dolio> Splitting them into different variables would be something other than ContT.
11:46:07 <Eduard_Munteanu> I guess not, that's quantified differently.
11:46:13 <rwbarton> well, then you would use an end or something to get ContT back
11:46:21 <rwbarton> or not an end
11:46:28 <Cale> n-dolio: Any idea how to express the fact that whatever lift does, it has to do it in some fashion independently of the choice of m?
11:46:31 <rwbarton> but obviously since ContT is not a functor, you need to change it somehow
11:46:56 <ski> clahey : it's an "existential". `IOReadRef a' is basically `exists b. (IORef b,b -> a)' -- the data constructor gets signature `IORR :: forall a b. IORef b -> (b -> a) -> IOReadRef a' (*hiding* `b' from the result type)
11:47:24 <clahey> ski: Oh, yes, actually, I think I do.  Wouldn't pure a = IORR newIORef a id
11:48:00 <ski> clahey : no, since `newIORef :: a -> IO (IORef a)', rather than `newIORef :: a -> IORef a'
11:48:05 <clahey> Right.
11:48:23 <clahey> ski: Doesn't the same argument apply to Applicatives?
11:48:34 <ski> you can of course write `newIOReadRef :: a -> IO (IOReadRef a)', but that doesn't match the "shape" in the type of `pure'
11:48:36 <n-dolio> Cale: Not off hand.
11:48:46 <Botje> Philippa: crashing is a way of telling ;)
11:48:56 <rwbarton> the category C' with C'(a, b) = C(a, b) x C(b, a) is just a full subcategory of C x C' anyways. both are different categories from C
11:49:03 <clahey> ski: Agreed on that.
11:49:23 <clahey> ski: But could you not define readIORefFunc which implements <*>, but not pure?
11:49:38 <n-dolio> Cale: It's probably always some kind of naturality.
11:50:07 <n-dolio> But you can't just assume it's naturality with T being a covariant functor.
11:50:29 <rwbarton> (sorry, meant C x C^op of course)
11:50:40 <Cale> n-dolio: right.
11:51:01 <ski> clahey : more generally, `type IOReadRef = CoYoneda IORef', where `data CoYoneda f b = forall a. FMapIncl (a -> b) (f a)' -- `CoYoneda' is one way to turn *any* `f :: * -> *' into a *functor* `CoYoneda f'
11:51:04 <Eduard_Munteanu> Naturality implies functoriality here, no?
11:51:17 <rwbarton> "some kind of naturality" doesn't :)
11:51:39 <ski> clahey : i'm not sure what you're asking
11:51:52 <Cale> Eduard_Munteanu: well, what he's saying is that there's probably a way to view this as a natural map between functors, but perhaps not the functors we're considering
11:53:13 <Soultaker> I have:
11:53:14 <Soultaker>   data Queue e
11:53:22 <Soultaker>   emptyQ :: Queue e -> Bool
11:53:46 <Soultaker> and now I try to create a function to use this in the State monad (with the state being a queue):
11:53:54 <Soultaker>   empty :: MonadState (Queue e) m => m Bool
11:53:58 <Soultaker>   empty = liftM emptyQ get
11:54:04 <Eduard_Munteanu> Cale: is there something like a distributivity law for monads? That is, a map TM -> MT subject to certain conditions.
11:54:24 <Cale> Eduard_Munteanu: T is now another monad here?
11:54:25 <clahey> ski: I had the idea of storing a function in the IORef and using <*> to apply it, but all of a sudden the resulting IORR needs two IORefs instead of just the one.
11:54:34 <Soultaker> .. but this doesn't work.  The compiler says: Non type-variable argument in the constraint: MonadState (Queue e) m"
11:54:40 <Eduard_Munteanu> Cale: wasn't that the entire point of lift?
11:54:40 <ski> @type Data.Traversable.sequence
11:54:42 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
11:54:42 <Soultaker> what exactly is going on here?
11:54:50 <clahey> ski: So you can't implement <*> because of the IORef.
11:55:00 <Cale> Eduard_Munteanu: M and TM were monads
11:55:06 <Cale> Eduard_Munteanu: but T wasn't a monad on its own
11:55:22 <Cale> (it doesn't even act on objects of our original category, only on monads)
11:55:40 <rwbarton> @type liftM length get
11:55:42 <Eduard_Munteanu> Erm, right, that wasn't well-typed.
11:55:42 <lambdabot> forall a (m :: * -> *). (MonadState [a] m) => m Int
11:56:01 <ski> Soultaker : `{-# LANGUAGE FlexibleContexts #-}', iirc
11:56:18 <Soultaker> is there a way to get this to work without changing options?
11:56:25 <Soultaker> and what does the error message even mean?
11:56:32 <rwbarton> you could delete the type signature
11:56:40 <rwbarton> did it suggest FlexibleContexts?
11:57:07 <Soultaker> it did.
11:57:23 <ski> clahey : yes, you can't merge them
11:57:45 <rwbarton> you should turn on FlexibleContexts like ski said then
11:58:02 <ski> clahey : probably there's some way to freely get an idiom from it, similarly to `CoYoneda' for functors
11:58:05 <Soultaker> ok, so this is normal?
11:58:05 <rwbarton> you are already using extensions like it or not, you're using MonadState, that's a multiparameter type class with a functional dependency, those are two extensions
11:58:23 <ski> Soultaker : you're running into a conservative restriction in Haskell98
11:58:29 <shachaf> rwbarton: To be fair, FDs without MPTCs is kind of silly.
11:58:30 <rwbarton> with these extensions sometimes you need to write more general contexts
11:58:36 <Eduard_Munteanu> Cale: hrm, and ostensibly not all monads have transformers variant. (I was thinking maybe lifting could be expressed in terms of a distributivity law somehow)
11:58:42 <Eduard_Munteanu> *variants
11:58:44 <rwbarton> hehe
11:59:06 <n-dolio> class Single a | -> a where ...
11:59:13 <Cale> Eduard_Munteanu: sometimes, seemingly quite rarely, you can
11:59:15 <shachaf> class Nullary | ->
11:59:17 <Soultaker> aha. I'll just turn on that option then and pray everything works. Thanks guys :)
11:59:27 <n-dolio> shachaf: Still illegal for some reason.
11:59:38 <Cale> Soultaker: it'll work
11:59:50 <Cale> Soultaker: that's pretty much the least controversial extension ever
12:00:05 <n-dolio> shachaf: I think Derek said you looked it up, and it's just a conditional test somewhere that makes Nullary not work?
12:00:08 <n-dolio> For no apparent reason?
12:00:13 <ski> Soultaker : `FlexibleInstances' and `FlexibleContexts' are considered pretty benign extensions, lifting H98 restrictions
12:00:18 <shachaf> n-dolio: Yep.
12:00:28 <Eduard_Munteanu> Cale: I'll try going through that paper on monad transformers as monoid homomorphisms, maybe that's why they approached it that way, hrm.
12:00:41 <Cale> Eduard_Munteanu: which paper was that?
12:00:42 <strebe> Eduard_Munteanu: what paper is that?
12:00:50 * Eduard_Munteanu looks
12:00:58 <Soultaker> I believe you.  (I'm now reading a wiki page that tries to explain the concept.)
12:01:01 <Cale> Eduard_Munteanu: Have you seen the Catsters videos on distributivity laws for monads?
12:01:26 <Cale> Soultaker: It just removes that arbitrary restriction which was in the standard
12:01:36 <Eduard_Munteanu> @google monad transformers monoids
12:01:39 <lambdabot> http://www.disi.unige.it/person/MoggiE/ftp/tcs10.pdf
12:01:40 <lambdabot> Title: Monad Transformers as Monoid Transformers
12:01:58 <Cale> Soultaker: and you pretty much need it if you're going to do much of anything with the mtl stuff.
12:02:00 <Eduard_Munteanu> That one maybe, but I'm unsure, I skimmed a bit through it.
12:02:14 <Eduard_Munteanu> Cale: mm, no, I'll look for it.
12:02:42 <shachaf> n-dolio: Maybe someone should propose removing that restriction.
12:03:27 <acowley> Moggi papers can be tough going
12:03:37 <Eduard_Munteanu> Cale: hm, that paper actually mentions lifting as a reason for their monoidal approach.
12:04:15 <Cale> Eduard_Munteanu: and look in the table at what happens for ContT
12:05:01 <Cale> aha!
12:05:20 <Cale> So he has this definition of a basic transformer
12:05:29 <Eduard_Munteanu> Mm, page 4?
12:05:40 <Cale> page 26
12:06:20 <Eduard_Munteanu> I meant the ContT thing.
12:06:25 <Cale> oh, yeah...
12:06:42 <Cale> "Taxonomy of monad transformers"
12:07:06 <Cale> and he has the "type" column which lists the others as variously monoidal, functorial, covariant
12:07:16 <Cale> and then continuations are "basic"
12:07:41 <Cale> and in Definition 4.1 on page 26, he says what that means
12:08:30 <mightybyte> In case someone in here isn't subscribed to haskell-cafe...we have a job opening for a full-time Haskell programmer in NYC.  http://www.haskell.org/pipermail/haskell-cafe/2012-October/103898.html
12:08:47 <Cale> So it's a natural map between two functors |M| -> M and M is our category of monoids in some fixed monoidal category, which we might as well take as the category of monads on C.
12:09:25 <Cale> it's a natural map from the inclusion of |M| into M, to our actual monad transformer T
12:09:33 <mcstar> omg moment
12:09:45 <Eduard_Munteanu> Yikes, n-category theory :).
12:09:55 <Cale> Just barely
12:10:09 <mcstar> using a PSQueue is 2x slower than just sorting my map
12:10:13 <Cale> "2-cell in the 2-category of categories" just means "natural transformation"
12:10:17 <strebe> Cale: what books and papers would I need to read to understand that? :-)
12:10:45 <mcstar> needs automatic word wrapping
12:10:47 <Cale> strebe: Do you know what a category is?
12:11:03 <strebe> Cale: vaguely; I've read a little bit on category theory, but I don't have a firm grasp of it
12:11:12 <Eduard_Munteanu> Ah, it's not so bad if you put it that way.
12:11:23 <Cale> okay, so maybe you'll want to start with Awodey's book called Category Theory
12:11:30 <strebe> Ok; thank you
12:11:42 <Cale> (check PM :)
12:11:59 <acowley> mcstar: that's surprising performance!
12:12:09 <mcstar> yeah
12:12:22 <mcstar> i have a (Int,Int) -> Set Int map
12:12:33 <mcstar> and a PSQueue of (Int,Int) -> Int
12:12:44 <mcstar> the lenght of the set is the priority
12:13:14 <Cale> strebe: As you go along, and after you have a few basic definitions of things under your belt (at least what categories and functors are, perhaps natural transformations too), then you can also start watching the excellent mini-lectures by the Catsters on youtube
12:13:16 <mcstar> now, accessing the minimal element from the queue takes 2x longer than just sorting the whole map on the set size
12:13:27 <Cale> http://www.youtube.com/user/TheCatsters
12:13:51 <rwbarton> oh no, I have to go back and look whether "monoidal functor" means "lax monoidal functor"
12:14:33 <shachaf> Only in California.
12:15:20 <Cale> strebe: A difficult thing about them is that they are not really in any particularly natural order.
12:15:42 <rwbarton> apparently it does
12:16:07 <Cale> strebe: though, once you know what categories, functors, and natural transformations are, you can watch the series on monads, and then most of the other series will become accessible from there.
12:16:19 <strebe> Cale: hmm, ok; I generally prefer reading if given the choice, but if they're illuminating enough I'll give them a go. Thanks for the ordering advice.
12:17:23 <Cale> strebe: I think they're quite motivating anyway, from the perspective of seeing why this stuff is fun to study for its own sake.
12:20:49 <strebe> Cale: ok, I'll give them a whirl. Looks like natural transformations are only covered halfway into the book, so they really add quite a lot to the prereqs :-)
12:21:29 <Cale> strebe: well, you can read the definition of a natural transformation and hopefully start to understand it almost immediately after learning what a functor is
12:21:55 <Cale> It's just that the book puts a bunch of other material in between, because it's not beelining for monads :)
12:22:07 <shachaf> f : ℕ → ℕ -- natural transformation
12:22:11 <Cale> haha
12:23:20 <strebe> Cale: ahhhh, ok, excellent. I wasn't sure how much I could skip around in this book and have it keep making sense
12:25:05 <Eduard_Munteanu> You should be able to skip over pullbacks, (co)limits and Yoneda stuff if you're interested in monads.
12:25:20 <Eduard_Munteanu> Oh, and adjoints too.
12:25:26 <shachaf> Yoneda, yo problems.
12:26:01 <Eduard_Munteanu> Yo need a embedding, homie!
12:26:06 <Cale> Yeah, though Awodey's presentation of Yoneda is the one which actually finally made me properly understand what Yoneda was any good for.
12:26:58 <Cale> It's a completion theorem for categories.
12:28:03 <Cale> You can take any "bad" category and embed it into one which has every widget you could possibly ask for, and do this in such a way that if you manage to construct an arrow between two of the objects which came from your original category, then the arrow must have been there to begin with.
12:30:34 <Eduard_Munteanu> I wonder if there's a Yoneda for enriched categories, that embeds stuff into something else than -> Set.
12:31:07 <rwbarton> yes
12:31:10 <djahandarie> Yes, it should work fine
12:31:32 <Eduard_Munteanu> Nice, so this generalizes neatly.
12:31:33 <djahandarie> I don't think you'd even need to change much of anything about Yoneda for it to just work directly
12:32:08 * nejucomo stumbles upon this BitC retrospective thread from a rust language thread: http://www.coyotos.org/pipermail/bitc-dev/2012-March/003300.html -covers type system + systems language issues.
12:32:29 <djahandarie> Though the category being enriched over may need to be symmetric monoidal rather than just monoidal. Not sure about that.
12:32:35 * djahandarie tries to think about that
12:32:39 <djahandarie> rwbarton probably knows.
12:32:47 <rwbarton> yeah, you might need a tolerably good V
12:33:11 <nejucomo> Since I don't have a handle a good handle on haskell's type classes, throwing in systems programming issues is beyond my grasp currently.
12:33:18 <Cale> also, a lot of the niceness of the "completion" Set^(C^op) comes from the niceness of Set.
12:33:21 <rwbarton> I usually only think about cases where V is quite good so I don't know offset
12:33:23 <rwbarton> er
12:33:24 <rwbarton> offhand
12:33:33 <djahandarie> Looks like http://ncatlab.org/nlab/show/enriched+Yoneda+lemma talks about different generalizations
12:34:15 <Eduard_Munteanu> Cale: yeah, but it makes me wonder what nice gadgets are there in Vect K or some other things. I guess I should read up on enriched category theory first.
12:34:58 <shachaf> bos: Will you be at the meeting next week?
12:35:07 <rwbarton> Vect K would also be quite good by any reasonable definition, assuming you mean all K-vector spaces
12:35:18 <rwbarton> as opposed to just finite-dimensional ones or something
12:36:24 <djahandarie> The weak case on that nlab page is what I was thinking, interesting that the other version exists too
12:38:32 <ladida> hello
12:43:21 <acowley> Is there no way to write a standalone deriving line that derives multiple classes in one line?
12:44:00 <shachaf> deriving instance Foo a; deriving instance Bar a
12:44:09 <shachaf> s/a/A/
12:45:24 <hpaste> nejucomo pasted “Why isn't this constant memory usage?” at http://hpaste.org/76157
12:45:25 <ClaudiusMaximus> acowley: standalone deriving lines allow you to specify a context, so, that's probably why it's not possible, if indeed it isn't possible (not read the manual in anger)
12:45:46 <acowley> I checked the manual, and was now hoping it was just undocumented :/
12:46:09 <nejucomo> I have a tiny program in that hpaste, but it's memory usage grows with the input length (I think).  I expected it to be constant memory usage on average.
12:46:10 <acowley> It's particularly annoying when you have a type family instance
12:46:49 <acowley> Suppose I have a data instance with a newtype, I'd like to use generalized newtype deriving for great joy, but instead I need half a dozen standalone deriving lines outside the definition.
12:47:05 <ClaudiusMaximus> ah
12:47:15 <nejucomo> Does anyone see why?
12:47:46 <rwbarton> nejucomo, no
12:47:59 <nejucomo> I'm using getContents, then parsing that into a list, then computing the difference between each element in a new list, then printing the results.
12:48:35 <ClaudiusMaximus> :t interact
12:48:36 <lambdabot> (String -> String) -> IO ()
12:48:49 <nejucomo> rwbarton: Do you see a cleaner way to make the types unambiguous where I introduced readInTup ?
12:49:19 <nejucomo> ClaudiusMaximus: Are you suggesting I use that?
12:49:36 <ClaudiusMaximus> nejucomo: yes, if this is your whole program
12:49:44 <ClaudiusMaximus> nejucomo: and not an example of a bigger issue
12:49:56 <Cale> nejucomo: how are you compiling this? I don't see why it would use more than constant space even unoptimised, but you'll want to use at least -O if not -O2
12:50:01 <ClaudiusMaximus> s/bigger issue/issue in your real code/
12:50:21 <nejucomo> This is the whole program, but I'm running it with: bzcat input.bz2 | ./NthPrimeDelta > output
12:50:40 <nejucomo> Cale: I just ran "ghc --make NthPrimeDelta.hs".
12:50:48 <Cale> nejucomo: stick in -O2
12:50:52 <Cale> and see if it's any better
12:51:01 <nejucomo> ClaudiusMaximus: Thanks, interact would be cleaner; but the memory usage is still a mystery to me.
12:51:05 <nejucomo> Cale: Thanks.
12:51:09 <rwbarton> maybe a million lines of input was too many to test on
12:51:15 * rwbarton twiddles thumbs
12:51:27 <rwbarton> anyways it seems to be using constant space here
12:51:38 <rwbarton> ah, there we are. 125,616 bytes maximum residency (411 sample(s))
12:51:40 <rwbarton> with -O2
12:51:49 <nejucomo> I have > 5 million lines of input...
12:52:10 <nejucomo> (Which I computed with code taken from "The Genuine Sieve of Eratosthenes".  ;-)
12:52:12 <rwbarton> well, pretty sure it is not using linearly much space if it uses 125,616 bytes on 1 million items
12:52:27 <rwbarton> okay, I guess it could be using one bit per item ;)
12:52:39 <Cale> nejucomo: It is very weird that this would use non-constant space even without -O
12:52:43 <rwbarton> yeah
12:53:06 <nejucomo> Neat, it looks like with -O2 it's using < 4 megs rss (according to htop).
12:53:06 <Cale> rwbarton: care to try that?
12:53:10 <rwbarton> ok
12:53:23 <shachaf> 125,616? That's a lot of bytes!
12:53:29 <rwbarton> still looks constant in top
12:54:05 <rwbarton> nejucomo, now just to sanity check, try building without -O2 again?
12:54:28 <nejucomo> It was dying where I had a ulimit of -s 8192 and -v 1048576.
12:54:56 <kirindave_> Hmm
12:55:03 <kirindave_> Got a 30m commute in a moment
12:55:08 <rwbarton> without any -O it uses an extravagant 129,968 bytes
12:55:18 <nejucomo> I've heard ulimit works on address space range, not actual memory allocation sizes, so could the compiled output be using special address spaces?
12:55:34 <kirindave_> Can anyone recommend a good introduction to comonads? And when I say "good" I'd like to invoke the spirit of the Free Monad tutorial from haskell for all as a shining example of what I'd like to read.
12:55:44 <Cale> nejucomo: well, it's certainly nothing like a C program's memory layout
12:56:01 <nejucomo> rwbarton: For my input which is > 5 million primes, each represented as: show (index, prime) -on a separate line, the rss passed 1 gig.
12:56:04 <rwbarton> are you sure it wasn't the bzcat that was breaking the ulimit? it probably mmaps the input file
12:56:20 <nejucomo> The longest lines were less than I'd guess 25 characters.
12:56:34 <Cale> nejucomo: what do -s and -v represent?
12:56:36 <nejucomo> So maybe worst case size 125 million bytes.
12:56:37 <rwbarton> I am just wondering whether you weren't actually running the code you posted.
12:56:59 <nejucomo> Cale: I was afraid you'd ask.  I'd have to go read the manpage.
12:57:14 <rwbarton> ulimit -a says stack size              (kbytes, -s) 8192 / virtual memory          (kbytes, -v) unlimited
12:57:21 <nejucomo> I think -v is "virtual size" (in kb)... and -s is...
12:57:39 <Cale> "stack size" sounds like a crazy thing to try to limit in a Haskell program
12:57:51 <Cale> because how the hell does it know what GHC is using for a stack?
12:57:53 <nejucomo> Ah...
12:57:57 <Cale> GHC has multiple stacks
12:58:01 * nejucomo double checks .bashrc.
12:58:25 <nejucomo> Ok, so I do not set that ulimit in my personal configuration.  Maybe it's a debian thing?
12:58:28 * nejucomo pokes around.
12:58:58 <shachaf> nejucomo: That's my ulimit -s too.
12:59:05 <shachaf> I doubt it's an issue.
12:59:40 <shachaf> Does GHC actually use the OS stack for its "stack"?
12:59:57 <strebe> what does the Hom in HomSets stand for? (page 20 of Awodey)
12:59:57 <nejucomo> Sure enough, on another debian account where I don't run ulimit, ulimit -a shows the same stack size limit.
13:00:10 <rwbarton> the stack size limit is not an issue
13:00:22 <nejucomo> So the -O2 version ran fine.
13:00:29 <rwbarton> did you try without -O again?
13:00:49 <nejucomo> Hrm.  Another strangeness is that I ran this last night without -O2 and it worked just fine.
13:01:28 <rwbarton> you were probably just running some other version of the code that held onto ps somehow
13:01:31 <nejucomo> Here's the literal command and output (linux / debian / ghc 7.4.1):
13:01:32 <nejucomo> $ bzcat ./data/primes.bz2 | ./NthPrimeDelta | tee ./data/deltas | pv
13:01:32 <nejucomo> NthPrimeDelta: out of memory (requested 2097152 bytes)                                                                                                                                       ]
13:01:35 <shachaf> Isn't GHC supposed to have a smart recompilation checker these days such that if you run it with different -O it'll recompile?
13:01:36 <nejucomo>  
13:01:47 <nejucomo> (sorry for a paste, but it seemed short.)
13:02:17 * nejucomo deletes the build files and reruns ghc --make without a -O argument...
13:02:41 * hackagebot symbol 0.1.4 - A 'Symbol' type for fast symbol comparison.  http://hackage.haskell.org/package/symbol-0.1.4 (GeoffreyMainland)
13:02:42 <kmels> hi, I can't get this code to compile http://hpaste.org/76159, what should I be importing from template haskell?
13:03:10 <nejucomo> Actually, the code that succeeded was also a different commandline without tee or pv.
13:03:29 * nejucomo is running the newly compiled version.
13:03:29 <shachaf> kmels: People might be able to help you if you say what the problem is. :-)
13:04:04 <rwbarton> you should delete lines 2 and 3 for sure
13:04:15 <kmels> shachaf, of course sorry, error says: /home/kmels/tmp/th.lhs:16:18: parse error on input `$', that's like
13:04:21 <nejucomo> Hrm.  This version is also using <4 MiB rss, and virt is stable at 121 Mb.
13:04:34 <shachaf> kmels: Oh, that's a .lhs file.
13:04:38 <kmels> still.
13:04:38 <rwbarton> oh, I think the {-# LANGUAGE ... #-} stuff also needs > perhaps
13:04:39 <shachaf> Add > before your {-# lines.
13:04:39 <nejucomo> It may either have been something with the shell pipeline or some pebkac.
13:04:44 <nejucomo> Thanks for the suggestions.
13:04:47 <kmels> ah!
13:04:50 <kmels> -_-
13:04:53 <shachaf> kmels: Also, what rwbarton said. Lines 2 and 3 aren't helping.
13:05:02 <kmels> now it works
13:05:33 <kmels> thank you
13:07:41 * hackagebot iptables-helpers 0.4.1 - Static checking of iptables rules  http://hackage.haskell.org/package/iptables-helpers-0.4.1 (EvgenyTarasov)
13:09:26 <ski> strebe : "Hom" is short for "Homomorphism"
13:12:32 <acowley> I thought that use of hom was actually more general as it is a set of functions all of which have the same domain and codomain.
13:13:20 <acowley> For instance, it could be called a mor-set or morph-set
13:13:30 <acowley> given the way the definition tends to be worded
13:15:12 <strebe> ski: yeah, I read a little more carefully and hit wikipedia, but thank you.
13:20:14 <Cale> strebe: Yeah, that's one little place where the notation of category theory is influenced by its applications. Many category theorists prefer writing C(X,Y) in place of Hom(X,Y) (or Hom_C(X,Y)) to refer to the collection of arrows between X and Y in the category C, because apart from being more compact and being unambiguous about which category is being discussed, it also is a bit less presumptuous in some sense :)
13:21:14 <acowley> C(X,Y) 4 lyf
13:21:38 <Cale> strebe: In a lot of categories, the arrows really are some structure-preserving functions ("homomorphisms"), but this need not be the case.
13:22:19 <bfig> i'm having trouble using trace. i want to make some out of order executiion like this: a = trace (show something ++ " " ++ show a) (...)
13:22:37 <bfig> maybe its' not the best way to use it, but what are the limitations of trace?
13:23:10 <rwbarton> heh
13:23:16 <rwbarton> does that loop?
13:23:21 <bfig> no it explodes :p
13:23:24 <rwbarton> the mysteries of unsafePerformIO
13:23:36 <rwbarton> what do you mean by explodes
13:23:36 <Eduard_Munteanu> This is a good opportunity to remind you there's ##categorytheory ;)
13:23:41 <bfig> nothing happens :p
13:23:46 <rwbarton> oh weird
13:23:53 <shachaf> bfig: Isn't that the opposite of "explodes"?
13:24:03 <bfig> shachaf, well, it is like bottom
13:24:05 <rwbarton> anyways I recommend something like traceLabel s x = trace (s ++ show x) x
13:24:33 <ClaudiusMaximus> maybe it eats ram trying to pass an infinite CString to the debugprint function in the RTS
13:24:50 <monochrom> implode :)
13:24:52 <bfig> it makes the program die although it makes sense from a certain point of view and if it didn't make sense it should give me some error or whatever
13:25:10 <rwbarton> but it's odd because
13:25:12 <rwbarton> > fix error
13:25:13 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
13:25:16 <qasi> any papers that I can read about type families and type functions?
13:25:16 <bfig> the weird part is, what does it mean to show something that does a trace?
13:25:43 <bfig> i'm gonna go with your recommendation rwbarton
13:25:54 <rwbarton> well showing something that does a trace is no problem
13:26:15 <qasi> bfig, try evaluating a
13:26:16 <rwbarton> it will evaluate the thing, if the thing is being evaluated for the first time then the trace will happen
13:26:19 <qasi> bfig, like showing it afterwards
13:27:00 <monochrom> interesting, a = trace (show a ...
13:27:41 <bfig> i think the problem is that putting a trace in the middle makes the function not act as pure
13:28:04 <bfig> i thought that once the trace was executed it was all the same, but probably it is called every time 'a' is accessed
13:28:19 <rwbarton> the problem is in order to evaluate a you have to do the trace and in order to figure out what to print in the trace you have to evaluate a
13:29:11 <rwbarton> now it's not really clear to me whether this means it just works or it loops printing "something something something ..." or it loops printing nothing or what
13:29:15 <adnauseam> ello
13:29:18 <strebe> Cale: ahhh, thank you, that is a bit clearer :-)
13:29:26 <bfig> it just locks down, i need to Ctrl -c. nothing is printed
13:29:32 <bfig> but now it makes sense
13:29:52 <strebe> (My brain needs a break for the night by now, I was tired when I started, but this book is by far the best one I've seen on category theory, thanks again!)
13:30:04 <Cale> Yeah, no problem!
13:30:08 <bfig> which book?
13:30:12 <Cale> Awodey
13:30:37 <bfig> i should learn some CT :(
13:31:03 <Cale> bfig: check PM :)
13:31:18 <rwbarton> with ghc it prints <<loop>> even without any optimizations or -threaded
13:31:26 <bfig> =)
13:31:29 <monochrom> "r = trace (show r) 30 :: Int". this is a black hole. in ghci, you get silent idling for black holes. but try to add "main = print r" and compile to exe, and run the exe. you get "<<loop>>", telling you it's a black hole
13:31:54 <shachaf> monochrom: My ghci prints <<loop>> for black holes after a while.
13:31:54 <bfig> cool :)
13:32:01 <monochrom> oh, that's good
13:32:09 <rwbarton> how long is a while?
13:32:13 <shachaf> A few seconds.
13:32:18 <rwbarton> interesting
13:32:20 <shachaf> It also doesn't use 100% during that while. I wonder what it's doing.
13:32:24 <shachaf> Maybe it's happening after a GC?
13:32:52 <monochrom> black hole blocks the offending thread
13:33:10 <shachaf> 5-6 seconds, it looks like.
13:33:16 <parcs`> it's a new feature of 7.6
13:33:20 <monochrom> recall that ghci is built with -threaded, and moreover, by default, your commands are run in a forkIO thread
13:33:38 <shachaf> monochrom: But shouldn't it detect the black hole immediately?
13:33:59 <rwbarton> probably it is sending your program to the simons who check whether there is a loop
13:34:16 <monochrom> it certainly detects, that's why the RTS blocks the thread rather than busy-loop it. but it can choose to be silent
13:34:22 <elliott> IIRC threaded runtime does weird things to black holes.
13:34:23 <shachaf> Simon Says solve the halting problem
13:34:45 <shachaf> monochrom: I'm just wondering what's happening during those 5 seconds.
13:34:59 <parcs`> shachaf: run ghci with +RTS -B and see if the beep coincides with the exception being thrown
13:35:29 <shachaf> I don't get beeps. :-(
13:35:30 <monochrom> the child thread blocks because of black hole. the main thread blocks because it's waiting for child thread
13:35:57 <Cale> Oh, I wonder if it's doing what I thought might be a good idea at one point: after some delay, actually check in some fashion to see if there's another thread evaluating this thunk, and if so, give up on waiting.
13:35:59 <shachaf> shachaf@carbon:~$ ghc -ignore-dot-ghci -e 'let x = x in x' +RTS -B 2>&1 | xxd
13:36:19 <monochrom> and then possibly 7.6 has a watchdog or GC thread that wakes up every 5 seconds and kicks things
13:36:24 <shachaf> Bah, xxd is being buffered.
13:37:18 <shachaf> parcs`: Yes, there's one \a right before it prints <<loop>>
13:37:36 <shachaf> There are also a bunch that happen earlier, but I guess they could be unrelated.
13:38:31 <monochrom> ok, so the GC thread wakes up and finds the black hole and kicks it
13:39:28 <monochrom> (there has always been a GC thread that wakes up every several seconds, but different versions give it different powers and responsibilities)
13:39:38 <Sculptor> hi!
13:41:50 <bfig> I got pneumonia, and then I contracted this life-threatening, deadly illness called C. diff.
13:41:59 <bfig> http://en.wikipedia.org/wiki/Tig_Notaro
13:42:11 <monochrom> if you link your program by -threaded, your exe enjoys the same GC thread, too, which can mitigate some of your programming mistakes
13:42:23 <bfig> woops ww, sorry
13:43:15 <monochrom> for example you forget to close files, but your program has some idle time. the GC thread will close them for you. now you think you are so bugless...
13:43:25 <MrFenix> how long will it take to get a username for hackage?
13:43:37 <monochrom> until you take away "-threaded" and then your program will not close those files
13:46:24 <Attic> Hey could someone help me out with cabal? I'm trying to install darcs but I get this error https://gist.github.com/3875344 Not really sure how to fix it
13:46:44 <MrFenix> I just created https://github.com/JanBessai/transformers-runnable
13:47:11 <dino-> Attic: Trying to install darcs via cabal-install, as in building it?
13:47:20 <catkc> aloha. I'm having some difficulty with a set comprehension acting unpredictably. source: http://pastebin.com/eV9hDYAz
13:47:23 <maukd> The paste eV9hDYAz has been copied to http://hpaste.org/76160
13:47:29 <monochrom> lastly, (r = trace ("hi" ++ show r) 30) "does not print" hi because it prints hi but you haven't flushed the buffer
13:47:44 <dmwit> Attic: The simplest is probably to install darcs via your package manager instead. Second simplest is to cabal unpack darcs and try relaxing the dependency on base.
13:47:50 <dino-> Attic: tbh, I always use binaries of darcs, last time I was able to get a pkgbuild for Arch of it.
13:47:52 <rwbarton> does it only print one hi?
13:48:30 <Attic> Not sure about it, but I heard that AUR is outdated to hackage packages. But it should be fine then?
13:48:40 <Attic> Cabal feels like such a pain lol
13:49:06 <monochrom> it prints one hi, then black-hole
13:49:19 <rwbarton> I see
13:49:19 <dmwit> darcs doesn't change very quickly, and has good cross-version compatibility anyway.
13:49:23 <rwbarton> makes sense
13:49:24 <dino-> Attic: I just did this a couple of days ago from the aur , it got me 2.8.0
13:49:31 <catkc> never mind, I think I've got it.
13:49:46 <Attic> Ok, I'll try getting it on AUR then, thanks
13:49:51 <dino-> Attic: which is actually latest for Linux
13:49:55 <dino-> on darcs.net
13:50:08 <Nisstyre> dino-: last time I tried the pkgbuild for darcs in the AUR it did not build
13:50:18 <qasi> okay stupid question maybe, but how do you pronounce ::, ->, => and so on? I ask because I'm german, so I use some german name, but when giving talks in english I'd really like to use the "proper" names...
13:50:22 <Nisstyre> installing via cabal is the best option imo
13:50:27 <dmwit> dino-: eh? darcs.net and Hackage both have 2.8.2
13:50:39 <dmwit> oh, you mean binaries
13:50:40 <dmwit> okay
13:50:54 <rwbarton> "a -> b" I pronounce "a to b"
13:51:04 <Nisstyre> rwbarton: "a implies b"
13:51:14 <Nisstyre> or "a function from 'a' to 'b'"
13:51:17 <rwbarton> "e :: t" "e has type t" if it's a declaration
13:51:19 <qasi> Nisstyre, I use 'implies' for '=>' ?
13:51:22 <dmwit> Nisstyre: That very much depends on what you're trying to emphasize in your talk.
13:51:27 <dino-> Nisstyre: darcs-bin worked a couple of days ago for me, on a very fresh system. Someone last updated 2012-Aug  https://aur.archlinux.org/packages.php?ID=62086
13:51:41 <shachaf> Nisstyre: Go back to #agda.
13:51:43 <qasi> rwbarton, yeah, I also use "has type" for ::
13:51:43 <Nisstyre> dino-: okay, well, maybe it's been updated since I last tried it
13:51:52 <dino-> Nisstyre: But yeah, stuff gets stale in the aur. It's up to us to keep it working.
13:51:57 <dmwit> qasi: "c => a" I would probably say something like "a whenever constraints c hold" or something similar.
13:52:07 <dino-> community driven, like Hackage
13:52:14 <dmwit> e.g. "Num a => a -> a -> a" would be "a to a to a whenever a is a number"
13:52:22 <Nisstyre> yeah, "a must have the constraint that it is an instance of c", does that sound right?
13:52:23 <rwbarton> "e :: t" "e of type t" if it is an expression I guess
13:52:24 <qasi> dmwit, bit awkward when you have long types
13:52:29 <dmwit> yep
13:52:34 <acowley> Are fundeps the only way to have the same type be the codomain of two injective type-level functions?
13:52:34 <shachaf> I pronounce "e :: t" as "e colon colon t"
13:52:38 <catkc> on an unrelated note, sin pi is producing something close to zero, but not quite. Any way I can have it produce the correct value?
13:52:40 <rwbarton> that is good too
13:52:47 <qasi> dmwit, with lots of constraints: mkM :: (Typeable Typeable Monad m)
13:52:47 <qasi> a, Typeable b,
13:52:47 <qasi> (m a), Typeable (m b),
13:52:47 <qasi> => (b -> m b) -> a -> m a
13:53:03 <elliott> "Typeable Typeable Monad m"?
13:53:13 <monochrom> I erred. it does not print hi at all. I use NoBuffering on stdout and stderr, see nothing
13:53:18 <elliott> that type looks like complete nonsense
13:53:27 <dmwit> qasi: "a function converting b to m b into a to m a whenever everything is typeable and m is a monad"
13:53:29 <qasi> elliott, pasted that from a paper, went completely wrong
13:53:37 <qasi> I'll type it by hand
13:53:41 <qasi> or just...
13:53:42 <shachaf> acowley: What do you mean?
13:53:43 <qasi> :t mkM
13:53:44 <lambdabot> forall b (m :: * -> *) a. (Monad m, Typeable a, Typeable b) => (b -> m b) -> a -> m a
13:53:57 <qasi> ah, actually, that's not exactly it
13:54:02 <sipa> > (sin pi) :: CReal
13:54:04 <lambdabot>   0.0
13:54:12 <sipa> catkc: ^
13:54:20 <catkc> cheers
13:54:21 <sipa> > sin pi
13:54:22 <kwos> hello!
13:54:22 <lambdabot>   1.2246467991473532e-16
13:54:34 <qasi> mkM :: (Typeable a, Typeable b, Typeable (m a), Typeable (m b), Monad m) +> (b -> m b) -> a -> m a
13:54:41 <dino-> Nisstyre: as an additional note, there are kind of a pile of darcs* things in the aur, probably at least one that tries to build from source, and many marked out of date. So there's a lot in there that probably fails.
13:54:41 <qasi> ups, the + is a -
13:54:47 <jfischoff> hello kwos
13:54:48 <ion> > printf "%.3f" (sin pi :: Double) :: String
13:54:49 <lambdabot>   "0.000"
13:54:51 <monochrom> oh, I think know why. hPutStrLn has hi granularity
13:54:52 <qasi> so I think I would pronounce that as:
13:54:53 <Nisstyre> dino-: talk to the maintainers
13:54:58 <shachaf> > sin pi :: CReal
13:54:59 <lambdabot>   0.0
13:55:13 <shachaf> Oh, someone said that.
13:55:21 <ion> yeah
13:55:24 <Nisstyre> > exp $ sin (2*pi)
13:55:26 <lambdabot>   0.9999999999999998
13:55:44 <dmwit> > exp $ sin (2*pi) :: CReal
13:55:45 <lambdabot>   1.0
13:56:05 <qasi> "mk-m has the type, when the constraints hold that a, b, m a and m b are Typeable, as well as m being a Monad, then b to m b, to a to m a"
13:56:09 <rwbarton> monochrom: next challenge: explain why "fix error" works then
13:56:12 <shachaf> Of course the CReal Show instance is lying scum.
13:56:14 <qasi> not entirely unambigous, but good enough I guess
13:56:19 <qasi> and I'd want to show the type anyway
13:56:28 <dmwit> sounds reasonable
13:56:39 <dmwit> > 1.00000000000000000000000000000001 :: CReal
13:56:40 <lambdabot>   1.00000000000000000000000000000001
13:56:59 <dmwit> eh, I won't spam
13:57:05 <shachaf> dmwit: It's 40 digits.
13:57:12 <shachaf> Or is that just for Eq?
13:57:18 <shachaf> > 1.00000000000000000000000000000000000000001
13:57:19 <lambdabot>   1.0
13:57:26 <catkc> lying scum? how do you mean? this is my first "real" program in haskell. I moved over from C because I have no idea how to translate the maths I'm doing into that language
13:57:48 <shachaf> > 1.00000000000000000000000000000000000000001 :: CReal
13:57:49 <lambdabot>   1.0
13:58:07 <Nisstyre> is there a decimal type in the stdlib?
13:58:09 <dmwit> catkc: CReal numbers are arbitrarily precise, but have no introspection, so things like show and (==) choose a particular precision to operate on.
13:58:09 <shachaf> catkc: I'm not talking about your program. :-)
13:58:11 <qasi> now why is it Typeable (m a), Typeable (m b) in the paper but not in the actual lib?
13:58:15 <qasi> :t mkM
13:58:16 <lambdabot> forall b (m :: * -> *) a. (Monad m, Typeable a, Typeable b) => (b -> m b) -> a -> m a
13:58:39 <shachaf> I,I elimispection
13:58:45 <Nisstyre> ohh, Data.Decimal :P
13:58:53 <monochrom> oh yikes, I was misreading the source code of Debug.Trace. for GHC, it totally does not use hPutStrLn at all
13:58:55 <dmwit> qasi: Well, I would have expected a Typeable1 m constraint, which gives Typeable (m a) and Typeable (m b) for free.
13:59:03 <catkc> shachaf: I figured. I mean, I have very little experience upon which to understand most things said. You're talking to a novice who only knows basic C.
13:59:03 <qasi> maybe there's an instance Monad m, Typeable m, Typeable a => Typeable (m a)?
13:59:19 <shachaf> catkc: The C in CReal stands for Computable, not the language C.
13:59:25 <dmwit> qasi: Nearly. There's an instance (Typeable1 f, Typeable a) => Typeable (f a).
13:59:30 <Cale> Surely the Typeable instance shouldn't need a Monad constraint :)
13:59:30 <catkc> I also figured that.
13:59:37 <qasi> dmwit, ah okay
13:59:47 <qasi> dmwit, different kinds, I see
13:59:51 <dmwit> right
13:59:59 <dmwit> Future versions of the library may be able to fix this oddity.
14:00:03 <qasi> dmwit, but there is no Typeable1 constraint in that type...
14:00:09 <dmwit> (Hooray, kind polymorphism!)
14:00:17 <dmwit> qasi: Yes, I know, that's throwing me off, too.
14:00:20 <catkc> But I mean, in turn, that the sum total of my experience with programming anything, at all, is C.
14:00:22 <qasi> or maybe you don't really need it.
14:00:29 <catkc> I'll be quiet now, thank you for your help :)
14:00:33 <qasi> what's the lambdabot command to show source again?
14:00:42 <hpc> @src Maybe
14:00:42 <lambdabot> data Maybe a = Nothing | Just a
14:00:42 <monochrom> it calls (withCString (your string here) $ \cmsg -> a foreign function for printing cmsg). that is going to need the whole string forced before any printing begins
14:00:47 <qasi> @src mkM
14:00:47 <lambdabot> Source not found. My brain just exploded
14:00:56 <qasi> hpc, thanks anyway 8)
14:00:59 <byorgey> @hoogle mkM
14:00:59 <lambdabot> Data.Generics.Aliases mkM :: (Monad m, Typeable a, Typeable b) => (b -> m b) -> a -> m a
14:00:59 <lambdabot> Data.Graph.Inductive.NodeMap mkMapGraph :: (Ord a, DynGraph g) => [a] -> [(a, a, b)] -> (g a b, NodeMap a)
14:00:59 <lambdabot> Language.Haskell.TH.Syntax mkModName :: String -> ModName
14:01:05 <Cale> qasi: The lambdabot src command is very limited in terms of what it knows about
14:01:09 <hpc> the @src database is woefully incomplete
14:01:11 <monochrom> (trace (cycle "hi ") blah) takes infinite memory :)
14:01:12 <hpc> and sometimes wrong
14:01:13 <Cale> and it doesn't have the real source
14:01:20 <shachaf> @src CReal
14:01:20 <ClaudiusMaximus> monochrom: 21:24 < ClaudiusMaximus> maybe it eats ram trying to pass an infinite CString to the debugprint function in the RTS
14:01:21 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
14:01:26 <Nisstyre> @src Data.Function.on
14:01:26 <lambdabot> Source not found. Are you on drugs?
14:01:28 <byorgey> qasi: @src just consults a text file with definitions of stuff from the Prelude, it's fairly dumb
14:01:31 <Nisstyre> @src on
14:01:32 <lambdabot> (*) `on` f = \x y -> f x * f y
14:01:38 <rwbarton> monochrom, I see, while printing when an unhandled exception occurred probably uses some other built-in code path
14:01:41 <S11001001> on is the coolest
14:01:45 <qasi> byorgey, did not expect that.
14:01:50 <byorgey> me neither.
14:01:51 <monochrom> yeah, what ClaudiusMaximus says
14:02:10 <Nisstyre> that is a pretty implementation of on
14:02:13 <qasi> mkM = extM return
14:02:14 * ClaudiusMaximus sleepytime now
14:02:15 <qasi> great.
14:02:19 <monochrom> "fix error" goes through a sane printer
14:02:54 <qasi> but the type given in the source indeed only has the constraints Monad m, Typeable a, Typeable b
14:03:25 <qasi> so Typeable (m {a,b}) probably wasn't needed to begin with
14:04:09 <parcs`> > tan (pi/2)
14:04:11 <lambdabot>   1.633123935319537e16
14:04:20 <qasi> and the source in the paper is
14:04:27 <rwbarton> > tan (pi/2) :: CReal
14:04:31 <lambdabot>   mueval-core: Time limit exceeded
14:04:35 <qasi> mkM f = cast case f of Just g -> g; Nothing -> return
14:04:57 <dmwit> > id case 3 of 3 -> 3
14:04:59 <lambdabot>   <no location info>: parse error on input `case'
14:05:07 <qasi> I guess that does not need Typeable (m {a,b}), since it's never casted/typechecked
14:05:18 <rwbarton> do you mean "case cast f of"
14:05:18 <qasi> a is casted to b
14:05:20 <monochrom> it was fun debugging Debug :)
14:05:31 <hpc> monochrom: ha, awesome
14:05:32 <troydm> is Monad m => m a   equally the same as (\x -> (x,w)) ?
14:05:35 <dmwit> rwbarton: maybe cast $ case f of
14:05:36 <qasi> rwbarton, yes, sorry, typo
14:05:42 <hpc> @remember monochrom it was fun debugging Debug :)
14:05:42 <lambdabot> Nice!
14:05:51 <shachaf> Debuggin' the Debeguine.
14:05:55 <mapf`> > let a = a in a
14:05:58 <lambdabot>   mueval-core: Time limit exceeded
14:06:08 <dmwit> troydm: no
14:06:19 <shachaf> tranma: No.
14:06:21 <dmwit> troydm: In fact, it's a bit of a weird question, because one is a type and the other isn't.
14:06:23 <qasi> dmwit, heh, nice, but that's not it
14:07:17 <dmwit> :t cast
14:07:19 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
14:07:34 <dmwit> :t \f -> cast $ case f of Just g -> g; Nothing -> return -- just out of curiosity
14:07:35 <lambdabot> forall b a (m :: * -> *). (Typeable a, Typeable1 m, Typeable b, Monad m) => Maybe (a -> m a) -> Maybe b
14:07:41 <troydm> dmwit: well i was kinda a reading about IO actions being World -> ((),World)
14:07:57 <troydm> dmwit: i to tell you the truth i don't quite get it
14:08:01 <shachaf> I like how people write code like "case cast v of Just ... -> ...; _ -> case cast v of Just ... -> ...; _ -> ..."
14:08:05 <dmwit> troydm: I see.
14:08:13 <dmwit> troydm: Okay, a few things to clear up:
14:08:13 <byorgey> troydm: you should strike that from your memory
14:08:21 <dmwit> troydm: First of all, not all monads are IO. =)
14:08:23 <monochrom> we need type-case!
14:08:37 <troydm> dmwit: yeah that i get it
14:08:38 <dmwit> troydm: Second: have you grokked the State monad yet? If not, that would be a good place to start.
14:08:54 <troydm> dmwit: no i haven't yet
14:08:59 <troydm> ok i'll take a look
14:09:01 <Nisstyre> shachaf: you should see my Racket code, I tend to nest matches >.>
14:09:02 <troydm> thx
14:09:05 <maukd> there is no RealWorld :-|
14:09:06 <Nisstyre> it's similar to that
14:09:09 <dmwit> I have some good tutorials in my bookmarks, let me link you one.
14:09:14 <troydm> i kinda have a mixed feelings about Monads
14:09:27 <troydm> sometimes i think i understand them
14:09:38 <nor> <>io> is monad a cofunctor?
14:09:46 <troydm> but most times i think i understand nothing of Monads
14:09:57 <Nisstyre> troydm: do you understand type classes?
14:09:59 <byorgey> nor: what?
14:10:06 <troydm> Nisstyre: yes
14:10:16 <byorgey> troydm: do you understand Functor?
14:10:18 <dmwit> argh, All About Monads has moved again?
14:10:33 <Nisstyre> troydm: okay, well it's not that difficult to understand the Monad type class after using some things that are instances of Monad for a while
14:10:43 <troydm> byorgey: isn't Functor the part of Monad ?
14:10:46 <bfig> if i'm looking for a dictionary structure that has a 'lookup' by some partial information, enough to give me a definite ordering but not the whole object, and that might give me a multiset, is there something like that already done?
14:10:58 <Nisstyre> byorgey: Functor is a separate type class entirely
14:10:59 <nor> > map ((/3) . flip) [15,30,300]
14:11:00 <lambdabot>   No instances for (GHC.Real.Fractional (f b),
14:11:01 <lambdabot>                    GHC.Num.Num...
14:11:02 <dmwit> troydm: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html http://www.haskell.org/haskellwiki/All_about_monads http://scienceblogs.com/goodmath/2007/01/29/more-monads-stateful-programmi-1/
14:11:03 <byorgey> troydm: every monad is also a functor.
14:11:19 <dmwit> troydm: The first two links are general monad tutorials, but also have very fine sections on the state monad.
14:11:19 <Nisstyre> but yes, they are closely related as byorgey said
14:11:25 <nor> > 30 / 3
14:11:26 <lambdabot>   10.0
14:11:33 <troydm> thx
14:11:37 <dmwit> The Typeclassopedia is also a fine resource for this, though I don't know if it talks specifically about State. =)
14:11:43 <troydm> i'll read into them
14:11:52 <byorgey> it mentions State, but not in depth
14:12:00 <nor> > map (3 . flip) [(/15),(/30),(/300)]
14:12:02 <lambdabot>   [3,3,3]
14:12:02 <troydm> that is actually my second attempt to grok Monads and Haskell
14:12:09 <Soultaker> does haskell have a syntax comparable to Python's (x < y < z)?
14:12:16 <Soultaker> or must this be written as (x < y) && (y < z)?
14:12:17 <nor> > flip (-3) 4
14:12:18 <lambdabot>   No instance for (GHC.Show.Show (f b))
14:12:18 <lambdabot>    arising from a use of `M3765145478...
14:12:21 <dmwit> troydm: As others have mentioned, State isn't a 100% accurate way to understand IO. But it's a halfway decent first approximation.
14:12:23 <Nisstyre> Soultaker: you mean is < transitive in Haskell?
14:12:25 <troydm> the funny thing is i've understand and learned Erlang in just a bout few weeks
14:12:25 <shachaf> Soultaker: No, but you can write a function that takes a list.
14:12:26 <nor> > 4 . flip (-3)
14:12:27 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b1)
14:12:28 <lambdabot>    arising from a use of ...
14:12:38 <shachaf> Nisstyre: No. Python lets you write (x < y < z) for (x < y && y < z)
14:12:41 <qasi> ok, something else entirely: leaving out universal quantification, can GADT syntax do anything that the normal anonymous syntax can't? constraints I guess?
14:12:58 <byorgey> qasi: you mean leaving out existential quantification?
14:13:04 <dmwit> troydm: As for "grokking monads", I think it's easiest to grok a couple type constructors that happen to be monads first, and then see the generalization second (one of the reasons I liked "You Could Have Invented Monads" so well).
14:13:06 <qasi> byorgey, I'm sorry, yes
14:13:19 <byorgey> qasi: GADTs = ADTs + existential quantification + type equality constraints
14:13:32 <qasi> byorgey, that sums it up nicely, thanks
14:14:12 <qasi> byorgey, okay this may be totally stupid, but why is it existential quantification when it uses forall?
14:14:14 <Nisstyre> shachaf: oh, I forgot about that
14:14:17 <troydm> dmwit: actually you know i kinda understand Monads generally but the hardest thing for me is to understand how World -> ((),World) maps to IO
14:14:34 <Nisstyre> shachaf: that's kind of a wart on python now that I think about it
14:14:39 <troydm> dmwit: i was reading this http://is.gd/49mcxr
14:14:39 <monochrom> it takes infinite time to learn something that does not exist. for example "the 'meaning' of monad"
14:14:45 <Philonous> troydm:  That's an implementation detail of GHC
14:14:48 <dmwit> troydm: Well, actually, World -> ((),World) maps to IO (), sort of.
14:15:04 <troydm> dmwit: the last part of it explaining IO and World -> ((), World)
14:15:04 <shachaf> Nisstyre: (1 < 2 in xs) means (1 < 2) && (2 in xs)!
14:15:16 <troydm> dmwit: and i undertand 0% of it
14:15:21 <dmwit> troydm: The idea being that the "World" type represents all the data that isn't in the computation -- the state of the LCD screens, the bits that are going to appear/be sent on the network, etc.
14:15:33 <shachaf> qasi: GHC doesn't have first-class existentials.
14:15:34 <qasi> troydm, think about IO being a State monad, and the State is World?
14:15:44 <dmwit> troydm: So a function which takes in the current state of the world, and returns a new state of the world, is one that does a bit of IO. =)
14:15:50 <Nisstyre> shachaf: well, I guess in has a higher precedence than <
14:16:05 <shachaf> Nisstyre: It's not really about precedence, is it?
14:16:05 <qasi> shachaf, meaning? (I know I should have taken a logic class!)
14:16:18 <Nisstyre> shachaf: maybe not
14:16:30 <monochrom> but it only takes a short time to: get fluency in types, use that to appreciate the types of "return" and ">>=", and understand a dozen of concrete examples.
14:16:36 <troydm> dmwit: thx, i think i'll try reading about State monad first
14:16:42 <shachaf> qasi: Meaning that you can't say "exists" directly. If you could, you'd be able to say something like data Foo = Foo (exists a. (a,a -> Int))
14:16:47 <byorgey> qasi: note that  (exists a. T1 a) -> T2   is isomorphic to   forall a. T1 a -> T2
14:16:48 <Philonous> troydm:  That is actually a horrible way of thinking about IO.
14:16:49 <Nisstyre> shachaf: that expression as you explained it, makes no sense to me at all
14:17:06 <dmwit> It's not a horrible way of thinking about IO. It's a bit inaccurate, but it's not horrible.
14:17:08 <shachaf> qasi: As it is you can write data Foo = forall a. Foo (a,a -> Int), which works out to the same thing.
14:17:09 <troydm> Philonous: that article?
14:17:18 <byorgey> qasi: which is why Haskell can get away with always representing existential quantification in terms of universal.
14:17:29 <shachaf> Nisstyre: "in" means "`elem`", except it's a keyword.
14:17:30 <qasi> byorgey, didn't know that. thanks.
14:17:53 <troydm> yeah but that would mean that IO a == World -> (a,World) is it not?
14:17:54 <shachaf> Nisstyre: "a FOO b BAR c" means "(a FOO b) && (b BAR c)" for all FOO and BAR in a certain class of operators.
14:18:22 <dmwit> troydm: That's the intuition, yes.
14:18:23 <Nisstyre> shachaf: well, I know that, I just don't understand how it gets parsed as being both (or (< 1 2) (in 2 xs))
14:19:00 <shachaf> Nisstyre: "in" is one of this class of operators.
14:19:07 <Nisstyre> shachaf: okay, fair enough
14:19:08 <shachaf> Nisstyre: It's like 1 < 2 <= 3
14:19:14 <troydm> dmwit: i think i'm at the momentum were i need to really write some real world software in Haskell in order to understand it better
14:19:37 <monochrom> "real world software" is too overwhelming
14:19:39 <shachaf> qasi: If you think about it for a while it'll make sense. :-)
14:19:53 <dmwit> Oh, in that case, you want this one: http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html =)
14:20:01 <shachaf> qasi: The difference between "forall a." and "exists a." is who gets to/has to choose what "a" is.
14:20:15 <troydm> dmwit: thx i'll look into that :)
14:20:20 <Philonous> troydm:  I meant thinking of IO a as "Realworld -> (a, Realworld)" . I haven't read that particular article
14:20:46 <qasi> shachaf, where it's "fixed", basically?
14:20:57 <shachaf> qasi: What's fixed?
14:22:27 <qasi> shachaf, not.. free? :D okay I think that won't help you either... I'm thinking about stuff like forall a exists b : a + b = c. what I mean is, in this case, when looking at b, I regard a as "fixed" (it has already been chosen), but I still can freely choose b. one token later and b is chosen as well
14:22:57 <shachaf> qasi: Yep, that seems like a reasonable way of looking at it.
14:22:57 <monochrom> perhaps it means: "I have f::t->t, the caller says f True, this fixes t to Bool"
14:23:10 <qasi> shachaf, cool
14:23:40 <shachaf> qasi: When you write "∀ a. ∃ b. : a + b = 5", someone else can choose any "a", but *you* can choose any "b".
14:23:49 <hpc> qasi: i think what ends up tripping people up is they don't realize 'a' is fixed to the value of "anything"
14:24:05 <shachaf> These are sometimes two different meanings of the word "any" -- I think monochrom wrote about that. :-)
14:24:13 <qasi> heheh
14:24:21 <monochrom> there is no "value of anything"
14:24:23 <hpc> mono called me out on it the other day in -blah
14:24:25 <qasi> subtle
14:24:27 <hpc> it was pretty funny
14:24:30 <bfig> something like ' Ord a =>   (b -> c -> Ordering) ->OrderedMdict b -> [b] '
14:24:33 <qasi> should have taken a logic class ;)
14:24:49 <bfig> * like ' Ord a =>   (a -> b -> Ordering) ->OrderedMdict a -> [a] '
14:24:57 <monochrom> some logic classes don't make it clear, either
14:25:21 <dmwit> bfig: huh?
14:25:50 <Philonous> troydm:  And btw. that is not the "real type" of IO. IO is an abstract type (constructor), it's opaque to the programmer (unless you get into internals of GHC, but GHC is not haskell)
14:26:00 <qasi> I have some experience with agda and there was very existential quantification in there which I had to use, but it's long ago. plus, dependent types made a lot of it different. I think I was using the existential quantification mostly for things which were more values than types, though what a value is, is of course is kind of fluid in Agda...
14:26:22 <shachaf> qasi: The dependent type way of looking at it is the simplest. :-)
14:26:31 <bfig> i want to have a structure 'OrderedMdict a' that allows me to do those kind of searches where i pass it a function that let's me lookup like it was a binary search tree
14:26:33 <qasi> shachaf, yeah?
14:26:39 <shachaf> qasi: forall a. ...a... means (a:Set) -> ...
14:26:43 <hpc> shachaf: well, agda's dependent way
14:26:46 <troydm> Philonous: ic
14:26:47 <qasi> hpc, oh, yeah!
14:26:49 <shachaf> qasi: exists a. ...a... means ((a:Set), ...a...)
14:26:52 <shachaf> hpc: Well, yes.
14:26:59 <qasi> shachaf, oh, yeah!
14:27:04 <hpc> scala has tinges of dependent types, but they look wonk because subtyping :P
14:27:25 <bfig> i'm going to implement it and post it in a paste. if it is done already i'd like to use previously programmed structures
14:27:31 <bfig> (it will be pretty inefficient)
14:27:40 <qasi> that "oh, yeah!" was meant for shachaf not hpc. but "oh yeah" to you, too, hpc ;)
14:27:42 <ski> (.. "anything" is a side-effectful term in natural language)
14:28:21 <shachaf> ski: Natural language scoping rules are too hard for me to understand.
14:28:33 <qasi> shachaf, I don't think I really get your second line. a tuple?
14:28:51 <shachaf> qasi: Yes. You have to provide both a type and a value that uses that type.
14:28:58 <ski> shachaf : Chung Shieh-Chan (et al.) have written some papers on this
14:28:58 <qasi> shachaf, or maybe I have a slight idea what you're hinting at...
14:29:01 <qasi> shachaf, aah.
14:29:05 <shachaf> qasi: For example (Int, 5)
14:29:15 <shachaf> Of course, the person *using* that tuple can't do anything useful with it.
14:29:25 <ludde> Hi can someone help me with an easy haskell function, please pm me
14:29:30 <shachaf> But let's say you have ((a:Set), a, a -> Int)
14:29:31 <dmwit> ludde: No, ask here.
14:29:36 <dmwit> ?hpaste
14:29:37 <lambdabot> Haskell pastebin: http://hpaste.org/
14:29:39 <bfig> how can i represent this without ghc complaining: data Ord a => MyDict a ?
14:29:43 <shachaf> Then you might have the value (String,"hello",length)
14:29:55 <dmwit> bfig: You can't (well, shouldn't).
14:30:03 <dmwit> bfig: Put those constraints on the functions that need them, instead.
14:30:14 <shachaf> qasi: Now someone can take that tuple and get an Int out of it, because they know that the two "a"s are the same.
14:30:22 <bfig> ok. well, they kinda belong to a typeclass anyway
14:30:43 <qasi> shachaf, ah, I see
14:30:46 <shachaf> qasi: (Getting an Int out of it is the *only* thing you can do with that tuple, though. So you might as well just use an Int directly.)
14:31:00 <qasi> but maybe there
14:31:12 <qasi> there's also a -> Bool in it
14:31:15 <qasi> for example.
14:31:21 <shachaf> In which case it's isomorphic to (Int,Bool). :-)
14:31:29 <shachaf> But there are certainly use cases for exists.
14:31:34 <qasi> hm, also true 8)
14:31:58 <shachaf> ((a:Set), a, (a -> a), (a -> Int)) corresponds to a stream of Ints.
14:32:25 <shachaf> qasi: Now to see how exists can be converted to forall, you just need to put it in negative position (i.e., as an argument to a function)
14:32:49 <shachaf> foo : ((a:Set), a, (a -> Int)) -> Int
14:32:50 * hackagebot mainland-pretty 0.2.3 - Pretty printing designed for printing source code.  http://hackage.haskell.org/package/mainland-pretty-0.2.3 (GeoffreyMainland)
14:32:51 <timthelion> merijn: I was making a wild assumption based on Ocams razor :P
14:32:52 * hackagebot mainland-pretty 0.2.4 - Pretty printing designed for printing source code.  http://hackage.haskell.org/package/mainland-pretty-0.2.4 (GeoffreyMainland)
14:33:03 <timthelion> wrong channel...
14:33:03 <shachaf> By currying foo, you get foo : (a : Set) -> a -> (a -> Int) -> Int
14:33:25 <shachaf> See how that works? You're still passing in the same three values, they're just curried.
14:33:39 <qasi> aaah, yes
14:34:08 <shachaf> Now you can see why ((exists a. Foo a) -> r) ~ (forall a. (Foo a -> r))
14:34:30 <qasi> yes, thanks
14:34:56 <qasi> it's just rearranged
14:35:15 <shachaf> qasi: The same thing works with GADTs. Instead of writing data Foo where { MkFoo :: (exists a. a) -> Foo }, you write data Foo where { MkFoo :: forall a. a -> Foo }
14:35:20 <atriq> Has anyone used TardisT seriously?
14:35:28 <shachaf> atriq: I doubt it.
14:35:56 <qasi> shachaf, cool
14:35:56 <atriq> I can't think of anything that COULD use it
14:36:38 <qasi> shachaf, by the way, you used the term "negative"... I often hear about "positive types", I guess that's related? I think I remember them having the property to be not infinite or something?
14:36:58 <shachaf> qasi: I don't think it's related to being infinite.
14:37:55 <shachaf> qasi: In the type "(a -> b) -> c", "c" is positive and "(a -> b)" is negative. But then "a" is positive again, because it's twice-negative.
14:38:30 <shachaf> "negative" means "on the left side of (an odd number of) (->)".
14:38:32 <Cale> qasi: Yeah, it's a term given to positions in types relative to function arrows.
14:38:46 <n-dolio> qasi: The positive and negative you're thinking of is a different positive and negative.
14:38:49 <Cale> The intuition for it comes from logic
14:38:51 <thoughtpolice> yeah, the way edwardk explained it was just that you start positive, and for every -> you end up on the LHS of, you flip sign
14:39:15 <n-dolio> Although, perhaps subtly related.
14:39:21 <Cale> A -> B that is, "A implies B" means "B or not A"
14:39:32 <Cale> so the A is "negated"
14:39:40 <jfischoff> ah
14:39:40 <qasi> oh
14:39:50 <qasi> that's incredibly intuitive
14:39:58 <shachaf> n-dolio: What are the positive and negative qasi is thinking of?
14:40:00 <Lutin`> And the negation is what lets you go between forall a. exists a.
14:40:01 <qasi> I was really wondering about that
14:40:22 <n-dolio> shachaf: The stuff Harper was talking about in that one blog post.
14:40:41 <n-dolio> Where positive types are data, and negative types are codata, _maybe_.
14:40:46 <shachaf> Cale: But you can't go from (a -> b) to Either (Not a) b. :-)
14:41:08 <n-dolio> Or in some presentations, you distinguish between positive data and negative continuations.
14:41:09 <qasi> so, Int is a positive type. Int -> Int is a negative type. but Int -> Int -> Int is a positive type, again?
14:41:14 <Cale> shachaf: at least not without call/cc
14:41:16 <james_> de
14:41:17 <ski> shachaf : nitpick, s/positive/occurs positively/, mutatis mutandis for "negative"
14:41:17 <james_> freenodede
14:41:18 <james_> freenodede
14:41:28 <shachaf> ski: Fair enough.
14:41:47 <dmwit> uh, not quite
14:41:49 <qasi> or are we just talking about the individual types in that type? so you just say "the second Int in that type occurs negatively"?
14:42:06 <dmwit> qasi: Int appears positively in Int; Int appears negatively in Int -> String; String appears positively in Int -> String
14:42:06 <ski> a negative type is one which is isomorphic to `Not a', for some `a'
14:42:12 <shachaf> qasi: Positive and negative refer to *positions* in a type, not to a type itself.
14:42:13 <thoughtpolice> qasi: individually. if you have a -> b, then 'a' is in negative position. if you were to have (a -> b) -> b, it's back in positive.
14:42:38 <qasi> shachaf, okay, good
14:42:39 <rwbarton> normally one talks about appearances of type variables
14:42:50 <dmwit> qasi: In Int -> Char -> String, Int and Char are both negative and String is positive (because it is Int -> (Char -> String)).
14:42:52 <ski> (usually a structural definition is made, though)
14:43:00 <shachaf> :: forall String Int. (String -> Int) -> Int
14:43:01 <Cale> Another way in which to think about it is the interaction between the user of a definition and the code which makes up that definition
14:43:05 <thoughtpolice> yeah, i've never heard of someone refer to a non-type variable in terms of positive/negative types
14:43:43 <Cale> The types in negative positions are types of things which are supplied by the user of a term, and the types in positive positions are things which are supplied by the term itself.
14:44:16 <n-dolio> ski: That's not how Harper was using it. He actually meant codata for negative types. But I'm not sure he's using it the same way as anyone else.
14:44:41 <ski> n-dolio : hm, which Harper is that ?
14:44:48 <n-dolio> Bob Harper.
14:45:06 <ski> any relevant paper (blog post ?) ?
14:45:22 <n-dolio> His blog is called Existential Type, i believe.
14:45:52 <qasi> Cale, I see, yes. in (a -> b) -> c, I have to supply a to use a -> b, but I get b, right?
14:46:04 <n-dolio> He wrote some post about how call-by-push-value shows that you want to do eager/strict evaluation for inductive/positive types and lazy evaluation for coinductive/negative types.
14:46:05 <shachaf> Someone should make a weblog that trolls ML people and call it Universal Type.
14:46:09 <n-dolio> Which is incorrect, but....
14:46:13 <shachaf> qasi: If "you" are the implementor of the function, then yes.
14:46:18 <qasi> shachaf, yes
14:46:21 <Cale> qasi: yes, from the point of view of the one implementing the function, right
14:46:27 <qasi> cool
14:46:28 <shachaf> If "you" are the user of the function, it's the opposite: You have to be able to produce a "b" for any "a".
14:46:31 <ski> qasi : assume we start with `<type> ::= Bool | <type> -> <type> | (<type>,<type>) | Either <type> <type>'
14:46:32 <shachaf> But if you can do that, then you can get a "c".
14:47:00 <Cale> shachaf: That is such a good idea
14:47:18 <shachaf> Cale: ?
14:47:18 <qasi> shachaf, makes sense, yes
14:47:28 <Cale> shachaf: the Universal Type thing
14:47:34 <shachaf> Oh.
14:47:37 <ski> qasi : then we can define (one-hole) contexts as `<cxt> ::= * | <cxt> -> <type> | <type> -> <cxt> | (<cxt>,<type>) | (<type>,<cxt>) | Either <cxt> <type> | Either <type> <cxt>'
14:48:22 <ski> qasi : there is an obvious operation `plug :: <cxt> -> <type> -> <type>', where `plug c t' would normally be written as `c[t]'
14:48:37 <qasi> ski, makes sense, yes
14:48:52 <ski> qasi : `*' represents the (single) "hole" in a context
14:49:34 <ski> qasi : now we can "split" this into
14:49:59 <shachaf> If Haskell had first-class existentials, how would you write the equivalent of data Foo = forall a. Foo a (a -> Int)?
14:50:05 <ski> qasi : and negative contexts `<neg> ::= <pos> -> <type> | <type> -> <neg> | (<neg>,<type>) | (<type>,<neg>) | Either <neg> <type> | Either <type> <neg>'
14:50:12 <shachaf> data Foo = forall a. Foo (exists a. a (a -> Int)) doesn't mae sense, of course.
14:50:31 <ski> (qasi : note there's no `*' directly appearing in the definition of a negative context)
14:50:31 <n-dolio> shachaf: newtype Foo = Foo (exists a. (a, a -> Int))
14:50:35 <shachaf> Or would you write a parameterized "Foo" and then use it with "exists"?
14:50:42 <shachaf> n-dolio: I'll take that as a yes.
14:51:04 <Cale> http://www.youtube.com/watch?v=KJe9H6qS82I -- implementing this in Haskell seems like it would be a really nice application for Repa
14:51:44 <ski> qasi : so a specific occurance of `t' occuring positively in `u' means that there is some positive context `c' such that `u' is `c[t]'
14:51:48 <hiptobecubic> Cale, it's beautiful
14:51:51 <Lutin`> Cale: That video is mesmerizing
14:51:55 <ski> qasi : and similarly for occuring negatively and negative context
14:52:01 <Lutin`> When I saw it earlier I watched it several times
14:52:09 <jfischoff> Cale: have you seen this? http://www.slideshare.net/kizzx2/repagolpdf
14:52:10 <shachaf> Cale: It seems like the sort of thing conal would appreciate.
14:52:10 <qasi> ski, wait. you said "now we can split this into" and then the next thing was "and negative contexts". is there something missing?
14:52:20 <Cale> Have you tried the actual program?
14:52:22 <shachaf> Except he'd want continuous time too. :-)
14:52:28 <qasi> ski, the definition of positive contexts <pos> I guess?
14:52:31 <Cale> It's so fun to tweak the parameters
14:52:33 <ski> er
14:52:58 <jfischoff> Cale: I wonder how easily you could just copy that code and tweak it
14:52:58 <Cale> there's a smooth continuum of life/death settings
14:53:07 <ski> qasi : positive contexts `<pos> ::= * | <neg> -> <type> | <type> -> <pos> | (<pos>,<type>) | (<type>,<pos>) | Either <pos> <type> | Either <type> <pos>'
14:53:20 <ski> qasi : sorry, for some reason that didn't make it through
14:53:25 <qasi> ski, ah, thanks
14:53:40 <Lutin`> Here is the paper describing it http://arxiv.org/abs/1111.1567
14:54:09 <Lutin`> PDF here http://arxiv.org/pdf/1111.1567v2
14:54:12 <ski> qasi : the differences between the definition of `<pos>' and `<neg>' is : (a) `<pos>' and `<neg>' have swapped roles, throughout; (b) only `<pos>' has `*' as an alternative, `<neg>' doesn't
14:54:40 <qasi> ski, I see
14:54:41 <Cale> You'd need to construct large stencils, I think.
14:55:03 <ski> qasi : often one also defines *strictly* positive contexts `<spos> ::= * | <type> -> <spos> | (<spos>,<type>) | (<type>,<spos>) | Either <spos> <type> | Either <type> <spos>'
14:55:21 <ski> qasi : so in this case, we don't allow "going through an even number of negative contexts"
14:55:28 <Cale> and of course, it's all done with floating point values instead of integers
14:56:28 <ski> qasi : it's easy to extend these with `forall' and `exists' if you want to, btw
14:56:41 <qasi> ah
14:57:00 <qasi> strictly positive contexts, interesting...
14:57:04 <qasi> any interesting properties?
14:57:30 <ski> qasi : anyway, `t' counts as occuring negatively in `t -> u' because `->' is contravariant in its left argument
14:57:55 <ski> contravariance flips between negative and positive occurance, while covariance keeps it
14:58:03 <jfischoff> Cale: larger stencils with repa are a little more involved then the method used in that paper
14:58:15 <jfischoff> Cale: but still do able
14:58:26 <qasi> ski, that's a nice way to see this
14:58:31 <catkc> given that Random is in haskell98, is there any way I can get random numbers in something using the base and haskell2010 packages?
14:58:54 <catkc> or must I rewrite my program to work with haskell98? pardon my lack of correct jargon.
14:58:55 <dmwit> System.Random
14:58:56 <qasi> ski, yeah thanks, I think I got it now
14:58:56 <c_wraith> catkc: is there any reason you can't use the random package?
14:59:15 <c_wraith> oh, I think dmwit's answer is the one you're looking for
14:59:57 <ski> qasi : anyway, the main point is to explicitly define the contexts to be able to talk about a specific position in a type/proposition -- having done that, it's (hopefully) easy to understand what is meant
14:59:58 <qasi> and as an implementor of a function with type a -> b, the signs in a flip for me
15:00:01 <catkc> well, stackoverflow says there's no way to get System.Random if I've got haskell98 hidden, which I understand it needs to be if I'm using base and haskell2010?
15:00:13 <rwbarton> it probably says that about Random
15:00:15 <rwbarton> not System.Random
15:00:24 <rwbarton> System.Random is the haskell 2010 name for the haskell 98 module Random
15:00:38 <shachaf> In the next version it'll be called System.System.Random
15:00:54 <Lutin`> Control.System.Random
15:01:01 <ski> qasi : yes, thinking in terms of what "I" (the implementor, the callee) has to compute, and what "you" (the environent, the caller) has to compute is also a good intuition
15:01:04 <shachaf> Revised.Revised.Revised.Report
15:01:10 <catkc> lol
15:01:29 <qasi> ski, cool
15:01:33 <qasi> interesting, never thought about that
15:01:43 <qasi> well I guess in a certain way, I have, when looking at complex types
15:02:06 <ski> qasi : re interesting properties, i think Agda has some restrictions about how one is allowed to declare data types, which involve strict positivity
15:02:14 <Saizan> i'm trying to find a post about monads being category with a speicific extra property, anyone remembers it?
15:03:15 <qasi> ski, right, I think this is what I was getting at
15:05:08 <ski> qasi : it can also be interesting to define a purely negative type/proposition by `<pneg> ::= false | <prop> -> <pneg> | <pneg> /\ <pneg> | forall x. <pneg>'
15:06:18 <ski> qasi : then one can e.g. prove that if `A \/ not A |- B' is provable intuitionistically, where `B' is purely negative, then so is `|- B'
15:06:38 <ski> (iow, proving a negative proposition, one may freely emply principle of omniscience)
15:07:00 <zhulikas> is hakyll preferred way to generate html?
15:07:39 <qasi> ski, what is |- ?
15:07:51 * hackagebot bv 0.1.0 - Bit-vectors library  http://hackage.haskell.org/package/bv-0.1.0 (IagoAbal)
15:08:17 <qasi> ski, I know this from the syntax of describing type systems, but there it was always basically an environment
15:08:20 <Cale> http://www.youtube.com/watch?v=c9EoI9tw6NE&feature=channel&list=UL by the same guy is also really cool
15:08:52 <qasi> ski, ooh wait okay I got it
15:08:56 <ski> qasi : `Foo |- Bar' means "`Bar' follows (logically) from `Foo'"
15:08:58 <ski> qasi : if you think this sounds interesting, i can suggest "Constructivism in Mathematics: An Introduction -- Volume I" by Anne Sjerp Troelstra,Dirk van Dalen in 1988
15:09:29 <qasi> ski, it does! I will get that
15:09:41 <Cale> qasi: What is your background? Have you studied other areas of mathematics?
15:09:42 <ski> (that's a book. perhaps your uni library has it)
15:09:44 <kwos> I'm calling select through FFI and immediately it gets interrupted with EINTR, but only if I compile the code. If I run this in ghci then it works fine. Have you seen anything like this?
15:10:02 <shachaf> kwos: Why are you calling select?
15:10:35 <kwos> I want to wait on a descriptor?
15:10:47 <shachaf> kwos: Fork a thread.
15:11:07 <kwos> shachaf: why?
15:11:08 <shachaf> GHC internally does some kind of polling with select/epoll/whatever, which might be interfering with your select.
15:11:09 <Cale> Like, a real Fd rather than a Handle?
15:11:21 <kwos> Cale: yes
15:11:42 <Cale> kwos: If it works okay in GHCi, try compiling with -threaded
15:11:48 <Cale> and see if that makes a difference
15:11:48 <kwos> shachaf: but why does it behave differently in GHCi and compiled code?
15:11:57 <Cale> GHCi is compiled with the threaded runtime
15:12:22 <qasi> Cale, I'm a master in computer science (actually a german diploma, but it's equivalent). I have done "some" theoretical computer science simply typed lambda calculous and other type systems, but not too much. this also involved doing some math on a math-student level, like Analysis I & 2 (the latter being calculous with complex numbers), Linear Algebra 1 & 2, a discrete math class...
15:12:31 <Cale> kwos: and it evaluates each command in a forked thread
15:13:15 <tohava> I am trying to write a program using GHC.Generic. In my program there is a type (data DATA a = C1 a Int | C2 a Double Int | C3 a), and I want to write a generic program that does some function on the 'a' parameter and returns the rest of the adt unchanged. How do I do this? Note that I may want to add C4 and C5 in the future as well, WITHOUT changing the program
15:13:28 <kwos> the behaviour with -threaded is the same
15:13:57 <rwbarton> tohava: well in this case you could just use "deriving Functor" and fmap
15:14:10 <ski> qasi : `|-' is one of the main concepts in logic. logic is more about knowing what is a valid/correct *argument* rather than knowing what is *true*
15:14:21 <qasi> ski, that book covers Martin Löf's type theory? sounds awesome
15:14:35 <Cale> qasi: ah, okay, cool. It would perhaps be more interesting if you've had some topology, but there is this homotopy type theory stuff which is beginning to form a connection where on the one side we have this logic and computation stuff, and on the other, we have the geometry of spaces up to deformation.
15:15:39 <ski> qasi : `Foo,Bar |- Baz' is how we express that if we accept `Foo' and `Bar' as premises (*assuming* they are "true"), then we have a logically valid argument showing how `Baz' follows from the premises
15:15:42 <qasi> Cale, oh. unfortunately, I know next to nothing about topology. I read a chapter of a book called "Algebraic Topology" out of interest, but at that time I was pretty much a freshman, and it went mostly over my head.
15:15:58 <Cale> qasi: Was it chapter zero of Hatcher's book?
15:16:02 <tohava> rwbarton, where can I read about it?
15:16:16 <rwbarton> @google ghc derivefunctor
15:16:17 <lambdabot> http://stackoverflow.com/questions/4001749/is-derivefunctor-a-well-recognized-extension-cabal-seems-confused
15:16:17 <lambdabot> Title: haskell - Is DeriveFunctor a well-recognized extension? Cabal seems confused - S ...
15:16:20 <rwbarton> er
15:16:30 <lpvb> What benefits does haskell gain with forced purity against languages with optional purity?
15:16:31 <ski> qasi : for Martin-Löf Type Theory, you can try "Intuitionistic Type Theory" by Per Martin-Löf in 1984 at <http://intuitionistic.wordpress.com/works-on-martin-lofs-type-theory/>
15:16:36 <rwbarton> well, do you mean "deriving Functor" specifically or Functor in general
15:16:41 <tohava> rwbarton, also, is there a way to do with GHC generics? that allows for the construcor count to change? (it looks like to me like this completely changes the type, but I may be wrong)
15:16:45 <qasi> Cale, it was so many years ago... but I'm pretty sure I will recognize it if I take a look into it. I'll check. (it wasn't my book, so I'll try google books or something)
15:16:48 <Lutin`> ski: I actually do have that book in my uni library
15:16:58 <rwbarton> I haven't used GHC generics (recently)
15:17:04 <Cale> lpvb: http://www.math.cornell.edu/~hatcher/AT/AT.pdf
15:17:07 <Cale> oops
15:17:08 <Cale> lol
15:17:12 <Cale> qasi:  http://www.math.cornell.edu/~hatcher/AT/AT.pdf
15:17:13 <Lutin`> I'll make sure to check it out on my way by the library on monday
15:17:21 <qasi> ski, should I read the book you recommended before?
15:17:41 <qasi> Cale, yes I remember the cover, that was definitely it
15:18:07 <Cale> qasi: The first chapter (well, the zeroth) of that book is very scary, because you're actually not meant to read it first :)
15:18:19 <ski> qasi : the book i mentioned before (Troelsta & van Dalen) only mentions very little Type Theory. but it's good for understanding intuitionistic logic, and various variants of axiom of choice and other axioms that have been considered for inclusion by constructivists (e.g. Brouwer's Bar Induction, and Markov's Principle)
15:18:44 <qasi> Cale, seems like I did read chapter 1, also, or at least started it
15:18:54 <ski> qasi : the books are probably a bit orthogonal
15:19:01 <Lutin`> I have a book on Topology by Adams, Franzosa
15:19:08 <Cale> But I also think that there ought to be a better book on algebraic topology. Hatcher's presentation makes some things needlessly difficult.
15:19:21 <Lutin`> But it's combinatoric
15:19:27 <ski> Lutin` : well, at least i found the book interesting, i hop you'll too
15:19:49 <qasi> ski, I think I would really need something about logic. as it is now, I don't even really know what "first order logic" is and all that. I know what a predicate is, heh, but I always feel that I'm severly lacking (even though my brush with Agda *did* help a lot)
15:19:53 <Lutin`> ski: I'm sure I will. I'm a CSE/Math major
15:19:57 <Cale> (I unfortunately don't have any specific recommendation in that department because my course just had its own set of notes)
15:20:56 <qasi> Cale, maybe I should just try again. although until now I didn't have any particular motivation about getting into topology. but you say that type theory is actually starting to reach out to it?
15:21:07 <ski> qasi : perhaps you'd need a more basic logic book that more in depth explains propositional and predicate logic, and a proof system and a semantics (models) for both, including talking some about soundness and completeness
15:21:23 <Cale> qasi: yeah :)
15:21:35 <ski> qasi : however, i don't think it'll hurt to take a look at the book anyway, if you can get a hold of it
15:21:36 <Cale> qasi: There are deep connections between computable functions and continuous ones.
15:21:54 <ski> @where topology
15:21:55 <lambdabot> "topology in Haskell" <http://www.haskell.org/pipermail/haskell/2004-June/014134.html> and "Synthetic topology of data types and classical spaces" <http://www.cs.bham.ac.uk/~mhe/papers/entcs87.(pdf|
15:21:55 <lambdabot> dvi|ps)> by Martn Escard
15:22:00 <qasi> do you know a. abel? I learned lambda calculous from him, got me a lot more interested into type systems
15:22:01 <Lutin`> Cale: There's a chapter in this book on homotopy and degree theory
15:22:06 <ski> qasi : ^ computational motivation for topology
15:22:19 <ski> qasi : also you can try the book "Topology via Logic" by Steven Vickers
15:22:20 <Cale> ^^ that book is also really accessible, and though it follows a different sort of connection to topology is also very interesting
15:22:40 <qasi> Cale, that does sound interesting, the connection between computable and continuous
15:22:40 <Cale> (Escardó's)
15:23:13 <Lutin`> So a homotopy deforms map f to map g
15:23:16 <tohava> rwbarton, thanks
15:23:32 <qasi> I think I'll have a lot of questions for the people I know who work or worked in that field 8) and who I will see again pretty soon...
15:23:49 <acowley> oy, pandoc's dependencies and 7.6 are not on friendly terms
15:24:28 <ski> qasi : if you want to read a beginner book on logic, i suggest getting one that uses some variant of natural deduction (perhaps called Fitch or Lemmon style) for the proof/derivation system
15:24:30 <rwbarton> for those who want a serious algebraic topology book, a friend of mine recommends tom Dieck's
15:24:56 <ski> (qasi : since "Hilbert-style" proofs, which are otherwise often used are a PITA)
15:25:18 <qasi> ski, okay?
15:25:59 <Lutin`> Cale: Oh this book actually is a survey of topology so it's got point-set, algebraic, geometric and knot theory
15:26:17 <qasi> maybe I can find some lecture notes on basic logic?
15:26:23 <rwbarton> > 3 `mod` 0
15:26:24 <lambdabot>   *Exception: divide by zero
15:26:36 <Lutin`> qasi: I'll look through my old bookmarks
15:26:37 * ski isn't quite sure where he learned basic logic from
15:26:47 <Lutin`> I learned it in discrete math
15:26:48 <acowley> on the streets
15:26:57 <qasi> Lutin`, that would be great
15:26:58 <ski> (i recall looking at lots of research papers, and browsing several books)
15:27:28 <qasi> I don't know, maybe I do actually know "basic" logic. though, as I said, I don't really know the distinction between "first order logic" and anything else, so maybe not.
15:27:42 <dgpratt> qasi: late to this converstation, but maybe something here would be useful to you: http://www.cs.uoregon.edu/Research/summerschool/summer12/curriculum.html
15:27:51 <dgpratt> err...conversation
15:28:01 <companion_cube> wikipedia has fine definitions for different logis
15:28:03 <companion_cube> logics
15:28:03 <ksf> qasi, http://www.youtube.com/watch?v=h_9WjWENWV8
15:28:07 <qasi> dgpratt, wow, title is totally relevant to my interests at least
15:28:21 <dgpratt> (although if you want to watch the videos, I hope you have a good connection)
15:28:28 <ksf> well, not about logic so much, but it definitely gets you into the mood.
15:28:37 <dgpratt> (they're huge files)
15:28:47 <qasi> dgpratt, I'm in Germany, so it's pretty good, yeah ;)
15:29:32 <qasi> dgpratt, ok, looking at the table of contents of that video, I'm pretty sure that I know all of these
15:29:33 <Lutin`> qasi: Whole thing is relevant
15:29:38 <Saizan> http://hpaste.org/76161 <- i guess it was known that CoYoneda is a higher-order writer monad?
15:30:01 <qasi> boolean algebra, quantifiers, predicates, different proof techniques... those I learned pretty early on
15:31:35 <qasi> dgpratt, the videos about Logical relations of Amal Ahmed, however, look pretty intriguing.
15:32:02 <ski> Saizan : monad yes. i'm not sure i see where you see the writer
15:32:39 <ski> qasi : do you know about introduction and elimination rules for all the connectives
15:32:50 <qasi> well great, thanks to all of you. pretty great resources.
15:33:11 <qasi> ski, don't think so. do you have an example?
15:33:27 <Saizan> ski: well, Category is a higher-order Monoid, no?
15:33:44 <Lutin`> qasi: http://www.proofwiki.org/wiki/Definition:Natural_Deduction
15:33:44 <companion_cube> ski: sequent calculus is so boring :>
15:33:50 <ski> Saizan : i suppose so, in some sense
15:34:02 <ski> companion_cube : heh, i didn't mention sequent calculus :)
15:34:15 <qasi> ski, oh yes I know these!
15:34:16 <ski> (and in what way do you find it boring ?)
15:34:35 <companion_cube> it's not convenient for automated deduction :)
15:34:36 <qasi> especially modus ponens ;)
15:35:13 <ski> qasi : yes, but also disjunction-elimination,existential-elimination,forall-introduction,&c.
15:35:17 <qasi> and the law of the excluded middle, which I think separates intuistic from classical logic, right?
15:35:23 <dgpratt> well, I'm pretty sure my resume got lost in the tubes; was pretty sure they would come through with a lucrative job offer by now ಠ_ಠ
15:35:28 <ski> qasi : more or less, yes
15:35:43 <dolio> Hilbert is bad, but I don't think Fitch is great, either.
15:35:52 <shachaf> qasi: It's also equivalent to call-with-current-continuation.
15:36:00 <dolio> But maybe it's easier to learn than proof trees.
15:36:03 <qasi> ski, hmm, no. those I don't know.
15:36:26 <companion_cube> in what way is Hilbert bad?
15:36:41 <dolio> companion_cube: The only inference rule is modus ponens.
15:36:42 <qasi> shachaf, hah, yes, I actually took a look at that. by looking at it as a type etc... again, having done a bit of Agda helped enormously with that.
15:36:46 <shachaf> Hilernie and Hilbert
15:36:48 <dolio> And you get some axioms.
15:36:54 <Lutin`> Eh
15:36:58 <ski> qasi : commonly learning "different proof techniques" sweeps those under the rug (typically calling all of them "direct proof")
15:37:01 <Lutin`> I actually like Fitch
15:37:05 <qasi> shachaf, modus ponens being just ($) and all
15:37:16 <ski> companion_cube : no local hypotheses
15:37:28 <qasi> ski, I understand
15:37:37 <ski> companion_cube : it's like programming in SKI-combinators, instead of lambda-calculus. PITA !
15:37:51 <shachaf> ski isn't a fan of ski-combinators?
15:37:57 <companion_cube> eww
15:38:13 * ski isn't a fan of actually writing larger programs/proofs with them, no
15:38:26 <ski> (or reading)
15:39:11 <tohava> Another question, given an AST [d| f x = "asd" |], how can I ask haskell for its type?
15:39:17 <ski> in a sense they are the assembler language of functional programming
15:39:19 <companion_cube> come on, a proof is not to be read, but to be proof-checked by a program ;)
15:39:58 <ski> companion_cube : s/proof/program/, s/proof-checked/executed/, s/program/computer/
15:40:08 <companion_cube> no, I meant it
15:40:18 <dimka> For example, there is some R combinator, that RXYZ |>w ZYX. How can R be formulate with SKI?
15:40:27 <qasi> okay, it's late, I'm going to finish reading that SYB-paper and go to bad. thanks again, I will look at the lectures and books
15:40:40 <ski> companion_cube : i just meant : apply the Curry-Howard correspondence to what you said, and see what it says
15:40:59 <companion_cube> ski: the curry howard replaces "executed" by "type-checked", didn't it?
15:41:00 <kwos> so, here's select issue distilled: http://hpaste.org/76162
15:41:05 <kwos> what's wrong with this code?
15:41:06 <companion_cube> wouldn't it*
15:41:08 <companion_cube> grr
15:41:22 <kwos> I'm compiling this with 7.6 on OSX
15:41:43 <Lutin`> companion_cube: doesn't it*
15:41:49 <dolio> ski: Since propositions are obviously just true or false, it doesn't matter how you proved it, just that you did. Obviously. :)
15:42:09 <companion_cube> yeah, I should have put "would" everywhere, to start
15:42:38 <dolio> All you need is the proposition and whether it's true or false.
15:43:16 <acowley> I don't have colors in ghci when run by inf-haskell in emacs. Is there a way to colorize that buffer?
15:43:33 <exFalso1> haskell needs agda style records. am i right or am i right
15:43:49 <dolio> In what sense?
15:44:34 <rwbarton> kwos: I think the ghc runtime uses signals internally so it is not surprising that you would get EIN
15:44:37 <rwbarton> TR
15:44:45 <exFalso1> in that it treats records as modules
15:45:36 <kwos> rwbarton: it turns select into a tight loop if I retry on EINTR
15:45:40 <rwbarton> hmm
15:45:44 <rwbarton> that isn't good
15:45:51 <ksf> 1.8G for a third of 80 minutes?
15:46:11 <ksf> are those lectures double HD holograms?
15:47:04 <ion> What lectures?
15:47:17 <ksf> http://www.cs.uoregon.edu/Research/summerschool/summer12/curriculum.html
15:47:21 <ion> thanks
15:47:25 <tohava> Let's say I have a function f, and I want to know which of its parameters have a type T, how can I do this in Haskell?
15:47:31 <ksf> :t f
15:47:32 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
15:47:39 <ksf> ...in ghci
15:47:39 <dgpratt> ksf: they're that big due to the amt of information in them, of course
15:47:40 <rwbarton> kwos: I think you can tell ghc not to use these signals for the duration of a particular FFI call
15:49:17 <dolio> exFalso1: Records aren't modules exactly.
15:49:23 <ksf> kwos, also, the ghc rts already uses epoll under the hood.
15:49:42 <ksf> kwos, just spawn a couple of threads and block on your handles and you're fine.
15:49:57 <dolio> But every record has an associated module that takes a value of the record and has all the members of the record.
15:50:44 <dolio> Plus they're dependent records, of course.
15:51:40 <dolio> Really you want Agda's modules, though, probably.
15:52:48 <kwos> ksf: I don't like the idea that I have to change what my program does because ghc runtime signals like crazy
15:53:23 <rwbarton> well... oh.
15:55:32 <c_wraith> If you mark the FFI call as safe, GHC will run it in a separate process that shouldn't get the runtime signals.
15:56:04 <ski> dimka : `R = \X. \Y. \Z. Z Y X = \X. \Y. S (S I (K Y)) (K X) = \X. S (S (K S) (S (K (S I)) (S (K K) I))) (K (K X)) = S (K (S (S (K S) (S (K (S I)) (S (K K) I))))) (S (K K) (S (K K) I))'
15:56:42 <Enigmagic> duh.
15:58:03 <ski> companion_cube : "proof-checked" with "type-checked" i suppose, yes
15:58:17 <dimka> ski: nice, could you please explain how it could be done with pen, paper and my right hand?
15:58:20 <ski> dimka : exercise, write a Haskell program that does this translation
15:59:35 <ski> dimka : `\x. x = I', `\x. e = K e' where `e' doesn't contain `x' free, `\x. e0 e1 = S (\x. e0) (\x. e1)'
16:00:10 <ski> (if you want to you could replace the middle rule by `\x. y = K y' where `y' is a variable distinct from `x')
16:00:58 <ski> dimka : second part of exercise : express the translation as a fold
16:01:15 <rwbarton> third part of exercise: add this program to lambdabot
16:01:26 <acowley> I don't suppose anyone here is Christopher Kuklewicz?
16:01:41 <ksf> fourth part of the exercise: implement zygohistomorphic prepromorphisms in SKI
16:02:04 <dimka> rwbarton: these kind of questions is really often here?
16:02:08 <dimka> are*
16:03:02 <ski> dimka : it comes up, from time to time
16:05:26 <dimka> ski: but why \Z. Z Y X = S (S I (K Y)) (K X) ?
16:05:49 <ski>      \Z. Z Y X
16:05:52 <Soultaker> hmm, can hlint be sometimes wrong, or am I missing something?
16:05:58 <ski>   =  S (\Z. Z Y) (\Z. X)
16:06:09 <ski>   =  S (S (\Z. Z) (\Z. Y)) (K X)
16:06:15 <ski>   =  S (S I (K Y)) (K X)
16:06:34 <ski> (recall that `Z Y X' means `(Z Y) X')
16:06:45 <dmwit> Soultaker: hlint can be often wrong
16:07:02 <dmwit> Soultaker: Sometimes, hlint will suggest a change and immediately suggest its opposite.
16:08:05 <Soultaker> actually, reading more carefully, it seems to make sense in my case.
16:08:14 <Soultaker> it suggests I add parenthesis so I can remove a $ somewhere else.
16:09:09 <Soultaker> (I still think it's a very useful tool to semi-beginners like me)
16:10:16 * ski idly wonders which paste Soultaker is talking about
16:12:31 <dimka> ski: it helps, thanks
16:24:07 <singpolyma> How would I build an (atto)parsec parser that can start at any position?  That is, if the parse fails, skip one character and try again
16:24:35 <dmwit> I think for efficiency attoparsec doesn't support lookahead.
16:24:39 <dimka> ski: \Y. K Y = K?
16:24:52 <dmwit> In Parsec, though, it's something like
16:25:11 <dmwit> parser = try realParser <|> (anyChar >> parser)
16:25:34 <dmwit> If you know enough about the grammar to rewrite it to consume arbitrary stuff first, that's even better.
16:26:47 <singpolyma> dmwit: ah, yes, that works for a single leading char (even with attoparsec), but if I use (many anyChar) then it just consumes all the input :(
16:27:04 <dmwit> What I posted will consume an arbitrary number of leading characters.
16:27:15 <dmwit> And yes, many anyChar doesn't work.
16:27:22 <ski> dimka : yes, that's a shorthand
16:28:28 <dimka> ski: what should I do when I get smth like \X. (K (S (K X) I))?
16:28:43 <singpolyma> dmwit: thanks :)
16:29:52 <dmwit> dimka: Evaluate, I guess.
16:30:02 <dmwit> You shouldn't get that, though.
16:30:23 <dmwit> I mean, if you start from a (closed) lambda term you shouldn't reach that kind of thing during your translation.
16:30:37 <dmwit> or... wait
16:30:44 <dmwit> dmwit--
16:31:26 <dmwit> \X. K (S (K X) I) = S (\X. K) (\X. S (K X) I) -- ?
16:32:28 <ski> yes
16:32:55 * hackagebot MonadRandomLazy 0.1 - Lazy monad for psuedo random-number generation.  http://hackage.haskell.org/package/MonadRandomLazy-0.1 (NormanRamsey)
16:34:39 <dmwit> :t \x -> const (ap (const x) id)
16:34:41 <lambdabot> forall b b1 b2. (b1 -> b) -> b2 -> b1 -> b
16:35:02 <dmwit> :t ap (const const) (ap (ap (const ap) const) (const id))
16:35:03 <lambdabot> forall b b1 a. (a -> b1) -> b -> a -> b1
16:35:57 <dmwit> :t const . flip ap id . const
16:35:58 <lambdabot> forall b a b1. (a -> b1) -> b -> a -> b1
16:36:37 <evancz> Hi, I am curious how Haskell does "dynamic dispatch" for typeclasses.
16:36:47 <evancz> Does anyone know any good resources on this?
16:36:56 <evancz> I have not been able to find anything
16:37:26 <hpc> haskell doesn't specify how to do it
16:37:30 <hpc> GHC uses dictionary passing
16:37:39 <dmwit> evancz: Each typeclass instance describes how to build a record containing the methods of the class. Whenever you write "Foo a => t", this is desugared to a function taking a typeclass dictionary (record) for "Foo a" and returning a "t".
16:37:50 <hpc> so for an Eq instance, you have something like
16:37:56 <dmwit> Yes, with the caveat that this description applies to GHC.
16:38:02 <dmwit> JHC does something else, for example.
16:38:16 <ion> Out of curiosity, what does JHC do?
16:38:20 <dmwit> ?djinn (a -> b) -> c -> a -> b
16:38:20 <lambdabot> f a _ b = a b
16:38:30 <hpc> boolEqDict = Eq {(==) True True = True; (==) False False = True; ...; (/=) x y = not (x == y)}
16:38:42 <dolio> JHC passes a representation of the type around, and then does case analysis on it.
16:38:42 <dmwit> ion: Types are available at runtime. Let me find a description of why this is neat, one moment.
16:38:56 <hpc> and to compare two booleans, you have
16:39:04 <hpc> (==) boolEqDict True True
16:39:09 <hpc> or something to that effect
16:39:26 <dmwit> http://repetae.net/computer/jhc/jhc-reify-typeclass.html I think discusses JHC's approach
16:39:31 <ion> Thanks
16:39:47 <hpc> ooh
16:41:43 <hpc> that's pretty rad
16:42:09 <ion> data Num a = Num { fromInteger :: Integer -> a; (+) :: a -> a -> a; … }; sum :: Num a -> [a] -> a; sum numDict = foldl' ((+) numDict) (fromInteger numDict 0)
16:44:11 <evancz> So when you write eq = (==)
16:44:23 <evancz> wait, backup
16:44:34 <evancz> my question is how does it do specialization?
16:44:41 <evancz> so if you have a function that is very general
16:44:57 <evancz> is there a scenario where it is unclear how it will be used?
16:45:09 <hpc> sometimes there are scenarios where it is unclear which instance to use
16:45:16 <jmcarthur> existential types can lead to this kind of situation, for example
16:45:16 <hpc> in those cases, you get an ambiguous type error
16:45:28 <hpc> another good case is
16:45:29 <rwbarton> "show . read"
16:45:31 <hpc> :t show . read
16:45:32 <lambdabot> String -> String
16:45:42 <hpc> which instance does it use? science doesn't know!
16:45:42 <jmcarthur> oh what the question only about type inference?
16:45:46 <jmcarthur> i interpreted it differently
16:45:53 <jmcarthur> *was
16:46:04 <evancz> I think this is clarifying things
16:46:04 <hpc> when you are using say, (==) on a concrete type
16:46:10 <hpc> it passes the dictionary automagically
16:46:14 <evancz> I see
16:46:24 <hpc> so if you wrote
16:46:29 <hpc> foo :: Int -> Int -> Int
16:46:31 <hpc> foo = (==)
16:46:34 <hpc> it's really
16:46:39 <evancz> And every use of (==) ultimately has a concrete type that can be infered at compile time
16:46:40 <hpc> foo = (==) intDict
16:46:40 <evancz> ?
16:46:53 <jmcarthur> if you use an existential type with a type class constraint, the dictionary can not be compiled away. outside of this case, it often can be optimized away
16:46:57 <evancz> I get the dict part
16:47:10 <evancz> okay! cool!
16:47:12 <jmcarthur> not all uses of (==) have a statically inferrable type
16:47:22 <jmcarthur> data Foo = forall a. Eq a => Foo a a
16:47:31 <jmcarthur> check (Foo x y) = x == y
16:47:35 <rwbarton> also in polymorphic recursion
16:47:38 <jmcarthur> ah yes
16:47:47 <hpc> constraint kinds add an interesting wrinkle as well
16:47:55 <rwbarton> the nice thing about the dictionary translation is that you don't need to statically infer the type
16:47:56 <jmcarthur> oh?
16:47:56 <hpc> which ultimately amounts to compiler-checked dictionary passing
16:48:04 <dmwit> evancz: http://stackoverflow.com/questions/11420126/does-haskell-have-return-type-overloading/11422333#11422333
16:49:20 <ksf> > show . read $ "()"
16:49:22 <lambdabot>   "()"
16:49:34 <ksf> I KNOW MORE THAN SCIENCE!
16:49:55 <rwbarton> lucky guess
16:50:17 <dmwit> > show . read $ " (  ( ) )"
16:50:19 <ksf> knowledge. knowledge.
16:50:19 <lambdabot>   "()"
16:50:23 <evancz> so is one of the problems with a more flexible record system?
16:50:43 <jmcarthur> read str = if str == "()" then () else error "bad!"
16:50:44 <dmwit> That sentence seems to be lacking a predicate.
16:51:00 <evancz> haha, it definitely is!
16:51:02 <evancz> one sec
16:51:21 <evancz> with adding a more _ _ _ to Haskell?
16:51:28 <ion> I think you accidentally a
16:51:31 <ksf> > read "(())" :: ()
16:51:33 <lambdabot>   ()
16:51:44 <ksf> looks like a bug to me
16:51:44 <evancz> crap
16:51:45 <evancz> redo
16:51:45 <ion> > read "()"
16:51:46 <lambdabot>   ()
16:51:53 <dmwit> ksf: Not a bug.
16:51:57 <rwbarton> > read "(3)"
16:51:58 <lambdabot>   *Exception: Prelude.read: no parse
16:51:59 <dmwit> ksf: It's doing actual lexing and parsing.
16:51:59 <evancz> Let's say you want to add extensible records to Haskell.
16:52:00 <rwbarton> argh
16:52:03 <rwbarton> > read "(3)" :: Int
16:52:03 <ksf> oh. parenthesis.
16:52:04 <lambdabot>   3
16:52:04 <jmcarthur> ksf: it's just () in parens
16:52:07 <ksf> > read "(()" :: ()
16:52:08 <lambdabot>   *Exception: Prelude.read: no parse
16:52:12 <evancz> Is this going to be a problem for typeclasses?
16:52:15 <dolio> > read "((((((((5))))))))" :: Int
16:52:16 <lambdabot>   5
16:52:28 <jmcarthur> evancz: you mean would a more flexible record system be a problem for type classes?
16:52:33 <dolio> > read "(                               )"
16:52:34 <evancz> yeah!
16:52:35 <lambdabot>   ()
16:52:44 <dmwit> dolio: ...wut
16:52:50 <jmcarthur> evancz: i'm not sure i see why that would be, without more explanation of what you mean by "more flexible"
16:52:50 <dmwit> oh
16:52:55 <dolio> > case () of (                  ) -> 5
16:52:57 <lambdabot>   5
16:53:01 <dmwit> I missed the end of it. -_-
16:53:05 <jmcarthur> oh extensible records
16:53:15 <jmcarthur> i still don't see what the problem would be though
16:53:20 <evancz> yeah, some people call it "structural typing"
16:53:37 <evancz> if you have an instance for { x } and for { x, y }
16:53:44 <evancz> and you give it { x, y, z}
16:53:46 <typoclass> > read "5 {- abc -}" :: Int
16:53:47 <lambdabot>   *Exception: Prelude.read: no parse
16:53:50 <evancz> which instance do you use?
16:53:58 <parcs`> > read "([(5)])" :: [Int]
16:54:00 <lambdabot>   [5]
16:54:05 <ion> Give what {x,y,z}?
16:54:15 <dolio> dmwit: Sometimes people don't realize that [] and () can have space in them.
16:54:18 <evancz> one sec, i'll do a bigger example
16:54:18 <jmcarthur> it wouldn't be a problem if the types also explain things like covariance/contravariance/invariance
16:54:32 <evancz> can you elaborate on that?
16:54:32 <hpc> i doubt you could add structural typing to GHC without losing a lot of other features
16:54:36 <dmwit> dolio: Yeah. I knew that, but thought you had done this:
16:54:39 <dmwit> > read "(
16:54:41 <lambdabot>   <no location info>:
16:54:41 <startling> > read "(   )" :: ()
16:54:41 <lambdabot>      lexical error in string/character literal at end o...
16:54:42 <lambdabot>   ()
16:54:42 <dolio> :)
16:54:48 <dmwit> ...and then gotten a meaningful answer from lambdabot. =P
16:54:53 <dolio> > read "(                                                                                                                                                                   )"
16:54:54 <lambdabot>   ()
16:55:06 <ksf> btw, those lectures have 1440x1080 resolution.
16:55:15 <ksf> who posts such beasts on the internet?
16:55:16 <dmwit> > read "5\        \6" :: Int
16:55:18 <lambdabot>   56
16:55:23 <dolio> Nice.
16:55:33 <rwbarton> that isn't read though
16:55:34 <startling> > read "5  6" :: Int
16:55:35 <ion> So… finally lectures where you can read the slides?
16:55:35 <lambdabot>   *Exception: Prelude.read: no parse
16:55:38 <ksf> *they don't even fit on my scleen*
16:55:45 <evancz> instance Foo { x :: Int } where magnitude r = r.x
16:55:47 <hpc> > "5\                                                                '6"
16:55:48 <lambdabot>   <no location info>:
16:55:48 <lambdabot>      lexical error in string/character literal at chara...
16:55:49 <dmwit> not read, I agree
16:55:52 <hpc> > "5\                                                                \6"
16:55:52 <dmwit> hm...
16:55:53 <lambdabot>   "56"
16:55:57 <rwbarton> > read "5\\   \\6" :: Int
16:55:59 <lambdabot>   *Exception: Prelude.read: no parse
16:56:02 <jmcarthur> evancz: the question is should type class instances always apply to subtypes of a type? supertypes of the type? only exactly the type?
16:56:08 <evancz> instance Foo { x :: Int, y :: Int } where magnitude r = sqrt (r.x^2) (r.y^2)
16:56:09 <dmwit> rwbarton: Just what I was about to try. =)
16:56:11 <startling> is there a "Read r => Maybe r"?
16:56:18 <dmwit> startling: reads
16:56:26 <ion> > " \ \ \ \ \ \ \ \ \ \ "
16:56:27 <startling> > reads "12" :: Maybe Integer
16:56:27 <lambdabot>   "      "
16:56:28 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe
16:56:28 <lambdabot>                             ...
16:56:35 <startling> :t reads
16:56:36 <otters> :t reads
16:56:36 <lambdabot> forall a. (Read a) => String -> [(a, String)]
16:56:37 <dmwit> > reads "12" :: ReadS Integer
16:56:38 <lambdabot> forall a. (Read a) => String -> [(a, String)]
16:56:39 <lambdabot>   Couldn't match expected type `Text.ParserCombinators.ReadP.ReadS
16:56:39 <lambdabot>           ...
16:56:40 <evancz> jmcarthur: yeah! so it is a problem?
16:56:49 <rwbarton> in the future there is a readMaybe or something
16:56:49 <dmwit> > reads "12" :: [(Integer, String)]
16:56:50 <startling> > reads "12"
16:56:50 <lambdabot>   [(12,"")]
16:56:51 <lambdabot>   []
16:56:52 <dolio> > read "\"5\\     \\6\""
16:56:53 <lambdabot>   *Exception: Prelude.read: no parse
16:56:55 <jmcarthur> evancz: i think it would be reasonable, no matter which of those you pick or perhaps even if you pick something slightly more flexible by allowing to specify what you mean, for the compiler to just complain if there are overlapping instances, just like it already does
16:56:58 <startling> dmwit: ah
16:56:59 <dolio> > read "\"5\\     \\6\"" :: String
16:57:00 <lambdabot>   "56"
16:57:08 <ion> startling: I think readMay made it into Prelude or Data.Maybe in GHC 7.6 or something.
16:57:14 <dolio> > read (read "\"5\\     \\6\"") :: Int
16:57:15 <lambdabot>   56
16:57:17 <startling> > reads "12    " :: [(Integer, String)]
16:57:18 <lambdabot>   [(12,"    ")]
16:57:20 <startling> neat
16:57:27 <evancz> someone mentioned that it would cause other problems too
16:57:33 <dmwit> > lex "12    " -- little known feature of H98
16:57:33 <evancz> what sort of problems?
16:57:34 <lambdabot>   [("12","    ")]
16:57:37 <jmcarthur> for type interence
16:57:39 <evancz> this is the only one I can think of
16:57:40 <ski> > (reads :: ReadS Integer) "12"
16:57:42 <lambdabot>   [(12,"")]
16:57:47 <jmcarthur> it becomes much harder (undecidable?)
16:57:47 <rwbarton> > lex "(12 13)  "
16:57:48 <dmwit> ski: ah, thanks, of course
16:57:49 <lambdabot>   [("(","12 13)  ")]
16:57:50 <evancz> they said it might conflict with other language features
16:57:56 <jmcarthur> that too
16:57:56 <evancz> hmmm
16:57:57 <hpc> lex++
16:58:03 <jmcarthur> i have no idea how it interacts with, say, GADTs
16:58:12 <rwbarton> > lex "0o789"
16:58:12 <lambdabot>   [("0o7","89")]
16:58:17 <startling> hpc: luthor?
16:58:28 <ski> dmwit : often used when hand-writing `Read' instances
16:58:36 <ski> (`lex', i.e.)
16:59:33 <dmwit> rwbarton: Well, that's a bit odd.
16:59:44 <rwbarton> isn't it lovely
16:59:48 <ion> > 0o789
16:59:49 <lambdabot>   7
16:59:49 <evancz> I'll try to find the great record debates that were going on a couple months ago
16:59:54 <rwbarton> just what you wanted it to do, I bet
17:00:08 <dmwit> ooooh
17:00:10 <rwbarton> > 0xford
17:00:12 <lambdabot>   15
17:00:13 <evancz> That would probably give me an idea of the cases we have not thought of
17:00:16 <dmwit> Yes, it is, actually. =P
17:00:17 <ion> > 0o7o
17:00:18 <lambdabot>   7
17:00:24 <ski> Hugs> lex "0o789"
17:00:25 <ski> [("0","o789")]
17:00:31 <ski> interesting
17:00:37 <hpc> > 0xford
17:00:39 <lambdabot>   15
17:00:43 <dmwit> 0xford is very funny
17:00:43 <rwbarton> no hax
17:00:47 <hpc> oh, rwbarton beat me to it
17:00:50 <typoclass> ion: i bet that wouldn't work in ghci. it's just because of those lambdabot Num instances
17:00:56 <ion> typoclass: Verily.
17:01:43 <startling> > 0o7ffff
17:01:44 <dmwit> > 0xblast
17:01:44 <lambdabot>   Not in scope: `ffff'
17:01:45 <lambdabot>   11
17:01:54 <startling> > 0x79999
17:01:55 <lambdabot>   498073
17:02:03 <ski> evancz : have you seen <http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#trex> yet ?
17:02:05 <startling> ...weird.
17:02:12 <startling> > 0x7 9999
17:02:13 <lambdabot>   7
17:02:21 <jmcarthur> > 7 9999
17:02:22 <dmwit> startling: f isn't an octal digit. =)
17:02:22 <lambdabot>   7
17:02:29 <startling> dmwit: oh heh
17:02:40 <dolio> Everyone loves maximal munch.
17:02:48 <startling> > 0o7777
17:02:49 <lambdabot>   4095
17:02:51 <typoclass> startling: 9999 is in scope (integer literal). ffff is not in scope
17:02:54 <evancz> ski: I have not!
17:03:00 <startling> typoclass: yeah, I understand
17:03:02 <typoclass> > 0o7pred -- this is in scope, for instance
17:03:04 <lambdabot>   Ambiguous type variable `a' in the constraint:
17:03:04 <lambdabot>    `GHC.Enum.Enum a'
17:03:04 <lambdabot>      ar...
17:03:08 <startling> > 0o7888
17:03:09 <lambdabot>   7
17:03:24 <startling> and because 8 isn't an octal digit, it's lexed separately
17:03:38 <jmcarthur> it's just interaction of the interesting lexing rules and NumInstances
17:03:40 <ion> > unfoldr (listToMaybe . filter (not . null . fst) . lex) "foo (bar + 42)"
17:03:42 <lambdabot>   ["foo","(","bar","+","42",")"]
17:03:43 * dmwit occasionally wishes for an 0b notation for binary literas.
17:03:46 <dmwit> literals.
17:03:48 <jmcarthur> me too
17:03:49 <ion> dmwit: ditto
17:04:06 <startling> me four
17:04:09 <jmcarthur> quasiquoter?
17:04:32 <evancz> ski: that link is great! Thank you!
17:05:44 <jmcarthur> > 0o7f
17:05:45 <lambdabot>   Ambiguous type variable `a' in the constraint:
17:05:45 <lambdabot>    `SimpleReflect.FromExpr a...
17:05:54 <jmcarthur> aw
17:06:32 <rwbarton> > 0x
17:06:33 <lambdabot>   0
17:06:35 <evancz> On a side note and assuming you care about client-side programming, do any of you use Elm? If not, do you prefer a some Haskell->JS compiler? If you have deep reservations about Elm can you tell me what they are?
17:06:50 <ski> @let showBin = showIntAtBase 2 intToDigit
17:06:52 <lambdabot>  Defined.
17:06:55 <ski> @let readBin = readInt 2 (`elem` "01") digitToInt
17:06:56 <lambdabot>  Defined.
17:07:03 <ion> > map (unfoldr (listToMaybe . filter (not . null . fst) . lex)) ["0xaz", "0xz", "0x"]
17:07:05 <lambdabot>   [["0xa","z"],["0","xz"],["0","x"]]
17:07:13 <evancz> If you do use some straight HS->JS compiler, which one? Why? Can you actually do things yet?
17:08:09 <ski> evancz : yw
17:08:18 <ion> I only use gay HS→JS compilers.
17:08:27 <evancz> what?
17:08:35 <evancz> to both ski and ion
17:08:42 <hpc> lol ion
17:08:51 <ski> evancz : "yw" is short for "you're welcome"
17:09:21 <evancz> ski: Ah, how did I not know that?!
17:09:33 <jmcarthur> > 0o1foldl1
17:09:34 <evancz> which ones are the gay ones?
17:09:34 <lambdabot>   1
17:09:43 <evancz> I am assuming that gay is a technical term!
17:10:04 <typoclass> evancz: he was just making a pun on the words straight and gay
17:10:33 <evancz> man, two silly misunderstandings in a row!
17:10:41 <evancz> typoclass: thank you
17:11:23 <evancz> I meant "straight" as in "no semantic or syntactic differences"
17:11:30 <evancz> which Elm does not qualify as
17:11:56 <evancz> Wait, so Elm is a gay HS->JS compiler!
17:12:07 <ion> There was a comparison somewhere in the wiki, i think.
17:12:22 <evancz> I think I saw that
17:13:00 <evancz> I am looking for subjective stuff, like "person X hates Elm because ____"
17:13:17 <evancz> I am trying to understand the different kinds of people who might be interested in Elm
17:13:25 <evancz> so I can figure out where to focus my time
17:14:11 <evancz> as much as it pains me to do less theoretical stuff, I am more and more thinking that I just need to focus on web developers
17:14:29 <evancz> and I think that group is generally fairly distinct
17:14:59 <rwbarton> I want Cloud Haskell support in my Haskell->JS compiler
17:15:03 <rwbarton> Even if I don't know why yet.
17:15:04 <evancz> In other words, examples and docs take precedence over typeclasses and extensible records
17:15:18 <evancz> rwbarton: lol, I agree
17:15:36 <evancz> I was super excited about Opa-lang initially
17:15:45 <evancz> because it seemed like it might be kinda like that
17:15:58 <evancz> I think they tried to do too much too soon though
17:16:00 <typoclass> evancz: there's several projects to compile to js, but i have no idea if they are reliable yet. check out http://fay-lang.org/ , they have a section comparing their stuff to elm. also see https://github.com/yesodweb/yesod/wiki/Javascript-Options , it lists a few
17:16:22 <dmwit> Javascript is the new assembly.
17:16:34 <evancz> dmwit: for sure!
17:16:48 <evancz> it's a shame its concurrency stuff is so bad
17:17:00 <Cale> evancz: I haven't looked at Elm, but in my day job, I've been working on maintaining a web application lately whose backend we are going to replace with a Haskell program. It would be very nice to be able to use the same Haskell source to define the data structures in both the backend and frontend of the application, so that they could never go out of sync with each other.
17:17:06 <dmwit> ...and the HTML box model is the new framebuffer.
17:17:08 <typoclass> dmwit: more like the new c?
17:17:10 <dmwit> Not sure which of those makes me sadder.
17:18:05 <evancz> Cale: I am not sure if any of the HS->JS compilers let you do this yet, but I really like that feature!
17:18:29 <evancz> My dream for Elm is a bit more general though
17:18:49 <evancz> I want there to be a typed way to communicate between server and client
17:19:02 <evancz> such as OData (http://www.odata.org/)
17:19:12 <evancz> so it wasn't just a Haskell specific thing
17:19:17 <luite> Cale: Fay already lets you do that with a limited subset of haskell
17:19:37 <Cale> I think once you get to the point of using a compiler which checks the types on both sides, how you actually serialise the types is somewhat immaterial.
17:19:38 <cmccann> just don't forget to account for malicious or broken clients
17:20:01 <Cale> and yeah, of course you still want to be concerned about security
17:20:22 <ion> Remember to turn on \"magicquotes\" for safety.
17:20:48 <cmccann> including things like denial of service from sending stuff that's time-consuming to validate
17:22:28 <evancz> cmccann: the people working on F# have this feature (typed data transfer). Not sure if they have provided solutions for the things you mention
17:22:42 <evancz> I forget what they call it...
17:22:58 <Cale> For the most part, I think that you'd likely want to use a Serialise class à la Cloud Haskell, or something similar which goes via JSON just to be kind to third party developers.
17:23:00 <cmccann> if they don't explicitly say they do I'd assume they don't
17:23:33 <luite> Cale: the ToJSON and FromJSON Aeson classes might be enough
17:23:42 <rwbarton> ever dealing with DOS attacks against your TCP stack is hard enough
17:23:45 <rwbarton> *even
17:24:00 * cmccann remembers a DoS attack caused by forcing hash collisions on query parameter names, that was hilarious
17:24:11 <ion> Let’s use SOAP.
17:24:25 <Cale> It would be nice if all we had to worry about were sophisticated attackers.
17:24:32 <luite> Cale: unless you want polymorphic values, then some cloud haskell trick is required i guess
17:24:37 <cmccann> especially since all the enterprise-strength crap was vulnerable to it, but dusty old perl code wasn't
17:24:55 <Cale> Normal users can DoS our existing backend by doing fairly normal things that they might reasonably want to do.
17:25:27 <ion> cale: What language is it written in, btw?
17:25:36 <Cale> lol, groovy/grails
17:26:27 <ion> It must be fast because JVM.
17:26:32 <Cale> ahahaha
17:26:58 <cmccann> Cale, is the site cutting edge web 2.0 stuff? because periodically collapsing under the burden of normal users doing normal things on the side seems required for that.
17:27:22 <Cale> So, every method call does a lookup by string comparison of the method name and the types of its arguments in a map.
17:27:46 <Cale> It's so web scale, you have no idea.
17:27:51 <cmccann> bwahahahaha
17:28:04 <ion> I think it should look up the types of its arguments from a NoSQL database.
17:28:15 <evancz> I have to go run some errands, but thanks for discussing some of this stuff with me.
17:28:15 <kirindave> That would probably make it faster.
17:28:34 <kirindave> Guys guys, it's MongoDB you should be directing your hate at outright.
17:28:39 <kirindave> Don't pussyfoot around.
17:29:21 <Cale> As far as I can tell, these guys were like "We really like Ruby and Rails and think that's really hip, but wouldn't it be nice if we could use Java's great standard libraries, like the Calendar API? We know nothing about writing compilers, but I'm sure that won't be a problem."
17:30:32 <cmccann> Cale, isn't that pretty much how it went for Ruby and Rails themselves anyway?
17:30:40 <Cale> and so they implemented a "compiler" which as far as I can tell is like a horribly inefficient interpreter, except that it takes a while to "compile" your code each time.
17:31:00 <cmccann> ok so at least they were successful in imitating ruby
17:31:04 <cmccann> I'll give them that much
17:31:12 <Cale> I think it might actually be slower than Ruby
17:31:41 <luite> i wonder if it's slower than ghcjs :)
17:31:42 <cmccann> these days perhaps, early versions of ruby were kinda horrifically slow
17:31:53 <maukd> http://www.flickr.com/photos/silent11/182188797/
17:32:01 <Cale> also, here's something hilarious: there are private and public keywords and the compiler will accept them, but they do nothing
17:32:12 <cmccann> that's fantastic
17:32:24 <Nafai> Cale: in Groovy?
17:32:29 <Cale> yes
17:32:33 <Nafai> nice
17:33:00 <ion> Does Groovy have method_missing?
17:33:35 <Cale> ion: If it does, then as far as I know we're not using it at least.
17:34:45 <maukd> http://pugs.blogs.com/talks/yapcna-ppencode.pdf good times
17:41:18 <Saizan> ski: do you think we can find a functor-ish F such that F (CoYoneda k f a) = CoYoneda k f (Maybe a) ?
17:44:21 <niceisnice> Records in Haskell are usually not well perceived… What do you think of that? http://news.ycombinator.com/item?id=4643371
17:45:05 <Cale> niceisnice: It's not so much that they're bad, it's that they're not great.
17:45:21 <c_wraith> Of all the cools things they could do - they do none
17:45:25 <jmcarthur> Saizan: data CoYoneda k f a = CoYoneda (k -> a) (f k)   ?
17:45:43 <Cale> niceisnice: and we now know several systems for how they could work which would be better than how they do
17:46:25 <Saizan> jmcarthur: data CoYoneda k f a = forall r. CoYoneda (k r a) (f r)
17:46:31 <tohava> rwbarton, 1 question though. What if I have data D a b, and I want to do something like fmap, but for 'a' instead of 'b'?
17:46:36 <tohava> (fmap always uses the last type parameter)
17:46:38 <niceisnice> And it's not better for OCaml for instance… I truly think things like this limit the popularity of FP languages.
17:46:40 <jmcarthur> ah, k generalizes the function
17:46:55 <Saizan> yep, i'm assuming it's a Category
17:46:58 <jmcarthur> more reasonable than my guess, i guess
17:46:58 <Cale> niceisnice: Basically, all that the record syntax in Haskell gives you is a little bit of syntax sugar around algebraic datatypes.
17:47:23 <rwbarton> tohava: ah, then you are stuck/need to do something manually
17:47:41 <rwbarton> or maybe there is a TH Bifunctor deriver somewhere
17:47:58 * hackagebot gluturtle 0.0.23 - turtle like LOGO with glut  http://hackage.haskell.org/package/gluturtle-0.0.23 (YoshikuniJujo)
17:48:13 <Cale> niceisnice: you have an update syntax which, given a record r with some field f, you can write  r { f = v } to construct a new record with the same field values as r, except the field f is v.
17:48:59 <Cale> niceisnice: and that works for multiple fields and is polymorphic, but isn't a first class function in any way
17:49:10 <Saizan> the exercise is a bit unfair though i guess, we might want to know that k is FinSet, or even the injective subcategory
17:49:30 <Cale> niceisnice: The records are not extensible, you can't add new fields to them, or write operations on multiple record types with similar field structure.
17:49:57 <niceisnice> Didn't Simon PJ propose an extension at some point? Like 10 years ago?
17:49:58 <Cale> niceisnice: However, there are libraries which solve problems like this without introducing new constructions to the language.
17:50:19 <Cale> One, which is particularly nice, is Edward Kmett's lens library.
17:50:31 <niceisnice> http://research.microsoft.com/en-us/um/people/simonpj/Haskell/records.html
17:50:50 <Cale> Yes, as far as I know, that was never implemented
17:51:06 <Cale> also, its syntax sucks, as far as going along with the rest of Haskell is concerned
17:51:45 <jmcarthur> Saizan: i feel like your question is unapproachable for me, which makes me sad. i really need to actually dig in to some category theory and such
17:52:09 <jmcarthur> i've gleaned a lot here and there, but my knowledge lacks a lot of depth
17:52:56 <Cale> niceisnice: Daan Leijen also wrote some papers whose semantics for extensible records and variants are quite interesting (though again, I think the concrete syntax used in the papers is quite incongruent with the rest of Haskell)
17:53:57 <Saizan> jmcarthur: i'm more or less in the same boat, just trying to find abstract nonsense that matches the very concrete reality of higher-order pattern unification :)
17:54:24 <Cale> niceisnice: But the fact that people are now solving these issues as libraries in plain Haskell seems to suggest that perhaps it's not really necessary to extend the language, or that if anything, we should adopt one of these plans.
17:55:40 <Cale> niceisnice: Presently, when you define a record type like   data Employee = Empl { name :: String, salary :: Integer }
17:56:03 <Cale> niceisnice: you get functions   name :: Employee -> String   and  salary :: Employee -> Integer
17:56:08 <Cale> for extracting those values
17:57:04 <Cale> However, you get nothing in the way of automatically defined functions for "immutably updating" an Employee, with a new salary say, to get a new Employee
17:57:33 <niceisnice> Syntactic sugar could help...
17:57:34 <Cale> You just get that syntax, and you end up writing things like:  joe { salary = salary joe + 100 }
17:57:35 <Nereid> cool https://personal.cis.strath.ac.uk/robert.atkey/fomega-parametricity.html
17:57:38 <Nereid> also this is pretty new
17:57:48 <Cale> But what we want isn't really syntactic sugar :)
17:58:18 <Cale> We want some nice way to get an honest function   Integer -> Employee -> Employee
17:58:35 <Cale> well, maybe you could do that via syntax
17:58:42 <Cale> But there's actually something really nice
17:58:46 <clahey> @pl \x -> f x && g x && h x
17:58:47 <lambdabot> liftM2 (&&) f (liftM2 (&&) g h)
18:00:25 <maukd> :t and . sequence [f, g, x]
18:00:27 <lambdabot>     Couldn't match expected type `f Bool' against inferred type `Expr'
18:00:28 <lambdabot>     In the expression: x
18:00:28 <lambdabot>     In the first argument of `sequence', namely `[f, g, x]'
18:00:32 <Cale> People, including Twan van Laarhoven (who is perhaps responsible most of all for this initially) noticed that you can define a functional data structure which says how to extract and replace some "field" in another data structure
18:00:35 <maukd> :t \f g h -> and . sequence [f, g, h]
18:00:37 <lambdabot> forall (f :: * -> *). (Monad f, Functor f) => f Bool -> f Bool -> f Bool -> f Bool
18:00:58 <clahey> :t ((.) . (.))
18:01:00 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
18:01:04 <maukd> :t \f g h x -> (and . sequence [f, g, h]) x
18:01:05 <lambdabot> forall t. (Monad ((->) t), Functor ((->) t)) => (t -> Bool) -> (t -> Bool) -> (t -> Bool) -> t -> Bool
18:01:22 <Cale> niceisnice: The first iteration of this was to define simply something like:   data Lens a b = L { view :: a -> b, set :: b -> a -> a }
18:01:27 <niceisnice> Thanks Cale for the links, I'll have a look. Not doing a lot of Haskell since 2003.
18:01:33 <Cale> http://www.twanvl.nl/blog/haskell/cps-functional-references
18:01:59 <clahey> :t [f, g, h] <*> x
18:02:01 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Expr'
18:02:01 <lambdabot>     In the second argument of `(<*>)', namely `x'
18:02:01 <lambdabot>     In the expression: [f, g, h] <*> x
18:02:28 <clahey> @pl \x -> [f, g, h] <*> x
18:02:28 <lambdabot> ([f, g, h] <*>)
18:03:11 <typoclass> Cale: those look conspicuously like lenses, which i hear are the next big thing :)
18:03:22 <Cale> typoclass: They *are* lenses
18:03:24 <clahey> :t [f, g, h] <*> [x]
18:03:27 <lambdabot> forall b. (SimpleReflect.FromExpr b) => [b]
18:03:45 <Cale> The link to twanvl's site describes the very earliest implementation of lenses
18:04:08 <shachaf> Really, that's the earliest description?
18:04:21 <Nereid> Cale: no, just the earliest implementation of van Laarhoven lenses.
18:04:22 <Nereid> :v
18:04:24 <Cale> Well, it's equivalent to whatever the first version was
18:04:32 <Nereid> sure.
18:04:42 <Cale> Just a pair of the getter and setter functions.
18:05:08 <shachaf> Cale: The link you gave gives the (a -> f a) -> b -> f b representation.
18:05:17 <Cale> oh, dang
18:05:22 <Cale> That's not what I wanted :)
18:05:41 <Cale> I want the non-CPS functional references link :)
18:05:51 <Cale> http://twanvl.nl/blog/haskell/overloading-functional-references
18:05:55 <Cale> I think that's it, yeah :)
18:06:10 <Cale> So, if you look at that
18:06:32 <Cale> he defines a lens:  fst :: FRef (x,y) x
18:06:45 <shachaf> OK, but that's quite a bit older. :-)
18:06:46 <Cale> fst = FRef { get = \(x,y) -> x, set = \x (_,y) -> (x,y) }
18:06:50 <Cale> yes, quite a bit :)
18:06:58 <Cale> That's the article I meant to link originally
18:07:24 <shachaf> I wonder why nobody made a big deal about them until recently.
18:07:26 <Cale> now if you look at  set fst :: x -> (x,y) -> (x,y)
18:07:35 <Cale> this is sort of okay...
18:07:58 <Cale> except that maybe you'd like  set fst :: z -> (x,y) -> (z,y)
18:08:10 <Cale> i.e. polymorphically update not only the value, but the type of that field
18:08:46 <Cale> This kind of thing didn't quite fit into the original description of lenses
18:09:53 <Cale> But what was nice about lenses (and still is, in newer constructions) is that you can take two lenses, say  Lens a b   and  Lens b c  and stick them end to end, to give something which lets you extract or update a sub-subfield of type c in a structure of type a
18:10:20 <cornihilio> excuse me, but I seriously don't get this. When I was playing around with attoparsec I got the result type was of attoparsec.done or fail, and then wrote the case statement. what about something like data.binary.runGetState? what does it return when it fails? am I supposed to use a maybe value?
18:10:21 <copumpkin> bapa: are you QF?
18:10:23 <shachaf> A useful Category instance other than (->)!
18:10:31 <Cale> shachaf: Indeed!
18:10:36 <shachaf> Well, it *was*, until people like twanvl and edwardk came along and messed it up.
18:10:51 <copumpkin> types should always stay the same anyway
18:10:57 <copumpkin> one type for all time should be enough for anyone
18:11:22 <Cale> shachaf: haha
18:11:42 <Cale> Well, they made it so that the Category instance for (->) was enough.
18:11:50 <shachaf> Cale: But (.) is backwards.
18:12:03 <shachaf> Should've double-CPSed it.
18:12:07 <Cale> :)
18:12:41 <shachaf> That wouldn't lose any desirable features (other than the (.) order), would it?
18:12:41 <dolio> copumpkin: Wouldn't that be qfbapa?
18:13:19 <Cale> cornihilio: runGet and runGetState assume that there will be no errors in parsing, and crash the program on failure
18:13:25 <hpaste> clahey pasted “MicroXML parser” at http://hpaste.org/76163
18:13:29 <copumpkin> dolio: I was wondering if they were the same guy!
18:13:37 <copumpkin> qf might be his little cousin
18:13:37 <Cale> (well, they throw an exception which is tricky to catch, because they are pure code)
18:13:41 <shachaf> I mean type Lens a b c d = forall f r. Functor f => ((a -> f b) -> r) -> (c -> f d) -> r
18:13:58 <dolio> Is there a paper reducing bapa to qfbapa?
18:14:11 <copumpkin> I didn't think that was possible
18:14:16 <dolio> Okay.
18:14:28 <copumpkin> I can't remember what's what though
18:14:34 <clahey> So, if anyone would be willing to look over my parser, I'd love any feedback.
18:15:01 <Cale> cornihilio: you'll want to use runGetIncremental instead, I think
18:15:53 <Cale> funny, the docs speak of runGetPartial, but don't define that. I think they just renamed it to runGetIncremental
18:16:08 <clahey> edwardk, I'm using trifecta.  Is oneOfSet specific to that or would that work with parsec?
18:16:20 <clahey> Oh, I have to run.  I'm at rehearsal.
18:16:33 <clahey> If you have any comments, my email is clahey@clahey.net or I'll be around later.
18:16:55 <Cale> shachaf: It would be interesting to see if there was any performance difference
18:17:08 <Cale> shachaf: I don't *think* it loses anything.
18:17:31 <cornihilio> uh, is there an obvious button on hackage when looking at the api for something to look at the newest stable version of the library?
18:17:34 <Cale> Apart from being even harder to describe in terms of category theoretic constructions :)
18:18:04 <shachaf> Cale: I hope lens operations tend to get inlined anyway for the most part.
18:18:06 <Cale> cornihilio: replace the version number in the URL with latest?
18:18:12 <shachaf> Well, I guess you can't do it in most of the interesting cases. :-)
18:18:56 <Cale> shachaf: So long as the things are functions which make sense, I don't mind what order I'm composing them in.
18:19:32 <Cale> niceisnice: Did I link you to the lens library proper?
18:19:40 <Cale> http://hackage.haskell.org/packages/archive/lens/3.0.1/doc/html/Control-Lens.html
18:19:41 <cornihilio> Cale: thank you very much for the help!
18:20:17 <Cale> http://hackage.haskell.org/packages/archive/lens/latest/doc/html/Control-Lens.html -- haha, should have used latest myself!
18:22:03 <niceisnice> Thanks Cale
18:22:19 <shachaf> Cale: It's kind of annoying how Google never finds the "latest"/versionless Hackage pages when those are almost always the ones you want.
18:23:22 <shachaf> On the other hand you want to make links in a post or something that don't become wrong when a module changes.
18:23:24 <typoclass> shachaf: i'll give eleventy billions to whoever makes google always go to the latest version (or latest stable)
18:23:28 <wumpus> I've also noticed that, it always find the documentation for older versions (that's not only with hackage, though)
18:24:58 <dgpratt> so what, in layman's terms, is a Kan extension?
18:25:20 <shachaf> A Kan extension is not in layman's terms, as far as I know.
18:25:57 <typoclass> dgpratt: i have no clue, but i think edwardk has a blog post explaining them (or series of blog posts, or deluge)
18:26:16 <shachaf> comonad.com has a few posts about the topic but it won't be immediately obvious. :-)
18:26:39 <typoclass> dgpratt: tell me when you find out what they are :-)
18:27:19 <dgpratt> shachaf: I wasn't entirely serious about it being in layman's terms :)
18:27:48 <dgpratt> surely Cale must know of these things?
18:28:35 <dgpratt> it's one of those subjects that keeps popping up in various contexts and its starting to bug me
18:30:45 <dgpratt> I suppose there is no royal road to Kan extensions
18:31:43 <dgpratt> (and even if there were, I'm not royalty)
18:33:03 <djahandarie> (Totally OT, but if anyone feels like listening to some sloppy improvisation on the piano: http://althack.org/2012-10-11-4.ogg )
18:35:07 <dgpratt> I feel as though something bad is about to happen...
18:35:24 <dgpratt> ...no, wait, it's all good...
18:35:49 <dgpratt> ...no, it's all bad! VERY bad!
18:36:17 <dgpratt> djahandarie: you're taking me on quite the emotional roller coaster ride, here
18:36:36 <djahandarie> Hehe :-)
18:37:08 <dgpratt> djahandarie: :)
18:38:06 <Cale> dgpratt: I know of them, but I don't understand Kan extensions satisfactorily enough to give an explanation for laymen
18:38:22 <dgpratt> Cale: fair enough
18:39:36 <dgpratt> oh, I'm digging this part, djahandarie
18:39:47 <djahandarie> 4:50ish?
18:40:02 <dgpratt> djahandarie: yep
18:40:08 <djahandarie> Yeah, that worked out well.
18:40:25 <zzo38> Does this Haskell type meaningful anything to you (I wrote it while trying to figure out something else):  (forall y. forall z r. (x -> Cont r z) -> Cont r ((z -> x') -> y)) -> y)   Is it understandable to you? I did not completely understand.
18:40:27 <Cale> They're sort of at the end *cough-cough* of a long story which proceeds in classical category theory by defining more and more general notions of "things satisfying a universal property"
18:42:56 <Cale> zzo38: The fact that there are more )'s than ('s is a bit worrying
18:43:08 <zzo38> Cale: I may have mistyped it, sorry.
18:43:19 <typoclass> @remember Cale The fact that there are more )'s than ('s is a bit worrying
18:43:20 <lambdabot> Nice!
18:44:02 <maukd> preflex: calc (1 + 2) * 3)
18:44:02 <preflex>  9
18:44:04 <maukd> pfft
18:44:12 <zzo38> (forall y. (forall z r. (x -> Cont r z) -> Cont r ((z -> x') -> y)) -> y)
18:44:23 <zzo38> That is what I meant.
18:44:40 <maukd> preflex: calc (1 + 2))) * 3
18:44:40 <preflex>  9
18:46:06 <zzo38> Cale: Is it OK now?
18:46:16 <Cale> zzo38: yeah, I'm just thinking about it
18:46:25 <Cale> There's a term of this type?
18:46:35 <Cale> @djinn a -> Cont r a
18:46:36 <lambdabot> Error: Undefined type Cont
18:46:46 <shachaf> @djinn-add Cont r a = (a -> r) -> r
18:46:46 <lambdabot> Cannot parse command
18:46:49 <shachaf> @djinn-add type Cont r a = (a -> r) -> r
18:47:01 <Cale> maybe the foralls are going to kill us
18:47:30 <zzo38> x and x' are external variables not forall
18:48:21 <Cale> @djinn ((x -> Cont r z) -> Cont r ((z -> x') -> y)) -> y
18:48:22 <lambdabot> -- f cannot be realized.
18:48:24 <Cale> right
18:50:02 <Cale> classically, I can expand this, and get y or (x' and z) or (x' and not x) or (not x and not z)
18:50:16 <Cale> (ignoring the Conts)
18:50:30 <Cale> I dunno
18:50:53 <cornihilio> Cale: hey, a quick question about runGetIncremental, how the hell does that not accept a bytestring? how does it work then?
18:52:30 <Cale> cornihilio: You apply it to an action of type Get a, and then you immediately get a Decoder a, which is probably Partial
18:53:18 <Cale> you then use pushChunk (to push in a strict bytestring) or pushChunks (to push in a lazy one)
18:53:46 <Cale> and you get another Decoder a
18:55:03 <Cale> you can then pushEndOfInput, just to inform any Partial decoder that nothing more is coming
18:55:35 <Cale> and finally see whether you have some failure, or parsed the thing successfully, or if it insists that the input is incomplete
18:58:49 <Cale> cornihilio: A nice thing about this is when you want to try to parse input when you're not sure whether you have it all (or sure that you don't), you can pass in part of the input and get a continuation which lets you continue later, or finish right then if the parser says it's done.
19:03:00 * hackagebot gluturtle 0.0.26 - turtle like LOGO with glut  http://hackage.haskell.org/package/gluturtle-0.0.26 (YoshikuniJujo)
19:05:06 <cornihilio> Cale: but do I have to worry about that? I am parsing 3 32-bit words at the immediate beginning of the bytestream. Is taking the length of a lazy bytestring before parse/get call costly?
19:05:45 <Cale> Well, it's not really necessary to do the check, because your parser will do it for you :)
19:06:04 <Cale> but no, it's not costly to measure the length of a ByteString
19:06:14 <Cale> at least, a strict one
19:06:41 <cornihilio> Cale: err, yeah, I'm using a lazy one...
19:07:51 <cornihilio> is there a cheap way of checking that a certain amount of bytes exist in a bytestream? that it at least has 96 bytes or whatever?
19:08:35 <Cale> It's *relatively* cheap to check a lazy bytestring's length
19:08:37 <maukd> not . null . drop n
19:08:48 <typoclass> cornihilio: have a thread taking 96 bytes, blocking if not enough is available?
19:08:58 <Cale> yeah, see maukd's function :)
19:21:42 <shachaf> maukd: What's preventing mauke from coming back?
19:22:01 <cornihilio> maukd, typoclass, Cale: thank you all!
19:22:30 <ivanm> shachaf: maukd is alphabetically lower and thus gets him slightly ahead in the queue? :p
19:22:45 <shachaf> I assume it's related to mauke.hopto.org
19:24:36 <cornihilio> I am experiencing a really weird error https://gist.github.com/3876976 in my code https://gist.github.com/3876974 atm. I don't get how on earth it's expecting a BSC.Bytestring, especially when I run a search and don't see it touching anything near there.
19:25:38 <ivanm> cornihilio: attoparsec returns strict bytestrings
19:33:13 <cornihilio> but the error is related to only the areas where I am using the Binary.Data.Get, right? I don't think attoparsec is involved at all in this area.
19:34:23 <Cale> cornihilio: the first parameter to Fail is a strict bytestring
19:34:45 <cornihilio> Cale: you mean a normal, non-lazy bytestring?
19:34:50 <Cale> right
19:35:30 <Cale> You possibly wanted Left (BL.pack err)?
19:37:13 <applicative> cornihilio: if you are using the  most recent ByteString, it has functions toStrict and fromStrict
19:38:22 <applicative> so it would be -> Left $ BL.fromStrict contents
19:39:36 <cornihilio> well I'm thinking about it now, and I'm pretty sure that running into an error when trying to get this packet data shouldn't be legal (no point in continuing on), so I'm just going to use a Maybe intstead.
19:40:46 <cornihilio> applicative: that's a pretty scary fuction I've never heard of. If my lazy bytestring is way bigger than ram, what do I get returned? a strict bytestrig bigger than ram? and I'm supposed to conver that back into being lazy? I've never heard of being able to mess with how lazy a bytestring is.
19:41:36 <ivanm> cornihilio: you typically only use those for smaller bytestrings, specifically in cases where attoparsec or something returns a strict and you're dealing with lazy
19:42:21 <shachaf> cornihilio: A strict bytestring is a contiguous array of bytes in memory. A lazy bytestring is a lazy list of string bytestrings.
19:42:33 <shachaf> cornihilio: From that you should be able to figure out everything about the behavior of fromString and toStrict.
19:55:14 <Nereid> I want overloaded function application.
19:56:00 <startling> haha
19:56:32 <startling> instance IsCallable a where call :: a b c -> b -> c ?
19:56:49 <startling> er, s/instance/class
19:56:51 <Nereid> no, not quite
19:57:11 <Nereid> for instance, any Applicative could be one.
19:58:22 <Nereid> class Apply a b c | a -> b, a -> c where ...
19:58:31 <Nereid> ($) :: a -> b -> c
19:58:32 <Nereid> or so
19:58:45 <Nereid> I dunno
19:59:05 <Nereid> I don't expect it to ever happen though
19:59:14 <Nereid> and applicative is good enough
20:00:15 <Cale> I HERD U LIEK AMBIGUOUS TYEPS
20:00:30 <Nereid> I know it can't work.
20:00:41 <Nereid> at least not in the obvious way.
20:01:22 <startling> what's the best way to error in template haskell? `error`?
20:01:27 <startling> or can I do something nicer?
20:01:56 <rwbarton> fail probably
20:02:29 <startling> can I point to some line of source somehow, though?
20:02:44 <rwbarton> whose source
20:03:05 <rwbarton> your source or the source of the place where the splice is?
20:03:50 <startling> the source of the place where the splice is
20:04:32 <rwbarton> I thought fail tells you that
20:05:10 <startling> ...oh.
20:06:25 <rwbarton> /tmp/temp.hs:5:1: test
20:06:42 <rwbarton> where there is a splice "x" on line 5 of temp.hs, and x is defined as fail "test" in another file
20:07:18 <rwbarton> error (instead of fail) gives a different error message
20:07:33 <rwbarton> which is somehow simultaneously more and less useful...
20:07:57 <rwbarton> it shows the code that caused the splice that errored but not its location in the file
20:08:17 * shachaf found out about the magic of assert recently.
20:08:42 <shachaf> @ty GHC.Base.assert
20:08:44 <lambdabot> forall a. Bool -> a -> a
20:09:03 <copumpkin> it's pretty magic :)
20:09:29 <typoclass> shachaf: i think people get it from Control.Exception usually
20:10:03 <shachaf> typoclass: Sure, but :i in GHC doesn't tell you where you got a symbol, just where it's defined.
20:10:21 <shachaf> I found out about assert from reading GHC sources! So at least one useful thing has come of it so far.
20:13:04 * hackagebot gluturtle 0.0.27 - turtle like LOGO with glut  http://hackage.haskell.org/package/gluturtle-0.0.27 (YoshikuniJujo)
20:26:00 <hpaste> lispy pasted “cabal install cabal-install error” at http://hpaste.org/76164
20:26:54 <lispy> anyone have ideas about that cabal install error?
20:27:15 <lispy> I just upgraded to ghc-7.6 and now I'm trying to upgrade my cabal-install
20:28:08 <shachaf> lispy: Did something get messed up in your ~/.cabal?
20:28:17 <shachaf> Did you `cabal update`?
20:28:36 <lispy> shachaf: I don't have a ~/.cabal
20:28:41 <edwardk> shachaf: re the direction of (.) i don't know that i'd reverse it for lens even if i could
20:28:43 <lispy> I also didn't cabal update
20:28:56 <shachaf> edwardk: I'm not saying it's the wrong direction.
20:29:11 <edwardk> the fact that (.) as composition turns into the classic imperative foo.bar.baz is one of the best parts
20:29:14 <shachaf> It is the opposite of what you'd get if it was a normal Category instance, though.
20:29:21 <shachaf> edwardk: You can do that with any lens type, though! :-)
20:29:32 <carter_> shachaf how's it the opposite
20:29:36 <carter_> ?
20:29:37 <edwardk> shachaf: not without reversing the arguments
20:29:46 <shachaf> lispy: Oh, you should try `cabal update`, I guess.
20:29:51 * carter_ looks at the hackage docs
20:29:57 <shachaf> edwardk: What do you mean?
20:30:21 <shachaf> I mean that you can e.g. say userVisibleLens = (Control.Category.. realLens)
20:30:23 <edwardk> Lens Foo Bar . Lens Bar Baz ==> Lens Foo Baz
20:30:29 <shachaf> And then compose those with with (.)
20:30:30 <dolio> Because OO-style x.foo.bar = bar (foo x) = (bar . foo) x
20:30:34 <shachaf> It's a similar CPSy thing.
20:30:52 <dolio> Backwards.
20:31:21 <hpaste> lispy annotated “cabal install cabal-install error” with “what does cabal update do?” at http://hpaste.org/76164#a76165
20:31:28 <lispy> shachaf: ^^ :)
20:33:27 <shachaf> > let invf, invg, invh :: (Expr -> r) -> (Expr -> r); invf = (. f); invg = (. g); invh = (. h); run = ($ id) in run (invf . invg . invh) x
20:33:30 <lambdabot>   h (g (f x))
20:33:35 <shachaf> That works for any Category, not just (->)
20:33:46 <typoclass> lispy: it asks hackage.haskell.org for the newest index of all packages. subsequent 'cabal install' runs will be able to fetch those packages. i'd expect that cabal needs to do update at least once that after installing (i wonder why it didn't tell you so ...)
20:33:56 <shachaf> lispy: ?
20:34:04 <shachaf> lispy: Did you run it without --help?
20:34:19 <lispy> oh, sorry, I've been thinking of 'cabal upgrade'. Yes, I did an update earlier (and just now again to be sure)
20:34:30 <shachaf> And it still happens?
20:34:39 * shachaf is going to blame it on Windows.
20:34:40 <lispy> shachaf: yes
20:34:43 * lispy too
20:34:52 <typoclass> lispy: right, upgrade was the thing that kept breaking people's stuff. i think they disabled it at some point
20:34:55 <shachaf> (Because I've never gotten that error. ∎)
20:35:18 <rwbarton> I think this kind of thing can happen when your Cabal is too old to read some .cabal files on hackage
20:35:18 <typoclass> lispy: try adding -v3. your initial error message sure is puzzling
20:35:44 <typoclass> rwbarton: i think lispy was mentioning he has the cabal that came with ghc 7.6
20:35:58 <rwbarton> I didn't think that was what he said
20:36:07 <rwbarton> oh, the Cabal, perhaps
20:36:20 <rwbarton> but cabal-install is statically linked against Cabal
20:36:41 <rwbarton> lispy: cabal --version
20:36:47 <cornihilio> what does an error like Couldn't match expected type `Maybe (HeaderSimple, BL.ByteString)' with actual type `(t0, t1)' mean?
20:36:52 <shachaf> typoclass: Didn't he say he has an old cabal that he wanted to upgrade?
20:36:52 <lispy> I have an OLD cabal actually
20:36:58 <shachaf> Oh, -v3 is a good idea.
20:37:03 <cornihilio> in regards to this line of code:     DBG.Done contents' index header -> (header, contents')
20:37:06 <typoclass> rwbarton: i could have sworn ghc came with cabal-install these days ... nvm
20:37:21 <Nereid> nice discovery of the day. http://hackage.haskell.org/package/applicative-quoters
20:37:23 <hpaste> lispy annotated “cabal install cabal-install error” with “cabal --version” at http://hpaste.org/76164#a76166
20:38:27 <hpaste> lispy annotated “cabal install cabal-install error” with “install -v3” at http://hpaste.org/76164#a76167
20:38:45 <shachaf> lispy: How can you not have a .cabal?
20:38:50 <shachaf> You must have a .cabal if you did `cabal update`.
20:38:52 <frio> typoclass: ghc doesn't, but haskell-platform does :)
20:38:58 <shachaf> I'm guessing it's hidden away somewhere Windowsy.
20:39:02 <typoclass> frio: ah i see
20:39:45 <lispy> isn't there a repair command or something for ghc-pkg? anyone recall the command?
20:39:56 <rwbarton> lispy: http://comments.gmane.org/gmane.comp.lang.haskell.libraries/18025
20:40:08 <lispy> shachaf: yeah, I can't find my .cabal probably because I'm a newb on windows
20:40:08 <shachaf> lispy: I think it's your cabal, not your ghc-pkg, that's broken.
20:40:34 <rwbarton> yes
20:40:37 <rwbarton> FSVO broken.
20:40:41 <frio> why's it looking at warp anyway? :/
20:40:53 <rwbarton> it looks at everything
20:40:58 <typoclass> frio: i think it's trying to read through all the .cabal files
20:40:59 <rwbarton> why? who knows
20:41:01 <frio> ah, right
20:41:04 <frio> ahhhh
20:41:10 <lispy> interesting
20:41:11 <frio> so try ghc-pkg unregister warp or something
20:41:15 <rwbarton> no no
20:41:20 <typoclass> rwbarton: good catch
20:41:22 <lispy> my ghc-pkg doesn't know about warp
20:41:33 <rwbarton> the .cabal file is in 00-index.tar or whatever
20:41:35 <lispy> So it really has to do with the index
20:41:40 <rwbarton> the archive of all .cabal files on hackage ever
20:41:43 <typoclass> lispy: the mail thread describes a fix
20:41:46 <lispy> So I'll have to munge the index everytime I update
20:41:50 <shachaf> lispy: Just strace it! ...Wait, Windows.
20:41:58 <lispy> shachaf: yeah :(
20:41:59 <rwbarton> no, just until you cabal install cabal-install to a new version
20:42:24 <lispy> ah right
20:42:25 <frio> ah rwbarton, i see
20:42:27 <frio> good link :)
20:43:14 <typoclass> it's kind of embarrassing that cabal can be killed in this way, instead of just ignoring the unparsable sections or files
20:43:18 <lispy> okay, next question: Where should I find 00-index.tar
20:43:59 <rwbarton> now that is a good question
20:44:01 <lispy> oh, I think windows might automatically limit file searches such that my HP install is not getting searched
20:44:24 <typoclass> lispy: try this ghci command http://www.haskell.org/haskellwiki/Cabal-Install#The_cabal-install_configuration_file
20:44:39 <rwbarton> wow
20:44:49 <rwbarton> windows...
20:45:20 <lispy> typoclass: thanks
20:45:23 <shachaf> lispy: C:\Users\lispy\something?
20:45:32 <shachaf> \Application Data\something?
20:45:49 <typoclass> shachaf: most likely c:\Users\lispy\.cabal
20:45:49 <shachaf> Maybe Application Data\Roaming\something. One of those Windowsy places.
20:46:11 <lispy> "C:\\Users\\dagit\\AppData\\Roaming\\cabal"
20:46:29 <strebe> hm. I'm trying to get my head around functors. Aren't they essentially arrows in the special case where the objects happen to be categories?
20:46:31 <shachaf> Wait, my guess was right?
20:46:31 <lispy> the lack of a leading dot is part of why I couldn't find it
20:47:49 <shachaf> I remember when I ran Windows and my main drive letter accidentally ended up being E:
20:47:52 <shachaf> Not pleasant.
20:49:16 <maukd> better than Ě:
20:49:33 <shachaf> Or Е.
20:49:33 <maukd> ∵:
20:49:42 <lispy> Now that I'm passed the issue with warp, I've run into new fun. I need to teach cabal where to find my C compiler
20:49:47 <lispy> Why windows? Why?
20:50:12 <shachaf> lispy: Why Windows, indeed?
20:50:48 <maukd> wherefore art thou windows
20:51:46 <Nereid> strebe: sure, functors are the arrows in the category of categories.
20:51:58 <Nereid> but that doesn't really say anything about functors.
20:52:05 <Nereid> it just tells you what the category of categories is.
20:53:15 <lispy> I guess the Haskell Platform installer should ask (and recommend) to add its mingw to your path during install
20:53:27 <strebe> Nereid: I was wanting to make sure I was piecing things together correctly, and I was a bit amazed that that wasn't explicitly mentioned, so figured I'd double check to make sure I wasn't entirely going down the wrong path. Thanks. :-)
20:53:35 <lispy> Then you'd get a plausible C/C++ compiler
20:53:57 <shachaf> lispy: I doubt you'd get a C++ compiler.
20:54:09 <shachaf> Well, not with GHC.
20:54:16 <shachaf> GHC comes with a C compiler, though, doesn't it?
20:54:16 <lispy> shachaf: That seems to be the case
20:54:38 <lispy> shachaf: I think it comes with a mingw install of GCC (not just 'gcc')
20:54:51 <shachaf> Ah.
20:54:58 <shachaf> Anyway, you can use ghc to compile your C files. :-)
20:55:24 <lispy> unless the package specifically tries to invoke a C compiler (like say, the Network package)
20:55:30 <shachaf> Hmm, maybe it still links in the RTS.
20:55:34 <typoclass> shachaf: not that cabal would know about it, apparently. which is of course windows' fault somehow
20:55:36 <typoclass> :)
20:55:43 <shachaf> CC=ghc
20:56:19 <lispy> Now I have a problem where the version of HTTP that it tries to use doesn't work with ghc 7.6...
20:56:27 <lispy> THis is much more tedious than I would have expected
20:57:41 <orzo_> i needed a sort for a mostly-sorted list.  I came up with this thing sort of like merge sort, but with an O(n) pass that generates an intial list of sorted lists that it is divide-and-conquer reduced via a merge operation.  I'm curious if that algorithm has a name and if it was worthwhile to do in the first place.
20:57:44 <hpaste> orzo pasted “What's this sort called?” at http://hpaste.org/76168
20:58:00 <Jafet> That's called Data.List.sort.
20:58:03 <Tarrasch> Hello, if a package making a newtype didn't do an automatic deriving upon decleration. Can I do it in a external library? I know this will cuase an orphan instance but still
20:58:21 <orzo_> oh really, that's the Data.List.sort algorithm?
20:59:02 <guidj0s> Hopefully, implementation-defined.
20:59:38 <gienah> lispy: later HTTP versions build, or there is a patch: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/http/files/http-4000.2.3-ghc-7.6.patch
20:59:56 <Jafet> Well, sort additionally uses the fact that after an ascending chain ends, there is a descending one.
20:59:57 <lispy> I'm going to try a different approach.
21:00:12 <dolio> orzo_: Your algorithm is O(n^2) on a sorted list.
21:00:26 <fenton> any suggestions as to why I get: cabal install ghc-mod
21:00:29 <fenton> cabal: Command.optionToFieldDescr: feature not implemented
21:00:33 <lispy> Why? Because I edited HTTP.cabal to allow ghc-7.6, but the autogenerated code (generated by cabal) didn't compile. So I think that means I should try the bootstrapping script instead
21:00:46 <dolio> Oh, wait, maybe not.
21:01:09 <guidj0s> orzo_: Randomize a simple quicksort.
21:01:38 <lispy> and the bootstrap fails
21:02:31 <lispy> another option is to install the version of the HP that I skipped
21:02:35 <orzo_> i'm looking at Data.List.sort code, i think it might very well be the same algorithm
21:02:41 <lispy> Presumably that version of cabal could handle this
21:02:50 <gienah> lispy: setup --verbose=3 might give more hints (maybe, not sure about this bootstrap script)
21:02:57 <guidj0s> orzo_: The same as which?
21:03:05 * lispy get sthe idea to install an intermediate version of cabal-install
21:03:49 <gienah> s/setup --verbose=3/setup configure --verbose=3/
21:04:36 <orzo_> guidj0s: Data.List.sort is the same algorithm as my paste, but coded in fewer lines
21:04:39 <dolio> orzo_: Disregard that. I thought you were building up a list with xs ++ [x] for a second there.
21:04:58 <gienah> probably more likely: cabal-install configure --verbose=3   (not sure because I don't use cabal-install)
21:05:23 <dolio> Unless your custom span is, in which case it is O(n^2).
21:05:29 <orzo_> guidj0s: i'm still verifying that though
21:05:50 <guidj0s> orzo_: Why not use the existing one?
21:06:24 <orzo_> guidj0s: curiosity, i dont know
21:07:07 <guidj0s> orzo_: Then consider quicksort, with a random pivot choice.
21:07:12 <orzo_> guidj0s: i just wanted O(n) on sorted list garonteed while other cases being good
21:07:44 <guidj0s> Oh, well. My suggestion gives O(nlogn) for sorted input.
21:08:15 <orzo_> my input is likely sorted
21:09:59 <Jafet> Sometimes insertion sort works even better than mergesort.
21:10:15 <dolio> That's for small lists.
21:10:39 <guidj0s> Jafet: Subjective.
21:12:07 <dolio> Quicksort with a random pivot choice isn't very ideal for lists.
21:12:08 <Jafet> Insertion sort is faster on the following list: concatMap [[2*i, 2*i-1] | i <- [1..n]]
21:12:24 <Jafet> s/Map//
21:13:06 * hackagebot http-reverse-proxy 0.1.0.1 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.1.0.1 (MichaelSnoyman)
21:17:14 <orzo_> With input [1,2,34,2,5,8,4,7,9], my toSortedChains yields [[1,2,34],[2,5,8],[4,7,9]] but Data.List.sort as linked from http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#sort uses a sequences function that yields [[1,2,34,2,5,8,4,7,9]].
21:17:28 <orzo_> which is not what i expected
21:17:30 <orzo_> heh
21:20:25 <cornihilio> can you do assignment within an if then expression?
21:20:34 <Jafet> orzo: it does not.
21:20:39 <dolio> What's assignment?
21:20:42 <orzo_> Jafet: does not what?
21:21:01 <orzo_> i cut and pasted sequences into a module and set cmp=compare as a global
21:21:10 <cornihilio> if x > 0 then y = 3 else y =6
21:21:35 <cornihilio> I tried doing that in a where block and the compiler got mad at me...
21:21:42 <Jafet> dolio: something grownups don't have to do any more
21:21:57 <dolio> Oh.
21:22:06 <dolio> Use y | x > 0 = 3 | otherwise = 6
21:22:19 <Jafet> y = if x > 0 then 3 else 6
21:22:21 <dolio> And that's not assignment.
21:22:29 <dolio> That's a definition of y.
21:22:38 <dolio> My point was, assignment doesn't exist.
21:23:10 <orzo_> writeIORef
21:23:11 <orzo_> heh
21:23:13 <rking> This page says "a .Haskell-like syntax" ( https://en.wikipedia.org/wiki/Agda_(theorem_prover) ). Is that a glitch or does ".Haskell" actually mean something?
21:23:28 <rking> I had to wipe my screen to make sure that wasn't a fleck of snoo stuck to the screen.
21:24:25 <shachaf> Just a glitch.
21:24:33 <rking> OK, deleting. ☺
21:25:14 <orzo_> Jafet: when you said "it does not." were you indicateing you did a similar test of the "sequences" function and that i somehow screwed up the code in transfer?
21:26:11 <Jafet> I don't really have to test it, but yes
21:28:47 <hpaste> orzo pasted “sequences” at http://hpaste.org/76170
21:29:15 <lispy> Okay, looks like HTTP needs to require at least Cabal version 1.14 (currently allows Cabal 1.8)
21:29:24 <orzo_> That is code from http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#sort
21:29:58 <rwbarton> what happened on line 5
21:30:09 <rwbarton> you switched the order of the cases in sequences
21:30:17 <Jafet> He accidentally the base case
21:30:43 <orzo_> rwbarton: good catch
21:31:16 <orzo_> that fixed it, now the only difference is their version adds an extra [] to the end where mine had no empty lists
21:31:39 <orzo_> theirs: [[1,2,34],[2,5,8],[4,7,9],[]], mine: [[1,2,34],[2,5,8],[4,7,9]]
21:32:07 <orzo_> so i think it is the same algorithm
21:32:20 <dolio> Yours wasn't O(n) on descending lists, was it?
21:32:45 <dolio> Although you may not have any of those.
21:33:01 <orzo_> hm, i wasnt concerned about that case
21:33:42 <orzo_> but if the Data.List version is O(n) for both cases and does as well as mine otherwise, then i ougt to use it i guess
21:33:58 <dolio> Also they do some funky merge strategies.
21:34:11 <dolio> Pairwise to maybe keep the lists similar size and stuff.
21:34:20 <shachaf> The picture on https://en.wikipedia.org/wiki/Agda_(theorem_prover) is great.
21:34:25 <orzo_> i do that same thing
21:34:29 <dolio> Oh, okay.
21:35:04 <dolio> shachaf: That (< ... >) looks unnecessary.
21:35:08 <rwbarton> it looks like what a theorem prover would look like in a movie
21:35:45 <shachaf> What's (< ... >)?
21:35:59 <dolio> It has letters I can't type in the ... part.
21:36:09 <dolio> But it's (< gamma_1 , gamma_2 >) or something.
21:36:13 * lispy has finally upgraded his ghc
21:36:17 <lispy> (and cabal)
21:36:18 <dolio> The parens seem superfluous.
21:36:35 <shachaf> dolio, deprived of his magical Emacs powers, is forced to type ASCII like the rest of us mortals.
21:36:36 <dolio> It's hard to tell, though, because it's a 10-character wide column in the middle of a block of text.
21:36:48 <dolio> Oh, actually, I may be able to type them.
21:38:10 <dolio> (< γγsub1
21:38:12 <dolio> Damn.
21:38:41 <dolio> (< γ₁ , γ₂ >)
21:39:03 <rwbarton> I wonder whether it is even an actual photo of a screen or just CGI
21:39:10 <shachaf> Hey, I can do it too. (< γ₁ , γ₂ >)
21:39:25 <dolio> ibus kind of sucks.
21:39:27 <shachaf> C-S-u 3B3 <space>, <Compose> _ 1 , etc.
21:39:40 <shachaf> You just have to know the codepoint. I knew that alpha was 3b1 so it was easy.
21:39:55 <dolio> Yeah, I'm not going to memorize codepoints.
21:40:17 <Cale> I remapped my left Win key to Greek
21:40:30 <shachaf> Your loss, dolio.
21:40:33 <Cale> γ = Win-g
21:41:01 <rwbarton> (< γ₁ , γ₂ >)
21:41:08 <rwbarton> i can type it too using screen copy/paste :)
21:42:10 * shachaf wonders where Peaker's gone.
21:42:38 <Cale> =→　(< γ₂ , a₂ >)
21:46:45 <Cale> http://hackage.haskell.org/packages/archive/Agda/2.3.0.1/doc/html/src/Agda-Auto-Auto.html#auto -- wow
21:47:49 <shachaf> That's, uh...
21:47:51 <shachaf> Quite a function.
21:50:15 <dolio> Wow, agsy is all one function, huh?
21:51:06 <Cale> I like how there's a function called smash'em (in Agda.Compiler.Epic.Smashing)
21:51:18 <bos> whoa, that's the scariest haskell function i've ever seen
21:51:26 <bos> scarier even than fix f = f (fix f)
21:51:49 <shachaf> fix isn't scary.
21:52:03 <shachaf> fix f = let x = f x in x is scaries, anyway.
21:52:31 <bos> so long as we're reading from the same joke book
21:52:38 <thoughtpolice> heh, i like how it has: 'let cmnt = if ii' == ii then agsyinfo ticks else ""' and then, 'where agsyinfo ticks = ""'
21:52:42 <dolio> Should be Agda.Compiler.Epic.Nigel.Thornberry.Smashing
21:52:46 * bos smashes the hashable package with a mallet
21:52:48 <pikhq> And I thought the code gen in my Brainfuck compiler was bad.
21:52:58 <shachaf> Hey, bos is alive.
21:53:07 * hackagebot cblrepo 0.7.0 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.7.0 (MagnusTherning)
21:53:18 <pikhq> https://github.com/pikhq/haskell-bfc/blob/master/main.hs (40 lines of *Haskell*?)
21:53:58 <bos> did you know that () is an instance of Enum?
21:54:16 <pikhq> Well, I suppose it does have an ordering.
21:54:30 <Cale> A lot of Agda's code looks very well written though.
21:54:31 <pikhq> () == ()
21:54:37 <bos> it's also an instance of Bounded
21:54:40 <shachaf> bos: That sounds perfectly reasonable to me.
21:54:50 <shachaf> Even useful in some cases.
21:55:00 <bos> shachaf: it's reasonable, but simultaneously funny
21:55:17 <shachaf> bos: Are you going to be at the meeting next week?
21:55:20 <lispy> > suc ()
21:55:21 <lambdabot>   Not in scope: `suc'
21:55:27 <lispy> > succ ()
21:55:28 <lambdabot>   can't find file: L.hs
21:55:34 <bos> shachaf: i don't know what "the meeting" is, so no
21:55:57 <shachaf> https://sites.google.com/site/bayareahaskell/
21:56:04 <bos> definitely not going
21:56:08 <lispy> This is what bugs me
21:56:08 <shachaf> edwardk is talking about lenses and things.
21:56:08 <lispy> Prelude> succ ()
21:56:09 <lispy> *** Exception: Prelude.Enum.().succ: bad argument
21:56:12 <bos> cool
21:56:13 <shachaf> Ah, OK.
21:56:20 <bos> i'll be in finland
21:56:22 <cornihilio> does Data.Binary.Get.runGet have any return values besides Get? How am I supposed to capture any error/fail that it throws?
21:56:26 <Cale> pikhq: you should use Harpy :)
21:56:32 <shachaf> Finland is a good place to be!
21:56:36 <edwardk> bos: fair nuff
21:56:38 <Cale> > [()..]
21:56:39 <lambdabot>   [()]
21:56:46 * shachaf should go there again sometime.
21:57:05 <Cale> cornihilio: you don't catch that error
21:57:08 <lispy> > succ ()
21:57:09 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
21:57:15 <lispy> ah, there we go
21:57:15 <Cale> cornihilio: runGet is for when you know it's going to succeed
21:57:41 <Cale> cornihilio: There is technically a way to catch that error, but it is fiddly
21:57:55 <pikhq> Cale: Eh, it was more amusing doing it manually.
21:58:01 <cornihilio> Cale: oh no, so I am stuck using that weird incremental one? nooooooo
21:58:01 <edwardk> bos: you mean there is something in Finland other than Assembly? This boggles my mind.
21:58:07 <lispy> It seems like if we're going to have succ for () that maybe we need to make some rule like: succ () == ()
21:58:12 <pikhq> Though if I make it any less trivial, I'll probably want to do something like that.
21:58:31 <Cale> cornihilio: You should be able to use the incremental one to write something like runGet but which gives you a potential error.
21:58:41 <shachaf> edwardk: There are many lakes.
21:59:02 <edwardk> shachaf: oh yeah you have like a finnish grandmother or something, right?
21:59:45 <shachaf> Yes. Tomorrow's her birthday!
21:59:49 <edwardk> its like shachaf's 13th citizenship
21:59:57 <edwardk> =)
22:00:14 <shachaf> edwardk: We're not counting IRC channels here, are we?
22:00:28 <edwardk> shachaf: =P
22:00:39 <Cale> http://www.smbc-comics.com/ :D
22:01:19 <shachaf> Cale: The worst part is that Leibniz did it first!
22:03:23 <edwardk> I'm pretty sure you can substitute Leibniz for Newton in any predicate. Maybe we should call that Newtonian equality… or, after substitution, Leibnizian equality.
22:04:06 <shachaf> @remember edwardk I'm pretty sure you can substitute Leibniz for Newton in any predicate. Maybe we should call that Newtonian equality…
22:04:07 <lambdabot> I will remember.
22:04:14 <shachaf> Hmm, should I add the last bit in?
22:04:27 <edwardk> *shrug*
22:04:41 * shachaf likes it without.
22:04:41 <rwbarton> better without
22:04:44 <clahey> edwardk, Willing to help me debug my parser?
22:04:48 <clahey> What was it?
22:05:18 <edwardk> clahey: that question really invites a no response ;)
22:05:27 <hpaste> clahey pasted “MicroXML parser” at http://hpaste.org/76171
22:05:44 <shachaf> edwardk: Remember last year when you were talking about Leibnizian equality?
22:05:47 <clahey> edwardk, That is a totally allowed response.
22:05:55 <shachaf> Those were the days, man.
22:05:59 <edwardk> clahey: willing, yes. able, maybe not ;)
22:06:13 <edwardk> shachaf: I use it a lot
22:06:21 <clahey> So, that hpaste is the code.
22:06:34 <clahey> When parsing http://dvcs.w3.org/hg/microxml/raw-file/tip/spec/microxml.html
22:06:39 <clahey> It says:
22:06:59 <clahey> /home/clahey/microxml.html:3:1: error: expected: end tag
22:06:59 <clahey> <head>
22:06:59 <clahey> ^
22:06:59 <clahey> Nothing
22:07:34 <edwardk> clahey: im going to pet you are missing a bunch of strategically placed 'try' blocks
22:07:52 <cornihilio> is there a really cheap sorting data structure for haskell? I basically want to easily add an item to the right place, so it stays sorted, and remove any values that are lower than x
22:08:11 <cornihilio> I'm guessing I want something more complex than a list, but I'm not sure
22:08:19 <shachaf> cornihilio: Data.Set?
22:09:13 <cornihilio> shachaf: thank you!
22:09:27 <clahey> edwardk, So is there a debugging tool for this?
22:09:34 <edwardk> clahey: not really
22:09:49 <clahey> You just have to think at it really hard?
22:09:53 <edwardk> yep
22:10:01 <shachaf> Another approach is to be right the first time.
22:10:25 <edwardk> that works well for me
22:10:28 <clahey> So, I should theoretically be able to add try to every production.
22:10:34 <clahey> It'll just be slower.
22:10:43 <edwardk> its a very bad idea to 'over-try' ;)
22:10:52 <clahey> Because?
22:11:02 <edwardk> the whole thing becomes pretty abysmal and you get no usable error messages
22:12:03 <edwardk> in your <head> example did you have a matching closing </head>?
22:12:24 <clahey> Yes.
22:12:47 <clahey> I wouldn't be surprised if it's not parsing the element for some other reason.
22:13:11 <clahey> Why wouldn't it report expecting element?  Does the try suppress that?
22:13:37 <edwardk> as a rule of thumb, if you use try, also use a <?>
22:13:43 <edwardk> try foo <?> "whatever"
22:14:02 <edwardk> because try causes it to throw away the information about what it was expecting and where it was expecting it that happened inside of foo
22:14:08 <edwardk> so you need an error that is 'located where you started'
22:14:14 <edwardk> thats what the <?> is for
22:15:19 <edwardk> you have a few options. you could move the 'try' into 'element' itself, that way making it self-contained, and then you don't have to duplicate the <?>
22:15:46 <edwardk> element = try (do … ) <?> "element"
22:16:40 <edwardk> that'd probably be my preferred solution if it were my code
22:16:53 <clahey> Ha.
22:17:10 <clahey> That just moved the error to sooner and it says, "expected element"
22:17:18 <edwardk> progress ;)
22:17:38 <edwardk> fix up the rest of your try's to also have <?>'s and see if you get more expected alternatives
22:17:39 <clahey> Which makes sense since the try is problematic.  It just makes it a useless message.
22:18:11 <edwardk> another trick here, is you can see if that is too big of a try
22:18:45 <clahey> It won't.  The toplevel basically is an element with a little dressing and that's where it's having the problem.
22:18:52 <edwardk> which i guess may not work because of <foo/> tags
22:18:53 <clahey> ... I'll try that.
22:19:04 <clahey> Those are still elements.
22:19:10 <clahey> I did left expression merging.
22:19:31 <edwardk> then basically you may be able to factor the try down deeper into element
22:19:39 <clahey> Right.
22:19:47 <edwardk> e.g. by committing once you've parsed char '<' and name
22:20:02 <clahey> Yep.
22:20:15 <edwardk> e.g. element = do nameVal <- try $ char '<' >> name; ...
22:20:51 <edwardk> the game is to try to minimize the use of try and the scope it has as much as possible to fake LL(1) as much as you can
22:21:47 <edwardk> that way you'll get error messages closer to the actual problem, because you'll be more 'committed'
22:24:10 <clahey> It's the empty element tag that's messing it up.
22:24:18 <clahey> /home/clahey/microxml.html:5:117: error: unspecified error
22:24:18 <clahey> <c/css/spec/cg-draft.css" rel="stylesheet" type="text/css" charset="utf-8" />
22:25:02 <edwardk> guess you might have scewed up the left factoring then =)
22:25:06 <clahey> That minimizing the try thing was beautiful.
22:25:13 <clahey> Probably.
22:26:21 <clahey>  [] <$ string "/>"
22:26:28 <clahey> That seems right to me.
22:26:34 <edwardk> seems plausible
22:26:36 <otters> that almost looks like an HTML tag
22:26:44 <edwardk> otters =)
22:27:00 <clahey> otters, Yeah.  It's html while also being valid microxml.
22:28:27 <edwardk> erm, where is the whitespace between the name and attributes, etc. being consumed in all of this?
22:28:41 <edwardk> < foo >
22:28:57 <clahey> s
22:29:07 <clahey>   (skipMany s <?> "optional space")
22:29:07 <edwardk> ah
22:29:25 <edwardk> nameVal <- name;  attributes <- attributeList;  skipMany s
22:29:32 <edwardk> where is the s between name and attributeList?
22:29:42 <edwardk> oh some s *> attributeList
22:29:54 <edwardk> "attributeList = M.fromList <$> many (some s *> attribute)"
22:29:57 <edwardk> missed that
22:30:03 <clahey> Yep.
22:30:15 <edwardk> so used to the space being tracked by something like lexeme that i'm not used to dealing with it by hand
22:30:24 <clahey> Ah.
22:30:36 <clahey> Except that space is relevant in a lot of contexts.
22:30:47 <edwardk> attribute = (,) <$> (attributeName <* skipMany s) <*> (char '=' *> skipMany s *> attributeValue)  -- can be cleaned up
22:31:24 <clahey> liftM2?
22:31:28 <edwardk> attribute = (,) <$> attributeName <* skipMany s <* char '=' <* skipMany s <*> attributeValue
22:31:37 <edwardk> put the >'s before the things you want
22:31:41 <edwardk> remove the rest
22:31:47 <edwardk> and no parens need apply ;)
22:31:49 <clahey> Got it.
22:32:12 <edwardk> this only works if you use <* <*> <$ and <$>. when you mix *> this rule goes to hell
22:32:33 <edwardk> bra *> x <* ket is about the only time i like using *>
22:32:44 <edwardk> mainly because it doesn't generalize like the above
22:33:44 <edwardk> so its complaining at the /> in your example?
22:33:49 <clahey> Yep.
22:34:03 <clahey> unspecified error.
22:34:16 <clahey> I've added a bunch more <?> and it's still unspecified.
22:34:23 <edwardk> interesting
22:34:43 <edwardk> can you hpaste the current one?
22:35:12 <hpaste> clahey pasted “MicroXML parser” at http://hpaste.org/76172
22:35:21 <clahey> Yes.
22:38:10 <astropirate> Do many people use haskell for web based applications?
22:38:37 <astropirate> I know there are a couple of web frameworks
22:38:54 <astropirate> but was wondering just how widespread is haskell on the web
22:39:21 <astropirate> I pondering on using it. but will do so if there aren enough libraries and tooling out there. I dont want to write everything
22:39:21 <edwardk> @hpaste
22:39:22 <lambdabot> Haskell pastebin: http://hpaste.org/
22:39:36 <hpaste> edwardk pasted “microxml fiddling” at http://hpaste.org/76173
22:39:55 <edwardk> i need to install trifecta on this machine still, but this was just a few cleanups
22:40:33 <edwardk> still unspecified?
22:40:42 <clahey> I've added even more <?>.  What did you change?
22:41:13 <edwardk> i moved the <?>'s to the definition sites more, removed some prophylactic parens by using layout better
22:42:05 <edwardk> e.g.  s = oneOf "\x9\xa\x20" <?> "space"   instead of commenting each use site
22:42:24 <edwardk> that way the error report will say, expected foo, space, or blah.
22:43:39 <clahey> Expected space.
22:44:19 <clahey> Got it.
22:44:49 <Cale> astropirate: The company I work for is about to replace our backend with one written in Haskell.
22:45:19 <clahey> It parsed the space as the beginning of an attribute.
22:45:30 <edwardk> makes sense
22:46:07 <edwardk> you can refactor the grammar to put the space parsing after the preceding attribute/name
22:46:22 <edwardk> this is actually a fairly common problem with 'front parsing' the space
22:47:00 <edwardk> as your grammar exists right now you'd wind up reparsing the same whitespace. once to try to parse it in an attribute and again to parse to the />
22:47:38 <edwardk> lex p = p <* skipMany s
22:48:09 <astropirate> Cale, ohh? were you involved in the development?
22:48:19 <edwardk> then you can refactor to use lex name, many (lex attribute)
22:48:36 <Cale> astropirate: Well, I am, we're just starting in on it.
22:48:51 <Cale> astropirate: There are at least three major web frameworks in Haskell right now: Happstack, Snap, and Yesod.
22:49:53 <clahey> edwardk, That would mistakenly allow <a b="c"d="e"/>
22:50:08 <clahey> But I can use sepBy.
22:50:12 <edwardk> sure
22:50:27 <Cale> astropirate: and they're all pretty modular and cover a fairly wide range of concerns as far as what you'll typically need in a web application.
22:54:13 <fenton> anyone using arch linux and emacs to program in haskell?
22:54:42 <clahey> Any idea why noneOf "<&>" wouldn't match ?
22:55:34 <Cale> clahey: encoding issue maybe?
22:55:36 <clahey> I changed it to be the proper class and now it just works.
22:55:45 <Cale> hmm
22:57:27 <certainty> .,
22:57:48 <clahey> edwardk, Thank you much.
22:58:07 <clahey> edwardk, I will keep working on decreasing the use of try and improving error messages.
22:58:18 <edwardk> clahey: got it to work?
22:58:21 <clahey> Yep.
22:58:24 <edwardk> great =)
22:58:50 <clahey> It was the attribute space thing and then it wasn't handling an unrecognized character.
22:59:04 <clahey> I dislike that it was saying "expected end tag"
22:59:37 <clahey> It was saying that because content could validly end there since it was a many.
22:59:52 <clahey> And content must be followed by an end tag, which wasn't there.
23:00:15 <clahey> But element or dataChar or charRef would all have been valid there.
23:00:46 <clahey> Not sure how to make that better.
23:06:31 <edwardk> your dataChar and charRef, are they tagged with <?>
23:06:33 <edwardk> ?
23:07:19 <edwardk> e.g. dataChar = noneOf "<&>" <?> "character"
23:23:12 * hackagebot alex-meta 0.3.0.5 - Quasi-quoter for Alex lexers  http://hackage.haskell.org/package/alex-meta-0.3.0.5 (JonasDuregard)
23:23:36 <startling> does anyone know if you can implement interfaces like #Functor in Rust?
23:23:42 <startling> It doesn't seem like you can. :/
23:25:10 <Ralith> that whole flock of trendy C-likes didn't do a very good job of studying the state of the art before finalizing their design, it seems like
23:25:49 <startling> Ralith: there are other ones?
23:26:07 <astropirate> there is a new compile to JS language every two days :S
23:26:15 <Ralith> startling: Go, at least.
23:26:17 <astropirate> << converting from JS to haskell
23:26:21 <startling> Ralith: oh, right
23:26:37 <Ralith> they mean well.
23:26:48 <startling> haha
23:26:58 <Ralith> but it feels like the developers are still C++ developers at heart.
23:27:15 <startling> yeah, I know what you mean
23:27:18 <Ralith> (as in, they haven't really lived-and-breathed other paradigms)
23:27:38 <Cale> astropirate: I think you mean the other way
23:27:54 <astropirate> Cale, what do you mean o_O
23:27:57 <astropirate> lol
23:28:01 <astropirate> i'm coming from JS to haskell
23:28:09 <Cale> oh, I see
23:28:18 <astropirate> I gave up
23:28:20 <Cale> I thought you were talking about the compilers
23:28:35 <astropirate> ahh :)
23:28:42 <Cale> There are a whole bunch of projects going on to compile from Haskell to Javascript
23:28:53 <astropirate> I dont think thats a good idea
23:28:57 <shachaf> And none in the other direction.
23:29:00 <shachaf> Coïncidence?
23:29:11 <Cale> astropirate: Why? It would be great :)
23:29:58 <Cale> astropirate: You could use the same datatypes on the frontend and backend of your web application, and never have to worry about the communication of data structures going out of sync.
23:30:26 <Cale> (because they were both compiled from the same data declarations :)
23:30:45 <astropirate> Cale, well, when you code in a language you think in terms of that environment. you dont think about the pitfalls and such of the language that your code is going to be compiled into
23:30:58 <astropirate> also
23:30:59 <Cale> Well, yes
23:31:07 <astropirate> more importantly DEBUGGING HELL
23:31:08 <astropirate> :)
23:31:12 <Cale> I don't think about the pitfalls of x86 assembly
23:31:19 <astropirate> heh
23:31:23 <Cale> but somehow life goes on :)
23:31:38 <astropirate> well alright I suppose that could work
23:31:44 <astropirate> but you would need MIGHTY intelligent tooling
23:31:47 <astropirate> and mature
23:32:03 <astropirate> that does not yet exist
23:32:25 <Cale> but it's getting there, and lots of people are trying to do it, because it would be worthwhile
23:32:40 <Cale> Fay already compiles a fairly significant portion of Haskell
23:33:11 <Cale> http://fay-lang.org/#examples
23:33:48 <astropirate> hmm
23:33:51 <Cale> It's not mature
23:33:52 <astropirate> this looks interesting
23:33:56 <Cale> but it's something :)
23:35:22 <astropirate> well I hope it works out
23:36:05 <Cale> http://www.youtube.com/watch?v=dhFZ8vx9byc
23:36:19 <strebe> Cale: for what it's worth, it turns I can't just skip to natural transformations; chapter 7 seems to make fairly little sense without understanding coproducts, which in turn basically implies at least a fair chunk of chapters 2 and 3 :-)
23:37:17 <Cale> strebe: ah, okay
23:37:39 <Cale> strebe: Do you understand the definition on its own?
23:37:51 <strebe> Cale: of natural transformations?
23:38:11 <Cale> yeah
23:43:27 <cornihilio> is there an easy way to convert a word32 to an Int64?
23:43:35 <Claudius1aximus> fromIntegral
23:44:25 <cornihilio> that converts it to an Integer though, correct?
23:44:32 <Nereid> no
23:44:36 <Nereid> look at its type
23:44:56 <ClaudiusMaximus> the specification is to go via Integer, but compiler may have optimisation RULES
23:45:02 <strebe> Hmm. Not entirely. The idea of having functors as the objects of a category is clear enough (though I'm still feeling a little shaky on functors themselves); but I'm not really entirely understanding the arrows of that category, which are the natural transformations
23:45:32 <cornihilio> Nereid: what does that type (Num b, Integral a) => a -> b mean?
23:45:55 <Nereid> cornihilio: it means that if a is an Integral and b is a Num, then you get a function a -> b
23:45:59 <strebe> cornihilio: a needs to be some kind of Integral type; b can be any numeric type
23:46:10 <Nereid> cornihilio: read about typeclasses if you haven't already
23:46:30 <strebe> so you can use that function to change, say, an Int to a Double, but not vice versa (or an Int to an Integer, and vice versa)
23:46:53 <cornihilio> but what does this mean in particular: (Num b, Integral a) => a
23:47:14 <Nereid> you should parse it as (Num b, Integral a) => (a -> b)
23:47:17 <cornihilio> that's a function, right?
23:47:20 <Nereid> no
23:47:27 <Nereid> => is not ->
23:47:36 <strebe> http://book.realworldhaskell.org/read/using-typeclasses.html -- see "Numeric types", cornihilio
23:47:48 <Nereid> cornihilio: again, read about typeclasses
23:47:55 <Nereid> Num and Integral are typeclasses
23:47:57 <cornihilio> thank you, I will
23:48:00 <cornihilio> thanks!
23:48:07 <strebe> see => as "implies" if you want, or "Given that b is a Num and a is an Integral, this is a function from a to b"
23:48:24 <Nereid> there's a hidden "forall a b." in the front.
23:48:25 <dmwit> > let x :: (Num b, Integral a) => a; x = undefined in "hi" -- I think the specific type you asked about is an error
23:48:27 <lambdabot>   Ambiguous constraint `GHC.Num.Num b'
23:48:27 <lambdabot>      At least one of the forall'd type...
23:48:41 <Nereid> indeed
23:49:04 <strebe> it's a prerequisite or restriction on the function's types; a->b is any type, while (Num b) => a -> b means that b needs to be somewhere in the Num typeclass
23:49:16 <Cale> strebe: okay, so suppose you have two functors F, G: C -> D, each of which is in some way a "picture" of C in D (though perhaps it's folded up and squished a good bit), yeah?
23:49:20 <ClaudiusMaximus> :t 7
23:49:22 <lambdabot> forall t. (Num t) => t
23:49:41 <pharaun> love it when you spend time and end up with complicated code then you get some clever insights and you reduce dozens of line into a single elegant line
23:49:44 <pharaun> its great
23:49:50 <ClaudiusMaximus> you can ignore the "forall t." for the moment
23:49:51 <strebe> Cale: ok (and thank you for mentioning that, I was having trouble figuring out how much folding and squishing was allowed)
23:50:15 <Cale> strebe: For each object X in C, we have an object FX in D, and for each arrow a: X -> Y in C, we have an arrow Fa: FX -> FY in D.
23:50:51 <Cale> strebe: and we have a similar sort of thing going on for G
23:50:55 <strebe> Cale: does the converse necessarily hold?
23:51:00 <Cale> no
23:51:05 <Nereid> converse of what?
23:51:27 <Cale> So you might not cover all of D, and you might not even cover all the arrows FX -> FY
23:51:33 <strebe> Nereid: basically, whether some F' D -> C necessarily makes sense
23:51:55 <Cale> strebe: there might be another functor in the other direction, and there might even be an inverse to F
23:51:59 <Cale> But not always
23:52:13 <strebe> Cale: yeah, there clearly sometimes is, but being sure it's not always is helpful :-)
23:52:56 <Nereid> example: if 1 is the category with just one object and its identity arrow, then the functor category [1,C] is isomorphic to C.
23:53:13 <Cale> To make it really concrete, there's a trivial example provided by two of the simplest possible categories. We can take the empty category, and there's a functor from that to the category with one object and only the one required identity arrow on that object.
23:53:13 * hackagebot gluturtle 0.0.31 - turtle like LOGO with glut  http://hackage.haskell.org/package/gluturtle-0.0.31 (YoshikuniJujo)
23:53:55 <Cale> (it doesn't have to make any assignments of objects to objects or arrows to arrows, because the empty category doesn't have any)
23:54:10 <Cale> But then if you try to make a functor going in the other direction, you can't do it.
23:54:32 <Cale> Because you have nothing to send the one object of the single object category to.
23:54:46 <Nereid> silly example.
23:54:51 <strebe> useful example
23:54:56 <Nereid> sure.
23:55:04 <Nereid> that doesn't make it not silly.
23:55:06 <Nereid> :p
23:55:20 <strebe> the silly/trivial examples tend to be critical during early bootstrapping of understanding, at least for me
23:55:34 <Cale> okay, so we have our two squished pictures of C sitting inside D, and the question becomes, can we form a connection from one to the other?
23:55:36 <hirsch_> > "/foo/bar" </> "baz"
23:55:38 <lambdabot>   Not in scope: `</>'
23:55:39 <Cale> Well, what does that mean?
23:56:09 <Cale> So a natural transformation eta: F -> G assigns to each object X in C, some arrow eta_X: FX -> GX in D
23:56:55 <Nereid> example: in the 2-object category 2 with objects s, t and a single nonidentity arrow s -> t,
23:57:06 <Nereid> a functor 2 -> C is the same as an arrow in C,
23:57:14 <Nereid> and a natural transformation between two such functors is a commutative square.
23:57:22 <Nereid> in C.
23:57:32 <strebe> Nereid: ehm, sorry, what's a commutative square?
23:57:34 <Cale> and of course, this would be no good if it did nothing to preserve the structure of the *arrows* of C in any way
23:57:40 <Nereid> eh.
23:58:02 <Nereid> strebe: it's a square that commutes
23:58:02 <Nereid> uh
23:58:05 <Palmik> Hmm, is there a function for folding over number in standard lib? Surely there must be, but it's evading me (f :: (a -> a) -> a -> n -> a).
23:58:11 <Cale> So for any arrow a: X -> Y in C, we have its two images: Fa: FX -> FY on the one hand and Ga: GX -> GY on the other
23:58:14 * hackagebot const-math-ghc-plugin 0.3.0.0 - Compiler plugin for constant math elimination  http://hackage.haskell.org/package/const-math-ghc-plugin-0.3.0.0 (ConradParker)
23:58:33 <Nereid> strebe: http://upload.wikimedia.org/wikipedia/commons/9/91/Commutative_square.svg
23:58:36 <hirsch_> "/foo/bar" </> "baz" = "/foo/bar/baz"
23:58:36 <hirsch_>  but "/foo/bar" </> "/"
23:58:36 <hirsch_>  = "/" ??
23:58:38 <Nereid> where hf = kg
23:58:43 <Cale> and we want those to somehow work out nicely with the arrows that our natural transformation is giving us
23:58:45 <hirsch_> strange behaviour
23:58:53 <Cale> strebe: following?
23:59:01 <Nereid> strebe: you may postpone reading my examples until later.
23:59:01 <strebe> Nereid: ahh
23:59:11 <strebe> Cale: working on it, backtracking and thinking
23:59:53 <Nereid> hirsch_: it kinda makes sense.
