00:34:32 <coldpizza72i> Can someone suggest where to begin with this assignment http://www.cs.rit.edu/usr/local/pub/jeh/courses/FP/Labs/Interpreter-kladoi/
00:41:27 <ClaudiusMaximus> coldpizza72i: something like   type Context = ...   ; interpretExpr :: Context -> Expr -> Expr ; interpretStmt :: Context -> Stmt -> Context
00:44:30 <coldpizza72i> ClaudiusMaximus: what exactly do you mean
00:45:08 <yitz> ClaudiusMaximus: i don't think any context is required in this assignment
00:45:44 <ClaudiusMaximus> yitz: hm, not even the current values of variables?
00:46:35 <yitz> no, nothing was said about that, so i would assume always start with an empty context to keep things simple
00:47:13 * ClaudiusMaximus wonders whether I'm looking at the right page
00:47:19 <yitz> coldpizza72i will get extra credit from ClaudiusMaximus if contexts are supported. but i'm not so sure coldpizza72i is going to focus on that. :)
00:48:14 <yitz> coldpizza72i: i think the function you want for "most of the program" will have type Prog -> [(String, Int)]. is that correct?
00:48:38 <coldpizza72i> that sounds correct
00:49:09 <yitz> coldpizza72i: ok then. you already have a significant start!
00:50:00 <yitz> coldpizza72i: name your function, and start writing it. you'll need one equation for each constructor of Prog. in each case, just start writing, and the types will basically write your program for you.
00:53:50 <yitz> coldpizza72i: ah, now i see what ClaudiusMaximus means. when you handle Seq, you'll have to call your function recursively, except with a pre-existing set of variable bindings. so yeah, you'll need to support that.
00:54:40 <coldpizza72i> yitz: will i need a do block for the myFunction Seq Stmt Prog ?
00:55:38 <ClaudiusMaximus> you can keep the Context in a State monad, or you can do the plumbing manually, depending on which you are more comfortable with (and what the lectures covered so far i guess)
00:55:59 <yitz> coldpizza72i: ClaudiusMaximus means that in terms of the "functional style" mentioned at the beginning, "Old State" is a context of variable bindings, "Modification" is a Prog that, when run, modifies the set of variable bindings, and "New State" is the resulting new set of variable bindings.
00:56:35 <ClaudiusMaximus> (coincidentally, plumbers are tearing my bathroom apart rather noisily, which is impairing my cognition, plus it's too early)
00:56:38 <yitz> coldpizza72i: no
00:57:31 <yitz> ClaudiusMaximus: Old State and New State are a bathroom, and Modification is the plumbers. We probably also fit your brain into that paradigm somehow.
00:57:49 <ClaudiusMaximus> yitz: :)
00:59:30 <yitz> coldpizza72i: so you'll write a function with the type that ClaudiusMaximus said. Then the final function with the type I said will just be that called with an empty set of variable bindings.
01:00:09 <yitz> coldpizza72i: ClaudiusMaximus intended that you write "type Context = [(String, Int)]". Did you learn yet about type synonyms like that?
01:00:32 <coldpizza72i> yits yes
01:01:00 <yitz> coldpizza72i: OK great
01:01:19 <ClaudiusMaximus> seems i also meant interpretExpr :: Context -> Expr -> Int, too
01:08:31 <ClaudiusMaximus> is there any simple tutorial on using ghc-7.6's type-level Nat stuff?  is it going to be faster than the Haskell98 + Rank2Types way, or is it just to make more programs ill-kinded and rule out stupid mistakes?
01:12:57 <ClaudiusMaximus> also, how do i benchmark    naturalNumberAsInt :: NaturalNumber n => n -> Int    for large type-level-natural-number n   without either 1) the magic compiler optimising it all away at compile time; or 2) using Rank2Types which also benchmarks the dictionary construction...
01:23:40 * Polarina wonders what dictionary construction is.
01:29:49 <ClaudiusMaximus> Polarina: inductively building up a type class dictionary for NaturalNumber (SuccessorTo n) from the type class dictionary of NaturalNumber n
01:32:26 <Polarina> ClaudiusMaximus, ah. I can think of one way from the top of my head. Put naturalNumberAsInt into module A and compile with optimizations, make a new function in B that only calls your function in A, like { naturalNumberAsInt' = naturalNumberAsInt }. Compile B without any optimizations (-O0). Then have module C use module B. C would test the performance of your function.
01:32:36 * Polarina thinks that would do the trick.
01:33:00 <ClaudiusMaximus> sounds tricky...
01:33:19 <ClaudiusMaximus> will try it though
01:33:56 <Polarina> It should force C to use it, as it has no idea about the definition of the function in B (not in the interface file).
01:34:33 <ClaudiusMaximus> hopefully
01:34:35 <ClaudiusMaximus> :)
01:35:00 <Polarina> If you compile C with optimizations, make sure the compiler can't figure out that the call's redundant no matter the definition.
01:35:12 <Polarina> Like, in B, put it in the IO monad or something.
01:35:20 <ClaudiusMaximus> mm, interesting
01:35:24 <Polarina> Should solve it.
01:36:18 <Polarina> Don't forget the evil, known as lazy evaluation. Use seq if needed. :)
01:36:40 <ClaudiusMaximus> yep, and season with {-# NOINLINE #-} to taste
01:36:48 <Polarina> ClaudiusMaximus, I haven't actually tried this method before, but it makes sense.
01:37:02 <Polarina> ClaudiusMaximus, can't do any harm to have that pragma there. :)
01:37:28 <ClaudiusMaximus> i think the IO method might be sanest, actually..
01:37:56 <ClaudiusMaximus> unless ghc is sufficiently devious
01:39:30 <Polarina> module B where naturalNumberAsInt' :: NaturalNumber n => n -> IO Int; naturalNumberAsInt' x = let a = naturalNumberAsInt x in a `seq` return a
01:39:37 <Polarina> Should do the trick. :)
01:41:13 <Polarina> ClaudiusMaximus, let me know if this helps. *smile*
01:44:05 <Polarina> You can look at the Core output as well, if you want, to see if it's doing either magic or logic.
01:44:18 <ClaudiusMaximus> true..
02:12:13 <ClaudiusMaximus> Polarina: the IO with NOINLINE trick worked, giving me a lovely graph http://mathr.co.uk/haskell/type-level-natural-number-1.1.1.png
02:19:15 <Peaker> Annoying to write readMaybe every time I want it in a one-off script :(  want it in base
02:20:01 <ClaudiusMaximus> Peaker: it is, in 7.6
02:20:23 <Polarina> ClaudiusMaximus, brilliant! :D
02:22:01 <ClaudiusMaximus> Peaker: http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/release-7-6-1.html#id9281219
02:22:16 <ClaudiusMaximus> Polarina: :)
02:23:40 <Peaker> "reads" has been a really annoying thing to use :)
02:30:14 <michael_> Hm, yesterday I asked a question in here and people were actually quite helpful. However, I am afraid I am a bit stuck again. My task is to write a function apply :: State -> [Rule] -> State that takes a state (i.e. a sequence of letters) and applies to each letter of this state the first applicable rule from the list of rules. Letters that have no applicable rules should be copied to the new state.
02:30:23 <michael_> You came up with quite a few solutions, but my problem now is how to make it work with my Haskell program.
02:31:10 <michael_> As it was pointed out yesterday, the standard function works on pairs, not Rules.
02:31:21 <michael_> That could probably be a problem.
02:31:30 <merijn> I guess nested ReaderT's are slightly cumbersome to work with?
02:32:16 <merijn> What's the best way to wrap a ReaderT around an arbitrary monad stack? Reimplement Reader with a different name so it doesn't collide with any possible internal Readers?
02:32:18 <jude0> how do i convert Integer to Int?
02:32:43 <michael_> http://pastebin.com/zvYiYZ88
02:32:44 <merijn> jude0: fromIntegral
02:32:46 <michael_> My program
02:32:49 <maukd> The paste zvYiYZ88 has been copied to http://hpaste.org/76362
02:32:52 <ivanm> @hoogle Integer -> Int
02:32:53 <lambdabot> Data.Time.Calendar gregorianMonthLength :: Integer -> Int -> Int
02:32:53 <lambdabot> Data.Time.Calendar.Julian julianMonthLength :: Integer -> Int -> Int
02:32:53 <lambdabot> Data.Generics.Schemes gsize :: Data a => a -> Int
02:33:00 <ivanm> huh, that's _so_ helpful
02:33:23 <dibblego> merijn: nesting transformers with themselves is generally not a good idea, after all, you have join in that case
02:33:34 <c_wraith> :t fromInteger
02:33:36 <lambdabot> forall a. (Num a) => Integer -> a
02:33:51 <jude0> Couldn't match expected type `Int' with actual type `Integer' when I tried from integral
02:33:52 <merijn> I'm guessing fromInteger is just a restricted fromIntegral?
02:33:59 <merijn> :t fromIntegral
02:34:01 <lambdabot> forall a b. (Integral a, Num b) => a -> b
02:34:09 <c_wraith> it's actually half of the implementaiton of fromIntegral
02:34:13 <c_wraith> @src fromIntegral
02:34:13 <lambdabot> fromIntegral = fromInteger . toInteger
02:34:33 <merijn> > (fromIntegral (5 :: Integer)) :: Int
02:34:35 <lambdabot>   5
02:34:41 <c_wraith> fromInteger is in the Num class, toInteger is in the Integral class
02:35:46 <merijn> dibblego: The point is that I want to wrap around an arbitrary monad stack without knowing what's inside, so either I (may) end up nesting Readers or I reimplement reader with a different name to avoid collision
02:36:12 <dibblego> merijn: ReaderT does exactly that
02:36:17 <merijn> dibblego: Join only works for monads that are the same, nested ReaderT's are not the same and can't be joined
02:36:27 <merijn> dibblego: I think you are misunderstanding my question
02:36:32 <dibblego> possibly
02:36:43 <dibblego> I doubt there is a good reason to rename ReaderT though
02:36:52 <c_wraith> I don't see any conflict with an inner instance of MonadReader, so long as your functions are polymorphic on the inner type
02:36:56 <merijn> dibblego: If I implement my wrapper as ReaderT then it won't work if the stack I end up wrapping *already has* ReaderT
02:37:07 <dibblego> what won't work?
02:37:41 <merijn> c_wraith: How do ask and co decide which Reader instance to read from in case of nesting?
02:37:59 <merijn> Based on the type carried inside?
02:38:11 <c_wraith> merijn: no.  Based on what it knows about the type.
02:38:29 <c_wraith> merijn: the type of the stack that is, not the type inferred for ask
02:38:38 <jude0> I still can not figure out the fromintegral issues any one want to take a look at a sample http://ideone.com/1wZGF
02:39:33 <ivanm> jude0: are you trying to re-define Lookup?
02:39:41 <ivanm> but you have no need to use fromIntegral there that I can see :s
02:39:55 <ivanm> s/Lookup/lookup/
02:40:10 <jude0> not sure what lookup is. thanks i will check it out
02:40:14 <ivanm> @hoogle lookup
02:40:15 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
02:40:15 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
02:40:15 <lambdabot> Data.HashTable lookup :: HashTable key val -> key -> IO (Maybe val)
02:40:21 <ivanm> @src lookup
02:40:21 <lambdabot> lookup _key []          =  Nothing
02:40:21 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
02:40:21 <lambdabot>                         | otherwise = lookup key xys
02:40:38 <ivanm> note that null is better than /= []
02:41:14 <merijn> ivanm: case of would be even better
02:41:17 <ivanm> and also it's preferable to pattern match; e.g. case (filter ((==var).fst) prog) of (res:_) -> Just (snd res); _ -> Nothing
02:41:23 <ivanm> merijn: hold your horses! ;)
02:41:45 <ivanm> jude0: oh, I knokw your problem
02:41:47 <ivanm> type defaulting
02:41:47 <startling> how do you differentiate between a nullary function and a global value in haskell bindings?
02:41:51 <ivanm> x isn't of type Prog
02:42:14 <startling> do you even need to?
02:42:23 <merijn> startling: What is a nullary function?
02:42:25 <ivanm> startling: you mean binding something in another language into Haskell? or using Haskell from another language?
02:42:33 <c_wraith> startling: first you define a nullary function in haskell
02:42:34 <merijn> startling: Haskell doesn't have nullary functions...
02:42:38 <startling> ivanm: binding to C
02:42:46 <startling> merijn: int somefunction(void)
02:42:51 <startling> well, binding C to haskell
02:42:54 <ivanm> startling: IO Int ?
02:42:58 <c_wraith> sounds like an IO action to me
02:43:02 <merijn> startling: Those should end up being IO actions
02:43:04 <ivanm> unless it's a const
02:43:08 <jude0> never heard of a nullary function. but I figure that I can just use the lookup function
02:43:11 <startling> okay, I get that.
02:43:23 <ivanm> @type null
02:43:24 <lambdabot> forall a. [a] -> Bool
02:43:24 <ivanm> jude0: ^^
02:43:35 <startling> but there's a global variable that's an integer. is that also an IO CInt?
02:43:37 <merijn> c_wraith: Guess I need to meditate on the details of MonadReader for enlightenment
02:43:38 <ivanm> jude0: in your example: let x = ... :: Prog
02:43:41 <ivanm> ^^ that will fix it
02:43:46 <merijn> startling: If it can change, yes
02:43:49 <ivanm> in ghci, integral literals default to Integer
02:43:52 <ivanm> so that was your problem
02:44:01 <merijn> startling: If it's const then it could be just CInt
02:44:09 <startling> merijn: it can change
02:44:11 <jude0> oh thanks ivan that makes sense
02:44:14 <ivanm> your function wouldn't accept the value, nothing to do with your code being wrong :p
02:44:32 <startling> does ghc deal with the function/global difference behind the schenes?
02:44:34 <startling> *scenes
02:44:35 <merijn> startling: Then what is the conceptual difference between a function and the variable that requires a difference other than being IO CInt in haskell?
02:44:58 <startling> merijn, you call a function. you look at a variable.
02:45:00 <merijn> startling: afaik it should
02:45:11 <merijn> That's something for the FFI to work out :)
02:45:22 <startling> k. didn't know if i had to tell it something
02:45:39 <merijn> startling: Well probably variables/functions have different FFI imports
02:45:54 <startling> merijn: oh! yes, probably
02:45:55 <jude0> is there a built in function that does searches a list and adds a value if not there or updates an existing one?
02:46:01 <startling> thanks for answering my question finally!
02:46:27 <ivanm> jude0: don't think so
02:46:35 <ivanm> but it sounds like you want to look at Data.Map
02:46:46 <ivanm> @hoogle Data.Map.update
02:46:46 <lambdabot> Data.Map update :: Ord k => (a -> Maybe a) -> k -> Map k a -> Map k a
02:46:47 <lambdabot> Data.Map updateAt :: (k -> a -> Maybe a) -> Int -> Map k a -> Map k a
02:46:47 <lambdabot> Data.Map updateLookupWithKey :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> (Maybe a, Map k a)
02:46:47 <jude0> yea i was thinking lookup then map
02:46:58 <ivanm> jude0: no, not the map function
02:47:08 <ivanm> the Data.Map module
02:47:45 <ivanm> unless your lookup lists are very short, Data.Map will be more performant
02:47:51 <jude0> updateLookupWithKey already exists in Data.Map and I should use it?
02:48:39 <ivanm> if that's what you want
02:48:44 <ivanm> but you wouldn't be using a list of values
02:49:25 <jude0> i have a list of tuples with string key does that work?
02:49:34 <obiwahn> > let {z = 8000; x = 100 : map (\y -> (y/(z-1))+y) (x)} in last (take z x)
02:49:36 <lambdabot>   271.81119340749444
02:49:46 <obiwahn> waht has the bot imported so that works_
02:50:20 <ivanm> obiwahn: the Prelude?
02:50:26 <ivanm> are you saying that that doesn't work in ghci?
02:51:04 <ivanm> oh, that's weird...
02:51:06 <ivanm> I see what you mean
02:51:20 <ivanm> I'm guessing it's using some non-monomorphic Num a => a value for numbers
02:51:51 <quicksilver> yes, LB has monomorphism restriction off.
02:52:02 <quicksilver> You're using z as both an Integer and a Double there
02:52:16 <quicksilver> which, in standard haskell, requires that you put an explicit signature on z
02:52:37 <quicksilver> let {z :: Num a => a; z = 8000; x = 100 : map (\y -> (y/(z-1))+y) (x)} in last (take z x)
02:52:44 <quicksilver> ^^ there is a version which will work in your ghci
02:52:55 <obiwahn> :) thank you
03:14:49 * hackagebot simple-config 1.1.1.0 - Simple config file parser generator  http://hackage.haskell.org/package/simple-config-1.1.1.0 (YusukeNomura)
03:19:57 <ivanm> if I have a C struct that I'm interacting with using the FFI, I just use poke to change values don't I?
03:21:30 <ClaudiusMaximus> ivanm: yes, assuming you have a Storable instance
03:21:45 <ClaudiusMaximus> for the relevant fields
03:21:54 <b_jonas> ivanm: or you can import foreign functions for modifying the fields
03:23:29 <merijn> If I have "module Foo (Bar.X, Bar.Y, Bar.Z) where import qualified Bar" then modules import Foo will just see X, Y and Z, right?
03:25:01 <ClaudiusMaximus> merijn: should do, test with ghci :bro Foo i guess
03:26:26 <ivanm> ClaudiusMaximus, b_jonas: *nod*
03:26:51 <ivanm> when writing a peek instance, do I assume that the memory is already allocated? (because all the examples I've found seem to do so)
03:27:00 <ivanm> s/peek/poke/
03:27:28 <ClaudiusMaximus> yes, you need to allocate separately, poke just pokes
03:27:53 <ClaudiusMaximus> @hoogle poke
03:27:53 <lambdabot> Foreign.Storable poke :: Storable a => Ptr a -> a -> IO ()
03:27:54 <lambdabot> Foreign.Marshal.Array pokeArray :: Storable a => Ptr a -> [a] -> IO ()
03:27:54 <lambdabot> Foreign.Marshal.Array pokeArray0 :: Storable a => a -> Ptr a -> [a] -> IO ()
03:27:57 <ivanm> OK, so does that mean that I _shouldn't_ use a foreign method that does malloc inside my poke definition?
03:28:14 <ClaudiusMaximus> not unless it magically allocates at the Ptr a you are passed in
03:28:50 <ClaudiusMaximus> also, Storable is for fixed-size things
03:29:02 <ivanm> OK, I'll get rid of the malloc call in the C code I'm using
03:29:23 <ivanm> no, wait, that won't work then...
03:29:27 <ClaudiusMaximus> gotta go out now, g'luck
03:31:08 <ivanm> OK, my plan for how to deal with empty array elements thus needs to be re-thought...
03:55:02 <merijn> Man, the biggest contribution of DataKinds might just be the elimination of silly typeclass constraints for enforcing phantom types...
04:11:19 <Saizan> you mean stuff like class List a ?
04:11:32 <Saizan> i never used those even before
04:14:40 <merijn> Saizan: Yeah, some libraries I'm using are doing stuff like that
04:23:09 <meh> O.o anyone here?
04:23:32 <ivanm> nope
04:23:49 <byorgey> hi Guest10346
04:23:59 <quicksilver> nobody here but us chickens
04:24:04 <Guest10346> failed to identify in time :(
04:24:35 <byorgey> we can continue calling you meh if you like =)
04:24:41 <Guest10346> idc
04:24:43 <Guest10346> haah
04:26:14 <Guest10346> so i went thru a few of the lessons
04:26:27 <Guest10346> haskell is pretty cool
04:26:50 <merijn> Since the constructor for ReaderT takes a "r -> m a" is there some way to turn "r -> b -> m a" into "b -> r -> m a" (well, flip, obviously, but I was thinking of functions where b has any number of arguments...)
04:27:55 <hpc> you could exploit MonadReader horribleness to make it not care how deep the stack goes
04:28:04 <merijn> i.e. "r -> b -> c -> m a" to "b -> c -> r -> m a" you can more easily use functions with reader...
04:28:11 <ivanm> is it correct to use the alloca* functions in the FFI to define poke for values, as long as I don't directly use that Ptr value afterwards?
04:28:24 <killy9999> unsafePerformIO $ putStrLn (show x)
04:28:32 <killy9999> what's wrong with this line of code?
04:28:40 <ivanm> killy9999: putStrLn . show == print
04:28:55 <hpc> are you sure you want unsafePerformIO?
04:28:57 <merijn> killy9999: What do you expect it to do?
04:28:58 <ivanm> but.... you shouldn't use unsafePerformIO unless you're wrapping a pure function
04:29:00 <merijn> killy9999: And why
04:29:35 <killy9999> merijn: I need to slow down my program, so I figured out printing a lot of data to stdout would be a good idea
04:29:40 <killy9999> this is only for debugging
04:29:46 <merijn> killy9999: Why not threadDelay?
04:29:50 <hpc> @hoogle threadDelay
04:29:51 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
04:29:51 <lambdabot> GHC.Conc.IO threadDelay :: Int -> IO ()
04:29:51 <lambdabot> GHC.Conc threadDelay :: Int -> IO ()
04:29:57 <merijn> killy9999: You have no guarantee that that will actually print...
04:30:09 <killy9999> merijn: I will notice that :)
04:30:10 <merijn> hpc: Can you give me slightly more of a hint how I could abuse that?
04:30:34 <hpc> uh
04:30:50 <hpc> wait crap, you wanted to do an n-ary flip on an actual function
04:30:52 <killy9999> anwyay, aside from the fact that this is not very smart line of code, I don't see why this gives me an error message
04:30:56 <killy9999> Couldn't match expected type `IO a0' with actual type `()'
04:31:17 <ivanm> why do you want to slow down your program?
04:31:23 <ivanm> most people want to speed theirs _up_!
04:31:36 <killy9999> ivanm: that's what I am ultimately trying to do
04:31:48 <ivanm> how does slowing your program down help speed it up?
04:31:56 <ivanm> isn't that what profiling + benchmarking is for?
04:31:56 <killy9999> I need to make sure that I am writing criterion benchmarks correctly
04:32:09 <hpc> use threadDelay
04:32:10 <dibblego> if you slow it down enough, the poles flip
04:32:16 * ivanm still doesn't follow
04:32:24 <killy9999> I do not want to benchmark time needed to create input data for my algorithm
04:32:43 <ivanm> so you define that outside, force it with rnf
04:32:53 <ivanm> and _then_ pass it through to criterion
04:32:56 <killy9999> I wrote a code that is *supposed* to force the data before the benchmark
04:33:07 <killy9999> but I don't see any difference in the benchmark
04:33:11 <tumdum> I want to use test-framework with cabal test, what should I do to see output from test-framework on stdout?
04:33:22 <killy9999> which is a signel for me to double-check that I am doing everything the right way
04:33:40 <ivanm> tumdum: I believe there's a flag you can use
04:33:43 <ivanm> cabal test --help
04:33:46 <hpc> killy9999: benchmark the input data separately
04:33:55 <hpc> see if it actually takes a long time to generate
04:34:02 <killy9999> hpc: OK
04:34:19 <killy9999> tumdum: by default this is logged to a file - this is not what you want?
04:34:33 <tumdum> no, I want to see only test-framework output
04:35:09 <killy9999> perhaps: cabal test; cat dist/test/the-long-name-of-log-file.log  ??
04:35:12 <ivanm> tumdum: yes, but by default cabal test seems to prevent _any_ output
04:35:21 <ivanm> but IIRC there's a flag to change that
04:35:52 <killy9999> tumdum: remember that cabal test WILL display results on stdout if any of the tests fail
04:36:05 <killy9999> if it just logs to a file it means that everything works
04:36:22 <killy9999> this is still not what you need?
04:37:25 <tumdum> eventually it is but not right now
04:37:58 <ivanm> tumdum: cabal test --show-details=always ?
04:39:19 <fork`> hi
04:39:37 <tumdum> yes, show-details=always is working :)
04:40:34 <tumdum> thanks ivanm and killy9999 :)
04:40:35 <WashIrving> teki
04:47:47 <jude0> I am having trouble figuring out how to set the type of an empty data.map. does anyone know how to make the type match properly? http://ideone.com/RIM2H
04:48:43 <hpc> (empty :: Data.Map Key Value)
04:48:45 <hpc> er
04:48:50 <hpc> (empty :: Map Key Value)
04:48:55 <ClaudiusMaximus> jude0: you probably want to use 'type' instead of 'data'
04:49:23 <jude0> yea i was going back and forth between type and data. was not sure good reasoning for one or the other
04:49:42 <hpc> right now your data is the same as (String, Int)
04:49:43 <ClaudiusMaximus> your data declares a constructor called Map
04:50:34 <hiteki> netb
04:51:14 <jude0> thanks... i now get
04:51:14 <jude0> "Couldn't match expected type `Vars'
04:51:14 <jude0>                 with actual type `Map String Int'
04:51:14 <jude0>     In the expression: (empty :: Map String Int)"
04:51:57 <jude0> does it not work because its a data and not a type?
04:52:42 <ClaudiusMaximus> so you need  Vars = Map String Int  which you can do with 'type Vars = Map String Int'  (or 'data Vars = Vars (Map String Int) ; empty = Vars (Map.empty)'
04:53:49 <ClaudiusMaximus> jude0: http://www.haskell.org/haskellwiki/Type might be worth a read
04:54:23 <jude0> k thanks for the link and the type signature thing
05:01:42 <killy9999> um... how do I raise x to y in Haskell?
05:01:52 <killy9999> to power of y
05:01:56 <killy9999> x^y that is
05:02:04 <fmap> > 3^4
05:02:06 <lambdabot>   81
05:02:21 <killy9999> 10^(-12)
05:02:24 <killy9999> > 10^(-12)
05:02:25 <lambdabot>   *Exception: Negative exponent
05:02:33 <troydm> > 3^(pi)
05:02:34 <killy9999> so no, ^ does not do
05:02:34 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:02:34 <lambdabot>    `GHC.Float.Floating a'
05:02:34 <lambdabot>  ...
05:02:47 <fmap> > 10^^(-12)
05:02:48 <lambdabot>   1.0e-12
05:02:53 <killy9999> perfect
05:03:16 <ClaudiusMaximus> > 3 ** pi -- probably this one
05:03:17 <lambdabot>   31.54428070019754
05:03:38 <ClaudiusMaximus> :t ((^), (^^), (**))
05:03:39 <lambdabot> forall a b a1 b1 a2. (Num a, Integral b, Fractional a1, Integral b1, Floating a2) => (a -> b -> a, a1 -> b1 -> a1, a2 -> a2 -> a2)
05:03:59 <killy9999> thanks
05:16:01 <sepp2k> http://stackoverflow.com/questions/12912739/rankntypes-what-is-causing-this-error Is there a way to use the function from my answer (which uses ConstraintKinds and Rank2Types) without having to specify a type signature each time you call it?
05:16:15 <sepp2k> Or for that matter, a simpler way to define and/or use it?
05:21:04 <merijn> Bah, and once again my beautiful code is impossible to write due to lack of type level composition :(
05:25:06 <jude0> my directions say to use map's as list... i do not see an aslist, do you think it means toList or fromList?
05:27:30 <jude0> nevermind i found that Java has an asList so that is probably what was meant
05:27:36 <edwardk> sepp2k: no, you can't avoid it. because the polymorphic constraints won't be solved by anything.
05:28:57 <sepp2k> edwardk: Okay, thanks.
05:29:11 <bartavelle> are there nicer wrappers over the sqlite package ?
05:29:37 <bartavelle> ah there are
05:31:04 <Cale> jude0: Surely they mean toList :)
05:39:52 * hackagebot complex-generic 0.1.1 - complex numbers with non-mandatory RealFloat  http://hackage.haskell.org/package/complex-generic-0.1.1 (ClaudeHeilandAllen)
05:39:54 * hackagebot variable-precision 0.3.1 - variable-precision floating point  http://hackage.haskell.org/package/variable-precision-0.3.1 (ClaudeHeilandAllen)
05:48:11 <_rvl> hi all... this is killing me. what do i have to import to get regexps like e.g. "aaabb" =~ "(a+)(b*)" :: [String] ?
05:48:26 <Botje> Text.Regex, presumably.
05:48:59 <dd> morning
05:49:30 <Botje> huh, no
05:49:37 <Botje> it's in the different Text.Regex subpackages
05:50:06 <_rvl> it doesn't seem to be in Text.Regex.Posix although the real world haskell book suggests it does
05:50:36 <_rvl> @hoogle (=~) :: String -> String -> [String]
05:50:36 <lambdabot> Text.Regex.Posix.Wrap (=~~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target, Monad m) => source1 -> source -> m target
05:51:37 <Botje> hayoo says it's in Text.Regex.Posix.Wrap
05:51:39 <parcs`> _rvl: do you mean :: String ?
05:51:42 <Botje> (among others)
05:52:11 <_rvl> Botje: That seems to be the =~~ operator which i suppose is different from =~
05:52:33 <parcs`> _rvl: =~ is exported in Text.Regex.Posix for me
05:52:53 <_rvl> parcs`: if you use :: String you get either the whole string or "". I would like a list of match groups, i.e. those in ()
05:53:55 <_rvl> so I expect "aaabb" =~ "(a+)(b*)" :: [String] == ["aaa", "bb"]
05:54:10 <dd> another newbie question:  I have a list of strings that can have trailing empty strings in it ["N8", "01", "", "03", "04", "", "", ""].  Is there an easier, general way to get rid of the trailing nulls than:  reverse . dropWhile (== "") . reverse $ theString
05:54:39 <quicksilver> no
05:54:46 <quicksilver> that way is fine :)
05:54:54 <dd> ok, thanks -)
05:55:03 <quicksilver> although I'd use null instead of  (=="")
05:55:13 <sp3ctum> @src null
05:55:13 <lambdabot> null []     = True
05:55:13 <lambdabot> null (_:_)  = False
05:55:29 <sp3ctum> > null ""
05:55:30 <lambdabot>   True
05:55:39 <dd> gotcha
05:55:42 <sp3ctum> good call.
05:56:51 <dd> I wrote a basic EDI parser in 5 lines of code, that led to some jaw dropping comments at work yesterday, so now I'm souping it up a bit to do more complex tasks
05:57:37 <parcs`> _rvl: this works getAllTextSubmatches ("aabb" =~ "(a+)(b*)" :: AllTextSubmatches [] [Char])
05:57:37 <yitz> dd: cool!
05:57:59 <parcs`> _rvl: returns ["aabb","aa","bb"]
05:59:07 <_rvl> parcs`: excellent, excellent
05:59:24 <dd> is parsec the best way to go?  meaning fast and space efficient?  We do have some very large files I would want to run this on
06:00:27 <quicksilver> it is a reasonable way to go
06:00:48 <quicksilver> only experimentation will show if it's good enough for you I suspect.
06:00:50 <parcs`> if you want very high throughput, check out attoparsec
06:01:23 <dd> thanks
06:02:05 <_rvl> the world is saved and I don't have to go back to python
06:03:02 <_rvl> unfortunately i am called to leave, thanks and bye
06:05:39 <merijn> dd: Attoparsec has better performance, afaik. But I've also heard that porting parsec to attoparsec is fairly trivial
06:05:55 <merijn> dd: So I'd probably stick with parsec until it doesn't work and then consider moving to attoparsec
06:07:45 <cornihilio> hey, what's the best way to split a list at a given index? this page is listing weird split functions: http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html
06:07:59 <dd> ok, that is good to know
06:08:01 <cornihilio> I'm looking for the normal a -> [a] -> ([a], [a])
06:08:20 <trotro> you need instance of Eq
06:08:31 <parcs`> cornihilio: break
06:08:36 <lispy> ?hoogle a -> [a] -> ([a], [a])
06:08:37 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
06:08:37 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
06:08:37 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
06:08:56 <lispy> cornihilio: have you seen hoogle yet? Lets you search by type signature
06:09:23 <cornihilio> lambdabot is wrong: splitAt doesn't exist http://hackage.haskell.org/packages/archive/split/latest/doc/html/Data-List-Split.html
06:09:30 <parcs`> > break (=='a') "bcadefab"
06:09:31 <lambdabot>   ("bc","adefab")
06:09:42 <Botje> cornihilio: splitAt is defined in Data.List, not .Split
06:09:45 <lispy> cornihilio: that's a different module
06:09:57 <lispy> ?hoogle Eq a => a -> [a] -> ([a], [a])
06:09:58 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
06:09:58 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
06:09:58 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
06:10:10 <Philippa> dd: these days, parsec is the "parse anything, not necessarily as quickly as could be but not appallingly slow" option
06:10:12 <cornihilio> I am a fool
06:10:14 <cornihilio> thank you!
06:10:24 <lispy> ?hoogle  (a -> Bool) -> [a] -> ([a], [a])
06:10:25 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
06:10:25 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
06:10:25 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
06:11:05 <Philippa> and by anything, I mean... well, turing complete and happy to emit all kinds of effects as it works along whatever it's munching
06:11:16 <lispy> :t \x -> break (==x)
06:11:17 <lambdabot> forall a. (Eq a) => a -> [a] -> ([a], [a])
06:11:28 <stevan> hi, does compiling libraries and executables with profiling (--enable-{library,executable}-profiling) affect performance (when +RTS -p -RTS, isn't passed)? thanks.
06:11:38 <lispy> stevan: yes
06:12:00 <lispy> stevan: It adds a lot of extra parameters to functions for the book keeping
06:12:09 <lispy> stevan: and that in turn goofs up some optimiations
06:12:34 <lispy> stevan: so you have the two combined effects, a) extra book keeping + parameters, b) fewer optimizations fire
06:13:21 <stevan> i see, so what's the recommended solution? reinstall every package after profiling is done?
06:13:27 <lispy> stevan: but, the nice thing about using --enable-library-profiling is that it builds 2 versions. One with profiling and one without.
06:14:02 <lispy> So you don't have to worry about reinstalling libraries. I would recommend rebuilding the executable.
06:14:14 <stevan> hmm, i don't see duplicates of my packages in the ghc-pkg list output?
06:14:29 <dd> These are for the most part text files of roughly 2-3 kb size.  Although there are some that can run to 800 pages when coming off the mainframe, so i need some kind of streaming solution long term
06:14:40 <lispy> look for files like libHSfoo_p
06:15:26 <Philippa> ah. How much memory do you have to work in? Those aren't actually all that big compared to some of the datasets people have tried with Parsec
06:15:37 <Philippa> OTOH, Parsec definitely isn't a streaming solution
06:15:58 <lispy> streaming parsers are very hard to write.
06:16:18 <lispy> It's usually much easier to chunk the data set and parse it as a stream
06:16:47 <dd> our prod boxes are 8 gb
06:17:06 <dd> chunking is fine
06:17:18 <Philippa> mmm. You can let the non-stream parser do the chunking if you don't need to parallelise, but you definitely need an outer loop driving it if you're going to do it that way
06:18:09 <parcs`> what's a streaming parser if not just e.g. attoparsec-enumerator?
06:18:54 <lispy> parcs`: parsers usually have to consume a lot, if not all, of the input to know what they are returning.
06:19:15 <dd> the parse is fairly trivial, closer to CSV than anything else
06:19:28 <lispy> parcs`: attoparsec-enumerator is for things like csv parsers where you could `lines` the input
06:19:39 <dd> EDI files have segments composed of elements, elements are terminated by a separator and segments are terminated by a different separator
06:20:05 <lispy> parcs`: at least, that's how I grok it. It's for parsing things have have lots of little records as contrasted with xml where you need the whole tree.
06:20:11 <Philippa> dd: cool, worst case you just end up doing something multi-layered then
06:20:15 <parcs`> lispy: oh right. i remember someone explaining this to me before :P
06:20:29 <Philippa> (chunking pass -> chunk parsing in parallel, etc etc)
06:21:09 <dd> yah, i don't need this to be my enterprise solution today, we already have one, but boy, this is a lot easier for prototyping and developing extensions
06:21:13 <merijn> What's UndecidableInstances do?
06:21:20 <lispy> dd: I bet you can make haskell do this quite efficiently
06:21:45 <dd> I'm up to 20 lines of code and it already does 100% of the core parsing necessary, i just need to add header parsing and I'm done
06:22:36 <dd> I can lispy, problem is it would have to run in the JVM to work with everything else.  But for batch jobs, scripts and prototyping, i'm thinking this is great
06:22:46 <ClaudiusMaximus> merijn: allows ghc type checking to be non-terminating, so you have to be careful that your instances converge, or somthing like that (i may be way off)
06:22:53 <lispy> dd: and in fact, if you rewrote your parser to use attoparsec then the attoparsec-enumerator mentioned already would give you streaming-like capabilities at the cost of requiring you to learn enumerators (not a beginner subject)
06:23:20 <parcs`> merijn: allows the creation of instances that can potentially make the compiler loop during instance resolution
06:23:36 <ClaudiusMaximus> merijn: http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/type-class-extensions.html#undecidable-instances
06:23:42 <merijn> parcs`: hmmm, and how do I ensure it doesn't? ;)
06:23:47 <lispy> dd: I don't know where your haskell-fu is at, but enumerators are not that bad, just hard to get started with.
06:23:51 <dd> well, i'm massively impressed so far, so I will probably buckle down and learn it once I get this thing working really well where I can demo it
06:24:13 <Philippa> dd: so talk to us another time about getting a Haskell program to do code generation! Not total beginner work, but easier than you'd expect
06:24:13 <dd> well, this is my first program in haskell, my fu is white belt
06:24:22 <merijn> parcs`,ClaudiusMaximus: Although I'm mostly copying the same usecase as MonadReader which uses UndecidableInstances, so I guess it'll be fine
06:24:33 <Philippa> dd: then congrats :-)
06:24:34 <lispy> dd: GHC has really good profiling tools and I highly recommend using them before you start to optimize.
06:25:05 <Philippa> lispy: I really need to take a proper look at attoparsec sometime, don't I? Not that I need to use it personally, but
06:25:06 <dd> Yes, need to get profiling up and running and some kind of testing framework
06:26:23 <lispy> Philippa: It's not mind blowing in any way. It's just parsec with lots of features missing and you don't need to use try because lookahead basically doesn't exist.
06:26:54 <Philippa> lispy: sure. What do you get for it?
06:27:00 <lispy> Philippa: it was meant for simple parsing jobs where performance matters
06:27:03 <stevan> lispy: thanks, recompiling the executable with profiling disabled seems to have done the trick.
06:27:06 <c9s> CindyLinz: !!
06:27:20 <Philippa> lispy: sure, I'd gathered it's intended for fast LL(1) parsing + whatever you can kludge
06:27:30 <dd> see you all later, thanks for the help
06:27:36 <Philippa> (if it's monadic then you can kludge the lot, of course)
06:27:38 <lispy> dd: good luck
06:28:06 <fenton> i've got a list of lines and i want to extract two different regex's.  would i filter the list twice? any suggestions?
06:28:34 <trotro> you pass the result of the first filmter to the second ond
06:29:01 <fenton> ok thx...
06:29:27 * lispy heads to work
06:29:34 <fenton> trotro: sorry wont work...the matches will be on different lines...i think i'm not being clear...it's not a nested regex, so to speak
06:29:49 <trotro> its a union ?
06:30:20 <fenton> say i have a list of last names and want each row that has 'smith' and 'jones'
06:31:28 <Philippa> smith /and/ jones, or smith /or/ jones?
06:32:08 <Philippa> but you never need to filter twice: you can combine the predicates
06:33:24 <fenton> smith or jones
06:33:44 <fenton> ok only one pass great
06:34:04 <Philippa> fenton: can you see why you only need one pass?
06:35:35 <fenton> Philippa: well if i can design a predicate that matches on either string...then only one combined predicate needed...right?  still dont know what the predicate would look like tho? :)
06:36:41 <Philippa> well, you'd take the two predicates for each string and find a function to combine them appropriately, no?
06:37:51 <fenton> Philippa: two functions (predicates) and combine with an || as a new predicate function.
06:39:24 <Philippa> sounds about right
06:39:34 <fenton> foundLine line = line =~ "(Jones|Smith)"
06:39:57 <Philippa> I wasn't going to push it into a regex matcher myself, but sure
06:40:16 <Philippa> (beware: I haven't used regen in Haskell, I work with parsec instead)
06:41:37 <fenton> Philippa: never heard of parsec, i'll have to look into that...
06:42:15 <Philippa> parsec is basically the swiss army tacnuke of parsing in haskell
06:42:28 <Philippa> only slightly less likely to kill you and all your mates than C++ is
06:43:49 <fenton> Philippa: i'm reading now...looks quite cool!  Thanks for the tip!
06:53:24 <DanMere34567> hi everyone
06:54:54 * hackagebot unix-process-conduit 0.1.0.1 - Run processes on Unix systems, with a conduit interface  http://hackage.haskell.org/package/unix-process-conduit-0.1.0.1 (MichaelSnoyman)
06:55:17 <DanMere34567> quick question, at the moment i can use this function xs = [((sp_dny_le00_ma_in_ZMB!!0),(sp_dny_le00_ma_in_ZMB!!1))] but what i want to do is somthing like xs = [((sp_dny_le00_ma_in_ZMB!!n),(sp_dny_le00_ma_in_ZMB!!n+1))][0..50] so that it will build the list till it gets to n=50 how can I do this?
06:56:25 <Botje> zip list (tail list)
06:56:36 <Botje> and take 50 or 51 elements from that list.
06:56:49 <ClaudiusMaximus> replace "][" with "| n <- [", but you probably want what Botje said -- the syntax i mention is called "list comprehension"
06:57:01 <Botje> > let list = [8..20] in take 5 (zip list (tail list))
06:57:03 <lambdabot>   [(8,9),(9,10),(10,11),(11,12),(12,13)]
06:57:12 <DanMere34567> ok
06:57:22 <ClaudiusMaximus> using !! gets more expensive the larger the argument is
06:57:22 <bartavelle> not sure if this was printed (deconnected), is there an already written function that converts hex encoded bytestrings (or text) into a bytestring ?
06:59:36 <merijn> I guess there's no inverse of lift? (t m a) -> m a
06:59:46 <DanMere34567> thank guys
06:59:51 <Botje> merijn: that's runXXXMonadT
07:00:47 <merijn> Botje: No, because that doesn't work on all monad transformers, i.o.w. I need to define my monad transformer implementation separately for every transformer :(
07:04:41 <EvanR> MonadXXX ?
07:05:12 <merijn> EvanR: I'm defining one of those, so the one I need doesn't exist yet
07:05:24 <EvanR> sounds naughty
07:05:54 <nand`> byorgey: I approve of the usage of tau :)
07:06:31 <b__> can I bind x + y as z and use it thus: [x + y | x <- xs, y <- ys, z > 2] ?
07:06:32 <merijn> EvanR: Figured I could just write "instance (MonadXXX m, MonadTrans t, Monad (t m)) => MonadXXX (t m)", but it's start to look like I have to define a seperate instance for all monad transformers :(
07:06:51 <EvanR> uhg transformers
07:07:07 <b__> like [z@(x + y) | x <- xs, y <- ys, z > 2] or something?
07:09:40 <cornihilio> is there something equivalent to mod for doubles/floats? I mean can't it just check that the decimal value is the same?
07:10:46 <ClaudiusMaximus> > [ z | x <- [0..5], y <- [0..5], let z = x + y, z > 2 ] -- b__    -- i hate this syntax clunkiness
07:10:47 <lambdabot>   [3,4,5,3,4,5,6,3,4,5,6,7,3,4,5,6,7,8,4,5,6,7,8,9,5,6,7,8,9,10]
07:10:51 <Cale> merijn: If you choose to provide lifting instances, which lift the operations that your transformer provides through other transformers, then you need to write lots of instances.
07:10:59 <ClaudiusMaximus> @hoogle mod'
07:10:59 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
07:10:59 <lambdabot> Data.Fixed divMod' :: (Real a, Integral b) => a -> a -> (b, a)
07:11:08 <ClaudiusMaximus> cornihilio: ^
07:11:15 <b__> ClaudiusMaximus, thanks
07:11:37 <Cale> merijn: But I never thought of the lifting instances as particularly good style in the first place.
07:12:15 <ClaudiusMaximus> > (10/3)*3 `mod'` 10 -- but beware the rounding errors inherent in the system, cornihilio
07:12:16 <lambdabot>   10.0
07:12:18 <Cale> All they accomplish really is making it easy to write code in poor form without abstracting the use of monad transformers.
07:12:20 <merijn> Cale: Why not?
07:12:59 <Cale> If you're wrapping your uses of monad transformers already, doing the lifts manually in the small part of the code where you're defining your basic operations is not a hassle.
07:13:23 <ClaudiusMaximus> hm, maybe that parses differently than i expected
07:13:35 <ClaudiusMaximus> > (10 / 3 * 3) `mod'` 10
07:13:36 <lambdabot>   0.0
07:14:07 <ClaudiusMaximus> > (10 / 3 * 3) `mod'` 10  :: Float
07:14:08 <lambdabot>   0.0
07:14:13 <ClaudiusMaximus> hm, anyway
07:14:55 <Sculptor> hi!
07:15:00 * ClaudiusMaximus wanders off to code up sin/cos/etc for variable-precision by copy/pasting from arxiv papers by experts in numerical analysis...
07:15:46 <Philippa> Cale: I'd disagree /if it were less ridiculous when you want new lifting instances/
07:15:49 <Philippa> as it is? Yeah, bad style
07:15:50 <merijn> Cale: I have a library API which would very much benefit from wrapping everything up in a Reader like monad, but if that wraps around any monad stack I'm using that means I have to lift every other operation in said monad stack
07:16:20 <Philippa> Yep. Minor PITA, but still a PITA
07:17:12 <merijn> It would be much nicer if the API provides a generic opaque base monad with it's operations pre-lifted so you can use them whereever....(I'm not excluding the possibility that I'm overlooking other solutions, but I haven't thought of them yet)
07:17:36 <Philippa> it'd be much nicer if typeclasses weren't the only tool we had for this kind of shit, too!
07:17:44 <merijn> Philippa: Word.
07:17:45 <Philippa> (the instance manipulation part, they're not so hot at)
07:18:13 <merijn> Actually, if we had instance chains they'd be a bit less sucky to beat into doing what you want
07:19:51 <Philippa> yeah. Hell, even just being able to express "you should never want to use (the nice sugar for) this for more than one instance, top of stack wins" would help
07:20:07 <Philippa> but we can't fake lexical scope properly
07:20:12 <Philippa> ...huh
07:20:26 <Philippa> yes, I did just say that without thinking it consciously or having done so previously. The lexical scope bit, that is
07:20:39 <Philippa> I should let that rattle around my brain a bit more, I think
07:23:40 <Philippa> ...dammit. I already have one vaguely ML-like module system to code up...
07:35:59 <RachelS> Hi all, I'm quite new to Haskell - so go easy on me!  What I want to do is put together a universal datatype - essentially I want to be able to create a list of elements of my newly defined datatype, with these elements being Strings, Integers, or whatever else.  Then, I want to be able to write functions that work with these elements, and treat an Integer like an Integer, and a String like a String.  How might that datatype look?
07:37:30 <merijn> RachelS: Are you thinking of something like an interpreter working with expressions of different types?
07:38:00 <merijn> hmm, actually I don't think my original idea will work
07:38:07 <alpounet> RachelS, can you describe your concrete use case?
07:38:22 <n-dolio> There's a Dynamic type that kind of does this, in the really extreme case.
07:38:32 <n-dolio> It may or may not be what you're looking for.
07:38:34 <merijn> RachelS: You could do it using existentials, but since you're new you probably want to avoid those for now. Maybe there's a better way if you tell use what you want to do?
07:39:58 <n-dolio> The question would be whether there is a finite list of types you care about. Or is it really everything.
07:41:01 <RachelS> I've been reading about DSL - Domain specific languages, and I want to be able to describe a problem using words of meaning to my domain - some of which will carry with them Strings or Integers, but I'd like to leave it open enough so that any type can be used.  So, yes, ideally leaving in everything!
07:42:35 <RachelS> I've been reading up on Existentials, and had a quick look at Dynamic...  the best I've come up with so far is defining a datatype that has specific types for being with a String, and an Integer, and a List...  and then a free type that will allow anything
07:42:42 <Philippa> why do you want a universal datatype for this?
07:42:43 <RachelS> It seems like there must be a better way
07:42:53 <Philippa> why not eg a parameterised one, the way things like monads work?
07:44:51 <tdammers> RachelS: I'm currently using exactly that approach - one constructor for each data type I want to support
07:44:56 <nand`> polymorphy replaces universal datatypesd
07:45:00 <nand`> s*
07:45:31 <tdammers> I need this to emulate the typing behavior of dynamically-typed languages (javascript and PHP for now)
07:45:36 <nand`> (disclaimer: I didn't read what this was about)
07:45:48 <tdammers> but marshalling between haskell and this 'variant' data type is rather painful
07:48:31 <RachelS> Hmmm...  doing this with a universal datatype is kind of research question, which will hopefully lead on to other things.  (When I've figured out Haskell some more!).  What I'm looking to do is build up a set of constraints, and then be able to evaluate whether my domain language complies with those contraints
07:48:50 <scooty-puff> i was wondering what the reason was for ListT not being an instance of MonadWriter - i had been cleaning up a permutation monad had was unable have have it properly implement "pass" of MonadWriter
07:48:52 <Philippa> or rather, the program in it/value it builds?
07:49:11 <scooty-puff> *had -> and
07:49:26 <Philippa> sorry, let me rephrase: are you looking to do constraint programming, or to work out if you can build an appropriate language?
07:49:51 <RachelS> So, I should be able to run a test, and see if the values in my list of universal data elements are greater than 100 say.  If it's an Integer or Float, then it will be able to evaluate this, otherwise it will fail - but that's ok
07:51:04 <RachelS> If I understand you correctly - Both...  I want to define an appropriate language for my domain, and then be able to evaluate that language against my constraints - which I'll also define
07:51:09 <Philippa> *nod*. Is there a reason you want your DSL to be dynamically typed? Or is that just an artefact of how you're implementing it?
07:51:17 <Ale> hi everyone
07:52:40 <Philippa> hi Ale
07:53:01 <byorgey> hi there Ale
07:53:11 <Ale> hi, how are you?
07:53:24 <byorgey> Ale: I'm well, thanks.  Are you trying some Haskell? =)
07:53:45 <Ale> I'm trying to learn something of haskell 'cause tomorrow I'm having an exam
07:54:09 <Botje> one does not learn Haskell in a day
07:54:15 <Philippa> heh, I hope you were getting on okay with it previously then - it's not necessarily a hard language, but it's not necessarily the same as what you've done either
07:54:17 <scooty-puff> i feel a meme coming on..
07:54:26 <lispy> Botje: but perhaps one can learn something of haskell in a day
07:54:28 <Botje> we have enough brain-matter explosions imprinted on the wall as proof :)
07:54:31 <Philippa> Botje: I dunno, I can teach someone enough to write bad but turing complete code
07:54:46 <pckt> One did not say it was a haskell exam, could just be procrastinating
07:54:52 <RachelS> I'm not sure...  I need my language to be able to be built from elements of any type, but my constraints will mostly just work on specific known types
07:54:54 <tdammers> half a dozen cerebral detonations are part of the learning curve
07:54:57 <scooty-puff> Ale, what are you looking for?  is this a haskell-specific exam?
07:55:07 <scooty-puff> Ale, resources are probably that best that anyone here could provide
07:55:15 <scooty-puff> *that -> the
07:55:34 <lispy> tdammers: true that
07:55:50 <Ale> yes scooty
07:55:56 <lispy> Haskell: Prepare for mental detonations.
07:56:03 <Ale> it's a haskell exam in paper
07:56:16 <Ale> it will includes lists and lists of lists
07:56:27 <Philippa> RachelS: it sounds like the universal datatype might not be the way to go, then. I've mostly been doing simple term equality constraints and the like, which I've been using a monad for - I'm looking to solve the constraint set rather than check values satisfy it though
07:56:29 <lispy> Ale: higher order functions?
07:56:35 <lispy> Ale: types?
07:57:00 <RachelS> Ale - I quite like http://learnyouahaskell.com/chapters - it's a free book, and is quite an easy read
07:57:09 <lispy> Ale: could you, for instance, write your own version of map or fold from scratch?
07:57:40 <lispy> Ale: have you ever read the Prelude and tried to implement the things there for yourself?
07:58:14 <lispy> Ale: When I was taking a class on Haskell I found those exercises to be very valuable, but your mileage may vary.
07:58:29 <Philippa> RachelS: is there a good reason not to just build combinators for building up values as your DSL, for example? Does the language need to manipulate things like state?
07:59:32 <Ale> no, that's the point
07:59:57 <Ale> I always did the exercises in paper, but not in a compiler
08:00:02 <RachelS> Philippa - Yeah, it's lists of data elements that I want to be able to run my constraints against.  A simple example might be if I had my list of data elements, and I wanted to confirm whether they are all above a certain value, or a string "N/A" perhaps
08:00:36 <Philippa> RachelS: there are already standard functions that do a lot of those things :-) Though you might want to add a few relatives
08:00:45 <Philippa> :t all
08:00:47 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
08:01:14 <Philippa> all (>10) [20,30,5]
08:01:20 <Philippa> > all (>10) [20,30,5]
08:01:22 <lambdabot>   False
08:01:22 <lispy> Ale: are you a mathematics student and not comp. sci. student? (Just wondering why you've not done them in a compiler)
08:01:26 <Philippa> > all (>10) [20,30,50]
08:01:28 <lambdabot>   True
08:02:04 <lispy> Ale: if you have ghci installed it's pretty easy to get started
08:02:32 <lispy> Ale: and also, tryhaskell.org where you can get started with only a web browser
08:02:41 <Philippa> RachelS: I've written things like household budgets as Haskell code before, they came out perfectly legible to non-programmers
08:03:14 <Philippa> RachelS: it gets more interesting if you want to do things like 'instrument' code though - if you want it to tell you 'how' it'll run, things like that
08:03:16 * lispy disappears again
08:03:28 <Ale> I have ghci but I don't know how to use it
08:03:30 <Ale> :(
08:03:51 <Ale> I'm not a math student
08:04:11 <Ale> I just studyng for system analyst
08:05:10 <Philippa> there are a few commands it's useful to know in ghci, otherwise you can just enter expressions and ask it to evaluate them
08:05:11 <RachelS> Thanks, didn't know you could do that...  that's maybe part of it...  how could I make it work with say:  MyVal [MyVal 123, MyVal "N/A"]
08:05:20 <Philippa> :t "what's the type of this?"
08:05:22 <lambdabot> [Char]
08:06:13 <RachelS> So, maybe I'd be able to take that MyVal, and pull it in to a function...  and also pass in my contraints, and then get an output whether it fits my two constaints of - must be greater than 100, or a string "N/A"
08:06:15 <RachelS> ?
08:06:35 <Philippa> RachelS: that depends on what you want MyVal to do, but I suspect this is the point where we talk about functors and applicatives and monads
08:06:38 <Ale> and, I had the bad luck to waste so much time in another subject
08:07:03 <RachelS> Philippa - the :t type is the thing I'm trying to work out :-)  It seems like I should be able to do something like that...  but I don't know how I'd define that datatype
08:07:07 <Ale> so, I couldn't study this subject properly
08:07:10 <Philippa> oh, wait, no, you definitely definitely need something different to mix numbers and strings like that, yes!
08:07:17 <strebe> ale: the basics aren't too bad; try typing things like let a = [1, 2, 3]       let b = [4, 5, 6]       0:a        a++b (wherever I put a lot of spaces, put a new line)
08:07:36 <Philippa> (and I normally avoid doing that like the plague for a number of good reasons: I'm a statically typed kinda girl. Sort of.)
08:07:42 <strebe> ale: well, do you want to learn it? We can't give you a passing grade on it no matter how much we feel sorry for your circumstances....
08:08:27 <Philippa> RachelS: so you're going to need to define your own versions of all the predicates you need the hard way, unfortunately :-(
08:08:33 <Philippa> lots of pattern matching, lots of tedium
08:08:48 <Philippa> but once you've got the hang of it, you'd just be translating bits of the Prelude
08:09:33 <strebe> ale: try typing out the kinds of things you've done on paper, and ask when you run into problems
08:09:41 <Philippa> would you like me to talk a little about what you can do if you're happy to not put different types in the same list, though? It's pretty powerful
08:10:23 <Philippa> (someone else'd better talk about how to do the pattern-matching, my brain's not in the right state for it at the moment whereas at least if I'm doing the monad tutorial I know Cale will wander by sooner or later :p)
08:10:43 <RachelS> Ha, alright...  hmmm...  so, what I have at the moment is essentially MyListVal [MyIntegerVal 123, MyStringVal "N/A", MyOtherVal 54.63]...  this way I can write functions that understand what to do with the appropriate types - but it feels a bit ugly - since MyOtherVal can be anything - including an Integer or String or whatever, and if the data elements aren't typed properly on the way in, then they don't get handled appropriately
08:11:38 <lispy> Ale: that's unfortunate, but let's not focus on that right now. Right I recommend getting the simplest things working. Make sure you can evaluate things (just use tryhaskell.org for now) like 2 + 3. Start defining writing your own versions of simple list functions. Try writing null, head and tail.
08:11:57 * lispy can't type
08:12:06 <Cale> If you're putting differently-typed things into the same list, there has to be *something* they all have in common.
08:12:08 <lispy> Ale: hopefully you can parse what I said and make sense of it :)
08:12:41 <Cale> If you can decide what that thing is -- what interface they all provide which allows them to belong to that list -- then you could instead to decide to store records of those functions instead.
08:12:51 <Philippa> RachelS: yeah. And you're kinda stuck with that ugliness unless you let your MyVal type... well, talk about the types on the type level
08:13:12 <Philippa> (but also what Cale is saying: we're tackling different problems and you get to decide which one you have)
08:13:15 <lispy> Ale: if you're not sure what null, head, or tail should do try evaluating the provided versions. Once you think you understand them, write your own versions.
08:13:50 <lispy> > null [1,2,3]
08:13:51 <lambdabot>   False
08:13:58 <lispy> > null []
08:13:59 <lambdabot>   True
08:14:00 <Cale> If you're just sticking random crap in a list where the elements have nothing to do with one another and which you don't even know how many of them you have, then fuck you. I don't want to ever have to maintain your shitty program.
08:14:12 * lispy disappears again (maybe for real this time)
08:14:13 <Cale> :D
08:14:27 <lispy> Cale: heh
08:14:31 <lispy> Cale: easy now :)
08:14:57 <Cale> (but surely you agree with me on this :)
08:14:59 <Saizan> webdev is changing Cale's spirit
08:15:12 <Ale> thanks lispy, your words are useful
08:15:12 <Philippa> Cale: it could well be the domain programmers' programs. And, well, sometimes prolog is a valid choice?
08:15:17 <b_jonas> so in the special case when there's nothing common, you essentially get a [()] ?
08:15:22 <Philippa> (sometimes, you should be programming in prolog instead!)
08:15:38 <Ale> I will try to do some exercises right now
08:15:47 <Cale> Philippa: But even the domain programmers should be forced into doing something sensible!
08:16:08 <Ale> but is also good to know that there are people like you helping here
08:16:10 <Philippa> heh. I think it's time to introduce functors, anyway?
08:16:18 <Cale> If they're putting random things into a list, you have to wonder why they think it's okay to stick all that stuff together.
08:16:36 <Cale> Maybe they're missing some fundamental operation which they ought to have been provided
08:16:38 <Philippa> Cale: "ListOfShitMyBossEmittedFromUnstatedOrifice"
08:16:46 <RachelS> Ha, ok, so Cale, I think this fits in to the whole Haskell class thing?  So, I'd define a class with my Integer and String, and other familiar things, which could then be handled by non-shitty code...  and then anything else could be handled by more generic code
08:17:27 <Philippa> RachelS: if you don't definitely /need/ lists of random crap, you can do much much better
08:17:28 <Cale> RachelS: Well, perhaps -- if your operations already belong to a typeclass, then you can easily form an existential type to "forget" the original types of the values and only remember that they were instances of the class.
08:17:35 <RachelS> I'm figuring this out as I go along...  I've read about a whole bunch of stuff, and trawled the internet trying various ideas, and my head is a bit of a jumble of not entirely connected stuff right now
08:18:05 <Mortchek> class BossEmissions a where { youWantMeToDoWhatWithThat :: IO () }
08:18:06 <Philippa> mmm. Did you know we have typeclasses for specific flavours of DSL?
08:18:06 <Cale> RachelS: But also, you can just imagine bundling up data structures with recordings of what those functions do to your data (and Haskell is lazy, so those'll only be computed if needed)
08:18:12 <Mortchek> Woop
08:18:16 <b_jonas> or you can go traditional and put an actual closed type in the list
08:18:26 <Mortchek> Shoulda been a function :P
08:18:55 <b_jonas> right, the functions
08:20:01 <Cale> RachelS: For example, if the only thing the elements have in common is that at some point you're going to turn them into Strings, just turn them into Strings and store those in the list.
08:20:35 <RachelS> Philippa: No...  I didn't know that...   Cale:  That sounds interesting - in a I don't fully understand, but it sounds like it might make sense for my problem kind of way...  could you tell me more?
08:20:37 <Cale> RachelS: and don't worry about the cost of doing so up front, because the prettyprinting function will only be evaluated when you actually start to take them out and look at them
08:20:42 <b_jonas> how do you translate to putting the functions in the list if it's a multi-parameter typeclass though? like, if you have a class method that can do something with any two elements of the list?
08:21:07 <Philippa> b_jonas: then you're SOL
08:22:01 <Cale> RachelS: Or, let's say you have a bunch of objects in some animation or game, and each of them needs to have a way to draw itself on the screen, and to step forward by some amount of time.
08:22:18 <Philippa> (individual values know their own types, but things holding them don't, so you can't take the type info from two values together)
08:22:18 <RachelS> Cale: I was considering the convert everything to Strings approach...  but then it seems to create a pile of mess on the other side - like checking if a value is an Integer, or checking if that value is greater than 100, say
08:22:33 <Cale> RachelS: and the reason you're sticking them into a list is to later be able to iterate over that list and draw them all, or to step them all forward in time
08:22:59 <Cale> RachelS: Okay, well, if you're going to need to check if the thing is greater than some integer
08:23:15 <Cale> RachelS: then you need to be able to define what that means for *all* the values you put in the list
08:23:28 <Cale> Otherwise, why are you putting them into the list?
08:23:41 <Philippa> RachelS: so one of those typeclasses, though often not thought of as a DSL, is Functor. A Functor is a type [constructor] that lets you 'map' functions over its values - so it has a "run a haskell function over me" operation
08:23:55 <RachelS> Philippa - yeah, that makes sense - whenever I've tried to do that, GHCi shouts at me...
08:24:03 <Cale> Presumably you're putting all these things into a list so that you can iterate over the list in some uniform way later on.
08:24:13 <Philippa> some Functors are simple - Maybe, for example. Others are really complicated - Parsec's instance, say
08:24:17 <Cale> A list is just a loop which hasn't happened yet.
08:24:29 <RachelS> Cale: Well, in my case, it's either an Integer and it can do that comparison, or it's not, and then that constraint will fail
08:24:39 <Cale> okay
08:24:49 <Philippa> they won't give you your list of mixed types! But they'll let you work on lists of any one type you like
08:24:56 <Cale> So what you really have is a Boolean value alongside your String?
08:25:11 <Philippa> and you can nest mappings - MyVal [MyVal 1, MyVal 2, MyVal 3] works fine
08:25:29 <Philippa> (but you'll probably turn it to MyVal [1,2,3] somewhere along the line)
08:25:32 <Cale> RachelS: anything you might want to do once you get the elements of the list out, you can also do before you put them in
08:25:46 <Cale> RachelS: and that has a tendency of making the list have a uniform type
08:26:08 <Cale> Do you see what I mean?
08:26:54 <Cale> So you'd have   data MyRecord = MR { prettyprint :: String, bigEnough :: Bool }
08:27:03 <RachelS> Cale: Well, in it's simplest form, I want to be able to have two constraints defined - say [greater than 100] or [equal to "N/A"], and then I want to be able to have my list of stuff, and have a function take the stuff, and the constraints and tell me whether I have valid input
08:28:23 <Cale> If all that you're planning to do is to check that the constraints are satisfied, why not put the tests into the list as boolean values, and then just apply 'and' to the list or whatever after that?
08:29:04 <ski> scooty-puff : i vaguely seem to recall `ListT m' not being a monad unless `m' is commutative
08:29:13 <RachelS> Philippa: Yeah, the list has to be a mixed type, unfortunately
08:29:17 <Cale> RachelS: Does that make sense?
08:29:17 <ski> @wiki ListT done right
08:29:18 <lambdabot> http://www.haskell.org/haskellwiki/ListT_done_right
08:29:53 <Philippa> RachelS: is there more of a problem spec you could show us? Right now the best answer we're likely to give you amounts to "reimplement Prolog" or "reimplement Scheme" or limited subsets thereof
08:29:56 * hackagebot perm 0.1.0.0 - permutation Applicative and Monad with many mtl instances  http://hackage.haskell.org/package/perm-0.1.0.0 (AndySonnenburg)
08:30:18 <Cale> Philippa: My initial suggestion is just to use the and function
08:30:21 <RachelS> Cale: Possibly it makes sense - but, if I'm feeding in lists of input, then...  um...  would I be able to enter my list without the boolean values, and then these boolean values would be computed for me, based on the constraints?
08:30:25 <Philippa> Cale: well yeah, beat you to it
08:31:08 * ski would like to see a BNF of the DSL ..
08:31:18 <Cale> RachelS: Well, for each type of thing, you can write a function which computes the appropriate constraint
08:31:20 <Philippa> ski: I suspect we're waaay too early for that
08:31:34 <Cale> RachelS: and then you can apply the appropriate function for that type of thing to the element before you put it in the list
08:32:03 <Cale> RachelS: If you want, at that point, you can define a typeclass which says what the constraint is for each type.
08:32:08 <Philippa> Cale: you're going to get the multiple dispatch problem, even if one parm's known statically
08:32:17 <Cale> class MyConstraint a where
08:32:18 <ski> Philippa : well, not necessarily in symbols, words would be fine as well
08:32:20 <RachelS> Cale: Ok, that sounds like what I'm looking for...
08:32:22 <Cale>   constraint :: a -> Bool
08:32:41 <trotro> it isn't what we call a predicate ?
08:33:12 <Cale> trotro: Well, it sounds like RachelS wants a specific predicate on each type.
08:33:16 <ski> (i suppose what i'm is : some way to delinate the problem better)
08:33:56 <Cale> Philippa: not if you just apply different functions to each element of the list, such that the result is a Bool :)
08:34:07 <Philippa> RachelS: the other thing you can do, which also hurts, is provide a set of built-in datatypes that's enough to build your own datatypes including all the constraints you could want. But that's back to reimplementing Scheme or Prolog
08:34:09 <Cale> You just have a value of type [Bool] then
08:34:29 <Philippa> Cale: I think we're picturing a different constraint:value mapping here
08:34:46 <trotro> Cale, ha ok
08:34:54 <Cale> I mean, it sounds like all that RachelS is going to do with these values is to apply a predicate to each of them.
08:35:14 <Cale> and that's the entire continuation of the program as far as any one of these values is concerned
08:35:18 <Philippa> sure. But I think that predicate is && a bunch of different ones
08:35:26 <Philippa> with different target types and defaults
08:35:40 <Cale> hm?
08:35:53 <Philippa> otherwise, the question I would've asked is: why specifically a list?
08:35:53 <Cale> Surely you mean different source types?
08:36:08 <Philippa> was speaking loosely :-)
08:36:11 <Philippa> (but yes)
08:36:38 <Cale> So just apply all the various functions to the elements ahead of time, and you no longer have the problem of what sort of value to put in the list
08:36:50 <Cale> You're putting Bool in the list, and then applying and to the result.
08:38:05 <Cale> and you *have* to know, somewhere in your program, which exact types these things are (say, when you parsed them from user input, or entered them by hand)
08:38:08 <Philippa> I had the impression 'ahead of time' doesn't know the constraints
08:38:23 <Philippa> Cale: there's a reason I keep commenting about reimplementing Scheme or Prolog!
08:38:50 <anakreon> I've built a parser with Parsec. When schemantic errors are detected I call fail with an appropriate error message. However, I need to discriminate between syntactic errors and semantics one. How could I achieve this?
08:39:10 <Philippa> RachelS: Do you need mixed stuff in general, or are you just using "N/A" to mark where there's no value?
08:39:18 <pingu> is haskell suitable for webpages
08:39:29 <pingu> i mean, is there any big site using it?
08:39:34 <RachelS> Cale, Philippa: Sorry for being slow coming back to you here, I'm trying to absorb some of your wisdom, and think if I have my solution yet :)
08:39:44 <pingu> or web is not for haskell?
08:39:53 <pingu> just out of curiosity
08:39:54 <pingu> =)
08:39:57 <RachelS> Cale:  Ok, so, say I wanted to have this function:  evaluate (greaterThan 100 || notAvailable) (MyVal [MyVal 123,MyVal "N/A"])
08:40:12 <Cale> pingu: There are some really nice web frameworks written in Haskell. At skedge.me, we're starting to rewrite our entire web backend in it.
08:40:17 <RachelS> Which, should result in a "True!"
08:40:47 <Philippa> RachelS: so when I asked about "N/A", there's a really good reason for it
08:40:59 <Cale> and [greaterThan 100 123, notAvailable "N/A"]
08:41:01 <Cale> done!
08:41:13 <Philippa> Cale: *no*
08:41:18 <Cale> ;)
08:41:42 <Cale> You can *always* do this
08:41:49 <RachelS> Philippe: Yeah, I need the mixed stuff...  the example I'm giving here is a bit simpler, but if I can solve this (which is easier to talk about), then I should have the bigger solution too
08:42:11 <Philippa> RachelS: I think we really need a flavour of what 'larger' looks like
08:42:15 <Cale> There's no reason to form a list of arbitrarily-typed values if all you're going to do with them when you get them out is to turn them into Bool
08:42:34 <Cale> in exactly one way
08:42:36 <anakreon> The reason I want to discriminate the two error kinds is that parsing should stop in case of schematic errors. if I have for example  (try possibleError) <|> otherRule, otherRule will be executed if possibleError detected a schematic error.
08:43:03 <hashpuppy> haskell doesn't have actors right?  is there a reason for this?
08:43:11 <Cale> hashpuppy: See Cloud Haskell
08:43:16 <hashpuppy> thanks
08:43:28 <Cale> hashpuppy: We kind of hate to call it the 'actor model' for some reason.
08:43:35 <anakreon> In essence I need an alternative to fail which the try combinator won't handle
08:43:42 <Cale> hashpuppy: but that's basically what it is
08:43:43 <hashpuppy> interesting.  thanks for the heads up
08:44:10 <RachelS> Cale, Philippa:  Well, the list of items could be a lot longer than the list of constraints...  and some of the items in the list could be lists themselves
08:44:12 <Philippa> RachelS: we're still looking at lots of tedious pattern-matching unless you can make Cale happy or we can find a little more structure, I'm afraid
08:44:43 <Philippa> if you're truly stuck with heterogenous data, the "thing in common" is going to be the guts of a dynamically typed language
08:45:18 <Cale> RachelS: See, my argument is that instead of putting differently typed values into the list in the first place, you can instead look at all the things your program will do with the elements of the list when it takes them out again, and put *those things* into the list.
08:45:27 <RachelS> I'm pretty sure there must be a way of writing that function the way I'm imagining it - i.e. evaluate (greaterThan 100 || notAvailable) (MyVal [MyVal 123,MyVal "N/A"])   but, I just can't figure out how to write it ;)
08:45:40 <hashpuppy> FYI, https://github.com/jepst/CloudHaskell/commit/6acbcb6b2fc6bb6789cce2083cdd4747ef427627
08:45:43 <simon> it seems XMonad.Util 0.1.3.1 refers to 'catch' when it should be referring to catchIOError (pointed out by geekosaur). how do I make this replacement to my local copy of the package? simply going to .cabal/packages/hackage.haskell.org/xmonad-utils/0.1.3.1/xmonad-utils-0.1.3.1, unpacking the tarball and making the changes does not affect the install script.
08:45:46 <ski> Cale : we haven't really learned yet whether RachelS would also like to be able to do other things with the `MyVal ...' thing
08:45:54 <Philippa> nope. You're stuck with MyInt, MyString etc.
08:46:07 <Philippa> otherwise, you want a dynamically typed language
08:46:15 <Cale> hashpuppy: Yes, Cloud Haskell's implementation is (partly) in the distributed-process package
08:46:50 <Saizan> or use Typeable all over the place, which is an approximation
08:47:01 <Cale> ski: right, but RachelS hasn't said anything about doing anything other than turning them into Bool values
08:47:20 * ski nods
08:48:13 <Cale> Basically, I'm expressing the existential viewpoint, and Philippa is expressing the universal viewpoint here :)
08:48:41 <RachelS> Yeah, I think Cale is right - I just need to work out whether each element in the list fits any or all of the constraints, or not.
08:49:14 <RachelS> Oh, so the MyInt, MyString etc thing would be the universal datatype way?  That doesn't seem right?
08:49:22 <foob> //echo asd
08:49:26 <yitz> RachelS: are you not allowed to tell us what you are modeling?
08:49:42 <RachelS> Unless it comes with the MyAnything element...  which makes me sad.
08:50:14 <Cale> RachelS: well, applying the MyInt, MyString etc. tags will let you do *everything* that you could have done with Int or String or what-have-you, later in the program, by matching the appropriate tag and then carrying on with whatever it was you were going to do.
08:50:20 <ski> i think it would probably help if we could figure somewhat better *what* is wanted. *then* we can consider alternate ways of modelling it
08:50:53 <Cale> RachelS: My approach is to say there has to be *something* which you want to do later in the program, and if you work out exactly what that is ahead of time, you can just store its results into the list.
08:51:04 <RachelS> yitz: Yeah, it's something I need to keep a bit quiet for the moment...  but I'm convinced that finding the right solution for my evaluate (greaterThan 100 || notAvailable) (MyVal [MyVal 123,MyVal "N/A"]) problem will get me there
08:51:21 <byorgey> shapr: ping
08:51:43 <Cale> RachelS: So you could have a datatype like:   data Value = I Integer | S String
08:52:01 <Cale> and then your list becomes simply  [I 123, S "N/A"]
08:52:05 <byorgey> @ask shapr just wondering if you have any experience deploying ghclive to heroku
08:52:06 <lambdabot> Consider it noted.
08:52:14 <Cale> and you can write a function like:
08:52:22 <Cale> condition :: Value -> Bool
08:52:32 <Cale> condition (I n) = greaterThan 100 n
08:52:44 <Cale> condition (S x) = notAvailable x
08:53:07 <Cale> and then  evaluate condition [I 123, S "N/A"]
08:53:10 <Cale> right?
08:53:14 <tdammers> RachelS: https://bitbucket.org/tdammers/hpaco/raw/1e1cb23bda4ed4b6601d2209d402dc65ba6c7a77/hpaco-lib/Data/Variant.hs
08:53:24 <tdammers> this is how I do it
08:53:47 <tdammers> it models the full set of typical generic data types in a dynamically-typed language
08:53:58 <tdammers> but it doesn't have an "Anything" wrapper
08:54:08 <ski> RachelS : what should `greaterThan 100', applied to `MyVal "N/A"', be ?
08:54:29 <ski> RachelS : same for `notAvailable', applied to `MyVal 123'
08:54:30 <tdammers> ski: `false`, obviously :P
08:54:38 <RachelS> Cale: Right, yeah, that's pretty much where I am...  I have some of my familiar types laid out - I, S, L (for list), etc...  and I found I could use:   forall a. (Show a) => MyAnything a  to handle anything else...
08:54:54 <tdammers> RachelS: no, you can't
08:55:00 <Cale> RachelS: okay, so that's one approach, but it's not always the best thing to do
08:55:10 <tdammers> type variables get resolved at compile time
08:55:11 <RachelS> ski: yeah, it would be false if it doesn't fit the constraint
08:55:23 <ski> tdammers : how about `not . lesserThanOrEqual 100', applied to `MyVal "N/A"', then :)
08:55:28 <tdammers> so you can't do [MyAnything 23, MyAnything "foobar", MyAnything (Just 1) ]
08:55:29 <Cale> It's a good approach if you want to be able to write lots of new operations on your data
08:56:00 <tdammers> ski: if you implement dynamic typing, you have to define type coercion rules, but that is a different (and unrelated) problem
08:56:01 <Cale> But it's bad if you want to later be able to extend the number of cases that you have -- i.e. the number of primitive data types that you support.
08:56:28 <RachelS> tdammers: Thanks - I'm taking a look
08:57:21 <tdammers> RachelS: note that the type coercion rules are modelled after PHP and Javascript; if you start from scratch, you probably want to define different ones
08:59:14 <scooty-puff> ski: i may misunderstand the meaning of a commutative monad, but shouldn't ListT also not be an instance of MonadError since do { throwError "a"; throwError "b" } `catchError` return returns different results depending on which throwError action is executed first?
09:00:19 <Cale> RachelS: okay, another way to do it is to fix an interface to the elements, to decide ahead of time that, for example, the only thing you're ever going to do to them is to apply this constraint function anyway, so might as well get it over with up-front
09:00:43 <Cale> RachelS: But this is a somewhat trivial example, as it stands, so let me give you a better one.
09:00:53 <ski> scooty-puff : possibly, not sure
09:01:05 <Cale> RachelS: Suppose we're writing a game, and there are a bunch of various objects we're animating.
09:01:20 <ski> (scooty-puff : i suppose some non-commutative monads might work -- but not all of them, at the least)
09:01:32 <scooty-puff> k
09:01:37 <Cale> RachelS: still here?
09:01:55 <Cale> oh, you're looking at tdammers' library
09:03:49 <RachelS> Cale: I'm still here - and yes, looking at tdammers code, and thinking about what you've just said about "fix an interface to the elements" - it is the only thing that my function needs to do, just be able to evaluate elements against my constraint list
09:04:32 <Cale> RachelS: right, so if that's really all there is to it, why form a list of the elements in the first place?
09:04:46 <Cale> RachelS: why not just form a list of the results of applying the appropriate constraints?
09:05:13 <Cale> Do you have some other reason?
09:07:21 <Cale> (My questions aren't meant to be entirely rhetorical)
09:07:51 <RachelS> Cale: Well, partly it's because I want to be able to run one list against many different sets of constraints, in turn.  Yeah, it's important that the elements are in a list, and then they get evaluates - put an interim step of this would make sense to be a list of Bool values, I'm thinking
09:08:39 <RachelS> Cale: Sorry, *evaluated   and *but
09:09:27 <notdan> Hi, is anyone here familiar with Alex?
09:10:02 <Cale> RachelS: Do you have a fixed list of the constraints?
09:10:19 <Cale> (and I don't mean in the technical sense, but just a set)
09:11:07 <RachelS> Cale: Yes, it's a fixed Set...  I'll add more constraints at some point in the future, but it could be considered a fixed set for now
09:11:11 <bartavelle> why does it whine that there is no instance of (Control.Monad.Trans.Control.MonadBaseControl IO m0) when I do withSqliteConn in a function (of type IO (xxxx)), and not in main ?
09:11:18 <Cale> RachelS: I mean, in order to form a piece of data which encodes what each of the constraints said about each piece of data.
09:11:36 <Cale> RachelS: That's another option for encoding your program.
09:11:44 <Wayne> is there some kind of haskell development environment for windows? something like eclipse
09:12:08 <Cale> Wayne: there are things, but they are all unpopular
09:12:23 <Cale> (some people seem to like them though)
09:13:03 <applicative> Wayne: if  you know eclipse maybe you can make sense of eclipsefp
09:13:20 <RachelS> Cale: Ok, that sounds interesting - and how might that piece of data look like?  How might be constraint be written in Haskell?
09:13:48 <Wayne> yea
09:13:51 <Wayne> that looks promising
09:13:52 <Wayne> thanks
09:14:46 <Cale> RachelS: it would look like a record type full of Bool values
09:16:15 <RachelS> Cale: I can imagine that record type, perhaps matching types with a boolean value - so I could have a constraint to check if a value was a String or not...  say, but, how would that help me with something more advanced, like checking if that Integer is greater than 100 ?
09:16:30 <Cale> RachelS: We're just slicing the problem the other way -- recording the product of the results of these tests ahead of time, rather than using a discriminated union of the types of values which are inputs to the tests
09:17:21 <Cale> RachelS: If you need a test which says whether an Integer was greater than 100, then you just record precisely that fact
09:17:27 <Cale> That's a Bool too
09:17:36 <yitz> bartavelle: what sql package are you using? can you paste your code?
09:17:40 <yitz> @where hpaste
09:17:40 <lambdabot> http://hpaste.org/
09:18:01 <trotro> hard to explain true functional programming, isn't it ? :D
09:18:11 <Cale> RachelS: So you're choosing up-front the set of tests that you want to perform
09:18:21 <haskellElephant> @pl (\(x,y) -> (abs x, abs y))
09:18:21 <lambdabot> abs *** abs
09:18:49 <Cale> RachelS: but extending those tests to new types of data becomes easy
09:19:16 <RachelS> Cale: Sure, ok, and that would rely on the values going in to the constraint being of an constrained type - so e.g. MyInteger, which could then be matched, and handled?
09:19:23 <Cale> (you just use different functions to produce the Boolean responses
09:19:24 <Cale> )
09:19:40 <Cale> Or just plain Integer at that point
09:19:57 * hackagebot shelly 0.14.2 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.14.2 (GregWeber)
09:20:39 <yitz> @type join (***) abs
09:20:40 <lambdabot> forall c. (Num c) => (c, c) -> (c, c)
09:22:16 <RachelS> Cale: Ok, alright - I'm feeling like I should try some of this stuff out and see how far I can get! :-)  Thanks so much for your help Cale, Philippa, ski, tdammers...  it's appreciated!
09:22:48 <Cale> RachelS: This all makes a lot more sense if you can give sensible names to the constraints
09:23:03 <Cale> RachelS: I was going to do one example which I think makes this approach clearer
09:23:26 <Cale> RachelS: Which is that if you're writing a game, and you have a bunch of sorts of object
09:23:58 <Cale> A lot of the time the first thing people will do is start by having a single datatype for all the objects in the game with lots of cases
09:24:27 <bartavelle> yitz, 2s
09:24:37 <Cale> data GameObject = Ball { position, velocity, acceleration :: Vector, radius :: Double } | Spaceship { ... } | ...
09:24:49 <Cale> and then they write functions like  draw :: GameObject -> IO ()
09:25:04 <Cale> and  stepTime :: DeltaTime -> GameObject -> GameObject
09:25:09 <Cale> etc. etc.
09:25:16 <bartavelle> yitz, http://hpaste.org/76369
09:25:30 <bartavelle> yitz, if I copy paste "getCertificate" in main it works
09:25:33 <Cale> But it's much more likely that you want to add new objects to your game than new basic ways to handle those
09:25:34 <bartavelle> this doesn't help much hum
09:25:38 <bartavelle> this is persistent.sqlite
09:25:40 <johnw`> joeyh: is there an option like what --git-dir does for git?  I.e., for some arbitrary directory, I want to run git-annex commands within another directory
09:26:01 <Cale> So another approach is to define a game object as the results of these various functions for acting on game objects:
09:26:22 <Cale> data GameObject = GO { draw :: IO (), stepTime :: DeltaTime -> GameObject, ... }
09:26:40 <Cale> and then the actual objects themselves as functions producing records of this type
09:27:01 <Cale> ball pos vel acc radius = GO { .. }
09:27:13 <Cale>   where draw = drawCircle pos radius
09:28:19 <Cale>         stepTime dt = ball ...
09:28:29 <zxspectrum> I have the Parsec grammar test = try(char '(' >> char 'a' >> char 'b') <|> (char '(' >> char '0' >> char '1')
09:28:41 <Cale> RachelS: make sense?
09:28:48 <RachelS> Cale: Right, yeah, that makes sense to me.
09:29:38 <Cale> RachelS: That latter approach, at least to me, is the heart of object oriented programming, once you remove all the extraneous stuff about inheritance and subtyping.
09:29:42 <zxspectrum> but the error messages aren't very good. for parseTest test "(ac" I get "unexpected "a", expecting "0"". is there a way to improve that other than factoring out the left paren?
09:29:51 <shachaf> Cale: Come on, what does a game really need, other than balls and spaceships?
09:29:57 <Cale> shachaf: :D
09:30:33 <quicksilver> shachaf: bacon
09:30:37 <b_jonas> Cale: but then what do you do if you want to have a function that acts on pairs of game objects? like, destroyOnCollision :: GameObject -> GameObject -> Bool;
09:30:39 <Cale> narwhals?
09:30:44 <b_jonas> shachaf: bullets and walls
09:31:02 <Cale> b_jonas: right, so a refinement of this is often more appropriate
09:31:11 <b_jonas> shachaf: but basically you're right, you only need seven kinds of game objects
09:31:30 <Cale> where instead of producing a single GameObject, you might produce a list of them
09:31:45 <RachelS> Cale: Thanks :)  Yeah, it might make more sense approaching it from this angle.  It certaintly gives me some more ideas about how I can tackle this...  unforunately I think the limiting factor currently is my comfort level with Haskell...  but I'm working on it - and now I have a range of ideas to go forward with :)
09:31:49 <Cale> and you might allow each game object to see the state of the world when it's deciding how to step forward in time
09:32:26 <quicksilver> b_jonas: GameObject a, GameObject b => destroyOnCollison :: a -> b -> Bool works fine :)
09:32:39 <quicksilver> b_jonas: I don't advocate this approach, but you certainly can make it work.
09:33:19 <b_jonas> Cale: the state of world is not what I'm interested in, but how destroyOnCollision wants to dispatch on the combination of the type of both game objects
09:33:24 <shachaf> That doesn't really give you any more ability than GameObject -> GameObject -> Bool, does it?
09:33:36 <haskellElephant> @pl (\(x,y) -> (x <= e && y <= e))
09:33:37 <lambdabot> uncurry ((. (<= e)) . (&&) . (<= e))
09:33:41 <b_jonas> Cale: so you can't just put it as a function in the function version of GameObject because it depends on the other too
09:34:19 <quicksilver> shachaf: a priori it doesn't give you anything.
09:34:25 <Cale> b_jonas: Right, it may. You might end up needing to expose more about the structure of game objects through those fields.
09:34:38 <quicksilver> shachaf: until I tell you what methods I have in 'GameObject' you can't see what choices I have for implementing it.
09:34:40 <Cale> b_jonas: for example, information about the geometry of an arbitrary game object
09:34:44 <trotro> a good game need tire race and cars only :D
09:34:48 <johnw`> shachaf: are you always in channel? :)
09:34:58 <b_jonas> oh, and there are 7 types of game objects so 49 different bodies, but most of them are constant false, which is convenient to write as an ordinary algebraic pattern match
09:35:03 <shachaf> quicksilver: Right, but you can presumably put the same methods in the data type as in the classes.
09:35:05 <johnw`> your time frame must be like 2am-12pm or something (my time)
09:35:08 <quicksilver> shachaf: however I defend that approach only out of devil's advocacy.
09:35:13 <shachaf> I guess you can't put associated types in the data type.
09:35:15 <quicksilver> shachaf: I strongly discourage it in fact.
09:36:12 <shachaf> quicksilver: Is it strictly necessary to advocate the devil when someone who's just starting to learn Haskell is in the channel?
09:36:27 <quicksilver> no.
09:36:37 <b_jonas> like, gameObject (Bullet bt _ _) (Player pt _ _ _) = ...; gameObject (Enemy _ _ _) (Player _ _ _ _) = true; gameObject (Bullet _ _ _) (Enemy et _ _) = ...; gameObject _ _ = false;
09:36:39 <quicksilver> but Cale was hilighting the type class approach for whatever reason.
09:36:43 <glguy> Is this the "right" way to write "find the index of the first element in an IntMap whose value satisfies a given predicate" using the lens package (not advocating, just learning)? \p -> headOf (indicesOf (ifiltered (const p) ifolded))
09:36:45 <shachaf> quicksilver: He was?
09:36:51 <quicksilver> and I didn't think that 'destroyOnCollision' was a valid objection.
09:36:57 <shachaf> I didn't see Cale mentioning type classes at all.
09:37:01 <Cale> I didn't say anything about type classes!
09:37:08 <b_jonas> me neither
09:37:09 <edwardk> hrmm
09:37:17 <Cale> I was advocating classical functional programming :D
09:37:29 <Cale> (which is secretly object oriented :)
09:37:29 <quicksilver> shachaf: no, he didn't.
09:37:36 <quicksilver> shachaf: I'm just blind.
09:37:46 <quicksilver> please erase me from your memories of the last 10 minutes I've been making no sense.
09:37:47 <b_jonas> maybe I need some cases for walls too though
09:37:52 <glguy> edwardk: was that hrmm for me?
09:38:01 <edwardk> glguy: yeha
09:38:01 <joeyh> johnw`: it supports GIT_DIR (and GIT_WORK_TREE)
09:38:40 <Cale> b_jonas: for deciding whether things collide or not, you're right, the game objects will need some way to express their geometry as an element of some appropriate data type
09:38:56 <edwardk> glguy: that would work. i find it pretty messy though
09:39:07 <Cale> b_jonas: and again, you'd have various options for how that data type will be constructed
09:39:08 <glguy> edwardk: Is there a non-messy way?
09:39:44 <Cale> (whether it's expressed via the result of half-plane intersection tests, or explicit cases, or what)
09:39:52 <b_jonas> Cale: it's not the genometry, the geometry is checked first and that function called only when the objects overlap. this function has to dispatch on the types of object to determine how one of the overlapping objects affects the other.
09:39:55 <edwardk> glguy: well, if you only want the index you can always just convert to itoList or something and do it the boring way off that
09:40:27 <shachaf> b_jonas: Whether to represent GameObject as Ball | SpaceShip | ... or as GameObject { draw, step, ... } is a pretty fundamental, language-independent API design decision.
09:40:42 <edwardk> its annoying that you can't use 'filtered' there
09:41:01 <Cale> Yeah, the point I'm trying to make here really has nothing special to do with games.
09:41:02 <glguy> I tried that, but I loose my indexed function
09:41:15 <Cale> It's a choice you make constantly whenever you're writing any program
09:41:20 <shachaf> Cale: Or with Haskell!
09:41:22 <Cale> in any language, mind you
09:41:34 <shachaf> Admittedly some languages make it harder to declare sum types.
09:41:40 <Cale> though many languages have only very shitty support for the first way
09:41:50 <quicksilver> and some languages make it pretty inconvenient to pass around tuples of closures.
09:41:57 <b_jonas> yeah
09:41:58 <shachaf> (And Haskell arguably makes it harder to do things the second way sometimes.)
09:42:01 <quicksilver> you could argue most languages manage to make *both* ways hard :)
09:42:16 <edwardk> l ^? indicesOf (ifiltered (const p) ifolded)
09:42:24 <joeyh> johnw`: if env vars won't do, options could be wired up. I guess it'd be easy aside from perhaps communicating the state from getopt to where it initializes the git repo. Pathes accepted :)
09:42:44 <shachaf> johnw`: Not always, just when you are.
09:42:45 <Cale> quicksilver: lol, indeed
09:42:56 <edwardk> fmap fst . ifind (const p)
09:42:57 <glguy> edwardk: My first version used ^?
09:43:06 <glguy> from the types I figured those were the same operation flipped
09:43:10 <edwardk> yeah
09:43:12 <Nafai> joeyh: How's the git-annex kickstarter work coming?
09:43:34 <edwardk> glguy: that uses http://hackage.haskell.org/packages/archive/lens/3.0.4/doc/html/Control-Lens-WithIndex.html#v:ifind
09:43:46 <edwardk> IntMap is FoldableWithIndex
09:43:50 <edwardk> so you can ifind on it
09:44:02 <glguy> that looks more direct, thanks :)
09:49:21 <zxspectrum> edwardk, why doesn't your lens library have instances for Maybe?
09:49:29 <edwardk> traverse
09:49:43 <edwardk> traverse %~ (+1) $ Just 12
09:49:56 <edwardk> no need for a custom traversal when traverse works out of the box
09:49:56 <zxspectrum> ah
09:50:58 <edwardk> traverseRight is there for Either because Either lacks a Traversable instance ;) and for symmetry with traverseLeft
09:51:20 <edwardk> the attempt to drawyour thoughts towards 'traverse' is why the traversals are mostly named traverseFoo
10:07:16 <tumdum> is this the best way to use hpc or is there already some nicer way: https://gist.github.com/1470421 ?
10:19:52 <crdueck> i'm having trouble determining if the State monad is usable in my code. I have data GameState = GS [Particle] (Map CoOrds Particle). I want to apply a function f :: Particle -> GameState -> GameState over the list of Particles in GameState that allows a particle to interact with the current GameState, possibly altering it, and then the new GameState is used when the function is applied to the next particle.
10:19:59 * hackagebot zip-archive 0.1.2.1 - Library for creating and modifying zip archives.  http://hackage.haskell.org/package/zip-archive-0.1.2.1 (JohnMacFarlane)
10:20:59 <Cale> crdueck: sure, you could write that as  Particle -> State GameState ()
10:21:16 <lispy> PatternGuards didn't make it into Haskell2010, did they? If so, was there a big reason why not?
10:21:22 <lispy> They seem pretty harmless
10:21:38 <Cale> lispy: they're in
10:21:48 <Cale> http://www.haskell.org/haskellwiki/Haskell_2010#Changes_since_Haskell_.2798
10:23:13 <Cale> It actually doesn't matter so much whether they're harmless or not. I think the Report should remain true to its name and just be a *report* about what Haskell is at the time that it's written.
10:24:25 <Cale> i.e. it should be taken as descriptive rather than as prescriptive
10:25:52 <Cale> To that end, it would be nice to have descriptions of all the language extensions that are in use.
10:26:19 <nifr> Do you see a need for a prescriptive document at all? What would it be besides the Report?
10:26:21 <Cale> and rather than trying to standardise what everyone is doing, just describe what has been done
10:26:47 <Cale> nifr: I don't, really.
10:26:59 <Cale> nifr: We don't have enough implementations of Haskell to need one.
10:27:40 <nifr> I've only seen the Report mentioned in two ways
10:27:48 <nifr> 1) hey! GHC doesn't follow the report
10:28:03 <nifr> 2) hey! the Report doesn't specify what to do
10:28:08 <Cale> :)
10:28:18 <Cale> Well, that makes me happy.
10:28:24 <nifr> and there are two kinds of people who say that: authors of papers and authors of other implementations :)
10:28:53 <nifr> (again, that's just what I've seen/heard in my experience)
10:29:04 <shachaf> Cale: I think the semantics of some of the extensions in GHC are only described in the GHC source.
10:29:18 <Cale> What bothers me is where implementations don't make changes which would be good changes because the report says to do things some other way
10:30:05 <Cale> (Where by "implementations", I really mean GHC)
10:30:54 <Cale> Some of the processes surrounding the libraries and such are glacial in making changes that everyone wants.
10:30:56 <nifr> right, that's the cost of having a "standard", but I hear there's also long term benefits to having one... my experience is just to short and I'm too myopic to recognize that benefit, I suppose
10:31:28 <Cale> heh, we finally have subsequences and permutations in Data.List, and it only took several years!
10:32:00 <lispy> Cale: hmm...Well, I'm glad to see they are in. I must not be getting Haskell2010 the way I'm building this because GHC asked me to add -XPatternGuards (I don't mind adding LANGUAGE PatternGuards, it just struck me as something that should have gone into Haskell2010 and it did!)
10:32:36 <Cale> lispy: The report describes the extensions
10:32:39 <Cale> extension*
10:32:58 <nifr> I never kept running a linux distro, but from what I recall it seems that maybe they'd have some experience on how to balance standardization versus rapid progress
10:33:20 <geekosaur> actually, most of them do poorly in that regard
10:33:29 <nifr> ha
10:33:34 <Cale> actually, hmm
10:33:43 <geekosaur> see debian stable, compare to the thrash when arch linux decided to abandon haskell-platform, etc.
10:33:43 <nifr> well "having experience" might not mean "knowing how to solve it" :/
10:33:57 <Cale> No, the report really does seem to just glom in pattern guards into the syntax of the language in an unqualified way
10:33:59 <Cale> interesting
10:34:11 <geekosaur> they're all over the map and not one of them seems to manage a decent balance :/
10:34:37 <Cale> http://www.haskell.org/onlinereport/haskell2010/haskellch12.html#x19-19100012.3
10:34:44 <Cale> well, I don't know what *that* means
10:35:02 <Cale> Those implementations are also encouraged to support the following named language features: PatternGuards, NoNPlusKPatterns, RelaxedPolyRec, EmptyDataDecls, ForeignFunctionInterface
10:35:10 <Cale> These are the named language extensions supported by some pre-Haskell 2010 implementations, that have been integrated into this report.
10:35:12 <strebe> yeah, about the best that happens with distributions is when they provide working, stable packages of most software you'd want, and you're a bit on your own for anything sufficiently cutting-edge
10:37:38 <Cale> Yeah, I'm glad that distributions all provide the stable software that I want like Gnome 2 and ALSA and not bleeding edge crap which is broken like Gnome 3 and PulseAudio. Oh wait.
10:47:23 <johnw`> joeyh: ping
10:54:59 * hackagebot enummapmap 0.1.0 - Map of maps using Enum types as keys  http://hackage.haskell.org/package/enummapmap-0.1.0 (MatthewWest)
10:59:59 * hackagebot orc 1.2.1.3 - Orchestration-style co-ordination EDSL  http://hackage.haskell.org/package/orc-1.2.1.3 (TrevorElliott)
11:00:42 <deech> Aside from OOHaskell are there any other packages for allowing open recursion in Haskell?
11:01:28 <efie> I googled that a Char is a unicode code-point, but when I parse a file which contains a dash (–) and print the parsed result, not – is displayed but the XML-numeric-number: \8211. Why and how can you fix this?
11:02:14 <fmap> > show '–'
11:02:15 <lambdabot>   "'\\8211'"
11:02:57 <geekosaur> efie, if you use "print" instead of "putStrLn" then it's going through "show" which makes special characters visible
11:03:07 <geekosaur> see what fmap did above
11:03:41 <shachaf> "XML-numeric-number" :-(
11:04:42 <shachaf> Anyway, printing it out with putStr should work. print/show isn't for printing text but for examining something (like p/#inspect in Ruby, say).
11:04:49 <hpaste> newbiee pasted “function” at http://hpaste.org/76371
11:05:40 <shachaf> newbiee: Is that homework?
11:05:48 <newbiee> no
11:05:54 <newbiee> studying for test
11:06:05 <shachaf> Ah, test-driven development.
11:07:10 <shachaf> Well, what have you tried?
11:08:44 <efie> shachaf: that's what wikipedia said.. what is the right word it?
11:08:47 <newbiee> i tried a main function that take the string and then call on the first helper function to check for Uppercase but did not know what should i do after
11:09:17 <crdueck> is it possible to have something like mplus but with different types contained in each monad? I cant think of a way to write the type signature so i dont think there is. It would be something like mplus :: Monad m => m a -> m b -> m (a or b)
11:09:44 <geekosaur> efie: usually "numeric escape sequence" or just "[numeric] escape"
11:09:52 <efie> ok
11:10:13 <geekosaur> crdueck, not without an Either in the mix somewhere
11:10:28 <tromp> :t liftM Left
11:10:30 <lambdabot> forall a1 b (m :: * -> *). (Monad m) => m a1 -> m (Either a1 b)
11:10:57 <shachaf> crdueck: A value of type "m a" isn't a monad. "m" is a monad.
11:11:16 <shachaf> Anyway, something like (Left <$> x) `mplus` (Right <$> y)?
11:11:48 <crdueck> :t \x y -> (Left <$> x) `mplus` (Right <$> y)
11:11:49 <lambdabot> forall a b (m :: * -> *). (Functor m, MonadPlus m) => m a -> m b -> m (Either a b)
11:12:19 <tromp> :t <$>
11:12:21 <lambdabot> parse error on input `<$>'
11:12:22 <shachaf> You can use liftM like tromp did if you don't want the Functor constraint.
11:13:01 <geekosaur> :t (<$>)
11:13:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:13:17 <efie> thanks, it works
11:14:06 <crdueck> :t \x y -> (liftM Left x) `mplus` (liftM Right y)
11:14:07 <lambdabot> forall a1 b (m :: * -> *). (MonadPlus m) => m a1 -> m b -> m (Either a1 b)
11:15:11 <parcs`> crdueck: is the thing Alternative?
11:15:13 <hpaste> newbiee pasted “function” at http://hpaste.org/76372
11:15:21 <parcs`> if so you can do 'Left <$> x <|> Right <$> y
11:16:21 <crdueck> parcs`: the actual monad is Maybe, I have two functions returning Maybe a and Maybe b, and if the first function returns Nothing, I want to use the result of the second function
11:17:20 <crdueck> i can do it with two case expressions, but i was looking for a cleaner way
11:20:52 <geekosaur> :t maybe (Just . Left) (fmap Right . g) f
11:20:52 <johnw`> :t (<|>)
11:20:53 <lambdabot>     Couldn't match expected type `Maybe (Either a b)'
11:20:54 <lambdabot>            against inferred type `Either a2 a1'
11:20:54 <lambdabot>       Expected type: a -> Maybe (Either a b)
11:20:54 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
11:20:58 <geekosaur> whoops
11:21:02 <johnw`> @src (<|>)
11:21:02 <lambdabot> Source not found. Wrong!  You cheating scum!
11:21:18 <johnw`> i'm not familiar with Alternative
11:21:29 <efie> @src ((<|>))
11:21:29 <lambdabot> Source not found. Just what do you think you're doing Dave?
11:21:35 <clahey> @src <|>
11:21:36 <lambdabot> Source not found. Are you on drugs?
11:21:40 <geekosaur> the @src database is highly incomplete
11:21:41 <shachaf> johnw`: It's like MonadPlus except Applicative.
11:21:44 <johnw`> ah, it's a monoid for applicatives
11:21:56 <shachaf> FSVO "monoid"...
11:21:57 <johnw`> so what <|> means depends on the Alternative
11:22:20 <johnw`> > Just 10 <|> Just 20
11:22:21 <lambdabot>   Just 10
11:22:25 <johnw`> > Nothing <|> Just 20
11:22:26 <lambdabot>   Just 20
11:22:29 <clahey> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html
11:22:33 <johnw`> ok, makes sense
11:22:51 <johnw`> i'm starting to love binary associative operations :)
11:22:55 <clahey> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Applicative.html#Alternative
11:23:05 <shachaf> johnw`: What, like .&. and .|.?
11:23:26 <johnw`> from which library?
11:23:40 <shachaf> Data.Bits
11:23:48 <johnw> then, yes!
11:24:59 <clahey> :t many Just 5 :: Maybe Int
11:25:00 <lambdabot>     Couldn't match expected type `Maybe Int'
11:25:00 <lambdabot>            against inferred type `[Maybe a]'
11:25:00 <lambdabot>     In the expression: many Just 5 :: Maybe Int
11:25:13 <clahey> :t Control.Applicative.many Just 5 :: Maybe Int
11:25:14 <lambdabot>     Couldn't match expected type `Maybe Int'
11:25:14 <lambdabot>            against inferred type `[Maybe a]'
11:25:14 <lambdabot>     In the expression: many Just 5 :: Maybe Int
11:25:23 <Botje> clahey: please don't paste to the channel like that.
11:25:34 <johnw> > many (Just 5)
11:25:38 <lambdabot>   mueval-core: Time limit exceeded
11:25:49 <johnw> huh, I guess it's not lazy?
11:25:59 <johnw> shouldn't that become an infinite list of Just 5's?
11:26:25 <parcs`> :t many
11:26:27 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
11:26:45 <johnw> oh, Just [5...]?
11:29:45 <clahey> johnw: Yeah, I think it would be Just . repeat $ 5
11:30:04 <shachaf> Why?
11:30:16 <parcs`> 'many' doesn't produce anything until it fails
11:31:22 <clahey> Which is why it never returns, but if time were infinite, it would give the same result as that.
11:31:31 <clahey> If that's even a useful thing to say.
11:32:39 <parcs`> > sequence (repeat (Just 5))
11:32:41 <lambdabot>   *Exception: stack overflow
11:33:04 <shachaf> clahey: Not really.
11:33:18 <byorgey> johnw: in some sense, many "doesn't know" that the (Just 5) will always be Just
11:33:20 <shachaf> The way we usually talk about infinite thing is to assume some arbitrarily large finite thing.
11:34:01 <johnw> where by arbitrarily large we mean infinitely large? :)
11:34:09 <clahey> shachaf: If you wrote those as mathematical equations, a reasonable match would be Just (repeat (5)) ?
11:34:35 <clahey> shachaf: I know it's not a useful thing to talk about for haskell in practice.
11:34:57 <shachaf> clahey: No, many (Just 5) = _|_
11:37:36 <tac> What's the best way to get started with LaTex?
11:40:09 <Botje> don't blindly copy-paste \usepackage things without reading what they are.
11:40:18 <clahey> /join #latex
11:40:35 <parcs`> copious amounts of google
11:40:55 <clahey> I actually started by reading the TeX book.
11:40:55 <sipa> copious amounts of 10^100 ? :o
11:40:56 <tac> all sound advice
11:41:14 <clahey> sipa: Wouldn't that be googol?
11:41:26 <sipa> ok ok...
11:41:44 <ClaudiusMaximus> i want to implement complex agm http://planetmath.org/encyclopedia/ComplexArithmeticGeometricMean.html and am wondering if there's some cute efficient trick for picking the correct square root
11:42:14 <chersanya> anyone knows, what's the reason for not including something like isLeft and isRight for Either in standard library? it would be nice, like for Maybe
11:42:33 <ezyang> I wonder how hard it would be to get invertible syntax descriptions for alex/happy
11:42:40 <ezyang> @hoogle Either a b -> Bool
11:42:40 <lambdabot> Data.Graph.Inductive.Basic hasLoop :: Graph gr => gr a b -> Bool
11:42:40 <lambdabot> Data.Graph.Inductive.Query.DFS isConnected :: Graph gr => gr a b -> Bool
11:42:40 <lambdabot> Data.Graph.Inductive.Graph isEmpty :: Graph gr => gr a b -> Bool
11:43:00 <chersanya> it was the first thing i've tried))
11:43:04 <chersanya> but there are no
11:43:21 <ezyang> @hoogle Either a b -> (a -> r) -> (b -> r) -> r
11:43:22 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
11:43:22 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
11:43:38 <shachaf> ezyang: I always think that isLeft and isRight exist and they always turn out not to.
11:43:43 <ezyang> :t either (const False) (const True)
11:43:44 <lambdabot> forall a b. Either a b -> Bool
11:43:59 <ezyang> @pl either (const False) (const True)
11:44:00 <lambdabot> either (const False) (const True)
11:44:04 <ezyang> blah :)
11:44:17 <chersanya> yes, it's easy to implement, but they are not in standard library))
11:44:25 <shachaf> @pl \k -> either (k False) (k True)
11:44:25 <lambdabot> liftM2 either ($ False) ($ True)
11:44:32 <chersanya> like isJust for maybe for example
11:44:49 <parcs`> :t null.rights.pure
11:44:50 <lambdabot> forall a a1. Either a1 a -> Bool
11:44:59 <shachaf> @ty liftM2 either False True (flip const)
11:45:00 <lambdabot>     Couldn't match expected type `m (a -> c)'
11:45:00 <lambdabot>            against inferred type `Bool'
11:45:00 <lambdabot>     In the second argument of `liftM2', namely `False'
11:45:01 <hmg> Hi guys, I am having a cabal dependency problem trying to install the criterion package. It says that it cant configure parallel-3.1.0.1 because it requires deepseq 1.1.* but I already have deepseq 1.1.0.2 installed! I have no idea how to fix it because it looks like it should be working correctly...
11:45:05 <parcs`> or maybe lefts..
11:45:23 <chersanya> parcs`: magic?)
11:45:27 <shachaf> Bah.
11:45:36 <parcs`> chersanya: no, silliness
11:45:42 <ezyang> hmg: Pastebin cabal -v output?
11:46:52 <ClaudiusMaximus> @djinn Either a b -> Bool
11:46:52 <lambdabot> f a =
11:46:52 <lambdabot>     case a of
11:46:52 <lambdabot>     Left _ -> False
11:46:52 <lambdabot>     Right _ -> True
11:47:30 <hmg> @ezyang: http://pastebin.com/BMFgGQKi
11:47:31 <lambdabot> Unknown command, try @list
11:47:34 <maukd> The paste BMFgGQKi has been copied to http://hpaste.org/76373
11:48:36 <ClaudiusMaximus> could write a package which uses th to autogenerate is* functions automagically, naming the package 'this' (if it isn't already taken)
11:49:38 <ezyang> monad-par-extras is requiring too large a version of deepseq, it seems
11:50:57 <clahey> ClaudiusMaximus: So, given a, c :: Complex, you could divide both by (a/|a|), compute the geometric mean, pick the one that has the same value for signum . imagPart
11:51:23 <clahey> Sorry, pick the one that has the same value for signum . imagPart as c / (a/|a|)
11:51:38 <clahey> And then of course multiply by a/|a| to rotate back to the correct value.
11:51:39 <hmg> ezyang: but what can I do with that? from what I gather I should unlist and try to reinstall some packages but I have no idea where to start.
11:52:49 <strebe> Cale> Yeah, I'm glad that distributions all provide the stable software that I want like Gnome 2 and ALSA and not bleeding edge crap which is broken like Gnome 3 and PulseAudio. Oh wait. <-- Indeed, Cale. I didn't say it was particularly common.
11:53:17 <clahey> ClaudiusMaximus: Actually, perhaps the sqrt function will automatically choose the right one?
11:53:22 <hiptobecubic> strebe, slackware forever!
11:53:38 <ezyang> I'd suggest reinstalling statistics to get it linked against deepseq 1.3
11:53:45 <strebe> hiptobecubic: Slackware was my second distro, and I used it for a few years, but, no. :-)
11:54:14 <ezyang> and then install parallel-3.2.0.3, so that it can link against deepseq 1.3
11:55:15 <hmg> ezyang: statistics is not installed, but my version of parallel is 3.1.0.1 http://hpaste.org/76374 I guess that means I should try to upgrade the version of the parallel package?
11:55:30 <hiptobecubic> strebe, what now?
11:55:31 <ClaudiusMaximus> clahey: the rotate and rotate back with / and * is a good plan, just to get something working, but was hoping there'd be some cuter trick with just * and +
11:55:58 <ezyang> sure, just 'cabal install parallel'
11:56:13 <clahey> ClaudiusMaximus: I don't know, but it seems like a good way to do it to me.
11:56:29 <clahey> ClaudiusMaximus: Actually, you don't need to divide by a/|a|
11:56:30 <strebe> hiptobecubic: at this point, I'm using ubuntu, though I'm not entirely thrilled with it. The package management and range of packages are the main reason, and I'm running xmonad, have gotten rid of pulseaudio, etc
11:56:34 <clahey> Just divide by a.
11:56:35 <ClaudiusMaximus> clahey: the context is using this for implementation of trigonometric functions with software floating point
11:57:20 <hmg> ezyang: looks like its working. Why are you so magical?
11:57:24 <clahey> Actually, does that mean that (sqrt(c) * a) does the right thing?
11:58:01 <clahey> No, that's wrong.  Hmm.
11:58:18 <ezyang> hmg: Experience :)
11:58:26 <hiptobecubic> strebe, that's a big jump.
11:58:31 <clahey> Maybe sqrt(c/a) * a ?
11:58:55 <hiptobecubic> strebe, I went the other way a few years ago actually. Wouldn't go back.  Anyway i'm off. ciao!
11:59:13 <ezyang> Is there a way to extract operator precedences out of a Happy file?
11:59:18 <clahey> ClaudiusMaximus: Do some testing, but I think that's what you want.
11:59:41 <ClaudiusMaximus> clahey: i don't think it'd work, consider a = 1, c = -1 - i
12:00:11 <ClaudiusMaximus> but i haven't tested which way the sqrt goes
12:00:23 <clahey> ClaudiusMaximus: That one works fine.
12:00:57 <ClaudiusMaximus> clahey: oh, so it does
12:00:57 <clahey> > sqrt ( (-1) :+ (-1) )
12:00:59 <lambdabot>   0.45508986056222733 :+ (-1.09868411346781)
12:01:26 <clahey> I'm pretty confident about this solution.  Think about it this way.
12:02:40 <clahey> Your two values are a and c, but we want to make one of them be real, so we divide both by a, run the algorithm, then multiply by a.  sqrt (c/a * a/a) * a
12:02:52 <clahey> Don't forget to special case a == 0.
12:03:12 <clahey> In the case where it's undefined, you will get a funny value.
12:03:15 <ezyang> @fixity (!)
12:03:16 <lambdabot> Unknown command, try @list
12:04:37 <clahey> That is, in the case where your mathematical definition is undefined, you'll get a different answer depending on the order of your operands.
12:05:30 <ClaudiusMaximus> yep, running some tests...
12:07:37 <hpaste> Weasel pasted “list” at http://hpaste.org/76376
12:15:39 <ClaudiusMaximus> clahey: my testing shows that almost always  sqrt (b / a) * a `approxEq` sqrt (a / b) * b    -- rounding errors prevent use of ==
12:16:37 <ClaudiusMaximus> clahey: not yet checked that it's the right root, maybe a symmetry / continuity argument applies (ie, if it is ok for one point, it must be ok for all)
12:17:37 <ClaudiusMaximus> clahey: thanks
12:35:30 <pooya72> Hello Everybody!
12:35:47 <shachaf> hi pooya72
12:36:05 <pooya72> hi shachaf
12:36:40 <pooya72> so has anyone here played around with rust? http://www.rust-lang.org/ It seems quite haskellish
12:37:20 <ion> It’s pure?
12:37:33 <MostAwesomeDude> I'm not yet convinced that Rust is robust enough for serious work, but it could grow into something cool.
12:39:01 <clahey> The example on the front page has rand with no explicit context, so I'm guessing it's not totally pure.
12:39:11 <pooya72> no it's not totally pure
12:39:20 <clahey> Although that is inside a do, so maybe I'm wrong.
12:39:26 <pooya72> put it has purity: http://smallcultfollowing.com/babysteps/blog/2012/10/12/extending-the-definition-of-purity-in-rust/
12:39:46 <pooya72> MostAwesomeDude: it's still in alpha but it looks interesting
12:39:55 <pooya72> just wondering how people compared it haskell
12:40:02 <pooya72> like what rust took away from it
12:40:18 <Ralith> well-intentioned, not really attractive compared to real haskell
12:44:11 <pooya72> it was interesting that since I learned a little haskell it made learning rust a lot easier.
12:56:12 <parcs`> MostAwesomeDude: rust is written in rust, so there's that
12:57:04 <MostAwesomeDude> parcs`: Sure.
13:03:06 <ezyang> Anyone know if anyone's extracted the layout sensitive bits from the Haskell Alex definition and packaged them up nicely for other lexers to use?
13:20:43 <ski> pooya72 : interesting ..
13:21:05 <pooya72> ski: rust?
13:21:25 <ski> yes
13:22:43 <ski> i'm not sure i like that they call it "purity", but the concept they're trying to capture seems interesting
13:23:24 <pooya72> ski: yeah.
13:23:45 <ski> i wonder if only parameters (and presumably local variables) can be declared `&mut', or also components of structures
13:26:14 <pooya72> ski: that's an interesting question. only one way to find out ;)
13:26:28 <pooya72> ski: it took over an hour to have it compile
13:30:48 <Dawnywing> hello
13:31:14 <Dawnywing> anyone here active?
13:31:39 <simon> hi.
13:31:57 <clahey> Dawnywing: No one had spoken for like 5 minutes before you came in.
13:32:07 <clahey> So comparatively, the channel was dead.
13:32:07 <Dawnywing> aww
13:32:24 <clahey> Dawnywing: What's up?
13:32:28 <Dawnywing> so is this chat channel for educational purposes?
13:32:49 <Philippa> amongst others, though we tend not to do people's homework for them
13:32:55 <maukd> I only use it for recreational purposes, I swear
13:33:09 <Dawnywing> i am currently studying at university and got stuck on a couple of things
13:33:10 <Boreeas> I'm only here for the bots
13:33:26 <Dawnywing> It isn't really for homework, just trying to figure out how to fix some issues
13:33:37 <astor> I think it is used as a tool to get quoted by Haskell Weekly News.  That's why I'm here.
13:34:04 <Philippa> Dawnywing: sure. What's catching you out?
13:34:51 <Dawnywing> I have to convert hex values (in Char type) to int
13:35:16 <maukd> what do you mean by "hex value?
13:35:27 <Dawnywing> counting from 0 to F
13:35:34 <maukd> what
13:35:48 <maukd> :t digitToInt
13:35:49 <lambdabot> Char -> Int
13:35:58 <Dawnywing> so for example toHex 'F' and that it will return 15
13:36:26 <maukd> > digitToInt 'F'
13:36:27 <lambdabot>   15
13:36:38 <Philippa> > digitToInt 'G'
13:36:40 <lambdabot>   *Exception: Char.digitToInt: not a digit 'G'
13:36:43 <clahey> It's in Data.Char if I remember correctly.
13:36:43 <Dawnywing> I zipped [0..9] with ['0'..'9'] ++ zip [10..] ['A'..'F']
13:37:01 <Philippa> so I'm pretty sure Dawnywing is supposed to write the function from scratch, not RTFM for how to do it
13:37:05 <ivanm> @hoogle Char -> Int
13:37:05 <lambdabot> Data.Char digitToInt :: Char -> Int
13:37:05 <lambdabot> Data.Char ord :: Char -> Int
13:37:05 <lambdabot> Graphics.UI.GLUT.Callbacks.Window Char :: Char -> Key
13:37:09 <Dawnywing> wait, I'll show what I did
13:37:18 <Dawnywing> f ch = head [ a | (a,b) <- (zip [0..9] ['0'..'9'] ++ zip [10..] ['A'..'F']) , isDigit ch || isAlpha ch, b == toUpper(ch) ]
13:37:52 <Philippa> Dawnywing: which libraries are you allowed to use? Prelude only? Some subset that you've been taught in class?
13:37:57 <Dawnywing> But I believe using head in order to take out a from the list and such isn't really right
13:38:23 <Dawnywing> It says I don't really have to worry about the libraries, but..
13:38:36 <Dawnywing> It is about learning several more basic functions such as zipping and learning the syntax
13:38:53 <Dawnywing> So I doubt using some simple function from a library will teach me anything much
13:39:02 <Philippa> *nod*. So the 17-case pattern match is out
13:39:21 <Dawnywing> To answer the question, I am using Data.Char, Data.List and Test.QuickCheck
13:39:29 <clahey> Dawnywing: Does the code you wrote work?
13:39:53 <Dawnywing> yes, partially
13:39:58 <Dawnywing> it works for any valid input
13:40:16 <Dawnywing> however if I give something like.. f '!' it will throw an error
13:40:26 <Philippa> sure. What type is the function supposed to have?
13:40:31 <Dawnywing> and I want to be able to determine what to do with it myself
13:40:44 <Philippa> have you been introduced to the Maybe type?
13:40:44 <Dawnywing> Char input, Int output
13:40:51 <Philippa> right, in that case you're SOL
13:41:00 <Dawnywing> No, I never heard of the Maybe type yet
13:41:20 <Philippa> or at least, stuck pissing about using negative Int values as error codes: wouldn't bother unless you've been told to
13:42:06 <Dawnywing> Well, the thing is that I have to build another function on top of this one
13:42:59 <Dawnywing> But I cannot work with it if the first function already gives an error rather than deleting the wrong input
13:43:29 <clahey> Dawnywing: Is there a function that will tell you whether your function will work?
13:43:36 <Philippa> you can if you also have an "isHexDigit" function
13:44:09 <Dawnywing> Not that I'm aware of
13:44:54 <Dawnywing> The function I have to build the first one on is the following:
13:44:55 <clahey> Dawnywing: Could you write one?
13:45:16 <Dawnywing> umm, write a function to test if mine works?
13:45:43 <clahey> Yeah, a function Char -> Bool that tells whether your function will error out.
13:45:54 <Dawnywing> The only way I could think of would be writing a recursive version and using quickcheck to test whether both give the same results
13:46:11 <Dawnywing> But in that case I'd have to figure out how to write it recursively also, and I might make the same mistakes
13:46:26 <clahey> Not to test if yours works.  Just to tell whether the input is valid.
13:47:19 <Dawnywing> I would say the input is valid as long as it is a character 0 to 9 or A to F (caps or not doesn't matter since I use toUpper)
13:48:05 <clahey> Dawnywing: Right.
13:48:20 <Kyraimion> > flip lookup (zip (['0' .. '9'] ++ ['a' .. 'f']) [0..]) 'f'
13:48:22 <lambdabot>   Just 15
13:48:31 <Nisstyre> Dawnywing: have you considered using a smart type constructor of some kind?
13:48:32 <Dawnywing> What I tried was in the next function testing whether the function returns an int between 0 and 15
13:48:43 <Nisstyre> *smart data constructor
13:48:59 <clahey> Dawnywing: What happens if you check whether the input is valid before calling the main function?
13:49:26 <Dawnywing> I don't know about smart type constructors
13:49:32 <Nisstyre> Dawnywing: http://www.haskell.org/haskellwiki/Smart_constructors
13:50:02 <Nisstyre> Dawnywing: I misspoke, they're not technically type constructors
13:50:04 * hackagebot git-annex 3.20121016 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20121016 (JoeyHess)
13:50:29 <Dawnywing> and how can I check the input before calling the main function btw?
13:50:55 <Dawnywing> And thank you for the link Nisstyre
13:51:01 <clahey> Dawnywing: Are you familiar with if?
13:51:07 <Dawnywing> if statements?
13:51:28 <Kyraimion> Dawnywing:  In haskell they are expressions
13:51:47 <Dawnywing> Yeah, I am very confused about these here because I'm used to object oriented programming
13:51:54 <Nisstyre> Dawnywing: if you make your type into a union type of each possible character (yes I know that would be large) then you can statically ensure it will be valid input
13:52:55 <Kyraimion> Dawnywing:  "if a then b else c" would be "a ? b : c" in C/C++
13:53:03 <Dawnywing> But I want any input other than '0' to '9' and 'A' to 'F' to be seen as invalid and be ignored
13:53:03 <shachaf> IsChar is the best type class.
13:53:19 <Nisstyre> Dawnywing: you will know at compile time whether that input is even possible
13:53:39 <Nisstyre> using the method outlined here: http://www.haskell.org/haskellwiki/Smart_constructors#Enforcing_the_constraint_statically
13:53:45 <Nisstyre> except not peano numbers
13:53:53 <Nisstyre> well, maybe for the number portion of your input
13:53:54 <gfredericks> given that monads are so useful, it must be common to want to use two or more at the same time? what's the approach there?
13:54:11 <Dawnywing> Mmm..
13:54:20 <Kyraimion> gfredericks:  Monad transformers
13:54:30 <shachaf> gfredericks: The answer you'll get is "monad transformers", and sometimes it's even the right answer, but not always.
13:54:37 <Dawnywing> Is it possible to kick error inputs in the next function instead also?
13:54:41 <gfredericks> at least now I have something to google!
13:54:51 <gfredericks> Kyraimion: shachaf: thanks
13:55:06 <Dawnywing> function 1: transform Char into Int (hex character into its integer value)
13:55:16 <Nisstyre> Dawnywing: in general, you want to stop thinking about "how can I fail gracefully?" and more about "how can I ensure an error will never occur at all?"
13:55:17 <copumpkin> > ord 't'
13:55:18 <lambdabot>   116
13:55:28 <Nisstyre> Dawnywing: although there are situations where it's unavoidable that errors might occur
13:55:28 <shachaf> > digitToInt 'a'
13:55:30 <lambdabot>   10
13:55:52 <Dawnywing> function 2: get a string input, ignore the random characters and return the value of the highest valued hex character
13:55:55 <SegFaultAX|work> How long does it usually take to get accepted into the Bay Area Haskell group?
13:56:07 <copumpkin> > isDigit 'a'
13:56:08 <lambdabot>   False
13:56:12 <shachaf> SegFaultAX|work: Until Ivan sees your email.
13:56:29 <copumpkin> > digitToInt 'q'
13:56:30 <lambdabot>   *Exception: Char.digitToInt: not a digit 'q'
13:56:36 <shachaf> SegFaultAX|work: If you want to make sure to register for the Thu meeting, you can probably email Satnam directly.
13:56:36 * copumpkin slaps digitToInt
13:56:39 <SegFaultAX|work> shachaf: Hmm, well I want to register for the talk on Thursday.
13:56:50 * shachaf .psychic.moed
13:56:53 <Nisstyre> Dawnywing: also why not just make your function be "f :: String -> Maybe Hex" ?
13:56:58 <SegFaultAX|work> shachaf: Well played.
13:57:05 <copumpkin> :t spoon
13:57:06 <lambdabot> Not in scope: `spoon'
13:57:10 <copumpkin> Cale: can we haz spoon?
13:57:26 <copumpkin> then it becomes trivial
13:57:32 <Dawnywing> Let me try that Nisstyre
13:57:34 <shachaf> spoon makes everything trivial.
13:57:37 <shachaf> Like the halting problem.
13:57:52 <copumpkin> :t max . mapMaybes (?spoon . digitToInt)
13:57:53 <lambdabot> Not in scope: `mapMaybes'
13:57:57 <copumpkin> :t max . mapMaybe (?spoon . digitToInt)
13:57:58 <lambdabot> forall b. (Ord b, ?spoon::Int -> Maybe b) => [Char] -> [b] -> [b]
13:58:08 <copumpkin> hmm
13:58:11 <Dawnywing> Oh wait, no that's not what I need though
13:58:16 <Nisstyre> Dawnywing: you can do that, or you can use the fancy type class method outlined in that link I gave you
13:58:23 <copumpkin> :t maximum . mapMaybe (?spoon . digitToInt)
13:58:24 <Cale> errr
13:58:24 <lambdabot> forall a. (Ord a, ?spoon::Int -> Maybe a) => [Char] -> a
13:58:26 <copumpkin> there we go
13:58:32 <Cale> y u no just check?
13:58:35 <shachaf> copumpkin: 15
13:58:49 <copumpkin> Cale: because there isn't a corresponding check function?
13:58:52 <copumpkin> as far as I know?
13:58:58 <Cale> Yeah, but it's easy enough...
13:59:00 <Dawnywing> eg function "a2cz!" = 12
13:59:11 <copumpkin> Cale: why duplicate the effort when it's cleaner with spoon? :P
13:59:18 <strebe> Is there a simple way to query something (cabal? hoogle?) for a package and find a list of packages that depend on it? It would be nifty for getting an idea of how widely used different packages to do similar things are, and to see examples of their use
13:59:20 <shachaf> "cleaner with spoon"
13:59:21 <Dawnywing> so checks the maximum of the existing hex values in the string
13:59:38 <Dawnywing> which is c, and the value of c in Int is 12
13:59:41 <copumpkin> spoon is clearly always the right answer
13:59:48 <copumpkin> Dawnywing: my code does that
13:59:49 <shachaf> @ty digitToInt . maximum . filter (`elem` "0123456789abcdefABCDEF")
13:59:50 <lambdabot> [Char] -> Int
13:59:52 <Cale> strebe: I've heard noise about doing that for some time now
13:59:56 * copumpkin slaps shachaf 
13:59:57 <copumpkin> that's ugly
14:00:04 <shachaf> Spoon's ugly.
14:00:16 <copumpkin> nope
14:00:16 <shachaf> The halting problem's ugly. :-(
14:00:20 <strebe> Cale: cool, what do people tend to talk about implementing it on?
14:00:25 <copumpkin> it isn't trying to solve the halting problem
14:00:30 <shachaf> I know.
14:00:30 <Cale> strebe: There was even at one point an implementation of reverse dependency lookup, but it was separate from the main hackage, and I don't recall where it was.
14:00:43 <shachaf> That's the problem!
14:00:46 <Cale> strebe: But it should eventually hopefully be part of hackage
14:00:54 <copumpkin> Cale: so no spoon in lambdabot? no namespace clashes :(
14:00:55 <Kyraimion> strebe:  http://packdeps.haskellers.com/reverse
14:00:58 <copumpkin> it's cute!
14:01:04 <strebe> Cale, Kyraimion: thank you
14:01:50 <Dawnywing> uff this is one tricky programming language
14:02:05 <Dawnywing> copumpkin you mean this code? :t maximum . mapMaybe (?spoon . digitToInt)
14:02:16 <copumpkin> Dawnywing: yep :P
14:02:20 <shachaf> I *think* copumpkin is joking.
14:02:23 <copumpkin> no
14:02:23 <Cale> Dawnywing: I'm not sure if copumpkin is serious
14:02:25 <copumpkin> it's correct
14:02:27 <Kyraimion> copumpkin:  Using a spoon to unwrap the burrito?
14:02:30 <shachaf> I didn't say it wasn't correct.
14:02:32 <copumpkin> I'm not joking
14:02:37 <Cale> :S
14:02:39 <copumpkin> spoon is designed to work around shitty APIs
14:02:43 <copumpkin> like digitToInt
14:02:45 <shachaf> Kyraimion: Please don't talk about burritos in here. It's off-topic.
14:02:52 <copumpkin> that's why we made it
14:02:58 <copumpkin> to work around shitty things that throw exceptions
14:03:07 <copumpkin> but the std lib is full of such things
14:03:29 <Cale> What is Dawnywing's actual goal here?
14:03:34 <copumpkin> beats me :)
14:03:41 <Dawnywing> Parse error: naked expression at top level
14:03:41 <Cale> I think it would be good to know
14:03:43 <shachaf> Where did this maximum thing come from?
14:03:48 <merijn> copumpkin: Wait, spoon is essentially a  headToSafeHead transformer? :)
14:03:50 <Dawnywing> i dont like errors, but this one sounds interesting
14:03:53 <copumpkin> merijn: yeah
14:03:57 <merijn> copumpkin: <3
14:03:59 <Cale> because if the goal is "parse a hexadecimal number as a string"
14:04:11 <Cale> then using spoon is totally unnecessary
14:04:14 <copumpkin> Cale doesn't like my package :(
14:04:16 * copumpkin sobs in the corner
14:04:21 <shachaf> copumpkin: teaspoon is probably what should be used here?
14:04:24 <shachaf> NFData is evil.
14:04:24 <merijn> Why did I not know about Control.Spoon before?
14:04:32 <copumpkin> shachaf: they're more or less the same here, but sure
14:05:02 <Cale> copumpkin: YOU SIT THERE AND THINK ABOUT HOW YOU BROKE THE SEMANTICS BY WRITING DISCONTINUOUS FUNCTIONS
14:05:03 <shachaf> Spontrol.Coonerism
14:05:18 * copumpkin sobs loudly
14:05:38 <merijn> Cale: What's that even mean? >.>
14:05:38 <shachaf> What makes a functio continuous?
14:05:41 <copumpkin> clearly the definition of spoon is just spoon = Just
14:05:45 <copumpkin> :D
14:05:48 <Cale> hahaha
14:05:54 <merijn> shachaf: *not understanding high five*
14:06:00 <copumpkin> I should make a compiler flag that lets you pick safeSpoon
14:06:11 <copumpkin> spoon :: NFData a => a -> Maybe a
14:06:14 <copumpkin> teaspoon :: a -> Maybe a
14:06:45 <merijn> Cale: in all seriousness, what makes a function continuous?
14:06:53 <jfischoff> distributed spoon == spork?
14:06:59 <Cale> shachaf, merijn: do you know about the definedness ordering?
14:07:03 <shachaf> Yes.
14:07:16 <merijn> No
14:07:21 <merijn> Or maybe?
14:07:24 <copumpkin> it's not a very exciting ordering, in the grand scheme of things
14:07:29 <copumpkin> _|_ is the least defined value
14:07:46 <copumpkin> everything else is equally defined, isn't it?
14:07:50 <copumpkin> well
14:07:53 <copumpkin> they aren't comparable?
14:08:05 <shachaf> Everything else?
14:08:11 <Cale> Okay, so x is less defined than or equal to y (which I'll write x <= y, but it is usually written with a "squarer" sign) if you can replace some occurrences of _|_ in x with values and obtain y
14:08:16 <shachaf> Maybe we're thinking of different orderings.
14:08:17 <companion_cube> is id the most defined value?
14:08:31 <Cale> (perhaps including _|_ itself)
14:08:33 <Kyraimion> copumpkin:  Isn't _|_ < (_|_,_|_) < (0,0)
14:08:45 <Cale> yes
14:09:07 <Cale> _|_ <= (_|_,_|_) <= (0,_|_) <= (0,0)
14:09:09 <merijn> Right
14:09:24 <copumpkin> but (_|_, 0) and (0, _|_) aren't comparable?
14:09:31 <Cale> okay, so normally, every function you can define in Haskell has the property that it preserves this ordering
14:09:33 <shachaf> Yes, it's a partial ordering.
14:09:34 <Cale> right
14:09:55 <shachaf> Why is it called "continuous"?
14:10:06 <Cale> (_|_,0) and (0,_|_) aren't comparable, but they have a common upper bound
14:10:21 <Cale> Well, not only that
14:10:28 <Kyraimion> shachaf:  A function f is continuous iff for all x, y; x < y ==> f(x) < f(y)
14:10:31 <ion> Huh. http://hackage.haskell.org/packages/archive/base/latest/doc/html/GHC-Exts.html#v:inline
14:10:50 <merijn> Pffft, continuity is overrated
14:11:06 <merijn> Don't catch et al. break continuity then too?
14:11:07 <hpc> just ask the writers of doctor who
14:11:08 <copumpkin> Kyraimion: so continuous = monotonic?
14:11:15 <hpc> who needs continuity!
14:11:41 <shachaf> I would think of that as "monotonic", yes.
14:11:44 <hpc> merijn: exception handling doesn't break continuity if the exception is thrown and caught in IO
14:11:49 <Cale> A function which preserves the ordering is called monotone, but we also need to know that it preserves all least upper bounds
14:11:52 <ion> When should one use inline instead of the INLINE pragma?
14:11:56 <hpc> (i don't know enough to expand that assertion further)
14:11:58 <Cale> and such a function is called continuous
14:12:18 <copumpkin> Cale: so monotone and lub-preserving = continuous?
14:12:24 <Cale> yeah
14:12:33 <copumpkin> how does this fit with other definitions of continuity?
14:12:59 <Cale> sorry, maybe that should be directed least upper bounds
14:13:06 <Reflector666> hello everybody
14:13:08 <copumpkin> this sounds like a (co)product-preserving functor of some sort
14:13:13 <Reflector666> how are you doing?
14:13:19 <Cale> copumpkin: well, that's a property of normal continuous functions as well
14:13:37 <copumpkin> normal continuous functions aren't monotone are they? except on a small scale?
14:13:38 <Cale> (though it's not sufficient to say that a function is continuous in the ordinary sense)
14:13:39 <shachaf> There should be a sticker than says "I lub partial orderings"
14:13:53 <hpaste> newbiee pasted “function” at http://hpaste.org/76380
14:14:34 <Saizan> from a topology you can derive an order i think? and topologically continuous functions are monotone for that order?
14:14:50 <hpaste> Cale annotated “function” with “function (annotation)” at http://hpaste.org/76380#a76381
14:15:06 <ivanm> shachaf: as in finding the least upper bound? :p
14:15:26 <Cale> copumpkin: well, right
14:15:31 <glguy> Cale: sometimes it's good to be absolutely sure :)
14:15:44 * merijn is sad
14:15:55 <Cale> Here's another sense then...
14:15:56 <copumpkin> the spoon is a lie
14:15:57 <merijn> "if p then True else False" in that paste just now :(
14:16:11 <shachaf> merijn: Should be "if p == True then True else False"
14:16:38 <Cale> if not (p == True) then False else True
14:16:42 <copumpkin> if (if p == True then True else False) then True else False
14:16:43 <maukd> if (p == True) == False then False else not False
14:16:50 <hpaste> newbiee pasted “function” at http://hpaste.org/76383
14:16:50 <ivanm> merijn: you mean the one by Cale? :o
14:16:59 <glguy> Cale: maybe he's using rebindable syntax?
14:17:02 <Cale> ivanm: I pasted the reply
14:17:11 <merijn> ivanm: No, by newbiee whoever that is
14:17:27 <ivanm> oh, Cale was just pointing that out
14:17:37 <Cale> newbiee: oh, you're here now
14:17:40 <Nisstyre> newsham: use a case expression
14:17:45 <newbiee> cale: sorry i got disc
14:17:53 <Cale> newbiee: We already responded to your paste :)
14:17:54 <newbiee> cale: can you repost?
14:18:00 <Cale> http://hpaste.org/76380
14:18:01 <Nisstyre> oops, newbiee
14:18:06 <Nisstyre> newbiee: or use pattern matching
14:18:13 <Nisstyre> (without using case)
14:18:17 <hpaste> merijn annotated “function” with “function (annotation)” at http://hpaste.org/76383#a76384
14:18:37 <ivanm> what's checkLower
14:18:39 <ivanm> ?
14:18:41 <parcs`> that's not true
14:18:49 <newbiee> it's a helper function
14:19:11 <parcs`> if RebindableSyntax is enabled then if foo then True else False is not necessarily foo
14:19:14 <ivanm> @type liftM2 (||) null (("true"==) . map toLower) -- does this do what newbiee wants?
14:19:15 <lambdabot> [Char] -> Bool
14:19:15 <merijn> newbiee: Hard to simplify without seeing what it does
14:19:19 <Cale> newbiee: Well, we know that it's a function and that it's maybe helping ;)
14:19:26 <Nisstyre> newbiee: you don't need to explicitly return a boolean type there
14:19:34 <Nisstyre> newbiee: since (==) already does
14:19:36 <merijn> parcs`: If you know how to do that you probably aren't asking these questions :p
14:19:47 <newbiee> oh ok let me repost with the other helper functions
14:19:51 <parcs`> merijn: yeah, i probably shouldn't have mentioned that. meh
14:20:38 <ski> "Show reverse dependencies" <http://hackage.haskell.org/trac/hackage/ticket/576>
14:22:14 <hpaste> newbiee pasted “function” at http://hpaste.org/76385
14:22:24 * shachaf . o O ( why didn't ski . o O ( ) that? )
14:23:04 <maukd> data Wtf = Nothing | Just "True"
14:23:06 <ivanm> newbiee: why do you bother with the Maybe part of checkLower and checkIfDigit ?
14:23:07 <hpc> . o O ( why didn't ski . o O ( ) that? ) O o . <shachaf>
14:23:25 <ivanm> maukd: heh
14:23:38 <ivanm> and using head and tail there is bad; pattern match!
14:23:48 <efie> I am trying to use the state monad (first time :o) and I get: No instance for (MonadState [((Int, Int), Int)] (state Table))
14:23:48 <efie> -- arising from a use of `state' when I do this: http://hpaste.org/76386
14:23:54 <ivanm> so it looks like you're wanting to return a Bool from checkLower and checkDigit anyway
14:24:08 <ivanm> and you're alternating checking isLower with isDigit
14:24:11 <newbiee> ivanm can you post a version with pattern match?
14:24:22 <ski> shachaf : heh, i suppose i might as well have. originally i had the other link in there as well, and some english words connecting them
14:24:33 <maukd> checkIfDigit = all isDigit; checkIfLower = all isLower
14:24:50 <ivanm> newbiee: checkLower (Just ls@(l:ls')) = if isLower l then checkLower (Just ls') else checkIfDigit (Just ls)
14:24:57 <Cale> newbiee: are you trying to check if a string consists of lowercase letters followed optionally by digits?
14:24:58 <maukd> chkStr s = checkIfLower s || checkIfDigit s
14:25:01 <shachaf> ski: It's just what I've come to expect.
14:25:03 <ivanm> maukd: no, that's not quite true going by what it does
14:25:09 <newbiee> yes
14:25:11 <maukd> ivanm: yes, but it's all misnamed
14:25:24 <ivanm> yeah
14:25:36 <ivanm> Cale: ahhh, so _that's_ what it's doing!
14:25:49 <ivanm> @type all isDigit . dropWhile isLower
14:25:50 <lambdabot> [Char] -> Bool
14:26:00 <glguy> null . dropWhile isDigit . dropWhile isUpper
14:26:20 <ivanm> glguy: how is that any better than using all?
14:26:23 <glguy> it's not
14:26:26 <ivanm> if you really want to use Maybe, then just fmap that
14:26:29 <ivanm> oh, good :)
14:26:31 <glguy> I was writing it before I read yours, not correcting you
14:26:42 <Cale> Okay, so that's the completely competent way to write the function
14:26:55 <Cale> We can also do it recursively in a much simpler way
14:26:57 <ski> newbiee : perhaps you could *annotate* your original paste with updates (using the fine "Annotate" button at the top), instead of creating new pastes ?
14:27:13 <ivanm> I'm still not sure why the Maybe bit is there
14:27:27 <newbiee> ski: okie, new at this
14:27:32 <ivanm> unless those functions are used elsewhere
14:27:39 <newbiee> ivanm: error checking?
14:27:48 <Reflector666> hey guys. I wanted to ask.. Is it better to start learning programming from SICP of from some imperative lang like C#?
14:27:56 <ivanm> checkLower [] = True; checkLower (l:ls) | isLower ls = checkLower ls; | otherwise = checkIfDigit (l:ls)
14:28:04 <Reflector666> i had heard than shoult start from SICP
14:28:13 <ivanm> newbiee: error checking from what?  Especially when you're feeding in a Maybe
14:28:15 <ski> newbiee : no worry
14:28:19 <shachaf> Reflector666: Why are you asking in here? Neitehr of those has to do with Haskell. :-)
14:28:32 <Philippa> Reflector666: SICP will be easier if you try it first, but it depends partly on how quickly you need to do "real stuff"
14:28:39 <Philippa> you want to have encountered both
14:28:46 <ivanm> Reflector666: can you clarify your question?  do you mean use SICP but with C# instead of Scheme?
14:28:51 <Reflector666> just interesting you meaning..if you do not mind
14:28:57 <shachaf> Both structure *and* interpretation.
14:29:02 <ivanm> if so, I'm not sure how well that would work
14:29:44 <ivanm> newbiee: note that you're using Nothing and (Just "True") as your only outputs from your check* functions; as such you should probably use Bool
14:29:45 <newbiee> cale: when i dropped the "then True else false" from what you suggest, it gave me error .... if b then True else False is same as b
14:29:45 <Dawnywing> isHex x = '0' <= x && x <= '9' || 'a' <= x && x <= 'f' || 'A' <= x && x <= 'F' works! :)
14:30:18 <Cale> newbiee: oh?
14:30:18 <newbiee> ivanm I know just want to see other way of doing it
14:30:23 <Reflector666> i mean just start learning programming..without any big experience in it... should it better made with SICP course or with some serial book about something like C Sharp or C++
14:30:24 <Cale> newbiee: What error?
14:30:37 <ivanm> newbiee: well, I did up an alternate checkLower function above
14:30:48 <newbiee> cale: Syntax error in expression (unexpected symbol "checkLower")
14:30:53 <ivanm> and glguy and I both did functions that combine checkLower and checkDigit
14:31:05 <Cale> Reflector666: There are many worse choices for a place to start learning to write programs than SICP, let's put it that way.
14:31:21 * ivanm agrees with Cale 
14:31:35 <Nisstyre> Reflector666: I really really like "How to Design Programs", it uses DrRacket to teach Scheme
14:31:44 <Nisstyre> http://htdp.org
14:31:50 <ivanm> SICP does rather well on focusing on teaching you _programming_ rather than "programming with <language>" like most books do
14:31:54 <Nisstyre> that book should be used for all intro CS courses
14:32:07 <ivanm> since you can get over the syntax of scheme faster (which is why it was chosen IIUC)
14:32:08 <shachaf> Like SIKP, the cheap knockoff book that uses the less-known programming language "skeem".
14:32:09 <Cale> newbiee: What do you have there?
14:32:15 <ivanm> shachaf: heh
14:32:21 <Nisstyre> ivanm: yes, but it is not suitable for people with no math background
14:32:26 <Cale> newbiee: did you paste your new code?
14:32:28 <ivanm> @remember shachaf SIKP, the cheap knockoff book that uses the less-known programming language "skeem"
14:32:28 <lambdabot> I will never forget.
14:32:30 <ivanm> Nisstyre: how so?
14:32:47 <Nisstyre> ivanm: it assumes you know integral calculus I thijnk
14:32:49 <Nisstyre> *think
14:32:54 <ivanm> Nisstyre: I found high school level math much more than sufficient for SICP
14:32:58 <Reflector666> yes i heard than HTDP asd SICP is the best choise for beginners. but isn't it explaing on hard math examples?
14:33:03 <ivanm> sure, but you do need to know math for programming
14:33:09 <newbiee> yeah
14:33:20 <Nisstyre> ivanm: yeah, but kids should be getting taught CS at an early age
14:33:30 <ivanm> Reflector666: from what I've seen, programming books come in three flavours: teach via math, teach via textual examples, teach via the ridiculous (e.g. LYAH)
14:33:30 <Nisstyre> so obviously some other book has to fill that gap
14:33:35 <hpaste> ski annotated “function” with “pattern-matching” at http://hpaste.org/76385#a76387
14:33:43 <Cale> Reflector666: If the math in those books puts you off, then you're probably going to hate programming anyway.
14:33:59 <ivanm> Nisstyre: I dunno about that, but SICP is aimed more at uni level, I'll agree on that
14:34:00 <Nisstyre> ivanm: I guess I would say "use SICP" for undergrads in a CS program, for everyone else (kids, people who just want to learn about programming) use HtDP
14:34:06 <ski> newbiee : ^ there is shown how to use pattern-matching instead of `head' and `tail'
14:34:15 <hpaste> newbiee pasted “function” at http://hpaste.org/76388
14:34:17 <Reflector666> no no..I'm ok with math..I love it) just interesting
14:34:33 <Cale> newbiee: you left in the if
14:35:02 <Reflector666> sorry..what is "CS programms"
14:35:05 <Reflector666> ?
14:35:05 * hackagebot hackport 0.3 - Hackage and Portage integration tool  http://hackage.haskell.org/package/hackport-0.3 (SergeiTrofimovich)
14:35:13 <Nisstyre> ivanm: BTW, the university I go to offers an undergrad intro course that uses Haskell
14:35:16 <newbiee> cale: silly me... you're right
14:35:26 <Philippa> shachaf: what does the P combinator do?
14:35:30 <Nisstyre> the professor told me that it actually works pretty well
14:35:35 <hpaste> Cale annotated “function” with “function” at http://hpaste.org/76385#a76389
14:36:00 <glguy> isDigit x && allDigits xs
14:36:10 <Reflector666> i mean what does it mean.."CS"
14:36:14 <Nisstyre> Reflector666: people who plan on going to school for computer science
14:36:18 <shachaf> Philippa: P?
14:36:19 <Reflector666> oooh god
14:36:20 <Cale> right, I could have done that as well
14:36:20 <Nisstyre> it's short for computer science
14:36:21 <newbiee> cale: is there a different way to write the helper function and still maintain the same type?
14:36:21 <Reflector666> ))
14:36:25 <shachaf> Oh, as in SIKP. Ask skip.
14:36:30 <Reflector666> computer science i guess
14:36:33 <Reflector666> ))
14:36:43 <Cale> newbiee: the type of the helper function makes things needlessly difficult
14:36:50 <hpaste> ski annotated “function” with “alternative, using guards instead of `if'-`then'-`else'” at http://hpaste.org/76385#a76390
14:36:55 <Philippa> Cale: so accessibility varies re maths. You don't necessarily have to be what most people think of as 'good at maths' to enjoy programming
14:36:57 <hpaste> Cale annotated “function” with “function (annotation)” at http://hpaste.org/76385#a76391
14:37:00 <ski> newbiee : and that's using guards instead, if you prefer them
14:37:15 <Reflector666> guys thanx for answers
14:37:16 <newbiee> ski: how would that look?
14:37:17 <Philippa> (so much is bogged down in 'syntactic' issues! But there's more than one approach)
14:37:36 <ski> newbiee : see <http://hpaste.org/76385#a76390> (and also the other annotation i made there)
14:38:01 <Kyraimion> Reflector666:  If search for "SICP" on youtube you get the corresponding MIT lecture held by Abelson (one of the Authors)
14:38:13 <Cale> Reflector666: Computer science is a misnomer. It's not really about computers (any more than astronomy is about telescopes), and it's not a science, in that it doesn't really use the scientific method.
14:38:50 <Nisstyre> Cale: although there is a blurring line between engineering and computer science that most people don't acknowledge
14:39:03 * ski . o O ( Computing Science )
14:39:13 <shachaf> The Structure and Interpretation of Cat Pictures, a book in rhymes by Abelson and Dr. Seussman.
14:39:16 <Philippa> ski: quite
14:39:30 <Nisstyre> also, http://youtu.be/aHk42kDwesM?list=FLcBI0SEgnOBJYWN24P3oPbA
14:39:32 <Cale> shachaf: hahaha
14:39:46 <Philippa> shachaf: Ignoring kittehs ignore input?
14:40:27 <Reflector666> Cale: this is the frase from first lecture))
14:40:34 <Cale> Reflector666: indeed
14:40:56 <ski> newbiee : anyway, Cale's annotation is a more merciless refactoring of your code than mine :)
14:41:50 <newbiee> ski and cale: thank you :)
14:41:51 <Cale> newbiee: Why is it that you're using Maybe String instead of Bool in checkLower and checkIfDigit?
14:42:11 <Cale> newbiee: You're using the values Nothing and Just "True" instead of using False and True respectively
14:42:19 <Cale> and it's making life harder for you
14:42:33 <Nisstyre> yeah, I told him to use that for error handling before...
14:42:34 <ski> newbiee : as a next refactoring step along my line, you could try removing the `Maybe's from the *inputs* of `checkLower' and `checkIfDigit' (because `Maybe' isn't really needed there in your code, since you always call them with an argument `Just ...')
14:42:36 <Nisstyre> he may have taken that the wrong way
14:42:37 <newbiee> well on the test the instruction would make life harder for me
14:42:38 <newbiee> lol
14:42:41 <Reflector666> guys and the final question if you dont mind. In what age you become developers? I mean a good one, not just trying and learning. may be when you get dev job. In what age you been then?
14:43:01 <ski> newbiee : of course, this is just a suggestion for refactoring -- perhaps you have some other idea you want to try instead
14:43:13 <newbiee> i just need to know both concept
14:43:23 <newbiee> and using guard is good to know
14:43:29 <Reflector666> im 25 y.o and i'm just starting to learn programming...so i have suck interest
14:43:30 <Cale> Reflector666: It's a gradual process, not one with a clear boundary, like "NOW I'm a good programmer"
14:43:38 <newbiee> using bool is easy
14:43:48 <newbiee> but i guess i need to know how to use Maybe type
14:44:23 * shachaf wonders whether newbiee cares about learning Haskell at all.
14:44:25 <ski> Reflector666 : not to discourage you, but <http://norvig.com/21-days.html>
14:44:50 <wakigame> Sometimes I think 99% of being a good programmer, is simply trying to keep learning. Never stop expanding your knowledgebase.
14:45:03 <newbiee> shachaf ...... lol... yes i do... first of all, i need to know enough to get a good grade on the test first....
14:45:05 <ski> Reflector666 : imo, if you want to continue learning programming, it's important that you keep having *fun* while programming
14:45:06 <Nisstyre> wakigame: that's part of being a good human
14:45:15 <wakigame> Nisstyre: agree
14:45:28 <Reflector666> thanx for article)
14:45:31 <newbiee> i think haskell offer many things that is easy to do then java or c for examples
14:45:54 <Nisstyre> Haskell is conceptually much simpler imo
14:46:57 <efie> it's all about types and typeclasses, isn't it?
14:47:37 <shachaf> efie: No, type classes are the devil.
14:47:40 <shachaf> It's just about types.
14:47:49 <Nisstyre> I guess you could argue that laziness makes it hard to reason about some code
14:48:27 <Cale> It makes it easy to reason about other code
14:48:55 <efie> shachaf: they are? I more or less skipeed the chapter at LYAH about typeclasses because I wanted to start doing something ... I then figured out that more or less everything later became an instances of a typeclass :)
14:49:18 <shachaf> efie: Lots of things are instance of type classes, but that's sort of incidental.
14:49:24 <Cale> efie: Well, understanding type classes is a major part of understanding types
14:49:29 <Cale> (at least in Haskell)
14:49:37 <Nisstyre> efie: the reason type classes exist is for something called ad-hoc polymorphism
14:49:42 <Cale> NO
14:49:42 <shachaf> Cale: I don't think that's true.
14:49:45 <Cale> nononononono
14:49:55 <Nisstyre> Cale: is that directed at me?
14:49:58 <Cale> yes
14:50:02 <Nisstyre> why is that wrong?
14:50:05 <shachaf> Cale: If you have a good understanding of types and parametric polymorphism, type classes are relatively simple.
14:50:05 * hackagebot hs-pkpass 0.3 - A library for Passbook pass creation & signing  http://hackage.haskell.org/package/hs-pkpass-0.3 (VincentAmbo)
14:50:19 <Philippa> It was branded a new approach at ad-hoc polymorphism at the time /because they didn't have a better description/
14:50:25 <Philippa> they're not ad-hoc, and we have a better description or three now
14:50:26 <Cale> Everyone says this because the original paper was subtitled "Making ad-hoc polymorphism less ad-hoc"
14:50:41 <Philippa> which implies it's no longer (fully) ad-hoc :p
14:50:46 <Cale> but it's actually something which behaves quite differently
14:50:56 <Nisstyre> Philippa: okay, that doesn't make what I said wrong.
14:51:34 <parcs`> ad-hoc is a pretty ad-hoc term anyway
14:51:38 <Nisstyre> I agree that it doesn't mean that now though
14:51:41 <Philippa> no, but historically they exist to achieve something that was previously done with it
14:51:47 <Philippa> and it /already had an extant definition/
14:51:53 <Philippa> which is much the same one in use now
14:52:11 <Cale> Nisstyre: Okay, so ad-hoc polymorphism is polymorphism by defining things with one definition for each type at which you are going to apply them.
14:52:24 <Nisstyre> yes
14:52:34 <Cale> But that's not what type class polymorphism gives you
14:52:37 <Cale> Consider sort
14:52:52 <Philippa> where 'things' aren't some new entity, just the existing functions or values or whatever that you already had
14:52:54 <Cale> sort is polymorphic, not because it has been defined once for every type of list
14:53:09 <Cale> but because it depends on a type class polymorphic function
14:53:51 <Cale> That's something that you can't do with ad-hoc polymorphism
14:53:51 <Nisstyre> Cale: that makes sense
14:54:02 <Nisstyre> I understand what you're getting at
14:54:20 <Philippa> Cale: in the absence of getting syntactic macro happy, anyway
14:54:27 <Cale> It's better to see type class polymorphism as parametric polymorphism with constraints
14:54:28 <Philippa> (at which point you probably have bigger problems)
14:54:35 <Nisstyre> Cale: should type classes be introduced as a way to solve the problem of ad-hoc polymorphism you think?
14:54:41 <n-dolio> You do exactly that in C++.
14:54:46 <Nisstyre> and then later explain that it's not just that thing you can solve with them?
14:54:50 <n-dolio> Except you don't have type classes there to make it sensible.
14:54:56 <Nisstyre> s/thing/problem/
14:54:58 <Cale> Nisstyre: I'd rather that people not mention the words ad-hoc
14:55:06 <Cale> Nisstyre: What you're doing is much more structured
14:55:09 <Nisstyre> Cale: no, I mean, like in Real World Haskell
14:55:17 <Nisstyre> it introduces type classes as a way to solve that problem
14:55:41 <Cale> They are a solution to a problem obtaining a certain kind of polymorphism
14:55:49 <Nisstyre> do you think that's doing a disservice to people?
14:55:58 <Philippa> yeah, but you shouldn't. You should introduce them as a way of solving problems that might otherwise have been solved with ad-hoc polymorphism. You don't need to invoke ad-hoc polymorphism at all
14:56:00 <Cale> Ad-hoc polymorphism is another possible solution to some of the same problems
14:56:10 <Cale> But it's not really the same thing
14:56:18 <Philippa> and unless you're dealing with a target audience that already knows it /with a solid definition/ and can spot the differences? Yeah, that's just confusion
14:56:22 <Nisstyre> yeah, I understand that
14:56:28 <Philippa> (and introducing it as 'how to do ad-hoc' is just wrong)
14:57:14 <Nisstyre> Philippa: what if you say "Haskell type classes can be used to accomplish this"
14:57:21 <Nisstyre> emphasis on "can be used"
14:57:35 <sipa> @faq can type classes be used to accomplish this?
14:57:35 <lambdabot> The answer is: Yes! Haskell can do that.
14:57:51 <Philippa> Nisstyre: for what value of "this"?
14:58:16 <Nisstyre> Philippa: ad-hoc polymorphism, in the context of an introduction, maybe defining == for more than one type
14:58:26 <Nisstyre> without using the words "ad-hoc polymorphism"
14:58:37 <Philippa> so not, in fact, ad-hoc polymorphism :p
14:58:49 <Philippa> (== is a reasonable example, yes)
14:58:59 <shachaf> Cale: I heard all it takes to get added to the lambdabot admin list is to ask you!
14:59:01 <Philippa> (but you want to talk about the commonalities between instances)
14:59:25 <Nisstyre> Philippa: yes, I agree
14:59:59 <Philippa> so conceptualising it as 'ad-hoc' even without using the phrase is basically a waste of brain cells
15:00:56 <Nisstyre> Philippa: so, I guess you could start by making a sort function like Cale mentioned, then asking how you would make sure all of the possible inputs are "orderable"
15:01:27 <Nisstyre> I dunno, it's difficult I think to introduce them properly
15:03:15 <hpaste> ClaudiusMaximus pasted “variable precision reciprocal” at http://hpaste.org/76392
15:04:18 <Philippa> Nisstyre: one approach is to work by analogy to ML modules only with a 1:1 type:instance restriction
15:04:33 <ClaudiusMaximus> anyone care to code review and/or take up the challenge presentted at the end of my paste?  i need to sleep...
15:04:41 <Philippa> (that gets you your wonky analogy with OO classes, too!)
15:05:00 <ClaudiusMaximus> ...but i'm in one of those "can't rest until it's done" phases
15:05:42 <hpaste> kmels pasted “is this writable with Map.foldl?” at http://hpaste.org/76393
15:07:48 <glguy> kmels: This might be what you were looking for: mapAccum :: (a -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
15:07:50 <ski> kmels : hm, `foldr', at least
15:08:23 <shachaf> glguy++ # always forget about mapAccum*
15:08:25 <ski> glguy : what are the ordering guarantees of that (if any) ?
15:08:36 <glguy> ski: you'll have to check the docs
15:09:02 <shachaf> ski: "ascending order of keys"
15:09:36 <efie> concerning efficiency, is it better to implement an algorithm using recursion or the State Monad?
15:09:41 <ClaudiusMaximus> i was gonna suggest scanl, but didn't notice the Map stuff
15:09:43 <shachaf> There's also mapAccumRWithKey, though no mapAccumR for some reason.
15:09:56 <ski> efie : too general question
15:10:07 <shachaf> efie: It's better to figure out what your algorithm is first and then worry about "efficiency".
15:10:13 <kmels> glguy, very nice thank you
15:10:17 <shachaf> Of course, you could also convert to a list and then use Data.List.mapAccumL
15:10:27 <ski> ClaudiusMaximus : i think `scanl' would be somewhat awkward
15:10:36 <shachaf> Which would presumably not be much worse. Maybe a little worse if the Data.Map function is smart.
15:12:09 <efie> ok, I will try it both ways and then maybe ask again =)
15:12:29 <shachaf> efie: Before worrying about efficincy to this degree you should know how State works. :-)
15:12:40 <shachaf> Recursion and "the State Monad" are not alternatives.
15:13:20 <niklasb> can I stack multiple readerT's on top of each other? how do I ask from the inner reader?
15:13:28 <trotro> lift
15:13:31 <trotro> but count them
15:13:42 <niklasb> hmm, doesn't seem to work here, probably I'm doing it wrong
15:14:03 <niklasb> oh, so if there's another stateT around the two readerT's, do I need lift . lift?
15:14:16 <shachaf> Yes.
15:14:21 <niklasb> nice
15:14:24 <efie> shachaf: hmm I'm sure I saw a few examples on the web which presented some recursive code and also did it using the state monad for fun
15:14:24 <shachaf> niklasb: Are you sure that's what you want, though?
15:14:32 <shachaf> It sounds a bit evil to me.
15:14:34 <niklasb> shachaf: of course not ;)
15:14:50 <niklasb> I just need my code to access a configuration and a runtime context
15:14:55 <niklasb> and some functions only need one of them
15:15:19 <shachaf> If you're defining your own monad and implementing it using ReaderT, that's OK.
15:16:07 <niklasb> yeah, that's pretty much what I do. most of the functions have a declaration like (MonadReader A) => ... or (MonadReader B) => ... and then they are finally run in the same monad
15:16:07 <shachaf> But if you're going to be sprinkling your own code full of lifts, that might mean you should restructure it.
15:16:21 <shachaf> You can always pass an argument instead of using ReaderT...
15:16:49 <niklasb> shachaf: yeah.. I just defined asksA and asksB, I guess that's pretty clean
15:17:06 <niklasb> i'm not sure though
15:17:23 <shachaf> You can also use ReaderT (Blah,Blue)
15:18:08 <niklasb> shachaf: that's what I did at the beginning, but some functions just operate on the Blah, and I need to evaluate them to get a Blue
15:18:13 <niklasb> *the initial Blue
15:18:48 <niklasb> but yeah, I guess I'll just use explicit arguments
15:18:49 <efie> shachaf: like this http://stackoverflow.com/questions/11250328/working-with-the-state-monad-in-haskell could be expressed by [1..10]
15:19:04 <efie> (because you said it's no alternative)
15:19:37 <shachaf> efie: "State" is not an alternative to recursion.
15:19:47 <shachaf> collectUntil is defined recursively, if you look closely.
15:20:06 * hackagebot partial-uri 0.1 - Datatype for passing around unresolved URIs.  http://hackage.haskell.org/package/partial-uri-0.1 (StephenWeber)
15:22:00 <glguy> edwardk: ping?
15:22:10 <edwardk> pong
15:22:34 <glguy> edwardk: no implied urgency, just curious if you saw my lens issue ticket, curious if that was an actual bug
15:22:52 <edwardk> haven't looked. checking now
15:23:19 <edwardk> looks like droppingWhile has a bug
15:23:35 <efie> shachaf: ok, then I should have expressed clearlier what I mean- I think there are some cases in which using the State Monad is/looks nicer/clearer (may the State Monad use recursion) then doing several nested recursion with a lot of parameters. I wrote the latter a lot in the past, so now I'm thinking if using (maybe recursive) State Monad would be better (also for efficiency)
15:24:26 <shachaf> efie: Do you know how State works?
15:24:39 <efie> I think so :)
15:24:45 <edwardk> now to remember how to fix it ;)
15:24:48 <shachaf> It has exactly the performance characteristics that you'd expect for passing in a state and getting a tuple as a result. Because that's what it is.
15:25:06 * hackagebot route-generator 0.5 - Utility to generate routes for use with yesod-routes  http://hackage.haskell.org/package/route-generator-0.5 (StephenWeber)
15:25:13 <shachaf> efie: If it's a *clearer* way to express your logic, then you should use State. Worry about efficiency later or never.
15:25:17 <Reflector666> ok guys..i'll go sleep. it's pretty late down here in moscow. nice to meet you, world will be ours, so don't stop.. goodbye everyone
15:25:38 <shachaf> efie: Often things that you think would be clearer with State actually aren't, though.
15:26:10 <ski> night Reflector666
15:26:36 <efie> shachaf: ok, seems like I need to make more experience with this
15:27:14 <edwardk> glguy: good catch
15:33:13 <Kyraimion> Cale:  Regarding polymorphism, my understanding is that a function is ad-hoc polymorphic if it has different definitions  depending on the type of it's argument, while it is parametric polymorphic when it has only one definition that happens to not use the type of one of it's arguments
15:33:47 <Kyraimion> Cale:  So (<) would be ad-hoc polymorphic while sort is parametric polymorphic
15:34:21 <shachaf> @ty (<)
15:34:23 <lambdabot> forall a. (Ord a) => a -> a -> Bool
15:34:24 <shachaf> @ty sort
15:34:25 <lambdabot> forall a. (Ord a) => [a] -> [a]
15:34:32 <shachaf> Those look pretty similar to me.
15:35:15 <Kyraimion> shachaf:  Except that there is one definition of sort for all a
15:35:39 <shachaf> No, it's different for every a
15:35:53 <Kyraimion> @src sort
15:35:53 <lambdabot> sort = sortBy compare
15:36:17 <edwardk> glguy: ok, i think i've fixed it. running tests now
15:36:21 <shachaf> > sort "ba"
15:36:22 <lambdabot>   "ab"
15:36:26 <shachaf> > compare 'a' 'b'
15:36:28 <lambdabot>   LT
15:37:27 <glguy> edwardk: are you attempting to test how many versions hackage will let you release in total of a single package? :-D
15:37:44 <edwardk> nah i already pushed that with trifecta and category-extras ;)
15:37:52 <johnw> edwardk: hello!
15:37:55 <edwardk> heya johnw
15:37:59 <johnw> joeyh: can I rename a remote safely with git-annex?
15:38:12 <johnw> joeyh: I'd like each remote to have a descriptive name, rather than all but "origin"
15:38:17 <shachaf> category-extras was so great until the antitrust lawsuit.
15:38:31 <edwardk> shachaf: hahahahaha
15:38:31 <edwardk> @remember shachaf category-extras was so great until the antitrust lawsuit.
15:38:32 <lambdabot> Okay.
15:38:38 <edwardk> I'm sure roconnor meant well
15:40:17 <edwardk> looks like my fix is also glitched. one sec. establishing the correct paramorphism
15:40:29 <johnw> what is paramorphism?
15:40:50 <edwardk> are you familiar with the notion of a catamorphism?
15:40:55 <johnw> yes
15:40:58 <johnw> and homo
15:41:01 <johnw> not so much hylo
15:41:09 <edwardk> a paramorphism is a catamorphism where you also get access to the original structure
15:41:11 <edwardk> :t foldr
15:41:12 <johnw> or ana
15:41:13 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
15:41:18 <edwardk> that is a list catamorphism
15:41:24 <edwardk> para :: (a -> [a] -> b -> b) -> b -> [a] -> b
15:41:26 <shachaf> ([a] -> a -> b -> b) -> b -> [a] -> b ?
15:41:30 <edwardk> would be the list paramorphism
15:41:33 <johnw> ah, ok
15:41:51 <shachaf> edwardk: Does that give f the original list at each step or the "remainder"?
15:41:53 <edwardk> para f z = z; para f z (x:xs) = f x xs (para f z xs)
15:42:01 <shachaf> Ah, OK.
15:42:14 <edwardk> shachaf: the remainder from there down. its the original untransformed list
15:42:29 <shachaf> OK.
15:42:36 <edwardk> With that dropWhile p = para (\x xs xs' -> if p x then xs' else (x:xs)) []  (or something close)
15:42:39 <shachaf> So it's like a combined Church-Scott encoding!
15:42:58 <edwardk> haven't really thought about it in those terms but i suppose =)
15:43:39 <edwardk> in category-extras para is the generalized catamorphism for the (,) (Mu f) comonad
15:44:22 <edwardk> i have a notion of paraOf already in lens, but its the uniplate style bottom up paramorphism.
15:44:34 <edwardk> the one i need is the fold-like right-to-left paramorphism
15:44:35 <kyagrd_> edwardk: So, is paramorphism close to primitive recursion?
15:44:43 <edwardk> kyagrd_: exactly like =)
15:45:40 <edwardk> kyagrd: you can use a paramorphism to encode precisely primitive recursion. its about the last interesting recursion scheme before they start becoming contrived
15:47:18 <johnw> edwardk: why did you start out that definition above with "para f z = z; "?  Isn't that a syntax error by not using the same number of arguments in the two patterns?
15:47:29 <johnw> did you mean para f z []?
15:47:38 <edwardk>  i did
15:47:39 <kyagrd> naming of them is hard to remember. catamorphism = iteration, anamorphism = coiteration, paramorphism = primitive recursion, ...
15:47:57 <edwardk> thats what i get from writing it off the top of my head
15:48:22 <johnw> there aren't enough brackets on the top of your head?
15:48:25 <edwardk> i'm not a fan of the names.
15:48:33 * ski . o O ( catamorphism = iteration ?? )
15:48:39 <johnw> ski: think of a fold
15:48:47 <kyagrd> yeah it's hard to see which is the dual operation of which
15:49:07 <ski> johnw : it doesn't feel like iteration to me. `foldl' does
15:49:16 <edwardk> kyagrd: http://comonad.com/reader/2009/recursion-schemes/ is sort of a field guide
15:49:39 <johnw> i believe both foldl and foldr can be catamorphisms
15:49:42 <johnw> is that right?
15:49:54 <kyagrd> ski, http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.157.5242 catamorhpism is called iteration in some communities. and ana is coiter
15:49:55 <ski> johnw : yes, if you take them over different list types
15:50:06 <johnw> what is "coiteration"?
15:50:11 <ski> @type unfoldr
15:50:12 <kyagrd> johnw, anamorphism
15:50:13 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
15:50:16 <johnw> lol
15:50:19 <johnw> what is anamorphism?
15:50:26 <johnw> ah
15:50:32 <johnw> I've not yet used unfolds
15:50:44 <johnw> but that does make it clear, thanks
15:50:48 <kyagrd> usually when you call -morphism it usually means more general notion than just list
15:50:55 <ski> kyagrd : interesting/strange
15:50:56 <edwardk> they generalize to other base functors.  ana :: Functor f => (a -> f a) -> a -> Mu f
15:51:05 <kyagrd> you can think of it for trees and etc
15:51:53 <ski> @let foldTree :: (a -> [o] -> o) -> (Tree a -> o); foldTree node (Node a ts) = node a (map (foldTree node) ts)
15:51:54 <lambdabot>  Defined.
15:51:58 <kyagrd> ski, I like those name better because I only have to remember half of them :)
15:52:26 <edwardk> http://hackage.haskell.org/packages/archive/recursion-schemes/3.0/doc/html/Data-Functor-Foldable.html encodes a lot of these including my monad transformer way of turning all of the foo-morphism prefixes into modifiers that can be mixed
15:52:35 <edwardk> hence the 'zygohistomorphic prepromorphism' jokes
15:52:40 <ski> by "iteration", i think of something like SICP's "iterative processes"
15:53:59 <johnw> when I hear "iteration", I think "walking over a structure one by one"
15:54:15 <johnw> whether that yields a value or not, so map is an iterator too, it simply collects a list result
15:54:27 <johnw> but then, C++ has resulted in my having a damaged vocabulary
15:54:38 <edwardk> yeah but that is in part the corruption of your vocabulary by spending all your time in c++ land
15:54:41 <edwardk> yep
15:54:50 <edwardk> next you'll be talking about functors funny too ;)
15:55:07 <johnw> actually, hearing people use the word "functor" here this week has been making me cringe
15:55:16 <johnw> what they *mean* is arrow
15:55:23 <johnw> "A thing that acts like a function"
15:55:23 <shachaf> Arrow?
15:55:25 <edwardk> no, they really mean functor
15:55:30 <kyagrd> johnw, not every arrow is a functor
15:55:35 <edwardk> oh you mean at the committee
15:55:39 <johnw> C++ functor = Haskell arrow
15:55:46 <shachaf> Not really...
15:55:55 <edwardk> kyagrd: some context. he's off at the c++ committee working on standardization stuff
15:56:05 <shachaf> johnw is?
15:56:08 <johnw> yes
15:56:09 <kyagrd> Oh, the C++ world ...
15:56:15 <edwardk> c++ functor isn't _quite_ a haskell arrow. its still weaker
15:56:18 <johnw> we were just talking about generic lambdas
15:56:20 * shachaf doesn't recommend understanding C++ in terms of Haskell, just as he doesn't recommend understanding Haskell in terms of C++
15:56:27 <johnw> edwardk: yes
15:56:36 * adnauseam agrees with shachaf 
15:56:47 <adnauseam> WE COMPARE SEXUAL ORGANS NOA
15:56:57 <adnauseam> =p
15:56:58 <johnw> what I mean is that "Arrow" comes infinitely closer to what C++ means by a functor than "Functor" does
15:57:07 <edwardk> a c++ functor is just something with overloaded application. an arrow implies a lot of tools for putting them together which c++ lacks
15:57:19 <johnw> yes, that is a very good point
15:57:24 <johnw> Bare Naked Arrows
15:57:35 <monochrom> Broken Arrow. a movie
15:57:46 <johnw> I keep forgetting that the other half of Haskell is all the goodness you get from creating a type class instance
15:58:07 <johnw> otherwise, Category by itself would seem positively anemic
15:58:12 <johnw> but in context, it's incredibly rich
15:58:26 <edwardk> i prefer 'horrible hack to work around the lack of environment capture in the default function type' to 'arrow'
15:58:32 <edwardk> it captures the semantics better ;)
15:58:38 <johnw> i'll suggest it!
15:58:58 <johnw> apparently we are working toward a C++14, edwardk, not C++17 as I mentioned
15:59:05 <edwardk> HHtWAtLoEC for short
15:59:47 <adnauseam> Broke Back Monad
15:59:58 <johnw> adnauseam: complete with a surprise ending
16:00:24 <monochrom> homebrew closure
16:00:27 <adnauseam> as long as it's no side effect, we cool
16:00:56 <adnauseam> anyone taking cs50 on edx btw ?
16:00:57 <edwardk> adnauseam: is that the homoiconic cowboy movie?
16:01:20 <johnw> it's truly homomorphic, yes
16:01:30 <monochrom> yeah homomorphic :)
16:01:31 <adnauseam> =D
16:02:13 <edwardk> oh yeah, i guess the homoiconic one would involve a cowboy with a lisp
16:02:55 <monochrom> yeah, that's Brokeback Macro
16:08:30 <kyagrd> back to the Functor in Haskell, I beleive we can derive fmaps for non-strictly positve but positive functors. Such as data Foo a = MkFoo (Foo -> a)
16:09:25 <hpaste> importantshock pasted “convert regular ADTs to fixed points of functors: boring boilerplate” at http://hpaste.org/76394
16:09:47 <importantshock> hey everyone, i'm wondering if there's a way to simplify the code I just posted
16:10:05 <Cale> I actually don't know of any instance of Functor for a type which has its constructors exposed that's not almost immediate to write based on the type.
16:10:06 <importantshock> it's essentially a very tedious walk through a tree-like structure to convert it to a fixed point of a functor
16:10:37 <importantshock> s/tree-like structure/nested ADT
16:10:50 <edwardk> kyagrd: erm, ghc does that with DeriveFunctor
16:11:03 <importantshock> not sure if generics or SYB can help me here, but I'd be grateful for any assistance
16:11:48 <Cale> importantshock: any of the generics libraries ought to be able to help with that, I'm just trying to think if I've seen one which does precisely that
16:11:49 <edwardk> cale: there are the illegal-ish uu-parsinglib-style cases, but there i tend to just 'coyoneda' each constructor so it becomes a legal functor again
16:12:11 <importantshock> Cale: yeah it seems like the perfect situation, but I always get tripped up on the types
16:13:47 <kyagrd> edwardk: "data Foo a = MkFoo (Foo a -> a) deriving Functor" doesn
16:13:52 <kyagrd> doesn't work
16:13:57 <michael__> Hi - I need help implementing a function called apply in a program. Does any of you have the time to look at the program and help me getting started?
16:14:00 <ski> kyagrd : that's not positive
16:14:01 <kyagrd> at least not in GHC 7.4.1
16:14:09 <kyagrd> ski, it is positive not "strictly" positive
16:14:16 <ski> it is not positive
16:14:31 <edwardk> no thats not positive. the a in Foo a occurs in negative position
16:14:35 <kyagrd> oh I'm sorky
16:15:00 <kyagrd> What I meant wos "data Foo a = MkFoo ((Foo a -> a) -> a) deriving Functor" this
16:15:10 <ivanm> michael__: is this homework?
16:15:14 <edwardk> thats also failing positivitiy
16:15:15 <ski> kyagrd : the next to last `a' occurs in negative position there
16:15:30 <kyagrd> grrr I should change it to Bool or unit
16:15:30 <edwardk> (Foo a -> Bool) -> a   would work
16:15:43 <ivanm> edwardk: stop being so negative about what kyagrd is trying to do! ;)
16:15:49 <ski> kyagrd : maybe you wanted something like `data Bar o a = MkBar ((Bar o a -> o) -> o)' ?
16:15:52 <michael__> ivanm: Yes, it is homework.
16:15:56 <edwardk> ivanm: i'm positive. just not strictly positive
16:16:07 <ivanm> edwardk: heh
16:16:21 <ivanm> michael__: well, we could have a look, but no guarantees
16:16:30 <kyagrd> edwardk: I just changed it "data Foo a = MkFoo ((Foo a -> ()) -> a) deriving Functor" okay this even with XDeriveFunctor doesn't work
16:16:36 <shachaf> I have a book that means ≥0 by "positive" and >0 by "strictly positive".
16:16:42 <michael__> Of course not - I will need to copy it to pastebin. One moment.
16:16:59 <shachaf> kyagrd: Works for me.
16:17:04 <ski> kyagrd : hm, i suppose what i suggested is somewhat useless -- how about `data Bar o a = MkBar ((a -> Bar o a -> o) -> o)' instead ?
16:17:23 <importantshock> Cale: I was thinking `gmapQ convert` would work if I added a Data constraint to Reifiable, but I can't make heads or tails of the error.
16:17:23 <kyagrd> shachaf: what GHC version are you using?
16:17:25 <ivanm> @where hpaste
16:17:25 <lambdabot> http://hpaste.org/
16:17:25 <shachaf> 7.6
16:17:27 <ivanm> michael__: ^^
16:17:39 <ski> kyagrd : btw, do you need/want to define a recursive type ?
16:17:42 <kyagrd> ah I should upgrade it
16:17:44 <michael__> We have just started learning Prolog and Haskell, so we have just been introduced to some very basic things. We will just have two lectures to get introduced to each of the programming languages and the idea is that we should get some hands-on-experience.
16:18:20 <michael__> http://pastebin.com/pEfzxaaW
16:18:22 <michael__> The program.
16:18:25 <maukd> The paste pEfzxaaW has been copied to http://hpaste.org/76395
16:18:26 <ski> michael__ : also note there's a ##prolog channel on this IRC network
16:18:32 <michael__> I can explain in short what it should do.
16:18:40 <michael__> Thanks :)
16:18:46 <kyagrd> ski, I didn't get the question. what do you mean I need to define recursive type? I always define recursive types in programming (like syntax tree etc)
16:19:47 <ski> kyagrd : it seemed you either wanted to understand "strictly positive", or trying to simplify some example you had which wasn't working
16:20:05 <michael__> My first task is to write a function apply :: State -> [Rule] -> State that takes a state (i.e. a sequence of letters) and applies to each letter of this state the first applicable rule from the list of rules.
16:20:32 <michael__> This program will draw fractals, when these predicates are implemented :)
16:20:52 <kyagrd> ski, oh I was just not happy about sometimes deriving Functor doens't work for non-strictly postive but positive type. It seems that they work in 7.6
16:21:03 <michael__> Letters that have no applicable rules should be copied to the new state.
16:21:29 <michael__> This function corresponds to going from depth n to depth n + 1.
16:21:36 <ski> michael__ : .. and where is the problem ?
16:22:30 <michael__> The problem is I am not really sure where to get started. What I have so far is this, but I am afraid I am overcomplicating things:
16:22:31 <michael__> let apply [] _ = []; apply (x:xs) rs = (case lookup x rs of Nothing -> [x]; Just s -> s) ++ apply xs rs in apply "FXRYF" [('X',"XRYF"),('Y', "FXLY")]
16:23:08 <shachaf> Hmm, this seems vaguely familiar.
16:23:20 <michael__> According to the exercise, I should be able to test my function using this:
16:23:21 <michael__> apply "FXRYF" [Rule 'X' "XRYF", Rule 'Y' "FXLY"]
16:23:34 <michael__> It should produce this:
16:23:35 <michael__> "FXRYFRFXLYF"
16:23:40 <shachaf> Oh, that was you asking the same question yesterday.
16:23:54 <michael__> Yes, it was me. But I am still a bit stuck.
16:23:58 <ski> michael__ : i think you could use `concatMap' to define `apply'
16:25:10 <ski> michael__ : anyway, your code for `apply' looks like it would work, i think
16:25:58 <michael__> Hm, yes. But wouldn't it only work on pairs? Not Rules?
16:26:21 <michael__> shachaf: I hope it is OK to get back, if I need further assistance?
16:26:23 <ski> i suppose
16:26:41 <shachaf> michael__: Sure. I was wondering if I could refer you to the previous conversation, but it turns out that that was you too. :-)
16:26:52 <ski> so you either need to define your own `lookup' which works on `Rule's, or you need to convert the `Rule's to pairs
16:26:54 <ski> (or both)
16:26:56 <michael__> Hehe - yes, it was me, that is why ;)
16:27:41 <michael__> Hm, would it make sense to make a conversion? And would there be any advantage of doing both?
16:28:03 <ski> not in itself
16:28:18 <ski> it might be less code to write
16:28:38 <Cale> michael__: I recommend breaking the problem into two main pieces: turn a list of pairs [(Char,String)] which correspond to rules into a function Char -> String
16:29:07 <ski> Cale : except michael__ also need to catch the "no match" case
16:29:08 <michael__> Cale: Thanks, I think that would be a better approach.
16:29:09 <Cale> and secondly, a part which applies a function (Char -> String) to each of the characters of a String and concatenates the results
16:29:23 <Cale> ski: Indeed, but that can be part of this conversion :)
16:29:24 <ski> Cale : oh, sorry nvm, i just realized it doesn't matter :)
16:30:26 <Cale> michael__: but yeah, you'll want to think carefully about what String to produce when the Char that your function is given doesn't match any rule.
16:32:35 <michael__> Well, if it does not match any rule, I just need to return the letter. However, I need to figure out how to write that in Haskell - I guess that will be a bit of a challenge ;)
16:32:56 <michael__> According to the teacher, it should be possible to write the apply function in 2 lines with a helper function in 3 lines. So I guess it is not too much code, even though it is challenging.
16:33:10 <importantshock> Uniplate may do what I need
16:33:33 <michael__> Uniplate? What is that? :)
16:34:20 <michael__> I never heard about that.
16:34:47 <parcs`> > [10..0]
16:34:49 <lambdabot>   []
16:34:54 <Nereid> > [10,9..0]
16:34:55 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0]
16:35:05 <kyagrd> michael__: http://www.haskell.org/haskellwiki/Uniplate
16:35:15 <michael__> Thanks :)
16:36:13 <parcs`> > [10,11..0]
16:36:15 <lambdabot>   []
16:36:58 <ski> michael__ : Uniplate is probably beyond you atm. i suggest ignoring it for the while
16:37:11 <michael__> Hehe - I guess you are right ;)
16:39:42 <Nereid> hmm, uniplate looks handy.
16:40:15 <michael__> But you suggest that I turn a list of pairs which correspond to rules into a function Char -> String. Would this be value Haskell?
16:40:16 <michael__> apply :: State -> [(Char,String)] -> Char -> String
16:40:23 <parcs`> it's unfortunate that [10..0] doesn't work as expected
16:40:30 <michael__> *valid
16:40:33 <michael__> Not value, sorry ;)
16:40:40 <Nereid> parcs`: whether it works as expected depends on your expectations.
16:40:42 <shachaf> parcs`: Atlernatively, fortunate.
16:40:53 <parcs`> Nereid: you know what i mean
16:40:54 <michael__> I mean, would it be possible to write something like that, if I want to do that?
16:41:08 <Nereid> parcs`: but this makes sense.
16:41:15 <maukd> parcs`: your expectations are broken
16:41:27 <parcs`> of course it makes sense
16:41:41 <Nereid> no, it makes sense that [10..0] = []
16:41:57 <parcs`> yeah, i know
16:42:04 <parcs`> that's what i was referring to
16:42:11 <Nereid> [a..b] should be the list of values that are >= a and <= b.
16:42:57 <shachaf> Nereid: What about [a,b..c] be?
16:43:03 <shachaf> s/about/should/
16:43:09 <Nereid> that's harder. :v
16:43:10 <parcs`> except that Ord and Enum are not related to each other
16:43:11 <typoclass> Nereid: yeah, but it would make just as much sense if it were defined as "[a..b] is the list of values that are between a and b"
16:43:20 <Nereid> ok fine
16:43:29 <Nereid> the list of successors of a that are not successors of b
16:43:33 <Nereid> (including a, but not b)
16:43:45 <Nereid> (er, including b too)
16:43:45 <cmccann> clearly [10..0] should be a list that counts from 10 up to infinity, then wraps around and counts from negative infinity up to zero
16:43:47 <Eduard_Munteanu> > [1..10]
16:43:48 <michael__> Would apply :: State -> [(Char,String)] -> Char -> String be a way to turn a list of pairs into a function Char -> String in Haskell?
16:43:48 <cmccann> that makes sense, right
16:43:49 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
16:44:14 <maukd> guess what PHP's range() does
16:44:16 <hpc> michael__: what's State?
16:44:20 <typoclass> several things make sense, the question is which is implementable and which is most intuitive
16:44:32 <cmccann> maukd, something incorrect
16:44:35 <parcs`> typoclass++
16:44:40 <hpc> maukd: makes a temporary file and subtracts the timestamp from its unix permissions
16:44:47 <cmccann> haha
16:44:48 <maukd> hpc: close
16:45:01 <Nereid> haha
16:45:08 <Eduard_Munteanu> One could also argue [0..10] should be [0,1,2,3,4,5,6,7,8,9]
16:45:13 <michael__> State is the type.
16:45:28 <maukd> Eduard_Munteanu: wouldn't that be [0..10) ? :-)
16:45:28 <typoclass> Eduard_Munteanu++
16:45:44 <maukd> or maybe [0..10[
16:45:47 <Eduard_Munteanu> Heh, I guess so.
16:45:48 <parcs`> [0.1 .. 1.0]
16:45:54 <Nereid> I hate that notation. [0..10[
16:45:54 <parcs`> > [0.1 .. 1.0]
16:45:55 <lambdabot>   [0.1,1.1]
16:45:56 <maukd> [0..]10
16:46:01 <Nereid> haha
16:46:01 <parcs`> that makes sense!!11
16:46:20 <shachaf> Ruby uses (a...b) to mean >= a && < b
16:46:24 <Nereid> the Enum instances for floating point numbers are .....
16:46:36 <hpc> maukd: PHP's range is surprisingly close to correct
16:46:39 <Nereid> > filter (<= 1.0) [0.1..]
16:46:43 <lambdabot>   mueval-core: Time limit exceeded
16:46:44 <Nereid> oh
16:46:46 <maukd> hpc: [citation needed]
16:46:46 <Nereid> > takeWhile (<= 1.0) [0.1..]
16:46:46 <hpc> i couldn't even find any obvious bugs
16:46:47 <lambdabot>   [0.1]
16:47:10 <johnw> 0.1 is a notoriously hard number for FP
16:47:11 <hpc> maukd: citation is that it will take me more than 5 seconds to find what it does wrong :P
16:47:14 <johnw> it's a repeating binary decimal
16:47:18 <maukd> hpc: the spec itself is a bug
16:47:26 <maukd> the documentation sucks
16:47:27 <johnw> or, repeating binary floating point number
16:47:42 <maukd> hpc: try interesting values of $step, such as negative numbers, 0, or fractionals
16:47:48 <hpc> ah
16:47:48 <parcs`> > let enumFromTo' a b | fromEnum a > fromEnum b = enumFromTo b a | otherwise = enumFromTo a b in (enumFromTo' 10 1, enumFromTo' 1 10)
16:47:50 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
16:47:57 <parcs`> oops
16:48:12 <hpc> i would, but unfortunately i remembered not to install PHP
16:48:31 <parcs`> anyway such functionality can obviously be implemented but the question is why doesn't it work that way
16:48:37 <Nereid> the Enum class doesn't really specify what should happen, anyway
16:48:38 <parcs`> (enumFromTo)
16:49:02 <cmccann> Enum doesn't really specify anything useful
16:49:21 <maukd> parcs`: because otherwise you can't get empty ranges
16:49:25 <typoclass> parcs`: {random argument in favor of the current state of things, opposing any alternative on flimsy grounds}
16:49:26 <Nereid> though neither does Ord or Eq
16:49:30 <monochrom> kudos dolio for "mathematicians have their own particular interests that affect the way they frame things, and that doesn't mean those ways are better for everyone"
16:49:36 <cmccann> and if Enum did specify any behavior, floats would almost certainly break the rules
16:50:30 <parcs`> maukd: perhaps there should be two functions, one that is syntactic sugar for the function that behaves more intuitively and another for the function that behaves like enumFromTo does now
16:50:44 <maukd> parcs`: your argument is invalid
16:50:51 <maukd> enumFromTo *is* the intuitive version
16:51:00 <parcs`> er, rather, one that behaves more intuitively for which [a..b] is syntactic sugar
16:51:08 <typoclass> parcs`: good idea
16:51:18 <maukd> parcs`: stop trying to break my code
16:51:21 <parcs`> maukd: do you truly think that
16:51:26 <maukd> yes, of course
16:51:29 <parcs`> that enumFromTo is intuitive
16:51:52 <parcs`> ask anybody familiar with the idea of list comprehensions but not familiar with haskell what [10..1] should equal
16:52:03 <maukd> can I ask a Perl programmer?
16:52:09 <typoclass> maukd: anything "is the intuitive version" once you've been used to it for a couple years
16:52:18 <parcs`> does perl work that way too?
16:52:19 <Nereid> [10..1] isn't a list comprehension
16:52:23 <maukd> parcs`: yes, of course
16:52:38 <maukd> and so does pascal
16:52:39 <Nereid> python range(10,1) is the empty list.
16:52:43 <maukd> and python
16:52:49 <shachaf> And Ruby.
16:52:53 <hpc> maukd: you called?
16:52:55 <maukd> only PHP does it differently
16:52:56 <parcs`> damn it
16:53:01 <parcs`> my argument has been foiled
16:53:04 <parcs`> /retreat
16:53:24 <Nereid> even octave, [10:1] is the empty vector
16:53:32 <kyagrd> anyone using lhs2TeX?
16:53:46 <typoclass> maukd: Nereid: shachaf: does that mean haskell should abolish monads and purity? after all, none of the languages you mentioned have it
16:54:05 <maukd> typoclass: non sequitur
16:54:05 <Nereid> no, because none of the languages mentioned above have it
16:54:08 <Nereid> ^
16:54:23 <Nereid> but all of these languages have an analogue of [a..b]
16:54:36 <maukd> this discussion is about the behavior of an existing range operation
16:54:51 <parcs`> how does [10..1] look in perl?
16:54:56 <parcs`> or [a..b]
16:54:57 <maukd> parcs`: like that
16:55:08 <maukd> well, it depends
16:55:19 <maukd> [10 .. 1] is valid perl (and the result is [])
16:55:44 <maukd> but .. is an infix operator so you could also argue that the answer is 10 .. 1
16:55:57 * cmccann figured perl would magically detect what behavior you expect and do the right thing in context
16:56:09 * Nereid forgot that perl doesn't have a repl
16:56:14 <Nereid> unless it does and no one told me
16:56:16 <maukd> Nereid: it does
16:56:30 <maukd> that is, there are a few
16:56:31 <importantshock> grumble grumble infinite types
16:56:37 <Nereid> haha.
16:56:43 * monochrom adds fuel to the debate: compare haskell [0..0] to python range(0,0)
16:57:04 <Eduard_Munteanu> Try Ocaml for a change, they're ok there ;)
16:57:07 <shachaf> monochrom: Python range(a,b) is Haskell [a..b-1]
16:57:09 <Nereid> true, python range(0,3) is [0,1,2]
16:57:11 <typoclass> Nereid: maukd: you have argued that [10..1] should be [] because haskell should follow the herd. you haven't argued that [10..1] should be [] because it's right or logical or whatever
16:57:21 <shachaf> monochrom: Python range(0,-1) = []
16:57:21 <Nereid> typoclass: I also believe it's right and logical.
16:57:34 <monochrom> yes I know, it's fuel
16:57:40 <maukd> typoclass: I don't think I've done that
16:57:56 <Nereid> and that was my first argument, actually.
16:58:02 <maukd> I generally argue that everyone else got it right because Haskell does it this way
16:58:06 <Nereid> haha
16:58:15 <parcs`> how is enumFromTo any more logical than enumFromTo'
16:58:28 <Nereid> parcs`: it's simpler
16:58:33 <parcs`> > let enumFromTo' a b | fromEnum a > fromEnum b = reverse (enumFromTo b a) | otherwise = enumFromTo a b in (enumFromTo' 10 1, enumFromTo' 1 10)
16:58:35 <lambdabot>   ([10,9,8,7,6,5,4,3,2,1],[1,2,3,4,5,6,7,8,9,10])
16:58:43 <Nereid> enumFromTo' a b has to check which of a or b is smaller, etc
16:59:07 <monochrom> to a large extent, I actually like range(0,3) = [0,1,2] better
16:59:11 <maukd> parcs`: enumFromTo' has unpredictable behavior
16:59:14 <Nereid> meanwhile, for reasonable instances of both Enum and Ord, we have [a..b] = takeWhile (<= b) [a..]
16:59:20 <Nereid> where [a..] = iterate succ a
16:59:33 <shachaf> (LOOP FOR X FROM 10 TO 1 COLLECTING X) #=> NIL
16:59:41 <Eduard_Munteanu> parcs`: you probably don't want that reverse, it interacts badly with laziness.
16:59:51 <maukd> parcs`: for example, what does [0 .. length xs - 1] do?
16:59:58 <parcs`> Eduard_Munteanu: oh, right
17:00:10 <parcs`> > let enumFromTo' a b | fromEnum a > fromEnum b = enumFromThenTo b (pred b) a | otherwise = enumFromTo a b in (enumFromTo' 10 1, enumFromTo' 1 10)
17:00:11 <lambdabot>   ([],[1,2,3,4,5,6,7,8,9,10])
17:00:17 <parcs`> bah, you get the idea
17:00:33 <Nereid> simpler is better!!
17:00:37 <parcs`> maukd: good point
17:01:12 <kyagrd> > let xs = [0 .. length xs -1] in take 1 xs
17:01:16 <lambdabot>   mueval-core: Time limit exceeded
17:01:19 <kyagrd> well it seems to loop
17:01:25 <Nereid> honestly I'd be fine with [0..10] excluding 10 too.
17:01:41 <maukd> in many cases you have a range where at least one of the end points is not a constant
17:02:05 <parcs`> you have persuaded me
17:02:06 <Ralith> shachaf: nobody's written lisp in all caps for decades
17:02:08 <maukd> and in all of those cases (I can think of) you want it to handle empty ranges
17:02:20 <shachaf> Ralith: I have evidence to the contrary.
17:02:31 <Ralith> shachaf: nobody who matters* :D
17:02:40 <maukd> enumFromTo' can't return an empty list. that makes it ... unattractive
17:02:48 <shachaf> Ralith: Nobody who matters has written lisp for decades.
17:02:53 <Ralith> ouch
17:03:06 <Ralith> nobody who matters to lisp, then :P
17:03:32 <monochrom> chrisdone matters. he has written much elisp lately. for using haskell in emacs
17:03:33 <kyagrd> > let xs = [0 .. head xs] in head xs -- this will loop too
17:03:33 <typoclass> maukd: i find it perfectly plausible to have [9..5] as sugar for enumFromTo' as a quick literal notation, and enumFromTo 0 (length xs - 1) for more control
17:03:36 <lambdabot>   mueval-core: Time limit exceeded
17:03:40 <parcs`> maukd: but i say that there should be an enumFromTo _and_ enumFromTo' (not named that way, of course), the latter of which is what [a..b] syntax desugars to
17:03:48 <monochrom> but I doubt that he writes in caps :)
17:04:11 <maukd> parcs`: so you want to break [0 .. length xs - 1]?
17:04:11 <parcs`> maukd: so if a user wanted to do [0..length xs -1] he can de enumFromToOldVersion 0 (length xs - 1)
17:04:15 <monochrom> anyway maukd says what I want to say.
17:04:18 <maukd> yeah, no
17:04:35 <parcs`> maukd: i don't want to break or propose anything
17:04:41 <parcs`> i'm just arguing!
17:04:41 <maukd> fix your expectations
17:05:04 <maukd> the current behavior is not old or deficient. it's deliberate
17:05:58 <maukd> enumFromTo' should not even exist
17:06:02 <maukd> it's pointless
17:06:16 <parcs`> it's convenient
17:06:18 <maukd> its only use is in ranges where both end points are constant
17:06:25 <parcs`> no
17:06:26 <maukd> and in that case you don't need a runtime check
17:06:36 <kyagrd> > let xs = [0,1 .. error "how about this? isn't this strange?"] in head xs
17:06:37 <lambdabot>   *Exception: how about this? isn't this strange?
17:06:54 <Nereid> not strange at all
17:06:57 <maukd> parcs`: what would you use it for?
17:07:31 <Nereid> because, say, error "..." ⊑ -1
17:08:05 <ion> > [0,1 .. -42]  -- it will check whether -42 is reached for the first elements, too.
17:08:06 <lambdabot>   []
17:08:13 <maukd> typoclass: if short syntax is what you're after, I propose (.?.) = enumFromTo'. then you can write 9 .?. 5
17:08:25 <maukd> the ? stands for "I have no idea WTF this thing is doing"
17:08:29 <Nereid> haha
17:08:32 <johnw> joeyh: ping
17:08:53 <parcs`> maukd: in place of 'enumFromThenTo a (pred a) b' or 'reverse (enumFromTo a b)'
17:09:23 <maukd> parcs`: that would be broken
17:09:36 <maukd> enumFromTo' is different from either of those
17:09:38 <kyagrd> > let xs = [False,True, error "okay this works"] = take 2 xs
17:09:39 <lambdabot>   <no location info>: parse error on input `='
17:09:42 <parcs`> oh, okay i see what you're asking
17:09:44 <kyagrd> > let xs = [False,True, error "okay this works"] in take 2 xs
17:09:45 <lambdabot>   [False,True]
17:09:54 <kyagrd> Int was not good
17:10:09 <shachaf> <elliott> > let in shachaf please
17:10:12 <parcs`> yeah, it would be kind of useless or at least cumbersome to use
17:10:39 <maukd> I'm not opposed to an enumToFrom variant or something like that
17:11:23 <Nereid> > [False,False..True]
17:11:24 <lambdabot>   A section must be enclosed in parentheses thus: (`False..` True)Not in scop...
17:11:26 <shachaf> (LOOP FOR X FROM 10 DOWNTO 1 COLLECTING X)
17:11:30 <Nereid> what?
17:11:33 <parcs`> i see the light now
17:11:35 <maukd> Nereid: SPACES
17:11:39 <shachaf> > [False, False .. True]
17:11:42 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,False,False,Fa...
17:11:45 <Nereid> oh weird.
17:11:53 <Nereid> oh yeah.
17:11:56 <Nereid> hahaha.
17:12:21 <Nereid> > [True, True ... False]
17:12:23 <lambdabot>   Not in scope: `...'
17:12:23 <kyagrd> . is space sensitive
17:12:24 <Nereid> > [True, True .. False]
17:12:25 <lambdabot>   []
17:12:27 <maukd> module False where (.) = ...
17:12:29 <Nereid> > [True, True .. True]
17:12:30 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
17:12:32 <Nereid> > [True, True .. undefined]
17:12:33 <lambdabot>   *Exception: Prelude.undefined
17:12:49 <Nereid> > [False,False .. undefined]
17:12:50 <lambdabot>   *Exception: Prelude.undefined
17:12:52 <Nereid> > [False,True .. undefined]
17:12:53 <lambdabot>   *Exception: Prelude.undefined
17:12:55 <Nereid> hm.
17:13:06 <Nereid> ergh.
17:13:33 <Nereid> > map (take 2) [f False False, f False True, f True False, f True True] where f x y = [x,y..undefined]
17:13:34 <lambdabot>   <no location info>: parse error on input `where'
17:13:41 <Nereid> > let f x y = [x,y..undefined] in map (take 2) [f False False, f False True, f True False, f True True]
17:13:42 <lambdabot>   [*Exception: Prelude.undefined
17:13:45 <Nereid> oh duh.
17:13:56 <parcs`> @src flip
17:13:59 <lambdabot> flip f x y = f y x
17:14:13 <parcs`> bah, that's not true
17:14:21 <parcs`> at least not in caleskell
17:14:29 <Adeon> are you doubting the computer
17:14:38 <typoclass> parcs`: isn't it some lambdabot special ... erm yeah, something with Functor
17:14:45 <maukd> :t flip
17:14:46 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
17:14:51 <parcs`> :t \f x -> fmap ($ x) f
17:14:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
17:14:58 <Nereid> @type \f x -> fmap ($x) f
17:14:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
17:15:02 <typoclass> Adeon: @src relies on a smallish plaintext file of sources, afaik
17:15:03 <Nereid> ah, beaten.
17:15:56 <shachaf> typoclass: Smallish? It's over two dozen kilobytes!
17:16:05 <glguy> :t (.)
17:16:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:16:19 <parcs`> :t fix (ap flip)
17:16:21 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
17:16:49 <maukd> löb?
17:16:57 <typoclass> shachaf: what's that in lolcat captions?
17:17:05 <maukd> :t \f x -> ($ x) . f
17:17:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
17:17:09 <parcs`> > fix (ap flip) [1, 2, head, (!!0) + (!!1)]
17:17:11 <lambdabot>   [1,2,1,3]
17:17:19 <parcs`> the power of caleskell
17:18:49 <maukd> :t \f x -> flip ask x . f
17:18:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
17:19:17 <Nereid> where ask = ($)
17:19:21 <Nereid> no wait.
17:19:39 <Nereid> :t \f x -> Prelude.flip ask x . f
17:19:40 <lambdabot> forall b c (f :: * -> *). (Functor f) => f (b -> c) -> b -> f c
17:19:43 <Nereid> eh ok
17:19:46 <Nereid> :t ask
17:19:48 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
17:20:31 <Nereid> :t \f x -> flip ask x Prelude.. f
17:20:32 <lambdabot> forall a c a1. (a1 -> a -> c) -> a -> a1 -> c
17:21:24 <parcs`> flip id x . f = ($ x) . f = fmap ($ x) f = flip
17:21:46 <maukd> :t \f x -> flip asks x . f
17:21:48 <lambdabot> forall b a (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
17:21:59 <Nereid> :t asks
17:22:01 <lambdabot> forall r a (m :: * -> *). (MonadReader r m) => (r -> a) -> m a
17:22:04 <maukd> ask == asks ∎
17:22:26 <Nereid> well yeah, both are id when m = (r ->)
17:22:43 <maukd> > asks ()
17:22:44 <lambdabot>   Couldn't match expected type `r -> a' against inferred type `()'
17:22:47 <maukd> > ask ()
17:22:48 <lambdabot>   ()
17:23:02 <Nereid> well asks has a more restricted type.
17:23:27 <maukd> ask : asks :: id : ($)
17:23:27 <parcs`> :t [flip flip flip flip flip {-5-}, flip flip flip flip flip flip {-6-}, flip flip flip flip flip flip flip {-7-}] {-8,9,10...-}
17:23:29 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) b1. (Functor f, Functor f1) => [f1 ((f (a -> b) -> a -> f b) -> b1) -> f1 b1]
17:23:35 <parcs`> they all have the same types!
17:23:47 <maukd> static typing is a sham!
17:24:33 <parcs`> i don't understand why that works and i don't want to
17:25:11 * maukd invents a homoironic language
17:25:28 <dmwit> :t flip flip flip flip flip
17:25:29 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) b1. (Functor f, Functor f1) => f1 ((f (a -> b) -> a -> f b) -> b1) -> f1 b1
17:25:33 <dmwit> :t flip flip flip flip flip flip
17:25:34 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) b1. (Functor f, Functor f1) => f1 ((f (a -> b) -> a -> f b) -> b1) -> f1 b1
17:25:57 <Nereid> not a surprise.
17:26:01 <Nereid> flip flip flip flip = flip flip flip.
17:26:11 <Nereid> by definition
17:26:19 <monochrom> wait, what, sham? homoironic?
17:26:41 <parcs`> :t [fmap fmap fmap fmap fmap fmap fmap fmap {-8-}, fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap {-12-}, fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap {-16-}]
17:26:42 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => [(a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))]
17:26:48 <dmwit> :t flip
17:26:49 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
17:26:50 <parcs`> dmwit: explain that!
17:27:10 <monochrom> this is getting weird
17:27:19 <dmwit> parcs`: Explain what?
17:27:26 <Nereid> parcs`: I just explained it.
17:27:27 <dmwit> You're surprised that two things have types that can be unified?
17:27:47 <monochrom> hehe
17:27:55 <Nereid> oh fmap
17:27:57 <parcs`> dmwit: oh i thought you were Nereid, same nick color
17:28:10 <parcs`> Nereid: explain that!
17:28:13 <Nereid> lol
17:28:22 <ion> You can’t explain that.
17:28:53 <shachaf> fmap goes in, fmap goes out
17:28:54 <parcs`> both of your nicks are this low contrast blue color that i can barely distinguish from black
17:29:19 <shachaf> parcs`: Funny, all of your nicks are grayish.
17:29:25 <shachaf> Except when you're talking to me.
17:29:33 <Nereid> no, all of your nicks are black
17:29:34 <ion> dmwit goes down, Nereid comes up. You can’t explain that.
17:29:34 <Nereid> !!
17:29:55 <parcs`> Nereid: also how does flip flip flip flip = flip flip flip ?
17:30:01 <Cale> @src flip
17:30:02 <lambdabot> flip f x y = f y x
17:30:06 <parcs`> :t [flip flip flip, flip flip flip flip]
17:30:08 <lambdabot> forall (f :: * -> *) b (f1 :: * -> *) a b1. (Functor f, Functor f1) => [f ((f1 (a -> b1) -> a -> f1 b1) -> b) -> f b]
17:30:08 * hackagebot perm 0.1.0.1 - permutation Applicative and Monad with many mtl instances  http://hackage.haskell.org/package/perm-0.1.0.1 (AndySonnenburg)
17:30:11 <Cale> put f = flip, x = flip, y = flip
17:30:20 <parcs`> oh
17:30:23 <parcs`> cool
17:30:28 <Nereid> anyway, easy
17:30:36 <Cale> Of course, the flip in lambdabot is generalised :)
17:30:45 <shachaf> "generalised"
17:30:51 <ion> :t [flip flip flip, flip flip flip flip, flip flip flip flip flip flip flip]
17:30:53 <lambdabot> forall (f :: * -> *) b (f1 :: * -> *) a b1. (Functor f, Functor f1) => [f ((f1 (a -> b1) -> a -> f1 b1) -> b) -> f b]
17:30:56 <Cale> > flip f x y
17:30:58 <lambdabot>   Ambiguous type variable `b' in the constraints:
17:30:58 <lambdabot>    `SimpleReflect.FromExpr ...
17:31:00 <Cale> > flip f x y :: Expr
17:31:02 <lambdabot>  Terminated
17:31:05 <Cale> war
17:31:06 <Cale> > flip f x y :: Expr
17:31:09 <lambdabot>   f y x
17:31:17 <shachaf> > flip f x i :: Expr
17:31:19 <lambdabot>   f i x
17:31:30 <Cale> hah
17:31:31 <maukd> Cale: did you see my ask/asks version?
17:31:33 <Nereid> :t iterate flip (flip fliip flip)
17:31:34 <lambdabot> Not in scope: `fliip'
17:31:36 <parcs`> so how does flip {n + 3} = flip {n + 4}
17:31:36 <Nereid> :t iterate flip (flip flip flip)
17:31:38 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1 -> b
17:31:38 <lambdabot>       Expected type: a -> a1 -> a -> b
17:31:38 <lambdabot>       Inferred type: (a -> a1 -> b) -> a1 -> a -> b
17:31:40 <Cale> maukd: nope
17:31:52 <maukd> :t \f x -> flip ask x . f
17:31:52 <Nereid> parcs`: apply the definition of flip to flip flip flip flip
17:31:53 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
17:31:55 <maukd> :t \f x -> flip asks x . f
17:31:56 <lambdabot> forall b a (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
17:31:58 <dmwit> parcs`: equality is symmetric
17:32:21 <parcs`> Nereid: what would x and y be?
17:32:24 <Nereid> flip f x y = f y x, now put f = x = y = flip
17:32:26 <maukd> parcs`: it's not flip {n + 4}, it's flip f x y = f y x
17:33:18 <parcs`> why does flip flip flip flip {-4-} = flip flip flip flip flip {-5-}
17:33:35 <dmwit> Because flip flip flip flip = flip flip flip
17:33:36 <Nereid> parcs`: apply flip^4 = flip^3 to flip
17:33:39 <Nereid> :t iterate ($ flip) (flip flip flip)
17:33:40 <lambdabot>     Occurs check: cannot construct the infinite type:
17:33:41 <lambdabot>       b = (f (a -> b1) -> a -> f b1) -> b
17:33:41 <lambdabot>     Probable cause: `$' is applied to too many arguments
17:33:43 <Nereid> aw.
17:34:04 <dmwit> flip^5 = (flip^4) flip = (flip^3) flip = flip^4
17:34:25 <parcs`> dmwit: can you go one step further?
17:34:29 <parcs`> flip flip flip flip = flip flip flip ==> ?
17:34:31 <Nereid> if f = g, then f x = g x
17:34:44 <Nereid> now take f = flip^4, g = flip^3, x = flip
17:35:36 <parcs`> oh
17:35:39 <dmwit> flip flip flip = (\f x y -> f y x) flip flip = (\x y -> flip y x) flip = (\y -> flip y flip) -- this is what you can do
17:35:39 <parcs`> awesome
17:36:02 <parcs`> thanks!
17:36:03 <ivanm> with hsc2hs, if I have a C struct that contains a pointer, will #{ptr myStruct, structField} give me the actual pointer, or a pointer to the pointer?
17:36:23 <elliott> ivanm: i think the latter
17:36:51 <ivanm> elliott: that's what I was afraid of...
17:36:56 <mapf> it is possible to give a unique name to each function in module with TH?
17:37:23 <shachaf> parcs`: I think the explanation for the fmap fmap fmap thing is that (.) is associative.
17:37:25 <mapf> function with the given type of course
17:37:53 <parcs`> so why does fmap {8 + 4n} = fmap {8} ?
17:37:57 <parcs`> shachaf: elaborate!
17:38:19 <shachaf> parcs`: Well, for one, it happens with (.) instead of fmap.
17:38:28 <shachaf> You might find that version easier to think about. :-)
17:38:46 <parcs`> that's a lot of boobs
17:39:01 <ion> I like how the sugarhaskell package on Hackage installs Java files and a thin wrapper written in Haskell that runs java.
17:39:33 <ion> More packages should do that.
17:39:49 <parcs`> @let fmaps = (.)(.)(.)(.)(.)(.)(.)(.)
17:39:51 <lambdabot>  Defined.
17:39:53 <parcs`> :t fmaps
17:39:55 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
17:40:02 <parcs`> damn it
17:40:08 <shachaf> thanks Cale
17:40:22 <lispy> ion: I don't understand, could you please elaborate
17:40:24 <mapf> so it seems i need to lift the whole module in quotation and then attach names
17:40:25 <dmwit> ?let f' = (Prelude..); f's = f' f' f' f' f' f' f' f'
17:40:26 <lambdabot>  <local>:5:5: Not in scope: `Prelude..'
17:40:27 <dmwit> :t f's
17:40:28 <lambdabot> Not in scope: `f's'
17:40:37 <dmwit> ?let f' = Prelude.(.); f's = f' f' f' f' f' f' f' f'
17:40:38 <shachaf> (P..)
17:40:38 <lambdabot>  <local>:5:5: Not in scope: data constructor `Prelude'
17:40:47 <dmwit> ooookay
17:40:53 <parcs`> fmaps (.)(.)(.)(.) = (fmaps . (.)) (.)(.) = fmaps . (.) . (.) = fmaps . ((.) . (.))
17:40:54 <dmwit> ?let f' = (P..); f's = f' f' f' f' f' f' f' f'
17:40:54 <lambdabot>  <local>:5:5: Not in scope: `P..'
17:40:59 <shachaf> Hmm.
17:41:09 <ion> lispy: Understand what?
17:41:15 <dmwit> > (3 P.. 4) 5
17:41:16 <lambdabot>   3
17:41:21 <dmwit> ...what
17:41:21 <lispy> ion: sugarhaskell
17:41:32 <parcs`> = ?
17:41:33 <ion> @hackage sugarhaskell
17:41:33 <lambdabot> http://hackage.haskell.org/package/sugarhaskell
17:41:34 <shachaf> @ty let (f.g)x=f(g x) in (.) (.) (.) (.) (.) (.) (.) (.)
17:41:36 <lambdabot> forall t t1 t2 t3 t4. (t2 -> t3) -> (t -> t1 -> t4 -> t2) -> t -> t1 -> t4 -> t3
17:41:39 <shachaf> There you go.
17:41:54 <dmwit> ?let f' x y = x P.. y
17:41:55 <lambdabot>  <local>:5:11: Not in scope: `P..'
17:41:59 <dmwit> bah
17:42:41 <parcs`> fmaps . ((.) . (.)) = ? = fmaps
17:42:42 <lispy> ion: You said more packages should do what it does, but I don't understand what it does that you like. I just read the description on hackage and I also can't tell what problem it addresses.
17:43:05 <ivanm> elliott: so I can then use peek on that to get the actual pointer, right?
17:43:16 <shachaf> parcs`: Anyway, it's because (.) is associative.
17:43:24 <ion> lispy: That was sarcasm.
17:43:26 <elliott> ivanm: I think so, yeah. But don't take my word for it, it's been ages since I used hsc2hs.
17:43:30 <typoclass> lispy: i believe what ion said was pure sarcasm. he is in fact surprised and irritated that it installed javaish stuff
17:43:43 <ivanm> fair enough
17:43:44 <ion> Well, not irritated really. Just amused.
17:44:02 <typoclass> ivanm: are you aware of http://www.haskell.org/ghc/docs/latest/html/users_guide/hsc2hs.html ? (just checking)
17:44:09 <lispy> aaaaah
17:44:14 <ivanm> typoclass: yeah, it's not exactly the clearest :)
17:44:19 <lispy> ion: that explains so much
17:44:22 <typoclass> ivanm: fair enough
17:44:35 <lispy> ion: guess my client filtered out your <sarcasm> tags
17:44:39 <kyagrd> repetitive dots in parens can invoke repetitive pattern phobia
17:44:47 <Nereid> regarding fmap
17:44:54 <Nereid> you can prove that fmap^6 = fmap^10
17:44:54 <ivanm> elliott: or I could just use #{peek ...} to get the pointer *facepalm*
17:45:06 <Nereid> by showing that fmap^6 x y = fmap^10 x y directly
17:45:14 <parcs`> :t fmap fmap fmap fmap fmap
17:45:16 <lambdabot> forall a (f :: * -> *) a1 b. (Functor f) => (a1 -> b) -> (a -> a1) -> f a -> f b
17:45:17 <Nereid> (you'll need to use fmap (f . g) = fmap f . fmap g once)
17:46:08 * shachaf wonders whether a^5 should mean (a a a a a) or (a (a (a (a a))))
17:46:32 <dmwit> "should"?
17:46:37 <lispy> ion: okay yeah. I like that their thesis is roughly "no one makes syntax extensions to haskell because that would require extra tools". Followed by, so we made a tool for that, but in Java so no one will want to use it because that would require installing a JVM.
17:46:45 <dmwit> If we're going by "should", a^5 should mean (a . a . a . a . a).
17:47:03 <Nereid> I'm being lazy and writing a^t to be a a a a a
17:47:07 <Nereid> a^5
17:47:13 <shachaf> dmwit: Er, right.
17:47:14 <parcs`> it should mean a*a*a*a*a surely
17:47:15 <shachaf> That.
17:47:17 <ion> lispy: hehe
17:47:22 <ski> shachaf : (loop ((for x (down-from 10 (to 1))) (for result (listing x))) => result) ; => (9 8 7 6 5 4 3 2 1)
17:47:24 <typoclass> shachaf: can i interest you in a huge factfree argument what [a..5] should mean?
17:47:27 <lispy> OSX is the only platform where I don't mind using java and that's only because apple installed it for me
17:48:45 * ski . o O ( `(($ a) ^ 5) id' )
17:49:26 <lispy> ion: in other news, I've been meaning to look at idris's idiom brackets to see a) what is provided, b) if it could/should be ported to GHC
17:49:27 <ivanm> what happens if I don't free memory I allocated using the Foreign stuff?  will it get freed when ghci quits? (or my program finishes when I compile it)
17:50:17 <lispy> ivanm: any unfreed memory is always collected by the time the process exits. ForeignPtr has a finalizer that will free the memory.
17:50:22 <ion> lispy: I’d love to have something like (| a `x` b |) = liftA2 x a b in GHC Haskell.
17:50:44 <ivanm> lispy: *nod* I'm just using Ptr though
17:51:01 <lispy> ?hoogle Ptr a -> ForeignPtr a
17:51:01 <lambdabot> Foreign.ForeignPtr newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)
17:51:01 <lambdabot> Foreign.Concurrent newForeignPtr :: Ptr a -> IO () -> IO (ForeignPtr a)
17:51:01 <lambdabot> Foreign.ForeignPtr newForeignPtr :: FinalizerPtr a -> Ptr a -> IO (ForeignPtr a)
17:51:02 <ivanm> is nullPtr the correct way of getting a new Ptr value which gets malloc'd on the C side?
17:51:23 <lispy> ivanm: nullPtr is basically the value 0
17:51:45 <lispy> ivanm: You probably need a Ptr (Ptr a)
17:52:06 <lispy> ivanm: if you are supposed to allocate the pointer, than you typicall want alloca
17:52:13 <ivanm> ahhh, OK
17:52:20 <ski> or something like `Foo -> IO (Ptr Bar)', i suppose
17:52:52 <elliott> <ion> lispy: I’d love to have something like (| a `x` b |) = liftA2 x a b in GHC Haskell.
17:53:01 <elliott> she can do this! (she has all kinds of annoying foibles that will make you not want to use it.)
17:53:16 <ivanm> I have a Ptr Foo, and a foreign function of type Ptr Foo -> Ptr Bar -> IO () which will malloc the Bar value
17:53:24 <ivanm> so I just need the Ptr Bar value to pass in
17:53:30 <lispy> elliott: hehe. Yeah, I heard connor said that he prototypes in Agda and then codes it up in SHE :)
17:53:57 <lispy> elliott: at least for the harder things. I guess Agda is nicer for understanding why something doesn't type check
17:53:59 <ion> I’ve tried she, but having a dependency on an external preprocessor seems more trouble than it’s worth, and it did have some annoying issue i don’t remember anymore.
17:54:15 <elliott> Its error messages are quite bad IIRC.
17:54:40 <lispy> ivanm: Hang on. Something you said doesn't make sense to me yet.
17:54:45 <ski> ivanm : `malloc' will conjure up a new pointer, you'll either need `IO (Ptr Bar)' in the result, or `Ptr (Ptr Bar)' or `Ptr Bar -> IO ()' or something similar as an argument
17:55:09 <lispy> ivanm: In C that would be like, void blah(Foo *foo, Bar *bar);
17:55:29 <ivanm> lispy: yes, that's what I have
17:55:36 <ski> ivanm : and it won't work
17:55:44 * ivanm is quite aware that he's probably not doing something right here :p
17:55:52 <lispy> ivanm: and if blah assigned a value to bar, like bar = malloc(N); then the caller wouldn't actually be able to see this assignment when blah returns.
17:55:55 <ivanm> ski: *facepalm* I get you now
17:55:56 <ski> ivanm : C needs to be able to tell the new pointer to Haskell, somehow
17:56:28 <lispy> ivanm: Do you know why C programming is hard yet?
17:56:31 <lispy> :)
17:56:41 <ivanm> I'm quite aware, yes :)
17:57:05 <ivanm> OK, I can get rid of that malloc call in my C code, but my Bar struct has pointers in there; I still need to malloc those though, right?
17:57:06 <shachaf> C programming is easier than C-Haskell interoperation.
17:57:32 <ski> ivanm : probably
17:57:41 <lispy> ivanm: It's hard to say with only that description
17:57:56 <ivanm> OK, now my peek definition doesn't seem to work...
17:58:29 <lispy> ivanm: Have you ever seen the box diagrams that people draw for pointers? It might help you visualize this.
17:58:56 <lispy> ivanm: I bet you could whip up a diagram like that in graphviz in minutes
17:59:03 <kyagrd> is there a way to invoke unlit separately?
17:59:25 <lispy> kyagrd: Yes, although I haven't done that for years and I forgot how
17:59:29 <kyagrd> When I ask ghc --help it says it call call unlit, CPP or other phase
17:59:38 <kyagrd> but I can't find it in the guide
18:00:05 <kyagrd> there is a -cpp option but not the unlit
18:00:59 <lispy> Sorry that I have to run. The US presidential debate starts now.
18:01:06 <ivanm> lispy: heh, quite probably :)
18:01:15 <ivanm> oh, that sounds _thrilling_ :s
18:01:27 * ivanm needs to start reading up on political stuff for the local election on Saturday
18:02:08 <kyagrd> lispy: Ah, there is a separte binary unlit
18:03:58 <kyagrd> lispy: but no documentation though, somehow used by ghc
18:10:20 <Csigusz> hmm, why use C/C++ when there is Haskell?
18:10:48 <MostAwesomeDude> Csigusz: Patching existing C libraries.
18:11:14 <Csigusz> ah, that is the only reason?
18:11:16 <Csigusz> :)
18:11:47 <ivanm> in my case, because I need to benchmark my Haskell implementation against a non-existant possible C implementation
18:11:51 <ivanm> by trying to duplicate one function
18:11:58 <ivanm> which assumes immutable values
18:12:05 <ivanm> which is thus causing my current dilemma :s
18:12:23 <ivanm> I have a perfectly fine and capable Haskell implementation already!
18:12:30 <Csigusz> hehe
18:12:39 <ski> (.. what is the dilemma ?)
18:12:51 <ivanm> ski: why my FFI stuff doesn't work :p
18:13:23 * ski doesn't see how that is a dilemma
18:13:31 <ivanm> well, maybe dilemma is the wrong word
18:13:48 <startling> ivanm: do you need to compare it against something?
18:13:52 <startling> or are you making a point
18:14:26 <ivanm> hmmmm..... if I have in C "struct Foo { Bar *bar }", will using alloca/with/malloc/etc. on the Haskell side actually set aside memory for the Bar value, or just enough for a pointer to it?
18:15:08 <ivanm> gah, worked out one reason my code was wrong; in my cloning method I had the src and dest variables the wrong way round :s
18:15:18 <startling> ivanm: just enough for a pointer to it, I think
18:16:01 <startling> ivanm: you'd need to alloca the room for the Bar in poke, I think
18:16:08 <startling> er well, no
18:16:13 <startling> I don't actually no what you'd do
18:17:52 <ivanm> startling: making a point; the reason I'm bothering with the marshalling is so that I can specify the initial input value in Haskell and use it for botht he Haskell and C implementation
18:18:10 <ivanm> hmmmm.... if it's just enough for a pointer, then I wonder why in this other case it works... oh well :)
18:27:12 <BMeph_> ivanm: "It's C; it's probably not doing what you think it is. It's certainly not doing what you think it should." ;)
18:27:24 <ivanm> heh
18:29:03 <ski> > even (floor (0 / 0))
18:29:04 <lambdabot>   True
18:29:25 <mm_freak> > floor (0/0)
18:29:26 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
18:29:34 <byorgey> hehe
18:29:45 <mm_freak> > 0/0
18:29:46 <lambdabot>   NaN
18:29:53 <byorgey> > length . show . floor $ 0/0
18:29:54 <startling> > even NaN
18:29:55 <lambdabot>   Not in scope: data constructor `NaN'
18:29:55 <lambdabot>   310
18:30:01 <startling> how do you get NaN?
18:30:02 <mm_freak> floor actually gives me a number for NaN?
18:30:09 <mm_freak> startling: 0/0
18:30:11 <ski> > read "NaN" :: Double
18:30:12 <byorgey> startling: by dividing 0/0, or other such nonsense
18:30:13 <lambdabot>   NaN
18:30:21 <latro`a_> wtf
18:30:30 <startling> oh, you can't just pull it out of nowhere?
18:30:31 <startling> darn.
18:30:36 <mm_freak> > ceiling (0/0)
18:30:38 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
18:30:42 <startling> I assumed it was data Float = NaN | ...
18:30:49 <latro`a_> what type is the 0/0 in there
18:30:55 <mm_freak> ok, i just proved that NaN is an integer
18:31:05 <mm_freak> > floor (0/0) == ceiling (0/0)
18:31:05 <byorgey> latro`a_: Double, presumably
18:31:06 <lambdabot>   True
18:31:22 <latro`a_> :t floor
18:31:23 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
18:31:31 <ski> @type (0/0) `asAppliedTo` ceiling
18:31:32 <lambdabot> forall b a b1. (Fractional b, RealFrac a, Integral b1) => (a -> b1) -> b
18:31:33 <startling> oh. that makes sense
18:31:35 <latro`a_> so it's at least some RealFrac
18:31:40 <ski> hm
18:31:44 <startling> because NaN can't be turned into an Integral, really
18:31:47 <latro`a_> > floor (0/0 :: Float)
18:31:48 <lambdabot>   -510423550381407695195061911147652317184
18:31:51 <latro`a_> lol
18:31:57 <ski> @type (0/0) `asTypeIn` ceiling
18:31:58 <lambdabot> forall t. (RealFrac t) => t
18:31:59 <latro`a_> ceiling (0/0 :: Float)
18:32:06 <latro`a_> that's cute
18:32:10 <latro`a_> er
18:32:16 <latro`a_> > ceiling (0/0 :: Float)
18:32:18 <lambdabot>   -510423550381407695195061911147652317184
18:32:20 <mm_freak> RealFrac should really throw exceptions instead of producing nonsense
18:32:29 <mm_freak> at least for Double and Float
18:32:34 <latro`a_> so apparently NaN is an integer, who'd have thunk it
18:32:47 <typoclass> mm_freak: i was thinking the same
18:32:51 <ivanm> BMeph_: and I just found a bug in my C code :p
18:33:25 <ivanm> (admittedly, the analogous bug would have occured in Haskell as well; getting an edge and its inverse mixed up)
18:33:47 <mm_freak> ivanm: if the finding of a bug is the realization that a bug is there, then i haven't actually spent a lot of time on finding bugs
18:34:31 <mm_freak> fixing them on the other hand…  you know, C programmers lose 2/3 of their day on average
18:34:42 <mm_freak> 1/3 to fixing bugs, 1/3 to having nightmares about them
18:34:54 <ion> > toRational (0/0)
18:34:55 <lambdabot>   (-2696539702293473861593957786183537100426965468413459859101451217365990137...
18:35:10 * hackagebot git-annex 3.20121017 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20121017 (JoeyHess)
18:39:59 <Vyn> @let swap i j list | i < j = hs ++ (y:xs) ++ (x:ys)| otherwise = swap j i list where (hs, zs) = (take i list, drop i list); (x:xs, y:ys) = (take (j - i) zs, drop (j - i) zs)
18:40:01 <lambdabot>  Defined.
18:40:02 <ivanm> mm_freak: no, I knew there was a bug, but I thought it was on the FFI side
18:40:17 <ivanm> but then was looking at the code to double-check that and spotted that I was using e rather than ei as an index
18:41:58 <latro`a_> vyn--you could probably just do a let with min/max instead of the recursion
18:42:39 <latro`a_> > let xs = [1..10] in (take 2 xs,drop 2 xs)
18:42:41 <lambdabot>   ([1,2],[3,4,5,6,7,8,9,10])
18:42:46 <latro`a_> > splitAt 2 [1..10]
18:42:47 <lambdabot>   ([1,2],[3,4,5,6,7,8,9,10])
18:42:53 <latro`a_> ^also that
18:43:25 <Vyn> > splitAt 3 [10,9..1]
18:43:26 <lambdabot>   ([10,9,8],[7,6,5,4,3,2,1])
18:43:30 <Vyn> Ah! Thank you
18:43:39 <mm_freak> > map (`mod` 2) . iterate (\x -> mod (x^2) (2^60 + 33)) $ 2^40
18:43:41 <lambdabot>   [0,1,0,1,1,1,0,1,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,1,...
18:44:15 <Vyn> But latro`a_, is the overall logic good, or is there a better way of swapping?
18:44:33 <latro`a_> > swap 2 1 [1,2,3]
18:44:35 <lambdabot>   [1,3,2]
18:44:44 <latro`a_> ah, I see
18:45:09 <byorgey> Vyn: it's a strange operation to do on singly-linked lists.
18:45:15 <latro`a_> it is that, yeah
18:45:47 <latro`a_> that said, I think I'd probably split into three instead
18:46:02 <Vyn> Yes. I was trying to write a function that generates a Fike's permutation from a Fike's sequence, and it's defined in terms of swapping
18:46:42 <latro`a_> split at i and then split at j (i.e. at j-i in the second part)
18:47:03 <latro`a_> then reconstruct
18:47:12 <latro`a_> not sure if that's much better really
18:47:25 <Vyn> latro`a_: Yes, now that you showed me splitAt, I see how to do that
18:47:32 <byorgey> Vyn: what is a Fike's permutation or a Fike's sequence?
18:48:33 <byorgey> oh, found it on google, never mind
18:48:51 <Vyn> byorgey: It's an algorithm for generating permutations
18:49:03 <Vyn> byorgey: Yeah, here's the original paper: http://comjnl.oxfordjournals.org/content/18/1/21
18:49:32 <byorgey> Vyn: right, it's kind of pointless coding it on lists in Haskell, because the whole point is that it's fast using swaps like that
18:49:41 <byorgey> Vyn: but swapping elements in a Haskell list is O(n)
18:49:57 <Vyn> byorgey: I'm not trying to generate all the permutations, I'm trying to generate just the n-th permutation under Fike's ordering
18:50:42 <sinelaw> hi, how would you name a function :: [Map k v] -> Map k [v] ?
18:50:55 <Jafet> If you can construct the permutation, use sorting to perform it.
18:51:07 <byorgey> Vyn: ah, well I think there is a better way to do that than via swapping.
18:51:25 <Vyn> byorgey: That's what I wanted to know
18:52:04 <Jafet> :t M.unionsWith
18:52:05 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [M.Map k a] -> M.Map k a
18:52:35 <Jafet> :t M.map join . M.unionsWith (++) . M.map return
18:52:37 <lambdabot>     Couldn't match expected type `[M.Map k (m (m a))]'
18:52:37 <lambdabot>            against inferred type `M.Map k1 (m1 a1)'
18:52:37 <lambdabot>       Expected type: M.Map k1 a1 -> [M.Map k (m (m a))]
18:52:38 <copumpkin> the monoid instance on Map is annoying
18:52:38 <byorgey> Vyn: basically you can convert n to "base factorial"
18:52:48 <byorgey> Vyn: e.g. see http://stackoverflow.com/questions/7918806/finding-n-th-permutation-without-computing-others
18:53:25 <byorgey> I'm off to bed though, hope that pointer is enough =)
18:53:35 <Jafet> :t fmap join . M.unionsWith (++) . fmap return
18:53:36 <lambdabot> forall (m :: * -> *) a k. (Monad m, Monoid (m (m a)), Ord k, Monad (M.Map k)) => [m (m a)] -> M.Map k (m a)
18:54:06 <Jafet> :t fmap join . M.unionsWith (++) . fmap (fmap return)
18:54:08 <lambdabot> forall (m :: * -> *) a k. (Monad m, Monoid (m (m a)), Ord k) => [M.Map k (m a)] -> M.Map k (m a)
18:54:55 <Vyn> byorgey: That works for lexicographical, which I did. This one is slightly different, in that the place values are not factorials, but some sort of reverse factorials (5!/2!, 5!/3!, 5!/4!, 5!/5!, for example)
18:55:04 <Vyn> byorgey: Okay, good night, and thank you! : )
18:55:54 <byorgey> Vyn: ah, ok.  If you don't figure it out ping me again tomorrow, I'd be interested to think about it more
18:56:12 <Vyn> byorgey: Sure! Thanks again :)
18:56:49 <sinelaw> hi, how would you name a function :: [Map k v] -> Map k [v] ?
18:56:56 <sinelaw> oops. disregard that.
18:57:47 <sinelaw> :t foldr (M.unionWith (++) . M.map (:[])) M.empty
18:57:49 <lambdabot> forall k a. (Ord k) => [M.Map k a] -> M.Map k [a]
18:58:20 <latro`a_> ...watch lambdabot butcher this...
18:58:32 <latro`a_> :t foldr (M.unionWith (++) . M.map return) M.empty
18:58:32 <Jafet> Quit monkeying around
18:58:33 <lambdabot> forall k a (m :: * -> *). (Monoid (m a), Ord k, Monad m) => [M.Map k a] -> M.Map k (m a)
18:58:40 <latro`a_> joy
19:00:35 <sinelaw> @hoogle Monoid (m a) => (m a) -> (m a) -> (m a)
19:00:36 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
19:00:36 <lambdabot> Language.Haskell.TH.Syntax qRecover :: Quasi m => m a -> m a -> m a
19:00:36 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
19:01:02 <Eduard_Munteanu> @hoogle sequence
19:01:03 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
19:01:03 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
19:01:03 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
19:01:24 <sinelaw> :t foldr (M.unionWith mplus . M.map return) M.empty
19:01:25 <lambdabot> forall (m :: * -> *) a k. (MonadPlus m, Ord k) => [M.Map k a] -> M.Map k (m a)
19:01:43 <byorgey> sinelaw: I would name it 'Data.Traversable.sequenceA' ;-)
19:01:43 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
19:04:00 <sinelaw> :t sequenceA
19:04:02 <lambdabot> Not in scope: `sequenceA'
19:04:21 <sinelaw> Applicative f => t (f a) -> f (t a)
19:04:32 <Vyn> Jafet: Sorry, I wasn't sure what you were saying, earlier. Now I see, I think. I'm not trying to apply a permutation to a list, I'm trying to generate the permutation of [1..n], in a particular way described by Fike
19:04:37 <sinelaw> byorgey, ok, what's the logic though?
19:06:07 <Eduard_Munteanu> sinelaw: replace t by [] and f by (Map k)
19:06:20 <byorgey> sinelaw: wait, sorry, that doesn't work, Map is Traversable but not Applicative
19:06:32 <byorgey> in this case it would be using the Traversable instance of List
19:07:40 <Eduard_Munteanu> :t traverse
19:07:42 <lambdabot> Not in scope: `traverse'
19:07:49 <Eduard_Munteanu> @hoogle traverse
19:07:49 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
19:07:49 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
19:07:49 <lambdabot> Control.Parallel.Strategies parTraverse :: Traversable t => Strategy a -> Strategy (t a)
19:08:05 <otters> @pl get' a b = fromJust (get a b)
19:08:06 <lambdabot> get' = (fromJust .) . get
19:08:06 <importantshock> Something that's vexing me: if a type A is a Monoid instance but not an Eq instance, is there any way to test to see whether a given A is equal to the empty element?
19:09:53 <blackdog> i'm trying to cobble together a web demo for a talk tomorrow - is there an explanation for how to avoid XSS with Blaze? I'm using Scotty for the routing etc, and while i'm not wedded to it, I don't want to shock people with the full-on yesod approach.
19:10:02 <Jafet> importantshock: no. Does that help?
19:11:24 <elvis4526> hi, how do I put one xmobar of each of my two screens in xmonad
19:11:38 <importantshock> Jafet: Confirmed my suspicions. Was frustrated that the Leijen pretty-printer (well, Kmett's Text.PrettyPrint.Free)  doesn't have an (isEmpty :: Doc -> Bool) method; thought it might have been hiding in the hierarchy of classes.
19:13:36 <edwardk> its tricky because isEmpty is basically impossible, because the decision to be empty can be contingent. there are constructors for things that can check the current offset or screen width
19:13:43 <edwardk> so those need a context
19:14:06 <Jafet> Oh, I was just thinking of the IO monoid
19:14:24 <Jafet> #xmonad
19:30:11 * hackagebot network-info 0.2.0.3 - Access the local computer's basic network configuration  http://hackage.haskell.org/package/network-info-0.2.0.3 (JacobStanley)
19:37:53 <minopret> Hi, I would search but Cale said I should ask some questions. So, does ghc optimize reverse snoc^n (to cons^n)?
19:38:13 <ion> @hoogle snoc
19:38:13 <lambdabot> Data.ByteString.Char8 snoc :: ByteString -> Char -> ByteString
19:38:13 <lambdabot> Data.ByteString.Lazy.Char8 snoc :: ByteString -> Char -> ByteString
19:38:13 <lambdabot> Data.ByteString snoc :: ByteString -> Word8 -> ByteString
19:38:59 <blackdog> minopret: are you talking specifically in the case of lists?
19:39:19 <ion> minopret: You could use -ddump-core and see what happens exactly.
19:39:19 <shachaf> That sounds like a bit of a magic optimization.
19:39:38 <minopret> yes I suppose I mean lists rather than ByteString, so maybe what I mean is not called snoc in Haskell?
19:40:07 <minopret> Anyway given lazy evaluation, why would it be magic to turn (reverse snoc ) into cons?
19:40:25 <minopret> Hmm, I mean (cons reverse), don't I.
19:40:28 <Cale> lazy evaluation is not magic
19:41:00 <shachaf> It might be lazy, but it's still evaluating the same code. :-)
19:41:40 <minopret> motivation: in Scheme or whatever I frequently find myself building a list backwards and then reversing the result.
19:41:50 <Cale> minopret: Yeah, that's slow.
19:42:04 <Cale> well... it might be faster than left associated (++) :)
19:42:07 <jmcarthur> it sounds like you need to use a different algorithm or data structure if you find yourself doing that often
19:42:09 <shachaf> minopret: In Scheme that's often necessary because you want to make things tail-recursive.
19:42:20 <minopret> exactly, tail calls.
19:42:21 <shachaf> Whereas in Haskell, because of laziness, you might not need to make them tail-recursive in the first place.
19:42:23 <jmcarthur> oh, i misread that. you are just talking about accumulators
19:42:30 <shachaf> minopret: For example, map:
19:42:33 <shachaf> @src map
19:42:33 <lambdabot> map _ []     = []
19:42:34 <lambdabot> map f (x:xs) = f x : map f xs
19:42:36 <Cale> minopret: But that's the backwards way to build a list in Haskell :)
19:42:48 <Cale> You *want* right-associated appends
19:42:51 <shachaf> That's actually a good definition -- a tail recursive map would be considered worse.
19:42:58 <shachaf> (For most purposes.)
19:43:01 <jmcarthur> (far worse)
19:43:11 <Cale> s/most/all/
19:43:19 <shachaf> There are some cases where it makes sense to make a tail-recursive-and-reversing map, aren't there?
19:43:22 <dolio> The problem with that definition is that it doesn't line up the brackets with the parentheses.
19:43:29 <Cale> well, okay, it would be better for the purpose of making your CPU hot
19:43:32 <jmcarthur> shachaf: i have never come across such a case
19:43:40 <shachaf> I think I saw an article about it somewhere.
19:44:31 <typoclass> dolio: how do you mean, line up?
19:44:46 <dolio> map _ [    ] = []
19:45:04 <dolio> map f (x:xs) = f x : map f xs
19:45:07 <Cale> heh
19:45:17 <typoclass> dolio: oh, a joke :) sorry, didn't catch that
19:45:28 <dolio> This is no joke!
19:45:29 <shachaf> map _ [{--}] = []
19:45:42 <shachaf> dolio never jokes, typoclass.
19:45:53 <Cale> I prefer never putting any space in the middle of  []
19:46:02 <shachaf> @quote eat.a
19:46:03 <lambdabot> dforsyth says: "c++ can eat a dick imo
19:46:07 <shachaf> @quote eat.a.comment
19:46:07 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
19:46:09 <dolio> I don't joke about lining up things in code, at least.
19:46:16 <shachaf> @forget dforsyth "c++ can eat a dick imo
19:46:17 <lambdabot> Done.
19:46:23 <dolio> Well, maybe sometimes.
19:46:35 <minopret> lambdabot channels people? THAT is a joke.
19:46:52 <Cale> @keal
19:46:52 <lambdabot> T could perform expressions 600mb and bigger
19:47:01 <Cale> @keal
19:47:01 <lambdabot> proofs are no longer sound
19:47:05 <blackdog> in soviet russia, people couldn't be bothered finishing this joke about lambdabot
19:47:21 <sinelaw> what's the "nice" way to write: f (Some x) = blablabla; f y = y   ?
19:47:33 <sinelaw> (I'm asking about the f y = y part)
19:47:38 <typoclass> dolio: you should send a patch to the ghc libraries folks rightaway
19:47:42 <shachaf> sinelaw: What's wrong with f y = y?
19:47:44 <Cale> sinelaw: what's wrong with what you wrote?
19:47:54 <minopret> f (Some x) = blablabla; please, f y = y
19:47:55 <typoclass> blackdog: in america, people couldn't ... bother ... erm
19:47:55 <dolio> typoclass: I'd be surprised if it looks like that in GHC.
19:48:04 <dolio> It's probably split into three different functions with rewrite rules.
19:48:12 <shachaf> map f = foldr ((:).f)
19:48:12 <dolio> I need to send a patch to the report committee.
19:48:25 <shachaf> dolio: Can you tell them to fix the "IO functions" thing while you're at it?
19:48:27 <Cale> sinelaw: anything nicer would have something to do with whichever type the 'Some' constructor belonged to, I think.
19:48:31 <shachaf> That's a harmless fix, surely.
19:48:51 <jmcarthur> i wish i could supply different numbers of arguments to different cases of the same function
19:48:52 <dolio> shachaf: It doesn't look like that, either. Needs to use build.
19:49:11 <jmcarthur> i could it might look funny
19:49:13 * shachaf wonders what happened to the whole stream fusion thing.
19:49:23 <jmcarthur> it's still there!
19:49:28 <jmcarthur> concatMap still sucks
19:49:30 <typoclass> dolio: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Base.html#map has a RULE, but map itself seems refreshingly straightforward :-P
19:50:05 <dolio> Heh.
19:50:35 <shachaf> map = undefined; {-# RULES "map" map = realMap #-}
19:51:04 <latro`a_> ....
19:51:07 <latro`a_> *shudder*
19:51:13 <jmcarthur> i wish there was a nicer syntax for replacing constructors with functions without having to bind fields to variables and all that
19:53:07 <Cale> length = cata [] -> 0; (x:xs) -> x + xs
19:53:08 <sinelaw> Cale, I was wondering if there's a way to use id nicely
19:53:11 <jmcarthur> foldr f z = case rec { (:) -> f; [] -> z }   -- a bonus recursive syntax!
19:53:46 <jmcarthur> cata is the appropriate name for this case rec thing i guess
19:54:29 <dolio> Or fold.
19:54:32 <Cale> If there was a second syntax and we named it cata' would that be a catastrophe?
19:54:34 <jmcarthur> bah
19:54:39 <dolio> Of course, cata isn't taken.
19:54:56 <dolio> Well, not by commonly used stuff.
19:55:05 <dolio> It's probably in an edwardk library somewhere.
19:55:15 <edwardk> which?
19:55:19 <dolio> cata
19:55:20 <shachaf> @remember Cale If there was a second syntax and we named it cata' would that be a catastrophe?
19:55:20 <lambdabot> Done.
19:55:58 <dolio> Cale: Also that's sum.
19:56:13 <typoclass> Cale: that's hypothetical, right? (not one of the 7.6 syntax extensions)
19:56:28 <Cale> dolio: derp, you're right
19:56:40 <shachaf> typoclass: Extensions that are actually implemented are too mainstream for #haskell
19:56:41 <Cale> I meant to write 1+xs of course
19:57:17 <Cale> sum is good, but it doesn't show off the use of pattern matching in the syntax quite as much
19:57:32 <minopret> Hmm, what else to ask. Is it intentional or just a nice coincidence that Scala and Haskell interchange the meanings of : and ::, as well as -> and =>? :-)
19:57:53 <dolio> : is by far more standard.
19:57:55 <typoclass> shachaf: "i liked the extension better before it was implemented" <- language hipster
19:57:56 <ski> Cale : needs to support para
19:57:57 <shachaf> Haskell got it wrong.
19:58:02 <Cale> You'd have to ask Odersky
19:58:09 <Cale> I think Haskell got it right.
19:58:29 <shachaf> Cale: Types are much more important than lists.
19:58:33 <Cale> You rarely have more than one :: on a line
19:58:53 <dolio> Not in Scala! Boom!
19:59:59 <Cale> Maybe if Haskell were dependently typed and we had terms with type signatures occurring inside types, then : would be better
20:00:24 <shachaf> Maybe Haskell should support naming parameters even if it's not dependently typed.
20:00:47 <shachaf> foo : (something : Int) -> (somethingElse : Int) -> Int
20:01:13 <lispy> shachaf: wouldn't that be redundant with the value level?
20:01:22 <ski>   map (fun :: a -> b) (list :: [a]) :: [a]  -- imagine the fun
20:01:25 <shachaf> lispy: One of them is not exported.
20:01:32 <minopret> looks like Scala is consistent with Standard ML, not that I would know whether that's good or bad.
20:01:35 <lispy> shachaf: or does this allow you to pass parameters by name?
20:01:49 <shachaf> lispy: It would be just like Agda except you couldn't use the names.
20:01:51 <ski> (i suppose s/\) :: [a]/\) :: [b]/ would be nice)
20:01:59 <typoclass> shachaf: i want that! it's sometimes gets difficult to read if you have all the eleventy types on the "foo :: " line(s), and on the "foo ... = " line all the names for them
20:02:06 <lispy> shachaf: My Agda-fu is too weak to understand
20:02:27 <shachaf> lispy: You don't need much Agda-fu to understand it. Agda lets you name a parameter in the type.
20:02:44 <shachaf> lispy: The reason it lets you do it is that you can also *use* that parameter in the type. But that's a different matter. :-)
20:02:59 <dolio> minopret: It's also consistent with Agda, Epigram, Cayenne, and just about every paper on type theory.
20:03:09 <lispy> shachaf: ah yeah. Agda doesn't have the same type/value division.
20:03:15 <shachaf> dolio: And the usual mathematical function notation.
20:03:20 <dolio> That too.
20:03:35 <dolio> Coq....
20:03:35 <minopret> OK, well at least that gives me a mnemonic. Thanks.
20:03:40 <dolio> NuPRL.
20:03:42 <dolio> Twelf.
20:03:51 * shachaf doesn't actually know any Agda, really, just "whoa, dude, what if Haskell had dependent types, man?"
20:04:04 <shachaf> (And was total.)
20:04:16 <shachaf> (And was good instead of bad.)
20:04:44 <typoclass> shachaf: i hear that's coming out in 7.8
20:04:54 <dolio> Did Miranda use : or ::? I can't remember.
20:05:11 <shachaf> ::
20:05:11 <minopret> It's fun to write an interpreter in a total language. You just tell it to run up to a bazillion times and when that isn't enough you decide whether to ask it for a bazillion more.
20:05:15 <shachaf> That's probably where Haskell got it.
20:05:27 <shachaf> Miranda also had the great * thing.
20:05:45 <shachaf> That was good syntax, man.
20:05:59 <dolio> Of course, Miranda had numbered type variables where the numbers were unary strings of *.
20:06:05 <shachaf> I'd like to see some edwardk-style code written with Miranda *s.
20:06:40 <dolio> fmap :: Functor * => (** -> ***) -> * ** -> * ***
20:07:07 <lispy> dolio: that must take some getting used to
20:07:37 <shachaf> Miranda was never "used", was it?
20:07:56 <lispy> On the subject of => vs. ->. I think if we matched math, that -> is the correct arrow for function signatures and |-> would be closer to correct for lambdas.
20:08:16 <lispy> But, I'd hate to type |-> all the time
20:08:33 <dolio> loop : Arrow *** => *** (*, **) (****, **) -> *** * ****
20:08:43 <shachaf> lispy: Let's not match the mathematical notation *too* closely.
20:08:44 <minopret> how about typing λ all the time
20:08:44 <ski> lispy : yes, i think `UnicodeSyntax' ought to allow `↦' in lambdas
20:08:46 <dolio> What could be clearer?
20:09:07 <typoclass> dolio: mud, for instance?
20:09:54 <lispy> as for :: vs. :, I could go either way. I don't see the extra : as a problem.
20:10:11 <dolio> Math doesn't usually use lambda, though, so you could drop it.
20:10:20 <dolio> Or if you want to stick to lambda calculus tradition, you'd use a .
20:10:27 <lispy> I don't use : for cons as often as I type type signatures, so maybe a switch would be more economic
20:10:46 <minopret> ok, another goofy question, not sure whether more or less so: where is Haskell on the issue of "a functional programmer knows the value of everything and the cost of nothing"
20:11:02 <dolio> lispy: I think the original argument was the exact opposite of that. :)
20:11:06 <Cale> minopret: It applies :)
20:11:11 <shachaf> Let's compromise on : for type and ∷ for cons.
20:11:15 <shachaf> The way Agda does it.
20:11:15 <minopret> bwahaha
20:11:22 <lispy> dolio: yes it was. But, in practice we put in way more types that we were expected to
20:11:27 <Cale> minopret: Well... to the standard at least :)
20:11:29 <lispy> than*
20:11:33 <minopret> yet I still want to learn Haskell, so that's something.
20:11:40 <Cale> minopret: Haskell doesn't specify how anything actually executes
20:11:51 <typoclass> minopret: haskell functional programmers are so lazy, they don't know the value of anything yet
20:11:55 * lispy assumes that all the boxes with question marks mean what he wants them to mean
20:12:00 <ski> dolio : there was some paper that suggested (e.g.)  `∀ x. P(x)' be interpreted as `∀ (x. P(x))', where the bracketed part would be a function expression
20:12:02 <Cale> minopret: It just says what the results of programs are, and lets the implementations do whatever they want which has the same termination behaviour and result.
20:12:03 <lispy> I wonder if upgrading putty would help
20:12:44 <dolio> ski: Well, in some cases it's literally that.
20:12:46 <Cale> minopret: So in order to understand performance, you have to understand the implementation. But it's not quite so bad as that, because there are a bunch of models which are higher level than that and which do quite a good job of modelling it.
20:12:48 <dolio> With poorer syntax.
20:12:53 <dolio> Agda 1, for instance.
20:13:12 <lispy> minopret: if we're talking GHC, Haskellers have figured out how to get good performance, but it's true that we delay thinking about that till its demanded.
20:13:13 <dolio> And Agda 2's sigma.
20:13:23 <minopret> and I have to get over my recent affection for tail calls.
20:13:27 <shachaf> Agda 2's Sigma?
20:13:32 <Cale> minopret: For example, there's the extremely glib way of looking at things where you just imagine expressions being rewritten over and over.
20:13:49 <ski> lispy : `↦' was the unicode version of `|->'
20:13:53 <shachaf> minopret: Do you understand why you want to write map the way it is, rather than the tail-call way?
20:14:02 <dolio> Σ A \x -> B
20:14:10 <Cale> minopret: If you do that with outermost-first evaluation, and you're careful to implement sharing with 'let', then you get a very decent model of how programs will actually perform.
20:14:11 <lispy> ski: cool. I figured.
20:14:33 <ski> dolio : hm, i don't recall that from Agda1 -- iirc it was always `\(x :: A) -> ..x..'
20:14:37 <Cale> (where time corresponds to the number of rewrite steps, and space corresponds to the number of symbols it takes you to write things down)
20:14:39 <shachaf> Is that a different thing from (x:A) -> B?
20:14:56 <minopret> I actually wrote foldr using only atom car cdr cond cons eq quote, and yet no, I don't understand why I want to write map at all, but let me re-read your explanations :-)
20:15:06 <ski> dolio : oh, missed "poorer syntax". ok
20:15:31 <dolio> ski: I'm pretty sure it was closer to a logical framework, and Pi was a two argument type that expected a function.
20:15:57 <Cale> minopret: In fact, let me take you through an evaluation of foldl to see why tail calling might not always work out how you might want
20:15:57 <ski> shachaf : yes, it's `(x : A) * B'
20:16:07 <Cale> @src foldl
20:16:07 <lambdabot> foldl f z []     = z
20:16:07 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
20:16:07 <shachaf> Oh, I confused sigma with pi.
20:16:16 <Cale> foldl (+) 0 (1:2:3:[])
20:16:20 * shachaf sighs.
20:16:26 <shachaf> One day I'll learn the Greek alphabet!
20:16:28 <ion> * shachaf sigmas
20:16:30 <Cale> -> foldl (+) (0 + 1) (2:3:[])
20:16:38 <Cale> -> foldl (+) ((0 + 1) + 2) (3:[])
20:16:39 <shachaf> kill -SIGMA ion
20:16:47 <Cale> -> foldl (+) (((0 + 1) + 2) + 3) []
20:16:48 <ion> * sigmaf sigmas.
20:16:51 <ski> dolio : yes. though in Alfa you can add some syntactic sugar on top of it
20:16:54 <Cale> -> ((0 + 1) + 2) + 3
20:17:15 <Cale> now, up to this point, the program has used no stack space at all in GHC's implementation
20:17:29 <Cale> but now it's going to :)
20:17:32 * ski . o O ( shachaf-algebras )
20:17:49 <minopret> what, it destructively rewrote the expression?
20:17:50 <Cale> because (+) needs to pattern match on both its arguments to evaluate, and the first one isn't evaluated yet
20:18:26 <Cale> Yeah, the implementation in GHC has a representation of expressions in memory and they get rewritten destructively.
20:18:39 <minopret> ok
20:19:18 <Cale> Every expression is a code pointer, when you evaluate it, you enter the code, and the code computes a value and updates the pointer to a shorter piece of code which returns the value immediately
20:19:24 * ski wants constructively rewritten expressions ..
20:19:47 <Cale> But you rarely have to think at that level, because it's easier just to picture expressions being rewritten successively.
20:20:09 <minopret> code pointer... *thinks "thunk"*
20:20:31 <Cale> yeah
20:21:04 <Cale> That's the generic term for "implementation mechanism for runtime representation of expressions"
20:21:13 <Cale> but I'm happier just to call the things expressions
20:22:35 <minopret> I should get a St. Gregory Chaitin medal that I can rub for luck at times like these (no disrespect)
20:23:12 <Cale> So, at this point (...) + 3 will get put on the stack
20:23:22 <Cale> and then (...) + 2
20:23:29 <Cale> and then 0 + 1 will evaluate to 1
20:23:35 <Cale> and then 1 + 2 will evaluate to 3
20:23:42 <Cale> and then 3 + 3 will evaluate to 6
20:24:14 <minopret> ok. and so we return to the moral of the story, which I have fully forgotten.
20:24:37 <Cale> and if the nested expression full of strict functions you constructed while the foldl did nothing but call itself over and over with new parameters was gigantic, you'd be threatened with stack overflow
20:25:01 <minopret> ok
20:26:00 <minopret> so the alternative to attempting tail calls is to relax and write something less contrived
20:27:44 <minopret> or something
20:28:41 <Cale> minopret: Okay, so in *this* case, of adding numbers
20:28:56 <Cale> there's no way to produce part of a number having looked at only the first part of the list
20:29:17 <Cale> So we really do want foldl, but we'd be better off with a stricter variant of it.
20:30:03 <Cale> So, we either turn on optimisations and let the compiler's strictness analysis figure this out, or we use the explicitly strict foldl'
20:30:06 <startling> can I have a class where a method returns some w specific to that class?
20:30:20 <startling> and have another method that takes that w
20:30:30 <Cale> startling: Do you mean specific to each instance?
20:31:04 <sinelaw> @hoogle ByteString -> String
20:31:05 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
20:31:05 <lambdabot> Data.ByteString.Lazy.Char8 unpack :: ByteString -> [Char]
20:31:05 <lambdabot> Data.ByteString.Char8 head :: ByteString -> Char
20:31:19 <startling> Cale: yeah, sorry
20:32:08 <pordan30> startling: http://www.haskell.org/haskellwiki/Functional_dependencies ?
20:32:16 <Cale> startling: There are two whole sets of extensions related to this: there's multiparameter type classes with functional dependencies, and then there are the newer class associated types and type families
20:32:37 <Cale> You can do it either way, sometimes one syntax works out more nicely than the other
20:33:19 <Cale> So, let's suppose you have a class for vector spaces, and you want to relate the vector space type with the type of scalars
20:33:28 <Cale> You can use a multiparameter class:
20:33:45 <shachaf> sinelaw: decodeUTF8 is probably the function you want.
20:33:46 <Cale> class VectorSpace f v where (*^) :: f -> v -> v; ...
20:34:00 <shachaf> sinelaw: You probably don't want Data.ByteString.Char8.unpack, because that's an evil function.
20:34:06 <Cale> but you'll find that this is annoying because the compiler won't infer which f you want from the choice of v
20:34:23 <startling> pordan30, Cale: neat, thanks
20:34:46 <sinelaw> why s it evil?
20:34:49 <Cale> So you can use functional dependencies to say that any choice of v uniquely determines f
20:34:56 <shachaf> sinelaw: Because bytes aren't characters.
20:34:59 <Cale> class VectorSpace f v | v -> f where (*^) :: f -> v -> v; ...
20:35:18 <Cale> startling: and that will restrict you to a single instance for any given v
20:35:36 <Cale> startling: (and also let the compiler do type inference better)
20:35:56 <Cale> startling: secondly, you could use the TypeFamilies extension, and write:
20:35:57 <startling> Cale: neat, the ambiguity was getting in the way when I tried MultiParamTypeClasses before
20:36:13 <lispy> ion: page 20: http://www.cs.st-andrews.ac.uk/~eb/writings/idris-tutorial.pdf
20:36:16 <Cale> class VectorSpace v where type Scalar v; (*^) :: Scalar v -> v -> v
20:36:24 <Cale> (etc.)
20:36:30 <lispy> ion: Looks like the idris idiom brackets are specifically for overloading application
20:36:41 <startling> Cale: oh, huh
20:37:10 <Cale> and that basically lets you define a type level function, one instance at a time
20:38:16 <lispy> ion: It seems like this would be pretty straight forward for Haskell considering the existing monad syntax sugar.
20:38:52 <ion> lispy: Yeah, the she preprocessor already does that.
20:40:55 <lispy> ion: I'd much rather say {-# LANGUAGE ApplicativeBrackets #-} (or IdiomBrackets)
20:41:36 <lispy> I think ApplicativeBrackets would be more guessable, but maybe the original name is better.
20:42:24 <ion> lispy: Yes, i’d use that. she isn’t a very good solution for idiom brackets.
20:42:58 * ski somehow thinks "idiom" is a cooler name than "applicative functor"
20:43:26 <ion> {-# LANGUAGE IdiotBrackets #-}
20:43:41 <ski> hehe
20:44:00 <Cale> WHO ARE YOU CALLING AN APPLICATIVE?
20:44:03 <lispy> [| exp |] translates to error "idiot code"
20:44:35 <lispy> Isn't [| |] already taken for the quasiquoter?
20:45:02 <ion> Well… (| f |) = pure f, (| f a |) = pure f <*> a, (| f a b |) = pure f <*> a <*> b would be consistent.
20:45:45 <ski> ion : consistent with what ?
20:45:49 <ion> itself
20:45:52 <Cale> [| exp |] where exp is any Boolean expression translates to  if exp /= True then False else True
20:45:54 <ski> heh
20:46:10 <lispy> ion: I was demonstrating the idiot brackets :)
20:46:22 <ion> I mean, i don’t think (| f |) should be considered an error.
20:46:41 <ski> ion : who says it should ?
20:46:46 <Cale> > do 5
20:46:47 <lambdabot>   5
20:47:11 <minopret> is <*> always pronounced "angle bum", or only by a certain guy in Australia?
20:47:21 <Cale> Only by that guy
20:47:26 <ski> it's pronounced `ap'
20:47:39 <Cale> yeah, ap for apply
20:47:53 <shachaf> zap = zipWith id
20:47:56 <ski> @type ap
20:47:57 <ski> @type (<*>)
20:47:58 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
20:47:59 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
20:48:31 <ion> Perhaps i interpreted lispy’s joke to have an assumption it didn’t actually have. :-P
20:49:03 <lispy> ion: My joke was that [| |] turns all expressions into an error
20:49:07 <minopret> Thanks for everything! I also have LYAH for my subway ride so I might get on to somewhat less introductory questions after a while... bye.
20:49:22 <lispy> minopret: cheers
20:49:23 <ion> lispy: Ah, ok. :-)
20:49:35 <ski> minopret : bye, welcome back anytime :)
20:50:47 <Cale> lispy: it should turn all expressions into awkward newbie versions of those expressions
20:51:09 <lispy> Cale: Explain to me like I'm Calvin, why is "do 5" a Num t => t, and "do {5; 4}" is an error?
20:51:26 <Cale> lispy: because do { x } = x
20:51:27 <shachaf> lispy: It's not an error.
20:51:37 <Cale> but do { 5; 4 } is  5 >> 4
20:51:37 <ski> lispy : GHC polymorphism
20:51:40 <lispy> > do {5; 4}
20:51:41 <lambdabot>   No instances for (GHC.Num.Num (m a), GHC.Num.Num (m b))
20:51:41 <lambdabot>    arising from a u...
20:51:47 <shachaf> > do { 5; 4 } $ 3
20:51:49 <lambdabot>   4
20:51:56 <lispy> shachaf: That doesn't work in normal ghci.
20:52:19 <shachaf> lispy: Get with the times, man.
20:52:21 <ion> > do { 5; 4 } 3
20:52:22 <lambdabot>   <no location info>: parse error on input `3'
20:52:29 <lispy> Cale: ah, I guess I never realized that do {x} = x, and therefore you can just put anything there and get it back.
20:52:48 <lispy> > do (+)
20:52:48 <shachaf> By the way, do { a; b; c } isn't the same as a >> b >> c
20:52:50 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
20:52:50 <lambdabot>    arising from a use...
20:53:14 <Cale> shachaf: orly?
20:53:26 <Cale> shachaf: did you write a bad monad instance to check?
20:53:37 <shachaf> > do do do let in do do do let in do dee dee
20:53:39 <lambdabot>   la la la
20:53:43 <shachaf> Cale: I don't need to. It's specified in the Report.
20:54:05 <ski> lispy : in `do {x}', instead of requiring that the type of `x' has shape `m a', there is simply no restriction on that type in GHC
20:54:11 <Nereid> > do True
20:54:12 <lambdabot>   True
20:54:13 <ion> > do do do do do do do do do do do do do do do do batman
20:54:15 <lambdabot>   batman
20:54:18 <Nereid> haha
20:54:30 <Cale> shachaf: But the report is mostly about the state that Haskell was in when it was 1999
20:54:31 <shachaf> ski: GHC used to have that requirement, I think.
20:54:43 <ski> shachaf : istr so too
20:54:45 <shachaf> Cale: The 2010 report also requires it.
20:54:51 <shachaf> infixl >>
20:54:56 <Cale> do {e;stmts}	=	e >> do {stmts}
20:55:04 <shachaf> Exactly.
20:55:12 <Nereid> why is >> infixl?
20:55:15 <lispy> shachaf: could you clarify what do { a; b; c } is in terms of (>>) and (>>=) ?
20:55:21 <Cale> oh, haha
20:55:22 <shachaf> lispy: a >> (b >> c)
20:55:23 <Nereid> a >> (b >> c)
20:55:29 <lispy> ah
20:55:34 <shachaf> Which is what a >> b >> c *should* be.
20:55:40 <Cale> why the hell would >> be infixl?
20:55:46 <shachaf> Actually do { a; b; c } is a >>= (\_ -> b >>= (\_ -> c))
20:55:49 <lispy> but you're saying, a >> b >> c == (a >> b) >> c
20:55:55 <Nereid> yes
20:55:56 <shachaf> You can override (>>) so I need to specify that.
20:56:20 <Cale> I'd never actually thought much about the way that >> associates, but it clearly ought to associate to the right
20:56:27 <shachaf> Cale: Yes. :-(
20:56:34 <Nereid> any instance satisfying the monad laws has a >> (b >> c) and (a >> b) >> c equal, but there can be a performance difference
20:56:40 <shachaf> Don't you love it when associative operators associate in the wrong direction?
20:56:46 <ski> (lispy : s/==/=/)
20:56:49 <Cale> At least composition is right
20:57:37 <lispy> ski: after the article I read today about referential transparency, I'm not sure if I can claim "="
20:57:49 <ion> ≡
20:57:59 <shachaf> lispy: Well, "==" is *certainly* not correct.
20:58:04 <shachaf> == could be anything.
20:58:10 <lispy> ski: http://stackoverflow.com/questions/210835/what-is-referential-transparency/9859966#9859966
20:58:18 <ski> lispy : surely if the ASTs are the same, the expressions are semantically equal ?
20:58:59 <lispy> ski: hmm...okay. That's fair.
20:59:32 <lispy> (that article is still interesting, so read it when you get some time)
20:59:50 <mapf> why ghc does dead code elimination only at the module level?
20:59:59 <lispy> the punchline is that we've changed the meaning of referential transparency from the original intended meaning.
21:00:15 <shachaf> lispy: Sounds like an argument about words.
21:00:19 <shachaf> I don't care about words. :-)
21:00:55 <lispy> shachaf: It's long, but if you read both his answers you'll see that he's actually talking about PL semantics.
21:02:40 * ski . o O ( `referentiallyTransparent f  ⇔  ∀ (∀ x : α. e : β). ∀ v : α. (f e) [x ↦ v] ≡ (f (e [x ↦ v])) [x ↦ v]' )
21:02:50 <mm_freak> Polarina: pull =)
21:03:33 <ion> ski: I like how you used fancy Unicode but then used the nasty ` instead of ‘.
21:03:41 * ski bows
21:04:59 <lispy> there is a place not far from here named ski bowl, "ski bows" looks pretty similar
21:05:07 <Clint> ¸
21:05:36 <shachaf> lispy: Are you still in Portland these days?
21:06:12 <lispy> shachaf: yes
21:06:37 <lispy> ski: hmm..due to my lack of unicode at the moment, I thought I would check the logs to see what you said, but it fails to render there as well: http://tunes.org/~nef/logs/haskell/12.10.16
21:06:50 <mapf> :t runST
21:06:51 <lambdabot> forall a. (forall s. ST s a) -> a
21:07:16 <glguy> lispy: the tunes.org logs alway botch the unicode stuff
21:07:19 <shachaf> lispy: Renders for me.
21:07:33 <glguy> but it rendered fine in normal clients
21:07:41 <ski> (a generalization of that would be `referentiallyTransparent f  ⇔  ∀ ma : m α. f ma ≡ (ma ⟫= λ a ↦ f (return a))')
21:07:47 <shachaf> lispy: It's not sending an encoding, though.
21:07:52 <shachaf> lispy: Tell your browser to render it as UTF-8
21:08:13 <lispy> shachaf: Thanks. I'll try that.
21:08:59 <lispy> Or maybe I won't. Chrome doesn't have an obvious option for this.
21:09:05 <ski> lispy : ascii versions : `referentiallyTransparent f  <=>  forall (forall x : a. e : b). forall v : a. (f e) [x |-> v] === (f (e [x |-> v])) [x |-> v]'
21:09:44 <ski> lispy : respectively `referentiallyTransparent f  <=>  forall ma : m a. f ma === (ma >>= \a -> f (return a))'
21:11:32 <lispy> ski: hmm
21:11:48 <lispy> ski: What does the prime mean on the second [x |-> v] ?
21:12:02 <ski> no
21:12:03 <shachaf> lispy: It closes the ` , I assume. :-)
21:12:09 <lispy> ah
21:13:18 <ski> the first version is meant to express that the context `f' is referentially transparent wrt the variable `x' in the sense that plugging the context with any expression (possibly) containing `x' is the same as plugging it with that expression, but with `x' replaced by the "outer" value of `x', (`v') above
21:14:31 <ski> in terms of natural language, you could e.g. think of `x' as the current time
21:14:52 <lispy> This definition seems reasonable.
21:16:00 <ion> The matching character to ` (the grave accent symbol) would be ´ (the acute accent symbol).
21:16:06 <ski> then "Yesterday Peter said ... is payday" isn't ref. trans. since you can't replace "today" with "wednesday" in that context
21:16:11 <shachaf> ski: ☝
21:16:30 <shachaf> ion has acute accent.
21:17:00 <lispy> ski: are you thinking that the author of that answer on SO misunderstood the way FP folks use ref. transparency?
21:18:04 <ski> shachaf : that looks like a trapezoid with one right angle, to me ..
21:18:21 <shachaf> ski: It's a finger pointing upwards.
21:18:29 <shachaf> Well, a hand pointing upwards with one finger.
21:18:32 <ski> oh
21:18:36 <ion> ski: You could say  ̏foo" instead of "foo".
21:19:12 <ski> lispy : i don't know
21:19:26 <lispy> ski: if you look at his second post to that question, you see how he ways we misinterpret it: http://stackoverflow.com/a/11740176/5113
21:19:39 <ski> (the above definition(s) are something i've been pondering on and off for some while)
21:20:13 * hackagebot dbus 0.10.2 - A client library for the D-Bus IPC system.  http://hackage.haskell.org/package/dbus-0.10.2 (JohnMillikin)
21:20:43 <lispy> ski: I don't know if you made that defintion up, but it does seem to match the definition Uday Reddy gave in the first part of his answer
21:21:08 <lispy> What I'm struggling with is all this "value", "evaluation", and talk of denotation
21:21:16 <ski> lispy : the two definitions above i've made up, yes
21:21:27 <lispy> "Functional programmers seem to believe that these "values" exist within the programming language, not outside. In doing this, they differ from both the philosophers and the programming language semanticists."
21:21:43 <lispy> I don't understand that statement yet
21:22:04 <ski> @where purelyfunctional
21:22:04 <lambdabot> "What is a Purely Functional Language?" at <http://www.cs.indiana.edu/~sabry/papers/purelyFunctional.ps> by Amr Sabry, 1998
21:22:10 <ski> have you seen that paper yet ?
21:22:45 <Cale> shachaf: Those unicode guys should get their act together and put pictographic versions of all of sign language in there.
21:23:00 <shachaf> Cale: I don't think they take advice from mathematicians anymore.
21:23:08 <lispy> ski: nope. thanks for the link
21:23:18 <shachaf> Cale: Not after the DOUBLE-STRUCK/FRAKTUR/SANS-SERIF ITALIC business.
21:23:23 <Nisstyre> Cale: hey, at least we have the full IPA in unicode
21:23:32 <shachaf> SANS-SERIF BOLD ITALIC, even!
21:23:37 <Nisstyre> as someone who is doing linguistics I like that fact
21:23:49 <shachaf> MONOSPACE, BOLD ITALIC SMALL
21:24:58 <Cale> WHITE UP POINTING MIDDLE
21:25:41 <ion> I still don’t understand why there’s a white smiling face and a black smiling face, but just a white frowning face.
21:27:09 * ski doesn't understand why they use the terms "white" and "black" instead of something like "outlined" and "filled"
21:27:47 <Cale> ski: obviously for when full-colour unicode rolls around
21:27:59 <shachaf> 1F34E   RED APPLE     [<U+1F34E>]
21:27:59 <shachaf> 1F34F   GREEN APPLE     [<U+1F34F>]
21:28:41 <glguy> 🍎🍏
21:28:53 <glguy> These are the characters people need in their character set
21:29:14 <glguy> What's the codepoint for the American Idol logo?
21:29:32 <shachaf> Unicode doesn't have codepoints for play/pause/fast-forward/rewind/stop :-(
21:29:43 <shachaf> That's because they are cruel people with no warmth or joy in their hearts.
21:30:03 <Cale> http://codepoints.net/U+1F34E http://codepoints.net/U+1F34F
21:30:10 <glguy> They're saving room for more important things :) a pause button probably encourages piracy
21:30:19 <Cale> you can really tell the difference with their sample glyph
21:31:30 <ion> shachaf: Some combinations of font renderers and fonts actually render those as red and green.
21:31:51 <glguy> On my screen they are red and green
21:32:03 <Cale> oh really?
21:32:06 <shachaf> TWIST: glguy is red-green colorblind.
21:32:36 <pordan30> lispy: in the addendum, the key point is the distinction between denotation and value; the issue might be obscured by some philosopher's in the tradition highlighted using the terms also interchangeable. see the section after he quotes landin/story/bird & wadler
21:32:51 <glguy> http://www.galois.com/~emertens/redgreen.png
21:32:55 <ski> lispy : i think the "can be replaced by another _expression_ that refers to the same thing" thing is a valid criticism
21:32:56 <ion> TWIST: red is green, and the non-red-green-colorblind people are just psychotic and think they see different colors.
21:32:58 <pordan30> *philosophers
21:33:41 <ski> (lispy : part of the reason for me pondering the above definitions it to try to make these concepts and how they differ clearer to myself)
21:35:42 <wizard`> hello?
21:35:45 <wizard`> helo?
21:36:26 <Cale> hello
21:36:36 <AfC> "hello" is the generally accepted spelling, yes
21:36:55 <liyang> おはようございます。
21:37:12 <shachaf> Cale: Unless you're an SMTP server.
21:37:23 <AfC> shachaf: :)
21:37:40 <liyang> shachaf: I thought exactly the same thing… but couldn't remember what the appropriate response was.
21:38:01 <tac> liyang: おはよ～
21:38:23 <strebe> liyang: it's hardly morning where you are!
21:38:25 <pikhq> liyang: おはよう。どうして日本語で書いてるの。
21:38:30 <lispy> pordan30, ski: thanks. I'm over here taking all this in.
21:38:46 <mm_freak> ehllo?
21:38:47 <mm_freak> ehlo?
21:38:57 <liyang> pikhq: 東京に住んでいるから！
21:39:15 <tac> この＃HASKELLでは日本語のできる人がたくさんいる。
21:39:15 <pikhq> あ、なるほど。良い理由だね。
21:39:27 <ski> 250 c80-216-142-165.bredband.comhem.se
21:39:29 <ion> shachaf: EHLO
21:39:42 <ion> Oh, mm_freak already said that.
21:40:06 <liyang> strebe: True. It's almost two in the afternoon.
21:40:50 <ion> 私はガラスを食べられます。それは私を傷つけません。
21:40:51 <liyang> wizard`: did you have a question? Other than how to spell ‘hello’ that is. :)
21:41:08 <pikhq> ion: w
21:41:18 <tac> ion: lol
21:41:21 <wizard`> I am accustomed to the this new environment.
21:41:26 <djahandarie> おー
21:41:29 <tac> ion: that takes me back
21:41:54 <wizard`> liyang: are you japanese?
21:41:56 <djahandarie> tacさんは日本人ですか
21:42:21 <pikhq> 僕米国人だ。白人も。
21:42:25 <liyang> ion: 俺はラクダだ！
21:42:39 <tac> flip runPerson me $ do x <- eatGlass; return (hurts x)
21:42:40 <liyang> wizard`: nope, expat Brit.
21:42:45 <ion> “American's me. And white.”
21:43:01 <pikhq> ion: "I'm American. Also white." in fairly casual Japanese.
21:43:01 <NemesisD> did something recently do away with prelude.catch?
21:43:07 <ion> liyang: Google Translate has trouble with that.
21:43:09 <tac> djahandarie: こいつ、ただアニメずきだろ。
21:43:13 <pikhq> Formal language on IRC just seems wrong. :)
21:43:13 <mm_freak> 再び英語を話します。私は日本語を読むことができない！
21:43:14 <NemesisD> all hell broke loose in all of my haskell projects
21:43:20 <tac> なんてね。。。。
21:43:29 <tac> アメリカ人だ。
21:43:36 <pikhq> mm_freak: Hah.
21:43:42 <Cale> NemesisD: would not be too surprised...
21:43:58 <glguy> NemesisD: http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/release-7-6-1.html It's new in 7.6.1
21:44:03 <glguy> The deprecated function catch has been removed from Prelude.
21:44:08 <Cale> NemesisD: Prelude's catch has not been the recommended one to use for a very long time
21:44:10 <pikhq> tac: s/て/って/ I think.
21:44:17 <wizard`> many weird guys here
21:44:27 <liyang> ion: for some reason my brain associated "I can eat glass; it doesn't hurt me." with camels.
21:44:28 <tac> pikhq: nante = "as if"
21:44:36 <pikhq> tac: Ah.
21:44:37 <djahandarie> wなるほど。私も<tac
21:44:50 <pikhq> tac: Somehow never seen that before and noticed it.
21:44:50 <tac> ok, Japanese hour is over for me
21:44:55 <tac> but it was fun guys
21:45:14 * hackagebot basic-prelude 0.3.1.0 - An enhanced core prelude; a common foundation for alternate preludes.  http://hackage.haskell.org/package/basic-prelude-0.3.1.0 (MichaelSnoyman)
21:45:15 <mm_freak> probably most of us just used a translator
21:45:21 <mm_freak> (including me)
21:45:23 * pikhq wasn't, at least. :)
21:45:47 <ion> I copied my text from the I Can Eat Glass Project.
21:46:15 <ski> lispy : ty for sharing that link
21:46:16 <NemesisD> Cale: i'm not very used to exception handling in haskell, i have a hard time figuring out a way to force a type when using 'catch' without it looking horrendus
21:46:35 <djahandarie> I tend to use polite speech on IRC. I don't know why.
21:46:37 <NemesisD> i.e. using catch' and defining catch' in a "where" to have an explicit type
21:46:43 <lispy> ski: yw. I guess it was on the haskell subreddit.
21:46:47 <mm_freak> NemesisD: use a constructor
21:46:56 <Cale> NemesisD: Usually pattern matching in a lambda will do it
21:47:01 <mm_freak> `catch` (\(X x) -> …)
21:47:23 <mm_freak> > (\Just x -> x) (Just 3)
21:47:24 <lambdabot>   Constructor `Data.Maybe.Just' should have 1 argument, but has been given 0
21:47:44 <strebe> mm_freak: いいえ
21:48:02 <lispy> ski: so I guess the lesson for today is that RT doesn't have anything to do with the evaluation, simply the denotation.
21:48:46 <mm_freak> strebe: sorry, i'm not firing up the translator again =)
21:48:58 <pikhq> mm_freak: "No"
21:49:06 <NemesisD> Cale and mm_freak how would i pattern match an IOError constructor
21:49:07 <pikhq> Read "iie"
21:49:36 <wizard`> bye
21:49:38 <wizard`> exit
21:49:50 <wizard`> how can I gut out of here?
21:49:54 <wizard`> #c
21:49:59 <NemesisD> wizard: /quit
21:50:00 <lispy>  /quit
21:50:02 <strebe> wizard`: probably /quit
21:50:06 <wizard`> cool thanks
21:50:10 <mm_freak> NemesisD: you wouldn't, but if you don't care about the actual exception value, just its type, you can use catchJust
21:50:26 <liyang> wizard`: /disco
21:50:30 <glguy> :t catchJust
21:50:32 <lambdabot> Not in scope: `catchJust'
21:50:44 <mm_freak> :t Control.Exception.catchJust
21:50:45 <lambdabot> forall e b a. (GHC.Exception.Exception e) => (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a
21:50:48 <glguy> mm_freak: why would catchJust be better if you didn't care about the value?
21:51:17 <NemesisD> yeah it has a selector on it
21:51:48 <mm_freak> glguy: because you can easily use a predefined predicate
21:52:37 <mm_freak> isError p = \e -> if p e then Just () else Nothing
21:52:38 <Cale> Note also, in  System.IO.Error, there's a function catchIOError
21:52:47 <mm_freak> catchJust (isError isAlreadyExistsError)
21:53:45 <mm_freak> finally a style i have used is:  x `catch'` f where catch' :: …; catch' = catch
21:54:05 <shachaf> Haskell exceptions. :-(
21:54:22 <Cale> shachaf: Haskell 98 exceptions :(
21:54:52 <Cale> The new ones are good, it's just the legacy bits which suck.
21:54:57 <NemesisD> i gotta say, the only thing that really scares me when i'm writing production haskell programs is exceptions
21:55:03 <shachaf> The new ones are still not particularly good, are they?
21:55:10 <Cale> shachaf: What's wrong with them?
21:55:23 <mm_freak> NemesisD: nah, you get used to that, and in the end the code isn't that ugly =)
21:55:24 <shachaf> I don't remember.
21:55:34 <shachaf> The whole Typeable/SomeException mess is pretty messy.
21:55:49 <NemesisD> i've yet to read a guide that covers the "right" way to do exceptions in haskell, so there's always some lurking possibility of some unhelpful error that will kill my program instantaneously
21:55:58 <Cale> I think Control.Exception should have a newtype wrapper for IOError
21:56:06 <Cale> It's easy enough to add one
21:56:17 <Cale> That way you could just pattern match to catch those
21:56:30 <NemesisD> i hope snoyberg is working on that mezzo haskell book now that he got hired at fp complete or whatever, i think the community needs it
21:56:35 <NemesisD> or at least i do ;)
21:56:36 <Cale> (also would be nice to have some things for the various specific IO errors)
21:56:48 <strebe> NemesisD: mezzo haskell book?
21:57:08 <mm_freak> i think the problem is IO itself…  it resembles Maybe when it should actually be an Either
21:57:23 <Cale> ?
21:57:37 <NemesisD> the way java does exception documentation from what i know about it is about the only nice thing i can say about that language
21:57:40 <mm_freak> openFile :: IO Handle  -- legacy
21:57:53 <Cale> try :: Exception e => IO a -> IO (Either e a)
21:57:56 <mm_freak> openFile :: IO OpenError Handle  -- probably better
21:58:07 <NemesisD> where each method documents the exception  taxonomy it can throw and then you must explicitly handle those or document that your function can throw them too
21:58:21 <Cale> mm_freak: That wouldn't become horrible at all ;)
21:58:36 <shachaf> Cale: Next up is subtyping of exceptions.
21:58:56 <strebe> NemesisD: it's not as nice as you'd think; for instance, null pointer exceptions aren't actually expressed that way
21:59:06 <NemesisD> mm_freak: i like that. at some point i want the compiler to confront me with the possible errors rather than let me ignore them
21:59:11 <strebe> i think the erlang model is more useful here
21:59:15 <mm_freak> Cale: i don't think it would become that horrible
21:59:21 <NemesisD> strebe: oh yeah, don't get me wrong, null errors are a problem in a lot of languages
21:59:39 <NemesisD> strebe: but i like the idea, i wish Ruby had it or haskell had it with more dicipline
21:59:44 <mm_freak> NemesisD: it still allows you to ignore the errors…  it just doesn't allow you to ignore changes in error type
21:59:53 <Cale> mm_freak: Okay, so what is the type of (>>) now?
22:00:14 <strebe> NemesisD: my point is that Java's methods -don't- document a bunch of the errors they can throw, and it bites surprisingly often
22:00:17 <mm_freak> Cale: you can't use (>>) in some places
22:00:23 <Cale> haha
22:00:41 <NemesisD> mm_freak: i know but it means that if i really need something to not explode, i can look at the type, put in the proper handlers and be guaranteed that no exception can take my program down
22:01:15 <mm_freak> anyway, my point is that it's not really the fault of the exception system…  "extensible" exceptions have some ugliness to them and i don't see a way around Typeable
22:01:36 <Cale> mm_freak: I was thinking you'd at least say something like  (>>) :: IO e a -> IO e' b -> IO (e :+: e') b
22:01:54 <Jafet> :+: couldn't be a straight constructor, though
22:01:57 <mm_freak> Cale: i can't without generalizing Monad =)
22:02:02 <Jafet> It would be the union
22:02:12 <NemesisD> it may be a documentation issue. in the literature i've read to get me where i am in haskell, i've seen virtually no discussion on exception handling
22:02:42 <Cale> Jafet: Well, people have managed to do this sort of thing and handle the equivalences using insane typeclass hackery
22:02:47 <mm_freak> NemesisD: you can't use IO to encode errors in the type…  you have to put your own monad in front of it
22:03:07 <mm_freak> NemesisD: to be sure to handle every case, have a fallback SomeException handler
22:03:21 <mm_freak> `catch` (\(SomeException _) -> …)
22:03:38 <mm_freak> that one catches all exceptions
22:03:41 <strebe> NemesisD: less than you'd think. I ran into something once where a particular class (not mine, one that came with the java sdk) was refusing to load on a particular platform. This caused an exception, and short of catching all exceptions and leading into the world of pain of silently making exceptions that aren't expected disappear, code in Java -can- blow up
22:04:50 <NemesisD> strebe: i think you may have misunderstood me. i have nothing but contempt for java and i wasn't asserting that they actually implemented their exception system well. i just liked the general idea
22:05:54 <Jafet> Hey now, some of my friends are java coders.
22:06:02 <strebe> NemesisD: I had the misfortune of using Java for a couple of years, and I found it verbose and surprisingly unhelpful at the same time, but I can agree with you that more things that can be statically checked at compile time can be useful
22:07:26 <NemesisD> i should probably be prevented from writing production haskell code until i find some resources to help me master exceptions
22:07:49 <mm_freak> they really aren't that complicated
22:07:58 <mm_freak> learn to use SomeException
22:08:22 <mm_freak> that covers most of the basics
22:08:52 <mm_freak> think of 'catch' as:  catch :: IO a -> (SomeException -> IO a) -> IO a
22:09:15 <mm_freak> then the rest is just understanding the semantics of the polymorphic 'catch'
22:09:43 <strebe> NemesisD: i assume you've seen http://book.realworldhaskell.org/read/error-handling.html or equivalent information, and have glanced at Control.Exception and handle - beyond that, I don't have much to say because I haven't looked at Haskell exceptions enough yet
22:10:03 <NemesisD> i figured it would be something like that, maybe it would be easier if more people documented exceptions that can be thrown or derived their own exception types for more specific exceptions. its a code smell to just catch an exception of any type. less so in a statically typed language but still
22:10:32 <NemesisD> catching everything is worse in ruby, if you make a typo within the rescue block it will catch it :/
22:11:28 <mm_freak> IO exceptions are viewed by most people as sort of "fatal"…  softer errors are usually done using Either et al…  that's probably where the lack of documentation comes from
22:11:28 <NemesisD> strebe: reading that as we speak
22:12:04 <strebe> mm_freak: IO exceptions -shouldn't- be viewed as fatal quite often
22:12:05 <mm_freak> that's why most of my exception halding is really just adding a "`finally` cleanUp" here and there
22:13:19 <mm_freak> like:  forkIO (c `finally` reportBack)
22:13:21 <NemesisD> IO is a scary place, but you can't just give up when things get rough :P
22:13:29 <mm_freak> =)
22:14:49 <mm_freak> you know what's really scary
22:14:54 <NemesisD> it would be interesting if we got all the cool supervision tree stuff in erlang and then threw out its crappy functional programming layer for haskell
22:14:56 <mm_freak> async exceptions together with FFI
22:15:20 <mm_freak> herlang =)
22:16:22 <NemesisD> erlang has pattern matching and is dynamically typed, wha...huh. uhh
22:18:08 <ski> NemesisD : Prolog roots :)
22:18:18 <Cale> NemesisD: Are you aware of Cloud Haskell?
22:18:38 <NemesisD> Cale: yeah. im quite interested in it but i don't have a use for it that i can think of now
22:19:05 <Cale> (It has the supervision tree stuff in Erlang, afaik?)
22:19:09 <NemesisD> i wrote a leaky bucket HTTP rate limiter. i suppose i could use it to have distributed failover
22:19:18 <NemesisD> Cale: oh i was unaware of that
22:19:53 <Cale> I don't really know enough about Erlang...
22:20:01 <Cale> Maybe it only has the foundations of that
22:20:14 * hackagebot conduit 0.5.2.7 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-0.5.2.7 (MichaelSnoyman)
22:20:16 <Cale> It seems like you can build supervision trees of processes, anyway
22:20:34 <lispy> looking at the lexer source for GHC, it seems that [: :], [| |], and (| |) are all already taken for extensions (parr, TH, and arrows respectively)
22:20:51 <NemesisD> erlang has OTP which is like a standard library/convention for module design. it has some built in libraries for stopping child processes dying from taking the program down
22:20:54 <shachaf> @yarr
22:20:55 <lambdabot> Shiver me timbers!
22:21:22 <Cale> http://skillsmatter.com/podcast/scala/cloud-haskell -- I don't know why scala is in the URL
22:21:30 <lispy> So, <| |> it is?
22:21:38 <NemesisD> it isn't magic though, you'd better have some smart error handling logic or you'll just keep flapping your child processes and not get any work done
22:21:41 <ski> lispy : for ?
22:21:48 <lispy> That kind of matches <$> and <*>
22:21:49 <Cale> NemesisD: that's a good talk about what is in Cloud Haskell
22:21:57 <lispy> ski: the idiom/applicative brackets
22:21:58 <shachaf> ◀...▶
22:22:00 <Jafet> [|:) (:|]
22:22:28 <NemesisD> Cale: yeah i'd been meaning to watch that. i think SPJ is going to do a talk on it very soon
22:22:47 * ski wants reflective syntax for monads, instead
22:23:19 <lispy> So then you might have something like: f x y = <| x + y |> :: (Applicative f, Num a) => f a -> f a -> f a
22:23:42 <Cale> NemesisD: there are ways to link processes such that if one dies, so does the other, and then there are ways to make one process monitor another, so that it gets notification when the other dies
22:23:56 <lispy> ski: what is the reflective syntax for monads? Use a special syntax and you get a free monad thingy instead?
22:23:57 <Cale> (and then ways to break those links)
22:24:21 <NemesisD> Cale: in cloud haskell? that sounds good and very similar to how it works in erlang from what i remember
22:24:27 <Cale> yes
22:24:28 <ski> lispy : it's an idea of mine, originally inspired by idiom brackets
22:25:10 <Cale> link :: ProcessId -> Process ()
22:25:13 <Cale> monitor :: ProcessId -> Process MonitorRef
22:25:33 <Nereid> lispy: there's a template haskell thing for applicative brackets
22:25:41 <lispy> Nereid: oh yead?
22:25:41 <Cale> There are apparently also variations of these for nodes and ports
22:25:42 <Nereid> applicative-quoters package
22:25:53 <Cale> http://hackage.haskell.org/packages/archive/distributed-process/0.4.0.1/doc/html/Control-Distributed-Process.html
22:26:01 <Cale> you can see the core of the library there
22:26:23 <ski> lispy : it would be capable of writing some functorish, or idiomatic, or monadic expressions in a neater way
22:26:25 <Cale> "A unified semantics for future Erlang"
22:26:32 <Cale> Apparently future Erlang = Haskell
22:27:05 <Jafet> Haskell, the future ghost of past Erlang happening backwards at the same time
22:27:07 <lispy> Nereid: that library seems to be only partially implemented
22:27:21 <Nereid> in what way?
22:27:48 <Polarina> mm_freak, oooh, so many shiny thinks. :)
22:28:04 <NemesisD> Cale: id welcome erlang's future being haskell. deploying and designing erlang apps correctly is a mysterious black art. for our company it seemed to serve as a funnel of consulting hours to Erlang Solutions
22:28:41 <ski> lispy : .. i'm probably too tired atm to explain it, though. perhaps later, if you're interested
22:29:14 <Nereid> ski: I'm interested too
22:29:27 <mm_freak> Polarina: the interface is now much simpler…  after the manager wire i will release officially
22:29:59 <Cale> NemesisD: all the backend stuff for this library is really shiny too, it looks like it should admit many interesting implementations
22:30:05 <Polarina> mm_freak, this is really good work. I like it in every way. :)
22:30:12 <mm_freak> thanks =)
22:31:01 <ion> Nice. The ghc 7.4.2 binary package being linked against libffi.so.5 and my system’s libLLVM-*.so being linked against libffi.so.6 seems to result in a segfaulting binary.
22:32:28 <Polarina> mm_freak, now for a random question unrelated to those recent changes. In Control.Wire.Prefab.Effect, is there a particular reason that the execute* wires are based on MonadBaseControl rather than MonadIO? Just asking because it bit me once that I couldn't derive a MonadBaseControl instance automatically.
22:32:36 <DanMere34567> hi can i ask a question, i have a printf function currently and its printing out a bunch of elements of a list. what i want to do is instead of declaring each seperate (sp_dyn_le00_ma_in_ZWE !! 0::Float) untill the end of the list what i want to do is put a list comprehension so that it becomes (sp_dyn_le00_ma_in_ZWE !! n::Float)|<-n [0.52] but i cant get it to work.
22:32:58 <ion> Wait… i don’t remember how i got it to segfault, but when i just ghc --make, the binary just complains it can’t find libffi.so.5.
22:33:19 <mm_freak> Polarina: MonadIO can't handle exceptions, only throw them
22:33:31 <Polarina> mm_freak, fair enough. :)
22:33:41 <mm_freak> Polarina: to use your own exception handling use mkFixM
22:34:04 <mm_freak> (or mkGen, if you will)
22:35:25 <DanMere34567> do you guys think its poissble to do that with printf? i tryed a bunch of ways but i just cant get it to work. will i need to just declare the 52 seperate floats?
22:36:15 <mm_freak> DanMere34567: concatMap, also don't use (!!)
22:36:34 <DanMere34567> mm_freak: ok thanks.
22:36:40 <mm_freak> you can also use intercalate
22:37:03 <mm_freak> > intercalate ", " . map (printf "%8.2f") $ [0, 3.5, 7, 4]
22:37:05 <lambdabot>   "    0.00,     3.50,     7.00,     4.00"
22:37:30 <mm_freak> > concatMap (printf "%8.2f") $ [0, 3.5, 7, 4]
22:37:31 <lambdabot>   Ambiguous type variable `b' in the constraints:
22:37:31 <lambdabot>    `Text.Printf.IsChar b'
22:37:31 <lambdabot>  ...
22:37:43 <mm_freak> > concatMap (printf "%8.2f") $ [0, 3.5, 7, 4] :: String
22:37:44 <lambdabot>   "    0.00    3.50    7.00    4.00"
22:38:24 <DanMere34567> thanks!
22:39:54 <ion> class IsChar c
22:39:56 <ion> Instances:
22:40:00 <ion>   IsChar Char
22:40:03 <ion> How useful!
22:40:26 <shachaf> ion: It's useful if you like Haskell 98.
22:49:13 <kevin123> Hi, I'm using the hinotify (haskell inotify)  library, and I was hoping to get some help with it.
22:49:39 <kevin123> If I put a watch on a directory, and then move that directory, I get a MovedOut event telling me the directory moved
22:49:59 <kevin123> But then I have no way of knowing where it moved to, so I can't remove the watch on that directory.
22:50:07 <lispy> Nereid: see the explanation here: http://hackage.haskell.org/packages/archive/applicative-quoters/0.1.0.8/doc/html/Control-Applicative-QQ-Idiom.html
22:50:25 <eflister> is there an instance Alternative [] that short circuits?  ie, a <|> b | null a = b | otherwise = a
22:50:26 <Nereid> about the fixity stuff?
22:52:07 <lispy> Nereid: "Does not apply to nested applications:" re-reading that, I guess that's an intentional decision
22:52:16 <Nereid> indeed
22:52:36 <lispy> and not really different from do-notation
22:53:06 <Nereid> I guess you could try nesting the idiom brackets if you wanted to? :s
22:53:19 <Nereid> can you nest quasiquotes like that?
22:54:14 <Cale> eflister: There isn't an instance like that, but in the past, similar things have been considered for a split of MonadPlus
22:54:41 <lispy> Nereid: syntactically, I think you just need to arrange for haskell-src-meta to parse the QQ
22:54:51 <lispy> Nereid: And then you'd probably have to look for that in the sub AST
22:54:58 <Nereid> but what happens when you encounter the first |] ?
22:55:14 <Cale> (i.e. have MonadPlus and MonadOrElse, or something like that)
22:55:21 <Nereid> or am I missing something
22:55:27 <eflister> cale: thx :) how would you make it yourself?  convert to Maybe's instance?
22:55:58 <Cale> I'd just write the function by pattern matching and then use that
22:56:03 <lispy> Nereid: I was thinking that ghc would know to just "grab the stuff in the middle" and feed it to i, but that's magical
22:56:20 <lispy> Nereid: so maybe it would fail
22:57:25 <eflister> cale:  :( what if you were a n00b and wanted to exercise your feeble grasp of Alternative?  :)
22:57:46 <maukd> newtype
22:58:32 <eflister> maukd: i'll try it!
22:58:40 <lispy> Nereid: do you know if the original applicative paper's idiom brackets changed the nested applications?
22:58:55 <Nereid> I don't know.
22:59:01 <Nereid> (haven't read the paper :s)
22:59:11 <Cale> eflister: I guess you could take maukd's advice and use a newtype
23:00:09 <lispy> Nereid: I think this is it, checking now: http://www.soi.city.ac.uk/~ross/papers/Applicative.pdf
23:01:07 <Cale> eflister: Somewhat related is the stuff in the logict package (which has an instance of its MonadLogic for lists)
23:01:19 <Cale> there's an operation  ifte :: m a -> (a -> m b) -> m b -> m b
23:02:03 <Cale> Logical conditional. The equivalent of Prolog's soft-cut. If its first argument succeeds at all, then the results will be fed into the success branch. Otherwise, the failure branch is taken. satisfies the following laws:
23:02:15 <Cale> (you can read the laws here http://hackage.haskell.org/packages/archive/logict/0.5.0.2/doc/html/Control-Monad-Logic-Class.html)
23:03:01 <lispy> Nereid: I don't think they intended the brackets to apply in the subexpressions.
23:03:56 <lispy> one of their example uses is: sequence [] = [| [] |]; sequence (c:cs) = [| (:) c (sequence cs) |]
23:04:27 <shachaf> sequence = foldr (liftA2 (:)) (pure [])
23:04:36 <Cale> eflister: another option would be an Alternative instance which interleaved the elements
23:06:07 <lispy> shachaf: the question was: sequence cs = pure sequence <*> cs, or just the normal application
23:06:12 <Cale> I've never been convinced that idiom brackets are better than the infix operators that Applicative provides.
23:06:34 <lispy> Cale: this thing I'm running into now is giving me doubts :)
23:06:51 <lispy> With the explicit pure/<*>/<$> it seems more clear
23:06:58 <Cale> well, right
23:07:12 <Cale> (that was kind of my point)
23:08:15 <lispy> I'm pretty sure the intent is [| (:) c (sequence cs) |] = pure (:) <*> c <*> (sequence cs)
23:08:37 <Cale> yeah, that's all they do
23:08:56 <Cale> just one application level deep
23:09:06 <lispy> It's also probably why they wrote it in prefix
23:09:43 <Cale> Yeah, if it let you write [| c : sequence cs |]
23:10:09 <Cale> then that's simultaneously cute and annoying
23:10:15 * hackagebot unix-process-conduit 0.2.0 - Run processes on Unix systems, with a conduit interface  http://hackage.haskell.org/package/unix-process-conduit-0.2.0 (MichaelSnoyman)
23:11:14 <Nereid> Cale: sounds like it does yeah
23:15:16 <lispy> > pure (+) <*> Just 1 <*> Just 2
23:15:18 <lambdabot>   Just 3
23:15:51 <Cale> One thing which I don't understand is why the arrow syntax and do notation in which the arrows went in the other direction was removed.
23:16:29 <Cale> I mean, yeah, if it hadn't been implemented, implementing it would be kinda silly
23:16:40 <lispy> I read a Yampa paper recently that was really painful because I've never bothered to learn arrow notation.
23:16:47 <Cale> but given that it was already there and seemingly not hurting anyone...
23:17:19 <Cale> The translation of arrow notation will hurt your head if you try to think about it too hard
23:18:22 <Cale> and the one in GHC is shitty because it is required to use arr for basically all the manipulations of values that are being bound and passed to later parts of the computation
23:19:24 <Cale> This isn't so bad for some arrows, but if your goal is to inspect and optimise the compositions of arrow computations dynamically, all the arrs are like black boxes which you can't see through
23:19:39 <lispy> I think the case for arrows is poorly motivated. Or maybe I just haven't read the right paper. For example, I don't know when I should/shouldn't use arrows.
23:19:57 <glguy> Every time I thought arrows could help me arr stopped me :)
23:20:00 <Cale> Arrows are the wrong thing, as currently specified
23:20:08 <Cale> arr itself isn't so bad
23:20:13 <shachaf> @arr
23:20:13 <lambdabot> Shiver me timbers!
23:20:16 <Cale> though it ought to be separate
23:20:23 <Cale> from the main part of the class
23:20:53 <shachaf> johnw: You're in CA?
23:21:06 <Cale> Arrow notation is practically a notation for expressing maps in monoidal categories
23:21:07 <shachaf> Wrong channel, I guess.
23:21:19 <Cale> or symmetric monoidal categories, perhaps
23:21:46 <Cale> and if you formalise symmetric monoidal categories in Haskell, you get a much nicer class
23:22:12 <Cale> which looks a lot like Arrow, but with some differences
23:23:06 <Cale> In particular, you want to make fst, snd, the left/right associators, and swap explicit
23:24:20 <Cale> (and you can go a little farther and have explicit left/right unit insertion/retraction for the monoidal operation too)
23:24:27 <lispy> Cale: I lack the CT background to understand and it's close to bedtime :)
23:24:32 <Cale> okay :)
23:24:45 <lispy> I want to understand, but maybe not tonight
23:26:20 <Cale> lispy: basically, you have class methods: fst :: (a,b) ~> a,  assocL :: (a,(b,c)) ~> ((a,b),c),  swap :: (a,b) ~> (b,a)
23:26:27 <Cale> and some others like that
23:26:37 <shachaf> Cale: (~>) is dead. :-(
23:26:43 <Cale> lispy: and you make the Arrow syntax use those instead of putting arr everywhere
23:26:55 <Cale> shachaf: yeah, I know, but I cba to type something which parses
23:27:29 <Cale> You will still need arr in the Arrow syntax in some cases
23:27:40 <lispy> Cale: ah
23:28:31 <Cale> but it reduces the usage to those cases where you're pattern matching on something which isn't a tuple, or where you're constructing a complicated expression to the right of -<
23:29:25 <Cale> actually, probably s/tuple/nesting of pairs/
23:31:50 <lispy> Good night, sir
23:32:14 <lispy> (and good night to the rest of you as well)
23:34:40 <kevin123> Hi, I'm using the hinotify (haskell inotify) library, and I was hoping to get some help with it.
23:34:47 <kevin123> If I put a watch on a directory, and then move that directory, I get a MovedOut event telling me the directory moved
23:34:57 <kevin123> But then I have no way of knowing where it moved to, so I can't remove the watch on that directory.
23:35:54 <dcoutts> kevin123: probably you want to contact the package author, if you think it's a real limitation in the api
23:36:40 <kevin123> dcoutts: I don't know if it's a limitation, or I just am not seeing how it should be done
23:43:09 <johnw> is Awodey's book on Category Theory a good place to start?
23:51:25 <lightquake> johnw: if you want to learn category theory for its own sake, yeah
23:51:44 <johnw> would much of it be applicable to improving my use of Haskell?
23:52:50 <lightquake> i don't think so
23:53:02 <lightquake> gasp, i found code that only compiles with the monomorphism restriction
23:54:01 <johnw> really?  Can I see it?
23:55:04 <johnw> joeyh: is there really no way to truly delete dead repositories?
23:58:19 <lightquake> johnw: i don't have a minimal test case
