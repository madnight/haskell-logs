00:00:00 <ibid> phryk: i don't know lisp much, but i *think* a closer analogy is a reader macro
00:01:23 <arcatan> i think Template Haskell is the full-fledged Lisp macro equivalent, but i don't know much about Lisp or TH.
00:02:17 <RylandAlmanza> I've got a list of lists. Anyone have a [[Bool]] -> [Char] function handy?
00:02:47 <arcatan> RylandAlmanza: what kind of function are you looking for?
00:04:51 <hpaste> RylandAlmanza pasted “[[Bool]] -> [Char]” at http://hpaste.org/68666
00:05:05 <RylandAlmanza> arcatan: ^
00:07:07 <phy> RylandAlmanza wouldn't concatMap (\x -> if x then 1 else 0) do?
00:07:34 <RylandAlmanza> concatMap, huh?
00:07:38 <sopvop> So, I have an instance ToJSON (Map Text a), and bunch of newtypes wrapping Text used as keys for other maps. What would be the cheapest way to handle that? Of course I can just make function taking map and converter for keys, but would rather derive stuff instead of making explicit instances.
00:07:45 <RylandAlmanza> Can you explain what that function does, phy
00:07:46 <RylandAlmanza> ?
00:08:17 <phy> @lambdabot :t concatMap
00:08:18 <lambdabot> Unknown command, try @list
00:09:03 <ibid> > concatMap (\x -> if x then 1 else 0) [[True,False],[False,False]]
00:09:04 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
00:09:04 <lambdabot>         against inferred type ...
00:09:22 <phy> sorry RylandAlmanza messed up terribly would get back in a  moment
00:09:40 <ramier> i just wrote a rpn calculator with the basic 4 operations in 10 lines of code
00:09:44 <ramier> i could've done it in 1
00:10:29 <ibid> @type concatMap (\x -> if x then 1 else 0)
00:10:30 <lambdabot> forall b. (Num [b]) => [Bool] -> [b]
00:12:01 <RylandAlmanza> I think the hard part is that I want linebreaks after every three characters
00:19:42 <phy> RylandAlmanza unlines . (map (map (\x -> if x then '1' else '0' ))) does it
00:30:57 <phy> @type unlines
00:30:58 <lambdabot> [String] -> String
00:54:35 * hackagebot cryptocipher 0.3.3 - Symmetrical Block, Stream and PubKey Ciphers  http://hackage.haskell.org/package/cryptocipher-0.3.3 (VincentHanquez)
01:08:33 <womb> Hi guys!
01:14:15 <absence> are there examples on using netwire somewhere?
02:10:01 <Skola> Hey, I am trying to install lambdabot but get the following error:
02:10:03 <Skola> [ 9 of 79] Compiling Plugin.Pl.Common ( Plugin/Pl/Common.hs, dist/build/lambdabot/lambdabot-tmp/Plugin/Pl/Common.o )
02:10:06 <Skola> /tmp/ghc6628_0/ghc6628_0.s: Assembler messages:
02:10:09 <Skola> /tmp/ghc6628_0/ghc6628_0.s: Error: .size expression for PluginziPlziCommon_operators19_entry does not evaluate to a constant
02:10:22 <Skola> could it be my version of ghc or?
02:12:24 <gienah> Skola: maybe your binutils version
02:13:18 <k-zed_> may be stupid question: does lambdabot offer some "usual" ircbot features, like channel protection, opping, that sort of thing?
02:13:21 <k-zed_> or just the haskelly goodness
02:14:52 <shachaf> @list
02:14:53 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
02:16:56 <Skola> gienah: my binutils seem to be up to date
02:17:16 <gienah> Skola: http://hackage.haskell.org/trac/ghc/ticket/5050 says you need to turn off fvia-C
02:17:52 <arcatan> @src take
02:17:52 <lambdabot> take n _      | n <= 0 =  []
02:17:52 <lambdabot> take _ []              =  []
02:17:52 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
02:18:48 <Skola> gienah: do you know how I do that?
02:19:35 <rainman1985> ski: are you there, i managed to almost solve the problem.. could you check my steps?
02:20:30 <gienah> Skola: like: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/lambdabot/files/lambdabot-4.2.3.2-binutils-2.21.patch
02:21:27 <Skola> thank you very much : }
02:22:38 <arcatan> @src (++)
02:22:38 <lambdabot> []     ++ ys = ys
02:22:38 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
02:22:38 <lambdabot> -- OR
02:22:38 <lambdabot> xs ++ ys = foldr (:) ys xs
02:25:27 --- topic: '["Haskell Platform 2011.4: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.1: http://is.gd/vkWMMa ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","admin/spam issues: #haskell-ops "]'
02:25:27 --- topic: set by glguy on [Wed Apr 18 20:44:31 2012]
02:25:27 --- names: list (clog tiglog synonymous schlaftier donderom rainman1985 mgsloan path[l] treyka edon Skola zhulikas zeissoctopus klickback t7 Facefox jpeeters maccy Dybber ronniy Muffin_ ketil HugoDaniel LtWorf Per4u3e chu raichoo edsko mceier dve stobix_ ftrvxmtrx fbern ulfdoz orbital_fox bradleyayers newbie_ lankjan dywi dimituri m3ga janbanan timebomb brandonw aartamonau gehmehgeh Guest57773 noj gwicke Draggor ennui otters womb choo xraycat moebius_eye rtharper gienah)
02:25:27 --- names: list (Beetny hiptobecubic araujo itemad cads VZakharov milessabin rmunoz joni6128 jeltsch jtannenbaum almostsix schlicht jbauman mrtimuk mah_b Palmik dreixel bru` phy roconnor DrSyzygy phryk fukushima Grahack vlprans hrehf vodik demolithion LaughingMan imphasing|home adlan DarthArachides ThomasLocke blackdog [[zz]] sopvop xarts augur da-x sanemat Cale homie` fgomez MrFenix kizzo potix2 EarlGray jamil_1 shintah xinming_ iFire vili EyesIsMine ramkrsna JaffaCake1)
02:25:27 --- names: list (m_stone [mth] localhost amiri gerard0 bd_ otto_s_ wespee juhp jfischoff salisbury peterhil copumpkin nsxt seolfor c_wraith Nereid tomprince A1kmm Targen ifox00 bgamari jrslepak cdidd jianmeng TacticalGrace Yarou thinker341 Lemon gurrag Croms keseldude dolio kallisti sgronblo gwern akosch Philippa pantski herself td123 tessier Zenith77 TDJACR trin_cz morolin pygospa SyntaxNinja ghorn zw01 lomeo ryandm1 Peaker kadoban dsouza jamiely_desktop asdf` siracusa)
02:25:27 --- names: list (ambimorph aristid mgodshall mux hashbrowncipher lpsmith nyingen shrimpx vertue chris2 thetallguy1 jssanders Masxmasx bezik eacameron gentleben krakrjak niloc132 pfoetchen MK_FG And[y] mortberg PaksAway Belgarion0 jamey_ bmfx mauke jrslepak_neu Ornedan Gracenotes_ quuxman adnap kephas sordina2 agundry_ joe_k_ julmuri- rvchangue master_of_master dMazz nus ArchGT pzol gdoteof tsou welterde armlesshobo wahjava Lenin[Away] Jaxan DasIch BMeph Jonno_FTW Polarina)
02:25:27 --- names: list (mcglk tobiassjosten koala_man thetallguy ivan\ pommes_ descender cheater_ bitonic jix SoupE andrewsw netogallo schroedinbug shutdown_-h_now Modius``` sykora tzxn3 drgreenthumb Vq amuck nilg` prti Botje stepcut glguy Clex az coppro Nisstyre liyang mattp_ Shadow^Dancer theorbtwo crdueck chee1 alek_b ezyang ClaudiusMaximus elnn zk Twey ppilate wting zomg kish dp_wiz r126f dmwit magicman pikhq parcs` snorble_ hpc popx nlogax OnionKnight Draconx vmeson)
02:25:27 --- names: list (irene-knapp1 EvanR dca _flow_ linduxed stepnem NimeshNeema Nemykal Obfuscate dabradley pettter dimmy Nimatek petanqk Baughn Guest45395 Y_Less klapaucius Cerise_ Astro- integral_ dqd ehamberg idnar inr_ Nemo7 JamesJRH wagle saiam confab ninegrid kleini\ Maxdamantus mimi_vx_ brett Redshift64 sShintah srcerer setmeaway Bytter_ gtmanfred noam ngochai Excureo brisbin olsner jmcarthur ps-auxw MoALTz `0660 palmfrond julmae retronym Eiam hiredman kaitocracy_ solirc)
02:25:27 --- names: list (hayashi solarus shoerain Taggnostr2 EEVIAC training4zombies ernst Eidel_ Dtgr oddraisent Shanachan Entroacceptor lopex sajith ion ggreg elgot kobsu sawjig arcatan milli jonaskoelker waterlaz bogner perlite Adios drbean Joshua_MG sporous preflex mxweas tafryn idoru caligula_ taruti dogmaT helgikrs jgr[detached] afarmer DustyDingo Deewiant Igloo SimonRC matthiasgorgens nchaimov AlbireoX ocharles_ arnihermann__ tomh andersk akahn mndrix srid_ SeanTAllen liesen)
02:25:27 --- names: list (si14 aristid-ic blackrain wilfredh xrl IbnFirnas AtnNn niko Jaak thoughtpolice joe9 yam levitation[A] comak bddn jonke k6b Axman6 tehmillhouse mertsas hamishmack ofan Khisanth dabblego nighty^ c1de0x Boney kloeri ahihi2 alexsdutton dan64 Internet13 Dodek LeNsTR|off kopi mornfall cschneid human_bot hirsch_ zormit hyko Lemmih mlh CindyLinz int-e bobry OsakaFoo drmegahertz jaspervdj davidL Gilly_ kolmodin lebastr pingveno wollw neptunepink lispy ido nimred)
02:25:27 --- names: list (_root_ forrestv djanatyn dropdrive Ralith Kuba adnam pcapriotti Hugglesworth tgeeky sp3ctum ski mahogny Saizan Innominate endojelly Tesseraction mkaito elliottcable ByronJohnson dominikh rsimoes dcolish sig_wall Mitar iulian boxo tufisi sipa newsham MrNibbles scgilardi thirsteh mm_freak snarkyboojum bxc seats gseitz hiato dom96 xian deavid xnyhps kkris cjay wto tavelram__ pr jyyou Counter-Strike alang_ Alan nominolo mokus hvr sm hackagebot b52 kakos anachron)
02:25:27 --- names: list (danr ChristianS Guest99277 AntiSpamMeta dino- _janne lucian rwbarton nibalizer monochrom froztbyte mefisto minsa __class__ smarter derekv xsysstar robinbb klugez LauJensen ve sohum routin mee mikeplus64 bonk mm|swarm albel727 brainproxy saurik jabirali alpounet __main__ amiddelk frigga Bwild suiside kaol aliak_ hugin ocharles Aikawa Nanar jlouis nihtml ccasin Spockz mrLite Ke tridactyla shachaf Kovensky s4msung thoughtpolice_ fmap aleator_ Clint BrianHV)
02:25:27 --- names: list (MasseR kalven eno davorak d-snp kategeek Dashkal pyykkis mrdomino Iceland_jack joachifm chra buymcdonalds osfameron Athas Utkarsh_ obcode jaxtr ray OMGTallMonster samek Munksgaard dwierenga epsil audunska adnauseam CosmicRay blast_hardcheese BlastHardcheese gentz knyppeldynan @ChanServ cynick FUZxxl Gothmog_ pi8028 Raynes brixen mendez xplat ahkurtz_ noplamodo djahandarie jrk duairc_ sjl rmunroe mjhan_ copton_ tew88 bcoppens myme peddie wolong `micro sully)
02:25:27 --- names: list (tromp_ certainty tauntaun pharaun Ayvee PHO_ johs thorkilnaur othiym23 jayne robbert chipdude mrshoe BigEndian boyscared pou ousado rhodesd srh Razz jlewis ciaranm guerrilla confound j4pe mrd statusfailed companion_cube tomku tlockney limetree_ k-zed_ dkasak gdsx lambdabot quicksilver mercury^ Derander_ topologist tswett norm2782 kekimmo ricky drdo gdeest ivan` sunnavy sunfun tempire cods brweber2_ ormaaj lulf locci Bassetts fireglow dowski jd10 mietek flori)
02:25:27 --- names: list (aiko- hive-mind geekosaur sclv Damn3d_ Zariel Tinned_Tuna Veinor bartavelle majoh zaiste wunki_off SonicvanaJr mehitabel Aha2Y frontendloader em eintopf traviscline electrogeek koeskoes pyrtsa runejuhl SHODAN angstrom fall_ ahf lokydor squimmy anonus KaneTW tamiko mateu Liskni_si void jlaire barrucadu Ptival fxkr jml Guest23437 earthy amiller uber_mort opqdonut Gcool xaimus_ jrockway_ hpaste koninkje1away dumbhat moonlite aszlig Zarathu Starfire bens Martty)
02:25:28 --- names: list (simsaladin qtplatypus nand` adimit tg Plex- zeiris tsuraan_ ibid nathanel_ marienz etpace_ byorgey pqmodn beppu ortmage1 Yahovah_ Luke tazjin Varakh jrib colah absence identity def-lkb_ jackhill dixie_ gemelen kini decltype finnrobi freiksenet gredman quaestor luis TML Enigmagic birkenfeld mjo The_third_man acfoltzer davesq ben yeltzooo edwinb wires mrno_ otterdam smly- zenzike edwtjo_ Sunhay arkx puzza007 nkpart mimico_away yrlnry Nshag Eliel gwillen)
02:25:28 --- names: list (zygoloid mbernstein Will| dnm emias chr1s_ Arnar dju noddy gereedy fabjan shepheb kosmikus anders^^ lnostdal dumael wereHamster flux luite FireFly KitB maloi mike2 totte willb Laney davean felipe_ dcoutts fryguybob strlen reacocard ziman fattrat rcj_ pdxleif yan_ mroman_ dilinger mantovani tomaw ybit levi)
02:29:58 <womb> :t _mapM
02:29:59 <lambdabot> Not in scope: `_mapM'
02:30:17 <ben> :t mapM_
02:30:18 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
02:30:18 <womb> :t mapM_
02:30:20 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
02:30:30 <womb> i r tired
02:30:33 <womb> diablo 3 ;/
02:31:26 <kamatsu> any yi people here? i'm looking for help implementing a highlighter
02:34:08 <Axman6> kamatsu: hamishmack is someone you might like to talk to about that
02:35:43 <kamatsu> specifically, i'm looking to write an agda highlighter for yi
02:36:36 <kamatsu> agda generates highlighting information in a file, which is basically a list of ranges and how to highlight them
02:37:22 <Skola> @list
02:37:23 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
02:37:27 <kamatsu> but generating them as stuff is updated is too expensive, I want to be able to just instruct yi to highlight specific ranges of text specific ways, not write a parser for agda.
02:41:19 <kamatsu> ah, i think i can do it with overlays
02:41:23 <kamatsu> nevermind :)
02:52:07 <mikeplus64> with QuasiQuotes, how do you retrieve a function given it's name and type?
02:52:24 <mikeplus64> or just name
02:56:37 <mgsloan> mikeplus64: This is what I've been using lately to debug TH stuff in GHCI: https://github.com/mgsloan/quasi-extras/blob/master/reifyQ.hs
02:57:55 <mgsloan> what this does is reify whatever you quote using reifyQ.  It then takes the resulting value, and lifts it to an AST that when evaluated will yield the same thing.  It then passes that to Show :)
02:58:37 <mgsloan> so, [reifyQ|myFunction|] will tell you exactly the information that TH gives you for that
02:58:57 <mikeplus64> nice
03:00:15 <quicksilver> neat, mgsloan
03:00:32 <mikeplus64> but i still have no idea of how to splice a function declared already into a quasiquote, ie for variable interpolation in a string
03:02:04 <mgsloan> quicksilver: Thanks!  The other stuff that's in that repo is even cooler.
03:02:57 <mgsloan> I've got TH AST pattern matching.  E.g.  let [e'| $(l) + $(r) |] = some ast yielding expr
03:03:58 <mikeplus64> i'm looking at the shakespeare source tree but it like other yesod projects is huge
03:04:33 <mgsloan> mikeplus64: I'm not sure what you mean.  Do you want to refer to a function inside an AST generated by a quasiquote, and have the name of the function as a part of the string supplied by the user?
03:04:47 <mgsloan> do you want to let the user put haskell code into the quasi-quote?
03:06:12 <mikeplus64> what I want is a quasiquoter such that if you had [thing| $(person), you are $(adjective) |] it would take previous definitions for person and adjective and make a string out of it
03:09:30 <mikeplus64> oh, i think i have found it, right there on the hackage docs, lookupValueName, oops
03:11:03 <mgsloan> A couple of relevant packages:
03:11:03 <mgsloan> http://hackage.haskell.org/packages/archive/Bravo/latest/doc/html/Text-Bravo.html
03:11:04 <mgsloan> http://hackage.haskell.org/packages/archive/hako/latest/doc/html/Text-Hako.html
03:12:09 <mgsloan> I'm actually planning on writing a string interpolation quasi-quoter very soon
03:13:05 <mgsloan> I extracted out a general treatment of parsing / substituting splices here: https://github.com/mgsloan/themplates
03:13:16 <mikeplus64> doing this more as a learning excercise than for something I need :)
03:13:20 <mgsloan> (this package doesn't know about Template Haskell)
03:13:38 <mgsloan> gotcha, cool!  Glad to see more people playing with TH :D
03:14:38 <mgsloan> I think it's really under-appreciated.  A little uglier than most parts of haskell, which is likely why it's often snubbed, but I think with a bit of love it can really shine
03:14:42 <mikeplus64> might write a little tutorial on it once i have a clue of what i'm doing
03:14:44 <mikeplus64> yeah
03:15:23 <mgsloan> Haskell's abstraction mechanisms are powerful, but are not the full answer to meta-programming
03:16:17 <mikeplus64> next project should be making a QuasiQuoter to make TH functions in a less bang-head-on-wall way
03:16:20 <mikeplus64> ;)
03:16:35 <mgsloan> mikeplus64: That is what I'm doing :)
03:16:46 <mikeplus64> excellent
03:16:57 <mikeplus64> call it TemplateTemplateHaskell
03:17:54 <mgsloan> you'll be able to use something like the [e| blah blah my ast $( with splices ) |] syntax, but the splices can go in more places.  In one variant of these QQs, one of these functions are called on the results of the splice: https://github.com/mgsloan/quasi-extras/blob/master/src/Language/Haskell/TH/Convenience.hs
03:18:14 <mgsloan> So, this lets you do stuff like [e'| $("f") x y |]
03:18:31 <mgsloan> so, a string becomes a VarE!
03:18:55 <mgsloan> it actually already works, just polishing
03:19:29 <mikeplus64> nice!
03:20:19 <mikeplus64> your example above eerily reminds me of jquery/js programming
03:20:38 <mgsloan> yeah, I don't like the splice syntax
03:20:58 <mgsloan> I think I'm going to support the old syntax, but make a push for: [e'| {{"f"}} x y |]
03:21:07 <mgsloan> muuuuch better looking
03:51:55 <mikeplus64> ok, i have it sort of working, but, I end up with a [Q Exp] (all of String "Exps"), and no idea of how to concatenate them
03:56:34 <t7> im writing a type checker in C hohoh
03:56:46 <t7> this is rather long winded
03:57:14 <gwern> @quote
03:57:14 <lambdabot> ozone says: shapr: hugs has been ported to an apple IIIc? ; shapr: MAIN :: IO (); MAIN = DO PUTSTRLN "GODDAMN CAPS"
03:59:15 <mgsloan> mikeplus64: Probably something like foldr (\l r -> appE (appE [| (++) |] l) r) (ListE [])
03:59:36 <mgsloan> err listE []
04:00:14 <mgsloan> better yet, foldr (\l r -> appsE [ [| (++) |], l, r]) (ListE [])
04:01:10 <mgsloan> or, foldr (\l r -> infixE (Just l) [| (++) |] (Just r)) (listE [])
04:01:25 <mgsloan> that's probably best
04:03:08 <linduxed> can i include ? in function names?
04:03:18 <mgsloan> linduxed: nope
04:03:19 <quicksilver> no.
04:03:32 <quicksilver> normal identifiers are a-z A-Z 0-9 and '
04:03:34 <bitonic> > let foo?bar = 1 in foo?bar
04:03:35 <lambdabot>   <no location info>: Parse error in pattern
04:03:55 <quicksilver> oh, and _
04:04:00 <bitonic> lambdabot: and a crapload of others if you enable UnicodeSyntax
04:04:15 <bitonic> sorry, linduxed
04:04:24 <bitonic> that's not considering operators
04:04:33 <bitonic> linduxed: you can use ? for an operator name, iirc
04:04:48 <bitonic> let x ?? y = x + y in 1 ?? 2
04:04:52 <bitonic> > let x ?? y = x + y in 1 ?? 2
04:04:52 <lambdabot>   3
04:05:09 <linduxed> ok thx
04:05:20 <linduxed> by the way, if i've got this data type
04:05:21 <linduxed> data Pot = Pot { marbleCount :: Int, isStore :: Bool, position :: Int } deriving (Show)
04:05:36 <linduxed> do i get to use some setter?
04:06:04 <bitonic> linduxed: well, you can user record syntax, if you have a `pot :: Pot', you can do `pot {position = 3}', for example
04:06:06 <linduxed> because it would be pretty nice to set the values, instead of having to create new Pots all the time
04:06:32 <bitonic> linduxed: wait, that's another issue. In haskell values are immutable. you can't modify the Pot in-place. you'll always have to create a new onw
04:06:35 <bitonic> *one
04:06:48 <linduxed> bitonic: that was exactly what i was wondering
04:07:01 <linduxed> bitonic: in that case, i'll have to make new ones with the altered values
04:07:49 <bitonic> linduxed: yeah but the record syntax gives you a nice way to modify just a field
04:13:22 <mikeplus64> mgsloan: thanks!
04:13:35 <mikeplus64> wasnt quite it but was close enough
04:13:45 <mgsloan> welcome!
04:14:28 <absence> http://hpaste.org/68667 <- why do i get a warning about overlapped pattern matches here?
04:15:11 <mgsloan> with my stuff it'll be foldr (\l r -> [e'| {{l}} ++ {{r}}|]) [e'| [] |]
04:16:00 <mgsloan> absence: because a pattern that is just a variable matches every case
04:16:01 <mikeplus64> nice
04:16:25 <byorgey> absence: what mgsloan said.  'theyKey' in line 2 has nothing to do with 'theKey' on line 1.
04:16:35 <byorgey> it is just a new variable name that matches anything.
04:16:54 <absence> oh, i see
04:17:07 <absence> so i need to use guards or if for that?
04:17:18 <linduxed> bitonic: oh so wait
04:17:30 <hpaste> byorgey annotated “asdasd” with “asdasd (annotation)” at http://hpaste.org/68667#a68668
04:17:36 <byorgey> absence: yes, like ^^^
04:17:52 <absence> right, thanks :)
04:18:01 <hpaste> mgsloan annotated “asdasd” with “asdasd (annotation)” at http://hpaste.org/68667#a68669
04:18:13 <mgsloan> argh!
04:18:14 <mgsloan> lol
04:18:39 <mgsloan> holy cow, they're identical!
04:18:43 <byorgey> amazing!
04:18:49 <byorgey> great minds think alike
04:18:55 <hpaste> “Me, too!” annotated “asdasd” with “asdasd (annotation)” at http://hpaste.org/68667#a68670
04:19:12 <linduxed> bitonic: if i've got an existing Pot called mrPotson that was created with "Pot 3 False 2", will i create an identical copy except for the position if i do mrPotson {position = 5} ?
04:19:15 <mgsloan> guess so :D But you're faster!
04:19:30 <ion> Great butts fart alike.
04:19:48 * hackagebot snaplet-i18n 0.0.2 - snaplet-i18n  http://hackage.haskell.org/package/snaplet-i18n-0.0.2 (HaishengWu)
04:20:13 <t7> i like coding in C
04:20:14 <byorgey> mgsloan: I was faster *this* time.  We'll have to try a few hundred more times to get a statistically meaningful sample.
04:20:17 <t7> its like a puzzle
04:20:30 <t7> memory game. dont forget to free your memory
04:20:45 <mgsloan> byorgey: true true.  Also, this is probably your morning, while this is my late-night :)
04:21:02 <byorgey> hehe, true =)
04:23:00 <bitonic> linduxed: yes
04:23:08 <t7> but i keep trying to use haskell block comments :(
04:23:13 <bitonic> the term "copy" is dangerous here
04:23:30 <bitonic> because it doesn't need to actually copy the contents of the fields in the other structures
04:23:36 * bitonic has to go to lunch
04:23:39 <linduxed> bitonic: ok, thx
04:25:03 <mikeplus64> mgsloan: now, for the grande finale, how would one go about defining a Lift instance for Text? text somewhat recently got "real" Text literals that aren't just packed at runtime, and my quasiquoter having to unpack and pack stuff is pretty lame
04:25:34 <mikeplus64> the only thing imo that should need to be packed is the string that quoteExp provides
04:25:48 <mikeplus64> but my opinion often differs from reality...
04:26:31 <mgsloan> hmm, I think you ought to be able to output (LitE (StringLit l)), and have those interpreted as "real" Text literals
04:26:49 <mgsloan> but I'm not very familiar with Text
04:28:00 <mikeplus64> i don't think i can output a literal because well, it's an expression, unless there is a way to transform it into one
04:28:47 <mgsloan> ohh, right, lift.  I think you ought to be able to just lift the stringified version of the Text
04:29:50 * hackagebot family-tree 0.1.1 - Family trees with lenses  http://hackage.haskell.org/package/family-tree-0.1.1 (NathanVanDoorn)
04:30:31 <Taneb> :)
04:31:44 <byorgey> Taneb: is that your package? =D
04:31:52 <Taneb> yEAH
04:31:56 <Taneb> Woops, caps lock
04:31:57 <Taneb> Yeah
04:32:05 <byorgey> nICE
04:32:09 <Taneb> :P
04:36:56 <mgsloan> this is entirely OT, but... perfect music for super late night haskelling: http://www.youtube.com/watch?v=_h3MM6JHZ_I
04:39:09 <mikeplus64> that's never offtopic :)
04:40:48 <byorgey> woah trippy video
04:42:04 <mgsloan> byorgey: that too!  Goes with the music pretty well.
04:42:10 <byorgey> agreed
04:48:43 <Cale> http://www.youtube.com/watch?v=zgswhBHPeI8
04:52:28 <gurrag> [ubuntu] Should I be prefixing my `cabal install $PACKAGE` commands with `sudo` every time?
04:52:36 * mgsloan enjoys that he has started the posting of youtube links to music :D http://www.youtube.com/watch?v=__OSyznVDOY
04:52:49 <gurrag> I'd rather not but it seems some packages need it, although I'm not sure
04:53:07 <Taneb> gurrag, I'd believe doing so would be A Bad Thing
04:53:23 <Taneb> Try to avoid it.
04:53:36 <Taneb> If a package won't install, see if it's in the Software Centre
04:53:45 <gurrag> hmm... a good deal of the packages I try to install through cabal end in "a depends on b which failed to install"
04:53:50 <gurrag> oh okay
04:54:37 <gurrag> a bunch of wx related stuff just failed on deepseq-1.3.0.0 failing to install
04:55:05 <gurrag> it's just like the old debian days heh
04:55:27 <Taneb> I thought deepseq was in the Haskell Platform now?
04:56:50 <gurrag> oh dear, I may have done things out of order; I had installed ghc through the Software Center
04:57:08 <gurrag> how much do I have to backpedal before going back and installing the Haskell Platform?
04:57:30 <gurrag> will it be able to handle what I've currently already installed through apt-get or do I need to nuke everything and start over
04:58:28 <Taneb> You don't, I think. Just search of haskell-platform in the software centre
04:59:03 <gurrag> ah; I see it now, thank you
05:04:39 <gurrag> hmm, configuring DeepSeq fails here
05:05:00 <gurrag> array-0.3.0.3:Data.Array can't be safely imported! The module itself isn't safe.
05:05:33 <gurrag> this is after installing the `haskell-platform` package
05:05:50 <Taneb> cabal install array --reinstall?
05:08:09 <byorgey> no!
05:08:46 <byorgey> try  ghc-pkg trust array
05:09:02 <byorgey> not sure why you should need that
05:09:06 <byorgey> what version of GHC is this?
05:09:37 <gurrag> 7.4.1-1ubuntu2
05:14:05 <saep> try GHC.Arr
05:14:44 <t7> mm_freak: hows your compiler coming along?
05:24:08 <Taneb> gurrag, did I break your computer?
05:32:54 <Cale> I wonder if anyone has ever paid Springer $34.95 for access to a PDF of a single paper.
05:33:17 <copumpkin> I'm sure it happens every few days
05:33:24 <copumpkin> :)
05:36:38 <bitonic> Cale: what are you referring to?
05:37:33 <Cale> Things like this: https://springerlink3.metapress.com/content/pj2775t3j0435262/resource-secured/?target=fulltext.pdf&sid=t1djwuiqw5zr45fuk0k4szb2&sh=www.springerlink.com
05:37:39 <mikeplus64> how can I get the type of a Q Exp that I've gotten from the 'environment' via global (mkName "foo") (ie, String, Int etc) ?
05:39:38 <Taneb> typeOf $(exp) ?
05:40:35 <rwbarton> @hoogle reify
05:40:36 <lambdabot> Language.Haskell.TH.Syntax reify :: Name -> Q Info
05:40:36 <lambdabot> Language.Haskell.TH reify :: Name -> Q Info
05:40:36 <lambdabot> package reify
05:41:15 <rwbarton> hmm, does that do what you want?
05:42:07 <rwbarton> check for DataConI or VarI and extract the Type field
05:42:49 <mikeplus64> alright, thanks
05:50:47 <eikke> is there any way to work around 'overflow checks' when using rem and mod?
05:56:20 <ion> What overflow checks?
05:57:34 <Axman6> eikke: what checks?
05:58:29 <rwbarton> and what do you mean "work around"?
05:59:04 <ClaudiusMaximus> >  minBound `div` (-1)
05:59:05 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:59:05 <lambdabot>    `GHC.Real.Integral a'
05:59:05 <lambdabot>   ...
05:59:09 <ClaudiusMaximus> >  minBound `div` (-1 :: Int)
05:59:10 <lambdabot>   *Exception: arithmetic overflow
05:59:22 <rwbarton> yeah, I expect that is the check in question
05:59:31 <rwbarton> >  minBound `mod` (-1 :: Int)
05:59:33 <lambdabot>   *Exception: arithmetic overflow
06:01:12 <ClaudiusMaximus> i think that last one has been fixed (at least looking at the source for 7.4.1)
06:01:27 <ClaudiusMaximus> @version
06:01:28 <lambdabot> lambdabot 4.2.2.1
06:01:28 <lambdabot> darcs get http://code.haskell.org/lambdabot
06:01:38 <ClaudiusMaximus> oh, doesn't give ghc version..
06:02:25 <eikke> those indeed :)
06:03:23 <Axman6> i don't get any checks in my ghci
06:03:35 <Axman6> ah, except with minBound
06:03:41 <rwbarton> you can use the underlying functions directly, if you import GHC.Prim or GHC.Int or something, I think they're called intMod#, intRem# etc.
06:04:00 <mikeplus64> rwbarton: "`foobar` is not in the type environment at a reify" :(
06:04:02 <hpc> > minBound `rem` (-1 :: Int)
06:04:03 <lambdabot>   *Exception: arithmetic overflow
06:04:03 <ClaudiusMaximus> sourcce i'm looking at is http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Real.html
06:04:11 <ClaudiusMaximus> about half way down the page
06:04:40 <ClaudiusMaximus> as rwbarton says, http://www.haskell.org/ghc/docs/7.4.1/html/libraries/ghc-prim-0.2.0.0/GHC-Prim.html#g:3 if you're truly speed hungry, but i wouldn't recommend it (you'll have to check preconditions manually)
06:05:07 <rwbarton> oh there are just ordinary boxed Int-specific versions, convenient
06:05:46 <ClaudiusMaximus> and if you just want correctness, use Integer..
06:06:46 <eikke> I dont really require correctness
06:07:03 <eikke> it's more a game we're doing, comparing different compilers and languages
06:09:19 <Axman6> it's amazing how powerful let x = x in x is, all the functions in there are defined using it!
06:09:20 <rwbarton> mikeplus64: I think `foobar` needs to be in a module imported in whatever piece of code the TH thing is getting spliced into
06:12:28 <mikeplus64> rwbarton: it's odd, i can do global (mkName t) where t is the name of the function and use that fine
06:13:06 <mikeplus64> when it's just a "local" declaration like let foo = "aaa" in [srep|$(foo)|]
06:32:03 <dreixel> @pf (\fs bs -> unF ((unF fs) bs))
06:32:03 <lambdabot> Maybe you meant: bf pl
06:32:27 <dreixel> no, I meant give me the pointfree version of this
06:32:27 <Sagi> I want to take a stab at creating a Haskell BGP library, but I am relatively new to haskell. Can someone point me to a different protocol library implemented using some best practices? I've been looking at attoparsec and Data.Binary.
06:32:35 <dreixel> who knows what the right command is?...
06:32:48 <ClaudiusMaximus> dreixel: it's @pl for "pointless"
06:32:55 <dreixel> ah, thanks ClaudiusMaximus
06:32:59 <dreixel> @pl (\fs bs -> unF ((unF fs) bs))
06:33:00 <lambdabot> (unF .) . unF
06:33:05 <dreixel> amazing.
06:36:04 <mm_freak> t7: working on a small RTS now
06:36:38 <dreixel> @pl (\fs bs cs -> unF (unF ((unF fs) bs)) cs))
06:36:38 <lambdabot> (line 1, column 42):
06:36:39 <lambdabot> unexpected ")"
06:36:39 <lambdabot> expecting variable, "(", operator or end of input
06:36:44 <t7> run time system? real time strategy?
06:36:52 <dreixel> @pl (\fs bs cs -> unF (unF ((unF fs) bs) cs))
06:36:53 <lambdabot> (((unF .) . unF) .) . unF
06:37:16 <absence> mm_freak: you mentioned something about using Alternative instead of injectEvent and hold for netwire recently. i didn't understand anything at that time, but now i see why it would be nice to avoid inject/hold. :) could you briefly explain again please?
06:38:59 <dreixel> @pl (\f -> (unF .) . (zipWith' f))
06:39:00 <lambdabot> ((unF .) .) . zipWith'
06:39:39 <mm_freak> absence: wires can be inhibiting
06:39:48 <mm_freak> absence: 'empty' is the wire that always inhibits
06:39:58 <mm_freak> and x <|> y selects the first wire to produce
06:40:02 <mm_freak> left-biased
06:40:37 <mm_freak> so in netwire you often have wires that act like the identity wire when an event occured and inhibit otherwise
06:41:53 <absence> mm_freak: so if i have two inhibiting wires, and want a non-inhibiting one, i do x <|> y <|> someNonInhibitingWire?
06:42:10 <dreixel> @pl (\f -> (((unF .) . unF) .) . unF . map f)
06:42:10 <lambdabot> (((((unF .) . unF) .) . unF) .) . map
06:42:13 <absence> instead of injecting and holding both x and y
06:42:37 <dreixel> @pl (\f -> (unF .) . unF . map f)
06:42:38 <lambdabot> (((unF .) . unF) .) . map
06:42:46 <mm_freak> hypothetical score display that flashes whenever the score increases:  currentScore >>> (diff >>* flashMsg <|> identity) >>> textLabel
06:42:56 <mm_freak> absence: yes
06:43:46 <mm_freak> absence: note about the example:  the predefined 'diff' wire does not act like identity, but outputs the last score on change, but you get the idea
06:47:27 <mm_freak> absence: diff' = proc x -> do diff -< x; identity <- x
06:47:43 <mm_freak> that is a version of 'diff' that acts like identity whenever the value has changed, and otherwise inhibits
06:48:14 <mm_freak> you can also add a notYet wire, so that it does not produce at the first instance
06:48:32 <mm_freak> diff' = proc x -> do notYet -< (); diff -< x; identity <- x
06:49:03 <mm_freak> or a nicer way to write it assuming you import Control.Category
06:49:10 <mm_freak> diff' = proc x -> do notYet . diff -< x; identity <- x
06:50:00 <mm_freak> typo:  identity -< x
06:50:04 <mm_freak> not ->
06:50:24 <absence> mm_freak: thanks a lot, i think i get how it works. now i just have to wrap my head around the details of the arrow syntax :)
06:50:46 <mm_freak> absence: the whole arrow way is optional…  you can just as well use Applicative =)
06:51:07 <mm_freak> diff' = liftA2 snd diff identity
06:51:11 <hpc> proc-do is a ridiculous syntax in any event
06:51:45 <mm_freak> proc-do (and arrows in general) can be useful for complicated compositions
06:51:54 <Axman6> i've never been able to figure out what it means
06:51:54 <mm_freak> especially when you use ArrowChoice and ArrowLoop
06:52:19 <absence> mm_freak: i know it's optional, but i think it will be easier to start with
06:52:27 <quicksilver> I think proc-do is a very neat syntax for one or two particular cases
06:52:39 <quicksilver> I've never successfully learnt to recognise those cases :P
06:52:40 <mm_freak> absence: not necessarily…  if you have a good understanding of Applicative, you should be ready to go right away
06:52:51 <mm_freak> absence: proc-do is just a more explicit way of routing variables
06:52:56 <quicksilver> I spent some time working on parse/transform code with an arrow interface
06:53:10 <quicksilver> and I always found it more comfortable to use arrow + applicative combinators
06:54:15 <mm_freak> diff' = liftA2 snd (notYet . diff) identity  -- a wire that passes its input to both given wires and combines the outputs using the given function
06:54:32 <mm_freak> in this case the first wire's output is ignored and the second's is outputted
06:54:57 <mm_freak> diff' = proc x -> do notYet . diff -< x; identity -< x
06:55:02 <mm_freak> i'm doing the exact same thing there
06:55:16 <mm_freak> the result is the output of the last line
06:56:32 <mm_freak> "proc x -> do y1 <- a1 -< x; y2 <- a2 -< x; identity -< f y1 y2" and "liftA2 f a1 a2" are equivalent
06:57:52 <hpc> huh, i think i see what arrow notation does now
06:58:08 <hpc> proc input -> do out <- arrow -< input; ...
06:58:38 <mm_freak> yeah…  arrow notation becomes nice when you have actual expressions to the right and patterns to the left =)
06:58:53 <mm_freak> (x, y) <- myComp -< a + b + c
06:59:19 <hpc> i still say it's a ridiculous notation :P
06:59:39 <mm_freak> if you have ArrowChoice you can use if/case just like in monadic do-notation
06:59:44 <mm_freak> proc x -> if …
06:59:53 <mm_freak> this is insanely difficult with Applicative =)
07:00:09 <mm_freak> especially when you want to use 'case' instead of 'if'
07:00:27 <mm_freak> and you have regular do/rec notation when you want to use ArrowLoop
07:00:43 <mm_freak> rec x <- integral 0 -< y; y <- integral 15 -< x
07:02:16 <mm_freak> it may look funny, but the notation makes sense…  when using arrows you /must/ be explicit about what is arrow input and what is a function argument
07:03:03 <hpc> mm_freak: yeah, because you could have something like a CoKleisli arrow, where you would have to manually extract before performing normal function application
07:03:49 <hpc> can you nest arrow applications?
07:03:58 <mm_freak> "nest"?
07:04:00 <hpc> y <- complicated -< x -< z
07:04:16 <mm_freak> like "y <- complicated . x -< z"?
07:05:00 <hpc> like complicated :: a ~> b ~> c
07:05:14 <hpc> and trying to call complicated x z
07:05:21 <mm_freak> the arrow syntax can help you with that
07:05:40 <mm_freak> it has a special operator syntax and banana brackets, which are a bit harder to explain
07:06:01 <mm_freak> r <- (| f (comp1 -< x) (comp2 -< y) |)
07:06:01 <hpc> so the nicer way would just be
07:06:16 <hpc> curried <- complicated -< x
07:06:23 <hpc> y <- curried -< z
07:06:27 <mm_freak> the nice thing about the notation is that the arrow variables x and y are in scope within the (| |) block
07:06:44 <mm_freak> the arrow machinery saves you from a lot of explicit passing there
07:07:04 <hpc> man, arrows sound like the leakiest abstraction...
07:07:59 <mm_freak> well, inputs and outputs are a very implicit thing…  arrow notation makes them explicit and also brings them into scope in very complicated scenarios like above
07:08:19 <Polarina> hpc, not to worry, the GC will save you.
07:08:22 <mm_freak> for example this is legal:  proc x -> (comp1 -< x) <+> (comp2 -< y)
07:09:05 <mm_freak> nothing to do with GC…  the translation is fairly straightforward and doesn't introduce a lot of what you wouldn't have introduced yourself anyway
07:09:40 <mm_freak> arrow notation is about creating arrow side channels…  when you use Category and Applicative you have to create them explicitly
07:10:04 <hpc> i thought that's what Monad was about ;)
07:10:15 <mm_freak> you don't need side channels when using a monad =)
07:10:44 <mm_freak> a side channel solves this problem:  x . y . z, how to provide z's output as input to x?
07:11:35 <mm_freak> Category alone can't solve that one…  Applicative solves it in a cumbersome way…  arrows solve it in another cumbersome way…  arrow notation removes the cumber =)
07:12:05 <absence> mm_freak: r1 <- a1 -< (); r2 <- a2 -< (); is it possible to do the same as a1 <|> a2 when using proc-do (with r1 and r2)?
07:13:24 <mm_freak> absence: i don't understand the question…  r1 and r2 are not in scope in the particular other computation
07:14:07 <mm_freak> in proc notation you can write:  proc x -> (do r <- a1 -< (); …) <|> (do r <- a2 -< (); …)
07:14:28 <mm_freak> if you line up the 'proc' keyword with '<|>' you don't need the parentheses
07:14:59 <mm_freak> or with 'do' actually
07:16:01 <hpaste> “Ertugrul Söylemez” pasted “Arrow operator notation” at http://hpaste.org/68677
07:16:06 <mm_freak> absence: see the paste
07:16:11 <absence> mm_freak: a1 and a2 are inhibiting arrows and i want to select the first one that produces. is that possible inside a single proc?
07:16:22 <mm_freak> sure
07:16:32 <absence> ah, multiple do
07:16:33 <mm_freak> y <- a1 <|> a2 -< x
07:16:36 <mm_freak> =)
07:17:09 <mm_freak> the thing between <- and -< is a regular expression…  only the arrow variables are out of scope there
07:18:28 <absence> mm_freak: in that single-line example x is passed as input to the arrow that is selected. how would it look if i wanted different inputs for each arrow (say x1 and x2)?
07:18:46 <mm_freak> in that case you use arrow operator notation
07:19:00 <mm_freak> y <- (a1 -< x1) <|> (a2 -< x2)
07:19:11 <mm_freak> x1 and x2 can refer to arrow variables there
07:19:20 <mm_freak> the arrow rewriter takes care of the plumbing
07:20:21 <mm_freak> this is basically the same as in the paste, just without do-blocks =)
07:20:31 <mm_freak> arrow notation is very powerful…  i recommend reading this:  http://www.haskell.org/ghc/docs/latest/html/users_guide/arrow-notation.html
07:20:32 <absence> ah! things are starting to make sense now, thanks :)
07:21:10 <mm_freak> it's a bit scary to read, but it really gives an insight into the greatness of arrow notation…  if it weren't for proc/do, i'd never use arrows =)
07:21:51 <absence> i'll check it out, i was acutally looking for info about the notation earlier, but only found simpler examples
07:23:05 <mm_freak> absence: a few months ago i started an arrow tutorial that should explain these things very well, but unfortunately never got around to finishing it…  however it should provide all the basics you need to understand the rest:  http://ertes.de/new/tutorials/arrows.html
07:24:39 <absence> mm_freak: great :)
07:25:40 <Polarina> mm_freak, nice!
07:27:18 <absence> mm_freak: it sounded like you discouraged the use of injectEvent. was that only in the context of doing "hacks" with holdWith, or in general? it looks like an easy way to make an arrow inhibit, but are there better ways?
07:27:48 <absence> to make a wire inhibit, i mean
07:28:47 <mm_freak> absence: injectEvent is meant for library authors who don't want to write wires in the low level way using mkGen et al
07:29:10 <mm_freak> whenever you can construct an Either value from some outside event source like a widget library you can use injectEvent
07:29:23 <mm_freak> as a library author you would rather want to use something like mkGenM
07:29:37 <absence> why is that?
07:30:22 <mm_freak> well, first of all low level wires are as efficient as the underlying monad…  netwire is designed to be very fast (in my benchmarks i've easily reached > 10 million FPS)
07:30:53 <mm_freak> the next is:  when dealing with a widget/network/whatever library you would to have direct access to the underlying monad
07:31:35 <mm_freak> this is only true for library developers interfacing with something…  an application developer should never need this
07:32:54 <mm_freak> to be a library developer you need to understand the automaton arrow, which i've started to explain in the tutorial i linked
07:33:36 <mm_freak> netwire uses my proud invention of the wire arrow, which is a modified automaton arrow =)
07:38:32 <absence> mm_freak: i see. i'll try both ways and see how i like them :)
07:45:09 * hackagebot http-conduit 1.4.1.4 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.4.1.4 (MichaelSnoyman)
07:46:12 <absence> mm_freak: is it possible to have a wire produce output without giving it input (e.g. for doing movement in a game while a key is held down), or should it take Maybe InputEvent so i can feed it Nothing while the key is held down?
07:47:14 <sonoflilit> Hi, I'm having trouble installing gtk2hs on my arch linux machine, seems like my glib2 is too new
07:47:34 <sonoflilit> an error saying something like "only glib.h can be included directly"
07:47:59 <sonoflilit> the internet says a patch was applied may 1, and the latest release was september 2011
07:49:07 <sonoflilit> Had anyone fought with this before? What would be the easiest way to go forth? Can I install an old version of glib on Arch? How hard is it to install darcs gtk2hs?
07:49:09 <hpc> sonoflilit: cabal update
07:49:13 <hpc> the latest gtk is may 8
07:51:21 <sonoflilit> hpc: Indeed, it was. Just not announced on their website
07:52:12 <sonoflilit> I could have sworn I cabal update'd a moment before installing, but I see the minor version of the /tmp/xxxx dir chosen by cabal changed by a bit, so lets hope it will work this time
07:52:40 <hpc> in general, the order i try packages in is hackage -> the repo field on hackage -> the website -> give up
07:53:17 <Polarina> absence, if I am not mistaken, ignore me if I am (just a beginner), you can use the underlyind monad to affect the computation of the wire. E.g. the IO monad, you can have a wire that reads from a file and gives different output each instant.
07:55:10 * hackagebot http-conduit 1.4.1.5 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.4.1.5 (MichaelSnoyman)
07:55:12 * hackagebot http-conduit 1.4.1.6 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.4.1.6 (MichaelSnoyman)
08:00:17 <absence> Polarina: but you have to provide input for it to get something out of it if you use stepWireM at least
08:01:30 <Polarina> absence, the input could well be an empty tuple.
08:04:16 <hpc> haha, Quit: What happened to Systems A through E?]
08:04:33 <hpc> i really want to know now, how System F was named
08:04:54 <sonoflilit> hpc: Nope, didn't help, same error
08:05:12 <hpc> sonoflilit: hmm, no idea then
08:05:57 <quicksilver> hpc: I would guess it stands for 'fondamental', or similar, girard being french.
08:06:00 <quicksilver> dunno though.
08:06:01 <sonoflilit> did anybody here manage to install gtk2hs with glib2.32?
08:14:19 <Luke> anyone know if there's any sql conduit implementations?
08:14:59 <bitonic> Luke: what do you mean?
08:15:45 <Luke> a sql db conduit
08:16:02 <Luke> for example, read/write to postgresql through a conduit interface
08:16:23 <Polarina> bitonic, I would assume a source that has a database row as an output.
08:16:49 <bitonic> Luke: I don't see how the enumerators fit SQL... you're not consuming/streaming incrementally
08:17:00 <c_wraith> you can certainly consume incrementally
08:17:04 <bitonic> right
08:17:07 <c_wraith> that's kind of the entire point of database iterators
08:17:21 <bitonic> well, but it's a different thing
08:17:37 <bitonic> it's a list with a cursor pointing at an element, more than an undefined-length stream
08:17:59 <lpsmith> actually,  postgresql-simple's fold combinator is streaming
08:18:17 <c_wraith> It's still a cursor.  You still can iterate over it in bounded local space (not counting the local accumulator)
08:18:25 <Luke> lpsmith: thanks - that's a good thing to note
08:18:26 <lpsmith> The idea of exporting a conduit or something did cross my mind
08:18:30 <Luke> i'll probably use that
08:19:46 <bitonic> c_wraith, lpsmith: yeah but I'd expect it to be useful for certain operations more then as a general interface to make queries/retrieve results
08:20:26 <Luke> lpsmith: i just ask for conduits because my scripts already use that. i'm processing CSVs now and it would be nice to just swap out the conduit type with a sql conduit =)
08:20:51 <shapr> kalven: Hail Eris!
08:20:53 <shapr> whoops
08:20:56 <shapr> kallisti: HAIL ERIS!
08:21:22 <Luke> lpsmith: have you seen the csv conduit implementation?
08:22:56 <Luke> I'm already producing data to a mssql db but it looks like the haskell support for that sucks
08:25:14 * hackagebot hakyll 3.2.8.1 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.2.8.1 (JasperVanDerJeugt)
08:27:28 <mm_freak> absence: a wire that does not depend on input should have a fully polymorphic input type
08:27:55 <mm_freak> constant :: b -> Wire e (>~) a b
08:28:00 <mm_freak> (omitting context)
08:28:27 <lpsmith> unfortunately it doesn't offer a way to stop early,   but you might find the implementation instructive
08:28:46 <mm_freak> the 'a' is fully polymorphic and not used anywhere…  that means that the wire will not refer to its input
08:30:04 <lpsmith> Luke, no, I haven't seen that
08:30:47 <mm_freak> lpsmith, cdsmith, where is dvdsmith?
08:30:54 <osfameron> hehe
08:30:56 <Polarina> mm_freak, it has baffled me for a long time, but could you explain what (>~) is? So far I've only seen it as a thing that "is there".
08:31:36 <mm_freak> Polarina: Wire is a family of arrow transformers:  one for each exception type, and (>~) is the underlying arrow, much like with monad transformers
08:31:36 <statusfailed> When cabal builds a package, do I have the HTML documentation locally?
08:31:42 <phryk> Poraline: Bald angry chinese guy with a broken nose?
08:31:54 <lpsmith> although postgresql does have some (limited) support for dealing with CSV directly,  with the COPY IN/COPY OUT interface.  Unfortunately postgresql-simple doesn't support that directly at the moment,  you'd have to muck around in the Internal module and with libpq
08:31:55 <mm_freak> newtype ReaderT e m a = ReaderT (e -> m a)
08:32:01 <dcoutts_> statusfailed: if you enable documentation then yes
08:32:06 <mm_freak> runReaderT :: ReaderT e m a -> e -> m a
08:32:23 <statusfailed> dcoutts_: how do I do that?
08:32:39 <mm_freak> newtype Wire e (>~) a b = Wire (a >~ (Either e b, Wire e (>~) a b))
08:33:03 <mm_freak> stepWire :: Wire e (>~) a b -> (a >~ (Either e b, Wire e (>~) a b))
08:33:05 <dcoutts_> statusfailed: one off just use --enable-documentation, to make it persistent edit the ~/.cabal/config
08:33:51 <Polarina> mm_freak, e would be the inhibitation type?
08:33:53 <mm_freak> Polarina: in most cases (>~) a kleisli arrow, example:  type MyWire = Wire LastException (Kleisli IO)
08:33:58 <mm_freak> yeah
08:34:37 <mm_freak> stepWire :: Wire e (Kleisli m) a b -> Kleisli a (Either e b, Wire e (Kleisli m) a b)
08:34:41 <mm_freak> hence the convenience function
08:34:55 <mm_freak> stepWireM :: Wire e (Kleisli m) a b -> a -> m (Either e b, Wire e (Kleisli m) a b)
08:34:59 <mm_freak> same thing
08:35:04 <mm_freak> (omitting context)
08:35:27 <statusfailed> dcoutts_: thanks!
08:35:34 <Polarina> mm_freak, all right, thanks. It all makes much more sense now.
08:35:42 <mm_freak> (actually the wire netwire is designed Kleisli only serves as a type…  you use the underlying monad directly without the Kleisli wrapper…  that's why it uses a data family)
08:35:54 <mm_freak> s/the wire//
08:35:59 <mm_freak> no
08:36:07 <mm_freak> s/the wire/the way/
08:36:08 <mm_freak> =)
08:36:14 <Polarina> :)
08:37:01 <sonoflilit> hpc: alright, so I fixed it by cabal unpack -> examine stuff a bit -> delete one line -> cabal install
08:37:17 <mm_freak> by the data family the performence increased from 10000 FPS to 10 million FPS for most applications with a peak of 200 million FPS =)
08:38:02 <mm_freak> conclusion:  it's wrong to say that the Kleisli wrapper makes no performance difference ;)
08:44:24 <womb> is there good simple tutorial with images about using and building packages with cabal ?
08:45:02 * dcoutts_ isn't aware of any with images
08:45:24 <dcoutts_> womb: this has some packaging advice http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
08:45:50 <womb> dcoutts_:  long one with images! thanks! bro
08:46:12 * dcoutts_ doesn't see any images
08:47:03 * armlesshobo doesn't have arms
08:53:34 <womb> dcoutts_: logo image!
08:54:45 <dcoutts_> heh
09:05:14 <EvanR> can you write a lambda expression with more than one pair of pattern -> body
09:05:46 <EvanR> \True -> Foo, False -> Bar
09:06:09 <ClaudiusMaximus> EvanR: lambda-case syntax would be nice, but for now there's \x->case x of ...
09:11:28 <EvanR> not that anyone should be pattern matching bools ;)
09:12:39 <cheater__> ClaudiusMaximus: there was a lambda case proposal, wasn't there?
09:13:26 <Cale> I don't want that, I want case sections
09:13:47 <EvanR> im fine the way it is, i dont like too much fancy syntax
09:13:50 <Cale> (case of ...) would translate to (\fresh -> case fresh of ...)
09:14:14 <EvanR> Cale that would be cool
09:14:52 <Cale> Which would also tidy up the case in do-notation where you need to case on the result of an action, and end up introducing a variable for it
09:15:19 <Cale> getFoo >>= case of
09:15:19 * hackagebot yesod-auth-kerberos 1.0.1 - Kerberos Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-kerberos-1.0.1 (ArashRouhani)
09:15:22 * hackagebot circ 0.0.3 - A Compiler IR Compiler.  http://hackage.haskell.org/package/circ-0.0.3 (TomHawkins)
09:15:27 <Cale>   Bar ... -> ...
09:15:30 <Cale> and so on
09:16:44 <absence> mm_freak: does what you wrote about fully polymorphic input type mean that i should supply dummy input (like empty tuple)?
09:20:15 <mm_freak> absence: you will have to
09:20:27 <mm_freak> an arrow computation always takes input
09:20:33 <mm_freak> even if it ignores it
09:21:21 <mm_freak> two recommendations about that:  never use () as input type…  it seems to make sense, but it will stand in your way at every other corner, especially when you use applicative style
09:21:41 <mm_freak> second:  don't pattern-match against ignored inputs, if for some reason you choose to give a more specific type
09:21:52 <mm_freak> i.e. prefer "proc _" over "proc ()"
09:22:55 <dixie_> > map (map) $ repeat map
09:22:56 <lambdabot>   Overlapping instances for GHC.Show.Show ([a -> b] -> [[a] -> [b]])
09:22:56 <lambdabot>    arisi...
09:23:03 <dixie_> > :t $ map (map) $ repeat map
09:23:04 <lambdabot>   <no location info>: parse error on input `:'
09:23:12 <dixie_> :t $ map (map) $ repeat map
09:23:13 <lambdabot> parse error on input `$'
09:23:17 <dixie_> :t map (map) $ repeat map
09:23:18 <lambdabot> forall a b. [[a -> b] -> [[a] -> [b]]]
09:25:30 <c_wraith> dixie_: the parens around that map don't do anything
09:26:41 <EvanR> :t map map
09:26:42 <lambdabot> forall a b. [a -> b] -> [[a] -> [b]]
09:27:02 <EvanR> :t fmap fmap
09:27:03 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
09:28:38 <EvanR> :t (<*> (<*>))
09:28:39 <lambdabot> forall b (f :: * -> *) a b1. (Applicative f) => (f (a -> b1) -> (f a -> f b1) -> b) -> f (a -> b1) -> b
09:28:44 <EvanR> \o/
09:30:21 * hackagebot hakyll 3.3.0.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.3.0.0 (JasperVanDerJeugt)
09:30:57 <EvanR> (f (a -> b) -> (f a -> f b) -> c) -> f (a -> b) -> c
09:33:08 <EvanR> :t ap
09:33:10 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:33:16 <EvanR> :t (<*>)
09:33:16 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
09:33:31 <EvanR> how are they different
09:34:25 <EvanR> @src ap
09:34:25 <lambdabot> ap = liftM2 id
09:34:40 <EvanR> @src liftM2
09:34:40 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
09:35:21 * hackagebot happstack-server 7.0.2 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.0.2 (JeremyShaw)
09:36:11 <c_wraith> EvanR: only in the constraints required
09:37:12 <c_wraith> EvanR: well, and there are fewer constraints on the definition of (<*>), since it's defined in terms of the laws for pure and fmap
09:37:41 <EvanR> :t pure
09:37:42 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
09:37:53 <EvanR> pure :: Maybe Int
09:38:02 <cheater__> Cale: yeah, i'd like that sort of case "sections" as you call it too
09:38:05 <EvanR> er
09:38:12 <EvanR> > pure 0 :: Maybe Int
09:38:13 <lambdabot>   Just 0
09:38:35 <EvanR> > pure 0 :: [Int]
09:38:36 <lambdabot>   [0]
09:38:47 <c_wraith> More interesting is to look at list.  Note that its applicative instance works the same as its monad instance - but that's only for the sake of sanity
09:39:08 <hpc> c_wraith: also it's required to
09:39:14 <hpc> mostly
09:39:15 <c_wraith> There are many more correct applicative instances than monad instances for list
09:39:35 <c_wraith> for instance, there's the ZipList applicative instance
09:39:38 <EvanR> are there standard newtypes for those
09:39:45 <c_wraith> there is for ZipList
09:39:45 <hpc> c_wraith: i mean, i think there's rules for Functor/Applicative that say "if it's a Monad, these are equal"
09:39:54 <hpc> i know of ZipList :P
09:40:23 * hackagebot hakyll-contrib 0.1.0.0 - Extra modules for the hakyll website compiler  http://hackage.haskell.org/package/hakyll-contrib-0.1.0.0 (JasperVanDerJeugt)
09:40:37 <c_wraith> hpc: Not quite. They say "If it's a monad, pure=return, (<*>)=ap is a valid Applicative instance".  But that's not the same as "the only valid applicative instance"
09:41:01 <hpc> c_wraith: no, i mean
09:41:13 <c_wraith> It's just that it would be amazingly confusing to have the instances be inconsistent with each other
09:41:21 <hpc> if you want an Applicative instance that disagrees with a Monad instance, you have to newtype it
09:41:22 <c_wraith> So for practical reasons, you don't do that.
09:41:27 <hpc> is the rule
09:41:30 <hpc> i think
09:41:42 <EvanR> whats ziplist do
09:41:54 <c_wraith> For that to be a rule, rather than good practice, you need Applicative to be a superclass of monad.
09:42:26 <c_wraith> > (+) <$> [1,2,3] <*> [10,11,12]
09:42:27 <lambdabot>   [11,12,13,12,13,14,13,14,15]
09:42:36 <hpc> c_wraith: i know; i mean "rule" in the same way that the Monad laws are "rules"
09:42:43 <c_wraith> > (+) <$> ZipList [1,2,3] <*> ZipList [10,11,12]
09:42:44 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList a))
09:42:44 <lambdabot>    arising ...
09:42:53 <c_wraith> > fromZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [10,11,12]
09:42:54 <lambdabot>   Not in scope: `fromZipList'
09:42:58 <EvanR> getZipList
09:43:05 <c_wraith> > getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [10,11,12]
09:43:05 <hpc> "it's not enforced, but don't do $this ever" kind of thing
09:43:06 <lambdabot>   [11,13,15]
09:43:26 <c_wraith> unsurprisingly, its <*> implementation is zip
09:43:26 <EvanR> ah
09:43:30 <c_wraith> well, zipWith
09:43:33 <EvanR> got it
09:43:51 <hpc> @src ZipList (<*>)
09:43:51 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
09:43:56 <hpc> :t zipWith ($)
09:43:56 <lambdabot> forall b b1. [b -> b1] -> [b] -> [b1]
09:44:02 <daniel31415> @botsnack
09:44:02 <lambdabot> :)
09:47:02 <EvanR> > pure 0 :: ZipList Int
09:47:03 <lambdabot>   No instance for (GHC.Show.Show
09:47:03 <lambdabot>                     (Control.Applicative.Zip...
09:47:14 <EvanR> > getZipList $ pure 0 :: ZipList Int
09:47:15 <lambdabot>   Couldn't match expected type `Control.Applicative.ZipList
09:47:15 <lambdabot>                  ...
09:47:25 <EvanR> > getZipList $ pure 0 :: [Int]
09:47:26 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
10:02:41 <RylandAlmanza> Anyone want to help me get from [[Bool]] to [Char]?
10:02:42 <RylandAlmanza> http://hpaste.org/68666
10:05:23 * hackagebot arbb-vm 0.1.1.8 - FFI binding to the Intel Array Building Blocks (ArBB) virtual machine.  http://hackage.haskell.org/package/arbb-vm-0.1.1.8 (JoelSvensson)
10:06:55 <shachaf> "get from [[Bool]] to [Char]" doesn't really specify the behavior of the function you want there.
10:06:58 <jfischoff> RylandAlmanza: start with Bool -> Char the map in can concat the results
10:07:14 <jfischoff> ugh auto correct
10:07:23 <shachaf> For that matter, your @paste doesn't specify it either. Do you want newlines and spacees and everything?
10:07:24 <ClaudiusMaximus> RylandAlmanza: try starting with something :: Bool -> Char, and somethingElse :: (Bool -> Char) -> [Bool] -> [Char], and anotherThing :: [String] -> String ; also check out Hoogle and Hayoo if you haven't already
10:07:56 <RylandAlmanza> shachaf: Just newlines. Sorry, I should've been more specific
10:08:31 <Zedrikov> <RylandAlmanza> Anyone want to help me get from [[Bool]] to [Char]? ⇐ from_bool_to_char list_list_bool = ([] :: [Char])
10:09:31 <shachaf> RylandAlmanza: It's difficult to help you without knowing what you've tried, or what you're doing. :-)
10:10:15 <shachaf> > zipWith3 if' [True, False, True, True, False] (repeat '0') (repeat '1') -- fun!
10:10:17 <lambdabot>   "01001"
10:11:38 <RylandAlmanza> shachaf: Wow, thanks! Man, haskell is really powerful!
10:12:24 <Zedrikov> where is if' defined? GHCi doesn't seem to know about it
10:12:35 <shachaf> RylandAlmanza: Don't actually do what I said.
10:12:39 <strager> hehe
10:12:48 <strager> if' c t f = if c then t else f
10:12:51 <shachaf> You still haven't answered the other questions.
10:13:00 <shachaf> Is this homework or something?
10:14:54 <absence> mm_freak: if there's a wire that inhibits in a network, is it necessary to select (using <|>) a different one immediately for that network not to inhibit as well, or can it be done later? i.e. will this inhibit: wireThatInhibits >>> (someWire <|> wireThatAlwaysProduces)
10:17:46 <RylandAlmanza> shachaf: No, I'm generating a random cave using cellular automata. The list of lists represents the 2D plane of cells. True means the cell is alive, False means it's dead. Would you like to see all the code I have so far?
10:20:50 <hpaste> shapr pasted “cannot configure cabal-install” at http://hpaste.org/68681
10:21:02 <shapr> Could someone suggest a fix for my inability to install cabal-install?
10:21:47 <Clint> shapr: manually specify cabal-install-0.14.0 ?
10:21:50 <shapr> The problem seems to be that unix-2.4.2.0 requires base <4.4 and I have base-4.5, is this a known problem?
10:22:10 <Clint> the problem is that something wants unix-2.4.20 when you have a better one already
10:22:20 <shapr> Ah
10:22:29 <Clint> (probably 2.5.1.0)
10:22:44 <hpc> shapr: cabal --version
10:23:03 <shapr> hpc: I have cabal-install version 0.8.0 and Cabal 1.8.0.2
10:23:42 <hpc> wow that's old
10:24:06 <shapr> I had a more recent version, but then I upgraded to Ubuntu 12.04 and blew away my ~/.ghc dir...
10:24:40 <hpc> ghc 7.4.1?
10:24:43 <shapr> Yup
10:24:48 * shapr tries apt-get install cabal-install
10:24:50 <hpc> use the darcs version
10:25:28 <hpc> darcs/github are the only ones that compile with 7.4.1
10:26:46 <Zedrikov> > (concat . (intersperse "\n")) . (map (map (flip ((flip if') '1') '0'))) [[True, True, False],[False, True, True],[False, True, False]]
10:26:47 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
10:26:47 <lambdabot>         against inferred ty...
10:27:12 * shapr blows away everything in ~/.cabal/bin/
10:28:45 <Zedrikov> > (concat . (intersperse "\n")) . (map (map (flip ((flip if') '1') '0'))) []
10:28:46 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
10:28:46 <lambdabot>         against inferred ty...
10:32:07 <shapr> I'm lost in the dependency labyrinth :-|
10:32:14 <Zedrikov> > ((concat . (intersperse "\n")) . (map (map (flip ((flip if') '1') '0')))) [[True, True, False],[False, True, True],[False, True, False]] -- You can try this too RylandAlmanza
10:32:16 <lambdabot>   "*Exception: was too lazy to actually define it
10:32:37 <alpounet> uh
10:32:38 <shapr> I've never seen THAT error before.
10:32:40 <hpc> Zedrikov: dude what
10:33:02 <Zedrikov> GHCi accepts it
10:33:21 <Zedrikov> (after defining if')
10:33:31 <alpounet> @src if'
10:33:31 <lambdabot> Source not found. You type like i drive.
10:33:40 <hpc> :t if'
10:33:41 <lambdabot> forall t1 t. t1 -> t -> t -> t
10:33:46 <alpounet> except there, i don't kno wwhere it can come from
10:33:46 <hpc> lol
10:34:25 <Zedrikov> > ((concat . (intersperse "\n")) . (map (map (flip ((flip if') '1') '0')))) []
10:34:26 <lambdabot>   ""
10:34:38 <Zedrikov> Line may be too long
10:34:40 <hpc> > if' x x x
10:34:42 <lambdabot>   *Exception: was too lazy to actually define it
10:35:06 <shapr> What's if' ?
10:35:10 <Zedrikov> > ((concat . (intersperse "\n")) . (map (map (flip ((flip if') '1') '0')))) [[True]]
10:35:12 <lambdabot>   "*Exception: was too lazy to actually define it
10:35:24 <alpounet> it comes from the definition of if'
10:35:30 <alpounet> that we don't have.
10:35:39 <nand`> @let if' c t e = if c then t else e -- correct?
10:35:41 <lambdabot>  <local>:3:0:
10:35:41 <lambdabot>      Warning: Pattern match(es) are overlapped
10:35:41 <lambdabot>               In...
10:35:42 <hpc> @undefine
10:35:51 <hpc> @let if' c t e = if c then t else e
10:35:51 <lambdabot>  Defined.
10:35:57 <shergill> edwardk: what's the benefit of the reflection package (http://hackage.haskell.org/package/reflection) over, say, using a reader monad?
10:36:06 <shapr> > if' x x x
10:36:06 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
10:36:07 <lambdabot>         against inferred type ...
10:36:09 <shapr> nope
10:36:22 <alpounet> :t if'
10:36:22 <shapr> I'm certainly curious what if' was...
10:36:22 <lambdabot> forall t. Bool -> t -> t -> t
10:36:35 <alpounet> this one makes more sense anyway
10:36:36 <edwardk> shergill: he constraint 'lifts' over lambdas, where the reader doesn't. this means you can get a lot more sharing
10:36:39 <nand`> > map (`if'` "yes" "no") [True, False, True]
10:36:40 <lambdabot>   Couldn't match expected type `t1 -> t'
10:36:40 <lambdabot>         against inferred type `[GHC....
10:36:44 <nand`> hmm
10:36:50 <nand`> I can't section multiple parameters like that?
10:37:34 <shergill> edwardk: hmm i'm probably being dumb, but could you give an example? or elaborate on what you mean by 'lifts' over lambdas?
10:37:36 <edwardk> shergill: this is safe because a dictionary for a given type is unique, so Foo a => … will always be called with the same argument for the same a, but a function might be called with different arguments
10:37:41 <absence> hmm, my Int turns into a GHC.Prim.Any, which doesn't have a Show instance. is there a way to see its value?
10:37:48 <Zedrikov> > ((concat . (intersperse "\n")) . (map (map (flip ((flip if') '1') '0')))) [[True, True, False],[False, True, True],[False, True, False]]
10:37:49 <lambdabot>   "110\n011\n010"
10:38:35 <ion> (flip ((flip if') '1') '0')? /me cringes
10:39:04 <alpounet> \x -> if' x '1' '0'
10:39:11 <alpounet> looks better
10:39:22 <hpc> @let (t ?? f) p = if p then t else f
10:39:23 <lambdabot>  Defined.
10:39:24 <edwardk> for comparison, lets reason about newtype Mod = Mod (Int -> Int) vs. newtype Mod s = Mod Int where Reifies s Int
10:39:32 <hpc> :t ('1' ?? '0')
10:39:33 <lambdabot> Bool -> Char
10:39:46 <edwardk> when you are done adding two Mod values in the former, you have a function. when you are done in the latter you have an actual Int
10:40:17 <edwardk> if you then use that value multiple times, in the former case, it has to compute the value all over again, just in case you passed a different modulus, becaue it has no idea.
10:40:26 <edwardk> whereas in the latter, its already computed the answer
10:41:02 <shergill> ah ok, that makes sense
10:41:10 <nand`> @pl (t ?? f) p = if p then t else f
10:41:10 <lambdabot> (line 1, column 12):
10:41:11 <lambdabot> unexpected "="
10:41:11 <lambdabot> expecting variable, "(", operator or end of input
10:41:23 <nand`> @pl \ t f p -> if p then t else f
10:41:23 <lambdabot> flip . flip if'
10:41:29 <edwardk> compute x^1000 in using the function representation.. while youa re doing that. write the code and compute x^1000 with the reflection implementation. you'll finish writing the code before the former completes ;)
10:41:47 <ion> (??) = flip bool, i think.
10:41:50 <shergill> edwardk: heh. thanks
10:41:51 <edwardk> (and running it)
10:42:12 <Zedrikov> <alpounet> looks better ⇐ It is, but I wanted to do it point free for fun
10:42:23 <edwardk> the new reflection is also insanely cheap (thanks elliott)
10:42:25 <ion> FSVO fun
10:42:35 <alpounet> hah ok
10:42:43 <ion> thelliott
10:42:52 <ion> The new reflection?
10:43:07 <edwardk> http://hackage.haskell.org/packages/archive/reflection/1.1.5.1/doc/html/src/Data-Reflection.html
10:43:10 <ion> Thankes
10:43:13 <strager> I'd like a MonadTrans where I can just "throw" something.  Running the monad would be: (Monad m, MyMonad t) => t e m a -> m (Either e a).  I noticed ErrorT in Control.Monad.Trans.Error, but it requires e to be an instance of Error, and it has 'catch' semanics I don't care about.
10:43:18 <strager> semantics*
10:43:22 <edwardk> ion: it is _evil_ =)
10:43:25 * shapr grumbles at cabal
10:43:30 <edwardk> it casts a function to a dictionary
10:43:56 <hpaste> shapr pasted “unable to install cabal-dev” at http://hpaste.org/68683
10:43:57 <ion> That code made a swooshing sound as it flew over my head.
10:43:59 <RylandAlmanza> brb
10:43:59 <luite> shapr: what's the problem?
10:44:11 <shapr> luite: I just pasted the error, any ideas?
10:44:23 <nand`> what's the whole “class Foo a b | a -> b” thing about?
10:44:33 <nand`> I've seen that a few times before but I have no idea what it means
10:44:34 <shapr> I feel like I should blow away ~/.ghc and ~/.cabal and start over :-|
10:44:41 <shapr> nand`: fun deps!
10:44:41 <c_wraith> strager: try the explicit-exception package
10:44:45 <shapr> functional dependencies
10:44:54 <shergill> nand`: it's a functional constraint. it basically says that type a is associated with at most one b
10:44:59 <edwardk> ion: it effectively passes 'const a' function _as_ the typeclass argument Reifies s a in (forall s. Reifies s a => Proxy s -> r)
10:45:06 <luite> shapr: try this first: ghc-pkg unregister Cabal-1.14.0-2b114764d2ca987efdb5c842f49ccff5
10:45:13 <shapr> ok
10:45:20 <edwardk> ion: ion: notice there are no _instances_ of Reifies lying around ;)
10:45:37 <c_wraith> double-ion
10:45:43 <ion> edwardk: I’ll have to take a better look at it when i’m a bit less tired. :-)
10:45:57 <strager> Great; thanks c_wraith
10:45:57 <shapr> luite: ghc-pkg: cannot find package Cabal-1.14.0 :-(
10:46:17 <shapr> but it worked without 2b114764d2ca987efdb5c842f49ccff5 on the end
10:46:29 <luite> oh i hope that unregisterd the right one then...
10:47:02 <shapr> I get the same error without the shadowed part.
10:47:07 <ion> edwardk: I do appreciate its evilness. :-)
10:47:12 <edwardk> basically in ghc a dictionary that has exactly has one member has the same representation as that member
10:47:21 <shapr> Golly I wish my GSoC project were finished already so I could share my cabal session with you :_)
10:47:23 <luite> shapr: ugh then it unreigsterd the wrong one
10:47:50 <ion> edwardk: Alright
10:47:52 <shapr> Is there an easy way to fix this? Could I blow away all of ~/.cabal and ~/.ghc and start over?
10:47:58 <luite> shapr: remove ~/.ghc
10:47:58 <ClaudiusMaximus> shapr: ghc-pkg register the correct one
10:48:05 <edwardk> there is a less evil version https://github.com/ekmett/reflection/blob/master/slow/Data/Reflection.hs
10:48:07 <ClaudiusMaximus> shapr: then unregister the wrong one
10:48:13 <edwardk> but its about 3 orders of magnitude slower
10:48:40 <edwardk> still considerably faster than the original though
10:49:18 <ion> edwardk: I’d have preferred impossibru :: a
10:49:24 <edwardk> =)
10:52:01 <Guest51142> hi
10:52:49 <armlesshobo> Guest51142: hi, avis
11:03:34 <nand`> how would I go about debugging a segfault in a haskell application?
11:03:40 <nand`> are tools like gdb of any use here?
11:07:07 <c_wraith> gdb is of some use if the segfault is coming from native code
11:07:22 <c_wraith> it can give you a backtrace into the native library
11:07:38 <nand`> for starters I don't know if the segfault is coming from native code or not
11:07:46 <c_wraith> well, it can tell you that, too
11:08:17 <shergill> nand`: http://hackage.haskell.org/package/reflection
11:08:19 <shergill> oops
11:08:24 <shergill> nand`: http://hackage.haskell.org/trac/ghc/wiki/Debugging/CompiledCode?redirectedfrom=DebuggingGhcCrashes
11:08:40 <c_wraith> (the most common segfaults in ghc-generated code are from buggy native libraries, using native libraries incorrectly, and from bad FFI bindings to native libs)
11:09:19 <nand`> c_wraith: that may be a possibility; the segfault seems to occur some time during the startup sequence after some ncurses code is called, but the main program hasn't started yet
11:16:31 <illissius> edwardk: I'm getting instance conflicts between Data.Traversable.Instances and transformers when trying to install semigroupoids, even though my transformers is 0.3.0.0 and the #if in Data.Traversable.Instances would seem to guard against exactly that. Do you happen to have any idea why?
11:18:49 <Clint> is there a library that handles something like vacation time accrual?
11:29:54 <hpaste> Sagi pasted “First try at using Attoparsec” at http://hpaste.org/68684
11:30:59 <Sagi> anyone who can give me some pointers? I'm a bit lost at how to split up the parsing between separate parsers
11:33:27 <Sagi> My goal is to parse BGP messages, I created four data types for the different messages and now want a generic parser returning one of these (I created a typeclass for this purpose). I'm not sure if the errors I'm seeing are due to my inexperience with applicative style or something else :-)
11:34:13 <nand`> looks to me as if they need to have the same type
11:35:29 <nand`> bgpMsg :: BGPMsg b => Parser b -- means that the parser can, in any situation, parse *any type* that has a BGPMsg instance; it doesn't mean that it only returns one of many concrete types depending on some other conditions
11:35:53 <nand`> maybe you want something like data BgpMsg = OpenMsg ... | UpdateMsg ... | NotificationMsg ... | KeepaliveMsg ...
11:36:27 <Sagi> I had that earlier, but then it complains about double definitions as each of those is actually a separate data statement in record syntax
11:36:42 <Sagi> that's why I tried the class thingy
11:36:46 <nand`> so get rid of the separate types
11:37:07 <Sagi> oh duh
11:37:11 <nand`> no reason you can't put the record syntax on BgpMsg constructors
11:37:42 <Sagi> thanks, no idea why that didn't cross my mind.
11:37:51 <nand`> alternatively; if your separate types exist because those themselves have multiple constructors, just name them differently (and just unbind the BgpMsg wrappers in an approprate case match or whatever)
11:38:04 <nand`> s/unbind/unwrap/
11:38:12 <Sagi> some of them do, yes
11:38:12 <eikke> anyone ever done Inifinband/RDMA/iWarp stuff with Haskell?
11:38:37 <Sagi> what do you mean with 'just unbind'?
11:39:00 * Gurrag checking out that University of Reddit FP tutorial based on Haskell
11:39:19 <Sagi> doesn't the thing with one data statement make sure every message is a BGPMsg?
11:39:25 <nand`> ie some function  process :: BgpMsg -> IO (); process msg = case msg of OpenMsg o -> ...; UpdateMsg u -> ...;
11:39:31 <Sagi> that breaks if you keep them separate, doesn't it?
11:39:55 <nand`> or however your implementation is going to be structured internally
11:41:27 <nand`> think of BgpMsg as a big “Either ...” in this scenario; used only to glue together the bgpMsg Parser which can return one of many
11:41:52 <nand`> (I have no idea if this is good design practice, mind; just going by what would enable your function to exist)
11:42:16 <Sagi> hehe, I have no idea whether the current thing is good practice, I'm open to anything :-)
11:44:00 <Sagi> thanks, I'll rewrite my types and see where that gets me!
11:44:44 <ion> Can i ask mueval to print the type of an expression without evaluating it?
11:45:13 <ion> gwern: ↑
11:45:28 <gwern> ion: sure, if you install it and use that option.
11:45:42 <gwern> :t head "foo"
11:45:43 <lambdabot> Char
11:45:53 <gwern> lambdabot has a ghci script for :t
11:46:46 <nand`> come to think of it, I need to write my school project's protocol parsers to use some *parsec now; my current code just uses a decode :: Parsable p => ByteString -> p
11:47:02 <ion> So, :t doesn’t use mueval?
11:47:09 <nand`> but based on strict bytestrings, with lots of ugly splitting operations in between
11:47:15 <ion> I fail to see that option in mueval --help.
11:50:49 <RylandAlmanza> @type intersperse
11:50:49 <lambdabot> forall a. a -> [a] -> [a]
11:52:09 <RylandAlmanza> ghci is giving me "Not in scope: `intersperse'"
11:52:30 <geekosaur> it's in Data.List
11:52:38 <RylandAlmanza> thanks, geekosaur
11:52:44 <shachaf> theekosaur
11:52:49 <geekosaur> (at least, I assume you're using a ghc more recent than 6.8...)
11:53:06 <hpc> anyone using a ghc that old deserves trouble :P
11:53:38 <geekosaur> wait, intersperse is fine, I was thinking of intercalate
11:53:46 <geekosaur> (wrt ghc 6.8)
11:54:35 <RylandAlmanza> Why is ghci actuall showing "\n" instead of inserting a linebreak?
11:54:55 <hpc> > "bacon"
11:54:55 <monochrom> because you didn't use putStr
11:54:55 <lambdabot>   "bacon"
11:54:59 <hpc> > show "bacon"
11:55:00 <lambdabot>   "\"bacon\""
11:55:12 <ClaudiusMaximus> RylandAlmanza: use putStr or putStrLn, ghci uses print which uses show
11:55:21 <shachaf> Because that's how ghci shows strings.
11:55:24 <RylandAlmanza> oh, ok. Thanks
11:55:39 <monochrom> yeah, show and putStr are intentionally different, and for good reasons
11:56:16 <monochrom> show is intended for "what would you write as a literal in source code?"
11:57:13 <armlesshobo> show 123
11:57:18 <armlesshobo> > show 123
11:57:18 <lambdabot>   "123"
11:57:44 <armlesshobo> :t show
11:57:45 <lambdabot> forall a. (Show a) => a -> String
12:00:19 <nand`> this has gotten me thinking; is there some dual to IsString that has toString :: IsString' a => a -> String   <- which would not behave like show but actually convert something to a string equivalent, eg. for Text; fromString :: String -> String should be id
12:00:22 <nand`> toString*
12:01:17 <dcoutts_> nand`: "a string equivalent"?
12:01:23 <monochrom> usually, people implement show to be the inverse of fromString, too
12:01:52 <byorgey> but it isn't for String itself.
12:01:52 <RylandAlmanza> Whoo! I finished it!
12:02:03 <RylandAlmanza> Take a look at what you guys all helped me create!
12:02:09 <hpaste> RylandAlmanza pasted “Cellular Automata Cave” at http://hpaste.org/68685
12:02:42 * dcoutts_ thinks we should abolish Show and Read and replace them with a Term class for converting to/from untyped terms (which could then be shown/read in the traditional read/show syntax)
12:02:43 <byorgey> RylandAlmanza: cool =)
12:03:55 <Sagi> I should be able to do something smart with the information from length fields, right? Something like msg <- take len and then feed msg to a next stage parser?
12:04:21 <nand`> dcoutts_: that sounds sane, together with the actual Show being defined as “produce a sane text output of this value”, and not “produce a GHC-compatible representation which will evaluate back to the value”; with instance Show HaskellTerm being defined as the old show
12:05:08 <edwardk> illissius: interesting
12:05:08 <nand`> s/GHC/Haskell/
12:05:15 <edwardk> illissius: i had thought i had guarded it away
12:06:01 <dcoutts_> nand`: I quite like the Haskell compatible representation, though I accept it doesn't work with qualified modules etc etc
12:06:16 <weasels> n
12:06:38 <dcoutts_> nand`: but yes I think a untyped term typeclass would find many uses
12:06:46 <edwardk> illissius: i can't duplicate the problem here, but if you can figure out a patch i'll happily take/adapt it
12:07:03 <phy> @src repliate
12:07:03 <lambdabot> Source not found. Are you on drugs?
12:07:06 <dcoutts_> in text and binary serialisation, with some support for backwards/forwards compat
12:07:16 <phy> @src replicate
12:07:16 <lambdabot> replicate n x = take n (repeat x)
12:07:31 <dcoutts_> e.g. we don't really use read/show for serialisation because it's horribly fragile
12:07:39 <dcoutts_> as well as slow
12:07:43 <edwardk> src is such a departure from the usual tone of lambdabot
12:08:14 <nand`> I have expressed my dissatisfaction with @src's error messages on previous occasions
12:08:19 <nand`> I still consider it inappropriate
12:08:47 <nand`> especially when the function in question actually exists, @src just doesn't know about it for some reason
12:08:50 <rasfar> edwardk: unless you count vixen (if that even still exists)
12:09:12 <illissius> edwardk: Me too (think it should be guarded away), and yesterday applicative tried it and it worked for him/her. So I don't know what the difference could be. I wiped all my packages and started fresh and still ran into it. but I'm not the only one with the problem because this paste is by someone else: http://hpaste.org/68307
12:09:43 <monochrom> change all "you" to "I" :)
12:10:22 <illissius> edwardk: if I figure anything out i'll notify you, but probably I'm just going to fall back into wait-a-while-and-maybe-it'll-go-away mode :)
12:12:19 <Saizan> illissius: which Cabal version have you used to build?
12:12:45 <Saizan> illissius: cabal --version should tell, if you're using cabal-install
12:13:11 <illissius> Saizan: right. cabal-install version 0.8.2 using version 1.8.0.2 of the Cabal library
12:13:24 <dcoutts_> wow, properly old
12:13:32 <illissius> hmm
12:13:56 <edwardk> illissius: well, i've got nothing, so if you want it to be fixed, it'll probably take some external initiative ;)
12:14:05 <Saizan> istr a bug in the MIN_VERSION_foo macros
12:14:13 <edwardk> what version of ghc?
12:14:20 <illissius> edwardk: 7.4
12:14:53 <Saizan> you should try with a newer Cabal/cabal-install
12:15:21 <illissius> Saizan: I'm not entirely clear on what's handled by cabal-install, what by Cabal, and what their relationship is. ghc-pkg list says I have Cabal-1.14.0
12:15:24 <armlesshobo> I'm having a rough time understanding Maybe
12:15:35 <edwardk> does anyone have a guess at the cabal version when that was fixed? i think i have that package claiming a need for 1.6
12:15:36 <illissius> but cabal-install's using an older version?
12:15:39 <armlesshobo> I think I'm just thinking about it improperly
12:16:04 <illissius> anyway, yeah, I'll try upgrading and maybe that'll fix it
12:16:30 <monochrom> Maybe gives you two choices: "no answer", "has answer, here it is: 4". that is all.
12:16:32 <Saizan> illissius: to avoid compiling the Setup.hs, cabal-install will use the Cabal lib he was compiled against if the build-type is Simple
12:16:41 <dcoutts_> edwardk: what fix are we talking about?
12:16:49 <Saizan> illissius: you can override that with --cabal-lib-version=1.14.0 though
12:17:02 <Saizan> s/he/it/
12:18:12 <edwardk> illissius: let me know
12:18:28 <edwardk> i started using MIN_VERSION_foo a lot more aggressively over the last few weeks
12:18:44 <Saizan> dcoutts_: istr a bug in the generation of the MIN_VERSION_pkg macros, which might explain why illissius with its old Cabal would get weird results, that's the bug
12:18:46 <edwardk> so if that is the culprit it may affect dozens of packages now
12:18:59 <dcoutts_> ah yes
12:19:24 <edwardk> dcoutts_/Saizan: any idea what version those problems were in?
12:19:38 <dcoutts_> edwardk: it's not using it that's the problem but using #if !MIN_VERSION_pkg(...)
12:19:46 <illissius> edwardk, Saizan: --cabal-lib-version=1.14.0 fixed it. thanks!
12:20:02 <edwardk> dcoutts_: thats exactly what i'm doing
12:20:06 <dcoutts_> edwardk: because the macro used not to expand to an expr with outer ()'s, so the ! then applied to the wrong thing
12:20:13 <edwardk> ah
12:20:22 <dcoutts_> edwardk: you can work around it by using !(...)
12:20:30 <edwardk> so if i surround it in parens whenever i negate it it should be usable on old cabals?
12:20:38 <dcoutts_> exactly
12:20:44 <edwardk> i'll go hunt for uses of it and update them
12:20:47 <dcoutts_> but I think it was probably fixed in 1.10
12:22:08 <edwardk> illissius: i'm pushing 1.3.2 of semigroupoids momentarily, i'd like you to test it
12:22:22 <edwardk> illissius: uploaded
12:22:39 <edwardk> illissius: see if that works without the --cabal-lib-version
12:22:51 <illissius> roger
12:22:52 <edwardk> i'll go back and chase down others
12:24:11 <edwardk> wow this infects a lot of my packages
12:24:22 <edwardk> thanks for the catch
12:25:45 * hackagebot semigroupoids 1.3.2 - Haskell 98 semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-1.3.2 (EdwardKmett)
12:25:46 <armlesshobo> do most of you use editors like emacs/vi instead of something like leksah?
12:25:47 * hackagebot charset 0.3.2 - Fast unicode character sets based on complemented PATRICIA tries  http://hackage.haskell.org/package/charset-0.3.2 (EdwardKmett)
12:26:02 <RylandAlmanza> What should I use as the parameter for mkStdGen? Right now, I use the same parameter every time for my cave generator, so it always generates the same cave. The parameter is like a seed, right?
12:26:32 <RylandAlmanza> armlesshobo: I usually use vi, but I'm trying out sublime text 2, and liking it a lot for haskell.
12:26:50 <illissius> edwardk: yep, works now, thank you
12:26:54 <RylandAlmanza> I just started with haskell though, so don't use me as a reference
12:26:56 <nand`> @hoogle IO StdGen
12:26:56 <lambdabot> Did you mean: :: IO StdGen
12:26:57 <lambdabot> No results found
12:27:03 <nand`> @hoogle :: IO StdGen
12:27:04 <lambdabot> System.Random getStdGen :: IO StdGen
12:27:04 <lambdabot> System.Random newStdGen :: IO StdGen
12:27:04 <lambdabot> Prelude readLn :: Read a => IO a
12:27:13 <byorgey> RylandAlmanza: just use  getStdGen
12:27:26 <byorgey> which will seed it using some sort of default source (like the time or something else)
12:28:03 <armlesshobo> RylandAlmanza: hmm. i've never heard of sublime text 2
12:28:13 <RylandAlmanza> so, would it be randoms (mkStdGen getStdGen)? or just randoms (getStdGen)
12:28:37 <rwbarton> neither
12:28:47 <RylandAlmanza> armlesshobo: "It's like the rising star of text editors" - haxe.org
12:29:13 <dmwit> RylandAlmanza: The only really correct solution is to save your generator's state across runs of the program.
12:29:16 <otters> sublime text 2 is like a shitty version of chocolat/textmate
12:29:31 <dmwit> The half-correct solution is to use getStdGen as byorgey suggests, though.
12:30:03 <RylandAlmanza> otters: Really? Having not tried either of those, I thought it was great. Do I have to download YET ANOTHER text editor now?
12:30:08 <byorgey> why only half-correct?  Does it end up using the same seed if you run the program too fast in succession, or something like that?
12:30:12 <otters> RylandAlmanza: does it have tabs/splits yet?
12:30:24 <nand`> iirc emacs seems to be the most popular for Haskell; I used to use Sublime text 2 until I bothered to sit down and learn vim, now I use that exclusively
12:30:27 <dmwit> byorgey: PRNGs have various nice properties that you expect proofs of.
12:30:36 <kobsu> RylandAlmanza: no... st2 is good
12:30:41 <dmwit> byorgey: But the sequence of first answers from various seeds do not have those properties.
12:30:44 <nand`> otters: it definitely does
12:30:45 * hackagebot comonad 1.1.1.6 - Haskell 98 compatible comonads  http://hackage.haskell.org/package/comonad-1.1.1.6 (EdwardKmett)
12:30:48 <nand`> kobsu: but unfortunately non-free
12:30:52 <rwbarton> he's writing a cave generator, i don't think he needs to be able to prove things about it
12:30:54 <nand`> and also graphical
12:30:58 <otters> okay, I used it before it had tabs
12:30:59 <dmwit> e.g. the sequence of first numbers generated by the seeds [0..10] might all be even or something else equally non-random.
12:31:02 <otters> so it's probably fine now
12:31:25 <byorgey> fair enough.  But since RylandAlmanza is just using this for an ASCII-art cave generator, I really doubt it matters all that much =P
12:31:36 <dmwit> =)
12:33:28 <nand`> is there some RandomGen that uses /dev/random internally?
12:33:36 <nand`> wait
12:33:42 <nand`> you could just open that with regular file IO
12:34:00 <arcatan> indeed
12:34:14 <RylandAlmanza> I'm still not sure how to use getStdGen to generate a list of random numbers
12:35:03 <RylandAlmanza> rwbarton: Did you see what you helped me generate yet? http://hpaste.org/68685
12:35:21 <armlesshobo> RylandAlmanza: http://stackoverflow.com/questions/10220463/how-do-i-use-newstdgen-or-getstdgen-instead-of-mkstdgen-in-haskell
12:35:24 <armlesshobo> this might help
12:35:47 * hackagebot recursion-schemes 2.0.2 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-2.0.2 (EdwardKmett)
12:36:32 <dmwit> :t getStdGen
12:36:34 <lambdabot> IO StdGen
12:36:36 <rwbarton> RylandAlmanza: ah no, thanks, I was going to ask to see the output actually, your project sounds cool :)
12:36:36 <dmwit> :t mkStdGen
12:36:38 <lambdabot> Int -> StdGen
12:36:47 <edwardk> ah, looks like it was just those 4 packages that used it negated
12:36:54 <dmwit> You use getStdGen just like mkStdGen, except it does a bit of IO first and doesn't ask you for a seed.
12:36:57 <edwardk> all set
12:37:06 <rwbarton> RylandAlmanza: neat
12:37:31 <RylandAlmanza> You're a good man, armlesshobo
12:37:38 <RylandAlmanza> Thanks, rwbarton
12:38:09 <RylandAlmanza> You're a good man as well, you helped me a lot. :)
12:38:30 <armlesshobo> RylandAlmanza: lol ty
12:44:54 <Sagi> how do I run a Parser inside a Parser definition? I want to parse a bytestring previously obtained using "take" without resorting to two separate parse calls.
12:45:17 <Sagi> (still trying to do something sensible with a length field in binary packet format)
12:45:43 <hpc> str <- parse bytestring
12:45:54 <hpc> let result1 = runParser p1 str
12:46:00 <hpc> let result2 = runParser p2 str
12:46:01 <hpc> ...
12:46:34 <Sagi> hmm, let me think about that :-)
12:47:04 <hpc> however, you probably want try and (<|>)
12:48:54 <Sagi> the format is like <field, field, len, body (size len)>. My intuition says to do a 'body <- take len', but then I should somehow continue with this body within the function
12:49:09 <Sagi> the solution you propose leaves you with Result types, doesn't it
12:52:27 <uniquenick> I need to group tuples, like tuple1 (a,b,c) = ((a), (b,c)) and tuple1 (a,b,c,d) = ((a),(b,c,d)).  Is there a way to do that with a typeclass?
12:53:31 <shachaf> It's probably possible but it's also likely that you don't want it. :-)
12:53:42 <shachaf> (Why do you want it?)
12:54:46 <uniquenick> I get lists of stuff like [(a,b,c)], where some portion of those is redundant, and the other is unique
12:55:22 <uniquenick> and I want to group on the redundant portion so like [(a,b,c)] becomes (a, [(b,c)])
12:55:30 <Sagi> hey, I think I can simply flip the arguments to parse
12:56:12 <uniquenick> but it could also need to be that [(a,b,c)] becomes (a,b, [c])
12:57:01 <uniquenick> so if I turn it into (a,(b,c)) or ((a,b),c) first, then I can easily do the grouping
12:59:21 <kallisti> the documentation on GHC.Generics is rather sparse.
13:06:53 <eacameron> why do I have to manually do `fromIntegral (length xs)` to convert to Integer from Int??
13:07:24 <eacameron> isn't Int a subset of Integer?
13:07:40 <mauke> no
13:07:46 <mauke> Int isn't a set
13:08:01 <adamt> What is it then? A circular list? :-)
13:08:15 <geekosaur> strictly typed languages do not "promote" or convert types for you
13:08:27 <mauke> Int is a type
13:09:10 <adamt> Stupid question
13:09:12 <adamt> Is Int unboxed and Integer boxed?
13:09:38 <eacameron> mauke: I realize that, I mean Int is bounded and Integer is unbounded, so the "conversion" should be implicit, no?
13:09:55 <mauke> adamt: no
13:10:05 <mauke> eacameron: why should it be implicit?
13:10:22 <sepp2k> adamt: No, both are boxed. Int is a fixed-width integer and Integer is an arbitrary precision integer.
13:10:25 <alpounet> adamt, unboxed types have # at the end of their name
13:11:08 <eacameron> mauke: I guess the *real* question is why does `length` return an Int and not a Num?
13:11:17 <mauke> :t genericLength
13:11:18 <lambdabot> forall b i. (Num i) => [b] -> i
13:11:36 <mauke> for efficiency, probably
13:11:47 <geekosaur> strictly typed languages never do implicit conversions
13:12:18 <mauke> and what is a "strictly typed language"?
13:12:30 <adamt> geekosaur: don't you mean static typed?
13:12:37 <mauke> adamt: no
13:12:46 <eacameron> mauke: ahh! there *is* a length that does what I want! ;) Yeah...I agree that implicit type conversion would be bad...
13:21:20 <shergill> edwardk: so, is there any situation where reader would be preferred to reflection? or does the reflection approach obsolesce the reader monad?
13:23:31 <hpaste> Sagi pasted “BGP parsing using Attoparsec for dummies” at http://hpaste.org/68688
13:23:48 <Sagi> hpc: I tried the solution you proposed, but I either misunderstood or didn't implement it right, because I'm still stuck with a Result instead of a Parser as type.
13:27:01 <adamt> Why is that dividing a NominalDiffTime with another NominalDiffTime yields a result of type NominalDiffTime, instead of a regular number of sorts?
13:27:30 <Gurrag> is it considered poor form to import from Prelude?
13:28:11 <hpc> :t (/) -- adamt
13:28:12 <lambdabot> forall a. (Fractional a) => a -> a -> a
13:28:22 <hpc> Gurrag: Prelude is automatically imported
13:28:35 <Gurrag> thank you
13:29:23 <adamt> hpc: Okay, i see. It still hurts a bit on the inside. Thanks.
13:30:00 <hpc> Sagi: hmm, try asking again; i don't know parsec very well
13:30:02 <rwbarton> yes, NominalDiffTime as a Num instance is sort of bad but there isn't really a better alternative within the standard hierarchy of numeric type classes
13:30:53 <EvanR> when writing an attoparsec parser, how to produce a list of values parsed from lines of text
13:31:05 <Gurrag> Is there any "haskell beginners'" irc channel here?
13:31:10 <EvanR> without having to reverse a list or use data.sequence or something
13:31:24 <navaati> Gurrag: it's #haskell
13:31:28 <navaati> ask your questions
13:31:41 <kallisti> Gurrag: importing from Prelude is pretty common to avoid overlapping names with other modules.
13:31:52 <Sagi> hpc: okay, thanks for your time though
13:31:57 <kallisti> I wouldn't say it's poor form if you have a reason to.
13:32:15 <kallisti> for example:  import Prelude hiding (catch)
13:32:45 <kallisti> will override the implicit Prelude import, and hide the symbol catch, which is also a function in Control.Exception with different behavior.
13:32:49 <EvanR> import qualified the non prelude thing
13:34:08 <kallisti> I think there are plenty of situations where it would be incredibly cumbersome to do it that way.
13:34:39 <EvanR> ah ok, the answer to my question is to use for
13:34:42 <EvanR> forM
13:34:43 <Sagi> (attoparsec) how can I do a "subparse" on a length delimited binary protocol field? In other words, how can the next rule in a Parser act on the result of the previous Parser and not on the next input? http://hpaste.org/68688
13:35:10 <EvanR> @src forM
13:35:11 <lambdabot> forM = flip mapM
13:35:20 <EvanR> @src mapM
13:35:20 <lambdabot> mapM f as = sequence (map f as)
13:35:29 <EvanR> @src sequence
13:35:30 <lambdabot> sequence []     = return []
13:35:30 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
13:35:30 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
13:35:44 <kallisti> :t sequence
13:35:45 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
13:35:48 * hackagebot PortFusion 1.0.4 - high-perf. distributed reverse / forward proxy & tunneling solution for TCP  http://hackage.haskell.org/package/PortFusion-1.0.4 (CetinSert)
13:35:55 <navaati> oh, lambdabot has alternative definitions ! great
13:36:31 <EvanR> thats great
13:36:35 <hpc> lambdabot doesn't have very many
13:36:38 <EvanR> so it builds the list forward
13:36:42 <hpc> and the monadic ones aren't any of them
13:36:56 <hpc> :t (.) -- fmap
13:36:57 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:37:13 <hpc> :t flip -- flip fs x = fmap ($ x) fs
13:37:13 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
13:37:17 <hpc> :t (++) -- mappend
13:37:18 <lambdabot> forall m. (Monoid m) => m -> m -> m
13:37:22 <hpc> and that's all i remember
13:37:55 <kallisti> hpc: believe he/she was referring to @src
13:38:00 <kallisti> not Caleskell.
13:38:11 <EvanR> :t forM
13:38:12 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
13:38:22 <EvanR> :t whileM
13:38:23 <lambdabot> Not in scope: `whileM'
13:38:58 <hpc> kallisti: oh
13:39:46 <navaati> yeah, i was referring to the "lambdabot: -- OR: sequence = blah"
13:39:52 <EvanR> er, why is there no whileM or untilM
13:40:04 <kallisti> EvanR: good question
13:40:07 <kallisti> however you can find them here
13:40:12 <kallisti> @hackage monad-loops
13:40:13 <lambdabot> http://hackage.haskell.org/package/monad-loops
13:40:27 <kallisti> there's also an ifM here:
13:40:32 <kallisti> @hackage cond
13:40:33 <lambdabot> http://hackage.haskell.org/package/cond
13:41:02 <kallisti> I think ifM is common enough to be included in Control.Monad
13:41:35 <EvanR> never wanted a ifM
13:41:44 <kallisti> it'll happen. ;)
13:41:45 <EvanR> i use when sometimes though
13:42:05 <kallisti> 20 or so temporary Bool variables later, you'll wish there was an ifM
13:42:17 <EvanR> just avoid bool variables ;)
13:42:32 <kallisti> well, without an if', that's not easy either
13:42:47 <kallisti> avoid all conditional execution of IO? okay. I'll work on that. :P
13:43:25 <lucian> is there a way to pattern match a Maybe with a let?
13:43:36 <lucian> i know i can do let (Just x) = ...
13:43:40 <c_wraith> lucian: if you want to branch, no
13:43:50 <lucian> but i don't know i can set x to a default value otherwise
13:43:56 <c_wraith> lucian: though you can use a case and a let together...  let x = case foo of...
13:43:58 <kallisti> use a case expression instead. or one of the functions from Data.Maybe
13:44:00 <EvanR> let (Just x) = ... works but crashes if its Nothing
13:44:04 <lucian> c_wraith: so do i need to pattern match in a function? oh, case
13:44:16 <kallisti> > fromMaybe 2 (Just 4)
13:44:17 <lambdabot>   4
13:44:20 <kallisti> > fromMaybe 2 Nothing
13:44:21 <lambdabot>   2
13:44:23 <EvanR> use maybe and fromMaybe
13:44:31 <lucian> kallisti: that's precisely what i want, thanks!
13:44:40 * lucian is going through lyah
13:44:52 <kallisti> maybe is worth a look too. it's a generalization of fromMaybe.
13:45:10 <applicative> @type maybe
13:45:11 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:48:00 <edwardk> shergill: reflection can only be used if you can find some sort of 'stack discipline' to the way you introduce and eliminate the quantified variables it uses, so sometimes you have to use reader. another example is that while you can use Tagged s a as a kind of reader monad, you can't ever call 'local' on it
13:49:28 <schlicht> can i use let or where in an anonymous function?
13:49:38 <kallisti> you can use let in any expression
13:49:42 <kallisti> but you can't use where in a lambda.
13:50:13 <shergill> edwardk: i've never really encountered a use case for local. usually if i need that ability, i just go in for state. it could just be as a result of my limited programming experience in haskell though
13:50:17 <kallisti> you can use where after function definitions and after cases in a case expressions
13:50:46 <schlicht> okay, thanks :)
13:51:13 <edwardk> shergill: yeah. personally i think baking local into MonadReader was a mistake. (it should exist in a separate class)
13:51:29 <edwardk> since it rules out a lot of useful reader-like monads
13:51:54 <shergill> agree
13:54:33 <clearwaterreviva> Does haskell make design patterns obsolete?
13:54:57 <ezyang> clearwaterreviva: It certainly makes a class of design patterns unnecessary
13:55:43 <monochrom> some
13:56:44 <monochrom> most design patterns weren't even designed for haskell
13:57:36 <arcatan> then again, haskell probably has some design patterns of its own
13:57:39 <lucian> in fact, many good languages make many design patterns unnecessary
13:58:36 <kallisti> I'm pretty design patterns are only applicable to Java-like languages.
13:58:41 <kallisti> many of them.
13:58:49 <hpc> arcatan: i think the use of TH to define lenses counts as a design pattern
13:59:06 <kallisti> monads are design patterns.
13:59:13 <adamt> which patterns are turned absolute by Haskell?
13:59:25 <shapr> Huh, cabal-dev is nifty.
13:59:28 <lucian> kallisti: general things like "reactor pattern" aren't strictly for java, though
13:59:31 <monochrom> the command pattern. the composite pattern
13:59:52 * lucian is a python dev and hardly knows any "patterns"
14:00:09 <lucian> i find the vast majority of them to be a failure of the language when it comes to DRY
14:00:12 <adamt> lucian: Just don't get a job involving enterprise java. =/
14:00:19 <lucian> adamt: i make a point of it :)
14:00:31 <kallisti> "Lazy initialization" is a pattern we use a lot. ;)
14:00:54 <shapr> tying the knot
14:00:55 <monochrom> that is like singleton done right
14:01:15 <hpc> floating let, for memory management
14:01:25 <shapr> Perhaps design patterns are just common idioms?
14:01:36 <hpc> shapr: i would call them workarounds for language limitations
14:01:48 <shapr> worker wrapper?
14:01:57 <lucian> hpc: although perhaps not all of them
14:01:59 <hpc> Monad isn't a design pattern, for instance
14:02:02 <hpc> it's an abstraction
14:02:03 <lucian> some are general concepts
14:02:14 <kallisti> but RWS is a design pattern.
14:02:19 <lucian> like callbacks
14:02:34 <hpc> if you didn't have Monad as a type class, and had to define returnMaybe, returnList, returnIO
14:02:38 <hpc> that's a design pattern
14:02:46 <hpc> er, bad example
14:03:13 <hpc> liftM2Maybe, liftM2List, liftM2IO
14:03:25 <kallisti> many libraries/applicables use prototypes quite a bit
14:03:33 <kallisti> by providing default records to override.
14:03:39 <gentleben> cps is a design pattern that I have used in a bunch of languages
14:03:41 <kallisti> *applications
14:04:25 <hpc> gentleben: same
14:04:31 <hpc> except mostly perl
14:04:38 <monochrom> I'm inclined to take design patterns as idioms or workarounds, depending on specific cases
14:04:41 <gentleben> i used it a lot in c#
14:04:47 <kallisti> we use the "adapter pattern" quite a bit with newtype wrappers.
14:04:59 <kallisti> or other kinds of transformations.
14:05:02 <hpc> monochrom: perhaps "design pattern" = "unabstracted abstraction"
14:05:03 <kallisti> and wrappers.
14:05:18 <monochrom> ah that's a good one!
14:05:34 <hpc> where instead of abstracting away those two nested for loops, you memorize the "pattern" of writing them everywhere
14:05:55 <hpc> or instead of using ContT, you CPS-transform your code
14:06:05 <byorgey> "design pattern" = "unabstracted abstraction"  -- I like that!
14:06:29 <byorgey> hpc++
14:06:33 <hpc> :D
14:07:27 <joelr> moin
14:07:28 <kallisti> I'd say the interpreter pattern is relevant to Haskell, in the context of domain-specific languages.
14:07:40 <shapr> Gutentag joelr
14:07:56 <joelr> are people using happstack these days? i need a scalable smtp server (just receive email and dispatch programmatically)
14:08:06 <monochrom> well yeah, and interpreter done in haskell is much less boilerplate than interpreter done in java or c++
14:08:12 <shapr> joelr: You could also try Peter Simons' postmaster
14:08:21 <kallisti> yes. that's why the design pattern is more relevant to Haskell.
14:08:35 <joelr> shapr: is that haskell? is it on github?
14:08:41 <shapr> Yes, and I don't know.
14:08:59 <joelr> shapr: thanks for the tip!
14:09:00 <shapr> joelr: https://gitorious.org/postmaster
14:09:53 <joelr> shapr: he seems to be rewriting it in c++
14:09:58 <joelr> i wonder why
14:10:02 <shapr> I dunno.
14:10:31 <stepcut> joelr: yup. it is still under active development
14:10:50 <kallisti> oh I didn't know postmaster was Haskell.
14:10:52 <stepcut> joelr: however, the HAppS-SMTP server was deprecated a long time ago
14:11:11 <joelr> stepcut: happs = happstack, i suppose. ok
14:11:17 <stepcut> joelr: yeah
14:11:18 <joelr> stepcut: what's under active development?
14:11:29 <navaati> omg, is it possible to rewrite haskell to C++ ? must be hell
14:11:36 <joelr> stepcut: what's the smtp replacement then?
14:12:15 <stepcut> joelr: happstack is still under development.. but not the SMTP or DNS components. Mostly just things related to http/https
14:12:23 <absence> mm_freak: sorry to bother you about this again, i have trouble understanding how to use <|> instead of holdWith/injectEvent. would you mind taking a quick look at http://hpaste.org/68691 ?
14:12:37 <joelr> stepcut: are you actively involved?
14:12:49 <stepcut> joelr: yes. I am the current maintainer
14:13:31 <EvanR> how does this look
14:13:33 <EvanR> http://codepad.org/PC7NLaFh
14:13:40 <joelr> stepcut: i need to receive email (possibly mime?) to a randomly assigned email address, think uuid. then treat it as a request to do something and treat the email address the mail was sent to as a key to lookup stuff
14:14:23 <stepcut> joelr: well. as I said… the SMTP stuff is gone, so happstack won't really help you there.. unless you need a web interface as well
14:15:12 <joelr> stepcut: why was it gone? why not just leave it in? and yes, i would need a web server too
14:16:52 <stepcut> joelr: well, it was removed before I took over. But even just keeping it building takes time. the SMTP stuff never even made it into happstack I think. You can probably still get the HAppS-SMTP code if you want
14:17:03 * joelr is somewhat distressed at the thought of having to start by re-implementing an smtp server
14:19:20 <RylandAlmanza> Ok, I'm sorry that I keep asking the same question, but I'm having trouble understanding how to properly get random values. I'm trying to fill a tilemap (represented as a [[Bool]]) with random values. Here's what I have so far:
14:19:23 <hpaste> RylandAlmanza pasted “Creating a list of lists of random bools” at http://hpaste.org/68692
14:19:31 <joelr> does peter simons hang around here?
14:20:19 <dmwit> RylandAlmanza: That looks like it will create h copies of a single row.
14:20:39 <EvanR> when writing an attoparsec parser, how do i throw a parse error
14:20:41 <EvanR> fail?
14:20:58 <dmwit> RylandAlmanza: Have you considered something like "take h . chunk w", where "chunk" is from "Data.List.Split" in the "split" package?
14:21:04 <RylandAlmanza> dmwit: It would, but I'm passing i to mkStdGen as a parameter, so it's a different random generater for each row
14:21:23 <dmwit> RylandAlmanza: Oh, you're not going to get very much randomness from that approach.
14:21:30 <RylandAlmanza> exactly
14:21:32 <shapr> joelr: I haven't seen him here in a year or two.
14:21:40 <shapr> joelr: But he's very responsive to email.
14:21:46 <dmwit> RylandAlmanza: As I was saying earlier, the sequence of first (resp. second, third) numbers from sequential seeds is not random.
14:21:59 <dmwit> ...not even pseudorandom. =)
14:22:02 <joelr> shapr: is he the cryp.to guy?
14:22:08 <shapr> Yup, that's him.
14:22:34 <joelr> allright, i emailed him
14:22:44 <shapr> Not to be confused with the cr.yp.to guy :-)
14:23:13 <EvanR> RylandAlmanza: the first few outputs from generators as a function of the seed is never how RNGs are designed
14:23:29 <EvanR> the first few outputs as a function of the seed arent going to be random
14:23:35 <EvanR> because thats not how theyre designed
14:23:46 <stranac> hello haskell people
14:23:58 <shapr> stranac: bok hrvatska people!
14:24:00 <stranac> i'd like to learn haskell and looking for a good book
14:24:04 <nand`> @where lyah
14:24:04 <lambdabot> http://www.learnyouahaskell.com/
14:24:08 <nand`> ^- stranac
14:24:17 <shapr> stranac: and possibly Real World Haskell
14:24:20 <EvanR> seed the generator and never reseed
14:24:24 <lucian> lyah is great
14:24:37 <shapr> I haven't seen the author around here in awhile though, too bad.
14:24:59 <stranac> thx, i'll check those out
14:25:34 * shapr grumbles at cabal-dev
14:26:33 <shapr> Is anyone here using chris done's most recent version of haskell-mode ?
14:26:42 <RylandAlmanza> > chunk 2 [0, 1, 0, 1, 0, 1, 0, 1]
14:26:43 <lambdabot>   Not in scope: `chunk'
14:26:48 <shapr> For whatever reason, C-c C-z gives me a prompt, but I can't type anything :-(
14:28:33 <RylandAlmanza> What do I import to use chunk? I tried Data.List and Data.List.Split
14:28:51 <Peaker_> mauke, hey, you there?
14:29:25 <shapr> @hoogle chunk
14:29:25 <lambdabot> Data.Text.Lazy.Internal chunk :: Text -> Text -> Text
14:29:25 <lambdabot> Network.HTTP.Base chunkedTransfer :: BufferOp a -> IO (Result a) -> (Int -> IO (Result a)) -> IO (Result ([Header], a))
14:29:25 <lambdabot> Data.Text.Lazy.Internal chunkOverhead :: Int
14:29:31 <rwbarton> isn't it chunks?
14:29:35 <rwbarton> @hoogle chunks
14:29:35 <lambdabot> package chunks
14:29:35 <lambdabot> Data.Text chunksOf :: Int -> Text -> [Text]
14:29:35 <lambdabot> Data.Text.Lazy chunksOf :: Int64 -> Text -> [Text]
14:29:40 <rwbarton> hmm
14:29:41 <monochrom> hpc: https://plus.google.com/102208456519922110915/posts/LXxRByiCMV4 :)
14:29:58 <rwbarton> oh no
14:30:02 <shachaf> I assume if you look through the Data.List.Split documentation you'll find what you're after.
14:30:07 <rwbarton> it should be in Data.List.Split...
14:30:34 <joelr> is anyone using zeromq with haskell?
14:30:55 <joelr> any other means to scale beyond a single process?
14:31:03 <rwbarton> RylandAlmanza: wait, was the error with Data.List.Split that the module couldn't be found?
14:31:11 <RylandAlmanza> yeah
14:31:13 <tzxn3> a lot of monads seem to have an accompanying runX function
14:31:18 <tzxn3> runState, runWriter
14:31:20 <byorgey> @hoogle chunk +split
14:31:21 <lambdabot> Could not find some databases: split
14:31:21 <lambdabot> Searching in:
14:31:21 <lambdabot>   .
14:31:21 <adimit> RylandAlmanza: install packages split.
14:31:23 <rwbarton> You probably should have mentioned that :) You have to install it.
14:31:26 <tzxn3> what exactly does it do?
14:31:33 <adimit> RylandAlmanza: cabal install split.
14:31:33 <RylandAlmanza> ah, ok
14:31:41 <byorgey> tzxn3: it's different for each monad.
14:31:55 <tzxn3> in a general sense
14:31:57 <nand`> :t splitEvery
14:31:58 <lambdabot> Not in scope: `splitEvery'
14:32:10 <tzxn3> bind is different for each monad but it has a general concept behind it
14:32:24 <RylandAlmanza> aha! Thanks, guys
14:32:32 <byorgey> tzxn3: but bind is a method of the Monad class.  runX is not.
14:32:38 <tzxn3> aye
14:32:57 <byorgey> tzxn3: however, generally I guess you can say that the runX methods "run" the monad: they have some type "like"  m a -> a
14:33:05 <tzxn3> but it must have some general unifying concept
14:33:09 <byorgey> except they usually take other arguments, and may return extra stuff along with the a
14:33:14 <nand`> well for example Reader or State are just monad wrappers around types like “s -> ” or
14:33:22 <nand`> “s -> a” or “s -> (a, s)”
14:33:26 <byorgey> @type runWriter
14:33:27 <lambdabot> forall w a. Writer w a -> (a, w)
14:33:32 <nand`> and the “runX” accompanying it just un-wraps this
14:33:47 <byorgey> for example, runWriter takes a Writer computation and "runs" it, giving you the final a along with the "log" of type w
14:33:54 <byorgey> @type runState
14:33:55 <lambdabot> forall s a. State s a -> s -> (a, s)
14:34:10 <EvanR> :t mplus
14:34:11 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
14:34:14 <byorgey> runState takes a State computation, along with an initial state, and runs it, giving you the value of type a and the final state
14:34:15 <EvanR> :t mconcat
14:34:16 <lambdabot> forall a. (Monoid a) => [a] -> a
14:34:28 <EvanR> :t msum
14:34:29 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
14:34:29 <tzxn3> nice
14:34:30 <byorgey> tzxn3: does that make sense?
14:34:33 <tzxn3> yeah
14:34:54 <twopoint718> join #plan9
14:34:59 <shapr> twopoint718: good idea
14:35:03 <twopoint718> oops, hahah
14:35:04 <dmwit> runIO = unsafePerformIO
14:35:10 <nand`> tzxn3: if you look at the definition for State etc. what I'm saying might become more clear: newtype State s a = State { runState :: s -> (a, s) }
14:35:29 <nand`> it's just a convenient newtype wrapper, with runState being the associated un-wrapper
14:35:55 <byorgey> in my opinion, the fact that the runX methods for State, Reader, and Writer happen to be newtype projections is kind of misleading.  Or I should say it's sort of a "pun"
14:35:56 <dmwit> s/convenient/inconvenient/
14:36:00 <nand`> (of course the definition I gave isn't entirely correct, it's in reality implemented in terms of StateT)
14:36:09 <byorgey> that's not really what they *are*
14:36:20 <dmwit> byorgey++
14:36:56 <nand`> byorgey: you have a point, it's best to just look at the types of these things
14:37:03 <EvanR> because it can be done that way doesnt mean it should
14:37:04 <byorgey> oh, right, runState, runReader, etc. actually *aren't* newtype projections anymore!
14:37:09 <twopoint718> shapr: I came for the quirky OS, but I stayed for the Rc shell!
14:37:32 <dmwit> came for the OS, stayed for the string return type
14:37:44 <dmwit> Screw you, exit codes! I'm going to actually *say* what went wrong!
14:38:08 <nand`> twopoint718: but is it a type safe shell?
14:38:23 <dmwit> Yes. However, there is only one type.
14:38:24 <Polarina> Why does the conduit library have to be so complex? :/
14:38:52 <byorgey> oh, cool.  with a string return type you can give errors like "Error: -1.  Please see the user manual for a table of error codes."
14:38:59 <dmwit> hehehe
14:39:09 <nand`> we need a lazy shell where every runnable program is an arrow in Kleisli IO
14:39:10 <byorgey> then no one has to wonder what -1 means
14:39:16 <nand`> lazy, type safe
14:39:31 <EvanR> to continue please refer to the secret codes in the manual included with the floppy diskette
14:39:54 <nand`> “please consult the man page for a list of error codes” “No manual entry for batbaz”
14:40:59 <dmwit> stealing Vilhelm's joke now
14:41:12 <dmwit> From the table of error codes: "Error code -1: other error."
14:41:55 <nand`> “Error code -2: (FIXME: Add error descriptions)”
14:42:04 <nand`> open source software ^
14:42:34 <dmwit> "Please see the source code. There is no other way to know for sure what -1 means."
14:43:15 <blarg> how do i do something like the following in haskell (the right way)
14:43:18 <blarg> type CommandDatabase = Map.Map String ([String] -> a) execute :: CommandDatabase -> CommandWords -> a
14:43:20 <dmwit> followed by discovering that -1 occures 6253 times in the codebase
14:43:45 <blarg> i want to make a generic command line interface
14:43:59 <blarg> do i use Typeable?
14:44:03 <dmwit> blarg: Two things; first, you need the "a" on the LHS of the type declaration:
14:44:14 <dmwit> type CommandDatabase a = Map String ([String] -> a)
14:44:19 <joelr> are there any haskell bindings to amazon dynamodb?
14:44:26 <dmwit> second: you can't possibly hope to always return an a; at best, Maybe a
14:44:35 <dmwit> If you agree that's acceptable, then:
14:44:43 <blarg> dmwit, but then a isn't generic is it? it's only what it is when i instantiated it
14:45:06 <dmwit> execute db (w:ws) = fmap ($ws) (Map.lookup w db)
14:45:16 <dmwit> blarg: yes
14:45:23 <blarg> yes it isn't generic?
14:45:27 <dmwit> yes
14:45:28 <byorgey> blarg: do you really want to allow different commands to return different types?
14:45:35 <blarg> yes byorgey
14:45:39 <byorgey> think carefully.  What would you do with them?
14:45:57 <blarg> whatever someone wants to define the commands as
14:46:12 <dmwit> joelr: If you don't see anything on Hackage, the answer is probably "no".
14:46:20 <joelr> ok
14:46:27 <byorgey> I mean, what can you do with the output of a command if you don't know what type it is?
14:46:55 <nand`> personally I think [String] ->  is already a bit too lenient, I would be in favor of somehow using types to your advantage to enforce the right arguments to a command; then using the calling code to check whether the user-supplied command line can actually fit into that or not; instead of relying on the command code to check it locally every time
14:46:57 <blarg> byorgey: if i'm executing the command i know what type it is
14:47:05 <nand`> unfortunately I don't know how to best implement this
14:47:41 <dmwit> blarg: Then look it up in the map for that type.
14:47:55 <nand`> keep in mind also handling optional parameters, etc.
14:48:13 <blarg> dmwit: i don't follow
14:48:17 <byorgey> oh, that's an idea, you could have one Map per return type
14:49:18 <byorgey> blarg: if you really want to allow different commands with different return types in the same Map, you will have to create an existential wrapper to hide their types; and yes, you would then probably need something like Typeable.
14:49:27 <byorgey> however, this is rarely the right solution.
14:49:57 <blarg> here's what I might do, eg: createCommand db "bind" ([String]->BindType)
14:50:00 <byorgey> better is to figure out a better way to structure things so that you don't need a heterogeneous map.
14:50:02 <dmwit> (Usually, the right solution is to identify the operations you want to do on the darn thing once you have it, and store those operations instead.)
14:50:29 <dmwit> (Rather than storing an existential type for which all you know how to do is those operations.)
14:50:34 <blarg> then if I'm executing an inputted bind from a user: execCommand ["bind", "a", "+moveup"]
14:50:54 <blarg> but I wouldn't have knowledge of their input
14:51:12 <byorgey> blarg: this is the problem.  what type should execCommand have?
14:51:29 <blarg> it should be generic
14:51:31 <blarg> unknown type
14:51:35 <dmwit> blarg: We're trying to tell you that the answer to your question, as stated so far, is "mu".
14:51:37 <blarg> is Typeable to right way to go?
14:51:46 <EvanR> meh
14:52:03 <nand`> what's the return type of execCommand?  -> IO ()  or similar?
14:52:07 <byorgey> blarg: Typeable is the way to go to do specifically what you are asking.  But it is unlikely to be the right way to go.
14:52:34 <byorgey> blarg: there is no such thing as an "unknown, generic" type in Haskell
14:53:18 <YaZko> Hello, I'm new to Haskell, (so am I to irc, but that's another story) and I had a little question : having a look at the standard libraries, I noticed both a List module and a Data.List module. Is there any particular reason ? Are they equivalent ? Thanks for any help !
14:53:20 <dmwit> blarg: Your question sucks: you're asking "how do I do X", which presumably is a small sub-goal of a large project, and the answer is "you rearrange your project so you don't have to do X". But we can't tell you how to rearrange without a bit more knowledge about the project.
14:53:41 <byorgey> YaZko: yes, List is an old name for Data.List, which is now the standard name
14:53:57 <YaZko> Oh ok, thank you a lot !
14:54:40 <byorgey> YaZko: also, welcome =)
14:54:54 <YaZko> : )
14:55:01 <dmwit> Well, I suppose one answer is to tell you how to do X and let you suffer. Learn for yourself why it's not the right answer.
14:55:05 <dmwit> In that case, you'll want
14:55:10 <dmwit> ?wiki existential quantification
14:55:10 <lambdabot> http://www.haskell.org/haskellwiki/existential_quantification
14:55:32 <dmwit> ?wiki existential type
14:55:33 <lambdabot> http://www.haskell.org/haskellwiki/existential_type
14:55:42 <dmwit> Turns out ?wiki isn't very smart. =P
14:56:16 <blarg> lambdabot is doing something similar to what i want done with ?wiki
14:56:21 <EvanR> 'how do i do X' 'dont do X'
14:56:23 <EvanR> classic
14:56:44 <byorgey> blarg: no it isn't.  All lambdabot's commands produce Strings.
14:56:50 <byorgey> (essentially)
14:57:05 <byorgey> it's probably something more like LambdabotMonad ()
14:57:49 <monochrom> I don't know why "unknown type, will know at run time" is involved. I wrote a command line thingy where commands are bindable at run time, too. the type is known, it's String -> IO (). or String -> IO Bool if you want to know success vs failure.
14:57:54 <dmwit> (Alternately: if you're correct that lambdabot is doing something similar to what you want, then just produce String's or LambdabotMonad ()'s instead of trying to go down the existential quantification path!)
14:58:18 <byorgey> the point is that all lambdabot's commands have to produce a result of the same type.  That type is rich enough to support all the sorts of things that lambdabot plugins can do.
14:58:33 <byorgey> so figure out what sorts of things your commands should be able to do, and make a type that encapsulates them.
14:59:55 * stranac likes haskell so far
15:01:07 <monochrom> Indeed IO() encapsulated all I wanted. all I wanted was outputting something to stdout and sending something to a given socket
15:01:36 <monochrom> and updating a few MVars
15:02:10 <shapr> stranac: Are you doing tryhaskell.org ?
15:03:29 <RylandAlmanza> Why would someone want to use darcs over git? Are there any services for darcs that are as great as github?
15:04:38 <stranac> shapr: just started reading through lyah, but tryhaskell seems pretty interesting
15:05:10 <byorgey> RylandAlmanza: no, there aren't.  But darcs has (IMO) a much cleaner model and a much nicer command-line interface
15:05:53 * hackagebot indents 0.3.3 - indentation sensitive parser-combinators for parsec  http://hackage.haskell.org/package/indents-0.3.3 (SamAnklesaria)
15:05:55 <RylandAlmanza> Perhaps I shall try to make darcshub as my next haskell project then. :)
15:05:59 <monochrom> because some people do not want github but do want what darcs does that git doesn't, such as another story of revision history
15:06:12 <byorgey> RylandAlmanza: that would be fantastic. =)
15:06:24 <byorgey> RylandAlmanza: if you want to do that I suggest contributing to darcsden instead of starting from scratch
15:06:49 <byorgey> http://darcsden.com/
15:07:02 <RylandAlmanza> byorgey: Yeah, mostly a joke. I've only been programming in haskell for a couple days. I'm not ready for that kind of challenge! Thanks, though. :)
15:08:01 <byorgey> RylandAlmanza: well, I think it could be less of a joke than you think.  Contributing small bug fixes or features to an existing project can be a great way to learn.
15:08:10 <adamt> RylandAlmanza: Some people like tools that works like unstable C4, which might just blow your head off, while others prefer a moderately sized gun with an "are you sure?" confirmation box.
15:08:24 <byorgey> though darcsden in particular may not be a great vehicle for that, I don't know how actively anyone is working on it at the moment.
15:09:23 <byorgey> Do you really want to blow your head off? (1/2)  [ynW...], or ? for more options:
15:09:52 <nand`> I'd like to see a diff list
15:10:28 <byorgey> - head
15:10:37 <nand`> y
15:10:49 <aavogt> RylandAlmanza: there's also this http://patchtag.com/
15:12:04 <monochrom> An ironic combination of Siri and Windows: you are hurt, you tell the cell phone "call me an ambulance". cell phone asks: "are you sure you want me to call you an ambulance?" you say yes. cell phone asks for your password. you give it. cell phone commits: "confirmed. from now on, I will call you 'an ambulance'" you die of combination of injury and irony
15:12:31 <nand`> monochrom: nice
15:12:58 <monochrom> I took the "call me an ambulance" from some website collecting Siri jokes
15:14:24 <shergill> monochrom: i missed the 'windows' bit
15:15:00 <monochrom> the windows bit adds time-dilating confirmation dialogs (dialogues?)
15:17:20 <shergill> ah
15:21:47 <dmwit> ?remember nand` <byorgey> Do you really want to blow your head off? (1/2)  [ynW...], or ? for more options: <nand`> I'd like to see a diff list <byorgey> - head <nand`> y
15:21:47 <lambdabot> Good to know.
15:21:59 <dmwit> ?quote
15:21:59 <lambdabot> JonHarrop says: As Haskell has shown, laziness cannot be implemented efficient at all.
15:22:15 <dmwit> Maybe, but who cares about efficient?
15:22:18 <dmwit> ?quote
15:22:19 <lambdabot> GentleIntro says: If k1 and k2 are kinds, then k1->k2 is the kind of types that take a type of kind k1 and return a type of kind k2.
15:22:51 <shachaf> Now that's my kind of type!
15:23:13 <ajg> Hi all. Does a function similar to this exist? Monad m => (a -> m b) -> (b -> c) -> a -> m c
15:23:22 <dmwit> :t liftM
15:23:23 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
15:23:42 <dmwit> :t \f g -> liftM g . f
15:23:43 <lambdabot> forall a1 r (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f (m a1) -> (a1 -> r) -> f (m r)
15:23:50 <dmwit> argh
15:23:56 <dmwit> :t \f g -> liftM g Prelude.. f
15:23:57 <lambdabot> forall a1 r (m :: * -> *) a. (Monad m) => (a -> m a1) -> (a1 -> r) -> a -> m r
15:23:58 <shachaf> Probably not with exactly that type, but you can compose a couple of other functions to do it.
15:24:11 <shachaf> dmwit: What's wrong with the generalized version?!
15:24:25 <shachaf> @ty \f g -> fmap g . g
15:24:26 <lambdabot> forall t a (f :: * -> *). (Functor f) => t -> (a -> f a) -> a -> f (f a)
15:24:38 <shachaf> Er.
15:24:40 <shachaf> @ty \f g -> fmap g . f
15:24:42 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (f a) -> (a -> b) -> f1 (f b)
15:24:49 <dmwit> shachaf: From the question, I conclude that ajg is somewhat of a beginner. The specialized type is more readable for beginners.
15:24:50 <shachaf> @ty \f g -> g .: f
15:24:52 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => f (g a) -> (a -> b) -> f (g b)
15:24:55 <shachaf> @ty flip (.:)
15:24:56 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => f (g a) -> (a -> b) -> f (g b)
15:25:11 <shachaf> Not so useless now, is it?
15:25:22 <nand`> shachaf: that's unexpectedly awesome
15:25:26 <shachaf> ajg: Ignore me -- that only works in lambdabot.
15:25:36 <shachaf> ajg: What dmwit said. liftM/fmap and (.)
15:25:45 <ajg> Ah, I see
15:26:06 <shachaf> (However, I'm not sure whether defining a separate function for this, as opposed to inlining it, is worth it.)
15:26:28 <dmwit> :t \f g -> f >=> return . g
15:26:30 <lambdabot> forall a (m :: * -> *) b a1. (Monad m) => (a -> m b) -> (b -> a1) -> a -> m a1
15:26:31 <nand`> maybe he wants to pass it to a fold or something
15:26:39 <dmwit> also possible
15:26:47 <ajg> For a bit I thought maybe arrows were the answer, but I'm not sure they'd help
15:26:58 <ajg> specifically something like >>^
15:27:05 <dmwit> Arrows are nearly the answer.
15:27:14 <nand`> arrows are always the answer, if not because they can be as expressive as the whole applicative/monad deal
15:27:23 <shachaf> ajg: That looks like a little Befunge program!
15:27:39 <ajg> shachaf: heh
15:27:52 <dmwit> Anyway, (>=>) is a handy function to keep in your arsenal.
15:27:55 <dmwit> :t (>=>)
15:27:56 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
15:28:12 <ajg> yeah, my previous solution was a >=> return . b
15:28:20 <dmwit> right
15:28:50 <ajg> I just wondered if something already existed, I guess
15:29:00 <dmwit> The fact that (>=>) is arrow composition in the Kleisli arrow is why I say arrows are "nearly" the answer -- you have to munge the second argument before they're completely the answer. =)
15:29:12 <ajg> dmwit: gotcha
15:29:41 <ajg> anyway, thanks for the help, guys
15:30:49 <Peaker> I have some TH code (mauke's printf), whose *output code* is generating type warnings despite not yet being called anywhere..
15:33:39 <jfischoff> Peaker: do you mean that you aren't calling printf or are you not using the code printf generates?
15:34:30 <Peaker> funny thing is, if I inject a type-error there, it compiles fine and removes the type warning
15:34:30 <Peaker> it seems like the warning is some sort of heuristic on the [| ... |] code
15:50:41 <Peaker> weird! I'm using TH's newName, generating nested lambdas with differing arg names, and still getting shadow warnings!
15:51:39 <hpaste> Peaker pasted “Weird shadow warnings” at http://hpaste.org/68696
15:52:02 <Peaker> note there's no binding for "a" and ghc complains still!
15:52:12 <Peaker> The Glorious Glasgow Haskell Compilation System, version 7.4.1
15:53:31 <nexion> is it possible to do an 'or' in a 'case' pattern-match for a data constructor?
15:54:12 <Peaker> nexion, Don't think so.. You could re-use the same names/funcs, though
15:55:15 <YoDogIHeardYouLi> Hey Dawgs
15:55:55 <YoDogIHeardYouLi> Whats up in this IRC chodmies?
15:56:10 <nexion> Peaker, thanks
15:56:22 <YoDogIHeardYouLi> K bro
15:56:43 <nexion> lol
16:01:43 <jfischoff> Peaker: Do you still get the error when you replace the printf call with splice?
16:02:11 <Peaker> jfischoff, what do you mean?
16:04:11 <mkscrg> language extension question: is -XImpredicativeTypes a Good One or a Bad One?
16:04:35 <copumpkin> its meaning changes every few releases, so I'd say to stay away
16:04:44 <jfischoff> Peaker: http://hpaste.org/68696 you might have to change somethings slightly to get it to compile
16:04:52 <mkscrg> copumpkin: got it. thanks
16:05:07 <copumpkin> mkscrg: there are examples of good uses of it, but they don't always work
16:08:51 <Peaker> jfischoff, too many unexported names
16:09:24 <jfischoff> Peaker: d'oh
16:16:53 <RylandAlmanza> I have a question about type classes. Let's say I have a type class Square {width :: Int, height :: Int}
16:17:09 <RylandAlmanza> That creates the functions width and height to find the width and height of a square
16:17:13 <RylandAlmanza> right?
16:17:31 <RylandAlmanza> Does that mean I can't have any other typeclasses with parameters of the same name?
16:20:41 <sepp2k> RylandAlmanza: You can't define type classes with record syntax like that.
16:21:12 <donri> RylandAlmanza: are you sure you don't mean algebraic data type / record?
16:21:51 <sepp2k> Well, you can when you add a "where", though you usually don't define type classes with braces.
16:21:58 <RylandAlmanza> ah, I meant algebraic data types actually
16:22:04 <donri> sepp2k: even so, i think it'd be ; not , :)
16:22:21 <sepp2k> Ah, yes, that's right.
16:22:42 <Peaker> RylandAlmanza, record namespacing sucks, yes :)
16:23:00 <sepp2k> RylandAlmanza: To answer your question: Yes, you can only have one record with a given field name per module
16:23:03 <donri> RylandAlmanza: width will really have the type Square -> Int
16:23:06 <donri> etc
16:23:11 <donri> you can inspect the types with :t in ghci
16:23:31 <donri> oh, i missed the actual question :)
16:23:52 <RylandAlmanza> ok, so I'd probably want to have field names be things like "squareWidth" as opposed to just "width"
16:25:11 <donri> sepp2k: you can reuse "width" if either you use modules to namespace the records, or, if it is the same record type only different constructors (e.g. data Shape = Square {width,height} | Rectangle {width,height}) though the latter case can lead to partial functions if not all constructors share that field
16:25:17 <donri> eh, that was meant for RylandAlmanza
16:26:11 <RylandAlmanza> Alright, thanks guys. :)
16:27:18 <donri> you can also go nuts with type classes... instance HasWidth Square where width = squareWidth ... or something
16:29:-178.hsd1.md.comcast.net) joined #haskell
17:18:35 <monochrom> I haven't seen it
17:20:00 <monochrom> I have only seen: compiling (actually, linking) with -threaded will occasionally make deadlocks undeadlock
17:22:58 <ezyang> Which GHC is the next Haskell Platform going to target?
17:23:28 * hpc would guess 7.4.1
17:23:38 <BMeph> ezyang: At the rate I see, I'd quip 7.6... ;þ
17:24:06 <ezyang> Well, it's supposed to hit this month
17:25:18 <monochrom> the next GHC release is merely 7.4.2
17:25:57 <geekosaur> thought they wanted 7.4.2's bug fixes
17:26:25 <hpc> what bugs did they want fixed?
17:26:30 * hpc has yet to hit any of them
17:27:12 <ezyang> *sigh*. I just upgraded to Precise and was hoping to leapfrog to 7.4+ for my system GHC, but looking at the situation, I guess I'll have to wait.
17:27:23 <monochrom> dark matter bugs that fly through you instead of hitting you :)
17:27:52 <hpc> ezyang: you don't need to install the platform to get ghc
17:28:18 <hpc> install 7.4.1 + the darcs version of cabal, and you're set
17:28:52 <monochrom> the hackage version of cabal suffices
17:28:52 <dcoutts_> hpc: it's released now, no need to use darcs version
17:29:04 <hpc> oh, cool
17:29:08 <ezyang> I tend to be conservative with my system stuff :^)
17:29:15 <ezyang> broken xmonad is no fun
17:32:19 <monochrom> http://spl.smugmug.com/Humor/Lambdacats/13227630_eKt46#!i=965006902&k=kWLvY
17:32:37 <monochrom> it used to have a title, "how about a release?"
17:33:30 <byorgey> xmonad works just fine under ghc 7.4.
17:36:07 <monochrom> http://spl.smugmug.com/Humor/Lambdacats/13227630_eKt46#!i=1288212148&k=5KLHJ3V "trapd in Monad tutorl plz help" and a cat burrito!
17:37:16 * Eduard_Munteanu wonders if those were made by geheimdienst
17:38:04 * byorgey made that particular one
17:38:54 <Eduard_Munteanu> Oh, heh.
17:46:33 <nand`> http://spl.smugmug.com/Humor/Lambdacats/13227630_j2MHcg/1#!i=960526421&k=MnNqB <- cute
17:48:50 <monochrom> yeah, I like that one a lot too
17:57:03 <t7> that poor cat in the shower
17:58:56 <t7> http://spl.smugmug.com/Humor/Lambdacats/13227630_j2MHcg/1#!i=960526238&k=yVZwD i think they mean foldl1
17:59:01 <t7> totally ruined the joke
18:00:36 <ezyang> wait, I suck. Precise is on 7.4.1
18:14:28 <mikeplus64> if i have a Lit (from template haskell) that was made via doublePrimL, how can I make it Double and not Double#?
18:15:17 <tommd> GHC.Types.D#
18:15:19 <mikeplus64> oh, rationalL, herp
18:16:06 <mikeplus64> tommd: will keep that in mind
18:16:17 <monochrom> hey, GHC.Internal.F# would be a cool name :)
18:17:56 <tommd> We must settle for GHC.Exts.F#
18:32:15 <JoeyA> If unsafeFreeze (from the array package) is used in lazy ST, will using the returned array force all of the deferred ST computation prior to it (in particular, accesses to the array) ?
18:34:37 <JoeyA> I'm just wondering if it's possible to have a situation where runSTArray, in conjunction with lazyToStrictST, could return an incomplete array due to the ST computations intended to fill it never happening.
18:43:42 <Eduard_Munteanu> JoeyA: how do you mean "incomplete"?
18:43:59 <JoeyA> Suppose the array starts uninitialized (e.g. it was created with newArray_)
18:45:06 <JoeyA> Then we have forM_ [0..n] $ \i -> writeArray arr i $ "Item #" ++ show i
18:46:19 <JoeyA> I'm wondering if, in a lazy state monad, the forM_ is forced by the use of unsafeFreeze's return value.
18:47:23 <Eduard_Munteanu> JoeyA: I don't think it needs to force anything
18:48:19 <JoeyA> Well, if code later on accesses the frozen array's items, the forM_ ... computation would need to happen at some point.  Otherwise, the items will be incorrect.
18:48:36 <Eduard_Munteanu> Yeah, at some point, but not all at once.
18:49:54 <Eduard_Munteanu> JoeyA: actually, no, it might not happen at all.
18:49:59 <Eduard_Munteanu> E.g. if you don't use that value.
18:51:09 <JoeyA> Well, the array items are written with writeArray computations.  I don't think GHC is smart enough to defer computations up to the last write to that index.  That would require solving the halting problem.
18:52:40 <copumpkin> depends what you mean
18:52:47 <copumpkin> what is it writing to the array slots?
18:52:55 <copumpkin> that depends on whether it's an unboxed array or not
18:53:01 <Eduard_Munteanu> Consider some   forM_ [0..n] $ \i -> writeArray arr (f i)
18:53:12 <copumpkin> if it is boxed, it's writing deferred computations to each array slot
18:53:30 <Eduard_Munteanu> You don't need to compute f 1 if you only access the zeroth value.
18:53:47 <copumpkin> people invoke the halting problem way too easily in CS
18:54:06 <Eduard_Munteanu> Yeah, he might be looking at it from the wrong "end".
18:54:58 <Eduard_Munteanu> That gets you an array of thunks (the deferred computations), it's not that GHC does anything smart about it.
18:55:42 <JoeyA> Well, it doesn't put a thunk there until writeArray actually happens.
18:56:06 <JoeyA> The only thing there is an error value (assuming a boxed array).
18:56:50 <Eduard_Munteanu> JoeyA: which is another deferred computation and so on
18:57:52 <ezyang> What is the classic way of version testing from Cabal, and then setting preprocessor macros accordingly?
18:58:31 <JoeyA> ezyang: testing versions of other packages?  e.g. #if MIN_VERSION_stm(2,4,0)
18:58:47 <ezyang> coool.
18:59:34 <JoeyA> Here's where I did that: https://github.com/joeyadams/haskell-chat-server-example/blob/master/Main.hs
18:59:50 <Eduard_Munteanu> Btw, I mean writeArray is another deferred computation.
19:00:16 <JoeyA> Note that MIN_VERSION_pkg macros don't work outside of Cabal.
19:00:20 <ezyang> huh, CoqTop.hs:34:0:  error: missing binary operator before token "("
19:00:27 <ezyang> oh, rite
19:01:37 <illissius> ezyang: also as we just discovered today you need additional parentheses if you want to work around a bug with older versions of cabal. https://github.com/ekmett/semigroupoids/commit/c6160c5e9cbc3a64b734982ece23b52fd7678f86
19:02:16 * ezyang sighs 
19:06:58 <applicative> illissius: you figured out the semigroupoids business evidently
19:07:51 <illissius> applicative: right. my cabal was old and had a bug
19:08:33 <illissius> or rather, my cabal-install was really old and uses the cabal it was compiled with by default, instead of the much newer one that comes with ghc, but you can change that with a flag.
19:09:11 <illissius> mostly wasn't me doing the figuring out, but that was the result
19:10:21 <applicative> i see
19:11:56 <applicative> hey it was after all my  data-kinds variant of rampion's red-black trees that simon p j added to the testsuite.  https://github.com/ghc/testsuite/blob/master/tests/polykinds/RedBlack.hs
19:13:12 <applicative> i thought it wasn't after thinking it was, now i'm beaming  groundlessly again
19:13:43 <illissius> applicative: did ghc have some kind of problem with it?
19:15:02 <applicative> this, no its just an additional test, completely beside any point.  I guess the existing tests werent so complicated.
19:15:55 <applicative> i was just pleased that my kind signatures were cut-and-pasted by simon p j , hah
19:16:41 <applicative> never mind rampions brilliance
19:17:32 <illissius> makes one feel special to have conversed on IRC with someone whose kind signatures were cut-and-pasted by spj
19:18:13 <applicative> :)
19:18:16 <Eduard_Munteanu> Yeah, you should definitely make up the "SPJ number".
19:18:27 <applicative> I'm up to 1
19:19:48 <applicative> he made some very teacherly remarks about gadts &c on rampions gist, it was nice. https://gist.github.com/2659812
19:20:39 <applicative> very tutorialish : "I think you believe that cY must be Black. But why?"
19:21:42 <mikeplus64> is there a function to evaluate Exps from Language.haskell.Exts ?
19:24:18 <nanothief> Is there an Isomorphism class somewhere on hackage, that could be used to convert type like (a -> a) to  (b -> b) given (a->b) and (b -> a)?
19:25:29 <applicative> if there were a class, wouldn't there be too many candidate isomorphisms?
19:26:23 <applicative> sometimes there;s  data Iso a b = Iso (a->b) (b->a)
19:26:27 <sipa> @djinn (a -> b) -> (b -> a) -> (a -> a) -> (b -> b)
19:26:27 <lambdabot> f a b _ c = a (b c)
19:26:58 <applicative> still more reason to be suspicious
19:27:16 <nanothief> I saw the Iso type. I was more looking for a Functor like class, but for types that need both the from and to conversions to convert their type
19:28:07 <nanothief> @djinn (a -> b) -> (b -> a) -> (Maybe a -> a) -> (Maybe b -> b)
19:28:07 <lambdabot> f a _ b c =
19:28:07 <lambdabot>     case c of
19:28:08 <lambdabot>     Nothing -> a (b Nothing)
19:28:08 <lambdabot>     Just d -> d
19:29:13 <applicative> sometimes theres e.g. class NaturalTransformation f g = NT (forall a . f a -> g a)  then there could be the other way round too.
19:29:40 <illissius> :t f to from go = to . go . from
19:29:41 <lambdabot> parse error on input `='
19:29:41 <Eduard_Munteanu> Mm... Functor f => (f a -> f b) -> a -> b?
19:30:03 <illissius> :t \to from go -> to . go . from
19:30:04 <Eduard_Munteanu> Well s/Functor/SomeReasonableThing/
19:30:04 <lambdabot> forall a b a1 (f :: * -> *). (Functor f) => (a -> b) -> f a1 -> (a1 -> a) -> f b
19:31:00 <applicative> hm
19:32:01 <nanothief> Eduard_Munteanu: Functor is close, as is Cofunctor. But some types need both the to and from conversions to be able to map over their type
19:32:40 <applicative> mikeplus64 isn't the  answer no?  Does Haskell.Src... e.g. know the meaning of imported functions?
19:32:58 <nanothief> @djinn (a -> b) -> (b -> a) -> (Int -> a, a -> Int) -> (Int -> b, b -> Int)
19:32:59 <lambdabot> Error: Undefined type Int
19:33:10 * Eduard_Munteanu isn't sure what a Cofunctor is, CT-wise... presumably a normal functor, just *to* Hask :)
19:33:39 <mikeplus64> applicative: i "found" Language.Haskell.Interpreter, but that doesnt evaluate Exps
19:33:39 <nanothief> it is very similar to cofucntor, except cofmap :: (b -> a) -> f a -> f b
19:34:03 <Eduard_Munteanu> nanothief: mm, that's just a contravariant functor, though
19:35:03 <nanothief> thats right
19:35:08 <illissius> (from the 'contravariant' package)
19:36:05 <nanothief> @djinn (a -> b) -> (b -> a) -> (c -> a, a -> c) -> (c -> b, b -> c)
19:36:06 <lambdabot> f a b (c, d) = (\ e -> a (c e), \ f -> d (b f))
19:36:15 <applicative> mikeplus64: oh yeah, it was the example in the example folder for hint that was making me doubt what i was saying.  what is it doing?
19:37:47 <nanothief> There we go, you can't make the type (c -> a, a -> c) an instance of either Functor or Cofunctor, but you could have a class that took both the to and from conversions to map over the type
19:38:15 <nanothief> .. I might just make my own, I just prefer to use an existing class if one already exists
19:50:09 <dmwit> nanothief: Yes, there's such a thing on Hackage, don't reinvent it.
19:50:12 <dmwit> moment
19:51:14 <dmwit> http://hackage.haskell.org/packages/archive/groupoids/0.2.1.2/doc/html/Data-Isomorphism.html
19:51:20 <hpaste> applicative pasted “hint example” at http://hpaste.org/68701
19:52:13 <dmwit> foo :: Iso (->) a b -> (a -> a) -> (b -> b); foo iso f = embed iso . f . project iso
19:52:43 <applicative> mikeplus64: ^^^ if I stick a request for user input in the example from  hint, it evaluates e.g. foldr (+) 0 [1..3] if I type that.  I wonder what its doing
19:53:00 <mikeplus64> applicative: i found it
19:53:06 <dmwit> foo :: Category k => Iso k a b -> k a a -> k b b; foo iso f = embed iso . f . project iso -- even better
19:53:11 <mikeplus64> Language.Haskell.Meta has parseExp
19:53:22 <mikeplus64> which will produce a Exp from Language.Haskell.TH :)
19:54:04 <mikeplus64> so it just looks like let Right e = parseExp str in appE [| toString |] (return e)
19:56:34 <applicative> Language.Haskell.Meta  by matt morrow the why-the-lucky-stiff of hackage
19:56:44 <dmwit> It's probably possible to write a function foo :: Iso (->) a b -> f a -> f b, but not in Haskell. =P
19:57:15 <jtobin> @undo do m <- Control.Concurrent.newEmptyMVar ; Control.Concurrent.forkIO $ do r <- (print 2) ; Control.Concurrent.putMVar m r ; return m
19:57:15 <lambdabot> Control.Concurrent.newEmptyMVar >>= \ m -> Control.Concurrent.forkIO $ (print 2) >>= \ r -> Control.Concurrent.putMVar m r >> return m
19:57:46 <jtobin> @typ Control.Concurrent.newEmptyMVar >>= \m -> Control.Concurrent.forkIO $ (print 2) >>= \r -> Control.Concurrent.putMVar m r >> return m
19:57:47 <lambdabot>     Couldn't match expected type `()'
19:57:47 <lambdabot>            against inferred type `GHC.MVar.MVar ()'
19:57:47 <lambdabot>     In the first argument of `return', namely `m'
19:57:53 <jtobin> ?!
19:57:53 <lambdabot> Maybe you meant: . ? @ v
19:59:04 <dmwit> oooo
19:59:30 <nanothief> dmwit: I just felt that method was a bit redundant, as to create a transormation, you have to know about the type being transformed. With Functor, you write the code to do the transormation once, then you just need to pass in the (a -> b) function. With this approach though, you need to use the base type f every time with the transoform functions
19:59:51 <nanothief> (unless I'm not understanding it correctly)
20:00:15 <dmwit> I'm not sure I understood that complaint.
20:00:54 <dmwit> :t under
20:00:55 <lambdabot> forall o n n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> (n -> n') -> o -> o'
20:02:06 <nanothief> lets say I am given a type F a, and I want to change it to F b. With Functor, this is simple, just pass in a (a -> b) function. I don't have to know anything about F to do this. Correct me if I'm wrong, but using the Iso method, I do need to know about the internals of F in order to transform F a into F b
20:02:51 <dmwit> Correct.
20:03:00 <dmwit> But you only asked for F = (->), so that's only one transformation.
20:03:14 <nanothief> I was going to write a class DualFunctor f where dualFmap :: (a -> b) -> (b -> a) -> f a -> f b. Then you can again transform f without knowing the internals
20:03:38 <nanothief> ahh sorry, that was just an example type, I should have made that more clear
20:04:10 <dmwit> Sure, that's a reasonable class.
20:04:22 <dmwit> Now let's see if that one is on Hackage...
20:04:54 <nanothief> <- the "see if that one is on hackage" is where my search kung-fu failed me :(
20:06:03 <Eduard_Munteanu> I wonder if there's a generalized (arbitrary categories) functor somewhere.
20:06:39 <dmwit> Eduard_Munteanu: yes =)
20:07:03 <Eduard_Munteanu> Well, I wrote one myself, but I do wonder if edwardk has something like that already :)
20:08:12 <dmwit> nanothief: http://hackage.haskell.org/packages/archive/bifunctors/0.1.3.3/doc/html/Data-Bifunctor.html looks similar, but not identical
20:08:25 <dmwit> (the difference being that your proposed typeclass provides the same argument in both "slots")
20:08:55 <dmwit> Oh, no.
20:09:06 <dmwit> no, no
20:09:20 <nanothief> that looks like the arrow funcs
20:09:26 <Eduard_Munteanu> Basically   class (Category c, Category d) => GFunctor c d f | f -> c d
20:10:11 <Eduard_Munteanu> providing     gfmap :: c a b -> d (f a) (f b)
20:10:20 <dmwit> Eduard_Munteanu: http://hackage.haskell.org/packages/archive/categories/1.0.3/doc/html/Control-Categorical-Functor.html
20:10:52 <Eduard_Munteanu> Oh, neat.
20:11:17 <Eduard_Munteanu> I wonder about his fundeps.
20:11:44 <Eduard_Munteanu> That seems a bit restrictive.
20:11:48 <Veinor> blah
20:11:53 <Veinor> i hope cabal gets that parallel building feature soon
20:12:24 <dmwit> Eduard_Munteanu: His fundeps are more relaxed than your proposed one...
20:13:18 <dmwit> His say once you've chosen a functor f, r and t determine each other; yours say that once you've chosen a functor f, r and t are already determined.
20:13:33 <Eduard_Munteanu> dmwit: oh? I'm reading mine as "a given functor defines its own source and target categories", while his seem to do more
20:14:09 <Eduard_Munteanu> Ah, right, now I see it.
20:14:34 <mm_freak> absence: selection has to happen immediately
20:14:51 <dmwit> nanothief: newtype also looks pretty close to what you want
20:14:59 <dmwit> ?hackage newtype
20:14:59 <lambdabot> http://hackage.haskell.org/package/newtype
20:15:33 <dmwit> I don't think exactly what you propose is on Hackage, though.
20:16:59 <shergill> how do you control the verbosity of ghci? eg. when you type :browse ghci at times shortens declarations with ellipses. how do you increase that limit?
20:19:29 <dmwit> shergill: Dunno! Have you looked in the Fine Manual?
20:20:07 <shergill> dmwit: i am browsing it atm. was hoping someone here remembered how to do it and might save me the time
20:20:25 <nanothief> dmwit: I think I could use the newtype funcs to do what I want, but I think it would end up simpler to use a new class instead
20:22:07 <dmwit> :t foldMap
20:22:08 <lambdabot> Not in scope: `foldMap'
20:22:13 <dmwit> :t T.foldMap
20:22:14 <lambdabot> Couldn't find qualified module.
20:22:21 <dmwit> pfft, whatever
20:36:07 * hackagebot shelly 0.9.2 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.9.2 (GregWeber)
20:51:00 <mikeplus64> how would one define an instance for Lift (from TH) Text?
20:51:45 <mikeplus64> oh, neat, there is deriveLift
20:55:40 <tgeeky> @quote byorgey CReal
20:55:40 <lambdabot> byorgey says: I got this great pair of toy glasses in my breakfast CReal that make you CDouble.
20:55:52 <monochrom> hahaha
20:55:53 <mikeplus64> now the question becomes whether or not you can define a Lift instance for unboxed valuse
20:56:09 <mikeplus64> (ie ByteArray#)
20:56:14 <nonty> Anyone care to help a newbie understand the reasons for some compiler warnings that I've been getting when compiling a 2003 program under GHC 7.4.1?
20:56:35 <shachaf> nonty: I don't think anyone will help you if you don't @paste the program.
20:56:41 <shachaf> Or at the very least the errors.
20:56:46 <shachaf> People in here are mean like that. :-(
21:00:20 <nonty> shachaf: I'm a newbie in IRC too.  I can direct you to a web site that has the original: http://cgi.cs.indiana.edu/~sabry/cnf0.hs  I have made some mods to the imports.
21:00:59 <shachaf> nonty: You probably need to go over each warning, understand what it says, and fix it.
21:02:45 <nonty> shachaf: For this, import Control.Monad Data.List GHC.IO & System.Environment and add a bunch of options to the compiler (it tells you which ones) and it compiles.
21:04:21 <nonty> schachaf: Unfortunately, my bauckground is in C++, and I can't really und erstand whether the compiler is nitpicking, or the program is really faulty.
21:04:48 <shachaf> nonty: Things have changed since 2003 -- mostly for the better.
21:04:57 <tgeeky> nonty: Haskell compilers do not pick nits.
21:05:05 <shachaf> tgeeky: Sure they do.
21:05:31 <shachaf> nonty: Asking people to download and compile a file and look at the warnings (after making a few changes) isn't likely to produce very good results in IRC. :-)
21:05:41 <shachaf> Just because it's a hassle.
21:05:43 <tgeeky> my glorious compiler does not. It's right, and I'm wrong!
21:05:58 <monochrom> in IRC or in person or in anywhere
21:06:03 <shachaf> Yep.
21:06:18 <shachaf> You're better off @pasting specific warnings and asking about them, if you're sure that you can't figure them out.
21:06:29 <shachaf> Often reading the warning is enough to figure out what you should do, though. :-)
21:06:32 <shachaf> @paste
21:06:33 <lambdabot> Haskell pastebin: http://hpaste.org/
21:07:53 <nonty> It's a 700 line file, so I'll fire up the compiler a few more times and gather some snippets.  Stay tuned, please.
21:07:53 <monochrom> actually I do not so much mind compiling a file myself. I am a scientist, I want to reproduce results, too
21:09:04 <monochrom> my biggest grief is things like "this file except change X to Y and by the way there is an obvious typo with an obvious fix"
21:10:17 <shachaf> obviypo
21:19:07 <hpaste> “nonty, Purdom, Sabry” pasted “nonty” at http://hpaste.org/68702
21:21:31 <nonty> shachaf: Is that the sort of pasting you had in mind?  I've got 2 instances of the same sort of error message at the "f" to the left of the
21:21:56 <shachaf> nonty: Did you try -XScopedTypeVariables?
21:22:08 <shachaf> That's what it's suggesting to you in the error message.
21:22:29 <tgeeky> shachaf: see! that's not nitpicking. That's the polar opposite. Suggestion-making!
21:23:22 <shachaf> It's very helpful!
21:24:00 <nonty> Yes, and it suppresses the message from the compiler.  Maybe this is harmless, but I'd still like to know why the compiler complains. In C++ I program to avoid such warnings.
21:25:22 <monochrom> either -XScopedTypeVariables on the compiler command, or {-# LANGUAGE ScopedTypeVariables #-} at the beginning of the file. similarly for other -X things
21:25:39 <tgeeky> nonty: It's not a warning.
21:25:46 <tgeeky> "Scoped Type Variables are an extension to Haskell's type system  ..."
21:25:49 <geekosaur> it complains because standard Haskell doesn't allow you to specify a type in a pattern like that.  you need the extension, or to do it in some other way (guards or sometimes using asTypeOf)
21:25:52 <tgeeky> nonty: you are turning an extention on
21:25:55 <aavogt> you could put the type signature somewhere else if it's for documentation purposes
21:25:59 <nonty> tgeeky: It's all fun until you accidentally suppress a warning that you're doing something seriously wrong... and pay the price.
21:26:13 <tgeeky> nonty: it's not a warning!
21:27:07 <tgeeky> nonty: warnings typically have the word "warning" in them. This is something you can do when you enable an extension to the language (ScopedTypeVariables) and otherwise it's invalid Haskell.
21:27:47 <rwbarton> did something happen to PatternSignatures?
21:27:51 <nonty> Well, in at least one of the other suggestions it makes, it uses the term "Illegal".  Does that sound more serious?
21:28:01 <tgeeky> nonty: it is illegal!
21:29:08 <tgeeky> this one says illegal too. There is a language specification, and the ability to use scoped type variables wasn't part of it. Someone thought of it, after the fact, and they require that you turn the extension on to use this feature.
21:29:53 <nonty> Yeah, maybe that's the one.. <sheepishly> in any case, I'll get back to determining what it is I have to do to get it to compile.
21:30:00 <tgeeky> nonty: that is, this is technically an error. It should (and evidently is) refusing to compile.
21:30:20 <tgeeky> nonty: insert this: {-# LANGUAGE ScopedTypeVariables #-} at the top of the file
21:30:32 <monochrom> which is what I said
21:30:41 <tgeeky> which is what that monochrom guy said
21:30:56 <tgeeky> nonty: that will tell the compiler that you mean business, and you can move on to other warnings or errors
21:31:21 <tgeeky> does C++ not have language extensions?
21:31:34 * monochrom does not understand why this is made so complicated, complete with debates on the semantics of "warnings" (they aren't even "warnings") and the peril of c++ programming
21:31:36 <tgeeky> or do you just get them all by default
21:32:48 <tgeeky> monochrom: I certainly don't intend to! I view it as the existence of this awesome thing (haskell) which was at some point in the past made awesomer (by scoped type variables), but in order to distinguish levels of awesomeness, one has to pay the proce of telling GHC just how awesome you want it to be.
21:33:16 <nonty> "ghc -XScopedTypeVariables -XMultiParamTypeClasses -XFunctionalDependencies -XFlexibleInstances -rtsopts cnf1.hs"  is what I have to use. Are these all language extensions?
21:33:43 <tgeeky> yes. You don't need to (and shouldn't) specify them on the command line.
21:34:27 <monochrom> you have an old file, you would use old options or old compiler directives to compile it by an old compiler. now you have a new compiler, you need new options or new compiler directives. I have served exactly an instance of what the new option or the new directive looks like. does it need to be more complicated than merely "syntax of options have changed"?
21:34:42 <tgeeky> specify them, without the -X, with the {-# LANGUAGE ScopedTypeVariables, MultiParamTypeClasses, FunctionalDependencies, FlexibleInstances #-} pragma (that's what {-# ... #-} is called -- pragma) at the top of the file in question
21:34:49 <tgeeky> so you don't have to type them in at the command line
21:35:08 <monochrom> and yes I assure you the old compiler would abort too unless you give an old option "-fglasgow-exts"
21:35:12 <nonty> tgeeky: Thankyou very much.  I'll try specifying them in the file as suggested.
21:40:14 <Veinor> where do i go to file ghc bugs?
21:40:40 <tgeeky> Veinor: http://hackage.haskell.org/trac/ghc/
21:40:49 <tgeeky> Veinor: use guest / guest if you're squeamish
21:44:44 <Veinor> reported, thanks :)
21:47:02 <JoeyA> To quote my favorite comment on StackExchange: I think the terms "file" and "against" are inappropriate. You *report* bugs *to*... - Bugs are not lawsuits.
21:47:05 <JoeyA> http://programmers.stackexchange.com/q/79936/3650
21:47:53 <robinhoode> What is the most efficient way to count the # of lines in a large file (say < 100mb)?
21:48:14 <robinhoode> length $ lines content seems to crash with an out of memory error.
21:49:20 <JoeyA> Are you doing it though GHCi?  It'll probably be faster (though not screaming fast) if you compile with optimization (e.g. ghc -O2).
21:49:57 <monochrom> length $ filter ('\n' ==) content
21:51:00 <JoeyA> monochrom: That'll return 2 for a file with 3 lines without a trailing newline.
21:51:15 <monochrom> right
21:52:06 <JoeyA> I wrote a line counting function in my recursive-line-count package: https://github.com/joeyadams/haskell-recursive-line-count/blob/master/CountLines.hs#L70
21:52:11 <robinhoode> monochrom: Nah, that also bailed on me with.. not enough memory..
21:52:28 <monochrom> then you do something else wrong
21:52:32 <robinhoode> So is there some implicit understanding about how haskell handles the memory between these two functions?
21:52:55 <nonty> monochrom: tgeeky: schachaf: I've put those language extension specs at the top of the file and it produces sensible-looking output.
21:53:23 <nonty> I'm still not sure I'm still not sure why it should want over 6.7GB of memory for a large input, though.why it should want over 6.7GB of memory for a large input, though.
21:53:59 <JoeyA> main = interact $ show . length . lines
21:54:04 <JoeyA> Works for me, when compiled with ghc -O2
21:54:13 <JoeyA> (GHC 7.4.1)
21:54:30 <mm_freak> is there a language above assembly that promises very fast (better than C) yet portable code?  for example is fortran such a language?
21:54:33 <nonty> I'm using RTS options to give it 512MB of stack and limit  it to  5GB of heap.
21:54:34 <JoeyA> yes | ./count-lines stays at around 3.5MB memory usage.
21:54:35 <monochrom> see my http://www.vex.net/~trebla/haskell/lazy.xhtml especially "case study: average" to see how to spend a lot of memory because you do a bit more than what you say
21:54:39 <rwbarton> what is "content"
21:55:01 <rwbarton> I mean, where did it come from exactly
21:57:44 <rwbarton> "length $ lines content" should use some largish constant times the length of the longest line for memory provided content came from lazy IO like readFile
21:57:53 <monochrom> and in fact followed by "case study: co-routines" for how if you don't do a bit more, suddenly memory consumption drops to zilch
21:58:31 <rwbarton> and also provided you don't use content elsewhere
22:08:20 <nexion> what do you guys recommend for resolving hostnames into Network.Socket.Internal's HostAddress? I was considering using the network-dns package, but it says it's obsolete
22:08:57 <monochrom> I have always used Network.BSD
22:11:17 <nexion> that'd work
22:11:55 <nexion> I'm still wondering why network-dns is considered obsolete.. it seems to have a great interface
22:29:48 <Gunni> can anyone tell me why 312 `div` 198 gives me 1 and not 2,260869565...
22:30:01 <shachaf> Gunni: Because div is integer division.
22:30:01 <Gunni> warning very new at haskell
22:30:06 <charliesome> Gunni: `div` is integer division
22:30:26 <charliesome> Gunni: use 312.0 / 198.0 for floating division
22:30:26 <Gunni> oh, how do i get decimal division'
22:30:28 <Gunni> k
22:30:29 <shachaf> Gunni: One of the first steps to getting less new at Haskell is to learn how to look this sort of thing up. :-)
22:30:37 <Gunni> yeah i tried
22:30:41 <shachaf> Hoogle is a good tool to find documentation:
22:30:44 <shachaf> @where hoogle
22:30:44 <lambdabot> http://haskell.org/hoogle
22:31:05 <charliesome> shachaf: we've all been bitten by integer division when we were new
22:31:08 <shachaf> Type "div" there, click on it, read description. :-)
22:31:10 * hackagebot QuasiText 0.1.2.0 - A QuasiQuoter for Text.  http://hackage.haskell.org/package/QuasiText-0.1.2.0 (MikeLedger)
22:31:13 <Gunni> yeah but in my eyes div :: a -> a -> a tells me very little
22:31:17 <mikeplus64> :)
22:31:23 <shachaf> charliesome: Did I say otherwise?
22:31:30 <Gunni> i know it takes in two things and returns one
22:31:41 <shachaf> Gunni: That's why you should do what I said. :-)
22:31:51 <shachaf> "integer division truncated toward negative infinity"
22:31:52 <charliesome> Gunni: it takes in two integers and returns an integer
22:32:13 <Gunni> i didn't think division was ever done without decimals
22:32:19 <Gunni> my mistake
22:32:29 <shachaf> Also, Haskell doesn't have decimal division.
22:32:39 <shachaf> It has floating point division, which is a very different thing.
22:33:02 <Gunni> oh just wording fail on my part
22:33:09 <ladr0n> shachaf: what's the difference?
22:33:19 <Veinor> > (1.0 / 3.0 + 1.0 / 3.0 + 1.0 / 3.0) == (1.0 :: Double)
22:33:20 <lambdabot>   True
22:33:22 <ladr0n> shachaf: or are you just referring to the idiosyncracies of floating point numbers?
22:33:22 <Veinor> huh
22:33:26 <Veinor> i thought that didn't work
22:33:47 <shachaf> ladr0n: I am. Also "decimal" implies things like "base 10".
22:33:58 <ladr0n> shachaf: righto
22:34:17 <shachaf> > 0.1 + 0.2 == 0.3 -- Veinor: Something like this?
22:34:18 <lambdabot>   False
22:34:25 <Veinor> yeah, like that
22:34:29 <Gunni> oh in my mind decimal implied a comma in the number ;D
22:34:43 <shachaf> There are no commas in floating-point numbers.
22:34:52 <shachaf> (Not even in Europe.)
22:34:58 <Gunni> comma, period whatever it is
22:35:02 <Gunni> 123,123
22:35:13 <shachaf> No, there aren't periods either. :-)
22:35:26 <Gunni> then what is 123.123 ?
22:35:47 <Gunni> one hundred twenty three point one hundred twenty three
22:35:47 <shachaf> I'm nitpicking but understand floating point idiosyncrasies is important if you're going to be using them. :-)
22:35:48 <Gunni> right?
22:36:14 <shachaf> Gunni: I have no idea what it is. A rational number? A real number? A sequence of UTF-8 characters?
22:36:41 <Veinor> http://en.wikipedia.org/wiki/Double-precision_floating-point_format
22:36:44 <ladr0n> Prelude> :type 123.123
22:36:45 <ladr0n> 123.123 :: Fractional a => a
22:36:53 <ladr0n> well there's your answer :P
22:37:13 <newsham> you shouldnt use equality on reals anyway ;-)
22:37:14 <shachaf> ladr0n: Not really...
22:37:32 <Veinor> basically, 123.123, when treated as a Double, gets represented internally as (1 + b) * 2^e, where b is between 0 and 1 and e is an integer
22:38:49 <Gunni> well it's 5 in the morning right now, i'm just giving up for now and going to sleep
22:38:53 <Gunni> thanks for all the help though
22:42:01 <newsham> whats the haskell func for converting float to pair of integers w/ mantissa and exponent?
22:42:10 <monochrom> "what is ___ ?" is better left to philosophers.
22:42:40 <monochrom> @hoogle decode
22:42:40 <lambdabot> Prelude decodeFloat :: RealFloat a => a -> (Integer, Int)
22:42:40 <lambdabot> Data.Text.Encoding decodeASCII :: ByteString -> Text
22:42:40 <lambdabot> Data.Text.Lazy.Encoding decodeASCII :: ByteString -> Text
22:42:44 <monochrom> decodeFloat
22:43:29 <monochrom> and I don't mean newsham's fine question! I mean the ilk of "what is monad?" "what is 123?"
22:44:00 <shachaf> monochrom: Best left to philosophers and people like conal!
22:44:11 <newsham> > decodeFloat 123.123
22:44:12 <lambdabot>   (8664010889386525,-46)
22:44:28 <shachaf> That's not what 123.123 *is*.
22:44:30 <newsham> > 8664010889386525 * 2**(-46)
22:44:31 <lambdabot>   123.123
22:44:38 <shachaf> 123.123 is obviously a Dedekind cut.
22:45:19 <newsham> ?src Dedekind
22:45:20 <lambdabot> Source not found. Maybe you made a typo?
22:45:20 <RylandAlmanza> Anyone here do any haskell game development? I'm trying to decide what to use to render graphics. Looks like my options are sdl, opengl, or fungen
22:45:21 <newsham> nope.
22:46:20 <shachaf> newsham: OK, 123.123 is a tuple (True,123123,1000)
22:46:55 <newsham> nope.
22:47:07 <newsham> you forgot to normalize
22:47:21 <shachaf> I did?
22:50:13 <ladr0n> RylandAlmanza: I haven't done it myself, but it seems like sdl would be your best bet
22:50:20 <newsham> yup, the haskell floats are normalized into a unique representation
22:50:24 <newsham> and its not that tuple
22:50:39 <ladr0n> takes a brave person to do game development in haskell, though
22:51:09 <shergill> is there anything other than sourcegraph, that can be used to analyze the module imports of a haskell project?
22:51:26 <RylandAlmanza> Alright, thanks ladr0n. :)
22:53:34 <newsham> there's a games page on the haskell wiki that lists some games, some papers about games, some of which are advanced
22:53:51 <newsham> http://www.haskell.org/haskellwiki/Game_Development
22:57:45 <mikeplus64> RylandAlmanza: i made this game http://quasimal.com/projects/level_0.html
22:58:10 <mikeplus64> uses SDL, which is very easy for just 2D
22:58:49 <mikeplus64> and should be much nicer to use with 3D than GLUT (ew, callbacks!)
22:59:42 <mikeplus64> but, a word of warning: haskell's SDL doesn't work on Windows
22:59:49 <mikeplus64> not withough significant monkey business
23:02:14 <RylandAlmanza> Thanks mikeplus64 and newsham
23:02:59 <augur> so im having a philosophical quandry with probabilistic learning
23:03:58 <augur> in most (all?) probabilistic learning mechanisms, if you train it on the sequence of 1 million 0's
23:04:25 <augur> it will inevitably say 0 with almost complete certainty
23:04:51 <augur> lets say the sequences are at most 2 million digits long
23:05:26 <augur> it's not the case, tho, that the certainty that it gives that 0 is next is reflective of the probability of 0 being next tho
23:05:38 <shergill> augur: "it will inevitably say 0 with almost complete certainty" <--- wrong
23:05:41 <augur> i mean, the probability is 50% of course
23:05:49 <augur> shergill: well, it depends on the learning algo, of course
23:05:58 <shergill> no, it depends on the parameters
23:06:18 <shergill> specifically, it depends on the relative importance you want to give your prior belief
23:06:27 <newsham> if there's a one in a million chance that the next digit is 1, then wouldnt it be right in being "almsot completely certain"?
23:06:43 <shergill> in your case your prior belief is that heads is as likely as tails
23:06:49 <augur> newsham: except that depends entirely on the sequences that are possible
23:07:08 <augur> newsham: if all binary sequences of 2m digits are possible, then the probability isnt 1 in a million
23:07:35 <augur> if there's only two sequences possible, all 0s and all 1s, then the probability that it's 0 is 100%, etc.
23:07:43 <augur> shergill: right, but thats where my philosophical quandry comes in
23:08:17 <shergill> augur: i have to dash, but i'll reply when i come back
23:08:45 <shergill> but do elaborate on your quandary
23:08:59 <augur> well so like
23:09:36 <augur> unless your possibility space has inherently excludes certain sequences, there will always be some probability that any given sequence will show up
23:10:53 <augur> so your probability widget should never have any predictive power in a single run, because you could always be in the very rare case
23:12:21 <ziman> this is where laplace smoothing comes in
23:12:24 <augur> it could of course give probabilities for each possible next outcome, but then it should be useless because you still have to decide which to expect
23:12:38 <augur> ziman: it has nothing to do with smoothing
23:13:31 <augur> if you choose to behave according to the most likely outcome, then on a single trial, if it hits the all 0's case, it should fail completely
23:14:12 <augur> in fact, it should fail essentially always, because most of the time it will make _some_ wrong prediction
23:15:18 <RylandAlmanza> Anyone know how hard it is to make a binding in haskell? All the game-related libraries seem a little outdated. I do have previous experience making language bindings.
23:16:50 <augur> if you train it on a finite sample of even distribution over the binary numbers, it'll have some bias, so it'll be wrong most of the time
23:17:25 <augur> the larger the subset the less wrong it'll get, but at the limit it becomes impossible to decide what to expect
23:17:43 <c_wraith> RylandAlmanza: It's not hard, really.  The hardest part is creating an API that feels natural in haskell.  (And the fact that if you get types in the FFI wrong, it will just mysteriously segfault... sometimes.)
23:18:20 <RylandAlmanza> c_wraith: Any articles or other resources to get me started?
23:22:10 <mikeplus64> what's the darcs equivalent to gitk?
23:24:04 <ziman> augur, yes but in that case, you should have philosophical problems with everything; are you sure that you are seeing what you're seeing given that there's nonzero probability of photons interacting with your retina in a way that creates an image of a computer and keyboard, while you are in fact sitting at a beach looking at palms?
23:24:33 <augur> ziman: thats sort of my point :P
23:24:48 <augur> im just using a learning algo because, well, they do seem to _work_ pretty well
23:33:00 <ziman> [maybe we should take this to -blah if we want to continue] Personally (IRL), I gave up the idea of "knowing surely" completely -- and the framework of probabilistic inference gives you just the tools to deal with this standpoint and reason from there, keeping inherent (quantifiable) uncertainty in everything. I don't know whether I'm *really* seeing what I'm seeing but I also don't care much.
