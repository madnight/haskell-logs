00:03:49 <xil> hi everyone. I'm looking for a FIFO datastructure that doesn't operate in the IO monad. Is there such a thing?
00:04:10 <Veinor> xil: what do you mean?
00:04:33 <xil> Veinor: something like Control.Concurrent.Chan, but Chan's functions all return IO (something)
00:05:03 <ladr0n> why do you want it to not use the IO monad?
00:05:05 <xil> I don't want the IO. I want a list that's FIFO rather than Haskell's standard list which is FILO
00:05:20 <shachaf> You want a mutable data type, or what?
00:05:35 <xil> ladr0n: I mean I could use the IO monad, but then everything has to be IO and I'd just like to avoid that
00:06:00 <xil> shachaf: I essentially want the equivalent of the Haskell list [], but FIFO rather than FILO
00:06:23 <xil> is there not such a thing?
00:06:23 <shachaf> What API do you want for it?
00:06:43 <xil> shachaf: all I need is the ability to enqueue and dequeue
00:06:47 <shachaf> add :: a -> Fifo a -> Fifo a; remove :: Fifo a -> (Maybe a, Fifo a)?
00:07:12 <Veinor> xil: http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Sequence.html
00:07:30 <xil> aha, there
00:07:35 <shachaf> Data.Sequence will probably work reasonably well for that, yes.
00:07:57 <xil> I thought I remembered using something for this and it was Seq, just didn't remember that specifically until now
00:07:58 <xil> thanks =]
00:08:01 <shachaf> Hackage also has several queue libraries.
00:08:45 <xil> shachaf: yeah I was looking at some of those, but they look rather robust, and consequently more complex than my current needs
00:08:57 <xil> wasn't sure it would be worth figuring them out if there were a simpler solution
00:08:58 <shachaf> I just looked and some of them had pretty simple APIs.
00:09:39 <shachaf> But if you don't care that much Data.Sequence should probably be fine. :-)
00:09:57 <xil> I concede that I didn't look too thoroughly  =P, but yeah sequence is exactly what I need =D
00:12:41 <xil> oh also, regarding arrays. If I have an immutable array and modify it's contents several times, but after each time I never refer to the previous version, then can I rely on Haskell to modify elements in place?
00:13:06 <shachaf> No.
00:13:21 <shachaf> There's a version of Array that does that, kind of, but you don't want to use it.
00:13:27 <xil> better to go with a mutable array like IOArray?
00:13:42 <shachaf> Well, better to go with a data structure appropriate for what you're doing. :-)
00:13:55 <shachaf> And/or algorithm.
00:14:17 <shachaf> Maybe it's IOArray or STArray or something; maybe not.
00:15:28 <xil> well I'm making a directed graph, and desire O(1) on random access for moving through the graph
00:15:37 <xil> and the graph is always a fixed size after creation
00:15:55 <xil> that's why I was thinking an array of some type
00:19:26 <shergill_> augur: look into bayesian methods. they yield a probability distribution instead of a point-estimate like frequentist methods (svm etc). you can then defer your philosophical quandary to a later stage when you get the output from the learning algorithm, and then once you decide one way or another (in line with your philosophical beliefs) take action
00:19:42 <augur> shergill_: i already commented on that :P
00:22:44 <shergill> augur: ah right. you called it useless because 'you still have to decide which to expect'. that's wrong. because what you should be expecting _is_ a probability distribution. and not taking into account approximation errors, bayesian methods _will_ give you that probability
00:23:15 <augur> shergill: except if you're trying to make a decision about something, you have to pick some action
00:23:21 <augur> not some probability distribution of actions
00:23:48 <shergill> augur: that's different from what you're expecting. that's at a stage of making use of that which you're expecting
00:23:58 <augur> for instance, suppose you're playing a game where one wrong choice loses the game
00:24:07 <augur> one wrong prediction means you lose
00:24:56 <augur> so how could you design a learning algorithm that predicts the binary sequence so you win? if the possible games are just the binary numbers of length n, you will almost always lose
00:25:12 <shergill> augur: right, and given a probability distribution and an external setting wherein you're required ot make use of that information, you take the action which maximizes the quantity you're interested in
00:25:34 <augur> but you have to know ahead of time what the probability distribution of the space is
00:25:39 <shergill> yes, learning algorithms can't do magic
00:25:44 <augur> i know, im just saying
00:26:11 <augur> without some prior _truth_, a learning algorithm couldn't possible have any hope of being accurate
00:26:25 <augur> but if it has some prior knowledge of truth, then there's nothing to do.
00:26:46 <augur> you just use that as the optimal strategy
00:26:57 <shergill> you just build a tower of priors (i'm actually not being facetious), and at the top of that tower put an uninformative prior
00:27:14 <augur> i think learning algorithms only work when the number of games is infinite
00:27:16 <shergill> ideally, it'd be priors all the way down, but due to computational reasons you cap it at a finite depth
00:27:21 <augur> and you iterate
00:27:22 <shergill> /s/depth/height/
00:27:43 <augur> yeah, that's what i mean basically
00:27:54 <augur> i mean, imagine this scenario, right
00:28:00 <augur> we're playing the binary prediction game
00:28:09 <augur> but each time we play, the "truth" is different
00:29:11 <augur> you couldnt give a single algorithm that will learn properly for all games, because it will always have to start over with it's guessing
00:29:49 <shergill> learning algorithms with infinite precision only work when you have infinite data and infinite resources. but learning algorithms _do_ work with finite data and resources
00:29:59 <augur> right
00:30:20 <augur> i think the crucial bit is that the rules are stable, and the games are infinitely long
00:30:32 <augur> then you can probably get arbitrarily close to the truth
00:30:51 <shergill> right
00:31:05 <shergill> if you haven't, i'd recommend reading up on de-finetti's theorem etc
00:31:09 <shergill> the basis of bayesian methods
00:31:33 <shergill> there are other extensions to it, all basically talking about the learnability of sequences
00:39:42 <jfischoff> shergill: how do you choose uninformative priors?
00:40:44 <shergill> jfischoff: you don't. the higher up in the hyperparameter 'stack' they are the less impact they have
00:40:52 <shergill> oh sorry
00:40:57 <shergill> misread your ques
00:41:15 <shergill> depends on the family of priors
00:41:35 <jfischoff> for instance in the bent coin or binomial
00:41:56 <jfischoff> there have been several options purposed
00:42:05 <jfischoff> I'm not sure if there is a concensus
00:43:23 <shergill> for binomial you'd pick its conjugate ie beta distribution and set its parameters to be equal (alpha = beta)
00:43:54 <jfischoff> yep that is one way
00:44:25 <jfischoff> Does that also lead to the rule of succession?
00:44:55 <shergill> rule of succession?
00:46:05 <jfischoff> yes I just looked it up. it is the same http://en.wikipedia.org/wiki/Rule_of_succession#Mathematical_details
00:50:06 <shergill> well the idea of having priors (or pseudocounts) is the same. but the idea of having an uninformative prior is orthogonal
00:50:33 <shergill> the rule of succession also takes into account the strength of your belief in said prior
00:52:19 <shergill> eg setting alpha = beta is enough for an uninformative prior. setting them to 1 vs, say, 100 talks about the strength of your beliefs
00:52:23 <jfischoff> I think the beta distribution is equivalent to using an uniform prior for your probabilities, but for whatever reason their have been alternatives purposed
00:54:05 <jfischoff> http://en.wikipedia.org/wiki/Non-informative_prior#Uninformative_priors
01:29:43 <bitonic> Is there an abstraction similar to sockets for inter-threads comunication in haskell? so something that will block on receive and with async send, and some way to close a "connection" (maybe in a better way that just receiving 0 on receive)
01:30:23 <mauke> you could make something out of channels or TVars
01:30:37 <bitonic> mauke: I could, but maybe there's something out there already
01:30:58 <bitonic> it seems something useful to have
01:34:28 <c_wraith> CHP?
01:34:41 <c_wraith> Or is that entirely the wrong direction?
01:35:01 <bitonic> c_wraith: http://www.cs.kent.ac.uk/projects/ofa/chp/ this?
01:35:11 <c_wraith> yeah, that's the project.
01:35:17 <c_wraith> I suspect it's not really what you want
01:35:26 <bitonic> from the look of it, it sounds a bit overkill :P
01:35:34 <bitonic> but I'll check it out, thanks
01:35:44 <bitonic> really what I want could be implemented with MVars fairly easily
01:41:18 * hackagebot vty 4.7.0.14 - A simple terminal access library  http://hackage.haskell.org/package/vty-4.7.0.14 (CoreyOConnor)
02:23:58 <solrize> http://www.well-typed.com/blog/66  why does the channel example have   forever $ return ()   in main?
02:24:13 <solrize> and why does that blow out memory in addition to looping, at least in ghci?
02:49:30 <Botje> that loops forever
02:54:07 <Karunesh> Hi all
03:36:15 <mikeplus64> if i have a record with a member of type a -> b -> c, can I use function syntax in the record? ie if I have data Foo = F {a :: Int -> Int -> Int}, is there a way to do F { a x y = x + y } instead of F { a = \x y -> x + y } ?
03:36:34 <shachaf> Nope.
03:36:58 <mikeplus64> oh well :(
03:37:41 <sipa> foo x y = x + y
03:37:44 <sipa> F { a = foo }
03:37:58 <sipa> or even
03:38:03 <sipa> F { a = foo }
03:38:14 <sipa>     where foo x y = x + y
03:38:28 <shachaf> That's not how where works.
03:38:36 <shachaf> Well, not with-out more context.
03:39:57 <byorgey> let foo x y = x + y in F { a = foo }
03:40:34 <byorgey> also,  F { a = (+) }   =P
03:41:09 <mikeplus64> was just an example :)
03:41:24 * hackagebot shake 0.2.10 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.2.10 (NeilMitchell)
03:41:28 <byorgey> I know =)
03:45:55 <sp3ctum> is there a good irc client in haskell?
03:48:10 <mikeplus64> client, not really
03:48:23 <mikeplus64> but there are bots
03:49:05 <sp3ctum> hmm
03:49:29 <mikeplus64>  https://github.com/mikeplus64/QuasiText
03:49:31 <mikeplus64> herp
03:49:34 <mikeplus64> bad clipboard
03:49:41 <mikeplus64> https://github.com/mikeplus64/Greg
03:49:48 <mikeplus64> my irc bot library
03:51:55 <robinhoode> Are there any NoSQL databases that work with Haskell natively?
03:52:16 <robinhoode> It seems like many of them use JavaScript on the back end to do map/reduce
04:55:02 <HugoDaniel> hi
04:55:07 <HugoDaniel> i can't understand this: http://rosettacode.org/wiki/Towers_of_Hanoi#Haskell
04:56:34 <mauke> HugoDaniel: what's unclear?
04:57:35 <HugoDaniel> lazyness and the order of evaluation of ++
04:57:47 <mauke> huh?
04:58:17 <HugoDaniel> how are the values being hold up to be computed ?
04:58:58 <mauke> I can't parse that sentence
04:59:06 <mauke> (specifically the "being hold" part)
04:59:44 <HugoDaniel> how does the call stack grow ?
05:00:00 <mauke> ... bigger?
05:00:30 <HugoDaniel> sorry, im not in my days
05:00:32 <mauke> is there even a call stack?
05:00:41 <HugoDaniel> it should be, because its recursive
05:00:54 <HugoDaniel> hanoi is calling itself
05:01:08 <byorgey> GHC's runtime does not really use a call stack.  It has an evaluation graph.  Or something like that.
05:01:19 <byorgey> but in any case that is an implementation detail.
05:01:23 <mauke> I thought the stack was for evaluating thunks, not calling functions
05:01:36 <byorgey> I don't see how it is relevant to understanding the hanoi function.
05:01:53 <HugoDaniel> i understand it, just don't know how it goes underneath
05:02:08 <HugoDaniel> sure its easy, typical hanoi solving equation implemented in haskell
05:02:19 <HugoDaniel> 1st year, 1st semester type of homework
05:02:24 <HugoDaniel> no problems there
05:02:54 <byorgey> so, ++ has to pattern-match on its first argument
05:02:58 <mauke> it's kinda inefficient because (++) copies its first arg
05:04:11 <HugoDaniel> yeah
05:04:33 <HugoDaniel> but there are two (++) with recursive calls on each side
05:05:02 <HugoDaniel> i dont understand it :(
05:05:10 <mauke> the second (++) is ok because it immediately turns into (a,b) : hanoi (n-1) c b a
05:05:29 <HugoDaniel> ah, ok, tail recursion makes that easy going
05:05:40 <mauke> it's not tail recursive
05:05:45 <mauke> @src (++)
05:05:45 <lambdabot> []     ++ ys = ys
05:05:45 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
05:05:46 <lambdabot> -- OR
05:05:46 <lambdabot> xs ++ ys = foldr (:) ys xs
05:06:06 <HugoDaniel> why isn't it tail recursive ?
05:06:26 <mauke> because the outermost call isn't to itself
05:07:05 <byorgey> I guess you end up with a recurrence like  T(n) = 2T(n-1) + 1 + T(n-1)
05:07:17 <byorgey> so it ends up doing O(3^n) work to generate a list of length O(2^n)
05:07:17 <HugoDaniel> mauke but it is
05:07:23 <mauke> HugoDaniel: where?
05:07:27 <byorgey> though I could be mistaken
05:07:50 <HugoDaniel> f n a b c = .. ++ f .. <- here
05:07:58 <mauke> that's not the outermost call
05:08:55 <HugoDaniel> its the leftmost, so ++ has more precedence than function calling ?
05:08:57 <HugoDaniel> it shouldn't
05:09:04 <mauke> it's not the leftmost
05:09:09 <HugoDaniel> sory, rightmost
05:09:16 <byorgey> however, the RHS recursive call is guarded recursive, since the ++ does not match on its second argument.
05:09:20 <byorgey> but the LHS recursive call is not.
05:09:20 <mauke> "rightmost" doesn't matter
05:09:36 <HugoDaniel> it does if (++) has less precedence than function calling (which i think is the case in haskell)
05:09:42 <mauke> HugoDaniel: no
05:09:45 <mauke> (++) (f x) (f y)
05:09:51 <mauke> the outermost call is to ++, not f
05:10:23 <HugoDaniel> oh ok
05:10:24 <HugoDaniel> nice
05:10:42 <HugoDaniel> so its not tail recursive
05:10:54 <HugoDaniel> making it even worse than what i was thinking initially :(
05:11:16 <mauke> tail recursion is bad for streaming
05:11:22 <byorgey> tail recursive vs. non-tail-recursive is not really important in Haskell.
05:11:35 <HugoDaniel> why ?
05:11:43 <byorgey> because of laziness.
05:11:52 <mauke> because for streaming you want to generate results incrementally
05:11:59 <byorgey> the important thing is guarded recursion.
05:12:08 <byorgey> if recursive calls only occur as arguments to constructors
05:12:13 <byorgey> then you can consume the result lazily
05:12:48 <HugoDaniel> byorgey: i dont understand
05:13:03 <mauke> @src foldr
05:13:03 <lambdabot> foldr f z []     = z
05:13:03 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:13:12 <mauke> foldr isn't tail recursive
05:13:14 <osa1> what's wrong with this code? http://paste.lisp.org/display/129521 I'm getting an error about | character in last line
05:13:18 <mauke> the outermost call is to f, not foldr
05:13:22 <byorgey> HugoDaniel: consider  map f [] = [];  map f (x:xs) = f x : map f xs
05:13:35 <mauke> (yeah, or that. maybe a bit simpler than foldr)
05:13:40 <byorgey> HugoDaniel: this is not tail recursive, agreed?
05:13:51 <byorgey> (because the outermost call is to (:), not map)
05:14:09 <mauke> osa1: remove "-> _" and change "=" to "->"
05:14:10 <HugoDaniel> byorgey: yes, i see that now with the explanaition from mauke
05:14:16 <HugoDaniel> agreed
05:14:22 <HugoDaniel> i can understand yes
05:14:31 <HugoDaniel> lazyness just postpones the evaluation of the right hand of (:)
05:14:32 <byorgey> HugoDaniel: however, map is quite nice and can often be compiled to iterative code that runs in constant space
05:14:43 <HugoDaniel> and the result of the first hand is immediately returned
05:14:52 <byorgey> HugoDaniel: right.
05:14:59 <osa1> mauke: great, thanks.
05:15:08 <byorgey> HugoDaniel: that's what I mean when I say "recursive calls only occur as arguments to constructors"
05:15:32 <byorgey> you can evaluate one or more constructors from the result (and do something useful with them) before demanding the result of the recursive call.
05:16:01 <byorgey> in the case of map, the recursive call occurs as an argument to the (:) list constructor
05:17:23 <HugoDaniel> hmm
05:19:01 <fluffynukeit> hello, all.  I have a question regarding infinite search monad if anyone can answer.  Anyone here familliar with it?
05:20:13 <byorgey> HugoDaniel: sorry, I have to go, but can continue later (or someone else can continue)
05:20:28 <HugoDaniel> byorgey: still i dont know how does it work with two (++) constructors (can these be called constructors?=)
05:20:32 <HugoDaniel> ok, thanks :)
05:20:42 <mauke> no, (++) isn't a constructor
05:20:49 <mauke> it doesn't start with an uppercase character
05:20:53 <HugoDaniel> @src (++)
05:20:54 <lambdabot> []     ++ ys = ys
05:20:54 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
05:20:54 <lambdabot> -- OR
05:20:54 <lambdabot> xs ++ ys = foldr (:) ys xs
05:21:02 <mauke> (':' counts as uppercase punctuation)
05:21:12 <HugoDaniel> oh
05:21:13 <HugoDaniel> ok
05:21:19 <mauke> @src []
05:21:19 <lambdabot> data [] a = [] | a : [a]
05:21:20 <HugoDaniel> so ':' is actually List
05:21:26 <HugoDaniel> ah yes ok ok
05:22:40 <HugoDaniel> ok, then if i have a pattern like: f n a b = f (n-1) b a ++ [..] ++ f (n-1) a b
05:24:19 <HugoDaniel> it gets deconstructed like: f (n-1) b a : ([...] ++ f (n-1) a b), right ?
05:24:24 <HugoDaniel> or am i thinking this all wrong again ?
05:24:47 <HugoDaniel> @src (:)
05:24:48 <lambdabot> Source not found.
05:24:52 <rwbarton> well first of all you need to know x ++ y ++ z means x ++ (y ++ z)
05:25:23 <rwbarton> to evaluate that we start with the outermost function application, the left ++
05:25:43 <rwbarton> and the definition of ++ says we first pattern match the left argument against [] vs. (x:xs), and go from there
05:26:02 <HugoDaniel> ok
05:26:12 <mauke> :t (++)
05:26:13 <lambdabot> forall m. (Monoid m) => m -> m -> m
05:26:15 <mauke> heh
05:26:21 <mauke> :t (P.:)
05:26:22 <lambdabot> Couldn't find qualified module.
05:26:26 <mauke> :t (Prelude.++)
05:26:26 <lambdabot> forall a. [a] -> [a] -> [a]
05:26:32 <mauke> :t (:)
05:26:32 <lambdabot> forall a. a -> [a] -> [a]
05:27:29 <HugoDaniel> i still haven't understood how the hanoi gets evaluated though :/
05:27:36 <HugoDaniel> im very dumbass
05:27:49 <HugoDaniel> hanoi n a b c = hanoi (n-1) a c b ++ [(a,b)] ++ hanoi (n-1) c b a
05:27:56 <mauke> well, it gets evaluated when its caller looks at the result
05:28:16 <mauke> and "looks at the result" means it determines whether it's [] or (:) x y for some x, y
05:28:29 <mauke> (because those are the two possible shapes for a list value)
05:29:08 <HugoDaniel> so
05:29:23 <HugoDaniel> hanoi 0 _ _ _ = []
05:29:31 <mauke> the result has the form (++) (hanoi (n-1) a c b) ((++) [(a,b)] (hanoi (n-1) c b a))
05:29:49 <HugoDaniel> the outtermost is the first (++)
05:29:52 <mauke> the next step in evaluating that is to substitute the definition of ++
05:30:25 <mauke> (++) [] ys = ys; (++) (x : xs) ys = x : (++) xs ys
05:30:36 <mauke> so (++) pattern matches on its first argument
05:30:45 <mauke> so we need to evaluate *that*
05:31:04 <mauke> now we need to resolve hanoi (n-1) a c b
05:31:30 <mauke> hanoi itself pattern matches on its first argument (to compare it to 0)
05:31:37 <HugoDaniel> nice yes, pattern matching implies evaluation to know the flow
05:31:39 <mauke> so we call n-1
05:32:04 <mauke> the next step depends on whether n-1 is 0 or not
05:32:35 <mauke> if it's 0, we simply return [] without looking at a/c/b
05:32:55 <mauke> if not, we're stuck with another (++) (hanoi ...) ((++) ... ...)
05:33:03 <HugoDaniel> and so on
05:33:06 <mauke> yeah
05:33:13 <HugoDaniel> cool
05:33:24 <HugoDaniel> its like a tree of pattern matchin
05:33:34 <HugoDaniel> a graph actually
05:36:47 * hackagebot time-lens 0.1 - Lens-based interface to Data.Time data structures  http://hackage.haskell.org/package/time-lens-0.1 (RomanCheplyaka)
05:37:46 <HugoDaniel> so since the (++) definition
05:37:51 <HugoDaniel> pattern patches on the first argument
05:38:01 <HugoDaniel> we always get the first argument evaluated
05:38:47 <HugoDaniel> and the evaluation of the second argument postponed until needed
05:39:12 <mauke> (++) itself never evaluates its second argument
05:39:14 <HugoDaniel> (++) never evaluates the second argument, right ?
05:39:17 <mauke> haha
05:39:23 <HugoDaniel> cool :)
05:41:14 <HugoDaniel> hanoi is just (++) trickery inside recursive calls, i still haven't quite got it yet, but i can +- see how it goes
05:41:30 <HugoDaniel> because the second argument of the first (++), is the first argument of the second (++)
05:42:03 <mauke> the second argument of the first (++) is the second (++)
05:42:22 <HugoDaniel> ah yes yes true
05:42:32 <HugoDaniel> very good then its easy
05:42:39 <HugoDaniel> cool
05:43:08 <HugoDaniel> i feel totally dumb for not getting it immediately :)
05:43:28 <HugoDaniel> i see this is a very common pattern in knapsack algorithms and recursive dynamic programming
05:44:53 <Stalafin> I am going to have to write a quantum montecarlo simulation for my Master thesis - do you recommend using Haskell for something like that, performance wise?
05:45:53 <HugoDaniel> Stalafin: you are asking the right question in the wrong channel :/
05:46:11 <HugoDaniel> in here you are only going to get biased opinions :)
05:46:18 <Stalafin> HugoDaniel: obviously :D
05:46:41 <lucian> in ghci, i did import System.Random, but random and mkStdGen are reported as not in scope
05:46:46 <Stalafin> HugoDaniel: the thing is that I could obviously write this in Fortran or Python, but I really dig Haskell (although I don't know much about it)
05:46:47 <lucian> perhaps i'm misunderstanding haskell's import
05:46:51 <mauke> .oO( I use nuclear decay to randomly select channels to ask for advice )
05:47:15 <Stalafin> HugoDaniel: so the question is, if it is worth diggin my theet into Haskell...
05:47:23 <mauke> lucian: works here
05:47:41 <lucian> mauke: and your prompt includes System.Random after importing it? mine doesn't
05:47:57 <mauke> lucian: no, I have a fixed prompt of "*"
05:48:05 <lucian> oh
05:48:20 <HugoDaniel> Stalafin: im not familiar with monte carlo methods, but haskell sure is worth learning, specially if you are a curious kind of person
05:48:23 <arcatan> Stalafin: if you don't know much about Haskell, you might find that learning it takes lots of time
05:48:30 <mauke> lucian: http://hpaste.org/68706
05:49:16 <Stalafin> arcatan: I am aware of that; I have some basic computer science training (using SML), although I am not a computer scientist.
05:49:40 <lucian> mauke: hmm, not what i'm getting here
05:50:12 <arcatan> I'd expect that performance-wise Haskell would be at least as fast as Python, unless there are some well-optimized Python libs you could use
05:50:34 <lucian> arcatan: it's often faster
05:50:53 <lucian> arcatan: barring unexpected thunk-related weirdness, i've found there's no comparison
05:51:02 <lucian> although PyPy probably beats it
05:51:13 <arcatan> I mean, Haskell is fast when you know what you do, but debugging the performance can be tricky
05:52:14 <arcatan> Fortran's feats in scientific computation are well-established :P
05:52:45 <c_wraith> Fortran is very well designed for allowing the compiler to do high-level optimization of scientific code.
05:52:48 <lucian> mauke: ah, works now. i installed haskell-platform. very odd that i didn't get an error about the package missing
05:53:26 <lucian> c_wraith: not exactly, it's terrible for parallelisation. compilers often unroll loops and then re-build them as parallel ones
05:54:44 <Stalafin> Seems like there are BLAS bindings for Haskell
05:54:50 <Stalafin> That's pretty cool.
05:55:57 <HugoDaniel> mauke: im sorry to be insisting but why is that implementation of hanoi inefficent ?
05:58:33 <mauke> because (++) copies its first argument
05:59:13 <mauke> and there are 2^n calls to hanoi/the first (++) in it
05:59:22 <mauke> copies, copies everywhere
05:59:51 <ziman> > cycle "copies "
05:59:52 <lambdabot>   "copies copies copies copies copies copies copies copies copies copies copi...
06:00:24 <HugoDaniel> oh
06:00:26 <weasels> > cycle "developers "
06:00:26 <lambdabot>   "developers developers developers developers developers developers develope...
06:00:39 <rwbarton> any time you have (x ++ y) ++ z, you are copying x twice
06:01:13 <HugoDaniel> yeah, it copies (++) (x : xs) ys = x : (++) xs ys
06:02:11 <HugoDaniel> is there any alternative in haskell ?
06:02:16 <mauke> hanoi_d 0 _ _ _ = id
06:02:57 <adnauseam> guys , how do i go about removing all elements of a set from another, using foldr "?
06:02:59 <ziman> it would be cool if lambdabot could output the number of cpu cycles burned while evaluating the given expression, something like Hugs does (with the number of reductions, iirc)
06:03:07 <mauke> hanoi_d n a b c = hanoi_d (n-1) a c b . ((a, b) :) . hanoi_d (n-1) c b a
06:03:18 <mauke> hanoi n a b c = hanoi_d a b c []
06:03:30 <adnauseam> i've been trying by implemeting takeWhile with foldr, i'm not sure how to make it recurisve
06:03:57 <HugoDaniel> mauke, i see, very good
06:04:07 <mauke> adnauseam: foldr works on lists, not sets
06:04:31 <adnauseam> mauke - i've two strings - i was just thinking too generally
06:04:48 <adnauseam> didn't mean haskell sets
06:05:07 <mauke> remove xs ys = filter (`notElem` xs) ys
06:05:29 <HugoDaniel> rwbarton: im copying it all, recursively, into a new list of x and y, and then copying it all again (also with y) into a new list of x, y and z, right ?
06:05:54 <adnauseam> hmm
06:05:54 <mauke> @src elem
06:05:54 <lambdabot> elem x    =  any (== x)
06:05:59 <mauke> @src any
06:05:59 <lambdabot> any p =  or . map p
06:06:02 <mauke> @src or
06:06:02 <lambdabot> or    =  foldr (||) False
06:06:06 <mauke> @src map
06:06:06 <lambdabot> map _ []     = []
06:06:06 <lambdabot> map f (x:xs) = f x : map f xs
06:06:09 <mauke> meh
06:06:18 <HugoDaniel> hmm
06:06:24 <mauke> implementation of map/filter in terms of foldr left as an exercise for the reader
06:07:15 <adnauseam> hm
06:07:17 <adnauseam> thanks ma n
06:12:17 <rtharper> adnauseam: it's a good exercise =)
06:32:43 <bartavelle> hello, what is the inner monad type if I want to use ErrorT in a pure function ?
06:33:07 <Saizan> Identity
06:33:44 <navaati> (or you can simply use Either, which is a MonadError)
06:34:11 <bartavelle> I am not sure on how to do that
06:34:26 <bartavelle> i can runErrorT on something that just returns Either ?
06:34:52 <navaati> runErrorT :: ErrorT e m a -> m (Either e a)
06:35:19 <navaati> with m = Identity, you have runErrorT :: ErrorT e Identity a -> Identity (Either e a)
06:35:58 <navaati> it's simpler to not bother with runErrorT and runIdentity
06:36:32 <navaati> istead of having actions of type "ErrorT e Identity a", you have actions of type "Either e a"
06:36:47 <bartavelle> As I said, I am not sure on how to do that. I want to chain computations on a parameter that will transform it and can result in a an error
06:37:01 <bartavelle> doing it with >>= is straightforward
06:37:12 <bartavelle> I suppose I could just put all my computations in a list
06:37:13 <bartavelle> and fold
06:37:18 <navaati> yeah, but >>= works with either, too
06:37:23 <bartavelle> ah !
06:38:01 <bartavelle> with func1 :: Either a b, func2 :: Either a b, I could write x = (func1 >>= func2) y ?
06:38:22 <byorgey> that does not type check, but you have the right idea
06:38:32 <navaati> no, this is wrong, and would be wrong with ErrorT as well
06:38:48 <bartavelle> ah yes
06:38:52 <bartavelle> func1 y >>= func2
06:39:48 <navaati> no, calm down and listen to the types
06:39:48 <navaati> an object of type "Either e a" is *not* a function
06:39:51 <navaati> you could have, of course, something of type "a ‚Üí Either e b" which would be a function
06:40:28 <bartavelle> ah sure
06:40:43 <bartavelle> func1 :: b -> Either String b
06:41:12 <mauke> no, func2
06:41:44 <bartavelle> func1 and func2 should have the same type definition in my case
06:41:47 <navaati> for example, if you have "func1 :: a ‚Üí Either e b" and "func2 :: b ‚Üí Either e c", you could write "x = func1 y >>= func2", and x would have type "Either e c" (it assumes that y have type "a")
06:42:52 <mauke> bartavelle: no
06:43:02 <mauke> that's not how >>= works
06:43:06 <navaati> :t (>>=)
06:43:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
06:43:44 * mauke ponders
06:43:57 <navaati> seems, bartavelle, that you rather want something like :
06:43:58 <navaati> :t mapM
06:43:58 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
06:44:10 <navaati> or :
06:44:13 <navaati> :t sequence
06:44:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
06:45:07 <bartavelle> err
06:45:40 <navaati> you said "I want to chain computations on a parameter that will transform it and can result in a an error"
06:46:11 <bartavelle> i want to do exactly this, to validate a "resource" : validation res = requiredParameters ["name","path","mode"] res >>= stringParameter ["name","path"] >>= validMode ["mode"]
06:46:37 <bartavelle> and that will check that I have set all 3 parameters in my resource, that "name" and "path" are strings, and that mode is an actualy posix file mode
06:46:40 <bartavelle> actual
06:46:42 <navaati> yeah, seems good
06:47:16 <bartavelle> and all 3 functions should have type : MyResourceType -> Either String MyResourceType
06:47:58 <bartavelle> works like a charm !
06:48:01 <bartavelle> thanks
06:48:12 <bartavelle> it is indeed much better than bothering with runErrorT
06:48:27 <navaati> oh, tip of the day : look at (>=>)
06:48:35 <navaati> :t (>=>)
06:48:35 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
06:48:49 <navaati> composition for monadic functions
06:48:53 <bartavelle> ah
06:49:10 <navaati> with this, you can write :
06:49:14 <bartavelle> that way I could remove "resÈ"
06:49:18 <bartavelle> from my equation
06:49:27 <navaati> validation = requiredParameters ["name","path","mode"] >=> stringParameter ["name","path"] >=> validMode ["mode"]
06:49:30 <navaati> exactly
06:49:37 <bartavelle> looks much better yes
06:52:41 <navaati> (hum, also it looks like there could be a monoid involved here, but‚Ä¶)
06:52:46 <topologist> echo $window
06:53:05 <navaati> wrong
06:53:17 <navaati> :)
06:53:23 <bartavelle> I am not sure how this could be a good thing
06:59:48 <navaati> ah no, the monoid i was thinking about does not respect the laws. anyway, don't bother about that :)
06:59:50 <d-snp> hey, is there a quick and dirty oneliner for getting a random number inside an io monad?
07:00:03 <navaati> d-snp: there is
07:00:13 <mauke> :t randomIO
07:00:14 <lambdabot> forall a. (Random a) => IO a
07:00:31 <navaati> mauke faster than me
07:00:43 <c_wraith> :t randomRIO -- also useful sometimes
07:00:44 <lambdabot> forall a. (Random a) => (a, a) -> IO a
07:01:04 <c_wraith> the tuple is (lower bound, upper bound)
07:02:11 <d-snp> ah nic ethanks
07:03:40 <d-snp> hmm it has no definition for Word32
07:04:31 <mauke> easily fixed by using the Integer instance. probably.
07:05:50 <d-snp> argh I find io monad syntax still so awkward
07:09:02 <mikkihiiri> hello again! a quick question, if I have a module that has my own record, can I somehow export that type constructor?
07:09:50 <mauke> sure, why not?
07:10:26 <mikkihiiri> then how?
07:11:22 <mauke> er. put it in the export list?
07:11:42 <hpaste> mikkihiiri pasted ‚Äúimporting type constructor‚Äù at http://hpaste.org/68711
07:11:53 <mikkihiiri> there's my module
07:12:34 <Saizan> Bus would work
07:12:41 <Saizan> but it only exports the type
07:13:12 <Saizan> if you want to export the data constructor then you've to use Bus(Bus) or Bus(..)
07:14:46 <mikkihiiri> thanks. Bus(Bus) works if I also export number, line, start etc.
07:15:01 <mikkihiiri> but what does that syntax actually mean?
07:15:12 <mikkihiiri> Bus(Bus) I mean
07:15:54 <navaati> it means "export the type called Bus and it's data constructor called Bus aswell"
07:16:46 <mikkihiiri> okay.. is there a documentation for that somewhere.. never seen anything like that
07:17:30 <mauke> @where report
07:17:30 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
07:24:16 <romildo> Today I've read about the possibility of using haskell-mode for emacs and speedbar, and followed the insturctions at http://www.haskell.org/haskellwiki/Emacs/Project_navigation, but no .hs files are listed in the speedbar. Any clues?
07:24:16 <lambdabot> romildo: You have 1 new message. '/msg lambdabot @messages' to read it.
07:26:51 <Taneb> Does hackage check for duplicate modules?
07:27:02 <hpc> don't think so
07:27:13 <Taneb> As in, Foo.Bar is in package baz already! Don't use it in package foobar!
07:27:28 <hpc> see: base Prelude, haskell98 Prelude, haskell2010 Prelude
07:27:39 <Taneb> Aaaah
07:28:30 <hpc> it warns about inventing new top-level modules though
07:28:50 <hpc> "don't use Foo.Bar - top-level module Foo doesn't exist"
07:29:13 <Taneb> Okay
07:29:56 <Taneb> How do GHC et al. behave if there's a conflict?
07:31:25 <hpc> they will freak out, if conflicting packages are included in compilation
07:31:43 <hpc> so for Prelude, that means it fails to compile if cabal's build-depends include base and haskell98
07:31:57 <hpc> or if you have base and haskell-98 both ghc-pkg unhidden
07:32:13 <Taneb> This gives me a possibly awful idea for an extension
07:32:21 <hpc> package imports?
07:32:29 <Taneb> import Foo.Bar from baz
07:32:32 <hpc> import "base" Prelude -- already exists
07:32:37 <Taneb> Aaah
07:32:47 <Taneb> Thanks for telling me that
07:32:59 <Taneb> I've not needed it yet, though
07:33:06 <hpc> i hope you never do ;)
07:34:08 <hpc> hehe, i am so glad i put /usr/game/fortune in my bashrc
07:34:09 <hpc> "Excellent day for putting Slinkies on an escalator.
07:34:11 <hpc> "
07:35:23 <XexonixXexillion> Is there any way to guarantee that an action won't be interrupted by GC?
07:36:10 <hpc> XexonixXexillion: is this out of curiosity, or do you need this for something?
07:36:31 <XexonixXexillion> hpc: curiosity
07:36:50 <hpc> afaik, there isn't, but i don't know very much about that kind of low-level trickery
07:37:12 <hpc> you have me curious too, now :P
07:38:55 <navaati> it would be sooo much useful (realtime stuff)
07:41:38 <hpc> fast GCs go really quick, so whatever you were doing would have to be pretty sensitive to time
07:42:08 <kallisti> > foldr (const succ) 0 [100..110]
07:42:09 <lambdabot>   11
07:42:13 <hpc> er, forgot about the occasional full-program GC
07:42:15 <hpc> ignore me
07:42:17 <Taneb> Is there a way of retroactively enabling documentation on a module, without reinstalling it?
07:42:35 <kallisti> Taneb: cabal haddock will generate docs from a package. is that what you mean?
07:43:01 <Taneb> kallisti, like cabal install module --enable-documentation
07:43:21 <kallisti> all of the --enable-* options require a reinstall as far as I know.
07:43:24 <kallisti> it's a huge pain. :P
07:43:56 <kallisti> about 2 months ago I nuked my cabal directory and changed the config to enable profiling by default, so I can profile my code.
07:44:14 <kallisti> also enable-optimization which does -O2 I believe
07:44:45 <hpc> cabal doesn't -O2 by default?
07:44:47 <hpc> :(
07:44:53 <Saizan> it -O by default
07:44:58 <hpc> ah
07:45:53 <kallisti> there should be a "cabal nuke" :P
07:46:07 <hpc> cabal unsafeLaunchMissiles
07:46:15 <navaati> +1 : sadly it still happens often
07:46:23 <Saizan>  -O --enable-optimization[=n]      Build with optimization (n is 0--2, default
07:46:23 <Saizan>                                    is 1)
07:46:25 <Saizan> btw
07:46:36 <kallisti> oh.
07:46:57 <kallisti> I wonder how I set that in the config file
07:47:10 <kallisti> oh wait nevermind
07:47:22 <weasels> hmmm
07:47:28 <kallisti> I didn't use the optimization config setting, I just manually set --ghc-options='-O2' under flags.
07:50:13 <weasels> so if I remove the -- in front of "optimization: True", then I get this error message when using cabal
07:50:19 <weasels> "cabal: Command.optionToFieldDescr: feature not implemented"
07:50:46 <weasels> so how *do* I turn optimization on
07:51:18 <kallisti> I did flags: --ghc-options='-O2'
07:51:21 <kallisti> but there's likely a better way
07:51:40 <hpc> --enable-optimization=2
07:51:42 <weasels> yeah, well, there's a directive in ~/.cabal/config for it, but if I uncomment it
07:51:46 <weasels> cabal breaks
07:51:54 <kallisti> yes I believe that happened to me too
07:51:56 <kallisti> which is why I did the above
07:52:06 <weasels> so why does uncommenting a line break the cabal config
07:52:18 <kallisti> because it's not implemented apparently.
07:52:24 * kallisti is helpful.
07:52:43 <weasels> well, I don't want optimization always set to O2
07:52:55 <kallisti> what do you want
07:53:13 <weasels> I want to be able to control it when using ghc and always have it max when using cabal-install
07:53:32 <kallisti> then that's what this does.
07:53:46 <kallisti> ghc defaults are not in any way related to your cabal config.
07:54:05 <weasels> cabal uses ghc
07:54:12 <Taneb> ghc does not use cabal
07:54:12 <kallisti> correct(?)
07:54:25 <hpc> correct
07:54:25 <weasels> wait
07:54:39 <weasels> oh, there we go
07:54:57 <kallisti> it would be silly to have ghc and cabal coupled in such a way.
07:55:30 <Taneb> Especially as cabal allows you to change compilers
08:00:53 <kallisti> > foldr (const (2:)) [] [100..110]
08:00:54 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2]
08:03:20 <ziman> @hoogle (a,b) -> (b,a)
08:03:21 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
08:03:21 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
08:03:21 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
08:05:17 <infame> A question, f :: Int -> Int -> Int = Int that returns a partial f' and applies and Int, then returns a partial f'' and returns a Int?
08:05:37 <Twey> infame: Uh, yes
08:05:50 <Twey> Wait, no
08:05:56 <Twey> There's only one possible intermediate function there
08:05:58 <Twey> Int -> Int -> Int = Int -> (Int -> Int)
08:05:59 <byorgey> infame: the way you worded that is strange.
08:06:13 <infame> byorgey: Yeah... Im aware of that :p
08:06:14 <byorgey> f is a function which takes an Int, and returns a function of type  (Int -> Int)
08:06:29 <byorgey> the returned function, in turn, takes another Int as an argument and finally returns an Int
08:07:01 <infame> Ah, alright.
08:07:05 <infame> Thanks.
08:10:47 <infame> Kinda like haskell, although, curried function's a bit confusing... Both in the structure and practical usage of it...
08:12:21 <Taneb> I'm sorta glad I wasn't really competent in any language before I started Haskell
08:12:41 <Taneb> I knew a bit of Python, and a mostly forgotten bit of VB.NET
08:13:03 <Taneb> But I struggle with imperative programming more than I do functional, now
08:14:02 <infame> I kinda wish that was my current state, now. :p
08:14:26 <Taneb> It's not that great
08:15:05 <Taneb> I tried to learn C, I'm confused about nearly everything
08:15:36 <infame> I also strugle to find moments where I would actually use Haskell over, say, C++(/11)/C#/Java/Python/Ruby
08:16:10 <Taneb> The only one of those I've really used is Python
08:16:34 <Taneb> And looking back at it, I think I was really meant for functional programming? I dunno
08:16:54 <infame> Python is fun... But it kinda removes the challenge that C++(/11) and Java gives you... Less fun that way..
08:17:05 <Taneb> You sound like a Dwarf Fortress fan
08:17:20 <infame> Pardon me?
08:17:29 <Taneb> Never  mind
08:17:33 <infame> xD
08:19:24 <infame> Ah... Looks a bit too old school for me.
08:19:37 <Taneb> Heh
08:19:48 <Taneb> The motto is "Losing is Fun", but we're getting quite off topic here
08:20:15 <infame> You don't say
08:20:29 <Taneb> Haskell has the advantage in that  there's a lot less that /could/ go wrong
08:20:59 <Taneb> Mistype a variable name, it'll probably not compile
08:21:42 <Philippa_> unless you're using a lot of single-character identifiers
08:21:44 <Philippa_> BTDT
08:21:53 <infame> strongly typed, then
08:21:59 * hackagebot digestive-functors 0.3.1.0 - A practical formlet library  http://hackage.haskell.org/package/digestive-functors-0.3.1.0 (JasperVanDerJeugt)
08:22:24 <navaati> is Edward Amsden here ? Animas is broken (because of Eq not implied by Num anymore)
08:22:48 <Taneb> infame, EXTREMELY so
08:23:05 <infame> Using Haskell for CGI, could be fun, though.
08:23:45 <Taneb> Look up Snap, Yesod, and Happstack, among others
08:24:42 <luite>  i don't think the actual CGI launcher for WAI is that well supported though... it's more common to run haskell directly as a web server, and if necessary, use a reverse proxy
08:25:21 <luite> (WAI is the lower level support library for Yesod and some other smaller frameworks, that contains the actual web server or launcher)
08:25:24 <navaati> Taneb: don't caps-lock on "extremely" : there are stronger typed languages :)
08:25:45 <Taneb> navaati, it's EXTREMELY next to Python
08:26:48 <sipa> comparing haskell's static types to python results in a division by zero
08:26:55 <navaati> OH SHI-
08:27:11 <Taneb> Then what'd JavaScript be?
08:27:31 <sipa> the same, i guess - it has no static types at all, afaik?
08:27:48 <lucian> JS is not strongly typed
08:27:57 <lucian> python is
08:28:07 <navaati> well, i think we should distinguish static vs strong, here
08:28:12 <lucian> navaati: indeed
08:28:35 <lucian> in js, '1'+2 is '12' and '1'-2 is -1
08:28:40 <navaati> (ah, python is strongly typed ? interesting, i thought it was not the case)
08:28:48 <lucian> in python, '1' + 2 gives an error
08:29:30 <navaati> in haskell, '1'+2 is correct if you're crazy enough to define a Num instance of Char :D
08:30:03 <sipa> > let a+b = "haha" in ('1'+2)
08:30:04 <lambdabot>   "haha"
08:30:34 <lucian> navaati: heh
08:30:42 <navaati> also that
08:30:55 <navaati> > let a+b = "haha" in typeRep (+)
08:30:56 <lambdabot>   Not in scope: `typeRep'
08:31:19 <sipa> :t (let a+b = "haha" in (+))
08:31:20 <lambdabot> forall t t1. t -> t1 -> [Char]
08:31:22 <navaati> :t let a+b = "haha" in (+)
08:31:22 <mauke> *> '1' + 2
08:31:23 <mauke> '3'
08:31:23 <lambdabot> forall t t1. t -> t1 -> [Char]
08:31:49 <mauke> *> '1' + '2'
08:31:49 <mauke> 'c'
08:31:52 <navaati> Applicative stuff ?
08:31:54 <hpaste> applicative pasted ‚Äúbytestring moronism‚Äù at http://hpaste.org/68713
08:31:54 <navaati> :t (*>)
08:31:55 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
08:31:59 * hackagebot digestive-functors 0.3.2.1 - A practical formlet library  http://hackage.haskell.org/package/digestive-functors-0.3.2.1 (JasperVanDerJeugt)
08:32:11 <Cale> navaati: That's presumably just mauke's prompt
08:32:42 <applicative> Can someone say what is the most egregious error in my little paste?    all the unconses in 'packbyfours'?
08:33:05 <lucian> perhaps i should've mentioned, '' is a string (not a char) in python, just like ""
08:33:24 <Taneb> And """"""
08:34:06 <applicative>  http://hpaste.org/68713 is pretty slow, though  i'm just getting the idea of what i'm doing
08:37:05 <MaskRay> could you please recommend some blogs on syb?
08:37:47 <applicative> hm, blogs are the new 'tutorials' or 'documentation
08:38:48 <MaskRay> tutorials are welcome
08:41:59 * hackagebot protocol-buffers 2.0.7 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/protocol-buffers-2.0.7 (ChrisKuklewicz)
08:42:01 * hackagebot protocol-buffers-descriptor 2.0.7 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification  http://hackage.haskell.org/package/protocol-buffers-descriptor-2.0.7 (ChrisKuklewicz)
08:42:03 * hackagebot hprotoc 2.0.7 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/hprotoc-2.0.7 (ChrisKuklewicz)
08:46:02 <b_jonas> wow, this is cool! I'm reading the release notes for ghc 7.4.1, and it says "It is now possible to give any sort of declaration at the ghci prompt." That's a long wanted feature.
08:46:06 <b_jonas> I know it's old news for you.
08:46:59 * hackagebot digestive-functors 0.4.0.0 - A practical formlet library  http://hackage.haskell.org/package/digestive-functors-0.4.0.0 (JasperVanDerJeugt)
08:47:01 * hackagebot digestive-functors-snap 0.4.0.0 - Snap backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-snap-0.4.0.0 (JasperVanDerJeugt)
08:51:13 <MaskRay> applicative: the trilogy looks good http://web.archive.org/web/20081222003042/http://www.cs.vu.nl/boilerplate/#papers
08:52:03 * hackagebot digestive-functors-blaze 0.4.0.0 - Blaze frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-blaze-0.4.0.0 (JasperVanDerJeugt)
08:52:05 * hackagebot digestive-functors-heist 0.4.0.0 - Heist frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-heist-0.4.0.0 (JasperVanDerJeugt)
08:52:32 <JoeyA> ViewPatterns aren't part of Haskell 2010, are they?
08:53:07 <d-snp> how do I get the current time and date in haskell? I need to check the time difference between some time and another
08:53:25 <d-snp> Data.Time.Clock's getCurrentTime seems to only show the time on today
08:54:15 <Clint> what?
08:55:02 <JoeyA> d-snp: What version of Data.Time.Clock are you looking at?  This has both date and time: http://hackage.haskell.org/packages/archive/time/1.4.0.1/doc/html/Data-Time-Clock.html#t:UTCTime
08:55:31 <d-snp> oh it has a day number
08:55:41 <d-snp> ahh ok
08:56:39 <JoeyA> Note that diffUTCTime can be used to get the difference between two times.
08:57:03 <JoeyA> The reason (-) isn't used is because the return value has a different type, and rightly so.
08:58:21 <d-snp> right
08:59:06 <applicative> MaskRay, i see the WayBack.  It seems there is more literature on uniplate
09:10:52 <d-snp> weird, it says in http://hackage.haskell.org/packages/archive/time/1.4.0.1/doc/html/Data-Time-Clock.html#t:UTCTime that there should be an instance of Show for UTCTime, but if I try to let ghci sow it it says no instance for show
09:11:20 <JoeyA> d-snp: Looks like that instance was added recently.
09:11:29 <rwbarton> are you using version 1.4.0.1 of the time package?
09:11:55 <JoeyA> Err, nevermind
09:11:59 <JoeyA> It's in 1.2
09:12:25 <JoeyA> The Show instance is in 1.0, too.  I think you need to import the module that defined UTCTime
09:12:37 <monochrom> no, it has been there for a long time. it is just lurking in a module you don't expect. import everything (import Data.Time), you'll have it. to actually find out where, use ":info UTCTime"
09:12:51 <JoeyA> (which is Data.Time.Clock...)
09:13:01 <d-snp> ah
09:13:34 <JoeyA> Yeah, I confirm that there is an instance, but it's not appearing in ghci.  I don't know why.
09:15:11 <JoeyA> Ah, got it.  The instance is in LocalTime.
09:16:31 <d-snp> hm? I think it's in Data.Time.Format
09:16:47 <d-snp> oh hm, no you're right
09:17:13 <JoeyA> Just import Data.Time, and you get it all
09:17:18 <d-snp> ok
09:25:28 <JoeyA> Why are so many code generation libraries (e.g. blaze-html, xhtml-combinators) under the Text namespace?
09:26:10 <JoeyA> Although Text or String is the ultimate output (and in some cases, input) format, most code that uses such libraries will work with richer types.
09:26:57 <d-snp> man, Data.Time.Format has no preferred time format :(
09:27:44 <hpc> d-snp: http://hackage.haskell.org/packages/archive/old-locale/1.0.0.3/doc/html/System-Locale.html#t:TimeLocale
09:27:56 <hpc> see the two definitions at the very bottom
09:28:15 <aristid> d-snp: "%Y-%m-%dT%H:%M:%S" is a good time format.
09:29:08 <hpc> the time format i am using for one of my projects is "%a - %T"
09:29:12 <JoeyA> So what is the "new locale library" alluded to by old-locale's package description?
09:29:20 <hpc> which actually i should switch to %T [%a]"
09:29:34 <hpc> "Mon [10:50:22]" -- example output
09:29:35 <aristid> hpc: what does that expand to?
09:30:05 <aristid> hpc: so you know which weekday it is, and the time, but nothing else?
09:30:09 <hpc> it's meant to format IRC timestamps within the past week
09:31:07 <d-snp> oh I don't need to parse anything at all
09:31:11 <d-snp> I can just use the constructor
09:32:36 <d-snp> btw JoeyA if I include Data.Time in ghci I don't get it all
09:34:31 <JoeyA> Data.Time just imports Calendar, Clock, LocalTime, and Format: http://hackage.haskell.org/packages/archive/time/1.4.0.1/doc/html/Data-Time.html
09:35:15 <d-snp> in my ghci show doesn't work until I explicitly import LocalTime
09:35:19 <JoeyA> import Data.Time \n getCurrentTime works for me
09:35:28 <d-snp> ok
09:35:49 <JoeyA> Doesn't work in 7.0.3, though
09:36:32 <JoeyA> But does work if I say :m +Data.Time.LocalTime instead of import (again, for 7.0.3)
09:36:47 <JoeyA> Err, +Data.Time
09:38:59 <JoeyA> By the way, note that in a time format, %Z is extremely verbose on Windows (e.g. "Eastern Standard Time")
09:39:36 <addict3d_> last time I tried to learn haskell, I was too frustrated and gave up... Not this time!
09:41:37 <JoeyA> Bah, the sort function in http://hackage.haskell.org/package/acme-php is of type [()] -> [()].
09:41:54 <hpc> JoeyA: XD XD XD
09:42:00 <hpc> JoeyA: check the source
09:42:09 <JoeyA> yeah
09:42:25 <JoeyA> I think that was a mistake, though (monomorphism restriction).
09:42:34 <hpc> that's the point
09:42:49 <byorgey> by parametricity, every sort can be factored into a call to acme-php sort, plus some other sort.
09:43:04 <b_jonas> er what?
09:43:32 <byorgey> my_sort xs = snd (Acme.PHP.sort [(),(),()], sort xs)
09:44:06 <b_jonas> but then you lose the strict semantics promised by Acme.PHP
09:44:15 <b_jonas> or do you?
09:45:05 * hpc doesn't presume to say that acme-php has semantics
09:45:28 <JoeyA> instance Floating String where pi = "3.14"
09:45:30 <JoeyA> bahahaha
09:45:42 <byorgey> b_jonas: who cares? it works, that's all that matters, right? ;)
09:45:44 <sipa> > pi :: String
09:45:46 <lambdabot>   No instance for (GHC.Float.Floating GHC.Base.String)
09:45:46 <lambdabot>    arising from a use ...
09:46:59 <hpc> my personal favorite is notElem
09:47:01 * hackagebot arithmoi 0.2.0.5 - Efficient basic number-theoretic functions.  Primes, powers, integer logarithms.  http://hackage.haskell.org/package/arithmoi-0.2.0.5 (DanielFischer)
09:47:03 * hackagebot shake 0.2.11 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.2.11 (NeilMitchell)
09:47:26 <byorgey> cos x = sin (x + 90)   -- hahahaha =)
09:48:06 <monochrom> ghc 7.0 ghci's "import" command is buggy. I don't trust it. use ":m +"
09:48:36 <monochrom> or enter your import statements into a file and load that file
09:52:37 <monochrom> is "if compare x y == GT  ... else if compare x y == EQ ... else if compare x y == LT ... else ..." part of the joke?
09:52:59 <hpc> monochrom: very much so
09:53:01 <rwbarton> hmm, why have i never seen "head . head . dropWhile (not . null . drop 1) . group . iterate f" before :)
09:53:04 <hpc> monochrom: try and spot the bug
09:53:47 <rwbarton> it's sort of clever, in its own way
09:54:32 <monochrom> this is the work of a drunk man
09:54:37 <JoeyA> Does it work for most practical usage?  That's all that matters, anyway.
09:54:42 <rwbarton> wait, doesn't it have an extra "not"
09:55:01 <JoeyA> Empty lists, etc. don't really matter that much.
09:55:09 <JoeyA> And nobody really cares what order "01" and "1" are sorted.
09:55:45 <rwbarton> > head . head . dropWhile (not . null . drop 1) . group $ "abcdeefg"
09:55:46 <hpc> hint: the sort function works perfectly fine on lists that are already sorted
09:55:47 <lambdabot>   'a'
09:55:52 <rwbarton> > head . head . dropWhile (null . drop 1) . group $ "abcdeefg"
09:55:53 <lambdabot>   'e'
09:56:58 * JoeyA writes a QuickCheck test for Prelude.PHP.sortBy
10:03:54 <JoeyA> Hmm, what's the proper way to QuickCheck multiple properties?  Just call quickCheck for each one?
10:04:14 <hpc> yeah
10:04:44 <hpc> or you can check \x -> foo x && bar x && ...
10:04:54 <hpc> depends on what kind of test it is, and which looks less horrid
10:07:21 <byorgey> JoeyA: you can also use a package such as test-framework to automate the process somewhat
10:08:56 <JoeyA> Thanks
10:09:42 <JoeyA> Aww, Prelude.PHP doesn't work for typical inputs.
10:10:45 <JoeyA> The PHP way would be to do the expected thing for expected inputs, and the unexpected thing for unexpected inputs.
10:11:50 <JoeyA> For example, with pg_fetch_all, "FALSE is returned if there are no rows in the result, or on any other error. "
10:12:10 <d-snp> I don't understand this, how would I extract the seconds from NominalDiffTime? http://hackage.haskell.org/packages/archive/time/1.1.4/doc/html/src/Data-Time-Clock-UTC.html#NominalDiffTime
10:12:29 <d-snp> I thought using patternmatching
10:12:32 <hpc> JoeyA: but sort works on all inputs!
10:12:42 <hpc> so why would you use sortBy?
10:12:47 <JoeyA> heh
10:13:44 <JoeyA> d-snp: fromIntegral. floor
10:13:59 <JoeyA> (unless there's a better way)
10:14:07 <d-snp> oO
10:14:14 <hpc> fromInteger . floor
10:14:15 <JoeyA> Err, just floor
10:14:18 <monochrom> yeah, use the fact that it is a Num instance etc
10:14:24 <hpc> or that
10:14:27 <hpc> :t floor
10:14:28 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
10:14:39 <d-snp> ohh it has an instance of floor
10:15:16 <JoeyA> If you want milliseconds instead, floor . (* 1000)
10:15:17 <d-snp> oh it has an instance of Real, so it has all methods for Real?
10:15:59 <monochrom> yes
10:16:54 <d-snp> alright.. now would 32bits be enough...
10:17:12 <d-snp> do I want it to be y3k proof? :P
10:17:39 <monochrom> IIRC it's 2047
10:17:54 <JoeyA> > properFraction (3.14 :: NominalDiffTime) :: (Int64, NominalDiffTime)
10:17:55 <lambdabot>   Not in scope: type constructor or class `NominalDiffTime'Not in scope: type...
10:18:31 <geekosaur> 2038's a bugger problem if it touches posix...
10:18:36 <geekosaur> bigger
10:18:48 <monochrom> oops, 2038
10:19:26 <d-snp> I chose today, 2hours ago as my epoch
10:19:31 <hpc> after 2038, the next timestamp overflow is after the sun explodes
10:19:36 <d-snp> :P
10:20:19 <JoeyA> NominalDiffTime is ultimately stored as a fixed-point integer, in picoseconds (it appears).
10:20:25 <JoeyA> Integer, to be more precise.
10:20:40 <d-snp> eh oh
10:20:56 <d-snp> well then this is going to crash way sooner
10:21:09 <d-snp> alright, lets hope no one will ever use this package then :P
10:21:15 <JoeyA> What package?
10:21:35 <d-snp> I'm building a pure implementation of the SCTP protocol
10:21:43 <d-snp> for research/education purposes :P
10:22:00 <d-snp> but I'm terrible at haskell so it will be pretty bad
10:22:37 <nschoe> Hi everyone, I have a small problem with the honk audio library and ghci. When I fire up ghci I can :m Sound.Honk but I have the permission error as described here: http://past.is/SxfE . But when I try sudo ghci I can't :m Sound.Honk. how come ?
10:22:53 <nschoe> I run Archlinux and installed honk with cabal-install
10:23:01 <hiptobecubic> what's honk?
10:23:17 <hiptobecubic> nschoe, because as sudo you aren't you, you're root
10:23:22 <hiptobecubic> root doesn't have that library
10:23:26 <hiptobecubic> it's in your home dir
10:23:51 <hiptobecubic> nschoe, also, be careful when sudo'ing stuff or you'll end up with your home dir being owned by root and everything breaks
10:24:05 <nschoe> hiptobecubic: hum... makes sense.
10:24:14 <hiptobecubic> nschoe, you probably need to add you user to some group or something. I don't know what arch does
10:24:15 <nschoe> hiptobecubic: okay, so how cna I try to play with tihs library?
10:24:37 <hiptobecubic> nschoe, ah i see.
10:24:55 <nschoe> hiptobecubic: yeah... the thing is: I am alreayd a member of the audio group. But that doesn't seem to change anything.
10:25:12 <hiptobecubic> nschoe, yeah no. if you are playing with pc speaker you have to be root i think.
10:25:33 <rwbarton> shouldn't have to be
10:25:34 <hiptobecubic> so switch to the root user with "su -"
10:25:39 <JoeyA> I'd just ghc foo.hs, then sudo ./foo
10:25:45 <nschoe> hiptobecubic: so my only way would be to actually compile the file with my little test in it, then execute it as root?
10:25:50 <JoeyA> Here's what I got: beepDo: interrupted (Interrupted system call)
10:25:52 <rwbarton> you can strace runghc OneBeeph.hs and figure out what device file it can't open
10:26:03 <JoeyA> Might be that my laptop doesn't have a PC speaker.
10:26:05 <hiptobecubic> nschoe, or install the library as root.  or do what rwbarton says because he apparently has good ideas
10:26:27 <nschoe> Okay, I'll try using strace
10:31:34 <teneen> Why is there no ghc extension OverloadedLists?
10:31:40 <teneen> like OverloadedStrings
10:31:46 <JoeyA> beep_do (in the honk package) ought to be broken up into beep_start and beep_stop, so the GHC RTS can do the waiting.
10:32:21 <JoeyA> I don't think sleep, nanosleep, etc. work with GHC because the RTS spams SIGALRM or something.
10:32:22 <byorgey> teneen: because no one has implemented it.
10:32:37 <cheater__> teneen: implement it!
10:32:56 <nschoe> JoeyA: So it means the lib is "broken"?
10:33:11 <teneen> Yeah, I'm asking to know if it has been proposed and rejected for example :)
10:33:15 <JoeyA> It'd be neat if OverloadedLists could let you pattern match on e.g. ByteString
10:33:17 <teneen> Does it have any problems?
10:33:24 <nschoe> Because I do have the same error when ghc beepOnce.gs then sudo ./beepOnce
10:33:48 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.glasgow.user/22065/ :)
10:33:55 <byorgey> OverloadedLists -- i.e. something that just lets you interpret list literals differently -- doesn't sound all that useful to me.
10:34:19 <byorgey> probably what you would really want is a typeclass that lets you reinterpret list operations.
10:34:24 <JoeyA> byorgey: But it would be tremendously useful for pattern matching.
10:34:43 <byorgey> JoeyA: would it?  does OverloadedStrings give you pattern matching?
10:34:52 <rwbarton> i think so?
10:34:55 <b_jonas> how would that work?
10:34:56 <JoeyA> "str"
10:34:56 <rwbarton> like Num/Eq
10:34:59 <JoeyA> It gives you that
10:35:08 <byorgey> but only on literals, right?
10:35:22 <byorgey> i.e. you can't write  ('x':foo)
10:35:24 <monochrom> > "x" :: ByteString
10:35:24 <lambdabot>   Not in scope: type constructor or class `ByteString'
10:35:33 <byorgey> or even (x:xs)
10:35:34 <JoeyA> Right.  I suppose you'd have to overload cons.
10:35:36 <b_jonas> maybe you just want view patterns?
10:35:48 <b_jonas> or even double arrow view patterns (do we have those in ghc now?)
10:35:59 <byorgey> right. my point is, once you start going that route, there tends to be a lot of disagreement as to what exactly should go in such a type class.
10:36:03 <rwbarton> or you can use TH for fancy pattern matching stuff
10:36:04 <JoeyA> With a view pattern, I guess it would be uncons -> Just (x, xs)
10:36:12 <byorgey> see e.g. http://hackage.haskell.org/package/ListLike
10:37:05 <byorgey> though I certainly agree it could be useful.
10:38:35 <nomeata> sm: Hi. Would you mind making a new shelltestrunner release with updated build dependencies, in particular supporting test-framework 0.6?
10:38:38 <JoeyA> > let f (B.uncons -> Just (x, xs)) = B.cons x xs; f _ = B.empty in f "hello"
10:38:38 <lambdabot>   Not in scope: `B.uncons'Not in scope: `B.cons'Not in scope: `B.empty'
10:42:53 <plat0> If I "cabal update && cabal install yesod-platform" I get "cabal: The following packages are likely to be broken by the reinstalls:" and then a list of snap-related packages.  Can someone explain to me what this means and how I should get yesod?  This is with Debian's cabal-install 0.14.0-2.
10:44:42 <JoeyA> plat0: What happens if you use --solver=modular (I assume you have the new cabal-install)
10:45:20 <nschoe> What is the course of action for me when cabal gives me such an error message, with no more info: "language-c-0.4.2 failed during the configure step. The exception was: ExitFailure 1"?
10:45:36 <JoeyA> Oh wait, you do.  I skipped over the "This is with Debian's cabal-install 0.14.0-2".
10:45:58 <monochrom> this is a new check since cabal-install 0.14. see my http://www.vex.net/~trebla/haskell/sicp.xhtml#pigeon for what would happen if you were not stopped
10:46:00 <JoeyA> nschoe: Try installing that package by itself to see what happens.
10:46:06 <JoeyA> i.e. cabal install language-c-0.4.2
10:46:08 <Eduard_Munteanu> nschoe: look above, or cabal install -v. It might be missing some executable dependency.
10:46:14 <plat0> JoeyA: Do you mean "cabal install --solver=modular yesod-platform"?
10:46:18 <plat0> If so, same result.
10:46:24 <nschoe> JoeyA: This is what I did, and this is the error I get.
10:47:00 <Eduard_Munteanu> nschoe: cabal install -v language-c-0.4.2   and pastebin the result
10:47:06 <nschoe> JoeyA: Ho my bad, I did not see the "The program happy is required but it could not be found" sentence :/
10:47:08 <JoeyA> hpaste, not pastebin
10:47:18 <JoeyA> !pastebin
10:47:23 <Eduard_Munteanu> :P
10:47:24 <nschoe> Okay, I'll do that
10:47:25 <JoeyA> (isn't there a bot action for that?)
10:47:31 <Eduard_Munteanu> nschoe: no
10:47:36 <Eduard_Munteanu> Just install happy :)
10:47:59 <nschoe> Eduard_Munteanu: Obviously, I meant when (if?) I get a similar error with happy
10:48:03 <Eduard_Munteanu> @where paste
10:48:03 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
10:48:52 <plat0> To be honest I don't mind removing snap actually, but I don't know how to do that with cabal ...
10:49:12 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml#remove for how to remove packages
10:50:26 <plat0> OK I will try that, but would prefer yesod and snap to be installed at the same time if that's possible!
10:50:58 <JoeyA> Maybe just cabal install --force-reinstalls
10:51:02 <JoeyA> yesod-platform
10:51:32 <plat0> Yes I may just do that.  I wonder why it says it will break snap ..
10:51:43 <monochrom> this is a new check since cabal-install 0.14. see my http://www.vex.net/~trebla/haskell/sicp.xhtml#pigeon for what would happen if you were not stopped
10:51:57 <JoeyA> or take the nuclear option: cd .ghc; mv x86_64-linux-7.4.1 x86_64-linux-7.4.1-old (as in, install cabal packages from scratch)
10:52:53 <plat0> OK thanks monochrom
10:53:19 <plat0> JoeyA: will that make me a separate install of all the cabal files+
10:53:31 <monochrom> I recommend reading the whole article
10:53:39 <Nisstyre> Is there a better way of getting information about the filesystem size than parsing the command line output of "df" ?
10:53:52 <geekosaur> not really
10:53:55 <Nisstyre> drat
10:54:09 <geekosaur> no Haskell binding to the C API, probably because there isn't actually a single useful portable API
10:54:42 <monochrom> also, I am too lazy to check whether yesod and snap have a fundamental perpetual version war or just that your current setup has flaws
10:55:16 <geekosaur> even Unixlikes have 4 or 5 of them, although a not very useful POSIX interface exists
10:55:25 <Nisstyre> fair enough
10:55:36 <JoeyA> What about statvfs?
10:55:37 <geekosaur> "As standardized, portable applications cannot depend on these functions returning any valid information at all."
10:55:46 <geekosaur> quote from statvfs manpage
10:55:48 <Nisstyre> JoeyA: I couldn't find any Haskell library that has an interface to it
10:56:12 <Nisstyre> also as geekosaur just said it's unportable
10:56:26 <geekosaur> no, it's portable, it just doesnt reliably return any information
10:56:36 <Nisstyre> oh, okay
10:56:41 <geekosaur> portably useless :)
10:56:43 <Nisstyre> does that depend on your filesystem?
10:56:47 <rwbarton> to determine filesystem free space, create larger and larger files until you get a disk space exceeded error
10:57:55 <geekosaur> admittedly, it's a difficult problem.  OpenAFS and MSDFS are examples of filesystems where the statvfs model simply does not apply
11:00:43 <e98> I'm a haskell noob but wondered one thing while fixing a stupid bug in non-Haskell code
11:01:02 <e98> say you have a function which returns the extension of a file you pass in
11:01:27 <e98> and you're using it in a function where you want to - if needed - replace the extension with something else
11:01:34 <e98> and return a _new_ filename
11:01:59 <davean> even df doesn't do things like tell you how much space you can use
11:02:12 <Nisstyre> davean: that's true
11:02:34 <e98> can I make Haskell prevent stupid mistakes where I accidentally returned the file extension instead of the untouched original filename
11:02:47 <Nisstyre> e98: smart constructors maybe?
11:02:47 <geekosaur> none of the interfaces tell you whether the filesystem has a reserve or not, yeh
11:03:11 <e98> based on having distinct types for the getExtension function and this utility function being spec'ed to return a filename as a result
11:03:28 <Eduard_Munteanu> That doesn't really count as free space, though.
11:03:28 <monochrom> yes
11:03:47 <e98> Nisstyre: smart constructors?
11:03:53 <e98> monochrom: did you reply to me?
11:03:58 <monochrom> yes
11:03:59 <Nisstyre> http://www.haskell.org/haskellwiki/Smart_constructors
11:04:55 <e98> when I was writing that utility function I thought I should think about that little detail but as it's written blindly without testing due to it being called only for Windows
11:05:03 <e98> I forgot to check that
11:05:26 <geekosaur> Eduard_Munteanu, the problem is that some OSes *do* claim it is free space
11:05:43 <e98> and that function was actually returning the OtherExtension case but not the filename and OtherExtension erroneously
11:05:51 <geekosaur> there's a config toggle in the linux kernel, for example
11:06:17 <geekosaur> as to whether reserved space is reported or not; if it is reported, it's reported as free space
11:07:30 <e98> Nisstyre: so I cannot just spec getExtension's result with a type File.Extension and utilityFunction with return type File.Name
11:07:47 <e98> Nisstyre: although both may be (byte)string
11:08:08 <Nisstyre> e98: well, if you accidentally make the file extension not actually be a file extension, then there will be no type error
11:08:10 <monochrom> sure you can
11:08:13 <Nisstyre> because they're both byte strings or w/e
11:08:19 <Nisstyre> so use smart constructors
11:08:47 <monochrom> well, I guess I don't understand the question
11:08:50 <Nisstyre> e98: I have no idea what those types are though
11:09:32 <e98> monochrom: just using newtype to define an alias
11:09:40 <e98> and only use the aliases
11:09:47 <bgamari> I have heard that use of Data.Array is now frowned upon. Is this true?
11:09:49 <e98> even though the actual type is the same
11:09:50 <Nisstyre> e98: I don't think you'll be able to get compile time errors though
11:09:50 <monochrom> then yes newtype works
11:10:07 <bgamari> Data.Vector is now favored, I suppose?
11:10:08 <e98> Nisstyre: yes, that's the whole point, prevent being stupid or lazy
11:10:27 <Nisstyre> e98: where are you getting the file extensions from?
11:10:32 <Nisstyre> is there a function that parses a filename?
11:11:00 <e98> sorry this is not Haskell code, but I'm playing with Haskell
11:11:16 <e98> and wondered whether Haskell would have prevented that at compile time
11:11:26 <Nisstyre> I don't think it would, if I understand you correctly
11:11:30 <hpc> @src words
11:11:30 <lambdabot> words s = case dropWhile isSpace s of
11:11:30 <lambdabot>     "" -> []
11:11:30 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
11:11:45 <e98> so
11:12:24 <Nisstyre> e98: Haskell can prevent you from returning some other type than the file extension one at compile time though
11:12:29 <Cale> e98: It's possible to lean on the type system a bit to ensure that you don't make mistakes of that type, though filenames in Haskell are generally treated as strings.
11:12:40 <Nisstyre> but it can't prevent you from putting erroneous data in the right type
11:12:54 <Nisstyre> only at runtime
11:12:57 <e98> fileExt :: FileName -> FileExtension
11:12:58 <Cale> e98: (so the pre-existing stuff won't protect you there, but you could make it do so)
11:13:06 <Cale> right, you'd have something like that
11:13:11 <hpc> @let splitExts "" = []; splitExts s = case break (== '.') s of (ext, rest) -> ext : splitExts rest
11:13:12 <lambdabot>  Defined.
11:13:12 <e98> changeExt :: FileName -> FileName
11:13:20 <Cale> where FileExtension was a newtype, not just a synonym for String
11:13:30 <hpc> @let splitDirs "" = []; splitDirs s = case break (== '/') s of (ext, rest) -> ext : splitDirs rest
11:13:31 <lambdabot>  Defined.
11:14:00 <Nisstyre> e98: with a smart constructor you'd get that at runtime though, and you'd notice the errors pretty quickly
11:14:03 <e98> yeah, assuming it's all strings, newtype to make an alias (if that's the right name)
11:14:17 <hpc> -- hmm, something like that
11:14:41 <e98> changeExt would pattern match on fileExt filename
11:15:14 <e98> and GHC could prevent me accidentally return the result of filExt filename instead of a new filename of type FileName
11:15:21 <e98> while both are probably strings
11:15:48 <e98> Nisstyre: smart constructor reads like it's even more powerful
11:15:52 <iadicicco> :o
11:16:25 <e98> Nisstyre: but the bug I fixed was stupid and went in due to laziness and not having access to Windows and as the code works correctly on non-Windows
11:16:57 <e98> it was in the AnyOtherCatchAllExtension case
11:17:31 <e98> had accidentally returned that extension instead of original untouched filename
11:17:59 <Nisstyre> e98: if you had two separate types, one for filenames, and one for file extensions, then yes, that would be caught at compile time
11:18:22 <e98> Nisstyre: newtype enough although both are actually say String
11:18:55 <e98> Nisstyre: forgot the question mark
11:19:58 <Nisstyre> should be
11:20:17 <Nisstyre> http://www.haskell.org/haskellwiki/Newtype
11:20:57 <e98> monochrom: still think "yes should work", or is this a different scenario?
11:21:55 <newsham> > unfoldUntil null (second (drop 1) . break (== '/')) "/this/is/a/test"
11:21:57 <lambdabot>   ["","this","is","a","test"]
11:23:41 <Nisstyre> e98: actually you probably want to create your types using "data"
11:23:58 <e98> Nisstyre: because newtype is limited?
11:24:01 <Nisstyre> yeah
11:24:23 <e98> is there a Haskell idiomatic way to do this simple one
11:24:34 <e98> if I don't want to use smart ctors?
11:24:52 <e98> *another one
11:26:55 <e98> what comes after " act" in the channel topic string. it's corrupted here. unicode maybe.
11:27:50 <e98> Nisstyre: thanks
11:27:53 <e98> monochrom: thanks
11:29:07 <hpc> 14:28 -!- Topic for #haskell: ["Haskell Platform 2011.4: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.1: http://is.gd/vkWMMa ","Haskell News: http://reddit.com/r/haskell ","The Haskell
11:29:11 <hpc>           programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","admin/spam issues: #haskell-ops "]
11:29:22 <hpc> e98: i don't see " act" anywhere in the topic
11:29:29 * Nisstyre doesn't either
11:29:35 <e98> hmm
11:30:12 <e98> this one "#haskell_ that's used by most act" and then 3 characters that look incorrectly interpreted
11:30:29 <Nisstyre> that's weird
11:30:46 <e98> maybe not in the topic
11:30:48 <e98> but name?
11:30:58 <e98> it's printed when people join
11:31:15 <e98> "has joined #haskell_ that's used by most act"XXX
11:31:52 <newsham> try control-L
11:31:54 <hpc> kill your client and rejoin
11:31:57 <hpc> or that
11:35:00 <e98> hpc: so when monoc and looopy joined, didn't you see a string after "has joined "?
11:35:12 <monoc> no, I don't see anything of the form "has joined #haskell_ that's used by most act"
11:35:12 <e98> could it be irssi?
11:35:22 <Nisstyre> could be your terminal
11:35:31 <hpc> i see normal joins
11:35:50 <e98> what did you see as the join message for monoc?
11:40:27 <khayyim> "something :: IO ()" means that something returns nothing; it just performs side effects, yes? And "something :: IO String" would mean that something gets a String from IO, yes?
11:40:33 <looopy> ???
11:41:06 <e98> looopy: asking me?
11:41:39 <looopy> e98: no, more so testing my existence here. =P
11:41:40 <monochrom> I am not sure I want to commit to your exact wording, but let's just say yes
11:42:11 <ion> khayyim: something :: IO () results in (), something :: IO String results in a String upon execution.
11:42:26 <khayyim> ion, thanks, that makes sense.
11:42:34 <nexx> khayyim not exactly. It is a String in IO context. But it doesn't need to come from IO
11:42:42 <e98> looopy: I hereby approve your existence as a client in this channel. I cannot vouch for more than that
11:42:50 <looopy> sweet
11:43:23 <khayyim> nexx, What would be a String in IO context, that didn't come from IO?
11:43:47 <nexx> return "blup"
11:44:06 <khayyim> ah, of course
11:44:46 <e98> this must be my client somehow as part of the formatting of join messages
11:45:02 <e98> whatever it is, it's funny
11:45:45 <e98> I knew machines have a consciousness
11:46:16 <e98> but was expecting that to ride a bike in leather jackets while holding a shotgun
11:46:26 <e98> not printing corrupted chars here
11:47:06 <monochrom> I print corrupted chars all the time
11:48:37 <e98> monochrom: then please ask your mom for just punishment. that'll teach you
11:59:32 <e98> monochrom: hope that didn't offend you.
11:59:46 <e98> have to leave. thanks guys.
11:59:50 <monochrom> no, I took it as a joke
12:00:04 <e98> monochrom: then it be a joke
12:00:43 <e98> monochrom: that was also a joke
12:00:52 <monochrom> haha ok!
12:01:06 <monochrom> "this statement is a joke"...
12:02:31 <Philippa_> "This statement is neither true nor a joke"
12:03:01 <shergill> please refrain from making self-referential jokes -- signed godel, rolling in his grave
12:08:26 <newsham> "godel did not say this" -goedel
12:09:17 <shergill> hah
12:09:17 <mauke> Godel, Goedel, G√∂del, G√∏del
12:09:24 <shergill> +1
12:09:30 <DrSyzygy> G≈ìdel
12:09:32 <monochrom> hahaha
12:09:40 <DrSyzygy> if you're gonna be that way about it, might as well be complete. :-P
12:09:49 <mauke> G≈ëdel
12:09:53 <newsham> escher esher exur eshur
12:09:58 <mauke> esker
12:09:59 <newsham> bak
12:10:05 <newsham> bock
12:10:05 <DrSyzygy> mauke: Those hungarian accents?
12:10:12 <mauke> yes!
12:10:19 <monochrom> m√¥n√∂chr√∏m
12:10:21 <DrSyzygy> mauke: Do you have them on your keyboard, or did you just look up the right unicode?
12:10:28 <mauke> neither
12:10:31 <mauke> <Compose> = o
12:10:45 <DrSyzygy> right
12:10:57 <monochrom> same here, <compose> " o etc
12:11:00 <DrSyzygy> (I'd count "I have a compose key" as "they're on my keyboard)
12:11:40 <mauke> well, I do have immediate access to e.g. „Äå„Äç
12:11:46 <newsham> ?src (.)
12:11:47 <lambdabot> (f . g) x = f (g x)
12:11:47 <lambdabot> NB: In lambdabot,  (.) = fmap
12:12:07 <newsham> > (.) " o
12:12:09 <lambdabot>   <no location info>:
12:12:09 <lambdabot>      lexical error in string/character literal at end o...
12:16:48 <tazjin> Hm, can the precision of GHCi's +s be changed?
12:17:58 <shergill> +s ?
12:20:10 <jonaskoelker> I had a dream this night in which I wrote some haskell
12:20:18 <jonaskoelker> that was pretty surreal...
12:20:20 <sp3ctum> how did it end?
12:20:30 <jonaskoelker> in a fencing scene against the villain
12:20:33 <Taneb> I once had a dream where there was loads of lambda calculus floating around
12:20:37 <statusfailed> Is it possible to make CmdArgs allow command line syntax like this: `myProgram --option Value` instead of `myProgram --option=Value` ?
12:21:03 <jonaskoelker> though I'm not quite certain about the transition :D
12:21:44 <Taneb> Seeing as this was at a "party" with loud music and UV light, everyone assumed I was drunk
12:21:47 <Taneb> (which I wasn't)
12:22:13 <Taneb> (I was just really tired
12:22:16 <Taneb> )
12:22:36 <sp3ctum> Taneb, just out of curiosity, how did it appear on the outside
12:22:37 <jonaskoelker> do the quotes signify that you were not having a good time, or that you typically don't in those environments, or ...?
12:27:10 <Taneb> sp3ctum, I can find a photo, hang on
12:37:52 <Taneb> sp3ctum, that's me on the left: http://a7.sphotos.ak.fbcdn.net/hphotos-ak-ash4/431115_174406462672026_100003080204247_261971_527408504_n.jpg
12:38:05 <Taneb> With the bad hair and the periodic table shirt
12:39:13 <amiller> hey i've come up with a pair of monads i'm trying to identify
12:39:23 <amiller> it's supposed to encapsulate secure traversals of a hash structure like a merkle tree
12:39:31 <amiller> there are two modes, Record and Replay
12:40:07 <amiller> each of them defines a function getByHash :: h -> a   where h is the type of secure digests of a
12:41:26 <amiller> Record is a write-only state monad and it appends each 'a' you fetch to a list
12:41:39 <amiller> Replay takes in one of those lists, and it gives you back elements from it, but only if the hash is correct
12:45:35 <BMeph> amiller: That 'getByHash' function seems to imply that you're working with comonads, not monads.
12:46:46 <copumpkin> write-only state monad? you sure you don't want the writer monad?
12:48:24 <amiller> ah that's pretty interesting
12:48:44 <copumpkin> really depends if you have an associative op :)
12:51:25 <Philippa_> copumpkin: or one you're willing to treat as close enough, yeah
12:52:07 <Philippa_> the "close enough for my purposes" catch is one of the secret horrors of haskell code still, not least because there are fewer, more precise variations and so people are tempted to actually do it :-)
12:52:09 <Philippa_> (fast and loose!)
12:56:21 <raichoo> Hi, can anybody explain why defining type family kind signatures differ from GADT type signatures? http://pastebin.com/QybrfrnM
12:56:23 <mauke> The paste QybrfrnM has been copied to http://hpaste.org/68719
12:56:24 <copumpkin> but zomg
12:56:30 <copumpkin> it won't be a real monad if it isn't a real monoid
12:56:31 <copumpkin> ZOMG
12:56:40 <zomg> THE HORROR!
12:56:57 <khayyim> So when main returns (), does that mean it returns nothing at all, or is there more to "()"?
12:57:01 <copumpkin> raichoo: probably cause nobody thought of it. You should propose it on the trac :)
12:57:10 <mauke> @src ()
12:57:10 <lambdabot> data () = ()
12:57:22 <mauke> > length [(), (), ()]
12:57:23 <lambdabot>   3
12:57:37 <byorgey> raichoo: it's because there is a difference between indices and parameters.
12:58:04 <byorgey> raichoo: with  type family Plus :: Nat -> Nat -> Nat  you wouldn't be able to pattern-match on the first two type arguments.
12:58:47 <raichoo> byorgey: Where can I read up more about indices and parameters in depth?
12:59:09 <byorgey> the difference is important because type families must be fully applied -- but only to their indices.
12:59:37 <byorgey> raichoo: about the concept in general, or about this particular corner of type families?
13:00:28 <raichoo> byorgey: tbh I don't know the difference between indices and parameters. Blank spot on the map :)
13:00:56 <strager> khayyim: Yes; it's kind of like 'void' in C
13:00:57 <byorgey> raichoo: the difference is basically whether you are allowed to pattern-match on them.
13:01:04 <monochrom> there is nothing to ()
13:01:05 <strager> Except it's actually a value.
13:01:13 <strager> (and type)
13:01:20 <khayyim> So it is something. And that something is nothing.
13:01:30 <byorgey> you can do different things based on different values for an index.  But a definition is "parametric" in its parameters, i.e. it must behave uniformly for all values of the parameters
13:01:49 <strager> khayyim: It's one thing, and it doesn't really give you much information beyond that.
13:01:58 <monochrom> well, my "nothing" just means uninteresting
13:01:58 <byorgey> It's not nothing.  There is exactly one value of type (), which is also called ()
13:02:17 <byorgey> (one non-undefined value)
13:02:31 <byorgey> the fact that there is only one possible value means that it gives you no information.
13:02:48 <raichoo> byorgey: Do you have a source to read about the topic? I'd love to grok this stuff :)
13:03:08 <khayyim> So a "()" is sort of a "null"?
13:03:34 <monochrom> main is not confined to IO (). you can make it IO Int, IO (String -> Bool), etc.
13:03:35 <strager> If there was a "null" type which can only have "null" values, then yes.
13:04:21 <monochrom> I would refrain from "like", "sort of". you never know how other people misinterpret you
13:04:57 <khayyim> If main were IO Int, where would the result be sent?
13:05:07 <strager> It's ignored.
13:05:08 <monochrom> it would be ignored
13:05:21 <strager> Pretend the caller of main does something like: do { _ <- main }
13:05:27 <byorgey> raichoo: hmm, let me think... most of the sources I know of are rather high-level, since this index/parameter distinction is sort of the tip of a large iceberg (called "parametricity").
13:05:51 <khayyim> Why use anything but IO () if it'll just be ignored?
13:05:57 <byorgey> raichoo: although the basic idea itself is not difficult.
13:06:24 <monochrom> to give you more freedom
13:06:46 <khayyim> Ah
13:07:03 <byorgey> raichoo: perhaps try reading the Wikipedia page on parametricity (though I can't vouch for the quality, I haven't looked at it)
13:07:11 <raichoo> byorgey: Just throw it at me if you like, I can take a headache :) The more I can learn the better.
13:07:25 <strager> Interesting; if I do: main :: IO Int; main = return 2;  runghc prints "2"
13:07:31 <raichoo> byorgey: Thank you :)
13:07:41 <monochrom> hrm, that's bad
13:07:44 <byorgey> raichoo: the index/parameter distinction also comes up (and is quite important) in dependently typed languages like Agda and Coq
13:08:12 <strager> If I do: main :: IO Int; main = return undefined; // undefined is printed, but with main :: IO (), undefined is not printed
13:08:45 <strager> And if main :: IO (Int -> Int), undefined is not printed.  So I think GHC assumes that, if it is an instance of Show, it should be shown, else ignored.
13:08:50 <monochrom> well, I suppose runghc is trying to be nice, too nice
13:08:56 <strager> Yeah ;P
13:09:24 <strager> If I ghc --make, the return value is unused.
13:09:29 <strager> So I guess it is runghc.
13:09:42 <raichoo> byorgey: Ok, I guess reading some Agda docs should be a good starting point.
13:09:43 <monochrom> runghc is not too far from ghci in many aspects
13:09:51 <byorgey> raichoo: sure
13:09:59 <strager>        runghc is considered a non-interactive interpreter and part of The Glasgow Haskell Compiler.  runghc is a compiler that
13:10:02 <strager>        automatically runs its results at the end.
13:10:11 <Peaker> strager, that's peculiar feature of runhaskell/runghc
13:10:47 <raichoo> byorgey: Great, thanks. The wikipedia article is kind of a stub. I want more and in depth. Agda it is then :)
13:10:48 <Peaker> I always use    main :: IO ()    so I was also surprised when my value was printed out of nowhere once when I accidentally had a different type of main
13:11:13 <khayyim> Interesting. Makes sense.
13:11:29 <strager> Pretty sure that's non-standard though =]
13:11:38 <khayyim> Quite.
13:11:41 <byorgey> raichoo: ok =)
13:11:54 <rwbarton> I wonder what it does with IO a, or Show a => IO a
13:12:13 <mauke> IO (IO ())
13:12:43 <shachaf> Peaker: That's a GHC bug.
13:12:45 <monochrom> since it has all type information, it can do as type-case on "is it ()? is it a Show instance? ..."
13:13:07 <Peaker> shachaf, oh, I thought it was a "feature" :)
13:13:33 <khayyim> Now, I don't need the type signature for the program to work right, yes? E.g., 'main = putStrLn "Hello, world!"' It's just there to help the compiler, yes?
13:13:42 <shachaf> Peaker: This is a runghc thing, right?
13:13:46 <strager> khayyim: Often, but not always.
13:13:47 <Peaker> shachaf, yeah, or runhaskell
13:14:01 <strager> Sometimes a type signature is required.
13:14:02 <shachaf> Peaker: runghcing a program is like loading that program in ghci and typing "main".
13:14:12 <strager> Though I can't think of a case off the top of my head.  I have encountered such cases, though.
13:14:22 <rwbarton> can i write main :: String then?
13:14:23 <shachaf> So if its type is IO () or IO a where a isn't Show, it won't print anything; otherwise it'll print a.
13:14:24 <khayyim> strager: So in other words, always write out the type signature?
13:14:27 <Peaker> khayyim, if you don't use any advanced GHC extensions, then you only have to tell the compiler what the types are when it is really impossible to deduce (assuming an open world, at least)
13:15:10 <khayyim> Peaker: thanks, comprehensive answer
13:15:16 <strager> khayyim: I always write out signatures for top-level identifiers.  There's a GHC option to warn (or error) if one isn't present.
13:15:32 <Peaker> khayyim, for example,  if you write:  show . read    then the compiler has no idea what's the type in between there, and there's no way to tell
13:15:49 <mauke> the other one is polymorphic recursion
13:16:03 <Peaker> mauke, hey, there's a little annoying warning when using your TH printf
13:16:20 <mauke> what is it?
13:16:39 <khayyim> Thanks all, that clears a few things up
13:16:41 <Peaker> mauke, the "\a -> ... a ..." seems to cause shadowing of "a", if you use printf on more than one fmt arg
13:16:45 <RylandAlmanza> How can I turn program arguments into integers instead of strings?
13:17:00 <mauke> read
13:17:12 <shachaf> length
13:17:26 <mauke> > 3 "foo"
13:17:27 <lambdabot>   3
13:17:42 <mietek> I still don't understand why GHC includes Cabal, but not cabal-install.
13:18:07 <Peaker> mauke, it's so weird -- even if I change your code to explicitly use "newName" and dump the splice which shows it uses different names, I still get the GHC warning in the use-site that there's shadowing
13:19:44 <hpaste> Peaker pasted ‚Äúprintf-th-shadowing‚Äù at http://hpaste.org/68720
13:19:54 <Peaker> mauke, http://hpaste.org/68720 <-- very weird!
13:20:13 <mauke> Peaker: how are you compiling?
13:20:33 <hpaste> Peaker annotated ‚Äúprintf-th-shadowing‚Äù with ‚Äúprintf-th-shadowing (annotation)‚Äù at http://hpaste.org/68720#a68721
13:20:52 <geekosaur> mietek, because cabal-install is developed separately.  there are already oddnesses that pop up because some other separately developed things are also bundled with ghc out of necessity
13:21:02 <Peaker> mauke, with pragma for -O2 -Wall and LANGUAGE TemplateHaskell, ghc --make
13:21:20 <strager> > map read ["1", "3234", "-24"] :: [Int]
13:21:21 <lambdabot>   [1,3234,-24]
13:21:24 <strager> RylandAlmanza: ^
13:21:31 <hpaste> Peaker annotated ‚Äúprintf-th-shadowing‚Äù with ‚Äúprintf-th-shadowing (annotation) (annotation)‚Äù at http://hpaste.org/68720#a68722
13:21:48 <RylandAlmanza> ooh, thanks, strager
13:22:02 <RylandAlmanza> > read "3"
13:22:03 <lambdabot>   *Exception: Prelude.read: no parse
13:22:14 <RylandAlmanza> map read ["3"]
13:22:17 <RylandAlmanza> > map read ["3"]
13:22:18 <lambdabot>   [*Exception: Prelude.read: no parse
13:22:32 <mauke> Peaker: no warnings here
13:22:38 <RylandAlmanza> Oh, I know what I did
13:22:42 <Peaker> The Glorious Glasgow Haskell Compilation System, version 7.4.1
13:22:47 <Peaker> mauke, which version are you using?
13:22:53 <RylandAlmanza> I'll use ghci so I don't have to spam the channel. Thanks again, strager
13:22:58 <mauke> Peaker: 7.0.4
13:23:05 <Peaker> I think TH triggers very weird GHC behaviors
13:23:24 <strager> RylandAlmanza: You need to specify the target type somehow.  In a larger program it probably can be inferred, but with simply `read "3"` it's ambiguous.
13:23:59 <strager> RylandAlmanza: e.g. do you want an Int back, or a Double?  Or maybe a String or Char?  Or a list of maps from Int to Bool?
13:25:05 <jonaskoelker> does the latter have read syntax?  Would that be "\_ -> True"?
13:25:37 <mauke> > M.fromList [(42, True)]
13:25:38 <lambdabot>   fromList [(42,True)]
13:25:50 <strager> > read "[fromList [(42,True)]]" :: [Map Int Bool]
13:25:51 <lambdabot>   Not in scope: type constructor or class `Map'
13:25:55 <jonaskoelker> oh _map_ maps :)
13:25:55 <strager> > read "[fromList [(42,True)]]" :: [Data.Map Int Bool]
13:25:57 <lambdabot>   Not in scope: type constructor or class `Data.Map'
13:26:00 <strager> > read "[fromList [(42,True)]]" :: [M.Map Int Bool]
13:26:01 <lambdabot>   [fromList [(42,True)]]
13:26:02 <strager> derp.
13:26:18 <jonaskoelker> dependent extensible record proposal?
13:26:27 <strager> No.
13:26:29 <strager> Just derp.
13:26:43 * jonaskoelker says Nothing
13:27:15 * strager says Just "ok"
13:27:15 <Taneb> Does -fdefer-type-errors allow infinite types?
13:28:03 <Taneb> :t let omega x = x x in omega omega
13:28:04 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
13:28:04 <lambdabot>     Probable cause: `x' is applied to too many arguments
13:28:04 <lambdabot>     In the expression: x x
13:28:46 <jonaskoelker> ?src fix
13:28:46 <lambdabot> fix f = let x = f x in x
13:29:00 <Taneb> NOT QUITE THE SAME THING
13:29:09 <jonaskoelker> I know :)
13:29:34 <Taneb> Although@
13:29:37 <Taneb> :t fix fix
13:29:39 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
13:29:39 <lambdabot>     Probable cause: `fix' is applied to too many arguments
13:29:39 <lambdabot>     In the first argument of `fix', namely `fix'
13:29:56 * jonaskoelker has a sploding brain at 'fix fix'
13:30:00 * timthelion tried to install openSUSE. :(
13:30:35 <Taneb> jonaskoelker, it would not do anything special
13:31:02 <jonaskoelker> any fixed point of `fix' must satisfy... returning itself on itself, so uhm... the identity?
13:31:29 <Taneb> jonaskoelker, only if your implementation of "fix" is running on a machine that is super-turing complete
13:31:34 <jonaskoelker> ^_^
13:32:24 <Taneb> (That is, equivalent to the machine hypothesised by Super-Turing)
13:32:31 <jonaskoelker> :D
13:32:43 <sausage2> aavogt: stop PMing me
13:32:57 <sausage2> I wont do your haskell homework
13:33:04 <geekosaur> ...waaaa?
13:33:06 <jonaskoelker> sausage2: "/ignore aavogt"?
13:33:20 <Taneb> I wish /I/ got Haskell homework
13:33:33 <raichoo> byorgey: One last question. What am I using in the type family example? parameters or indices?
13:33:34 <timthelion> Do any haskell people use suse?
13:33:36 <chris2> Taneb: want to do mine? :)
13:33:44 <geekosaur> aavogt appears to be who he normally is, and would not be asking people to do his homework
13:33:51 <Taneb> chris2, not really, I've got enough Latin to do already
13:34:07 <sausage2> geekosaur: doesnt matter, he shouldnt PM me anyway
13:34:14 <chris2> good i'm done with latin, then :P
13:35:05 <shachaf> sausage2: Given that aavogt has been in this channel since at least 2009, and I've never seen you in here before, it seems like something suspicious is going on.
13:35:11 <geekosaur> ^^
13:35:24 <nand`> Does anybody know a good monospace/bitmap font that includes stuff like ‚àÄ‚àÉ‚àà‚â†?
13:35:25 <sausage2> shachaf: please stay within the channel topic. Thank you.
13:35:34 <geekosaur> @where ops
13:35:35 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
13:35:41 <nand`> while those symbols do render for me, they're hardly recognizable; mainly because they're being downscaled horribly
13:36:13 <jonaskoelker> nand`: the xterm font, -misc-fixed-medium-r-semicondensed--13-*-*-*-*-*-iso10646-1
13:36:13 <nand`> I essentially can't work with Agda whatsoever because all of those symbols result in unreadable gibberish in my terminal
13:36:48 <nand`> (meanwhile, other symbols like √ó√∑‚âà‚â§‚â•¬´¬ª¬¨Œª display fine)
13:37:47 <Taneb> nand`, try http://en.wikipedia.org/wiki/Monospace_(Unicode)
13:37:52 <Eduard_Munteanu> nand`: DejaVu Sans Mono is ok, although it doesn't have all Agda-related glyphs
13:37:57 <Cale> geekosaur: What's going on here?
13:38:13 <Yarou_> i wish people would PM me :(
13:39:31 <nand`> Eduard_Munteanu: I'll give it a try, thanks
13:40:05 <nand`> Taneb: does that go by any other names? my distro's repos doesn't have anything named ‚Äúmonospace‚Äù
13:40:15 <Eduard_Munteanu> I think there are a few fonts which have better coverage there, but I can't really stand bitmapped stuff like Unifont :)
13:41:05 <Taneb> nand`, it's installed by default on Ubuntu, I'll see if I can find it
13:42:13 <monochrom> I just use whatever font ubuntu chooses out of the box.
13:42:17 <nand`> Eduard_Munteanu: funny, I have unifont installed but it's not helping for those glyphs
13:42:27 <byorgey> raichoo: indices, since you are pattern-matching on them
13:42:42 <amiller> i'm trying now to do something like Hashable' but where the type of the digest is left as a parameter, rather than fixed to Int the way Data.Hashable is
13:42:45 <amiller> class Hashable h d where hash :: d -> h
13:42:46 <jonaskoelker> Cale: see pm
13:42:53 <Eduard_Munteanu> nand`: are you running Emacs in a terminal or X?
13:43:02 <amiller> i wonder if there's a simple way to do that, i'm stuck now because of some consequences of having two parameters in the class
13:43:06 <amiller> simpler*
13:43:09 <byorgey> raichoo: also, in the kind signature, indices come before the :: and parameters come after
13:43:21 <nand`> Eduard_Munteanu: I'm not actually running emacs, I've dumped those symbols into a file and I'm inspecting them using ‚Äúcat‚Äù in my terminal
13:43:36 <nand`> Eduard_Munteanu: I need this to work in the terminal though, so ‚Äújust use X‚Äù isn't an option
13:43:36 <raichoo> byorgey: Thanks, from here on I can find my way :) That helped me a lot.
13:43:37 <Eduard_Munteanu> Hm.
13:43:44 <monochrom> "monospace" on ubuntu is a virtual font, i.e., a disjoint union of many fonts. for ‚àÄ it happens to be DejaVu Sans Mono
13:44:05 <Eduard_Munteanu> Hm, I didn't know that.
13:44:11 <Taneb> Neither did I
13:44:14 <nand`> I've installed and enabled DejaVu Sans Mono; the symbol still looks atrocious (though slightly less atrocious than before)
13:44:24 <sausage2> So how do I print the text "gee-k-o-saur"?
13:44:43 --- mode: ChanServ set +o monochrom
13:44:45 --- mode: monochrom set +b *!*@c83-250-91-84.bredband.comhem.se
13:44:45 --- kick: sausage2 was kicked by monochrom (sausage2)
13:45:16 <byorgey> raichoo: the same before/after the colon thing happens in Coq and Agda too.
13:45:23 <monochrom> s/disjoint union/biased union/
13:45:34 <nand`> I can't find DejaVu Sans Mono in xfontsel; what's the foundry name for it?
13:45:47 <byorgey> raichoo: note also I got the terminology from Agda; you might not actually find the terms "index/parameter" used in the GHC manual etc., but the concept is the same
13:46:11 <geeksaurious> Hi. How do I print the text "gzz-saurious"?
13:46:16 <monochrom> I don't know, and I don't want to know. probably non-existent in the xfontsel scheme
13:46:28 <raichoo> byorgey: Any paper you can recommend?
13:46:30 <Eduard_Munteanu> Not sure, but you could use xft fonts.
13:46:39 --- mode: monochrom set +b *!53fa5b54@*
13:46:47 --- kick: geeksaurious was kicked by monochrom (geeksaurious)
13:46:54 <byorgey> raichoo: not off the top of my head, it's one of those things I picked up from who knows where (probably multiple places)
13:47:06 <raichoo> byorgey: ^^
13:47:24 <Eduard_Munteanu> nand`: if this is urxvt, add something like   URxvt.font:             xft:DejaVu Sans Mono-11:antialiasing=true,spacing=mono       to .Xdefaults
13:47:46 <shachaf> thanks monochrom. thonochrom
13:47:59 <monochrom> what is the thono part?
13:48:19 <ion> th(anks, m)onochrom
13:48:19 <dmwit> monochrom: It's from a British comedy sketch.
13:48:32 <monochrom> haha
13:48:47 <dmwit> http://www.youtube.com/watch?v=9jtU9BbReQk
13:48:50 <ion> If you haven‚Äôt watched Look Around You, you‚Äôre in for a treat.
13:49:34 --- mode: monochrom set +b *!25021c9d@*
13:49:38 --- kick: Gksszzurr was kicked by monochrom (Gksszzurr)
13:49:45 <dmwit> As long as we're off-topic for a moment: I'm quite proud of myself. I managed to figure out what "yrlnry" stands for all by myself just using Google.
13:50:15 <Taneb> dmwit, enlighten us?
13:50:24 <mauke> dmwit: using google is cheating :-)
13:50:37 <ion> The nickname of some dude?
13:50:55 <geekosaur> a user often in here
13:50:57 <dmwit> It's the nick of "some dude", yeah, and also is a one-key-off typo for telnet.
13:51:06 <ion> ah
13:51:09 <mietek> ?seen apfelmus
13:51:09 <lambdabot> Unknown command, try @list
13:51:14 <monochrom> oh, that's neat
13:51:28 <dmwit> monochrom: Right??
13:51:39 <ion> snqur: Right.
13:51:57 --- mode: ChanServ set +o mauke
13:51:57 --- mode: mauke set +b $a:sausage2
13:52:04 <dmwit> =)
13:52:22 <shachaf> Why are you asking monochrom?
13:52:27 <monochrom> something doesn't fit
13:53:04 <palmfrond> can someone type a msg to me in chan? like say my nick
13:53:17 <monochrom> your nick
13:53:23 <mauke> my nick
13:53:23 <ion> my nick
13:53:24 <Saizan> byorgey: given "type family F a :: * -> *", shouldn't F a b ~ F a c imply b ~ c ?
13:53:28 <mauke> palmfrond: ok
13:53:35 <palmfrond> hrm, didn't makea sound
13:53:43 <mietek> http://code.haskell.org/lambdabot/COMMANDS says seen provides: users seen
13:53:45 <mietek> @users
13:53:45 <lambdabot> Unknown command, try @list
13:53:46 <palmfrond> i wonder which Textual alert setting this is, when someone says your nick in a chan
13:53:54 <mietek> @seen
13:53:55 <lambdabot> Unknown command, try @list
13:53:57 --- mode: mauke set -o mauke
13:54:03 <mietek> *sigh*
13:54:07 <shachaf> mietek: Yes, it's out of date.
13:54:15 --- mode: monochrom set -b *!*@c83-250-91-84.bredband.comhem.se
13:54:32 <mietek> shachaf: so lambdabot doesn't provide seen any more?
13:54:33 <palmfrond> mauke, once more please?
13:54:45 <Taneb> palmfrond, can I try?
13:54:52 <shachaf> palmfrond: There are probably better channels for that. :-)
13:54:56 <palmfrond> aha ok works, thanks guys
13:55:05 <palmfrond> no other channel is as kind
13:55:11 <palmfrond> maybe #postgresql
13:55:25 <dmwit> Saizan: Probably we need two kinds of (->) kinds, injective and non-injective ones.
13:55:27 <mauke> mietek: preflex does
13:55:33 <monochrom> something doesn't fit. in "telnet" -> "yrlnry", I'm wondering why n does not go to m
13:55:35 <dmwit> Saizan: I think that would probably be a useful extension, but it's not one GHC has just now.
13:55:45 <dmwit> monochrom: it's typed with the other hand
13:56:06 <geekosaur> monochrom, it's only off by one woth the left hand
13:56:07 <ion> I type y with the index finger of the right hand, though. yhn are aligned.
13:56:17 <mietek> mauke: oh, thanks.
13:56:19 <shachaf> ion: Sure, but he wasn't trying to type 'y'. :-)
13:56:34 <ion> Heh, true
13:56:38 <palmfrond> dmwit, what are your ideas for splitting kinds into those two?
13:56:42 <ion> Didn‚Äôt think this all the way through.
13:56:42 <monochrom> God, that's ugly
13:57:07 <dmwit> palmfrond: I haven't thought deeper than the one sentence I said above.
13:57:16 <palmfrond> oh
13:57:23 <dmwit> palmfrond: Though I think there are people at UPenn who are thinking deeper. =)
13:57:28 <byorgey> I have, and it gets complicated =)
13:57:36 <cleardance> > product [1..10]
13:57:37 <lambdabot>   3628800
13:57:38 <palmfrond> byorgey, please go on
13:58:00 <byorgey> palmfrond: sorry, I'd rather not page all that back into my head at this point =)
13:58:17 <palmfrond> haha, i understand :)
13:58:18 <mietek> Does anyone know if there's a more up-to-date solution to this question now? http://stackoverflow.com/questions/5868916/haskell-graphics-library-that-works-in-ghci-on-macos-x
13:58:24 <geekosaur> Saizan, re type families, if you assume that ghc helpfully reminds you that "type families are not injective"
13:58:35 <nand`> Eduard_Munteanu: switching to xft actually fixed most of those symbols except for ‚â† which remains completely broken; I'm guessing not even DejaVu Sans Mono includes this
13:58:38 <palmfrond> could it be said blocks are the units of a page?
13:58:40 <geekosaur> (I think... I may be confused)
13:59:05 <mauke> my DejaVu Sans Mono has ‚â†
13:59:13 <monochrom> ‚â† is in DejaVu San Mono just fine
13:59:15 <nand`> odd
13:59:30 <nand`> ah, it displays fine using unifont; I guess I'll just set up my terminal to use that after my default font
13:59:31 <palmfrond> that's a long language name :)
13:59:33 <monochrom> just dump ubuntu on your computer and never customize it again
13:59:38 <dmwit> mietek: OpenGL and Gtk work on MacOS; what else could you possibly need? =)
13:59:47 <dmwit> mietek: (cairo is a part of Gtk and quite nice for 2D graphics)
14:00:09 <jjl_> hi folks. i'm trying to achieve high performance with SMP and concurrency and i'm wondering where i could read about it in a way that doesn't make me feel stupid for not understanding advanced haskell
14:00:19 <BMeph> monochrom: Interesting that you commented on the 'n', but not the 'l'... :)
14:00:47 <monochrom> "l" I understand, it would be shifted to ":" which is not nice for irc nick
14:01:35 <mietek> dmwit: using the cairo package?
14:01:53 <dmwit> yes
14:02:19 <dmwit> Actually, I hear getting gtk2hs built on MacOS is somewhat tricky; you might want to look at the instructions on the wiki.
14:02:37 <mietek> I think that's been improved and actually works now.
14:02:41 <dmwit> http://www.haskell.org/haskellwiki/Gtk2Hs/Mac
14:03:02 <mietek> Yes, thanks.
14:03:34 <Saizan> geekosaur: my question wasn't about that
14:04:13 <Saizan> geekosaur: because i'm asking it to figure out that they are in fact injective in their parameters
14:05:59 <bgamari> Anyone know of a function Monad m => (a -> m a) -> a -> m a
14:06:06 <Cale> bgamari: id
14:06:06 <dmwit> id
14:06:08 <bgamari> which iterates an action recursively
14:06:08 <Taneb> id
14:06:26 <dmwit> :t many
14:06:27 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
14:06:37 <dmwit> Related: how should it know when to stop?
14:06:40 <bgamari> hmm, or perhaps with a cound
14:06:44 <shachaf> bgamari: Maybe you mean (a -> m a) -> m a?
14:06:45 <bgamari> iteration count*
14:06:47 <dmwit> ?hackage monad-loop
14:06:48 <lambdabot> http://hackage.haskell.org/package/monad-loop
14:06:48 <shachaf> @ty mfix
14:06:49 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
14:06:57 <dmwit> eh
14:07:00 <dmwit> ?hackage monad-loops
14:07:00 <lambdabot> http://hackage.haskell.org/package/monad-loops
14:07:34 <bgamari> iterateWhile looks good
14:07:35 <bgamari> thanks!
14:10:21 <bgamari> Alright, new request
14:10:34 <bgamari> Monad m => Int -> (a -> m a) -> a -> m a
14:11:00 <monochrom> I would write it myself
14:11:12 <bgamari> I guess concatM with replicate would work
14:12:44 <zomg> bgamari: you know you can do hoogle searches with type signatures like that =)
14:14:45 <strager> Is that replicate+fold?
14:14:57 <strager> Well it can't be fold; nevermind
14:15:03 <dmwit> Sure it can.
14:15:13 <strager> What good is fold with only one argument?  =]
14:15:20 <dmwit> :t \n f -> foldr (>=>) return (replicate n f)
14:15:21 <lambdabot> forall (m :: * -> *) c. (Monad m) => Int -> (c -> m c) -> c -> m c
14:15:22 <strager> oh right, monads; nevermind again!
14:16:10 <dmwit> :t \n f a -> foldl (>>=) a (replicate n f)
14:16:12 <lambdabot> forall (m :: * -> *) b. (Monad m) => Int -> (b -> m b) -> m b -> m b
14:16:32 <dmwit> :t \n f a -> foldl (>>=) (return a) (replicate n f)
14:16:33 <lambdabot> forall (m :: * -> *) b. (Monad m) => Int -> (b -> m b) -> b -> m b
14:21:11 <jmcarthur> :t Data.Foldable.fold
14:21:12 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
14:23:08 <Taneb> Can someone explain what ~'s in types mean?
14:23:37 <timthelion> I'm confused, the lastest GHC is 7.4.1, which is incompatible with haskell98, and yet the latest haskell platform is ghc 7.0.4(haskell98)
14:23:40 <timthelion> ?
14:25:37 <td123> timthelion: platform provides a stable environment, ghc doesn't wait for a new platform to release a new stable version
14:26:57 <noam> if i have a strict ST function `f :: ... -> ST s (Set Int)` that returns a set, and somewhere i want to only check whether the set is empty without computing it all, can i use strictToLazyST, or do i have to define `f` using lazy ST?
14:27:16 <timthelion> hm, I was on arch linux, developing on arch, and writing 7.4.1 compatible code.  Now I decided to try Suse, but it seems 7.4.1 doesn't work on Suse(cannot even build xmonad with the ghc from the unstable repos) I guess I'll just go back to Arching.
14:27:43 <geekosaur> timthelion, most platforms stuck with the stable platform, arch and now ubuntu bolted for the bleeding edge
14:28:40 * timthelion has considered ubuntu to be as evil as M$ after seing that unity doesn't build elsewhere.
14:28:55 <timthelion> I guess I'll just have to go back to arch :(
14:29:17 <td123> fyi, unity builds on arch.. you literally need to have 80 patched packages for it to work properly though :P
14:30:04 <timthelion> td123: :) you have to duplicate install many many libraries,  Basically you have to install a broken ubuntu into arch...
14:31:12 <td123> yup, in no way am i condoning the practice :)
14:31:41 <timthelion> I just don't want to have to back convert my code to haskell98.  Seems like a waste of time
14:35:31 <Mathnerd314> Taneb: example?
14:35:42 <Taneb> idQMO :: x ~ z => y
14:35:48 <Taneb> (from Prelude.Generalize)
14:36:24 <Taneb> Actually, I think I've got a few things to learn first, and it's getting late.
14:36:32 <Taneb> I'll start this journey in the morning.
14:36:34 <Taneb> Goodnight!
14:47:44 <xil> hi everyone. I hope this isn't inappropriate but I'm wondering if anyone would mind giving me some feedback on coding practices. I have a couple functions and a record data type. I tried commenting some to explain what's going on. Would anyone mind giving me some feedback on how it's coded? http://hpaste.org/68724
14:49:11 <hpc> xil: looks good
14:49:27 <lpsmith> xil, that's what this channel is for!   But I don't know much about neural nets,  so I personally can't really help you
14:49:33 <hpc> your where clauses are a bit funky
14:49:50 <xil> hpc:  that's the kind of thing I want feedback on. Can you tell me more?
14:49:56 <hpc> typically what people will do is half-indent the 'where' keyword, then do a single indent for the rest of it
14:50:49 <hpc> also, you should curry (?) and rename it (??)
14:50:59 <xil> lpsmith: this isn't that complex. I explain a good deal in the comments. It's basically a graph doing a breadth first search
14:51:10 <hpc> hmm, apparently (??) isn't defined anywhere
14:51:14 <hpc> name is probably fine then
14:51:41 <hpc> actually...
14:51:51 <hpc> (?) = if
14:51:53 <lpsmith> xil,  well I've been following the ml-class,  but I've been busy this week and haven't gotten to the most recent lectures.
14:51:58 <hpc> (if you could do such a thing with syntax)
14:52:05 <lpsmith> (err,  neural net lectures)
14:52:18 <xil> hpc: curry it?
14:52:37 <xil> hpc: oh get rid of the tuple?
14:52:49 <hpc> xil: replace it with if-then-else, actually
14:52:56 <xil> why's that?
14:53:01 <hpc> because that's what it is equal to
14:53:13 <xil> I know, but it's a convenience to avoid using if-then-elses
14:53:15 <hpc> (?) p t f = if p then t else f
14:53:17 <hpc> ah
14:53:18 <xil> I don't like the formatting of them
14:53:34 <xil> oh just redefine it
14:53:40 <xil> yeah I can do that
14:53:47 <xil> but why curry it?
14:53:50 <hpc> still, it looks funny
14:54:08 <xil> the reason I have it with the tuple is because it makes it much more clear when nesting and such
14:54:09 <lpsmith> ehh, I don't think there is any problem with the ?
14:54:10 <hpc> xil: uncurried functions look strange in haskell
14:54:35 <lpsmith> though you might consider setting an infixl or infixr at an appropriate priority level for it
14:54:44 <xil> makes it easier to format too, because I don't need to put parentheses around each argument when the arguments are more complex
14:55:00 <d-snp> I am being tackled by the awkward squad :(
14:55:04 <hpc> hmm, listen to lpsmith
14:55:06 <xil> lpsmith: I've been avoiding that out of ignorance of the various fixities of different common functions
14:55:14 <lpsmith> e.g.  infix 2 ?   or something,  I guess there isn't really an association that makes sense
14:55:39 <jonaskoelker> right-assoc if curried, I'd think...
14:55:40 <lpsmith> xil,  you can look up the fixities in ghci with the :info command
14:55:45 <xil> with the tuples I didn't need to worry about fixity. That's why I have it that way
14:55:45 <lpsmith> :info ++
14:55:46 <jonaskoelker> from reading a rant about how PHP gets it  wrong :D
14:55:56 <xil> oh yeah, but there are a lot of functions
14:56:02 <xil> would take time to figure out what fixity I want
14:56:21 <lpsmith> fair enough :)
14:56:50 <xil> but what about the rest of the code. Specifically I feel like the way I handle the record in modifyNeuron looks weird
14:56:54 <xil> certainly feels weird
14:58:06 <xil> hpc: can you show me a small example of that thing you said about the where clause indentation?
14:59:21 <jonaskoelker> here's a fun idea: [p ? t = \f -> if p then t else f], then use it as (p ? t $ f)
15:00:05 <xil> jonaskoelker: the problem is when <t> is a more complex expression with infix operators
15:00:16 <jonaskoelker> hence the fixity declaration :)
15:00:31 <xil> that's why I have the tuple. <t> can be literally anything
15:00:38 <xil> well yes, but I need to be mindful of the fixity
15:00:44 <xil> also can't use $ in the expression
15:00:59 <xil> but with the tuple I can put literally anything in there
15:01:36 <jonaskoelker> fair point
15:02:15 <jonaskoelker> ... you could invent a new synonym for $, e.g. $: (trying to look like c/java/...)
15:02:16 <xil> I'm sure that when I get more knowledgeable I'll curry it and give it a fixity declaration as appropriate
15:02:38 <jonaskoelker> I'm not sure my solution is better than yours or vice versa, FWIW
15:04:31 <xil> yeah, discussion is good, I totally agree
15:04:51 <hpc> http://hackage.haskell.org/trac/ghc/ticket/728 -- want
15:05:40 <c_wraith> that milestone is amusing
15:06:20 <jonaskoelker> xil, you may want to look at http://www.haskell.org/onlinereport/decls.html#prelude-fixities
15:08:07 <sajith_>  
15:09:17 <hpc> http://hackage.haskell.org/trac/ghc/ticket/1555 -- best bug ever
15:10:43 <monochrom> haha that's neat
15:11:33 <dsfox> Why is it that I can runQ [d|foo = \ extra tid t -> () |] -> [ValD (VarP foo_0) (NormalB (LamE [VarP extra_1,VarP tid_2,VarP t_3] (ConE GHC.Tuple.()))) []]
15:11:38 <dsfox> but I cannot runQ [d| $(varP (mkName "foo")) = \ extra tid t -> () |]
15:15:30 --- mode: monochrom set -bb *!25021c9d@* *!53fa5b54@*
15:15:36 --- mode: monochrom set -o monochrom
15:18:35 <jonaskoelker> would you people be interested in doing a code review a la xil's on my code?
15:22:20 <hpaste> Jonas pasted ‚Äúdice roller‚Äù at http://hpaste.org/68725
15:24:31 <dmwit> Perhaps codereview.stackexchange.com.
15:24:46 <dmwit> Not sure how many people want to just sit down and read 1000 lines of code.
15:25:33 <jonaskoelker> fair point ^_^
15:27:22 <hpaste> Jonas pasted ‚Äú136 lines of dice roller‚Äù at http://hpaste.org/68726
15:27:32 <jonaskoelker> more reasonable? :)
15:28:56 <dmwit> pffft, everyone knows 0^0 is 1.
15:29:32 <lpsmith> Ok,  what's the verdict on importing GHC.IO.Exception?   It's not visible in the haddocks,  yet it appears to be the only way to manage certain kinds of exceptions...
15:29:35 <hpc> huh, data families look interesting
15:29:43 <jonaskoelker> my irony-meter says "ambiguous" on that one :)
15:30:08 <dmwit> haha only serious
15:30:11 <dmwit> 0^0 is 1
15:30:50 <dmwit> If we're critiquing style, your names are aweful.
15:30:54 <dmwit> awful
15:30:55 <Cale> But isn't the number of functions from the empty set to itself undefined? ;)
15:30:58 <Cale> lol
15:32:05 <jonaskoelker> :)
15:32:06 <dmwit> You might like MonadRandom.
15:32:16 <dmwit> ?hackage MonadRandom
15:32:17 <lambdabot> http://hackage.haskell.org/package/MonadRandom
15:32:25 <jonaskoelker> how are my names bad?
15:32:35 <dmwit> ll? ls? ss? rec1? rec2?
15:32:38 <dmwit> WTF are these things?
15:32:53 <dmwit> lll, sss, sssg, ssl, sll...
15:33:03 <jonaskoelker> recur[n-args], l/s = list/scalar, g for guard
15:33:04 <jonaskoelker> ^_^
15:33:46 <dmwit> lll, three lists according to the thing you just said, takes a function and two values (not necessarily lists).
15:33:49 <dmwit> Your naming is awful.
15:33:53 <jonaskoelker> granted, they're not optimized for readability
15:34:14 <jonaskoelker> yep, the function is _l_ist -> _l_ist -> _l_ist
15:34:48 <Cale> Well, it doesn't technically have to be, given the inferred type of lll
15:35:00 <Cale> but I guess you're thinking of it that way
15:35:07 <jonaskoelker> yeah
15:35:08 <dmwit> Also, naming functions after your types is just a bad idea.
15:35:13 <dmwit> Give it a real name *and* a type.
15:35:17 <jonaskoelker> why?
15:35:22 <dmwit> We already have types!
15:36:15 <fmap> hungarian notation strikes back
15:36:32 <dmwit> Anyway, the whole things seems like it should just be in a RandT ErrorT LogicT monad.
15:36:48 <dmwit> Then you wouldn't need any of these one-liner functions with weird names.
15:37:14 <jonaskoelker> how would something like 'sample env gen (Add x y) = ...' look like, then?
15:37:20 <Phlogistique> how do I get a list of instances for a typeclass in ghci?
15:37:39 <shachaf> :i
15:37:45 <Phlogistique> thanks!
15:37:54 <dmwit> sample (Add x y) = liftM2 (+) x y, probably
15:38:05 <dmwit> yes
15:38:05 <jonaskoelker> el neato! :)
15:39:09 <Cale> So if you take the 9-dimensional cube with sides of length 4 centred on the origin, and you pack it with 2^9 spheres of radius 1 whose centres have coordinates +-1, you can fit a sphere of radius 2 centred at the origin which will be tangent to all 2^9 of those spheres as well as the cube itself.
15:39:13 <dmwit> sample (Div x y) = do { xv <- sample x; yv <- sample y; guard (yv /= 0); return (x `div` y) } -- or similar
15:39:43 <jonaskoelker> so... I'm not so sharp with the monad xformers; how do I write eval in your suggested case?
15:40:13 <dmwit> You'd string together runLogicT, runErrorT, and runRandT.
15:40:20 <dmwit> Let the types guide you on exactly how to string them together.
15:40:34 <Phlogistique> Is it possible to request the source for an instance with @src?
15:40:36 <Phlogistique> @src join
15:40:37 <lambdabot> join x =  x >>= id
15:40:47 <Phlogistique> @src >>=
15:40:47 <lambdabot> Source not found. Maybe you made a typo?
15:40:55 <byorgey> Cale: hehe, awesome
15:40:56 <otters> @src (>>=)
15:40:57 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
15:41:02 <dmwit> sample (Add x y) = liftM2 (+) (sample x) (sample y) -- this is probably what it would look like, not the thing above; I didn't read rec2 carefully enough
15:41:18 <RichyB> Cale, I take it you saw the article on /r/programming about higher dimensioned spheres being spiky?
15:41:24 <Cale> RichyB: yeah
15:41:35 <dmwit> ?src [] (>>=)
15:41:35 <lambdabot> xs >>= f     = concatMap f xs
15:41:40 <dmwit> Phlogistique: ^
15:41:56 <mzero> Phlogistique: you can't find the src for >>= because it is a type class method --- it will differ for each Monad instance
15:41:59 <Cale> I somewhat disagree about "spiky" being a good term, but it's a nice observation nonetheless :)
15:42:04 <RichyB> That src command is amazing.
15:42:12 <jonaskoelker> I'm not sure why you'd have LogicT... ?
15:42:13 <byorgey> "not enough room in your tiny apartment for all your stuff?  No problem!  Just upgrade to the ninth dimension!"
15:43:10 <byorgey> "then just stick everything in the corner!"
15:43:20 <Cale> RichyB: all it does is paste in part of a text file
15:43:29 <dmwit> Cale: I don't get it. How is the radius-2 sphere at (0,0,...,0) tangent to the radius-1 sphere at (0,0,...,0)?
15:43:31 <RichyB> byorgey, but everything would be crammed up right next to the walls.
15:43:48 <Cale> dmwit: that's not one of the radius 1 spheres I mentioned
15:43:52 <dmwit> ...oh, +-1, not 1/0.
15:43:54 <dmwit> got it
15:44:11 <byorgey> dmwit: WORMHOLES
15:44:38 <jonaskoelker> byorgey: :D
15:44:48 <Phlogistique> dmwit: thanks
15:44:52 <jonaskoelker> I think just one extra dimension would be great to store all my 3d clutter in ;-)
15:44:53 <Phlogistique> ?src id (>>=)
15:44:54 <lambdabot> Source not found. The more you drive -- the dumber you get.
15:45:03 <dmwit> id is not a type
15:45:18 <otters> ?src IO >>=
15:45:18 <lambdabot> Source not found. Do you think like you type?
15:45:20 <Phlogistique> oh, I though [] was an instance of a type
15:45:27 <dmwit> [] is a type constructor
15:45:31 <jonaskoelker> dmwit: why the LogicT?
15:45:32 <Phlogistique> ?src ((->) r) (>>=)
15:45:33 <lambdabot> Source not found. My pet ferret can type better than you!
15:45:34 <dmwit> ?src Maybe (>>=)
15:45:34 <lambdabot> (Just x) >>= k      = k x
15:45:34 <lambdabot> Nothing  >>= _      = Nothing
15:45:35 <Cale> jonaskoelker: You can purchase another stash tab for 100000 gold.
15:45:39 <Phlogistique> ?src ((->) a b) (>>=)
15:45:40 <lambdabot> Source not found. There are some things that I just don't know.
15:45:40 <dmwit> jonaskoelker: because ListT doesn't exist =)
15:45:47 <Phlogistique> ?src (->) (>>=)
15:45:48 <lambdabot> f >>= k = \ r -> k (f r) r
15:46:07 <otters> should it not technically be ((->) r) (>>=)
15:46:12 <otters> instead of (->) (>>=)
15:46:26 <dmwit> otters: Yes, ?src is not parsing real Haskell.
15:46:36 <otters> it's cheating :<
15:46:48 <dmwit> otters: It just has a file with paragraphs; it looks for a paragraph whose first line is exactly what you type, and gives you the remaining lines in the paragraph.
15:46:52 <Cale> It's just looking for a line in the text file which follows a blank line and which matches that
15:46:53 <dmwit> The simplest possible technology.
15:47:00 <Cale> and then printing the text up to the following blank line
15:48:25 <dmwit> jonaskoelker: (Perhaps more helpfully: ) because of the [Integer] in your Result type, and the way you treat it in your various one-liners.
15:48:35 <jonaskoelker> ah
15:48:43 <jonaskoelker> hmm...
15:49:07 <jonaskoelker> well, it might not be obvious, but I represent integers as one-element lists
15:49:14 <jonaskoelker> (ain't bug-for-bug compatibility fun?)
15:49:34 <jonaskoelker> all the scalar functions check the length, then unwrap the value
15:49:38 <jonaskoelker> (or fail o/w)
15:49:45 <jonaskoelker> is that what you'd gathered as well?
15:50:35 <dmwit> Yes, in my hypothetical rewrite you wouldn't do that.
15:50:42 <jonaskoelker> ah, neato
15:52:50 <dmwit> Oh, I see what you mean.
15:53:03 <dmwit> Okay, yeah, skip the LogicT and use a real type instead of [Integer].
15:53:09 <dmwit> Like Either Integer [Integer] or something.
15:53:29 <dmwit> Or make your Exp type a GADT to prevent ill-typed terms.
15:53:57 <dmwit> s/terms/expressions/
15:54:16 <jonaskoelker> and do type-checking before evaluating rather than during?
15:54:34 <dmwit> GADTs would force you to do "type-checking" before evaluating, yes.
15:54:44 <jonaskoelker> ah, yeah, duh
15:55:15 <jonaskoelker> well... hm... it seems like overkill
15:55:21 <dmwit> If that's a "duh" statement for you, you're smarter than me. =P
15:55:39 <dmwit> It took me several times being exposed to GADTs before I figured out what the point was. =P
15:56:08 <jonaskoelker> maybe not such much with the duh-ness on second thought :)
15:59:48 <dmwit> What does cat do?
16:00:10 <jonaskoelker> integer concatenation, 1 `cat` 2 = 12
16:00:19 <dmwit> weird
16:00:32 <jonaskoelker> hey, I'm implementing someone else's language ^_^
16:07:08 <jonaskoelker> dmwit: I'd use a ... reader?  state?  for the environment I'm threading through my tree?
16:07:18 <dmwit> Ah, yeah, Let does make GADTs a bit trickier.
16:07:26 <dmwit> State for the environment, I'd guess.
16:07:35 <dmwit> Reader can work.
16:07:36 <dmwit> :t local
16:07:37 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
16:07:54 <jonaskoelker> I'm not sure I follow
16:08:22 <dmwit> Which thing don't you follow?
16:08:29 <jonaskoelker> the significance of `local'
16:08:37 <dmwit> ah
16:08:51 <dmwit> "local" is for adding lexically-scoped variables to your environment. =)
16:08:57 <kloplop321> Has anyone had issues installing the Haskell Platform on mac with the latest xcode? (GHC doesn't have the "Install" Button enabled, and the Haskell Platform pkg says I need to install xcode.)
16:09:28 <jonaskoelker> very good =)
16:09:41 <dmwit> local (insert var val) foo
16:10:24 <jonaskoelker> neato!  So... we're up to something like Reader Error Random?
16:10:33 <jonaskoelker> in some order ^_^
16:11:01 <dmwit> yeah =)
16:11:54 <byorgey> kloplop321: take a look at http://www.haskell.org/haskellwiki/Mac_OS_X
16:12:11 <byorgey> not sure if it will answer your questions, but it seems to have some info about xcode + the HP
16:12:45 <kloplop321> Yes, the Haskell Platform which is linked to refuses to continue and claims xcode is not installed.
16:12:52 * byorgey does not actually know anything about OS X, except that it has now replaced Windows as the most annoying OS on which to install Haskell stuff
16:13:02 <kloplop321> Oh joy.
16:13:34 <kloplop321> I'm considering getting the "bindist" version of ghc
16:14:40 <kloplop321> The haskell platform for mac looks like it hasn't been touched for almost exactly a year.
16:14:57 <kloplop321> that might explain a few things.
16:16:58 <geekosaur> the haskell platform everywhere is kind of old; there should be a new version toward the end of this month
16:17:19 <geekosaur> but yes, that means apple's changes to xcode 4.3 broke it (and pretty much everything else...).
16:19:01 <kloplop321> Well, xcode is installed differently through the app store now, so the paths are likely different.
16:21:12 <mzero> kloplop321: there is an easy fix
16:21:14 <mzero> actually
16:21:24 <kloplop321> Do tell
16:21:36 <mzero> and not quite try - HP for Mac was released with the last release in Dec 2011.
16:22:25 <mzero> the problem is that Apple moved the location of gcc!
16:22:40 <kloplop321> so something as easy as a change of a env var?
16:22:52 <kloplop321> I suppose I inferred incorrectly from the package file name.
16:23:10 <kloplop321> (2011.4, so I thought it was April 2011)
16:23:14 <mzero> where is gcc on yoru system?
16:23:16 <mzero> (where gcc?)
16:23:17 <kloplop321> hold on.
16:23:58 <kloplop321> `which gcc` doesn't find anything. though that might be an outdated terminal session with the env vars
16:24:14 <mzero> shouldn't have anything to do with env
16:24:22 <jonaskoelker> PATH?
16:24:41 <mzero> well....  maybe - but I don't think installing Xcode changes your PATH
16:24:51 <kloplop321>  /Applications/Xcode.app/Contents/Developer/usr/bin/gcc
16:24:57 <jonaskoelker> point taken :)
16:24:58 <mzero> joy
16:25:02 <mparodi_> Hello guys
16:25:19 <mzero> The HP 2011.4.0.0 mac installer expects to find gcc in /usr/bin/gcc
16:25:29 <kloplop321> a symbolic link maybe then?
16:25:42 <mzero> the GHC 7.0.4 installed by that will expect to find gcc in /Deve/oper/usr/bin/gcc
16:25:59 <kloplop321> mzero: do you perhaps type in dvorak?
16:26:25 <mzero> if you symlink gcc into /usr/bin   - and simply simply simlink all of /Applications/Xcode.app/Contents/Developer / over to /Developer (if it isn't already)
16:26:28 <mzero> then you should be fine
16:26:40 <mzero> no, kloplop321 I don't type in dvorak
16:26:58 <mparodi_> if I want to find a function to get a list of digits out of a string, where should I search it?
16:27:05 <mzero> oh - hehe - no idea how that typo occurred
16:27:08 <kloplop321> hmm.. well, its just that a l and / is a common mistype in dvorak
16:27:10 <mparodi_> in the book I'm reading it says it's called "digits" but it's not in Prelude
16:27:43 * kloplop321 will attempt some linking magic
16:27:45 <mzero> > filter isDigit "snookie87yeahbaby2012"
16:27:46 <lambdabot>   "872012"
16:28:03 <dmwit> mparodi_: Perhaps you should look for the definition of "digits" in the book.
16:28:29 <kloplop321> oh, that's a nice bot
16:28:30 <mparodi_> dmwit, the problem is actually that it uses Hugs (I'm using ghci) and besides that it's pretty "old"
16:28:41 <dmwit> That's not the problem at all.
16:29:09 <mparodi_> it is, I have already seen some things that doesn't work in ghci and you can do with Hugs
16:29:39 <mzero> kloplop321: can you see if /Developer/usr/bin exists on your system ?
16:29:40 <dmwit> Perhaps you should set your ghci to H98 mode.
16:29:50 <mparodi_> isn't it in that mode?
16:29:51 <mzero> (unless you've already symlink'd it)
16:29:51 <kloplop321> mzero: Haskell Platform doesn't refuse to start now :D
16:29:52 <mparodi_> good question
16:29:57 <dmwit> ghci -XHaskell98
16:30:05 <kloplop321> and it completed
16:30:05 <dmwit> No, modern ghci's are in Haskell2010 mode by default.
16:30:10 <mparodi_> Prelude> digits
16:30:11 <mparodi_> <interactive>:1:1: Not in scope: `digits'
16:30:18 <dmwit> Yes, digits is not in the Prelude.
16:30:24 <kloplop321> cabal started
16:30:25 <mzero> kloplop321: did you have to make both symlinks I suggested?
16:30:31 <kloplop321> mzero: indeed.
16:30:31 <dmwit> Which is why I suggested you look in your book for its definition.
16:30:43 <mzero> (I'm trying to a- gather instructions to publish on this, and b- prepare the next HP release)
16:31:17 <mparodi_> dmwit, it uses it as if it was a standard function
16:31:28 <kloplop321> :t "Apples" replies "Apples" :: [Char] :D
16:31:29 <lambdabot> parse error on input `:'
16:31:34 <kloplop321> bah
16:31:41 <mparodi_> ahm, maybe it's defined somewhere, let me check again
16:31:55 <kloplop321> thanks for your assistance mzero
16:31:59 <mzero> welcome
16:33:01 <mparodi_> ah, alright, it's defined in the book :)
16:33:13 <mparodi_> anyway, so what's the standard approach to find a function you need?
16:33:21 <hpc> @where hoogle
16:33:21 <lambdabot> http://haskell.org/hoogle
16:33:37 <mparodi_> great!
16:33:38 <mparodi_> thanks
16:37:04 <mikeplus64> in ghci is there a :show bindings, for bindings not made at the prompt but in a loaded module?
16:37:44 <geekosaur> :browse ?
16:37:52 <mikeplus64> ah, thanks
16:45:35 <lpsmith> what's the difference between shutdown and sClose?
16:47:35 <mparodi_> ok, so... suppose you have a generator to get all digits in "test 1, 2 and 3." ([1, 2, 3]). and you use a function like "firstDigit foo = case (digits foo) of [] -> '\0'; (x:_) -> x"
16:47:56 <mparodi_> does it really create the list of digits or just the first item?
16:48:11 <mparodi_> [1, <something still not evaluated here>]
16:48:12 <dmwit> Just the first item.
16:48:29 <mparodi_> good, then that function firstDigit is not *that* bad
16:49:47 <mparodi_> (I thought it was really bad because it only uses one item of the list of all the digits :)
16:54:45 <mzero> anyone here want to weigh in on the version of mtl & transformers for the next HP?
16:56:08 <applicative> mzero, hm, is there a discussion of the stakes somewhere?
16:56:55 <mzero> just if we are moving to mtl-2.1.1 and transformers-0.3.0.0
16:57:10 <mzero> this has been the tentative plan for two weeks - and I'm triple checking
16:59:36 <applicative> a priori it seems like one should go for the most recent one; there will be a period where everything is broken anyway, and perhaps quite a while til the next HP is released
16:59:48 <applicative> but is it thought  that they are immature?
17:00:20 <tgeeky> mzero: i want transformers-0.3
17:00:33 * applicative hasn't studied the differences so he's clueless of course
17:00:43 <applicative> whats better about it tgeeky
17:00:49 <tgeeky> applicative: larger version number!
17:01:17 <tgeeky> mzero: just blame me in some official capacity, and forward the hate mail my way
17:01:25 <geekosaur> weren't some useful instances just added to it?
17:01:48 <tgeeky> thanks to luite: http://hdiff.luite.com/cgit/transformers/commit?id=0.3.0.0
17:02:16 * hackagebot arithmoi 0.2.0.6 - Efficient basic number-theoretic functions.  Primes, powers, integer logarithms.  http://hackage.haskell.org/package/arithmoi-0.2.0.6 (DanielFischer)
17:02:19 <mzero> oh - tgeeky, are you, IRL, one of the maintainers?
17:02:23 <tgeeky> oh yes, they include Control.Applicative.Backwards, which I am actually using (seriously!)
17:02:30 <tgeeky> mzero: not even close.
17:02:41 <tgeeky> lots of changes though
17:03:10 <tgeeky> mzero: actually, in seriousness, here's a concrete reason
17:03:19 <applicative> Backwards is pleasing, but not a major step forward
17:03:53 <tgeeky> applicative: well it also contains the applictive lift class
17:04:01 <tgeeky> or type, rather
17:04:11 <applicative> thats what i'm looking at. didn't know it
17:04:18 <tgeeky> applicative: and the reverse functor
17:04:33 <tgeeky> applicative: this will be useful in general to anyone writing invertible computation
17:04:52 <tgeeky> mzero: and it includes a source repository (finally)
17:05:26 <mzero> as for the stakes -- there a number of packages that have upper bounds that will not build with those versions of mtl or transformers
17:05:39 <mzero> for most of them, they just need their upper bound bumped
17:05:42 <tgeeky> mzero: why don't we have the ability to just make that query damn it.
17:05:45 <mzero> it is possible that some might break
17:06:06 <applicative> i  advise ignoring that, based on past experience
17:06:24 <applicative> a new HP gives focus to the matter of updating
17:06:55 <applicative> in between people straggle, you have the power to enforce widespread updates
17:07:18 * hackagebot happstack-yui 7351.0.0 - Utilities for using YUI3 with Happstack.  http://hackage.haskell.org/package/happstack-yui-7351.0.0 (DagOdenhall)
17:08:40 <applicative> in a sense the haskell platform will cure a lot of current breakage, whatever you do
17:09:44 <applicative> we should add a seal of approval on hackage "Platform compatible"
17:10:06 <tgeeky> er.
17:10:14 <tgeeky> maybe if the platform has a regular release cycle
17:10:25 <tgeeky> at this point GHC is more regular than HP
17:11:03 <applicative> its seeming rarer than when if first got going, which is fine, its obviously an immense labor etc
17:11:05 <mzero> *ahem* as the new release manager - I'm tryin' here!!!
17:11:18 * applicative hails mzero
17:11:29 * tgeeky hopes he has not offended the master, sir.
17:11:37 <donri> applicative: don't you mean "empty"
17:11:47 <mzero> cut me a little slack -- this is my first time as RM, and I think -- just barely -- I'll get this one out in the month we said we would (May)
17:12:06 * applicative hails empty and mempty too; but mzero rules.
17:12:21 <donri> but applicative knows not of mzero
17:12:34 <tgeeky> mzero: go with the new transformers. The next release of HP may well be 7.6, and it will (probably) require trasnformers-3?
17:12:49 <applicative> i think its a no brainer
17:13:34 <tgeeky> plus, as far as I can tell, you're guaranteed that it won't break code, it will just cause bumping (which I think should be added to the Haskell Versioning Policy somehow, but that's a seperate issue)
17:15:27 <applicative> unless you think there is some flaw in transformers-0.3 you should use it.  you will be increasing breakage and bumping in the short term, decreasing it in the longer term
17:15:39 <applicative> tgeeky is already using Backward:)
17:16:10 <tgeeky> I am!
17:16:28 * applicative will no stop repeating his argument, which, though decisive is not that great
17:16:32 <tgeeky> I am making a class called Centered, which is unfoldable and foldable both forward and backward.
17:16:33 <applicative> now
17:17:15 <applicative> mzero, I hope we are not projecting anything but faith in and admiration for and gratitude to you
17:17:38 <tgeeky> hehe
17:18:00 <mzero> uhm - the version numbers for mtl and transformers are both major number bumps -- indicating possible API breakage - but I dont' think they are
17:18:08 <mzero> applicative: yes - I'm feelin' the love
17:18:22 <tgeeky> mzero: i was going to say it. I don't really know why that went to 0.3
17:19:00 <applicative> the new modules aren't breakage, but they are distinctly new
17:19:13 <tgeeky> i haven't even really read the HVP, so what do I know.
17:19:28 <applicative> besides is a really central package, so the rules might be a little different in its case
17:20:10 * applicative is an mtl hater so he wont comment
17:22:41 <applicative> mzero, if you need more testing for os x i can help, if my general half-competence isn't  an issue
17:22:58 <tgeeky> mzero: if you need testing for Windows, I can help. I'm not half-competent.
17:24:16 <mzero> there is a trial install up now: http://www.ozonehouse.com/mark/platform/Haskell%20Platform%202012.2.0.0%2032bit%20rc1.pkg   --- it is 32bit and won't work with Xcode 4.3 (modulo the symlink hacks I listed above) ---- and there will likely be some minor version bumps before final
17:24:22 <mzero> but sure - have a whack!
17:25:05 <mzero> I don't think a windows build is out yet
17:28:25 <mzero> break for dinner - laters all
17:28:39 <applicative> hm, the xcode on this machine is  ancient.  be good mzero
17:29:26 <BMeph> mzero: When y'all get a 64-bit Windows build, call me. ;)
17:30:05 <tgeeky> BMeph: Ian has been working on that quite dilligently it seems.
17:31:19 <applicative> a straightforward smooth windows haskell platform would be a great step forward for Haskell. I can't imagine the horrors that would be involved in producing it
17:31:58 <geekosaur> can we hope that's part of what;s being funded along with the 64 bit windows support?
17:32:20 <solrize> the lambda tribe in two sentences
17:32:20 <solrize> In the beginning was the lambda. God saw it, realized he didn't need anything else, and stopped there.
17:32:25 <applicative> is there financial help with that?
17:32:28 <geekosaur> (well, can "we" hope - I am still not much of a Windows user)
17:32:49 <geekosaur> my understanding is that it is being funded and the current target is ghc 7.6.1
17:33:12 <ohgodno> q
17:33:14 <geekosaur> I do not recall who is doing the funding though
17:33:32 * applicative has brazenly set the new os x installer going.
17:35:23 * applicative tries 'cabal install gloss' for a standard issue disaster
17:36:03 <applicative> geekosaur, oh i see that sounds great
17:36:56 <geekosaur> http://hackage.haskell.org/trac/ghc/wiki/Status/May12 says the Industrial Haskell group
17:37:06 <geekosaur> does not mention if corresponding Haskell Platform work is funded
17:38:23 <applicative> ah I see. there is also the never ending libgmp license nonsense, it would be great if that could be conveniently finessed
17:38:59 <geekosaur> IHG webite doesn't mention any such thing eiter, but also doesn;t mention funding 64-bit windows support
17:43:35 <geekosaur> I will mention that what comes to mind to me for a better HP for Windows requires that VS be supported instead of or in addition to mingw, and unless that's part of the 64 bit support it will be a rather large hurdle
17:48:45 <applicative> some of the 'gloss examples' take forever to compile; i guess all this specializing and so on with repa
17:50:29 <applicative> the 'activity moniter' says it's opt that's taking forever, what is it doing, speaking as a unix-halfwit?
17:51:16 <applicative> i have seen this before with stream fusion-y things
17:51:55 <monochrom> I have not heard of "opt" as a unix program. only as a directory name.
17:52:08 <applicative> same here, maybe its a mac thing
17:52:46 <applicative> opt - LLVM optimizer
17:52:51 <applicative> not surprising
17:53:26 <monochrom> alright, llvm is awesome :)
17:54:30 <applicative> stream fusion can make the llvm think too, I noticed this before compiling vector things with -fllvm
17:54:45 <applicative> think too much
17:55:35 <applicative> it may have been 5 minutes now for 'gloss-mandel'
17:56:37 <applicative> our language strains the limits even of the llvm
17:58:12 <monochrom> oh yikes, 5 minutes is no longer awesome :)
17:58:59 <monochrom> http://xkcd.com/303/ :)
17:59:11 <applicative> i see the cabal file gives the options  -Wall -threaded -rtsopts -eventlog Odph -fno-liberate-case -funfolding-use-threshold1000 -funfolding-keeness-factor1000 -fllvm -optlo-O3
17:59:22 <applicative> one can anticipate disaster
17:59:58 <hpc> monochrom: i keep a VM on-hand with ghc ready to compile, just so i can look like i am hacking the matrix or whatever :P
18:00:11 <applicative> what is fno-liberate-case to  do with
18:00:59 <hpc> applicative: it enslaves the lower-case letters and makes them do all the work :D
18:01:17 <applicative> hah
18:01:30 <applicative> thats what the Upper Case always does
18:02:01 <hpc> applicative: SO says it's something to do with expanding case statements
18:02:29 <hpc> and that setting the flag can speed up compilation
18:03:30 <applicative> hm, seems not to be working, it's still compiling.
18:04:29 <applicative> the llvm optimizer is using little cpu and one thread, but refuses to declare its job done
18:05:03 <hpc> could it be swapping?
18:06:45 <applicative> maybe,  it's back to plenty of cpu.
18:07:05 <applicative> sorry, this  is silly, I'm testing the new os x platform installer, tempted by mzero
18:08:04 <newsham> mzero on one shoulder, who's on the other?
18:09:09 * geekosaur probably should be, in some sense
18:10:12 <geekosaur> since when the new HP is released I want to steal ownership of the moribund macports HP and update it, because I'm getting tired of being unable to build anything interesting
18:10:43 <geekosaur> (no, installing the official one is not a fix; since everything else comes from macports that just means I get iconv link errors everywhere...)
18:12:00 <robinhoode> Is there a preferred NoSQL database that has good iterop with Haskell?
18:12:30 <robinhoode> I'd like to run an app on a small cluster (3 - 5 VPSes) to do map / reduce operations..
18:13:43 <JoeyA> MongoDB might be good.  It has a Persistent backend: http://hackage.haskell.org/package/persistent-mongoDB
18:13:53 <applicative> geekosaur: iconv was the chronic torment when i first got a mac, esp with macports, the platform mostly resolved this
18:14:05 <robinhoode> Yeah I've been looking at that...
18:14:23 <robinhoode> But it's got a lot of mixed reviews around the 'net..
18:14:27 <applicative> i would end up with four competing libiconvs
18:14:30 <robinhoode> I guess it's worth a shot just to learn it
18:14:38 <geekosaur> except that I cannot then build stuff that uses, for example, gtk2hs, unless I find someone's non-macports gtk+ build.  and same for other useful frameworks that I already have installed in macports variants
18:15:08 <newsham> http://www.haskell.org/haskellwiki/Web/Databases_and_Persistence
18:15:17 <geekosaur> and at this point ditching macports is not useful, because I get to rebuild everything in that case (and I do mean everything, I have a lot of stuff installed and in regular use)
18:16:03 * hpc thinks the more noble effort would be in streamlining the process of getting mac to behave itself
18:17:18 <geekosaur> yes, I am aware "cool kids" like to use homebrew these days.  mostly because its solution to the problem involves crossing every stream it can --- and I have already had to rebuild systems because of things that did that (including very early versions of both fink and macports; there is a reason they moved to all-inclusive ecosystems)
18:18:31 <mietek> gtk2hs + OS X = :(
18:18:56 <mietek> "malloc: *** error for object 0x103aef688: pointer being freed was not allocated"
18:19:03 <applicative> I have to say homebrew made things a lot easier, but I dont have the same requirements probably. gtk is hopeless
18:19:34 <geekosaur> so, no homebrew until they learn that the reason why nobody else does it that way is that in the long run it causes problems.  which they *are* learning, but slowly; they're still in the "oh, we can fix that case by case" stage of denial. like all their predecessors went through
18:20:35 <applicative> hah, gloss-mandel is still at it.  does 10 minutes suggest the llvm is going to optimize forever?
18:21:19 <gienah> if gtk is a problem on MacOS, then maybe wxhaskell / wxwidgets might be an alternative
18:21:28 <hpc> applicative: let it run overnight, perhaps
18:21:35 <applicative> some of the trouble they evade with homebrew seems to be by an extreme contraction in your  o options
18:21:35 <geekosaur> back before things fell behind, I had gtk2hs working with macports ghc.  that is what I plan to work on.
18:21:51 <geekosaur> gienah:  not helpful if you are trying to build a package that was written with gtk2hs
18:22:35 <mietek> geekosaur: funnily enough, I'm working on the same issue right now.  I have gtk2hs installed and working (apart from cairo) with non-homebrew GHC 7.4.1 and rest all from homebrew.
18:22:49 <mietek> Remaining thing is cairo.
18:23:11 <mietek> http://hackage.haskell.org/trac/gtk2hs/ticket/1241
18:25:36 <gienah> geekosaur: no, well maybe can try to debug the memory heap corruption with valgrind
18:26:08 <applicative> when i bothered trying to install gtk2hs i aspired to such errors.  usually there would be some incoherent linking with the 400 copies  of standard libraries
18:26:20 <applicative> os x seems to come with
18:27:05 <gienah> another idea: macos comes with dtrace, you can use that to debug memory heap corruption problems
18:28:41 <applicative> here is the hilarious letter to the haskell cafe from conor mcbride, it appeared when i was first learning haskell http://www.haskell.org/pipermail/haskell-cafe/2009-December/071117.html
18:28:57 <geekosaur> and some other librares like readline that apple stomped on in various annoying ways
18:29:16 <applicative> "i realized i had two copies of libiconv.dylib, so i renamed the latter opt/local/lib/moolibiconv.dylib
18:29:32 <applicative> "do  you think I broke anything"
18:29:39 <geekosaur> yeh, that just breaks macports
18:29:49 <geekosaur> and you, once you link with anything from macports
18:30:12 <applicative> yes; but I knew I had found my leader when I read it :)
18:30:26 <geekosaur> the alternative being hoping eveyrthing will work with Apple's ancient iconv, or installing a newer one without symbol renaming and hoping everything manages not to get confused
18:30:40 <gienah> geekosaur: dtrace malloc debugging: http://docs.oracle.com/cd/E19205-01/820-4221/
18:31:02 <applicative> what does the Haskell platform do for iconv?  It seems to have finessed all this
18:31:45 <geekosaur> HP itself does not care, I think.
18:31:58 <geekosaur> almost all GNU libraries *do* care
18:32:19 <geekosaur> (except libgmp which has no UI components to translate)
18:32:30 <applicative> haskeline is the familiar package  thatstill  gives me iconv torments.  that's part of the reason i was happy to try this installer, i can't reinstall agda
18:32:55 <applicative> with my homemade ghc
18:32:57 <geekosaur> hm, right haskeline is in HP, so I just lied.  sigh
18:32:59 <hamishmack> I build GHC on OS X to use the same icon as gtk-osx
18:33:21 <applicative> ah, that's why  it's  no probem
18:35:14 <applicative> hm haskeline isn't in the new platform i just installed but maybe its not complete
18:35:59 <geekosaur> *blink* did ghci stop using haskeline, then?
18:36:25 <applicative> maybe some of the code is integrated ?
18:37:54 <RylandAlmanza> Anyone have an opinion on the best haskell web framework?
18:39:22 <illissius> Typeable1+ are weird.
18:40:54 <applicative> if "framework" is the operative word, I would think yesod?
18:41:29 <hamishmack> Oops meant iconv not icon (must turn off auto correct)
18:41:43 <applicative> and anyway, 'conduits' are 1000 times better than enumerators
18:47:55 <applicative> hm, i struck 'gloss-mandel' from the cabal files; the other examples built, but I think the repa-involving ones are the ones giving "bus error" when I try them
19:01:24 <applicative> man the wx machinery produces 21000 line haskell modules
19:01:55 <gienah> applicative: you can see why its generated code :-)
19:02:43 <applicative> surprisingly readable though
19:04:12 <applicative> wxcIsBusy ::  IO () ; wxcIsBusy = wx_wxcIsBusy ;foreign import ccall "wxcIsBusy" wx_wxcIsBusy :: IO () -- makes perfect sense
19:05:39 <gienah> applicative: it was easy to patch it for ghc head: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/wxdirect/files/wxdirect-0.90.0.1-ghc-7.5.patch
19:07:20 * hackagebot happstack-yui 7351.1.0 - Utilities for using YUI3 with Happstack.  http://hackage.haskell.org/package/happstack-yui-7351.1.0 (DagOdenhall)
19:08:26 <strager> Diff of a diff!  Aaaah!
19:08:28 <donri> uh so how do you fix a broken cabal upload
19:10:02 <applicative> gienah: I see does that solve all those warnings about CInt
19:12:32 <tgeeky> since I'm working on other things and feel like being intellectually lazy... can someone give me a good, technical reason why cabal doesn't allow multiple "library" definitions in one cabal file?
19:13:20 <tgeeky> right, me neither.
19:13:25 <gienah> applicative: I didn't notice it had warning with ghc 7.4.1, I guess I should check that before upstreaming the patch
19:14:14 <tgeeky> wouldn't that actually also solve the need for cabal-meta or cabal-nirvana or whichever is designed to just specify exact prerequisites?
19:14:47 <tgeeky> maybe not. You might need to push the version number down into the library section
19:18:01 <nand`> can a deterministic turing complete machine simulate any other deterministic turing complete machine in finite time?
19:18:49 <nand`> that is; simulate the machine so that any finite-time calculation on the simulated machine will halt in finite time on the simulating machine
19:24:01 <Eduard_Munteanu> nand`: um, I guess so, why are you talking about different DTMs?
19:25:17 <nand`> Eduard_Munteanu: the idea was whether or not it's possible to simulate, say, an x86 processor running Linux in something like rule 110
19:25:56 <Draconx> nand`, a computational model is "turing complete" if it can simulate a universal turing machine.  In particular, a (deterministic) turing machine with an attached halting oracle for turing machines is turing complete (call this model T1).  Turing machines (call them T0) are also turing complete.  T0 is strictly less powerful than T1, so the answer to your question is "no".
19:26:13 <Eduard_Munteanu> nand`: it should, after all, you assume infinite memory
19:26:18 <Draconx> nand`, However, church-turing thesis postulates that T1 isn't something that can exist in the real world.
19:26:21 <ptrf> hi, I'm having a bit of issue finding a way to get the current time in haskell with microsecond resolution. I found Data.Time.Clock, and the getCurrentTime returns UTCtime, and it doesnt seem to feature subsecond resolution. am I mistaken?
19:27:03 <rwbarton> http://en.wikipedia.org/wiki/Universal_Turing_machine -- nand` are you asking about this?
19:27:10 <ptrf> or, how can I find something that returns the timestamp with subsecond resolution, because hoogle isnt helping me
19:30:19 <nand`> Draconx: I'm not sure I follow; wouldn't it be comparing T1 to T1, and not T1 to T0? I specifically mentioned ‚Äúany other deterministic turing complete machine‚Äù, not ‚Äúany other turing machine‚Äù
19:30:41 <nand`> rwbarton: looks relevant
19:30:45 <Draconx> nand`, both T1 and T0 are turing complete machines.
19:30:50 <rwbarton> oh i missed "complete" in your question
19:31:18 <Draconx> nand`, so T0 is a turing complete machine that cannot simulate another turing complete machine, namely T1.
19:32:53 <nand`> Draconx: oh, I misread your original response
19:34:54 <nand`> Draconx: and yes, that answers my question quite well
19:37:42 <mietek> Woop woop
19:38:04 * mietek got gtk & cairo working on OS X
19:38:25 <mietek> Only took a finite number of reinstallations
19:39:01 <Draconx> nand`, but church-turing thesis seems to apply, given your comment about "x86 processor running Linux", which roughly states that anything you can actually build in the real world can be simulated by a turing machine (and therefore with any model that's turing-complete).
19:39:21 <nand`> Draconx: right
19:45:00 <ClaudiusMaximus> ptrf: UTCTime is pico-second precision, but implementations of getCurrentTime are likely to be less acccurate (i don't know any more accurate way myself, though)
19:50:07 <ptrf> ClaudiusMaximus: thanks, I imported and took a look at it :) I guess I was just too lazy at first :P
19:50:36 <ClaudiusMaximus> ptrf: join $ liftM2 ((print .) . flip diffUTCTime) getCurrentTime getCurrentTime   -->  0.000001s   (a quick test in ghci)
19:50:37 <nand`> it seems to show at least some sub-second precision for me
19:51:00 <nand`> shows 6 digits after the decimal point, but I have no idea about its accuracy
19:51:04 <ptrf> something like that ClaudiusMaximus  :)
19:51:37 <ptrf> I was coming up with something like that :) thanks
19:52:53 <nand`> for successive iterations of ‚ÄúdiffUTCTime <$> getCurrentTime <*> getCurrentTime‚Äù it seems to be 0s most of the time, and 0.000001s rarely
19:53:09 <nand`> so I'm guessing it's actually measuring that precision on my machine as well
20:01:37 <applicative> mietek: you should write up the instructions, except probably  you've already forgotten half the tricks.
20:07:22 * hackagebot file-embed 0.0.4.4 - Use Template Haskell to embed file contents directly.  http://hackage.haskell.org/package/file-embed-0.0.4.4 (MichaelSnoyman)
20:27:22 * hackagebot warp 1.2.1.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.2.1.1 (MichaelSnoyman)
20:41:13 <tgeeky> dmwit: ut oh. we're all out of #pee
20:41:19 <tgeeky> abandonware!
20:43:36 <dmwit> eh?
20:43:43 <jfischoff> ?
20:52:23 * hackagebot shelly 0.9.3 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.9.3 (GregWeber)
21:01:26 <JEntrep> Alright Haskell!
21:01:45 <JEntrep> Hey Nisstyre
21:01:52 <Nisstyre> sup
21:07:00 <nand`> Why exactly does Data.ByteString.Char8 exist? Isn't Word8 isomorphic to Char8 (when truncated to 8 bits)?
21:07:15 <nand`> is this just a convenience thing?
21:08:13 <dmwit> What is Char8? I've never heard of it.
21:08:37 <nand`> it's actually Char
21:08:38 <wo0kie> just wanted to thank byorgey and elliottcable for helping me out with previous haskell homework assignments :)
21:08:39 <nand`> not Char8
21:08:42 <dmwit> right
21:08:49 <wo0kie> made a big difference :)
21:08:50 <nand`> but internally it only uses 8 bits
21:09:01 <nand`> so I don't see what the distinction is, except perhaps being misleading
21:09:04 <geekosaur> Word8 is closer to the actual format ByteString uses; Char is more convenient but Char in Haskell is more than 8 bits so there is data loss
21:09:12 <dmwit> nand`: Anyway, yes, it's just wrong.
21:09:18 <dmwit> It can't really store Char's.
21:09:35 <dmwit> gotta encode it first
21:09:43 <geekosaur> (I should say potential data loss, but I don;t think the API checks if you are trying to use >8bit characters with the Char interface)
21:09:45 <nand`> I think the .Char8 interface just invites being lazy; whereas Word8 forces people to think about unicode encoding
21:10:11 <dmwit> nand`: correct
21:12:46 <jmcarthur> nand`: if you're after unicode encoding (or even if you're not necessarily but you're still thinking of it as text rather than binary data) then you probably want to be using the text package anyway
21:13:04 <tgeeky> dmwit: ah! I accidentally the wrong IRC network.
21:13:24 <dmwit> ah! phew
21:13:53 <nand`> jmcarthur: a fair point; I mainly come across ByteString when transmitting UTF8-encoded Text over TCP connections
21:13:58 <ClaudiusMaximus> @where pvp
21:13:58 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
21:14:44 <tgeeky> I've got this new thing I'm trying today. It involves uninhibited blatant plagarism and module names like: Pearl.Generalizing_and_Dualizing_the_Third_List_Homomorphism_Theorem.Pearl. I really think you guys will like it.
21:18:50 <ClaudiusMaximus> PVP say "(1) instances added => bump major version; (2) if only new types ... => bump minor version" -- what should i do if i add a new type and instances for it?  i feel it should be safe to apply (2), because the instances won't overlap with anything that wasn't already overlapping, but what say you?
21:19:10 <dmwit> Pearl twice?
21:19:30 <tgeeky> dmwit: yep. it's the binding of the paper, if you will
21:19:52 <tgeeky> the first pearl is to make sure this horrible abuse of namespace gets snuck away.
21:20:20 <tgeeky> I am pretty sure I am going to have to write and ask permission, though.
21:20:23 <dmwit> ClaudiusMaximus: neat question
21:20:43 <tgeeky> ClaudiusMaximus: Yes. We were discussing this earlier.
21:20:43 <geekosaur> ClaudiusMaximus, it should probably be clearer about that, but the reason for (1) is potential for conflicts with others defining the same instances so it can't apply if they're only for new types you're adding
21:21:09 <dmwit> ClaudiusMaximus: I would say (2) applies.
21:21:39 <tgeeky> ClaudiusMaximus: The actual package (more important, forgive your package's importance) is with transformers 0.2.x.x -> 0.3.0.0 in: http://hdiff.luite.com/cgit/transformers/commit?id=0.3.0.0
21:22:15 <tgeeky> ClaudiusMaximus: It's (obviously not breaking existing *anything*, only adding new things) versus (making lots of packages bump their transformers dep)
21:22:44 <tgeeky> This was in the context of what 'mzero' who is the new maintianer of haskell-platform, should put in the next haskell-platform
21:23:12 * mzero looks up
21:23:38 <geekosaur> use/mention distinction... :)
21:23:43 <tgeeky> hehe.
21:25:26 <mzero> ClaudiusMaximus: I'm w/dmwit - bump minor
21:25:36 <ClaudiusMaximus> ok, thanks all :)
21:26:23 <mzero> anyone here have Xcode 4.3 installed?
21:26:50 <ClaudiusMaximus> (i did see a bit of that discussion, but wasn't paying too much attention - i didn't realize the transformers diff 0.2 -> 0.3 wasn't so major)
21:27:38 <ClaudiusMaximus> although it *is* longer than my diff will be, which is surely a sign of my package's insignificance :)
21:28:04 * geekosaur has been carefully refusing to install 4.3, sorry
21:29:01 <tgeeky> ClaudiusMaximus: yeah. I'm thinking of writing some git hooks to automatically distinguish between (versioning changes, documentation changes, and code changes). I'd like to include "nominal, not structural module changes" to that list too, but I'm not sure it's as easy.
21:30:30 <tgeeky> but if you have this kind of thing in place (somewhere along the line you distinguish these things), then it might be acceptable for cabal to automatically bump versioning, just commuting over all of the (versioning, documentation) changes
22:38:23 <ClaudiusMaximus> is it just me having slight problems uploading to hackage? - it all works fine (i see my package on the recent page), except the browser sits there for 10mins after the upload completed, before hackage replies with an Internal Server Error page
22:40:10 <dmwit> I don't exactly want to make an upload just to test it out.
22:40:26 <dmwit> But who uploads from the browser these days? So archaic!
22:40:38 <dmwit> just cabal sdist && cabal upload dist/*.tar.gz
22:40:54 <ClaudiusMaximus> sure, but it happened to me my last 3 or so uploads, over 2 weeks or so
22:41:04 <dmwit> hm
22:41:13 <dmwit> Maybe write an email to Ross?
22:41:13 <ClaudiusMaximus> that does sound handy, i may try it next time
22:41:30 <dmwit> You shouldn't literally use *.tar.gz, though.
22:41:45 <ClaudiusMaximus> hehe, ok
22:42:26 * hackagebot variable-precision 0.2.1 - variable-precision floating point  http://hackage.haskell.org/package/variable-precision-0.2.1 (ClaudeHeilandAllen)
22:43:20 <ClaudiusMaximus> i think i'd rather file a ticket than send an email to a busy individual - though if i can't find where to do that i might
22:45:04 <yitz> ClaudiusMaximus: well, the standard way to get an account on hackage for uploading is still a personal email to Ross.
22:45:46 <yitz> ClaudiusMaximus: it's true that he's busy, but i think he would change that policy if he minded dealing with the occasional administrative email regarding hackage.
22:47:30 <ClaudiusMaximus> yitz: ok - i looked at the hackage trac and it seems more about cabal-install and hackage2 than server admin
22:47:41 <ClaudiusMaximus> so i guess a mail will do for now
22:59:00 <puritan> Why does this trick the type checker? www.mail-archive.com/haskell-cafe@haskell.org/msg18596.html
22:59:29 <puritan> (using unsafePerformIO + IORefs to define unsafeCoerce)
23:12:57 <xil> hi everyone. So I'm looking for a reliable way to essentially get a non monadic array that won't copy the array in memory every time I make a change. Essentially I have some tail recursion that changes the array on each iteration, but because of the tail recursion I don't need to save previous versions
23:13:55 <tgeeky> i'm confused. Is there any way with haddock to hyperlink to a module which you've imported qualified?
23:14:34 <puritan> xil: I don't think it's possible if you really require random access
23:14:47 <tgeeky> That is, I will always have to type This is a link to "Some.Longass.Module.Name.Here#02" even if I've done "import qualified Some.Longass.Module.Name.Here as SLMNH" ...?
23:15:12 <puritan> xil: If that's the case they you'll have to switch to a tree if you want to keep the rest of your constraints
23:15:20 <Eduard_Munteanu> xil: you can't really "solve" that, unless the compiler gets smarter about that sort of stuff.
23:17:46 <xil> aha, I see. That's a shame. Well the random access is of utmost importance. Maybe I'm just doing this wrong. I'm making a class that needs a function "simulate" for simulating a given neural network with some given inputs and produces some outputs. I want the outputs to just be a list of values, but as I have it now I in my instance of this class I need the function to use IO
23:17:46 <mzero> xil - perhaps what you want is Data.Array.ST - you work with the array in the ST monad while you're mutating it - but then you can "get it out" back into your pure code
23:18:07 <xil> mzero: orly? I'll check that out. Sounds like what I might need
23:19:04 <xil> yes! I only need the mutable state within the algorithm
23:19:33 <xil> that's the description I was looking for. Couldn't figure out the words
23:20:34 <puritan> Actually...
23:20:38 <puritan> You can do something really evil
23:20:39 <puritan> http://codepad.org/9bxIg42m
23:21:18 <mzero> puritan: what is evil about that?
23:22:51 <ClaudiusMaximus> @hoogle (//)
23:22:51 <lambdabot> Data.Array.IArray (//) :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e
23:22:51 <lambdabot> Data.Array (//) :: Ix i => Array i e -> [(i, e)] -> Array i e
23:23:25 <puritan> mzero: Well, in ghc you can do this http://codepad.org/7PBosqPx
23:23:27 <ClaudiusMaximus> but that doesn't help if you need a chain of updates
23:23:32 <puritan> (codepad doesn't seem to be running ghc)
23:23:40 <puritan> You can update an index along the way
23:24:03 <puritan> Not in Haskell98 mind you
23:24:39 <puritan> in ghc this yields array (0,2) [(0,1),(1,1),(2,1)]
23:25:14 <puritan> xil: So actually you could use that method
23:25:27 <puritan> xil: but it's a hack and a really subtle one at that
23:25:51 <mzero> puritan: that still doesn't seem evil to me at all - and matches exactly what the doc says it should do
23:26:03 <mzero> (which does point out that it isn't H98...)
23:26:04 <xil> puritan: I think I'll use ST. It looks like it's designed very specifically for this
23:26:33 <mzero> xil - you may also prefer to use the Data.Vector family --- depending on what your arrays are arrays of
23:26:41 <mzero> Vector is faster if you can use it
23:27:02 <mzero> I'm curious though - do you have your whole algo. working in pure form first?
23:27:33 <ClaudiusMaximus> > let input = listArray (0,5) [0..5] ; output = input // [ (i, (if i == 0 then 0 else (output ! i - 1)) + input ! i) | i <- indices input ] in output :: Array Int Int  -- this might work with lazy arrays
23:27:37 <lambdabot>   mueval-core: Time limit exceeded
23:28:00 <xil> mzero: not actually, no, but I have it all designed
23:28:24 <ClaudiusMaximus> guess not
23:28:28 <xil> mzero: it's exactly the same just replacing IOArray with Array and all calls to the read and write functions with the analogues
23:28:31 <puritan> mzero: Doesn't it break referential transparancy?
23:28:33 <mzero> If I were you, I'd get it all to work purely first ---- then optomize it with ST as needed
23:28:48 <mzero> puritan: nope
23:29:12 <mzero> remember - those things are lazy!
23:29:30 <xil> mzero: okay, I'll do that when I write it out. Not doing that quite yet. Right now I needed to know that it could be done for the sake of defining this class
23:29:42 <mzero> k
23:29:47 <mzero> anyhow - night all
23:29:49 <mzero> I'm off to bed
23:29:52 <xil> night!
23:35:47 <puritan> Yay it looks like Mac OS lion broke my ghc
23:37:18 <puritan> Why is GHC bigger than the Haskell platform 0_o
23:38:08 <dmwit> It surely isn't.
23:38:22 <dmwit> Perhaps you're comparing a source distribution of GHC to the platform?
23:38:40 <puritan> http://hackage.haskell.org/platform/mac.html 64 bit is 150 MB
23:38:49 <dmwit> Or perhaps you're comparing flat distribution of GHC to an installer that downloads things from the network as it works.
23:38:50 <puritan> http://www.haskell.org/ghc/download_ghc_7_4_1#macosx_x86_64 the package is 152MB
23:38:59 <puritan> maybe it includes sources too
23:39:25 <puritan> yay installing GHC rather than Haskell platform fixed the lion compatibility issue
23:42:26 <puritan> a = let a0 = a ! 0 in array (0, 2) [(0, 0), (1, a0), (0, 1), (2, a0)]
23:42:34 <puritan> results in array (0,2) [(0,1),(1,1),(2,1)]
23:42:45 <puritan> nobody finds it weird that a0 takes on two values?
23:43:24 <dmwit> a0 doesn't take on two values
23:43:37 <dmwit> it takes on one value: a ! 0 (=== 1)
23:44:32 <puritan> oh, I see
23:44:39 <puritan> ok nevermind
23:44:49 <puritan> You can't do the evil thing I thought you could do
23:44:50 <ClaudiusMaximus> "Haskell 98 requires that for Array the value at such [repeated] indices is bottom", but ghc doesn't follow that
23:44:59 <puritan> too bad : (
23:45:16 <dmwit> Oh, crazy.
23:45:23 <dmwit> What does Haskell 2010 require?
23:46:00 <dmwit> same thing
23:46:03 <ClaudiusMaximus> wait, maybe i misinterpreted http://hackage.haskell.org/packages/archive/array/latest/doc/html/Data-Array-IArray.html#v:array
23:46:21 <ClaudiusMaximus> not sure whether it's talking about boxed or unboxed arrays in that sentence
23:47:26 <dmwit> http://www.haskell.org/onlinereport/haskell2010/haskellch14.html#x22-20100014 <- it's talking about boxed arrays
23:47:45 <dmwit> unboxed arrays aren't in the Report
23:48:09 <ClaudiusMaximus> thanks
23:49:43 <dmwit> Seems like a good point for a Haskell' proposal.
23:49:52 <dmwit> What does Hugs do?
23:50:58 <ClaudiusMaximus> Hugs> :also Array
23:50:58 <ClaudiusMaximus> Array> let a = let a0 = a ! 0 in array (0, 2) [(0, 0), (1, a0), (0, 1), (2, a0)] in a
23:51:01 <ClaudiusMaximus> array (0,2) [(0,
23:51:04 <ClaudiusMaximus> Program error: undefined array element
23:51:17 <dmwit> aw, bummer
23:52:29 <dmwit> I guess there's not too many places where the Report says "implementation-specific". =P
23:52:37 <ClaudiusMaximus> same with -98 command line flag
23:54:12 <ClaudiusMaximus> well, i think i'd personally prefer the hugs behaviour if it said "undefined (due to duplicate definition) array element"
23:55:06 <ClaudiusMaximus> because otherwise you could have annoying bugs;  but then something like  checkArray :: Array ... -> Maybe (Array ...) would be nicer than an error call
23:55:27 <ClaudiusMaximus> gets messy i guess
23:56:04 <dmwit> Well, you can always implement whatever interface you want with STArray.
23:56:32 <ClaudiusMaximus> i think a nice property to have would be  array b (xs ++ ys) = array b (ys ++ xs)
23:59:53 <dmwit> Plain old Array seems a bit... lousy for most things, though.
