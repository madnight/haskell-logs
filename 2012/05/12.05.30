00:08:23 <zzo38> My question still have not been answered about, is there something like readProcess for network?
00:10:00 * geekosaur does not understand the question; a network connection looks like a file, not a process
00:11:16 <geekosaur> and while you could relate sockets and pipes (and some unixlikes do) running a process and establishing a network connection are not particularly closely related
00:11:31 <zzo38> geekosaur: I mean, readProcess will get the filename and argument, and the input, and then results the output. So, something like that, you give it the hostname, port number, and input, and then it connects and sends that, and then when the server closes the connection everything received will be the result
00:11:46 <zzo38> There should be String and ByteString versions.
00:11:52 <shachaf> geekosaur: They're not?
00:12:06 <shachaf> Pipes seem like a special case of sockets to me.
00:12:07 <zzo38> I tried once but it doesn't work
00:13:18 <geekosaur> shachaf, did you even see the "and while you can relate..." part?
00:20:46 <geekosaur> zzo38, there is probably not the kind of fire-it-and-hope beyond Network.Socket and friends ( http://hackage.haskell.org/package/network ) because too much data invites deadlock (the OS buffers fill, waiting for you to read, but you're blocked on the connection finishing instead of reading content)
00:22:00 <geekosaur> readProcess will for example block in exactly that way if your program outputs more than PIPE_BUF (portably 64Kbytes, some Linux versions allow more)
00:23:12 <geekosaur> the network APIs don't guarantee even that large a buffer, so a blocking mechanism similar to readProcess would be very prone to block forever
00:23:59 <zzo38> Why doesn't it just allocate more memory and try again, if that happens?
00:25:23 <geekosaur> and what happens when that is exhausted?  the kernel (and I do mean the kernel; this has nothing to do with Haskell, in fact it's known as the open3 problem in Perl and Python) sets hard limits so naive programs can't cause a systemwide denial of service
00:25:43 <zzo38> You should get an error.
00:25:58 <geekosaur> in the case of processes, a pipe has a fixed buffer size, no exceptions; network buffers are more variable
00:26:21 <zzo38> They should have a ByteString version to save memory, too
00:26:47 <kallisti> I'm pretty sure you could create a simple library on top of wxWidgets to greatly simplify everything
00:26:54 <kallisti> er wxHaskell specifically.
00:27:04 <kallisti> for example, a Reader that holds the current parent frame.
00:27:18 <kallisti> that all of the library functions implicitly asks from.
00:27:29 <geekosaur> the network package has a ByteString version.  as for the other, you are blocked in waitpid(), you cannot be reading and it's the *other program* that is blocked waiting for you to read() instead of waitpid()
00:28:00 <Catnaroek> Hello. Is there any way to configure ghc so that -XMultiParamTypeClasses is always passed by default?
00:28:03 <kallisti> then you can arrange your controls in indented blocks, with "local" or some API-specific function to define the parent for the given block.
00:28:04 <geekosaur> or for networking, it's othr system calls (close()) but the same general effect.
00:29:24 <geekosaur> the network version of the deadlock is especially difficult because it could only be detected by both systems comparing what their corresponding processes are doing, which simply cannot be done with TCP/IP (and would be very high overhead in a protocol which did allow it)
00:29:34 <zzo38> Catnaroek: You can use LANGUAGE pragma in the source files
00:29:56 <zzo38> Always passing it by default won't work well when used with other computers that don't have that
00:30:18 <Catnaroek> zzo38: Oh.
00:30:24 <Catnaroek> Never mind, thanks! :)
00:31:06 <dmwit> Or you can cabalize your package and put MultiParamTypeClasses in the extensions: line.
00:33:07 <geekosaur> also, I would note that even if it could detect that particular deadlock, your next request would again be for the OS to allocate indefinite buffers and retry at the expense of anything else on the system so you can keep using the naive version
00:33:52 <Catnaroek> dmwit: For the time being, I just have a toy program, I just realized that I would be using MultiParamTypeClasses quite often.
00:33:59 <geekosaur> and, well, no.  at some point you get told "no, do it right in the first place"
00:34:03 <Catnaroek> But thanks for the proposal as well!
00:35:15 <zzo38> Currently I have this program    http://sprunge.us/HhTg    which uses readProcess but I want to add internet as well (both upload and download).
00:35:16 * geekosaur thinks the documentation for readProcess should mention the deadlock thing, actually; makes note to formulate a doc patch
00:35:29 <zzo38> geekosaur: Yes I agree the document should mention it
00:38:21 <zzo38> It is why, I want to be able to download files in this way from internet in this program, if that option is selected.
00:43:30 <zzo38> And also uploading.
00:45:12 <zzo38> Is there a word games dictionary for Haskell?
00:47:56 <earthy> 'word games dictionary for haskell'?
00:48:36 <dmwit> /usr/share/dict/words
00:49:21 <earthy> or http://wordnet.princeton.edu/wordnet/
00:50:19 <earthy> or http://dreamsteep.com/projects/53-the-english-open-word-list-eowl.html
00:51:49 <earthy> http://wordlist.sourceforge.net/
00:52:08 <zzo38> I will look at that last one, perhaps
00:55:18 <Peaker> In System F/Agda, if you have a Pi (name : String) (paramType : Expression) (resultType : Expression) -- the scope env for pi params and lambda params is the same?
00:55:39 <Peaker> (Is that ok because there are not supposed to be lambdas that enclose Pis?)
00:55:57 * geekosaur finds a library on hackage claiming to do the download part, looks at source, gets headache.  strict bytestring; would be fun to see what happens when someone DoSes it with a multigigabyte file...
00:56:33 <Peaker> because it appears that any type can refer to any runtime value from the enclosing scope, regardless of whether it was declared with a Pi
00:56:36 <Peaker> (which seems like a bug?)
00:56:53 <Peaker> looking at http://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html impl. of System F
01:03:39 <zzo38> What does a Pi (name : String) (paramType : Expression) (resultType : Expression) mean?
01:09:19 <Peaker> zzo38, it's how Pi can be represented within a SystemF implementation
01:09:52 <zzo38> And what is a Pi?
01:10:06 <Peaker> The type of potentially-dependent functions
01:10:38 <Peaker> I think I see though -- types can refer to types of lambda args, but not to their values. They can refer to values of Pi args, within the Pi itself, though
01:12:48 <RylandAlmanza> I'm making a little game in haskell. The program runs completely fine for a while, but eventually crashes with "libgcc_s.so.1 must be installed for pthread_cancel to work"
01:13:00 <RylandAlmanza> Anyone know why this happens?
01:13:14 <RylandAlmanza> I assume the obvious solution is to install the required library
01:14:12 <timthelion> RylandAlmanza: did you get GHC from haskell.org or from your distro?
01:14:27 <RylandAlmanza> distro
01:15:07 <timthelion> RylandAlmanza: seems to me to be a compilation problem.  Like it was compiled against more than one version of libgcc somehow.
01:15:40 <mroman> RylandAlmanza: Do you have a 64bit linux?
01:16:02 <RylandAlmanza> 32bit linux on a 64bit computer
01:16:11 <RylandAlmanza> I'm glad that it's likely not my code
01:16:17 <RylandAlmanza> Compilation problems I can deal with
01:17:23 <mroman> Is libgcc installed on your system?
01:18:22 <mroman> you can test that with 'whereis libgcc_s.so.1' under debian & co.
01:18:34 <mroman> or checking if the file is in /lib/
01:18:56 <mroman> (ls -lah /lib | grep libgcc)
01:19:52 <timthelion> mroman: well, it's probably installed, just under a version different than .1 ...
01:20:32 <timthelion> The probable cause, is that GHC was compiled against libgcc_s.so.1 but RylandAlmanza has a different version.
01:20:58 <timthelion> different version of libgcc that is
01:21:16 <geekosaur> not entirely clear; I think the point of that message is that you might have compiled against a *static* libgcc
01:21:33 <geekosaur> but the dynamic one is necessary for pthread_cancel, probably via dlopen()
01:22:10 <timthelion> geekosaur: if ghc is dynamically loading modules in the middle of a game, that seems like a preformance bug :D
01:24:09 <RylandAlmanza> Thanks guys. So, anything obvious I should try first? Or should I go for a google search?
01:24:14 <geekosaur> timthelion, no doubt, but this is *glibc* loading modules
01:25:37 <mroman> RylandAlmanza: Yes.
01:25:56 <mroman> ls -lah /lib | grep libgcc
01:26:12 <mroman> that will tell us which version is installed on your system.
01:26:18 <geekosaur> and, I suppose you make sure you never touch anything that might involve NSS in some way?  because that is also loaded dynamically as needed
01:26:18 <geekosaur> (never look up users, hostnames, etc.)
01:26:29 <mroman> (asuming that your libraries are in /lib)
01:28:01 <RylandAlmanza> says I only have libgccpp.so.1 which points to libgccpp.so.1.0.3
01:28:32 <mroman> Which distribution do you have?
01:29:37 <mroman> on debian/ubuntu you could try installing libgcc through apt-get install libgcc1
01:30:09 <mroman> on other distributions I don't know. Consult your local package manager :)
01:38:46 <kallisti> SqlError {seState = "E", seNativeError = 7, seErrorMsg = "execute: PGRES_FATAL_ERROR: connection pointer is NULL\n"}
01:38:48 <womb> yesterday i was playing with HandsomeSoup and i got ownd by Arrow ;/ i wanted to extract part of tree and have a pure function to parse it using their css ;/
01:38:51 <womb> Hi all!
01:38:54 <kallisti> anyone ever had this error when working with HDBC-postgresql?
01:39:11 <womb> kallisti: it is simple, he cant connect ;]
01:39:22 <kallisti> typically it gives better info than that..
01:39:27 <womb> or you do not have connection in scope
01:39:44 <womb> can you put this line into hpaste ?
01:39:57 <womb> i think he wants to use your connection but he don't have it in scope
01:40:20 <kallisti> in scope?
01:40:27 <geekosaur> that does sound like you're doing something without a valid connection
01:40:38 <kallisti> yes it's already connected
01:40:41 <kallisti> it fails on an INSERT
01:40:42 <womb> yeah so you have opened connection yes ?
01:40:53 <womb> can you show this bit of code ?
01:45:20 <kallisti> womb: I don't know what kind of info it would provide. I INSERT within a transaction.
01:46:22 <kallisti> hm
01:46:30 <kallisti> so the connection is getting freed perhaps?
01:47:11 <kallisti> it's within a Wx GUI, so it could be that withPostgreSQL is actually exiting before the main loop starts?
01:47:29 <kallisti> I'm not sure how the "main loop" works with regard to the things called immediately after it.
01:48:34 * geekosaur would stronlyly suspect that yes, the connection is freed before the main loop is engaged
01:49:17 <kallisti> I'll try without the with*
01:49:34 <geekosaur> use connectPostgreSQL and either stow in a global (ugh) or in state that GUI callbacks can access
01:49:35 <timthelion> kallisti: threads?
01:50:21 <geekosaur> GUIs and threads don't typically mix (in particular X11 is bad at threaded)
01:50:28 <womb> yes exactly it can be "out of scope" and GC simply frees it.
01:50:52 <kallisti> I don't use any threads myself.
01:50:58 <geekosaur> (it can do them, with the right call, but does it the lazy way and grabs a Big Giant Lock mutex on every call)
01:51:15 <timthelion> geekosaur: this is no reason not to fight the good fight.  But more importantly, when are we going to fix this crap?  This puts us decades behind M$ :(
01:51:40 <timthelion> threads are wonderful things.
01:52:25 <geekosaur> xcb fixes it to some extent but I am under the impression gtk2 is libX11 based.  gtk3 is xcb/wayland hence better at threads, but I don't think wxwindows has been ported to gtk3 yet
01:52:29 <kallisti> yep that was the issue.
01:52:41 <kallisti> which is strange because it was working with the exact same connection function earlier.
01:52:59 <earthy> um, M$ *also* still has one giant big lock around the UI
01:53:18 <earthy> worse, you can not update the UI from any thread other than the so-called dispatcher thread
01:53:24 <timthelion> earthy: what about those videos of two people using a table top at the same time?
01:53:27 <earthy> err, UI dispatcher thread.
01:53:29 <geekosaur> in any case, it's still orthogonal to the main loop's callbacks getting invoked in a different context from the one that has the database connection
01:53:35 <mroman> earthy: That somehow makes sense to me.
01:53:42 <earthy> timethelion: singlethreaded UI
01:53:45 <shachaf> Is this really going to be a channel that spells it "M$"?
01:53:50 <mroman> At least in .NET you can invoke functions in the UI-Thread.
01:54:00 <coppro> I got through that phase years ago
01:54:10 <earthy> sorry, you prefer MS?
01:54:18 <geekosaur> point, lose the condescending reference.  try to remember who funds GHC development
01:54:23 <earthy> or should I spell it in full, MicroSoft?
01:54:36 <mroman> earthy: MS or Microsoft I guess are ok.
01:54:47 <mroman> as geekosaur said, a lot of ghc goes on in microsoft research centers ;)
01:54:50 * earthy does .net for a living so I've got no beef. ;)
01:55:11 <mroman> F#, I hope !
01:55:15 <earthy> C#
01:55:18 <mroman> :(
01:55:21 <timthelion> I don't know.  My father worked(past tense).  And when he worked(past tense) he worked at M$.  So the $ makes perfect sense to me...
01:55:59 <earthy> ah, it's not too bad. C# has pretty good support for functional programming, as OO languages go
01:56:32 <timthelion> C# is a wonderful language.
01:56:34 <mroman> F# actually has OOP.
01:56:37 <zzo38> Well, yes, many of the papers written for Haskell are in Microsoft I have seen it; but Haskell is not really a part of Microsoft, it is a separate project
01:56:54 <earthy> haskell is MSR, MSR is *great*
01:57:17 <earthy> but used to be mostly separate from Microsoft
01:57:27 <Peaker> timthelion, "wonderful" is a relative term :)
01:57:41 <earthy> well, it is full of wonder... :P
01:57:57 <earthy> 'I wonder... yup...'
02:08:26 <zzo38> How would I add the internet function into this program I made? I would want to be able to download the list and quiz files from gopher to local and upload quiz file from local computer to sprunge
02:13:30 <timthelion> zzo38: :D
02:14:05 <sipa> gopher... sure
02:14:53 <timthelion> sipa: wget supports gopher I think.
02:15:07 <timthelion> no clue what sprunge is
02:15:14 <timthelion> have to look in my history text book
02:15:33 <geekosaur> it's a pastebin.  gopher support would seem odd
02:15:57 <timthelion> geekosaur: zzo38 is a bit odd, if you hadn't noticed.
02:16:12 <zzo38> Sprunge is HTTP POST to http://sprunge.us/ with a field "sprunge" containing the data, and then it returns the URL where you can download it.
02:16:35 * geekosaur declines bait
02:17:55 <zzo38> Whether or not wget supports gopher is irrelevant.
02:18:11 <timthelion> zzo38: no it's not, haskell can execute cli programs
02:18:46 <zzo38> timthelion: Yes, I know, and the program I posted does so. But I am trying to avoid relying on more external programs than needed
02:19:01 <timthelion> zzo38: but if you want to add the internet to haskell, you'll need more than one computer, or at least some virtualization software, like qemu
02:19:17 <zzo38> I am not trying to "add the internet to haskell"
02:19:39 <timthelion> ^_^
02:20:38 <timthelion> zzo38: you see, the thing is that we have httpget functionaliyt. but gopher is a bit... um. how do I say this. Like, you know when your mother starts going deaf and forgeting if she left the stove on?
02:20:57 <hpaste> xraycat pasted “room for improvement (?)” at http://hpaste.org/69248
02:21:24 <zzo38> But to do what I said like readProcess, it would be like readProcess calling netcat; I just wanted to avoid an external program
02:21:25 * geekosaur wonders if zzo38 even intended the gopher we're thinking of, or something else unrelated
02:21:39 <xraycat> stats like those aren't usually a good sign, are they? ^^
02:22:27 <geekosaur> also, to the extent that there are bindings for what you want in haskell, they're libcurl bindings => you still have an external dependency.  nobody's reimplementing existing ecosystems in haskell for you, and even if they did, they'd still be dependencies...
02:23:30 <timthelion> geekosaur: if haskell had direct serial TCP/IP support, implementing gopher can't be hard can it?
02:23:47 <geekosaur> network still isn't a bootlib...
02:24:07 <bas_> when writing in the applicative style, is either <$>/<*> or fmap/liftA preferred?
02:24:37 <geekosaur> I generally see the infix operators being used
02:24:56 <bas_> okay
02:25:06 <timthelion> bas_: just make your code as unreadable and mathy as possible, it'll look better on your resume that way.
02:25:44 <bas_> yes as a webdesigner it will land me a great job I bet
02:25:45 <rlpowell> I can't seem to get cabal to do anything today; running Fedora packages for ghc 7.0.4 and cabal 0.10.2, and it seems that everything I try ends up looking like this:  http://pastie.org/private/tw1mlrbsmzb5ycosapqra (i.e. "time" won't install, and it has some sort of dependency failure on Cabal-1.10.2 itself)
02:25:50 <rlpowell> Any ideas?
02:26:08 <danr> bas_: I'd go for infix, but I would write liftA foo rather than (foo <$>)
02:26:21 <bas_> agreed
02:26:22 <danr> i.e. I'm not very fond of <$> and <*> sections
02:26:57 <zzo38> If I need to, I could use external netcat. There is a problem that some require -q -1 and others don't require that
02:27:32 <bartavelle> hello, here is a topic I am clueless about : how to make things strict
02:27:35 <bartavelle> I wrote this
02:27:35 <bartavelle> http://hpaste.org/69249
02:28:16 <bartavelle> it parses a tsv file made of an URL, and the time it took to process. I group the times by URLs (with a map) and compute statistics
02:28:57 <geekosaur> rlpowell, this looks like you overrode a bootlib somewhere (directory and/or old-time are likely but not certain) and that will derange cabal-install rather badly.  you can recover by moving ~/.ghc somewhere out of the way, unless the install was done into the global package registry in which case you need to reinstall ghc
02:28:58 <Philippa> danr: I'm half tempted to tweak my editor to provide syntax lowlighting for them
02:29:07 <bartavelle> I believe the line "parsed = map parseline x" generated all thunks (whatever that might be), and only when it is over does the Map starts collecting stuff
02:29:12 <Philippa> as in "you should notice these are here, but they're totally not the centre of attention"
02:30:00 <danr> Philippa: that's quite a good idea really
02:30:11 <bartavelle> if anyone has a clue ...
02:30:17 <xraycat> bartavelle: did you take a lookt at? http://www.haskell.org/haskellwiki/Performance/Strictness
02:30:20 <kallisti> bartavelle: I doubt that's what's happening
02:30:31 <kallisti> bartavelle: are you getting any specific performance issues?
02:30:35 <ClaudiusMaximus> xraycat:  repeated use of  length l > k  smells a bit, also bang patterns on lists are mostly useless (they only force to the first (:))
02:30:39 <rlpowell> geekosaur: OK, thanks. I *do* have things I want to install that want old-time ; how do I deal wath that?
02:30:41 <bartavelle> yeah, gigabytes of memory used
02:30:49 <teneen> Does this function "MonadPlus m => (a -> b -> m c) -> [a] -> [b] -> m [c]" exist somewhere? (a zipWithM for lists of equal length)
02:31:03 <bartavelle> xraycat, ok, I'm looking at it right now
02:31:35 <kallisti> bartavelle: for what size file.
02:31:49 <danr> teneen: what's with the monadplus?
02:31:59 <bartavelle> about 100 mb
02:32:09 <xraycat> ClaudiusMaximus: it provided a small speed up, k is usually pretty small
02:32:31 <rlpowell> geekosaur: Also, there's no way to jsut uninstall old-time or similar?
02:32:42 <teneen> danr: because the lists should be of equal length
02:32:46 <kallisti> bartavelle: if you ran a profile test you could see exactly where the memory is being allocated
02:33:13 <bartavelle> Hum, ok, I did just run the prof thingie
02:33:29 <geekosaur> rlpowell, old-time is a bootlib, you do not need to install it
02:33:57 <geekosaur> it comes with the compiler.  if you are installing it manually, you are shooting yourself in the kneecaps; bootlibs (required by the compielr) should not be overridden
02:34:27 <rlpowell> Huh!  OK.  But packages wouldn't install because they wanted a particular version from hackage.
02:34:34 <geekosaur> as for uninstalling, well, http://ivanmiljenovic.wordpress.com/2010/03/15/repeat-after-me-cabal-is-not-a-package-manager/
02:34:46 <rlpowell> Why does hackage even *have* those packages, then?
02:34:53 <geekosaur> then you need to find versions of those packages compatible with your ghc
02:35:04 <geekosaur> because your version of ghc is not the only one, or the only supported one
02:35:15 <rlpowell> Got it.  I'll read the article you linked, as I seem to be confused.  Thanks.
02:35:58 <geekosaur> and unless you have the most recent cabal-install (which I think still needs a manually override to install, sigh) it is very stupid about shooting itself, and therefore you, in the foot in such cases
02:36:00 * hackagebot imagepaste 0.2.0.0 - Command-line image paste utility  http://hackage.haskell.org/package/imagepaste-0.2.0.0 (YuriBochkarev)
02:36:09 <geekosaur> er, manual override
02:36:30 <rlpowell> Yeah, it's not obvious how to upgrade cabal-install on my system at all.  -_-
02:36:37 <timthelion> erum, basically cabal sucks. :D
02:36:46 <rlpowell> Compared to what?
02:36:52 <kallisti> bartavelle: if it's saying that parseLine is building up thunks, then that means that its consumers aren't fully evaluating the output its producing
02:37:12 <kallisti> in general terms. I can't tell exactly where that's occuring.
02:37:30 <geekosaur> it's not that it sucks, it's that it is a helper for ghc-pkg which is also not really a package manager and will probably never be made capable of being one (because the ghc devs are not in the package manager business)
02:37:56 <geekosaur> and there's only so much that cabal-install can hack on top of it, especially if it alao wants to try to support other implementations
02:37:57 <timthelion> rlpowell: In a not so strickly typed programming language, the problems of cabal are solved by most library versions being magically backwards compatible.  In haskell things aren't so easy, and it causes us pain.
02:38:04 <timthelion> strictly
02:38:41 <mroman> That's what I hate about haskell.
02:38:55 <mroman> You can't change one data ... without rewriting every function that uses it.
02:38:57 <timthelion> if there was *any* version to version compatiblity of libraries it would solve a lot of problems.
02:39:23 <mroman> all pattern matching breaks
02:39:38 <mroman> and everything else too
02:39:46 <timthelion> mroman: proper record selection can help a lot.  If you do some tricks it can even be type safe.
02:40:08 <kallisti> clever library design helps too
02:40:10 <mroman> I sometimes even do stuff like
02:40:31 <mroman> dummy data fields.
02:40:35 <mroman> "reserved"
02:40:44 <mroman> so I can add stuff later without breaking pattern matching.
02:40:55 <timthelion> mroman: record selectors are better I think.
02:41:07 <kallisti> OO encapsulates for you, that's why it's easier to change things around in the internals. A good Haskell library should encapsulate internals as well; it's just not as idiot-proof to do so.
02:41:10 <zzo38> I have made up a way to allow data fields to be added to a record in other modules which do not know each other. However, pattern matching doesn't work with it.
02:41:17 <mroman> timthelion: Can I match against record selectors?
02:41:29 <mroman> like
02:41:30 <timthelion> mroman: yes, with case's
02:41:37 <mroman> data Foo = Bar Int String
02:41:50 <mroman> baz (Bar 0 a) = 0
02:42:08 <mroman> timthelion: But not at function top level?
02:42:11 <danr> baz (Bar{ barInt = 0, barString = a }) = ...
02:42:28 <kallisti> pretty sure parens aren't necessary there.
02:42:35 <mroman> danr: Thanks.
02:42:43 <mroman> That would do the trick, yes.
02:42:46 <timthelion> mroman: baz x@Bar{} = case x of Bar 0 a -> fsdkfds ; Bar _ a -> kjfdsla...
02:42:51 <mroman> If I don't have to use every selector.
02:42:56 <kallisti> apparently a large number of people don't know that you can pattern match on record fields.
02:42:56 <timthelion> danr: really :D
02:43:06 <kallisti> by "a large number" I mean the 2 people I've sampled.
02:43:07 <danr> kallisti: oh right, the parens are probably redundant
02:43:08 <timthelion> cool
02:43:11 <danr> mroman: np :)
02:43:39 <danr> mroman: you might want to look at NamedFieldPuns and RecordWildCards as well
02:43:51 <kallisti> historic day: someone said that a feature of record syntax was cool.
02:43:54 <mroman> I certainly will :)
02:44:01 <danr> which lets you write Bar{..} to get the selectors in scope, or Bar{barInt} to get barInt in scope...
02:44:40 <mroman> When coding GUIs I usually stuff everything in one big data
02:44:46 <zzo38> I use record syntax sometimes, too
02:44:47 <mroman> which i stuff into an IORef and pass that around.
02:45:02 <timthelion> mroman: that's evil :D
02:45:06 <kallisti> a lot of libraries use "opaque" types precisely because it makes changing internals easier.
02:45:07 <mroman> I know.
02:45:11 <mroman> But what can I do?
02:45:16 <mroman> Functions need access to the gui
02:45:32 <mroman> I could wrap it into MonadStateT I guess somehow.
02:45:50 <timthelion> mroman: wait 6 months and I'll have an answer for you.  I'm using a better way in an application I'm writting.  I'll write a paper on how when I'm done.
02:46:03 <zzo38> Look at my "extensible-data" package, and then use something like   StateT (ExtProd p) IO    monad, although I don't know if that is efficient enough
02:46:29 <zzo38> If you do not need extensible data, you can just use    StateT x IO
02:46:29 * timthelion has reimplemented OO for haskell :D
02:46:38 <mroman> timthelion: Keep me posted.
02:46:46 <zzo38> timthelion: How is it?
02:47:59 <zzo38> Is there a way to make a type that can have only prime numbers, without having to count primes at runtime?
02:48:03 <mroman> Although I have no idea how you would do that.
02:48:18 <timthelion> Look at ThreadObjects and GridEditorObjects.  I pass around GridEditorObjects, and the "update" the ThreadObjects.  It's all thread safe. https://github.com/timthelion/gridhaskell-haskarrow
02:48:20 <mroman> Gtk callbacks need a reference to the gui.
02:48:48 <mroman> else they can't read textfields or change the gui when an event occured.
02:49:52 <Twisol> I have a design question. Lets say I'm reading some protocol from a socket, and there's a possibility that at some point it will become compressed and require decompression. The compression acts on the whole stream, but the signal for the compression is a command sequence in the protocol. How do I build a pipeline like this such that I can enable/disable decompression?
02:50:22 <zzo38> And, a type of a function with natural number as input and output but that the output must not be greater than the input?
02:50:31 <Twisol> *start signal
02:50:48 <rlpowell> geekosaur: That article's suggestion of "use your OS's package management system" isn't going to help me get yesod installed.  -_-
02:51:07 * rlpowell tries cabal-dev
02:51:20 <danr> timthelion: nice usage of lhs
02:51:21 <geekosaur> rlpowell, the first step there I think is "throw out your ghc and start with 7.4.1"
02:51:25 <danr> maybe I should start using that
02:51:53 <geekosaur> you might wait a couple days for the next haskell platform (or install the release candidate)
02:51:58 <timthelion> danr: elsewhere, it's just all code... I'm not very consistent with that.
02:52:21 <rlpowell> 30-02:50 < geekosaur> rlpowell, the first step there I think is "throw out your ghc and start with 7.4.1" -- A package my OS *also* doesn't have.  :)
02:52:31 <rlpowell> But *nod*, regardless.
02:52:37 <geekosaur> exactly
02:52:47 <rlpowell> cabal: cannot configure old-time-1.1.0.0. It requires base >=4.4 && <5 For the dependency on base >=4.4 && <5 there are these packages: base-4.4.0.0, base-4.4.1.0 and base-4.5.0.0. However none of them are available. -- yay.
02:52:51 <zzo38> And, type of lists that remember if they are infinite or not?
02:52:53 <rlpowell> geekosaur: Exactly which?
02:53:23 <geekosaur> yesod stays close to the bleeding edge, you really can't get away with any OS packages including (for most OSes/distributions) the compielr package
02:53:33 <danr> timthelion: maybe I should fork your project and do the line lengths < 80 chars ;)
02:53:43 <danr> reading of fnf
02:53:43 <rlpowell> geekosaur: Ah.  Good to know, thanks.
02:54:07 <timthelion> danr: hehe
02:54:43 <geekosaur> it will briefly be possible to work with yesod with the next haskell platform but I expect it will continue to evolve past what the platform provides at a fairly fast clip (even if Snoyman hopes otherwise...)
02:54:51 <timthelion> danr: please note, that I'm not anywhere near done
03:01:07 * hackagebot imagepaste 0.2.0.1 - Command-line image paste utility  http://hackage.haskell.org/package/imagepaste-0.2.0.1 (YuriBochkarev)
03:07:15 <sayuke> i know theres a way but its been a while. how do you pattern match without splitting up the data. something like f (foo=Data a b) = foo
03:07:18 <sayuke> im using record syntax
03:07:55 <path[l]> why cant I do [1, 2, .. (p `div` c)] where p and c are defined?
03:08:00 <timthelion> sayuke: like f foo@Data...?
03:08:35 <nand`> > let p = 8, c = 2 in [1, 2, .. (p `div` c)]
03:08:36 <lambdabot>   <no location info>: parse error on input `,'
03:08:40 <nand`> uh
03:08:42 <nand`> > let p = 8, c = 2 in [1, 2 .. (p `div` c)]
03:08:43 <lambdabot>   <no location info>: parse error on input `,'
03:09:02 <adamt> What's the preferred markdown library not licensed under the GPL? (eg. not pandoc..)
03:09:11 <path[l]> oh
03:09:13 <path[l]> comma
03:09:18 <path[l]> sorry, that was silly
03:09:20 <path[l]> thanks
03:09:21 <sayuke> timthelion: that was it. thankyou. couldnt find that for the life of me
03:09:38 <nand`> oh, I messed up twice
03:09:42 <nand`> > let p = 8; c = 2 in [1, 2 .. (p `div` c)]
03:09:43 <lambdabot>   [1,2,3,4]
03:09:44 <nand`> there we go
03:11:12 <fmap> > let p = 8; c = 2 in [1, 2 ..  p `div` c]
03:11:13 <lambdabot>   [1,2,3,4]
03:13:17 <alpounet> adamt, well, is there another one?
03:18:08 <adamt> alpounet: I think that is the question.
03:18:32 <adamt> There's sundown, for one.
03:20:34 <alpounet> adamt, sundown looks okay, and it's Public Domain
03:20:39 <Peaker> I knew get = id, but I just discovered gets=id too, heh
03:20:43 <Peaker> @type gets
03:20:44 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
03:21:29 <adamt> alpounet: Which still leaves the (admittedly rather open) question about the best non-gpl alternative to pandoc. But yeah, it does look okay. :)
03:25:05 <bitonic> adamt: if you need markdown only, I wrote bindings to sundown: hackage.haskell.org/package/sundown
03:25:54 <bitonic> oh, alpounet already mentioned it
03:25:59 <adamt> bitonic: I already have it up and running (somewhat, not the fault of sundown), i was just wondering whether it was THE alternative to pandoc :)
03:26:30 * adamt is having a battle with yesod's Textarea that also wants to turn content into HTML
03:27:16 <bitonic> adamt: well it's not even close to sundown in functionality. but markdown -> html is what most people need in webdev
03:27:42 <bitonic> and sundown itself is a good, battle tested library
03:28:38 <bitonic> sorry, it's not close to pandoc in functionality.
03:28:59 <adamt> But simple markdown is fine, just need basic markup :)
03:29:42 <bitonic> well then sundown will serve your needs.
03:30:21 <adamt> Nice to hear.
03:31:29 <bitonic> sundown is pretty rich in markdown functionality actually, the "problem" is that it only does md to html
03:32:24 <adamt> does it output html or xhtml?
03:33:15 <bitonic> html, they changed a while ago. I'm not sure about the details, the best thing is to try
03:33:16 <kishore> hello there
03:33:48 <kishore> can anyone brief what functional programming is
03:33:55 <adamt> will do, after rebuilding everything. installing yesod-markdown broke everything. :P
03:34:12 <adamt> kishore: http://en.wikipedia.org/wiki/Functional_programming ;)
03:34:22 <kishore> i tried googling.. but with full math
03:34:37 <kishore> thanks adamt
03:43:46 <mcstar> functional programming is the opposite of useless programming afaik
03:44:38 <adamt> That's certainly one way to put it.
03:44:52 <Peaker> you mean the opposite of dysfunctional programming?
03:45:45 <Urchin> lol
03:47:15 <nand`> functional programming is programming by applying, abstracting and combining functions
03:47:28 <nand`> imperative programming is programming by modeling state and state transitions
03:47:33 <nand`> (the two are not mutually exclusive)
03:47:41 <merijn> I prefer the name "value oriented programming"
03:47:49 <sipa> haha!
03:47:50 <adamt> functional programming is programming in a way your collegues don't understand.
03:48:08 <merijn> As it deals with data and transitions between data, rather than state-to-state transition
03:48:18 <Urchin> functional programming is when you have a bunch of functions
03:48:35 <nand`> merijn: there's also the matter that functions themselves are values; which is something not intuitive in imperative languages
03:48:44 <merijn> The fact that "transitions between values" == functions and the fact that functions == values
03:48:51 <bitonic> to be fair, functional programming is a pretty vague. "equational reasoning" might be a better term to describe one of haskell core values
03:49:01 <merijn> nand`: I beg to differ, a lot of imperative languages have first class functions
03:49:18 <merijn> Examples: Ruby (blind guess), python, Go
03:49:22 <sipa> and a lot of imperative languages allow functional programming
03:49:48 <nand`> merijn: yes; it's common now - that's not my point
03:50:09 <sipa> imperative programming means specifying code flow, and hoping that the resulting values make sense
03:50:12 <merijn> "common now", okay, so how about Lisp?
03:50:37 <sipa> functional programming means specifying data flow, and hoping that the resulting execution makes sense
03:50:44 <nand`> merijn: how about assembly?
03:50:49 <mcstar> in functional land, usually every return value matters, and thats the effect of calling a function, its return value, so a program can only be built up by nesting and branching
03:51:17 <merijn> nand`: Lisp is from the fifties, so saying that first class functions are only common in modern non-functional languages is wrong\
03:51:51 <nand`> merijn: (ignoring the fact that a single language doesn't necessarily make something “common”)
03:52:18 <merijn> Lisp is hardly a single language, but ok
03:52:37 <nexx> first class funcitons common in non-functional languages?
03:52:43 <merijn> Incidentally, first class functions are almost trivial in assembly
03:53:05 <mcstar> btw, i think Paul Graham wrote, how imperative and functinal programs look different, functional ones look nested(i.e. frequently indented) while imperative ones look block structured
03:53:28 <merijn> nexx: Well, ruby, python, go, C++, javascript, Java (in some indeterminate future version, I think they've pushed back to 8)
03:54:31 <merijn> nexx: (lisp/scheme too), and probably more languages that I'm not currently familiar with
03:55:24 <nexx> merijn you consider lisp/scheme as non-functional?
03:55:27 <bxc_> anyone use the fastcgi package recently? fastcgi programs are timing otu for me...
03:55:27 <merijn> The only languages I know for sure don't have them are C (where you can sorta fake it using function pointers), asm and (maybe?) Objective-C
03:55:51 <merijn> nexx: Lisp certainly, scheme...depends who I'm talking to?
03:56:09 <mcstar> lisp is functional but impure
03:56:21 <merijn> nexx: Neither pay much attention to referential transparency
03:56:32 <mcstar> you call most of the functions for their reuturn values
03:56:40 <merijn> mcstar: Only for definitions of functional that are wide enough to be practically meaningless
03:57:07 <nand`> What's the most common word for something that's like a function but isn't pure? Procedure? Or is that too general?
03:57:15 <popx_>  /names
03:57:36 <mcstar> you would tighten the definition of 'functional' just because popular languages started to integrate some of its goodies?
03:58:01 <nexx> merijn I'm at the end of my bachelor in cs. I never used Lisp and Scheme (actually DrScheme) only in my first semester
03:58:19 <nand`> Perhaps “semi-functional” since not everything has side effects
03:58:22 <merijn> mcstar: No, I would tighten it to a set that is sufficiently specific that it is worth talking about in more detail
03:58:58 <merijn> nexx: If you get Scheme during your bachelor they usually teach (or at least start with) a functional subset of the language
03:59:22 <merijn> So in that scenario you could qualify Scheme as being functional
03:59:29 <nexx> ok
03:59:49 <merijn> As I said, it's a bit (and by a bit I mean "a lot") ambiguous :p
04:00:41 <merijn> mcstar: I'm not sure there is much you can say about the functional languages (including Scheme/Lisp) that doesn't also hold for all languages in general
04:00:42 <mcstar> merijn: so what exactly is your definition? (btw, didnt we have this conversation before? i have a very strong deja vu)
04:01:07 <merijn> mcstar: I haven't had this conversation before, but I've seen it before :p
04:02:22 <merijn> I would argue that the most sensible key distinction would be referential transparency or lack thereof
04:03:07 <mcstar> since im a newbie, ill ask this, do you consider the IO monadic operations pure? i guess it should be, since you are 'threading the state' right?
04:03:37 <merijn> I consider the semantic of IO in haskell pure, its implementation is not
04:04:10 <merijn> Then again, there is no "pure" implementation of any language as it all runs as machine code on machines that are impure in reality that is impure :p
04:04:18 <cizra> Hi! I can't install Agda because haskell-src-exts fails to compile. Mentions something about a deprecated testing interface.
04:05:10 <merijn> That's a common trip-up, I think. Many people think that "impure implementation" means the thing implemented is necessarily also impure, which I don't think makes any sense.
04:05:23 <hpc> cizra: what version of ghc, haskell-src-exts?
04:05:31 <hpc> hackage says the latest builds fine on 7.4
04:05:34 <mcstar> merijn: if scoping permits shadowing indentifiers, does this still mean it is referentially transparent?
04:06:11 <hpc> mcstar: yes; you can always α-rename to remove shadowing
04:06:42 <merijn> Sure, names are a thing for humans. On a conceptual level you'd want to use De Bruijn indices or something similar so that there is no shadowing ever
04:07:05 <merijn> Humans are just a lot better at names than they are at De Bruijn indices :p
04:07:07 <mcstar> somehow, it feels like shadowing requires ordering
04:07:22 <mcstar> but probably im mistaken
04:07:25 <nexx> merijn to add to your list of languages without first class functions (afaik): visual basic, pascal, msl, php (you can sorta fake it using meta programming), sql
04:07:37 <gienah> cizra: not really sure, but we do tweak it a bit, see patches in the files directory: https://github.com/gentoo-haskell/gentoo-haskell/tree/master/sci-mathematics/agda
04:08:14 <cizra> hpc: The Glorious Glasgow Haskell Compilation System, version 7.4.1
04:08:27 <cizra> /tmp/haskell-src-exts-1.13.3-16979/haskell-src-exts-1.13.3/Setup.hs:1:1:
04:09:07 <ski> > let permutations ([ ],~[    ]) = return ([],[]); permutations (yxs,~(y:ys)) = exists $ \xs -> do {(y,yxs,xs) <- select (y,yxs,xs) ; (xs,ys) <- permutations (xs,ys); return ((yxs,y:ys),xs)}; exists x_ax = liftM fst . mfix $ \ ~(_a,x) -> x_ax x; setXs xs ~(_xs,ys) = (xs,ys) in mfix (permutations . setXs "abc") :: [(String,String)]
04:09:08 <lambdabot>   [("abc","abc"),("abc","acb"),("abc","bac"),("abc","bca"),("abc","cab"),("ab...
04:10:06 <bitonic> that's a long one liner
04:10:19 <cizra> Oh my. I was missing Happy!
04:10:51 <ski> bitonic : using a crazy (but apparently working) idea of mine ..
04:11:20 <hpc> cizra: were you using cabal install, or Setup.hs? cabal knows what depends you don't have ;)
04:12:05 <ski> i model a Prolog predicate taking `(xs,ys)' as a function taking `(xs,ys)' and (nondeterministically) *returning* `(xs,ys)' (the "same" value)
04:12:37 <ski> then i use `mfix' to pass the output back into the input
04:12:55 <hpc> ski: ooh
04:13:25 <nand`> tgeeky: ping
04:13:34 <ski> if i'm careful not to look at the input too early, then the input will become the output -- otherwise it'll hang itself
04:13:53 <ski> > let select (_,     [       ],_ ) = mzero; select (x,xxs0@(x0:xxs1),xs) = return (x0,xxs0,xxs1) `mplus` do {(x,xxs1,xs) <- select (x,xxs1,xs); return (x,xxs0,x0:xs)}; setXXs xxs ~(x,_xxs,xs) = (x,xxs,xs) in mfix (select . setXXs "abc") :: [(Char,String,String)]
04:13:55 <lambdabot>   [('a',"abc","bc"),('b',"abc","ac"),('c',"abc","ab")]
04:13:58 <ski> > let append (~[     ],~[],      [      ]) = return ([],[],[]); append (~(_x:xs), ys,xsys0@(x:xsys)) = return ([],xsys0,xsys0) `mplus` do {(xs,ys,xsys) <- append (xs,ys,xsys); return (x:xs,ys,x:xsys)}; setXsYs xsys ~(xs,ys,_xsys) = (xs,ys,xsys) in mfix (append . setXsYs "abc") :: [(String,String,String)]
04:14:00 <lambdabot>   [("","abc","abc"),("a","bc","abc"),("ab","c","abc"),("abc","","abc")]
04:14:05 <ski> is two other examples
04:14:35 <ski> the first nondeterministically selects an element from a list, also computing the remainder
04:14:49 <ski> the second nondeterministically splits a list into two halves
04:15:04 <ski> (such that appending them would yield the original list)
04:15:05 <bitonic> ski: I'll read at proper code when/if you'll upload somewhere
04:15:35 <bitonic> reading that is pretty painful :D
04:15:55 <ski> (you could always copy and paste, and replace `;' with newline ..)
04:18:45 <cizra> hpc: I was using cabal install, but still it didn't miss happy.
04:23:36 <bitonic> ski: sure, but I might copy them in a file :)
04:28:03 <ski> lo Paprikachu
04:30:41 <path[l]> I have a question about composition. If I do sum $ map (\x -> x*x) [1,2,3], how can I write that as sum.map ?
04:31:08 <ski> > (sum .: map) (^ 2) [1,2,3]
04:31:10 <lambdabot>   14
04:31:31 <ski> > ((sum .) . map) (^ 2) [1,2,3]
04:31:33 <path[l]> oh, why does it need brackets around sum.map. Does . have a lower precedence than function application
04:31:33 <lambdabot>   14
04:31:44 <ski> > ((sum .)  map (^ 2)) [1,2,3]
04:31:45 <lambdabot>   Couldn't match expected type `[t -> t1]'
04:31:45 <lambdabot>         against inferred type `[a]...
04:31:54 <hpc> path[l]: all infix operators have lower precedence than function application
04:32:00 <ski> > (sum . map (^ 2)) [1,2,3]
04:32:02 <lambdabot>   14
04:32:04 <path[l]> aha
04:33:15 <bas_> hlint often gives incorrect suggestion when it concerns "redundant brackets", especially after infix ++
04:33:23 <bas_> is there a way to prevent this?
04:33:42 <fmap> > (sum . map (join (*))) [1,2,3]
04:33:44 <lambdabot>   14
04:34:18 <fmap> bas_: you can blacklist suggestions
04:34:30 <hpaste> path pasted “euler 31 - 2” at http://hpaste.org/69255
04:34:39 <path[l]> how can I make this code more elegant
04:34:46 <path[l]> I dont like my map
04:36:23 <Botje> could use a list comprehension
04:37:05 <path[l]> hmm
04:37:10 <path[l]> ah I see
04:37:11 <path[l]> ok
04:37:50 <fmap> bas_: something like `hlint $file --ignore="Redundant bracket"'
04:37:52 <Paprikachu> [13:25:31]	<ski>	lo Paprikachu
04:37:53 <Paprikachu> hm?
04:38:07 <bas_> fmap the thing is, sometimes it's quite useful
04:38:14 <bas_> but at different times it is simply incorrect
04:38:44 <bas_> I'll have to deal with it either way
04:39:36 <fmap> well that's strange since hlint thinks redundant bracket is `error'
04:40:15 <ski> 17:52 < Paprikachu> hi ski
04:40:25 <Paprikachu> ah ^^
04:40:29 <bas_> fmap let me try to find an example
04:40:52 <ski> bas_ : hm, do you have an example of bad suggestion with `++' ?
04:41:27 <ski> fmap : yeah, it should be "style warning"
04:42:01 <merijn> path[l]: Another good improvement would be to move some parts of your map function to a where clause
04:42:20 <merijn> path[l]: For example, the lambda function is a good candidate
04:43:06 <path[l]> right, I guess I was trying to play golf here. But let me try the list comprehension approach first
04:43:16 <ski> path[l] : there is no point in using `$' there
04:43:47 <ski> oh, actually there is
04:43:50 <merijn> ski: There is
04:43:52 <ski> (the `sum.map'
04:44:09 * ski forgot that we talked about that just befre
04:44:11 <path[l]> if I remove it, I'll need to bracket the whole sum.map section I guess
04:44:22 <ski> yes
04:44:32 <Paprikachu> > forever $ do ;
04:44:33 <lambdabot>   <no location info>: Empty 'do' construct
04:44:39 <ski> one could define a `sumMap' function here
04:44:40 <path[l]> I find brackets distracting, so I try to get rid of them when possible
04:44:43 <Paprikachu> > forever $ do return ();
04:44:44 <lambdabot>   No instance for (GHC.Show.Show (m b))
04:44:45 <lambdabot>    arising from a use of `M2635889092...
04:44:49 <path[l]> ski: oh right
04:44:53 <Paprikachu> :(
04:45:09 * ski finds `$' is usually (not always) more distracting than brackets
04:45:31 <Paprikachu> how can i make this work?
04:45:31 <ski> > forever $ fo return () :: Maybe Int
04:45:33 <lambdabot>   Not in scope: `fo'
04:45:37 <ski> > forever $ do return () :: Maybe Int
04:45:38 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
04:45:38 <lambdabot>         against inferred type ...
04:45:48 <ski> @type forever
04:45:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
04:45:57 <Paprikachu> whatever.
04:46:30 <ski> > forever $ do return () :: Maybe ()
04:46:34 <lambdabot>   mueval-core: Time limit exceeded
04:46:46 <Paprikachu> ... whatever this means.
04:46:53 <ski> it means it hangs
04:47:00 <Paprikachu> i mean your code
04:47:18 <hpc> forever $ do return () = return () >> return () >> return () >> ........
04:47:22 <ski> the `:: Maybe ()' constrains the `return ()' to be of type `Maybe ()'
04:47:36 <ski> Paprikachu : it complained because it couldn't infer which monad to use
04:47:46 <ski> i told it to use the `Maybe' monad
04:48:05 <Paprikachu> mkay
04:48:13 <Paprikachu> i still dont understand that monad stuff
04:48:26 <ski> > execWriter . forever $ do tell "hi"
04:48:27 <fmap> btw do is redundant
04:48:28 <lambdabot>   "hihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihi...
04:48:36 <Botje> Paprikachu: welcome to the middle of the haskell learning curve.
04:48:45 <Botje> you will spend quite some time not 'getting' monads.
04:48:47 <Paprikachu> nah.
04:48:49 <Botje> and then the light will go on :)
04:48:53 <Paprikachu> i'm at the very beginning.
04:49:11 <Jaak> that curve is littered with wrecks
04:49:18 <Botje> and monad tutorials.
04:49:25 <Botje> and exploded brains
04:49:30 <Paprikachu> > do return()
04:49:31 <lambdabot>   No instance for (GHC.Show.Show (m ()))
04:49:31 <lambdabot>    arising from a use of `M643041436...
04:49:39 <Paprikachu> > do return() :: Maybe ()
04:49:40 <lambdabot>   Just ()
04:50:00 <ski> @src Maybe return
04:50:00 <lambdabot> return              = Just
04:50:02 <Paprikachu> > error "foobar"
04:50:03 <lambdabot>   *Exception: foobar
04:50:14 <Jaak> > forever Nothing
04:50:15 <lambdabot>   Nothing
04:50:26 <Paprikachu> "error" is what i needed in my math parser
04:50:26 <Jaak> deep...
04:50:59 <hpc> you probably didn't want error; what it throws is uncatchable
04:51:07 <hpc> (or near enough)
04:51:20 <Paprikachu> hm okay, then you're right
04:51:58 <Paprikachu> > do return 42
04:51:59 <lambdabot>   No instance for (GHC.Show.Show (m t))
04:52:00 <lambdabot>    arising from a use of `M3765891454...
04:52:10 <Paprikachu> > do return 42 :: Int
04:52:11 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
04:52:11 <lambdabot>         against inferred type ...
04:52:18 <Paprikachu> fufufufuf
04:52:35 <Paprikachu> > do return 42 :: Int ()
04:52:36 <lambdabot>   `GHC.Types.Int' is applied to too many type arguments
04:52:52 <Paprikachu> blah
04:53:20 <Paprikachu> what's wrong here?
04:53:32 <MasseR> Paprikachu: You want something like IO Int or State Int or Writer Int
04:53:39 <MasseR> Oh wait, those last two take more arguments
04:53:44 <MasseR> But IO Int is valid
04:53:54 <Paprikachu> how do i write this?
04:53:58 <taylorgb> > do return 42 :: Maybe Int
04:53:59 <lambdabot>   Just 42
04:54:10 <MasseR> Like that :)
04:54:12 <ski> > (`runStateT` 1) . forever $ do s <- get; if s > 99 then lift (Left ("terminated, s = " ++ show s)) else put (2 * s)
04:54:13 <Paprikachu> why Maybe -.-
04:54:14 <lambdabot>   Left "terminated, s = 128"
04:54:22 <MasseR> Paprikachu: It's one of the simplest monads
04:54:39 <fmap> > return 42 :: [Int]
04:54:40 <lambdabot>   [42]
04:54:42 <hpaste> path pasted “euler 31 - 2” at http://hpaste.org/69257
04:54:44 <hpc> @where lyah -- starts explaining Monad with Maybe
04:54:44 <lambdabot> http://www.learnyouahaskell.com/
04:55:04 <hpc> though you should know type classes, Functor, Applicative first
04:55:08 <Paprikachu> i'm already reading this tutorial
04:55:13 <MasseR> Paprikachu: But rather, you weren't struggling with monads just now
04:55:17 <path[l]> so this is what I've ended up with now. a list comprehension and a where clause. I guess it's pretty readable now
04:55:20 <ski> path[l] : next time, "Annotate" the original paste with updates
04:55:21 <MasseR> You were struggling with types
04:55:25 <Paprikachu> i'm in chapter "recursion"
04:55:27 <path[l]> ski: ah, ok
04:55:31 <MasseR> data Maybe a = Just a | Nothing
04:55:50 <MasseR> :t return
04:55:50 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
04:55:58 <hpc> Paprikachu: continue learning in the order LYAH follows, and ignore anything in here that you don't understand ;)
04:55:59 <MasseR> Or more simple: Monad m => a -> m a
04:56:02 <path[l]> Im ok with understanding what monads do, but not yet at the point where I'd think of using a monad to solve a problem  : x
04:56:14 <dzhus> if function f is strict on arguments x and y, and in the body of f I write `let z = x + y`, will z be strictily evaluated or bang pattern is needed?
04:56:28 <Paprikachu> but i already know recursion, i just read it in case there is something special about it in haskell
04:56:48 <ski> Paprikachu : saying `Int ()' is like saying `int<void>' in C++
04:56:48 <`Jake`> there is: You don't use it
04:56:55 <`Jake`> explicitly
04:57:04 <Paprikachu> ?
04:57:15 <Paprikachu> what do you mean by that?
04:57:18 <MasseR> Paprikachu: Jake means that you have higher level methods available
04:57:24 <MasseR> Like map and folds
04:57:30 <`Jake`> You'll learn that in the next chapter
04:57:34 <Ptival> Int does not take parameters, you never put something right after it
04:58:06 <Paprikachu> but map is a function, isn't it?
04:58:10 <MasseR> Continuing to Ptival, if you see the Maybe declaration earlier, you see that it has 'Maybe a' meaning that it takes a parameter
04:58:13 <Paprikachu> > map (+2) [1..10]
04:58:13 <ski> `Jake` : Paprikachu will first need to learn how to use recursion for basic tasks, like keeping an accumulator while looping
04:58:14 <MasseR> Paprikachu: Yes
04:58:14 <lambdabot>   [3,4,5,6,7,8,9,10,11,12]
04:58:35 <Paprikachu> i have no problem with recursion
04:58:54 <`Jake`> ski: Yeah, and like implementing standard higher order functions to understand them
04:58:55 <MasseR> Paprikachu: So you understand tail call optimization, accumulators and such?
04:58:57 <ski> accumulator-passing is a specific *style* of using recursion in
04:59:17 <`Jake`> MasseR: Is Tail recursion even mentioned in lyah?
04:59:28 <ski> you still need to learn that style (if you don't already know it, perhaps from recursive templates, if not from recursive C++ functions)
04:59:38 <MasseR> `Jake`: I'm not sure actually. It's been a while since I read it
04:59:39 <Paprikachu> can you give me an example?
04:59:52 <Ptival> `Jake`: I don't think so
05:00:04 <MasseR> fact n = n * fact (n-1)
05:00:11 <MasseR> fact 1 = 1
05:00:16 <MasseR> Versus
05:00:37 <ski> > let sumPlus [] sumSoFar = sumSoFar; sumPlus (n:ns) sumSoFar = sum ns (n + sumSoFar)  in sumPlus [2,3,5] 0
05:00:38 <MasseR> fact n acc = fact (n-1) (acc * n)
05:00:38 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t
05:00:45 <MasseR> fact 0 acc = acc
05:00:55 <ski> > let sumPlus [] sumSoFar = sumSoFar; sumPlus (n:ns) sumSoFar = sumPlus ns (n + sumSoFar)  in sumPlus [2,3,5] 0
05:00:56 <Paprikachu> what's special about it?
05:00:56 <lambdabot>   10
05:01:05 <MasseR> Paprikachu: Imagine how it's unwrapped
05:01:25 <MasseR> With the latter, it calls itself as the last part
05:01:26 <ski> Paprikachu : that we keep the "current result" in an extra parameter `acc'/`sumSoFar'
05:01:41 <MasseR> And it keeps the 'state' with itself with the accumulator
05:01:45 <ski>      fact 5
05:01:47 <Paprikachu> ...and?
05:01:51 <ski>      5 * fact 4
05:01:57 <ski>      5 * (4 * fact 3)
05:01:58 <Paprikachu> i still don't see anything sepcial...
05:02:02 <MasseR> Paprikachu: The latter one can be optimized
05:02:03 <Paprikachu> special
05:02:03 <barrucadu> Paprikachu: The latter runs in constant space
05:02:07 <ski>      5 * (4 * (3 * fact 2))
05:02:10 <barrucadu> (with tail-call optimisation)
05:02:13 <ski>      5 * (4 * (3 * (2 * fact 1)))
05:02:20 <ski>      5 * (4 * (3 * (2 * (1 * fact 0))))
05:02:23 <ski>      5 * (4 * (3 * (2 * (1 * 1))))
05:02:25 <MasseR> Paprikachu: See what ski did? That's linear space
05:02:26 <ski>      5 * (4 * (3 * (2 * 2)))
05:02:32 <Paprikachu> yeah
05:02:34 <ski>      5 * (4 * (3 * 2))
05:02:37 <Ptival> in "fact n = n * fact (n-1)", while you compute the recursive call, you have to remember "when I finish this, I still have to multiply by n to obtain the result"
05:02:37 <MasseR> That's how the first one works
05:02:38 <ski>      5 * (4 * 6)
05:02:40 <ski>      5 * 24
05:02:42 <ski>      120
05:02:52 <Paprikachu> that's how i would implement it
05:03:00 <MasseR> Paprikachu: That's the 'naive' way to do it :)
05:03:00 <ski> which ?
05:03:05 <ski> the former or the latter ?
05:03:06 <Paprikachu> it's the simple way.
05:03:08 <hpaste> mcstar pasted “recursion” at http://hpaste.org/69258
05:03:10 <Paprikachu> the former.
05:03:13 <ski> so, this uses unbounded stack space
05:03:13 <Ptival> in "fact n acc = fact (n-1) (acc * n)", while you compute the recursive call, well, that result will be your final result, nothing to do after!
05:03:30 <ski>      fact 5 1
05:03:46 <ski>   =  fact 4 (1 * 5)
05:03:48 <mcstar> i like that i got that recursion right, for almost the first time, i just had to satisfy the typechecker ^^
05:03:54 <ski>   =  fact 3 (5 * 4)
05:04:01 <ski>   =  fact 2 (20 * 3)
05:04:06 <ski>   =  fact 1 (60 * 2)
05:04:13 <ski>   =  fact 0 (120 * 1)
05:04:16 <ski>   =  120
05:04:18 <MasseR> Paprikachu: See how the recursion is optimized into a loop
05:04:27 <MasseR> ski is a good compiler ;D
05:04:37 <ski> s/cmopiler/tracer/
05:04:43 <ski> @where stepeval
05:04:43 <lambdabot> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
05:05:12 <ski> (there's one caveat above, though ..)
05:05:23 <Paprikachu> you need a helper function :P
05:05:32 <ski> yes, you do
05:05:38 <ski> (or you can use `foldr' or `foldl')
05:05:45 <zezikaro> Sorry, parsing failed.
05:05:45 <zezikaro> D:
05:05:57 <Paprikachu> what's foldl/foldr?
05:06:04 <MasseR> Paprikachu: You are right. The fold functions abstract away these details, but it's still good to understand
05:06:04 <`Jake`> how about fact = product [1..n]
05:06:17 <ski> > foldr f [a,b,c]
05:06:18 <lambdabot>   No instance for (SimpleReflect.FromExpr [SimpleReflect.Expr])
05:06:18 <lambdabot>    arising fr...
05:06:22 <ski> argh
05:06:34 <`Jake`> or is product not tail recursive?
05:06:41 <ski> oh, i missed an argument
05:06:46 <ski> > foldr f z [a,b,c]
05:06:47 <lambdabot>   f a (f b (f c z))
05:07:03 <ski> @src product
05:07:03 <lambdabot> product = foldl (*) 1
05:07:17 <ski> > foldl f z [a,b,c]
05:07:18 <lambdabot>   f (f (f z a) b) c
05:07:27 <ski> > foldr (*) 1 [a,b,c]
05:07:28 <lambdabot>   a * (b * (c * 1))
05:07:29 <Paprikachu> what does foldl return?
05:07:30 <ski> > foldl (*) 1 [a,b,c]
05:07:31 <lambdabot>   1 * a * b * c
05:07:59 <Paprikachu> @src foldl
05:08:00 <lambdabot> foldl f z []     = z
05:08:00 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
05:08:04 <ski> `foldl' takes a "combining function", an "initial state", and a list
05:08:11 <Paprikachu> i know
05:08:16 <Paprikachu> but what does it return
05:08:28 <ski> then it takes the first element of the list, combine it with the state, to get a new state
05:08:36 <ski> similarly with the next element
05:08:42 <ski> finally returning the final state value
05:08:46 <Paprikachu> yeah, but how can lambdabot print it
05:08:54 <untitled> how do I "query" a records from a list of records? like I want all records with "age"-parameter 20 from a list of records
05:08:56 <Paprikachu> i mean, it doesn't return a string
05:08:57 <barrucadu> lambdabot is special.
05:08:58 <mcstar> these questions are very well explained in either of the good books
05:09:06 <ski> Paprikachu : there's a "number" type called `Expr' which is a trick to do this
05:09:11 <Botje> untitled: a simple filter / list comprehension?
05:09:20 <Ptival> lambdabot has a special type for expressions and their symbolic evaluation
05:09:43 <ski> untitled : list comprehension ?
05:09:48 <ski> untitled : or `filter'
05:10:14 <Paprikachu> is there a merge/combine function for lists?
05:10:27 <ski> combine in which way ?
05:10:33 <Paprikachu> pair-wise
05:10:45 <Ptival> zip and zipWith
05:11:07 <Paprikachu> > zip [1,3..10] [2,4..10]
05:11:08 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10)]
05:11:14 <`Jake`> @t zipWith
05:11:15 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
05:11:24 <`Jake`> @type zipWith
05:11:25 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
05:11:34 <ski> @type zip
05:11:35 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
05:11:43 <Paprikachu> > zipWith [1..10] [1..10] (+)
05:11:45 <lambdabot>   Couldn't match expected type `a -> b -> c'
05:11:45 <lambdabot>         against inferred type `[...
05:11:49 <Paprikachu> hmm
05:11:53 <anachron> @source otherwise
05:11:53 <ski> the function needs to be the first argument
05:11:54 <lambdabot> otherwise not available
05:11:58 <anachron> bleh.
05:12:02 <ski> @src otherwise
05:12:02 <Paprikachu> > zipWith (+) [1..10] [1..10]
05:12:03 <lambdabot> otherwise = True
05:12:03 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
05:12:04 <`Jake`> zipWith (+) [1..10] [1..10]
05:12:13 <anachron> ah
05:12:50 <mcstar> > let LYAH person = "happy and knowledgeable " ++ person in LYAH "Paprikachu"
05:12:52 <lambdabot>   Not in scope: data constructor `LYAH'Not in scope: data constructor `LYAH'
05:12:58 <ski> > zipWith (+) [0 .. 9] [0,100 .. 900]
05:13:00 <lambdabot>   [0,101,202,303,404,505,606,707,808,909]
05:13:09 <mcstar> > let lYAH person = "happy and knowledgeable " ++ person in lYAH "Paprikachu"
05:13:11 <lambdabot>   "happy and knowledgeable Paprikachu"
05:13:12 <fmap> > [x + y | x <- [1..10] | y <- [1..10]]
05:13:13 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
05:14:08 <ski> > zip "help" [0 ..]
05:14:09 <lambdabot>   [('h',0),('e',1),('l',2),('p',3)]
05:14:19 <Ptival> the infamous
05:14:26 <Ptival> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in take 20 fibs
05:14:27 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
05:14:46 <Paprikachu> oO
05:14:57 <byorgey> should be  0 : 1 :    =)
05:15:02 <Ptival> oh :D
05:15:03 <ski> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs  -- an infinite list
05:15:04 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
05:15:09 <`Jake`> what happens if you let lambdabot zip two infinite lists?
05:15:13 <ski> byorgey :)
05:15:17 <frontendloader> try it and see
05:15:17 <ski> works fine
05:15:17 <hpc> > zip [0..] [1..]
05:15:18 <lambdabot>   [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,1...
05:15:21 <`Jake`> ok
05:15:37 <Paprikachu> > take 10 $ zip [1..] [2..]
05:15:38 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11)]
05:15:43 <frontendloader> breaking the bot is good for science
05:15:48 <hpc> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in zip fibs (tail fibs)
05:15:49 <lambdabot>   [(1,1),(1,2),(2,3),(3,5),(5,8),(8,13),(13,21),(21,34),(34,55),(55,89),(89,1...
05:16:04 <ski> Paprikachu : the nice thing with infinite lists is that you don't have to tell beforehand how many items you want
05:16:36 * hackagebot hsx 0.10.3 - HSX (Haskell Source with XML) allows literal XML syntax in Haskell source code.  http://hackage.haskell.org/package/hsx-0.10.3 (NiklasBroberg)
05:16:38 <Paprikachu> üplkojihuzt
05:16:39 <ski> Paprikachu : you just make your infinite list, passing it around and processing it a bit, then finally you extract however many elements you wanted in the end
05:16:48 <Paprikachu> i know. ^^
05:17:36 <mcstar> repeat n = let l = n : l in l
05:17:50 <ski> @src repeat
05:17:50 <lambdabot> repeat x = xs where xs = x : xs
05:18:53 <qnikst> hello, question about conduit
05:19:18 <qnikst> is it possible to connect list of sources, i.e. when first source is closed then read next one
05:19:25 <Ptival> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in zipWith3 (\a b c -> show a ++ "+" ++ show b ++ "=" ++ show c) fibs (tail fibs) (tail (tail fibs))
05:19:27 <lambdabot>   ["1+1=2","1+2=3","2+3=5","3+5=8","5+8=13","8+13=21","13+21=34","21+34=55","...
05:19:58 <Paprikachu> > let fib n = fib $ n -1 + fib $ n - 2; fib 0 = 0; fib 1 = 1; in map fib [1..10]
05:19:59 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
05:20:06 <Paprikachu> yuck fou
05:20:09 <Ptival> this never gets old
05:20:19 <ski> > let fib n = (fib $ n -1) + (fib $ n - 2); fib 0 = 0; fib 1 = 1; in map fib [1..10]
05:20:20 <lambdabot>   [*Exception: stack overflow
05:20:28 <Paprikachu> why
05:20:32 <Paprikachu> ._.
05:20:37 <byorgey> which one?
05:20:41 <ski> > let fib 0 = 0; fib 1 = 1; fib n = (fib $ n -1) + (fib $ n - 2); fib 0 = 0; in map fib [1..10]
05:20:42 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
05:20:47 <Paprikachu> oh lol.
05:20:57 <Paprikachu> ah right, there was this stupid rule
05:20:59 <ski> Paprikachu : you need to have the base cases first, otherwise it'll always choose the non-base case
05:21:30 <ski> (because it tries to match in a first-to-last order, instead of trying the most specific ones first)
05:21:38 <Paprikachu> yeah, i just forgot that :)
05:22:06 <qnikst> smth like $$+ but for source
05:22:14 <Paprikachu> > let fib n = fib 0 = 0; fib 1 = 1; fib (n -1) + fib (n - 2) in map fib [1..10]
05:22:15 <lambdabot>   <no location info>: parse error on input `='
05:22:25 <hpaste> mcstar pasted “fibonacci would be happy” at http://hpaste.org/69260
05:22:32 <Paprikachu> > let fib 0 = 0; fib 1 = 1; fib n = fib (n -1) + fib (n - 2) in map fib [1..10]
05:22:34 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
05:22:40 <ski> yep
05:23:22 <Paprikachu> > let nums = [x | x < 3, x > 1]
05:23:23 <lambdabot>   not an expression: `let nums = [x | x < 3, x > 1]'
05:23:29 <ski> that one is O(fib n), though :)
05:23:34 <Paprikachu> > [x | x < 3, x > 1]
05:23:35 <lambdabot>   []
05:23:40 <barrucadu> ski: The best time complexity.
05:23:48 <`Jake`> I tried to zip one of the fibonacci functions with [1..] and dicovered this pattern: http://img687.imageshack.us/img687/6310/fibs.png
05:23:50 <ski> > [x | x <- [0 .. 9], x < 3, x > 1]
05:23:52 <lambdabot>   [2]
05:24:03 <`Jake`> I wonder if it's related to the golden ratio and stuff
05:24:11 <Paprikachu> LOL
05:24:19 <Botje> Jaak: heh, cool!
05:24:40 <barrucadu> Jaak: That is quite nice
05:24:54 <`Jake`> guess i have to change my name now
05:24:59 <barrucadu> Ah
05:25:05 <Paprikachu> :D
05:25:07 <barrucadu> `Jake`: That is quite nice.
05:25:14 <Ptival> :D
05:25:15 <barrucadu> Jaak: I'm sure you're nice as well.
05:25:27 <`Jake`> It doesn't even matter how wide the terminal is, something similar will always happen
05:25:31 <`Jake`> for me, anyways
05:26:00 <Ptival> `Jake`: what's the code?
05:26:08 <mcstar> whats the pattern?
05:26:22 <mcstar> seems homogeneous
05:26:26 <ski> markus3 : presumably `zip [1 ..] fibs'
05:26:30 <ski> mcstar ^
05:26:39 <`Jake`> fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
05:26:46 <`Jake`> zip [1..] fibs
05:27:00 <mcstar> ski: the parabola?
05:27:13 <ski> mcstar : sorry, ENICK
05:27:24 <ski> mcstar : but yes, i think that's what `Jake` meant
05:27:39 <ski> re Paprikachu_
05:28:00 <Paprikachu_> ^^
05:28:07 <Paprikachu_> what's the pattern of jakes output?
05:28:10 <Paprikachu_> ;O
05:28:19 <ski> the parabola thing
05:28:22 <`Jake`> well, that's not all, there are larger, similar lines around it, but there not on the screen
05:28:29 <`Jake`> they are*
05:29:04 <mcstar> actually, not a parabola, but a logarithm
05:29:17 <`Jake`> seriously?
05:29:33 <ski> (Paprikachu_ : you know you can do `/msg NickServ ghost Paprikachu <password>', right ?)
05:29:45 <Paprikachu_> my nick is not registered
05:29:47 <Ptival> zip [1..] [2 ^ i | i <- [1..]] -- shows the same patterns
05:30:01 <Ptival> it just has to do with the rate of increase in digits
05:30:04 <`Jake`> welcome back
05:30:18 <ski> ok
05:30:34 <Paprikachu> but maybe i should register it
05:30:45 <`Jake`> yeah, you should
05:31:14 <`Jake`> you can even tell your chatprogram to log you in automatically, probably
05:31:18 <Paprikachu> i know
05:31:25 <ski> (hm, i think one can omit the `<password>', if the other nick you have currently is already identified)
05:31:30 <Paprikachu> already did that in euirc
05:31:34 <ski> (and they both are linked, of course)
05:32:04 * ski has linked `ski' and `ski_' together in this way
05:32:11 <Paprikachu> now i'm registered ;)
05:32:15 <`Jake`> yay!
05:32:37 <hpc> i don't link my nicks, i just use aliases
05:32:47 <hpc> /hpc -- and then i am identified!
05:33:26 <ski> hpc : but what about when you get broken connection, like Paprikachu_ just above ? do you `ghost' (with password) ?
05:33:45 <hpc> yes
05:33:47 <hpc> alias is
05:33:56 <mcstar> the fibonacci sequence increses by 1 digit in every 5 iterations on average
05:33:56 <hpc> ghost, release, recover, nick, ident
05:34:33 <Paprikachu> clear
05:34:38 <Paprikachu> oops
05:34:41 <`Jake`> and 2^x ?
05:34:42 <Paprikachu> forgot /
05:34:43 <Paprikachu> :P
05:35:00 <ski> `Jake` : what about it ?
05:35:10 <ski> hm
05:35:28 <`Jake`> ski: mcstar just wrote something about the fibonacci sequence
05:35:37 <ski> > logBase 10 ((1 + sqrt 5) / 2)
05:35:38 <lambdabot>   0.20898764024997873
05:35:43 <dzhus> if function f is strict on arguments x and y, and in the body of `f` I write `let z = x + y`, will z be strictily evaluated or explicit bang pattern is needed?
05:35:44 <ski> > logBase ((1 + sqrt 5) / 2) 10
05:35:45 <lambdabot>   4.784971966781666
05:35:53 <ski> almost five, yes
05:36:09 <Paprikachu> > log 10
05:36:10 <lambdabot>   2.302585092994046
05:36:18 <Paprikachu> > ln 10
05:36:19 <lambdabot>   Not in scope: `ln'
05:36:21 <`Jake`> log 2
05:36:21 <mcstar> ski: try computing the elements by the using the generator XD
05:36:22 <ski> dzhus : not strictly evaluated, iirc
05:36:24 <`Jake`> >log 2
05:36:27 <`Jake`> > log 2
05:36:29 <lambdabot>   0.6931471805599453
05:36:32 <hpc> dzhus: z = THUNK (x + y)
05:36:32 <Paprikachu> > log 1
05:36:33 <ski> > log (exp 1)
05:36:34 <lambdabot>   0.0
05:36:35 <lambdabot>   1.0
05:36:37 <ski> > exp 1
05:36:38 <lambdabot>   2.718281828459045
05:36:46 <hpc> dzhus: as opposed to if x/y weren't strict, z = THUNK (THUNK + THUNK)
05:36:46 <ski> `log' is `logBase (exp 1)'
05:36:47 <Paprikachu> > e^j*pi
05:36:53 <lambdabot>   mueval: ExitFailure 1
05:36:53 <lambdabot>  mueval: Prelude.undefined
05:37:02 <ski> > exp (0 :+ pi)
05:37:04 <Paprikachu> are there complex numbers in haskell?
05:37:06 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
05:37:07 <`Jake`> > log $ exp 1
05:37:08 <lambdabot>   1.0
05:37:25 <`Jake`> @hoogle Complex
05:37:26 <lambdabot> Data.Complex data RealFloat a => Complex a
05:37:26 <lambdabot> Data.Complex module Data.Complex
05:37:26 <lambdabot> package complex-integrate
05:37:29 <ski> > `a :+ b' corresponds to `a + i*b' (with `a' and `b' real)
05:37:30 <lambdabot>   <no location info>: parse error on input ``'
05:38:00 <ski> @let imaginaryUnit = 0 :+ 1
05:38:03 <lambdabot>  Defined.
05:38:07 <ski> > exp (imaginaryUnit * pi)
05:38:12 <lambdabot>   mueval-core: Time limit exceeded
05:38:18 <ski> > exp (imaginaryUnit * pi)
05:38:20 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
05:38:24 <mcstar> fib 10000 has 2090 digits
05:38:34 <mcstar> not that much
05:38:57 <ski> mcstar : which generator ?
05:39:01 <Paprikachu_> e^j*pi is exactly -1
05:39:06 <Paprikachu_> :<
05:39:20 <ski> floating-point approximations
05:39:25 <Paprikachu_> i know
05:39:26 <mcstar> ski: phi^n+psi^n or something
05:39:27 <Paprikachu_> :P
05:39:45 <Paprikachu_> > let j = imaginaryUnit in e^(j*pi)
05:39:46 <lambdabot>   No instance for (GHC.Real.Integral (Data.Complex.Complex t))
05:39:46 <lambdabot>    arising fro...
05:40:03 <Paprikachu_> > let j = imaginaryUnit in exp $ j * pi
05:40:03 <ski> mcstar : ok, that one -- you'll get floating-point errors with that one, i think, for large enough inputs, if you use `Float' or `Double'
05:40:04 <mcstar> ski: im just making fun of that it would quickly became inaccurate
05:40:05 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
05:40:42 <Paprikachu_> > let j = imaginaryUnit; e = exp 1 in e ^ (j * pi)
05:40:43 <lambdabot>   No instance for (GHC.Real.Integral (Data.Complex.Complex t))
05:40:44 <lambdabot>    arising fro...
05:41:04 <mcstar> btw, haskell comlex constructor was very unusual for me
05:41:06 <`Jake`> > let j = imaginaryUnit in exp $ j * pi * 2
05:41:08 <lambdabot>   1.0 :+ (-2.4492935982947064e-16)
05:41:25 <Paprikachu_> > let j = imaginaryUnit; e = exp 1 in e ^ (j * pi)
05:41:26 <lambdabot>   No instance for (GHC.Real.Integral (Data.Complex.Complex t))
05:41:27 <Paprikachu_> why
05:41:27 <lambdabot>    arising fro...
05:41:58 <ski> > let j = imaginaryUnit; e = exp 1 in e ** (j * pi)
05:42:00 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
05:42:06 <Paprikachu> damnit
05:42:11 <Paprikachu> what's the difference
05:42:12 <ski> `^' (and `^^') is for integral exponents
05:42:21 <ski> `**' is for floating exponent
05:42:22 <`Jake`> e ^ (2*i*pi) = 1;  2*i*pi = ln 1;  2*i*pi = 0;  i = 0
05:42:26 <ski> @src (^)
05:42:27 <Paprikachu> suuuuuuuuucks
05:42:27 <lambdabot> x ^ 0            =  1
05:42:27 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
05:42:27 <lambdabot>   where f _ 0 y = y
05:42:27 <lambdabot>         f x n y = g x n
05:42:27 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
05:42:29 <lambdabot>                       | otherwise = f x (n-1) (x*y)
05:42:31 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
05:42:35 <Paprikachu> xD
05:42:36 <Paprikachu> what
05:42:38 <ski> Paprikachu :)
05:42:44 <mcstar> Paprikachu: consider that ocaml doesnt have an integer exponentiation operator
05:43:01 <Paprikachu> who cares about ocaml
05:43:07 <ski> me thinks Paprikachu probably hasn't seen O'Caml
05:43:15 <Paprikachu> you are right
05:43:32 <mcstar> im just saying haskell doesnt exactly suck because ^ doesnt do what you want
05:43:43 <merijn_> :t (^)
05:43:44 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
05:43:53 <merijn_> :t imaginaryUnit
05:43:54 <lambdabot> forall t. (RealFloat t) => Complex t
05:43:55 <Paprikachu> i said ^ sucks, not haskell
05:43:59 <`Jake`> :t (**)
05:44:00 <lambdabot> forall a. (Floating a) => a -> a -> a
05:44:06 <MasseR> mcstar: Definitely not, but in some situations haskell typing interferes. Especially when doing something mathematic. fromIntegral all over the place
05:44:11 <mcstar> potato potato
05:44:12 * ski . o ( `double pow(double x,double y);' )
05:44:16 <merijn_> Paprikachu: There is exponentiation for non-integrals, but they are not (^)
05:44:22 <navaati> :t (**)
05:44:23 <lambdabot> forall a. (Floating a) => a -> a -> a
05:44:45 <Paprikachu> haskell can also have overloaded return types (which are painful), so why cant it have this operator overloaded?
05:45:07 <mcstar> MasseR: when i needed much use for fromIntegral, i aliased it for 'fi' (still was ugly, yes)
05:45:25 <`Jake`> Paprikachu: I'd guess performance issues (?)
05:45:37 <mcstar> overloaded return type?
05:45:40 <navaati> mcstar: i have to do this all the time. actually much of the pain of fromIntegral comes from its too much long name
05:45:43 <Paprikachu> like read
05:45:45 <merijn_> mcstar: Yes, see read
05:45:58 <mauke> Paprikachu: because ^ is useful
05:46:02 <ski> (Ada also has overloading on return type)
05:46:20 <MasseR> navaati: It also breaks the reading flow.
05:46:38 <mcstar> isnt it just simple polymorphism?
05:47:00 <mcstar> it just happens that the type specification comes from the return type requirement?
05:47:07 <ski> navaati,MasseR : you can always locally declare `fI = fromIntegral'
05:47:07 <navaati> ^ uses a different algorithm than **, doesn't it ? like, ^ is the log2(n) trick for exponentiation whereas ** is the machine floating point operatin, right ?
05:47:15 <ski> navaati : yes
05:47:16 <`Jake`> yes, it does
05:47:22 <mparodi> @src foldl
05:47:22 <lambdabot> foldl f z []     = z
05:47:22 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
05:47:24 <mparodi> @src foldr
05:47:25 <lambdabot> foldr f z []     = z
05:47:25 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:47:29 <`Jake`> src (**) doesn't work
05:47:33 <MasseR> ski: I mean, that the fromIntegral/fi in the middle of an equation breaks the flow
05:47:38 <MasseR> Makes it more difficult to read
05:47:41 <Paprikachu> > foldl (+) 0 [1,2,3]
05:47:42 <ski> @src Double (**)
05:47:42 <lambdabot>   6
05:47:42 <lambdabot> Source not found. Are you on drugs?
05:48:06 <ski> MasseR : ok
05:48:28 <navaati> lambdabot is such a bitch…
05:48:44 <`Jake`> (**) = powerFloat and powerFloats source is: powerFloat  (F# x) (F# y) = F# (powerFloat# x y)
05:48:45 <mcstar> merijn_: so how is 'overloaded return type' is different from what i said?
05:48:55 <Paprikachu_> fuuuuuuuuu internet
05:49:15 * ski hands Paprikachu_ a cookie
05:49:19 <MasseR> I don't remember anymore what I did, but I remade a teachers implementation in haskell, and showed to a friend of mine how neat the solution was. Until he found the area littered with fromIntegral at which time I was "Uhm. Disregard those. Try to read around them"
05:49:22 <Paprikachu_> nyum
05:49:26 <Paprikachu_> :3
05:49:46 <`Jake`> that powerFloat code is weird
05:50:12 <Paprikachu_> how do i decide if i use foldl or foldr?
05:50:32 <mauke> Paprikachu: in general, you never use foldl
05:50:34 <MasseR> Paprikachu_: If you need infinite arrays, use foldr, otherwise use foldl' :)
05:50:39 <Paprikachu_> > foldl (+) 0 [1, 2, 3]
05:50:40 <lambdabot>   6
05:50:42 <mauke> there are no infinite arrays
05:50:44 <Paprikachu_> > foldr (+) 0 [1, 2, 3]
05:50:45 <lambdabot>   6
05:50:59 <navaati> `Jake`: no, it just unboxes (read : dereferences pointers) the numbers, apply the native operation "powerFloat#" on them and boxes (read : put behind some pointer) the result
05:51:16 <Paprikachu_> 2 opinions, who do i know which one is right?
05:51:20 <Paprikachu_> :P
05:51:24 <Paprikachu_> *how
05:51:25 <MasseR> Paprikachu_: Nope, only one opinion
05:51:29 <MasseR> Note that I said foldl'
05:51:34 <`Jake`> navaati: ok... so the source for powerFloat# is something else?
05:51:39 <mcstar> Paprikachu_: you try evaluating what each one does, and see for yourself
05:51:46 <navaati> and we can assume (not sure, though, it's more likely to be true with Double) that "powerFloat#" is the machine code operation
05:51:52 <Paprikachu_> what's foldl'?
05:52:00 <`Jake`> ok
05:52:03 <`Jake`> thanks
05:52:04 <mcstar> strict brother of foldl
05:52:15 <Paprikachu> what does "strict" mean?
05:52:20 <mcstar> not lazy
05:52:36 <yitz> @src foldl
05:52:37 <lambdabot> foldl f z []     = z
05:52:37 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
05:52:39 <Paprikachu> what
05:52:41 <yitz> @src foldl'
05:52:42 <lambdabot> foldl' f a []     = a
05:52:42 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
05:52:43 <mcstar> you know avout thunks, doyou?
05:52:48 <mauke> technically, a function f is strict in its argument if f _|_ == _|_
05:53:07 <mcstar> dont you*
05:53:15 <mauke> *don't
05:53:16 <mauke> *about
05:53:17 <Paprikachu> i don't get it.
05:53:22 <ski> Paprikachu : consider `foldl (*) 1 [1,2,3,4,5]' again
05:53:33 <mcstar> mauke: why dont you correct your name too?
05:53:38 <ski>      foldl (*) 1 [1,2,3,4,5]
05:53:42 <Paprikachu> 120
05:53:46 <ski>   =  foldl (*) (1 * 1) [2,3,4,5]
05:53:53 <ski>   =  foldl (*) ((1 * 1) * 2) [3,4,5]
05:53:59 <ski>   =  foldl (*) (((1 * 1) * 2) * 3) [3,4,5]
05:54:10 <ski>   =  foldl (*) ((((1 * 1) * 2) * 3) * 4) [5]
05:54:13 <yitz> mcstar: be nice to mauke
05:54:15 <mauke> mcstar: how is it incorrect?
05:54:18 <ski>   =  foldl (*) (((((1 * 1) * 2) * 3) * 4) * 5) []
05:54:25 <ski>   =  ((((1 * 1) * 2) * 3) * 4) * 5
05:54:28 <ski>   =  (((1 * 2) * 3) * 4) * 5
05:54:30 <mcstar> mauke: it just doesnt make sense, much like my avout
05:54:32 <ski>   =  ((2 * 3) * 4) * 5
05:54:36 <ski>   =  (6 * 4) * 5
05:54:40 <ski>   =  24 * 5
05:54:43 <ski>   =  120
05:54:44 <ski> vs.
05:54:46 <mcstar> mauke: i thought, maybe its a typo (j/k)
05:54:49 <mauke> mcstar: no, your avout was a typo. you just don't know what "mauke" means
05:54:51 <ski>      foldl' (*) 1 [1,2,3,4,5]
05:54:57 <ski>      foldl' (*) (1 * 1) [2,3,4,5]
05:55:01 <ski>      foldl' (*) 1 [2,3,4,5]
05:55:07 <ski>      foldl' (*) (1 * 2) [3,4,5]
05:55:08 <markus3> hi! with cabal-dev, it seems that I need to bump the version of a package to make add-source to really add the source -- is the re some way to force it?
05:55:13 <ski>      foldl' (*) 2 [3,4,5]
05:55:18 <ski>      foldl' (*) (2 * 3) [4,5]
05:55:22 <ski>      foldl' (*) 6 [4,5]
05:55:29 <ski>      foldl' (*) (6 * 4) [5]
05:55:31 <ski>      foldl' (*) 24 [5]
05:55:32 <mauke> ski: I find that a bit annoying
05:55:38 <ski>      foldl' (*) (24 * 5) []
05:55:40 <Paprikachu> so i should use foldl' because it uses less space?
05:55:41 <ski>      foldl' (*) 120 []
05:55:44 <ski>      120
05:55:48 <MasseR> Paprikachu: Exactly
05:55:54 <mauke> ski: and hard to read, because you can't see all of it, it gets interrupted by other stuff, and it scrolls off screen
05:55:54 <mcstar> Paprikachu: and  time too
05:56:02 <ski> mauke : that i didn't show the explicit `seq' calls ?
05:56:02 <yitz> markus3: yes: rm it from cabal-dev/packages-*/ and from cabal-dev/lib/. (two files)
05:56:14 <mauke> ski: no, that you type long sequences of stuff into the channel
05:56:18 <Paprikachu> is there a foldr'?
05:56:22 <ski> mauke : oh, ok
05:56:26 <ski> Paprikachu : no
05:56:47 <Paprikachu> > foldr' (+) 0 [1, 2, 3, 4, 5]
05:56:48 <lambdabot>   Not in scope: `foldr''
05:56:49 <markus3> yitz: thank you
05:56:50 <Paprikachu> damnit
05:57:03 <ski> (it wouln't make sense to have it, either)
05:57:07 <mcstar> Paprikachu: i dont want to sound rude, but you should really learn these from a book, and come back if you specifically dont understand something
05:57:14 <Paprikachu> > let foldr' = foldr in foldr' (+) 0 [1, 2, 3, 4, 5]
05:57:15 <lambdabot>   15
05:57:15 <markus3> wish there was a way to force the add-source
05:57:19 <Paprikachu> hah
05:57:46 <Paprikachu> but learning by doing is far more fun ._.
05:57:48 <yitz> markus3: yes, i agree. since it'a not that hard to do by hand, it wouldn't be hard to add an option for that either
05:58:05 <mcstar> Paprikachu: there is too much distraction on irc to realy learn these i think
05:58:06 <Paprikachu> also it gives me the chance to discuss something to understand it better :x
05:58:07 <Botje> Paprikachu: lyah has tons of examples and exercises you can follow and play with
05:58:31 <ski> mcstar : i'm not sure. perhaps sometimes there is
05:58:42 <yitz> markus3: i use local yackage servers instead of add-source, but i also run into that.
05:58:56 <`Jake`> Botje: lyah doesn't have exercises at all, does it?
05:59:01 <Paprikachu> having to compile the lyah stuff is annoying ._.
05:59:18 <Botje> compile?
05:59:24 <Botje> you can just read it online :P
05:59:35 <Paprikachu> to play around with it
05:59:41 <mcstar> mauke: btw, what does it mean, if you'd be so kind to tell me
05:59:53 <Botje> `Jake`: oh, then I misremember
05:59:56 <Paprikachu> (note: my ghci is broken)
06:00:15 <`Jake`> Botje: realworldhaskell has tons of exercises
06:00:23 <Botje> ah.
06:00:24 <mauke> mcstar: I chose the name because of its ambiguity. it's the name of an island as well as about 4 different regional things in germany
06:00:45 <markus3> yitz: I guess it tries to do the right thing not adding the same version again, but then I'd need to bump the version of my package every time
06:00:59 <Paprikachu> > fmap init $ hGetLine stdin
06:01:00 <lambdabot>   Not in scope: `hGetLine'Not in scope: `stdin'
06:01:03 <Paprikachu> fu
06:01:21 <ski> Paprikachu : just in case you didn't know/think of it, you can also `/msg lambdabot > ...' -- but sometimes it's something which one would like others opinion on, in which case #haskell could be more appropriate
06:01:36 <mroman> > interact$init
06:01:38 <lambdabot>   <IO ()>
06:01:47 <mroman> Paprikachu: It wouldn't do anything anyway ;)
06:01:50 <yitz> markus3: right. that's the default for when it downloads from a hackage server. the opposite should be the default for add-source. and either one should be overrideable by an option.
06:02:08 <`Jake`> > foldl' (*) 1 [1..]
06:02:12 <lambdabot>   mueval-core: Time limit exceeded
06:02:16 <Paprikachu> but sometimes you tell me something related to my code what i didnt know, ski
06:02:16 <mcstar> Paprikachu: in what way is your ghci broken?
06:02:28 <ski> Paprikachu : right
06:02:38 <Paprikachu> $ ghci
06:02:40 <Paprikachu> GHCi, version 7.4.1: http://www.haskell.org/ghc/  :? for help
06:02:42 <Paprikachu> Loading package ghc-prim ... linking ... done.
06:02:43 <Paprikachu> Loading package integer-gmp ... linking ... done.
06:02:45 <Paprikachu> Loading package base ... linking ... done.
06:02:46 <Paprikachu> Segmentation fault
06:02:48 <Paprikachu> that way
06:02:49 <markus3> yitz: a "cabal-dev bump [dir]" could be handy also
06:03:08 <markus3> updating some fourth number in the version
06:03:10 <yitz> markus3: what would it do exactly?
06:03:14 <mcstar> Paprikachu: upgrade your system
06:03:16 <yitz> ah right
06:03:23 <Paprikachu> no
06:03:32 <Paprikachu> ghc works just fine :o
06:03:54 <yitz> markus3: but it would also need to commit that as a patch to your version control. :) so i have a little script for that.
06:04:14 <fmap> Paprikachu: and what strace says?
06:04:24 <Paprikachu> what's strace?
06:04:45 <markus3> yitz: :)
06:05:32 <fmap> strace traces syscalls and signals issued/received in executable
06:05:55 <fmap> could be useful to find cause of segfaults
06:06:01 <Paprikachu> rename irc ghci
06:06:04 <Paprikachu> problem solved :o
06:06:09 <mcstar> maybe run it under valgrind
06:06:18 * ski . o O ( `ghcirc' )
06:07:01 <Paprikachu> so.. what can i do next with haskell
06:07:03 <ski> .. where you connect an irc channel to your GHCi, so that others also can play with your functions
06:07:11 <Paprikachu> :D
06:07:22 <Paprikachu> maybe i'll do just that!
06:07:32 <mcstar> except your private functions...
06:07:35 <sm> I have thought of building an irc client into my apps, for help/feedback
06:08:09 <sm> we could start a craze!
06:08:12 <mcstar> Paprikachu: now go and solve all of PE
06:08:15 <ski> mcstar : should work for those as well, with `*Foo> '
06:08:37 <ski> ("PE" being "Partial Evaluation" ?)
06:09:07 <barrucadu> "Project Euler" probably
06:09:15 <ski> ah
06:10:05 <t7> > system "sudo rm -rf /"
06:10:06 <lambdabot>   Not in scope: `system'
06:10:27 <Paprikachu> project euler is boring
06:10:37 <`Jake`> t7: You'll have to know the password for that
06:10:40 <barrucadu>  >>>  sudo rm -rf /
06:10:40 <barrucadu> Password:
06:10:40 <barrucadu> rm: it is dangerous to operate recursively on ‘/’
06:10:40 <barrucadu> rm: use --no-preserve-root to override this failsafe
06:10:42 <Paprikachu> some of them are far too easy and the rest is too hard
06:11:07 <barrucadu> t7: Don't forget your rm flags (or /*) :P
06:11:37 <Paprikachu> lol noob
06:11:54 <mcstar> pe is definitely not boring, and anyway why would you say that if you also say the rest is too hard?
06:12:10 <`Jake`> When I first used sudo I thought it was broken because I couldn't enter anything when it asked me to enter the password...
06:12:17 <t7> > DROP TABLE *
06:12:18 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
06:12:47 <mcstar> obviously the hard problems arent boring
06:14:02 <mcstar> `Jake`: when i first used sudo, i didnt understand why would it work with my user password
06:14:55 <merijn_> mcstar: Same here
06:15:08 <merijn_> mcstar: To used to su, I guess
06:15:36 <mm|swarm> when i first used sudo my account was not in the sudoers file
06:15:52 <mcstar> bummer
06:15:54 <mm|swarm> and I panicked over the «this incident will be reported» thing
06:16:07 <mcstar> mm|swarm: the black hat hacker
06:16:38 <mm|swarm> but we were supposed to learn to use it in that lab :)
06:20:16 <mcstar> i remember i set a wallpaper of a naked woman for the lab computers, they shared the gconf registry of something, so it was easy
06:20:27 <mcstar> of->or
06:27:38 <Paprikachu> http://learnyouahaskell.com/recursion#a-few-more-recursive-functions
06:27:49 <Paprikachu> why is replicate not implemented like this:
06:28:00 <Paprikachu> replicate 0 x = []
06:28:17 <Paprikachu> replicate n x = x : replicate (n - 1) x
06:28:41 <mcstar> @src replicate
06:28:41 <lambdabot> replicate n x = take n (repeat x)
06:29:29 <Paprikachu> click the link
06:29:41 <Paprikachu> in lyah it's implemented with guards
06:29:44 <Paprikachu> i don't get why
06:29:47 <mcstar> he just wants to demostrate gurads
06:30:08 <Paprikachu> he already did that before
06:30:09 <Gothmog_> also, that way negative values are handled
06:30:20 <Paprikachu> who cares?
06:30:21 <mcstar> true
06:30:27 <mcstar> i care
06:30:33 <Paprikachu> i wouldn't handle negative values
06:30:39 <Paprikachu> it's an error
06:30:56 <Gothmog_> that depends on your definition of replicate :)
06:31:03 <hughfdjackson> is there any way you can get a similar @src thing in ghci?
06:31:05 <mcstar> Paprikachu: but errors can be different
06:31:20 <mcstar> Paprikachu: your version would loop forever
06:31:30 <Paprikachu> i don't care
06:31:34 <mcstar> pfff
06:31:39 <ski> i think Paprikachu's point is that a precondition is that the count is not negative
06:31:46 <Paprikachu> yes
06:31:57 <Paprikachu> exactly that
06:32:01 <ski> it would be nicer if it used a `Nat' or `Natural' number type, though
06:32:34 <Paprikachu> also, i don't like the take implementation
06:32:35 <Gothmog_> it can make perfect sense to handle negative numbers that way
06:32:44 <Paprikachu> take _ [] = []
06:32:49 <Paprikachu> this is just wrong
06:33:09 <merijn_> What should it do then? Crash?
06:33:13 <Paprikachu> if i try to take 5 elements out of an empty list, this should be an error
06:33:13 <merijn_> That's even worse
06:33:26 <mcstar> it is much better than an coupertino loop, afaik
06:33:27 <merijn> partial functions are terrible horrors
06:33:29 <Paprikachu> no, that's exactly what should happen
06:33:33 <ski> > map (take 3) ["","a","bc","def","ghij","klmno","pqrstu"]
06:33:34 <lambdabot>   ["","a","bc","def","ghi","klm","pqr"]
06:33:40 <ski> Paprikachu : also consider
06:33:42 <Paprikachu> making errors disappear is the worst thing that can happen
06:33:44 <merijn> Paprikachu: That gives you unpredictable runtime behaviour
06:33:51 <merijn> It isn't masking an error
06:33:52 <ski> > zip "abcd" [0,1,2,3,4,5,6,7,8,9]
06:33:54 <lambdabot>   [('a',0),('b',1),('c',2),('d',3)]
06:33:56 <ski> > zip "abcd" [0 ..]
06:33:57 <lambdabot>   [('a',0),('b',1),('c',2),('d',3)]
06:34:22 <Paprikachu> take 5 [] should just be error "empty list bla bla"
06:34:28 <Gothmog_> either restrict the domain, or define it on negative numbers in a sane way.
06:34:37 <ski> Paprikachu : i agree about "making errors disappear ..", but in this case, one could argue that the behaviour is useful
06:34:59 <merijn> It is more consistent, easier and pure to check for empty list then it is to handle an exception
06:35:00 <ski> Paprikachu : i.e. it really means "take five elements (or as many as you've got, if fewer)"
06:35:03 <mcstar> it is useful for functional style, maybe not for imperative
06:35:26 <merijn> Just look at abominations like head
06:35:31 * merijn shudders
06:35:35 <Paprikachu> > head []
06:35:36 <lambdabot>   *Exception: Prelude.head: empty list
06:35:37 <ski> Paprikachu : iow, we don't know `length (take n as) = n', we only know `length (take n as) <= n = True'
06:35:53 <mcstar> for example. beforehand, you cant know if a list has as many elements as you ask from take
06:35:55 <Jaak> the "take at most n" behaviour of take can be very useful, exactly like the truncating behaviour of zip(With)
06:36:12 <ski> mcstar : except by reasoning, i.e.
06:36:37 <ski> "it's not a bug, it's a feature" ;)
06:37:09 <mcstar> Paprikachu: take arrays for example, they have bounds checking by default
06:37:22 <mcstar> it makes sense for arrays
06:37:36 <ski> mcstar : yes, but if you're out of bounds, you don't get a dummy value
06:38:00 <Paprikachu> real programmers don't need bounds checking, they never have out-of-bound-erros
06:38:05 <Paprikachu> > take 5 $ reverse [1..]
06:38:08 <mcstar> no, im saying you use arrays differently than lists
06:38:09 <lambdabot>   mueval-core: Time limit exceeded
06:38:16 <ski> > listArray (2,4) "abc" ! 1
06:38:17 <Paprikachu> hurr
06:38:17 <lambdabot>   *Exception: Ix{Integer}.index: Index (1) out of range ((2,4))
06:39:53 <Paprikachu> didnt the author forget the edge case of having two empty lists in the implementation of zip?
06:40:10 <mcstar> ?
06:40:12 <Jaak> er, Paprikachu, i expect that it was sarcasm... off by one errors (many of which can be cought by baunds checking) are incredibly common
06:40:13 <ski> > map (take 3 . (++ repeat '-')) ["","a","bc","def","ghij","klmno","pqrstu"]
06:40:15 <lambdabot>   ["---","a--","bc-","def","ghi","klm","pqr"]
06:40:23 <Jaak> > zip [] []
06:40:24 <lambdabot>   []
06:40:25 <navaati> well, it makes an empty list, which is perfect
06:40:35 <Jaak> caught*
06:40:44 <Paprikachu> [15:37:47]	<Jaak>	er, Paprikachu, i expect that it was sarcasm... off by one errors (many of which can be cought by baunds checking) are incredibly common
06:40:58 <Paprikachu> actually, allthough it was sarcasm, i'm serious
06:41:12 <Jaak> (sodding grammer)
06:41:18 <Paprikachu> i can't even remember if i ever had a off by one error
06:41:42 <mcstar> Paprikachu: if you write throw away code, it might not surface at all
06:41:57 <navaati> Paprikachu: if you want a language which ensure total functions, go take a look at Agda. Haskell is not such a language
06:42:13 <Paprikachu> what's a total function?
06:42:20 <Paprikachu> [15:39:10]	<mcstar>	Paprikachu: if you write throw away code, it might not surface at all
06:42:26 <Paprikachu> my code is obv better than most code
06:42:34 <Paprikachu> at least in c++
06:42:38 <ski> a function which never is partial, never throws an error, and never loops
06:42:44 <navaati> a total function is a function which is defined on all its domain
06:42:52 <ski> > head []
06:42:54 <lambdabot>   *Exception: Prelude.head: empty list
06:42:59 <ski> `head' is partial, not toal
06:43:02 <navaati> (math guys : is my definition correct ?)
06:43:11 <ski> > fix id  -- also partial
06:43:15 <lambdabot>   mueval-core: Time limit exceeded
06:43:22 <navaati> :t fix id
06:43:24 <lambdabot> forall a. a
06:43:40 <mcstar> navaati: 'domain' by definition is what a functin is defined on
06:43:43 <Paprikachu> also, i don't get what total functions have to do with anything i said here
06:43:48 <Paprikachu> but whatever
06:43:59 <mcstar> navaati: so it doesnt mean 'for all possible input'
06:44:00 <navaati> mcstar: i was suspecting such a thing, thx
06:44:12 <Paprikachu> off-by-one errors are not made by me
06:44:33 <byorgey> the definition of 'domain' depends on who you ask.
06:44:43 <mcstar> whom
06:44:56 <byorgey> who.
06:44:56 <fmap> ski: aren't "never throws an error" and "never loops" the same thing in general?
06:44:58 <Jaak> Paprikachu: take a look at the presentation by the lead developer of the unreal engines. a large class of the errors they have are out-of-bounds errors
06:45:08 <path[l]> does anyone know how I can memoize a function that takes two arguments
06:45:16 <Jaak> http://www.cs.princeton.edu/~dpw/popl/06/Tim-POPL.ppt
06:45:17 <navaati> fmap: yup : _|_
06:45:19 <Paprikachu> also, the elem' implementation in lyah is dumb
06:45:32 <ski> navaati : yes (depending on the sense in which you use the word "domain" :)
06:45:39 <ski> well, throwing an error means the function is *not* total
06:45:55 <mekeor> how can i solve this issue with cabal?:
06:45:56 <hpaste> mekeor pasted “standard issue with cabal: package needs base==3.*” at http://hpaste.org/69262
06:46:15 <Paprikachu> it should better be: elem _ [] = False; elem x x:xs = True; elem x y:ys = elem x ys
06:46:42 <ski> Paprikachu : where is that ?
06:46:50 <Paprikachu> http://learnyouahaskell.com/recursion#a-few-more-recursive-functions
06:46:52 <navaati> oh, btw, can one think of exception (in haskell) to be like being in an implicit Either context ?
06:46:57 <fmap> elem x x:xs wouldn't work
06:47:08 <path[l]> I read this link, which tells me how I can memoize a recursive function that takes one parameter http://www.haskell.org/haskellwiki/Memoization, but if I take 2 ints as arguments, Im not sure how to memoize
06:47:17 <mekeor> fmap: why?
06:47:21 <mcstar> byorgey: i dont mean this as an insult, but http://web.ku.edu/~edit/whom.html
06:47:56 <Siod> mcstar: you don't understand language, or apparently the current state of english
06:48:05 <navaati> path[l]: something that takes 2 ints is (nearly, modulo strictness) isomorphic to something that takes a pair of ints
06:48:05 <Siod> mcstar: is dying if not already dead
06:48:16 <byorgey> mcstar: I know the rules. but the fact is that 'who' is also correct, because it is widely used in the objective csae, even in print.
06:48:17 <fmap> mekeor: conflicting definitions
06:48:26 <path[l]> right, but the problem is only that there is no defined order I guess
06:48:30 <Siod> mcstar: moreover, prescritivism in an informal context is retarded
06:48:52 <Paprikachu> > let elem' _ [] = False; elem' x x:xs = True; elem' x y:ys = elem' x ys in elem 42 [1,2,42,3,4]
06:48:53 <Paprikachu> > let elem' _ [] = False; elem' x x:xs = True; elem' x y:ys = elem' x ys in elem' 42 [1,2,42,3,4]
06:48:53 <lambdabot>   <no location info>: Parse error in pattern
06:48:53 <lambdabot>   can't find file: L.hs
06:48:54 <Paprikachu> bot dead?
06:49:22 <navaati> path[l]: uh ? pairs have an order, arguments have an order aswell
06:49:28 <Siod> mcstar: people are allowed to use different registers; you're suffering from hyperwhiteness: http://www.linguistics.ucsb.edu/faculty/bucholtz/articles/MB_JLA2001.pdf
06:49:33 <path[l]> oh they do? hmm
06:49:46 <Siod> a common pathology in the it community
06:50:23 <Siod> and hypercorrection: http://en.wikipedia.org/wiki/Hypercorrection
06:51:09 <timthelion> as a person who speaks a language with 7 cases, I agree with mcstar, that English speekers should be able to handle their three, and use whom correctly.  There IS a semantic difference between who and whom.
06:51:11 <mcstar> Siod: thanks for putting mu psichological profile together
06:51:20 <Paprikachu_> > let elem' _ [] = False; elem' x x:xs = True; elem' x y:ys = elem' x ys in elem' 42 [1,2,42,3,4]
06:51:21 <lambdabot>   <no location info>: Parse error in pattern
06:51:27 <Siod> mcstar: no problem :)
06:51:37 <Paprikachu_> fu
06:52:04 <Jaak> > let equal x x {- incorrect -} = True in equal 1 1
06:52:06 <lambdabot>   Conflicting definitions for `x'
06:52:06 <lambdabot>  Bound at: <interactive>:1:10
06:52:06 <lambdabot>            <i...
06:52:14 <moebius_eye> Is there a Haskell bible? Because, I'm a lost sheep, here.
06:52:14 <hpaste> “3noch <elliot@3noch.com>” pasted “Ignoring EOF from STDIN” at http://hpaste.org/69263
06:52:19 <eacameron> My simple program works fine but I dislike the fact that I have to catch EOF errors when reading STDIN. Any thoughts?
06:52:30 <eacameron> That hpaste was mine...
06:52:38 <timthelion> moebius_eye: learn yourself haskell
06:52:46 <Paprikachu_> haskell is a cool and dumb language at the same time
06:52:53 <TUX007> Hi guys. I just got my hands on a haskell pdf pack.
06:53:06 <moebius_eye> TUX007: torrent?
06:53:08 <TUX007> I am going to take 1 month to learn it.
06:53:09 <TUX007> No
06:53:11 <Paprikachu_> it has some cool features, but there are some important features lacking :|
06:53:14 <TUX007> My friend sold it to me
06:53:27 <moebius_eye> Share it! :)
06:53:35 <Paprikachu_> like repeating variables in pattern
06:53:38 <TUX007> I wish.
06:53:48 <Paprikachu_> s
06:53:50 <Ptival> Paprikachu_: to test their equality?
06:53:52 <timthelion> Paprikachu_: what would repeating variables do?
06:53:55 <moebius_eye> Why not, TUX007
06:53:57 <moebius_eye> ?
06:54:01 <Jaak> repeated variables in pattern are ambiguous
06:54:07 <Paprikachu> no, they aren't
06:54:14 <mcstar> Paprikachu_: you are judging haskell prematurely, before you have a feel for it
06:54:14 <Jaak> leads to good old java == problem
06:54:18 <timthelion> Paprikachu: example?
06:54:25 <`Jake`> something like (==) a a = true; (==) _ _ = false ?
06:54:28 <Paprikachu> let f x x = True
06:54:32 <TUX007> moebius_eye: I don't have permission
06:54:33 <Paprikachu> let f x y = False
06:54:34 <mekeor> Jaak: expalin further, pls
06:54:43 * mekeor supports Paprikachu 
06:55:02 <timthelion> what does f x x = even mean?
06:55:08 <`Jake`> that x == x
06:55:12 <Jaak> me: you might get two different objects that are equal in structure
06:55:18 <timthelion> why not use case guards???
06:55:32 <danr> how do I do haddock comments when using bird-style literate haskell?
06:55:33 <mekeor> "f x x =" is the same as "f x y | x == y =".
06:55:41 <moebius_eye> TUX007: and you paid for it?
06:55:46 <timthelion> f x y | x == x = True ;| True = False
06:55:57 <mekeor> x == x ?!
06:55:57 <TUX007> Yes.
06:56:06 <`Jake`> maybe not
06:56:21 <mekeor> timthelion: did you mean "x == y"? you did, right? right.
06:56:25 <timthelion> mekeor: yes
06:56:26 <timthelion> sorry
06:56:28 <mekeor> :)
06:56:41 <Paprikachu> it means that if you pass the same argument twice, the result is what after the = comes
06:56:41 <Paprikachu> i'm used to this from c++
06:56:41 <Paprikachu> ._.
06:56:47 <navaati> mekeor: which mean that a certain form of pattern matching can draw a typeclass constraint ? i find that ugly…
06:57:33 <hdev> does cabal install the package sources somewhere by default (i can only find .hi files or tar.gz), i want to create tags for them
06:57:40 <sabrehagen> window 3
06:57:44 <Ptival> do you assume (==) is transitive, or do you perform pair-wise checks?
06:57:50 <sabrehagen> my bad, sorry
06:58:06 <navaati> sabrehagen: tmux :p ?
06:58:35 <Paprikachu> QQ i want this to work
06:58:36 <sabrehagen> navaati: irssi ;)
06:59:12 <timthelion> danr: I once read a thread on haskell-cafe about it, but still looking for it.
06:59:15 <`Jake`> there's a paragraph about that in realworldhaskell, but I can't find it
06:59:24 <sayuke> how do you match on multiple records like heap{h=thHeap, y=thYoungest, o=thOffset}
06:59:32 <mekeor> anyway guys. i wanna install HGL. i get this error: http://hpaste.org/69262 . how to solve this?
06:59:42 <parcs`> sayuke: like that
06:59:46 <sayuke> sorry im retarded
06:59:52 <sayuke> h->H
06:59:55 <timthelion> danr: http://www.haskell.org/pipermail/haskell-cafe/2009-September/066700.html
07:00:27 <Lemmih> mekeor: Poke the maintainers.
07:00:38 <mparodi> @src zip
07:00:39 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
07:00:39 <lambdabot> zip _      _      = []
07:00:45 <`Jake`> I think I've found it
07:00:53 <danr> timthelion: http://hackage.haskell.org/packages/archive/Takusen/0.8.5/doc/html/src/Database-Enumerator.html
07:00:58 <danr> timthelion: thanks
07:01:06 <mekeor> Lemmih: srsly?
07:01:21 <ski> Siod : well, i welcome the language comments like mcstar's. while i agree that someones people don't agree about what's "right", i still think there is a point in "correcting", so that one may get the chance to decide which to use
07:02:03 <Siod> ski: http://en.wikipedia.org/wiki/Register_%28sociolinguistics%29
07:02:05 <`Jake`> but realworldhaskell doesn't tell us why we can'tuse the same name in a pattern twice, it just tells us that we should use guards instead...
07:02:24 <mparodi> @src unzip
07:02:24 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
07:02:59 <Siod> ski: http://www.reddit.com/r/linguistics/search?q=whom&restrict_sr=on
07:03:37 <mparodi> what is the meaning of ~(as, bs)?
07:03:43 <mparodi> @type (~)
07:03:45 <lambdabot> parse error on input `)'
07:03:50 <mparodi> @type ~
07:03:51 <lambdabot> parse error (possibly incorrect indentation)
07:04:11 <Siod> ski: do you know how annoying, and insulting, it is to correct someone when they're speaking in their dialect?
07:04:15 <timthelion> Siod: The reason we try to maintain a grammar, is not because we want to be assholes, but because we wan't to maintain a certain lack of ambiguity in language.
07:04:39 <Siod> there is no ambiguity with whom/who
07:04:57 <timthelion> Siod: and you call yourself a programmer :D
07:05:11 <mparodi> > foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[]) [1..5] [1..5]
07:05:12 <lambdabot>   Couldn't match expected type `[t1] -> t'
07:05:12 <lambdabot>         against inferred type `([t...
07:05:18 <mparodi> > (foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])) [1..5] [1..5]
07:05:20 <lambdabot>   Couldn't match expected type `t1 -> t'
07:05:20 <lambdabot>         against inferred type `([t2]...
07:06:03 <Siod> timthelion: where you going to show me the ambiguity?
07:06:06 <mcstar> `Jake`: i label in a pattern becomes a binding, thats why, if it would be allowed to bind 2 arguments to the same label, how would you solve shadowing?
07:06:08 <Siod> s/where/were
07:06:09 <mparodi> > let unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[]) in unzip [(1,"a"), (2, "b"), (3, "c")]
07:06:10 <lambdabot>   ([1,2,3],["a","b","c"])
07:06:13 <mcstar> i->a
07:06:16 <mparodi> > let unzip = foldr (\(a,b) (as,bs) -> (a:as,b:bs)) ([],[]) in unzip [(1,"a"), (2, "b"), (3, "c")]
07:06:17 <lambdabot>   ([1,2,3],["a","b","c"])
07:06:35 <mparodi> what is ~? if you remove it the result is the same
07:06:45 <saep> mparodi: ~ tells the compiler that the pattern will match if the preceeding ones have failed (if any) and any succeeding patterns will not be checked
07:06:50 <ski> Paprikachu : the problem with allowing "it means that if you pass the same argument twice, the result is what after the = comes" is that then it becomes very easy to break referential transparency
07:06:56 <mparodi> o.o
07:07:00 <ski> Siod : ty for the links
07:07:02 <mcstar> ~pattern is lazy binding or something, top level definitions use it by default
07:07:04 <timthelion> Siod: Joe: He hit the lady in the Red.  Sally: Whom?
07:07:07 <Paprikachu> why do you mean by that?
07:07:13 <ski> Siod : i can imagine it yes, but i don't understand it. personally i welcome it
07:07:17 <Jaak> > let unzip = foldr (\(a,b) (as,bs) -> (a:as,b:bs)) ([],[]) in unzip (zip [1..] [2..])
07:07:18 <lambdabot>   *Exception: stack overflow
07:07:24 <Jaak> > let unzip = foldr (\(a,b) >(as,bs) -> (a:as,b:bs)) ([],[]) in unzip (zip [1..] [2..])
07:07:25 <lambdabot>   <no location info>: parse error on input `>'
07:07:28 <Jaak> > let unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[]) in unzip (zip [1..] [2..])
07:07:30 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
07:07:36 <timthelion> Siod: Who's identity was inquired about?
07:07:39 <mparodi> I didn't get iy
07:07:47 <`Jake`> mcstar: It would still be nice if there was a sentence in realworldhaskell about the reason for it ;-)
07:07:49 <ski> (Tux_007 : personally, i would think it morally dubious, if not outright wrong, to pay for that kind of information without getting permission to copy)
07:07:59 <Siod> timthelion: yes, there's ambiguity there, but it's a contrived example
07:08:17 <Paprikachu> ski: what do you mean by breaking referential transparency
07:08:34 <Paprikachu> what does this term mean?
07:08:47 <timthelion> Siod: I don't know. In Czech, we ask one word questions all the time like that.  I know it's less common in English.  But probably because most people don't know the details well enough to understand such a question.
07:09:02 <Siod> timthelion: because whom is dying, Sally would simply say Who hit the lady? or What lady?
07:09:38 <Siod> timthelion: moreover most language can be ambigious in contrived examples, but languages is so contextual
07:09:48 <ski> Paprikachu : consider `f x x = True; f x y = False', now consider `let square x = x*x in f square square' vs. `let square0 x = x*x; square1 x = x*x in f square0 square1' -- (unless the compiler uses optimizations/rewritings) the first evaluates to `True', and the second to `False'
07:10:07 <Siod> that's one of the more striking lessons in NLP
07:10:10 <ski> Paprikachu : but declaratively, they *ought* to evaluate to the same thing, since the same function was passed
07:10:13 <mparodi> can you figure out how to define zip using fold* ?
07:10:56 <ski> Paprikachu : there *is* a way to do what you want in GHC, but you have to explicitly ask for it (and you have to check for yourself that your use of it is referentially transparent) -- e.g. using this for memoization is ok
07:10:59 <Paprikachu> i still don't get it
07:11:19 <Paprikachu> `f x x = True; f x y = False', now consider `let square x = x*x in f square square' vs. `let square0 x = x*x; square1 x = x*x in f square0 square1'
07:11:27 <Siod> wow, i butchered that sentence: most language usage can be ambigious in contrived examples because language is so contextual
07:11:30 <Paprikachu> True/False is exactly what the result should be
07:11:41 <Siod> -1 for multitasking
07:11:43 <ski> Paprikachu : i hope you do see why one (under a naïve implenentation, assuming no optimizations) evaluates to `True', and the other to `False', yes ?
07:12:06 <Paprikachu> i do, and this is what should happen
07:12:32 <Siod> timthelion: http://research.microsoft.com/en-us/groups/nlp/
07:12:37 <Paprikachu> strictly speaking, it's comapring addresses of functions
07:12:38 <ski> Paprikachu : we want to be able to replace `let x = blah in f x x' with `f blah blah' and then with `let y = blah in f blah y' and then `let x = blah; y = blah in f x y'
07:12:55 <timthelion> Siod: I actually understant where you are comming from.  As a native English speaker studying in the Czech Republic(I'm half Czech, half American) sometimes I have to take an English exam.  The teachers will mark me off for not using the British English forms.
07:12:58 <ski> Paprikachu : and all of these are supposed to evaluate to the same thing (but maybe the efficiency will be different)
07:13:05 <ski> Paprikachu : yes
07:13:24 <adamt> timthelion: In reality they're just jalous of your english.
07:13:43 <ski> Paprikachu : but ideally we want to compare thw functions for when they "behave the same" -- but this is most often impossible, and otherwise it's commonly not efficient
07:14:01 <Siod> timthelion: teachers expect you to write in your most formal register, which is basically the brahmin dialect of the country
07:14:06 <Paprikachu> no, i dont want that
07:14:06 <ski> Paprikachu : so the problem is that "compare addresses" as an implementation of "behave the same" can give false negatives
07:14:33 <Siod> timthelion: http://en.wikipedia.org/wiki/Prestige_%28sociolinguistics%29
07:14:41 <ski> Paprikachu : well, this is one of the main points of functions in Haskell : that if you pass what is logically the same arguments, you get the same result
07:15:10 <ski> it's one of the things which enable us to refactor code much easier, with no worry about changing the behaiour
07:15:12 <Siod> timthelion: there is no reason we should be taught the higher class dialects as correct, over say african american vernacular english
07:15:41 <Siod> timthelion: it's just society has a habit of valuing high status groups over low status groups, and so it's a kind of implicit classism
07:16:04 <ski> Paprikachu : as an fast check for efficiency's sake, comparing addresses is ok, but one should make sure that the end result is still the same as if we treated them as potentially different
07:16:11 <Paprikachu> obviously they are different functions, so they shouldnt compare equal
07:16:26 <ski> they are not different functions, they behave the same
07:16:27 <eacameron> how do I convert between a ByteString.Lazy.Char8 to a ByteString.Char8??
07:16:50 <Paprikachu> yes, they behave the same, but they are different functions
07:17:20 <ski> Paprikachu : `let x = blah in f x x' should always behave the same. and `let x = foo; y = bar in f x y' should always behave the same as `f foo bar'
07:17:27 <timthelion> Siod: agreed.  But how do you adapt to the various dialects while maintaining understandability?  For example, a person from rural Alabama may be as smart as a person from Seattle, yet they shouldn't be going to a US university not understanding/speeking a costal dialect.  They would fail in the first semester.
07:17:27 <ski> this is what "replace equals for equals" means
07:17:40 <ski> and this is a very powerful way of refactoring code
07:18:01 <Paprikachu> well, x and y are references to functions
07:18:12 <ski> er, the `let x = blah in f x x' should always behave the same as `f blah blah', i meant
07:18:16 <ski> Paprikachu : shouldn't matter
07:18:19 <ski> it should *always* hold
07:18:21 <Paprikachu> it should
07:18:29 <ski> you shouldn't have to consider any caveats
07:18:31 <Paprikachu> example: f x = x * x
07:18:35 <Siod> timthelion: that's a strange thing to say; why wouldn't they understand other dialects. that's like saying an English upper class southerner wouldn't understand a northerner
07:18:38 <Paprikachu> g = f
07:18:42 <Paprikachu> h x = x * x
07:18:53 <Paprikachu> equal f g should yield False
07:18:57 <ski> then all of `f',`g',`h' are conceptually the same function
07:19:02 <Paprikachu> err, True
07:19:05 <timthelion> Siod: even if they do understand costal dialects, they won't be understood.
07:19:11 <Jaak> mhmhh, the extensional view is inherant to haskell
07:19:14 <Paprikachu> but equal f h yields False
07:19:18 <ski> Paprikachu : do you agree about my `let ...' examples ?
07:19:30 <mcstar> you cant structurally compare functions
07:19:32 <Siod> timthelion: of course they would be
07:19:48 <Paprikachu> yes, i think
07:20:07 <timthelion> Siod: I have met many people in the US I didn't understand.
07:20:48 <ski> Paprikachu : then consider `let f x = x*x; h x = x*x in hasSameAddress f h'
07:21:04 <ski> Paprikachu : this should be the same as `let f = \x -> x*x; h = \x -> x*x in hasSameAddress f h'
07:21:05 <Siod> http://accent.gmu.edu/browse_language.php?function=detail&speakerid=445
07:21:30 <ski> Paprikachu : which should be the same as `let f = \x -> x*x in hasSameAddress f (\x -> x*x)'
07:21:39 <ski> Paprikachu : which should be the same as `hasSameAddress (\x -> x*x) (\x -> x*x)'
07:21:43 <mcstar> Siod: i think ethnic or other variations in a language usually introduce ambiguity and degradation, (besides phonetic abberations) so this process shouldnt be welcomed in my view
07:21:49 <Paprikachu> you say it should, i say it shouldnt
07:21:52 <ski> Paprikachu : which should be the same as `let fh x = \x -> x*x in hasSameAddress fh'
07:22:00 <ski> er `let fh x = \x -> x*x in hasSameAddress fh fh'
07:22:08 <ski> Paprikachu : which should be the same as `let fh x = x*x in hasSameAddress fh fh'
07:22:09 <Paprikachu> `hasSameAddress (\x -> x*x) (\x -> x*x)' <<< this should yield True
07:22:20 <ski> why ?
07:22:21 <mparodi> @instances Bool
07:22:22 <lambdabot> Couldn't find class `Bool'. Try @instances-importing
07:22:27 <mparodi> @class Bool
07:22:27 <lambdabot> Unknown command, try @list
07:22:30 <Jaak> yep, and you have nicely reached the issues with javas == operator...
07:22:38 <Paprikachu> because the lambda does not exist more than once in the binary.
07:22:47 <mparodi> @list
07:22:48 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
07:22:53 <ski> Paprikachu : given a naïve implementation, `hasSameAddress (\x -> x*x) (\x -> x*x)' will allocate two functions
07:22:58 <eacameron> ok I found ByteString's toChunks. Curious why toChunks returns a [ByteString] instead of just a ByteString...?
07:22:59 <Paprikachu> it's the same function
07:23:20 <ski> Paprikachu : ok, replace `\x -> x*x' with `\x -> a*x', where `a' is an input to the "outer" function we're writing this code inside
07:23:29 <Siod> the following thread should answer your questions: http://www.reddit.com/r/linguistics/comments/k42c1/linguistic_prescriptivism_how_can_it_not_be/
07:23:31 <ski> better ?
07:23:44 <Paprikachu> then they're different lamdbas, so it should return false.
07:23:53 <bscarlet> Paprikachu: Why should all functions even have to have an address?
07:23:53 <ski> no
07:24:06 <ski>   hasSameAddress (\x -> a*x) (\x -> a*x)
07:24:07 <mekeor> how can base-3.0.3.2 depend on "base >=4.0 && <4.3" ?!???  -- sometimes i hate cabal.
07:24:10 <Paprikachu> bscarlet: i didn't say that
07:24:18 <ski> both lambdas read the same, just as with `\x -> x*x'
07:24:20 <Paprikachu> oh, you mean you pass it twice?
07:24:24 <ski> yes
07:24:25 <Paprikachu> then it's true.
07:24:39 <Paprikachu> i was talking about one lambda being x * x and the second a * x.
07:24:57 <ski> i pass the same expression twice, but the implementation will probably (assuming no optimization) create two closures
07:25:11 <ski> and thus pass two closures with different memory addresses
07:25:18 <timthelion> Siod: calling a Snak a snæ already prevents understandability.
07:25:20 <ski> Paprikachu : oh, ok
07:25:21 <mparodi> How do I redefine the instance of Show Bool? I'm getting "Duplicate instance declarations: ..."
07:25:42 <ski> mparodi : define a new `Bool' ...
07:25:48 <Siod> timthelion: ?
07:26:01 <geekosaur> mekeor: if it's talking about versions if base, you have already lost.  note that versions of base really mean versions of ghc
07:26:06 <Siod> timthelion: did you see my link?
07:26:18 <mparodi> data Bool = True | False ?
07:26:19 <timthelion> Siod: It is only because most Alabamans learn how to speak "more like CNN" as they grow up, that we can understand them at all. Their children are harder to understand, and visit them for lunch and you won't grasp a word they say.
07:26:30 <geekosaur> so if something is talking about them, you need to find out what version of GHC the package wants you to be using
07:26:30 <mekeor> geekosaur: s/if/of/ ??
07:26:37 <ski> Paprikachu : .. btw, i'm sorry if my explanation attempt became a bit garbled above
07:26:47 <mekeor> geekosaur: oh, okay. foo.
07:26:51 <geekosaur> ...versions of base, yes
07:26:55 <timthelion> Siod: I'm refering to your link
07:27:00 <Siod> timthelion: seriously, that question answers you in depth
07:27:05 <Siod> link
07:27:18 <mekeor> geekosaur: then i really have to contact the maintainer. i did so already, actually. but it will take some time… argh!  thanks anyway.
07:27:23 <Siod> timthelion: http://www.reddit.com/r/linguistics/comments/k42c1/linguistic_prescriptivism_how_can_it_not_be/
07:27:29 <mparodi> ski, is it what you mean? data Bool = True | False
07:27:30 <geekosaur> sadly there is no straightforward mapping between base and ghc versions, although there is probably a list somewhere
07:27:40 <mekeor> :/
07:28:04 <ski> mparodi : yes, except `data Bool = False | True' :)
07:28:05 <timthelion> Siod: perhaps we should move this to -blah?
07:28:15 <ski> Paprikachu : ok, so which step in the sequence of purportively equal expressions don't you agree with ?
07:28:21 <mparodi> is there any difference?
07:28:27 <Siod> timthelion: this discussion has already been had in http://www.reddit.com/r/linguistics/comments/k42c1/linguistic_prescriptivism_how_can_it_not_be/
07:28:39 <navaati> mparodi: yep, in the Enum and Bounded instances of Bool
07:28:45 <mparodi> ah, sure
07:28:50 <mparodi> anyway, it says Ambiguous occurrence `Bool'
07:28:56 <mparodi> Ambiguous occurrence `True'
07:28:59 <mparodi> Ambiguous occurrence `False'
07:28:59 <navaati> > [minBound..maxBound] :: [Bool]
07:29:00 <lambdabot>   [False,True]
07:29:07 <ski> (timthelion : better be careful with shapr ..)
07:29:27 <navaati> mparodi: you need to define something with another name, or mask the Prelude one
07:29:35 <Paprikachu> can we continue the discussion later (i.e in ~3 hours)?
07:29:41 <ski> mparodi : `import Prelude hiding (Bool)'
07:29:45 <Paprikachu> i'm still at school
07:29:45 <navaati> data MyBool = MyFalse | MyTrue
07:29:49 <ski> Paprikachu : ok
07:30:38 <ski> mparodi : you should also consider enabling an extension that lets the `if ... then ... else ...' syntax use your `Bool' type
07:30:44 <ski> (and guards, iirc)
07:31:00 <mparodi> an extension?
07:31:02 <mparodi> hmn..
07:31:19 <ski> mparodi : btw, why do you want to change `Show Bool' ? -- the instance is already correct
07:31:38 <ski> changing it to behave in any other way would be incorrect
07:31:57 <mparodi> I know, I was just trying to print "Falso" and "Verdadero" instead (book's exercise...)
07:32:05 <ski> ok, i see
07:32:25 <mparodi> it works but I can't use this Bool instance for anything else other than show lol
07:32:34 <ski> mparodi : well, the simplest is then to say something like `data Boolean = Falso | Verdadero', and then `instance Show Boolean where ...'
07:32:51 <ski> you could define a `toBool :: Boolean -> Bool'
07:33:03 <ski> (/me isn't sure how to translate `Bool' to spanish(?))
07:33:14 <int-e> Boole is a name :P
07:33:26 <mparodi> in Spanish, "Bool" as well
07:34:04 <ski> well, `import Prelude hiding (Bool)' should work
07:34:13 <mparodi> yep, it works
07:34:15 <mparodi> thanks
07:34:20 <ski> (possibly together with `import qualified Prelude as P')
07:34:27 <ClaudiusMaximus> what condition on p > 1 is necessary and sufficient for  (\x -> (p * x) `mod` w) to be invertible over x in [0..w) ?  (context: tricking repa's spatially correlated evaluation into scaling more reliably to multiple cores for images where pixels are independent but work needed per pixel is spatially correlated)
07:34:49 <mparodi> (actually we say "Booleano" instead of "Boolean", but the abbreviation is the same)
07:35:00 <int-e> ClaudiusMaximus: p coprime to w
07:35:13 <ski> int-e : yeah, but sometimes you can "translate" names (make them sound more as a domestic one) :)
07:35:33 <`Jake`> I guess in esperanto, Boole would be Bulo
07:35:56 <ski> ClaudiusMaximus : also holds for `p >= 0'
07:36:23 <int-e> ski: and for p<0, to :)
07:36:31 <ClaudiusMaximus> int-e: ok cool, thanks :)  any cool algorithms like: given w, find a p coprime to w such that w/p ~= phi = (sqrt 5 + 1) / 2   ?
07:36:35 <mparodi> ok, and what about this one: how do you define zip using fold*? I couldn't find any simple way
07:36:39 <ski> yeah, but i was assuming only natural numbers existed :)
07:36:53 <int-e> ClaudiusMaximus: yes, take two consecutive fibonacci numbers
07:37:02 <`Jake`> and Haskell would be haskelo in esperanto
07:37:06 <ClaudiusMaximus> int-e: w isn't free
07:37:39 <ClaudiusMaximus> int-e: in my particular case, w is 2^k+1  for some natural k
07:37:48 <ski> ClaudiusMaximus : hm, maybe you could take the largest factor of `w' which is a fibonacci number, and "replace" it with the next one ?
07:38:07 <ski> possibly there are better approaches
07:38:09 <int-e> ClaudiusMaximus: oh. sorry, no cool algorithm then.
07:38:33 <ski> (requiring to find the largest factor is probably not that good)
07:39:23 <ski> (or i suppose in the general case some proportion (probably not half) of the factors will need to be found and tried)
07:39:49 <ClaudiusMaximus> thanks for the ideas :)  i think i'll go with exhaustive search for "best" p and memoize it for each w, as i only need it for w in [ 2^k+1 | k <- [4 .. 12]] or so
07:40:45 <ClaudiusMaximus> (this is the kind of thing i've been making this week with repa: http://claudiusmaximus.goto10.org/g/mandelbrot/newton-basins-3/ )
07:41:14 <mcstar> ski: how about using a type synonym? and enabling TypeSynonymInstances ?
07:41:19 <Paprikachu> i'm off now, have to do something for school
07:41:24 <Paprikachu> see you later guys :)
07:41:25 <ski> (also the "find factor ..." idea probably wouldn't be "smooth" as `w' increases)
07:41:41 <ski> mcstar : type synonym for what ?
07:41:48 <mcstar> for Bool
07:41:59 <mcstar> so you can have a different show
07:42:09 <ski> mcstar : you still need to avoid the existing `Show Bool', so this doesn't work
07:42:47 <ski> you can't say `type Bulo = Bool' and then `instance Show Bulo where ...', since this'll clash with `instance Show Bool'
07:42:58 <ski> (because `Bulo' *is* the same type as `Bool')
07:43:52 <ski> `TypeSynonymInstances' only enables you to use type synonyms in instance heads -- it does not allow you to use different instances for the synonym than for the type it is a synonym of
07:44:03 <mcstar> ok
07:44:22 <mcstar> so you cant 'subtype' Bool
07:44:23 <ski> (so it's main use if for abbreviation)
07:44:29 <ski> subtyping ?
07:44:37 <mcstar> well, sort of, like in OO
07:44:51 <ski> yes, i know, but i don't see where subtyping comes in here
07:44:55 <mcstar> you keep what you need(those instance declarations) but override some, like Show
07:44:57 <ski> but no, there's no subtyping in Haskell
07:45:02 <ski> @where O'Haskell
07:45:02 <lambdabot> extension to Haskell adding subtyping and records, plus non-blocking reactive communication, by Johan Nordlander, Magnus Carlsson, and Bjrn von Sydow, at <http://web.archive.org/web/20090517021445/
07:45:03 <lambdabot> http://www.cs.chalmers.se/~nordland/ohaskell/>, also see `Timber'
07:45:04 <ski> @where Timber
07:45:05 <lambdabot> concurrent, reactive, event-driven language that was inspired by O'Haskell, <http://timber-lang.org/home.html>. also see `O'Haskell'
07:45:08 <ski> might be interesting
07:45:12 <ski> those have subtyping
07:45:17 <ski> you could say
07:45:23 <navaati> woaw, pattern matching is possible at toplevel, so yummy !
07:45:29 <ski>   data FileBool > Bool = FileNotFound
07:45:30 <mcstar> ski: no, i dont want that, not particularly fond of OO
07:45:42 <timthelion> navaati: hm?
07:45:47 <ski> mcstar : this is not really like traditional OO, it is just subtyping added to Haskell
07:46:30 <mcstar> ski: what problem do type families address?
07:46:30 <timthelion> is the haskell name trademark?
07:46:36 <ski> mcstar : O'Haskell doesn't provide any overriding -- it doesn't even provide (co)inheritance
07:46:48 <navaati> timthelion: i can write "[keyStateDown,keyStateUp] = map keyState [Down,Up]" as a toplevel declaration, and it will export into module scope keyStateDown and keyStateUp
07:47:01 <ski> mcstar : MPTC (with FDs) often get clunky to use
07:47:23 <ski> timthelion : not sure, but i think no
07:47:56 <ski> (since there's this joke about "blah, blah, Miranda[0], blah blah -- [0] Miranda is a registered trademark of ...")
07:48:11 <timthelion> navaati: ah. of course, there is nothing special about the top level.
07:48:31 <mcstar> Meta-Polar Tetrion Collision? with Fermat Disintegrators?
07:48:34 <navaati> yeah, yeah, but it's so f*cking powerful…
07:48:34 <ski> navaati : yes, you can write `keyStateDown,keyStateUp :: ...' as well
07:49:04 <timthelion> ski: good, since I'm writting a stack based language with "haskell" in it's name.
07:49:08 <navaati> ski, yeah, handy. the only drawback is that haskell-mode does not color it the right way
07:49:17 <ski> timthelion : you could ask on the mailing list, to be sure
07:49:38 <ski> navaati : ok :/
07:49:48 <sipa> mcstar: multi parameter type classes and functional dependencies
07:49:48 <ski> (complain to chrisdone ?)
07:49:50 <timthelion> ski: I presume it's hard to trademark someone ELSES name.
07:50:00 <mcstar> thx
07:50:05 <ski> (mcstar : sorry, didn't notice your question)
07:50:11 <timthelion> Since we aren't exactly close associates with Mr. Curry himself.
07:50:23 <ski> could be
07:50:34 * ski has very little idea about how trademarking laws work
07:50:45 <navaati> ah, chrisdone is the maintainer, nice, since i had another problem with haskell mode (wrong indentation with UnicodeSyntax)
07:51:30 <navaati> isn't miranda a name aswell ?
07:52:26 <OliverB> Can anyone tell me what the point of 'drop' in Conduit having type Sink is? I would have expected it would make more sense as an  Int -> Conduit a m a  … or rather Int -> Pipe a a m ()
07:52:51 <timthelion> navaati: not all trademarks are valid.  Infact, most trademarks don't hold up in court :D
07:53:15 <ski> navaati : istr some programmer naming their daughters "Joy","Miranda" ..
07:53:47 <navaati> aww, man, these IP laws are so… *sigh*
07:54:54 <ski> OliverB : apparently it's meant to effectfully drop ("eat") some items, instead of transferring on all but the dropped items ..
07:55:33 <timthelion> navaati: the good news, is most of them are unconstitutional.  Since the constitution only protects congresses right to promote the well being of inventors and creators, and not stifle it.
07:55:57 <timthelion> navaati: if you are in the US that is.  The rest of the world is slave to the US anyways, so it doesn't mater.
07:56:16 <mparodi> @instances Integral
07:56:17 <lambdabot> Int, Integer
07:57:08 * hackagebot monad-loops 0.3.3.0 - Monadic loops  http://hackage.haskell.org/package/monad-loops-0.3.3.0 (JamesCook)
07:57:09 <navaati> timthelion: you have the unluck of being in a country where IP laws are the most fucked up, and the luck of being in a country where you can go to the tribunal to make the constitution be respected
07:58:04 <geekosaur> ...if you can afford to
07:58:09 <timthelion> navaati: what? I live in Prague :D
07:58:29 <Clint> "most fucked up" seems like an exaggeration
07:58:56 <timthelion> Clint: Europe is better, no software patents here.
07:59:04 <moebius_eye> What???
07:59:07 <Clint> that's what you think
07:59:16 <moebius_eye> timthelion: that's bullshit.
07:59:29 <Clint> the US also doesn't have patents on math
07:59:35 <moebius_eye> No software patent? Really?
07:59:53 <OliverB> ski: I must be missing something, isn't Sink the end of the pipeline? I don't see how you would use it …
08:01:39 <timthelion> moebius_eye: really, no software patents.  You have to phrase it in "the maner in which the hardware interfaces and interacts with the software.  That's patentable.  But software is not.
08:02:12 <Clint> which is exactly the same in the US
08:02:47 <moebius_eye> OK, then, so I can recompile some patented code, with different flags, and I'm not infringing?
08:03:15 <timthelion> Clint: no it is not.  For example, mplayer is distributable in Europe because we have no software patents.  Where as in the US, the data codecs for media ARE patentable, and mplayer cannot be distributed(a la openSUSE not having it, Novel being in the US and not Europe)
08:03:22 <moebius_eye> And I can sell the resulting binaries, then.
08:03:23 <ski> OliverB : i don't claim to understand pipelines, but something like `do drop ...; ...' ?
08:03:32 <timthelion> moebius_eye: that's copyright, not patent
08:03:56 <Clint> timthelion: they're not patentable; they're just patented
08:04:05 <timthelion> Clint: hm?
08:04:16 <OliverB> ski: Ah - I see, I can use the Monad instance to use it in a not totally linear pipe
08:04:33 <Clint> timthelion: you can't patent math
08:04:38 <sipa> they are patented until being challenged in court for not being patentable
08:04:42 <timthelion> Clint: Like you say that if it ever went to court Codec would be defined as an algorithm and an algorithm is math and the patents would fail?
08:05:00 <Clint> timthelion: well, only in the theoretical case
08:05:03 <timthelion> Clint: so why doesn't Novel just kill the patents on those codecs?
08:05:18 <timthelion> Clint: it costs them money now to licence the codecs.
08:05:27 <timthelion> for the paid version of SUSE
08:05:28 <Clint> because of judicial corruption, basically
08:05:46 <navaati> less money than going to court, and also because sometimes judges are cunts
08:05:56 <sipa> there is a f*cking patent on repeatedly applying a compression algorithm until a result of the requested size is reached - that is not patented math, that ia patented math nonsense
08:06:47 <timthelion> sipa: Apple has a patent on sliding menues on small screened devices.  They used it to block the zune from sale for about 6 mos
08:07:13 <int-e> sipa: I have this great program that can compress any file larger than 1 MB. decompression is planned for the next version ...
08:07:18 <dolio> How could you possibly patent the compression thing?
08:07:52 <dolio> I bet there are thousands of people out there who have zipped files multiple times in the hopes of getting more compression.
08:08:05 <timthelion> dolio: some greek guy has a patent on a wheel that spins infinitly, powered on by magnets at the bottom which push it arround.  The machine generates infinite free energy :D
08:08:05 <sipa> not that i agree with that being patented, timthelion, but at least there is *some* contribution or idea there, instead of mathematical impossibility
08:08:12 <barrucadu> dolio: All sorts of stupid trivial things are patented
08:08:13 <int-e> dolio: sometimes it even works.
08:08:14 <dolio> It's an idea so obvious that non-experts would think of it.
08:08:36 <barrucadu> dolio: Last time I checked, Google have a patent on a linked list with an auxillary pointer.
08:09:08 <int-e> the patent system is just broken
08:09:20 <dolio> I wouldn't even be surprised if the patent examiner had done that sort of thing before reading the patent.
08:09:36 <timthelion> int-e: I agree.  Being totally serious, I would get rid of it, but strengthen copyrights.
08:09:37 <navaati> are patn
08:09:57 <navaati> are patent examiners lawyers or engeeners ?
08:10:01 <navaati> (or both ?)
08:10:08 <Clint> the one i know is a lawyer
08:10:08 <timthelion> navaati: they are clerks
08:10:08 <tulinius> Either, i think.
08:10:09 <int-e> timthelion: hmm. but shorten the protection period for copyrights.
08:10:15 <timthelion> int-e: also agreed
08:10:15 <navaati> s/are x/are x supposed to be/
08:10:26 <OliverB> You just need to take the trivial idea and add sufficient obfuscation and legalese so that no one knows it's trivial ..
08:10:31 <dolio> The people I knew who were examiners got engineering degrees, but there are elements of both.
08:10:43 <Clint> patent lawyers are also supposed to be technical
08:10:55 <timthelion> int-e: but I really think people shouldn't download films.  They do cost money to make.  I just want to have the freedome to implement MY ideas, I have nothing against protecting the hard work of others.
08:10:59 <OliverB> But then the original purpose of patents was to communicate great ideas, so it's not working so well
08:11:29 <sipa> 5-10 years copyright by default, extensible to 15-25 something by registering it for only an administrative cost
08:11:37 <sipa> that would be reasonable to me
08:11:39 <navaati> so if they are technical, how the fuck can they approve such stupid patents ?
08:12:29 <barrucadu> They get paid a fortune
08:12:41 <barrucadu> It's in their interests to approve patents and so get lots of business
08:12:54 <timthelion> sipa: I have a bigger problem with the transferability of copyright.  Why should I pay some investment firm money?  Just because they bought a copyright, I have no moral resposibility to ensure their investment is proffitable.
08:13:19 <mcstar> a patent only needs to be original, thats all, at least in hungary(and shouldnt obviously contradict natural laws)
08:13:52 <barrucadu> Original and non-obvious to an expert in the field is the UK requirement, IIRC
08:14:12 <taylorgb> Copyright legislation isn't really fit for digital media, as it requires you to control access, which you really can't do.
08:14:21 <mcstar> barrucadu: yes, it must be 'new' in some sense
08:14:49 <Saizan> all of this is off topic btw :)
08:15:22 <monochrom> someone should go patent Type Directed Name Resolution!
08:18:00 * ski . o O ( "The Surprising History of Copyright and The Promise of a Post-Copyright World" by Karl Fogel in 2011-03(?) at <http://questioncopyright.org/promise> )
08:19:26 <locci> hi, how would I signal stop enumerating to toEnum?
08:19:38 <Clint> eh?
08:20:32 <mcstar> :)
08:21:04 <ski> .. i think `Signal' is already in `Enum', since it's `CInt'
08:21:59 <locci> right now I'm forcing the enumeration order using a list, so I implemented toEnum as toEnum x = theList !! x
08:22:18 <ski> timthelion : aren't you thinking about patents there, not copyright ?
08:22:49 <locci> which raises an exception when the enumeration reaches the end of the list
08:22:58 <ski> locci : are you talking about `System.Posix.Signals.Signal' ?
08:23:37 <timthelion> ski: what do you mean?
08:24:09 <zezikaro> is "<-" always used in IO operations?
08:24:14 <zezikaro> or system calls
08:24:26 <ski> timthelion : otherwise, why would you need to pay them money for something you're invented yourself ?
08:24:28 <locci> ski, I don't think so. Maybe I'd better post a tiny bit of code
08:24:35 <ski> @hpaste
08:24:36 <lambdabot> Haskell pastebin: http://hpaste.org/
08:24:54 <timthelion> ski: I mean like when I buy a book from a dead author, I have trouble paying money to some firm that bought their estate.
08:24:59 <OliverB> Hackage clearly needs to be restricted and commercialized, royalties for each library… it's way too open
08:25:10 <ski> zezikaro : (a) not `<-' isn't always used when doing `IO'; and (b) `<-' is also sometimes used when not doing `IO'
08:25:17 <hiptobecubic> timthelion, why?
08:25:31 <timthelion> hiptobecubic: why should I? I have NO moral obligation to do so.
08:25:49 <zezikaro> uhhh
08:25:52 <zezikaro> o.O
08:25:54 <geekosaur> zezikaro, it's part of do notation.  and it's secretly very similar to the arrow pointing the other way
08:26:07 <ski> timthelion : i thought reselling was ok under copyright law ?
08:26:23 <hpaste> locci pasted “Card deck” at http://hpaste.org/69268
08:26:44 <timthelion> ski, it is allowed, but I don't like it.  By not paying that firm, I'm not preventing anyone from being rewarded for their productive labors.
08:27:10 <hiptobecubic> timthelion, that's not true. The current owner paid for the estate which included the rights to the book. It's like not paying for something because it was created on contract with no royalties.
08:27:14 <geekosaur> @undo do { x <- getLine; putStrLn x }
08:27:15 <lambdabot> getLine >>= \ x -> putStrLn x
08:27:25 <hiptobecubic> not that that's relevant here...
08:27:31 * hiptobecubic goes back to cramming
08:27:32 <timthelion> hiptobecubic: paying for something is not the same as doing a productive labor :D
08:27:50 <locci> the problem I'm experiencing is that when the enumeration reaches the end of the list, !! raises an exception
08:27:52 <hiptobecubic> timthelion, it's better. It's instantaneous.
08:29:27 <ski> timthelion : you don't like not paying the firm ?
08:29:46 <ski> (i.e. what's "it" in "it is allowed" ?)
08:29:49 <timthelion> ski: I don't like paying the firm
08:30:08 <timthelion> ski: the firm is aloud to buy the copyright
08:30:15 <timthelion> allowed
08:30:32 <ski> yes, but that doesn't (legally) stop you from reselling the book you bought
08:30:49 <ski> (at least afaik, ianal, &c.)
08:31:04 <timthelion> ski: it legally stops me from downloading a book written in 1920 buy a guy who is long dead.
08:31:13 <timthelion> s/buy/by
08:31:21 <otters> @pl \x y z -> [x,y,z]
08:31:22 <lambdabot> (. ((. return) . (:))) . (.) . (:)
08:31:27 <matthiasgorgens> Has anybody here worked with the haskell bindings to curl?
08:31:52 <ski> timthelion : well, this isn't physical matter, so it's not obviously the same thing as with dead-tree books (which i thought you were talking about)
08:31:56 <otters> matthiasgorgens: I have
08:31:57 <mcstar> > toEnum 2323453422 :: Char
08:31:58 <lambdabot>   *Exception: Prelude.chr: bad argument: 2323453422
08:32:03 <mcstar> locci: ^^
08:32:27 <timthelion> ski: oh.
08:32:51 <timthelion> ski: does my point make any sense to you?
08:32:51 <matthiasgorgens> otters: good. :o)  I use the `simple' i.e. multithreaded interface.  Starting a download works fine, but I want to interrupt it.  I am trying to kill the thread it's one, but killThread just blocks.  did you try something like that?
08:32:55 <ski> timthelion : i think if you get sold a physical book under the agreement that you can't resell it, then reselling it wouldn't be a problem except with reference to that agreement
08:33:27 <matthiasgorgens> timthelion: also if you found a physical book that somebody lost, you wouldn't be bound by that agreement of the loser.
08:33:44 <matthiasgorgens> (though you might have to give it back.)
08:33:46 <locci> mcstar: but I can enumerate all the chars without having exceptions thrown, but in my case [Card Five Hearts ..] raises an exception as soon as the enumeration reaches the end of list
08:33:49 * timthelion has an epipheny. 
08:34:08 <timthelion> Lets make a used ebook store!
08:34:10 <ski> timthelion : i think the usual claim with non-physical books is that you aren't simply sold the book, instead you agree to follow a licence which could forbid you from doing stuff like reselling
08:34:17 <locci> so I guess there has to be a way to tell the program when to stop the enumeration
08:34:20 <geekosaur> locci, you want Bounded
08:34:23 <ski> i'm not sure whether this holds water, though (ianal)
08:34:29 <mcstar> locci: i dont think you instance definition for Enum is complete
08:34:56 <matthiasgorgens> timthelion: there are other people with similar ideas making those arguments in courts.
08:35:06 <timthelion> matthiasgorgens: :D
08:35:11 <timthelion> anyways I'm off
08:35:13 <barrucadu> I think the argument is that you're not sold a copy of the ebook, you're sold a license agreement which lets you read the ebook subject to certain draconian restrictions
08:35:16 <locci> geekosaur: Bounded works because it is implemented by the compiler. I had to use a list because I was having problems (deriving Enum didn't work)
08:35:23 <matthiasgorgens> timthelion:  http://duckduckgo.com/?q=used+ebooks
08:35:36 <locci> mcstar: I'll check
08:35:52 <barrucadu> eg "I agree Amazon can delete this ebook without my permission if they want" (etc)
08:35:58 <ski> timthelion : let's implement a system for "losing non-physical books", and for others to "find them" ! :)
08:35:58 <geekosaur> no, Bounded works because something, which can be you or an automated derivation, defines its minBound and maxBound for a type.
08:37:23 <geekosaur> Enum for Bounded types is defined in terms of Bounded; this is a convention, not a compiler-enforced thing
08:37:54 <geekosaur> (and has at times been subject to discussion because of the different behavor of Enum with Bounded)
08:39:22 <ski> locci : `toEnum n | inRange ((boundSize :: Seed) * (boundSize :: Value)) n = deck !! n where boundSize = maxBound - minBound + 1 | otherwise = error "..."' ?
08:39:33 <geekosaur> it *is* a somewhat messed up arrangement, or at least not a clean separation of concerns.  but the only "built in" aspect of it is that most people use automated deriving; if you choose to write your own, the onus is on you to follow the rules
08:40:17 <geekosaur> See http://www.haskell.org/ghc/docs/7.0.4/html/libraries/base-4.3.1.0/Prelude.html#t:Enum
08:40:23 <ski> hm, i suppoe there needs to be a few `toEnum's/`fromEnum's littered in there as well
08:40:28 <geekosaur> which tells you the rules for Enum, and the rules for Enum with Bounded
08:41:04 <ski> geekosaur : "For any type that is an instance of class Bounded as well as Enum, the following should hold:" :(
08:41:30 * geekosaur has the odd feeling that he had just said that, multiple times...
08:41:33 <ski> (this suffers from the third-party problem)
08:42:08 <ski> (perhaps this is what you alluded to, by "somewhat messed up arrangement")
08:42:53 <geekosaur> yes
08:43:54 <geekosaur> also alluding to a thread on -cafe some time back (a year or so) where a new hierarchy was proposed and promptly bikeshedded to death
08:44:45 <geekosaur> touching on the Enum/Bounded relationship, the conflation of enumerations and ranges, the meaning if ny of the Float and Double instances of Enum, etc.
08:45:01 <geekosaur> er.  "the meaning (if any) of"
08:53:31 <Botje> mmm, bikeshedding..
08:57:10 <ski> geekosaur : *nod*
08:57:17 <locci> I see now.
08:58:19 * ski wonders how to shed a bike
08:58:28 <ski> @wn shed
08:58:29 <lambdabot> *** "shed" wn "WordNet (r) 3.0 (2006)"
08:58:29 <lambdabot> shed
08:58:29 <lambdabot>     adj 1: shed at an early stage of development; "most amphibians
08:58:29 <lambdabot>            have caducous gills"; "the caducous calyx of a poppy"
08:58:29 <lambdabot>            [syn: {caducous}, {shed}] [ant: {lasting}, {persistent}]
08:58:30 <locci> Now I'm left wondering why it mostly worked in the first place.
08:58:31 <lambdabot> [13 @more lines]
08:58:41 <locci> thank you
08:58:56 <ski> locci : you could annotate the paste with your new code, if you wish
08:59:06 <navaati> well, it is widely accepted that the Enum instances of Double and Float have absolutely no meaning and should go burn in hell, isn't it ?
08:59:18 <mauke> ski: it's (bike shed)-ing, not bike (shedding)
08:59:47 <navaati> (wow, i've just read "you could annotate the past with your new code, if you wish" and started to imagine crazy stuff)
08:59:50 <RichyB> mauke, "ow! I just dropped a bike on my foot!" is a fun mental image though.
08:59:56 <geekosaur> except by those who make use of the instances and complain bitterly whenever their inhgerent wrongness is raised
09:00:11 <geekosaur> inherent (I kan tipe)
09:00:13 <ski> locci : btw, isn't "Seed" traditionally named "Suit" ?
09:00:23 <navaati> this kind of people exist ? damn…
09:00:54 <hpaste> locci annotated “Card deck” with “Card deck (annotation)” at http://hpaste.org/69268#a69271
09:01:16 <navaati> > [0.05,0.06..]
09:01:16 <lambdabot>   [5.0e-2,6.0e-2,6.999999999999999e-2,7.999999999999999e-2,8.999999999999998e...
09:01:33 <navaati> -_-
09:01:44 <armlesshobo> > [1..52]
09:01:45 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
09:01:55 <armlesshobo> 52 pick up :)
09:01:59 <ski> mauke : oh, it's <http://en.wiktionary.org/wiki/shed#Etymology_3>
09:02:17 <locci> ski: I don't really know, but very probable. Googling seed vs suit just gives me gundam results
09:02:25 <mauke> haha
09:02:48 <ski> locci : see <http://en.wikipedia.org/wiki/Card_deck#Suits>
09:02:51 <zezikaro> hi, what sort of application can I make to learn more about haskell ?
09:03:08 <mauke> .oO( a haskell compiler )
09:03:47 <bscarlet> zezikaro: one you need
09:04:00 <mekeor> zezikaro: just write any application in haskell.
09:04:01 <zezikaro> Does an artist need a painting?
09:04:05 <bscarlet> zezikaro: (or want)
09:04:32 <zezikaro> par example? :o
09:05:27 <bscarlet> zezikaro: The point is it'd be good to choose something you personally find motivating. You'll be best at answering that.
09:05:33 <mekeor> zezikaro: a minimalistic calculator or editor.
09:05:58 * mekeor finds calculators nice.
09:06:03 <zezikaro> So you're suggesting things that actually need a gui
09:06:03 <nand`> infix <-> RPN convertor
09:06:22 <mekeor> zezikaro: no
09:06:35 <zezikaro> I can do infix to postfix, i've made one in java and c#
09:06:35 <bscarlet> zezikaro: Maybe a more useful angle for you would be to decide what part of Haskell you want to learn next.
09:06:59 <zezikaro> the next chapter is...
09:07:11 <zezikaro> well there was one thing i wanted to do, but it's bloody hard
09:07:12 <tulinius> Look at bugtrackers for various Haskell projects, and fix some bugs. ;)
09:07:13 <zezikaro> print a tree
09:07:16 <mekeor> zezikaro: personally, i prefer stdin and stdout and command-line arguments as the only interface…
09:07:31 <dmwit> zezikaro: I recommend that as your next project.
09:07:42 <dmwit> Bloody hard things that you also want to do... the perfect matchup!
09:07:45 <navaati> zezikaro: printing a tree is not so hard and an interesting (and very functional-style) stuff
09:07:48 <zezikaro> dmwit I don't know how i'd even do that in a language i'm familiar with
09:07:59 <bscarlet> zezikaro: great!
09:08:00 <zezikaro> navaati printing it such that it's 'visually nice'
09:08:05 <ski>   "When I first started to learn Haskell in 1999, I decided I needed a project. Haskell was my first (modern) functional language and I was seduced by its robust strong type system and efficiency gains. After writing a toy ray-tracer (my usual first project in a new language) it was clear I needed to try something somewhat more challenging and jhc was born."
09:08:15 <ski>   "My reasoning was simple, by writing a Haskell compiler in Haskell I will double my language learning speed since I will not only have to learn how to program in it by forcing myself to complete a non-trivial project, but also its subtle semantics and dark corners since I actually needed to implement it correctly. Writing a compiler is also doubly efficient to begin with, since if you self-compile improvements not only give you a better opti
09:08:22 <ski>   "All in all I figure I was making very good use of my time. For some reason, when I explain my reasoning to other people they look at me like I am crazy, but I can detect no flaw in my logic." -- John Meacham, on the JHC Haskell compiler, at <http://repetae.net/computer/jhc/jhc.shtml>
09:08:25 <zezikaro> as in, you can clearly see what the parent is
09:08:27 <ski> zezikaro ^
09:08:53 <mekeor> oO
09:09:23 <tulinius> just do some recursive magic and calculate the size of each sub-tree, and use it for something sensible >:)
09:09:40 <zezikaro> funny, everyone seems to make lisp intepreters in lisp
09:09:45 <zezikaro> and haskell intepreters in haskell too?
09:09:46 <navaati> zezikaro: there also is a pretty-printing library that you can use
09:10:20 <dmwit> zezikaro: Do you know TeX?
09:10:33 <dmwit> Implementing the TeX box model for text output to the console is a fun afternoon hack.
09:10:36 <zezikaro> is that just a version of LaTeX ?
09:10:50 <dmwit> Um, no, but knowing LaTeX is sufficient.
09:10:57 <mekeor> TeX is the father of LaTeX.
09:10:57 <zezikaro> i don't know either, i just wondered :(
09:10:58 <bscarlet> zezikaro: I'd start by deciding if you want something like a TreeView or something like GraphViz would do.
09:11:00 <dmwit> (LaTeX is a collection of libraries built on TeX.)
09:11:28 <navaati> dmwit: "fun afternoon hack" ? omg… sound terrible
09:11:30 <zezikaro> bscarlet tree view is
09:11:30 <ski> zezikaro : the original Mercury implementation was written in Mercury
09:11:31 <zezikaro> Parent
09:11:33 <zezikaro> -> child
09:11:36 <zezikaro> -> child
09:11:37 <zezikaro> right?
09:11:48 <bscarlet> zezikaro (you can google image search treeview and "graphviz tree") to see either.
09:11:49 <dmwit> navaati: Not at all. The horrible bits of TeX are in its parser, not its conceptual bits.
09:12:01 <dmwit> The conceptual bits were done by Knuth, after all!
09:12:04 <zezikaro> I'll do that first; I was hoping to do something more visual (but text based) graphviz
09:12:11 <navaati> (the parser too, i guess)
09:12:22 <dmwit> (that's the joke =)
09:13:53 <dmwit> Anyway, I wouldn't propose trying to clone TeX. I was just suggesting stealing its ideas and having a lark.
09:14:25 <tulinius> Writing documents in Haskell does sound more nice than writing them with LaTeX.
09:16:02 <navaati> yup. does that exist btw ?
09:17:00 <navaati> dmwit: actually what is horrible is that the resolution of Tex is something very small (2^16th of a pt, iirc) whereas the resolution of the console is so big
09:17:44 <scopedTV> I'm confused. There is no Alternative instance for binary's Get monad?
09:18:00 <zezikaro> I'll do the trees thank you
09:18:12 <scopedTV> How then, am I supposed to detect "parse failure"? Is this at all possible?
09:18:46 <otters> > mappend ("gr" ++) reverse "ot"
09:18:48 <lambdabot>   "grotto"
09:18:55 <scopedTV> (My data format is such that I can probably use some kind of peek/lookup; but it's ugly.)
09:19:39 <navaati> otters: oO… i just can't understand your code
09:19:54 <otters> navaati: I'm trying to understand myself
09:20:00 <otters> > mappend reverse ("gr" ++) "ot"
09:20:02 <lambdabot>   "togrot"
09:20:09 <otters> @src (->) mappend
09:20:09 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
09:20:14 <otters> son of a gun
09:20:15 <strager> scopedTV: You may want attoparsec in that case
09:20:26 <strager> Or you can use manual lookaheads
09:20:42 <scopedTV> strager: I'm now looking at cereal. Is there a good reason not to have Alternative? Effiency?
09:20:44 <strager> Or split the stream
09:20:50 <strager> I don't know.
09:20:55 <otters> oh
09:20:59 <otters> it's f x `mappend` g x
09:21:10 <otters> so reverse "ot" ++ ("gr" ++) "ot"
09:21:26 <strager> There's likely overhead of backtracking, both conceptually and performance-wise
09:21:32 <scopedTV> attoparsec is another option of course, but I also like serialization at the same time.
09:21:56 <navaati> :t on
09:21:57 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
09:22:10 <scopedTV> not only deserialization / parsing
09:22:39 <scopedTV> I could, of course, still use Binary for that. I'll try with cereal.
09:23:12 <otters> why you'd want to do this is a mystery
09:23:27 <kcsrk> Does Haskell have parametric modules? I am looking for something similar to Standard ML functors..
09:23:57 <strager> kcsrk: Nope.  =[
09:24:59 <monochrom> associated type/data families come close
09:25:55 <monochrom> in some cases you can also s/module/record/ and then you get first-class parameterized... records!
09:26:20 <monochrom> in fact, parsec has an example...
09:26:57 <kcsrk> monochrom: let me check parsec example.. thanks
09:31:12 <uniquenick> how can I group a list into a list of lists by length rather than comparing elements?  Like turn a list of 50 things in to a list of 5 lists of 10 things?
09:32:15 <monochrom> iirc...
09:32:35 <tromp_> see Data.List.Split
09:32:38 <monochrom> > group [5,5,5, 9, 4,4,]
09:32:39 <lambdabot>   <no location info>: parse error on input `]'
09:32:45 <monochrom> > group [5,5,5, 9, 4,4]
09:32:46 <lambdabot>   [[5,5,5],[9],[4,4]]
09:33:05 <monochrom> oh nevermind, misread
09:33:05 <tromp_> > splitEvery 3 ['a'..'z']
09:33:06 <lambdabot>   Not in scope: `splitEvery'
09:33:21 <tromp_> > Data.List.Split.splitEvery 3 ['a'..'z']
09:33:21 <lambdabot>   Not in scope: `Data.List.Split.splitEvery'
09:34:35 <tromp_> @hoogle splitEvery
09:34:35 <lambdabot> No results found
09:36:30 <shachaf> > (\n -> map (map snd) . groupBy ((==) `on` fst) . zip (cycle (replicate n False ++ replicate n True))) 3 ['a'..'z']
09:36:32 <lambdabot>   ["abc","def","ghi","jkl","mno","pqr","stu","vwx","yz"]
09:37:30 <strager> let f _ [] = [] ; f i xs = (let (as, bs) = splitAt i xs in as : f i bs) in f 2 ['a'..'z']
09:37:33 <strager> > let f _ [] = [] ; f i xs = (let (as, bs) = splitAt i xs in as : f i bs) in f 2 ['a'..'z']
09:37:34 <lambdabot>   ["ab","cd","ef","gh","ij","kl","mn","op","qr","st","uv","wx","yz"]
09:37:57 <strager> > let f _ [] = [] ; f i xs = (let (as, bs) = splitAt i xs in as : f i bs) in f 7 ['a'..'z']
09:37:58 <lambdabot>   ["abcdefg","hijklmn","opqrstu","vwxyz"]
09:38:57 <strager> shachaf: Interesting solution
09:40:07 <mm_freak> huh?
09:40:22 <mm_freak> > takeWhile (not . null) . map (take 3) . iterate (drop 3) $ ['a'..'z']
09:40:24 <lambdabot>   ["abc","def","ghi","jkl","mno","pqr","stu","vwx","yz"]
09:40:39 <mm_freak> @ strager, shachaf
09:40:51 <ski> > (\n -> unfoldr (\s -> guard (not (null s)) >> Just (splitAt 3 s))) 3 ['a'..'z']
09:40:52 <lambdabot>   ["abc","def","ghi","jkl","mno","pqr","stu","vwx","yz"]
09:41:20 <ski> > (\n -> unfoldr (\s -> guard (not (null s)) >> Just (splitAt n s))) 13 ['a'..'z']
09:41:22 <lambdabot>   ["abcdefghijklm","nopqrstuvwxyz"]
09:41:45 <ski> > map length ((\n -> unfoldr (\s -> guard (not (null s)) >> Just (splitAt n s))) 13 ['a'..'z'])
09:41:46 <lambdabot>   [13,13]
09:41:48 <shachaf> mm_freak: Yes, I know. My goal was to write a solution I haven't seen before. :-)
09:41:54 <mm_freak> i see
09:42:17 <mm_freak> i also like the unfoldr solution, but the iterate/map solution is easier to read
09:43:11 <mm_freak> > takeWhile (not . null) . unfoldr (splitAt 3) $ ['a'..'z']
09:43:12 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe ([a], [a1])'
09:43:12 <lambdabot>         against...
09:43:18 <mm_freak> > takeWhile (not . null) . unfoldr (Just . splitAt 3) $ ['a'..'z']
09:43:20 <lambdabot>   ["abc","def","ghi","jkl","mno","pqr","stu","vwx","yz"]
09:43:39 <ski> > (\n -> unfoldr (\s -> guard (not (null s)) >> Just (splitAt n s))) 0 ['a'..'z']
09:43:40 <lambdabot>   ["","","","","","","","","","","","","","","","","","","","","","","","",""...
09:45:35 <ski> exercise : write down suitable laws for this function
09:46:22 <ski> uniquenick : ^ mostly intended for you
09:46:57 <uniquenick> law1: just import Data.List.Split and use the one someone more experienced wrote
09:47:25 <ski> hehe
09:47:47 <ski> i was just thinking it would be good practice, thinking about what laws you really expect to hold here
09:47:57 <mm_freak> chunksOf : {X : Set} -> (l : Nat) -> Vec X n -> Vec (Vec X l) (div (n + l - 1) l)
09:48:00 <mm_freak> =P
09:48:16 <ski> mm_freak : except for possibly the last element ..
09:48:32 <mm_freak> ski: i considered that
09:49:12 <ski> you have `Vec (Vec X l) (...)' which claims each returned vector has the same size (`l')
09:49:34 <ski> of course, you could require `n' to be a multiple of `l'
09:49:36 <mm_freak> oh
09:49:39 <mm_freak> indeed
09:50:12 <ski> (also, `n' is unbound in the above)
09:50:28 <mm_freak> chunksOf : {X : Set}{n : Nat} -> (l : Nat) -> Vec X n -> Vec (n' : Nat, Vec X n') (div (n + l - 1) l)
09:50:31 <mm_freak> there =P
09:50:46 <ski> too weak for my taste :)
09:50:58 <mm_freak> i know, but i wouldn't know how to do it
09:51:01 <ski> all but the last vector should be required to have length `l'
09:51:21 <mm_freak> at least not in a single LOC
09:51:49 <ski> in fact, `Vec : (n : Nat) -> (Fin n -> Set) -> Set' could be useful
09:52:25 <ski> (so the type of each element can depend on its index)
09:53:21 <mm_freak> i just wanted to sound smart…  now you make me sound stupid =P
09:53:35 <Iceland_jack> Welcome to my world
09:53:36 <ski> eh, sorry about that :/
09:53:56 * ski was just attempting to point to exciting problems/extensions
09:54:18 <mm_freak> of course…  would be interesting to construct the type of that one
09:55:27 <mm_freak> i also doubt that the 'div' way would work, unless you use a builtin Nat type about which the compiler knows a lot OOTB
09:55:57 <strager> @pl m >>= \r -> case r of _ -> x
09:55:57 <lambdabot> (line 1, column 23):
09:55:58 <lambdabot> unexpected "_"
09:55:58 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
09:56:05 <strager> @pl m >>= \r -> case r of { _ -> x }
09:56:05 <lambdabot> (line 1, column 23):
09:56:05 <lambdabot> unexpected "{"
09:56:06 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
09:56:59 <k-zed> isn't that just \_ -> x ?
09:57:50 <mparodi_> @src head
09:57:50 <lambdabot> head (x:_) = x
09:57:50 <lambdabot> head []    = undefined
09:58:02 <strager> k-zed: Imagine I have more case conditions ;P
09:58:18 <mparodi_> > let f list sublist = head [n | n <- [1 .. length list], take (length sublist) (drop n list) == sublist] in f "abcd" "bc
09:58:19 <lambdabot>   <no location info>:
09:58:20 <lambdabot>      lexical error in string/character literal at end o...
09:58:20 <strager> That's a common pattern for me
09:58:20 <mparodi_> > let f list sublist = head [n | n <- [1 .. length list], take (length sublist) (drop n list) == sublist] in f "abcd" "bc"
09:58:22 <lambdabot>   1
09:58:28 <mparodi_> > let f list sublist = head [n | n <- [1 .. length list], take (length sublist) (drop n list) == sublist] in f (cycle "abcd") "bc"
09:58:33 <lambdabot>   mueval: ExitFailure 1
09:58:33 <lambdabot>  mueval: Prelude.undefined
09:58:39 <mparodi_> why? ^
09:58:56 <mauke> length list
09:58:58 <strager> Because head is evil
09:59:03 <mparodi_> head is evil?
09:59:13 <strager> and length list
09:59:23 <mparodi_> can you explain me more?
09:59:24 <strager> > length (cycle "abcd")
09:59:29 <lambdabot>   mueval: ExitFailure 1
09:59:29 <lambdabot>  mueval: Prelude.undefined
09:59:35 <mm_freak> > head []
09:59:36 <strager> You can't take the length of an infinite list
09:59:36 <lambdabot>   *Exception: Prelude.head: empty list
09:59:36 <mparodi_> ahm
09:59:49 <mparodi_> but I don't need to know the precise length
10:00:14 <strager> > zipWith snd (cycle "abcd") [1..]
10:00:14 <mparodi_> so it's better to use [1 ..] ?
10:00:15 <lambdabot>   Couldn't match expected type `(a, b -> c)'
10:00:15 <lambdabot>         against inferred type `G...
10:00:21 <mm_freak> mparodi_: length doesn't care if you need it…  it calculates it anyway, strictly
10:00:27 <mparodi_> > let f list sublist = head [n | n <- [1..], take (length sublist) (drop n list) == sublist] in f (cycle "abcd") "bc"
10:00:28 <lambdabot>   1
10:00:33 <mparodi_> > let f list sublist = head [n | n <- [1..], take (length sublist) (drop n list) == sublist] in f (cycle "abcd") "bcz"
10:00:37 <lambdabot>   mueval-core: Time limit exceeded
10:00:38 <mauke> > let f list sublist = head [n | n <- zipWith const [1 ..] list, take (length sublist) (drop n list) == sublist] in f (cycle "abcd") "bc"
10:00:39 <mparodi_> I can't use [1..]
10:00:39 <lambdabot>   1
10:01:09 <mparodi_> > let f list sublist = head [n | n <- [1..], take (length sublist) (drop n list) == sublist] in f "abcd" "bcz"
10:01:13 <lambdabot>   mueval-core: Time limit exceeded
10:01:16 <mparodi_> you see
10:01:19 <mm_freak> > let isLongList xs = length xs > 1000 in isLongList [1..]
10:01:23 <lambdabot>   mueval-core: Time limit exceeded
10:01:27 <kallisti> I would think lines would be somewhat intelligent about different line-ending formats.
10:01:27 <parcs`> mparodi_: look at mauke's solution
10:01:27 <armlesshobo> > "Butts"
10:01:28 <lambdabot>   "Butts"
10:01:30 <kallisti> but it's not
10:01:42 * armlesshobo giggles
10:02:06 <mparodi_> > let f list sublist = head [n | n <- zipWith const [1 ..] list, take (length sublist) (drop n list) == sublist] in f (cycle "abcd") "bcz"
10:02:10 <lambdabot>   mueval-core: Time limit exceeded
10:02:15 <mparodi_> > let f list sublist = head [n | n <- zipWith const [1 ..] list, take (length sublist) (drop n list) == sublist] in f "abcd" "bcz"
10:02:16 <lambdabot>   *Exception: Prelude.head: empty list
10:02:25 <mm_freak> > let isLongList = not . null . take 1000 in isLongList [1..]
10:02:26 <mparodi_> mauke's solution doesn't work well
10:02:26 <lambdabot>   True
10:02:30 <mm_freak> > let isLongList = not . null . take 1000 in isLongList [1..100]
10:02:32 <lambdabot>   True
10:03:00 <mm_freak> uh
10:03:05 <mm_freak> > let isLongList = not . null . drop 1000 in isLongList [1..]
10:03:07 <lambdabot>   True
10:03:09 <mm_freak> > let isLongList = not . null . drop 1000 in isLongList [1..100]
10:03:11 <lambdabot>   False
10:03:59 <mparodi_> <parcs`> mparodi_: look at mauke's solution <- <mparodi_> mauke's solution doesn't work well
10:04:08 <mparodi_> > let f list sublist = head [n | n <- zipWith const [1 ..] list, take (length sublist) (drop n list) == sublist] in f "abcd" "bcz"
10:04:09 <lambdabot>   *Exception: Prelude.head: empty list
10:04:45 <mparodi_> ah, ok. I can return Maybe
10:04:47 <mparodi_> never mind
10:04:58 <parcs`> use listToMaybe instead of head
10:05:17 <mparodi_> @type listToMaybe
10:05:19 <lambdabot> forall a. [a] -> Maybe a
10:05:21 <mparodi_> @src listToMaybe
10:05:22 <lambdabot> listToMaybe []        =  Nothing
10:05:22 <lambdabot> listToMaybe (a:_)     =  Just a
10:05:23 <parcs`> and mauke's solution fixes the strict-length thing but you still can't use that function over an infinite list
10:05:44 <mparodi_> > let f list sublist = head [n | n <- zipWith const [1 ..] list, take (length sublist) (drop n list) == sublist] in f (cycle "abcd") "bc"
10:05:46 <lambdabot>   1
10:05:47 <mparodi_> I can
10:06:16 <mparodi_> it's not possible is the string is not on the list (and that makes sense)
10:06:25 <parcs`> yeah, i should've clarified
10:06:39 <mparodi_> @const
10:06:40 <lambdabot> Unknown command, try @list
10:06:41 <mparodi_> @src const
10:06:42 <lambdabot> const x _ = x
10:07:55 <Paprikachu> re :o
10:08:07 <kallisti> > lines "it's not\r\nsmart about\r\nlines"
10:08:08 <lambdabot>   ["it's not\r","smart about\r","lines"]
10:08:35 <kkyqqp> what's the best way to apply a list of functions to a list of values? that is, apply the list of functions say,  [(*) 10,(+) 1] to [1,2]
10:08:35 <kallisti> the lack of Windows support in Haskell is hilarious.
10:08:50 <kallisti> kkyqqp: depends on what you want to happen
10:08:56 <Paprikachu> windows sucks :P
10:09:03 <kallisti> do you want to apply each function to each element?
10:09:09 <kallisti> or pair elements with functions?
10:09:19 <mparodi_> @index listToMaybe
10:09:20 <lambdabot> Data.Maybe
10:09:21 <kallisti> > zipWith ($) [(*) 10, (+) 1] [1,2]
10:09:22 <lambdabot>   [10,3]
10:09:28 <kkyqqp> well, I actually want the first one in a way, but I was planning on using the second and List.permutations
10:09:36 <kallisti> > [(*) 10, (+) 1] <*> [1,2]
10:09:37 <lambdabot>   [10,20,2,3]
10:09:39 <kallisti> like this?
10:09:40 <mparodi_> there are so many functions to do whatever you want lol
10:09:47 <kkyqqp> exactly like that, thanks!
10:10:01 <kallisti> that's an operator in Control.Applicative.
10:11:28 <mparodi_> by the way, when I was trying with the length version of the solution I couldn't interrupt the process and I had to kill it many times, is it normal?
10:11:57 <applicative> > > [f x | f <- [(*) 10, (+) 1] | x <- [1,2]]
10:11:58 <lambdabot>   <no location info>: parse error on input `>'
10:12:07 <applicative> > [f x | f <- [(*) 10, (+) 1] | x <- [1,2]]
10:12:07 <lambdabot>   [10,3]
10:12:13 <applicative> > [f x | f <- [(*) 10, (+) 1] , x <- [1,2]]
10:12:14 <lambdabot>   [10,20,2,3]
10:12:17 <ski> kallisti : arguably it oughtn't be "smart" about that
10:12:20 <zezikaro> what type is *
10:12:20 <zezikaro> ?
10:12:23 <kallisti> Paprikachu: the fact that you prefer one system over another isn't reason to completely bias programming language libraries so that they're only functional on that system.
10:12:46 <applicative> zezikaro: its not a type
10:12:55 <kallisti> ski: I'd love to hear a compelling reason why this is the case.
10:12:55 <parcs`> mparodi_: yeah ghc was too busy allocating like mad to handle your interrupty
10:12:55 <ski> (i'm also not sure i like `lines' accepting a (non-empty) string not ending with `\n')
10:12:59 <applicative> or, its the type of ordinary types
10:13:04 <zezikaro> uh
10:13:16 <ski> kallisti : hides bugs/incompatibilities, instead of encouraging people to fix them
10:13:19 <applicative> so its called a kind
10:13:20 <Paprikachu> hey ski, we have to discuss something :D
10:13:32 <applicative> is the kind query in here
10:13:40 <applicative> @kind Maybe
10:13:41 <lambdabot> * -> *
10:13:42 <mparodi_> > length [1.. length [1.. length [1..]]]
10:13:45 <kallisti> ski: in my case the only bug is that lines doesn't handle \r\n "properly"  :P
10:13:46 <lambdabot>   mueval-core: Time limit exceeded
10:13:48 <mparodi_> parcs`, I can interrupt that ^
10:14:01 <applicative> yeah, Maybe takes a type like Int and returns a type, here Maybe Int
10:14:14 <ski> kallisti : we already have the concept of binary vs. textual file to read `\r\n' from a text file on windows into a single `\n' character
10:14:15 <applicative> @kind Either
10:14:15 <lambdabot> * -> * -> *
10:14:35 <applicative> zezikaro: Either makes a type from two types so thats its kind ^^^
10:14:38 <ski> kallisti : so, arguably having `\r\n' inside a Haskell string would normally be a bug
10:14:45 <untitled> how would I write in haskell this code in C: for(i=0; i<10; i++) myFunction(i); ?
10:14:51 <kallisti> ski: this behavior only occurs on linux systems?
10:14:59 <ski> kallisti : which behaviour ?
10:15:01 <kallisti> er
10:15:01 <kallisti> windows
10:15:02 <mparodi_> > length $ cycle "abc"
10:15:07 <lambdabot>   mueval: ExitFailure 1
10:15:08 <lambdabot>  mueval: Prelude.undefined
10:15:10 <mparodi_> I can't interrupt this one ^
10:15:14 <kallisti> ski: say I read a file with \r\n in linux.
10:15:17 <kallisti> which is the current case.
10:15:20 <zezikaro> untitled what does myFunction return?
10:15:22 <mparodi_> isn't it almost the same as length [1..]?
10:15:23 <kallisti> then the \r\n will remain, right?
10:15:31 <Ralith> untitled: does myFunction have side effects?
10:15:32 <parcs`> mparodi_: sometimes you can, sometimes you can't. it depends on when you interrupt and what was happening behind the scenes at the time
10:15:43 <untitled> zezikaro: does it matter?
10:15:46 <untitled> Ralith: not really
10:15:53 <Ralith> untitled: "not really?"
10:15:54 <ski> kallisti : yes, and then you ought to run some kind of `msToUnixLineEnding :: String -> String' conversion
10:15:54 <kallisti> yes. but it almost certainly has side-effects, considering how it's used.
10:15:59 <zezikaro> i'd say so
10:16:01 <mparodi_> no, it's *impossible* to interrupt "length $ cycle "abc"", try it yourself
10:16:04 <kallisti> forM_ [1..9] myFunction
10:16:14 <zezikaro> 0..9
10:16:19 <kallisti> ski: or lines
10:16:20 <mparodi_> on the other hand you can always interrupt "length [1..]"
10:16:21 <kallisti> ideally
10:16:35 <untitled> kallisti: what about the argumernt?
10:16:47 <Ralith> untitled: it is provided.
10:16:57 <Paprikachu> > let times 1 f = f; times n = do f; times (n - 1) f in times 5 (print 42)
10:16:58 <lambdabot>   Equations for `times' have different numbers of arguments
10:16:58 <lambdabot>    <interactive>:...
10:17:09 <Paprikachu> > let times 1 f = f; times n f = do f; times (n - 1) f in times 5 (print 42)
10:17:11 <lambdabot>   <IO ()>
10:17:20 <ski> kallisti : except that that encourages people to gloss over the distinction, yielding confusion when they later use another function where they didn't think to do this "helping, DWIM" conversion
10:17:20 <kallisti> Paprikachu: the number is being passed to the function each call.
10:17:30 <zezikaro> dwim?
10:17:31 <Ralith> untitled: perhaps one of the wide variety of haskell tutorials would be of interest?
10:17:34 <shachaf> mparodi_: Probably the reason has to do with it having no allocations.
10:17:38 <ski> "Do What I Mean"
10:17:45 <Paprikachu> kallisti: ?
10:18:09 <kallisti> Paprikachu: er. disregard me. :P
10:18:14 <kallisti> I'm silly.
10:18:16 <applicative> kallisti: doesn't the standard string infrastructure do some of that?
10:18:24 <mparodi_> yeah, maybe, shachaf
10:18:25 <Paprikachu> what's wrong in my piece of code?
10:18:38 <ski> it is unfortunate that Windows and *nix systems decided not to be compatible with each other on this matter, but we want to isolate the damage, not making it spread more
10:18:43 <applicative> kallisti: I mean the \r\n \n nonsense
10:18:43 <kallisti> ski: then the title "lines" is misleading.
10:19:07 <kallisti> applicative: not that I'm aware of. not as part of the "string infrastructure", but the conversion is automatic on Windows when you read from files.
10:19:24 <applicative> the only thing i've seen cause a little chaos is the 'bom'
10:19:37 <Paprikachu> > let times 1 f = f; times n f = do f; times (n - 1) f in times 5 (print "foo")
10:19:39 <lambdabot>   <IO ()>
10:19:39 <strager> I love seeing the DOM in UTF-8-encoded text.
10:19:42 <Paprikachu> :(
10:19:48 <ski> kallisti : i think it was C which started converting `\r\n' to `\n', when reading from files opened in text mode, on windows -- so internal to the C program, we act according to the Unix convention
10:19:50 <Paprikachu> > let times 1 f = f; times n f = do f; times (n - 1) f in times 5 (putStr "foo")
10:19:52 <lambdabot>   <IO ()>
10:19:55 <ski> kallisti : then Haskell borrowed this from C
10:20:23 <Paprikachu> why does it print this shit?
10:20:23 <ski> kallisti : but i'm not sure what you mean by "lines" being misleading ?
10:20:30 <hiptobecubic> strager, BOM?
10:20:35 <strager> byte order marker
10:20:38 <strager> Unicode
10:20:56 <untitled> what about for(i=0; i<10; i++) str = "this is time " ++ i; myFunction(str); ?
10:20:58 <hiptobecubic> strager, yes. You said 'dom'. I wasn't sure if it was something new.
10:21:44 <strager> Oh, my bad =]
10:21:49 <Paprikachu> ski: ?
10:21:54 <kallisti> ski: basically I think there's a pretty common practice of DWIM with regard to functions that are completely specialized towards line endings.
10:22:05 <kallisti> and that it shouldn't really be unexpected..
10:22:19 <Paprikachu> why doesn't it work :(
10:22:22 <mauke> forM_ [0 .. 9] $ \i -> myFunction ("this is time " ++ show i)
10:22:32 <strager> untitled: forM_ [0..9] $ \i -> myFunction ("this is time " ++ show i)
10:22:40 <nand`> :t forM_
10:22:40 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
10:22:51 <parcs`> shachaf: ah, yeah
10:22:55 <Paprikachu> > let times 1 f = f; times n f = do f; times (n - 1) f in times 5 (show 42)
10:22:56 <lambdabot>   "42424242424242424242424242424242"
10:23:05 <Paprikachu> lol
10:23:17 <untitled> strager: thanks man
10:23:18 <Paprikachu> what
10:23:52 <mauke> Paprikachu: cool list comprehension
10:24:02 <strager> untitled: or: mapM_ myFunction $ map (\x -> "this is time " ++ show x) [0..9]; and now you can easily extract the right hand side out
10:24:15 <Paprikachu> mauke: what do you mean?
10:24:31 <Paprikachu> this is intended to print 42 5 times, not 16 times QQ
10:24:32 <mauke> Paprikachu: the 'do f; times (n - 1) f' part
10:24:51 <Paprikachu> ???
10:24:53 <mauke> > do [(), (), ()]; return 42
10:24:54 <lambdabot>   [42,42,42]
10:24:57 <hiptobecubic> ends up doing it moret han once
10:25:06 <mauke> you're doing things f times
10:25:07 <dylukes> @src fmap
10:25:07 <lambdabot> Source not found. stty: unknown mode: doofus
10:25:10 <dylukes> @src (.)
10:25:10 <lambdabot> (f . g) x = f (g x)
10:25:10 <lambdabot> NB: In lambdabot,  (.) = fmap
10:25:15 <dylukes> hehe
10:25:16 <Paprikachu> i don't get it.
10:25:21 <dylukes> :t fmap
10:25:22 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:25:23 <mauke> > [ 42 | [(), (), ()] ]
10:25:24 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
10:25:24 <lambdabot>         against inferred type ...
10:25:30 <mauke> > [ 42 | _ <- [(), (), ()] ]
10:25:31 <lambdabot>   [42,42,42]
10:25:39 <kallisti> untitled: any proper translation of C to Haskell is going to operate differently from the original C code. You could do a direct translation with mutable variables and the like but it would be highly unlikely that you would write similar logic in a real program.
10:25:41 <nand`> > 2 ^ (5-1)
10:25:42 <dylukes> How do you do that thing in lambdabot where you replace a type variable?
10:25:42 <lambdabot>   16
10:25:45 <Paprikachu> what does this have to do with my code
10:25:56 <mauke> Paprikachu: the 'do f; times (n - 1) f' part
10:26:04 <nand`> each ‘do .. ; ...’ in that code (aka >>) doubles the list size
10:26:10 <dylukes> untitled: kallisti: Sometimes using ST/STUArrays and IO is the best way to replicate an imperative algorithm, and get the performance you want.
10:26:22 <Paprikachu> whaaaaat.
10:26:28 <Paprikachu> so what does this code really do?
10:26:35 <untitled> kallisti: dylukes ok
10:26:43 <alpounet> Paprikachu, it's using the list monad
10:26:48 <mauke> Paprikachu: for each element in f: ignore it and collect times (n - 1) f instead
10:26:56 <Paprikachu> > let times 1 f = f; times n f = do { f; times (n - 1) f } in times 5 (show 42)
10:26:57 <lambdabot>   "42424242424242424242424242424242"
10:27:09 <Paprikachu> how can i correct that?
10:27:15 <mauke> Paprikachu: what's the intended result?
10:27:33 <Paprikachu> guess what "times 5 (show 42)" means ;)
10:27:39 <mauke> I have no idea
10:27:44 <mauke> that's why I'm asking
10:27:50 <hiptobecubic> repeat 5 "42" or something?
10:27:54 <mauke> hiptobecubic: replicate
10:27:57 <nand`> > replicate 5 (show 42)
10:27:57 <Paprikachu> times x = do something 5 times
10:27:57 <geekosaur> you are in the list monad.  do you intend to be?
10:27:57 <lambdabot>   ["42","42","42","42","42"]
10:28:00 <hiptobecubic> ah yes replicate
10:28:02 <Paprikachu> *x times
10:28:03 <mauke> Paprikachu: define "do"
10:28:14 <Paprikachu> call the function n times
10:28:16 <mparodi_> @src foldl
10:28:16 <mauke> Paprikachu: what does it mean to 'do' "42"?
10:28:16 <lambdabot> foldl f z []     = z
10:28:16 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
10:28:19 <mauke> Paprikachu: "42" is not a function
10:28:23 <hiptobecubic> @src replicate
10:28:23 <lambdabot> replicate n x = take n (repeat x)
10:28:32 <Paprikachu> that's why i passed show 42 to it...
10:28:37 <mauke> Paprikachu: show 42 is "42"
10:28:49 <mroman> @src repeat
10:28:49 <lambdabot> repeat x = xs where xs = x : xs
10:28:53 <Paprikachu> doens't show print a variable?
10:28:53 <mroman> @src cycle
10:28:54 <lambdabot> cycle [] = undefined
10:28:54 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
10:28:58 <nand`> Paprikachu: no
10:29:03 <mroman> :t cycle
10:29:04 <lambdabot> forall a. [a] -> [a]
10:29:05 <mauke> Paprikachu: no
10:29:06 <Paprikachu> and how can i do that?
10:29:07 <nand`> Paprikachu: you're thinking of ‘print’
10:29:09 <mroman> :t repeat
10:29:10 <lambdabot> forall a. a -> [a]
10:29:13 <mroman> ok.
10:29:14 <Paprikachu> but print prints shit
10:29:16 <hiptobecubic> Paprikachu, show is a string representation of some value
10:29:18 <nand`> :t replicateM 5 (print 42)
10:29:18 <lambdabot> IO [()]
10:29:26 <Paprikachu> > let times 1 f = f; times n f = do f; times (n - 1) f in times 5 (print 42)
10:29:27 <lambdabot>   <IO ()>
10:29:28 <geekosaur> @src print
10:29:28 <lambdabot> print x = putStrLn (show x)
10:29:29 <Paprikachu> ...
10:29:38 <tulinius> Paprikachu: Does it print the pile-of-poo unicode symbol, or what are you saying?
10:29:51 <Paprikachu> it gives me <IO ()>
10:29:55 <Paprikachu> not 4242424242
10:29:56 <mauke> Paprikachu: your base case is wrong, btw. it should be times 0
10:29:58 <nand`> lambdabot won't do IO
10:30:06 <mauke> Paprikachu: lambdabot still doesn't execute IO
10:30:08 <mparodi_> @src foldr
10:30:09 <lambdabot> foldr f z []     = z
10:30:09 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:30:10 <mauke> Paprikachu: and it never will
10:30:17 <tulinius> Paprikachu: you need to to execute the IO first then.
10:30:23 <Paprikachu> [19:27:25]	<mauke>	Paprikachu: your base case is wrong, btw. it should be times 0
10:30:27 <Paprikachu> what do you mean by that
10:30:39 <mauke> Paprikachu: your code doesn't work for times 0 (print 42)
10:30:43 <zezikaro> How do you pass in a function to a function, in which you don't care about its return
10:30:43 <Paprikachu> i know
10:30:49 <mauke> Paprikachu: it should
10:30:56 <nand`> hmm
10:31:02 <mauke> zezikaro: if you don't care about the value, why pass anything?
10:31:04 <mroman> zezikaro: Why would you not care about its return?
10:31:04 <Paprikachu> it's because i didn't know how to write a function that does nothing
10:31:09 <mauke> Paprikachu: ah
10:31:16 <mauke> Paprikachu: that would be 'return ()' in this case
10:31:16 <Paprikachu> maybe like
10:31:20 <Paprikachu> yeah
10:31:27 <mauke> @src replicateM_
10:31:27 <lambdabot> replicateM_ n x = sequence_ (replicate n x)
10:31:28 <nand`> I was thinking about the “do f; times ...” code Paprikachu showed earlier (the one with show 42) for a while and wondering why it *doubled* the list size per iteration; I just figured it out
10:31:28 <Paprikachu> thats what i wanted to say :=
10:31:30 <nand`> because 42 has two digits
10:31:32 <mroman> zezikaro: That's like saying: I'd like to calculate 5+5, but I don't care about the return value ;)
10:31:46 <nand`> so each element of “42” is getting replaced by “42” itself and then flattened (as per []'s monad instance)
10:31:53 <mauke> nand`: exactly
10:31:55 <Paprikachu> what the heck?
10:31:59 <zezikaro> http://ideone.com/hRQCs
10:32:11 <mauke> Paprikachu: your function already exists as replicateM_, btw
10:32:16 <zezikaro> no i want to traverse a tree in a specific order
10:32:17 <ski> kallisti : it may or may not be common practice, but i think it's not good practice
10:32:21 <zezikaro> but i don't care what logic is applied to the tree
10:32:28 <ski> kallisti : the same goes for `/' vs `\' in paths, btw
10:32:28 <Paprikachu> i know, just tried to implement it myself
10:32:39 <tulinius> zezikaro: i see you're reading LYAH :)
10:32:39 <mparodi_> foldr f z [x1, x2, x3] = f x1 (f xs (f x3 z))           foldl f z [x1, x2, x3] = ...?
10:32:40 <Paprikachu> but why is its name replicateM_ and not just replicateM?
10:32:46 <nand`> zezikaro: just traversing a tree won't do anything though
10:32:49 <mparodi_> s/xs/x2/
10:32:54 <mroman> zezikaro: If you want IO
10:32:56 <mauke> Paprikachu: because it doesn't collect the return values
10:32:58 <ski> (even though i agree it can be quite convenient -- i just happend to think it's a bad kind of convenience)
10:32:58 <mroman> then IO () is fine
10:33:02 <mroman> :t print
10:33:03 <lambdabot> forall a. (Show a) => a -> IO ()
10:33:06 <zezikaro> i want it to be generic
10:33:14 <mroman> so your function has to be something like (a -> IO ())
10:33:14 <Paprikachu> ?
10:33:19 <applicative> http://hpaste.codepad.org/1OCs4xhG  Paprikachu <<<
10:33:38 <nand`> zezikaro: maybe you want something like Tree a -> [a]
10:33:43 <mauke> Paprikachu: the naming convention is that functions of the form foo_ have no useful return value
10:33:44 <Paprikachu> ok
10:33:46 <nand`> (which can then be combined with stuff like sequence_)
10:33:46 * mauke handwaves
10:33:49 <mroman> Which would make your inOrderTraversal
10:33:53 <applicative> nothing wrong with inventing replicateM_ again.  'times' is a nice name
10:34:03 <mroman> (Ord a, Show a) => (a -> IO ()) -> Tree -> IO ()
10:34:06 <nand`> @hoogle times
10:34:06 <lambdabot> Graphics.UI.GLUT.Fonts TimesRoman10 :: BitmapFont
10:34:06 <lambdabot> Graphics.UI.GLUT.Fonts TimesRoman24 :: BitmapFont
10:34:06 <lambdabot> Network.Browser browserTimestamp :: BrowserEvent -> ClockTime
10:34:06 <zezikaro> mroman but that wouldn't work for an infinite tree?
10:34:13 <strager> zezikaro: Why don't you have the function return a lazy list?
10:34:22 <Paprikachu> thanks for the explanations
10:34:24 <nand`> > let times = replicate in 5 `times` show 42
10:34:25 <lambdabot>   ["42","42","42","42","42"]
10:34:28 <nand`> has a nice ring to it
10:34:32 <zezikaro> strager because i don't know what that is :(
10:34:37 <applicative> Paprikachu: you should call it times_ though
10:34:43 <mroman> zezikaro: Traversing an infinite tree?
10:34:56 <Paprikachu> because it has no useful returnvalue, i now i know that :)
10:35:00 <Paprikachu> -i
10:35:08 <mparodi_> I'm confused with foldl, can anyone tell me what would the result of "foldl f z [x1, x2, x3]" (for example, with foldr it would be (f x1 (f xs (f x3 z))")?
10:35:14 <strager> zezikaro: Just return a list
10:35:19 <mauke> > foldl f z [x, y, z]
10:35:20 <lambdabot>   f (f (f z x) y) z
10:35:26 <mauke> > foldr f z [x, y, z]
10:35:27 <lambdabot>   f x (f y (f z z))
10:35:34 <nand`> I think Paprikachu's function should be called timesM_
10:35:35 <strager> inOrderTraversal left ++ [x] ++ inOrderTraversal right
10:35:48 <mauke> > foldl f z [a, b, c]
10:35:49 <lambdabot>   f (f (f z a) b) c
10:35:52 <mroman> zezikaro: http://codepad.org/LXGWir9I
10:35:52 <mauke> better
10:35:53 <Paprikachu> why M? because it has something to do with monads?
10:35:56 <mparodi_> what!? I didn't know lambdabot was able to do that :)
10:35:57 <mauke> Paprikachu: yes
10:35:59 <mroman> You probably are looking for that ;)
10:35:59 <mparodi_> thank you mauke
10:36:06 <Paprikachu> i don't know monads for now
10:36:17 <mauke> > deriv sin x
10:36:18 <lambdabot>   1 * cos x
10:36:21 <nand`> then don't write timesM_ :P
10:36:23 <kallisti> Paprikachu: it's not even a special feature of lambdabot. it's just the SimpleReflect module.
10:36:26 <mauke> > deriv (sin + 2 * cos) x
10:36:27 <ski> strager : or using an accumulator (or `Endo') :)
10:36:27 <lambdabot>   1 * cos x + 2 * (1 * negate (sin x))
10:36:42 <mroman> Although the output does not look correct :)
10:36:45 <mroman> For a binary search tree
10:36:53 <morphles> One has to have fields of all records named differently since haskell automaticaly generates accessors for them, is there a way around such limitation so that for example accesors would get prefix of the type, and you could have fields with same name?
10:37:00 <Paprikachu> what's deriv?
10:37:08 <strager> derivative
10:37:19 <Paprikachu> what's that? :|
10:37:20 <ski> Paprikachu : `replicateM' is "like" `replicate", only it allows to perform some "effects", while it is generating the list
10:37:24 <strager> Calculus stuff.
10:37:24 <mauke> Paprikachu: Ableitung
10:37:33 <Paprikachu> :O
10:37:38 <nand`> :t sin
10:37:39 <lambdabot> forall a. (Floating a) => a -> a
10:37:39 <Paprikachu> oh that
10:37:39 <ski> Paprikachu : and then `replicateM_' just ignores generating the list completely, only doing the effects
10:37:44 <nand`> :t deriv
10:37:45 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
10:37:47 <Paprikachu> how do you know i speak german
10:37:48 <nand`> ooh
10:38:00 <mauke> Paprikachu: you once typo'd '?' as 'ß'
10:38:02 <mroman> zezikaro: I don't think you insert the numbers correctly.
10:38:04 <ski> Paprikachu : there's also a `filterM' version of `filter', &c.
10:38:06 <Paprikachu> lol :D
10:38:34 <mauke> hmm, I should've said I'm Sherlock Holmes
10:38:40 <Paprikachu> mauke is a clever person
10:38:43 <Paprikachu> ^^
10:38:49 <mauke> elementary, my dear Paprikachu
10:38:59 <ski> (`wireless.dyn.drei.com' also gives a (weak) clue)
10:39:18 <Paprikachu> hehe
10:39:29 <zezikaro> mroman fixed thank you
10:39:35 <nand`> > deriv cos x
10:39:36 <lambdabot>   1 * negate (sin x)
10:39:39 <Paprikachu> i should really learn monads
10:39:57 <nand`> funny; when I try this in GHCi (after importing SimpleReflect) and friends I get “1 * negate a”
10:40:00 <Paprikachu> > deriv exp
10:40:01 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
10:40:01 <lambdabot>    arising from a use of `...
10:40:22 <applicative> Paprikachu: just learn fmap first
10:40:39 <mauke> > deriv exp 1
10:40:40 <Paprikachu> a monad version of map?
10:40:41 <lambdabot>   2.718281828459045
10:40:42 <mauke> > deriv exp 2
10:40:44 <lambdabot>   7.38905609893065
10:40:46 <nand`> Paprikachu: functor
10:40:48 <mauke> works
10:40:52 <applicative> cheater has decided to return a value ^^
10:40:58 <nand`> Paprikachu: map = fmap; but restricted to lists :P
10:41:04 <applicative> @type fmap
10:41:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:41:07 <cheater> have i
10:41:07 <ski> Paprikachu : "What the hell are Monads?" by Noel Winstanley in 1999 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html> is a somewhat old, but short, and i think, nice first exposure to monads
10:41:11 <Paprikachu> so what does fmap do?
10:41:17 <kallisti> > fmap (+1) (Just 1)  -- other things can be mapped over besides lists
10:41:17 <applicative> > fmap even [1]
10:41:17 <lambdabot>   Just 2
10:41:18 <lambdabot>   [False]
10:41:19 <zezikaro> <strager> zezikaro: Just return a list
10:41:20 <cheater> what type is it, applicative?
10:41:23 <ski> > deriv exp x
10:41:24 <lambdabot>   1 * exp x
10:41:27 <zezikaro> that would require two traversals to do one application of a function
10:41:29 <mauke> Paprikachu: applies a function to all elements
10:41:32 <applicative> > fmap even (Left "error")
10:41:32 <lambdabot>   Left "error"
10:41:38 <zezikaro> <mroman> zezikaro: http://codepad.org/LXGWir9I
10:41:38 <ski> > deriv (\x -> exp (2 * x))  x
10:41:39 <lambdabot>   2 * 1 * exp (2 * x)
10:41:41 <zezikaro> that's not "generic"
10:41:43 <applicative> > fmap even (Right 1)
10:41:43 <lambdabot>   Right False
10:41:47 <ski> > deriv (\x -> exp (cos * x))  x
10:41:48 <zezikaro> that means i can only apply functions that return io ()
10:41:48 <lambdabot>   Couldn't match expected type `a -> a'
10:41:49 <lambdabot>         against inferred type `Data.N...
10:41:49 <nand`> Paprikachu: applies a function to all elements, while “preserving the structure” so that fmap id = id
10:41:50 <ski> > deriv (\x -> exp (cos x))  x
10:41:51 <lambdabot>   1 * negate (sin x) * exp (cos x)
10:41:52 <cheater> @type even
10:41:53 <lambdabot> forall a. (Integral a) => a -> Bool
10:41:54 <zezikaro> i just wanted to apply any function
10:41:59 <Paprikachu> > fmap odd [1,2,3]
10:42:01 <lambdabot>   [True,False,True]
10:42:04 <applicative> > fmap even ("hello world", 1)
10:42:05 <lambdabot>   ("hello world",False)
10:42:05 <mroman> zezikaro: Well.
10:42:06 <cheater> @type (fmap even)
10:42:07 <lambdabot> forall a (f :: * -> *). (Integral a, Functor f) => f a -> f Bool
10:42:11 <Paprikachu> > map odd [1,2,3]
10:42:13 <lambdabot>   [True,False,True]
10:42:17 <cheater> what's fmap even?
10:42:18 <mroman> You could make (Monad m) -> m ()
10:42:20 <ski> Paprikachu : no, `mapM' is the monad version of `map'
10:42:24 <zezikaro> mroman I could use 'b' couldn't I?
10:42:37 <Paprikachu> and mapM_ is the monad version that returns nothing useful?
10:42:37 <applicative> @type even
10:42:38 <nand`> mapM = sequence .: map
10:42:38 <lambdabot> forall a. (Integral a) => a -> Bool
10:42:39 <Paprikachu> :P
10:42:40 <zezikaro> inOrderTraversal :: (Ord a, Show a) => (a -> b) -> Tree a -> b
10:42:44 <ski> Paprikachu : `fmap' is a generalization of `map' to work over arbitrary "collections", instead of just over lists
10:42:44 <mauke> Paprikachu: yes
10:42:51 <ski> Paprikachu : yep
10:42:51 <nand`> mapM_ = sequence_ .: map
10:42:53 <applicative> cheater: even takes an integral thing to a truth value
10:42:58 <mroman> zezikaro: You cant just use "any" function. You have to satisfy the typ checker.
10:43:01 <strager> zezikaro: Yes, but it's lazy
10:43:09 <mroman> and functions like print are in the IO monad.
10:43:14 <cheater> applicative: what's an "integral thing"?
10:43:19 <ski> Paprikachu : `forM' and `forM_' are aliases of `mapM' and `mapM_', with the argument order conveniently flipped
10:43:19 <mroman> which means, that print has no type (a -> b)
10:43:20 <zezikaro> strager lazy how so
10:43:20 <applicative> cheater: so fmap even goes inside a structure of integery things, and makes a stucture of truth values instead
10:43:32 <applicative> cheater Int Integer
10:43:42 <applicative> @instances Integral
10:43:42 <lambdabot> Int, Integer
10:43:48 <strager> zezikaro: Because you can get the first element in the list (i.e. the leftmost element in the tree) without generating the entire list
10:43:57 <applicative> thats all in the prelude I guess cheater ^^^
10:44:11 <ski> Paprikachu : this means you can write `do ...; forM_ myList $ \element -> do ..something with element..', where the `..something with element..' is normally indented more than the rest of the code
10:44:43 <ski> Paprikachu : so, this is more or less the common way to do "for"-loops in Haskell
10:44:54 <ski> (in case there isn't a better way to rewrite it)
10:44:54 <nand`> forM = flip mapM ?
10:44:57 <ski> yes
10:44:59 <strager> Yes nand`
10:45:03 <mauke> @src forM
10:45:04 <lambdabot> forM = flip mapM
10:45:04 <ski> @src forM
10:45:05 <applicative> so a list of ints is a 'structure' or container, so if I fmap even into it, I get list of the same length with the answer to the question 'even?' in it
10:45:05 <lambdabot> forM = flip mapM
10:45:18 <applicative> > fmap even [1..10]
10:45:19 <lambdabot>   [False,True,False,True,False,True,False,True,False,True]
10:45:29 <applicative> > fmap even (Just 1)
10:45:30 <lambdabot>   Just False
10:45:33 <ski> > map even [1..10]
10:45:34 <lambdabot>   [False,True,False,True,False,True,False,True,False,True]
10:45:40 <cheater> > fmap even ["hello world"]
10:45:41 <lambdabot>   No instance for (GHC.Real.Integral [GHC.Types.Char])
10:45:42 <lambdabot>    arising from a use ...
10:45:48 <Paprikachu> > flip \(a, b) -> a - b $ 3 5
10:45:49 <lambdabot>   <no location info>: parse error on input `\'
10:45:50 <cheater> > fmap even ("hello world", 2)
10:45:51 <lambdabot>   ("hello world",True)
10:46:04 <cheater> why does it do that?
10:46:05 <applicative> a Maybe Int is a 'structure' containing an Int , unliess its Nothing
10:46:10 <nand`> > sequence [[1,2], [3,4]]
10:46:11 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
10:46:12 <`Jake`> fmap even (2,2,2)
10:46:13 <ski> > fmap even (Node 0 [Node 1 [],Node 2 [Node 3 []]])
10:46:14 <lambdabot>   Node {rootLabel = True, subForest = [Node {rootLabel = False, subForest = [...
10:46:15 <`Jake`> > fmap even (2,2,2)
10:46:16 <lambdabot>   No instance for (GHC.Base.Functor ((,,) t t1))
10:46:17 <lambdabot>    arising from a use of `e_...
10:46:17 <kallisti> cheater: because that's the Functor instance for (,) a
10:46:18 <Paprikachu> > (flip \(a, b) -> a - b) 3 5
10:46:20 <lambdabot>   <no location info>: parse error on input `\'
10:46:28 <Paprikachu> > (flip $ \(a, b) -> a - b) 3 5
10:46:29 <applicative> a (String,Int) is a structure containing an Int
10:46:30 <lambdabot>   0
10:46:34 <Paprikachu> what.
10:46:35 <ski> cheater : because `instance Functor (a,)'
10:46:35 <cheater> kallisti: not sure i am following
10:46:44 <kallisti> @instances Functor
10:46:45 <lambdabot> ((,) a), ((->) r), ContT r m, Either a, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
10:46:45 <applicative> cheater, to use this jargon of 'structure', which goes a little thin at points
10:46:46 <mauke> Paprikachu: hahahaha
10:46:58 <mauke> Paprikachu: sorry, you're running into some interesting Num instances defined by lambdabot
10:47:02 <ski> > (flip $ \a b -> a - b) 3 5
10:47:04 <lambdabot>   2
10:47:06 <ski> Paprikachu ^
10:47:13 <mauke> > subtract 3 5
10:47:14 <lambdabot>   2
10:47:17 <Paprikachu> :(
10:47:25 <ski> > map (subtract 3) [0 .. 9]
10:47:27 <lambdabot>   [-3,-2,-1,0,1,2,3,4,5,6]
10:47:38 <Paprikachu> > map (-3) [0..9]
10:47:39 <lambdabot>   [-3,-3,-3,-3,-3,-3,-3,-3,-3,-3]
10:47:44 <Paprikachu> what.
10:47:51 <kallisti> Paprikachu: -3 is "negative 3"  not "subtract 3"
10:48:03 <Paprikachu> > map ((-)3) [0..9]
10:48:04 <lambdabot>   [3,2,1,0,-1,-2,-3,-4,-5,-6]
10:48:07 <nand`> Caleskell strikes again
10:48:12 <ski> Paprikachu : in lambdabot, there's a generalization of `flip', which can be interesting, but in your case made your code type-check (and return a confusing answer) instead of stopping with a type error
10:48:15 <applicative> cheater of the ones in scope here, the r -> Int one is the wierdest , if you think of it as a Map from rs to Ints you can think how you 'go into the structure' and map even over it
10:48:16 <nand`> (-)3 is (3-)
10:48:24 <nand`> > map (+(-3)) [0..9]
10:48:25 <lambdabot>   [-3,-2,-1,0,1,2,3,4,5,6]
10:48:32 <applicative> @type fmap even length
10:48:33 <lambdabot> forall a. [a] -> Bool
10:48:34 <Paprikachu> what the heck
10:48:34 <mauke> > P.flip
10:48:35 <lambdabot>   Overlapping instances for GHC.Show.Show
10:48:36 <lambdabot>                              ((a ->...
10:48:38 <ski> > let flip = Prelude.flip in  (flip $ \(a, b) -> a - b) 3 5  -- Paprikachu, what you'd get without Caleskell
10:48:38 <Paprikachu> -.-
10:48:39 <lambdabot>   Not in scope: `Prelude.flip'
10:48:40 <kallisti> Paprikachu: it's not a standard Haskell feature.
10:48:42 <ski> er
10:48:46 <applicative> > fmap even length $ "hercules"
10:48:46 <ski> > let flip = P.flip in  (flip $ \(a, b) -> a - b) 3 5  -- Paprikachu, what you'd get without Caleskell
10:48:47 <lambdabot>   True
10:48:47 <lambdabot>   can't find file: L.hs
10:48:49 <`Jake`> > map (flip (-) 3) [0..9]
10:48:51 <lambdabot>   [-3,-2,-1,0,1,2,3,4,5,6]
10:48:55 <mauke> > (P.flip $ \(a, b) -> a - b) 3 5
10:48:56 <lambdabot>   0
10:49:02 <mauke> ski: this has nothing to do with flip
10:49:04 <kallisti> Paprikachu: integer literals in Haskell are overloaded on Num. so any instance of the Num can be used.
10:49:05 <mauke> it's all Num
10:49:06 <ski> oh
10:49:10 <Paprikachu> > map (*2) [1..9]
10:49:10 <ski> mauke : yeah, i just realized
10:49:12 <lambdabot>   [2,4,6,8,10,12,14,16,18]
10:49:24 <kallisti> Paprikachu: lambdabot has an instance defined for functions, so that the integer literal "3" represents the constant function f(x)=3  (const 3 in Haskell)
10:49:24 <ski> > 1 2 3  -- testing
10:49:25 <lambdabot>   1
10:49:34 <nand`> > map (*2) (Just 5)
10:49:35 <lambdabot>   Couldn't match expected type `[a]'
10:49:35 <lambdabot>         against inferred type `Data.Mayb...
10:49:40 <nand`> > fmap (*2) (Just 5)
10:49:41 <lambdabot>   Just 10
10:49:43 <nand`> > fmap (*2) Nothing
10:49:44 <lambdabot>   Nothing
10:49:48 <applicative> > fmap even ord $ 'a'
10:49:49 <lambdabot>   False
10:49:54 <applicative> > fmap even ord $ 'b'
10:49:54 <lambdabot>   True
10:50:02 <Paprikachu> haskell is such a crazy language
10:50:04 <kallisti> Paprikachu: you can also "add" functions together and subtract them and such, with this instance.
10:50:06 <mroman> zezikaro: At best you can get (Monad m, Show a) => Tree a -> (a -> m b) -> m ()
10:50:09 <`Jake`> > 4 + 5 2 + 2
10:50:10 <kallisti> > abs + negate $ 2
10:50:11 <lambdabot>   11
10:50:11 <lambdabot>   can't find file: L.hs
10:50:15 <mroman> If you really want to pass a function
10:50:22 <Paprikachu> > map (+2) [0..9]
10:50:23 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
10:50:24 <`Jake`> what.
10:50:25 <ski> @type flip `asTypeIn` \flip -> (flip $ \(a, b) -> a - b) 3 5
10:50:26 <mroman> or you may just collect the elements in a list like strager said.
10:50:26 <lambdabot> forall a b. (Num b, Num a) => ((a -> b, a -> b) -> a -> b) -> a -> (a -> b, a -> b) -> b
10:50:27 <untitled> strager: hey, this "forM_" expects some weird return type: "Couldn't match expected type `m0 b0' with actual type `Types'", my function returns Types =\
10:50:33 <`Jake`> > 4 + 5 2
10:50:34 <lambdabot>   9
10:50:40 <`Jake`> > 4 + 5 2 + 2
10:50:41 <nand`> `Jake`: (4 + 5 2 + 2) = 4 + (5 2) + 2 = 4 + 5 + 2
10:50:41 <lambdabot>   11
10:50:48 <Paprikachu> > map (-(2)) [0..9]
10:50:49 <strager> untitled: Code please?
10:50:49 <kallisti> Paprikachu: that's how foldr f z [a,b,c] works. the single-letter variables are elements of a type with a Num instance
10:50:49 <lambdabot>   [-2,-2,-2,-2,-2,-2,-2,-2,-2,-2]
10:50:55 <`Jake`> nand`: oh, ok
10:50:59 <kallisti> Paprikachu: the Num instance simply forms a string of the expression it represents
10:51:02 <kallisti> > x + 2
10:51:03 <lambdabot>   x + 2
10:51:08 <kallisti> > 2 + 2 :: Expr
10:51:09 <lambdabot>   2 + 2
10:51:28 <Paprikachu> > xx + 2
10:51:29 <lambdabot>   Not in scope: `xx'
10:51:33 <applicative> untitled: what is Types
10:51:38 <Paprikachu> hihi
10:51:44 <kallisti> Paprikachu: well actually I shouldn't say that's how foldr z [a,b,c] works because there's no Num magic going on there.
10:51:59 <mroman> zezikaro: http://codepad.org/6om2AcPc <- like that.
10:52:08 <nand`> :t f
10:52:09 <kallisti> Paprikachu: but, for example
10:52:09 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
10:52:12 <applicative> > let for = flip map in for [1,2,3] even
10:52:12 <kallisti> > sum [a,b,c]
10:52:14 <lambdabot>   can't find file: L.hs
10:52:14 <lambdabot>   [False,True,False]
10:52:21 <kallisti> > sum [a,b,c] :: Expr
10:52:21 <lambdabot>   0 + a + b + c
10:52:26 <applicative> > let for = flip map in for [1,2,3] show
10:52:27 <lambdabot>   ["1","2","3"]
10:52:42 <hpaste> untitled pasted “return value” at http://hpaste.org/69277
10:52:51 <untitled> applicative: my own datatype
10:52:58 <kallisti> Paprikachu: you can do a lot of confusing, magical things with typeclasses.
10:53:00 <untitled> strager: ^
10:53:17 <Paprikachu> i see ^^
10:53:29 <nand`> @src x
10:53:29 <lambdabot> Source not found. The more you drive -- the dumber you get.
10:53:30 <kallisti> especially with Num, because it has built-in syntax associated with it.
10:53:31 <strager> Can you show the source of printArray, or the full type?
10:53:33 <cheater> applicative: why is fmap even an identity for strings in [String, Int] but crap out on [String] ?
10:53:34 <strager> @ untitled
10:53:40 <ski>   (flip $ \(a, b) -> a - b) 3 5  =  flip (\(a, b) -> a - b)) 3 5  =  (\(a, b) -> a - b) 5 3  =  (\(a, b) -> a - b)) (fromInteger 5) 3  =  (\(a, b) -> a - b)) (5,5) 3  =  (5 - 5) 3  =  0 3  =  (fromInteger 0) 3  =  (\_ -> 0) 3  =  0
10:53:45 <ski> Paprikachu : that's it
10:53:46 <untitled> strager: why?
10:53:49 <nand`> cheater: [String, Int] <- what?
10:53:53 <kallisti> Paprikachu: in essence, the integer literal "3"  is more like  fromInteger (3 :: Integer)
10:53:57 <strager> I don't know what "Types" is
10:54:05 <ski> Paprikachu : this is a combination of two confusing (but fun) non-standard instances of `Num' in lambdabot
10:54:07 <strager> untitled: Why are you iterating by index, anyway?
10:54:11 <applicative> cheater you meann in (String,Int) not [String,Int], which doesn't make sense
10:54:12 <`Jake`> > 4 + 5 123 + 2
10:54:13 <kallisti> Paprikachu: types that are instances of Num can define what "fromInteger" means
10:54:14 <lambdabot>   11
10:54:17 <cheater> applicative, nand`: sorry of course i meant (String, Int)
10:54:24 <cheater> i'm a bit tired
10:54:41 <applicative> cheater, fmap acts on the second element of (x,y)
10:54:54 <nand`> (,) x is an instance of Functor
10:55:10 <Paprikachu> ski: this is crazy
10:55:13 <cheater> > fmap even ("hello world",)
10:55:14 <lambdabot>   Illegal tuple section: use -XTupleSections
10:55:21 <cheater> > fmap even ("hello world", "hello world")
10:55:22 <lambdabot>   No instance for (GHC.Real.Integral [GHC.Types.Char])
10:55:22 <lambdabot>    arising from a use ...
10:55:24 <cheater> ok
10:55:26 <untitled> strager: does it matter what "Types"? it's a custom datatype, no more, I'm iterating by index because I want every element of array and an index also passed to printArray
10:55:34 <parcs`> is there a function rotate :: Int -> [a] -> [a]
10:55:34 <cheater> why am i getting an error for (String, String) and not for (String, Int)?
10:55:44 <nand`> cheater: because of the type of “even”
10:55:47 <kallisti> cheater: so since (,) a is an instance of functor, you can take the "f" in the type for fmap and substitute it with (,) a
10:55:48 <nand`> > even "hello world"
10:55:49 <lambdabot>   No instance for (GHC.Real.Integral [GHC.Types.Char])
10:55:49 <lambdabot>    arising from a use ...
10:55:50 <kallisti> :t fmap
10:55:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:55:52 <applicative> cheater:  fmap even  acts on each element of a list -- of Ints , since they're what can be even or not
10:56:05 <kallisti> cheater: (a -> b) -> (,) a1 a -> (,) a1 b
10:56:07 <Paprikachu> i still don't get the difference between map and fmap
10:56:16 <nand`> Paprikachu: map only works on lists
10:56:21 <nand`> Paprikachu: other than that there's no difference
10:56:21 <applicative> cheater: Strings cant be even or not, so fmap even ["Hello","world"] makes no sense.
10:56:25 <kallisti> Paprikachu: map is for lists only, fmap is overloaded on many different types.
10:56:32 <Paprikachu> can you show me an example that works with fmap only?
10:56:39 <applicative> cheater: similarly fmap even (2,"hello") makes no sense
10:56:39 <nand`> > fmap (+1) (Just 5)
10:56:40 <lambdabot>   Just 6
10:56:50 <cheater> how does fmap even ("aa", 2) make more sense than fmap even ("aa", "bb")
10:56:54 <cheater> sorry i still don't get it
10:57:01 <nand`> cheater: because (even "bb") makes no sense
10:57:04 <applicative> cheater, fmap id always makes sense :)
10:57:07 <strager> Because even can be applied to at least one member
10:57:08 <Paprikachu> but istn this the same as Just 5 + 1?
10:57:16 <nand`> Paprikachu: try it
10:57:18 <nand`> > Just 5 + 1
10:57:18 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe t))
10:57:19 <lambdabot>    arising from a use of...
10:57:26 <kallisti> cheater: because the second tuple element is the thing that the function is being applied over
10:57:27 <Paprikachu> > Just 5 + Just 1
10:57:28 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe t))
10:57:29 <lambdabot>    arising from a use of...
10:57:34 <kallisti> cheater: even "aa" makes no sense, even 2 does.
10:57:39 <cheater> nand`: but (even "aa") makes no sense either yet in this case "even" ends up being id OR even, depending on context
10:57:54 <mroman> @src fmap
10:57:55 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
10:57:56 <nand`> cheater: I don't get it
10:57:56 <applicative> instance Num a => Num (Maybe a) ... could take care of that
10:58:01 <cheater> kallisti: why does fmap even choose to be id for strings in one case and error out in another case?
10:58:01 <nand`> cheater: how does “even” end up being id?
10:58:08 <kallisti> cheater: it doesn't
10:58:08 <Paprikachu> > case Just 5 of Just x -> x + 1; Nothing -> Nothing
10:58:09 <nand`> > fmap even ("hello world", 5)
10:58:09 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
10:58:10 <lambdabot>    arising from a use of...
10:58:10 <lambdabot>   ("hello world",False)
10:58:18 <nand`> -- it translates 5 to “False”
10:58:19 <kallisti> cheater: expand the type of fmap so that f = (,) x
10:58:21 <kallisti> :t fmap
10:58:22 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:58:30 <Paprikachu> > case Just 5 of Just x -> Just $ x + 1; Nothing -> Nothing
10:58:31 <lambdabot>   Just 6
10:58:34 <eacameron> Control.Concurrent give an example of how to wait for all threads: children = unsafePerformIO (newMVar [])     Is there a way NOT to use unsafe functions for this?
10:58:40 <strager> cheater: That's how the instance of Functor is defined for (,).
10:58:41 <cheater> nand`: it doesn't touch "aa" in (fmap even ("aa", 2))
10:59:00 <cheater> ok
10:59:02 <nand`> Paprikachu: that's in effect how “fmap” is defined for Maybes. fmap _ Nothing = Nothing, fmap f (Just x) = Just $ f x
10:59:11 <cheater> > fmap even (2, "bb")
10:59:12 <lambdabot>   No instance for (GHC.Real.Integral [GHC.Types.Char])
10:59:12 <lambdabot>    arising from a use ...
10:59:14 <kallisti> cheater: instance Functor ((,) a) where fmap f (a,b) = (a, f b)
10:59:15 <applicative> cheater: a pair is really unlike a list, I remember finding this difficult.  Its one of those things where after you see it you wonder what you were thinking.  Kind of annoying...
10:59:19 <cheater> ok i think i get it now
10:59:34 <ski> Paprikachu : the two instances here are `instance Num a => Num (rho -> a)' and `instance (Num a,Num b) => Num (a,b)'
10:59:39 <nand`> cheater: yes, it never touches the first element of a tuple, because that's how it's defined
10:59:43 <nand`> cheater: in any scenario
10:59:54 <nand`> > snd $ fmap even (undefined, 5)
10:59:54 <lambdabot>   False
10:59:57 <cheater> so fmap looks at (,) String as a constructor for (,) String Int ?
11:00:04 <ski> Paprikachu : the latter is a quick-and-dirty way to treat pairs of numbers as a kind of "vectors", (with both `(+)' and `(*)' being pointwise)
11:00:06 <Paprikachu> > undefined
11:00:07 <lambdabot>   *Exception: Prelude.undefined
11:00:13 <cheater> is that it?
11:00:15 <ski> Paprikachu : the former means we can type
11:00:16 <nand`> cheater: yes, and (,) String Int sugars to (String, Int)
11:00:17 <Paprikachu> what's undefined?
11:00:23 <ski> > (sin - cos) (pi/4)
11:00:24 <lambdabot>   -1.1102230246251565e-16
11:00:25 <applicative> cheater: in the 'structure' or 'container' metaphor, the first element is part of the structure or container, so it isn't replaced
11:00:27 <nand`> @src undefined -- Paprikachu
11:00:27 <lambdabot> Source not found. I've seen penguins that can type better than that.
11:00:29 <nand`> bah
11:00:31 <nand`> @src undefined
11:00:31 <lambdabot> undefined =  error "Prelude.undefined"
11:00:33 <mroman> Paprikachu: undefined is undefined .
11:00:49 <nand`> in other words; undefined is a value that, if inspected, will error
11:00:56 <cheater> applicative: yeah
11:00:56 <applicative> cheater, I mean in say: fmap even ("hello", 2)
11:01:00 <cheater> applicative: now i see
11:01:20 <nand`> in this analogy ("hello", X) is the container where X is the element it contains
11:01:31 <ski> Paprikachu : typically you use `undefined' when you really should be writing an explicit error message saying what wasn't defined, but you're too lazy and CBA (e.g. when you're just wanting to get something through the type-checker, fast)
11:01:44 <cheater> applicative: so fmap only goes as deep as it needs to find something that's Int; and if it does find it, it applies, and if itdoesn't find it, it errors out?
11:01:44 <strager> Paprikachu: From a pure point of view, undefined = undefined; i.e. it's an infinite loop.  Practically, we report an error so your program doesn't hang.  =]
11:01:57 <ski> (you can also use `undefined' for stubs)
11:02:16 <Paprikachu> > let f = undefined in f
11:02:17 <lambdabot>   *Exception: Prelude.undefined
11:02:22 <nand`> you also use undefined when demonstrating laziness :)
11:02:24 <strager> cheater: The type system does that, not fmap itself.  But basically, yes.
11:02:43 <kallisti> cheater: it's not a runtime error. it's a type error
11:02:44 <zezikaro> thanks mroman
11:02:53 <kallisti> cheater: it's the same thing as map abs "hello"
11:02:59 <kallisti> applying abs to a Char is a type error
11:03:03 <applicative> cheater, fmap even has to know what structure it's going into, then if when it reaches in it doesn't find an Int, its a type violation, yes
11:03:11 <ski> Paprikachu : a third use is when you need to pass a value somewhere, but you know the value will never be needed (but here you should really use a descriptive error message instead, unless you're very sure the value won't perhaps be evaluated in the future, when libraries might change)
11:03:15 <cheater> strager: is it possible to have a type which is container but also has an Int instance, and as a container holds other things that have an Int instance?
11:03:19 <ski> nand` : *nod*
11:03:33 <cheater> also for applicative ^
11:03:44 <nand`> cheater: “Int instance” <- no such thing
11:03:51 <strager> An Int instance?
11:03:54 <nand`> Int isn't a typeclass
11:04:00 <applicative> cheater, you mean a Num instance
11:04:02 <mroman> > let t :: (a -> m); t = id; t id
11:04:03 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:04:05 <nand`> or Integral
11:04:08 <kallisti> cheater: you could have a container that's a Functor as well as a Integral, and Num
11:04:16 <nand`> example: 1
11:04:17 <mroman> > let t :: (a -> m); let t = id; t id
11:04:18 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:04:20 <mroman> hm.
11:04:21 <mroman> damn.
11:04:31 <cheater> kallisti: can you give an example?
11:04:38 <nand`> > 1 + 1 -- Num
11:04:38 <lambdabot>   2
11:04:42 <kallisti> lists. you can encode numbers as their lengths.
11:04:45 <nand`> > fmap (+1) 1 $ 5 -- Functor
11:04:46 <lambdabot>   2
11:04:58 <mroman> > let t = id :: (a -> m) in t id
11:04:59 <lambdabot>   Couldn't match expected type `m' against inferred type `a'
11:04:59 <lambdabot>    `m' is a rigi...
11:05:01 <applicative> cheater: a 'containter type' as we're thinking of it is a thing like list or Maybe  that can contain any type
11:05:29 <applicative> cheater: but a Num instance is some concrete type like Int or whatever you define it for
11:05:40 <ski> > 4 :: (Int,Double)
11:05:41 <Guest45717> > let t :: (a -> m); t = id in t id -- mroman: this?
11:05:41 <lambdabot>   (4,4.0)
11:05:42 <lambdabot>   Couldn't match expected type `m' against inferred type `a'
11:05:42 <lambdabot>    `m' is a rigi...
11:05:43 <Paprikachu> does haskell have support for atomics?
11:05:50 <ski> > 4 + (5,6.0)
11:05:50 <kallisti> what are atomics.
11:05:51 <lambdabot>   (9,10.0)
11:05:51 <mroman> > let t a = a :: (a -> m) in t id
11:05:52 <lambdabot>   Inferred type is less polymorphic than expected
11:05:52 <lambdabot>    Quantified type variable...
11:06:09 <applicative> cheater: You could define a crazy num instance for Maybe a, generally, Nothing = 0, (Just x) = 1, so to speak
11:06:10 <Paprikachu> atomics are .... atomics. atomic operations on variables.
11:06:23 <Paprikachu> threadsafe without locking
11:06:36 <mroman> oh.
11:06:42 <kallisti> cheater: there aren't any real rules on how Num should behave, other than it's expected to behave somewhat like a field.
11:06:51 <mroman> > let t a = a :: (a -> m) -> (a -> m) in t id
11:06:53 <lambdabot>   Inferred type is less polymorphic than expected
11:06:53 <lambdabot>    Quantified type variable...
11:07:09 <kallisti> there's just a general expectation the Num is "number-like"
11:07:13 <kallisti> but no real definition of what that means.
11:07:23 <Paprikachu> so no atomics in haskell?
11:07:37 <yitz> > let t :: (a -> m); t = id in t id -- mroman: this?
11:07:38 <lambdabot>   Couldn't match expected type `m' against inferred type `a'
11:07:38 <lambdabot>    `m' is a rigi...
11:07:44 <applicative> cheater the thing about fmap and 'Functor' is that you have to define in advance for the container, apart from knowing what is going to be in it
11:07:49 <Lemmih> Paprikachu: See IORef, MVar and STM.
11:07:49 <kallisti> Paprikachu: depends on the context. STM allows you to compose atomic operations within threads.
11:07:51 <applicative> @type fmap
11:07:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:07:57 <mroman> Why won't lambdabot listen to me :(
11:08:03 <nand`> applicative: how about instance Num n => Num (Maybe n) where any operation involving Nothing would return Nothing; and the rest would work as expected? It would make failure-enabled math easier without involving the monad instance
11:08:22 <yitz> mroman: lambdabot is listening to you and telling you the truth
11:08:29 <kallisti> you could also have a Fractional instance where division by zero results in Nothing.
11:08:39 <yitz> mroman: what are you trying to do?
11:08:46 <applicative> nand`: oh, that would be more sensible clearly
11:09:04 <nand`> what kind of axioms are Num instances expected to follow; if any?
11:09:24 <applicative> the Num laws!
11:09:52 <Paprikachu> is it possible to create asymmetric operators?
11:09:55 <sipa> abs (negate x) = abs x ?
11:10:05 <yitz> nand`: that's a painful question. because ieee floats have a Num instance, and they don't really follow any sensible laws.
11:10:07 <Paprikachu> e.g. an operator + that adds pointers and numbers?
11:10:13 <mroman> yitz: t :: (a -> m) -> (a -> m); t a = a
11:10:16 <applicative> (+) and (*) must be associative !!
11:10:19 <nand`> yitz: indeed; also
11:10:25 <kallisti> none that are explicitly written anywhere. I think it's generally expected to behave like a ring  (aka an additive group and a multiplicative semigroup)
11:10:28 <sipa> x - y = x + negate y
11:10:35 <Paprikachu> for pointers and numbers this would be the case
11:10:40 <mroman> and then call t id
11:10:50 <cheater> applicative: let's say i have such a crazy num instance as you describe for Maybe, and do fmap even [Just 1, Nothing, Just 2]. How does fmap know if it should give me [False, True, False] or [Just False, Nothing, Just True] ?
11:11:03 <sipa> Paprikachu: look at the type of (+)
11:11:08 <sipa> :t (+)
11:11:09 <lambdabot> forall a. (Num a) => a -> a -> a
11:11:22 <sipa> that's 3 a's there, so it has to be three times the same type
11:11:23 <Paprikachu> sucks
11:11:27 <yitz> mroman: well id is always in scope, because it's in the prelude. try using id' or idFun or something
11:11:42 <kallisti> Paprikachu: not really. how do you translate 2 different Num instances between each other arbitrarily?
11:11:47 <kallisti> how do you decide the type of the result?
11:11:53 <yitz> mroman: so you are trying to define a version of id with a narrower type?
11:11:57 <nand`> yitz: “Num” suggests a ring; eg. the presence of a “negate” function; but some Num instances violate this eg. Data.Number.Nat
11:11:58 <mroman> > let t :: (a -> m) -> (a -> m); t a = a; t id
11:11:59 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:11:59 <Paprikachu> define it.
11:12:07 <Paprikachu> in c++ i can do that too.
11:12:13 <mroman> yitz: I't works in ghci
11:12:20 <sipa> you create a class (Num a, Num b) => BiNum a b ?
11:12:20 <mparodi_> > (.) $ flip
11:12:22 <lambdabot>   Overlapping instances for GHC.Show.Show
11:12:22 <lambdabot>                              (f (f1...
11:12:23 <mroman> I just don't know how to feed it to lambdabot.
11:12:24 <nand`> so I was left curious how many ax-crazy Haskellers would stalk me for defining odd Num instances
11:12:24 <kallisti> nand`: and I would say that Num + Fractional suggests a field.
11:12:35 <nand`> kallisti: unfortunately I have no idea what a field is
11:12:43 <mparodi_> (.) $ flip == (.) flip ?
11:12:44 <Paprikachu> i could make an operator + that takes foo, bar and returns baz.
11:13:00 <sipa> nand`: something you can solve equations in
11:13:09 <mparodi_> @type ($)
11:13:10 <lambdabot> forall a b. (a -> b) -> a -> b
11:13:15 <mparodi_> it seems it doesn't do anything :P
11:13:30 <Paprikachu> $ is a function?
11:13:38 <sipa> no, ($) is a function
11:13:56 <sipa> mparodi_: a $ b $ c d  ==  a (b (c d))
11:14:00 <cheater> applicative: will it by default go only as deep as it needs to find a Num instance?
11:14:04 <kallisti> nand`: basically instead of a multiplicative semigroup you have a commutative group under multiplication, multiplicative inverses, and division.
11:14:10 <mparodi_> so (.) $ flip == (.) (flip), sipa ?
11:14:17 <mparodi_> ie, (.) flip
11:14:25 <kallisti> nand`: rings are to integers as fields are to reals.
11:14:26 <sipa> yes
11:14:35 <mparodi_> @src ($)
11:14:35 <nand`> kallisti: sounds sensible
11:14:36 <lambdabot> f $ x = f x
11:14:37 <Paprikachu> does haskell have pointers?
11:14:38 <sipa> mparodi_: (.) flip   == (flip .)
11:14:43 <yitz> mroman: not for me. that part at the end doesn't parse. you want "in t id" rather than "; t id" i think, don't you?
11:15:14 <mparodi_> hmn, what about a $ b c?
11:15:14 <sipa> Paprikachu: it does, but you're better off right now not knowing about them
11:15:17 <nand`> “commutative group under multiplication” <- but groups require two operators; what's the second operator in this commutative group?
11:15:18 <mparodi_> > a $ b c
11:15:19 <lambdabot>   Couldn't match expected type `a -> b'
11:15:19 <lambdabot>         against inferred type `Simple...
11:15:22 <Paprikachu> why?
11:15:28 <copumpkin> nand`: they do?
11:15:28 <jtza8> Is there a standard function that does the following -- argsTo2Tuple f (a, b) = f a b -- so that you could do something like this -- map (argsTo2Tuple (+)) (zip [1..10] [5..15]) -- ?
11:15:30 <nand`> oh
11:15:31 <yitz> mroman: that does work in ghci. except that you end up with something without a Show instance, so ghci can't print it.
11:15:32 <kallisti> nand`: er, multiplication is a binary operation
11:15:32 <nand`> I was thinking ring, my bad
11:15:33 <zachk> how would I use a fold like this foldX (>>=) something [return,return,return] ?
11:15:39 <mparodi_> @type a $ b c
11:15:40 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Expr'
11:15:40 <lambdabot>     In the first argument of `($)', namely `a'
11:15:40 <lambdabot>     In the expression: a $ b c
11:15:41 * nand` keeps mixing up ring and group
11:15:49 <sipa> Paprikachu: because that will tempt you to write C code in Haskell, while there almost always better solutions
11:15:50 <copumpkin> :)
11:15:51 <mroman> yitz: Yes @no instance
11:15:58 <kallisti> nand`: oh. you're thinking of rings. groups only need one operation.
11:16:02 <mparodi_> sipa, can you add parenthesis here: a $ b c?
11:16:06 <nand`> kallisti: so a field = two abelian groups where one distributes over the other?
11:16:08 <kallisti> rings have 2 where one distributes over the other.
11:16:08 <sipa> mparodi_: a (b c)
11:16:08 <mroman> Interestingly one can define instance Num (a -> m)
11:16:11 <mparodi_> good
11:16:14 <mparodi_> thank you sipa
11:16:15 <copumpkin> nand`: with an exception for 0
11:16:16 <Paprikachu> pointers are just fine
11:16:23 <kallisti> nand`: yes
11:16:30 <mparodi_> a $ b c d == a (b c) d
11:16:31 <mparodi_> I guess
11:16:36 <sipa> mparodi_: no
11:16:39 <copumpkin> nand`: that exception is a source of lots of ugliness in algebra
11:16:44 <sipa> a $ b c d    == a (b c d)
11:16:45 <Paprikachu> a (b c d)
11:16:52 <nand`> right; no inverse exists for 0 such that 0*x = 1
11:16:52 <kallisti> nand`: I don't know if this is a property of abelian groups, but there's also additive inverses and multiplication inverses
11:16:53 <mparodi_> it's so insane, $ doesn't do anything >_>
11:16:55 <kallisti> as well as identities
11:16:57 <sipa> a $ b c d    == a (b c d)  == a ((b c) d)
11:17:06 <sipa> mparodi_: no it's just to avoid parenthesis
11:17:22 <nand`> kallisti: abelian groups have inverses
11:17:25 <kallisti> ah okay.
11:17:31 * hackagebot notcpp 0.1 - Avoiding the C preprocessor via cunning use of Template Haskell  http://hackage.haskell.org/package/notcpp-0.1 (BenMillwood)
11:17:31 <mparodi_> <sipa> a $ b c d    == a (b c d)  == a ((b c) d) <- ok, I got it!
11:17:38 <nand`> (as well as being associative, having an identity *and* being commutative)
11:17:45 <kallisti> ah okay, then yes.
11:18:01 <tulinius> Paprikachu: Even if haskell had pointers they would need to give read-only access only.
11:18:05 <monochrom> I think it's fine to let even beginners know how to write C code in Haskell (complete with pointers and handwritten mallocs and frees). the verbosity alone will ensure that they won't overuse it.
11:18:12 <sipa> Paprikachu: i agree that pointers are fine for some purposes, but if you want to learn thinking in a functional way, avoid them
11:18:15 <yitz> mroman: what you are defining is the same as id from the prelude, except it's limited; it *only* works for functions.
11:18:23 <Paprikachu> tulinus: why?
11:18:31 <kallisti> Paprikachu: pointers are typically used when interfacing with C code.
11:18:36 <kallisti> and not much else.
11:18:42 <tulinius> Paprikachu: The all immutable data thing.
11:18:45 <Paprikachu> but they're so awesome :(
11:18:46 <tulinius> *the whole
11:18:53 <kallisti> tulinius: we have pointers, and can write to them no problem in the IO monad.
11:18:56 <fmap> mparodi_: and you can avoid lambdas with ($)
11:19:04 <fmap> > map ($ 3) [(+1), (*2), negate]
11:19:06 <lambdabot>   [4,6,-3]
11:19:08 <monochrom> otoh I'm too lazy to write such a tutorial
11:19:08 <sipa> Paprikachu: they are extremely powerful, but they're hard to reason about
11:19:09 <kallisti> Paprikachu: we also have abstractions of the idea of a "reference".  IORef, MVar, etc.
11:19:22 <kallisti> Paprikachu: so using pointers directly isn't necessary.
11:19:25 <mauke> Paprikachu: http://mauke.hopto.org/stuff/haskell/hell.hs
11:19:28 <mauke> this is how you machine code
11:19:34 <mparodi_> interesting
11:19:41 <zezikaro> can you do this per chance
11:19:41 <Botje> hell is other people's haskell code.
11:19:53 <zezikaro> (x:(y:ys)) = ...
11:19:58 <Botje> yes
11:19:59 <sipa> zezikaro: sure
11:20:01 <tulinius> kallisti: Everything seems to be possible in the IO monad. ;)
11:20:02 <Botje> or just (x:y:ys)
11:20:09 <zezikaro> ^
11:20:11 <kallisti> tulinius: of course.
11:20:11 <zezikaro> thanks
11:20:18 <nand`> and with unsafePerformIO, outside of it :P
11:20:28 <kallisti> tulinius: it's misleading to say that it's not possible. it's just not possible in pure code for reasons that are hopefully obvious.
11:20:37 <yitz> monochrom: here's a short tutorial: let prog = "main () {..."; writeFile "prog.c" prog; system "gcc prog.c"
11:20:57 <monochrom> hahaha
11:21:14 <nand`> need I mention https://github.com/mmirman/ImperativeHaskell/blob/master/Main.hs ?
11:21:20 <cheater> applicative / kallisti / strager: this place is really busy, wanna talk in #codez instead? there's a lambdabot there
11:21:31 <mauke> yitz: bonus points if you compile it into a shared library, foreign import dlsym, then load it dynamically
11:21:40 <yitz> mauke: yeah!
11:22:38 <applicative> cheater my crazy num instance doesnt make sense, here's a start of a one like nand` mentioned and something you can do http://hpaste.codepad.org/aWodD1ok
11:22:38 <mroman> yitz: I know that :)
11:22:56 <mroman> > id
11:22:57 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
11:22:57 <lambdabot>    arising from a use of `...
11:22:57 <zezikaro> is there a way to make things mutable?
11:23:06 <mroman> but I was expecting this message
11:23:08 <yitz> mroman: ok. ;)
11:23:20 <nand`> applicative: now try (Just 5) + (Just 3)
11:23:21 <mroman> zezikaro: With IO, yes.
11:23:24 <mroman> like MVar
11:23:26 <mauke> zezikaro: yes, foreign import mprotect, make all pages writeable, then castPtr all over the place
11:23:35 <zezikaro> D:
11:23:38 <zezikaro> okay i'll not do that xD
11:23:39 <zezikaro> thanks
11:23:45 <Botje> zezikaro: why would you want that?
11:23:57 <mroman> or IORef
11:23:57 <tulinius> zezikaro: Maybe you should reconsider the necessity of mutable data.
11:24:08 <Paprikachu> > do f <- 42; f <- 666; f <- 0;
11:24:09 <lambdabot>   <no location info>:
11:24:09 <lambdabot>      The last statement in a 'do' construct must be an ...
11:24:09 <zezikaro> because i'm an idiot and i'm still getting to grips with haskell
11:24:13 <mroman> (not sure if IORef is mutable, i shall look)
11:24:15 <Paprikachu> > do f <- 42; f <- 666; f <- 0; return ()
11:24:16 <lambdabot>   No instance for (GHC.Show.Show (m ()))
11:24:16 <lambdabot>    arising from a use of `M775628377...
11:24:19 <mroman> Yes.
11:24:21 <applicative> cheater: http://hpaste.codepad.org/a3E0INjA
11:24:22 <Paprikachu> fu
11:24:23 <Botje> Paprikachu: numbers are not monads.
11:24:34 <mroman> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-IORef.html
11:24:35 <Paprikachu> whatever
11:24:39 <mroman> or using state monad.
11:24:47 <ski> Paprikachu : for immutable stuff, no atomic things are needed -- for mutable, see what Lemmih said
11:25:00 <Paprikachu> i know
11:25:04 <ski> for FFI stuff, one can use pointers
11:25:16 <lpsmith> :t do f <- 42; f <- 666; f <- 0; return ()
11:25:17 <lambdabot> forall (m :: * -> *) t t1 t2. (Num (m t), Monad m, Num (m t1), Num (m t2)) => m ()
11:25:21 <mroman> zezikaro: Haskell itself does not know that concept.
11:25:23 <ski> also, `IORef',`MVar',`TVar' has some of the characteristics of pointers
11:25:31 <mroman> (Correct me if I'm wrong)
11:25:41 <mroman> But it can be achieved in terms of haskell.
11:25:43 <applicative> cheater: or better, to see how  Num works check out the last two lines of http://hpaste.codepad.org/tSid8gwz
11:26:02 <Paprikachu> also, do i have to close a handle explicitly that i get from connectTo?
11:26:05 <mroman> and through cheating by using IO.
11:26:05 <hpaste> nand` pasted “Num instance for Num n => Maybe n” at http://hpaste.org/69281
11:26:11 <nand`> applicative:  ^
11:26:16 <mroman> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-IORef.html
11:26:40 <ski> Paprikachu : type class overloading in Haskell is supposed to be more principled than overloading in most other languages. e.g. if you define `(+)', you're supposed to make sure this "implements addition", in some appropriate sense
11:26:42 <Botje> Paprikachu: probably. the IRC tutorial you're following uses bracket to ensure it's closed, no?
11:27:13 <Paprikachu> but addition can also make sense asymmetric
11:27:38 <ski> Paprikachu : the designers of Haskell decided that `(+)' should take two operations of the same type (mathematically, roughly that it should be a "ring") -- if you want you can define you own addition function (possibly overloaded), which doesn't have this restriction
11:28:00 <Paprikachu> but then i can't use +
11:28:37 <ski> Paprikachu : but making it have the same type for the arguments (and the result) means that code is much less often ambiguous -- with a "different argument-types are allowed" addition, you'd much often need to manually disambiguate addition, which would be a PITA
11:28:46 <cheater> applicative: thx, looking over the pastes (btw we're chatting in #codez now)
11:28:56 <Paprikachu> no, it isn't
11:28:57 <yitz> Paprikachu: the convention in mathematics is that + is usually commutative. you would use * for an operation that isn't. so you would expect the same thing in haskell. but the compiler doesn't enforce that.
11:28:59 <ski> Paprikachu : yes you can, if you hide the `Prelude'-defined `(+)' (or use qualified import)
11:29:07 <gdoteof> i am trying to do something like --   let negify = ((*) -1);   I also have a function    getSomething :: Double -> Something    when i try and do   getSomething (negify 2.0)  i am getting a type error that negify is returning an Int rather than the expected double
11:29:09 <hpaste> nand` annotated “Num instance for Num n => Maybe n” with “Fractional instance for Fractional n => Maybe n (annotation)” at http://hpaste.org/69281#a69282
11:29:22 <nand`> here's the Fractional instance with the _ / 0 = Nothing
11:29:28 <monochrom> what a stupid "debate". import Prelude hiding((+)); import Foreign.Ptr; (+) = plusPtr; -- end of story
11:29:37 <mroman> gdoteof: Doesn't num provide negate?
11:29:40 <mroman> > negate 7
11:29:41 <lambdabot>   -7
11:29:51 <Paprikachu> but then i can't add numbers :o
11:29:52 <ski> Paprikachu : "but addition can also make sense asymmetric" -- i definitely agree, but this isn't the common case. i think here Haskell has made a reasonably good trade-off between generality and convenience of use
11:29:56 <untitled> strager: looks like I've painted myself into a corner, I used a chain of functions like: print->parseInput->defineWhatToPrint->constructTheType and now in defineWhatToPrint I want to printAll, that's basically and array of Types
11:29:57 <monochrom> there is minusPtr too
11:29:57 <yitz> gdoteof: this sounds like monomorphism restriction
11:30:18 <ski> Paprikachu : yes, you can, with `import qualified Prelude as P' and then use `a P.+ b'
11:30:24 <yitz> gdoteof: did you provide a type signature for negify?
11:30:27 <Paprikachu> xD
11:30:27 <untitled> strager: I guess I just can't return instances of Types one by one back to print
11:30:31 <Paprikachu> this is just stupid
11:30:33 <strager> untitled: Code sample please
11:30:33 <Paprikachu> i want both
11:30:34 <mroman> yitz: It is.
11:30:36 <Paprikachu> with +
11:30:43 <nand`> it should still be Integer, not Int; with defaulting rules
11:30:46 <strager> I really don't understand the context of your problem
11:31:07 <ski> Paprikachu : the problem with what you suggest is really that it would very often give ambiguity problems
11:31:23 <Paprikachu> no.
11:31:24 <applicative> gdoteof: if you ask ghci the type of negify, you'll find out how it understood yoyu
11:31:26 <nand`> :t plusPtr
11:31:27 <lambdabot> Not in scope: `plusPtr'
11:31:29 <monochrom> haskell is not c. get over it.
11:31:39 <Paprikachu> C sucks anywa
11:31:41 <Paprikachu> y
11:31:43 <mroman> gdoteof: You need to add a function type declaration.
11:31:49 <untitled> strager: what part of code do you want?
11:31:49 <mroman> negify :: (Num a) => a -> a
11:31:54 <mroman> negify :: ((*)(-1))
11:32:03 <mauke> :t negate
11:32:04 <lambdabot> forall a. (Num a) => a -> a
11:32:05 <yitz> =
11:32:08 <ski> (Paprikachu : when Haskell can't uniquely determine which overloading is meant (assuming it can't be polymorphic, which it often can), it complains, without arbitrarily picking one of the choices -- this is really the right thing to do, but when you get ambiguity, that's annoying)
11:32:14 <mroman> else the infered type will be Integer -> Integer instead of Num a => a -> a
11:32:20 <mroman> (or just use negate :D)
11:32:20 <applicative> gdoteof, or you can :set -XNoMonomorphismRestriction
11:32:27 <strager> untitled: Everything relevant
11:32:28 <monochrom> (and yes, I'm personally really tired of all these bickering-like syntax questions and wishes. maybe you aren't bickering, but it comes across that way, and I'm tired of it.)
11:32:32 <ski> s/without/instead of/
11:32:41 <Paprikachu> but there is nothing ambigous when using it for numbers
11:32:42 <gdoteof> mauke: maybe i will just use negate
11:32:49 <gdoteof> applicative: ok.  so i can use it on an int and a Double if i tu rn off the restriction
11:33:01 <ski> (monochrom : hm, what was that re ?)
11:33:03 <Paprikachu> just because you _can_ make it asymmetric it doesn't mean that that's always the case
11:33:11 <applicative> gdoteof: you'll probably have to redefine it?
11:33:15 <gdoteof> i am using it on an int as well
11:33:31 <monochrom> ski, re day after day of these "why doesn't haskell let me do ___"
11:33:34 <nand`> given the strangeness of some Num instances in the first place I doubt being asymmetric or not is going to be a show stopper; you can't assume too much about num instances in the first place
11:33:55 <nand`> and many of them are full of = error ...
11:34:12 <applicative> gdoteof: you can put the line :set -XNoMonomorphismRestriction in your .ghci file, then it will start up that way.  The default is a little tiresome, I rarely regret putting it in my .ghci
11:34:17 <nand`> ?faq Can Haskell do pointer arithmetic?
11:34:17 <lambdabot> The answer is: Yes! Haskell can do that.
11:34:18 <ski> monochrom : ok
11:34:41 <yitz> monochrom: i wonder how often they ask "why didn't C properly infer the type of this function" on c#?
11:34:42 <applicative> Haskell is the finest pointer arithmetic language in the world
11:34:46 <Paprikachu> ?faq what's better, blue or green?
11:34:46 <lambdabot> The answer is: Yes! Haskell can do that.
11:34:50 <mroman> ?faq Can Haskell do Haskell?
11:34:50 <lambdabot> The answer is: Yes! Haskell can do that.
11:35:01 <ski> (i think answering these questions sometimes (often ?) helps people understand the reason for something -- and sometimes to understand that the reason isn't that good)
11:35:03 <mroman> ?faq Can Haskell solve the halting problem?
11:35:04 <lambdabot> The answer is: Yes! Haskell can do that.
11:35:07 <mroman> LIAR!!!
11:35:09 <untitled> strager: well, it's very big, didn't you get the idea?
11:35:35 <applicative> lambdabot is a cheerleader, a bit prone to exageration
11:35:59 <applicative> until it gets in a bad mood
11:36:12 <ski> @botsnack
11:36:13 <strager> untitled: Sorry; I'm busy at the moment.  If you want my help, PM me and I'll get back to you in a few.
11:36:13 <lambdabot> :)
11:36:13 <nand`> halts x = x `seq` True
11:36:15 <applicative> @faq Can Haskell make you miserable?
11:36:15 <lambdabot> The answer is: Yes! Haskell can do that.
11:36:19 <gdoteof> applicative: i am not in ghci, but i put i4
11:36:39 <ski> nand` : yeah, thouhg using `Sierpinski' would be prettier
11:36:45 <gdoteof> uh.  not 14.  bad clipboard
11:36:45 <gdoteof> {-# LANGUAGE ScopedTypeVariables, NoMonomorphismRestriction #-}
11:36:51 <applicative> right
11:37:02 <Paprikachu> ?faq Can Haskell give me a blowjob?
11:37:02 <lambdabot> The answer is: Yes! Haskell can do that.
11:37:07 <nand`> ski: I don't get the reference
11:37:16 <nand`> other than the person Sierpinski
11:37:19 <Paprikachu> \o/
11:37:39 <nand`> (and something about triangles)
11:37:39 <ski> nand` : well, `data Sierpinski = Halts', re the `Sierpinski' space in topology
11:37:54 <nand`> ski: oh
11:38:07 <Paprikachu> > data X = Left X | Middle X | Right X;
11:38:08 <lambdabot>   <no location info>: parse error on input `data'
11:38:19 <Paprikachu> > data Foo X = Left X | Middle X | Right X;
11:38:20 <lambdabot>   <no location info>: parse error on input `data'
11:38:24 <Paprikachu> omg fu
11:38:29 <ski> nand` : this topology has two points, `Halts' and `_|_', and three open sets : `{}',`{Halts}',`{Halts,_|_}'
11:38:34 <nand`> lambdabot won't let you define data types
11:38:43 <ski> nand` : not that `{_|_}' is *not* an open set
11:39:01 <nand`> note that the second definition is incorrect; “Foo X” <- X has to be a variable
11:39:33 <ski> nand` : the nice thing with this is that the continuous function from a type `T' to `Sierpinski' are exactly the computable functions (if we assume the "natural" topology on `T', generated by the definedness partial order)
11:39:35 <Paprikachu> X is an uppercase variable
11:39:38 <Paprikachu> :P
11:39:55 <nand`> “data X = Left X | Middle X | Right X” <- this may or may not be what you want, it's useful for defining an infinite sequence of triforks, but that's about it
11:40:09 <ski> nand` : then we can *define* a type `T' to be compact if we can implement `forallT :: (T -> Sierpinski) -> Sierpinski'
11:40:13 <nand`> eg. Left (Left (Middle (Left (Right (Right (Middle ...
11:40:41 <hpaste> gdoteof annotated “Handler/Player.hs” with “Handler/Player.hs (annotated with error)” at http://hpaste.org/69284#a69286
11:40:44 <ski> nand` : and we can *define* a type `T' to be Haussdorf if we can implement `(/=) :: T -> T -> Sierpinski'
11:41:09 <zezikaro> Uhh
11:41:09 <monochrom> ski, it goes bad when one crosses the line from answering to arguing. every bit of language design being "lose X to gain Y", you can go into a mexican standoff "but I prefer X!" "no, I insist on Y!", and you almost always do, as we have just observed empirically
11:41:15 <zezikaro> does anyone know what a naked expression is? o.O
11:41:19 <nand`> ski: I have no idea what any of that means but it sounds interesting and related
11:41:19 <gdoteof> http://hpaste.org/69284#line167 i even tried explictly casting the call of the problem function
11:41:30 <Paprikachu> > "8====o"
11:41:30 <ski> monochrom : granted
11:41:31 <lambdabot>   "8====o"
11:41:38 <Paprikachu> naked expression
11:41:39 * nand` <- knows nothing about topology
11:41:42 <ski> @where topology
11:41:42 <lambdabot> "topology in Haskell" <http://www.haskell.org/pipermail/haskell/2004-June/014134.html> and "Synthetic topology of data types and classical spaces" <http://www.cs.bham.ac.uk/~mhe/papers/entcs87.(pdf|
11:41:42 <lambdabot> dvi|ps)> by Martn Escard
11:41:59 <ski> nand` : see that ^ paper -- the initial sections aren't that hard to understand (and it uses Haskell)
11:42:03 <ski> also see
11:42:05 <ski> @where impossible
11:42:06 <lambdabot> <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>,<http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/>
11:42:28 <nand`> ski: I'll have a look, thanks
11:42:36 <ski> nand` : i became interested in topology after seeing these connections between it and computing :)
11:42:52 <nand`> I hear category theory comes from topology
11:43:03 <ski> well, algebraic topology, but yes
11:43:06 <monochrom> the statistical observation is that when a person asks "why doesn't this language do ___", with about 99% probability it is not a "why" question, it is a rhetorical question, the asker really means "I want haskell to do ___". the preference has already been chosen. it has to be a mexican standoff.
11:43:52 <ski> monochrom : yes, but still explaining the rationale (if any, and regardless of whether it's a good one or not), may help people understand
11:44:05 <yitz> ski: the chapter on denotational semantics in the haskell wikibook is also nice
11:44:14 <ski> nand` : what yitz said
11:44:38 <yitz> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
11:44:45 <zezikaro> :t sum
11:44:46 <lambdabot> forall a. (Num a) => [a] -> a
11:45:04 <Paprikachu> > sum []
11:45:05 <lambdabot>   0
11:46:26 <nand`> yitz: I've opened it (and the other links ski mentioned); this should make for a good read the next time I'm bored
11:46:46 * nand` is still waiting for some books on set theory from tgeeky :(
11:49:28 <armlesshobo> :t product
11:49:28 <lambdabot> forall a. (Num a) => [a] -> a
11:49:57 <gdoteof> so essentially i am doing  let (firstOp,secondOp) = case formResult { Addition->((+=.), id); Subtraction -> ((-=.), negate); }; runDB { update someId (firstOp something); insert $ MyConstructor (secondOp thingOne) (secondOp thingTwo)
11:50:36 <Paprikachu> is there a way to embed a haskell interpreter in my c++ program?
11:50:37 <mparodi_> > let bar (n+1) = n in bar 5
11:50:38 <lambdabot>   <no location info>: Parse error in pattern
11:50:49 <ski> nand` : iirc, there's one or two more-or-less-updates on this topic on Andrej Bauer's blog, but i CBA to look them up atm
11:50:55 <gdoteof> where, MyConstructor wants Int Double   thingTwo is a double, but (secondOp thingTwo) appears to be ambiguous/returning an int
11:51:27 <bscarlet> Paprikachu: yes
11:51:37 <mparodi_> why I can put a pattern like (n+1) en Hugs and I can't in ghci?
11:51:41 <ski> Paprikachu : Hugs can be embedded in C, which should work. i'm not sure about GHC, but i suspect one can do it there as well (maybe ask in #ghc ?)
11:51:46 <mparodi_> s/en/in/
11:51:53 <mparodi_> > let bar (n+1) = n in bar 5
11:51:54 <lambdabot>   <no location info>: Parse error in pattern
11:51:59 <mauke> mparodi_: because hugs is old
11:52:00 <mparodi_> >_>
11:52:05 <ski> monochrom : because `NPlusKPatterns' are disabled in GHC
11:52:09 <ski> argh
11:52:13 <ski> mparodi_ ^
11:52:13 <monochrom> hah
11:52:13 <mparodi_> mauke, old? it does something that ghci can't :P
11:52:21 <mauke> mparodi_: yes
11:52:29 <mparodi_> ah, then all I need to do is enable it
11:52:30 <nand`> GHC(i) used to be able to do it
11:52:31 <ski> mparodi_ : you can enable it in GHC, as well
11:52:33 <monochrom> you're looking at deprecation
11:52:46 <bscarlet> Paprikachu: Do you want an interpreter (e.g. ghci?) or to call compiled (e.g. by ghc) code from C++?
11:52:50 <mparodi_> it was a bad idea to use that kind of patterns?
11:52:51 <nand`> for reasons see also http://hackage.haskell.org/trac/haskell-prime/wiki/RemoveNPlusK
11:52:57 <Paprikachu> interpreter
11:53:13 <Paprikachu> i want to able to load scripts at runtime
11:53:31 <nand`> Paprikachu: that still doesn't exclude compiled code / GHC
11:53:35 <nand`> just compile it at runtime
11:53:39 <Paprikachu> yeah
11:53:46 <monochrom> Haskel 98 supports "f (n+1)". Haskell 2010 doesn't. ghc since some version goes with Haskell 2010.
11:54:04 <geekosaur> 7.2.1, I believe
11:54:05 <bscarlet> Paprikachu: Since you can call Haskell from C++ and GHCi's written in Haskell, you should be able to do it.
11:54:10 <nand`> as long as you're not going to do something like GHCi where the results of previous evaluations can affect the compilation of furthers
11:54:12 <mparodi_> I see
11:55:17 <zezikaro> Can I place limitations on 'a' for data constructors
11:55:19 <gdoteof> oh man.  internet is bad
11:55:22 <ski> mparodi_ : however, there *are* things that Hugs can do, that GHC can't, see "restricted type synonyms" and "trex" (a flexible / light-weight record system) at <http://cvs.haskell.org/Hugs/pages/hugsman/exts.html>
11:55:39 <zezikaro> data Foo (Ord a) = Foo a | Bar a a
11:55:54 <zezikaro> for instanve
11:56:05 <mparodi_> data Ord a => Foo a ?
11:56:09 <nand`> data Ord a => Foo a = Foo a | Bar a a -- should work I believe with some extension
11:56:18 <nand`> but it needs an extension for a reason
11:56:21 <ski> mparodi_ : yes, but this is usually a bad idea
11:56:31 <mparodi_> what?
11:56:36 <nand`> by adding the constraint to the definition every single function that works with them will also have to carry around the constraint in their types
11:56:46 <ski> `data Ord a => Foo a = ...' doesn't behave as one'd want it to
11:56:54 <mparodi_> oh, no?
11:57:04 <mparodi_> how do you achieve the same then?
11:57:10 <nand`> eg. mkFooToBar (Foo a) = Bar a a; mkFooToBar :: Ord a => Foo a -> Foo a
11:57:10 <monochrom> you can do it but it doesn't simplify anything
11:57:13 <nand`> needs the Ord constraint
11:57:18 <nand`> even though it's nonsensical in context
11:57:39 <ski> (a) you still have to say `Ord a' in type signatures; (b) when taking `Foo a', as *input* you *require* the caller to supply `Ord a', instead of extracting it from the data
11:58:18 <ski> mparodi_ : you may want to use `data Foo :: * -> * where Foo,Bar :: Ord a => a -> Foo a' instead (requires `GADTs' extension)
11:58:27 <ski> zezikaro ^ see above
11:58:28 <mparodi_> o.o
11:58:36 <zezikaro> i'm trying to understand
11:58:40 <zezikaro> thanks
11:58:46 <ski> (you can say `Foo a' instead of `Foo :: * -> *', yes)
11:59:06 <nand`> or data Foo a = Ord a => Foo a -- does this work with the appropriate extensions?
11:59:29 <ski> mparodi_ : with the `GADT'y declaration i said, a value of type `Bar T' contains both a value of type `T', and a constraint `Ord T'
11:59:36 <ski> this means that you can then write e.g.
11:59:44 <ski>   useless :: Foo a -> Bool
11:59:52 <ski>   useless (Foo a) = a == a
11:59:53 <nand`> zezikaro: in this scenario there's no real reason to have the constraint though
11:59:57 <ski>   useless (Bar a) = a /= a
12:00:00 * mparodi_ forwards to zezikaro
12:00:12 <ski> note that i *didn't* have to add `Ord a => ' to the type signature here
12:00:28 <nand`> since you can simply write useless :: Ord a => Foo a -> Bool
12:00:33 <nand`> for cases where the constraint is actually needed
12:00:36 <ski> if you had used `data Ord a => Foo a = ...', then you would have had to add the constraint in the type signture of `useless'
12:00:41 <zezikaro> it's a binary tree
12:00:47 <zezikaro> the constraint of comparable will always be needed
12:00:58 <zezikaro> i don't understand most of the notation you just used
12:01:04 <monochrom> yes, and you will always have to re-state it everywhere
12:01:12 <zezikaro> regardless of data constructor
12:01:18 <ski> zezikaro,mparodi_,nand` : basically, the specified behaviour of `data Ord a => Foo a = ...' in the report is generally considered to be a mistake, "don't use"
12:01:19 <nand`> Data.Map doesn't have the constraint
12:01:19 <zezikaro> okay i thought it could be inferred
12:01:37 <zezikaro> ski 'the report' ?
12:01:42 <zezikaro> which report is this
12:01:46 <ski> @where report
12:01:47 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
12:02:36 <ski> zezikaro : `GADT'-notation is an alternate (and also more general) way to declare datatypes
12:02:41 <ski> e.g. instead of saying
12:03:11 <ski>   data Tree a = Tip
12:03:11 <ski>               | Node a (Tree a) (Tree a)
12:03:13 <ski> you can say
12:03:18 <ski>   data Tree a
12:03:19 <ski>     where
12:03:42 <ski>     Tip  ::                          Tree a
12:03:43 <ski>     Node :: a -> Tree a -> Tree a -> Tree a
12:04:02 <ski> (where i (usually) prefer replacing the first line with `data Tree :: * -> *')
12:04:29 <nand`> the ‘a’ in ‘data Tree a’ has zero significance for GADTs, right?
12:04:29 <ski> i.e., instead of the BNF-inspired notation for datatypes, you explicitly state the type signatures of the data constructors
12:04:33 <nand`> ie. the variable
12:04:34 <ski> nand` : yes
12:04:46 <ski> (which is why i prefer stating a `KindSignature' for it instead)
12:05:40 <ski> (but sometimes i leave some type variables in, if they appear in a parametric way in all the data constructor type signatures)
12:06:00 <ski> e.g.
12:06:11 <ski>   data Expr (var :: * -> *) :: * -> *
12:06:13 <ski>     where
12:06:28 <ski>     Var :: var a -> Expr var (var a)
12:06:41 <ski>     Pair :: Expr var a -> Expr var b -> Expr var (a,b)
12:06:49 <ski>     Int :: Int -> Expr var Int
12:06:51 <ski>     ...
12:07:27 <zezikaro> I wish I knew what any of these acronyms are. BNF ? brackus noare form? GADT? g.* abstract data type
12:07:51 <taylorgb> close enough
12:07:53 <zezikaro> Generalized algebraic data type
12:07:53 <ski> (this is pretending that Haskell `GADT's are like indexed data types in Agda)
12:07:56 <mekeor> ski: hpaste, pls
12:08:14 <ski> zezikaro : Backus-Naur form, or Backus-Normal form, yes
12:11:45 <hpaste> ski pasted “GADT stuff for mekeor” at http://hpaste.org/69289
12:21:54 <mparodi_> is there any way to know what is being composed with (.) in an expression like "foldr (++) . map (:)"?
12:22:21 <shachaf> The function (foldr (++)) is being composed with the function (map (:)).
12:22:21 <mparodi_> foldr ((++) . map (:)) ?
12:22:28 <mparodi_> how you know?
12:22:36 <shachaf> Because that's how Haskell syntax works.
12:22:50 <shachaf> Function application is the third-tightest-binding thing.
12:22:53 <mparodi_> but what's the precedence of (.) relative to functions?
12:22:57 <mparodi_> ahm
12:22:59 <shachaf> Lower.
12:23:03 <mparodi_> I see
12:23:08 <mparodi_> ok, that makes sense
12:23:08 <ibid> all operators are lower than function applications
12:23:11 <shachaf> Function appliaction is pretty much the highest-precedence thing.
12:23:40 <mparodi_> so foldr (++) . map (:) == (.) (foldr (++)) (map (:))
12:23:54 <shachaf> That's right.
12:24:01 <mparodi_> ok, thanks
12:24:08 <shachaf> One of the best ways to learn about these things is to experiment with small expressions in ghci.
12:24:46 <shachaf> For example, let f = foldr (++) . map (:); let g = (foldr (++)) . (map (:)); let h = foldr ((++) . map (:)); :t f; :t g; :t h
12:24:49 <mparodi_> I totally agree, that's what I'm doing :P
12:28:39 * tgeeky_ lets out a small thank you to The Jesus for haskell.
12:28:46 <tgeeky_> or your respective diety
12:29:41 <zezikaro> Could anyone help me with my fromStream method please http://codepad.org/tIUKhzT8
12:29:42 <luite> diety? are you saying i'm fat?
12:29:48 <zezikaro> it's saying it can't match the pattern in ghci
12:29:48 <Cale> tgeeky_: Simon Peyton Jones
12:29:48 <preflex>  Cale: you have 2 new messages. '/msg preflex messages' to read them.
12:30:04 <zezikaro> "non-exhaustive patterns in function fromStream"
12:30:19 <tgeeky_> Cale: I was going to also put "The SPJ" but I felt I would have left out so many The Oleg, The SMar, ...
12:32:11 <Cale> Yeah, but I still consider him a better representative, you know, actually existing and all that :D
12:32:30 <Botje> zezikaro: what about fromStream [] ?
12:32:47 <zezikaro> Botje oops
12:34:41 <zezikaro> Botje Okay that was missing, but it didn't solve the problem
12:35:58 <jfischoff> zezikaro: as a general practice, I would cover all your cases, and if some are "impossible" use error to give a description. If your fromStream and toStream form an isomorphism, then you can use quickcheck to verify, and shrink to find a minimal test case.
12:36:27 <jfischoff> zezikaro: -Wall will tell you if something is missing
12:36:58 <zezikaro> jfischoff I don't know what 'isomorphism' is :(
12:37:15 <zezikaro> I did hear a talk mention it, when they were talking about some weird language i didn't understand though
12:37:20 <zezikaro> -wall
12:37:37 * hackagebot filestore 0.5 - Interface for versioning file stores.  http://hackage.haskell.org/package/filestore-0.5 (JohnMacFarlane)
12:37:42 <zezikaro> > -wall
12:37:43 <lambdabot>   Not in scope: `wall'
12:37:48 <zezikaro> what is 'wall' sorry
12:37:53 <zezikaro> google doesn't give anything
12:38:28 <taylorgb> Enabled all warnings
12:40:11 <zezikaro> that flag isn't settable from 'runhaskell' is it?
12:40:17 <jfischoff> zezikaro: 'isomorphism' is a way of saying you go forwards and backwards for all input.
12:40:36 <jfischoff> zezikaro: an invertible process
12:42:01 <augur> http://fdiv.net/2012/04/01/objectivist-c
12:42:05 <jfischoff> zezikaro: I have to run to lunch, but personally I find for to/from pairs quickcheck with shrinks is a great way to find issues and minimal tests cases.
12:42:17 <augur> the randian screen at the end is, of course, true if it were SPJ saying it :x
12:43:55 <zezikaro> jfischoff thanks
12:47:31 <alexShpilkin> In http://pchiusano.blogspot.com/2010/06/spj-trick-for-typesafe-adt-annotations.html, a neat trick for introducing annotations into (say) an expression type without stuffing the annotation type all over your constructors was described. Is there a way to do a similar thing with a (heterogeneous) AST?
12:50:07 <djahandarie> I love that I can read any Haskell blog post, and edwardk inevitably has a comment about cofree comonads at the bottom of the page
12:50:40 <ski> @where DecoratingStructures
12:50:41 <lambdabot> <http://web.archive.org/web/20051126143527/http://haskell.org/hawiki/DecoratingStructures>
12:50:41 <ski> @where IndirectComposite
12:50:41 <lambdabot> <http://web.archive.org/web/20051126141834/http://haskell.org/hawiki/IndirectComposite>
12:50:44 <ski> alexShpilkin ^
12:53:21 <nand`> tgeeky_: !
12:54:30 * ksf wants a feature matrix of frp implementations.
12:54:53 <tgeeky_> nand`: hey!
12:55:10 <tgeeky_> I will send you a list of availables when I get home later today
12:55:15 <djahandarie> Column titles: "Works" "Works fast" "Doesn't have shitty syntax"
12:55:18 <nand`> okay
12:55:24 <nand`> just making sure there hasn't been a miscommunication
12:55:26 <nand`> it's been a while :P
12:55:46 <mauke> never a miscommunication
12:55:46 <tgeeky_> yeah. I keep missing you or forgetting when I get home
12:55:48 <mauke> you can't explain that
12:55:50 <ksf> there are more than one that have yes in all of those columns.
12:56:01 <ski> alexShpilkin : btw, i think if you replace `data Expr a = Expr a (ExprImpl a)' and `data ExprImpl a = ..a..(Expr s)..' with `data Expr a = Expr (Annotate a (ExprF (Expr a)))', `data Annotate a self = Ann a self' and `data ExprF a self = ..a..self..', then i think you can use the fact that `Annotate a' is a comonad, to remove some boiler-plate
12:56:26 <ski> (note how the latter is using IndirectComposite)
12:56:30 <ksf> something like "proper event switching" "sane sharing" "leakiness"
12:57:21 <ski> alexShpilkin : "Is there a way to do a similar thing with a (heterogeneous) AST?", you can trivially pass `a' to the other types as well
12:57:44 <ksf> netwire looks interesting.
12:57:53 <ski> alexShpilkin : however, doing IndirectComposite is harder here, since we'd really want a tuple (or preferably, a record) of types
12:59:01 <mparodi_> @src scanl
12:59:01 <lambdabot> scanl f q ls = q : case ls of
12:59:01 <lambdabot>     []   -> []
12:59:02 <lambdabot>     x:xs -> scanl f (f q x) xs
12:59:07 <ski> .. maybe it is possible to use some kind of `GADT' trick to simulate the type-level tuples/records, perhaps similar to one used in Multiplate
12:59:36 <alexShpilkin> ski: thanks! <trying to understand the comonad part in the background> it looks like I'd have to pass around not only versions of ‘self’ = ‘Expr ...’, but also ‘Pat’, and ‘Decl’, and whatever happens to be in the mutually recursive group — or am I wrong?
12:59:52 <mparodi_> argh! it's hard to figure out what a function does if all the variables are like x f q y, etc -.-"
13:00:11 <ski> alexShpilkin : well, typically when you traverse your trees, you want to ignore the annotations. so `extract :: Annotate ann a -> a' will be of help here
13:00:19 <mparodi_> @hoogle scanl
13:00:20 <lambdabot> Prelude scanl :: (a -> b -> a) -> a -> [b] -> [a]
13:00:20 <lambdabot> Data.List scanl :: (a -> b -> a) -> a -> [b] -> [a]
13:00:20 <lambdabot> Prelude scanl1 :: (a -> a -> a) -> [a] -> [a]
13:00:31 <ksf> then, otoh, I just *love* sodium's asynchronicity and listener approach.
13:00:44 <ksf> ...sodium doesn't deal with sharing properly, though.
13:01:09 <ski> alexShpilkin : but then when we compute a transformed copy of the tree, we (usually) want to *preserve* the annotations, so `(=>>) :: Annotate ann a -> (Annotate ann a -> b) -> Annotate abb b' can help here
13:01:34 <ski> alexShpilkin : btw, `extract' and `(=>>)' are the two basic comonad operations, they're dual to `return' and `(>>=)' for monads
13:01:37 <nand`> should it be considered bad form to model 90% of some application in a big StateT ProgramState IO with lots and lots of ‘do’ sugar?
13:02:14 <ski> nand` : if you can think of a way to do it will less of that, but which is still reasonable, that would be a win, yes
13:02:21 <kallisti> nand`: depends on the application.
13:02:25 <ski> nand` : sometimes one can use `MonadPrompt'
13:02:51 * hackagebot gitit 0.10 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.10 (JohnMacFarlane)
13:03:03 <ski> (which allows one to inspect the actions created, and not just performing it in `IO')
13:03:17 <kallisti> nand`: the webdriver package I wrote is basically 100% that, because the entire purpose is to communicate with a remote web server that understands a JSON-based API.
13:03:30 <nand`> kallisti: yeah, I'm working on a networked P2P chat program
13:03:31 <alexShpilkin> ski: writing down the duals is not the problem, the problem is understanding what in the world I’d want to use them =) OK, so I understand the comonadic idea (here)
13:03:55 <nand`> so there's lots of state going on (current connections, DHT fragments, etc.)
13:04:04 <ski> mparodi_ : `f' is the combine function, like in `foldl', `q' is the initial state (like in `foldl'), `x' is the current element, `xs' is the rest of the elements
13:04:41 <alexShpilkin> ski: still passing all the mutually recursive types (or a tuple, or a record of them) around is the way to go
13:04:46 <mparodi_> I can guessed that but it means nothing, it's completely abstract :P
13:05:32 <ski> alexShpilkin : the problem is that typically you'd write code like `foo (Expr ann (App operator operand)) = ...return (Expr ann (App newOperator newOperand))'
13:06:43 <ski> alexShpilkin : you could say `foo (Expr ann expr) = liftM (Expr ann) (work expr) where work (App operator operand) = ...return (App newOperator newOperand); ...' i suppose
13:07:10 <ski> alexShpilkin : "still passing ..." -- unfortunately, yes
13:08:01 <ski> mparodi_ : heh, ok -- hopefully the simlarity with `foldl' should help a bit, if you already understand `foldl'
13:08:47 <ski> alexShpilkin : i haven't tried much with using a comonad here, but i suspect it can be better, or at least as nice, as the above formulation
13:09:44 <mparodi_> err, s/I can guessed/I guessed/
13:09:54 <mparodi_> at least there's an example in hoggle :P
13:11:05 <ski> > scanl f q [a,b,c,d,e]
13:11:06 <lambdabot>   [q,f q a,f (f q a) b,f (f (f q a) b) c,f (f (f (f q a) b) c) d,f (f (f (f (...
13:11:12 <ski> > scanl (+) q [a,b,c,d,e]
13:11:13 <lambdabot>   [q,q + a,q + a + b,q + a + b + c,q + a + b + c + d,q + a + b + c + d + e]
13:11:19 <ski> mparodi_ : does those ^ help ?
13:11:41 <mparodi_> yep
13:11:49 <mparodi_> > scanr f q [a, b, c]
13:11:50 <lambdabot>   [f a (f b (f c q)),f b (f c q),f c q,q]
13:12:48 <mparodi_> scanr is like fold many times with the tail of the list you just used
13:12:56 <mparodi_> foldr, btw
13:13:17 <mparodi_> scanl the same with foldl
13:14:02 <ski> yep (except inits, not tails)
13:14:10 <ski> > tails [0,1,2,3]
13:14:11 <lambdabot>   [[0,1,2,3],[1,2,3],[2,3],[3],[]]
13:14:13 <ski> > inits [0,1,2,3]
13:14:15 <lambdabot>   [[],[0],[0,1],[0,1,2],[0,1,2,3]]
13:14:29 <hiptobecubic> @src scanr
13:14:29 <lambdabot> scanr _ q0 []     =  [q0]
13:14:29 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
13:14:29 <lambdabot>     where qs@(q:_) = scanr f q0 xs
13:15:35 <nand`> > map (foldr f q) (tails [a, b, c])
13:15:36 <lambdabot>   [f a (f b (f c q)),f b (f c q),f c q,q]
13:16:09 <hiptobecubic> that's nice, what package gives you symbolic evaluation like that?
13:16:16 <nand`> SimpleReflect
13:16:21 <mparodi_> @src foldr1
13:16:21 <lambdabot> foldr1 _ [x]    = x
13:16:22 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
13:16:22 <lambdabot> foldr1 _ []     = undefined
13:16:31 <ski> > (([] :) . concatMap (init . tails) . inits) "abcd"
13:16:32 <ski> > (([] :) . concatMap (tail . inits) . tails) "abcd"
13:16:33 <lambdabot>   ["","a","ab","b","abc","bc","c","abcd","bcd","cd","d"]
13:16:34 <lambdabot>   ["","a","ab","abc","abcd","b","bc","bcd","c","cd","d"]
13:17:02 <ski> > x == x
13:17:03 <lambdabot>   True
13:17:05 <ski> > x == x + 0
13:17:07 <lambdabot>   False
13:17:35 <hiptobecubic> Well you don't know what x is and how + is defined, perhaps?
13:17:56 <ski> (caveat emptor)
13:17:56 * hackagebot cond 0.4.0.1 - Basic conditional and boolean operators with monadic variants.  http://hackage.haskell.org/package/cond-0.4.0.1 (AdamCurtis)
13:17:57 <nand`> ski the Eq instance for Expr is messed up
13:18:03 <ski> yep
13:18:03 <hiptobecubic> or is it because of this SimpleReflect thing
13:18:08 <nand`> ski: it does string comparison on the “output”
13:18:19 <ski> not s/string/structural/ ?
13:18:25 <kallisti> which is basically all you can do.
13:18:31 <kallisti> because Num implies no laws about how + behaves.
13:18:40 <hiptobecubic> > x + 0
13:18:41 <lambdabot>   x + 0
13:18:51 <hiptobecubic> > x + x
13:18:52 <lambdabot>   x + x
13:18:53 <ski> kallisti : it should imply identity laws, at the very least
13:18:59 <nand`> ski: instance Eq Expr where a == b = show a == show b
13:19:02 <kallisti> yes.
13:19:07 <ski> > x ^ 5
13:19:08 <lambdabot>   x * x * (x * x) * x
13:19:18 <ski> nand` : i see
13:19:24 <alexShpilkin> ski: foo (Ann ann (App f op)) = ... (Ann ann (App f' op')) ... -- looks like fmap?
13:19:44 <hiptobecubic> Why do the parens show up?
13:19:50 <hiptobecubic> > x^3
13:19:50 <lambdabot>   x * x * x
13:19:53 <hiptobecubic> > x^4
13:19:54 <lambdabot>   x * x * (x * x)
13:20:03 <ski> alexShpilkin : yes, but what happens if you're merging two trees ?
13:20:08 <hiptobecubic> > x^6
13:20:09 <lambdabot>   x * x * (x * x) * (x * x)
13:20:23 <ski> hiptobecubic : because it's `(x * x) * (x * x)' for `x^4'
13:20:23 <hiptobecubic> > x^6 / x
13:20:24 <lambdabot>   x * x * (x * x) * (x * x) / x
13:20:37 <alexShpilkin> ski: ahem? trees of ... what?
13:20:44 <hiptobecubic> ski, it isn't though? see above
13:20:48 <alexShpilkin> ski: expression trees?
13:20:50 <ski> (but `+' is declared to be left-associative, so some brackets can be omitted)
13:21:05 <ski> alexShpilkin : yes
13:21:12 <nand`> > x^16
13:21:13 <lambdabot>   x * x * (x * x) * (x * x * (x * x)) * (x * x * (x * x) * (x * x * (x * x)))
13:21:31 <ski> > x ^^ (-5)
13:21:32 <lambdabot>   recip (x * x * (x * x) * x)
13:22:03 <nand`> > x ** 2
13:22:03 <lambdabot>   x**2
13:22:06 * alexShpilkin tries to invent a useful way to merge two source-location-annotated expression trees that would conserve source locations
13:22:07 <nand`> > x ** 0.2
13:22:08 <lambdabot>   x**0.2
13:22:44 <ski> alexShpilkin : i'm not saying comonads definitely help (any more than `fmap'/`liftM') -- i'm meremly saying that i think it would be intersting to explore
13:22:52 <hiptobecubic> @type (^^)
13:22:53 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
13:23:03 <hiptobecubic> @type (^)
13:23:04 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
13:23:10 <ski> alexShpilkin : e.g., maybe if we're doing macros, comonads can help more ??
13:23:30 <hiptobecubic> what's the benefit of using (^^)?
13:23:39 <ski> > x ^ (-5)
13:23:40 <lambdabot>   *Exception: Negative exponent
13:23:51 <dmwit> alexShpilkin: Judging purely by the last sentence you wrote, you might like http://bosker.wordpress.com/2012/05/10/on-editing-text/
13:24:18 <ski> > 4 ^ (-5) :: Integer
13:24:20 <lambdabot>   *Exception: Negative exponent
13:24:24 <ski> > 4 ^^ (-5) :: Rational
13:24:25 <lambdabot>   1 % 1024
13:24:42 <geekosaur> exact result, I think; (**) uses floating point math which is inherently inaccurate
13:25:00 <ski> yep, but hiptobecubic asked about `(^^)', not `(**)'
13:25:13 <hiptobecubic> > 4 ^ (-5) :: Rational
13:25:13 <lambdabot>   *Exception: Negative exponent
13:25:23 <dmwit> geekosaur answered the benefit of (^^) over (**); you answered the benefit of (^^) over (^)
13:25:26 <geekosaur> actually did not say what thy were comparing ^^ to
13:25:27 <dmwit> You're both right.
13:25:36 <ski> (oh, you were thinking `(^^)' as opposed to `(**)' -- i was thinking the former as opposed to `(^)')
13:25:37 <nand`> :t (^^)
13:25:38 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
13:25:40 <nand`> :t (^)
13:25:41 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
13:25:53 <nand`> :t recip
13:25:54 <lambdabot> forall a. (Fractional a) => a -> a
13:26:09 <ski>   recip x = 1 / x
13:26:10 <hiptobecubic> given the context, i was safe to assume i was referring to (^)
13:26:14 <hiptobecubic> it*
13:26:16 <geekosaur> 3 ways to do powers.  next think you know we'll be perl }:>
13:26:30 <geekosaur> thing
13:26:37 <alexShpilkin> ski: well, maybe... thank you! looks like I'll be playing around with expression trees for a while. I'll say more when I'll figure something out
13:26:41 <hiptobecubic> geekosaur, can also call pow from math.h :)
13:26:52 <kallisti> don't forget exp
13:26:54 <kallisti> > exp 1
13:26:54 <lambdabot>   2.718281828459045
13:26:57 <ski> obviously `(^)' should be in the class `MoufangLoop' (where we have power-associativity) !
13:27:03 <geekosaur> or fiddle with log/exp, yeh
13:27:37 <ski> alexShpilkin : yw :)
13:27:43 <hiptobecubic> > exp(2 * log (x))
13:27:44 <lambdabot>   exp (2 * log x)
13:28:09 <ski> > (exp . (2 * log)) x
13:28:11 <lambdabot>   exp (2 * log x)
13:28:20 <ski> > deriv (exp . (2 * log)) x
13:28:22 <lambdabot>   2 * (1 * recip x) * exp (2 * log x)
13:28:33 <hiptobecubic> @t deriv
13:28:33 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
13:28:36 <hiptobecubic> @type deriv
13:28:38 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
13:28:52 <hiptobecubic> @info deriv
13:28:53 <lambdabot> deriv
13:28:53 <ski>   data Dif a = D a a  -- iirc
13:29:05 <hiptobecubic> just dual numbers?
13:29:08 <kallisti> yep
13:29:11 <djahandarie> For a moment there I thought there was a command called @timebomb
13:29:12 <ski> (Automatic Differentiation via dual numbers)
13:29:22 <nand`> has any attempt been made to unify all of the set-with-dyadic-operator classes? eg. Semigroup, Monoid, Group; by giving them the constraints you'd expect (class Semigroup m => Monoid m where ...)
13:29:46 <ski> @yhjulwwiefzojcbxybbruweejw
13:29:47 <lambdabot> Just 'J'
13:30:01 <hiptobecubic> What the hell is that
13:30:06 <ski> @help yhjulwwiefzojcbxybbruweejw
13:30:07 <lambdabot> V RETURNS!
13:30:18 <nand`> I.. what
13:30:31 <ski> @yhjulwwiefzojcbxybbruweejw
13:30:31 <lambdabot> "\""
13:30:38 <dmwit> Tonight at 11: Inside jokes are incomprehensible to outsiders!
13:30:48 <nand`> :'(
13:31:00 <kallisti> > derivs f = map val . iterate df . f . dVar  in derivs cos x :: [Expr]
13:31:01 <lambdabot>   <no location info>: parse error on input `='
13:31:04 <kallisti> > let derivs f = map val . iterate df . f . dVar  in derivs cos x :: [Expr]
13:31:06 <lambdabot>   [cos x,1 * negate (sin x),1 * (1 * negate (cos x)),1 * (1 * (1 * sin x)),1 ...
13:31:12 <ski> iirc, there was a bug in lambdabot which people found interesting to exploit
13:31:51 <kallisti> > let derivs f = map val . iterate df . f . dVar  in derivs (^^3) x :: [Expr]
13:31:52 <lambdabot>   [x * x * x,(1 * x + x * 1) * x + x * x * 1,(1 * 1 + 1 * 1) * x + (1 * x + x...
13:32:42 <hiptobecubic> I do declare, this package seems to be implemented in a rather inefficient way.
13:32:52 <kallisti> how so?
13:33:25 <dmwit> ?let reallyReduce v = let v' = reduce v in if v' == v then v else reallyReduce v'
13:33:26 <lambdabot>  Defined.
13:33:47 <nand`> :t reduce
13:33:48 <lambdabot> Expr -> Expr
13:33:50 <hiptobecubic> well do you really want a bunch (1 * 1 * 1 * 1 + 1 * 1 * 1 * x) instead of (1 + x) if you are doing some performance conscious number crunching?
13:34:01 <dmwit> > let devins f = map val . iterate (reallyReduce . df) . f . dVar in derivs (^^3) x :: [Expr]
13:34:01 <nand`> > reallyReduce $ (1 * x + x * 1) * x + x * x * 1
13:34:02 <lambdabot>   Not in scope: `derivs'
13:34:02 <lambdabot>   (1 * x + x * 1) * x + x * x * 1
13:34:15 <dmwit> > let derivs f = map val . iterate (reallyReduce . df) . f . dVar in derivs (^^3) x :: [Expr]
13:34:16 <lambdabot>   Couldn't match expected type `Data.Number.Dif.Dif a'
13:34:16 <lambdabot>         against inferr...
13:34:24 <dmwit> oh, right
13:34:26 <ski> `fmap' ?
13:34:41 <dmwit> nand`: =(
13:34:47 <dmwit> nand`: I was hoping for a bit more.
13:34:48 <nand`> > reallyReduce $ 1 * x
13:34:50 <lambdabot>   1 * x
13:34:52 <nand`> ..
13:34:55 <ski> > let derivs f = map val . iterate (fmap reallyReduce . df) . f . dVar in derivs (^^3) x :: [Expr]
13:34:56 <nand`> well there's your problem
13:34:56 <lambdabot>   No instance for (GHC.Base.Functor Data.Number.Dif.Dif)
13:34:56 <lambdabot>    arising from a us...
13:34:59 <ski> :(
13:35:01 <dmwit> nand`: yes
13:35:16 <dmwit> > reallyReduce (1+1+2)
13:35:18 <lambdabot>   1 + 1 + 2
13:35:22 <nand`> > reduce (1+1+2)
13:35:22 <lambdabot>   2 + 2
13:35:27 <dmwit> ...what did I do
13:35:31 <dmwit> > reduce (1*x)
13:35:31 <nand`> > reduce (2+2)
13:35:32 <lambdabot>   4
13:35:32 <lambdabot>   can't find file: L.hs
13:35:41 <dmwit> ack, what!
13:35:44 <geekosaur> mmm, race conditions
13:35:49 <dmwit> > reduce (1*x)
13:35:50 <lambdabot>   1 * x
13:35:53 <ski> > let derivs f = map val . iterate (df) . f . dVar in map reallyReduce (derivs (^^3) x) :: [Expr]
13:35:55 <lambdabot>   [x * x * x,(1 * x + x * 1) * x + x * x * 1,2 * x + (1 * x + x * 1) * 1 + (1...
13:36:05 <dmwit> Okay, well, even if I fix whatever bug I have it still won't work. So I won't try to fix it.
13:36:18 * nand` wonders if the :: [Expr] is really needed there
13:36:26 <kallisti> hiptobecubic: I don't know how you can avoid that using automatic differentiation.
13:36:39 <ski> probably not
13:36:46 <nand`> > reduce (x+x)
13:36:47 <lambdabot>   x + x
13:36:51 <nand`> :(
13:37:01 <ski> > reduce (x - x)
13:37:02 <lambdabot>   x - x
13:37:04 <kallisti> ski: I usually add it on just to be safe, because I have no clue why it complains about it sometimes.
13:37:06 <nand`> you won't be getting 3x² out of it any time soon it seems
13:37:07 <hiptobecubic> kallisti, I don't either. I have never tried to implement it myself.
13:37:35 <ski> kallisti : i usually try in private first, without the type ascription, and only randomly add such if i need it
13:37:50 <kallisti> it essentially implements the chain rule. you'd either need to multiply a bunch of 1's, or explicit check that something produces a 1 when derived. either way it's an overhead.
13:38:33 <ski> kallisti : well, you could statically check once when building the function, instead of every time when the function is applied
13:38:49 <ski> (consider `map (deriv f) ...')
13:38:53 <nand`> @src reduce
13:38:54 <lambdabot> reduce _ 0 = undefined
13:38:54 <lambdabot> reduce x y = (x `quot` d) :% (y `quot` d)
13:38:54 <lambdabot>     where d = gcd x y
13:38:59 <kallisti> hm, true.
13:39:09 <dmwit> nand`: different reduce
13:39:11 <ski> (here "statically" means "before the main argument is given to the function")
13:39:13 <nand`> oh
13:39:14 <kallisti> right
13:39:14 <dmwit> (In fact, where is that coming from?)
13:39:16 * nand` was stumped
13:39:18 <dmwit> ?src reduce
13:39:18 <lambdabot> reduce _ 0 = undefined
13:39:18 <lambdabot> reduce x y = (x `quot` d) :% (y `quot` d)
13:39:19 <lambdabot>     where d = gcd x y
13:39:22 <dmwit> ?index reduce
13:39:23 <lambdabot> bzzt
13:39:42 <dmwit> Hoogle doesn't know about it, either.
13:39:42 <ski> kallisti : for functions which can do significant work when only passed some of their arguments, this can be a good thing to do
13:39:59 <hiptobecubic> @tell lambdabot "sleeeeeeep"
13:39:59 <lambdabot> Nice try ;)
13:40:11 <nand`> dmwit: it might be defined locally
13:40:16 <ski> @karma lambdabot
13:40:17 <lambdabot> lambdabot has a karma of 5
13:40:34 <kallisti> @karma C
13:40:34 <lambdabot> C has a karma of 0
13:40:38 <kallisti> really?
13:40:39 <hiptobecubic> @karma ski
13:40:39 <lambdabot> ski has a karma of 7
13:40:46 <dmwit> nand`: ?src searches a static database
13:40:52 <kallisti> I would think C++ is a pretty common thing to say
13:40:56 <ski> @time lambdabot
13:40:57 <lambdabot> I live on the internet, do you expect me to have a local time?
13:41:07 <nand`> dmwit: where does this come from?
13:41:08 <hiptobecubic> yes?
13:41:12 * geekosaur thinks it's so common lambdabot ignores it
13:41:18 <djahandarie> kallisti, it's specifically ignored
13:41:19 <hiptobecubic> @karma hiptobecubic
13:41:19 <dmwit> nand`: GHC.Real has it, apparently.
13:41:19 <lambdabot> You have a karma of 0
13:41:29 * hiptobecubic sighs
13:41:30 <kallisti> djahandarie: elitists...
13:41:51 <nand`> :t GHC.Real.reduce
13:41:51 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
13:41:54 <geekosaur> neh, the elitist one is what happens if you ++ java
13:42:01 <djahandarie> Either that, or people mention C-- in here enough to balance out the C++ mentions.
13:42:05 <nand`> that type signature makes sense now
13:42:07 <geekosaur> ignoring c for that is just sanity
13:43:32 <dmwit> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Real.html#reduce
13:44:59 <nand`> preflex: karma C
13:44:59 <preflex>  C: 189345
13:45:11 <nand`> djahandarie: apparently not
13:45:15 <djahandarie> preflex, karma djahandarie
13:45:16 <preflex>  djahandarie: 7
13:45:28 <dmwit> preflex: karma C/C
13:45:29 <preflex>  C/C: 6315
13:45:34 <djahandarie> Heh
13:45:39 <djahandarie> I think preflex is in some other channels
13:45:46 <ski> nand` : see <http://code.haskell.org/lambdabot/State/source>
13:45:53 <nand`> he's in #xmonad, #rxvt-unicode and #haskell-blah
13:46:04 <mauke> preflex: karma i
13:46:04 <preflex>  i: 2365
13:46:09 <djahandarie> You sure that's not just your common channel list nand`?
13:46:18 <nand`> djahandarie: possible
13:46:25 <geekosaur> and perl6
13:46:26 <nand`> djahandarie: if he's in other channels; they must be set hidden/secret
13:46:27 <ski> <http://code.haskell.org/lambdabot/State/L.hs> may also be interesting
13:46:29 <geekosaur> #perl6 that is
13:46:35 <nand`> he/she/it
13:46:36 <ski> and <http://code.haskell.org/lambdabot/show/SimpleReflect.hs> for the `Expr' thing
13:46:50 <nand`> (this is from a /whois preflex)
13:46:56 <ski> nand` : conventionally, lambdabot is a "she"
13:47:02 <djahandarie> nand`, I'm fairly sure it only shows common channels by default
13:47:02 <nand`> @src [] mplus
13:47:03 <lambdabot> mplus = (++)
13:47:05 <nand`> interesting
13:47:12 <dmwit> nand`: I don't think so. My /whois for preflex is also short, but contains some very public channels.
13:47:19 <dmwit> (that you didn't mention)
13:47:24 <ski> (or maybe s/conventionally/traditionally/ or s/conventionally/nominally/ ..)
13:47:27 <nand`> djahandarie: depends on the IRCd; normally it shows all channels that are not hidden (or common) as well
13:47:33 <mauke> > 10 + 30+1 + 18 + 2
13:47:34 <lambdabot>   61
13:47:44 <djahandarie> Naturally talking about the IRCd freenode runs :P
13:47:46 <mauke> in theory preflex is in 61 channels across 4 networks
13:48:07 <nand`> 30+1 <- laziness strikes again
13:48:20 <mauke> there's a reason for that
13:48:25 <nand`> elaborate
13:48:26 <dmwit> nand`, djahandarie: My guess is that it is possible for a particular nick to request privacy, and mauke is smart.
13:48:28 <mauke> no :-)
13:48:30 <ski> nand` : depends on whether the user has set flag `+i' or not
13:48:39 <ski> (i have set `-i')
13:48:45 <nand`> ski: I see
13:48:48 <dmwit> ski confirms my hypothesis.
13:49:08 <ski> (`/set usermode -i' in irssi)
13:49:17 <dmwit> Well, half of it; the other half wasn't really a hypothesis. =)
13:49:31 <mauke> AFAIK freenode automatically sets +i on connect
13:49:32 <ski> (or, `/mode -i' if you just want to try it once)
13:49:44 <nand`> dmwit: what is it then; an axiom?
13:49:45 <ski> mauke : yes (but it used to not do that)
13:50:13 <dmwit> call it a lemma
13:50:38 <nand`> I was being humorous, or attempting to
13:51:30 <geekosaur> lemma see ur channels? :p
13:51:31 * ski . o O ( "Well, call me Ishmael." )
13:54:18 <mdmkolbe> Can Haddock do subscripts?  E.g. render @t_0@ as t<sub>0</sub>
13:54:42 <mauke> t₀
13:59:38 <hpaste> “Jonathan Fischoff” pasted “cabal-dev error” at http://hpaste.org/69305
13:59:40 <jfischoff> any ideas on how to fix this ^ cabal-dev error?
14:00:12 <jfischoff> I called: `cabal-dev ghci`
14:02:39 <jfischoff> nevermind
14:02:42 <hhb_> I've been asking for help on a datagram socket question here for the last few days. Thanks for all the help. FYI, I posted it on SO http://stackoverflow.com/questions/10823974/why-does-asynchronous-udp-datagram-haskell-server-have-packet-loss
14:02:46 <ski> geekosaur : yeah, that's why i set mode `-i', to encourage this kind of stalking :)
14:02:54 <ski> (you could set it too, if you think it's a good idea)
14:03:54 <ski> (note that it won't show secret channels, though, unless you're also in that channel, or you're the same freenode identity as the nick you're stalking)
14:09:08 <paradoxe> hii
14:10:17 <ski> hello paradoxe
14:10:28 <paradoxe> how are you ?
14:10:36 * ski is hungry
14:12:21 <tew88> I've just started playing with Haskell (following LYAH.) For a toy project, I need to represent a 30-dimensional vector: what type should I be looking to?
14:12:55 <Botje> Data.Array, maybe.
14:13:13 <nand`> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
14:13:15 * nand` hides
14:13:21 <Botje> nand`: you are a bad person.
14:13:39 <nand`> is that even a valid type?
14:13:59 <Botje> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
14:13:59 <nand`> oh yes; it is
14:14:00 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -
14:14:00 <lambdabot> > z -> t28 -> t29 -> t30 -> t31 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31)
14:14:05 <nand`> it's just Data.Ord that limits the size
14:14:07 <nand`> err
14:14:09 <nand`> Data.Tuple
14:14:53 <nand`> but yeah, tuples would be silly either way since for a vector you really want a homogenous type
14:15:14 <tew88> Data.Array sounds promising, thanks
14:15:16 <zzing> @src fst
14:15:17 <lambdabot> fst (x,_) =  x
14:15:34 <Peaker> it's so (unnecessarily) clumsy, IMO
14:15:36 <tew88> twntynine... :(
14:16:37 <nand`> tew88: that's 29 separators :P
14:23:12 * hackagebot Elm 0.1.2 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.1.2 (EvanCzaplicki)
14:23:23 <nand`> the page on denotational semantics in the Haskell wikibook notes that https://upload.wikimedia.org/wikibooks/en/math/9/f/5/9f555b313e438e5e34cb7b8c6dac83d5.png does not hold; why?
14:23:26 * ksf decides sodium is the best frp library we have right now.
14:23:44 <nand`> I figured they would be of the same “definedness”
14:23:45 <ksf> dodgy sharing semantics I can live with.
14:25:00 <parcs`> ksf: how did you form that decision
14:25:42 <ksf> it's controlled multithreaded, has switch, is fast enough, and has a very nice IO-side interface.
14:26:15 <ksf> sharing isn't so important, If I really do have something expensive to share I can cache it.
14:27:05 <tulinius> nand`: this is why
14:27:14 <hpc> ksf: or give it your own name, and it shares that way
14:27:26 <tulinius> the =[ operator means ((less defined) or equal)
14:27:43 <nand`> oh; not “less defined or equally defined”?
14:27:51 <tulinius> correct.
14:27:54 <nand`> okay
14:27:56 <nand`> thanks
14:28:00 <tulinius> np.
14:28:12 <nand`> also that is a very sad operator
14:28:23 <parcs`> ksf: good points. also isn't the author working on an frp-based iphone game?
14:28:26 <nand`> why not [=
14:28:27 <tulinius> Some dude linked a (english) lecture from a german university that talked about that.
14:28:45 <tulinius> nand`: no idea, we should totally find the unicode symbol for it.
14:28:57 * hpc still doesn't get frp
14:28:58 <nand`> agree; if only so I can add it to my keyboard map
14:29:08 <ksf> seems so. he mentioned a commercial frp library in the announcement, and does ios stuff on github.
14:29:09 <hpc> are there any simple "do this useful thing" examples?
14:29:23 * applicative thinks, "sodium"
14:29:24 <applicative> ?
14:30:06 <ksf> ...and I really do need to limit those framerates. I can make X eat 90% of a core by wiggling the mouse.
14:30:24 <ksf> (while eating 4% of a core to issue the commands)
14:30:35 <dmwit> nand`, tulinius: Where is that graphic used?
14:30:42 <nand`> dmwit: https://en.wikibooks.org/wiki/Haskell/Denotational_semantics
14:30:47 <dmwit> The only place I see it used is in a sentence to the effect "the following is NOT TRUE"
14:31:04 <nand`> tulinius: I did not find it on https://en.wikipedia.org/wiki/Math_symbols
14:31:20 <nand`> though I did find ⊆ which is unfortunately not the same
14:31:21 <dmwit> Oh, I misread tulinius' answer.
14:31:28 <dmwit> Okay, his explanation was correct.
14:31:31 <hpc> applicative: "simple" ;)
14:32:12 <dmwit> shapecatcher suggests ⊑
14:32:22 <dmwit> http://shapecatcher.com/
14:32:50 <nand`> dmwit: fair enough
14:32:54 <hiptobecubic> dmwit, oh neat. it's like detexify
14:33:08 <dmwit> It also suggests "BLACK CHESS ROOK" ♜ =P
14:33:19 <dmwit> hiptobecubic: Yep, it came soon after detexify. =)
14:33:24 <armlesshobo> LMAO
14:33:28 <armlesshobo> dmwit: white for me
14:33:28 <nand`> dmwit: awesome link
14:33:30 <armlesshobo> :P
14:34:06 <tulinius> lets see who can draw the pile of poo symbol.
14:34:36 <nand`> I get “black draughts man” ⛂
14:34:45 <dmwit> ጇ
14:34:51 <nand`> also tamil year sign ௵
14:35:05 <dmwit> ⵓ is actually pretty close to what I drew for "pile of poo"
14:35:06 <hiptobecubic> dmwit, is that a turtle?
14:35:17 <armlesshobo> ▦▦▦▦▦▦▦
14:35:19 <armlesshobo> chex
14:35:45 <dmwit> hiptobecubic: heh; Ethiopic syllable jwa
14:36:01 <hiptobecubic> dmwit, ah of course
14:36:04 <nand`> Keyboard ⌨
14:36:17 <hiptobecubic> nand`, i also got keyboard.... and "pouting cat face"
14:36:42 <hiptobecubic> 😾
14:36:50 <tulinius> the closest i got to poo was hot beverage. hmm.
14:36:51 <nand`> and thus I've stopped reading this article on denotational semantics and started doodling around on shapecatcher.com; all thanks to dmwit
14:36:52 <dmwit> Those crazy Japanese.
14:36:59 <dmwit> haha
14:37:27 <armlesshobo> it didn't get the korean letter ㅎ
14:37:30 <armlesshobo> when i drew it
14:37:41 <dmwit> My font doesn't get that letter, either. =(
14:37:45 <hiptobecubic> they aren't supported it says
14:37:57 <nand`> ⌤ <- up arrowhead between two horizontal bars
14:38:02 <nand`> an excellent source of smileys
14:38:22 <tulinius> who needs more smileys than >:) and =[
14:38:32 <hiptobecubic> ^.^
14:38:33 <nand`> (I was actually going for 大
14:38:42 <nand`> (.).(.)
14:38:44 * nand` runs
14:39:01 <tulinius> or slightly more optimistic: (*)(*)
14:39:08 <nand`> :t (*)(*)
14:39:08 <lambdabot> forall a. (Num a) => (a -> a -> a) -> a -> a -> a
14:39:16 <tulinius> nice save.
14:40:00 <dmwit> > (*)(*)(*) 3 4 5
14:40:01 <lambdabot>   144
14:40:06 <dmwit> logical
14:40:49 <hpc> > (*)(*)(*) 3 4
14:40:50 <lambdabot>   144
14:41:03 <nand`> > (3 * 4) * (3 * 4)
14:41:03 <lambdabot>   144
14:41:39 <tulinius> :t (*)(+)
14:41:40 <lambdabot> forall a. (Num a) => (a -> a -> a) -> a -> a -> a
14:41:47 <nand`> > (*)(+) 3 4
14:41:48 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
14:41:48 <lambdabot>    arising from a use of `...
14:41:53 <nand`> > (*)(+)(*) 3 4
14:41:54 <lambdabot>   84
14:41:55 <applicative> hpc somehow "poodle invasion: click on the poodles to keep them under control" is not giving too much confidence in sodium
14:42:01 <applicative> :)
14:42:12 <hiptobecubic> applicative, was just thinking the same
14:42:14 <nand`> > (3+4) * (3*4)
14:42:15 <lambdabot>   84
14:42:16 <hiptobecubic> I'd like to see it work though
14:42:42 <tulinius> > (*)(+) 1 2 3
14:42:43 <lambdabot>   5
14:42:45 <hiptobecubic> on second thought. what an absolutely *enormous* waste of time that would be...
14:42:46 <alex-hu> How do I read floats of different endianness?  The code in Binary. ... module seems to be only concerned with ints.
14:42:50 <tulinius> > (*)(+) 2 3
14:42:51 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
14:42:51 <lambdabot>    arising from a use of `...
14:42:57 <dmwit> Ah, now I understand how (*)(*) works.
14:43:08 <tulinius> dmwit: care to share? :>
14:43:32 <dmwit> sure
14:43:40 <nand`> (*) needs a num instance for (Num a => a -> a -> a)
14:43:42 <dmwit> (*) goes under lambdas with \bot's instances, right?
14:43:57 <armlesshobo> the left most operator picks the left most two arguments
14:44:05 <armlesshobo> (*) takes 1 and 2
14:44:10 <ksf> poodle needs Data.Bitmap.IO changed to Data.Bitmap.Simple, then it should run.
14:44:15 <armlesshobo> which equals 2
14:44:17 <tulinius> oh
14:44:30 <nand`> hmm
14:44:32 <tulinius> and the right (*) takes (1*2) and 3.
14:44:39 <dmwit> So, (*) f g x y = f x y * g x y
14:44:40 <armlesshobo> the result is the first arg of the (+)
14:44:42 <hpc> applicative: yeah, this is really bugging me now because i could really use FRP for something legit, and all the current examples suck
14:44:44 <applicative> oh, I added Data.Bitmap.Pure
14:45:19 <applicative> hpc, I was feigning to object on behalf of  the poodles, really
14:45:20 <nand`> what I thought was happening is that (*)(+) 1 2 3 was computing (1 2 3) * (2 + 3)
14:45:28 <dmwit> well, ((*) f g x) y = (f x * g x) y = (*) (f x) (g x) y = f x y * g x y
14:45:55 <hpc> applicative: it's a poorly written example
14:46:06 <hpc> no comments on the parts that are interesting for people using it as an example
14:46:25 <hpc> and nothing to say "look here, not at the mountains of GLUT initialization)
14:46:27 <hpc> "
14:47:21 <hiptobecubic> Why does (*) f g x = f x * g x instead of (f (*) g) x?   i thought application was left associative?
14:47:37 <dmwit> hiptobecubic: It does equal (f * g) x.
14:47:46 <jaxtr> ahh it's a wonderful day
14:47:47 <applicative> its awfully complicated for such a simple game but i guess apart from Main it should ultimately be in sodium-opengl or whatever
14:48:07 <dmwit> hiptobecubic: But to reduce (f * g) x, you must look at the definition of (*) for functions.
14:48:13 <dmwit> hiptobecubic: Which is (*) f g x = f x * g x
14:48:20 <hiptobecubic> dmwit, oh... i didn't realize
14:48:24 <nand`> the num instance for functions ignores its argument, right?
14:48:31 <hiptobecubic> functions are an instance of num?
14:48:36 <nand`> hiptobecubic: in lambdabot
14:48:38 <dmwit> In lambdabot, yes. =)
14:48:42 <dmwit> > 1 undefined
14:48:42 <hiptobecubic> oh
14:48:43 <lambdabot>   1
14:48:51 <hiptobecubic> Why ?
14:48:58 <nand`> to confuse people
14:49:00 <dmwit> Because .
14:49:12 <hiptobecubic> Because (.)?
14:49:16 <nand`> http://hackage.haskell.org/packages/archive/NumInstances/1.0/doc/html/src/Data-NumInstances.html
14:49:17 <shachaf> It makes some things work out nicely.
14:49:21 <dmwit> Yes (!).
14:49:41 <nand`> (*) = liftA2 (*)
14:52:08 <nand`> > map ((*2)+1) [1..10]
14:52:08 <lambdabot>   [3,5,7,9,11,13,15,17,19,21]
14:52:41 <strager> Is it possible to have cabal-install build only a specific build target (e.g. just one of three executables)?
14:53:11 <hpc> i think so
14:53:13 * hackagebot regex-pcre 0.94.4 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-pcre-0.94.4 (ChrisKuklewicz)
14:53:15 * hackagebot elm-server 0.1.2 - The Elm language server.  http://hackage.haskell.org/package/elm-server-0.1.2 (EvanCzaplicki)
14:53:18 <hpc> try cabal build --help or cabal install --help
14:53:23 <otters> so I create a server socket with listenOn
14:53:26 <dmwit> You can have a flag and set buildable: false in the other executable blocks.
14:53:27 <otters> and I accept a client
14:53:34 <otters> and I write the string "\4660" to the client
14:53:41 <otters> and the client receives "4"
14:53:56 <otters> why is that?
14:53:58 <hpc> > "\4660"
14:53:59 <lambdabot>   "\4660"
14:54:08 <otters> it's ሴ
14:54:19 <dmwit> otters: because
14:54:19 <hpc> > 0x4660 `mod` 256
14:54:20 <lambdabot>   96
14:54:20 <otters> a random character I chose because it's u+1234
14:54:21 <strager> hpc: Nothing relevant listed there
14:54:28 <strager> dmwit: Preferably I wouldn't need to configure again
14:54:30 <otters> dmwit: what must I do to make it output correctly
14:54:30 <hpc> > chr 96
14:54:31 <dmwit> > ord '\4660' `mod` 256
14:54:31 <lambdabot>   '`'
14:54:32 <lambdabot>   52
14:54:42 <hpc> > chr 52 -- oh
14:54:43 <lambdabot>   '4'
14:54:46 <hpc> well then
14:54:59 <hpc> otters: client needs to be reading unicode
14:55:07 <otters> what's it doing now?
14:55:10 <nand`> otters: encode/decode it properly
14:55:15 <hpc> otters: just the first byte
14:55:15 <dmwit> hpc: No, the sender needs to be sending Unicode.
14:55:25 <hpc> oh, or what dmwit says
14:55:27 <otters> oooh
14:55:30 <hpc> (or more likely, both)
14:55:45 <nand`> > ord '\4660' `div` 256
14:55:46 <lambdabot>   18
14:56:06 <ski> > '\x1234'
14:56:08 <lambdabot>   '\4660'
14:56:09 <otters> oh, THAT's what Data.Text.Encoding is for
14:56:14 <dmwit> otters: Also, if you wanted hex 4660, you need the x.
14:56:32 <dmwit> > ord '\x4660' `mod` 256
14:56:33 <lambdabot>   96
14:56:38 <nand`> he wanted U+1234
14:56:40 <dmwit> > chr (ord '\x4660' `mod` 256)
14:56:42 <lambdabot>   '`'
14:56:57 <hiptobecubic> NumInstances is great
14:57:06 <armlesshobo> > chr (ord '\x4660')
14:57:07 <lambdabot>   '\18016'
14:57:10 <dmwit> Ah, I see, I misinterpreted lambdabot's output because we were both asking for things at the same time.
14:57:27 <dmwit> > '\x4660' -- armlesshobo
14:57:28 <lambdabot>   '\18016'
14:57:37 <dmwit> > chr (ord '\4660' `mod` 256)
14:57:39 <lambdabot>   '4'
14:57:42 <dmwit> phew
14:58:11 <armlesshobo> > chr 48
14:58:12 <lambdabot>   '0'
14:58:14 <armlesshobo> ok cool
15:01:26 <hiptobecubic> > do f <- [1,2,3]: return (f+1) :: [int]
15:01:27 <lambdabot>   <no location info>:
15:01:27 <lambdabot>      The last statement in a 'do' construct must be an ...
15:01:36 <hiptobecubic> > do f <- [1,2,3]; return (f+1) :: [int]
15:01:37 <lambdabot>   Inferred type is less polymorphic than expected
15:01:37 <lambdabot>    Quantified type variable...
15:01:44 <hiptobecubic> > do f <- [1,2,3]; return (f+1) :: [Int]
15:01:44 <lambdabot>   [2,3,4]
15:01:52 <hiptobecubic> What is 'f' in there?
15:02:02 <ski> the numbers `1',`2',`3', individually
15:02:05 <hiptobecubic> some kind of de-listed values?
15:02:09 <nand`> a local variable
15:02:15 <ski> > [f + 1 | f <- [1,2,3]]
15:02:17 <lambdabot>   [2,3,4]
15:02:19 <navaati> is there a way to hide an instance when importing a module ?
15:02:32 <nand`> > [1,2,3] >>= \f -> return (f+1)
15:02:32 <lambdabot>   [2,3,4]
15:02:34 <ski> > [x | f <- [1,2,3] , x <- return f]
15:02:35 <lambdabot>   [1,2,3]
15:02:45 <ski> > [x | f <- [1,2,3] , x <- return (f + 1)]  -- rather
15:02:46 <lambdabot>   [2,3,4]
15:02:54 <hiptobecubic> so there is a loop and f takes each value in sequence
15:03:01 <ski> yes
15:03:11 <ski> this is the (angelic) nondeterminism monad
15:03:11 <nand`> @src [] (>>=)
15:03:11 <lambdabot> xs >>= f     = concatMap f xs
15:03:51 <ski> > ($ 10) $ do x <- (^ 3); y <- (^ 5); return (x + y)
15:03:52 <lambdabot>   101000
15:04:18 <ski> > ((^ 3) + (^ 5)) 10
15:04:19 <lambdabot>   101000
15:04:46 <hiptobecubic> i was aware of >>= in the list monad, but it occurred to me that you could then take things 'out' and bind them to some name using do notation. But it didn't make sense to me because the list has some structure that i would expect to be lost when the listyness is taken away
15:05:03 <applicative> navaati disappeared.  I was preparing to reveal the awful truth
15:05:14 <navaati> i'm here again, and… oh shit
15:05:20 <applicative> haha
15:05:21 <nand`> hiptobecubic: solution: >>= doesn't take the listyness away
15:05:33 <navaati> really ? not even a contrived way ?
15:05:36 <nand`> since the RHS results are re-composed in order
15:06:03 <ski> > do line <- ["abc","def","ghi"]; (do c <- line; ['(',c,')']) `mplus` "\n"
15:06:05 <lambdabot>   "(a)(b)(c)\n(d)(e)(f)\n(g)(h)(i)\n"
15:06:06 <hiptobecubic> I guess the f just represents 'all list values' and you can act on them collectively
15:06:11 <ski> hiptobecubic ^
15:06:13 <nand`> it's disassembled and reassembled, so to say
15:06:57 <ski> > do line <- ["abc","def","ghi"]; "cruft : " `mplus` (do c <- line; ['(',c,')']) `mplus` "\n"
15:06:58 <lambdabot>   "cruft : (a)(b)(c)\ncruft : (d)(e)(f)\ncruft : (g)(h)(i)\n"
15:07:12 <nand`> hiptobecubic: yeah; basically due to the definition of (>>=) = concat .: map; and the way map works already
15:07:39 <ski> > text $ do line <- ["abc","def","ghi"]; "cruft : " `mplus` (do c <- line; ['(',c,')']) `mplus` "\n"
15:07:40 <lambdabot>   cruft : (a)(b)(c)
15:07:40 <lambdabot>  cruft : (d)(e)(f)
15:07:40 <lambdabot>  cruft : (g)(h)(i)
15:07:53 <nand`> :t text
15:07:54 <lambdabot> String -> Doc
15:08:34 <hiptobecubic> > text $ do line <- repeat "abc"; "cruft : " `mplus` (do c <- line; ['(',c,')']) `mplus` "\n"
15:08:38 <lambdabot>   mueval-core: Time limit exceeded
15:08:45 <hiptobecubic> > text $ do line <- replicate 20 "abc"; "cruft : " `mplus` (do c <- line; ['(',c,')']) `mplus` "\n"
15:08:47 <acowley> I have an associated type family something like type T a :: * -> * -> *, but then when I want to define an instance, I'm not allowed to say, type T Foo b = …. even if my kinds match up. I really want to refer to the type parameter by a name, but I'm not allowed to bind it to one.
15:08:48 <lambdabot>   cruft : (a)(b)(c)
15:08:48 <lambdabot>  cruft : (a)(b)(c)
15:08:48 <lambdabot>  cruft : (a)(b)(c)
15:08:48 <lambdabot>  cruft : (a)(b)(c)
15:08:48 <lambdabot> ...
15:10:01 <ski> acowley : hm, iirc it should work -- are you sure the problem isn't in the `...', with a type synonym/family which isn't sufficiently applied ?
15:10:14 <acowley> ski: I'll double check
15:14:15 <nand`> hmm; seeing something like “1 < 2 < 3” is unsettling; what is the type of (<) here?
15:15:39 <hpc> nand`: yeah, you need instance Num Bool to pull that off
15:15:42 <geekosaur> with (Prelude.<) that can only work with a funky Num instance
15:15:44 <geekosaur> that
15:15:52 <nand`> indeed
15:16:01 <nand`> but I was referencing a broader mathematical domain; not just Haskell
15:16:44 <nand`> one could define < to actually be a family of <n operators, where <₂ has two parameters and <₃ three
15:16:45 <djahandarie> With loose notation, that could just be saying "it is true that 2 is between 1 and 3"
15:16:54 <hpaste> acowley pasted “Associated type family arity” at http://hpaste.org/69312
15:17:01 <djahandarie> Similar to the 1 < x < 3 notation.
15:17:06 <acowley> ski: I think that hpaste demonstrates my confusion
15:17:08 <geekosaur> in that case, one way to do it is to have (<) fail or return the larger value, in which case a chain of x < y < z ... can do something sane
15:17:17 <nand`> and 1 <₃ 2 <₃ 3 being sugar for (<₃') 1 2 3
15:17:20 <ski> acowley : hm, if `T' is declared like `type T a :: * -> *' in the class, try changing it to `type T a b :: *' (where `b' is an unused variable)
15:17:29 <hpc> nand`: i think that would take similar nincompoopery to that which led to (x, y, z) syntax
15:17:36 <ski> > inRange (1,3) 2
15:17:38 <lambdabot>   True
15:18:02 <nand`> geekosaur: yeah; that could work
15:18:13 <acowley> ski: Yes, but I don't understand why I need to do that
15:18:17 <ski> acowley : yes, change it to `Type T1 a b :: * -> *'
15:18:33 <acowley> ski: I feel like the kind annotation on the type family should be equivalent to naming that positional argument
15:18:42 <applicative> navaati: here's a typical discussion, see what ehird says http://stackoverflow.com/questions/8728596/explicitly-import-instances
15:18:47 <ski> acowley : i'm not sure either (it seems needless to forbid giving more parameters than needeed, in the definition)
15:18:51 <acowley> ski: Right, that what I was trying to demonstrate with my C2 class
15:18:57 <ski> acowley : you could ask about it on the mailing list
15:19:01 <Peaker> > inRange (1,3) 3
15:19:03 <lambdabot>   True
15:19:16 <geekosaur> another way is for < to be polymorphic such that its result type is a product type that passes on the larger value, and parameters can be either numeric or the same product type
15:19:16 <Peaker> > (inRange . second (-1)) (1,3) 3
15:19:21 <lambdabot>   mueval-core: Time limit exceeded
15:19:23 <nand`> geekosaur: 3 < 2 < 4  the (2 < 4) succeeds and returns 4, and 3 < 4 is also true but clearly 3 < 2 < 4 is not
15:19:23 <Peaker> > (inRange . second (subtract 1)) (1,3) 3
15:19:27 <lambdabot>   mueval-core: Time limit exceeded
15:19:32 <djahandarie> > 3
15:19:34 <lambdabot>   3
15:19:37 <geekosaur> the first one I mentioned is used by Icon, fwiw
15:20:01 <Peaker> > (inRange . second (subtract 1)) (1,3) 3
15:20:03 <lambdabot>   False
15:20:14 * geekosaur does not recall the exact rules used by icon, actually, and book is buried somewhere unreachable
15:20:32 * ski thinks when one writes `a < b = c =< d' in math, that's not really a proposition, but a proof
15:20:58 <ski> (a proof that `a < d', in this case)
15:22:02 <nand`> how about 1 < 2 ∧ 2 < 3
15:22:20 <nand`> (for some reason that doesn't render correctly in my terminal, it's supposed to be logical conjunction)
15:22:32 <ski> (or i suppose, it's simultaneously a proof of : `a < b',`b = c',`c =< d',`a < c',`b =< d',`a < d', under the assumptions `a < b',`b = c',`c =< d' -- but primarily, it's a proof of `a < d')
15:22:50 <ski> nand` : yes, that's the usual explanation
15:23:31 <ski> (actually, skip the "under the assumptions ..." bit, it doesn't fit)
15:24:27 <ski> so, if you're assuming `a < b =< c', you're really assuming all of `a < b',`b =< c',`a < c', but the last one automatically follows from the two others, so you may omit that one
15:33:00 <EvanR> is there a functor instance for pairs
15:33:15 <hpc> > succ <$> (1, 15)
15:33:16 <lambdabot>   (1,16)
15:33:17 <hpc> yes
15:33:48 <hpc> it's somewhere hard to find though
15:33:51 <EvanR> > chr <$> (1, 15)
15:33:52 <lambdabot>   (1,'\SI')
15:33:54 <avpx> That's strange, I'd expect to have seen (2,16)
15:34:11 <avpx> I guess the fmap just applies to the last element of the pair
15:34:11 <hpc> avpx: follow the types
15:34:13 <nand`> > succ <$> ("hello", 15)
15:34:14 <lambdabot>   ("hello",16)
15:34:17 <EvanR> avpx: yeah but what about succ <$> ('c',15)
15:34:19 <hpc> :t fmap
15:34:21 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:35:02 <nand`> avpx: that would only be possible with, say, a newtype Pair a = (a,a)
15:35:18 <avpx> I suppose so
15:35:19 <nand`> = Pair (a,a) even
15:35:44 <navaati> mm_freak: ping
15:35:45 <EvanR> Two a = Two a a
15:35:49 <EvanR> data
15:35:55 <EvanR> or newtype
15:36:17 <EvanR> should exist!
15:36:43 <navaati> "newtype Two a = Two a a" is impossible : newtypes have only one field
15:41:37 <mm_freak> navaati: pong
15:41:59 <mm_freak> looking at how Category is defined wouldn't Morphism be a more appropriate name?
15:42:59 <mm_freak> id :: Morphism a a
15:43:02 <navaati> (+1, the Category class naming is very confusing)
15:43:09 <mm_freak> uhm
15:43:23 <mm_freak> id :: Morphism (>~) => a >~ a
15:43:52 <mm_freak> hmm…  actually no
15:44:10 <navaati> your MonadClock instance for WWithDT in netwire cause trouble
15:44:33 <mm_freak> navaati: WWithDT is a class itself…  what exactly do you mean?
15:44:54 <mm_freak> there is only one MonadClock instance, namely for IO
15:45:14 <navaati> this one "(AdditiveGroup t, MonadClock t m) => WWithDT t (Kleisli m)"
15:45:29 <mm_freak> what's the trouble?
15:45:37 <jfischoff> Would it be possible to replace the STG machine with a machine that supported lazy incremental computing?
15:46:01 <mm_freak> jfischoff: the STG machine basically /is/ lazy incremental computing…  could you elaborate?
15:46:35 <navaati> it makes it very hard to implement a simple WWithDT instance for "(MonadReader (DTime t) m) => WWithDT t (Kleisli m)" (with DTime being a simple newtype)
15:47:11 <mm_freak> navaati: yes, netwire works with absolute time…  to use time deltas you have to introduce a frame of reference
15:47:19 <navaati> wich is quite common when you don't want to be in the IO monad and you don't have access to absolute time
15:47:30 <jfischoff> mm_freak: My understanding is that with incremental computing with your inputs change you only recompute the dependents functions. STG just has sharing, but won't bind functions to inputs that get re-fired. Atleast that is my understanding
15:47:30 <navaati> -_-
15:48:20 <mm_freak> navaati: while most AFRP libraries use time deltas, i have chosen to have time as a feature and figured that time deltas were very hard to implement as a generic concept
15:48:42 <navaati> in the current situation i have to make (ReaderT (Time t)) a MonadClock instance, and add dt to finally see them substracted… that feels silly
15:49:46 <mm_freak> navaati: yes, that's true…  if you have a solution, i'd be happy to implement it =)
15:49:56 <mm_freak> requirement:  time must be an addon
15:51:24 <navaati> well, i have been able to make an instance " (Monad m) ⇒ WWithDT t (Kleisli (ReaderT (DTime t) m))" by enabling OverlappingInstance, but it's a bit ugly
15:51:52 <mm_freak> jfischoff: that doesn't really make sense…  the spreadsheet metaphor doesn't work well for functional programs, because spreadsheets change
15:53:12 <mm_freak> navaati: i see what you mean now
15:53:18 * hackagebot elm-yesod 0.1 - The Elm language Yesod compatibility module.  http://hackage.haskell.org/package/elm-yesod-0.1 (VincentAmbo)
15:53:51 <mm_freak> navaati: i'm working on a new major version of netwire that will handle most of this very differently
15:53:56 <navaati> oh, ok
15:54:12 <mm_freak> in particular i have decided to get rid of the data family again
15:54:15 <navaati> so the OverlappingInstances stuff will be enough atm, then
15:54:31 <mm_freak> yeah, just go with that one for now
15:55:00 <mm_freak> the new wire type is slightly different and i'm trying to bring time deltas back
15:55:19 <mm_freak> the main problem with time deltas was the impossibility to write a clean MonadClock instance for IO
15:55:35 <mm_freak> it would require a global variable
15:56:04 <zezikaro> what's the best way to remove a value from a tree?
15:56:13 <zezikaro> recreate the entire tree?
15:56:20 <mm_freak> zezikaro: yes
15:56:25 <avpx> zezikaro: Well, data structures in Haskell are immutable
15:56:26 <zezikaro> that's costly though
15:56:31 <mm_freak> zezikaro: no
15:56:35 <zezikaro> no?
15:56:37 <avpx> zezikaro: Not necessarily, it's copy-on-write
15:56:42 <zezikaro> cow
15:56:52 <mm_freak> zezikaro: haskell uses sharing, so most of the tree is just reused
15:57:17 <zezikaro> it shares immutable objects
15:57:18 <zezikaro> ?
15:57:33 <mm_freak> if you forget the old tree afterwards the complexity is really just the traversal to the deleted element and the space complexity is -1
15:57:38 <mm_freak> sure
15:58:18 <mm_freak> that's why trees are so fast and immutable arrays are so slow =)
16:00:27 <zezikaro> ?
16:00:33 <zezikaro> okay thanks
16:02:37 <zezikaro> > forM_ print [1..5]
16:02:39 <lambdabot>   Couldn't match expected type `[a]'
16:02:39 <lambdabot>         against inferred type `a1 -> GHC...
16:02:42 <zezikaro> =[
16:02:44 <zezikaro> why do i suck
16:02:50 <mm_freak> zezikaro: mapM_
16:02:56 <mm_freak> forM_ = flip mapM_
16:03:00 <`Jake`> setting up vim for haskell is more fun than I thought it would be
16:03:11 <zezikaro> :t flip
16:03:12 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
16:03:20 <zezikaro> i'm confused
16:03:21 <zezikaro> but thank you
16:03:25 <mm_freak> that's caleskell =)
16:03:41 <mm_freak> the real type of flip is:  flip :: (a -> b -> c) -> (b -> a -> c)
16:04:00 <mm_freak> > (-) 3 5
16:04:01 <lambdabot>   -2
16:04:03 <mm_freak> > flip (-) 3 5
16:04:05 <nand`> `Jake`: vim had Haskell syntax highlighting out of the box for me; the rest was just setting up tabs as 2 spaces. Don't know what else you'd need :P
16:04:05 <lambdabot>   2
16:04:14 <zezikaro> > mapM_ print [1..5]
16:04:16 <lambdabot>   <IO ()>
16:04:27 <nand`> :t Prelude.flip
16:04:27 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
16:04:39 <mm_freak> zezikaro: and yes, lambdabot won't execute your IO actions =)
16:04:40 <`Jake`> nand`: well, I just added automatic compiling and running on f5 and f6, its a little bit faster that way
16:04:40 <Peaker> Caleskell is anti-pedagogical
16:04:54 <Peaker> lambdabot is supposed to help people
16:04:58 <mm_freak> yes, caleskell should be removed
16:05:37 <navaati> :t flip (Maybe (toUpper))
16:05:38 <lambdabot> Not in scope: data constructor `Maybe'
16:05:58 <navaati> :t flip (Just (toUpper)) -- ouch, i'm tired -_-
16:05:59 <lambdabot> Char -> Maybe Char
16:06:07 <navaati> :t flip (Just (toUpper)) 'a'
16:06:08 <lambdabot> Maybe Char
16:06:13 <navaati> flip (Just (toUpper)) 'a'
16:06:23 <navaati> > flip (Just (toUpper)) 'a'
16:06:24 <lambdabot>   Just 'A'
16:06:35 <`Jake`> nand`: And I have found a little function for a module header
16:08:03 <navaati> :t \f a -> fmap ($ a) f
16:08:04 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
16:09:30 <nand`> something I've been wondering about; when mixing qualified and non-qualified imports I like to write them like “import           Foo” so the module names all align
16:09:39 <nand`> does anybody else do this / is it bad?
16:10:43 <jfischoff> hand`: you might like https://github.com/jaspervdj/stylish-haskell/blob/master/README.markdown
16:11:10 <jfischoff> s /hand`/nand`
16:11:24 <nand`> oh nice
16:11:29 <Peaker> nand`, 1) Don't import Foo without () when unqualified   2) these spaces are pretty common
16:11:56 <zezikaro> > repeat 5 '.'
16:11:57 <Peaker> I hate that import syntax encourages these fragile open imports
16:11:58 <lambdabot>   Couldn't match expected type `GHC.Types.Char -> t'
16:11:58 <lambdabot>         against inferred...
16:12:03 <nand`> Peaker: I already do 1 most of the time
16:12:11 <Peaker> nand`, it's terrible :)
16:12:12 <zezikaro> :t repeat
16:12:13 <lambdabot> forall a. a -> [a]
16:12:25 <nand`> but sometimes I import something that I need quite a number of functions from (too many to bother listing) but none of them conflict
16:12:26 <zezikaro> o.O
16:12:43 <Peaker> nand`, none of them conflict in the current version
16:12:49 <Peaker> nand`, why not use qualified then?
16:12:57 <zezikaro> > take 5 (repeat '.')
16:12:58 <lambdabot>   "....."
16:13:04 <zezikaro> is there a better way to do that
16:13:30 <zezikaro> > map (const '.') 5
16:13:31 <lambdabot>   No instance for (GHC.Num.Num [a])
16:13:31 <lambdabot>    arising from the literal `5' at <inter...
16:13:37 <zezikaro> > map ('.') 5
16:13:39 <lambdabot>   Couldn't match expected type `a -> b'
16:13:39 <lambdabot>         against inferred type `GHC.Ty...
16:13:46 <Peaker> nand`, I don't have any single import like that in my relatively large project (~6700 lines)
16:13:49 <zezikaro> oh god why do i suck so much
16:14:00 <mauke> zezikaro: hoogle is your friend
16:14:02 <nand`> Peaker: if I “import qualified Foo.Bar”; I'll have to reference all functions using “Foo.Bar.barBaz”, won't I?
16:14:06 <Peaker> zezikaro, take it easy, Haskell is hard at first :)
16:14:21 <Peaker> nand`, then use: import qualified Foo.Bar as B
16:14:29 <Peaker> nand`, B.baz
16:14:36 <nand`> > replicate 5 '.' -- zezikaro
16:14:37 <lambdabot>   "....."
16:14:45 <Peaker> nand`, if you design-for-qualified, you won't have "bar" in each name in the module "Bar"
16:14:54 <Peaker> Bar.baz instead of barBaz
16:15:26 <nand`> Peaker: take Control.Applicative for an example of something I often import “raw”; since I want stuff like <$> and <*> and liftA2 without having to list them all
16:15:59 <Peaker> nand`, Control.Applicative is somewhat OK because it is almost Prelude, but I do list the (4-5 at most) I use from there
16:16:02 <nand`> the “barBaz” thing was a fluke; I just picked a name at random
16:16:24 <Peaker> import Control.Applicative ((<$>), (<*>), Applicative(..))
16:16:29 <Peaker> not that bad
16:16:41 <nand`> another thing I don't import qualified are modules that only contain types for use in my own project; eg import FooProject.Types
16:16:42 <Peaker> nand`, you can also use -ddump-minimal-imports
16:16:47 <zezikaro> nand` thanks
16:17:40 <nand`> hmm, stylish-haskell doesn't have a package in my distro's repository and it's not on hackage either :<
16:17:46 <Peaker> nand`, hmm.. I don't like a "Types" module most of the time... types go to the module that implements their concept
16:18:11 <nand`> Peaker: only problem I have with that is recursive dependencies
16:18:25 <byorgey> Peaker: yeah, often a "Types" module is to avoid circular imports
16:18:46 <nand`> that's actually the only reason I ever use a “Types” module - for types which would otherwise be circular
16:19:53 <hpc> an .hs-boot by any other name, but at least it's a nicer name ;)
16:20:17 <nand`> I wonder if stylish-haskell also sorts and groups imports
16:20:34 <nand`> oh; it at least doesn't group them
16:20:51 <nand`> but it appears to sort blocks of imports
16:21:16 <Peaker> nand`, byorgey sometimes you can add a type param
16:21:32 <Peaker> nand`, I just use "sort-lines" on my imports in emacs
16:21:44 <adimit> What's the difference between a TMVar and a TVar?
16:22:31 <Peaker> like MVar vs. IORef, probably
16:24:41 <adimit> yeah, I guess the put operation on TMVar blocks on full mvars, though I'm not quite sure why I'd need that in an STM context.
16:25:30 <mauke> because that's what MVars do
16:25:48 <Peaker> I guess stm threads want to wait for each other?
16:25:54 <Peaker> mvars are nice
16:26:03 <adimit> ah, ok. thanks!
16:26:14 <Peaker> though I guess tmvars are just as dead-lockable as mvars?
16:26:18 <hpc> i think you would use it when you know you would get conflict
16:26:34 <Peaker> or maybe it's a transactional fail when it blocks?
16:26:41 <Peaker> so you can have orElse?
16:26:42 <hpc> and waiting is faster than the transaction fail
16:26:49 <mauke> Peaker: that would be my expectation
16:27:17 <adimit> from the docs: putMvar will retry when the TMVar is currently full.
16:27:25 <adimit> so it's not simply blocking/waiting, but retrying.
16:29:09 <bitonic> adimit: putMvar will wait for the var to be empty, fill it and return
16:30:10 <adimit> bitonic: I know that :-) I was just wondering out alound why that would be useful within  STM. But I think that's clear now.
16:30:45 <bitonic> adimit: so we're is the retrying?
16:31:17 <adimit> bitonic: it's not putMVar, it's putTMVar, and blocking is implemented in STM.TMVar as retry.
16:31:33 <adimit> bitonic: http://hackage.haskell.org/packages/archive/stm/2.3/doc/html/Control-Concurrent-STM-TMVar.html#v:putTMVar
16:31:57 <bitonic> adimit: right, I misunderstood what you were referring to
16:43:20 <zezikaro> Hi could anyone help me with my 'prettyTree' function please
16:43:20 <zezikaro> http://codepad.org/7aRVMqJU
16:43:34 <zezikaro> I need to reduce duplicated code
16:43:41 <zezikaro> and woah those indents are huge
16:43:50 <zezikaro> visually they're not that huge in notepad++ ..
16:44:40 <monochrom> that is what you get for using tabs
16:45:08 <zezikaro> tab is easier than spaces
16:45:22 <nand`> disagree
16:45:23 <monochrom> to be precise, for allowing your editor to insert tabs
16:45:39 <zezikaro> i changed it to insert spaces instead of tabs
16:45:43 <zezikaro> it didn't really make a difference
16:45:50 <krey_> hi, can someone help me figure out join :: (Coroutine i (Coroutine i a)) -> (Coroutine i a), where Coroutine i o = Return o | Coroutine (i -> (o, Coroutine i o))? this *is* a monad, right?
16:46:11 <monochrom> well, sure, I don't know, but pastebins don't lie. the pastebin clearly shows you have tabs
16:46:33 <nand`> iirc flipping that switch in Notepad++ won't change anything until you actually re-indent every line
16:47:08 <zezikaro> i'll leave it for now
16:47:10 <monochrom> oh, yeah, changing settings affect future edits only
16:47:13 <nand`> I recommend s/\t/  /g
16:47:26 <zezikaro> could you help me reduce my code please :)
16:47:33 <mm_freak> zezikaro: unlike most other languages in haskell it's common to have nonuniform indentation margins
16:47:41 <mm_freak> so i recommend spaces, too
16:48:02 <nand`> what's the most common? 4 or 2?
16:48:08 <monochrom> 3.99999
16:48:20 <zezikaro> o.O
16:48:22 <nand`> as long as it isn't 3.14159
16:48:40 <nand`> (round tabs?)
16:48:57 <mm_freak> the average for me is somewhere between 3 and 10
16:49:17 <nand`> I wonder in how much of a minority I'm placing myself by using 2 spaces
16:49:28 <mm_freak> 4 spaces after 'do', 'then' and 'else', 2 spaces after 'if' and 'of'
16:49:32 <mm_freak> and 0 after 'where'
16:49:52 <c_wraith> 37 spaces after a let
16:49:58 <mm_freak> hehe
16:50:15 <mm_freak> up to 50 spaces after a record-opening '{'
16:50:47 <monochrom> to be fair, using tabs is your business, and I have no right to object. (and I haven't objected.) I was just saying, if paste looks different from editor, that's what you get for tabs, and the paste is not lying, the editor is. and there is also another caveat you'll run into...
16:51:09 <nand`> GHC considers tabs to be 8 spaces right?
16:51:40 <monochrom> ghc sees code the same way pastebin sees it, not the way your editor sees it. you will easily get indentation errors for what seems right in your editor. editor lies. just remember that.
16:51:47 <zezikaro> why argue over tab spaces xD
16:52:02 <nand`> because Haskell is whitespace sensitive; often verily so
16:52:13 <monochrom> and no, I am not arguing. I am telling you what problems you'll run into. it's really your call.
16:52:20 <nand`> a few spaces of indentation more or less can change the meaning of some nested block structures
16:53:09 <monochrom> and yeah, maybe not errors but gross errorless misinterpretation of your code
16:53:59 <zezikaro> how can i reduce the duplication?
16:57:17 <monochrom> I don't think prettyTree contains much redundancy. maybe you could factor out "indent+1".
16:57:43 <zezikaro> there's a duplication in how the 'name' is printed out
16:57:54 <zezikaro> also i'm exposing 'Int -> Int' as in, indent and child number
16:57:57 <zezikaro> for no reason
16:58:01 <zezikaro> is there nothing i can do about that
16:58:09 * snhmib uses 2 spaces unless he wants to align something neatly
16:58:20 <zezikaro> because atm I need to call it with prettyTree tree 0 0
16:58:25 <zezikaro> which is kinda silly
16:58:44 <zezikaro> so i know there's stuff wrong with it, but i'm not sure how it should be fixed
16:58:45 <monochrom> oh you mean program behaviour? well then I am not sure what behaviour you desire
16:58:48 <zezikaro> because i don't know haskell well
16:58:58 <zezikaro> s/well/at all/
16:59:01 <`Jake`> Is there a certain reason for he fact that some GHC source files are .hs files and some are literate files?
16:59:19 <`Jake`> seems to be inconsistent
17:00:21 <`Jake`> *awkward silence*
17:00:33 <adimit> `Jake`: that's actually rather typical if a project contains some/a lot of research work.
17:00:59 <hpaste> nand` pasted “Tree prettyPrint” at http://hpaste.org/69314
17:01:13 <adimit> not every file *needs* that much documentation, and it's easier to write plain .hs. But some files need so much documentation, that you'd write them in .lhs. It's a matter of convenience.
17:01:24 <bitonic> `Jake`: yeah the GHC codebase can be a mess
17:01:37 <`Jake`> ok... I see
17:01:42 <adimit> also, what bitonic said. GHC is super-old.
17:01:56 <bitonic> adimit: there are .lhs files with very few comments
17:02:23 <hpaste> nand` annotated “Tree prettyPrint” with “Tree prettyPrint (annotation)” at http://hpaste.org/69314#a69315
17:02:29 <bitonic> both in GHC itself and in the base libs
17:02:29 <nand`> zezikaro: ^
17:02:33 <nand`> is this relevant?
17:03:11 <`Jake`> oh, ghc.list has comments which are not part of the code but begin with "--", that's interesting
17:03:57 <navaati> @src (<$)
17:03:57 <lambdabot> (<$) = (<$>) . const
17:04:03 <zezikaro> yes thank you
17:04:10 <zezikaro> i don't get it, but thanks
17:06:36 <navaati> mm_freak: do you think a glue-code module between netwire and gloss should be under Graphics.Gloss or Control.Wire namespace ?
17:09:37 <mm_freak> navaati: somewhere below Graphics
17:10:27 <nand`> Graphics.Gloss.Wire?
17:10:34 <navaati> 'k
17:10:57 <mm_freak> perhaps even Graphics.Wire
17:11:33 <mm_freak> because if you want to be below .Gloss a more appropriate name would be Graphics.Gloss.NetWire
17:12:00 <navaati> it'll be Graphics.Gloss.Wire.Pure.Game, then, since there is already Graphics.Gloss.Interface.{Pure,IO}.{Game,Simulate,Animate}
17:12:28 <navaati> ah, ok, let's s/Wire/NetWire/
17:12:52 <nand`> I wonder how many ax-crazy Haskellers would chase me out of the room for thinking about module aliases; ie Control.Wire.Gloss = Graphics.Gloss.Wire
17:13:25 * hackagebot hmatrix-gsl-stats 0.1.2.12 - GSL Statistics interface  http://hackage.haskell.org/package/hmatrix-gsl-stats-0.1.2.12 (VivianMcPhail)
17:13:28 <infinity0> lambdabot: help
17:14:15 <SplinterOfChaos> Hi, i'm importing Data.List.Split for splitAt, but when i write Data.List.Split (splitAt), ghc tells me splitAt isn't exported. Can anyone explain that?
17:14:22 <navaati> again : netwire-gloss or gloss-netwire for the package name… eh ><
17:14:30 <mauke> @index splitAt
17:14:31 <lambdabot> Data.List, Prelude
17:14:41 <mauke> SplinterOfChaos: splitAt isn't in Data.List.Split
17:14:43 <navaati> sometimes a tree is not the right data structure…
17:14:51 <nand`> there's also net-glosswire and glossnet-wire
17:16:03 <nand`> speaking of which; there's one thing I've always wondered
17:16:14 <nand`> what exactly *is* a zygohistomorphic prepromorphism?
17:16:27 <SplinterOfChaos> mauke: Huh... Never mind. I thought when i took the import out it produced an error, but it doesnt.
17:16:29 <mauke> http://www.haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms
17:16:32 <zezikaro> i have never heard of those words
17:16:32 <zezikaro> ever
17:17:12 <nand`> I have a feeling that by reading through the code snippet provided I ended up knowing *less* than I did before
17:17:29 <geekosaur> neither did anyone else before that; it's more a "looky what I can do!" than something of practical use
17:18:00 <nand`> the thing I'm wondering though; is it just a joke / gibberish name or do the concepts involved actually exist?
17:18:24 <geekosaur> the concepts exist, as a sort of theoretical toy
17:18:27 * hackagebot hmatrix-repa 0.1.2 - Adaptors for interoperability between hmatrix and repa  http://hackage.haskell.org/package/hmatrix-repa-0.1.2 (VivianMcPhail)
17:18:50 <RenJuan> it's funny as hell
17:18:55 <geekosaur> you could probably deconstruct the name with sufficient application of Greek
17:19:17 <RenJuan> what it is
17:19:39 <RenJuan> is some valid but simple shit that can be given comic names
17:19:57 <infinity0> heh, ghci is using about 3GB ram to display :type fmap^36
17:20:20 <monochrom> hahaha
17:20:21 <infinity0> (did it for teh lulz)
17:20:54 <nand`> infinity0: what am I supposed to be seeing? fmap^36   :: (Functor f, Num ((a -> b) -> f a -> f b)) =>      (a -> b) -> f a -> f b
17:21:24 <infinity0> ah i didn't know ^ was an actual thing. i meant fmap 36 times
17:21:29 <nand`> oh
17:21:57 <infinity0> it's printed :: (Functor but is now stuck
17:22:05 <adimit> the sound of a hundred nerds typing fmap fmap fmap fmap into their interpreters.
17:23:46 <nand`> I still get a type for 35 “fmap”s
17:23:53 <nand`> and it uses about 50% of my memory in the process..
17:24:02 <nand`> but for 36 it skyrockets to 80% when I killed it
17:24:19 <nand`> adimit: nay; intercalate " " $ replicate 36 "fmap"
17:24:29 <parcs`> i think type checking fmap^n takes like 2^n memory
17:24:59 * adimit hands in his nerd-card.
17:25:26 <infinity0> mine gets stuck with 30 but is ok with 24
17:26:14 <nand`> success
17:26:38 <nand`> the type of fmap^36 is in fact   :: (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
17:26:58 <infinity0> wat
17:27:10 <illissius> how to tell haskeller from normal person: where normal person writes fap fap fap fap fap, haskeller writes fmap fmap fmap fmap fmap
17:27:15 <adimit> is "fmap fmap fmap" the Haskell nerd's version of an onomatopoetic euphemism for mental masturbation?
17:27:26 <adimit> illissius: i see we had the same idea.
17:27:32 <illissius> jynx :|
17:28:01 <illissius> that's a word I haven't seen before though
17:28:05 <parcs`> yeah, every fmap^(8+4n) has the same type
17:28:27 * hackagebot hstatistics 0.2.4 - Statistics  http://hackage.haskell.org/package/hstatistics-0.2.4 (VivianMcPhail)
17:28:37 <illissius> and now I know what it means!
17:29:14 <parcs`> :t fmap fmap fmap fmap fmap fmap fmap fmap -- fmap^8
17:29:15 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
17:29:43 <`Jake`> :t fmap
17:29:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:30:03 <infinity0> parcs`, nand`: so, i get ** => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b)) every 4, but the bit before the => increases as i add fmaps
17:30:42 <parcs`> infinity0: i don't understand
17:30:49 <parcs`> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap -- fmap^12
17:30:50 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
17:30:58 <monochrom> yes, type inference is as hard as unification, which is exponential time
17:31:25 <infinity0> http://pastebin.com/fKXCHke9
17:31:25 <monochrom> I think exponential memory too but not sure
17:31:31 <mauke> The paste fKXCHke9 has been copied to http://hpaste.org/69316
17:31:55 <infinity0> that's 4, 8, 12
17:31:56 <magicman> infinity0: In ghci, do :m + Control.Monad.Instances, then you get instance Functor ((->) a), that should get rid of a lot of those extra constraints.
17:32:09 <parcs`> oh
17:32:28 <parcs`> usually you import Control.Applicative which exports C.M.I
17:32:28 <nand`> infinity0: oh wow
17:32:48 <magicman> Neat! Didn't know that, thanks :)
17:32:49 <nand`> I actually just import Cale
17:33:07 <infinity0> ah i see, thanks guys
17:33:10 <infinity0> what does that do exactly?
17:33:17 <nand`> (my .ghci is pretty much like lambdabot's prelude)
17:33:50 <infinity0> import Control.Applicative didn't work for me, but :m did
17:36:22 <illissius> infinity0: right, import was added (to ghci) in 7.4 or maybe 7.2
17:38:07 <infinity0> what does ((->) a) mean?
17:38:25 <nand`> a function from a to ...
17:38:30 <geekosaur> a function which takes a single parameter.  (reclal that that means all functions...)
17:38:59 <infinity0> oh
17:39:00 <magicman> ((->) a) is like (a -> b), but without the b.
17:39:19 <nand`> ((->) a) would be (a ->) if you could section the (->) type like that
17:39:26 <magicman> Like Maybe is Maybe a without the a.
17:39:41 * magicman fails at words.
17:39:51 <infinity0> i see
17:39:59 <infinity0> ah ok that makes sense
17:40:14 <nand`> ((->) a) = λb. a -> b
17:40:16 <nand`> :)
17:40:33 <infinity0> but is that just a compiler trick to make it look consistent with everything else
17:40:50 <nand`> it's valid haskell, if that's what you're asking
17:41:18 <nand`> so by no means a “trick”; just like ((+) 1 2) is valid Haskell for (1 + 2)
17:42:32 <infinity0> i mean, is "(->)" and "Maybe" the same sort of "object" to the compiler
17:42:52 <monochrom> actually yes, though with different arities
17:43:03 <monochrom> "type constructors"
17:43:14 <infinity0> ah ok cool
17:43:28 <infinity0> ah, i can write :type (->) Int Int and that works
17:43:43 <geekosaur> :k (->)
17:43:44 <lambdabot> ?? -> ? -> *
17:43:50 <geekosaur> although that leaks some evil ghc internals
17:43:59 <cyto> @help
17:43:59 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:44:03 <nand`> (->) is no more special than say “Maybe” at the type level; but a value of type a -> b does have some unique properties as far as I can tell
17:44:27 <cyto> @pl \x -> (x, x)
17:44:28 <lambdabot> join (,)
17:48:44 <infinity0> oh, one more thing, why isn't C.M.I imported by default?
17:49:02 <infinity0> if Functor is already in Prelude, why not its known instances?
17:49:29 <infinity0> or, fmap rather
17:51:12 <navaati> mm_freak: code drop : https://github.com/navaati/gloss-netwire
17:51:30 <navaati> feel free to upload on hackage (i don't have an account)
17:54:13 <mm_freak> navaati: that would be wasteful…  in the near future there will be a new major version of netwire that will be incompatible
17:54:19 <ski> infinity0 : btw, on #haskell, we (by which i mean, i) commonly pretend there's an `TypeOperatorSections' extension, so that we can type `(rho ->)' and `(omega,)' instead of `(->) rho' and `(,) omega' (requiring `TupleSections' as well, for the latter one)
17:54:24 <navaati> ah, yeah, right
17:54:27 <navaati> i'll wait, then
17:54:41 <navaati> btw, "near future" = when ?
17:58:30 * hackagebot hsignal 0.2.4 - Signal processing and EEG data analysis  http://hackage.haskell.org/package/hsignal-0.2.4 (VivianMcPhail)
18:00:10 <otters> What does hFlush do on a Handle that is not buffered?
18:00:20 <nand`> isn't -XTupleSections on by default in GHC 7.4.1? At least it seems to be in GHCi
18:00:23 <otters> Because it *looks* like it waits for more data before returning
18:03:18 <otters> wait, no, not hFlush, hClose
18:03:38 <otters> hClose on an unbuffered Handle, which doesn't return until data is available on the Handle
18:03:43 <otters> what's up with that
18:19:03 <otters> What would cause hIsClosed to block until data is available on the socket?
18:21:49 <shachaf> Perhaps it's asking whether the other side closed it?
18:22:34 <otters> Well nuts
18:22:37 <otters> I just want to close this side
18:23:15 <Ralith> otters: just call close, and don't worry about it failing?
18:24:43 <otters> Ralith: I wouldn't worry, but it blocks, and I'm trying to close two sockets (in bracket_)
18:25:50 <Ralith> otters: at the OS level, close blocks until buffers are flushed
18:26:04 <otters> Well, fuck
18:26:26 <otters> There is no buffering on the handles
18:27:25 <Ralith> what kind of handles are they?
18:27:53 <otters> one was created by calling accept on a socket made by listenOn
18:27:57 <otters> and the other was made by connectTo
18:28:01 <Ralith> sockets have buffers all over the place.
18:28:05 <otters> TCP handles
18:28:07 <Ralith> yes
18:28:08 <otters> not filehandles etc.
18:28:28 <Ralith> that's how socket data gets around
18:28:32 <Ralith> buffers
18:29:35 <otters> Hm
18:31:25 <otters> Well, this is an IRC server
18:31:28 <otters> so I'd like to close the client instantly
18:31:40 <tazjin> Hrrm, the Haskell platform page still says "May 2012". I'd say time is running out!
18:32:12 <geekosaur> final release candidate has been out a couple of days, seems likely release will drop tomorrow
18:32:25 <Ralith> otters: set O_NONBLOCK
18:32:29 <Ralith> (no, I don't know how to do that in haskell)
18:32:32 <tazjin> 24
18:32:37 <otters> Ralith: I set NoBuffering
18:32:39 <tazjin> *23:59 UTC? ;P
18:32:39 <otters> is that not the same thing
18:32:50 <geekosaur> ghc runtime should be setting O_NONBLOCK already, I think?
18:32:54 <geekosaur> and no, it's not the same thing
18:33:22 <geekosaur> NoBuffering tells the GHC runtime not to do its own buffering; O_NONBLOCK tells the OS to not block on *its* buffers
18:33:44 <otters> huh
18:33:50 <Ralith> I don't know how GHC's I/O stuff works
18:34:00 <Ralith> but the close syscall will not block if O_NONBLOCK is set.
18:34:43 <otters> well
18:34:47 <otters> huh
18:35:12 <geekosaur> System.Posix.IO.setFdOption, btw, if it is necessary
18:35:19 <otters> won't that make this non-portable?
18:35:58 <gzmask> what's the difference between filter even  and takeWhile (even) ?
18:36:16 <geekosaur> yes.  :(  may need to see if someoneover in #ghc can provide a better idea about the runtime internals
18:36:28 <blackdog> gzmask: try each on [1,2,3,4,5]
18:36:50 <Ralith> otters: doing I/O correctly is hard.
18:36:55 <otters> geekosaur: should I ask them about how to set O_NONBLOCK
18:36:57 <Ralith> otters: doing it correctly *and portably* is even harder.
18:37:11 <otters> yes
18:37:17 <Ralith> basically you have to do it differently on every platform.
18:37:18 <otters> I have already been fighting I/O for a few days
18:37:20 <mauke> @check \xs -> filter even xs == takeWhile even xs
18:37:21 <lambdabot>   "Falsifiable, after 9 tests:\n[0,-3,2]\n"
18:37:25 <gzmask> blackdog: why takeWhile (even) returns empty list?
18:37:28 <geekosaur> otters, first ask them if it's needed; I was under the impression the ghc runtime did it anyway on Unixlikes
18:37:35 <otters> hm
18:37:47 <geekosaur> but documentation says maybe only with -threaded
18:37:53 <blackdog> gzmask: because takeWhile collects elements while the condition is true.
18:37:55 <otters> I am using -threaded
18:38:10 <blackdog> the first element is not even, so it ignores the rest of the list.
18:38:13 <geekosaur> hrm.  then you definitely need to find a GHC internals expert, I'm afraid
18:38:18 <otters> hm
18:38:19 <otters> okay
18:39:25 <gzmask> blackdog: then it should be taking 2 and 4 ?
18:39:52 <geekosaur> gzmask, no.  takeWhile means exactly what it says, take While the condition is true, then stop
18:40:12 <geekosaur> since the condition is not initially true it stops immediately
18:40:27 <gzmask> geekosaur: i see, thanks!
18:40:30 <shachaf> while (condition == true) { take(list); }
18:40:48 <shachaf> stop();
18:41:37 <dmwit> condition == true /* =/ */
18:42:30 <shachaf> isTrue(condition) == true ? true : false
18:42:41 <otters> isTrue always returns true
18:42:44 <otters> heh
18:42:57 <dmwit> Well, the function does say it "is true".
18:43:48 <otters> isTrue condition = condition ? (true ? true : false) : (false ? false : true)
18:44:08 <Ralith> != false
18:44:17 <irene-knapp1> isTrue condition = isTrue condition
18:44:36 <irene-knapp1> wait, no
18:45:00 <dmwit> irene-knapp1: Yeesh, you can't even screw up correctly!
18:45:02 <dmwit> =P
18:45:51 <irene-knapp1> bah :)
19:05:51 <zxspectrum> I'm trying to set up a project with quickcheck and code coverage testing using cabal. I have a test-suite entry in my .cabal file and it's half working. Is there a way to get the test output in the console when I run cabal test?
19:07:55 <zxspectrum> also, hpc doesn't seem to work. I get "hpc: can not find ProjectName.ModuleToTest in [dist/hpc/mix/projectname-0.1.0.0]" when I run cabal test
19:08:33 <zxspectrum> is there something I need to do other than putting -fhpc in ghc-options?
19:33:50 * hackagebot plot 0.1.3.4 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  http://hackage.haskell.org/package/plot-0.1.3.4 (VivianMcPhail)
19:38:51 * hackagebot plot-gtk 0.1.0.9 - GTK plots and interaction with GHCi  http://hackage.haskell.org/package/plot-gtk-0.1.0.9 (VivianMcPhail)
19:39:14 <zxspectrum> looks like adding the offending module to other-modules in the test-suite entry fixes the hpc problem
19:39:53 <zxspectrum> but I still can't figure out how to get cabal test to write the actual test output to the console
19:49:08 <hpaste> “Joey Adams” pasted “Detecting self-reference in a list using StableName” at http://hpaste.org/69320
19:49:38 <JoeyA> The example I posted uses StableName to detect a cycle in an input list.
19:49:54 <JoeyA> Yes, it *does* violate referential transparency (or something like that).
19:50:19 <JoeyA> Nonetheless, doing this sort of thing is useful for an embedded DSL that generates code to run elsewhere.
19:51:19 <JoeyA> Is there a library that facilitates locating self-references in more general circumstances?
19:51:48 <JoeyA> E.g. you could have a Tree data structure that contains cycles (meaning it wouldn't be a "tree" at all, but a graph).
19:52:14 <JoeyA> You can then traverse the Tree, replacing self-references with indexes onto a table.
19:55:09 <JoeyA> Also, would it be accurate to say that my detectSelfReference "violates referential transparency" ?
19:56:25 <JoeyA> It uses object identity, meaning it will treat cycle [1..10] and map id (cycle [1..10]) differently, even though they're supposed to be exactly the same.
19:56:54 <qtplatypus> JoeyA: Yes.
19:57:31 <JoeyA> Note that detectSelfReference runs in IO
20:00:38 <JoeyA> :t catch
20:00:38 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
20:10:46 <qtplatypus> Is there a text templating module for Haskell, like ruby's erb or Perl's template tool kit?
20:13:16 <sm> qtplatypus: there's a list at http://stackoverflow.com/questions/5770168/templating-packages-for-haskell , plus newer options like shakespeare-text
20:13:43 <qtplatypus> sm: Thankyou
20:19:30 <kkyqqp> what's a good way of checking if an infinite list is repeating itself, and testing how long the cycle is? especially if it's a particularily long cycle, such as [1,1,1..(10000 1's)..,1,1,2] and repeating
20:20:18 <shachaf> kkyqqp: Well, you can't.
20:20:38 <shachaf> Well, you can look for a cycle.
20:20:45 <shachaf> But you can never be sure that the cycle fully describes the list.
20:21:01 <Axman6> sure you can
20:21:07 <Axman6> ... given infinite time >_>
20:21:21 <shachaf> No, you can't.
20:21:48 <kkyqqp> I guess that makes sense
20:22:08 <shachaf> Axman6: Well, you can define what "infinite time" means and then maybe you can.
20:22:35 <shachaf> kkyqqp: If you're thinking of a C-style pointer equality thing, you can't do that.
20:22:45 * Axman6 has a feeling his compilation of LLVM + Clang on his Raspberry Pi is about to die :(
20:23:03 <ion> Why compile on Raspberry Pi?
20:23:20 <Axman6> couldn't get the qemu thing working
20:23:25 <Axman6> plus it's fun
20:23:50 <JoeyA> kkyqqp: You're about 30 minutes too late.
20:24:00 <kkyqqp> how do you mean?
20:24:06 <JoeyA> kkyqqp: You can cheat and use stable names: http://hpaste.org/69320
20:24:15 <JoeyA> The reason I say "cheat" is because it violates referential transparency.
20:24:42 <JoeyA> If you run that program, all of the examples work except the last one.
20:25:33 <JoeyA> Namely, detectSelfReference will treat map id $ cycle [1..100] and cycle [1..100] differently, even though the semantics of the language say they're "equivalent".
20:26:02 <kkyqqp> interesting, I'm not sure I understand this
20:27:21 <Axman6> JoeyA: would the optimisation map id = id cause the last one to work?
20:27:44 <JoeyA> Axman6: Perhaps, but the example doesn't work even with ghc -O2.
20:27:52 <Axman6> odd
20:28:19 <JoeyA> kkyqqp: Functions generally should not care where the data comes from.
20:29:11 <JoeyA> If you say f [0..] [0..], each list's cons cells will be completely different objects internally.
20:29:30 <JoeyA> However, [0..] and [0..] are exactly the same value, so they should be interchangeable.
20:30:26 <JoeyA> I wonder if there's a better explanation of referential transparency out there somewhere.
20:31:00 <shachaf> @google referential transparency
20:33:40 <Cale> Also, even if you pointer compare something with what ought to be itself, the GC might move it in the time that you get the pointer the first and second time
20:34:11 <Cale> So, that's not even reliable when you know that it's the same thing.
20:34:26 <shachaf> Cale: (lambdabot is down, by the way.)
20:34:43 <Cale> oh
20:37:21 <Axman6> @google referential transparancy
20:37:28 <lambdabot> http://en.wikipedia.org/wiki/Referential_transparency
20:37:36 <startling> FFI question -- how do I tell ghc to use some headers and object files?
20:37:37 <Axman6> close enough -_-
20:39:41 <thoughtpolice> startling: you can just pass a .c file to ghc. should Just Work. the FFI as of recent versions doesn't use *.h files anymore, so an 'ffi import' name has to be bound to the link-time symbol
20:40:20 <shachaf> Don't name the .hs file the same name as the .c file, though!
20:40:34 <shachaf> When I make a little thing to test something about the FFI I tend to forget that.
20:40:35 <startling> thoughtpolice, oh, cool
20:40:38 <startling> shachaf: heh
20:40:51 <shachaf> They compile to the same .o and GHC gets confused.
20:40:53 <startling> hmm, so it magically gets the symbols from c?
20:40:57 <startling> can I use object files?
20:40:59 <shachaf> (Maybe it should warn about that.)
20:41:05 <shachaf> Yes, object files work.
20:41:10 <startling> awesome
20:41:16 <thoughtpolice> startling: it just runs gcc in the background and emits an object file. so it just links to the object at compile time
20:41:30 <shachaf> There's no magic -- you specify the symbols explicitly in your foreign import.
20:41:40 <startling> thoughtpolice: oh right
20:41:56 <startling> hmmm, it appears the FFI things on the wiki are outdated
20:42:21 <startling> do I just ignore the {-# INCLUDE lines? everything else is still good?
20:42:46 <shachaf> Try it out and see!
20:42:54 <shachaf> The GHC documentation is probably a non-outdated place to look.
21:08:49 <recursive> sorry, im compiling a web browser on my machine at this time, what is the current version of cabal
21:10:17 <shachaf> 1.14.0
21:10:36 <recursive> thank you
21:11:37 <recursive> wow, 1.14.0, man, couple months ago it was 0.10.2
21:37:27 <Rhamphoryncus> Okay, I'm easily amused.  I got to the section of the tutorial/book titled "Why care about types?" and all I can think is "well, if you've ever used PHP..."
21:41:40 <Axman6> or ruby or python or Objective-C...
21:49:36 <Veinor> Axman6: obj-c is statically typed though
21:49:43 <unnali> Axman6: at least "3" + 5 isn't 8 in ruby, python or obj-c :)
21:50:17 <ion> or "35"
21:50:28 <unnali> indeed!
21:59:49 <MasseR> Rhamphoryncus: Haha :D
22:00:15 <MasseR> Rhamphoryncus: Did you see the discussion about adding (optional) type constraints to php
22:00:29 <Rhamphoryncus> nope.  I try to stay far away from PHP
22:00:43 <MasseR> It was something like that if you have function(int $foo), it wouldn't be okay if you couldn't call it with 2.2
22:00:57 <MasseR> Or "2"
22:00:58 <Rhamphoryncus> uhuh
22:01:08 <Ralith> -_-
22:01:10 <Rhamphoryncus> I'm sure it'd only work half the time
22:01:23 <MasseR> It would have to have behind the scenes type casting.
22:01:39 <MasseR> I say, if I take the effort to declare optional type constraints, I want those types and nothing else
22:01:53 <Veinor> Axman6: i honestly like python's type system
22:01:59 <MasseR> If I want to take use of the dynamic nature, then I just won't declare the types. -.-
22:02:11 <MasseR> Veinor: Python has never bitten me with its types. Unlike php
22:02:22 <Veinor> my favorite is JS's
22:02:25 <Veinor> where
22:02:28 <Veinor> "a" === "a"[0]
22:04:11 <MasseR> Then again, types are only small part of what's wrong with php :/
22:07:02 <Axman6> Veinor: python has a type system?
22:07:09 <Veinor> of course
22:07:10 <Ralith> of course it does
22:07:17 <Ralith> did you think it was untyped?
22:07:17 <Veinor> TypeError: unsupported operand type(s) for +: 'int' and 'str'
22:07:31 <Veinor> (when i tried to add 2 and "2")
22:07:41 * Axman6 is just talking shit
22:10:04 <Axman6> was it JS where "5" + 3 == "53" and "5" - 3 == "2"? I saw something like that on a SO post asking for the strangest language features for your preferred language
22:10:19 <dobblego> you guys really need to watch the WAT video
22:10:40 <unnali> MasseR: PHP has type hinting, e.g.  public function test(OtherClass $otherclass) { ... } -- but it can only be used with non-builtin classes.
22:10:49 <Ralith> what.
22:12:49 <MasseR> unnali: Yep I know
22:25:07 <chazor> Axman6: yea that sounds like JS
22:30:07 <otters> where's fcntl.h
22:30:30 <unnali> otters: /usr/include/fcntl.h
22:30:31 <unnali> ?
22:30:37 <unnali> otters: /usr/include/sys/fcntl.h ? depends on your OS.
22:30:54 <unnali> otters: /usr/include/linux/fcntl.h ? etc.
22:39:24 <Axman6> locate fcntl.h will tell you
22:40:44 <unnali> assuming you have a locate command! if not, find / -name fcntl.h will tell you.
22:40:49 <unnali> assuming you have a find command.
22:42:19 <kallisti> hm, could you consider all of the processes running on a machine as a source of entropy?
22:42:28 <kallisti> I guess it would be pretty stale on most systems.
22:43:54 <kallisti> I just imagined a random shuffle algorithm that works by spawning threads for each element of the list, with random sleeps within a given range.
22:44:21 <kallisti> the threads that finish first are at the front of the list.
22:44:36 <Ralith> that wouldn't work very well
22:45:38 <kallisti> because you would have to rely on the scheduler?
22:46:41 <Ralith> because threading is extremely prone to idiomatic corner cases
22:49:21 <kallisti> I'm not sure what idiomatic corner cases refers to here.
22:51:14 <sipa> kallisti: that's equivalent to assigning a random number to each element, and then sorting based on those numbers
22:51:25 <sipa> that will not give you a perfect shuffle
22:51:40 <kallisti> and that's assuming your scheduler is perfect.
22:51:54 <sipa> but if the numbers assigned are large enough, it will approximate it well
22:55:06 <dmwit> kallisti: http://dis.4chan.org/read/prog/1295544154
22:57:40 <kallisti> "Oh shit, we're busted, there's a REALISTICALLY THINKING PERSON in this thread!"
22:57:44 <kallisti> that pretty much sums it up.
23:01:32 <dmwit> I also quite liked "Just run an insertion sort over the output if you're worried about race conditions. This ensures that the numbers are relatively close to their ending points."
23:01:46 <dmwit> .
23:03:03 <dmwit> Oh crap, I just looked at my scrollbar.
23:04:06 <Ralith> kushal: a perfect scheduler will not generate a random distribution.
23:04:10 <Ralith> it will generate an arbitrary one.
23:04:49 <kushal> Ralith, was that for me ?
23:04:58 <Ralith> nope!
23:05:00 <Ralith> kallisti: ^
23:05:18 <Ralith> (damn large irc channels >_>)
23:06:40 <kallisti> Ralith: er, the scheduler isn't the source of randomness
23:06:46 <kallisti> it was the... randomly generated sleep times.
23:06:52 <Ralith> kallisti: then why are you involving the scheduler?
23:07:02 <Ralith> just calculate the effects that the sleep times would have had.
23:07:05 <Ralith> it's trivial.
23:07:11 <Ralith> we usually call that sorting.
23:07:22 <dmwit> If you can generate random times, why not just use whatever source you were using to make the times to make the thing you care about instead?
23:07:54 <Ralith> kallisti: but you said you wanted to use the running processes as a source of entropy.
23:07:57 <Ralith> sleep times have nothing to do with that.
23:08:37 <kallisti> it would effect the scheduler. I was initially considering what would happen if you overwhelemd the scheduler, but I doubt that would be very random.
23:08:46 <unnali> "randomly generated sleep times are the source of randomness"
23:08:59 <kallisti> all part of the thought process. and then I arrived at the more sensible solution, which of course dissolves into the more trivial "just sort with random numbers"
23:09:17 <kallisti> so, as usual, my brainstorm decays into something completely uninteresting.
23:09:20 <dmwit> =)
23:10:21 <Ralith> kallisti: but, as mentioned, that's a flawed approach to shuffling anyway.
23:10:51 <kallisti> in what way?
23:11:15 <Ralith> ask someone who knows more combinatorics than me
23:11:20 <Ralith> this is #haskell, there's probably a hundred of 'em
23:11:41 <kallisti> I guess if the number of elements exceeds the number of random possibilities
23:12:08 <kallisti> or, would that even matter?
23:15:24 <kallisti> oh I guess it would be equivalent to a naive shuffle.
23:15:29 <kallisti> where you swap any element with any other.
23:15:45 <kallisti> or, similar, at least.
23:27:58 * edwardk waves hello.
23:28:14 <edwardk> ddarius apparently yet lives.
23:32:15 <yitz> good evening edwardk. late for you, no?
23:32:39 <shachaf> edwardk: Oh?
23:32:46 <shachaf> Did he just quit IRC?
23:32:52 <edwardk> more like i'm getting back on my usual schedule
23:33:05 <edwardk> was just getting back in from boston haskell
23:33:26 <shachaf> Oh, right!
23:33:36 <kallisti> it's bad when going to sleep at 4 AM instead of 6 AM is back toward my usual schedule. :P
23:33:41 <yitz> oh i thought you were usually in boston
23:33:44 <Ralith> been there
23:35:41 * yitz looks further up in the conversation and notices that kallisti mentioned "randomly generated sleep times"
23:35:52 <Ralith> hahaha
23:36:20 <edwardk> yitz: i am, i'm also usually don't sleep much ;)
23:36:32 <yitz> haha, know the feeling.
23:37:04 <edwardk> been getting decent sleep for the last few months and it has been seriously screwing with my productivity
23:37:28 <shachaf> @remember edwardk been getting decent sleep for the last few months and it has been seriously screwing with my productivity
23:37:28 <lambdabot> Done.
23:37:35 <edwardk> i want those 5-6 hours a night back
23:38:07 <edwardk> Can anyone actually download https://docs.google.com/open?id=0ByK3AAy5ubqaZE1lblpwNjF0VlU ?
23:38:20 <edwardk> testing to see if google docs is working for my slides
23:38:27 <edwardk> or if i need to find a way to get it uploaded to comonad.com
23:38:39 <dmwit> edwardk: Seems to be working for me.
23:38:39 <shachaf> edwardk: It's 28MB
23:38:46 <shachaf> They're unable to scan for viruses, but it lets me download.
23:38:47 <edwardk> shachaf: well, yes
23:38:53 <shachaf> I don't think I'll manage it over this connection, though...
23:38:58 <edwardk> ah
23:39:03 <edwardk> dmwit: thanks
23:39:58 <dmwit> oooh, pretty
23:39:58 <edwardk> uploading the slides to comonad.com directly
23:40:05 <dmwit> 28MB seems a bit much for 42 slides, though
23:40:07 <edwardk> the haskell watermark?
23:40:18 <edwardk> dmwit: i didn't exactly optimize for web presentation ;)
23:40:20 <dmwit> Is that watermark included separately in every slide or something?
23:40:44 <edwardk> i probably included it a couple of times, but if that was the pdf slides, it should be pointers to the same resource
23:41:18 <edwardk> my main concern was giving the actual talk ;)
23:41:24 * dmwit nods
23:42:32 <edwardk> its 1.2 mb as a pptx, the pdf conversion blows it sky high
23:42:39 <edwardk> and loses the transitions, etc.
23:42:55 <edwardk> i have about a half gig of video to send to youtube for the talk as well
23:49:32 <Ralith> how does powerpoint manage to make a pdf that bulky
23:50:16 <c_wraith> render all text to 700 dpi bitmaps
23:50:20 <Ralith> ah.
23:50:44 <c_wraith> Not that it's that bad..  But it certainly would be consistent.
23:51:44 <edwardk> going to try slideshare and see how bad it is
23:51:56 <edwardk> i can get it down to ~12mb, but you lose all the resolution on the images =(
23:52:27 <edwardk> c_wraith: i tend to use 3kx2k images for source material and what not when i raid flickr for commercial sharealike imagery =P
23:52:49 <Ralith> oh, so the original is 1.2mb because all the images are external?
23:52:54 <Ralith> that's cheating :P
23:53:05 <edwardk> no they should be inline, now that you mention it
23:53:08 <edwardk> hrmm
23:53:32 <edwardk> maybe thats the problem i'm having with preview
23:54:39 <edwardk> try http://www.slideshare.net/ekmett/skewbinary-online-lowest-common-ancestor-search
23:54:55 <yitz> edwardk: it's kinda strange. chrome usually shows pdfs in a browser tab with its own internal viewer, but refuses to do so for this.
23:55:11 <edwardk> should be a bit faster than the google link
23:55:15 <dmwit> It's a wee bit mangled.
23:55:34 <dmwit> yitz: Google docs is sending an annoying mime type, probably.
23:55:37 <edwardk> dmwit: i noticed the haskell watermark is a bit dimmed by slideshare
23:56:01 <teneen> What's the default fixity and precedence for a user-defined operator?
23:56:26 <edwardk> oh i see a few problems with the Tarjan LCA slide
23:56:40 <edwardk> and some aspect ratio issues
23:57:01 <edwardk> but overall better than i feare
23:57:03 <edwardk> er feared
23:59:09 <edwardk> Any operator lacking a fixity declaration is assumed to be infixl 9
23:59:28 <edwardk> http://www.haskell.org/onlinereport/decls.html 4.4.2
