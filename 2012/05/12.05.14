00:00:17 <kallisti> liyang: aha! makes sense.
00:01:22 <sopvop> Hello #haskell. So, I have a datatype, say User record with some fields. And I need to both convert to/from json, and also be able to update it from partial json serialization. To make it easier I've made UserUpdate datatype, which has all fields wrapped in Maybe, and an update function, merging the User and userupdate.
00:01:27 <sopvop>  The problem is - it's almost the same code repeated twice for (de)serialization, plus update function. And I have like 5 such datatypes. Not that much, but still looks ugly. Any Ideas on better handling of such problems?
00:02:31 <kallisti> I'm not sure that the extra data types are actually saving you any time.
00:02:47 <kallisti> what's the behavior that should occur when the JSON is missing fields?
00:02:56 <kallisti> it's perfectly possible to fill in default values, for example.
00:03:59 <sopvop> The original stays the same. I need to update existing record from partial json.
00:04:34 <kallisti> oh I see
00:04:50 <sopvop> So, the update type is there for easier parsing of updates. If field is missing - you get Nothing for it, and update function leaves it as is.
00:04:54 <kallisti> I would just write functions to do that, handling the Value structure explicitly
00:05:09 <kallisti> the extra records is definitely overkill
00:08:20 <kallisti> sopvop: in other words instead of writing to/fromJSON instances for your update record, just have f :: MyType -> Value -> MyType
00:08:38 <kallisti> well actually
00:08:43 <kallisti> f :: MyType -> Object -> MyType
00:08:53 <kallisti> since I'm guessing you explicitly want JSON objects.
00:09:49 <sopvop> Yeah, like that. And everything in some kind of error monad, in case the filed is there but can't be deserialized.
00:09:58 <sopvop> field
00:10:24 <kallisti> I would just ignore extraneous fields in the JSON >_>  but I'm a bad person.
00:10:38 <kallisti> it's pretty standard practice when dealing with JSON, anyway.
00:11:06 <sopvop> I actually started from that, but wanted cleaner code and ended up with even uglier one :)
00:11:31 <kallisti> to the point that if you start parsing JSON from other languages' code with incredible strictness then you end up with a lot of runtime parse errors.
00:11:34 * kallisti speaks from experience.
00:11:42 <sopvop> I mean the field exists, but is a string instead of int - then it's an error.
00:11:53 <kallisti> ah right
00:12:23 <kallisti> you could actually continue using the Parser monad for that if you wanted
00:12:26 <kallisti> its basically an error monad.
00:17:49 <sopvop> It maybe cool to make monoid over update functions like (a->a), and mappend = (.) and... I don't think I need it really
00:18:55 <kallisti> sopvop: the functor instance for functions does just that
00:19:30 <kallisti> > (+1) `fmap` (+1) $ 2
00:19:31 <lambdabot>   4
00:20:40 <kallisti> sopvop: there's also Endo which forms a monoid over (a -> a)
00:20:43 <kallisti> :t Endo
00:20:44 <lambdabot> forall a. (a -> a) -> Endo a
00:21:12 <kallisti> > getEndo (mconcat [Endo (+1), Endo (+1), Endo (+1))) 2
00:21:13 <lambdabot>   <no location info>: parse error on input `)'
00:21:22 <kallisti> > getEndo (mconcat [Endo (+1), Endo (+1), Endo (+1)]) 2
00:21:22 <c_wraith> also, it's appEndo
00:21:23 <lambdabot>   Not in scope: `getEndo'
00:21:25 <kallisti> oh right
00:21:33 <kallisti> > appEndo (mconcat [Endo (+1), Endo (+1), Endo (+1)]) 2
00:21:34 <lambdabot>   5
00:21:48 <kallisti> c_wraith: I always think getEndo because all the other ones are get*
00:22:37 <sopvop> Looks like it's what is needed. Now I should decide wherever spend a day trying to figure out how to tie it all together, or just write explicit update functions.
00:34:02 <structuralist> Are histomorphisms related to pattern matching?
00:42:40 <crdueck> @src permutations
00:42:40 <lambdabot> Source not found. My brain just exploded
00:45:25 * hackagebot scyther-proof 0.4.1.0 - Automatic generation of Isabelle/HOL correctness proofs for security protocols.  http://hackage.haskell.org/package/scyther-proof-0.4.1.0 (SimonMeier)
00:52:52 <blackdog> Is there an alternative to Network.HTTP? Throwing an exception because of a closed port strikes me as pretty bad behaviour for a haskell program.
00:53:40 <crdueck> does haskell have an "andMap" function? i'm almost sure i'd seen it before...
00:54:01 <Franciman> @hoogle andMap
00:54:01 <lambdabot> No results found
00:54:26 <kallisti> blackdog: http-conduit is the best HTTP library I've found
00:54:31 <crdueck> Franciman: i didnt know the bot supported hoogle as well. maybe i have the name wrong though
00:54:33 <kallisti> (note: you don't actually have to use conduits if you don't need them)
00:54:58 <Franciman> what should andMap do, crdueck?
00:55:12 <kallisti> perhaps he's thinking of all
00:55:14 <kallisti> :t all
00:55:15 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
00:56:00 <crdueck> kallisti: thats it
00:56:03 <crdueck> thanks
00:56:11 <blackdog> kallisti: hm, i'll have a look. thanks.
00:56:17 <crdueck> its called andmap in scheme haha
00:56:34 <kallisti> crdueck: there's also "and" which is just all id
00:56:44 <kallisti> or foldr (&&) True
00:57:03 <kallisti> (which works like Scheme's and)
01:03:06 <Franciman> sure that ghc is quite excellent at optimizing code
01:05:05 <kallisti> Franciman: was that a question or just a statement? o_o
01:05:26 <Franciman> I tried to make a statement, but evidently I failed :S
01:05:45 <kallisti> :>
01:09:04 <Franciman> is there anyone using hugs?
01:09:40 <jgr> ope
01:09:41 <jgr> nope
01:11:38 <frankd_> I am back
01:12:36 <frankd_> quit
01:12:36 <kallisti> getDirectoryContents: resource exhausted (Too many open files)
01:12:38 <kallisti> what
01:13:10 <kallisti> there's only one file in that directory
01:13:42 <kallisti> ah it must be lazy IO
01:14:34 <kallisti> @hoogle evaluate
01:14:35 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
01:14:35 <lambdabot> Control.Exception evaluate :: a -> IO a
01:14:35 <lambdabot> Control.OldException evaluate :: a -> IO a
01:15:26 * hackagebot edenskel 1.1.0.0 - Semi-explicit parallel programming skeleton library  http://hackage.haskell.org/package/edenskel-1.1.0.0 (MischaDieterle)
01:16:07 <crdueck> @src length
01:16:07 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
01:16:26 <kallisti> length [] = 0; length (_:xs) = 1 + length xs
01:17:58 <Eduard_Munteanu> Franciman: you probably shouldn't use hugs, it's really old and unmaintained.
01:18:03 <t7> i need to read the type classes paper now
01:18:15 <t7> i have a feeling this is gonna melt my brain
01:18:26 <Eduard_Munteanu> Franciman: just get the Haskell Platform and perhaps add some IDE on top
01:18:27 <Franciman> Eduard_munteanu, I just wanted to know :)
01:18:32 <Franciman> btw thanks for the advice
01:18:44 * kallisti programs Haskell exclusively in notepad.exe
01:18:49 <Franciman> lol
01:18:51 <Eduard_Munteanu> Eww :P
01:19:06 <kallisti> just kidding I use emacs of course.
01:19:10 <jgr> kallisti: you're living up to your name.
01:19:28 <kallisti> I am?
01:19:40 <jgr> trolling? :)
01:21:04 <kallisti> oh right
01:21:13 <kallisti> that was a bit of a stretch for me at 4 AM
01:21:28 <jgr> kallisti: :)
01:21:56 <kallisti> oh crap my code compiles.
01:22:13 <t7> never a good sign
01:22:55 <jgr> kallisti: you're doing it wrong :)
01:23:09 <kallisti> damn you lazy bytestring IO
01:24:20 <kallisti> I wonder why there is no NFData instance for ByteString
01:24:28 <kallisti> (of the lazy variety)
01:27:27 <womb> Hi guys
01:27:35 <womb> i have a question
01:27:42 <Taneb> Ask away
01:27:55 <womb> why people use State Monad and not just  a plain tail recursive function ?
01:28:33 <c_wraith> womb: that's kind of like asking why people use division and not just addition
01:28:34 <t7> because passing extra arguments is awkward
01:28:34 <Eduard_Munteanu> womb: so they don't need to pass state around explicitly?
01:28:39 <jgr> lol
01:28:41 <jgr> c_wraith: n1
01:29:10 <jgr> womb: it's all about abstraction :)
01:29:24 <womb> i'm just coming from Erlang world so for me passing state around in gen_Server is ntohing new.
01:29:24 <kallisti> in some situations returning tuples is just fine
01:29:24 <c_wraith> the State monad doesn't even mean tail-recursive.
01:29:38 <c_wraith> so they kind of have zero to do with each other.
01:29:47 <Eduard_Munteanu> Yeah, that too, tail recursion is a non-issue here.
01:29:47 <kallisti> but for large programs State is much much nicer.
01:30:05 <womb> c_wraith: i mean tail recursive to not blow up on standard recursion :)
01:30:11 <c_wraith> womb: yes. that's irrelevant
01:30:18 <Eduard_Munteanu> If it even recurses.
01:30:42 <c_wraith> womb: there is nothing requiring any kind of recursion, tail or otherwise, in State
01:30:55 <womb> ekhm there is
01:31:04 <c_wraith> womb: there is also nothing limiting you to tail or non-tail recursion, in State
01:31:09 <womb> at least i can't think about other solution
01:31:13 <c_wraith> It's completely irrelevant
01:31:29 <womb> with single assigment how do you complete it without recursion ?
01:31:33 <womb> updating the state
01:32:12 <c_wraith> passing a new state to the next function in the line does not imply any sort of recursion
01:32:24 <Eduard_Munteanu> > evalState (modify (+1) >> get) 5
01:32:24 <lambdabot>   6
01:32:33 <Eduard_Munteanu> Any recursion there? :)
01:32:57 <Eduard_Munteanu> :t (modify (+1) >> get)
01:32:57 <lambdabot> forall (m :: * -> *) b. (MonadState b m, Num b) => m b
01:33:12 <womb> well you have a function application
01:33:38 <Eduard_Munteanu> > evalState get 5   -- how about now?    :)
01:33:39 <lambdabot>   5
01:33:41 <c_wraith> function application does not imply recursion, non-recursion, or much of anything else. All it implies is function application
01:34:20 <womb> tbh i need toe xamine internals of state monad to go deeper in this conversation
01:34:36 <c_wraith> the internals of state are basically mechanical
01:34:38 <Eduard_Munteanu> @src get
01:34:38 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
01:34:51 <Eduard_Munteanu> @src State
01:34:51 <lambdabot> Source not found. My pet ferret can type better than you!
01:34:53 <Eduard_Munteanu> Bah.
01:35:03 <Eduard_Munteanu> @src Monad State
01:35:03 <lambdabot> Source not found. :(
01:35:09 * Eduard_Munteanu gives up
01:35:23 <Franciman> lol
01:35:30 <kallisti> womb: essentially State is a function from some state value to a tuple
01:35:36 <womb> i think i'm right i just need to examine internals to be sure i'm using right words :D
01:35:41 <c_wraith> @djinn (s -> (s, a)) -> (a -> s -> (s, b)) -> (s -> (s, b))
01:35:41 <lambdabot> f a b c =
01:35:41 <lambdabot>     case a c of
01:35:41 <lambdabot>     (d, e) -> b e d
01:35:42 <Eduard_Munteanu> Basically get is a wrapped identity function.
01:35:53 <kallisti> the argument sets the initial state, the return value contains the final result along with another state value.
01:35:56 <c_wraith> djinn can implement state, if given the correct type signatures
01:36:03 <c_wraith> the implementation is automatic :)
01:36:46 <kallisti> womb: even when you /do/ recurse there's not much harm of a stack overflow
01:36:52 <kallisti> you can happily loop forever without stack overflows.
01:37:09 <womb> but tail recursion is more optimal ?
01:37:12 <womb> faster ?
01:37:17 <c_wraith> womb: nope. the same.
01:37:17 <kallisti> tail recursion is not the same in Haskell.
01:37:23 <womb> i'm just used to do it
01:37:23 <kallisti> it doesn't work like that
01:37:40 <womb> i produce more C like code in haskell because i was corrupted at university and in my first job ;]
01:38:01 <womb> i don't do brilliant code like you guys i just produce small things that works.
01:38:27 <liyang> (Subtly implying that we write things that don't work. :)
01:39:33 <womb> nah i just see often code that is "nice" using a lot of funky features
01:39:40 <deggis> i think there's nothing better than producing small things (hey, that's a plural!) that do work
01:39:43 <womb> flips etc, while i eg hate flip
01:40:04 <womb> flip is most basic example of how i go mental
01:40:20 <c_wraith> flip in real code isn't that common
01:40:29 <c_wraith> clever one-liners aren't real code
01:40:30 <liyang> Makes you flip out, does it?
01:41:37 <womb> well im stil beginner and i still get my mind melted when i go back and read real world haskell maybe thats why :)
01:42:23 <womb> i also don't like operator overloading like Data.List //
01:42:34 <kallisti> that's not overloaded...
01:42:44 <kallisti> oh you mean just being able to define operators.
01:43:00 <womb> defining operators yeah :)
01:43:10 <mauke> yeah, who needs (+) or (==) anyway
01:43:12 <liyang> ITT: s/I don't understand/I don't like/
01:43:12 <Franciman> what I find interesting is that writing ONLY ast nodes structures in like C++ it takes something like 500 lines or much more
01:43:14 <blackdog> womb: i think i'd miss them :)
01:43:20 <ibt> does lambdabot have an rss plugin? if so, where is it?
01:43:27 <womb> i just assign it to "difference" and use this function ;p
01:43:28 <Franciman> in haskell it takes dramatically less likes
01:43:39 <liyang> (Don't mind me, I'm just trolling.)
01:44:05 <Franciman> *lines
01:44:08 <t7> gonna get my mum a chrome book :3
01:44:16 <Franciman> lol
01:44:37 <womb> liyang: i think you could be right ;] i'm not smart enough so i prefer names
01:44:38 <kallisti> Franciman: that's because you basically have to implement algebraic data types by hand
01:44:45 <kallisti> whereas Haskell comes with them, as well as nice syntax for working with them
01:44:58 <Franciman> yeah of course
01:45:19 <deggis> ibt: now that you asked, i became interested in that too. it seems there's 'rss subscription' included in lambdabot 2 feature sketch
01:45:33 <liyang> womb: s/smart/used to it/
01:45:47 <kallisti> I was talking about Haskell with a friend of mine who programs in C, and I explained how a Haskell data structure is like a tagged union. He was completed baffled as to why anyone would ever want to use such a thing. :P
01:46:01 <Franciman> lol
01:46:20 <Franciman> liyang, you're getting too perly
01:46:24 <ibt> deggis: i saw it listed under 'new plugins' on the wiki, but that's all i've seen. there is also an rss2irc project on haskell, but i don't want to run a separate bots.
01:46:31 <Franciman> :)
01:46:40 <womb> ADT are like Unions
01:46:41 <womb> or Enums
01:47:21 <kallisti> they're like tagged unions of structs.
01:47:36 <kallisti> where an enum is just an empty struct of sorts.
01:47:37 <Franciman> tagged unions in C is equal to
01:47:44 <Franciman> a struct of a enum and a union
01:47:48 <linduxed> what does the @ mean in (xs@(x:_):ys)
01:47:49 <deggis> ibt: yeah, that's not convenient. i've tried rss2irc (with success), but would like to run lambdabot with some plugin, too
01:47:53 <liyang> Some parts of the standard libraries provide flipped variants of many functions, e.g. Control.Exception.{handle,catch} or Data.Traversable.{traverse,for}. But most modules don't, so flip does come in useful on many an occasion.
01:48:04 <kallisti> linduxed: it binds the pattern on the right to the variable xs
01:48:12 <kallisti> so xs refers to the whole list that the pattern (x:_) matches
01:48:13 <linduxed> kallisti: ok thx
01:48:43 <womb> Franciman: well in union you could have void* and break this "rule" ?
01:48:52 <womb> void**
01:49:01 <Ptival> linduxed: it's know as an "as-pattern"
01:49:02 <kallisti> womb: yes, it's not directly comparable to the C code.
01:49:10 <kallisti> you can do all sorts of nonsense in C code.
01:49:24 <womb> void** is not nonsense its abstraction :D
01:49:24 <Franciman> womb that si?
01:49:27 <Franciman> *is
01:49:43 <Franciman> how you find out what's the actual type?
01:50:05 <OMGTallMonster> Implying C has actual types.
01:50:13 <OMGTallMonster> It's whatever type you want it to be. :D
01:50:19 <womb> actually in C if you will go will with void** you can only guess what type is after casting it
01:50:48 <Franciman> but if you keep an enum you get a bit more type safety
01:50:53 <womb> but it will let you cast void** on any pointer to anything, maybe processor level exception handling lol
01:51:00 <womb> Enums are ok
01:51:03 <Franciman> but C + type-safety = math error
01:51:09 <womb> that why i like comparing ADT to enums
01:51:47 <Franciman> no wait
01:51:59 <Franciman> type-safety € C = 0
01:52:38 <womb> one more thing
01:53:04 <womb> do you like and use exceptions for "application" level errors handling ?
01:53:20 <womb> i just use them "because i must" but i just trust typechecker
01:53:25 <womb> is this stupid approach ?
01:54:07 <blackdog> womb: heh, i'm arguing with bos about this on twitter right now :)
01:54:22 <blackdog> womb: https://twitter.com/#!/bos31337/status/201945877689008129
01:54:30 <womb> i'm following bos and i don't see the flame
01:54:37 <blackdog> i think he's wrong, but he's a much better hacker than i am, so take that with a grain of salt :)
01:55:20 <womb> isn't he like child of haskell , i heard BoS was effect of first type checked program in haskell and he is not real human.
01:55:51 <womb> i'm gone follow you
01:56:11 <Franciman> blackdog, I'd fight hardly for this
01:56:32 <Franciman> this is one of the major reasons for which in the middle age things didn't evolve
01:56:47 <womb> blackdog: are you a scary guy with random beard aroudn face ?
01:56:56 <Franciman> lol
01:57:37 <womb> maybe using name would be more appropriate :D Mark ?
01:59:23 * kallisti wonders at what point he realizes the compiler is a friend rather than an enemy.
01:59:27 <kallisti> *realized
02:00:45 <liyang> A friend that only tells you off when you're wrong.
02:01:16 <womb> diablo 3 is coming out today
02:01:48 <liyang> It'd be nice if it occasionally gave you messages of encouragement, like "Hey, that typechecked first time! Well done!" or "Hang on in there, you're close!"
02:02:15 <kallisti> I can't figure out this bug..
02:03:06 <womb> liyang: like a game ? or Achievement system. Type Checked Achievement Unlocked you earned 10 points
02:03:15 <Franciman> lolol
02:03:35 <liyang> Doesn't Visual Studio have something like that?
02:03:50 <womb> i did not used it since 2004 so maybe
02:04:16 <kallisti> it looks like my directory traversal just runs out of file handlers
02:04:18 <kallisti> at some point
02:04:25 <kallisti> when traversing through Firefox's cache.
02:04:52 <Eduard_Munteanu> kallisti: depth-wise, or just because you don't close old stuff?
02:05:10 <kallisti> it's certainly not depth
02:05:22 <kallisti> possibly breadth though
02:05:25 <kallisti> there's a lot of directories per level.
02:06:05 <tehmillhouse> Hiya, total newbie here. I'm trying to use Network.Curl.curlGetString :: URLString -> [CurlOption] -> IO (CurlCode, String)
02:06:47 <tehmillhouse> but for some reason, using snd $ Curl.curlGetString x [] doesn't check out (x is a String)
02:07:14 <kallisti> Eduard_Munteanu: https://github.com/kallisti-dev/filesystem-trees/blob/master/src/System/File/Tree.hs  anything that stands out as an obvious fix in the getDir_ function?
02:07:18 <tehmillhouse> Have I fundamentally misunderstood IO?
02:07:37 <kallisti> yes
02:07:40 <tehmillhouse> (Oh, and Network.Curl is imported as Curl.)
02:07:44 <kallisti> IO (CurlCode, String)  is not a tuple
02:07:48 <Eduard_Munteanu> tehmillhouse: Curl.curlGetString x [] :: IO (CurlCode, String), not (CurlCode, String)
02:07:56 <kallisti> it's a computation that produces a tuple
02:08:30 <kallisti> so you can't call snd on it directly, you have to bind the result to a value with >>=
02:08:49 <kallisti> *to a variable
02:08:59 <tehmillhouse> :t (>>=)
02:09:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:09:12 <kallisti> the a in this type is your tuple
02:09:13 <kallisti> m is IO
02:09:56 <Eduard_Munteanu> Or "fmap snd ..." / "snd <$> ..."
02:10:05 <tehmillhouse> ...Yeah, looks like I'll be burying my face in documentation some more.
02:10:07 <kallisti> yes that would be the most straightforward way.
02:10:19 <kallisti> tehmillhouse: I recommend reading a good book on the subject
02:10:45 <tehmillhouse> I've got tabs opened on "Real World Haskell", "Learn you a Haskell" and "Learn Haskell Fast and Hard"
02:10:55 <kallisti> might want to read over monads then
02:11:08 * Eduard_Munteanu never heard about the latter
02:12:02 <tehmillhouse> Eduard_Munteanu: It's more praxis-oriented, and jumps right into real-world examples. It does skip a lot of the beautiful theory behind it all though.
02:12:34 <kallisti> probably a lot of non-theoretical-totally-necessary-to-grasp-Haskell fundamentals
02:12:37 <kallisti> as well
02:12:50 * kallisti recommends LYAH and RWH as always.
02:14:10 <Botje> It's incredible how fast people here go from "how do i fac" to "hmm, which applicative functor can I use here?"
02:14:54 <rtharper> Botje: sometimes a bit too fast ;)
02:15:06 <tehmillhouse> Well thank you for all the help, I'll go read up on how IO really works then. Bye o/
02:15:19 <Botje> that's why we have the wall of brain art :)
02:15:40 <kallisti> Eduard_Munteanu: oh actually I think this is a roblem with zip-archive and not my filesystem-trees code.
02:16:01 <kallisti> let me make sure.
02:16:39 <kallisti> yes seems that way
02:18:29 <kallisti> even when I force the bytestring on all the compressed data, to ensure that file handles are closing
02:18:35 <kallisti> I get the error. so something else must be going on
02:19:43 <kallisti> ...lol, now I think it's filesystem-trees again
02:58:06 <technopredator> Ho
02:58:10 <technopredator> Hi*
02:58:19 <Taneb> Hi, ho, hi ho
02:58:45 <technopredator> Do this channel has a online compiler bot like #c++?
02:58:57 <Taneb> > "try lambdabot"
02:58:58 <lambdabot>   "try lambdabot"
02:59:08 <technopredator> ho thx xD
02:59:29 <technopredator> oh*
02:59:52 <Taneb> Try having half an hour more sleep and then some coffee?
03:00:13 <technopredator> why? you found out my GMT?
03:00:34 <Taneb> Nah, you just seem like you've just woke up
03:00:38 <Taneb> @time technopredator
03:00:39 <lambdabot> Local time for technopredator is lunes, 14 de mayo de 2012 06:00:09 a.m.
03:00:51 <mauke> @time Taneb
03:00:54 <lambdabot> Local time for Taneb is Mon May 14 11:00:32
03:01:26 <technopredator> xD
03:01:34 <technopredator> nice :)
03:01:43 <sipa> @time sipa
03:01:45 <technopredator> I'm sleepless
03:01:47 <lambdabot> Local time for sipa is Mon May 14 12:01:21 2012
03:01:47 <Taneb> lambdabot does everything
03:02:03 <Taneb> @space Taneb
03:02:03 <sipa> @vixen can you do everything?
03:02:03 * lambdabot will count to five...
03:02:03 <lambdabot> Do you know what happened to the Romans?  The last six Roman emperors were fags. . . .  You know what happened to the popes?  It's all right that popes were laying the nuns.
03:02:30 <Taneb> I've never encountered @vixen before...
03:02:36 <Taneb> Is that like #esoteric's fungot?
03:02:37 <mauke> good thing we got rid of the offensive @vixen
03:02:40 <technopredator> my sleep schedule is scrambled again :(
03:02:44 <mauke> Taneb: it autocorrects to @nixon
03:02:48 <sipa> @vixen are you intelligent?
03:02:48 <lambdabot> Finishing second in the Olympics gets you silver. Finishing second in politics gets you oblivion.
03:02:50 <technopredator> I've been awake for hours
03:03:04 <mauke> @nixon
03:03:05 <lambdabot> A public man must never forget that he loses his usefulness when he as an individual, rather than his policy, becomes the issue.
03:03:13 <sipa> @faq does Haskell make you intelligent?
03:03:13 <lambdabot> The answer is: Yes! Haskell can do that.
03:03:48 <Taneb> Yeah, last night I said "goodnight" and thought "damn, I'm stuck in the IO monad". That was when I realised I needed sleep
03:05:57 <Taneb> The worst thing is, I hadn't even been writing IO code that day
03:06:06 <blackdog> Taneb: i rescued it from a visual basic script years ago
03:06:24 <blackdog> but there was some pretty sketchy stuff buried in a pile of regexes, so it got turfed.
03:06:49 <Taneb> This is @nixon, not my sleepy IO, right?
03:07:23 <blackdog> Taneb: yeah. or @vixen, anyway.
03:08:09 <hamid> @slap hamid
03:08:09 * lambdabot karate-chops hamid into two equally sized halves
03:08:54 <Taneb> Hmm... It seems Eclipse has just crashed on me
03:09:16 <hamid> Taneb: you code haskell with eclipse?
03:09:54 <Taneb> Yeah, I couldn't figure out Leksah, and I don't get emacs or vim et al.
03:11:16 <Taneb> For little things I use gedit or Notepad++, depending on which OS I'm running at the time
03:11:55 <technopredator> Leksah is pretty straightforward and simple imo
03:13:22 <technopredator> btw anyone follow Games Of Thrones?
03:13:58 <hamid> technopredator: you want somebody spoil it? :P
03:14:00 <technopredator> the latest ep aired yesterday
03:14:31 <hamid> technopredator: 7th?
03:14:47 <technopredator> no I just wanted to say that the laatest ep, ep7, is out for torrent
03:14:58 <technopredator> I'm downloading it right now
03:15:07 <technopredator> yeah 7th
03:15:31 <technopredator> eztv one, 390MB, 77.1%
03:15:36 <osfameron> very off-topic
03:15:37 <hamid> technopredator: cool i gonna dl it :)
03:15:50 <hamid> oops! this is haskell channel :D
03:16:10 <technopredator> I have a slow connection so I download the smallest possible, there are 140MB ones great quality, even at dull screen
03:16:18 <Dtgr> of course it is out, what else would you except after >20 hours of airing
03:16:34 <Dtgr> but yeah, very offtopic :)
03:17:11 <Eduard_Munteanu> There's #haskell-blah for that.
03:17:17 <technopredator> what do you think of a 40KB/s connection? is it very slow to you?
03:17:38 <technopredator> yeah I know about that channel but everyone is asleep there xD
03:17:54 <Eduard_Munteanu> How so? Did you try? :P
03:18:30 <technopredator> no but is *wispers* so quite...
03:18:36 <osfameron> I'm not even sure warez is relevant to -blah
03:19:40 <kallisti> there doesn't seem to be a way for to force lazy ByteString IO to finish.
03:19:57 <kallisti> converting the lazy bytestring to strict is not helping me.
03:20:35 <technopredator> and actually  sub-24 hrs true torrents are surprising to me, really fast IMO
03:21:25 <technopredator> I'd expect more hrs days before a true decent quality torrent appears, but I guess is thanks to digital cable TV
03:21:34 <technopredator> and nice sharing people :D
03:22:44 <Taneb> And it being a popular series, one presumes
03:22:45 <technopredator> ok, I'll go off now
03:23:31 <Taneb> Should addPerson be FamilyTree -> (FamilyTree, Int) or FamilyTree -> (Int, FamilyTree) ?
03:23:38 <Taneb> Where the Int is the index of the new person
03:24:04 <technopredator> 80.9%, yes! xD
03:24:47 <Taneb> I suppose the former would go well with IORefs
03:28:33 <feniks> ,
03:31:06 <technopredator> > cout << “The Good, the”;
03:31:07 <lambdabot>   <no location info>: lexical error at character '\8220'
03:31:30 <Taneb> technopredator, lambdabot doesn't do C++. It does Haskell
03:31:34 <technopredator> > std::cout << “The Good, the”;
03:31:35 <lambdabot>   <no location info>: lexical error at character '\8220'
03:31:44 <technopredator> oh ok
03:31:46 <Taneb> > "The Good, the"
03:31:47 <lambdabot>   "The Good, the"
03:31:59 <Taneb> (and it doesn't do IO, just evaluates expressions)
03:32:04 <technopredator> > cunt << “The Good, the”; lol
03:32:04 <lambdabot>   <no location info>: lexical error at character '\8220'
03:32:12 <sipa> technopredator: this is not c++
03:32:42 <sipa> and even in C++, it's "", not “”
03:32:45 <technopredator> read the "reserved word" xD
03:32:52 <sipa> i see none
03:33:05 <Taneb> technopredator, get some sleep and a better sense of humour
03:33:24 <technopredator> lol xD
03:33:27 <schlicht> i'm searching for an algorithm to arrange and display typed lambda calculus, does anyone have a hint?
03:33:41 <technopredator> you bitter ppl
03:39:32 <Franciman> can sombody explain me the use and utility of literate haskell?
03:39:47 <Taneb> @pl \f -> let ((n,_):_) = dropWhile (uncurry (==)) . zip [1..] . IM.keys $ f in n
03:39:47 <lambdabot> (line 1, column 11):
03:39:47 <lambdabot> unexpected "("
03:39:47 <lambdabot> expecting "()", natural, identifier or "in"
03:40:27 <Taneb> Franciman, it encourages longer, more informative comments
03:40:42 <Taneb> The emphasis is on the description of the code rather than the code itself
03:40:50 <linduxed> isn't there an easier way to write "pred x || pred y" ?
03:40:52 <Taneb> This makes mistakes easier to notice and fix
03:41:05 <linduxed> would "pred (x || y)" work?
03:41:06 <quicksilver> :t or
03:41:07 <lambdabot> [Bool] -> Bool
03:41:11 <quicksilver> :t any
03:41:11 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
03:41:12 <Franciman> any line not starting with > is treated as a comment right?
03:41:14 <Taneb> :t (||) `on` pred
03:41:15 <lambdabot> Bool -> Bool -> Bool
03:41:15 <quicksilver> any pref [x,y]
03:41:24 <quicksilver> linduxed: any pred [x,y]
03:41:38 <Taneb> That works too
03:41:41 <Franciman> btw, thanks :)
03:41:43 <linduxed> haha, that's funny because i'm trying to implement myAny
03:41:48 <linduxed> so i can't use that
03:42:16 <Taneb> :t on
03:42:17 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
03:42:22 <Taneb> :t (||)
03:42:23 <lambdabot> Bool -> Bool -> Bool
03:42:39 <Taneb> I'm assuming your pred is a -> Bool
03:42:56 <Taneb> :t (||) `on` (f :: a -> Bool)
03:42:57 <lambdabot>     Ambiguous occurrence `f'
03:42:58 <lambdabot>     It could refer to either `L.f', defined at <local>:5:0
03:42:58 <lambdabot>                           or `SimpleReflect.f', imported from SimpleReflect at State/L.hs:73:0-32
03:43:03 <Taneb> :t (||) `on` (func :: a -> Bool)
03:43:05 <lambdabot> Not in scope: `func'
03:43:28 <Taneb> :t let f = even  in (||) `on` f
03:43:29 <lambdabot> forall a. (Integral a) => a -> a -> Bool
03:43:54 <Taneb> > ((||) `on` even) 6 7
03:43:55 <lambdabot>   True
03:43:58 <kallisti> :t (||) `on` (undefined :: a -> Bool)
03:43:59 <lambdabot> forall a. a -> a -> Bool
03:44:09 <Taneb> I forget you can do that
03:44:24 <Taneb> kallisti, haven't seen you in a while; how's it going?
03:44:27 * kallisti will often replace unfinished chunks of code with undefined while debugging.
03:44:29 <danr> :t \f -> (||) `on` f
03:44:30 <lambdabot> forall a. (a -> Bool) -> a -> a -> Bool
03:44:36 <kallisti> Taneb: not bad. I've been coding like a madman.
03:44:46 <kallisti> and now I should go to sleep.
03:44:49 <Taneb> How's Portal Chess fairing?
03:45:05 <kallisti> I haven't touched it much.
03:45:24 <Taneb> Fair 'nuff
03:45:30 <Taneb> Well, goodnight, then
03:45:31 <kallisti> I plan to revisit it though
03:45:33 <Franciman> night
03:45:47 <kallisti> but I'm almost focused on all of this: https://github.com/kallisti-dev
03:46:12 * kallisti sleeps.
04:10:40 * hackagebot hamlet 1.0.1.3 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.0.1.3 (MichaelSnoyman)
04:10:42 * hackagebot persistent-mongoDB 0.9.0.2 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-0.9.0.2 (MichaelSnoyman)
04:10:56 <Taneb> What does hackagebot even do?
04:11:13 <Taneb> Is it commits to Hackage, or just random modules?
04:12:11 <quicksilver> all uploaded packages on hackage.
04:12:26 <Taneb> So, does it message when somebody uploads a package/
04:13:06 <quicksilver> yes
04:15:44 * hackagebot persistent-postgresql 0.9.1 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-0.9.1 (MichaelSnoyman)
04:15:46 * hackagebot persistent-template 0.9.0.2 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-0.9.0.2 (MichaelSnoyman)
04:15:48 * hackagebot pool-conduit 0.1.0.2 - Resource pool allocations via ResourceT.  http://hackage.haskell.org/package/pool-conduit-0.1.0.2 (MichaelSnoyman)
04:15:50 * hackagebot servius 1.0.0.2 - Serve Shakespearean templates via Warp  http://hackage.haskell.org/package/servius-1.0.0.2 (MichaelSnoyman)
04:15:52 * hackagebot shakespeare 1.0.0.2 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-1.0.0.2 (MichaelSnoyman)
04:16:11 <Taneb> I'm still waiting for my Hackage account...
04:19:32 <Franciman> hey people, is there any overhead if I used guards to check bytestrings equality rather than pattern matching using the view pattern extension?
04:20:03 <t7> is chris done in the house?
04:20:25 <t7> preflex: @seen chrisdone
04:20:25 <preflex>  chrisdone was last seen on #haskell 6 days, 14 hours, 54 minutes and 53 seconds ago, saying: ah, cool!
04:20:54 * hackagebot shakespeare-css 1.0.1.2 - Stick your haskell variables into css at compile time.  http://hackage.haskell.org/package/shakespeare-css-1.0.1.2 (MichaelSnoyman)
04:20:56 * hackagebot shakespeare-i18n 1.0.0.2 - A type-based approach to internationalization.  http://hackage.haskell.org/package/shakespeare-i18n-1.0.0.2 (MichaelSnoyman)
04:20:58 * hackagebot shakespeare-js 1.0.0.2 - Stick your haskell variables into javascript/coffeescript at compile time.  http://hackage.haskell.org/package/shakespeare-js-1.0.0.2 (MichaelSnoyman)
04:21:00 * hackagebot shakespeare-text 1.0.0.2 - Interpolation with quasi-quotation: put variables strings  http://hackage.haskell.org/package/shakespeare-text-1.0.0.2 (MichaelSnoyman)
04:21:02 * hackagebot wai-handler-devel 1.2.0.2 - WAI server that automatically reloads code after modification.  http://hackage.haskell.org/package/wai-handler-devel-1.2.0.2 (MichaelSnoyman)
04:21:07 <hpaste> eaie pasted “a” at http://hpaste.org/68493
04:26:04 * hackagebot warp 1.2.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.2.1 (MichaelSnoyman)
04:26:06 * hackagebot yesod 1.0.1.6 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.0.1.6 (MichaelSnoyman)
04:26:08 * hackagebot yesod-auth 1.0.2.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.0.2.1 (MichaelSnoyman)
04:26:10 * hackagebot yesod-core 1.0.1.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.0.1.2 (MichaelSnoyman)
04:26:12 * hackagebot yesod-default 1.0.1.1 - Default config and main functions for your yesod application  http://hackage.haskell.org/package/yesod-default-1.0.1.1 (MichaelSnoyman)
04:28:46 <Taneb> What does System.Info.os return in Mac OSX?
04:29:46 <hamid> in imperative languages when you are debugging actually you are testing or looking at variables' value. how is debugging in haskell ?
04:30:00 <Taneb> Debug.Trace?
04:30:01 <sipa> Horrid.
04:30:17 <sipa> fortunately, if it compiles, it usually works :)
04:30:27 <Taneb> Unless you're me :/
04:30:31 <t7> you havnt seen my code buddy
04:30:34 <hamid> :D
04:31:01 <blackdog> Taneb: my favourite line is "a refreshing desert in the oasis of referential transparency"
04:31:14 * hackagebot yesod-form 1.0.0.4 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.0.0.4 (MichaelSnoyman)
04:31:16 * hackagebot yesod-json 1.0.0.1 - Generate content for Yesod using the aeson package.  http://hackage.haskell.org/package/yesod-json-1.0.0.1 (MichaelSnoyman)
04:31:18 * hackagebot yesod-newsfeed 1.0.0.2 - Helper functions and data types for producing News feeds.  http://hackage.haskell.org/package/yesod-newsfeed-1.0.0.2 (MichaelSnoyman)
04:31:20 * hackagebot yesod-persistent 1.0.0.1 - Some helpers for using Persistent from Yesod.  http://hackage.haskell.org/package/yesod-persistent-1.0.0.1 (MichaelSnoyman)
04:31:22 * hackagebot yesod-routes 1.0.1.1 - Efficient routing for Yesod.  http://hackage.haskell.org/package/yesod-routes-1.0.1.1 (MichaelSnoyman)
04:31:27 <hpaste> sopvop pasted “Partial update of record from json!” at http://hpaste.org/68494
04:31:41 <Taneb> blackdog, where does it day that?
04:31:55 <sopvop> If anyone still remembers my question from 3 hours ago, I've this thing and it works.
04:32:06 <blackdog> i think it's from pugs? http://www.perlmonks.org/?node_id=520826
04:32:18 <blackdog> ah, it's from audrey tang
04:32:33 <blackdog> she's got a way with words :)
04:33:51 <sopvop> I feel so smart now, like a real functional programmer.
04:34:50 <blackdog> sopvop: i don't know why there's this persistent myth that functional programmers are smart. look at all the support we need! The real geniuses are people who write perfect code in dynamic languages. like pushing a pea up everest with your nose..
04:35:36 <osfameron> heh
04:35:48 <Franciman> nope, the real genious is me ( of course just kidding ;) )
04:35:48 <osfameron> it helps if you try to use most functional style in dynamic languages
04:36:05 <lucian> it also helps if you use a strongly, dynamically typed language
04:36:14 <sopvop> I want pattern matching in my python please :)
04:36:15 <blackdog> osfameron: :/ wearing the hairshirt without the benefits?
04:36:21 <osfameron> you get loads of benefits
04:36:24 <lucian> try '1'+'2' and '1'-'2' in js
04:36:24 * hackagebot yesod-sitemap 1.0.0.1 - Generate XML sitemaps.  http://hackage.haskell.org/package/yesod-sitemap-1.0.0.1 (MichaelSnoyman)
04:36:26 * hackagebot yesod-static 1.0.0.2 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-1.0.0.2 (MichaelSnoyman)
04:36:28 * hackagebot yesod-test 0.2.0.6 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-0.2.0.6 (MichaelSnoyman)
04:36:35 <osfameron> and you don't have to wear the hairshirt, because you can do yucky dynamic (but convenient) stuff when you need to
04:36:49 <hpaste> killy9999 pasted “Num polymorphism” at http://hpaste.org/68495
04:36:51 <killy9999> Here's a question relating to very simple code I just pasted. Numercial literals in Haskell are polymorphic and can have different type depending on the context, right?
04:37:04 <osfameron> if someone wants to pay me to work on pure FP code in NW UK I'd be interested, but until then I'm working on dynamic languages...
04:37:05 <blackdog> osfameron: well, if you control all the code, you do.
04:37:16 <blackdog> osfameron: i might be hiring soon.
04:37:25 <blackdog> half our team's international anyway.
04:37:27 <killy9999> I understand that in the first case the second parameter to (+) is interpreted as Double because the first one was a Double
04:37:41 <osfameron> blackdog: nice :-)
04:37:51 <mauke> killy9999: neither of them is Double
04:37:54 <Franciman> blackdog, and you need a genius too
04:37:57 <Franciman> :P
04:37:57 <killy9999> why?
04:37:58 <mauke> :t 1
04:37:59 <lambdabot> forall t. (Num t) => t
04:38:00 <mauke> :t 2.0
04:38:01 <lambdabot> forall t. (Fractional t) => t
04:38:17 <mauke> 1 + 2.0 :: (Fractional t) => t
04:38:30 <killy9999> hm... why is it fractinal?
04:38:40 <t7> > [1, "hi"] :: [forall a. a]
04:38:41 <lambdabot>   Couldn't match expected type `a'
04:38:41 <lambdabot>         against inferred type `[GHC.Types....
04:38:42 <mauke> what do you mean by "why"?
04:38:58 <FrancisB> hello
04:38:59 <killy9999> well, let me finish my question
04:39:07 <killy9999> because I'm clearly misundestanding somethoing
04:39:13 <Franciman> hi FrancisB
04:39:15 <blackdog> Franciman: well, i won't deliberately hire dumb people :)
04:39:22 <killy9999> the question is why doesnt 1 + 2.0 cause an error
04:39:28 <FrancisB> hello franciman
04:39:29 <mauke> killy9999: why would it?
04:39:39 <FrancisB> can i ask you somethings?
04:39:42 <Franciman> they sometimes can save you
04:39:50 <Franciman> like saying-doing hilarious things
04:40:08 <killy9999> I thought that the exact type of 1 is determined before we get to the second parameter
04:40:14 <killy9999> so 1 becomes an Int
04:40:16 <mauke> killy9999: no
04:40:40 <killy9999> and by the time we get to 2.0 we must get an error since Double (or fractional) doesn't belong to Int
04:40:51 <killy9999> that's what I thought which obviuoslky is wrong
04:41:01 <killy9999> and I'm trying to figure out what happens
04:41:12 <mauke> :t (+)
04:41:13 <lambdabot> forall a. (Num a) => a -> a -> a
04:41:21 <tgeeky> @info Fractional
04:41:22 <lambdabot> Fractional
04:41:25 <tgeeky> @src Fractional
04:41:25 <lambdabot> class  (Num a) => Fractional a  where
04:41:25 <lambdabot>     (/)             :: a -> a -> a
04:41:25 <lambdabot>     recip           :: a -> a
04:41:25 <lambdabot>     fromRational    :: Rational -> a
04:41:30 <killy9999> how can Haskell delay the evaluation of te exact type of first parameter until it gets to the second one?
04:41:52 <mauke> killy9999: types aren't evaluated
04:42:01 <killy9999> perhaps I used the wrong term
04:42:09 <mauke> you used the wrong concept
04:42:09 <killy9999> inferred would be better?
04:42:13 <Franciman> hey dudes, having some guards checking bytestring's content like this : string == BS.pack [0x00,0x01,0x023] ( ofc having the total assurance that the string is of length 4 ), is efficient enough?
04:42:22 <mauke> killy9999: the whole expression is type checked at once
04:42:22 <tgeeky> killy9999: in this case, he caught a misunderstanding, not a semantic issue
04:42:25 <barrucadu> killy9999: The type is inferred, it's (Num a) => a
04:43:01 <FrancisB> franciman, have you a little time?
04:43:07 <Franciman> tell me
04:43:15 <FrancisB> thanks
04:43:54 <FrancisB> can you suggest me if i doing good to migrate from scheme to haskell?
04:44:16 <Alan> damn... you can't interleave function definitions...
04:44:17 <killy9999> OK, so how is the return type of 1 + 2.0 determined?
04:44:18 <Franciman> well that's a matter of taste, I think
04:44:30 <killy9999> I undestand that the major role is the (+)
04:44:31 <Botje> FrancisB: learn both.
04:44:36 <Franciman> I don't know scheme, so I can't express any point of view
04:44:44 <Franciman> *my
04:44:44 <Botje> killy9999: + locks both types to be the same
04:44:51 <killy9999> which expects both arguments of type a and return a, prowiding that a is instance of Num
04:44:53 <mauke> killy9999: first let's rewrite the expression as ((+) 1) 2.0
04:45:17 <FrancisB> ah yes this is good. i first used lisp, then migrate to scheme, now to haskwell
04:45:51 <mauke> (+) :: (Num a) => a -> (a -> a)
04:45:53 <FrancisB> i read somewhere haskwell is a wolf in sheep clothing
04:45:55 <mauke> 1 :: (Num a) => a
04:46:09 <mauke> so (+) 1 :: (Num a) => a -> a
04:46:16 <killy9999> yes
04:46:19 <FrancisB> haskell typo
04:46:30 <mauke> 2.0 :: (Fractional a) => a
04:46:43 <Botje> FrancisB: it makes you hate other languages for being so backward :P
04:46:47 <mauke> ((+) 1) 2.0 :: (Num a, Fractional a) => a
04:46:47 <FrancisB> botje do you know lisp?
04:46:58 <Botje> yes. and scheme.
04:47:14 <Franciman> I think I should learn also list
04:47:16 <Franciman> *lisp
04:47:18 <killy9999> mauke: where does the Fractional come from?
04:47:28 <mauke> <mauke> 2.0 :: (Fractional a) => a
04:47:46 <mauke> and if you're wondering where that comes from ... the language definition
04:47:59 <Botje> and that comes from the H98 committee!
04:48:01 <Franciman> but it has got so many parenthesis
04:48:18 <FrancisB> sure franciman
04:48:27 <sipa> FrancisB: http://www.xkcd.com/297/ ?
04:48:39 * killy9999 has to think about it for a moment and check the Haskell Report
04:48:49 <killy9999> Ok, so one more question
04:48:53 <FrancisB> but the parenthesis are easy one time you are accustomed
04:48:53 <killy9999> when I write 1
04:48:59 <Franciman> lol
04:49:00 <killy9999> it's actualy fromInteger 1
04:49:14 <killy9999> that's how numeric literals' polymorphism is achieved?
04:49:14 <sipa> killy9999: that's a recursive definition :)
04:49:22 <FrancisB> thanks sipa
04:49:44 <tgeeky> killy9999: the question is (I think) could you change what happens when you write "1" easily?
04:49:51 <sipa> killy9999: but you're right; 1 is (fromInteger TheIntegerValueCorrespondingToOne)
04:49:55 <FrancisB> with scheme i do 900,000 factoria recursive and not tail
04:50:04 <FrancisB> factorial lol
04:50:17 <tgeeky> FrancisB: I kind of like that word. factoria.
04:50:21 <tgeeky> it sounds like a place
04:50:34 <Eduard_Munteanu> Like utopia, heh.
04:50:42 <killy9999> tgeeky: not sure what you mean...
04:51:03 <FrancisB> tgeeky, hahah, like yes
04:51:05 <sipa> killy9999: anyway, to answer your question: yes
04:51:16 <Franciman> off to lunch bbl
04:51:21 <FrancisB> i am a bif fan of recursion
04:51:29 <FrancisB> big lol
04:51:35 <killy9999> sipa: OK, thanks
04:51:41 <sipa> killy9999: every type in Num provides a fromInteger function; so integer literals can automatically become part of any Num type
04:51:44 <killy9999> I think I understand it now
04:51:54 <tgeeky> killy9999: http://stackoverflow.com/questions/6812604/in-haskell-can-i-make-numeric-literals-not-polymorphic-by-default
04:52:12 <killy9999> tgeeky: thanks
04:52:30 <tgeeky> killy9999: you are allowed to redefine fromIntegral if you'd like, is what I meant. That might be a reason why it's useful to have things arranged this way
04:52:45 <tgeeky> killy9999: I'll let you be the judge. I've never tried seriously using it :)
04:53:00 <FrancisB> sipa and franciman: have you some haskell boos to suggest me?
04:53:08 <sipa> boos?
04:53:10 <FrancisB> books
04:53:27 <sipa> LYAH and RWH? :)
04:53:34 <sipa> (never read RWH myself, though)
04:53:42 <Botje> haskell boos!
04:53:59 <FrancisB> books botje
04:54:00 <sipa> ;;where LYAH
04:54:03 <killy9999> tgeeky: not exactly what I wanted to do, but good to know :)
04:54:04 <FrancisB> typo lol
04:54:11 <sipa> @where LYAH
04:54:12 <lambdabot> http://www.learnyouahaskell.com/
04:54:20 <tgeeky> killy9999: hehe. Just a bit of perspective.
04:54:40 <killy9999> FrancisB: start with LYAH, once you've done most of it swicth to RWH ;)
04:55:02 <tgeeky> all*
04:55:07 <tgeeky> finish it. It's very short.
04:55:13 <FrancisB> ah yes thanks killy999
04:55:49 <FrancisB> and what is best to use, hugs or ghc?
04:55:54 <tgeeky> ghc
04:56:15 <FrancisB> thanks tgeeky
04:57:59 <killy9999> does anyone use Hugs anyway?
04:58:44 <FrancisB> i read hugs is good for newcomers
04:58:59 <mauke> yes, 10 years ago
05:00:50 * hackagebot hissmetrics 0.2.2 - Unofficial API bindings to KISSmetrics.  http://hackage.haskell.org/package/hissmetrics-0.2.2 (FelipeLessa)
05:00:52 * hackagebot Crypto 4.2.5 - Collects together existing Haskell cryptographic functions into a package  http://hackage.haskell.org/package/Crypto-4.2.5 (CreightonHogg)
05:01:06 <killy9999> I got "Programming in Haskell" by Hutton and it uses Hugs, so I gues they still use it at Notts
05:01:37 <FrancisB> well dear friend
05:01:44 <FrancisB> a nice day for you all
05:01:48 <FrancisB> thank you
05:03:03 <synonymous> Why can't GHC infer the constraint (Eq a) from, say, (Floating a)? I thought Floating is in the hierarchy of Eq..
05:03:27 <Cale> synonymous: Not anymore :)
05:03:55 <Cale> synonymous: Many people have wanted Eq out of the superclass context for Num for years, and GHC is finally doing it :)
05:04:02 <mauke> Show too?
05:04:05 <Cale> yeah
05:04:09 <mauke> \o/
05:04:23 <Cale> class Num a where
05:04:37 <mauke> oh frabjous day, calloo, callay
05:05:00 <Taneb> > os
05:05:01 <lambdabot>   Not in scope: `os'
05:05:09 <Taneb> > System.Info.os
05:05:10 <lambdabot>   Not in scope: `System.Info.os'
05:05:11 <synonymous> Oh...Is there a nice diagram somewhere showing the new hierarchy?
05:05:25 <Taneb> Can anyone tell me what System.Info.os returns on a Mac?
05:05:45 <zenzike> Taneb: "darwin"
05:05:51 <Taneb> zenzike, thanks
05:05:54 <barrucadu> Why did people want to get Eq out of Num?
05:06:14 <Taneb> Computable reals, I believe
05:06:15 <linduxed> i've got this code https://gist.github.com/2693585 for which i get this error
05:06:23 <linduxed> Couldn't match type `a' with `Bool'
05:06:25 <linduxed>       `a' is a rigid type variable bound by
05:06:27 <linduxed>           the type signature for myAny :: (a -> Bool) -> [a] -> Bool
05:06:31 <mauke> barrucadu: because otherwise you can't make functions instances of Num
05:06:47 <Taneb> zenzike, you couldn't tell me where Minecraft save files are on a mac?
05:06:50 <linduxed> Expected type: a -> Bool -> Bool  Actual type: a -> a -> Bool
05:07:00 <linduxed> i don't understand why that happens
05:07:18 <mauke> linduxed: what's the type of foldr?
05:07:38 <linduxed> (a -> b -> b) -> b -> [a] -> b
05:07:52 <mauke> linduxed: what's the type of step?
05:08:01 <linduxed> oh wait... let me stare at this for a second
05:09:07 <linduxed> but i don't get this still!
05:09:19 <linduxed> step acc x
05:09:32 <zenzike> Taneb: no idea sorry
05:09:36 <mauke> linduxed: what's the type of step?
05:09:37 <linduxed> that is "step Bool list"
05:09:52 <linduxed> and it returns a Bool from the guards
05:10:12 <linduxed> it should be Bool -> list -> Bool
05:10:17 <Taneb> zenzike, thanks anyway
05:10:18 <linduxed> ...which is wrong anyway
05:10:20 <linduxed> but still
05:10:31 <linduxed> that's not what it says as actual type
05:10:47 <mauke> what
05:11:06 <linduxed> "what" is exactly how i feel about it
05:11:07 <mauke> linduxed: why do you think it should be Bool -> list -> Bool? and what is list?
05:12:20 <linduxed> i think step looks like Bool -> a -> Bool because the two arguments are first a bool and then an element from the inList
05:12:33 <mauke> linduxed: why do you think the first argument is a Bool?
05:12:35 <linduxed> and the lines underneath only return Bools
05:12:56 <linduxed> because the line above says foldr step False inList
05:13:01 <mauke> linduxed: ignore the line above
05:13:09 <mauke> I'm only talking about step
05:14:03 <linduxed> i haven't completely understood how foldr works, so i assumed so far that the second argument for foldr is the accumulator, which is passed as the first argument to step
05:14:11 <mauke> dude
05:14:14 <mauke> stop looking at foldr
05:14:22 <linduxed> and the third argument for foldr is passed as the second argument for step
05:14:27 <mauke> stop
05:14:28 <linduxed> ok sure
05:14:54 <Axman6> heh
05:15:08 <mauke> your definition of step has two parameters and returns either True or False
05:15:14 <mauke> so step :: ??? -> ??? -> Bool
05:15:36 <mauke> || takes two Bools
05:15:51 * hackagebot yesod-routes 1.0.1.2 - Efficient routing for Yesod.  http://hackage.haskell.org/package/yesod-routes-1.0.1.2 (MichaelSnoyman)
05:16:03 <mauke> pred returns a Bool, so pred acc || pred x checks out
05:16:16 <mauke> pred takes an 'a'
05:16:41 <mauke> since you're passing both acc and x to pred, both acc and x must have type 'a'
05:16:50 <mauke> therefore step :: a -> a -> Bool
05:17:20 <mauke> that is the "actual type"
05:17:31 <linduxed> ok, that explains it
05:17:51 <mauke> btw, you can simplify that to: step acc x = pred acc || pred x
05:18:42 <linduxed> see i would have assumed that that might have broken fold somehow, since it's not exhaustive
05:18:54 <linduxed> i mean, what if both fail
05:18:57 <mauke> how is it not exhaustive?
05:19:01 <linduxed> oh wait
05:19:07 <linduxed> then they're false
05:19:19 * linduxed is disappointed with himself
05:19:23 <linduxed> oh well
05:19:31 <mauke> you've written the equivalent of 'if xyz then True else False'
05:19:35 <mauke> which is simply xyz
05:20:06 <Axman6> mauke: you have any idea how hard it is to get students to realise that? :(
05:20:40 <flux> "if xyz == True then True else False" ;)
05:21:00 <mauke> Axman6: just don't let them use 'if' :-)
05:21:05 <mauke> (or guards)
05:21:07 <DrSyzygy> if (xyz == True) and (xyz != False) then True else False
05:21:27 <mauke> because then they end up with: case xyz of True -> True; False -> False
05:21:31 <mauke> and then you can beat them
05:21:51 <liweiagm> hello how to quit from ghci
05:21:59 <Axman6> mauke: we don't, we've never used if. but they use guards all the time -_-
05:22:03 <linduxed> haha, i don't think i do these things in other languages (at least i hope so) but in haskell i'm trying to wrap my head around so many things that the basics fly out of the window
05:22:05 <xraycat> ctrl + d
05:22:05 <Axman6> liweiagm: :quit
05:22:16 <liweiagm> ok i know
05:22:35 <mauke> linduxed: I understand :-)
05:22:42 <linduxed> however
05:22:45 <linduxed> one thing though
05:22:58 <linduxed> i'm still quite confused about the fold methods
05:23:27 <Axman6> > foldr f z [a,b,c] :: Expr
05:23:28 <lambdabot>   Ambiguous occurrence `f'
05:23:28 <lambdabot>  It could refer to either `L.f', defined at <local...
05:23:33 <mauke> @undefine
05:23:36 <Axman6> > foldr f z [a,b,c] :: Expr
05:23:37 <lambdabot>   f a (f b (f c z))
05:23:41 <Axman6> ta
05:23:53 <Axman6> > foldr (*) z [a,b,c] :: Expr
05:23:54 <lambdabot>   a * (b * (c * z))
05:24:06 <mauke> > foldr (*) z [a,b,c]
05:24:07 <lambdabot>   a * (b * (c * z))
05:24:15 <mauke> > foldl (*) z [a,b,c]
05:24:16 <lambdabot>   z * a * b * c
05:24:38 <linduxed> yeah i get that part
05:24:51 <linduxed> it's... how do i explain this
05:25:53 * hackagebot snaplet-i10n 0.0.1 - snaplet-i18n  http://hackage.haskell.org/package/snaplet-i10n-0.0.1 (HaishengWu)
05:27:26 <linduxed> currently i think "the first argument is a function. the second argument is an accumulator. the third argument is a list. every step, the accumulator is given as the first argument to the step function, and the first element of the list is given as the second argument to the step function. the step function then returns whatever it likes and that is then set as the accumulator value"
05:27:50 <mauke> no, the accumulator is the second argument
05:28:02 <mauke> (of step)
05:28:23 <linduxed> mauke: that would explain why some shit has worked with me being very surprised that it worked
05:28:52 <mauke> and what step returns is the result of the whole foldr
05:28:57 <mauke> it doesn't become a new accumulator
05:29:01 <linduxed> ...
05:29:03 <linduxed> gaaaaah
05:29:15 <linduxed> then in that case i really don't understand it
05:29:31 <linduxed> despite actually haven written some working functions with it
05:29:39 <mauke> > foldr (\_ _ -> 42) 0 "hello"
05:29:40 <lambdabot>   42
05:30:41 <mauke> linduxed: step is called with the first element and an accumulator. the result of step is the result of foldr.
05:30:52 <mauke> linduxed: but the accumulator is not foldr's second argument
05:30:54 * hackagebot snaplet-i18n 0.0.1 - snaplet-i18n  http://hackage.haskell.org/package/snaplet-i18n-0.0.1 (HaishengWu)
05:31:10 <mauke> linduxed: the accumulator passed to step is a recursive invocation of foldr
05:31:25 <mauke> @src foldr
05:31:25 <lambdabot> foldr f z []     = z
05:31:26 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:31:41 <mauke> ^ the second equation is key
05:32:37 <mauke> another important point is lazy evaluation
05:33:01 <mauke> if the step function doesn't use its second argument, the recursive call to foldr never happens
05:33:02 <linduxed> yeah i know that foldl and foldl' aren't good with that
05:33:26 <mauke> it's just f x (...whatever...)
05:35:56 <mauke> http://upload.wikimedia.org/wikipedia/en/3/3f/Fold-diagrams.svg
05:36:03 <mauke> while we're at it
05:38:55 <linduxed> so have i understood correctly that step must always be a two argument function?
05:39:07 <mauke> depends!
05:39:17 <mauke> technically every function takes exactly one argument
05:39:29 <linduxed> well yes... i've read something about that
05:39:44 <linduxed> but it didn't really sink in
05:40:12 <mauke> > let foo = (+) 1 in foo 4
05:40:13 <lambdabot>   5
05:40:18 <linduxed> and i think i know how to do some basic currying, but i wouldn't say that i understand the idea behind it
05:40:40 <linduxed> i know that i can do "takeTwo = take 2"
05:40:44 <linduxed> or something like that
05:40:52 <mauke> heh
05:40:55 <sipa> linduxed: the function (+), of type Num a => a -> a -> a is actually a -> (a -> a); that is, it takes just one argument (a number) and returns one value (a function that again takes one argument (a number) and returns a number)
05:41:05 <mauke> linduxed: try understanding 'flip id'
05:41:38 <linduxed> sipa: i've read a very similar explanation on Real World Haskell
05:41:38 <sipa> :t (5)
05:41:39 <lambdabot> forall t. (Num t) => t
05:41:41 <t7> Set.union should have a bleeding infix operator
05:41:44 <sipa> :t (+)
05:41:44 <linduxed> and it just doesn't penetrate
05:41:45 <lambdabot> forall a. (Num a) => a -> a -> a
05:41:47 <sipa> :t (+) 1
05:41:48 <lambdabot> forall t. (Num t) => t -> t
05:41:49 <sipa> :t (+) 1 2
05:41:50 <mauke> t7: `Set.union`
05:41:50 <lambdabot> forall t. (Num t) => t
05:42:01 <t7> c1 `Set.union` c2 `Set.union` c3 `Set.union` c4 `Set.union` c5
05:42:13 <t7> i should use unions
05:42:19 <mauke> I should use onions
05:42:21 <t7> but its doesnt look like the paper
05:42:29 <lucian> i find (+), (+) 1 and (+) 1 2 useful for this. functions are chains of calls and they only actually get called when the chain is exhausted
05:42:43 <mauke> :t let (∪) = S.union in ?x ∪ ?y
05:42:44 <lambdabot> parse error (possibly incorrect indentation)
05:42:52 <sipa> lucian: or not at all
05:43:01 <mauke> > let (∪) = S.union in ?x ∪ ?y
05:43:02 <lambdabot>   mueval-core: internal error: PAP object entered!
05:43:02 <lambdabot>      (GHC version 6.12.3 f...
05:43:07 <mauke> sweet
05:43:11 <lucian> and the syntax let a = 2 vs let a x = 2 * x seems also useful to understand. a function with no arguments will just return
05:43:14 <lucian> sipa: indeed
05:43:23 <t7> mid size haskell/ml programs must have so many constraints
05:43:32 <t7> like thousands
05:43:35 <sipa> lucian: a function with no arguments is no function
05:44:00 <mauke> > ?x
05:44:01 <lambdabot>   mueval-core: internal error: PAP object entered!
05:44:02 <lambdabot>      (GHC version 6.12.3 f...
05:44:04 <lucian> sipa: but it sure acts like one-argument function called once
05:44:18 <lucian> s/called/curried/
05:44:33 <sipa> i think you mixing execution with evaluation
05:44:41 <mauke> what does it mean to curry a one-argument function?
05:44:43 <t7> @hoogle foldM
05:44:44 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
05:44:44 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
05:44:44 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
05:45:03 <t7> is Set a foldable
05:45:12 <t7> @hoogle Set
05:45:13 <lambdabot> Data.Bits setBit :: Bits a => a -> Int -> a
05:45:13 <lambdabot> Control.OldException setUncaughtExceptionHandler :: (Exception -> IO ()) -> IO ()
05:45:13 <lambdabot> Data.Set module Data.Set
05:45:24 <t7> @faq is Set a foldable?
05:45:25 <lambdabot> The answer is: Yes! Haskell can do that.
05:46:01 <t7> @hoogle foldMap
05:46:02 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
05:46:02 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
05:46:49 <t7> > foldMap (return . (+ 3)) (Data.Set.fromList [1..10])
05:46:50 <lambdabot>   Not in scope: `foldMap'Not in scope: `Data.Set.fromList'
05:47:00 <parcs`> curry1 :: (a) -> b -> (a -> b)
05:48:17 <t7> @hoogle (a -> m b) -> s m a -> s m b
05:48:18 <lambdabot> Data.Map mapMaybe :: Ord k => (a -> Maybe b) -> Map k a -> Map k b
05:48:18 <lambdabot> Data.Map updateMax :: (a -> Maybe a) -> Map k a -> Map k a
05:48:18 <lambdabot> Data.Map updateMin :: (a -> Maybe a) -> Map k a -> Map k a
05:51:30 <robstewartuk> oddly, my {-# LANGUAGE ScopedTypeVariables #-} in my .hs file is being ignored by ghc.. Use - "XScopedTypeVariables to permit it"
05:52:11 <robstewartuk> would there be any reason why ghc ignores the language pragma ?
05:52:16 <yitz> robstewartuk: is it the very first line of the file?
05:52:27 <Alan> @src undefined
05:52:28 <lambdabot> undefined =  error "Prelude.undefined"
05:52:39 <Axman6> @src error
05:52:40 <lambdabot> error s = throw (ErrorCall s)
05:52:41 <robstewartuk> yitz: yes.
05:53:25 <Alan> hmm
05:53:46 <Axman6> @src throw
05:53:47 <lambdabot> throw exception = raise# exception
05:54:48 <robstewartuk> oh yikes.. it wasn't the first line
05:55:13 <robstewartuk> it was the 4th, following 3 previous pragma declarations. nm.
05:55:45 <liweiagm> how many lessons in try haskell?
05:55:57 <yitz> robstewartuk: you can combine multiple LANGUAGE pragmas into one though. separate the option names by commas.
05:56:11 <robstewartuk> yitz: cheers, will do.
06:00:51 <Franciman> does data.text support utf-8?
06:01:54 <quicksilver> you're not supposed to care how it stores the data internally
06:01:56 <quicksilver> that's abstract.
06:02:12 <quicksilver> you just encode it when you send it to a socket/file etc.
06:02:24 <Franciman> no I mean can it decode utf8?
06:02:27 <quicksilver> (and conversely when you read something from a socket/file)
06:03:12 <quicksilver> Franciman: absolutely. See Data.Text.Encoding.
06:03:30 <Franciman> okay thanks
06:03:35 <quicksilver> or just read the utf8 as a String
06:03:39 <quicksilver> and convert that into Text
06:04:00 <Axman6> ew
06:04:12 <Franciman> quicksilver, but if I need different decoders
06:04:19 <Franciman> to decode a binary string
06:04:31 <Franciman> do you suggest using ByteString or Data.Text=
06:04:32 <Franciman> *?
06:04:35 <quicksilver> I don't understand your question
06:04:36 <Axman6> I think it's telling that I've never used the Text package. I don't deal with human readable data very often
06:04:47 <quicksilver> ByteString and Data.Text are never really alternatives.
06:04:55 <quicksilver> ByteString is a good way to represent bytes
06:04:58 <Franciman> quicksilver I have a binary stream
06:05:02 <quicksilver> Data.Text is a good way to represent characters
06:05:10 <Franciman> and some parts should be decoded in utf8
06:05:15 <quicksilver> then it's a ByteString while it's binary
06:05:19 <Franciman> some other using some compression algorithm
06:05:21 <quicksilver> and you decode the utf8 parts into Text
06:05:32 <quicksilver> decodeUtf8 :: ByteString -> Text
06:05:50 <Franciman> oh great, last thing
06:06:17 <Franciman> what's the most efficient way to do something like pattern matching on ByteStrings, quicksilver ?
06:06:46 <quicksilver> searching for patterns in the first few bytes of a bytestring?
06:07:01 <Franciman> hmm
06:07:08 <Franciman> pattern matching like
06:07:12 <Franciman> fun "LOL"
06:07:15 <Franciman> fun "NOP"
06:07:21 <Franciman> not regex
06:08:11 <quicksilver> well I'd just do fun | take 3 bs == [76,79,76]
06:08:23 <quicksilver> but it does depend a bit on the wider context
06:08:31 <quicksilver> Data.Binary or attoparsec might be useful tools
06:08:43 <Axman6> (mugh nicer when you turn OverloadedStrings)
06:08:43 <quicksilver> those are two different approaches to "parsing" binary data.
06:08:47 <Botje> isn't there a B.isPrefixOf ?
06:08:53 <Axman6> yes
06:08:59 <quicksilver> OverloadedStrings is hideous.
06:09:05 <Axman6> bah
06:09:38 <bitonic> quicksilver: it can be really handy.
06:09:44 <quicksilver> sure
06:09:48 <bitonic> I can't imaging writing some code without it. it'd be a pita
06:09:49 <quicksilver> so can php
06:09:58 <Taneb> OverloadedStrings has a long way to go for perfection
06:10:02 <Franciman> hmm maybe I should parse an integer rather than the string
06:10:06 <Alan> bah, these things look so useful for what i'm doing, but i'm working in units smaller than 1 byte :(
06:10:13 <bitonic> quicksilver: no. OverloadedStrings is bad in a completely different and lesser way
06:10:23 <quicksilver> there are a couple of bit-parsing libraries, alan
06:10:27 <bitonic> I mean if you're writing a warp application, without OverloadedString you can go crazy
06:10:44 <Taneb> If the conversion from String was done at Compile time rather than run time...
06:10:50 <bitonic> since you're going to be working with Text and ByteString all the time
06:10:53 <Franciman> quicksilver, I parse from the stream using the Get monad, then I have the first four bytes representing an id ( for example FORM )
06:10:56 <quicksilver> I'll have to take your word for it; I've never tried to write a warp application.
06:11:11 <quicksilver> but I strongly dislike literal overloading.
06:11:12 <bitonic> Taneb: that has nothing to do with OverloadedStrings, which just puts a `fromString'
06:11:21 <Franciman> and then when analyzing I should do different things depending on the id
06:11:23 <quicksilver> bitonic: yes, that's his point I think :)
06:11:32 <Taneb> Yeah
06:11:33 <Axman6> Alan: what're you doing?
06:11:57 <bitonic> quicksilver: the problem is that it's really really noisy to add a function in front of every string literal you use
06:12:38 <quicksilver> bitonic: I'll just have to take your word for it. I doubt I can appreciate it without trying myself.
06:12:47 <bitonic> quicksilver: e.g. I've been playing with this: https://github.com/bitonic/sockjs-haskell/blob/master/Network/SockJS.hs look at the number of literals and imagine adding a `toString' or similar in front of each literal
06:13:57 <bitonic> quicksilver: btw, why do you think that overloaded string literals are much worse than overloaded number literals? is it related to the illusion of things happening at compile time while they're not?
06:14:20 <quicksilver> I don't like overloaded number literals either.
06:14:48 <bitonic> quicksilver: oh well, then: why don't you like overloaded literals?
06:14:57 <quicksilver> overloading String literals for Text isn't too bad, though; at least it's faithful
06:15:09 <quicksilver> overloading String literals for ByteString is horrid.
06:15:16 <bitonic> yeah I can agree with you on that.
06:15:54 <bitonic> but then, rational number literals aren ot going to be faithful if the type is Double
06:16:05 <quicksilver> I don't like them when they can fail; I don't like them when there is substantial behind-the-scenes computation going on.
06:16:05 <bitonic> at least they won't crash your application :P
06:16:35 <quicksilver> they violate the expectations set up by the lexical syntax - literals shouldn't "do" anything, they should just "be".
06:16:37 <bitonic> quicksilver: well the thing is that if you don't use that you're going to add that `fromString' manually yourself
06:18:02 <bitonic> quicksilver: mah. with overloadedstrings, "blah" is a shorthand for `fromString ('b':'l':'a':'h':[])"'. it's not that bad.
06:21:49 * quicksilver doesn't think fromString "blah" is that bad
06:22:05 <quicksilver> and it shows that computation is being done, and reminds you it might fail (if that's the case)
06:22:52 <Axman6> doesn't OverloadedStrings give you a compile time error?
06:23:02 <bitonic> Axman6: nope
06:23:10 <Axman6> hmm, that's kinda annoying
06:23:32 <bitonic> yeah but imho it's a good compromise if you know what you're doing. and we should remove the ByteString fromString instance
06:23:43 <bitonic> which doesn't make much sense
06:23:50 <bitonic> and it's the only widely used unsafe one
06:24:41 <quicksilver> I gather that there are instances in XML libs and suchlike
06:24:48 <quicksilver> which are also unsafe.
06:25:19 <bitonic> yeah that's silly as well, imho. a TH QQ makes much more sense in that case
06:25:32 <bitonic> it's one of those cases in which TH is useful :P
06:26:31 <luite> Text doesn't use an actual String to do the conversion btw, not sure how it's implemented, maybe a rewrite rule
06:26:56 <bitonic> oh right I remember some discussion about that...
06:27:08 <luite> it uses the internal Addr# representation, was a recent change
06:27:13 <ski> Alan : hm .. just wondering if you figured out whatever you were doing with constructors for `Instruction'
06:27:22 <Alan> ski: still working on that problem :(
06:27:43 <ski> i'm still not sure what you were trying to do
06:27:52 <ski> (or wanting to do, as the case may be)
06:28:27 <bitonic> luite: but here we're talking about the `fromString' implementation, it's not something related to OverloadedStrings right?
06:29:45 * ski is glancing at <https://github.com/alanbriolat/foostack/blob/master/src/FooStack/Asm.lhs>
06:31:48 <luite> bitonic: hmm, not sure, even though it doesn't convert through a String, it can still fail i guess, in theory
06:34:58 <bitonic> luite: wait, why would Text.fromString ever fail?
06:35:12 <bitonic> (I wasn't implying that)
06:37:18 <luite> bitonic: not sure, i thought it used utf16 internally, so i think it cna't represent all code points
06:37:41 <Taneb> It doesn't fail, it converts, iirc
06:37:49 <ski> Alan : .. maybe you could state the problem ?
06:38:42 <Taneb> luite, it does http://unicode.org/reports/tr36/#Deletion_of_Noncharacters
06:39:20 <Alan> ski: i have the Instruction type, it has lots of constructors, no consistency in constructor argument types, i need to convert to and from a Word16, and I don't want to specify constant values in more than one place because that's a recipe for programming errors
06:39:30 <Taneb> Replacing invalid characters with �
06:39:46 <bitonic> luite: ah, right, while the source characters are UTF-8
06:40:13 <Alan> ski: so the "problem" is being able to define a bijective mapping between non-homogenous constructors and values of a particular type
06:40:38 <ski> the `Word16' being the instruction word ?
06:41:04 <Alan> ski: yes, i'm packing/unpacking the instruction and its operands into a 16-bit word
06:41:44 <ski> maybe you want to introduce a type of "effective operand" ?
06:41:46 <matthiasgorgens> Is there a nice way to write a function with the type m a -> m b -> (a -> b -> m c)?
06:41:51 <matthiasgorgens> oops.
06:41:55 <matthiasgorgens> m a -> m b -> (a -> b -> m c) -> m c
06:41:59 <luite> Taneb: ah
06:42:11 <Alan> @hoogle m a -> m b -> (a -> b -> m c) -> m c
06:42:11 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
06:42:12 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
06:42:12 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
06:42:15 <Botje> it almost looks like liftM2. almost :(
06:42:20 <matthiasgorgens> ok.
06:42:31 <ski> which could be either an address, an immediate byte, or an indirect address -- or something
06:42:34 <matthiasgorgens> that's good enough.
06:42:39 <matthiasgorgens> oh, not.
06:42:40 <Botje> :t \ma mb f -> join (liftM2 f ma mb)
06:42:41 <lambdabot> forall a1 a2 (m :: * -> *) a. (Monad m) => m a1 -> m a2 -> (a1 -> a2 -> m a) -> m a
06:42:50 <matthiasgorgens> that might do it.
06:43:17 <ski> Botje : .. sometimes called `bindM2'
06:43:41 <luite> Taneb: i guess that makes the situation similar to ByteString
06:43:49 <Axman6> :t \f a b c -> join (liftM3 f a b c)
06:43:50 <matthiasgorgens> bindM2 a b c = join $ c <$> a <*> b
06:43:50 <lambdabot> forall a1 a2 a3 (m :: * -> *) a. (Monad m) => (a1 -> a2 -> a3 -> m a) -> m a1 -> m a2 -> m a3 -> m a
06:44:02 <Taneb> luite, what does ByteString do?
06:44:06 <Alan> ski: you mean, make my Instruction constructors homogeneous by generalising Operands?
06:44:21 <luite> Taneb: i think it truncate codepoints
06:44:38 <ski> Alan : yes -- it seemed to me that was what you wanted -- maybe i don't understand what you want yet, though
06:44:39 <luite> but in both cases what you get is something that approximates the String literal
06:44:48 <Alan> ski: so data Operand = None | R2 Register Register | RI Register Byte | ...
06:44:49 <luite> but is not always quite the same
06:45:11 <ski> Alan : hm, i was thinking for a single operand, not for all of them
06:45:25 <Alan> ski: the operand count is variable though
06:45:41 <ski> well -- not really
06:45:47 <ski> not for each individual instruction
06:45:51 <Taneb> ByteString is just an arbitrary string of Bytes, it seems, whereas Text is optimized for UTF-something or other (16?) with relevant security
06:46:08 <ski> `NOT' only takes a single operand, the addition variants all take two, %c.
06:46:24 <Alan> ski: i've got operand encoding and decoding fine - it's the opcodes that are the problem
06:46:41 <ski> do you want to redesign the opcodes ?
06:47:30 <Alan> generalising Operand doesn't give me anything that (Encodable a, Encodable b) => a -> b -> Instruction doesn't
06:47:52 <Alan> ski: in what way?
06:48:31 <cark> hello all i have a newbie question about typeclasses, is this the place to ask such questions ?
06:48:45 <ski> it seems to me that it might be nicer to combine the non-immediate and immediate versions of various opcodes
06:48:46 <Alan> ski: this is my problem: I want, for example LDBI -> 0x0 in encode, and 0x0 -> LDBI in decode, without actually specifying 0x0 in two places
06:48:57 <parcs`> cark: yes
06:49:16 <ski> oh, you want to specify encoding and decoding at the same time
06:49:22 <cark> parcs`: cool !
06:50:00 <cark> so here it is, I want to define the class of all types that can be tranformed into a list, like so : class AsList a b where getList :: a -> [b]
06:50:21 <cark> then i can do : instance AsList (Clist a) a where  getList = asList
06:50:44 <luite> Taneb: right, in practice, Text is still a much better match ouf course
06:50:54 <luite> but who cares about that ;)
06:50:56 <cark> but this requires MultiParamTypeClasses extension, which i feel it should not
06:51:06 <Alan> ski: somewhat
06:51:07 <Taneb> luite, unless you're actually dealing with strings of bytes
06:51:24 <Taneb> In which case Text is awful
06:51:37 <luite> Taneb: right but in that case the use of string literals for those is rather questionable
06:51:44 <cark> I tried doing it like so : class AsList a where getList :: a -> [b]
06:51:54 <Taneb> luite, yeah
06:52:08 <cark> but the I run in all kind of problems when trying to define an instance for my Cons list sample
06:52:15 <Alan> ski: but i can't think of a way to define the opcode values that i can still use it in pattern matching...
06:52:32 <cark> is it possible at all to define this class with a single parameter ?
06:52:47 <ski> Alan : hm, how do you mean ?
06:53:48 * ski found `encodeInstruction' and `decode4'
06:53:58 <parcs`> cark: why do you feel it should not require MultiParamTypeClasses?
06:54:17 <Alan> ski: are you viewing the latest copy? i cleaned up decode a bit
06:54:30 <cark> parcs`: because i'm a newbie with newbie needs, and it feels like that's more advanced =)
06:54:39 <Alan> i.e. rolled decode4, decode8, etc. into decodeInstruction
06:54:40 <cark> but really i don't know
06:54:41 <ski> hm, i'm probably looking at the version from two days ago ..
06:55:26 <cark> parcs`: should i just go with it ?
06:55:39 <Alan> ski: ok so suppose i could somehow define a function "opcode :: (Operand -> Operand -> Instruction) -> Int"
06:55:42 <parcs`> cark: yes
06:55:59 <cark> parcs`: hehe ok thanks, sure makes life easier
06:56:07 <Alan> ski: i would then have a function that gives me the opcode value for each Instruction constructor, assuming they are all 2-operand instructions...
06:56:20 <ski> Alan : hm, you could do `opcode :: Instruction (Operand,Operand) -> Int'
06:56:22 <parcs`> cark: there are other ways to do it with only one type parameter
06:56:31 <Alan> ski: but i still can't do "decode (opcode LDBI) = ..."
06:56:41 <ursfromthewoods> join haskell-game
06:56:51 <ursfromthewoods> join #haskell-game
06:56:56 <parcs`> /
06:57:16 <parcs`> cark: you can have 'class AsList a where type ListResult a; getList :: a -
06:57:33 <Alan> ski: and without being able to reuse it in a pattern... well i'd still need to specify the opcode value in 2 places
06:57:52 <Taneb> luite, my advice (but I'm no expert) would be to use Text for textual data, ByteString for raw data, lazy versions when there could be a very large amount, (eg. a stream), and String when teaching or if you REALLY want to use list functions
06:57:54 <parcs`> cark: you can have 'class AsList a where type ListType a; getList :: a -> [ListType a]' -- but then you'll need the TypeFamilies extension :)
06:58:22 <cark> parcs`: haha well
06:59:08 <cark> parcs`: i don't have the first idea about TypeFamilies yet, so I might stick to the first solution then
06:59:28 <cark> parcs`: thanks a lot =)
06:59:48 <Alan> ski: the annoying thing is that in C i would just #define and be done with it
06:59:53 <Alan> :P
07:00:39 <ski> Alan : so, to avoid this duplication, i suppose i would try to define the encoder and the decoder at the same time
07:01:20 <Alan> ski: one thing i tried to do was interleave function definitions, but apparently haskell doesn't like that :P
07:01:28 <Alan> so at least they were next to each other
07:01:33 <Alan> ski: how would you go about that?
07:01:36 <ski> nah, unfortunately not
07:01:58 <ski> so, i would have a datatype like `data Coder a = MkCoder {encode :: a -> Chunk,decode :: Chunk -> a}'
07:02:26 <quicksilver> some people have written some papers about defining en/decoders at the same time
07:02:39 <quicksilver> you can build up libraries of combinators for reversible operations like this
07:02:49 * ski nods
07:02:51 <Alan> quicksilver: anything you can remember off the top of your head?
07:03:05 <Alan> ski: ah, i hadn't thought of doing it like that
07:03:15 <quicksilver> http://research.microsoft.com/pubs/64036/picklercombinators.pdf
07:03:22 <quicksilver> I think those were reversible no?
07:03:29 <ski> then `class Codable a where coder :: Coder a'
07:03:49 <Jaak> pickling is hardly a reversibly process...
07:04:06 <quicksilver> also http://www.informatik.uni-marburg.de/~rendel/unparse/
07:04:10 <byorgey> Alan: www.informatik.uni-marburg.de/~rendel/rendel10invertible.pdf
07:04:12 <ski> we want `instance (Codable a,Codable b) => Codable (a,b)' to avoid some boilerplate with operands, i think
07:04:19 <quicksilver> (which is on hackage as http://hackage.haskell.org/package/invertible-syntax )
07:04:33 <quicksilver> and http://hackage.haskell.org/package/boomerang-1.3.1
07:04:39 <Alan> ski: that looks like a type functor :|
07:04:47 <ski> which ?
07:04:50 <ski> `Codable' ?
07:04:56 <Alan> oh, no, i got confused
07:04:57 <ski> er,  `Coder', i meant
07:04:57 <Alan> by the syntax
07:05:11 <Alan> thanks quicksilver (and byorgey)
07:05:14 <Alan> I shall read some of those :)
07:05:20 <ski> i'm pondering whether GADT would be good for your instructions
07:05:57 <Alan> i looked at GADTs earlier, and it seems like it might be
07:06:04 <Alan> but i'd like to avoid language extensions if i can
07:06:04 <ski> then you could replace `Operand -> Operand -> Instruction' with `Instruction (Operand,Operand)', i think
07:06:53 <ski> well, we'd like to distinguish between the core instruction, and the instruction together with its operands
07:07:00 <ski> this would be for the former
07:08:02 <ski> with a `Coder' thing, you could probably combine your `decodeArity2' with an `encodeArity2'
07:08:36 <ski> (and hopefully then only specify `0x0' in one place)
07:10:00 <ski> i think it would be good to distinguish between instructions which can in one argument accept e.g. immediates, one ones which can't
07:10:25 <ski> i.e. have a more fine-grained specification of what kinds of operands various instructions accept
07:11:45 <edsko> @pf \x -> x
07:11:45 <lambdabot> Maybe you meant: bf pl
07:11:49 <edsko> @pl \x -> x
07:11:49 <lambdabot> id
07:11:54 <Alan> one of the other reasons I want to avoid a general "operand" type is that the depth of syntax for unpacking gets horrible
07:11:55 <edsko> @pl \x -> f x >> g
07:11:55 <lambdabot> (>> g) . f
07:12:08 * ski nods
07:12:44 <ski> with GADTs, you'd need one level for the application of an instruction to the tuple of operands
07:12:48 <Alan> i'm actually pleased with my Encodable typeclass, but I think the issue is I need to extend it a lot
07:13:05 <Franciman> guys, is there any performance difference between pattern matching a guards in a case like : fun 12 = 0; fun n = 1 VS fun n | n == 12 = 0 | otherwise = 1
07:13:06 <Franciman> ?
07:13:16 <ski> (bbiam)
07:13:29 <Axman6> Franciman: depends on the implementation of (==)
07:13:50 <Franciman> Axman6, just Word32 == Word32
07:13:53 <Franciman> implementation
07:14:31 <Axman6> probably still better to use pattern matching
07:15:28 <Franciman> okay thanks :)
07:17:15 <Axman6> actually, for primitive types, it might be better to use (==). benchmark and find out (and report results ;)
07:17:37 <fmap> that's hardly a bottleneck
07:19:04 <Axman6> it could be
07:19:19 <ski>  
07:20:59 * hackagebot yesod-platform 1.0.4 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.0.4 (MichaelSnoyman)
07:21:18 <ski> hm, you use `Enum Register' ..
07:21:32 <Taneb> (personally I think lines, words, unlines, unwords should by IsString a => a -> [a] / IsString a => [a] -> a, not sure how good of an idea this would be)
07:26:22 <byorgey> Taneb: IsString a => [a] -> a  can't work, since the only method provided by IsString is fromString
07:26:36 <Taneb> I mean, added to the class
07:26:56 <byorgey> oh, I see what you mean.
07:27:16 <byorgey> well, perhaps they should go in a separate class. I don't think they should be added to IsString.
07:27:23 <Alan> ski: yes, i do at the moment
07:27:38 <byorgey> because those functions might not make sense for everything you want to use String literals for.
07:27:46 <Alan> ski: mainly because, for now, it gives me a reversible encoding for register identifiers=
07:29:08 <edsko> @pl \e -> invalidEndPoint e >> return Nothing
07:29:09 <lambdabot> (>> return Nothing) . invalidEndPoint
07:29:10 <Alan> ski: also, what you were saying about fine-grainednesss.. surely what i currently have is as fine-grained as you can get...
07:29:39 <Alan> every single instruction constructor specifies exactly what operand types it accepts - you can't actually construct an invalid instruction within the confines of that type
07:34:10 <womb> forkIO wins world
07:34:24 <ski> Alan : well, it might be nicer to make the mapping from register to bits be more future-friendly
07:34:47 <ski> currently, you have nine addressable registers
07:35:39 <Axman6> womb: too many arguments to forkIO
07:35:52 <womb> BoS was lucky he started a company and got boughted by facebook :-F
07:35:56 <Alan> ski: indeed, all i'd need to do is define encode/decode to something other than fromEnum/toEnum
07:36:07 <ski> maybe you'll later want to add a return address register, a frame pointer register, maybe more accumulators or index/address registers
07:36:48 <ski> (and then it'd be nice if the accumulators were contiguous, as well as the index registers)
07:36:58 <Alan> ski: yeah, i'm fully aware of that
07:37:08 <Alan> ski: at the moment that gives me a reversible encoding so i can get the rest working
07:37:24 <hpaste> tgeeky pasted “can't see show instance” at http://hpaste.org/68505
07:37:24 <Alan> i'm not going to leave it like that because it means new registers would invalidate old binary encodings
07:37:25 <womb> Axman6: its not so bad, i think forkIO is mega nice way to make easy API with smart hood
07:37:31 <ski> ok, fine
07:37:58 <tgeeky> anyone take a look at my problem?
07:38:25 * ski is irked by the `FOO' vs. ` FOOI' dichotomy, though ..
07:38:44 <Alan> ski: why?
07:38:55 <ski> it seems repetetive, to my eye :)
07:39:13 * ski is mostly familiar with 6502 and 680x0, though
07:39:40 <tgeeky> and for reference:   module MyModule (  Something(), ... ) where ...   ;   Something is exported with no constructors, right?
07:39:47 <tgeeky> or is this only constructors?
07:39:47 <ski> tgeeky : yep
07:39:55 <ski> the former
07:40:12 <tgeeky> no constructors means I can't use the Show instance for it?
07:40:16 <tgeeky> but that the original author can?
07:40:26 <byorgey> tgeeky: your Show instance for IntBindingState t  says that a Show instance for  t (UTerm t IntVar)  is required.
07:40:41 <Alan> ski: it does seem repetitive, i'd agree, but my Instruction type directly corresponds to the encoding
07:40:44 <Botje> tgeeky: no constructors only means you cannot use the constructor. instances are always exported
07:41:11 <byorgey> tgeeky: so now you are trying to use show, and it is requiring such an instance, and can't satisfy it
07:41:14 <ski> Alan : i think it still could, it'd just be a slightly different grouping of the instruction words into "logical instructions"
07:41:15 <Alan> ski: in the same way that MOV is actually many many different instructions under the same name
07:41:20 * ski nods
07:41:45 <byorgey> tgeeky: you need to put a  (Show (t (UTerm t IntVar))) => ...  constraint on the PPrint instance for IntBindingState t too.
07:41:55 <tgeeky> byorgey: I understood that. But in Control.Unification.IntVar, that thing I need:  Show (t (Uterm t IntVar)) => ... -- is on the left hand side
07:42:07 <ski> hm, you need four bits for a register, so far ..
07:42:13 <Alan> ski: i only get a maximum of 15 instructions with 12 bits of operand
07:42:16 <byorgey> tgeeky: that's exactly the point, it's on the *left-hand-side*
07:42:20 <Alan> if i want to have more than 16 instructions overall
07:42:24 <byorgey> tgeeky: which means it is *required*, not provided.
07:42:42 <byorgey> a => b  means whenever you make use of b, you had better provide a.
07:43:07 <byorgey> so you are using the Show instance for IntBindingState t.  Hence you must provide a Show instance for  (t (UTerm t IntVar)).
07:43:39 <byorgey> tgeeky: put another way, the *reason* that you need that thing is *because* it is on the left-hand side!
07:43:48 <tgeeky> byorgey: hehe. I also understand that. I am sure I have seen output provided by this show instance on my console. (that is, I've seen { nextFreeVar = ... }), so I assumed that someone else provided it
07:44:05 <ski> Alan : hm, the immediate bytes, they are part of the instruction word, yes ?
07:44:14 <Alan> ski: i'm trying to keep the encoding simple, so i've gone for fixed-width instructions, and everything else basically led me to 4-bit register identifiers (but 2 non-overlapping sets) and 8-bit immediate values
07:44:25 <byorgey> tgeeky: sure.  For any *specific* use of show, there will be some specific t, and hence some specific Show instance for that choice of t.
07:44:34 <Alan> ski: yes, every instruction is exactly 1 word and has all of its operands in that word
07:44:48 <byorgey> tgeeky: but you are doing something which is generic over t.
07:45:56 <coldpizza72i> I'm getting non exhaustive patterns http://hpaste.org/68506
07:46:18 <Alan> ski: this is why i have the crazy Chunk datatype to help in packing partial words into  aword
07:46:40 <Botje> coldpizza72i: you need to provide a case for sieve []
07:47:08 <Axman6> womb: I love forkIO =)
07:47:51 <Alan> ski: although, i think my life could be made easier with all instructions being Constructor () (or (a) or (a,b)), because then all of my constructors are of type c -> Instruction
07:48:07 <Alan> and would make my encode/decode framework a lot easier to define
07:48:40 <Alan> and it doesn't make the pattern matching syntax much heavier
07:49:51 <tgeeky> byorgey: follow up: if this thing weren't an UndcidableInstance, I wouldn't have asked the question in the first place, right?
07:50:21 <byorgey> tgeeky: I don't think UndecidableInstances has anything to do with it.
07:51:20 <tgeeky> byorgey: if that show instance weren't undecidable, he wouldn't have needed to write it (instead using deriving (Show)), and that means I wouldn't have to either?
07:51:35 <tgeeky> that's what I meant, at least
07:51:39 <byorgey> oh, well, sure
07:52:18 <geekosaur> (that was a PPrint instance that required a Show instance, not a Show instance, I thought?)
07:52:56 <tgeeky> geekosaur: one of those should be PPrint? :o
07:53:34 <byorgey> actually, that's a good point; even if the Show instance *could* be automatically derived, presumably it would still have the same constraint.
07:53:38 <tgeeky> either way, what I really want to write is:   instance PPrint [(MachineState, IntBindingState ValueF)] where ...
07:54:06 <geekosaur> sorry, I got confused somewhree
07:54:29 <byorgey> tgeeky: there isn't an existing PPrint instance for lists?
07:55:02 <tgeeky> byorgey: I am not sure yet. I assumed there was one for tuples, but didn't know what to assume about lists
07:55:20 <byorgey> because if there is, you won't be able to write that instance since it overlaps
07:55:33 <byorgey> you would have to wrap up that type in a newtype first
07:55:38 <Alan> ski: i think i'm getting somewhere with this :)
07:56:01 * hackagebot monad-par-extras 0.3.2 - Combinators and extra features for Par monads  http://hackage.haskell.org/package/monad-par-extras-0.3.2 (RyanNewton)
07:56:05 <Alan> ski: your earlier stuff about "data Coder a = MkCoder { encoder :: a -> Chunk, ...}" is really helpful :)
07:56:19 <tgeeky> i don't even know where this PPrint comes from.
07:57:09 <tgeeky> byorgey: ah. it's custom made by jfischoff.
07:57:23 <ski> Alan : ok
07:57:27 <womb> Axman6: why you love forkIO ?
07:57:34 <tgeeky> byorgey: and nope, no PPrints for lists or tuples.
07:57:36 <Alan> ski: well, i'll let you know how i get on with that
07:57:40 <Alan> i definitely have more thinking to do
07:57:47 * ski nods
07:57:47 <Axman6> womb: why not? it's great
07:58:03 <womb> Axman6: i know its great, thats why i ask why we love same women.
07:58:16 <Axman6> woman?
07:58:26 <womb> forkIO not a women ?
07:59:15 <Axman6> no? it's a function...
07:59:37 <womb> that would explain a lot :|
07:59:50 <sipa> women fork?
08:00:19 <t7> only if your rich and or very handsome
08:00:46 <Alan> ski: bah, i think i got stuck again :(
08:00:52 <Alan> ah well, that's enough for one day
08:02:41 <tgeeky> byorgey: ah. it really does require undecidable. After restarting ghci, I get again:  Variable occurs more often in a constraint than in the instance head in the constraint Show (t (UTerm t IntVar))
08:02:52 <byorgey> yes, it does
08:08:20 <Gurrag> is there any way to define a function from within the REPL, e.g. on <tryhaskell.org> ?
08:09:29 <t7> let f x = x + 2 in f 123
08:09:42 <t7> i just defined the function f
08:10:15 <flux> but only for that expression. apparently you cannot add and keep new functions.
08:10:35 <OlegYch|h> i wonder why 'let' is required in repl
08:11:07 <osfameron> lambdabot lets you define functions though, iirc?
08:11:42 <flux> olegych|h, f x = x + 2 would be a function definition if f isn't defined, otherwise would be a boolean? seems sort of tricky semantics.
08:12:31 <Axman6> what does that have to do with booleans?
08:13:02 <flux> oh, right, I mixed the syntax with ocaml :)
08:13:20 <quicksilver> ghci supports definitions as lets without ins
08:13:26 <quicksilver> not sure if tryhaskell does or not
08:13:55 <t7> because then it would have to keep track of sessions
08:14:26 <flux> just send all definitions at each entry :)
08:14:49 <AndChat157044> I can't download Haskell platform now. Is there any other channel?
08:15:08 <Axman6> where are you trying to download it from?
08:15:35 <AndChat157044> Haskell.org
08:15:57 <bitonic> AndChat157044: http://hackage.haskell.org/platform/ seems to work
08:17:27 <womb> Axman6: did you responded to me ?
08:17:33 <womb> i was heavly afk
08:17:40 <Axman6> i don't think so
08:17:54 <womb> k soz for interuption.
08:21:02 <mrkronecker> What is the name of the abstraction in which your functions are all passed functions which determine what occurs with your function's output?
08:21:17 <mrkronecker> I am trying to find an old article
08:21:26 <shachaf> Continuation-passin style?
08:21:29 <mrkronecker> OH!
08:21:32 <mrkronecker> Yes! Thank you!
08:26:01 * hackagebot xss-sanitize 0.3.2 - sanitize untrusted HTML to prevent XSS attacks  http://hackage.haskell.org/package/xss-sanitize-0.3.2 (GregWeber)
08:27:19 <byorgey> ok, so currying arises from an adjunction  (A x -)  -|  (-^A).  I seem to recall reading somewhere a derivation of a similar adjunction in a higher-order setting, i.e. in a functor category.
08:27:28 <byorgey> does anyone have any idea what I'm talking about, or know of any relevant links?
08:28:05 <cark> parcs`: ended up having to use type families anyways, and found a solution with functional dependencies too (tho this one also with multiple parameters)
08:28:48 <parcs`> cark: great :)
08:28:51 <cark> =)
08:29:01 <cark> thanks for pointing that direction out
08:34:40 <rwbarton> byorgey: was it "functors from C x D to E are the same as functors from C to the category of functors from D to E"?
08:34:45 <rwbarton> replacing Set by Cat
08:35:26 <byorgey> rwbarton: no, I mean where C, D, and E are functors
08:35:45 <byorgey> I want to find a right adjoint to  F x -  where F is a functor
08:36:24 <rwbarton> oh
08:36:38 <rwbarton> a functor from some index category I to Set?
08:37:00 * Axman6 pokes at #haskell-in-depth 
08:37:02 <byorgey> yes, I think so
08:37:25 <rwbarton> then F x - will have a right adjoint yes
08:37:37 <rwbarton> Set^I is a topos so in particular it is cartesian closed
08:38:01 <byorgey> right, makes sense
08:38:08 <rwbarton> the formula for the adjoint is a little involved though
08:38:37 <byorgey> rwbarton: do you have any links to somewhere I can read about it?
08:39:15 <byorgey> though I seem to remember a fairly simple calculational derivation making use of the Yoneda lemma
08:39:30 <byorgey> I just can't remember where I read it
08:39:58 <rwbarton> you can calculate it using the yoneda lemma yeah
08:39:59 <rwbarton> hmm
08:42:13 <rwbarton> i don't know of a link off-hand, but it goes like this--let me say my functors are I^op -> Set so I don't get horribly confused, then if I want to know the value of G^F on the object i, by Yoneda that is Hom([i], G^F) = Hom(F x [i], G) = natural transformations from (F x (the functor represented by i)) to G
08:42:47 <jfischoff> all numbers between 0.0 and 1.0 are normalized and have the same about t
08:42:57 <jfischoff> whoops wrong window
08:46:03 <dzhus89> is there existing strict version of plain lists in Haskell?
08:46:37 <byorgey> rwbarton: ah, ok, got it. thanks!
08:46:45 <Axman6> not that i'm aware of. it's dead simple to implement though
08:47:35 <bitonic> Axman6: but you don't get the nice syntax
08:47:47 <quicksilver> I think the main reasons that people use lists relate to their laziness, though
08:47:57 <quicksilver> if don't want a tail-lazy structure maybe you don't want lists at all.
08:50:43 <Gurrag> is `:` similar to Lisp's `cons` ?
08:51:03 * hackagebot abstract-par-accelerate 0.3.3 - Provides the class ParAccelerate, nothing more.  http://hackage.haskell.org/package/abstract-par-accelerate-0.3.3 (RyanNewton)
08:51:05 * hackagebot meta-par-accelerate 0.3.5 - Support for integrated Accelerate computations within Meta-par.  http://hackage.haskell.org/package/meta-par-accelerate-0.3.5 (RyanNewton)
08:51:29 <Axman6> Gurrag: i believe so
08:51:31 <byorgey> Gurrag: yes, except it is typed.
08:51:36 <Axman6> > 1 : [2,3]
08:51:37 <lambdabot>   [1,2,3]
08:51:41 <Axman6> :t (:)
08:51:42 <lambdabot> forall a. a -> [a] -> [a]
08:51:44 <byorgey> whereas you can give any old arguments to Lisp's cons.
08:52:16 <byorgey> for example you can't use (:) to build trees or general pairs like you can in Lisp.
08:52:39 <Gurrag> Thank you
08:52:52 <quicksilver> and it's tail-lazy
08:52:56 <tgeeky> byorgey: After some chores, I think what was going on is that I was expecting that -- since the compiler had the instance (Show (t (UTerm t IntVar))) => Show (IntBindingState t)  -- that it should should understand that the RHS *always* has the LHS constraint, but that's not even true :o
08:53:04 <quicksilver> well it's totally lazy but the tail is more important :)
08:53:25 <byorgey> tgeeky: right
08:53:35 <byorgey> tgeeky: it means the RHS always *requires* the LHS constraint.
09:07:03 <roha> question: is there some higher order function like map, but for which you can specify to which elements the function should be applied. basically i need to implement some kindof for (int i = 0; i < N; i += 2) loop
09:09:22 <roha> or what could be a fast way to do such a loop in haskell with vectors?
09:09:41 <yitz> roha: 3 approaches. 1. build that test into the function you are mapping. 2. break up the list (lazily), apply to one half, then merge it back together. 3. write a map function hard-wired for the special case of 2.
09:10:06 <yitz> roha: which one is best depends on your more details of what you are trying to do.
09:10:13 <Eiam> myThing x = [ x | x<-N, even x] ?
09:10:14 <tromp_> zipWith ($) (cycle f id) ?
09:10:29 <Eiam> no
09:10:37 <Eiam> nevermind that, its checking the wrong thing ;)
09:11:42 <parcs`> snd (unzip (map f (zip [0..] xs)))
09:12:10 <roha> the way i have it now it does check in the function to be applied if it should apply it. im just unsure because of speed. what would be the fastest of your three options?
09:12:22 <roha> oh and i use unboxed vectors atm
09:12:28 <yitz> roha: they're all ok.
09:12:52 <yitz> ohh. it's not a list? you said map.
09:13:08 <roha> oh sorry, i meant Vector.map
09:13:29 <roha> i used vectors because i have to do alot of indexing in the function which i want to apply
09:14:59 <yitz> roha: for me that wouldn't be a reason to use vectors in almost any case. sounds like a premature optimization. but anyway, if you're using vectors, i suppose you could do the same thing you do in the imperative loop.
09:16:11 <roha> sorry, what do you mean with "you could do the same thing you do in the imperative loop"
09:16:43 <roha> the vectors are really big 25'000k elements or more
09:16:49 <quicksilver> just map over the constant list [0,2..]
09:17:03 <quicksilver> and use that as an index
09:17:07 <roha> i just thought O(n) indexing of lists is kind of bad for such huge lists
09:17:25 <quicksilver> into your vector
09:17:32 <yitz> well, for example, if you have a mutable vector in the ST monad, you could just map a mutation function over the even numbers to index in.
09:17:46 <quicksilver> forM_ [0,2..] $ \i -> ... do something to your vector at index i ..
09:17:50 <yitz> roha: isn't that what you're doing in C too?
09:19:07 <roha> yitz, aah ok, i haven't thought about that way to do it. i was mentally stuck on "V.map f someVector"
09:20:07 <roha> ok thanks alot, yitz, quicksilver. i'll do it that way.
09:20:31 <ski> @hoogle (i -> a -> b) -> (v i a -> v i b)
09:20:31 <lambdabot> Data.Map mapWithKey :: (k -> a -> b) -> Map k a -> Map k b
09:20:31 <lambdabot> Data.Map adjustWithKey :: Ord k => (k -> a -> a) -> k -> Map k a -> Map k a
09:20:31 <lambdabot> Data.Map intersectionWith :: Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c
09:20:40 <roha> and  a general question: can you beat/reach the speed of java with mapping etc. for pure looping
09:20:48 <roha> s/for/vs
09:20:51 <quicksilver> certainly, yes
09:20:57 <quicksilver> depends on the java compiler and VM
09:23:43 <roha> oh and one last thing: in which cases should one prefer unboxed vectors vs boxed vectors/lists?
09:25:16 <roha> for example in my case: i need to each element of a big collection of elements several hundred times
09:25:51 <roha> i need to modify each element...
09:26:27 <quicksilver> that depends on quite a lot of things
09:26:39 <quicksilver> but lists are almost never going to be the right thing for large persistant collections
09:26:54 <quicksilver> other structures you didn't mention like IntMap and Sequence will also be right for some cases
09:27:03 <quicksilver> (along with vectors and arrays)
09:28:00 <roha> do you know of any tutorial which offers an overview of the pro/cons of each structure?
09:29:22 <Franciman> roha, I think that data-structures like lists and trees are more suitable for non persistant data
09:29:46 <Franciman> because they are cheaper to be modified ( look at zippers for trees for example )
09:29:54 <quicksilver> roha: I'm pretty sure there isn't one.
09:30:11 <Franciman> vectors, arrays are more fast to be accessed
09:30:13 <quicksilver> roha: these data structures got created a vastly different times
09:30:28 <Franciman> so for persistant data they are better
09:30:56 <Franciman> *faster
09:30:58 <ClaudiusMaximus> a data-structure-opaedia would be handy
09:31:04 <Franciman> yeah quite a lot
09:31:41 <roha> yeah that would be really helpful for beginners
09:32:26 <roha> anyway, thanks alot for your help!
09:33:05 <Axman6> roha: if you need to update things a lot, then Vectors aren't a great idea, unless you use the mutable interface. if you'd prefer to stick to an immutable interface, then something like Seq or IntMap might be better (since they have O(log n) update of nodes)
09:34:05 <mm_freak> IntMap actually has O(1), but in practice it behaves like O(log n)
09:34:47 <Axman6> true
09:35:04 <Axman6> well, O(log n) until it's full no? =)
09:35:18 <mm_freak> until it's half-full
09:35:19 <roha> Axman6, If i need to modify ~half of all elements in one go, that would be ok though right?
09:35:39 <Axman6> roha: depends how you do it =)
09:35:48 <mm_freak> roha: i'd likely use immutable there
09:36:25 <Axman6> isn't there some mapWithIndex for Vector?
09:36:41 <roha> yes i just saw there indeed is
10:58:22 <FrancisB> hello friends
10:58:29 <Franciman> hi FrancisB
10:58:57 <FrancisB> hi franciman, glad to see you
10:59:05 <Franciman> glad to see you too
10:59:12 <FrancisB> thank you
10:59:25 <FrancisB> i done a session with haskell
10:59:39 <jaxtr> cool FrancisB
10:59:59 <FrancisB> hello jaxtr, thanks
11:00:17 <FrancisB> i see it is a very powerull language
11:01:33 <FrancisB> i am accustomed with lisp and scheme
11:01:43 <FrancisB> type a lot of parenthesis
11:02:25 <FrancisB> franciamn, about graphics, haskell is powerful too?
11:04:57 <ski> Scheme is a pretty little language :)
11:05:17 <Franciman> FrancisB, yes there are libs for that
11:05:18 <FrancisB> yes ski, true
11:05:26 <Franciman> like a binding for OpenGL
11:05:31 <Franciman> ( HOpenGL )
11:05:47 <FrancisB> ah yes franciman
11:06:02 <FrancisB> i will see later
11:07:16 <FrancisB> franciman, do you know graph theory?
11:07:43 <FrancisB> ski do you know scheme?
11:07:46 <Franciman> hm no
11:08:23 <FrancisB> franciman, i wanto do something in graph theory, that is why i asked about graphics
11:08:37 <ski> FrancisB : some
11:09:13 <FrancisB> ski i was able to do 900,000 factorial recursive, not tail
11:09:54 <ski> ok
11:09:56 <ski> doing SICP ?
11:10:02 <FrancisB> yes
11:10:03 <ClaudiusMaximus> there are packages like 'fgl' and 'graphviz'; and if you're into scheme/graphics you might like the 'fluxus' program
11:10:43 <ski> FrancisB : i think it might help here to consider how you (probably) would compute the factorial of a number, by-hand
11:11:11 <FrancisB> hahaha nice this ski
11:11:12 * hackagebot darcs 2.8.1 - a distributed, interactive, smart revision control system  http://hackage.haskell.org/package/darcs-2.8.1 (GaneshSittampalam)
11:11:47 <FrancisB> claudiusmaximun i turned to haskell now
11:11:58 <FrancisB> and i think i am happy
11:12:59 <ski> FrancisB : writing it tail-recursively in Haskell is basically the same
11:13:34 <FrancisB> thats good ski
11:14:08 <FrancisB> but i need to do a lot of work
11:14:32 <FrancisB> be just back
11:15:15 <EEVIAC> hmmm, when i try cabal install haddock, i get
11:15:17 <EEVIAC> cannot configure haddock-2.10.0. It requires ghc >=7.4 && <7.6
11:15:24 <EEVIAC> There is no available version of ghc that satisfies >=7.4 && <7.
11:15:44 <EEVIAC> i don't really get the ghc package, is it sort of special or something?
11:16:10 <td123> EEVIAC: 7.4 <= 7.4.1 < 7.6
11:16:17 <dcoutts> EEVIAC: this refers to ghc the library
11:16:23 <dcoutts> ghc-pkg list ghc
11:16:48 <EEVIAC> i have ghc-7.0.4
11:16:55 <geekosaur> >= 7.4 && < 7 sounds like some oter dependency is wrong
11:17:25 <EEVIAC> that's strange, ghc-pkg check says everything is ok
11:17:53 <EEVIAC> oh wait no it doesn't, i was on another computer
11:18:23 <EEVIAC> on the computer where ghc-pkg check is ok, i get that there is no available version of ghc that satisfies >=7.4 && <7.6
11:18:52 <byorgey> EEVIAC: if you have ghc-7.0.4, then you can't build haddock-2.10.0.
11:18:58 <EEVIAC> (also why isn't ghc the library on hackage?)
11:19:24 <byorgey> EEVIAC: because it's quite intimately tied to a particular installation of ghc.
11:19:27 <EEVIAC> should i install an older version of haddock?
11:19:32 <byorgey> yes
11:19:44 <byorgey> try  cabal install haddock-2.9.3
11:20:44 <byorgey> to answer your earlier question, yes, the ghc package is special.  It provides the GHC API.
11:20:52 <EEVIAC> oh, that makes sense.
11:21:43 <mrkronecker> I was hoping to write a simple adventure game in Haskell. I've been poking around, but I'm struggling to consider an appropriate functional implementation though! Can anyone recommend an intelligent approach?
11:22:36 <ski> mrkronecker : i assume you want to allow cycles in your location graph ?
11:22:40 <EEVIAC> hmmm haddock 2.9.3 fails to build though. Not in scope: data constructor ACoAxiom
11:22:46 <EEVIAC> eh, i'll figure it out
11:23:03 <mrkronecker> ski: Ah, yes.
11:23:20 <mrkronecker> ski: As in, players will be able to turn back on previous areas?
11:23:44 <ski> well, not just that, but that there can be several different paths to reach the same destination
11:24:01 <mrkronecker> ski: Ah! Yes. I do plan on this.
11:24:03 <ski> so that you can walk around a cycle that's *not* just retracing your steps
11:24:24 <ski> i made a very simple adventure game which didn't allow this, mostly as an experiment
11:25:07 <ski> but if you want this, you want to have some kind of store for keeping the current state of all the locations (things left, devices operated, locks unlocked, &c.)
11:25:51 <ski> e.g. it could be a `Map' from some kind of location identifiers to the current state of that location, also including the exists from there to other locations
11:26:03 <byorgey> mrkronecker: ll is my real family
11:26:03 <byorgey> (13:31) <   byorgey> oh, are boshac and hac boston not the same thing?
11:26:11 <byorgey> oops, mispaste
11:26:36 <byorgey> mrkronecker: http://byorgey.wordpress.com/2011/05/27/bit-rotted-text-adventure-edsl-free-to-a-good-home/    -- may give you some inspiration
11:26:57 <byorgey> no guarantees that it represents an intelligent approach.
11:27:16 <mrkronecker> Thanks for your advice! I'll read through this.
11:30:09 <FrancisB> back friend
11:30:19 <FrancisB> must go
11:30:29 <FrancisB> bye all
11:36:55 <schlicht> is there a clean way to have a second ghc (with libs) on my system (archlinux)?
11:37:09 <stobix> is it possible to write a show instance for [Foo], where Foo is a data I've created?
11:38:17 <stobix> instance Show ([Foo]) where -- generates an error
11:38:45 <Axman6> :t showList
11:38:46 <lambdabot> forall a. (Show a) => [a] -> String -> String
11:38:54 <Axman6> @src Show
11:38:55 <lambdabot> class  Show a  where
11:38:55 <lambdabot>     showsPrec :: Int -> a -> ShowS
11:38:55 <lambdabot>     show      :: a   -> String
11:38:55 <lambdabot>     showList  :: [a] -> ShowS
11:39:15 <td123> schlicht: nope
11:39:32 <schlicht> td123, :(
11:39:38 <fmap> stobix: what error?
11:39:41 <alpounet> schlicht, last time i needed that i used env variables + --with-ghc option of cabal
11:39:47 <barrucadu> shutdown_-h_now: You could install everything to /opt I suppose
11:39:51 <barrucadu> Err
11:39:57 <barrucadu> schlicht: ^
11:40:07 <fmap> stobix: i believe you need -XFlexibleInstances for that
11:40:10 <alpounet> stobix, does Foo have a Show instance?
11:40:28 <dcoutts> schlicht: yes, each ghc has versioned install dirs, and version-suffixed prog names, e.g. ghc-7.4.1
11:40:38 <dcoutts> schlicht: I've got half a dozen versions installed
11:40:55 <schlicht> dcoutts, and how do you switch between them?
11:41:07 <dcoutts> schlicht: you select it explicitly, they're all on the $PATH
11:41:15 <rasfar> schlicht, what has worked for me is to install multiple versions, then change my executable search path to select amongst them.
11:41:15 <ski> stobix : implement `showList' in `instance Show Foo where ...'
11:41:27 <dcoutts> schlicht: with distro packages, usual solution is to let your distro manage your main one, install the others in /usr/local
11:41:49 <stobix> alpounet: it does
11:41:55 <dcoutts> schlicht: e.g. $ which ghc
11:41:55 <dcoutts> /usr/bin/ghc
11:42:00 <stobix> ski: oh! Thanks, I will
11:42:00 <dcoutts> but, $ which ghc-7.4.1
11:42:00 <dcoutts> /usr/local/bin/ghc-7.4.1
11:42:11 <schlicht> dcoutts, mhm okay, i will try it :)
11:42:14 <stobix> fmap: trying to avoid that, though. ;)
11:42:20 <rasfar> I have 3 versions, 6.12 from Ubuntu package, 7.0.4 via haskell-platform installation (and the GHC compiled from source), and 7.4.1 by just installing the binary.
11:42:30 <ski> stobix : `showList' is basically a hack around this
11:42:33 <dcoutts> schlicht: then using them is easy, cabal install -w ghc-7.4.1
11:43:07 <rasfar> maybe someone will have better advice, or advise against this? it's sometimes frustrating if you forget to change your path back, or you have different paths in different terminals.
11:43:27 <schlicht> dcoutts, okay, maybe i will come back to you :)
11:43:32 <schlicht> thanks everyone!
11:47:12 <rasfar> (sorry for the duplicate advice, I'm having connection issues)
11:48:08 <gurrag> [haskell newcome here] is Control.Monad something that should be avoided for the sake of code purity?
11:48:18 <ski> gurrag : no
11:48:54 <ski> however, non-monadic code is often easier to comprehend than monadic code
11:49:03 <ski> (except when it's not ..)
11:49:37 <ski> if you find yourself writing the same boilerplate things over and other, that might be a hint that a monad could help avoid the clutter
11:49:50 <ski> (however, in some cases, other things than monads are what would help)
11:51:27 <fmap> gurrag: code purity and monads are orthogonal
11:53:49 <linduxed> can you use record syntax for algebraic data types or is that restricted to the data types with only one constructor?
11:55:04 <geekosaur> record syntax is sugar for normal ADT syntax; I would be surprised if it didn't work...
11:55:12 <otters> linduxed: you can
11:55:22 <geekosaur> the usual restrictions would apply, types must be the same for each label
11:55:49 <linduxed> ok, i'll look for an example where it's been done
11:55:51 <ClaudiusMaximus> linduxed: yes; random example from some code of mine: http://hackage.haskell.org/packages/archive/variable-precision/0.2/doc/html/Numeric-VariablePrecision-Float.html#t:DFloat
11:56:09 <ClaudiusMaximus> (probably not the best example, though)
11:56:59 <linduxed> ClaudiusMaximus: well that is a good enough example :-)
12:01:20 <Mathnerd314> I need a function overwriteCString :: String -> CStringLen -> IO ()... is there an easy way to obtain it?
12:02:06 <ClaudiusMaximus> @hoogle pokeArray
12:02:06 <lambdabot> Foreign.Marshal.Array pokeArray :: Storable a => Ptr a -> [a] -> IO ()
12:02:07 <lambdabot> Foreign.Marshal.Array pokeArray0 :: Storable a => a -> Ptr a -> [a] -> IO ()
12:02:21 <ClaudiusMaximus> but String is unicode and CString is ???
12:03:19 <ClaudiusMaximus> i'd probably go via ByteString and copying
12:03:27 <ClaudiusMaximus> @hoogle copyBytes
12:03:28 <lambdabot> Foreign.Marshal.Utils copyBytes :: Ptr a -> Ptr a -> Int -> IO ()
12:05:53 <dmwit> jfischoff: A Term is a textual representation of a (graphical) wiring diagram.
12:06:49 <dmwit> All the "programs" written in PEE will be Haskell values of type Term.
12:10:18 <dmwit> jfischoff: Just saw your pull request. I'll look at it shortly.
12:10:27 <dmwit> The text in the request isn't quite accurate, though.
12:10:59 <dmwit> The machine reads in Terms (programs) and Values (inputs) and produces Values (outputs).
12:52:18 <gngng> ciao
12:52:27 <gngng> !lista
12:52:44 <JoeyA> I want to write a parser with very simple rules for indentation syntax.
12:53:06 <JoeyA> If the line starts with whitespace, then it's "indented".  Otherwise' it's not.  I don't care about the width of indentation.
12:53:29 <JoeyA> Second, I want to discard trailing whitespace on each line.
12:54:11 <JoeyA> I wrote a Parsec parser for the contents of a line.  I'm wondering what a good approach would be to support parsing the entire document.
12:56:06 <JoeyA> It wouldn't make much sense to write a "tokenize" function that returns [(Bool, String)] (a list of trimmed lines and their indentedness), since the parser is interested in the contents of the lines.
12:58:47 <ymasory> where are the functions for dealing with the file system?
12:59:09 <JoeyA> System.Directory
12:59:19 <ymasory> thank you
12:59:20 <JoeyA> (in the directory package)
13:00:17 <JoeyA> There's also System.FilePath, for working with file paths in a platform-independent fashion.
13:04:12 <JoeyA> I suppose I could wrap my per-line parser with code that breaks the string into lines, detects indentation, and lines, and sets input position on each line.
13:04:39 <roha> can somebody tell me why i can't get an element of a mutable array like this:
13:04:42 <schlicht> dcoutts, i install another version of ghc to /usr/local, and thats works sofar, but runhaskell doesnt find Control.Monad.State, mtl is install for the version in local
13:04:43 <hpaste> roha pasted “get element of mutable vector” at http://hpaste.org/68515
13:04:55 <schlicht> any idea?
13:05:27 <roha> this is where read is defined: http://hackage.haskell.org/packages/archive/vector/0.9.1/doc/html/Data-Vector-Unboxed-Mutable.html#t:MVector
13:07:08 <twanvl> roha: why do you use liftM2?
13:07:20 <JoeyA> roha: What versions of GHC did you try it on?
13:07:50 <twanvl> I would expect just MV.read x 2, assuming that x :: MVector IO a
13:08:02 <roha> i wanted to lift read into the IO mona dto apply it to the vector in the IO monad
13:08:27 <roha> x has type IO (Vector Realworld a)
13:08:59 <twanvl> liftM is for non-monadic functions, but read is monadic
13:09:17 <twanvl> you x returns a new vector each time
13:09:30 <roha> i got it from a list through:           V.thaw $ V.fromList someList,   where V is = Data.Vector.Unboxed
13:09:51 <JoeyA> roha: what does :t x say?
13:09:58 <twanvl> you could do {vec <- x; MV.read vec 2 }
13:10:11 <roha> x :: IO (V.MVector GHC.Prim.RealWorld Int)
13:10:53 <roha> i got it through: let x = V.thaw $ V.fromList [1..1000] :: IO (V.MVector GHC.Prim.RealWorld Int)
13:13:12 <roha> JoeyA, sorry about the GHC Version: Its 7.4.1
13:13:15 <JoeyA> roha: Different types of MVectors, apparently.
13:13:25 <JoeyA> err
13:13:30 <JoeyA> I guess V is importing Unboxed?
13:13:41 <roha> yes
13:13:53 <JoeyA> Okay, I get the same thing
13:15:54 <roha> Any idea how i could index such a vector?
13:19:09 <hpaste> “Joey Adams” annotated “get element of mutable vector” with “get element of mutable vector (annotation)” at http://hpaste.org/68515#a68516
13:19:23 <JoeyA> Works with an explicit type signature.  I wonder if this is a bug in the type checker.
13:19:29 <JoeyA> roha: ^
13:20:53 <JoeyA> Oh, liftM2 takes a pure function and applies it, while MV.read is an action.  That's why y is an action rather than a value.
13:22:10 <tac> @type Data.Vector.Unboxed.thaw
13:22:11 <lambdabot> Couldn't find qualified module.
13:22:17 <tac> @type thaw
13:22:18 <lambdabot> Not in scope: `thaw'
13:22:30 <ski> @index thaw
13:22:31 <lambdabot> Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable
13:22:31 <tac> lambdabot: we're going to have problems, lambdabot....
13:22:48 <ski> @type Data.Array.MArray.thaw
13:22:48 <tac> thank you ski
13:22:49 <lambdabot> forall (a :: * -> * -> *) i e (m :: * -> *) (b :: * -> * -> *). (Ix i, Data.Array.Base.IArray a e, Data.Array.Base.MArray b e m) => a i e -> m (b i e)
13:23:08 * moebius_eye is confused
13:23:30 <tac> Who thought lifting the index into a typeclass was a good idea >_>
13:23:30 <JoeyA> Okay, so liftM2 MV.read x (return 2) returns an action.
13:23:44 <c_wraith> moebius_eye: that happens sometimes with haskell.
13:23:59 <ski> tac : multidimensional arrays
13:24:05 <JoeyA> join $ liftM2 MV.read x (return 2) is of type IO Int
13:24:14 <moebius_eye> c_wraith: I'm new to haskell. I've been looking for the good tutorial for days now.
13:24:20 <c_wraith> @where lyah
13:24:21 <ski> @where LYAH
13:24:21 <lambdabot> http://www.learnyouahaskell.com/
13:24:21 <lambdabot> http://www.learnyouahaskell.com/
13:24:23 <c_wraith> haha
13:24:28 <ski> moebius_eye : how about that one ?
13:24:29 <c_wraith> That's probably the best starting point
13:25:12 <moebius_eye> Thanks. :) I was playing around with http://tryhaskell.org/ (didn't help much)
13:25:17 <roha> JoeyA, In which Monad was the returned Int wrapped?
13:25:45 <roha> I suppose join got the IO Int out of there
13:26:03 <dcoutts_> schlicht: all the libs are independent for each ghc instance
13:26:23 <tac> moebius_eye: in case you haven't noticed, lambdabot is also a haskell evaluator. One that you can share code with in the channel
13:26:25 <tac> > 1 + 1
13:26:26 <lambdabot>   2
13:26:31 <tac> > tail [1,2,3,4,5]
13:26:31 <lambdabot>   [2,3,4,5]
13:26:36 <hpaste> “Joey Adams” annotated “get element of mutable vector” with “get element of mutable vector (annotation) (annotation)” at http://hpaste.org/68515#a68517
13:26:56 <ski> JoeyA : is there a reason you don't do `x <- ...' in that paste ?
13:27:19 <JoeyA> ski: It's being passed to liftM2
13:27:27 <ski> why ?
13:28:25 <JoeyA> There are actually two type errors (GHC doesn't show the second, for some reason)
13:28:28 <moebius_eye> tac thanks :)
13:28:43 <JoeyA> In GHCi, you can say 3 :: Int and return 3 :: IO Int, and it'll print 3 either way.
13:28:47 <moebius_eye> > map toUpper "great"
13:28:48 <lambdabot>   "GREAT"
13:28:53 <JoeyA> But if you say return (return 3) :: IO (IO Int), you get a type error.
13:28:56 <moebius_eye> YAY! :D
13:29:11 <JoeyA> liftM2 MV.read x $ return 2 returns IO (m Int), with some constraints on m.
13:29:24 <JoeyA> So the real error is that GHCi can't print that.
13:29:46 <JoeyA> But for some reason, it fails to see that m has to be IO.
13:29:46 <tac> JoeyA: With do notation, ideally, you ought to avoid a doubled-up monad
13:30:05 <hpaste> ski annotated “get element of mutable vector” with “is there anything wrong with this ?” at http://hpaste.org/68515#a68518
13:30:48 <ski> JoeyA,roha : ^
13:31:21 * hackagebot wxc 0.90.0.3 - wxHaskell C++ wrapper  http://hackage.haskell.org/package/wxc-0.90.0.3 (JeremyODonoghue)
13:31:39 <roha> JoeyA, ski, thanks!
13:32:52 <ski> roha : generally, when you're calling something of type `Blah -> Bleh -> IO Bloh', you usually want `x <- ...' rather than `let x = ...', inside a `do'-block
13:33:25 <schlicht> dcoutts_, yeah i reinstall it for both version... just removed the version from my distro and using online self build and cabal, maybe that works
13:36:23 * hackagebot wxcore 0.90.0.1 - wxHaskell core  http://hackage.haskell.org/package/wxcore-0.90.0.1 (JeremyODonoghue)
13:36:25 * hackagebot wx 0.90.0.1 - wxHaskell  http://hackage.haskell.org/package/wx-0.90.0.1 (JeremyODonoghue)
13:50:24 <ArchGT> (|z"jy4FuS+ZJ
13:50:32 <ArchGT> ups
13:50:40 <geekosaur> there's a password change in the making...
13:50:49 <ArchGT> sadly
13:51:13 <yan_> haha
13:51:14 <ski> ..either that, or a new programming language
13:51:19 <yan_> someone's writing APL
13:57:49 <donri> ArchGT: http://xkcd.com/936/
13:58:35 <ArchGT> donri: I prefer diceware
14:11:23 * hackagebot bifunctors 0.1.3.3 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-0.1.3.3 (EdwardKmett)
14:16:27 <Alan> ski: i didn't get anywhere :(
14:16:49 <ski> ):
14:17:22 <Alan> ski: i still can't work out how to have things on the left-hand-side
14:18:00 <Alan> ski: and it seems i can't actually treat constructors as values on the LHS of a function
14:18:36 <moebius_eye> > shout s = map toUpper ( unwords ( map (++" !")  words ( s ) ) )
14:18:37 <lambdabot>   <no location info>: parse error on input `='
14:18:47 <moebius_eye> > let shout s = map toUpper ( unwords ( map (++" !")  words ( s ) ) )
14:18:48 <lambdabot>   not an expression: `let shout s = map toUpper ( unwords ( map (++" !")  wor...
14:19:27 <ski> Alan : example ?
14:20:04 <ski> > let shout s = map toUpper (unwords (map (++ " !")  words s))  in  shout "hello there"
14:20:05 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]]'
14:20:06 <lambdabot>         against inferred ...
14:20:07 <Alan> ski: i can't do "opcode LDBI = 0x0"
14:20:21 <ski> > let shout s = map toUpper (unwords (map (++ " !") (words s)))  in  shout "hello there"
14:20:23 <lambdabot>   "HELLO ! THERE !"
14:20:41 <ski> > let shout s = (map toUpper . unwords . map (++ " !") . words) s  in  shout "hello there"
14:20:42 <lambdabot>   "HELLO ! THERE !"
14:20:49 <ski> > let shout = map toUpper . unwords . map (++ " !") . words  in  shout "hello there"
14:20:51 <lambdabot>   "HELLO ! THERE !"
14:20:52 <tac> @src unwords
14:20:52 <lambdabot> unwords [] = ""
14:20:53 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
14:21:52 <homie> let shout = map toUpper . unwords . map (++ " !") . words  in  shout "are you ok?"
14:21:53 <moebius_eye> thanks ski :)
14:22:09 <homie> let shout = map toUpper . unwords . map (++ " !") . words  in  shout "how are you"
14:22:26 <moebius_eye> homie: you need to use ">"
14:22:40 <moebius_eye> > let shout = map toUpper . unwords . map (++ " !") . words  in  shout "how are you"
14:22:42 <lambdabot>   "HOW ! ARE ! YOU !"
14:22:49 <Alan> ski: making a "data Codec a = Codec { encoder :: a -> Chunk, decoder :: Chunk -> a }" helps a little bit, except there's still no way to decide which decoder to use without already knowing which decoder to use...
14:23:00 <homie> > let shout s = map toUpper (unwords (map (++ " !") (words s)))  in  shout "hello there"
14:23:02 <lambdabot>   "HELLO ! THERE !"
14:23:11 <homie> > let shout s = map toUpper (unwords (map (++ " !") (words s)))  in  shout "how are you?"
14:23:13 <lambdabot>   "HOW ! ARE ! YOU? !"
14:23:37 <homie> hmm ok
14:24:56 <moebius_eye> There's one thing I need to know...
14:25:07 <moebius_eye> How do I create a haskell script??
14:25:35 <moebius_eye> I mean, a *multiline* program with more than just on line in the main
14:25:45 <adimit> does anyone have a clue if/how I could use solr from within haskell?
14:26:08 <adimit> (or lucene, for that matter.)
14:26:12 <ski> Alan : hm
14:26:24 * hackagebot data-nat 0.1 - data Nat = Zero | Succ Nat  http://hackage.haskell.org/package/data-nat-0.1 (GaborLehel)
14:26:30 <ski> Alan : example of why `opcode LDBI = 0x0' doesn't work ?
14:27:18 <rwbarton> moebius_eye: with do notation? having trouble imagining what kind of difficulties you are having
14:28:30 <geekosaur> rwbarton, indentation comes to mind
14:30:47 <ski> Alan : hm, i suppose maybe you're having general parsing problems ?
14:31:30 <Alan> ski: well the type checker tells me that for "data I = A Int", A isn't actually of type (a -> I)
14:32:12 <ski> it's of type `Int -> I', yes
14:32:30 <moebius_eye> I just want to define a few fonctions and call them one by one. But I get weird error messages.
14:32:31 <Alan> foo :: (Int -> Foo) -> Int
14:32:35 <ski> (i'm not sure what you expected there)
14:32:38 <moebius_eye> Such as this:     Couldn't match expected type `IO t'
14:32:39 <Alan> foo Bar = 0x0
14:32:50 <ski> moebius_eye : hpaste the code ?
14:32:54 <donri> moebius_eye: hpaste.org your code
14:32:55 <Alan>     Couldn't match expected type `Int -> Foo' with actual type `Foo'
14:32:55 <Alan>     In the pattern: Bar
14:32:57 <Alan>     In an equation for `foo': foo Bar = 0
14:33:16 <ski> Alan : right, you can only match on completely applied constructors
14:33:23 <rwbarton> weird error message
14:33:23 <Alan> ski: exactly my point
14:33:37 <hpaste> moebius_eye pasted “this is sparta” at http://hpaste.org/68522
14:33:52 <ski> Alan : which was partly why i suggested decoupling the instruction, proper, from the operands
14:33:54 <moebius_eye> Nice! :D I really like this channel! :)
14:33:57 <donri> you can do Foo{} to match the constructor i think
14:34:14 <ski> Alan : and to do that sanely in this case, you need GADTs
14:34:17 <Alan> ski: you mean actually so an instruction is actually an (Opcode, Operands) pair?
14:34:26 <ski> Alan : more or less, yes
14:34:28 <donri> moebius_eye: putStrLn
14:34:54 <ski> Alan : still, i'm not sure of in which context you want to match on `Bar' above -- maybe there's another way out
14:35:06 <donri> moebius_eye: http://www.haskell.org/haskellwiki/Introduction_to_IO
14:36:21 <ski> moebius_eye : elaborating on what donri said, you want `main = putStrLn (shout ...)'
14:37:18 <Alan> ski: ok, let me put it as simply as i can - I want to match an argument against a value without that value being directly in the LHS
14:37:30 <ski> ok
14:37:42 <Alan> because if that value has to be DIRECTLY in the LHS, then it must be a duplicate of a RHS of the same value somewhere
14:37:45 <ski> you can do that with `case' (or a local definition in `let'/`where')
14:38:41 <Alan> ski: case x of (opcode LDBI) ?
14:39:24 <Alan> ski: won't that be both horrible and really bad performance?
14:39:25 <ski> however, you will probably need to merge defining equations, since it commits to an equation as soon as the patterns in the definiendum matches (as well as guards being true, if any)
14:39:42 <moebius_eye> Why do I need parentheses???
14:39:49 <ski> moebius_eye : where ?
14:39:52 <Alan> ski: also, i think i was failing to understand how GADTs would help with the problem... i think i understand them, but since I don't know what you were getting at i possibly don't
14:40:13 <moebius_eye> in putStrLn ( shout "this is sparta" )
14:40:14 <ski> Alan : you can't really put `opcode LDBI' inside a pattern
14:40:39 <Alan> ski: so it's still the same problem? I can't get the opcode value to match against
14:40:43 <ski> (it would be possible to use a view pattern, but i'm not sure you want to do that)
14:40:46 <Alan> without writing it twice
14:40:46 <moebius_eye> Oh, I get it: a function can be an argument to a function. Disambiguation, YadaYada. ^^
14:40:56 * ski isn't really seeing the big picture here
14:41:16 <ski> moebius_eye : *nod*
14:41:38 <ski> > map (map succ) [[],[0],[1,2],[3,4,5],[6,7,8,9]]
14:41:39 <lambdabot>   [[],[1],[2,3],[4,5,6],[7,8,9,10]]
14:42:05 <donri> .o(...haskell without first-order functions...?)
14:42:30 <donri> did i just accidentally first-class and higher-order
14:42:56 <ski> Alan : what i was considering was writing a function which takes an opcode, and the corresponding instruction bits, and creates a `Codes ...' thing which when given one gives the other
14:43:46 * ski hopes that's not too vague to be intelligble
14:44:03 <Alan> ski: is there any chance you could make an example?
14:44:13 <Alan> I'm still not entirely sure I understand
14:44:23 * ski isn't either .. :/
14:45:04 <Alan> also, one of my constraints is that I don't want my Instruction type to be capable of holding invalid instructions
14:45:13 <Alan> which is why i don't have (Instruction, Operands)
14:45:18 * ski nods
14:45:39 <ski> (but if you use GADTs, you won't have that problem, even if you use that representation)
14:45:42 <Alan> it's just so silly that I can't seem to find a way to avoid repeated instances of numeric constants
14:46:21 <ski> hm, should i refresh <Asm.lhs> ?
14:46:32 <Alan> ski: possibly :P
14:46:45 <Alan> I think i just added some stuff at the bottom
14:46:51 <Alan> nothing that actually worked
14:47:26 <ski> (i would skip the `a' argument to `codec')
14:50:10 <ski> hm, who decides how to split the chunks which are passed to `decodeInstruction' ?
14:50:50 <ski> hm, ok, so you start by `4'
14:54:03 <ski> hm, i think to combine the two directions, we need another way to combine the multiple cases, meaning parsing of some kind
14:56:24 * hackagebot hirt 0.0.1.1 - Calculates IRT 2PL and 3PL models  http://hackage.haskell.org/package/hirt-0.0.1.1 (IvanLabath)
15:01:34 <Alan> ski: i'm thoroughly lost :\
15:12:32 * ski is pondering the code, attempting some experiments
15:13:08 <dolio> @brain
15:13:09 <lambdabot> I think so, Brain, but a codpiece made from a real fish would get smelly after a while, wouldn?t it?
15:13:18 <edwardk> @tell mm_freak you can only make it a profunctor if you generalize profunctor to other categories
15:13:19 <lambdabot> Consider it noted.
15:15:25 <c_wraith> @hoogle IsString
15:15:26 <lambdabot> Data.String class IsString a
15:15:26 <lambdabot> GHC.Exts class IsString a
15:17:58 <Alan> ski: :)
15:18:14 <Alan> ski: am I being unreasonable? should i settle for writing the constants twice?
15:18:46 <ski> i don't think you're unreasonable
15:19:06 <Alan> is it just an awkward edge case for pure functional programming?
15:19:15 <ski> i'm pondering whether to throw out the "try four bits at a time" thing
15:19:44 <ski> well, i think i can do this with a parser -- i'm just pondering how to not make it more complicated than necessary
15:20:11 <ski> e.g. it'd be nice to get away with not having error recovery in the parser, i think
15:20:16 <Alan> ski: the "try 4 bits at a time" thing is currently the only way i've come up with for handling variable-length opcodes, because you don't actually know where to split the instruction in advance
15:20:37 <vaflis> is there a Haskell library I could use to feed a [(a, b)] and it would generate me an image graph of it?
15:21:02 <ski> Alan : ok, so i'll try without that, then
15:21:03 <vaflis> well, [(Integer, Int)] actually
15:23:56 <vaflis> ok, Chart
15:28:14 <ski> atm you're using `undefined' in case the decoding fails
15:28:29 <ski> if one wanted to, one could add some error reporting
15:29:26 <Alan> ski: indeed
15:29:52 <Alan> ski: like i said earlier, my main issue was getting the bidirectional conversion working before caring too much about the friendliness of it
15:34:00 <ski> (hm -- do i need a separate type of parsers ?)
15:35:53 <Alan> ski: i'd be interested to see what kind of thing you're making
15:38:18 <Veinor> https://github.com/veinor/sandboxer i wrote this a while ago for managing cabal-dev sandboxes, igured it might be useful
15:39:52 <mKarpis> Hi, please is here anybody from AI team?
15:42:01 <Alan> can you test for equality between functions?
15:42:14 <Alan> > id == id
15:42:15 <lambdabot>   *Exception: (==): No overloading for function
15:42:18 <ski> not really
15:42:23 <Peaker> Alan, in general, no.  in some specific cases, ya
15:42:28 <ski> (in some cases you can, but mostly not)
15:42:37 <Alan> ok
15:43:34 <Alan> so at the very least for any kind of bidirectional map i need something that is a substitute for my instruction constructors
15:43:40 <Alan> rather than the constructors themselves...
15:45:12 * ski is currently trying to massage the code into something which is better suited to merge
15:46:26 * hackagebot dyre 0.8.7 - Dynamic reconfiguration in Haskell  http://hackage.haskell.org/package/dyre-0.8.7 (WillDonnelly)
15:47:06 <Alan> ski: i really need to get some sleep now :(
15:47:08 <ski> hm, so now i will try with `choices :: [(Chunk,Parser a)] -> Parser a'
15:47:13 <ski> Alan : ok
15:47:40 <ski> Alan : i'm pondering adding a new type `Parser'
15:47:47 <ski> it will make things nicer, but more abstract
15:47:50 <Alan> feel free to PM me with whatver though, i'll see it in the morning
15:48:06 <ski> i'm not sure if you prefer more ugly, but easier to follow
15:48:33 <ski> (easier to follow for one who isn't used to applicative functors and/or monads, i.e.)
15:48:53 <Alan> ski: i'm fairly confident i grasp applicative functors and monas now
15:49:13 <Alan> and as you might have seen, i've used parsec already (AsmParser is very out of sync with Asm now though)
15:49:24 <ski> ok
15:49:30 <Alan> but mainly it's just this duplication of information that I want to solve
15:49:35 <ski> so then i'll not spare the abstractions
15:49:37 * ski nods
15:49:45 <ski> that's the main point i'm wanting to reach here
15:49:59 <ski> i just want to first make the decoding compositional
15:50:10 <Alan> because i just know i'm going to get screwed over if (decode . encode) != id
15:50:10 <ski> so that i can follow up with the `Codec' idea properly
15:50:21 * ski nods
15:50:29 <Alan> and that's easy to do with an opcode typo
15:50:34 <ski> indeed
15:50:38 <Alan> and/or changing an opcode in just one place
15:50:55 <Alan> compositional decoding sounds very good
15:50:58 <Peaker> I might be out of context, but aren't pickler combinators relevant here?
15:51:08 <Alan> I probably would have gotten there eventually
15:51:10 <ski> we have `Eq Chunk', which i'm going to utilize
15:51:36 <ski> Peaker : quite possibly
15:51:44 * ski is trying to work with the existing code
15:51:48 <Alan> ski: also feel free to replace Chunk if you think there is a better abstraction - I created it just because i wanted something i could append/split bitwise
15:52:15 <Alan> hence it being a Monoid
15:52:38 <ski> i think i don't need to change it here
15:53:10 <Alan> i think i should try to read the pickler combinators paper again
15:53:11 <ski> btw, do you mind if i paste the resulting code on a paste-site ?
15:53:17 <Alan> at a skim-read i didn't really grasp it
15:53:20 <ski> (should i make it expire after a while ?)
15:53:44 <Alan> ski: I don't hugely care - this is public domain as far as i'm concerned, i'm just building stuff for the fun of it
15:53:53 <ski> ok *nod*
15:54:58 <Alan> ski: my eventual goal is to have built a CPU architecture, compiler and operating system, "from scratch"
15:55:05 <Alan> but just all as a learning exercise
15:55:16 <Alan> although not a good sign if i'm getting bogged down in instruction encoding :P
15:55:29 <Alan> anyway, really must go to bed
15:55:42 <Alan> getting old, 7 hours isn't enough sleep :|
15:55:46 * Alan longs to be a student again
15:56:01 <Alan> except, you know, the bit where having no money and lots of deadlines sucks
15:56:08 <Peaker> I think older ppl need less sleep
15:58:04 <Alan> also, taking another look at pickler combinators, that's somewhat what i'm trying to do, yet it doesn't solve the problem
15:58:25 <Alan> composition isn't the big problem (althoug it sounds like ski is solving that one too)
15:58:39 <Alan> it's defining the values of the primitives in a non-duplicating way
16:00:14 <Alan> but seriously, going to sleep now!
16:00:29 <Alan> thanks ski , i'm sure i'll talk to you again tomorrow
16:01:18 <ski> yw
16:05:30 * ski realizes he has tea waiting ..
16:29:50 <hpaste> da-x pasted “Pure logging” at http://hpaste.org/68523
16:30:30 <kallisti> anyone know of a version of System.Directory.getModificationTime that doesn't use old-time?
16:33:16 <kallisti> it seems impossible to avoid old-time :P
16:35:19 <Peaker> da-x, for debug, Debug.Trace is acceptable..
16:35:56 <da-x> Peaker: oh, just sent you the E-Mail
16:36:54 <Peaker> da-x, STT seems fundamentally wrong to me too
16:37:09 <da-x> Debug.Trace - "They should not be used in production code."
16:37:12 <da-x> acceptable?
16:37:54 <Peaker> "for debug" implies not in prod. code mostly :)
16:38:29 <da-x> It doesn't look like a clean approach to me
16:38:46 <aristid> da-x: it's fine for debugging.
16:38:56 <Peaker> da-x, it's not.. the typical logging approach is a WriterT
16:39:34 <Peaker> where the monoid is a log, which can be an action (e.g: putStrLn) or a list of logs
16:40:27 <Peaker> da-x, then when you run the writert you can use/discard the log
16:40:35 <da-x> it doesn't always work out well if you have huge amount of logging
16:40:49 <ski> (`STT' ?)
16:41:03 <Peaker> ski, broken ST transformer
16:41:07 <kallisti> okay I no longer have any clue what's going on...
16:41:14 <ski> broken `ST' transformer is broken, yes
16:41:27 <da-x> what's wrong with having the code polymorphic about how it does the logging?
16:41:33 <kallisti> I rewrote code from zip-archive to use strict bytestring IO, and I'm still getting "resource exhausted (Too many open files)"
16:41:34 <da-x> maybe it can be done without STT?
16:41:38 <Peaker> da-x, the action monoid approach shouldn't be problematic I think
16:41:42 <da-x> but I really like ST
16:42:29 <Peaker> da-x, sure, you can wrap ST with some monad transformer that can be an instance of your class
16:42:40 <Peaker> (e.g: the WriterT)
16:43:09 <da-x> oh why didn't I do that
16:43:51 * da-x <- http://weknowmemes.com/wp-content/uploads/2012/03/genius-rage-face.png
16:43:58 <kallisti> is there a way I could get more debug info about open file handles?
16:44:39 <Peaker> Kind error, genius-rage-face.png :: *, expected * -> *
16:45:41 <hpc> whoa, STT
16:45:50 <hpc> is that even safe?
16:45:54 <kallisti> no
16:46:11 * hpc is surprised it exists
16:46:38 <Peaker> it doesn't correctly exist
16:46:44 * kallisti has absolutely no idea why this bug exists now.
16:46:44 <kallisti> strict bytestring IO is... strict... right?
16:47:02 <Peaker> kallisti, IME
16:47:36 <hpc> kallisti: strict bytestrings exist either as totally unevaluated or totally evaluated, so yes, i suppose
16:48:09 <hpc> hGetContents will still be "lazy IO", but once you read even a single byte, you block on the whole thing
16:48:18 <kallisti> ah there we go I think I got it.
16:48:31 <kallisti> now it's a memory leak.
16:48:33 <kallisti> excellent.
16:49:54 <hpc> kallisti: if your program is a big loop, and you've accounted for leaks where your state gets enormous, try looking for "hanging noops"
16:50:04 <hpc> stuff like foo = do {bar; foo; return ()}
16:50:34 <kallisti> er, why.
16:50:50 <hpc> each iteration of the loop tacks a (>> return ()) onto the end
16:50:54 <kallisti> I think my state is just getting enormous
16:50:59 <hpc> ah, k
16:51:16 <hpc> eventually you end up with >> return () >> return () >> ...
16:51:19 <kallisti> because I'm using strict bytestring IO to create a list of zip-file entries
16:51:22 <kallisti> which I think turn into a zip-file
16:51:28 <kallisti> but I'm doing this recursively on a Firefox profile.
16:51:30 <kallisti> which is a lot of data.
16:51:36 <hpc> heh
16:51:38 <kallisti> but
16:51:42 <kallisti> if I use lazy bytestring IO
16:51:45 <kallisti> I run out of file handles.
16:51:47 <kallisti> lose-lose.
16:54:37 <kallisti> time to try a different approach
16:55:09 <Eduard_Munteanu> Mm, what happens if you don't initialize all values of an UArray? Default to a sensible value? (say, zero for Int)
16:56:31 * hackagebot static-resources 0.1.1 - JavaScript and Css files concat for http optimization  http://hackage.haskell.org/package/static-resources-0.1.1 (MariuszRak)
16:56:43 <kallisti> Eduard_Munteanu: might have to go source diving to find out.
16:56:49 <kallisti> it may just expose whatever data as already there
16:56:52 <kallisti> C-style
16:58:04 <Eduard_Munteanu> Hm, looks like it.
16:58:13 <Eduard_Munteanu> This should really be documented.
16:58:47 <kallisti> Eduard_Munteanu: if that's the case then in some system configurations it could actually initialize to zero
16:58:48 <hpc> when it's not documented, assume the system is actively working against you
16:59:18 <kallisti> in other words it's system dependent
16:59:20 <kallisti> what happens
17:01:34 * hackagebot static-resources 0.1.2 - JavaScript and Css files concat for http optimization  http://hackage.haskell.org/package/static-resources-0.1.2 (MariuszRak)
17:02:15 <hpc> someone needs to tell MariuszRak how HTTP/1.1 works
17:02:21 <hpc> :P
17:05:17 <jfischoff> what are people using to manage dependencies the building of multiple cabal packages?
17:07:43 <hpc> jfischoff: i use cabal ;)
17:08:17 <monochrom> HTTP/1.1 is quite complex
17:08:33 <hpc> i just keep a mental list of which packages are the tricky ones, and make sure those are installed --global
17:08:37 <hpc> so the problem is solved forever
17:09:17 <hpc> monochrom: the ability to reuse an existing connection for multiple resources should already be well-known
17:09:37 <hpc> there's no overhead for many small files, and it's better for caching
17:12:45 <EEVIAC> hey what's that trick from RWH for getting the head of a list as a Maybe value
17:13:00 <hpc> listToMaybe
17:13:02 <mauke> @hoogle [a] -> Maybe a
17:13:02 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
17:13:02 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
17:13:03 <lambdabot> Prelude head :: [a] -> a
17:13:17 <EEVIAC> yeah, there's that
17:13:21 <hpc> if you're feeling extra evil, use unsafeCoerce, and accept the fact that you get different behavior in ghc vs ghci
17:13:24 <hpc> :D
17:21:54 * ski . o O ( "`unsafeCoerce' -- when you're feeling extra evil" )
17:22:40 <kallisti> I wonder how efficiently I can take an existing list of filepaths and transform it into a filesystem tree.
17:26:22 <jamiltron> Is there already a function for finding the index of the first element in a [Maybe Int] that is not Nothing?
17:27:01 <kallisti> listToMaybe . dropWhile isNothing
17:27:23 <jamiltron> kallisti: Nice, thank you!
17:28:32 <monochrom> head . catMaybes
17:29:00 <monochrom> except, head is nasty in case it receives the empty list.
17:29:19 <monochrom> listToMaybe . catMaybes -- ironically! :)
17:29:47 <byorgey> jamiltron: you want to find the *inderx* of the first non-Nothing element, or just the element itself?
17:29:52 <jamiltron> Yes
17:29:53 <kallisti> yeah but dropWhile isNothing is more efficient in the off-chance that you're accidentally using a strict dialect of Haskell.
17:30:07 <jamiltron> byorgey: Yes
17:30:17 <byorgey> jamiltron: yes to which?
17:30:44 <kallisti> you can't find just the index.
17:30:45 <monochrom> well, I guess the original question already said "index"
17:30:47 <kallisti> because it may not exist.
17:30:52 <jamiltron> byorgey: Sorry, I want to find the index.
17:30:59 <kallisti> you need to find a Maybe Int
17:31:04 <kallisti> otherwise your function is partial.
17:31:04 <byorgey> that's why I was clarifying. because it seems no one else read the question carefully.
17:31:26 <kallisti> sure I did. I just answered with the best answer. You can't just return an Int from such a thing.
17:31:29 <kallisti> :)
17:31:34 <byorgey> jamiltron: try  elemIndex isJust
17:31:39 <geekosaur> part of it is that any time you want the index of something in a ist, you need to consider if a list is really what you want
17:31:51 <geekosaur> in a list
17:32:08 <jamiltron> geekosaur: What would the alternative be?
17:32:29 <monochrom> the dual of the XY Problem is the XY Solution: you ask question X, we answer question Y :)
17:32:42 <byorgey> jamiltron: it depends. why do you need the index? what are you going to do with it?
17:32:59 <byorgey> monochrom: indeed =)
17:33:17 <ku> do people deploy haskell web apps on heroku?
17:33:20 <dmwit> :t findIndex
17:33:21 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
17:33:28 <geekosaur> lists ae singly linked lists, they work best when you go through the whole thing; random access / indexing is usually an indication that you want smething wth a more efficient indexing mechanism.  if it really needs to be a flat index thing, use an array or a Vector; sometimes Map is more appropriate, although at first guess probably not here
17:33:35 <byorgey> oh, yeah, I meant findIndex, not elemIndex
17:33:38 <byorgey> thanks dmwit
17:33:38 <jamiltron> byorgey: I was intending on using it as an identifier for values.
17:34:01 <jamiltron> dmwit: findIndex is exactly what I was looking for, thank you!
17:34:53 <jamiltron> geekosaur : An array is probably more what I am looking for, to be honest.
17:35:05 <kallisti> maybe
17:35:22 <kallisti> Vector is basically just an efficient array type
17:36:27 <jamiltron> I assume the Numeric Haskell: A Vector tutorial on the haskell wiki is the best source for investigating vectors?
17:36:41 <kallisti> I guess I just assume people don't use linked lists like arrays, and they it contains Maybe Int...
17:36:56 <kallisti> jamiltron: I would just look at the documentation for Vector
17:37:00 <kallisti> that basically tells you anything you need to know.
17:37:13 <kallisti> not everything needs a tutorial.
17:39:04 <jamiltron> kallisti: Thank you
17:39:16 <kallisti> jamiltron: a common theme with data structure code is that they reuse a lot of function names
17:39:24 <kallisti> that already exist in other modules. so you may want to qualify your import
17:39:30 <kallisti> import qualified Data.Vector as V
17:40:44 <nrnrnr> I have a question about acid-state.
17:41:05 <nrnrnr> I notice that Data.Acid.Remote, when it opens a Unix domain socket, makes that socket world writable.
17:41:17 <nrnrnr> Is there a way I can change the default permissions on that socket?
17:42:33 <geekosaur> not really, aside from changing your umask; bind() on AF_LOCAL sockets doesn't provide a way to set the initial permissions
17:43:01 <geekosaur> thatis, acid-state is just reflecting the same lack of ability to set it that's in the native mechanism
17:43:19 <nrnrnr> OK, good; that saves me the trouble of looking for something fancy.
17:43:37 <nrnrnr> I can just be sure that my app sets a restrictive umask before creating the socket.  Thanks!!
17:45:09 <nrnrnr> Or maybe I can change the permissions on the socket after it is open...
17:46:41 <stepkut> nrnrnr: I think there should really be a version of openRemote that allows you to pass in a Socket you have already openned -- but I don't think that exists yet
17:47:43 <ku> does anyone have advice for deploying haskell web apps?
17:48:07 <donri> ku: that's quite a broad question :)
17:49:21 <jfischoff> ku: did you see this? http://www.yesodweb.com/blog/2012/05/keter-app-deployment
17:52:13 <dabblego> I advise, just do it! :)
17:52:41 <nrnrnr> stepkut: I agree.  Also, it turns out that there is no way to perform an action after acidServer opens the socket but efore it starts serving
17:52:54 <nrnrnr> I will talk to lemmih.
17:53:46 <ku> jfischoff: interesting, I'd only seen this before:http://www.yesodweb.com/blog/2011/07/haskell-on-heroku
17:54:21 <ku> and these repos: https://github.com/jpetazzo/snap-on-dotcloud https://github.com/gregwebs/haskell-heroku
17:54:46 <monochrom> I just read vector's haddock and started using it right away
17:55:24 <jfischoff> ku: thanks for the links
18:15:19 <hpaste> stj pasted “an interesting benchmark -- I can't explain the results” at http://hpaste.org/68526
18:16:05 <stj> this is amazing... am I getting something terribly wrong? is myFoldl indeed a real foldl? :)
18:17:53 <kallisti> yes you can write foldl as foldr
18:18:50 <Ralith> that wasn't the question.
18:20:09 <kallisti> stj: foldl' works well with functions that are strict in their arguments
18:20:16 <kallisti> such as subtraction
18:20:20 <kallisti> foldr does not.
18:21:39 <Ralith> that wasn't the question either.
18:21:51 <kallisti> Ralith: then feel free to answer
18:21:58 <Ralith> I don't know the answer!
18:22:04 <Ralith> I'm as intruiged as stj is.
18:22:05 <kallisti> (if you actually look at the paste you'll see the questions asked)
18:22:43 <stj> kallisti: we're looking forward to the answer to the third question :)
18:22:55 <stj> that's the most intriguing one
18:23:02 <kallisti> stj: I'm not sure about that one.
18:23:16 <stj> and second, too
18:24:35 <rwbarton> what happens if you copy the definition of foldl' from Data.List into your module (and rename it)
18:24:59 <rwbarton> possibly it is able to optimize better when it has the definition directly available like this
18:25:03 <rwbarton> and the function is used only once
18:25:08 <Ralith> the obvious conclusion is that composing a function with itself is very efficient
18:25:09 <dmwit> > foldr (\x a -> a . (`f`x)) id [x,y,z] $ w
18:25:11 <lambdabot>   f (f (f w x) y) z
18:25:18 <dmwit> > foldl f w [x,y,z]
18:25:19 <lambdabot>   f (f (f w x) y) z
18:25:32 <Ralith> er, not with itself
18:25:35 <Ralith> at all, perhaps?
18:25:39 <Ralith> compared to the alternative, anywy
18:25:55 <dmwit> My guess about why it's so fast: because of buildr/foldr fusion.
18:26:24 <rwbarton> that is a more promising theory
18:26:57 <stj> rwbarton: if I copy foldl' from Data.List, nothing changes
18:27:34 <dmwit> About the "NOTE": which one(s) does -fllvm take down to 0s?
18:28:20 <stj> dmwit: the first one, I'll try with others
18:28:21 <dmwit> The only way to know for sure why it's so fast is to look at the Core that's generated for each version.
18:28:56 <rwbarton> you can also try compiling -ddump-rules-something-or-other
18:29:13 <dmwit> I think you can ask... what rwbarton said
18:29:27 <rwbarton> i just remember it is *not* -ddump-rules
18:29:49 <stj> dmwit: -fllvm does no good in other versions
18:31:37 <kallisti> Ralith: the composition should have little effect on performance
18:31:51 <dmwit> -ddump-simpl-stats [-ddump-simpl-iterations], according to http://www.haskell.org/haskellwiki/GHC/Using_rules
18:31:51 <Ralith> indeed.
18:31:51 <kallisti> and it's certainly not going to be faster than direct application
18:32:07 <Ralith> that's the thing with haskell--direct application often isn't.
18:32:19 <kallisti> I don't understand what you mean
18:32:22 <kallisti> you use direct application all the time.
18:42:51 <dmwit> ?ask jfischoff Any idea why I'm getting these? http://hpaste.org/68528
18:42:52 <lambdabot> Consider it noted.
18:45:11 <geekosaur> 116 reduce/reduce conflicts?  impressive
18:45:30 <kallisti> hm
18:45:37 <kallisti> looks like my memory link is the result of a thunk
18:45:42 <kallisti> er, many thunks, rather
18:52:55 <stj> some more testing: foldl from Data.Vector is as fast as myFoldl
18:53:01 <stj> also, fllvm brings it to 0.0 sec
18:55:48 <stj> that's when I use V.generate, however, if I use V.fromList then it's exactly as slow as foldl and foldl' on lists
18:57:38 <stj> so I guess the bottleneck here are lists themselves, and GHC somehow managed to transform myFoldl to something without a pointless list
18:59:27 <yub3> @help
18:59:27 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:59:33 <yub3> @list
18:59:34 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
19:00:09 <ski> hm, getting `Eq' and `Show' for this existential seems tricky/ugly ..
19:00:57 <ski> i essentially need `deriving Eq1'
19:07:56 <ski> (hm .. but i don't *want* TH !)
19:09:07 <monochrom> wait, don't you just say "data E = forall a . (Eq a, Show a) => E a"?
19:09:58 <monochrom> although, I now see that this capturing of Eq is pretty useless
19:10:29 <ski> i have basically `data Foo = forall i. F (Bar i) i', where `Bar' is a GADT
19:11:06 <ski> also, `Bar' has lots of constructors, so writing the `Eq1' instance manually doesn't appear that attractive
19:11:59 <monochrom> I would bite the bullet and do it by hand
19:12:12 <ski> if i try `deriving instance Eq Foo', it of course only matches on the `F' constructor, not on the consrtuctors for `Bar'
19:13:18 <Cale> selfEqual (E x) = x == x
19:13:37 <ski> you mean making an `Eq1' instance, or a direct `Eq' instance for `Foo' ?
19:13:54 <monochrom> you know how OOP people write this unattractive truckload of code? (hint: I carefully say "write this unattractive truckload of code". OOP does not reduce the amount)
19:14:10 <ski> i imagine they use code-generators
19:15:12 <monochrom> answer: simply instead of 100 cases in your GADT in one single place, they spread it over 100 subclasses in 100 files. so each file doesn't look that bad, and gives you the illusion that you don't have 100 cases. but do.
19:15:26 <ski> hm .. i think i'll need the `Eq1' instance anyway, so i'd better write that
19:15:31 <monochrom> err, s/but do/but you do/
19:19:56 <ski> monochrom : hm, you're thinking Visitor, yes ?
19:20:43 <monochrom> actually just composite pattern, but I have used both together for obvious reasons
19:21:24 <monochrom> ah, but if you're doing 2-ary operations such as Eq, it is visitor alright
19:22:41 <crdueck> RWH has a section on using C functions from a library like math, is there a good guide on using user defined C functions/libraries in Haskell?
19:23:57 <Axman6> it'
19:24:23 <Axman6> it's not much different i believe. you just write your C files, and i think you need a header to be able to link to it.
19:25:23 <crdueck> Axman6: okay, i'll try it out
19:26:05 <Axman6> you'd then compile your C files using cc -c foo.c, and when you compile your app, i think you use ghc Foo.hs foo.o
19:27:28 <monochrom> actually, ghc since some version ignores *.h files completely
19:28:21 <crdueck> so compile a object file from a .c file, then use ghc as Axman6 said?
19:28:25 <monochrom> and "ghc -c foo.c" is a more right command than "cc -c foo.c"
19:28:55 <Axman6> been a while since i've done it =)
19:31:17 <crdueck> using C's sqrt as an example: i import it with "foreign import ccall "math.h sqrt"". how would I import a C function I've written myself?
19:31:39 <monochrom> firstly like I said, math.h will be ignored
19:31:50 <crdueck> monochrom: okay, i was just following RWH
19:31:50 <monochrom> secondly, same syntax
19:32:19 <monochrom> RWH was outdated the day it was written. another outdatedness is its Control.Exception story
19:32:27 <Axman6> how does it know the type of sqrt then? i assume you link with -lm... but <confused>
19:32:29 <crdueck> so replace math.c with the .c file i've written the function in
19:32:47 <geekosaur> RWH was written when ghc used a C intermediate, which therefore understood include files; these days ghc generates native assembly code directly, C include files are useless
19:33:24 <monochrom> it knows the type because you write a haskell type signature, and there is a standardized translation from haskell type signature to C type
19:35:09 <crdueck> so all I need is "foreign import ccall "foo.c foo"; foo :: CInt -> CInt" for example?
19:35:30 <monochrom> delete "foo.c"
19:35:58 <monochrom> delete the semicolon
19:35:59 <crdueck> how does it know the definition of foo then?
19:36:41 <rwbarton> it links against an object file which has the symbol foo
19:37:05 <monochrom> it knows because you will type in "ghc/gcc -c foo.c && ghc haskell.hs foo.o" or "ghc haskell.hs foo.c"
19:40:01 <monochrom> RWH's FFI example is also highly carried away
19:43:30 * Axman6 suggests this would make a good blog post for others to refer back to in the future
19:43:47 <ski> hm, using `data Foo = forall i. Eq i => F (Bar i) i' appears to work ..
19:43:55 <monochrom> it jumps at once into a pretty advanced example with overwhelming information on a tricky case, and so basic information such as "but how does it know where is the C code" is lost in the midst
19:44:01 <ski> .. i wonder which `Eq' dictionary it uses
19:44:13 <dmwit> ski: The one available at the time F is called.
19:44:21 <ski> dmwit : there's two available
19:44:27 <dmwit> nuh-uh
19:44:40 <ski> yes
19:44:59 <monochrom> it stores the Eq of i, not the Eq of (Bar i)
19:45:18 <monochrom> since the code reads "forall i. Eq i"
19:45:29 <ski> i have one thing of type `(Bar i,i)', and another of type `(Bar j,j)', together with `Eq i' and `Eq j' dictionaries
19:45:34 <ski> then i discover that `i' and `j' are the same type
19:45:51 <dmwit> Congratulations! Now you know that the Eq i and Eq j dictionaries are the same dictionary.
19:46:17 * ski still wonders *which* of them it uses ..
19:46:48 <monochrom> I don't think (Bar i, i) is relevant. your code reads "F (Bar i) i" not "F (Bar i, i)" and certainly not "forall i. Eq (Bar i, i)"
19:47:17 <ski> tupled or curried constructor, makes no difference
19:47:44 <ski> (but yes, the latter isn't happening anywhere here)
19:47:49 <monochrom> in other words, suppose you write "F (undefined :: Char) 'x'", then i = Char, you get Char's Eq
19:48:08 <dmwit> monochrom: I think the question goes like this.
19:48:24 <ski> s/:: Char/:: Bar Char/
19:48:26 <monochrom> sorry, "F (undefined :: Bar Char) 'x'"
19:48:51 <dmwit> Oh, wait, yeah, I just realized I really don't understand what the question is.
19:49:04 <dmwit> So, how do you discover that i and j are the same type?
19:49:26 <ski> using `class Eq1 f where eq1 :: f i -> f j -> Maybe (Equal i j)'
19:49:35 <dmwit> Foo doesn't have a type argument.
19:49:38 <ski> with an appropriate `instance Eq1 Bar', of course
19:49:47 <dmwit> aha!
19:49:53 <monochrom> there are too many foo's
19:50:07 <dmwit> Right, now I understand the question.
19:50:07 <ski> (`Bar' is a GADT, so this is no problem -- except the code is too chatty)
19:50:56 <dmwit> monochrom: So, we're writing f :: Foo -> Foo -> Maybe Foo; and the question is whether it chooses to copy the pointer from the first Foo or the second Foo into the result Foo when the result is a Just.
19:51:31 <ski> i'm aware that due to uniqueness of instances, it shouldn't matter which instance is used -- still, the operational part of me wants to know which one is used :)
19:51:43 <dmwit> f returns a Just when the Foo happens to be wrapping i's of the same type and a Nothing otherwise
19:51:57 <dmwit> ski: right
19:52:08 <dmwit> ski: You could examine the Core. =)
19:52:25 <monochrom> the actual arguments of F decides. like we have always said.
19:53:16 <ski> dmwit : in fact, even `forall_type i j. forall (fi :: f i) (fj :: f j). eq1 fi fj = Just Refl => fi = fj'
19:53:17 <dmwit> monochrom: not good enough; what if I use the Bar i from the first Foo and the j from the second Foo?
19:53:56 <monochrom> that's interesting. I will bet the second.
19:54:28 <dmwit> monochrom: Yeah, I don't know how it chooses, either.
19:54:30 <dmwit> =)
19:54:33 * ski isn't sure what dmwit is considering here
19:54:50 <ski> (i'm not sure why you're pondering `f :: Foo -> Foo -> Maybe Foo')
19:55:07 <dmwit> ski: I'm just trying to convince monochrom that there is an interesting question here, now that you've convinced me.
19:55:22 <ski> .. hm, i suppose it could be seen as a kind of unification
19:55:58 <monochrom> we're saying: f (Foo b0 x0) (Foo b1 x1) = Just (Foo b0 x1). this is screwy to your mind.
19:56:18 <dmwit> Anyway, I don't know the policy GHC uses; I think monochrom probably doesn't either; and I don't know of a good way to find out what it is other than reading GHC's source.
19:56:30 <ski> well, that's illtyped, unless you know `b0' and `b1' have the same type
19:56:37 <dmwit> You can find out what choice it makes for any particular situation by asking it for the Core it generates, but that doesn't give you the policy it uses. =)
19:56:58 <dmwit> ski: Yes, insert the appropriate case on eq1.
19:57:03 * ski nods
20:02:44 <ski> hm .. now for `Show' and `Read'
20:06:27 <ski> hm, `Show' was fairly painless
20:09:44 <ski> @type GHC.Read.choose
20:09:45 <lambdabot> forall a. [(String, Text.ParserCombinators.ReadPrec.ReadPrec a)] -> Text.ParserCombinators.ReadPrec.ReadPrec a
20:16:43 <ski> hm, `Read' is indeed more interesting
20:17:27 <ski> how would it even work, typewise ?
20:18:02 <monochrom> oh haha, yes, polymorphic in the result type, that explodes many brains
20:18:15 <ski> arguably `read :: String -> Bar Blah' should only parse strings which correspond to the constructors of type `Bar Blah'
20:18:33 <monochrom> right, it uses Bar's Read
20:18:43 <ski> but if you consider the general case, we want `read :: String -> exists i. Bar i'
20:18:50 <ski> s/you/we/
20:19:31 * ski tried `deriving instance Read (Bar i)' -- which unsurprisingly didn't work
20:19:48 <monochrom> then you have an existential type, and the pointer to the right Read is already added when you create the existential value
20:20:15 <ski> i probably actually need to get `exists i. Read i *> Bar i', in this case
20:20:46 <monochrom> "*>"? "=>"?
20:21:11 <ski> `*>' : `=>' :: `(,)' : `(->)'
20:21:52 <ski> after having read a `Bar i', i need to read an `i'
20:22:56 * ski feels another class materializing
20:23:47 <ski> @src Read
20:23:48 <lambdabot> class Read a where
20:23:48 <lambdabot>   readsPrec    :: Int -> ReadS a
20:23:48 <lambdabot>   readList     :: ReadS [a]
20:23:48 <lambdabot>   readPrec     :: ReadPrec a
20:23:48 <lambdabot>   readListPrec :: ReadPrec [a]
20:24:04 <ski> hm -- is `readListPrec' used anywhere ?
20:24:50 <monochrom> iirc it's the same story as Show having showList
20:25:20 <monochrom> > read "[True,False]" :: [Bool]
20:25:21 <lambdabot>   [True,False]
20:25:35 <monochrom> > read "\"xy\"" :: [Char]
20:25:35 <lambdabot>   "xy"
20:25:38 <ski> yeah, i know `readList', but `readListPrec' ?
20:25:40 <monochrom> is why you need it
20:25:52 <ski> maybe it's not always atomic
20:26:37 <monochrom> I guess readList is just a call to readListPrec
20:28:01 <monochrom> eh? Haskell 2010 has two methods only (readsPrec, readList). the others may be GHC's addition
20:28:29 <slack1256> check out GHC.Read
20:28:34 <slack1256> there is defines what is internal
20:28:43 <slack1256> *there is where
20:29:32 <monochrom> it's GHC's addition and someone's proposal
20:29:34 <ski> hm, i see `ReadPrec' isn't a type synonym, as i thought
20:38:06 <ski> hm .. always generating `Read i' seems a bit non-general
20:39:39 <rwbarton> @src ReadPrec
20:39:39 <lambdabot> Source not found. Maybe if you used more than just two fingers...
20:40:10 <monochrom> I heard that a classmate used just two fingers to type :)
20:40:41 <slack1256> i love you lambdabot xD
20:40:43 <monochrom> (also why he wrote and verified programs on paper before entering into the computer)
20:41:30 * ski did that with assembly programs, reinventing labels
20:46:35 <deech> Hi all, Does Template Haskell allow you to create a module?
20:47:25 <shachaf> I doubt it.
20:47:29 <geekosaur> no, because it's in the context of a module already and ghc only allows one module per file
20:47:31 <shachaf> Generally in GHC module <-> file.
20:48:34 <ski> hm .. it also seems wrong to fix a specific class to use for each type, say `Bar', that i want to read
20:48:49 <deech> That's what I figured. I wanted to generate some convenient A.B.C type notation and the only way I can think to do that is to have modules.
20:49:12 <strager> You can import qualified Foo as A.B.C, iirc
20:49:15 <strager> if that helps
20:49:19 <shachaf> Ugh.
20:49:48 <geekosaur> strager, given this is Template Haskell, importing is unlikely to help
20:50:11 <monochrom> yes, import X as A.B.C is valid
20:50:50 <monochrom> import Prelude as Text.Parsec.String!
20:50:53 <ski> i think i want something like `class BarClass cl where {instance cl Int; instance (cl a,cl b) => cl (a,b)}' -- but i'm not sure how to do it
20:51:20 <deech> Apparently there's a ticket in for creating modules on-the-fly (http://hackage.haskell.org/trac/ghc/ticket/1480).
20:51:44 <gurrag> What is the preferred method for setting up Haskell with a REPL on 64 bit Linux?
20:52:41 <monochrom> install the linux x64 version of ghc. there is already a binary (already compiled) on the ghc website
20:52:58 <monochrom> then use "ghci" for REPL
20:54:48 <slack1256> guys in which part of the world are you (continent) (i know off-topic)
20:55:03 <Axman6> the internet
20:55:38 <slack1256> where nobody knows you are a dog, right
20:55:54 <kallisti> it looks like the zip-archive package doesn't handle large directories very well
20:55:56 <slack1256> am i the only one lurking on #haskell at 2 am?
20:56:09 <kallisti> I get "resource exhausted (Too many open files)" very easily.
20:56:40 <kallisti> this could be highly problematic
20:57:44 <monochrom> north america
20:58:10 <ski> @src readList
20:58:11 <lambdabot> Source not found. stty: unknown mode: doofus
20:58:27 <geekosaur> slack1256, I've been out here at 0400 sometimes... sleep schedule sometimes gets interesting
20:58:50 <ski> slack1256 : europe
20:58:51 * kallisti thinks it might be time for a zip-conduit package
20:59:36 <ski> @source Text.Read
20:59:37 <lambdabot> http://darcs.haskell.org/packages/base/Text/Read.hs
20:59:49 <blackdog> Veinor: heya mate - any progress on releasing askitter?
21:02:16 <Veinor> blackdog: i'm blocking on hoauth right now due to the image uploading stuff
21:03:29 <ski> whence `readList' ?
21:03:43 <blackdog> Veinor: oh, the unbuildability thing?
21:03:52 <Veinor> yeah
21:04:22 <blackdog> Veinor: i think it's buildalble now
21:04:23 <blackdog> https://github.com/dsouza/hoauth/pull/8
21:04:41 <ski> hm, `GHC.Read.readListDefault' seems to be it
21:04:44 <Veinor> it's blocking on https://github.com/dsouza/hoauth/pull/6
21:05:00 <blackdog> oh, right. damn, it's just fixes all the way down, hey.
21:13:14 <Veinor> blackdog: yeah. fortunately dsouza said they're looking at it, so once that gets uploaded i can upload askitter
21:13:37 <blackdog> Veinor: *happydance*
21:13:52 <blackdog> although thankfully cabal-meta at least makes it bearable to use vendored libraries
21:14:04 <Veinor> yeah, i've heard cabal-meta is good at that
22:26:41 <tsanhwa> join #lisp
22:26:54 <blackdog> blasphemy!
22:56:50 * hackagebot cryptocipher 0.3.2 - Symmetrical Block, Stream and PubKey Ciphers  http://hackage.haskell.org/package/cryptocipher-0.3.2 (VincentHanquez)
23:01:51 * hackagebot hit 0.3.0 - Git operations  http://hackage.haskell.org/package/hit-0.3.0 (VincentHanquez)
23:01:53 <roconnor> @hoogle lookupBy
23:01:54 <lambdabot> No results found
23:01:59 <roconnor> @hoogle lookup
23:01:59 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
23:01:59 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
23:02:00 <lambdabot> Data.HashTable lookup :: HashTable key val -> key -> IO (Maybe val)
23:13:36 <Refried_1> I can't figure out the difference between the State monad and the ST monad, but I get the impression that the former is deprecated; is that true?  Or are they the same?  Or else, can someone point me to some reading or explain the difference?
23:13:54 <ski> neither is deprecated
23:14:13 <ski> `State' is for managing a single piece of state which is implicitly threaded through your code
23:14:39 <shachaf> Refried_1: They're completely different.
23:14:44 <dabblego> they are quite different and both co-exist
23:14:44 <Refried_1> :-\
23:14:55 <shachaf> State is much simpler so you should work on understanding that first.
23:15:01 <Refried_1> ok
23:15:03 <dabblego> agreed
23:15:04 <ski> `ST' is for being able to dynamically allocate new pieces of state (of arbitrary type) (including arrays) -- you also get the bonus of update-in-place
23:15:30 <dabblego> perhaps learn Reader before State, but that's not always the best outcome
23:16:38 <ski> Refried_1 : typically, `ST' is used either for performance, or for the dynamic allocation of pieces of state (of arbitrary type) (or both things at the same time)
23:17:28 <shachaf> Refried_1: A good exercise for understanding State is to write some code that doesn't use it that accomplishes the same goals.
23:17:37 <ski> Refried_1 : e.g. if you wanted to sort a list, one option would be to copy the elements over to an `STArray', then use quick-sort on that, finally collecting the elements back into a list
23:17:43 <shachaf> Most likely you'll end up with code that looks just like what State code turns into.
23:18:26 <ski> Refried_1 : unlike if you used `IO' and `IOArray's, you could actually get `qsort :: Ord a => [a] -> [a]' with neither `IO' nor `ST' in the return type here
23:18:33 <shachaf> Whereas understanding ST is much trickier. :-)
23:18:40 <shachaf> Is there a complete implementation of ST in pure Haskell?
23:19:27 <ski> Refried_1 : so `ST' serves as a nice replacements for algorithms in `IO' which only manipulate *local* state, for purposes of efficiency in an imperative algorithm
23:20:20 <ski> shachaf : i think the generation of unique refs with arbitrary type is the hard part
23:20:32 * ski doesn't know if there's an in-haskell implementation
23:21:21 <ski> (using anything like `unsafeCoerce' is of course cheating)
23:21:27 <Refried_1> thanks all
23:22:31 <Refried_1> shachaf: when you say, "write some code that doesn't use State the accomplishes the same goals" -- what are the goals?  I understand the type signature, but it doesn't seem too interesting
23:22:50 <Refried_1> except i guess insofar as it allows state-changing operations to be chained together in a standard way (is that correct?)
23:23:55 <shachaf> Refried_1: That's pretty much it.
23:24:03 <shachaf> (And the whole Monad thing.)
23:24:06 <ClaudiusMaximus> shachaf: even the Hugs implementation is full of 'primitive' http://darcs.haskell.org/hugs98/libraries/hugsbase/Hugs/ST.hs
23:24:37 <Refried_1> ski:  so ST is just to be able to have mutable references, but doesn't imply nondeterminism like IO.  ( ? )
23:24:54 <ski> yes
23:25:22 <ski> in a sense, `State s' gives you a *single* mutable reference (conceptually)
23:25:34 <Refried_1> ok, and ST lets you allocate as many as you want
23:25:53 <ski> (but typical implementations won't actually use update-in-place to implement it -- if you did it in Clean, you'd probably get that)
23:26:05 <ski> yes, and of whatever *type* you want
23:26:21 <refried__> ah, for State you have a fixed state type through the whole thing
23:26:45 <refried__> it it isn't actually mutable so much as that you can return a different state, right?
23:26:46 <ski> if you fix the type of the reference, it's easy to do an in-haskell implementation of it (minus the update-in-place thing, which is just a performance thing anyway)
23:27:13 <ski> well, conceptually, it's the same thing
23:27:35 <refried__> hmm
23:28:09 <ski> in mathematical modelling of imperative programs, the program is modelled as a function that given an initial state computes the final state
23:28:34 <ski> and this is basically what the `s -> (a,s)' thing inside `State s' is
23:29:32 <ski> i.e. the mutable state is thought of as conceptually consist of a sequence of versions / state values
23:29:49 <yitz> refried__: as an exercise, you can write a module that implements the State API in ST/STRef, and (more or less) vice versa.
23:30:06 <ski> whether this is implemented by allocating a new state value, or by overwriting the old one (if unreachable), is "merely" an optimization detail
23:30:20 <shachaf> yitz: "more or less" being for a single type?
23:31:22 <yitz> shachaf: you implement a runST that takes an STRef as a parameter, and you have to stuff everything inside just that one by using an appropriate type.
23:32:09 <yitz> shachaf: or you can take two STRefs. or you can take an HList of arbitrary STRefs. starts to get messy.
23:32:21 <ski> hm .. maybe one can do it with a recursive know, somehow
23:32:26 <ski> s/know/knot/
23:32:56 <yitz> shachaf: but anyway, doing it with one STRef is enough to accomplish the point of the exercise, i.e., to understand in what sense the two are equivalent.
23:33:06 <ski> (which might have been what yitz was referring to ..)
23:34:11 <shachaf> ST's actual typical use is also pretty different from State's.
23:34:44 <yitz> shachaf: right. the APIs reflect that difference.
23:35:28 <yitz> but denotationally they are pretty much the same thing.
23:35:37 <gigi2> hi everybody!
23:36:57 <gigi2> yesterday I decided to uninstall the haskell platform and go for a GHC +cabal installation, because I could not install SourceGraph that required cabal 1.14
23:37:07 <newsham> > mr fix it
23:37:07 <gigi2> so I uninstalled everything
23:37:09 <lambdabot>   I'm workin on it!
23:37:24 <gigi2> installed GHC 7.4.1
23:37:56 <gigi2> Cabal 1.14 and cabal-install 1.14
23:38:57 <gigi2> now when I try to install scion-browser or buildwrapper, cabal tells me that I have a version of Cabal 1.14 that Shadows another version of Cabal
23:39:01 <gigi2> and in effect
23:39:26 <gigi2> with ghc-pkg list I see that there is one installed with GHC and one in my local .cabal repository
23:40:15 <yitz> gigi2: it's a bad idea to re-install Cabal on top of the one provided with GHC, unless you really know what you are doing.
23:41:18 <yitz> gigi2: probably easiest to start over, and this time don't re-install Cabal.
23:41:32 <gigi2> I see... but when I installed cabal-install it told me that Cabal was missing... so I went for the installation and now that I got this error message I discovered that I have two copies...
23:41:34 <gigi2> ok
23:41:37 <gigi2> I start over
23:41:44 <gigi2> this time trying without cabal...
23:45:11 <gigi2> bootstrapping cabal-install now
23:46:53 * hackagebot xml-conduit 0.7.0.3 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-0.7.0.3 (MichaelSnoyman)
23:50:54 <gigi2> it worked! thank you yitz!
23:51:27 <ski> @index Typable
23:51:28 <lambdabot> bzzt
23:52:39 <ski> > isJust (cast (undefined :: Bool) :: Maybe Bool)
23:52:40 <lambdabot>   True
23:52:41 <ski> > isJust (cast (undefined :: Bool) :: Maybe Int)
23:52:43 <lambdabot>   False
23:57:43 <ski> hm, there's probably a simpler way to check whether two types are equal ..
