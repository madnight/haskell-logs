00:01:25 * hackagebot persistent-sqlite 0.9.0.2 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-0.9.0.2 (MichaelSnoyman)
00:16:26 * hackagebot wai 1.2.0.2 - Web Application Interface.  http://hackage.haskell.org/package/wai-1.2.0.2 (MichaelSnoyman)
00:21:28 * hackagebot wai-app-static 1.2.0.3 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-1.2.0.3 (MichaelSnoyman)
00:21:30 * hackagebot wai-eventsource 1.2.0.2 - WAI support for server-sent events  http://hackage.haskell.org/package/wai-eventsource-1.2.0.2 (MichaelSnoyman)
00:21:32 * hackagebot wai-extra 1.2.0.4 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-1.2.0.4 (MichaelSnoyman)
00:21:34 * hackagebot wai-frontend-monadcgi 1.2.0.2 - Run CGI apps on WAI.  http://hackage.haskell.org/package/wai-frontend-monadcgi-1.2.0.2 (MichaelSnoyman)
00:21:36 * hackagebot wai-handler-fastcgi 1.2.0.2 - Wai handler to fastcgi  http://hackage.haskell.org/package/wai-handler-fastcgi-1.2.0.2 (MichaelSnoyman)
00:26:38 * hackagebot wai-handler-launch 1.2.0.2 - Launch a web app in the default browser.  http://hackage.haskell.org/package/wai-handler-launch-1.2.0.2 (MichaelSnoyman)
00:26:40 * hackagebot wai-handler-scgi 1.2.0.2 - Wai handler to SCGI  http://hackage.haskell.org/package/wai-handler-scgi-1.2.0.2 (MichaelSnoyman)
00:26:42 * hackagebot wai-test 1.2.0.2 - Unit test framework (built on HUnit) for WAI applications.  http://hackage.haskell.org/package/wai-test-1.2.0.2 (MichaelSnoyman)
00:26:44 * hackagebot wai-websockets 1.2.0.2 - Provide a bridge betweeen WAI and the websockets package.  http://hackage.haskell.org/package/wai-websockets-1.2.0.2 (MichaelSnoyman)
00:26:46 * hackagebot warp 1.2.0.2 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.2.0.2 (MichaelSnoyman)
00:31:48 * hackagebot warp-static 1.2.0.2 - Static file server based on Warp and wai-app-static  http://hackage.haskell.org/package/warp-static-1.2.0.2 (MichaelSnoyman)
00:31:50 * hackagebot warp-tls 1.2.0.4 - SSL support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-1.2.0.4 (MichaelSnoyman)
00:32:31 <structuralist> Hi, so I'm trying to understand monads…
00:32:54 <structuralist> I think I get the idea of an F-algebra, and a monad is that plus some additional conditions, and I was hoping someone could motivate them for me
00:33:26 <structuralist> namely the commutative diagrams here: http://en.wikipedia.org/wiki/Monad_(category_theory)#Algebras_for_a_monad
00:34:05 <shachaf> The category-theory meaning will not be all that helpful for understanding the Haskell use.
00:34:09 <structuralist> sorry I don't mean monad per se, but an algebra for one
00:34:56 <shachaf> What's the context of what you're trying to figure out?
00:35:16 <structuralist> shachaf: I'm curious about the mathematical meaning. I've used monads, but I don't feel like I really understand them intuitively.
00:36:36 <structuralist> I was reading about F-algebras because I wanted to know about catamorphisms and the like and I saw that an algebra for a monad is a similar thing
00:36:53 <shachaf> structuralist: "catamorphism" just means "fold". :-)
00:37:24 <shachaf> Are you trying to learn about the mathematical meaning *with the purpose of understanding Haskell better*, or just on its own?
00:38:51 <structuralist> I want to understand monads mathematically, to the point where I can intuit the connection with functional programming
00:39:31 <tzxn3> why do mathematicians always invent stupid words?
00:39:57 <structuralist> tzxn3: naming abstract things is hard…
00:40:16 <tzxn3> just call folds folds
00:40:19 <tzxn3> :p
00:40:40 <structuralist> I thought "catamorphism" was coined by a computer scientist
00:40:59 <MichaelBurge> Is there a quick and dirty way to get a unique identifier of a record when implementing a "Show" instance? Like a hash of some internal GHC datastructure?
00:42:24 <structuralist> "these have been catamorphisms (from the greek preposition κατα meaning 'downwards' as in 'catastrophe')"
00:43:10 <ktosiek> MichaelBurge: I don't know, but why would you want to do that? They are immutable...
00:44:51 <MichaelBurge> ktosiek: The record might have cycles in it so a default deriving instance won't work, and I'm not actually interested in the contents of the record when I show it - I just need something to uniquely identify it.
00:45:28 <ktosiek> oh, I hadn't tough about cycles, thanks :-)
00:53:29 <Saizan> structuralist: try to work out what the T-algebras for the list monad are
00:53:58 <dzhus> is pattern matching faster than picking a type class instance (when it cannot be known statically)?
00:54:24 <Saizan> structuralist: or i could tell you if you want :)
00:54:39 <Botje> dzhus: picking a type class instance happens at compile time, pattern matching is runtime..
00:54:52 <Botje> so they are incomparable :)
00:55:03 <dzhus> Botje: not necessarily in compile time
00:56:13 <Botje> in that case it boils down to a record selection + invoke
00:56:26 <efie> I understand what "($ 4) :: Num a => (a -> b) -> b" means. But what about "(4 $) :: Num (a -> b) => a -> b"? It seems that 4 is interpreted as a function of type a -> b, but why now (a-> b) (which is, that the 4-function takes an a and returns a b) has to be in instance of Num?
00:56:46 <Botje> efie: because 4 is not 4.
00:56:59 <Botje> 4 === fromIntegral 4 :: Num a
00:57:10 <Saizan> :: Num a => a
00:57:16 <Botje> eh, yeah
00:57:25 <Botje> efie: and you're applying 4 to *something*, so a = b -> c
00:58:02 <Botje> so you end up with Num (b -> c) => b -> c
00:58:36 <Saizan> more specifically ($) requires a function as first argument (because it will get applied to something)
01:01:06 <efie> ok, I think I got it, thanks
01:04:24 <structuralist> Saizan: It would be some h :: [a] -> a such that (map h) . h == join . h and h . return == id ?
01:07:22 <structuralist> er
01:07:51 <structuralist> h . (map h) == h . join rather
01:11:44 <structuralist> the only thing I can think of is h = head
01:11:59 <structuralist> that doesn't even work
01:14:30 <structuralist> fold?
01:15:14 <structuralist> but only if the operation is associative?
01:28:54 <Saizan> structuralist: remember that you can also pick what to use for 'a'
01:29:33 <structuralist> is there some general answer I can give beyond just stating the conditions?
01:30:01 <Saizan> structuralist: yep, it ends up being a fairly well known structure
01:30:13 <Saizan> structuralist: class of structures, i guess
01:37:30 <Saizan> btw, it's h . map h == h . join
01:38:18 <structuralist> yeah I corrected myself
01:45:01 <structuralist> h = mconcat ?
01:45:35 <structuralist> then the algebras are monoids
01:46:09 <structuralist> Saizan I think I got it
01:47:12 <Saizan> structuralist: yep
01:50:54 <Saizan> so that's a motivation for these laws, you get the monoids as the T-algebras for the free monoid monad, and this works for other abstract algebra structures like groups etc..
01:52:50 <structuralist> ah okay
01:54:16 <structuralist> the free X monad should have Xs as algebras, now to understand why it works...
01:59:25 <FudgeSickle> Hello, I'm working through some of the stuff in learn you a haskell. In the state monad section it gives a code example that uses 'State $' to turn the function in to a state but this throws errors on my ghci. Any thoughts?
01:59:41 <aavogt> FudgeSickle: state $
02:00:04 <Lemmih> FudgeSickle: My guess is user error.
02:00:15 <aavogt> mtl-2 doesn't have the State constructor
02:00:30 <aavogt> LYAH was written before mtl-2 existed
02:01:11 <Lemmih> Ah, I was wrong.
02:01:14 <aavogt> (but maybe the tutorial has you write your own State, in which case whatever mtl does is irrelevant)
02:02:08 <FudgeSickle> No it's binding a function in state to use the State monad.
02:02:55 <FudgeSickle> Hmm, is there a summary of changes for mtl-2 with reasoning?
02:03:28 <aavogt> the reasoning is that they re-defined (State s) to be (StateT s Identity)
02:03:42 <quicksilver> the basic idea was to make everything use the transformer version
02:03:45 <aavogt> or actually that's what happened
02:03:46 <quicksilver> there was a lot of duplicated code, before
02:03:50 <adamt> How would i go about turning a NominalDiffTime into a number of days? when just dividing with 60*60*24 it is has :t = NominalDiffTime, and i would rather prefer a number of sorts. :)
02:03:55 <quicksilver> with 'basic' and 'transformer' versions of everything.
02:04:07 <quicksilver> adamt: realToFrace
02:04:08 <FudgeSickle> ah, okay, thanks
02:04:12 <quicksilver> adamt: sorry, realToFrac
02:04:20 <quicksilver> (and then divide by 3600*24 as you suggest)
02:05:07 <adamt> awesome, thank you quicksilver.
02:15:19 <FudgeSickle> After 'import Control.Monad.State.Lazy' I just get 'not in scope state'
02:16:21 <t7> is there a warning switch for error and undefined in non IO code?
02:18:27 <Peaker> FudgeSickle, you mean: Not In scope: "State" ?
02:18:57 <FudgeSickle> no, in ghci 'let pop = state $ (\(x:xs) -> (x,xs))'
02:19:13 <FudgeSickle> followed by 'Not in scope: `state''
02:19:23 <Peaker> FudgeSickle, is that from LYAH?
02:19:28 <FudgeSickle> yeah
02:19:54 <Peaker> oh, it is in the MonadState class
02:20:44 <Peaker> FudgeSickle, Try ":i StateT"
02:21:10 <Peaker> FudgeSickle, does that work?
02:21:21 <FudgeSickle> Yeah it gives a print out
02:21:31 <Peaker> What does it say about "Defined in.."
02:21:50 <FudgeSickle> Control.Monad.State.Lazy
02:22:06 <FudgeSickle> I have already 'import  Control.Monad.State.Lazy'
02:22:10 <Peaker> also, in the shell, what does "ghc-pkg list mtl" tell you?
02:22:48 <FudgeSickle> Ah I think I see the problem ... mtl-1.1.0.2
02:23:04 <Peaker> you can use "cabal update && cabal install mtl"
02:23:29 <FudgeSickle> Thanks
02:32:01 <t7> ATS looks cool but has some really ugly names for constants and keywords
02:36:10 <MichaelBurge> Is there a way to have "cabal test" run all of your HUnit tests that are in "TEST/" directories? That is, the test for "/path/to/x" is "/path/to/TEST/x"
02:37:08 <Phlogistique> t7: also, it looks really, really ugly
02:37:32 <osa1> is it possible to collect strings in an alex lexer using "basic" wrapper? or do I have to use "monad" wrapper?
02:56:04 <Feuerbach> How do I reinstall base with ghc (to test my changes to it)?
03:02:48 <FudgeSickle> @undo do x<-get
03:02:48 <lambdabot>  Parse error at end of input
03:41:52 <srhb> Curious, what's going on here?: http://stackoverflow.com/questions/10513007/weird-behavior-of-newcstringfree
03:43:29 <flux> srhb, try allocating 410M again after that free
03:43:39 <flux> probably the memory won't be returned to the operating system
03:43:53 <srhb> Indeed, I get about 500 total after doing it again.
03:46:45 <srhb> http://hackage.haskell.org/trac/ghc/ticket/698 <-- Doesn't this claim that it _should_ be released, or is that really only working on Windows?
03:49:03 <srhb> er, fixed.
03:50:18 <srhb> I guess it's a libc problem.
04:14:33 <roha> hey, i have a question about some code ive written. the running time is pretty slow and im wondering if i can do (substantially) better. if someone has time, i'd be grateful for any tips. i included some short explanations in the code for easier reading.
04:14:37 <hpaste> roha pasted “calculating potential of points in a grid” at http://hpaste.org/68270
04:17:32 <merijn> roha: Unrelated to performance I think hlint's suggestion of replacing the if/else at line 34 with guards is a good idea
04:18:23 <angstrom> should I use one of these over the other? `Just 1 >>= Just <$> (+1)' vs `Just 1 >>= Just . (+1)'
04:18:25 <roha> merijn, yeah youre right, ill fix that
04:19:29 <merijn> angstrom: Why not "(+1) <$> Just 1"?
04:19:31 <osa1> I'm having trouble with Alex, I can't even compile examples in Alex's github repo, can anyone help me? http://stackoverflow.com/questions/10514316/haskell-alex-error-in-wrapper-template
04:19:43 <merijn> Or "fmap (+1) (Just 1)"
04:20:13 <merijn> Actually, does the first one even typecheck?
04:20:13 <roha> i just wonder i that way to compute this is just bound to be slow (mapping a function over a vector of size 25000 several hundred times)
04:20:42 <aristid> :t (+1) <$> Just 1
04:20:43 <lambdabot> forall a. (Num a) => Maybe a
04:20:48 <aristid> merijn: it does.
04:20:58 <merijn> aristid: I meant angstrom's first one
04:21:03 <angstrom> yes :-)
04:21:13 <merijn> :t Just 1 >>= Just <$> (+1)
04:21:13 <aristid> :t Just 1 >>= Just <$> (+1)'
04:21:14 <lambdabot> forall a. (Num a) => Maybe a
04:21:14 <lambdabot>     lexical error in string/character literal at end of input
04:21:24 <roha> or if there is maybe some way to reach the speed of a c++ algorithm which just loops over the whole thing hundreds of times
04:21:50 <aristid> angstrom: your first once is funny because it uses (<$>), but inefficiently :D
04:22:01 <merijn> angstrom: Anyhoo, I'd go with my first
04:22:28 <angstrom> merijn: thanks. it makes more sense, indeed
04:23:06 <merijn> In general if you find yourself doing "x >>= return . y" that's a sign you really want fmap/<$>
04:25:04 <aristid> @src liftM
04:25:05 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
04:25:59 <merijn> Yeah, but liftM forces a monad, why add that restriction if you can get away with just functor?
04:27:13 <angstrom> so it's generally a good idea to stay in the "computationally most specialized" typeclass possible?
04:27:25 <merijn> Least specialised, really
04:27:30 <merijn> Functor is more general than monad
04:27:35 <merijn> And all common monads are functors
04:27:49 <merijn> So functor code works with more types than monad code
04:28:02 <angstrom> ah, ok. then I got it the wrong way around
04:28:24 <merijn> It's an attempt to be as generic and reusable as possible
04:35:18 <t7> is Numeric.* still good to use?
04:38:05 <t7> whats the most wedely used lib for 3d math? (Quaternions, Rotation matrix etc)?
04:39:29 <ski> merijn : for polymorphic code, you may want `liftM' instead ..
04:56:48 <t7> is there a babys first guide to compiling shaders using hopengl somewhere?
05:00:02 <alpounet> t7, have you looked in the github repo?
05:00:26 <t7> nope, theres a hopengl repo on github?
05:01:33 <t7> i cant see any examples
05:21:42 <merijn> Hmm, how do people usually deal with giving maybe an inline function? Write your own wrapper that takes the (a -> b) argument last, specify a local helper or something else?
05:22:13 <hpc> :t maybe
05:22:15 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
05:22:25 <quicksilver> merijn: don't quite understand your question
05:22:29 <hpc> maybe z (foo . bar . baz) perhaps
05:22:34 <quicksilver> why is it being a first argument a barrier to it being inline?
05:22:55 <hpc> quicksilver: parens
05:23:02 <merijn> quicksilver: It's not a barrier, I'm not sure how to make it look best
05:23:12 <byorgey> use glitter
05:23:24 <quicksilver> I use parentheses, it's not a sin ;-)
05:23:34 <hpc> @quote paren
05:23:35 <lambdabot> dons says: you start with lisp, get to statically typed lisp (ML), add laziness, add whitespace to solve the parens stuff, add syntax sugar (for human programmability), and finally, add purity (i.e.
05:23:35 <lambdabot> true functional programming), and you've got haskell
05:23:45 <quicksilver> maybe bar (\x -> blah blah balh) foo
05:23:46 <merijn> My problem is that my return type is in the state monad so it's a multiline do block
05:23:46 <hpc> er, hmm
05:23:48 <ClaudiusMaximus> t7: if you're still stuck, i made a couple of demos that use shaders - can't remember exactly how i implemented them (a few months ago now) and they might not be good code, but they're on hackage as 'snowglobe' and 'gearbox' - however i have to go out now so won't be able to help further
05:23:49 <hpc> @quote banana
05:23:49 <lambdabot> Kaidelong says: <Kaidelong> take 6 "bananas" <lambdabot> "banana" <Kaidelong> clearly lambdabot is keeping the bananas to itself and lying about it
05:23:53 <hpc> eh
05:24:03 <hirsch_> Is there a way to use parMap in a controlled way to avoid stack overflows? With a limited number of threads.
05:24:13 <byorgey> merijn: ah, NOW we learn the real issue =)
05:24:13 <alpounet> t7, you may want to ask in #haskell-game
05:24:13 <t7> ah cool, thanks ClaudiusMaximus
05:24:23 <ClaudiusMaximus> hirsch_: parBuffer is what i use
05:24:34 <t7> i think i should get a prototype working in opengl 1 now though
05:24:35 <merijn> byorgey: Yeah, in hindsight I should probably have said that first :p
05:24:36 <quicksilver> merijn: parens look fine to me...
05:24:42 <hayashi> Today's Conundrum: I could do with something like (***), but lifting the resulting (m a, m b) into m(a, b), and have absolutely no idea how to do that without making a completely new combinator
05:24:59 <hayashi> *(***) on functions returning monads
05:25:02 <merijn> quicksilver: Even with a 3-4 line do block?
05:25:09 <quicksilver> sure
05:25:17 <quicksilver> do blocks are just expressions
05:25:20 * quicksilver shrug
05:25:24 <quicksilver> question of taste I suppose
05:25:25 <byorgey> merijn: if that pattern happens multiple times I might make a flipped version of maybe.  But for something one-off I'd use parens too.
05:25:29 <quicksilver> hayashi: liftM2 (,)
05:25:32 <hirsch_> ClaudiusMaximus, thx I'll look at it
05:26:05 <byorgey> @type  uncurry (liftM2 (,))
05:26:06 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
05:26:26 <quicksilver> if it happens many many times it is possible that you might be in a different monad (like a MaybeT one) or something.
05:27:56 <merijn> I guess I'll just put each maybe argument on its own line
05:28:16 <hpaste> merijn pasted “Result” at http://hpaste.org/68274
05:28:18 <quicksilver> yes, that often looks best if one argument is more than one line
05:29:06 <merijn> (I'm open to better looking suggestions)
05:29:53 <quicksilver> merijn: well that particular lambda does look like it's doing something general which might deserve a name
05:30:41 <merijn> Maybe, I'm just now refactoring from code that compiles into something readable :p
05:30:48 * quicksilver nods
05:31:06 <quicksilver> but aside for that (reusable chunks of code deserve a name) I think that's fine
05:31:44 <merijn> I'm not so sure it's that general, though
05:35:42 <hayashi> @src (***)
05:35:43 <lambdabot> f *** g = first f >>> second g
05:36:16 <merijn> hmm, I don't suppose there's a left associative variation of ($)?
05:55:59 <ski> merijn : `flip' or `>>=' ?
05:59:32 <lamefun2> Is there something that supports VSync in Haskell?
06:02:43 <merijn> ski: flip doesn't work so well with multiple composed functions
06:03:00 <merijn> Or rather, it works but I just move the parenthesis around instead of removing them :p
06:07:00 <ski>   maybe (...) `flip` movedTo $ \newId -> do
06:07:02 <ski>     ...
06:07:05 <ski> would that work ?
06:07:10 <ski> the other option i suggested is
06:07:51 <ski>   access (ptr . infoLens (id, loc)) >>= maybe (...) $ \newId -> do
06:07:53 <ski>     ...
06:08:12 <ski> hm, though maybe the relative precedences of `>>=' and `$' here are still wrong
06:08:26 <saml> @google haskell good parts
06:08:28 <lambdabot> http://learnyouahaskell.com/modules
06:08:28 <lambdabot> Title: Modules - Learn You a Haskell for Great Good!
06:08:37 <ski> (this is imo an argument in favor of supporting `foo bar \x -> ..x..' syntax)
06:09:05 <saml> did anyone make a presentation about good parts of haskell?
06:09:34 <fmap> Are there bad parts?
06:10:14 <saml> sicne haskell is misunderstood as a grad students' sketchbook
06:10:44 <saml> need concise presentation of haskell for daily workers
06:11:03 <merijn> saml: SPJ had a nice intro talk, lemme see if I can find it
06:11:23 <saml> thanks i'll google
06:11:39 <saml> http://www.haskell.org/haskellwiki/Video_presentations
06:13:06 <merijn> saml: I think I'm thinking of the "escape from the ivory tower" talk
06:13:16 <lamefun2> :t (<-)
06:13:17 <lambdabot> parse error on input `<-'
06:13:28 <saml> ah thanks merijn
06:13:41 <lamefun2> what is <- in do sequences?
06:13:58 <merijn> lamefun2: Syntactic sugar
06:14:01 <saml> get the monad's value
06:14:09 <danr> @undo { x <- m ; f x }
06:14:09 <lambdabot>  Parse error at "{" (column 1)
06:14:13 <merijn> @undo do {x <- foo; bar x }
06:14:13 <lambdabot> foo >>= \ x -> bar x
06:14:18 <saml> x <- monadAction
06:14:31 <saml> let x = pureFunction
06:15:19 <merijn> lamefun2: The undo process that lambdabot shows is literally what happens in the compiler, so if you understand (>>=) and lambda's you should be able to figure it out from that example
06:15:57 <saml> lamefun2, <- in do is same as =
06:16:06 <merijn> No
06:16:12 <saml> not the same.. but it's easier that way
06:16:19 <merijn> Because the way unsugaring works you can assign different thing to the same name
06:16:20 <hpc> it's also wrong ;)
06:16:40 <saml> do { let x = 1; x <- foo x;  x <- foo x; print x; }
06:16:43 <merijn> The desugaring is not complicated, so you might just as well show it
06:16:52 <merijn> @undo do { let x = 1; x <- foo x; x <- foo x; print x; }
06:16:52 <lambdabot>  Parse error at "<-" (column 19)
06:17:07 <merijn> @undo do { let x = 1; x <- foo x; x <- foo x; print x }
06:17:07 <lambdabot>  Parse error at "<-" (column 19)
06:17:13 <merijn> hmm
06:18:05 <merijn> @undo do { x <- foo x; x <- foo x; print x }
06:18:05 <lambdabot> foo x >>= \ x -> foo x >>= \ x -> print x
06:20:50 <saml> lamefun2, http://codepad.org/X3gJjqjG
06:20:57 <t7> http://hpaste.org/68276 if i comment out line 60 it draws the quad in a different position
06:21:03 <t7> why would it do that?
06:22:41 <saml> opengl thing
06:22:48 <davesq> Is there a way to get lambdabot's source lookup running locally within ghci?
06:23:05 <saml> sure  http://www.haskell.org/haskellwiki/Lambdabot
06:23:48 <merijn> davesq: Note that lambdabot doesn't actually look up sources
06:24:04 <merijn> '@src' is filled with flithy lies and untrue claims
06:24:16 <quicksilver> davesq: lambdabot's @src lookup really isn't very useful.
06:24:29 <quicksilver> davesq: better to use the library source (either online or locally)
06:24:30 <hpc> davesq: use hoogle
06:24:41 <quicksilver> hoggle gives you links into the online copy
06:24:41 <davesq> Righto, thanks for the feedback.
06:28:21 <lamefun2> @undo do { x <- foo x; y <- foo y; x <- foo x; y <- foo y; print x + y; }
06:28:22 <lambdabot> foo x >>= \ x -> foo y >>= \ y -> foo x >>= \ x -> foo y >>= \ y -> print x + y
06:31:39 <lamefun2> :t ($)
06:31:40 <lambdabot> forall a b. (a -> b) -> a -> b
06:34:10 <lamefun2> f $ a = f a ?!
06:34:17 <Botje> yep
06:34:25 <lamefun2> just to confuse newcomers?
06:34:40 <merijn> No
06:34:42 <quicksilver> lamefun2: to cut down on ()
06:34:56 <merijn> ($) has the lowest possible priority
06:35:03 <quicksilver> a b c $ e f g = (a b c) (e f g)
06:35:05 <danr> @type zipWith ($)
06:35:06 <lambdabot> forall b b1. [b -> b1] -> [b] -> [b1]
06:35:22 <vraid> is unfoldr the function to use to create a list of numbers which fit certain conditions?
06:35:24 <hpc> :t ($ x)
06:35:25 <lambdabot> forall b. (Expr -> b) -> b
06:35:27 <quicksilver> yes, and also as a useful function for higher order functions.
06:35:40 <byorgey> lamefun2: it also comes in handy to pass to higher-order functions sometimes
06:35:57 <byorgey> > zipWith ($) [succ, (*6), (+2)]  [19, 27, 304]
06:35:59 <lambdabot>   [20,162,306]
06:36:02 <quicksilver> > map ($"hi") [reverse,map toUpper, map (const 'a')]
06:36:03 <lambdabot>   ["ih","HI","aa"]
06:36:55 <byorgey> vraid: it depends.  can you be a little more specific about what sort of conditions you mean?
06:37:05 <byorgey> it sounds more like a filter to me, but hard to say without more details.
06:37:36 <byorgey> unfoldr is for creating a list starting from some "seed" value and a function that says how to turn a seed value into the next element of the list and a new seed value.
06:37:56 <vraid> i'm doing project euler problems to learn, the first one is summing all numbers below x which are multiples of 3 or 5
06:38:12 <byorgey> vraid: ah, ok, I don't think unfoldr will help you with that one
06:38:25 <byorgey> vraid: try 'filter'
06:38:26 <byorgey> @type filter
06:38:27 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
06:38:32 <vraid> byorgey: thanks, will do
06:38:45 <byorgey> it keeps only those elements for which the function returns True
06:38:49 <frontendloader> vraid: Have you seen these already? They're a bit gentler set of problems than Project Euler http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
06:38:57 <frontendloader> gradually ramping up
06:38:57 <byorgey> > filter even [1..10]
06:38:58 <lambdabot>   [2,4,6,8,10]
06:39:39 <frontendloader> also more haskell-specific.
06:40:12 <vraid> i'll look into it
06:40:26 <Elemir> @undo do { ix -> index; return $ mdl { ngramIndex = Just ix } }
06:40:27 <lambdabot>  Parse error at "->" (column 9)
06:40:33 <Elemir> @undo do { ix <- index; return $ mdl { ngramIndex = Just ix } }
06:40:34 <lambdabot> index >>= \ ix -> return $ mdl{ngramIndex = Just ix}
06:40:42 <davesq> i'm reading through learnyouahaskell on applicative functors. It's got an example: (pure 3) "blah" but ghci is giving me an error ("No instance for (Functor ((->) [Char]))". Any ideas as to what I'm doing wrong?
06:41:09 <byorgey> davesq: nothing, just  import Control.Monad.Instances
06:41:26 <byorgey> that instance is not in the Prelude
06:41:38 <davesq> byorgey: thanks! I just had Control.Applicative
06:42:58 <ehamberg> that was an error with the new “import” support in ghci. it's fixed in the newest version.
06:43:15 <ehamberg> (i.e. you don't need to import Control.Monad.Instances anymore)
06:44:00 <lamefun2> how is operator priority determined?
06:44:21 <byorgey> ehamberg: oh, really?  as of what version of GHC?
06:44:59 <ehamberg> i tried on 7.4.1 now and it works. i hit the same issue myself and remember someone mentioned that back then.
06:45:08 <absence> does anyone know if the may release of haskell platform is somewhat on schedule?
06:45:18 <ehamberg> byorgey: http://stackoverflow.com/questions/7687181/ghc-7-0-4-seems-to-have-forgotten-how-to-apply-functors – the last comment there
06:45:33 <byorgey> ehamberg: ah, cool
06:47:19 * hackagebot DSH 0.7.8.1 - Database Supported Haskell  http://hackage.haskell.org/package/DSH-0.7.8.1 (GeorgeGiorgidze)
06:49:36 <t7> can i times a quaternion by -1 to get the opposite rotation?
06:51:58 <vraid> t7: if your quaternion is w, i, j, k, its opposite is w, -i, -j, -k
06:52:06 <Botje> I think you need to invert either the angle or the vector it's rotating around.
06:53:51 <byorgey> t7: when using quaternions to represent rotations, composing rotations is given by *multiplying* quaternions, not adding.
06:54:06 <byorgey> so the opposite rotation is the multiplicative inverse.
06:54:29 <byorgey> i.e. the opposite rotation of q is 1/q
06:54:39 <t7> oo
06:54:46 <bitonic> is hackage having problems today? cabal often fails to download files
06:56:03 <t7> byorgey: Number.Quaternion doesnt have / or div
06:56:07 <t7> is there another name?
06:56:19 <byorgey> t7: what package is this from?
06:56:25 <vraid> by / he means multiplication by inverse
06:56:35 <vraid> t7: conjugate is the inverse
06:56:53 <vraid> q * (conjugate q) = identity quaternion
06:57:44 <byorgey> really? that doesn't seem right to me
06:58:31 <rwbarton> assuming q is a unit quaternion
06:58:31 <vraid> why not? if q is rotation in one direction, and its conjugate the opposite rotation, multiplying them together would yield the identity
06:59:00 <vraid> yeah, a unit quaternion
06:59:12 <t7> actually i can just apply all the rotations inversly
06:59:12 <byorgey> vraid: the conjugate is not the opposite rotation.  right, only if q has unit magnitude.
06:59:24 <t7> rather than inverse it before i convert to matrix
06:59:43 <vraid> i'm thinking too much in unit quaternions
07:00:00 <vraid> t7: what are you trying to do?
07:00:23 <t7> 6 degrees of freedom camera
07:00:35 <byorgey> hmm, maybe it doesn't matter, I guess the magnitude doesn't affect the rotation it represents
07:01:07 <vraid> as with complex numbers, the magnitude should only affect the length, not the rotation
07:01:35 <vraid> unless i'm forgetting something
07:02:19 <dekuked> sorry to bug you guys, but what does this error signify?: https://gist.github.com/2644696
07:02:34 <byorgey> dekuked: no apologies necessary =)
07:02:35 <Peaker> having some data types which refer to each other via a (*->*) indirection is fine.  Trying to abstract away this indirection by having the type take it as an argument and be ((* -> *) -> *)  adds a whole lot of difficulty. Suddenly, instances need to be flexible and undecidable. deriving and Data.Derive no longer work... :(
07:04:24 <byorgey> dekuked: eek, I don't know.  I don't know why GHC would need to execute gcc.  Maybe someone with more Mac OS experience can pipe up.
07:07:01 <dcoutts> byorgey, dekuked: ghc calls gcc for linking
07:07:14 <byorgey> huh, didn't know that
07:07:16 <dcoutts> as opposed to calling ld directly
07:07:29 <davesq> dekuked: have a look at the first comment here: http://justtesting.org/using-the-glasgow-haskell-compiler-ghc-on-os
07:07:57 <dcoutts> byorgey: also uses it if you try to compile a .c file using ghc
07:08:17 <byorgey> dcoutts: well, that I might even expect =)
07:08:19 <dcoutts> and indeed also calls gcc to assemble .s files
07:08:27 <davesq> dekuked: latest xcode moved dev tools, so need to edit "pgmgcc" in  /usr/bin/ghc to just read "gcc"
07:08:38 <dcoutts> ghc only emits assembly, not object code, uses gcc as the assembler
07:11:42 <hpaste> Peaker pasted “Abstracted indirection without losing sanity?” at http://hpaste.org/68279
07:13:03 <byorgey> dcoutts: ah, interesting, I see
07:13:29 <Peaker> any ideas on how to regain sanity there?  abstracting a little indirection is much more trouble than I expected...
07:18:28 <t7> how can i convert between Double -> GLdouble ?
07:19:01 <dekuked> um, like this?: https://gist.github.com/2644793
07:19:06 <osa1> can anyone help me? what's wrong with this LanguageDef? http://hpaste.org/68280
07:19:11 <dekuked> I changed all the $pgmgcc to gcc
07:19:23 <dekuked> $pgmgcc -> $gcc, sorry
07:20:08 <rwbarton> osa1: looks like nothing is wrong, try turning on NoMonomorphismRestriction
07:20:20 <dekuked> and this is the less helpful error I get now: https://gist.github.com/2644817
07:20:23 <rwbarton> or figure out what type you want to give it
07:20:46 <osa1> rwbarton: thanks, it workde
07:20:48 <osa1> worked*
07:21:46 <rwbarton> $pgmgcc -> $gcc doesn't seem like the thing to do
07:22:04 <rwbarton> those sound like shell variables
07:23:15 <rwbarton> did you read the comment davesq linked to?
07:26:53 <dekuked> rwbarton: thanks; no apparently I didn't read/undrestand it fully. it works now though! thank you guys!
07:27:00 <t7> Number.Quaternion could use some helper funcs for noobs like meh
07:27:52 <lamefun2> How to bind C libraries to Haskell?
07:28:49 <HugoDaniel> lamefun2: use the ffi
07:28:52 <Eduard_Munteanu> lamefun2: check the FFI docs
07:29:10 <Eduard_Munteanu> @google haskell ffi
07:29:12 <lambdabot> http://www.haskell.org/haskellwiki/FFI_Introduction
07:29:13 <lambdabot> Title: FFI Introduction - HaskellWiki
07:29:16 <HugoDaniel> lamefun2: its a snap, if you need an example check out my glhui package on hackage
07:33:45 <linduxed> i know i can figure out whether a character exists in a string with isInfixOf, but assuming that isInfixOf turns out true, is there a function that tells me on what position this character is found?
07:34:45 <vraid> byorgey: [ n | n <- [1..999] , divisible n ] is another way to write: filter divisible [ n | n <- [1..999] ] ?
07:35:29 <byorgey> vraid: yes, and the second can also be rewritten to just  filter divisible [1..999]
07:35:52 <vraid> ah, that would be preferred then
07:35:53 <Botje> linduxed: if you're just looking for one character, you can use findIndex
07:36:17 <Saizan> > findIndex ("bar" `isPrefixOf`) . tails $ "foobar"
07:36:18 <lambdabot>   Just 3
07:36:36 <Botje> oh, findIndex take a predicate. silly.
07:36:55 <vraid> byorgey: also filter divisible (takeWhile (< 1000) [1..]) ?
07:37:07 <linduxed> Botje: hmmm, findindex sounds ok
07:38:25 <byorgey> vraid: yes, that is also equivalent
07:39:07 <linduxed> but... how do i do a predicate for that?
07:39:26 <linduxed> elem?
07:39:27 <Botje> find (== 'x')
07:39:28 <linduxed> hmmm
07:39:32 <Botje> eh, findIndex
07:40:12 <linduxed> ok
07:40:27 <linduxed> btw, is there an "unMaybe" function?
07:40:32 <bitonic> uh-oh, I get linking errors. It was a while. How do I go on to insvestigate what's wrong?
07:40:46 <linduxed> or do i have to treat the Just and Nothing value on my own?
07:41:57 <Botje> linduxed: yes, you ned to pattern match.
07:42:09 <Botje> linduxed: although there are helper functions like 'maybe'
07:48:01 <Alan> hmmm, i just discovered i can do something that feels a bit risky...
07:48:04 <merijn> Is there a GHC flag to dump warnings to a file?
07:48:19 <Alan> so i'm making some enum-like data types, and i can have same-named constructors for different types
07:48:23 <t7> where is the quaternion mul method... ?
07:48:24 <Alan> is there any real downside to that?
07:48:24 <merijn> linduxed: You probably want "maybe" or "fromMaybe"
07:48:40 <merijn> Alan: Well, you might confuse yourself?
07:49:11 <merijn> And the compiler might not always be able to determine which one you are referring to and refuse to compile
07:49:42 <Alan> merijn: well at the moment it's kinda convenient because I have two enums, where one is a subset of another
07:49:48 <Alan> is there a better way to do that?
07:50:33 <Peaker> Alan, why not have   data Wrapper = Inner | MoreConstructorsHere ?
07:50:53 <Alan> Peaker: because it's ugly
07:50:55 <Alan> :P
07:50:58 <merijn> "data Enum1 = ...; data Enum2 = ... | Wrapper Enum1"?
07:51:51 <ski> (subtypes or refinement types can be awfully handy, in some cases ..)
07:52:40 <Peaker> should have been:  data Wrapper = Inner InnerType | MoreConstructorsHere ?
07:52:50 <Peaker> ski, in this case just need polymorphic variants
07:53:02 <dekuked> what does it mean to run this "ghci> :module +Data.Char"?
07:53:07 <Peaker> if Haskell had better support of finer-grained anonymous sums/products, it would be awesome
07:53:19 <Peaker> dekuked, basically it's the interactive shell equivalent of "import Data.Char"
07:53:26 <Peaker> dekuked, but now you can juse use "import Data.Char" insted
07:53:40 <ski> Peaker : or that, yes
07:53:50 * ski agrees with Peaker
07:55:02 <dekuked> does that mean I'm working within that modules namespace? how do I "unload" it?
07:55:14 <Peaker> dekuked, :m -Data.Char
07:57:02 <rwbarton> dekuked, it means that now you can write 'isUpper' instead of 'Data.Char.isUpper'
07:57:56 <rwbarton> it doesn't mean you are working "within Data.Char"
07:58:02 <rwbarton> you can :m + many modules
08:02:25 <tromp_> > 128613/119181
08:02:26 <lambdabot>   1.079140131396783
08:04:24 <edro4838> set colour on
08:09:25 <vraid> is this declaration decent? fibSum = \n -> sum (filter even (takeWhile (<= n) fib))
08:10:39 <hpc> @pl \n -> sum (filter even (takeWhile (<= n) fib))
08:10:39 <lambdabot> sum . filter even . flip takeWhile fib . flip (<=)
08:10:42 <hpc> yes
08:10:43 <hpc> :P
08:10:59 <rwbarton> more normal to write  fibSum n = sum ...
08:11:31 <vraid> all right, i'll use fibSum n =
08:11:59 <vraid> trying to get a feel for how this is usually written
08:13:18 <int-e> I would write  fibSum n = sum (filter even (takeWhile (<= n) fibs)) [it's customary to use an 's' indicating plural for lists] or perhaps  fibSum n = sum . filter even . takeWhile (<= n) fibs.
08:13:39 <int-e> meh. ... takeWhile (<= n) $ fibs
08:13:52 <rwbarton> f . g . h $ x style strikes again
08:14:26 <vraid> what does $ mean?
08:14:31 <hpc> f $ x = f x
08:14:34 <hpc> it's just function application
08:14:41 <hpc> with a very low precedence
08:14:45 <int-e> while the point-free version above is too much for me.
08:14:58 <hpc> f . g $ x y = (f . g) (x y)
08:15:03 <Phlogistique> is there any layman-oriented explanation of functions in the recursion-schemes package? I have a hunch that some functions I wrote could be replaced with short and magical incantations with ××××morphisms, but I'm not a category theorist
08:15:08 <vraid> to denote that the filters are applied "before" the fibs function?
08:15:58 <vraid> . is function composition, right?
08:16:02 <scopedTV> Yes.
08:16:03 <Phlogistique> vraid: it is
08:16:09 <hpc> vraid: it's a precedence trick
08:16:12 <hpc> fibs isn't a function
08:16:18 <vraid> ah, right
08:16:31 <tromp_> > 233/189
08:16:32 <lambdabot>   1.2328042328042328
08:16:39 <hpc> f . g $ x = (f . g) x = f (g x)
08:16:45 <int-e> vraid: f . g . h x   is  f . g . (h x), but to apply the result of the composition to an argument you want (f . g . h) x. Which using $ can be written as f . g . h $ x.
08:16:47 <hpc> f . g x = f . (g x) = wrong
08:17:11 <vraid> ah
08:19:10 <vraid> so i could write fibSum n = sum (((filter even) . (takeWhile (<= n))) fibs)
08:19:22 <rwbarton> holy parentheses, batman!
08:19:39 <vraid> but it looks better with fibSum n = sum (filter even takeWhile (<= n) $ fibs)
08:20:05 <int-e> vraid: right. but it takes quite some time to match the parentheses.
08:20:19 <int-e> vraid: while the second one misses a .
08:21:44 <flebron> Hi. Are guards part of pattern matching?
08:22:23 <MasseR> afaik no
08:22:35 <byorgey> it depends what you mean.
08:22:42 <vraid> better? fibSum n = sum ((filter even) . takeWhile (<= n) $ fibs)
08:23:36 <byorgey> evaluation of guards is part of the process of determining which function definition clause will be selected.
08:23:43 <byorgey> so it will be interleaved with pattern matching.
08:24:57 <vraid> int-e: which is better style,  (f . g . h) $ x y,  or f . g . h $ x y
08:25:08 <rwbarton> the latter
08:25:30 <rwbarton> unnecessary parenthese are almost always bad style
08:26:51 <Phlogistique> is there no proposal for a generic syntax for doing "case o of { pattern -> True; _ -> False }"?
08:27:12 <Phlogistique> something like "pat <- expr" in guards, but usable everywhere
08:27:21 <Phlogistique> as an expression
08:27:46 <Phlogistique> well, maybe it wouldn't make that much sense
08:28:46 <ski> > (not . null) [() | Left _ <- [Left 2]]
08:28:47 <lambdabot>   True
08:28:52 <EvanR> how to get the last 10 items from a list
08:28:52 <scopedTV> ugh that sounds awfully specific
08:28:53 <ski> > (not . null) [() | Left _ <- [Right 3]]
08:28:54 <lambdabot>   False
08:29:02 <scopedTV> EvanR: reverse . take 10 . reverse
08:29:13 <EvanR> is that the best way
08:29:32 <ski> you could write your own ..
08:29:39 <geekosaur> EvanR, I would be tempted to say "last 10 items from a list" suggests list is not quite the right structure
08:29:44 <EvanR> yes
08:29:49 <EvanR> geekosaur youre totally right
08:29:55 <EvanR> is that why theres no standard function for it
08:29:56 <ski> vraid : alternatively `(f . g . h) x y'
08:30:05 <flebron> Another question. In "f x = 5", x is an entirely fresh variable, regardless of me saying "x = 7" before or after in the file scope, correct?
08:30:10 <int-e> ski: not the same
08:30:13 <scopedTV> flebron: yes
08:30:24 <ski> vraid : er, alternatively `(f . g . h) (x y)' i meant -- which would be `(f . g . h . x) y' as an alternative
08:30:26 <flebron> Whereas I _could_ use it as part of a guard, "f y | y == x = 5".
08:30:31 <scopedTV> EvanR: pretty much, yes. It's O(length)
08:30:42 <vraid> what does `' mean?
08:30:43 <Phlogistique> flebron: GHC will warn you with -Wall
08:30:47 <scopedTV> vraid: you mean `` ?
08:30:54 <vraid> i see ` '
08:30:58 <ski> vraid : i just use it to quote Haskell code into english
08:31:01 <Phlogistique> (which annoys me because I like to shadow variables all the time when I write haskell)
08:31:06 <vraid> ah, ok
08:31:08 <scopedTV> vraid: like 4 `mod` 3 ?
08:31:19 <vraid> scopedTV: no, like what ski said, but he explained it
08:31:22 <scopedTV> Ah, now I see the context. It's just quotation.
08:31:28 <scopedTV> Yeah.
08:31:40 <EvanR> but theres a 'last'
08:32:03 <scopedTV> Yes, that function is also O(length)
08:32:08 <EvanR> guess thats not nearly as painful to do as last N
08:32:22 <scopedTV> No, it's just as slow.
08:32:32 <EvanR> yeah but its more complex
08:32:43 <Phlogistique> EvanR: last 10 is easier than last N
08:32:43 <EvanR> you have to go through it twice, or keep a record
08:32:44 <scopedTV> Only slightly.
08:33:05 <EvanR> keep a record of the last N nodes
08:33:34 <EvanR> and then if its less than N nodes...
08:33:37 <EvanR> gah
08:33:45 <Phlogistique> > let last10 xs@[a,b,c,d,e,f,g,h,i,j] = xs; last10 (x:xs) = last10 xs in last10 [1,2,3,4,5,6,7,8,9,10,11,12]
08:33:46 <lambdabot>   [3,4,5,6,7,8,9,10,11,12]
08:33:49 <rwbarton> you can use a variant of the "sneaky trick"
08:34:04 <EvanR> > let last10 xs@[a,b,c,d,e,f,g,h,i,j] = xs; last10 (x:xs) = last10 xs in last10  [1,2,3,4,5,6,7,8]
08:34:05 <lambdabot>   *Exception: <interactive>:3:4-66: Non-exhaustive patterns in function last10
08:34:11 <EvanR> brrrrr
08:34:24 <EvanR> rwbarton: sneaky trick?
08:34:40 <rwbarton> > let excess xs [] = xs; excess (_:xs) (_:ys) = excess xs ys; lastN n xs = excess xs (drop n xs) in lastN 10 [1..100]
08:34:41 <lambdabot>   [91,92,93,94,95,96,97,98,99,100]
08:35:17 <rwbarton> @where sneaky
08:35:17 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
08:35:35 <rwbarton> "takeFromEnd" I guess
08:35:43 <EvanR> mind being blown
08:35:48 <ski> > let takeLast n xs0 = loop xs0 (\_ ys -> ys) where loop [] k = k n []; loop (x:xs) k = loop xs (\n ys -> case n of 0 -> ys; _ -> k (n-1) (x:ys)) in takeLast 4 "abcdefghij"
08:35:48 <lambdabot>   "ghij"
08:36:05 <ski> > let takeLast n xs0 = loop xs0 (\_ ys -> ys) where loop [] k = k n []; loop (x:xs) k = loop xs (\n ys -> case n of 0 -> ys; _ -> k (n-1) (x:ys)) in takeLast 100 "abcdefghij"
08:36:06 <lambdabot>   "abcdefghij"
08:37:47 <ski> (you could alternatively return pairs instead ..)
08:38:08 <ski> (but this way, you don't have to pass through all the skipped frames)
08:38:40 <ski> EvanR : all clear ?
08:38:57 <EvanR> errr
08:39:16 <EvanR> still attempting to grok rwbarton
08:39:27 <ski> hm, i suppose we can do better
08:39:29 <flebron> Phlogistique, thanks :) I didn't know about that behavior re: -Wall.
08:41:10 <ski> > let takeLast n xs0 = loop xs0 (\_ -> xs0) where loop [] k = k n; loop xs0@(_:xs) k = loop xs (\n -> case n of 0 -> xs; _ -> k (n-1)) in takeLast 4 "abcdefghij"
08:41:10 <lambdabot>   "ghij"
08:41:35 <ski> could be nicer if we could start discarding tails before we reach the bottom
08:43:04 <rwbarton> i think the sneaky trick method has better space usage
08:43:09 <rwbarton> maybe that is what you just said
08:43:35 <ski> yeah, i was thinking about not holding on to the input longer than necesssary
08:43:40 <rwbarton> right
08:44:15 <ski> feels a bit overkill maybe to invoke queues here
08:44:30 <bitonic> how do I refer to type vars in the class instance declaration in the body of the methods? the ScopedTypeVariables `forall' trick doesn't work
08:45:13 <ski> rwbarton : actually, how would you do the sneaky thing, without invoking `length' ?
08:45:35 <rwbarton> I wrote it above
08:45:40 <rwbarton> > let excess xs [] = xs; excess (_:xs) (_:ys) = excess xs ys; lastN n xs = excess xs (drop n xs) in lastN 10 [1..100]
08:45:41 <lambdabot>   [91,92,93,94,95,96,97,98,99,100]
08:45:48 <ski> oh, `excess'
08:45:53 <ski> (missed that)
08:46:05 <rwbarton> I don't think there is any standard library function that will help out
08:46:20 <ski> no -- but i'm not looking for it either :)
08:47:02 <ski> bitonic : hm, pattern signatures ?
08:49:22 <bitonic> ski: what's that?
08:49:51 <ski> maybe you can paste the code in question, and i can demonstrate
08:50:24 <bitonic> ski: instance Foo (Bar a) where; foo = <code that references `a'>
08:51:29 <ski> and what is the type of `foo' ?
08:51:34 <Saizan> excess ~ zipWith const, but with more sharing
08:52:10 <bitonic> ski: let's say `Quux a -> Whatever'
08:52:16 <ski> the `zipWith const' version however didn't do the same thing
08:52:22 <ski> bitonic : ok, so then write
08:52:22 <bitonic> can you write out the typesig explicitly? iirc you can't
08:52:32 <ski>   foo (... :: Quux a) = ...
08:52:49 <bitonic> ski: ah, right. I solved that specific instance in another way, but thanks.
08:52:58 <ski> bitonic : "can you write out the typesig explicitly? iirc you can't" unfortunately you can't (one ought to be able to, imo)
08:53:20 <ski> bitonic : in case the variable is in the return type, you coul also say
08:53:26 <ski>   foo x :: Blah a = ...
08:53:33 <ski> (or combining both)
08:53:36 <bitonic> ski: ah, that I didn't know. thanks.
08:53:47 <rwbarton> foo :: a -> Blah a = ... ? (yuck)
08:53:58 <rwbarton> maybe (foo :: a -> Blah a) = ...
08:54:03 <bitonic> rwbarton: I don't thinky ou can do that in that instance...
08:54:05 <ski> bitonic : would also work, if it's not a function-style definition
08:54:14 <ski> er, rwbarton ^
08:54:30 <rwbarton> interesting, i guess not
08:54:36 <ski> (are you defining `maybe' in that last one ?)
08:54:49 <rwbarton> it doesn't actually work
08:55:00 <rwbarton> "Pattern bindings (except simple variables) not allowed in instance declarations"
08:55:06 <parcs`> @hoogle numCapabilities
08:55:06 <lambdabot> GHC.Conc.Sync numCapabilities :: Int
08:55:07 <lambdabot> GHC.Conc numCapabilities :: Int
08:55:12 <ski> oh, that's interesting
08:55:28 <ski> i suppose you could do a local `where', then
08:55:37 <rwbarton> ew
08:55:39 <rwbarton> but yes
08:55:42 * ski nods
08:56:08 <rwbarton> same error with no parentheses
08:56:19 <scopedTV> Why can't I overload function application?
08:56:28 <rwbarton> would that bring a into scope, anyways?
08:56:37 <rwbarton> foo :: a -> Blah a = ...   I mean
08:56:38 <ski> rwbarton : yeah
08:57:10 * ski actually prefers this style to the `blah :: forall a. ..a..' one
08:57:29 <ski> (mostly, but not fully, because of the use of `forall' here)
08:57:37 <bitonic> scopedTV: {-# LANGUAGE OverloadedArrows #-}
08:57:55 <scopedTV> Does that exist?
08:58:11 <rwbarton> I have wished for overloaded application too but in practice I think it would be a terrible idea
08:58:24 <bitonic> scopedTV: nope
08:58:25 <scopedTV> Why, rwbarton?
08:58:33 <ski> in restricted scopes, it might be bearable
08:58:37 <rwbarton> you would lose almost all ability to infer types
08:58:38 <bitonic> scopedTV: type signatures EVERYWHERE
08:58:45 <rwbarton> which rather defeats the purpose
08:58:49 <bitonic> it would be hell
08:59:04 <scopedTV> I see.
09:00:23 <rwbarton> it would depend on the design of course,  "class Apply a b c where apply :: a -> b -> c" might be okay with functional dependencies a -> b, a -> c
09:00:43 <rwbarton> or at least not a total disaster
09:01:16 <scopedTV> That would be useful for maps, for example.
09:02:19 <scopedTV> It would also hold for data FWM a b c = FWM { f :: a -> b, meta :: c }, afaics
09:04:51 <bitonic> jaspervdj: is there a way through the WebSockets interface to actively reply to requests?
09:05:34 <bitonic> e.g. detect when something new is pushed on the Iteratee and respond
09:08:59 <vraid> factors n	= a : factors (n/a) | a <- factor n 2
09:09:23 <vraid> i'm trying to make a list, with 'factors :: Int -> [Int]', and 'factor :: Int -> Int -> Int'
09:09:36 <vraid> but i can't figure the syntax out
09:09:59 <ski> maybe you want a list comprehension ?
09:10:20 <ski> hm, or maybe not
09:10:21 <mauke> factors n = let a = factor n 2 in a : factors (n `div` a)
09:14:39 <vraid> now i get *** Type           : String -> IO () *** Does not match : a -> b -> c
09:14:40 <vraid> at putStrLn show (last (factors 600851475143))
09:14:55 <scopedTV> putStrLn (show (last (factors 37)))
09:15:15 <scopedTV> What you're doing is (putStrLn show) (last (factors 37))
09:15:43 <mauke> ooh, hugs?
09:15:55 <vraid> ah, got it, thanks
09:16:08 <mauke> @src print
09:16:08 <scopedTV> Looks like hugs, yes.
09:16:09 <lambdabot> print x = putStrLn (show x)
09:16:17 <scopedTV> I did not know that people are still using hugs.
09:16:28 * ski hugs vraid
09:16:32 <vraid> now is the question if this is a horrible factorisation algorithm or not http://codepad.org/yihFOcj7
09:16:54 <scopedTV> Yes, quite horrible.
09:17:20 <ski> you shoul use guards, or at least `if'-`then'-`else', instead of the `case'
09:17:43 <vraid> i haven't gotten to that syntax
09:17:57 <scopedTV> You're doing too much work.
09:18:07 <ski> the outer brackets between `case' and `of' are redundant
09:18:08 <tac-tics> ski: For readability? Or is case-matching on Bools slower than those?
09:18:19 <ski> tac-tics : for readability
09:18:30 <ski> the efficiency should be the same
09:18:32 <scopedTV> Readability suggests patterns, but it's fine.
09:18:41 <tac-tics> gotcha
09:18:48 <vraid> only the factor function is bad?
09:18:48 <scopedTV> Really it's just sugar. If you don't know them, fine.
09:18:59 <scopedTV> Well this is the most naive factoring algorithm.
09:19:19 <scopedTV> Humankind knows better ones.
09:19:40 <vraid> i'm trying to learn the language syntax here, not arrive at optimal solutions :)
09:20:05 <scopedTV> Oh other than that I think it's ok.
09:20:13 <scopedTV> replace putStrLn (show ( by print (
09:20:21 <scopedTV> You can remove the "do" in line 12.
09:20:37 <rwbarton> if you paste your code on hpaste.org it will make many of these suggestions automatically
09:20:59 <vraid> do is required for multiple procedures?
09:21:16 <scopedTV> vraid: do is syntactic sugar for >>=
09:21:18 <ski> `do' is required iff you have more than one command in the block
09:21:18 <mauke> do is technically never required
09:21:33 <scopedTV> vraid: but yeah, what you said is the gist of it.
09:21:35 <vraid> i haven't gotten to >>= either
09:21:44 <scopedTV> It doesn't harm anything to have a "do" lingering there.
09:21:49 <mm_freak> as i'm implementing a compiler for a functional language i can see how with a non-optimizing compiler "print = putStrLn . show" can have a performance penalty compared to "print x = putStrLn (show x)"…  is that true for GHC?  and if no, is it because of optimizations or a clever way of creating the graph?
09:21:55 <scopedTV> Also, I think you're starting over from "2" all the time, aren't you.
09:21:56 <rwbarton> do is for building up larger actions out of smaller actions, here there is just one action so you don't need "do"
09:22:08 <ski> > do do 2 + do 3
09:22:09 <lambdabot>   5
09:22:14 <vraid> yeah, like the scheme do
09:22:25 <vraid> if i recall correctly
09:22:27 <ski> Scheme `do' is something completely different
09:22:29 <yan_> i finally finished a small tool i was working on, can someone take a quick look at the way its structured (it's small) and just comment on if it has any obvious awful style choices? https://github.com/yan/hhhhoard
09:22:42 <yan_> er not finished, but got to a point where it's useful
09:22:49 <ski> `do' in Haskell is more like `let*' in Scheme, sortof
09:23:24 <scopedTV> vraid: you could add, optionally, a type signature for "main", namely main :: IO ()
09:23:27 <FudgeSickle> @undo do do 2 + do 3
09:23:28 <lambdabot> 2 + 3
09:23:37 <FudgeSickle> heh
09:23:47 <yan_> does lambdabot eval anthing set in this channel?
09:23:57 <scopedTV> yan_: Yes.
09:24:00 <yan_> neat
09:24:02 <tac-tics> It will eval anything with a > at the start (to the best of its ability)
09:24:03 <yan_> said*
09:24:03 <tac-tics> > 1 + 1
09:24:04 <lambdabot>   2
09:24:07 <scopedTV> yan_: It does not execute IO actions, though.
09:24:11 <tac-tics> > head "abc"
09:24:12 <mm_freak> > let 1 + 1 = 3 in 1 + 1
09:24:12 <lambdabot>   'a'
09:24:13 <scopedTV> She*
09:24:13 <lambdabot>   can't find file: L.hs
09:24:30 <ski> @slap L.hs
09:24:30 <lambdabot> *SMACK*, *SLAM*, take that L.hs!
09:24:35 <mm_freak> huh?
09:24:36 <mm_freak> > let 1 + 1 = 3 in 1 + 1
09:24:37 <lambdabot>   3
09:24:39 <mm_freak> ah
09:24:47 <mm_freak> there we go…  apparently it has some kind of flood protection =)
09:24:56 <mauke> no, it doesn't
09:24:59 <quicksilver> mm_freak: I honestly don't know; are you familiar in general with the STG approach?
09:24:59 <ski> .. alternatively a race condition
09:25:25 <mm_freak> quicksilver: i'm familiar with the G approach, but my understanding is that an STG has the same graph, just evaluates it differently
09:25:33 <quicksilver> mm_freak: there are some subtleties in how it handles fully saturated functions which I'm not confident with
09:26:07 <quicksilver> mm_freak: I would say, as a starter, that (.) will inline, so putStrLn . show is the same as (\x -> putStrLn (show x))
09:26:18 <quicksilver> mm_freak: I'm not sure if it was the (.) or the eta-expansion you were worrying about.
09:26:35 <mm_freak> hmm, inlining could indeed make a difference
09:26:36 <dwierenga> i'm brand-new to haskell. can anyone recommend which DB library to use to connect to MS Sql Server?  this could be for either linux or windows.
09:26:46 <mm_freak> i was assuming no inlining, but (.) as a supercombinator
09:27:15 <quicksilver> the GHC design appears (to my deeply uninformed eye) to rely very heavily on inlining
09:27:29 <vraid> is this better syntax for factorization? http://codepad.org/VbCDOf6K
09:27:30 <scopedTV> dwierenga: I'm not sure there are any. Did you try to look on hackage?
09:27:46 <mm_freak> with no inlining the graph of 'print (show x)' is, App "print" (App "show" x), while the graph of "(print . show) x" is App (App (App "." "print") "show") x
09:27:48 <scopedTV> vraid: Yes, definitely!
09:27:51 <tac-tics> vraid: looks good.
09:27:59 <quicksilver> mm_freak: yes. the inlining is key there.
09:28:03 <scopedTV> vraid: note that you can use "otheriwse" instead of True there.
09:28:05 <tac-tics> vraid: One note. The convention in haskell is to use "otherwise" instead of "True"
09:28:06 <c_wraith> GHC definitely depends on huge amounts of inlining
09:28:07 <scopedTV> (in line 4)
09:28:12 <quicksilver> however I also know that eta-conversion is not a NOP
09:28:23 <quicksilver> eta-converted forms will produce different code in at least some cases.
09:28:26 <scopedTV> vraid: but it's the same thing. "otherwise" is defined as "True" in the Prelude.
09:28:26 <vraid> got it :)
09:28:30 <quicksilver> I do not know which.
09:28:31 <dwierenga> scopedTV: it looks like HSQL, HDBC and Takusen can all do it (allegedly).  Google doesn't reveal the Haskell's community preference though
09:28:32 <scopedTV> eh, no.
09:28:39 <ski> vraid : also, s/(f * f)/f * f/
09:28:57 <mm_freak> i wonder what happens in GHC…  i see no practical performance penalty in using (.)
09:29:04 <scopedTV> one of HSQL/HDBC was LGPL iirc, the other BSD.
09:29:08 <mm_freak> perhaps i should examine the core
09:31:25 <mm_freak> ski: minor nitpick: that replaces "fabc" by "f * f"
09:31:29 <mm_freak> ski: minor nitpick: that replaces "fabc f" by "f * f"
09:31:32 <quicksilver> mm_freak: examining the core is good. Also you could ask JaffaCake. He's not likely to be around at this time of day though.
09:31:48 <mm_freak> ok, thanks
09:32:02 <c_wraith> he was around an hour and a half ago...  This is only just slightly too late to catch him.
09:35:36 <xplat> can someone remind me how to get ghci to print the time taken and bytes allocated?
09:35:56 <hpc> :set +s, iirc
09:35:58 <byorgey> :set +s
09:36:07 <hpc> yeah
09:36:31 <hpc> see also, :help
09:36:41 <xplat> ah, thanks
09:37:32 <osa1_> is there a way to install a library's not most-recent version from cabal?
09:38:09 <byorgey> osa1_: yes,  cabal install foo-library-0.6.93
09:38:31 <byorgey> I mean you just append -version to the end of the package name
09:38:36 <osa1_> thanks
09:39:27 <mm_freak> xplat: note that the stats of GHCi are not really representative…  you should use the RTS flag -s in the compiled program instead
09:43:07 <ski> mm_freak : `fabc' ?
09:43:48 <xplat> mm_freak: i just wanted to compare stats with someone else who used +s.  and 'representative' depends on how you plan to use the code, too
09:43:48 <mm_freak> ski: that was a typo, see the next line
09:44:06 <ski> where did `fabc' come from ?
09:44:21 <mm_freak> oh, my apologies
09:44:31 * ski doesn't understand
09:44:39 <mm_freak> f * f matches "f f", "f  f" and "f   f", but not "f * f"
09:44:46 <mm_freak> or "ff" for that matter
09:44:53 <ski> oh, right, regexen
09:45:17 * ski stands corrected
09:47:57 <ismail> hi anyone listening?
09:48:00 <mm_freak> a language is at least context-sensitive, when a finite context-free grammar can't express it, right?
09:48:16 <mm_freak> ismail: go ahead
09:49:02 <ismail> i am new to this language haskell, but i know that it has got something to do with lambda calculus. Does anyone have suggestions for online-reading about that?
09:49:17 <rasfar> @where LYAH
09:49:18 <lambdabot> http://www.learnyouahaskell.com/
09:49:25 <rasfar> hey i got it right!
09:49:45 <mm_freak> hehe
09:50:03 <rasfar> ismail, that's the usual recommendation, presuming you've had some programming experience at least.
09:50:41 <mm_freak> ismail: the lambda calculus is pretty simple, but can be confusing (i.e. simple ≠ easy)…  i suggest learning haskell without regard for the lambda calculus for now, unless you are a math inclined person anyway
09:50:42 <hpc> LYAH should still be just as easy to grasp if you haven't programmed before, i think
09:50:45 <hpc> possibly easier
09:50:45 <ismail> yes, i can code
09:50:47 <ismail> thank you
09:51:33 <ismail> i am a maths student @mm_freak
09:51:41 <flebron> We teach Haskell as a first programming language in my university, it's indeed quite easy if you've never programmed, but know basic math like what a function is.
09:52:04 <mm_freak> ismail: in that case basic ("untyped") lambda calculus can be learned from wikipedia
09:52:38 <mm_freak> ismail: http://en.wikipedia.org/wiki/Lambda_calculus
09:52:47 <flebron> Lambda calculus is one of the formalisms to define computation, like Turing machines are.
09:53:31 <ismail> Thanks a lot
09:54:02 <ismail> I am looking for a "tutorial" with examples from lambda calculus
09:54:16 <ismail> Or an introduction
09:54:29 <ismail> Where lambda calculus is explained with haskell
09:55:03 <mm_freak> ismail: lambda calculus is the formalism on which haskell expressions are built…  in fact haskell is compiled to (a slightly extended) lambda calculus, and that is then compiled to machine code…  however, that all is really not necessary to understand the language
09:55:25 <rasfar> I imagine the lambda calculus would have more appeal to someone mathematically-inclined, and Turing machines to the engineering-inclined.
09:55:46 <mm_freak> yeah, lambda calculus has some mathematical elegance to it
09:55:46 <rasfar> s/ to / for /g
09:58:18 <ismail> Great. The reason why im asking is this: I am studying lambda calculus, but i don't want to scratch every calculation on paper. I have heard, that i can emulate lambda "applications" with haskell
09:58:44 <mm_freak> ismail: not on untyped lambda calculus
09:58:49 <ismail> For example i'd like to play with church numerals
09:59:24 <mm_freak> you can't project untyped lambda calculus to haskell…  for example there is no corresponding haskell expression for the Y combinator
09:59:39 <mm_freak> you can write the /expression/, but the compiler will reject it because it's illtyped
09:59:49 <sepp2k> ismail: You can't represent those directly (i.e. without wrapper types) in Haskell.
09:59:55 <ismail> my beloved Y combinator
10:00:19 <sepp2k> ismail: You might look at scheme for that (if strict semantics are okay for you).
10:00:44 <sepp2k> There's also a lazy scheme dialect somewhere, now that I think about it.
10:01:35 <sepp2k> Plus you'll probably find plenty of interpreter for the actual untyped lambda calculus with various evaluation strategies on the web.
10:02:01 <mm_freak> ismail: you can use haskell to write a DSL for the untyped lambda calculus
10:02:10 <ismail> What means DSL?
10:02:18 <mm_freak> domain-specific language
10:02:58 <mm_freak> write a type that captures lambda calculus expressions, then you can implement things like conversion, reduction, substitution, etc.
10:03:22 <mm_freak> data Expr = App Expr Expr | Lam Name Expr | Var Name
10:03:53 <ismail> is there a way to save this chat script?
10:03:55 <vraid> what function can i use to turn an int into a list of digits?
10:04:37 <mm_freak> > reverse . map (`mod` 10) . takeWhile (> 0) . iterate (`div` 10) $ 12345
10:04:39 <lambdabot>   [1,2,3,4,5]
10:04:59 <rasfar> ismail, worst case you can find the logs at tunes.org
10:05:00 <mm_freak> vraid: in general the non-reversed variant is easier to deal with
10:05:01 <hpc> > digitToInt . show $ 12345
10:05:03 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
10:05:03 <lambdabot>         against inferred type...
10:05:07 <hpc> > map digitToInt . show $ 12345
10:05:09 <lambdabot>   [1,2,3,4,5]
10:05:25 <hpc> that one works in other bases too
10:05:30 <mm_freak> > map digitToInt . show $ "-13"
10:05:31 <ismail> hey this lambdabot is just great!
10:05:32 <lambdabot>   [*Exception: Char.digitToInt: not a digit '"'
10:05:40 <hpc> cheater!
10:05:53 <mm_freak> > reverse . map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10) $ (-12345)
10:05:58 <lambdabot>   mueval-core: Time limit exceeded
10:05:58 <rwbarton> you got it wrong anyways
10:06:09 <rwbarton> but yes
10:06:11 <vraid> so show converts the int into a string of chars, digit to int converts these chars back to ints?
10:06:17 <mm_freak> > reverse . map (`rem` 10) . takeWhile (/= 0) . iterate (`quot` 10) $ (-12345)
10:06:20 <lambdabot>   [-1,-2,-3,-4,-5]
10:06:37 <hpc> vraid: yep; mm_freak is doing it the algebraic way
10:07:21 <vraid> both are good to know
10:11:09 <jaspervdj> bitonic: How do you mean?
10:15:00 <ismail> Does gcc have haskell compiler or interpreter?
10:15:17 <parcs`> ismail: nope
10:16:02 <ismail> is there any haskell compiler or interpreter for linux?
10:16:05 <bitonic> jaspervdj: I'd like to "respond" to clients requests, instead of just sending/receiving things
10:16:47 <BrianHV> ismail: ghc and ghci work fine on linux
10:16:50 <rasfar> ismail, of course -- i think they all can run under linux?
10:17:10 <jaspervdj> bitonic: Well you can inspect the URL in the HttpRequestPart
10:17:25 <jaspervdj> and act based on that
10:17:40 <jaspervdj> but for request-reply, you might be better of with just HTTP
10:17:44 <mm_freak> ismail:
10:17:48 <mm_freak> @where haskell platform
10:17:48 <ismail> do you have names?
10:17:48 <lambdabot> http://haskell.org
10:17:52 <ismail> okey
10:17:53 <mm_freak> @where haskellplatform
10:17:53 <lambdabot> I know nothing about haskellplatform.
10:17:57 <mm_freak> hmm
10:18:01 <mm_freak> @where hp
10:18:02 <lambdabot> http://hackage.haskell.org/platform/
10:18:03 <mm_freak> ah
10:18:06 <mm_freak> ismail: this one
10:18:22 <rasfar> or you could boldly go ... UHC
10:19:11 <teneen> Is it possible to use the primitive hash constructor of Int? as it is used in the Prelude for example?
10:19:13 <rasfar> probably >99% of people here use ghc/ghci so you'll get better support with that, but alternatives exist
10:19:20 <bitonic> jaspervdj: no I mean responding to websocket requests, the RequestHttpPart only contains the HTTP handshare request information
10:20:17 <bitonic> jaspervdj: e.g. this node library: https://github.com/faye/faye-websocket-node predictably works with callbacks and offers "onmessage" and "onclose". I'd like to have something similar using websockets
10:20:17 <jaspervdj> bitonic: well, basically just receive a request message, then send a response message back? You can use something like JSON for both.
10:20:18 <rasfar> (it comes with the afore-mentioned Haskell Platform, which is the recommended way to install)
10:20:25 <teneen> (I#  m#), can I use the primitive functions with m#?
10:20:34 <Enigmagic> teneen: enable -XMagicHash and import GHC.Types (i think)
10:20:39 <jaspervdj> bitonic: callbacks are the JavaScript way
10:20:45 <jaspervdj> Iteratee monads are the Haskell way
10:20:58 <teneen> Enigmagic: Is this unboxing?
10:21:03 <bitonic> jaspervdj: I know I know, but I have to deal with the Javascript way right now and I need a similar interface
10:21:19 <bitonic> jaspervdj: anyways, thanks
10:21:34 <Enigmagic> teneen: yeah, that's dealing directly with the unboxed, unlifted integer
10:21:44 <jaspervdj> bitonic: in that case, you can have something like: loop :: (Message -> WS ()) -> WS ()
10:21:55 <mm_freak> ismail: note that your distribution likely comes with haskell packages…  some even have a "haskell platform" package
10:21:57 <jaspervdj> bitonic: with an implementation that just receives/responds according to the callback
10:22:02 <teneen> Enigmagic: Thanks!
10:22:27 <Enigmagic> teneen: the compiler will try to convert things to that form most of the time anyways so unless you are calling a function that takes a Int# it may not be worth the effort
10:22:55 <bitonic> jaspervdj: yeah right
10:23:10 <jaspervdj> bitonic: I have to run, if trouble comes up, feel free to mail me
10:23:38 <bitonic> jaspervdj: I think I'm just getting confused by this python/js code I'm reading
10:23:43 <bitonic> that's doing strange things
10:23:52 <bitonic> and I have to shift everything to enumerators
10:24:17 <ismail> mm_freak: i am running opensuse 12.1 and just installed the ghc package. unstable 7.1
10:24:27 <bitonic> jaspervdj: aaaahhh ok. I was misreading. My bad
10:25:34 <mm_freak> ismail: you should probably go with manually installing the haskell platform then
10:25:54 <mm_freak> ismail: remove the GHC package you installed before you do that
10:26:21 <ismail> does ghc not run well?
10:28:31 * kallisti is ensure how to do error handle on filesystem trees.
10:28:54 <kallisti> uh
10:28:55 <kallisti> unsure
10:29:56 <mm_freak> ismail: it runs well and is part of the platform
10:31:01 <ismail> understand
10:32:52 <ismail> so you mean \me install from source
10:33:22 <mm_freak> ismail: you're not installing from source when you install the platform
10:35:36 <ismail> I find no way for opensuse to install manually haskell platform without installing from source. please give me a hint
10:37:41 <mm_freak> ismail: i might have been wrong…  it seems like installing from source is the way to go to manually install the platform…  perhaps you indeed want to use the opensuse packages
10:37:45 <mm_freak> sorry
10:39:01 <ismail> thank's for setting things right
10:39:23 <ismail> i hope that simple ghc will do what i need :-)
10:40:15 <saml> i have a Map, how can I lookup?  like  map[k]
10:40:17 <geekosaur> wait, what?  there's a binary (with a make install that just patches pathnames so you can install it wherever) and there's a link wiht an opensuse icon to prebuilt haskell platform packages
10:41:19 <sepp2k> saml: Using the lookup function
10:41:19 <ismail> where exactly?
10:41:28 <saml> oh lookup thanks
10:41:35 <saml> prelude was shadowing
10:42:13 <sepp2k> saml: Yeah, it does that a lot with map. That's why people usually import Map qualified
10:42:19 <cg_morton> ismail, what was the problem with using the opensuse packages?
10:42:22 <geekosaur> https://build.opensuse.org/package/repositories?package=ghc&project=devel%3Alanguages%3Ahaskell follow link for your distribution to find prebuilt packages
10:42:54 <geekosaur> although I'm not sure why I have to click clearly marked links from the haskell plaform page... I didn;t think they were that difficult to sort out
10:44:28 <mm_freak> saml: that's not shadowing, it's just a name clash
10:44:51 <mm_freak> the compiler doesn't know which "lookup" you're referring to, unless you qualify the name
10:44:58 <mm_freak> import qualified Data.Map as M
10:45:00 <mm_freak> M.lookup
10:45:11 <relation> is there a way to comment function argument such that it appears somehow in haddock?
10:45:30 <cg_morton> say, who maintains the page on http://hackage.haskell.org/platform/linux.html ?  The Arch Linux link is broken
10:46:02 <hpaste> “Ertugrul Söylemez” pasted “Haddock-document arguments” at http://hpaste.org/68287
10:46:08 <mm_freak> relation: see paste
10:46:40 <relation> mm_freak thanks
10:48:23 <relation> mm_freak: thanks, now I've realized how close I was :-D
10:48:50 <mm_freak> relation: it's a bit unfortunate, but the arrow must appear to the left
10:49:28 <saml> hey, lambdabot doesn't have Data.Map ?
10:49:40 <gwern> @roll 0d1
10:49:41 <lambdabot> Consider it noted.
10:49:51 <gwern> @dice 0d1
10:49:51 <lambdabot> 0d1 => 0
10:50:19 <vraid> @dice 5d20
10:50:19 <lambdabot> 5d20 => 38
10:51:38 <saml> > Data.Map.fromList [('a', 1)]
10:51:39 <lambdabot>   Not in scope: `Data.Map.fromList'
10:52:01 <mm_freak> > M.singleton 3 'x'
10:52:02 <lambdabot>   can't find file: L.hs
10:52:15 <jeff_s_> Interesting, I performed one forkIO, yet all my processors are being used.
10:52:17 <mm_freak> > Map.singleton 3 'x'
10:52:19 <lambdabot>   Not in scope: `Map.singleton'
10:52:25 <mm_freak> @undef
10:52:28 <mm_freak> > M.singleton 3 'x'
10:52:29 <lambdabot>   fromList [(3,'x')]
10:52:32 <mm_freak> there you go
10:52:56 <kallisti> what's a good way to handle errors while traversing a tree?
10:53:03 <kallisti> what's the most flexible approach, I mean.
10:53:15 <mm_freak> kallisti: use a monadic traversal combinator
10:53:45 <kallisti> hm, continuations perhaps?
10:53:52 <kallisti> I could be overcomplicating things.
10:53:58 <mm_freak> kallisti: yeah
10:54:12 <kallisti> well for example
10:54:14 <mm_freak> when you have:  foldTree :: (a -> b) -> (b -> b -> b) -> Tree a -> b
10:54:30 <mm_freak> have:  foldTreeM :: (a -> m b) -> (b -> b -> m b) -> Tree a -> m b
10:54:36 <mm_freak> add a (Monad m) constraint, of course
10:54:37 <kallisti> it's not that kind of tree.
10:54:45 <kallisti> but yeah it would look similar to that.
10:54:53 <mm_freak> whatever tree it is, you can always write a folding combinator
10:54:57 <kallisti> yes
10:55:08 <kallisti> but that doesn't... provide anything.
10:55:09 <mm_freak> or use explicit recursion, if you wish
10:55:15 <kallisti> it's like saying:  yeah you don't need anything else, just use a for loop!
10:55:21 <mm_freak> sure it does:  'm' can be Maybe or some Either
10:55:41 <mm_freak> you're folding the tree…  in a pure fold you can't handle errors
10:55:44 <mm_freak> in a monadic fold you can
10:56:00 <mm_freak> same as 'map' vs. 'mapM'
10:56:46 <mm_freak> if you want to actually /handle/ errors, i.e. exception handling, you probably want to traverse the tree explicitly
10:57:49 <saml> how can I unlet something i @let  in lambdabot?
10:58:01 <kallisti> mm_freak: well the idea is to provide some common filesystem manipulation operators
10:58:05 <kallisti> like recursive removal
10:58:11 <kallisti> I already have a simple version of that
10:58:20 <kallisti> but if an exception is triggered the whole thing stops in an intermediate state.
10:58:46 <kallisti> I also have a version that lets you add an exception handler to each removal
10:59:28 <monochrom> "in a pure fold you can't handle errors. with meth, you can"? :)
11:01:29 <hpaste> “Jeff Shaw” pasted “not tail recursive?” at http://hpaste.org/68288
11:01:45 <jeff_s_> Anybody have an idea about why this function takes so much memory?
11:01:53 <jeff_s_> (For very large values of n.)
11:02:24 <jeff_s_> If it makes a difference, I'm running ghci (or running the compiled program) with -N4
11:03:42 <fmap> the problem can be (n-1) thunk
11:03:43 <monochrom> the IORef stores a huge addition chain rather than a number
11:03:57 <jeff_s_> Oooooh, thanks.
11:04:07 <monochrom> no, n-1 is evaluated because of the pattern matching "incr 0 ... = ..."
11:04:16 <fmap> ah
11:04:17 <fmap> yes
11:04:40 <jeff_s_> er, oh, ok.
11:04:56 <monochrom> it is the \x -> (x+1...
11:04:57 <kallisti> integer operations are strict, btw.
11:05:10 <kallisti> numeric operations actually
11:05:16 <kallisti> (for built-in in numeric types)
11:05:21 <kallisti> you can easily make lazy numeric types.
11:07:33 <hpaste> “Jeff Shaw” annotated “not tail recursive?” with “not tail recursive? (annotation)” at http://hpaste.org/68288#a68289
11:08:05 <jeff_s_> I added the main function. Interestingly, even if I perform only one forkIO, it uses all 4 of my CPUs.
11:08:42 <c_wraith> atomicModifyIORef will never do anything *except* put a thunk into the IORef
11:08:52 <c_wraith> that's a key part of how it is implemented
11:09:02 <scooty-puff> when/how are lattices used in type inference - any type inference (not necessarily haskell, unless with extensions it does something different than the HM(X)++ stuff)
11:09:22 <scooty-puff> when are they/how are they/can they
11:10:16 <jeff_s_> c_wraith, so I'm making thousands of (+1) thunks, and then when I read the IORef, it evaluates them?
11:10:30 <rwbarton> when you try to print x it evaluates them/x
11:10:30 <c_wraith> yes
11:10:41 <c_wraith> err, yeah. reading the ioref is irrelevant
11:10:50 <c_wraith> it's when you do something that needs to examine the read value that matters
11:10:51 <jeff_s_> well, right
11:11:10 <hpaste> c_wraith annotated “not tail recursive?” with “not tail recursive? (annotation) (annotation)” at http://hpaste.org/68288#a68290
11:11:45 <c_wraith> that is a sort of hacky way to get around it. Note that it actually forces the value after atomicModifyIORef has returned
11:12:03 <c_wraith> But since the thunk is shared, the evaluation is shared
11:12:08 <jeff_s_> c_wraith, that's very clever. I like it!
11:12:52 <jeff_s_> I tried something similar, but I missed the "evauluate x" part.
11:13:46 <jeff_s_> I take it that modifyMVar has the same problem?
11:13:56 <c_wraith> Actually, it doesn't
11:14:01 <c_wraith> because it works with IO actions
11:14:06 <c_wraith> rather than pure functions
11:14:15 <rwbarton> @type modifyMVar
11:14:17 <lambdabot> Not in scope: `modifyMVar'
11:14:17 <jeff_s_> Oh, interesting. I see.
11:14:18 <c_wraith> it needs to execute the action in order to generate the value put into the MVar
11:14:48 <c_wraith> So if executing the action fully evaluates the result, that suffices
11:15:34 <monochrom> reading an IORef still does not evaluate the thunk stored. reading just means duplicating a pointer.
11:16:10 <jeff_s_> Right, that makes perfect sense. That's why evaluate (or maybe rdf?) is required.
11:16:42 <monochrom> atomicModifyIORef r (\x -> let y=x+1 in seq y (y, ()))  may help
11:16:47 <jeff_s_> by rdf I mean rnf.
11:17:24 <monochrom> another devious scheme is atomicModifyIORef r (\x -> let y=x+1 in (y,y)) >>= evaluate
11:17:49 <c_wraith> monochrom: that's exactly equivalent to what I pasted, right?
11:18:04 <c_wraith> (well, except I left in the useless strictness stuff, I shouldn't have)
11:18:06 <monochrom> I haven't read your paste. may very well be the same
11:18:11 <jeff_s_> It is.
11:18:28 <jeff_s_> You're both geniuses.
11:18:58 <monochrom> I'm inclined to leave the evaluation outside the critical section
11:19:38 <scooty-puff> i assume its the same with STRef?
11:19:47 <jeff_s_> Is there any reason not to use MVar if I'm going to evaluate the contents of the IORef, anyway? (I'll BRB.)
11:20:06 <monochrom> yes, same thunking in STRef
11:20:20 <c_wraith> is there an atomicModifySTRef?
11:20:43 <monochrom> there isn't. there is no forkST either.
11:20:51 <c_wraith> oh.  good opint
11:21:25 <monochrom> MVar does not lead to less thunking
11:21:29 <c_wraith> Since ST is explicitly designed to stop sharing STRefs across different ST actions, there's no real usefulness in it
11:21:50 <scooty-puff> were i to want to change that, would it be as simple as newRef init = init `seq` newSTRef init; writeRef r x = x `seq` writeSTRef r x?
11:22:15 <c_wraith> that would work for things where WHNF is sufficient
11:22:20 <c_wraith> would be pretty useless for String
11:22:25 <scooty-puff> right
11:22:25 <scooty-puff> ok
11:22:59 <scooty-puff> there was one occasion where i defined data List a = Nil | a :| !(List a) just to make it work..
11:23:43 <monochrom> yeah, that or rnf
11:28:31 <jeff_s_> Thanks everyone! I learned a lot of useful information about thunks and IORefs.
11:37:37 * hackagebot xhtml 3000.2.1 - An XHTML combinator library  http://hackage.haskell.org/package/xhtml-3000.2.1 (ChrisDornan)
11:39:10 <davidd___> can someone please tell me why let myLast xs = last xs doesn't work for this problem http://www.haskell.org/haskellwiki/99_questions/Solutions/1
11:40:09 <rwbarton> it does work, but I think it misses the point somewhat
11:40:59 <davidd___> rwbarton: thank you
11:49:20 <ZettaBlade> haskell is the shiiiiiitttttt
11:49:30 <cg_morton> word
11:50:38 <EvanR> aint that some shit
11:51:18 <ZettaBlade> If only it could help me with my chem homework. Then I'd be set!
11:57:44 <dmwit> davidd___: Not only does it work, it's listed as one of the solutions.
11:58:24 <davidd___> dmwit: you're right
12:08:51 <ZettaBlade> beer+haskell=???
12:09:00 <c_wraith> productive
12:09:02 <EvanR> dysfunctional code
12:09:30 <c_wraith> only language in which I've ever written a large library that has several other users while drunk :)
12:09:46 <hpc> c_wraith: which library?
12:09:52 <c_wraith> (tests were written while sober!)
12:09:58 <EvanR> the type system means you dont have to walk the straight line so much ;)
12:09:58 <ZettaBlade> you can thank beer for the existence of haskell
12:09:59 <c_wraith> lrucache
12:10:02 <ZettaBlade> just sayin'
12:14:05 <ZettaBlade> what is your favorite codebase?
12:14:42 <kallisti> Win32 API
12:15:13 <ZettaBlade> FUUUUUUUUUUU-
12:15:38 <ZettaBlade> that's piss!
12:16:02 <ZettaBlade> I'm talking about stuff you actually like
12:16:34 <ZettaBlade> freakin' trolls man
12:17:22 <c_wraith> Something you'll learn in here is that many of us have decided we hate most languages and code bases - it's just a matter of "what's the most tolerable?" :)
12:18:02 <EvanR> everything sucks
12:18:58 <jgr> EvanR: except for what i wrote in the last 10 minutes.
12:19:10 <c_wraith> jgr: in another 10 minutes, you'll hate it too
12:19:17 <jgr> c_wraith: right.
12:19:22 <jgr> c_wraith: that was my point.
12:21:25 <ZettaBlade> AHHHH
12:21:31 <ZettaBlade> programmers are crazy!
12:21:43 <scopedTV> orly?
12:21:57 <EvanR> you dont say.jpg
12:22:09 <davidd___> is it just me or does haskell have a lot of cool operators to manipulate functions (e.g. $, ., ``)
12:22:23 <EvanR> `` isnt an operator
12:22:28 <c_wraith> davidd___: that's kind of the point of functional programming
12:22:28 <kallisti> it's certainly not a coincidence.
12:22:35 <scopedTV> davidd___: you can define your own even :)
12:22:44 <scopedTV> f >++>> g = g . f
12:22:49 <mauke> it's almost like it's a functional language
12:22:50 <davidd___> wow
12:23:12 <scopedTV> There are some things that cannot be made into functions, like -- (this is used for comments)
12:23:15 <davidd___> maybe I am a newb but I haven't been able to do those things in clojure... at least not yet
12:23:29 <jgr> scopedTV: literal haskell! :)
12:23:33 <scopedTV> They exist in Clojure, it's just not so pretty.
12:23:39 <davidd___> I see
12:23:59 <scopedTV> But the syntaxis is something that is for the most part taste.
12:24:08 <scopedTV> in Clojure I suppose it's more essential than that.
12:24:13 <cg_morton> clojure has macros, so you can do -anything-
12:24:42 <kallisti> it's just not as easy as lazy evaluation for the most common cases.
12:25:03 <scopedTV> I like static typing.
12:25:10 <EvanR> famous last words "___ has macros, so you can do *anything*"
12:25:46 <ZettaBlade> c has macros, so you can do *anything*
12:25:55 <kallisti> also we have TH, which is equivalent in functionality. But I guess it doesn't really integrate into Haskell's syntax quite so nicely.
12:25:57 <ZettaBlade> why don't you guys use C?
12:26:07 <scopedTV> ZettaBlade: does it?
12:26:11 <mauke> ZettaBlade: I do
12:26:12 <cg_morton> haha, I do use C
12:26:21 <scopedTV> ZettaBlade: not so featureful :). I use C btw.
12:26:30 <EvanR> C is my favorite esoteric language
12:26:32 <ZettaBlade> I come from C/C++
12:26:38 <scopedTV> C/C++ is not a language.
12:26:43 <ZettaBlade> Honestly, if haskell wasn't, I would C
12:26:46 <mauke> scopedTV: yes, it is
12:26:54 <kallisti> C is not worth the pain in most cases.
12:27:00 <ZettaBlade> are you shitting me? Of course C is a language
12:27:06 <scopedTV> C is. C/C++ isn't.
12:27:07 <EvanR> >_>
12:27:10 <mauke> ZettaBlade: C/C++, not C
12:27:10 <ZettaBlade> and C is not painful
12:27:16 <scopedTV> C is very painful.
12:27:26 <EvanR> c++ is more painful
12:27:27 <scopedTV> There are more painful languages, like C++.
12:27:29 <ZettaBlade> I dream in C++
12:27:35 <ZettaBlade> you guys are haers
12:27:37 * EvanR looks at ZettaBlade 
12:27:52 <ZettaBlade> >_<
12:27:53 <cg_morton> I dream in pictures, but then I'm an outlier
12:27:53 <Taneb> I dream in lambda calculus
12:27:56 <Taneb> Or have done at least once
12:28:08 <EvanR> i dream in money
12:28:13 <mauke> scopedTV: your assertion is unprovable
12:28:24 <jfischoff> my dreams are fuzzy pixelate landscapes
12:28:43 <scopedTV> mauke: I'm not sure what you mean.
12:28:45 <Taneb> In other news, I'm getting fed up with waiting for the Hackage guy
12:29:37 <kallisti> ZettaBlade: I think electricsheep is my favorite codebase.
12:29:51 <Taneb> I'm also getting tired
12:29:54 <mauke> scopedTV: you can't prove a negative
12:29:56 <EvanR> i prefer dikumud gamma
12:30:23 <scopedTV> mauke: sure you can??
12:30:36 <EvanR> there is no maximum number
12:30:45 <mauke> scopedTV: ok, prove that C/C++ is not a language
12:30:54 <scopedTV> I lost interest.
12:31:01 <kallisti> conflating English with formal logic is always fun.
12:31:11 <cg_morton> first we assume C/C++ is a language, then demonstrate that that leads to a contradiction
12:31:31 <mauke> http://web.archive.org/web/20090421080714/http://www.cpax.org.uk/prg/portable/c/c++/rfe00000.html
12:31:32 <gu> .
12:31:33 <cg_morton> I'll leave the details as an exercise to the reader
12:31:36 <EvanR> if c/c++ were a language, it would be worse than c++, which is impossible
12:31:37 <EvanR> QED
12:31:48 <mauke> sadly the original site seems to be down
12:31:54 <scopedTV> haha
12:32:23 <kallisti> EvanR: ah, so a minimum counter example.
12:32:33 <kallisti> interesting technique.
12:32:39 * hackagebot postgresql-simple 0.1.2 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.1.2 (LeonSmith)
12:34:28 <EvanR> c/c++ => 1/++
12:35:04 <vraid> EvanR: not 1++ ?
12:35:11 <mauke> as far as I know I'm the only person to ever write a C/C++ interpreter
12:35:33 <EvanR> ok
12:35:48 <ibid> vraid: i suppose it depends on relative precedence of concat and slash :)
12:35:50 <EvanR> c/c++ evaluates to 2 for all c not equal to zero
12:36:04 <ibid> mauke: which one is it?
12:36:09 <scopedTV> EvanR: ?
12:36:11 <mauke> ibid: huh?
12:36:18 <mauke> :t (c/c++)
12:36:19 <lambdabot>     No instance for (Monoid Expr)
12:36:19 <lambdabot>       arising from a use of `++' at <interactive>:1:1-5
12:36:19 <lambdabot>     Possible fix: add an instance declaration for (Monoid Expr)
12:36:20 <ibid> mauke: your interpreter?
12:36:36 <mauke> ibid: what do you mean by "which"?
12:36:37 <EvanR> ++ in c, not haskell ;)
12:36:39 <ibid> EvanR: isn't it undefined behaviour?
12:36:56 <ibid> mauke: i'm wondering if it's the one i knew in the 90's
12:37:14 <mauke> C/C++ didn't exist in the 90s
12:37:29 <companion_cube> C did exist
12:37:31 <mauke> the rfe is from 2005
12:37:34 <EvanR> c++ did
12:37:36 <ibid> there certainly was something people called C/C++
12:37:48 <mauke> ibid: I disagree
12:37:51 <ibid> C dates from the seventies
12:37:58 <ibid> C++ dates from the eighties
12:37:59 <EvanR> visual studio
12:38:08 <ibid> and it was common practice to talk about C/C++
12:38:09 <EvanR> a c/c++ system
12:38:10 <mauke> ibid, EvanR: http://web.archive.org/web/20090421080714/http://www.cpax.org.uk/prg/portable/c/c++/rfe00000.html
12:38:19 <ibid> in the nineties
12:38:26 <ibid> late 90s at least, when i learned both languages
12:38:49 <Eduard_Munteanu> Hah.
12:39:03 <ibid> :)
12:39:13 <ibid> mauke: ah
12:39:25 <ibid> mauke: and yeag, the one i was thinking of was a C interpreter
12:40:21 <mauke> http://codepad.org/MGVibBd7
12:41:25 <ibid> my that looks ... <censored>
12:41:26 <ibid> :)
12:41:37 <mauke> http://codepad.org/Fe7zIBWk
12:42:48 <ibid> is there a language spec or manual?
12:43:15 <mauke> there used to be
12:44:00 <ibid> (you know, i once tried to learn intercal.  i eventually got fed up with it and wrote an intercal hello world generator:)
12:46:01 <tac-tics> What's an n-category?
12:46:48 <Eduard_Munteanu> tac-tics: basically a generalisation of categories with arrows between arrows between ...
12:47:00 <ski> i think there's several possible definitions ..
12:47:04 <Eduard_Munteanu> AFAIU, at least, I haven't studied those in much depth.
12:47:26 <hpc> @quote category.in.the
12:47:26 <lambdabot> No quotes match. Maybe you made a typo?
12:47:29 <hpc> :(
12:47:47 <Eduard_Munteanu> @google ncatlab
12:47:49 <lambdabot> http://ncatlab.org/
12:47:49 <lambdabot> Title: nLab
12:48:18 <Eduard_Munteanu> Also, there's an introductory paper by Baez somewhere.
12:48:47 <Eduard_Munteanu> @google baez n-categories
12:48:49 <lambdabot> http://arxiv.org/abs/q-alg/9705009
12:49:17 <tac-tics> thanks
12:49:28 <byorgey> tac-tics: the category Cat is the canonical example of a 2-category.  There are categories (objects, i.e. 0-morphisms), functors (arrows, i.e. 1-morphisms), and natural transformations are arrows between functors, i.e. 2-morphisms.
12:50:35 <tac-tics> So, they were invented so Category Theorists could stop making up new words?
12:54:35 <hpaste> yan_ pasted “composition” at http://hpaste.org/68296
12:55:17 <yan_> can someone take a look at lines 6-9.. it /feels/ like i can compose the 'get auth, then if auth, get token and then make a GoogleAuth' into a single statement with liftM2 or something similar
12:55:30 <yan_> (i am referring to the thing i just pasted)
12:56:48 <yan_> hmm looking at it now, feels like "liftM2 GoogleAuth (lookupField "Auth" response) (getGoogleTokenValue auth)" should work, but i need to get a value from the first arg to the next
12:57:03 <yan_> (i.e. what the lookupField generates, i need to pass it to getGoogleTokenValue)
12:57:21 <byorgey> then you can't use liftM2.
12:57:34 <yan_> byorgey: so the way i have it now is idiomatic?
12:59:45 <byorgey> yan_: well, instead of  do  token <- ... ;  return (GoogleAuth ... )   you can just write  GoogleAuth auth <$> getGoogleTokenValue auth
13:03:11 <yan_> byorgey: hm. what instance of applicative am i using in this case?
13:03:21 <byorgey> <$> is just fmap
13:03:30 <byorgey> there's no Applicative involved
13:04:11 <yan_> oh. this makes a whole lot more sense.
13:04:33 <yan_> since i'm lifting a partially applied value constructor to Maybe
13:04:59 <byorgey> looks like MaybeT IO, in fact
13:05:06 <yan_> yes yes
13:11:38 <hpaste> yan_ pasted “verbose blob” at http://hpaste.org/68298
13:12:27 <yan_> byorgey: can i do a similar fmap on the code above? since i'm essentially redefining what `fmap` is defined to be for the Either functor? i only need to perform an extra operation inside Right
13:14:05 <EvanR> for a type T a b c d e, functor instance must apply to the e?
13:14:09 <scopedTV> Yes.
13:14:14 <EvanR> ok
13:14:27 <monochrom> instance Functor (T a b c d) where
13:14:33 <scopedTV> The kind is * -> *
13:14:50 <scopedTV> It's not possible to reorder (unless you newtype it)
13:15:03 <EvanR> how would it look with a newtype reorder
13:15:17 <scopedTV> newtype X a b c = T a c b, instance Functor (X a b)
13:15:39 <EvanR> whoa
13:15:59 <monochrom> err, you're missing a data constructor
13:16:22 <scopedTV> Right. Thanks.
13:16:28 <ski> scopedTV : are you sure that'll work ?
13:16:58 <ski> hm, yeah with an explitit instance, it could
13:17:10 <monochrom> newtype X a b c = Xtor (T a c b)
13:18:14 <scopedTV> I think so, it should work.
13:18:33 <EvanR> ok now im not so confused / amazed anymore
13:18:35 <scopedTV> But as monochrom pointed out, there should be a constructor.
13:18:38 <EvanR> thanks monochrom
13:22:10 <yan_>     Expected type: Handle -> IO (Either String Bool)
13:22:10 <yan_>       Actual type: Handle -> IO (Either String (IO Bool))
13:22:12 <yan_> so close
13:22:31 <EvanR> you need to conver IO Bool to Bool ;)
13:22:59 <scopedTV> fmap (fmap unsafePerformIO)
13:23:07 <yan_> (i already have two fmaps here)
13:23:16 <scopedTV> Don't actually do that, by the way.
13:23:19 <EvanR> lol
13:24:13 <yan_> what i'm actually trying to do: http://hpaste.org/68300
13:24:20 <yan_> the lines that are commented are what i'm trying to replace
13:24:36 <yan_> with: fmap (writeBytes ....
13:25:20 <yan_> and line 9 is what i'm working on to replace it
13:26:07 <scopedTV> yan_: why not use either?
13:27:07 <jeff_s_> Anybody know of a function for hexadecimal characters, :: ByteString -> Int32? I don't want to reinvent the wheel.
13:27:21 <scopedTV> readHex I think
13:27:24 <scopedTV> look in Numeric
13:27:35 <jeff_s_> scoped - close enough, thanks
13:27:36 <EvanR> @hoogle ByteString -> Int32
13:27:37 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
13:27:37 <lambdabot> Data.ByteString.Lazy foldl :: (a -> Word8 -> a) -> a -> ByteString -> a
13:27:37 <lambdabot> Data.ByteString foldl :: (a -> Word8 -> a) -> a -> ByteString -> a
13:27:45 * hackagebot wl-pprint-extras 1.6.3.1 - A free monad based on the Wadler/Leijen pretty printer  http://hackage.haskell.org/package/wl-pprint-extras-1.6.3.1 (EdwardKmett)
13:27:47 * hackagebot reactive-bacon 0.4 - FRP (functional reactive programming) framework  http://hackage.haskell.org/package/reactive-bacon-0.4 (JuhaPaananen)
13:27:48 <jeff_s_> ya, i was going to use foldl for the conversion :)
13:27:49 * hackagebot wl-pprint-terminfo 0.8.3.1 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-0.8.3.1 (EdwardKmett)
13:27:55 <scopedTV> It's not ByteString-based though.
13:28:13 <jeff_s_> ya, but speed isn't super important for me in this case, at least not for now.
13:28:28 <EvanR> cereal might have something
13:28:55 <yan_> scopedTV: i am using either
13:28:59 <jeff_s_> I discounted it before looking, because the serialization packages seem to put the length of something before the thing. Maybe I'm wrong for Int32, though.
13:29:04 <scopedTV> yan_: I mean the function, not the type.
13:29:05 <scopedTV> :t either
13:29:06 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
13:29:26 <yan_> scopedTV: ah hm
13:29:41 <EvanR> storing int32 as hex digits? :S
13:29:52 <EvanR> in a bytestring
13:30:20 <scopedTV> It's probably some user input or a text-based file format.
13:30:33 <scopedTV> It's not that weird, is it?
13:31:07 <jeff_s_> Actually, sorry, I mixed up something in my head. I'm not going from hex digits to int32, I'm going from hex digits to a bytestring.
13:31:32 <EvanR> whats your final encoding like
13:31:47 <scopedTV> Ah.
13:31:50 <jeff_s_> foldl can work, but it's a little weird because you have to know if you're in the first character fo the byte or the second.
13:32:12 <scopedTV> So [Int] -> ByteString where each element is in [0..16) ?
13:32:32 <yan_> scopedTV: either is likely what i want but i'm getting tangled up in the IO monad
13:32:41 <EvanR> [0..16]
13:32:46 <jeff_s_> Nope, ByteString -> ByteString, where the output is half the length of the input
13:32:47 <EvanR> > [0..16]
13:32:48 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]
13:32:53 <EvanR> > [0 .. 15]
13:32:55 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
13:32:55 <scopedTV> EvanR: Err, no.
13:33:02 <jeff_s_> e.g.. "ff" -> pack [255]
13:33:06 <scopedTV> I used mathematical notation sometimes used in Analysis
13:33:11 <jeff_s_> er, Char8.pack "ff" -> pack [255]
13:33:17 <EvanR> oh i didnt see )
13:33:38 <ski> @type cont .: flip . either
13:33:39 <lambdabot> forall a r a1. (a1 -> r) -> Either a1 a -> Cont r a
13:33:47 <yan_> scopedTV: what i'm trying is this: writeContents h = either id (B.hPut h) <$> openURI dlurl
13:34:04 <scopedTV> yan_: perhaps you'd like (return.id) there.
13:34:15 <ski> @pl return . id
13:34:15 <lambdabot> return
13:34:56 <ski> yan_ : are you sure `B.hPut' isn't monadic ?
13:35:06 <yan_> ski: it is
13:35:08 <scopedTV> It is, ski.
13:35:16 <yan_> it's bytestring's hPut
13:35:18 <ski>   writeContents h = either return (B.hPut h) =<< openURI dlurl  -- maybe ?
13:35:42 <scopedTV> ski: the Left should be packed again I think. I'm not sure
13:35:57 <scopedTV> either (return.Left) (\x -> B.hPut h x >> return (Right True))
13:35:58 <yan_> yeah,     Expected type: IO (Either () B.ByteString)
13:35:58 <yan_>       Actual type: IO (Either String B.ByteString)
13:36:11 <scopedTV> but this is hardly clear.
13:36:16 <yan_> yeah this is getting very messy
13:37:44 <yan_> scopedTV: the use case just popped out at me as a functor example, so i wanted to try to rewrite it, but having the older way is cleaner
13:38:02 <ski> > ()
13:39:21 <ski> hm, maybe the netsplit is slowing lambdabot down ..
13:39:39 <mauke> preflex: seen lambdabot
13:39:40 <preflex>  lambdabot was last seen on #haskell 5 minutes and 24 seconds ago, saying: return
13:39:44 <ski> scopedTV : i was thinking `traverse' could do it
13:39:58 <EvanR> lambdabot caught in the netsplit vortex
13:40:01 <EvanR> time dilation
13:41:22 <scopedTV> yan_: yeah it sure looks like it.
13:42:30 <ski>   writeContents h = traverse (B.hPut h) =<< openURI dlurl  -- something like this, i think
13:47:22 <lambdabot>   ()
13:47:32 <EvanR> wwwwwaaaaaaaaaaaaa
13:47:33 <uniquenick> if I have a [(a,b)] where lots of 'a's are the same, and I want to group it into a list like [(a,[b])], there's no function to do that in the standard library right?
13:48:02 <EvanR> uniquenick: multimap
13:49:19 <luite> uniquenick: not a single one no, but you can use a combination of map, sortBy and groupBy to do it
13:49:39 <yan_> ski: there's no Traversable instance for Either a
13:51:03 <EvanR> luite: or do fromList from multimap
13:51:12 <EvanR> then toList
13:51:34 <luite> fromListWith (++) is what you mean?
13:51:43 <luite> that would also work yeah
13:51:50 <EvanR> err
13:51:56 <EvanR> fromListWith?
13:52:40 <luite> toList . fromListWith (++) . map (second (:[]))
13:52:43 <luite> would be the whole thing
13:53:17 <EvanR> k
13:53:27 <scopedTV> (:[]), I prefer return there.
13:53:32 <scopedTV> What does #haskell think?
13:53:34 <uniquenick> any particular advantage to one method over the other?
13:53:43 <ion> pure
13:53:49 <scopedTV> pure is better than return?
13:53:52 <EvanR> fromListWith (++) seems horribly inefficient
13:53:55 <scopedTV> "more beautiful", that is.
13:54:03 <luite> scopedTV: i think this is more explicit, return or pure makes you think more because you need to think which instance is used here
13:54:13 <ion> It’s shorter. :-P And return shouldn’t exist in the first place.
13:54:24 <scopedTV> That I can agree with.
13:54:27 <luite> EvanR: could be that flip (++) is better
13:54:46 <armlesshobo> hello, everybody!
13:54:49 <yan_>     Expected type: Handle -> IO (Either String ())
13:54:49 <yan_>       Actual type: Handle -> IO (Either String (IO ()))
13:54:50 <yan_> so close
13:54:57 <navaati> one can define a AND bewteen constraints (in the sense of ContraintKinds) simply by puting them in a tuple, for example (Num t, Show t) means that t must be an instance of Num AND Show.
13:54:57 <navaati> is there a way to say OR ?
13:55:15 <scopedTV> hi armlesshobo!
13:55:25 * armlesshobo tries to wave
13:55:31 * armlesshobo is deeply saddened
13:56:26 <c_wraith> navaati: nope.
13:56:44 <yan_> ok looks like this will work: fmap (B.hPut h) <$> openURI dlurl
13:56:59 <yan_> i changed the overall return type to: IO (Either String (IO()))
13:57:05 <yan_> since i throw that value away anyway at the call site
13:57:14 <navaati> c_wraith: ok. anyway, i can't remember why i wanted to do that, so…
13:57:24 <scopedTV> But then the returned IO action will never be executed! beware.
13:57:54 <yan_> scopedTV: hm, good point
13:58:18 <yan_> and there's no clear way to get it to execute before returning, right?
13:58:33 <navaati> a typeclass basically describes a set of types, right ?
13:58:40 <scopedTV> :t either return join
13:58:41 <lambdabot> forall a (m :: * -> *). (Monad m) => Either a (m (m a)) -> m a
13:59:18 <scopedTV> navaati: That, plus some operations one can perform on those types.
13:59:20 <c_wraith> navaati: Well, it's a predicate on types. When extended to multiparameter type classes, it means a relation, etc
13:59:41 <armlesshobo> since $ and '.' both are right-associative, would they function the same way?
13:59:58 <scopedTV> armlesshobo: No, their type is different.
14:00:06 <scopedTV> however f $ g $ x is the same as f . g $ x
14:01:02 <armlesshobo> scopedTV: would f . g x be the same as f . g $ x?
14:01:12 <Peaker> armlesshobo, nope
14:01:15 <scopedTV> armlesshobo: No.
14:01:19 <scopedTV> f . g x is f . (g x)
14:01:24 <Peaker> armlesshobo, f . (g x)    vs    (f . g) x
14:01:26 <scopedTV> f . g $ x is (f . g) $ x
14:01:38 <scopedTV> which is, in turn, (f . g) x
14:01:42 <navaati> hum… so maybe i've got my OR : if A and B are instances of C, (C t) <=> (t ~ A OR t ~ B)
14:01:51 <Phlogistique> is there a name for foldl (flip id) ?
14:02:03 <armlesshobo> scopedTV, Peaker: oh! I gotcha. That makes sense
14:02:19 <Phlogistique> @hoogle a -> [a -> a] -> a
14:02:19 <lambdabot> Data.Generics.Schemes everywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
14:02:20 <lambdabot> Data.Generics.Schemes everywhere' :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
14:02:20 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
14:08:13 <kallisti> it's bad when I have to refer to the documentation to my own library.
14:17:27 <adnauseam> hrm, i understand foldr
14:17:45 <adnauseam> does foldl then start from the \end\ and move towards the start ?
14:17:48 <adnauseam> start\head
14:19:00 <scopedTV> No.
14:19:09 <scopedTV> It updates an accumulator during each iteration.
14:19:14 <scopedTV> (operationally speaking.)
14:19:22 <adnauseam> tell me more o_0
14:19:48 <scopedTV> > foldr (+) e [x,y,z]
14:19:49 <lambdabot>   x + (y + (z + e))
14:19:56 <scopedTV> @src foldr
14:19:56 <lambdabot> foldr f z []     = z
14:19:56 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:19:58 <scopedTV> err,
14:20:03 <scopedTV> > foldl (+) e [x,y,z]
14:20:04 <lambdabot>   e + x + y + z
14:20:07 <scopedTV> @src foldl
14:20:07 <lambdabot> foldl f z []     = z
14:20:07 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:20:36 <monochrom> foldl gives you (((a+b)+c)+d). it is not clear to me what is meant by "start from the end"
14:20:52 <adnauseam> so the operation f doesn't change
14:21:16 <adnauseam> oh...
14:21:23 <adnauseam> that f z x bit
14:21:23 <dmwit> Which end does foldr "start from", in your terminology?
14:21:25 <adnauseam> hmm
14:21:47 <adnauseam> dmwit: tail of the list
14:21:47 <scopedTV> No, the operation doesn't change, but the "zero value" / the accumulator changes
14:21:49 <adnauseam> but i see it doesn't
14:21:51 <scopedTV> again, operationally.
14:22:13 <monochrom> I would entirely give up on trying to say "start from end", "start from begin". some wordings are not meant to be fixed
14:22:22 <c_wraith> They both start from the head. They're also entirely different operationally, despite giving the same result with a commutative function
14:22:27 <c_wraith> err, associative
14:22:58 <adnauseam> monochrom: aye i apologise dude, i'm not too familiar with the terminology yet so sometimes i use retarded discriptions to convey what i think
14:23:13 <dmwit> Associative isn't enough.
14:23:22 <monochrom> well, it goes beyond wording. some broken concepts are not meant to be fixed, either
14:23:24 <dmwit> It has to be associative plus z has to be special.
14:23:32 <scopedTV> Yeah, z has to be a zero.
14:23:33 <c_wraith> oh, true
14:23:38 <dmwit> z being an identity for the operation is sufficient, but not necessary.
14:23:47 <c_wraith> (also, the input list has to be finite)
14:24:27 <dmwit> z commuting with everything is more relaxed, and still sufficient (but still not necessary).
14:24:44 <adnauseam> hmm, i think my thought-error there is trying to compare foldr with foldr and thinking they're related
14:24:58 <c_wraith> well.  foldr and foldr *are* related. :P
14:25:02 <anonanon> question about lambdabot, howto get it to respond IN channel?  (home network)
14:25:19 <dmwit> tgeeky: Well, we've got eta and epsilon now. Take a crack at defining trace. =)
14:25:25 <c_wraith> however, foldr and foldl are really not related, except that both are common access patterns for working with lists
14:25:39 <adnauseam> anonanon: use > command
14:25:41 <dmwit> anonanon: Responding in channel is the default.
14:25:45 <adnauseam> > 1+1
14:25:46 <lambdabot>   2
14:25:53 <jfischoff> hey dmwit
14:26:03 <adnauseam> c_wraith: yes i see that now
14:26:11 <dmwit> jfischoff: hey!
14:26:11 <Eduard_Munteanu> I guess anonanon is asking how to get lambdabot on his own IRC network/channel.
14:26:13 <anonanon> thanks guys, but it's only responding to my /msg's :(
14:26:13 <hiptobecubic> Oh good.
14:26:16 <jfischoff> add more parsing last night
14:26:21 <jfischoff> will check in tonight
14:26:22 <Eduard_Munteanu> (lambdabot the software, not Cale's instance)
14:26:25 <dmwit> jfischoff: uh-oh
14:26:37 <dmwit> jfischoff: I just changed a few things.
14:26:41 <jfischoff> no worries
14:26:45 <dmwit> jfischoff: In particular, terms aren't typed any more. =P
14:26:46 <jfischoff> is it in the repo
14:26:48 <dmwit> yes
14:26:52 <anonanon> i've got it connected and responding, hoogle and all, just have to /msg it for response. :(
14:27:09 <anonanon> thought it may be a config thingy.
14:27:09 <jfischoff> I don't think that will affect me
14:27:19 <monochrom> is it in a channel?
14:27:26 <adnauseam> anonanon: it doesn't respond to > in channel ?"
14:27:32 <adnauseam> are you sure it is in channel ?
14:27:41 <jfischoff> dmwit: cool I'll let you know if I have any problems
14:27:42 <anonanon> yah, present and responsive, but not IN channel, yes and yes adnauseam.
14:27:52 <dmwit> great
14:27:57 <adnauseam> does it give errors when you speak in channel ?
14:27:58 <dmwit> Send me a pull request whenever you're ready. =)
14:28:01 <adnauseam> you should be able to see its feed on console
14:28:02 <monochrom> are you in the same channel? :)
14:28:07 <jfischoff> will do :)
14:28:33 <anonanon> yes, is in channel, yes can see feeds, but only feed 'activity' is via /msgs
14:29:09 <dmwit> try
14:29:10 <dmwit> ?echo
14:29:10 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "dmwit!~dmwit@pool-71-185-1-144.phlapa.east.verizon.net", msgCommand = "PRIVMSG", msgParams = ["#haskell",":?echo"]}
14:29:11 <lambdabot>  rest:""
14:29:50 <tromp_> :t logBase
14:29:51 <lambdabot> forall a. (Floating a) => a -> a -> a
14:29:57 <anonanon> similar results.  /msg lambdabot ?echo   works  ?echo doesn't.
14:30:03 <tromp_> > logBase 1.77894 10
14:30:03 <lambdabot>   3.9974208565767
14:30:09 <tromp_> > logBase 10  1.77894
14:30:10 <lambdabot>   0.25016130046821666
14:30:15 <dmwit> strange
14:30:23 <anonanon> yah, is why I'm asking here.
14:30:25 <dmwit> anonanon: Aha! Does lambdabot have voice in that channel
14:30:26 <dmwit> ?
14:30:37 <hiptobecubic> Are boxed vectors just vectors of pointers to boxed data?
14:30:37 <dmwit> or whatever IRC permissions it needs to talk
14:30:47 <solidus-river> are there any monoDB bindings for haskell?
14:30:48 <adnauseam> heh, yeah actually, is the channel muted ?
14:30:57 <hiptobecubic> And if so, why should it be any faster than just using lists?
14:31:07 <solidus-river> haha, well, i should have googled that
14:31:15 <c_wraith> hiptobecubic: that's still one less indirection for each element than a list
14:31:17 <anonanon> channel only show "+i"  no v or m switches
14:31:17 <dmwit> hiptobecubic: They are, and they're faster because FUSION and LLVM.
14:31:40 <hiptobecubic> c_wraith: what's the extra indirection in the list?
14:31:42 <anonanon> also, it would show in the feed as deteced the command request ?echo, etc.
14:31:54 <c_wraith> hiptobecubic: with a list, you need the indirection for looking at the current element, and for getting the next (:) in the list.
14:31:57 <hiptobecubic> dmwit: i get fusion, why llvm?
14:32:09 <c_wraith> hiptobecubic: you skip the latter entirely with a vector
14:32:12 <dmwit> hiptobecubic: Vector is closer to Array than lists.
14:32:37 <hiptobecubic> c_wraith: but boxed vectors can be recursively defined, so they can also be created and consumed lazily?
14:32:40 <anonanon> so, first you've heard of this issue?  lambdabot not "monitoring" regular channel chat?
14:33:04 <dmwit> Do *you* have permission to speak in the channel?
14:33:12 <c_wraith> hiptobecubic: boxed vectors aren't defined that way. They're a bunch of consecutive pointers to thunks
14:33:26 <anonanon> yes, is fresh channel, I'm op. (my server)
14:33:32 <anonanon> (internal network)
14:33:49 <hiptobecubic> c_wraith: mm_freak make a neural net that used boxed vectors recursively though
14:34:19 <anonanon> I *did* have to remove two imports to get this working:  "Control.Parallel" and "Control.Parallel.Strategies"  -- related ??
14:34:31 <monochrom> "recursively defined" is ambiguous
14:36:19 <c_wraith> hiptobecubic: do you mean "why would someone nest vectors"?
14:36:20 <hiptobecubic> monochrom: c_wraith: yeah, it looks like it's using V.generate
14:36:33 <S11001001> @pl \f x -> f x x
14:36:33 <lambdabot> join
14:36:43 <hiptobecubic> c_wraith: no. and i'm not sure how that's related?
14:36:51 <scopedTV> S11001001: the (e ->) monad
14:36:56 <S11001001> mmm
14:37:07 <scopedTV> S11001001: it's quite a useful function, I use it often.
14:37:21 <c_wraith> hiptobecubic: why do you think generate is lazy?
14:37:55 <hiptobecubic> c_wraith: i don't. He described this function as 'recursively defining a boxed vector'
14:37:56 <hiptobecubic> http://hackage.haskell.org/packages/archive/instinct/latest/doc/html/src/AI-Instinct-Brain.html#activation
14:38:10 <hiptobecubic> unless I completely misunderstood him
14:38:44 <hiptobecubic> dmwit: does the llvm backend do some kind of magic with arrays then?
14:38:56 <S11001001> thanks scopedTV
14:44:04 <monochrom> the only significant recursion there is in actOf, and it is just an ordinary Int->Double, and it doesn't use av, i.e., no dynamic programming.
14:44:19 <Phlogistique> I'm a little put off by command line parsing libraries in Haskell. It seems everything is incredibly complex
14:44:47 <dmwit> hiptobecubic: I don't know, actually.
14:44:54 <dmwit> You should take my answer with a small mountain of salt.
14:45:05 <dmwit> Optimization isn't really my thing.
14:45:18 <Phlogistique> (and ugly)
14:47:12 <hiptobecubic> dmwit: ok well thanks for the effort
14:47:16 <hiptobecubic> bed ->   night all
14:49:15 <bgamari> Phlogistique: to the contrary, CmdArgs is pretty simple
14:49:39 <bgamari> granted the TH requirement is a tad unfortunate, but perhaps this too will pass
14:50:29 <Phlogistique> bgamari: the impure interface was a big turn-off; TH is OK though
14:50:37 <Phlogistique> I shall use this
14:52:07 <alpounet> there's a recent one that I liked iirc, 'options'
14:52:09 <alpounet> smth like that
14:52:45 <Pedromdrp> hello
14:53:26 <Pedromdrp> I started using haskell today and I am trying to install mysql-simple, however I am getting the following error when using cabal:
14:53:27 <Pedromdrp> cabal: Error: some packages failed to install: pcre-light-0.4 failed during the building phase. The exception was: ExitFailure 1
14:53:36 <Pedromdrp> I am using mac os x 10.6
14:53:43 <Phlogistique> alpounet: yes
14:53:49 <Botje> Pedromdrp: I would imagine pcre needs the libpcre library. did you install that?
14:53:50 <scopedTV> Please paste all output Pedromdrp.
14:54:22 <Pedromdrp> Ileibniz:tutoring pedromdrp$ cabal install -p pcre-light Resolving dependencies... Configuring pcre-light-0.4... Preprocessing library pcre-light-0.4... Base.hsc:103:18: error: pcre.h: No such file or directory Base.hsc: In function ‘main’: Base.hsc:402: error: ‘PCRE_ANCHORED’ undeclared (first use in this function) Base.hsc:402: error: (Each undeclared identifier is reported only once Base.hsc:402: error: for each funct
14:54:33 <Pedromdrp> wait... it is truncated
14:55:07 <Botje> yeah .. you need to install pcre.
14:55:12 <Botje> (the package, that is)
14:55:28 <Pedromdrp> I did: cabal install -p pcre
14:55:32 <Pedromdrp> isn't that how you install it?
14:56:27 <Pedromdrp> give me one second, I will make it the output online
14:56:46 <scopedTV> @where hpaste
14:56:47 <lambdabot> http://hpaste.org/
14:57:06 <luite> Pedromdrp: it's missing pcre.h
14:57:40 <luite> Pedromdrp: usually you'd install the pcre library with macports or homebrew
14:57:54 <hpaste> Pedromdrp pasted “output” at http://hpaste.org/68301
14:57:59 <luite> Pedromdrp: it's a non-haskell dependency, so you odn't install it with cabal
14:58:03 <Pedromdrp> http://hpaste.org/68301
14:58:14 <Pedromdrp> I see
14:58:32 <luite> do you use macports or homebrew?
14:58:37 <Pedromdrp> nope
14:59:22 <Pedromdrp> I started today using haskell to develop a webserver, and decided to use snap
14:59:26 <luite> Pedromdrp: easiest would probably be homebrew
14:59:43 <luite> install homebrew, and then brew install pcre
14:59:44 <Pedromdrp> and I looked at a presentation from the author of the book "haskell in the real world"
14:59:51 <Pedromdrp> and he made this "mysql-simple" package
14:59:55 <scopedTV> Cool.
14:59:55 <Pedromdrp> which I intended to use...
15:00:14 <scopedTV> bos, you mean I suppose.
15:00:24 <Pedromdrp> yes bos
15:00:31 <Pedromdrp> is HDBC-mysql a better alternative?
15:00:43 <scopedTV> Well, you need the C library for perl-compatible regexes
15:00:58 <luite> nah mysql-simple is a good one
15:01:03 <scopedTV> On my Mac I can hardly do anything without homebrew.
15:01:05 <luite> for simple low-level db access
15:01:15 <scopedTV> to MySQL, the inferior database ;)
15:01:29 <Pedromdrp> :D
15:01:44 <Pedromdrp> I normally use other ones... but I decided to give it a go :P
15:01:48 <luite> for higher level you can use haskelldb (which depends on hdbc) or persistent, or even the all-haskell acid-state, if you don't really need sql
15:02:12 <Pedromdrp> I intend to use sql, as I am used to it from other languages
15:02:39 <Pedromdrp> I just decided to develop for the first time in haskell... (I had some previous haskell but only basic stuff)
15:02:49 <Pedromdrp> so still trying to get familiar with the packages
15:02:58 <luite> Pedromdrp: best to install homebrew first then
15:03:52 <luite> i'm pretty sure that yesod can be installed without pcre though, but maybe that's without mysql support
15:04:17 <luite> so you can have at least some db access without that lib
15:04:36 <Pedromdrp> well I am installing homebrew.... might as well try it
15:04:50 <luite> yeah, you'll probably need it more if you install more packages
15:04:54 <scopedTV> Well, you might need a C library for your favorite RDBMS anyway.
15:05:03 <luite> you can also use it to install libmysqlclient etc
15:05:27 <luite> hm, i thought there was a native haskell postgresql client actually
15:05:47 <scopedTV> That's possible, libpq is a bit of a pain I think.
15:06:45 <dmwit> wow, LogicT is magic
15:06:55 <kallisti> LogicT is fun.
15:06:56 <dmwit> instance Monad (LogicT m)
15:06:58 <Pedromdrp> I have the C connector already running :)
15:07:03 <Pedromdrp> that was fine
15:07:08 <dmwit> note: not instance Monad m => Monad (LogicT m)
15:07:19 <kallisti> dmwit: I use it to efficiently determine movesets in a chess variant
15:07:32 <kallisti> @hoogle void
15:07:33 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
15:07:33 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
15:07:33 <lambdabot> package void
15:07:42 <kallisti> I'm kind of confused by this Functor constraint.
15:07:44 <kallisti> on void.
15:07:58 <dmwit> void = fmap (const ())
15:08:04 <kallisti> why not liftM?
15:08:14 <dmwit> fmap is more general
15:08:19 <kallisti> since Prelude is silly and doesn't make Functor a superclass of Monad.
15:08:24 <dmwit> Well, it ought to be, except hysterical raisins intervened.
15:08:39 <dmwit> But really, what Monad isn't a Functor?
15:08:43 <dmwit> People know to do that by now.
15:08:49 <scopedTV> They all are. They should be.
15:09:15 <dmwit> So "fmap is more general" is controversial in only the most technical sense.
15:09:27 <kallisti> dmwit: the monad (Monad m) => m  is not a functor. ;)
15:09:38 <kallisti> nor is (MonadIO m) => m  etc
15:09:54 <dmwit> So add (Functor m) to your constraints and move on with your day.
15:10:02 <kallisti> yeah that's what I did.
15:10:14 <kallisti> doesn't mean I can't complain! :P
15:10:18 <dmwit> =D
15:10:44 <kallisti> also I prefer to leave out Functor constraints when possible.
15:10:47 <kallisti> because they're contagious.
15:11:14 <dmwit> unsafeCoerce . void
15:11:23 <kallisti> unsafeVoid
15:11:27 <kallisti> good function name
15:11:37 <dmwit> hehehe
15:11:52 * kallisti is tempted to rename unsafe-promises to lazy-promises
15:12:03 <kallisti> because a) they're not that unsafe  b) lazy promises is a fun name
15:12:07 <Pedromdrp> thank you :)
15:12:16 <Pedromdrp> homebrew did fix the problem
15:12:40 <monochrom> procastinator
15:13:06 <otters> hmm
15:13:11 <Pedromdrp> btw, I have one extra question
15:13:19 <Pedromdrp> is there a good place with code examples
15:13:23 <Pedromdrp> of the different packages?
15:13:32 <otters> how does join work
15:13:33 <dmwit> kallisti: Why wouldn't you give promise the type IO a -> IO (IO a)?
15:13:39 <dmwit> That seems much cleaner, and perfectly safe.
15:13:40 <scopedTV> otters: join is return >>= id
15:13:43 <otters> right
15:13:45 <otters> but
15:13:48 <scopedTV> errr, join x is x >>= id
15:13:53 <otters> what's passed to id?
15:13:58 <dmwit> It's also quite convenient.
15:14:01 <kallisti> the thing in x
15:14:02 <scopedTV> the result of the computation.
15:14:06 <otters> oh
15:14:08 <scopedTV> Let's take an example.
15:14:08 <kallisti> if x is (Monad m) => m a
15:14:11 <kallisti> then id is passed the a
15:14:28 <otters> okay
15:14:29 <scopedTV> putStrLn "hello" >> return (putStrLn "world")
15:14:34 <scopedTV> this has type IO (IO ())
15:14:36 <mm_freak> :t return >=> id
15:14:37 <lambdabot> forall (m :: * -> *) c. (Monad m) => m c -> m c
15:14:51 <otters> huh
15:14:56 <mm_freak> :t return >>= id
15:14:57 <lambdabot> forall a. a -> a
15:15:03 <monochrom> in do notation: join whee = do { more <- whee; more }
15:15:08 <scopedTV> it's the action that, when performed, prints "hello", and yields the action that, when performed, prints "world"
15:15:09 <otters> a -> a
15:15:17 <mm_freak> :t (>>= id)
15:15:18 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
15:15:20 <mm_freak> this is join
15:15:28 <scopedTV> the join of this runs the action, and then runs its results
15:15:30 <kallisti> otters: since >>= expects that the function you pass it return a monad, that automatically forces the a in m a to be m b
15:15:31 <otters> okay
15:15:50 <monochrom> do { more <- whee; more } = whee >>= \more -> more = whee >>= id  is how id comes up
15:15:55 <mm_freak> otters: imagine a parser that returns a parser…  for example you can implement a CSV parser that way
15:16:09 <mm_freak> first run a parser that parses the first line and interprets the headers
15:16:15 <mm_freak> it returns a parser for the rest
15:16:43 <otters> in join x = x >>= id isn't the type of x m (m a)?
15:16:45 <monochrom> my favourite example is an STM operation returns an IO action to be run in IO
15:16:51 <dmwit> otters: yes
15:17:50 <monochrom> join (atomically ((... >> return (putStrLn "x")) <|> (... >> return (hClose h))))
15:17:53 <kallisti> monochrom: I like forever . join . readChan $ c
15:18:01 <scopedTV> otters: Yes, it is.
15:18:05 <monochrom> oh, that's neat too
15:18:15 <scopedTV> otters: For example, IO (IO ()) or (e -> (e -> a))
15:18:21 <kallisti> that's basically how I'm doing concurrency right now.
15:18:22 <otters> > :t let foo = return (return "foo") in (foo >>=)
15:18:23 <lambdabot>   <no location info>: parse error on input `:'
15:18:28 <otters> oops
15:18:28 <mm_freak> i've used the join . takeMVar idiom in a concurrent logger
15:18:28 <kallisti> instead of message passing I pass monads. :P
15:18:31 <scopedTV> the latter is exactly why join f = \x -> f x x  in the (e ->) monad
15:18:32 <otters> :t let foo = return (return "foo") in (foo >>=)
15:18:33 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) b. (Monad m1, Monad m) => (m1 [Char] -> m b) -> m b
15:18:44 <mm_freak> and the join . atomically idiom i use in most projects that use STM
15:18:47 <otters> this is why it's confusing me
15:19:06 <otters> because foo is type m1 (m1 String)
15:19:06 <kallisti> otters: what about that?
15:19:12 <otters> but along the way one of the m1s just disappears
15:19:20 <mm_freak> the Parser . Parser idiom is really useful for context-sensitive grammars
15:19:27 <otters> (m1 String -> m b) I get that
15:19:31 <otters> but shouldn't it return m (m b)
15:19:32 <monochrom> join is concat if the monad is []
15:19:38 <kallisti> no
15:19:40 <kallisti> it should return m b
15:19:41 <anonanon> I think the issue was the channel name was lambdabot, fyi.  Once I joined a diff channel it started working.  Thanks everybody!
15:19:45 <kallisti> because that's how >>= works
15:19:48 <kallisti> >_>
15:19:49 <monochrom> @type concat
15:19:49 <lambdabot> forall a. [[a]] -> [a]
15:19:50 <otters> oh
15:19:53 <mm_freak> :t \x -> return (return x) >>= id
15:19:54 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
15:19:59 <otters> oh, oh wait
15:20:00 <monochrom> you don't say "should it be [[a]] -> [[a]]"
15:20:02 <otters> okay never mind
15:20:07 <otters> I just understood
15:20:13 <otters> took me awhile but we got there
15:20:24 <otters> I was confounding >>= and fmap
15:20:34 <kallisti> they're very similar
15:20:54 <otters> right
15:20:58 <kallisti> do you know:  join (fmap f m) = m >>= f   ?
15:20:59 <otters> but I got it now
15:21:09 <mm_freak> otters: fmap is a special case of (>>=)
15:21:26 <otters> it's just (>>=) with a return
15:21:30 <otters> implicit
15:21:30 <scopedTV> fmap f = (>>= (return.f))
15:21:30 <mm_freak> (=<<) :: (a -> m b) -> m a -> m b
15:21:31 <otters> right
15:21:37 <mm_freak> fmap :: (a -> b) -> m a -> m b
15:21:54 <kallisti> for some reason when I was learning monads I found it more helpful to look at it the other way.
15:22:01 <kallisti> with the equation I posted above.
15:25:17 <monochrom> sorry, which equations again?
15:25:30 <kallisti> join (fmap f m) = m >>= f
15:26:19 <kallisti> it's the same relationship between fmap and >>=, stated a different way
15:26:33 <mm_freak> the comparison of fmap and (>>=) is useful for understanding the list monad
15:26:56 <mm_freak> > fmap (\x -> x + 1) [10, 20, 30]
15:26:57 <lambdabot>   [11,21,31]
15:27:10 <mm_freak> > (=<<) (\x -> [x + 1, x + 2]) [10, 20, 30]
15:27:11 <lambdabot>   [11,12,21,22,31,32]
15:27:25 <mm_freak> there you see the concatMap pattern
15:27:43 <kallisti> yep. that's what join (fmap f m) = m >>= f   shows
15:27:47 <mm_freak> (=<<) is a variant that allows the result of the function to be nondeterministic as well
15:27:58 <tikhonjelvis> I think a DFA/NFA example is nice for the list monad.
15:28:17 <mm_freak> tikhonjelvis: i agree about the D and N, but not really about the FA
15:28:30 <mm_freak> the FA is rather something for the ZipList functor
15:28:41 <mm_freak> which has different semantics of course
15:29:01 <tikhonjelvis> They're just the simplest exampl of nondeterminism I can think of.
15:29:21 <armlesshobo> are you looking for just a list of possible end states?
15:29:25 <mm_freak> nondeterminism yes, but the list monad doesn't really model automata
15:30:03 <armlesshobo> you can model automata with it
15:30:15 <armlesshobo> could*
15:30:36 <mm_freak> you can model the progress of an automaton (ab-) using a list
15:30:49 <mm_freak> ZipList allows you to compose automata
15:32:46 <tikhonjelvis> I was basically thinking of using a fold for the DFA and a foldM for the NFA. So the list monad is just used in the transition function rather than modelling the automaton itself.
15:40:28 <mm_freak> tikhonjelvis: you can have actual automata with composition by using ZipList, ZipStream or even the automaton arrow
15:40:35 <mm_freak> the arrow is the most flexible one
15:42:34 <tikhonjelvis> What's a good way to display structured text with wxHaskell? I basically want to display some syntax-highlighted code.
15:43:26 <bitonic_> uhm. Is there any parser for aeson json values that gets *any* json value and not just objects/arrays?
15:44:32 <luite> bitonic: Data.Aeson.Parser.value
15:44:49 <t7> tikhonjelvis: maybe html window inside it?
15:45:08 <bitonic> luite: right, thanks.
15:45:28 <tikhonjelvis> t7: I was thinking that, but I can't find how to do that in the documentation.
15:45:35 <t7> tikhonjelvis: alternatively http://docs.wxwidgets.org/stable/wx_wxrichtextctrl.html#wxrichtextctrl
15:45:54 <tikhonjelvis> Ah, that sounds promising. Thanks.
15:46:02 <adnauseam> how do i use lambdabot to beta reduce a function ?
15:46:17 <t7> tikhonjelvis: http://docs.wxwidgets.org/stable/wx_wxhtmlwindow.html#wxhtmlwindow
15:46:42 <tikhonjelvis> Ah, that makes sense. I was looking for "web view", and it happens to be called "html window".
15:46:43 <t7> whatcha righting, anyhow?
15:46:54 <t7> writing*
15:46:56 <tikhonjelvis> Basically a diff/merge tool type thing.
15:46:57 <hpc> > (\x -> x ** 15) (y - 2) :: Expr
15:46:58 <lambdabot>   (y - 2)**15
15:47:15 <adnauseam> o
15:47:31 <hpc> it's not even remotely general-purpose though
15:47:39 <hpc> what with the Expr type
15:47:53 <adnauseam> > (\x -> x x ) (\x -> x x ) :: Expr
15:47:54 <lambdabot>   Occurs check: cannot construct the infinite type:
15:47:54 <lambdabot>    t = t -> SimpleReflect...
15:48:03 <adnauseam> fair enough
15:48:04 <newsham> > foldl (+) z [x,y]
15:48:05 <lambdabot>   z + x + y
15:48:23 <adnauseam> > (\x -> x x ) (\y -> y y ) :: Expr
15:48:24 <lambdabot>   Occurs check: cannot construct the infinite type:
15:48:24 <lambdabot>    t = t -> SimpleReflect...
15:48:40 <t7> > anyfink :: Expr
15:48:41 <lambdabot>   Not in scope: `anyfink'
15:48:58 <adnauseam> > reverse :: Expr
15:48:59 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
15:48:59 <lambdabot>         against inferred ...
15:49:05 <adnauseam> almost ;p
15:49:17 <adnauseam> but aye i understand
15:49:25 <qwert_> I have written a program calculating the values of a first order recursion function. For n=12 it takes 5s to compute, for something like n=15 it takes forever -- what could be the issue here?
15:49:35 <newsham> > reverse [x,y,z]
15:49:36 <lambdabot>   [z,y,x]
15:50:01 <c_wraith> qwert_: O(n!^2) algorithm?
15:50:05 <luite> qwert_: ghc doesn't memoize values automatically
15:50:15 <c_wraith> (I've written algorithms with that complexity before...  oops)
15:50:20 <luite> qwert_: same for common subexpressions
15:50:44 <qwert_> c_wraith: it's a simple explicite Euler method
15:51:02 <qwert_> luite: So what could I do about it?
15:51:26 <luite> qwert_: dunno, perhaps show the implementation first
15:51:38 <c_wraith> Oh, is it looking for something to converge? It's fully possible for a function Double -> Double to not converge even when calculus claims the function does on real numbers
15:51:41 <luite> qwert_: if you need something more than once, you can use let (or where), to give it a name
15:54:01 <qwert_> luite: the implementation is just: x (n+1) = x n + h*f n
15:54:10 <qwert_> with a given f n and x 0
15:54:24 <qwert_> It is Integer->Float
15:54:57 <qwert_> I have also tried to use let
15:55:05 <qwert_> But I don't know about where
15:55:24 <adnauseam> what's !! called ?
15:56:24 <scopedTV> nth element?
15:56:26 <scopedTV> or bang-bang
15:56:52 <adnauseam> ;p
15:56:59 <c_wraith> usually !! is called "a sign something might be wrong"
15:57:07 <Cale> qwert_: Maybe try turning it into a sum or foldl'
15:57:18 <Cale> qwert_: Can I see the code?
15:57:20 <c_wraith> There are not many places where !! is a good idea
15:57:23 <Cale> hpaste.org
16:04:52 <hpaste> qwert_ pasted “Euler method” at http://hpaste.org/68302
16:06:58 <c_wraith> that looks like it's just massively recursive
16:07:23 <c_wraith> memoize it if you want results in a reasonable amount of time
16:09:31 <c_wraith> the x functions have a branching factor of 2. the v functions have a branching factor of four.  That implies runtimes on the order of O(4^n)
16:09:32 <qwert_> c_wraith: how can I memorize?
16:09:49 <qwert_> c_wraith: oh ok
16:10:31 <Bytter> is there any QuickCheck wiz around?
16:11:21 <ezyang> Just ask the question!
16:12:18 <Bytter> ezyang: my question is actually about ScalaCheck (the QuickCheck equivalent) for scala, but the same may apply: http://stackoverflow.com/questions/10518015/high-order-scalacheck
16:12:20 <c_wraith> some people would use Data.MemoCombinators for that...  I've never bothered to figure out how exactly it works. But since the recursive structure is so simple, I'd be tempted to just use simple memoization based on boxed arrays
16:13:25 <ezyang> you need a generator for your input cases, and in a non-lazy language it is a little hard to create values of type 'a'.
16:13:41 <ezyang> and in all languages hard to test it for equality :^)
16:14:02 <Bytter> ezyang: so, basically, i would need a generator for polymorphic unary functions
16:15:51 <qwert_> Ok, that sounds rather complicated.
16:16:18 <Polarina> Why would this comment give me a sytax error? Protocol.hs:36:61: parse error on input `--\'
16:16:20 <c_wraith> or you could replace each of those functions with an infinite list
16:16:28 <c_wraith> that's the simplest
16:16:34 <ezyang> Honestly, for things like this you should just rely on the awesomeness of the typechecker.
16:16:49 <AtnNn> Polarina: you need a space between -- and \
16:17:41 <hpc> :t (--\) -- valid identifier
16:17:42 <lambdabot> parse error (possibly incorrect indentation)
16:17:46 <Polarina> AtnNn, shouldn't anything following a --  be a comment?
16:17:46 <hpc> oh, or not
16:17:48 <qwert_> How would that infinite list look like?
16:18:51 <Polarina> --a is a valid comment.
16:19:20 <c_wraith> @hoogle zipWith4
16:19:21 <lambdabot> Data.List zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
16:19:21 <lambdabot> Data.Sequence zipWith4 :: (a -> b -> c -> d -> e) -> Seq a -> Seq b -> Seq c -> Seq d -> Seq e
16:19:26 <hpc> Polarina: i just assume " -- anything" is a comment
16:19:27 <c_wraith> hey, it exists.  nice
16:19:32 <fmap_> > let a --\ b = a + b in 3 --\ 5
16:19:33 <lambdabot>   8
16:19:34 <hpc> and that you can't use "--" in an identifier
16:21:52 <Polarina> c_wraith, that breaks so many syntax highliters.
16:22:12 <mizu_no_oto> Which is generally easier to parallelize in Haskell:  memoizing a recursive function, or dynamic programming?  In particular, I'd like to make a parallel version of Floyd-Warshal (or the equivalent memoized recursive algorithm) for a class.
16:22:31 <zzo38> Hopefully "prelude-generalize" package is better now.
16:22:35 <c_wraith> mizu_no_oto: with lazy evaluation, they're the exact same thing
16:22:53 <c_wraith> mizu_no_oto: so you only actually get dynamic programming if your table is strict
16:22:58 * hackagebot prelude-generalize 0.2 - Another kind of alternate Prelude file  http://hackage.haskell.org/package/prelude-generalize-0.2 (AaronBlack)
16:23:29 <qwert_> c_wraith: Ok, thanks, I will try it this way
16:23:47 <zzo38> Do you like these changes to this program?
16:24:49 <mizu_no_oto> Is there a good library for memoizing recursive functions?
16:25:00 <hpc> several
16:25:15 <hpc> you have to "unfix" them pre-memo though
16:25:16 <mizu_no_oto> Since then I could use `par`, presumably, to add parallelism
16:25:27 <hpc> ie, replace foo params = ... foo ...
16:25:29 <hpc> with
16:25:38 <hpc> foo = \foo params -> ... foo ...
16:25:52 <mizu_no_oto> Ah
16:25:58 <mizu_no_oto> What's a good one?
16:26:05 <hpc> that gives the memo function somewhere to "hook" itself
16:26:07 <hpc> so to speak
16:26:15 <hpc> for the recursive call
16:28:02 <mizu_no_oto> What's a good library to use?
16:29:28 <hpc> mizu_no_oto: use the hoogle, luke
16:30:28 <hpc> one of my favorites memoizes with an sqlite database
16:31:21 <c_wraith> someone once did a truly terrifying unsafePerformIO memoizer based on my lrucache library. I was terrified it worked.
16:31:40 <c_wraith> I hope it was never released, though :)
16:31:54 <hpc> c_wraith: awesome
16:32:01 <hpc> it actually doesn't sound too dangerous
16:32:16 <hpc> if you ignore the not knowing when something will be recomputed
16:33:18 <kniu> I just got a crazy idea
16:33:21 <c_wraith> I guess the worst-case behavior is just that it slightly slows down the original function (when nothing is ever in the cache)
16:33:30 <c_wraith> It should never introduce crazy wrong behavior
16:33:55 <luite> c_wraith: hmm i might have done that for some code at some point :p
16:34:03 <c_wraith> luite: I think it was you, yes :)
16:34:06 <kniu> you know how, using Control.Applicative, you use a bunch of operators to make monadic code look like normal function application?
16:34:24 <kniu> <$>, <*>, *>, <*, and related
16:34:49 <mizu_no_oto> Do any of the memoization libraries have problems with parallel haskell?
16:34:55 <kniu> what if we make function application syntax (a.k.a. the whitespace 'operator') overloaded, like do notation?
16:35:02 <luite> c_wraith: nah i never released that, wouldn't want to risk my reputation for something like that ;p
16:35:05 <hpc> kniu: the Identity monad is that thing
16:35:10 <hpc> @src Identity
16:35:11 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
16:35:15 <hpc> @src Identity return
16:35:16 <lambdabot> return a = Identity a
16:35:19 <hpc> @src Identity (>>=)
16:35:20 <lambdabot> m >>= k  = k (runIdentity m)
16:36:15 <kniu> hpc, I don't quite understand what you mean
16:36:41 <hpc> kniu: oh, i think i misunderstood what you were suggesting
16:36:49 <hpc> overloading function application is horrible
16:36:55 <kniu> does that mean I can write (f x y) where (f :: Identity a -> Identity b -> Identity c) and (x :: Identity a) and (y :: Identity b) ?
16:36:58 <hpc> kniu: what would be the type of ($)?
16:37:08 <kniu> I... have no idea
16:37:25 <hpc> kniu: you already can write that
16:39:31 <kniu> ($) :: forall f a b. Applicative f => (a -> f b) -> f a -> f b
16:39:33 <kniu> ?
16:40:06 <newsham> Prelude> :type ($)
16:40:06 <newsham> ($) :: (a -> b) -> a -> b
16:40:31 <newsham> kniu: is that from lambdabot?
16:40:51 <newsham> lambdabot is "special"
16:40:53 <kniu> newsham, no I just wrote it
16:41:09 <newsham> oh, heh, thats what i get for reading out of context
16:41:11 <hpc> kniu: you actually just wrote the type of (>>=)
16:41:23 <hpc> er, (=<<)
16:41:40 <kniu> :t <$>
16:41:41 <lambdabot> parse error on input `<$>'
16:41:48 <kniu> :t (<$>)
16:41:49 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:41:52 <kniu> :t (=<<)
16:41:53 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
16:41:58 <kniu> hm
16:42:00 <kniu> indeed
16:42:07 <hpc> :t (<*>)
16:42:09 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:42:29 <hpc> the progression of those types from functor to applicative to monad is neat
16:42:59 * hackagebot MemoTrie 0.4.13 - Trie-based memo functions  http://hackage.haskell.org/package/MemoTrie-0.4.13 (ConalElliott)
16:43:08 <c_wraith> speaking of memoization
16:43:16 <c_wraith> I wonder what Conal changed
16:43:27 <kniu> maybe the solution is just to have better lexical syntax for <$>, =<<, and <*>
16:43:53 <hpc> kniu: do-notation and idiom brackets are that syntax
16:44:07 <kniu> hpc, what are idiom brackets?
16:44:08 <hpc> few people use idiom brackets though, because it's so easy to write applicative code
16:44:10 <c_wraith> of course, haskell doesn't *have* idiom brackets...
16:44:25 <hpc> (| f x y |) = f <$> x <*> y
16:44:29 <hpc> or something like that
16:44:34 <c_wraith> SHE does, but haskell does not
16:44:37 <hpc> c_wraith: i think there's TH that offers it
16:44:39 <kniu> is that in Haskell?
16:44:46 <hpc> kniu: not with that syntax
16:45:12 <c_wraith> you can write it with TH, yes.  but TH slows down compilation so much people tend to avoid it for simple syntactic sugar
16:45:35 <hpc> in any event, it's not really a problem for haskellers to have a few infix symbols in the middle of interesting code
16:45:58 <hpc> it's a lot like perl, only we know what our code does
16:46:03 <hpc> :D
16:47:53 <c_wraith> the one that really gets me is f <$> pure a <*> b
16:48:07 <c_wraith> because usually a is not a single-lexeme expression
16:50:15 <kniu> isn't that better written as
16:50:19 <kniu> f a <$> b
16:50:21 <monochrom> wait, can you do f a <$> b for that?
16:50:46 <Philippa> yes
16:51:04 <Philippa> can't do f a <*> b instead of f <*> a <*> b though
16:51:22 <Philippa> er, f <*> pure a <*> b, even
16:51:24 <kniu> f <$> a <*> pure b --how do I shorten this?
16:51:42 <Philippa> you don't because <$> has the wrong associativity, IIRC
16:51:52 <hpc> :t flip
16:51:53 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
16:52:03 <kniu> flip f b <$> a
16:52:13 <kniu> :t (*>)
16:52:14 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
16:52:14 <hpc> :t \f a b -> flip f b <$> a
16:52:15 <lambdabot> forall a a1 b (f :: * -> *). (Functor f) => (a -> a1 -> b) -> f a -> a1 -> f b
16:52:16 <kniu> :t (<*)
16:52:17 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
16:52:35 <monochrom> wait, flip has a general type like that as well? is that caleskell?
16:52:46 <c_wraith> yes
16:52:48 <hpc> :t (<$)
16:52:49 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
16:52:56 <hpc> :t (<$$>)
16:52:57 <lambdabot> Not in scope: `<$$>'
16:53:04 <hpc> :t (<**>)
16:53:05 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
16:53:50 <kniu> I like Caleskell better than vanilla Haskell, tbh
16:58:42 <conal> c_wraith: i exported the associated data type constructors from MemoTrie so people can define instances of other classes over various Trie representations.
16:58:55 <c_wraith> ah. that makes sense
16:59:15 <conal> i had to dig around to find out how to export them.
17:00:44 <c_wraith> Hmm.  Come to think of it, I've never done that myself.
17:00:45 <xil> hey everyone. OpenGL question. I want to use vertexAttribPointer and one of the parameters it takes has a Ptr a attribute. In C++ a call like this would have "(GLvoid*)0" for the pointer. Does anyone know if I can just use nullPtr in Haskell?
17:01:23 <conal> http://www.haskell.org/haskellwiki/GHC/Type_families#Import_and_export
17:01:38 <conal> i'm playing with modeling FPGA-like stuff, using tries to generalize muxes and LUTs.
17:02:42 <applicative> I remember reading that passage about exporting type families, or rather trying to ...
17:03:30 <applicative> associated families rather
17:05:32 <acowley> xil: yes
17:05:39 <xil> acowley: thanks =]
17:05:58 <acowley> xil: np!
17:07:11 <xil> acowley: oh quick other question, just if you happen to know since no one in #opengl has responded yet. If I leave out a fragment shader, will it default to using the color from glColor calls? Or in Haskell, "color" calls?
17:07:57 <kallisti> no matter how much people rage on it
17:08:02 <kallisti> RecordWildcards makes my life easier.
17:08:21 <acowley> xil: that's a good question, but if I had to guess I'd say that behavior is undefined. I think I read that you have to supply vertex and fragment shaders for the program to be valid, but I may have just assumed that. Certainly the geometry shader is optional.
17:08:51 <acowley> xil: why not just try it? :)
17:09:18 <applicative> c_wraith: check out the she idiom brackets in the parser for this 'Frank' language...  http://hpaste.org/68304
17:09:49 <xil> acowley: oh I'm working on that, it's just that I'm learning GL 2 while also figuring out how to do it in Haskell, and I haven't gotten to a place where I can run it quite yet. Usually I ask in here with the intention of just trying it, but the hope that someone might answer first, making it easier to debug if I do have a problem
17:10:21 <xil> in fact, I'm converting this, albeit small, program from GL 1 to GL 2, in the sense of fixed functionality to whatever you call drawArray stuff
17:10:30 <acowley> xil: understood. If you can avoid it, don't use glColor. Use vertex arrays.
17:10:47 <acowley> xil: Have you seen my modern OpenGL in Haskell tutorial?
17:10:58 <xil> acowley: not sure, could you link?
17:11:08 <acowley> @google modern OpenGL in Haskell
17:11:11 <lambdabot> http://www.arcadianvisions.com/blog/?p=224
17:11:11 <lambdabot> Title: Arcadian Visions » Modern OpenGL with Haskell
17:11:22 <xil> aha, I did
17:11:32 <acowley> did it not get you off the ground?
17:12:59 <xil> I didn't quite read the whole thing. I used it to figure out how to load/compile/link shaders, but because I'm just doing one small rendering, I've been doing everything else pretty much by going through the docs
17:13:15 <acowley> I think that's often a mistake with something as big as OpenGL
17:13:38 <acowley> tutorials and recipes are an effective way to identify the parts of the API you need to think about
17:13:50 <xil> well I learned GL 1 pretty well, so I'm really interested in seeing the full GL 2 way of doing things
17:14:07 <xil> namely, you use GLUtil, and I kinda wanted to see how it's actually done
17:14:18 <xil> I actually went into the GLUtil source to see how to load up shaders
17:14:28 <acowley> Yeah, it's good in some ways, but brings a lot more boilerplate for doing simple things.
17:14:42 <acowley> Good!
17:15:01 <acowley> I've added a little bit of OpenGL 3 things to GLUtil a while ago, too
17:15:29 <xil> I'm actually doing this out of curiosity for understanding how OpenGL really works, hence not wanting to use helper packages too much. At least not yet
17:15:40 <xil> unfortunately, my current drivers limit me to GL 2 =[
17:17:12 <acowley> xil: Yeah, so what I recommend is starting with a working executable as found in the blog post, then copy the GLUtil parts you use into your own code (maybe in a second file).
17:17:57 <acowley> xil: graphics APIs are impossible to figure out when you can't see the output. That's why camera bugs are so nasty.
17:18:31 <kallisti> hm, would a rose tree zipper be a comonad?
17:18:38 <xil> oh yeah. I spent, like, a solid month figuring out camera dynamics when I learned OpenGL originally
17:20:26 <acowley> xil: that's great, I've been doing OpenGL for twenty years and I still throw out my camera code fairly often :P
17:21:25 <parcs`> 20 years? christ
17:21:27 <xil> oh wow. Yeah I've only been doing this for a few years, and not very much until pretty much now. And then found out last week that I've been limiting myself to GL 1 this whole time. Had no idea
17:22:56 <acowley> sooooo old
17:22:57 <monochrom> some people have been using fortran 77 the whole life and still haven't checked out fortran 90 or something, too
17:23:09 <acowley> 77 was a good vintage
17:23:37 <acowley> the biggest reasons to move on from GL 1 are performance and portability to GLES 2
17:23:57 <acowley> afaict F77 folks see no reasons to move on
17:24:06 <monochrom> also, some people are still using a 10-year-old mirc version and still haven't checked out the 5-year-old version
17:24:25 <acowley> Internet hipsters
17:24:26 <monochrom> and last but not least:
17:24:32 <monochrom> @quote ray 1970s
17:24:32 <lambdabot> ray says: when you're dealing with programmers you are often dealing with people who voluntarily use 1970s terminals. they cannot be reasoned with
17:25:08 <ozataman> are these quotes listed somewhere? :)
17:25:23 <jfischoff> @quote opengl
17:25:23 <lambdabot> Cale says: OpenGL is the Rubik's Cube of graphics libraries. It's nearly impossible to change some things without affecting other things
17:25:53 <OMGTallMonster> Rubik's cubes are fun. :)
17:27:09 <acowley> What I learned many years ago is that your video drivers hate you, and OpenGL is a troll. If you internalize that, it all becomes much more comprehensible.
17:54:48 <AtnNn> I completed Oleg's de-typechecker
17:54:50 <AtnNn> http://code.atnnn.com/projects/guess/repository/entry/guess-combinator/Guess/Combinator.hs
17:59:06 <dmwit> So, does this mean somebody should make a Haskell' proposal?
17:59:08 <dmwit> http://stackoverflow.com/a/10402105/791604
18:00:37 <dmwit> AtnNn: cool =)
18:03:00 <ben> is abs (-0.0) = -0.0 defined in the report or something?
18:03:59 <ben> yeah, looks like it
18:04:03 <mm_freak> > signum (-0.0) * abs (-0.0)
18:04:04 <lambdabot>   -0.0
18:04:06 <ben> abs x    | x >= 0  = x ;
18:04:07 <ben> | x <  0  = -x
18:05:43 <nyingen> I'm trying to figure out how to design a program that will process hundreds of large xml files. The files describe graphs. I want to use xml-conduit to do SAX parsing of the files, then translate the data to graphs using the fgl library
18:06:02 <nyingen> The question is: how do I deal with the state manipulations required to build up the graphs during parsing?
18:06:08 <gwern> hm. I wish .prof format was more readable and would align columns better...
18:06:14 <nyingen> IORef with a state object inside? Some kind of state monad? Other?
18:06:37 <dmwit> Are state manipulations really necessary?
18:06:45 <parcs`> gwern: what ghc version do you have?
18:06:53 <gwern> 7.0.4
18:07:18 <parcs`> i've noticed that the .prof output of 7.4.1 is much more readable
18:07:41 <nyingen> dmwit: not sure how else I would build up a graph object according to a stream of sax events
18:08:32 <nyingen> I wrote such a program using xml-enumerator and using a IORef to maintain the state, but I'm getting weird artifacts possibly due to laziness
18:08:51 <nyingen> since I can't figure out how to fix that, I was thinking I'd start over with xml-conduit and a different state approach, if warranted
18:09:17 <gwern> hm. so the profile output says a fifth of the runtime is going just to 'pandocTransform = bottomUp (map (convertInterwikiLinks . convertHakyllLinks))', but the 2 convert calls make up no more than 5% of the time... so I guess bottomUp or map really sucj
18:10:06 <dmwit> nyingen: Well, I don't know, but can you turn a stream of SAX events into a stream of edges?
18:10:14 <dmwit> I'll admit I don't know much about SAX.
18:10:34 <dmwit> But if you have to do state, and you can do it with State, there's not much advantage to using IORef instead.
18:11:19 <jfischoff> nyingen: do anything about the graph structure. Is it dag, or can it have cycles? (this is only indirectly related to your issue)
18:11:20 <nyingen> dmwit: I was thinking of using a conduit to accomplish something like that. Basically 'buffer' the sax events until all the events for a given graph are recevied, then pass that on to the graph-construction function
18:11:42 <parcs`> gwern: i've noticed that 7.4.1 is also better in that regard -- profiling is much more granular and thorough
18:11:44 <nyingen> jfischoff: it can have cycles, but the cycles are notated specially. that part shouldn't be a problem (my existing program handles it fine)
18:11:47 <jfischoff> s /do anything/ do you know anything
18:12:10 <gwern> map should be efficient, so it must be bottomUp. checking the Pandoc generics module, apparently topDown also exists and does somewhat the same thing modulo edgecases that shouldn't apply. let's see how that profiles...
18:12:25 <gwern> possibly bottomup is forcing multiple traversals of a page or something
18:12:39 <gwern> just the name 'bottomUp' compared to 'topDown' sounds inefficient
18:14:10 <ku> I am reading the haskell wiki book
18:14:15 <ku> and came across this
18:14:22 <ku> Haskell language opted for a more prudent "monomorphism restriction". It means that values may only have a polymorphic type if it can be inferred from the context, or if you explicitly give it one. Otherwise, the compiler is forced to choose a default monomorphic (i.e. non-polymorphic) type. This feature is somewhat controversial.
18:14:23 <ku> is it true that it is controversial?
18:14:40 <blackdog> ku: no. everybody hates it.:)
18:14:56 <gwern> ku: it's so controversial one conference required a SWAT assault on an auditorium of die-hards
18:15:06 <ku> ha
18:15:24 <ku> so is it considered good in any way or by any one?
18:15:34 <gwern> ku: olin shivers was going to write a version of his CMU guns essay about the restriction with a pro-restriction sniper took him out
18:15:42 <gwern> *when
18:15:49 <ku> hah
18:17:05 <ku> i'm trying to get a sense for haskell culture, does the haskell project respond to criticism quickly when everyone generally agrees?
18:17:09 <dmwit> There are probably people who benefit from it but don't know enough about it to like it or dislike it: beginners who are getting asymptotically better performance because they wrote crappy (but polymorphic!) code.
18:17:16 <gwern> (darn. topDown is trivially different)
18:18:43 <ku> also the example given doesn't seem to work in my ghci...
18:18:43 <Philippa> ku: "the haskell project"? (generally agrees which way?)
18:18:48 <blackdog> ku: there does need to be an alternative, though. it's generally agreed that records are awful, but there's no consensus on a replacement yet.
18:19:10 <Philippa> yeah. Records are a particularly bad incident of hysterical raisins
18:19:22 <dmwit> ku: There is a well-known process for proposing, discussing, and implementing changes to the language.
18:19:31 <blackdog> Philippa: kind of a perfect-is-the-enemy-of
18:19:34 <blackdog> the-good, too
18:19:41 <ku> Philippa: I mean in terms of core committers and the community that surrounds the language
18:19:44 <dmwit> ku: See http://hackage.haskell.org/trac/haskell-prime/
18:19:48 <Philippa> blackdog: that and nobody wants to have to redo it in 5 years' time
18:19:53 <ku> dmwit: ah ok
18:20:26 <ku> thanks
18:20:42 <Axman6> ku: all decisions are thought about deeply before making changes that may break code. this is why we have several features in the languages which most people agree are crap, but haven't been replaced because a) they're relied on in old code, and b) we don't have alternatives that are better enough to justify breaking the old code
18:20:45 <Philippa> note that GHC Haskell changes rather faster than Haskell'
18:20:48 <blackdog> Philippa: ya. totally understandable, but a bit frustrating.
18:21:37 <Philippa> Axman6: also c) until recently we didn't have sensible transitional paths - LANGUAGE pragmas are still comparatively new compared to some library lifetimes
18:21:56 <Axman6> good point
18:22:20 <blackdog> at least -fglasgow-exts is disappearing :)
18:22:24 <ku> Philippa: what exactly is the different between GHC haskell and others, I am aware that GHC is the most used compiler, so you're saying it is "ahead" of others?
18:23:33 <dmwit> GHC implements Haskell98 and Haskell2010.
18:23:37 <Philippa> I'm saying that implementations have their own extensions, and "GHC Haskell" is something of a de facto standard
18:23:42 <dmwit> At your option, there are a variety of language extensions available, as well.
18:23:51 <dmwit> Some of those extensions are also supported by other compilers, but most aren't.
18:23:55 <Philippa> Also, what dmwit said re 98, 2010
18:24:22 <Philippa> some of the extensions aren't well-defined enough for implementations to agree adequately, either. That's one price of seeing research go straight into implementation
18:25:05 <ku> ah ok
18:25:17 <Philippa> so some GHC extensions are more stable than others - "GHC Haskell" is really a cluster concept based on which ones are "stable enough"
18:25:31 <blackdog> ku: in practical terms, most of the stuff on hackage is only tested with ghc. if you want to write an app that's basically glue code between a bunch of libraries (as a lot of web apps are, for instance), GHC is your only real choice.
18:25:35 <Philippa> (did anyone ever think impredicative types were?)
18:25:44 <tgeeky> ku: stick to GHC, though. There's a reason that G stands for both Glorious and Glasgow.
18:25:56 <Philippa> it ain't the weather in Glasgow!
18:26:16 <ku> ha
18:26:23 <tgeeky> plus, look at this face: http://en.wikipedia.org/wiki/File:Simon_Peyton_Jones_01.jpg
18:26:36 <tgeeky> That's the face of brilliant madness and mad brilliantness, all wrapped up in a bowtie.
18:27:20 <Philippa> ...I have a sudden image of SPJ as the Twelth Doctor
18:27:47 <tgeeky> Philippa: in 100 years, when the show actually ends, I'm betting that he's the -1st doctor :O
18:27:54 <ku> out of curiosity  are there any major open source projects using a implementation other than GHC with extensions specifc to those implementations?
18:28:16 <tgeeky> ku: there's the Utretch Haskell Compiler, and Hugs, and... a few others.
18:28:18 <Philippa> can't think of any
18:28:26 <tgeeky> None of them have anywhere near the suite of extensions that GHC has
18:28:28 <Philippa> tgeeky: that's not what ku asked
18:28:58 <Philippa> There used to be stuff that relied on Hugs aaaages back
18:29:34 <tgeeky> Philippa: oh, good point. I thought he was talking about the compilers, not the software made with them
18:29:40 <ku> I like the sound of Hugs ha
18:30:35 <ku> thanks all for the details
18:30:52 <alpounet> AFAIK, there isn't any major open source project being specific to Hugs or UHC
18:31:38 <derekv2> I want to find the position of the first element in a list to exceed some value, up to some maximum
18:31:53 <dmwit> :t findIndex
18:31:54 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
18:32:15 <dmwit> :t \f n -> findIndex f . take n
18:32:16 <lambdabot> forall a. (a -> Bool) -> Int -> [a] -> Maybe Int
18:32:45 <gwern> is syb known to be slow?
18:32:48 <derekv2> dmwit Thanks I'll try it
18:33:09 <sipa> alpounet: except those compilers themselves, maybe?
18:33:49 <alpounet> sipa, yeah I guess, but that has been suggested by tgeeky somehow
18:35:31 <monochrom> @remember Philippa ...I have a sudden image of SPJ as the Twelth Doctor
18:35:31 <lambdabot> Okay.
18:35:59 <tgeeky> the bottom line is, if you see a project on Hackage which says "Portable: No", it's probably not because it relies on an extension to Hugs or UHC
18:39:59 <ku> Oh the list http://www.haskell.org/haskellwiki/Books I've read Learn you a Haskell, does anyone here particularly recommend one of them?
18:40:13 <wli> Speaking of perl, is there an analogue of perl's split operator using delimiters described regexes?
18:40:30 <ku> or are they all pretty good books to pick up haskell (coming from imperative)
18:40:52 <alpounet> ku, RWH is pretty cool because it makes you write concrete programs
18:41:04 <alpounet> like, some/many of them can actually be useful
18:41:13 <Philippa> ku: if you like hugs, you might appreciate the date of the first release - valentine's day
18:43:38 <lispy_> Philippa: oh neat. I didn't know about that
18:44:25 <derekv2> mand c = take 10 [r | r <- iterate (\z -> (z ** 2) + c) c, realPart (abs (r**2)) < 2]
18:44:50 <ku> Philippa: =)
18:44:51 <derekv2> It should stop generating when its reached 10, right?
18:46:07 <Nisstyre> How would I turn this into point-free? ((1 + n) * (n/2))^2 lambdabot gives "(^ 2) . liftM2 (*) (1 +) (/ 2)" which does not work because there is no instance of Monad for "((->) c0)"
18:46:30 <monochrom> yes, if it ever reaches 10
18:46:56 <derekv2> actually, that can't be the problem
18:47:17 <monochrom> > take 10 [x | x<-[1..], x<0]
18:47:21 <lambdabot>   mueval-core: Time limit exceeded
18:47:21 <derekv2> because its blocking up on input where it shouldn't hit 10
18:47:30 <derekv2> oh.
18:47:35 <monochrom> is an example of never reaching 10
18:47:40 <derekv2> I see.
18:47:59 <derekv2> I didn't figure it worked like that.
18:48:01 <parcs`> Nisstyre: import Control.Applicative
18:48:25 <derekv2> Then take isn't what I want.
18:48:48 <Nisstyre> parcs`: oh there's an instance defined in there I guess
18:48:54 <Nisstyre> sweet
18:49:41 <parcs`> it's actually defined in Control.Monad.Instances and re-exported in C.A but you eventually want to import Control.Applicative anyway
18:55:32 <hpaste> dibblego pasted “semigroupoids” at http://hpaste.org/68307
18:55:45 <dibblego> does anyone have a formula to resolve the duplicate instances of Foldable (IdentityT m) in Data.Traversable.Instances and Control.Monad.Trans.Identity?
19:00:02 <xil> hey everyone. If I want a multiple line string literal, how do I go about that? I just had the string span multiple lines but GHC throws a lexical error on the new line character
19:00:45 <yan_> xil: escape the newline: i.e. "foo \<enter>
19:00:46 <wli> Backslashes followed by whitespace I think.
19:00:54 <shachaf> xil: You can use a TH quasiquoter
19:01:10 <shachaf> Or backslashes if you're OK with those. :-)
19:01:12 <xil> yan_: do I need another backslash on the next line?
19:01:27 <yan_> xil: every time you have a newline character, just add a backslash before it
19:01:39 <xil> okay, thanks =]
19:01:46 <xil> shachaf: I'll google that too, thanks =]
19:01:53 <yan_> xil: looks like you need to add a slash for where you want it to begin
19:02:35 <shachaf> > "a\     \b" -- \s+ between the backslashes.
19:02:36 <lambdabot>   "ab"
19:03:24 <xil> looks like I need to do "sometext\<enter>\<somespace>moretext"
19:03:34 <shachaf> No need for the <somespace>
19:03:40 <shachaf> Unless you actually want some space, that is.
19:03:57 <xil> ghc threw an error on the first character of "moretext" without it
19:04:10 <xil> oh wait...
19:04:21 <shachaf> Haskell has exciting escape sequences.
19:04:22 <yan_> xil: you can do: "sometext\<enter><somespace>\moretext" if you want <sometext> to be indented
19:04:23 <shachaf> Like \&
19:04:34 <yan_> rather "moretext"
19:05:12 <xil> oh whoops, didn't try without <somespace> because I thought it would escape the 'm' in "moretext"
19:05:20 <xil> I'll take your word for it that it doesn't
19:07:11 <Axman6> hmm, so i've come up with a string searching algorithm, and I was wondering if anyone could identify its actual name/creators (I'm assuming I haven't come up with some amazing new string searching algorithm...)
19:07:24 <Axman6> paste in a sec
19:07:39 <hpaste> Axman6 pasted “String Search” at http://hpaste.org/68308
19:08:48 <Axman6> also, I think a hashmap is not right thing to be using here
19:10:24 <derekv> mand c =  [r | r <- iterate (\z -> (z ** 2) + c) c, realPart (abs r) < 2]
19:10:56 <Axman6> basically, i make a mapping between each character in the needle and its position in the needle, then i make hops of length needle, and search backwards distances based on the character I land on's position in the needle
19:11:03 <derekv> Doesn't complete.
19:11:10 <derekv> OK I get why,
19:11:24 <Axman6> because iterate goes on forever
19:11:29 <Axman6> use takeWhile
19:11:34 <Axman6> or something
19:11:56 <derekv> [x | x <- [1..10], x<5] can terminate because it knows how [1..10] is ordered?
19:12:08 <Axman6> it can terminate because [1..10] terminates
19:12:22 <derekv> It works with much bigger numbers.
19:12:26 <Axman6> [ x | x <- [1..], x < 5] will not terminate
19:12:30 <shachaf> derekv: Only because your computer is fast. :-)
19:12:54 <Axman6> > [x | x <- [1..100000], x<5]
19:12:55 <lambdabot>   [1,2,3,4]
19:12:58 <Axman6> > [x | x <- [1..1000000], x<5]
19:12:59 <lambdabot>   [1,2,3,4]
19:13:03 <Axman6> > [x | x <- [1..10000000], x<5]
19:13:06 <lambdabot>   mueval-core: Time limit exceeded
19:13:20 <Axman6> it still has to go through all 10000000 numbers
19:13:33 <OMGTallMonster> Axman6: Haven't evaluated it thoroughly, but it sounds a lot like KMP.
19:15:38 <derekv> damn
19:15:42 <derekv> my emacs just crashed
19:15:46 <derekv> that makes me sad
19:16:33 <Axman6> OMGTallMonster: i think it's different to KMP, but the wikipedia article for KMP doesn't give a good explanation at all
19:16:41 <Axman6> it could do with a nice general overview
19:17:06 <derekv> I'm too tired to learn a new way to program , and that makes me sad
19:17:27 <Axman6> derekv: what problems are you having?
19:17:45 <derekv> Axman6, just learning, tried to skip ahead and calculate mandlebrot
19:19:20 <Axman6> > let mand = takeWhile (\r -> realPart (abs r) < 2) . iterate (\r -> (r^2) + c) in mand (sqrt 2 :+ sqrt 2)
19:19:21 <lambdabot>   Couldn't match expected type `Data.Complex.Complex a'
19:19:21 <lambdabot>         against infer...
19:19:40 <Axman6> > let mand c = takeWhile (\r -> realPart (abs r) < 2) . iterate (\r -> (r^2) + c) $ c in mand (sqrt 2 :+ sqrt 2)
19:19:42 <lambdabot>   []
19:19:54 <Axman6> > let mand c = takeWhile (\r -> realPart (abs r) < 2) . iterate (\r -> (r^2) + c) $ c in mand (0.02 :+ 0.01)
19:19:56 <lambdabot>   [2.0e-2 :+ 1.0e-2,2.0300000000000002e-2 :+ 1.04e-2,2.030393e-2 :+ 1.0422240...
19:33:07 * hackagebot global-config 0.3.0 - Global mutable configuration  http://hackage.haskell.org/package/global-config-0.3.0 (AlexanderDorofeev)
19:37:49 <OMGTallMonster> Axman6: I'm still new to Haskell, but what is the purpose of your intlist datatype, as opposed to [Int]?
19:38:52 <Axman6> premature optimisation :P
19:39:14 <OMGTallMonster> heh
19:39:15 <Axman6> also, it kinda makes sense to use a list which can't be empty. saves a little processing
19:39:41 <Axman6> the hashmap takes care of the case where the list is empty (ie, the character doesn't exist in the needle)
19:41:31 <OMGTallMonster> So if the needle contains multiple of the same character, the hashmap contains all the occurrences.
19:43:08 <tgeeky> hmm... it looks like github is adopting the Solariazed color scheme with its icons
19:44:19 <Axman6> OMGTallMonster: exactly
19:44:25 <OMGTallMonster> Axman6: It seems like searching for "aaaaaaaaaaaaaaaaaaaaab" in "aaaaaaaaaaaaaaaaaaaaaab" would be a degenerate case.
19:45:19 <Axman6> OMGTallMonster: i think it's still worst case O(n*n/k) where k is the length of the needle
19:45:25 <Axman6> but i'm not sure about that
19:46:01 <OMGTallMonster> Well, KMP is O(n). :P
19:56:47 <tgeeky> dmwit: here?
20:00:47 <xil> hey, does anyone know how I can get a message to acowley?
20:01:07 <shachaf> preflex: seen acowley
20:01:07 <preflex>  acowley was last seen on #haskell 2 hours, 33 minutes and 57 seconds ago, saying: What I learned many years ago is that your video drivers hate you, and OpenGL is a troll. If you internalize that, it all becomes much more comprehensible.
20:01:14 <shachaf> xil: @tell acowley hi acowley
20:01:32 <xil> shachaf: that'll give him the message when he's next on IRC?
20:01:34 <shachaf> xil: Or @ask acowley what?
20:01:39 <shachaf> xil: Next time he talks in here.
20:02:00 <xil> cool!
20:03:58 <xil> @tell acowley hey, fun fact: you can't use nullPtr in the VertexArrayDescriptor; it causes a segfault. I looked through your GLUtils and did it your way, using "wordPtrToPtr $ fromIntegral 0", which works =D
20:03:59 <lambdabot> Consider it noted.
20:04:06 <xil> lambdabot is awesome
20:05:09 <lambdabot> i know :)
20:05:22 <tgeeky> hmm
20:05:26 <xil> ...
20:05:31 <tgeeky> someone has a hand up her ass, evidently
20:05:56 <parcs`> xil: i haven't had that problem
20:06:23 <xil> parcs`: well I can say that changing it from nullPtr to that other thing stopped the segfault
20:06:29 <parcs`> strange..
20:06:34 <parcs`> by the way where is this GLUtils
20:06:49 <xil> parcs`: https://github.com/acowley/GLUtil
20:07:41 <xil> going AFK -->
20:14:22 <adnap> > let as = [0,0.05..2] in zip as (map sin as)
20:14:24 <lambdabot>   [(0.0,0.0),(5.0e-2,4.997916927067833e-2),(0.1,9.983341664682815e-2),(0.1500...
20:18:43 <nyingen> @quote
20:18:43 <lambdabot> Saizan_ says: i've found that it requires a bit of olegy sophistication, but there could be simpler ways
20:19:23 <nyingen> Oleg : Haskell :: Gandalf :: Middle-Earth ?
20:19:37 <nyingen> er, subtract a colon from that last pair
20:19:41 <hpaste> grom358 pasted “poker” at http://hpaste.org/68309
20:20:26 <grom358> what is wrong with that? I put it into ghci and it tells me <interactive>:1:1: parse error on input `data'
20:21:48 <Axman6> @pl \xs -> zip xs (map f xs)
20:21:49 <Axman6> lambdabot? :(
20:21:49 <lambdabot> ap zip (map f)
20:22:14 <OMGTallMonster> Axman6: Yeah, your algorithm is O(len*hlen), I think.
20:23:09 * hackagebot global-config 0.3.1 - Global mutable configuration  http://hackage.haskell.org/package/global-config-0.3.1 (AlexanderDorofeev)
20:36:59 <adnap> > let (f,as) = (\x->(pi/2)-x,[0,0.05..2]) in zip (map cos as) (map (sin . f) as)
20:37:01 <lambdabot>   [(1.0,1.0),(0.9987502603949663,0.9987502603949663),(0.9950041652780258,0.99...
20:37:11 <grom> yeah I want to port this https://github.com/grom358/poker-stats to Haskell
20:41:03 <adnap> @pl \f,as->zip (map cos as) (map (sin . f) as)
20:41:03 <lambdabot> uncurry (ap (zip . map cos) . map . (sin .))
20:41:18 * adnap pukes
20:41:52 <adnap> >:t ap
20:42:45 <adnap> (a -> b) -> a -> b
20:48:21 <kallisti> What's the most scaleable "data persistence" system for Haskell?
20:48:29 <kallisti> these days.
20:55:54 <Enigmagic> grom: data constructors have to start with a capital letter
20:56:29 <crdueck> whats the reccomended way to get sane haskell indentation in vim?
20:56:36 <grom> Enigmagic: okay.. now I get <interactive>:1:17: parse error on input `='
20:57:33 <Enigmagic> grom: what version of GHC are you using? defining data types in ghci is only supported in 7.4 and up (or maybe it was 7.2)
20:59:53 <adnap> @hoogle main
20:59:54 <lambdabot> Language.Haskell.Syntax main_mod :: Module
20:59:54 <lambdabot> Language.Haskell.Syntax main_name :: HsName
20:59:54 <lambdabot> package mainland-pretty
21:00:01 <adnap> @hoogle ap
21:00:02 <lambdabot> Prelude appendFile :: FilePath -> String -> IO ()
21:00:02 <lambdabot> System.IO appendFile :: FilePath -> String -> IO ()
21:00:02 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
21:00:31 <adnap> +
21:02:28 <grom> oh.. i see.. The Glorious Glasgow Haskell Compilation System, version 7.0.3
21:04:46 <kallisti> > let i=shows; fizz=showString "Fizz"; buzz=showString "Buzz";fb=const(fizz.buzz); f=const fizz; b=const buzz in unwords . map ($"") $ zipWith ($) (cycle [i,i,f,i,b,f,i,i,f,b,i,f,i,i,fb]) [1..]
21:04:48 <lambdabot>   "1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz 16 17 Fizz 19 Bu...
21:05:33 <kallisti> probably not what the interviewer was looking for.
21:06:09 <grom> Enigmagic: so my best beat is to make a module and load it into ghci then I guess?
21:07:06 <shachaf> Or to upgrade GHC. :-)
21:11:35 <grom> yeah.. I don't see no deb package to upgrade.. and I really don't like the idea of compiling it myself at this stage
21:18:35 <mizu_no_oto> Would using memocombinators cause (using listCalculatedFromMemoizedFunc (parList rdeepseq)) to not run in parallel?  I compiled with ghc --make -with-rtsopts="-N7", but it's only using a single CPU
21:20:16 <kallisti> mizu_no_oto: try compiling with -threaded
21:21:30 <mizu_no_oto> nope, still a single CPU
21:27:29 <crdueck> anyone? whats the reccomended way to get sane haskell indentation in vim? is this not an appropriate question for this channel?
21:28:56 <shachaf> crdueck: The default works pretty well for me.
21:29:09 <shachaf> set smarttab expandtab autoident sw=4
21:29:36 <liyang> ah, but if you want textbook Haskell indentation that won't do.
21:29:47 <liyang> But please don't use textbook Haskell indentation.
21:29:48 <shachaf> Which textbook?
21:30:07 <liyang> Any textbook. Variable hanging indents.
21:31:32 <jfischoff> dmwit: you there?
21:32:21 <liyang> crdueck: FYI, if you haven't come across it already: https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
21:37:48 <Axman6> hmm, anyone know of a library that provides faster lookup of Word8 values than something like Data.HashMap
21:38:11 <Axman6> at the moment I have a HashMap Word8 Foo, and I'm wondering if there might be something faster
21:38:27 <jfischoff> that would be cool
21:38:29 <Axman6> could use an Array actually
21:38:37 <liyang> Sure, a 256-element Vector.
21:38:47 <jfischoff> different interface
21:39:03 <Axman6> jfischoff: that's ok for what I want
21:39:25 <jfischoff> yeah
21:42:31 <guest_> does anyone know what version of cabal Hackage is running?
21:42:53 <OMGTallMonster> Axman6: Did you see my comment before you left?
21:45:23 <OMGTallMonster> I'm still pretty sure your algorithm has flaws.
21:50:01 <Axman6> OMGTallMonster: which comment?
21:50:30 <lamefun2> @undo { a <- getLine ; b <- getLine ; putStrLn a ++ b }
21:50:30 <lambdabot>  Parse error at "{" (column 1)
21:50:35 <OMGTallMonster> Your algorithm is O(len*hlen), I think.
21:50:55 <lamefun2> @undo { x <- foo ; x <- foo ; bar x y }
21:50:56 <lambdabot>  Parse error at "{" (column 1)
21:52:11 <lamefun2> !help undo
21:53:05 <Axman6> @undo do { x <- foo ; x <- foo ; bar x y }
21:53:05 <lambdabot> foo >>= \ x -> foo >>= \ x -> bar x y
21:53:13 <OMGTallMonster> Because "aaaaaaaaab" `stringSearch` replicate 100 'a' has to perform isPrefixOf for every character of the haystack (minus the last 11).
21:53:20 <lamefun2> @undo do { x <- foo ; y <- foo ; bar x y }
21:53:21 <lambdabot> foo >>= \ x -> foo >>= \ y -> bar x y
21:54:03 <Axman6> OMGTallMonster: yeah, it does have some pathelogical cases. seems to be quite a bit slower than findSubstring in Data.ByteString anyway (which I think uses B-M)
21:54:16 <OMGTallMonster> B-M?
21:54:23 <Axman6> Boyer-Moore
21:55:05 <OMGTallMonster> I see.
21:55:22 * Axman6 makes mine parallel for funsies
21:57:27 <Axman6> @index parMap
21:57:27 <lambdabot> Control.Parallel.Strategies
21:57:56 <Axman6> huh, why don't I have parallel installed...
21:58:22 <hpaste> lamefun pasted “Where does X go?” at http://hpaste.org/68312
21:59:12 <lamefun2> or rather
21:59:38 <lamefun2> how does X go into the third function?
22:00:13 <lamefun2> the third function has only Y argument?
22:02:06 <mm_freak> lamefun2: please remember that haskell is case-sensitive
22:02:18 <mm_freak> X is not a variable, but you are referring to a variable in your code
22:03:02 <jfischoff> has anyone worked with unification-fd? My question is..what is it for?
22:03:04 <hpaste> Enigmagic annotated “Where does X go?” with “Where does X go? (annotation)” at http://hpaste.org/68312#a68313
22:03:25 <lamefun2> Enigmagic: I'm trying to understand what's behind do
22:03:27 <mm_freak> then consider that (>>=) is associative:  a >>= \x -> b >>= \y -> c = a >>= (\x -> b >>= (\y -> c))
22:03:31 <Enigmagic> lamefun2: those two functions are equivalent, perhaps the edited version will make the scoping more obvious
22:03:55 <mm_freak> a >>= (\x -> …)
22:04:02 <mm_freak> so the x is in scope for …
22:04:14 <mm_freak> b >>= (\y -> …)
22:04:18 <mm_freak> y is in scope for …
22:04:39 <mm_freak> a >>= (\x -> b >>= (\y -> …))
22:04:50 <mm_freak> x is in scope for "b >>= (\y -> …)"
22:04:56 <mm_freak> and y is in scope for "."
22:04:57 <mm_freak> "…"
22:07:10 <crdueck> i'm just starting RWH, could someone please tell me why ghc finds a parse error in this code: http://sprunge.us/FcOC
22:07:17 <scooty-puff> jfischoff, i am planning on it (not quite the same) - i plan on using it for type inference
22:07:37 <mm_freak> crdueck: lastButOne x:xs
22:07:44 <mm_freak> that's parsed as (lastButOne x) : xs
22:07:59 <mm_freak> function application has the highest operator priority
22:08:51 <crdueck> mm_freak: okay, i thought i'd seen something like that before. I must have remembered incorrectly.
22:09:02 <jfischoff> scooty-puff: Great. So what does it make easier?
22:09:04 <mm_freak> crdueck: very likely you did
22:09:12 <mm_freak> just with an additional pair of parentheses
22:09:18 <mm_freak> lastButOne (x:xs)
22:11:39 <mm_freak> the pattern "lastButOne x : xs" would be allowed if you were defining a function called ':' and it would be equivalent to the pattern "(:) (lastButOne x) xs"…  of course that's invalid, because ":" is not a valid function name and lastButOne is not a constructor
22:11:46 <mm_freak> x +++ 0 = x
22:11:55 <mm_freak> x +++ y = succ x +++ pred y
22:12:00 <mm_freak> that's allowed
22:16:45 <crdueck> mm_freak: one more question, my function works find if i type it into ghci, but if i try to load it i get a complaint "arising from a use of ==". Could you please explain this?
22:16:53 <crdueck> s/find/fine
22:17:57 <Jed_84> hi everyone
22:18:55 <mm_freak> crdueck: could you please paste the entire error message?
22:19:38 <Jed_84> I need to sort a list of integers without using higher order functions
22:19:44 <Jed_84> what's the absolutely easiest way to do this in haskell?
22:19:47 <Jed_84> performance is not a problem
22:19:52 <mm_freak> Jed_84: 'sort'
22:20:00 <mm_freak> > sort [5,4,1,3,2]
22:20:01 <lambdabot>   [1,2,3,4,5]
22:20:11 <crdueck> lastbutone.hs:2:32:
22:20:11 <crdueck>     No instance for (Eq a)
22:20:11 <crdueck>       arising from a use of `=='
22:20:11 <crdueck>     In the expression: tail xs == []
22:20:11 <crdueck>     In the expression: if tail xs == [] then x else lastButOne xs
22:20:13 <crdueck>     In an equation for `lastButOne':
22:20:16 <crdueck>         lastButOne (x : xs) = if tail xs == [] then x else lastButOne xs
22:23:20 <Enigmagic> vlc
22:23:26 <Enigmagic> gah
22:27:14 <dmwit> jfischoff: I'll be traveling for the next week or so, with limited connectivity (sorry).
22:28:39 <jfischoff> no worries. I have some small changes, but I am struggling to understand the whole system right now. What are we going to explicitly write?
22:29:04 <jfischoff> somethings might be able to be infered
22:29:18 <jfischoff> also unification-fd is all new to me
22:29:48 <jfischoff> I'd love a tutorial explanation if there is one
22:30:57 <dmwit> let's see
22:31:18 <dmwit> unification-fd is all new to me, too (as of... a week ago?)
22:31:20 <mm_freak> crdueck: did you write a type signature for your function?
22:31:35 <dmwit> I'm not sure what tutorial to give, though maybe a tutorial on unification in general would be a good start (which is not new to me).e
22:31:50 <crdueck> mm_freak: yes "lastButOne :: [a] -> a"
22:32:02 <dmwit> http://en.wikipedia.org/wiki/Unification_(computer_science) might be a good place to look
22:32:21 <dmwit> You actually should have a pretty good intuition of how this stuff works already just by intuiting how Haskell's type system works.
22:32:44 <dmwit> If you have a function of type "a -> a" and a value of type "[b]", you can sort of intuit that you're actually using the function at type "[b] -> [b]".
22:32:58 <dmwit> Turning the intuition into something mechanical that computers can do is called "unification".
22:33:12 * hackagebot sbv 1.4 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  http://hackage.haskell.org/package/sbv-1.4 (LeventErkok)
22:33:16 <dmwit> The way it works is by trying to find some assignments of the variables "a" and "b" that make some things equal.
22:33:43 <dmwit> In particular, you're trying to make "a -> a" and "[b] -> c" equal.
22:33:58 <dmwit> The way you do it (sort of) is by looking at the top constructor; here, that's "->".
22:34:29 <dmwit> Since the top constructor for both already match, you can recurse deeper and try to equate "a" and "[b]" (the first arguments to the constructor) and "a" and "c" (the second arguments to the constructor).
22:34:55 <dmwit> The "zipMatch" function I've written in the code is doing this process of matching top constructors; unification-fd is doing the rest of the work to apply things recursively.
22:34:55 <mm_freak> crdueck: that's not enough
22:35:12 <mm_freak> crdueck: the type is (Eq a) => [a] -> a
22:35:22 <dmwit> As for what we're explicitly going to write, well, that's up in the air a bit, I guess.
22:35:27 <mm_freak> because (==) must be allowed for values of type 'a'
22:35:55 <crdueck> mm_freak: okay, i dont understand that yet. i guess that means keep reading.
22:36:07 <dmwit> In my head I'm imagining that there's still a parser for untyped terms and a little type inference engine (again using unification-fd) to turn the untyped terms into typed terms (or maybe just to sanity check them without annotating them with types).
22:36:17 <mm_freak> crdueck: yes =)
22:36:26 <dmwit> But you have a say in what our goal is, too. =)
22:36:38 <jfischoff> very cool
22:36:55 <jfischoff> Just finished reading everything and this is new stuff for me
22:37:11 <jfischoff> I have a few thoughts.
22:38:36 <jfischoff> First I am a little confused about the relationship between and are Type, Values, Terms and UTerms. Lets start with Term and UTerm. What's going on there?
22:39:20 <jfischoff> Also at what will the top level parser return. Terms?
22:40:22 <dmwit> oh, UTerm is a lousy name
22:40:24 <dmwit> sorry about that
22:40:34 <dmwit> I don't think we use Type at all currently.
22:40:49 <dmwit> But if we did use it, a Value would have a Type, and a Term would have two Types (a domain and a codomain).
22:40:51 <jfischoff> yes ...
22:41:06 <dmwit> A UTerm is a Value, except something we only have partial information about.
22:41:21 <dmwit> For example, we might know it's a Left (Left (....something....))
22:41:31 <jfischoff> interesting
22:42:13 <Jed_84> I need to sort a list of strings using a custom defined "isGreaterThan" function, without using higher order functions
22:42:21 <dmwit> + some equations off to the side that may involve the something that nails it down more (or maybe not)
22:42:23 <Jed_84> any pointers on how to approach this problem?
22:42:37 <jfischoff> so I should be parsing values or terms?
22:42:50 <dmwit> terms looks more useful to begin with
22:43:13 * hackagebot certificate 1.2.2 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-1.2.2 (VincentHanquez)
22:43:24 <jfischoff> cool
22:44:00 <dmwit> Oh, I did call it UValue. Good.
22:44:05 <dmwit> (The U is for unification.)
22:45:21 <dmwit> I think actually Value basically isn't a useful type for us.
22:45:26 <dmwit> But I'm not 100% sure of that.
22:45:37 <mm_freak> Jed_84: it's kinda stupid not to use a higher order function there
22:45:42 <dmwit> Okay, I'm heading to bed now.
22:45:48 <jfischoff> dmwit: hehe. Well I really don't know
22:45:53 <mm_freak> > sortBy (flip compare) [1..5]
22:45:54 <lambdabot>   [5,4,3,2,1]
22:46:02 <dmwit> Leave me questions here, in PM, with lambdabot, whatever, and I'll try to answer them. =)
22:46:06 <jfischoff> dmwit: good night man!
22:46:35 <mm_freak> Jed_84: the only valid reason not to use sortBy is when this is homework and you're forbidden to use the predefined sortBy
22:46:49 <Jed_84> mm_freak, i know, but it's a stupid assignment from my programming course
22:47:07 <Jed_84> and they won't let us use higher order functions
22:47:11 <path[l]> haha
22:47:14 <Jed_84> i guess i'll end up implementing a bubble sort by hand
22:47:25 <mm_freak> Jed_84: are you allowed to /write/ a higher order function?
22:47:28 <Jed_84> nope
22:47:39 <Jed_84> it sucks
22:47:54 <Jed_84> i mean it takes out all the fun of coding haskell
22:47:56 <Jed_84> but whatever
22:47:57 <mm_freak> Jed_84: every function of type A -> B -> C is a higher order function
22:48:03 <mm_freak> so your assignment probably can't be solved
22:48:30 <mm_freak> your comparison operator certainly wants two arguments, so it's higher order
22:48:43 <mm_freak> background:  (->) is right-associative
22:48:50 <mm_freak> so A -> B -> C = A -> (B -> C)
22:48:51 <Jed_84> we can't use currying, pass functions as parameters or return functions
22:49:11 <mm_freak> hmm…  i wonder if they really want to teach haskell =)
22:49:12 <mm_freak> anyway
22:49:21 <mm_freak> just reimplement the merge sort algorithm
22:49:24 <Jed_84> they want to teach us to learn how to think in terms of expressions rather than instructions
22:49:31 <Jed_84> and to learn how to use recursion
22:49:31 <mm_freak> lol?!
22:49:38 <Jed_84> yep
22:49:41 <Jed_84> it's a beginners course
22:49:47 <mm_freak> higher order functions are /the/ way to think in terms of expressions
22:49:54 <Jed_84> like, there's people in this course who've never written a single line of code in their lives
22:50:12 <Jed_84> i agree with you but that's how this stupid course is
22:50:33 <mm_freak> ok, well, again:  go with a self-implemented mergesort
22:50:43 <mm_freak> that's probably the number one sorting algorithm for lists
22:51:37 <Jed_84> mm_freak, i was thinking of implementing bubble sort
22:51:42 <Jed_84> wouldn't it be easier?
22:51:47 <mm_freak> Jed_84: and make sure you have only a single function arrow in your type signatures…  if you see two arrows anywhere you have a higher order function
22:51:54 <Jed_84> i forgot to mention, we can't use list comprehension either
22:52:49 <Jed_84> mm_freak, we can use functions "taking multiple parameters" as long as those are values and not functions
22:53:27 <mm_freak> Jed_84: then you have to use tuples…  and i'd implement mergesort
22:53:41 <mm_freak> bubblesort feels wrong on lists
22:55:36 <mm_freak> Jed_84: i really hope that your teacher is aware of the right-associativity of (->)…  but if currying is specifically forbidden he probably is
22:59:56 <Jed_84> mm_freak, yes, he's aware of that
23:21:34 <dibblego> !seen roconnor
23:44:44 <akosch> i'm using the quasiquoting example from http://www.haskell.org/haskellwiki/Poor_man%27s_here_document
23:45:10 <akosch> how can I get rid of the warning, that I'm not initializing all the fields of QuasiQuoter
23:46:21 <yitz> akosch: initialize them?
23:46:25 <shachaf> akosch: Presumably by initializing all the fields of QuasiQuoter?
23:46:47 <akosch> with what? I don't know much about quasiquoting
23:47:12 <shachaf> There are modules on Hackage that do this, by the way.
23:47:39 <shachaf> Presumably you'd look up the documentation for QuasiQuoter, though, and figure out what should go in them, and then put that in them.
23:48:50 <shachaf> It might be that you'll just need to fill them with _|_ anyway.
23:49:36 <akosch> shachaf: documentation is a bit scarce on this, but I can figure it out I guess
23:49:48 <shachaf> http://hackage.haskell.org/packages/archive/string-quote/0.0.1/doc/html/src/Data-String-Quote.html
23:49:49 <akosch> shachaf: what modules on hackage do this btw?
23:49:57 <shachaf> http://hackage.haskell.org/packages/archive/string-qq/0.0.2/doc/html/src/Data-String-QQ.html
23:49:59 <rwbarton> the other fields are for what the quasiquoter should expand to in a pattern context, and in some more contexts now i guess
23:50:01 <shachaf> A bunch of them.
23:50:15 <rwbarton> maybe declaration context
23:50:40 <akosch> I see, thanks everyone!
23:50:42 <shachaf> Being able to figure this out quickly is much more valuable than having a working string quasiquoter, though. :-)
23:51:10 <osa1__> is there a way to import a package qualified but also hiding some names? I'm using bot ParserCombinators.Parsec and Text.Parsec under the name P  but there are still ambiguous occurences
23:51:13 <shachaf> TH ought to have more documentation.
23:51:52 <shachaf> osa1__: import qualified Blah as P hiding (...)?
23:51:59 <shachaf> Hmm, I just found a ghci bug.
23:52:16 <osa1__> shachaf: doesn't work
23:52:23 <yitz> akosch: here are the docs for QuasiQuoter: http://hackage.haskell.org/packages/archive/template-haskell/2.7.0.0/doc/html/Language-Haskell-TH-Quote.html
23:52:49 <shachaf> yitz: Those, uh, don't actually say what those fields are.
23:53:01 <akosch> yitz: thanks, I found this myself. Just had no idea what those fields are
23:53:18 <yitz> akosch: so we see there that the other constructors are quotePat, quoteType, and quoteDec. just set each of those to undefined.
23:53:51 <shachaf> Get rid of _|_s by specifying _|_s!
23:54:04 <shachaf> (That's a good thing, of course. At least you're honest about being dishonest.)
23:54:32 <shachaf> But use an informative error instead of undefined at least. :-(
23:54:44 <yitz> akosch: you can use a quasi-quoter also for pattern matching, for generating type expressions, and for generating type declarations. that's what those do.
23:55:12 <akosch> any example code I might look at for understanding this better?
23:55:54 <yitz> shachaf: since these get run only at compile time, it could be undefined is good enough. i think ghc generates an informative compile-time error from that automatically.
23:56:14 <shachaf> Hmm.
23:56:20 <shachaf> Anyway I found a ghci bug.
23:56:31 <shachaf> $ ghci
23:56:39 <shachaf> λ> import qualified Data.List as L hiding (hi)
23:56:41 <shachaf> λ> import qualified Data.List as L hiding (foldr)
23:57:51 <yitz> shachaf: there were known bugs in the earlier versions of ghci import statement support. do you have a very recent ghc?
23:57:59 <shachaf> Oh.
23:58:04 <shachaf> No, it's just 7.4.x
23:59:51 <yitz> shachaf: oh, well, i have HP, which is back at 7.0.4. so maybe that is indeed an new bug.
