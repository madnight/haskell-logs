00:46:42 <MagneticDuck> yo all. The duck is here. A little question: if I have a value of type "f a" and I have a function "a -> b" and want to get a value "f b", then if "f" is a functor I can use <$> or map, right? Just confirming...
00:47:10 <shachaf> MagneticDuck: "fmap", but yes.
00:47:18 <shachaf> "map" is sadly exclusive to lists.
00:47:24 <MagneticDuck> yeah
00:47:28 <MagneticDuck> typo
00:47:30 <MagneticDuck> thanks
00:48:37 <newsham> ?type fmap undefined
00:48:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> f b
00:49:28 <shachaf> ?type fmap ?function
00:49:29 <lambdabot> forall a b (f :: * -> *). (?function::a -> b, Functor f) => f a -> f b
00:50:01 <shachaf> That's a nicer way to look at what something really does. :_)
00:50:30 <arcatan> oh, that's nice
00:51:14 <shachaf> I demand that GHC support type-level ImplicitParams!
01:01:00 <kallisti_> so church-encoding is basically representing values of a data type as their catamorphisms, no?
01:01:39 <shachaf> Right.
01:01:49 <shachaf> You're also allowed to use the word "fold". :-)
01:02:03 <kallisti_> but catamorphism sounds so good.
01:03:01 <shachaf> Try to be impressive is better than trying to sound impressive. :-)
01:03:39 <kallisti_> that's not really the rationale behind the word-choice.
01:04:23 <MagneticDuck> just a style question-- should one write "map (\x -> ...) $ xs" or "(\x -> ...) <$> xs"?
01:04:34 <kallisti_> I usually see map
01:04:41 <kallisti_> specifically with lambdas
01:04:46 <MagneticDuck> but the second is shorter...
01:04:49 <MagneticDuck> :P
01:05:04 <kallisti_> you're free to notate it however you like.
01:05:44 <shachaf> MaskRay: Even shorter: map (\x -> ...) xs
01:05:53 <shachaf> s/skRay/gneticDuck/
01:06:01 <MagneticDuck> xD
01:06:16 <MagneticDuck> MaskRay. Sounds like a superhero.
01:06:22 <MaskRay> honored to be mentioned
01:06:32 <MagneticDuck> :D
01:06:51 <MaskRay> MagneticDuck: i'm a beginner
01:06:57 <shachaf> hi MaskRay
01:06:58 <shachaf> HaskRay
01:07:12 <MagneticDuck> RaskMay
01:07:17 <MagneticDuck> something like that
01:07:32 <MagneticDuck> yes I understand
01:07:49 <MagneticDuck> but can I still do that here: "blocks = (\xs -> (init xs, tail xs)) <$> split "" $ lines str"
01:07:56 <MaskRay> or [ .. | x <- ..]
01:08:07 <MagneticDuck> ouch my eyes
01:08:26 <shachaf> MagneticDuck; Can't you replace <$> with . there?
01:08:36 <MagneticDuck> ah true
01:08:47 <MagneticDuck> haskell style is still not natural to me...
01:09:12 <MagneticDuck> I tend to overuse $
01:09:19 <shachaf> (init &&& tail) . split "" . lines $ str
01:09:34 <MagneticDuck> @type &&&
01:09:35 <lambdabot> parse error on input `&&&'
01:09:44 <newsham> ?type (&&&)
01:09:45 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
01:09:45 <MagneticDuck> @type (&&&)
01:09:46 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
01:10:13 <shachaf> (&&&) :: (a -> b) -> (a -> c) -> a -> (b, c)
01:10:33 <MagneticDuck> hm
01:10:44 <MagneticDuck> how do I pronounce that?
01:10:54 <newsham> > ((+1) &&& (*5)) 5
01:10:56 <lambdabot>   (6,25)
01:11:09 <MagneticDuck> I just say "and" three times fast?
01:11:16 <MagneticDuck> andandand
01:12:46 <kallisti_> I believe the docs call it "fanout"
01:12:46 <MagneticDuck> no really how do I pronounce that
01:12:53 <MagneticDuck> grr IRC timings
01:12:54 <MagneticDuck> ty
01:15:51 <newsham> is there a name for ((==) `on` f) ?
01:16:01 <jonaskoelker> comparing f
01:16:10 <newsham> ?src comparing
01:16:11 <lambdabot> Source not found. You type like i drive.
01:16:11 <jonaskoelker> :t comparing
01:16:12 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
01:16:25 <jonaskoelker> oh wait, no, wrong
01:16:33 <jonaskoelker> pretend I know what I'm talking about :D
01:16:55 <newsham> ?type \f -> ((==) `on` f)
01:16:56 <lambdabot> forall b a. (Eq b) => (a -> b) -> a -> a -> Bool
01:17:04 <newsham> ?hoogle (Eq b) => (a -> b) -> a -> a -> Bool
01:17:05 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
01:17:05 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
01:17:05 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
01:17:30 <jonaskoelker> ?hoogle Ordering -> Bool
01:17:31 <lambdabot> Data.Generics.Twins geq :: Data a => a -> a -> Bool
01:17:31 <lambdabot> Network.BufferType buf_isEmpty :: BufferOp a -> a -> Bool
01:17:31 <lambdabot> Network.BufferType buf_isLineTerm :: BufferOp a -> a -> Bool
01:17:47 <jonaskoelker> :t (== EQ)
01:17:48 <lambdabot> Ordering -> Bool
01:18:10 <jonaskoelker> :t ((== EQ) . comparing ?f)
01:18:11 <lambdabot>     Couldn't match expected type `Ordering'
01:18:11 <lambdabot>            against inferred type `b -> Ordering'
01:18:11 <lambdabot>     Probable cause: `comparing' is applied to too few arguments
01:18:18 <jonaskoelker> :t ((== EQ) . comparing f)
01:18:19 <lambdabot>     Couldn't match expected type `Ordering'
01:18:19 <lambdabot>            against inferred type `b -> Ordering'
01:18:19 <lambdabot>     Probable cause: `comparing' is applied to too few arguments
01:18:25 <jonaskoelker> -.-
01:18:29 * jonaskoelker fails
01:19:08 <newsham> :t (\f a b -> comparing f a b == EQ)
01:19:10 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Bool
01:21:03 <jonaskoelker> does anyone know what kind of error `error' throws?  How do I catch it with `handle'?
01:21:38 <shachaf> @ty ((==) `on`)
01:21:39 <lambdabot> forall b a. (Eq b) => (a -> b) -> a -> a -> Bool
01:24:50 <Enigmagic> jonaskoelker: ErrorCall
01:25:16 <Enigmagic> > handle (\ (SomeException e) -> print (typeOf e)) (error "foo")
01:25:17 <lambdabot>   Not in scope: data constructor `SomeException'
01:25:28 <Enigmagic> no IO but there ya go :P
01:26:03 <jonaskoelker> Enigmagic: neat trick, thanks :)
01:26:40 <jonaskoelker> is that the idiomatic haskelly way to handle it-didn't-read errors, btw?  (with handle)
01:26:52 <jonaskoelker> (or, I guess quasiequivalently, try/catch)
01:27:16 <Enigmagic> i usually use catch
01:27:48 <jonaskoelker> but they're equivalent under the hood, yes?
01:27:54 <Enigmagic> yeah
01:28:24 <Enigmagic> i think catch = flip handle
01:28:37 <jonaskoelker> :t catch
01:28:38 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
01:28:39 <jonaskoelker> :t handle
01:28:40 <lambdabot> forall (a :: * -> * -> *) e b ex. (ArrowError ex a) => a e b -> a (e, ex) b -> a e b
01:28:58 <jonaskoelker> :t Control.Exception.handle
01:28:59 <lambdabot> forall e a. (GHC.Exception.Exception e) => (e -> IO a) -> IO a -> IO a
01:29:08 <burbul> Is there a difference in speed between mapM and mapM_, or is the latter just present for stylistic reasons?
01:29:38 <Enigmagic> burbul: mapM will build a thunk chain of [()]
01:30:26 <burbul> Sorry, don't really know what a thunk is (other than that it's not completely evaluated)
01:30:59 <newsham> handle (\e -> putStrLn $ "oops, got: " ++ show (e :: ErrorCall)) (print (error "foo"))
01:31:02 <newsham> oops, got: foo
01:31:05 <Enigmagic> burbul: mapM returns a value (typically a thunk) for each element you are mapping over, mapM_ does not
01:31:10 <burbul> As far as I can see calling mapM and ignoring the result is the same as
01:31:22 <burbul> Calling mapM_
01:31:49 <Enigmagic> try it on a really large list ;)
01:32:15 <burbul> ok, so it is speed? they are referentially equal to each other, right?
01:32:23 <burbul> Thanks
01:32:30 <Enigmagic> yes they are equal
01:33:11 <burbul> (I need to write an analogue for a tree datatype, and I'm not so concerned about speed yet, but I wanted to make sure there weren't two concepts there that I was failing to distinguish)
01:33:29 <burbul> (As well as checking the style point)
01:33:50 <newsham> ?src mapM
01:33:51 <lambdabot> mapM f as = sequence (map f as)
01:33:53 <newsham> ?src mapM_
01:33:54 <lambdabot> mapM_ f as = sequence_ (map f as)
01:34:33 <Enigmagic> > mapM_ (\ _ -> return ()) [1..1000000]
01:34:34 <lambdabot>   No instance for (GHC.Show.Show (m ()))
01:34:34 <lambdabot>    arising from a use of `M899293190...
01:34:46 <newsham> burbul: is your tree foldable?
01:34:46 <Enigmagic> > runIdentity $ mapM_ (\ _ -> return ()) [1..1000000]
01:34:47 <lambdabot>   ()
01:34:52 <Enigmagic> > runIdentity $ mapM (\ _ -> return ()) [1..1000000]
01:34:53 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
01:35:01 <b_jonas> yeah, maybe check them out in the typeclassopedia for foldable
01:35:20 <Enigmagic> does lambdabot have a strict monad?
01:36:27 <shawng> hello all. Just wanted to say you guys have my highest respect. I'm going to finish SICP this summer. I'll check in in the Winter or fall
01:37:04 <shawng> allez en avant, la foi vous viendra
01:37:26 <Enigmagic> :t runST
01:37:27 <lambdabot> forall a. (forall s. ST s a) -> a
01:37:36 <b_jonas> a strict what monad?
01:37:36 <Enigmagic> > runST $ mapM (\ _ -> return ()) [1..1000000]
01:37:37 <newsham> ?type Data.Foldable.mapM_
01:37:38 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Foldable.Foldable t, Monad m) => (a -> m b) -> t a -> m ()
01:37:39 <lambdabot>   *Exception: stack overflow
01:37:47 <Enigmagic> > runST $ mapM_ (\ _ -> return ()) [1..1000000]
01:37:49 <lambdabot>   ()
01:37:54 <Enigmagic> there ya go
01:38:01 <burbul> yup! thanks.
01:38:14 <b_jonas> wow
01:38:36 <b_jonas> though wait
01:38:43 <burbul> although part of the reason why was wondering why one bothered with mapM_ was that it seemed like in a lazy language
01:39:01 <b_jonas> > runST $ (mapM (\ _ -> return ()) [1..1000000] >> return ())
01:39:05 <lambdabot>   *Exception: stack overflow
01:39:11 <burbul> if you didn't evaluate the result, Haskell wouldn't do the work to compute it.
01:39:12 <b_jonas> hmm, that way too
01:39:42 <b_jonas> ah, is this like the Writer trick?
01:39:50 <newsham> burbul: but i think the IO will cause the chain of thunks to be built up?
01:40:03 <b_jonas> you don't evaluate either the side effects or the result so the computation isn't ran
01:40:06 <newsham> (ie. when using the IO monad)
01:40:13 <burbul> ok -- I can believe it. (I don't have my head around thunks.)
01:40:33 <newsham> could use the profiler to verify
01:40:45 <newsham> run with mapM_ and mapM on large data and look at heap stats
01:44:28 <fredmorcos> I am looking for a music player that isn't bloated but supports DAAP sharing
01:44:41 <fredmorcos> rhythmbox is extremely slow in loading/reloading my library
01:44:58 <burbul> newsham: I believe it! I just don't have the mental model needed to understand it yet.
01:45:00 <fredmorcos> qt/gtk-only players are ok
01:45:09 <fredmorcos> preferably no kde deps
01:45:11 <fredmorcos> any ideas?
01:46:24 <newsham> burbul: i think it might be true, but i'm not convinced :)
01:47:14 <Enigmagic> @src sequence
01:47:14 <lambdabot> sequence []     = return []
01:47:14 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
01:47:14 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
01:49:05 <Enigmagic> if the Monad instance isn't lazy in bind then it's going to use some stack space each time an element is evaluted
01:52:12 <fredmorcos> oh my...
01:52:19 <fredmorcos> ^^ wrong channel
01:52:49 <fredmorcos> apologies
01:56:42 <burbul> Is there a way to set up the type signature of a function before using @pl ?
01:57:02 <Botje> @pl doesn't look at types
01:57:03 <lambdabot> doesn't look at types
01:57:11 <Botje> durr. that
01:57:12 <Botje> .
01:57:17 <burbul> :)
01:57:22 <MaskRay> Enigmagic: how does laziness eliminate stack space usage?
01:57:34 <burbul> @pl mapExpM f (ApplyFn fn args) = (liftM (ApplyFn fn) $ mapM (mapExpM f) args) >>= f
01:57:34 <lambdabot> (line 1, column 29):
01:57:34 <lambdabot> unexpected "="
01:57:34 <lambdabot> expecting variable, "(", operator or end of input
01:57:50 <Enigmagic> MaskRay: go compare Control.Monad.State.Lazy and .Strict
01:57:54 <burbul> @undo mapExpM f (ApplyFn fn args) = (liftM (ApplyFn fn) $ mapM (mapExpM f) args) >>= f
01:57:54 <lambdabot> mapExpM f (ApplyFn fn args) = (liftM (ApplyFn fn) $ mapM (mapExpM f) args) >>= f
01:58:27 <jonaskoelker> fredmorcos: happens to the best of us :-)
01:58:28 <newsham> so there's a generic mapM_ for all foldables, and there's a generic fmap for all functors.    but there's no generic mapM for a bunch of data structs, is there?
01:58:28 <burbul> @pl (liftM (ApplyFn fn) $ mapM (mapExpM f) args) >>= f
01:58:29 <lambdabot> f =<< fmap (ApplyFn fn) (mapM (mapExpM f) args)
01:58:46 <Enigmagic> MaskRay: the difference allows a list (like [()]) to be generated element at a time instead of building the full list first
01:58:47 <burbul> newsham: mapM there is being applied on a list, and
01:59:15 <burbul> mapExpM on a datatype I have defined; (ApplyFn _ _) is an instance of that datatype
01:59:21 <newsham> burbul: unrelated to your code above
01:59:28 <burbul> mapExpM :: Monad m => (RuleExp -> m RuleExp) -> RuleExp -> m RuleExp
01:59:33 <burbul> ah, sorry
02:00:56 <newsham> why no fmapM?
02:01:52 <burbul> @pl f =<< liftM g
02:01:52 <lambdabot> f =<< fmap g
02:03:07 <burbul> When I asked the question about making @pl pay attention to type signatures, it was because I have trouble making sense of things like this...
02:03:17 <burbul> @type f =<< liftM g
02:03:18 <lambdabot> forall b a1 r (m :: * -> *). (Show (m r), Show (m a1), SimpleReflect.FromExpr b, Show a1, SimpleReflect.FromExpr r, Monad m) => m a1 -> b
02:03:35 <burbul> I can't make head or tail of that...
02:03:54 <newsham> ?pl \f g -> f =<< fmap g
02:03:55 <lambdabot> (. fmap) . (=<<)
02:05:12 <burbul> @pl (f . g) =<<
02:05:12 <lambdabot> (line 1, column 12):
02:05:13 <lambdabot> unexpected end of input
02:05:13 <lambdabot> expecting white space or simple term
02:05:23 <burbul> @pl ((f . g) =<<)
02:05:23 <lambdabot> (f . g =<<)
02:30:54 <burbul> @djinn Monad m => (a -> m b) -> Maybe a -> m (Maybe b)
02:30:55 <lambdabot> -- f cannot be realized.
02:32:41 <burbul> How does one type a multi-clause function into lambdabot?
02:35:55 <paolino> Hello, I noticed that the writer monad on a lazy monoid like [] let me unroll the monadic computation by evaluating the monoid, is this always the case for WriterT [] m what ever is m ?
02:36:55 <solarus> > let f 0 = 0; f n = f (n-1) in f 100 -- burbul: like this?
02:36:56 <lambdabot>   0
02:38:06 <burbul> thanks!
02:42:23 <burbul> @pl let x f Nothing = return Nothing; x f (Just v) = liftM Just (f v) in x
02:42:24 <lambdabot> (line 1, column 45):
02:42:24 <lambdabot> unexpected "v"
02:42:24 <lambdabot> expecting operator or ")"
02:43:12 <burbul> :(
02:43:50 <bitonic> burbul: pl does not understand patterns, except tuples
02:44:09 <burbul> ah. thanks.
02:44:36 <burbul> Is that why djinn screwed up as well? (because it didn't understand Maybe)
02:44:47 <bitonic> burbul: djinn does understand patterns, iirc
02:45:01 <burbul> The function I just wrote down has the type signature I sent in to djinn
02:45:08 <burbul> But it said 'f cannot be realised'
02:45:47 <bitonic> mah, maybe I'm wrong. it surely understands tuples, but that might be a special case like in pl
02:46:25 <paolino> I ask the real question: if I lift the (a -> m a) argument of a naive iterateM in the WriterT [] and tell the result , is it correct that I can always run the computation lazily by evaluating the monoid of results ?
02:47:01 <Botje> :t \f ma -> maybe (return Nothing) (return . Just) (fmap f ma)
02:47:02 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> a) -> Maybe a1 -> m (Maybe a)
02:48:03 <burbul> That's definitely nicer than what I had
02:48:23 <burbul> @pl   \f ma -> maybe (return Nothing) (return . Just) (fmap f ma)
02:48:23 <lambdabot> (maybe (return Nothing) (return . Just) .) . fmap
02:48:51 <burbul> I feel like there should be a way of writing without having to mention the Nothing and Just
02:49:01 <paolino> :t fmap id
02:49:02 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f a
02:49:21 <paolino> :t (fmap id .) . fmap
02:49:22 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1 -> a) -> f a1 -> f a
02:50:07 <paolino> :t (fmap return .) . fmap
02:50:08 <lambdabot> forall a (m :: * -> *) (f :: * -> *) a1. (Monad m, Functor f) => (a1 -> a) -> f a1 -> f (m a)
02:50:20 <paolino> mh, not really
02:50:52 <burbul> weird.
02:52:00 <burbul> But thanks for trying.
02:52:21 <paolino> :t (return .) . fmap
02:52:22 <lambdabot> forall (m :: * -> *) a b (f :: * -> *). (Monad m, Functor f) => (a -> b) -> f a -> m (f b)
03:18:29 <XcvX> What would be an application area where Haskell would shine?
03:20:38 <paolino> description
03:22:21 <Philippa> anything where you've got a lot of stuff going on that smells a bit like 70s mainframe work, anything where you're dealing with something that smells a bit like a language (including non-trivial GUIs) if you're willing to do a bit of binding work...
03:23:22 <Philippa> back end web stuff'd be a good example
03:23:52 <Philippa> (and yes, it's good at writing interpreters and compilers - but consider that eg the innards of something like Photoshop involve something like that too? Version control-like things are cheap in Haskell)
03:23:59 <Guest33101> hi everyone, I am new to haskell. When I test a code with ghc -fllvm, I get an error of 'opt: Bitcode stream should be a multiple of 4 bytes in length'. What does that mean?
03:36:59 <burbul> How do I decide whether to use the State monad or the ST monad for an application?
03:38:42 <earthy> burbul: ST is State on Acid
03:38:55 <burbul> ok...
03:39:02 <earthy> see e.g. http://stackoverflow.com/questions/5545517/difference-between-state-st-ioref-and-mvar
03:39:23 <burbul> Yes, I was just reading that, but still wasn't sure which to use.
03:39:47 <burbul> The application I have is that I need to rename all the variables in expression a to avoid clashes with variables in expression b
03:40:11 <burbul> Every time I rename a variable in a, I'm going to have to update the list of 'disallowed names'
03:40:33 <burbul> So I was thinking of using something like     State (Set String)
03:40:40 <burbul> To keep track of the list of disallowed names...
03:40:51 <MagneticDuck> hey there. I'm trying to make a very simple irc bot
03:40:55 <MagneticDuck> ...and having some problems
03:41:05 <absence> mm_freak_: keeping the input connected to the output becomes quite cumbersome in applicative style when using Reader. is it better to use arrow syntax than e.g. "check pred = (never ||| identity) . (arr . uncurry $ eitherPred . pred) . first readState . arr ((,) ())", or is there a better trick?
03:42:18 <MagneticDuck> so, I basically want to make a very simple irc bot; for now, I'd be happy if I could just have a input / output bot; someone says something, the bot either responds or says nothing
03:42:20 <MagneticDuck> that's all
03:42:51 <MagneticDuck> I was working with the tutorial "roll your own irc bot" that I was recommended to here
03:42:57 <MagneticDuck> but the code seems to have a few problems
03:44:43 <MagneticDuck> Of course I already wrote the pure core; defined a function String -> Maybe String and tested it offline. I also wanted to add a token to define whether or not the bot is "sleeping" that would just be passed in the program loop, and I accomplished that offline but on irc I'm stuck.
03:55:23 <arnsholt> I've some data serialized to a relatively simple line-based format. What's the recommended way to deserialize it into my program?
03:56:47 <MagneticDuck> I think I scared everyone again
03:56:48 <MagneticDuck> ._.
04:03:15 <burbul> arnsholt -- if it's in a string, you could use Parsec?
04:04:00 <MagneticDuck> any answers for my question? tutorials?
04:05:51 <MagneticDuck> well I have to go... if anyone has any answers they would be appreciated
04:07:43 <arnsholt> burbul: Yeah, I guess I could do that. A full-blown parser feels a bit weird though, since it's not terribly complicated
04:07:51 <MagneticDuck> just say them whenever and I'll see them afterwards
04:11:34 <absence> mm_freak_: sorry, that was me overcomplicating things. "check pred = arr snd . first (require . arr pred . readState) . arr ((,) ())" doesn't seem quite so bad ...
04:12:08 <MagneticDuck> ...so yeah just PM me if you guys recommend any tutorials..
04:12:39 <fmap> MagneticDuck: may be i don't understand you but common way to hide someone's state (token) is State
04:12:49 <dzhus> is there a random numbers library which implements only PRNG algorithm with pure interface?
04:12:55 <fmap> maybe StateT BotState IO in your specific case
04:13:11 <MagneticDuck> Yes
04:13:29 <MagneticDuck> what I wanted to know is if there's any really simple way to make a simple IO irc bot
04:13:56 <MagneticDuck> listens to input, and then either replies or does nothing for every line
04:14:10 <MagneticDuck> like if there are any packages that I might look into...
04:15:36 <absence> "toTuple = (,) ()" <- is there a better/library way to do that?
04:17:05 <fmap> MagneticDuck: I don't know what is simple, but IORefs could be another possibility to hide state.
04:17:39 <MagneticDuck> forget about the token; I have just never written a irc bot in my life
04:18:12 <MagneticDuck> any tutorials on how to make a painfully simple haskell bot?
04:18:41 <hpc> @google haskellwiki irc bot
04:18:43 <lambdabot> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
04:18:43 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
04:18:58 <hpc> ah, that's what it was called
04:19:01 <hpc> go through that
04:19:12 <MagneticDuck> hm okay
04:19:16 <hpc> and then throw it out and come up with a better way or organizing it :P
04:21:26 <MagneticDuck> unfortunately it seems that the code doesn't compile
04:21:27 <MagneticDuck> ._.
04:21:38 <MagneticDuck> I'm running ubuntu linux, latest ghci version
04:22:49 <MagneticDuck> well I have to go now
04:22:56 <MagneticDuck> bb
04:23:26 * MagneticDuck is away: Going for a walk. Back in a couple of hours. Coffee.
04:47:40 <Taneb> Is there some class so I can do something like fmap2 :: (a -> b) -> f a c -> f b c?
04:48:15 <shachaf> Taneb: Bifunctor?
04:48:17 <hpc> there's the arrow functions
04:48:17 <Peaker> Taneb: you can use the Flip newtype maybe
04:48:27 <shachaf> http://hackage.haskell.org/packages/archive/category-extras/0.44.4/doc/html/Control-Bifunctor.html
04:48:39 <Taneb> hMM
04:48:42 <Taneb> *Hmm
04:48:44 <shachaf> (category-extras is gone, but that.)
04:49:16 <Taneb> shachaf, I saw that, it's somewhere else now
04:49:22 <Taneb> Peaker, where's that defined?
04:49:25 <Peaker> Taneb: http://hackage.haskell.org/packages/archive/TypeCompose/0.9.1/doc/html/Control-Compose.html#g:9
04:53:24 <ferh332> hello, to all :)
04:53:30 <Taneb> Hello
04:53:47 <ferh332> may be someone done benchmark on repa package?
04:54:04 <ferh332> Data.Array.Repa
05:00:24 <hpaste> anonymous pasted “void” at http://hpaste.org/69091
05:01:43 <T_X> I'm really fascinated of the error handling possibilities via the Maybe/Either Monad. And I'm currently wondering whether it is possible to transform "parseTorrent :: String -> IO BEncode" into "parseTorrent :: String -> Maybe BEncode"
05:01:51 <T_X> or whether that does not make any sense at all
05:02:17 <T_X> (I read a couple of times in here, that you usually cannot / do not want to get rid of the IO context)
05:02:22 <shachaf> It makes no sense at all.
05:02:28 <T_X> :)
05:02:35 <shachaf> However, you can turn it into something that returns IO (Maybe a)
05:02:43 <shachaf> Or probably MaybeT IO a or something like that.
05:02:50 <shachaf> However, IO already has exceptions. :-)
05:03:44 <T_X> I initially had something like IO (Maybe BEncode), but replaced that with 'IO BEncode' as I thought I could just use the error context of the IO Monad already
05:04:36 <T_X> schachaf: hm, ok, thx, then I leave the code like that for now
05:05:55 <ClaudiusMaximus> you probably want a   parseTorrent :: ByteString -> Maybe BEncode  and a  readTorrent :: FilePath -> IO BEncode
05:08:42 <Peaker> T_X: what does parseTorrent do?
05:11:52 <T_X> Peaker: it takes a filename (:: String), opens and reads it, then calls bRead, a BEncode parser library. Also see http://hpaste.org/69091
05:13:03 <T_X> ClaudiusMaximus: ah, so changing the function which is calling 'parseTorrent'. hmm, good point, need to think about that
05:21:57 <ClaudiusMaximus> T_X: ah, so your parseTorrent is what i'd call readTorrent, and my parseTorrent is probably the bRead function
05:25:29 <Peaker> T_X: then separate the open/read part, and then a pure parser function
05:28:25 <T_X> ClaudiusMaximus: hm, I had called it parseTorrent as currently it is doing both, the file reading and file parsing. but yes, Peaker, ClaudiusMaximus, your suggestions sound good, this separating. so hiding the IO in the function calling parseTorrent instead of trying to hide it within my current parseTorrent (which is impossible). thx for the suggestions!
05:31:14 <absence> tuplise a = fmap (flip (,) a)
05:31:26 <absence> that works with lists, tuples, etc
05:31:33 <absence> how can i make it work with e.g. 3?
05:32:18 <hpc> :t flip (,) a
05:32:19 <lambdabot> forall a. a -> (a, Expr)
05:32:40 <hpc> :t flip (,)
05:32:41 <lambdabot> forall a a1. a1 -> a -> (a, a1)
05:34:24 <rwbarton> :t (,a)
05:34:24 <lambdabot> Illegal tuple section: use -XTupleSections
05:35:04 <rwbarton> absence, i don't know what you mean
05:35:33 <sipa> > (,5) 3
05:35:34 <lambdabot>   Illegal tuple section: use -XTupleSections
05:36:18 <rwbarton> > flip (,) a 3
05:36:19 <lambdabot>   (3,a)
05:37:09 <absence> > fmap (flip (,) a) 3
05:37:10 <lambdabot>   No instance for (GHC.Show.Show (f (a, SimpleReflect.Expr)))
05:37:10 <lambdabot>    arising from...
05:37:32 <absence> rwbarton: you forgot the fmap :)
05:38:37 <rwbarton> fmap means something
05:38:42 <rwbarton> something you don't seem to want
05:38:46 <rwbarton> so why do you have it
05:38:51 <rwbarton> I mean
05:38:56 <rwbarton> > fmap (flip (,) a) [3,4,5]
05:38:56 <absence> if i remove it, it won't work for lists
05:38:57 <lambdabot>   [(3,a),(4,a),(5,a)]
05:39:02 <rwbarton> > flip (,) a [3,4,5]
05:39:03 <lambdabot>   ([3,4,5],a)
05:39:08 <rwbarton> these are both legal, and mean different things
05:39:19 <absence> quite so
05:39:33 <rwbarton> when you use fmap, you are saying something like "apply (,a) to each element of this structure"
05:39:48 <rwbarton> but 3 isn't a structure so what would that mean
05:40:07 <absence> so i have to have a separate function for the special case of not having a structure?
05:41:10 <rwbarton> I guess?
05:41:49 <rwbarton> this example is sort of trivial, I mean you can write the "special case of not having a structure" function as (,a)
05:42:14 <shachaf> > runIdentity $ fmap (flip (,) a) (Identity 3)
05:42:16 <lambdabot>   (3,a)
05:42:23 <shachaf> @ty fmap
05:42:24 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:42:27 <rwbarton> I wouldn't bother to define a function at all if the definition was (,a)
05:43:01 <rwbarton> if it was some more complicated function, I would define the non-fmap version and then just use fmap wherever I needed it
05:43:02 <shachaf> If you didn't have this "special case", it wouldn't know which thing you mean to be the structure, for one.
05:43:10 <absence> shachaf: aha, interesting ...
05:46:27 <absence> rwbarton: it will be more complicated, and composed with other functions, so adding fmap manually would mean to make two versions of all the composite functions
05:46:42 <absence> the identity functor might do the trick though
05:48:07 <shachaf> Sounds like you might be doing something wrong.
05:48:48 <absence> possibly :)
05:50:54 <medfly> hi
05:51:11 <rwbarton> I'm still a little confused, yeah, since the only thing you can do with Functor f => f X is to apply fmap f for some f :: X -> Y to it
05:54:32 <absence> rwbarton: i think what i initially wanted might not be possible - a function that turns 'a' into '(a,v)' and '(a,b)' into '(a,(b,v))', but those are different types
05:55:03 <rwbarton> oh
05:57:55 <hpc> absence: if you feel especially evil today, there's overlapping instances and type families
05:58:17 <hpc> but you probably don't want that
05:59:23 <rwbarton> yes, a problem here is that '(a,b)' is a special case of 'a'!
06:00:36 <Siod> is there any significant overhead in using lenses?
06:00:55 <absence> that does sound like something that could quickly turn evil :P
06:14:54 <absence> hpc: that said, this makes me twitch: http://hpaste.org/69092
06:15:23 <mrkronecker> Is it a bad idea to have a data type with potentially thousands of constructors?
06:15:54 <hpc> mrkronecker: uh, if you have to ask...
06:15:57 <hpc> :P
06:16:22 <Taneb> mrkronecker, almost certainly, what are you trying to do?
06:16:41 <mrkronecker> I'm just trying to figure out a good way to serialize the state of my program by representing functions as data :/
06:17:06 <mrkronecker> The data type which represents these functions is the one which may potentially have thousands of constructors
06:17:23 <dmwit> Come on.
06:17:37 <dmwit> At the very worst, you define a language that, when interpreted, includes all the functions you were going to serialize.
06:17:42 <dmwit> Then you write out the AST.
06:17:46 <dmwit> That's at the very worst.
06:17:50 <dmwit> You can surely do better than that.
06:18:20 <hpc> see also, parsec
06:18:39 <gienah> maybe acid-state might help
06:19:20 <mrkronecker> I'll have a look at those. Thank you.
06:22:24 <mrkronecker> AH! Ah! I never considered this!
06:22:48 <mrkronecker> You can save and rerun all of the actions of the user
06:23:06 <mrkronecker> This acid-state thing is so clever!
06:24:01 <mrkronecker> I guess that it could take a while to load if the saved state is reached by some especially complex path -
06:25:00 <mrkronecker> but it would spare all of the effort involved in representing the state as data!
06:25:12 <mrkronecker> Thanks so much
06:26:31 <mm_freak_> absence: there are things for which i would use arrow notation
06:26:46 <mm_freak_> keep in mind that you can combine the two
06:26:55 <mm_freak_> so for complicated signal flows feel free to use arrow notation
06:29:26 <mroman> Is there a package for haskell which allows getting a handle to other running processes?
06:31:07 <hpc> almost certainly
06:31:32 <hpc> ah, here: http://hackage.haskell.org/packages/archive/process/1.1.0.1/doc/html/System-Process.html
06:32:19 <hpc> it runs the command, gives you stdin, out, err, and a handle to the process to kill it if you have to
06:32:57 <mroman> hpc: I'm looking for non-child processes ;)
06:33:28 <hpc> oh
06:33:39 <hpc> that i don't know
06:33:54 <Paprikachu> why does haskell need the "otherwise" keyword in the last "case"?
06:33:56 <absence> mm_freak_: right :)
06:33:58 <hpc> but perhaps you could do some goofiness with a gdb child process?
06:34:01 <hpc> Paprikachu: it doesn't
06:34:04 <mroman> Paprikachu: It's not a keyword.
06:34:04 <hpc> @src otherwise
06:34:05 <lambdabot> otherwise = True
06:34:07 <mroman> And it does not ;)
06:34:35 <mroman> True always matches.
06:34:36 <Paprikachu> what.
06:34:47 <hpc> Paprikachu: guards are roughly the functional analog of if (cond) {stuff} else if (next cond) {stuff} ...
06:34:52 <ski> > case False of otherwise -> 'a'; False -> 'b'
06:34:53 <lambdabot>   'a'
06:35:23 <Paprikachu> i don't get it, when is it needed?
06:35:27 <mroman> > case False of 1>0 -> 'a'; False -> 'b'
06:35:28 <lambdabot>   <no location info>: Parse error in pattern
06:35:32 <ski> it's not needed at all
06:35:36 <mroman> hm.
06:35:48 <mroman> > case False of (1>0) -> 'a'; False -> 'b'
06:35:49 <lambdabot>   <no location info>: Parse error in pattern
06:35:51 <ski> peolpe think it looks nicer, when writing guards, than writing `True'
06:36:35 <Paprikachu> sign x = | x < 0 -> -1 | x == 0 -> 0 | otherwise 1
06:36:46 <Paprikachu> or something like that, lol
06:36:54 <mroman> s/->/=
06:37:01 <alpounet> Paprikachu, it's used to say "whenever the other patterns are not matched, return this value"
06:37:24 <ski> > let merge xs [] = xs; merge [] ys = ys; merge xs0@(x:xs) ys@(y:ys) | x < y = x : merge xs ys0 | x == y = x : merge xs ys | otherwise = y : merge xs0 ys in merge [0,3,4,6,9] [1,4,5,7,8]
06:37:25 <lambdabot>   Conflicting definitions for `ys'
06:37:26 <lambdabot>  Bound at: <interactive>:1:57-58
06:37:26 <lambdabot>          ...
06:37:34 <mparodi> I think ski is a bot. how is that he's always here to help? >_>
06:37:39 <ski> > let merge xs [] = xs; merge [] ys = ys; merge xs0@(x:xs) ys0@(y:ys) | x < y = x : merge xs ys0 | x == y = x : merge xs ys | otherwise = y : merge xs0 ys in merge [0,3,4,6,9] [1,4,5,7,8]
06:37:40 <lambdabot>   [0,1,3,4,5,6,7,8,9]
06:37:50 <ski> > let merge xs [] = xs; merge [] ys = ys; merge xs0@(x:xs) ys0@(y:ys) | x < y = x : merge xs ys0 | x == y = x : merge xs ys | True = y : merge xs0 ys in merge [0,3,4,6,9] [1,4,5,7,8]
06:37:51 <lambdabot>   [0,1,3,4,5,6,7,8,9]
06:38:11 <ski> Paprikachu : see how `otherwise' here just means `True'
06:38:19 <ski> @src filter
06:38:19 <lambdabot> filter _ []     = []
06:38:20 <lambdabot> filter p (x:xs)
06:38:21 <lambdabot>     | p x       = x : filter p xs
06:38:23 <lambdabot>     | otherwise = filter p xs
06:38:50 <ski> so since `otherwise' is just `True', if you put it in the last guard, that will act as a "catch-all" case
06:38:57 <ski> however in
06:39:01 <ski> > case False of otherwise -> 'a'; False -> 'b'
06:39:03 <lambdabot>   'a'
06:39:27 <ski> it matches a *new* variable name with the scrutinee (`False' here), which always succeeds
06:39:47 <Paprikachu> what. :X
06:39:48 <ski> > case False of otherwise -> [otherwise]; False -> []
06:39:49 <lambdabot>   [False]
06:39:57 <ski> is the same as
06:40:03 <ski> > case False of x -> [x]; False -> []
06:40:04 <lambdabot>   [False]
06:40:39 <Paprikachu> i don't get it
06:40:49 <Paprikachu> probably because i don't know the haskell syntax
06:41:03 <hpc> > case 15 of otherwise -> otherwise
06:41:03 <lambdabot>   15
06:41:20 <hpc> in that case, the real "otherwise" gets shadowed
06:41:21 <Paprikachu> i don't even get this xD
06:41:52 <ski> Paprikachu : in a `case', you match the value of an expression with one or more patterns, and you stick with the first pattern that matches
06:42:14 <mparodi> Paprikachu, it's like a switch in other languages
06:42:18 <Paprikachu> but you said otherwise is the same as True
06:42:24 <ski> yes, normally
06:42:38 <ski> but `otherwise' is just a variable which has the value `True'
06:42:41 <ski> but you can do
06:42:42 <hpc> patterns define variables
06:42:47 <ski> > let otherwise = 42 in otherwise
06:42:48 <lambdabot>   42
06:42:54 <hpc> > otherwise
06:42:54 <lambdabot>   True
06:43:00 <Paprikachu> lol
06:43:02 <ski> to locally bind a new value for a new variable named `otherwise'
06:43:10 <hpc> @let globalvar = 9001
06:43:11 <lambdabot>  Defined.
06:43:13 <hpc> > globalvar
06:43:14 <lambdabot>   9001
06:43:20 <hpc> > let globalvar = "blargh" in globalvar
06:43:21 <lambdabot>   "blargh"
06:43:27 <Paprikachu> @let  otherwise = False
06:43:28 <lambdabot>  Defined.
06:43:33 <hpc> > case 15 of globalvar -> globalvar
06:43:33 <lambdabot>   15
06:43:38 <hpc> Paprikachu: making sense now?
06:43:48 <mparodi> it's like True in a way since it always match the value in the case
06:44:35 <Paprikachu> [15:41:06]	<hpc>	Paprikachu: making sense now?
06:44:36 <Paprikachu> not really
06:44:42 <mparodi> switch (whatever) { default: e }     ==      case whatever of otherwise -> e
06:44:45 <mparodi> basically
06:44:46 <Paprikachu> you assign the value "blargh" to globalvar
06:44:57 <Paprikachu> and then try to match 15 against it?
06:45:08 <Paprikachu> that makes no sense to me
06:45:36 <ski> > case [0.1.2] of x:y:z -> (x,y,z); x:y:[] -> (x,y,[42])
06:45:37 <lambdabot>   No instances for (GHC.Num.Num (f a), GHC.Num.Num (f b))
06:45:37 <lambdabot>    arising from a u...
06:45:38 <hpc> Paprikachu: those lines all use different "globalvar"s
06:45:46 <ski> er
06:45:50 <ski> > case [0,1,2] of x:y:z -> (x,y,z); x:y:[] -> (x,y,[42])
06:45:51 <lambdabot>   (0,1,[2])
06:45:55 <ski> > case [0,1] of x:y:z -> (x,y,z); x:y:[] -> (x,y,[42])
06:45:56 <lambdabot>   (0,1,[])
06:46:05 <ski> > 0:1:2:[]
06:46:06 <lambdabot>   [0,1,2]
06:46:19 <Paprikachu> [15:43:06]	<hpc>	Paprikachu: those lines all use different "globalvar"s
06:46:27 <Paprikachu> but then globalvar doesn't exist at all
06:46:49 <ski> Paprikachu : surely you're familiar with
06:46:50 <ski>   {
06:46:54 <ski>   int x = 3;
06:46:59 <ski>   ..use x..
06:47:09 <ski>     while (..blah..)
06:47:11 <ski>     {
06:47:15 <ski>     int x = 42;
06:47:20 <ski>     ..use x..
06:47:26 <ski>     }
06:47:29 <ski>   ..use x..
06:47:32 <ski>   }
06:47:44 <hpc> Paprikachu: gimme a sec to paste something
06:47:50 <ski> in case you don't change any of the `x's, then outside of the `while', `x' is `3'
06:47:55 <ski> and inside of it, `x' is `42'
06:48:21 <ski> simply because the `x' inside the `while'-loop is a *different* variable than the `x' outside it
06:48:57 <Paprikachu> [15:43:18]	<ski>	> case [0,1,2] of x:y:z -> (x,y,z); x:y:[] -> (x,y,[42])
06:49:13 <Paprikachu> so the case keyword is like the switch keyword in other languages?
06:49:21 <ski> mostly, but not quite
06:49:26 <Paprikachu> and foo -> bar means case foo: bar?
06:49:34 <ski> yes, mostly
06:49:52 <ski> except that in C++ (e.g.) the cases doesn't introduce new variables
06:50:11 <dmwit> What do I need to import to be allowed to write (# a, b #) ?
06:50:15 <hpc> http://hpaste.org/69095
06:50:20 <dmwit> I've already got {-# LANGUAGE MagicHash #-} at the top of my file.
06:50:26 <Paprikachu> > case [1,2,1] of x:y:x -> True; x:y:z -> False
06:50:28 <lambdabot>   Conflicting definitions for `x'
06:50:28 <lambdabot>  Bound at: <interactive>:1:16
06:50:28 <lambdabot>            <i...
06:50:38 <hpc> dmwit: UnboxedTuples
06:50:41 <ski> when `[0,1,2]' (which really is `0:1:2:[]') is matched with the pattern `x:y:z:[]', then *new variables `x',`y',`z' are created, and bound to the values `0',`1',`2'
06:50:57 <dmwit> hpc: thanks
06:51:07 <ski> Paprikachu : you can't repeat the same variable in a pattern
06:51:11 <ski> but you can say
06:51:21 <ski> > case [1,2,1] of x0:y:x1 | x0 == x1 -> True; x:y:z -> False
06:51:22 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
06:51:32 <ski> eh, except that this is a type error :)
06:51:32 <ski> so
06:51:40 <ski> > case [1,2,1] of x0:y:x1:z | x0 == x1 -> True; x:y:z -> False
06:51:41 <lambdabot>   True
06:51:56 <Paprikachu> what.
06:51:59 <ski> > case [1,2,1] of x0:y:x1:z | x0 == x1 -> Just (x0,y,z); x:y:z -> Nothing
06:52:00 <lambdabot>   Just (1,2,[])
06:52:17 <ski> `z' gets matched with the empty list at the end of `1:2:1:[]'
06:52:29 <Paprikachu> why do you need it?
06:52:46 <ski> well, lists in Haskell are single-linked lists
06:52:57 <ski> (for finite lists), lists always end in the empty list
06:53:16 <ski> conceptually, you build lists by starting from the empty list, and then add elements in front of it
06:53:33 <ski> (but this is not the whole picture, since you can have infinite lists, due to laziness)
06:53:33 <mauke> > "a" : ["s", "d", "f"]
06:53:34 <lambdabot>   ["a","s","d","f"]
06:53:47 <mauke> > case ["a", "s", "d", "f"] of x : xs -> (x, xs)
06:53:48 <lambdabot>   ("a",["s","d","f"])
06:53:53 <ski> > "a" : "s" : "d" : "f" : []
06:53:54 <lambdabot>   ["a","s","d","f"]
06:53:59 <ski> > "a" : ("s" : ("d" : ("f" : [])))
06:54:00 <lambdabot>   ["a","s","d","f"]
06:54:15 <Siod> is there any significant overhead with lenses?
06:54:20 <Paprikachu> what's the difference between () and [] again?
06:54:29 <barrucadu> () is a tuple
06:54:38 <hpc> :t ()
06:54:39 <lambdabot> ()
06:54:40 <hpc> :t []
06:54:41 <lambdabot> forall a. [a]
06:54:45 <ski> `(.. , .. , ..)' is a tuple -- think like a `struct', but with no names for the fields
06:55:16 <ski> `[3,2,4]' is a (single-linked) list, and is really sugar for `3 : (2 : (4 : []))'
06:55:38 <Paprikachu> yeah i know, tuple elements can have different types while list elements must have the same type
06:55:46 <ski> (all the elements of a list have to be the same type. but the "fields" of a tuple can have different types)
06:55:51 <ski> *nod*
06:55:58 <mparodi> http://paste.kde.org/487976, is there any more direct/intuitive/quickly way to type check expressions with (.) that the one I did?
06:56:15 <Taneb> Tuples are fixed length, whereas you can add elements to lists with ease
06:56:16 <Siod> is there any significant overhead in using anything similar to lenses; e.g., serialization with aeson templates
06:56:37 <Paprikachu> > 'a' : ('b', 'c')
06:56:38 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
06:56:39 <lambdabot>         against inferred ty...
06:57:08 <Paprikachu> > "a" : ("b", "c")
06:57:09 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]]'
06:57:09 <lambdabot>         against inferred ...
06:57:12 <Siod> is there any significant overhead in using templates, at all
06:57:18 <Paprikachu> what.
06:57:24 <mauke> Paprikachu: what.
06:57:35 <Taneb> You can't add elements to a tuple like that
06:57:40 <Paprikachu> [15:51:27]	<ski>	> "a" : ("s" : ("d" : ("f" : [])))
06:57:42 <Paprikachu> [15:51:28]	<lambdabot>	["a","s","d","f"]
06:57:42 <mauke> s/ like that//
06:57:43 <mparodi> actually now that I know the result it's easy to explain, but I I have to type check any expression I have to write it all to be sure
06:57:43 <Paprikachu> there it worked too
06:57:52 <Siod> does 2+2=4?
06:57:53 <mauke> Paprikachu: that was a completely different expression
06:57:55 <mparodi> buf if I *
06:57:55 <dmwit> Paprikachu: That's not a tuple.
06:57:56 <ski> mparodi : that only looks fine (except you forgot to add `Num f')
06:58:13 <mparodi> ski, yes, it's correct, but it takes time
06:58:28 <Paprikachu> > 'a' : 'b' : 'c'
06:58:30 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
06:58:30 <lambdabot>         against inferred ty...
06:58:35 <hpc> Siod: not if you redefine addition
06:58:36 <dmwit> > 'a' : 'b' : 'c' : []
06:58:37 <Paprikachu> > 'a' : 'b' : 'c' : []
06:58:37 <lambdabot>   "abc"
06:58:38 <lambdabot>   "abc"
06:58:42 <hpc> > let 2 + 2 = 5 in 2 + 2
06:58:43 <lambdabot>   5
06:58:47 <Taneb> It's as easy is 1, 2, 3
06:58:52 <Paprikachu> wtf?
06:58:57 <Siod> hpc: that's cute
06:59:02 <Siod> i want to pat you on the head
06:59:06 <ski> mparodi : i this case, i'd probably do it more or less like that (maybe skipping some mediate steps)
06:59:12 <Paprikachu> why does this work?
06:59:23 <ski> it defines a new function `(+)'
06:59:25 <Taneb> Paprikachu, the last element needs to be a list
06:59:27 <Paprikachu> let 1/0 = 42 in 1/0
06:59:31 <Paprikachu> > let 1/0 = 42 in 1/0
06:59:32 <lambdabot>   42
06:59:40 <ski> > let 1/0 = 42 in 1/1
06:59:41 <lambdabot>   *Exception: <interactive>:3:4-11: Non-exhaustive patterns in function /
06:59:53 <ski> > let 1/0 = 42; a/b = a + b in 1/1
06:59:54 <lambdabot>   2
06:59:54 <hpc> Paprikachu: you redefined (/)
07:00:13 <hpc> > let (*) = (&&) in True * False
07:00:13 <lambdabot>   False
07:00:30 <Paprikachu> x
07:00:32 <Paprikachu> xd
07:00:46 <Paprikachu> let (*) = (^) in 42 * 2
07:00:51 <mzero> don't worry - if you did that in a program, GHC would warn you about that
07:00:52 <hpc> Paprikachu: incidentally, that's the same thing that happens with otherwise in case :P
07:00:54 <Paprikachu> > let (*) = (^) in 42 * 2
07:00:55 <lambdabot>   1764
07:01:03 <Taneb> > let 1 : 0 = 42 in typeOf (/)
07:01:04 <lambdabot>   No instance for (GHC.Num.Num [t])
07:01:04 <lambdabot>    arising from the literal `0' at <inter...
07:01:09 <ski> Paprikachu : you may note that the  "abc"  notation is sugar for  ['a','b','c']  which is sugar for  'a' : 'b' : 'c' : []
07:01:14 <Taneb> > let 1 / 0 = 42 in typeOf (/)
07:01:15 <lambdabot>   Integer -> Integer -> Integer
07:01:31 <Paprikachu> > typeOf typeOf
07:01:32 <lambdabot>   Ambiguous type variable `a' in the constraint:
07:01:33 <lambdabot>    `Data.Typeable.Typeable a...
07:01:57 <Paprikachu> :|
07:02:01 <Taneb> typeOf :: Typeable a => a -> TypeRep
07:02:06 <Taneb> Don't worry about it
07:02:17 <mauke> :t typeOf
07:02:18 <lambdabot> forall a. (Typeable a) => a -> TypeRep
07:02:20 <hpc> typeOf is don't-use-it-in-real-code evilness
07:02:27 <Paprikachu> > typeOf 42
07:02:28 <lambdabot>   Integer
07:02:34 <mauke> :t 42
07:02:35 <lambdabot> forall t. (Num t) => t
07:02:35 <Paprikachu> > typeOf Integer
07:02:36 <lambdabot>   Not in scope: data constructor `Integer'
07:02:47 <ski> > typeOf (typeOf `asAppliedTo` False)
07:02:47 <Paprikachu> > typeOf typeOf 42
07:02:48 <lambdabot>   can't find file: L.hs
07:02:48 <lambdabot>   Bool -> TypeRep
07:02:58 <ski> > typeOf (typeOf `asAppliedTo` "hello")
07:03:00 <lambdabot>   [Char] -> TypeRep
07:03:11 <mparodi> ski, you can do that as well: http://paste.kde.org/487982 it's shorter but then you'll have to figure out if 'd' and 'e' can be expressed in terms of f
07:03:13 <Paprikachu> what's "asAppliedTo"?
07:03:28 <Taneb> It specializes a function
07:03:36 <mparodi> (.) map (+) :: f -> [d] -> [e]     !=    (.) map (+) :: f -> [f] -> [f]
07:03:39 <hpc> asAppliedTo :: (a -> b) -> a -> (a -> b)
07:03:47 <hpc> asAppliedTo f x = f
07:03:50 <ski> Paprikachu : just a trick to use the specific instance of the function which could be applied to a given argument
07:03:54 <hpc> Paprikachu: it's just a constrained type
07:04:01 <ski> @type map
07:04:02 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:04:03 <ski> @type chr
07:04:04 <lambdabot> Int -> Char
07:04:10 <ski> @type map `asAppliedTo` chr
07:04:11 <hpc> @type map `asAppliedTo` chr
07:04:12 <lambdabot> (Int -> Char) -> [Int] -> [Char]
07:04:12 <lambdabot> (Int -> Char) -> [Int] -> [Char]
07:04:14 <hpc> hah
07:04:16 <ski> (:
07:04:21 <Paprikachu> also, i have problems reading these function types
07:04:37 <mzero> Paprikachu: this then, is the first skill you should practice
07:04:39 <ski> `(Int -> Char) -> [Int] -> [Char]' reads as `(Int -> Char) -> ([Int] -> [Char])'
07:04:45 <mzero> reading function types is the key to Haskell
07:05:09 <ski> informally : a function taking an argument of type `Int -> Char', and an argument of type `[Int]', and returning a result of type `[Char]'
07:05:14 <Paprikachu> i know that is has something to do with binding
07:05:34 <ski> > map chr [109,97,112,32,99,104,114]
07:05:35 <lambdabot>   "map chr"
07:06:27 <Paprikachu> > let foreach = map in foreach (print) [1,2,3]
07:06:28 <lambdabot>   [<IO ()>,<IO ()>,<IO ()>]
07:06:35 <Paprikachu> huh
07:06:48 <hpc> :t print
07:06:49 <lambdabot> forall a. (Show a) => a -> IO ()
07:06:49 <Paprikachu> smilies.
07:07:07 <Paprikachu> > let foreach = map in foreach (show) [1,2,3]
07:07:09 <lambdabot>   ["1","2","3"]
07:07:22 <ski>   char *map(char (*)(int),int);  /* in C */
07:07:53 <Paprikachu> map returns a new list?
07:07:56 <ski> er, with the second argument being of type `int *', i suppose
07:07:58 <ski> Paprikachu : yes
07:08:06 <Paprikachu> alright
07:08:06 <hpc> ski: one of these days i need to learn how to read C type signatures...
07:08:15 <barrucadu> map takes a function and a list, and applies the function to every element of the list, making a new list
07:08:18 <Paprikachu> C type signatures are pretty easy
07:08:29 <mauke> hpc: you start in the middle and progress outwards
07:08:29 * barrucadu is now annoyed by C types
07:08:33 <barrucadu> Haskell has spoiled me
07:08:36 <Paprikachu> it's much more interesting in c++
07:08:40 <ski> > map f [a,b,c]                                          :: [Expr]
07:08:41 <lambdabot>   [f a,f b,f c]
07:08:44 <hpc> Paprikachu: i don't usually have trouble, but the positioning of (*) makes no sense in my mind
07:08:50 <Paprikachu> with member functions that can be const and stuff
07:09:16 <mauke> hpc: here's a set of recursive generation rules: http://mauke.hopto.org/stuff/c/how-to-declare.txt
07:09:16 <ski>   template <A,B> B *map(B (*)(A),A *);  // something like this in C++
07:09:25 <Paprikachu> guess what void* (foo::* const) (void*) is
07:09:50 <Paprikachu> ski, not really
07:09:54 <mauke> a const pointer to member of foo of type function taking pointer to void and returning pointer to void
07:09:59 * ski doesn't really know C++
07:10:15 <Paprikachu> now make an array of those, please
07:10:19 <ski> (and presumably `std::vector' would be better)
07:10:19 <Paprikachu> :3
07:10:25 <hpc> mauke: ill have to bookmark that and read it every day for a month to get it :P
07:10:33 <Paprikachu> you would do it with iterators
07:10:45 <mauke> Paprikachu: void* (foo::* const [42]) (void*)
07:11:25 <Paprikachu> and now make it a reference to this array
07:11:35 <mauke> Paprikachu: void* (foo::* const (&)[42]) (void*)
07:11:53 <Paprikachu> are you sure?
07:11:58 <mauke> (I'm literally following how-to-declare.txt at this point)
07:12:56 <hpaste> killy9999 pasted “Existential Quantification - what's wrong?” at http://hpaste.org/69096
07:13:16 <killy9999> disregard that
07:13:17 <Paprikachu> i should really learn haskell
07:13:21 <killy9999> I just noticed a typo
07:13:30 <Paprikachu> but don't know what to do with it
07:13:36 <Paprikachu> any ideas?
07:14:11 <ski> implement a C++ interpreter ?
07:14:15 <hpc> lol
07:14:19 <dmwit> Paprikachu: scratch your itches
07:14:19 <barrucadu> Make whatever you would make in C++
07:14:24 <hpc> Paprikachu: pick a project and get at it
07:14:40 <Paprikachu> i don't do any projects in c++
07:14:46 <Paprikachu> no motivation
07:14:52 <barrucadu> My first nontrivial project was a database to keep track of my book collection, with a web front-end using Yesod
07:14:53 <hpc> i wrote an IRC bot and a website in haskell when i was learning
07:14:53 <Paprikachu> just little stuff
07:14:58 <killy9999> Paprikachu: what programming langauge do you use?
07:15:07 <Paprikachu> c++
07:15:23 <Paprikachu> and in school i have to do java, but i don't use it
07:15:25 <killy9999> so what do you program?
07:15:30 <Paprikachu> *at school
07:16:14 * mzero wonders what kind of school teaches programming in *just* Java.....
07:16:21 <nand`> my first non-trivial haskell program was a program that calculated the “center of mass” of an image by treating it as a planar lamina with a mass function
07:16:22 <hpc> mzero: terrible ones
07:16:26 <Nimatek> Many do.
07:16:28 * ski . o O ( "JavaSchools ?" )
07:16:41 <hpc> wait, that's unfair
07:16:42 <Nimatek> I would even guess the majority does.
07:16:43 <barrucadu> mzero: The intro to programming course at my uni used Java. For some reason this replaced the old Scheme course...
07:16:45 <hpc> unusually terrible ones
07:16:52 <Paprikachu> normally i do template stuff in c++
07:16:55 <hpc> the plain old terrible ones teach java except for a semester of python
07:16:56 <Paprikachu> http://ideone.com/6JKKm
07:17:05 <mzero> in any event, Paprikachu: what's the most fun program you've written in the last 6 months?
07:17:07 <nand`> mzero: good schools I've found allow you to program in whatever language you can provide a compiler for; and the prof can understand it (ie. no malbolge)
07:17:08 <jonaskoelker> hpc: we learned seven weeks worth of sml too ^_^
07:17:21 <Paprikachu> i don't really know
07:17:30 <barrucadu> (fortunately, this year there have been forays into C, Haskell, Erlang, Ada, Pascal-FC...)
07:17:38 <ski> jonaskoelker : SML :D
07:17:42 <hpc> my classes were mostly java
07:17:42 <Paprikachu> i didn't do much in the last 6 months
07:17:46 <hpc> two classes in C
07:17:48 <mzero> okay - a year?
07:17:49 <jonaskoelker> some later courses assumed knowledge of one of C, C++
07:17:55 <hpc> one prolog, one lisp
07:18:04 <ski> (which lisp ?)
07:18:05 <hpc> and one in R
07:18:08 <Nimatek> I assist a prof teaching Java ._.
07:18:09 <hpc> common lisp :(
07:18:14 <mzero> I'm just saying, the way to learn Haskell, or really any programming system, is to pick something you've done, small and fun and redo it
07:18:27 <jonaskoelker> ski: what are you expressing with that ":D"?
07:18:33 <nand`> the only classes I've had were C# unfortunately, but that's fine since I'm fairly experienced with C# so I don't actually have to learn it anymore. I can survive submitting a few tests in it
07:19:37 <Paprikachu> maybe i could write a math parser in haskell
07:19:38 <nand`> do any school teach Agda?
07:19:43 <hpc> nand`: doubtful
07:20:00 <hpc> agda is quite firmly stuck in "research-land" at the moment
07:20:04 <jonaskoelker> also, straw poll: what's people's opinion on the statement "Haskell is MLish"?
07:21:07 <ski> jonaskoelker : that SML is cool :)
07:21:41 <Paprikachu> how can i read a line from stdin?
07:21:44 <jonaskoelker> my limited experience with FP divides FP languages into two buckets: lisp and not-lisp ("MLish"), and haskell definitely goes in the latter.  More specifically, static hindley-milner inference, (G)ADTs, pattern matching, ...
07:21:50 <jonaskoelker> hGetLine stdin
07:21:51 <ski> iirc, HBC, the first haskell implementation, was written in LazyML
07:22:09 <jonaskoelker> I would've laughed if you'd said perl :D
07:22:13 <Paprikachu> do i need to import anything?
07:22:19 <jonaskoelker> System.IO I think
07:22:25 <ski> @index getLine
07:22:25 <lambdabot> System.IO, Prelude
07:22:26 <jonaskoelker> @hoogle hGetLine
07:22:27 <lambdabot> System.IO hGetLine :: Handle -> IO String
07:22:27 <lambdabot> GHC.IO.Handle hGetLine :: Handle -> IO String
07:22:27 <lambdabot> Data.ByteString hGetLine :: Handle -> IO ByteString
07:22:47 <jonaskoelker> ore use getLine as ski says ^_^
07:22:53 <ski> Paprikachu : if just `stdin', then `getLine' is in `Prelude', so you don't need to import anything else for that
07:23:07 <ski> (`Prelude' is automatically imported)
07:23:26 <mzero> 's undergraduate courses were in: PL/C, ELC, C, Prolog, Lisp (Scheme, T & NIL variants), assembly (Vax, 6502, PDP-6), Forth, and Pascal
07:23:51 <jonaskoelker> I find there's something nice about SML, but also there's something... meeehhhh... it lacks a certain pizzazz than haskell has
07:24:10 <ski> mzero : sounds like a fun curriculum
07:24:14 <Paprikachu> http://ideone.com/h1k5j
07:24:16 <Paprikachu> QQ
07:24:19 <mzero> and before that had learned Cobol, Fortran, APL, Basic, & Autocoder (IBM 1401)
07:24:48 <mzero> I'm definitely of the opinion that students should be learning at least one new language / programming system per term
07:25:33 <Paprikachu> students in my class can't even handle the last 3 years java
07:25:53 <jonaskoelker> you think the tradeoff between learning new programming systems and learning new theoretical concepts (automata theory, turing machines, ...) is good with that?
07:25:56 <ski> jonaskoelker : yeah, but i miss `local'-`in'-`end' and the module system, in Haskell
07:26:13 <Paprikachu> also, what's wrong with my code
07:26:26 <Nimatek> Paprikachu: The last line.
07:26:32 <Paprikachu> you don't say
07:26:36 <Nimatek> It's type is String, but main must be IO ()
07:26:37 <jonaskoelker> ski, that's basically (let ... (defn f ...) (defn g ...)), right?
07:26:45 <mzero> Paprikachu: try      main = getLine >>= putStrLn . reverse >> main
07:26:53 <mauke> mzero: :-(
07:26:56 <Nimatek> Paprikachu: Change it to putStrLn $ show $ parse line
07:27:06 <jonaskoelker> or "main = interact reverse", IIRC
07:27:06 <mauke> Paprikachu: change it to: print (parse line)
07:27:10 <jonaskoelker> :t interact
07:27:11 <lambdabot> (String -> String) -> IO ()
07:27:22 <Nimatek> Or print, yeah.
07:27:22 <ski> Paprikachu : you need `putStrLn (show (parse line))', which can be shortened to `print (parse line)' (add `$'s if you wish)
07:27:33 <mzero> sure, but he wanted to know how ot read a line
07:27:35 <Paprikachu> whatever IO () s
07:27:37 <Paprikachu> is
07:27:39 <jonaskoelker> oh true :)
07:27:52 <ski> @type putStrLn
07:27:53 <lambdabot> String -> IO ()
07:27:56 <jonaskoelker> [I figured that was just a stepping stone towards a larger goal]
07:27:58 <mauke> :t getLine
07:27:59 <lambdabot> IO String
07:28:06 <dmwit> :t readLn
07:28:07 <lambdabot> forall a. (Read a) => IO a
07:28:16 <ski>   `putStrLn "Hello"' is the action that, when executed, will print `Hello' to `stdout'
07:29:00 <ski> and `getLine' is the action that, when executed, will read a line from `stdin' (and return it as result of the action)
07:29:31 <mzero> Paprikachu: for now, you can think of IO as a "transformer" or "modifier" of types. When used on the return type of a function, it means "this function does something that interacts with the realworld, and so produces a result that isn't purely a function if it's inputs --- the result may vary for the same inputs"
07:29:32 <jonaskoelker> and printf is the action that, when execute, will debug your program =)
07:29:35 <ski> (note that `getLine' isn't a function, but an action. and `putStrLn' is a function that returns an action -- the function itself doesn't print anything)
07:30:00 <mzero> Paprikachu: it is worth getting that into your head - even if what I wrote is four lines long!  :-)
07:30:32 * ski . o O ( only three here .. )
07:30:32 <jonaskoelker> mzero: that depends on your $COLS ;-)
07:30:34 <Paprikachu> how do comments in haskell work again?
07:30:44 <ski>   code here  -- line comment
07:30:50 <ski>   {- block comment
07:30:52 <Paprikachu> ahkay
07:30:52 <ski>      ...
07:30:52 <jonaskoelker> {- like this -} but not this -- but this
07:30:53 <ski>   -}
07:30:54 <Paprikachu> y
07:30:56 <mzero> jonaskoelker: then you have to read my comment in IO!
07:30:57 <Paprikachu> ty
07:32:17 <jonaskoelker> mzero: well, since my monitor transmits your comment on the etherbus to my eyes, I have to do everything in IO anyways ;)
07:32:29 <dmwit> Pop quiz! {-"-}"am I still in block comment mode?
07:32:40 <dmwit> "{-"-}am I still in quote mode?
07:32:58 <jonaskoelker> and the right answer is :t {-"-}"foo
07:32:59 <mzero> functions returning IO () may seem odd: how can () vary? but in this case, it is the realworld that varies!   So if  you execute   putStrLn "Hello"   three times - the realworld is different after each execution, even if the expression returns the same () to your program
07:33:19 <mauke> mzero: I dislike your explanation
07:33:53 <hpc> you see, IO is like a burrito...
07:34:07 <barrucadu> Mmm, functional burrito
07:34:07 <hpc> oh man, imagine that said in bill cosby's voice
07:34:17 <Paprikachu> okay, i have no idea how to write a mathparser.
07:34:18 <mauke> zip zop
07:34:32 <taylorgb> One worthy use of a time machine
07:34:33 <mzero> well, seems like "IO is just a state monad with an unobtainable state value so that actions are forced into sequential execution" isn't going to quite help at this tage
07:34:35 <mzero> stage
07:34:49 <mauke> mzero: IO isn't a state monad
07:34:52 <monochrom> http://spl.smugmug.com/Humor/Lambdacats/13227630_eKt46#!i=1288212148&k=5KLHJ3V
07:34:57 <jonaskoelker> Paprikachu: how familiar are you with parsing in general?
07:35:06 <jonaskoelker> also, how generally do you want to parse math?
07:35:08 <Paprikachu> i already wrote a math parser in c++
07:35:09 <mzero> it's a variante of one
07:35:14 <mauke> mzero: I disagree
07:35:18 <ski> (`IO' has aspects of a state monad, if you don't introduce concurrency)
07:35:24 <Paprikachu> but i have problems writing it in haskell because i need iteration
07:35:34 <mauke> Paprikachu: use recursion instead
07:35:39 <jonaskoelker> when, why?
07:35:44 <Paprikachu> doesn't work in this case.
07:35:48 <mauke> Paprikachu: why not?
07:35:52 <Paprikachu> -- sum = product [('+' | '-') product]*
07:36:19 <Paprikachu> if i do this recursive, it would add or substract the whole value on the right side from the left
07:36:25 <jonaskoelker> Paprikachu: are you hand-writing a recursive descent parser?
07:36:29 <Paprikachu> yes.
07:36:30 <mauke> sum = product >> many ((token '+' <|> token '-') >> product)
07:36:53 <Paprikachu> but 1 - 2 + 3 is obviously not 1 - (2 + 3)
07:36:55 <mauke> Paprikachu: that's not a loop, that's a comment
07:37:04 <mzero> mauke - a) this is exactly why my description of IO was more appropriate for now, and b)   newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
07:37:05 <Paprikachu> it's my grammar
07:37:12 <ski> Paprikachu : use an accumulator
07:37:20 <mauke> Paprikachu: and it contains no loops
07:37:31 <hpaste> rhapsodhy pasted “yesod time” at http://hpaste.org/69097
07:37:32 <Paprikachu> it does
07:37:37 <rhapsodh1> i thought i'd jump into making a webpage with yesod as a first encounter with haskell, and struggling to output the result of getPOSIXTime
07:37:43 <mauke> mzero: 1) that type is a lie  2) there is no RealWorld value
07:37:43 <ski> `*' arguable is a loop
07:37:48 <rhapsodh1> i have this now: http://hpaste.org/69097
07:38:08 <rhapsodh1> what is the correct way to do this?
07:38:30 <barrucadu> Paprikachu: If you define your grammar suitably, recursive parsing works fine (and is in fact a pretty normal way to do things)
07:38:41 <barrucadu> Paprikachu: Although, the usual way to do parsing in Haskell is to use Parsec
07:38:48 <jonaskoelker> how about happy?
07:38:51 <nand`> I'm surprised by how many people decide to learn Haskell because of one of its web frameworks
07:38:53 <Paprikachu> i want to do it manually
07:38:58 <ski> Paprikachu : after reading the initial `product', call a helper function that keeps the current result so far in an argument, initializing it with the result of the initial `product'
07:39:03 <jonaskoelker> Paprikachu: for the learning experience?
07:39:07 <Paprikachu> yes
07:39:08 <mzero> indeed - it came right out of GHC.Prim - though I expect the compiler still treats it special in places
07:39:13 <Paprikachu> but i got an idea now
07:39:18 <nand`> Paprikachu: implement your own combinatorial parser library :P
07:39:33 <Paprikachu> already did that in c++
07:39:42 <nand`> do it in Haskell
07:39:48 <monochrom> c++ is different
07:40:00 <jonaskoelker> luckily =)
07:40:49 <Paprikachu> c++ templates are a bit like haskell
07:41:02 <rhapsodh1> nand`: yesod is pretty fascinating because it's quite different than flask or django
07:41:05 <Paprikachu> no iteration and only constants
07:41:27 <mauke> yes, templates are basically an awful functional language
07:41:29 <mauke> with awful syntax
07:41:34 <jonaskoelker> isn't there some kind of laziness in them as well?
07:41:45 <jonaskoelker> or am I off my rocker here
07:41:51 <ski> ("What Does Haskell Have to Do with C++?" <http://bartoszmilewski.com/2009/10/21/what-does-haskell-have-to-do-with-c/>)
07:42:05 <rhapsodh1> besides, i don't have any math or parsing problem
07:42:09 <rhapsodh1> right now :)
07:43:50 <monochrom> all those "c++ template is like haskell" only means, if you have written a parser at the template level, you sort of know how to write in haskell. well, have you?
07:44:22 <Paprikachu> i started doing it, but gave it up
07:44:26 <b_jonas> I have written a parser in C++ but it uses no templates
07:44:28 <monochrom> 10 to 1 your parser in c++ was not at the template level
07:44:51 <monochrom> well then "I have done it in c++" is useless.
07:45:01 <Paprikachu> it used recursion too
07:45:19 <nand`> I'm not exactly sure how templates work and how they're different from C# generics; but in C# I can't implement, say, monads because I can't parameterize a type over a type that isn't of kind *; that is I can't write a type with kind (* -> *) -> * or so. Can you do this (or its equivalent) in C++ templates?
07:45:37 <Paprikachu> templates are completely different from generics.
07:45:39 <b_jonas> nand`: yes, you can do that in C++
07:45:52 <mauke> I think http://mauke.hopto.org/stuff/ploki/ploki-0.6.5.1/examples/calc.pk could be fairly Haskellable
07:46:22 <hpc> nand`: what you can't do in C++ is stuff like Monoid's mempty
07:46:25 <hpc> iirc
07:46:40 <Paprikachu> templates are a compiletime mechanism while generics are a runtime mechanism
07:46:50 <Paprikachu> also, templates alone are turing complete
07:47:06 <Paprikachu> while generics can't be used for much more than containers-of-type-T
07:47:19 <jonaskoelker> don't java containers have a fixed point thingie?
07:47:20 <nand`> yeah, generics can just express types of kind * -> * -> * ... -> *
07:47:34 <jonaskoelker> ISTR my compiler teacher said as much
07:47:40 <nand`> ie. I can write a Foo<Int, String, List<Bar>, ...>
07:47:49 <nand`> but not a Foo<List, Int, String>
07:48:07 <Paprikachu> yeah, you can do that in c++
07:48:24 <Paprikachu> you can also pass values as parameters
07:48:41 <nand`> Paprikachu: related to type dependency?
07:48:52 <Paprikachu> yes
07:49:58 <Paprikachu> in my example that i posted before i use a variable list of characters (char...) as a template parameter to create a rhombus at compile time
07:50:14 <Paprikachu> http://ideone.com/6JKKm
07:52:07 <taylorgb> http://ideone.com/6JKKm
07:52:10 <taylorgb> oops
07:52:44 <mauke> template<template<typename> M, typename A, typename B> struct Wtf { B (*f)(A); Wtf(B f_(A)) : f(f_) {} M<B>::type operator()(A x) { return M<B>::unit(this->f(x)); } }; template<template<typename> M, typename A, typename B> M<B>::type liftM(B f(A), M<A>::type mx) { return M<A>::bind(mx, Wtf<M, A, B>(f)); }
07:53:08 <Paprikachu> you forgot the class keyword after M
07:53:18 <mauke> my attempt at: liftM f mx = mx >>= (\x -> return (f x))
07:53:20 <Paprikachu> err, before
07:53:21 <mauke> 100% untested
07:53:32 <Paprikachu> template <template <typename> class M <<< here
07:53:39 <mauke> I can never get the syntax for template templates right
07:53:50 <mauke> because it's completely unlike every other parameterized construct in C++
07:54:06 <Paprikachu> you can even write template-template-template-parameters
07:54:15 <Paprikachu> or template-template-template-template-parameters
07:54:22 <ski> that's good
07:54:34 <mauke> doesn't really help because templates are typenames
07:54:47 <mauke> that is, they don't really exist as far as most of the language is concerned
07:55:08 <Paprikachu> template <template <template <template <template <typename> class> class> class> class> struct foo {};
07:55:14 <mauke> e.g. I can't have members of a template
07:55:28 <nand`> There needs to be a webcomic about Haskell: “The adventures of Haskell Curry”, based on laziness puns and type shenanigans
07:55:50 <taylorgb> Paprikachu: Have you ever found such a template to be useful?
07:55:55 <Paprikachu> nope.
07:56:00 <hpc> nand`: it already exists, but nobody reads it so the thunk never got forced :D
07:56:19 <nand`> hehe
07:56:25 <Paprikachu> i haven't even felt the need for template-template parameters so far
07:56:27 <jonaskoelker> and that, recursively, is the first one ;)
07:56:56 <taylorgb> I know that crypto++ uses templates rather liberally, I'm not convinced it is a good thing.
07:56:58 <b_jonas> Paprikachu: people usually use a template class that has template members instead of a template template
07:57:05 <b_jonas> Paprikachu: because the syntax gets easier
07:57:08 <Paprikachu> don't teach me c++.
07:57:17 <b_jonas> oh well
07:57:17 <ski> nand` : you might enjoy <http://www.lisperati.com/landoflisp/panel01.html>
07:58:27 <Paprikachu> template-template parameters are normally not used because they would impose restrictions over what can be passed and what not
07:58:43 <Paprikachu> a prominent example would be the allocator-type of the STL-containers
07:58:56 <b_jonas> but then, haskell is better because it can actually prove stuff generically about higher order types, which is why we can have nested types.
07:59:03 <b_jonas> non-regular types
07:59:08 <b_jonas> C++ won't ever be able to do that
07:59:22 <b_jonas> because it has to check everything about each instantiated type individually
07:59:26 <Paprikachu> i don't know what you mean
07:59:31 <mauke> what are nested types?
07:59:34 <b_jonas> so they can't have more than finitely many types in the same program
07:59:36 <b_jonas> mauke: non-regular types
07:59:40 <mauke> ?
08:00:53 <b_jonas> mauke: the kind of stuff like data L a = Z | T (L (a, a) (a, a))
08:01:11 <b_jonas> that calls back itself with more complicated parameters
08:01:27 <b_jonas> there was an article about them somewhere
08:01:33 <Paprikachu> i don't even know what this construct does
08:02:14 <hpc> b_jonas: you mean data L a = Z | T (L (a, a))?
08:02:27 <b_jonas> hpc: yes, sorry
08:02:36 <monochrom> polymorphic recursion
08:02:40 <b_jonas> or rather, data L a = Z | T (L (a, a)) (L (a, a))
08:02:52 <mauke> Paprikachu: template<typename T> struct X { X< pair<T, T> > *foo; };
08:03:25 <ski>   data PerfectlyBalancedTree a = Elements a | Double (PerfectlyBalancedTree (a,a))
08:03:26 <Paprikachu> and?
08:03:33 <dzhus> can ST actions be run in parallel?
08:04:03 <b_jonas> dzhus: not likely. how would the result be pure then?
08:04:05 <ski> dzhus : not if they're in the same state thread
08:04:28 <monochrom> runST x `par` runST y ?
08:05:36 <Paprikachu> how can i get the nth character of a string?
08:05:42 <mauke> :t (!!)
08:05:42 <lambdabot> forall a. [a] -> Int -> a
08:05:48 <Paprikachu> or is there something like a string iterator in haskell?
08:05:50 <ski> > "foobar" !! 3
08:05:51 <lambdabot>   'b'
08:05:55 <mauke> Paprikachu: strings are their own iterators
08:06:02 <mauke> because they're lists
08:06:09 <ski> @hoogle unsafeInterleaveST
08:06:10 <lambdabot> Control.Monad.ST unsafeInterleaveST :: ST s a -> ST s a
08:06:10 <lambdabot> Control.Monad.ST.Lazy unsafeInterleaveST :: ST s a -> ST s a
08:06:13 <ski> @hoogle unsafeForkST
08:06:14 <lambdabot> No results found
08:06:42 <Paprikachu> is there a function skipSpaces in haskell?
08:06:50 <mauke> :t dropWhile isSpace
08:06:50 <lambdabot> [Char] -> [Char]
08:06:54 <dzhus> monochrom: ah, somehow I've missed runST
08:06:56 <ski> i suppose there could be something like `unsafeForkST', if you're sure the state used by the forked thread is disjoint from the other state
08:07:06 <ski> (there'd need to be some way to get the answer back, though)
08:07:30 <ski> dzhus : eh .. how were you running `ST s'-actions, if not `runST' ?
08:07:31 <dzhus> b_jonas: ski: Yes, I needed parallelism for different instances of ST, not inside one
08:07:31 <jmcarthur> Paprikachu: it sounds like you are parsing. maybe it would be worth looking at a parser combinator library in the future. (i don't think you should quite yet, though, since it sounds like you are still trying to get around some of the basics)
08:07:50 <ski> (`stToIO' ?)
08:07:56 <Paprikachu> i *am* actually parsing, but i want to do it by hand
08:07:58 <monochrom> runST x `par` runST y has limitations. x and y can't share data
08:08:03 <dzhus> ski: I was only looking into converting my code to use ST from pure
08:08:09 <jmcarthur> Paprikachu: as an exercise?
08:08:12 <dzhus> monochrom: sure, I have full data independence
08:08:16 <Paprikachu> -_-
08:08:21 <monochrom> oh good, we're happy then :)
08:08:27 <Paprikachu> dont' ask me over and over again, yes, as an exercise
08:08:36 <Paprikachu> what do i have to import for isSpace?
08:08:41 <jmcarthur> i'm sorry, i just opened IRC, so if you said it earlier i didn't see
08:08:42 <mauke> @hoogle isSpace
08:08:42 <lambdabot> Data.Char isSpace :: Char -> Bool
08:08:46 <copumpkin> Paprikachu: use @hoogle
08:08:55 <ski> @index isSpace
08:08:56 <lambdabot> Data.Char
08:09:36 <ski> dzhus : so you were using `State' before ?
08:10:48 <Paprikachu> is there a function that parses an int and returns both the int and the remaining string?
08:10:58 <hpc> :t reads
08:10:58 <lambdabot> forall a. (Read a) => String -> [(a, String)]
08:11:25 <Paprikachu> > reads "123abc"
08:11:26 <lambdabot>   []
08:11:29 <hpc> > reads "12345 and some more text here..." :: [(Int, String)]
08:11:29 <lambdabot>   [(12345," and some more text here...")]
08:11:50 <Paprikachu> why the :: stuff?
08:12:00 <hpc> to keep it from defaulting to ()
08:12:19 <hpc> > break isDigit "123abc"
08:12:19 <lambdabot>   ("","123abc")
08:12:20 <Paprikachu> ...whatever.
08:12:30 <hpc> > read "12345" :: Int
08:12:31 <lambdabot>   12345
08:12:33 <hpc> > read "12345"
08:12:34 <lambdabot>   *Exception: Prelude.read: no parse
08:12:37 <hpc> > read "()"
08:12:38 <lambdabot>   ()
08:12:47 <Paprikachu> @index reads
08:12:48 <lambdabot> Text.Read, Prelude
08:12:58 <Paprikachu> so i dont have to import it?
08:13:57 <ski> > (reads :: ReadS Int) "12345 and some more text here..."  -- you can call `reads' like this
08:13:58 <lambdabot>   [(12345," and some more text here...")]
08:14:34 <ski> if the result is an empty list, then there is a parse error
08:14:48 <hpc> if it's more than one result, it's an abiguous parse
08:14:52 <ski> > (reads :: ReadS Int) "only some text here..."
08:14:53 <lambdabot>   []
08:14:56 <hpc> usually that doesn't happen
08:15:17 <Paprikachu> how can there be more than one result?
08:15:30 <ski> for `Int' there can't
08:16:31 <ski> you could define an ambiguous parser, that could parse "1 + 2 + 3" as alternatively `Add (Const 1) (Add (Const 2) (Const 3))' and `Add (Add (Const 1) (Const 2)) (Const 3)'
08:17:09 <Paprikachu> are haskell function names case insensitive?
08:17:09 <boccato> "My left foot" =~ "f" :: [String]
08:17:10 <hpc> ie, it parses "1 + 2 + 3" as "1 + (2 + 3)" or "(1 + 2) + 3"
08:17:24 <ion> > let r s = listToMaybe [ a | (a,"") <- reads s ] in map r ["42", "42 ", " 42"] :: [Integer]
08:17:25 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
08:17:25 <lambdabot>         against inf...
08:17:26 <boccato> Why does this gives me an error?
08:17:33 <ion> > let r s = listToMaybe [ a | (a,"") <- reads s ] in map r ["42", "42 ", " 42"] :: [Maybe Integer]
08:17:34 <lambdabot>   [Just 42,Nothing,Just 42]
08:17:53 <boccato> > "My left foot" =~ "f" :: [String]
08:17:54 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
08:17:55 <lambdabot>                    ...
08:18:05 <boccato> I love this bot =)
08:18:24 <barrucadu> Paprikachu: No
08:18:26 <b_jonas> boccato: what does that even mean?
08:18:28 <hpc> :t (=~) -- you really don't want to be using this...
08:18:28 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
08:18:45 <Paprikachu> but why did this work then
08:18:52 <Paprikachu> [17:11:25]	<ski>	> (reads :: ReadS Int) "12345 and some more text here..." -- you can call `reads' like this
08:18:57 <jmcarthur> Paprikachu: not only are they case sensitive, but the case of the first letter actually determines whether it's a function or a constructor
08:19:01 <boccato> I am following the Real World Haskell book. The chapter on Regex
08:19:15 <mauke> Paprikachu: because the name of the function is 'reads'
08:19:16 <ski> Paprikachu : there was just a single parser there (no ambiguity)
08:19:24 <jmcarthur> Paprikachu: the only use of reads there is reads. ReadS is a type constructor
08:19:25 <hpc> boccato: a lot of RWH is deprecated or outdated
08:19:28 <Paprikachu> but what's ReadS
08:19:31 <barrucadu> Paprikachu: "ReadS Int" is a type
08:19:33 <hpc> ironically because it itself spurred a lot of development
08:19:43 <mauke> Paprikachu: btw, I tried http://ideone.com/QNAOv
08:20:00 <mauke> conclusions: 1) I hate C++  2) it doesn't work
08:20:02 <ski> Paprikachu : the `:: ReadS Int' just specifies that we're interested in parsing an `Int' -- because you know, `read' and `reads' are overloaded (on the return type)
08:20:03 <b_jonas> @info ReadS
08:20:03 <lambdabot> ReadS
08:20:09 <b_jonas> very useful, bot
08:20:13 <b_jonas> @def ReadS
08:20:13 <ski>   type ReadS a = String -> [(a,String)]
08:20:14 <lambdabot> Maybe you meant: bf do let
08:20:18 <mauke> b_jonas: there is no @info
08:20:18 <b_jonas> that, yes
08:20:19 <ski> @type reads
08:20:20 <lambdabot> forall a. (Read a) => String -> [(a, String)]
08:20:25 <mauke> b_jonas: and there never has been
08:20:32 <ski>   reads :: Read a => String -> [(a,String)]
08:20:36 <hpc> mauke: what does @info get spellchecked to?
08:20:37 <ski>   reads :: Read a => ReadS a
08:20:42 <mauke> hpc: undo
08:20:57 <b_jonas> isn't @info supposed to be similar to the ghci :info command?
08:20:58 <hpc> @info do {x; y}
08:20:58 <lambdabot> x >> y
08:20:59 <b_jonas> okay
08:21:03 <hpc> freaky
08:21:04 <b_jonas> lol
08:21:18 <boccato> hpc: Thanks. So Regexes has changed. I was wondering if I had to import something else.
08:22:33 <ski> Paprikachu : `reads' is a function that takes a `String' and gives a list of `a'-`String'-pairs (each pair representing a successfully parsed value, together with the remainder of the input string)
08:23:07 <ski> > (reads :: String -> [(Int,String)]) "12345 and some more text here..."  -- Paprikachu, this works just as well, but is longer to type
08:23:08 <lambdabot>   [(12345," and some more text here...")]
08:23:38 <ski> > reads "12345 and some more text here..." :: [(Int,String)]  -- and this is also awkward to type, but does the same thing
08:23:39 <lambdabot>   [(12345," and some more text here...")]
08:23:55 <Paprikachu> http://ideone.com/Lywsf
08:23:57 <Paprikachu> meh.
08:24:41 <ski>   parseInt = reads :: ReadS Int
08:24:42 <ski> or
08:24:56 <ski>   parseInt inputString = reads inputString :: [(Int,String)]
08:25:04 <ski> or
08:25:16 <Paprikachu> i don't get the difference.
08:25:17 <ski>   parseInt = reads :: String -> [(Int,String)]
08:25:38 <ski> `ReadS Int' is just a shorthand for writing `String -> [(Int,String)]'
08:25:46 <Taneb> Well, I've just successfully used Monad Transformers for the first time
08:25:48 <ski> if you say `reads :: Blah', then `Blah' should be a function type
08:26:06 <b_jonas> Taneb: congrats
08:26:22 <Taneb> Project Euler problem number 25
08:26:23 <ski> `ReadS Int' is a function type (since it's `String -> [(Int,String)]', which has the function arrow `->' in there)
08:26:34 <Taneb> (what's the first fibonacci number with 1000 digits
08:26:36 <Taneb> )
08:26:43 <Paprikachu> http://ideone.com/cbcgy
08:26:45 <ski> `[(Int,String)]' is not a function type, so `reads :: [(Int,String)]' doesn't work
08:26:50 <Paprikachu> what's now wrong?
08:26:51 <b_jonas> Taneb: how did you get monad transformers in that?
08:26:54 <ion> taneb: You used monad transformers for that? :-D
08:26:59 <Taneb> I used RWS Integer (Sum Integer) (Integer, Integer) ()
08:27:12 <hpc> @let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
08:27:13 <lambdabot>  Defined.
08:27:21 <ski> `reads inputString :: [(Int,String)]' works, because here you're not ascribing the type to the function `reads', but to the result of applying the function to the argument `inputString'
08:27:36 <hpc> > head . dropWhile (\fib -> length (show fib) < 1000) $ fibs
08:27:37 <lambdabot>   107006626638275893676498058445739688508368389663215166501323520337531452060...
08:27:43 <Taneb> The Reader is for the 1000 digits, the Writer for the where it is in the sequence, and the state for the current and previous one
08:27:49 <ski>   main = print $ eval getLine
08:27:51 <ski> should be
08:27:54 <ski>   main = do
08:27:59 <ski>     line <- getLine
08:28:03 <ski>     print $ eval line
08:28:05 <ski> or
08:28:17 <monochrom> how to use ReadS: http://www.vex.net/~trebla/haskell/reads.xhtml
08:28:22 <ski>   main = getLine >>= \line -> print (eval line)
08:28:25 <ski> or
08:28:28 <b_jonas> Taneb: um, and where's the transformer in that? do you mean just the MonadFoo methods?
08:28:28 <pooya72> hello everyone!
08:28:30 <ski>   main = getLine >>= print . eval
08:28:31 <ski> or
08:28:35 <Taneb> b_jonas, yes
08:28:37 <ski>   main = print . eval =<< getLine
08:28:46 <Taneb> I've never really figured them out before
08:28:49 <Paprikachu> ...and why?
08:28:52 <ion> or
08:28:54 <Paprikachu> can it be
08:28:58 <b_jonas> Taneb: okay
08:29:02 <Paprikachu> main = do print $ eval getLine
08:29:04 <ion>   main = print =<< fmap eval getLine
08:29:17 <ski> monochrom : i think you should mention using `ReadS' as an alternative, there
08:29:18 <ion> paprikachu: Look at the types or print, eval and getLine.
08:29:35 <nand`> ski: “I hereby pronounce you guilty.. of having side effects!” <- haha
08:29:37 <ski> Paprikachu : `getLine' isn't a `String', it's an `IO String', which is why that doesn't work
08:29:46 <ski> nand` :D
08:30:22 <Paprikachu> haskell is confusing.
08:30:26 <ski> Paprikachu : you need to "run/execute" the `getLine' action to get the actual string
08:30:29 <ski> e.g. using
08:30:31 <ski>   line <- getLine
08:30:32 <b_jonas> try to write it in applicative squiggles next to further confuse Pap
08:30:34 <nand`> “Hindley Milner type checker” oh boy
08:30:56 <ski> Paprikachu : by doing this, you explicitly say when* you want to perform this input from `getLine'
08:31:23 <Paprikachu> eval needs the result of getLine, so it has to evaluate it before calling eval
08:31:25 <ski> Paprikachu : otherwise, say you had written `main = print (foo getLine getLine)', how would you know which of the `getLine's happened first ?
08:31:35 <ski> s/evaluate/execute/ :)
08:31:46 <ski> (that's a technical term)
08:32:07 <Paprikachu> in that case i would leave it undefined
08:32:09 <ski> nand` : isn't it great !? :)
08:32:51 <ski> Paprikachu : the simplest way for a beginner is probably to use `line <- getLine' like i showed above -- but the other versions also work
08:33:24 <mauke> Paprikachu: I'm not sure what you mean by "result of getLine"
08:33:25 <nand`> ski: the ending is nice
08:33:30 <nand`> “side effects are fine!”
08:33:33 <mauke> Paprikachu: evaluating getLine does nothing; getLine is a constant
08:33:38 <nand`> “..where did the cat go?”
08:33:44 <Paprikachu> getLine returns a line from stdin
08:33:50 <ion> nand: The ending of what? I probably missed some link.
08:34:08 <nand`> ion: http://www.lisperati.com/landoflisp
08:34:09 <mauke> Paprikachu: depends on what you mean by "returns"
08:34:14 <ski> *executing* `getLine' yields a line result, yes
08:34:18 <monochrom> after an hour, http://spl.smugmug.com/Humor/Lambdacats/13227630_eKt46#!i=1288212148&k=5KLHJ3V is still relevant!
08:34:24 <ski> *evaluating* `getLine' yields itself (doing nothing)
08:34:39 <Paprikachu> -_-
08:34:45 <ski> just like evaluating `gets' (not `gets()') in C does nothing
08:34:48 <Paprikachu> i wanted to say execute, okay?
08:34:50 <nand`> ion: oh, not the same link: http://www.lisperati.com/landoflisp/panel23.html
08:34:54 <nand`> ^- is what I was reading
08:35:12 <ion> nand: Thanks
08:35:19 <nand`> wrong again, http://www.lisperati.com/landoflisp/panel01.html
08:35:21 <nand`> there we go
08:35:51 <pooya72> hello everyone!
08:36:23 <danr> hello there
08:36:51 <Paprikachu> how can i get the first element from a tuple?
08:36:59 <mauke> Paprikachu: pattern matching
08:37:02 <nand`> Paprikachu: fst
08:37:13 <nand`> (works on 2-tuples only, though)
08:37:20 <danr> uncurry const
08:38:00 <Paprikachu> http://ideone.com/4qkES
08:38:01 <ski> btw, note that
08:38:04 <ski>   eval line = head $ parseInt $ skipSpaces line;
08:38:07 <ski> could be written like
08:38:15 <ski>   eval = head . parseInt . skipSpaces;
08:38:19 <ski> i.e. as a "pipeline"
08:38:30 <mauke> Paprikachu: parseInt doesn't return a tuple
08:38:36 <ski> (you decide which is most clear to you)
08:38:44 <Paprikachu> o_o
08:39:02 <ski> i think yuo want both `fst' and `head' there ?
08:39:34 <ion> parseInteger :: String -> Maybe Integer; parseInteger s = listToMaybe [ a | (a,"") <- reads s ]
08:39:37 <Paprikachu> i dont even know what head does, i just guessed that there is a function head that returns the first element of a tuple
08:39:46 <ski> > head "abcd"
08:39:48 <lambdabot>   'a'
08:39:57 <mauke> Paprikachu: no, that's fst
08:39:59 <nand`> :t head -- Paprikachu
08:39:59 <lambdabot> forall a. [a] -> a
08:40:00 <ski> > head [5,7,1,4,2,8]
08:40:01 <lambdabot>   5
08:40:10 <Paprikachu> yeah, now i know
08:40:14 <ski> `head' gets the first element of a list (if there is any)
08:40:16 <ski> > head []
08:40:17 <lambdabot>   *Exception: Prelude.head: empty list
08:40:28 <zezikaro> Hi, could anyone help me with a stupid haskell question
08:40:29 <zezikaro> http://ideone.com/ZUfsU
08:40:30 <Paprikachu> but why does head $ ... return the full tuple in eval?
08:40:37 <zezikaro> why am i not allowed to do xs == [] in my guards
08:40:47 <ski> > let parseInt = reads :: ReadS Int  in parseInt "12345 and some more text here..."
08:40:48 <lambdabot>   [(12345," and some more text here...")]
08:40:55 <ski> > let parseInt = reads :: ReadS Int  in head $ parseInt "12345 and some more text here..."
08:40:56 <lambdabot>   (12345," and some more text here...")
08:41:00 <ski> > let parseInt = reads :: ReadS Int  in fst . head $ parseInt "12345 and some more text here..."
08:41:02 <lambdabot>   12345
08:41:10 <Paprikachu> so reads returns a list of tuples?
08:41:17 <ski> yes, a list of pairs
08:41:17 <ion> @type reads
08:41:18 <lambdabot> forall a. (Read a) => String -> [(a, String)]
08:41:33 <Paprikachu> and why not just a single pair?
08:41:44 <ski> (a) there might be a parse error
08:41:51 <ski> > let parseInt = reads :: ReadS Int  in fst . head $ parseInt "only some text here..."
08:41:53 <lambdabot>   *Exception: Prelude.head: empty list
08:42:00 <ski> we'd like to avoid exceptions, if we can
08:42:05 <Taneb> zezikaro, (==) needs an Eq, and you haven't written an Eq constraint in.
08:42:08 <applicative> zezikaro: you are using ==
08:42:08 <Taneb> :t null
08:42:09 <lambdabot> forall a. [a] -> Bool
08:42:11 <mauke> zezikaro: because you don't know whether the type 'a' supports equality
08:42:14 <ski> (b) there might in some rare cases be multiple parses
08:42:19 <mauke> zezikaro: and that's what's required for ==
08:42:25 <applicative> but zezikaro I think we should dispense with the use of ==
08:42:25 <Taneb> :t null -- this is what you want, zezikaro
08:42:26 <zezikaro> mauke thanks
08:42:26 <lambdabot> forall a. [a] -> Bool
08:42:27 <zezikaro> take' :: (Eq a) => Int -> [a] -> [a]
08:42:31 <zezikaro> that then?
08:42:34 <mauke> zezikaro: no
08:42:37 <mauke> zezikaro: stop using ==
08:42:53 <Paprikachu> (b) doesn't make sense to me
08:42:58 <zezikaro> always?
08:42:59 <ski> Paprikachu : what should happen if the read `line' doesn't parse ?
08:43:03 <Paprikachu> (a) does sound like a bad argument
08:43:10 <applicative> zezikaro: you separate the cases :  take n [] = []; take n (x:x) = ...
08:43:26 <ski> Paprikachu : we can't catch exceptions, except from `IO'
08:43:32 <Paprikachu> it should throw an exceptions or something
08:43:32 <ion> Wasn’t that already explained after “<Paprikachu> how can there be more than one result?” (about 30 minutes ago)? :-)
08:43:46 <monochrom> [(a,String)] supports ambiguous grammars (many valid parses)
08:43:57 <ion> paprikachu: Exceptions are evil.
08:43:58 <Paprikachu> also, there is something like Maybe, as far as i'm conerned, allthough i don't know how it works
08:44:09 <ion> paprikachu: parseInteger :: String -> Maybe Integer; parseInteger s = listToMaybe [ a | (a,"") <- reads s ]
08:44:10 <applicative> zezikaro: it is just that you are using  x == []  when you should be matching on the case [].
08:44:15 <mauke> Paprikachu: Maybe is like a list with at most one element
08:44:27 <ski> yes, `Maybe' (or `Either MyExceptionType') may be used to encode exceptions in a nicer way
08:44:51 <applicative> zezikaro: there is nothing wrong with say a list of functions Integer->Integer, and taking 5 of them.  But I dont want to compare these lists for equality
08:44:58 <monochrom> if you don't worry about ambiguous grammars, Maybe (a,String) is good
08:45:32 <nand`> ski: the comic on the root web page of that domain is hilarious as well
08:45:50 <zezikaro> okay gotcha
08:45:51 <zezikaro> tahnks
08:45:53 <zezikaro> thanks
08:46:16 <b_jonas> Paprikachu: you know, just because in most cases you don't want to work with ambiguous grammars, haskell won't want to have two sets of read functions, one that allows ambiguous grammars and one that doesn't
08:46:27 <nand`> “I forgot about those obnoxious schemers from the continuation guild!”
08:46:29 <applicative> zezikaro: http://ideone.com/ZqzjT
08:46:41 <monochrom> exception is not evil. however, exception does not mix well with the non-IO side of haskell
08:46:43 <b_jonas> Paprikachu: it's easier to allow a list all the time
08:46:47 <Paprikachu> what does this have to do with grammars?
08:46:59 <b_jonas> Paprikachu: because it's not really any more complicated to use than a maybe would be
08:46:59 <Paprikachu> i want a function that parses an int, nothing more
08:47:05 <mauke> b_jonas: I've never seen an ambiguous Read instance
08:47:06 <dmwit> hvr: pong
08:47:09 <mauke> b_jonas: literally, never
08:47:15 <b_jonas> Paprikachu: what was wrong with read then?
08:47:18 <b_jonas> > read "42"
08:47:19 <lambdabot>   *Exception: Prelude.read: no parse
08:47:24 <b_jonas> > read "42" :: Int -- sorry
08:47:25 <lambdabot>   42
08:47:33 <Paprikachu> i need the remaining string
08:47:36 <monochrom> "E ::= 0 | E + E" ambiguous grammar. multiple valid parse trees
08:47:46 <hvr> dmwit: hi
08:47:52 <nand`> “and finally, the lazy guild! By waiting until the very last moment, they are extremely efficient!” <- haha
08:47:53 <b_jonas> Paprikachu: well if you want to do that often, define such a function
08:47:54 <dmwit> What's up?
08:48:23 <hvr> dmwit: ...I was hoping you could hpaste the code that ran in 0.02 secs
08:48:31 <b_jonas> nand`: where are those quotes from?
08:48:33 <dmwit> The code in my answer runs in 0.02 seconds.
08:48:45 <nand`> b_jonas: http://landoflisp.com/
08:48:53 <Paprikachu> http://ideone.com/rk9rX
08:48:57 <Paprikachu> what's wrong here?
08:49:03 <dmwit> hvr: More precisely: head (solveLP (the 100 arguments here)) runs in 0.02 seconds.
08:49:34 <hvr> dmwit: which GHC version?
08:49:37 <applicative> zezikaro: I left out take 0  case http://ideone.com/aAbe7
08:49:37 <mauke> Paprikachu: head . reads doesn't have the type String -> [(Int, String)]
08:49:44 <dmwit> hvr: 7.4
08:49:45 <b_jonas> Paprikachu: you know the built-in reader for Int will skip leading spaces itself fine
08:49:46 <monochrom> perhaps need parentheses?
08:49:48 <b_jonas> you don't need to help it
08:50:04 <hvr> dmwit: alright, lemme recheck
08:50:09 <Taneb> RWS etc. are handy when doing recursion, because they mean you don't need to explicitly pass around so much
08:50:44 <dmwit> hvr: It runs in equal times in 7.2 and 7.0 here.
08:50:46 <b_jonas> Paprikachu: but the error message says you're giving the wrong type for parseInt (after the double colon)
08:50:59 <dmwit> I would test with older GHCs but I don't keep them back that far. =)
08:51:00 <Taneb> (my current HaskellThought tm)
08:51:14 <applicative> ghc-6.8.2 Ideone is like time travel
08:51:32 <Paprikachu> http://ideone.com/BRp4p
08:51:32 <monochrom> you are young again! :)
08:51:34 <Paprikachu> this works now
08:51:37 <MagneticDuck> hey there
08:51:38 <Paprikachu> but i dont get why
08:51:51 <Paprikachu> i tough a . b is the same as (a) . (b)
08:51:56 <Paprikachu> thought
08:51:58 <dmwit> hvr: ...and, for completeness, also the same in 7.5.20120526 =)
08:52:01 <mauke> Paprikachu: it is
08:52:03 <applicative> hey man ghc-6.8.2 is before my time :)
08:52:14 <b_jonas> Paprikachu: (a . b :: t) means ((a . b) :: t)
08:52:16 <hvr> dmwit: you're right; I messed up something at my end :-)
08:52:18 <monochrom> (x . y) :: Type  vs  x . (y :: Type)  should be a pretty obvious issue
08:52:23 <b_jonas> because :: has an exteremely low precedence
08:52:53 <monochrom> but I guess since you're still learning parsing, you aren't sensitive to such issues
08:52:57 * applicative thinks, by contrast, codepad.org uses the most cutting edge version of Hugs
08:53:34 <mauke> monochrom: they aren't learning parsing
08:54:11 <Paprikachu> i'm learning haskell, not parsing
08:54:31 <zezikaro> applicative thanks
08:55:47 <hvr> dmwit: mystery solved: I accidently imported Monad.ST instead of Monad.ST.Lazy...
08:56:18 <hvr> dmwit: sorry for the noise
08:56:37 <dmwit> Yep, the .Lazy is really critical. =)
08:56:41 * ski wonders what hvr is using `ST.Lazy' for
08:56:53 <absence> mm_freak_: is it a good rule of thumb to let the original input flow through the entire network? e.g. should updateWorld pass both its input and the rendering data to render, or just the rendering data? render . check isRenderEvent . updateWorld . (check isRenderEvent <|> check isKeyMouseEvent)
08:56:56 <dmwit> (I actually originally wrote and scrapped an answer because I made the same mistake, not realizing there even was a .Lazy. =)
08:57:04 <hvr> ski: http://stackoverflow.com/questions/10767736/
08:57:06 <dmwit> ski: http://stackoverflow.com/q/10767736/791604
08:57:49 <dmwit> (Only Carl's answer pointed me to my mistake, at which point I figured it was worth redoing the actual transliteration with my new knowledge to double-check that everything worked.)
08:58:08 <ski> hvr, did you see monochrom's <http://hpaste.org/63925> ?
08:58:22 <monochrom> w00t :)
08:58:27 <ski> (:
08:58:38 <dmwit> ski: That was spawned by Carl's answer at the linked question, I think.
08:58:46 <dmwit> via c_wraith's followup questions here on #haskell
08:58:53 <ski> ah, i see
08:58:55 <hvr> ski: thx, looks interesting
08:59:25 <c_wraith> dmwit: oh no, you've discovered my non-secret identity!
08:59:26 <lambdabot> c_wraith: You have 1 new message. '/msg lambdabot @messages' to read it.
08:59:36 <int-e> oh it's almostButNotQuiteSafelyInterleaveST.
08:59:47 <Paprikachu> how do i get the second element of a pair?
08:59:49 <dmwit> Wait, Carl = c_wraith?
08:59:58 <monochrom> oh no, now I have discovered your secret identity too, now that you say that's your secret identity!
09:00:13 <c_wraith> no, it's not a secret :)
09:00:21 <int-e> monochrom: he may be bluffing. well, misdirecting.
09:00:50 <Paprikachu> @index sec
09:00:50 <lambdabot> bzzt
09:00:53 <dmwit> His /whois says Carl. He checks out guys!!!1!
09:01:02 <c_wraith> Paprikachu: snd is the name of the function
09:01:11 <monochrom> then again stackoverflow identities are like the () type to me
09:01:40 <ski> Paprikachu : as you read integers and `+'s and `-'s, how would you know when to stop attempting to read another integer ?
09:01:50 <ski> @index snd
09:01:51 <lambdabot> Data.Tuple, Prelude
09:02:01 <monochrom> (i.e., since I don't use stackoverflow, I have little interest in telling who's who there)
09:02:02 <Paprikachu> as long as the string is not empty
09:02:14 <ski> that's not compositional
09:02:29 <b_jonas> ski: I always read 14 integers. the spec says that's how many the input will have.
09:02:33 <b_jonas> oh wait
09:02:34 <ski> what if you want to insert your `sum' grammar into a larger grammar ?
09:02:36 <monochrom> anyway c_wraith, I hope you like my "sprinkle sprinkle little stars" :)
09:02:56 <b_jonas> yes, what ski says
09:02:59 <Paprikachu> don't know then
09:03:06 <c_wraith> I'm looking at it now. I haven't slept much this weekend, though, so it might be a total failure to comprehend today :)
09:03:08 <ski> e.g. if you later want to add
09:03:22 <monochrom> well yeah, it is going to be bizarre :)
09:03:36 <dmwit> Everything shows up all backwards in that paste.
09:03:37 <ski>   expression_list ::= sum [',' expression_list]*
09:03:40 <Paprikachu> also i don't know how to parse a - b + c
09:04:36 <ski> first you parse `a', initializing `a' as the current result
09:05:10 <ski> then you attempt to parse `-' and a new expression, i.e. `b', update the current result to the old result minus the new value, and continue like this
09:05:29 <ski> e.g. ending when you can't parse a `-' or a `+' any more
09:05:40 <augur> Paprikachu: have you read parsing techniques?
09:06:19 <Paprikachu> my doesn not have anything to do with parsing, it's because i don't know how to do it recursively
09:06:38 <augur> what
09:06:56 <Paprikachu> parsing that stuff with iteration is simple.
09:07:00 <barrucadu> Recursion is the normal way to do parsing, as grammars are inherently recursive
09:07:06 <mauke> Paprikachu: converting iteration to recursion is simple
09:07:29 <mauke> Paprikachu: I suspect your issue is more related to mutable data structures
09:07:42 <ski> mauke : i suspect that's not the issue at this point
09:07:44 <augur> Paprikachu: do you know how to do tree walk recursively?
09:07:48 <Paprikachu> while(!atend) if(nextchar == '+') result += parseInt; else if(nextchar == '-') result -= parseInt;
09:08:01 <Paprikachu> that's basically how i would do it
09:08:01 <hpaste> hvr pasted “STArray vs. Vector” at http://hpaste.org/69099
09:08:09 <barrucadu> That's rolling up parsing and evaluation into one
09:08:17 <mauke> Paprikachu: how does that deal with * / vs. + - ?
09:08:18 <Paprikachu> you don't say
09:08:28 <ski> Paprikachu : yeah, and this translates to a helper function which keeps the current `result' in a parameter
09:08:30 <mauke> Paprikachu: because you have to do the * / first
09:08:35 <Paprikachu> in this case i don't support * and /
09:08:39 <hvr> dmwit: for some reason, the non-ST version is still faster than the ST version (even if not by much)
09:08:42 <Paprikachu> just plain + and -
09:08:46 <mauke> ok, that makes things very simple
09:09:07 <augur> Paprikachu: go read up on parsing and on recursion. i feel that would help you.
09:09:17 <hvr> dmwit: see http://hpaste.org/69099
09:09:40 <mauke> parse result = if atend then result else if nextchar == '+' then parse (result + parseInt) else if nextchar == '-' then parse (result - parseInt) else wat
09:09:45 <Paprikachu> i know how to parse shit, i have done it in c++ before. it's because i have a problem doing it RECURSIVELY.
09:09:54 <mauke> Paprikachu: ^ recursion
09:10:04 <Siod> what's a good tutorial for conts?
09:10:06 <augur> Paprikachu: then go read up on recursion.
09:10:13 <augur> Siod: continuations?
09:10:16 <Paprikachu> no ty
09:10:18 <Siod> augur: yes
09:10:26 <augur> Paprikachu: then you'r fucked, pally.
09:10:50 <augur> Siod: i dont think there is a good tutorial on continuations, unfortunately. but i think the wikipedia page on it does as good a job as any
09:11:07 <augur> especially http://en.wikipedia.org/wiki/Continuation-passing_style
09:11:17 <Siod> augur: thanks
09:11:18 <Paprikachu> mauke, now i see your solution i understand it, but i wouldn't been able to write it myself.
09:11:33 <mauke> Paprikachu: do you know about state machines?
09:11:39 <Paprikachu> no.
09:11:49 <mauke> hmm, too bad
09:12:15 <augur> Paprikachu: the best way to get into recursive parsing is to simulate normal stack-based top-down parsers in a recursive setting
09:12:36 <mauke> augur: I have no idea what you just said
09:12:41 <augur> mauke: :)
09:12:43 <Paprikachu> me neither
09:12:46 <augur> well
09:12:51 <augur> go read Parsing Techniques then
09:12:54 <augur> its a good book
09:13:11 <mauke> "normal stack-based top-down parsers"?
09:13:17 <mauke> how are they normal if I've never seen them?
09:13:24 <augur> uh
09:13:29 <augur> what
09:13:53 <augur> are you saying that something rare can't have a standard construction?
09:14:09 <mauke> this looks like a case of "let me explain X in terms of Y, which you've never heard of"
09:14:19 * augur shrugs
09:14:23 <augur> i wasn't trying to explain anything
09:14:44 <Paprikachu> http://ideone.com/eRVWi
09:14:58 <Paprikachu> as you can see i have no problems writing parsers, this is my c++ version.
09:15:24 <augur> you keep saying that but that doesn't change my recommendation
09:17:30 <mauke> loops become recursive calls
09:17:36 <dmwit> hvr: Going to lunch. Maybe I'll take a look later... but no promises.
09:17:38 <mauke> variables that change in the loop become function parameters
09:18:08 <hvr> dmwit: enjoy your meal :)
09:18:38 <augur> Paprikachu: perhaps some good introductions to functional program would help you
09:18:44 <augur> or maybe SICP + Little Scheme
09:18:45 <augur> r
09:19:05 <Paprikachu> i have done functional programming for months, if not years with c++ templates
09:19:32 <mauke> yes, but only trivial stuff
09:19:52 <augur> apparently you havent done it enough since what you're failing at here is like week-1 FP stuff
09:20:32 <Paprikachu> moar demotivation pls
09:20:33 <mauke> I have done imperative programming for months, if not years with the C preprocessor
09:20:45 <mauke> #if X < 0
09:20:47 <Siod> c++ templates encsapulate a tiny aspect of functional programming
09:20:48 <mauke> ...
09:20:49 <mauke> #endif
09:20:54 <augur> Paprikachu: i dont think i could demotivate you any more than you are right now.
09:21:04 <augur> Paprikachu: you seem to be unwilling to try anything anyone suggests
09:21:17 <augur> why are you here, Paprikachu
09:22:02 <Paprikachu> isn't this the gay chanß
09:22:04 <Paprikachu> ?
09:22:12 * barrucadu feels like digging out and resuming his compiler project
09:22:13 <Paprikachu> then i'm mistaken
09:22:19 <Paprikachu> sorry 'bout that.
09:22:22 <hpaste> ski pasted “parsing sums” at http://hpaste.org/69100
09:22:52 <Siod> man, emacs prelude is really nice
09:22:55 <barrucadu> Well, I think that's the first ragequit from #haskell I've seen
09:23:02 <augur> ooookay. was that just a really bad attempt to troll?
09:23:28 <barrucadu> Iterative parsing. Not a technique I have seen before.
09:24:18 <mauke> here's an iterative parser: http://mauke.hopto.org/stuff/c/wcalc.c
09:25:15 <Siod> lol it's very ugly, but it should be fast
09:25:23 <absence> is it possible to make a Category instance for monads so you can "let act = act3 . act2 . act1"?
09:25:51 <Saizan> absence: you need the Kleisli wrapper
09:26:12 <Saizan> absence: or you can use (<=<) from Control.Monad
09:26:22 <Siod> look at this: http://www.json.org/JSON_checker/JSON_checker.c
09:26:45 <absence> Saizan: meaning i would have to write "let act = runKleisli (Kleisli act3 . Kleisli act2 . Kleisli act1)"? :/
09:27:00 <Saizan> absence: yep :\
09:27:34 <absence> Saizan: <=< it is then
09:28:09 <augur> Saizan: i cant turn my head left :(
09:38:33 <MagneticDuck> btw guys I just noticed that there is such thing as karma here on #haskell
09:38:39 <MagneticDuck> I've never seen anyone use it in my life
09:38:40 <MagneticDuck> o.o
09:38:51 <MagneticDuck> karma mauke
09:38:58 <nand`> preflex: karma mauke
09:38:59 <preflex>  mauke: 847
09:39:05 <Clint> MagneticDuck--
09:39:12 <MagneticDuck> -_-
09:39:15 <MagneticDuck> oh please
09:39:15 <ski> @karma mauke
09:39:15 <lambdabot> mauke has a karma of 9
09:39:24 <sipa> @karma preflex
09:39:25 <lambdabot> preflex has a karma of 1
09:39:30 <sipa> preflex: karma lambdabot
09:39:31 <preflex>  lambdabot: 39
09:39:36 <nand`> lambdabot++
09:39:42 <MagneticDuck> lambdabot++
09:39:46 <sipa> @karma lambdabot
09:39:47 <MagneticDuck> such a nice guy
09:39:47 <lambdabot> lambdabot has a karma of 8
09:39:50 <nand`> girl
09:39:53 <sipa> preflex: karma preflex
09:39:54 <preflex>  preflex: 25
09:40:11 <MagneticDuck> btw Clint, why the --? Not that I care.
09:40:25 <nand`> I think preflex is bugged in a way that -- actually increases karma
09:40:33 <nand`> at least that happened to me last time I tried reducing my own karma
09:40:39 <MagneticDuck> @karma MagneticDuck
09:40:39 <lambdabot> You have a karma of -1
09:40:47 <MagneticDuck> ouch
09:40:52 <Clint> MagneticDuck++
09:40:56 <ski> @karma+ MagneticDuck
09:40:57 <lambdabot> MagneticDuck's karma raised to 1.
09:41:06 <MagneticDuck> yay
09:41:19 <nand`> back to writing Haskell
09:41:39 <ski> preflex: karma MagneticDuck
09:41:40 <preflex>  MagneticDuck has no karma
09:41:59 <MagneticDuck> oh and are there any portugese speakers here? because I just noticed that #haskell-pt is empty. On the plus side, I am now an operator.
09:42:13 <monochrom> preflex probably doesn't monitor @karma+
09:42:20 <MagneticDuck> ...and now back to working through project euler
09:43:38 <MagneticDuck> LeNsTR sure likes flags
09:44:10 <LeNsTR> ^)
09:44:24 * ski waves the interrupt disable flag
09:44:44 <MagneticDuck> gosh I never even knew preflex existed
09:44:57 <MagneticDuck> preflex: quote ski
09:44:57 <preflex>  no quotes found for ski
09:45:06 <ski> try `@quote' ?
09:45:13 <MagneticDuck> @quote ski
09:45:13 <lambdabot> ski says: our tribe is better than their tribe <companion_cube> we have advanced technologies like fire or STM !
09:45:29 <MagneticDuck> okay
09:45:50 * ski probably hasn't said very memorable things
09:46:19 <MagneticDuck> okay now I actually have a question guys
09:46:35 <MagneticDuck> what's the easiest way to make a progress bar...?
09:46:49 <MagneticDuck> I just want to run a function that's going to take a while
09:46:51 <sean__> easy way to turn a number into a list???
09:46:58 <MagneticDuck> no
09:47:10 <sipa> sean__: ?
09:47:14 <sipa> in what way?
09:47:23 <ski> > show 496
09:47:24 <lambdabot>   "496"
09:47:31 <ski> > map (:[]) (show 496)
09:47:32 <lambdabot>   ["4","9","6"]
09:47:38 <MagneticDuck> (\x -> take x $ repeat "I LIKE DUCKEZ")
09:47:39 <parcs`> MagneticDuck: you want a textual progress bar?
09:47:54 <MagneticDuck> well anything really
09:48:21 <parcs`> well first you have to figure out what is progress
09:48:30 <MagneticDuck> yeah
09:48:51 <ski> @wn progress
09:48:52 <lambdabot> *** "progress" wn "WordNet (r) 3.0 (2006)"
09:48:52 <lambdabot> progress
09:48:52 <lambdabot>     n 1: gradual improvement or growth or development; "advancement
09:48:52 <lambdabot>          of knowledge"; "great progress in the arts" [syn:
09:48:52 <lambdabot>          {advancement}, {progress}]
09:48:54 <lambdabot> [19 @more lines]
09:49:26 <MagneticDuck> but my question is what's a good way to track the progress of some pure code from a simple interface
09:49:27 <Paprikachu> http://ideone.com/uv01f
09:49:27 <sean__> Yes but i want the list to be a list of integers not chars
09:49:31 <Paprikachu> what is wrong here?
09:49:38 <MagneticDuck> @type digits
09:49:39 <lambdabot> Not in scope: `digits'
09:49:42 <MagneticDuck> aw
09:50:10 <parcs`> MagneticDuck: most progress bars are fake, so... :)
09:50:25 <sean__> How can I turn a number into a list of integers.  Like 134 -> [1,3,4]
09:50:37 <MagneticDuck> @type mod
09:50:38 <lambdabot> forall a. (Integral a) => a -> a -> a
09:50:39 <ski> Paprikachu : s/case x/case y/ ?
09:50:57 <Paprikachu> no
09:51:04 <parcs`> map read . show :D
09:51:12 <ski> hm, no
09:51:13 <MagneticDuck> sean__: use modulus
09:51:24 <MagneticDuck> sean__: :P
09:51:32 <sean__> number is very large
09:51:36 <MagneticDuck> well you actually want div
09:51:46 <parcs`> you want divMod
09:51:49 <ski> Paprikachu : what is the error message ?
09:51:56 <MagneticDuck> @type divMod
09:51:57 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
09:51:59 <MagneticDuck> oohh
09:52:09 <Paprikachu> see the output below the code
09:52:16 <sipa> :t scanl
09:52:17 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
09:52:23 <ski> oh, missed that
09:52:43 <MagneticDuck> parcs': I mean like I have some recursive function, and I want to track its progress. all pure code.
09:52:54 <MagneticDuck> in the number of iterations
09:53:02 <MagneticDuck> as I already know how many it will take
09:53:04 <MagneticDuck> happy now?
09:53:08 <parcs`> yes
09:53:11 <ski> Paprikachu : ah i see
09:53:12 <parcs`> that is not too hard
09:53:16 <ski> Paprikachu : you have no termination case
09:53:26 <MagneticDuck> parcs`: I guessed not
09:53:35 <Paprikachu> oh
09:53:39 <sean__> How can i load multiple files in ghci
09:53:42 <sean__> ???
09:53:45 <ski> Paprikachu : `parseImpl' never returns, so `print' doesn't know what type you want to print
09:53:47 <Paprikachu> so it would be like
09:53:49 <parcs`> what you have to do is make the recursive case a parameter of the function
09:53:54 <monochrom> pure code doesn't support progress monitor
09:53:54 <Paprikachu> otherwise -> acc
09:53:56 <Paprikachu> ?
09:54:07 <MagneticDuck> sean__: :l file1.hs \n :l file2.hs
09:54:21 <MagneticDuck> you just load one then the other
09:54:26 <MagneticDuck> or you can do them at the same time
09:54:31 <ski> Paprikachu : well, i'd add `parseImpl acc ""   = acc' just above the current clause for `parseImpl'
09:54:53 <ski> Paprikachu : if you really want to, you could use `if line == "" then acc else ...' instead
09:54:59 <Paprikachu> that doesn't work for strings that end with spaces
09:55:18 <ski> ok, so `if all isSpace line then acc else ...' ?
09:55:25 <ski> @index isSpace
09:55:25 <lambdabot> Data.Char
09:56:00 <ski> Paprikachu : .. or you could make sure to strip leading spaces before calling `parseImpl', then matching on `""' would work
09:56:09 <applicative> Paprikachu http://ideone.com/ZHUAR hm
09:56:33 <sean__> MagneticDuck tried loading them one after the other and im getting the error for the first file: Not in scope:
09:56:34 <ski> Paprikachu : or, i suppose `x' already is that, so check `x' for `""' instead ?
09:57:14 <Paprikachu> i'll better do it in a way that i would do it
09:57:20 <ski> applicative : s/17/acc/
09:57:33 <Paprikachu> but i don't understand why this returns 0
09:57:35 <Paprikachu> http://ideone.com/n7mx1
09:57:36 <applicative> ski, then it gives 0
09:57:53 <MagneticDuck> sean__: well then you have a scope problem. paste the code on hpaste.org
09:58:01 <applicative> because of parseSum
09:58:43 <ski> Paprikachu : i think you probably want  parse line = parseImpl 0 ('+':line)
09:58:45 <sean__> When i load one file the code works. Then i load the next file and the first function doesn't work
09:58:51 <monochrom> to load many files in ghci: ":load f.hs g.hs" or ":load f.hs", ":add g.hs"
09:59:00 <ski> Paprikachu : otherwise it'll try to look for a `+' or `-' at the start, which isn't there
09:59:01 <sean__> MagneticDuck so its not an error of code.
09:59:15 <MagneticDuck> sean__: sounds like you're declaring a function twice. paste the code.
09:59:38 <ski> Paprikachu : alternatively, you could parse a single integer in `parse', instead of calling `parseImpl' there with `0'
10:00:02 <MagneticDuck> LeNsTR: Do you just do that every time you go to the bathroom..? xD
10:00:21 <sean__> MagneticDuck its two files each containing two seperate functions
10:00:33 <monochrom> when you use ":load", previous things are deliberately forgotten. this is why sometimes you have to ":add"
10:00:44 <sean__> MagneticDuck one is factorial and the other is a sumAll function for lists.
10:01:01 <MagneticDuck> sean__: paste everything you have and what you're typing into ghci. :)
10:01:23 <Paprikachu> got it
10:01:25 <Paprikachu> http://ideone.com/gtFm1
10:01:27 <Paprikachu> :DDD
10:01:40 <sean__> MagnetickDuck:  :l factorial.hs /n :l sumAll.hs
10:01:46 <ski> Paprikachu : yeah, like that :)
10:02:05 <ski> instead of
10:02:06 <sean__> MagneticDuck: and like i said factorial will work but once i load sumAll it will say out of scope
10:02:07 <ski>   y = parseInt $ tail x
10:02:09 <ski> you could say
10:02:14 <ski>   (n,rem) = parseInt $ tail x
10:02:26 <ski> Paprikachu : and then use `n' and `rem' instead of `fst y' and `snd y'
10:02:42 <Paprikachu> ah right, you told me that before
10:02:54 <ski> Paprikachu : same with `acc = parseInt line', really
10:02:58 <MagneticDuck> sean__: are you using modules?
10:03:33 <sean__> MagneticDuck: no today is my first day using haskell, I don't even know whtat that is.
10:03:52 <Clint> monochrom: you've been completely ignored
10:03:52 <ski> Paprikachu : i would also replace `otherwise' there with `_' (or `rest' if you prefer a name)
10:04:02 <monochrom> not the first time or the last time
10:04:17 <applicative> Paprikachu: nice.  it's slightly more readable thus http://ideone.com/1Uih9
10:04:26 <applicative> oh ski is saying this
10:04:58 <Paprikachu> hm, this _ stuff is cool
10:05:13 <ski> `_' just means "ignore this part, i'm not interested"
10:05:19 <Paprikachu> yeah, i know
10:05:35 <Paprikachu> i already used it for '+' : _
10:05:40 * ski nods
10:05:57 <ski> i'm just pointing out that it's really what you wanted in the `otherwise -> acc' case, as well
10:06:01 <MagneticDuck> sean__: well yes. in that case the second file will put the first out of scope
10:06:31 <MagneticDuck> sean__: You need to use modules to solve your problem of using two files with two sets of functions loaded at the same time
10:06:37 <applicative> hadn't noticed that otherwise;it's not the real otherwise, its being read as if it were 'x'
10:07:06 <sean__> MagneticDuck okay thank you.
10:07:16 <sean__> exit
10:07:16 <MagneticDuck> sean__ yw
10:07:32 <zezikaro> can I ask what projects people have worked on using haskell?
10:07:33 <Peaker> it could be nice if ghc could propagate knowledge about lack of use of a result so that we wouldn't need sequence_, skip* (in parsec), and various other _ functions
10:07:56 <ski> Paprikachu : now try entering e.g. `1 + banana' as input for your parser :)
10:08:03 <Peaker> zezikaro: I'm working on a structural editor for functional programming in Haskell
10:08:28 <ski> Peaker : *nod*
10:08:35 <applicative> zezikaro: for reasons of planetary security, I am  not at liberty to say.
10:08:41 <zezikaro> what does that involve Peaker?
10:08:45 <zezikaro> o.O
10:09:18 <Paprikachu> at first tell me what's wrong here: http://ideone.com/CvI4h
10:09:19 <ski> i wonder to what extent selector-thunks do this
10:09:26 <Paprikachu> i tried to simplify it a bit
10:09:26 <Peaker> zezikaro: we implemented our own little GUI toolkit, versioned key/value store, and code editing UI on top of that
10:09:38 <Peaker> zezikaro: It's preliminary but already cute :)
10:10:13 <zezikaro> link/screeny ?
10:10:16 <ski> Paprikachu : consider when `line = "42"'
10:10:19 <Peaker> Paprikachu: why do you use ; ?
10:10:36 <ski> Paprikachu : then after the initial `parseInt' we get `result = 42' and `input = ""'
10:10:41 <Peaker> zezikaro: http://github.com/Peaker/bottle
10:10:46 <applicative> Paprikachu: it tried  to match it with the empty string
10:11:12 <ski> Paprikachu : so we call `skipSpaces ""', which is `""', and try to match it with `op : tmp', which doesn't work since `""' is the empty list/string, doesn't match
10:11:27 <Paprikachu> ._.
10:12:31 <ski> Paprikachu : so, you have to allow for the rest of the line containing only spaces, to be able to terminate properly
10:13:50 <applicative> Paprikachu: this works though it has silly indirection http://ideone.com/AQHnQ
10:14:05 <ski> Paprikachu : btw, just in case you didn't know : you can define your operations `parseImpl',`parseSum',`main',&c. in whatever order you like, there is no need to have defined e.g. `parseImpl' before `parseSum'
10:14:14 <zezikaro> Peaker any screenshots?
10:15:08 <Peaker> zezikaro: not yet, maybe I ought to take some, but it's not really useful yet
10:15:13 <Peaker> (but it is fun)
10:15:19 <ski> Paprikachu : btw, your grammar shouldn't read
10:15:22 <ski>   -- sum = primary-expression [('+' | '-') sum]*
10:15:25 <ski> it should be either
10:15:29 <applicative> Paprikachu: or better this http://ideone.com/TewRa
10:15:36 <Paprikachu> my grammar is garbage at the moment
10:15:38 <ski>   -- sum = primary-expression [('+' | '-') sum]?
10:15:39 <ski> or
10:15:46 <ski>   -- sum = primary-expression [('+' | '-') primary-expression]*
10:17:28 * pooya72 testing
10:17:50 * ski untesting
10:18:05 <Paprikachu> finnaly it works like expected: http://ideone.com/gjaYt
10:18:07 <monochrom> > 1 2 3
10:18:08 <lambdabot>   1
10:18:09 <Paprikachu> *finally
10:18:36 <Paprikachu> > tail []
10:18:37 <lambdabot>   *Exception: Prelude.tail: empty list
10:19:00 <ski> Paprikachu : looks ok
10:19:12 <zezikaro> Peaker I'm just interested, I wouldn't know how to build that github stuff
10:19:14 <ski> hm
10:19:15 <zezikaro> or even download it
10:19:31 <ski> Paprikachu : actually, the `tail' stuff could be cleaned up
10:19:33 <Paprikachu> i totally forgot that every parser has to return the input too
10:19:39 <nand`> hmm, Data.ByteString.Lazy.hGetContents errors on hClose (illegal operation (handle is closed)), but System.IO.hGetContents does not
10:19:58 <nand`> I'm trying to avoid the string IO though, since I'll be packing it into a bytestring afterwards either way
10:20:44 <monochrom> then, do not hClose
10:20:57 <applicative> zezikaro: git clone https://github.com/Peaker/bottle.git     then cd bottle  then cabal install
10:21:00 <Paprikachu> how can  it, ski?
10:21:13 <ski> Paprikachu : hm, actually, no, forget what i said :)
10:21:22 <nand`> monochrom: I'm not sure how I can avoid using hClose
10:21:27 <applicative> zezikaro: good luck with all the dependencies though
10:21:56 <monochrom> whichever hGetContent you use, you are just not supposed to hClose. I think the docs say that, too.
10:22:07 <ski> Paprikachu : what i was thinking of amounts to putting the `parseInt' call into both branches of the `case', instead of outside it
10:22:34 <ski> Paprikachu : while you may want to do that when tackling slighty larger parsers, i now recalled that you didn't want to do it atm
10:22:47 <Paprikachu> you said before that i should try entering 1 + banana, i guess it will raise an exception or something
10:22:53 <ski> yes
10:23:09 <Paprikachu> so what can i do about that?
10:23:21 <applicative> zezikaro:  GLFW-b and BerkeleyDB would presuppose that you have previously installed things with your package manager or whatever
10:23:34 <nand`> I have one thread that looks like: (lines <$> hGetContents h) >>= mapM_ process; I want to “interrupt” this from another thread (and close the socket)
10:23:39 <ski> e.g. make `parseInt' return `Just (nextval,input)' instead of `(nextval,input)'
10:23:47 <ski> then it could return `Nothing' in case of parse failure
10:23:54 <ski> which you can then `case' on, to detect
10:24:07 <applicative> zezikaro: are you just  looking for a magnificent Haskell executable?
10:24:14 <nand`> right now I'm using hClose to close the handle; but if that's not the way to do it I'm stumped
10:24:26 <ski> (or if you prefer, you can have `[(nextval,input)]' vs. `[]' instead of `Just (nextval,input)' vs. `Nothing')
10:25:01 <monochrom> that one is better off with forever (hGetLine h >>= process)
10:25:01 <ski> Paprikachu : you can make `parseInt' return this `Just (nextval,input)' by replacing `head' with `listToMaybe' (import `Data.Maybe')
10:25:18 <mparodi_> is there any difference between, for example        case 123 of 1 -> "a"; otherwise -> "b"         and      case 123 of 1 -> "a"; _ -> "b"
10:25:21 <mparodi_> ?
10:25:29 <monochrom> the general case is better off with killThread
10:25:41 <mparodi_> does the "otherwise" add anything or is it just a variable like "foo" or "_"?
10:25:48 <ski> mparodi_ : none, except that in the former case, the local variable `otherwise' is bound to `123'
10:25:49 <applicative> > otherwise
10:25:49 <lambdabot>   Ambiguous occurrence `otherwise'
10:25:50 <lambdabot>  It could refer to either `L.otherwise', d...
10:25:53 <applicative> yipe
10:25:54 <ski> @define
10:25:58 <ski> > otherwise
10:25:59 <lambdabot>   True
10:26:01 <applicative> > Prelude.otherwise
10:26:01 <lambdabot>   True
10:26:16 <applicative> > Prelude.otherwise
10:26:17 <lambdabot>   True
10:26:37 <ski> mparodi_ : "or is it just a variable" -- yes
10:26:37 <mparodi_> > case "123" of "1" -> "a"; foo -> foo
10:26:38 <lambdabot>   "123"
10:26:42 <mparodi_> it's the same with "foo"
10:27:00 <applicative> oh i see this is a question about lambabot madness not haskell
10:27:03 <ski> > case "123" of "1" -> "a"; otherwise -> reverse otherwise
10:27:04 <lambdabot>   "321"
10:27:07 <parcs`> mparodi_: otherwise is not magic
10:27:11 <Peaker> zezikaro: basically it's a "git clone ..." command followed by "cabal install" -- but it does need some C libraries to be available
10:27:16 <ski> applicative : ?
10:27:21 <mparodi_> <parcs`> mparodi_: otherwise is not magic <-- that was the question! :P
10:27:34 <applicative> ski i'm still confused
10:27:46 <mparodi_> > case "123" of "1" -> "a"; foo -> reverse foo
10:27:47 <lambdabot>   "321"
10:27:57 <applicative> mparodi_: where you wrote is there any difference between, for example        case 123 of 1 -> "a"; otherwise -> "b"         and      case 123 of 1 -> "a"; _ -> "b"
10:27:59 <mparodi_> foo works as well as otherwise
10:28:03 <parcs`> mparodi_: otherwise is a name defined in the Prelude whose value is true
10:28:05 <parcs`> True
10:28:09 <applicative> the otherwise was just a variaable youintroduced
10:28:11 <Paprikachu> so Maybe is a data type that has a "null value" like a pointer?
10:28:29 <jonaskoelker> pretty much
10:28:32 <jonaskoelker> but better :)
10:28:42 <applicative> mparodi_: you could have written foldr -> "a" or map ->  "a"
10:29:04 <Paprikachu> and what does listToMaybe do?
10:29:13 <jonaskoelker> > listToMaybe []
10:29:14 <lambdabot>   Nothing
10:29:15 <jonaskoelker> > listToMaybe [1]
10:29:16 <lambdabot>   Just 1
10:29:16 <mparodi_> oh, ok
10:29:17 <jonaskoelker> > listToMaybe [1, 2]
10:29:18 <lambdabot>   Just 1
10:29:28 <parcs`> mparodi_: 'otherwise' is used in guards to mean a base case, because it always evaluates to True
10:29:32 <jonaskoelker> probably msum
10:29:33 <Paprikachu> hm okay
10:29:44 <Paprikachu> but what if i want an error message?
10:29:47 <mparodi_> I got it. in this case it's not important since otherwise there is just a variable like foo, but it's important when you use | otherwise = since its value is already defined as True
10:29:54 <jonaskoelker> Either String MyResultType
10:29:58 <mparodi_> | foo = ...         ->          Not in scope: `foo'
10:30:04 <parcs`> yeah
10:30:24 <Paprikachu> ?
10:30:27 <nand`> monochrom: the problem with forever $ hGetLine h >>= ... is that it errors when h is EOF, so I have to change it to a more verbose tail-recursive construct that checks hIsEOF as well (which incidentally also errors after hClose)
10:30:29 <ski> > let map foldl [] = []; map foldl ((foldl -> foldr):(map foldl -> scanr)) = foldr : scanr in map toLower "FOLDR"
10:30:30 <lambdabot>   "foldr"
10:30:39 <nand`> I wish there was a hIsClosed :: Handle -> IO Bool
10:30:42 <jonaskoelker> Paprikachu: it's a standard type, like maybe, defined like "data Either a b = Left a | Right b"
10:30:51 <mparodi_> ski, what a confusing way to write "foldr"!
10:31:07 <parcs`> mparodi_: if you enable -Wall, you'll get an unused variable warning if you mistakenly use 'otherwise' in a case pattern or something
10:31:08 <ski> Paprikachu : if you want an error message, is that the business of `parseSum' ? -- shouldn't the caller of it decide what the message should be ?
10:31:11 <jonaskoelker> > either id show $ Left "error message"
10:31:13 <lambdabot>   "error message"
10:31:18 <jonaskoelker> > either id show $ Right (2 + 2)
10:31:19 <lambdabot>   "4"
10:31:36 <monochrom> then add exception handling. catch (forever (hGetLine h >>= process)) (\_ -> return ())
10:31:37 <Paprikachu> parseInt should return an error message when it was unable to parse an int
10:31:59 <ski> `Nothing' will act as a "parse error" message
10:32:11 <mparodi_> Warning: This binding for `otherwise' shadows the existing binding imported from Prelude
10:32:16 <parcs`> well actually an unused variable warning and a shadow warning
10:32:17 <mparodi_> your're right parcs`
10:32:18 <nand`> monochrom: I already have exception handling, I just don't know how to catch the “illegal operation (handle is closed)” error
10:32:25 <Paprikachu> but Nothing does not give any useful information
10:32:40 <ski> if you want to be able to distinguish between different parse errors, you can use `Left msg' instead of `Nothing' and `Right (nextval,input)' instead of `Just (nextval,input)'
10:33:06 <Paprikachu> can you show me how i can rewrite parseInt that way?
10:33:32 <monochrom> you have not already tried my exact code
10:33:43 <jonaskoelker> nand`: to find out the type, throw and catch SomeException and print its typeOf in ghci
10:33:56 <ski>   parseInt = maybe (Left "can't parse int") Right . listToMaybe . (reads :: String -> [(Int, String)]);
10:33:59 <ski> e.g.
10:34:05 <ski> Paprikachu ^
10:34:12 <jonaskoelker> (someone in here suggested that to me earlier today)
10:34:33 <mparodi_> can't I define a data type in interactive mode?
10:34:37 <Paprikachu> okay, i don't get that
10:34:42 <mparodi_> > data Foo = False | True
10:34:43 <lambdabot>   <no location info>: parse error on input `data'
10:34:50 <mparodi_> > let data Foo = False | True
10:34:51 <lambdabot>   <no location info>: parse error on input `data'
10:35:08 <jonaskoelker> mparodi_: I think not
10:35:09 <monochrom> you can define a data type in ghci 7.4
10:35:10 <ski> Paprikachu : `listToMaybe' converts the list to either `Nothing' or `Just (value,rest)'
10:35:20 <hpc> :t listToMaybe
10:35:20 <lambdabot> forall a. [a] -> Maybe a
10:35:23 <mparodi_> hm.. mine is...
10:35:30 <ski> Paprikachu : then the `maybe ...' converts that to either `Left "can't parse int"' or `Right (value,rest)'
10:35:33 <mparodi_> 7.04
10:35:40 <mparodi_> 7.0.4 actually
10:35:47 <monochrom> then you can't
10:35:47 <ski> Paprikachu : you could write this with `case' directly as well -- `maybe' is just a utility function
10:36:40 <Siod> does anyone know when the next version of haskell platform comes out?
10:36:45 <monochrom> orthogonally, lambdabot's ">" goes through a different path, which does not support a lot of things
10:36:55 <jonaskoelker> ski: wait, what, how does that work?  reads returns [] when there's no valid parse?
10:37:18 <mparodi_> @def Bool
10:37:18 <lambdabot> Maybe you meant: bf do let
10:37:25 <ski>   parseInt input = case reads input :: [(Int, String)] of
10:37:28 <ski>     [(value,rest)] -> Right (value,rest)
10:37:28 <ski>     _ -> Left "can't parse int"
10:37:33 <applicative> Siod, I think it is supposed to be bad taste to ask.  But I tested the provisional os x installer the other day so things are happening
10:37:33 <ski> would also work, if you prefer it
10:37:38 <mparodi_> Bool is a data, right?
10:37:40 <ski> jonaskoelker : yes
10:37:48 <monochrom> Bool is a data
10:38:02 <mparodi_> monochrom, but I can redefine True and False!
10:38:10 <jonaskoelker> ski: shouldn't the "." after Right be a "$" ?
10:38:14 <mparodi_> data Foo = False | True
10:38:19 <ski> Paprikachu : you can read "Right" as "correct (parse)", if you want to
10:38:32 <monochrom> yes you can. there is no contradiction
10:38:47 <mparodi_> monochrom, but there is a contradiction if I define Bar in the same way
10:38:54 <mparodi_> >> if I add data Bar Multiple declarations of `Main.True'
10:38:57 <jonaskoelker> ski: otherwise it returns an Either String (Maybe (Int, String)), right?
10:38:58 <ski> jonaskoelker : no, it's a composition chain (a "pipeline")
10:39:06 <mparodi_> err, Multiple declarations of `Main.True'
10:39:15 <monochrom> Prelude.True vs Main.True
10:39:21 <jonaskoelker> :t maybe (Left "foo") Right . listToMaybe . (reads :: String -> [(Int, String)])
10:39:22 <lambdabot> String -> Either [Char] (Int, String)
10:39:41 <mparodi_> ah, so you can't define it twice in the same module!
10:39:42 <monochrom> where "Prelude" and "Main" are module names
10:39:43 <mparodi_> it makes sense
10:40:06 <jonaskoelker> ski: so where's the Maybe that gets fed to maybe?
10:40:11 <mparodi_> even tough they're somehow different. Main.Foo.True vs Main.Bar.True
10:40:16 <jonaskoelker> sorry for being dense ^_^
10:40:22 <ski> jonaskoelker : output from `listToMaybe'
10:40:53 <jonaskoelker> why doesn't that get fed to Right?
10:40:55 <cheater_> hi
10:41:02 <mparodi_> s/tough/so/
10:41:03 <cheater_> there is a version of Haskell in foreign languages, isn't there?
10:41:04 <ski> lo cheater_
10:41:24 <mparodi_> it's not like an enum as I can see, monochrom
10:41:54 <monochrom> haskell namespace division is not that fine-grained
10:42:48 <ski> Paprikachu : the `parseInt' i wrote first was just a "does the job" version, i was assuming you wanted to concentrate on the `parseImpl' stuff -- if you want the longer, more explicit version, it should works as well
10:43:13 <dzastinas>  "let" keyword is abbreviation?
10:43:28 <Paprikachu> how can i concatenate two lists?
10:43:45 <jonaskoelker> dzastinas: no?  I maybe not understand your question, but I'm guessing "no" is the answer you want
10:43:51 <jonaskoelker> l1 ++ l2
10:44:07 <jonaskoelker> :hoogle '[a] -> [a] -> [a]'
10:44:14 <jonaskoelker> @hoogle '[a] -> [a] -> [a]'
10:44:15 <lambdabot> Parse error:
10:44:15 <lambdabot>   '[a] -> [a] -> [a]'
10:44:15 <lambdabot>   ^
10:44:18 <jonaskoelker> @hoogle [a] -> [a] -> [a]
10:44:19 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
10:44:19 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
10:44:19 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
10:44:53 <Paprikachu> @index listToMaybe
10:44:53 <lambdabot> Data.Maybe
10:44:56 <nand`> mplus and mappend work too :P
10:45:34 <jonaskoelker> as does foldr (:) l2 l1 :D
10:46:04 <Paprikachu> http://ideone.com/H1IZw
10:46:07 <Paprikachu> whats wrong here?
10:47:15 <monochrom> "let" keyword is not an abbreviation
10:47:25 <dzastinas> ok thanks
10:47:29 <ion> The type of reads is “String -> blah”, the type of reads foo is just “blah”.
10:47:37 <applicative> Paprikachu: the signature  String -> [(Int, String)] should be attached to reads only,
10:47:44 <byorgey> Paprikachu: the problem is that you are claiming that 'reads line' has type  String -> [(Int, String)], but it does not have that type.
10:47:56 <Paprikachu> so how can i correct that?
10:48:01 * MagneticDuck is away: Doing things. Practicing piano. I will be back on later today probally and I will take a video tutorial of a new shape of mine, the triple helix.
10:48:03 <jmcarthur> once reads has been applied to an argument, it no longer expects an argument
10:48:11 <jmcarthur> just remove the argument from the type annotation
10:48:14 <jonaskoelker> Paprikachu: ... $ (reads :: String -> ...) line
10:48:19 <jmcarthur> or that
10:48:20 <applicative> (reads :: String -> [(Int, String)]) line
10:48:26 <jmcarthur> my suggestion would be less verbose
10:48:37 <jmcarthur> (reads line :: [(Int, String)])
10:48:38 <applicative> (reads line :: [(Int, String)])
10:48:44 <ion> (reads :: ReadS Integer) line
10:48:52 <applicative> ion wins
10:49:02 <dzastinas> Other question, How should i read "map" declaration (a -> b) -> [a] -> [b], how this function would look in Java?
10:49:06 <jmcarthur> at least if you say ReadS Int instead
10:49:06 <jonaskoelker> wouldn't "result :: Int" work as well?
10:49:12 <ski> Paprikachu : `reads line :: [(Int,String)]' or `(reads :: ReadS Int) line'
10:49:15 <Paprikachu> http://ideone.com/aBii0
10:49:17 <Paprikachu> QQ
10:49:43 <ski> now you need to fix the calls to `parseInt'
10:49:56 <jonaskoelker> dzastinas: see greenspun's tenth rule :->
10:50:01 <jmcarthur> dzastinas: the a and b types would be something like generics in java
10:50:02 <ski> instead of
10:50:04 <ski>   let (result, input) = parseInt line
10:50:10 <ski>   in parseImpl result input;
10:50:12 <ski> you want
10:50:16 <jonaskoelker> dzastinas: (or don't, that's just me having fun at java's expense)
10:50:22 <ski>   case parseInt line of
10:50:24 <mzero> Siod: We hope it will land this week
10:50:30 <ski>     Left msg -> something here
10:50:36 <Paprikachu> isn't there a way to just throw an exception and don't change functions for the "working" case?
10:50:40 <mzero> Siod: RC3 or RC4 versions of the installers should show up ... today!
10:50:41 <ski>     Right (result, input) -> parseImpl result input
10:50:51 <jmcarthur> dzastinas: i don't know how to express higher order functions in java though. do you still have to make special objects just for them nowadays?
10:50:55 <ski> Paprikachu : if you use monads
10:51:17 <jmcarthur> for the function parameters, that is
10:51:20 <Paprikachu> is that easier to write/understand?
10:51:28 <ski> depends
10:51:39 <ski> when you understand monads, it's easier to write/understand :)
10:51:53 <Paprikachu> i don't even know what a monad is
10:52:01 <ion> @google java map function
10:52:03 <lambdabot> http://stackoverflow.com/questions/3907394/java-is-there-a-map-function
10:52:03 <lambdabot> Title: Java: is there a map function? - Stack Overflow
10:52:12 <Siod> mzero: awesome :)
10:52:14 <dzastinas> i understand the result type of "map" functions its array [b], but input is also [a], [b].
10:52:25 <dzastinas> but (a ->b)
10:52:28 <dzastinas> ?
10:52:34 <dzastinas> dont get this part :)
10:52:36 <jonaskoelker> dzastinas: nope, its inputs are of type [a] and (a -> b)
10:52:38 <ski> Paprikachu : a monad here is just a couple of utility functions which help you avoid the boiler-plate on having to `case' all the time on `Left ..' and `Right ...'
10:52:46 <jonaskoelker> dzastinas: that's a function that takes something of type a and returns something of type b
10:53:05 <ski> Paprikachu : the monad will also handling updating the `line'/`tmp'/`input' for you, as a bonus
10:53:29 <jmcarthur> dzastinas: http://stackoverflow.com/questions/4861023/java-generics-how-to-encode-a-functor-interface-in-java
10:53:30 <jonaskoelker> dzastinas: in java, you might want to have "Interface function { public <A, B> B call(A arg); }"
10:53:58 <ski> Paprikachu : but doing it "the explicit way" first can help with understanding what really happens, when using the monad
10:54:05 <jmcarthur> dzastinas: tl;dr: just don't do it in java ;)
10:54:15 <Paprikachu> okay, then i'll do it explicit
10:54:17 <dzastinas> ok thanks a lot of info, i need do digest it
10:54:42 <jonaskoelker> I second jmcarthur :)
10:55:01 <applicative> Paprikachu: this typechecks, but note all the unhandled cases http://ideone.com/p3wNB
10:55:32 <jmcarthur> dzastinas: i promise it's not worth trying to understand it in terms of java
10:55:45 <ski> Paprikachu : yeah, you could start working from applicative's version, changing it to not "crash" on parse failure
10:55:53 <jmcarthur> dzastinas: map takes a function on normal types and returns a function to work on lists of those types instead
10:56:19 <jmcarthur> dzastinas: think of it with parens like this:   (a -> b) -> ([a] -> [b])
10:56:23 <dzastinas> oh, ok, but still it dosnt work in java, becouse you can not put function as a parameter?
10:56:39 <dzastinas> (a -> b) -> ([a] -> [b])
10:56:43 <jmcarthur> dzastinas: it can be make to work in java, some may claim, but it's waaaay to verbose
10:56:47 <jmcarthur> *too
10:56:54 <jmcarthur> s/verbose/boilerplatey and nasty/
10:57:26 <dzastinas> so basicly (a -> b) input and ([a] -> [b]) result?
10:57:36 <Eduard_Munteanu> jmcarthur: isn't the visitor pattern mostly the same thing? They seem to do that quite a bit.
10:57:58 <jmcarthur> Eduard_Munteanu: is that a claim that it's not boilerplatey and nasty?
10:58:09 <Eduard_Munteanu> jmcarthur: um, no, it is nasty :)
10:58:09 <ski> Paprikachu : to use the monadic version, you basically define a type `type Parser a = String -> Either String (a,String)' and two utility functions `returnP :: a -> Parser a' and `bindP :: Parser a -> (a -> Parser b) -> Parser b' (every monad must implement these two functions, `Parser' is an example of a monad)
10:58:23 <jonaskoelker> Paprikachu: unless I'm misreading your code, "1 1 +" would parse
10:58:36 <jmcarthur> Eduard_Munteanu: also, it's not *quite* the same thing. once can always tweak the haskell version in ways that are much more difficult in java
10:58:49 <ski> jmcarthur : parses to `1', yes
10:58:53 <ski> er
10:58:57 <jmcarthur> but some of the essense is there, still
10:58:57 <Paprikachu> jk: it would, because there is no check for an empty line at the end
10:58:57 <ski> jonaskoelker ^
10:59:00 <jonaskoelker> gotcha :)
10:59:23 <Eduard_Munteanu> dzastinas: yeah, you give it a function on elements and it gives you back a function on lists of such elements.
10:59:24 <Paprikachu> i know that it's missing, i just want to concentrate on implementing the parser
10:59:30 <jonaskoelker> Paprikachu: but don't you want "1 + 1" rather than "1 1 +"?  That's what your regexp says...
10:59:43 <ski> applicative : actually .. are you sure that type-checks ?
10:59:43 <Paprikachu> 1 1 + is an error
10:59:46 <Eduard_Munteanu> > map succ [1,2,3,4]
10:59:47 <lambdabot>   [2,3,4,5]
10:59:55 <Eduard_Munteanu> > (map succ) [1,2,3,4]
10:59:56 <lambdabot>   [2,3,4,5]
11:00:07 <ski> > map ord ['a','b','c']
11:00:08 <lambdabot>   [97,98,99]
11:00:18 <jmcarthur> dzastinas: think of it as a variation of foreach, where the code block you use is just another parameter to the function
11:00:46 <mikkihiiri> I have to lists of type a and b and a function that takes parameters of type a and b. Is there some easy way to run this function to all combinations of these two lists?
11:00:47 <Eduard_Munteanu> > let foreach = flip map in foreach [1,2,3,4] succ
11:00:49 <lambdabot>   [2,3,4,5]
11:00:50 <mikkihiiri> to=two
11:00:52 <jmcarthur> > let for = flip map in    for [1,2,3,4,5] (\x -> x * 5)   -- dzastinas
11:00:52 <Paprikachu> http://ideone.com/H1xVM
11:00:53 <lambdabot>   [5,10,15,20,25]
11:00:56 <jmcarthur> lol
11:00:59 <Paprikachu> how can i make it print the error message?
11:02:04 <jonaskoelker> can I wget a URL into an emacs buffer?
11:02:08 <jonaskoelker> (sorry, that's OT)
11:02:27 <Eduard_Munteanu> Paprikachu: use Either for parseImpl too
11:02:55 <ski> Paprikachu : i think `_ -> acc' should be `_ -> Right acc'
11:02:56 <Eduard_Munteanu> Paprikachu: you can use Either as a monad and let it propagate errors
11:04:24 <ski> Paprikachu : anyway, you need to use `case' on `parseInt line' and `parseInt $ tail tmp', instead of binding in a `let'
11:04:30 <ski> so that you can handle both cases
11:04:37 <ski>   case parseInt line of
11:04:47 <ski>     Left errorMsg -> Left errorMsg
11:05:04 <ski>     Right (result,input) -> parseImpl result input
11:05:38 <Paprikachu> this stuff is annoying
11:05:40 <ski> applicative : ok, i see it type-checks, because `parseImpl' is only tail-calling itself
11:06:04 <dzastinas> so that information i can read from first part of "map" (a -> b) ...
11:06:11 <Paprikachu> it's like errocodes in plain C
11:06:16 <ski> yes
11:06:21 <Paprikachu> you have to check it in every function that uses it
11:06:32 <ski> using a `Parser' monad will hide this boiler-plate
11:07:02 <dzastinas> map input is a nad result b? which is later given to other function as input?
11:07:09 <jmcarthur> Paprikachu: you can hide all that junk with a monad
11:07:21 <jmcarthur> Paprikachu: whether it be a parser monad as was suggested or even just the Either monad
11:07:32 * ski nods
11:07:49 <Paprikachu> how can i think of a parser monad?
11:07:57 <jmcarthur> > do { x <- Right 5; y <- Right 3; return (x + y) }
11:07:58 <lambdabot>   Right 8
11:08:04 <jmcarthur> > do { x <- Right 5; y <- Left "error"; return (x + y) }
11:08:05 <lambdabot>   Left "error"
11:08:29 <ski> > do { x <- Left "error"; y <- error "not reached"; return (x + y) }
11:08:30 <lambdabot>   Left "error"
11:08:46 <applicative> ski, oh, is it wrong, it was a  mechanical transformation
11:08:55 <ski> applicative : no, it's ok
11:09:10 <jmcarthur> > do { x <- Right (error "This isn't technically reached either!"); y <- Left "error"; return (x + y) }
11:09:11 <lambdabot>   Left "error"
11:09:14 <Paprikachu> throw "foobar";
11:09:16 <Paprikachu> :(
11:09:19 <ski> applicative : it's just that `parseImpl' itself doesn't return any `Left blah' stuff
11:09:35 <jonaskoelker> @type (map (\x -> x + 1))
11:09:36 <lambdabot> forall a. (Num a) => [a] -> [a]
11:09:38 <jonaskoelker> dzastinas: ^^^
11:09:51 <hc> >
11:09:56 <applicative> ski I see but we'll want it to
11:09:59 <ski> Paprikachu : the `do'-notation jmcarthur showed is just a thin wrapper over the basic monadic operations
11:10:01 <hc> > let add up = evalState (look up) where look funny = get >>= \life -> if real life then return funny else put (life-1) >> look (funny+1); real sex = (sex == 0)
11:10:03 <lambdabot>   not an expression: `let add up = evalState (look up) where look funny = get...
11:10:05 <ski> applicative : indeed
11:10:20 <jmcarthur> Paprikachu: by "thin wrapper" ski means "syntax sugar"
11:10:25 <ski> yes
11:10:31 <jonaskoelker> dzastinas: if I give `map' the function which adds one to its argument, map gives me back a function which operates on a list
11:10:38 <jonaskoelker> dzastinas: if I then apply than to a list, I get a list back
11:10:40 <jmcarthur> @undo do { x <- Right 5; y <- Right 3; return (x + y) }
11:10:41 <lambdabot> Right 5 >>= \ x -> Right 3 >>= \ y -> return (x + y)
11:10:52 <jonaskoelker> > map (\x -> x + 1) [1..5]
11:10:53 <lambdabot>   [2,3,4,5,6]
11:10:58 <ski> Paprikachu : so .. i assume you want to know how these "monadic operations" work, yes ?
11:11:09 <newsham> papr: parser monad has actions that consume input and return parsed data, or return an error.  the bind operator lets you run one parser first then another parser second.  there's also an alternation operator which tries one parser and if it fails will try another
11:11:12 <jonaskoelker> dzastinas: that's equivalent to > (map (\x -> x  + 1)) [1..5]
11:11:18 <jonaskoelker> (note the parentheses)
11:11:33 <Paprikachu> if that's required to implement it the not-annoying way, then yes
11:11:56 <jmcarthur> i don't think i'd say it's required
11:12:02 <jmcarthur> it's something that can be picked up as you use it
11:12:13 <dzastinas> i think i undersntad the process of map. but the declaration still confuse me, i should read the rules, how to read declation types or something
11:12:35 <jonaskoelker> dzastinas: basically 'x -> y' is a function that takes an x and returns a y
11:12:44 <jonaskoelker> dzastinas: and '->' is right-associative
11:12:45 * ski ponders suggesting we move to #haskell-overflow, to avoid some of the noise
11:12:57 <jonaskoelker> dzastinas: so 'a -> b -> c -> d' is the same as 'a -> (b -> (c -> d))'
11:13:04 <jmcarthur> nah don't go to overflow
11:13:09 <ski> ok
11:13:10 <dzastinas>  -> its like pipelines in unix?
11:13:18 <ski> Paprikachu : in general, for a monad `M' (which is a "generic type"), you need to implement two functions `return :: a -> M a' and `bind :: M a -> (a -> M b) -> M b'
11:13:31 <jmcarthur> going to overflow is a great way to stifle input from other people :\
11:13:46 <ski> Paprikachu : in your case (if we forget about the parsing, and only consider the error handling), the monad is `Either String', where the `String' is the error message
11:13:53 <jonaskoelker> dzastinas: uhm... hmm.. well, pipelines are basically function _composition_, and '->' is the function type
11:14:07 <jonaskoelker> dzastinas: so they're related, but different
11:14:26 <jonaskoelker> dzastinas: (as an aside, "." is haskellese for function composition)
11:14:29 <jmcarthur> :t (.)    -- dzastinas: this is the type of "pipelines"
11:14:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:14:35 <ski> Paprikachu : e.g. we'll want to get `parseSum :: String -> Either String Int', where `Either String Int' either is `Left errorMessage', or `Right result'
11:14:36 <jmcarthur> err
11:14:38 <jmcarthur> ugh
11:14:43 <jmcarthur> dzastinas: not that :)
11:14:43 <jonaskoelker> ((+1) . (*2)) 5
11:14:43 <ski> Paprikachu : ok, so far ?
11:14:45 <jonaskoelker> > ((+1) . (*2)) 5
11:14:47 <lambdabot>   11
11:14:47 <Paprikachu> yep
11:14:56 <jmcarthur> :t (Prelude..)    -- dzastinas: this
11:14:57 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
11:15:19 <jmcarthur> dzastinas: (.) is a function that takes two functions and chains them together, somewhat like a unix pipe
11:15:19 <ion> > ((+1) (*2)) 5
11:15:20 <lambdabot>   11
11:15:24 <ion> > (+1) (*2) 5
11:15:25 <lambdabot>   11
11:15:33 <ski> Paprikachu : conceptually, we think of a value of type `Either String Foo' as either having "raised an exception" (the `errorMessage' above), or "returned normally" a `result'
11:15:56 <ski> Paprikachu : of course, a value of type `Either String Foo' *really* is just a container which contains either the error message, or the result
11:16:12 <ski> Paprikachu : but the point is to think of it as something what "raises an exception" or "returns normally"
11:16:37 <jonaskoelker> ion: huh?  That don't no typecheck in mah haskell...
11:16:53 <ski> now, to avoid having to write the tiresome `case' on `Left' and `Right', we'd prefer if we could do it *once and only once*
11:17:17 <ion> jonaskoelker: lambdabot has a funky Num instance for functions.
11:17:26 <ski> Paprikachu : conceptually, we want to be able to "run one potentially-exception-throwing computation after another"
11:17:34 <ski> which suggests writing a function
11:17:40 <jonaskoelker> ion: ah... very... interesting :)
11:17:48 <ion> jonaskoelker: You can run :t (+1) (*2) 5 in ghci and see what instances it would use.
11:17:54 <ski>   then :: Either String a -> Either String b -> Either String b
11:18:08 <jonaskoelker> oh yeah
11:18:20 <ski>   then action0 action1 = case action0 of
11:18:21 <jonaskoelker> heh, that's neat.  Surely that'd work for fractional as well
11:18:21 <hpc> :t (+1) (*2) 5 -- you can also do it now
11:18:22 <lambdabot> forall a. (Num a) => a
11:18:27 <ski>     Left errMsg -> Left errMsg
11:18:39 <ski>     Right _ -> case action1 of
11:18:41 <hpc> oh, hmm
11:18:42 <ski>       Left errMsg -> Left errMsg
11:18:51 <ski>       Right result -> Right result
11:18:59 <ion> @hackage NumInstances
11:19:00 <lambdabot> http://hackage.haskell.org/package/NumInstances
11:19:04 <Paprikachu> a -> b -> c is c func(a, b) in pseudo-C notation?
11:19:14 <hpc> Paprikachu: yes
11:19:35 <hpc> well, more or less
11:19:36 <ski> Paprikachu : whis function `then' will use `case' for us, first checking if the first action failed with an error message, in that case aborting (not doing the second action) and giving that error message
11:19:53 <ski> Paprikachu : otherwise, we check the other action, and return either an error message or a result
11:19:55 <jonaskoelker> Paprikachu: actually it's (c func(b)) func(a)
11:20:08 <jonaskoelker> (a function one one argument that returns a function)
11:20:15 <ski> Paprikachu : however, note the `_' in there
11:20:30 <ski> that means that we're forgetting the result (if any) of the first action
11:20:43 <ski> generally, we'd like to decide what to do next, depending on the result of the first action
11:20:50 <ski> for this reason, we change
11:20:55 <ski>   then :: Either String a -> Either String b -> Either String b
11:20:56 <ski> into
11:21:04 <ski>   bind :: Either String a -> (a -> Either String b) -> Either String b
11:21:22 <coppro> style question: is it unreasonable to define a function with the same interface as a constructor to guard against interface changes?
11:21:30 <ski>   bind (Left  errMsg) a_action = Left errMsg
11:21:30 <coppro> and then not export the constructor?
11:21:42 <ski>   bin (Right result) a_action = a_action result
11:21:46 <ski> s/bin/bind/
11:21:55 <newsham> coppro: sounds reasonable to me (why wouldnt it be?  do you have objections?)
11:21:56 <Eduard_Munteanu> coppro: depends, you won't be able to pattern-match
11:22:03 <ski> Paprikachu : i simplified it a little bit as well, but that's it
11:22:18 <ski> Paprikachu : now, assuming we also change `parseImpl' we can write
11:22:25 <dzastinas> so (a -> b) -> [a] -> [b] states, that this function takes parameter (a ->b). Then iterates array, and then opperates with list [a], and list [b]?
11:22:40 <jonaskoelker> coppro: I think that might guard against underlying-implementation changes, but I'm not sure how it'd guard against interface changes ... ?
11:23:03 <newsham> dzastinas: its a func that takes in a func of type (a->b) and a list of a's, and returns a list of b's
11:23:09 <ski>   parseSum line = bind (parseInt line) (\(result,input) -> parseImpl result input)
11:23:19 <ski> though more commonly it would be written like
11:23:23 <newsham> or alternately you can think of it as:  (a -> b) -> ([a] -> [b])    a func that takes in an (a->b) and returns a new func ([a] -> [b])
11:23:28 <ski>   parseSum line =
11:23:33 <ski>     bind (parseInt line) \(result,input) ->
11:23:34 <ski>     parseImpl result input
11:23:39 <ski> or, using the `do'-sugar
11:23:41 <ski>   parseSum line =
11:23:53 <ski>     do (result,input) <- parseInt line
11:24:00 <ski>        parseImpl result input
11:24:24 <ski> Paprikachu : note how the tiresome `case' on `Left' and `Right' disappeared inside `bind' ? :)
11:24:32 <ski> Paprikachu : we can do the same inside `parseImpl'
11:24:55 <newsham> ski (and paprikachu): btw, i've got http://www.thenewsh.com/~newsham/formal/parse/parser.lhs if it helps
11:24:58 <dzastinas> oh it takes two paramets so first is (a->b) and i can say its function. i can say this from brackets :)? or by? and secand argument is [a], and result is [b] list
11:25:08 <ski> (actually, `bind (parseInt line) \(result,input) ->' above should be `bind (parseInt line) $ \(result,input) ->')
11:25:46 <newsham> yah the parenthesis let you see that its a function
11:25:55 <dzastinas> ok not function but function type
11:26:20 <ski> Paprikachu : yeah, you might want to check out newsham's <http://www.thenewsh.com/~newsham/formal/parse/parser.lhs>
11:26:21 <newsham> dzastinas: in haskell all functions are curried so in reality all funcs are funcs of just one arg, but we can pretend that they're functions of multiple args
11:27:00 <newsham> if you see:  a -> b -> c -> d it means  a -> (b -> (c -> d))    but we often pretend it just means   (a,b,c) -> d
11:27:19 <dzastinas> oh ok
11:28:02 <hc> hi, quick question on 'cabal install semigroups':
11:28:14 <hc> i'm getting the error "You need -XDeriveDataTypeable to derive an instance for this class" -- is there a quick fix to that, like passing that parameter to cabal?
11:28:15 <ski> dzastinas : so, `map' is a function that takes a function as input, and returns a function as output (and that function takes a list as input, calling the first function input on every element of it, returning the resulting list)
11:28:23 <ski> @type ord
11:28:24 <lambdabot> Char -> Int
11:28:27 <ski> @type map ord
11:28:27 <lambdabot> [Char] -> [Int]
11:28:34 <ski> @type map ord ['a','b','c']
11:28:35 <lambdabot> [Int]
11:28:38 <ski> @type (map ord) ['a','b','c']
11:28:38 <lambdabot> [Int]
11:28:40 <ski> > map ord ['a','b','c']
11:28:41 <lambdabot>   [97,98,99]
11:29:32 <ski> > map (map succ) [[],[0],[1,2],[3,4,5],[6,7,8,9]]
11:29:33 <lambdabot>   [[],[1],[2,3],[4,5,6],[7,8,9,10]]
11:29:34 <ryankarason> question: i am writing a paper about haskell and reasoning about programs. particularly looking at software verification. since haskell is so mathematical it seems many of this verification can be done by stand math proofs. does anyone know of any good documentation about this subject?
11:29:48 <ion> hc: Add {-# LANGUAGE DeriveDataTypeable #-} to the beginning of the file.
11:29:50 <dzastinas> return a function :), i have to change the way i think
11:29:50 <Paprikachu> sorry, but i think that's a bit too much at once
11:30:01 <Paprikachu> at least for me :|
11:30:02 <ion> hc: Sorry, i missed your first line.
11:30:22 <ski> dzastinas : `succ' is the function that adds one to a number. then `map succ' returns the function that adds one to every element of a list
11:30:27 <newsham> ryan: blog style article on the subject:  http://www.thenewsh.com/~newsham/formal/reverse/
11:30:32 <ion> hc: Yeah, i think there’s a line you can add to semigroups.cabal to add the -X… to all ghc invocations.
11:30:46 <ski> dzastinas : and this function is passed to `map', to add one to every element of every element of a (twice nested) list
11:31:11 <ion> hc: But i wonder why it doesn’t build on your system in the first place? Seems to work fine here.
11:31:40 <jonaskoelker> dzastinas: yep---and having to change (expand) one's mind is one of the benefits of learning different programming paradigms :)
11:31:59 <newsham> ryan: there are entire computer languages designed to enable assisted proof development.  some are closely related to haskell.  the most popular one is called coq, there's also agda (closely related to haskell) and isabelle/hol.
11:32:07 <hc> ion: it's a debian stable (squeeze), with a fresh haskell-platform install
11:32:15 <newsham> there are freenode channels for #coq and #agda, too.
11:33:09 <ski> Paprikachu : what `bind' does is factor out the annoying checking for "error code" out of the main code
11:33:37 <newsham> papr: there's a firehose of information on this stuff :)
11:34:18 <ski> Paprikachu : did you try looking at <http://www.thenewsh.com/~newsham/formal/parse/parser.lhs> yet ?
11:34:35 <Paprikachu> nope, i tried to understand what you were saying
11:34:38 <ski> ok
11:35:10 <ski> `then'/`bind' is a way to combine "two computations which may throw an expecption" into a single one
11:35:44 <ski> the important point here is that if the first one "throws an exception", we want to abort with that error message, instead of also doing the second one
11:35:56 <basti_> hi people
11:35:57 <b_jonas> this channel is great. there's so many thing you can learn by just listening here.
11:35:57 <ski> and this is what `then'/`bind' does
11:36:10 <Paprikachu> that's why you used the case construct
11:36:14 <ski> yes
11:36:24 <basti_> i'm having a memory leak in a foldl construction. I tried using "foldl'", but to no avail
11:36:37 <ryankarason> thanks newsham!
11:36:43 <ski> in the `bind' version, i avoided using `case', instead giving two clauses for `bind' -- but i could have used `case' instead, it's the same thing
11:36:48 <basti_> how would you go about fixing such a thing?
11:36:49 <newsham> ryan: you're welcome
11:37:10 <Eduard_Munteanu> basti_: mm, pastebin the code?
11:37:19 <ski> Paprikachu : if you want to, i could write a version of `bind' using `case' as well ..
11:37:55 <basti_> Eduard_Munteanu: i got it in a git repository which i might update or i'd try to paste the section i believe to be the culprit
11:38:18 <Paprikachu> no, you don't need to, it's just pattern matching
11:38:21 <kstt> hello
11:38:30 <ski> ok
11:38:31 <Eduard_Munteanu> kstt: hi
11:38:41 <b_jonas> an Either monad, yay!
11:38:50 <hc> ion: but patching that config file seems to have helped :)
11:38:53 <Eduard_Munteanu> basti_: yeah, either pastebin or push to a temporary branch etc.
11:38:56 <ski> Paprikachu : so, let's assume that we have written
11:38:56 <ion> hc: I recommend avoiding the system Haskell packages and installing a newer version of GHC to your home directory: https://gist.github.com/2815423
11:39:04 <basti_> https://github.com/bastiaanzapf/som < this is the git repository
11:39:09 <kstt> how portable is a "cereal" dump please ? Can it be loaded on a different architecture ? By a binary built with a different compiler ?
11:39:16 <basti_> oh, but the data file is missing
11:39:32 <Clint> kstt: depends on the instances
11:39:59 <basti_> there it is
11:40:02 <hc> ion: i thought about that, but then i saw the packages i'm using on the haskell website and figured they'd be quite up-to-date... if i run into more troubles of this sort, i will install it from sources, though
11:40:12 <ski>   parseOp :: Num a => String -> Either (a -> a -> a,String)
11:40:22 <ski> then we could write `parseImpl' something like
11:40:35 <basti_> I need to do that as a "pure" computation because that parallel haskell framework expects pure computations
11:40:51 <kstt> Clint: ok
11:41:01 <ski>   parseImpl line0 =
11:41:35 <basti_> "somtest" has a main which will demonstrate the problem
11:41:46 <ski> oh, right, we need some way to terminate it as well
11:42:04 <ion> hc: GHC 6.12.1 was released in December freaking 2009. :-P
11:42:06 <Paprikachu> what does the type signature mean?
11:42:14 <Paprikachu> escpecially the =>
11:42:28 <ski> ok, i guess we could simplify it to
11:42:39 <ski>   parseOp :: String -> Either (Int -> Int -> Int,String)
11:42:52 <ski> (obsessive-compulsive generalization !)
11:43:17 <monochrom> ghc 6.12.1 has a bug: http://www.vex.net/~trebla/haskell/sicp.xhtml#ghc6121
11:43:31 <ski> Paprikachu : the idea was to write a parser which parses an operator symbol (`+' or `-' here) and returns the function `(+)' or `(-)' to use
11:43:54 <monochrom> I do not always recommend upgrading to the bleeding edge, but you should either go back to 6.8 or go forward to at least 6.12.3
11:44:08 <Eduard_Munteanu> basti_: so which is the culprit?
11:44:12 <monochrom> err, s/6.8/6.10/
11:44:15 <ski>   parseImpl acc line0 =
11:44:25 <Paprikachu> so parseOp is a function that takes a string (the line to parse) and returns either an error message (if the parsing fails) or a function that takes two ints (operands of the operator?) and returns the result of aplying it?
11:44:26 <ski>     let line1 = skipSpaces line0 in
11:44:31 <tertl3> is haskell more fun on linux?
11:44:38 <basti_> Eduard_Munteanu: I think "learn" builds up unneeded copies of "som"
11:44:47 <basti_> (in Som/Som.hs)
11:44:59 <ski>     if line1 == "" then acc else
11:45:00 <Eduard_Munteanu> Ah, one of the latest commits.
11:45:07 <basti_> i don't even know how to prove that
11:45:08 <ski>       bind (parseOp line1)) $ \(op,line1) ->
11:45:21 <Eduard_Munteanu> basti_: this one? https://github.com/bastiaanzapf/som/commit/a59ed43f1349db45c14f6480c4384caa8d0ed7bd
11:45:21 <basti_> (i'm currently refactoring existing code ;)
11:45:46 <basti_> yes this is where i started to try around with foldl_
11:45:47 <basti_> '
11:45:56 <ski>       bind (parseInt line1)) $ \(nextval,line2) ->
11:46:03 <hc> ion: i'm using that very version
11:46:10 <b_jonas> tertl3: well of course
11:46:10 <ski>       parseImpl (op acc nextval) line2
11:46:28 <ski> Paprikachu : hm, this is becoming hard to read, should i paste it instead ?
11:46:31 <basti_> i actually first discovered the problem when i started to use the ".lrn" parser
11:46:31 <ion> hc: Yes, i know. That’s what squeeze has.
11:46:37 <Paprikachu> yes, please
11:46:52 <ski> Paprikachu : "so parseOp is a .." -- yes
11:46:57 <monochrom> in practice, haskell is most convenient on linux
11:47:34 <b_jonas> ski: :parseOp :: String -> Either (Int -> Int -> Int,String)" looks wrong
11:47:50 <b_jonas> ski: do you mean parseOp :: String -> Either String (Int -> Int -> Int)
11:47:51 <b_jonas> ?
11:47:54 <ski> er, yes that
11:47:58 <ski> no
11:47:59 <Eduard_Munteanu> basti_: btw, why redefine foldl'?
11:48:13 <ski>   parseOp :: String -> Either String (Int -> Int -> Int,String)
11:48:15 <basti_> Eduard_Munteanu: i didn't know where to find it and had the definition at hand
11:48:23 <b_jonas> ski: ah
11:48:25 <Eduard_Munteanu> @index foldl'
11:48:25 <lambdabot> Data.List
11:48:26 <b_jonas> ski: makes sense
11:48:33 <Paprikachu> hah, i knew there was something wrong
11:48:34 <b_jonas> you want to return the rest of the string too
11:48:36 <Paprikachu> :D
11:48:58 <b_jonas> so it's an either monad around state monad
11:49:01 <basti_> ok
11:49:05 <b_jonas> ski: ok
11:49:33 <b_jonas> ski: though wait, wouldn't you want to have the pair the other way then? like String -> Either String (String, Int -> Int -> Int)
11:49:34 <basti_> so, this program easily eats up some GB
11:49:43 <basti_> it doesn't need to, imo ;)
11:49:44 <b_jonas> so the state is on the fst side?
11:49:56 <hc> ion: oh, that's what you meant. well, i meant to run lambdabot, and that is working now, so i'll stick with that version for now
11:50:03 <Eduard_Munteanu> basti_: did you profile it?
11:50:23 <basti_> Eduard_Munteanu: not yet, no. but i'll try that.
11:50:32 <Eduard_Munteanu> basti_: try pasting a profile
11:51:28 <newsham> why doesnt lambdabot have a parsec in scope?
11:51:36 <newsham> would be really easy to do examples in lbot
11:51:40 <agocorona> let justify= flip . formMaybe
11:52:06 <nand`> is there some form of predefined removeFirst :: (a -> Bool) -> [a] -> (Maybe a, [a])
11:53:16 <nand`> I guess I could implement it in terms of \f xs -> (find f xs, dropFirst f xs) for some dropFirst with correct semantics
11:53:17 <Eduard_Munteanu> :t deleteFirstsBy   -- ?
11:53:18 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a] -> [a]
11:53:38 <Eduard_Munteanu> Ah, you also want that element.
11:53:44 <nand`> right
11:53:55 <nand`> I'll just implement it myself
11:54:22 <basti_> Eduard_Munteanu: that'll take a little while, i haven't got profiling for gtk compiled :/
11:55:39 <agocorona> > let justify= flip . fromMaybe
11:55:40 <lambdabot>   not an expression: `let justify= flip . fromMaybe'
11:55:41 <Eduard_Munteanu> basti_: btw, try using the folds from Data.Foldable
11:55:49 <Eduard_Munteanu> Instead of reimplementing them for arrays and such.
11:56:00 <basti_> okay
11:56:37 <Eduard_Munteanu> :t Data.Foldable.foldl'
11:56:38 <lambdabot> forall a b (t :: * -> *). (Data.Foldable.Foldable t) => (a -> b -> a) -> a -> t b -> a
11:57:31 <agocorona> > let justify= flip . fromMaybe in  find 'x' "blahblahblah"  `justify` error "x not found"
11:57:32 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
11:57:32 <lambdabot>         against inferred ...
11:57:57 <Paprikachu> ski, are you okay?
11:57:58 <Eduard_Munteanu> You might also want foldr for non-strict operations.
11:58:33 <basti_> i thought foldl is somewhat easier on the heap?
11:59:33 <agocorona> > let justify= flip  fromMaybe in  find 'x' "blahblahblah"  `justify` error "x not found"
11:59:34 <lambdabot>   Couldn't match expected type `b -> GHC.Bool.Bool'
11:59:34 <lambdabot>         against inferred ...
12:00:59 <hpaste> ski annotated “parsing sums” with “parsing sums, monadically” at http://hpaste.org/69100#a69109
12:01:03 <ski> Paprikachu ^
12:01:08 <agocorona> > let justify= flip  fromMaybe in  find (=='x')  "blahblahblah"  `justify` error "x not found"
12:01:10 <lambdabot>   *Exception: x not found
12:03:44 <Eduard_Munteanu> basti_: not necessarily. Assuming associative operations, you most likely want foldr for non-strict productive functions, and foldl' for strict stuff (like (+) on numbers)
12:03:50 <b_jonas> ski: hmm, so bind in that paste is a bind for the either monad, not for the either+state monad, right?
12:03:55 <ski> yes
12:04:05 <basti_> hmm
12:04:38 <hpaste> djh pasted “error compiling ghc” at http://hpaste.org/69110
12:04:40 <b_jonas> and the "is the same as" has to be understood loosely, only in this context, right?
12:04:43 <agocorona> > let justify= flip  fromMaybe in  findIndex 'x' "blahblahblah"  `justify` -1
12:04:44 <lambdabot>   Precedence parsing error
12:04:44 <lambdabot>      cannot mix `justify' [infixl 9] and prefix `-...
12:05:05 <b_jonas> or maybe it doesn't actually matter
12:05:08 <b_jonas> hmm
12:05:09 <agocorona> > let justify= flip  fromMaybe in  findIndex 'x' "blahblahblah"  `justify` (-1)
12:05:09 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
12:05:10 <lambdabot>         against inferred ...
12:05:11 <b_jonas> they might really be the same
12:05:50 <ski> Paprikachu : i added the type signatures in there just for clarity, you can omit them if you prefer
12:05:58 <agocorona> > let justify= flip  fromMaybe in  findIndex (=='x') "blahblahblah"  `justify` (-1)
12:05:59 <lambdabot>   -1
12:06:23 <strager> > fromJust $ findIndex (=='x') "blah" <|> Just (-1)
12:06:24 <lambdabot>   -1
12:06:37 <agocorona> but justify is more elegant
12:06:40 <strager> Not as "efficient" but easier to grok =]
12:06:46 <agocorona> usinjg infix notation
12:06:54 <strager> Look at my <|>; it's infix
12:07:30 <ski> > fromMaybe (-1) (findIndex (=='x') "blah")
12:07:31 <lambdabot>   -1
12:07:33 <strager> I'd really just use fromMaybe, prefix.
12:07:39 <strager> like that, except with $
12:07:56 <ski> > (fromMaybe (-1) . findIndex (=='x')) "blah"
12:07:57 <lambdabot>   -1
12:07:59 <agocorona> mine is nicer ;)
12:08:08 <strager> ;P
12:08:40 <ski> agocorona : why did you name it "justify" ?
12:08:44 <agocorona> allthough applicative is trendy
12:08:53 <ski> (also, what are you going to do with `-1' later on ?)
12:08:56 <strager> "turn into just" is what I read "justify" as
12:09:24 <agocorona> because it justifies a maybe expression. is more readable
12:09:40 <strager> let justify = Just in ...
12:10:00 <agocorona> it´s not the same
12:10:06 <strager> <|> almost 'justifies'
12:10:13 <agocorona> almost
12:10:23 <strager> If the rhs is Just x, <|> always yields Just (or _|_)
12:12:45 <b_jonas> ski: okay, I understand that example, but wouldn't that be a bit hard to expand because you can't look forward even a single token?
12:13:06 <b_jonas> ski: you look forward to check for the end of the line (skippig spaces first), okay, but it'd be hard to do more
12:13:59 <agocorona> but the goal is to put all the maybe stuff in the rigth, and to do the justified stuff in the left
12:14:08 <ski> it's not that hard to change `parseOp' to look for multiple-character operator symbols
12:15:34 <ski> agocorona,strager : oh
12:16:25 <ski> Paprikachu : you may note i wrote in the paste line
12:16:32 <ski>   foo `bind` \fooResult ->
12:16:38 <ski>   bar `bind` \barResult ->
12:16:40 <ski>   baz
12:16:43 <ski> instead of
12:16:57 <ski>   bind foo $ \fooResult ->
12:17:02 <b_jonas> maybe separating tokenizers and parsers isn't in fashion among haskellers with their fancy recursive descent parsers
12:17:03 <ski>   bind bar $ \barResult ->
12:17:05 <ski>   baz
12:17:09 <ski> but it's the same thing
12:17:19 <ski> and it really means
12:17:23 <ski>   bind foo (\fooResult ->
12:17:26 <ski>   bind bar (\barResult ->
12:17:29 <ski>   baz))
12:17:56 <ski> so, everything from `\fooResult ->' 'til the end is passed as an argument function to `bind'
12:18:19 <ski> (it represents what to do *after* "doing" the `foo' argument, unless that "throws an exception")
12:18:47 <ski> Paprikachu : hm, have you seen the `\x -> ..x..' notation before ?
12:19:36 <ski> `\x -> ..x..' is the (unnamed) function that given an input, call it `x', returns `..x..'
12:19:59 <ski> e.g. `\x -> 1 + x^2' is the function that adds one to the square of its input
12:20:12 <ski> > map (\x -> 1 + x^2) [0,1,2,3]
12:20:14 <lambdabot>   [1,2,5,10]
12:20:26 <ski> > let f = \x -> 1 + x^2  in  map f [0,1,2,3]
12:20:27 <lambdabot>   [1,2,5,10]
12:20:32 <ski> > let f x = 1 + x^2  in  map f [0,1,2,3]
12:20:33 <lambdabot>   [1,2,5,10]
12:20:59 <Paprikachu> [21:16:14]	<ski>	Paprikachu : hm, have you seen the `\x -> ..x..' notation before ?
12:21:06 <Paprikachu> it's a lambda taking one argument
12:21:24 <ski> yes
12:21:33 <ski> so when i say
12:21:48 <ski>   parseOp                    line1 `bind` \(op     ,line2) ->
12:22:04 <Paprikachu> two arguments, op and line2?
12:22:04 <ski>   ..op..line2..
12:22:26 <ski> pedantically speaking, it's a single argument, which is a pair (a two-tuple)
12:22:43 <ski> but we can think of it as two arguments, due to the pattern-matching there
12:22:58 <ski> this pair is the "normal result" of `parseOp'
12:23:20 <ski> `bind' handles propagating "abnormal result" (i.e. "exception") under the covers, for us
12:23:38 <Paprikachu> yeah, it's the case-stuff you defined in the beginning
12:23:44 <ski> yes
12:23:58 <ski> unless there's a parse failure, `parseOp' will give us a pair of the operator function to use to add/subtract, and also the rest of the input line
12:24:10 <jonaskoelker> how do I make ghci tell me all the infix* decls in effect?
12:24:55 <ski> Paprikachu : btw, before `do'-notation was invented, this is how one used monads
12:25:11 <ski> now, (with some appear to magic sugar) we could write
12:25:13 <b_jonas> jonaskoelker: I don't know, but you can ask about the fixity of a particular operator like :info +
12:25:19 <b_jonas> + is the infix operator there
12:25:27 <ski>   (op,line2) <- parseOp line1
12:25:37 <ski>   (nextval,line3) <- parseInt line2
12:25:45 <ski>   parseImpl (op acc nextval) line3
12:25:51 <b_jonas> @hoogle <+>
12:25:51 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
12:25:51 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
12:25:51 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
12:25:59 <ski> which is more or less the same as the `bind' stuff above, but slightly nicer
12:26:08 <ski> this now looks closer to
12:26:14 <ski>   (op,line2) = parseOp line1;
12:26:20 <ski>   (nextval,line3) = parseInt line2;
12:26:26 <ski>   return (parseImpl (op acc nextval) line3);
12:26:33 <ski> (in pseudo-C code)
12:26:45 <Siod> how did paprikachu get you guys to basically teach them haskell from the ground up
12:27:05 <ski> Siod : Paprikachu asked about parsing
12:27:14 <b_jonas> Siod: this channel always does that
12:27:21 <b_jonas> they explain great
12:27:35 <Paprikachu> yeah, ski should become a teacher
12:27:42 <Siod> alright, anyone want to explain continuations to me?
12:27:56 <nand`> +1 for that, I always forget
12:28:06 * ski confesses to maybe have partially started/contributed to this custom of #haskell
12:28:06 <nand`> probably because I've never used them
12:28:48 <b_jonas> Siod: sure, but ask a more detailed question perhaps
12:29:04 <ski> (#haskell was my first IRC channel, so i hadn't been spoilt by the customs of other channels before it)
12:29:21 <basti_> for a valid profile, a program must exit normally, no?
12:29:21 <Siod> i don't get the ground up treatment? :()
12:29:33 <b_jonas> Siod: this channel especially likes anything starting with "co", and continuations are codata so they count there doubly
12:29:54 <ski> Siod : consider a simple
12:29:56 <Siod> what do you mean by codata?
12:30:01 <ski>   product [    ] = 1
12:30:16 <ski>   product (n:ns) = n * product ns
12:30:28 <ski> now consider the evaluation trace for
12:30:51 <ski>      product [2,3,5,0,7,8]
12:30:57 <ski>   =  2 * product [3,5,0,7,8]
12:30:59 <Paprikachu> does this work for product [x]?
12:31:03 <ski>   =  2 * (3 * product [5,0,7,8])
12:31:11 <ski>   =  2 * (3 * (5 * product [5,0,7,8]))
12:31:15 <ski> (er, s/5,//)
12:31:24 <b_jonas> Paprikachu: yes
12:31:26 <ski>   =  2 * (3 * (5 * (0 * product [7,8])))
12:31:33 <ski>   =  2 * (3 * (5 * (0 * (7 * product [8]))))
12:31:39 <ski>   =  2 * (3 * (5 * (0 * (7 * (8 * product [])))))
12:31:42 <ski>   =  2 * (3 * (5 * (0 * (7 * (8 * 1)))))
12:31:45 <Paprikachu> ns is then matched against an empty list, am i right?
12:31:46 <ski>   =  2 * (3 * (5 * (0 * (7 * 8))))
12:31:48 <ski>   =  2 * (3 * (5 * (0 * 56)))
12:31:51 <ski>   =  2 * (3 * (5 * 0))
12:31:54 <ski>   =  2 * (3 * 0)
12:31:55 <b_jonas> Paprikachu: yes
12:31:55 <ski>   =  2 * 0
12:31:57 <ski>   =  0
12:32:19 <ski> now, let's say we want to stop multiplying when/if we reach a `0'
12:32:27 <ski> so, we can add to the above equations
12:32:34 <ski>   product (0:_ ) = 0
12:32:42 <DanBurton> "If you'd be interested in a 2nd edition of Real World Haskell, please RT and think about filling out this quick survey: http://bit.ly/ooydix " ~ tweet from Bryan O'Sullivan
12:32:43 <ski> then we'll get a trace like
12:32:50 <ski>      product [2,3,5,0,7,8]
12:32:51 <basti_> Eduard_Munteanu: ok, that helped a lot
12:32:56 <ski>   =  2 * product [3,5,0,7,8]
12:33:02 <ski>   =  2 * (3 * product [5,0,7,8])
12:33:09 <ski>   =  2 * (3 * (5 * product [0,7,8]))
12:33:16 <ski>   =  2 * (3 * (5 * 0))
12:33:17 <DanBurton> here's the link to retweet: https://twitter.com/bos31337/status/106496536434851841
12:33:18 <ski>   =  2 * (3 * 0)
12:33:20 <ski>   =  2 * 0
12:33:21 <ski>   =  0
12:33:32 <Eduard_Munteanu> basti_: mm, what?
12:33:59 <ski> Siod : but we'd now like to abort the computation as soon as we reach a `0', instead of having to do all the pending multiplications from the wrapping recursive calls
12:34:15 <Paprikachu> and what's the continuation here?
12:34:24 <b_jonas> Paprikachu: none yet. wait for it.
12:34:25 <ski> consider the step
12:34:34 <ski>   2 * (3 * product [5,0,7,8])
12:34:38 <basti_> Eduard_Munteanu: the problem actually appears to be deeper down
12:34:48 <ski> the continuation of the call to `product' here is
12:34:54 <ski>   2 * (3 * <>)
12:35:07 <ski> where `<>' denotes a "hole" in the expression
12:35:10 <ski> (not valid Haskell syntax)
12:35:15 <b_jonas> ski: and do you want to avoid all the prior multiplications too? like, you don't want to just write a (:: Integer -> [Integer] -> Integer) product function, right?
12:35:32 <ski> the continuation is "everything we have to do after the `product' call returns)
12:35:35 <Eduard_Munteanu> basti_: do you mean Data.Foldable folds fixed something?
12:35:53 <ski> b_jonas : yes, see "but we'd now like to ..."
12:36:29 <b_jonas> ah, I see
12:36:30 <basti_> Eduard_Munteanu: no, but i can see in the profile that it's not as simple as i thought
12:36:33 <b_jonas> sorry, it was a stupid question
12:36:41 <ski> this "continuation" of the call `product [5,0,7,8]' here looks awfully much like a function here
12:36:42 <basti_> most of the memory is eaten away by functions called deeper down the graph
12:36:43 <jonaskoelker> ski: so you're going to CPSify product? :-)
12:36:46 <ski> it's an expression with a hole
12:36:49 <ski> jonaskoelker : yep
12:36:57 <ski> so, we represent the continuation
12:37:02 <ski>   2 * (3 * <>)
12:37:05 <ski> in Haskell as the function
12:37:12 <ski>   \result -> 2 * (3 * result)
12:37:12 <Eduard_Munteanu> basti_: pastebin it
12:37:27 <Eduard_Munteanu> Don't take it for granted, it might still point you in the wrong direction.
12:37:30 <ski> where `result' will become the value of `product [5,0,7,8]'
12:37:40 <ski> Siod : are you following ?
12:37:49 <basti_> Eduard_Munteanu: ok, wait a sec
12:38:11 <Siod> so, you're basically controlling the execution of product right? and you want to inject your own code somewhere in that execution?
12:38:18 <basti_> Eduard_Munteanu: http://pastebin.com/BUasjvgs
12:38:21 <mauke> The paste BUasjvgs has been copied to http://hpaste.org/69112
12:38:28 <ski> i want to control "what happens after the call"
12:39:18 <ski> so, now, instead of just returning the value of `product', i'm going to let it take the continuation ("what to do afterwards") as an *argument*, so we'll now "return" a value by calling the continuation on the value
12:39:31 <ski> in code, this becomes
12:39:41 <ski>   productCPS [    ] cont = cont 1
12:39:56 <ski> so we say `cont 1' to "return" `1' to the continuation
12:40:03 <Siod> wait, after the call is <> right?
12:40:05 <ski> which will then do its thing with that result
12:40:20 <Siod> i.e., you have a bunch of recursive calls, and the cont is after <>?
12:40:21 <ski> Siod : i'm not sure what you're asking ?
12:40:32 <Eduard_Munteanu> basti_: how did you compile it?
12:40:38 <ski> the continuation represents "everything around" the current call
12:40:49 <ski> different recursive calls will have different continuations
12:40:50 <basti_> > ghc -prof -auto-all -rtsopts somtest.hs
12:40:51 <lambdabot>   Not in scope: `ghc'Not in scope: `prof'Not in scope: `auto'Not in scope: `r...
12:40:59 <ski> in
12:41:13 <ski>   2 * (3 * product [5,0,7,8])
12:41:20 <Eduard_Munteanu> basti_: hm, no -O or -O2?
12:41:29 <basti_> no.
12:41:32 <ski> the continuation of the `product [5,0,7,8]' call is here vaguely written as
12:41:37 <ski>   2 * (3 * <>)
12:41:42 <Eduard_Munteanu> basti_: try -O2 and see if it fixes anything
12:41:50 <ski> and in Haskell, we'll *represent* this continuation as the function
12:41:51 <ski>   \result -> 2 * (3 * result)
12:41:56 <ski> but, in
12:42:06 <ski>   2 * product [3,5,0,7,8]
12:42:15 <basti_> it does, actually.
12:42:21 <ski> well, say instead
12:42:23 <basti_> now "amapix" is the largest memory hog
12:42:30 <ski>   2 * (3 * (5 * product [0,7,8]))
12:42:49 <Eduard_Munteanu> basti_: paste again?
12:42:50 <ski> the continuation of the call `product [0,7,8]' here can be denoted like
12:42:57 <ski>   2 * (3 * (5 * <>))
12:43:16 <ski> where `<>' denotes the hole where the result of `product [0,7,8]' will be "plugged in"
12:43:29 <ski> and we represent this continuation in Haskell as
12:43:35 <ski>   \result -> 2 * (3 * (5 * result))
12:43:53 <Siod> ok, i think i follow
12:43:57 <ski> now, i'm going to change
12:43:59 <basti_> Eduard_Munteanu: http://pastebin.com/7phDY35g
12:44:03 <mauke> The paste 7phDY35g has been copied to http://hpaste.org/69113
12:44:03 <ski>   2 * (3 * product [5,0,7,8])
12:44:05 <ski> into
12:44:18 <ski>   productCPS [5,0,7,8] (\result -> 2 * (3 * result))
12:44:20 <ski> and
12:44:27 <ski>   2 * (3 * (5 * product [0,7,8]))
12:44:28 <ski> into
12:44:34 <basti_> i mean, of course, amapix will allocate just about most of the memory
12:44:35 <ski>   productCPS [0,7,8] (\result -> 2 * (3 * (5 * result)))
12:45:04 <ski> i.e. i'm going to *reify* the continuation as an *explicit* argument of `productCPS' (renamed to emphasize that this now takes an extra argument, the continuation)
12:45:12 <ski> Siod : ok ?
12:45:43 <Eduard_Munteanu> basti_: learndistance too, seems strange
12:45:51 <monochrom> ski: in your quoting style `x', there can be strangeness like `x = 'x''
12:45:58 <ski> monochrom : i know :/
12:46:01 <basti_> yes it ought not to behave that way
12:46:02 <Siod> i think i got it
12:46:09 <ski> ok
12:46:13 <Siod> the cont is like a slide ruler on execution?
12:46:25 <ski> heh, not sure exactl what you mean :)
12:46:26 <Siod> or control flow
12:46:42 <ski> it makes control flow more explicit (and more malleable, therefore)
12:46:44 <ski> so now we replace
12:46:51 <b_jonas> slide rule? what?
12:46:51 <monochrom> "cont is like control flow" is always right
12:46:56 <ski>   product [    ] = 1
12:46:56 <b_jonas> how does it go here?
12:46:56 <ski> with
12:46:59 <basti_> it's called a lot, so i wouldn't wonder about it allocating lots of memory
12:47:03 <ski> productCPS [    ] cont = cont 1
12:47:09 <ski> Siod : ok, so far ?
12:47:12 <basti_> but still, it ought to free it again
12:47:22 <Siod> yes
12:47:33 <ski> then, the recursive case (going to skip the `0' case for the while)
12:47:39 <beefcube> if one has a cabal file with several "Executable:" is there a way to to move common "Build-Depends:" among each  to a separate definition which is shared? Currently each executable is importing from the same File.hs in the same directory, and this depends on 'Data.Heap'
12:47:41 <Siod> it's wrapping cont, so that it can inspect cont's control flow
12:47:51 <Siod> like being the slider on a slide rule
12:47:55 <ski>   productCPS (n:ns) cont = ??n * productCPS ns??
12:48:02 <ski> the original here is
12:48:14 <ski>   product (n:ns) = n : product ns
12:48:22 <Paprikachu> what is ??
12:48:30 <ski> Siod : heh, if it works for you, then fine
12:48:38 <ski> Paprikachu : meaning "is this correct yet ?" :)
12:48:45 <ski> (i.e. pseudo-code)
12:49:02 <ski> we need to massage
12:49:05 <ski>   productCPS (n:ns) cont = ??n * productCPS ns??
12:49:07 <Paprikachu> the orignal was n * product ns
12:49:09 <ski> a bit, to make it right
12:49:34 <Paprikachu> typo :)
12:49:49 <ski> we have to realize that in Continuation-Passing-Style (CPS), which is what we're doing here, functions don't like if you explcitly do things with their result
12:49:59 <ski> they prefer if you tell them what you intend to do with the result
12:50:15 <ski> firstly, the recursive call to `productCPS' should have two arguments
12:50:24 <ski> one is `ns', the list of the remaining numbers
12:50:34 <ski> the other should be the continuation that we pass to the recursive call
12:50:50 <ski> this continuation should represent what we want to "do after" the recursive call
12:50:51 <Eduard_Munteanu> basti_: I'm thinking immutable arrays might be the problem here, at least considering the way you're using them.
12:50:56 <ski> so, let's rewrite
12:50:57 <Siod> what happened to the original product function?
12:50:59 <ski>   productCPS (n:ns) cont = ??n * productCPS ns??
12:51:00 <ski> into
12:51:08 <ski>   productCPS (n:ns) cont = ??n * productCPS ns (\result -> ...)??
12:51:09 <basti_> Eduard_Munteanu: how should i use them instead?
12:51:29 <ski> Siod : we're mutating it into this CPS monster
12:51:32 <Siod> so, it's been rewritten into
12:51:34 <Siod> right, ok
12:51:42 <ski> the rewriting isn't done yet, though
12:51:56 <ski> here `result' will become the product of the list `ns'
12:51:57 <Paprikachu> shouldn't it be \result -> n * result
12:51:59 <Paprikachu> ?
12:52:04 <ski> yes, good suggestion
12:52:07 <ski> so, we try
12:52:15 <ski>   productCPS (n:ns) cont = ??n * productCPS ns (\result -> n * result)??
12:52:21 <mparodi_> why does it say it's ambiguous? http://paste.kde.org/488228
12:52:25 <ski> but, we don't want `n *' twice in there, so
12:52:32 <ski>   productCPS (n:ns) cont = ??productCPS ns (\result -> n * result)??
12:52:41 <mparodi_> Main.show does not have the same time as Prelude.show
12:52:45 <ski> still, it's not quite right
12:52:51 <mparodi_> in fact you can't use Prelude.show with Expr
12:53:03 <b_jonas> yup, because we have to use cont as well
12:53:07 <ski> Siod,Paprikachu : we have to recall that *this* current call to `productCPS' also has a `cont' argument
12:53:13 <ski> and we've forgotten about that
12:53:31 <basti_> Eduard_Munteanu: might i try to thaw/freeze
12:53:32 <basti_> ?
12:53:36 <ski> so, "what to do after" really is "multiply by `n', and the continue with whatever `cont' wants to do"
12:53:40 <mparodi_> <mparodi_> Main.show does not have the same time as Prelude.show <-- s/time/type/ *
12:53:47 <monochrom> try: show (Lit n) = Main.show n. similarly for others
12:54:01 <basti_> Eduard_Munteanu: sadly, they demand that the type of "learn" be pure so that it can be used in a parallel dialect of haskell
12:54:09 <ski> this leaves us at
12:54:18 <ski>   productCPS (n:ns) cont = productCPS ns (\result -> cont (n * result))
12:54:20 <monochrom> of course, you can also use "import Prelude hiding (show)"
12:54:24 <ski> which is actually the final version
12:54:41 <ski> Siod,Paprikachu : ok ?
12:55:01 <Paprikachu> i'm not quite sure if i got that last step
12:55:09 <monochrom> oh yikes, I have errors
12:55:13 <Siod> so, this is just the original product rewritten in CPS style, and we still need to stop the control flow when a 0 is found, rgiht?
12:55:22 <monochrom> show (Lit n) = Prelude.show n
12:55:26 <ski> after `productCPS' "returns" the product of `ns' into `result', we want to fist multiply by `n'
12:55:38 <Eduard_Munteanu> basti_: you can still use a STArray underneath
12:55:38 <ski> then we want to do whatever `cont' tell us to do
12:55:49 <ski> Siod : yep
12:55:58 <Phlogistique> "fist multiply" sounds like an awesome way of multiplying.
12:56:06 <Eduard_Munteanu> basti_: or even STUArray if you can convert those values to Double (btw, why not use Double instead of Float?).
12:56:07 <ski> (Siod : also "CPS style" is "Continuation-Passing-Style style" :)
12:56:27 <b_jonas> so result is likely going to become the product of ns here?
12:56:30 <monochrom> "different types" does not cause a haskell compiler to "resolve name clashes"
12:56:32 <ski> Paprikachu : consider a call
12:56:42 <ski>   show (product [2,3,4])
12:56:49 <ski> here the continuation is
12:56:53 <ski>   \result -> show result
12:57:01 <ski> so, we'd translate this into
12:57:11 <Eduard_Munteanu> basti_: and try to minimize the number of "maps" you apply, perhaps you can do more in one go.
12:57:11 <ski>   productCPS [2,3,4] (\result -> show result)
12:57:24 <ski> Paprikachu : now, `cont' will become this `\result -> show result'
12:57:44 <ski> Paprikachu : if we don't use `cont' in `productCPS', then we forget about doing this at the end
12:57:51 <Egbert9e9> i've been trying to cabal install soegtk but glib won't install
12:58:05 <ski> let's assume we have just
12:58:20 <ski>   productCPS [    ] cont = cont 1
12:58:21 <ski>   productCPS (n:ns) cont = productCPS ns (\result -> n * result)
12:58:25 <ski> then, if we trace
12:58:34 <ski>      productCPS [2,3,4] (\result -> show result)
12:58:43 <ski>      productCPS [3,4] (\result -> 2 * result)
12:58:47 <ski>      productCPS [4] (\result -> 3 * result)
12:58:52 <ski>      productCPS [] (\result -> 4 * result)
12:58:56 <ski>      (\result -> 4 * result) 1
12:58:59 <ski>      4 * 1
12:59:01 <ski>      4
12:59:11 <ski> so, because `cont' was unused in
12:59:14 <ski>   productCPS (n:ns) cont = productCPS ns (\result -> n * result)
12:59:25 <ski> we completely forgot most of the multiplications to do, as well
12:59:30 <ski> now, let's try with the proper
12:59:34 <ski>   productCPS [    ] cont = cont 1
12:59:40 <ski>   productCPS (n:ns) cont = productCPS ns (\result -> cont (n * result))
12:59:43 <ski> then we get
12:59:49 <ski>      productCPS [2,3,4] (\result -> show result)
13:00:02 <ski>   =  productCPS [3,4] (\result -> show (2 * result))
13:00:04 <Egbert9e9> the exception was ExitFailure 1
13:00:08 <Eduard_Munteanu> basti_: another thing that might help is specializing and perhaps inlining learndistance
13:00:09 <ski>   =  productCPS [4] (\result -> show (2 * (3 * result)))
13:00:16 <ski>   =  productCPS [] (\result -> show (2 * (3 * (4 * result))))
13:00:20 <ski>   =  (\result -> show (2 * (3 * (4 * result)))) 1
13:00:22 <Eduard_Munteanu> e.g. for Double
13:00:27 <ski>   =  show (2 * (3 * (4 * 1)))
13:00:29 <ski>   =  show (2 * (3 * 4))
13:00:32 <ski>   =  show (2 * 12)
13:00:34 <ski>   =  show 24
13:00:37 <ski>   =  "24"
13:00:48 <Phlogistique> ski: are you actually typing the traces?
13:00:51 <Paprikachu> alright
13:00:54 <Eduard_Munteanu> It might enable some strength reduction optimizations too.
13:00:54 <ski> yes
13:00:54 <Paprikachu> yes, he is
13:01:04 <Paprikachu> but what do we need this stuff for?
13:01:10 <medfly> hi guys
13:01:11 <Phlogistique> OK. I wish we had a tool to do that
13:01:15 <Eduard_Munteanu> medfly: hi
13:01:19 <ski> @where stepeval
13:01:20 <lambdabot> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
13:01:37 <ski> now, we wanted to *abort* as soon as we see an `0'
13:01:45 <ski> so, we add the following clause
13:01:52 <medfly> I am trying to see if there exist an implementation of an algorithm (A* search)
13:02:03 <ski>   productCPS (0:_ ) _    = 0
13:02:08 <ski> now, let's see what happens with
13:02:11 <monochrom> hackage probably has A* search
13:02:21 <ski>      productCPS [2,3,5,0,7,8] (\result -> show result)
13:02:28 <ski>   =  productCPS [3,5,0,7,8] (\result -> show (2 * result))
13:02:32 <Paprikachu> ah, i understand
13:02:35 <ski>   =  productCPS [5,0,7,8] (\result -> show (2 * (3 * result)))
13:02:38 <Paprikachu> the continuation gets ignored
13:02:42 <ski>   =  productCPS [0,7,8] (\result -> show (2 * (3 * (5 * result))))
13:02:48 <Paprikachu> that's why 0 is not multiplied with the result
13:02:49 <ski>   =  0
13:02:52 <ski> exactly :)
13:02:57 <Phlogistique> which is bad!
13:03:04 <Phlogistique> we want to show the result!
13:03:07 <ski> no
13:03:11 <ski> well
13:03:15 <ski> we can do
13:03:22 <Paprikachu> show (...)
13:03:24 <ski>      show (productCPS [2,3,5,0,7,8] (\result -> result))
13:03:25 <ski> instead
13:03:35 <ski> i.e. not include it in the explicit continuation
13:03:37 <monochrom> there is a type error in productCPS [2,3,5,0,7,8] (\result -> show result)
13:03:45 <medfly> I can't seem to find it
13:03:50 <Paprikachu> so continuations are used to implement lazy evauation?
13:03:50 <ski> (monochrom : indeed)
13:04:02 <medfly> I could implement it myself but it's stupid to not reuse existing stuff
13:04:02 <ski> Paprikachu : this isn't really lazy evaluation
13:04:02 <Paprikachu> +l
13:04:34 <Siod> this is so reminding me of hooked or wrapped functions in c
13:04:42 <Phlogistique> now, there is a Continuation monad, no?
13:04:43 <b_jonas> > let { prodCP :: [Integer] -> (Integer -> a) -> a; prodCP [] c = c 1; prodCP (h:t) c = prodCP t (\r -> c (h * r)); prod s = prodCP s id; } prod [x, y, z]
13:04:44 <lambdabot>   <no location info>: parse error on input `prod'
13:04:45 <medfly> ah there we go
13:04:46 <ski> Paprikachu : continuations can be used to implement exceptions, coroutines, cooperative concurrency (also preemptive, if we have a timer), backtracking, &c.
13:04:50 <b_jonas> > let { prodCP :: [Integer] -> (Integer -> a) -> a; prodCP [] c = c 1; prodCP (h:t) c = prodCP t (\r -> c (h * r)); prod s = prodCP s id; } in prod [x, y, z]
13:04:51 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
13:04:51 <lambdabot>         against inf...
13:05:07 <b_jonas> > let { prodCP :: (Num a) => [n] -> (n -> a) -> a; prodCP [] c = c 1; prodCP (h:t) c = prodCP t (\r -> c (h * r)); prod s = prodCP s id; } in prod [x, y, z]
13:05:09 <lambdabot>   Could not deduce (GHC.Num.Num n) from the context (GHC.Num.Num a)
13:05:09 <lambdabot>    arisin...
13:05:20 <b_jonas> > let { prodCP :: (Num n) => [n] -> (n -> a) -> a; prodCP [] c = c 1; prodCP (h:t) c = prodCP t (\r -> c (h * r)); prod s = prodCP s id; } in prod [x, y, z]
13:05:21 <lambdabot>   x * (y * (z * 1))
13:05:21 <Paprikachu> hm..
13:05:27 <b_jonas> > let { prodCP :: (Num n) => [n] -> (n -> a) -> a; prodCP [] c = c 1; prodCP (h:t) c = prodCP t (\r -> c (h * r)); prod s = prodCP s id; } in prod [x, 0, z]
13:05:28 <lambdabot>   x * (0 * (z * 1))
13:05:30 <Paprikachu> coroutines sound interesting
13:05:50 <Paprikachu> (i know what coroutines are, no need to explain)
13:06:09 <Egbert9e9> guys, i want to use Haskell School of Expression's library, but it won't compile (soegtk)
13:06:10 <b_jonas> > let { prodCP :: (Num n, Eq n) => [n] -> (n -> a) -> a; prodCP [] c = c 1; prodCP (h:t) c = if 0 == h then 0 else prodCP t (\r -> c (h * r)); prod s = prodCP s id; } in prod [x, 0, z]
13:06:11 <lambdabot>   Could not deduce (GHC.Num.Num a)
13:06:11 <lambdabot>    from the context (GHC.Num.Num n, GHC.Cl...
13:06:13 <ski> one use of CPS is if you want to get tail-calls in something you implement in C
13:06:26 <Paprikachu> what's a tail call? :x
13:06:28 <medfly> b_jonas: maybe you should try that on pm
13:06:36 <b_jonas> medfly: sorry, yuo're right
13:06:53 <ski> Paprikachu : in GCC, there's a `-fsibling-calls', i think, which (*partially*) gives you it
13:07:26 <ski> Paprikachu : basically, in C terms, if you write `return foo(...);', then this is compiled as a jump, *reusing* the existing activation frame, instead of allocating a new one
13:07:33 <ski> that's tail-call
13:07:44 <Paprikachu> okay
13:07:53 <dmwit> hvr: Conclusion: using ST is a premature optimization. =)
13:07:59 <ski> Paprikachu : this is important if you want to write iteration in terms of recursion :)
13:08:22 <ski> (otherwise an iterative process implemented by recursion could blow the stack)
13:08:26 <Paprikachu> yeah, it prevents stack overflows
13:08:40 <ski> however, i'm not just talking about simple `for' or `while' loops here
13:08:51 <ski> the typical case of tail-calls is tail-*recursion*
13:08:59 <Phlogistique> ski: would you care to show how productCPS would be implemented with the Cont monad?
13:09:08 <ski> sure
13:09:19 <b_jonas> guess it works now
13:09:21 <Siod> wait, so there's CPS and then there's the Cont monad, what's the difference?
13:09:29 <b_jonas> > (prod [x, y, z], prod [x, 0, z])
13:09:31 <lambdabot>   (x * (y * (z * 1)),0)
13:09:42 <ski> Siod : the `Cont' monad hides the CPS stuff inside the familiar monad interface
13:09:43 <Siod> would CPS be lumped in the category of design patterns?
13:09:58 <ski> probably more or less
13:10:07 <ski>   productCont :: Integer -> Cont Integer Integer
13:10:17 <b_jonas> it's no longer a pattern if it's formalized as a monad
13:10:24 <b_jonas> not just a pattern that is
13:10:31 <ski>   productCont [    ] = do return
13:10:32 <Phlogistique> b_jonas: but monad is a pattern
13:10:44 <ski>   productCont (0: ) = do abortCont 0
13:10:50 <hpc> Siod: in general, "design pattern" is an abstraction that you implement by hand :P
13:10:53 <ski>   productCont (n:ns) = do
13:11:02 <ski>     result <- productCont ns
13:11:05 <mparodi_> http://paste.kde.org/488252 <-- this should be working but it doesn't. am I wrong?
13:11:07 <ski>     return (n * result)
13:11:08 <hpc> so it's a design pattern if your language somehow can't define Cont
13:11:22 <ski> given the general
13:11:30 <ski>   abortCont :: o -> Cont o a
13:11:43 <ski>   abortCont o = cont $ \_ -> o
13:11:55 <mparodi_> (show is ambiguous, it says)
13:12:04 <ski> you could also write the last clause of `productCont' like
13:12:18 <ski>   productCont (n:ns) = liftM (n *) (productCont ns)
13:12:28 <mauke> mparodi_: and what does it actually say?
13:12:34 <mparodi_> <mparodi_> (show is ambiguous, it says)
13:12:37 <ski> Phlogistique : ok ?
13:12:38 <mauke> mparodi_: and what does it actually say?
13:12:46 <Phlogistique> ski: ok
13:13:04 <mparodi_> http://paste.kde.org/488264
13:13:04 <Phlogistique> ski: I'm having a hard time with abortCont though
13:13:12 <mparodi_> http://paste.kde.org/488264 <-- mauke
13:13:14 <Phlogistique> what's "cont" here?
13:13:19 <ski> Paprikachu : anyway, consider some dozens of functions, all ending with `return foo(...);' where `foo' is one of these functions
13:13:20 <mauke> mparodi_: ok, what's unclear about that?
13:13:29 <ski> Paprikachu : this can be good to implement a state machine, e.g.
13:13:30 <dmwit> mparodi_: Perhaps you meant "instance Show Expr where ..."?
13:13:34 <hpc> mparodi_: you're defining show, but it already exists
13:13:52 <Phlogistique> btw, ski++
13:13:53 <ski> Paprikachu : `_'
13:13:56 <ski> er
13:13:57 <hpc> and don't do what dmwit said; 'show' isn't actually a member of the class Show
13:14:00 <ski> Phlogistique : `_'
13:14:08 <hpc> write show' (with the end single quote)
13:14:12 <hpc> or showExpr, or something
13:14:13 <dmwit> mparodi_: Really, though, you should be writing a pretty-printer and leaving Show instances to the compiler via deriving.
13:14:43 <Phlogistique> ski: I mean, in your example implementation of abortCont, there is a free variable "cont"
13:14:44 <ski> Phlogistique : in terms of CPS, we have `abortCPS o cont = o'
13:14:48 <mparodi_> hmn.. the point is that this example appear as I pasted it on a book
13:14:52 <mparodi_> so it should be working
13:14:56 <ski> Phlogistique : oh, that one
13:14:58 <ski> @type cont
13:14:59 <lambdabot> forall a r. ((a -> r) -> r) -> Cont r a
13:15:01 <mparodi_> appears*
13:15:02 <ski> is that
13:15:08 <Phlogistique> OK, thanks
13:15:13 <ski> Phlogistique : sorry for the use of the same name for two different things
13:15:18 <b_jonas> mparodi_: which book and doesn't it have more context?
13:15:28 <ski> Phlogistique : formerly this `cont' was called `Cont'
13:15:36 <mparodi_> b_jonas, The Craft of Functional Programming
13:15:47 <ski> (as in `newtype Cont o a = Cont ((a -> o) -> o)')
13:15:49 <Phlogistique> right
13:15:57 <mparodi_> and if you pay attention, it uses both show's. the one for Int and the one it's defining for Expr
13:16:12 <b_jonas> mparodi_: yep, that's what makes it strange
13:16:28 <b_jonas> and it looks like it's definitely in haskell
13:16:31 <hpc> Cont got redefined and now there's no constructor anymore
13:16:34 <mauke> mparodi_: which chapter?
13:16:38 <hpc> so they wrote a function with the same semantics
13:16:41 <hpc> @src Cont
13:16:41 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
13:16:41 <nexion> hey guys, I'm trying to use System.Console.CmdArgs and wondering if there's a way to have the names of the args in the console be different from the name it's assigned to in the code
13:16:42 <ski> Siod : so, the `product' example shows how one can use continuations to "jump out of" an on-going computation, leaving/aborting it
13:16:44 <mparodi_> page 251, mauke
13:16:46 <hpc> ...
13:16:48 <hpc> ignore @src
13:16:49 <mauke> mparodi_: which chapter?
13:16:53 <mparodi_> 14
13:17:00 <ski> Siod : however, one can do similar stuff (not quite the same) with exceptions
13:17:15 <SinPatrones> hi
13:17:16 <SinPatrones> ...
13:17:17 <SinPatrones> :D ....
13:17:23 <ski> Siod : but, with continuations, we can also "jump back into" a computation, e.g. a computation which has already returned :)
13:17:23 <Siod> ski: i've heard that cont is generally considered to be a generalization of other monads with more specific behavior, and hence it's relative lack of usage, is that right?
13:17:27 <dmwit> howdy
13:17:36 <b_jonas> nexion: I don't understand
13:17:43 <b_jonas> your question
13:17:45 <mauke> mparodi_: http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/Code/Chapter14_1.hs this one?
13:17:47 <ski> Siod : i'm not sure
13:18:10 <mauke> mparodi_: (search for "Expressions")
13:18:19 <b_jonas> ski: that, yes, or implement coroutines, like you already mentioned
13:18:20 <ski> Siod : it's not that often that one needs the generality (or convenience) of continuations -- but when one does, there's no substitute
13:18:26 <Siod> http://www.reddit.com/r/haskell/comments/twgk0/does_anybody_actually_understand_cont/
13:18:44 <Siod> "It's not necessarily that Haskellers don't understand Cont, but that they choose not to use it because 99.9% of the time, there's a more specific monad transformer they can use."
13:18:48 <mparodi_> oh! it says instance Show Expr where ¬¬!
13:18:54 <nexion> b_jonas:
13:18:56 <nexion> initialCommandLineArgs = CommandLineArgs {
13:18:56 <nexion>   siteId = def,
13:18:56 <nexion>   newAdminPassword = def
13:18:56 <nexion> }
13:19:05 <ski> SinPatrones : hello
13:19:09 <nexion> then --siteid=... is set as siteId
13:19:09 <mauke> mparodi_: it's also in a comment
13:19:15 <dmwit> hpc: "'show' isn't actually a member of class Show"...?
13:19:23 <dmwit> ?src Show
13:19:23 <lambdabot> class  Show a  where
13:19:23 <lambdabot>     showsPrec :: Int -> a -> ShowS
13:19:23 <lambdabot>     show      :: a   -> String
13:19:23 <lambdabot>     showList  :: [a] -> ShowS
13:19:26 <dmwit> hpc: ?
13:19:27 <nexion> my question is if I can have siteId be set as claSiteId
13:19:39 <mparodi_> mauke, the code printed on the book doesn't include the line "instance Show..." and it doesn't say it's not working u.u
13:19:40 <Siod> ski: yeah, so i have a practical problem with callbacks in wxhaskell, and someone told me that i need to use continuations to insert program state
13:19:45 <nexion> as it causes symbol shadowing
13:20:06 <hpc> dmwit: oh, i thought it wasn't
13:20:16 <Siod> ski: i.e., the program all follows from key events, and you can't maintain state through each key press, so you need upper level state
13:20:20 <hpc> thought it had a default definition in terms of something else, but perhaps i am thinking of read
13:20:23 <hpc> @src Read
13:20:23 <lambdabot> class Read a where
13:20:23 <lambdabot>   readsPrec    :: Int -> ReadS a
13:20:23 <lambdabot>   readList     :: ReadS [a]
13:20:23 <lambdabot>   readPrec     :: ReadPrec a
13:20:23 <lambdabot>   readListPrec :: ReadPrec [a]
13:20:28 <hpc> yeah, there it is
13:20:36 <dmwit> yeah
13:20:38 <Siod> ski: which you then have to somehow send to each keyevent callback
13:20:39 <ski> Siod : mhm, ok
13:20:45 <ski> what
13:20:51 <ski> 's the type of a keyevent callback ?
13:21:16 <dmwit> Siod: I think continuations are a cute trick for keeping state in the callback-happy world, but they're certainly not necessary.
13:21:19 <hpc> Siod: try doing it with IORef first, perhaps
13:21:21 <applicative> Siod, after this fashion?  http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html
13:21:22 <dmwit> IORefs and the like work just fine.
13:21:25 <Siod> onKeyDown :: TextCtrl() -> Key -> MyState IO ()
13:21:37 <Siod> and then in gui = do ....
13:21:47 <mparodi_> done, if you add the "instance Show Expr" line it works
13:21:48 <Siod> lift $ set ctrlInput [processEnter := True,
13:21:48 <Siod>                         on anyKey ::= onKeyDown]
13:22:11 <Siod> and so i construct the program state in gui = do ... and want to give that state to onKeyDown
13:23:22 <SinPatrones> hi
13:23:22 <SinPatrones> ....
13:23:26 <SinPatrones> i'm sorry
13:23:31 <SinPatrones> I was busy
13:23:50 <Siod> i was going to use wxhaskell's vars
13:24:03 <Siod> but i thought there might be a better way like with continuations
13:24:13 <ski> Siod : applicative's link looks like it might be appropriate
13:24:25 <Siod> i'll get to reading
13:24:34 <ski> @karma+ dpiponi
13:24:34 <lambdabot> dpiponi's karma raised to 1.
13:24:40 <ski> @karma sigfpe
13:24:41 <lambdabot> sigfpe has a karma of 0
13:24:50 <ski> preflex: xseen dpiponi
13:24:50 <preflex>  dpiponi was last seen on freenode/#haskell 215 days, 20 hours, 23 minutes and 31 seconds ago, saying: BMeph: I might blog about one aspect of GLUT programming though it's a bit of a dirty hack really.
13:24:52 <applicative> sigfpe++\
13:24:54 <applicative> sigfpe++
13:24:55 <Siod> ski++
13:25:31 <ski> hehe, that quote looks like it's about exactly that blog post :)
13:26:08 <applicative> so, Siod, its a bit of a dirty hack, but you could try it :)
13:26:57 <parcs`> you would be better off with a saner framework than with glut + cont stuff
13:27:30 <applicative> Sion is using wxhaskell in any case
13:27:34 <parcs`> oh
13:27:58 <SinPatrones> somebody can help me with Haskell please
13:28:13 <ski> what do you have problems with, SinPatrones ?
13:28:30 <ski> are you looking for a book/tutorial ?
13:28:30 <applicative> SinPatrones: as is said in Rebel with a Cause, "Its all we ever do"
13:28:33 <SinPatrones> :D ...
13:28:42 <ski> or do you have some code which you wonder about ?
13:28:43 <SinPatrones> with "Type"
13:28:58 <ski> yes ?
13:29:07 <SinPatrones> just a momen please
13:29:10 <applicative> thats a good place to start worrying, the types
13:29:24 * ski waits for SinPatrones to type more
13:29:36 <b_jonas> By the way, I'll never forget my conversation here where I said that people new to programming should be taught procedural programming first whereas #haskell argued they should be taught declarative programming first. I'm unsure which one is right ever since.
13:30:01 * applicative wonders if SinPatrones is naming himself after a line of the Internationale
13:30:22 <opqdonut> I taught Introduction to Functional Programming at my uni this spring
13:30:24 <b_jonas> nexion: well, from the manual it seems there's a purer syntax, isn't there?
13:30:32 <opqdonut> and had one student who had never programmed before
13:30:34 <opqdonut> (math major)
13:30:45 <applicative> did it work?
13:30:48 <opqdonut> yeah
13:30:52 <opqdonut> full marks
13:30:55 <opqdonut> said he liked it
13:30:57 <b_jonas> opqdonut: there are math majors who have never programmed as a minor?
13:31:04 <b_jonas> oh, just one student
13:31:05 <b_jonas> okay
13:31:13 <b_jonas> great, congrats for that
13:31:25 <pooya72> :opqdonut what language did you teach?
13:31:27 <opqdonut> N=1 isn't proof, but it was refreshing
13:31:29 <opqdonut> haskell
13:31:33 <b_jonas> I'm curious now
13:31:33 <monochrom> I take the best or worst of both worlds: should be taught both procedural and declarative concurrently
13:31:46 <opqdonut> monochrom: declarative procedural?
13:31:46 <mauke> concurrent declarative programming
13:32:04 <b_jonas> monochrom: yeah, let them suffer
13:32:06 <pooya72> opqdonut: was it easy for them to pick it up?
13:32:06 * applicative is post-procedural
13:32:09 <monochrom> no, two courses taken at the same time
13:32:14 <opqdonut> b_jonas: I'd give you a link to the course material, but unfortunately it's in Finnish
13:32:23 * applicative is post-post-functional
13:32:36 <opqdonut> pooya72: the functional part was easy, the IO part was hard
13:32:37 <b_jonas> opqdonut: who cares? I keep linking to my Hungarian notes as well, because the program source codes are understandible
13:32:48 <b_jonas> opqdonut: I keep meaning to rewrite the good parts in English though
13:32:49 * ski is pre-braindamage
13:32:54 <jonaskoelker> can I somehow say (var1, var2, var3) <- (monad1, monad2, monad3) ?
13:33:05 <ski> jonaskoelker : `liftM3 (,,)'
13:33:11 <parcs`> :t uncurry3
13:33:12 <otters> b_jonas: do Hungarian programmers use English notation?
13:33:12 <opqdonut> b_jonas: well the good part was the exercises :)
13:33:12 <lambdabot> Not in scope: `uncurry3'
13:33:23 <monochrom> hahaha
13:33:55 <b_jonas> otters: if that means randomly renaming all variables so that it's not apparent who they are copying their homework from, then yes
13:34:01 <applicative> (var1, var2, var3) <- (,,,) <$> monad1 <*> monad2 <*>monad3
13:34:05 <otters> b_jonas: that is what it means
13:34:05 <ski> monochrom : misread you as "declarative concurrency"
13:34:08 <ski> (a la CTM)
13:34:25 <applicative> (var1, var2, var3) <- (,,) <$> monad1 <*> monad2 <*>monad3
13:34:48 <b_jonas> ski: what's a CTM?
13:34:57 <ski> @where CTM
13:34:58 <lambdabot> "Concepts, Techniques, and Models of Computer Programming", by Peter Van Roy,Seif Haridi, at <http://www.info.ucl.ac.be/~pvr/book.html>
13:35:15 <ski> (it's a good book)
13:35:33 <b_jonas> thanks
13:37:28 <ski> <SinPatrones> Defines a new type "Square Matrix" and functions:
13:37:32 <ski> <SinPatrones> Square sum :: Matrix -> Matatrices Square -> Square Matrices
13:37:33 <ski> <SinPatrones> to return the sum of two square matrices
13:37:33 <SinPatrones> alguein que hable español
13:37:46 <jonaskoelker> applicative: thanks, that worked :-)  I'm gonna' go with sequence and lists instead, though :P
13:37:49 <jonaskoelker> (makes for simpler code)
13:38:13 <applicative> if they are all the same type thats the obvious way forward
13:38:14 <jonaskoelker> (... readable by mere green-belt haskellers)
13:38:26 <ski> SinPatrones : are you to define a single type of square matrices ?
13:38:50 <ski> you need to pick some representation of a matrix
13:39:03 <ski> a simple one is to represent the matrix
13:39:05 <ski>   0 1
13:39:07 <ski>   2 3
13:39:11 <ski> as a list of lists
13:39:16 <ski>   [[0,1],[2,3]]
13:39:49 <ski> SinPatrones : so, how far have you come with defining a type for this ?
13:40:41 <ski> <SinPatrones> type SquareMatrices = [[Float]]
13:40:44 <ski> that works, yes
13:41:34 <b_jonas> must mean Double instead of Float. Float in haskell is like C float, right?
13:42:13 <ski> yes
13:42:44 <ski> <SinPatrones> sum :: SquareMatrices -> SquareMatrices -> SquareMatrices
13:42:49 <ski> <SinPatrones> sum n m = n + m
13:42:49 <ski> <SinPatrones> is that possible??
13:43:25 <ski> SinPatrones : no, not directly. you need to reach every element of the two matrices, and add them individually
13:43:48 <ski> SinPatrones : this could be done with a recursive function (or two), e.g.
13:44:31 <ski> <SinPatrones> .. do you know to somebody can speak spanish ??
13:44:32 <Paprikachu> does haskell have a concept of data structures?
13:44:38 <ski> SinPatrones : you might try #haskell.es
13:45:13 <ski> Paprikachu : yes
13:45:23 <ski> e.g. lists are a data structure
13:45:25 <Paprikachu> i mean something like arrays, linked lists (singly, doubly), deques, queues, sets/multisets, etc
13:45:35 <ski> there's also arrays, sets, maps, &c. in libraries
13:45:51 <ski> doubly linked lists aren't used commonly, but you can do it
13:45:54 <greymalkin> Paprikachu: It sounds like you're confusing "data structure" with "class" from OO
13:46:13 <Paprikachu> no i'm not.
13:46:13 <ski> @hoogle PQueue
13:46:14 <lambdabot> package pqueue
13:46:14 <lambdabot> package pqueue-mtl
13:46:15 <greymalkin> A tuple (x, y) is a data structure.
13:46:29 <ski> @hackage pqueue
13:46:29 <lambdabot> http://hackage.haskell.org/package/pqueue
13:46:33 <Eduard_Munteanu> SinPatrones: although you could have a Num instance for SquareMatrices
13:46:41 <Paprikachu> are there plain arrays?
13:46:48 <greymalkin> deques, queues, etc are defined by the way they are used.
13:46:50 <ski> yes
13:46:54 <Eduard_Munteanu> Paprikachu: how plain?
13:46:56 <ski> there's both immutable and mutable arrays
13:47:05 <Eduard_Munteanu> Also boxed and unboxed.
13:47:24 <Paprikachu> arrays like they are laid out in memory in C
13:47:35 <ski> @quote immutable.boxed
13:47:36 <lambdabot> elliott says: <Cale> Array is immutable boxed  <Cale> UArray is immutable unboxed  <Cale> IOArray is mutable boxed  <elliott> IOUArray is an array of debts.
13:47:41 <ski> Paprikachu : yep
13:47:50 <Eduard_Munteanu> Unboxed stuff is like that.
13:48:04 <Paprikachu> because lists are really inefficient data structures
13:48:12 <ski> there's no special syntax for arrays, just normal library functions
13:48:19 <Eduard_Munteanu> Paprikachu: how so?
13:48:29 <jmcarthur> Paprikachu: there are unboxed ones, which are based on ghc primops and such, and there are Storable ones, which are like C arrays (intended to be used for FFI stuff)
13:48:35 <Paprikachu> arrays beat them in almost _any_ use.
13:48:38 <jmcarthur> Paprikachu: lists are sometimes much faster
13:48:46 <jmcarthur> Paprikachu: consider consing over and over
13:48:49 <ski> > listArray (3,8) [1,4,2,8,5,7]
13:48:51 <lambdabot>   array (3,8) [(3,1),(4,4),(5,2),(6,8),(7,5),(8,7)]
13:48:54 <Paprikachu> these cases are very rare.
13:48:58 <ski> > listArray (3,8) [1,4,2,8,5,7] ! 5
13:48:59 <lambdabot>   2
13:49:01 <ski> > listArray (3,8) [1,4,2,8,5,7] ! 0
13:49:02 <lambdabot>   *Exception: Ix{Integer}.index: Index (0) out of range ((3,8))
13:49:03 <Eduard_Munteanu> Not really.
13:49:05 <jmcarthur> Paprikachu: or how about generating a list lazily and consuming it as you go?
13:49:13 <jmcarthur> Paprikachu: such things are *very* common in haskell
13:49:21 <Eduard_Munteanu> Even better in the presence of fusion.
13:49:45 <applicative> lists  aren't inefficient if they are never built
13:49:46 <ski> Paprikachu : because lists are lazy, they often aren't all present allocated in memory at once, instead they often act like "reified loops/iterators"
13:49:47 <jmcarthur> Eduard_Munteanu: although in the presence of fusion you might as well use arrays most of the time anyway :)
13:49:57 <Paprikachu> i know
13:50:14 <Paprikachu> i'm just questioning the way haskell deals with data
13:50:21 <Eduard_Munteanu> jmcarthur: yeah, but getting fusion to work for such arrays sounds more difficult
13:50:29 <ski> Paprikachu : e.g. you can get a list of all the characters from a big file, convert it to a list of lines, translate each line a bit, then output it -- and the whole list is probably never all in memory at once
13:50:39 <jmcarthur> Eduard_Munteanu: no easier for lists, though
13:50:48 <Paprikachu> you can do that with arrays too.
13:50:50 <jmcarthur> Eduard_Munteanu: it's just that the fallback (laziness) might be better sometimes
13:50:55 <b_jonas> @faq can you do efficient computation with lists in haskell?
13:50:55 <lambdabot> The answer is: Yes! Haskell can do that.
13:51:06 <ski> Paprikachu : yes, but manually, choosing a chunk size
13:51:18 <shapr> Any Haskellers in Annapolis, MD want to hang out?
13:51:19 <Paprikachu> and?
13:51:29 <jmcarthur> Paprikachu: it's a lot of work to do that with arrays
13:51:38 <greymalkin> What happens when there's a line longer than your chunk size?
13:51:40 <applicative> Paprikachu: you just need to figure out which of the 1000 types available is the one you need
13:51:43 <jmcarthur> shapr: MD? :o
13:51:48 <ski> just saying that you can get away with using lists where you couldn't in other languages, and that it's often pleasant to do so
13:52:00 <Eduard_Munteanu> jmcarthur: how so? I'd think fusion for productive list functions should be easier, especially if you want to generate elements one by one.
13:52:08 <greymalkin> How much code, and how many redundant checks are you willing to repeatedly code in the guise of optimized data access?
13:52:12 <medfly> shapr: hometown of Travis Pastrana?
13:52:15 <shapr> jmcarthur: Yah, I'm in Annapolis for a wedding today and tomorrow, figured I'd see if there were Haskellers to meet!
13:52:18 <shapr> medfly: who?
13:52:31 <applicative> shapr: I thought you'd joined the Navy
13:52:32 <Paprikachu> do understand me wrong, i love lists, they are the most awesome datastructure ever, but sadly they are sometimes inherently inefficient
13:52:36 <Paprikachu> *don't
13:52:46 <shapr> applicative: Nah, I'm nearly too old. Max age is 42
13:52:58 <medfly> shapr: http://images.newcelebritypics.com/img/celebs/images/t/travis_pastrana-12731.jpg
13:52:59 <applicative> ah well
13:53:10 <shapr> medfly: I don't watch TV...
13:53:21 <greymalkin> The point here is that the cases in Haskell where an array is more efficient than a list are vanishingly small.
13:53:23 <b_jonas> shapr: great, hope you'll find other haskellers there
13:53:27 <shapr> me too!
13:53:31 <applicative> Paprikachu: check out my favorite array library Data.Vector.Unboxed  http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial
13:53:42 <jmcarthur> Eduard_Munteanu: what makes you think that makes it any easier?
13:53:56 <medfly> shapr: a guy that does stunts, motocross, and rally racing :-)
13:54:03 <b_jonas> if not, then find some guests on the wedding that don't yet know they like haskell, and convert them :-)
13:54:12 <medfly> shapr: picture is him jumping out of an airplane with no parachute on.
13:54:23 <ski> Paprikachu : consider e.g. `main = do str <- getContents; putStr (unlines (map reverse (lines str)))' -- because the list of characters is lazy, it isn't first loaded into memory, and only then split into lines, each line reversed, &c.
13:54:37 <jmcarthur> Eduard_Munteanu: fusion relies on rewrite rules to make a more inlinable version of a function. that works just as well for arrays as for lists (although you lose some strictness, of course)
13:55:03 <ski> Paprikachu : instead all of `getContents',`lines',`map reverse',`unlines',`putStr' here execute in an interleaved fashion (like generators, more or less)
13:55:14 <Paprikachu> what does unlines do?
13:55:19 <jmcarthur> Eduard_Munteanu: but i'll say again, the fallback behavior of lists when fusion fails is nicer
13:55:31 <ski> > lines "this is\ma multi-line\mstring"
13:55:31 <Paprikachu> ah, i think i get it
13:55:32 <jmcarthur> > unlines ["foo", "bar", "baz"]
13:55:32 <lambdabot>   <no location info>:
13:55:32 <lambdabot>      lexical error in string/character literal at chara...
13:55:33 <lambdabot>   "foo\nbar\nbaz\n"
13:55:56 <shapr> medfly: But can he write Haskell?!
13:55:56 <ski> er
13:55:57 <ski> > lines "this is\na multi-line\nstring"
13:55:58 <lambdabot>   ["this is","a multi-line","string"]
13:56:04 <ski> > unlines ["this is","a multi-line","string"]
13:56:04 <greymalkin> Paprikachu: Don't (also) get me wrong. I'm not saying that there is no need for array-like behaviour; but to question thet fundamental data type of a language based solely on whether it's the most efficient for some particular case is silly.
13:56:05 <lambdabot>   "this is\na multi-line\nstring\n"
13:56:27 <Paprikachu> greymalkin: no, it isn't.
13:56:29 <ion> @check \s -> (unlines . lines) s == s
13:56:31 <lambdabot>   "Falsifiable, after 5 tests:\n\"\\906866\\86878\\821706\"\n"
13:56:32 <applicative> > lines $ unlines $ lines "this is\na multi-line\n\nstring\n"
13:56:33 <lambdabot>   ["this is","a multi-line","","string"]
13:56:45 <Paprikachu> questioning everything may sound stupid, but it's the key to understand it.
13:56:49 <applicative> > l unlines $ lines "this is\na multi-line\n\nstring\n"
13:56:50 <lambdabot>   Couldn't match expected type `([GHC.Base.String]
13:56:50 <lambdabot>                           ...
13:56:52 <applicative> >unlines $ lines "this is\na multi-line\n\nstring\n"
13:56:52 <Eduard_Munteanu> jmcarthur: hm, actually, I'm not sure, you might be right. I was thinking one must produce a whole array, but I don't think you need that.
13:56:57 <applicative> man i'm lost
13:57:14 <ski> applicative : s/>/> /
13:57:21 <applicative> yeah
13:57:39 <greymalkin> w/e
13:57:52 <jmcarthur> Eduard_Munteanu: exactly. that'
13:57:54 <jmcarthur> err
13:58:04 <jmcarthur> Eduard_Munteanu: exactly, that's what makes the vector library so awesome!
13:58:10 <applicative> Paprikachu: there are many arrayish libraries. Just because the Prelude uses lists all over doesnt mean anything
13:58:16 <applicative> vector++
13:58:45 <applicative> @karma vector
13:58:45 <lambdabot> vector has a karma of 1
13:58:54 <jmcarthur> Paprikachu: questioning is one thing, but making ignorant (i mean that in the literal sense, not in some derogatory way) claims is another.
13:59:19 <Paprikachu> so the program from ski reverses all lines read from stdin?
13:59:23 <ski> yes
13:59:33 * hackagebot incremental-parser 0.2.1 - Generic parser library capable of providing partial results from partial input.  http://hackage.haskell.org/package/incremental-parser-0.2.1 (MarioBlazevic)
13:59:40 <Paprikachu> easy with arrays
13:59:42 <jmcarthur> i think reversing is not a good example for lists
13:59:46 <ski> of course, in this case it'd be almost as easy to just call `getLine' repeatedly
13:59:50 <applicative> main = interact $ unlines . map reverse . lines
13:59:55 <jmcarthur> since you have to read everything into memory anyway
13:59:58 <b_jonas> but isn't it at once a bad example because getContents is evil?
14:00:08 <ski> jmcarthur : not more than one line at a time
14:00:12 <jmcarthur> b_jonas: IMO, yes
14:00:22 <b_jonas> jmcarthur: we reverse each line like rev, not like tac
14:00:36 <jmcarthur> oh i see
14:00:36 <applicative> bjonas, getContents is very good for small markdown documents like I write
14:00:46 <jmcarthur> i misunderstood Paprikachu and didn't read ski's code
14:00:58 <b_jonas> applicative: okay, but is it a good example for showing why we like lists?
14:01:36 <applicative> it's a good example of why we like lazy IO, insofar as we do
14:01:39 <applicative> you're right
14:02:32 <jmcarthur> Paprikachu: you say it's easy with arrays, but i'd be impressed if it was any easier with arrays than with lists, and also quite impressed if it's as efficient
14:02:47 <Eduard_Munteanu> Unfortunately, Prelude stuff seems to suck at fusion really hard.
14:02:48 <greymalkin> Paprikachu: The big reason that lists are more efficient for most operations in Haskell is strictly because of the lazy evaluation; The list rarely (if ever) needs to actually be created or traversed fully; an array would just be a block of memory that got very little use.
14:02:54 <jmcarthur> i mean, i'm one of those who believe that strings as lists was a bad idea, but not for quite the same reason
14:03:19 <jmcarthur> i just think strings normally aren't intended to be thought of as lists
14:03:28 <taylorgb> Isn't it just that you should give greatest visibility to the type of data structures that model the general case the best. Functional languages usually model recursion best, therefore cons lists are preferred; whereas imperative languages generally follow an iterative model, so arrays are generally preferred. Nothing stops you implementing libraries to provide the special cases, but you shouldn't necessarily choose it to be the default.
14:03:47 <Eduard_Munteanu> Also, think about arrays, if you try to expand them, you need contiguous chunks of memory.
14:04:05 <Eduard_Munteanu> And you might need to copy data around to do that.
14:04:32 <greymalkin> jmcarthur: Strings are very good as lists for computational linguistics :-P
14:05:10 <jmcarthur> greymalkin: lists of strings is a different matter, if that's what you mean
14:05:27 <greymalkin> Oh... and if you needed that larger hunk for just a single line in the middle (back to line parsing) you wouldn't get that space back until after the whole file was done being read.
14:06:13 <Paprikachu> [23:01:14]	<Eduard_Munteanu>	Also, think about arrays, if you try to expand them, you need contiguous chunks of memory.
14:06:15 <Paprikachu> [23:01:31]	<Eduard_Munteanu>	And you might need to copy data around to do that.
14:06:37 <greymalkin> jmcarthur: I'm speaking from the standpoint of parsing -- although the itermediate target is usually lists of strings... I guess I'd just point out that a string-as-list is way easier to tokenize than a string-as-block.
14:06:40 <Paprikachu> you won't believe me, but copying is actually more efficient than allocating little pieces of memory and storing data there
14:07:11 <jmcarthur> Paprikachu: our memory allocator is very very efficient (just an integer increment, basically)
14:07:24 <greymalkin> Paprikachu: For all sizes of memory < n -- where n is usually very large.
14:07:42 <greymalkin> For typical allocators.
14:07:55 <Egbert9e9> how do i compile glib if it refuses to do so?
14:08:02 <applicative> Paprikachu: i dont think main = interact $ map toUpper  allocates too much even for a zillion mb files :)
14:08:06 <Eduard_Munteanu> Yeah, you don't have to go through stuff like malloc().
14:08:08 <monochrom> I guess cache locality implies that sometimes copying wholesale is faster than fragmented heap data
14:08:09 <jmcarthur> once something gets promoted to the major heap it gets more expensive, but the majority of allocations never get there
14:08:34 <Eduard_Munteanu> You could have some sort of slab that packs objects tightly to maximize cache usage.
14:08:55 <monochrom> otoh ghc's heap allocator tries to compact and be contiguous, too
14:09:00 <jmcarthur> Eduard_Munteanu: you mean like a minor heap and a copy collector? ;)
14:09:26 <Eduard_Munteanu> jmcarthur: more like Linux's SLAB
14:09:40 <applicative> Paprikachu in any  case we love arrays here, it practically all we ever do
14:09:42 <jmcarthur> but linux's slab can't move things around dynamically
14:09:48 <Eduard_Munteanu> Yeah.
14:10:26 <b_jonas> who cares how efficient it is? you'll just rewrite the 1% of code that takes 99% of the time as more efficient if you really need to in the end.
14:10:37 <monochrom> the typical ghc-generated allocation code is "if hp exceeds limit then call GC else hp+=10" where hp is a register. also it may be -= instead of +=, I forgot
14:10:39 <b_jonas> and most of the time you don't need even that.
14:11:04 <applicative> Paprikachu: here for example is the standard going text library, called 'text' http://hackage.haskell.org/packages/archive/text/0.11.1.5/doc/html/Data-Text.html  read the beginning
14:11:47 <monochrom> actually s/call GC/call GC with current continuation/ so it knows how to resume after GCing
14:12:03 <thoughtpolice_> Eduard_Munteanu: jhc does something similar, and uses a SLUB-style design to pack objects together for better cache
14:12:08 <thoughtpolice_> *cache usage
14:12:45 <Eduard_Munteanu> thoughtpolice_: hm, part of their regions thingy?
14:14:04 <applicative> Paprikachu: here is the standard library for dealing with binary nonsense; it pervades all current Haskell code http://hackage.haskell.org/packages/archive/bytestring/0.9.2.1/doc/html/Data-ByteString.html
14:14:05 <thoughtpolice_> Eduard_Munteanu: no, part of the GC
14:14:19 <thoughtpolice_> john has seemingly abandoned the regions thing somewhat
14:14:38 <monochrom> I am not against knowing about efficiency. I think that people here are against it either. they speak like they are against it, here is why: they have seen too many people who are totally wrong about efficiency, so they don't want to hear anymore
14:14:48 <monochrom> err, typo
14:15:05 <b_jonas> monochrom: agreed
14:15:06 <monochrom> I am not against knowing about efficiency. I think that people here aren't against it either. they speak like they are against it, here is why: they have seen too many people who are totally wrong about efficiency, so they don't want to hear anymore
14:15:22 <b_jonas> yep
14:15:50 <greymalkin> I think we lost Paprikachu.
14:16:07 <applicative> oh no,  he was making excellent progress!!
14:16:12 <Paprikachu> i'm just annoyed that my c++ code won't compile
14:16:23 <thoughtpolice_> Eduard_Munteanu: but basically he has a SLUB style cache for every kind of data type, and he does lots of optimizations to minimize data type size (so for example, there are optimizations that make 'Maybe Int' representation basically int* - so you either have NULL for Nothing and non-NULL for Just x)
14:16:42 <thoughtpolice_> which is a nice optimization at any rate
14:16:58 <monochrom> in particular, if a C expert talks about C code efficiency, that's cool. but then he knows little about haskell and he still starts opiniating about haskell code efficiency, well that's moronic
14:17:02 <kstt> Please, how portable is a "cereal dump" ? Can a dump from an architecture A be loaded on an architecture B ?
14:17:13 <Eduard_Munteanu> thoughtpolice_: hm, nice
14:17:26 <Paprikachu> gladly i'm no a C expert.
14:17:32 <Paprikachu> *not
14:17:36 <hpc> kstt: what's in a cereal dump? text?
14:18:15 <thoughtpolice_> Eduard_Munteanu: jhc has a lot of neat little ideas like that, yeah
14:18:30 <kstt> hpc : a data of some type implementing Serialize
14:18:38 <hpc> ah
14:18:44 <Clint> hpc: he meants the result of 'put' written to a file
14:18:45 <greymalkin> I've seen people try to optimize "encode a number array as space-delimited base10 rep" by manually resizing and encoding directly into &std::string[0]...
14:18:46 <Paprikachu> also, this piece of c++ code should copy the lines from stdin to stdout with arrays, but it doesn't compile for whatever reason: http://ideone.com/u4XpW
14:19:11 <greymalkin> It was the day I found "premature optimization is the root of all evil" (I think that was Larry Wall)
14:19:11 <jmcarthur> kstt: it depends on if the Serialize instance is using "native"
14:19:23 <jmcarthur> kstt: ... or explicitly saying big or little endien
14:19:24 <kstt> Clint: ah, glad to see you are still here. I had to disconnect early on my previous attempt.
14:19:47 <Clint> off and on
14:20:54 <hpc> kstt: it doesn't specify, but the dependencies look sufficently kosher that im gonna guess it should work
14:21:45 <kstt> jmcarthur: "native" = instances automatically derived from ghc generics ?
14:22:15 <jmcarthur> kstt: native as in machine native byte ordering
14:22:43 <mauke> Paprikachu: the reason is error: invalid conversion from 'char' to 'const char*'
14:22:47 <jmcarthur> i don't know about whether instances derived using generics are cross platform
14:22:58 <Paprikachu> you don't say :P
14:23:34 <monochrom> woah, char -> const whatever* is 31337
14:23:36 <b_jonas> Paprikachu: that won't work even if it compiles. the "\n" would be printed between every two characters, because you're copying characterwise.
14:23:57 <mauke> Paprikachu: http://ideone.com/5H4bc
14:24:02 <b_jonas> Paprikachu: you'll have to print the "\n" explicitly
14:24:09 <Paprikachu> the "\n" is printed between each T's, which is std::string.
14:24:18 <kstt> jmcarthur: ok, thank you for this tip. I expected the doc to be more explicit on this point.
14:24:27 <mauke> Paprikachu: line[0] is not a std::string
14:24:32 <kstt> beside endianess, dumps should be portable then ?
14:24:38 <monochrom> wait, are we offering c++ tutorials too? :)
14:24:48 <jmcarthur> kstt: i would think so. the best way to know is to test, of course
14:24:50 <Paprikachu> fuck you.
14:24:56 <Paprikachu> i made a mistake, okay?
14:24:58 <jmcarthur> Paprikachu: hey now
14:25:03 <mauke> Paprikachu: excuse me?
14:25:05 <b_jonas> mauke: that works
14:25:09 <jmcarthur> Paprikachu: please take it easy
14:25:37 <mauke> yukkuri shiteitte ne
14:25:47 <Paprikachu> no, i don't take it easy
14:25:59 <jmcarthur> Paprikachu: then you won't last much longer here
14:26:06 <Paprikachu> treat me like a normal user and i treat you the same way
14:26:08 <kstt> :)
14:26:32 <kstt> so keep cool, like other haskellers here :)
14:26:34 <jmcarthur> Paprikachu: then don't take the "fuck you" route here
14:26:44 * ski isn't sure why Paprikachu got upset
14:26:45 <Paprikachu> [23:22:05]	<monochrom>	wait, are we offering c++ tutorials too? :)
14:26:50 <Paprikachu> that's the same, indirectly.
14:26:54 <jmcarthur> no it's not
14:26:59 <mauke> Paprikachu: not at all
14:27:01 <jmcarthur> it's a little hint that you are off topic
14:27:09 <newsham> fighters to their corners.
14:27:14 <b_jonas> jmcarthur: he didn't start the off-topicness
14:27:27 <jmcarthur> i wasn't trying to imply there was any wrongdoing there about being on topic
14:27:29 <mauke> it's a little hint that *we're* off topic
14:27:31 <b_jonas> jmcarthur: it was me and mauke replying who did
14:27:45 <jmcarthur> okay, i didn't mean to be insinuating about that
14:28:09 <Paprikachu> mono is saying that i should not post code, because he claims that this shows that i have no clue of c++, which is obviously wrong.
14:28:11 <kstt> anyway, such wording is not excusable, whatever the motivations
14:28:17 <b_jonas> jmcarthur: you weren't. Paprikachu: get a thicker skin please.
14:28:18 <applicative> Paprikachu: don't worry about any of this, people are very friendly here, but get touchy if you diss the language
14:28:36 <mauke> Paprikachu: where did you get that from?
14:28:50 <Paprikachu> it's what he wanted to say.
14:28:53 <mauke> Paprikachu: where did you get that from?
14:29:11 <newsham> ascii communications can lead to misunderstandings.
14:29:14 <Paprikachu> what do you mean by "get", it's obvious.
14:29:20 <mauke> Paprikachu: no, it isn't
14:29:26 <TouristFromNoobc> So, what's so great about static typing, Ive benn programming Python for a long time and never experienced much bugs from typing.
14:29:28 <mauke> Paprikachu: basically, you're crazy
14:29:32 <ski> Paprikachu : i only interpreted monochrom as being amused at C++ being discussed -- at least i saw no glee
14:29:32 <applicative> Paprikachu: don't worry about it
14:29:33 <Paprikachu> lemme caps it
14:29:43 <jmcarthur> Paprikachu: it is not obvious to many of us. look, if you want to talk this over we can do so in #haskell-ops or something
14:29:47 <greymalkin> TouristFromNoobc: Python is staticly typed.
14:29:54 <jmcarthur> or maybe just -blah
14:29:57 <Paprikachu> OH WAIT, ARE WE OFFERING C++ TUTORIALS TOO? :)
14:29:58 <kstt> greymalkin: what ?
14:29:59 <jmcarthur> since we haven't kicked anybody
14:30:15 <newsham> tourist: its just a sanity check on your code that can find bugs early.  in dynamic typing you can write test cases to look for bugs.  in static typing you get some double checking over your code at compile time without writing tests.
14:30:32 <taylorgb>  TouristFromNoobc: Have you even forgot to return the value of a function and had to try and find out why a long chain of function calls returns None?
14:30:34 <applicative> Paprikachu: if you are being genuinely dissed, this is against the rules. If there is a dispute it should go to #haskell-ops
14:30:42 <b_jonas> Paprikachu: just drop it and go on. none of us were trying to insult you.
14:30:47 <newsham> tourist: if you never make typing mistakes then you wont notice any benefit.
14:30:49 <kstt> TouristFromNoobc: then you belong to a very small elite, congratulations
14:31:06 <applicative> Paprikachu:  our principal purpose is to help  you learn haskell
14:31:10 <greymalkin> Oh... strictly typed, not statically.
14:31:34 <ski> greymalkin : i think the term "strongly typed" is usually employed
14:31:42 <applicative> Paprikachu: which we would very much like  to do
14:31:47 <mauke> ski: and I usually complain about it
14:32:02 <ski> mauke : about C++ ?
14:32:04 <hpc> "strongly typed" is a very nebulous phrase
14:32:13 <mauke> ski: no, about "strongly typed"
14:32:16 <ski> oh, ok
14:32:19 <kstt> strongly typed is implied but does not make much sens for a language that does not care what types are, as long as objects respond to methods at runtime.
14:32:29 <monochrom> duplicity is a python program. it had a silly bug entirely due to lack of static typing
14:32:46 <Peaker> what does duplicity do?
14:32:48 <greymalkin> ski: Yeah... I knew it was one of those 's' words ;-)
14:32:55 <hpc> what's the bug?
14:32:56 <monochrom> duplicity makes backups
14:33:02 <Clint> sometimes it does
14:33:06 <kstt> :)
14:33:09 <Peaker> monochrom, what was the bug?
14:33:30 <mauke> TouristFromNoobc: static typing isn't just a safety rail (that is, it doesn't just prevent bad stuff). it also enables good stuff.
14:33:30 <monochrom> it'll take me a while to find its url again
14:33:42 <newsham> sometimes in python you forgot to include a "return" and inadvertantly implicitely return None, when you didnt intend to.
14:33:44 <applicative> TouristFromNoobc: if you have static types, then you can have all kinds of cool relationships between them
14:33:52 <newsham> thats something a type checker would tell you about immediately
14:34:15 <hpc> sometimes you can trick the type checker into writing code for you
14:34:20 <Peaker> TouristFromNoobc, when you say "I've never experienced much bugs from typing" -- what do you mean? What kind of bugs did you encounter?
14:34:22 <b_jonas> applicative: as the devil's advocate, you can have most of those relationships among dynamic types too
14:34:27 <kstt> the None | AnyType pattern, accepted in python (as well as in most language), cause bugs everyday
14:34:43 <Peaker> TouristFromNoobc, did you ever have a program crash with "NoneType has no attribute 'foo'" ?
14:34:44 <newsham> billion dollar mistake, kstt? :)
14:34:52 <ski> kstt : *nod*, "domain contagion"
14:35:00 <applicative> b_jonas: yes,  but are they as easily comprehended as fmap, >>=, & co?
14:35:43 <b_jonas> applicative: well, I think you can have an fmap and >>= with dynamic types too. you can't have a return without explicitly telling its type though.
14:35:48 <thoughtpolice_> i'll also just throw out that I love static types from an API perspecitve. makes it so much easier to derive intent and how to use an API in many cases. i also feel safer when i distribute statically typed libraries - it stops bugs in my code, and my users code over the lifetime of my project
14:35:59 <Peaker> if you call:  System.Mem.Weak.addFinalizer foo (delete foo) -- the finalizer references "foo" too, will that not cause any trouble?
14:36:05 <b_jonas> applicative: but static typing allows you to talk about those relationships more easily
14:36:19 <newsham> paprikachu: btw, there's a #haskell-blah channel for topics that are off-topic here.  you could always ask c++ questions there if you wanted to talk about c++ (besides the normal C/c++ irc channels)
14:36:21 <b_jonas> applicative: because if you use dynamic types, you no longer have [a]
14:36:25 <thoughtpolice_> i write in ruby a lot at work, and when you have code which isn't rigorously documented (which happens in any language,) i have to go source diving more often than I would like
14:36:27 <b_jonas> applicative: you only have lists
14:36:30 <ski> TouristFromNoobc : i suspect that you've just never identified the type-related bugs as being *type*-related bugs
14:36:40 <Peaker> b_jonas, without static types, the differences between <*> and =<< and more advanced stuff becomes untractable quickly
14:36:43 <b_jonas> and you don't know what type of values they contain until you look into them
14:37:17 <b_jonas> ski: no, you don't understand. he just writes perfect code. he doesn't have any bugs.
14:37:24 <ski> b_jonas : you can still think about those types, even if the language processor doesn't keep track of it for you
14:37:25 <applicative> my impression was like Peaker's , but I can hardly profess expertise
14:37:40 <newsham> bjonas: we dont need the sarcasm.  lets be nice.
14:37:48 <b_jonas> sorry
14:37:49 <ski> b_jonas : oh, i was under the impression that TouristFromNoobc was a programmer
14:37:53 <b_jonas> newsham: you're right
14:37:57 <Peaker> static types allow much more abstraction to be used before it becomes incomprehensible. This in turn allows more code re-use, more DRY, and better code
14:38:07 <Peaker> (amongst the various advantages of static types)
14:38:14 <applicative> TouristFromNoobc: life is not worth living without fmap >>= <*> mapM_ and co
14:38:22 <TouristFromNoobc> ok maybe its good, never really had the chance to write something big in haskell
14:38:32 <TouristFromNoobc> and i guess computer games isnt haskells forte
14:38:48 <hpc> @hackage monadius
14:38:48 <lambdabot> http://hackage.haskell.org/package/monadius
14:39:05 <newsham> i think with some work, computer games could be haskells forte...  perhaps...
14:39:18 <kstt> haskell is good at a lot of things, including computer games
14:39:22 <newsham> i mean, people write computer games in .js all the time..
14:39:36 <Peaker> the documentation for addFinalizer says "A specialised version of mkWeakPtr, where the Weak object returned is simply thrown away (however the finalizer will be remembered by the garbage collector, and will still be run when the key becomes unreachable)." -- does this mean the finalizer is not allowed to make the object reachable? Otherwise it seems paradoxical
14:39:40 <jmcarthur> newsham: i would like to see that
14:39:42 <hpc> newsham: to be fair, javascript has the GUI code baked in :P
14:39:49 <jmcarthur> (plug: #haskell-game is a thing)
14:39:56 <kstt> to be totally honnest, haskell does not bring much for the case of numeric-intensive computation based on array updates through loops
14:39:57 <newsham> hpc: right.. i was alluding to perf though..
14:40:19 <Peaker> any experienced FFI user can confirm/deny the above?
14:40:26 <applicative> TouristFromNoobc: I like this specious meme "Haskell is no good for computer games"
14:40:28 <jmcarthur> kstt: what makes you say that?
14:40:33 <applicative> TouristFromNoobc: since I hate computer games
14:40:42 <monochrom> no, I can't find the duplicity bug anymore
14:40:50 <kstt> jmcarthur: experience on a raytracer
14:41:04 <applicative> my haskell''' typechecker rejects the program if it realizes it's a game
14:41:07 <hpc> Peaker: i don't think in general, you want a finalizer to bring things into scope
14:41:12 <monochrom> (I have also forgotten almost all information about the bug)
14:41:12 <kstt> jmcarthur: and data from the shootout
14:41:27 <jmcarthur> kstt: were you trying to rely in some fundamental way on imperative array updates?
14:41:34 <jmcarthur> the shootout is crap
14:41:52 <kstt> jmcarthur: not blindly
14:41:54 <newsham> whats wrong with the shootout?
14:41:59 <Peaker> hpc, what do you mean? graphics-drawingcombinators is using   font <- createFont  ...   and then addFinalizer font (destroyFont font)   -- which seems like it might not work
14:42:07 <applicative> someone needs to work on that shootout nonsense.
14:42:11 <b_jonas> applicative: wow, how does that work?
14:42:13 <kstt> jmcarthur: I just needed a fast a simple ray tracer
14:42:16 <b_jonas> I mean, rejecting games
14:42:24 <b_jonas> do you have a formal description?
14:42:27 <applicative> b_jonas: it's still theoretical
14:42:31 <jmcarthur> the shootout puts silly constraints on the benchmarks just to test very specific things about the languages, like hash table performance (hence the terrible fasta results, which relied on somebody to write a hashtable implementation just for the benchmark...)
14:42:31 <applicative> :)
14:42:47 <applicative> that k-nucleotide
14:42:50 <jmcarthur> oh that
14:42:50 <applicative> that's
14:42:55 <jmcarthur> i mix them up
14:42:57 <kstt> the C++ variant is shorter, cleaner, and *much* faster than the haskell variant, period. I am the first to be sorry about that fact, but it remains a fact.
14:43:07 <newsham> jmc: *shrug* still lots to be learned, even if some of the constraints might seem arbitrary.
14:43:13 <applicative> but i think that was stupid, I was just working on it with vector
14:43:41 <jmcarthur> the binary tree one is another example. it forces you to do things in a way that most haskellers wouldn't really do
14:43:48 <applicative> previous haskell entries didn't build an imperativestyly hash table implementation
14:43:57 <thoughtpolice_> binary-trees is actually *faster* if you take away some of the strictness
14:44:04 <newsham> jmc: and as a result you can see what happens when you try to write certain non-idiomatic stuff in haskell
14:44:13 <applicative> someoneshould do that without gouy noticing
14:44:16 <newsham> it still points out strengths and weaknesses in langauges..  seems worthwhile to me
14:44:18 <thoughtpolice_> ISTR at one point you could get a 10%-ish or so speed increase by removing the strictness on the data type leafs, IIRC
14:44:56 <b_jonas> I never care about benchmarks people make
14:45:00 <jmcarthur> it would be more worthwhile if the benchmarks themselves were more clearly explained up front
14:45:13 <jmcarthur> people draw bad conclusions from the shootout all the time
14:45:14 <Paprikachu> also, this: http://ideone.com/MPE2l
14:45:20 <Paprikachu> :3
14:45:21 <jmcarthur> not just about haskell
14:45:35 <applicative> the hash table  one should go.  there is nothing wrong with using an array to hash the little strings as ints
14:45:38 <newsham> s'ok, people draw bad conclusions without benchmarks, too :)  its kinda what people do.
14:45:54 <b_jonas> newsham: yes, I do that
14:45:56 <jmcarthur> but my complaints are about these particular benchmarks and their presentation
14:46:06 <b_jonas> in some rare occasions I do benchmarks myself
14:46:26 <newsham> fair enough.  i always thought they were pretty informative if you dont get carried away by just toying with the numbers.
14:46:41 <newsham> its nice to see what the diff impls look like, how they perform, etc
14:46:46 <jmcarthur> Paprikachu: is that supposed to be in response to the list stuff?
14:46:52 <jmcarthur> Paprikachu: where's the array?
14:47:01 <Paprikachu> std::string is an array
14:47:13 <mauke> Paprikachu: but where's the array of lines?
14:47:23 <Paprikachu> you don't need it
14:47:23 <hpc> obviously we need to change the way we write benchmarks - instead of many programs solving a single problem, write a single program and make it solve all the problems
14:47:33 <hpc> then see which problem it solves fastest! genius! :D
14:47:45 <jmcarthur> Paprikachu: you have an iterator where we would have a list
14:48:01 <mauke> jmcarthur: really?
14:48:14 <b_jonas> so are colored alligators a better representation of lambda calculus than singing birds are?
14:48:16 <monochrom> sounds like a SAT solver to me
14:48:44 <Paprikachu> actually the only data structure that's needed at al is the array for the string
14:48:46 <jmcarthur> mauke: where *ski's version from earlier was a list, at least
14:48:51 <ski> b_jonas : i think the idiot bird has more appeal
14:49:03 <mauke> jmcarthur: where's the iterator?
14:49:13 <parcs`> kstt: what c++ variant?
14:50:28 <b_jonas> what keeps bothering me about the birds is, when you hear the name of a bird, how do you find or recognize that bird in the jungle?
14:50:42 <jmcarthur> mauke: you are right to point this out. it's really just a for loop
14:50:44 <b_jonas> do the names describe the plumage or something?
14:51:09 <hpc> b_jonas: double-blind taste test ;)
14:51:27 <b_jonas> you don't have this problem with the eggs that actually hatch into the crocs instead of just naming crocs
14:51:50 <b_jonas> I mean, maybe for someone with more experience in nature the birds make sense
14:52:18 <jmcarthur> Paprikachu: anyway, the case for lists we were making was precisely where you chose not to use an array at all, which is to store all the lines from the input
14:52:32 <solidus-river> how easy is it to map knowledge of haskell to ocaml?
14:53:01 <greymalkin> map ( + awesomeness) ocaml
14:53:03 <jmcarthur> solidus-river: if you know haskell and you know C, ocaml is somewhere in between
14:53:07 <Paprikachu> i thought it was about strings as lists vs strings as arrays
14:53:19 <jmcarthur> Paprikachu: i agree that strings as lists is a bad idea
14:53:24 <jmcarthur> a bad default, that is
14:53:29 <solidus-river> jmcarthur: awesome, i know c, and i'm almost done with learn you a haskell (on zippers)
14:53:42 <solidus-river> i was hoping going over ocaml would be an easy skip after that
14:53:59 <jmcarthur> there's almost no reason to learn ocaml after learning haskell and c, IMO
14:54:12 <jmcarthur> unless it's for school/work
14:54:19 <solidus-river> jmcarthur: whats your reasoning for that?
14:54:20 <Paprikachu> if for whatever reason you want to store all lines in memory, it changes completely, thats clear
14:54:32 <jmcarthur> solidus-river: i just don't think it really brings much to the table on its own
14:54:41 <monochrom> ocaml has an interesting type system and an interesting module system. they are worth learning. OOP will look different and sane
14:55:11 <mauke> Paprikachu: the thing is, the Haskell version "stores" all lines in a list but it still doesn't read it all into memory
14:55:17 <jmcarthur> solidus-river: haskell mostly supercedes it, apart from the powerful module system in ocaml. i don't care for the OOP stuff in ocaml. if haskell is ever too slow, the FFI to C is plenty enough
14:55:49 <solidus-river> how does F# compare to both?
14:56:22 <jmcarthur> never used F#
14:56:57 <Peaker> I haven't used ocaml but I heard it had anonymous type sums, and boy I want those (and anonymous records too)
14:57:22 <jmcarthur> Paprikachu: the interesting thing about lists in haskell isn't for using them as data, but for using them as codata, which is just a way of saying that you can in some sense use it as a control structure
14:57:52 <Peaker> Haskell's ADTs are in a sense too rigid.. When you build a large computational pipeline, the intermediate steps may very well have slightly different types, but either you have to define types for each of these (with lots of repetition) or use coarse/inaccurate types
14:57:55 <jmcarthur> Paprikachu: lists are essentially some convenient combination of typical linked lists and "loops that might terminate"
14:58:22 <jmcarthur> Peaker: it has polymorphic variants, and they are... alright...
14:58:25 <Paprikachu> yeah, something like a generating iterator
14:58:37 <mauke> > [0 ..]
14:58:38 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
14:58:43 <mauke> > zip [0 ..] "hello"
14:58:44 <lambdabot>   [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
14:58:49 <jmcarthur> Peaker: they are convenient sometimes, but they complicate the type system a lot (they essentially require subtyping)
14:58:59 <moebius_eye> > zip [0 ..] "hello"
14:59:00 <lambdabot>   [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
14:59:05 <moebius_eye> what?
14:59:26 <solidus-river> moebius_eye: putting > before a command runs it in a server side ghci instance i'm guessing
14:59:33 <Peaker> jmcarthur, why do they require subtyping?
14:59:38 <moebius_eye> solidus-river: I know
14:59:45 <Paprikachu> > 1+True
14:59:46 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
14:59:46 <lambdabot>    arising from the literal `1'...
14:59:48 <Paprikachu> :(
15:00:05 <moebius_eye> > True and false
15:00:06 <lambdabot>   Not in scope: `false'
15:00:06 <jmcarthur> Peaker: if you write a function that accepts `Foo, `Bar, or `Baz, you want it to also accept data that can only be `Foo or `Bar, for example
15:00:10 <moebius_eye> > True and False
15:00:11 <Paprikachu> > if 1 then True else False
15:00:11 <lambdabot>   Couldn't match expected type `([GHC.Bool.Bool] -> GHC.Bool.Bool)
15:00:11 <lambdabot>           ...
15:00:12 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
15:00:12 <lambdabot>    arising from the literal `1'...
15:00:25 <monochrom> try "True && False"
15:00:43 <moebius_eye> > True && False
15:00:44 <lambdabot>   False
15:00:49 <Peaker> jmcarthur, that means unification is more flexible, not sub-types, iiuc...
15:00:57 <Paprikachu> how can i make 1+True compile? :<
15:00:58 <hpc> jmcarthur: why, that's what unsafeCoerce is for!
15:01:01 <hpc> :P
15:01:06 <mauke> Paprikachu: why would you want to?
15:01:11 <Peaker> jmcarthur, similarly to how type-class restrictions add up in unification, anonymous sums can unify too (or intersect in contravariant positions)
15:01:12 <Paprikachu> just for fun
15:01:25 <mauke> Paprikachu: define a Num instance for Bool
15:01:27 <moebius_eye> > Bool(1)
15:01:28 <lambdabot>   Not in scope: data constructor `Bool'
15:01:30 <monochrom> 1 + fromEnum True
15:01:32 <applicative> > let (true,false) = (True,False) in true && false
15:01:33 <lambdabot>   False
15:01:41 <ski> jmcarthur : i like "might terminate" :)
15:02:07 <monochrom> also, if toEnum 1 then "x" else "y"
15:02:08 <ski> > 1 + fromEnum True  -- Paprikachu
15:02:09 <lambdabot>   2
15:02:17 <greymalkin> jmcarthur, Paprikachu: Stream parsing is pretty ugly using arrays for strings; Other than static representation (output), when would a string be better as an array?
15:02:43 <Paprikachu> but i want it to be of type Bool, not Int
15:02:53 <jmcarthur> greymalkin: we have a lot of convenient functions for these purposes already
15:02:57 <hpc> greymalkin: when all you need to do is store it, for instance
15:03:03 <monochrom> toEnum (1 + fromEnum True) :: Bool
15:03:06 <hpc> [Char] has a lot of per-character memory overhead
15:03:06 <applicative> > map (fromEnum.even) [1..10]
15:03:07 <lambdabot>   [0,1,0,1,0,1,0,1,0,1]
15:03:15 <ski> Paprikachu : if you really want to, you can hack up an `instance Num Bool where ...', defining `(+)',&c.
15:03:19 <jmcarthur> greymalkin: i mean, look at the text library!
15:03:27 <Paprikachu> can you show me how o do that?
15:03:31 <Paprikachu> *to
15:03:33 <applicative> > map (fromEnum.(<5)) [1..10]
15:03:34 <lambdabot>   [1,1,1,1,0,0,0,0,0,0]
15:04:02 <ski> Paprikachu : what do you want `True + True' to be ? `True' ? `False' ? a run-time error ?
15:04:14 <Paprikachu> true
15:04:35 <Paprikachu> True + something = True, False + False = False
15:04:48 <applicative> which is 0 :)
15:04:49 <ski> how about subtraction ?
15:04:53 <ski> and multiplication ?
15:05:10 <monochrom> you can leave them undefined
15:05:14 <Paprikachu> False - True = True, True - False = False, True - True = True, False - False = False
15:05:15 <tgeeky> ski: compile time error, unicorn, respectively
15:05:22 <ski> what should `2 :: Bool' be ? `False' or a run-time error ? or maybe `True' that as well ?
15:05:30 <Paprikachu> err, True - False = True
15:05:35 <applicative> okay those are 4 lines of your  Num Bool instance
15:05:46 <mauke> this is a bit like "hey, I don't know C++ but can you show me how to make print 1, 2, 3; compile?"
15:05:47 <Paprikachu> and True - True = False
15:06:05 <Paprikachu> 2 :: Bool is True
15:06:07 <Eduard_Munteanu> You could make it similar to the boolean algebra stuff.
15:06:19 <mauke> Paprikachu: what is -True?
15:06:19 <jmcarthur> i honestly don't think it's too crazy to have Num Bool
15:06:33 <Paprikachu> mauke: True
15:06:36 <jmcarthur> i haven't thought through all the properties yet
15:06:46 <tgeeky> jmcarthur: i always assumed it would look like GF(2)
15:06:50 <jmcarthur> (as if there are any specified anyway)
15:06:51 <mauke> Paprikachu: what is True + (-True)?
15:06:53 <tgeeky> or Z/2Z, if you want to think of it that way
15:06:56 <ski> Paprikachu : so `n :: Bool' where `n' is an integer literal is `True' iff `n' is not zero ?
15:07:01 <Paprikachu> True
15:07:03 <Eduard_Munteanu> Negation and reciprocals should be logical negation I guess.
15:07:08 <Paprikachu> ski: yes
15:07:15 <jmcarthur> tgeeky: yeah, we already have all kinds of modular arithmetic instances
15:07:31 <mauke> Paprikachu: so x - y is no longer x + (-y)?
15:07:40 <Paprikachu> no.
15:07:44 <monochrom> it's the same phenomenon as what I said about efficiency. no, it is not crazy to consider efficiency or Num Bool, but among the people who consider them, very, very few actually know what they're talking about
15:07:57 <Paprikachu> well, let's make -True be False
15:08:16 <mauke> still doesn't work
15:08:30 <Paprikachu> QQ
15:08:33 <Paprikachu> then it's TRUE
15:08:47 <jmcarthur> so (+) = (||)?
15:08:48 <tgeeky> Paprikachu: if that doesn't work, then you're boned
15:08:54 <mauke> how about Bool doesn't have a sensible Num instance
15:08:58 <Eduard_Munteanu> I'm thinking of (+) = or, (*) = and, - x = not x, a / b = a * (not b)
15:09:38 * hackagebot Elm 0.1.1.5 - The Elm compiler and server.  http://hackage.haskell.org/package/Elm-0.1.1.5 (EvanCzaplicki)
15:09:44 <mauke> Eduard_Munteanu: x + (-x) = 1? :-)
15:09:51 <Eduard_Munteanu> Yep.
15:10:10 <Paprikachu> no, True
15:10:15 <Paprikachu> :P
15:10:21 <Eduard_Munteanu> Fair point :)
15:10:32 <monochrom> try using xor for plus
15:10:33 <tgeeky> x - x = 0; x * 1/x = 1
15:10:54 <ski> Paprikachu : so subtraction gives `False' only when both bools are `False' ?
15:11:10 <jmcarthur> http://en.wikipedia.org/wiki/Boolean_ring
15:11:11 <tgeeky> ski: True!
15:11:16 <applicative> Paprikachu: i started your num instance http://codepad.org/homqZ61r
15:11:18 <Paprikachu> subtraction gives False when both bools are equal
15:11:28 <otters> strangely, True's internal representation is 576460752303423488
15:11:30 <otters> in Int form
15:11:47 <Paprikachu> what?
15:11:57 <Paprikachu> joke or real=
15:11:59 <Paprikachu> ?
15:12:01 <tgeeky> > True :: Int -- is this 5764...
15:12:02 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
15:12:02 <lambdabot>         against inferred type ...
15:12:03 <Eduard_Munteanu> BTW, does Num require anything, like axioms?
15:12:05 <tgeeky> False!
15:12:10 <otters> based on a highly formal process which involves unsafeCoerce True :: Int
15:12:15 <jmcarthur> otters: that was a pointer
15:12:19 <mauke> it's 1454860422 here
15:12:22 <otters> oh man
15:12:25 <otters> silly me
15:12:30 <Paprikachu> how can i print the value of True?
15:12:30 <otters> why do they even let me near computers
15:12:37 <tgeeky> > show True
15:12:38 <lambdabot>   "True"
15:12:46 <Paprikachu> i mean the internal value :P
15:12:50 <geekosaur> define "value of"
15:12:52 <barrucadu> The value of True is True.
15:12:52 <mauke> Paprikachu: there is no internal value
15:12:57 <pooya72> just a random question, what other programming language do you guys use that you feel "fits" really well with haskell. I'm assuming C given the FFI but other than that. Like maybe python -> C -> haskell
15:13:05 <Eduard_Munteanu> data Bool = False | True
15:13:08 <applicative> oh my god, dirty secrets of  ghc True = 576460752303423488
15:13:14 <mauke> pooya72: I use Perl
15:13:14 <Eduard_Munteanu> You can use toEnum, though
15:13:15 <monochrom> ghc represents True by a pointer to a shared record
15:13:18 <mauke> but I don't know if it "fits"
15:13:23 <Eduard_Munteanu> If that makes any sense.
15:13:23 <applicative> 64bit Truth is objective
15:13:25 <Paprikachu> wtf?
15:13:29 <tgeeky> pooya72: haskell is a unique snowflake, just like everyone else
15:13:31 <Eduard_Munteanu> > toEnum True
15:13:32 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
15:13:32 <lambdabot>         against inferred type ...
15:13:34 <pooya72> mauke: why?
15:13:35 <Paprikachu> why does ghc do it like that
15:13:42 <pooya72> tgeeky: haha
15:13:44 <mauke> pooya72: because it's good
15:14:04 <Eduard_Munteanu> Erm, fromEnum.
15:14:04 <jmcarthur> Paprikachu: because that's how it does constructors with no fields
15:14:08 <Eduard_Munteanu> > fromEnum True
15:14:09 <lambdabot>   1
15:14:15 <Paprikachu> ?
15:14:16 <applicative> pooya72: Standard ML of course
15:14:18 <tgeeky> applicative: false. Lambda_CMB is at least 10^120, so 120 bit truth.
15:14:25 <pooya72> mauke: that was assumed :) I'm a not real programmer so don't know strength weaknesses...
15:14:27 <jmcarthur> Paprikachu: True and False are just constructors
15:14:35 <mauke> @src Bool
15:14:35 <lambdabot> data Bool = False | True deriving (Eq, Ord)
15:14:35 <pooya72> applicative: why Standard ML?
15:14:38 * hackagebot Elm 0.1.1.6 - The Elm compiler and server.  http://hackage.haskell.org/package/Elm-0.1.1.6 (EvanCzaplicki)
15:14:43 <Paprikachu> huh?
15:14:47 <tgeeky> pooya72: it's an ancestor to Haskell
15:14:53 <Paprikachu> True and False are not values?
15:15:00 <jmcarthur> they are values
15:15:00 <Eduard_Munteanu> Paprikachu: they are
15:15:03 <otters> okay, so why is unsafeCoerce 'a' == 97 as In?
15:15:05 <Eduard_Munteanu> True :: Bool
15:15:05 <otters> Int
15:15:05 <jmcarthur> constructors are values
15:15:06 <tgeeky> @src Bool
15:15:06 <lambdabot> data Bool = False | True deriving (Eq, Ord)
15:15:12 <otters> because that's the actual ascii codepoint
15:15:12 <monochrom> values are pointers to records
15:15:21 <otters> rather, why is True represented as a pointer and 'a' not
15:15:28 <pooya72> tgeeky: you mean Perl or Standard ML?
15:15:30 <Eduard_Munteanu> otters: why wouldn't it be?
15:15:37 <Eduard_Munteanu> > chr 97
15:15:38 <lambdabot>   'a'
15:15:38 <applicative> pooya72: nice module system, strict evaluation, none of this fancy higherkinded nonnsense
15:15:43 <tgeeky> pooya72: ML is an ancestor to Haskell. Perl is on a different tree.
15:15:46 <otters> True seems like it would be an easy primitive
15:15:50 <otters> since there are only two values
15:15:54 <pooya72> tqeeky: yeah
15:15:58 <jmcarthur> otters: agreed
15:16:02 * applicative wonders what tree perl is on, awk-> sed->
15:16:11 <applicative> or is that sed-> awk
15:16:13 <tgeeky> have any of you ever actually played with the language 'Gofer'?
15:16:14 <jmcarthur> otters: unfortunately ghc doesn't do anything special with enum types like this
15:16:20 <otters> nuts
15:16:22 <pooya72> applicative: tqeeky: but if it's so similar to haskell why use it?
15:16:29 <monochrom> I haven't told you the full story of representing True and False by GHC. they are two pointers, but there is more.
15:16:39 <pooya72> applicative: Standard ML that is...
15:16:41 <mauke> applicative: perl draws from C, sh, awk, sed, basic, ada, lisp, ...
15:16:48 <jmcarthur> otters: crazy optimization people will sometimes use newtypes around Ints instead of ADTs because of this
15:16:51 <tgeeky> pooya72: I didn't assert that it was 'so similar.' I said it was an ancestor. Your question is asking like, what need is there for your parents if we have you?
15:16:55 <Eduard_Munteanu> otters: True is actually represented merely as a constructor tag
15:17:11 <Eduard_Munteanu> It is a nullary constructor, mind.
15:17:15 <otters> right
15:17:18 <pooya72> tqeeky: so what need does it cover?
15:17:19 <jmcarthur> otters: also, even as a primitive, you have to suppose laziness somehow
15:17:23 <ski> Paprikachu : that leaves multiplication
15:17:29 <otters> I see
15:17:33 <tgeeky> pooya72: haskell? It was designed to do programming language research
15:17:35 <otters> You learn something new every day
15:17:36 <jmcarthur> otters: so while ghc might be able to unbox bools in such a world, you would still need a boxed version
15:17:43 <Paprikachu> True * True = True, else False
15:17:43 <jmcarthur> for some cases
15:17:49 <ski> ok
15:17:58 <pooya72> tqeeky: no Standard ML. What need does it cover that you use alongside haskell.
15:18:11 <applicative> tgeeky: it a commercial plot to bring Research Software Ltd (tm) down
15:18:28 <pooya72> tgeeky: just trying to understand languages
15:18:32 <greymalkin> Paprikachu: And (True / True) should be what?
15:18:40 <applicative> pooya72: evaluation is strict, it has a superior module system
15:18:43 <tgeeky> pooya72: oh, heck if I know. I've never used ML. I assume nobody would use it these days, given we have Haskell.
15:18:46 <Eduard_Munteanu> Sounds like false to me,
15:18:47 <jmcarthur> MLton is a pretty cool "feature" of SML
15:18:47 <mauke> greymalkin: / is not in Num
15:18:47 <Paprikachu> True
15:19:00 <Ralith> tgeeky: haskell is not a superset of ML.
15:19:13 <tgeeky> Ralith: I didn't say that specifically, and I don't think it
15:19:13 <monochrom> exploiting address alignment, i.e., the lower 2 or 3 bits of an address do not contain information, those lower bits are also used to hold whatever GHC wants to store.
15:19:33 <tgeeky> Ralith: I'm just saying, if you're sitting down to accomplish some goal, I'm not sure why one would pick ML.
15:19:36 <Ralith> tgeeky: nor does haskell obsolete ML in any other regard :P
15:19:37 <greymalkin> mauke: :( But if we're inventing a mostly-arbitrary type conversion, why not put it in for completeness?
15:19:41 <jmcarthur> monochrom: i thought that was not the case...
15:19:48 <pooya72> applicative: cool thanks
15:19:57 <jmcarthur> monochrom: if it were, wouldn't unboxed ints have lower precision than native? and i'm pretty sure they don't...
15:20:06 <Ralith> well, perhaps you could argue that the type system is a superset
15:20:13 <hpaste> ski pasted “instance Num Bool” at http://hpaste.org/69115
15:20:17 <ski> Paprikachu ^
15:20:28 <monochrom> more precisely, in the Bool case, 1 bit is used to store "am I pointing to the 1st constructor or the 2nd constructor?". you just need to look at that bit.
15:20:34 <jmcarthur> or is the information of whether to treat it as a pointer in the info table?
15:20:42 <applicative> pooya72: there's some well informed anti-Haskell pro-ML trolling by my neighbor here;   http://existentialtype.wordpress.com/  he's a partisan so its unfair  but well informed
15:20:48 <jmcarthur> but pointers could still have some other information packed in, i guess
15:20:54 <monochrom> when you really want to deference that pointer (rare), you set-zero the lower bits, then deference
15:21:07 <Paprikachu> lol :D
15:21:15 <otters> lines 39/40 are wrong
15:21:16 <mparodi> @hoogle [a] -> a
15:21:16 <lambdabot> Prelude head :: [a] -> a
15:21:16 <lambdabot> Data.List head :: [a] -> a
15:21:16 <lambdabot> Prelude last :: [a] -> a
15:21:19 <tgeeky> ski: so: signum, abs, and negate all have the same result? :O
15:21:20 <pooya72> applicative: thanks! I was just curious what other languages complement haskell.
15:21:32 <mparodi> is there a max :: [a] -> a?
15:21:37 <jmcarthur> mparodi: maximum
15:21:39 <ski> tgeeky : appears so
15:21:42 <tgeeky> ski: clearly this means we should remove those three from Num!
15:21:54 <mparodi> why lambdabot didn't show me it?
15:21:59 <ski> tgeeky : we want `abs 0 = 0', surely
15:22:02 <mparodi> @t maximum
15:22:02 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
15:22:09 <monochrom> Int takes up like 2 machine words so that user gets 32/64 bits and compiler still plays address tricks
15:22:13 <ski> @hoogle [a] -> a
15:22:13 <lambdabot> Prelude head :: [a] -> a
15:22:13 <lambdabot> Data.List head :: [a] -> a
15:22:13 <lambdabot> Prelude last :: [a] -> a
15:22:14 <jmcarthur> mparodi: lambdabot showed you three valid functions for your type signature
15:22:15 <ski> @hoogle+
15:22:15 <lambdabot> Data.List last :: [a] -> a
15:22:15 <lambdabot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
15:22:15 <lambdabot> Data.List foldl1 :: (a -> a -> a) -> [a] -> a
15:22:17 <ski> @hoogle+
15:22:17 <lambdabot> Prelude foldr1 :: (a -> a -> a) -> [a] -> a
15:22:18 <applicative> pooya72: those posts produced a temptest in a teapot a while back.  the great lennart a gave an excellent response to the one about evaluation order  http://augustss.blogspot.com/2011/05/more-points-for-lazy-evaluation-in.html
15:22:19 <lambdabot> Data.List foldr1 :: (a -> a -> a) -> [a] -> a
15:22:21 <lambdabot> Data.List foldl1' :: (a -> a -> a) -> [a] -> a
15:22:23 <ski> &c.
15:22:36 <jmcarthur> @hoogle Ord a => [a] -> a
15:22:36 <lambdabot> Prelude maximum :: Ord a => [a] -> a
15:22:36 <lambdabot> Data.List maximum :: Ord a => [a] -> a
15:22:36 <lambdabot> Prelude minimum :: Ord a => [a] -> a
15:22:53 <otters> hoogle plus
15:22:59 <mparodi> ah, didn't know, thanks
15:23:03 <jmcarthur> @karma @hoogle
15:23:03 <lambdabot>  @hoogle has a karma of 0
15:23:13 <jmcarthur> oh that would be ++
15:23:13 <ski> @karma hoogle
15:23:14 <lambdabot> hoogle has a karma of 0
15:23:22 <tgeeky> @hoogle++
15:23:22 <lambdabot> Data.List minimum :: Ord a => [a] -> a
15:23:22 <lambdabot> Prelude head :: [a] -> a
15:23:22 <lambdabot> Data.List head :: [a] -> a
15:23:28 <tgeeky> @karma @hoogle
15:23:28 <lambdabot>  @hoogle has a karma of 0
15:23:36 <jmcarthur> worth a shot
15:23:41 <ski> @karma+ @hoogle+
15:23:42 <lambdabot>  @hoogle+'s karma raised to 1.
15:23:55 <tgeeky> waiiiiiiiiit a damn minute
15:24:00 <tgeeky> @karma+ tgeeky
15:24:01 <lambdabot> You can't change your own karma, silly.
15:24:04 <applicative> pooya72: several of those posts are priceless wisdom whatever your language e.g. http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
15:24:21 <jmcarthur> lol... a `mempty` b  -- woops
15:24:28 <Paprikachu> so what does the syntax "instance Num Bool where ..." do in words?
15:24:29 <mparodi> @karma haskell
15:24:29 <lambdabot> haskell has a karma of 3
15:24:38 <jmcarthur> :t \a b -> a `mempty` b
15:24:40 <lambdabot> forall t t1 t2. (Monoid (t -> t1 -> t2)) => t -> t1 -> t2
15:24:42 <ski> preflex: xseen augustss
15:24:42 <preflex>  augustss was last seen on freenode/#haskell 200 days, 21 hours, 52 minutes and 34 seconds ago, saying: > div (-1) 2
15:24:44 <ski> preflex: xseen lennart
15:24:45 <preflex>  Sorry, I haven't seen lennart
15:24:53 <mparodi> anyway, thanks
15:25:08 <Paprikachu> preflex: xseen Paprikachu
15:25:08 <preflex>  Paprikachu was last seen on freenode/#haskell 39 seconds ago, saying: so what does the syntax "instance Num Bool where ..." do in words?
15:25:22 <tgeeky> preflex: xseen Paprikachu
15:25:23 <preflex>  Paprikachu was last seen on freenode/#haskell 14 seconds ago, saying: preflex: xseen Paprikachu
15:25:26 <tgeeky> ohhhhh
15:26:06 <hpaste> fmap pasted “ambiguous types” at http://hpaste.org/69117
15:26:23 <Paprikachu> ski, would you mind to answer my question? :)
15:26:41 <fmap> is it possible to write type signature which typechecks to this stuff
15:26:42 <fmap> ?
15:27:36 <ski> Paprikachu : well, it declares the type `Bool' as being an instance of the type class `Num' (very *roughly* comparable to "implementing an interface / abstract base class"), giving implementations of the methods in that type class
15:28:01 <ski> it might be simpler to consider a simpler type class first, like Eq
15:28:03 <ski> @src Eq
15:28:04 <lambdabot> class  Eq a  where
15:28:04 <lambdabot>     (==), (/=)   :: a -> a -> Bool
15:28:21 <applicative> fmap: if i write s in amodule I get s :: (RandomGen t1, Random t) => t1 -> t
15:28:24 <ski> a type class is roughly a set of types
15:28:38 <ski> in this case, `Eq' corresponds to the set of types which implement equality
15:28:43 <monochrom> @type random
15:28:44 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
15:29:22 <ski> for each type `Foo' in `Eq', there must be implementations of `(==) :: Foo -> Foo -> Bool' and `(/=) :: Foo -> Foo -> Bool'
15:29:48 <ski> often, when we declare new types, we can *derive* the implementation of `Eq'
15:30:03 <ski> but sometimes we need to or want to implement it explicitly
15:30:12 <monochrom> eh? "let s g = u1 where (u1, g') = random g" works fine in ghc 7.0.3
15:30:40 <ski> e.g. if you have two sets, internally implemented as trees, then you don't want structural equality, you want to check that the two sets contain the same elements
15:31:01 <monochrom> (at the ghci prompt, too)
15:31:03 <fmap> applicative: this doesn't work for me with no MR
15:31:04 <ski> Paprikachu : following, so far ?
15:31:16 <monochrom> I have NoMR, too
15:31:21 <Peaker> it doesn't type-check in ghci here in 7.4.1
15:31:26 <Paprikachu> yes
15:31:31 <Peaker> (it does type-check in ghc.. seems like a ghc 7.4.1 bug?)
15:31:40 <Peaker> the MR is irrelevant here, I think
15:31:42 <applicative> "let should not be generalized"
15:31:43 <ski> so, let's declare a simple enum-like type
15:31:54 <ski>   data PrimaryColor = Red | Green | Blue
15:32:08 <ski> we can derive the class `Eq' for this, like
15:32:27 <ski>   data PrimaryColor = Red | Green | Blue
15:32:27 <ski>                       deriving (Eq,Show)
15:32:31 <pooya72> applicative: I'm a philosophy major, and his comment about booleans is on track. http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/ I'll have to read through it fully later, but thanks!
15:32:38 <ski> (deriving `Show' is also good, so that we can print these values)
15:32:51 <monochrom> oh, then, try this: let { s :: (RandomGen t1, Random t) => t1 -> t; s g = u1 where (u1,g') = random g }
15:32:53 <ski> but assume we want to implement `Eq' explicitly, so we just assume
15:32:54 <ski>   data PrimaryColor = Red | Green | Blue
15:32:57 <ski>                       deriving Show
15:32:59 <applicative> pooya72: philosophy students make  the best haskellers
15:33:12 <ski> then we can make `PrimaryColor' an instance of `Eq' like
15:33:14 <tgeeky> ski: that's just Bool for 3-landers
15:33:21 <ski>   instance Eq PrimaryColor
15:33:24 <ski>     where
15:33:27 <tgeeky> btw, check out: LOL memory (seriously!) http://en.wikipedia.org/wiki/Core_rope_memory
15:33:43 <ski>     Red   == Red   = True
15:33:49 <ski>     Green == Green =  True
15:33:57 <ski>     Blue  == Blue  = True
15:34:04 <ski>     _     == _     = False
15:34:14 <DrSyzygy> isn't that just the result of ... deriving Eq ?
15:34:21 <applicative> pooya check out pandoc, a philosophy proessor wrote it ....
15:34:28 <ski> and in fact we don't need to define `(/=)', since there's a *default* implementation of it, namely
15:34:39 <ski>   a0 /= a1 = not (a0 == a1)
15:34:44 <ski> DrSyzygy : sure
15:35:14 <ski> Paprikachu : after we've done this, we can use `(==)' and `(/=)' on values of type `PrimaryColor'
15:35:26 <ski> however, not only those, but also a hold of other functions
15:35:29 <ski> e.g.
15:35:41 <ski>   elem :: Eq a => a -> [a] -> Bool
15:35:52 <Eduard_Munteanu> applicative: heh, though to be fair, there are philosophy profs and philosophy profs
15:35:59 <otters> tgeeky: software *woven* into ROM
15:35:59 <ski> this means that `elem' takes two arguments, an `a', and a list of `a's, and returns a `Bool'
15:36:12 <Paprikachu> what's => again?
15:36:20 <Clint> constraint
15:36:21 <otters> class constraint
15:36:26 <otters> a is an instance of Eq
15:36:27 <ski> then `Eq a =>' here means that it only does this, *provided* that `a' is in the type-class `Eq' (i.e. has equality implemented)
15:36:55 <applicative> Eduard_Munteanu: theyre all the same
15:36:56 <ski> we say that the `elem' function is *overloaded* over all types having equality
15:37:48 <monochrom> threesome :: Eq a => a -> a -> a -> Bool; threesome x y z = x==y && y==z
15:38:05 <ski> Paprikachu : if you then use `(==)' or `elem' when you define a new function, that function will also be overloaded over every type with equality (unless something in the function fixes the type to a specific one)
15:38:37 <Paprikachu> threesome a b c = a 8===o b 8===o c
15:38:42 <Paprikachu> can you make this compile? :P
15:38:55 <monochrom> if you just have "threesome x y z = x==y && y==z", the type is inferred automatically, and you see that you get the "Eq a => ..."
15:38:59 <monochrom> in fact...
15:39:01 <ski> Paprikachu : also, note that you don't really need to write an explicit type signature like monochrom did here (though it's good documentation, and can help tracking down type errors faster) -- it would have inferred that `threesome' is overloaded anyway
15:39:05 <monochrom> @let threesome x y z = x==y && y==z
15:39:06 <lambdabot>  Defined.
15:39:09 <monochrom> @type threesome
15:39:10 <lambdabot> forall a. (Eq a) => a -> a -> a -> Bool
15:39:31 <ski> Paprikachu : you'd need to define `o' as something
15:39:33 <Paprikachu> how can i define custom operators?
15:39:40 <ski> like
15:39:45 <otters> (op) = ...
15:39:47 <Paprikachu> can i define 8===o an operator?
15:39:48 <ski>   x +/**- y = ...
15:39:50 <otters> (+++) = (++)
15:40:00 <otters> no you can't
15:40:02 <ski> Paprikachu : no, operators just contain symbolic characters
15:40:05 <otters> infix operators can only contain symbols
15:40:07 <otters> yeah
15:40:18 <ski> you can use non-symbolic identifiers as infix, though
15:40:30 <otters> but you have to surround them with backticks
15:40:31 <ski> > elem "B" ["a","B","c"]
15:40:32 <otters> which is ugly
15:40:33 <lambdabot>   True
15:40:40 <ski> > "B" `elem` ["a","B","c"]  -- the same thing
15:40:41 <lambdabot>   True
15:40:46 <Siod> i imagine library developers try not to use existing operators defined by other libraries
15:40:54 <Paprikachu> yeah i know infix function calls
15:40:57 <monochrom> as long as you satisfy lexical requirements, you can just go ahead make custom operators
15:40:59 <Siod> is there some central database of used operators?
15:41:01 <otters> > let (??) = elem in "B" ?? ["a", "B", "c"]
15:41:02 <lambdabot>   True
15:41:07 <Siod> like named stars
15:41:11 <Eduard_Munteanu> Siod: mm, hoogle?
15:41:13 <ski> Paprikachu : but you can't mix alphanumeric and symbolic chars in an identifier
15:41:20 <Paprikachu> :(
15:41:34 <monochrom> write like "x ^^^ y = ..." or "(^^^) x y = ...". then you can use ^^^
15:41:48 <ski> @type let o = 0; threesome x y z = x==y && y==z in threesome
15:41:50 <lambdabot> forall a. (Eq a) => a -> a -> a -> Bool
15:42:00 <Siod> what's an operator defined by some esoteric library
15:42:04 <ski> @type let o = 0; threesome a b c = a 8===o b 8===o c in threesome
15:42:05 <lambdabot> Not in scope: `==='
15:42:06 <lambdabot> Not in scope: `==='
15:42:09 <ski> oh, right
15:42:16 <ski> @type let o = 0; (===) = (/=); threesome a b c = a 8===o b 8===o c in threesome
15:42:17 <lambdabot>     No instance for (Num Bool)
15:42:17 <lambdabot>       arising from a use of `threesome' at <interactive>:1:64-72
15:42:17 <lambdabot>     Possible fix: add an instance declaration for (Num Bool)
15:42:34 <ski> hehe, it doesn't work, unless you add the `instance Num Bool' thing
15:42:48 <Paprikachu> :D
15:42:49 <mparodi> I have a list t :: [Tree], I want to find if in any of its trees there's an element e. can you do so with map in an efficient way (ie, not applying the same function to every tree)?
15:42:54 <Siod> hoogle didn't find the data.lens operators
15:43:25 <mparodi> ...; elems (Tree t) e = ??? $ map elems t e
15:43:45 <mparodi> it is not efficient anyway, map will apply elems to all the elements in the list t
15:43:48 <ski> Paprikachu : there's more type classes, of course, like `Ord' for things that can be compared for ordering, `Show' for things that can be converted to a string (representing Haskell code evaluating to the input), `Read' for things which can be converted in the other direction, and many others
15:44:27 <Paprikachu> type classes are probably what c++ concepts should have been
15:44:45 <monochrom> absolutely
15:44:56 <Siod> anyone using haskell-mode: how do I show more than 'Compilation failed.'
15:45:02 <ski> mparodi : something like `any (elemTree e) t' ?
15:45:07 <monochrom> c++ concept actually has a less-learning-curve syntax
15:45:35 <solidus-river> what are some good resources for looking up functional reactive programming?
15:45:46 <mparodi> let me check, I've never used any
15:45:48 <ski> maybe conal's blog ?
15:45:56 <ski> @where conal
15:45:57 <lambdabot> http://conal.net
15:46:06 <Siod> i'm reading http://www.haskell.org/haskellwiki/FRP_explanation_using_reactive-banana
15:46:13 <ski> > any isUpper "fooBar"
15:46:14 <lambdabot>   True
15:46:16 <Siod> to get reactive-banana working with my wxhaskell project
15:46:17 <ski> > any isUpper "foobar"
15:46:18 <lambdabot>   False
15:46:41 <mparodi> does it check if 'a' and 'r' are upper in `any isUpper "fooBar"'?
15:46:58 <monochrom> let me show you...
15:47:02 <Siod> is anyone here using haskell-mode?
15:47:07 <ski> @where hoogle
15:47:07 <lambdabot> http://haskell.org/hoogle
15:47:12 <monochrom> > any even [0, undefined, undefined]
15:47:13 <lambdabot>   True
15:47:15 <ski> Siod : tried that ^ as well ?
15:47:23 <jmcarthur> Siod: i always either use ghc-mod or just ghci in the shell
15:47:25 <monochrom> it stops early
15:47:26 <mparodi> oh, good
15:47:32 <Siod> ski: ?
15:47:35 <ski> > any even (1 : [0,2 ..])
15:47:36 <lambdabot>   True
15:47:52 <Siod> haskell-mode doesn't show compile errors?
15:47:57 <ski> Siod : <http://haskell.org/hoogle>
15:48:04 <monochrom> so yeah, if you do "any p (map f blah)" it is not so bad
15:48:04 <jmcarthur> ski: maybe you misinterpreted the question?
15:48:06 <mparodi> haskell++
15:48:13 <solidus-river> so whats everyone talking about when they talk about ocaml's mutability?
15:48:16 <dmwit> any (p . f) blah is better
15:48:17 <ski> <Siod> hoogle didn't find the data.lens operators
15:48:26 <solidus-river> as adverse to haskells parallellism
15:48:38 <Siod> ski: i don't see them there
15:48:43 <jmcarthur> solidus-river: in ocaml you can mutate things in place. in haskell, you can't (without the IO monad)
15:48:47 <dmwit> solidus-river: OCaml has mutable variables.
15:48:49 <Siod> ski: do you know how to show compile errors in haskell-mode?
15:48:56 <dmwit> Not sure what else to say about that.
15:48:59 <solidus-river> but what is the definitoin of a mutable variable?
15:49:22 <ski> Siod : hm, <http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=Data.Lens> seems to have them
15:49:34 <jmcarthur> solidus-river: the ability to change the value of something and observe that change in a different part of you code
15:49:40 <monochrom> mutable variable means "IORef" or "STRef" or "TVar" or "MVar" in haskell; means "ref" in ocaml.
15:49:52 <solidus-river> ah, so you can in a way listen for a change on a variable
15:49:53 <jmcarthur> monochrom: or a mutable field in ocaml
15:49:55 <ski> (monochrom : or a `mutable' record field)
15:49:59 <jmcarthur> which is how ref is defined
15:50:09 <dmwit> solidus-river: Listening is a much more exciting property to allow.
15:50:16 <monochrom> I am rusty in ocaml, indeed
15:50:21 <dmwit> solidus-river: Just plain old writing is already enough to be mutable.
15:50:52 <solidus-river> so when a mutable variable changes it writes itself to all other instances of that variable?
15:51:00 <dmwit> what
15:51:09 <mparodi> nice, it works :)
15:51:18 <ski> `a -> b' in O'Caml is basically `Kleisli IO A B' in Haskell
15:51:20 <solidus-river> dmwit: i might be too many beers in for this discussion right now
15:51:28 <jmcarthur> solidus-river: do you know C?
15:51:32 <pooya72> applicative: haha, why you say that? It's funny cause I REALLY like haskell and I just started.. "philosophy students make  the best haskellers"
15:51:33 <solidus-river> jmcarthur: yes
15:51:42 <monochrom> you now see why I define "mutable" by actual program constructs. so you can empirically test behaviours rather than argue philosophically
15:51:43 <jmcarthur> solidus-river: in C you can change the value of a field in a struct
15:51:48 <jmcarthur> solidus-river: ocaml lets you do the same thing
15:51:58 <monochrom> observe reality > think
15:52:34 <solidus-river> is there any reason ocaml or haskell would be faster for a largely io driven program?
15:52:57 <Peaker> what event loop does ocaml use? or does ocaml use blocking IO?
15:53:03 <jmcarthur> solidus-river: ghc's runtime is insanely fast for I/O
15:53:09 <Ralith> jmcarthur: why's that?
15:53:13 <jmcarthur> Peaker: it doesn't have an event loop built in
15:53:13 <applicative> pooya72: I mentioned http://johnmacfarlane.net/tools.html the first is among the greatest haskell programs
15:53:39 <ski> monochrom : is C++ concepts something else than just implicitly requiring properties of your template arguments in the body of the template ?
15:53:46 <jmcarthur> Ralith: it has very lightweight green threads that run on multiple cores and use epoll behind the scenes
15:53:56 <Ralith> o
15:53:59 <Ralith> is there a writeup on that anywhere?
15:54:06 <jmcarthur> Peaker: libraries like LWT and Async are meant to fill in that gap
15:54:19 <jmcarthur> Peaker: they are basically like twisted or something. not really like the IO monad :(
15:54:24 <parcs`> what is the "sequence point" during which an asynchronous exception may be thrown?
15:54:37 <Paprikachu> [00:51:06]	<ski>	monochrom : is C++ concepts something else than just implicitly requiring properties of your template arguments in the body of the template ?
15:54:40 <monochrom> yes it is something else than implicitly. it is pretty explicit. but I no longer recall the syntax.
15:54:41 * hackagebot cairo 0.12.3.1 - Binding to the Cairo library.  http://hackage.haskell.org/package/cairo-0.12.3.1 (DanielWagner)
15:54:50 <Paprikachu> mono was faster.
15:54:56 <jmcarthur> Ralith: there are a few but i can't think of any off the top of my head
15:55:04 <pooya72> applicative: I didn't know he was haskeller! haha!
15:55:30 <Paprikachu> there's also ConceptClang which can compile c++ code with concepts
15:55:49 <applicative> think there a number of languages represented on that page...
15:55:54 <Paprikachu> ConceptGCC has the old version of concepts only
15:56:06 <henry__> hi
15:56:17 <applicative> hi henry__
15:56:33 <henry__> real
15:56:42 <applicative> henry__: what are you actual and expected types?
15:56:51 <pooya72> applicative: And I didn't know he wrote pandoc! I love that program! markup conversion is part of the reason I even decided to learn programming...
15:57:10 <Peaker> jmcarthur, that sucks.. Haskell sounds much nicer then :)
15:57:21 <applicative> well so maybe haskell not sml in your case, pooya72
15:57:40 <Peaker> solidus-river, given Haskell uses event-driven-by-default with a fast event engine (based on epoll), it is likely Haskell will outperform ocaml
15:57:52 <Peaker> (unless the ocaml code is written in explicit CPS style, apparently)
15:57:57 <Ralith> Peaker: you measure language quality by the amount of stuff that's hardcoded in the compiler?
15:58:06 <jmcarthur> no, i think it would still outperform it
15:58:07 <Peaker> jmcarthur, basically if they had do-notation they could just have a Cont monad for the async callbacks?
15:58:19 <Ralith> I'd think that what matters more is the ability to do that sort of thing in a lib.
15:58:35 <jmcarthur> Peaker: there are already monad-like operators
15:58:38 <jmcarthur> Peaker: just no sugar
15:58:57 <Peaker> Ralith, It doesn't really matter where its done, IMO.  There just needs to be a good framework that allows writing high-level threaded code that is high-performance
15:59:00 <jmcarthur> Peaker: (but a big secret is that they aren't really monads because they violate the laws)
15:59:07 <Peaker> jmcarthur, why do they need to do that?
15:59:24 <jmcarthur> Peaker: there is no need, but it's a convenient notation
15:59:40 <Peaker> Ralith, if Haskell didn't have it, it would be easy to write a Cont monad that handles callbacks for you.
15:59:43 * hackagebot glib 0.12.3.1 - Binding to the GLIB library for Gtk2Hs.  http://hackage.haskell.org/package/glib-0.12.3.1 (DanielWagner)
15:59:45 * hackagebot gstreamer 0.12.1.1 - Binding to the GStreamer open source multimedia framework.  http://hackage.haskell.org/package/gstreamer-0.12.1.1 (DanielWagner)
15:59:47 * hackagebot gtk2hs-buildtools 0.12.3.1 - Tools to build the Gtk2Hs suite of User Interface libraries.  http://hackage.haskell.org/package/gtk2hs-buildtools-0.12.3.1 (DanielWagner)
15:59:48 <pooya72> applicative: funny that he built a lot of things I built in ruby (although mine was to much crappier degree). I'm referring gitit. I built something similar on ruby with sinatra and gitr
15:59:49 * hackagebot gtksourceview2 0.12.3.1 - Binding to the GtkSourceView library.  http://hackage.haskell.org/package/gtksourceview2-0.12.3.1 (DanielWagner)
15:59:51 * hackagebot svgcairo 0.12.1.1 - Binding to the libsvg-cairo library.  http://hackage.haskell.org/package/svgcairo-0.12.1.1 (DanielWagner)
15:59:53 <Peaker> jmcarthur, I mean, what do they gain from breaking the monad laws?
15:59:59 <jmcarthur> Peaker: foo; >>= fun x ->; bar x    (* replacing semicolons with new lines *)
16:00:02 <jmcarthur> oh
16:00:13 <jmcarthur> Peaker: i think it's because they don't realize that it's horrible :\
16:00:20 <monochrom> haha
16:00:22 <jmcarthur> Peaker: but no there is a better excuse than that
16:00:38 <Peaker> jmcarthur, what laws do they break? You can link me to RTFM if you want :)
16:00:42 <pooya72> applicative: thanks... this site has been really useful!
16:00:45 <monochrom> perhaps they want a particular evaluation order? efficiency?
16:00:47 <jmcarthur> Peaker: a choice that was made is that bind always denotes a context switch
16:01:06 <jmcarthur> Peaker: the idea being that you can always be sure that between two binds you have exclusive access to state
16:01:18 <applicative> pooya72: sure  have you seen the standard tutorials if you want to make a go of Haskell ?
16:01:46 <Peaker> jmcarthur, I see
16:01:51 <jmcarthur> Peaker: also, there are some design choices that lead to the *need* for bind to be a context switch in order to prevent some code from running that you don't want to run :(
16:02:07 <monochrom> hrm, I appreciate no-context-switch between two binds, but it doesn't sound like breaking a monad law
16:02:09 <pooya72> applicative: I'm reading through real world haskell. I like it so far. Learn you a haskell was too much code upfront, but I find it good read for refreshing.
16:02:09 <Peaker> well, that's within the scope of Cont's bind
16:02:10 <jmcarthur> Peaker: so basically, return x >>= f is not the same as f x
16:02:15 <jmcarthur> monochrom: ^^
16:02:28 <Peaker> or rather, not bind, but a different bind-like function
16:02:32 <monochrom> oh, yeah, that, haha, well, I approve of it then
16:02:41 <applicative> pooya72: oh, okay those are the going texts, maybe typeclassopedia at some point later
16:03:17 <pooya72> applicative: ok, bookmarked it...
16:03:24 <jmcarthur> it does mess with the ability to use transformers and such on it
16:03:44 <jmcarthur> like if i want to transform it to be a reader, i can't use ask without context switching
16:03:48 <applicative> pooya72: anyway, people here can give you advice as difficulties arise
16:04:00 <monochrom> but you can fudge the definition of "same" within reason, and then "return x >>= f" will be the "same" as "f x" again
16:04:09 <pooya72> applicative: yeah thanks. Sometimes I get stuck cause I'm learning alone...
16:04:33 <jmcarthur> monochrom: if i use return in the middle of a larger expression then that means i must be context switching, which is pretty bad if i wasn't expecting that
16:04:33 <Siod> is template haskell as powerful as lisp macros?
16:04:47 <applicative> have you installed the haskell platform pooya72 ?
16:04:50 <pooya72> Is there anything like http://clojure.org/cheatsheet for haskell? I really like how they have multiple examples.
16:04:53 * hackagebot webkit 0.12.4 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkit-0.12.4 (DanielWagner)
16:05:06 <pooya72> applicative: yeah through homebrew on mac
16:05:37 <jmcarthur> i think the crazier thing about lwt and async is that the *creation* of a deferred causes its side effects to happen, and the results are always shared even if you bind it multiple times
16:05:40 <applicative> ok  http://hackage.haskell.org/package/CheatSheet  cabal install cheatsheet :)
16:05:49 <monochrom> well that's why you relax the meaning of "same". you just don't expect exact same behaviour. you allow some nondeterminism.
16:05:59 <applicative> why it's hackaged, I dont know
16:06:25 <applicative> ah here http://cheatsheet.codeslower.com/CheatSheet.pdf there are other like things
16:07:01 <Peaker> jmcarthur, impurity adds arbitrary points for side-effects to happen it makes for silly choices
16:07:04 <jmcarthur> monochrom: there are simple examples where applying that monad law to remove an unnecessary bind deterministically gives you the wrong result
16:07:24 <jmcarthur> s/the wrong/a different/
16:07:41 <jmcarthur> Peaker: yeah :(
16:07:51 <monochrom> well yes, sure, you expect that much in front of concurrency, monad or not.
16:08:04 <pooya72> applicative: thanks, so i did cabal install cheatsheet. what do i do with it now?
16:08:36 <monochrom> look for some file inside $HOME/.cabal/share/CheatSheet maybe
16:08:59 <Peaker> monochrom, well, if it were considered raw non-determinism it would be ok, but as I understand it, it seems that the official solution is adding binds just for their side effect
16:09:09 <Peaker> (deterministically)
16:09:39 <jmcarthur> that's right
16:09:42 * hackagebot Elm 0.1.1.7 - The Elm compiler and server.  http://hackage.haskell.org/package/Elm-0.1.1.7 (EvanCzaplicki)
16:09:48 <applicative> pooya72: i linkedthe pdf too. i'm studying this mad hackaging of it now
16:09:55 <jmcarthur> the design is meant to eliminate as much nondeterminism as possible
16:09:56 <ski> Paprikachu,monochrom : ok
16:10:13 <jmcarthur> i don't really agree with the tradeoffs that were made, but it is what it is
16:10:48 <ski> jmcarthur : yeah, iirc, Lwt lacked some discipline in following the monad laws
16:10:59 <jmcarthur> ski: lwt and async both
16:11:08 * ski doesn't know about `async'
16:11:11 <applicative> hah, pooya72 if you now do cheatsheet on the command line it will  tell you.
16:11:21 <jmcarthur> ski: async is jane street's alternative to lwt
16:11:27 <ski> i see
16:11:40 <applicative> pooya72: it occurs, ~/.cabal/bin should be in your $PATH variable
16:12:01 <Peaker> jmcarthur, Twisted is like async too: instead of (a -> IO ()) -> IO ()    Cont-like functions, they have sort of:   a -> IO (IO () -> IO ())  functions so the effect happens first, and then you might register a callback/errback. If you don't, errors can be swallowed/ignored
16:12:24 <jmcarthur> Peaker: that seems about right
16:12:27 <Peaker> jmcarthur, and then Twisted uses GC finalizers to try and catch these generated (IO () -> IO ()) if they had no errback registered and had an error
16:12:33 <pooya72> applicative: ok so it tells me were the pdf and literal file are...
16:12:35 <Peaker> to debug dump it (bah)
16:12:44 <parcs`> do async exceptions get raised between (>>=)s?
16:12:44 <jmcarthur> Peaker: async deferreds are just ivars with limitations to make them covariant
16:12:53 <applicative> pooya72: i should have linked the pdf first, but came upon the hackage bit
16:13:08 <pooya72> applicative: no this is better
16:13:15 <jmcarthur> parcs`: in async there are special "monitors" for handling exceptions. my understanding is that this was an improvement over however lwt does it
16:13:19 <applicative> you can run the lhs file through pandoc -r markdown+lhs -w whatever
16:13:37 <applicative> wait i'm not sure about that
16:14:14 <jmcarthur> parcs`: the gist is that jobs are associated with monitors and bind creates new jobs associated with the same monitor
16:14:23 <applicative> no,  lhs is too texy for that
16:14:34 <jmcarthur> parcs`: and jobs are the indivisible units of code executed by the scheduler
16:15:20 <pooya72> applicative: does it do anything interactive? it looks like LaTeX source code.
16:15:56 <applicative> it is, the hackaging is very silly, I wish I hadn't brought it to your attention given http://cheatsheet.codeslower.com/CheatSheet.pdf
16:16:57 <dmwit> pooya72: You should have CheatSheet.pdf in .cabal/share or similar.
16:17:11 <pooya72> dmwit: yeah I got it thanks
16:17:17 <dmwit> Oh, okay.
16:17:32 <ski> jmcarthur : re "the *creation* of a deferred causes its side effects to happen" -- hm, maybe there should be a  delay : (unit -> 'a Lwt.t) -> 'a Lwt.t  ?
16:17:41 <ski> (or am i misunderstanding what you meant ?)
16:17:44 <pooya72> applicative: dmwit: It's still nothing like http://clojure.org/cheatsheet with the amount of examples though...
16:17:47 <applicative> pooya72: yeah the program is almost as minimal as can-i-have-a-pony
16:18:02 <pooya72> applicative: hey at least he tried! ;)
16:18:04 <applicative> which i sometimes use to test a new ghc or cabal
16:18:08 <jmcarthur> ski: there is such a thing, but it doesn't address the thing i don't like about it
16:19:02 <applicative> or rather the 'pony' package, which builds the executable can-i-have-a-pony ...
16:19:04 <ski> jmcarthur : you mean that if you bind a delayed action twice, it will perform the side-effects inside `delay' once ?
16:19:28 <jmcarthur> ski: basically if i have something like    after : Time.Span.t -> unit Deferred.t   and i apply it to some span, then if i bind the resulting deferred multiple times then i'm only registering multiple callbacks to the same event, not arranging for multiple delays
16:19:32 <jmcarthur> right
16:19:53 <ski> ok, that's strange, yes
16:20:05 <jmcarthur> so i can't have something like    afterTenSeconds :: unit Deferred.t
16:20:17 <applicative> notice that the hello program needed at least two bug fixes http://hackage.haskell.org/package/hello
16:20:56 <pooya72> haha
16:20:58 <ski> jmcarthur : given something like `delay', but which executed every time the action is bound, would help, i think
16:21:12 <applicative> but pony, none at all.  http://hackage.haskell.org/package/pony
16:21:14 <jmcarthur> yeah, but that would be a major departure from how it currently works
16:21:28 <jmcarthur> ski: the underlying representation is just an ivar
16:21:29 <applicative> the authors are both master haskellers....
16:21:34 <ski> jmcarthur : hm, iirc in Concurrent ML, there's something like that
16:22:06 <jmcarthur> ski: an ivar is either empty or filled, of course. likewise, a deferred is either undetermined or determined
16:22:11 <ski> (but maybe i'm comparing apples and oranges -- i know neither Lwt nor CML well)
16:23:08 <jmcarthur> all i'm getting at is that in order to support something like that the semantics would have to change entirely, since it would also imply that you can create other deferreds with similar behavior
16:23:34 <ski> hm, i think i see
16:24:02 <ski> (or you could maybe wrap deferred stuff in a new monad, which indirects this as you want)
16:24:14 <applicative> pooya72: I see what you mean, the clojure cheatsheet has links for each standard function to some characteristic use
16:24:23 <applicative> pooya72: this does seem like a sensible idea
16:24:39 <jmcarthur> ski: yes that is also possible. unfortunately, ocaml is not as good at eliminating layers of abstraction as ghc is
16:24:50 <pooya72> applicative: yeah, maybe it's time to build one ;)
16:24:52 <jmcarthur> or, to be more precise, it doesn't remove any layers of abstraction
16:25:12 <dmwit> "add optional threading support"
16:25:40 <dmwit> an important feature for hello-world programs
16:25:52 <applicative> pooya72: the equivalent is the haddock -ed documentation, but people frequently complain that  it is fairly minimal
16:26:09 <pooya72> applicative: I'm going through this list, and each one I read I'm like "man that's a good idea!" http://johnmacfarlane.net/tools.html
16:28:09 <ski> jmcarthur : *nod*
16:28:39 <pooya72> applicative: why is pandoc so slow though? http://jgm.github.com/lunamark/ I thought haskell would be pretty comparable to C. I remember pandoc being slow. Kind of annoying.
16:28:56 <jmcarthur> i never thought of pandoc as slow
16:28:56 <zzo38> I think the   Free ((->) Bool)   monad could be used for a few things, including Huffman coding, and random values generation from bitstream
16:29:06 <ski> jmcarthur : even though getting guarantees about removal of layered abstractions, i think it's nice that (presumably partially) due to the use of monad transformers, GHC often does this
16:29:15 <zzo38> pooya72: Did you try using optimization? If you don't, then Haskell will be slower than C.
16:29:59 <pooya72> zzo38: well I'm just going by the statics the author of pandoc put in the benchmarks. http://jgm.github.com/lunamark/ he's written the same type of program in lua and C.
16:29:59 <jmcarthur> pooya72: i imagine pandoc is slow for a couple reasons. it's probably not superoptimized, and it does some pretty complicated stuff
16:30:12 <jmcarthur> oh i didn't know he did that
16:30:21 <Peaker> jmcarthur, OCaml's reverse type application syntax is also weird :)
16:30:58 <pooya72> jmcarthur: yeah, pandoc does do a lot more. but does that affect it's performance on straight markdown to html?
16:31:03 <Peaker> (given values are applied the same way)
16:31:30 <jmcarthur> pooya72: it probably doesn't. i don't really know the reason it's slower. i still stand by my claim that it's probably just not very optimized
16:31:37 <jmcarthur> s/claim/guess/
16:31:46 <jmcarthur> Peaker: yeah
16:31:55 <jmcarthur> Peaker: values are not applied that way
16:32:19 <dmwit> Maybe they should be.
16:32:30 <dmwit> At least function composition would be in a sensible order, then.
16:33:01 <dmwit> At CT reading group one week we tried writing function application backwards.
16:33:04 <dmwit> It's hard.
16:33:12 <applicative> pooya72: those arent the same kind of program
16:33:24 <zzo38> Does Pandoc support DVI, MediaWiki, ESC/P, etc?
16:33:49 <zzo38> Does it accept RFC format?
16:34:13 <applicative> Input formats:  native, json, markdown, markdown+lhs, rst, rst+lhs, docbook,                 textile, html, latex, latex+lhs
16:34:14 <ski> Peaker : all the MLs are like that (well, apart from Smerdyakov's Ur)
16:34:31 <applicative> Output formats: native, json, html, html5, html+lhs, html5+lhs, s5, slidy,                 dzslides, docbook, opendocument, latex, latex+lhs, beamer,                 beamer+lhs, context, texinfo, man, markdown, markdown+lhs,                 plain, rst, rst+lhs, mediawiki, textile, rtf, org, asciidoc,                 odt, docx, epub
16:35:02 <pooya72> applicative: that's crazy
16:35:22 <zzo38> Well, then it has MediaWiki for output, but not input. They could add MediaWiki format for input as well, and add DVI and Plain TeX and ESC/P for output.
16:35:32 <pooya72> applicative: so supporting multiple input - output formats and all the case selections is slowing it down?
16:35:43 <zzo38> They should also support manual page format for input.
16:36:44 <pooya72> zzo38: and .mobi for the kindle ;)
16:37:16 <ski> dmwit : i sometimes try writing function arrows the other way around
16:37:31 <ski> (as i think they did in the Catsters, at one point)
16:37:52 <applicative> there is a mediawiki parser but I think it isn't comp[lete or something
16:38:15 <rwbarton> like B <- A instead of A -> B?
16:38:17 <zzo38> pooya72: O, yes, that too. I don't use Kindle and don't recommend it, but if you want to use it then yes implement that too.
16:38:31 <ski> zzo38 : hm, `Free (Bool ->)' is perfectly balanced binary trees, yes ?
16:38:34 <ski> rwbarton : yep
16:38:59 <zzo38> ski: It is a binary tree with values at the endpoints.
16:39:17 <ski> zzo38 : hm, no, not perfectly balanced
16:39:32 <jmcarthur> ski: the algebra of programming has that convention of reversing the arrows
16:39:43 <jmcarthur> i like it in some ways
16:39:49 <ski> jmcarthur : *nod*, i recall it, now that you mention it
16:40:08 <dmwit> Huh, what's nice about reversing the function type arrow?
16:40:09 <ski> zzo38 : do you think `Free (Bool ->)' would have any advantages to an explicit binary tree ?
16:40:10 <applicative> i'm not sure plain TeX would make too much sense as an output format, unless there will a million prefatory macros, ie.something like latex
16:40:13 <zzo38> ski: Correct, it is not perfectly balanced.  Free (Bool ->)  can also be used to represent a Huffman coding, too, I suppose.
16:40:20 <newsham> do you think some day we'll have all our syntax flowing data from right to left?
16:40:48 <newsham> Int <- Int <- Int..     x = proc =<< (foo . bar . baz) <$> proc2    etc...
16:41:04 <ski> dmwit : you get : given `f :: A <- B' and `x :: B', then `f x :: A'
16:41:18 <zzo38> ski: I think it might if you want to make a program to take a random stream of bits to roll six sided dice uniformly
16:41:32 <jmcarthur> dmwit: if f : A <- B and g : B <- C then f . g : A <- C
16:41:33 <ski> dmwit : also, `uncurry ($) :: a <- (a <- b,b)'
16:41:35 <newsham> ?dice 1d6
16:41:35 <lambdabot> 1d6 => 6
16:41:37 <zzo38> The binary tree for such a thing would be infinite, although it could be done
16:41:42 <ski> and what jmcarthur said
16:41:53 <jmcarthur> dmwit: the Bs are nice and close to each other, in other words
16:42:12 <jmcarthur> (i stole that from the book)
16:42:12 <dmwit> I see.
16:42:19 <ski> zzo38 : but couldn't you use an infinite binary tree with the other representation as well ?
16:42:26 <mparodi> @hoogle  ( a -> b) -> Maybe a -> Maybe b
16:42:26 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
16:42:27 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
16:42:27 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
16:42:35 <applicative> pooya72: pandoc is faster than most markdown implementations I think; there is a preliminary attempt to modernize that haskell https://github.com/jgm/pandoc2  In  fact it takes no time at all compared to the pdflatex it calls
16:42:35 <ski> mparodi : `fmap',`liftM'
16:42:38 <zzo38> ski: Yes you can; they are equivalent.
16:42:54 <mparodi> @hoogle liftM
16:42:54 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
16:42:54 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
16:42:54 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
16:43:06 <mparodi> @def liftM
16:43:06 <lambdabot> Maybe you meant: bf do let
16:43:13 <ski> zzo38 : so, i wondered whether the functional representation had any advantages to the data-structural one
16:43:18 <pooya72> applicative: interesting!
16:43:18 <ski> @index liftM
16:43:19 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
16:43:19 <mparodi> how is the command to get a description?
16:43:35 <mparodi> @help
16:43:35 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:43:38 <evancz> I recently uploaded a package to Hackage. In the first version I uploaded (http://hackage.haskell.org/package/Elm-0.1.1.4), documentation was generated as expected. In the subsequent versions as I tried to get improved documentation posted, no documentation was generated at all. Does anyone know what I might be doing wrong?
16:43:41 <mparodi> @list
16:43:41 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
16:44:04 <zzo38> But using   Free ((->) Bool)  gives you the monad for free
16:44:10 <pooya72> applicative: so now I can connect with a senior philosopher and work on the same open source projects. two birds with one stone.
16:44:12 <ski> *nod*
16:44:19 <dmwit> evancz: You didn't wait long enough.
16:44:22 <danr> ski: interesting function arrow reversal
16:44:29 <dmwit> evancz: Documentation is generated once per day or so.
16:44:31 <mparodi> @help help
16:44:31 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:44:32 <evancz> No way!
16:44:37 <evancz> Haha, thank you guys :)
16:45:00 <ski> danr : for curried function, you have to learn to read the other way, though
16:45:07 <applicative> evancz: it just hasn't happened yet
16:45:16 <mparodi> actually I don't have liftM defined
16:45:16 <dmwit> evancz: Did you make three uploads to try to fix that? =P
16:45:24 <mparodi> <interactive>:1:1: Not in scope: `liftM'
16:45:34 <evancz> Lol, only one of them was to fix that issue.
16:45:35 <pooya72> applicative: but he hasn't made any commits in over 7 months..
16:45:38 <dmwit> Oh, okay. =)
16:45:48 <ski> danr : like `(>>=) :: m a <- (m a <- b) <- m b <= Monad m' or `map :: ([a] <- [b]) <- (a <- b)'
16:45:48 <Peaker> ski, Haskell innovated the type-application-like-value-application approach?
16:45:51 <Peaker> or Miranda?
16:45:54 <mparodi> @type fmap
16:45:55 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:45:59 <applicative> pooya72: i think it is being imported into the other, instead of beginning again
16:46:05 <danr> ski: I like how you read the return type first
16:46:20 <ski> Peaker : iirc, Miranda has it as well -- i can't tell whether it invented it, though
16:46:27 <mparodi> it doesn't have the same type, why f == Maybe?
16:46:28 <ski> danr : indeed :)
16:46:38 <danr> ski: (>>=) will create a "m a" if you give me something that creates "m a" from b, and given an "m b"
16:46:42 <evancz> On that note though, I often end up finding about compatibility errors after uploading. Is there any way to avoid this? I'd likely have only 2 or 3 releases if I knew a better way to do this.
16:46:43 <danr> quite cute
16:47:22 <danr> ski: makes me wonder where the function space arrow originates from
16:47:31 <ski> danr,jmcarthur : i believe that in a language with non-commutative product type, the `<-' is the right way to type functions which are applied like `f x'
16:47:50 <pooya72> applicative: i see. Is there any reason why he picked Yesod over Snap? https://github.com/jgm/gitit2
16:47:52 <ski> danr : well, `f : A ---> B' comes from Category Theory :)
16:47:53 <evancz> Was that clear? In other words, the only way I know to test that 'cabal install elm' is going to work is by actually uploading. That seems bad.
16:48:15 <danr> ski: but it's an older concept than that
16:48:15 <ski> danr : but there it isn't used for function space, only for morphism class
16:48:21 <ski> maybe
16:48:32 <applicative> it takes pandoc 1.7 seconds to turn a 200 book into latex
16:48:37 <ski> danr : afaiu, the notation `f : A ---> B' in math comes from CT, though
16:48:37 <applicative> 200 page
16:48:57 <danr> ski: I remember my set theory professor saying that function application ought to be written "x f" to make sense... but maybe you're right, it's the arrows that should be turned around ;)
16:49:26 <ski> danr : before that, people usually said something like "`f' is a `B'-valued function (of an `A' variable)"
16:49:27 <dmwit> evancz: You can just "cabal install" from a directory with a cabal package...
16:49:37 <danr> ski: that's a bit weird. it's not like CT had a great breakthrough over mathematics, right?
16:49:39 <dmwit> evancz: Likewise you can just "cabal haddock" to test that your documentation looks the way it ought to.
16:49:52 <danr> at least initially. frowned upon as abstract nonsens
16:49:54 <ski> e.g. "`f' is a real-valued function (of a complex variable)"
16:50:15 <danr> let's see what wikipedia says ;)
16:50:17 <dmwit> evancz: If you're paranoid, you can "cabal sdist", then untar the tarball it creates somewhere else and try cabal installing from there.
16:50:20 <zzo38> No, I think the way the functions are now is OK since they are the way they are done in mathematics.
16:50:23 <applicative> with --strict , i.e. no markdown syntax extension it takes 1.2 sec. to make a 200 page book into latex
16:50:28 <dmwit> evancz: (In case you're worried that some files will be missing from the tarball.)
16:50:30 <applicative> pooya72: ^^^
16:50:33 <ski> danr : i don't recall where, but my memory tells me i read that this notation in math comes from CT
16:50:35 <zzo38> I do think category theory and other mathematics is good and I like it
16:51:42 <dmwit> zzo38: The only reason that it's like it is in mathematics is historical.
16:51:48 <ski> danr : the problem with `x f' is that typically `x' is a larger expression than `f', and reading left-to-right, we prefer seeing a description of the function applied, instead of first jumping to an argument (that isn't directly connected to the expected result)
16:51:58 <Eduard_Munteanu> zzo38: then why aren't you in ##categorytheory? :P
16:52:00 <zzo38> dmwit: Yes.
16:52:06 <danr> ski: that's a good argument ;)
16:52:07 <dmwit> Likely if mathematicians were able to wipe out everybody's memories and reinstate a new memory in its place, function application would be reversed tomorrow.
16:52:07 <ski> danr : this holds both for applications of `f', and for definitions of it
16:52:08 <pooya72> applicative: so it's probably faster than the benchmark he put here http://jgm.github.com/lunamark/ but still not as fast as his others...
16:52:09 <evancz> dmwit: I think I should probably take the paranoid route as I often forget to include new libraries in my .cabal file.
16:52:15 <ninegrid> correct me if i'm wrong but didn't Gell-Man use CT to postulate the existance of quarks and color charge?
16:52:35 <zzo38> Depending on the programming language it might make more sense one way or the other.
16:52:42 <mparodi> > let bar = fmap (\x -> Char.ord x)
16:52:43 <lambdabot>   not an expression: `let bar = fmap (\x -> Char.ord x)'
16:52:45 <evancz> Sorry, 'new libraries' should be 'new modules'.
16:52:48 <mparodi> > fmap (\x -> Char.ord x)
16:52:49 <lambdabot>   Not in scope: `Char.ord'
16:52:53 <mparodi> > fmap (\x -> ord x)
16:52:53 <lambdabot>   Overlapping instances for GHC.Show.Show
16:52:53 <lambdabot>                              (f GHC...
16:52:57 <dmwit> evancz: I understood. =)
16:52:58 <evancz> In any case, thank you again for your help!
16:53:01 <mparodi> what on Earth?
16:53:05 <ski>   g(b_i) = f(b_i)
16:53:09 <ski>   g(0) = 0
16:53:09 <jmcarthur> i like left to right evaluation. it just so happens that with laziness, f x *is* left to right evaluation :)
16:53:18 <ski>   g(u + v) = g(u) + g(v)
16:53:20 <ski> e.g.
16:53:26 <zzo38> jmcarthur: Yes!
16:53:46 <hpc> ski: icwydt
16:53:50 <hpc> er
16:53:51 <hpc> jmcarthur
16:54:05 <jmcarthur> i would be more inclined toward "x f" in a strict language than in a lazy language
16:54:05 <ski> where for each `b', `b_i' is a basis vector, `f' maps each such element to a vector in another vector space
16:54:31 <pooya72> ok everyone I'm out. Thanks for your help applicative:
16:54:40 <ski> we want to get a function `g' which agrees with `f' on the basis vectors, and which is linear (and defined on the whole basic space)
16:54:46 <newsham> jmc: got some backwards func composition?
16:54:55 * nand` thinks arrow reversal would be less of a compromise than juxtapositional reversal
16:55:01 <zzo38> jmcarthur: Well, yes, that too; in Forth you put the commands afterward, but they have actions too, and they are written in the way they are performed.
16:55:21 <newsham> ?type (.)
16:55:22 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:55:22 <zzo38> nand`: I think such things as this should be done by macros instead.
16:55:33 <applicative> pooya72: yes be good
16:55:36 <danr> ski: cannot find any history about the notation, but it would be really cool if it is as you say about being a ct heritage
16:55:44 <newsham> ?hoogle (a -> b) -> (b -> c) -> (a -> c)
16:55:45 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
16:55:45 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
16:55:45 <lambdabot> Control.Parallel.Strategies (-|) :: (a -> b) -> Strategy b -> (b -> c) -> (a -> c)
16:55:53 <ski> @type (>>>)
16:55:54 <jmcarthur> newsham: not quite sure what you're asking, nor do i know which direction is "backwards" ;)
16:55:55 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
16:56:08 <ski> (iirc, `|>' or something like that in F#)
16:56:09 <newsham> jmc: flip (.)
16:56:16 <jmcarthur> :t (>>>)  -- newsham
16:56:17 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
16:56:42 <newsham> IIRC (>>>) has an irritating precedence
16:56:50 <newsham> but yah i should use it more often
16:56:57 <jmcarthur> i do terrible things by mixing (.) and (<<<)
16:57:03 <newsham> usually I go right to left with =<< and (.)
16:57:04 <nand`> does anybody else think the name for “Category” is confusing and misleading? I would have called it “Morphism” since the type itself doesn't represent an arbitrary category, it represents a morphism in the category Hask
16:57:06 <ninegrid> ski: isn't f#'s |> just haskell's $
16:57:14 <nand`> or rather
16:57:18 <zzo38> I will use <<< and >>> when I want their precedence
16:57:18 <jmcarthur> newsham: don't forget (<=<)!
16:57:19 <newsham> though I gues if I used >>> and >>= then I'd still have weirdness due to do notation <- direction
16:57:20 <nand`> a category with objects derived from Hask
16:57:22 <rwbarton> flip ($) i think
16:57:25 <dolio> x : A, y : B, f : B -> A -> C, x y f : C. So easy.
16:57:27 <ski> ninegrid : ok, so `flip ($)' -- i couldn't recall
16:57:35 <newsham> its a rare day when i use the fish operator
16:57:45 <coppro> <>< ?
16:57:45 <zzo38> newsham: Fish operator?
16:57:54 <newsham> <=< or >=>
16:57:58 <danr> ohh... it was a long time you heard about the fish operator
16:58:00 <mparodi> ah, I got it, fmap works not just with Maybe so I have to specify the type :)
16:58:02 <ninegrid> ski: then just <| in F#
16:58:14 <ski> mparodi : depends -- often you don't have to
16:58:16 <ski> ninegrid : ok
16:58:26 <zzo38> newsham: I find <=< and >=> useful sometimes, not that rarely
16:58:26 <jmcarthur> dolio: i admit it took me a bit too long to line up the types in f to the values in that expression
16:58:33 <mparodi> ski, here I have to: fmap (\x -> Char.ord x)
16:58:33 <newsham> cool.
16:58:39 <sipa> rf
16:58:55 <jmcarthur> presumably due to inexperience, but it also throws me off that x and y were in a different order than the parameters in the type of f
16:59:04 <ski> nand` : yes, it's a little bit weird, that way
16:59:07 <dolio> jmcarthur: The latter was my point.
16:59:08 <jmcarthur> which for some reason i expected not to be the case
16:59:19 <zzo38> But =<= and =>= are less useful.
16:59:20 <ski> mparodi : `fmap Char.ord' should also work
16:59:27 <jmcarthur> i see
16:59:30 <Rambo> is a newbie
16:59:42 <ski> hello Rambo
16:59:45 <mparodi> ski, same problem. you have to write the type
16:59:49 <dolio> Unless you want to start making 'x y f = y (x f)'
16:59:54 <ski> mparodi : why ?
16:59:54 <Eduard_Munteanu> zzo38: what are those?
16:59:54 <Rambo> hi ski
17:00:00 <mparodi> ski, ask ghci :P
17:00:00 <jmcarthur> newsham: i don't use <=< often with, say, IO, but i use it pretty often with other monads
17:00:05 <ski> dolio : obviously ?
17:00:10 <zzo38> Eduard_Munteanu: Cokleisli compositions
17:00:16 <mparodi> it says: Ambiguous type variable `f0' in the constraint: (Functor f0) arising from a use of `fmap'
17:00:20 <ski> dolio : i guess type application in the MLs doesn't do that ..
17:00:20 <jmcarthur> ski: note the reordering
17:00:27 <ski> oh
17:00:30 * ski missed that
17:00:34 <dolio> It doesn't reorder the arguments.
17:00:47 <applicative> Rambo what is your type error? :)
17:00:50 <Eduard_Munteanu> zzo38: oh. Though one could also use (<<<) to avoid memorizing all those things.
17:01:27 <mparodi> <mparodi> it says: Ambiguous type variable `f0' in the constraint: (Functor f0) arising from a use of `fmap' <- ski
17:02:01 <ski> dolio : i think `x y f' ought to be either `(x y) f' (as in type-application in the MLs), or `x (y f)' (consistent with your first comment)
17:02:25 <startling> what should I use for unit testing?
17:02:26 <zzo38> Eduard_Munteanu: You can have <<< and >>> and . for morphism composition if they are that category
17:02:33 <dolio> ski: Yes, but then if you have a parameter list x y z f, the type is in the opposite order.
17:02:52 <dolio> So you have to choose where the disconnect is.
17:02:55 <ski> Rambo : do you have any book/tutorial on Haskell to follow yet ?
17:02:59 <nand`> zzo38: “Cokleisli compositions” <- Why ‘Co’?
17:03:07 <ski> Rambo : maybe you have some question ? in that case, just go ahead and ask it
17:03:08 <jmcarthur> startling: for pure functions, quickcheck (i sometimes *also* use smallcheck)
17:03:08 <zzo38> nand`: For comonads
17:03:22 <startling> jmcarthur: thanks!
17:03:28 <Eduard_Munteanu> nand`: newtype Cokleisli w a b = Cokleisli (w a -> b)
17:03:29 <jmcarthur> startling: there is technically support for IO, but i've never used it
17:03:31 <nand`> zzo38: oh, I see; I got mixed up, thought you were talking about >=>
17:03:47 <ski> mparodi : i mean, in what context do your `fmap Char.ord' occur ?
17:03:56 <startling> jmcarthur, i'm not testing IO anyway, so it's fine.
17:03:57 <jmcarthur> startling: there are some testing frameworks for making it more convenient but i don't have enough knowledge to recommend one
17:04:07 <mparodi> Main> let bar = fmap Char.ord
17:04:10 <mparodi> ski, ^
17:04:15 <ski> mparodi : usually, the context determines which type is needed .. however, if you just enter it in GHCi, then there's (probably) no context
17:04:27 <dolio> ski: Unless A -> B -> C = B -> (A -> C). :)
17:04:31 <ski> mparodi : ok, try `:set -XNoMonomorphismRestriction'
17:04:40 <mparodi> O.o
17:04:46 <ski> dolio : yeah, but it appears perverse :)
17:04:55 <mparodi> bar :: Functor f => f Char -> f Int
17:04:58 <jmcarthur> startling: the thing i like about quickcheck is that it gives you a good spread of tests and has a lot of helper code. the thing i like about smallcheck is mainly that it's freaking fast
17:05:01 <mparodi> it ""works"" now
17:05:07 <ski> mparodi : *nod*, so you got the general version, now
17:05:18 <applicative> it works fine in my ghci without -XNoMo...
17:05:35 <ski> mparodi : if you really want to, you can say `let bar :: Maybe Char -> Maybe Int; bar = fmap Char.ord'
17:05:45 <ski> applicative : `.ghci' ?
17:05:55 <Eduard_Munteanu> Is that still on by default since Haskell2010?
17:05:55 <mparodi> yep, if I force the type it works
17:06:08 <startling> hmmm, quickcheck generates random tests? I'm testing a parser, so I don't think that will be the best
17:06:16 <nand`> :t fmap Char.ord `asAppliedTo` Nothing
17:06:17 <lambdabot> Maybe Char -> Maybe Int
17:06:27 <ski> mparodi : this is just the DMR biting, consider putting that `:set ...' into your `.ghci' file
17:06:31 <jmcarthur> startling: if you have a way to generate valid inputs then it's perfect
17:06:49 <jmcarthur> startling: and if you don't have a way to generate valid inputs then it's probably worth making such a generator anyway
17:06:49 <applicative> ski: youre right I thought I'd gotten rid of it
17:07:01 <startling> jmcarthur, but then i'm testing both the generator and the parser
17:07:03 <jmcarthur> startling: quickcheck can help with that somewhat
17:07:14 <jmcarthur> startling: the generator can be pretty stupid
17:07:24 <startling> jmcarthur, that's true
17:07:26 <mparodi> <nand`> :t fmap Char.ord `asAppliedTo` Nothing <-- interesting... why I don't have any asAppliedTo
17:07:28 <ski> (dolio : .. i assume you don't have a system with `A -> B -> C  =  B -> A -> C', here)
17:07:30 <mparodi> ?
17:07:35 <nand`> mparodi: it's only defined in lambdabot
17:07:36 <jmcarthur> startling: quickcheck is best when there are clear properties you can come up with
17:07:44 <applicative> mparodi: my .ghci file has the line:   :set -XNoMonomorphismRestriction
17:07:52 <jmcarthur> startling: if you only want to test some specific cases, there's hunit, but i've never used it
17:07:55 <mparodi> nand`, ah. ok, it would be interesting to have that in ghci u.u
17:08:02 <nand`> mparodi: define it yourself :P
17:08:04 <nand`> @src asAppliedTo
17:08:04 <lambdabot> Source not found. My brain just exploded
17:08:12 <nand`> oh no
17:08:16 <zzo38> I suppose you could define it like this:    asAppliedTo :: (x -> y) -> x -> x -> y; asAppliedTo = const;
17:08:22 <applicative> those are weak grounds for a brain exploding
17:08:23 <startling> jmcarthur, oh, hmm, interesting
17:08:46 <startling> jmcarthur, so instead of having a regression test use a specific case, i'd come up with a generalization of that case
17:08:46 <ski> dolio : "Yes, but then if you have a parameter list x y z f, the type is in the opposite order.","So you have to choose where the disconnect is." -- indeed. same with `f :: A <- B <- C; b :: B; c :: c' and `f c b'
17:08:47 <mparodi> <applicative> mparodi: my .ghci file has the line:   :set -XNoMonomorphismRestriction <-- I don't even have the file :P
17:08:53 <jmcarthur> startling: a stupid example of a typical quickcheck test is to check that some operation is commutative
17:08:53 <nand`> applicative: lambdabot must be mixing existentials with GADTs during its search for the source
17:08:56 <jmcarthur> startling: exactly
17:09:05 <ski> dolio : of course, `f :: A <- (B,C)' with `f (b,c)' is fine :)
17:09:06 <zzo38> mparodi: Then make such a file and then it will read it.
17:09:17 <startling> jmcarthur: that's odd, but it makes a lot of sense. thanks!
17:09:35 <mparodi> I'm not sure if it's really a good idea. I don't know what :set -X... means
17:09:37 <ski> dolio : the contravariance causes reversal of order in the tupling/currying
17:09:39 <jmcarthur> startling: well, you don't just generalize regression tests
17:09:44 <jmcarthur> startling: it's more like you define a spec
17:09:51 <zzo38> mparodi: It selects a language extension option
17:09:54 <startling> jmcarthur: yeah, that was jut an example
17:09:55 <jmcarthur> doesn't have to be complete though
17:10:11 <ski> @where LYAH
17:10:12 <lambdabot> http://www.learnyouahaskell.com/
17:10:16 <mparodi> ok, but I prefer a standard version since I'm still learning
17:10:24 <ski> Rambo : have you seen <http://www.learnyouahaskell.com/> yet ?
17:10:31 <jmcarthur> startling: if you can some meaningful tests in to use with quickcheck, you will never look at unit testing quite the same way again
17:10:47 <jmcarthur> unless you've done fuzz testing before
17:10:51 <ski> mparodi : the `:set -XNo..' here just turns the DMR off
17:10:53 <applicative> mparodi   touch .ghci  && nano .ghci  then paste in :set -XNoMonomorphismRestriction and save
17:11:13 <newsham> ?check \xs -> reverse (reverse (xs :: [Int])) == xs
17:11:14 <mparodi> echo ":set -XNoMonomorphismRestriction" > ~/.ghci
17:11:15 <lambdabot>   "OK, passed 500 tests."
17:11:21 <mparodi> is easier :P
17:11:34 <applicative> the MonomorphismRestriction wasn't stopping missles from being launched, mparodi , honest
17:11:50 <applicative> besides, the os x say function knows how to pronounce it
17:11:57 <zzo38> mparodi: Yes, that way easier
17:12:17 <mparodi> first of all, what is DMR?
17:12:30 <applicative> type say NoMonomorphismRestriction
17:12:31 <sipa> deeaded monkmorphism restriction
17:12:32 <ski> mparodi : the DMR only strikes when (a) you don't have explicit arguments in your definition (i.e. you have `f = ...' instead of `f x = ..x..'); and (b) you don't have an explicit type signature (for `f')
17:12:32 <zzo38> mparodi: Dreadful Monomorphism Restriction
17:12:35 <sipa> dreaded
17:12:44 <newsham> dennis m. ritchie
17:13:13 <ski> mparodi : and what it does, when it strikes, is forbid any overloading (like `Functor f =>' or `Eq a =>', &c.) on the affected definition
17:13:15 <nand`> mparodi: http://www.haskell.org/haskellwiki/Monomorphism_restriction
17:13:39 <ski> mparodi : if it can, it will default types to avoid ambiguity, otherwise it will complain, as in your case
17:14:00 <ski> mparodi : if you had said `let f x = fmap Char.ord x', it wouldn't have struck
17:14:06 <nand`> sometimes you end up with a lot of () in your types
17:14:10 <applicative> mparodi: it's too hard to explain, but your idea why you were having trouble with "let blah = fmap ord"  is basically the right one
17:14:22 <mparodi> actually it was the first think I tried ski
17:14:40 <mparodi> thing *
17:14:51 <ski> nand` : like ?
17:15:01 <applicative> mparodi: and your idea that you shouldnt  have a problem with  "let blah = fmap ord" is the NoMonomorphismRestriction idea
17:15:35 <ski> mparodi : ironically, the DMR was added, because it was thought that it would be less confusing for newbies, that way
17:15:38 <mparodi> oh, no, actually it was: let bar = fmap (\x -> Char.ord x)
17:15:45 <ski> mparodi : yeah, that's different
17:15:51 <ski> also
17:15:58 <kallisti_> ski: doesn't it also share better?
17:16:02 <ski>   let bar = \x -> fmap Char.ord x
17:16:03 <ski> is different
17:16:10 <mparodi> yes, it's the "same" as let bar = fmap Char.ord
17:16:36 <ski> kallisti : yes, the idea was that something which syntactically looked like it would share in a lazy implementation, *would* actually share
17:16:44 <ski> mparodi : *nod*
17:17:09 <ski> to defuse the DMR, you either have to have explcit arguments to the left of the `='
17:17:30 <applicative> -XNoMono... is less confusing for learners, but maybe for bad reasons...
17:17:34 <ski> (this is impossible if you're not defining a function, e.g. a parser, or a top-level definition of a set or something)
17:17:46 <ski> *or* you have to add a type signature
17:17:58 <hpc> applicative: the even more less confusinger advice is "put type signatures on stuff at the top level"
17:18:09 <nand`> ski: don't know any examples but some pointfree code I defined in GHCi once ended up with a type involving lots of [()] -> .. where it should have been something like Integral a => [a] -> ...
17:18:12 <ski> (or you can also disable it, with `:set -XNo...' in GHCi, e.g.)
17:18:14 <nand`> ski: older version of GHCi too iirc
17:18:22 <zzo38> In a program I always add a type signature but in GHCi I find -XNoMonomorphismRestriction to be useful.
17:18:22 <nand`> naturally, adding the type signatures made it work fine
17:18:29 <ski> nand` : ah, interesting
17:19:08 <ski> i think i prefer O'Caml's behaviour here
17:19:19 <ski> (in not exactly the same situation, but a similar one)
17:19:20 <nand`> ski: what's that?
17:19:42 <ski> well, in some cases in O'Caml (and SML), it will refuse to infer a polymorphic type
17:19:52 <mparodi> alright, I have :set -X.. now :)
17:20:00 <ski> (inferring a polymorphic type in those cases could break the type system, because of side-effects)
17:20:10 <ski> so, you might have wanted to infer
17:20:20 <ski>   frob :: Foo a -> Bar a
17:20:24 <ski> which really means
17:20:28 <ski>   frob :: forall a. Foo a -> Bar a
17:20:33 <ski> but instead, what you get is
17:20:37 <ski>   frob :: Foo _a -> Bar _a
17:20:42 <ski> which *isn't* polymorphic
17:20:54 <ski> it's just that it hasn't decided yet which concrete type `_a' is
17:20:58 <ski> as soon as you say
17:20:59 <nand`> ah
17:21:01 <ski>   frob blah
17:21:02 <ski> where
17:21:05 <ski>   blah :: Foo Bool
17:21:13 <ski> it will instantiate `_a' to `Bool' giving
17:21:19 <ski>   frob :: Foo Bool -> Bar Bool
17:21:44 <nand`> does that prevent you from using frob elsewhere, eg. with an Int?
17:21:48 <ski> yes
17:21:56 <ski> because it isn't polymophic
17:22:11 <nand`> it could be like templates, where multiple copies are compiled
17:22:26 <ski> often if you're writing code, the rest of the code context will determine the type `_a' for you
17:22:36 <ski> but in the interactor, you can encounter such types "live"
17:22:54 <nand`> so it just prevents you from doing that?
17:23:03 <nand`> (automatically, that is)
17:23:15 <ski> yes
17:23:27 <ski> this is really not that similar from
17:23:42 <ski> @type let foo id = (id "a",id False) in foo id
17:23:44 <lambdabot>     Couldn't match expected type `Bool' against inferred type `[Char]'
17:23:44 <lambdabot>       Expected type: Bool -> t
17:23:44 <lambdabot>       Inferred type: [Char] -> t1
17:23:54 <ski> here the `id' argument is also monomorphic
17:24:25 <nand`> @type let foo id = (id "a", id False); foo :: (forall a. a -> a) -> (String, Bool) in foo id
17:24:25 <lambdabot> (String, Bool)
17:24:34 <ski> (except that in the O'Caml case, you can't give a polymorphic typing for `frob', it'd be unsafe, as opposed to using a rank-2 signature above)
17:24:49 <newsham> case lang of Ocaml ->
17:25:15 <nand`> return ()
17:26:22 <ski>   match lang with Ocaml -> ...  (* actually *)
17:26:41 <ski>   case lang of SML => ...  (* is SML *)
17:28:02 <ski> (s/similar/dissimilar/)
17:29:06 <ski> btw, if we use `unsafePerformIO', we can do the same unsafe things re the type system which the value restriction in the MLs is meant to disallow
17:29:30 <ski>   {-# NOINLINE globalIORef #-}
17:29:39 <ski>   globalIORef :: IORef a
17:29:54 <zzo38> ski: I have seen things like that, and I don't like those kind of things
17:29:55 <ski>   globalIORef = unsafePerformIO (newIORef (error "can't happen"))
17:30:04 <ski>   unsafeCoerce :: a -> b
17:30:34 <zzo38> I generally find unsafeCoerce more useful than unsafePerformIO
17:30:39 <ski>   unsafeCoerce a = unsafePerformIO (do writeIORef globalIORef a; readIORef globalIORef)
17:31:20 <dolio> ski: Yeah. I suppose my general point is that A -> B -> C actually works appropriately (by design?) with f x y, and that trying to use the former to motivate y x f doesn't work. You'd have to move to C <- B <- A, and then the same sort of people would come along and complain that it's y x f instead of f x y.
17:31:33 <ski> because there's no `IO' type in the MLs to keep track of the distinction between `() -> a' and `IO a', we could do the above, if we could define `globalIORef'
17:31:34 <nand`> I've never used unsafeCoerce, mainly because I have no idea how it works (in regards to GHC's internal representation of types)
17:32:07 <ski> (and if you don't like `error' there, you could use `newIORef Nothing', giving `globalIORef :: IORef (Maybe a)' instead, which also works)
17:32:38 <ski> nand` : basically, you should only use `unsafeCoerce :: a -> b', if you know that the types `a' and `b' are the same in your case (but the compiler can't see it)
17:32:46 <applicative> ski, I want to find out whats in my globalIORef Possible fix: add an instance declaration for (Show GHC.Prim.Any
17:32:51 <ski> (i think there's one or two more cases which are allowed, but i can't recall them)
17:33:01 <dolio> And also, not currying is annoying. :)
17:33:11 <nand`> ski: I'm not sure when I'd be working with two identical but somehow distinct types
17:33:19 <nand`> examples?
17:33:29 <applicative> oh wait if its an Int , *** Exception: can't happen
17:33:52 <ski> dolio : yeah, i'm aware of it :)
17:34:21 <ski> applicative : hmm ?
17:34:23 <dmwit> nand`: Data.Dynamic is the canonical one
17:34:32 <ski> (dolio : i.e., to both)
17:35:03 <applicative> ski, just figuring out let  globalIORef = unsafePerformIO (newIORef (error "can't happen"))
17:35:17 <ski> nand` : one example could be if you have a heterogenous map, where you have keys of type `Key a', where `a' is the type of the value associated with the key in the map
17:36:03 <ski> nand` : a bit like `STRef's, only doing it yourself (and persistent, instead of emphemeral data)
17:36:31 <dmwit> ski: Surely you don't need a global IORef to implement unsafeCoerce.
17:36:56 <dmwit> unsafeCoerce = let localIORef = unsafePerformIO (newIORef undefined) in ...
17:36:59 <ski> nand` : so you want to implement `lookup :: Key a -> HMap -> Maybe a'
17:37:01 <Peaker> ski, hmm.. such a globalIORef would be thread-unsafe?
17:37:14 <ski> dmwit : yes, that works as well
17:37:28 <dmwit> Peaker: My objection exactly. =)
17:37:30 <ski> Peaker : probably
17:37:30 <Peaker> it would suck if two threads unsafeCoerce and one gets the other's value
17:37:47 <nand`> ski: right
17:37:47 <ski> (:
17:37:48 <dmwit> Peaker: But it's easy to refine, as above.
17:38:35 <ski> nand` : if you have a fixed set of keys, i think you don't need this, GADTs are sufficient -- but if you wnat to generate new keys dynamically, i don't know another way
17:39:43 * applicative gives up on Control.Pipe.Final  maybe another day
17:40:44 <ski> nand` : i think edwardk had some example where he knew `A' was a `newtype' of `B', but wanted to convert from `F A' to `F B' (or vice versa) -- GHC has some kind of equality conversions which could probably be used here, though
17:41:24 <dobblego> is there a Data.Map-like thing that can provide insertion order?
17:41:25 <nexion> does ghc have a way of passing parameters to the code at compile-time? something like C's defines with -D
17:41:41 <ski> applicative : "oh wait if its an Int , *** Exception: can't happen" :), the `global' referred to extent, not scope
17:42:12 <applicative> ski I think I got it in the end
17:42:28 <nexion> I'd like to have multiple builds that are identical with the exception of the hostnames used (test servers vs prod)
17:42:40 <jmcarthur> nexion: you can use the c preprocessor with ghc
17:42:49 <jmcarthur> nexion: google GHC CPP or something to that effect
17:43:10 <nexion> is this a good way to achieve that?
17:43:25 <jmcarthur> nexion: it's a common way
17:43:48 <hpc> you usually don't want CPP
17:44:22 <nexion> all I'd like to do is set some boolean or integer in the code
17:44:23 <hpc> it's got some C-specific logic to do with parsing/lexing
17:45:09 <applicative> hpc but hackage is full of cpp nonsense
17:45:12 <hpc> nexion: just define it at the top level
17:45:18 <hpc> module Foo where
17:45:22 <hpc> global = False
17:45:27 <hpc> stuff a b c = ...
17:45:28 <hpc> ...
17:45:42 <jmcarthur> i'd just use a cabal flag and CPP, personally
17:45:46 <dobblego> does Okasaki have anything to say re: a map that can give insert order?
17:46:18 <ski> ("can give insert order" ?)
17:46:22 <hpc> applicative: it also has http://hackage.haskell.org/package/acme-php-0.0.1
17:46:47 <dobblego> ski: an operation that can tell me the order in which the associations were inserted
17:47:02 <ski> something like `toList' ?
17:47:06 * applicative is glad to see 'Safe Inferred' for acme-php
17:47:20 <dobblego> ski: yes, but insertion order, not the key order
17:47:22 <nand`> What's a good and easy to use module to parse (relatively simple) runtime parameters supporting short (-x value), long (--xname value) and assignment (-x=value or --xname=value)?
17:47:39 <nexion> hpc: I'm not sure what you mean.. will that allow me to override it to True at compile-time?
17:47:40 <ski> dobblego : i don't recall
17:47:43 <jmcarthur> dobblego: there's always the pair-of-maps with a counter approach
17:47:58 <dobblego> jmcarthur: you mean (Map k v, Map k Int) ?
17:48:00 <dmwit> nand`: I've been happy with the built-in GetOpt stuff.
17:48:00 <ski> you'd have to define whether `update's are basically a removal followed by an insertion
17:48:02 <hpc> nexion: if you want it to be True, you can just change it temporarily
17:48:06 <dobblego> ski: me neither and I cannot find anything in the theses
17:48:09 <dmwit> nand`: Other people like cmdargs.
17:48:16 <hpc> i assume what you want is some kind of debug mode?
17:48:17 <jmcarthur> dobblego: i mean (Map k v, Map Int k, Int)
17:48:26 <nexion> hpc: yeah
17:48:29 <dobblego> jmcarthur: can you provide a link to explain this?
17:48:30 <ski> dobblego : i can't recall anything about it from the book, bicbw
17:48:30 <hpc> yeah, go with that
17:48:34 <nand`> dmwit: noted both, thanks
17:48:54 <hpc> nexion: if you wanted apache-style #defines-that-enable-useful-functions, i would have to slap you :D
17:48:58 <applicative> man this acme=php stuff is great.  instance Floating String
17:48:59 <jmcarthur> dobblego: Map Int k just gives you a decent toList for keys, you can either include values with that too or look them up in the other map
17:49:14 <jmcarthur> dobblego: the Int is just a counter that you use to populate the Map Int k
17:49:33 <jmcarthur> eh i guess you might as well just have a list or something
17:49:37 <ski> @hoogle Map a b -> Int
17:49:37 <lambdabot> Data.Map size :: Map k a -> Int
17:49:38 <lambdabot> Data.Map findIndex :: Ord k => k -> Map k a -> Int
17:49:38 <lambdabot> Data.Graph.Inductive.Query.DFS noComponents :: Graph gr => gr a b -> Int
17:49:39 <hpc> applicative: one of these days im gonna get around to redefining the standard type classes
17:49:48 <applicative> almost as good as 'instance Monad Char'
17:49:49 <jmcarthur> you could just reverse it when you need the toList
17:50:12 <nand`> dmwit: GetOpt seems perfect for my needs
17:50:15 <monochrom> hoogle's database should include acme-php so we can all benefit :)
17:50:17 <dobblego> jmcarthur: do you know of an implementation of this? I'd be interested in seeing the insert/delete operations
17:50:23 <jmcarthur> dobblego: what operations need to be most efficient?
17:50:50 <jmcarthur> or, rather, what would be the desired worst case running times of them?
17:50:51 <dobblego> jmcarthur: insert, get
17:51:09 <jmcarthur> how slow can toList be?
17:51:14 <jmcarthur> and what about space usage?
17:51:19 <dobblego> I was thinking O(n)
17:51:27 <dobblego> jmcarthur: are you thinking (Map k v, [k]) ?
17:51:30 <nexion> hpc: that would work, but it's not ideal since I'd have to keep changing that value
17:51:37 <jmcarthur> i don't see anything wrong with that one, yes
17:51:44 <nexion> hpc: I could have the build system dump a .hs file with the value, which would allow automatic building of debug and release versions
17:51:50 <hpc> nexion: maybe template haskell could help...
17:51:57 <dobblego> jmcarthur: I have considered that too, but then removed the space blow-out a bit with (Map k v, Map k Int)
17:52:25 <jmcarthur> dobblego: you could make that Map k (v, Int)
17:52:25 <nexion> I'm surprised that it seems like I'm trying to do something unusual here
17:53:11 <dobblego> jmcarthur: yeah I guess I can
17:53:17 <jmcarthur> dobblego: not sure i see how that is better than (Map k v, [k]) though
17:53:18 <applicative> wow, notElem x ys = elem (not x) ys is excellent
17:53:53 <dobblego> jmcarthur: with [k] I'd keep keys that have been inserted more than once
17:54:06 <jmcarthur> oh and you only want the latest
17:54:12 <dobblego> right
17:54:30 <dobblego> the toList would essentially normalise it
17:54:56 <jmcarthur> i see, but in O(n log n) instead of the desired O(n)
17:55:17 <applicative> > let notElem x ys = elem (not x) ys in notElem True [True,False]
17:55:18 <lambdabot>   True
17:55:38 <applicative> It seems to fail in corner cases hpc ^^^
17:55:42 <nand`> http://hackage.haskell.org/packages/archive/acme-now/1.0.0.1/doc/html/src/Acme-Time-Now.html#now
17:55:57 <hpc> applicative: of course!
17:56:01 <hpc> applicative: wait until you see sort
17:57:29 <jmcarthur> dobblego: for a space tradeoff you can get the O(n) toList. (Map k (v, Int), Map Int k). toList is just toList on the second map. insertion requires you to check the first map for an existing entry so you can remove it from the second map.
17:58:07 <dobblego> yeah, thanks
17:58:14 <jmcarthur> dobblego: that's basically the same Map k v paired with a bijection between keys and ints
17:58:25 <jmcarthur> s/bijection/bijective map/
18:11:43 <startling> hmm, what's the best way to join a list of strings, putting some other string in between?
18:12:46 <dmwit> :t intercalate
18:12:47 <lambdabot> forall a. [a] -> [[a]] -> [a]
18:13:08 <dmwit> There's also unwords and unlines for particularly common use cases.
18:13:14 <nexx> intersperse
18:14:01 <startling> oh, unwords is perfect for me
18:14:03 <startling> thanks!
18:15:12 <Nimatek> > concat . intercalate ". " . words $ "speaking with pauses."
18:15:13 <lambdabot>   Couldn't match expected type `[a]'
18:15:13 <lambdabot>         against inferred type `GHC.Types...
18:15:23 <dmwit> no concat necessary
18:15:36 <dmwit> > intercalate ". " . words $ "speaking with pauses."
18:15:38 <lambdabot>   "speaking. with. pauses."
18:15:40 <Nimatek> indeed
18:15:53 <Nimatek> I should sleep.
18:15:55 <hpc> @let shatnerize = intercalate ". " . words
18:15:56 <lambdabot>  Defined.
18:16:05 <Nimatek> Haha.
18:16:47 <applicative> > shatnerize "yes Haskell can do that"
18:16:49 <lambdabot>   "yes. Haskell. can. do. that"
18:18:10 <ClaudiusMaximus> does repa evaluate adjacent elements in the same thread where possible?  how can i make it do the opposite with the minimum of fuss?
18:18:14 <ski> "shatnerize" ?
18:18:32 <hpc> ski: it's how william shatner talks
18:18:43 * ski has no idea who that is
18:18:58 <nand`> https://en.wikipedia.org/wiki/William_Shatner
18:19:01 <nand`> had to look it up myself
18:19:15 <hpc> for a prime example of shatner: http://www.youtube.com/watch?v=Kestt5BI3eg&feature=related
18:19:21 <hpc> also http://www.youtube.com/watch?v=HU2ftCitvyQ&feature=youtube_gdata
18:19:30 <nand`> seems like he portrays the fictional captain James T. Kirk
18:20:03 <startling> is a Char a byte or a unicode character?
18:20:20 <hpc> unicode
18:20:23 <applicative> it is a character
18:20:32 <nand`> for byte, see Word8
18:20:39 <hpc> it's an encoding-agnostic character, even
18:20:50 <startling> thanks!
18:21:38 <nand`> hpc: how's it implemented (in GHC)? machine integer containing the unicode codepoint?
18:21:45 <hpc> @src Char
18:21:46 <lambdabot> data Char = C# Char#
18:21:50 <hpc> like that ;)
18:21:53 * hpc has no clue
18:22:25 * nand` has always wondered what the ‘#’ after fields meant
18:22:32 <hpc> nand`: it means nothing
18:22:36 <nand`> oh okay
18:22:41 <dobblego> jmcarthur: I think I would also need to keep an Int so: (Map k (v, Int), Map Int k, Int)
18:22:43 <nand`> so that's just some internal magic type?
18:22:51 <applicative> hpc I think acme-php could do with a Bits instance
18:22:52 <dobblego> i.e. the next Int
18:22:53 <hpc> it's just a convention like "'" for internal types
18:22:57 <startling> hmmm, how do I get the bytes of a char encoded in utf-8?
18:23:03 <hpc> foo' VS foo#
18:23:15 <applicative> > ord 'a'
18:23:16 <lambdabot>   97
18:23:19 <startling> oh lovely
18:23:20 <hpc> but the latter requires an extension, because (#) is a symbol-y character
18:23:43 <startling> applicative, where is that?
18:23:52 <applicative> ord?
18:24:04 <startling> yeah. doesn't seem to be a builtin
18:24:08 <applicative> Data.Char
18:24:11 <nand`> > ord '原'
18:24:11 <lambdabot>   21407
18:24:13 <startling> ah. thanks!
18:24:17 <applicative> i'm not sure it's what you meant
18:24:21 <nand`> technically that isn't UTF-8
18:24:21 <hpc> applicative: it could do with lots of things, definitely; i just need to get bored enough with writing good code to come back to it ;)
18:24:23 <startling> yeah, it isn't
18:24:29 <shachaf> nand`: "technically"
18:24:31 <startling> that appears to be the unicode codepoint
18:24:35 <ski> @type 12#
18:24:36 <lambdabot> GHC.Prim.Int#
18:24:38 <shachaf> Also in every other way.
18:24:42 <startling> I'd like a list of bytes, if possible
18:24:43 <shachaf> startling: Data.Text has it, at least.
18:25:12 <nand`> startling: usually you want String -> ByteString as a composition of String -> Text and Text -> ByteString
18:25:20 <shachaf> nand`: Really?
18:25:26 <nand`> at least if I remember correctly
18:25:33 <startling> oh, Codec.Binary.UTF8.String has it
18:25:36 <shachaf> I understand that you might *have* to do that, but why do you *want* it?
18:25:37 <nand`> there's definitely http://hackage.haskell.org/packages/archive/text/latest/doc/html/Data-Text-Encoding.html#v:encodeUtf8 though
18:25:53 <startling> > encode "a"
18:25:54 <lambdabot>   Not in scope: `encode'
18:26:06 <startling> > import Codec.Binary.UTF8.String; encode "a"
18:26:08 <lambdabot>   <no location info>: parse error on input `import'
18:26:18 <startling> oh well
18:26:21 <startling> you get the idea
18:26:28 <nand`> oh, there's Data.ByteString.UTF8.fromString/toString as well
18:26:30 <applicative> unfoldr (Text.uncons)
18:26:54 <zezikaro> I'm on chapter 4-5 of learn you a haskell now, and I'm wondering what sort of basic program I can write?
18:27:04 <zezikaro> all of the examples so far have been 1 line of code really
18:27:14 <nand`> shachaf: you don't; ignore what I said
18:27:26 <startling> zezikaro, what do you want to write?
18:28:08 <applicative> unfoldr (whatever . Text.uncons) rather , where whatever is the function that gives you the 'bytes'
18:28:28 <nand`> zezikaro: I think the problem with that is that IO etc. doesn't get introduced until later; so you're very limited in terms of what “real” programs you can implement; but you could try some projectEuler stuff (in GHCi or similar)
18:28:50 <shachaf> Don't recommend "projectEuler stuff". :-(
18:28:58 <shachaf> You won't learn Haskell from doing that.
18:29:23 <zezikaro> I don't think i'd get very far in project euler either
18:29:26 <hpc> PE is only good for teaching number theory
18:29:33 <hpc> and that's something nobody wants to learn
18:29:34 <hpc> ;)
18:30:01 <nand`> heh
18:30:29 <hpc> you could skip ahead to the IO chapter and figure out just enough to write some code that you can swap non-IO functions into
18:30:36 * applicative loved the distribution of primes etc as a boy
18:30:36 <nand`> there's also “99 haskell problems” but it's based on a rewrite of a rewrite of two languages that are very much unlike Haskell
18:30:38 <hpc> and then try writing stuff like "cat" and "wc" with it
18:30:42 <nand`> so a lot of the examples seem rather contrived
18:32:02 <nand`> using hpc's suggestion you could implement your program body as main' :: String -> String and then stick the wrapper “main = getContents >>= putStrLn . main'” somewhere without having to learn IO
18:33:02 <nand`> or just stick to GHCi, which is what I did for the first few weeks of using Haskell
18:33:20 <applicative> zezikaro: install gloss and then download the gloss-examples library and look at the simpler examples.
18:33:51 <zezikaro> hpc I decided to do that, but I couldn't get it working o.O
18:33:56 <zezikaro> Skipping to chapter 8 that is
18:34:14 <applicative> oh I see http://dac4.designacourse.com:8000/ is still up.
18:35:10 <zezikaro> in leksah it didn't seem to work
18:35:25 <zezikaro> leksah's mouse events are really broken
18:36:04 <zezikaro> if you select text and your mouse goes out of the window, it still keeps highlighting up to your cursor, even if you let go of the mouse
18:36:18 <applicative> nand`: the way to write it is "interact main' "
18:37:01 <nand`> applicative: thanks, I keep forgetting about helpers like those
18:37:31 <applicative> then wc is main = interact main'; main' = show.length.words
18:37:39 <applicative> sort of
18:37:41 <startling> what's the best way to get a Word8 as a string if it's ascii (and, ideally, a hex escape if it's not)? i'm just using this for Show
18:38:21 <startling> *printable ascii, rather
18:38:30 <c_wraith> ascii printable = 32 - 126
18:38:41 <ClaudiusMaximus> > (toEnum . fromEnum) (99 :: Word8) :: Char
18:38:43 <lambdabot>   'c'
18:38:54 <c_wraith> for everything outside of that range..   other stuff
18:39:30 <monochrom> also (chr . fromIntegral)
18:39:40 <nand`> > show ((toEnum . fromEnum) (21407 :: Word8) :: Char)
18:39:41 <lambdabot>   "'\\159'"
18:39:53 <nand`> oh, 21407 as Word8 doesn't exactly work
18:39:58 <applicative> zezikaro: do you know how to compile a module like this main = interact main'; main' = show.length.words
18:40:26 <zezikaro> applicative no -p
18:40:27 <zezikaro> =[
18:40:49 <startling> oh, (chr. fromIntegral) is perfect
18:40:50 <startling> thanks!
18:41:09 <applicative> so put it in a file, save it as zez.hs then do ghc --make -O2 zez.hs
18:41:16 <monochrom> (toEnum . fromEnum) needs more type annotations, that's all
18:41:20 <dmwit> startling: Whatcha hackin' on?
18:41:33 <nand`> f x | x < 32 || x > 126 = '\\' : show x | otherwise = [(toEnum . fromEnum) c :: Char]
18:41:46 <applicative> then  cat zez.hs | ./zez will tell you how many words
18:41:51 <startling> dmwit: bytecode compiler for a language I'm implementing, so i can bootstrap the actual bytecode compiler (written in that language)
18:41:52 <nand`> ‘x’ instead of ‘c’ in the second part
18:42:00 <applicative> zezikaro: what platform are you on?
18:42:14 <dmwit> Cool!
18:42:50 <zezikaro> applicative windows >.<
18:42:52 <zezikaro> 7
18:42:57 <zezikaro> don't judge me please haha
18:43:11 <ski> @check \x -> fromEnum x == (fromEnum . (toEnum  :: Int -> Char) . fromEnum) x
18:43:13 <lambdabot>   "OK, passed 500 tests."
18:43:26 <dmwit> We don't judge in here. Sometimes I even defend PHP just for the heck of it.
18:43:55 <applicative> hmmmm  damn no copy of Windows around
18:44:06 <dmwit> You can still use ./zez < zez.hs even in the Windows command prompt.
18:44:17 <dmwit> or ./zez < somethingMoreInteresting.txt
18:44:23 <applicative> there you are.'
18:44:43 <applicative> i used zez.hs because I knew it was in the same directory
18:44:56 <shashwat> > filter (\x -> floor (sqrt x) == ceiling (sqrt x)) [1..100]
18:44:57 <lambdabot>   [1.0,4.0,9.0,16.0,25.0,36.0,49.0,64.0,81.0,100.0]
18:45:27 <shashwat> Why do I get non integer values as result ?
18:45:38 <dmwit> Because you started with non-integer values.
18:45:49 <applicative> the command in windows would be ghc.exe --make -O2 zez.hs
18:46:04 <ski> `floor' and `ceiling' give fractional results
18:46:09 <dmwit> > filter (\x -> floor (sqrt (fromIntegral x)) == ceiling (sqrt (fromIntegral x))) [1..100]
18:46:10 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
18:46:24 <ski> well, more importantly, they, and `sqrt' take fractional inputs
18:46:34 <shashwat> dmwit: oh, got it.
18:46:36 <zezikaro> > [x | x <- [1..100], floor (sqrt x) == ceiling (sqrt x)]
18:46:37 <lambdabot>   [1.0,4.0,9.0,16.0,25.0,36.0,49.0,64.0,81.0,100.0]
18:46:51 <shashwat> It is like typecasting ?
18:46:57 <ski> not casting
18:47:00 <dmwit> There is no casting in Haskell.
18:47:22 <ski> it merely constraints the numbers in the original list to have been fractional from the very start
18:47:34 <ski> > [1,2,3]
18:47:35 <lambdabot>   [1,2,3]
18:47:38 <ski> > [1,2,3] :: [Double]
18:47:39 <lambdabot>   [1.0,2.0,3.0]
18:47:49 <applicative> > [floor x | x <- [1..100], floor (sqrt x) == ceiling (sqrt x)]
18:47:49 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
18:48:16 <dmwit> :t 1
18:48:17 <lambdabot> forall t. (Num t) => t
18:48:18 <dmwit> :t sqrt
18:48:19 <lambdabot> forall a. (Floating a) => a -> a
18:48:53 <applicative> :t 0.0
18:48:54 <lambdabot> forall t. (Fractional t) => t
18:49:20 <shashwat> So if any operation happens which need to change values from integer to float, it will be changed and remain so unless we specifically specify it ?
18:50:01 <dmwit> Expressions never change type.
18:50:04 <applicative> shashwat: if its an Int, you must map it to a Float with a function
18:50:40 <applicative> > let one = 1 :: Integer in fromInteger one :: Float
18:50:41 <lambdabot>   1.0
18:50:54 <dmwit> Or: what does "remain so" mean in that sentence?
18:51:11 <ski> shashwat : using `sqrt' on the numbers in the list caused them to have been floating-point numbers from the start
18:51:35 <ski> shashwat : using `fromIntegral' on them first would cause them to have been integral from the start, instead
18:51:50 <shashwat> ski: Oh.  I got it now.  I was under the impression, they were integers and got changed to float.
18:51:53 <ski> shashwat :  there is no "change values from integer to float" going on here
18:51:59 <applicative> the member 1 of the type Integer has been the same since the time of Plato
18:52:02 <ski> > 2 :: Float
18:52:03 <lambdabot>   2.0
18:52:07 <ski> > 2 + 3.0
18:52:08 <lambdabot>   5.0
18:52:14 <ski> `2' here is a `Float'
18:52:25 <dmwit> Double
18:52:28 <dmwit> But yes.
18:52:43 <ski> (because in the latter case, `3.0', via `(+)' demanded it, and in the former case, because the type ascription demanded it)
18:52:50 <ski> yeah
18:53:11 <shashwat> ski: dmwit: got it. Thanks. :)
18:53:15 <dmwit> I think this is a deceptive way of describing it.
18:53:23 <dmwit> 2 here is not a Float, it's a forall a. Num a => a
18:53:29 <dmwit> 3.0 is a forall a. Floating a => a
18:53:43 <ski> yes, it's slightly more complicated
18:53:57 <ski> > (2 + 3.0) - (2%3)
18:53:58 <lambdabot>   13 % 3
18:54:01 <dmwit> At the very end, to avoid ambiguity, a particular instance of Num and Floating is chosen, namely in this cases Double.
18:54:21 <boccato> Is there command in Sublime Text 2 to align all the = signs?
18:54:22 <dmwit> (2 + 3.0 is a forall a. (Num a, Floating a) => a; I skipped that step.)
18:54:43 <ski> (dmwit : isn't `Num' a superclass of `Floating' ?)
18:54:54 <dmwit> I'm sure it is. =)
18:55:11 <dmwit> Luckily, that doesn't make my statement wrong. =)
18:55:53 <Clint> is that an implementation detail or is it spec'd to be Double?
18:56:11 <dmwit> That's in the spec.
18:56:38 <dmwit> Certain special ambiguities (namely, numeric ones) are resolved in a special order.
18:56:39 <ski> dmwit :)
18:57:51 <dmwit> Clint: http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-790004.3.4 describes the precise rules
18:59:26 <nand`> what's a good module to plot out a :: Double -> Double -> Color ? I'm going through gloss's documentation and it doesn't seem to have any constructions of the sort
18:59:31 <Clint> dmwit: thanks
19:00:50 <nand`> why does the haskell report use unicode characters in types instead of actual haskell syntax?
19:01:00 <nand`> at least in that section
19:01:18 <dmwit> Just turn on UnicodeSyntax and that's valid. =)
19:01:56 <dmwit> nand`: You'll have to specify how you want to sample that infinite space, I suppose.
19:02:43 <nand`> dmwit: I'm looking for something like gloss's “display” which allows the user to zoom/pan around, I can provide a default rectangle
19:02:43 <dmwit> Other than that I would think gloss ought to be fine, or cairo.
19:02:54 <dmwit> aha
19:03:19 <dmwit> That's actually a bit trickier. I don't know of any library which does that.
19:03:52 <dmwit> I have a similar tool for cairo, but it is (as I'm sure the gloss one is) not for rasters.
19:04:07 <dmwit> Shouldn't be hard to adapt either gloss's display or some such display with gtk.
19:04:32 <nand`> I'm not sure how this would work by adapting gloss
19:04:36 <dmwit> Just gotta make it a (Double -> Double -> Render ()) instead of a Render (). =P
19:04:59 <dmwit> nand`: Copy the source of display, but everywhere it calls the rendering callback, have it call a callback that knows the width and height of the current zoom level.
19:05:16 <dmwit> Then do your sampling inside that function.
19:05:47 <dmwit> <- actually never used gloss, so this advice is necessarily really vague
19:08:04 <nand`> http://hackage.haskell.org/packages/archive/gloss-raster/1.7.4.3/doc/html/Graphics-Gloss-Raster-Field.html
19:08:48 <nand`> this seems useful
19:10:46 <dmwit> Oh, perfect. =)
19:11:07 <nand`> just a shame it's limited to Float; I was hoping to zoom into Double precision or more
19:13:53 <nand`> ah, it doesn't let me interact either
19:14:09 <nand`> but I can use makePicture and draw that using the normal gloss API
19:24:57 * hackagebot filesystem-trees 0.1.0.2 - Recursively manipulate and traverse filesystems as lazy rose trees.  http://hackage.haskell.org/package/filesystem-trees-0.1.0.2 (AdamCurtis)
19:29:57 * hackagebot webdriver 0.3.2.1 - a Haskell client for the Selenium WebDriver protocol  http://hackage.haskell.org/package/webdriver-0.3.2.1 (AdamCurtis)
19:32:35 <Haskell_Chap> hello all
19:32:43 <Haskell_Chap> ? <<
19:33:10 <kallisti> hi
19:33:24 <Haskell_Chap> what language was the Glasgow Haskell Compiler done in?
19:33:47 <kallisti> C originally. now it's mostly bootstrapped Haskell with some C internals.
19:34:02 <Haskell_Chap> It was Simon Peyton Jones that did this project, no?
19:34:50 <Haskell_Chap> kallisti: i've been learning C++ lately and like it in that strange type constraint way
19:35:02 <kallisti> he's been a primary contributor to the project. I don't know who started it.
19:35:14 <kallisti> http://www.ohloh.net/p/ghc
19:35:21 <kallisti> a lot of info about the project and its history, contributors, etc
19:35:29 <Haskell_Chap> amazing guy frankly
19:35:51 <shachaf> kallisti: GHC was originally C?
19:36:09 <kallisti> to my knowledge..
19:36:19 <shachaf> I thought it was Lazy ML or Haskell or something like that.
19:36:30 <shashwat> In ghci how do I jump to the beginning of line in a tmux session ?   Prefix key is mapped to control+a.  In shell I work with vi-mode ( i.e. $ for jumping to start of the line), is there any such alternative for ghci ?
19:36:46 <kallisti> I've been wrong before. :P
19:36:50 <Haskell_Chap> would it be possible to get my hands on the compiler code? Maybe an older version, not so implemented
19:36:53 <jfischoff> anyone every gotten this error from cabal: The program ar is required but it could not be found. ?
19:37:05 <shachaf> jfischoff: Sounds like you should install the program ar.
19:37:15 * shachaf has advanced error-message-reading powers.
19:37:20 <jfischoff> hehe
19:37:29 <shachaf> (Alternatively, if you have it installed, tell it where to find it.)
19:37:40 <shashwat> jfischoff: Is it "The program ar" or "The programmer"
19:37:42 <jfischoff> mind you I have a hacked version of cabal for cross compiling for arm
19:37:54 <jfischoff> but I thought maybe someone else had seen it
19:37:56 <geekosaur> that could get interesting
19:38:20 <Haskell_Chap> ill figure it out
19:38:28 <jfischoff> yeah…its probably something none one outside of blackh has seen, or maybe Cale?
19:38:30 <dmwit> shashwat: Just hit "home"?
19:38:53 <shashwat> dmwit: No home key on mac. :(
19:39:03 <dmwit> shashwat: Buy a real keyboard.
19:39:07 <tgeeky> ha!
19:39:17 <dmwit> shashwat: Alternately, learn to configure readline.
19:39:25 <geekosaur> ar is the simple archiver used for static libraries; it has some binary dependencies because of the archive symbol table, so you need to find the version of ar for your cross-development environment
19:39:48 <shashwat> dmwit: That sounds nice, let me check.
19:40:15 <geekosaur> shashwat, if this is actually tmux (which normally uses control-b, I thought), try hittig control-a twice
19:40:21 <tgeeky> dmwit: what about mice? What's the mac mouse called? Mighty Mouse?
19:40:48 <dmwit> Mac laptops do the touchpad thing now, which incidentally has quite convenient right- and middle-click.
19:41:29 <dmwit> And I think he's on a laptop, because the desktop Mac keyboards usually do have a home key.
19:41:30 <jfischoff> geekosaur: this our current hypthosesis
19:42:07 <shashwat> geekosaur: It shows last window.
19:42:12 <geekosaur> home should be fn+left arrow on a mac laptop
19:42:32 <geekosaur> shashwat, maybe this is really screen, then?  control-a followed by a in that case
19:42:39 <shashwat> geekosaur: Damn. Yeah, it is.  Never knew.
19:42:59 <mzero> isn't clover-up-arrow = home on a mac keyboard
19:43:30 <mzero> jfischoff: which version of GHC?
19:43:40 <zzo38> How to write environment variable by Haskell program?
19:43:54 <kallisti> System.Environment should have functions related to that
19:43:55 <shashwat> geekosaur: All the ~/.tmux.conf I found on net changed prefix to control+a, easier to use.  I am using the same.
19:43:59 <jfischoff> mzero: HEAD with the iOS patched version of cabal
19:44:03 <mzero> on the mac, if it is GHC 7.4.1, there is a fix for ar not found
19:44:13 <jfischoff> mzero: oh cool
19:44:21 <zzo38> kallisti: I looked they seem to be only reading environment variable, not writing.
19:44:47 <zzo38> I want to call an external program with an environment variable set and then get the output from that program.
19:44:49 <mzero> jfischoff: find the file "settings" -- it is in the usr/lib/ghc   dir
19:45:24 <geekosaur> System.Posix.Env.putEnv or System.Posix.Env.setEnv
19:45:25 <mzero> under your --prefix install dir
19:45:47 <jfischoff> ah
19:45:54 <mzero> as shipped, it seems that settings gets badly set on Mac
19:46:05 <zzo38> geekosaur: I do not have that module in my computer
19:46:07 <mzero> it is probably referencing /Developer
19:46:10 <geekosaur> but, to call an external program, cal instead:  /usr/bin/env VAR=value command
19:46:28 <geekosaur> zzo38, this is Windows?  good luck...
19:46:28 <dmwit> In most shells, VAR=value command is sufficient.
19:46:46 <mzero> but your ar is probably in /usr/bin/ar
19:46:48 <geekosaur> dmwit, but the env command I gave can be used with non-shell stuff too
19:46:49 <dmwit> Oh, I didn't read context, and am wrong as a result.
19:46:52 <dmwit> right
19:47:01 <jfischoff> mzero: yes that is where my ar is
19:47:09 <zzo38> geekosaur: Yes it is Windows I intend it to work on both Windows and on UNIX.
19:47:38 <geekosaur> I think the fact that there are no setters in the system-independent System.Environment tells you about how weel that will go :(
19:48:14 <zzo38> O, there is env in Cygwin.
19:48:41 <tgeeky> and msys
19:48:46 <tgeeky> (which actually comes with GHC)
19:48:59 <jfischoff> mzero: this is very helpful. My settings are pointing to /usr/bin/ar but I think for arm there is a different ar I have to point to. So I know where to change it know :)
19:49:10 <jfischoff> s /know/now
19:49:17 <nexion> what does ghc need to know in order to find the modules installed with cabal? I'm running into "Could not find module `Network.Socket'" when trying to build from some environment I don't fully understand
19:49:24 <tgeeky> you know now, now you kno!
19:49:27 <mzero> jfischoff: perfect!
19:49:31 <zzo38> I could also modify the other program it is calling, so that it is capable to take the input from the command-line or stdin instead of only the environment variable
19:50:10 <geekosaur> nexion, "ghc-pkg list" shows you what packages ghc knows about
19:51:05 <nexion> geekosaur: interesting.. when I run that, I get a lot more packages than when scons runs it
19:52:03 <nexion> 111 vs 34
19:52:25 <geekosaur> this sounds like either scons is ignoring per-user packages or it is using a different ghc installation
19:52:54 <nexion> it seems very strange.. when I run the command scons tells me it's running, it works
19:54:02 <nexion> it's running the same ghc, verified by having it run 'whereis ghc'
19:54:26 <nexion> I'm suspecting environment variables
19:56:05 <zzo38> OK, instead I just decided to modify the other program it is calling, to support input on the command-line as well.
19:56:32 <zzo38> (The program is Internet Quiz Engine, another program I have written myself, in C)
19:56:52 <nexion> I found it
19:57:07 <nexion> export HOME=...
19:57:14 <nexion> :)
20:00:20 <zzo38> If I call readProcess what are the rules for the filename there? Will something like "./filename" always work on Windows and UNIX?
20:04:56 <ski> shachaf : HBC is LazyML
20:21:13 <startling> what should i use for argument parsing?
20:22:09 <zzo38> startling: Do you mean command-line argument?
20:22:17 <startling> yeah.
20:22:33 <zzo38> I happen to like System.Console.GetOpt
20:22:56 <zzo38> You also need System.Environment
20:24:02 <startling> thanks!
20:24:13 <Haskell_Chap> Hello again
20:24:38 <Haskell_Chap> So this is for all the other New Yorkers in the chat
20:25:32 <zzo38> For example:    getOpt RequireOrder [Option "x" [] (NoArg 'x') "Execute", Option "d" [] (NoArg 'd') "Disappear"] <$> getArgs    will work.
20:26:08 <zzo38> Although you may want the list of the options in a separate top-level declaration to use it with usageInfo
20:26:52 <Haskell_Chap> Professor Schenkhart (please excuse me if this spelling is incorrect) of the CUNY graduate center intends to teach a Haskell course this fall (i'll get the course name if anyone is interested)
20:28:03 <Haskell_Chap> I'm a Hunter student, but wouldn't mind a foray into higher abstraction for the sake of Haskell
20:28:14 <Haskell_Chap> Does anyone know if he uses this chat?
20:28:27 <zzo38> I am not sure what ReturnInOrder does, but I only ever use RequireOrder anyways. For the options you use: Option (letters for the option) (names for long option) (specify what argument it takes and what the response should be) (descriptive text)
20:28:53 <Haskell_Chap> anyone from NY?
20:29:16 <zzo38> RequireOrder means switches must come first (if you need a non-switch starting with - you can use -- to separate them), and Permute means the switches do not have to come first.
20:29:19 <clockfort> Haskell_Chap: There are a bunch of us in here from RIT, where there is also a Haskell course
20:29:33 <mzero> I grew up in NY, if that counts :-)
20:29:33 <jmcarthur> Haskell_Chap: i'm in NY, and there are a few others, but i don't know of anybody that i think would be interested in a course
20:30:18 <Haskell_Chap> clockfort: what is IRT, i'm not familiar. Also please tell me about the next Hacker meeting, would like to meet some fellow Haskellers in this city
20:30:27 <zzo38> I am guessing ReturnInOrder means that the switches do not have to come first and that it will keep the order that the non-switches come before or after the switches.
20:30:58 <clockfort> Haskell_Chap: Rochester Institute of Tech. And there are no meetings until next year, everything is suspended for summer.
20:31:15 <geekosaur> put otherwise:  RequireOrder behaves like POSIX getopt, Permute behaves like GNU getopt, ReturnInOrder is kinda halfway in between the two
20:31:19 <jmcarthur> Haskell_Chap: https://groups.google.com/group/nyhaskell
20:31:21 <Haskell_Chap> jmcarthur: do you know about hacker meetups this summer. I would like to connect to the community here. I think it would be good for my development seeing as I am just starting out
20:31:32 <Haskell_Chap> jmcarthur: thanks
20:31:32 <jmcarthur> Haskell_Chap: beat you to it ;)
20:31:50 <jmcarthur> fairly new group, and we don't meet especially often, but occasionally we do
20:32:26 <mm_freak_> absence: think of your application in two layers
20:32:31 <zzo38> geekosaur: Yes, that would be it. I prefer to always use RequireOrder, but if you want to you can check if POSIXLY_CORRECT environment variable is set, if so use RequireOrder otherwise use Permute
20:32:34 <geekosaur> zzo38, ReturnInOrder makes non-option arguments look like arguments to an option, and takes as parameter a function which accepts the raw non-option argument and produces an option record
20:32:42 <Haskell_Chap> well let's meet more! I heard Haskell is great for combinatorics. I would like to code an algo to play bridge
20:33:00 <zzo38> geekosaur: Yes that is what I thought it meant from the type.
20:33:22 <Haskell_Chap> also would like to progress to making a trading system after making algos for games like go, texas hold em' and others
20:33:39 <Haskell_Chap> the distinction between hot an cold games is important though
20:33:49 <mm_freak_> absence: on one layer you have application primitives (game objects, GUI elements, etc.), which take exactly the input they need…  a game object for instance might take all game objects and the world as input, a text box might take a text as input, etc.
20:34:02 <mm_freak_> absence: on the other layer you connect those primitives to form the application
20:34:11 <startling> I get an "ld: warning: could not create compact unwind for .LFB3: non-standard register 5 being saved in prolog" when compiling; the binary seems to work fine. I'm on os x, ghc 7.0.4; any ideas?
20:34:16 <mm_freak_> absence: all in all a wire should never request more information than it actually processes
20:36:01 <geekosaur> startling, it's normal and can be ignored.  (basically a change to the Lion linker; it can simplify some things if they behave like Objective-C, and issues that warning if it runs across something that doesn't behave like Objective-C)
20:36:17 <mzero> startling: that is perfectly normal (alas), and you can safely ignore it
20:36:48 <mzero> when Haskell Platform 2012.2.0.0 comes out next week (we hope), it will use GHC 7.4.1, and that warning will be gone
20:37:05 <mzero> (I can point people at release candidates for that HP if anyone wants to be brave enough to try it)
20:37:06 <tgeeky> mzero: hoooooooo-ray!
20:37:16 <tgeeky> mzero: s/brave/stupid/ <----
20:37:19 <tgeeky> this guy
20:37:19 <Haskell_Chap> jmcarthur: maybe that was more suited to private chat
20:37:37 <mzero> (at least on mac and source tarball - windows release candidate due in a day or two)
20:38:36 <Haskell_Chap> jmcarthur: would you be interested in making game algos? I want to begin with dominos and use the system downtown (w/o a computer of course)
20:38:49 <Haskell_Chap> jmcarthur: to gamble
20:38:53 <startling> geekosaur, mzero thanks!
20:39:23 <mzero> rc4 announcement for HP 2012.2.0.0 here: http://projects.haskell.org/pipermail/haskell-platform/2012-May/001929.html
20:40:20 <mm_freak_> what's this about categorical type systems?  are they more powerful than Co(i)C?
20:40:23 <Haskell_Chap> clockfort: how about you? would you like to make game algos? Bridge, go, or dominos? It would be progressing towards making a trading system
20:40:29 <mzero> should work on Mac OS X 10.6 and 10.7, and with any appropriate Xcode
20:40:40 <Haskell_Chap> clockfort: I almost have 2600 on board
20:40:47 <Haskell_Chap> clockfort: you know 2600?
20:43:09 <Haskell_Chap> Haha, no one is responding to me directly. You may know Haskell, but I guarentee you in the long run, your system will not beat mine because this is a personal interest of mine
20:43:48 <zzo38> 2600? Do you mean the quarterly publication?
20:43:56 <monochrom> I believe your guarantee. I am not even competing.
20:44:11 <zzo38> Haskell_Chap: How much do you want to bet?
20:44:34 <jmcarthur> Haskell_Chap: i participate in the google ai challenge when it happens, but that's enought for me
20:45:30 <Haskell_Chap> 2600 meets at the Citicorp building the first Friday of every month. I want to see all New Yorkers there next meeting. The director of the project is a great guy. His name is Vermont (VT), functional programmer. Though not sure what his professional dev. was.
20:45:55 <Haskell_Chap> there is also a nice publication
20:46:13 <Haskell_Chap> very sophisticated
20:46:28 <jmcarthur> Haskell_Chap: i recommend that you take this to #haskell-blah since it's not really on topic here
20:48:54 <Haskell_Chap> zzo38: I'm not in the interest of betting. I'm just starting out in truly appreciating math and programming; if you get to know me you might come to understand why. But I do believe in though is the power of open source development and collaboration for the greater good
20:49:08 <Twisol> I'm writing an implementation of the Telnet protocol as my first real Haskell project. How do I tell what namespace(s) my modules should go in?
20:49:43 <zzo38> I also believe in though is the power of open source development and collaboration for the greater good, and I also like mathematics, too.
20:50:02 <Haskell_Chap> moving to #haskell-blah >>>
20:51:51 <clockfort> I think you mean >>=    :-)
20:52:15 <mzero> Twisol: you can just choose!  After all, as an application, your modules will never collide with any others
20:52:34 <mzero> Many people choose their project name as the top of their module space
20:52:44 <zzo38> If you are making a standalone program rather than a library, I suggest using "Main." as the top. This is what I do, at least.
20:53:04 <mzero> so, say you are building FooTelnetPro  then your modules would be like   FooTelnetPro.Options and FooTelnetPro.Sockets
20:53:08 <Twisol> mzero: It's not an application though, it's supposed to be a general implementation of the Telnet protocol. RFC 854.
20:53:35 <zzo38> Twisol: If it is supposed to be a library, then perhaps Network.Protocol.Telnet should be the namespace?
20:53:55 <mzero> or just Network.Telnet
20:54:28 <tgeeky> anyone know what's involved with allowing djinn to understand recursive types?
20:54:35 <tgeeky> @djinn-add data Tree a = L a | N (Tree a) a (Tree a)
20:54:35 <lambdabot> Error: Recursive types are not allowed: Tree
20:54:49 <Twisol> Okay. Any reason to prefer one over the other? And is there a general rule of thumb for finding the best place for a library?
20:55:25 <monochrom> the Turing test is involved in allowing djinn to understand recursive types
20:55:38 <tgeeky> monochrom: that sounds intractable then
20:55:47 <tgeeky> because I'm an idiot
20:55:48 <monochrom> yes, it is that bad
20:55:58 <monochrom> no, you are not an idiot
20:56:04 <tgeeky> well, that's debatable :O
20:56:16 <zzo38> Perhaps idiotic in some things and not in others
20:56:34 <tgeeky> I certainly am smart enough to know I shouldn't be trying to prove Turing wrong :O
20:57:02 <Mathnerd314> > let f x = case (cast x) of { Just 1 -> 1; Just False -> 2; Just Nothing -> 3 } in [f 1, f False, f Nothing]
20:57:03 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
20:57:03 <lambdabot>         against inferred type ...
20:58:20 <JEntrep> How quickly could a Mathematician pick up Haskell?
20:58:23 <zzo38> That doesn't work; it could work with a macro, if Haskell supported these kind of macros, but it cannot work like that
20:58:49 <zzo38> JEntrep: Probably like another programming language, except that if you know mathematics it helps a bit in Haskell
20:58:56 <nand`> JEntrep: depends on the lifting strength of the mathematician in question
20:59:00 <monochrom> very quickly at first, then very slowly and frustratedly
20:59:18 <JEntrep> zzo38, Good, thats what I was hoping for from Haskell. :)
20:59:22 <zzo38> I program in Haskell because I like mathematics
20:59:23 <JEntrep> monochrom, :/
20:59:42 <nand`> I learn mathematics because I like programming in Haskell
20:59:45 <JEntrep> Its why I would like to take up Haskell
21:00:01 <zzo38> JEntrep: Do you know some things about category theory, and some other areas of mathematics?
21:00:03 <monochrom> very quickly at first because [ x^2 | x<-[1..10], even x ] looks pretty natural
21:00:35 <nand`> monochrom: then frustratingly once GHC's brain explodes?
21:00:35 <monochrom> very slowly and frustratedly later because [x | x<-[1..], x<10] does not terminate as expected
21:00:36 <JEntrep> zzo38, Not extensively but yes I know some basic Categories. :p
21:01:39 <Twisol> For all it knows, it could take a nosedive later in the sequence. ;D
21:01:40 <zzo38> JEntrep: In Haskell, you will see a class Functor but it is only for endofunctors on the (->) category. There is also Monoid, Monad, and so on, which correspond to those mathematical structures.
21:02:11 <zzo38> monochrom: But isn't it lazy?
21:02:11 <JEntrep> zzo38, Ah...I did hear Category Theorists helped work on Haskell?
21:02:33 <monochrom> it is lazy. that doesn't help
21:02:45 <zzo38> But there are some problems, such as, Functor is not a superclass of Monad and join (usually called mu in mathematics) is not a class method of Monad
21:02:46 <nand`> > sum $ [ x^2 | x <- [1..], x < 10 ]
21:02:48 <Twisol> zzo38: it has indeterminite length - it doesn't know that everything after a certain point will always fail the predicate
21:02:49 <lambdabot>   mueval-core: Time limit exceeded
21:03:13 <nand`> > sum $ map (^2) [1..9]
21:03:14 <lambdabot>   285
21:03:26 <monochrom> I see that some of you are true mathematicians, too :)
21:03:29 <zzo38> Twisol: I know that.
21:03:55 <Twisol> *shrug* :)
21:04:05 <mzero> Twisol: just look at other things on Hackage that are similar - I see most protocols directly under Network - I don't think Network.Telnet would be unreasonable
21:06:05 <startling> Twisol: oh hai
21:06:16 <Twisol> startling: Hallo!
21:06:53 <zzo38> I often write Haskell codes on paper, too.
21:06:58 <startling> Twisol: i meant to ask, since we were talking about parsing stuff: have you ever seen ometa?
21:07:55 <Twisol> startling: I have! Never looked into it beyond what I initially saw on HackerNews, but it seemed interesting enough.
21:09:00 <JEntrep> I am curious though
21:09:12 <JEntrep> Is Haskel implemented in SaaS anywhere?
21:09:28 <Twisol> Like what Heroku does for other languages, you mean?
21:09:34 <JEntrep> Idk
21:09:59 <JEntrep> I'm just looking for examples of Haskell in Client-Server actions. :p
21:10:56 <nand`> Haskell servers are fun to write
21:11:16 <JEntrep> Sarcasm?
21:11:20 <nand`> no
21:11:20 <mzero> since I write all my GUI's as web pages... all my haskell programs are servers!
21:11:31 <JEntrep> :)
21:12:02 <zzo38> I generally don't write GUI programs
21:12:48 <nand`> JEntrep: haskell servers, even using the low level APIs, are made easy because of Haskell's powerful threads. You can just indefinitely call forkIO to fork a read/reply loop for every new connection
21:13:35 <greymalkin> Agh... my head won't stop thinking "object acting like function" while I'm reading about Functor
21:13:44 <arbn> Yeah. Even coming from Twisted, Haskell is easier.
21:13:55 <JEntrep> nand so you can relax with how strict you make your code your saying?
21:14:06 <JEntrep> "strict"
21:14:26 <nand`> I'm not sure what you mean by that question
21:14:33 <jmcarthur> JEntrep: you just code the way you would have before you learned that too many threads is bad
21:14:41 <nand`> ^
21:14:50 <JEntrep> ohhh
21:15:06 <startling> is there a general api for haskell, like wsgi for python? or does everything use scgi/fastcgi/whatever?
21:15:09 <zzo38> And then, can you send message between the threads?
21:15:11 <JEntrep> I'm not all familiar with threading
21:15:13 <startling> web api, that is
21:15:13 <JEntrep> :/
21:15:17 <raadad_> hey guys
21:15:18 <jmcarthur> zzo38: that's one way
21:15:32 <arbn> greymalkin: How is a functor like an object?
21:15:34 <Twisol> Haskell threads seem a little bit like actors...
21:15:42 <mzero> startling: there are several different API's -- but they are richer like wsgi
21:15:51 <nand`> zzo38: I tend to use MVars, mainly because I've never experimented with other methods
21:15:54 <raadad_> how would i write a function that would traverse a list and apply a function to it, and return true if all results were true, and false if any were false
21:15:55 <jmcarthur> Twisol: they aren't any more like actors than any other kinds of threads, as far as i can tell
21:16:04 <nand`> but that's less sending messages and more accessing common data
21:16:07 <zzo38> raadad_: all
21:16:11 <mzero> raadad_: that function already exists in the prelude
21:16:13 <mzero> is this homework?
21:16:26 <raadad_> no, i want to write it in coffeescript
21:16:30 <raadad_> but id ont knwo what to togoogle
21:16:40 <raadad_> so i thought i would ask the purists
21:16:44 <mzero> @src all
21:16:44 <startling> raadad_, it's pretty trivial
21:16:44 <lambdabot> all p =  and . map p
21:16:45 <raadad_> thanks guys
21:16:57 <zzo38> Ask they who understands coffeescript
21:17:03 <greymalkin> arbn: "Functor" is (as I learned it in C++) a class which overloads the '()' operator and acts like a function... used a lot in templates. -- In haskell, "Functor" is something different.
21:17:07 <mzero> but that won't work in JS/CS
21:17:22 <raadad_> most of the programm coffeescript imperativly( including me) i want to tchange that
21:17:53 <greymalkin> And the closest I've been able to get is "Functor is designed to map the internal  type 'a' to 'b' within a container"
21:17:59 <zzo38> Yes, in Haskell, the class Functor is for endofunctors on (->) category where if you have (f x) and a function (x -> y) then you can make the function (f x) to (f y) satisfying certain laws
21:18:03 <startling> raadad_, for x in myarray: if x is false, return False ... return True
21:18:11 <Twisol> raadad_: You may want to check out Underscore.js, it implements a number of functional-style methods.
21:18:20 <zzo38> greymalkin: But, yes that is basically what it is, although it is not always containing values
21:18:39 <nand`> the way I visualize functor is “structure-preserving map”, structure preserving because fmap id = id
21:18:42 <greymalkin> Actually, writing it out like that just made it a bit clearer...
21:18:55 <raadad_> CS is built on underscroe, thanks guys
21:19:01 <raadad_> startling, good start, but that wont work
21:19:08 <zzo38> nand`: Yes that too
21:19:12 <startling> raadad_, why not?
21:19:20 <Twisol> greymalkin: The rubber duck technique strikes again. :)
21:19:40 <raadad_> as soon as there is a true value it will return,
21:19:46 <raadad_> or does the ... prevent that
21:19:52 <greymalkin> Twisol: I want to get that reference... rubber duck technique?
21:19:55 <startling> raadad_: the ... is my unindent
21:20:03 <Twisol> greymalkin: http://en.wikipedia.org/wiki/Rubber_duck_debugging
21:20:03 <raadad_> oh ok
21:20:07 <raadad_> thnkas dude, i appreciate it
21:20:12 <raadad_> i wanted to avoid a for loop :P
21:20:22 <raadad_> but thats clean enough
21:20:24 <startling> raadad_, why
21:20:33 <startling> Twisol, so, no more dcpu?
21:21:01 <raadad_> becuase i want to see how to do it functionally,
21:21:16 <Twisol> startling: I haven't felt in the mood for a little while, and I have an internship coming up. Besides, I fell behind as soon as Notch released the new revision.
21:21:31 <greymalkin> Twisol: Ahah! Pair programming!
21:21:34 <zzo38> And then once you know Functor, you can know Monad too; it is a Functor having return to make it out of a single value, and join to make (f (f x)) to (f x), for example   fmap succ "Hello" = "Ifmmp"   and   join [[1,2,3],[4,5],[6]] = [1,2,3,4,5,6]
21:21:35 <nand`> raadad_: the functional way would be a map composed with a fold
21:21:36 <raadad_> ii appreciate the help, and i will apply your example, thanks dudes
21:21:41 <startling> Twisol: hey me too!
21:21:48 <Twisol> greymalkin: Pretty much ;)
21:21:51 <startling> Twisol: not the internship thing, but everything else
21:21:53 <zzo38> And then there is >>= which does fmap and join together, which is a very common thing to do
21:22:02 <nand`> :t \f -> foldl (&&) True . map f
21:22:02 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
21:22:30 <zezikaro> Twisol lol
21:22:37 <startling> raadad_, may make sense to implement it with an "any_equals" function
21:22:47 <zzo38> So, for example     [1,4,2] >>= \x -> [0..x] = [0,1,0,1,2,3,4,0,1,2]
21:22:54 <startling> raadad_, and then it'd be any_equals(False, mylist)
21:23:06 <zzo38> Now hopefully you can understand the Functor and Monad?
21:23:24 <raadad_> thats what i will od :D
21:23:26 <raadad_> *do
21:23:39 <startling> raadad_, but you're going to need a for somewhere in there
21:24:46 <Twisol> Is there a formal way to do a fold that aborts halfway (like 'break' in other languages), or is that best left to explicit recursion?
21:25:16 <zzo38> Twisol: You can use the Either monad
21:25:27 <zzo38> So, if you want to continue you do Right and if you want to stop you do Left
21:25:30 <nand`> or Maybe
21:25:48 <Twisol> Ah. Hrm.
21:25:52 <zzo38> nand`: But then you cannot stop with a value
21:26:01 <nand`> indeed
21:26:26 <raadad_> damn !,
21:26:31 <Twisol> using Maybe would be more like an imperative loop, and Either like a fold that only went part way?
21:26:39 <greymalkin> zzo38: Oh, sweet! I just did that a while ago (without that syntax) to solve a least-common-multiple problem... by combinding a "make factors" function, mapped, sorted, nub'd, then I used a foldl to achieve what probably works as a join.
21:26:48 <nand`> @hoogle (a -> b -> Maybe a) -> a -> [b] -> Maybe a
21:26:49 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
21:26:49 <lambdabot> Data.Foldable foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
21:26:49 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
21:26:57 <raadad_> im trying to stop myself from solving problems the :normal way
21:27:15 <raadad_> so i can appreciate why its done the funcitonal way
21:27:49 <zzo38> So you can just use foldM or foldlM
21:28:10 <nand`> which incidentally works for both Maybe and Either e
21:28:28 <zzo38> nand`: Well, yes it would work with any monad
21:28:31 <Twisol> Rather clever. Thanks.
21:29:10 <zzo38> greymalkin: Can you describe what it was?
21:30:58 <zezikaro> Hi, does anyone know why my 'toUpper' doesn't work
21:31:07 <hpaste> Greymalkin pasted “Silly LCM solver” at http://hpaste.org/69120
21:31:09 <zezikaro> 'learn you a haskell for great good' as an example with map toUpper list
21:31:15 <zezikaro> and it doens't work in ghci :S
21:31:26 <nand`> > map toUpper "obey"
21:31:27 <lambdabot>   "OBEY"
21:31:58 <Twisol> zezikaro: can you explain in what way it isn't working?
21:32:03 <greymalkin> zzo38: That was my "I'm not through the Functor section of learn-you-a" way to solve the least common multiple.
21:32:31 <greymalkin> And ski might notice I've already broken my promise to myself ... not to use '$'
21:32:37 <zezikaro> 'Not in scope toUpper'
21:32:41 <zzo38> greymalkin: Learn-you-a-Haskell does not discuss join, but with the list monad, join is the same as concat.
21:32:50 <zzo38> There are also other functions for dealing with lists.
21:33:02 <zzo38> And map is the same as fmap with lists.
21:33:24 <Twisol> zezikaro: import Data.Char ?
21:33:52 <mzero> zezikaro: in ghci, type    :m + Data.Char
21:34:00 <Twisol> greymalkin: What's wrong with ($)?
21:34:05 <zezikaro> "No instance for (Num [Char])
21:34:09 <mzero> that brings that module into scope -- much like import would in a source file
21:34:21 <greymalkin> Twisol: Mental blockage I had last night.
21:34:22 <zezikaro> oh hm
21:34:29 <zzo38> I have made a better ($) in Prelude.Generalize
21:34:42 <nand`> zzo38: defined as?
21:34:45 <zezikaro> Twisol Howcome I had to import data.char ?
21:35:06 <greymalkin> I hadn't yet encountered function composition notation
21:35:09 <mzero> because toUpper isn't part of the Prelude (the autmoatically loaded module)
21:35:19 <Twisol> zezikaro: Because toUpper isn't part of the Prelude, which consists of mostly the most general and useful functions.
21:35:37 <zezikaro> >t:toUpper
21:35:42 <zezikaro> > t:toUpper
21:35:43 <lambdabot>   Couldn't match expected type `[SimpleReflect.Expr]'
21:35:43 <lambdabot>         against inferre...
21:35:55 <Twisol> > :t toUpper
21:35:56 <lambdabot>   <no location info>: parse error on input `:'
21:36:01 <mzero> :t toUpper
21:36:02 <lambdabot> Char -> Char
21:36:08 <Twisol> I don't know the special things for this channel >_>
21:38:39 <raadad_> i have implemented map and fold
21:38:49 <raadad_> so now i can implement an all function :D
21:39:23 <startling> raadad_: it'll be less efficient than it has to be, though
21:39:42 <Twisol> I think if you just used fold, you'd be going over everything, even if there's something that doesn't match at the very beginning.
21:39:49 <startling> yeah.
21:39:58 <startling> (unless you implement Either)
21:40:00 <raadad_> true , but i will understand the concepts more
21:40:01 <Twisol> something like that Either map… yeah
21:41:03 <Twisol> though to be honest, implementing an Either container in Javascript would be a lot less efficient than it is in Haskell anyways
21:41:05 <nand`> How do I enable GHC extensions in GHCi again?
21:41:47 * mzero wonders why everyone always jumps to download the 64-bit version of GHC/HP -- for most programming, the 32-bit version is faster and more efficient
21:42:49 <Twisol> mzero: would guess it's so that the software matches up to what your processor uses. I don't know if that's a good thing or not, but it sounds like plausible rationale.
21:44:17 <mzero> it isn't -- even on a 64-bit capabilty Intel CPU, the 32-bit version runs faster and with less memory
21:44:26 <greymalkin> Twisol: I don't know your exact problem, but my first instinct was to use 'takeWhile' to make the loop terminate at the right time.
21:44:43 <nand`> (Never mind my previous question)
21:45:08 * hackagebot attoparsec 0.10.2.0 - Fast combinator parsing for bytestrings  http://hackage.haskell.org/package/attoparsec-0.10.2.0 (BryanOSullivan)
21:45:41 <Twisol> greymalkin: Nice, I didn't know about that one. My problem is that I want to be able to interrupt my Telnet stream reader if something happens such that the remaining input needs to be reprocessed before being read again.
21:45:57 <Twisol> (i.e. having a compression option turned on, such that the remaining input needs to be decompressed.)
21:46:42 <BMeph> raadad_: I hope you implemented map using fold, that should be fun, easy, and blow people's minds! ;)
21:46:46 <greymalkin> Oh... Hmm.. I/O... haven't gotten there yet (though I'm a comms junkie at heart, so I've been itching to skip ahead)
21:46:55 <arbn> mzero: Yeah. Unless you don't have 32-bit libs installed, it'd be better to assess how much you actually need to address.
21:47:26 <Twisol> greymalkin: I'm not even working at the IO level yet, actually.
21:47:45 <Twisol> greymalkin: Just assuming I have a list of Word8's (unsigned char basically) and folding over those.
21:48:44 <mzero> arbn: true, but I'm looking at Mac download stats - and they have the 32-bit libs!
21:49:01 <nand`> :set prompt "λ "   -- my .ghci is now complete
21:49:34 <greymalkin> Twisol: An infinite list, I assume?
21:50:59 <zzo38> IO is also a monad, where (IO x) means some I/O action to perform with a response of type x. And then that response can be used with fmap, join, >>=, and so on.
21:51:10 <raadad_> yeah i did bmeph
21:51:13 <Twisol> greymalkin: Not necessarily - I haven't thought too much about the ramifications of that yet. Right now I'm just doing readTelnetString [0xFF, 0xFD, 200, 1, 2, 3, 4, 5] Plaintext
21:51:22 <startling> Twisol, have you seen attoparsec?
21:51:34 <raadad_> gotta love CoffeesScript, :D
21:52:01 <zzo38> fmap means affect the response some function (do not affect the action). join means if the response is another I/O action, perform that one after the first one that results in that response, and use that result. >>= mean you can decide what do next from the response.
21:52:02 <jfischoff> so I screwed up my package database, and have to versions of template haskell 2.7.0.0, one depends on containers 0.4.2 and one on 0.5.0. How can I fix things?
21:52:15 <arbn> I think one could only love CoffeeScript in comparison with JavaScript. :P
21:52:19 <Twisol> startling: Kind of. I didn't think it would be a good fit because most of Telnet is streaming, minus the 2/3-byte command sequences. Of course I could've misunderstood attoparsec.
21:52:47 <startling> Twisol, i think the point of attoparsec is to work on streaming data
21:52:54 <startling> though perhaps i'm misremembering
21:53:15 <Twisol> startling: I assumed it was for streaming data containing the protocol, not streaming data within the protocol.
21:53:24 <Twisol> (like reading pieces of a WebSocket frame from the wire)
21:53:31 <zzo38> arbn: There are things I don't like about CoffeeScript
21:53:32 <Twisol> i'll take another look at it regardless
21:53:39 <mzero> jfischoff: do you want one but not the other? you can hide the offending one
21:53:44 <mzero> or remove it
21:53:46 <zzo38> Although there are things I dislike about JavaScript too
21:53:50 <mzero> after unregistering it
21:54:10 <nand`> zzo38: but is there something you dislike about CoffeeScript but like about JavaScript?
21:54:40 <jfischoff> mzero: so I should just go through and hide the ones I don't want, err remove
21:55:01 <hpaste> Twisol pasted “Telnet reader” at http://hpaste.org/69121
21:55:10 <Twisol> ^ is what I have so far of my reader.
21:55:38 <mzero> jfischoff: I'd unregister 'em if you don't need 'em
21:55:53 <jfischoff> mzero: will do
21:56:33 <jfischoff> mzero: finally go the iOS branch working!
21:56:44 <mzero> woot!
21:56:51 <jfischoff> :)
21:57:16 <mzero> that's exciting - I might actually code for iOS if I had that running
21:58:20 <jfischoff> I'm going to spend a day next week in SF or somewhere in the Bay Area to help out haskellers in cafe. Also I'm in this room all day, so I can help you through any issues
21:58:47 <jfischoff> like physically in a coffee shop somewhere
21:59:42 <arbn> You should just tell the people in the same cafe to get on IRC. :P
21:59:49 <mzero> ? You're holding a haskell office hours in a S.F. cafe?
21:59:56 <jfischoff> mzero: yeah
22:00:09 <Twisol> Well that's pretty neat.
22:00:11 <mzero> hilarious - which? when?
22:00:38 <Twisol> Wish i lived closer to SF, all the good tech stuff seems to happen up there. :P
22:00:46 <mzero> I'm down in Mtn. View - I hack in our local cafe, but no one ever asks me Haskell questions
22:01:12 <jfischoff> hehe, I'm in San Mateo but I though SF would be easier for most people but maybe not
22:01:51 <jfischoff> maybe Mountain view instead, depends on the where interested people are, assuming there is at least one person :)
22:02:11 <Twisol> I'm way down in the LA area. XD
22:02:42 <Twisol> I know of one or two Ruby meetups here, but that's it.
22:03:40 <jfischoff> I think there is tens times as many programmers in LA as there are in SF
22:04:05 <mzero> what were you hoping to teach?
22:04:35 <jfischoff> not really teach anything, just help troubleshoot the iOS setup=
22:04:43 <mzero> Another option is to hold a workshop at someplace like Hacker Dojo -- The workshop we organized last year there was packed
22:04:46 <shachaf> mzero: Rumour goes that after next the June meeting, bahaskell is going to move to Mountain View.
22:05:20 <mzero> oh - that'd be nice
22:05:23 <mzero> for me!
22:06:33 <jfischoff> mzero: yeah, maybe a haskell iOS day as a more organized event is the best idea. We get the installation process nailed down by then (maybe)
22:07:06 <zzo38> nand`: Yes there are things I dislike about CoffeeScript but like about JavaScript. I generally prefer the JavaScript syntax, although I dislike the automatic insertions of semicolons and that you need the entire word "function" to make a function
22:09:54 <zezikaro> How do you make applications using haskell?
22:10:01 <nand`> using a haskell compiler
22:10:17 <zezikaro> graphical interfaces i mean
22:10:42 <nand`> the most common way is to use a graphical toolkit like Gtk or wxWidgets
22:11:26 <zezikaro> i'd like to represent a turing machine in an interface somehow
22:11:43 <startling> zezikaro, sdl might have you covered
22:15:33 <zezikaro> startling How does that work?
22:15:40 <zezikaro> it seems to be just like a canvas?
22:17:49 <startling> zezikaro, you could say that
22:17:50 <zzo38> I like SDL with C, I don't know about with Haskell
22:18:00 <startling> sdl came way before canvas
22:18:02 <zezikaro> I don't know c >.<U
22:18:10 <startling> yeah, i've never used it with haskell either.
22:18:17 <zezikaro> lol
22:18:24 <zezikaro> what would you suggest that people have used? :D
22:24:15 <kallisti> zezikaro: openGL bindings might be an option
22:24:26 <kallisti> but you could use SDL as well
22:24:38 <zezikaro> Why is everything so hard in haskell =[
22:24:52 <kallisti> what were you expecting?
22:25:18 <Twisol> it's very formalized and lends itself to a certain mode of thinking
22:25:38 <kallisti> you need to use a GUI toolkit to draw graphics. it's the same as any other language.
22:25:49 <kallisti> http://www.haskell.org/haskellwiki/Applications_and_libraries/GUI_libraries
22:27:02 <jfischoff> is it possible to just blow alway your package database and start over?
22:27:10 <kallisti> yep
22:27:24 <kallisti> you need to delete stuff in your .cabal file, and something in .ghc I believe.
22:27:28 <kallisti> I don't remember exactly which files.
22:27:48 <jfischoff> kallisti: well its good to know its possible ...
22:28:10 <kallisti> I believe you can delete your entire .cabal file (but I would keep your config)
22:29:03 <startling> ooh, concatMap is nice
22:29:14 <kallisti> :t concatMap
22:29:15 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
22:29:16 <kallisti> :t (>>=)
22:29:17 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
22:29:35 <kallisti> what do these types have in common
22:30:17 <kallisti> ah wait maybe I should make it a bit clearer:
22:30:17 <copumpkin> :t flip concatMap
22:30:18 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
22:30:19 <Twisol> seems vaguely like the first two parameters are swapped, but I'm not expert
22:30:20 <kallisti> yes
22:30:20 <copumpkin> :t (>>=)
22:30:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
22:30:21 <Twisol> *no expert
22:30:48 <startling> kallisti: neat
22:30:55 <Twisol> What does the 'forall' mean?
22:31:05 <kallisti> > "hello" >>= replicate 3
22:31:06 <lambdabot>   "hhheeellllllooo"
22:31:23 <startling> Twisol: for any m of type * -> * ...
22:31:34 <Twisol> would that be a kind?
22:31:43 <kallisti> yes.
22:31:52 <startling> err yes
22:32:03 <Twisol> so any type constructor with one parameter?
22:32:12 <kallisti> yep
22:32:15 <Twisol> Interesting.
22:32:48 <kallisti> lambdabot is just being verbose, all of the forall is implied by the rest of the type
22:33:22 <kallisti> but that's the syntax if you want to explicitly quantify variables within a type, for example when using existential types or rank-N types.
22:33:38 <Twisol> which i have no clue about at this stage in my learning. :D
22:35:20 <kallisti> :t id
22:35:21 <lambdabot> forall a. a -> a
22:35:29 <kallisti> just writing "a -> a"  implies the forall a.
22:35:41 <kallisti> similarly,  m a  implies that m :: * -> *
22:35:50 <Twisol> So under what situations do you need an explicit forall?
22:36:25 <kallisti> when you need a rank-N type. for example, you need to enforce that a function passed to a higher-order function is polymorphic
22:37:31 <Twisol> Like maxBounded?
22:37:36 <kallisti> no
22:37:44 <kallisti> myFunc :: (forall a. [a] -> [a]) -> FilePath -> IO [a]
22:37:52 <kallisti> if you omitted the forall
22:37:56 <kallisti> then it would be
22:38:05 <kallisti> myFunc :: forall a. ([a] -> [a]) -> FilePath -> IO [a]
22:38:32 <kallisti> which means that you can only apply the function passed to myFunc on /one/ particular type of lists.
22:38:55 <kallisti> but with the rank-N type you're stating that you want the function to be polymorphic on all lists.
22:39:27 <Twisol> So the difference between passing a function you wrote that only works on [Int], versus a function you wrote that works on any [a]?
22:39:34 <kallisti> well, yes.
22:39:36 <kallisti> except that the second form
22:39:40 <kallisti> also accepts your [a] function
22:40:05 <kallisti> but you can't apply it to 2 different kinds of [a], so to speak.
22:40:06 <Twisol> but the first excludes the [Int] function>
22:40:12 <kallisti> yes.
22:40:20 <Twisol> right, 'a' still refers to the same thing - I got that much from my formal logic class ^_^
22:40:41 <kallisti> I use it to define a strict and lazy IO version of a function
22:40:48 <kallisti> in the filesystem-trees package.
22:41:39 <kallisti> http://hackage.haskell.org/packages/archive/filesystem-trees/0.1.0.1/doc/html/src/System-File-Tree.html#getDir_
22:41:57 <kallisti> getDir_ is the underlying implementation of getDirectory and getDirectory', the first being strict and the second using lazy IO.
22:42:16 <kallisti> so getDirectory = getDir_ unsafeInterleaveIO; getDirectory' = getDir_ id
22:42:52 <Twisol> I see.
22:43:31 <kallisti> I need them to be "polymorphic enough" to apply to multiple different types within my code.
22:44:03 <kallisti> a simpler example would be existential types. are you familiar with typeclasses already?
22:44:10 <Twisol> Is there a second implicit forall around that first form? Recalling from my formal logic class, a variable without an explicit value or a quantifier doesn't make sense.
22:44:35 <kallisti> there's an implicit forall on the outside of the entire type expression that quantifies any type variables that aren't explicitly qualified
22:44:40 <Twisol> Gotcha.
22:44:48 <kallisti> thus why lambdabot is being unnecessarily verbose when it says forall a. a -> a
22:44:49 <Twisol> Yes, I'm familiar with typeclasses to an extent.
22:44:52 <Twisol> *nod*
22:45:11 * hackagebot lambda2js 0.1 - Untyped Lambda calculus to JavaScript compiler  http://hackage.haskell.org/package/lambda2js-0.1 (MatejKollar)
22:46:21 <kallisti> an existential type essentially has a polymorphic field, that can be constrained to a certain typeclass
22:46:29 <kallisti> or rather, its constructor has a polymorphic field.
22:47:13 <kallisti> data SomeNum = forall a. Num a => SomeNum a
22:47:25 <Eduard_Munteanu> That's not quite the same thing.
22:47:40 <kallisti> so the constructor SomeNum takes some a, where a is an instance of the typeclass Num
22:47:45 <kallisti> Eduard_Munteanu: not the same as what?
22:48:14 <Eduard_Munteanu> I read "polymorphic field" as data SomeNum = SomeNum (forall a. a)  or similar
22:48:32 <kallisti> ah, well that's similar isn't it?
22:48:49 <kallisti> there's just a typeclass constraint.
22:48:54 <Eduard_Munteanu> Not quite an existential.
22:49:19 <tmiw> I have to be missing something. Any ideas? http://pastebin.com/LKpC9n5C
22:49:22 <mauke> The paste LKpC9n5C has been copied to http://hpaste.org/69123
22:50:12 * hackagebot PortFusion 1.1.0 - high-performance distributed reverse / forward proxy & tunneling for TCP  http://hackage.haskell.org/package/PortFusion-1.1.0 (CetinSert)
22:50:45 <zezikaro> Does everyone here use Haskell for math related things?
22:50:49 <Twisol> tmiw: I think you're associating the parentheses after 'all' incorrectly
22:51:02 <Twisol> but I'm not certain
22:51:17 <Twisol> newp, I think it's fine, ignore me
22:51:42 <kallisti> Twisol: the difference between   Num a => [a]  and [SomeNum]  is that each SomeNum constructor can contain a different type with a Num instance, whereas  the first type can only refer to one.
22:51:47 <Eduard_Munteanu> kallisti: in fact that's just a rank-n type
22:51:54 <kallisti> Eduard_Munteanu: the second one? yes.
22:52:05 <kallisti> but I'm curious what really makes them different
22:52:06 <Eduard_Munteanu> Yeah, the one I typed above.
22:52:18 <greymalkin> Is there a way to define a generic main on the compiler line?
22:52:24 <Twisol> zezikaro: I'm investigating using it for a websocket server.
22:53:28 <kallisti> Eduard_Munteanu: as in, what's the difference between forall a. Num a => SomeNum a   and SomeNum (forall a. Num a => a)
22:53:34 <greymalkin> Like, I've been working through Euler project problems to get a handle on Haskell; I load the file and tweak it in ghci; the final solution step I assign to "problem".
22:53:52 <kallisti> greymalkin: the main function is the entry point for a Haskell executable
22:53:57 <kallisti> well, it's not really a function.
22:53:58 <greymalkin> I'd like to be able to say: ghc problem01.hs --main 'print problem'
22:54:10 <kallisti> oh
22:54:12 <kallisti> like that..
22:54:32 <Twisol> tmiw: try (all (\v -> (T.length v) > 0) rawVals)
22:54:50 <kallisti> greymalkin: you could use ghci of course
22:55:02 <kallisti> but I don't know of a way to add code to a program on the command line during compilation
22:55:09 <kallisti> other than bash hacks of course. :P
22:55:14 <ClaudiusMaximus> sigh.  spent an hour debugging, and it turned out i had a row index and a column index swapped => meaningless images with interesting glitches
22:55:23 <Eduard_Munteanu> kallisti: the semantics for existentials are different. The quantified variable is associated with the type itself, whereas in the second case you merely say the constructor accepts polymorphic values.
22:55:35 <tmiw> Twisol: that fixed it, thanks!
22:55:44 <Twisol> tmiw: Glad to hear!
22:55:56 <kallisti> Eduard_Munteanu: do they not behave equivalently?
22:56:07 <Twisol> tmiw: all takes a predicate and a list; you were giving it a list of booleans, because you were mapping over the list with your predicate before giving it to all
22:56:23 <tmiw> ah
22:56:31 <Twisol> :t all
22:56:32 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
22:56:45 <tmiw> all id map … probably would have worked, but would have been too verbose
22:56:46 <Eduard_Munteanu> kallisti: mm, no
22:57:15 * tmiw is still learning
22:57:16 <Twisol> tmiw: probably would've, it was just missing that predicate in that case :)
22:57:18 <tmiw> :)
22:57:20 <Twisol> tmiw: so am I :P
22:57:29 <Eduard_Munteanu> In particular the second one isn't useful to abstract over implementations the same way as existentials.
22:57:58 <kallisti> Eduard_Munteanu: so you can't unwrap the constructor and call typeclass methods on the rank-n version?
22:58:03 <greymalkin> Yeah, I'm just working the problems in the same directory I worked them in other languages, and I wanted to check how their execution time compared, but compile time keeps getting in the way of a meaningful result.
22:58:51 <greymalkin> And it's not very DRY to have a directory full of 30 files all with a common line "main = print problem"
22:59:36 <kallisti> Eduard_Munteanu: I'm referring to data SomeNum = SomeNum (forall a. Num a => a)   not the unconstrained forall a. a   example.
23:00:11 <Twisol> greymalkin: Couldn't you build it to an executable first, and then time it?
23:00:32 <strager> :t and
23:00:33 <lambdabot> [Bool] -> Bool
23:00:45 <strager> @src all
23:00:46 <lambdabot> all p =  and . map p
23:01:06 <Twisol> strager: hahah, brilliant
23:01:13 <greymalkin> Twisol: Yeah, but that means going back and adding "main = print problem" to every file.
23:02:02 <greymalkin> Not a problem, per se, just something I thought might have been available/hidden :)
23:02:21 <kallisti> find project_euler_directory -name '*.hs' -exec echo -e '\nmain = print problem' >> {} \;
23:02:58 <Twisol> Can ghc accept an input file from stdin?
23:03:58 <kallisti> unfortunately specifying - doesn't seem to work
23:04:03 <Twisol> Shame...
23:04:37 <kallisti> runghc can
23:04:40 <greymalkin> No, my solution so far has just been 'ghc <problem>.hs -e problem' -- but it doesn't seem to compile
23:04:58 <kallisti> $ echo 'main = print (2 + 2)' | runghc
23:04:58 <kallisti> 4
23:05:12 <Twisol> greymalkin: try throwing in a --make or -O for fun
23:05:26 <zezikaro> <Twisol> zezikaro: I'm investigating using it for a websocket server.
23:05:28 <zezikaro> what does that involve?
23:06:09 <Twisol> zezikaro: no clue yet :) There's a websockets package though, which looks useful.
23:06:34 <kallisti> greymalkin: it looks like -main-is can specify the main function
23:06:39 <Twisol> basically it's like doing sockets code with an augmented socket
23:06:42 <kallisti> -main-is Main.problem
23:06:43 <kallisti> perhaps
23:07:12 <kallisti> but by the time you type that a few times, you've already repeated yourself more than using some bash-fu to put the main at the end of each file. :P
23:07:20 <kallisti> think of all the saved keystrokes.
23:07:37 <Twisol> kallisti: actually, that would be pretty useful if you wanted to keep your Project Euler solutions in one file
23:07:46 <kallisti> that's what I do..
23:07:52 <kallisti> but I just change the main line manually
23:07:58 <kallisti> and move on with my day.
23:08:05 <Twisol> :D
23:09:06 <Eduard_Munteanu> kallisti: no, that'd actually be a polymorphic value
23:09:41 <kallisti> Eduard_Munteanu: I don't understand..
23:10:22 <kallisti> "actually be a polymorphic value" as in the typeclass constraint is ignored, or something else?
23:10:48 <hpaste> “Eduard - Gabriel Munteanu” pasted “Existential vs rank-n in constructor” at http://hpaste.org/69124
23:11:00 <Eduard_Munteanu> kallisti: http://hpaste.org/69124
23:11:13 <Eduard_Munteanu> It's not ignored, but it's not right either.
23:11:37 <kallisti> ...how can you get away with that. :P
23:11:46 <kallisti> that looks like an unsafeCoerce to me.
23:12:18 <Eduard_Munteanu> In fact you can't even build such a value, AFAIU, except undefined stuff.
23:13:00 <Eduard_Munteanu> You need some  foo :: forall a. Show a => a   to begin with
23:13:15 <kallisti> ah rightg
23:13:33 <kallisti> are you sure a :: Int  isn't a type error
23:13:41 <kallisti> something like "could not deduce (a ~ Int)"
23:13:51 <Eduard_Munteanu> (which is much like   forall a. a   or a proof that any type is inhabited)
23:14:17 <Eduard_Munteanu> kallisti: it isn't, in fact you kinda have to specify a type there, otherwise it's ambiguous.
23:14:42 <kallisti> ah I see.
23:15:00 <kallisti> because a is polymorphic
23:15:12 <kallisti> you're just specifying its type
23:15:19 <kallisti> but it's probably just undefined anyway. :P
23:15:22 <Eduard_Munteanu> Yeah, you get to pick the type there.
23:16:05 * kallisti thinks it would be nice if existentials and rank-N types were merges
23:16:06 <Eduard_Munteanu> On the other hand, existentials are more like packing a hidden type together with a value which depends on that type.
23:16:07 <kallisti> *merged
23:16:39 <kallisti> the "hidden type" is implemented as a dictionary of its typeclass methods.
23:16:50 <kallisti> since that's the only thing you know about it really.
23:17:12 <Eduard_Munteanu> Mm, you don't actually need a typeclass constraint (you just need it to do useful stuff with it :D)
23:17:41 <kallisti> in that case wouldn't the rank-N and existential examples exhibit the same behavior?
23:18:00 <kallisti> well, except that you can't pick the type of the existential
23:18:08 <kallisti> oh nevermind
23:18:23 <kallisti> you can actually construct values with non-undefined things in the existential case
23:18:36 <kallisti> but then you can't do anything with them really.
23:18:39 <Eduard_Munteanu> Yeah.
23:18:53 <kallisti> whereas with the rank-N you /only/ get bottom.
23:19:11 <Eduard_Munteanu> Not always, you could have other values wrapped in there.
23:19:44 <Eduard_Munteanu> E.g. consider wrapping   forall a. a -> a
23:19:55 <kallisti> oh, yes.
23:20:03 <kallisti> you can wrap anything sufficiently polymorphic. I didn't consider that.
23:20:32 <Twisol> I grok about 60% of this discussion. I count that as an achievement. :o
23:21:53 <Eduard_Munteanu> To be fair, I'm not clear on the exact semantics of existentials either, for example the exact difference between Haskell's stuff and strong sums/existentials.
23:22:31 <Eduard_Munteanu> (like Agda's  Σ Set ...)
23:23:39 <solrize_> hey to what extent is the ghc runtime shared between concurrent linux processes?  i mean how much memory overhead do i take from running a haskell program if another one is already running?  tx
23:23:58 <Eduard_Munteanu> There an existential is more like a pair of a type and a value whose type depends on that type.
23:24:06 <kallisti> each program is distinct. they don't share memory in any way.
23:24:51 <kallisti> GHC's default backend outputs compiled machine code with the runtime system embedded in.
23:25:58 <zzo38> That makes the program file extremely large
23:26:49 <Eduard_Munteanu> Um, assuming dynamically-linked stuff, don't you get the RTS linked in as a copy-on-write map?
23:27:09 <Eduard_Munteanu> But yeah, static linking is still default I think.
23:27:13 <kallisti> yes and yes
23:28:11 <Eduard_Munteanu> So I guess a lot of that memory is shared.
23:28:28 <solrize_> kallisti, hmm, static linking means duplicating that runtime everywhere?
23:28:59 <solrize_> is there some inherent reason the runtime has to be so big?  jhc's is very small though it doesn't have all the concurrency stuff
23:29:02 <Eduard_Munteanu> solrize_: sounds like it, the linker can't know you're not running different RTSes.
23:29:24 <Eduard_Munteanu> Each program has its own copy in the executable.
23:29:47 <kallisti> Eduard_Munteanu: I'm not familiar with how dynamic linking is implemented. I didn't realize memory sharing would take place between multiple programs that link to the same shared lib.
23:29:49 <Eduard_Munteanu> (whereas in the dynamic linking case the linker resolves them to the same .so)
23:29:50 <solrize_> is there an obstacle to using a .so ?
23:30:07 <solrize_> .so = shared object
23:30:08 <kallisti> you need the RTS shared lib on your system.
23:30:19 <Eduard_Munteanu> solrize_: you need to compile with -dynamic I think
23:30:19 <Twisol> dynamic linking, to my knowledge, refers to mapping another binary image into the current executable's RAM
23:30:26 <kallisti> which an be a problem when distributing for people who don't have it.
23:30:27 <solrize_> ic
23:30:31 <Twisol> those pages often have a copy-on-write functionality enabled
23:30:33 <kallisti> such as: anyone who isn't a Haskell programmer
23:30:57 <solrize_> yeah i don't care much about distributing binaries but if i did, there'd be an installer with the .so
23:31:01 <Eduard_Munteanu> kallisti: yeah, the linux system linker mmaps the .so's once as copy-on-write
23:31:18 <kallisti> ah okay.
23:31:39 <Eduard_Munteanu> So if one program modifies say a global variable, it only needs to duplicate that particular page or so.
23:31:47 <kallisti> I wasn't thinking of shared code.
23:31:56 <kallisti> but yes that counts as shared memory.
23:34:03 * kallisti thinks we could probably come up with a distribution system that installs all the necessary shared libs
23:34:12 <kallisti> for platforms like Windows.
23:34:28 <kallisti> well, not "all" of them, but the ones related to GHC.
23:34:51 <kallisti> but I suppose external dependencies could be handled as well.
23:34:52 <Eduard_Munteanu> Doesn't that exist already?
23:35:30 <Eduard_Munteanu> IIRC, the defaults wrt linking are a bit different on Windows.
23:37:31 <Twisol> It's kind of interesting, coming from an ecosystem (Ruby, Javascript) that doesn't need to worry about static vs. dynamic linking. It's all dynamic.
23:38:44 <Eduard_Munteanu> I don't really know why they picked static linking, maybe to simplify distributing executables.
23:38:57 <kallisti> that sounds like the main benefit to me.
23:39:09 <Eduard_Munteanu> (Although, libc and such are always dynamically linked by default, no?)
23:39:13 <Blockyclock> How can this: http://pastebin.com/yS650HS1 be written so that there's just one f & the D1/D2 check goes through guards?
23:39:30 <kallisti> Eduard_Munteanu: yeah
23:39:41 <shachaf> Blockyclock: It can't, really.
23:39:51 <kallisti> I want to say libgmp is dynamically linked by default, since I've gotten compilation errors involving it.
23:39:54 <shachaf> You can write a helper function for it.
23:39:57 <Blockyclock> okay
23:39:59 <mzero> Blockyclock: why would you want to? do yo ubelieve it would be faster somehow?
23:39:59 <shachaf> @ty fromMaybe
23:40:00 <lambdabot> forall a. a -> Maybe a -> a
23:40:05 <shachaf> Er.
23:40:07 <shachaf> @ty maybe
23:40:08 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
23:40:27 <Eduard_Munteanu> kallisti: oh, yes, that's a licensing issue no?
23:40:30 <qtplatypus> Blockyclock: Why would you wish to?
23:40:53 <Blockyclock> well, guards are a lot more convenient & pretty much of the time
23:41:07 <Blockyclock> eg you can have a where over guards if they're in the same definition
23:41:19 <kallisti> Eduard_Munteanu: GMP is under the LGPL so I'm not sure if that's an issue.
23:41:20 <mzero> uhm, well, in this case they'd be more code & less convenient
23:41:24 <shachaf> I think of pattern matching as much nicer than guards.
23:41:36 <shachaf> Pattern-matching is compiler-verified; guards just use Bools.
23:41:38 <Eduard_Munteanu> Hm, I don't remember the exact reason.
23:41:43 <shachaf> Bools are the devil. :-(
23:41:53 <Twisol> Why's that?
23:41:57 <qtplatypus> You could write it as a case statement.  Which isn't much better.
23:42:11 <Blockyclock> :-(
23:42:32 <shachaf> Blockyclock: Anyway, since your D is equivalent to Maybe, you could take inspiration from Maybe for this.
23:42:35 <zzo38> What do you dislike about Bools? I like the Bool type using the bool function
23:42:50 <Eduard_Munteanu> :t maybe
23:42:52 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
23:43:00 <zzo38> Just use Maybe instead of D, use a type synonym if needed
23:43:00 <shachaf> So if you had a function like fromMaybe, you could say 100 * fromMaybe 1 d, or something like that.
23:43:06 <greymalkin> @src GetLine
23:43:07 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
23:43:12 <shachaf> zzo38: Bools aren't compiler-verified.
23:43:19 <augur> so i have a question ey
23:43:23 <shachaf> You have to not make mistakes with them.
23:43:27 <augur> well maybe i should take this elsewhere
23:43:31 <Eduard_Munteanu> > maybe 100 (* 100) $ Just 2
23:43:31 <qtplatypus> zzo38: What is the bool function?
23:43:32 <lambdabot>   200
23:43:36 <Eduard_Munteanu> > maybe 100 (* 100) $ Nothing
23:43:37 <lambdabot>   100
23:43:38 <greymalkin> @src getLine
23:43:38 <lambdabot> getLine = hGetLine stdin
23:43:41 <qtplatypus> augur: Just ask your question.
23:43:42 * shachaf (along with most of the rest of humanity) is not very good at not making mistakes.
23:43:47 <Blockyclock> okay, thanks
23:43:47 <greymalkin> Okay, that's what I was expecting.
23:43:50 <Haskell_Chap> hey all
23:43:58 <Haskell_Chap> http://www.computingatschool.org.uk/index.php?id=the-challenge
23:44:04 <augur> qtplatypus: nah, itll get drowned out and isnt strictly Haskellish
23:44:09 <Haskell_Chap> I assume all americans know?
23:44:17 <zzo38> qtplatypus:  bool :: x -> x -> Bool -> x; bool x _ False = x; bool _ x True = x;    It is defined in the module Prelude.Generalize in the package "prelude-generalize"
23:44:28 <kallisti> Eduard_Munteanu: unless LGPL is more restrictive than I thought
23:44:31 <Eduard_Munteanu> augur: don't let that get in your way though ;)
23:44:40 <Haskell_Chap> :)
23:45:04 <qtplatypus> zzo38: Ooh, I like it.  Saves me having to write if' all over the place which I've been doing.
23:45:25 <zzo38> This module makes head polymorphic, so it can be used with Maybe as well as [] and other things
23:45:37 <zzo38> And a lot of other generalizations and other stuff
23:45:57 <kallisti> zzo38: you should generalize boolean algebras.
23:46:11 <zzo38> It also changes $ to infixl
23:47:26 <mzero> what? it changes the associativity of $?
23:47:29 <mzero> that's nuts
23:48:08 <zzo38> mzero: If you don't like it, you can reset it after importing, but I did it that way so that you can put multiple arguments
23:48:28 <zzo38> And now tail can be used with any MonadLogic; not only [] and (LogicT m) is MonadLogic, but so is such things as (StateT s []) and so on.
23:48:44 <mzero> no thanks, I'll just stick to the Prelude
23:49:51 <qtplatypus> And it has "swap" <#
23:50:33 <zzo38> Yes that too
23:52:02 <zzo38> You may need -XExtendedDefaulting in order to effectively use this
23:52:14 <Eduard_Munteanu> Left-associative ($) makes some sense at times.
23:56:50 <yitz> Haskell_Chap: not too many americans know about it in general, but here in the haskell world they do
23:57:13 <yitz> Haskell_Chap: since simon pj is one of the leading figures in that initiative
