00:03:22 * hackagebot hspec-discover 0.0.3 - Automatically discover and run Hspec tests  http://hackage.haskell.org/package/hspec-discover-0.0.3 (SimonHengel)
00:08:05 <solirc> Does anyone have an idea what's wrong with my description field for hspec-discover?
00:08:06 <solirc> http://hackage.haskell.org/package/hspec-discover
00:08:19 <solirc> for some reason the code block is not marked up properly
00:11:35 <blackdog> solirc: the layout, you mean? not exactly sure
00:11:49 <blackdog> thanks for the lib, btw - it's exactly what i've been looking for for ages
00:11:57 <blackdog> life is far too short to list all your tests
00:12:11 <solirc> blackdog: :)
00:12:41 <solirc> blackdog: seems to me that the parser is bogus
00:12:50 <blackdog> i wrote tbc with pete gammie ages ago, but it ended up too hard keeping everything in sync and it's bitrotted to hell and back
00:14:32 <solirc> blackdog: looks interesting
00:15:27 <blackdog> solirc: the approach might be possible now with cabal-dev ghci
00:15:42 <blackdog> but running ghci in a wrapper isn't really tenable without
00:20:15 <solirc> blackdog: I use ghci for doctest with no big issues, but the user is required to provide all the ghc options.
00:20:26 <solirc> or in what issues did you ran?
00:23:11 <blackdog> solirc: not having exactly the same options as is set in the cabal file
00:23:47 <blackdog> that's sort of the killer app for me - if you spend two minutes debugging your tests because they're running in a different environment as your code, that's two minutes too many.
00:27:29 <ohgod> .
00:27:48 <solirc> blackdog: yes, that is true
00:29:06 <solirc> the parser issue is triggered by { .. }
00:29:15 <solirc> it does not like curly braces
00:29:28 <taruti> Which library would be ideal for an unpacked vector (elements may be appended in a mutable way to the end) of Int64s with very fast index based access?
00:29:47 <solirc> I wonder if I could just provide html character references
00:34:03 <Viktor> Hi guys, could anyone help me to solve this problem ?
00:34:18 <Viktor> complement_strand :: [Char] -> [Char]
00:34:29 <Viktor> complement_strand "aggt" => "tcca"
00:35:40 <blackdog> Viktor: first come up with a function that takes a Char to a Char
00:35:51 <blackdog> then think about how you could apply that function to every element of a list...
00:37:12 <Viktor> thx, hopefully it works
00:39:05 <blackdog> solirc: which parser issue?
00:39:09 <blackdog> sorry, missed it before
00:40:01 <solirc> blackdog: The reason why my documentation got screwed on Hackage
00:40:18 <solirc> you can not include any curly braces in cabal's description field
00:40:23 <solirc> not even in a code block
00:40:51 <solirc> if you include both { and }, the parser produces rubbish
00:41:09 <solirc> if you only include {, cabal will complain
00:41:30 <blackdog> oh, right.
00:41:41 <solirc> so it seems to me, that it is not even a Hackage issue
00:42:05 <solirc> I'll probably open a Cabal ticket for that as soon as the tickets have been migrated over to GitHub
00:45:28 <moebius_eye> > [3..]
00:45:30 <lambdabot>   [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,...
00:45:50 <xil> hey everyone. General programming question but since I'm here so often I thought I'd ask y'all. I can't remember what you respectively call a pair of functions where one is the one actually called by the programmer, but the second is called from the first and basically does all the work. Anyone know what I mean? It's on the tip of my tongue.
00:45:58 <moebius_eye> How can I generate an infinite list of 3 ?
00:46:05 <blackdog> xil: worker/wrapper?
00:46:06 <moebius_eye> I tried [3..3]
00:46:11 <xil> repeat 3
00:46:15 <xil> > repeat 3
00:46:16 <lambdabot>   [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,...
00:46:25 <moebius_eye> thank you very much, xil
00:46:41 * moebius_eye gusta #haskell :) 
00:46:42 <fmap> > [3,3..]
00:46:42 <xil> blackdog: ah thanks. Not what was on the tip of my tongue but I think that's what I was thinking of, =P
00:46:43 <lambdabot>   [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,...
00:46:51 <xil> moebius_eye: no prob =]
00:47:43 <xil> fmap: much more concise
00:48:23 * hackagebot hspec-discover 0.0.4 - Automatically discover and run Hspec tests  http://hackage.haskell.org/package/hspec-discover-0.0.4 (SimonHengel)
00:48:53 <hpaste> mikeplus64 pasted “cabal install wxc” at http://hpaste.org/68569
00:49:02 <mikeplus64> anyone know the solutoin to this?
00:49:17 <mikeplus64> i want to try out reactive-banana-wx, not going to have much luck without a working wx
00:54:52 <xil> moebius_eye: btw, just for good measure you may want to know about replicate
00:54:57 <xil> > replicate 3 5
00:54:57 <lambdabot>   [5,5,5]
00:56:22 <xil> @src replicate
00:56:23 <lambdabot> replicate n x = take n (repeat x)
00:56:28 <xil> wow
00:56:48 <blackdog> solirc: what are SRC CUR DST in hspec-discover?
00:56:58 <blackdog> trying to get it working with a new project
01:00:40 <xil> @src map
01:00:41 <lambdabot> map _ []     = []
01:00:41 <lambdabot> map f (x:xs) = f x : map f xs
01:02:13 <Starfire> @src iterate
01:02:14 <lambdabot> iterate f x =  x : iterate f (f x)
01:16:25 <solirc> blackdog: It is the original source file, the file where the current content is, and the file where the content should be put
01:17:10 <solirc> blackdog: http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/options-phases.html#pre-processor
01:17:45 <solirc> blackdog: Did you invoke hspec-discover on its own?
01:33:25 * hackagebot certificate 1.2.3 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-1.2.3 (VincentHanquez)
01:36:28 <womb> Hi!
01:36:46 <womb> I was one of the europe 1 to kill diablo on normal >_<
01:41:17 <t7> god damn there is a package for everything
01:41:34 <t7> when will it be my turn for hackage fame and fortune
01:43:59 <deggis> t7: instant fame and fortune for person, who upgrades hackage to have commenting and maybe other 2010 things
01:44:42 <t7> ah like user posts and stuff?
01:45:43 <deggis> yes. i think there could be some ongoing efforts, but i'm anxious for having those :)
01:46:27 <amcik> can you help me?
01:46:56 <deggis> in many cases (i think) it would easier people's lives a lot if the packages could have user posted comments right on the site (like how to fix build problems with something that's nowdays common)
01:48:12 <amcik> can you speak german
01:48:25 * hackagebot hspec-discover 0.0.5 - Automatically discover and run Hspec tests  http://hackage.haskell.org/package/hspec-discover-0.0.5 (SimonHengel)
01:48:45 <solirc> blackdog: just pushed an other version of hspec-discover to Hackage, that includes a fix for the issue you reported
01:49:55 <amcik> complement_strand "aggt" => "tcca"
01:50:53 <solirc> amcik: is this homework?
01:52:45 <fmap> his mate was here a couple hours ago with the same problem
01:52:50 <amcik> no its work at home for testing my haskell knowledge
01:52:56 <fmap> so i guess yes, this is homework
01:53:14 <solirc> amcik: Don't get it.
01:54:30 <amcik> this function is my experiment for me
01:55:03 <solirc> amcik: have you had a look at "lean you a Haskell"
01:55:33 <solirc> amcik: After you have read that, you'll probably come up with a solution ;)
01:55:50 <solirc> amcik: s/lean/learn
01:55:51 <fmap> how "tcca" is a complement of "aggt" btw?
01:55:59 <fmap> don't get it
01:57:06 <deggis> sounds like some dna sequence
01:57:18 <amcik> becoz its a chain in DNA... you know adenin matches with timin anf guaninn with cytosine
01:57:45 <fmap> ah
01:57:50 <fmap> interesting
01:58:28 <amcik> complement_strand :: [Char] -> [Char]
01:58:44 <amcik> complement_strand "aggt" => "tcca"
01:59:28 <amcik> how can i build a function or shuld i do a list comprehension ???
02:00:19 <t7> > let complement_strand "aggt"  = "tcca" in complement_strand "aggt"
02:00:20 <lambdabot>   "tcca"
02:01:35 <amcik> thx dude :D
02:02:01 <Cale> complementStrand = map complement
02:02:07 <fmap> amcik: first you need a function which takes 'a' and gives 't', … of type ∷ Char → Char
02:02:31 <fmap> then map it over the string
02:05:32 <amcik> thx everbody i musst go
02:05:35 <amcik> :)
02:05:50 <t7> fmap: does your client do unicode replacement symbols?
02:08:41 <fmap> t7: no
02:59:42 <hpaste> marco pasted “xmonad.hs” at http://hpaste.org/68574
03:49:10 <womb> is there any rspec style testing tool / dsl for haskell ?
03:49:19 <womb> with DSL aka
03:49:32 <womb> describe "terror server"
03:49:41 <womb>   it "should serve terror"
03:49:44 <womb> etc ?
03:50:24 <quicksilver> apparently there is
03:50:24 <quicksilver> http://hackage.haskell.org/package/hspec-1.1.0
03:50:27 <quicksilver> how horrific.
03:51:29 <womb> is it good or just someone weekend project that nobody is using ?
03:52:00 <womb> pro
03:52:01 <womb> thanks :D
03:52:33 <alpounet> it seems to work fine but people generally use other testing libraries
03:52:47 <quicksilver> I have no idea, I'd never heard of it until today.
03:52:58 <quicksilver> it's had many revisions at least.
03:56:22 <t7> :t (>>=)
03:56:23 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
03:57:18 <womb> i saw QuickTest and it is nice
03:57:48 <womb> maybe i should use only it
03:57:58 <womb> i have some fears about testing I/O parts
03:58:37 * hackagebot yesod-rst 0.2.1 - Tools for using reStructuredText (RST) in a yesod application  http://hackage.haskell.org/package/yesod-rst-0.2.1 (PascalWittmann)
04:19:33 <Axman6> @hoogle showHex
04:19:34 <lambdabot> Numeric showHex :: Integral a => a -> ShowS
04:27:02 <XexonixXexillion> Is trifecta useable yet?
04:28:15 * Axman6 starts up doestrifectahavedocsyet.com
04:28:55 <quicksilver> its' edwardk-ware so it is surely useable.
04:29:02 <quicksilver> it only remains to find out how to use it.
04:30:18 <aleator_>  Stoopid question: Is it possible to draw a sensible CT diagram of homomorphism rule for applicative functors?
04:33:51 <XexonixXexillion> is there any way to make GHC spit out the libraries that it links with?
04:34:00 <hpc> try -v
04:35:41 <XexonixXexillion> correction; the libraries and their paths (I need to pass them to another linker)
04:36:09 <bitonic> quicksilver, XexonixXexillion: the interface is actually pretty simple, similar to other parser combinators libraries. But don't try to decipher types like this: http://hackage.haskell.org/packages/archive/trifecta/0.51.0.1/doc/html/Text-Trifecta-Parser-Prim.html
04:41:59 <quicksilver> bitonic: if only GHC was a little bit smart and we didn't need to manually unroll CPS-style for performance, I guess.
04:45:52 <fmap> Are there tricks for understanding such libraries with no documentation before heat death of the universe?
04:46:27 <Axman6> read the source?
04:47:19 <quicksilver> read the source / just try stuff
04:48:21 <quicksilver> ask the author is also possible :)
04:48:29 <bitonic> quicksilver: uhm what do you mean? the performance wouldn't be affected by newtypes, would it?
04:48:38 <quicksilver> bitonic: no
04:48:52 <quicksilver> bitonic: I'm referring to the (a -> ErrState e -> ErrLog e -> Bool -> Delta -> ByteString -> It Rope r) bits
04:49:12 <quicksilver> they are used where it might be more natural to define a datatype which holds those fields
04:49:21 <bitonic> quicksilver: oh, ok.
04:49:28 <bitonic> uhm.
04:49:37 <quicksilver> but GHC generates better code if you unroll the datatype into a function which returns a result
04:49:40 <quicksilver> CPS-style
04:49:40 <bitonic> so you're saying that a curried function is faster than a datatype?
04:49:46 <quicksilver> exactly that, yes.
04:49:57 <bitonic> that's surprising.
04:50:12 <quicksilver> no allocation, and slightly different strictness analysis
04:50:20 <quicksilver> I don't understand the details myself.
04:51:03 <quicksilver> I first became aware of it in Neil Mitchells uniplate paper, where he indicated that CPS-transforming the key methods yielded a really substantial performance boost
04:51:16 <bitonic> I would have guessed the opposite
04:51:22 <quicksilver> but he didn't invent the idea - it's GHC implementation folklore which he picked up elsewhere
04:51:22 <bitonic> that packing the arguments together would have been faster
04:51:47 <hpc> does that change if you make the data type strict/funboxed?
04:52:45 <quicksilver> I don't believe so hpc
04:52:54 <quicksilver> but I think edwardk is the one to ask :)
04:55:20 <tgeeky> dmwit: ping
04:55:20 <adamt> Is anybody aware of up to date libvlc bindings for Haskell?
04:55:29 <tgeeky> adamt: probably don't exist
04:55:44 <hpc> @hoogle vlc
04:55:44 <lambdabot> No results found
04:55:53 <tgeeky> adamt: using the "I would have heard of it, if they existed" metric
04:55:57 <tgeeky> hpc: the media player
04:56:01 <tgeeky> oh, nm
04:56:02 <hpc> yeah, i know
04:56:04 <adamt> Too bad.
04:56:18 <tgeeky> adamt: make the bindings, and turn that frown, upside down!
04:57:15 <adamt> tgeeky: I struggle just doing casual things with Yesod, I'm not sure I'm prepared writing bindings yet. :>
04:57:52 <hpc> and maintaining the bindings
05:00:07 <alpounet> @google libvlc haskell
05:00:09 <lambdabot> http://www.ubuntuupdates.org/package/getdeb_apps/natty/apps/getdeb/libvlc-dev
05:00:10 <lambdabot> Title: UbuntuUpdates - Package "libvlc-dev" (natty 11.04)
05:00:20 <alpounet> yeah, not bindings
05:00:22 <alpounet> no*
05:00:37 <adamt> Not to be rude, but i *did* google :)
05:00:49 <i1126> bitonic: Hey, I have a question to you.. we've talked about this already once, but my logs don't reach that far. I try to install xmobar from github, using runhaskell configure/build/install.. I want to use it with all extensions, so I configure it with all extensions.. but it does not work.. I remeber from our talk a long while back that I have to install it with all extensions, too, but I don't remember how.. can you give me the same advice once again? ;)
05:01:55 <adamt> Oh well, I hope i can find something else, I sure as hell isn't going to poke to mplayer in slave mode again.
05:05:00 <fmap> i1126: Doesn't cabal install xmobar.cabal --flags="all_extensions" just work?
05:07:05 <i1126> fmap: Thank you!
05:07:24 <i1126> fmap: That was exactly what I was looking for. I did not know the way to use cabal for installing locally build packages!
05:09:04 <adamt> So basically there's no resonable way of playing media with Haskell. That's a bit sad.
05:09:27 <liweiagm> why so many variable named xs
05:09:47 <adamt> liweiagm: it's just like using i and j for counters in other languages.
05:10:21 <liweiagm> does it have speciall meaning
05:10:38 <adamt> Not really, it's usually just a list of something.
05:11:27 <liweiagm> sometimes i see `ys`
05:13:18 <hpc> liweiagm: it's pluralization
05:13:23 <hpc> "duck" => "ducks"
05:13:26 <hpc> "x" => "xs"
05:13:54 <hpc> you have probably seen stuff like
05:13:58 <hpc> head (x:xs) = x
05:14:25 <hpc> which is, call the first element of the list x, and the remainder is xs ("list of xs")
05:16:03 <alpounet> adamt, the binding to ffmpeg may help you
05:18:31 <saiam> [D
05:19:30 <adamt> alpounet: Thanks. Sadly it hasn't been updated for 2,5 years and the documentation seems lacking. =/
05:20:09 <alpounet> adamt, well actually check the patch-tag repo for the ffmpeg-tutorials package or smth like that
05:20:22 <alpounet> he ported the C examples of the tutorial to Haskell
05:20:42 <alpounet> and it seems it includes an audio/video player using SDL for the display
05:22:03 <alpounet> (tutorial05 i'd say, tutorial02 just includes display i think, haven't checked the others)
05:22:58 <t7> someone should do bindings to sfml
05:23:18 <alpounet> t7, it's been started actually
05:23:20 <alpounet> a while back
05:23:35 * adamt just wants something that can play all sorts of audio-codecs. ;)
05:23:54 <t7> i hope your not on windows
05:24:38 <alpounet> adamt, then you're better off writing a libvlc binding indeed P
05:24:39 <alpounet> :P *
05:25:11 <adamt> alpounet: That's what i fear ^
05:25:13 <adamt> * ^^
05:26:10 * t7 didnt know libvlc was a thing :O
05:26:44 <adamt> t7: I didn't either until recently, but it's probably awesome enough to warrant a small project. :)
05:28:12 <crdueck> i'm trying to find a path through a binary tree (not binary search), i tried a simple greedy algorithm at first but it could not find the correct path. I'm not too familiar with other search algorithms, could someone suggest some alternatives which would be better able to find a global maximum path that the greedy search is missing?
05:28:17 <t7> whos berengal on github?
05:28:41 <Axman6> crdueck: maximum how?
05:29:06 <crdueck> Axman6: each node has a value, finding the maximum sum of the path down the tree
05:29:14 <mux> project euler material
05:29:19 <crdueck> mux: indeed
05:29:33 <crdueck> i dont want an answer obviously, just a better algorithm
05:29:36 <Botje> crdueck: dynamic programming.
05:29:52 <mux> dynamic programming isn't even needed here
05:30:34 <Botje> well, that's what i'd call it without giving too much away
05:31:09 <crdueck> Botje: i'll search around for dynamic programming then
05:32:23 <mux> that reminds me of how much I hate that term
05:33:16 <rainman1985> Can anyone explain or point me to a resource regarding the type inference rules in Haskell? I am reading that there are 3 rules (Function application, type instantiation and abstraction) that Haskell uses to infer the signature of a function
05:33:26 <Botje> crdueck: you are trying a greedy search because going down all paths will take too long.
05:33:31 <rainman1985> however I don't perfectly understand them
05:33:43 <rainman1985> the notation is somehow confusing
05:33:51 <Botje> crdueck: dynamic programming is about exploiting shared solutions to subproblems
05:34:49 <Botje> rainman1985: what notation? the one used in the typing rules?
05:35:27 <rainman1985> No, actually.
05:35:36 <rainman1985> one sec..
05:35:56 <rainman1985> https://www.dropbox.com/s/zp8gugdj45t4kjq/haskell.pdf
05:35:59 <rainman1985> if you scroll down
05:36:20 <rainman1985> to page 2 in the PDF, in the appendix, you can see them
05:36:42 <hpc> t7: oh, i know berengal
05:36:47 <Botje> oh, that's nice. dropbox gives a preview
05:36:48 <hpc> he very rarely pops up in here, even
05:37:09 <rainman1985> Yep
05:37:54 <hpc> he's in norway
05:38:16 <Botje> rainman1985: I think the Cons_x mean "constraints"
05:38:20 <Taneb> How is Kleisli pronounced?
05:38:34 <rainman1985> Yes
05:38:55 <Botje> rainman1985: so can you point out the confusing bits of rule 1?
05:39:22 <crdueck> Botje: i guess you are familiar with the euler problem i'm trying to solve? i dont see how "exploiting shared solutions to subproblems" applies here.
05:39:25 <hpc> kl-eye-slee, i think
05:39:50 <Botje> crdueck: what do, for example, the left five paths have in common?
05:40:29 <crdueck> they share the same root?
05:40:36 <Botje> exactly
05:41:00 <Botje> not only the root, but a path down that root
05:41:15 <Botje> so you want to avoid walking that shared path  more than once
05:41:53 <rainman1985> I'm not sure I'm interpreting rule 1 correctly
05:41:57 <XexonixXexillion> Taneb: I'd be inclined to agree with hpc on the pronunciation
05:42:17 <rainman1985> I mean, if the function f has the Constraint f, then its argument e must of type Constraint f, correct?
05:42:24 <crdueck> Botje: i think i understand, thanks
05:42:38 <rainman1985> must be*
05:42:53 <Taneb> Thanks!
05:43:34 <Botje> rainman1985: skip the part to the left of the big arrow for now
05:43:45 <Botje> if f :: \sigma \to \tau and e :: \sigma, then f e :: \tau
05:44:09 <Botje> The monkeying around with Cons stuff is to propagate constraints upwards, i guess
05:44:10 <rainman1985> oh i see
05:44:39 <Botje> if you had (g x) e, then the (g x) inference would give you additional constraints that you need to take into account when you solve e and (g x) e
05:45:41 <rainman1985> yes. so it is basically saying that the type of the first argument inferts the type of the only argument of the function signature.
05:46:33 <rainman1985> The return type of the function must be inferred in some other way then, since it is assumed as known in the first rule.
05:47:29 <mauke> that's rule 3, I think
05:47:53 <Botje> indeed.
05:48:30 <rainman1985> What about rule 2?
05:48:34 <Botje> also, you are given all the types for functions applied in the example
05:48:54 <Botje> so you won't need rule 3 for problem 3
05:49:01 <Botje> well, once.
05:49:03 <Botje> for repeatAsNum
05:49:32 <Botje> rainman1985: rule 2 says you're allowed to plug in a type in place of a type variable.
05:51:47 <rainman1985> Hm, can you explain it a little better? I still don't quite understand it.
05:52:03 <Botje> if you have a type Maybe a, where a is a polymorphic type variable
05:52:13 <Botje> you are allowed to instantiate it to Maybe Int, replacing a by Int
05:52:42 <rainman1985> I see
05:52:59 <Botje> this is necessary if you need to typecheck id 5 (id :: a -> a, 5 :: Int)
05:54:03 <rainman1985> Perfect, thanks you so much, that was a big help
05:54:27 <saml> hey i'm ronery
05:54:30 <saml> wrong chan
05:55:26 <Botje> glad to help
05:55:31 <Botje> crdueck: let me know if you figure it out
05:58:10 <manjunaths> Hello
05:58:27 <manjunaths> I am trying to learn some haskell, and I have this question
05:58:40 <manjunaths> I have a function, like this
05:58:57 <manjunaths> mkL::[Int]
05:59:04 <manjunaths> mkL = do return 1
05:59:08 <quicksilver> (that's not a function)
05:59:08 <manjunaths> so that works
05:59:33 * adamt wonders how that works
05:59:44 <quicksilver> it's a funny way of writing mkL = [1]
05:59:48 <manjunaths> how do I make it do something like ? mkL = do return 1,2,3,4,5
05:59:57 <quicksilver> mkL = [1,2,3,4,5]
06:00:09 <quicksilver> you don't want to use either 'do' or 'return' here.
06:00:09 <adamt> you don't want to write "do return foo" me thinks.
06:00:13 <manjunaths> No, I want to use do and return
06:00:18 <Botje> manjunaths: why?
06:00:22 <quicksilver> for what reason do you want to use them?
06:00:23 <adamt> No you don't. :)
06:00:40 <manjunaths> Because [] is a monad and I should be able to do that no ?
06:00:49 <manjunaths> No just it should work
06:00:54 <quicksilver> no it shouldn't.
06:00:57 <manjunaths> I don't know how
06:01:02 <quicksilver> return puts a value into the monad (loosely)
06:01:03 <Botje> return for [] will give you *one* element.
06:01:09 <adamt> manjunaths: Maybe you should just say what you want to achieve. :)
06:01:10 <quicksilver> for lists, it gives you a single element
06:01:18 <Botje> you could do something like do { x <- [1..5]; return x}
06:01:19 <manjunaths> Why ? return for the list monad should give me list no ?
06:01:30 <quicksilver> manjunaths: no. return for the list monad gives you singletons.
06:01:31 <Botje> but that is exactly the same as writing [1..5] directly.
06:01:39 <Botje> @src return []
06:01:39 <lambdabot> Source not found. You speak an infinite deal of nothing
06:01:42 <Botje> @src [] return
06:01:42 <lambdabot> return x    = [x]
06:01:56 <hpc> @src [] (>>=)
06:01:57 <lambdabot> xs >>= f     = concatMap f xs
06:02:03 <hpc> @src concatMap
06:02:04 <lambdabot> concatMap f = foldr ((++) . f) []
06:02:07 <saml> manjunaths, mkL = [1,2,3,4,5]
06:02:28 <arcatan> foo = do [1,2,3,4,5]
06:02:30 <manjunaths> ah...interesting
06:02:40 <hpc> manjunaths: try writing [1,2,3,4,5] with a list comprehension
06:02:51 <hpc> then realize that comprehensions translate directly to do-notation
06:03:03 <manjunaths> I don't want to use the [], I want to construct the list without any []
06:03:22 <hpc> > 1:2:3:4:(return 5) -- massively cheating
06:03:23 <lambdabot>   [1,2,3,4,5]
06:03:36 <Botje> manjunaths: you cannot do that.
06:03:49 <manjunaths> hpc Hmmm don't use :, can something like this be done
06:03:53 <hpc> no
06:04:02 <solirc> manjunaths: enumFromTo 10 20
06:04:05 <manjunaths> mkL = do 1 >>= 2 >>= 3 >>= return 4
06:04:14 <hpc> manjunaths: that won't work
06:04:16 <Axman6> > let xs = 1 : xs in xs
06:04:17 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
06:04:24 <saml> [1,2,3,4,5]  what's wrong with this?
06:04:26 <hpc> the list monad is not even remotely what you want for this
06:04:42 <saml> don't be a java programmer. you don't need monad factory for every list
06:04:44 <manjunaths> I am trying to learn monads
06:04:45 <hpc> there's no possible list monad that does what you want
06:04:56 <arcatan> > 1:2:3:4:5:mzero
06:04:57 <lambdabot>   [1,2,3,4,5]
06:05:13 <quicksilver> manjunaths: the list monad is about computations which return multiple results
06:05:18 <quicksilver> its' about "all possible combinations"
06:05:29 <quicksilver> it's not remotely about "trying to avoid writing [] and ,"
06:05:31 <saml> i am not sure if learning monads is helpful in programming in haskell
06:05:52 <hpc> manjunaths: learn the definition of (>>=) and return, for Maybe
06:06:04 <Taneb> > let foo x = [x `div` 2; x * 2] in do {x <- [1,2,3]; return (foo x)}
06:06:04 <manjunaths> hpc, yes
06:06:04 <hpc> learn what they do for IO (since you can't really learn those definitions)
06:06:04 <lambdabot>   <no location info>: parse error on input `;'
06:06:08 <adamt> I'm new with Haskell, i try to avoid monads :>
06:06:14 <hpc> learn what they do for something like Reader
06:06:14 <Taneb> > let foo x = [x `div` 2, x * 2] in do {x <- [1,2,3]; return (foo x)}
06:06:15 <lambdabot>   [[0,2],[1,4],[1,6]]
06:06:27 <manjunaths> hpc, yes
06:06:27 <hpc> and ONLY THEN worry about Monad itself
06:06:35 <manjunaths> hpc, ok
06:06:42 <hpc> and skip [], it's a very hard to conceptualize instance
06:06:43 <quicksilver> > do x <- [1,2,3]; y <- [4,5,6]; guard (even (x+y)); return (y-x);
06:06:43 <lambdabot>   [4,2,4,2]
06:06:49 <Taneb> > let foo x = [x `div` 2, x * 2] in do {x <- [1,2,3]; y <- foo x; return (foo y)}
06:06:49 <lambdabot>   [[0,0],[1,4],[0,2],[2,8],[0,2],[3,12]]
06:07:16 <hpc> and don't let IO trick you into thinking Monad is magic
06:07:22 <Taneb> (quicksilver's examples are probably better)
06:07:35 <crdueck> Botje: would dijkstra's algorithm be an appropriate choice for this problem?
06:08:05 <hpc> also, read the LYAH chapter
06:08:06 <hpc> @where lyah
06:08:07 <lambdabot> http://www.learnyouahaskell.com/
06:08:28 <saml> learn ghc manual and start programming
06:08:41 <hpc> heh
06:09:05 <saml> http://www.haskell.org/ghc/docs/latest/html/users_guide/
06:09:32 <saml> it's a widely used haskell compiler. i woudl recommend using that compiler.
06:09:57 <quicksilver> but that manual won't help you much in learning haskell
06:10:09 <quicksilver> it's a compiler manual, not a language guid
06:10:12 <saml> never mind. yah
06:10:22 <saml> i thought the manual included haskell introduction
06:12:41 <manjunaths> @src (>>=)
06:12:41 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
06:13:06 <manjunaths> @src [] (>>=)
06:13:06 <lambdabot> xs >>= f     = concatMap f xs
06:13:27 <hpc> concatMap f xs = concat (map f xs)
06:13:51 <hpc> it has an ugly expanded definition in reality though
06:13:55 <hpc> for speed
06:19:15 <manjunaths> Ok, I get it
06:19:26 <manjunaths> return for list gives me a singleton
06:19:37 <manjunaths> :t (:)
06:19:37 <lambdabot> forall a. a -> [a] -> [a]
06:19:50 <quicksilver> correct, manjunaths
06:20:09 <manjunaths> and then I've to use (:) to make more of them
06:20:13 <manjunaths> Cool
06:20:40 <manjunaths> Thanks guys
06:21:24 <manjunaths> @src [] (:)
06:21:24 <lambdabot> Source not found. It can only be attributed to human error.
06:21:30 <manjunaths> @src (:)
06:21:30 <lambdabot> Source not found. Wrong!  You cheating scum!
06:21:36 <arcatan> :)
06:21:59 <nand`> (:) isn't actually a Haskell definition iirc because it has illegal syntax, but it goes something like
06:22:10 <nand`> data [a] = a : [a] | []
06:22:24 <nand`> (or data [] a = (:) a [a] | [] )
06:22:37 <Taneb> I thought it was okay for data's to have infix constructors if the constructor began with :
06:23:43 <Taneb> But other than that, it's illegal
06:23:49 <Taneb> Thinking about it
06:24:06 <quicksilver> that is correct, Taneb
06:24:09 <nand`> well, for one; you can't define anything related to [] or : because it throws an “Illegal binding of built-in syntax” error
06:24:11 <quicksilver> the : part of list is almost-standard
06:24:24 <quicksilver> it just happens to be reserved
06:24:27 <nand`> but even without that I think the [a] stuff is illegal
06:24:30 <quicksilver> the [] is completely non-standard
06:24:32 <manjunaths> @src (cons)
06:24:32 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
06:24:35 <nand`> of course the [1,2,3] syntax is hard-defined built-in sugar
06:24:54 <nand`> that's pretty much impossible to emulate with a custom data type analog to []
06:24:58 <quicksilver> data List a = a :+ List a | Nil
06:25:09 <quicksilver> is the kind of thiing you can define yourself.
06:26:34 <t7> whats the url for the website where i exchange my lambdabot karma for bitcoin?
06:27:07 <nand`> that would be an awful website :(
06:27:14 <nand`> karma should not be materialized
06:28:04 <vraid> nand`: luckily, bitcoins are immaterial ;)
06:28:44 <nand`> true, but can be exchanged for “hard” currency
06:29:41 <vraid> i always wondered why people would buy bitcoins
06:29:52 <vraid> it doesn't seem a very safe currency, in terms of demand
06:29:57 <nand`> anonymity
06:30:08 <t7> its great for drug dealers
06:30:13 <bitonic> -blah
06:30:16 <t7> not so great for buyers
06:30:57 <Botje> crdueck: you will still have to walk all the paths, i think
06:33:31 <crdueck> Botje: then i think i'm still stuck, should i memoize the paths i've already walked?
06:33:52 <Botje> crdueck: getting there.
06:34:03 <Botje> crdueck: but you don't know how far you've walked a given path already
06:34:13 <vraid> t7: true, drug trading could keep it alive
06:34:31 <crdueck> start from the bottom?
06:34:47 <mizu_no_oto> What happens when you have an array being lazily computed with listArray have an element be simultaneously demanded from two different sparks working in parallel?
06:35:05 <vraid> the risk of losing your money buying bitcoins being smaller than the risk of being caught buying drugs
06:35:53 <mizu_no_oto> i.e. on two different cores.
06:36:15 <int-e> mizu_no_oto: usually one arrives first, replaces the thunk with a black hole, and the second one blocks on that black hole.
06:36:56 <int-e> mizu_no_oto: very occasionally, both sparks will continue evaluating the same thunk.
06:38:55 <hpc> i feel like i am about to accidentally implement FRP
06:39:56 <Botje> crdueck: yes :)
06:39:58 <ClaudiusMaximus> mizu_no_oto: see also -feager-blackholing flag for ghc http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/using-smp.html#parallel-compile-options
06:40:00 <mizu_no_oto> Would that explain why my program which is using memocombinators to try to do floyd-warshall in parallel actually slows down after I put more than a few threads in?  It's a quad core, so it should have 8 hyper-threads.  But I see almost no benefit after N3, and at N7 it actually starts taking more time than N6
06:40:40 <Axman6> Accidently, a wild FRP appears
06:40:48 <hpc> heh
06:41:22 <mizu_no_oto> I'm using "`using` parBuffer numCapabilities rdeepseq" to parallelize it, as CladiusMaximus suggested yesterday.
06:41:54 <mizu_no_oto> Mostly, I'd like to know why it doesn't scale well with additional cores
06:43:18 <ClaudiusMaximus> it could be a non-scalable algorithm on some inputs - you might end up with a long chain of sparks each waiting for the previous to complete
06:45:13 <quicksilver> mizu_no_oto: I very much doubt it.
06:45:36 <quicksilver> that is, I very much doubt what you observe has anything to do with very rare cases of double-evaluation.
06:46:16 <quicksilver> my guesses would be either (1) there just aren't enough applicable thunks for the sparks to work on at times or (2) something else is the bottleneck, like cache bandwidth.
06:46:28 <hpc> at worst, double-evaluation would duplicate work on other cores, yes?
06:46:35 <quicksilver> right
06:46:42 <quicksilver> hyper-threading only works for certain workloads
06:46:42 <hpc> that doesn't sound like something that would produce a slowdown between 6 and 7
06:46:57 <quicksilver> bear in mind that you don't *really* have those extra cores
06:47:07 <quicksilver> you just have the ability to double up on the cores in certain specific cases
06:47:16 <quicksilver> when waiting for certain things.
06:47:36 <quicksilver> parallel performance is hard to analyse :-(
06:48:55 <mizu_no_oto> So it might be that beyond N4, hyperthreading doesn't really help, and it runs into some problems with cache misses or something when I try to go to N7
06:49:17 <mizu_no_oto> Which would make sense because N4, N5, and N6 are all almost equal
06:49:19 <hpc> quicksilver: that makes sense
06:50:15 <quicksilver> he's gone
06:50:27 <quicksilver> in particular hyperthreading doesn't give you access to more memory bandwidth
06:50:38 <quicksilver> so if you're memory constrained the extra threads can't actually progress.
06:50:54 <quicksilver> (but you can make yourself slower because of the synchronisation/communication overhead)
06:51:23 <hpc> cool
06:51:41 <hpc> http://fc08.deviantart.net/fs71/f/2010/323/a/f/the_more_you_know_by_stathisnhx-d33639v.png
06:52:50 <womb> is it cool to ask for a date girl from the office ? different team same office
06:52:58 <womb> is it pure and functional
06:53:46 <hpc> womb: it's non-strict
06:53:58 <hpc> you won't actually go on a date, because the thunk isn't forced until you ask her to marry you
06:55:08 <nand`> of course, marriage is strict
06:56:17 <adamt> womb: (sorry for the language) Don't shit where you eat. Only date her if you're sure it's not going to get awkward, or you are prepared to get a new job. ;)
06:56:59 <hpc> methinks this should be in -blah
07:03:59 <absence> http://hpaste.org/68578 <- in this contrieved example, the details of the file format exists in both put and get, making it hard to maintain and easy to introduce bugs. is it possible to abstract the structure away or something? is there a module/pattern/trick for it?
07:14:00 * hackagebot fixplate 0.1.3 - Uniplate-style generic traversals for optionally annotated fixed-point types.  http://hackage.haskell.org/package/fixplate-0.1.3 (BalazsKomuves)
07:14:46 <mparodi_> Hello
07:14:52 <mparodi_> whatis the problem with this definition: http://paste.kde.org/480068
07:14:53 <mparodi_> ?
07:15:22 <mparodi_> it's an example I found in a Haskell book but somehow it doesn't work well
07:15:57 <mparodi_> fastFib 501 is fine (7031219417428144879), fastFib 502 is wrong (-6555735915413952335)
07:16:03 <Axman6> what do you mean by well?
07:16:15 <Axman6> mparodi_: the Int values are overflowing
07:16:19 <mparodi_> ahm
07:16:24 <copumpkin> use Integer, not Int
07:16:31 <mparodi_> ok, let's see
07:17:05 <mparodi_> good, thank you!
07:17:21 <Axman6> > let fibSetp :: (Integer, Integer) -> (Integer, Integer); fibStep (a,b) = (b,a+b); loop 0 = (1,1); loop n = fibStep (loop (n-1)) in loop 501
07:17:23 <lambdabot>   The type signature for `fibSetp' lacks an accompanying binding
07:17:33 <Axman6> > let fibStep :: (Integer, Integer) -> (Integer, Integer); fibStep (a,b) = (b,a+b); loop 0 = (1,1); loop n = fibStep (loop (n-1)) in loop 501
07:17:34 <lambdabot>   (36501474072363421101223707790647935599608158150145549785274782936680019936...
07:17:47 <Axman6> > let fibStep :: (Integer, Integer) -> (Integer, Integer); fibStep (a,b) = (b,a+b); loop 0 = (1,1); loop n = fibStep (loop (n-1)) in fst $ loop 501
07:17:48 <lambdabot>   365014740723634211012237077906479355996081581501455497852747829366800199361...
07:17:50 <mparodi_> accompanying binding ?
07:18:13 <mparodi_> ah, it was an error, never mind
07:18:16 <Axman6> mparodi_: also it's very likely that fastFib 501 is wrong. that answer above is the correct answer
07:18:31 <mparodi_> what's the problem with the code?
07:18:41 <mparodi_> it's shown in the book The Craft of Functional Programming
07:18:48 <Axman6> fibonacci numbers grow fast
07:19:02 <deech> Hi all, I'm trying to understand tagless final interpreters. I've looked at Oleg's tutorials and they are a little opaque for me. Can anyone point me to something more basic?
07:19:11 <Axman6> also that's a pretty terrible way to compute that, you can do it tail recursively much more nicely
07:19:19 <mparodi_> Axman6, by te way, with 500 it was overflowed as well, not fastFib 50 is HUGE
07:19:37 <mparodi_> 500 *
07:19:55 <Axman6> > let fib !a b 0 = a; fib a b n = fib b (a+b) (n-1) in fib 0 1 50
07:19:56 <mparodi_> fastFib 501
07:19:56 <lambdabot>   12586269025
07:19:56 <mparodi_> 365014740723634211012237077906479355996081581501455497852747829366800199361550174096573645929019489792751
07:20:03 <tromp_> @let fib a b = a: fib b (a+b)
07:20:04 <lambdabot>  Defined.
07:20:15 <Axman6> > let fib !a b 0 = a; fib a b n = fib b (a+b) (n-1) in fib 0 1 20
07:20:16 <lambdabot>   6765
07:20:19 <Axman6> > let fib !a b 0 = a; fib a b n = fib b (a+b) (n-1) in fib 0 1 30
07:20:21 <lambdabot>   832040
07:20:25 <Axman6> > let fib !a b 0 = a; fib a b n = fib b (a+b) (n-1) in fib 0 1 40
07:20:26 <lambdabot>   102334155
07:20:36 <Axman6> > let fib !a b 0 = a; fib a b n = fib b (a+b) (n-1) in fib 0 1 50
07:20:37 <lambdabot>   12586269025
07:20:40 <Axman6> > let fib !a b 0 = a; fib a b n = fib b (a+b) (n-1) in fib 0 1 500
07:20:41 <lambdabot>   139423224561697880139724382870407283950070256587697307264108962948325571622...
07:20:51 <Axman6> > let fib !a b 0 = a; fib a b n = fib b (a+b) (n-1) in fib 0 1 501
07:20:52 <lambdabot>   225591516161936330872512695036072072046011324913758190588638866418474627738...
07:20:57 <Axman6> > let fib !a b 0 = a; fib a b n = fib b (a+b) (n-1) in fib 0 1 502
07:20:58 <lambdabot>   365014740723634211012237077906479355996081581501455497852747829366800199361...
07:21:27 <mparodi_> > let fib !a b 0 = a; fib a b n = fib b (a+b) (n-1) in fib 0 1 50000
07:21:28 <lambdabot>   107777348930729747802790388551194808296251067694115797849023092100327447353...
07:21:36 <mparodi_> > let fib !a b 0 = a; fib a b n = fib b (a+b) (n-1) in fib 0 1 500000
07:21:40 <lambdabot>   mueval-core: Time limit exceeded
07:21:45 <mparodi_> alright
07:22:40 <mparodi_> (I just found fastFib 0 is 1 in the example I pasted, it's wrong too)
07:24:10 <adamt> to clarify, the cabal binary is part of cabal-install, and not "cabal", correct?
07:24:16 <hpc> adamt: yes
07:24:22 <adamt> hpc: Thanks.
07:24:26 <mparodi_> Axman6, your example doesn't work in ghci tough http://paste.kde.org/480074
07:24:36 <hpc> adamt: trying to get cabal for ghc 7.4.1?
07:25:55 <adamt> hpc: trying to clean up my package mess caused by mixing packages from portage with local packages. ;)
07:26:03 <hpc> ah
07:26:06 <adamt> hpc: i have had cabal and ghc 7.4.1 working for some time.
07:26:12 <hpc> gotcha
07:26:25 <womb> damn i asked about dating girl in office question and forgot to look at people answering
07:26:28 <womb> :(
07:26:49 <adamt> womb: (sorry for the language) Don't shit where you eat. Only date her if you're sure it's not going to get awkward, or you are prepared to get a new job. ;)
07:26:51 <womb> guys, have you ever integrated icinga ?
07:27:01 <adamt> also, another person mentioned it being #haskell-blah material.
07:27:50 <womb> adamt: thanks i needed this.
07:29:00 * hackagebot language-c-quote 0.3.1.1 - C/CUDA/OpenCL quasiquoting library.  http://hackage.haskell.org/package/language-c-quote-0.3.1.1 (GeoffreyMainland)
07:32:41 <absence> trying again: http://hpaste.org/68578 <- in this contrieved example, the details of the file format exists in both put and get, making it hard to maintain and easy to introduce bugs. is it possible to abstract the structure away or something? is there a module/pattern/trick for it?
07:33:07 <hpc> absence: don't think so; ive seen a lot of people asking about that
07:33:26 <absence> ah
07:34:08 <absence> i think i read about something like that in a lisp book, but it probably depends on macros
07:34:55 <hpc> in theory, it's possible to generate a parser and printer from the same grammar, but i don't think there's a haskell lib for it
07:37:43 <tgeeky> roconnor: ping
07:38:14 <tgeeky> hpc: there is
07:38:19 <tgeeky> hpc: invertible-syntax
07:38:25 <hpc> oh, cool
07:38:37 <tgeeky> hpc: also, you might consider BNFC and/or BNFC-meta to do the job, though the latter actually makes a parser and a quasi quoter
07:38:45 <roconnor> tgeeky: ack
07:39:13 <absence> hpc: would that require template haskell?
07:39:32 <tgeeky> roconnor: can I have you take a look at my stupid attempt to write a multiplate for something that I shouldn't be writing a multiplate for?
07:40:13 <tgeeky> roconnor: https://github.com/technogeeky/pi-eta-epsilon/blob/with-multiplate/src/Language/PiEtaEpsilon/Multiplate.hs
07:40:31 <hpc> absence: doesn't look like it
07:40:40 <hpc> look at what tgeeky mentioned
07:41:06 <tgeeky> absence: invertible-syntax uses template haskell to do stuff internally, but it doesn't require you to use template haskell
07:41:23 <tgeeky> roconnor: the types etc are in Evalutor.hs and Syntax.hs https://github.com/technogeeky/pi-eta-epsilon/tree/with-multiplate/src/Language/PiEtaEpsilon
07:41:50 <tgeeky> roconnor: you can ignore everything that's not in Term, because I couldn't even write it for Term properly.
07:42:05 <absence> okay i'll check those out. thanks :)
07:42:09 <hpc> tgeeky: no it doesn't
07:42:18 <hpc> tgeeky: just checked, invertible-syntax doesn't even depend on TH
07:42:30 <tgeeky> hpc: http://hackage.haskell.org/packages/archive/partial-isomorphisms/0.2/doc/html/Control-Isomorphism-Partial-TH.html
07:42:36 <hpc> and doesn't use language extensions
07:42:39 <hpc> oh
07:42:51 <hpc> huh
07:44:39 <tgeeky> roconnor: if you don't have time to do the requisite digging, please just say so. I don't want my misadventures wasting your time.
07:45:08 <lpsmith> is there a way to explicitly mark a module as "unsafe",  re: safe haskell?
07:45:28 <hpc> lpsmith: just don't mark it as safe
07:45:40 <hpc> or put a little note in the top section of haddock
07:46:26 <lpsmith> I mean,  the inferencer doesn't seem to be working quite right,  I have a module that is unsafe,  (postgresql-libpq) and then ghc infers the safety of postgresql-simple,  which should be trustworthy (as long as you don't muck around in the internal module),  but not safe,  as GHC thinks.
07:46:29 <tgeeky> lpsmith: one way is to use {-# LANGUAGE -XUnsafe #-}
07:47:03 <tgeeky> lpsmith: another way is to write/export? a dummy function that uses unsafePreformIO
07:47:32 <tgeeky> lpsmith: there is a bug that's fixed in ghc 7.4.2 relating to haddock saying that something which should be Unsafe-inferred is instead Safe-inferred.
07:47:38 <tgeeky> lpsmith: but I don't think this is it
07:47:45 <lpsmith> well, any FFI should be unsafe...
07:48:29 <tgeeky> lpsmith: this is probably that bug, then
07:48:36 <lpsmith> tgeeky, that might be it
07:48:51 <tgeeky> lpsmith: I don't know if ghc 7.4.2-rc has been released or not
07:49:14 <lpsmith> ok, I'll worry about the relationship of postgresql-simple and postgresql-libpq to safe haskell after 7.4.2 comes out.
07:50:35 <quicksilver> the first 7.4.2 rc was today.
07:50:57 <lpsmith> hmm
07:51:31 <lpsmith> That's still a ways down my priority list,  I think.   I was just hoping this was going to be a quick fix.
07:51:58 <armlesshobo> anyone here ever heard of haskell?
07:52:02 <lpsmith> (not saying that it isn't going to be a quick fix,  but that still involves more than I'm willing to do at the moment.)
07:52:04 <armlesshobo> can't find it
07:52:06 <armlesshobo> :P
07:52:15 <lpsmith> armlesshobo, never.  What is this you speak of?
07:52:16 <td123> quicksilver: link to rc?
07:52:21 <tgeeky> armlesshobo: your username is a lie.
07:52:25 <armlesshobo> lpsmith: sounds like voodoo to me
07:52:58 <armlesshobo> tgeeky: your username makes no sense :(
07:53:08 <quicksilver> td123: http://www.haskell.org/pipermail/glasgow-haskell-users/2012-May/022371.html
07:53:23 <lpsmith> armlesshobo, can we help you with something?
07:53:48 <Taneb> HACKAGE ACCOUNT HECK YEAH
07:53:56 <lpsmith> =)
07:54:12 <armlesshobo> lpsmith: yeah, I don't fully understand what it means when a signature has () in it
07:54:15 <armlesshobo> lpsmith: like IO ()
07:54:20 <armlesshobo> what's the () for?
07:54:29 <armlesshobo> I thought the () were to group expressions.
07:54:34 <Taneb> IO isn't a thing on its own
07:54:39 <quicksilver> it's a type with only one member
07:54:42 <quicksilver> which is also called ()
07:54:45 <Taneb> IO is a thing-wrapper
07:54:49 <quicksilver> it's used for return values you don't care about
07:54:51 <Axman6> > ()
07:54:52 <lambdabot>   ()
07:54:56 <Axman6> > () == ()
07:54:57 <lambdabot>   True
07:54:58 <Taneb> () is like a tuple with no elements
07:55:00 <Axman6> :t ()
07:55:01 <lambdabot> ()
07:55:02 <quicksilver> so it's like "an IO action which deosn't return anything"
07:55:04 <adamt> () is for entering lisp-mode.
07:55:08 <S11001001> :k IO
07:55:09 <lambdabot> * -> *
07:55:16 <Axman6> often likened to void in other languages
07:55:20 <armlesshobo> so, () means a tuple with no elements?
07:55:25 <Axman6> not sure it's a good likening though
07:55:29 <armlesshobo> AND they are used to group expressions?
07:55:29 <lpsmith> yup
07:55:35 <tgeeky> quicksilver: no it's not. IO () is that
07:55:44 <quicksilver> tgeeky: it's IO () he was talkin gabout.
07:55:49 <quicksilver> tgeeky: (among other things)
07:55:52 <tgeeky> quicksilver: oh, ok, sorry. didn't read far enough up
07:55:57 <Taneb> OK, while I was waiting for my hackage account, I thought of a better way to do everything
07:56:01 <lpsmith> armlesshobo, well, to group expressions,  you have to put stuff inside.   () is a special case where you have nothing inside, not even whitespace
07:56:03 <lpsmith> > ( )
07:56:04 <lambdabot>   ()
07:56:12 <lpsmith> ok,  I guess you can have whitespace :)
07:56:14 <quicksilver> () does have two purposes though
07:56:19 <quicksilver> > (1+2)+3
07:56:20 <lambdabot>   6
07:56:21 <quicksilver> grouping
07:56:22 <MaskRay> Void is used for values you cannot construct?
07:56:23 <quicksilver> > (1,2)
07:56:24 <lambdabot>   (1,2)
07:56:24 <quicksilver> tuples
07:56:40 <armlesshobo> ah ok. gotcha
07:56:41 <Taneb> This is probably a good thing
07:56:51 <oddraise1t> Taneb: how long have you waited it?
07:57:34 <armlesshobo> so, for IO (), the result of the last expression would be treated as nothing? or IO?
07:57:51 <Taneb> oddraise1t, 15 days
07:57:53 <S11001001> expression?
07:57:55 <quicksilver> the result of the last expression is ()
07:58:01 <quicksilver> which contains no information, really
07:58:09 <quicksilver> so it's actions which "return nothing"
07:58:11 <quicksilver> like putStrLn
07:58:12 <lpsmith> armlesshobo, well  "IO ()" is a value representing some action that doesn't return anything interesting.
07:58:13 <oddraise1t> Taneb: it's okay
07:58:23 <quicksilver> :t putStrLn "hi"
07:58:24 <lambdabot> IO ()
07:58:51 <oddraise1t> Taneb: people used to wait it during 4-5 months
07:59:05 <Taneb> Oh wow, I don't think I could cope with that
07:59:49 <lpsmith> There aren't very many functions that are both interesting and legitimate that have type  (... -> ()).   But there are lots of interesting,  legimate functions that have type  "... -> IO ()"
08:00:34 <Taneb> () is only interesting for its context, in other words
08:01:41 <hpc> similarly, there aren't very many interesting and legit functions with type (() -> ...)
08:01:48 <lpsmith> well, () can diverge,  so "... -> ()" can be very interesting if you are looking things from a computational theory perspective,    but not very interesting from a practical perspective.   Or rather,  the interesting thing from a practical perspective is that they are so uninteresting.
08:01:51 <hpc> because you would usually just use the type (...)
08:02:27 <td123> quicksilver: thanks for the link
08:04:06 <armlesshobo> but why does is need to have IO before ()?
08:04:20 <armlesshobo> In the tutorials, I've never seen anything like it
08:05:01 <hpc> armlesshobo: "IO foo" is the type of actions that do something in the real world and produce a value of type foo
08:05:07 <hpc> for instance, getLine :: IO String
08:05:24 <hpc> it gets a line from the part of the real world that is your terminal window, and produces a string
08:05:38 <hpc> putStrLn :: String -> IO ()
08:06:02 <Taneb> Does anyone remember me going on about my family-tree lens problem?
08:06:06 <hpc> it takes a string as a parameter, prints it to your terminal in the real world, then returns a value of type ()
08:06:12 <Taneb> I think I've just thought of a great solution
08:06:17 <hpc> () is the type of uninteresting things
08:06:19 <hpc> so really
08:06:23 <armlesshobo> hpc: () is a type?
08:06:29 <armlesshobo> hpc: I thought IO would be the type
08:06:34 <S11001001> :k IO
08:06:34 <lambdabot> * -> *
08:06:36 <hpc> putStrLn takes a string, does stuff, then returns nothing interesting
08:06:36 <tgeeky> :k ()
08:06:37 <S11001001> :k ()
08:06:37 <lambdabot> *
08:06:38 <lambdabot> *
08:06:40 <S11001001> :k IO ()
08:06:41 <lambdabot> *
08:06:43 <tgeeky> hehe
08:06:46 <Taneb> armlesshobo, IO turns a type into a different type
08:06:47 <hpc> armlesshobo: () is a type and a value; it's rather confusing
08:06:50 <hpc> data () = ()
08:07:29 <tgeeky> hpc: I wouldn't say it's entirely uninteresting. Things like:  () -> ((),()) are interesting.
08:07:59 <hpc> tgeeky: only if you have a halting oracle to let you decide what to do with such values
08:07:59 <armlesshobo> IO transforms what ever input to ()?
08:08:03 <armlesshobo> or to other types?
08:08:15 <hpc> armlesshobo: "IO foo" is the type of actions that do something in the real world and produce a value of type foo
08:08:25 <hpc> "foo" there is a type
08:08:27 <tgeeky> hpc: I meant that as a type
08:08:29 <hpc> "IO foo" is a type
08:08:29 <tgeeky> hpc: hehe :)
08:08:47 <armlesshobo> ahhhhh
08:08:56 <Axman6> examples of IO foo: IO (), IO String, IO Int, IO (Bool,Double)
08:08:57 <armlesshobo> so "IO ()" is a type
08:09:01 <Axman6> yes
08:09:05 <armlesshobo> omg...
08:09:09 <hpc> and IO String is a type
08:09:12 <hpc> and String is a type
08:09:18 <hpc> and so on
08:09:59 <armlesshobo> would you use () for a signature of a function if you don't want it to return anything important, then?
08:10:04 <Axman6> IO () is a type like Maybe Int is a type
08:10:10 <Axman6> sure
08:10:22 <hpc> armlesshobo: yeah
08:10:30 <armlesshobo> is Int () a type then?
08:10:38 <sipa> no, Int does not take a type argument
08:10:48 <armlesshobo> ok
08:10:49 <armlesshobo> ok
08:11:06 <Axman6> only things eith kind * -> * can be used like that. Maybe has kind * -> *:
08:11:10 <Axman6> :k Maybe
08:11:11 <armlesshobo> IO is the type, but () is the type argument
08:11:11 <lambdabot> * -> *
08:11:14 <Axman6> :k []
08:11:15 <lambdabot> * -> *
08:11:20 <Axman6> :k IO
08:11:21 <lambdabot> * -> *
08:11:24 <Axman6> but
08:11:26 <armlesshobo> just like String would be the type argument too
08:11:26 <Axman6> :k Int
08:11:27 <lambdabot> *
08:11:33 <nand`> tgeeky: how is () -> ((), ())? To me it sounds like there's exactly two ways to implement it: f () = ((),()) or f () = undefined/bottom/error/whatever silly thing
08:11:33 <Axman6> :k String
08:11:34 <lambdabot> *
08:11:44 <nand`> how is ... interesting*
08:11:52 <armlesshobo> Axman6: what does :k do?
08:12:01 <hpc> armlesshobo: it shows the kind of a type
08:12:03 <Axman6> it tells you the kind of a type
08:12:08 <armlesshobo> ah gotcha
08:12:13 <hpc> armlesshobo: which is basically one level higher than showing the type of a value
08:12:35 <Axman6> so you know how you've got data constructors like Just and (:)?
08:12:40 <Axman6> > Just 1
08:12:41 <lambdabot>   Just 1
08:12:43 <Axman6> :t Just
08:12:44 <lambdabot> forall a. a -> Maybe a
08:12:45 <tgeeky> nand`: it shows up in this negative/fractional types paper as a way to construct the value ((),()) of type 1 x 1
08:13:00 <armlesshobo> do any other types have a type argument?
08:13:01 <Axman6> we've also got type constructors, and they all have different kinds
08:13:12 <tgeeky> nand`: and then they apply an isomorphism of 1 <-> (1/b) x b
08:13:15 <Axman6> sure, plenty
08:13:22 <Axman6> armlesshobo: lists are another example
08:13:35 * Axman6 -> sleep
08:13:56 <Taneb> What's a better way of saying "thePeopleAtThisEvent"
08:14:00 <Taneb> ?
08:14:07 <tgeeky> nand`: which nets you: ((1/x,x), (1/y,y)) ... which you can use AssocX and CommuteX to get: ((1/x,y), (1/y,x)). Which is interesting!
08:14:11 <alpounet> Taneb, attendees?
08:14:16 <tgeeky> nand`: so by transitive property of interesting, it's interesting :o
08:14:29 <sipa> alpounet: there are even types that take another type which takes another type argument as argument
08:14:39 <sipa> :k MaybeT
08:14:39 <Taneb> alpounet, perfect! Thanks!
08:14:40 <lambdabot> Not in scope: type constructor or class `MaybeT'
08:16:46 <absence> in "value <- Binary.get", what is the best way to specify the type of "value"?
08:17:04 <hpc> (value :: Foo), i think
08:17:22 <nand`> or specify it later on (eg. where you actually need it) and let type inference take over
08:17:24 <alpounet> sipa, wrong nickname I think :P
08:17:26 <nand`> which I personally think is the most elegant
08:17:28 <adamt> doesn't that require some language extension to work?
08:17:31 <quicksilver> that requires an extension, hpc
08:17:48 <quicksilver> value <- Binary.get :: Get Foo works.
08:17:55 <absence> scopedtypevariables
08:18:09 <sipa> alpounet: oh, sure
08:18:20 <sipa> armlesshobo:  there are even types that take another type which takes another type argument as argument
08:18:38 <absence> all good suggestions though, thanks :)
08:19:10 <Taneb> And a better way to say eventsThisPersonWasAt?
08:19:45 <nand`> “participations”? No, that's ugly (and probably not an actual word)
08:19:56 <Taneb> attended?
08:20:31 <nand`> that could work
08:20:38 <nand`> attendedAt for more clarity
08:21:23 <gdoteof> i am not sure how much of this is yesod specific.  i am trying to bind an operator +=. to a variable and use it later.
08:21:26 <gdoteof>  http://hpaste.org/68583
08:21:50 <gdoteof> something like [PlayerMinutes +=. someInt] is valid and will compile
08:21:55 <gdoteof> so i tried to do
08:22:14 <Taneb> Unfortunately, I find it difficult to reach the golden naming convention between ultra-verbose "eventsThisPersonAttended" and the ultra-consise "evts"
08:22:29 <geekosaur> theirEvents?
08:22:32 <gdoteof> let foo = (+=.);  [PlayerMinutes `foo` someInt] but it's wrong
08:22:48 <nand`> geekosaur: that sounds like they organized them
08:22:53 <Taneb> geekosaur, doesn't quite fit
08:22:53 <flux> "personEvs"
08:22:55 <adamt> attendedEvents? :)
08:23:01 <geekosaur> gdoteof, my first inclination is to guess it's the monomorphism restriction
08:23:08 <flux> there should be a website deedicated to naming variables, functions, etc
08:23:45 <geekosaur> assign an explicit type to "as" (and possibly also to "hm" since it's also liable to the MMR)
08:23:55 <Botje> gdoteof: monomorphism restriction, I bet.
08:23:58 <geekosaur> s/liable/subject/
08:24:10 <Taneb> adamt: I might actually go with that
08:24:12 <Taneb> Thanks, everyone
08:24:22 <nand`> gdoteof: it might help to post what the actual error you get is
08:25:00 <gdoteof> nand`: that seems fair.  i will ammend
08:25:19 <hpaste> gdoteof annotated “Handler/Player.hs” with “Handler/Player.hs (annotation)” at http://hpaste.org/68583#a68584
08:25:21 <Taneb> And why does family have to be a reserved word... :/
08:25:26 <kallisti> Taneb: take the verbose style and shorten a few words
08:25:52 <geekosaur> ...ugggh
08:27:51 <adamt> Taneb: f4|\/|1|y
08:28:45 <Taneb> I'll stick with family', I think
08:29:15 <nand`> gdoteof: what happens when you add type signatures for as and hm?
08:30:37 <geekosaur> wait.  family should not be a keyword if you aren't using that extension, I think?
08:30:39 <gdoteof> nand`: currently looking up the type sigs
08:31:14 <nand`> > let family = 5 in family
08:31:15 <lambdabot>   5
08:33:13 <geekosaur> (speaking of, I notice a tiny ghc bug in that error... it outputs "as" without the ``.  expression printer confused by "as" as variable instead of not-a-keyword?)
08:33:48 <Taneb> It's highlighted and I don't like highlighting
08:34:03 * hackagebot parallel 3.2.0.3 - Parallel programming library  http://hackage.haskell.org/package/parallel-3.2.0.3 (SimonMarlow)
08:34:12 * shapr puts lowlighting (underglow?) on Taneb's expressions.
08:34:33 <geekosaur> the highlighting is from hpaste, and I'm not surprised by that getting it wrong.  it's the absent `` that struck me
08:34:44 <kallisti> shapr: so I think I fixed major bugs in the way filter works
08:34:49 <kallisti> but now I need to test if it's efficient
08:34:51 <shapr> w00t!
08:34:58 <shapr> kallisti: profile it?
08:35:06 <Taneb> Thanks, shapr!
08:35:09 * shapr hugs SyntaxNinja
08:35:27 <nand`> I actually get confused by the presence or nonpresence of ` ' quite often; eg. when mistyping “foo” as “foo'” it can complain about not finding foo', perhaps you meant `foo'
08:35:29 <shapr> Did I mention that cabal was primarily created due to SyntaxNinja's influence?
08:35:40 <shapr> SyntaxNinja++  for making cabal happen
08:35:42 <nand`> at first sight those look identical in the error output
08:35:55 * dcoutts seconds shapr's ++
08:36:05 <nand`> who made cabal-install?
08:36:20 <nand`> I don't like cabal-install :(
08:36:28 <shapr> nand`: fix it?
08:36:41 <shapr> nand`: Or at least write up how it could be improved?
08:36:45 <kallisti> shapr: yes
08:37:07 <kallisti> shapr: I had to change the way it works a bit to make it useful
08:37:35 <holzensp> I'm trying to bend my head around the GHC API; it's not too straightforward… so I have a question about adding modules to the module graph
08:37:43 <shapr> nand`: If you say "cabal-install could be greatly improved if it did A by method C because B help everybody." then people will be motivated to do those things!
08:37:45 <nand`> shapr: by making it not get confused by everything, break less often and act more like a package manager - having it resolve dependencies somewhat but claim not to be a package manager results in lots of headaches
08:37:49 <nand`> I just avoid it completely
08:38:01 <gdoteof> hrm. this is quickly becoming not worth it :)i am getting a type error on type signature :)
08:38:02 <nand`> and use portage instead, but that's distro-specific and not a general solution
08:38:22 <shapr> nand`: Oh, I like cabal-install lots, it's only started having problems in the past year or so.
08:38:31 <shapr> nand`: This clearly means it's successful, right? :-)
08:38:37 <alpounet> the modular solver helps a bit
08:38:40 <holzensp> My problem is as follows; I parse a file. When I find imports, I check whether I can find the source file of the import and parse it too. If I can't find the source file, I assume it's a package module. No my problem is; how can I load a package module?
08:38:56 <alpounet> people closely following their projects' dependencies too
08:39:14 <nand`> shapr: perhaps
08:39:44 <shapr> alpounet: Is there a guide to writing better dependencies for a project? Or dependencies that will confuse cabal-install less?
08:40:55 <alpounet> shapr, i don't think so. following the PVP is one thing, but having the exact right version bounds for each dependency is waaaaay harder, in addition to the difficulty of making these bounds cooperate nicely with other stuffs you install via cabal-install
08:41:10 <hpaste> gdoteof annotated “Handler/Player.hs” with “Player.hs with type sig” at http://hpaste.org/68583#a68586
08:41:29 <alpounet> to avoid your project depending on A depending itself on B-1.1, and on C depending itself on B-1.2 for example
08:41:35 <adamt> i have a set S that i need to split into T and U, and U then needs to be split unto V and W. Obviously i can just partition twice, but is there a neat trick to do a 3-way partition in one go?
08:41:45 <Taneb> Damn, just realised what I'm doing prevents adoption
08:42:00 <hpaste> ClaudiusMaximus annotated “floyd-warshall” with “floyd-warshall (annotation)” at http://hpaste.org/68542#a68587
08:42:06 <hpaste> gdoteof annotated “Handler/Player.hs” with “Player.hs with type sig (error)” at http://hpaste.org/68583#a68588
08:42:08 <Taneb> Which is bad
08:42:10 <shapr> alpounet: Perhaps there could be a 'dependency tuner' that would grab a bunch of other versions from hackage and try to *find* confusions and then guide the developer to dependencies that don't cause confusion?
08:42:19 <geekosaur> gdoteof, for starters I would separate the type signature from the definition (just like with a top level), just to make it easier to read
08:42:30 <gdoteof> geekosaur: yeah i did that too
08:42:31 <alpounet> shapr, actually, one of the goals of scoutess is to test that kind of thing BEFORE you release
08:42:32 <gdoteof> same error tho
08:42:37 <kallisti> shapr: graph on the left is profile of a regular home traversal. second graph is home traversal filtering on (".mozilla/" `isInfixOf`) http://dl.dropbox.com/u/16495819/2012-05-16_11-38-17_2390x768.png
08:42:49 <shapr> kallisti: oh that's neat!
08:42:57 <alpounet> shapr, you can also check snoyman's cabal-nirvana, for example
08:43:10 <shapr> I've heard about it, but haven't looked into any details.
08:43:22 <gdoteof> er i take it back, not the same error
08:44:04 <hpaste> gdoteof annotated “Handler/Player.hs” with “seperate type sig” at http://hpaste.org/68583#a68589
08:44:07 <geekosaur> the first error is telling you that you need another extension; that is correct
08:44:57 <shapr> kallisti: Is the isInfixOf really that expensive?
08:45:07 <hpaste> gdoteof annotated “Handler/Player.hs” with “seperate type sig (error)” at http://hpaste.org/68583#a68590
08:45:10 <geekosaur> gdoteof, the type sig needs to be at the same indent level
08:45:26 <geekosaur> I guess forgetr I said it since all it did was confuse you
08:45:50 <gdoteof> geekosaur: is it not in the latest?
08:45:51 <alpounet> shapr, scoutess will tell you with which combination of dependencies versions the build fails, and why exactly it fails, so that you can either fix the version bounds, or talk to the maintainer of the problematic dependency so that he can fix smth, or w/e
08:46:14 <hpaste> geekosaur annotated “Handler/Player.hs” with “seperate type sig (syntactically correct)” at http://hpaste.org/68583#a68591
08:46:25 <kallisti> shapr: if a node fails the predicate test, the new filter version will only remove the node if all of its children fail as well.
08:46:36 <gdoteof> geekosaur: ah
08:46:44 <ski> gdoteof : `as :: ...' should be indented as much as `as = ...'
08:47:02 <geekosaur> if that "not in the latest" was about the extension, Rank2Types/RankNTypes has *existed* for a long time but is not enabled by default
08:47:12 <shapr> kallisti: That makes sense
08:47:20 <gdoteof> ski: thanks.
08:47:26 <gdoteof> geekosaur: well, good news, we are back to the original error :)
08:47:30 <geekosaur> writing out the type signature involving a forall requires it to be enabled (that it can be inferred is just a Haskell type oddity...)
08:47:40 <kallisti> shapr: because otherwise things like (".txt" `isSuffixOf`)  will just return an empty forest, because non of the parent directories match
08:48:10 <hpaste> gdoteof annotated “Handler/Player.hs” with “error after geekosaurs fix” at http://hpaste.org/68583#a68592
08:48:26 <kallisti> and I think this kind of directory-based filtering isn't something you'd even want to do anyway. You can just use find for that.
08:48:30 <ski> geekosaur : i'm not sure this is a case of higher-rank types ..
08:49:11 <ski> gdoteof> :t update
08:49:24 <ski> gdoteof> :t PlayerMinutes
08:49:26 <geekosaur> ski, Rank2Types is mentioned in the error message e pasted
08:49:41 <kallisti> shapr: honestly I'm pleased with how small the overhead is.
08:49:57 <gdoteof> ski.  update ::  Key b val -> [Update val] -> b m ()
08:50:14 <ski> geekosaur : yes, but i suspect that may be because a (polymorphic) pattern signature was used
08:50:35 <ski> gdoteof : with which constraints on `b' and `m' (and `val' ?) ?
08:50:44 <geekosaur> well, yes, that was why I said splitting the type... hm, ok
08:50:56 <shapr> apfelmus has posted the first post for our GSoC project: http://ghclive.wordpress.com/
08:50:56 <gdoteof> ski: PlayerMinutes umm... i am not quite sure.   i am a bit out of my element here.
08:51:01 * shapr boings cheerfully
08:51:10 <gdoteof> ski http://hackage.haskell.org/packages/archive/persistent/latest/doc/html/Database-Persist.html#v:update
08:51:23 <ski> also, how is `Handler' defined ? (is it a type synonym ?(
08:51:38 <shapr> kallisti: I'll be happy if it's easy to use and I can build playlists easily :-)
08:52:41 <ski> `PlayerId' is `Key Something SomethingElse' ?
08:52:42 <gdoteof> ski: it is a type synonym yeah.  this is all within Yesod
08:52:54 <ski> a type synonym of what ?
08:52:54 <kallisti> shapr: and if you can't, you should let me know what you had trouble with. ;)
08:52:57 <ClaudiusMaximus> @tell mizu_no_oto i wrote a version in repa (parallel unboxed arrays), and added to your paste here http://hpaste.org/68542#a68587  (i haven't checked correctness, and it's a slightly different algorithm computes each pass in parallel instead of sequentially with mutation)
08:52:58 <lambdabot> Consider it noted.
08:53:02 <shapr> I will certainly do that.
08:53:45 <gdoteof> ski: i believe it is a synonum if GHandler sub App ()
08:54:37 <gdoteof> and I can't say with confidence what PlayerId is
08:54:52 <gdoteof> though in human speak is is the 'key for the entity'
08:54:58 <kallisti> I wonder if clever use of parallelism could speed up this code
08:56:28 <gdoteof> if it's not obvious i am not exactly sure what i am doing here and definitely don't know this inside and out.  this is my first attempt at a haskell program
08:57:03 <gdoteof> i could do what i am trying to do by nesting ifs within case statements and having a few update lines; it just seemed like i ought to be able to bind the operator to a variable and that it would be nicer that way
08:57:09 <ski> well, i don't really know the types here
08:57:18 <SyntaxNinja1> hi shapr!
08:57:47 <mekeor> how do i do like "data Foo = SomeClass t => Foo t t" ?
08:57:50 <ski> gdoteof : if you have a working but more awkward version, maybe you could paste it ?
08:58:12 <bitonic> mekeor: ExistentialQuantification, but make sure that's what you want
08:58:19 <geekosaur> ski asked if it was a type synonym, and you said yes... that can cause kinding problems like this.  handling that correctly turns out to be rather expensive, IIRC, so ghc cuts a corner and that's possibly biting you
08:58:24 <shapr> howdy SyntaxNinja1!
08:58:33 <gdoteof> ski: right.  yep i don't either.  thanks for the help.  i thought it would be sort of abstracted away from the surrounding types and that i could just bind an infix operator to a variable and reuse it.
08:58:36 <shapr> SyntaxNinja1: How's code?
08:58:42 <mekeor> bitonic: ok, ty
08:58:45 <gdoteof> ski: sure i will do that.. is it not clear though what i am going for?
08:59:14 <SyntaxNinja1> The problems w/ cabal and cabal-install are largely "victim of their own success" type problems ;) Previously, it was difficult to use even a few packages and now we can use many packages, but there are more complex problems.
08:59:20 <SyntaxNinja1> That's always the way when you write software, IMO.
08:59:24 <ski> gdoteof : i don't know Yesod -- but seeing a working version could help me better see the types, i think
08:59:52 <gdoteof> update playerId [PlayerMinutes +=. 10]   ; for example, compiles and is fine.  what i want to do is do    let foo = (+=.)    ;    update playerId [PlayerMinutes `foo` 10]
09:00:03 <gdoteof> but i will put up a working version in a few minutes
09:00:29 <dcoutts_> SyntaxNinja: yeah, definitely
09:00:49 <ski> where is `(+=.)' coming from ?
09:00:50 <dcoutts_> SyntaxNinja: the solver I wrote was fine at the time I wrote it, now it's really painful
09:00:55 <shapr> I sort of wish cabal update had incremental updates to cut down on bandwidth usage, but if I really want it, I'll go fix it...
09:01:08 <dcoutts_> shapr: if you have time, I have a design
09:01:27 <shapr> Let me see how my GSoC project goes :-)
09:01:55 <Taneb> shapr, what are you doing with GSoc?
09:02:00 <tommd> Two cabal questions: How do I determine what compiler to test c flags with when using "custom" builds?  The buildProgramPaths is always [].
09:02:35 <shapr> Taneb: http://ghclive.wordpress.com/
09:03:10 <ski> hm
09:03:24 <dcoutts_> tommd: use the 'compiler' from the LocalBuildInfo
09:03:37 <tommd> Even for testing C flags? Sounds good.
09:03:54 <tommd> Also - I set some cc-options (whatever the field was) in a configure stage hook, but they didn't take effect.
09:04:00 <gdoteof> ski: http://hackage.haskell.org/packages/archive/persistent/0.9.0.4/doc/html/Database-Persist.html
09:04:04 <tommd> Is that my misunderstanding or a bug I should hunt down and fix?
09:04:05 * hackagebot webdriver 0.3.2 - a Haskell client for the Selenium WebDriver protocol  http://hackage.haskell.org/package/webdriver-0.3.2 (AdamCurtis)
09:04:08 <gdoteof> under query combinators
09:04:16 <alpounet> dcoutts_, i can't wait to see that new index
09:04:34 <ski> gdoteof : hm, what happens when you try just `as = (+=.)' in there (with the type signature) ?
09:04:55 <dcoutts_> alpounet: you mean hackage index format
09:04:59 <dcoutts_> ?
09:05:33 <dcoutts_> tommd: to call gcc, use the Program stuff, it'll use the configured one
09:05:38 <Taneb> shapr, that looks pretty cool
09:06:03 <dcoutts_> tommd: what you set in hooks is not persistent, it's used for that hook only
09:06:51 <alpounet> dcoutts_, yeah
09:07:23 * mekeor doesn't understand why MultiParamTypeClasses is not part of Haskell.
09:07:31 <tommd> Ahh, thanks dcoutts_.
09:08:09 <alpounet> dcoutts_, actually the most awesome idea i can think of is having a webservice that can tell what's the last version of that package, what are all the versions of that package, that can send you just all the packages and their versions, etc
09:08:16 * mekeor finds empty data-types and type-classes funny.
09:08:42 <alpounet> (by sending i mean just the name and numbers, not the actual content of the packages)
09:08:55 <ski> mekeor : .. did you want existentials ?
09:08:57 <dcoutts_> alpounet: right, certainly possible for the new hackage server to do
09:09:09 <mekeor> ski: i think so, yes.
09:09:22 <dcoutts_> alpounet: but it's obviously not a replacement for the index, we need to support archives on "dumb" http servers
09:09:38 <dmwit> tgeeky: pong
09:09:39 <lambdabot> dmwit: You have 1 new message. '/msg lambdabot @messages' to read it.
09:09:42 <dmwit> ?messages
09:09:43 <lambdabot> tgeeky said 2h 4m 22s ago: is there a sym combinator in your implementation? I noticed it in the paper (where it's not used) and Pi.hs (where it's not used).
09:09:55 <alpounet> dcoutts_, yeah and anyway we also need backward compatibility as a starter
09:10:04 <dmwit> tgeeky: That's what adjoint does, no?
09:10:29 <alpounet> (for repos with the old package format as well as older versions of cabal/cabal-install)
09:10:42 <dmwit> tgeeky: Anyway, to be pedantic: no, I took "sym" out of the language.
09:10:56 <gdoteof> ski: ok.  i facepalmed.  i put it to the way i thought would work and it still didn'twork.  i was not inside a runDB;
09:10:57 <dmwit> tgeeky: You'll notice that *nowhere* in their paper do they use "sym" -- they always use the adjoint construction instead.
09:11:00 <gdoteof> so i basically just wasted your time
09:11:13 <alpounet> dcoutts_, but i'd gladly tackle this once the new index format is there, so that i can use that webservice in scoutess instead of rewriting half of cabal-install :P
09:11:15 <dmwit> tgeeky: So, instead of a language construct that reverses a term, we have a meta-language construct that reverses the term.
09:11:21 <shapr> Taneb: I certainly hope so :-)
09:11:33 <dmwit> tgeeky: I think it's cleaner that way, conceptually: the machine doesn't need to know what to do with "sym"s.
09:11:36 <dcoutts_> alpounet: well the right thing to do is to make the index handling available as a lib
09:11:45 <dcoutts_> alpounet: hackage-client
09:11:49 <ski> gdoteof : no worry :)
09:11:50 <Taneb> shapr, it's the kind of thing if I tried, I'd say, "This is obvious", and emerge foour weeks later saying "This is impossible"
09:11:51 <dmwit> tgeeky: (And their machine specification indeed doesn't even say what to do with "sym"s, I think -- it just gets stuck -- which surely isn't what they meant.)
09:12:19 <alpounet> dcoutts_, yeah but i'd like to avoid downloading the index archive when i just want to figure out the latest version of some package
09:12:44 <alpounet> it was smth like 23MB last time i checked
09:12:47 <dcoutts_> alpounet: if it's a regular service then a one-time download + small incremental update should be ok, no?
09:13:22 <dcoutts_> alpounet: providing all the data means fewer round trips and more flexibility for the client to do whatever analysis it needs
09:13:24 <alpounet> dcoutts_, yes I think so! it's just that for now, there is no such thing as incremental update, is there?
09:13:35 <dcoutts_> alpounet: right, but that'd go along with the new format
09:13:43 <dcoutts_> new/extended
09:13:49 <alpounet> yeah
09:14:14 <alpounet> dcoutts_, but with a webservice we could maybe make it deliver only the data you ask it to
09:14:30 <alpounet> like in scoutess i will most likely never care of a package's description
09:14:58 <alpounet> yet, i currently pay for it, network traffic wise
09:14:59 <shapr> Taneb: Hopefully this project will fit into just one summer.
09:15:05 * ski idly wonders what mekeor is doing
09:15:16 <Taneb> shapr, you're probably older and better than me
09:15:34 <shapr> I am likely older... as for the rest, nothing is certain :-)
09:15:37 <Taneb> older here implying more experienced
09:16:16 <shapr> But I had to start knowing zero Haskell just like everybody else.
09:16:25 <shapr> If you put in the work, you get the knowledge.
09:16:31 <kallisti> yep
09:16:35 <alpounet> dcoutts_, but I agree that the webservice should just sit on top of the rest, not replace it, just like a "plugin"
09:16:43 <dcoutts_> alpounet: it's a tradeoff right, to get just what you need, there's much less flexibility
09:16:49 <Taneb> I'm trying to put in the work, but I should really put in some more work into tomorrow's ancient history exam
09:16:58 <dcoutts_> and the service needs to provide many different things
09:17:00 <shapr> Taneb: Yes, passing exams is very important :-)
09:17:08 <dcoutts_> and the number of round trips can be rather high
09:17:28 <dcoutts_> alpounet: I'm reasonably confident that with incremental update the bandwidth will be trivial
09:17:44 <dcoutts_> and it's always one round trip
09:18:34 <alpounet> dcoutts_, right. just thought it could be nice to have such a webservice that would just occasionally need to ask a question or two to hackage
09:18:53 <alpounet> and i insist, it would just be "an additional tool"
09:19:10 <dcoutts_> alpounet: certainly it would not be too hard to extend the new hackage-server to provide some extra resources
09:19:21 <mekeor> ski: i recently had a nice idea and i'm setting up the types behind this fun project: i thought of a website where you search for words of the english language with different criteria. furthermore, you can watch like a graph/tree with vertices and edges where vertices are words and edges are relations between those words… etc etc
09:19:22 <hpc> alpounet: wait for hackage2, then see what happens
09:19:33 <SyntaxNinja> shapr: Code is pretty good. Most of my development lately (what little there is) has been for Android stuff, which is fun.
09:19:44 <SyntaxNinja> I like carrying my programs in my pocket and showing them to people.
09:20:03 <dcoutts_> SyntaxNinja: in Java or Haskell? :-)
09:21:35 <stensonred> Hello: What happens to the binaries in .ghc and .cabal when I update GHC? What would happen if I used one version of GHC for one project and then another for another project? How does it deal with the changing versions and ABI?
09:21:43 <ski> mekeor : ok
09:21:59 <dcoutts_> stensonred: libs for each ghc instance are completely separate
09:22:03 <ski> .. and how does existentials fit into this ?
09:22:21 <stensonred> dcoutts_: separate but all within .cabal and .ghc?
09:22:24 <hpc> stensonred: executables stick around, compiled libraries are reinstalled
09:22:28 <hpc> or technically, installed
09:22:36 <hpc> different ghc versions keep different ghc-pkg lists
09:23:10 <hpc> so, if you install hoogle, then upgrade ghc
09:23:16 <hpc> hoogle will still work
09:23:19 <infiniteloop3> hey guys, i'm learning haskell right now but i'm a bit confused as to how function types work
09:23:33 <alpounet> hpc, well yeah but i'm kind of duplicating work so from time to time i annoy dcoutts_ to get some informations on parts of hackage2 :P
09:23:36 <infiniteloop3> anyone have a particularly helpful site to learn this on? (i've looked)
09:23:39 <hpc> but if you install hoogle with the new ghc, it will have to install all the dependencies again, as well as hoogle itself
09:23:45 <ski> infiniteloop3 : ok, what are you confused about ?
09:23:52 <dcoutts_> stensonred: right
09:24:20 <dcoutts_> alpounet: you can extend the hackage-server now and use it :-)
09:24:21 <infiniteloop3> ski: something like (+) :: Num a => a -> a -> a
09:24:21 <ski> infiniteloop3 : do you have any particular piece of code which is puzzling you ?
09:24:35 <dcoutts_> alpounet: I can update the code for the public test instance
09:24:59 <Gurrag> Are there any lists of imperative programming idioms / mindsets and their corresponding solutions in pure functional programming?
09:25:05 <infiniteloop3> ski: i get that it takes a type a but then i'm confused about the arrows
09:25:08 <ski> infiniteloop3 : the `Num a =>' there means that the function is overloaded over all types `a' which are instances of the type class `Num' -- which just means that the type `a' supports basic numeric operations
09:25:15 <hpc> Gurrag: probably, but i doubt they would be useful
09:25:34 <ski> infiniteloop3 : the `a -> a -> a' part means that the function takes two arguments of types `a' and `a', and returns a result of type `a'
09:26:12 <ski> infiniteloop3 : one example of what `a' could be is `Integer' -- so one specific *instance* of this function is `(+) :: Integer -> Integer -> Integer'
09:26:33 <infiniteloop3> ski : so the last a is the return value type correct?
09:26:45 <ski> infiniteloop3 : it may be nice to concentrate on *non*-overloaded functions at first, if you're unsure about functions in general
09:26:49 <ski> infiniteloop3 : yes
09:27:13 <infiniteloop3> ski: gotcha so would map be non overloaded?
09:27:17 <ski> yes
09:27:30 <ski> and `length', and `concat', and `reverse', and `not'
09:27:42 <infiniteloop3> ski : okay so for map :: (a -> b) -> [a] -> [b] , that means it takes in a function and a list and returns a list of type b
09:27:45 <ski>   take :: Int -> [a] -> [a]
09:27:51 <hpc> infiniteloop3: yes
09:28:23 <infiniteloop3> ski : so in that case it takes an integer and a list and returns a list of type a
09:28:30 <ski> yes
09:28:41 <infiniteloop3> thanks hpc and ski, i think i'm starting to understand it a little better
09:28:46 <ski> where the type of the elements in the input list is the *same* as the type of the elements in the output list
09:28:47 <mekeor> ski: in particular, this graph should make clear which nouns, e.g., are a subset of another noun, for example "animal" and "human" should be connected with an edge specifing that all humans are animals… anyway. i'm just trying out the types, i'm not sure whether i really need existential types. -- actually, i often have problems when i have to decide whether to use a class or a data-type; is there a nice rule for that? i mean, let's
09:28:47 <mekeor> assume we want to implement animals in haskell. we could do something like "data Animal = ABacteria Bacteria | AArchaea Archaea | AEukaryota Eukaryota; {- and then -} data Bacteria = Foo | Bar | …; -- and so on" or we could do "class Animal where {- insert some functions which we need here -}; data Bacteria = …; instance Animal Bacteria;". which method should you use when?
09:29:09 <alpounet> dcoutts_, well, yeah it will have to wait, exams period. but anyway there's quite some things to discsuss with you at some point, like what to put in the separate library (the one that will query hackage-server etc, that would be a kind of cabal-install library), and then if there's some way for me to have a local hackage repo without writing it myself (even if i already have some code that does this, but it doesn't follow the new/exten
09:29:09 <alpounet> ded format for the index)
09:29:10 <alpounet> etc
09:29:12 <Taneb> I'm just gonna make sure all my lines are less than 80 characters, and then write the Haddock docs, then HACKAGE AWAY
09:29:32 <dcoutts_> alpounet: right
09:29:37 <ski> infiniteloop3 : the same `a' is used in both places -- `a' stands for an arbitrary type, like e.g. `Integer' or `String', or `[(String,Double)]' -- but all the places where `a' appears have to stand for the *same* concrete type
09:29:53 <mekeor> ski: sorry, i mean "class Animal a where".
09:29:57 <hpc> mekeor: consider eats :: Animal -> Animal :: Bool
09:30:10 <mekeor> hpc: okay.
09:30:11 <hpc> mekeor: or eats :: Animal a => a -> a -> Bool
09:30:18 <mekeor> hpc: okay.
09:30:19 <infiniteloop3> ski : gotcha thanks, that helps a lot
09:30:34 <hpc> do you want bacteria to eat archaea
09:30:34 <mekeor> hpc: oh.
09:30:37 <SyntaxNinja> dcoutts_: in Haskell
09:30:38 <hpc> or whatever
09:30:40 <SyntaxNinja> er Java
09:30:41 <SyntaxNinja> heh
09:30:48 <ski> infiniteloop3 : however, in `map', the types of the elements in the input list and the output list *may* be different types
09:30:57 <hpc> also consider eats :: Animal a, Animal b => a -> b -> Bool
09:31:01 <mekeor> hpc: hmmm... yes, that should be possible. i mean, yes, bacteria should be able to eat archaea or so, yes.
09:31:05 <hpc> my expectation is that such a function will be damn hard to write
09:31:08 <mekeor> hpc: considered, okay.
09:31:13 <ski> infiniteloop3 : but the supplied function argument must be able to transform an element of the one type to an element of the other type
09:31:15 <mekeor> hpc: i see. hmm...
09:31:30 <mekeor> hpc: cool, thanks for this example.
09:31:31 <hpc> so you probably want a data type, and then just bite the annoying verbosity
09:31:38 <Taneb> Right, now the longest line is 75 characters
09:31:41 <infiniteloop3> ski : so having two different types a->b for example, doesn't necessarily mean they'll be different types?
09:31:48 <hpc> or maybe do some GADT tricks
09:31:49 <ski> infiniteloop3 : so one possible instance of `map' is `map :: ([Int] -> String) -> [[Int]] -> [String]'
09:31:50 <mekeor> hpc: annoying verbosity?
09:32:18 <hpc> data Animal a where Bact :: Bacteria -> Animal Bacteria; ...
09:32:26 <ski> infiniteloop3 : but another one is `map :: ((Bool,Int) -> (Bool,Int)) -> [(Bool,Int)] -> [(Bool,Int)]'
09:32:29 <ski> infiniteloop3 : right
09:32:40 <hpc> mekeor: well, the annoying every-"instance"-being-clumped-together-ness
09:32:40 <infiniteloop3> ski : that makes a ton more sense
09:32:50 <hpc> of having to match over every constructor of Animal for every function
09:32:54 <dcoutts_> SyntaxNinja: :-)
09:33:05 <mekeor> hpc: i see, true.
09:33:10 <infiniteloop3> ski : i'm gonna mess around with hugs and see if it helps replacing the letters with concrete types
09:33:25 * mekeor didn't understand GADTs really.
09:33:29 <kallisti> shapr: oh also there's this http://hackage.haskell.org/packages/archive/filesystem-conduit/0.4.0/doc/html/Data-Conduit-Filesystem.html
09:33:32 <infiniteloop3> ski : thanks a a lot, i appreciate the help
09:33:36 <alpounet> dcoutts_, next time i go to England i may actually come to Oxford, it may be the occasion to get a beer or two and discuss this hah
09:33:44 <hpc> mekeor: ah, then i wouldn't worry about it here; it might not buy you much anyway
09:33:49 <hpc> stick with ADT
09:34:27 <mekeor> hpc: wait. do GADTs make sense for data-types of kind * ? or only for higher kinds? i mean like * -> * ?
09:34:42 <dcoutts_> alpounet: oh yes, do let me know if you plan to come. Could perhaps sync with OxHUG
09:34:52 <hpc> mekeor: you would add a type parameter just for information passing
09:35:06 <hpc> data Animal a where Bact :: Bacteria -> Animal Bacteria; ...
09:35:18 <ski> infiniteloop3 : btw, note that while `map' isn't *overloaded*, it is *polymorphic* -- you can use it in many difference *instances* -- but the point is that `map' itself functions in exactly the same way here, it doesn't know (or care) what the element types actually *are*, as long as they "line up" correctly with the argument function
09:35:20 <mekeor> hpc: so, GADTs don't make sense for types with the kind *, right?
09:35:20 <hpc> then you can write
09:35:23 <zztr> the install of persistent-postgresql is failing because it can't seem to find libpq. postgresql is installed (verified with `yum list installed`) and /usr/lib64/libpq.so.5 exists. what would be a next step to try? googling these error messages isn't helping
09:35:29 <mekeor> [Y/n]
09:35:31 <kallisti> shapr: which is probably a more sensible approach for the common case.
09:35:33 <hpc> mekeor: yeah
09:35:34 <ski> @tell infiniteloop3 btw, note that while `map' isn't *overloaded*, it is *polymorphic* -- you can use it in many difference *instances* -- but the point is that `map' itself functions in exactly the same way here, it doesn't know (or care) what the element types actually *are*, as long as they "line up" correctly with the argument function
09:35:35 <lambdabot> Consider it noted.
09:35:38 <mekeor> =) ok =)
09:35:48 <alpounet> dcoutts_, i can try yeah. it should be in July, so i'll just watch for any OxHUG happening at that moment
09:35:49 <hpc> eats :: Animal a -> Animal b -> Bool
09:36:04 <hpc> eats (Bact a) (Bact b) = bacteriaEatsOther a b
09:36:10 <hpc> eats ...
09:36:10 <dcoutts_> alpounet: ah, I'm away much of July
09:36:43 <hpc> it'll still be a huge function, but not quite as huge
09:37:15 <alpounet> hah, alright
09:37:21 <mekeor> hpc: so what how did GADTs simply the task here?
09:37:29 <ski> hpc : "every-\"instance\"-being-clumped-together-ness" ?
09:37:37 <hpc> mekeor: uh
09:37:48 <hpc> mekeor: they didn't... i should have thought that one through
09:37:56 <dcoutts_> alpounet: will be around beginning and end of july, away in the middle
09:38:00 <hpc> yeah, ignore me
09:38:04 <mekeor> done.
09:38:11 <hpc> :D
09:38:17 <mekeor> hpc: heheh, srsly, thank you.
09:38:37 <alpounet> dcoutts_, ok. i'll keep you posted!
09:38:42 <hpc> np
09:39:35 * ski recently pondered the joys of making instances of `Eq',`Show',`Read' for an existentially quantified GADT thing
09:42:05 <ski> hpc : .. just curious what you meant
09:42:23 <hpc> ski: instead of class foo; instance; instance; instance
09:42:43 <hpc> ski: you have, data foo; f x = x; f y = y; f z = z; f ...
09:42:57 <mekeor> (pattern matches)
09:43:04 <hpc> ie, instead of three smaller f definitions, you have one enormous one
09:43:31 <ski> hm, ok
09:43:36 <zztr> in case this is logged and indexed, the answer to my problem was `sudo yum install postgresql-devel`
09:44:33 <ski> i had the problem that i had `exists x. (EverGrowingListOfClasses x) *> ..x..'
09:45:05 <mekeor> what's *> ??
09:45:14 <mekeor> did you mean => ?
09:45:25 <mekeor> ski.
09:45:29 <ski> `*>' : `=>' :: `(,)' : `(->)'
09:46:03 <mekeor> wtf.
09:46:12 <hpc> yeah, i don't get it either
09:46:23 <ski> "a : b :: c : d" means "a is to b as c is to d"
09:46:32 <mekeor> when hpc doesn't get it it's impossible to understand.
09:46:40 <hpc> heh
09:46:43 <hpc> i don't get lots of things
09:46:57 <hpc> but that one makes a special amount of un-sense
09:47:00 <nand`> coincidentally lots of things are impossible to understand
09:47:07 <ski> if i say `foo :: Blah => Result', this means that the caller needs to supply `Blah' to call `foo'
09:47:26 <ski> if i say `bar :: Blah *> Result', this means that the *callee* will supply `Blah', when calling `bar'
09:47:46 <mekeor> s/callee/caller/ # ?
09:47:58 <ski> no
09:48:09 <mekeor> ah.
09:48:14 <rwbarton> i still find the '>' part of the notation misleading
09:48:21 <monochrom> it means in GHC haskell, the notation is still "=>". however, people think that notation is more than punctuations and separators, so they actually read "=>" out loud as "implies", which is not nice for existential types, so they want a different punctuation "*>", except they won't admit it's just a different punctuation, they will chastise you on how much it means different.
09:48:22 <rwbarton> not that i have another suggestion
09:48:42 * ski isn't really happy with `*>' either, but hasn't figured out a better notation
09:48:42 <hpc> ski: so foo :: instance -> result, bar :: (instance, result)
09:48:48 <hpc> if classes were first-class arguments
09:48:49 <ski> yep
09:48:54 <hpc> now i get it
09:48:56 <rwbarton> (also it is worth noting that this is just ski's made-up notation afaik)
09:49:01 <ski> indeed
09:49:08 <hpc> with constraint kinds i think you can do that
09:50:02 <ski> monochrom : exactly
09:51:42 <ski> the problem was that i wanted to do more and more useful things with the existential, so i added more and more constraints inside it
09:52:10 <ski> then i realized i didn't actually *need* to carry around the kitchen sink
09:53:45 <kallisti> what's the standard way to test for Windows in CPP?
09:53:53 <monochrom> I would just follow Dijkstra and write "∀x : constraints : expression" and "∃x : constraints : expression". or replace : by | if : is ambiguous
09:53:53 <kallisti> I've seen MINGW32  and CABAL_OS_WINDOWS
09:54:59 <ski> monochrom : how about `data Foo a = MkFoo (Blah (Boo a => Bar a))' ?
09:56:46 <monochrom> my point is, how about dropping both "=>" and "*>", you just need punctuations so you can separate these 3 things: quantifier, constraint, main experession.
09:57:32 <ski> my point is, i'm not convinced the constraints always want to be accompanied by a quantifier
09:57:35 <rwbarton> "=>" is not necessarily directly tied to a quantifier though
10:00:32 <monochrom> alright, are "data Foo a = MkFoo (Blah (Boo a => Bar a))" and "data Foo a = MkFoo (Blah (Boo a *> Bar a))" the same? different? only the first one is allowed? only the second one is allowed? is "=>" really implication? etc etc
10:01:25 <ski> if both are allowed, then surely they are different
10:01:41 <tgeeky> dmwit: ping
10:01:41 <ski> (unless there is an FD `-> a' on `Boo a')
10:01:44 <Taneb> Hmm... UTF8, UTF16, or UTF32?
10:01:50 <hpc> 8
10:01:57 <hpc> usually
10:02:08 <ski> (.. and an instance, i suppose)
10:03:07 <monochrom> sounds like you haven't even decided what "X *> Y" is for when there is no quantifier
10:03:07 <Taneb> hpc, 8 it is!
10:03:42 <gdoteof> how do i print a fractional as a decimal.  get 1.5 from 3%2 i mean
10:03:54 <rwbarton> monochrom, if you think in terms of dictionaries then => is just -> while *> is just (,)
10:06:16 <armlesshobo> to make sure I've got this: "data Shape = Circle Float Float Float | Square Float | Rectangle Float Float Float Float"
10:06:29 <armlesshobo> Circle, Swuare, and Rectangle are values
10:06:31 <armlesshobo> possible values
10:06:36 <armlesshobo> Square*
10:06:39 <armlesshobo> of Shape
10:06:44 <byorgey> they are constructors
10:06:50 <byorgey> which construct possible values of type Shape.
10:07:00 <armlesshobo> value constructors
10:07:05 <byorgey> right
10:07:25 <byorgey> e.g. Square by itself is not a value of type Shape; it requires a Float argument
10:08:05 <armlesshobo> byorgey: right, okay
10:08:56 <armlesshobo> if I create a module first, can I use the module as a possible value?
10:10:22 <byorgey> armlesshobo: as stated, the answer to your question is no.
10:10:43 <byorgey> armlesshobo: however, it seems a bit confused so I'm not sure I really understand what you're asking.
10:10:47 <navaati> byorgey: where is diagrams' HEAD ? is it a git, a darcs ?
10:10:49 <byorgey> can you give an example?
10:10:55 <rwbarton> a module cannot be a value in any sense in Haskell
10:11:26 <byorgey> navaati: darcs.  all the diagrams-related repos are on patch-tag.com
10:11:50 <navaati> 'k. hum, i'll need to re-learn darcs…
10:11:51 <byorgey> navaati: see http://projects.haskell.org/diagrams/download.html
10:12:15 <navaati> thanks
10:12:17 <armlesshobo> ahh, I misspoke. I meant to ask if I can use any element of a module as a possible value for a created type
10:12:27 <armlesshobo> wait
10:12:28 <armlesshobo> ...
10:12:37 <armlesshobo> (i'm obviously scatterbrained today)
10:13:26 <byorgey> armlesshobo: you can use any type (even ones defined in the same module) as an argument to a constructor.
10:13:42 <armlesshobo> byorgey: yes, that's what I was trying to get at
10:14:03 <byorgey> data MyType = ...   data MyOtherType = SomeConstructor MyType | SomeOtherConstructor ...
10:15:36 <armlesshobo> so, you can nest data statements?
10:16:09 <tac-tics> armlesshobo: No. data must be declared top-level
10:19:10 * hackagebot hbayes 0.3 - Inference with Discrete Bayesian Networks  http://hackage.haskell.org/package/hbayes-0.3 (alpheccar)
10:21:32 <gdoteof> @hoogle Rational -> Double
10:21:33 <lambdabot> Numeric fromRat :: RealFloat a => Rational -> a
10:21:33 <lambdabot> Prelude fromRational :: Fractional a => Rational -> a
10:21:33 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
10:22:15 <gdoteof> i want to print a rational as a decimal
10:22:54 <kallisti> > realToFrac (2 % 2)
10:22:55 <lambdabot>   1.0
10:23:04 <gdoteof> kallisti: t
10:23:16 <kallisti> not to say there's not a better way that I'm not familiar with.
10:23:18 <ClaudiusMaximus> there is the floatshow package that might help if you need more digits, i've used it in my variable-precision package for big floats
10:23:26 <kallisti> but realToFrac converts between fractional types pretty well.
10:24:30 <ClaudiusMaximus> > show (fromRational (1/7) :: Double)
10:24:31 <lambdabot>   "0.14285714285714285"
10:25:33 <kallisti> shapr: do you think I should export mapFSTree and mapToTree?
10:25:45 <kallisti> it could be useful to someone perhaps.
10:25:57 <gdoteof> how do i get 0.143 out of fromRational (1/7)
10:26:13 <tgeeky> roconnor: I have an updated file that actually mostly works (though I am still stuck on what to do with "Id"). Let me know if you have time to peek.
10:26:15 <gdoteof> for display purposes
10:26:30 <ClaudiusMaximus> > showFFloat (Just 3) (fromRational (1/7) :: Double) -- in 'Numeric' module
10:26:32 <lambdabot>   Overlapping instances for GHC.Show.Show
10:26:32 <lambdabot>                              (GHC.B...
10:26:43 <ClaudiusMaximus> > showFFloat (Just 3) (fromRational (1/7) :: Double) "" -- in 'Numeric' module  -- oops
10:26:44 <lambdabot>   "0.143"
10:29:46 <gdoteof> @hoogle ShowFFloat
10:29:47 <lambdabot> Numeric showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
10:33:41 <dawe> hi
10:33:54 <mekeor> hi dawe. what's up?
10:34:16 <dawe> how are you, nothing
10:34:22 <dawe> :)
10:34:36 <mekeor> thanks, i'm fine, too.
10:34:53 <dawe> np, im new here
10:35:17 <mekeor> dawe: if want to talk more about non-haskell, consider joining #haskell-blah.
10:35:30 <mekeor> *if you
10:35:43 <dawe> is this room for haskell pro languge?
10:35:58 <mekeor> well, it's ABOUT haskell.
10:36:11 <dawe> yes :) thanks
10:36:12 <mekeor> but of course, if you know haskell you certainly love it, too.
10:36:42 <dawe> im in python but i want to dive into haskell ;) lol
10:36:56 <mekeor> good choice =)
10:37:06 <dawe> thnx
10:37:20 <mekeor> dawe: what did you motivate to switch to haskell actually?
10:37:43 <dawe> umm
10:38:04 <dawe> i heard good about i, strong ..
10:38:07 <dawe> it
10:38:14 <mekeor> curiosity?
10:38:26 <mekeor> strong type-system?
10:38:45 <dawe> yes
10:38:48 <mekeor> howbeit. did you start learning haskell?
10:38:59 <gdoteof> > showFFloat (Just 3) (fromRational (1/7))
10:39:01 <lambdabot>   Overlapping instances for GHC.Show.Show
10:39:01 <lambdabot>                              (GHC.B...
10:39:15 <mekeor> “learn you a haskell” is a good book to start learning haskell with.
10:39:21 <mekeor> @where lyah
10:39:21 <lambdabot> http://www.learnyouahaskell.com/
10:39:22 <gdoteof> > showFFloat (Just 3) (fromRational (1/7)) ""
10:39:23 <lambdabot>   "0.143"
10:39:30 <dawe> no still in 0 but i bought some books , and downloade alot
10:39:31 <gdoteof> > showFFloat (Just 3) (fromRational (1/7)) ''
10:39:32 <lambdabot>   <no location info>:
10:39:33 <lambdabot>      lexical error in string/character literal at chara...
10:39:38 <mekeor> gdoteof: btw, you can also PM lambdabot.
10:39:40 <gdoteof> what is going on with the double quotes ther?
10:40:11 <mekeor> dawe: just read LYAH. IMO, nothing more is necessary.
10:40:12 <gdoteof> :t showFFLoat
10:40:12 <dawe> learn you haskell , i think i have it
10:40:13 <lambdabot> Not in scope: `showFFLoat'
10:40:44 <mekeor> :t ''
10:40:45 <lambdabot>     lexical error in string/character literal at character '\''
10:41:02 <dawe> is this book enough?
10:41:07 <mekeor> dawe: yes.
10:41:17 <dawe> thanks bro :)
10:41:30 <mekeor> dawe: np dude
10:41:31 <dawe> u like python?
10:41:40 <mekeor> dawe: never tried it =)
10:41:56 <dawe> oh ok
10:42:19 <mefisto> anyone using leksah? is it in a state where you can be productive with it?
10:42:20 <dawe> do u think haskell is easy for beginner?
10:42:25 <armlesshobo> I can have different value contstructors for the same value, right?
10:42:29 <mekeor> dawe: but there are lots of other people who switched to haskell from python.
10:42:41 <mekeor> mefisto: there's also #leksah (or so), btw.
10:43:01 <armlesshobo> like data Shape = Circle Float Float | Circle Float Float Float | ...
10:43:04 <mekeor> mefisto: it requires GHC 6, IIRC. that's the reason why i don't/can't use it.
10:43:09 <dawe> i know , but they dont leave python right?
10:43:18 * tac-tics never left python
10:43:19 <mekeor> dawe: idk
10:43:52 <dawe> :) its k
10:44:34 <mekeor> dawe: haskell is probably not the best language to start learning programming. but if you know an other prog-lang, it's not hard to comprehend. just begin reading LYAH and everything will be fine.
10:44:52 <mekeor> armlesshobo: yea, that's fine.
10:44:54 <dawe> right
10:45:06 <mekeor> armlesshobo: where's the question? :)
10:45:31 <armlesshobo> mekeor: just making sure I wasn't thinking incorrectly ;)
10:45:46 <mekeor> ok :)
10:46:01 <BrianHV> that's fine?
10:46:22 <BrianHV> having two Circle constructors?
10:46:39 <mekeor> oh wait. i didn't see that. lol
10:46:50 <armlesshobo> so, no?
10:46:51 <gdoteof> mekeor: I wonder abou tthat.  i don't think many programmers come up on a functional style, i wonder if you started with that you wouldn'thave to go through the process of unlearning
10:46:57 <mekeor> hehe i didn't give attention to that; sorry.
10:47:08 <rwbarton> armlesshobo, no
10:47:23 <mekeor> gdoteof: hmmm… true.
10:47:33 <mekeor> sorry armlesshobo.
10:47:38 <armlesshobo> mekeor: it's ok :)
10:48:06 <armlesshobo> gdoteof: i think at some point, you'd have to unlearn something
10:48:18 <mefisto> mekeor: fwiw I'm on 7.4.1 and it seems to run ok
10:48:22 <armlesshobo> regardless of the order in which you learn a language
10:49:13 <mekeor> mefisto: whuuut? oO
10:49:51 <mekeor> mefisto: thanks for this information.
10:50:01 <c_wraith> learning haskell first will force you to unlearn all kinds of stuff going to... most... other languages. :)
10:50:03 <mefisto> gdoteof: I came from... an unnamed web programming language that begins with P... and learning Haskell reminds me a bit of when I tried to switch keyboard layouts. Especially when thinking about anything that has to do with state, I find myself reaching for the wrong key
10:50:48 <mekeor> PHP.. BAH!!
10:51:08 <mekeor> :)
10:51:19 <dawe> :D
10:52:18 * tac-tics works on his PHP code some more
10:53:28 <hpc> i should come up with more stuff for php-haskell-prelude...
10:53:28 * zztr reads http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/
10:54:10 <dawe> mekeor, the book is learn you a haskell for great good! " right?
10:54:58 <mekeor> @where lyah -- look here:
10:54:58 <lambdabot> http://www.learnyouahaskell.com/
10:55:04 <mekeor> dawe: ^
10:55:16 <dawe> ok will see
10:56:30 <dawe> wow yes i have it thank god
10:57:04 <dawe> thanks for advice #mekeor
10:57:16 <dawe> :)
10:58:42 <mekeor> dawe: the book is available online for free… http://learnyouahaskell.com/chapters .
10:59:29 <dawe> yes
11:00:15 <nand`> zztr: “PHP was originally designed explicitly for non-programmers (and, reading between the lines, non-programs)” <- there's one to remember, works for a lot of “manager-friendly” languages
11:03:02 <stepcut> mefisto: Dvorak?
11:03:45 <mefisto> stepcut: yea. I abandoned the effort
11:04:16 <stepcut> mefisto: I switched to Dvorak + Haskell 10 years ago and haven't looked back :p
11:05:06 <dawe> mekeor , nice to meet you :)
11:05:23 <dawe> sorry will go now
11:05:23 <zztr> stepcut: sweet i'm still on dvorak, but haskell hasn't yet stuck (which of course is why i'm here)
11:05:34 <dawe> see u , GB
11:05:41 <mekeor> bye
11:06:13 <dawe> bye
11:06:18 <armlesshobo> anyone else use colemak?
11:06:21 <zztr> the best thing about typing in dvorak is the expressions of frustration and confusion when someone tries to take the wheel at my machine
11:06:22 <armlesshobo> i heard it was fun
11:06:33 <armlesshobo> so I picked it up
11:06:40 * mekeor uses bone – a layout optimized for german.
11:08:19 <stepcut> zztr: yup
11:14:06 <tgeeky> jfischoff: pong
11:14:15 <tgeeky> jfischoff: lunch. bbiaf. check out: https://github.com/technogeeky/pi-eta-epsilon/commit/77906ea0d7b8242bf8c515a600ca3ab85ab0eb8a
11:16:59 <jfischoff> tgeeky: yeah I realized this morning that Id is for indentity
11:17:14 <jfischoff> I have been going to back to the original Pi.hs
11:17:16 <jfischoff> too
11:17:30 <tac-tics> mmmm Pie.hs......
11:17:43 <jfischoff> hehe
11:26:20 <kane77> I'm trying to solve Problem 67 of project euler (maximum sum of numbers traversing through a triangle/binary tree) and I tried something like "maxTrSum (Branch a b c) = (val a) + max (maxTrSum b) (maxTrSum c)" but this seems to be enumerating all the possible paths..
11:26:55 <kane77> the a is value of current node b and c are branches..
11:29:15 * hackagebot filesystem-trees 0.1.0.1 - Recursively manipulate and traverse filesystems as lazy rose trees.  http://hackage.haskell.org/package/filesystem-trees-0.1.0.1 (AdamCurtis)
11:29:39 <rwbarton> a triangle is not really a binary tree
11:30:23 <rwbarton> you need some kind of sharing
11:30:46 <armlesshobo> rwbarton: like a binary graph lol
11:30:48 <armlesshobo> something like that
11:31:08 <kane77> rwbarton, well, yes, I believe I parsed them correctly I would say..
11:31:25 <rwbarton> right, it specifically fails to be a tree, when you make it into a tree you are essentially enumerating all possible paths
11:31:28 <armlesshobo> a <-> b, a <-> c, b <-> c
11:31:41 <kane77> oh
11:31:46 <armlesshobo> yup
11:31:50 <kane77> I guess you are right..
11:34:27 <kane77> my solution seemed a bit too easy :D
11:35:01 <hpc> can someone with more hackage experience here sanity-check this package before i upload it?
11:35:05 <hpc> https://github.com/headprogrammingczar/php-haskell-prelude
11:35:12 <kallisti> >php
11:35:15 <kallisti> nope. sorry. there's no hope.
11:35:23 <hpc> kallisti: it's an Acme package
11:35:26 * kallisti checks it out. :P
11:35:48 <hpc> i am mostly worried about not missing any important cabal fields
11:36:00 <hpc> i only want the code itself to suck :P
11:36:48 <aristid> so that's what hpc stands for
11:37:05 <hpc> and i think you also got my real name...
11:37:06 <hpc> oh well
11:37:27 <hpc> it'll be on hackage anyway
11:38:07 <kallisti> hpc: you may be interested in stuff from my cond library. There's overloaded conditional operators, so you could easily make numbers/lists/maps with boolean contexts
11:38:13 <kallisti> hpc: cabal file looks fine.
11:38:18 <hpc> groovy
11:38:37 <dcoutts_> hpc: cabal check can help with that sometimes
11:38:52 <hpc> dcoutts_: yeah, i got cabal to shut up about everything, figured i would ask here anyway
11:38:57 <aristid> @src foldr
11:38:57 <lambdabot> foldr f z []     = z
11:38:57 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:39:08 <hpc> kallisti: i am more interested in messing with the standard type classes
11:39:14 <hpc> so you can add Int and String together
11:39:17 <hpc> and get a Bool
11:39:32 <copumpkin> wtf
11:39:44 <hpc> ima upload it
11:39:48 <aristid> hpc: i don't see the pun in your foldr
11:40:05 <kallisti> hpc: an overloaded boolean class would let you do a && b stuff on numbers, for example.
11:40:07 <hpc> aristid: foldr is correct, but doesn't fuse
11:40:24 <hpc> kallisti: ooh, thought you just did custom operators
11:40:25 <hpc> me like
11:40:38 <kallisti> well, I do.
11:40:40 <rwbarton> a && b on numbers, what could go wrong...
11:41:19 <kallisti> Data.Algebra.Boolean has all the usual boolean things http://hackage.haskell.org/package/cond-0.3
11:41:35 <kallisti> and then ToBool lets you use conditionals.
11:41:36 <aristid> hpc: ok, it's still not PHP-worthily bad
11:41:41 <aristid> hpc: work on it!
11:41:45 <hpc> aristid: i know!
11:42:31 <kallisti> hpc: and of course IO instance should use unsafePerformIO
11:42:43 <kallisti> *instances
11:42:44 <hpc> kallisti: of course
11:43:15 <hpc> kallisti: and when you use the boolean operators on IO actions in an IO context, it still behaves like unsafeInterleaveIO
11:43:39 <alpounet> and perform a GC, just in case.
11:43:54 <hpc> XD
11:43:58 * kallisti was actually considering adding seperate modules for "truthy" numbers and lists to cond, but decided against it.
11:49:16 * hackagebot acme-php 0.0.1 - The flexibility of Haskell and the safety of PHP  http://hackage.haskell.org/package/acme-php-0.0.1 (JoeQuinn)
11:49:50 <afarmer> wut
11:50:11 <Clint> i'm sure i've seen that before
11:50:32 <hpc> yeah, i just uploaded it to hackage
11:51:17 * afarmer had to check if it was April 1st
11:51:23 <Clint> Acme 1st
11:52:09 <kallisti> being a perl programmer, I have no qualms with dynamic typing and implicit type conversions, per se.
11:54:02 <aristid> hpc: _now_ i know your real name.
11:54:03 <hpc> kallisti: me either, so long as there's a modicum of thought put into it
11:54:30 <hpc> i like how many acme packages have multiple revisions
11:55:01 * kallisti only uploads quality production quality material to hackage.
11:55:09 <kallisti> :>
11:55:22 <hpc> acme-java would be fun to write one of these days
11:55:44 <hpc> ooh, or acme-clisp
11:55:46 * kallisti thinks a dynamic-haskell package would be fun. as in, not a joke.
11:55:58 <hpc> turn if-then-else into a quasiquoter, because conditions have to be macros
11:56:22 <hpc> kallisti: it would
11:56:28 <hpc> not even remotely safe, but fun
11:57:00 <kallisti> you could make it safe.
11:57:41 <kallisti> typically dynamic languages have a small set of built in data types. you could implement a set of those and define operations in a typesafe (but highly overloaded) way
11:58:26 <kallisti> so it depends on what you mean by safe.
11:58:45 <kallisti> there's no guarantee that the typechecker will save you from doing something you didn't mean to do, but there will be no actual runtime exceptions as a result.
11:58:59 <ski> doing dynamic checking with contracts might be fun
11:58:59 <hpc> heh, true
11:59:29 <ski> (a la Racket's higher-order ones)
11:59:56 <hpc> hmm, how about if you used ST
12:00:15 <ski> so when something breaks, you get information about which part of the system to blame
12:00:18 <hpc> and had a Dynamic type which was a GADT stuffed in an STRef
12:00:25 <kallisti> I think newtypes go a long way towards conveying your intentions about implicit conversions.
12:00:41 <hpc> then define all the primitives on Dynamic to perform addition and string length and stuff
12:00:57 <hpc> and maybe a lift function
12:01:06 * kallisti wouldn't use Dynamic at all.
12:01:20 <hpc> kallisti: not THE Dynamic
12:01:23 <hpc> but name it that
12:01:28 <kallisti> oh
12:01:39 <hpc> and it would be a GADT
12:01:52 <hpc> (+) :: Dynamic a -> Dynamic a -> Dynamic a
12:02:00 <hpc> or something like that
12:02:07 <hpc> probably heterogenous addition
12:02:39 * kallisti thinks cond is more or less a significant chunk of the plumbing needed to implement imperative-style DSLs in Haskell.
12:03:28 <kallisti> namely, the conditionals. :P
12:07:53 <eacameron> I'm looking at a stemmer in haskell: what does this mean? isVowel = (not .) . isConsonant
12:08:04 <eacameron> I don't understand the double usage of .
12:08:09 <hpc> :t (not .) . isConsonant
12:08:10 <lambdabot> Not in scope: `isConsonant'
12:08:19 <hpc> @let isConsonant = undefined :: Char -> Bool
12:08:20 <lambdabot>  Defined.
12:08:20 <hpc> :t (not .) . isConsonant
12:08:21 <lambdabot>     Couldn't match expected type `f Bool' against inferred type `Bool'
12:08:21 <lambdabot>       Expected type: Char -> f Bool
12:08:21 <lambdabot>       Inferred type: Char -> Bool
12:08:38 <hpc> uh
12:08:41 <hpc> @undefine
12:08:45 <kallisti> eacameron: imagine applying arguments to the function one at a time
12:08:50 <hpc> :t \f g -> (f .) . g
12:08:50 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
12:09:03 <hpc> eacameron: it's basically a double-deep function composition
12:09:07 <kallisti> ((not . ) . isConsonant) x = not . isConsonant x
12:09:34 <eacameron> hpc: kallisti: ahh...wow that's confusing. but I guess it works
12:09:51 <hpc> eacameron: it's much less confusing to define (.:) = fmap . fmap
12:10:03 <hpc> isVowel = not .: isConsonant
12:10:05 * kallisti thinks they're equally confusing
12:10:28 <osfameron> I thought you only needed .: for functions that take 2 parameters?
12:10:55 <hpc> osfameron: i figure isConsonant takes another param
12:11:02 <osfameron> ah, ok then :-)
12:11:09 <hpc> because (f .: g) = (f .) . g
12:11:29 <romildo> hoogle-4.2.11 does not compile on my ~amd64 system (using the haskell overlay): src/Web/Server.hs:64:51:
12:11:30 <romildo>     Couldn't match expected type `UTCTime' with actual type `ClockTime'
12:11:46 <romildo> Any help?
12:12:17 * osfameron notes you can also spell (.:) as (.).(.)
12:12:20 <eacameron> well the code is here: take a look http://tartarus.org/~martin/PorterStemmer/haskell.txt
12:12:28 * kallisti brazenly uses (f .) . g in real code without any shame.
12:12:29 <hpc> romildo: cabal update first?
12:13:28 <kallisti> Haskell in a .txt file? that's a new one.
12:14:16 <kallisti> eacameron: isConsonant should be defined on Char instead of String
12:14:19 <armlesshobo> kallisti: not all of us can afford *.hs files...
12:14:43 <kallisti> also using !! for linear traversal is atrociously slow on linked lists
12:14:52 <eacameron> osfameron: (.).(.) ... so haskell is a language of emoticons
12:14:52 <kallisti> but I don't know why I'm telling you this, since you didn't write the code.
12:15:09 <hpc> yeah, it's pretty freaky code
12:15:19 <eacameron> hpc: haha, is it?
12:15:24 <kallisti> it looks like it tries to account for y as a special case within a string.
12:15:33 <hpc> even "module Main\nwhere" is strange
12:15:33 <romildo> hpc, I am using the gentoo linux package manager to manage Haskell installation on my system. My system is up to date with the repository (called haskell overlay), which usually is kept updated.
12:15:40 <kallisti> which isn't going to ever work without some kind of advanced english language processing.
12:16:17 <romildo> hpc, I was hoping someone else has seen this problem with hoogle before ...
12:16:51 <hpc> no clue
12:17:08 <hpc> and i don't gentoo, so i don't know any hacky ways of fixing it yourself
12:17:13 <eacameron> hpc: kallisti: I'm new enough to haskell not to know what "freaky code" looks like
12:17:26 <hpc> with cabal, you could download the tarball, fix it, then cabal install
12:17:44 <hpc> but i wouldn't recommend that because you should stick with either everything from package manager, or everything from cabal
12:17:54 <kallisti> eacameron: the use of !! should immediately signal warnings in your mind.
12:18:22 <vraid> kallisti: what should be used instead?
12:18:50 <kallisti> either a different data structure, if you really need random access, or pattern matching on : and [] when you're really just doing linear traversal.
12:19:26 <hpc> eacameron: is that part of homework or something?
12:19:41 <hpc> that's pretty much the only reason i can imagine someone reading code like that which was made by someone else
12:19:55 <vraid> kallisti: what if you need only one element from an infinite list?
12:20:16 <eacameron> hpc: no...looking at bayesian classification and doing some stemming. I'm currently using Haskell and the C version of that stemmer and gluing them together with bash pipes, but I'd rather just do it all in Haskell
12:20:27 <kallisti> vraid: that's basically the only case where it's fine to do so.
12:21:01 <eacameron> hpc: this is for work
12:21:05 <kallisti> vraid: I mean that when you see !! being used you should immediately consider why it's being used and whether or not it's a good idea. not that it's always bad to do so.
12:21:05 <vraid> the same goes if you need a few elements of said list?
12:21:06 <hpc> eacameron: gotcha
12:21:13 <vraid> ah, got it
12:21:47 <vraid> i was using !! in some code i wrote for learning yesterday, so i had to ask
12:22:36 <vraid> it was a project euler problem to multiply the 10th, 100th, 1000th and some more decimals of a number
12:22:37 <kallisti> vraid: if you need more than one element from a list then !! is going to perform poorly.
12:22:54 <mefisto> it looks like a very sad person wrote that code
12:23:03 <nejucomo> Is there a standard haskell data structure for a sequence with O(1) length and index lookup operations?
12:23:13 <kallisti> vraid: that's an acceptable use case, for "small" numbers like that.
12:23:30 <vraid> what would a more efficient approach be?
12:24:19 <kallisti> nejucomo: Data.Array is part of the Haskell 2010 standard. I think most people use Data.Vector.
12:24:20 <vraid> only thing that comes to my mind is using "last take x"
12:24:32 <kallisti> also for strings strict ByteString and Text have O(1) lookup and length.
12:25:09 <hpc> vraid: instead of recursing with the same list and changing the index, recurse over the tail of the list
12:25:10 <kallisti> vraid: yeah you would want to use take
12:25:14 <kallisti> if you're using a linked list.
12:25:28 <hpc> if all your accesses are [0, 1, 2, 3, 4, 5, ...
12:25:48 <vraid> in this case, they were 10, 100, 1000, 10000...
12:26:36 <EvanR_> so first i was told that i should write my networking code with threads, then i was told to write my mud with threads to simulate the worlds inhabitants, ... should a video game use threads for each object? should we use threads for everything that used to be considered IO-bound, imperative, or object oriented
12:27:11 <kallisti> that's really too vague to answer. I think threads for handling blocking IO is a good baseline.
12:27:38 <hpc> im using threads for operations i don't want to block on until later
12:27:45 <kallisti> but "everything imperative and object-oriented" is probably too general for that to allow concurrency to be applicable to every concept that fits that description.
12:27:57 <EvanR_> dysfunctional stuff
12:28:26 <hpc> so for this one program i am writing, i have a monitor thread and the gtk thread both sharing an MVar ()
12:28:39 <kallisti> EvanR_: you should use threads for anything IO related.
12:28:45 <geekosaur> EvanR_, it's more that threads are what you use instead of an event loop (more precisely, are your interface to the event loop in the runtime)
12:28:46 <kallisti> and par for pure parallelism.
12:29:07 <EvanR_> geekosaur: right, and in a video game, there are 'events'
12:29:09 <hpc> monitor thread takes from the var, calls postGUIAsync to issue a redraw, then waits to cap the program at 60fps
12:29:10 <EvanR_> even if theres no IO
12:29:12 <hpc> then repeats
12:29:18 <vraid> hpc: hmm.. with foldl (*) (f ns xs), where f returns some elements of xs?
12:29:22 <hpc> the redraw action fills the mvar when it's done
12:29:45 <EvanR_> hpc: monitor thread?
12:29:52 <EvanR_> meaning, the video ?
12:29:54 <kallisti> talking about programming language paradigms in the context of threading doesn't make any sense. How do you determine that something is "object-oriented nothing" that it "now needs to become concurrent". I can think of reasons why you wouldn't want or need to do such a thing.
12:30:04 <hpc> EvanR_: no, in the "keeping track of" sense
12:30:05 <kallisti> er... s/nothing/enough/
12:30:10 <hpc> probably poor choice of wording
12:30:17 <EvanR_> ok
12:30:19 <hpc> all it does is tell the gtk thread when to redraw
12:30:25 <hpc> the program basically runs like a movie
12:31:36 <EvanR_> are the FRP libs concurrent?
12:32:09 <hpc> EvanR_: afaik, FRP itself doesn't have concurrent semantics, but it can be implemented with concurrency under the hood
12:32:42 <hpc> so, "probably"
12:33:01 <HFSPLUS> does tom brady have a machinehead?
12:34:06 <EvanR_> im having a brain explosion, perhaps inappropriately, now i see everything thats not a function (either because its some hardware thing or because of technicality like being on a different computer) as being a concurrent process
12:34:45 <hpc> EvanR_: lol, same here
12:39:00 <angstrom> I'm trying to model s-expressions as a data-type, and was wondering how I'd handle a constructor `Quote', for which the supplied function should act like `id', when making it an instance of Functor? or is this not possible?
12:40:24 <kallisti> angstrom: why do you want an instance of Functor?
12:40:55 <angstrom> because I want to map over it :-)
12:41:11 <angstrom> but only with functions of type `a -> a', anyway
12:41:12 <kallisti> then why do you want to ignore Quotes when mapping over s-expressions?
12:41:21 <kallisti> it sounds to me like you want your own function
12:41:28 <kallisti> there isn't really anything special about fmap.
12:41:38 <EvanR_> if the type matches up
12:41:43 <EvanR_> make it a functor!
12:41:51 <angstrom> hm. fair enough
12:43:10 <kallisti> EvanR_: unless your s-expression is parametric.
12:43:34 <EvanR_> what would that mean in this context
12:43:44 <kallisti> I don't know.
12:44:00 <kallisti> yeah actually that's not possible with Functor
12:44:08 <kallisti> because id is a -> a but fmap is a -> b
12:46:12 <EvanR_> has anyone played new super mario bros
12:46:46 <EvanR_> mario has always been on the cutting edge of platform game responsiveness, and i keep wondering how bad their code must be to represent that
12:47:32 <kallisti> wot
12:48:26 <hpc> EvanR_: that responsiveness is more a function of the design of the game than performance of the programming
12:48:38 <EvanR_> right
12:48:43 <newsham> does ghc support idiom brackets for applicative?
12:49:11 <hpc> newsham: i thought it did but then i was corrected, so i don't think so
12:49:24 <EvanR_> but to get that effect you could make it straightforward and declarative or basically write assembly language c++
12:49:30 <hpc> there's a TH package for it, i think
12:49:36 <hpc> but it's not really "idiom brackets"
12:50:09 <absence> i've seen both netwire and reactive banana recommended for frp. what's the main difference between them?
12:51:15 <bitonic> absence: netwire uses arrows heavily
12:52:11 <absence> is that good, bad, or neither? :)
12:52:23 <bitonic> neither
12:52:34 <hpc> absence: depends if you like arrows? :P
12:52:43 <hpc> i assume you can use both without touching arrows
12:52:47 <bitonic> but it makes a big difference in how the API is structured
12:52:58 <newsham> wow, this documentation is not very informative.  http://hackage.haskell.org/packages/archive/applicative-quoters/0.1.0.5/doc/html/Control-Applicative-QQ-Idiom.html
12:53:13 <absence> so it's a matter of taste?
12:53:39 <kallisti> newsham: source code is pretty straightforward
12:54:01 <ski> angstrom : it's not clear what the "elements" in your sexps would be
12:54:04 <bitonic> absence: the implementation is completely different as well, mm_freak can tell you more
12:55:29 <angstrom> ski: hm?
12:55:35 <ski> angstrom : .. with one way to model things, it'd be the things inside `UnQuote' which `fmap' would call the function on
12:56:01 <ski> angstrom : i'm just pondering what you want to do ..
12:56:19 <stepkut> is there a function like, smap :: (String -> String) -> (Text -> Text)
12:56:21 <kallisti> newsham: one thing I don't understand is why it calls return on the argument of the application
12:56:45 <kallisti> oh nevermind I see
12:56:56 <kallisti> there's a $(..) there. :P
12:57:08 <angstrom> ski: http://hpaste.org/68601
12:57:20 <kallisti> newsham: [i| f a b ... c] = pure f <*> a <*> b <*> ... <*> c
12:58:22 <ski> angstrom : hm, so the atoms are your element -- any reason why ?
12:58:35 <kallisti> applicate x = [| pure $(return x) |]
12:58:39 <kallisti> this line is broken though.
12:58:56 <ski> kallisti> :t applicate
12:59:08 <kallisti> applicate :: Exp -> ExpQ
12:59:14 <kallisti> http://hackage.haskell.org/packages/archive/applicative-quoters/0.1.0.5/doc/html/src/Control-Applicative-QQ-Idiom.html#i  :P
12:59:19 <EvanR_> stepkut: or (a -> b) -> (a -> a) -> (b -> b) ;)
12:59:24 <angstrom> ski: I have another data-type, Atom, that is used outside of Sexp as well
12:59:34 <ski> ok ?
12:59:53 <ski> do you ever want to use `fmap' to change the atom type in a sexpr ?
13:00:37 <angstrom> no
13:00:51 <angstrom> Sexp is exclusively used with Atom
13:00:52 <stepkut> EvanR_: don't you need (b -> a) as well ?
13:01:05 <ski> and do you ever intend to use a different atom type in any other place, inside a sexpr ?
13:01:13 <ski> (i assume the answer to this is also "no")
13:01:18 <angstrom> yes :-)
13:01:29 <ski> angstrom : then it seems to me that you don't really want/need `fmap'
13:03:28 <ski> (the only other thing which could reasonably make you want to use `fmap' here is if you want to use an interface which requires `Functor')
13:03:31 <kallisti> I wonder what kind of applications you could find for quasi quoters in patterns that view patterns don't already cover.
13:04:00 <hpc> kallisti: you can generate patterns, yes?
13:04:32 <kallisti> hpc: well, yes, that's what it does.
13:04:50 <kallisti> I guess you could use it to create virtual patterns.
13:04:57 <EvanR_> stepkut: ah yeah
13:05:27 <stepkut> I guess I want the Isomorphism class ..
13:05:32 <hpc> ooh, use it to write combined pattern/guards
13:05:37 <EvanR_> stepkut: heh
13:05:47 <EvanR_> how deep does the rabit hole go
13:05:53 <shapr> hpc: Call 'em locks? guarded until you have the right pattern?
13:06:10 <kallisti> hpc: that's pretty much what pattern guards is..
13:06:29 <hpc> shapr: more thinking just to abstract away common patterns of "match on these and then guard on some deep inner part of them"
13:06:52 <adamt> i have a set S that i need to split into T and U, and U then needs to be split into V and W. Obviously i can just partition twice, but is there a neat trick to do a 3-way partition in one go?
13:06:52 <kallisti> the only use case that really stands out to me is defining "virtual constructors"
13:06:56 <absence> bitonic: i guess i'll make some toy code with both and seee which i like then :)
13:07:32 <hpaste> stepcut pasted “smap :: (String -> String) -> (Text -> Text)” at http://hpaste.org/68602
13:07:59 <ski> angstrom : .. i.e. i'm suggesting making an `perAtom :: (Atom -> Atom) -> (Sexp -> Sexp)' function ..
13:08:11 <hpc> stepkut: there can be multiple isomorphisms for a type
13:08:23 <hpc> for a pair of types, even
13:08:42 <stepkut> hpc: newtypes FTW!
13:09:18 <stepkut> or maybe phantom types.. class Iso name a b
13:09:20 <hpc> stepkut: you'd need to newtype both parameter types
13:09:31 <ski> (there's infinitely many isomorphisms on `Integer', e.g.)
13:09:36 <hpc> and phantom types in classes are freaky
13:09:42 <hpc> i like data Iso a b better
13:09:58 <stepkut> hpc: with data kinds it is even more and less freaky!
13:09:59 <kallisti> phantom types in classes = you must use explicit type signatures for this to work.
13:10:16 <angstrom> ski: so you would advice against having a more general one of type `(a -> a) -> Sexp a -> Sexp a'?
13:10:18 <kallisti> oh and enjoy your FlexibleContexts pragma.
13:10:50 <ski> angstrom : i would probably advice against it, unless you have a specific *reason* to do it (and i think there could be such reasons)
13:11:12 <stepkut> kallisti: yeah, would also be nice if, data Proxy a = Proxy, was standard, so that you could use proxy types instead
13:11:49 <ski> angstrom : in any case, if you're thinking (only) about `(a -> a) -> (Sexp a -> Sexp a)', then `fmap' is inappropriate
13:12:51 <kallisti> :t fmap
13:12:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:16:46 <ski> angstrom : e.g. `data SExpr a = SAtom Atom | SList [SExpr a] | SQuasiQuote (SExpr (SExpr a)) | SUnquote a' might be interesting in some cases ..
13:20:20 * ski . o O ( `instance Iso a a where iso = id' )
13:20:32 <stepkut> :)
13:20:54 <stepkut> instance Iso String String where iso = rot13
13:20:58 <angstrom> ski: interesting, indeed. as of now, I'm somewhat unsatisfied how things, especially data-types, are factored :\
13:21:10 <ski> stepkut : `OverlappingInstances', bletch :)
13:21:14 <angstrom> s/how/with how/
13:21:16 <stepkut> ski: :)
13:21:34 <hpc> instance Iso a b where iso = unsafeCoerce
13:21:38 <stepkut> heh
13:21:42 <stepkut> best class eva
13:21:59 <ski> just use `iso = const undefined'
13:22:03 <kallisti> one types 5 is another types SYSSEGV
13:22:16 <hpc> ski: that's not an isomorphism though
13:22:28 <hpc> namely, iso . iso /= id
13:22:39 <ski> hpc : it's a subiso
13:23:19 * ski . o O ( Partial Equivalence Relations )
13:23:30 <hpc> ah :P
13:23:49 <ski> angstrom : ok -- maybe you'd like to elaborate on anything there ?
13:26:33 <angstrom> ski: well. I'm basically trying to implement an interpreter for a scheme subset using a SECD machine. one of the problems is, that the SECD machine can work with cons-pairs, for which I'm having a dedicated data-type, but I'm having the Sexp data-type as well, which is pretty much isomorphic to the cons-pairs
13:27:34 <angstrom> now I find it more comfortable to write the compiler using the Sexp data-type and convert where necessary, e.g. Quote
13:27:40 <ski> do you want to distinguish between the data lists and the code sexprs, or not ?
13:27:48 <angstrom> yes, and no
13:28:09 <shapr> I wish I'd saved that snippet that mm_freak pasted for walking directories...
13:28:15 <ski> i assume the code (normally) only juggles the lists
13:29:04 * shapr reads kallisti's documentation
13:29:32 <ski> also, i assume you want to try to be faithful to Scheme, instead of possibly doing your own variant, where it seems interesting/good/fun
13:29:33 <shapr> kallisti: Why don't the haddocks link here? http://hackage.haskell.org/package/filesystem-trees
13:30:08 <kallisti> shapr: hm?
13:30:17 <kallisti> they do.
13:30:25 <kallisti> maybe it just now generated the docs.
13:30:40 <kallisti> when you first upload a new version the docs aren't generated immediately
13:30:56 <ski> angstrom : how are you intending to handle hygienic macros ? -- or maybe you haven't even considered those yet (maybe skipping them) ?
13:30:57 <shapr> oh!
13:31:19 <shapr> That was unexpected. I'd rather it linked to a page that said "docs are generating, brb"
13:31:40 <angstrom> ski: right now I don't think about macros. there are things with higher priority, e.g. TCO
13:31:46 * ski nods
13:32:30 <angstrom> then again, it's for class, where only the SECD machine is /really/ required. but it turned out to be kind of fun :-)
13:32:49 <kallisti> ski: differences from 0.1:  a) added NFData instance for FSTree  b) added levels function c) fixed isSymLink so that it returns False when the file/directory doesn't exist, rather than throwing an exception
13:33:52 <kallisti> (c) is actually pretty important, because other functions use isSymLink
13:34:21 <ski> it might be ok to translate the list to sexp, partially, on-demand ..
13:34:39 <shapr> kallisti: That last one is especially handy.
13:34:56 <kallisti> yes it matches the interface of the other predicates.
13:35:10 <ski> kallisti : mhm ..
13:35:15 <kallisti> I figured NFData would be useful as well given the lazy IO behavior.
13:35:28 <kallisti> you may want to suddenly force the whole tree for some reason.
13:35:45 <kallisti> (and an NFData instance for Tree is mysteriously missing)
13:35:48 * ski isn't sure how common that would be
13:35:54 <kallisti> ski: me neither.
13:36:19 <kallisti> or either? I don't even know.
13:36:22 <shapr> Huh, ghci in emacs is suddenly version 6.12 ... I wonder how that happened.
13:36:49 <kallisti> people still use GHC 6?
13:36:50 <hpc> shapr: blame apt?
13:36:59 <shapr> Whoops.. time to clean out /usr/local/bin
13:37:39 <angstrom> ski: another problem is, that if I'd use the cons-pairs for the code as well, I'd have to clutter it up with Quote and such (which isn't needed for the data representation). but yeah, converting where required seems good enough for now
13:37:43 <hpc> kallisti: 7.0 does some things that made it really hard for me to install a few packages
13:43:40 <kallisti> shapr: I'm still pondering the idea of including a module for zipper operations
13:45:45 <kallisti> for example, there's currently no operation that moves a file "into" a directory tree, both on-disk and in the tree representation.
13:45:57 <kallisti> a zipper would make this easier because a zipper is conceptually similar to a filepath.
13:46:06 <cheater__> @ping
13:46:06 <lambdabot> pong
13:46:11 <cheater__> @help
13:46:12 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:46:24 <ski> kallisti : "neither", i think
13:49:06 <shapr> kallisti: Is there a way to move a file into a directory?
13:49:48 <shapr> kallisti: Where's drawTree?
13:49:52 <kallisti> in Data.Tree
13:50:18 <ski> angstrom : to be explicit, i was thinking about something like `List -> SExpLevel List' where `data SExpLevel a = SAtom Atom | SList [a] | SQuote a | SQuasiQuote a | SUnquote a' -- where you maybe want to inline `List' into `a' in `SExpLevel a'
13:50:29 <shapr> kallisti: I don't see it mentioned anywhere except that one line in the documentation.
13:50:47 <kallisti> shapr: you could do it with FSTrees but it would be really clumsy without writing a special function to handle that case. I would just use System.Directory for that.
13:51:05 <shapr> fgrep drawTree **/* shows only that one line.
13:51:11 <kallisti> shapr: I guess I assumed familiarity with Data.Tree
13:51:16 <yan_> is a RoseTree just a regular tree?
13:51:23 <ski> kallisti : keeping in mind that i still have a very vague idea of what you're really doing, i think it might be a good idea to be able to first walk through a whole filetree, checking things and making "a list", then only after that succeeds, actually perform the action list
13:51:25 <kallisti> a "generic tree" or a multi-way tree, yes.
13:51:29 <shapr> Oh, it's in data.tree, aha
13:51:54 <kallisti> ski: you mean like a filter?
13:52:00 <kallisti> or a map?
13:52:25 <ski> kallisti : i mean like first checking if everything you want to do can actually be done, before attempting any of it
13:52:52 <kallisti> oh yes.
13:52:59 <ClaudiusMaximus> kallisti: when i needed to traverse a directory, i ended up with a function like walkDirectory_ :: (FilePath -> IO ()) -> (FilePath -> IO ()) -> FilePath -> IO ()  with 2 callbacks, one for files and the other for directories  (and a similar version without _ suffix that collects results in a list)
13:53:35 <ski> (kallisti : in the general case, it's probably hard to avoid unexpected problesm -- but one could still *try* avoiding the most common ones)
13:54:01 <ClaudiusMaximus> i should have generalized the 'list of results' to a monoid, so that you could do what ski just described
13:54:09 <kallisti> ClaudiusMaximus: I just use ifM from the cond package, it makes it easy to handle that sort of behavior.
13:54:17 <kallisti> but at one point I had a combinator similar to that.
13:54:22 <ski> (e.g. the directory which you want to move a file to doesn't exists; permission error; &c.)
13:54:27 * hackagebot paragon 0.1.16 - Paragon  http://hackage.haskell.org/package/paragon-0.1.16 (NiklasBroberg)
13:54:31 <kallisti> ski: that should be possible with maps and filters already. I should add a fold as well.
13:54:47 <ski> kallisti : nice :)
13:55:21 <kallisti> I don't really export a standard interface for files though. you'd need to use unix and directory for those checks.
13:55:27 <kallisti> the only thing
13:55:37 <kallisti> is that there's isSymLink and isFile and friends.
13:55:42 <ewageerg> aᵢ
13:55:59 <kallisti> but I doubt I could handle permissions in POSIX and Windows uniformly enough to export my own interface that's easy to use.
13:56:43 <ski> yan_ : define "regular tree"
13:57:13 <hpaste> ClaudiusMaximus pasted “filesystem key-value store” at http://hpaste.org/68604
13:57:15 <yan_> ski: acyclic graph, general tree, 1 or more child nodes per node
13:57:59 <kallisti> shapr: filter is kind of clumsy to use in the common case. I think I should make a filter1 that returns a Maybe FSTree
13:58:13 <ski> yan_ : basically yes (keeping the info in the nodes)
13:58:32 <ski> kallisti> :t filter1
13:58:33 <colah> I'm running last nights GHC build and want to play around with DataKinds. I can't find GHC.TypeLits
13:58:40 <colah> What package should I install?
13:58:56 <kallisti> filter1 :: (FilePath -> Bool) -> FSTree -> Maybe FSTree
13:58:56 <ClaudiusMaximus> kallisti: ^^ that's what i ended up with to use the filesystem like a db for a tile-based zooming fractal renderer, but i'll probably end up using sqlite3 blobs (now that i figured out that sqlite3 on disk is really really slow to insert lots of items without a wrapping transaction)
13:59:00 <kallisti> as opposed to
13:59:05 <kallisti> filter :: (FilePath -> Bool) -> FSForest -> FSForest
13:59:46 <kallisti> ClaudiusMaximus: I'm for postgresql all the way
13:59:48 <ski> kallisti : giving `Nothing' when ?
13:59:58 <kallisti> ski: when the predicate fails on the whole thing
14:00:07 <kallisti> in other words root fails.
14:00:16 <ski> hm .. strange
14:00:19 <kallisti> yes. it is.
14:00:34 <kallisti> but note that root can only fail if all of its children fail
14:00:53 <ski> hm, i thought you checked the root before the children
14:00:57 <ismail6> Hey guys. I have a specific problem with a list:
14:00:59 <kallisti> if a directory fails a filter, it'll only be removed if all of its children fail as well.
14:01:04 <colah> I would have expected GHC.TypeLits
14:01:04 <ClaudiusMaximus> kallisti: me too for serious projects - but if i switch to postgresql for this, i'll make it "optional but recommended" with the sqlite3 backend "still there but discouraged" because it's quite easy to move sqlite3 dbs between systems easily
14:01:23 <kallisti> ...it's kind of weird but it fills the common use case where you have something like filter (`isSuffixOf` ".txt")
14:01:26 <kallisti> er
14:01:26 <colah> (agh, copy paste with enter) to be installed with GHC.
14:01:33 <kallisti> filter (isSuffixOf ".txt")
14:01:55 <ski> kallisti : i wonder about whether when one of the children fail -- does that one just disappear from the result then ?
14:02:00 <kallisti> ClaudiusMaximus: it's easy with postgres if you know what you're doing. ;)
14:02:02 <ski> s/whether //
14:02:10 <kallisti> ski: yes.
14:02:21 <ski> ok
14:02:26 <ClaudiusMaximus> colah: random guess - maybe it's in a hidden package? or not exposed from the package?
14:02:33 <ismail6> i want to implement a serie :: [Int] -> [Int], which does something like this: [1,2,3,4,..] -> [1+2,1+2+3,1+2+3+4,...], does anyone have an idea]
14:02:39 <kallisti> ski: it may be that I really want 2 different kinds of filters
14:02:45 <angstrom> ski: I don't think I understand your example :\
14:02:53 <ski> ismail6 : use a helper function having an accumulator
14:03:04 <kallisti> one with the behavior that's currently used, and another that works in the straight-forward pre-order way.
14:03:17 <kallisti> but I think typically you want to filter by file and not by directory
14:03:41 <kallisti> with the aforementioned filter behavior, filter (==".txt") would just result in Nothing in most cases.
14:03:42 <ismail6> ski: could you give me a closed expression? Or would it be a bit work?
14:03:45 <kallisti> because root would fail immediately.
14:04:00 <ski> angstrom : i mean when you have a `List', you want to "virtually" check what it's top constructor is, if we imagine it had already been converted to a `SExpr'
14:04:03 <kallisti> er filter (isSuffixOf ".txt")
14:04:15 <colah> ClaudiusMaximus: Hm. I'm running ghci, so cabal shouldn't be hiding it. And my understanding is that its the proper library to use with TypeLit stuff...
14:04:19 <ski> angstrom : a bit like `unfoldr', if you know that one
14:04:23 <ClaudiusMaximus> kallisti: i don't really know what i'm doing most of the time with postgresql, really, and i don't expect my (less than a handful) of users want to learn either :)
14:04:48 <ski> ismail6 : i could give you a closed expression, but you'd not learn as much then .. :/
14:04:58 <kallisti> ClaudiusMaximus: I only have a vague idea. but I know that pg-dump will basically output a huge list of SQL statements that you can use to re-initialize the database elsewhere.
14:05:00 <ski> ismail6 : do you know what an accumulator is ?
14:05:09 <ismail6> ski: i understand. then please explain what an accumulator is
14:05:20 <kallisti> or just the table structure if you like. there's a lot of options.
14:05:36 <ski> kallisti : i think there's room for both preorder and postorder (in some cases maybe even both at the same time)
14:06:07 <kallisti> ski: I'd love to know how that would work.
14:06:29 <angstrom> ski: where List would be the cons-pair data-type?
14:06:35 <ski> angstrom : yep
14:06:38 <kallisti> note that the find function is pre-order, but it works a bit differently.
14:07:02 <ski> ismail6 : consider a factorial function, defined like
14:07:14 <ski>   factorial :: Integer -> Integer
14:07:19 <ski>   factorial 0 = 1
14:07:28 <ski>   factorial n = n * factorial (n - 1)
14:07:33 <kallisti> find accumulates a list of trees that match a predicate, via a pre-order traversal.
14:07:36 <ski> this is *not* using an accumulator
14:07:51 <ski> an example evaluation trace of this is
14:07:56 <ski>      factorial 5
14:08:02 <angstrom> ski: I see. that makes sense indeed
14:08:04 <ski>   =  5 * factorial 4
14:08:10 <ski>   =  5 * (4 * factorial 3)
14:08:15 <ski>   =  5 * (4 * (3 * factorial 2))
14:08:21 <ski>   =  5 * (4 * (3 * (2 * factorial 1)))
14:08:31 <ski>   =  5 * (4 * (3 * (2 * (1 * factorial 0))))
14:08:35 <ski>   =  5 * (4 * (3 * (2 * (1 * 1))))
14:08:37 <ski>   =  5 * (4 * (3 * (2 * 1)))
14:08:41 <ski>   =  5 * (4 * (3 * 2))
14:08:45 <ski>   =  5 * (4 * 6)
14:08:47 <ski>   =  5 * 24
14:08:49 <ski>   =  120
14:09:04 <ismail6> okay. i got the first bit.
14:09:07 <alpounet> this is wonderful.
14:09:08 <ClaudiusMaximus> colah: http://hackage.haskell.org/trac/ghc/wiki/TypeNats seems to indicate you need a particular (non-default) branch?
14:09:13 <ismail6> I do the same just with sum
14:09:15 <kallisti> ski: the nice thing about the recursive copy and move operations is that they return the rerooted tree, so you can keep track of collections of files as you move them around.
14:09:22 <ski> the think we want to avoid here is the slanted slope of the recursive calls
14:09:59 <ski> the accumulator version is
14:10:00 <colah> CladiusMaximus: It's been merged into HEAD, as I understand. That's what got me to try it. http://www.reddit.com/r/haskell/comments/s0vln/ghc_head_now_has_type_level_natural_number/
14:10:05 <ski>   factorial :: Integer -> Integer
14:10:09 <adamt> ski: I thought ghc was ok with tail recursion?
14:10:19 <ski>   factorial n = factorialTimes n 1
14:10:21 <ski>     where
14:10:31 <ski>     factorialTimes :: Integer -> Integer -> Integer
14:10:38 <kallisti> ski: but sane exception handling seems to be the problem.
14:10:55 <ski>     factorialTimes 0 !acc = acc
14:11:11 <ski>     factorialTimes n !acc = factorialTimes (n - 1) (acc * n)
14:11:16 <alpounet> adamt, problem is after calling the factorial for the last time, you still have that stack of multiplications to do
14:11:19 <ski> and an example evaluation trace is
14:11:23 <ski>      factorial 5
14:11:30 <ski>   =  factorialTimes 5 1
14:11:40 <ski>   =  factorialTimes 4 (1 * 5)
14:11:43 <ski>   =  factorialTimes 4 5
14:11:48 <ski>   =  factorialTimes 3 (5 * 4)
14:11:53 <ski>   =  factorialTimes 3 20
14:12:00 <ski>   =  factorialTimes 2 (20 * 2)
14:12:14 <ski>   =  factorialTimes 2 (20 * 3)  -- oops
14:12:20 <ski>   =  factorialTimes 2 60
14:12:24 <ski>   =  factorialTimes 1 (60 * 2)
14:12:30 <ski>   =  factorialTimes 1 120
14:12:35 <ski>   =  factorialTimes 0 (120 * 1)
14:12:38 <ski>   =  factorialTimes 0 120
14:12:40 <ski>   =  120
14:12:56 <adamt> alpounet: I was of the impression it ended up as a jmp, making it rather irrelevant. Might be mistaken, didn't look at the assembly myself.
14:13:04 <ski> ismail6 : so, the idea is to make a helper function, which will keep the "current result" in an extra argument
14:13:33 <alpounet> adamt, well laziness kicks in. see the first evaluation trace
14:13:39 <ski> ismail6 : and then when you call yourself recursively inside it, you call yourself with the "updated" version of the current result -- finally in the base case the current result is (more or less) the final result
14:13:57 <newsham> its pretty closely related to:   while(cnt > 0) { accum *= cnt; cnt -= 1; }
14:14:02 <ski> adamt : the first example isn't tail-recursive
14:14:21 <alpounet> and you still have that multiplication to do, after calling yourself
14:14:29 <newsham> the tail call rebinds the args like assignment in an imperitive language and then loops
14:14:47 <adamt> ski: What is it then?
14:14:53 * ski likes how in Scheme, `do' is defined in terms of a tail-recursive procedure
14:14:58 <alpounet> it's just recursive
14:15:06 <ski> adamt : "direct recursive" is sometimes used
14:15:41 <ismail6> ski: i copied an pasted your suggestions to a text file, and will try to pattern match your example to my problem. I think this wil get me a bit further. Thank you very much for your help.
14:15:48 <ski> btw, note the suggestive naming with `factorialTimes n acc' here -- the idea being that this should be equal to `factorial n * acc'
14:16:37 <newsham> ski: except factorialTimes 0 n   :)
14:16:48 <kallisti> shapr: what are some file/directory operations you need to do for your code?
14:17:27 <monochrom> factorialTimes 0 n = n = factorial 0 * n
14:17:29 <newsham> oh wait
14:17:31 <newsham> i'm dumb
14:17:33 <ski> angstrom : the parameterized `SExpLevel a' might be useful -- or maybe it's better to hardcode the case where `a' is `List'
14:17:34 <newsham> ignore me :)
14:18:00 <adamt> Oh, i see why it isn't tail recursive now.
14:18:08 <ski> kallisti : ok
14:18:11 * adamt thinks accumulators look nasty.
14:18:38 <ski> if you can (sensibly) avoid them, then you probably should
14:18:56 <kallisti> accumulators are very well optimized though.
14:19:00 <shapr> kallisti: For the playlist builder, the starting point is just "walk these subdirectories, build m3u files ordered by dir name and then filename".
14:19:01 <adamt> so the first version of fac would blow up the stack here?
14:19:12 <mynameistake> Is there a way to get elements out of a data constructor when the contructor is not exported by a module? For example if I have data Foo = Foo Bar Baz is there any way to get the value of Bar if Foo is not exported?
14:19:27 <shapr> kallisti: I have lots of ideas to make it fancier, but for the moment, this is to refresh my clue about Haskell and surrounding bits like git, haskell-mode, etc
14:19:48 <kallisti> shapr: see that's the main problem with my current code; it doesn't provide any information about the files from the traversal, you need to repoll all of it.
14:20:16 * nejucomo notices accumulator discussion, sees '!' patterns and remembers a tabled question:
14:20:58 <nejucomo> Why do some data declarations use '!' in the constructor?  Wouldn't it be better to always avoid '!' in constructors and leave it to pattern matching code to decide on a case-by-case basis when to be strict?
14:20:58 * ski . o O ( `m * n = m * n + 0 where 0 * n + o = o; (m+1) * n + o = m * n + (n + o)' )
14:21:21 <ski> nejucomo : in some cases you want to avoid extra bottoms
14:21:23 <ski> @src Complex
14:21:24 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
14:21:28 <alpounet> nejucomo, sometimes you are just sure you always want a field to be strict
14:21:40 <alpounet> for the reasons ski mentions
14:21:46 <ski> here `0 :+ _|_' e.g. is *not* distinct from `_|_'
14:21:58 <nejucomo> Ah, okay.
14:22:04 <alpounet> or because you know you're better off evaluating it when creating the value containing that field
14:22:22 <nejucomo> Thanks.
14:22:36 <newsham> performance, sometimes
14:22:49 <Tomsik> Or sometimes you want a pessimistic run time guarantee
14:22:52 <Tomsik> instead of amortized
14:23:04 <alpounet> nejucomo, note that for some types, and with the -funbox-strict-fields option to GHC, it also automatically unboxes your strict fields
14:23:05 <nejucomo> So two of my recent questions in this channel have answers related to distinct values containing bottom versus bottom itself…
14:23:15 <nejucomo> Maybe I should read more about lazy evaluation.
14:23:15 <alpounet> (or you can do that manually with {-# UNBOX #-} )
14:23:42 <nejucomo> It's actually kind of crazy how I can write plenty of productive code even though I'm murky on laziness.
14:23:58 <ski> ismail6 : btw, note that i used `!' in the accumulative version to perform the multiplications in each progression step (instead of all of them at the end) -- in a strict language, this wouldn't be necessary -- but in several cases, you don't want/need this
14:24:19 <ski> ismail6 : in short -- you can probably ignore the `!'s in there, for the time being :)
14:24:20 <ClaudiusMaximus> colah: i had a look around github, and it seems the branch there isn't merged.. http://img88.imageshack.us/img88/2580/typenatsmasternotmerged.png
14:24:57 <ClaudiusMaximus> colah: might be a red herring as the github is just a mirror
14:26:18 <ski> kallisti : i'm not really sure how to do stuff with these trees -- are the trees built by lazy I/O ? -- do the conversion functions perform any I/O, or only schedule I/O to be performed later ? -- &c.
14:27:03 <kallisti> ski: which conversions.
14:27:10 <kallisti> getDirectory uses lazy IO
14:27:15 <kallisti> that's the only thing that does any lazy IO.
14:27:17 <ski> kallisti : you mentioned filters and maps, i think
14:27:31 <kallisti> filterM and mapM can use IO if that's the monad you want.
14:27:47 <kallisti> maybe my documentation sucks.
14:28:35 <nejucomo> It seems like this definition of WHNF is missing, for example, integer values: https://en.wikibooks.org/wiki/Haskell/Graph_reduction#Weak_Head_Normal_Form
14:29:06 <nejucomo> Would an integer value be considered a constructor?  (-or the value returned by a constructor?)
14:29:37 <kallisti> for Int, Char, and Word,  WHNF = NF
14:30:30 <kallisti> it's kind of murky whether or not numeric literals count as constructs.
14:30:31 <ski> nejucomo : for the purposes of WHNF, yes
14:30:40 <kallisti> *constructors
14:31:38 <colah> ClaudiusMaximus: Thanks. I'll try building from source.
14:31:38 * shapr castigates himself for not reading
14:32:47 <kallisti> ski: did I answer your question?
14:33:23 * ski isn't sure -- is atm trying to find the package
14:34:31 <kallisti> @hackage filesystem-trees
14:34:32 <lambdabot> http://hackage.haskell.org/package/filesystem-trees
14:34:37 <kallisti> hope that helps. :P
14:35:09 <kallisti> basically you would traverse the tree with map or mapM
14:35:14 <ski> yeh, just found that in backlog :b
14:35:17 <kallisti> to do some kind of action to every file/directory
14:36:55 <kallisti> in the future, it would be nice to have an actual tree representation with File and Directory tags so that you don't have to use IO predicates.
14:37:30 <kallisti> I think I have a pretty good scheme for how that should be organized. but it'll have to wait for now.
14:39:08 <RylandAlmanza> So, I'm looking to start game programming with haskell. I have lots of game dev experience in other languages, but almost no experience with haskell (I tried haskell in my browser, and that's it.) Where do I start? I can't comprehend how you would make a game without objects and classes.
14:39:46 <kallisti> are you familiar with Learn You a Haskell?
14:39:50 <shapr> RylandAlmanza: I'd suggest reading one of the free online Haskell books to get a better understanding of Haskell.
14:39:56 <kallisti> that's a pretty good starting point for learning how to write Haskell programs.
14:40:12 <ski> @where LYAH
14:40:13 <lambdabot> http://www.learnyouahaskell.com/
14:40:55 <RylandAlmanza> Thanks, guys. I'll take a look
14:42:35 <mroman_> I don't really see the line between game and "without objects and classes".
14:43:18 <mroman_> as neither do games in C have classes, nor the good old games written in pure assembler ;)
14:43:53 <Clint> those were all incomprehensible
14:44:18 <t7> i bet every game in haskell immitates classes with function pointers for update and draw etc
14:44:55 <geekosaur> Frag is FRP, isn't it?
14:45:12 <RylandAlmanza> Every language I've ever used extensively had objects and classes. I've only dabbled in C and Assembler, though I have a lot of c++ experience
14:45:24 <dmwit> ?index on
14:45:24 <lambdabot> bzzt
14:45:28 <dmwit> ?hoogle on
14:45:28 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
14:45:28 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
14:45:28 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
14:45:42 <dmwit> It's not in Data.Function here. =/
14:46:00 <geekosaur> although (a) technically that and OOP are orthogonal (b) if you insist on objects being the only way to think, I'm sure you can force it into the mold if you force it hard enough; you didn;t need all the pieces snaping off anyway, since you got it to fit\
14:46:05 <c_wraith> dmwit: how old is that ghc?
14:46:11 <RylandAlmanza> geekosaur: What's FRP?
14:46:30 <dmwit> c_wraith: 7.4
14:46:32 <newsham> ryland: haskell allows you to aggregate data into records, thats sort of like an "object".
14:46:42 <c_wraith> dmwit: huh. wonder if it moved
14:47:13 <dmwit> oh
14:47:24 <dschoepe> Does anyone know which GHC version turned off DatatypeContexts by default? (and is it a known bug that the user manual for 7.4.1 still says it defaults to being enabled): http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/data-type-extensions.html
14:47:24 <dmwit> ...I put "import Data.Function" in the wrong file. >_<
14:47:24 <RylandAlmanza> I'm not saying I'm only going to use objects, I'm saying I only have experience with objects
14:47:27 <newsham> you'd still have different shaped collections of data, ie. to represent a player or an enemy or the world, but what you wouldnt have is inheritance
14:47:31 <RylandAlmanza> I'm willing to learn new things
14:48:14 <geekosaur> functional reactive programming
14:48:16 <newsham> like in c++ you'd likely have   class Point { int x, y;  Point(int x, y); ... etc }    in haskell you'd ahve:  data Point = Point Int INt
14:48:16 * geekosaur sighs, it's motel notwork crapout rush hour again... dropped packets, lost connections...
14:48:24 <newsham> to aggregate together the data to represent a point
14:48:36 <newsham> and then you might have another aggregate for a player that incorporates the point for position information
14:48:40 <shapr> RylandAlmanza: you're in the right place for that :-)
14:49:22 <dschoepe> Ah, nevermind, I found it: it was 7.2.1
14:51:26 <RylandAlmanza> So, where can I learn about functional reactive programming? The haskell wiki doesn't say much about it
14:51:28 <newsham> http://www.haskell.org/haskellwiki/Game_Development  has some example games and videos and some docs (some of them quite advanced).  and mentions a #haskell-game irc channel
14:51:36 <shapr> RylandAlmanza: A typeclass lets you define some functionality, and then separately define implementations of that functionality for each type.
14:51:40 <newsham> i wouldnt recommend starting off with FRP
14:51:50 <ski> RylandAlmanza : have you used any functional programming language before ?
14:51:51 <shapr> Yah, FRP is exciting stuff.
14:52:01 <shapr> A bit too exciting for starting out.
14:52:17 <RylandAlmanza> ski: Nope. That's actually why I chose haskell, is because I wanted to try out functional programming
14:52:33 <ski> RylandAlmanza : if not, then you should probably start with the basics, until you know them
14:53:00 <ski> RylandAlmanza : i.e. unlearn mutable variables and iterating using `for' and `while'
14:53:41 <armlesshobo> ski: what do you use instead of mutable variables?
14:53:57 <RylandAlmanza> It's just a bit frustrating. I learn new languages all the time, and generally, I don't even have to use tutorials. The concepts are so similar usually, that I can just pick it up like that. With this whole concept of functional programming, I have to start from the beginning with tutorials and everything.
14:54:11 <shapr> RylandAlmanza: I totally agree! I had that same experience!
14:54:11 <armlesshobo> RylandAlmanza: same here
14:54:43 <shapr> It's like learning any totally new skill... at first it seems impossible, and after some work, it seems just mostly impossible :-)
14:54:58 <RylandAlmanza> lol
14:55:03 <dmwit> ...and then you can't figure out what seemed so hard.
14:55:06 <shapr> Right
14:55:07 <armlesshobo> the need to unlearn things to successfully code in haskell is what drives me to learn more about it.
14:55:16 <shapr> armlesshobo: I had that same experience! It was GREAT!
14:55:25 <armlesshobo> it being different just intrigues me
14:55:34 <shapr> And now people can't really read my Python code if I don't make an effort to write it idiomatically.
14:55:45 <c_wraith> Haskell is an extreme case. first-class functions and immutability were not foreign concepts for me. Ultimately, it has higher-kinded type classes that made haskell tough for me.
14:55:46 <armlesshobo> lmao
14:56:01 <newsham> haskell: improving your python code since _____.
14:56:03 <c_wraith> err, it *was
14:56:13 <hpc> shapr: and you can't really write your python code either because python has crippled lambdas
14:56:17 <hpc> :D
14:56:23 <newsham> # from shapr.haskell import *
14:56:26 <shapr> RylandAlmanza: What's your background? Have you used first class functions?
14:56:30 <vraid> armlesshobo: not unlearn as much as throwing aside your preconceptions
14:56:35 <shapr> newsham: Who knows what you might get...
14:56:38 <armlesshobo> vraid: right.
14:56:48 <newsham> hpc: python has perfectly fine closures.  you just have to name them.
14:56:53 <shapr> hpc: True, but there are some fixes for the most painful anti-FP Python confusions.
14:56:54 <armlesshobo> vraid: stop defaulting to things you already know outside of the language
14:56:54 <ski> armlesshobo : one answer is that you don't use them. another is that sometimes you use accumulators. a third is that if you really need them, you can get them
14:57:00 <hpc> c_wraith: higher-kinded types make perfect sense once you have parametric polymorphism down
14:57:02 <RylandAlmanza> bbiab
14:57:19 <newsham> "python has broken lambdas" is a red herring.
14:57:33 <c_wraith> python has so much syntax.
14:57:34 <hpc> newsham: just crippled
14:57:41 <newsham> hpc: still a red herring.
14:57:47 <newsham> in practice you just name all your lambdas.
14:57:50 <ski> shapr : like how unicyling seems impossible, say ?
14:58:06 <vraid> armlesshobo: the same goes for learning new natural languages, it is much easier if you make no assumptions of how the grammar works
14:58:11 <shapr> ski: Yes, exactly. And how Capoeira seemed impossible, and trig, and Swedish, and ....
14:58:16 <hpc> newsham: and in practice, it's annoying :P
14:58:17 <armlesshobo> vraid: precisely
14:58:23 <newsham> python has plenty of flaws, I just dont think "cripled lambdas" is even in the top 10.
14:58:27 <vraid> shapr: being a swede, i agree with that
14:59:02 <shapr> vraid: Nowadays Swedish seems straightforward and simple to me. Next term, I'm sure Português will seem impossible at first.
14:59:06 <newsham> vraid: its very helpful to make assumptions of how the grammar works when you're french learning spanish and italian.
14:59:11 <t7> why are they crippled?
14:59:12 <newsham> just less so when learning japanese
14:59:20 <t7> oh they share data or something?
14:59:22 <shapr> Also next term, I hope to learn Prolog as part of my classes, so I'm sure that will be the same thing.
14:59:23 <newsham> t7: in what way?  or for what reason?
14:59:30 <tac-tics> t7: You can't have a lambda in python with multiple statements for one
14:59:47 <newsham> the expression part of the lambda expr must be an expression. you cant use python statements
15:00:10 <tac-tics> And Python is also weird about non-anonymous closures
15:00:14 <vraid> newsham: you should learn which things you can safely assume, not blindly assume them
15:00:16 <newsham> but you can have named nested functions that are fully general.  so in practice you just dont use the lambda syntax when you want a fully general lambda
15:00:30 <shapr> newsham: yup, you just generate and return your own functions
15:00:45 <ski> shapr : yeah, Prolog is fun :)
15:00:58 <hpc> newsham: that's like saying "don't use for loops when a while will do"
15:01:14 <newsham> tactics: yah, I think the behavior with mutable captured variables in closures is much more of a wart.
15:01:37 <t7> i think closed over variables are the devil
15:01:48 <newsham> but higher on my list is that the generator fucntions cant directly recurse or directly recurse or span more than one function.
15:01:55 <shapr> ski: The instructor will assign each student one programming language and we all write papers about those language. I hope to get Prolog or some other logic language.
15:01:58 <newsham> they should have allowed more general coroutines that spanned multiple function decls
15:02:08 <hpc> shapr: you're gonna get php
15:02:16 <hpc> i just know it :P
15:02:35 <shapr> I certainly hope not!
15:02:46 <hpc> shapr: actually, if you get perl you should write about how to code in functional style
15:02:55 <hpc> functional perl is actually really fun
15:03:02 <newsham> implementing web services using visual php sharp...
15:03:19 <hpc> thanks to how it handles arrays/hashes and arg-lists
15:03:25 <ski> shapr : if someone else takes Prolog, you could try to volunteer with Mercury or lambdaProlog or Oz
15:03:42 <newsham> shapr: you should write more c++ and asm!  its fun!
15:03:43 <shapr> ski: Yah, but this particular instructor doesn't like it when I volunteer information.
15:03:51 <ski> oh, i see
15:04:11 <newsham> bad teachers for the lose :(
15:04:14 * shapr shrugs
15:04:45 <shapr> I've learned a lot in her classes so far. I view university as an opportunity for me to teach myself many things, with or without teacher assistance.
15:05:13 <newsham> for sure, but with is better
15:05:26 <newsham> esp if they encourage not discourage yoru creativity and personal exploration
15:06:06 <armlesshobo> i explore myself constantly, which is why I got fired :(
15:06:19 <tac-tics> armlesshobo: I got fired over Emacs
15:06:22 <armlesshobo> :O
15:06:36 <armlesshobo> i would fire you too for using such a horrible OS :(
15:06:37 <tac-tics> I fatfingered at my last job, commenting out a bunch of lines
15:06:51 <armlesshobo> ;)
15:06:51 <tac-tics> Client was annoyed, things got political, I was their scapegoat :P
15:06:53 <vraid> armlesshobo: is that how you lost your arm too?
15:07:00 <armlesshobo> vraid: LOL yes
15:07:01 <armlesshobo> :(
15:07:51 <newsham> ?remember armlesshobo < tac-tics> armlesshobo: I got fired over Emacs   < armlesshobo> i would fire you too for using such a horrible OS :(
15:07:51 <lambdabot> It is forever etched in my memory.
15:08:17 <armlesshobo> lol
15:08:29 <sipa> ?remember newsham implementing web services using visual php sharp...
15:08:30 <lambdabot> Nice!
15:09:35 <newsham> ?quote services
15:09:35 <lambdabot> fsbot says: English -> English: no matching translation services found.
15:09:56 <sipa> haha
15:10:02 <sipa> fsbot never heard of id
15:10:24 <angstrom> ski: thanks for your input, btw
15:10:50 <tac-tics> @quote
15:10:50 <lambdabot> mwc says: XML is like violence. If it doesn't work, use more.
15:10:56 <tac-tics> hehe
15:13:41 <tac-tics> guarded recursion means that all recursive calls happen in the argument position of a constructor function, right?
15:14:35 <roconnor> tac-tics: that is guarded co-recursion
15:15:21 <tac-tics> What is guarded recursion, then?
15:15:47 <roconnor> tac-tics: guarded recursion happens when the recursive call is made on a substructure.
15:16:06 <tac-tics> ah ok
15:16:13 <roconnor> (also guarded co-recursion has another requirement)
15:16:33 <tac-tics> so guarded corecursion is productivity
15:16:43 <roconnor> yes
15:16:46 <tac-tics> I'm wondering if the terms are used somewhat interchangably in Haskell, where everything is codata
15:17:03 <tac-tics> (I just found the term on the wiki, and it led to an unwritten wiki page
15:17:03 <roconnor> tac-tics: in haskell data and codata are the same.
15:17:18 <roconnor> though it does appear more like codata than data
15:17:41 <roconnor> I'm not quite sure how data types in Haskell are initial, but I'm told they are.
15:17:51 <roconnor> (as well as final)
15:18:18 <DrSyzygy> are they really though?
15:18:25 <roconnor> DrSyzygy: so I'm told
15:18:37 <DrSyzygy> initial and final produce different structures for things like X = 1+X
15:18:57 <roconnor> DrSyzygy: not in the category DCPOs  ... so I'm told.
15:19:00 <DrSyzygy> so [] is our usualy potentially infinite lists for one of them, and infinite streams for the other
15:19:06 <DrSyzygy> ... oookay.
15:19:46 <roconnor> DrSyzygy: you are right for the category set.
15:20:10 <roconnor> an honestly, I pretend I'm in set when programming anyways. :)
15:20:12 <DrSyzygy> ahhhhh
15:20:13 <DrSyzygy> right
15:21:15 <Saizan> the point is that infinite suc's in front of a bottom are quite the same as infinite sucs
15:21:51 <edwardk> suc on that
15:22:06 <DrSyzygy> Saizan: ARE quite the same or are NOT quite the same?
15:22:15 <Saizan> are
15:22:27 <DrSyzygy> Saizan: Also; how is DCPO different from Set for this?
15:22:58 <Saizan> DrSyzygy: you've bottom in every type
15:23:58 <DrSyzygy> Saizan: So in DCPO, initial and final X=1+X are the same because you can use bottom to terminate an infinite stream early?
15:24:02 <DrSyzygy> or something along those lines?
15:24:08 <ski> angstrom : if you'd want to mull over more what you're doing, &c., i could listen ..
15:24:51 <monochrom> sorry, what is DCPO again?
15:25:04 <dolio> Directed complete partial order.
15:25:19 <roconnor> DrSyzygy: http://www.fing.edu.uy/~pardo/papers/tcs.ps.gz ... If I recall well, the introduction of this paper explained this well.
15:26:51 <Saizan> DrSyzygy: or conversely that the limit which you use to calculuate the least fixed point starts from {_|_} rather than {}, so you can kickstart from that rather than staying flat
15:27:11 <DrSyzygy> right
15:32:19 <angstrom> ski: there's actually one more thing: right now I desugar some forms to more primitive ones, e.g. let to lambda, and this is done by pattern matching and "manually" restructuring the sexps. since this is done with the constructors, though, it's rather bloat. I've stumbled upon QuasiQuotation and it seems like this could make things easier to write and read. I'm not 100% sure about that, though, or whether there's another approach..
15:33:51 <tokoro> hi
15:35:58 <acowley> Finding a bug you've hunted for more than a day is such a bittersweet victory.
15:36:12 <nejucomo> hehe...
15:37:04 <ski> angstrom : "since this is done with the constructors" -- which constructors ?
15:37:35 <angstrom> ski: Sexp' ones
15:37:51 <ski> you have "smart constructors" you mean ?
15:37:56 <hpc> acowley: heh, ive tracked down bugs in our perl codebase to the point of "this grammar is context-free"
15:37:59 <hpc> those sucked
15:38:23 <angstrom> ski: I don't know what that means, so probably no. I'll post something
15:40:18 <Peaker> how do you tell cabal to build an executable with profiling enabled?  "cabal configure --enable-executable-profiling -p" and "cabal build" did not do the trick
15:40:35 <hpaste> angstrom pasted “desugaring sexps” at http://hpaste.org/68611
15:40:39 <angstrom> ski: ^
15:41:27 <ski> preflex: xseen vixey
15:41:27 <preflex>  vixey was last seen on freenode/##C 1 year, 345 days, 10 hours, 18 minutes and 43 seconds ago, saying: emphasis on 'might' :)
15:43:04 <ClaudiusMaximus> Peaker: not sure, that generally works for me (assuming i have prof versions of all libs installed)  - but i tend to have something like this in my .cabal file(s) too to avoid uninformative profile output... ghc-prof-options: -prof -auto-all -caf-all -rtsopts
15:43:56 <Peaker> ClaudiusMaximus, it builds my lib with profiling, but the executable is only built without, apparently
15:44:58 <ClaudiusMaximus> Peaker: oh - i didn't check that case (combined lib/exe in one package)
15:45:23 <ClaudiusMaximus> though i do have a package that uses that, i'll try it and report back
15:45:57 <dcoutts_> Peaker: --enable-executable-profiling will build the exe as profiling
15:46:00 <dcoutts_> what are you seeing?
15:46:19 <Peaker> dcoutts, it builds the executable without profiling
15:46:23 <Peaker> builds the lib in both ways
15:46:24 <ski> angstrom : i suppose i would probably combine `isLET' and `desugarLET' into a single function
15:46:35 <dcoutts_> Peaker: yes, it only builds the exe for prof, not both
15:46:46 <dcoutts_> it does not use --auto-all or other such flags, if you want those, specify them
15:47:16 <Peaker> the exe isn't built for profiling though.. in my .cabal's exe section, I do have:   ghc-prof-options:    -O2 -Wall -prof -auto-all -caf-all -rtsopts
15:47:49 <Peaker> after "cabal configure --enable-executable-profiling -p && cabal build", I use: "dist/build/Editor/Editor +RTS -p" and get "Editor: the flag -p requires the program to be built with -prof"
15:47:59 <dcoutts_> Peaker: you may need to clean if you previously did a build, I'm not sure ghc --make will rebuild it
15:48:30 <angstrom> ski: this makes sense for LET, but I have other desugaring functions where it makes more sense to seperate applicability-checking and applying, and I wanted to keep things symmetrical
15:48:31 <dcoutts_> note that -prof is not needed in ghc-prof-options
15:48:45 <Peaker> dcoutts, "cabal clean" was done too
15:48:57 <Peaker> this is the .cabal file: https://github.com/Peaker/bottle/blob/master/Bottle.cabal
15:49:00 <ski> angstrom : i haven't used TH very much, so i'm not sure you can use it when matching on data (like you can in MetaML)
15:49:46 <dcoutts_> Peaker: can you get a log of cabal build -v
15:50:26 <angstrom> ski: from what I've seen, it seems to be possible
15:51:06 <ski> angstrom : you're aware that `isLET (Sexp [Atom (Symbol "LET"),Sexp [],Atom (Symbol "x")])' is `False', right ?
15:52:23 <angstrom> ski: good point :-)
15:52:26 <applicative> Peaker: should you also be adding -prof and so on to the Library section, if you are doing it like this?
15:53:03 <hpaste> Peaker pasted “Build log” at http://hpaste.org/68612
15:53:28 <Peaker> my problem seems to clearly be that "cabal" ignores my request to build the executable with profiling
15:53:37 <Peaker> it goes ahead and builds it without profiling, apparently explicitly
15:53:48 <Peaker> dcoutts, http://hpaste.org/68612
15:54:04 <ski> angstrom : also, `isLet (Sexp [Atom (Symbol "LET"),Sexp [Atom (Symbol "x")],Sexp [Atom (Symbol "x")]])' is `True'
15:54:05 <applicative> hm
15:55:01 <angstrom> ski: yeah. the predicate for bindings is still missing. it's all work in progress!
15:55:34 <ski> angstrom : if you were merging the two functions, you'd get it more or less for free
15:56:27 <angstrom> true
15:57:38 <ski> (you'd have to make `unzip' use `Maybe')
15:58:35 <dcoutts_> Peaker: mm, odd indeed, what does cabal --version report?
15:58:57 <Peaker> cabal-install version 0.15.0 using version 1.15.0 of the Cabal library
15:59:58 <dcoutts_> Peaker: would you mind trying to reproduce it with the released 0.14.0?
16:05:33 <Peaker> sure
16:05:33 <ski> re RylandAlmanza
16:06:39 <Peaker> why does "cabal list cabal-install" say: "Default available version: 0.10.2" yet allows install of 0.14.0?
16:06:49 <Peaker> isn't "default available" the newest?
16:07:15 <dcoutts_> Peaker: that's why it says default rather than latest
16:08:30 <dcoutts_> Peaker: precisely because the default need not be the latest
16:08:37 <Peaker> what does "default" mean here?
16:08:48 <dcoutts_> the one you get if you specify no version constraint
16:08:56 <Peaker> network package fails to build: "Network/Socket.hsc:340:16: parse error on input `CALLCONV'"
16:08:58 <hpc> how does it pick?
16:09:01 <dcoutts_> ie cabal install foo, vs cabal install 'foo > =x.y'
16:09:18 <dcoutts_> Peaker: cabal install cabal-install-0.14.0
16:09:32 <RylandAlmanza> Alright, I'm back. Who was it that wanted to know my background and if I knew what a first class function was? The answer is that I have no idea what a first class function is. :)
16:09:35 <Peaker> dcoutts, Yeah, I know, I did that, and it now failed on the network dep
16:09:58 <hpc> how does cabal decide what the default version is?
16:10:01 <dcoutts_> Peaker: it should be fine with the network & http version you have already
16:10:08 <Peaker> I don't have any
16:10:32 <Peaker> hmm: "-- In order to process this file, you need to have CALLCONV defined." from where?
16:10:40 <dcoutts_> hpc: there's a set of prefs on hackage, in future it'll be easier for package maintainers to set that
16:10:59 <dcoutts_> hpc: the purpose is to let people release somewhat unstable versions without breaking everything
16:11:12 <hpc> dcoutts_: cool
16:11:41 <dcoutts_> Peaker: perhaps pick a different network version, there should be one that works ok with your version of ghc, e.g. one from the corresponding HP release
16:12:51 * dcoutts_ installs network-2.3.0.11
16:14:02 <Peaker> ok, installing from Debian sid
16:14:10 <Peaker> I forgot I had installed these packages from sid (I'm on Debian testing)
16:17:07 <Peaker> cabal install --dry-run -v -v cabal-install-0.14.0 <-- doesn't explain why it wants to reinstall "network"
16:17:13 <Peaker> -v isn't it anymore?
16:17:40 <dcoutts_> Peaker: is it simply that one of network's deps is being rebuilt?
16:18:14 <dcoutts_> not all reinstalls get marked with a note about changed deps, since the deps don't have to change
16:18:49 <Peaker> ok, I had a bit of a mess, cleaned it up
16:18:53 <Peaker> discovered what's wrong with -v3
16:18:59 <dcoutts_> mm?
16:19:07 <dcoutts_> oh, with the deps
16:19:10 <Peaker> my previous attempts to install network installed a bunch of deps
16:19:17 <Peaker> then install from Debian installed same deps on global side
16:19:39 <Peaker> so now I removed the shadow user-level packages
16:19:49 <Peaker> and install of cabal-install isn't reinstalling stuff
16:20:11 <kallisti> are you using --reinstall?
16:20:14 <Peaker> yay, got: cabal-install version 0.14.0 using version 1.14.0 of the Cabal library
16:20:45 <Peaker> hah, the Debian sid one is the same version
16:20:50 <Peaker> all this trouble for little gain :)
16:21:14 <Peaker> ok, now building bottle with 0.14.0
16:21:29 <ski> RylandAlmanza : hm, could have been me
16:21:47 <bos> lol jvm: http://engineering.linkedin.com/voldemort/voldemort-solid-state-drives
16:21:50 <Peaker> dcoutts, seems correct now
16:22:00 <Peaker> (so far)
16:22:09 <dcoutts_> Peaker: you mean the --enable-executable-profiling works?
16:22:33 <Peaker> yeah
16:22:36 <ski> > map (^ 2) [0,1,2,3,4,5,6,7,8,9]
16:22:38 <lambdabot>   [0,1,4,9,16,25,36,49,64,81]
16:22:39 <Peaker> I guess it was just a bug in 0.10 ?
16:22:55 <crewza> hey guys
16:23:11 <ski> RylandAlmanza : `map' ^ is an example of a higher-order function. in this case it was passed a squaring function `(^ 2)' as argument, which it then called on every element in the given list
16:23:27 <dcoutts_> bos: wouldn't we have the same issue?
16:23:40 <bos> dcoutts_: quite possibly.
16:24:12 <bos> dcoutts_: in fact it might be worse, since we don't account for memory pressure correctly with bytestrings or mmapped memory
16:24:17 <dcoutts_> when the GC heap size is bigger than the working set it's allowed by the OS, it's never going to be nice
16:24:23 <bos> (at least we used to not with bytestrings)
16:24:37 <dcoutts_> bos: yeah, I don't know if that is fixed or not
16:24:43 <dcoutts_> bos: certainly mmap is not counted
16:24:45 <bos> probably not, would be my guess
16:24:46 <acowley> Does anyone know if the holes mode for future GHCs is working yet in HEAD?
16:24:57 <dcoutts_> bos: I thought it might have been fixed
16:25:47 <Peaker> what's a good way to visualize a time profile?
16:25:48 <t7> anyone here use hackyll
16:25:50 <t7> ?
16:25:53 <Peaker> or at least sort by % of time used?
16:26:11 <t7> im not sure wether to use hackyll for my personal site/blog or snap and postgre
16:27:25 <dcoutts_> bos: I guess the take home message is using SSDs and removing I/O bottlenecks exposes the next set of bottlenecks
16:27:34 <bos> dcoutts_: pretty much
16:27:41 <jfischoff> acowley: Do you know if you can use the holes with TH?
16:27:42 <bos> dcoutts_: the jvm gc is notorious for needing tons of tuning
16:28:01 * dcoutts_ suspects we'd be no better there
16:28:09 <bos> dcoutts_: undoubtedly
16:28:13 <acowley> jfischoff: I don't know anything about the current status of holes support, but I wouldn't expect it to work with TH :/
16:28:54 <tgeeky> bos: re: the voldemort-ssd link -- that's a pretty cool problem to have
16:29:04 <bos> tgeeky: for sure
16:29:15 <jfischoff> acowley: hmm that would be too bad. I feel like custom deriving of functions could be very useful.
16:29:35 <RylandAlmanza> Ok, I need some help understanding something
16:29:47 <RylandAlmanza> What's the difference between this: lucky :: (Integral a) => a -> String
16:30:02 <RylandAlmanza> and this: lucky :: Integral -> String
16:30:36 <bitonic> RylandAlmanza: the second one is invalid
16:30:40 <bitonic> Integral is a typeclass
16:30:42 <bitonic> @src Integral
16:30:43 <lambdabot> class  (Real a, Enum a) => Integral a  where
16:30:43 <lambdabot>     quot, rem, div, mod :: a -> a -> a
16:30:43 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
16:30:43 <lambdabot>     toInteger           :: a -> Integer
16:30:50 <acowley> jfischoff: Absolutely it would be useful, but typing macros hasn't exactly been mastered by anyone afaik
16:31:20 <bitonic> RylandAlmanza: Integral a => ... puts a constraints on the variable `a', in other words you're saying "`a' must be an instance of `Integral'"
16:31:55 <dcoutts_> RylandAlmanza: if you're familiar with Java, Java interfaces are types themselves, in Haskell type classes are not types
16:31:57 <bitonic> RylandAlmanza: Integral -> String is using `Integral' as if it were a type, but it isn't (it's a typeclass instead)
16:32:33 <RylandAlmanza> Is Int a type in haskell?
16:32:40 <bitonic> RylandAlmanza: yes
16:32:43 <Hello_> Hello Everyone..
16:32:51 <c_wraith> :t length "hello"
16:32:52 <lambdabot> Int
16:32:56 <RylandAlmanza> Why couldn't I do this, then? lucky :: Int -> String
16:33:09 <dcoutts_> RylandAlmanza: you could
16:33:09 <Peaker> RylandAlmanza, it may sound superfluous, but then you get to more interesting types where the "a" appears in multiple positions in the type, and so it is useful to be able to say which parts in the type are equal, and put constraints on them at the same time (most OO interface specifications can't do this)
16:33:41 <c_wraith> need more information to answer that one.  The signature is legal - but it may not have matched the code you provided.
16:33:42 <Peaker> RylandAlmanza, Int is one concrete type, "Integral" is a type-class that has "Int" as a member/instance, but also many other instances
16:33:45 <dcoutts_> RylandAlmanza: suppose you had  lucky :: (Integral a) => a -> a -> String
16:34:31 <dcoutts_> RylandAlmanza: that tells you much more than (the invalid) Integral -> Integral -> String, because it tells you that it's the same 'a' in both instances
16:34:59 <dcoutts_> RylandAlmanza: that's an illustration of what Peaker was saying
16:35:42 <crewza> what is NWO?
16:36:17 <mdmkolbe> How do I get the preview-latex feature of auctex to work with lhs2TeX?
16:36:18 <hpaste> angstrom pasted “refactored LET desugaring” at http://hpaste.org/68615
16:36:43 <angstrom> ski: ^ that's what I arrived at :-)
16:37:03 <ski> angstrom : next time, annotate the original paste with updates :)
16:37:18 <angstrom> ah. didn't think about that :\
16:37:38 <ski> i see `unzip' looks broken
16:37:48 <RylandAlmanza> Man, I don't understand any of this! God, it's so fun!
16:38:11 <RylandAlmanza> I haven't not understood a programming concept in a long time!
16:38:13 <jfischoff> acowley: I thought typed macros were more of thing to ensure that during runtime the macro generates correctly typed code. I want to be able to get the context for a splice. So first treat the splice as a hole, and then let me query the type of the hole with Q monad or something similar.
16:38:26 <exFalso> hi, does anyone know how one can get around ghci's "runtime linker"? it seems to load every symbol from -l'd libraries and check for duplicates/undefineds. in my specific problem TH splicing triggers the runtime linker
16:38:39 <ski> RylandAlmanza : `Int',`Integer',`Float',`Double' are all concrete types. `Integral',`Num',`Eq',`Ord' are type *classes*
16:38:58 <ski> RylandAlmanza : the type of a value is always a concrete type. otoh a type class can't be the type of a value
16:39:23 <exFalso> ski: -XConstraintKinds
16:39:44 <ski> RylandAlmanza : you can think of each type class as a collection of types. `Eq' is the class of the types which support equality, `Ord' is the class of the types which support ordering/comparision operations
16:39:49 <exFalso> well not a type of a "value" tho
16:40:02 <ski> exFalso : was about to say that, yes :)
16:40:38 <crewza> its the right irc web? i am looking for someone who can help me, I will pay xD
16:40:50 <ski> RylandAlmanza : when we say `lucky :: Integral a => a -> a -> String', we mean that this operation is *overloaded* on all types `a' which are in the type class `Integral'
16:41:02 <exFalso> crewza: just ask
16:41:15 <ski> RylandAlmanza : in particular, this means that valid instances of the above general type signature for `lucky' are :
16:41:22 <ski>   lucky :: Int -> Int -> String
16:41:27 <ski>   lucky :: Integer -> Integer -> String
16:41:34 <ski>   lucky :: Integer -> Int -> String  -- but not this !
16:41:56 <crewza> [exFalso]: know, i want to get up my youtube views... a friend tell me about shell bot. irc bot... i dont understand what is
16:42:27 <exFalso> sorry not gonna help you with that
16:43:07 <ski> crewza : this channel is for discussion on the programming language Haskell, and related topics
16:43:09 <RylandAlmanza> Thanks for your help ski. I'm just having trouble wrapping my head around what a typeclass is in the first place.
16:43:38 <jfischoff> RylandAlmanza: do you know any other programming language?
16:43:54 <applicative> crewza: we do have excellent irc bots, but they're not going to help :)
16:44:01 <ski> RylandAlmanza : if you know Java or C#, you can think of them sortof as interfaces in those languages (but people will yell at me if i don't say it's not an exact correspondence :)
16:44:07 <exFalso> RylandAlmanza: a typeclass is a way to describe common functionality between types. for example such a functionality can be that instances of the type can be "added together"
16:44:23 <crewza> sorry, made a mistake, very sorry xD hahaha
16:44:27 <RylandAlmanza> jfischoff: I know almost every other programming language! (Exageration, but I do know a lot of them.) I've just never learned a functional programming language, I'm used to OOP
16:44:44 <crewza> the language haskell make what?
16:44:48 <Peaker> in GHC's profile, COST CENTRE, time%   is cumulative or self-time ?
16:44:57 <jfischoff> RylandAlmanza: what ski said
16:45:02 <ski> RylandAlmanza : type classes are *used* when one wants to *overload* an operation on different types, making it execute somewhat different code depending on the type (but still, the abstract behaviour should in some sense be "the same")
16:45:35 <RylandAlmanza> Woah
16:45:38 <RylandAlmanza> I get it
16:45:46 <RylandAlmanza> Thanks, ski, you made it click for me!
16:45:50 <ski> RylandAlmanza : e.g., equality on different types will need to run different code, but the same abstract concept of "are they equal or not" is used
16:46:01 <Peaker> somewhat like OO interfaces, on steroids, on steroids, on steroids :)
16:46:25 <RylandAlmanza> You guys are great. Thanks for being so patient with me!
16:46:59 <ski> RylandAlmanza : btw, note that `length :: [a] -> Int' e.g. is *not* overloaded, it is just *polymorphic* (it doesn't care what the element type in the list is, the same code is run in any case)
16:47:06 <crewza> its a programming language or its and group? project?
16:47:51 <ski> RylandAlmanza : still, we can say that the general `length :: [a] -> Int' has instances `length :: [Double] -> Int', `length :: [Array Int String] -> Int', &c.
16:48:12 <ski> crewza : Haskell is a programming language
16:48:42 <crewza> [ski]: its just because i never heard before, sorry for this.... its desktop or web language?
16:48:45 <ski> crewza : if you're interested in learning it, you're welcome to stay :)
16:49:34 <crewza> [ski]: i like learn my own. i know basic programming... just dont know what do
16:49:38 <ski> Haskell is a general programming language, can be used for both "desktop"-type and "web"-type stuff
16:50:29 <ski> RylandAlmanza : yw, we try to be friendly in here :)
16:51:06 <crewza> its great xD i am reading about it
16:51:40 <ski> RylandAlmanza : would you like me to elaborate a little more on the type class concept ?
16:52:15 <RylandAlmanza> Na, I think I got it. I'm moving on for now. :)
16:52:20 <monochrom> I think it's better to s/same/analogous/ in your description above
16:52:23 * ski nods
16:55:04 <acowley> A funny thing I blame Haskell for is that I sometimes type my code in a very, very nonlinear way. I jump around an expression filling in little bits.
16:55:27 <monochrom> I do that too. but not because of haskell
16:56:08 <hpc> i still write code linearly, but with respect to different things
16:56:14 <monochrom> the universal phenomenon is that stream-of-consciousness order differs from best-presentation order
16:56:40 * jfischoff nods
16:56:41 <hpc> for my current project, this means 1. write this tight-looping thread 2. write that tight-looping thread
16:57:26 <hpc> and between steps 1 and 2 is any shared state
17:01:42 <acowley> On a smaller scale than that, too. For instance, I usually know that what I want is a composition of a few things. Since the individual parts of the composition are so terse, there aren't many downsides to typing them in according to the stream-of-consciousness ordering monochrom mentioned. In imperative languages with less expressive type systems, I think the reordering of parts is (A) slightly more effort between me and emacs
17:01:42 <acowley>  (B) easier to get wrong.
17:01:51 <kyyqqp> is there a good "how to do stuff with lists" tutorial out there for haskell? figuring out the ways to combine the list functions to do what I want still seems unnatural to me, and I feel like I'm reinventing the wheel too often
17:02:14 <ski> angstrom : hm, you can use `fromMaybe' instead of `maybe' there
17:04:35 <hpc> i need to rework these data structures to manage animations...
17:04:52 <hpc> and can't decide where to put the progress through the animation
17:05:07 <crewza> can anyone hear my music and help me share? xD
17:06:13 <ski>   unzip (Sexp ss) = mapAndUnzipM unbind ss
17:06:21 <ski>     where
17:06:34 <ski>     unbind (Sexp [a,b]) = Just (a,b)
17:06:47 <ski>     unbind  _           = Nothing
17:07:01 <ski>   unzip  _        = Nothing
17:07:21 <angstrom> !
17:07:32 <angstrom> mapAndUnzipM is what I was looking for!
17:07:42 <ski> could possibly be written nicer with monad comprehensions
17:08:06 <aristid> @hoogle mapAndUnzipM
17:08:07 <lambdabot> Control.Monad mapAndUnzipM :: Monad m => (a -> m (b, c)) -> [a] -> m ([b], [c])
17:08:17 <monochrom> the next evolution is mapUnzipAndCleanYourKitchenSinkM
17:08:29 * ski nods solemnly
17:08:31 <aristid> monochrom: finally
17:09:01 <Peaker> I don't understand "SCC" annotations.. if I take a param x, and add an SCC annotation on its use, what am I annotating? Read of a simple result (O(1) cost) or the actual computation behind that var?
17:09:10 <Peaker> how do cost-centre annotations play along with IO costs? do I annotate an (IO a) expression to get its evaluation costs, execution costs, or both?
17:09:46 * ski would assume the evaluation, if nothing else was stated
17:11:00 <ski> angstrom : anyway, it could easily be written directly using `liftM'
17:12:18 * ski supposes crewza weren't that interested in learning Haskell, atm ..
17:20:07 <lpsmith> imports have gotten to be a major pain point;   how do people deal with imports?    Write code and figure out what you need to import later?   Have a standard big list of imports that you start with and have the compiler minimize it later?  Some kind of editor/ide magic?
17:20:37 <angstrom> ski: there is one more thing: eventually I'd like to have something like a REPL for this, but implementing this is kindof tricky, given how the SECD machine works. do you want me to expand on this? :->
17:20:51 <ski> sure, if you'd like to
17:20:56 <lpsmith> Get distracted every time you want use a function you haven't imported and add it to the import list?
17:21:16 <RylandAlmanza> Oh my god
17:21:18 <luite> hm i still want to learn chrisdones import handling stuff for emacs :)
17:21:22 <RylandAlmanza> recursion is powerful
17:21:31 <lpsmith> RylandAlmanza, oh yes :)
17:21:31 <ski> RylandAlmanza : indeed :)
17:21:53 <angstrom> the problem is with keeping state. as it's now, it's only possible to evaluate expressions, inside a default-environment which is basically one big letrec
17:22:08 <ski> (iteration in Haskell is ultimately done by recursion)
17:22:14 <lpsmith> chrisdone should be on IRC more often :-P
17:22:24 <ski> preflex: xseen chrisdone
17:22:25 <preflex>  chrisdone was last seen on freenode/#haskell 1 day, 4 hours, 37 minutes and 11 seconds ago, saying: ah okies
17:22:43 <ski> lpsmith : you could use `tell' or `ask' ..
17:23:01 <lpsmith> I don't really have anything to ask at this point, sadly
17:23:14 <lpsmith> other than a request to teach us emacs magic
17:23:46 <ski> angstrom : yeah, for state, you'll probably want to involve a monad
17:24:01 <gienah> lpsmith: he did that: http://www.youtube.com/watch?v=E6xIjl06Lr4
17:24:07 <angstrom> so I can't just evaluate `(define bla 42)' and then evaluate `bla'. one easy solution would be to keep track of previous evaluations and stuff them into the environmen, but that's rather meh
17:24:13 <ski> lpsmith : you could ask whether there's any nice resources available
17:24:35 <lpsmith> gienah, I hadn't seen that yet
17:24:53 <luite> unfortunately i think that even chris' scripts come anywhere near java ides wrt import handling
17:24:54 <ski> angstrom : i would probably initially mostly ignore the interactive toplevel environment
17:24:57 <lpsmith> I'd seen some youtube demos, but not a lot in the way of discussion
17:25:39 <gienah> lpsmith: its a demo on haskell-mode
17:26:17 <angstrom> ski: that's what I'm doing right now anyways. one compromise could possibly be to read in a file and add it to the environment
17:27:42 <Peaker> lpsmith, I get distracted each time
17:27:58 <RylandAlmanza> are we talking about IDE's?
17:27:58 <applicative> lpsmith, maybe you should just have a block of text with practically everything you ever use, then use -ddump-minimal-imports later
17:28:08 <Peaker> lpsmith, but I'm working on a structural editor for Haskell which should solve that issue (among many others) :)
17:28:15 <RylandAlmanza> Can I have a haskell IDE? otherwise, I'll just use VIM like usual.
17:28:28 <lpsmith> applicative, yeah I was thinking about that
17:28:40 <luite> RylandAlmanza: there's leksah and eclipsefp
17:28:48 <ski> also Yi
17:28:56 <ski> and Manatee
17:29:03 <geekosaur> is manatee maintained any more?
17:29:11 <luite> RylandAlmanza: but i think both are more or less a work in progress
17:29:12 <ski> preflex: xseen ManateeLazyCat
17:29:13 <preflex>  ManateeLazyCat was last seen on freenode/#haskell 64 days, 9 hours, 54 minutes and 46 seconds ago, saying: applicative: Gnome-Shell lies to on powerful with gjs, it use JavaScript, make desktop environment not stable enough, it use clutter library, make it can't running on ATI driver, i hate it.
17:29:16 <Peaker> so, ghc time profiling is only for evaluation, and does not count IO execution? What if I FFI some IO computations? Are these measured?
17:29:22 <Peaker> (how do I SCC those?)
17:29:34 <ski> RylandAlmanza : but vim is probably fine, as well
17:29:35 <luite> ski: isn't yi more a vim clone with haskell scripting than a haskell ide?
17:29:48 <ski> could be
17:29:59 <luite> i've never used it :)
17:30:13 <Axman6> leksah uses yi for its test editor i believe
17:30:18 <Axman6> text*
17:30:20 <ski> ok
17:30:34 <applicative> geekosaur: I think ManateeLazyCat is too busy writing desktop linuxes for China
17:30:59 <luite> i liked his auto-translated talk here :p
17:31:30 <applicative> i love him, in Haskell you can communicate across worlds
17:32:44 <lpsmith> one thing though is that I've never really used inferior mode ghci,  my long habit is just to have a terminal open next to emacs
17:32:45 <applicative> luites, yes, why learn English when you can automate it, that's how I feel about Chinese too I guess
17:33:57 <Peaker> what's the effect of:  threadDelay 0 ?
17:35:22 <applicative> I doubt it's the same as return ()
17:35:58 <luite> applicative: i tried some language learning site that someone suggested once, that gave you random words to practice. when the firs three (mandarin) chinese words sounded the same (but with different characters and meaning) i decided that learning chinese might not be a good idea
17:36:09 <XexonixXexillion> Peaker: I have assumed it is equivalent to yield
17:36:37 <Peaker> XexonixXexillion, I have just 1 thread, and it's greatly affecting performance
17:36:45 <Peaker> I guess it adds an epoll syscall there
17:42:10 <dukio> why does this not work in TryHaskell? map (1+) "ibm"::[Char]
17:42:23 <hpc> > 1 + 'i'
17:42:23 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
17:42:23 <lambdabot>    arising from the literal `1...
17:42:31 <luite> dukio: map succ would work
17:42:34 <hpc> :t succ
17:42:35 <lambdabot> forall a. (Enum a) => a -> a
17:42:40 <luite> dukio: but Chars arent Nums
17:42:41 <dukio> > map succ "hal"
17:42:41 <hpc> :t (1 +)
17:42:41 <lambdabot> forall t. (Num t) => t -> t
17:42:41 <lambdabot>   "ibm"
17:42:56 <dukio> > map (+1) "hal"
17:42:57 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
17:42:57 <lambdabot>    arising from the literal `1...
17:43:12 <dukio> so how do I do this?
17:43:41 <hpc> > map succ "hal" -- dukio
17:43:42 <lambdabot>   "ibm"
17:44:04 <dukio> > map succ "hal"
17:44:05 <lambdabot>   "ibm"
17:44:39 <dukio> but I want to do (+2) and (+3) etc.
17:45:25 <XexonixXexillion> > chr (map (+1) (map ord "ibm"))
17:45:26 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
17:45:26 <lambdabot>         against inferred type ...
17:45:31 <elliomax> What haskell packages should I use if I am using HTML?
17:45:35 <elliomax> HTML parsing
17:45:40 <XexonixXexillion> > map chr (map (+1) (map ord "ibm"))
17:45:40 <lambdabot>   "jcn"
17:46:18 <XexonixXexillion> > map chr (map (-2) (map ord "jcn"))
17:46:19 <lambdabot>   "*Exception: Prelude.chr: bad argument: (-2)
17:46:26 <luite> > map (chr.(+1).ord) "ibm"
17:46:28 <lambdabot>   "jcn"
17:46:44 <luite> ghc should rewrite your version to this
17:46:52 <luite> with the rewrite rules
17:46:53 <aristid> XexonixXexillion: no sections with (-), sadly. try subtract.
17:48:19 <XexonixXexillion> aristid: I know that... I don't know why I just tried that... I must be half asleep
17:48:43 <aristid> XexonixXexillion: nevermind then:)
17:55:01 <lpsmith> yeah, thanks gienah, that video is a step in the right direction
17:55:18 <lpsmith> (as far as demonstrating chrisdone-mode)
17:55:39 <rasfar> elliomax, TagSoup (lightweight, but not good for tree manipulation) or HXT (quite heavyweight, uses arrows which may be unfamiliar, but good tree handling). Others?
17:55:54 <lpsmith> I tried it out for a while last summer,  I forget why I stopped playing with it
17:56:55 <lpsmith> I suppose I shall have to give it another go
17:57:13 <elliomax> rasfar: thanks!
17:57:20 <rasfar> :)
18:00:57 <cmears> gwern: is wdg-html-validator the package you were talking about on the hakyll mailing list?
18:01:10 <gwern> cmears: yes
18:01:41 <cmears> It looks like it only has apache as a recommendation, not a dependency, so maybe it can be made to work for your case
18:01:45 <cmears> (but I'm just guessing)
18:03:03 <cmears> (also I'm not sure that it is HTML5)
18:04:53 <gwern> cmears: for me, it pulls in 'apache2-mpm-itk apache2-utils apache2.2-common libi18n-charset-perl libio-string-perl libjconv-bin libjconv2 libosp5 libunicode-map8-perl libunicode-string-perl opensp   w3c-dtd-xhtml'
18:05:04 <gwern> but maybe I should actually try this before I give up
18:05:06 <luite> is it possible to build just one of the core libraries of ghc (base, ghc-prim, integer-gmp) without touching the rest?
18:12:11 <XexonixXexillion> Is there an easy way to cause cabal to run a script before running GHC?
18:12:31 <dcoutts_> XexonixXexillion: what are you really trying to do?
18:13:15 <XexonixXexillion> dcoutts_: Trigger compilation of some ada libraries that the program will be linked against
18:14:13 <dcoutts_> XexonixXexillion: you can do all kinds of evil things using hooks defines in Setup.hs
18:15:09 <dcoutts_> there isn't really a good solution for agda with cabal at the moment
18:16:11 <XexonixXexillion> dcoutts_: Not agda, ada, but that does help, thanks
18:16:40 <dcoutts_> oh ada
18:16:59 <dcoutts_> XexonixXexillion: then you should just specify the external libs as extra-libraries in the .cabal file
18:17:06 <dcoutts_> and assume they're already installed on the system
18:20:26 <XexonixXexillion> dcoutts_: I was considering that, but they don't logically stand alone. They're two halves of the same program
18:21:37 <gwern> cmears: I think it does install an apache server. during the installation: 'Setting up apache2-mpm-itk (2.2.22-5) ... [....] Starting web server: apache2apache2: Could not reliably determine the server's fully qualified domain name, using 127.0.1.1 for ServerName ', and pgrep turns up stuff like '/usr/sbin/apache2 -k start'
18:21:42 <dcoutts_> XexonixXexillion: then perhaps a top level build script that invokes the ada and Haskell parts
18:22:32 <cmears> gwern: I had hoped that maybe it was installing it only because the package "recommends" apache, and you could just ask it not to install it
18:22:39 <gwern> nope
18:22:53 <cmears> oh, that's a pity
18:23:25 <cmears> The "unicorn" software from w3 looks like the right thing, but it's not packaged
18:24:01 <gwern> frick, they dropped the commandline tool *without updating the description*?! http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=458394
18:25:22 <cmears> ouch ):
18:26:30 <gwern> and the default settings don't just work either >.<
18:29:32 <huangyi> How many packages on hackage? Anyone knows a rough number?
18:30:04 <hpc> huangyi: approximately a lot
18:30:16 <hpc> though it may be as many as oodles
18:31:05 <hpc> huangyi: you can probably find somewhere on hackage with a nice list of packages that you can run some code on
18:31:10 <hpc> to get an exact number
18:42:35 <bert___> hi guys, I have a newbie question on ghci: why if I define s using "let s = sort", the type of s is :: [()] -> [()] instead of the maybe naive :: Ord a => [a] -> [a]?
18:43:10 <geekosaur> monomorphism restriction
18:44:27 <bert___> geekosaur: thanks, I have heard about that. now I have to understand why that applies here
18:45:46 <geekosaur> if you name a binding without any parameters, it's forced to have a single type instead of whatever polymorphic type it would have
18:46:14 <byorgey> (only if it would otherwise have type class constraints)
18:46:23 <geekosaur> normally defaulting would cause it to be [Integer] -> [Integer] but ghci has extended defaulting rules so it ends up [()] -> [()]
18:46:40 <byorgey> bert___: the usual recommendation (especially for newbies) is to turn it off.
18:46:43 <geekosaur> it's often recommended to disable the monomorphism restriction in ~/.ghci because it's rather annoying
18:47:44 <bert___> i see, makes sense, thanks so much for the explanation!
18:49:22 <solidus-river> anyone here compiled ghc from scratch?
18:49:38 <geekosaur> not recently
18:49:59 <RichyB> Yes.
18:50:04 <solidus-river> do you rememer how long it took you and what your proc was :/
18:50:27 <RichyB> About 2 or 3 hours on an old 1-2GHz CPU.
18:50:32 <solidus-river> i've been waiting on this haskell tutorial i'm going over for almost an hour now and it's still chuggin
18:50:41 <solidus-river> damn
18:50:52 <luite> solidus-river: parrallel make, -j8 or similar, really helps
18:51:11 <luite> should be doable in 20 mins on a recent cpu
18:51:15 <geekosaur> building ghc from scratch is not generally recommended; there should be packages for lots of platforms linked from http://haskell.org/platform
18:53:04 <luite> if you have an older single or dual core, better download the binaries :)
18:53:04 <solidus-river> luite: -j8! i'm only doing -j5 i thought the standard was number of logical cpus + 1
18:54:02 <luite> solidus-river: oh dunno if it helps on mine, i have a quad with hyperthreading, but -9 just sounds like too much ;)
19:02:36 <frontendloader> the current version in ubuntu 12.04 has a bug with the builtin bit counting function
19:02:48 <frontendloader> which is why I tried to compile it myself awhile back
19:03:35 <frontendloader> http://hackage.haskell.org/trac/ghc/ticket/5872
19:03:48 <frontendloader> so 7.4.1 is current in ubuntu
19:03:51 <byorgey> frontendloader: well, 7.4.2 is about to be released soon, which IIRC includes a fix for that bug
19:04:37 <byorgey> there's a release candidate out for it right now
19:04:38 <frontendloader> I'm not sure if theres a way to patch just that
19:04:44 <frontendloader> manually
19:07:11 <byorgey> frontendloader: well, I guess so, using git, but why would you want to do that?
19:07:27 * BMeph would like a binary of a 64-bit Windows GHC...
19:07:29 <frontendloader> oh I meant in place, without rebuilding the whole of ghc
19:07:49 <byorgey> no, I really doubt it
19:13:04 <luite> it's part of the ghc-prim package, with some hacking i think you could rebuild that and the things that depend on it, but it's probably more work
19:17:50 <otters> what is if'?
19:19:05 <monochrom> defined as: if' True x y = x; if' False x y = y
19:42:09 * applicative love to build ghc 
19:42:12 <applicative> loves
19:42:51 <Enigmagic> it's one of my favorite hobbies
19:44:18 <applicative> stage1 stage2
19:44:27 <applicative> what could be more pleasing
19:45:38 <gurrag> someone should write a DAW in Haskell and call themselves Haskrillex
19:47:57 <mgsloan> nono, just "Haskrill" would be sufficient :)
19:51:30 <gurrag> I wonder what the state of audio libraries is in Haskell
19:51:54 <gurrag> [by state I mean how developed they are, not the actual program state]
19:56:47 <JoeyA> There are zero text-to-speech libraries, as far as I can tell.
19:57:49 * applicative uses System.Cmd.system "say" ...
19:58:14 <nejucomo> From "http://www.haskell.org/cabal/users-guide/developing-packages.html" it looks like if I have a library and a program, I have to redundantly specify all of the modules imported from the library into the program (in the program source and the cabal file).  Is that true?
19:59:43 <applicative> -- Prelude System.Cmd> system "say NoMonomorphismRestriction"   sounds great
20:00:13 <applicative> nejucomo: I think the answer is yes
20:00:43 <nejucomo> This seems like superfluous busy work, unless I am missing something.
20:00:51 <JoeyA> I could be wrong, but: if the program simply calls into the library, you can just mention the library as the only dependency.
20:01:10 <nejucomo> What do you mean "simply calls into" ?
20:01:13 <applicative> https://github.com/jgm/pandoc/blob/master/pandoc.cabal see line 192ff
20:01:41 <JoeyA> import qualified My.Package.Main as M; main = M.main
20:01:58 <nejucomo> Is there any case where the "other-modules" field for a program is not directly equivalent to all of the imports of the library into the program?
20:02:00 <JoeyA> ... If you're getting problems, it's because your program isn't building against the already-installed library, but is referencing the modules by file.
20:02:40 <JoeyA> What I usually do is put the library modules in their own directory (e.g. hs-source-dirs: lib).
20:03:10 <nejucomo> Well, my cabal file has been working because I had duplicate program sections (for three separate programs) which included the entire library by dint of hs-source-dirs pointing to the library source.
20:03:10 <JoeyA> I hate this, though, since it pushes the files I work on the most down a directory.
20:03:27 <nejucomo> I want to change it so that the library is built once for all three programs.
20:03:39 <nejucomo> (-and it would be nice to expose the library to other consumers.)
20:04:08 <nejucomo> joeyA: That's what I'm doing now.  I have (effectively): ./lib and ./programs.
20:04:12 <JoeyA> Is it possible to omit the implicit (I think) . from hs-source-dirs?
20:04:20 <RylandAlmanza> so, I have a list. How do I retrieve an item from that list by it's index?
20:04:40 <applicative> > [1,2,3] !! 2
20:04:41 <lambdabot>   3
20:05:04 <JoeyA> Note that xs !! n is O(n)
20:05:09 <RylandAlmanza> thanks, applicative
20:05:13 <nejucomo> I include the library as a build-depends in the programs, but when building, ghc complains it cannot find the module imported (from the library).
20:05:17 <JoeyA> (for valid values of n, of course)
20:05:19 <applicative> and of course it not safe
20:05:35 <nejucomo> -oooh. I bet it's because I didn't list that module in exposed-modules.
20:06:07 <JoeyA> You should always put all of your modules under exposed-modules.  Well, unless you're not me.
20:06:10 * nejucomo wants to expose every module with minimal repetition...
20:06:23 <nejucomo> JoeyA: I tend to agree.
20:06:32 <nejucomo> I wish there were shorthand for this.
20:06:49 <nejucomo> I guess there is: find | sed.  :-/
20:07:20 <JoeyA> Or use a Real text editor (if you aren't already ;-) )
20:07:38 <JoeyA> err, are you spanning multiple files?
20:08:02 <JoeyA> If that's the case, you'll need emacs.  That editor can do anything, so I've heard.  </troll>
20:09:20 <JoeyA> I recently submitted a patch to postgresql-simple that adds some functions to the .Internal module, and I kinda wished Internal wasn't exposed.  Though from a user's perspective, I tend to prefer internal modules be exposed.
20:09:46 <JoeyA> I wish Data.ByteString.Internal.c2w was in Char8.
20:10:29 <liyang> That is totally not safe. If you want to go down that route, just unsafeCoerce!
20:12:38 <RylandAlmanza> How do I add something to the end of a list?
20:13:11 <RylandAlmanza> > 'a':['b','c','d']
20:13:12 <lambdabot>   "abcd"
20:13:18 <RylandAlmanza> that adds to the frond
20:13:21 <RylandAlmanza> front*
20:13:30 <RylandAlmanza> but I don't know how to add to the end
20:13:49 <RylandAlmanza> wait
20:14:06 <RylandAlmanza> > ['b','c','d']:'a'
20:14:06 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]]'
20:14:07 <lambdabot>         against inferred ...
20:14:14 <RylandAlmanza> oh, that didn't work
20:14:29 <geekosaur> :t (:)
20:14:30 <lambdabot> forall a. a -> [a] -> [a]
20:15:03 <gurrag> > ['b','c','d']:['a']
20:15:04 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
20:15:04 <lambdabot>         against inferred ty...
20:15:14 <geekosaur> lists are not very good for that kind of access, so there;s nothing better than
20:15:50 <RylandAlmanza> geekosaur: What would someone use to store values to represent tiles on a map?
20:17:04 <geekosaur> > ['b','c','d'] ++ ['a']
20:17:06 <lambdabot>   "bcda"
20:17:06 <geekosaur> (sorry, network barfed yet again.  using a bouncer so I don't end up spewing connect/disconnect all the time, but still)
20:17:21 <RylandAlmanza> aha
20:17:25 <RylandAlmanza> thanks, geekosaur
20:17:55 <geekosaur> RylandAlmanza, a list in haskell is best considered as a data structure representing a loop.  it's not good for random access, or anything other than stepping through it starting from the head
20:18:47 <liyang> A loop? You don't mean a (singly-)linked-list?
20:19:22 <JoeyA> I'm pretty sure "loop" was meant.
20:20:29 <RylandAlmanza> Wait, so I still shouldn't use lists?
20:20:29 <rwbarton> loop as in for/while/etc. loop, not as in cycle
20:20:33 <RylandAlmanza> "What would someone use to store values to represent tiles on a map?"
20:21:00 * liyang thinks that's a somewhat obtuse way to think about lists.
20:21:10 <JoeyA> If it's mutable, a mutable Vector or Array.
20:22:02 <JoeyA> Or you could use Data.Sequence, if you want pure functional benefits (e.g. free rewind).
20:22:33 <JoeyA> Except Data.Sequence is slower than an array for random access.
20:22:39 <JoeyA> (mutable array, that is)
20:22:59 <RylandAlmanza> where can I get information on arrays or vectors in haskell?
20:23:41 <Axman6> google
20:23:51 <Axman6> the docs are quite easy to find
20:24:02 <JoeyA> http://www.haskell.org/ghc/docs/6.6/html/libraries/base/Data-Array-ST.html  bam!
20:24:07 <JoeyA> (jk, that's *really* old)
20:24:33 <RylandAlmanza> google result: Haskell API docs suck. A lot. « All Unkept
20:25:16 <JoeyA> Use Hoogle instead http://www.haskell.org/hoogle/
20:25:34 <JoeyA> Or Hayoo, which searches all of Hackage: http://holumbus.fh-wedel.de/hayoo/hayoo.html
20:25:46 <RylandAlmanza> thanks, JoeyA
20:26:59 <JoeyA> As for API docs concerning mutable arrays, see http://hackage.haskell.org/packages/archive/vector/latest/doc/html/Data-Vector-Mutable-Safe.html and http://hackage.haskell.org/packages/archive/array/latest/doc/html/Data-Array-MArray-Safe.html
20:27:41 <JoeyA> Vector is newer and faster and sexier and such, but Array has a nicer API for working with multi-dimensional arrays.
20:28:25 <RylandAlmanza> brb
20:30:07 <JoeyA> Second google result for "haskell mutable arrays": http://www.haskell.org/ghc/docs/4.08.2/set/mutablearray.html
20:31:11 <JoeyA> (GHC 4.08 was released in July 2000)
20:31:36 <JoeyA> I'm pretty sure Google was around back then.
20:36:12 <hpaste> tgeeky pasted “can someone tell me why hlint is suggesting this” at http://hpaste.org/68618
20:37:38 <tgeeky> oh. just to deduplicate that list.
20:40:00 <coppro> what is the preferred way to implement a typeclass which has additional methods that apply only if a condition is met
20:40:18 <coppro> normally I'd model this with another class, but then I can't get from A to B
20:43:37 <matthiasgorgens> coppro:  You could allow people not implement all methods of your typeclass in their instances.  but that doesn't sound very preferred to me.
20:43:44 <matthiasgorgens> *to.
20:43:47 <coppro> yeah
20:43:53 <coppro> you do understand what I mean by this, yes?
20:45:13 <m_stone> bos: pardon the interruption, but can you spare a moment for a pair of newbie llvm questions?
20:46:20 <bos> m_stone: maybe?
20:46:31 <m_stone> bos: thanks; working on typing the questions. :-)
20:46:56 <m_stone> bos: question 1 is about the high-vs.-low-level bindings and how to introduce string literals.
20:47:06 <m_stone> the background is that I'm working on compiling a small language of boolean functions over strings and I'm getting stuck trying to implement my string equality opcode.
20:47:30 <m_stone> typically, the opcode will have a left and right argument, which might be a literal and a variable to compare.
20:47:50 <bos> m_stone: i'm reworking the string literal support as you type
20:48:06 <m_stone> oh, excellent! that sounds promising indeed. :-)
20:48:36 <bos> but the long and short of it is "use withString"
20:49:06 <m_stone> bos: yeah; the problem that I'm running into is that (I *think*!) I want to forget the size of the resulting arrays.
20:49:22 <bos> huh
20:49:42 <m_stone> in other words, while I know the size of my string literals, I really want to create pascal-style (ptr, len) structs for each one.
20:50:06 <m_stone> (also, I'm very open to other suggestions for how to do this; this is just the approach that I was pursuing this evening)
20:50:12 <m_stone> so far, I tried two things:
20:51:18 <m_stone> a) using something like "strPtr <- liftCodeGenModule $ withString str return", (which doesn't work the way I want)
20:52:26 <m_stone> b) folding over the program I'm trying to compile at the start of my compilation routine to find all the string literals, then using withString to introduce them all and capturing the results in a map (which doesn't work because the resulting strings all have different types due to their differing lengths)
20:53:21 <bos> couldn't you use "string"?
20:53:31 * m_stone looks
20:54:06 <bos> it won't annotate the type with its length
20:55:17 <m_stone> bos: which module contains "string"?
20:55:36 <bos> LLVM.Core.CodeGen
20:56:42 <m_stone> that package is hidden in llvm-3.0.0.0. Is the routine exported elsewhere, or did you mean "could you use the source code of `string`...?"
20:56:50 <m_stone> *module is hidden
20:57:00 <bos> oh, oops, i didn't realize it was hidden
20:57:30 <m_stone> so ghci tells me, anyway, when I add "import LLVM.Core.CodeGen" :-)
20:57:33 <bos> ok
20:57:37 <bos> hang on, laundry calls
20:57:45 <m_stone> certainly, and thanks very much for the help!
21:01:34 <tactics_> CT question
21:02:14 <tactics_> If F is a functor and f is a morphism in the origin category for F, is F f the notation used to mean fmap f?
21:02:24 <copumpkin> yaeh
21:02:36 <tactics_> kk
21:02:43 <tactics_> I'm learning about F-algebras
21:02:48 <rwbarton> more like fmap f is the notation used to mean F f :P
21:02:49 <tactics_> because I'm sick of not knowing what co-induction means
21:02:50 <copumpkin> you can "apply" F to both objects and morphisms
21:02:54 <copumpkin> they love to overload notation
21:03:01 <tactics_> Yes
21:03:15 <m_stone> copumpkin: bah; the arrows-only definitions is so much cleaner! :-)
21:03:19 <tactics_> It's the one thing that keeps me from ever becoming a physicist, mathematician, category theorist, or well-rounded human being.
21:03:30 <copumpkin> :)
21:04:00 <tactics_> copumpkin, did you see my question in #idris earlier? You seem like someone who might have an opinion on it.
21:04:24 <tactics_> Basically, what are the pros and cons of using (l : List A ** so (length l == n)) versus Vect A n?
21:04:41 <tactics_> or, invariants "on the side" versus "baked into the datatype"
21:05:23 <copumpkin> so takes a bool to a set?
21:06:40 <tactics_> yeah
21:06:54 <tactics_> more or less
21:06:59 <dolio> FA with objects, Ff with morphisms, Fφ with natural transformations.
21:07:08 <tactics_> data so : Bool -> Set where oh : so True
21:07:16 <tactics_> (Don't you just love the pun?)
21:07:18 <rwbarton> no
21:07:25 <rwbarton> :P
21:07:32 <copumpkin> tactics_: well, I don't think the decidability is just a theoretical consideration
21:07:45 <tactics_> well, assuming it then
21:07:47 <copumpkin> if you need to carry a function, you can't write a bool-valued thing that states that
21:08:06 <copumpkin> I think Bools should be outlawed in most cases
21:08:09 <tactics_> how do you mean?
21:08:18 <tactics_> "carry a function"?
21:08:27 <tactics_> (But yes, bools are often suspicious
21:08:27 <copumpkin> say you have a data type that needs to be an invertible function
21:08:46 <copumpkin> how do you write a bool thingy that says it's invertible?
21:09:09 <tactics_> Can you give an example?
21:09:09 <copumpkin> to put it another way, what do you get out of compressing it down into a bool?
21:09:15 <copumpkin> it's not nothing, but it's not much
21:09:18 <dolio> The issue is that that's not a good way to carry the separate proof, even if you're going that route.
21:10:19 <tactics_> I guess it's just really easy to specify a constraint "on the fly"
21:10:29 <tactics_> rather than having to build up a datastructure which preserves it
21:33:22 <tactics_> man, wikipedia articles are terrible for math
21:34:25 <tactics_> In CT, when peope talk about an F-algebra, if "F" a parameter?
21:34:36 <rwbarton> yes
21:34:38 <tactics_> If I have a functor named G, can I talk about a G algebra?
21:34:40 <rwbarton> yes
21:34:58 <tactics_> allright
21:38:18 <tactics_> And so if I have a concrete X and f that together make up my F-algebra (for a concrete functor F), X is called the carrier
21:38:39 <tactics_> So if F X = 1 + X, then Nat is a carrier of F
21:39:34 <rwbarton> right
21:41:29 <coppro> Ok, question
21:41:52 <coppro> How do I make a function that does something different with a Fraction than with any other Num?
21:43:37 <yitz> coppro: you usually wouldn't want to do it that way. but you can create a data type with two constructors, one that contains anything and one just fractions, and pattern match on it.
21:44:09 <yitz> coppro: more often, if there are two different things you want to do, it's two different functions.
21:48:20 <ClaudiusMaximus> hm, i seem to need something like 'make -j' within my haskell program - the previous version just had a few static workers that "took the next job", but now jobs have dependent jobs, and i'm getting worker threads spinning - polling for the "next job", finding the job is in dependency wait, retrying, ...
21:50:51 <coppro> yitz: ah ok thanks
21:52:15 <coppro> yitz: the problem I'm trying to address is that I have a typeclass that sometimes has 'extra' info associated with it.
21:53:15 <coppro> e.g. if hasExtra e then Just (doStuff e) else Nothing
21:53:26 <coppro> where doStuff relies on a more restricted type
21:54:26 <ClaudiusMaximus> hmm, seems Data.Bits is losing the Num superclass in the future - I wonder if there'll be a mechanism to construct a value with all bits clear for an arbitrary "Bits" that doesn't look like "bit 0 `clearBit` 0"
21:54:38 <tactics_> Does anyone know, offhand, the distinction between a "positive" type and a "strictly positive" type?
21:55:18 <ClaudiusMaximus> for numbers, 'strictly positive' excludes zero, while 'positive' can include zero depending on author
21:55:30 <ClaudiusMaximus> dunno about types though
21:56:20 <tactics_> It has to do with positive positions in types
21:56:35 <tactics_> X -> Y, Y is positive, X is negative
21:58:10 <ClaudiusMaximus> coppro: you can maybe write something like   defaultFoo e = Nothing ; defaultExtraFoo e = Just (doStuff e) ; instance MyClass PlainThing where foo = defaultFoo ; instance MyClass FancyThing where foo = defaultExtraFoo
21:58:35 <coppro> hmm... suppose
21:58:39 <dolio> (Z -> Y) -> X, X is strictly positive, Z is positive.
21:59:36 <tactics_> dolio, What is the condition? That X appear only in the "return type" position?
21:59:46 <ClaudiusMaximus> dolio: and is Y in  ((X -> Y) -> Z) -> W  strictly positive ?
21:59:56 <dolio> Z is negated twice, so it's positive.
22:00:06 <dolio> X is negated 0 times, so it's strictly positive.
22:00:12 <tactics_> gotcha
22:00:27 <tactics_> sounds vaguely reminiscent of LEM
22:00:49 <tactics_> \neg \neg A is equal to A, but not constructively
22:00:52 * ClaudiusMaximus should shut up on this pos/neg thing, no idea about this stuff :)
22:01:15 <tactics_> ClaudiusMaximus, talking past the point where you know anything often leads to learning experiences :)
22:01:29 <tactics_> I employ that strategy often
22:01:39 <dolio> ClaudiusMaximus: It is just positive.
22:01:47 <ClaudiusMaximus> tactics_: very true
22:02:09 <tactics_> dolio, I was reading http://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt, which talks about least vs greatest fixpoints
22:02:29 <tactics_> It talks about functors F(X) which put X only in positive positions
22:02:48 <tactics_> but I wondered why it wouldn't be strictly positive positions
22:03:05 <tactics_> ... since both talk about requirements for strong normalization on algebraic datastructures
22:03:44 <dolio> System F can encode data types for all positive functors, not just the strictly positive ones.
22:04:07 <lpvb> how do I specify a function's type signature in ghci?
22:04:41 <dolio> There are various reasons for ruling them out in languages like Agda or Coq.
22:04:51 <dolio> Which may or may not be compelling.
22:05:18 <tactics_> I'm guessing they have to do with either dependent types or higher order parameters or something like that
22:05:34 <tactics_> (since system F is restricted to polymorphism over essentially "Set")
22:05:35 <ClaudiusMaximus> lpvb: inside the same let statement as you define the function in
22:06:00 <dolio> No, I don't think that's one.
22:06:05 <ClaudiusMaximus> > let fac :: Integer -> Integer ; fac n = product [1..n] in fac 5
22:06:06 <lambdabot>   120
22:06:15 <lpvb> 1thanks
22:06:19 <dolio> The first reason is that non-strictly positive types aren't set theoretic.
22:07:15 <ClaudiusMaximus> lpvb: also note you have to define the whole function in one let, otherwise you end up just defining multiple copies of the same name, and the last one shadows all the previous
22:07:16 <dolio> data P = Up ((P -> Bool) -> Bool) would have to be represented by a set that's isomorphic to its own double power set, for instance.
22:07:22 <The> The Highest People
22:07:30 <tactics_> dolio, I gotcha
22:07:53 <dolio> So, if you're trying to relate it back to set theory, and use it as a model, that's not going to work.
22:07:57 <tactics_> So the restriction is mostly there because Type Theory grew out of a history of Set Theory
22:08:22 <dolio> However, it also seems to be one of those tricky areas that's close to inconsistency.
22:08:26 <dolio> Like impredicativity.
22:08:43 <dolio> In fact, I think it's inconsistent with impredicativity.
22:09:06 <dolio> Actually, I'm not sure that's exactly it, because System F is impredicative.
22:09:17 <tactics_> I gotcha
22:09:30 <dolio> I do think it's inconsistent with excluded middle.
22:10:31 <dolio> There's some example involving Prop in Coq, too, but I don't remember what the issue is.
22:10:42 <tactics_> Yeah
22:10:55 <tactics_> I think you've answered my question to the extent I was curious
22:11:10 <tactics_> which was just to get a Big Picture idea of the concept
22:11:13 <tactics_> so thanks dolio :)
22:11:19 <dolio> I think it'd be cool to see what you could do with a theory with positive types. But I'm not aware of any.
22:12:47 <tactics_> hmm
22:12:59 <tactics_> Frustratingly, I don't feel any closer to today's goal
22:13:47 <tactics_> Which was to figure out if it's possible (and if how) to generate functions using a coinduction principle
22:13:57 <tactics_> dual to the notion of an inductive eliminator
22:14:16 <tactics_> but I think I'm on the right track
23:04:50 * hackagebot llvm-base 3.0.1.0 - FFI bindings to the LLVM compiler toolkit.  http://hackage.haskell.org/package/llvm-base-3.0.1.0 (BryanOSullivan)
23:09:50 * hackagebot llvm 3.0.1.0 - Bindings to the LLVM compiler toolkit.  http://hackage.haskell.org/package/llvm-3.0.1.0 (BryanOSullivan)
23:09:52 * hackagebot text 0.11.2.1 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-0.11.2.1 (BryanOSullivan)
23:49:21 <hithere_> hi
