00:00:18 <zzo38> ennui: I like the second one (with pointfree), but both ways can be use whichever way you prefer
00:03:47 <Phlogistique> dmwit: are cons/snoc O(1) when the container is sufficiently big? There is no info on performance in the Data.Vector documentation
00:04:34 <dmwit> My answer doesn't use Data.Vector.
00:04:50 <dmwit> ...and the answer is yes, but with the important caveat that it's amortized O(1).
00:04:54 <dmwit> So don't use it in a real-time system.
00:06:45 <Phlogistique> oh, you're Daniel Wagner
00:06:53 <Phlogistique> OK, then Array it is
00:07:44 <jfischoff_> dmwit:hey just sent you a pull
00:08:30 <dmwit> I'll take a look in the morning.
00:08:35 <jfischoff_> cool
00:41:05 <Catnaroek> Hello. N00b question. Is there any other base kind other than *?
00:41:12 <Catnaroek> s/other base/base/
00:41:52 <ski> not in Haskell, but GHC has `#' and `(#)' as well
00:42:12 <ski> @type 42#
00:42:13 <lambdabot> GHC.Prim.Int#
00:42:21 <Catnaroek> ski: What do # and (#) mean exactly?
00:42:28 <ski> @kind GHC.Prim.Int#
00:42:29 <lambdabot> #
00:42:41 <ski> @kind (# GHC.Prim.Int# , Int #)
00:42:41 <lambdabot> (#)
00:42:57 <ski> `#' is the kind of unboxed types, like e.g. `Int#'
00:43:13 <Catnaroek> Okay.
00:43:18 <Catnaroek> And (#) ?
00:43:20 <ski> `(#)' is the kind of unboxed tuple types (not included in the former)
00:43:25 <Catnaroek> Ah.
00:43:33 <ski> @src Int
00:43:33 <lambdabot> data Int = I# Int#
00:43:43 <bitonic> ski: you're forgetting ##
00:43:46 <Catnaroek> So both # and (#) are subsets of * ?
00:43:51 <ski> Catnaroek : no
00:44:21 <ski> @kind GHC.Prim.MutVar#
00:44:22 <lambdabot> * -> * -> #
00:45:05 <ski> bitonic : possibly .. an example of some type whose kind involves that ?
00:45:21 <Catnaroek> Oooh... I get it, Int is not a synonym, but a wrapper for Int#.
00:45:22 <bitonic> @kind (->)
00:45:23 <lambdabot> ?? -> ? -> *
00:45:27 <bitonic> ski: ah no sorry
00:45:29 <bitonic> I meant ?? and ?
00:45:45 <Catnaroek> What is "?"? Any kind?
00:45:50 <ski> yeah, `??' is the (least) superkind of `*' and `#'
00:46:01 <ski> and `?' is the (least) superkind of `?' and `(#)'
00:46:14 <Catnaroek> Waaait.
00:46:19 <liyang> Here's a useful picture: http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes
00:46:19 <ski> so `??' means normal (boxed) type, or unboxed type
00:46:42 <ski> and `?' means normal (boxed) type, or unboxed type, or unboxed tuple type
00:47:01 <ski> yeah, see that link liyang mentioned
00:47:16 <Catnaroek> lemme see
00:47:17 <Catnaroek> thx
00:48:01 <ski> Catnaroek : still, `?' is not a superkind for every kind -- e.g. the kind `(->) *' isn't a subkind of it
00:48:16 <Catnaroek> Ah, okay, okay.
00:48:39 <ski> (but i suppose you could say it's a superkind for every *concrete* kind)
00:49:15 <Catnaroek> Yep, yep... The kind of all actual types.
00:50:57 <Catnaroek> So the distinction between value (type) and function (type constructor expecting pending type parameters) is more rigid at the type system level.
00:55:40 <ski> Catnaroek : i'm not sure it's more rigid
00:58:03 <Catnaroek> ski: What I mean is, at the type system level, kinds effectively classify types and "type functions" according to the number of "type parameters" that must be passed to them to yield an actually instantiable type.
00:58:43 <ski> yes, and at the value level, types classify concrete values and value functions
00:59:12 <Catnaroek> Yup, but at value level, the distinction is not so rigid.
00:59:20 <ski> if anything, the kind system here appears less rigid, in that we have some nontrivial subkinding going on
00:59:31 <Catnaroek> A function can in some context be a valid value.
00:59:53 <Catnaroek> Oh.
01:00:14 <Catnaroek> ski: What's that nontrivial subkinding?
01:00:18 <ski> a function at the value level is valid as an argument if the type of the argument is a function type
01:00:36 <ski> and a type function can be a valid argument if the kind of the argument type is a function kind
01:00:49 <ski> * =< ??
01:00:54 <ski> # =< ??
01:01:01 <ski> ?? =< ?
01:01:01 <lambdabot> Plugin `compose' failed with: Unknown command: ""
01:01:05 <ski> (#) =< ?
01:01:12 <Catnaroek> What's "=<" ?
01:01:20 <ski> see liyang's link above, for a pictorial description
01:01:22 <zzo38> How would you compare the Ibtlfmm kinds with Haskell and other systems?
01:01:27 <ski> Catnaroek : "is subkind of"
01:01:34 <Catnaroek> Ah!
01:02:04 <Catnaroek> But so far kinds other than ? and * seem like an implementation issue.
01:02:14 <Catnaroek> base kinds*
01:02:52 <ennui> what's the (ungoogleable) meaning of .*. in the definition of 'on'?  -->  (.*.) `on` f = \x y -> f x .*. f y
01:03:15 <zzo38> ennui: I think it is simply a name of a parameter
01:03:18 <allbery_b> there isn't one; it's a symbol name
01:03:31 <allbery_b> that is the definition of "on"
01:07:43 <xil> hey everyone. Is there a way to move the mouse programmatically? I'm trying to program a 3D movement control system and it hinges on me being able to trap the mouse at center screen
01:08:16 <allbery_b> oh, second comment was redundant, sorry.  pointt here was supposed tobe that since "on" was being defined, (.*.) must simply be a parameter name
01:09:17 <allbery_b> xil, surely there is, a different way in different GUIs.
01:09:27 <xil> allbery_b: OpenGL
01:10:24 <fmap> > let (.*.) a b = a + b in 2 .*. 3
01:10:25 <lambdabot>   5
01:13:08 * hackagebot hquantlib 0.0.2.1 - HQuantLib is a port of essencial parts of QuantLib to Haskell  http://hackage.haskell.org/package/hquantlib-0.0.2.1 (PavelRyzhov)
01:19:20 <xil> ah finally found it. The Haskell GLUT binding has a statevar pointerPosition for warping the pointer
01:19:40 <xil> sorry for bothering everyone
01:21:07 <kini> another question about a sentence from Gentle Intro :) "A point not made earlier is that, for type correctness, the types of the right-hand sides of a case expression or set of equations comprising a function definition must all be the same; more precisely, they must all share a common principal type."
01:21:08 <kini> This is not true, is it? All that is required is that there must be some type applicable to all of them, not necessarily equal to their principal type, right?
01:21:12 <paulmaidment> Hi all
01:21:35 <kini> for example:
01:21:35 <kini> :t \x -> if x then 3 else pi
01:21:36 <lambdabot> forall t. (Floating t) => Bool -> t
01:23:08 * hackagebot blaze-builder-conduit 0.4.0.2 - Convert streams of builders to streams of bytestrings.  http://hackage.haskell.org/package/blaze-builder-conduit-0.4.0.2 (MichaelSnoyman)
01:23:12 <kini> hmm. Or maybe I'm confused
01:24:46 <HugoDaniel> hackage is so s.l.o.w.
01:24:56 <HugoDaniel> can i host a mirror of it ?
01:25:22 <zzo38> I want to be able to use a type system where (* -> ((& = a) -> (* = a => b) -> *) -> (+ = c) -> {c -> b} -> ({T {return "Hello"} 42} -> *) -> (@ -> @) -> *) is an acceptable kind.
01:28:10 <zzo38> Where * is the kind of ordinary types, # is the kind of low-level types, ? is the kind of both ordinary and low-level types, & is the kind of constraints, + is the kind of natural numbers, and @ is the kind of program modules.
01:28:32 <zzo38> And where user-defined "datakinds" are given capitalized alphanumeric names.
01:33:04 <AtnNn> zzo38: me too
01:33:09 <kini> no, I think I'm right, after all...
01:33:43 <kini> "\x -> if x then 3 else pi" is a valid expression, but 3 and pi do not have the same principal types
01:34:12 <kini> the typeclasses you see when you do :t 3 or :t pi are part of the type, right?
01:35:09 <zzo38> kini: There are types which can match both classes
01:35:27 <merijn> kini: Yes, numeric literals are overloaded in haskell
01:36:18 <kini> merijn: I was trying to figure out a sentence from the Gentle Intro
01:36:21 <zzo38> (There are some classes which are mutually exclusive, although the compiler has no way of knowing that. Comonad and Alternative are one such pair.)
01:36:24 <kini> "A point not made earlier is that, for type correctness, the types of the right-hand sides of a case expression or set of equations comprising a function definition must all be the same; more precisely, they must all share a common principal type."
01:36:29 <Phlogistique> merijn zzo38: I don't think that's the question kini is asking
01:36:35 <kini> but above don't I have a counterexample to that sentence?
01:36:49 <Phlogistique> What's a "principal type"?
01:36:57 <merijn> kini: I don't know the term principal type
01:37:00 <Ptival> "most general"?
01:37:21 <kini> No, least general which still encompasses all possible typings of the expression
01:37:26 <merijn> kini: But 3 and pi share a type, both Float and Double are instances of Num and Floating
01:37:27 <kini> most general is always just "a", isn't it?
01:37:37 <kini> to quote from the Gentle Intro:
01:37:39 <kini> An expression's or function's principal type is the least general type that, intuitively, "contains all instances of the expression". For example, the principal type of head is [a]->a; [b]->a, a->a, or even a are correct types, but too general, whereas something like [Integer]->Integer is too specific. The existence of unique principal types is the hallmark feature of the Hindley-Milner type system, which forms the basis of the type systems of Haskell, ML,
01:37:39 <kini> Miranda, ("Miranda" is a trademark of Research Software, Ltd.) and several other (mostly functional) languages.
01:38:07 <merijn> kini: So the compiler can infer either Float or Double as return type of that lambda expression. Which it picks depends on the context in which it is used
01:39:16 <kini> yes, I understand that (I think), but as Phlogistique said, that's not what I'm asking :)
01:39:33 <kini> as far as I can see, the principal type of "3" is just (Num)
01:39:58 <Ptival> so, what is the role of type classes with regards to principality of types?
01:39:59 <kini> which is different from the principal type of "pi", which is (Floating)
01:40:09 <kini> Ptival: I am not sure
01:40:21 <kini> typeclasses haven't been mentioned in the Gentle Intro so far
01:40:50 <kini> sorry, I should probably say Num a => a and Floating a => a respectively (?)
01:40:57 <zzo38> AtnNn: Do you possibly to understand my stuff I wrote about type systems and the example of kind I have given?
01:41:01 <geekosaur> yes, that last is correct.  Num is not a type
01:42:11 <Cale> kini: Right, Num and Floating are not themselves types
01:42:25 <zzo38> (Using my system, Num would be a type of kind (* -> &), so for "True" you would have (Bool ~) as what you are seem to be calling its "principal type")
01:43:19 <Ptival> should we consider the types as Num a -> a and Floating a -> a, for the sake of principality's definition?
01:43:34 <zzo38> Ptival: No. You should use => instead of -> there
01:44:10 <zzo38> (The way you have with -> is meaningless)
01:44:16 <kini> I... guess so? (But with =>) According to what I pasted from Gentle Intro, at least, it seems to be correct
01:45:01 <kini> since the literal "3" can by typed by a class of types which lies within Num and no smaller typeclass, I guess we can conclude that the principal type of the expression "3" is "Num a => a"
01:45:18 <kini> and similarly that the principal type of the expression "pi" is "Floating a => a"
01:45:28 <merijn> kini: Outside any context, yes. Inside the context of your lambda expression 3 is not Num a => a
01:45:31 <Ptival> kini: I'd agree with you...
01:45:55 <merijn> Context constrains it to "(Num a, Float a) => a", although I'm not sure this is relevant to your question
01:46:14 <kini> merijn: do you mean (Num a, Floating a) => a ?
01:46:20 <merijn> Eh, yeah
01:46:27 <kini> and ok then
01:46:44 <kini> I guess I was confused (again) by the fact that types are context-dependent...
01:46:46 <Ptival> merijn: I guess this does not make the Intro's claim true
01:46:54 <kini> so I guess "principal types" are also context-dependent
01:47:09 <kini> in which case it does make the Intro's claim true, but also pretty unenlightening...
01:47:14 <merijn> Ptival: I'm not sure I understand the claim, so I'm restricting myself to observations about how it is typed :p
01:47:22 <kini> I mean, obviously, there needs to be some constrained type which matches all possible outcomes
01:47:25 <Ptival> it looks like cheating anyway...
01:47:28 <kini> it's not even really worth stating...
01:47:31 <kini> (IMO)
01:47:46 <Ptival> I think the claim holds in the absence of type classes
01:47:50 <merijn> I've never really been a big fan of the Gentle intro anyway
01:48:10 <Ptival> (as in, "holds unambiguously")
01:49:00 <merijn> @quote Brend gentle
01:49:01 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
01:49:08 <opqdonut> Ptival: how about "case b of True -> (Nothing, Just 'a'); False -> (Just (), Nothing)"
01:49:38 <opqdonut> principal types: (Nothing, Just 'a') :: (Maybe a, Maybe Char), (Just (), Nothing) :: (Maybe (), Maybe a)
01:49:59 <Ptival> opqdonut: oh right :\
01:50:04 <opqdonut> what the typing rules say (and what the gentle intro should've said) is that the types of the expressions on the RHS of case must unify
01:50:18 <Ptival> indeed
01:50:21 <opqdonut> and the type of the case is the LUB (or whatever) of all those types
01:50:47 <kini> yeah it seems to be written strangely
01:50:48 <Ptival> seems more reasonable
01:51:05 <kini> it's telling me conditions on expressions which need to be satisfied in order for me to build a larger expression containing those smaller expressions
01:51:20 <kini> but at the same time, those conditions assume that the expressions are sitting in the larger expression already, and have that context
01:54:26 <navaati> hi
01:55:19 <kini> merijn: as for how good the gentle intro is, I just wanted to make sure I understood the theory of everything as I was learning
01:55:29 <kini> and lyah seemed not to do much theoretical explication
01:55:45 <kini> (I only got a few chapters in before deciding to try the gentle intro though)
01:58:02 <merijn> kini: I think you'd be better of reading LYAH and then just grabbing some papers/books on type theory itself
01:59:09 <xil> hey again. I'm using OpenGL and when I include a depth buffer then it displays...pixelated? Here's a pic http://i.imgur.com/3elRj.png. Anyone know why it only displays every other pixel basically?
01:59:22 <merijn> In my opinion learning haskell first and type theory second is probably easier than vice versa, unless you happen to have a very good
01:59:43 <merijn> hmm, premature enter
02:00:04 <merijn> That was supposed to be "very good math instinct"
02:07:05 <kini> merijn: well, my bachelor's is in math... I didn't learn much about logic and nothing about type theory as an undergrad though
02:07:31 <kini> any particular recommendations for books or papers on type theory?
02:08:06 <kini> I guess I'll go back to lyah for now
02:08:22 <quicksilver> @where tapl
02:08:22 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
02:08:26 <quicksilver> ^^ kini
02:08:29 <quicksilver> not read it myself, though.
02:09:07 <kini> Looks good! Thanks, I'll see if I can find a copy.
02:09:47 <merijn> kini: TAPL is highly recommended, I also have fairly nice course notes on untyped/simply typed/dependently typed lambda calculus somewhere
02:10:53 <Ptival> @where ttfp
02:10:54 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
02:10:58 <Ptival> is also often mentioned
02:11:03 <labo> hello
02:11:13 <kini> great, we even have it in the university library :)
02:11:21 <kini> Ptival: another Simon!? :P
02:24:56 <labo> would anyone be interested in taking a look at a package I've created, before I upload it to hackage?
02:33:24 <Catnaroek> @type uncurry
02:33:25 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
02:33:32 <Catnaroek> @type curry
02:33:32 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
02:38:12 <xraycat> hi, is there a way to do a qualified import in ghci?
02:53:21 <fmap> xraycat: import qualified Module as M
02:53:22 <fmap> ?
02:54:31 <fmap> i guess that requires 7.4.1 though
02:57:09 <danr> fmap: qualified module imports is in the haskell 98 report
02:57:37 <danr> 5.3.3 http://www.haskell.org/onlinereport/modules.html
02:58:24 <fmap> danr: the question was about ghci
02:59:45 <danr> fmap: ok sorry :)
03:00:10 <quicksilver> well you can do a qualified import ina  short .hs file and load the .hs file in ghci
03:00:13 <quicksilver> in any version of ghci
03:10:10 <t7> whens the new platform out
03:10:13 <t7> its been a year now
03:10:38 <bitonic> t7: no? the last was in Dec 2011
03:10:55 <t7> oh the title needs changing then
03:10:55 <bitonic> iirc it's every 6 months
03:11:14 <bitonic> t7: why?
03:11:23 <t7> Haskell Platform 2011.4
03:11:23 <MasseR> bitonic: "Haskell Platform 2011.4"
03:11:33 <bitonic> ah, the "4" is not the month
03:11:47 <bitonic> that is the latest HP
03:11:54 <t7> ah
03:12:13 <danr> next release may 2012
03:12:14 <danr> http://trac.haskell.org/haskell-platform/wiki/ReleaseTimetable
03:12:26 <bitonic> so, now!
03:12:31 <danr> any second, now!
03:13:03 <bitonic> damn I'm excited
03:13:19 <t7> whos having a release party?
03:18:34 <navaati> reactive-banana is strictly designed for use with callback-based libs, right ?
03:18:55 <navaati> (so, for example, not SDL)
03:19:05 <xraycat> quicksilver: that's what I'm doing atm, just hoped there would be a "better" way
03:23:19 * hackagebot tamarin-prover-utils 0.4.1.0 - Utility library for the tamarin prover.  http://hackage.haskell.org/package/tamarin-prover-utils-0.4.1.0 (SimonMeier)
03:23:21 * hackagebot tamarin-prover-term 0.4.1.0 - Term manipulation library for the tamarin prover.  http://hackage.haskell.org/package/tamarin-prover-term-0.4.1.0 (SimonMeier)
03:28:23 * hackagebot tamarin-prover 0.4.1.0 - The Tamarin prover for security protocol analysis.  http://hackage.haskell.org/package/tamarin-prover-0.4.1.0 (SimonMeier)
03:44:35 <srhb> Can I make ghci warn about nonexhaustive patterns on load?
03:44:53 <bitonic> srhb: -Wall
03:45:18 <srhb> bitonic: That will include more that just nonexhaustive patterns I think.
03:45:48 <fmap>  :set -fwarn-incomplete-patterns
03:46:08 <srhb> fmap: Awesome, thanks.
03:46:32 <srhb> Except, it doesn't work either. Weird.
03:48:06 <bitonic> srhb: it works for me
03:49:10 <srhb> It doesn't complain when I set it, but nor does it actually warn.
03:49:36 <bitonic> srhb: I have "blah Nothing = "foo"" in foo.hs, if I :set it and :load it it warns me.
03:50:39 <srhb> bitonic: Hmm, that works for me too. Odd
03:50:54 <bitonic> srhb: so what doesn't work :P?
03:51:19 <srhb> bitonic: I was doing the 20 intermediate haskell exercises, and I have furry f (x:xs) = f x : furry f xs... That is, map
03:51:23 <srhb> But without handling the empty list
03:51:26 <srhb> I thought that ought to give a warning.
03:51:42 <bitonic> it should.
03:51:45 <aristid> srhb: if you use -Wall, i think it should
03:51:56 <srhb> Perhaps it's because it's in an instance of a type class
03:52:10 <bitonic> srhb: it warns me
03:52:25 <bitonic> (with -fwarn-incomplete-patters and `foo (_:_) = "foo"')
03:52:37 <srhb> bitonic: How about if you throw foo in an instance?
03:52:47 <bitonic> srhb: what do you mean?
03:53:14 <bitonic> if `foo' is some typeclass method?
03:53:17 <srhb> I basically have the functor type class and an instance for lists with the map in
03:53:18 <srhb> Yes
03:53:21 * hackagebot approximate-equality 1.1 - Newtype wrappers for approximate equality  http://hackage.haskell.org/package/approximate-equality-1.1 (GregoryCrosswhite)
03:53:21 <srhb> Exactly
03:54:37 <bitonic> srhb: still warns me
03:54:51 <srhb> Warns me in ghc, but not in ghci. Not even with -Wall. So strange.
03:55:09 <bitonic> srhb: I don't believe you. post the code :P
03:56:00 <srhb> http://hpaste.org/68065
03:56:35 <bitonic> srhb: it warns me
03:56:42 * srhb rips out her hair
03:56:45 <bitonic> what version of GHC?
03:56:55 <srhb> 7.0.4
03:57:35 <srhb> Ah wait. Got it. My mistake. I was lying. :(
03:57:37 <bitonic> srhb: yep, tried now with that version and it works.
03:57:40 <bitonic> :)
03:57:59 <srhb> I forgot to remove the Emacs-factor. :-)
03:58:00 <t7> srhb you are missing a case
03:58:06 <srhb> t7: Yes.
03:58:38 <t7> i should read more
03:58:48 <srhb> Nah, waste of time really. :-)
04:00:02 <bitonic> srhb: on these matters the computer is usually right
04:08:23 * hackagebot hlbfgsb 0.0.1.0 - Haskell binding to L-BFGS-B version 3.0  http://hackage.haskell.org/package/hlbfgsb-0.0.1.0 (IvanLabath)
04:35:49 <Bytter> question: what other "typical" things does Arrows generalize besides functions?
04:37:06 <mekeor> kleisli-monads.
04:37:33 <Bytter> hmmm
04:37:36 <mekeor> look at the default instances of the arrow-typeclass ;)  http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Arrow.html#t:Arrow
04:39:40 <Bytter> mekeor: thx
04:40:13 <Bytter> is there a generalization of an "object" (in the OO sense) inspired in cat. theory?
04:44:06 <Botje> objects are just records, yah?
04:44:30 <mekeor> idk CT. but IMO record-types and objects are similar. there are lots of differences though, like inheritance, methods and so on.
04:45:01 <mekeor> for inhericante, haskell uses type-classes. methods are stupid.
04:45:20 <mekeor> methods, afaik, only make sense if you have something like "private" and "public".
04:45:29 <ski> Bytter : maybe "terminal `F'-algebra", for various (endo-)functors `F' ?
04:45:35 <merijn> Typeclasses are definitely not for inheritance
04:45:43 <merijn> Which is ok, because inheritance is retarded
04:45:49 <mekeor> merijn: but also. amongs others.
04:46:07 <merijn> I don't know of any situation where they are used for inheritance
04:46:08 <mekeor> merijn: why is inheritance "retarded" ?
04:46:25 <mekeor> merijn: applicative is an sub-class of functor. inheritance.
04:46:38 <ski> (the members of a type class are sometimes knows as methods of it ..)
04:47:07 <merijn> mekeor: That's not inheritance, because you need to implement functor separately
04:47:24 * mekeor should read http://www.haskell.org/haskellwiki/OOP_vs_type_classes
04:47:33 <ski> mekeor : that's interface inheritance -- i take merijn was thinking about implementation inheritance
04:47:36 <mekeor> merijn: ah, oh, right…
04:48:03 <merijn> mekeor: It's just a constraint/requirement. Referring to typeclasses as interfaces would make more sense than calling them inheritance
04:49:50 <ski> it's possible to do (implementation) inheritance for functions pattern-matching on variant datatypes -- it's called coinheritance
04:50:05 <ski> the same idea is also commonly used in proofs
04:50:16 <srhb> Is ((->) r) the type of functions? I'm looking at the functor instances, and wondering what to call that.
04:50:23 <mekeor> hm, i don't know enough of OOP yet, i think. i should read about it. thanks for that impulse :)
04:50:26 <Bytter> have the expression problem been solved, yet?
04:50:37 <Bytter> otherwise, i don't see any point in discussing inhertitance...
04:50:54 <ski> srhb : it's something which given a type `a' expresses the type of functions from `r' to `a'
04:51:08 <mekeor> srhb: i wouldn't call ((->) r) a type. i'd call it a type-constructor, like Maybe.
04:51:10 <mekeor> @kind Maybe
04:51:11 <lambdabot> * -> *
04:51:20 <mekeor> @kind ((->) r)
04:51:20 <lambdabot> Not in scope: type variable `r'
04:51:24 * ski would call it a type, but not a type constructor
04:51:25 <mekeor> @kind ((->) Integer)
04:51:25 <lambdabot> ? -> *
04:51:32 <srhb> Aaah, yes, of course. Type constructor.
04:51:35 <ski> (`(->)' however is a type constructor)
04:51:42 <srhb> Right
04:51:48 <ski> `Either' is a type constructor, `Either Int' is not
04:51:53 <srhb> Got it. :)
04:51:56 <mekeor> ski: why?!
04:52:02 <Bytter> mekeor: @kind (Maybe -> Integer)
04:52:05 <ski> `Either Int Bool' and `(->) r a' are *concrete* types
04:52:10 <Bytter> @kind (Maybe -> Integer)
04:52:11 <lambdabot>     `Maybe' is not applied to enough type arguments
04:52:11 <lambdabot>     Expected kind `??', but `Maybe' has kind `* -> *'
04:52:11 <lambdabot>     In the type `Maybe -> Integer'
04:52:19 <mekeor> Bytter: wtf?!
04:52:23 <Bytter> @kind (Maybe[a] -> Integer)
04:52:24 <lambdabot> Not in scope: type variable `a'
04:52:27 <Bytter> mekeor: sorry
04:52:34 <ski> @kind Maybe Int -> Integer
04:52:35 <lambdabot> *
04:53:16 <mekeor> for me, a type is something of kind *. a type constructor is something of type * -> ... -> *.
04:53:23 <ski> mekeor : just like `[]',`False',`Just',`Node' are data constructors, i want to call `Int',`Maybe',`Either',`(->)' type constructors
04:53:34 <mekeor> s/of type/of kind/ # sry
04:53:54 <ski> `Node 42' isn't a data constructor -- similarly, i don't want to call `Either Int' a type constructor
04:54:09 <mekeor> ski: for me, "Just" is a value constructor while "Nothing" is a value :P
04:54:33 <navaati> mekeor: hum… Just is a value : it's a function
04:54:35 <ski> both happen to be values, to me :)
04:54:53 <mekeor> navaati: ah, right. that's sounds meaningful, right.
04:54:59 <mekeor> i see.
04:55:30 <mekeor> It would be awesome if this was written somewhere in the wiki. is it already?
04:55:37 * ski dunno
04:56:30 <navaati> actually it's the difference between haskell and dependently typed languages : (Maybe) is a type constructor, not a type, whereas in a dependently typed language it *is* a type (of type Type -> Type)
04:56:37 <ski> mekeor : anyway, if you want to read about coinheritance, i suggest reading Erik Poll
04:56:58 <ski> navaati : hehe, to me it's both a type and a type constructor :)
04:57:14 <srhb> So what's the drawback of dependent typing? It seems objectively more powerful.
04:57:19 <Saizan> navaati: * -> * and Type -> Type are not fundamentally different
04:57:29 <ski> srhb : no global type inference
04:57:33 <srhb> Ah.
04:58:08 <ski> navaati : maybe you meant to say that `Maybe' would be a *value* in a DT language ?
04:58:17 <ski> @where ErikPoll
04:58:17 <lambdabot> "Subtyping and Inheritance for Inductive Types" in 1997 at <http://www.cs.ru.nl/E.Poll/papers/durham97.pdf>,"Subtyping and Inheritance for Categorical Datatypes" in 1997 at <http://www.cs.ru.nl/E.
04:58:17 <lambdabot> Poll/papers/kyoto97.pdf>,"A Coalgebraic Semantics of Subtyping" in 2000 at <http://www.cs.ru.nl/E.Poll/papers/cmcs00.pdf>,later version of that in 2001 at <http://www.cs.ru.nl/E.Poll/papers/ita01.
04:58:17 <lambdabot> pdf>
04:58:54 <mekeor> thanks, ski
05:02:57 <labo> does hackage support urls in cabal description fields?
05:04:03 <ski> mekeor : "A Tutorial on (Co)Algebras and (Co)Induction" by Bart Jacobs,Jan Rutten in 1997 at <http://www.cs.ru.nl/B.Jacobs/PAPERS/JR.pdf> might also be interesting
05:04:57 * ski wonders why that appears to be stalling after about half the paper ..
05:06:43 <hpaste> mekeor pasted “type, type constructor, concrete type, value or value constructor?” at http://hpaste.org/68068
05:06:57 <mekeor> please annotate ^ !  ski?
05:08:29 <hpaste> mekeor annotated “type, type constructor, concrete type, value or value constructor?” with “type, type constructor, concrete type, value or value constructor? (annotation)” at http://hpaste.org/68068#a68069
05:08:30 * hackagebot hirt 0.0.1.0 - Calculates IRT 2PL and 3PL models  http://hackage.haskell.org/package/hirt-0.0.1.0 (IvanLabath)
05:08:59 <hpaste> quicksilver annotated “type, type constructor, concrete type, value or value constructor?” with “type, type constructor, concrete type, value or value constructor? (annotation)” at http://hpaste.org/68068#a68070
05:09:15 <quicksilver> mekeor: annotated.
05:09:20 <quicksilver> the term "type" is not entirely clear.
05:09:37 <quicksilver> I have chosen to say that concrete types and type constructors are both types.
05:10:00 <mekeor> quicksilver: i see. cool.
05:10:28 <quicksilver> the other common terminology is to say that types are only concrete types.
05:10:32 <mekeor> quicksilver: is Nothing really a VC for you?
05:10:42 <quicksilver> but then you don't have a word to answer the question "what do kinds classify?"
05:10:50 <mekeor> quicksilver: yea, that was my opinion.
05:10:52 <quicksilver> mekeor: oh, absolutely. That one is not debateble.
05:11:00 <mekeor> :)
05:11:08 <quicksilver> data Maybe a = Just a | Nothing
05:11:14 <quicksilver> Just and Nothing are the constructors.
05:11:27 <quicksilver> any value with a Capital initial is a constructor.
05:11:43 <mekeor> oh, right. well, numbers? :)
05:11:59 <quicksilver> numbers are a bit fuzzy *especially* since they're overloaded.
05:12:02 <alpounet> it just happens to be a "nullary" constructor
05:12:40 <quicksilver> but, you can pattern match them which makes them like constructors
05:12:56 <quicksilver> and data Int = 0 | -1 | 1 | -2 | 3 | -3 | 4 .....
05:13:03 <mekeor> quicksilver: what do you mean by overloaded?
05:13:08 <quicksilver> seems like a natural model of Int, even though it's illegal syntax
05:13:19 <quicksilver> mekeor: 1 isn't necessarily an Int
05:13:25 <quicksilver> it's an overload Num literal
05:13:27 <mekeor> yea, it's Num a
05:13:32 <hpc> perhaps a better example of data syntax would be
05:13:35 <mekeor> ah, okay, got it.
05:13:39 <hpc> data Bool = False | True
05:13:50 <hpc> (False, True are constructors)
05:13:59 <quicksilver> hpaste: we already had Maybe which is a good example :)
05:14:03 <quicksilver> !
05:14:05 <quicksilver> that was for hpc
05:14:07 <mekeor> i'd call them just "values" though…)
05:14:07 <hpc> data Rational = Ratio Integer Integer -- the data type of fractions
05:14:22 <hpc> quicksilver: Maybe is rather abstract
05:14:22 <quicksilver> hpaste: don't steal my comments like that!
05:14:32 <quicksilver> maybe it is.
05:14:44 <quicksilver> I think mekeor is fairly comfortable with it though.
05:14:46 <hpc> plus, people come in asking questions about Maybe rather often
05:15:06 <mekeor> quicksilver: *nod*
05:16:06 <quicksilver> mekeor: which would you call just values?
05:16:18 <mekeor> False and True.
05:20:11 <DarkUnicorn> I'm trying to use phantom types to implement a money type with currency and ensure that currencies are not mixed. I have the problem that the phantom type disappears at compile-time but I need to have access to the currency. Any ideas? Looks dirty to carry the currency around as string -> https://github.com/SKoschnicke/haskell-shop-kata/blob/master/PriceList.hs
05:20:12 <mekeor> data Kind = * | (->) Kind Kind -- :D
05:20:12 <merijn> Is there any way to reduce/avoid some parenthesis/dollar signs in code like this? "adjust <- (`div` 2) <$> (access $ weight . origin)"
05:20:36 <danr> access (weight . origin) ?
05:21:31 <merijn> danr: Oh, yeah. That's a start :)
05:21:34 <hpaste> ski annotated “type, type constructor, concrete type, value or value constructor?” with “answers” at http://hpaste.org/68068#a68071
05:21:41 <fmap> flip div 2
05:21:42 <fmap> ?
05:21:46 <scopedTV> merijn: code seems perfectly intelligible for me.
05:21:46 <ski> mekeor ^
05:22:04 <merijn> fmap: I think flip makes things harder to read
05:22:15 <quicksilver> mekeor: but the point is that they're not just values
05:22:28 <quicksilver> mekeor: because you can pattern match on them.
05:23:09 <mekeor> DarkUnicorn: i'd do something like this:  data Money = Money { amount :: Double, currency :: Currency };  data Currency = Euro | Dollar | ...
05:23:47 <mekeor> DarkUnicorn: also, i don't think it's nice to indent the whole source code...
05:24:01 <DarkUnicorn> mekeor: yeah, but that makes it impossible to let the compiler check if two moneys have the same currency
05:24:25 <danr> merijn: if you find yourselv doing (`div` x) or (`div` 2) a lot, maybe introduce new functions, eg halve, divBy
05:24:28 <DarkUnicorn> mekeor: oh, ok, you're right
05:24:39 <mekeor> DarkUnicorn: sameCurrency = (==) `on` currency
05:24:54 <mekeor> @src on
05:24:54 <lambdabot> (*) `on` f = \x y -> f x * f y
05:24:55 <danr> but I agree that both backtick-infix sections and flip looks pretty dull
05:24:57 <scopedTV> danr: ugh, i would hate that. nothing wrong with (`div` 2)
05:25:05 <quicksilver> merijn: adjust <- fmap (`div`2) . access . weight $ origin
05:25:15 <ski> mekeor : any comments ?
05:25:28 <merijn> DarkUnicorn: On unrelated note, if you don't change currency into something other than Double I'm going to have to murder you
05:25:30 <mekeor> ski: scnd
05:25:39 <ski> @hoogle scnd
05:25:40 <lambdabot> No results found
05:25:47 <danr> lol
05:25:50 <mekeor> :D
05:26:02 <mekeor> ski: my comment: nice.
05:26:22 <danr> scopedTV: yeah, maybe it's overdoing it =)
05:26:28 <mekeor> quicksilver: ah!
05:26:35 <DarkUnicorn> mekeor: but that doesn't let the compiler enforce similar currencies, or am i wrong?
05:26:56 <mekeor> DarkUnicorn: how do you mean?
05:27:04 <mekeor> similar currencies?
05:27:10 <merijn> mekeor: He wants to check at compile time that he isn't mixing currencies
05:27:17 <mekeor> ah, oh.
05:27:20 <merijn> i.e. check that he doesn't add Euros to Dollars
05:27:22 <DarkUnicorn> exactly
05:27:36 <quicksilver> DarkUnicorn: you wil need a typeclass to convert your phantoms into strings
05:27:46 <mekeor> bah, idk that. idk anything about compile-time stuff...
05:27:48 <DarkUnicorn> also, i'm searching for a good arbitrary precision number datatype to replace double
05:28:04 <mekeor> DarkUnicorn: use integer.
05:28:07 <mekeor> as cents.
05:28:07 <bitonic> DarkUnicorn: Rational
05:28:23 <quicksilver> class Currency a where getCurCode :: Money a -> String
05:28:25 <bitonic> DarkUnicorn: or CReal if you need real numbers
05:28:39 <merijn> quicksilver: "access . weight $ origin" is semantically different from "access (weight . origin)", isn't it?
05:28:41 <mekeor> > pi :: CReal
05:28:42 <lambdabot>   3.1415926535897932384626433832795028841972
05:28:44 <bitonic> but operations might diverge with CReal
05:28:51 <DarkUnicorn> bitonic: okay i will check out CReal, thanks!
05:29:03 <hpc> use Cont Double
05:29:06 <quicksilver> instance Currency EURO where getCurCode _ = "EUR"
05:29:09 <bitonic> DarkUnicorn: well be sure that you know what it means to have an infinite precision real number :)
05:29:13 <hpc> then you can have whatever representation you want! ;)
05:29:30 <quicksilver> not sure CReal is what you normally need for currency.
05:29:39 <mekeor> merijn: you said "(access $ weight . origin)" in your original post.
05:29:41 <DarkUnicorn> quicksilver: i think i tried that but it didn't work, wait a moment
05:29:48 <hpc> quicksilver: maybe one of the currencies is BTC
05:29:51 <bitonic> I'm with quicksilver, why do you need real numbers for currency?
05:30:08 <quicksilver> Integer with ISO-4217 exponent is simply if you don't need to store fractions.
05:30:09 <Botje> to make the Hackers movie non-fiction!
05:30:15 <merijn> mekeor: Yes, but "access $ weight . origin" is identical to "access (weight . origin)"
05:30:16 <hpc> where you need eleven squajillion decimal points
05:30:24 <mekeor> merijn: *nod*
05:31:05 <scopedTV> I would like to send exp(3) euro to a person.
05:31:09 <mekeor> merijn: i think the fixity of <$> is low enough such that you don't need brackets around (access (weight . origin)).
05:31:21 <scopedTV> Please implement arbitrary-precision real numbers in the banking system. TY.
05:31:30 <merijn> mekeor: That produced a type error, that's why I added them
05:31:33 <hpc> (.) has one of the highest precedences, iirc
05:31:35 <DarkUnicorn> quicksilver: i think typeclasses will work, thank you!
05:31:38 <hpc> it might even be 9
05:31:59 <mekeor> merijn: ah, okay. dunno than. also, i don't think it's a big problem. you could just use hlint ;)
05:32:15 <merijn> Yes, (.) is infixr 9
05:32:22 <DarkUnicorn> bitonic: when calculating with money you may need more precision than cents
05:33:03 <mekeor> DarkUnicorn: for example?
05:33:03 <merijn> bitonic: Yes, but you want fixed precision
05:33:19 <DarkUnicorn> mekeor: tax calculations
05:33:38 <quicksilver> quite often the amount of precision to use is fixed and defined though
05:33:38 <merijn> mekeor: Billing, tarsnap bills in picodollars per byte, for example
05:33:39 <bitonic> merijn, DarkUnicorn: that doesn't mean you need real numbers
05:33:55 <bitonic> DarkUnicorn: Rational has arbitrary precision
05:33:58 <bitonic> @src Rational
05:33:59 <lambdabot> type Rational = Ratio Integer
05:34:03 <merijn> bitonic: My bad, I wanted to address that to DarkUnicorn
05:34:15 <mekeor> @src Ratio
05:34:15 <lambdabot> data (Integral a) => Ratio a = !a :% !a
05:34:19 <merijn> bitonic: I didn't mean to imply that was a reason to want Real numbers
05:34:25 <bitonic> merijn: ok :)
05:34:28 <DarkUnicorn> yeah, i don't need arbitrary precision but variable defineable precision
05:34:54 <bitonic> DarkUnicorn: I still don't see what's wrong with Rational :P.
05:35:00 <DarkUnicorn> maybe it's enough to ensure that precision only where its needed and stick with integer for the rest
05:35:16 <DarkUnicorn> nothing wrong with rational :)
05:35:36 <DarkUnicorn> that helped a lot, thanks guys!
05:35:38 <merijn> DarkUnicorn: Foolproof method (might require writing some plumbing) is using two Integers, one before the decimal and one for after
05:35:43 <mekeor> is CReal infinitely precise?!
05:35:51 <bitonic> mekeor: yes
05:35:55 <mekeor> cool
05:36:23 <bitonic> of course not all real numbers are computable, so your functions might diverge anytime :D
05:36:37 <otters> is OverlappingInstances in ghci 7.0.4?
05:36:41 <scopedTV> Yes.
05:36:46 <otters> oka
05:36:46 <mekeor> does the HERA-package include CReal?
05:37:09 <mekeor> mekeor: yes.
05:38:07 <mekeor> > sqrt 2 :: CReal
05:38:08 <lambdabot>   1.4142135623730950488016887242096980785697
05:38:09 <otters> https://gist.github.com/2594574
05:38:11 <otters> is giving me
05:38:24 <bitonic> mekeor: note that the Show instance for CReal truncates the number
05:38:26 <otters> "Overlapping instances for Flatten [t0] o0"
05:38:43 <bitonic> > showCReal 10 pi
05:38:44 <lambdabot>   "3.1415926536"
05:38:46 <bitonic> > showCReal 100 pi
05:38:48 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
05:38:58 <mekeor> bitonic: ah!
05:39:06 <mekeor> coool
05:40:56 <bitonic> mekeor: learning how CReal works will teach you something about maths :)
05:41:57 <scopedTV> Is there a Haskell library for formal series?
05:42:45 <mekeor> otters: where does GHC(i) know the type of 'flatten [[1, 2], [3, 4]]' in your code, actually?
05:43:01 <mekeor> bitonic: did you read/learn it?
05:43:03 <ski> > (read "3.141592653589793238462643383279502884197169" :: CReal) == pi
05:43:04 <lambdabot>   True
05:43:10 <ski> > length "3141592653589793238462643383279502884197169"
05:43:11 <lambdabot>   43
05:43:17 <mekeor> wow.
05:43:21 <otters> mekeor: it's defined as either id or concatMap flatten sooo
05:43:28 <mekeor> ski: the Eq instance of CReal is cool.
05:43:37 <ski> `(==)' for `CReal' is stupid, only looks at the first forty or so decimals
05:43:44 <bitonic> mekeor: I didn't read the source code of CReal specifically, but I learnt that youi can represent real numbers as series. TTFP has a nice section  about that
05:43:53 <otters> a -> a or [i] -> o
05:43:58 <scopedTV> CReal should not have an Eq instance.
05:44:05 <mekeor> bitonic: ah, yea, i see, okay.
05:44:07 <otters> because eventually it'll reduce to flatten = concatMap id
05:44:21 <ski> scopedTV : or, `(==)' should only even answer when the numbers are different
05:44:21 <mekeor> scopedTV: but a CaEq instance =)
05:44:22 <scopedTV> But I guess previously it was necessary (i.e. pre-GHC7.4)
05:44:50 <ski> > [0 ..] == [0 ..]  -- doesn't answer either
05:44:53 <lambdabot>   mueval-core: Time limit exceeded
05:44:54 <scopedTV> ski: which makes it worse than useless, just use unsafeEquality :: CReal->CReal ->Bool
05:45:14 <ski> i'm not sure whether it's worse than useless
05:46:07 <ski> but maybe having a dedicated class with `apart :: Haussdorff a => a -> a -> Sierpinski' would be more sensible
05:46:25 <mekeor> scopedTV: is http://en.wikipedia.org/wiki/Formal_power_series what you meant by "formal series" ?
05:46:31 <scopedTV> Yes, a formal power series.
05:46:57 * ski idly wonders whether scopedTV's nick has any relation to conals Tangible Values
05:47:09 <scopedTV> No, "Type Variables" =)
05:47:12 <ben> or maybe just televisio-- oh
05:47:47 <mekeor> notInScope would also be a nice nick :D
05:48:05 <ski> ben : well, surely it couldn't be *that* mundane, in *this* channel ! ;)
05:48:12 <ski> @where TV
05:48:13 <lambdabot> http://www.haskell.org/haskellwiki/TV
05:49:19 <akosch> I have a 100+ line SQL statement in my program. Currently I'm using the multi-line string syntax to store it in my code, but I'm looking for less cumbersome alternatives. I understand that there is some hackish way to define a heredocs syntax with quasiquoting and that I could also use template haskell to load the string from an external file (file-embed on hackage). Any other compile-time alternatives?
05:49:36 <scopedTV> unlines [ "SELECT", "FROM" ]
05:49:41 <scopedTV> align the [ and ,
05:50:04 <kulakowski> The C in CReal bugs me.
05:50:22 <scopedTV> use \ at the end of the line to escape the newline.
05:50:25 <akosch> scopedTV: yeah, I forgot about that. I like the multi-line syntax better :)
05:50:29 <bitonic> kulakowski: why?
05:50:37 <quicksilver> it's a bad name
05:50:46 <quicksilver> it looks like CInt and CString and CDouble ;)
05:50:51 <bitonic> ah, right :P
05:51:27 <mekeor> it should be named Triple (like Double) :D
05:51:38 <danr> and it's a bit superfluous anyway, since it's not like we can have uncomputable reals
05:51:45 <kulakowski> quicksilver: That. But also, (assuming that it does stand for computable or constructive or some such), kind of superfluous.
05:51:50 <bitonic> danr: I think it stands for Constructive
05:51:53 <kulakowski> danr: exactly.
05:51:59 <bitonic> that's what I assumed anyways
05:52:20 <bitonic> danr: well.. we can't have diverging CReals
05:53:23 <BMeph> It's superfluous, but a whole lot more honest than languages that call their Floats "Real"s. :)
05:53:39 <mekeor> do you think it'd be nice to make a wiki-page the naming-conventions about types/--constructors/--function/… ?  -- what should it be called?
05:54:06 <bitonic> mekeor: are there any? apart from the monad transformers, and newtype deconstructors
05:54:42 <danr> bitonic: interesting... the source code calls them both constructive and computable ( http://hackage.haskell.org/packages/archive/numbers/3000.0.0.0/doc/html/src/Data-Number-CReal.html#CReal )
05:54:56 <akosch> is there any package for doing the quasiquoting flavored heredocs? or do people use the code which shows up on google from old mailing list threads? :)
05:55:04 <mekeor> bitonic: are there any what?
05:55:16 <kulakowski> danr: What would be the distinction?
05:55:30 <bitonic> kulakowski: good point :P
05:57:57 <bitonic> mekeor: conventions
05:59:46 <quicksilver> kulakowski: well....
05:59:54 <mekeor> bitonic: well, there are unconvenient conventions convented by the conventer, ski: here: http://hpaste.org/68071
06:00:22 <quicksilver> kulakowski: technically a semantics of [Int] includes non-computable lists of Ints.
06:00:43 <quicksilver> kulakowski: whereas CReal has in some sense a stronger tie to computability
06:00:47 <quicksilver> but I do take your point.
06:01:33 <bitonic> mekeor: oh you mean "naming conventions" as in "haskell definitions - type values constructors etc."?
06:01:44 <kulakowski> Fair enough. Though if you do see an uncomputable [Int] lying around, let me know. I think I could have fun with one.
06:02:05 <ski> adding a `_' to the end often means "ignoring / not constructing result"
06:02:19 <mekeor> bitonic: i was kidding, sorry. uhm. no, AFAIK there are no really all over accepted naming-conventions but i always have problems how to call stuff. i think other people have this issue, too. so, i think it'd be nice to have a wiki-page suggesting a naming-convention or so… dunno.
06:02:32 <ski> `M' at the end often means "monadic version", `A' meaning "applicative functor version"
06:02:38 <mekeor> bitonic: *nod*
06:02:57 * ski str seeing some page which documented some of these conventions
06:03:01 <merijn> @pl \x y -> runStateT $ foo x y
06:03:02 <lambdabot> (runStateT .) . foo
06:03:53 <ski>   runState .: foo
06:04:19 <merijn> ski: Yeah, but I want/need that for more than 2 arguments in some cases
06:04:53 <mekeor> ski: can't find it. what does "str" mean?
06:05:18 <ski> "seem to recall/remember"
06:05:33 <ski> (as in the perhaps more common "istr")
06:05:51 <mekeor> ah, okay, thanks :)
06:05:56 <ski> merijn : `.::',`.:::',&c. ?
06:06:00 <merijn> i.e. I have some functions "a -> b -> StateT s m c" where the number of arguments (i.e. a and b) is between 1 and 5 and my code expects functions of type "a -> b -> m (c, s)"
06:06:24 <ski> the other option is not being pointless
06:06:27 <merijn> ski: Then I'd rather refactor all the code to expect StateT instead
06:06:44 * ski doesn't understand
06:07:05 <ski> (btw, shouldn't it be `a -> b -> s -> m (c,s)' rather ?)
06:07:15 <merijn> No
06:07:25 <merijn> Eh, maybe?
06:07:35 <merijn> ski: The functions are used as callbacks, but I originally wrote them to expect non-state functions
06:08:04 <merijn> I'd rather refactor the callbacks to expect StateT instead of writing ugly combinators/ugly lambda wrappers
06:08:31 <ski> ah, ok
06:08:39 <ski> are they already monadic ?
06:08:55 <merijn> They're stuck in IO anyway
06:09:00 <merijn> (They act on Chan's)
06:09:55 <quicksilver> merijn: I wrote a rambling email on the related problem of how to pass StateT callbacks to functons expecting IO callbacks a few years ago.
06:12:11 <ski> the "dreaded monad tunneling problem" ?
06:12:51 <quicksilver> I think I described it as an art rather than a problem, and spelt it the british way
06:21:53 <womb> hardcore / controversial: i know haskell is good for building APIs but what about building sites ? (web sites, RESTfull API's)
06:22:17 <scopedTV> It's fine IMO, although for very simple sites I'd prefer Python/Django.
06:22:46 <quicksilver> womb: http://softwaresimply.blogspot.co.uk/2012/04/hopefully-fair-and-useful-comparison-of.html
06:22:46 <hpc> for very simple sites, i think haskell does even better
06:22:58 <hpc> the syntactic cost of printing HTML is significantly less
06:23:29 <hpc> main = header $ do
06:23:34 <hpc>   h1 "Header"
06:23:36 <hpc>   p $ do
06:23:36 <t7> _not writing websites in agda... 2012..._
06:23:44 <womb> yeah but it is also problem if building more complex things using hardcore db
06:23:47 <womb> with haskell
06:23:51 <hpc>     putStrLn "oogle boogle"
06:23:54 <hpc> etc
06:24:39 <hpc> womb: there are some impressive db libraries already
06:24:43 <mm_freak_> i have a grammar for subtraction expressions like this:  diff = diff "-" diff | lit
06:25:14 <mm_freak_> i have converted it to a grammar that is not left-recursive for parsec, but now the subtraction is right-associative
06:25:24 <mm_freak_> does anyone know how to solve this problem?
06:25:48 <merijn> @djinn (s -> IO (a, s)) -> s -> IO (s, a)
06:25:49 <lambdabot> Error: Undefined type IO
06:26:04 <merijn> @djinn (Monad m) => (s -> m (a, s)) -> s -> m (s, a)
06:26:05 <lambdabot> -- f cannot be realized.
06:26:15 <mm_freak_> womb: personally i use yesod for web stuff
06:26:31 <lysgaard> If I want to do numerics in Haskell, random access arrays are a key component. Take row reducing a matrix as an example, what would be the best datatype to do that on? Also, let's restrict the matrix values to eg. Double.
06:26:48 <hpc> womb: i have a ~1000-line website with a blog, user account control, documentation for my IRC bot, and some old SVG generation code i am too lazy to exclude from the line count
06:27:14 <quicksilver> mm_freak_: your original grammar doesn't specify a unique association.
06:27:38 <hpc> womb: in fact, my bot itself used to be a transformer on top of my website's monad, so it could get database access
06:27:48 <quicksilver> mm_freak_: from a purely language theory point of view, (1-2-3) has two parses via that grammar.
06:27:55 <mm_freak_> quicksilver: i'm not partcularly skilled at making grammars, because this is my first time i have a complicated grammar to make
06:28:00 <womb> hpc: 1k lines is small and nice, but i fear i will reach problem like "integration oauth from facebook" API where i will have to input loads of work to complete it because there is nothing out there to use in terms of libs.
06:28:07 <womb> or framework says "don't like it"
06:28:15 <mauke> diff_tail x = do { char '-'; y <- lit; diff_tail (Diff x y) } <|> return x
06:28:23 <mauke> but I bet parsec has something for specifically this case
06:28:25 <quicksilver> mm_freak_: my point is that you've not broken anything in the conversion; the problem was in the initial grammar.
06:28:40 <mm_freak_> mauke: maybe, but i'd really like to learn this anyway
06:29:02 <mauke> oh, and diff = lit >>= diff_tail
06:29:09 <hpc> oauth is easy
06:29:24 <mm_freak_> mauke: ah…  is there a context-free way to express this?
06:29:39 <hpc> the hard part is reading through the damn documentation, which is a constant cost even if you use a library
06:29:40 <mauke> I don't know what context-free is
06:29:46 <scopedTV> mm_freak_: yes
06:30:18 <scopedTV> I think. But now I'm not sure.
06:30:19 <mm_freak_> mauke: i thought a grammar as simple as this should be context-free and thus expressible solely using applicative style
06:30:48 <mm_freak_> quicksilver: how exactly do i specify associativity in a grammer?
06:31:20 <mm_freak_> grammar
06:31:24 <quicksilver> mm_freak_: well mauke just showed a way.
06:31:24 <scopedTV> The standard trick is: Exp = Term | Exp + Exp; Term = Factor * Factor | Num; or something.
06:31:33 <scopedTV> At least for precedence.
06:31:39 <quicksilver> scopedTV: that's precedence.
06:31:46 <scopedTV> Yes.
06:31:50 <hpc> for associativity, you do something like
06:31:50 <quicksilver> scopedTV: mm_freak_ is concerned with fixing associativity.
06:31:53 <mm_freak_> scopedTV: yeah, i have a precedence parser working, but it has the wrong fixity
06:32:02 <quicksilver> mm_freak_: what mauke wrote was perfectly context-free
06:32:04 <hpc> ExpTail = + Exp ExpTail | ;
06:32:07 <scopedTV> Doesn't a similar trick work. for this.
06:32:10 <scopedTV> Right.
06:32:13 <ski> `Exp + Term' or `Term + Exp'
06:32:19 <quicksilver> mm_freak_: inserting extra productions is how you tweak the operational semantics
06:32:20 <hpc> ah, or that
06:32:25 <quicksilver> mm_freak_: to go down the leg you want.
06:32:28 <ski> hpc is talking about left-recursion
06:32:53 <womb> one more thing about tempaltes i need to have something like django templats | erb templates | ejs | because i need to be able to convert design into it.
06:33:00 <mm_freak_> isn't there a tutorial or something?  there is a lot about parsec, but little about how to make proper grammars
06:33:00 <womb> Heist seems to be nice
06:33:12 <hpc> ski: ah yeah; my compilers class was almost entirely operational details of LL/LR :/
06:33:27 <mm_freak_> and as a non-student i really have a hard time learning all this
06:33:29 <scopedTV> mm_freak_: you want to eliminate left-recursion?
06:33:38 <mm_freak_> scopedTV: no, i've done that already
06:33:39 <ski> hpc : not anything else than parsing !?
06:33:53 <mm_freak_> scopedTV: my parser interprets 1 - 2 - 3 as 1 - (2 - 3)
06:33:59 <hpc> ski: pretty much
06:34:02 <mekeor> DarkUnicorn: did you solve the currency-issue? i'd like to read the code :)
06:34:12 <hpc> this university's CS program is ridiculously operationally-oriented
06:34:22 <ski> mm_freak_ : maybe you should undo the left-recursion-elimination
06:34:34 <scopedTV> hpc: I had the same experience. 75% parsing, 25% the rest.
06:34:49 <scopedTV> mm_freak_: Yes, I'd fix the grammar first, then re-eliminate.
06:34:55 <mm_freak_> ok
06:34:57 <scopedTV> Your first grammar was ambigious.
06:35:03 <ski> hpc : i mean : didn't you learn anything about liveness analysis, code generation, checking variables are bound, type checking, &c. ?
06:35:07 <mm_freak_> let me give it a try
06:35:20 <ski> mm_freak_ : what is your original grammar ?
06:35:30 <hpc> ski: no, a bit at the end, just enough to write a symbol table, no
06:35:32 <hpc> respectively
06:35:33 <scopedTV> We did not cover *any* optimization techniques.
06:35:51 <scopedTV> Too bad, really, that's the fun part.
06:36:05 <scopedTV> But any CS student should write a compiler, at least once.
06:36:30 <mm_freak_> ski: my original grammar was:  diff -> diff "-" diff | lit
06:36:31 <hpc> my favorite professor taught the class though, which is the only reason i didn't drop the class :P
06:36:36 <mm_freak_> what about:
06:36:37 <mm_freak_> expr -> lit | diff
06:36:37 <mm_freak_> diff -> diff "-" expr
06:36:50 <scopedTV> That is better, I think.
06:36:55 <ski> and you want "-" to be left-associative ?
06:36:59 <mm_freak_> yeah
06:37:41 <mm_freak_> is this grammar correct for a left-associative "-"?
06:37:56 <ski> i don't think so
06:38:07 <ski> the `diff' in `expr' seems off
06:38:22 <hpc> diff is left-recursive, i think
06:38:25 <ski> also, that will insist on at least on "-" present
06:38:30 <ski>   diff -> diff "-" lit | lit
06:38:34 <ski> sounds to me what you're after
06:38:40 <mm_freak_> oh, i see
06:38:40 <ski> but that's left-recursive, of course
06:38:40 <hpc> ski: you missed expr -> lit | diff
06:38:42 <scopedTV> No, expr allows for "lit".
06:38:55 <mm_freak_> ski: i want to do the elimination once i get a correct grammar
06:39:05 <hpc> also, once you hit diff, there's no termination
06:39:07 <ski> hpc : i did not
06:39:16 <hpc> so it's either 0 minuses, or infinite
06:39:40 <ski> the naïve translation of this would be something like
06:40:00 <mm_freak_> diff -> diff "-" quot | quot
06:40:00 <mm_freak_> quot -> quot "/" lit | lit
06:40:16 <mm_freak_> is this correct for - and / with fixity and left-association?
06:40:21 <hpc> mm_freak_: yes
06:40:45 <mm_freak_> i see…  i think i'm getting it
06:40:48 <mm_freak_> thanks a lot guys
06:40:53 <scopedTV> exp -> exp - term | term; term -> lit | ( exp )
06:41:08 <scopedTV> Something like this?
06:41:26 <ski>   diff = do d <- diff
06:41:29 <ski>             sym "-"
06:41:32 <ski>             l <- lit
06:41:36 <scopedTV> But left-recursive obviously.
06:41:36 <ski>             return (Diff d l)
06:41:37 <ski>      <|> do lit
06:41:46 <scopedTV> ski: That does not terminate.
06:42:01 <scopedTV> Also, I'd prefer applicative style :) but that's minor.
06:42:05 <ski> adn to avoid the left-recursion, you'd transform this into
06:42:13 <DarkUnicorn> mekeor: at least typeclasses are working, now i'm thinking how to test with quickcheck when the Money constructor is not exported. i just pushed the current state
06:42:18 <mm_freak_> ski: let me try it, before you reveal =)
06:43:06 <hpc> DarkUnicorn: you want a test for "is the constructor exported", or you want "tests, but i don't have the constructor so it might be tricky"
06:43:09 <hpc> ?
06:43:25 <DarkUnicorn> hpc: the latter
06:43:30 <hpc> ah
06:43:32 <DarkUnicorn> see tests.hs
06:43:38 <hpc> was gonna say, "just compile it" ;)
06:43:44 <scopedTV> unsafeCoerce ? ;)
06:44:04 <DarkUnicorn> scopedTV: yeah, could go back right to ruby ;)
06:44:13 <hpc> DarkUnicorn: you have Eq, yes?
06:44:22 <DarkUnicorn> yes
06:44:32 <hpc> construct a "reference value", then have your test value, then compare
06:44:39 <quicksilver> DarkUnicorn: have a module called Foo.Internal which does export the types; have tests in a Tests module which imports the Internal module, but let your public interface not include the Internal module.
06:44:43 <hpaste> “Ertugrul Söylemez” pasted “Grammar for left-associative operators” at http://hpaste.org/68073
06:44:50 <hpc> or what quicksilver said...
06:45:08 <mm_freak_> is the paste correct for a right-recursive grammar with left-associative operators?
06:45:12 <quicksilver> although my instinct would not be that currency types need to be hidden
06:45:27 <DarkUnicorn> hpc: i need to give quickcheck the ability to generate arbitrary money values
06:45:38 <scopedTV> DarkUnicorn: make an Arbitrary instance?
06:45:55 <hpc> DarkUnicorn: oh
06:45:58 <DarkUnicorn> scopedTV: yeah, but how when i can't use the constructor
06:46:06 <hpc> DarkUnicorn: do it where you define the other instances
06:46:06 <scopedTV> You could do that inside your Internal module. quicksilver's suggestion is widely applied I think, to have an X.Internal module
06:46:20 <scopedTV> DarkUnicorn: In the .Internal module, otherwise you'd have an orphan instance anyway. (Not that bad in this case.)
06:46:38 <DarkUnicorn> i'll try the internal module
06:47:30 <DarkUnicorn> how should the Foo.Internal module get access to the not-exported things from my module?
06:47:47 <quicksilver> because that is where you put them.
06:47:49 <scopedTV> The .Internal module should contain them.
06:47:57 <DarkUnicorn> oh i see
06:48:04 <mm_freak_> i'll just implement it an see what i get =)
06:48:13 <scopedTV> so you'd have M, containing the import and re-exports the public interface, and M.Internal, containing the implementation details.
06:48:25 <DarkUnicorn> will try that, thank you!
06:48:28 <ski> mm_freak_ : hm, what's the original grammar for this `quot' ?
06:48:35 <scopedTV> M.Test imports M.Internal
06:49:36 <ski> mm_freak_ : also, i think your  diff'  is incomplete
06:49:53 <mm_freak_> ski: quot -> quot "/" lit | lit
06:50:04 <ski> ty
06:50:16 <mm_freak_> was my transformation wrong?
06:50:33 <ski> yes
06:50:53 <mm_freak_> let me try again
06:51:30 <ski> what should i call the datatype all this is parsed into ?
06:51:33 <ski> `Diff' ?
06:52:13 <hpaste> “Ertugrul Söylemez” annotated “Grammar for left-associative operators” with “Grammar for left-associative operators (annotation)” at http://hpaste.org/68073#a68074
06:52:25 <ski> (btw, i wouldn't call the  "(" diff ")"  case a literal -- however, it's atomic (wrt operators))
06:52:46 <mm_freak_> ski: right now i just want to get the parsing to work…  so the result should be a number
06:52:54 <mm_freak_> anyway, even before that i want to get a correct grammar
06:53:14 <mm_freak_> i have annotated my idea of a grammar with left-associative operators
06:53:18 <mm_freak_> is it correct?
06:53:22 <parcs`> mm_freak_: are you aware of Text.Parsec.Expr?
06:53:29 <mm_freak_> parcs`: yes
06:53:40 <mm_freak_> i'm ignoring that module intentionally
06:53:49 <parcs`> oh okay
06:58:16 <roconnor> how do I prove that (a* + b)* is the same language as (a + b)* ?
06:59:14 <t7> whats * in that context? 0
06:59:20 <scopedTV> One inclusion is trivial.
06:59:23 <roconnor> Kleene star
06:59:23 <mauke> kleene star
06:59:25 <Botje> you could expand the a* case.
06:59:26 <quicksilver> roconnor: by proving that every string in one is in the other.
06:59:35 <roconnor> quicksilver: I'd rather use algebra
06:59:37 <scopedTV> The other inclusion is also fairly trivial.
06:59:39 <Botje> a* = a a* | \epsilon
07:00:08 <hpc> (a + b)* = (a+b)* (a+b)* -- might start from here, perhaps
07:00:21 <sclv> yep!
07:00:25 <sclv> that takes you one way, easily.
07:00:40 <dzhus> What is the best way to maintain a bunch of really fast uncorrelated PRNGs? what is the fastest implementation for haskell?
07:01:00 <sclv> a* (a + b)* < (a+b)* (a+b)*
07:01:06 <roconnor> Botje: and a* = a* a + 1  ... and a x b <= b implies a* x b <= b ... and b x a <= b implies b x a* <= b ... here I'm using x for times.
07:01:49 <roconnor> sclv: using antisymmetry is such a pain.
07:02:35 <roconnor> sclv: but okay
07:02:54 <roconnor> I wish I had a list of standard theorems about regular expressions / kleene algebras.
07:03:20 <sclv> haha I actually have Kleene's introduction to metamathematics on my desk right now.
07:03:27 <scopedTV> Maybe use a** = a*. Pff.
07:03:28 <sclv> but I don't know what chapter to look up :-(
07:03:54 * scopedTV is happy that I could just say "it's trivial" in this case.
07:05:20 <mm_freak_> sum  -> prod sum'
07:05:21 <mm_freak_> sum' -> empty | "+" prod sum' | "-" prod sum'
07:05:27 <mm_freak_> is this transformation correct?
07:05:43 <mm_freak_> original production rule:  sum -> sum "+" prod | sum "-" prod | prod
07:05:45 <t7> Set should be an instance of num
07:05:54 <roconnor> scopedTV: I could use that regular language decision produdure right about now
07:05:54 <t7> save me some keystrokes
07:07:05 <sclv> this leaves out some steps, but should be the right path? (a* + b)*  -> a* (a* + b)* -> a* (a + b)* -> (a + b)*
07:11:31 <scopedTV> sclv: using inequalities there.
07:11:47 <scopedTV> Not the nicest way, but yeah.
07:11:55 <roconnor> scopedTV: no he isn't suggeting taht.
07:12:17 <scopedTV> Then i'm confused as to what ze is suggesting.
07:12:29 <scopedTV> Oh.
07:12:51 <scopedTV> Yeah you need some easy lemmata for that.
07:12:53 <quicksilver> I would personally prove it elementarily and then look at the steps and work out which of the steps are in fact proofs of useful laws
07:13:09 <quicksilver> then you get to invent your own algebraic system as you go.
07:13:18 <DarkUnicorn> just pushed the .Internal solution if anyone is interested :)
07:13:32 <roconnor> quicksilver: I already know what the axioms of a kleene algebra are ... just not what the theorems are.
07:13:34 <DarkUnicorn> works nicely :)
07:13:43 <roconnor> quicksilver: the main theorems.
07:13:53 <scopedTV> I'm sure somebody did some work to get this into Coq or something. :)
07:14:07 <roconnor> scopedTV: yes, there is a decision procedure in Coq for this
07:14:20 <roconnor> but importing it for this one problem isn't worthwhile.
07:14:36 <dgpratt> I know I'm preaching to the choir with this observation, but...
07:15:21 <hpaste> ski annotated “Grammar for left-associative operators” with “Grammar for left-associative operators (annotation)” at http://hpaste.org/68073#a68075
07:15:34 <ski> mm_freak_ ^
07:15:43 <dgpratt> I'm amused by what I percieve to be an increasing number of articles, blog posts, etc that say (in essence) "hey, if we throw out some of the basic tenets of OOP, objects work great!"
07:16:11 <ski> scopedTV : in case you're interested ^
07:16:12 <roconnor> dgpratt: yes: http://okmij.org/ftp/Computation/Subtyping/
07:17:04 <merijn> @pl \s -> swap <$> runStateT state s
07:17:04 <lambdabot> (swap <$>) . runStateT state
07:17:12 <dgpratt> roconnor: ah, interesting looking article; I'll have to add that to the queue
07:17:22 <mm_freak_> ski: thanks!
07:17:22 <quicksilver> merijn: see also evalStateT, execStateT
07:17:44 <mm_freak_> ski: you didn't have to write the code though, because i really want to get it right myself
07:17:56 <merijn> quicksilver: I know, but I need both state and result, but in reversed order
07:18:01 <merijn> (for use with modifyMVar)
07:19:10 <ski> mm_freak_ : my main point wasn't the transformed grammar, but how to write the code (specifically the passing of the "current result")
07:20:36 <ski> mm_freak_ : the state is the second argument
07:20:53 <mm_freak_> ski: yeah, i got that now…  my parser works except for one thing
07:20:59 <ski> (and yes, the state and the result ought to be in the other order in `State' -- ditto for `Writer')
07:21:01 <mm_freak_> 10 - 9 + 2 = 7
07:21:20 <t7> @hoogle (a -> c) -> (a, b) -> c
07:21:21 <lambdabot> Data.Graph.Inductive.Query.Monad orP :: (a -> Bool) -> (b -> Bool) -> (a, b) -> Bool
07:21:33 <scopedTV> dgpratt: Such as?
07:22:10 <ski> @type let (.) = (Prelude..) in (. fst)
07:22:11 <lambdabot> forall c a b. (a -> c) -> (a, b) -> c
07:22:33 <dgpratt> scopedTV: as seen on reddit recently, http://awelonblue.wordpress.com/2012/05/01/life-with-objects/
07:22:54 <mm_freak_> ski: maybe i'm misunderstanding…  do i /need/ that Diff type?
07:23:14 <ski> mm_freak_ : depends on whether you want a parse tree or not ..
07:23:15 <dgpratt> wherein the author espouses "stateless objects", which to me sounds like an oxymoron
07:23:17 <ski> > 10 - 9 + 2
07:23:18 <lambdabot>   3
07:23:23 <mm_freak_> ski: i don't
07:23:26 <mm_freak_> uhm
07:23:28 <mm_freak_> sorry
07:23:32 <mm_freak_> 10 - 1 + 2 = 7
07:23:34 <EvanR> but wait, oop isnt about mutable state at all!
07:23:34 <mm_freak_> with my parser
07:23:50 <EvanR> oop is never about what people say its about
07:23:52 <ski> mm_freak_ : looks like you've accidentally made it right-associative
07:23:52 <scopedTV> dgpratt: "stateless objects" = namespacing + encapsulation
07:24:09 <EvanR> classes used as namespaces pisses me off
07:24:13 <ski> mm_freak_ : are you sure you're passing the current result in the way i do ?
07:24:14 <dgpratt> scopedTV: what are we encapsulating, exactly?
07:24:14 <EvanR> use a namespace
07:24:17 <merijn> EvanR: Word
07:24:19 <mekeor> @remember EvanR oop is never about what people say its about
07:24:19 <lambdabot> Good to know.
07:24:24 <ski> @where object-oriented
07:24:25 <lambdabot> http://community.schemewiki.org/?object-oriented-programming
07:24:30 <sclv> if I have to use classes, I'd much prefer to only use them as namespaces :-)
07:24:34 <scopedTV> dgpratt: We're abstracting the state.
07:24:59 <hpaste> “Ertugrul Söylemez” annotated “Grammar for left-associative operators” with “(Buggy) code” at http://hpaste.org/68073#a68076
07:24:59 <dgpratt> scopedTV: you see my point about the oxymoron, then?
07:25:05 <scopedTV> dgpratt: I do.
07:25:25 <mm_freak_> ski: that's my code
07:25:44 <ski> yeah, that's wrong :)
07:25:51 <ski> it should be something like
07:26:05 <scopedTV> ski: using >>= in applicative code, tss ;)
07:26:16 <ski>   fmap (c +) (try $ opP '+' *> prodP) >>= sumT
07:26:26 <ski> scopedTV : can't be avoid here, afaics
07:26:44 <ski> mm_freak_ : i.e. you had wrong bracketing
07:26:54 <mm_freak_> oh
07:27:01 <mm_freak_> of course =)
07:27:12 <ski> the result of `c + ...' should be passed on to `sumT' as the "current result"
07:27:40 <t7> that feel when line is 80 characters long. and its friday. and 3 day weekend
07:27:52 <t7> its the simple things that make me happy
07:27:56 <mm_freak_> yeehaa
07:27:58 <mm_freak_> it works
07:28:02 <mm_freak_> thanks a lot, ski =)
07:28:30 <mm_freak_> % ./test3 '10 - 2*3 + 11'
07:28:31 <mm_freak_> 15
07:28:33 <mm_freak_> great stuff
07:28:48 * hackagebot wai-middleware-route 0.6.0 - Wai dispatch middleware  http://hackage.haskell.org/package/wai-middleware-route-0.6.0 (AlexanderDorofeev)
07:29:13 <ski> scopedTV : hm, i suppose it might be possible to make the continuation parser construct a function .. hm
07:30:06 <hpaste> mekeor pasted “why does this tiny happstack-code not work?!” at http://hpaste.org/68077
07:30:16 <mekeor> please help me with this code ^ ;-(
07:31:41 <quicksilver> mekeor: you don't have a ToMessage instance for Blaze's HTML type
07:31:48 <quicksilver> is what that error says.
07:32:03 <mm_freak_> final question:  opParser :: (Expr -> Expr -> Expr) -> Parser Expr -> String -> Parser Expr
07:32:03 <mekeor> quicksilver: but that code worked recently. today it doesn't. i don't undertand this.
07:32:21 <mm_freak_> is this a proper combinator for constructing left-associative operator parsers dynamically?
07:32:23 <hiptobecubic> Why is it a good rule of thumb to not write your own typeclasses?
07:32:45 <mm_freak_> hiptobecubic: because most of the time people abuse type classes because they think in OO terms
07:33:00 <mm_freak_> hiptobecubic: i write large programs without a single type class
07:33:04 <quicksilver> mekeor: you must have changed your libraries?
07:33:10 <quicksilver> mekeor: upgraded something?
07:33:13 <mekeor> quicksilver: i wrote this code a few weeks before. it worked. i don't know what happend but i really don't understand why there's no such instance anymore… :/
07:33:35 <mekeor> quicksilver: maybe. i don't remember exactly...
07:33:53 <t7> @hoogle Set a -> (a, Set a)
07:33:54 <lambdabot> Data.Set deleteFindMax :: Set a -> (a, Set a)
07:33:54 <lambdabot> Data.Set deleteFindMin :: Set a -> (a, Set a)
07:33:54 <lambdabot> Data.Set maxView :: Set a -> Maybe (a, Set a)
07:34:06 <mekeor> quicksilver: also, the #happs channel doesn't respond to my question. they're away, i think.
07:34:20 <hiptobecubic> mm_freak_, hmmm. that sounds suspiciously like what I did. How are they supposed to be thought of then? They are great for implementing some kind of standard interface on top of different types
07:35:06 <quicksilver> mekeor: I don't know what package normally provides that instance I'm afraid.
07:35:42 <mekeor> quicksilver: the problem is that there is actually such an instance: see http://hackage.haskell.org/packages/archive/happstack-lite/latest/doc/html/Happstack-Lite.html#v:toMessage
07:35:46 <hpaste> Eidel pasted “inorder error” at http://hpaste.org/68078
07:35:48 * quicksilver nods
07:35:54 <roconnor> sclv: I ended up using anti-symmetry plus a horrible proof.
07:35:59 <quicksilver> mekeor: maybe two different versions of blaze installed?
07:36:07 <Eidel> Can anyone please se the error in my code^ ?
07:36:09 <mm_freak_> hiptobecubic: that's difficult to answer…  as someone with OO experience likely you have made separate data-types for things which really belong into a single one
07:36:10 <ski> @hoogle f (a -> b) -> f (b -> c) -> f (a -> c)
07:36:10 <lambdabot> Data.Generics.Schemes everywhereBut :: GenericQ Bool -> GenericT -> GenericT
07:36:19 <ski> @hoogle f (b -> c) -> f (a -> b) -> f (a -> c)
07:36:19 <lambdabot> Data.Generics.Schemes everywhereBut :: GenericQ Bool -> GenericT -> GenericT
07:37:02 <mekeor> quicksilver: indeed.
07:37:34 <hpaste> ski annotated “Grammar for left-associative operators” with “purely applicative version” at http://hpaste.org/68073#a68079
07:37:44 <hiptobecubic> mm_freak_, well. I am trying to model two different financial options. A 'vanilla' and an 'asian'. They have the same properties mostly, but the properties may be computed differently depending on the contract.
07:37:57 <hiptobecubic> mm_freak_, would that engender making two different types?
07:38:00 <ski> scopedTV,mm_freak_ : i think that ^ should be a working purely applicative version
07:38:13 <ski> but the lambdas there are ugly
07:38:16 <mekeor> Eidel: what's the problem?
07:38:30 <ski> in this particular case, you could `flip', but it wouldn't be so easy for more than two arguments
07:38:33 <Eidel> mekeor: compiler error: parse error on input `='
07:38:39 <EvanR> hiptobecubic: factor out the contract type as Vanilla | Asias and thats it
07:38:53 <EvanR> and include that in the larger common data structure
07:39:01 <EvanR> Asian*
07:39:48 <mm_freak_> ski: monadic style seems reasonable here =)
07:40:08 <mm_freak_> hiptobecubic: make a single type for now
07:40:08 <ski> mekeor : yeah, or the half-applicative, half-monadic style :)
07:40:23 <mm_freak_> hiptobecubic: data Option = Vanilla X | Asian X
07:40:24 <mekeor> ski: huh?
07:40:31 <mekeor> :)
07:40:36 <ski> hiptobecubic : alternatively make a single type for a financial option, and just make two functions `vanilla' and `asian' which constructs values of this type
07:40:55 <Eidel> What does the 'as' keyword do?
07:41:07 <mm_freak_> Eidel: in import statements?
07:41:10 <ski> mekeor : the version at the end of my first annotation, which used both the applicative `<*>',`<*',`*>' operations, as well as the monadic `=<<'
07:41:12 <mm_freak_> if yes, it renames the module
07:41:19 <mm_freak_> import qualified Data.Map as M
07:41:19 <Eidel> mm_freak_: no, in functions
07:41:20 <hpc> Eidel: import qualified Data.ByteString.Lazy as BSL
07:41:25 <EvanR> mm_freak_: whats with the X
07:41:28 <hpc> foo = BSL.pack "foo"
07:41:34 <rwbarton> roconnor: why would the proof be horrible?  a* <= (a+b)* and b <= (a+b)* so a*+b <= (a+b)* and therefore (a*+b)* <= (a+b)*, and the other inequality is immediate
07:41:45 <mm_freak_> Eidel: could you give an example?
07:42:13 <mm_freak_> EvanR: i don't know hiptobecubic's application, but in most cases you'll want to assign the constructor to some information (the X)
07:42:14 <ski> scopedTV : any suggestion for improvement ?
07:42:27 <mm_freak_> EvanR: like Either e a = Left e | Right a
07:42:50 <EvanR> why not Contract contains basically a Bool
07:42:55 <EvanR> A | B
07:43:03 <EvanR> factored
07:43:11 <mm_freak_> EvanR: because the factored version is more error-prone
07:43:15 <EvanR> it is?
07:43:29 <mm_freak_> my type forces you to carry around the annotation
07:43:45 <EvanR> no it doesnt
07:43:50 <Shinka> I'm trying to setup a .ghci file but I run into "warning this file is writable by someone else, ignoring". I googled the problem and found the solution ($ chmod g-w .ghci) but surprisingly it doesn't work.
07:43:55 <EvanR> you can just carry on the X
07:44:00 <mm_freak_> EvanR: you need to factor out explicitly
07:44:03 * ski isn't sure hiptobecubic even wants to have different alternatives
07:44:12 <hpc> Shinka: chmod 644 ~/.ghci
07:44:19 <mm_freak_> gimmeAsian :: X -> Option
07:44:22 <hpc> Shinka: could be group permissions
07:44:30 <rwbarton> in general  data Foo = A X | B X  means (or should mean) something different than  data Bar = Bar AorB X
07:44:33 <mm_freak_> it's easier to make mistakes with a factored type
07:44:41 <hpc> and make sure it's chown'd to you, too
07:45:00 <mekeor> quicksilver: the problem really was the new version of the blaze-html. thank you. stepkut, from #happs, finally showed me how to solve this issue. life is great again! =) yippie yaaayayayaay
07:45:01 <Shinka> @hpc: ah! it works, thanks!
07:45:02 <lambdabot> Unknown command, try @list
07:45:20 <ski> s/@hpc/hpc/
07:45:35 <EvanR> mm_freak_: i still dont understand
07:45:52 <EvanR> how would you make a mistake with the A|B as a field
07:46:59 <rwbarton> here is an example
07:47:14 <rwbarton> data TemperatureReading = Celsius Double | Fahrenheit Double
07:47:25 <rwbarton> vs. data TemperatureReading = TemperaturReading TemperatureScale Double
07:47:38 <hpc> the latter is a form of "boolean blindness"
07:47:51 <hpc> https://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
07:47:58 <rwbarton> in the latter case you can extract the Double with pattern matching while ignoring the scale, this is a bad thing to do though
07:48:05 <mauke> data Expr = BinExpr BinOp Expr Expr
07:48:08 <rwbarton> in that it is meaningless given the semantics of TemperatureReading
07:48:15 <EvanR> rwbarton: seems like you can do the same with the first one even easier
07:48:23 <rwbarton> er, no?
07:48:35 <rwbarton> you would have to write two separate pattern matches
07:48:46 <mauke> case x of _ n -> n
07:48:46 <rwbarton> of course if you were really dedicated you could still make the same mistake, but it's definitely harder
07:49:14 <EvanR> so its better just because of the way haskell does pattern matching
07:49:25 <rwbarton> it is better if/when it represents the semantics of your data better
07:49:31 <rwbarton> consider instead
07:49:39 <EvanR> thats what i thought
07:49:39 <rwbarton> data Person = Person Gender String
07:49:46 <rwbarton> vs. data Person = MalePerson String | FemalePerson String
07:49:50 <rwbarton> where the String is the name
07:50:23 <EvanR> is all this dependent on the fact that theres a bool involved
07:50:26 <EvanR> what if its more than two cases
07:50:38 <EvanR> A X| B X | C X | D X | ...
07:50:41 <EvanR> :S
07:50:45 <rwbarton> same deal
07:50:48 <luite> is it possible to generate a complete trace of function calls with ghc somehow, that includes what is being evaluated where? (with realtime output, the program crashes, so a profiling summary doesn't seem to be useful)
07:50:58 <EvanR> well this 'optimization' seems like you can only do it once
07:51:07 <rwbarton> this is why people who ask "how do I write  foo (A x) = x; foo (B x) = x; foo (C x) = x; ..." are asking the wrong question
07:51:08 <Philippa> Gender's a particularly bad example for that one, given the range of identities out there in the wild and the changing nature of legislation about it
07:51:21 <EvanR> whatever is in X cant be pulled into the constructor without going quadratic with the number of constructors
07:51:29 <Philippa> you also have to pick which quality is worthy of being used as the constructor
07:51:33 <ClaudiusMaximus> luite: tried +RTS -xc ?
07:51:36 <mauke> type Gender = String
07:51:45 <ben> Maybe String
07:51:51 <mauke> haha
07:51:52 <ski> on this ADT topic, "Using Algebraic Datatypes as Uniform Representation for Structured Data" by Markus Mottl in 2003-03-10 at <http://www.ocaml.info/oefai/papers/algebraic_dts/> might be interesting
07:52:06 <luite> ClaudiusMaximus: it's a segfault, not an exception
07:52:13 <rwbarton> if it made sense to write that function foo, it means they organized their data structure wrong
07:52:15 <Philippa> ben's right btw: that'd be a good friend of mine locally
07:52:31 <luite> ClaudiusMaximus: does it also work for those?
07:52:37 <EvanR> i probably need a better data example
07:52:41 <EvanR> Person is pretty bad
07:52:46 <ClaudiusMaximus> luite: i'm guessing not
07:53:17 <luite> ClaudiusMaximus: I might try, but i asked first because it takes a lot of time to build the profiling version of everything
07:54:30 <Philippa> FWIW: algebraic datatypes aren't the best way to tackle boolean blindness in the long run, but doing a /really/ good job seems to need something analogous to dependent types
07:54:43 <Philippa> (which is a really good argument for having them even if you're not in a proving mood)
07:54:43 <ClaudiusMaximus> luite: btw, .prof files only get written on exit, so segfault might lead to empty file
07:55:04 <zachk> is hackage down? :-(
07:55:07 <luite> ClaudiusMaximus: yeah i know
07:55:16 <adu> Philippa: what is boolean blindness?
07:55:32 <xraycat> zachk: not for me
07:55:34 <Philippa> https://t.co/5WSvsiz7
07:55:53 <Philippa> when your data's all booleans/bits and you can't see what they actually /mean/, basically
07:55:58 <hpc> adu: see my link up above?
07:56:02 <hpc> er, -?
07:56:10 <luite> ClaudiusMaximus: the segfault happens only with ghci somehow, when running a large program with lots of dependencies
07:56:22 <EvanR> just throw it all in a normalized relational db
07:56:31 <EvanR> and let the query writer figure it out
07:56:32 <zachk> the hackage website is up, it does not respond to ping and my cabal will not update :^-/
07:57:04 <roconnor> adu: boolean blindness is the fact that when you do a case analysis on a Bool, your context remains unchanged so your types haven't learned anything.
07:57:30 <ski> Philippa : (re FWIW), *nod*
07:57:42 <mm_freak_> huh?!
07:57:51 <mm_freak_> case x of _ y -> …
07:57:52 <roconnor> adu: compare this to doing case analysis on Either.
07:58:02 <mm_freak_> i didn't know that was a valid pattern
07:58:16 <xraycat> zachk: sry, I see, have the same problem
07:58:22 <ski> > case Left () of _ y -> y
07:58:23 <lambdabot>   <no location info>: Parse error in pattern
07:58:43 <roconnor> I swear, just adding sum types to Java/C++/C# would improve productivity 10x.
07:58:49 <zachk> xraycat: I am downloading the tar ball of the latest packages, hopefully it shouldn't be too painful to install what I need from that
07:58:53 <ski> hear hear
07:59:09 <zachk> roconnor: sum types?
07:59:17 <ski> aka variant types
07:59:24 <hpc> roconnor: another 10x if you remove "extends" inheritance at the same time
07:59:27 <Mathnerd314> roconnor: tagged or untagged?
07:59:28 <roconnor> zachk: types of the form A + B ... eg Either A B.
07:59:34 <zachk> ahhh
07:59:49 <ski> discriminated records in Pascal is sortof the same -- but will less static checking
08:00:09 <roconnor> Mathnerd314: such implementation details do not concern me, but I can't imagine how to do it untagged. ... so tagged then.
08:00:19 <mauke> roconnor: untagged is union
08:00:25 <roconnor> ah I see
08:00:31 <ski> roconnor : it could be untagged, if it's unboxed
08:00:39 <roconnor> definitely tagged, otherwise you cannot do type safe case analysis.
08:00:54 <ski> (i.e. if you pass one continuation for each variant)
08:01:08 <linduxed> is there a way to debug haskell code step by step?
08:01:38 <zachk> linduxed: the simple answer is: not really afaik
08:01:46 <Ragnaroek> do you do MVC in Haskell?
08:01:46 <roconnor> ghc has some sort of debugger, but I haven't used it.
08:01:49 <linduxed> :-(
08:01:55 <k-zed_> (i'm a total amateur but) i tried that once
08:01:57 <EvanR> Ragnaroek: yeah
08:01:59 <k-zed_> it's sort of possible
08:02:00 <adu> roconnor: hpc: Philippa: so boolean blindness is just that booleans don't contain enough data?
08:02:05 <k-zed_> but the steps aren't what you expect them to be
08:02:08 <k-zed_> and it's generally a pita
08:02:12 <ski> there is Buddha, but i'm not sure whether it works with current versions of GHC,Hugs
08:02:14 <roconnor> linduxed: in fact, rather than step by step, due to refenetially transparency you can debug in any order you want. :D
08:02:17 <ski> @where Buddha
08:02:17 <lambdabot> http://www.cs.mu.oz.au/~bjpop/buddha/
08:02:26 <ski> @where stepeval
08:02:26 <lambdabot> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
08:02:32 <ski> is for small snippets
08:02:34 <roconnor> adu: I wouldn't really phrase it that way.
08:03:00 <hiptobecubic> linduxed,  google for ghci debug. There is a debugger that lets you step through a program and inspect results. it's pretty good.
08:03:05 <ski> adu : it's more like the meaning of the boolean isn't (explicitly) linked to the rest of the data
08:03:44 <Philippa> adu: it's that they contain /no/ statically-usable data
08:03:57 * hackagebot texmath 0.6.0.6 - Conversion of LaTeX math formulas to MathML or OMML.  http://hackage.haskell.org/package/texmath-0.6.0.6 (JohnMacFarlane)
08:04:02 <Philippa> an Either does: you can tell statically what the options "mean" as types
08:04:15 <t7> how can i calculate M in the implicit contraint: http://igitur-archive.library.uu.nl/math/2007-1122-200535/heeren_02_generalizinghindleymilner.pdf
08:04:21 <t7> its not very clear
08:04:30 <Philippa> whereas Bool's type is, um, Bool. Not a single bit worth of info there
08:05:21 <EvanR> you have in your hand a bit, but theres no intrinsic meaning. you have to keep track of the meaning separately from the program, and make sure the program is correct
08:05:35 <Ragnaroek> or is there something else for gui programming in haskell?
08:05:40 <EvanR> ive noticed this problem with more than just bits
08:05:47 <EvanR> but i dont know how to fix it
08:05:53 <Philippa> strings are a frequent offender
08:06:07 <ski> @quote stark
08:06:07 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
08:06:27 <merijn> roconnor, ski, Philippa: So similar to McBride defining things like an "Eq x y" type rather than use Bool, because it loses the type context?
08:06:34 <adu> EvanR: that sounds like general impedance mismatch between humans and silicon
08:06:45 <ski> merijn : yes
08:07:00 <hiptobecubic> :qa
08:07:26 <Philippa> adu: it's more about the languages we use before we extract the version for the silicon
08:07:31 <ski> unknown command ':qa'
08:07:39 <Philippa> C, to pick an example, can't talk about what bits mean. Coq can
08:08:09 <adu> Philippa: have you heard of Alexey Radul?
08:08:10 <Philippa> it's still about the static phase rather than the dynamic one
08:08:32 <Philippa> nope?
08:09:27 <adu> he's one of those MIT guys trying to replace state machines and lambda calculus
08:09:53 <Philippa> I don't really know what MIT've been up to so much
08:10:08 <Philippa> I'm flicking through his stuff on the web though
08:10:11 <adu> http://web.mit.edu/~axch/www/phd-thesis.pdf
08:11:03 <hpaste> “Ertugrul Söylemez” pasted “Expression parser with fixity and left-association” at http://hpaste.org/68080
08:11:09 <mm_freak_> that parser works
08:11:13 <mm_freak_> thanks to all of you =)
08:11:22 <adu> he's got an interesting model that (I think) could decrease that general impedance mismatch about 50-fold
08:12:08 <Philippa> is there a tl;dr version? I'm mostly used to working with propagators in a constraint programming context
08:13:31 <Philippa> a minimal language, say
08:13:59 <Philippa> I guess I'm also wondering if it comes with anything like a logic: Curry-Howard is important
08:13:59 <Mathnerd314> I'd like to write two functions, writeParameter :: (x : X) -> case x of { A -> String; B -> Int; C -> Bool } -> IO () and readParameter :: (x : X) -> IO (case x of { A -> String; B -> Int; C -> Bool } ). But Haskell isn't dependently typed; so what should I write instead?
08:14:00 <adu> Philippa: http://groups.csail.mit.edu/mac/users/gjs/propagators/
08:15:07 <ski> mm_freak_ : yw :)
08:16:05 <Philippa> adu: hmm. It seems like it's more sensible as a 'higher level' thing - typed lambda calculus being the machine code of static typing
08:16:24 <Philippa> but I suspect you're not as interested in static typing as some of us?
08:16:35 <adu> I love static typing
08:16:49 <adu> but static typing can be considered as a cell
08:17:24 <adu> and a Cell could be considered a typeclass, Alexey Radul admited he designed Cells based on Monads
08:17:25 <EvanR> dynamic typing is a missing feature
08:17:43 <EvanR> or something which can be built on top of static typing, but usually isnt
08:18:11 <ski> Mathnerd314 : write `writeParameter :: X x -> x -> IO ()' with `data X :: * -> * where A :: X String; B :: X Int; C :: X Bool'
08:18:31 <adu> EvanR: you obviously haven't heard of Typeable
08:18:36 <Philippa> heh. Yes, I suspect I can see what cells are before reading the definition? Actually I'm finding myself reading this as a nice refinement of OO
08:18:42 <mm_freak_> i figured it's better to write 'try (opP opStr) *> higherP' instead of trying all of it
08:19:02 <mm_freak_> it improves error messages, makes the parser faster and the grammar stricter
08:19:03 <t7> whats upsidedown U mean in Set theory?
08:19:16 <ski> mm_freak_ : note that it only handles left-associative operators, though
08:19:23 <EvanR> adu: thats why i mentioned built on top of static
08:19:25 <ski> t7 : intersection
08:19:33 <adu> Philippa: his cell's are not what you would expect, he's removed time from propagators and put it hidden away in cells, so there is no such thing as race condition in propagator networks
08:19:35 <mm_freak_> ski: i know…  fortunately i now already know how to do right-associative operators =)
08:19:42 <EvanR> adu: so youre obviously in need of less 'obviously'
08:19:54 <Mathnerd314> ski: ah, GADT's. Thanks! :-)
08:20:10 <mm_freak_> ski: i just have to figure out how to handle to "x + y - z" case, where + and - have different association properties…  i.e. how to detect the case and throw an error
08:20:15 <Philippa> adu: you might be surprised by what I'd expect :-)
08:20:39 <Philippa> (but that's /as/ I read: I'm not saying it's not important work and it's certainly work I hadn't /done/ even if I'd mused about how to sketch it)
08:21:04 <ski> mm_freak_ : i thought they had the same associativity in your case
08:21:13 <mm_freak_> ski: it was just an example
08:21:22 <ski> ok
08:21:37 <mm_freak_> anyway, i gotta go now…  thanks for your help
08:21:44 <ski> happy hacking !
08:24:33 <zachk> is there an idiomatic function for applying a function to just the head of a list, whilst still keeping the list intact?
08:25:00 <hpc> zachk: no, but you can define it
08:25:05 * hpc would name it (<:>)
08:25:15 <Bytter> > :t (&&&)
08:25:16 <lambdabot>   <no location info>: parse error on input `:'
08:25:17 <sclv> onHead
08:25:18 <adu> EvanR: apologies, I'm still waking up
08:25:24 <sclv> is what i would name it.
08:25:24 <Bytter> :t (&&&)
08:25:25 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
08:25:27 <sclv> or mapHead
08:25:31 <Bytter> :t (-<)
08:25:32 <lambdabot> Not in scope: `-<'
08:25:44 <Bytter> is -< part of the standard libraries?
08:25:48 <sclv> that's a special arrow symbol, not an operator
08:26:09 <hpc> it can be an operator
08:26:13 <hpc> if you don't turn on the extension
08:26:21 <EvanR> f <:> x:xs = f x : xs
08:26:27 <Bytter> sclv: so it's part of the language?
08:26:37 <EvanR> f <:> [] = launchMissiles
08:26:40 <scopedTV> it's part of an extension of Haskell.
08:26:45 <Bytter> scopedTV: ok
08:26:49 <zachk> yay hackage is working again
08:26:50 <sclv> Bytter: http://www.haskell.org/arrows/syntax.html
08:27:23 <hpc> arrow syntax is bamboozling, and you should assume it doesn't exist
08:31:33 <hpc> fleeting thought: writing bad haskell is hard
08:31:57 <hiptobecubic> hpc, i disagree.
08:32:01 <hiptobecubic> I'm an expert
08:32:32 <hpc> hiptobecubic: oh, lemme add you to this repository then... https://github.com/headprogrammingczar/php-haskell-prelude
08:32:58 <tgeeky> hpc: I didn't know that's what hpc stood for. hillarious
08:33:05 <hpc> ooold nickname
08:33:14 <hpc> not even mine; i just liked it as a username
08:33:21 <hpc> *not even my ide
08:33:22 <hpc> a
08:33:47 <parcs`> hpc: oh i though php haskell prelude was a thing written in php
08:34:04 <hpc> no, it's my personal quest to write the worst haskell code ever
08:34:07 <sclv> hpc: you need to redefine the dot operator!
08:34:18 <tgeeky> hpc: in the same way that PHP is a bad version of perl?
08:34:25 <applicative> awesome haskell in that php-haskell package...
08:34:28 <tgeeky> hpc: that's so avant-garde!
08:34:29 <sclv> and write a "records" system out of maps.
08:34:42 <sclv> and use ad-hoc overloading for everything.
08:34:48 <hiptobecubic> tgeeky, perl is a bad version of perl
08:35:08 <sclv> class Apply a b c | a b -> c
08:35:14 <tgeeky> hiptobecubic: maybe, but you had to write it once to find out.
08:35:25 <tgeeky> hiptobecubic: the PHP authors should have known better!
08:35:54 <EvanR> lol php
08:36:00 <sclv> oh, and write all your functions uncurried!
08:36:14 <applicative> you don't use compare on  the rhs  I'm trying to figure out the consequences
08:36:21 <ski> hpc : check out <http://pleac.sourceforge.net/pleac_haskell-on-steroids/index.html>
08:36:45 <applicative> uncurried is better, it adds an extra layer of laziness and confusion
08:36:45 <sclv> class Equals a b where (==) :: a -> b -> Bool
08:36:51 <EvanR> php is currently a bad version of java
08:36:56 <EvanR> its evolving
08:36:58 <sclv> instance Equals Int String where...
08:37:02 <EvanR> one day it will be a bad version of haskell
08:37:07 <parcs`> @check \a b
08:37:07 <lambdabot>   Parse error at end of input
08:37:19 <sclv> oh and have everything take Dynamics1
08:37:29 <tromp_> :t Ord
08:37:30 <lambdabot> Not in scope: data constructor `Ord'
08:37:40 <tromp_> :t ord
08:37:41 <lambdabot> Char -> Int
08:37:44 <mefisto> EvanR: it's like a snowball rolling down the computing hill, growing larger and larger as it picks up the worst features of the langauges it encounters
08:38:05 <parcs`> @check \a b -> b <= 0 || (a `mod` b == a .&. pred b)
08:38:06 <lambdabot>   "Falsifiable, after 23 tests:\n4\n3\n"
08:38:07 <EvanR> so it will pick up update syntax from haskell? ;)
08:38:24 <ski> long_palindromes = cat "/usr/share/dict/words" >>> filter(\s -> s == s.reverse && s.length > 4)
08:38:31 <EvanR> or the original monad/applicative/functor hierarchy
08:38:39 <tromp_> > map ord "=+*xostd"
08:38:40 <lambdabot>   [61,43,42,120,111,115,116,100]
08:39:02 <hpc> added a Num String instance :D
08:39:03 <tromp_> > map char $ sort $ map ord "=+*xostd"
08:39:04 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
08:39:04 <lambdabot>         against inferred type...
08:39:21 <EvanR> > "x" + "y"
08:39:23 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
08:39:23 <lambdabot>    arising from a use of `GH...
08:39:23 <ski> hpc : any comment on PLEAC-Haskell ?
08:39:42 <tromp_> > map chr $ sort $ map ord "=+*xostd"
08:39:43 <lambdabot>   "*+=dostx"
08:39:44 <applicative> there are surprisingly few good palindromes in /usr/share/dict/words
08:40:36 <keseldude> > filter (\x -> length x > 1) . nub $ concatMap inits (tails [1..4])
08:40:38 <lambdabot>   [[1,2],[1,2,3],[1,2,3,4],[2,3],[2,3,4],[3,4]]
08:40:39 <Jaak> > sort "=+*xostd"
08:40:40 <lambdabot>   "*+=dostx"
08:40:52 <keseldude> can you think of a better way to do what I did?^
08:41:41 <hpc> ski: didn't know it existed
08:41:42 <quicksilver> well the nub is not necessary in that example
08:41:55 <quicksilver> but it would make a difference on [1,2,1,2]
08:42:38 <ski> > (concatMap (tail . tail . inits) . init . init . tails)  [0,1,2,3]
08:42:39 <lambdabot>   [[0,1],[0,1,2],[0,1,2,3],[1,2],[1,2,3],[2,3]]
08:42:53 <keseldude> oh wow
08:43:05 <vhd> http://upload.wikimedia.org/wikipedia/commons/f/fc/Thunk-layers.png <- this is missing steps, yes?
08:43:17 <ski> > (concatMap (init . init . tails) . tail . tail . inits)  [0,1,2,3]
08:43:18 <lambdabot>   [[0,1],[0,1,2],[1,2],[0,1,2,3],[1,2,3],[2,3]]
08:43:37 <applicative> vhd: you mean thunks?
08:43:40 <ski> > (concatMap (init . init . tails) . tail . tail . inits)  []
08:43:41 <lambdabot>   *Exception: Prelude.tail: empty list
08:43:45 <vhd> applicative, yes.
08:44:17 <ski> hpc : note the use of `.' in those pages
08:44:26 <applicative> It depicts the order of evaluation of an expression.  A thunk is as yet unevaluated, to put it crudely
08:44:37 <hpaste> naren pasted “wholefunc” at http://hpaste.org/68083
08:44:58 <dmwit> > '!' < 't'
08:44:59 <lambdabot>   True
08:45:23 <applicative> vhd, so we can see that lambdabot only gets to the third level if I write
08:45:24 <narens> Hello! I have a question about performance regarding the code I pasted http://hpaste.org/68083
08:45:27 <dmwit> > sort "got gaM"
08:45:28 <lambdabot>   " Maggot"
08:45:44 <applicative> > fst (4,error "its a list in the png")
08:45:44 <vhd> yes, so for example head [undefined] would first go, thunk:thunk then undefined:thunk?
08:45:45 <lambdabot>   4
08:46:25 <applicative> > fst(4, head [undefined] )
08:46:26 <lambdabot>   4
08:46:32 <vhd> I guess what I am getting at, the caption for that image is "Evaluating the value (4, [1, 2]) step by step. The first stage is completely unevaluated; all subsequent forms are in WHNF, and the last one is also in normal form."
08:46:46 <applicative> so here even head is never looked at or developed
08:47:01 <dmwit> narens: Well, then, you should ask your question.
08:47:11 <dmwit> I've got to run, but I'm sure somebody will try to help.
08:47:13 <narens> dmwit: thanks. here goes
08:47:39 <applicative> vhd, right, does the caption seem  wrong?
08:48:46 <narens> My question is this. In the pasted file in the main function there is a commented line and an uncommented line and when I profile the two runs the commented line uses 2.5% GC time and the uncommented uses more than 30% GC time...the only difference is an accumulating paramater I want to keep. I am not sure how to improve the perf
08:49:20 <vhd> yes, because it seems it would need to go (thunk, thunk), then, (4, thunk) - (4, thunk : thunk) - (4, 1:thunk) so on
08:49:30 <vhd> it seems to be missing the thunk of the head part.
08:51:41 <applicative> vhd, right, it goes too fast, between (4,thunk) and (4, 1:thunk) comes (4,thunk:thunk)  -- you can recognize its a cons before  recognizing any element
08:51:46 <EvanR> does 'normal form' imply 'head normal form'
08:52:02 <hpaste> keseldude pasted “all sequences” at http://hpaste.org/68084
08:52:24 <vhd> applicative, yeah I just reread the caption and it doesnt say all :(, but yeah I assumed that was "all the steps".
08:52:51 <applicative> yeah, its either a mistake or a simplification
08:53:09 <narens> help?
08:53:14 <vhd> no its a mistake on my end, though I would recommend to include all steps
08:53:32 <ski> narens : `wholeMap' isn't incremental
08:54:13 <narens> ski: yea, but surely there must be a way to accumulate a paramter while joining lists withougt such a big perf hit
08:54:57 <applicative> > map snd $ zip (undefined:undefined:[])  (1:2:3:[])
08:54:58 <lambdabot>   [1,2]
08:54:59 <ski> narens : are you sure you can't just use `output ++', like in the other version ?
08:55:17 <narens> ski: but the other version cannot accumulate a value like mapAccum in Data.List
08:55:45 <ski> narens : so combine the best of both ?
08:55:50 <applicative> vhd ^^ there it recognizes the cons and uses them to make the length of the final list, but doesn't look at the things consed
08:55:57 <narens> ski: how that's what i tried to do
08:56:12 <narens> ski: I'm having trouble knowing where exactly the inefficieny is..
08:56:14 <ski> you also put `output' into an accumulator
08:56:24 <ski> i think you don't want to do that
08:56:46 <narens> ski: I did it the other way and it was worse
08:56:57 <ski> i think the inefficiency is probably because it's building the whole list at the same time in memory
08:57:24 <ski> which other way are you talking about here ?
08:58:00 <narens> ski: see, originally i just used Applicative instead so the last line was just (++) <$> output <*> wholeMap...
08:58:35 <narens> ski: something like what Data.Traversable does...
08:58:57 <ski> hm
09:03:09 <ski> narens : and that was not good either ?
09:03:10 <narens> ski: this is what i had originally:
09:03:13 <hpaste> naren pasted “wholefunc again” at http://hpaste.org/68086
09:03:58 <narens> ski: so that uses 58.8 GC time
09:04:07 * hackagebot webdriver 0.3.0.1 - a Haskell client for the Selenium WebDriver protocol  http://hackage.haskell.org/package/webdriver-0.3.0.1 (AdamCurtis)
09:04:12 <ski> narens : next time, annotate the original paste with updates (using the "Annotate" button)
09:04:32 <narens> ski: ah, thanks.. didn't know that
09:05:32 <ski> so, did this version type-check ?
09:05:55 <narens> ski: what do you mean? Yea, it compiles
09:06:29 <ski> i don't see which `Applicative' you're using
09:06:49 <narens> ski: oh.. in this one Maybe
09:07:21 <ski> oh, now i see
09:07:43 <ski> i'm still not clear on what you want to do
09:08:10 <ski> do you want to pass a state `c' around, also passing it to the `WholeFunc c a b' argument ?
09:08:25 <narens> ski: the wholeMap2 cannot accumulate a value as you build the list... but with applicative I can use an applicative to build up a value like traverse
09:08:46 <narens> ski: its just like monadic sequence
09:09:03 <ski> i would use `State', though
09:09:56 <ski>   newtype WholeFunc c a b = WholeFunc ([a] -> State c (WholeFunc c a b, Maybe [a], [b]))
09:10:24 <ski>   wholeMap :: WholeFunc c a b -> Maybe [a] -> State c [b]
09:11:09 <narens> ski: hang on.. let me try soemthing
09:16:33 <narens> ski: looks like state or a general monad is what will work.. because I tried to move the f from f[b] to f (WholeFunc f a b, Maybe [a], [b]) but that can't be done with Applicative.
09:17:24 <jfischoff> @pl \f x -> concat <$> mapM f x
09:17:25 <lambdabot> ((join <$>) .) . mapM
09:18:22 <ski>   (WholeFunc f a b, Maybe [a], f [b])  -- could work
09:18:41 <ski> @type \f x -> concat <$> mapM f x
09:18:41 <lambdabot> forall a a1 (f :: * -> *). (Monad f, Functor f) => (a1 -> f [a]) -> [a1] -> f [a]
09:20:31 <narens> ski: state works great... just as fast as wholeMap2
09:20:45 <narens> ski: thanks
09:20:50 <ski> nice
09:20:52 <ski> yw
09:21:48 <ski> @type (liftM concat . sequence) .: map
09:21:49 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> m [a]) -> [a1] -> m [a]
09:22:11 <pcavs> Is there a list that provides constant time lookup into know index?
09:22:15 <pcavs> known*
09:22:30 <narens> pcavs: array or vector
09:23:15 <quicksilver> or Seq or IntMap
09:23:15 <pcavs> narens: Seems like everything uses a List thought in the helpful Containers.Data.Map package
09:23:29 <quicksilver> given that constant time lookup is a lie anyway
09:23:57 <narens> quicksilver: lie?
09:24:59 <narens> :q
09:29:09 <smithw> Hi, I've written some code that works, but I don't quite get how. It's here: http://hpaste.org/68089 . What I don't understand is why the parMapM (line 104) is actually slower than mapM, and why I don't need a lift on line 67. Can someone help me with that?
09:29:53 <bxc> any dutchhug people know when is may meeting?
09:33:38 <parcs`> smithw: parallelism has an overhead, and when the thing you want to compute in parallel is not computationally expensive, it can be slower than computing it sequentially
09:34:04 <xraycat> I have a type: data Alphabet = Text String | Number Int | FPNumber Double and I want to be able to build the average of [Alphabet], if it only contains numbers, how would I go about it? instance Num Alphabet and implement (+) etc. or is there another/better way?
09:34:21 <hpaste> keseldude pasted “slow solution” at http://hpaste.org/68091
09:34:49 <smash> hello
09:35:18 <parcs`> smithw: you seem to be using parMapM in IO, which is pretty useless, because you're not actually computing anything. if you want to execute IO actions concurrently, use forkIO
09:35:38 <parcs`> smithw: and why do you think you need a lift on line 67
09:37:31 <smithw> parcs`: ahhh, I see. I thought I could use par on IO, that was my mistake then. I thought I needed a lift because, since compareFile is being called by a runReaderT, the "topmost" monad would be ReaderT, so to access the Writer monad whenRead requires I'd need a lift
09:38:20 <smash> i have a Text.JSON question if anyone can help: I've used Text.JSON.Generic to serielize a specific data structure do JSON, now I need to implement the function that from the JSON string builds the data structure again, anyone knows a good example to follow to build this fuction?
09:40:57 <kallisti> smash: that should already be part of the library.
09:41:09 <lamefun2> hello
09:41:43 <kallisti> smash: yeah just call decode on the string
09:42:04 <kallisti> (also I recommend aeson as a better library)
09:42:47 <lamefun2> As I understand, if I make a game in haskell: things, once created, are immutable. So, to move to the next frame, I should start the world from scratch and fill it with entities based on the previous state?
09:43:25 <kallisti> lamefun2: you're probably overthinking at such an early stage of development
09:43:38 <lamefun2> idk
09:43:40 <kallisti> if you're writing a game in Haskell you'll likely be talking to a low-level graphics API
09:43:54 <kallisti> which will be written in C or something else.
09:44:27 <kallisti> there is no need for you to manually think about "starting the world from scratch" on each frame.
09:44:43 <lamefun2> I'm talking about game logic
09:44:45 <smash> kallisti: from what i've seen decode returns me a JS object instance, not an instance of the Data type originally defined
09:44:47 * hayashi wonders what the best way would be of sending input from monad A to function B (like A>>=B or A<**>B) whilst returning A (if B succeeds) and discarding the result of B
09:45:09 <jfischoff> lamefun2:There are ways to use mutable in haskell if you need to for performance reasons
09:45:14 <kallisti> smash: look at its type decode :: JSON a => String -> Result a
09:45:19 <kallisti> it can convert to any JSON instance.
09:45:22 <hayashi> Currently I'm just doing A>>=B and forcing B to return A, that might indeed be the best/only way of doing it.
09:45:28 <kallisti> which, I'm assuming, includes your original data type.
09:45:31 <kallisti> since you serializes to JSON.
09:46:00 <kallisti> hayashi: are you familiar with <* ?
09:46:17 <kallisti> lamefun2: yes, and I'm saying there's no particular requirement for you to even think about that.
09:46:48 <smash> kallisti: hmm, looking at decode again
09:47:07 <hayashi> kallisti: Yeah, but in this case the thing whose result is to be discarded needs the thing it's discarded with as input.
09:47:27 <kallisti> ah yeah
09:47:29 <parcs`> smithw: the lift is already 'built in' the 'tell' function so to speak
09:47:31 <kallisti> I've sometimes wanted this mayself.
09:47:35 <hayashi> It probably is just easiest to have it pass through B, but that seems a little unintuitive
09:48:40 <kallisti> you just want do { a <- m; f =<< m; return a }
09:48:41 <kallisti> right?
09:48:50 <hayashi> Yep.
09:48:55 <smithw> parcs`: is it because I'm specifying a MonadWriter class requirement instead of enumerating the monad stack in the type declaration?
09:49:02 <hayashi> I suppose I could just write that as a custom combinator and use that
09:49:09 <parcs`> smithw: yes
09:49:14 <smash> kallisti: it seems i'm missing an: instance JSON MyData where
09:49:24 <kallisti> smash: how are you converting MyData to JSON then?
09:49:33 <lamefun2> kallisti: overthinking? I'm asking what's the common technique to advance the world one frame further in Haskell.
09:49:53 <smithw> parcs`: I see. Thank your very much for your time and help, I'll look up forkIO now :)
09:49:58 <smithw> *you
09:50:14 <kallisti> smash: oh you're using the Generic stuff, that's right.
09:50:25 <kallisti> yeah just use decodeJSON from Text.JSON.Generic
09:50:34 <kallisti> same thing but with a Data constraint instead of a JSON constraint.
09:51:00 <smash> kallisti: encode $ toJSON
09:51:02 <jfischoff> lamefun2: there is also #haskell-game
09:51:44 <kallisti> smash: look at the encodeJSON and decodeJSON functions in Text.JSON.Generic
09:53:07 <lamefun2> and how no requirement to think about it? how do I make a game where nothing moves?
09:53:29 <kallisti> lamefun2: you just create new copies.
09:53:43 <smash> kallisti: i think i got it, thank you very much
09:53:45 <lamefun2> ...
09:53:49 <kallisti> also functional reactive programming seems to fit with game logic nicely. http://www.haskell.org/haskellwiki/Game_Development
09:53:53 <lamefun2> that's what I thought I will need to do
09:54:25 <kallisti> right, but you don't have to "do" anything
09:54:38 <kallisti> it happens. that's just how Haskell works.
09:54:40 <shapr> kallisti: I'm accustomed to Python's walk function in ... os? os.path? So that's what I'd steal.
09:54:47 <shapr> kallisti: But I'd like to hear more about your design.
09:55:00 <kallisti> shapr: nah this approach would be way better because you can treat directories as trees of file names.
09:55:03 <lamefun2> I have previous state and build next state based on it, then discard previous state
09:55:06 <kallisti> and then do things like recursive copy, recursive delete, etc.
09:55:08 <kallisti> on top of that.
09:55:16 <lamefun2> or rather, writer rules of how next state depends of previous one
09:55:16 <shapr> Oh that sounds nifty.
09:55:24 <shapr> kallisti: Any code written yen?
09:55:24 <lamefun2> is it like that?
09:55:28 <kallisti> shapr: and then you get all of the Foldable and Traversable goodness
09:55:30 <kallisti> not yet no.
09:55:32 <kallisti> but soon
09:55:32 <shapr> I'd like to try it, I have a use for it right now :-)
09:56:40 <kallisti> shapr: well if you start a repo somewhere I'll help out when I can. I do plan on writing my own eventually as well. So whichever happens soonest, I guess.
09:57:08 <shapr> Sounds good... but don't expect anything from me before my last final on Wednesday.
09:57:31 <lamefun2> ok, i'll just try to do it
09:57:39 <kallisti> there's no pressing need on my end.
09:57:44 <edwardk> heya shapr
09:58:00 <shapr> howdy edwardk!
10:00:54 <lamefun2> and, about oop, there's no oop?
10:01:42 <kallisti> lamefun2: correct
10:02:06 <lamefun2> but, what if I, for example have a Player and Enemy
10:02:12 <lamefun2> both have location and can be rendered
10:02:26 <kallisti> there are number of approaches to problems like that
10:02:43 <kallisti> one is called typeclasses, which act as a way to overload functions on many different types. They're somewhat akin to interfaces in OOP.
10:03:16 <kallisti> another approach is to simply unify the representation of players and enemies into one type. They likely have more in common than they have in difference.
10:04:16 <kallisti> but "take OOP concepts and cram them into Haskell somehow" usually isn't the best way to go about it.
10:05:59 <kallisti> I actually recently did a sort of "pseudo-inheritance" with some recent code. I have Firefox profiles and Opera profiles, both with the same internal representation, but they can originate from different sources.
10:06:13 <kallisti> so I gave the unified type a type parameter, and then used phantom types to differentiate.
10:06:31 <kallisti> now you can't confuse a Firefox profile with an Opera profile, but you can also re-use all the code that they share in common.
10:07:44 <lamefun2> what if I have 3 characters and 24 types of enemies, all of which with different abilities?
10:08:16 <kallisti> then you give the generic structure for "actors" a representation for these arbitrary abilities.
10:08:36 <kallisti> it's unlikely even in an OO language that you would want to inherit 24 different subclasses for each enemy
10:08:40 <kallisti> or at least, I hope that's not what you would want to do.
10:09:22 * hackagebot abstract-par 0.3 - Type classes generalizing the functionality of the 'monad-par' library.  http://hackage.haskell.org/package/abstract-par-0.3 (RyanNewton)
10:09:53 <kallisti> also another approach, where you DO have a need to add new data onto existing data in a way similar to inheritance, is to embed the old data into a new structure.
10:10:08 <kallisti> something like the "has-a-" relationship in OO.
10:10:20 <kallisti> (aka aggregation)
10:12:17 <kallisti> Haskell has a lot of ways you can cumbersomely emulate inheritance.
10:12:41 <kallisti> if you continue expecting such things from Haskell, you'll probably come to the conclusion that Haskell is a pretty crappy OO language.
10:13:18 <hpaste> xraycat pasted “calculating with custom types” at http://hpaste.org/68092
10:14:19 <kallisti> xraycat: what's the need for Alphabet?
10:14:23 <kallisti> what is it used for?
10:17:33 <xraycat> kallisti: I wanted to distinguish text from numbers and I need to do different calculations whether my columns contain text or numbers, its part of: type Record = [Alphabet]
10:18:18 <xraycat> kallisti: in my original data I have rows like: usual,proper,complete,1,convenient
10:18:41 <kallisti> xraycat: I would split the Number Int | FPNumber Double  part into its own class
10:18:54 <kallisti> and then only use arithmetic operations on that portion
10:19:08 <xraycat> to avoid the partial definitions?
10:19:11 <kallisti> yes
10:19:20 <kallisti> so now you pattern match beforehand
10:19:35 <kallisti> and if you extract the  numeric portion, then you do some sort of calculation
10:19:41 <kallisti> but I don't know there may be a better way.
10:22:13 <kallisti> xraycat: it seems as though you're in part of your logic where being a Text constructor no longer applies
10:22:28 <kallisti> so it now it just sits around as a potential liability, causing runtime errors.
10:24:40 <xraycat> jup
10:26:34 <kallisti> xraycat: so you could define data Number = I Int | D Double
10:26:40 <kallisti> then define a Num instance for that
10:26:49 <smash> kallisti: ok, all working as intended.. thks for the help
10:26:55 <kallisti> then have:  data Alphabet = Text ByteString | Number Number
10:27:59 <vhd> $! will force evaluation of the whatever is after it? How does it work? I mean how deep will it force evaluation?
10:28:18 <ski> @src $!
10:28:18 <lambdabot> f $! x = x `seq` f x
10:28:33 <kallisti> vhd: it forces the top-most constructor to be evaluated
10:28:44 <xraycat> kallisti: thanks, I'll give it a try
10:28:47 <kallisti> the deepseq package offers "deep evaluation"
10:28:58 <kallisti> and has a $!! operator analogous to $!
10:29:09 <vhd> that answers my next question then
10:29:23 * hackagebot monad-par-extras 0.3 - Combinators and extra features for Par monads  http://hackage.haskell.org/package/monad-par-extras-0.3 (RyanNewton)
10:29:25 * hackagebot monad-par 0.3 - A library for parallel programming based on a monad  http://hackage.haskell.org/package/monad-par-0.3 (RyanNewton)
10:29:46 <kallisti> vhd: the type in question has to be an instance of NFData however
10:29:49 <kallisti> it doesn't work for arbitrary types.
10:29:57 <vhd> ah
10:30:03 <ski> vhd : what do you want to force ?
10:30:25 <vhd> I have a fairly large app and its slow, just trying to find ways to improve its performance.
10:31:03 <kallisti> profiling is a good way to determine where the actual performance issues lie.
10:31:19 <vhd> I know where the performance issue lies
10:31:30 <ski> forcing more won't always make things run faster / use less memory -- in some cases the opposite might result
10:31:57 <vhd> the app is a chess like game, seems like the most expensive task is generating the boards for the next set of moves.
10:32:01 <kallisti> also it lets you draw pretty graphs of memory usage. you can't beat that.
10:33:36 <vhd> ski everything I have read, seems to suggest that strictness is faster.
10:34:14 <vhd> assuming you always need the result, why would strictness be negative?
10:35:31 <ski> if the value would use a lot of memory when forced, and the consumer is incremental, it would be bad to force it all at one time
10:37:00 <ski> a very simple example is reading a file, counting the number of lines -- if you force the whole file `String' before passing it on, it would load the whole file into memory at the same time
10:40:04 <scooty-puff> is it possible to force the garbage collector to run?
10:40:07 <scooty-puff> or at least suggest it be run?
10:40:18 <ski> @hoogle performGC
10:40:19 <lambdabot> System.Mem performGC :: IO ()
10:40:22 <scooty-puff> k
10:40:53 <scooty-puff> yay, weak int map works..
10:41:11 <ski> you defined it ?
10:41:24 <scooty-puff> yeah, only insert and find just to test it
10:41:28 <scooty-puff> rips off most of intmap
10:41:32 <scooty-puff> but most ops in IO
10:41:38 <scooty-puff> just to deRefWeak, mkWeak
10:42:07 <hpaste> scooty-puff pasted “WeakIntMap (untested, incomplete)” at http://hpaste.org/68093
10:43:45 <scooty-puff> weird it doesn't warn about the bad UNPACK of Weak (Tip a)
10:44:23 * hackagebot meta-par 0.3 - Provides the monad-par interface, but based on modular scheduler "mix-ins".  http://hackage.haskell.org/package/meta-par-0.3 (RyanNewton)
10:47:20 <scooty-puff> from my previous paste: would expunge be better if it was WeakIntMap a -> IO (Maybe (WeakIntMap a)) - such that the data structure wasn't rebuilt if nothing expunged?
10:50:29 <quaestor_> /qui
10:51:51 <ski> scooty-puff : possibly
10:52:00 <ski> maybe you could use `MaybeT IO' ?
10:52:58 <scooty-puff> maybe a variant - on any Just (left or right of Bin), would need to rebuild
11:00:24 <xraycat> kallisti: I wouldn't be able to do the calculations with my type Record = [Alphabet] type, would I? I parse my data into [Record] and I would need to be able to calculate different things depending on the type of the column later on
11:01:01 <kallisti> xraycat: if data Alphabet = Text ByteString | Number Number
11:01:02 <kallisti> or whatever
11:01:05 <kallisti> then there's no problem with that.
11:01:08 <kallisti> you just pattern match
11:01:32 <kallisti> shapr: basic working version https://github.com/kallisti-dev/directory-trees
11:01:38 <xraycat> hmm
11:02:41 <shapr> yay!
11:04:26 <kallisti> shapr: some initial ideas I was thinking of are a) provide an options structure for things like following symbolic links, capturing only directories and ignoring files, and excluding directories with a specific name, etc b) add the current version of getDirectory as a convenient special case of this c) add some convenience functions for common usage (???) d) add a module for recursive copy/delete/move on directory trees
11:06:45 <kallisti> the main reasoning behind using a tree is it's basically the most general structure for this kind of operation. From there you can do basically whatever you want.
11:07:24 <kallisti> instead of, say, providing just a specific kind of walk over the tree.
11:07:28 <Franciman> trees are the killer data structure in haskell lol
11:09:12 <ski> kallisti : hard links might be fun
11:09:41 <kallisti> very.
11:10:41 <kallisti> infinite tree walks. :)
11:11:20 <ski> you'd want to insert indirections with identity into the tree^Wgraph
11:12:05 <kallisti> ski: this is beyond my undergrad CS math courses. :P
11:12:16 <kallisti> (though I'm switching to a dual major in CS and math)
11:14:41 <hiptobecubic> is there a way to tell if a Fractional actually has a valid Integral value?
11:14:47 <kallisti> shapr: it seems I have a "create cabal package" reflex.
11:14:52 <hiptobecubic> 4.0 for example, could be made 4 without loss of information
11:14:53 <kallisti> took like 3 minutes.
11:15:17 <kallisti> :t truncate
11:15:20 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
11:15:29 <kallisti> not for Fractional, but you could do that.
11:15:36 <hiptobecubic> if r == truncate r then yes else no?
11:15:38 <kallisti> check to see if the truncation is equal to the original
11:15:39 <kallisti> yes
11:15:46 <hiptobecubic> sounds good
11:15:52 <ski> > 4.0 == truncate 4.0
11:15:53 <lambdabot>   Ambiguous type variable `t' in the constraints:
11:15:53 <lambdabot>    `GHC.Real.Fractional t'
11:15:53 <lambdabot> ...
11:16:16 <ski> > (4.0 :: Double) == truncate (4.0 :: Double)
11:16:18 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
11:16:20 <lambdabot>    arising from a use ...
11:16:33 <ski> > 4.0 == (fromIntegral . truncate) 4.0
11:16:38 <lambdabot>   mueval-core: Time limit exceeded
11:16:42 <byorgey> > (4.0 :: Double) == fromIntegral (truncate (4.0 :: Double) :: Integer)
11:16:43 <lambdabot>   can't find file: L.hs
11:16:48 <byorgey> o.O
11:17:10 <monochrom> I think there is race condition in lambdabot
11:17:12 <ski> @botsmack
11:17:12 <lambdabot> :)
11:18:22 <kallisti> shapr: so yeah, feel free to submit pull requests whenever you want. Of course, you'll be mentioned as an author. (think of the fame and glory)
11:20:06 <kallisti> shapr: one thing that needs to be sorted out is the representation at each node
11:20:29 <kallisti> currently I'm doing it like this:  D, D/a, D/b, D/c, D/a/a, ... etc
11:20:43 <kallisti> so each child has its parent prepended to it.
11:21:43 <parcs`> how do you construct 'arr' from Category and Applicative?
11:21:55 <ski> kallisti : in case of symbolic (or hard) links, that might be a feature
11:22:16 <kallisti> that bascally ensures that each node is referring to a "real" (modulo race conditions and relative paths) path on the file system.
11:22:36 <kallisti> ski: seems more like a "feature" to me, for infinite walks.
11:22:44 <applicative> kallisti: there seems to be trouble on big directories
11:22:55 <ski> kallisti : hm ?
11:23:04 <kallisti> ski: those file paths are going to get pretty large.
11:23:09 <gwern> @quote
11:23:10 <lambdabot> puusorsa says: do not try this in a shell: :() { :&:; } ;:
11:23:12 <ski> hm, i suppose
11:23:20 <kallisti> but that's where the options come in.
11:23:22 <ski> you could construct them on demand, i assume
11:23:46 <kallisti> applicative: how so?
11:24:03 <ski> i.e., provide contextual traversal functions which construct the big paths, if wanted
11:24:55 <kallisti> I think the more common use cases will want the format of the current function, where the parent path is prepended to the front.
11:24:57 <applicative> i'm trying to read my HOME directory
11:25:04 <kallisti> hm, let me try
11:25:40 <kallisti> applicative: oh yeah, it hangs.
11:25:49 <ski> hm, is `read' or `get' more sensible for `IdVar a -> a' ?
11:25:54 <applicative> did you see this a year or so ago,  http://www.reddit.com/r/haskell/comments/cs54i/how_would_you_write_du_in_haskell/
11:26:20 <applicative> i remember trying to write a package 'directory-fold' after that :)
11:28:43 <parcs`> :t \f -> f <$> Control.Category.id
11:28:44 <lambdabot> forall a b (cat :: * -> * -> *). (Control.Category.Category cat, Functor (cat a)) => (a -> b) -> cat a b
11:35:20 <lamefun2> ok
11:35:40 <lamefun2> I made a class Actor, which has getX, getY and update
11:35:45 <lamefun2> how do I make list of actors?
11:36:10 <mauke> you don't
11:36:20 <mauke> classes aren't types
11:36:37 <lamefun2> ...
11:36:50 <lamefun2> how do I have polymorphism?
11:37:35 <cg_morton> you need to make a type that is an instance of the Actor type class, then put those in a list I guess
11:38:14 <geekosaur> lamefun2, I must ask, you said "I made a class". are you under the impression you are working with OO classes?
11:38:49 <cg_morton> type classes are more akin to 'interfaces' from the oo world
11:39:27 <lamefun2> http://pastebin.com/AbqaGX3B
11:39:29 <mauke> The paste AbqaGX3B has been copied to http://hpaste.org/68098
11:39:34 <geekosaur> except they're not really
11:39:40 <lamefun2> I still can make a list of interfaces in OO
11:40:00 <geekosaur> they have some semblances.  pretending they are OO will hurt you badly though.  they aren't related to OO.
11:40:06 <kallisti> hm, interesting.
11:40:31 <kallisti> for some reason I thought the evaluation of the tree would be lazy, but I see how that's not possible without unsafeInterleaveIO
11:41:40 <applicative> kallisti: here's a few peoples' attempts from there and elsewhere It's a mess, some of the originals are linked from the reddit page  https://github.com/michaelt/du-tempest
11:41:44 <lamefun2> What are classes for if I can't use them anywhere?
11:41:49 <cg_morton> lamefun2: If you're trying to say that everything in your world should be in a single list, you'll have a hard time of it
11:42:00 <monochrom> I am sorry to say that "I made a class Actor" is a bad start. http://www.haskell.org/haskellwiki/FAQ#I.27m_making_an_RPG._Should_I_define_a_type_for_each_kind_of_monster.2C_and_a_type_class_for_them.3F
11:42:01 <kallisti> lamefun2: what do you mean by "can't use them anywhere"?
11:42:39 <geekosaur> you can use them.  just not for what you think you want to do
11:42:47 <cg_morton> lamefun2: classes are for allowing type polymorphism in, for instance, function definitions
11:43:41 <kallisti> applicative: unsafeInterleaveIO is tempting. :)
11:43:51 <cg_morton> so you could have an   updateAll :: Actor a => [a] -> [a]    or whatever, but you can't have a list of [Actor] because it's not a thing
11:44:51 <applicative> kallisti, yeah. The alternatives are pretty fancy conceptually; I guess that was part of the charm.  Maybe enumerators or something would be good, this is before they really took off
11:45:06 <monochrom> classes are for operator overloading so you can have one single equality operator (==) that works for Char, Int, and user-defined types. but no one would ask for "a list that contains various items of various types that happen to support equality"
11:46:59 <ski> lamefun2 : you only have one instance of `Actor'
11:47:45 <kallisti> applicative: the main problem with unsafeInterleaveIO is race conditions as a result of keeping the Tree structure around
11:47:56 <applicative> kallisti or why not  the ffi  http://student.science.uva.nl/~rturk/GetDirContents.hsc
11:48:02 <monochrom> http://skipoleschris.blogspot.co.uk/2012/04/life-without-objects.html is also interesting in this context
11:48:11 <koala_man> if you store geographical data in a kd-tree or R-tree, what's the proper way of handling the poles and meridian?
11:49:26 <kallisti> applicative: alternatively I could use the unsafe tree structure internally and not export it.
11:49:41 <kallisti> but I'm not sure what I gain there.
11:49:51 <kallisti> some nice Traversable/Foldable instances? :P
11:52:57 <kallisti> applicative: so you'd have an abstract type representing a "directory" and then IO actions that act on that directory as it currently exists at that point in time.
11:53:03 <kallisti> eliminating issues like race conditions
11:53:10 <kallisti> (for the most part)
11:54:31 <applicative> kallisti I don't think anyone considered someone changing files during the process
11:54:40 <applicative> or is that what you mean
11:55:19 <kallisti> yes I mean file system changes
11:55:59 <ymasory> are monoids closed under mappend?
11:56:12 <kallisti> believe so.
11:56:22 <ymasory> thanks
11:57:59 <kallisti> ymasory: there's no real requirement that it be surjective or injective though.
11:58:10 <kallisti> but the type of mappend enforces closure.
11:58:17 <applicative> kallisti: Yes all this is a bit more primitive, but seems perfectly capable of extension. I mean like dolio's
11:58:39 <applicative> which is the one that made an impression on me and others
11:58:47 <kallisti> the approach I'm thinking of is using a custom structure.
11:58:56 <ymasory> kallisti: yeah that's what i noticed. you can't have a non-closed one due to the type system
11:58:56 <kallisti> restricted to IO for most of its operations
12:01:08 <lamefun2> cg_morton: but that's just for behaviours
12:01:17 <lamefun2> some subclasses also  contain additional data
12:08:05 <kallisti> lamefun2: I would suggest learning Haskell without trying to reverse engineer OO design onto it.
12:09:59 <ciaranm> but lamefun2 was taught OO programming all through his software engineering degree so he has to have classes and OO, because there is no other way!
12:10:00 <cg_morton> lamefun2: type classes don't contain data, nor can you subclass them
12:10:03 <d-snp> hey, is there a shorter way of saying this? isFizzBuzz i = isFizz i && isBuzz i
12:10:19 <ciaranm> i mean, how else do you get polymorphism and encapsulation and data hiding? OO invented those!
12:10:55 <kallisti> d-snp: yes, but it requires imports
12:11:06 <Clint> d-snp: liftA2 (&&) isFizz isBuzz ?
12:11:07 <kallisti> isFizzBuzz = liftM2 (&&) isFizz isBuzz
12:11:09 <d-snp> I want to first do isFizz on i, then do isBuzz on i, and then do &&
12:11:10 <kallisti> or that
12:11:19 <d-snp> oh hmm
12:11:38 <d-snp> that's not much prettier I guess
12:11:39 <danharaj> uh, type classes can have data
12:11:49 <ciaranm> d-snp: wait. how literally do you mean "then do"?
12:11:51 <kallisti> also they can be subclassed
12:11:59 <monochrom> you are welcome to force OO on haskell, but do not think that just because something is called "class" means that it means what you think
12:12:03 <danharaj> but not data in the same way or subclassing in the same way as oop.
12:12:11 <danharaj> Objects in oop are closures.
12:12:13 <danharaj> yawn.
12:12:18 <d-snp> ciaranm: well, I just want to do && on the result of both expressions
12:12:39 <kallisti> d-snp: the code examples we gave are equivalent to what you originally wrote
12:12:40 <ciaranm> d-snp: so if the first expression is true and the second expression does not terminate, what should happen?
12:12:44 <kallisti> so that should be what he meant.
12:13:48 <d-snp> ciaranm: lol.. the entire expression should not terminate
12:14:05 <d-snp> could it be any different?
12:14:12 <kallisti> no
12:14:14 <ciaranm> d-snp: and what about if the first is false and the second does not terminate?
12:14:40 <ciaranm> which is what i should have asked the first time if i was paying attention
12:14:42 <d-snp> if either one doesn't terminate the full expression should not terminate
12:14:46 <kallisti> > liftM2 (&&) (==2) (==undefined) 3
12:14:47 <lambdabot>   False
12:14:49 <kallisti> > liftM2 (&&) (==2) (==undefined) 2
12:14:51 <lambdabot>   *Exception: Prelude.undefined
12:14:53 <kallisti> miraculous
12:15:06 <d-snp> lol what
12:15:20 <kallisti> I'm not really sure what ciaranm is getting at
12:15:21 <d-snp> well ok, that's to be expected
12:15:31 <kallisti> he wrote out the expression, and wanted a "shorter" version
12:15:43 <monochrom> > False && undefined
12:15:44 <lambdabot>   False
12:16:08 <ciaranm> 20:10 < d-snp> I want to first do isFizz on i, then do isBuzz on i, and then do &&
12:16:15 <monochrom> > foldr1 (&&) [False, undefined]
12:16:16 <ciaranm> i'm wondering how literally he means that
12:16:16 <lambdabot>   False
12:16:20 <monochrom> > foldl1 (&&) [False, undefined]
12:16:21 <lambdabot>   False
12:16:23 <kallisti> not very.
12:16:39 <d-snp> there is a fun exercise on hackernews, about implementing the inverse of fizzbuzz in a functional language which I'm attempting
12:16:41 <monochrom> > foldr1 (&&) [False, undefined]
12:16:41 <kallisti> since isFizz i && isBuzz i   doesn't literally do that either.
12:16:42 <lambdabot>   False
12:16:45 <monochrom> sorry, typo
12:16:49 <monochrom> > foldr1 (&&) [False, undefined, undefined]
12:16:50 <lambdabot>   False
12:16:54 <monochrom> > foldl1 (&&) [False, undefined, undefined]
12:16:55 <lambdabot>   False
12:17:16 <ciaranm> fizzbuzz is boring. try the snail.
12:17:27 <mauke> what's the inverse of fizzbuzz?
12:17:45 <cg_morton> what is the type signature of isFizz and isBuzz?  Specifically, do they have side-effects?
12:17:48 <monochrom> ha, I see why
12:17:48 <d-snp> http://www.jasq.org/2/post/2012/05/inverse-fizzbuzz.html
12:17:53 <int-e> zzubzzib
12:18:04 <d-snp> .. no they don't have side effects :(
12:18:13 <kallisti> cg_morton: they're guaranteed to not have side effects
12:18:19 <kallisti> because && doesn't permit them.
12:18:36 <rwbarton> there are no side effects
12:18:38 <rwbarton> only effects
12:19:18 <monochrom> what "side" means is subjective
12:19:18 <kallisti> there is no
12:19:23 <kallisti> @hackage spoon
12:19:24 <lambdabot> http://hackage.haskell.org/package/spoon
12:19:31 <ciaranm> http://dpaste.com/742851/ <-- much more fun than fizzbuzz
12:19:54 <kallisti> the inverse of fizzbuzz is [1..]
12:20:19 * monochrom hacks http://captionsearch.com/image.php?id=244 into beginning with "what does it mean to be a side effect?" :)
12:20:56 <dino-> Hm, I kind of wish I had a manyTill1 in parsec.
12:21:26 <monochrom> many1Till?
12:21:29 <kallisti> manyTill1 p e = p *> manyTill p e
12:21:29 <lamefun2> so how do I do what I want to do?
12:21:54 <monochrom> use records for objects
12:21:55 <kallisti> lamefun2: you learn the basics of Haskell programming, and then use that knowledge to create your design.
12:22:15 <d-snp> so.. no inverse-fizzbuzz enthousiasts? :P
12:22:24 <dino-> Nothing but manyTill is in the API docs I have for Parsec 3.1.2
12:22:48 <dino-> Yeah, will write it
12:22:54 <monochrom> also I already posted a url you gladly ignored: http://www.haskell.org/haskellwiki/FAQ#I.27m_making_an_RPG._Should_I_define_a_type_for_each_kind_of_monster.2C_and_a_type_class_for_them.3F
12:24:09 <lamefun2> monochrom: I didn't
12:24:32 <monochrom> well then it already poses solutions and points to more solutions
12:27:35 <kallisti> shapr: yeah so I switched to using lazy IO
12:36:18 <stj> if I have a very expensive function computeColor and a constant like: color = computeColor, when asking for value color... is it guaranteed that it will be computed just once ?
12:38:09 <kallisti> stj: it won't be computed at all
12:38:15 <kallisti> until you bind it
12:38:20 <kallisti> or rather, unless you bind it.
12:38:20 <parcs`> stj: you mean color = computeColor blah?
12:38:38 <kallisti> oh, right.
12:39:10 <d-snp> does haskell have an infinite list of natural numbers somewhere?
12:39:18 <zzo38> How common are tricks like these in Haskell?   builtins = M.fromList $ zip (drop 3 . show <$> [minBound..maxBound :: BuiltinKeyword]) [0..];
12:39:23 <zzo38> d-snp:  [0..]
12:39:34 <d-snp> alright thanks
12:40:06 <rwbarton> assuming color = ... is a top-level definition then yes, assuming (1) you didn't turn off the Monomorphism Restriction or the binding is monomorphic anyways or doesn't involve a type class and (2) GHC doesn't try to get overly clever and inline color
12:40:53 <rwbarton> you can dissuade GHC from being clever by adding a NOINLINE pragma
12:40:57 <rwbarton> if it really matters to you
12:41:58 <zzo38> Do you know answer of my question?
12:43:00 <kallisti> any thoughts on this kind of approach to recursive directory traversal? https://github.com/kallisti-dev/directory-trees/blob/master/src/System/Directory/Tree.hs
12:43:37 <stj> hm, bad example... suppose I have primes = [x | x <- [1 .. 1000000], isPrime x] and I use it somewhere in code, in different, complex and independent functions... is it computed only once, or many times? will GC forget the primes so next times they will have to be computed again?
12:43:49 <rwbarton> same answer
12:44:11 <rwbarton> it is computed only once as long as the conditions (1) and (2) are met
12:44:40 <stj> I see, okay
12:44:53 <rwbarton> here condition (1) is not met unless you gave a monomorphic type signature for primes
12:45:04 <rwbarton> or unless isPrime has one
12:49:17 <zzo38> How to I make Haskell to use my Alternative and MonadPlus instances for IO rather than the ones that may exist in other libraries?
12:49:50 <Clint> what on earth are you trying to do?
12:50:29 <Franciman> what on earth LOL
12:50:42 <zzo38> Clint: Do you mean me? I am trying to use instances which are actually correct and forming a monoid, rather than the wrong ones.
12:51:06 <geekosaur> instances are global and those are probably in the base.  no way to override them that I know of
12:51:32 <twanvl> zzo38: You could use a newtype instead of the standard IO type
12:51:33 <zzo38> geekosaur: Actually as it turns out, they aren't in the base; but they might exist in other modules which are being imported.
12:52:53 <cg_morton> Is it out of the question to just specify  MonadPlus.print  or whatever?
12:53:38 <zzo38> cg_morton: I do not understand you.
12:54:41 <zzo38> What exactly does it mean to just specify  MonadPlus.print  or whatever?
12:55:49 <zzo38> The instances used in most modules are the ones which fail at the right identity law. My instance does not fail at the identity law.
12:55:51 <cg_morton> What I meant is, whereas 'print' would use the print IO function from standard Haskell, you could use a different implementation with the same name from your MonadPlus module.
12:56:58 <zzo38> cg_morton: Well, I could do so with a different IO type in a newtype surely; but that would require you to lift all IO actions imported from anywhere to work with the new one.
12:57:46 <cg_morton> ah, so you want to replace all IO references in any code anywhere with your code instead?
12:58:09 <rwbarton> where is this MonadPlus IO instance anyways
12:58:23 <zzo38> cg_morton: You seem to fail to understand me completely. I only want to override the instances for Alternative IO and MonadPlus IO
12:58:36 <zzo38> rwbarton: I think it is in transformers?
13:01:31 <parcs`> IO has a monadplus instance?
13:02:49 <ski> strangely, yes
13:03:21 <scooty-puff> does System.Mem.Weak.mkWeak consider key k, if unevaluated, as different from a whnf k?
13:03:45 <zzo38> parcs`: It does exist in some modules, and the instance given in those modules fails at the right identity law
13:05:32 <ski> @type Data.Traversable.traverse
13:05:33 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
13:05:43 <zzo38> Right identity law for MonadPlus means  flip mplus mzero = id
13:06:25 <tac-tics_> Are there any stable, maintained implementations of Haskell that compile to Javascript and have usable DOM FFIs?
13:06:52 <zzo38> One way to fix this and many other problems is to invent the new programming language Ibtlfmm but that doesn't exist therefore it cannot be used.
13:07:04 <twanvl> zzo38: what is mzero in IO? Is it throw <something>?
13:07:06 <ski>   traverse1 :: (Traversable1 t,Applicative i) => (forall a. f a -> i (g a)) -> (t f -> i (t g))  -- hmm
13:07:18 <rwbarton> have you considered simply making a libraries proposal to change the instances in question
13:07:37 <zzo38> twanvl: I think so. Or perhaps   mzero = fail [];   is the code I used anyways; the other ones are similar.
13:08:07 * ski isn't sure `MonadPlus IO' makes any sense at all
13:08:08 <zzo38> rwbarton: I don't know how to do so and I don't know how well that would help
13:09:06 <dino-> So weird! I can't get this to compile: quotedString = string "\"" >> manyTill anyChar (string "\"")
13:09:14 <dino-> But that expression works fine in ghci
13:10:04 <scooty-puff> does System.Mem.Weak.mkWeak work reliably on the standard boxed primitives?
13:10:31 <d-snp> gave up on fizzbuzz dino-? :P
13:10:41 <dino-> d-snp: Never started that today
13:10:55 <dino-> I did see one a long time ago gone with arrows, though.
13:11:02 <kallisti> is there a higher level library for dealing with symbolic links than System.Posix.Files?
13:11:06 <dino-> s/gone//
13:11:19 <dino-> er, done with arrows. Maybe I've been at the parsec too long today :(
13:11:20 <zzo38> ski: Here is mu instance Alternative IO:   empty = fail []; x <|> y = catch x $ \e -> modifyIOError (bool e <*> (userError [] /=));
13:11:29 <zzo38> s/mu/my/
13:11:36 <twanvl> dino-: what is the error message that you get?
13:11:53 <dino-> twanvl: No instance for (Text.Parsec.Prim.Stream s0 m0 Char) arising from a use of `string'
13:12:01 <zzo38> And this instance I think is correct; do you think so?
13:12:32 <dino-> In the twanvl In the manyTill line
13:12:36 <rwbarton> can you please rewrite this code like a human
13:12:44 <dino-> twanvl: In the manyTill line
13:13:17 <AndrewMarsh> It's because of the monomorphism restriction, you either have to give a type declaration or add the NoMonomorphismRestriction extension
13:13:38 <zzo38> rwbarton: ? Do you mean me, or someone else? Even then I do not know exactly?
13:14:07 <rwbarton> yes you
13:14:11 <rwbarton> never mind
13:14:27 <zzo38> ski: Here is mu instance Alternative IO:   empty = fail []; x <|> y = catch x $ \e -> modifyIOError (bool e <*> (userError [] /=)) y;
13:14:30 * hackagebot meta-par-accelerate 0.3 - Support for integrated Accelerate computations within Meta-par.  http://hackage.haskell.org/package/meta-par-accelerate-0.3 (RyanNewton)
13:14:31 <zzo38> OK, I fixed it now.
13:14:32 * hackagebot fields-json 0.2 - Abusing monadic syntax JSON objects generation.  http://hackage.haskell.org/package/fields-json-0.2 (MariuszRak)
13:14:35 <zzo38> Now is it better?
13:14:53 <dino-> AndrewMarsh: Thank you
13:15:09 <AndrewMarsh> You're welcome
13:16:11 <zzo38> How can I rewrite this code like a human; this is a computer code not a human, please.
13:16:44 <rwbarton> well for one thing, the empty String literal is written ""
13:17:14 <ski> @type let bool t e True = t; bool t e False = e in \e -> bool e <*> (userError [] /=)
13:17:15 <lambdabot> IOError -> IOError -> IOError
13:17:29 <twanvl> zzo38: normal people would use a lambda instead of the (->) functor
13:17:40 <rwbarton> and if rather than bool
13:17:48 <zzo38> rwbarton: Yes, but [] also works. If you do not like this, you can write the codes the way you want to write them, instead, and I will write the codes my way
13:17:49 <roha> is there a way to use a function which returns IO Bool in a guard?
13:17:53 <twanvl> or a named function
13:18:03 <rwbarton> zzo38: you can expect to be (more likely to be) ignored, then. it is your choice
13:18:22 <rwbarton> but writing [] for "" is just obfuscation
13:18:25 <ski> twanvl : zzo38 is unusual :)
13:18:42 <zzo38> rwbarton: Do you think I am crazy? To me I write the codes the way which is sensible to me.
13:18:46 <int-e> zzo38: you were asking about more human ways to write that code. "" is more readable than [], for strings.
13:18:49 <rwbarton> I'm pretty sure you are an alien.
13:18:52 <zzo38> And you please to write the codes the way you write sensible to you.
13:19:15 <int-e> ignore it is.
13:19:33 <twanvl> so, if I translate this correctly:  x <|> y = catch x $ \e1 -> modifyIOError (\e2 -> if e2 /= userError [] then e1 else e2) y
13:20:15 <zzo38> rwbarton: No actually I am human. (My Dungeons&Dragons character not human but that is not relevant here. Also, I put the computer on a wood desk, but that is not relevant here either.)
13:20:27 <AndrewMarsh> :)
13:20:34 <int-e> twanvl: it's probably comparing e1.
13:20:35 <zzo38> twanvl: Yes that is same thing. But I dislike the Haskell's "if" command
13:20:48 <ski> roha : no
13:20:58 <dino-> d-snp: FizzBuzz with arrows http://old.storytotell.org/blog/2007/04/08/haskell-arrows.html
13:21:24 <rwbarton> actually i think twanvl's translation is right
13:21:32 <rwbarton> a good demonstration of how the if code is more readable!
13:22:27 <twanvl> ski: with 'bool' I never know what the order of the arguments should be, is it  bool trueCase falseCase boolean? Or bool falseCase trueCase boolean? Or bool boolean trueCase falseCase?
13:22:48 <zzo38> twanvl: False and then true and then boolean, is the way I do so.
13:22:56 <ski> twanvl : i suspect zzo38 is using the first one (i would prefer the middle one)
13:23:02 <ski> ok
13:23:25 <ski> twanvl : the last is sometimes called  if'
13:23:40 <zzo38> ski: Actually I am using the second one, too. And I included this function and some others in the "prelude-generalize" package.
13:23:46 <ski> @pl \cond cons alt -> if cond then cons else alt
13:23:47 <lambdabot> if'
13:23:56 <ski> zzo38 : ok, nice :)
13:24:26 <twanvl> zzo38: the one you defined above was "bool t e True = t"
13:24:49 <zzo38> Well, I may have made a mistake. The first code I wrote was not even type checked correctly.
13:25:24 <twanvl> right, which IMO is a good reason to use an explicit if or guards
13:25:51 <ski> hm .. i want something like `class NaturalTransformation f g where type NatTransf f g :: *' -- is this sensible
13:25:54 <ski> ?
13:25:56 <zzo38> OK; you can use what you like, since Haskell does have if, and do-notation, and various other thing like that
13:26:30 * ski wonders whether there would come any associated operations with it
13:26:36 <zzo38> But, do you know how common it would be to use codes like this?   builtins = M.fromDistinctAscList $ zip (drop 3 . show <$> [minBound..maxBound :: BuiltinKeyword]) [0..];   (This is correct; it works.)
13:27:00 <ski> hm .. or maybe i don't want `f' and `g' as parameters, actually -- hm
13:27:34 <zzo38> The datatype BuiltinKeyword is defined like   data BuiltinKeyword = KW_convert | KW_enum | ... | KW_success deriving (Eq, Bounded, Enum, Show);
13:27:40 <rwbarton> zzo38: this is for your own benefit--although you are right that the current Alternative IO instance doesn't satisfy one of the identity laws, if you send an email to libraries@ suggesting the definition "empty = fail []; x <|> y = catch x $ \e -> modifyIOError (bool e <*> (userError [] /=)) y;" you are rather more likely to be ignored than if you make your code comprehensible
13:28:13 <zzo38> I don't have the email
13:28:16 <rwbarton> it is not just a matter of "I will write what I like, and you will write what you like"
13:28:49 <twanvl> zzo38: there's nothing wrong with that code,though  I would personally write 'map' instead of <$>
13:28:53 <zzo38> Actually that is the problem of Haskell, that they have to define Monad so that it doesn't have join as a class method and Functor as a superclass
13:29:17 <zzo38> twanvl: OK; I just wondering how common these kind of tricks with the derived Show instances would be used.
13:30:15 <twanvl> well, it is a bit of a hack, and definately needs a comment
13:30:52 <zzo38> twanvl: OK
13:30:58 <zzo38> I believe you
13:31:12 <zzo38> How common is it, though?
13:31:32 <scooty-puff> http://hackage.haskell.org/packages/archive/reactive/0.11.5/doc/html/src/FRP-Reactive-Internal-TVal.html ctrl-f deRefWeak - is this true?
13:31:46 <scooty-puff> if optimizations remove a boxing, will weak ref's not work correctly?
13:32:42 <twanvl> zzo38: in production code it's pretty rare, I immagine. But for personal projects I've use similar tricks
13:34:28 <scooty-puff> (i'm fine with unreliable finalizers, but not with (k :: Int), which is key'ed on from mkWeak, being unboxed as Int# for all uses, except just prior to the mkWeak call being boxed
13:34:29 <scooty-puff> )
13:38:08 <roconnor> is is possible to have a semi-ring homomorphism between Kleene algebras that doesn't preserve kleene closure?
13:41:24 <ski> hm, mapping graphs with node identities seems cumbersome ..
13:43:34 <roconnor> more specifically, if f is a semi-ring homomorphism and is f(x*) <= f(x)* (since f(x)* <= f(x*) should be easy)?
13:43:42 <roconnor> dare I ask in #math?
13:44:15 <dmwit> jfischoff: Are you on Windows? :-O
13:45:21 <rwbarton> roconnor: if the answer was no, then a Kleene algebra would be determined by its semiring structure, which seems like a fact that would be mentioned on the wikipedia page
13:45:25 <dmwit> roconnor: Don't we have something like this:
13:45:27 <rwbarton> so I guess the answer is yes :)
13:45:41 <dmwit> f(x*) = f(xx*) = f(x)f(x*)?
13:45:45 <int-e> roconnor: Hmm. I think it's possible: Consider the sets of  finite and infinite strings; there are two star operators: one that can only produce empty and infinite strings, and the standard one. (<= is the subset relation as usual, 1 = {epsilon}, 0 = {})
13:45:56 <monochrom> I suspect that #math doesn't know about Kleene anything
13:45:57 * Thomas|3 slaps mefisto with a large trout
13:46:16 <dmwit> Then the Kleene closure property ought to say that if f(x*) is a solution to that equation, then it is in fact f(x)*
13:46:37 <rwbarton> i'm reminded of how the modal operators in linear logic are not determined by the rest of the structure
13:47:01 <twanvl> is the Kleene closure unique?
13:47:03 <rwbarton> and i think int-e's example sounds like it is either right or at least in the right direction
13:47:06 <int-e> roconnor: err, not quite right, but the point is that the * operator produces a fixed point, not necessarily the least one.
13:47:18 <roconnor> int-e: hmm.
13:47:54 <dmwit> twanvl: ah
13:47:58 <dmwit> twanvl: good point
13:48:07 <roconnor> int-e: doesn't the axiom "ab <= b implies a*b <= b" mean it produces the least fixpoint?
13:48:38 <roconnor> well that plus "ba <= b implies "ba* <= b"
13:48:50 <int-e> hmm.
13:49:30 <int-e> yes. sorry.
13:49:35 <roconnor> twanvl: I think I'm conjecturing that the kleene closure is unique.
13:49:41 <roconnor> if it exists
13:50:00 <roconnor> ... and honestly I don't know of any dioid that isn't a kleene algebra.
13:50:06 * ski . o O ( `a^* =< b  <=>  a =< b /\ a * a^* =< b' ? )
13:50:13 <roconnor> though often the kleene operation is too trivial to mention.
13:50:20 <zzo38> I have some other question; I am making something called WizardCard. I wrote a parser. The idea is that card texts (with slight differences from the printed version) exported from TeXnicard, and the convert/ blocks can tell it how to convert the English texts to WizardCard codes. And in addition it has to support such thing as, some rules can be overridden, etc.
13:50:37 <ski> (hm, should be s/a =< b/1 =< b', probably ..)
13:51:08 <roconnor> ski: that iff doesn't hole because a* contains 1 and b might not.
13:51:16 <roconnor> *hold
13:51:40 <roconnor> `a^* =< b  <=>  1 =< b /\ a * a^* =< b' -- I think this one is true though.
13:51:46 <monochrom> haha nice, Hong Kong gets a haskell hackathon: http://www.haskell.org/haskellwiki/HkHac2012
13:51:52 <roconnor> in fact this is easy to prove.
13:51:57 <monochrom> although, they haven't found a venue yet!
13:52:07 <ski>   a^* =< b  <=>  1 =< b /\ a * b =< b  -- i wonder about this one
13:52:41 <djahandarie> @seen ddarius
13:52:41 <lambdabot> Unknown command, try @list
13:52:49 <ski> preflex: xseen ddarius
13:52:50 <preflex>  ddarius was last seen on freenode/#haskell 56 days, 18 hours, 45 minutes and 16 seconds ago, saying: BMeph: No.
13:52:57 <djahandarie> Thanks
13:52:59 <djahandarie> And hm :(
13:53:13 <zzo38> I would like to know if you have anything to say about this WizardCard ideas; perhaps you know somethings about these?
13:53:49 <roconnor> ski: 1 =< b /\ a * b =< b --> a^* =< b   is one of my theorems.
13:53:52 <wunki> anyone know how to pass a javascript variable to a templatetag?
13:53:53 <zzo38> For example, in Magic: the Gathering, some cards can specify while they are in effect, some rules will be overridden; and some will have other complicated effects which somehow should be programmable in there, etc
13:54:02 <zzo38> But it is not specific to Magic: the Gathering.
13:54:10 <wunki> oops, wrong channel, nm
13:54:10 <roconnor> ski: I'm not so sure about the other direction though.
13:54:46 <lamefun2> http://www.haskell.org/haskellwiki/FAQ#I.27m_making_an_RPG._Should_I_define_a_type_for_each_kind_of_monster.2C_and_a_type_class_for_them.3F - still
13:54:59 <rwbarton> you would like to say something like "if 1 + a + aa + ... + a^n <= b for all n, then a* <= b"
13:55:10 <lamefun2> am I supposed to cram ALL the variables that all my monster use in one Monster data structure?
13:55:13 <zzo38> lamefun2: I think the answer to that question depends much on the rules of the game
13:56:52 <zzo38> Also, do you want a different type or class for creature kind as creature instances? Do you want to implement PC/NPC unification? And so on.
13:56:56 <glguy> To use "threadscope" do you need to rebuild all the libraries you use with "eventlog"?
13:56:57 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
13:57:35 <roconnor> rwbarton: I would.
13:57:41 <ski> roconnor : let's say `b = a^* + c', then `a^* =< b', so by the reverse direction, `a * b =< b' meaning `a * (a^* + c) =< b' which is `a^+ + a*c =< a^* + c' which doesn't seem universally true
13:58:08 <lamefun2> zzo38: http://www.youtube.com/watch?v=rmsGEyonaQM
13:58:28 <zzo38> lamefun2: Do you have that video in Theora format?
13:58:28 <lamefun2> basically, if I use oop, i'd make everything that's not a piece of ground have one base class
13:58:43 <lamefun2> zzo38: no, but enable html5 on youtube
13:58:54 <roconnor> ski: indeed
13:59:12 <zzo38> (I also do not wish to open the web browser at this time.)
13:59:27 <lamefun2> I'm just interested if Haskell is appliable to this
13:59:28 <zzo38> (I also prefer, in general, text transcripts rather than video.)
13:59:39 <roconnor> rwbarton: actually, for my particular kleene algebra I have that a^* = 1 + a + a^2 + ... a^n for some n ... so I could cheat and use this.
14:00:34 <zzo38> lamefun2: Yes it is possile but you have to think of things such as what kind of rules you want to implement. (For some kind of rules that might want implemented, see my "extensible-data" package which might do some things that would help in some programs and computer game programs too.)
14:02:02 <lamefun2> have you seen the video?
14:02:05 <zzo38> No.
14:02:15 <zzo38> I prefer text rather than video
14:02:53 <lamefun2> uhm
14:02:58 <lamefun2> that's kinda impossible
14:02:59 <rwbarton> here is another task: determine whether there exists a kleene algebra in which a* is not the least upper bound of 1 + a + a^2 + ... + a^n as n varies (most likely because there is no such least upper bound)
14:03:10 <zzo38> What is kinda impossible?
14:03:21 <roconnor> rwbarton: I thought that was the definition of a kleene algebra.
14:03:47 <roconnor> rwbarton: clearly a* is an upper bound
14:03:49 <rwbarton> that's not what wikipedia says
14:03:53 <roconnor> :O
14:04:19 <rwbarton> but i might be missing a reason why it is always true
14:04:43 <rwbarton> ha.
14:04:59 <rwbarton> "At least ten inequivalent definitions of Kleene algebras or related structures have appeared in the literature"
14:05:12 <roconnor> great
14:05:23 <ski> \o/
14:06:37 <lamefun2> zzo38: to explain the rules
14:06:38 <rwbarton> from this: http://ecommons.library.cornell.edu/bitstream/1813/6971/1/90-1131.pdf
14:06:50 <rwbarton> section 3 has an example where the * structure is not given by 1 + a + a^2 + ...
14:08:26 <rwbarton> (or it claims to, i didn't read it closely)
14:08:28 <zzo38> lamefun2: O, OK. Now I understand you.
14:09:02 <lamefun2> bascially it's a Sonic the Hedgehog clone (crazy fast-paced 2d platformer where you can run on walls when you have high speed)
14:09:12 * ski ponders how to traverse/fold a graph without divulging the identities of the nodes
14:10:10 <twanvl> ski: what kind of graph? directed? (a)cyclic? labeled?
14:10:40 <rwbarton> he can't tell you that either
14:11:01 <ski> twanvl : directed, possibly cyclic or shared
14:11:26 <ski> twanvl : i'm not sure what you mean by "labelled", but i suspect the answer is "implicitly"
14:11:35 <zzo38> lamefun2: You could also look at what I have done with NodeClass in "dvi-processing"; specifically, each node is its own type but there is a type Node which contains anything having the NodeClass class, and Typeable is a superclass of NodeClass allowing you to access specific structures in each one, so you know exactly how one thing applies to another. You could also see the MESH:Hero engine which allows events and flags to make object interact with each other 
14:11:41 <roconnor> rwbarton: interesting
14:11:48 <twanvl> by labeled I mean whether you have node and/or edge labels
14:12:32 <twanvl> what does a fold mean for a cyclic graph?
14:12:40 <lamefun2> also
14:12:45 <tgeeky> ski: http://en.wikipedia.org/wiki/Expander_graph <-- that concept might help, if the graph qualifies. So far, it doesn't matter if it's undirected or not
14:13:07 <lamefun2> I want it to be possible to load entities as modules (so the engine is not limited with a finite type of entities and can load them as modules)
14:13:17 <lamefun2> Or I'd better use conventional OOP here?
14:13:23 <ski> twanvl : currently i'm pondering : `type FreshId :: * -> *; instance Monad FreshId; instance MonadFix FreshId; runFreshId :: FreshId a -> IO a; type IdVar :: * -> *; newIdVar :: a -> FreshId (IdVar a); readIdVar :: IdVar a -> a'
14:13:40 <ski> twanvl : er, and crucially `instance Eq (IdVar a)'
14:13:57 <tgeeky> ski: that gives you a graph?
14:14:05 <zzo38> lamefun2: It is possible to do that in Haskell. And, I have done things like that too.
14:14:21 <ski> tgeeky : using `mfix', yes
14:14:51 <tgeeky> ski: hm. and it doesn't tell you anything about the edges...
14:15:23 <zzo38> For example, I have used something like this:   data Node where { Node :: NodeClass x => x -> Node; }; class Typeable x => NodeClass x where { ... };
14:15:53 <twanvl> ski: how does this differ from IORef?
14:16:00 <captWheeto> How hard is it to write a simple language in Haskell? I'm bored alone and my CV is looking sparse
14:16:15 <zzo38> Will this work for what you are trying to do?
14:16:35 <zzo38> captWheeto: If you want to write a parser, it is not too difficult to do with Parsec
14:16:53 <captWheeto> I'll give it a whirl.
14:16:53 <ski> tgeeky : that's up to the application .. e.g. `type MyGraph = IdVar MyGraphCell; data MyGraphCell = Branch Condition MyGraph MyGraph | Return | Instr Instruction MyGraph' or something
14:16:59 <captWheeto> Cheers ;)
14:17:25 <ski> tgeeky : "how does this differ from `IORef'" -- `readIdVar :: IdVar a -> a'
14:17:28 <ski> er
14:17:32 <ski> twanvl ^
14:17:41 <ibid> captWheeto: it can be as simple as a classroom exercise.  or it can consume your next decade.  depends on your ambition :)
14:18:03 <monochrom> my http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements is an example of using parsec to parse a simple language
14:18:04 <captWheeto> It's not very high :P more fun
14:18:10 <twanvl> okay, so it's immutable
14:18:10 <captWheeto> More for fun*
14:18:35 <captWheeto> Wait wait wait
14:18:39 <captWheeto> What does <|> do?
14:18:52 <ski> tgeeky : an `IdVar' has a fixed value, and also has an identity (so you can know when you reach the same position in the graph) -- unlike `IORef', it can't be changed, and unlike `IVar'/`MVar' it can't be empty
14:18:53 <mauke> which <|>?
14:18:54 <tgeeky> @src (<|>)
14:18:54 <lambdabot> Source not found. Do you think like you type?
14:18:56 <ski> arg
14:18:58 <ski> twanvl ^
14:19:08 <zzo38> captWheeto: <|> is the monoid compositon of Alternative. In Parsec, <|> means that if the parser on the left fails, it will try the one on the right instead.
14:19:10 <captWheeto> In parsec, sorry I'm reading RWH section of it
14:19:14 <zzo38> That way you can have multiple things to parse.
14:19:14 <monochrom> "x <|> y" attempts x first. if that succeeds, that's all. if that doesn't succeed, attempt y.
14:19:21 <captWheeto> Aaaah!
14:19:24 <captWheeto> Thank you (:
14:19:29 <twanvl> ski: do you need heterogenous types?
14:19:38 <twanvl> or would a single graph have just one type of nodes
14:19:57 <ski> twanvl : i'm not sure what i *need* :)
14:20:07 <ski> twanvl : i'm just pondering this general problem
14:20:11 <twanvl> ok
14:20:25 <twanvl> with a single type, you can get rid of the IO, and just use a Map
14:20:26 <roconnor> rwbarton: thanks for you help.  For now I'll just stick with my proof that works for my particular Kleene algebra. ... since the theorem seem unlikely to be true in general.
14:20:31 <ski> twanvl : however, i'm realizing that to map over such a graph, i need `FreshId' (for allocating new nodes) -- and this makes me not happy
14:20:35 <zzo38> For example:    (char '(' *> (Just <$> many (oneOf ['A'..'Z'])) <* char ')') <|> (Nothing <$ char '*')    is a valid parser which parses () with letters in between, or an asterisk.
14:20:40 <int-e> roconnor: Ok, fixed points are uniquely determined. Let s and t both satisfy the properties of a^*. Then s <= s(1 + at) <= st <= t, with the last step following from at <= 1+at <= t. Likewise, t <= s.
14:21:04 <twanvl> you could made the MyGraphCell more transparent, then you would be able to traverse it: data MyGraphCell ref = Branch Condition ref ref | Return | Instr Instruction ref, instance Traversable MyGraphCell
14:21:07 <roconnor> int-e: :)
14:21:28 <int-e> roconnor: unless I messed it up again, it's close to midnight here :)
14:22:13 <zzo38> *> means to parser the thing on left followed by the thing on the right, using the result from the right. <* means to also do both parsers but using the result on the left. <$ means replace the result with a given value. <$> means to apply some function to the result.
14:22:33 <ski> twanvl : well, i was actually pondering `type GenMyGraph ref = ref (GenMyGraphCell ref); data GenMyGraph ref = Branch Condition (GenMyGraph ref) (GenMyGraph ref) | Return | Instr Instruction (GenMyGraph ref)' :)
14:23:03 <ski> twanvl : maybe using `IndirectComposite' would be nicer here, maybe
14:24:11 <tgeeky> dmwit: yes, everybody does love whitespace changes! :O
14:24:16 <ski> (twanvl : fyi, i already have `class Functor1 t => Traversable1 t where traverse1 :: Applicative i => (forall a. f a -> i (g a)) -> (t f -> i (t g))' :)
14:25:12 <kallisti> hm, there's no NFData instance for Tree
14:25:34 <kallisti> guess I can just fold
14:26:07 <roconnor> int-e: that seem correct to me
14:26:23 <roconnor> int-e: and I'm a bit surprised.
14:26:27 <twanvl> Ideally you would be able to write  data Graph ref = Branch Condition (ref Graph) | Etc,  but that doesn't kind check
14:26:41 <d-snp> what would a simple way be to select the shortest list in a list of lists?
14:26:47 <kallisti> foldr deepseq tree ?
14:26:54 <kallisti> will that force the entire tree?
14:26:59 <mauke> :t minBy (comparing length)
14:27:00 <lambdabot> Not in scope: `minBy'
14:27:05 <mauke> :t minimumBy (comparing length)
14:27:06 <lambdabot> forall a. [[a]] -> [a]
14:27:16 <kallisti> er seq rather
14:27:40 <int-e> roconnor: same here
14:27:58 <roconnor> int-e: though, it still doesn't quite establish that Kleene stars are preserved by semi-ring homomorphisms.
14:28:02 <d-snp> thanks mauke
14:28:26 <roconnor> ... does it?
14:29:22 <d-snp> hmm minimumBy is not in prelude? :(
14:29:38 <d-snp> weird that there's no generic version of min/minimum in prelude
14:30:00 <zzo38> d-snp: I have made up a "prelude-generalize" package which contains generalized versions of many things
14:30:10 <ski> twanvl : `Branch Condition (ref (Graph ref)) ...' works fine
14:30:33 <ski> (which is basically what i was suggesting, except i used a separate name)
14:32:11 <relation> is there any fuzzy set theory package for haskell?
14:32:11 <zzo38> d-snp: Data.Foldable has a generic minimum
14:34:30 <monochrom> there is a hybrid set package for haskell, i.e., an element's membership in a set can be of any integer multiplicity. yes, integer! x is in s for -5 "times".
14:34:48 <kallisti> monochrom: there's signed-multiset
14:34:54 <monochrom> yes, that's the one
14:34:59 <kallisti> but I think it's pretty new
14:34:59 <zzo38> monochrom: Can it be any monoid?
14:35:11 <tdammers> as in, there are three people on the bus, eight get off, now there's minus 5 people left?
14:35:12 <kallisti> and I recall some discussion on haskell-cafe about possibly better implementations than the one that currently exists.
14:35:16 <relation> monochrom: thanks
14:35:19 <zzo38> Or, any ring?
14:35:28 <monochrom> it's new. we don't have general monoidal multiplicity yet
14:35:30 <int-e> roconnor: Ok, so I'll revive my example: Let the first algebra be on {0,1} with operations + = max, * = min, * = identity. The homomorphism goes to the kleene algebra of sets of natural numbers (seen as strings over a singleton algebra} and infinity (the corresponding infinite stream). Then let the homomorphism send 0 to the empty set and 1 to N \cup {oo}.
14:35:55 <int-e> roconnor: and ... it still doesn't work.
14:36:06 <ski> monochrom : nice :)
14:36:15 <int-e> roconnor: I feel I'm missing something obvious here.
14:36:21 <scooty-puff> are there any docs for touch#?
14:37:47 * kallisti wonders if doesDirectoryExist count Windows folder shortcuts as directories.
14:37:49 <lamefun2> zzo38: existential types?
14:37:55 <kallisti> and if so, how I can check for their existence
14:37:57 <monochrom> "* = min, * = identity" is why conventional math notation has gone very wrong
14:38:04 <d-snp> alright I seem to have succeeded!
14:38:08 * ski needs yet another higher-order type class, *sigh*
14:38:08 <zzo38> lamefun2: What about existential types?
14:38:10 <statusfailed> woaaaaaaaaah, GHCI can debug!?!?!?
14:38:33 <int-e> monochrom: oops. the first one is concatenation, the second one the kleene star.
14:38:54 <monochrom> hehe, I know :)
14:39:01 <benmachine> hey guys, I wrote http://www.haskell.org/haskellwiki/Seq
14:39:06 <kallisti> shapr: with unsafeInterleaveIO I can happily traverse recursively from $HOME with no space leaks.
14:39:31 <rasfar> monochrom: there was a rather lengthy discussion of (some aspects of) signed-multiset on cafe http://permalink.gmane.org/gmane.comp.lang.haskell.cafe/97982 might help you decide
14:39:34 <ski> int-e : `(*) = min; (^*) = identity' ?
14:39:47 <kallisti> shapr: I currently have a lazy IO variant and a non-lazy IO variant, as well as the option to not follow symlinks (which is turned on by default)
14:39:59 <monochrom> yes I heard of signed-multiset from haskell-cafe precisely
14:40:05 <int-e> ski: yes.
14:40:39 <ski> twanvl : fwiw, i started thinking about this (for the `n'th time) because kallisti was talking about traversing directory trees
14:40:52 <d-snp> https://gist.github.com/2597922 <-- what do you think guys, will I get hired by Google in 2016?
14:41:09 <monochrom> why 2016 in particular?
14:41:39 <kallisti> ski: what's your opinion on a lazy IO approach?
14:41:46 <MrBusiness> if we divide syntactic eclectics into two sides, one side containing python and the other side containing perl, where in this dichotomy would haskell fall?
14:42:04 <kallisti> MrBusiness: probably towards perl.
14:42:07 <MrBusiness> mm
14:42:11 <benmachine> I also wrote this http://www.haskell.org/haskellwiki/User:Benmachine/Non-strict_semantics and would appreciate comments on how it compares with http://www.haskell.org/haskellwiki/Non-strict_semantics this
14:42:11 <kallisti> but... that's a highly subjective question. :P
14:42:17 <MrBusiness> yes
14:42:22 <d-snp> monochrom: it's a reaction to a blog where it is assumed that in 2016 all programmers use functional programming languages
14:42:36 <d-snp> http://www.jasq.org/2/post/2012/05/inverse-fizzbuzz.html?
14:42:37 <kallisti> I say perl because Haskell has a lot of user-defined operators that your average Python user would likely find "unreadable"
14:42:47 <kallisti> of course, readability is entirely dependent on ones knowledge.
14:42:57 <MrBusiness> yeah, I like the look of the Haskell, myself
14:43:03 <kallisti> but that's only in syntax. perl also has a lot of semantic irregularities
14:43:04 <MrBusiness> I am not averse to sigil construction and usage
14:43:05 <monochrom> 2016 is too soon for that. people live too long. and people write-protect their brains.
14:43:06 <kallisti> which you won't find in Haskell.
14:43:09 <MrBusiness> I know how to align them with the sun
14:43:10 <zzo38> Haskell also has indentation-sensitive codes like Python does, although in Haskell it is optional.
14:43:18 <ski> kallisti : i think it can be fine in many cases -- in some you might want more control of exactly when the I/O is done
14:43:22 <d-snp> monochrom: it's a wishful thinking thing :P
14:43:30 <rasfar> did someone say sigls?
14:43:34 <MrBusiness> oh yes
14:43:43 <kallisti> ski: in which case the enumerator approach would be useful?
14:43:50 <d-snp> if anyone would care to critique my haskell style I'd much appreciate it, I'm wondering wether it's public worthy yet :)
14:43:52 <ski> (kallisti : i'm of the opinion that the `unsafe' in `unsafeInterleaveIO' isn't really warranted)
14:44:00 <kallisti> yeah I'm started to see that.
14:44:04 <kallisti> *starting
14:44:07 <ski> kallisti : maybe (i don't know how `enumerator' or `iteratee' works)
14:44:10 <MrBusiness> I ain't never written any real Haskell, alas,
14:44:28 <MrBusiness> only shell scripts trying to pretend to be Haskell, and failing miserably for the effort.
14:44:35 * hackagebot hako 0.2.0 - A mako-like quasi-quoter template library  http://hackage.haskell.org/package/hako-0.2.0 (TobiasDammers)
14:44:45 <hpaste> benmachine pasted “checkEvaluated” at http://hpaste.org/68100
14:44:54 <benmachine> ski: you don't object to http://hpaste.org/68100 ? :P
14:44:55 <ski> (kallisti : to clarify, i think of `unsafeInterleaveIO' as akin to concurrency, thereby introducing nondeterminism into the application)
14:45:02 <monochrom> I side with kallisti too. perl has full-fledged lambda (sub), python castrates it.
14:45:23 <benmachine> ski: it's a bit more than concurrency, it makes evaluation observable, nothing else does that
14:45:28 <kallisti> I'm only comparing their syntax, for the record. a think a lot of perl's unreadability comes from its semantics.
14:45:54 <sharperguy> anyone mind advising me on a problem I'm having with parsec?
14:46:01 <ski> benmachine : depends on what you think is specified behaviour, and what just "happened" in this specific run
14:46:09 <zzo38> sharperguy: Simply ask your question.
14:46:17 <monochrom> well, python's castration of lambda is even at the syntactic level, too
14:46:30 <kallisti> hm, just got a stack overflow while traversing home
14:46:37 <tdammers> I always thought the syntactic level was why they castrated them in the first place
14:46:38 <ski> (however, maybe `unsafeInterleaveIO' should somehow be restricted to idempotent I/O -- i realize this would remove much of the usefulness)
14:46:46 <benmachine> ski: you view the IO Bool in that as just being sort of "return a Bool that may or may not mean anything, semantics-wise"
14:46:58 <benmachine> ski: that was meant to be a question, put one of these on the end: ?
14:47:15 <sharperguy> ok, bascially I have a parser which parses "<a href=blah.com>" strings into a record for the url. Now I want to create one that gets all the links from an html file as a list but ignoring any other html tags. But I'm not sure how to do it
14:47:48 <RenJuan> rwbarton: are you related to rsbarton?
14:49:37 <ski> benmachine : i don't really object more to that than using threads (more precisely, futures), no
14:49:43 <monochrom> use tagsoup for such simple html parsing. and it also means throwing out your diligently written parser for "<a href=blah>" because it is already done by tagsoup
14:50:06 <MrBusiness> o, good, I hate xml
14:50:39 <Elemir> @hoogle :: (a -> b -> c) -> (b -> a -> c)
14:50:40 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
14:50:40 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
14:50:40 <lambdabot> Data.IntMap fold :: (a -> b -> b) -> b -> IntMap a -> b
14:51:13 <ski> benmachine : "also, in that case, the I/O action is actually idempotent :)
14:51:23 <monochrom> tagsoup gives you a list of tags. you just screen that list for opening <a ...> tags, and then further screen for the href attribute. that's it.
14:51:24 <ski> s/"//
14:52:23 <sharperguy> monochrom, I'll look it up thanks
14:52:45 <ski> benmachine : "you view ... ?" -- well, more or less : i'd expect to get `True' only if at least one copy of it got forced
14:53:24 <kallisti> ski: what kind of futures are you talking about?
14:53:25 <ski> benmachine : here i'm expressly allowing an implementation to not cache the value
14:53:47 <monochrom> benmachine: in your article on non-strictness, you fall into the same fallacy that everyone else falls into, of talking about evaluation.
14:53:52 <benmachine> ski: okay, so you take the Bool as it really is, but you just don't mind that evaluation is observable
14:53:58 <lamefun2> ok
14:54:00 <benmachine> monochrom: I at least avoiding saying "lazy"
14:54:15 <scooty-puff> what needs to be done to use unboxed tuples?
14:54:16 <benmachine> monochrom: but they're related, and it's hard to talk about the relevance of one without mentioning the other
14:54:25 <scooty-puff> (where MagicHash, import GHC.Exts?)
14:54:30 <monochrom> however, I am cynical and tired of arguing my case. since everyone else is doing it already, why not, I don't care.
14:54:33 <Elemir> @pl ((\a b c d -> a b d c) (\a -> liftM . (flip a)))
14:54:33 <lambdabot> flip . (fmap .) . flip
14:54:39 <lamefun2> why heterogeneous lists are bad?
14:54:41 <ski> kallisti : something like `future :: IO a -> IO a', where looking at the result `a' will block until the thread spawned produces its result
14:54:45 <benmachine> monochrom: I care though!
14:54:49 <benmachine> monochrom: but I can't force it out of you :)
14:55:32 <zzo38> scooty-puff: MagicHash is a language extension; enable it in a LANGUAGE pragma
14:55:52 <scooty-puff> right
14:55:54 <kallisti> ski: ah, okay. yeah in that case I don't think evaluation is observable.
14:55:56 <scooty-puff> i enabled it by that means
14:56:02 <scooty-puff> and was getting odd syntax errors
14:56:11 <monochrom> outermost-first evaluation is close enough to lazy evaluation that it is not an improvement. it is still being operational (what steps to get an answer), when non-strictness is denotational (what answer to get)
14:56:19 <kallisti> ski: also check out http://hackage.haskell.org/package/unsafe-promises-0.0.1.1 if you haven't
14:56:31 <scooty-puff> but if i enabled with {-# OPTIONS_GHC -fglasgow-exts #-}, worked, though that method is deprecated
14:56:34 <benmachine> monochrom: okay, I see what you're saying
14:56:46 <benmachine> monochrom: I was conscious of that distinction and I tried not to fall into that trap, but I guess I did anyway
14:56:52 <benmachine> monochrom: that's useful, thank you
14:57:30 <kallisti> ski: in this case the only observable effect of evaluation is that it might take a really really long time, but that was the case before you used unsafeInterleaveIO.
14:57:38 <monochrom> however, like I said, I'm cynical. I know why everyone else must go operational. it is because they are only taught the operational story, nothing else. to learn a programming language, they are taught only how each program is executed.
14:58:02 <benmachine> kallisti: IO is allowed to arbitrarily take ages on everything because suddenly your CPU decided it had mroe important things to do :P
14:58:14 <kallisti> s/IO/evaluation/
14:58:15 <benmachine> or because your RAM accelerated to near the speed of light
14:58:21 <monochrom> so, if you avoid saying what steps to take, they become confused, they insist to know those steps.
14:58:42 <scooty-puff> when should touch<...> be used?
14:58:46 <oddraisent> :t lines <$> readFile
14:58:47 <lambdabot>     Couldn't match expected type `[Char]'
14:58:48 <lambdabot>            against inferred type `IO String'
14:58:48 <lambdabot>       Expected type: FilePath -> String
14:58:49 <scooty-puff> as in touchForeignPtr, touch#, etc.
14:58:52 <oddraisent> Why?
14:59:13 <ski> benmachine : basically, i'm thinking of `unsafeInterleaveIO foo' as a license to spawn a future thread for `foo' at any time
14:59:26 <int-e> roconnor: Ok, I got it. Consider the semiring N \cup { omega } with operations min and +, and  0^* = 0, a^* = omega otherwise. A related semiring is N \cup { omega, oo }, where oo > omega, oo^* = oo. Now let the semiring homomorphism from the first one to the second send natural numbers to themselves, but omega to oo.
14:59:30 <benmachine> oddraisent: readFile takes an argument
14:59:39 <oddraisent> :t lines <$> readFile ""
14:59:40 <lambdabot> IO [String]
14:59:45 <benmachine> ski: hmm, I see
14:59:58 <ski> (and as many times as it likes to, if we're to take the non-specification of laziness / by-need seriously)
15:00:14 <benmachine> oddraisent: if you don't give readFile an argument, you're using a different fmap, namely the one for functions
15:00:27 <whittle> monochrom: Sorry, I joined the conversation late. Are you talking about operational vs. denotational semantics?
15:00:33 <benmachine> then it becomes lines . readFile, and you try to match the output type of readfile (IO String) against the input of lines (String)
15:00:34 <monochrom> yes
15:01:07 <hpaste> stj pasted “my function” at http://hpaste.org/68101
15:01:09 <benmachine> monochrom: I'd be grateful if you were more specific about where I get it wrong
15:01:09 <stj> is there a better way to write this function, perhaps with less Nothings?
15:01:32 <Elemir> @pl (\f x y -> join $ (flip . (liftM .) . flip) f x y)
15:01:33 <lambdabot> ((join .) .) . flip . (fmap .) . flip
15:01:42 <benmachine> stj: what are x and y?
15:02:04 <benmachine> monochrom: although "all of it" is a legitimate answer
15:02:05 <stj> sorry, forgot this.... x = findInter a, y = findInter b
15:02:10 <stj> even plugging this in is a bit cumbersome
15:02:34 <kallisti> stj: there's <|> from Control.Applicative
15:02:39 <stj> sorry, should be findInter ray a and findInter ray b
15:02:42 <kallisti> as well as mplus, from Control.Monad. both do the same thing in this case.
15:02:47 <kallisti> > Just 2 <|> Just 3
15:02:48 <lambdabot>   Just 2
15:02:55 <stj> cool, I'll look it up
15:02:55 <kallisti> > Nothing <|> Just 3
15:02:56 <lambdabot>   Just 3
15:02:59 <kallisti> > Nothing <|> Nothing
15:03:00 <lambdabot>   Nothing
15:03:02 <benmachine> stj: also look up the "min" function
15:03:09 <stj> oh how wonderful
15:03:14 <benmachine> min x y | x < y = x | otherwise = y
15:03:15 <kallisti> oh right min works
15:03:21 <kallisti> I didn't consider that.
15:03:38 <kallisti> > min (Just 4) (Just 3)
15:03:39 <lambdabot>   Just 3
15:03:55 <kallisti> > min Nothing (Just 3)
15:03:56 <lambdabot>   Nothing
15:04:00 <kallisti> right, except for that.
15:04:00 <benmachine> min won't quite work because Nothing is defined to be smaller than everything else
15:04:02 <stj> oh my.... that is so awesome
15:04:11 <kallisti> so you'd want to use <|> and min
15:04:23 <benmachine> yeah, hmm
15:04:26 <benmachine> maybe liftA2 min
15:04:35 <benmachine> maybe liftA2 min a b <|> a <|> b
15:04:47 <dylukes_> *sigh*
15:04:50 <benmachine> the joys of applicative :)
15:05:31 <tommd> How do I add CC options from Setup.lhs.  I'm getting quickly lost after looking at ConfigFlags.
15:06:35 <monochrom> well, you should add that innermost-first is not the only way to get strictness, and outermost-first is not the only way to get non-strictness
15:06:53 <ski> @type Data.Traversable.mapM
15:06:54 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
15:06:58 <ski> @type Data.Traversable.mapA
15:06:59 <lambdabot> Not in scope: `Data.Traversable.mapA'
15:07:18 <kallisti> shapr: http://dl.dropbox.com/u/16495819/2012-05-04_18-03-40_1366x768.png  memory usage while traversing $HOME using the lazy IO approach. The last little spike ends with a stack overflow. I'm not sure what's causing that.
15:07:18 <Elemir> @pl \f ma b -> ma >>= flip f b
15:07:18 <lambdabot> flip ((.) . (>>=)) . flip
15:07:19 * ski wonders why `traverse' isn't named `mapA' (or that available as an alias)
15:07:25 <monochrom> the evaluation orders you ever mention should be "for example the computer may do this" rather than "must do this"
15:08:03 <benmachine> monochrom: you can't have an innermost-first non-strict strategy, right?
15:08:12 <benmachine> monochrom: I suppose you can have something that's neither inner nor outermost first
15:08:17 <benmachine> but that would be kind of... weird
15:08:29 <benmachine> well no, that would be speculative evaluation, I suppose
15:08:47 <monochrom> it is tempting to say "in the python case we know the order" but even then, python now receives various alternative compilers, some of which may optimize and re-order. no, we no longer know python orders.
15:09:17 <kallisti> no one knows anything about perl 5.
15:09:22 <benmachine> monochrom: do you mind if I copy your comments to the talk page because I'm not going to deal with them now :P
15:09:46 <monochrom> to evaluate "const x y" and get strictness, I can evaluate x first, then evaluate y, then throw it away, and go back to x
15:10:09 <monochrom> please go ahead and copy
15:10:52 <int-e> roconnor: and one last time, since I didn't accomodate for 0. Take {-oo} \cup N \cup {omega}, -oo as zero, 0 as one, max as addition, + as concatenation. For the second structure, extend with +oo as before. In the homomorphism, use the identity except for mapping omega to oo.
15:11:30 <monochrom> and yes, to obtain non-strictness, you can use speculative methods, evaluate more than you think you need, kill off some sub-evaluation threads later.
15:12:14 <monochrom> the next and lesser problem is bringing up "what is needed". every reader will misinterpret that some way
15:12:37 <ski> benmachine :: .. however, `unsafeInterleaveST' *is* unsafe (in the non-pure sense)
15:12:48 <monochrom> "if x/x == 10 then () else ()" do we "need" [sic] to evaluate x/x==10?
15:13:15 <benmachine> ski: I have to admit I didn't even know there was such a thing... isn't that pretty much what Control.Monad.ST.Lazy *is*?
15:13:30 <Cale> Yes, because  if _|_ then () else () = _|_
15:13:47 <monochrom> the Haskell Report simply decrees: if ⊥ then x else y = ⊥. end of story. no debate on the meaning of "need".
15:13:48 <Cale> ;)
15:14:00 <ski> benmachine : no
15:14:07 <ski> @hoogle unsafeInterleaveST
15:14:07 <lambdabot> Control.Monad.ST unsafeInterleaveST :: ST s a -> ST s a
15:14:07 <lambdabot> Control.Monad.ST.Lazy unsafeInterleaveST :: ST s a -> ST s a
15:14:16 <benmachine> ski: huh
15:16:35 <ski> benmachine : hm, it may be that `ST.Lazy' is implemented using `unsafeInterleaveST' (i'm not sure), but you may use it explicitly in `ST.Strict' as well
15:17:05 <benmachine> ski: in which case, why would ST.Lazy export it?
15:17:17 <benmachine> what would it even *do*
15:20:05 <ski> benmachine : i looked at the implementation, and as i suspected, it does *not* use `unsafeInterleaveST'
15:20:30 <benmachine> ski: okay, but surely they are basically the same idea
15:20:58 <ski> benmachine : with `ST.Strict' `runST (do writeSTRef undefined (); return ())' is bottom; while with `ST.Lazy' it is `()'
15:21:07 <lamefun2> I still don't really understand
15:21:28 <monochrom> I have a less trivial example of ST.Lazy
15:21:34 <lamefun2> does MonsterOps approach suppose that I cram every monster in my game into Monster structure?
15:21:38 <ski> i suspect it can make a difference with `mfix'
15:21:43 <benmachine> ski: ah, fair enough
15:21:49 <Igloo> ski: Are you sure it doesn't use it?
15:22:04 <Igloo> ski: Looks to me like it is defined with "unsafeInterleaveST = strictToLazyST . ST.unsafeInterleaveST . lazyToStrictST"
15:22:38 <benmachine> Igloo: I think we're talking about the implementation of ST as a whole
15:22:40 <benmachine> kind of
15:22:41 <ski> Igloo : yes, it uses it for the implementation of `unsafeInterleaveST' -- however, i was not talking about that one
15:22:50 <kallisti> any idea why there's no NFData instance for Data.Tree.Tree?
15:23:08 <Igloo> Oh, sorry, I misunderstood
15:23:29 <monochrom> my ST.Lazy example: http://hpaste.org/63925
15:25:42 <ski> monochrom : interesting
15:26:08 <monochrom> yeah, the exact semantics of ST.Lazy is a bit tricky
15:29:36 <monochrom> yes lamefun2, I would "cram" everything (well the data model anyway) into one Monster data structure, although it is not a horrible "cram". in practice, firstly there are not too many cases, secondly two different behaviours can be just the same record field that may point to one of two different functions
15:31:44 <ski> benmachine : you saw monochrom's example ?
15:31:56 <benmachine> ski: yeah, but I got distracted before actually running it :P
15:32:01 <monochrom> oh I forgot that you can run the lazy ST example off the web! http://www.vex.net/~trebla/haskell/testbed.cgi  thanks to chrisdone for the backend!
15:32:08 <lamefun2> aka
15:32:13 <lamefun2> Quake Entity O_O?
15:32:21 <monochrom> I don't know Quake.
15:32:29 <lamefun2> uhm
15:32:58 <lamefun2> it has one big entity C structure where everything is crammed, from powerups to players
15:33:08 * ski runs impure `unsafeInterleaveST's on monochrom's server
15:33:12 <monochrom> I'm sorry, if you ask like "is that like python XXX" or "is that like php YYY" I know nothing of those. it's why I'm in #haskell, not in #python
15:33:15 <applicative> kallisti: check out containers-0.5 it has an NFData instance
15:33:41 <monochrom> no, ski, the haskell code is run on chrisdone's server
15:34:00 <hpc> lamefun2: you would do something like this:
15:34:14 <benmachine> monochrom: hmm, it gets upset at me if I try to run a thing with fix
15:34:21 <hpc> data Unit = Unit {damage :: Int, speed :: Int, senseOfHumor :: Bool}
15:34:49 <hpc> monster d s = Unit {damage = d, speed = s, senseOfHumor = False}
15:34:52 <monochrom> it may or may not let you import Data.Function. I don't know which modules are allowed
15:35:07 <benmachine> oh right
15:35:10 <hpc> haskeller = Unit {damage = 0, speed = 0, senseOfHumor = True}
15:35:15 <benmachine> it could possibly give a better error message in that case :P
15:35:17 <hpc> voila! you have two "classes"
15:35:45 <hpc> to mooch off OOP terminology in a questionably-valid way
15:36:20 <ski> hpc : except no open recursion :D
15:36:47 <monochrom> to be fair, you need open recursion just for inheritance
15:37:03 <lamefun2> hpc: and something like this: https://github.com/Unvanquished/Unvanquished/blob/master/src/gamelogic/gpp/src/game/g_local.h#L79 ?
15:37:04 <ski> yeah, which was what i alluded to
15:38:07 <hpc> lamefun2: if you were naively translating, you can just turn the big-ass struct into a big-ass record
15:38:38 * hpc can't tell how to split it up without looking at the rest of the code
15:38:42 * ski ponders viewing open recursion as graph zipper modification
15:39:39 <monochrom> I'm sure there are good factorings (and they are valid in haskell, and nice, and all). but since I'm not paid for this, I'm not going to do it.
15:44:34 <monochrom> anyway, japanese edition of LYAH! http://www.amazon.co.jp/dp/4274068854
15:45:54 <monochrom> I learned ConstraintKinds recently.
15:46:55 * ski . o O ( <http://www.amazon.co.jp/%E5%85%A5%E9%96%80Haskell%E2%80%95%E3%81%AF%E3%81%98%E3%82%81%E3%81%A6%E5%AD%A6%E3%81%B6%E9%96%A2%E6%95%B0%E5%9E%8B%E8%A8%80%E8%AA%9E-%E5%90%91%E4%BA%95-%E6%B7%B3/dp/4839919623/ref=sr_1_2/375-0266840-9077220?ie=UTF8&s=books&qid=1223047009&sr=8-2> )
15:47:58 <monochrom> (import GHC.Exts(Constraint))  data Exists cls = forall a. (cls a) => E a  (the kind of cls is * -> Constraint, so that "cls a" is valid on the LHS of =>. it is inferred, you can also explicitly say data Exists (cls :: * -> Constraint) = ...)
15:48:12 <Jed_84> hi all
15:48:56 <Jed_84> newbie question. what's the easiest way to "mock up" a function in haskell, so i don't get compiler errors?
15:49:06 <c_wraith> foo = undefined
15:49:06 <Jed_84> something like "def foo: pass" in python
15:49:09 <ski> monochrom : aye ..
15:49:15 <benmachine> foo = foo also works
15:49:16 <monochrom> so now you can say "[E True, E 'x', E 5] :: Exists Show"
15:49:23 <monochrom> err, [Exists Show]
15:49:24 <benmachine> or foo = error "I haven't written this one yet!"
15:49:26 <t7> 2940 yen! whats that like 1000 euro....
15:49:34 <Jed_84> benmachine, I like that one :)
15:49:43 <hpc> monochrom: that's a much nicer hlist than HList
15:49:58 <ski> hpc : doesn't do the same thing
15:50:02 <hpc> i know
15:50:02 <Jed_84> benmachine, wouldn't foo = foo cause an infinite loop if it's evaluated?
15:50:20 <ski> Jed_84 : yes
15:50:22 <benmachine> Jed_84: yes
15:50:42 <benmachine> Jed_84: if you want a funciton that *works* when you evaluate it, you kind of have to just write the function :P
15:50:46 <Jed_84> benmachine, sky, will the haskell interpreter realize it's looping infinitely and kill the program? or it will just loop forever?
15:50:58 <benmachine> the interpreter won't notice, but if you compile the program it might
15:51:01 <monochrom> well, it's just existential type, but now you can have one existential type parameterized by the type class you want, rather than define another existential type for another type class
15:51:06 <hpc> Jed_84: sometimes it notices when compiled
15:51:06 <ski> Jed_84 : something like `foo = assert False', might give you line number, with the proper option
15:51:09 <hpc> but assume it doesn't
15:51:10 <Jed_84> benmachine, actually foo = foo is enoguh for my purposes. i'm just asking about what happens when you evaluate foo = foo out of curiosity
15:51:25 <hpc> > fix id
15:51:29 <c_wraith> > let x = x in x
15:51:29 <lambdabot>   mueval-core: Time limit exceeded
15:51:30 <zaltekk> Jed_84: it's easy to ry
15:51:30 <hpc> ^ is the same thing
15:51:32 <lambdabot>   mueval-core: Time limit exceeded
15:51:37 <Jed_84> zaltekk, true :)
15:52:49 <monochrom> although, because the kind "* -> Constraint" is hardcoded or inferred, you have to define a different type for a different kind, e.g., data ExistsHigher (cls :: (* -> *) -> Constraint) a = forall f. (cls f) => EH (f a)
15:53:49 <benmachine> monochrom: PolyKinds?
15:54:25 <monochrom> ah, I haven't looked into PolyKinds
15:55:55 <kallisti> @hoogle (<:>)
15:55:56 <lambdabot> No results found
15:57:52 <ozataman> is there an easy way to achieve fanout behavior in conduit, such that a source gets connected to multiple conduits each handed the same item from the source?
16:01:11 <benmachine> monochrom: it might not actually help you, but it's fun nonetheless
16:01:34 <monochrom> I think it helps or doesn't help depending on what I exactly do, but yes it's fun
16:04:23 <monochrom> DataKinds is the evil one :)  (evil = fun)
16:05:11 <ski> monochrom : i'm interested in polymorphic type classes here ..
16:05:48 <hpc> turn on all three and you have a strange almost-agda language
16:06:08 <benmachine> nah, we're a fair bit from agda yet
16:06:09 <monochrom> pretty sure that's the intention :)
16:06:14 <benmachine> but we're on the way
16:06:56 <monochrom> I heard that GHC HEAD is even closer. anyway you have to turn on all 3 plus GADTs
16:07:31 <ski> monochrom : for your example ?
16:07:41 <monochrom> for getting close to agda
16:07:45 <ski> ok
16:08:04 <hpc> ghc is looking for libgmp.so.3
16:08:11 <hpc> should i symlink it to /usr/lib/i386-linux-gnu/libgmp.so?
16:14:44 * hackagebot postgresql-simple 0.1 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.1 (LeonSmith)
16:17:59 <geekosaur> hpc, libgmp.so will be the wrong version.  libgmp3c2 is the package you need if this is recent ubuntu
16:18:06 <geekosaur> (or debian unstable/testing)
16:24:19 <cads> for a float function f, will signum $ f a !=  signum $ f b be faster than (f a) * (f b) < 0?
16:25:01 <cads> actually, I should profile this :D
16:25:02 <cads> sorry for the trivial question
16:25:05 <hpc> geekosaur: oh
16:25:06 <benmachine> cads: first, /= not !=, second, I'd say benchmark it
16:25:14 <parcs`> is there something like a ForeignPtr but for not necessarily pointers
16:25:15 <hpc> well it configured an installed right anyway
16:25:17 <benmachine> criterion is not too hard to use
16:25:45 <kallisti> @hoogle choose
16:25:46 <lambdabot> Test.QuickCheck.Gen choose :: Random a => (a, a) -> Gen a
16:25:46 <lambdabot> Test.QuickCheck choose :: Random a => (a, a) -> Gen a
16:26:03 <kallisti> what would be a good name for if' with the Bool argument at the end
16:26:06 <hpc> and bignums work
16:26:09 <c_wraith> parcs`: for running some sort of finalizer when something goes out of scope? there's Weak
16:26:10 <hpc> kallisti: (??)
16:26:10 <kallisti> f :: a -> a -> Bool -> a
16:26:23 <kallisti> that works
16:26:25 <kallisti> @hoogle (??)
16:26:26 <lambdabot> keyword ??
16:26:29 <hpc> o.O
16:26:30 <c_wraith> parcs`: well, when it's collected anyway. may or may not be near when it goes out of scope
16:26:33 <kallisti> keyword?
16:26:41 <kallisti> oh right kinds
16:26:41 <hpc> oh right, it's a kind
16:26:43 <ski> kallisti : `bool'
16:26:43 <kallisti> but it doesn't matter
16:26:49 <kallisti> > let (??) = (+) in 2 ?? 2
16:26:50 <lambdabot>   4
16:26:53 <ski> @type maybe
16:26:54 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:26:56 <ski> @type either
16:26:57 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
16:27:14 <parcs`> @hoogle Weak
16:27:14 <lambdabot> System.Mem.Weak module System.Mem.Weak
16:27:15 <lambdabot> System.Mem.Weak data Weak v
16:27:15 <lambdabot> System.Mem.Weak deRefWeak :: Weak v -> IO (Maybe v)
16:27:21 <kallisti> bool might be good
16:27:44 <cads> thanks ben, I'll check criterion out
16:28:19 <kallisti> quick give ?? a precedence
16:28:47 <kallisti> I wold think something like 0 or 1 is good
16:29:07 <hpc> 1
16:29:11 <hpc> so it is higher than ($)
16:29:23 <hpc> or leave it at default
16:29:38 <kallisti> default is way too high I think.
16:29:43 <kallisti> 1 sounds good
16:30:12 <byorgey> default = 9
16:30:58 <kallisti> yes
16:32:08 <hpc> gold doesn't have the --hash-size option
16:32:21 <hpc> and some cabal stuff sets that linker flag
16:32:30 * kallisti is making the coveted "conditional operators package"
16:34:27 <kallisti> > liftA2 (||) (Just True) (Just False)
16:34:29 <lambdabot>   Just True
16:34:37 * kallisti sanity check.
16:34:52 <ski> kallisti : including `(a -> Bool) -> (a -> b) -> (a -> b) -> (a -> b)' ?
16:35:10 <ski> > liftA2 (||) (Just True) Nothing
16:35:11 <lambdabot>   Nothing
16:35:32 <kallisti> ski: oh. sure. What should I call that?
16:35:58 <kallisti> ifApp? :)
16:36:19 <kallisti> right now I have if', bool, (??), cond, and maybeCond
16:36:36 <ski> kallisti : it's often called `cond' ;)
16:36:36 <kallisti> and I'm also adding lifted Monad/Applicative operators for &&, ||, if', and friends.
16:36:54 <hpc> @djinn (a -> Bool) -> (a -> b) -> (a -> b) -> (a -> b)
16:36:54 <lambdabot> f a b c d =
16:36:54 <lambdabot>     case a d of
16:36:54 <lambdabot>     False -> b d
16:36:54 <lambdabot>     True -> c d
16:37:03 <ski> (the `(a -> Bool) -> (a -> b) -> (a -> b) -> (a -> b)', i mean)
16:37:16 <hpc> @hoogle f Bool -> f b -> f b -> f b
16:37:17 <lambdabot> Control.Exception.Base bracket_ :: IO a -> IO b -> IO c -> IO c
16:37:17 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
16:37:17 <lambdabot> Control.OldException bracket_ :: IO a -> IO b -> IO c -> IO c
16:37:22 <kallisti> ski: well I think cond is a better name for the function that emulates Lisp's cond.
16:37:31 <hpc> :t liftA2 if'
16:37:32 <lambdabot> Not in scope: `if''
16:37:44 <hpc> @let if' a b c = if a then b else c
16:37:45 <lambdabot>  Defined.
16:37:46 <hpc> :t liftA2 if'
16:37:47 <lambdabot> forall b (f :: * -> *). (Applicative f) => f Bool -> f b -> f (b -> b)
16:37:54 <hpc> hmm
16:38:01 <hpc> :t liftA3 if'
16:38:02 <lambdabot> forall b (f :: * -> *). (Applicative f) => f Bool -> f b -> f b -> f b
16:38:17 <hpc> yeeesssssss
16:38:21 <t7> hpc, wtf that type has simpler solutions
16:38:22 * hpc would like that in its general form
16:38:23 <ski> hpc : there were suggested here `eitherA :: ApplicativeChoice i => i (a -> c) -> i (b -> c) -> i (Either a b) -> i c'
16:38:27 <t7> why does it choose if?
16:39:05 <hpc> ski: that looks odd, to me
16:39:05 <ski> hpc :  liftA3 if'  has the unfortunate behaviour of executing both the branches
16:39:16 <ski> @type liftA3 either
16:39:17 <lambdabot> forall a c b (f :: * -> *). (Applicative f) => f (a -> c) -> f (b -> c) -> f (Either a b) -> f c
16:39:37 <ski> `eitherA' would in general not be `liftA3 either'
16:40:42 <ski> kallisti> :t cond
16:41:15 <hpc> ski: oh, yes
16:41:17 <hpc> :(
16:42:22 <kallisti> :t cond
16:42:23 <lambdabot> Not in scope: `cond'
16:42:34 <kallisti> >_>
16:43:06 <kallisti> ski: oh, hmmm
16:43:16 <kallisti> so for a lifted if' I would want to use liftM yeah?
16:44:40 <c_wraith> :t if'
16:44:41 <lambdabot> forall t. Bool -> t -> t -> t
16:44:51 <kallisti> ski: er... no liftM would have the same problem I believe.
16:45:05 <kallisti> but it can be written without liftM
16:45:06 <t7> :t liftM
16:45:07 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
16:45:12 <kallisti> *liftM2
16:45:19 <cheezey> who owns lambdabot ?
16:45:29 <t7> cale?
16:45:36 <ski> @type \iac ibc -> liftA2 either iac ibc
16:45:37 <lambdabot> forall a c b (f :: * -> *). (Applicative f) => f (a -> c) -> f (b -> c) -> f (Either a b -> c)
16:45:43 <ski> that one is trivial, no problem
16:45:44 <c_wraith> cale runs the instance that lives in here, anyway
16:45:48 <cheezey> oh
16:45:52 <cheezey> you can have multiple instances>?
16:45:57 <kallisti> ski: yeah I was overthinking
16:45:58 <ski> @type \iac ibc iab -> fmap (\ab -> fmap ($ ab) (liftA2 either iac ibc)) iab
16:45:59 <lambdabot> forall a c b (f :: * -> *) (f1 :: * -> *). (Applicative f, Functor f1) => f (a -> c) -> f (b -> c) -> f1 (Either a b) -> f1 (f c)
16:46:03 <ski> has the wrong type
16:46:09 <ski> @type \iac ibc iab -> join (fmap (\ab -> fmap ($ ab) (liftA2 either iac ibc)) iab)
16:46:10 <lambdabot> forall a c b (m :: * -> *). (Applicative m, Monad m) => m (a -> c) -> m (b -> c) -> m (Either a b) -> m c
16:46:13 <c_wraith> cheezey: lambdabot is on hackage. anyone can run a copy
16:46:16 <ski> is fine, except monadic
16:46:32 <ski> @type \iac ibc iab -> iab >>= \ab -> fmap ($ ab) (liftA2 either iac ibc)
16:46:33 <lambdabot> forall (m :: * -> *) a c b. (Applicative m, Monad m) => m (a -> c) -> m (b -> c) -> m (Either a b) -> m c
16:46:36 <ski> also monadic
16:47:29 <t7> has anyone ever seen/head of something like @hoogle where you enter a type and it finds a function (or function composition) that has the same type?
16:47:38 <ski> @type \iac ibc iab -> iab >>= liftA3 either iac ibc . pure
16:47:38 <lambdabot> forall (m :: * -> *) a c b. (Applicative m, Monad m) => m (a -> c) -> m (b -> c) -> m (Either a b) -> m c
16:47:43 <c_wraith> @hoogle a -> a
16:47:43 <lambdabot> Prelude id :: a -> a
16:47:44 <lambdabot> Data.Function id :: a -> a
16:47:44 <lambdabot> GHC.Exts breakpoint :: a -> a
16:47:44 <ski> another way of writing the same thing
16:48:12 <c_wraith> t7: hoogle handles search by type just fine. Searching by composition of type seems crazy
16:48:12 <ski> kallisti : hm ?
16:48:22 <kallisti> ski: neverind. :P
16:48:27 <kallisti> liftM3 if'  also evaluates both actions
16:48:36 <ski> kallisti : i think in general, we need a new class `ApplicativeChoice' with member `eitherA' as specified above
16:48:42 <geekosaur> I'm suspecting t7 means something like @djinn?
16:48:44 <ski> kallisti : yes, that's the problem with it
16:48:44 <t7> so like (a -> c) -> (a, b) -> c
16:49:05 <hpc> @hoogle (a -> b) -> [a] -> [b]
16:49:06 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
16:49:07 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
16:49:07 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
16:49:09 <geekosaur> @help free
16:49:09 <lambdabot> free <ident>. Generate theorems for free
16:49:09 <t7> would return ($) . fst   or something
16:49:16 <kallisti> for monad, instead you'd want bool a b =<< p
16:49:18 <hpc> @djinn (a -> b) -> Maybe a -> Maybe b
16:49:18 <lambdabot> f a b =
16:49:19 <lambdabot>     case b of
16:49:19 <lambdabot>     Nothing -> Nothing
16:49:19 <lambdabot>     Just c -> Just (a c)
16:49:21 <geekosaur> @help djinn
16:49:21 <lambdabot> djinn <type>.
16:49:22 <lambdabot> Generates Haskell code from a type.
16:49:22 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
16:49:26 <ski> kallisti : the above examples of what we don't want was supposed to explain what it should be `... -> i (Either a b) -> i c' rather than `... -> i (Either a b -> c)'
16:49:44 <t7> like adding a path finding algorithm to hoogle
16:50:06 <kallisti> ski: I wasn't really paying attention to any of that. :P
16:50:10 <applicative> > let ifM :: Monad m => m Bool -> m a -> m a -> m a; ifM mb ma ma' = do {bool <- mb; if bool then ma else ma'} in ifM (Just True) (Just 1) undefined
16:50:11 <lambdabot>   Just 1
16:50:25 <ski> kallisti : so, e.g. for those types where it makes sense, one could imeplement `eitherA' without it always executing both branches (e.g. `ZipList', and `Stream' i think)
16:50:28 <t7> @djinn (a -> c) -> (a, b) -> c
16:50:28 <lambdabot> f a (b, _) = a b
16:51:18 <ski> kallisti : and then one could use `eitherA' whenever one wants to have this weak choice
16:52:31 <hpc> @undo do {bool <- mb; if bool then ma else ma'}
16:52:32 <lambdabot> mb >>= \ bool -> if bool then ma else ma'
16:52:43 <hpc> @pl mb >>= \ bool -> if bool then ma else ma'
16:52:43 <lambdabot> flip (flip if' ma) ma' =<< mb
16:52:47 <hpc> :(
16:52:51 <hpc> can't be ap'd
16:52:59 <hpc> (probably)
16:53:39 <ski> kallisti : so then e.g. `takeWhileA' could use `eitherA' instead of requiring `Monad' -- (to be able to finish early, e.g. with an infinite input list)
16:54:06 <ski> and it's easy to define `ifA' in terms of `eitherA'
16:54:22 <kallisti> hmm.. liftM2 (||)  isn't short-circuiting with respect to the monad..
16:54:28 <ski> yes it is
16:54:37 <ski> > liftM2 (||) (Just True) Nothing
16:54:38 <lambdabot>   Nothing
16:55:00 <ski> that would be `Just True' if it was short-circuiting
16:55:33 <kallisti> hm
16:56:30 <kallisti> so, did you mean "yes it isn't"?
16:56:50 <ski> > let ifM :: Monad m => m Bool -> m a -> m a -> m a; ifM mb ma0 ma1 = do {bool <- mb; if bool then ma0 else ma1}; orM mb0 mb1 = ifM mb0 (return True) mb1 in orM (Just True) Nothing
16:56:50 <lambdabot>   Just True
16:57:01 <quintessence> @pl \m a -> m >>= ($ a)
16:57:01 <lambdabot> (. flip id) . (>>=)
16:57:02 <kallisti> right
16:57:13 <ski> kallisti : er, sorry, i misead you -- yes
16:57:36 <kallisti> but you can't get the short-circuiting behavior without eitherA, when using Applicative.
16:57:51 <ski> right, with just `Applicative', it's impossible
16:58:12 <ski> hence the apparent need for a subclass `ApplicativeChoice'
16:59:20 <ski> (but one could ask whether there's any instances of `ApplicativeChoice' which aren't instances of `Monad')
17:00:04 <hpc> the answer being "probably"
17:00:15 <kallisti> ski: also with the bool combinator mentioned earlier you could write orM a b = a >>= bool True b
17:00:16 <hpc> ZipList might be an instance
17:00:18 <ski> for any value of a type `a' which can be encoded (internally, in the language) in terms of bits, i think one can probably implement `forall b. m a -> (a -> m b) -> m b' in terms of `eitherA'
17:00:24 <kallisti> (which is how I'm writing it)
17:00:47 <kallisti> er wait
17:00:49 <kallisti> (return True)
17:01:43 <ski> kallisti : well, `bool b (return True)', if you're having the `False'-branch argument before the `True'-branch one
17:01:58 <ski> (which would be consistent with
17:02:00 <ski> @src Bool
17:02:00 <lambdabot> data Bool = False | True deriving (Eq, Ord)
17:02:01 <ski> )
17:02:03 <kallisti> oh...
17:02:10 <kallisti> hm
17:02:27 <kallisti> that goes against my initial intuition.
17:02:35 <kallisti> but it would be consistent with that, maybe, either, etc.
17:02:59 <ski> for `??' and `cond' the other order is probably more reasonable
17:04:11 <kallisti> ski: bool is the catamorphism for Bool, right?
17:04:18 <ski> yep
17:04:42 <ski> (and the `case'-morphism as well, since it's not recursive)
17:05:45 <ski> @hoogle r -> (a -> [a] -> r) -> ([a] -> r)
17:05:45 <lambdabot> No results found
17:05:49 <ski> @hoogle r -> (a -> r -> r) -> ([a] -> r)
17:05:49 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
17:05:49 <lambdabot> Data.List foldr :: (a -> b -> b) -> b -> [a] -> b
17:05:49 <lambdabot> Prelude scanr :: (a -> b -> b) -> b -> [a] -> [b]
17:09:47 * hackagebot prelude-generalize 0.1.1 - Another kind of alternate Prelude file  http://hackage.haskell.org/package/prelude-generalize-0.1.1 (AaronBlack)
17:10:24 <ski> hm .. `(forall a. f a -> i (g a))' vs. `(forall a b. (a -> b) -> (f a -> i (g b)))' ?
17:12:40 <Desperate> hey
17:12:59 <byorgey> hi Desperate
17:13:36 <Desperate> just checking this out. taking lessons at same time.
17:13:43 <byorgey> cool
17:14:00 <byorgey> feel free to ask questions in here.
17:14:15 <Desperate> Sounds great.
17:14:32 <Desperate> I got one.
17:17:39 <rasfar> gah! the suspense....
17:18:06 <dgpratt> rasfar: :)
17:19:05 <hpc> pirate is set to be publicly hanged, but due to the weather they postpone it
17:19:12 <hpc> pirate says "the suspense is killing me!"
17:19:23 <irene-knapp> technically, it's the suspension
17:19:28 <hpc> shush :P
17:19:36 <irene-knapp> just saying :D
17:19:54 <dgpratt> I'll give y'all one to tide you over: How does callCC relate to classical logic?
17:19:56 <blackdog> irene-knapp: arrant pedantry :)
17:20:09 <hpc> :t callCC
17:20:10 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
17:20:11 <whittle> pirate walks into a bar with ship’s wheel sticking out of his pants
17:20:19 <whittle> barman asks what it’s for
17:20:31 <whittle> pirate response “Arrr, it’s driving me nuts!”
17:20:38 <dgpratt> oh dear
17:20:39 <t7> 2/10
17:20:45 <ski> @type let fwd :: ((forall a. f a -> g a) -> (forall a. t f a -> t g a)) -> ((forall a b. (a -> b) -> (f a -> g b)) -> (forall a. t f a -> t g a)); fwd fmap1 = fmap1' where fmap1' fgmap = fmap1 fg where fg fa = fgmap id fa in fwd
17:20:46 <lambdabot>     Inferred type is less polymorphic than expected
17:20:46 <lambdabot>       Quantified type variable `a' is mentioned in the environment:
17:20:46 <lambdabot>         fg :: f a -> g a (bound at <interactive>:1:196)
17:20:49 <ski> @type let bwd :: ((forall a b. (a -> b) -> (f a -> g b)) -> (forall a. t f a -> t g a)) -> ((forall a. f a -> g a) -> (forall a. t f a -> t g a)); bwd fmap1' = fmap1 where fmap1 fg = fmap1' fgmap where fgmap ab fa = fmap ab (fg fa) in bwd
17:20:50 <lambdabot>     Inferred type is less polymorphic than expected
17:20:50 <lambdabot>       Quantified type variable `a' is mentioned in the environment:
17:20:50 <lambdabot>         fgmap :: forall b1. (a -> b1) -> f a -> g b1
17:21:01 * ski wonders whether one can make those go through, somehow ..
17:21:21 <hpc> @quote yarr
17:21:21 <lambdabot> hpc says: yarr, arr be rather arr-bitrary
17:21:38 <rasfar> not to hit and run, but this place is really filling up, gotta mosey
17:22:09 <ski> dgpratt : by CH/BHK, classical logic means that every function can return more than once, and do similar strange stuff
17:22:37 <dgpratt> ski: oh
17:23:18 <ski> dgpratt : this is known as cut-elimination for LK being non-confluent
17:23:24 <dgpratt> ski: err, what's CH/BHK? CH makes me think Curry-Howard; coincidence?
17:23:38 <whittle> So, if I write a function that takes a request and returns an IO action that makes an HTTP call and produces a response value, is it semantically okay to call it sendRequest, even though the request doesn’t get sent until the returned IO monad is actually processed?
17:23:39 <ski> Currry-Howard / Brouwer-Heyting-Kolmogorov
17:23:58 <dgpratt> ski: ah, something to google :)
17:24:57 <ski> dgpratt : e.g. in SML/NJ i can implement  principleOfOmniscence : unit -> ('a,'a not) either
17:27:00 <dgpratt> ski: ok, starting to connect the dots (albeit weakly)
17:27:30 <monochrom> is that like Request -> IO Response? then it's surely sendRequest
17:28:23 <ski> if you evaluate `case principleOfOmiscence () of Left n => n + 1 | Right k => contradiction k 42', this will return `43'
17:28:47 <ski> where  contradiction : 'a not -> 'a -> 'b
17:29:31 <t7> i am starting to appreciate ML
17:29:39 <ski> (:
17:29:51 <monochrom> consider print :: (Show a) => a -> IO (). it returns an IO action that prints. if the returned IO action is not processed, there is no print. yet we have no problem calling it "print".
17:30:13 <kallisti> ski: I can't think of a better name for cond, and I'm already using cond for a the Lisp-style conditional operator.
17:30:24 <whittle> monochrom: Awesome, thanks.
17:30:47 <ski> (in case you wonder, the contradiction here is that the type of `k' is `int not', which is claiming that the type `int' is uninhabited -- we contradict this by constructing an inhabitant of `int', namely `42', and as a result derive any type we like)
17:30:55 <whittle> I’m trying to grok the denotational thing, and I just had a sudden panic about verbs.
17:31:03 <ski> kallisti : did you mention the type of your `cond' ?
17:31:17 <kallisti> cond :: [(Bool, a)] -> a
17:31:23 <kallisti> maybeCond :: [(Bool, a)] -> Maybe a
17:31:26 <dgpratt> ski: very interesting
17:31:51 <kallisti> cond throws a runtime error if a condition doesn't match
17:32:13 <kallisti> or rather, when no conditions match.
17:33:04 <kallisti> so it's something like "anonymous guards"
17:33:46 <ski> dgpratt : the operational semantics is that `principleOfOmniscience ()' will *always* (per default) assume that the type is uninhabited, returning `Right k' for a new continuation `k' of type  'a not  -- if later an inhabitant `x' is discovered (and signalled, using `contradiction' with the continuation, then the `principleOfOmniscience ()' call will return a *second* time, this time returning `Left x')
17:33:50 <kallisti> cond [(x > 0, a), (x == 0, b), (otherwise, c)]
17:35:30 <booyah> human brains are lazily evaluated
17:36:11 <monochrom> hahaha
17:38:09 <ski> dgpratt : another nice thing with continuations is that i can write `reify (fn () => reflect [3,4] + reflect [100,200])' and have it evaluate to `[103,203,104,204]' -- this is for the list monad, but we can do this with *every* (implementable) monad ! :)
17:40:06 <dmwit> ski: I knew ML was impure, but I didn't know it supported multiple returns.
17:40:16 <ski> dgpratt : in any case,  callCC : (('a -> 'b) -> 'a) -> 'a  corresponds to Peirce's law, and is equivalent to proof-by-contradiction, double-negation-elimination, and principle of omniscience (aka law/principle of excluded middle)
17:40:17 <dmwit> How does that work?
17:40:17 <kallisti> ski: so.. no ideas for a good name?
17:40:35 <ski> dmwit : you need continuations (and state) -- which not all implementations support
17:40:37 <dgpratt> ski: I must admit that last one is just not penetrating my brain, but I'm sure it's as nice as you say :)
17:40:49 <ski> SML/NJ supports continuations, though (and Mlton as well, iirc)
17:41:06 <dmwit> ski: Oh, there's an implicit ContT or something?
17:41:14 <ski> dmwit : see the paper "Representing Monads" by Andrzej Filinski
17:41:23 <ski> dgpratt ^
17:41:50 <ski> dmwit : yes, that's what having first-class continuations basically means
17:42:17 <ski> (or rather, the position of the `ContT o' in the conceptual monad transformer stack is fixed)
17:42:21 <dgpratt> ski: thanks for giving me some insight into this
17:44:09 <ski> dgpratt : there's also some paper with "lambda-mu-calculus" in the title, maybe by Curien, which i vaguely remember being interesting
17:44:20 <ski> also the thesis of Andrzej Filinski
17:44:20 <xil> hey. I'm using OpenGL and when I include a depth buffer then it displays...pixelated? Here's a pic http://i.imgur.com/3elRj.png. Anyone know why it only displays every other pixel basically?
17:44:35 <jfischoff> xil: post your code
17:44:39 <ski> there's also papers by Hayo Thielecke, and Olivier Danvy, about continuations
17:46:16 <xil> jfischoff: http://hpaste.org/68104
17:47:35 <Cale> xil: displays solid for me
17:48:09 <xil> Cale: interesting. Well that sort of explains? How are you running it?
17:48:17 <Cale> ghc --make gltest
17:48:20 <Cale> ./gltest
17:48:41 <xil> oh I don't --make
17:48:44 <xil> lemme try that
17:48:54 <xil> still no. Hmmm
17:49:07 <jfischoff> xil:update your driver I guess
17:49:11 <Cale> Oh, --make might be the default now
17:49:29 <Cale> yeah, it is
17:50:11 <xil> jfischoff: yeah, need to figure out how to do that
17:51:18 <monochrom> try on various different OSes, distros...
17:51:52 <xil> I'll have to install on them anyway, so I might as well try this one first
17:53:39 <dmwit> After adding an import for Data.IORef and Control.Monad, I can confirm that it's a solid cube here, too.
17:54:41 <Cale> xil: I do get a weird effect as I move the cube around with the spacebar held down
17:54:47 <kallisti> @hoogle select
17:54:48 <lambdabot> Graphics.Rendering.OpenGL.GL.Selection module Graphics.Rendering.OpenGL.GL.Selection
17:54:48 <lambdabot> Graphics.Rendering.OpenGL.GL.Selection Select :: RenderMode
17:54:48 <lambdabot> Text.Html select :: Html -> Html
17:54:52 <xil> don't hold space, just click it
17:55:12 <xil> it's a toggle for mouse control of rotation
17:55:17 <xil> or should be
17:55:18 <Cale> oh, even then
17:55:38 <xil> I'm sure there are kinks to work out, but I have to be able to see what's happening properly first =P
17:55:40 <Cale> It looks like it's erasing the previous cube afterward
17:55:49 <Cale> (after drawing the new one)
17:55:53 <Cale> or something similar
17:56:11 <xil> oh I forget to loadIdentity at the beginning of the display function
17:56:36 <xil> should be "display = do { clear [ColorBuffer]; loadIdentity;...}"
17:56:47 <byorgey> anything where you can get weird results by forgetting to ___ at the beginning of the ___ makes me sad =(
17:57:10 <Cale> That didn't appear to help
17:57:24 <Cale> OpenGL is the Rubik's Cube of graphics libraries
17:57:33 <kallisti> @hoogle selectBy
17:57:34 <lambdabot> No results found
17:57:57 <Cale> It's nearly impossible to change some things without affecting other things :)
17:58:24 <jmcarthur> @remember Cale OpenGL is the Rubik's Cube of graphics libraries. It's nearly impossible to change some things without affecting other things
17:58:25 <lambdabot> I will remember.
17:58:25 <Cale> and you frequently have to do things like A B A^-1 to change some particular piece of state
17:58:58 <jmcarthur> for what it's worth, i disagree only slightly
17:59:13 <jmcarthur> it's very easy to get yourself into a situation where what you say is true
17:59:54 <djahandarie> You don't disagree, he said "nearly"!
18:00:02 <jmcarthur> heh
18:00:10 <jmcarthur> okay, sure
18:02:02 <jfischoff> Cale: probably not what you meant but made me think of the versor product: http://en.wikipedia.org/wiki/Versor
18:02:51 <jfischoff> Cale: the versor product is A B A ^-1
18:05:01 <xil> oh hey, are y'all using freeglut? Maybe that's what's causing this problem for me?
18:05:33 <jfischoff> xil: it worked for me too. I just did cabal install glut
18:06:31 <xil> jfischoff: I did cabal install glut only yesterday, but have had OpenGL for a while. Maybe I need to upgrade my HOpenGL? Is there a way to just update everything with cabal?
18:08:01 <parcs`> what's a nice operator for matrix multiplication? perhaps #*#
18:10:00 <dmwit> jfischoff: a b (a^-1) is a really common operation in lots of groups
18:10:00 <quintessence> parcs`: hmatrix uses >< iirc
18:10:33 <dmwit> jfischoff: It even has a name: http://en.wikipedia.org/w/index.php?title=Conjugation_(group_theory)
18:10:59 <Cale> jfischoff: Yes, or generally any kind of conjugation by an element
18:24:04 <MaskRay_> In Alex with posn wrapper, why is the action type AlexPosn -> String -> token
18:24:22 <MaskRay_> Then there is no information on how long this token is
18:26:28 <xil> AHA. I was neglecting to clear the depthbuffer on each display. Don't know why y'all weren't have the display problem, but now I'm not. But I am noticing the increasing lag and eventual stack overflow
18:26:50 <napping> What is the String?
18:27:33 <napping> the example alexScanTokens suggests it's exactly the token, and you can check its length
18:29:51 * hackagebot cond 0.0 - Basic conditional operators with monadic variants.  http://hackage.haskell.org/package/cond-0.0 (AdamCurtis)
18:30:00 <kallisti> ^ perhaps my least offensive hackage upload to date.
18:30:32 <napping> MaskRay_: are you worried about the cost of length?
18:31:53 * kallisti notes that this might be the only language community where he can get away with creating such a trivial library.
18:31:55 <Cale> kallisti: haha, what's your most offensive?
18:32:17 <kallisti> probably my patch to interpolatedstring-perl6
18:32:39 <kallisti> to support Text and (prepare to cringe) ByteString.
18:33:11 <kallisti> but unsafe-promises probably offends people with objections to the use of unsafeInterleaveIO
18:33:49 <Cale> I've never really seen the need for interpolated string libraries, though I don't see anything wrong with Text and ByteString support for them
18:34:15 <kallisti> well the primary issue is that I use horrible IncoherentInstances hacks.
18:34:27 <kallisti> and yeah I've never really needed it as a library, but I could see it being convenient.
18:34:33 <kallisti> especially with things like large SQL queries, for example.
18:34:36 <napping> no haddocks?
18:34:41 <kallisti> it has to generate.
18:34:56 <kallisti> you can just look at the source for documentation though
18:35:01 <kallisti> it's pretty straightforward code.
18:35:19 <napping> yeah
18:35:45 <zzo38> Are there any Haskell package to request to WHOIS, Gopher, Finger, etc?
18:35:48 <dmwit> If you're using IncoherentInstances, chances are you meant to just use records instead.
18:36:40 <kallisti> I... have no clue how I would accomplish that.
18:37:11 <kallisti> Cale: so now if people ask "is there anything like if-then-else in the form of a function", you can point them to something. :P
18:37:16 <zzo38> Are my questions difficult?
18:38:00 <kallisti> zzo38: no. but I can google just as well as you.
18:38:08 <kallisti> and I didn't find anything.
18:38:26 <MaskRay_> napping: no, but i worryied about the lost information
18:38:41 <zzo38> kallisti: Google? But isn't it Hackage to access Haskell packages?
18:39:17 <napping> http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:gopher
18:39:47 <napping> MaskRay_: it shouldn't be lost. Look at http://www.haskell.org/alex/doc/html/wrappers.html#id462357
18:39:52 * hackagebot husk-scheme 3.5.5 - R5RS Scheme interpreter, compiler, and library.  http://hackage.haskell.org/package/husk-scheme-3.5.5 (JustinEthier)
18:40:05 <MaskRay_> napping: { ... } :: AlexPosn -> String -> token
18:40:12 <MaskRay_> napping: the length infomation is lost
18:40:21 <zzo38> Does cabal have a command to search for packages?
18:40:21 <napping> something has gone wrong if (take len str) produces something shorter than len
18:44:06 <MaskRay_> napping: doesn't the second field of AlexToken mean Token length
18:44:14 <MaskRay_> napping: how could it go wrong?
18:44:36 <zzo38> Basically what I wanted is, you give it the host name and port number and the data to send, and then it will give you the response from the server based on that, automatically dealing with open/close connection and so on.
18:45:11 <napping> Just looking at the wrapper part of the code, the "str" might be shorter than len and then you would lose information, but then Alex should have already produced a syntax error about premature EOF or found a shorter token or something like that
18:45:25 <xil> hmmm...so would anyone mind helping me debug this? Here's the code http://hpaste.org/68105. When I toggle mouse control with spacebar and then move the cube with the mouse, it causes a stack overflow after not too long. If I untoggle it then it seems to clear the stack and let me try again, but using the mouse will still eventually cause a stack overflow if I don't keep retoggling. Anyone see anything that could be the cause of that?
18:45:53 <napping> xil: sounds like a lazy counter getting too big?
18:46:24 <xil> napping: but I don't have any recursion, to my knowledge
18:46:42 <napping> Now I see several places thunks could pile up
18:46:49 <Cale> xil: stack overflows happen when evaluating an expression which has grown very large
18:46:56 <MaskRay_> napping: so the String stored in AlexInput is never guaranteed to be the whole input?
18:46:59 <Cale> xil: It's not a call stack
18:47:08 <xil> Cale: oh
18:47:26 <Cale> xil: It's a stack of pattern matches (case expressions) which are waiting for their scrutinee to be evaluated enough to be able to pattern match
18:47:37 <napping> MaskRay_: IIRC it's supposed to be the whole input, and the (take len str) should always end up giving you a string of len chars
18:48:04 <napping> if you want the length more directly, you could also do without any of the wrappers and provide a modified version yourself
18:48:26 <xil> Cale: do you see a potential cause of that in my code?
18:48:34 <xil> napping: where do you see a problem?
18:48:39 <napping> xil: modifyIORef camRot $ \ ( yaw, pitch ) -> ( yaw - dx, pitch - dy ) for one
18:48:52 <Cale> xil: Well, the display callback is getting called regularly, right?
18:49:15 <xil> Cale: at least every time the mouse callback is
18:49:16 <Cale> If not, then the yaw and pitch expressions in camRot are going to get big
18:49:18 <xil> or should be
18:49:18 <napping> if the pair is ( 0 , 0 ), then it turns into a pair of thunks ( <0 - 0.1 * (fromIntegral x - mx)> , < 0 - 0.1 * fromIntegral $ y - my > )
18:49:29 <zzo38> Is there any simple way in Haskell doing like what I have mentioned?
18:49:34 <xil> napping: but isn't it being evaluated in the display callback?
18:49:40 <Cale> it is
18:50:55 <xil> something is building up such that each motion of the mouse takes longer for the program to process, until an eventual stack overfloat
18:51:12 <xil> overflow
18:51:12 <Cale> xil: How long does that take to happen?
18:51:49 <MaskRay_> is there a way to make all undefined or pattern matching failure replaced by #define head (\xs -> case xs of { (x:_) -> x ; _ -> error("head: empty
18:51:52 <napping> zzo38: sounds like netcat, if that's all the whole program is supposed to do
18:51:55 <xil> Cale: couple of seconds
18:52:05 <Cale> okay, I'm not seeing that behaviour then
18:52:14 <Cale> I just press space and move the mouse around, yeah?
18:52:18 <xil> yeah
18:52:23 <MaskRay_> or dump the calling stack
18:52:50 <zzo38> napping: I mean a library, not a standalone program; and it does not need to work interactively; simply send the request as the first thing after connecting, and then receive the response and close the connection. Where the request and response can be arbitrary data.
18:52:51 <Cale> okay, I've been going at that for a few minutes now, and there's no change in behaviour or crash
18:53:15 <Cale> xil: Is http://hpaste.org/68105 the latest version?
18:53:16 <xil> Cale: ugh, so it's my system. Why is this happening to me and not you? Could it be the Haskell binding? Maybe I should reinstall with cabal?
18:53:23 <xil> yes
18:54:17 <Cale> I'm using GHC 7.4.1 with OpenGL 2.4.0.2.1 and GLUT 2.2.2.1
18:54:44 <xil> Cale: how do I check my opengl and glut versions?
18:54:53 <Cale> ghc-pkg list OpenGL
18:54:57 <Cale> ghc-pkg list GLUT
18:55:41 <napping> it looks like display should force things whenever it happens, but where is "b" used?
18:56:02 <Cale> b is used by when
18:56:18 <napping> ah, in motion
18:56:23 <xil> Cale: OpenGL 2.5.0.0 GLUT 2.3.0.0
18:56:33 <zzo38> Something like:   HostName -> PortNumber -> ByteString -> IO ByteString
18:56:33 <xil> GHC 7.4.1
18:56:41 <Cale> okay, so you've even got newer versions than I do.
18:56:45 <Cale> I'll try updating
18:57:01 <napping> hitting space a lot without moving the mouse could pile up not?
18:57:09 <Cale> napping: Yeah, it could
18:57:17 <Cale> (but somewhat unlikely)
18:57:45 <Cale> I'm starting to think this isn't the fault of his code
18:57:47 <dmwit> zzo38: Really, you can Google your question as well as we can. No need to ask it five times. If we knew the answer, we would have said so after the first time.
18:58:05 <Cale> Maybe a bug in the newer version of the bindings, or maybe a call stack overflow from some C code.
18:58:24 <xil> Arch is notorious to me for putting not entirely stable packages in the main repos
18:58:36 <xil> I feel like I shouldn't be using these versions of OpenGL and GLUT
18:58:39 <zzo38> I do not wish to open the web browser at this time and I do not like Google either.
18:58:48 <Cale> xil: I'm going to try the new versions
18:58:56 <napping> xil: It looks like it's probably okay, but I'd suggest making things stricter rather than thinking hard about whether thunks could pile up to dangerous levels
18:58:59 <Cale> There was no special reason I was using the older ones
18:59:11 <Cale> (They were the latest from hackage at the time I updated them last)
18:59:29 <zzo38> However, I cannot find it in Hackage either. There is some networked stuff though
18:59:51 <dmwit> zzo38: I was using "Google" as a generic verb for searching the web. Use whatever search engine you prefer.
19:00:00 <napping> zzo38: hackage.haskell.org has it's own search. just opening a connection and getting a response is pretty simple even with the basic "network" library
19:00:59 <zzo38> Well, I am searching the libraries I have installed to see what functions they have to see if it work
19:01:36 <Cale> xil: Okay, I'm not seeing that problem even with updated OpenGL and GLUT libraries
19:05:19 <xil> Cale: BAH!
19:05:50 <xil> Cale: you updated the Haskell bindings though right? Not the C libraries
19:06:36 <Cale> right
19:06:48 <xil> know how to check the version of the C libraries?
19:06:49 <Cale> I'm using NVidia's libGL
19:06:56 <Cale> from their latest driver
19:07:29 <xil> I'm using the open radeon driver for ATI. Maybe that's it...
19:07:37 <zzo38> Is there a strict hGetContents?
19:07:52 <dmwit> ?hackage strict
19:07:53 <lambdabot> http://hackage.haskell.org/package/strict
19:08:08 <xil> I'd use the proprietary driver if I didn't lose graphics support every other system update and have to manually reinstall
19:09:19 <xil> Cale: oh wait a sec, I have libgl 8.0.2-1, the "Mesa 3-D graphics library and DRI software rasterizer"
19:16:29 <zzo38> How am I supposed to make it receive everything until the remote host closes the connected? I think hGetContents is the wrong one
19:18:04 <napping> it does get the contents, the only trick is the host might not like it if you don't use it up fast enough
19:18:23 <zzo38> I did use the strict hGetContents
19:19:17 <napping> then you got everything the server sent
19:19:44 <zzo38> No, the program would freeze. I did use withSocketsDo as well.
19:20:05 <napping> did the server close the connection?
19:21:00 <zzo38> napping: Yes I believe so.
19:21:32 <zzo38> \x y z -> (connectTo x (PortNumber y) <>>= flip hPutStr z) >>= hGetContents     And it seems doesn't work
19:22:31 <Mathnerd314> kallisti: have you considered adding Bool -> Either a a -> a to cond?
19:22:55 <napping> what's that supposed to do?
19:23:38 <dmwit> perhaps he meant Bool -> a -> Either a a
19:23:52 <napping> or Bool -> (a,a) -> a
19:24:02 <napping> bool fst snd or bool Left Right, anyway
19:24:21 <Mathnerd314> oops, yeah, napping's is right
19:25:10 <dmwit> aw
19:25:24 <dmwit> If you're going to condM, at least make the constraint be MonadPlus m.
19:25:50 <dmwit> oh, condPlusM is that =P
19:26:09 <dmwit> Still, weird to see error instead of, say, fail.
19:34:50 <xil> Cale: are you on linux?
19:34:59 <Cale> yes
19:35:04 <kallisti> Mathnerd314: I had not, but now I have!
19:35:26 <xil> can you run "glxinfo | grep -i version"?
19:35:48 <ski> kallisti : `Either a a -> (Bool -> a)' might be nicer ..
19:35:59 <hpaste> Cale pasted “GL version info” at http://hpaste.org/68106
19:36:14 <ski> hm, or with pairs, yes
19:36:49 <kallisti> that's pretty straightforward with curry (bool a b) already
19:36:54 <xil> Cale: thanks =D. You have version 3.3 I have 2.1. maybe that has something to do with it. I'll poke around ##OpenGL for the answer
19:36:55 <kallisti> er
19:36:57 <kallisti> not that
19:37:22 <kallisti> bool already does the Either thing pretty well. Is it really common that people have Either a a?
19:37:38 <Cale> xil: Hm, I'm not sure those numbers are comparable, as you're using a completely different driver, aren't you?
19:37:39 <ski> hm, probably not
19:37:41 <tgeeky_> dmwit: good sir!
19:37:58 <Cale> xil: have you tried using the official fglrx driver?
19:38:09 <dmwit> tgeeky_: cheers mate
19:38:55 <zzo38> If you do have (Either a a) then (id ||| id) will get one value
19:38:58 <kallisti> dmwit: that's what condPlusM is.
19:39:05 <xil> Cale: yeah and I'm sure they would fix this but they are a pain in the butt on Arch because I basically can't do a system update with them installed
19:39:07 <dmwit> kallisti: Yeah, saw it after a second.
19:39:17 <xil> Cale: it's my ignorance on how to properly deal with them for sure, but it's what it is...a pain
19:39:42 * kallisti imagines there's some useful combinator he hasn't thought of.
19:39:42 <tgeeky_> dmwit: what is the relative degree of difficulty to write the unification solver compared to what you've done so far?
19:39:52 <kallisti> I'm not sold on the Either a a business though.
19:39:55 <dmwit> tgeeky_: I had a start at it this afternoon.
19:40:07 <dmwit> It's a bit trickier, since they don't talk about how to do it in the paper at all.
19:40:14 <dmwit> I've been looking at
19:40:18 <dmwit> ?hackage unification-fd
19:40:19 <tgeeky_> dmwit: hehe. "a bit trickier"
19:40:19 <lambdabot> http://hackage.haskell.org/package/unification-fd
19:40:27 <zzo38> kallisti: Yes I also try. Do you like <>>= function?
19:40:35 <dmwit> ...which looks like it provides some good stuff.
19:40:39 <tgeeky_> dmwit: so have you been mechanically translating the paper to this code?
19:40:42 <ski> kallisti : converting from `(Bool,a)' to `Either a a' might be more common ..
19:40:52 <kallisti> possibly
19:40:53 <dmwit> We'll need to parameterize our values by the type of unification variables, though.
19:40:58 <dmwit> tgeeky_: So far, yes. =)
19:41:13 <dmwit> e.g. take out the Int and replace it with a type variable
19:41:14 <kallisti> zzo38: what does that do?
19:41:24 <tgeeky_> dmwit: ok. Either way, you're much faster / more productive than I am, but after understanding what the code actually says somewhat better (through reading *your code* rather than their paper)
19:41:33 <ski> dmwit : which probably makes it into a monad ..
19:41:49 <zzo38> kallisti: It is defined in prelude-generalize as   x <>>= f = x >>= ap (<$) f;
19:41:54 <dmwit> ski: hm...
19:42:03 <tgeeky_> dmwit: that is where I see multiplate coming in
19:42:07 <dmwit> ski: I doubt it, since our unification variables are tagged with a type.
19:42:08 <ski> @type let x <>>= f = x >>= ap (<$) f in (<>>=)
19:42:09 <lambdabot> forall (m :: * -> *) a b. (Monad m, Functor m) => m a -> (a -> m b) -> m a
19:42:10 <kallisti> zzo38: ah. yep! that's good to me.
19:42:12 <dmwit> (of values in the language)
19:42:18 <tgeeky_> dmwit: if this can be done without a monad, but just applicative/alternative, then we might be able to do this *with applicative* genuinely
19:42:21 <kallisti> zzo38: I believe we were talking about this function previously?
19:42:30 <zzo38> kallisti: Probably.
19:42:43 <dmwit> tgeeky_: I really don't think Value will become a monad or an applicative.
19:42:50 <dmwit> not 100% sure of that
19:42:54 <dmwit> I've been wrong before. =)
19:43:04 <ski> dmwit : hm, maybe not in that case ..
19:43:39 <tgeeky_> dmwit: well if we don't paramterize it at all, it certainly won't :O
19:43:42 <tgeeky_> right?
19:44:00 <ski> dmwit : you could probably define `forall f g. (Functor f,Functor g) => (forall a. f a -> g a) -> (Value f -> Value g)', though
19:44:38 <dmwit> ski: It's possible. I'm a bit burnt just now, though, so I can't definitely comment intelligently. =P
19:44:43 <dmwit> tgeeky_: heh, right, of course
19:44:51 <dmwit> tgeeky_: gotta have the right kind =P
19:45:11 <kallisti> oh, a whenM would be good
19:45:19 <kallisti> guardM is too trivial though.  (guard =<<)
19:45:32 <ski> dmwit : such things can be useful if you want to "freeze" a structure involving unification variables, into a normal non-monad-traversable data structure
19:45:51 <dmwit> yes
19:45:54 <ski> (dmwit : possibly you'll need to traversify it, though)
19:45:55 * kallisti notes the irony in saying that something is too trivial for this library. :P
19:45:57 <dmwit> unification-fd has some facilities for freezing, too
19:46:06 <zzo38> I will also try to add these things to prelude-generalize as well, whichever of your ones are I liked too.
19:46:14 <dmwit> ski: I think maybe the UTerm (from unification-fd) will be the one providing Monad, Traversable, etc.
19:46:21 <dmwit> ski: Not Value.
19:46:31 * ski doesn't know `unification-fd'
19:46:43 <dmwit> It's a library on Hackage for unification. =)
19:46:52 <stj> unknown flag in  {-# OPTIONS_GHC #-} pragma: -threaded ---> why can't I have -threaded inside OPTIONS_GHC?
19:47:07 <ski> dmwit : and by "traversify" i meant `forall f g. (Functor f,Functor g,Applicative i) => (forall a. f a -> i (g a)) -> (Value f -> i (Value g))'
19:47:07 <dmwit> stj: OPTIONS_GHC is only for dynamic flags; -threaded is a static flag
19:47:22 <dmwit> stj: or possibly I have dynamic and static reversed; check the manual if you care about getting it correct
19:49:35 <twopoint718> I have what I hope isn't a weird question. I want to put the equivalent of ghci's :type command into a .hs and then print out the result.
19:49:35 <tgeeky_> dmwit: here's the point of multiplate in this situation: if we change: s/data Value =/data Value a =/;  s/data Term =; data Term a =/;   -- everything used to define Data Context (except Context itself)  -- *AND* possibly, I'm not sure about this part, do s/data Context =/data Context a =/;
19:49:54 <zzo38> kallisti: Do you have the (.:) and (.::) and (.:::) like I have in prelude-generalize?
19:50:39 <dmwit> twopoint718: in ghci, :l your file, then just use :t like usual
19:50:40 <tgeeky_> dmwit: then ____ magic happens ____
19:50:47 <kallisti> zzo38: those aren't conditional operators; so no.
19:50:48 <dmwit> You'll have access to anything you defined in the file.
19:51:02 <zzo38> Yes; they are not conditional operators.
19:51:33 <tgeeky_> dmwit: but in reality you have a chance of getting various ordered traversal functions and whatnot for free?
19:51:34 <ski> zzo38 : `infixl' or `infixr' ?
19:51:52 <twopoint718> dmwit: okay, thanks, that's what I'll do.
19:51:56 <tgeeky_> dmwit: though this is tangential I think to unification
19:52:00 <tgeeky_> dmwit: if helpful at all.
19:52:02 <zzo38> ski: I have them as infixr 9 same as (.) but if you think something else is better then I can adjust it
19:52:42 <ski> zzo38 : that's how i made them originally -- istr someone else in here using `infixl' instead -- i'm actually not sure if that would be better
19:53:01 <dmwit> tgeeky_: As I said before, you don't have to sell me on it. =)
19:53:08 <dmwit> I'm sold on anything based on lenses.
19:53:29 <tgeeky_> dmwit: well you said the other night that you don't think mutual recursion will enter the picture :O
19:53:44 <dmwit> I think that's true.
19:54:01 <dmwit> But I have no objection if you want to use multiplate.
19:54:16 <tgeeky_> dmwit: hehe of course, but I don't want to diverge so wildly yet :)
19:54:17 <zzo38> However the one I have is based on Control.Category as in  (.:) :: Category cat => cat b c -> (a -> cat a1 b) -> a -> cat a1 c;
19:54:21 <tgeeky_> I don't even know how to run this thing :O
19:54:36 <dmwit> heh
19:54:41 <ski> zzo38 : so not `Functor', then ..
19:54:43 <dmwit> It compiles, what do you need to run it for? =D
19:55:42 <zzo38> ski: Correct; it isn't Functor
19:56:18 <zzo38> It allows to define    bind2 = join .:: liftM2; bind3 = join .::: liftM3;
19:56:28 <tgeeky_> dmwit: ah! easy! compilation might show that it's a well defined for a one particle system, but I'm a physics nerd. I want at least two particles to see if opposites attract or repel.
19:57:15 <zzo38> (=<<) = join .: fmap;
19:57:20 <tgeeky_> dmwit: btw, you do agree that the color = R|G|B thing seems like it was accidentally edited in from another paper?
19:57:22 <charliesome> hi #haskell, beginner here! I have a IO [Int], how would I do a sum over the list and get the result as an IO Int?
19:57:43 <zzo38> charliesome: Use fmap to do functions on the values inside the IO or any other monad or functor
19:57:57 <xil> Cale: missed that comment about versions. I think 3.3 and 2.1 are comparable because they are the OpenGL version itself (or at least I'm guessing because they are valid OpenGL versions), while the number after the driver name is what's incompatible
19:58:05 <ski> zzo38 : *nod*
19:58:14 <sipa> charliesome: do { ints <- ioInts; return (sum ints) }
19:58:24 <sipa> or fmap sum ioInts
19:58:41 <dmwit> tgeeky_: looks like this paper to me
19:58:51 <ski>   liftM sum ioInts  -- the same
19:58:56 <dmwit> It talks about unifying variables with R later.
19:59:02 <kallisti> I wonder why there is no ifM in Control.Monad
19:59:02 <charliesome> sipa, zzo38: thanks
19:59:15 <tgeeky_> dmwit: the word I was looking for was 'unmotivated'?
19:59:23 <tgeeky_> that must mean I dont understand that part either.
19:59:25 <tgeeky_> cool!
19:59:53 <dmwit> tgeeky_: Yeah, it's super un-motivated.
20:00:12 <dmwit> A bit weird, but I think it was put there on purpose at least. =P
20:00:51 <tgeeky_> dmwit: let me make a suggestion. I don't quite understand the unification bits
20:01:08 <tgeeky_> dmwit: but I do understand color in lots of ways, and in this case, it's a pretty bad choice of three things to talk about.
20:01:44 <tgeeky_> dmwit: but if they are saying that one of three types is special, why not just do: list = L|C|R, and pick C as the special one.
20:02:26 <dmwit> Yeah, choosing R, G, and B as the only values of type color is a bit weird, given that we usually tag each of those with some more data.
20:02:52 <tgeeky_> dmwit: well, I mean it this way. Choosing color at all is weird, because there is never anything special about R vs B vs G
20:02:52 <dmwit> And I think they'd be perfectly happy alpha-varying that example however you want (e.g., to list = L|C|R).
20:03:08 <tgeeky_> dmwit: well, in my case, there *is* something special about one of them
20:03:17 <tgeeky_> dmwit: C doesn't have an opposite in the list
20:03:30 <tgeeky_> (or, if it does, it has two of them)
20:03:40 <dmwit> wut
20:03:57 <dmwit> What are opposites, and how did they come into the picture?
20:04:05 <tgeeky_> dmwit: in the paper, is R actually special?
20:04:14 <dmwit> no?
20:05:20 <tgeeky_> dmwit: so, if I changed the paper to say "unifying 1/alpha with color B" or " ... color G", then everything is identical, yes?
20:06:08 <tgeeky_> it seems that way to me. namely because he never mentions the other two, ever?
20:06:13 <dmwit> As long as you also changed "fixes alpha_1 to be B in the other".
20:12:17 <stj> how can I parallelize this? I've tried to use parMap with all available strategies, but without luck. :( -- render w h = [getPixel w h x y | y <- [0..h-1], x <- [0..w-1]]
20:13:10 <dmwit> How do you know you aren't having luck?
20:13:32 <stj> I ran it but it's even a bit slower than non-parallel version
20:14:08 <dmwit> That does not imply that it's not being parallelized.
20:14:47 <dmwit> If getPixel isn't doing much work, the overhead of tracking sparks can easily outweigh the benefit of doing things in parallel.
20:15:23 <stj> dmwit: it is doing quite a bit of work, but maybe there are too many pixels, which makes a great overhead
20:15:39 <stj> I'll try distributing the work in a more clever way
20:16:03 <dmwit> Also, how are you compiling/running?
20:17:04 <stj> {-# OPTIONS_GHC -O2 -fllvm -funbox-strict-fields -with-rtsopts=-N4 #-}
20:17:15 <stj> and I compile with: ghc -threaded -o ray ray.hs
20:17:52 <dmwit> huh
20:17:59 <tgeeky_> dmwit: My understanding:  "1" gives you:  () -> ((),());  Use "1 <-> (1/b) * b" and a fanout to get: (x^-1 , x) and (y^-1, y); Use shuffling to get a mix: (x^-1, y) and (y^-1,x).
20:18:00 <dmwit> Can't say I've ever seen that use of OPTIONS_GHC.
20:18:42 <dmwit> tgeeky_: with you so far
20:18:43 <stj> I don't understand the confusion :)
20:18:54 <ClaudiusMaximus> i found parBuffer (compute first n in parallel, then when one is demanded queue the next nth in parallel) to be almost always more sane than parMap (all items in parallel)
20:19:48 <zzo38> O, I can make (.:) like this instead:     (.:) :: (Category cat, Functor f) => cat b c -> f (cat a b) -> f (cat a c)
20:20:25 <tgeeky_> dmwit: And then, since I don't understand unification, I assime we just "identify" x with R, and we therefore know something about 1/x (it's also R). But we know nothing about y at all!
20:20:49 <tgeeky_> dmwit: as far as I could tell, it could unify using R, G, or B. Or Q if he had introduced it.
20:21:04 <tgeeky_> dmwit: granted I've admitted i don't even know what unification is :)
20:21:24 <dmwit> tgeeky_: I think the point is we unify x with y, then eliminate all the worlds where y is not R or some such thing.
20:23:00 <dmwit> (we can always generate an R out of thin air to unify with)
20:24:15 <tgeeky_> dmwit: so we have: (x^-1, y)  here.         and way over here      -- keep going          --> here, we have (y^-1, x)
20:24:31 <tgeeky_> dmwit: and I assume we're waiting for either of them toe be evaluted?
20:24:54 <dmwit> I don't think "evaluated" is a meaningful property of values in this language.
20:25:32 <kallisti> I'm somewhat mystified by the zipper package.
20:28:11 <tgeeky_> dmwit: ok, trusting the code again, these values they speak of must be what I called "VV" and you called "Tuple"
20:28:46 <stj> how do I use parBuffer, it returns Strategy [a], but what am I supposed to do with this, how do I extract my results out of this Strategy [a] ?
20:29:00 <tgeeky_> dmwit: they use the words "subcomputation" which I naively and incorrectly assumed at some point would represent a thunk
20:29:19 <dmwit> tgeeky_: Sorry, lagged out for about 210 seconds according to irssi, give me a second to catch up.
20:29:55 <dmwit> Yes, no thunks going on here.
20:30:05 <dmwit> And yes, I think it will be a Tuple.
20:30:42 <dmwit> Tuple (Tuple (UnifVar 0) (Recip (UnifVar 1))) (Tuple (UnifVar 1) (Recip (UnifVar 0))) -- or some such thing
20:31:25 <dmwit> then at some point we'll execute an epsilon* on the first one, to get a constraint that says UnifVar 0 = UnifVar 1 and be left with just
20:31:30 <dmwit> Tuple (UnifVar 1) (UnifVar 0)
20:31:35 <dmwit> err
20:31:46 <dmwit> Tuple (UnifVar 1) (Recip (UnifVar 0)) -- of course
20:32:02 <dmwit> Then, whenever we learn something about UnifVar 0, we also learn it about UnifVar 1.
20:33:10 <dmwit> kallisti: I suspect that this is somehow related to Conal's observation about zippers. Let me see if I can find the blog post.
20:33:39 <dmwit> http://conal.net/blog/posts/another-angle-on-zippers
20:33:41 <kallisti> dmwit: I'm looking up zippers because I'm also working on a tree-based library for directories, and was wondering if I could incorporate a zipper somewhere.
20:33:51 <dmwit> sounds nice
20:34:05 <tgeeky_> kallisti: zippers all the things!
20:34:10 <dmwit> Are you mystified about zippers in general or that zipper package in particular?
20:34:13 <tgeeky_> kallisti: and do you mean dictionary, as in a book with words?
20:34:18 <kallisti> just that package.
20:34:24 <dmwit> Because I think I more or less understand zippers, but I am also flummoxed by that package. =D
20:34:25 <tgeeky_> kallisti: or more like the kind of dictionaries that GHC passes around?
20:34:45 <kallisti> tgeeky_: dictionary? where? what? help.
20:34:53 <dmwit> tgeeky_: directory, not dictionary =)
20:35:05 <tgeeky_> dmwit: oh. snap.
20:35:11 <xil> oh hey everyone, so I figured out what causes the problem. It's the line that resets the pointer to center screen. Commenting that out prevents this problem. Hmmm.....
20:35:12 <dmwit> preflex: seen kosmikus
20:35:12 <preflex>  kosmikus was last seen on #ghc 9 days, 12 hours, 17 minutes and 8 seconds ago, saying: for case, I could be convinced
20:35:30 <tgeeky_> kallisti: oh. there is a wonderful package that does what you're talking about
20:35:40 <tgeeky_> kallisti: but of course, it operates on lits of trees -- which are forests
20:35:45 <tgeeky_> kallisti: and it's called 'forrest'
20:36:13 <dmwit> neither "forrest" nor "forest" seems to be a package name on Hackage
20:36:14 <tgeeky_> without the misspelling of the word 'forest'
20:36:23 <tgeeky_> dmwit: it is not on hackage, unfortunately
20:36:30 <tgeeky_> kallisti: here is the paper: http://www.cs.cornell.edu/~jnfoster/papers/forest-icfp.pdf
20:36:43 <stj> was parBuffer recently changed? I see two different type signatures around
20:37:35 <tgeeky_> kallisti: code is here: http://www.padsproj.org/distrib-forest.html
20:37:54 <tgeeky_> kallisti: this might be a little (or a lot) overboard, but it's as type safe as you'll ever make it, so it's a good starting point
20:39:18 <tgeeky_> dmwit: can you join #diagrams for a little while, so I can lightly pester you/not embarass myself in a recorded channel
20:39:32 <kallisti> this does indeed look like overkill.
20:40:08 <tgeeky_> kallisti: even if you don't use the code, it may help to read the paper. It's a pretty clever technique, and if you could re-implement it using conduits as the backend (instead of PADS) then you might be in for a treat
20:40:27 <dmwit> uh
20:40:45 <dmwit> I'm happy to joind #diagrams, but is it really an appropriate channel?
20:40:51 <dmwit> Maybe just PM if it's something private.
20:41:03 <tgeeky_> dmwit: yes, they have told me that it's perfectly fine, but ok :)
20:41:10 <kallisti> my code is basically "take a directory, put all the file names recursively in a tree; do this with lazy IO too."
20:41:23 <kallisti> but I'm also working on recursive copy, delete, and move.
20:42:13 <kallisti> very cutting edge stuff.
20:42:26 <kallisti> but I might as well check this out.
20:42:37 <tgeeky_> kallisti: the code is *very* difficult to read. it was for me, at least.
20:44:10 <kallisti> hm, why is there no generalization of filterM to Traversable?
20:54:58 * hackagebot selinux 0.1 - SELinux bindings  http://hackage.haskell.org/package/selinux-0.1 (LuiteStegeman)
20:56:24 <ClaudiusMaximus> stj: i seem to have used   withStrategy (parBuffer 4 rseq)  for 4 cores
20:56:54 <ClaudiusMaximus> stj: sorry for delay, wandered off...
20:57:03 <stj> I've figured it out... I needed runEval
20:57:08 <stj> no problem :)
20:57:08 <ClaudiusMaximus> stj: cool
20:57:13 <hpaste> stj pasted “it's my time to show off: a ray caster (for now... will grow up into a real ray tracer)” at http://hpaste.org/68107
20:57:27 <stj> finally... it's finished ^^
20:57:57 <stj> this was a java homework, but I found the problem so cool I had to write it in haskell, too
20:58:23 <stj> I'm pleasantly surprised that the haskell version is a tiny bit faster than java version
21:10:00 * hackagebot cond 0.0.1 - Basic conditional operators with monadic variants.  http://hackage.haskell.org/package/cond-0.0.1 (AdamCurtis)
21:11:18 <kallisti> why do we have no structured representation of file paths?
21:16:46 <geekosaur> it's all messed up.  FilePath is incorrectly String even on POSIX...
21:22:31 <aavogt> but there is the filepath library so some structure isn't too difficult to access
21:34:53 <xil> yay! Solved the OpenGL stack overflow. TL;DR - motion callback also resets the mouse position; had to stop it from triggering another motion callback
21:54:36 <xil> is there a simple way to get a single number value of the current time? Something Java's currentTimeMillis() or nanoTime(), which can be found here http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/System.html#currentTimeMillis()
21:56:44 <kallisti> xil: typically I use getCurrentTime from Data.Time.Clock
21:58:53 <xil> kallisti: oh right, I remember now that I don't need to inspect the types for Time, I can just compare them like they are numbers
21:59:00 <kallisti> yes
21:59:22 <xil> kallisti: off the top of your head do you recall how to see if 2 times are more than 10 milliseconds apart?
22:00:24 <xil> is it just "t2 - t1 < 10"? or 10000? 0.01?
22:00:28 <kallisti> not quite
22:00:32 <kallisti> because UTCTime isn't a Num
22:01:01 <kallisti> diffUTCTime a b >= 0.01
22:01:10 <xil> was just about to say, haha =]
22:01:20 <xil> yeah I noticed that when I looked at the docs again
22:01:45 <xil> so 1 is 1 second then?
22:01:49 <kallisti> yes
22:01:54 <xil> thanks =D
22:02:10 <kallisti> conversion functions to NominalDiffTime treat the value as seconds
22:02:20 <kallisti> so  (0.5 :: NominalDiffTime) is half a second.
22:02:22 <bos31337> are there any people around who have admin rights on hackage.haskell.org?
22:02:41 <kallisti> bos31337: typically the best way to get in contact with them is via email.
22:03:11 <bos> kallisti: yeah, i know, was just hopeful someone might be online
22:03:15 <bos> dcoutts for instance
22:06:16 <kallisti> xil: oh, not sure if this is relevant, but to convert an existing Real to a NominalDiffTime by using realToFrac
22:06:38 <kallisti> you would need to do that if you allow a Double argument to specify the time interval.
22:06:52 <bos> kosmikus: ping
22:07:48 <xil> kallisti: oh awesome, thanks =]. In this case I'm just using it to time some OpenGL animation, just storing the time and comparing that to the next time
22:07:59 <kallisti> ah okay.
22:08:12 <xil> but very good to know
22:08:33 <xil> actually had to think for a bit to figure out how to convert between different OpenGL integral types
22:08:43 <xil> just fromIntegral, lol
22:08:49 <kallisti> usually it's just fromIntegral, yeah.
22:09:32 <kallisti> realToFrac is typically the easiest way to convert "real" / floating-point types.
22:11:54 <kallisti> the Real typeclass just has a toRational function. And the fractional typeclass has a fromRational. so... yeah
22:11:58 <kallisti> realtoFrac.
22:17:20 <nyingen> @quote
22:17:20 <lambdabot> RichardFeynman says: What I cannot create, I do not understand. (on his blackboard when he died in 1988)
22:18:18 <nyingen> @quote
22:18:18 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
22:18:21 <nyingen> @quote
22:18:21 <lambdabot> Data.Numbers.Primes says: The number 6 is a good value to pass to this function.
22:20:03 * hackagebot hecc 0.3.3 - Elliptic Curve Cryptography for Haskell  http://hackage.haskell.org/package/hecc-0.3.3 (MarcelFourne)
22:20:05 * hackagebot hF2 0.1 - F(2^e) math for cryptography  http://hackage.haskell.org/package/hF2-0.1 (MarcelFourne)
22:45:03 * hackagebot unsafe-promises 0.0.1.2 - Create pure futures using lazy IO.  http://hackage.haskell.org/package/unsafe-promises-0.0.1.2 (AdamCurtis)
22:50:04 * hackagebot unsafe-promises 0.0.1.3 - Create pure futures using lazy IO.  http://hackage.haskell.org/package/unsafe-promises-0.0.1.3 (AdamCurtis)
23:12:00 <tommd> Grrrr.
23:12:22 <tommd> I'm able to detect if particular flags are accepted by the local C compiler but seem to be unable to get cabal to use the flags.
23:12:28 <sordina1> I'm having trouble understanding how Text.ParserCombinators.Parsec.IndentParser is meant to work with blocks...
23:12:57 <tommd> Currently I'm using a preConf user hook and adjusting the BuildInfo.
23:13:23 <hpaste> sordina1 pasted “IndentParser Blocks” at http://hpaste.org/68110
23:13:26 <tommd> I assume this is not the intended path
23:57:26 <Franciman> hey people can you give me a concrete example of Category TC ?
