00:00:40 <blackdog> kallisti: what was the type synonym doing, then? anything at all?
00:00:59 <kallisti> same thing a type synonym always does.
00:03:02 <kallisti> I'm not incredibly familiar with rank-n types, but I believe your input to x wasn't polymorphic enough
00:03:03 <Veinor> blackdog: forall a. (FromJSON a) => a -> String means 'if you give me a specific value that is an instance of FromJSON, i can turn it insto a string no matter what that type is'
00:03:33 <Veinor> (forall a. (FromJSON a) => a) -> String means 'if you give me a value that has type (FromJSON a) => a, I will give you a String'
00:04:27 <hpaste> justlooks pasted “my prb” at http://hpaste.org/68217
00:06:55 <hpaste> justlooks pasted “my prb” at http://hpaste.org/68218
00:07:28 <ion> perrbeh?
00:09:32 <hpaste> justlooks pasted “my prb” at http://hpaste.org/68220
00:10:46 <blackdog> Veinor: ok, cheers.
00:10:53 <blackdog> .. can they be nested?
00:11:16 <blackdog> ie, if i want forall a & b such that both are in FromJSON ?
00:14:35 <kallisti> blackdog: usually you would just refer to them as seperate AnyJsons.
00:14:45 <Veinor> yeah, you can use AnyJSON -> AnyJSON -> String
00:27:44 <kallisti> I think the best thing about Haskell is that it forces me to be a good programmer.
00:27:47 <kallisti> even though I'm not. :P
00:30:30 <blackdog> Veinor: hm, the AnyJSON solution seems to break down later - i end up with ambiguous type variables, where i didn't if i bundled it directly into the single datatype
00:30:41 * blackdog learns that existentials are not all wine and roses
00:35:18 <Enigmagic> blackdog: what's the error?
00:35:33 <Enigmagic> if you need type equality then it won't work
00:35:55 <shachaf> blackdog: An existential "AnyJSON" sounds like the classic "existential antipattern" (but I haven't been following the conversation or anything).
00:36:50 <blackdog> Enigmagic: ambiguous type variable
00:37:17 <Enigmagic> blackdog: that's not really enough context to help :P
00:37:18 <kallisti> shachaf: eh, it's not good to automatically assume that.
00:37:29 <kallisti> I have a perfectly legitimate use for an existential on FromJSON.
00:37:42 <|Lupin|> Hello there.
00:37:43 <shachaf> kallisti: As I said, I haven't been following the conversation.
00:38:05 <kallisti> right, I'm just saying, in general.
00:38:22 <blackdog> Enigmagic: :) yeah, sorry. it's hard - my example isn't precisely the one i've showed you - i cut it down to try to make the point
00:38:24 <kallisti> but yeah if the design can be rewritten without existentials and it's better to do so, then might as well get rid of it.
00:38:39 <blackdog> kallisti: i don't think i can without inconveniencing the end user.
00:38:50 <|Lupin|> I have a cabal question, please.
00:38:56 <|Lupin|> caal update says:
00:39:04 <shachaf> Wait, an existential FromJSON?
00:39:05 <|Lupin|> Downloading the latest package list from hackage.haskell.org
00:39:05 <|Lupin|> Stack space overflow: current size 8388608 bytes.
00:39:05 <|Lupin|> Use `+RTS -Ksize -RTS' to increase it.
00:39:09 <shachaf> Isn't FromJSON like Read?
00:39:14 <blackdog> my use case is that i'd like for them to be able to call "runChannel func", where func has type Baz -> Bar -> IO ()
00:39:20 <|Lupin|> Do I really have to recompile cabal to fix this ?
00:39:31 <shachaf> |Lupin|: What version of Cabal is it?
00:39:38 <kallisti> shachaf: it's like Read if Read were wrapped in an Error monad.
00:39:41 <shachaf> |Lupin|: Also, +RTS -Ksize -RTS is a runtime option, not a compile-time option.
00:39:51 <shachaf> kallisti: Read would be universal rather than existential, wouldn't it?
00:39:53 <blackdog> Baz and Bar have fromJSON instances. i want to manage the error checking of making sure the json fits those types in a centralised place, so the client only needs to talk in their terms
00:40:16 <kallisti> shachaf: I don't understand what makes typeclasses universal or existential.
00:40:26 <|Lupin|> cabal-install version 0.14.0
00:40:27 <|Lupin|> using version 1.14.0 of the Cabal library
00:40:58 <shachaf> kallisti: Well, in the case of Show and Read, (exists a. Show a => a) ~ String, and (forall a. Read a => a) ~ String
00:41:12 <kallisti> blackdog: I don't really understand. why are they concerned about FromJSON if they already have a Baz and Bar to pass in?
00:41:27 <|Lupin|> shachaf: yeah but when I tried to pass the option it said it needed to be recompiled to support most of the options. Does the option need to be passed litterally ?
00:42:19 <shachaf> |Lupin|: Oh, then it wasn't compiled with -rtsopts, I guess?
00:42:37 <|Lupin|> shachaf: yeah, I think you're right
00:42:37 <blackdog> kallisti: they don't. it's a framework sort of setup - i'll be parsing json from the network and passing them proper datatypes
00:42:38 <shachaf> |Lupin|: Sounds like an odd bug.
00:42:51 <|Lupin|> shachaf: btw this is the debian package that has been installed, debian unstable here
00:42:55 <shachaf> |Lupin|: You should ask dcoutts or someone who knows. :-)
00:43:00 <blackdog> runChannel just gets everything started.
00:43:12 <shachaf> |Lupin|: Oh, well, you could just install your own cabal, I guess.
00:43:35 <kallisti> blackdog: okay. different question: why do you need to treat every possible instance of FromJSON as though they are the same type?
00:44:21 <|Lupin|> shachaf: okay... thanks... perhaps I can start by checking whether that problem hasn't already been reported and fixed somehow...
00:45:39 <blackdog> kallisti: because i will have many clients, all calling runChannel with different types.
00:46:28 <kallisti> wouldn't that be ToJSON then?
00:46:37 <kallisti> if the types already exist..
00:46:54 <kallisti> FromJSON takes JSON and constructs other data structures.
00:47:06 <kallisti> if the structure is already there, then you don't need FromJSON at all.
00:47:39 <blackdog> they call runChannel with a callback function, though.
00:47:57 <blackdog> runChannel gets some raw json from the network, and has to turn it into something meaningful.
00:47:58 <kallisti> ah okay.
00:48:37 <kallisti> why not just:   FromJSON a => (a -> String) -> IO () ?
00:48:45 <kallisti> or whatever.
00:50:49 <kallisti> before you had type Foo = ...
00:50:53 <kallisti> er
00:50:57 <kallisti> type Foo = forall a. ...
00:51:01 <kallisti> when I think you might have wanted something like
00:51:04 <kallisti> type Foo a = ...
00:51:19 <blackdog> kallisti: the problem is that i will have a lookup table of these things
00:51:36 <blackdog> sorry, i'm making it more complex each time :) but the version i showed is really quite cut down
00:52:13 <kallisti> well sure, internally you can have a lookup table
00:52:20 <kallisti> but then the callback function doesn't have to care.
00:52:30 <kallisti> you can extract the value from AnyJSON and pass it to the callback.
00:52:38 <blackdog> something like [("doFoo", (\foo -> dostuffwithfoo foo)), ("doBar", (\bar -> dostuffwithbar bar))]
00:52:52 <blackdog> the callback function does have to care, because that table is part of the interface.
00:53:02 <shachaf> Now this sounds like a more interesting thing than it did before. But I also need to goto sleep;
00:53:14 <kallisti> oh okay. then yeah, hide the existential via functions.
00:53:21 <blackdog> one approach could be to spin off a separate thread for each function, but that's a bigger change
00:54:04 <blackdog> kallisti: :) 'sfunny, #haskell is quite good for getting to the simplest possible solution, but you have to work quite hard to convince people that you're not just complexifying for the sake of it...
00:54:47 <kallisti> well I wouldn't want to be suggesting horrible ideas on the basis of limited information.
00:54:59 <blackdog> quite right, too.
00:55:17 <blackdog> i well remember my early days with ocaml
00:55:43 <blackdog> subtype this, subtype that, ignoree the well-meaning people gently suggesting that i probably just needed a plain old data type...
00:56:02 <blackdog> if only we could stay young programmers for ever. i'm sure i used to know everything.
00:56:02 <kallisti> my use case for an existential is a bit simpler
00:56:23 <Enigmagic> blackdog: if you can split the type lookup and the parsing logic into two (which i think is possible, since the key name is being passed in to go) you can use proxy types instead of existentials
00:56:33 <Enigmagic> blackdog: like so : https://gist.github.com/2633184
00:56:49 <blackdog> Enigmagic: i've got to head off now, but i'll look at your code on the train...
00:56:51 <blackdog> cheers!
01:04:15 <MichaelBurge> Is there a compiler extension to automatically add setter functions to records, in addition to the getters?
01:04:47 <Enigmagic> no, but there are packages that do something similar. take a look at fclabels and data-lens
01:06:06 <MichaelBurge> Thanks Enigmagic - I might use those
01:06:34 <Enigmagic> np
01:06:55 <Peaker> MichaelBurge, https://github.com/Peaker/bottle/blob/master/bottlelib/Data/AtFieldTH.hs  allows polymorphic field updates (if the field type can change on its own)
01:07:07 <Peaker> fclabels/data-lens do not support polymorphic updates at all
01:08:31 <Peaker> data T a = T { f :: a } ; Data.AtFieldTH.make ''MyType   creates:   "atF :: (a -> b) -> T a -> T b"
01:08:36 <Peaker> oops
01:08:38 <Peaker> make ''T
01:13:45 <MichaelBurge> Peaker: Is there a Haddock package for that, or better documentation?
01:14:20 * hackagebot html-conduit 0.0.1 - Parse HTML documents using xml-conduit datatypes.  http://hackage.haskell.org/package/html-conduit-0.0.1 (MichaelSnoyman)
01:23:40 <womb> Hi guys :)
01:23:48 <Svarg> hi
01:24:13 <womb> finally after weekend i can say haskell is not hard :). It's easy i just now need to learn how to layout programs haskell style ;]
01:24:22 <womb> i feel like a winner even with this flu
01:30:02 <yitz> womb: \o/
01:39:30 <womb> yitz: \\o
01:54:22 * hackagebot bzlib-conduit 0.1.0.1 - Streaming compression/decompression via conduits.  http://hackage.haskell.org/package/bzlib-conduit-0.1.0.1 (HideyukiTanaka)
01:55:07 <merijn> Any recommended paper on conduits and how they compare to iteratees?
01:56:19 <solrize> the only thing like that afaik is written by michael
01:56:42 <solrize> but he had a pretty good blog post
01:57:24 <womb> cabal install warp
01:59:22 <solrize> http://www.yesodweb.com/blog/2012/01/conduit-versus-enumerator
01:59:39 <merijn> solrize: Thanks
02:05:47 <solrize> np
02:06:42 <augur> any interesting ways of implementing continuations i can read about?
02:08:40 <Svarg> augur: what do you mean by implementing continuations?
02:09:29 <augur> Svarg: well, you could imagine two ways of implementing continuations in a programming language -- continuize the semantics, so that everything is always, from the bottom up, inside the continuation monad, or something of that sort
02:09:53 <augur> or alternatively, by doing CPS transformations before interpretation, and then just running a normal interpreter on that
02:10:08 <augur> so im wondering if there are other ways of implementing a language with continuations
02:11:27 <Svarg> hmm.. well that about covers it
02:11:59 <Svarg> i would think all other approaches would be variations on those 2 themes
02:12:38 <augur> mayhaps mayhaps!
02:12:59 <augur> or, if anyone knows, is there a nice way to relate syntactic CPS-transforms to semantic continuzation?
02:14:34 <Svarg> what do you mean by "syntactic cps-transforms to semantic continuization"?
02:15:51 <augur> er
02:15:56 <augur> well
02:16:13 <augur> syntactic CPS-transforms are syntactic -- they're operations on terms in the object language
02:17:18 <augur> whereas a semantic continuization is a way of giving already-continuized semantics to things prior to evaluation, in some sense
02:17:33 <serafima_> hello
02:17:37 <augur> and then composing things under the continuation-appropriate notions of these things
02:17:49 <serafima_> does anyone here know if there's people active in the russian channel of haskell?
02:17:49 <Svarg> hi
02:18:08 <Svarg> don't know
02:18:48 <Svarg> augur: interesting
02:21:31 <merijn> gah
02:21:41 <merijn> round rounds 2.5 down to 2? >.<
02:23:06 <Svarg> merijn: "round x returns the nearest integer to x; the even integer if x is equidistant between two integers"
02:23:36 <merijn> Svarg: Yes, but that is different from "normal" rounding as employed by mere humans
02:24:13 <merijn> Or at least different from how any school here teaches it (which is essentially .5 rounding up and everything smaller rounding down
02:24:23 <Svarg> it's not uncommon - even has a name - though i can't remember it.. banker's rounding? or something like that
02:24:50 <merijn> I've never in my life encountered that way of rounding
02:24:51 <Svarg> though yes it is a bit unusual
02:25:08 <Svarg> http://en.wikipedia.org/wiki/Rounding#Round_half_to_even
02:25:09 <merijn> Certainly not what you want the default round implementation to do, imo
02:25:49 <merijn> Now I need to implement my own division and/or round :\
02:30:55 <womb> guys i have a question about multicore support in ghc 74.
02:30:57 <womb> 7.4
02:31:18 <womb> i compiled simple warp source code and runned it
02:31:28 <womb> it shows in monitor that he is using 1 thread
02:31:31 <Svarg> why is there no unfoldM anywhere in the standard libs?
02:31:33 <womb> and results are nice 10k req/sec
02:31:51 <womb> but he is using 1 thread why not 2 or 4 or something different ?
02:32:11 <Svarg> womb: did you compile with -threaded?
02:32:18 <womb> did i not switched on something for support on multithread
02:32:24 <womb> let me recompile with -treaded
02:33:29 <womb> Svarg: ok, thanks now i have 3 threads
02:33:33 <Svarg> np
02:33:36 <womb> why he is not doing this by default ?
02:33:40 <Svarg> not sure
02:33:49 <merijn> @pl \(val,rem) -> (val,val+rem)
02:33:50 <lambdabot> uncurry (liftM2 (.) (,) (+))
02:33:57 <womb> i wanna see differenc ebetween 1 core and 2 core
02:34:02 <merijn> hmm, that probably doesn't help :p
02:34:20 <Svarg> womb: you can control the number of os threads your code uses
02:34:29 <Svarg> +RTS -N<number of threads>
02:35:00 <Svarg> but with recent versions of ghc, you have to pass an extra flag at compile time to enable +RTS
02:35:05 <womb> when i type +RTS he says it is deprecated
02:35:18 <Svarg> oh? does it suggest an alternative?
02:35:41 <womb> wow i got performance drop on N4 compared to N1
02:35:45 <womb> 3k drop in performance
02:36:02 <womb> let me try N2
02:36:58 <womb> i'm testing it against 1 mln requests
02:38:18 <womb> good thing is memory usage 7.2 mb
02:38:24 <womb> aweosme less then erlang
02:39:08 <womb> ok let me try now +RTS -N2
02:39:30 <womb> i'm on 7k with 3 threads, 10k on 1 thread and now let me see on N2
02:39:56 <Enigmagic> womb: you'll also want to fiddle around with -A and -gq1 (or -qg1, i can't remember what the right order is).
02:39:57 <womb> maybe context switching is massive bollocks
02:40:08 <Enigmagic> try -A2m or -A5m and -gq1
02:40:14 <flux> womb, use 'time' to determine how much cpu% it uses?
02:40:20 <flux> (ie. does it use >100%)
02:40:22 <Svarg> womb: in what sense?
02:40:26 <womb> i will, i just think i have brain tumor when i see perofmrance drop using many cores
02:40:30 <Enigmagic> -qg1 disables parallel collections on gen0
02:41:02 <womb> cpu is always 100%
02:41:18 <womb> thats why i thought 2 cores = more performance
02:41:23 <womb> i was naive ;]
02:41:42 <Saizan> or maybe your code needs some improvement
02:41:50 <quicksilver> maybe it's not actually doing enough on each request for it to be worth having more than one thread
02:41:55 <Svarg> yeah
02:42:05 <womb> context switching could be problem here
02:42:08 <quicksilver> if the code is basically just accepting sockets as fast as it can, writing and closing them
02:42:14 <quicksilver> then it might as well be single-threaded.
02:42:36 <quicksilver> if it actually does, say, 50ms of work per request - then it would benefit massively from multithreading.
02:43:16 <womb> N2 = 4k
02:44:23 * hackagebot tagstream-conduit 0.3.2 - streamlined html tag parser  http://hackage.haskell.org/package/tagstream-conduit-0.3.2 (YiHuang)
02:48:26 <t7> cmon haskell platform...
02:48:36 <t7> new release plox
02:51:03 <t7> doest mconcat with [] break the identity axiom?
02:51:11 <t7> (of Monoid)
02:51:32 <Saizan> no, why?
02:53:09 <t7> for all elements a in S, the equation e • a = a • e = a
02:53:56 <t7> so 1 :  [1,2,3]   should equal [1,2,3] ?
02:54:47 <Liskni_si> [] ++ [1,2,3] should equal [1,2,3] ++ []
02:56:41 <Saizan> and both should be equal to [1,2,3]
02:57:17 <t7> oh ignore me
02:58:55 <Saizan> note btw that mconcat (xs ++ ys) = mconcat xs `mappend` mconcat ys and moncat [] = mempty, so mconcat is a monoid homomorphism
03:00:30 <frontendloader> http://www.haskell.org/haskellwiki/Prime_numbers#Calculating_Primes_in_a_Given_Range this snippet won't compile for me. http://bpaste.net/show/qDWOi4oP4hOt22HKNofY/
03:01:34 <frontendloader> also vim's auto-formatting for haskell leaves a lot to be desired, but that's a vim problem
03:03:07 <womb> ok i'm retesting it after i compiled it with no parallel support
03:03:20 <t7> frontendloader: i use this cool vim script
03:03:36 <t7> that changes alot of common operators to their unicode symbols
03:03:49 <womb> ye, one thread ~11k req / sec
03:04:04 <womb> damn how to find a test that will show something more
03:04:15 <t7> i bet i can get faster in C
03:04:17 <womb> because if i will add redis i will be benchmarking more db then haskell
03:04:19 <frontendloader> I'd just like something that can handle indenting
03:05:14 <Peaker> MichaelBurge, Feel free to make one :)
03:06:29 <Svarg> frontendloader: are you using any custom scripts for intending? or any options?
03:07:01 <frontendloader> tabstop=2, shiftwidth=2, cindent, expandtab, autoindent
03:07:26 <Svarg> frontendloader: yuck tabstop=2 - but anyway, try adding smartindent
03:08:12 <Svarg> oh.. and getting rid of cindent maybe
03:08:49 <frontendloader> still mangles everything :(
03:08:57 <Svarg> frontendloader: also when changing shiftwidth, change softtabstop too
03:09:22 <Svarg> can't remember how the two are related exactly.. but you get some weird stuff happening if they're not in sync from memory
03:10:06 <Svarg> what exactly does it mangle out of curiosity?
03:12:07 <womb> haha +RTS  gives 12k req/sec on 1 thread
03:12:08 <womb> kill me
03:12:17 <womb> i will have to spend todays evening checking this
03:12:31 <Svarg> +RTS by itself does nothing
03:12:39 <mm_freak_> is there a difference between "g machine" and "spineless tagless g machine"?
03:12:49 <Svarg> mm_freak_: yes
03:12:55 <mm_freak_> aren't g machines inherently spineless?
03:13:09 <frontendloader> https://gist.github.com/102eb9bcc0ba06975608 theres a before and after of some copy/pasted haskell
03:13:36 <Svarg> don't know, can't remember the details but i am pretty sure there is a difference between the two
03:13:57 <t7> maybe, but tagless ?
03:14:04 <womb> Svarg: i had to rebuild and relink with -rtsopts and run with +RTS -sstderr
03:14:13 <womb> and i started to have better results
03:15:25 <frontendloader> there's a syntax error in there, let r should be just r =
03:15:51 <felix_> hi
03:16:08 <womb> \o
03:16:12 <Svarg> frontendloader: the code you pasted must have used tabs for vim to reindent it like that
03:16:16 <felix_> is there a way to get in constant time any element of a Map from Data.Map?
03:16:50 <frontendloader> I set it to use 4 width because someone said ew at 2 width
03:16:57 <Svarg> i did :P
03:17:06 <merijn> felix_: No, Map's are O(log n), if you have Int keys then you can use IntMap which is O(min(n,W)) (where W is the width of a machine word)
03:17:22 <felix_> no I mean I really don't care which one I get
03:17:32 <felix_> i just want a "random" element from my map
03:17:45 <merijn> I don't think so? But why do you want that?
03:17:46 <felix_> (I'm trying to implement Prim's algorithm)
03:18:03 <felix_> so I can start with any vertex
03:19:03 <Svarg> frontendloader: if the code uses spaces to begin with, then what you copy and paste into vim will look the same - if it uses tabs, then it will be affected by whatever tab settings you have set up (it will just convert those tabs to spaces since you have expandtab set - which is good)
03:19:27 <Svarg> tabs are evil
03:19:30 <merijn> felix_: Convert to list and take the head?
03:19:56 <felix_> yes I think I'll have to do that, but well
03:19:58 <frontendloader> I hand-formatted it to use spaces
03:20:03 <felix_> that won't be in constant time I guess
03:20:12 <merijn> felix_: Might be close to
03:20:22 <Svarg> frontendloader: it would already be using spaces - problem is the tab character in the clipboard buffer
03:20:24 <merijn> felix_: Don't forget list generation is lazy
03:20:35 <felix_> oh
03:20:35 <merijn> It'll only generate the first element if that's all you use
03:20:37 <felix_> yes
03:20:40 <felix_> that's nice
03:20:42 <felix_> thanks!
03:20:54 <frontendloader> there are no tab characters in the before gist afaik
03:21:01 <merijn> So should most likely be very close to constant
03:21:16 <int-e> mm_freak_: As far as I can see, the original G machine had application nodes (taking two expressions, a function and its argument). The spineless version flattens this structure and puts it into a flat stack, and  partial application nodes on the heap when needed. The tagless aspect is just the idea of providing a code pointer rather than a tag in each node, and to rely on well-typedness to ensure that this does not cause...
03:21:22 <int-e> ...any trouble.
03:21:39 <frontendloader> the problem is it shooting that do block way off to the right on line 14
03:22:17 <felix_> I think I'll try to write a patch proposing a function doing what I want
03:22:21 <int-e> mm_freak_: and then there's a lot of trickery to combine the code and data stacks that you have on the abstract level into a single stack.
03:22:22 <felix_> because it's trivial to write
03:22:30 <Svarg> oops - i read the before and after the wrong way around - assumed 'before' was at the top
03:22:31 <felix_> and that can be useful, I guess
03:22:42 <Svarg> hmm very strange.. you must have some extra indenting settings swtiched on
03:23:06 <int-e> mm_freak_: err, control stack, not code stack.
03:23:57 <Svarg> frontendloader: i can send you my .vimrc and .gvimrc if that helps
03:24:03 <frontendloader> sure why not
03:26:16 <Svarg> oops - sent to the wrong person
03:26:18 <Svarg> heh
03:26:25 <frontendloader> can you just raw gist it or something?
03:26:52 <frontendloader> the computer I'm ircing on isn't the same as the one I'm editing on
03:26:56 <Svarg> aah np
03:30:15 <Svarg> frontendloader: i've pasted my .vimrc in pm so i don't spam in here
03:30:24 <frontendloader> yea I heard
03:31:13 <mm_freak_> int-e: i see, thanks
03:31:43 <rexamophone> hi peeps
03:31:56 <rexamophone> i'm learning haskell in preparation for a class
03:32:08 <rexamophone> i'm trying to do one of the exercises and i'm stuck
03:32:28 <rexamophone> **not looking for an answer** but i was hoping someone could give me a hint?
03:32:55 <rexamophone> i have to implement: append :: List a -> List a -> List a
03:33:12 <t7> what have you got so far?
03:33:17 <rexamophone> firstly using recursion, i'm trying this:
03:33:17 <rexamophone> append _ Nil = Nil
03:33:17 <rexamophone> append x (y:|ys) = x :| y :| append x ys
03:33:49 <mux> mmm, this is quite wrong
03:34:09 <rexamophone> (some of the types used in the course notes differ from base types in prelude, but it should be enough to understand whats going on)
03:34:17 <mux> the first line says that if I try to append an empty list to any other list, then I get an empty list
03:34:21 <rexamophone> @mux: you mean my approach?
03:34:22 <lambdabot> Unknown command, try @list
03:34:31 <mux> do you see how that doesn't make sense?
03:35:05 <rexamophone> ...not really...
03:35:09 <Svarg> mux: not sure that is helping if he's saying he's stuck on this
03:35:25 <mux> you're saying that, for instance, [1,2,3] ++ [] = []
03:35:30 <rexamophone> if the function is calling itself, at some point h:t would call append with an empty list, right?
03:35:49 <mux> do you see now?
03:35:50 <ski> at some point it'd call itself with an empty list, yes
03:35:51 <rexamophone> yes - isn't that the termination for the recursion?
03:36:06 <mux> think in terms of semantics of append
03:36:09 <ski> yes -- the problem is what you *return* in the base case
03:36:10 <t7> it certainly terminates the recursion
03:36:20 <mux> if I do [1,2,3] ++ [], I expect to get [1,2,3]
03:36:37 <rexamophone> oh wait
03:36:42 <rexamophone> right i get you...
03:36:52 <rexamophone> i havent reached that problem, (yet) i guess
03:37:06 <rexamophone> append x Nil = x
03:37:10 * mux nods
03:37:22 <rexamophone> cheers....
03:37:28 <mux> (most people would call the first parameter xs but that's just nitpicking)
03:37:34 <rexamophone> either way, ghci chokes on the second statement :D
03:37:37 <mux> now, you have problems with the second equation as well
03:37:38 <mux> yes
03:37:59 <ski> `:|' wants a list element as left argument
03:38:07 <ski> in `x :| ...', `x' is a list, not a list element
03:38:15 <mux> do you understand that (y:|ys) only matches a non-empty list ?
03:38:39 * ski would suggest scrapping that clause, and starting over again with it
03:38:52 <rexamophone> @ ski - i've kinda worked that out, but im not sure how to compose the function recursively with x cons head
03:39:12 <mux> maybe you should try to get the semantics right first, and then worry about termination
03:39:20 <rexamophone> okay....i can scrap it, but i'm still lost where to start....
03:39:56 <ski> rexamophone : s/@ ski -/ski :/
03:39:58 <rexamophone> sure...i found it easier to start with the termination of the recusive function first, and try to work back
03:40:26 <mux> I guess that depends on what you think is easiest
03:40:54 <rexamophone> right now i'm grappling at straws, so yeah any advice appreciated :)
03:40:58 <ski> hm -- i suppose this is all backwars, in some sense
03:41:15 <ski> rexamophone : i think you should consider pattern-matching on the *other* argument
03:41:49 <t7> someone should invent an algebraic structure called a Mongoloid
03:42:07 <mux> I suppose I would concentrate on the semantics first, especially in that case where they're easily understood, and then, termination/recursion should just fall into place
03:42:17 <mux> but people have different approaches, of course
03:44:02 <merijn> Using guard in IO will cause the remaining lines of a do block to only execute if the guard is true, right?
03:44:36 <Saizan> yes, you get an exception otherwise
03:45:18 <merijn> Oh, hmm. That's not what I want then
03:45:29 <mux> I guess you want when
03:46:23 <merijn> mux: Yeah, but that means indenting the rest of the block, which is what I wanted to avoid
03:46:36 <mux> merijn: or have another sub-function to avoid that
03:46:44 <merijn> yeah
03:46:51 <merijn> I'll figure something out
03:47:23 <Svarg> rexamophone: still stuck?
03:47:32 <rexamophone> you bet
03:47:40 <mux> rexamophone: what do you have now ?
03:47:40 <rexamophone> i'm looking at vim glazed over
03:47:59 <rexamophone> nothing really different
03:48:07 <rexamophone> changed the terms for h:t
03:48:10 <rexamophone> append (x:|xs) y = x :| append xs y :| xs
03:48:10 <Svarg> think about what ski said about pattern matching on the 2nd argument instead of the 1st one
03:48:56 <rexamophone> i thought ski said match on the first one? i was matching on the 2nd one (i thought)?
03:49:41 <Svarg> oh woops - brain not working
03:49:48 <rexamophone> i understand why the compiler has a problem with what ive done
03:50:03 <rexamophone> it's expecting 'a' for the head of the second cons, but im giving it a list
03:50:12 <rexamophone> List a, rather
03:50:25 <rexamophone> but i cant make the cognitive leap to what i need to do on that
03:51:08 <Saizan> (:|) :: a -> List a -> List a, right?
03:51:30 <merijn> rexamophone: So, the question to solve is then: How do we get an element from a list?
03:51:48 <Saizan> he already has an element out of the list: x
03:51:53 <Pitel> http://pastebin.com/BYrMnbU0 can you gus help me with this? It should do naive (without any checks if variables are free) substitution in lambda expression (using custom data class) [noob question]
03:51:55 <mauke> The paste BYrMnbU0 has been copied to http://hpaste.org/68223
03:52:09 <Saizan> rexamophone: why did you put .. :| xs at the end?
03:53:08 <rexamophone> you know looking at it again, i dont know why...
03:53:12 <rexamophone> it shouldnt be there
03:53:17 <Saizan> right :)
03:53:21 <rexamophone> the recursive function already takes ys
03:53:32 <Svarg> alright.. well there is more than one way to solve the problem - don't have to be concerned with efficiency just yet.. you can pattern match on either really - if you pattern match on the first argument, then you'll have to get to the end to add elements to the front of the 2nd one 1 by 1 - if you pattern match on the 2nd argument, you'll have to append them one by one to the end of the first
03:53:52 <Saizan> Pitel: the type error is because you lack LVar constructors around v' and var in line 8
03:54:16 <merijn> Pitel: What type is doSubst?
03:54:51 <merijn> Saizan: You ruined my socratic questioning mojo :(
03:55:06 <Pitel> merijn: Lambda a -> Lambda a (imho)
03:55:11 <Saizan> merijn: i consider that trolling :)
03:55:12 <rexamophone> svarg: i re-read that 3 times.....
03:55:30 <merijn> Pitel: And what types are v and v'?
03:55:33 <rexamophone> and i'm certain i dont get it
03:55:39 <Svarg> rexamophone: start with some example strings on a piece of paper
03:55:46 <t7> mm_freak_: hows your calculus coming along?
03:55:56 <Saizan> Svarg: he's already got one implementation, though
03:55:57 <rexamophone> let me step through it in my head
03:56:01 <Svarg> oh
03:56:08 <merijn> Pitel: And after answering that question, reexamine the first line of doSubst :)
03:56:11 <Svarg> didn't realize
03:56:26 <rexamophone> well after this, i need to implement the same thing using folds
03:56:31 <mm_freak_> t7: i'm working on an intermediate language now, so that i can compile it to machine code
03:56:56 <Saizan> rexamophone: so, you got to append (x :| xs) ys = x :| append xs ys; now you only need an equation for the append Nil ys case
03:57:06 <mm_freak_> the first version will be a simple graph reducer based on template instantiation, but i'm going to turn this into a full-featured STG machine
03:57:16 <mm_freak_> and it will be a library, so other people can use it, too
03:57:17 <t7> i thought it was fairly low level anyway? how are you gonna distil it even more?
03:57:43 <Pitel> merijn: ok... I guessed haskell should "know" they are LVar, and therefore I won't need to specify it.
03:58:05 <rexamophone> saizon: thats the recursion terminating case, right? i've got that
03:58:07 <merijn> Pitel: No, the pattern matching strips of the constructors (and therefore also the type)
03:58:20 <mm_freak_> t7: the lower level language doesn't have a high level type system and is supposed to be portable
03:58:30 <merijn> Pitel: If (LVar v) :: Lambda a, then v :: a
03:58:31 <Saizan> rexamophone: and how does it look?
03:58:40 <mm_freak_> t7: it's also not a lambda calculus, but really a graph of imperative programs
03:58:42 <rexamophone> append :: List a -> List a -> List a
03:58:42 <rexamophone> append Nil ys = ys
03:58:42 <rexamophone> append (x:|xs) ys = x :| append xs ys
03:58:43 <t7> ah so like an untyped lambda calc?
03:58:55 <Saizan> rexamophone: ah ok, fine then :)
03:58:55 <t7> ah :|
03:58:58 <rexamophone> that works :)
03:58:58 <mm_freak_> a high level assembly language if you will =)
03:59:15 <t7> cool, i look forward to seeing the source
03:59:39 <t7> im still trying to get constraint based Hindley milner to work ...
04:00:10 <mm_freak_> t7: it should be designed specifically to compile functional languages to…  it will do graph reduction and garbage collection, but nothing more
04:00:48 <merijn> Pitel: If you want to pattern match AND reuse the same value you can use an alias (but it's probably useless in this example) by using "doSubst e lv@(LVar v) lv'@(LVar v')", here lv is a name for (LVar v) (and thus has type Lambda a), while v is still type a
04:01:24 <rexamophone> Svarg: what you were saying earler about efficiency - you meant that matching on the first argument (ie: the way it's now done) is more efficient than matching on the second argument (ie: the way i was originally doing it)?
04:01:35 <mm_freak_> also the core language isn't as low level as i originally intended…  basically the high level language is just a layouted version with lots of syntactic sugar
04:06:13 <rexamophone> i suspect i got this right, but would like someone to just double check for me, please?
04:06:17 <rexamophone> append xs ys = foldRight (\x acc -> x :| acc ) ys xs
04:08:04 <Saizan> rexamophone: yup, that's right
04:08:19 <Svarg> rexamophone: matching has nothing to do with it - the way you've solved it is efficient, at least in a lazy language - if you were appending things to the end of the first argument instead, hmm.. actually in ghc that would still be ok - in a strict language it would be worse - and in a strict language neither solution would be optimal, first one would waste stack space, 2nd one would traverse the first argument over and over again
04:08:52 <rexamophone> ah ok
04:09:33 <Saizan> even in haskell (and GHC) appending at the end would end up retraversing the list more than needed
04:10:10 <Saizan> assuming there's any forcing of the result
04:11:46 <rexamophone> now getting that fold into point-free form....
04:12:01 <Svarg> ah yeah, it would too
04:12:11 <rexamophone> i know there's something i can do to drop the acc's but i dont quite understand
04:12:31 <rexamophone> what's the concept called? (so i can read it up further)
04:12:54 <Svarg> which concept?
04:13:04 <rexamophone> it's a partial application, bu i dont quite follow why the acc can be dropped off the lamba
04:13:09 <rexamophone> ^lambda
04:13:32 <Saizan> first write it in prefix form
04:13:39 <rexamophone> Svarg: essentially the steps to go from what i had to pf form
04:13:43 <Saizan> (\x acc -> (:|) x acc)
04:14:07 <t7> thats getting dangerously close to a smiley
04:14:15 <bitonic> mhm, I'm using conduits for the first time, would this be the correct way to "drain" a Source: `drain = C.await >>= maybe (return []) (\bs -> (bs :) <$> drain)'? It feels strange that there  isn't a function to do that already
04:14:26 <Saizan> then you should be able to eta-contract
04:14:32 <bitonic> t7: it's the unimpressed monkey
04:15:21 <Svarg> rexamophone: \x acc -> x :| acc is the same as \x acc -> (:|) x acc
04:15:26 <Svarg> does that help?
04:15:45 <rexamophone> yeah...
04:15:55 <Svarg> ooh oops
04:15:57 <rexamophone> that should have been obvious to me :(
04:16:01 <Svarg> didn't see Saizan already wrote that..
04:16:14 <rexamophone> soon as you guys said infix, i saw it....
04:17:23 <ski> rexamophone : re `append (x:|xs) y = x :| append xs y :| xs' -- you should think twice before using a variable name twice, such as `xs' here
04:17:25 <lamefun2> haskell is magical! and saint!
04:17:52 <hpaste> lamefun pasted “Magicalness and saintness of Haskell” at http://hpaste.org/68224
04:17:58 <rexamophone> ski: go on?
04:18:38 <Saizan> lamefun2: *Disjunction
04:18:45 <ski> rexamophone : using a variable name more (or less) than once, when you conceptually want to use it once often indicates some wrong-thinking
04:18:52 <lamefun2> I can't imagine what crazy class hierarchy I'd have to employ to do this
04:19:10 <ski> rexamophone : anyway, i take it you fixed your recursive definition of `append' now
04:19:30 <rexamophone> the recursive one? yes
04:19:42 <t7> how does haskell infer rank n polymorphism
04:19:53 <ski> rexamophone : btw, do you see how `append' recursively evaluates there ?
04:19:53 <bitonic> t7: it doesn't
04:19:56 <rexamophone> ski: Svarg suggested swapping the parameters i'm matching on
04:20:02 * ski nods
04:20:08 <bitonic> t7: inference for higher ranked types in undecidable
04:20:10 <ski> (i said something to that effect, as well)
04:20:20 <bitonic> t7: Rank 2 might be decidable, can't remember.
04:20:22 <rexamophone> ski: in all honesty, the foldR made more sense to me....i wrote that off the bat without any trouble
04:20:34 <ski> rexamophone : consider
04:20:41 <bitonic> t7: or decidable under certain assumptions (e.g. choose the lower ranked type when possible)
04:20:49 <rexamophone> ski: i ran through the eval in my head tho, and worked it out
04:21:03 <rexamophone> ski: consider?
04:21:04 <ski>      append (0 :| 1 :| 2 :| Nil) (3 :| 4 :| Nil)
04:21:15 <ski>   =  0 :| append (1 :| 2 :| Nil) (3 :| 4 :| Nil)
04:21:22 <ski>   =  0 :| 1 :| append (2 :| Nil) (3 :| 4 :| Nil)
04:21:33 <ski>   =  0 :| 1 :| 2 :| append Nil (3 :| 4 :| Nil)
04:21:39 <ski>   =  0 :| 1 :| 2 :| 3 :| 4 :| Nil
04:21:41 <Svarg> ski: actually you suggested that, then i mixed up what had been said to that point and confused him i think heh
04:22:08 <rexamophone> yup :)
04:22:18 <mm_freak_> t7: what about your language?  do you already have a parser?
04:22:19 <ski> rexamophone : sometimes, writing out "traces" like this can help you understand what is going on in a recursion
04:22:20 <lamefun2> also , I have data X = X1 T1 | X2 T2 how to make a function or field in another data that only accepts X2?
04:22:44 <ski> rexamophone : exercise, write a similar trace for your `foldRight'-based definition of `append'
04:23:24 <ski> Svarg : *nod* i suspected so :P
04:23:25 <t7> mm_freak_: nah im working on making the type erros a bit easier to read
04:23:36 <t7> and then i need mutual recursion
04:23:43 <lamefun2> I have data Value = Constant Float | Pointer Integer
04:23:45 <lamefun2> and instructions
04:23:59 <lamefun2> data Instruction = Mov Value Value | Add Value Value and so on
04:24:00 <mm_freak_> t7: do you indend your language to be parsed at all?
04:24:09 <t7> yeah
04:24:20 <Saizan> lamefun2: you can't, you could just use T2 instead though
04:24:24 <lamefun2> but for mov, second argument can't be constant as that makes no sense
04:24:25 <t7> its gonna be a staticly typed language that compiles to javascript
04:24:34 <t7> with all the javascript Objects built in
04:24:47 <ski> lamefun2 : just style, but i would put the `|' on the start of the lines, instead of at the end
04:24:48 <rexamophone> working it offline
04:24:51 <rexamophone> brb
04:25:18 <mm_freak_> t7: my approach was to add a source code position argument to every constructor…  by that alone i have GHC quality error messages minus its ability to present inference stacks (because there is no inference right now)
04:25:27 <ski> lamefun2 : anyway, what's so magical about that ?
04:25:35 <mm_freak_> t7: btw, my first target will be javascript as well =)
04:25:52 <lamefun2> ski: Do you imagine what  I'd have to write to make the same condition datastructure in C++ O_o?
04:25:59 <t7> mm_freak_: same, but im using algorithm W to infer types at the moment and its not great
04:26:14 <ski> lamefun2 : i'd prefer not to
04:26:35 <mm_freak_> t7: i'm going for value inference (my language is dependently typed) with a custom strategy similar to agda
04:27:03 <mm_freak_> the goal is to let the compiler write the code where possible
04:27:46 <ski> lamefun2 : i suspect you're thinking about an abstract class, with subclasses -- i might prefer a discriminated union
04:29:26 <lamefun2> I'm thinking about weakened discriminated unions
04:29:48 <osfameron> much like Thatcher
04:29:52 <lamefun2> type JustPointer = Pointer from Data
04:29:59 <t7> mm_freak_: are you gonna use _ for a placeholder or something? or implicit args like agda?
04:30:19 <ski> (placeholder ?)
04:30:21 <mm_freak_> having dependent sums suffices for existential types, right?  X -> (A : Set, A)
04:30:45 <mm_freak_> t7: _ will be an unnamed variable…  ? will be an inferred value
04:30:47 <ski> lamefun2 : hm, not sure what you mean
04:30:51 <t7> ski: in coq you can put _ and it attempts to infer it
04:31:03 <ski> ok
04:31:04 <Svarg> mm_freak_: what exactly does agda do for type inference? do you have a link to any papers?
04:31:27 <lamefun2> well  data X = X1 ... | X2 ... | X3 ...     type JustX1andX2 = X1, X2 from Data
04:31:50 <ski> lamefun2 : you're talking about refinement types ?
04:32:07 <mm_freak_> Svarg: as far as i know it does something similar to basic type inference, but across levels
04:32:10 <ski> (which is a way to creat subtypes)
04:32:18 <lamefun2> ski: what's that?
04:32:43 <Svarg> mm_freak_: is there a paper somewhere?
04:33:08 <mm_freak_> Svarg: the agda wiki is a good place to start…  it should link to all relevant material
04:33:28 <Svarg> i've been playing with lambda calculi with explicit substitution and higher-order unification a bit but didn't get around to trying to extend them with dependent types… and i'm kind of worried it would all fall apart with dependent types thrown into the mix..
04:33:37 <ski> lamefun2 : as a lame example, say that we have `data Nat = Zero | Succ Nat', then `data Even :< Nat = Zero | Succ Odd' and `data Odd :< Nat = Succ Even' would be examples of refinement types
04:33:42 <Svarg> gah… agda wiki..
04:33:44 <mm_freak_> Svarg: it will
04:34:00 <ski> lamefun2 : of course, Haskell doesn't have refinement types, so this is all imagined syntax
04:34:09 <lamefun2> ...
04:34:37 <ski> lamefun2 : but it sounded like you wanted a restricted/refined variant of a type, where some constructors were disallowed
04:34:46 <lamefun2> ye
04:34:49 <lamefun2> s
04:34:50 <Svarg> mm_freak_: do you mean it will fall apart? as in it won't work?
04:35:02 <Svarg> mm_freak_: for sure?
04:35:03 <mm_freak_> Svarg: it will work, but it has the potential to fall apart
04:35:23 <mm_freak_> Svarg: even basic type checking involves evaluating arbitrary expressions
04:35:39 <t7> @hoogle timeout
04:35:39 <lambdabot> System.Timeout module System.Timeout
04:35:40 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
04:35:40 <lambdabot> System.Event type TimeoutCallback = IO ()
04:35:42 <ski> mm_freak_ : and evaluating under binders too, iiuc
04:35:42 <Svarg> mm_freak_: yes i'm aware of that
04:36:26 <mm_freak_> Svarg: well, i consider a potentially nonterminating compiler "potentially falling apart"
04:36:27 <Svarg> mm_freak_: i'm more worried about the various rules breaking with dependent types added in… i've mostly been looking at lambda-ws
04:36:38 <mm_freak_> of course it depends on your language…  the agda compiler should always terminate
04:36:39 <ski> lamefun2 : in some cases, one can sensibly "factor" the type in Haskell ..
04:37:23 <Svarg> mm_freak_: i never said anything about non-terminating
04:37:36 <mm_freak_> Svarg: as far as i've seen in a dependent lambda calculus that doesn't use dependent types you can fully infer types…  so at least you don't lose power
04:38:26 <Svarg> what do you mean by dependent lambda calculus without dependent types?
04:38:39 <Svarg> or that doesn't use dependent types rather?
04:39:12 <mm_freak_> Svarg: let me rephrase:  in a dependently typed lambda calculus, you can infer types, as long as you don't use dependent types
04:39:58 <Svarg> sure
04:40:00 <t7> lol
04:40:29 <t7> simply typed lambda calculus then
04:40:42 <mm_freak_> polymorphic rather
04:40:52 <RichyB> mm_freak_, so you can still infer the subset in which you happen not to use the high-firepower type system features. :)
04:40:59 <t7> you cant infer type variables
04:41:00 <mm_freak_> yeah =)
04:41:04 <t7> well completely
04:41:28 <t7> see system f
04:41:41 <lamefun2> ski: what to do then?
04:41:47 <mm_freak_> t7: you infer types on application
04:42:23 <t7> mm_freak_: is that decidable ?
04:42:52 <mm_freak_> t7: sure
04:43:13 <mm_freak_> t7: but i think a necessary property is that type application is implicit like in haskell
04:43:38 <mm_freak_> i.e. "forall" always describes an implicit argument
04:44:05 <t7> and all foralls are at the start of the term?
04:44:07 <t7> like HM
04:44:16 <mm_freak_> yeah
04:44:30 <mm_freak_> well, they can come later, but that's equivalent for implicit application
04:44:43 <mm_freak_> they just may not be higher rank
04:45:17 <t7> are you gonna restrict that in your language?
04:45:40 <mm_freak_> my language has DTs
04:45:50 <mm_freak_> every argument of type Set is a forall
04:46:06 <t7> how are you gonna infer?
04:46:26 <mm_freak_> not sure yet…  i'm thinking of a dependency graph
04:47:28 <mm_freak_> for example:  f : (A : Set) -> A -> A, when you write f ? x, then the first argument follows from the second
04:47:46 <mm_freak_> and i think a depgraph can resolve it
04:48:16 <t7> ah cool
04:48:27 <rexamophone> ski: i've tried reasonin about the foldr lke we discussed....its making my head hurt
04:48:55 <rexamophone> although i got the foldr answer i clearly don't *get* it....
04:49:10 <mm_freak_> anyway, since i'm implementing a DT language you really see how haskell /not/ having them might actually be an advantage at times =)
04:51:11 <hpaste> ски annotated “масло” with “масло (annotation)” at http://hpaste.org/68225#a68227
04:51:50 <rexamophone> fwiw i'm pressing on with the pf form for append.
04:52:04 <ski> rexamophone : hm, ok
04:52:09 <ski> ("pf form" ?)
04:52:28 <lamefun2> haskell support non-english letters in identifiers?!
04:52:36 <rexamophone> point-free
04:52:42 <ski> lamefun2 : unicode
04:52:48 <rexamophone> (am i referring to it incorrectly?)
04:53:18 <ski> rexamophone : not really incorrectly. it's just that i'm not sure i've seen that abbreviation before ..
04:54:20 * mekeor defined an empty (but useful!) type-class :D
04:54:44 <mm_freak_> mekeor: you know, nowadays we do type level arithmetic using type families instead of type classes ;)
04:54:56 <lamefun2> is there a reason why there are not type refinements?
04:55:00 * ski bids mekeor meditate over emptiness
04:55:33 <mekeor> ski: :D hehea
04:58:49 <mekeor> it's a bummer that haskell/GHC can't automatically derive an instance for my empty class!
04:59:30 <mekeor> (although "instance MyEmptyClass DataType" isn't much longer than "… deriving MyEmptyClass"."
04:59:49 <mekeor> s/\"/)/
04:59:50 <ski> mekeor : you could request it as a feature
04:59:57 <mekeor> ski: rly?
05:00:47 <ski> lamefun2 : hm -- i don't think i'm getting the full picture of what you want to do
05:02:04 <ski> mekeor : you could always try
05:04:10 <rexamophone> can this expression be simplified further?
05:04:10 <rexamophone> append = flip (foldRight (:|))
05:04:33 <ski> not really
05:04:59 <ski> rexamophone : .. would you like to see a trace using `foldRight' ?
05:05:12 <rexamophone> please!
05:05:50 <ski> well, first i'd like to see your exact definition of `foldRight'
05:06:12 <rexamophone> foldRight :: (a -> b -> b) -> b -> List a -> b
05:06:12 <rexamophone> foldRight _ b Nil      = b
05:06:12 <rexamophone> foldRight f b (h :| t) = f h (foldRight f b t)
05:07:14 <mekeor> @src foldr
05:07:14 <lambdabot> foldr f z []     = z
05:07:15 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:07:34 <ski> rexamophone : right, so
05:08:02 <ski>      append (0 :| 1 :| 2 :| Nil) (3 :| 4 :| Nil)
05:08:06 <rexamophone> where i'd worked it out up to was that the whole thing was going to recurse to the bottom of the lists before evaluating cons, am i right?
05:08:21 <ski>   =  flip (foldRight (:|)) (0 :| 1 :| 2 :| Nil) (3 :| 4 :| Nil)
05:08:33 <ski>   =  foldRight (:|) (3 :| 4 :| Nil) (0 :| 1 :| 2 :| Nil)
05:08:45 <ski>   =  0 :| foldRight (:|) (3 :| 4 :| Nil) (1 :| 2 :| Nil)
05:08:53 <ski>   =  0 :| 1 :| foldRight (:|) (3 :| 4 :| Nil) (2 :| Nil)
05:09:01 <ski>   =  0 :| 1 :| 2 :| foldRight (:|) (3 :| 4 :| Nil) Nil
05:09:08 <ski>   =  0 :| 1 :| 2 :| 3 :| 4 :| Nil
05:10:45 <int-e> ski: botsnack
05:10:57 <rexamophone> i dont get how your evaluation statements came out
05:11:15 <rexamophone> in my head, i'm caught in recursion of foldRight f b t
05:11:30 <mekeor> :t flip (foldr (:))
05:11:31 <lambdabot> forall a. [a] -> [a] -> [a]
05:11:49 <mun> i have a slightly logical question
05:11:52 <mekeor> (flip (foldr (:))) is (++), right?
05:11:57 <mun> given a language {a,b,c} and some axioms {a=1,b=2} are {a=1,b=2,c=0}, {a=1,b=2,c=1} etc. all models of those axioms?
05:12:07 <mun> also does a model here have to give a value to 'c'?
05:12:52 <ski> mekeor : aye
05:13:19 <mekeor> how does the @test command work again?
05:13:29 <ski> rexamophone : `f' is `(:|)', and `b' is the whole `3 :| 4 :| Nil' thing
05:13:34 <ski> @help test
05:13:34 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:13:47 <ski> seems there is no such command
05:13:59 <rexamophone> i think i just saw the single step you do for each recursive call.
05:14:01 <mekeor> @test \x y -> x++y == flip (foldr (:)) x y
05:14:01 <lambdabot> Maybe you meant: let list tell
05:14:07 <rexamophone> gimme another sec :)
05:14:16 <mekeor> @list
05:14:16 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
05:14:30 <mekeor> i meant "check".
05:14:33 <mekeor> @check \x y -> x++y == flip (foldr (:)) x y
05:14:35 <lambdabot>   "OK, passed 500 tests."
05:14:37 <mekeor> yay
05:15:51 <ski> mekeor : heh, was about to suggest
05:16:22 <kane77> how can I turn "123" into [1,2,3] I'm currently trying something like (map read (map show "123")) but it gives me Prelude.read no parse..
05:16:28 <ski> @check \x y -> x++y == foldr (:) x y
05:16:30 <lambdabot>   "OK, passed 500 tests."
05:16:32 <ski> mekeor ^
05:16:42 <mm_freak_> i'm still not sure which path to take…  compiling to SK seems so extraordinarily simple and feels so easy to optimize, but i'll have a lot more nodes in the graph
05:16:58 <rexamophone> ski: in the first eval, you had 0 :| foldr ...
05:17:02 <mm_freak_> supercombinators are harder to implement, but should naturally give reasonable performance
05:17:06 <Svarg> mun: what is that? i haven't seen that notation before - confused but amused - why is c 0 or 1?
05:17:20 <geekosaur> kane77, why do you think you need show there?
05:17:24 <ski> @hoogle intToDigit
05:17:24 <lambdabot> Data.Char intToDigit :: Int -> Char
05:17:32 <ski> @hoogle digitToInt
05:17:32 <lambdabot> Data.Char digitToInt :: Char -> Int
05:17:35 <ski> kane77 ^
05:17:55 <kane77> geekosaur, ski thanks
05:17:58 <rexamophone> ski: if the def of foldr is 'f h (foldr f b t), why isn't the output ':| 0 :| foldr..."?
05:18:07 <mun> Svarg, sorry, the notation used isn't haskell. just general notation for expressing some logical formulae.
05:18:36 <ski> rexamophone : the output is `(:|) 0 (foldr ...)', which is just another way of writing `0 :| foldr ...'
05:18:41 <rexamophone> im expecting "f h", which evals to " :| 0"
05:18:55 <rexamophone> oh of course
05:18:56 <Svarg> mun: i'm aware of that - what logical formulae though?
05:18:57 <rexamophone> infix notation
05:19:05 <rexamophone> damnit it strikes again...
05:19:18 <Svarg> is there a name for that notation?
05:19:29 <Svarg> or what branch of logic is that used in?
05:19:55 <mun> Svarg, no. i'm just writing some sentences in propositional logic.
05:20:02 <Svarg> ah
05:21:38 <ibid> propositional logic doesn't usually deal with things like a=2
05:21:57 <ibid> that sounds more like first-order models
05:22:09 <ibid> though i've never seen it written quite like that
05:22:49 <rexamophone> ski: i've got it!
05:23:34 <rexamophone> thanks for your help everyone
05:24:08 <rexamophone> next function is `flatten :: List (List a) -> List a` but i'm going to bed...
05:24:31 <rexamophone> thanks again :)
05:24:33 <ibid> mun: ... but a model does fix the value of c, yes
05:24:48 <ibid> mun: assuming i understand your question right
05:24:59 <mun> ibid, indeed. TBH i was abusing notation a bit there.
05:25:21 <mun> ibid, so a model would have to contain a=1, b=1, but any value for c?
05:26:14 <ibid> mun: if we are talking about a first-order language with constants a, b, c and you constrain your models so that only a=1 and b=2 are allowed, then any such model will have a=1, b=2 and c = anything
05:26:48 <mun> ibid, thanks
05:26:50 <ski> rexamophone : great :)
05:27:03 <ibid> mun: if your axioms really are of the form a=1 etc and the numbers are logical symbols, not language constants, then it's not a normal FO language
05:28:09 <ibid> mun: a normal FO language would not be able to express a=1 without 1 being a constant and without = being a binary predicate (you could make it a logical symbol, then the logic is FO equational)
05:28:29 <ski> mun : "... are {a=1,b=2,c=0}, {a=1,b=2,c=1} etc. all models of those axioms?" -- yes
05:28:40 <ski> mun : "also does a model here have to give a value to 'c'?" -- yes
05:29:24 <ibid> (and if 1 is a constant, not a logical symbol, then the model needs to assign a value to it as well, which can be a bit confusing)
05:30:25 <Svarg> so where and how does c equal 0 or 1 there?
05:30:49 <ibid> Svarg: the value of c is not constrained, hence it can be anything. including 0 or 1
05:31:03 <Svarg> he asked if those are the only 2 models though, no?
05:31:25 <Svarg> ooh
05:31:26 <Svarg> wait
05:31:28 <Svarg> no he didn't
05:31:30 <Svarg> i misread
05:31:36 <Svarg> heh
05:31:40 <ibid> Svarg: i took the question to mean that those are two but not necessarily all models :)
05:31:45 <Svarg> yeah
05:31:49 <Svarg> ok that makes more sense now
05:31:58 <ibid> Svarg: to say that they are the only models you have to restrict the set from which you can draw values for c
05:32:03 <Svarg> yeah
05:32:35 <ibid> well, of course, you always should restrict it
05:32:44 <ibid> specify the universe, then give the assignments
05:32:45 * ski isn't sure whether `a',`b',`c' here are variables or function symbols, though
05:33:06 <ibid> ski: implicitly constants, given the question, methinks
05:33:23 <ibid> ski: a model wouldn't give values to variables
05:34:33 <ski> hm, right
05:35:05 * ski can't recall whether there's any name for the compound of a model and a valuation
05:35:21 <ibid> i don't think there is
05:35:50 <ibid> at least iirc i always had to say "all models and all valuations" when i did this stuff :)
05:36:15 <ibid> though i used a different word for valuation
05:40:32 <mekeor> do dependent classes make sense? i mean, classes which depend on values?  O_O
05:40:54 <mekeor> mm_freak_: what do you think?
05:41:24 <ski> dependent type classes ?
05:41:30 <mekeor> i mean, i think that that could make sense together with dependent types.
05:41:35 <ski> or maybe you meant dependent record types ?
05:41:35 <mekeor> ski: uhuh. *nod*
05:41:54 <mekeor> ski: i meant dependent type classes.
05:42:13 <ski> example of what you mean, exactly ?
05:43:05 <mekeor> well, when you do "class ClassName Foo Bar where …" Foo and Bar are types. would it make sense (esp. for languages which support dependent types) that Foo and Bar could be *values*, too?
05:43:43 <mekeor> i think so. because, usually, type-classes define type-signatures, right?
05:44:16 <mm_freak_> mekeor: a type class is really just a mechanism for passing records (dictionaries) implicitly
05:44:17 <mekeor> in dependently-typed languages, in these type-signatures, values can appear. you could use the value which the class gets here.
05:44:38 <mm_freak_> in that sense in a DT language if you have type classes, they can naturally depend on values
05:44:59 <mm_freak_> haskell:  plus :: (Num a) => a -> a -> a
05:45:30 <mm_freak_> a DT language:  plus : {A : Set} {Num A} -> A -> A -> A
05:46:36 <copumpkin> mm_freak_: there's an additional aspect to typeclasses that isn't covered by that
05:46:41 <mekeor> er, what? in idris, e.g., the first is the correct one…
05:46:50 <mm_freak_> copumpkin: what?
05:46:54 <copumpkin> uniqueness of instances
05:46:57 <copumpkin> which is an important property
05:47:01 <mm_freak_> true
05:47:22 <copumpkin> things like scala, which do adopt the "implicit dictionary passing" approach miss out on it
05:47:23 <lamefun2> is there an official Haskell coding style?
05:47:29 <mm_freak_> but that's the basic mechanism…  conceptually there is nothing stopping you from having value arguments to type classes in a DT language
05:47:37 <mm_freak_> lamefun2: yes, write readable code
05:47:41 <copumpkin> lol
05:47:57 <womb> lamefun2: i thought that language enforces style
05:48:02 <ktosiek> lamefun2: not really
05:48:11 <Svarg> lamefun2: http://stackoverflow.com/questions/6398996/good-haskell-source-to-read-and-learn-from
05:48:16 <womb> lamefun2:  with 2d syntax and naming conventions
05:48:28 <t7> gloss is pretty cool then
05:48:44 <mekeor> lamefun2: not official, but take a look at https://github.com/tibbe/haskell-style-guide , e.g.
05:48:54 <mm_freak_> lamefun2: a strict formatting standard usually leads either to unreadable code or to excessive line noise…  haskell leaves formatting up to you, and you shouldn't fixate on any particular style, but use whatever is best readable for the code segment you currently write
05:49:25 <t7> i may have to start formatting my code properly; without using tabs
05:49:30 <t7> but i do love tabs :(
05:49:33 <Svarg> tabs are evil
05:49:35 <copumpkin> I think tibbe had a guideline somewhere
05:49:45 <hiptobecubic> tabs are disgusting
05:50:07 <copumpkin> lamefun2: this isn't official, but probably reflects how many people write it: https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
05:50:13 <t7> if you use tabs exclusively they are pretty
05:50:14 <ktosiek> tabs are doubly evil in languages in which indentation matters
05:50:27 <t7> and take less disk space
05:50:40 <ktosiek> t7: you really care about that disk space?
05:50:42 <copumpkin> t7: yeah, we're really hurting for disk space today
05:50:47 <mekeor> copumpkin: i was faster :P
05:50:52 <copumpkin> oh, sorry
05:51:28 <t7> "You may or may not indent the code following a "hanging" lambda."
05:51:35 <t7> helpful...
05:51:59 <ktosiek> and files always take block_size*ceiling(length/block_size) anyway :-)
05:52:02 <copumpkin> there are always going to be things that boil down to personal preference :P
05:53:17 <Svarg> if disk space was really a concern, tabs do a really crappy job of not wasting space - can't really use that as an argument in favor of tabs these days :P
05:53:37 <t7> you save 3 bytes every indent
05:53:44 <Svarg> or you could just use gzip :P
05:53:52 <t7> i bet in the source of ghc thats like megabytes
05:53:58 <t7> a megabyte*
05:54:07 <Svarg> and compress each file
05:54:07 <copumpkin> holy shit!
05:54:10 <copumpkin> a megabyte!
05:54:13 <Svarg> hehe
05:54:16 * copumpkin faints
05:54:29 <ktosiek> that's, like, a whole 2s when downloading a tarball
05:54:40 <t7> ok im done pseudo trolling
05:54:45 <ktosiek> oh, wait, it's compressed, so like a 0.05s :-D
05:54:57 <ktosiek> t7: come on, that was funny :-)
05:55:23 <Phlogistique> https://mobile.twitter.com/PLT_Hulk/status/199818568093806592
05:56:30 <Jack_> hi, does anybody know how to remove something installed with cabal?
05:57:03 <bitonic> Jack_: ghc-pkg unregister and then manually delete the files.
05:57:29 <hpc> if you don't need it actually deleted, you can ghc-pkg hide instead
05:58:30 <t7> someone should fuse lambda calculus with corewars
05:59:25 <Jack_> bitonic, hpc, i just tried ghc-pkg unregister Agda-executable but was told the package cannot be found. i said cabal install agda-executable to install. what's the deal with that? btw, i definitely want to uninstall
05:59:54 <hpc> capitalization
06:00:40 <endojelly> Packet capture filter (device pppoe0): dst host [gelöscht] and (icmp or ((tcp or udp or sctp) and (src host 10.232.32.122)))
06:00:43 <endojelly> uh
06:00:46 <endojelly> na das erklärt's eigentlich oO
06:01:18 <endojelly> das ist ja echt mal das falsche interface
06:01:21 <endojelly> die falsche dst ip
06:02:16 <bitonic> Jack_: you can check the installed packages with `ghc-pkg list', and those are the ones you can unregister. capitalization matters
06:06:44 <ski> t7 : if you use tabs, make sure to (a) only indent using tabs; (b) always break like before any layout-block which is longer than one line
06:07:06 <ion> Also: if you use tabs, don’t. :-)
06:08:14 <mekeor> mm_freak_, ski, copumpkin: idris, in fact, does support "dependent type-classes" -- just awesome!
06:09:17 <mm_freak_> mekeor: no reason why it wouldn't
06:09:40 <mm_freak_> any language with inductive families has technically everything necessary to have "dependent type classes"
06:10:07 <mekeor> hmm, okay…
06:11:18 <Jack_> bitonic, thanks, i got the package name, it was Agda-2.3.0.1. the unregister command executed in about 1 second, suggesting the files weren't removed. is there a way to clean out these leftover files?
06:11:46 <bitonic> Jack_: you need to do it manually
06:12:06 <hpc> in theory, they're somewhere in ~/.cabal and/or ~/.ghc
06:12:07 <ski> mekeor : e.g. `x # 0 => ...' might be useful in several cases .. or `(-) : (m : Nat) -> (n : Nat) -> m >= n => Nat'
06:12:12 <mm_freak_> endojelly: falscher channel? ;)
06:12:19 <endojelly> mm_freak_, yap 8)
06:13:09 <ski> mm_freak_ : even uniqueness of instance property ?
06:13:36 <mm_freak_> ski: i don't know about the termination properties of idris
06:15:11 <mekeor> ski: what does "x # 0 => ..." mean?
06:15:38 <dcoutts> Jack_: executables do not get registered, so there's nothing to unregister
06:15:48 <mekeor> ski: i've got an example for a dependent type-class, too: http://codepad.org/26XSfH2N
06:16:16 <dcoutts> Jack_: there's no uninstall feature for the files themselves, but as hpc said, they're under ~/.cabal/ you only need to mess with it if you care about the disk space
06:17:04 <Jack_> great, thanks for the help guys, sorted!
06:19:04 <ski> mekeor : `#' is apartness
06:19:42 <t7> mekeor: coq has cool type classes
06:20:10 <Alan> hmmm, i think i'm failing to understand why i would want to use ST instead of State... maybe somebody could enlighten me?
06:20:48 <ski> Alan : guaranteed in-place update -- also dynamic allocation of state cells of any type
06:20:48 <quicksilver> Alan: they are really very different.
06:21:07 <quicksilver> Alan: so they're not often direct replacements for a given algorithm.
06:21:39 <quicksilver> State gives you a single haskell value (which can be arbitrarily complex) which you "modify" by producing new versions of it in the normal immutable way.
06:21:59 <hiptobecubic> quicksilver, why use it at all then?
06:22:18 <quicksilver> ST gives you a few different things including (1) the ability to create, destroy, mutate references of arbitrary type (STRef) and (2) mutable arrays STArry
06:22:24 <quicksilver> hiptobecubic: which use which?
06:22:36 <Alan> also, the docs seem to list it as "experimental"
06:22:37 <hiptobecubic> why use State if it is just normal immutable haskell?
06:22:59 <quicksilver> hiptobecubic: covenience. Boilerplate removal. abstraction.
06:23:40 <quicksilver> from one perspective the main reason to use State is to make it impossible to accidentally use s' when you meant s'', and break your algorithm.
06:23:55 <mm_freak_> hiptobecubic: because dealing with functions of the form s -> (a, s) can be inconvenient
06:23:57 <hiptobecubic> quicksilver, what do you mean?
06:23:59 <mm_freak_> hard to thread, etc.
06:24:03 <mm_freak_> State does all that for you
06:24:20 <quicksilver> hiptobecubic: let s' = blah s; s'' = blah s' in do_something s'
06:24:28 <quicksilver> hiptobecubic: typical hand-managed state.
06:24:34 <hiptobecubic> quicksilver, oh i see
06:24:35 <quicksilver> hiptobecubic: contains a bug, I should have used s'' at the end.
06:24:38 <hiptobecubic> quicksilver, yes
06:24:48 <hiptobecubic> quicksilver, and using State avoids such a thing?
06:24:51 <quicksilver> yes
06:24:55 <Alan> ok, so does ST end up trading some purity for some performance then?
06:24:57 <quicksilver> because you don't have to name any of them.
06:25:00 <quicksilver> Alan: no.
06:25:12 <quicksilver> it's still pure.
06:25:19 <hiptobecubic> it's pure on the outside
06:25:43 <quicksilver> hiptobecubic: (because you often get away without naming the s'' at all)
06:25:53 <quicksilver> hiptobecubic: e.g. do { blah; blah; get >>= do_something }
06:25:56 <quicksilver> or suchlike.
06:26:10 <hiptobecubic> oh
06:26:16 <hiptobecubic> quicksilver, ok sure.
06:26:21 <mm_freak_> Alan: ST is pure, but allows imperative programming
06:28:00 <Alan> ooh, the haskellwiki entry is a bit more fleshed out than the actual documentation
06:28:03 <Alan> i'll read that
06:28:13 <ktosiek> is STs in place modification based on some optimization? or on unsafePerformIO?
06:28:22 <quicksilver> hiptobecubic:  in any particular case the decision to use State can be quite marginal.
06:28:37 <quicksilver> Also note that STRefs are no "more mutable" than State.
06:28:46 <mm_freak_> ktosiek: neither…  it's just a limited IO
06:28:50 <quicksilver> only STArray is a real gain in mutability.
06:29:45 <hiptobecubic> hm
06:29:57 <mm_freak_> ok, a proper expression in my core language has no free variables…  when i translate this into supercombinators, all lambdas should be gone, right?
06:30:46 <hiptobecubic> I wrote an algorithm that was dependent on lists, which i managed to convert to generic vectors, and then unboxed vectors, but going from unboxed to unboxed.mutable wasn't trivial at all
06:31:17 <mm_freak_> hiptobecubic: in most cases you shouldn't use mutable vectors anyway
06:32:05 <mm_freak_> hiptobecubic: note that many algorithms on a mutable vector can be rewritten as a non-mutating algorithm on boxed vectors
06:32:44 <hiptobecubic> mm_freak_, well it works already with Unboxed
06:33:50 <ktosiek> mm_freak_: wouldn't that make it way slower? They would be copied all the time?
06:33:57 <hiptobecubic> mm_freak_, but i was expecting a significant speed difference switching to mutable vectors because the profiler is claiming that it's allocating/freeing many gigs, when it could clearly be running in constant space
06:34:19 <mm_freak_> ktosiek: no
06:34:57 <Alan> what is "boxed" vs. "unboxed"?
06:35:06 <ktosiek> is GC smart enough to modify things if they are the last reference?
06:35:06 <mm_freak_> ktosiek: then the original algorithm worked on a single vector, the transformed algorithm should work on a single vector, too…  and in the best case the vector gets optimized away entirely
06:35:14 <hiptobecubic> Alan, pointers to values or the raw values themselves
06:35:18 <mm_freak_> s/then/when/
06:35:23 <Alan> oh, i see
06:35:28 <quicksilver> ktosiek: no.
06:35:39 <bitonic> jaspervdj: wai-websockets is broken :( https://github.com/yesodweb/wai/issues/68
06:35:39 <mm_freak_> hiptobecubic: that's probably because you used unboxed vectors
06:35:57 <quicksilver> ktosiek: I wouldn't say it "isn't smart enough" but rather that it deliberately chooses not to :)
06:36:05 <hiptobecubic> mm_freak_, you'd expect it to be faster with boxed values?
06:36:22 <mm_freak_> hiptobecubic: see the 'instinct' library on hackage
06:36:43 <hiptobecubic> mm_freak_, AI.Instinct?
06:36:49 <mm_freak_> what virtually all neural network implementations i know do with a mutable vector i've done with an immutable boxed vector, and it performs very fast
06:37:21 <ski> ktosiek : it is based on a primitive implementation in the run-time system, just like `IO',`Int',`Float',&c.
06:37:25 <mm_freak_> hiptobecubic: see for example the 'activation' source code
06:37:32 <hiptobecubic> mm_freak_, oh damn. This was #1 on my list of things to try to do :(  I guess I need to think up a new project
06:37:34 <mm_freak_> in AI.Instinct.Brain
06:38:10 <mm_freak_> another nice demonstration of the power of boxed vectors is in the implementation of the delta rule in AI.Instinct.Train.Delta
06:38:16 <ski> hiptobecubic : often dynamic programming can be done with a lazy recursive array instead of by mutating an array
06:38:50 <hiptobecubic> can boxed vectors be defined recursively then?
06:38:54 <hiptobecubic> and unboxed cannot?
06:38:57 <mm_freak_> yes
06:39:31 <mm_freak_> 'activation' does that
06:41:16 <mm_freak_> basically by using a recursive vector construction i've saved me the whole trouble of iterating the network until it reaches a rest state
06:41:57 <hiptobecubic> hm
06:42:20 <Alan> ok, this haskell code is gibberish to me... is using # all over the place some kind of convention?
06:42:42 <hiptobecubic> Alan, you mean like (Double#) ?
06:43:00 <Alan> case newAlignedPinnedByteArray# (len# *# 2#) 2# s1# of
06:43:01 <hiptobecubic> I'll have to reexamine my code then. Maybe it would do better with just Vector instead of Unboxed.  I'm still shedding my C skin :)
06:43:04 <Alan> etc.
06:43:14 <hiptobecubic> Alan, ... looking at Core output?
06:43:22 <Alan> something to do with this? {-# LANGUAGE BangPatterns, MagicHash, UnboxedTuples #-}
06:43:23 <mm_freak_> =)
06:43:40 <ski> the two latter languages, yes
06:43:42 <hpc> Alan: you're looking at gross code
06:43:51 <hpc> or at least low-level code
06:44:02 <quicksilver> Alan: yes, it's a convention used by GHC to delimit its internal primitives and types
06:44:17 <hiptobecubic> mm_freak_, have you benchmarked this against other implementations of the same algorithm? At least informally ?
06:44:40 <hiptobecubic> by 'the same algorithm' i mean the same concept, but not the same idiomatic style of course.
06:44:47 <Alan> oh, now i've actually googled it... so it's a convention for unboxed things?
06:45:14 <ski> yeh
06:45:18 <hiptobecubic> Double# is an unboxed Double, if i recall
06:45:24 <ski> @kind GHC.Base.Int#
06:45:25 <lambdabot> #
06:45:26 <ski> @kind GHC.Base.Int
06:45:26 <lambdabot> *
06:45:32 <Alan> https://github.com/jaspervdj/dcpu16-hs/blob/master/src/Memory.hs
06:45:36 <Alan> the code i happen to be reading
06:45:46 <Alan> haha, and teh author is actually in this channel
06:45:51 <hiptobecubic> but i think it's usually pretty safe (and more readable) to use BangPatterns and -funbox-strict-fields or whatever it is
06:46:12 <hiptobecubic> throw some -O at it and hope for the best
06:46:25 <Alan> ok, so i'm making some kind of emulator thingy... am i better off not prematurely optimising?
06:46:37 <hiptobecubic> "am i better off not prematurely optimising"
06:46:40 <dcoutts> hiptobecubic: there's generally no need to use Double# directly, using ! and unpacking data is almost always enough
06:46:41 <Alan> i.e. implementing it in a naive way and hoping the optimiser does a good job?
06:46:44 <mm_freak_> hiptobecubic: no, but memory consumption outweighed CPU usage
06:46:57 <mm_freak_> hiptobecubic: the current representation of the connection matrix is a bit unfortunate
06:46:57 <Alan> or... should I at least make sure my memory emulation is effecient by using ST?
06:47:04 <Alan> and STArray?
06:47:06 <mm_freak_> hiptobecubic: fast, but also big
06:47:14 <hiptobecubic> dcoutts, {-# UNPACK Foooooooo #-} ?
06:47:24 <quicksilver> Alan: sounds like premature optimisation to me. It's not going to be a problem to change it later.
06:47:29 <quicksilver> Alan: correct first, fast later.
06:48:17 <Alan> also, it seems to me that in-source flags that tell the compiler to work differently always feel a bit icky
06:48:19 <hiptobecubic> I just like the question
06:48:25 <dcoutts> hiptobecubic: data Foo = Foo {-# UNPACK #-} !Double ...
06:48:33 <hiptobecubic> dcoutts, ah yes, that was it.
06:48:43 <Alan> hiptobecubic: because "premature" implies that it's bad already?
06:49:03 <hiptobecubic> Alan, pretty much by definition. It's funny that you'd call it that and then ask about it
06:49:07 <Alan> and that i know the answer, so i should obey it
06:49:12 <dcoutts> Alan: using {-# UNPACK #-} is fine, and more explicit than using {-# OPTIONS_GHC -funbox-strict-fields #-} at the top of the module
06:49:31 <Alan> hiptobecubic: i guess a better question would be "is worrying about unboxed types and STArray premature optimisation?"
06:49:39 <Alan> which probably is still a resounding yes
06:49:42 <hiptobecubic> {-# UNPACK #-} is pretty common it seems, yes.
06:49:53 <hiptobecubic> Alan, i think quicksilver summed up the best approach pretty nicely.
06:50:18 <hiptobecubic> Alan, if you can manage to get anything to work at all, then you can consider making work better.
06:50:20 <Alan> hiptobecubic: yeah, true
06:52:12 <frontendloader> can you tell the compiler to evaluate something to normal form at compile time? e.g seedData = myfunction [1..1000] so that seeddata isn't needed to be built every time the program is run?
06:53:28 <quicksilver> frontendloader: using TemplateHaskell, yes.
06:55:33 <scooty-puff> is it possible to set new default values for options when using cabal - write now have: https://raw.github.com/sonyandy/glyph/develop/Setup.hs
06:56:41 <scooty-puff> (specifically, alex options)
06:56:42 <mekeor> s/write/right/
06:56:48 <scooty-puff> right
06:57:06 <hpc> scooty-puff: edit ~/.cabal/config
06:57:18 <scooty-puff> can it be local to a package?
06:57:26 <scooty-puff> the changes
06:57:34 <dcoutts> scooty-puff: not yet, but we're moving in that direction
06:57:37 <scooty-puff> k
06:57:47 <scooty-puff> what i have works, just wondering
06:58:20 <YellowOnion1> hey, I found some spam on the wiki
06:58:34 <YellowOnion1> http://www.haskell.org/haskellwiki/Applications
06:58:41 <YellowOnion1> "cheap car insurance"
06:59:04 <mekeor> lol
06:59:19 <YellowOnion1> it's an invisible link, and I assume the user who added it needs to be banned heh
06:59:43 <hpc> it's visible to me
07:00:07 <YellowOnion1> well it looks like any other text until you hover over it
07:00:19 <mekeor> *nod*
07:01:07 <saml> lol
07:01:27 <Eduard_Munteanu> http://www.haskell.org/haskellwiki/index.php?title=Haskell_in_practice&diff=42635&oldid=42437
07:01:28 <YellowOnion1> don't have an account nor do I know how to handle spammers :)
07:02:04 <saml> MmSchubert5
07:02:18 <mekeor> hehe
07:02:44 <hiptobecubic> what a worthless spam
07:02:53 <hiptobecubic> I wouldn't have even noticed
07:02:58 <mekeor> "Fixing grammar errors"
07:02:59 <YellowOnion1> oddly I clicked it lol
07:03:09 <hpc> it's for search engines
07:03:16 <YellowOnion1> I click the window to focus it :-|
07:03:29 <mekeor> hpc: ah!
07:03:34 <YellowOnion1> ahh yeah
07:03:50 <hpc> haskell.org is a pretty reputable domain
07:04:01 <hpc> so a link from there to somewhere else will bump that site's rank
07:04:14 <hiptobecubic> hpc, ah of course.
07:04:39 <hiptobecubic> Why not put it somewhere less conspicuous then
07:04:57 <hiptobecubic> although, i guess it's pretty well hidden
07:06:49 <YellowOnion1> lol I would have added an entire section, "blah blah Uses haskell for their insurance management systems..."
07:08:47 <ehamberg> i undid the edit now. no more cheap insurance for you. :|
07:09:03 <mm_freak_> i have found a representation for expression that is particularly easy to translate into supercombinators…  i think i will go with them instead of SKI
07:09:20 <roha> repa question: I have a list which i convert to a Array D DIM2 a with fromListUnboxed. I now need the apply a function to each element in that array. i need to do that hundreds of times, but for each iteration i need the array of the previous iteration. i used unboxed vectors before and simply wrote some kind of Data.List.iterate function for vectors. If i do that with Repa Unboxed Arrays I get an error that the result of traverse/map is
07:09:20 <roha> a Repa Delayed Array. Any tips?
07:11:46 <roha> the function which needs the previous array to compute the values of the new array expects a Array U and complains about me passing it a Array D
07:12:29 <ski> mm_freak_ : which is that ?
07:13:40 <saml> hello bro
07:13:50 <jaspervdj> Alan: you mentioned me but I lost my log, what was it about? :-)
07:14:07 <saml> roha, use two arrays?
07:14:20 <rwbarton> roha: i haven't used repa 3 but you probably need to insert a call to something like 'force'
07:14:58 <lamefun2> I know why I always asked about classes
07:15:03 <roha> saml, i still would need to convert Array D to Array U
07:15:06 <mm_freak_> ski: \f -> f (\x -> f x) becomes:  \1 -> 0 ((\2 -> 0 1) 0)
07:15:15 <mm_freak_> ski: every lambda is completely local
07:15:21 <Alan> jaspervdj: talking about code in your DCPU-16 emulator
07:15:23 <roha> rwbarton, ok thanks i'll have a look
07:15:23 <mm_freak_> closures are passed explicitly
07:15:37 <Alan> jaspervdj: i was getting confused by half the characters being # :P
07:15:54 <lamefun2> if entity is TCharacter then (entity as TCharacter).TakeDamage;  for example in enemy collision code
07:16:02 <mm_freak_> \n -> x means that the lambda takes n arguments and references them as numbers within x
07:16:08 <ski> mm_freak_ : ok, deBruijn
07:16:11 <mm_freak_> no
07:16:25 <ski> hm no, not exactly i see now
07:16:31 <mm_freak_> variables of the outer lambda are out of scope in an inner lambda
07:16:41 <lamefun2> downcasting -.-
07:17:18 <ClaudiusMaximus> roha: http://hackage.haskell.org/packages/archive/repa/3.1.4.2/doc/html/Data-Array-Repa-Eval.html#g:3
07:17:19 <ski> ok
07:18:09 <jaspervdj> Alan: Right, that's a bit low-level
07:18:23 <jaspervdj> It's used to indicate unlifted types
07:22:14 <ski> lamefun2 : should obviously be `case asTCharacter entity of Just tCharacter -> takeDamage tCharacter; Nothing -> ...'
07:24:25 <roha> ClaudiusMaximus, if i use computeS it says: No instance for (repa-3.1.4.2:Data.Array.Repa.Eval.Fill.Fillable r20 (Int, Int, Bool, Double)) arising from a use of `computeS'. So if i make an instance declaration for an Array U of my Tuple-Type i should be fine?
07:26:13 <ClaudiusMaximus> roha: i think you just need to add a type annotation to force r20 = U
07:26:50 <ShawnMcCool> What is the general consensus on the current state of haskell for web-development?
07:27:24 <Clint> that it's rad
07:27:30 <roha> ClaudiusMaximus, ah your right, Unbox e => Fillable U e is already an instance of Fillable. It worked thanks!
07:27:45 <scooty-puff> and awesome
07:27:58 <ClaudiusMaximus> roha: cool!
07:28:03 <ShawnMcCool> So the hosting situation is acceptable?
07:28:38 <lamefun2> ski: and how I'm going to implement asCharacter? Can I extract curried stuff from data Entity functions?
07:30:06 <traviscline> is the first part of a forkIO 'body' guaranteed to run before the runtime yields to the next line after the forkIO?
07:30:23 <lamefun2> and takeDamage is kind of meaningless, since entities are just immutable states and not real OOP objects
07:31:06 <ski> lamefun2 : i have no idea how your data types look like
07:31:10 <scooty-puff> so i know theres a regions package, but was trying to think of it in a particular context - so i wrote a MonadRef instance backed by a weak map (where the Ref's are strong references) - but wanted to make it so cleaning the weak map of tombstones maybe wasn't so costly
07:31:29 <hpaste> scooty-puff pasted “MonadRegion type class” at http://hpaste.org/68232
07:31:53 <tdammers> haven't read enough probably, but takeDamage makes perfect sense if it returns an updated copy of the character, I would say
07:32:13 <scooty-puff> also wanted to make sure things allocated in the region didn't escape, hense the rank-2 type, but that it didn't make a weird kinded "m"
07:33:18 <ski> lamefun2 : maybe you'd actually want `modifyTCharacter :: (TCharacter -> TCharacter) -> (Entity -> Entity)' -- i dunno
07:33:34 <ski> (this is basically a partial lens)
07:37:29 <tdammers> ski: that's what I'm talking about
07:37:59 <ski> tdammers : figuring it doing no change if the entity isn't a `TCharacter'
07:38:32 <ski> whether this is the best or even a good way to structure things i dunno -- it seems to be possible, though
07:38:59 <tdammers> personally, I'd wrap the entire state of the game or whatever this is in a data structure and run a state monad over that
07:39:13 <lamefun2> I guess I need to build something working first to test everything - bullets that don't influence each other and start from there
07:40:10 <tdammers> maybe you better let go of entities that modify each other and themselves
07:40:19 <tdammers> it sounds like a good idea, but it gets messy fast
07:40:30 <scooty-puff> i assume for an IntMap, that deleteLT or deleteGT, that deletes all elements < or > some Int, could be done in O(log n) time?
07:40:30 <tdammers> in OOP just like in FP
07:42:20 <tdammers> instead, just let the entities observe the world passively, set a few parameters on themselves, and let a master object handle interactions
07:43:11 <tdammers> e.g., each bullet has a position and a velocity; the master object then looks at the bullets, updates their positions, and figures out if they have hit anything
07:43:40 <ski> tdammers : for a simple maze-adventure game i used a zipper ..
07:44:08 <tdammers> for collision detection?
07:44:15 <ski> scooty-puff : sounds plausible
07:44:34 <copumpkin> scooty-puff: yeah, just look at split
07:44:49 <copumpkin> scooty-puff: that can run in O(log n), and you can use it to build the operations you want
07:44:58 <scooty-puff> k
07:46:08 <scooty-puff> split is pretty much it - i'll have to check the strictness - may just be able to use that
07:50:02 * ski wonders how scooty-puff is using `MonadRegion'
07:53:01 <kkyqqp> is there an easier way of finding the integer sqrt than this?        toInteger $ ceiling $ sqrt $ fromInteger n
07:53:23 <ski> probably
07:53:29 <ski> (though, define "easier")
07:53:44 <kkyqqp> easier being really really simple, I guess
07:53:47 <t7> gloss is awesome
07:54:02 * ski was thinking of "easier" as in "cheaper/nicer to compute", not as "simpler to type"
07:54:23 <lamefun2> :t $
07:54:24 <lambdabot> parse error on input `$'
07:54:28 <ski> @type ($)
07:54:29 <lambdabot> forall a b. (a -> b) -> a -> b
07:54:37 <quicksilver> also that way isn't very good for integers such that the error term in Double's sqrt is > 1
07:54:38 <kkyqqp> what would a cheaper/nicer to computer version look like?
07:54:50 <quicksilver> (or do I mean 0.5?)
07:55:06 <ski> quicksilver : probably
07:55:31 <ski> hm, or maybe it depends
07:56:06 <scooty-puff> ski: yeah, thats not what i want - want to some how not require a position in the type constructor "m" for "s"
07:56:13 <ski> let's say the root is `nnn.92185', then it'd take only a small rounding error to get to large a result
07:57:06 <ski> scooty-puff : re your <http://hpaste.org/68232> paste ?
07:58:12 <ski> exercise : write a nice integral `sqrt', better than the linear brute-force
07:58:13 <scooty-puff> yeah, really want a runST type of thing
07:58:40 <ski> scooty-puff : i'm not sure what you're after -- you don't pass `s' as parameter to `m' in that paste ..
07:58:49 <scooty-puff> so have a RefSupplyT s m a, and can't think of a type class that would work - don't like runRegion :: (forall s . m s a) -> m a
07:58:59 <scooty-puff> because rules out a transformer
07:59:11 <scooty-puff> the paste is really no good..
07:59:40 <ski> scooty-puff : that `runRegion' is ill-kinded
07:59:50 * hackagebot hbayes 0.2.1 - Inference with Discrete Bayesian Networks  http://hackage.haskell.org/package/hbayes-0.2.1 (alpheccar)
07:59:56 <scooty-puff> o right, mean (forall s . m s a) -> m s a i guess?
08:00:02 <t7> is there an infix op for mappend?
08:00:08 <ski> scooty-puff : sounds unlikely
08:00:23 <ski> @type mappend
08:00:24 <lambdabot> forall a. (Monoid a) => a -> a -> a
08:00:26 <ski> @type (++)
08:00:26 <lambdabot> forall m. (Monoid m) => m -> m -> m
08:00:30 <ski> in lambdabot ^
08:00:32 <quicksilver> ski: I'm often annoyed there isn't a decent one in the library. I'm ignorant in such things I've always used binary chop if I've neede it.
08:00:43 <ski> t7 : you can say   blah `mappend` bleh
08:01:01 <ski> t7 : or you could locally redefine `(++)'
08:01:02 <quicksilver> ski: ISTR an integer version of newton-raphson (sp?) is better, and suffices for most purposes.
08:01:43 <ski> (correct spelling)
08:02:14 <ski> quicksilver : i suspect that one could adapt the old hand-algorithm for square roots to binary
08:02:38 <ski> but possibly other approaches would be better
08:02:54 <quicksilver> ski: http://www.finesse.demon.co.uk/steven/sqrt.html :)
08:03:13 <ski> (i'm not sure exactly what you mean by "binary chop" ? start by finding powers-of-two bounding it ?)
08:03:23 <tdammers> let sqrt x = filter (\n -> n * n == x) [1..]
08:03:33 <tdammers> that has to be the most inefficient implementation ever
08:03:35 <t7> storing game state in one huge ADT doesnt seem like a bright idea
08:03:38 <aristid> ski: actually Data.Monoid comes with (<>) now
08:03:44 <t7> should i use some sorta local database or something?
08:03:46 <ski> quicksilver : nice :)
08:03:48 <quicksilver> ski: search { 0, n/2, n/4, 3n/8, .... }
08:03:54 <ski> aristid : ok, didn't know
08:03:55 <bgamari> Is there any nice way to convert a repa array into a storable Data.Array.MArray?
08:04:37 <ski> tdammers : yeah, that's the brute-force one
08:05:07 <tdammers> it's inspired by the world's most inefficient yet deterministic search algorithm
08:05:15 <ski> (tdammers : though you really want it to work on non-perfect squares as well)
08:05:39 <ski> tdammers : thinking of Markov's Principle ?
08:06:02 <tdammers> let sort = head . filter isSorted . permutations
08:06:10 <ski> t7 : using a huge game state isn't necessarily bad
08:06:30 <ski> oh, s/search algorithm/sort algorithm/
08:06:43 <tdammers> uh, yeah... that's what I meant
08:07:10 <tdammers> coming up with a very inefficient *search* algorithm is much harder
08:07:49 <tdammers> less efficient than O(n), I mean
08:07:53 <ski> tdammers : i wonder how the "perform random swappings until sorted" performs in comparision
08:08:06 <tdammers> the problem with that is that it's not deterministic
08:08:10 <tdammers> so it doesn't really count
08:08:23 <ski> (for bonus points, make the `isSorted' thing incremental/adaptive)
08:08:46 <ski> ok
08:09:31 <tdammers> if the RNG actually produces a uniform distribution over the possible permutations, and the input is also shuffled using a perfect shuffling algorithm, then it makes no difference anyway
08:11:28 <ski> as long as it's deterministic on the surface, i think it's fine
08:11:30 <tdammers> oh, and how would I do an is-sorted check adaptively? I don't think I can do it any less efficient than walking the entire list and remember if any two consecutive elements are not ascending
08:12:07 <ski> (e.g. an "operation" implementing an extensional "function" (in Bishop's terminology) should, imo, be allowed to be (demonically) nondeterministic)
08:12:32 <t7> > abs (1, 2)
08:12:33 <lambdabot>   (1,2)
08:13:34 <ski> > Data.Complex.magnitude (1 :+ 2)
08:13:35 <lambdabot>   2.23606797749979
08:13:46 <ski> @type Data.VectorSpace.magnitude
08:13:47 <lambdabot> forall v. (InnerSpace v, Floating (Scalar v)) => v -> Scalar v
08:17:41 <ski> tdammers : well, i meant the adaptivity as an optimization ;)
08:19:59 <tdammers> ski: the whole point is to de-optimize :o
08:20:22 <ski> ("pessimize")
08:21:32 <ski> it would be interesting with a (more or less FP, say) system where adaptivity was pervasive
08:22:30 <scooty-puff> ski: http://hpaste.org/68235 is what i ended up with (RefSupplyT is just a StateT)
08:22:43 <scooty-puff> but can't think of how to generalize to a type class, but prob not worth it anyways
08:24:37 <ski> (also, the PC version of "optimize" is "improve" .. i wonder what "pessimize" would correspond to)
08:24:54 <tdammers> "exprove"
08:25:05 <scooty-puff> well, minus some errors, but the ideas about the same..
08:25:19 <scooty-puff> (related to my post)
08:25:30 <tdammers> also, "improve" is less specific than "optimize"
08:25:36 <|Lupin|> Hello (again) everybody.
08:26:03 <tdammers> at least in a programming context
08:26:04 <|Lupin|> I'm wondering: how to change the directory where Haskell packages are installed ?
08:26:19 <ski> scooty-puff : hm, confused by you having both a type `RefSupplyT', *and* a class `RefSupplyT' (mispaste ?)
08:26:30 <|Lupin|> (googled but couldn't find, not even in ghc's documentation)
08:26:35 <tdammers> |Lupin|: there's cabal-dev and friends
08:27:00 <tdammers> not *exactly* what you asked for, but maybe a sandbox is what you're looking for after all
08:27:29 <ski> tdammers : the argument being that "optimize" suggests reaching (at least a local) optimum, while "improve" would just suggest getting closer to one
08:27:51 <ski> (if you know a better term, please tell)
08:28:11 <tdammers> etymologically, you are probably right
08:28:26 <|Lupin|> tdammers: actually by default packages get installed under /usr/local/lib for global installs, I find that not very clean and would rather have them installed undr, say, /usr/local/lib/haskell...
08:28:31 <hpaste> scooty-puff annotated “RefSupplyT runRegion” with “RefSupplyT runRegion (annotation)” at http://hpaste.org/68235#a68236
08:28:32 <scooty-puff> yeah, must have, just the type, trying to make a type class that the runRegion could be RefSupplyT's implementation, but not that important
08:33:43 <hpc> @unmtl ContT r m a
08:33:44 <lambdabot> (a -> m r) -> m r
08:36:46 <|Lupin|> So is there no ay to tell GHC where to install packages ?
08:36:59 <mekeor> s/ay/way/
08:37:13 <|Lupin|> mekeor: yep thanks :)
08:37:15 <mekeor> |Lupin|: GHC can't install packages at all.
08:37:20 <mekeor> did you mean cabal?
08:37:29 <mekeor> or rather cabal-install..
08:37:35 <|Lupin|> mekeor: yep
08:38:03 <|Lupin|> mekeor: but I got the impression that cabal-install actually used something else to install packages
08:39:52 <geekosaur> ghc-pkg, but while you can tell it different places to install things, I don't think you can then easily tell ghc how to use them
08:40:01 <t7> open opengl guys in here
08:40:22 <t7> my perspective matrix is flipping the scene
08:40:26 <t7> only some times
08:42:07 <|Lupin|> geekosaur: well, one place would be enough...
08:42:37 <t7> omg
08:42:40 <t7> this is strange
08:44:09 <geekosaur> so, on unixy hosts ghc is a shell script which sets various locations, you could change that relatively easily.  no idea about how it's done on windows (possibly similar batch file wrapper)
08:44:26 <kmels> hi, how can I tell if Data.Proxy (from tagged) is contained in the haskell platform?
08:44:28 <geekosaur> I doubt changing things is well supported though
08:45:05 <hpaste> t7 pasted “help plz” at http://hpaste.org/68238
08:45:05 <|Lupin|> geekosaur: thanks for the hint about the shell script, good to know !
08:45:57 <|Lupin|> geekosaur: it surprises me a bit that I'd be the first user to find that filling /usr/local/lib with haskell libraries without putting all of them in a common subdirectory is not suitable...
08:47:21 <t7> whoops fov was wrong
08:48:27 <geekosaur> I have noticed it but it's kinda like how linux thinks thwacking everything into /usr/bin /usr/lib etc. with minimal organization because "the package manager should deal" is a good thing
08:48:47 <tromp_> > 524044 `modRem` 1
08:48:48 <lambdabot>   Not in scope: `modRem'
08:49:08 <tromp_> > 524044 `divMod` 13
08:49:09 <lambdabot>   (40311,1)
08:49:13 <geekosaur> quotRem or divMod
08:49:18 <tromp_> got it:)
08:49:44 <tromp_> > product [1..8]
08:49:44 <lambdabot>   40320
08:50:48 <|Lupin|> geekosaur: yeah well... the thing is the package manager does _not_ manage things correctly. What I mean is that to uninstall you have to remove and then unregister yourself...
08:51:17 <geekosaur> my point (well, snark) was more along the lines of "nobody else cares about maintainability any more, why should we?"
08:51:19 <|Lupin|> geekosaur: moreover other languages such as python, perl, ocaml, all install their libraries in a subdirectory under /usr/local/lib...
08:55:20 <|Lupin|> btw just would like to make clear that I'm not insisting on this to be unplesant or unpolite orto start a troll or whatever. It's a genuine question.
09:00:28 <quicksilver> |Lupin|: it's a little ugly to have the things directly in /usr/local/lib, but they're generally quite easy to identify as haskell packages
09:00:39 <quicksilver> |Lupin|: the version numbers are quite distinctive looking.
09:00:47 <quicksilver> |Lupin|: and you have ghc-pkg list to give you a list
09:01:00 <quicksilver> |Lupin|: so I think the tools make it harmless enough
09:01:09 <geekosaur> |Lupin|, if it wasnt clear, I'm not happy with the situation either.  but I also have no say in it
09:05:09 <|Lupin|> quicksilver: geekosaur: thanks for your comments. I believe I've found a solution. Just checking and will let you know.
09:06:29 <tromp_> > 524161 `divMod` 13
09:06:30 <lambdabot>   (40320,1)
09:08:01 <dzhus> is there any other way for implementing kind-of polymorphic except type classes, pattern matching or record-packed APIs?
09:08:24 <efie>  a phpBB forum uses a mysql database. is it possible to gain access to the database (if the owner of the forum agrees) using haskell? I would like to make a website where only people can register who are members of the forum. in the registration proces, they would have to enter the username/password which is stored in the database, so I need to check it
09:08:40 <hpc> @hoogle hdbc-mysql
09:08:41 <lambdabot> package HDBC-mysql
09:08:41 <lambdabot> package haskelldb-hdbc-mysql
09:08:53 <hpc> use the first one
09:09:46 <Eidel> DOes anyone know a good way to iterate through a binary tree?
09:10:01 <ski> recursion ?
09:10:07 <ski> a fold ?
09:10:18 <ski> in what way do you want to iterate ?
09:10:25 <dzhus> Eidel: Data.Traversable
09:10:35 <Eidel> An easy way ;)
09:10:54 <copumpkin> the answer depends on what you want to do at each step
09:11:02 <ski> do you just want to loop through the elements in some order ? preorder ? inorder ?
09:11:14 <copumpkin> are you constructing a new tree? performing some action at each node?
09:11:21 <ski> do you want to do something which depends on the tree shape, apart from element ordering ?
09:11:45 <Eidel> I have a completely sorted binary tree, and want to print the lowest integers
09:11:59 <efie> hpc: mysqlUser / mysqlPassword  woudl be the data of the adminstrator of the database?
09:12:35 <hpc> efie: they would be whatever user/password you want your program to use to access the db
09:12:56 * hpc doesn't know your configuration, and can't say much more than that
09:13:05 <Eidel> Or a better way to say it: want to print the integers in acsending order
09:13:11 <ski> Eidel : so something like `forM_', and throw an exception when you've had enough ?
09:14:29 <Eidel> Me dont know
09:17:33 <ski> Eidel : either manually do a function which translates (inorder/preorder/whatever) to a list, or implement `Foldable' (and possibly `Traversable') ?
09:18:08 <roconnor_> how do I convince cabal install to build mtlparse-0.1.2 using mtl-2.1.1 ?
09:19:06 <dcoutts> roconnor_: --constraint='mtl==2.1.1'
09:20:41 <roconnor_> how do I convince cabal install to build regexp using (mtlparse-0.1.2 using mtl-2.1.1) ?
09:21:06 <dcoutts> roconnor_: use multiple constraints
09:22:03 <Eidel> ski: I will try to define my own inorder
09:22:35 <roconnor_> hmm
09:22:48 <roconnor_> no matter what constaints I give cabal install I still get:
09:22:50 <roconnor_> package mtlparse-0.1.2 requires mtl-2.0.1.0
09:22:52 <roconnor_> package regexpr-0.5.4 requires mtl-2.1.1
09:22:53 <roconnor_> p
09:23:11 <dcoutts> then that's probably true
09:23:17 <conal> does the uniform pair functor/applicative/monad/foldable/traversable (data Pair a = a :# a) exist on hackage?
09:23:39 <conal> i've just added it to functor-combo, but i thought i'd check before releasing.
09:23:40 <roconnor_> dcoutts: regesp has no constraint on mtl
09:23:44 <roconnor_> *regexpr
09:23:53 <roconnor_> neither does mtlparse
09:26:05 <dcoutts> roconnor_: both of those versions are available as source from hackage? or are they local sources?
09:26:13 <ski> Eidel : just remember that left-nested `(++)'s is bad
09:26:15 <roconnor_> from hackage AFAIK
09:26:21 <roconnor_> maybe this is some sort of nixos thing
09:26:51 <roconnor_> seems unlikely
09:27:14 <dcoutts> roconnor_: you might get a hint if you use -v3, it'll say if they're "available" or "installed"
09:27:27 <dcoutts> if they're only installed, then there's no opportunity to rebuild with different deps
09:27:57 <|Lupin|> quicksilver: geekosaur: actually I have found and changed directory settings in Cabl's coniguration file, but they do not seem to be taken into account... wondering why...
09:28:24 <roconnor_> package mtlparse-0.1.2-710c72a704a2a188dd410c841f551759 is shadowed by package mtlparse-0.1.2-7a419a7740c647a1044ffed4978adeea
09:28:35 <roconnor_> because the latter has a larger hash, right?
09:28:47 <geekosaur> I presume that is cabal-install's configuration file; that does not control cabal-the-library as built into ghc
09:29:17 <roconnor_> maybe it is time I get cabal-dev :D
09:29:30 <|Lupin|> geekosaur: I'm talking about ~/.cabal/config.
09:29:35 <geekosaur> yes
09:29:41 <geekosaur> that is cabal-install
09:29:52 <geekosaur> it is regrettable that the names are so confusing
09:29:53 * hackagebot functor-combo 0.1.1 - Functor combinators with tries & zippers  http://hackage.haskell.org/package/functor-combo-0.1.1 (ConalElliott)
09:30:00 <|Lupin|> geekosaur: that file has been created by cabal-install itselfso I'm expecting cabal-install to take that file into account... or am I missing something ?
09:30:04 <geekosaur> the "cabal" command and ~/.cabal are part of cabal-install
09:30:08 <geekosaur> not the cabal library
09:30:38 <geekosaur> you made commnets earlier suggesting you wanted to change ghc, not cabal-install
09:31:00 <|Lupin|> geekosaur: it is the earlier comments that are wrong, I'm sorry.
09:31:01 <geekosaur> and cabal-install settings from ~/.cabal/config do not change ghc defaults / cabal-the-library
09:31:07 <|Lupin|> what I want to modify is cabal-install...
09:31:11 <geekosaur> only user settings
09:32:00 <|Lupin|> geekosaur: okay. So what I want to change, at the moment, is the behaviour of cabal-install. And then once this is done I'll figure out how to tell cabal-the-lib where the files are, if it needs to...
09:33:18 <|Lupin|> so I'm wondering why cabal-install does not take my modifications into account ? or does not seem to take them into account
09:33:27 <geekosaur> maybe you should describe the exact thing you are trying to achieve, not the mechanism.  you want X files to be installed at Y?
09:33:33 <|Lupin|> it uses a strange notation: $prefix/foo/bar
09:33:38 <|Lupin|> is that notation really supported ?
09:35:31 <|Lupin|> geekosaur: yes. When I do cabal install foo, I want that all the files of foo to be installed under /usr/local/lib/haskell/foo-.../whateverinsteadof /usr/local/lib/foo-.../whatever
09:36:02 <geekosaur> ok, so I will repeat what I said earlier.  "<geekosaur> and cabal-install settings from ~/.cabal/config do not change ghc defaults / cabal-the-library"
09:38:19 <|Lupin|> Installing library in /usr/local/lib/haskell/semigroups-0.8.3/ghc-7.4.1
09:38:22 <|Lupin|> that's it !
09:38:43 <|Lupin|> Installing library in /usr/local/lib/haskell/semigroups-0.8.3/ghc-7.4.1
09:39:29 <|Lupin|> Actually I modified the settings in .cabal/config but forgot to uncomment them... that's why they were not taken into account. Now everything works as expected...
09:39:43 <kkyqqp> I have a list of lists, and I want to get a union of the lists with repetition, that is, from [[1,1],[1,2,2],[1,2,3]] I would get [1,1,2,2,3], is there any function that would make this really simple?
09:39:53 <dcoutts> |Lupin|: get it working how you wanted? You do get full control over where files are installed, via the prefix, libdir etc etc, and yes they can use variables
09:40:30 <|Lupin|> dcoutts: yes, I think now it works according to my wishes, thank you.
09:40:31 <saml> if i develop web app in haskell, haskell guarantees proper UI rendering and behavior, right because of type safety
09:40:35 <nominolo> preflex: seen bos
09:40:35 <preflex>  bos was last seen on #ghc 3 days, 11 hours, 27 minutes and 48 seconds ago, saying: anyone home?
09:41:32 <geekosaur> so, did that actually work?  as in, did it then update the correct package.conf? or did it create a new one under /usr/local/lib/haskell (which is what I thought it would do if you overrode that in cabal-install instead of ghc)
09:41:32 <|Lupin|> okay, enough coding for today
09:41:37 <|Lupin|> thank you for your help
09:41:43 <geekosaur> well, package,conf.d
09:41:52 <geekosaur> package.conf.d
09:42:04 <|Lupin|> geekosaur: thanks for your patience with me. I'm sorry I was so confused in how I asked questions. Your answers helped a lot.
09:42:06 <hpc> saml: sure, if you think up the right types
09:43:36 <|Lupin|> geekosaur: what I wnated to change was not the location of the package database... it was the locatin where cabal-install installsthe haskell packages it builds... do you understand me ?
09:44:12 <geekosaur> right, but my understanding (and some experimentation, admittedly with an older version) was that changing that path in cabal-instal changed where it thought the package database was as well
09:44:32 <geekosaur> which then meant it was updating a package db that ghc wasn't paying attention to
09:44:57 <hpc> @unmtl Cont () a
09:44:57 <lambdabot> (a -> ()) -> ()
09:45:09 <copumpkin> that's a useful one
09:45:13 <hpc> heh
09:45:41 <hpc> i think in agda, Cont Void is the double-not monad
09:46:02 <hpc> whoops, this was meant for -blah
09:46:31 <|Lupin|> geekosaur: since I'm a total newbie in haskell I may very well be totally wrong, but I believe your understanding is not correct... To me, package db path and library installatino path are two distinct things...
09:48:19 <|Lupin|> will go now. Starving.
09:48:29 <|Lupin|> Bye. Till soon.
09:49:06 <tromp_> > 1572481 `divMod` 13
09:49:07 <lambdabot>   (120960,1)
09:49:16 <tromp_> > product [1..9]
09:49:16 <lambdabot>   362880
09:49:42 <tromp_> > 3 * product [1..8]
09:49:42 <lambdabot>   120960
09:50:51 <geekosaur> that said... at one point the ghc stuff I had on this machine (an early official haskell platform package for OS X) was doing some very strange things, path-wise
09:51:25 <geekosaur> glerh.  notwork... and I don't get notifications any more.  craptacular.
09:55:19 <bos> nominolo: ?
09:58:25 <tromp_> > 365*144
09:58:26 <lambdabot>   52560
10:02:50 <yrlnry> > sqrt(119)
10:02:51 <lambdabot>   10.908712114635714
10:03:06 <yrlnry> Hey, that's a lot easier than firing up bc() in the shell.
10:03:32 <tromp_> yeah; i abuse #haskell as a desktop calculator
10:05:17 <edwardk> preflex: xseen roconnor
10:05:17 <preflex>  roconnor was last seen on freenode/#haskell 1 day, 1 hour, 30 minutes and 49 seconds ago, saying: merijn: for now I think I'll leave it out; but if I'll be on the look out for it in other contexts.
10:08:29 <hpaste> dzhus pasted “Infinity in Haskell: which is faster?” at http://hpaste.org/68243
10:09:05 <edwardk> dzhus: the double based infinity will probably be faster
10:09:06 <Zenith77> Is anyone here familar with cycle detection?
10:09:46 <Tinned_Tuna> Ok, Wadler just won my heart with his ancient monads paper: "To make this change in animpure language is left as an exercise for masochistic readers."
10:09:48 <edwardk> Zenith77: yes
10:09:56 <edwardk> Tinned_Tuna: =)
10:11:00 <Zenith77> edwardk: familar with the tortoise and the hare technique?
10:11:03 <scooty-puff> will DoRec always result in the mfix being made as tight as possible?
10:11:18 <edwardk> Zenith77: yeah. i was going to suggest it if you hadn't seen it
10:11:30 <edwardk> scooty-puff: within reason, yes
10:13:01 <Zenith77> edwardk: well I may just be having a misunderstanding with it. But if you have something like 32 45 43 25 43 33 33 33 33 33
10:13:12 <Zenith77> Is it possible, or perhaps likely, that it would detected the "43" first
10:13:16 <Zenith77> and cause it to signal a loop
10:13:17 <Zenith77> ?
10:13:39 <scooty-puff> is there any way to have any other construct treated as so - tightened as much as possible?  for example, make runST as tight as possible (no exactly clear..) - runST $ do return (); s <- newSTRef (); readSTRef s; --> let _ = () in runST ...
10:13:42 <edwardk> Zenith77: the pointer/hare is referring to node pointers not the contents
10:13:43 <Zenith77> Or am I just misunderstanding what the algorithm is doing
10:14:00 <scooty-puff> *not exactly clear
10:14:06 <edwardk> you need something unique to each node
10:14:14 <Zenith77> ok
10:14:16 <Zenith77> hrm
10:14:22 <edwardk> pointer equality is the usual trick
10:14:28 <kallisti> shapr: hm, so I'm thinking I want to newtype my tree representation
10:14:50 <Zenith77> hrm
10:14:53 <kallisti> because some of the functions I could expose change the representation of the tree such that others will break.
10:15:07 <kallisti> so really I should have a newtype which always holds a "correct" representation
10:15:17 <kallisti> and then the functions that mess up that representation are just a regular Tree
10:15:27 <kallisti> s/are just/just return/
10:15:46 <scooty-puff> runStuff :: (forall s . m s a) -> m s a, tighten as much as possible in making sure the forall'd s is respected?
10:16:18 <scooty-puff> meh, probably not..
10:16:48 <scooty-puff> maybe abusing DoRec desugraing and RebindableSyntax, but wouldn't be at all clear
10:17:12 <Zenith77> edwardk: so is there an algorithm that detectes repition in a series of numbers?
10:17:35 <Zenith77> Or is it assumed, that the same number in a list will have equivelant pointers
10:17:38 <ski> uncomputable
10:17:43 <Zenith77> if it repeats that is
10:17:59 <edwardk> you're stepping out into uncomputable territory if you have an infinite list
10:18:07 <rwbarton> obviously if you just have a sequence of numbers you need some extra information to decide whether it eventually cycles
10:18:12 <rwbarton> since you cannot examine the whole list
10:18:23 <Zenith77> I mean, if you have a finite list
10:18:28 <ski> Zenith77 : let's say the list starts with `4',`4',`4',`4',... -- is it repeating with cycle length one ?
10:18:30 <Zenith77> is there no known alogrithm?
10:18:38 <Zenith77> I would say yes
10:18:43 <Zenith77> if you're asking me
10:18:49 <rwbarton> if you have a finite list then i don't understand the question
10:19:08 <ski> what if i tell you the next element is `2^(2^(2^(2^(2^0))))' ?
10:19:13 <rwbarton> i suspect there is no actual question at all
10:19:26 <Zenith77> What's confusing about the question?
10:19:31 <rwbarton> it doesn't appear to exist
10:19:47 <rwbarton> it is just like, do i think this probably repeats? not a real question
10:19:53 <ClaudiusMaximus> Zenith77: where are the numbers coming from?  if they're coming from some function that you know to be deterministic, then you can use node labels like a_{n-1} or (a_{n-1}, a_{n-2}) or whatever the inputs are
10:20:07 <byorgey> rwbarton: read back further.  Zenith77 was asking about the behavior of a particular algorithm on a particular input.
10:20:35 <rwbarton> it doesn't seem like valid input for the algorithm in question
10:20:40 <ski> Zenith77 : hm, for a finite list, i suppose you coul keep track of places where it possibly repeats, and check it up when you reach the end
10:20:41 <kallisti> hm, maybe I should give my Tree type lenses.
10:20:49 <rwbarton> since it is the wrong kind of thing
10:20:52 * ski isn't aware of a known algorithm for this
10:20:59 <t7> haskell glut on my windows 7 doesnt terminate the program when i close the window
10:21:03 <t7> but it did at work
10:21:18 <Zenith77> I'm not either, but it's a programming challenge. I have an algorithm that splits up a list into chunks read from a file and kind of just sees if they repeat. But it's very...inefficent
10:21:26 * ski . o ( "what's wrong with glasses ?" )
10:21:42 <Zenith77> Was just wondering if there was a known alogirthm. It's written in PHP, but I don't dare ask anything complicated in there
10:21:48 <rwbarton> "kind of just sees if they repeat" is exactly the kind of thing i am talking about
10:22:06 <Zenith77> Oh really?
10:22:15 <rwbarton> you need to specify the question before you can start asking for an algorithm
10:22:35 <ski> Zenith77 : given a list `xs', do you want to find the greatest `n', and an `ys', such that `xs = concat (replicate n ys)' ?
10:23:46 <ClaudiusMaximus> Zenith77: maybe try fft-based autocorrelation and extract some peaks http://en.wikipedia.org/wiki/Autocorrelation#Efficient_computation
10:24:25 <Zenith77> The question was originally, based on a misunderstanding of how the tortoise and hare algorithm worked. I thought the idea was to parse over the contents of a list, not just see if the pointers are pointing to the same area of memory. My understanding was that (in the case it was using the contents) that a list like  0 3 43 2 5 43 8 2 that the algorithm would detect that it was cyclic
10:24:50 <rwbarton> that algorithm makes an assumption, if you are going to try to execute it on a list of numbers
10:25:09 <rwbarton> that assumption is that there is some function f such that each term is f applied to the previous term
10:25:31 <rwbarton> so if two terms in the sequence are equal, the terms after them are also equal
10:25:36 <ski> Zenith77 : that list doesn't appear to be cyclic, in any nontrivial sense
10:25:48 <rwbarton> your input list doesn't satisfy that assumption
10:25:48 <byorgey> right, so that list in particular is not a valid input, because two different numbers follow occurrences of 43
10:25:49 <Zenith77> The numbers I gave were not
10:25:54 <Zenith77> Thank you
10:26:34 <Zenith77> byorgey: ^
10:27:01 <rwbarton> if you just give an arbitrary finite list of numbers, it's not at all clear what it would mean for it to be "cyclic"
10:27:23 <byorgey> I think what ski said would be a reasonable specification.
10:27:36 <ski> rwbarton : i gave one possible meaning, assuming you want `n' greater than `1'
10:27:37 <rwbarton> it is one possibility, sure
10:28:20 <ski> you could also allow a leading "hair" if you prefer
10:29:26 <rwbarton> what about 1,2,3,4,1,2,3,4,1,2, is that cyclic
10:30:05 <byorgey> given xs, find the shortest hs and greatest n, and ys and rem such that xs = hs ++ concat (replicate n ys) ++ rem  and  length rem < n  and  rem `isPrefixOf` ys
10:30:40 <byorgey> well, the second condition is implied by the third
10:31:17 <ski> byorgey : maybe also with `hs' an element of `tails ys', and `rem' an element of `inits ys', for rwbarton's case
10:31:43 <byorgey> ski: my intention with 'hs' was to allow for a leading 'hair'
10:32:20 <byorgey> rem `elem` inits ys  is equivalent to  rem `isPrefixOf` ys, I think
10:32:23 <ski> yea, i just symmetrized it a bit :)
10:32:39 <ski> (didn't seee the `isPrefixOf' part first)
10:33:00 * ski is reminded of finite rigs
10:33:02 <byorgey> I don't think yours is equivalent though, I had in mind something like   9, 17, 12, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2
10:33:24 <ski> *nod*, it wasn't intended to be equivalent
10:33:26 <byorgey> finite rigs? why?
10:33:43 <Zenith77> I fear I've stretched too much and managed to pull an intellectual muscle
10:33:48 <byorgey> hehehe
10:34:09 <ski> well, e.g. something like `5 + |N / (3 * |N)'
10:34:13 <byorgey> Zenith77: not possible, that's the feeling of your brain growing
10:34:20 <Zenith77> :P
10:34:24 <ski> `5' here is a "hair"
10:34:30 <byorgey> ski: I see
10:34:51 <ski> byorgey : i've mostly been pondering such when thinking about primitive roots and discrete logarithms in finite rings
10:35:02 <byorgey> ah, ok, makes sense
10:36:15 <Zenith77> Well, thank you for your time everyone. If you continue I'll just be watching.
10:39:08 <ski> (basically, if you take powers of a non-invertible element in a finite ring, it appears the exponent naturally wants to live in such a rig -- then one can consider tuple of elements raised to a tuple of exponents -- &c.)
10:40:55 <sclv> byorgey: seen this? http://stackoverflow.com/q/10453558/371753
10:41:20 <byorgey> sclv: nope, thanks
10:41:36 <sclv> i've been pondering if there's any reasonable direct way to go from a polymorphic type to the number of inhabitants.
10:41:47 <sclv> did you get further than yr. explorations with linear inhabitants?
10:41:51 <sclv> it seems devilishly hard.
10:41:58 <sclv> don't know if there's prior work.
10:43:55 <rwbarton> http://math.ucr.edu/home/baez/week240.html is relevant to that SO post
10:44:12 <hpc> sclv: perhaps something like this:
10:44:19 <hpc> 1. move foralls as far right as possible
10:44:29 <hpc> ie, unsafeCoerce :: forall a. a -> forall b. b
10:44:38 <hpc> (this is a no-op)
10:44:41 <Alan> what does forall actually do?
10:45:20 <hpc> 2. count the inhabitants of each inner forall with some simple method
10:45:26 <hpc> 3. expand out
10:45:52 <hpc> so unsafeCoerce = forall a. a -> forall b. b
10:46:00 <hpc> unsafeCoerce = forall a. a -> 0
10:46:09 <c_wraith> Alan: it introduces the scope for a type variable. In normal use cases, it's optional. Some use cases require it to be provided explicitly. Those cases all use language extensions
10:46:18 <hpc> unsafeCoerce = 0 -> 0
10:46:31 <hpc> hmm, that's 1
10:46:35 <hpc> perhaps not
10:46:57 <Alan> c_wraith: is it a "hack" to stop the compiler limiting the range of types that are valid for the function?
10:47:09 <ski> rwbarton : was thinking about it, but figuring it too much work to dig out which one it was :)
10:47:23 <c_wraith> Alan: nothing like that. It's just for scoping type variables.
10:47:46 <ski> Alan : it specifies that the corresponding value should be polymorphic
10:48:30 <ski> Alan : if your `forall's are all on the "top-level" of the signature, you can omit them (modulo some cases where there are already tyvars in scope)
10:48:40 <hpc> in some sense, it corresponds to type-level lambda
10:48:57 <hpc> (not in haskell though, for various reasons)
10:49:21 <byorgey> sclv: no, I didn't.  It does seem quite hard.
10:49:22 <ski> hpc : i think the step to `0 -> 0' isn't right
10:49:59 <ski> hpc : type-level lambdas are different
10:50:36 <c_wraith> In the context of the Rank2Types or RankNTypes extensions, explicit foralls let you express types that you can't otherwise. In the context of the ScopedTypeVariables extension, explicit foralls just let you refer to that type variable in type annotations inside the expression
10:50:50 <ski> hpc : `forall a. ..a..' is basically the same as `Pi (\a -> ..a..)', where `\a -> ..a..' is a type-level lambda
10:51:39 <ski> hpc : however .. (in System F), it's related to *terms* taking types as input -- like `/\a -> \(x :: a) -> x'
10:52:41 * ski misses `PatternSignatures'
10:56:48 <Clint> dcoutts: around?
10:58:01 <sclv> hpc: that doesn't get you very far.
10:58:30 <sclv> oh, you already realized.
10:58:40 <sclv> i mean, consider even things built with only one outer forall.
10:59:19 <sclv> i can tell you how many inhabitants forall a. ((a,a) -> a) -> (a,a,a,Bool) -> a has.
10:59:32 <sclv> and i can write a formula for it.
10:59:34 <roconnor_> how do I cabal remove?
10:59:54 <sclv> but i can't write a rule to relate that formula to forall a. ((a,a) -> a) -> (a,a,a,Bool) -> (a,a)for example.
10:59:57 <sclv> in a uniform way.
10:59:58 <c_wraith> roconnor_: no such thing
11:00:04 <sclv> roconnor_: ghc-pkg remove
11:00:19 <sclv> does what you want.
11:01:05 <Saizan> s/remove/unregister/ ?
11:01:10 <sclv> (actually, in that case, i sort of can... but there's others i can't)
11:01:10 <c_wraith> unless what you want is disk space back
11:01:17 <sclv> Saizan: oops, yes :-)
11:01:20 <c_wraith> because unregister doesn't delete anything
11:01:40 <roconnor_> no I just want cabal to stop selecting packages of the same version based on which has the larger hash
11:01:58 <sclv> eep
11:02:05 <roconnor_> meh, I'll just delete random things in .cabal
11:02:22 <c_wraith> I hope one of the GSoC projects related to cabal succeeds well enough to reduce problems like that
11:02:23 <sclv> ghc-pkg unregister is just fine! really!
11:02:48 <Saizan> roconnor_: deleting in .cabal doesn't help
11:02:54 <roconnor_> Saizan: oh right
11:02:58 <Saizan> roconnor_: use ghc-pkg unregister
11:03:08 <roconnor_> ghc-pkg is broken on nixos :(
11:03:14 <roconnor_> brokenish
11:03:41 <Saizan> well, delete random things in ~/.ghc then :)
11:03:56 <roconnor_> ah
11:04:25 <sclv> roconnor_: it works, i think, just by altering yr. package.conf
11:04:28 <Phlogistique> Isn't there anything more handy to use than GetOpt?
11:04:41 <roconnor_> sclv: ya
11:04:42 <sclv> for options parsing?
11:04:47 <Phlogistique> sclv: yes
11:05:10 <Phlogistique> for example, with automatic help and version options, and a concise DSL
11:05:23 <ski> sclv : interesting problem ..
11:05:41 <sclv> Phlogistique: lots of ppl like ndm's cmdargs
11:06:23 <Phlogistique> sclv: thanks
11:06:42 <sclv> Phlogistique: there are lots of other packages on hackage too
11:07:37 <Phlogistique> sclv: I'd rather use something rather widely used (or small enough to be embeddable in my sources)
11:07:38 <sclv> ski: it seems really hard. it clearly turns into combinatorics quickly. but the trick is what if any algebraic/compositional rules you can uniformly apply to get the combinatorial equations.
11:07:43 <Phlogistique> sclv: so CmdArgs will do
11:09:59 * hackagebot scotty 0.4.2 - Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp  http://hackage.haskell.org/package/scotty-0.4.2 (AndrewFarmer)
11:10:09 <ski> sclv : yeah, i don't know
11:10:26 * ski considers hacking around a bit with lambdaProlog to see if anything suggests itself
11:12:51 <jfischoff> what is the work around for using two packages that both declare the same module?
11:13:59 <parcs`> delete one of the packages, hide one of the packages, use PackageImports
11:15:52 <jfischoff> parks`: but I want to use both packages in the same project
11:18:18 <roha> is it possible to make a type (Int,Int,Double,Double) an instance of Ord so that i can use Data.List.minimum on a list of those tuples?
11:18:32 <ski> should already be an instance of `Ord'
11:19:02 <roha> it should only be sorted according to the last element in the tupel
11:19:15 <ski> > ((2,3,4.0,5.1) :: (Int,Int,Double,Double)) > (5,1,9.3,18.2)
11:19:15 <lambdabot>   False
11:19:42 <ski> roha : `minimumBy (comparing (\(_,_,_,x) -> x))'
11:20:01 <roha> ski, awesome, exactly what i was looking for!
11:20:04 <roha> thanks
11:20:30 <ski> > minimumBy (comparing (\(_,_,_,x) -> x)) ([(2,3,4.0,5.1),(5,1,9.3,18.2)] :: (Int,Int,Double,Double))
11:20:30 <lambdabot>   Couldn't match expected type `(GHC.Types.Int,
11:20:31 <lambdabot>                              ...
11:20:40 <ski> > minimumBy (comparing (\(_,_,_,x) -> x)) ([(2,3,4.0,5.1),(5,1,9.3,18.2)] :: [(Int,Int,Double,Double)])
11:20:40 <lambdabot>   (2,3,4.0,5.1)
11:20:42 <roconnor_> cabal confuses me
11:21:02 <Clint> sometimes it confuses itself
11:21:04 <roconnor_> I don't know why it instists that package mtlparse-0.1.2 requires mtl-2.0.1.0
11:22:55 <romildo> Which module defines the type operator :&: ?
11:23:06 <roconnor_> Data.Bits ?
11:23:13 <roconnor_> oop
11:23:17 <roconnor_> type operator
11:23:19 <parcs`> jfischoff: then PackageIMports
11:23:26 <roconnor_> @hoogle (:&:)
11:23:27 <lambdabot> No results found
11:23:57 <sclv> just realized something wild.
11:24:14 <sclv> forall a. (a -> a) -> a, and forall a. (a -> a) -> (a -> a) -> a
11:24:21 <sclv> these both have infinite inhabitants.
11:24:29 <sclv> but by diagonalization they're different infinities.
11:24:37 <conal> is there a standard(ish) function of type MonadPlus m => Bool -> a -> m a ?  I didn't find one on hoogle.
11:24:38 <romildo> It is used in "Generic Selections of Subexpressions" in the context of abstract syntax tree annotations using Annotations and multirec.
11:24:51 <sclv> so this gets really tricky *really* fast.
11:25:29 <nejucomo> It is possible to define my own Typeable instance?  I don't see a public TypeRep constructor.
11:25:29 * roconnor_ 's head expodes
11:26:00 <parcs`> conal: 'a <$ guard b' ?
11:26:51 <conal> parcs`: nice :) . thx.
11:27:07 <Baughn> I'm looking for any work on optimizing the /order/ of graph reduction to reduce memory usage.. this seemed like a good place to ask? :)
11:27:16 <roconnor_> why cabal why?
11:27:35 <sclv> Baughn: go on.
11:27:54 <sclv> graph reduction as in evaluation, or graph reduction on yr own graph structure?
11:28:03 <roconnor_> package mtlparse-0.1.2-710c72a704a2a188dd410c841f551759 is shadowed by package mtlparse-0.1.2-7a419a7740c647a1044ffed4978adeea
11:28:06 <Baughn> sclv: Both.
11:28:06 <danr> @hoogle (.&.)
11:28:06 <lambdabot> Data.Bits (.&.) :: Bits a => a -> a -> a
11:28:06 <lambdabot> Test.QuickCheck.Property (.&.) :: (Testable prop1, Testable prop2) => prop1 -> prop2 -> Property
11:28:06 <lambdabot> Test.QuickCheck (.&.) :: (Testable prop1, Testable prop2) => prop1 -> prop2 -> Property
11:28:15 <sclv> yeek.
11:29:07 <sclv> Baughn: you're aware of `seq` and `deepSeq` i assume?
11:29:27 <Baughn> sclv: Yes. It's not really a haskell problem, it just seemed like the most likely place to find someone who'd thought about it.
11:29:55 <Baughn> Given that lazy evaluation = graph reduction, someone must have considered how to optimize the ordering, even in principle
11:30:53 <sclv> Baughn: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.90.2386 ?
11:30:56 <lamefun2> where is swap control in Haskell's SDL binding?
11:31:14 <jfischoff> parcs`: where do i find more information on package imports?
11:31:39 <Baughn> sclv: Hm, probably not
11:31:54 <jfischoff> s /package imports/ PackageImports
11:34:14 <sclv> this is slightly more recent. Don't know what else there may be: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.641
11:35:44 <parcs`> jfischoff: http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/syntax-extns.html#package-imports
11:36:07 <jfischoff> parcs`++
11:36:25 <Baughn> sclv: Looks good. :)
11:36:43 <Baughn> Don't know yet if it'll be useful, but he's tackling the right problem area, at least
11:42:51 <sully> does ghc have an incremental garbage collector?
11:42:59 <Baughn> No
11:43:22 <dzhus> is there something like language-haskell library?
11:43:29 <dzhus> (like language-c)
11:43:29 <Baughn> sully: But you may not need one. The built-in GC is fast enough for most purposes, at least on modern hardware; the pauses are minimal.
11:43:57 <sclv> dzhus: haskell-src-exts
11:44:19 <Baughn> dzhus: Also hint, hs-plugins, etc. if you want to actually load code
11:44:39 <sclv> or template haskell if you want to splice in generated code at compile time
11:44:51 <sully> Baughn: sure, but if you are trying to build a network service with really low latency
11:44:57 <sully> or rather, with predictable latency
11:45:09 <Baughn> sully: Then you probably want C++
11:45:22 <Baughn> sully: I'll give you this: Haskell is much better than Java for the purpose.
11:45:24 <sully> I mean, but I don't want C++
11:45:34 <Baughn> Then you may want to reconsider your latency requirements
11:45:45 <Baughn> GC pauses are usually <1ms
11:45:48 <sully> (I also don't actually need to build such a network service)
11:45:49 <sclv> sully: if you want hard real time then you can't use a language with gc.
11:46:00 <sclv> you can use an edsl in haskell built for just such a purpose.
11:46:02 <sclv> like, e.g., atom
11:46:09 <sully> sclv: that's not quite true
11:46:30 <sully> Cheng and Blelloch designed a parallel concurrent real-time garbage collector with provable bounds on time and space
11:46:47 <sclv> and this gc is implememented by which language?
11:46:53 <sclv> s/language/language runtime/
11:47:13 <aristid> sclv: the point isn't that it's practical, but that it's possible, i think.
11:47:14 <sully> they implemented it in a SML runtime
11:48:14 <yan_> is there a way to take the src i wrote and have cabal calculate all the dependencies it needs automaticaly?
11:48:55 <parcs`> i don't think so
11:49:01 <sclv> my pointw as more that i don't know of anyone doing hard real time with fancy gc. one day we may have a language runtime that gives it and ppl use.
11:49:13 <sclv> but in the meantime...
11:49:44 <sully> I mean, soft real time is probably good enough
11:50:16 <hpaste> ski annotated “compiling pattern-matching, preliminaries” with “compiling pattern-matching, staged version (compiling), using implicit composable-continuation side-effects ("direct-style")” at http://hpaste.org/68245#a68248
11:51:28 <sully> the big problem is that "usually <1ms" isn't always good enough
11:51:40 <ski> (that's highlighted as OCaml, since hpaste apparently doesn't have SML highlighting)
11:51:56 <sully> like, if one in a thousand times it takes 300ms
11:51:57 <ClaudiusMaximus> supercollider apparently has an incremental realtime garbage collector, though i don't know any more details
11:52:25 <sully> you need to plan for that when you provision your servers
11:54:37 <ski> (well, it's really in MetaML, but it's an extension of SML, so ..)
11:58:06 <bgamari> How does one invert an axis of a Repa array?\
11:58:56 <bgamari> I guess backpermute would work
12:03:56 <kallisti> edwardk: does the function map Newtype  have any overhead?
12:04:09 <kallisti> I imagine it has some negligible but non-zero overhead.
12:04:11 <edwardk> ?
12:04:22 <edwardk> the Functor for (->) e ?
12:04:31 <edwardk> not sure i follow the question
12:04:35 <kallisti> no, mapping a newtype wrapper over a list.
12:04:46 <edwardk> oh, yeah, that has annoying overhead
12:04:56 <edwardk> i confess i've been known to cheat
12:05:01 <kallisti> unsafeCoerce? :P
12:05:04 <kallisti> that was my second question.
12:05:44 <edwardk> well, more like unsafeMapNewtype :: (Functor f, Newtype n o) => (o -> n) -> f o -> f n; unsafeMapNewtype = unsafeCoerce
12:05:59 <edwardk> and the reverse
12:06:13 <kallisti> oh..
12:06:30 <edwardk> that way you at least get some modicum of safety =)
12:06:36 <kallisti> what is this Newtype class business.
12:06:47 <edwardk> its in the 'newtype' package djahandarie wrote
12:07:05 <edwardk> http://hackage.haskell.org/packages/archive/newtype/0.2/doc/html/Control-Newtype.html
12:07:24 <edwardk> ala Sum foldMap [1,2,3,4]
12:08:17 <ski> edwardk : how about coercions ?
12:08:19 <kallisti> interesting.
12:08:22 <ski> somewhere around <http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes#Representationofcoercionassumptions>
12:08:42 <edwardk> ski: that might work as well
12:09:16 * ski has pondered `newtype k (Flip f b a) = MkFlip (k (f a b))'-like stuff before ..
12:10:44 <edwardk> newtype k (Flip f b a) = ?
12:10:46 <oddraisent> Is there any loop in monads? Like forever, but with some condition
12:11:22 <edwardk> ski: ah, that makes my head hurt
12:13:14 <ski>   MkFlip :: forall_kind k0 k1 k2. forall (a :: k0) (b :: k1) (f :: k0 -> k1 -> k2) (k :: k2 -> *). k (f a b) -> k (Flip f b a)
12:13:20 <ski> edwardk ^
12:13:47 <ski> just like `newtype Foo a = MkFoo (..a..)' defines a family of types `Foo a', one for each type `a'
12:14:19 <ski> `newtype k Foo = MkFoo (..k..)' will define a family of types `k Foo', one for each type `k'
12:14:29 <edwardk> ski: i'm somewhat leery that that is going to get you in trouble when you apply it to k = Set ;)
12:14:32 <ski> there needs to be some restrictions on where `k' can occur though, of course
12:15:32 <ski> edwardk : well, that trouble already exists ..
12:15:36 <saml> k :: k
12:16:11 <edwardk> ski: that was why i required functoriality
12:16:31 <kallisti> edwardk: yeah there was quite a bit of overhead just from adding/remove newtype constructors
12:16:57 <kallisti> that basically disappears with unsafeCoerce.
12:17:10 <kallisti> (I gave it a type signature just to be safe)
12:17:35 <ski> edwardk : i think part of the problem here might be using `newtype' or `data' to implement quotient and/or sub types, using an abstraction barrier
12:17:44 <edwardk> kallisti: yeah, i use a similar trick inside of the AD package, based on exploiting a bug in generalized newtype deriving
12:18:34 <kallisti> o_O
12:18:58 <edwardk> class Iso a b where iso :: f a -> f b; osi :: f b -> f a; instance Iso a a where iso = id; osi = id; newtype Foo a = Foo a deriving (Iso a, …)
12:19:03 <kallisti> you should never tell anyone how you do these things.
12:19:14 <kallisti> they may think your code is unsafe to use.
12:19:16 <edwardk> hah
12:19:39 <edwardk> i can always replace calls to iso/osi with calls to fmap
12:20:33 <ski> oddraisent : something like `m (Maybe a) -> m a' ?
12:21:33 <ski> @type let untilJust act = act >>= maybe (untilJust act) return in untilJust
12:21:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (Maybe a) -> m a
12:21:58 <kallisti> is there anything like mueval that takes advantage of Safe Haskell?
12:22:05 <kallisti> instead of using explicit whitelists?
12:23:13 <tgeeky> kallisti: not yet
12:26:21 * kallisti thinks that, in order for it to really be secure, it has to ignore Trustworthy pragmas.
12:26:48 <sclv> i have a very secure haskell evaluator.
12:26:53 <kallisti> you could have an explicit whitelist for Trustworthy packages.
12:27:01 <sclv> i call it `> /dev/null`
12:27:07 <kallisti> oh nice
12:27:11 <kallisti> it's even efficient.
12:27:36 <kallisti> and it completely avoids all side-effects
12:27:37 <kallisti> cool.
12:28:08 <bitonic> I'm not sure I get the point of Safe Haskell, given that THrustworthy pragma
12:28:26 <bitonic> aren't we just going to end putting Thrustworthy everywhere?
12:29:08 <Cale> That's quite a Freudian slip you've got there.
12:30:36 <Cale> But the idea is not to put Trustworthy on things which are not.
12:31:06 <Cale> Obviously the system only works if people are reasonable about its use.
12:32:56 <kallisti> s/are readonable about/don't exploit/
12:33:21 <kallisti> *reasonable  hlep waz anglish?
12:33:30 <roconnor_> haskeline is outdated  :(
12:34:20 <saml> what's better yesod vs. snap
12:34:56 <Cale> saml: My understanding is that they're incomparable
12:35:34 <bitonic> Cale: how do you decide what is thrustworthy?
12:35:45 <Cale> bitonic: you *really* don't want that h
12:35:49 <Cale> after the t
12:35:53 <bitonic> ahahah right.
12:35:56 <bitonic> my spelling is bad.
12:36:09 <bitonic> trusthworty. trustworthy.
12:36:53 <bitonic> anyways, how do you decide what is trustworthy? testing? proof of correctness? gut?
12:37:24 <rwbarton> dons decides
12:38:04 <bitonic> I mean it's arbitrary, and thus I'm not sure how much can it work... it's like the "portability" and "stability" stuff on hackage
12:38:04 * roconnor_ thinks it is in fact impossible to compile hledger
12:38:12 <bitonic> those are completely useless
12:38:20 <Cale> http://www.haskell.org/ghc/docs/7.2.2/html/users_guide/safe-haskell.html#safe-language
12:38:25 <Cale> ^^ that's what we're aiming for
12:39:02 <roconnor_> is it at all possible to build tranformers 0.2.1 with GHC 7.* ?
12:39:24 <bitonic> roconnor_: ofc
12:39:41 <bitonic> roconnor_: if hackage can build hledger (and it did) I'm sure we can as well
12:39:57 <bitonic> Cale: yeah but the problem is that it's still a human that decides :P
12:40:07 <Cale> That's not a problem, that's a requirement
12:40:19 <Cale> It's formally impossible for a machine to decide this.
12:40:29 <bitonic> Cale: I know
12:40:58 <Cale> So at best, all you're going to get is an approximation anyway
12:40:59 <bitonic> but it's like having a "correctness" field
12:41:07 <Cale> Sure
12:41:07 <td123> roconnor_: I just built hledger with ghc 7.4.1
12:41:08 <bitonic> it's not going to be useful
12:41:15 <Cale> Except that there are meaningful distinctions here
12:41:28 <Cale> You can *want* to write a non-Trustworthy package
12:41:56 <Cale> For example, any module which exports unsafePerformIO is clearly not Trustworthy
12:42:03 <Cale> But the FFI is damn useful.
12:42:05 <bitonic> Cale: I can only think of Debug.Trace and unsafe functions
12:42:06 <bitonic> yeah
12:42:14 <Cale> That's what we're distinguishing here.
12:42:19 <roconnor_> td123: what version of mtl and transformers?
12:42:32 <bitonic> Cale: fair enough then
12:43:37 <td123> roconnor_: mtl-2.0.1.0 transformers-0.2.2.0
12:44:29 <td123> roconnor_: oh right, I'm using old versions of those libs, there might be problems with the newer libs
12:44:36 <roconnor_> is there some way I can get cabal to run --get-pkg-conf?
12:44:47 <roconnor_> td123:  no no, that is the correct solution
12:44:52 <bitonic> Cale: then why is Data.ByteString.Unsafe "Safe-inferred"?
12:45:07 <roconnor_> I just can't get haskeline to install
12:45:27 <Cale> sorry?
12:45:30 <Cale> What do you mean by that?
12:46:30 <bitonic> Cale: the Data.ByteString.Unsafe module is marked as "Safe-referred", at least on my machine
12:46:32 <ski> bitonic : you can selectively decide in which packages you want to trust the `TrustWorthy' pragma
12:46:42 <tgeeky> Cale: http://hackage.haskell.org/packages/archive/bytestring/0.9.2.1/doc/html/Data-ByteString-Unsafe.html <-- top right corner
12:46:54 <tgeeky> Cale: this is probably just safehaskell confusion
12:47:05 <roconnor_> ghc-pkg register haskeline-0.6.4.6.conf --user --force
12:47:07 <roconnor_> horray
12:47:18 <kallisti> https://github.com/kallisti-dev/directory-trees/blob/master/src/System/Directory/Tree.hs  can someone verify that I'm using functional dependencies correctly here? the typeclass in question is called TreeLens
12:47:18 <Cale> oh, probably because it doesn't have any marker of its own, and doesn't import anything which isn't trustworthy.
12:47:34 <Cale> except... is that actually true?
12:47:49 <bitonic> Cale: I doubt that module doesn't use unsafePerformIO
12:48:00 <Cale> Yeah, it's true. This is actually safe.
12:48:01 <bitonic> and it clearly has functions that break those principles you linked
12:48:04 <tgeeky> Cale: yep
12:48:24 <Cale> The sense in which it's unsafe isn't the sense in which the trustworthiness system is trying to protect from.
12:48:27 <EvanR> what does safe mean in context of unsafePerformIO?
12:48:43 <Cale> There's no unsafePerformIO going on here
12:48:56 <bitonic> Cale: the functions are not referentially transparent
12:49:02 <Cale> and everything which ought to have IO type does
12:49:05 <kallisti> basically that it doesn't export some function with equivalent semantics to unsafePerformIO
12:49:08 <Cale> Sorry, what?
12:49:13 <Cale> Which function specifically?
12:49:20 <bitonic> "While these functions have a stable API and you may use these functions in applications, do carefully consider the documented pre-conditions; incorrect use can break referential transparency or worse."
12:49:26 <bitonic> Cale: I don't know, it says at the top of the page
12:49:34 * ski thinks instead of `unsafeBlah', it would be more useful to do `promiseBlah' as in Mercury, explicitly stating under what conditions something is safe
12:49:40 <d-snp> what's with haskell and these 1/2 letter abbreviations for parameters? it gets pretty annoying when reading documentation
12:49:41 <Cale> That doesn't appear to be true.
12:49:45 <rwbarton> well unsafeIndex obviously
12:50:07 <rwbarton> it doesn't give you unsafePerformIO but it does give you random answers/crashes
12:50:07 <Cale> oh, oops
12:50:09 <d-snp> newtype L e mi mo = L{UnL :: forall a. R e mi a -> mo (R e mi a)}
12:50:12 <bitonic> Cale: "A variety of head for non-empty ByteStrings. unsafeHead omits the check for the empty case, so there is an obligation on the programmer to provide a proof that the ByteString is non-empty.
12:50:12 <d-snp> wtf?
12:50:14 <Cale> there's inlinePerformIO
12:50:17 <bitonic> Cale: first function
12:50:21 <Cale> Yeah, that's a problem
12:50:30 <EvanR> d-snp: some modules do things like newtype L
12:50:43 <tgeeky> Cale: maybe safe-haskell hasn't added it to the list of unsafe things
12:50:45 <bitonic> so what's going on here?
12:51:07 <Cale> tgeeky: yeah, that's what I'm thinking
12:51:10 <Franciman> people, but which IDE do you use to program in haskell?
12:51:13 <Cale> Which module has that?
12:51:15 <EvanR> Franciman: unix
12:51:21 <otters> TextMate
12:51:23 <parcs`> d-snp: what package is that from
12:51:35 <ski> Franciman : Emacs
12:51:35 <bitonic> Franciman: emacs
12:51:37 <d-snp> iteratees
12:51:40 <Franciman> EvanR, unix?
12:51:42 <tgeeky> bitonic: you'll probably need to find yourself a safe-haskell expert, or read the docs very carefully
12:52:04 <bitonic> tgeeky: well that clearly looks like a bug to me
12:52:48 <bitonic> tgeeky: I don't know if it's in ByteString marking the wrong modules as trustworthy or something
12:52:54 <mgsloan> Franciman: I like sublime text
12:53:09 <bitonic> but that module is a classic example of what should be unsafe
12:53:24 <byorgey> Franciman: If you like/are comfortable with Eclipse, there is also EclipseFP which is a Haskell plugin.
12:53:25 <mgsloan> http://wbond.net/sublime_packages/alignment <- this, and multiple cursor support is really nice for haskell
12:53:49 <Franciman> byorgey, I feel like it's a bit too slow
12:54:07 <byorgey> Franciman: sure, I do too =)
12:54:10 <Cale> Yeah, inlinePerformIO is defined in Data.ByteString.Internal which imports unsafePerformIO among other things, and isn't marked as Safe
12:54:15 <ski> Franciman : why not try Emacs, then ?
12:54:15 <Cale> Or Trustworthy
12:54:19 <byorgey> I use emacs myself.
12:54:30 <Franciman> does it have autocompletion?
12:54:44 <bitonic> Franciman: yes
12:54:50 <EvanR> vim
12:54:52 <ktosiek> Franciman: and a kitchen sink, too
12:54:53 <parcs`> d-snp: module?
12:54:57 <Franciman> lol
12:55:04 <parcs`> d-snp: or rather, do you have a link
12:55:46 <bitonic> Cale: yeah, so it looks like a safe haskell bug
12:56:00 <Cale> Might be worth asking the mailing list about
12:56:00 <bitonic> which kinda proves that nobody pays attention to the safe haskell classification
12:56:05 <Franciman> well thanks all for your opinion :)
12:56:07 <bitonic> Cale: will do
12:56:11 <ski> preflex: xseen ManateeLazyCat
12:56:11 <preflex>  ManateeLazyCat was last seen on freenode/#haskell 56 days, 5 hours, 21 minutes and 45 seconds ago, saying: applicative: Gnome-Shell lies to on powerful with gjs, it use JavaScript, make desktop environment not stable enough, it use clutter library, make it can't running on ATI driver, i hate it.
12:56:12 <Cale> Well, hey, it's only existed for a short while
12:56:13 <Franciman> I'll give a try to emacs and sublime
12:56:21 <Cale> I don't know if anyone is actually using the system yet
12:56:38 <ski> Franciman : there's also Yi,Manatee,something more
12:56:46 <Cale> It came out with 7.4.1, didn't it?
12:57:19 <bitonic> Cale: the same applies to the array module
12:57:38 <Franciman> what scares me a bit about emacs is all those short-cuts
12:58:07 <Cale> Franciman: you can mostly ignore them
12:58:09 <d-snp> oh sorry parcs` I was reading again: http://okmij.org/ftp/Streams.html
12:58:56 <Cale> Franciman: After all, it's not a problem that there are lots of bindings unless you hold down modifier keys and mash random letters :)
12:59:11 <Cale> (which might be unadvisable in any case)
12:59:11 <Franciman> lol, of course
12:59:27 <d-snp> anyone of you used iteratee based i/o?
12:59:56 <EvanR> Cale: that works in many fighting games
13:00:10 <Franciman> ok I'll use emacs
13:00:23 <EvanR> haskell mode for emacs, i heard good things
13:00:51 <Veinor> haskell-mode is nice, it tends to not work as well if you're not working on a cabal project though
13:01:13 <d-snp> which you are never right?
13:01:56 <saml> can I optimize log for acid-state?
13:03:52 <bitonic> saml: what do you mean?
13:04:12 <saml> remove older logs
13:04:16 <saml> after commit
13:05:13 * hackagebot regexpr-symbolic 0.5 - Regular expressions via symbolic manipulation  http://hackage.haskell.org/package/regexpr-symbolic-0.5 (MartinSulzmann)
13:05:19 <solrize> d
13:05:45 <bitonic> Cale: voila` http://www.haskell.org/pipermail/haskell-cafe/2012-May/101172.html
13:05:52 * bitonic goes to have dinner
13:11:37 <saml> is there script that converts  import Foo.Bar   to import Foo.Bar (x, y, z, stuffUsed)
13:11:45 <d-snp> hmm I don't get one thing, what kind of thing is a in the definition of Iteratee?: data Iteratee el m a = IE_done a
13:12:04 <irctc070> Can anyone else use regexes in haskell? I can't get ghci to do anything other than throw 'no instance' errors with any statement involving '=~' to save my life.
13:12:22 <saml> what regex library are you using irctc070 ?
13:12:52 <irctc070> I've tried both Text.Regex.Posix and Text.Regex.TDFA
13:13:08 <irctc070> guessing it's an issue with the common interface
13:13:35 <rwbarton> > "testing" =~ "test" :: Bool
13:13:36 <lambdabot>   True
13:13:45 <sclv> irctc070: http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
13:13:57 <irctc070> OK, so it is my system.
13:14:15 <rwbarton> you need to make sure it knows what type you want to use =~ at
13:14:28 <rwbarton> so giving a type annotation like I did is one way
13:14:44 <jfischoff> > :t (=~)
13:14:45 <rwbarton> or it may be known from context
13:14:46 <lambdabot>   <no location info>: parse error on input `:'
13:14:51 <rwbarton> > not ("testing" =~ "test")
13:14:52 <lambdabot>   False
13:14:53 <irctc070> No, if I copy and paste your code into my ghci, I get a 'no instance' error
13:14:58 <rwbarton> oh hmm
13:15:10 <jfischoff> :t (=~)
13:15:11 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
13:15:29 <rwbarton> it worked for me with just Text.Regex.Posix loaded
13:15:39 <rwbarton> Prelude Text.Regex.Posix> "testing" =~ "test" :: Bool
13:15:39 <rwbarton> True
13:15:41 <rwbarton> ghc 7.0.4
13:16:09 <jfischoff> monomorphism restriction maybe?
13:19:23 <irctc070> What version of regex-posix do you have?
13:19:40 <rwbarton> regex-posix-0.95.1 (and regex-base-0.93.2)
13:22:14 <adamA7> Why I am banned from gentoo channel?
13:22:43 <identity> What could be the reason for Network.HTTP.Enumerator.simpleHttp working, the last time I tried it, without withSocketsDo(on windows), but now it doesn't?
13:23:17 <identity> I have no proof of it working last time, but I am 100% sure. I have a file with exactly one function in it, that uses simpleHttp, and it worked the last time I was playing around.
13:23:44 <ricli85> I have a strange problem with hspec and cabal
13:24:08 <ricli85> when I build my tests with cabal, sometimes the asserts do not seem to work (they pass when they should)
13:24:22 <ricli85> but if I build manually, I get correct behavior
13:24:38 <ricli85> any ideas how I can debug this problem?
13:24:54 <ricli85> I have created a small example which demonstrates the problem
13:25:41 <irctc070> rwbarton: Thanks for the help. Apparently something with my haskell installation is messed up. Any suggestions other than reinstalling?
13:26:02 <rwbarton> did you try doing exactly the following?
13:26:21 <rwbarton> (1) start ghci (2) :m +Text.Regex.Posix (3) "testing" =~ "test" :: Bool
13:28:05 <mreh> wowee, 900 people
13:29:02 <irctc070> It works! It looks like there's a slight semantic difference between ':m +' and 'import'
13:29:15 <c_wraith> yeah, there is
13:29:21 <kallisti> `unpl f `ap` g `ap` h
13:29:27 <kallisti> @unpl f `ap` g `ap` h
13:29:27 <lambdabot> ((f >>= \ k -> g >>= \ j -> return (k j)) >>= \ b -> h >>= \ a -> return (b a))
13:30:14 <mreh> cabal-dev is broken
13:30:27 <kallisti> @pl f (g x) (g (h x))
13:30:27 <lambdabot> f (g x) (g (h x))
13:30:34 <kallisti> @pl \x -> f (g x) (g (h x))
13:30:34 <lambdabot> liftM2 f g (g . h)
13:31:15 <mreh> installing happstack 7 cabal-dev can't find a package it just installed
13:31:27 <vhd> whats the easiest method to play sound in a haskell program?
13:31:28 <mreh> who do I inform
13:32:12 <stepcut> mreh: sounds like an issue with cabal-dev? or they way you are using it ?
13:32:40 <mreh> stepcut, i'm just doing cabal-dev install happstack on a clean environment
13:32:56 <mreh> installs transformers then dies because it can't find transformers
13:33:20 <mreh> wish i knew more about cabal
13:34:31 <rwbarton> hmm interesting, what is different about 'import'? it doesn't get instances apparently?
13:37:09 <kallisti> @hoogle on
13:37:10 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
13:37:10 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
13:37:10 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
13:37:17 <c_wraith> import sometimes doesn't pick up transitive instances in ghci
13:37:24 <c_wraith> it always gets direct instances
13:38:38 <ski> d-snp : presumably a "generic result" type of thing
13:38:39 <rwbarton> that's unfortunate
13:40:19 * hackagebot paragon 0.1.13 - Paragon  http://hackage.haskell.org/package/paragon-0.1.13 (NiklasBroberg)
13:41:18 <irctc070> Although it does solve my problem.
13:42:54 <Phlogistique> any advice wrt to technologies or language to build a programming language interpreter that has to run in real-time?
13:43:02 <irctc070> Thanks for all your help, everyone!
13:43:29 <Phlogistique> I'd like to write in something more expressive than C but I don't think Haskell is generally suited for real-time?
13:43:31 <saml> ghc -O2 --make --from-url http://www.happstack.com/docs/crashcourse/AcidState.html    #why doesn't this work?
13:43:54 <saml> if a web page is in literate haskell, can ghc download it and compile and run?
13:44:19 <mreh> saml: yes, just copy and past the source, or wget the page
13:44:40 <saml> that's two steps. i'm trying to have HTTP enabled module system for ghc
13:44:59 <saml> so that you can do thigns like  import http://www.happstack.com/docs/crashcourse/AcidState.html  as AcidState
13:45:31 <mreh> saml: sorry, didn't read what you wrote, as far as i know no
13:45:39 <mreh> why not write a script that does it
13:46:36 <scooty-puff> how expensive are System.Mem.Weak.Weak's?  if i go from using n, to using 2n, is it that horrible?
13:46:53 <scooty-puff> well, nm
13:47:05 <mreh> scooty-puff: try benchmarking with the profiling tools
13:47:30 <stepcut> mreh: dunno.. I know people use happstack 7 + cabal-dev.. but I don't use cabal-dev so I can't offer much advice
13:47:33 <scooty-puff> yeah, was just thinking that - that no one could answer that without knowing the constant stuff
13:52:00 <mathw> win move 9
13:52:04 <mathw> woops, sorry
13:52:04 <edwardk> preflex: xseen glguy
13:52:05 <preflex>  glguy was last seen on freenode/#haskell 3 days, 23 hours, 55 minutes and 8 seconds ago, saying: To use "threadscope" do you need to rebuild all the libraries you use with "eventlog"?
13:54:12 <Phlogistique> saml: this web page does not seem to be a literate haskell program
13:54:24 <saml> Phlogistique, it does to end users
13:54:45 <Phlogistique> saml: it might have been generated from a literate haskell program
13:54:55 <Phlogistique> but it does not make GHC able to compile it
13:54:55 <saml> it looks like source is .hs
13:55:00 <saml> wonder how they generated that page
13:55:41 <Phlogistique> Haddock?
13:56:42 <stepcut> saml: darcs get http://src.seereason.com/happstack-crashcourse
13:57:09 <stepcut> saml: the input files are .lhs files, but then they are run through markdown+hscolour+cpp, etc, to generate the .html files
13:57:36 <saml> so someone wrote those .lhs files ?
13:57:44 <stepcut> saml: it does automatically extract the source and put it in .hs files, http://www.happstack.com/docs/crashcourse/AcidStateCounter.hs
13:57:49 <saml> or are those also generated from markdown.. etc?
13:57:49 <stepcut> saml: yes.. specifically me
13:58:05 <saml> oh okay thanks stepcut . those are good documents
13:58:06 <stepcut> saml: some of the .lhs files are html, some are markdown
13:59:08 <stepcut> in theory you could try to screenscrape the .html to get the original source back.. but that will not actually work because there are type signatures and other things on the page which look like literate haskell.. but which are ignored using CPP in the source document
14:00:35 <kkyqqp> the union function in data.list only counts duplicates in the first list and not the second, is there an easier way to have a symmetric union that counts duplicates properly in both arguments of union other than this ugly version?             (\x -> \y -> (union x y) ++ ((union y x) \\ (union x y)))
14:01:02 <stepcut> saml: glad you found the content useful!
14:01:15 <twanvl> kkyqqp: don't use lists?
14:01:32 <kkyqqp> I just picked up haskell, what would you use instead?
14:01:48 <twanvl> the Set type from Data.Set
14:02:06 <Phlogistique> twanvl: maybe kkyqqp doesn't have an Ord instance
14:02:55 <Cale> kkyqqp: You could use nub
14:03:07 <Cale> If you don't have an Ord instance or don't want to sort things
14:03:49 <Cale> union (nub xs) ys  would work
14:04:23 <Cale> The reason for union being asymmetric like that is that it's less work to compute that way.
14:04:39 <kkyqqp> I can't see a way of doing it with sets without doing a similar hack where I go back to a list after taking the union, I need to preserve duplicates and sets don't do that- that is, I need the union of [1,1,1,2] and [2,2,2,2,1] to be [1,1,1,2,2,2,2]
14:04:52 <Cale> oh
14:05:01 <Cale> you want to preserve duplicates, that's different :)
14:05:05 <twanvl> do you need the result to be ordered?
14:05:07 <Cale> errr
14:05:09 <kkyqqp> I should have been more specific :D
14:05:12 <kkyqqp> order doesn't matter, no
14:05:15 <twanvl> otherwise you could just use (++)
14:05:33 <Cale> and you want the union to preserve the *maximum* of the number of elements, and not the sum
14:05:46 <Cale> You could use Data.Map
14:05:47 <kkyqqp> yes, the maximum
14:06:03 <Cale> Map a Integer
14:06:10 <Cale> (so, keep track of counts)
14:06:14 <twanvl> Data.MultiSet
14:06:18 <Cale> and use unionWith max
14:06:52 <kkyqqp> Maps or Multisets look like just what I need, thanks
14:08:18 <jjg> anyone have experience with parsec?
14:08:47 <twanvl> jjg: yes
14:09:12 <jjg> i've got a parser that needs to choose between multiple parsers, but it also needs backtracking
14:09:38 <jjg> parseExpr :: Parser Expr
14:09:40 <jjg> parseExpr = try parseCall <|> try parseLet
14:10:04 <jjg> the problem is that the error result from this thinks that it fails at line 1 column 1, pretty much no matter what
14:10:25 <jjg> so i'm not getting good error reporting
14:12:51 <rwbarton> well, this becomes a tough problem when your language needs this kind of backtracking
14:13:02 <rwbarton> you might try getting rid of the last 'try' though
14:13:47 <Veinor> are people still trying to make cabal install parallel?
14:13:49 <jjg> rwbarton: don't most languages need some form of backtracking? also I've tried that, i've got a list of parsers that need to be tried
14:14:07 <rwbarton> yeah, and most error messages are bad. *shrug*
14:14:50 <rwbarton> this isn't really a useful but just to give some perspective...
14:14:54 <rwbarton> *a useful answer
14:14:58 <twanvl> how early can you decide between a call and a let?
14:15:16 <jjg> twanvl: pretty much not at all until you see a = sign
14:16:17 <twanvl> then you can't hope for a better error message before that point, because the parser will always need to backtrack to consider the other alternative
14:16:29 <twanvl> it might help to not have 'try' on the second alternative
14:17:27 <jjg> twanvl: i guess I'm just surprised that there's nothing built in to deal with this.  I'd like the error reported to be based upon the parser that made it the farthest before erroring out
14:18:25 <twanvl> jjg: that would be a nice thing to have, I don't know why parsec doesn't do that
14:18:54 <kallisti> shapr: I've got a working recursive directory copy.
14:19:23 <twanvl> do parseCall and parseLet have a common prefix? If so, you could try to move the choicepoint to after that prefix
14:21:14 <jjg> twanvl: no not really
14:21:38 <jjg> twanvl: I'll just have to look into adding my own choice function i think
14:22:00 <kallisti> shapr: copyTo "test2" =<< getDirectory "/home/adam/test"
14:22:20 <kallisti> does what you would expect.
14:23:33 <kallisti> it also returns the tree in its new location.
14:23:40 <kallisti> which might be useful for some reason.
14:24:31 <mreh> ah, cabal does throw some unhelpful errors
14:24:43 <mreh> another package failing was causing that error
14:32:29 <statusfailed> Is it possible to derive Show of Text.Show.Bytestring?
14:37:26 <hpc> can someone with a linux compile/run this? https://github.com/headprogrammingczar/game
14:37:37 <hpc> i need to know if it fails to maximize because of xming, or something else
14:38:36 <d-snp> when Oleg says lazy I/O is a sin, does he mean I/O monads as is the regular style in GHC?
14:38:42 <hpc> d-snp: no
14:38:48 <hpc> he means stuff like hGetContents
14:39:02 <mauke> I like how build.sh installs
14:39:13 <d-snp> ah, I haven't used that yet
14:39:24 <kallisti> shapr: there's a lot to do though; remove should be all-or-nothing via temp directories.
14:39:28 <hpc> mauke: yeah, that one was to keep me from going insane
14:39:34 <hpc> i don't like putting .cabal/bin on my path
14:39:57 <d-snp> so they say Iteratee is a solution to lazy I/O, but is it an alternative to I/O monads too, or is it more complementary?
14:40:03 <mauke> and by "like" I mean "wtf were you thinking?"
14:40:04 <dcoutts> hpc: you can get cabal to add symlinks into ~/bin
14:40:07 <Peaker> unsafeInterleaveIO
14:40:42 <rwbarton> all IO in (modern, like post-1990-something) haskell is based on the IO monad
14:41:05 <Peaker> d-snp, conduits are probably nicer than iteratees
14:41:22 <mauke> d-snp: what do you mean, "monads"? I only know one IO monad
14:41:29 <mauke> is there a second possible instance?
14:41:31 <donri> oh, no IO done with functor or applicative eh? :)
14:41:35 <d-snp> mauke: I hope not :P
14:41:39 <hpc> d-snp: the evil of lazy IO is, suppose you did something totally innocent like
14:41:50 <rwbarton> and iteratees/conduits/pipes can run in any monad, doesn't have to be IO
14:41:58 <rwbarton> but if you are using them to do IO, it will be
14:42:14 <mauke> hpc: I ran it
14:42:41 <hpc> main = do {h <- openFile "/etc/passwd"; pass <- hGetContents h; hClose h; print pass} -- open file, read, close, print password
14:42:55 <hpc> but pass didn't actually get read from the file until the print statement
14:43:06 <hpc> mauke: did the window appear maximized?
14:43:13 <mauke> no
14:43:16 <hpc> :(
14:43:30 <mauke> :)
14:43:57 <Clint> dcoutts: could you take a look at some gtk2hs/glade trouble?
14:44:11 <dcoutts> Clint: maybe, if it's quick
14:44:23 <hpc> mauke: looks like i can't programatically maximize the screen then
14:44:31 <Clint> dcoutts: https://buildd.debian.org/status/package.php?p=haskell-glade
14:44:35 <mauke> good
14:44:44 <hpc> er, window
14:44:54 <Clint> dcoutts: that happens with gtk2hs-buildtools 0.12.3 and not with 0.12.1; the relevant change seems to be the import of CULong(..) vs. CULong
14:45:18 <hpc> mauke: it's annoying though, because i can't get the window to request a size bigger than the bare minimum it needs
14:45:34 <hpc> so either i make the window have a large minimum size, and then make it impossible to shrink by hand
14:45:42 <hpc> or make it appear teeny-tiny, as you saw
14:45:45 <mauke> my window manager doesn't care what you request
14:46:01 <mauke> it wasn't teeny-tiny
14:46:05 <hpc> oh
14:46:19 <hpc> when i run it, it's 100x100
14:46:36 * hpc will just have to add shit to it and accept that xming is derp
14:47:09 <mauke> 860x295
14:47:25 <hpc> oh, you're using xmonad
14:47:30 <hpc> cheatyface
14:49:13 <Peaker> or suppose you fork a thread and do a lazy IO operation in it and return a result to the main thread
14:49:19 <ski> hpc : first rule of `hGetContents', *never* `hClose' handles passed to it ..
14:49:39 <dcoutts> ski: I wouldn't say that
14:49:51 <hpc> first rule of hGetContents is know what lazy IO is
14:49:53 <Peaker> or suppose reading from your handle is a visible effect
14:49:58 <hpc> and know that it's lazy IO
14:50:03 <Peaker> or suppose you care about error handling or resource use :)
14:50:05 <dcoutts> just bracket it and ensure you consume the thing in the block
14:50:07 <hpc> and know that you don't want to be using lazy IO
14:50:46 <dcoutts> it's relatively straightforward to use lazy I/O in a sensible way
14:51:15 <Peaker> It's very un-Haskell-like
14:51:16 <ski> `hGetContents' conceptually closes the handle itself -- it is "semi-closed" -- it just hasn't happened yet
14:52:04 <dcoutts> Clint: hmm, I can't get the https page and there's no http version
14:52:23 <Clint> dcoutts: ok, the important part is "gtk2hsC2hs: UName: root name supply used after saving
14:52:26 <Clint> i think
14:52:32 <Peaker> dcoutts, lazy I/O has no error reporting and thus has no sensible use outside trivial programs
14:52:49 <dcoutts> Peaker: that's not true, you get exceptions as normal
14:52:58 <Peaker> not with hGetContents
14:53:16 <Peaker> do you get them as "error"s ?
14:53:21 <dcoutts> Clint: I've heard that reported and someone said it was related to a patch I applied, but I cannot see how
14:53:43 <Peaker> dcoutts, how do you catch a lazy I/O exception?
14:53:55 <dcoutts> Peaker: historically hGetContents did not throw I/O exceptions because there was no such thing in Haskell 98
14:54:27 <Clint> dcoutts: so if the GHC ifdef is removed from gtk2hs-buildtools, it works, or if you run cabal build twice in a row, it works, because somehow Types.chs gets reverted to the tarball version on the second run, as opposed to the version with the ifdef in it
14:54:33 <Clint> and none of this makes sense to me
14:54:34 <Peaker> but how does a value of type String throw IO exceptions?
14:54:39 <dcoutts> Peaker: and I'm not sure now if System.IO.hGetContents does throw I/O exceptions, but Data.ByteString.Lazy.hGetContents certainly does.
14:54:54 <dcoutts> Peaker: you can throw exceptions from pure code remember
14:55:01 <donri> Peaker: but it's of type IO String?
14:55:22 <Peaker> dcoutts, you mean like "undefined" and friends?
14:55:39 <Peaker> donri, not anymore.. I'm talking about exceptions in the later-IO
14:55:46 <Peaker> donri, not the initial IO
14:55:50 <dcoutts> Peaker: well they throw one kind of exception, you can throw any type in the Exception class
14:55:59 <donri> later-IO?
14:56:07 <donri> :t hGetContents
14:56:08 <lambdabot> Not in scope: `hGetContents'
14:56:21 <Peaker> donri, the IO that gets invoked by the pure evaluation of list cons cells
14:56:41 <Peaker> dcoutts, which function throws pure exceptions of such types?
14:57:18 <Peaker> donri, hGetContents >>= \s -> ... pure use of s may cause IO error long after the hGetContents "completed" and can no longer throw
14:57:24 <kallisti> blackdog: did you get my message earlier?
14:57:28 <dcoutts> Clint: so I don't have a solution to hand, nor have I investigated the problem, best advice is to pester the gtk2hs dev list, or bisect my patches and work out exactly which bit causes the problem.
14:57:55 <dcoutts> Peaker: throw :: Exception e => e -> a
14:58:03 <dcoutts> Peaker: Control.Exception
14:58:15 <dcoutts> throwIO :: Exception e => e -> IO a
14:58:25 <dcoutts> is the one that's sequenced in the IO monad
14:58:26 <Clint> dcoutts: http://lists.debian.org/debian-haskell/2012/05/msg00003.html ; that's the only bit
14:58:27 <Peaker> dcoutts, ah, well, to catch that you need to force evaluation deep enough, of course, which is fragile and may be anti-modular
14:58:37 <dcoutts> but you can only catch in the IO monad
14:58:51 <donri> Peaker: but the complete computation is still IO (and you can throw exceptions from pure code anyway)
14:59:15 <donri> > fix error
14:59:16 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
14:59:17 <Peaker> donri, throwing from pure code is/should-be frowned upon (IMO)
14:59:28 <dcoutts> Peaker: that's not related to exceptions though, that's the same issue as having to consume the file content so you can close it
14:59:34 <donri> yes, and it is
14:59:35 <donri> @hackage safe
14:59:36 <lambdabot> http://hackage.haskell.org/package/safe
14:59:49 <Peaker> donri, lazy I/O throws from pure code
15:00:06 <donri> not in the haskell sense i don't think
15:00:15 <Peaker> dcoutts, well, with conduits I don't have to worry about it
15:00:16 <dcoutts> Peaker: which is why I advocate the bracket open close approach, you find out as soon as you test it if you're not consuming the content
15:00:47 <dcoutts> Peaker: you're doing one convoluted thing or another, one enforces the style, the other is just a style
15:01:57 <Peaker> dcoutts, combinators that guarantee aspects of correctness, as opposed to sort-of-correctness via testing.. It's the Haskell-vs-everyone-else debate, in a smaller context
15:01:58 <dcoutts> Peaker: but I don't think it's fair to compare a highly structured enforced approach on one side, and pretend that lazy IO is an unstructured free for all
15:02:32 <absence> has anyone seen the "are we there yet?" talk by rich hickey? does haskell have the kinds of time abstractions (or whatever they're called) he talks about? there's been a lot of writing about frp, but in the talk he says it's not good enough because it fabricates "pretend time" instead of dealing with actual time, but i don't know what other alternatives exist :)
15:02:43 <Peaker> purity/IO-type in Haskell "enforces a style", similarly
15:03:27 <dcoutts> if you care about the resource use, or knowing when I/O errors happen then you use a resource bracketing style, it's not that hard, and it isn't essential to enforce everything
15:03:52 <dcoutts> Peaker: but I also admit that these schemes are getting better, simpler
15:03:53 <Peaker> dcoutts, I don't think there's anything else in Haskell where I need to worry about forcing evaluation or eval order for correctness
15:04:03 <dcoutts> e.g. pipes actually look reasonably ok
15:04:24 <dcoutts> unlike some of the previous schemes which do not pass the "can I explain it to an undergraduate" test
15:04:41 <Peaker> I'm an undergraduate :)
15:04:51 <sclv> absence: i don't remember the details of what he proposes
15:04:54 <sclv> but yes, haskell can do that.
15:04:57 <Peaker> (or less, I'm not sure)
15:04:59 <dcoutts> Peaker: there's plenty of places where you have to think about evaluation for resource use
15:05:13 <donri> Peaker: and you understood iteratees without much effort?
15:05:17 <Peaker> dcoutts, only for performance, not correctness
15:05:39 <dcoutts> Peaker: well it's the same with closing the file, it happens automatically, you only do it eagerly if you care about resource use
15:05:42 <conal> absence: i gave it a try and couldn't quite get what he was saying. maybe by "pretend time", he just meant that he doesn't see how to correctly implement the simple & precise frp notion of time with the mechanisms he's thinking of and/or for the kinds of problems he's thinking of. just a guess. my hunch is that he's onto something, but i can't tell quite what.
15:05:45 <Peaker> donri, iteratees are somewhat obsolete, I think.. there's conduits/pipes
15:06:22 <sclv> iteratees are *not* obselete!
15:06:27 <sclv> obsolete even
15:06:32 <dcoutts> Peaker: so yes it's a little different but not so radically so, I think people get too worked up about it
15:06:35 <sclv> they were never even selete!
15:06:39 <Peaker> dcoutts, or because my libraries close already.. or maybe reading from the socket has a visible effect
15:07:06 <donri> Peaker: but i think they're what dcoutts was referring to
15:07:11 <sclv> pipes are as far as i know very close to iteratees actually, just a different formulation.
15:07:17 <adnauseam> guys, a quick question
15:07:32 <absence> conal: i think there was something about interfacing with "actual time" (real-time / robotic stuff maybe?) that caused problems, but i could be wrong
15:07:36 <sclv> conduit, to the extent it moves towards pipeland, comes increasingly back in line with iteratees
15:07:37 <adnauseam> in the lambda (\x -> x) x, is the x that's outside of the lamda free, or bound ?
15:07:43 <sclv> they're a design point.
15:07:46 <sclv> that's being explored.
15:07:46 <Peaker> dcoutts, Haskell has gone through all the trouble of composing IO via special cps operators, and then comes lazy I/O and puts visible effects behind the evaluator again
15:08:16 <dcoutts> Peaker: if the effects are important then it's not an appropriate use of lazy I/O
15:08:18 <Peaker> donri, Iteratees were slightly difficult to understand because of the horrible naming scheme
15:08:42 <dcoutts> if the non-determinism matters then it's not good, non-determinism is fine when it doesn't matter
15:08:44 <absence> sclv: by "haskell can do that", i assume you mean it's turing complete and can do anything? ;)
15:09:16 <Peaker> dcoutts, lazy I/O is typically used to implement the core semantics of the program, so it is important
15:09:23 <d-snp> stanford is very good at teaching haskell / functional programming
15:09:32 <conal> absence: if one could formulate the question clearly, we might make some progress on it--either to showing that there is a problem with the abstraction or that there isn't one.
15:09:38 <sclv> absence: no. i mean that haskell can handle clojure's concurrency constructs.
15:09:49 <sclv> with its own.
15:09:51 <sclv> easily.
15:09:51 <d-snp> I'm reading cs240h, lecture on iteratee and it's way better than any other reference I've found so far
15:09:56 <Peaker> dcoutts, I don't really see how non-determinism of where the IO exceptions are thrown can ever not matter
15:10:12 <d-snp> http://www.scs.stanford.edu/11au-cs240h/notes/iteratee.html it also tells why lazy i/o is bad, and how iteratee tries to solve it
15:10:14 <sclv> to the extent that rh proposes things beyond what clojure currently handles, i can't speak to it.
15:10:20 <conal> absence: and in the process, perhaps limiting assumptions would be discovered.
15:10:23 <sclv> since i don't know what he's referring to.
15:10:28 <xil> hey everyone. I need a Ptr a for some OpenGL stuff and I'm just wondering if I can get some help figuring out pointers. In particular, I only need to initialize this thing, not hold on to the pointer long term. Is there something like withListPtr :: [a] -> (Ptr a -> IO b) -> IO b
15:10:29 <ninegrid> d-snp: love stanford <3
15:10:52 <sclv> but to the extent that he's motivating clojure's concurrency tools (which are neat!), haskell has, essentially, those, among a number of other options.
15:10:55 <mauke> @hoogle withArray
15:10:55 <lambdabot> Foreign.Marshal.Array withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
15:10:55 <lambdabot> Foreign.Marshal.Array withArray0 :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b
15:10:55 <lambdabot> Foreign.Marshal.Array withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b
15:10:57 <dcoutts> Peaker: if all you're doing is consuming the contents of the file, then it hardly matters when exactly the error happens, you let it propagate either way
15:11:04 <absence> sclv: ah, i see. that would be stuff like stm, agent, atom, etc?
15:11:07 <d-snp> yeah, I wish I was studying there, though the high costs probably make the pressure a bit too high to really have fun
15:11:16 <xil> mauke: ah thanks! =D
15:11:27 <mauke> @hoogle [a] -> (Ptr a -> IO b) -> IO b
15:11:27 <lambdabot> Foreign.Marshal.Array withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
15:11:28 <lambdabot> Foreign.Marshal.Array withArray0 :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b
15:11:28 <lambdabot> Foreign.Marshal.Utils with :: Storable a => a -> (Ptr a -> IO b) -> IO b
15:11:34 <sclv> absence: yeah.
15:11:40 <ninegrid> d-snp: it is still pretty nice that they make a lot of it publicly available
15:11:42 <sclv> there aren't precise analogues for everything.
15:11:45 <sclv> because we're *more* pure.
15:11:55 <absence> conal: i agree. it would be nice to have more details about it
15:12:50 <absence> sclv: i know there's an stm monad, what are some other names i can throw into (g/h)oogle?
15:12:57 <EvanR> @hoogle a -> b
15:12:58 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
15:12:58 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
15:12:58 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
15:13:16 <Peaker> dcoutts, if you just want to crash on every error I guess it's ok, if you also guarantee proper IO cleanup everywhere.  I think most programs don't want a crash and don't necessarily do proper cleanup (e.g: kill forkIO'd threads)
15:13:17 <dcoutts> Clint: I don't know why it triggers the error, but it'll be due to the use of the #if which is actually interpreted by c2hs
15:13:19 <sclv> just look at the core libs for channels and mvars and similar toys too.
15:13:20 <EvanR> besides unsafeCoerce what is a possible function with type a -> b ?
15:13:38 <sclv> Peaker: you can do that with lazy io!
15:13:39 <dcoutts> Peaker: but the place you'd put the exception handler is also essentially in the same place
15:13:56 <dcoutts> Peaker: wrapped around the consumer
15:13:56 <sclv> EvanR: const undefined
15:14:07 <EvanR> > unsafeCoerce 5 :: Char
15:14:08 <lambdabot>   Not in scope: `unsafeCoerce'
15:14:30 <sclv> absence: see also the `orc` library for another approach.
15:14:31 <Peaker> dcoutts, only if the consumer is even aware it's consuming lazy I/O in which case it might as well be in IO too
15:14:36 <sclv> there's a paper about it too, that's very nice.
15:15:00 <sclv> and then see the "cloud haskell" stuff for erlang-inspired actor styles
15:15:30 <dcoutts> Peaker: as I keep saying, if you care about the resource use then you bracket it, that means you have a place where you're consuming the whole resource and closing it. So you can wrap that in an exception handler. The pure code does not need to be aware of it.
15:15:40 <absence> sclv: channels?
15:16:05 <absence> sclv: i'll check those out, thanks
15:16:22 <sclv> absence: Control.Concurrent.Chan
15:16:28 <sclv> its been in core haskell libs for some time.
15:16:47 <Peaker> dcoutts, the pure-code-caller needs to be aware how much the pure code will evaluate into it, otherwise an IO exception can pop up in some random place in the program
15:17:05 <ski> adnauseam : free (in that expression. it's relative)
15:17:09 <conal> EvanR: without bottoms and unsafeXs, values of type forall a b. a -> b correspond to proofs of forall A B. A => B. including where B == False (b == Void). there aren't any.
15:17:19 <Peaker> dcoutts, which is OK iff you're willing to make unmodular assumptions (about the effect of such an exception in every other place in the program)
15:17:29 <EvanR> conal: cool
15:17:53 <Clint> dcoutts: importing CUInt instead of CUInt(..) there are warnings about "newtype `CUInt' is used in an FFI declaration, but its constructor is not in scope"; could that be relevant?
15:18:15 <Peaker> dcoutts, being aware exactly how much will be evaluated for reasoning about *exceptions* (not resource use) is IMO more problematic
15:18:42 <sclv> absence: that stuff was first described in 1996 (15 ish years ago! yeek) in the concurrent haskell paper: https://encrypted.google.com/search?hl=en&q=%22concurrent%20haskell%22%20peyton
15:19:17 <ski> @djinn a -> b
15:19:17 <lambdabot> -- f cannot be realized.
15:19:43 <acowley> Argh... I really want to partially apply a type synonym. What's my best bet for a compromise here?
15:19:46 <sclv> absence: actually, this should a zillion resources for you: http://www.haskell.org/haskellwiki/Parallel
15:20:02 <conal> i love that word: "realized"
15:20:14 <sclv> acowley: declare a new type synonym for the partially applied one?
15:20:21 <dcoutts> Clint: no, that's just the warning I was fixing by adding the ifdef
15:20:25 <ski> acowley : use extensionality, if possible -- or use `newtype'
15:20:56 <Veinor> ski: extensionality?
15:21:11 <ski> Veinor : `(forall a. f a = g a) => f = g'
15:21:12 <dcoutts> Clint: and that's the warning from ghc, where as this error is in c2hs
15:21:17 <Clint> dcoutts: so somehow the (..) is affecting a refcount?
15:21:23 <dcoutts> Clint: no
15:21:40 <dcoutts> Clint: the thing that's upsetting c2hs is the #if statement
15:21:43 <Clint> oh
15:21:48 <dcoutts> but why, I do not know
15:22:01 <dcoutts> Clint: it's not cpp that's handling those you see, it's c2hs
15:22:46 <dcoutts> c2hs handles (a subset of) cpp syntax in .chs files directly
15:23:09 <Clint> gotcha
15:23:22 <absence> sclv: i think i understand - there's no replacement concept for frp, instead one just uses "normal" parallelism (which fits nicely with rich's suggestion about letting e.g. guis be mutable)
15:23:37 <acowley> Okay, let me be more specific because I hope I'm missing the easy solution to this. I have: data T c a f = L c a | R c f and I have type F c a = Fix ([] :. T c a) where (:.) is functor composition.
15:23:37 <dcoutts> Clint: so for debian you can workaround it because you know which ghc you're using, so can do the #if statically by patching it to be one branch or the other
15:24:07 <acowley> But now I want to talk about F c :: * -> *
15:24:10 <Clint> dcoutts: right, thanks
15:24:29 <acowley> and I keep running aground with attempts at synonyms for the partial application
15:25:53 <Phlogistique> looks like I can't compile semigroups (and thus data-lens) with GHC 6.12.3?
15:26:09 <parcs`> 6.12.3 is really old
15:26:29 <Phlogistique> parcs`: indeed
15:26:36 <Phlogistique> that's what I have on this system though
15:28:56 <dmwit> > 3 :: Double .|. 5
15:28:57 <lambdabot>   Only unit numeric type pattern is valid
15:29:08 <dmwit> > (3 :: Double) .|. 5
15:29:09 <lambdabot>   No instance for (Data.Bits.Bits GHC.Types.Double)
15:29:10 <lambdabot>    arising from a use of ...
15:29:13 <dmwit> bummer
15:29:57 <parcs`> > True .|. False -- bigger bummer
15:29:58 <lambdabot>   No instance for (Data.Bits.Bits GHC.Bool.Bool)
15:29:59 <lambdabot>    arising from a use of `Da...
15:30:06 <identity> :t (.|:)
15:30:07 <lambdabot> Not in scope: `.|:'
15:30:08 <identity> :t (.|.)
15:30:09 <lambdabot> forall a. (Bits a) => a -> a -> a
15:30:13 <identity> oh..
15:30:14 <identity> duh.
15:30:38 <identity> I don't like how haskell's bitwise or is flipping me the bird. :(
15:36:59 <Polarina> Is there a function similar to mapM but for Data.Map?
15:37:25 <Clint> what?
15:37:46 <parcs`> Polarina: see Data.Traversable
15:37:51 <acowley> Polarina: Yes, it too is spelled "mapM"
15:38:22 <acowley> as parcs` said
15:39:04 <Polarina> I've been trying to use that module, but I cannot seem to get it to typecheck on anything.
15:39:24 <parcs`> well why not!
15:40:29 <edwardk> Polarina: you may have to hide the other mapM from Prelude
15:40:32 <Polarina> I've been trying to have it print the keys and values in Map String String, without success.
15:40:34 <edwardk> Polarina: import Prelude hiding (mapM)
15:40:38 * hackagebot semigroups 0.8.3.1 - Haskell 98 semigroups  http://hackage.haskell.org/package/semigroups-0.8.3.1 (EdwardKmett)
15:40:40 * hackagebot comonad 1.1.1.5 - Haskell 98 compatible comonads  http://hackage.haskell.org/package/comonad-1.1.1.5 (EdwardKmett)
15:40:41 <edwardk> import Data.Traversable
15:40:50 <rexamophone> @pl filter f a = foldRight (\x acc -> if' (f x) ((:|) x acc) acc) Nil a
15:40:50 <lambdabot> filter = flip foldRight Nil . flip flip id . (ap .) . (`ap` (:|)) . (((.) . if') .)
15:40:51 <Polarina> edwardk, I have.
15:41:26 <rexamophone> lambdabot: did you just tell me to go f**k myself?
15:41:44 <edwardk> Polarina: if you just want the contents, the easiest thing is to just use Data.Map.toList and run through those. traverse or mapM will just give you access to the values, not the keys
15:42:23 <acowley> Polarina: put some code up on hpaste if you want folks to take a look
15:42:41 <Polarina> edwardk, there's no more "efficient" method?
15:43:44 <edwardk> you can foldWithKey or fold to buid up the io action you are going to run, but that conversion is a lot cheaper than you think due to laziness
15:44:18 <Urm3l> System Info: Model:  MacBook Pro (LED Unibody) · CPU Speed:  2 @ 2.4 GHz · L2:  3 MB · RAM:  4 GB · OS X:  Version 10.7.3 (Build 11D50b) · Hostname:  Tobias Fabritzs MacBook Pro · User:  Tobias · Client:  Linkinus 2.2/24621 · Style:  Simplified
15:44:25 <edwardk> so it winds up happening as a sort of "wave front" right in front of you running the io actions, not as a monolithic conversion from the tree to a separate list
15:44:31 <Urm3l> sry bout that
15:44:33 <Urm3l> new irc client
15:44:34 <Urm3l> ^^
15:44:45 <shapr> Urm3l: So, is your irc client written in Haskell?
15:44:50 <edwardk> Urm3l: nice to meet you Tobias ;)
15:45:03 <shapr> GutenTag Urm3l!
15:45:08 <Polarina> edwardk, thanks.
15:45:17 <Urm3l> i guess its objective c =)
15:46:04 <acowley> Um3l: I hope it's called FünkeClient
15:47:27 <Urm3l> do you guys think if i want to learn haskell i could do well with learn yourself a haskell oder do i need to buy a book on it?
15:47:45 <Urm3l> ive got some experience in scheme
15:47:50 <acowley> LYAH is a great start.
15:48:07 <mauke> > oder
15:48:07 <d-snp> I didn't use a paper book, but I learned functional programming in a class, so I'm not sure
15:48:08 <mauke> :3
15:48:08 <lambdabot>   Not in scope: `oder'
15:48:25 <d-snp> we mostly learned by example
15:48:29 <mauke> you can always buy LYAH
15:48:40 <Urm3l> you learned haskell in class?
15:48:47 <Urm3l> lucky you
15:48:55 <d-snp> no, another pure functional language
15:48:56 <parcs`> Urm3l: LYAH is great
15:49:12 <donri> you mean "is a great"
15:49:34 <parcs`> lyah makes great success in haskell teaching
15:50:19 <Urm3l> hm i guess ill try it then
15:52:02 <donri> for make benefit of great language of haskell
15:53:55 <acowley> The cafe thread where people said they didn't like the humor in The Little Schemer was sad.
15:55:38 * hackagebot semigroupoids 1.3.1.2 - Haskell 98 semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-1.3.1.2 (EdwardKmett)
15:55:54 <edwardk> acowley: =( i missed that one
15:56:09 <acowley> edwardk: I need to miss more cafe threads
15:56:18 <identity> It's funny you should mention scheme, as i'm watching a scheme stream, where a friend of mine is streaming his desktop as he does scheme homework, heh.
15:56:37 <ledai> So there are actually computer science books with humor in them...
15:56:39 <acowley> …. why on earth would you watch a desktop stream of someone doing homework?
15:56:49 <identity> I'm stuck in sleeptyime limbo
15:56:54 <identity> sleepytime limbo*
15:57:07 <acowley> Ah I see, counting sheep :: counting parentheses
15:57:53 <identity> I feel like i have too much work to go to bed, but I'm too tired to do any of it, so I just sit here procrastinating until I can't stay awake
15:58:01 <identity> http://blog.geeksaresexytech.netdna-cdn.com/wp-content/uploads/2012/04/sleepytime.jpg
15:58:17 <acowley> What is this: data (f ::. g) a b = B (f a (g a b))
15:58:44 <acowley> identity: I do the same thing
15:59:48 <acowley> It's almost bifunctor composition
15:59:49 <identity> acowley: It is basically the only thing I do. I get do nothing and lose sleep doing it.
16:00:05 <edwardk> acowley http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Combinators-Of.html
16:00:39 * hackagebot shelly 0.7.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.7.1 (GregWeber)
16:00:42 <edwardk> i wrote a version of it a few years ago. never repackaged it after i discombobulated category-extras though
16:01:06 <edwardk> there are a few other functor combinators in there
16:01:13 <acowley> edwardk: that is almost the same; I'm a bit concerned I've got something wrong
16:01:35 <acowley> edwardk: I've never really understood what Of was
16:01:42 <edwardk> oh, because you have the repetition of the argument
16:01:46 <edwardk> which is kind of strange
16:02:11 <dmwit> why not f a :. g a
16:02:22 <dmwit> where :. is the usual functor composition
16:02:47 <edwardk> i had a number of combinators for wrapping the inputs or outputs of a bifunctor with another functor.
16:03:23 <edwardk> [(a,b)]   can be modeled as [] `Of` (,)
16:03:49 <edwardk> the name has no deep meaning other than that sort of reading ;)
16:04:13 <acowley> okay
16:05:13 <acowley> hmm
16:05:41 * hackagebot comonad-transformers 2.1.1.1 - Comonad transformers  http://hackage.haskell.org/package/comonad-transformers-2.1.1.1 (EdwardKmett)
16:05:45 <acowley> I want something more recursive though. Where each leaf is another A `Of` B
16:06:34 <acowley> Well, I should probably not bother with writing things using Fix or FixF and just write my own instances.
16:07:28 <edwardk> yeah
16:07:46 <edwardk> in my experience the type combinators are crap when recursion gets involved
16:08:12 <acowley> edwardk: they can make writing properties rather pretty though
16:08:21 <edwardk> sometimes =)
16:08:31 <acowley> well, eye of the beholder and all that
16:09:15 <acowley> I really liked the idea of factoring this all out into fixpoints and functor compositions
16:09:31 <acowley> but I can't really think of a great argument for all the trouble
16:09:43 <acowley> unless I get stuck again with my manual attempt :P
16:10:43 * hackagebot bifunctors 0.1.3.1 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-0.1.3.1 (EdwardKmett)
16:15:43 * hackagebot charset 0.3.1.1 - Fast unicode character sets based on complemented PATRICIA tries  http://hackage.haskell.org/package/charset-0.3.1.1 (EdwardKmett)
16:15:45 * hackagebot groupoids 0.2.1.1 - Haskell 98 Groupoids  http://hackage.haskell.org/package/groupoids-0.2.1.1 (EdwardKmett)
16:18:06 <xil> hey again everyone. So doing OpenGL stuff and I have this function http://hackage.haskell.org/packages/archive/OpenGL/latest/doc/html/Graphics-Rendering-OpenGL-GL-BufferObjects.html#v:bufferData whose type includes GLsizeiptr, and I can't make heads or tails of how to set that GLsizeiptr. I'm pretty sure it's the size, in bytes, of the array stored in the Ptr a, but can I just provide an Int for that?
16:19:49 <Polarina> xil, fromIntegral
16:19:51 <Polarina> http://hackage.haskell.org/packages/archive/OpenGLRaw/1.2.0.0/doc/html/Graphics-Rendering-OpenGL-Raw-Core31-TypesInternal.html#t:GLsizeiptr
16:20:13 <xil> Polarina: fromIntegral. I always always always forget I can do that
16:20:43 * hackagebot eq 0.3.7 - Leibnizian equality  http://hackage.haskell.org/package/eq-0.3.7 (EdwardKmett)
16:20:45 <xil> I took a loot at the doc for it but I still haven't gotten familiar enough with the various classes to extract meaningful stuff from the instances
16:20:51 <Polarina> xil, typeclasses are there to help you. :)
16:21:06 <xil> I'm still learning =]
16:21:27 <xil> I just keep forgetting what to take from them
16:22:05 <Polarina> Have you read the "Learn You a Haskell" book? http://learnyouahaskell.com/
16:22:12 <hpc> numeric type classes are there to screw with you, most of the time though
16:22:31 <hpc> unless you are using unusual numeric types, in which case they are a godsend
16:22:36 <xil> Polarina: I've read a lot of it, and several others. I mean I've been successfully using Haskell for a while, but there's always more to learn
16:22:50 <hpc> Polarina: i got the book free from the author :D
16:23:02 <Polarina> :D
16:23:47 <acowley> I part of the problem with forgetting about relevant typeclass instances is haddock, actually
16:24:29 <acowley> We're so accustomed to seeing lists of instances like Eq, Ord, and Show that it's like a EULA on some software where your eyes just glaze over and you say, "Right, whatever…."
16:25:01 <acowley> It's very helpful when the documentation author calls out the significance of some instances in some heading text.
16:25:45 * hackagebot comonads-fd 2.1.1.1 - Comonad transformers using functional dependencies  http://hackage.haskell.org/package/comonads-fd-2.1.1.1 (EdwardKmett)
16:25:47 * hackagebot either 0.3.0.1 - Haskell 98 either monad transformer  http://hackage.haskell.org/package/either-0.3.0.1 (EdwardKmett)
16:25:49 * hackagebot graphs 0.4.0.1 - A simple monadic graph library  http://hackage.haskell.org/package/graphs-0.4.0.1 (EdwardKmett)
16:28:57 <edwardk> i just try to implement pretty much any class that makes sense for a given data type
16:29:52 <S11001001> edwardk: what about the ones that make sense in multiple ways?
16:30:02 <edwardk> S11001001: those i tend to leave off
16:30:19 <edwardk> S11001001: i should have said, that make sense unambiguously or for which there is a common convention (like traversable)
16:30:43 * hackagebot data-lens 2.0.4.1 - Haskell 98 Lenses  http://hackage.haskell.org/package/data-lens-2.0.4.1 (EdwardKmett)
16:33:29 <parcs`> xil: you should use the raw bindings if you are learning opengl
16:33:49 <parcs`> xil: they are a little less convenient to use but at least it's a 1:1 mapping with the c api
16:33:49 <xil> parcs`: what do you mean by "the raw bindings"?
16:33:54 <parcs`> xil: OpenGLRAw
16:33:57 <parcs`> Raw*
16:34:00 <xil> oh I'm not learning OpenGL
16:34:04 <xil> I know it pretty well
16:34:09 <parcs`> oh ok
16:34:10 <xil> I'm learning the Haskell Binding
16:34:36 <xil> well, I am still learning OpenGL
16:34:46 <xil> but I have a working knowledge and understanding of it, so that's not where I get stuck
16:35:22 <xil> it's my Haskell knowledge that needs help. I don't know how many times I forget that instances of Integer are definable by casting with fromIntegral
16:35:57 <xil> actually that may not be accurate, have to look at the classes again
16:36:09 <xil> instances of type Num then
16:36:25 <parcs`> xil: still, the haskell bindings don't give you much. type safe enumerations, but that's about it. names are changed around and you'll likely have to grep the source code once to twice to find out what the analogue to a particular gl*() function is
16:37:23 <xil> yeah I supplement the hoogle docs with some tutorials to find the collection of functions being used for some task, then I try to find one that has a similar name in the haskell binding and the other ones tend to be reasonably named in the same package
16:37:37 <xil> haven't struggled too much with that, I've just had to be patient
16:38:53 <xil> it's a lot of the state creation that's getting me right now. Was stuck for hours before realizing that everything important is an instance of ObjectName and I just need to call genObjectName to create them. There are no other state creation functions though, while the C libraries have many for different things
16:39:23 <parcs`> yeah, that took a while to figure out here too
16:40:32 <xil> I'm still figuring out a lot of Haskell type stuff too, though, which doesn't make it easier. For example, I don't entirely understand "newtype" yet. Nor "forall"
16:40:44 * hackagebot data-lens-template 2.1.5 - Utilities for Data.Lens  http://hackage.haskell.org/package/data-lens-template-2.1.5 (EdwardKmett)
16:42:50 <parcs`> i can't say i entirely understand them, either. i just know when and how they are used :P
16:43:36 <xil> I haven't had a need, quite yet, to really look into them. I've read up some, but not enough to be able to say anything about them. One day =P
16:45:35 <dmwit> xil: replacing the "newtype" keyword with "data" is a pretty good first-order approximation of what's happening.
16:46:09 <xil> dmwit: I know newtype is like data when you only have 1 constructor
16:46:27 <dmwit> xil: If all the foralls appear at the beginning of the type, you can probably ignore them. Only nested foralls (or foralls in data/newtype declarations) are interesting.
16:47:40 <dmwit> xil: Yes. The difference, if you care, is that data stores a pointer to a constructor, which stores a pointer to the data it contains, whereas newtype just stores the pointer to the data.
16:48:15 <xil> interesting
16:48:42 <parcs`> one can say newtype defines a new type that is isomorphic to the underlying type but is distinct from the underlying type as far as type checking goes, but newtype also facilitates recursive magic like 'newtype Mu f = Mu (f (Mu f))' which is where the previous explanation is not convincing enough i think
16:49:20 <dmwit> Why is the previous explanation not convincing?
16:49:27 <dmwit> Mu f is isomorphic to f (Mu f).
16:49:58 <parcs`> perhaps it is
16:50:45 * hackagebot hyphenation 0.2.1.1 - Configurable Knuth-Liang hyphenation  http://hackage.haskell.org/package/hyphenation-0.2.1.1 (EdwardKmett)
16:50:47 * hackagebot monad-products 0.2.1.1 - Haskell 98 monad products  http://hackage.haskell.org/package/monad-products-0.2.1.1 (EdwardKmett)
16:50:49 * hackagebot free 2.1.1 - Monads for free  http://hackage.haskell.org/package/free-2.1.1 (EdwardKmett)
16:50:51 * hackagebot rad 0.1.6.3 - Reverse Automatic Differentiation.  http://hackage.haskell.org/package/rad-0.1.6.3 (EdwardKmett)
16:50:53 <c_wraith> Isomorphic, absolutely.
16:51:03 <parcs`> but simply saying 'Mu f ~ f (Mu f)' doesn't really convey what 'Mu f' allows you to do, at least for me
16:51:15 <dmwit> I suppose your complaint is that it isn't defining a new type that's isomorphic to an old type.
16:51:33 <dmwit> Mu f ~ f (Mu f) is not correct. The types are not equal; they're isomorphic.
16:51:47 <parcs`> yeah, my bad
16:52:40 <dmwit> Anyway, I don't think "this isomorphism explains what you can do with this type" is very common at all for any newtype.
16:52:46 <dmwit> So I don't see why Mu is special in that argument.
16:53:03 <dmwit> (And I don't see why the existence of an isomorphism should tell you what you can do with a type anyway.)
16:53:41 <Eduard_Munteanu> Recursive types are isorecursive in Haskell anyway.
16:54:37 <dmwit> e.g. I could write newtype Window = Window Int, but that doesn't mean I can do all Int-like thinks with Windows, nor that I can do Window-like things with Ints.
16:55:03 <dmwit> I can stick Windows in dialog boxes, and I can add Ints. neither operation translates well through the isomorphism
16:55:45 * hackagebot stable-maps 0.0.3.1 - Heterogeneous maps keyed by StableNames  http://hackage.haskell.org/package/stable-maps-0.0.3.1 (EdwardKmett)
16:56:08 <byorgey> but see, that's what *is* special about Mu.  The isomorphism really does tell you everything you need to know about it.
16:56:43 <edwardk> just repeatedly apply the isomorphism and you can peel off as many f's as you need
16:57:16 <dmwit> (assuming f is a Functor)
16:58:23 <Eduard_Munteanu> edwardk: oh, hey, you're around. I was meaning to ask you, what did you say was a better way to combine monads and comonads? Comonad transformers?
16:59:12 <parcs`> dmwit: good point..
16:59:16 <edwardk> you want a comonad on some kleisli category
16:59:17 <Eduard_Munteanu> (versus distributivity stuff)
16:59:32 <edwardk> otherwise you repeat your actions waaaaay too much
16:59:39 <kallisti> where can I find the constructor to IOException?
16:59:47 <dmwit> They're hidden.
16:59:51 <hpc> kallisti: use the source, luke ;)
17:00:09 <kallisti> yes I see that
17:00:12 <kallisti> are they exposed somewhere else?
17:00:22 <dmwit> I'm pretty sure that nope.
17:00:26 <edwardk> @tell eelis i got half way through updating my packages to be compatible with containers, but then i ran into a problem with the fact that parallel isn't ready for the new containers
17:00:26 <lambdabot> Consider it noted.
17:00:32 <hpc> kallisti: why do you need it?
17:00:46 <parcs`> c_wraith: by "perhaps it is" i was referring to the question "why is the previous explanation not convincing" :)
17:00:46 <byorgey> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-IO-Exception.html#IOException
17:00:47 * hackagebot keys 2.1.3.1 - Keyed functors and containers  http://hackage.haskell.org/package/keys-2.1.3.1 (EdwardKmett)
17:00:49 * hackagebot pointed 2.1.0.1 - Haskell 98 pointed and copointed data  http://hackage.haskell.org/package/pointed-2.1.0.1 (EdwardKmett)
17:00:58 <byorgey> we need a "here let me Hoogle that for you" website
17:01:25 <Eduard_Munteanu> edwardk: hm, so I guess you can't get them automatically from comonads / comonad transformers?
17:01:27 <hpc> byorgey: that would work if hoogle wasn't lacking a lot of definitions in the index
17:01:29 <kallisti> byorgey: thanks
17:01:33 <edwardk> Eduard_Munteanu: correct
17:01:39 <hpc> @hoogle mainQuit
17:01:39 <lambdabot> No results found
17:01:45 <kallisti> dmwit: I need to catch UnsatisfiedConstraints thrown by System.Directory.removeDirectory
17:01:53 <ski> @hoogle (a -> b -> b) -> b -> ParsecT s u m a -> ParsecT s u m b
17:01:54 <lambdabot> No results found
17:01:54 <edwardk> Eduard_Munteanu: another observation is that you may be able to use the monad-transformer implied by the comonad, since every comonad gives you a monad-transformer
17:02:06 <edwardk> Eduard_Munteanu: but i haven't tried that approach out
17:02:16 <edwardk> and i have no idea if it even makes sense ;)
17:02:24 <dmwit> How come the haddocks for base on Hackage are so broken?
17:02:44 <dmwit> kallisti: I think you're supposed to use the is* functions.
17:02:47 <hpc> dmwit: link?
17:03:01 <Eduard_Munteanu> edwardk: hm... about that... I also wrote some typeclass magic to decompose monads into adjunctions Hask <-> Hask_M (the Kleisli category of M) hoping I could automatically get a comonad.
17:03:12 <kallisti> dmwit: that's not a thing for that error type.
17:03:27 <Eduard_Munteanu> That does get me a comonad on Hask_M though, maybe that can be used?
17:04:00 <dmwit> My advice seems to be out of date, yes.
17:05:01 <Eduard_Munteanu> edwardk: http://hpaste.org/67745   (I'm not exactly sure it's right, but it seems to work)
17:05:46 <edwardk> Eduard_Munteanu: bookmarked. i'm going to finish uploading packages and head out, but i'll definitely take a look
17:06:15 * ski still doesn't really see why `~' instead of `=' was used for type equality constraint ..
17:06:16 <dmwit> kallisti: Ah, here we go: http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO-Error.html#t:IOError
17:06:24 <hpc> ski: parsing?
17:06:41 <ski> (i suspect that if there's a sensible explanation, it's related to partial types)
17:06:44 <parcs`> ski: "because = is used for too many things" is the official reason i think
17:07:29 <Eduard_Munteanu> Alright. (I initially thought I could automatically get comonads from monads, but that seems like a dead end)
17:07:55 <dmwit> kallisti: no... wait...
17:08:06 <dmwit> bleh, I can't keep all the exception stuff straight
17:08:22 <ski> parcs` : though i don't think "type equality" is really a new thing ..
17:14:57 <parcs`> ski: *shrug* that's the explanation given in "Fun with Type Functions"
17:15:36 <ski> is that the paper with type classes which are functions instead of predicates ?
17:15:57 <c_wraith> it's the one that introduces type families
17:16:15 <c_wraith> (rather than functional dependencies for doing the same thing)
17:16:17 <ski> .. oh, i misunderstood what parcs` were saying
17:16:18 <c_wraith> at least, iirc
17:17:24 <ski> `=' in `type' is ok, but in `data' and `newtype' it's stretching it
17:17:44 <ski> in constraints, i don't think it would be stretching it
17:19:22 <hpc> ski: for data and newtype, you can use GADT syntax
17:19:29 <donri> roconnor__: do you think a makePartialLens[es] could make sense that handles the case of multiple constructors for records with different fields?
17:19:33 <hpc> and pretend the '=' form is shorthand
17:27:11 <donri> roconnor__: but perhaps fall back to normal makeLens behavior for total fields?
17:28:29 <kallisti> aww yeah. recursive move, copy, delete, and merge on arbitrary filesystem trees with some degree of sanity.
17:28:42 <kallisti> (but only some)
17:32:06 <kallisti> would it be more efficient to accumulate a list with DList and snoc, or to accumulate with a linked list and then reverse?
17:33:59 <hpc> kallisti: depends
17:34:05 <hpc> suppose your list is infinite...
17:34:38 <hpc> (although, you would probably find a better way to make an infinite list than snoc)
17:45:50 <nyingen> @quote
17:45:51 <lambdabot> buttbot2 says: such ugly furbutt
17:49:31 <nyingen> @quote
17:49:32 <lambdabot> butt says: is butt x x x x x x x x x x x x x x x x x x x x
17:50:48 <sipa> @quote
17:50:49 <lambdabot> sethg says: I feel like I still don't understand comonads.  Maybe I just need a Zen comaster to hit me with a costick and then I'll become coenlightened.
17:50:51 * hackagebot bytestring-progress 1.0.2.1 - A library for tracking the consumption of a lazy ByteString  http://hackage.haskell.org/package/bytestring-progress-1.0.2.1 (AdamWick)
17:52:22 <aristid> @quote oleg
17:52:22 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
17:52:30 <aristid> there is only one master
17:53:51 <blackdog> hm. reckon it's appropriate to put instance declarations in a .Types module?
17:53:52 <lambdabot> blackdog: You have 2 new messages. '/msg lambdabot @messages' to read them.
18:11:40 <kallisti> hm, does haddock not like Unicode?
18:12:08 <kallisti> maybe I'm using some notation that I'm not aware of
18:12:43 <hpaste> kallisti pasted “parse error in haddock comment” at http://hpaste.org/68260
18:15:22 <monochrom> oh, right, haddock did not understand unicode in some parts, may be fixed in new enough versions
18:19:55 <kallisti> hm, that's no good
18:20:41 <kallisti> ah tree has output options
18:20:57 <JoeyA> If a user runs cabal install --enable-tests my-package, and my test suite fails, does package installation fail altogether?
18:22:41 <dangsos> shapr: howd you do on the final?
18:26:01 <kallisti> monochrom: well switching to ASCII didn't help.
18:26:13 <monochrom> yikes
18:26:39 <kallisti> maybe I should use > instead of @
18:28:01 <kallisti> there we go
18:28:02 <monochrom> yes, there is a difference between > and @. one of them interprets special markup symbols. I forgot which.
18:28:08 <kallisti> @ does
18:28:20 <kallisti> but @ is way more convenient to write for long blobs
18:30:27 <kallisti> luckily there exists such a thing as M-x query-replace
18:31:37 <jeff_s_> Does anyone know of a tutorial or something about the use of Data.Tagged? I discovered it, and now I'm wondering what the purpose of a phantom value is.
18:32:12 <kallisti> I would just learn about phantom types.
18:32:16 <solidus-river> once haskell is compiled down to byte code is it truly threadable? eg can it run on multiple procs safely?
18:32:22 <kallisti> once you know about those, then Data.Tagged is pretty simple.
18:32:29 <jeff_s_> I just discovered http://www.haskell.org/haskellwiki/Phantom_type
18:32:47 <solidus-river> i figured because its purely functional it ought to be but i'm pretty ignorant in that area
18:32:49 <kallisti> yeah Tagged is just a representation of a value wit an associated phantom type.
18:32:54 <ezyang> solidus-river: Yes, Haskell is very threadable.
18:33:05 <ezyang> But you do need lots of runtime support to make it happen.
18:33:51 <solidus-river> ezyang: what do you mean by that?
18:34:35 <vhd> can you declare a polymorphic type inside a type synonym?
18:34:41 <kallisti> vhd: yes
18:35:05 <kallisti> but it might not mean what you think.
18:35:11 <solidus-river> ezyang: as in what does runtime support entail? are you talking about os level?
18:35:13 <vhd> go on
18:35:30 <kallisti> well you can create a type synonym to a rank-n type
18:35:44 <kallisti> type T = forall a. U a
18:36:00 <ezyang> solidus-river: As in, the transformation of Haskell programs to bytecode isn't the magic bit which makes thread-safety happen.
18:36:00 <kallisti> but that's probably not what you want.
18:36:03 <vhd> hmm thats something havent seen before.
18:36:05 <kallisti> if you just want a polymorphic variable
18:36:06 <kallisti> you can do:
18:36:12 <ezyang> (and bytecode only shows up if your running ghci, anyway...)
18:36:15 <kallisti> type T a = U a
18:36:34 <solidus-river> ezyang: so you need to be carefull to make any data structures thread safe, is what your saying?
18:36:39 <ezyang> Runtime support is referring to the "runtime system" of Haskell, which is responsible for actually talking to the OS and figuring things out.
18:36:41 <vhd> but then what I want to constrain that type to a specific class?
18:36:46 <vhd> if*
18:36:54 <kallisti> vhd: (Class a) => T a
18:36:56 <kallisti> no problem.
18:37:08 <ezyang> solidus-river: Ah, well, GHC's runtime system has a much easier job than, say, Python, because most data structures people make are thread safe intrinsically.
18:37:09 <vhd> ok I will try that.
18:37:41 <solidus-river> ezyang: yeah, I guess what i meant is does the byte code automatically thread itself where possible
18:37:52 <kallisti> not implicitly
18:37:54 <ezyang> Stop for a sec, and define *bytecode* for me?
18:38:01 <kallisti> oh, right.
18:38:04 <ezyang> Also, define *thread itself*
18:38:07 <solidus-river> ezyang: i guess what is the process of taking a haskell program, and compiling it to a threadable binary
18:38:08 <kallisti> I read that as "machine code"
18:38:23 <solidus-river> ezyang: I meant native processor instructions
18:38:31 <solidus-river> ezyang: and by thread i mean os threads, not green threads
18:38:47 <solidus-river> ezyang: so i'm interested in the process of taking it from an interpretive language to a compiled executable thats threaded
18:38:47 <Axman6> vhd: don't put class constraints on types, put them on the functions that need those constraints (for instance, the Show instance of Set doen't need to know that the values in the set should implement Ord)
18:38:55 <solidus-river> ezyang: i know the interpretor threads wherever possible
18:39:01 <kallisti> it doesn't implicitly spawn threads without Haskell code telling it to do so, in some way.
18:39:02 <ezyang> solidus-river: OK. Then you're exactly interested in what the RTS does.
18:39:25 <ezyang> The compiled bytecode will contain lots of jumps to symbols in the RTS, and depending on which one you pick, it will be threaded or unthreaded.
18:39:35 <ezyang> The bytecode is "safe" in the sense that it can be linked against the threaded RTS.
18:39:37 <kallisti> you can spawn both OS threads and green threads, but green threads are preferable in most cases.
18:40:13 <solidus-river> how do you spawn threads in haskell?
18:40:28 <mauke> forkIO
18:40:30 <lcfrs> solidus-river: use forkIO
18:40:37 <ezyang> But those are green threads.
18:40:37 <solidus-river> and that has options for green and native threads?
18:40:41 <kallisti> forkIO, forkOS, and par, are 3 ways I know of. There are also many abstractions built on top of these primitives.
18:40:41 <mauke> no
18:40:50 <mauke> I don't think you can spawn "native" threads
18:40:52 <ezyang> No. You cannot directly ask GHC RTS to spawn a native thread.
18:41:15 <kallisti> I thought that was what forkOS was?
18:41:24 <mauke> kallisti: then you failed to read its description
18:41:26 <lispy> hello
18:41:31 <solidus-river> damn, does haskel have a GIL for their green threading?
18:41:31 <ezyang> forkOS arranges the illusion that a green thread is run on only one thread.
18:41:45 <lispy> solidus-river: GIL?
18:41:50 <ezyang> But it won't spawn a new thread, it'll just pick one OS thread out of the pool.
18:41:53 <ezyang> global interpreter lock
18:41:59 <ezyang> GHC has no need for such things!
18:42:09 <ezyang> Though we do have stop-the-world GC :-(
18:42:22 <lispy> ezyang: I think we have a parallel gc as well
18:42:27 <lispy> (I could be wrong)
18:42:39 <vhd> Axman6, thats what I would prefer to do but when I have type synonyms where I dont want to specify something specifc what options do I have?
18:42:46 <Axman6> solidus-river: GHC has about the fastest threading runtime of any language implementation out there (even faster than Erlang's). you don't get that sort of speed by using locks ;)
18:43:16 <ezyang> I think it's parallel gc for local collections.
18:44:23 <solidus-river> Axman6: haha, just doing my research before i dive in. So does Haskell compile to bytecode or just machine code
18:44:35 <ezyang> machine code
18:44:47 <lcfrs> i'm trying to build GHC as a smaller binary. is there a way to avoid linking unnecessary things to it? for e.g. the profiler?
18:44:51 <Axman6> both i think. i believe GHCi uses some form of bytecode... ezyang knows more than I do =)
18:44:53 <ezyang> @google ghc trac
18:44:56 <lambdabot> http://hackage.haskell.org/trac/ghc/
18:44:56 <lambdabot> Title: GHC
18:45:03 <ezyang> ^-- lots of information
18:45:12 <ezyang> Axman6: yep that's right
18:45:17 * Axman6 wins
18:46:56 <PeTiTa_MoNgEtA> hi
18:47:01 <solidus-river> very cool, I'll read up on the link some more
18:48:21 <Axman6> solidus-river: also, IMO, Haskell is one of, if not the, best languages for single machine concurrency. Erlang is a lot easier for using multiple machines without much effort, but Haskell still has it beat on a multicore environment. We've also got a clear distinction between concurrency and parallelism
18:48:39 <solidus-river> I was running through the haskell tutorials working my way towards monads and went to take a break to do a quick node.js server so i can say its something i've done. It seems like the thing people like node for is that its functional and easily non blocking, I'm trying to find out why they aren't as happy about haskell, it seems like its got everything under its belt that javascript has but is much much more non-blocking and logical
18:48:50 <solidus-river> maybe its that haskell has a higher memory footprint?
18:49:10 <ezyang> Haskell is very opinionated
18:49:19 <ezyang> And we haven't quite convinced everyone that its opinions are right
18:49:27 <kallisti> don't forget that Haskell uses actual concurrency.
18:49:30 <Axman6> we don't like javascript developers, they can stick with the pain that is node.js :P
18:49:39 <solidus-river> lol
18:49:40 <parcs`> haskell also has a very high learning curve, while node.js is just javascript
18:49:48 <kallisti> whereas node.js is just asynchronous stuff  (I believe)
18:50:08 <monochrom> node.js supports more non-blocking operations because it has no green thread story. haskell supports more blocking operations because it has an excellent green thread story.
18:50:36 <ezyang> JS also has this benefit that, you know, all web browsers run it
18:50:47 <kallisti> Python also has a lot of asynchronous IO libraries, because its threading libraries are poor.
18:51:05 <kallisti> I think this is just what languages with poor concurrency implementations do.
18:51:19 <solidus-river> kallisti: yeah, pretty much, I don't really get what the hype is, I get that JavaScript is a pretty cool language, but if your trying to get functional on a server it seems like server side JavaScript is the weirdest Frankenstein way to do it ever.
18:51:38 <solidus-river> threading in python SUCKS!
18:51:45 <ezyang> Language uniformity gives definite engineering bonuses
18:51:55 <solidus-river> i was trying to help a friend though it and then i started looking through their libs for it and my response was pretty much, dont bother
18:52:18 <blackdog> solidus-river: the GIL doesn't help much
18:54:51 <blackdog> solidus-river: rereading the implementation notes... "you can run as many python threads concurrently as you like, so long as they're not actually executing any python"
18:54:54 <blackdog> the mind, she boggles.
18:55:07 <monochrom> haha
18:55:07 * blackdog is not paraphrasing
18:55:13 <blackdog> *is paraphrasing
18:55:53 * hackagebot HandsomeSoup 0.3.1 - Work with HTML more easily in HXT  http://hackage.haskell.org/package/HandsomeSoup-0.3.1 (AdityaBhargava)
18:56:07 <monochrom> there was once a Byte magazine article that concludes, "Windows NT is a stable OS, as long as you just compare with Windows 95" :)
18:58:17 <shapr> dangsos: join #haskell-blah, I'll tell you all about the final
19:02:03 <booyah> eat a programming elephant one byte at a time
19:02:53 <byorgey> nom nom nom
19:03:21 <Axman6> @src callCC
19:03:22 <lambdabot> Source not found. Are you on drugs?
19:03:24 <Axman6> :(
19:04:01 <monochrom> it is a class method. you have to craft a more elaborate command to get the code for a particular instance. if lambdabot has it, that is
19:04:18 <byorgey> @hoogle callCC
19:04:18 <lambdabot> Control.Monad.Trans.Cont callCC :: ((a -> ContT r m b) -> ContT r m a) -> ContT r m a
19:04:18 <lambdabot> Control.Monad.Cont.Class callCC :: MonadCont m => ((a -> m b) -> m a) -> m a
19:04:18 <lambdabot> Control.Monad.Cont callCC :: MonadCont m => ((a -> m b) -> m a) -> m a
19:04:36 <booyah> byorgey: one monad at a time?
19:04:44 <tehgeekmeister> i have an open ended question, for whoever's around: if you needed to separate some text into chunks, and only print chunks that satisfied a predicate, how would you do that as efficiently as possible in haskell?
19:04:51 <byorgey> booyah: that would be "mon mon mon"
19:05:01 <tehgeekmeister> i've been playing around with this for months, and i'm not having any great luck with it so far
19:05:06 <tehgeekmeister> figured it's time to just ask how others would do it
19:05:08 <Axman6> tehgeekmeister: depends how you need to separate those chunks
19:05:53 <tehgeekmeister> Axman6: in the specific case at hand, it was grabbing a certain field from a flat json object, one json object per line
19:06:11 <monochrom> cut into list of chunks. filter. perhaps I may fuse them by hand.
19:07:06 <tehgeekmeister> so something like filter p .  makeChunks =<< getContents ?
19:07:49 <tehgeekmeister> i'm really interested in specifics, because i've tried three different enumerator packages, tweaked buffer sizes, switched underlying data structures, etcetera, and i can't get past being gc/allocation bound.
19:19:40 <napping> Is this in HEAD yet? http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/icfp12.pdf
19:20:56 * hackagebot cond 0.2 - Basic conditional and boolean operators with monadic variants.  http://hackage.haskell.org/package/cond-0.2 (AdamCurtis)
19:27:34 <parcs`> napping: think so
19:28:52 * Polarina would think that's bad practise.
19:29:07 <napping> The paper claims it at the bottom of the first page, I just got that far
19:29:28 <parcs`> it was added a little before the release of 7.4.1
19:30:19 <napping> I've got 7.4.1
19:31:42 <parcs`> it didn't make it to 7.4 sadly :(
19:32:13 <Polarina> I wish I knew what all these symbols meant.
19:32:22 <napping> Polarina: running broken programs seems to be popular
19:35:12 <napping> If this were #agda I might believe that you didn't!
19:43:40 <Polarina> Is is possible to get a list of packages on Hackage that have another specific package as a dependency?
19:46:43 <kallisti> question: if you had a typeclass representing a boolean algebra
19:46:52 <kallisti> would it be unreasonable to require an Eq superclass?
19:52:54 <monochrom> it may be bad to require Eq. Int->Bool is a boolean algebra
19:58:10 <dmwit> Polarina: It's called "reverse dependencies", and there are a few tools out there that do it. Dunno where exactly, but googling the term (plus maybe "Hackage") ought to find them.
19:58:14 <dmwit> Maybe lambdabot knows.
19:58:16 <dmwit> ?where revdeps
19:58:16 <lambdabot> "Show reverse dependencies" at <http://hackage.haskell.org/trac/hackage/ticket/576>,"Hackage with Reverse Dependencies" by Roel van Dijk at <http://bifunctor.homelinux.net/~roel/hackage/packages/
19:58:16 <lambdabot> hackage.html>,"Reverse Dependencies" at <http://bifunctor.homelinux.net/~roel/hackage/packages/archive/revdeps-list.html>,<http://packdeps.haskellers.com/reverse> -- `bifunctor.homelinux.net' is
19:58:16 <lambdabot> broken, use `81.26.216.99' instead
19:58:21 <dmwit> \o/
19:59:03 <dmwit> Dunno much about boolean algebras, but I would be surprised if f Bool was such a thing for all Functors f.
19:59:24 <dmwit> ...maybe Applicative f.
20:01:27 <dmwit> Oh, cool, does this mean we're going to have a way to open up errorful files in ghci and muck about with them before we've figured out how to fix them?
20:01:39 <dmwit> I've wanted that plenty of times (as I'm sure we all have).
20:04:34 <dmwit> GHC's core language is getting quite interesting.
20:05:06 <dmwit> I was going to say complicated, but given how many things it can express that hardly seems fair.
20:05:49 <booyah>  sometimes i wish code would just code itself too
20:05:56 <napping> It's actually very nicely done, just using the existing distinction between unlifted and lifted types
20:06:36 <napping> booyah: http://www.augustsson.net/Darcs/Djinn/
20:06:59 <augur> so
20:07:02 <augur> unless it's been invented before
20:07:07 <augur> i think i've invented multi-hole zippers
20:07:19 <booyah> napping: hmm?
20:08:09 <napping> @djinn (a -> b) -> (b -> c) -> (a -> c)
20:08:09 <lambdabot> f a b c = b (a c)
20:09:19 <monochrom> I code myself. does that count?
20:10:02 <kallisti> um
20:10:04 <kallisti> import Data.Monoid (Any(..), All(..), Dual(..), Endo(..))
20:10:09 <kallisti>     Not in scope: data constructor `Endo'
20:10:19 <dmwit> Endo is the type constructor.
20:10:27 <kallisti> isn't it also the data constructor?
20:10:36 <dmwit> ...and the value constructor, according to haddock.
20:10:37 <dmwit> weird
20:10:51 <monochrom> is it even in Data.Monoid?
20:11:01 <dmwit> yes
20:11:02 <kallisti> according to the docs.
20:11:10 <kallisti> even in 3.0.3.1
20:11:29 <dmwit> cannot reproduce
20:11:36 <dmwit> :t Endo works fine after that import here
20:11:37 <lambdabot> parse error on input `import'
20:11:46 <dmwit> Did you definitely save the file? =P
20:12:36 <kallisti> oh. actually. yes that's the issue.
20:12:39 <kallisti> I moved the file.
20:12:42 <kallisti> didn't move my emacs buffer. :P
20:13:04 <monochrom> works here in ghc 7.0.3, though I put that line in a file, not as a ghci command
20:13:25 * monochrom does not yet trust the "import" command at ghci prompt
20:13:53 <tgeeky> monochrom: do you trust :m +?
20:14:03 <monochrom> yes, that one I trust, has never failed
20:14:04 <tgeeky> monochrom: supposedly (tm) after 7.4.1 they are equivalent?
20:14:28 <dmwit> Nobody has claimed they're equivalent.
20:14:50 <dmwit> And that's a good thing, because they're not.
20:14:51 <monochrom> I play with 7.4.1 occasionally, but not frequently enough
20:14:57 <tgeeky> dmwit: the release notes?
20:15:01 <tgeeky> dmwit: let me check what it says
20:15:47 <tgeeky> dmwit: don't get me wrong, these days I believe you more than I believe me
20:16:39 <monochrom> currently, I use 7.4.1 for only playing new extensions (ContraintKind etc) or proving that people's cabal-install problems cannot be reproduced
20:17:25 <tgeeky> dmwit: The :m +M and import M GHCi commands now do exactly the same thing.
20:17:29 <tgeeky> file:///C:/msg/lang/h-7.4.1/doc/html/users_guide/release-7-2-1.html
20:17:39 <dmwit> Yes, that's not the same as saying :m + and import do the same thing, though.
20:17:53 <monochrom> on that note, ConstraintKinds is quite fun
20:18:13 <dmwit> Try :m + Data.Monoid(Endo(..)) and you'll see what I mean.
20:18:25 <hpaste> kallisti pasted “what instances am I forgetting?” at http://hpaste.org/68261
20:18:26 <kallisti> ^^^
20:19:20 <dmwit> instance Applicative f => Boolean (f Bool)
20:20:01 <kallisti> :(
20:20:10 <kallisti> I don't like instances that look like that.
20:20:22 <dmwit> possibly some kind of instance Bits a => Boolean (NewTypeWrapper a)
20:20:26 <dabblego> Either () (), Maybe ()
20:20:41 <dmwit> I think you could be excused for skipping dabblego's examples
20:20:51 <dabblego> yeah just kiddin'
20:21:03 <dmwit> kallisti: Oh, you're right, it doesn't collide with enough things.
20:21:11 <dmwit> instance (Applicative f, Boolean b) => Boolean (f b)
20:21:14 <kallisti> :(
20:21:17 <kallisti> :_(
20:21:24 <tgeeky> dmwit: Oh. You're just saying that bringing a module into scope in GHC isn't identical to what you can do in a file.
20:21:36 <kallisti> dmwit: I already have lifted operators and functions and stuff.
20:21:45 <dmwit> tgeeky: Correct.
20:21:51 <kallisti> also what's a good precedence for implies and xor?
20:22:01 <kallisti> implies should be lowest, I think?
20:22:25 <dabblego> (==>) = implies
20:22:37 <kallisti> I like `implies` >_>
20:23:03 <kallisti> also --> is a valid operator
20:23:09 <tgeeky> dmwit: I was going to say, that they are equivalent in the sense of GHCi, but that's evidently not even true. import actually works. So that line is a lie! :o
20:23:23 <monochrom> you should have a Heyting Algebra that is a superclass of Boolean Algebra :)
20:23:39 <tgeeky> though to be fair, they did add the overall "can do everything in ghci" thing in 7.4.1
20:23:44 <kallisti> monochrom: I don't know enough maths for that. patches welcome.
20:23:56 <kallisti> someone also recommends lattices
20:23:59 <kallisti> another thing I know little about.
20:24:01 <kallisti> but once day!
20:24:04 <kallisti> *one
20:24:09 <tgeeky> dmwit: can you make a todo and wishlist for p-e-e?
20:24:16 <tgeeky> perhaps in github somewhere
20:24:24 <dmwit> tgeeky: Why not just make an issue on the issue tracker?
20:24:42 <hpaste> vhd pasted “cool” at http://hpaste.org/68262
20:24:54 <dmwit> kallisti: A Heyting algebra is a boolean algebra minus negation, I think.
20:24:56 <tgeeky> dmwit: that will work too. I don't have an issue. I want to see your layout of work that needs to be done
20:25:00 <vhd> ^ what is the best way to deal with a problem in my paste.
20:25:03 <kallisti> dmwit: oh.
20:25:09 <dmwit> (though a==>0 looks pretty nearly like a negation)
20:25:16 <vhd> the problem*
20:25:21 <monochrom> minus negation, so now implication is a primitive operator
20:25:29 <kallisti> my default implementation of not is
20:25:32 <kallisti> not = xor true
20:25:46 <dmwit> That's a terrible default implementation.
20:25:50 <dmwit> I lied.
20:25:52 <kallisti> lol
20:25:54 <dmwit> Also, I'm an idiot.
20:25:55 <kallisti> for Bool it's
20:25:59 <kallisti> not = (/=)
20:26:00 <kallisti> er
20:26:03 <kallisti> xor = (/=)
20:26:20 <dmwit> tgeeky: I guess there's just the eta and epsilon base isomorphisms to add.
20:26:43 * kallisti notes that there's a bug in AC-boolean where xor = (==)
20:27:03 <dmwit> vhd: Why not let a ~ b?
20:27:05 <Eduard_Munteanu> Mm, Wikipedia says Heyting algebra + LEM gives you a boolean algebra.
20:27:09 <tgeeky> dmwit: traces?
20:27:21 <dmwit> vhd: That is, example :: Cool a => Bool -> Som a -> Some b -> IO ()
20:27:25 <dmwit> tgeeky: Already available!
20:28:18 <vhd> dmwit, because the a and b are indeed not garunteed to be the same. However the usage of them is only based on the Cool class.
20:28:28 <dmwit> I guess not quite available, but maybe ten minutes' work to add.
20:28:37 <dmwit> vhd: Then you will need to write it thus:
20:28:50 <monochrom> I think the basic idea is that someone doesn't want to write "if bl then do { coolf da; coolg db } else { coolf db; coolg da }"
20:28:51 <dmwit> if b1 then coolf ca >> coolg cb else coolf cb >> coolf ca
20:28:55 <dmwit> vhd: or similarly
20:29:16 <monochrom> err, s/da/ca  s/db/cb
20:29:18 <vhd> monochrom, yes thats exactly it, my actual function is rather big so I want to avoid that.
20:29:24 <kallisti> oh I guess I should have a biconditional as well.
20:29:27 <dmwit> Well that is just too bad.
20:29:41 <dabblego> biconditional = (==)
20:29:41 <vhd> I see, I thought maybe there was a better way of doing it.
20:29:47 <dabblego> you might want notimpliesa
20:29:55 <sipa> what's a biconditional?
20:29:55 <kallisti> wat
20:30:07 <kallisti> for Bool, it's (==)
20:30:10 <dabblego> sipa: biconditional is a synonym for equivalence
20:30:12 <kallisti> it's also the negation of xor.
20:30:26 <dabblego> p => q && q => p
20:30:27 <sipa> dabblego: thanks
20:30:49 <monochrom> there are two solutions, both treacherous. one uses template haskell, the other uses existential types
20:31:30 <flebron> Hi. Just to get started, is it sort of appropriate to think of Applicative as a monad where composition of functions of the type is controlled by the type, but the _order_ in which operations are applied isn't?
20:31:49 <dabblego> flebron: think of Applicative as Monad without join
20:32:14 <flebron> well what do I have then? because join is just bind id, so i don't have bind either?
20:32:22 <dabblego> right you don
20:32:23 <dabblego> don't
20:32:30 <dabblego> but you have f (a -> b) -> f a -> f b
20:32:35 <flebron> so i just have return and fmap? isn't that a pointed functor?
20:32:42 <dabblego> yes, but it's more than that
20:32:53 <dmwit> tgeeky: Hm. I guess it depends what information you want out of the trace.
20:32:56 <flebron> that one i was trying to imagine as fmap but for multiple argument functions
20:33:00 <kallisti> how should I organize the minimally complete definitions...
20:33:12 <dabblego> you have f (a -> b) -> f a -> f b instead of (a -> f b) -> f a -> f b
20:33:46 <dmwit> flebron: f (a -> b) -> f a -> f b is more than you get from just return and fmap.
20:33:49 <flebron> like, if i have f: a -> b -> c, and i have M a and M b, i can't just fmap f, because that gives me M a -> M (b -> c), the return value of which is useless without knowing what to do with M (b -> c)
20:34:05 <flebron> so a sort of "fmap but for multiple arguments"
20:34:15 <kallisti> hm, how do I define logical implication in terms of other logical operators.
20:34:18 <dabblego> flebron: right, liftA2
20:34:43 <flebron> or really liftAx, is what I imagine it gives me
20:34:44 <napping> kallisti: perhaps you can't. not a \/ b is the usual way
20:34:52 <dabblego> kallisti: not p || q
20:34:59 <kallisti> oh wait duh
20:35:14 <kallisti> that's the first thing you learn about boolean operators. :P
20:35:16 <flebron> :p
20:35:18 <kallisti> (one of them)
20:35:27 <napping> doesn't work in constructive logic, though
20:35:28 <Eduard_Munteanu> You surely can... write down a truth table for implication, get the same thing using the other stuff you know.
20:37:32 <flebron> also a professor explained some semantics behind arrows to me today, in some sense an arrow lets you remove the static computation out of the non-static one. like if you had \x -> (1, f x), you could get something like (1, \x -> f x). but i'm not concerning myself with this yet :p
20:39:31 <tgeeky> dmwit: In general I suppose it won't be true that 'every compact category admits a trace' implies that it admits only one?
20:40:07 <tgeeky> i've never seen the traced monodial category laws before. they don't look too bad.
20:40:14 <monochrom> heyting algebra is for propositional intuitionistic logic
20:41:07 <dmwit> hm
20:42:02 <Eduard_Munteanu> That thing looks like costrength I guess, maybe it isn't really an arrow-specific example?
20:42:48 <kallisti> yeah I can't read this Wikipedia article on Heyting algebras. :P
20:42:58 * Eduard_Munteanu should look into the CT stuff about arrows sometime
20:43:36 <dmwit> tgeeky: I suppose not, though I can't give you an example.
20:43:52 <tgeeky> dmwit: well clearly that can't be true. I was reading an article for a 'traced symmetric monodial category'. Surely that implies there's there an anti-symmetric construction
20:44:06 <tgeeky> or some other kind of one
20:44:09 <monochrom> yikes. heyting algebra is pretty easy. I should just dictate it to you. yes some wikipedia authors are way too excited and get carried away with adding more and more abstract nonsense
20:44:22 <tgeeky> dmwit: perhaps I should consult that paper I linked
20:45:06 <Eduard_Munteanu> monochrom: mm, it's pretty easy if you already grok stuff like meets and joins, otherwise... :/
20:45:28 <Eduard_Munteanu> I guess some background on lattices is helpful.
20:45:49 <tgeeky> dmwit: I wrote in my first read through: what about other examples? instead of x + y <-> x + z; what about x + y + z + t <-> (t - x - y - z)
20:47:51 <dmwit> tgeeky: I don't think traced symmetric monoidal implies there's such a thing as traced antisymmetric monoidal.
20:48:15 <dmwit> There may be an antisymmetric monoidal category, but I'm not confident it makes sense to define traces in such a thing.
20:48:53 <monochrom> oh lattice is easy too. you have two binary operators &&, ||. both of them associative, commutative, idempotent (e.g., x&&x = x). lastly, absorption law: x&&(x||y) = x, x||(x&&y) = x.
20:48:54 <dmwit> I'm not even confident there's such a thing as antisymmetric monoidal categories that people study, though.
20:49:15 <dmwit> There are monoidal categories that aren't symmetric.
20:49:25 <dmwit> And there are symmetric monoidal categories that aren't traced.
20:49:33 <tgeeky> dmwit: yes. Baez wrote a great 120 page paper about them that I read :o
20:49:58 <Eduard_Munteanu> dmwit, tgeeky: are you reading some paper?
20:50:12 <Eduard_Munteanu> I was looking at traced monoidal categories, and it looks interesting.
20:50:17 <dmwit> Well, we're implementing the "Two Dualities" paper.
20:50:26 <tgeeky> Eduard_Munteanu: dmwit is implementing pi-eta-epsilon, which is in the negative-fractional paper.
20:50:32 <dmwit> https://github.com/dmwit/pi-eta-epsilon
20:50:34 <tgeeky> Eduard_Munteanu: I'm watching and learning.
20:50:42 <kallisti> should my Boolean typeclass has a toBool method?
20:50:43 <monochrom> with a lattice, you get a partial order. let me use ≤ for the partial order symbol. x≤y iff x&&y=x iff x||y=y. I need this partial order to define heyting algebra
20:50:44 <dmwit> tgeeky: ...OH!
20:50:45 <Eduard_Munteanu> Thanks.
20:50:49 <dmwit> tgeeky: Is that what you meant by trace earlier?
20:51:01 <tgeeky> dmwit: is what?
20:51:12 <dmwit> tgeeky: I thought you meant you wanted a way to trace the computation of a term as it evolved through MachineStates!
20:51:24 <dmwit> You just meant the trace from the traced category...
20:51:39 <tgeeky> dmwit: yes. Though if that other thing is something cool, I'll take credit for it.
20:51:42 <dmwit> Then as soon as eta and epsilon are written, you get the trace for free (it's a derived term defined by the graphic on page whatever of the paper).
20:52:09 <dmwit> page 6
20:52:15 <monochrom> a heyting algebra has the above &&, ||, ≤, plus an implication operator ==>, with this axiom: c ≤ a==>b iff c&&a ≤ b.  you can mumble something about a Galois connection if you are inclined to
20:52:15 <tgeeky> dmwit: yes.
20:52:27 <Eduard_Munteanu> dmwit: mm... "A Tale of Two Dualities"?
20:52:28 <tgeeky> dmwit: I wanted this in code somewhere, so I could try alternatives and other weird things.
20:52:58 <dmwit> Eduard_Munteanu: "The Two Dualities of Computation: Negative and Fractional Types"; the pdf is at the github I linked.
20:53:10 <tgeeky> Eduard_Munteanu: https://www.cs.indiana.edu/~sabry/papers/rational.pdf <-- also here
20:53:12 <Eduard_Munteanu> Ah.
20:53:28 <dmwit> pretty cool paper
20:53:28 <tgeeky> i prefer to call it negative-rational, since PEE is a little weird.
20:53:47 <monochrom> there is no other requirement on ==> than the above axiom
20:53:48 <dmwit> I rather like typing runPEE in ghci.
20:53:49 <dmwit> makes me giggle
20:53:52 <tgeeky> hehe
20:54:52 <Eduard_Munteanu> @tell dylukes You might want to look at https://www.cs.indiana.edu/~sabry/papers/rational.pdf "The Two Dualities of Computation: Negative and Fractional Types", just mentioned by dmwit in #haskell.
20:54:53 <lambdabot> Consider it noted.
20:54:55 <monochrom> note: ==> is a binary operator, not a relation
20:55:55 <tgeeky> dmwit: in particular, the things listed under Examples
20:55:55 <monochrom> i.e., (==>) :: (Heyting a) => a -> a -> a.  in contrast with (≤) :: (Blah a) => a -> a -> Bool
20:55:57 <tgeeky> in: http://en.wikipedia.org/wiki/Compact_closed_category
20:57:01 <tgeeky> are all things which have very different reprentations normally from anything that I can imagine so far in PEE
20:58:34 <Eduard_Munteanu> monochrom: admittedly/confusingly ≤ might also denote an implication depending on the particular lattice one's concerned with, no?
20:59:19 <monochrom> right, so I have to write out the types to be clear
21:18:13 <jmcarthur> dmwit: i look forward to your implementation!
21:21:36 <dmwit> jmcarthur: What will finish first, the evaluator or the parser? =)
21:30:13 <jmcarthur> heh
21:30:27 <jmcarthur> evaluator!
21:30:40 <jmcarthur> i prefer embedded DSLs anyway :)
21:31:57 <dmwit> Oh, you're not jfischoff at all!
21:32:10 <dmwit> That was meant to be a poke in the ribs, since he's the one working on the parser. =P
21:46:07 <tehgeekmeister> alright, i'm back to ask more about it.  this program i'm obsessed with optimizing lately that does a lot of string manipulation is GC and allocation bound, regardless of which datastructures or algorithmic changes i try.  how's good to go about optimizing those sorts of things in haskell?
21:46:40 <tehgeekmeister> (http://stackoverflow.com/questions/10273696/why-does-haskell-enumerator-based-io-call-sigprocmask-so-often <== has some background of the problem i'm approaching in general, for anyone interested)
21:47:12 <ezyang> fuuuuusion
21:47:58 <tehgeekmeister> ezyang: i haven't found any way to get fusion to work for the problem i'm working on, but i admittedly am no haskell guru, so, if you can point me the right direction, i'll pursue it obsessively on my own
21:49:20 <ezyang> I don't actually know what you're doing algorithmically.
21:50:35 <tehgeekmeister> simple description, though it's really just an example problem: unnested hashes, represented as json, one per line.  grab the value for a specified key and print it, for each line it occurs on.
21:55:27 <tehgeekmeister> yeah, just tried switching it to text, and am using only functions that are subject to fusion, and it goes faster until it seizes up, but it still seizes a few seconds in.
21:56:14 <tehgeekmeister> ezyang: https://gist.github.com/2641906
21:56:36 <kallisti> I can't seem to get haddock to display bulleted lists in my cabal description
21:57:28 <ezyang> I think you should use a better algorithm for string searching...
21:57:50 <tehgeekmeister> i *thought* i was using a decent one, but i'm happy to learn of a better one
21:58:03 <tehgeekmeister> the head and tail cost centers seem to do an equal portion of the suspect allocation in the profiling summary
21:58:55 <ezyang> KMP?
21:59:12 <ezyang> Boyer-Moore?
22:00:07 <mzero> wondering why, for this simple chore, all the threading through Pipe?
22:01:17 <tehgeekmeister> mzero: mainly because i went that way months back, after using hGetContents blew up (thrashed VM so hard i had to restart).
22:01:32 <mzero> how big is this input file?
22:01:46 <tehgeekmeister> 1gb is the test file, but the real dataset is hundreds of gigs
22:02:01 <tehgeekmeister> but all small files
22:02:14 <tehgeekmeister> (the 1gb test file is a number of them concatenated)
22:02:17 <mzero> right, but there is an easy place between hGetContents and this
22:02:35 <mzero> like just writing the obvious read-line loop
22:03:05 <tehgeekmeister> ezyang: apparently my intuition on the cost of the naive algorithm was way wrong.  glad that was pointed out to me.  thanks.
22:03:27 <mzero> my guess is that you've threaded the simple `isInfixOf` search into the monadic machinery of Pipe --- I'm sure that's what's killing you
22:04:54 <tehgeekmeister> in this case, no, most of the time my algorithm does that entirely with plain recursion.  i'm really only using pipe to request more input.
22:05:21 <tehgeekmeister> in fact, a loop of calls to hGetLine would be a much more straightforward way of doing what i'm after.  i'll give that a try.
22:05:36 <mzero> why not a simple:    { s <- T.hGetLine; if (name `T.isInfixOf` s) then T.putStrLn s else return () }
22:05:37 <mzero> '
22:05:42 <mzero> in a loop?
22:06:23 <tehgeekmeister> that's not *quite* the right algorithm
22:06:25 <tehgeekmeister> it gets the filter
22:06:34 <tehgeekmeister> but it doesn't print just the value associated with the key
22:07:01 <mzero> well, searching for that string isn't right either - if it is JSON, you'll need to parse
22:07:28 <mzero> but just use Aeson - it'll be easy
22:07:53 <tehgeekmeister> well, the original exercise was to compare it to a one off thing i did in perl, and i didn't parse it there, either, so for the sake of fairness, i didn't parse it in haskell
22:07:54 <mzero> you could use the string inclusion test as an optimization hint to avoid parsing every line
22:08:22 <tehgeekmeister> eh, most lines will have the key, it's not worth the complexity.
22:11:15 * hackagebot cond 0.3 - Basic conditional and boolean operators with monadic variants.  http://hackage.haskell.org/package/cond-0.3 (AdamCurtis)
22:11:17 * hackagebot fs-events 0.1 - A haskell binding to the FSEvents API  http://hackage.haskell.org/package/fs-events-0.1 (NickPartridge)
22:19:25 <tehgeekmeister> mzero: so, just as a test, i wrote a program that only reads in a file, line by line, and even it is surprisingly slow.
22:19:56 <mzero> hpaste?
22:20:00 <tehgeekmeister> it peaks at about 20MB/s, which is closer to the slowest i'd like this to go.
22:20:01 <tehgeekmeister> sure
22:22:56 <hpaste> tehgeekmeister pasted “cat” at http://hpaste.org/68264
22:23:35 <tehgeekmeister> on this last run it was performing reasonably, much better than the figure i just quoted, but i think that might be partially because part of the file is buffered now.
22:23:51 <mzero> and you are compiling this -O2?
22:24:22 <tehgeekmeister> nope, but i can
22:24:24 <mzero> !
22:24:37 <tehgeekmeister> what?
22:24:54 <mzero> uhm, without -O2 many many things are very slow
22:25:01 <tehgeekmeister> oh.
22:25:09 <tehgeekmeister> good to know.
22:25:43 <tehgeekmeister> haskell is not my main language, though i'd very much like it to be.  slowness has been the main reason it can't be, so, maybe i'm on the right track here.
22:26:55 <tehgeekmeister> that made a very noticeable improvement to cat
22:27:06 <tehgeekmeister> i'll give that a try on the other one, too
22:28:36 <blackdog> tehgeekmeister: other thing that may be useful to look into is the buffering mode
22:28:38 <strager> tehgeekmeister: Probably better to use ByteString IO
22:28:49 <blackdog> not sure what the default is, but i imagine you probably want blockbuffering...
22:28:51 <strager> As this is parsing text then unparsing it
22:28:51 <mzero> or Text
22:29:02 <strager> well not unparsing
22:29:13 <mzero> actually, as he's parsing JSON, BytString
22:29:31 <mzero> er, what strager said :-)
22:29:51 <tehgeekmeister> blackdog: i've played with the buffering mode previously, didn't get much improvement from that
22:30:34 <blackdog> tehgeekmeister: -O2 and Text will make bigger differences
22:30:52 <augur> anyone really familiar with zippers willing to look something over for me?
22:30:58 <tehgeekmeister> i have both of those in my current version - it chokes after about a hundred lines.
22:31:05 <tehgeekmeister> must be my algorithm
22:31:25 <blackdog> tehgeekmeister: hpaste:)
22:31:26 <tehgeekmeister> there's a ton of allocation happening on two lines, but i can't figure out why
22:31:51 <tehgeekmeister> i put a gist up a bit ago, finding the link again
22:32:04 <tehgeekmeister> https://gist.github.com/2641906
22:32:10 <mzero> scratch that stuff with Pipe
22:32:21 <tehgeekmeister> alright
22:32:39 <mzero> you are taking a linear character search, which isn't so bad... but by hoisting into the Pipe monad, it is insanely expensive
22:34:44 <blackdog> tehgeekmeister: is that just string search, or am i missing something?
22:35:13 <tehgeekmeister> blackdog: basically just string search, except with a bunch of cruft to make it work in the pipe monad
22:36:58 <blackdog> tehgeekmeister: line-oriented?
22:37:12 <tehgeekmeister> blackdog: in current incarnation, yeah.
22:37:36 <tehgeekmeister> which makes pipe total overkill, really
22:39:44 <blackdog> tehgeekmeister: if you just want to solve your problem, i'd have a look at stringsearch on hackage.
22:40:12 <roconnor__> @tell donri yes, I think a makePartialLens[es] could make sense that handles the case of multiple constructors for records with different fields.
22:40:12 <lambdabot> Consider it noted.
22:40:38 <tehgeekmeister> blackdog: oh, man.  why didn't i consider that, like, months ago.
22:40:49 <tehgeekmeister> i actually am more interested in learning, but i will play with that too.
22:40:51 <blackdog> if it's for learning: calling length on rest is probably suboptimal, given that you then have to look at the whole Text chunk when what you actually care about is whether it's null or not.
22:41:22 <tehgeekmeister> my end goal is to figure out how to do these sorts of tasks efficiently enough in haskell that i can use it for most of this work
22:41:27 <tehgeekmeister> rather than perl
22:42:06 <blackdog> how big's your sample file, btw?
22:42:30 <tehgeekmeister> 1gb
22:42:36 <tehgeekmeister> the actual files are very small, but many in a row
22:42:51 <tehgeekmeister> i normally cat them all together and pipe them to whatever i'm using to process them
22:43:49 <blackdog> right. well, aeson seems to get between 20 and 40 mb/s, and that's parsing everything
22:44:18 <blackdog> so it should be possible to do better with just a dumb string matching search
22:45:33 <tehgeekmeister> alright
22:46:00 <tehgeekmeister> that's competitive with perl, which is my real need
22:46:17 <tehgeekmeister> i can't use a tool that's significantly slower since this is something i use regularly
22:52:04 <tehgeekmeister> well, now i have a good problem.
22:52:15 <tehgeekmeister> the haskell version runs too fast for me to benchmark it using this data.
22:52:38 <mzero> :-)
22:52:39 <blackdog> ha!
22:52:52 <kallisti> it's not difficult to be competitive with Perl.
22:52:53 <mzero> we're sorry, we can't help you with that problem
22:52:58 <c_wraith> sure we can
22:53:04 <c_wraith> benchmark it with criterion
22:53:08 <tehgeekmeister> which, in retrospect, might've been the problem with the other versions (they didn't do any EOF checking), so they might've just been spinning around like crazy, doing nothing.
22:53:09 <c_wraith> it will run it multiple times
22:53:19 <tehgeekmeister> oh, i have tons more data lying around
22:53:30 <roconnor__> use runhaskell to run the code interpreted instead of compiled!
22:53:31 <tehgeekmeister> i'll move onto criterion in another session.
22:54:18 <tehgeekmeister> kallisti: that's what i'd been hoping for, but i can't give much time to haskell fun, until i get more reward, so i hadn't found the right approach yet.
23:00:32 <kallisti> hmm for large directories getDirectoryContents is actually pretty slow.
23:02:17 <kallisti> slower than tree (a C program to traverse and display directories) on the equivalent traversal.
23:02:37 <kallisti> (the cache was "warm" for both of them)
23:04:02 <tehgeekmeister> kallisti: i've run into problems like that with directory listings in many tools/languages
23:04:33 <tehgeekmeister> there's a fast way to do it, and it's unfortunately quite uncommon to use it, from what i can tell
23:04:43 <tehgeekmeister> even find doesn't do it the fastest way possible
23:05:05 <kallisti> my guess is that getDirectoryContents is too strict.
23:05:09 <kallisti> but I don't know for sure.
23:05:14 <kallisti> I'll have to do some research.
23:05:33 <tehgeekmeister> i can't help with the haskell side of it
23:05:43 <tehgeekmeister> but there are fast and slow ways to do the syscall bit of it
23:08:26 <kallisti> yeah in my heap profile graph there's large spikes on the larger directories.
23:08:34 <kallisti> so it's allocating the directoy list up front.
23:08:49 <kallisti> if it were lazy IO with read_dir it would be faster.
23:09:18 <tehgeekmeister> yeah, that's ideal
23:10:41 <kallisti> on my first test run the entire thing was strict.
23:10:49 <kallisti> so it allocated the entire filesystem tree up-front
23:10:50 <kallisti> fun times.
23:11:55 <kallisti> on the current version my memory usage maxes out at like 6KB on a particularly large directory list
23:12:24 <kallisti> much better than my system locking up. :P
23:16:45 <kini> Why is Fractional in the Enum typeclass?
23:16:55 <kallisti> good question.
23:17:04 <kallisti> well, it's not
23:17:09 <kallisti> Fractional isn't a type
23:17:51 <kallisti> Float is though, which is pretty questionable.
23:18:13 <kallisti> Rational isn't too questionable, except that it doesn't actually enumerate correctly.
23:18:45 <kini> er, yes, I meant Rational I guess :)
23:18:49 <kallisti> kini: my guess is that having Enum instances for those types allows for convenient range syntax.
23:19:01 <kini> what is a "correct" enumeration of Rational?
23:19:01 <kallisti> Rational isn't unreasonable as an Enum because you actually can enumerate every Rational.
23:19:10 <kallisti> there isn't really /one/ correct enumeration
23:19:14 <kallisti> there are several correct ones.
23:19:26 <kallisti> ...without making too many assumptions about what an "enumeration" is.
23:19:50 <kini> yes, I am aware that the rationals are countable, but there is no enumeration of the rationals which is monotonic
23:19:57 <kallisti> right
23:19:58 <kallisti> and yet
23:20:04 <kallisti> this is the problem with Enum
23:20:10 <kallisti> it doesn't specify anything about what an enumeration is.
23:20:17 <kini> right...
23:20:34 <kini> I guess I assumed that an enumeration would necessarily be compatible with the ordering given by something being in Ord
23:20:49 <kallisti> but the Rational instance for Enum is very silly
23:20:55 <kallisti> > [1..10] :: Rational
23:20:56 <lambdabot>   Couldn't match expected type `GHC.Real.Rational'
23:20:56 <lambdabot>         against inferred t...
23:21:09 <kini> lol what
23:21:14 <kallisti> > [1/1..10/1] :: Rational
23:21:15 <lambdabot>   Couldn't match expected type `GHC.Real.Rational'
23:21:15 <kini> > [1..10] :: [Rational]
23:21:16 <lambdabot>         against inferred t...
23:21:17 <lambdabot>   [1 % 1,2 % 1,3 % 1,4 % 1,5 % 1,6 % 1,7 % 1,8 % 1,9 % 1,10 % 1]
23:21:21 <kallisti> oh right
23:21:32 <kallisti> lol. in my defense, it's 2:18 AM :P
23:21:38 <kini> :)
23:21:57 <iFire> No sleep for mathematicians!
23:22:44 <kini> you're right, though, that there's something wrong when [a..b] doesn't contain b or doesn't contain a
23:22:51 <tehgeekmeister> oh, no, it's not going too fast to benchmark
23:23:03 <kallisti> kini: oh, it does.
23:23:10 <tehgeekmeister> it's exiting too soon
23:23:18 <kallisti> the problem is that it skips a few numbers inbetween each step.
23:23:23 <kini> it does?
23:23:30 <kallisti> yeah >_>
23:23:34 <kini> > [1/1..10/1] :: [Rational]
23:23:35 <lambdabot>   [1 % 1,2 % 1,3 % 1,4 % 1,5 % 1,6 % 1,7 % 1,8 % 1,9 % 1,10 % 1]
23:23:41 <kini> hmm
23:23:45 <kallisti> those aren't all the rationals between 1 and 10
23:24:01 <kallisti> but then: Enum doesn't say what an enumeration is.
23:24:08 <kallisti> so I can't really complain. :P
23:24:29 <kini> well as we said, the enumeration doesn't need to be compatible with the ordering
23:24:30 <dabblego> when ghci loads with :set hide-package p and I do not have package p installed, I get a message about inability to hide it -- can I suppress this message?
23:24:43 <shachaf> kini: The part that people don't like is when [a..b] contains values *greater* than b.
23:24:43 <kini> so we could just say that those are the rationals between 1 and 10
23:24:48 <kini> unfortunately it becomes a bit inconsistent
23:24:50 <kallisti> right but I would expect at least some kind of bijection with the natural numbers.
23:25:21 <kallisti> aka I want it to list everything inbetween 2 points.
23:25:30 <kini> kallisti: I would expect an "enumeration" to simply be an upwards-countable linear ordering
23:25:40 <kini> since Haskell has infinite (upward) lists
23:26:10 <shachaf> > [0.5 .. 1.1] :: [Rational]
23:26:11 <lambdabot>   [1 % 2,3 % 2]
23:26:42 <kallisti> seems legit.
23:26:48 <kini> one way to "enumerate" rationals according to this definition is to biject it to NxN in the usual way (0 1 -1 2 -2 ...)
23:27:10 <kini> and then [a..b] would be "start at a in the 'square' NxN, go to the right until you find b"
23:27:11 <kallisti> er what
23:27:16 <kallisti> that's the bijection N -> Z  no?
23:27:23 <kallisti> I see no tuples.
23:27:40 <kini> if b is on a different row from a, then you just get an infinite list
23:27:51 <kini> kallisti: yes, I meant to lift that to the square of course :)
23:28:08 <kini> and that's N -> Z yes, but it's a bijection so just flip it to get Z -> N
23:28:17 <kini> a function from N -> Z is easier to write lol
23:28:19 <kini> since it's just a sequence
23:28:25 <kallisti> just rotate each set by 90 degrees
23:28:26 <kallisti> same thing
23:28:37 <kini> hm?
23:28:49 <kallisti> flip the symbol Z 90 degrees = N
23:28:54 <kini> hah
23:29:03 <kallisti> flip the symbol N 90 degrees = Z
23:29:21 <kallisti> that's how you get from N -> Z  to Z -> N
23:29:53 <tehgeekmeister> benchmark finally successful!
23:30:25 <tgeeky> hehe, as much as I think doing such things (comparing the shape of glyphs under discrete rotation) is interesting and potentially fun, I don't think other share that :O
23:30:30 * kallisti see that a directory-tree package already exists.
23:30:46 <kallisti> but it doesn't seem to do as many useful things, and it uses unsafePerformIO instead of unsafeInterleaveIO for some reason.
23:30:47 <tgeeky> kallisti: that sucks that it took so long
23:30:56 <tgeeky> kallisti: gasp! Link?
23:31:19 <kallisti> @hackage directory-tree
23:31:19 <lambdabot> http://hackage.haskell.org/package/directory-tree
23:31:21 * hackagebot dtd 0.5.1.1 - Parse and render DTD files  http://hackage.haskell.org/package/dtd-0.5.1.1 (MichaelSnoyman)
23:31:23 * hackagebot uri-conduit 0.4.0.1 - Read and write URIs  http://hackage.haskell.org/package/uri-conduit-0.4.0.1 (MichaelSnoyman)
23:32:19 <kallisti> I think it overcomplicates things with no real benefit.
23:33:13 <tehgeekmeister> mzero, ezyang, blackdog, strager: thanks for the help, guys.  finally got a good grip on this after months of off and on work.
23:33:23 <tgeeky> tehgeekmeister: watcha finish?
23:33:50 <tehgeekmeister> tgeeky: getting haskell to do some simple text filtering as fast as a quick perl script i wrote a while back
23:33:51 <mzero> cool, I'm guessing the working solution was simpler than you first thought
23:33:58 <tehgeekmeister> yeah, it's pretty simple
23:34:00 <kallisti> for comparison here's what I have so far: https://github.com/kallisti-dev/filesystem-trees/blob/master/src/System/File/Tree.hs
23:34:06 <mzero> -O2 does wonders!
23:34:36 <tehgeekmeister> it could be even simpler, had i started with this approach from the beginning, too.
23:34:37 <kallisti> yes we all need oxygen to breathe.
23:36:01 <kallisti> I don't think conflating file contents with the tree structure is necessary.
23:36:21 * hackagebot xml2html 0.1.2.3 - blaze-html instances for xml-conduit types  http://hackage.haskell.org/package/xml2html-0.1.2.3 (MichaelSnoyman)
23:36:23 <kallisti> you can just map an IO action onto filesystem tree to achieve that.
23:36:25 <tehgeekmeister> alright, it's time for me to get off of here
23:36:27 <tehgeekmeister> later guys
23:36:30 <tehgeekmeister> thanks again for the help
23:36:52 <kini> hmm... why doesn't this work in GHCi?
23:36:53 <kini> let enumsonly = (\x -> x) :: (Enum a) => a -> a
23:37:16 <kallisti> how is it not working?
23:37:58 <tgeeky> > let enumsonly = (\x -> x) :: (Enum a) => a -> a
23:37:59 <lambdabot>   not an expression: `let enumsonly = (\x -> x) :: (Enum a) => a -> a'
23:38:09 <tgeeky> @let enumsonly = (\x -> x) :: (Enum a) => a -> a
23:38:10 <lambdabot>  Defined.
23:38:16 <tgeeky> @type enumsonly
23:38:17 <lambdabot> forall a. (Enum a) => a -> a
23:38:20 <tgeeky> > enumsonly 4
23:38:22 <lambdabot>   4
23:38:34 <kini> hmm
23:39:07 <hpaste> kini pasted “enumsonly” at http://hpaste.org/68265
23:40:20 <kini> nobody else gets this output?
23:40:48 <sepp2k> kini: What's your ghc version?
23:41:01 <kini> 7.4.1
23:41:23 * hackagebot xml-catalog 0.7.0.1 - Parse XML catalog files  http://hackage.haskell.org/package/xml-catalog-0.7.0.1 (MichaelSnoyman)
23:41:25 * hackagebot xml-conduit 0.7.0.2 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-0.7.0.2 (MichaelSnoyman)
23:41:27 * hackagebot xml-hamlet 0.3.0.1 - Hamlet-style quasiquoter for XML content  http://hackage.haskell.org/package/xml-hamlet-0.3.0.1 (MichaelSnoyman)
23:41:28 <Enigmagic> kini: try running ":set -XNoMonomorphismRestriction" first
23:41:54 <kini> it works!
23:42:11 <kini> so (I hesitate to ask) what does that do?
23:42:23 <shachaf> @where dmr
23:42:24 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
23:42:35 <kini> haha. Thanks :)
23:43:14 <sepp2k> kini: Definitions at the top-level that are not defined using arguments (i.e. let f = ...  instead of  let f x = ...) and that don't have an explicit type signature need a non-polymorphic (i.e. monomorphic) type.
23:43:36 <Enigmagic> kini: it works if you write it this way instead: let enumsonly :: Enum a => a -> a; enumsonly x = x
23:44:00 <sepp2k> Note that adding a type signature to the value does not count as giving a type signature to the definition, you'd need to do ... what Enigmagic said
23:46:23 * hackagebot attoparsec-conduit 0.4.0.1 - Turn attoparsec parsers into sinks.  http://hackage.haskell.org/package/attoparsec-conduit-0.4.0.1 (MichaelSnoyman)
23:51:23 * hackagebot conduit 0.4.2 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-0.4.2 (MichaelSnoyman)
23:56:25 * hackagebot network-conduit 0.4.0.1 - Stream socket data using conduits.  http://hackage.haskell.org/package/network-conduit-0.4.0.1 (MichaelSnoyman)
23:56:27 * hackagebot packdeps 0.3.0.1 - Check your cabal packages for lagging dependencies.  http://hackage.haskell.org/package/packdeps-0.3.0.1 (MichaelSnoyman)
23:56:29 * hackagebot persistent 0.9.0.4 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-0.9.0.4 (MichaelSnoyman)
