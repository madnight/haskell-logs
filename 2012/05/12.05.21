00:02:55 <newsham> > (movel.movel.movel) ("sahhello","kell")
00:02:57 <lambdabot>   ("hello","haskell")
00:04:28 <newsham> need to straighten out my left and right sometime
00:08:09 <Taneb> Should I try to use unboxed types wherever possible?
00:12:47 <Nafai> Taneb: Thanks, I need to remember to look there
00:13:10 <Nafai> another question, is there a way to export only the accessors from a record from a module, and not the constructor?
00:13:42 * hackagebot Hach 0.0.1 - Simple chat  http://hackage.haskell.org/package/Hach-0.0.1 (DmitryMalikov)
00:14:02 <Taneb> Yes, I think it's putting the accessors but not the data type in the export list (I could be wrong)
00:14:05 <Taneb> Like:
00:14:34 <Taneb> module Foo (a, b) where data Foo = Foo {a :: Int, b :: Char}
00:14:50 <khayyim> nvm, looks like the site itself is borked
00:15:13 <Nafai> Taneb: Ok, just wasn't sure if I had to explicitly list each one
00:15:15 <shachaf> I guess exporting the accessors secretly lets you construct values?
00:15:17 <killy9999> anyone knows when to expect the new haskell platform?
00:15:33 <shachaf> As in (undefined :: Foo) { a = 5, b = 'q' }
00:15:56 <Taneb> killy9999, October I think
00:16:08 <killy9999> October?
00:16:16 <killy9999> it's supposed to be this month...
00:16:21 <Taneb> Wait, yeah
00:16:29 <Taneb> I was thinking of the next next release
00:16:43 <killy9999> no, the current one
00:16:44 <Taneb> Some time in the next 9 days
00:16:53 <killy9999> :)
00:55:24 <stj> Typeclassopedia says: "Give an example of a (bogus) Functor instance which satisfies the second law but not the first." I've tried it but no luck. Can someone help out?
00:55:40 <dmwit> Which law is the first one?
00:55:47 <stj> the first law is fmap id = id
00:56:07 <stj> and second, of course: fmap (g . h) = (fmap g) . (fmap h)
00:56:32 <Botje> Worked Bool a, with fmap f (Worked _ x) = Worked True (f x)
00:57:17 <stj> I see, thanks
00:58:03 <mgsloan> or, for lists, fmap f = map (f . f)
00:58:08 <bobry> conduit question: is it possible to combine multiple sources in a way similar to concat for lists?
00:58:08 <mgsloan> err nvm
00:58:22 <mgsloan> (wouldn't work because fmap and map change the types)
01:00:59 <Peaker> bobry, what does the Monad instance for sources do?
01:02:38 <bobry> not sure, I should check
01:08:34 <hpaste> Peaker pasted “Source monad instance” at http://hpaste.org/68765
01:08:44 <Peaker> bobry, ^^
01:12:23 <Peaker> apparently the Monad instance combines all consumptions and all productions
01:12:32 <Peaker> (sequentially)
01:14:51 <newsham> > (fmap succ "test", map (succ.succ) "test")
01:14:53 <lambdabot>   ("uftu","vguv")
01:15:10 <bobry> Peaker: thanks!
01:19:50 <ppilate> > :t succ
01:19:51 <lambdabot>   <no location info>: parse error on input `:'
01:20:03 <ppilate> @help
01:20:03 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:20:06 <ppilate> @list
01:20:07 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
01:20:24 <ppilate> @type succ
01:20:25 <lambdabot> forall a. (Enum a) => a -> a
01:21:45 <newsham> (succ 1, succ 'a', succ False)
01:21:49 <newsham> > (succ 1, succ 'a', succ False)
01:21:51 <lambdabot>   (2,'b',True)
01:23:05 <homie> or not
01:23:09 <homie> lol
01:25:40 <Taneb> succ True
01:25:43 <Taneb> > succ True
01:25:45 <lambdabot>   *Exception: Prelude.Enum.Bool.succ: bad argument
01:26:04 <newsham> > iterate succ False
01:26:05 <lambdabot>   [False,True,*Exception: Prelude.Enum.Bool.succ: bad argument
01:28:43 <Taneb> Is there much use for something like:
01:29:34 <Taneb> :t \f n -> flip (foldr ($)) (replicate n f)
01:29:35 <lambdabot> forall b. (b -> b) -> Int -> b -> b
01:52:52 <womb> Hello
01:53:03 <Taneb> Hi
01:53:17 <womb> i just learned i would earn 10k pounds mor e a year on avg if i would switch to haskell in work
01:53:31 <womb> but how to switch to haskell without haskell experience in business before ;/
01:53:34 <womb> any ideas ?
01:53:47 <mornfall> Learn. :-)
01:53:50 <Taneb> I'd start with either real world haskell or learn you a haskell
01:53:54 <Phlogistique> womb: I think you misheard; it's 10k pounds _less_
01:53:55 <Taneb> @where lyah
01:53:55 <lambdabot> http://www.learnyouahaskell.com/
01:53:58 <womb> assuming i know how to do some stuff
01:54:05 <Taneb> @where rwh
01:54:06 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
01:54:14 <womb> read this
01:54:21 <Taneb> One or both of those
01:54:26 <womb> both
01:54:32 <Taneb> Probably both is better
01:54:48 <Phlogistique> womb: but where and how did you get Haskell job opportunities? Several people here would be interested.
01:54:51 <womb> maybe i should produce some package and push to hackage before looking for a job ;p
01:55:02 <womb> London babe
01:55:17 <mornfall> womb: Yes, you should.
01:55:51 <womb> i would love to work as haskell dev
01:56:08 <womb> i'm a bit sick of doing ruby / node.js at work all the time
01:56:36 <womb> and i think i'm not complete retard. But that is questionable
02:00:00 <mornfall> I'm sure there are people who would consider working in ruby to be a luxury. :-)
02:00:46 <womb> mornfall: i think it depends on point of view, but if someone wants to work in ruby he should do it. There is such a big need for developers now that it is hard to find even 1
02:01:14 <mornfall> Probably true in most languages nowadays.
02:01:31 <mornfall> Nevertheless, some people are stuck with C jobs... :-)
02:02:15 <womb> C jobs are well paid
02:02:24 <womb> in london up to 100k best paid jobes evar
02:02:34 <womb> low latancy gambling jobs
02:03:02 <womb> i would love to play with it but i don't wanna be hit in a head by this low level
02:03:05 <womb> :)
02:03:10 <mornfall> xD
02:03:19 <mornfall> Paycheck's not everything.
02:03:42 <womb> well if you earn 2 x ruby guy
02:03:43 <womb> it is
02:04:38 <womb> you can pay off mortgage 2 x faster ;DDD
02:05:05 <lucian> paycheck does matter if your current one is terrible :)
02:05:13 <lucian> but otherwise, yeah, i'd rather not write C
02:05:25 <lucian> people should use something like Atom if they want a real-time system
02:05:41 <lucian> or at least Go
02:08:14 <mornfall> "latency free garbage collection" :-)
02:09:49 <Phlogistique> womb: makes me want to move to London. My current job is cool but noooobody uses Haskell in Paris
02:10:01 <mornfall> Phlogistique: OCaml? :)
02:10:11 <Taneb> A Parisian haskeller in London
02:10:23 <Phlogistique> mornfall: yep, I guess I should learn OCaml
02:10:34 <mornfall> Taneb: You should write an opera.
02:12:11 <LaughingMan> ghci does not find my cabal installed packages
02:12:51 <Taneb> mornfall, would you believe I actually tried once, then realised I had no idea about writing operas
02:13:01 <lucian> mornfall: yeah, people should write more gc-s. current ones suck
02:13:33 <mornfall> lucian: Everything sucks.
02:13:45 <Taneb> What doesn't suck blows.
02:14:33 <lucian> mornfall: but GCs in particular. all of them have unacceptable pauses with multi-GB heaps
02:15:16 <Botje> what about the azure ones?
02:15:28 <lucian> those are a step in the right direction, yes
02:15:31 <mornfall> lucian: Refcount then. It ruins locality, but the latency is OK (unless you lose a reference to a really big thing...).
02:15:37 <LaughingMan> can i delet all cabal installed packages?
02:15:46 <LaughingMan> to start fresh?
02:15:51 <schlicht> Is there a way to get the size in pixel of label (better: the text in the label) in gtk2hs before placing it?
02:16:07 <mornfall> LaughingMan: Look in ~/.cabal and ~/.ghc.
02:16:10 <lucian> mornfall: sure, but that sucks too. our computers can totally handle incremental collection
02:16:13 <Botje> schlicht: why do you need this?
02:16:56 <mornfall> lucian: You really want a concurrent collector. Tricky. :-)
02:17:03 <mornfall> (As in, writers concurrent with the GC.)
02:17:18 <lucian> mornfall: not necessarily concurrent, just with pause-able collections
02:17:24 <schlicht> Botje,  I'm placing a coule of labels in a layout container and the postion depends of the size of the other labels.
02:17:44 <mornfall> lucian: If you allow pausing at arbitrary points, it's the same thing.
02:18:00 <lucian> mornfall: concurrent with the mutator is tricky indeed, but it's predictability that i think is missing, not throughput
02:18:26 <Botje> schlicht: and you can't use the layout containers to your benefit?
02:18:34 <lucian> mornfall: not arbitrarily, just predictably pausable
02:18:49 <lucian> mornfall: so if i know the gc will never pause more than X ms, no matter what
02:18:51 * hackagebot cake 0.3.2.1 - A build-system library and driver  http://hackage.haskell.org/package/cake-0.3.2.1 (JeanPhilippeBernardy)
02:19:14 <mornfall> lucian: I'm not sure it is substantially easier that way.
02:19:44 <schlicht> Botje, i'm displaying a form of typed lambda calculus and i didnt find anything thats helpful
02:20:01 <lucian> mornfall: me neither, but i plan to try
02:21:04 <LaughingMan> cabal still says that the package is already installed
02:21:06 <mornfall> Maybe we should just prove it's impossible and be done with it. ;-)
02:21:12 <mornfall> (Best things in computer science are, anyway.)
02:22:25 <LaughingMan> is there another location
02:24:14 <Botje> schlicht: oh. good luck then :/
02:24:37 <Botje> you could stuff the text in some label and then query the width
02:25:34 <lucian> mornfall: heh
02:26:15 <schlicht> Botje, at the time i set the size of the label fixed, let the label widget center the text and work with the label as that. that works okay with on textsize and one font. but on different system this will get ugly
02:26:45 <schlicht> Botje, fixed depending on the length of the string
02:28:38 <Botje> the easy way out is using monospaced fonts ;)
02:29:33 <LaughingMan> something is seriously f*** up on my machine
02:29:48 <LaughingMan> ghc-pkg list lists the package
02:30:10 <LaughingMan> but ghci complains it's not there
02:31:43 <schlicht> Botje, yeah...do you know how i can set font and fontsize with gtk2hs?
02:34:06 <LaughingMan> oh I'm stupid
02:34:23 <Botje> schlicht: there's a widgetModifyFont and a widgetModifyStyle
02:35:21 <schlicht> Botje, thanks :)
03:25:36 <navaati> @hoogle Float -> Double
03:25:37 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
03:25:37 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
03:25:37 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
03:26:31 <zenzike> navaati: you might be looking for realToFrac
03:27:02 <navaati> ah yeah, thanks
03:29:27 <mietek> What is the invisible character TM uses for tabs? BLACK RIGHT-POINTING TRIANGLE? POINTER?
03:29:31 <mietek> Oops, wrong window.
03:32:05 <HugoDaniel> is there a good hash table implementation in haskell ?
03:32:28 <HugoDaniel> with performance similar to C :)
03:32:50 <HugoDaniel> O(C) in every operation
03:33:42 <quicksilver> HugoDaniel: unordered-containers on hackage.
03:33:48 <quicksilver> HugoDaniel: (O(1) is a lie, etc etc)
03:34:00 <HugoDaniel> :D
03:34:51 <HugoDaniel> is there any algorithms package all written in C but specially taylored to be used in the haskell FFI ?
03:54:09 * hackagebot arithmoi 0.4.0.1 - Efficient basic number-theoretic functions.  Primes, powers, integer logarithms.  http://hackage.haskell.org/package/arithmoi-0.4.0.1 (DanielFischer)
03:56:00 <adimit> @pl \a l -> a ++ show l
03:56:01 <lambdabot> (. show) . (++)
03:56:30 <adimit> @pl \l a -> a ++ show l
03:56:31 <lambdabot> flip (++) . show
04:02:10 <watcat> hey, trying to build a concat function with map, is this a moot attempt ?
04:02:41 <adimit> watcat: probably yes. Have you looked at concatMap?
04:02:45 <adimit> @hoogle concatMap
04:02:46 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
04:02:46 <lambdabot> Data.List concatMap :: (a -> [b]) -> [a] -> [b]
04:02:46 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
04:03:31 <mcstar> ClaudiusMaximus: hi
04:03:48 <watcat> oh thank you
04:04:29 <hpaste> “Rob Stewart” pasted “distinct randomized list” at http://hpaste.org/68770
04:05:03 <robstewartuk> there must be a better way to generate a distinct randomized list from a list xs than  http://hpaste.org/68770 ??
04:06:20 <mcstar> robstewartuk: you can split generators if thats what you want
04:07:12 <mcstar> probably not
04:10:47 <killy9999> @help quote
04:10:48 <lambdabot> quote <nick>
04:10:48 <lambdabot> remember <nick> <quote>
04:10:48 <lambdabot> Quote somebody, a random person, or save a memorable quote
04:10:58 <killy9999> @help protontorpedo
04:10:58 <lambdabot> protontorpedo is silly
04:11:20 <killy9999> @help remember
04:11:20 <lambdabot> quote <nick>
04:11:20 <lambdabot> remember <nick> <quote>
04:11:20 <lambdabot> Quote somebody, a random person, or save a memorable quote
04:11:44 <ClaudiusMaximus> mcstar: hi
04:11:45 <mcstar> robstewartuk: you want a random permutation?
04:11:46 <killy9999> @help yhjulwwiefzojcbxybbruweejw
04:11:46 <lambdabot> V RETURNS!
04:12:36 <mcstar> ClaudiusMaximus: hey, yesterday i redid the trie, by allocating a vector, that held a vector of (Bool, Int) pairs
04:12:55 <mcstar> so i could tweak the size of the second vector
04:13:20 <mcstar> turned out to be a factor of 2 faster than the one you pasted
04:13:30 <mcstar> i was quite glad
04:13:56 <mcstar> the second vector was also unboxed
04:14:13 <covi> Why <*> for (->) r is defined as: f <*> g = \x -> f x (g x)? The f x (g x) part confuses me.
04:14:27 <ClaudiusMaximus> mcstar: cool :)
04:14:52 <mcstar> roughly 2.5 times slower than c++, it is acceptable
04:16:36 <hpc> covi: use the types, luke
04:16:39 <hpc> :t (<*>)
04:16:40 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
04:17:04 <hpc> :: (r -> a -> b) -> (r -> a) -> (r -> b)
04:17:31 <hpc> x :: r, f :: (r -> a -> b), (g x) :: a
04:17:35 <hpc> and apply!
04:19:10 <covi> hpc: so r (a -> b) is the same as r -> a -> b?
04:21:18 <covi> :t (+2) <*> (*3)
04:21:19 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
04:21:19 <lambdabot>     Probable cause: `*' is applied to too few arguments
04:21:19 <lambdabot>     In the second argument of `(<*>)', namely `(* 3)'
04:21:25 <covi> :t ((+2) <*> (*3))
04:21:26 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
04:21:26 <lambdabot>     Probable cause: `*' is applied to too few arguments
04:21:26 <lambdabot>     In the second argument of `(<*>)', namely `(* 3)'
04:21:30 <covi> :t ((+2) <*> (*3) $ 1)
04:21:31 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
04:21:31 <lambdabot>     Probable cause: `*' is applied to too few arguments
04:21:31 <lambdabot>     In the second argument of `(<*>)', namely `(* 3)'
04:21:43 <mcstar> robstewartuk: i see, you can just put random integers in a set, until it reaches a certain size
04:25:21 <hpc> covi: f = ((->) r)
04:25:33 <hpc> or if you could do sections of (->), f = (r ->)
04:25:50 <covi> hpc: aha! I get it!!!
04:25:53 <hpc> so f (a -> b) = (r ->) (a -> b) = r -> (a -> b) = ...
04:26:19 <covi> so f (a -> b) where f :: r is not always the same as (r -> a -> b).
04:59:20 <covi> For exercise 1 here (http://en.wikibooks.org/wiki/Haskell/Applicative_Functors#Functors), is the solution   fmap f (Node x subtrees) = Node (f a) (fmap f subtrees)?
04:59:49 <mm_freak> in an inference rule, is there a way to express that you can never infer something?  like: "there is no way to infer that 4 is a prime number"
05:00:14 <mm_freak> "prime(4) | ⊥" doesn't seem right…  it seems like an empty statement
05:00:20 <byorgey> covi: not quite.
05:00:37 <covi> byorgey: some hint?
05:01:06 <covi> :t fmap
05:01:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:01:24 <byorgey> mm_freak: no, I have never heard of such a thing
05:01:28 <mm_freak> covi: it's a type error
05:01:45 <byorgey> covi: that would be correct if it were  data Tree a = Node a (Tree a)
05:01:51 <mm_freak> covi: your 'subtrees' is a list
05:01:55 <byorgey> but you have not dealt with the fact that there is a *list* of subtrees
05:02:40 <covi> fmap f (Node x subtrees) = Node (f a) (map f subtrees)
05:02:46 <covi> How about this?
05:03:02 <mm_freak> byorgey: what is the common way to deal with these things?  i'm trying to express peano's axioms in terms of inference rules
05:03:11 <covi> fmap f (Node x subtrees) = Node (f x) (map f subtrees)
05:03:23 <mm_freak> covi: also wrong…  subtress is a list of trees of elements
05:03:28 <mm_freak> f is a function from element to element
05:03:42 <Taneb> I think I sort-of get the Curry Howard correspondence
05:03:43 <mm_freak> you are applying f to trees
05:03:50 <byorgey> mm_freak: huh? which one of peano's axioms says you can't conclude something?
05:04:17 <mm_freak> byorgey: there is no natural number x with S(x) = 0
05:04:32 <byorgey> mm_freak: no, that axiom lets you conclude a negation
05:04:43 <mm_freak> ah!  thanks
05:05:08 <byorgey> i.e. on the top of the line you have "x natural" and on the bottom you have "not (S(x) = 0)"
05:05:48 <covi>     fmap f (Node x subtrees) = Node (f x) [fmap f subtree | subtree <- subtrees]
05:05:54 <covi> How about this, mm_freak ?
05:06:07 <byorgey> covi: yes, that is correct
05:06:14 <covi> Aha!
05:06:16 <byorgey> covi: now try rewriting it to use 'map' instead of a list comprehension
05:06:18 <mcstar> Node (f a) (map (fmap f) subtrees)
05:06:30 <byorgey> don't give away answers, mcstar
05:06:41 <mcstar> im learning too
05:06:45 <mm_freak> yeah, i see it now…  is it true that whenever i want to express "you can't conclude this", there may be a better way to express the whole system?
05:06:48 <byorgey> fair enough =)
05:06:55 <covi> I see :)
05:07:37 <mm_freak> covi: list comprehensions are syntactically nice, but not very composable and very verbose…  you have the power of currying at hand — make use of it =)
05:08:12 <byorgey> mm_freak: if you really want to express "you can't conclude this", I would simply not write down an axiom at all, and then prove that you cannot conclude that from the other axioms.
05:08:26 <byorgey> you don't need an extra axiom to say what you *can't* conclude.
05:08:51 <mm_freak> byorgey: yes, but how do i express the proof?
05:08:52 <covi> I suppose that map . fmap f $ subtrees is also correct (without parenthesis, dot added)?
05:08:53 <danr> mm_freak: I like list comprehensions. They usually convey their meaning well if you have sensible variable names (that does not necessarily imply long names), and I find them more maintainable than a series of maps, filters and concatMaps...
05:09:06 <mm_freak> byorgey: is there always a way to turn this into negation?
05:09:21 <danr> but indeed, in the example above the sensible solution is to use a map.
05:09:28 <mm_freak> covi: yes, that's correct
05:09:42 <mm_freak> covi: although in this case i'd write map (fmap f)
05:10:01 <covi> mm_freak: thanks, is the '$' necessary?
05:10:09 <byorgey> mm_freak: no, they are not the same thing.  But I am really not sure what you are getting at.  We didn't "turn it into" negation in the case of the peano axioms; that axiom was about negation all along.
05:10:25 <mm_freak> danr: you get used to compositions and at some point be able to read them faster than list comprehensions
05:10:36 <mm_freak> covi: ($) is just the application operator
05:10:39 <mm_freak> f $ x = f x
05:10:46 <mm_freak> but ($) has a low operator priority
05:10:52 <mm_freak> f . g $ x = (f . g) x
05:11:02 <byorgey> mm_freak: well, I guess you could say this: instead of saying "you cannot conclude X", you can say "you may conclude not X"; then if you can prove that your axiomatic system is consistent, you have shown that you cannot conclude X
05:11:05 <mcstar> covi: $ sometimes makes code easier to read, and spares you some parens
05:11:36 <covi> :t (.)
05:11:37 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:11:38 <covi> :t ($)
05:11:39 <lambdabot> forall a b. (a -> b) -> a -> b
05:12:04 <byorgey> uh, map . fmap f $ subtrees   is NOT correct
05:12:04 <mcstar> i noticed |> is popular in F#
05:12:21 <mm_freak> byorgey: well, i'm just learning logic…  it takes some getting used to
05:12:21 <covi> byorgey: ??
05:12:27 <byorgey> map . fmap f $ subtrees = (map . fmap f) subtrees = map (fmap f subtrees)
05:12:35 <byorgey> but it should be   map (fmap f) subtrees
05:12:46 <mm_freak> byorgey: but i see it now
05:13:28 <navaati> do you have a good book to get started with logic, axioms, these sort of things ?
05:13:52 <covi> navaati: coursera.org currently hosts an online course on logic
05:13:57 <mm_freak> mcstar: |> is a flipped (.), so it corresponds to (>>>) in haskell
05:13:57 <covi> byorgey: I see, ty
05:14:21 <mm_freak> actually no
05:14:24 <mcstar> mm_freak: oh, i didnt know there was >>>
05:14:34 <mm_freak> |> in F# corresponds to ($)
05:14:43 <mcstar> i just found a bit weird to flip the function - argument
05:14:58 <mm_freak> because you write x |> g |> f, where in haskell you would have written f (g x) or (f . g) x
05:15:04 <mcstar> (|>) :: a -> (a -> b) -> b
05:15:04 <lucian> i find |> looks less horrible than $
05:15:05 <mcstar> i guess
05:15:18 <mm_freak> i find both look horrible
05:15:25 <lucian> you could also write f $ g $ x in haskell
05:15:44 <mm_freak> i'm hoping for a less noisy way to apply values to a composition some day
05:15:53 <lucian> i think : would've been a nicer glyph, maybe
05:15:55 <mcstar> but notice, that |> must be left associative
05:15:58 <mm_freak> lucian: yeah, that's why |> corresponds to ($)
05:16:23 <mm_freak> lucian: (:) is syntactically invalid
05:16:32 <mm_freak> it's by definition a constructor or a type
05:16:37 <lucian> mm_freak: sure
05:16:49 <lucian> i was just saying it'd look less horrible
05:17:02 <mcstar> lucian: instead of $?
05:17:06 <lucian> yeah
05:17:20 <mm_freak> i think there is no non-horrible way…  personally i find that (f . g . h) x still looks best
05:17:22 <lucian> i guess i dislike haskell's tendency to use weird symbols instead of names
05:17:33 <lucian> sure, where you can use point-free
05:17:34 <mm_freak> lucian: like `applyTo`? =)
05:17:43 <lucian> mm_freak: for such simple things, no
05:17:45 <navaati> covi: bah, video lessons… -_-
05:17:55 <lucian> but there's <*> and <$> and >>= or w/e
05:18:01 <lucian> i bet there's -_- too
05:18:05 <covi> navaati: it's not what you think
05:18:05 <navaati> <$> is great
05:18:06 <mcstar> :)
05:18:07 <mm_freak> lucian: i mean "(f . g . h) x" instead of "f . g . h $ x"
05:18:20 <mm_freak> i really like the former better
05:18:23 <covi> navaati: they contain slides (pdf's), video's, quizzes, and assignments
05:18:24 <mm_freak> and it's not even longer
05:18:31 <lucian> navaati: i hate typing that
05:18:59 <mm_freak> lucian: you really want many of those symbols to be symbols
05:19:06 <mm_freak> in particular, what would you name <*>?
05:19:10 <lucian> mm_freak: i personally don't
05:19:15 <mm_freak> `applyTo`?
05:19:21 <lucian> yeah, that'd be better
05:19:21 <mm_freak> i mean there is "ap"
05:19:35 <mm_freak> but it's unfortunate
05:19:39 <covi> :t ap
05:19:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
05:19:44 <mm_freak> because ($) is also "apply to"
05:19:49 <mm_freak> so is fmap
05:19:53 <mm_freak> and <*>
05:19:53 <lucian> i'd say anything symbol longer than 2 chars is more trouble than it's worth
05:19:56 <mm_freak> and …
05:20:02 <lucian> ok, longer better name
05:20:05 <lucian> fapply
05:20:19 <lucian> bla `fapply` foo
05:20:26 <covi> Holy x, ap is the Monad (though I haven't learned it) equivalent to <*>?
05:20:49 <mm_freak> then you have:  fapply, afapply, mapply, apply, …  do you remember the story of all those C function names like printf, sprintf, snprintf, fprintf, …?
05:21:04 <mm_freak> please let's just keep <*>
05:21:08 <lucian> mm_freak: i don't think it's any worse than <$>
05:21:16 <zomg> fapply sounds like a URL shortener for you-know-what
05:21:17 <lucian> it's not like my opinion will change anything :)
05:21:21 <zomg> fapp.ly
05:21:48 <lucian> mm_freak: and C's problem was with lack of namespaces
05:21:48 <mm_freak> lucian: i really don't want to write cf `afapply` cx `afapply` cy
05:22:15 <navaati> lucian: you knw, the secret reason is that all these symbols are pretty when rendered with LaTeX :D
05:22:25 <mm_freak> lucian: much less i want to write "AF.apply" ;)
05:22:28 <lucian> navaati: that's just evil
05:22:45 <lucian> navaati: at least Fortress goes all the way and uses unicode
05:22:49 <mcstar> its insane to have unicode in code
05:22:59 <mcstar> i dont even know why does it exist at all
05:23:01 <navaati> you can in haskell too (i do it)
05:23:02 <mm_freak> lucian: let's face it, math has the same problem…  eventually you will learn what those symbols mean, and you will appreciate them =)
05:23:25 <lucian> mm_freak: it's not about learning, really
05:23:44 <lucian> i just much prefer names for anything other than trivial symbols
05:23:44 <navaati> mcstar: maybe because having ascii-art symbols is even uglier ?
05:23:58 <mm_freak> lucian: then what's "trivial"?
05:24:04 <mm_freak> it's not about triviality
05:24:09 <mm_freak> it's just about familiarity
05:24:18 <lucian> > + . = are trivial
05:24:19 <lambdabot>   <no location info>: parse error on input `+'
05:24:24 <lucian> heh
05:24:26 <mm_freak> lucian: how are they "trivial"?
05:24:33 <lucian> one or two chars
05:24:48 <covi>     fmap f (Either x y) = Either x $ f y
05:24:49 <mm_freak> what difference does the length make?
05:24:50 <barrucadu> mcstar: Unicode is wonderful, and using the appropriate mathematical symbols (where they exist) is better than using function names (imo)
05:24:52 <covi> is this correct?
05:25:08 <lucian> mm_freak: longer means more potential combinations
05:25:13 <mm_freak> covi: Either is a type
05:25:19 <mm_freak> covi: you pattern-match against constructors, not types
05:25:20 <navaati> if "trivial" is "one char" like + or × are, well, let's use ⊛ instead of <*>
05:25:23 <lucian> mm_freak: so more things with ascii art names
05:25:36 <lucian> navaati: that would be somewhat better if it were easier to type
05:25:40 <mm_freak> lucian: the choice of names is very reasonable in haskell
05:25:46 <mcstar> dont treat this opinion too seriously, i just dont get this, and literate programming (i like latex though)
05:25:56 <lucian> mm_freak: i'm just saying i disagree with that choice
05:25:59 <mm_freak> for example <…> intuitively means "functor version"
05:26:12 <mm_freak> ^… means:  pure function to the left
05:26:13 <mm_freak> etc.
05:26:20 <hpc> mm_freak: or just "lifted" in general
05:26:26 <hpc> see: <*>, <|>
05:26:32 <covi>     fmap f (Left x) = Left x
05:26:32 <covi>     fmap f (Right y) = Right $ f y
05:26:35 <mm_freak> hpc: that's the same =)
05:26:36 <covi> how about this?
05:26:54 <mcstar> covi: those situation s dont require $
05:26:56 <mm_freak> covi: except that i would have written "Right (F y)", yes =)
05:27:11 <mm_freak> uhm…  s/F/f/
05:27:18 <covi> mm_freak: thanks =)  but why $ is not good here
05:27:41 <mcstar> () is more intuitive
05:27:58 <mm_freak> covi: parentheses aren't evil…  parentheses better show the grouping
05:28:11 <mcstar> i like using $ when i generate inline actions
05:28:22 <covi> I see, thanks guys
05:28:23 <hpc> covi: it's a matter of making code look like what it means
05:28:42 <mm_freak> covi: for the same reason i prefer to write "print (f x)" over "print $ f x" or even "printf . f $ x"
05:29:20 <mcstar> though i prefer this: putStrLn $ "afdas" ++ show n ++ "dasfsdf"
05:29:38 <navaati> in this case i prefer using $ : "Right $ f y" pretty intuitively means "apply Right to f y", doesn't it ?
05:29:40 <covi> mm_freak: I prefer print $ f x because $ has a "splitting" feel
05:30:33 <mm_freak> covi: you don't split, you apply…  after a few years of haskell i found that ($) is actually quite evil
05:30:40 <mm_freak> you notice this when you come back to your code later
05:31:03 <watcat> hrm, what seems to be wrong here? foldr (\x -> if 'b' `elem` x then x else "") "" "b", i'm not sure what the accomulator needs to be, i tried it with [] too. it expects b0->b0 but apparently im not producing that
05:31:15 <mm_freak> nowadays i even tend to write "(f . g) (x + y)" over "f . g $ x + y"
05:31:30 <mm_freak> watcat: the folding function takes two arguments
05:32:01 <hpc> :t foldr (\x -> if 'b' `elem` x then x else "")
05:32:02 <lambdabot>     Couldn't match expected type `b -> b'
05:32:02 <lambdabot>            against inferred type `[Char]'
05:32:02 <lambdabot>     In the expression: x
05:32:14 <watcat> i thought foldr takes a function, an accomulator  and some list ?
05:32:27 <hpc> :t foldr -- how many arguments does the first function take?
05:32:27 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
05:32:30 <mm_freak> watcat: the "folding function" is the first argument of the foldr combinator
05:32:32 <mcstar> can haskell match expected type `b -> b' against inferred type `[Char]'?
05:32:37 <watcat> oh
05:32:39 <mcstar> NO haskell cant do that!
05:32:51 <arnsa> could anyone tell me what is haskell used for?
05:32:53 <ClaudiusMaximus> i rather write   (f . g . h) x  because the precedence messes up with   f . g . h $ x  + z
05:32:59 <kallisti> arnsa: writing computer programs.
05:33:07 <arnsa> kallisti, is it used for web dev?
05:33:11 <kallisti> yep
05:33:14 <hpc> i use ($) all the time
05:33:18 <arnsa> kallisti, what kind of programs?
05:33:23 <hpc> runWith foo $ \x -> do ...
05:33:26 <kallisti> arnsa: any kind
05:33:27 <mm_freak> mcstar: we'll see…  haskell can prove a -> b ;)
05:33:32 <watcat> arnsa - anything - xmonad is a gui, with yesod it's used for webdev, academically it is used to write logic/AI and solve other problems
05:33:36 <watcat> etc
05:33:42 <arnsa> kallisti, even games? o.O
05:33:45 <watcat> once you learn how to use folding...
05:33:58 <watcat> yes john carmack was considering haskell
05:34:01 <kallisti> there's a few games out there. functional reactive programming is a promising method for game dev.
05:34:02 <mm_freak> arnsa: i use it for networking applications
05:34:04 <lucian> arnsa: one could certainly write games with it, yes. it's a general-purpose language, like most nowadays
05:34:29 <mm_freak> and yes, haskell (slowly) enters the gaming world
05:34:32 <ClaudiusMaximus> hpc: yep i use that a lot too, but i did also go through a whole library i wrote changing runST $ do ...  to runST (do ...)  so that it would work in Hugs
05:34:33 <arnsa> lucian, is it dynamical language?
05:34:45 <arnsa> like Python for example
05:34:47 <lucian> arnsa: no, quite the opposite
05:34:49 <mm_freak> arnsa: haskell is a static language
05:34:56 <lucian> it's a statically, strongly typed language
05:35:04 <lucian> whereas python is dynamically, strongly typed
05:35:05 <kallisti> for some value of "strong"
05:35:12 <arnsa> heh okay, thanks for the info
05:35:34 <mm_freak> kallisti: ?
05:35:40 <lucian> arnsa: it's way less annoying than mainstream statically typed languages, though
05:35:45 <mcstar> its equally as important to mention it is lazy, and denotational
05:36:06 <lucian> i'm most comfortable with python and i really dislike writing java and similar, but haskell i find pleasant
05:36:11 <mm_freak> lucian: "though"?  are you implying that statically typed languages are generally annoying?
05:36:18 <navaati> haskell is denotational ? what the hell does it mean ?
05:36:19 <watcat> argghh... i can't wrap my head around this
05:36:32 <lucian> mm_freak: yes, ones like C, C++, Java
05:36:35 <ClaudiusMaximus> languages without type inference are generally annoying
05:36:47 <kallisti> mm_freak: the strong vs. weak typing distinction is really kind of ambiguous. Ad-hoc polymorphism can be considered a form of weak typing.
05:37:03 <mm_freak> kallisti: which haskell does not have
05:37:04 <lucian> mm_freak: the type system is too incomplete to be useful, but the compiler uses too much hand-holding for it to be feasible to write anything meaningful
05:37:38 <kallisti> mm_freak: typeclasses?
05:37:40 <mcstar> navaati: http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
05:37:59 <mm_freak> kallisti: how are they not strongly typed?
05:38:04 <navaati> kallisti: not really, because (+) is Num a ⇒ a → a → a, not (Num a, Num b, Num c) ⇒ a → b → c
05:38:11 <mm_freak> lucian: i agree about the common languages, but i wouldn't generalize this
05:38:32 <lucian> mm_freak: i did say mainstream. ML isn't
05:38:55 <mm_freak> it's just that the people designing languages are mostly not as smart as i would like them to be
05:39:01 <lucian> heh
05:39:08 <navaati> mcstar: i know that, but why would haskell be more "denotational" than C ? maybe the denotation of haskell is closer to usual maths, yeah…
05:39:17 <mm_freak> their brain seems to emergency-power-down when it comes to the type system and syntax
05:39:30 <kallisti> navaati: therefore ad-hoc polymorphism is impossible, because there exists a use of typeclasses that serves as a counter-example?
05:39:30 <lucian> mm_freak: sometimes they have reasons other than stupidity for particular choices
05:39:33 <mm_freak> the syntax is almost always designed for the compiler, not the human
05:39:43 <mcstar> navaati: exatcly
05:40:37 <navaati> kallisti: well, yeah, it's true that i'm more talking about the prelude than the language
05:41:00 <mm_freak> lucian: i regard it as stupidity to have "generics", but no real type variables and no kind system
05:41:11 <kallisti> I do agree that Haskell is stronger typed than your average language.
05:41:29 <kallisti> but that the distinction between strong and weak typing is still not very clear.
05:41:32 <companion_cube> navaati: haskell can be formalized as a rewriting system, for C I think it's more difficult
05:41:48 <mm_freak> kallisti: "implicit" doesn't mean "less strong"…  the implicit dictionary argument still has to match
05:42:09 <lucian> mm_freak: many people had that reaction about Go, but i think overall they made the right choice. its compiler is very simple and the language will be familiar to many
05:42:21 <mm_freak> weak typing means there is some implicit conversion going on, which does not happen in haskell
05:42:36 <lucian> kallisti: it's not terribly clear, but it's pretty clear when a language does implicit conversions or similar
05:42:39 <kallisti> mm_freak: so if you can implement implicit conversions in the language itself, it's suddenly not weak typing anymore?
05:42:47 <navaati> companion_cube: out of curiosity, what does mean recursion in a rewriting system ? (i don't know formally what a "rewriting system" is)
05:42:52 <mm_freak> kallisti: how can you do that?
05:42:55 <kallisti> but if it's built-in, now it's a weak type system.
05:43:03 <kallisti> mm_freak: with typeclasses, easily.
05:43:11 <mm_freak> kallisti: how?  example?
05:43:38 <kallisti> http://hackage.haskell.org/package/cond  all of this code is overloaded on a boolean conversion class.
05:43:42 <companion_cube> navaati: you rewrite expressions, so recursion is a rewriting step in which some symbols occur in both sides (like  map f x:xs  → (f x):(map f xs))
05:43:48 <kallisti> you could use it to implement PHP like conditional semantics
05:43:59 <mm_freak> lucian: Go is about the worst language invented in the last decade…  it fails in every respect
05:44:00 <navaati> mm_freak: see the return type of Text.Printf.printf for example
05:44:09 <mm_freak> it's a VERY ugly mixture of C and erlang
05:44:24 <mm_freak> sucky type system, immensely complicated syntax, etc.
05:44:31 <lucian> mm_freak: except where lots of people will use it to write good concurrent software, because they're familiar with the concepts
05:44:52 <mm_freak> lucian: those people are better off actually combining erlang and C (or just use haskell)
05:44:55 <lucian> mm_freak: i'd be very happy if it replaced C, C++ and Java
05:45:07 <lucian> mm_freak: right, but they'll never learn haskell, or even erlang
05:45:22 <mm_freak> navaati: printf is a hack
05:45:26 <lucian> mm_freak: they'll just keep writing code with threads in C++
05:45:41 <navaati> mm_freak: yeah, but a "legal in the language" one :)
05:46:05 <mm_freak> lucian: i'd like Go not to become popular…  i'd prefer if somebody actually designed a sane language and that one replaced C/C++/Java
05:46:22 <navaati> (i'm not talking about the vararg stuff but about the fact that it can return a String or an IO (), for example)
05:46:29 <lucian> mm_freak: if your definition of sane means "similar to haskell", it'll never ever be popular sadly
05:46:30 <watcat> foldr  (\x y-> if 'b' `elem` x then x else y) ""  "chat", this doesn't work.foldr  (\x y-> if 'b' `elem` x then x else y) [] ["chat"] does work. but it gives me a list. i don't want to produce a list. i just want a string. >.<
05:46:35 <companion_cube> but if you deem "sane" only languages close to haskell, none will replace C,C++ nor java
05:46:40 <womb> :t map
05:46:41 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
05:46:41 <mm_freak> navaati: you have a point there…  but i'm actually talking about the vararg stuff
05:46:41 <kallisti> mm_freak: so maybe I just don't understand what weak typing means, and if I do, I don't understand the importance.
05:46:54 <mm_freak> navaati: there is nothing wrong with printf being able to be either IO () or String
05:47:00 <lucian> mm_freak: just like Gosling designed Java to move C++ programmers away from the greater evil
05:47:21 <mm_freak> that's not weak typing, because in no case a string is converted to an IO () or vice-versa
05:47:34 <navaati> mm_freak: no, i don't say it's wrong, i say it's maybe an example of what kallisti would call "weak typing"
05:47:52 <navaati> (but in the end i agree with you)
05:47:52 <mm_freak> kallisti: weak typing is the compiler/interpreter trying to make sense of something that doesn't make sense
05:47:57 <mm_freak> that doesn't happen in haskell
05:48:05 <mauke> mm_freak: [citation needed]
05:48:20 <mm_freak> well, it happens, if you start to hack around the type system
05:48:28 <mm_freak> but of course then no language is really strongly typed
05:48:30 <kallisti> given a sufficient implicit conversion operation between data types, any operation can be forced to make sense.
05:48:33 <kallisti> see: Perl
05:48:50 <companion_cube> see: php
05:48:51 <mauke> no, Perl doesn't do that
05:48:58 <companion_cube> oh, wait, it still does not make sense
05:49:03 <mm_freak> lucian: "sane" means simple, readable syntax and a useful type system
05:49:20 <navaati> i think it's the "implicit conversion operation" that it's considered (and is) evil
05:49:28 <mm_freak> Go's syntax is more complicated than C++'
05:49:35 <mm_freak> and that's really something
05:49:42 <companion_cube> mm_freak: err, are you sure of that??
05:49:43 <kallisti> navaati: right so weak typing involves whether or not the conversion is builtin to the language
05:49:52 <navaati> kallisti: yep
05:49:53 <mauke> mm_freak: is it possible to write a parser for Go?
05:49:57 <kallisti> which is rather meaningless if you're using a highly overloaded library where the conversions are implicit to the programmer
05:50:16 <kallisti> the implicitness was just defined in the language itself.
05:50:25 <mm_freak> companion_cube: i've watched a video presentation which demonstrated all of the "syntactic features"
05:50:27 <russellw> mm_freak, I'm not particularly a fan of Go, but I didn't realize it's syntax was as complicated as that - what areas of it are particularly complicated?
05:50:31 <mm_freak> mauke: i doubt it
05:50:37 <navaati> if it's not builtin, if forces the programmer to ask explicitly for the conversion, which, in a statically typed language, is considered (by much people) a good thing
05:50:41 <lucian> mm_freak: people will want a C-like syntax and a type system that is static, but not too much so. that's the only thing that could be come popular
05:51:02 <lucian> russellw: it's simpler than C, but not by a lot
05:51:04 <companion_cube> mm_freak: to me, it looked like the syntax was simple, but they added some special cases, kind of hacks
05:51:21 <kallisti> mauke: well I don't mean there's an implicit conversion between every data type for every operation, but quite a few of the built-in operators interpret all of the builtin data types in a certain context.
05:51:40 <kallisti> (re: perl)
05:51:43 <mm_freak> kallisti: weak typing can be summarized as:  prefer to do something instead of throwing an error at the programmer
05:51:57 <mm_freak> companion_cube: lots of
05:52:09 <russellw> lucian, I had the impression it was somewhere in the range of a bit simpler than C to a bit more complicated than C depending on how you weight various things, yeah
05:52:15 <mauke> kallisti: what do you count as "data types" in perl?
05:52:24 <sopvop> Is anyone here familiar with web-routes-boomerang?
05:52:48 <navaati> it's very difficult to be simpler than C : C is dead simple
05:52:53 <mm_freak> lucian: not sure about that…  haskell is becoming very popular despite the strong typing and the unfamiliar syntax
05:53:04 <lucian> russellw: i consider things like expression assignments very dangerous (and go rightly disallows such things). but indeed, it could be argued it's similarly complex to C
05:53:09 <mauke> navaati: C is complicated because the lexer needs to know what typedefs are in scope
05:53:15 <russellw> navaati, it seems that way until you try to write a parser for it :)
05:53:17 <kallisti> mauke: good question. the implicit conversions make things confusing. You could treat numbers and strings as being one type essentially.
05:53:33 <lucian> mm_freak: is it? even python is not exactly "popular"
05:53:33 <navaati> aaaah, complicated to parse, yeah of course
05:53:33 <kallisti> but references are treated specially.
05:54:06 <mm_freak> lucian: take the derivative of "popular" wrt time
05:54:17 <kallisti> mauke: so I don't think it's enough to say that all scalars are the same "data type".
05:54:25 <mm_freak> dpopularity/dtime is positive for both haskell and python
05:54:32 <lucian> mm_freak: heh
05:54:40 <navaati> python *is* popular : it's basically the first language of a lot of people, at school
05:54:57 * kallisti learned Python on his own time when he was 16.
05:55:00 <ment> :t replicateM
05:55:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
05:55:22 <kallisti> I'm not sure that I would have found programming accessible otherwise.
05:55:38 <zomg> I'd kinda want to work with python or haskell but it kinda blows I'd basically have to take a real shitty salary because I don't have work experience for either :p
05:55:39 <mcstar> Chinese is more popular
05:55:49 <lucian> navaati: i was comparing it to the strongly incumbent ones like C++, C# and Java
05:56:01 <kallisti> zomg: well with Haskell jobs are very rare anyway
05:56:05 <zomg> Yeah
05:56:05 <mm_freak> zomg: gain that one in your spare time =)
05:56:09 <kallisti> (but most of the ones I've seen have high salaries)
05:56:38 * lucian has a crap-paying python job
05:56:42 <zomg> mm_freak: oh I know python pretty well and haskell somewhat but generally it doesn't count when they want you to have built something completely crazy
05:56:46 <navaati> lucian: depends if you mean "popular in the industry" or "popular for hobbyists", but industry use java and is full of crap anyway, so…
05:56:49 <mm_freak> one thing people don't see is:  while there aren't many haskell jobs, there also aren't many haskell programmers…  if you're good, the odds of getting a job are probably not much worse than with PHP
05:56:50 <lucian> i've noticed no causality between the two, though
05:56:59 <lucian> navaati: yes, the distinction is useful
05:57:04 <kallisti> mm_freak: that's my goal..
05:57:09 <zomg> It's stupid that they won't hire a sr level dev when he hasn't built a site with bazillion users.. how many people have?
05:57:19 <lucian> mm_freak: location can mess with that, though
05:57:22 <zomg> (I'm generally a web developer)
05:57:31 <mm_freak> zomg: something completely crazy is "a web application in PHP"
05:57:39 <navaati> mm_freak: really ? interesting point of view…
05:57:44 <zomg> mm_freak: I'd know since that's what I do :p
05:57:56 <zomg> Also why I'd sorta wanna do something else for a change
05:58:01 <mm_freak> navaati: i said "probably"…  don't take my words too seriously =)
05:58:22 <navaati> you made me hope x)
05:58:42 <zomg> maybe I should get a mid level telecommute job for some python house in the states
05:58:51 <zomg> they pay jr to mid devs more than I get here for sr =)
05:58:52 <zomg> oh well
05:59:07 <mm_freak> i used to be a PHP web developer…  it's a very frustrating job
05:59:16 <navaati> "telecommute" ?
05:59:19 * lucian shudders at the thought
05:59:24 <zomg> Not really if you get to work with people who aren't completely awful
05:59:26 <navaati> mm_freak: poor you…
05:59:36 <lucian> zomg: it's stupid how many companies refuse to consider telecommuting
05:59:38 <zomg> navaati: work from home / anywhere
05:59:45 <mm_freak> zomg: you get to work with a code base that is completely awful, no matter what you do
06:00:00 <mm_freak> PHP really embraces the concept of entropy
06:00:04 <lucian> even if you wrote it! ugh i hate php
06:00:09 <zomg> mm_freak: not really, we built a quite alright (for most parts anwyay) MVC based application with PHP :)
06:00:20 <zomg> The only places where it's bad is where I didn't get to shout at people for doing a bad job
06:00:23 <zomg> :P
06:00:34 <mm_freak> zomg: so you write a haskell interpreter in PHP? ;)
06:00:44 <mm_freak> → wrote
06:00:48 <zomg> Perhaps I should
06:00:52 <zomg> or a Haskell to PHP compiler
06:00:53 <zomg> =)
06:00:56 <lucian> there was a ruby -> php one
06:01:08 <lucian> and i'm sure it wouldn't be too much work to write a php clojurescript backend
06:01:20 <mm_freak> haskell to PHP compiler…  have fun…  an interpreter would be enough work already
06:02:28 <ment> having a job is overrated anyway
06:02:30 <zomg> an interpreter would be really slow though
06:02:31 <zomg> =)
06:02:45 <zomg> ment: true. I'd love to build a SaaS app and actually make money out of it
06:02:50 <mm_freak> i doubt that a compiled application would be much faster
06:03:12 <ment> zomg: what's saas?
06:03:14 <mm_freak> compile to an AST and interpret the AST
06:03:15 <lucian> mm_freak: any sort of dispatch in php is slow, so i'm not so sure
06:03:25 <zomg> ment: software as a service, sort of like what 37signals or such do
06:05:51 <mcstar> haskell is good for head expansion, i dont expect to use it for any real world application
06:06:06 <mm_freak> mcstar: why not?
06:06:23 <mcstar> im just not in that position
06:06:33 <zomg> Having used Haskell a bit for building a web application, it's rather nice infact.
06:06:41 <mcstar> but its great to build up some CS knowledge
06:06:44 * kallisti is developing pretty large applications in Haskell right now as a freelancer.
06:06:44 <zomg> (in addition to other things)
06:07:21 <mroman_> Isn't haskells license a huge bummer?
06:07:33 <mm_freak> kallisti: what kind of applications if i may ask?
06:07:44 <mm_freak> mroman_: how?
06:08:07 <mroman_> Well, to deploy precompiled binaries you'd have to track down all license of every package  you use
06:08:17 <mroman_> and every license of every depedency of every package you use.
06:08:23 <mroman_> and GHC Base is BSD.
06:08:23 <mm_freak> mroman_: is that a haskell issue?
06:08:34 <mroman_> Somehow.
06:08:53 <mroman_> You're "doomed" on using BSD licensed code.
06:09:01 <lucian> i don't see how haskell's license is worse than, say, python's
06:09:10 <mm_freak> mroman_: so?
06:09:18 <kallisti> mm_freak: data-driven bakends. Pretty soon I'll be working on a server-side backend for a mobile app.
06:09:21 <mauke> mroman_: what's the problem with BSD?
06:09:31 <mm_freak> kallisti: cool
06:09:44 <mroman_> BSD itself is not a huge problem.
06:09:49 <mroman_> But tracking down the licenses is.
06:10:04 <mauke> how is this different from ... anything else?
06:10:05 <lucian> mroman_: that's the same with any program where you use external libraries
06:10:07 <mm_freak> mroman_: you have to do that in every language
06:10:26 <kallisti> at least we have Hackage, where the license is clearly displayed on the description page.
06:10:35 <kallisti> along with all dependencies
06:10:59 <lucian> kallisti: i wouldn't say "at least", that's pretty much *the* solution
06:11:17 <mm_freak> ok, one problem is that haskell programs usually have lots of dependencies
06:11:24 <zomg> Licenses like that aren't really a big deal if you're just developing internal applications though =)
06:11:24 <kallisti> lucian: at most? :P
06:11:43 <lucian> mm_freak: how is that different from python/ruby/js ones?
06:11:45 <ChristianS> bsd is not a viral license, so it doesn't "doom" you at all
06:12:13 <mm_freak> lucian: the number packages you depend on indirectly can be hundreds
06:12:32 <mm_freak> a yesod hello world already needs literally hundreds of packages
06:12:45 <lucian> mm_freak: is that because haskell packages tend to be smaller?
06:13:03 <mm_freak> lucian: more focussed, yes
06:13:03 <mroman_> which means that you have to gather all hundred license files ;)
06:13:27 <lucian> well, our python thing at work has around 30 things it depends on
06:13:28 <ment> mm_freak: well even if you pay $1 or $2 per package you still get a reasonable price for hello world
06:13:37 <lucian> but some of them are made of many other bits, like django
06:13:48 <mm_freak> but it's really easy to ask cabal if there is any non-BSD license there
06:13:50 <mm_freak> and just review those
06:13:55 <lucian> i think it's just the granularity at which we're counting is different
06:13:57 <ClaudiusMaximus> http://www.haskell.org/pipermail/haskell-cafe/2011-October/095932.html [Haskell-cafe] cabal license check?
06:14:04 <mroman_> mm_freak: You still need to include every BSD license?
06:14:17 <lucian> how is BSD not a nice license?
06:14:17 <mm_freak> mroman_: nope
06:14:24 <lucian> it's pretty much carte blanche
06:14:35 <mroman_> I thought you have to include every author.
06:14:56 <mm_freak> mroman_: BSD effectively requires you to keep the copyright notices in source code, if you were to change it
06:15:06 <mm_freak> of course you won't edit all the hundreds of libraries you're going to use
06:15:29 <mroman_> "Redistributions in binary form must reproduce the above copyright notice,"
06:15:35 <mcstar> does BSD provide unrestricted binary distribution?
06:15:46 <mm_freak> i see
06:15:55 <mroman_> That includes the copyright (c) <author name> line if I understand it correctly.
06:16:00 <mm_freak> well, you can do that quite mechanically
06:16:04 <lucian> ah, that's 3-clause bsd
06:16:08 <mcstar> where do you put that?
06:16:17 <mm_freak> i don't think you really need to do all that by hand
06:16:26 <opqdonut> usually when people say BSD they refer to a version of the license _without_ the copyright clause
06:16:50 <opqdonut> see https://en.wikipedia.org/wiki/BSD_licenses#Terms
06:17:38 <mroman_> http://en.wikipedia.org/wiki/BSD_licenses#2-clause_license_.28.22Simplified_BSD_License.22_or_.22FreeBSD_License.22.29
06:17:50 <mm_freak> hmm, then i'll probably switch to BSD2
06:17:52 <mroman_> ^- still requires to include the copyright notice.
06:17:59 <manish411> hi haskellers!!!
06:18:08 <mm_freak> currently i'm distributing my packages under BSD3
06:18:18 <mm_freak> mroman_: in source code form
06:18:25 <mm_freak> you don't distribute the source code of dependencies
06:18:44 <mcstar> how about LGPL? can i use distribute a closed source program that uses LGPL licensed libs?
06:18:50 <mm_freak> hi there manish411
06:18:51 <ClaudiusMaximus> mroman_: maybe look at the cabal/debian tools, i imagine they automate collecting all the required license texts
06:18:52 <mroman_> But I distribute them in binary form.
06:19:00 <mroman_> Redistributions in binary form must reproduce the above copyright notice,
06:19:05 <mroman_> ^- still says so in 2-clause
06:19:08 <lucian> mceier: yes, that's the point of lgpl
06:19:15 <mcstar> k
06:19:19 <mm_freak> indeed
06:19:32 <mcstar> thats qt's oensource license, so im in the clear
06:20:16 <mm_freak> mroman_: but wait, that's only about redistributing the dependencies themselves
06:20:20 <manish411> guys any of you into parsec library??
06:20:23 <mm_freak> you don't redistribute dependencies
06:20:33 <mroman_> mm_freak: If I just do make, then I do.
06:20:37 <mroman_> due to static linking.
06:20:53 <mm_freak> manish411: just ask
06:21:16 <mroman_> And I don't really want to expect people to install haskell libraries on their systems.
06:21:28 <mm_freak> mroman_: i see the problem
06:21:52 <Taneb> Well, family-tree depends on a total of 19 modules, all of which are BSD3-licensed
06:22:07 <Taneb> 20 if you count ghc-prim
06:22:33 <Taneb> What's the license for ghc-prim?
06:22:42 <mm_freak> mroman_: but it only applies if you choose not to distribute the source code, right?
06:22:50 <mm_freak> otherwise you could just provide a link to the source code
06:23:05 <mm_freak> Taneb: BSD
06:23:24 <mroman_> mm_freak: It applies if I choose to distribute my application as a binary.
06:23:28 <manish411> starting to learn parsing through parsec, can we make a parser for a non left - recursive grammer without using ParseExpr library??
06:23:31 <mroman_> Which is usually what a normal user expects ;)
06:23:41 <Taneb> The BSD license sure is popular
06:26:31 <mm_freak> mroman_: the question is whether you want to keep the source code secret…  also you can always add the output of cabal
06:26:35 <nibalizer> hi guys, can someone try to help me with this dependency hell i've found myself in where haskell98 and base are mutually exclusive, but base is a requirement for haskell98?
06:26:46 <mm_freak> manish411: certainly
06:26:55 <mroman_> mm_freak: That does not matter @keeping the source code secret.
06:27:16 <mroman_> I have to include the notices in both the source and binary distribution.
06:27:19 <Taneb> nibalizer, why do you need Haskell98?
06:27:54 <mm_freak> mroman_: in some loosely specified form…  cabal output should suffice
06:28:10 <nibalizer> Taneb: stack overflow has led me to believe I do
06:28:32 <mroman_> mm_freak: I'll have a look into that. Thx.
06:28:33 <Taneb> nibalizer, link?
06:29:10 <manish411> and for left recursive grammer ??
06:29:19 <nibalizer> http://stackoverflow.com/questions/4447130/make-could-not-find-module-system
06:29:24 * hackagebot http-conduit 1.4.1.7 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.4.1.7 (MichaelSnoyman)
06:29:28 <manish411> there is a function called buildparseExpression
06:29:31 <Botje> manish411: you can, but it's boring.
06:29:41 <Botje> manish411: you have to manually encode precedence levels
06:29:48 <mm_freak> manish411: left-recursive grammars need to be rewritten to be right-recursive
06:29:50 <mm_freak> http://en.wikipedia.org/wiki/Left_recursion#Removing_left_recursion
06:30:09 <manish411> so what is the benefit of using buildparseExpression??
06:30:22 <mm_freak> if you can express your grammar using parsec's expression framework, go ahead…  personally i prefer to do it manually
06:30:56 <manish411> ya for starter it is good to do it manually
06:31:03 <manish411> i think
06:31:14 <mm_freak> probably…  but i'm not even a starter =)
06:31:35 <hpaste> nonefool pasted “Missing instance but passes compilation” at http://hpaste.org/68774
06:31:49 <manish411> I have to do some work on parsec library for my summer internship
06:32:06 <Taneb> nibalizer, I'd try installing from binaries
06:32:11 <Taneb> http://wiki.darcs.net/Binaries
06:32:14 <nonefool> ^^ can somebody tell me if the pasted program should pass compilation, or if it is a bug in ghc?
06:32:44 <nibalizer> okay thanks
06:33:02 <absence> mm_freak: hi there :) could i pester you about that netwire event problem of mine?
06:33:27 <mm_freak> absence: hi there…  sure
06:35:42 <absence> mm_freak: i got the impression that it's better to do event handling using <|> instead of holdwith/injectevent, but i can't wrap my head around it. i've figured out how to make it work with holdwith/injectevent (http://hpaste.org/68691), but i'm not sure how it's supposed to look the other way
06:37:01 <mm_freak> absence: at first you should stop thinking of event signals as Maybe Event
06:37:11 <absence> okay
06:37:13 <mm_freak> don't ever produce them in the first place
06:37:55 <mm_freak> events are not signals, but an abstract concept…  an inhibiting wire can be /interpreted/ as a non-happened event
06:38:02 <Philippa> mm_freak: it's a bit cruel to mention rewriting to right-recursion but not the combinators like chain*
06:38:37 <Philippa> the expr lib gives you what should be a reasonably fast implementation using a specialised algorithm, IIRC
06:39:03 <mm_freak> absence: example:  handleQuit . quitKey <|> handleMenu . menuKey <|> handleElse
06:39:31 <mm_freak> Philippa: i've never used chain*
06:39:59 <mm_freak> and the expression stuff in parsec scares me…  i came from attoparsec to parsec for a project i'm doing now
06:40:08 <mm_freak> and only because i need source code positions this time
06:40:22 <Cale> nonefool: I think you're right. There's no instance of Super anywhere in the program, so no instance of Duper could possibly be valid to use.
06:41:37 <absence> mm_freak: so handlequit and handlemenu are inhibiting wires right? don't they take Maybe Key or something like that to know when to inhibit?
06:41:44 <nonefool> Cale: even with the added instance, the program loops infinitely if the constraint on Foo is Duper instead of Super; I guess I just cheated myself into a incoherent instance?
06:42:07 <mm_freak> absence: no, quitKey and menuKey are inhibiting wires…  they act like identity, when the key is pressed and inhibit otherwise
06:42:07 <Cale> nonefool: I'm just looking at that case now...
06:42:20 <mm_freak> absence: in w2 . w1, if w1 inhibits, then the composition inhibits
06:42:33 <mm_freak> w2 is never reached in that case
06:42:55 <t7> anyone wanna hire me
06:43:03 <t7> im sick of windows server
06:43:06 <t7> and windows
06:43:14 <mm_freak> absence: of course handleQuit and handleMenu can inhibit, too, in which case again the composition inhibits
06:43:21 <Cale> nonefool: Oh, it should actually be complaining about overlapping instances, but it's not...
06:43:32 <Cale> er... no
06:43:41 <Cale> sorry, confused myself there :)
06:45:13 <absence> mm_freak: oh, i see.. the input for quitkey and menukey, that's the inputevent?
06:45:29 <mm_freak> absence: no, there are no input events
06:45:47 <mm_freak> if your wire receives input, the wire concludes that the event happened
06:46:04 <mm_freak> again, stop thinking of events as Maybe Something
06:46:33 <absence> mm_freak: i would, if i could imagine how to fire e.g. the quitkey event otherwise :)
06:46:57 <mm_freak> well, depends on your application/library design
06:47:09 <Cale> nonefool: Okay, yeah, it should be fine with the Super instance in place, but I think the <<loop>> is occurring because of overstrictness in the typeclass evidence.
06:47:26 <mm_freak> if your wire type itself captures the interface to the GUI library then quitKey would have this type:  MyWire a a
06:47:43 <mm_freak> it communicates with the GUI library to find out whether the quit key was pressed
06:47:49 <absence> mm_freak: i'm trying to hook this up with glut, which has a callback that is called whenever there is an input event
06:47:51 <mm_freak> if yes, it acts like identity, otherwise it inhibits
06:48:15 <mm_freak> GLUT is not a good library to interface with…  i recommend going for SDL instead
06:48:38 <mm_freak> SDL has a classic event processing loop, which is perfect for integration with FRP
06:48:41 <absence> mm_freak: i'm not a fan of glut myself, but it's what gpipe uses
06:50:23 <mm_freak> well, i'm not entirely sure how i would integrate netwire and GLUT…  one simple way is to just let the callbacks cause stepping
06:50:38 <mm_freak> the underlying monad would be a reader monad with the current state including pending events
06:50:59 <Cale> We use testDup requiring  Duper (Fam Float), and we have an instance Foo a => Duper (Fam a) which can be used at a ~ Float to obtain that instance. We have the instance Foo Float which is required by the instance. We're also required by the superclass constraint to have an instance of Super (Fam Float), which we also have. So at this point, everything should be satisfactory. At the value level,  testDup (FamFloat 3) sh
06:50:59 <Cale> ould be equal to testFoo (FamFloat 3) + testSup (FamFloat 3) -> 5 + 3 -> 8
06:51:03 <mm_freak> quitKey then communicates with this reader to find out whether the quit key was pressed in this instance
06:51:15 <mm_freak> if yes, acts like identity, otherwise inhibits
06:51:49 <mm_freak> s/instance/instant/
06:51:59 <Cale> So the loop isn't happening there, the only cycle which is around is in the typeclass evidence.
06:52:29 <absence> mm_freak: this is starting to make sense :)
06:53:01 <Cale> (and it's not even a cycle which ought to be a problem)
06:56:18 <nonefool> Cale: hhm ok, wouldn't know anything about that ;) but something like ;class (Bar a, Doo a) => Foo a where; instance Foo a => Magic a where; should be allowed if either Bar or Doo is a strict superclass of Magic? and it shouldn't be if Magic equals either Foo or Bar? (if so, why?)
06:56:53 <absence> mm_freak: would you do something similar in sdl? (i.e. gather events for each instant and use reader monad)
06:57:08 <Cale> nonefool: I'm not sure what you mean there...
06:58:42 <nonefool> Cale: there's some kind of cycle there, an instance for some superclass is generated from the subclass
06:59:00 <Cale> nonefool: class A t => B t  means that whenever we have an instance of B t, we ought to also have an instance of A t, or compilation should fail. (It doesn't matter if this is defined in terms of the methods of B or not, it just has to be defined somewhere.)
06:59:05 <nonefool> Cale: like Duper from Foo
06:59:14 <navaati> absence: are you here ?
06:59:34 <absence> navaati: sure am
06:59:34 <frerich> heh.
06:59:51 <nonefool> Cale: I could imagine type inference wouldn't halt or something because the instance that's required for the generating still needs to be generated
06:59:53 <nonefool> or something
07:00:00 <nonefool> but dunno
07:00:03 <Cale> Well, it should be fine.
07:00:30 <navaati> ah yeah, i should have read the backlog… if you're interested i've made a transcription of my gloss example from netwire to animas
07:01:21 <Cale> But what's happening, I think, is that at runtime, there's a cycle in the structure being used to hold the typeclass methods, and either the fields of this structure are strict, or something is causing them to be evaluated before they should be.
07:01:40 <Cale> Give me a moment to hand-compile this program a bit...
07:01:51 <absence> navaati: it would be interesting to see, even if i'm trying to learn netwire :)
07:02:37 <hpaste> navaati pasted “gloss animas” at http://hpaste.org/68775
07:03:02 <navaati> (it is a little bit different, but the idea is there)
07:05:33 <Cale> nonefool: Oh, I see.
07:05:51 <Cale> hah, compiling things by hand is a nice way to get some perspective. :)
07:06:02 <absence> navaati: yeah, it looks somewhat different. i'll keep it for when i have some more time, thanks :)
07:07:27 <mikeplus64> prodsum() { product | ¿ l . 'list {1..$l}' | sum }
07:07:30 <mikeplus64> herp
07:07:45 <mikeplus64> bad clipboard
07:08:01 <mikeplus64> http://quasimal.com/posts/2012-05-21-funsh.html <- maybe of interest to people here :)
07:09:38 <manish411> d
07:13:07 <manish411> mm_freak , so writing parser for non-left recursive grammer with basic parsec function is writing a recursive decent parser
07:13:07 <manish411> ??
07:13:08 <hpaste> Cale annotated “Missing instance but passes compilation” with “semicompiled with gaps” at http://hpaste.org/68774#a68776
07:15:39 <Cale> now, I'll fill in the "..." fields, as I believe the compiler has done
07:15:58 <hpaste> Cale annotated “Missing instance but passes compilation” with “semicompiled” at http://hpaste.org/68774#a68777
07:16:06 <RichyB> manish411, pretty much yeah. Parsec without using the "try" function pretty much maps 1:1 to a recursive descent parser.
07:16:16 <Cale> It's really the only option that it has
07:16:29 <Cale> Because it's the only polymorphic way to fill in those gaps
07:17:16 <Cale> I don't know if it's actually the right thing
07:17:31 <Cale> (it should probably just complain)
07:18:04 <manish411> ok got it
07:18:20 <nonefool> Cale: ok, good luck..
07:18:38 <Cale> nonefool: So, do you see what's going on there?
07:19:41 <Cale> I think this is still worth showing to Simon or someone involved in implementing this stuff.
07:19:47 <Cale> It's very confusing.
07:20:48 <nonefool> Cale: I will try to understand it in a few minutes, I'm occupied with some other stuff atm
07:23:35 <Cale> nonefool: This also explains why it behaves identically without the instance of Super for Fam Float. It's not actually using it at all!
07:24:30 * hackagebot arithmoi 0.4.0.2 - Efficient basic number-theoretic functions.  Primes, powers, integer logarithms.  http://hackage.haskell.org/package/arithmoi-0.4.0.2 (DanielFischer)
07:24:57 <Cale> Instead, it's using the instance of Super which is guaranteed by the instance of Duper, which is guaranteed by the instance of Foo which is supposed to be provided.
07:25:28 <navaati> absence: also an updated version of the netwire version which may be more in the spirit of netwire
07:25:32 <hpaste> navaati pasted “gloss netwire” at http://hpaste.org/68778
07:25:46 <Cale> Anyone else here have a look at this?
07:27:57 <nonefool> Cale: I see
07:28:45 <nonefool> should a bug report be created? will you do that?
07:29:56 <Cale> Well, I'm not sure what the correct behaviour here is, but it might be good to post this on the Haskell or Haskell-cafe mailing list and see what other people think. There are people much better versed in how these things interact than I am there.
07:30:27 <bitonic> Cale: what are we talking about here?
07:30:32 <bitonic> oh, this http://hpaste.org/68774
07:30:44 <Cale> yes
07:32:43 <bitonic> aha, interesting
07:34:03 <Cale> Hand-compiling also explains why it doesn't loop when you replace the superclass constraint on Foo to require Super (Fam a) instead of Duper (Fam a). It allows (and forces) it to use the specific instance of Super for Fam Float, rather than one obtained by looking inside the instance of Duper
07:34:42 <Cale> (which because it is dependent on the instance for Foo again, creates a loop)
07:35:57 <Cale> This is confusing, but I'm not sure whether or not to consider it an outright bug.
07:36:34 <Cale> Once you try to do the compiler's job here, it becomes obvious why it has done the only thing that it could have with what you've given it.
07:37:19 <Cale> However, there might be some sort of way that we could catch this and present an error or warning to the user.
07:41:44 <nonefool> Cale: well, I surely hope that's possible; it took me quite some time to figure out why even the simplest method in my generated class suddenly started looping (I totally forgot about changing the Super constraint to Duper the last time I looked at the code, which was a few weeks back)
07:49:08 <mcstar> is the ghc-core 'case ... of' different from the haskell one?
07:49:16 <rwbarton> yes
07:49:34 <mcstar> you can assign the evaluated expression to a name?
07:49:37 <rwbarton> it always evaluates to WHNF
07:49:55 <mcstar> case f x of y
07:49:59 <mcstar> a ->
07:50:01 <mcstar> b ->
07:50:08 <mcstar> i see this on a slide
07:50:24 <mcstar> as if y were bound to f x
07:51:58 <armlesshobo> mcstar: it is the result of f x
07:52:05 <armlesshobo> what it maps to
07:52:10 <armlesshobo> f: x -> y
07:52:13 <mcstar> thats what i thought
07:52:21 <armlesshobo> and you can have multiple cases
07:52:24 <mcstar> so this is sytactically different from haskell's
07:52:32 <mcstar> n
07:53:38 <mcstar> you can simulate this by using as-patterns in the cases
07:54:01 <armlesshobo> i'm not familiar with the core language, :\
07:57:21 <covi> instance Applicative (Either a) where pure x = Right x Right f <*> Right x = Right (f x)
07:57:29 <covi> ...
07:57:31 <ClaudiusMaximus> i have a module with a few variants of functions that can be used as implementations of class methods; now I want to use TemplateHaskell to generate instances to avoid excessive boilerplate - any nice example of this kind of thing?
07:57:55 <covi> http://hpaste.org/68779 Guys, is this correct?
07:59:23 <armlesshobo> ClaudiusMaximus: http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/template-haskell.html
07:59:30 <armlesshobo> ClaudiusMaximus: I think this might help :)
08:02:00 <mm_freak> absence: yes
08:03:57 <ClaudiusMaximus> armlesshobo: no example there for what i want to do, sadly
08:04:02 <armlesshobo> :(
08:04:18 <ClaudiusMaximus> armlesshobo: but thanks for the link, there may be something in the references
08:04:18 <rwbarton> covi: so far so good but what about the Left cases?
08:04:19 <mauke> covi: incomplete
08:04:30 <armlesshobo> ClaudiusMaximus: np :)
08:04:41 <mcstar> haskell is pretty simple if you get down to it.... http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType
08:05:22 <covi> rwbarton: I don't know what to do with the Left case... it seems I should return a "Whatever" or "Nothing"...
08:05:25 <covi> mauke: ^
08:05:50 <covi> :t <*>
08:05:52 <lambdabot> parse error on input `<*>'
08:05:58 <covi> :t (<*>)
08:05:59 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
08:07:13 <covi> Maybe I don't understand the Either type at the first place.
08:09:25 <S11001001> covi: try constraining a with Monoid, and use Monoid's features to get where you're going
08:10:04 <S11001001> covi: or even better, Semigroup
08:10:31 <covi> S11001001: I haven't learned Monoid yet. Is it possible to define Either a as an instance of Applicative without more advanced knowledge?
08:11:41 <ski> covi : should be
08:11:57 <mauke> yes
08:12:20 <mauke> Monoid is simpler than Applicative, though
08:12:34 <mparodi_> why the type of the function "comp2 f g = \x y -> g (f x) (f y)" is "(t2 -> t1) -> (t1 -> t1 -> t) -> t2 -> t2 -> t"?
08:12:39 <mparodi_> I thought it was (t2 -> t1) -> (t1 -> t1 -> t) -> (t2 -> t2 -> t)
08:13:06 <ski> mparodi_ : those are the same. the type `foo -> bar -> baz' is the same as `foo -> (bar -> baz)'
08:13:07 <mparodi_> after all comp2 returns a function of type (t2 -> t2 -> t)
08:13:17 <mparodi_> ah, really?
08:13:20 <ski> yes
08:13:24 <mparodi_> how is that possible?
08:13:25 <mroman_> mparodi_: Currying.
08:13:26 <mcstar> instance Applicative forall a. => (Either a b) where ?
08:13:30 <mcstar> can this work?
08:13:54 <mparodi_> ok, I suppose it's somewhere in the remaining of the book, I'll continue reading. thanks guys
08:13:58 * mcstar is making fool of himself
08:14:20 <mroman_> mparodi_: Functions can consume one parameter and return a function doing the rest.
08:14:35 <mroman_> > 5+6
08:14:36 <lambdabot>   11
08:14:41 <mroman_> > (+) 5 6
08:14:42 <lambdabot>   11
08:14:42 <c_wraith> mcstar: You mean with a type-level lambda? haskell doesn't have those, due to the fact that they completely break type inference
08:14:50 <mroman_> > ((+) 5) 6
08:14:51 <lambdabot>   11
08:14:55 <mroman_> ^- like that
08:15:03 <mcstar> c_wraith: i was going for something like that, yeah
08:15:03 <mparodi_> O.o
08:15:46 <mroman_> @type ((+) 5)
08:15:46 <c_wraith> mcstar: It's a reasonable question, because it's a natural thing to want to do.. But the consequences of it are "it breaks a lot of nice properties that we don't really want to give up"
08:15:47 <ski> mparodi_ : if you have a function of type `[a] -> [a] -> [a]', then this is really the type `[a] -> ([a] -> [a])', meaning that the function really takes a single argument which is a list of `a's, and returns a new function which (when called) takes a single argument which is a list of `a's, and returns a list of `a's
08:15:47 <lambdabot> forall t. (Num t) => t -> t
08:16:02 <ski> > max 7 4
08:16:03 <lambdabot>   7
08:16:04 <ski> > (max 7) 4
08:16:05 <lambdabot>   7
08:16:12 <Mathnerd314> what's the precedence of (::)?
08:16:12 <ski> > map (max 7) [4,5,6,7,8,9]
08:16:13 <lambdabot>   [7,7,7,7,8,9]
08:16:20 <mroman_> (+) is t -> t -> t but (+) 5 "consumed" a t and returned (t -> t)
08:16:26 <c_wraith> Mathnerd314: it applies to the entire preceding expression
08:16:37 <covi> Oh my brian just explodes. I don't know how to continue to define Either a as an instance of Applicative. Can anyone help?
08:17:02 <Mathnerd314> c_wraith: so it's essentially -1?
08:17:12 <covi> My progress:http://hpaste.org/68779
08:17:12 <mparodi_> ski, mroman_, that makes sense now. thank you!
08:17:25 <c_wraith> Mathnerd314: yeah, I suppose that's an accurate viewpoint
08:18:30 <mparodi_> so basically ALL the functions receive just one param and return a function that consumes the rest. regardless how you define that function
08:18:32 <hpaste> ClaudiusMaximus pasted “forking Data.Complex” at http://hpaste.org/68780
08:18:53 <ClaudiusMaximus> ^^ anyone care to look at that API and comment on its sanity?
08:18:58 <mm_freak> mparodi_: in the same way f x y = (f x) y
08:19:05 <ski> mparodi_ : note that this means that *all* functions really take *exactly* one argument .. however if we have a function like e.g. `lookup :: Eq key => key -> [(key,value)] -> Maybe value', which takes a `key' and returns a function which takes a list of `key'-`value'-pairs, and returns a `Maybe' `value' -- then we usually expresses this in short as `lookup' taking *two* arguments, one `key' and one association list
08:19:12 <mm_freak> you pass the first argument…  the result is a function to which you pass the second argument
08:19:17 <ski> mparodi_ : exactly
08:19:41 <ski> mparodi_ : this is also why if there's no `->' in the type, then it's not a function (there's no "zero-argument functions")
08:20:29 <covi> :w
08:20:38 <mparodi_> what about "foo = 1"
08:20:43 <mparodi_> it doesn't take any argument, does it?
08:20:44 <mcstar> rwbarton: in covi's case, doest the left case just left unevaluated, like Nothing for maybe?
08:20:47 <ski> mparodi_ : however, note that in some cases, "how many arguments a function takes" (in the abbreviated sense) can be ambiguous (because of polymorphism)
08:20:54 <mm_freak> mparodi_: that's a constant
08:21:03 <ski> mparodi_ : have you seen `foldr' yet ? how many arguments would you say it takes ?
08:21:09 <mparodi_> yes, I did
08:21:22 <ski> (your `foo' there is a number)
08:21:23 <mm_freak> mparodi_: note, it's a constant (X), not a constant function (a -> X)
08:21:27 <mparodi_> it takes like 3 iirc
08:22:02 <mparodi_> I know it's a number but I thought it was internally a function that returns a number
08:22:26 <mparodi_> I mean, a "zero-argument function"
08:22:27 <mm_freak> mparodi_: haskell is about semantics…  don't worry about the internals
08:22:43 <mm_freak> internally it works /very/ different from what you would expect when you come from other languages
08:23:11 <mparodi_> I asked because of that comment ski said: there's no "zero-argument functions"
08:23:46 <mm_freak> mparodi_: the confusion about zero-argument "functions" comes from the fact that most programming languages abuse the term "function"
08:24:16 <mm_freak> what you define in those languages are in fact procedures, not functions
08:24:17 <ski> > foldr (\a s -> concat ["(",show a,"+",s,")"])) "42" [0,1,2,3]
08:24:18 <lambdabot>   <no location info>: parse error on input `)'
08:24:23 <ski> > foldr (\a s -> concat ["(",show a,"+",s,")"]) "42" [0,1,2,3]
08:24:24 <lambdabot>   "(0+(1+(2+(3+42))))"
08:24:27 <mm_freak> they can act like functions, but in general they are just grouped machine instructions
08:24:32 <ski> > foldr (\a s -> concat ["(",s,"+",show a,")"]) "42" [0,1,2,3]
08:24:32 <lambdabot>   "((((42+3)+2)+1)+0)"
08:24:35 <ski> > foldr (\a k s -> k (concat ["(",s,"+",show a,")"])) (\s -> s) [0,1,2,3] "42"
08:24:36 <lambdabot>   "((((42+0)+1)+2)+3)"
08:24:48 <ski> mparodi_ : how many arguments does `foldr' take in that last example ?
08:25:27 <mparodi_> 3 ?
08:25:54 <ski>   foldr (\a k s -> k (concat ["(",s,"+",show a,")"]))
08:25:57 <ski>         (\s -> s)
08:26:00 <ski>         [0,1,2,3]
08:26:01 <ski>         "42"
08:26:06 <mm_freak> mparodi_: ski's point is that in the presence of polymorphism the notion of "arity" becomes loose and practically useless
08:26:16 <mm_freak> 'id' can take as many arguments as you want it to take
08:26:19 <mm_freak> > id sin 3
08:26:20 <lambdabot>   0.1411200080598672
08:26:36 <ski> mparodi_ : not three, no
08:27:15 <ski> mparodi_ : in Haskell, a function is something that takes an argument. in some other languages functions are things which *delay* computation, and *possibly* takes some arguments
08:28:07 <ski> > let a = 1 `div` 0 in a + 2
08:28:08 <lambdabot>   *Exception: divide by zero
08:28:20 <ski> > let a = 1 `div` 0 in if 2 > 3 then a else 42
08:28:20 <lambdabot>   42
08:28:41 <ski> in Haskell, computations are delayed anyway (`a' above)
08:29:52 <ski> mparodi_ : re the `foldr' example, you know the type of it is `(a -> b -> b) -> b -> [a] -> b' -- now say that `a' here is `Int' and `b' is `String -> String'
08:30:36 <shashwat> Where exactly can I find the source code for Haskell ?  For example, I wanted to look at source of List's length.  I went here - http://darcs.haskell.org/haskell-prime/ and got lost.
08:30:39 <ski> mparodi_ : then the type of `foldr', in *this* specific instance, is `(Int -> (String -> String) -> (String -> String)) -> (String -> String) -> [Int] -> (String -> String)'
08:30:41 <mparodi_> so in conclusion. you can think of Haskell's functions as if they always takes just one argument and returns a function (this is repeated until all arguments are consumed), and foo = 1 is NOT a function
08:31:01 <ski> or, omitting some brackets, `(Int -> (String -> String) -> String -> String) -> (String -> String) -> [Int] -> String -> String'
08:31:16 <mcstar> covi: im confused about how to complete the instance definition :(
08:31:20 <ski> so you can see that the types of the arguments above are as
08:31:33 <armlesshobo> mcstar: which instance?
08:31:35 <mm_freak> shashwat: http://hackage.haskell.org/package/base
08:31:49 <shashwat> mm_freak:  thanks.
08:31:54 <mcstar> making Either a b an instance of applicative
08:32:07 <mcstar> well, Either a
08:32:11 <ski>     (\a k s -> k (concat ["(",s,"+",show a,")"])) :: Int -> (String -> String) -> String -> String
08:32:14 <mm_freak> mparodi_: simpler…  a function is something that can be applied to a value
08:32:16 <mm_freak> period
08:32:31 <ski>   (\s -> s) :: String -> String
08:32:48 <ski>   [0,1,2,3] :: [Int]
08:32:55 <ski>   "42" :: String
08:32:55 <mm_freak> the type is X -> Y, where X is the argument type and Y is the result type
08:33:06 <mm_freak> Y is allowed to be of that form as well
08:33:12 <mm_freak> so a function can return a function
08:33:19 <Botje> (.. or take a function)
08:33:37 <ski> mparodi_ : "so in conclusion. you can think of Haskell's functions as if ..." -- yes
08:33:57 <mm_freak> mparodi_: now take 'id' as an example:  its type is x -> x
08:34:00 <mm_freak> what if x = a -> b?
08:34:12 <mm_freak> then its type becomes (a -> b) -> (a -> b)
08:34:41 <mcstar> Left x <*> _ = Left x; _ <*> Left x = Left x? but this doesnt feel right
08:34:50 <mm_freak> because of currying you can always omit rightmost parentheses
08:35:02 <mm_freak> (a -> b) -> (a -> b) = (a -> b) -> a -> b
08:35:33 <Polarina> Where is "with" defined as shown in http://www.yesodweb.com/book/conduits#how-it-works-213 ?  All I am getting is a not in scope error wher I try to run that example.
08:35:38 <mm_freak> now 'b' can be a function type again, and this can go on without limit
08:35:54 <mm_freak> > id (+) 3 4
08:35:55 <lambdabot>   7
08:36:13 <Botje> mcstar: why not? both the function and the argument can be Left, only when they're both Right can you do something useful.
08:36:38 <tibbe> Polarina: perhaps the API changed?
08:36:54 <tibbe> Polarina: form the example it looks like it ought to be in Control.Monad.Trans.Resource
08:37:28 <mparodi_> that makes sense. thanks a lot!
08:37:32 <ski> mcstar : because of assymetry ?
08:37:38 <Polarina> tibbe, I am importing that. And I cannot find it in the haddock doumentation either. http://hackage.haskell.org/packages/archive/resourcet/0.3.2.1/doc/html/Control-Monad-Trans-Resource.html
08:37:43 <mcstar> somehow the types didnt match in my head
08:37:47 <mcstar> so is that correct?
08:37:59 <tibbe> Polarina: check older versions of the package, it might have gotten renamed or something
08:38:00 <Botje> yes.
08:38:03 <mcstar> yay
08:38:10 <Botje> mcstar: don't forget the Right-Right clause, of course.
08:38:17 <mcstar> Botje: thats in covi's paste
08:38:41 <ski> @type let Left e <*> _ = Left e; _ <*> Left e = Left e; Right f <*> Right a = Right (f a) in (<*>)
08:38:41 <covi> mcstar: you are too?
08:38:42 <lambdabot> forall t t1 b. Either t (t1 -> b) -> Either t t1 -> Either t b
08:38:55 <Botje> mcstar: ah, wasn't following.
08:39:34 <mcstar> covi: not anymore :)
08:39:41 <ski> mcstar : it can be nice to spell out the exact type signature of `(<*>)' in the instance you're writing
08:39:48 <tac-tics> Is there a categorical theoretical basis for Monad Transformers?
08:40:08 <Polarina> tibbe, thanks.
08:40:21 <covi> mcstar: http://hpaste.org/68781 Is this definition correct? (haven't been following you guys)
08:40:47 <ski> mcstar : the general type signature of `(<*>)' in `Applicative f' (sans the constraint coming from the class itself) is `(<*>) :: f (a -> b) -> f a -> f b'
08:41:15 <ski> mcstar : in your specific case, `f' is `Either e', so you get `(<*>) :: Either e (a -> b) -> Either e a -> Either e b'
08:41:25 <covi> ski: I assume your definition is the same as this? (http://hpaste.org/68781)
08:41:37 <mellum> It seems many function in IntMap like delete or adjust do nothing if the key is not in the map. Is there some way to get an error instead?
08:41:44 <mcstar> ski: yeah, i get that
08:41:51 <ski> mcstar : so in your `Left x <*> _ = ...' as well as in `_ <*> Left x = ...', the `x' had type `e'
08:42:24 <ski> covi : basically, yes
08:42:41 <mcstar> i was following it in my head, and was worried that 'a' has disappeared when i was matching against Left (x :: b)
08:42:56 <covi> ski: ty
08:43:12 <covi> So basically we have to make use of convention here.
08:43:20 <ski> tac-tics : not that much -- it'd probably start with a functor between two monad categories
08:43:28 <ski> covi : hm, i'm not sure how you mean ..
08:43:29 <covi> The convention that 'Left x' is always an error
08:43:52 <mcstar> well, you make (Either a) an isntance of Applicative..
08:43:53 <covi> And if a computation involves an error, it returns the error
08:44:53 <covi> Let me manually check if the Applicative laws are followed..
08:45:18 <mcstar> covi: eat something before that, to have enough energy
08:45:27 <mcstar> XD
08:47:30 <mcstar> ski: i made an error in my comment, now i get why i was confused, a switched the types, Either a b = Left b | Right a , for some odd reason...
08:48:04 <mcstar> writing down things definitely helps
08:48:16 <Botje> mcstar: uhh?
08:48:23 <Botje> that's a weird error to make :)
08:50:09 <covi> :t ($ (+3))
08:50:10 <lambdabot> forall b a. (Num a) => ((a -> a) -> b) -> b
08:50:19 <mcstar> when i was learning to drive a car, i remember hearing: "No! the other left!"
08:50:20 <covi> $ (+3) 1
08:51:02 <geekosaur> .oO { now put your other left foot in }
08:51:07 <ski> mcstar : oh :)
08:51:33 <covi> I don't think the interchange law is followed...
08:51:42 <covi>     u <*> pure y = pure ($ y) <*> u
08:52:00 <ski> mcstar : in this context, i prefer to make `Either e' an instance of `Applicative', where `e' stands for "error" (or "exception") :)
08:52:16 <covi> Suppose u = Right x. Left hand side = Right (x y). Right hand side: Right (y x). Am I wrong?
08:52:19 <mcstar> good mnemonic
08:53:02 <rwbarton> covi, yes you are wrong
08:53:14 <ski> covi : your argument isn't well-typed
08:53:22 <rwbarton> for instance your computation does not even type check, but the law cannot fail to type check
08:53:54 <covi> I'm lost.
08:55:08 <covi> rwbarton: can you please explain further?
08:56:26 <rwbarton> if u = Right x so x :: a -> b and y :: b then how can you have Right (y x)
08:56:31 <rwbarton> you just pushed some symbols around wrong
09:00:46 <covi> rwbarton: But on rhs it has to be Right ($ y x), right?
09:07:55 <rwbarton> Right (($ y) x)
09:08:56 <armlesshobo> what's the "<-" operator?
09:09:21 <rwbarton> it's not an operator
09:09:34 <rwbarton> it is special syntax used in do notation and a few other places
09:09:53 <armlesshobo> hmmm
09:09:56 <armlesshobo> what does it imply?
09:10:03 <rwbarton> well where are you encountering it?
09:10:21 <armlesshobo> in the one example, I see "h <- openFile "foo.txt" ReadMode"
09:10:44 <rwbarton> okay, that is part of do notation
09:10:48 <rwbarton> by the looks of it
09:10:51 <`Jake`> This seems to be one of those questions which have been asked a 100 times already, but does anyone know why realworldhaskell is down?
09:11:15 <armlesshobo> rwbarton: would that be the same as h = do openFile "foo.txt" ReadMode
09:11:15 <armlesshobo> ?
09:11:32 <rwbarton> no
09:11:41 <ski> we need to see the context around that given line
09:11:58 <rwbarton> roughly speaking, do notation is a way to build up larger actions out of smaller actions
09:12:01 <rwbarton> in this case, IO actions
09:12:39 <rwbarton> "h <- openFile "foo.txt" ReadMode" means one of the actions is openFile "foo.txt" ReadMode, and then the result of that action (a Handle) can be referred to as h in the rest of the do block
09:13:01 <rwbarton> "h = do openFile "foo.txt" ReadMode" means h *is* the action of opening the file, which is completely different
09:13:16 <rwbarton> it would probably be clearer to explain this in the context of more code, yes
09:13:38 <armlesshobo> rwbarton: i mean, i got it from a tutorial on how to do file IO
09:14:04 <eikke> fwiw, I had some fun comparing compilers and compiler backends on a simple computational example today: https://gist.github.com/b783d33fb7eb1753dcfe
09:16:14 <rwbarton> the important thing to realize is that when you pass openFile a path and a mode, the return value is not a Handle
09:16:38 <rwbarton> it is an action that, when executed, produces a Handle
09:16:58 <rwbarton> if you write "h = do openFile "foo.txt" ReadMode" that means anywhere you see h, you can replace it by openFile "foo.txt" ReadMode
09:17:35 <armlesshobo> but how is it so different from using '=' and "<-"?
09:17:43 <rwbarton> how is what so different
09:17:50 <rwbarton> how are those two different from each other?
09:17:50 <armlesshobo> well
09:18:00 <armlesshobo> yes, how are the returned types different?
09:18:08 <geekosaur> ...what is the "do" supposed to be doing there?
09:18:24 <rwbarton> it doesn't do anything of course
09:18:27 <rwbarton> maybe I should have mentioned that
09:18:30 <geekosaur> ..never mind, I'll just confuse them
09:18:44 <rwbarton> I just copied it from the question
09:18:45 <ski> in `h = do openFile "foo.txt" ReadMode', the type of `h' is `IO Handle'
09:19:07 <eikke> rwbarton: at runtime you'd create multiple FDs of course, when doing this replacing, right?
09:19:23 <ski> in a `do'-block containing `h <- openFile "foo.txt" ReadMode', after that line (inside the block) `h' will have type `Handle'
09:19:39 <ski> armlesshobo : ok ?
09:20:25 <rwbarton> eikke, assuming that the program was one that actually compiled, and executed the action h in the places where it occurred, yes :)
09:21:06 <rwbarton> each time the action openFile "foo.txt" ReadMode is executed it would open a new file descriptor
09:22:02 <rwbarton> however, if you wrote "let h = openFile "foo.txt" ReadMode", and then tried to do "hGetLine h" etc., you would just get a compile error
09:22:11 <eikke> sure
09:22:17 <armlesshobo> type mistmatch
09:22:19 <armlesshobo> mismatch*
09:22:24 <ski> yep
09:22:30 <armlesshobo> but what's so special about <-?
09:22:35 <ski> it's just sugar
09:22:36 <armlesshobo> i don't think I understand it
09:22:36 <armlesshobo> lol
09:23:01 <ski> @undo do h <- openFile "foo.txt" ReadMode; foo h
09:23:01 <lambdabot> openFile "foo.txt" ReadMode >>= \ h -> foo h
09:23:16 <ski> `<-' here desugars to a call to `(>>=)'
09:23:21 <armlesshobo> ahhh
09:23:28 <armlesshobo> I don't know what >>= is lol
09:23:29 <armlesshobo> or means
09:23:34 <eikke> `bind`
09:23:40 <ski>   (>>=) :: IO a -> (a -> IO b) -> IO b
09:23:52 <ski> it combines two actions into a larger action
09:23:56 <ski> it's simpler to first look at
09:24:03 <ski>   (>>) :: IO a -> IO b -> IO b
09:24:08 <ski> we can say
09:24:22 <eikke> shameless plug: http://blog.incubaid.com/2012/04/02/tracking-asynchronous-io-using-type-systems/
09:24:28 <ski>   main = putStr "Goodbye " >> putStrLn "World"
09:24:36 <eikke> armlesshobo: ^^ there I explain >>= and others step-by-step
09:24:50 <ski> `putStr "Goodbye "' and `putStrLn "World"' are two `IO'-actions
09:24:53 <eikke> it's not using haskell, but might clarify things
09:25:00 <ski> specifically both have type `IO ()' in this case
09:25:56 <ski> in general, `foo >> bar' is an action that, *when* executed, will first execute `foo' (ignoring its result), and then execute `bar' (yielding its result as the result of the execution of the whole `foo >> bar' action)
09:26:04 <ski> armlesshobo : ok ?
09:26:16 <armlesshobo> ski: so far, so good
09:26:39 <ski> now, often we want to decide what to do later *depending* on the result we got from some previous `IO'-action
09:27:05 <ski> e.g. we might want to read an input line, then if it's empty, do one thing, and if it's not empty, do another thing
09:27:13 <ski> this is what `(>>=)' is for
09:27:18 <ski> compare
09:27:27 <ski>   (>>) :: IO a -> IO b -> IO b
09:27:29 <ski> with
09:27:30 <ski>   (>>=) :: IO a -> (a -> IO b) -> IO b
09:27:35 <eikke> m >> k == m >>= \_ -> k
09:27:58 <ski> in the latter case, the second (right) argument is actually a *function* that will be given the result of the left argument, before deciding what action to take
09:28:03 <ski> so, using this, we can write
09:28:54 <ski>   main = getLine >>= \name -> if null name then putStrLn "Goodbye" else putStrLn ("Hi " ++ name)
09:29:13 <ski> the first argument to `(>>=)' here is `getLine', which has type `IO String'
09:29:35 <ski> the second argument is `\name -> ..name..', it has type `String -> IO ()'
09:29:44 <ski> so `name' is a `String' (the line just read)
09:30:41 <armlesshobo> ski: ahhh ok
09:30:44 <ski> then `..name..' here is the action `if null name then putStrLn "Goodbye" else putStrLn ("Hi " ++ name)', so it can inspect whether `name' is the empty string before deciding to "be" the `putStrLn "Goodbye"' action, or the `putStrLn ("Hi " ++ name)' action
09:31:22 <ski> now, the `do' and `<-' notation is just a handy way of doing this with nicer syntax
09:31:26 <ski> instead of writing
09:31:35 <ski>   main = getLine >>= \name ->
09:31:42 <ski>          if null name
09:31:47 <ski>            then putStrLn "Goodbye"
09:31:50 <ski>            else putStrLn ("Hi " ++ name)
09:31:53 <ski> we can write
09:32:01 <ski>   main = do name <- getLine
09:32:07 <ski>             if null name
09:32:09 <ski>               then putStrLn "Goodbye"
09:32:12 <ski>               else putStrLn ("Hi " ++ name)
09:32:31 <armlesshobo> ski: i understand now. wonderful explanation
09:32:32 <armlesshobo> :)
09:32:40 <ski> yw :)
09:32:42 * ski bows
09:32:55 <ski> you can also write like
09:32:57 <ski>   do foo
09:33:01 <ski>      bar
09:33:03 <ski>      baz
09:33:13 <ski> this is basically the same as
09:33:16 <ski>   do _ <- foo
09:33:21 <monochrom> "do foo" has a nice ring to it :)
09:33:21 <ski>      _ <- bar
09:33:24 <ski>      baz
09:33:34 <ski> @undo do foo; bar; baz
09:33:34 <lambdabot> foo >> bar >> baz
09:33:34 <jfischoff> is there an easy way to track down the cause of a <<loop>>
09:33:40 <ski> @undo do _ <- foo; _ <- bar; baz
09:33:40 <lambdabot> foo >>= \ _ -> bar >>= \ _ -> baz
09:33:58 <ski> so you may note that `bar >> baz' is basically the same as `bar >>= \_ -> baz'
09:34:02 <armlesshobo> ski: so, let b = openFile "foo.txt" ReadMode, would store the action in b
09:34:08 <armlesshobo> and you could then do h <- b
09:34:09 <ski> yes
09:34:11 <armlesshobo> to get the handle
09:34:11 <ski> yes
09:34:35 <ski> so
09:34:42 * armlesshobo celebrates. Woo!
09:34:47 <ski>   let b = openFile "foo.txt" ReadMode in
09:34:52 <ski>   do h <- b
09:34:56 <ski>      h1 <- b
09:35:00 <ski>      ..h..h1..
09:35:02 <ski> is the same as
09:35:14 <ski>   do h <- openFile "foo.txt" ReadMode
09:35:18 <ski>      h1 <- openFile "foo.txt" ReadMode
09:35:19 <ski>      ..h..h1..
09:35:34 <armlesshobo> yes
09:35:35 <armlesshobo> got it
09:35:42 <ski> because `b' here is *equal* to `openFile "foo.txt" ReadMode' (they are the same action)
09:35:47 <armlesshobo> now, is there a naming convention for these kinds of identifies?
09:35:52 <armlesshobo> identifiers*
09:35:54 <ski> which ?
09:36:05 <ski> the `b' above ?
09:36:13 <armlesshobo> yeah
09:36:17 <armlesshobo> and/or h
09:36:33 <ski> well, `h' is often used for things of type `Handle'
09:36:37 <armlesshobo> like, how we have hungarian notation, is there something special for haskell?
09:36:45 <armlesshobo> or do we just use hungarian notation?
09:36:49 <eikke> yes
09:36:53 <ski> it's not *that* common to name actions like `b' above (but it happens)
09:36:56 <eikke> hLogFile and iAge
09:36:58 <armlesshobo> right
09:36:58 <armlesshobo> lol
09:38:45 <ski> i suppose one could also call it `myHandle' or `fileHandle' or something like that, if you want to be more verbose/clear
09:40:09 <monochrom> hungarian notation is uncommon among haskellers. I have never seen an instance, actually. note that "hGetLine" is not an instance of hungarian notation.
09:40:20 <armlesshobo> right
09:40:37 <armlesshobo> it's "hungarian notation-esque"
09:40:40 <armlesshobo> lol
09:41:06 * ski can't recall exactly what hungarian notation is
09:41:20 <geekosaur> tagging variables with their types as prefixes
09:41:26 <armlesshobo> yes
09:41:29 <armlesshobo> f -> float
09:41:32 <armlesshobo> fn -> function
09:41:36 <eikke> or, even worse, their type as well as their scope
09:41:36 <armlesshobo> i -> int
09:41:38 <armlesshobo> etc
09:41:39 <armlesshobo> m
09:41:42 <armlesshobo> g
09:41:43 <geekosaur> like pszFoo for a pointer toa null terminated string Foo
09:41:48 <eikke> s/scope/protection level/
09:41:50 <armlesshobo> m for modular
09:41:54 <monochrom> for example, id in hungarian notation is forall_a_a_to_a_id
09:41:55 <armlesshobo> global
09:41:57 <ski> geekosaur : their language types, or their conceptual (problem domain) types ? or maybe their *roles* ?
09:41:58 <armlesshobo> g -> global
09:42:26 <geekosaur> ski, language types in my experience.  I imagine they might have been intended otherwise
09:43:18 <armlesshobo> gpszFoo -> a global pointer to a null-terminated string
09:43:40 <ski> global extent or global scope ?
09:43:44 <armlesshobo> scope
09:43:55 <monochrom> in C, there is little difference
09:43:56 <jg> :t <*>
09:43:57 <lambdabot> parse error on input `<*>'
09:44:05 <jg> :t (<*>)
09:44:06 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
09:44:06 <ski> there's `static' inside of functions
09:44:11 <armlesshobo> m -> modular global, only global to that specific module
09:45:48 <armlesshobo> yeah, so I was just curious to see if haskell had it's own notation
09:45:50 <mcstar> it is funny, that in ocaml, camel-case identifiers are discouraged, they tell you to use _
09:46:03 <armlesshobo> opposite in C?
09:46:03 <armlesshobo> lol
09:47:09 <ski> hello again, jg
09:47:11 <jg> @pl \ ma -> (pure (flip ($)) <*> ma) <*> pure (flip ($))
09:47:11 <lambdabot> (<*> pure (flip id)) . (pure (flip id) <*>)
09:47:33 <dmwit> Yes, the intention was conceptual types, but it was corrupted almost immediately.
09:47:34 <ski> @type \ma -> (pure (flip ($)) <*> ma) <*> pure (flip ($))
09:47:35 <lambdabot> forall a (f :: * -> *) b. (Applicative f) => f a -> f ((a -> b) -> b)
09:47:47 <mcstar> ski: he is low on ram, he cant run irc and ghci at the same time
09:47:57 <armlesshobo> :O
09:48:09 <ski> @type fmap (\a -> ($ a))
09:48:10 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> f ((a -> b) -> b)
09:48:14 <ski> jg ^
09:48:59 <mcstar> btw, why arent these helper features incorporated into ghci?
09:49:07 <ski> which ?
09:49:16 <mcstar> this pl for example
09:49:17 <ski> oh `pl'
09:49:22 <monochrom> haha, we used to say that of emacs. "he is low on ram, can't run irc and emacs at the same time". punchline: "so he runs irc inside emacs"
09:49:28 <ski> i think it's available in some package thing
09:49:44 <mcstar> monochrom: Emacs Makes a Computer Slow?
09:50:04 <geekosaur> mcstar, it used to be possible to hook those into ghci, but I don't think it's been maintained
09:50:05 * ski . o O ( eighty megs and constantly swapping )
09:50:21 <geekosaur> inflation.  used to be "eight megs"
09:50:29 <monochrom> 80MB used to be a big deal
09:50:36 <mcstar> geekosaur: seems at least important a feature in ghci as in #haskell
09:50:42 * ski has a hard disk which is 80MB
09:50:49 <jg> @pl (\ f -> f (flip ($))) . (.) . flip ($)
09:50:49 <lambdabot> id
09:51:16 * geekosaur once ported emacs to a machne running AT&T System III UNIX in 4MB.  the amazing thing is, it actually worked
09:51:28 <geekosaur> every other prcess got swapped out when I launched it, though...
09:51:38 <mcstar> geekosaur: that explains your name
09:51:41 <armlesshobo> geekosaur: LOL
09:51:46 <eikke> there's need for other processes when running emacs?
09:51:46 <armlesshobo> mcstar: LOL
09:51:58 <geekosaur> (mid-1980s.  yes, I use this nick for a reason...)
09:52:00 <armlesshobo> there is a need for an underlying OS when running emacs?
09:52:13 <eikke> ln emacs /bin/init
09:52:18 <dmwit> ?pl flip ($) . flip ($)
09:52:19 <lambdabot> flip id . flip id
09:52:19 <armlesshobo> lol
09:52:25 <dmwit> :t flip ($) . flip ($)
09:52:26 <lambdabot> forall b a b1. a -> (((a -> b1) -> b1) -> b) -> b
09:52:42 <stj> are there any exercises you would recommend? I need to build my intuition with functors, monads and stuff
09:52:54 <ski> @google typeclassopedia
09:53:01 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
09:53:01 <lambdabot> Title: Typeclassopedia - HaskellWiki
09:53:12 <ski> stj : tried those ^ ?
09:53:18 <eikke> hands down the best resource out there indeed
09:53:20 <stj> yes, I'm reading that, but I would like more exercises
09:54:57 * hackagebot unfoldable 0.6.0 - Class of data structures that can be unfolded.  http://hackage.haskell.org/package/unfoldable-0.6.0 (SjoerdVisscher)
09:56:08 <ski> stj : i think it's best to work through all the common monads
09:56:27 <Saizan> unfoldable sounds more like the class for structures that can't be folded
09:56:31 <stj> ski: all right, I will, thanks :)
09:56:35 <mcstar> Saizan: damn
09:56:50 <mcstar> Saizan: i was wrirting up a sentence about that, but deleted it
09:56:51 <ski> also pondering whether you can make your datatypes into functors, idioms, monads
09:57:53 <Saizan> mcstar: bad puns are not for everyone :)
09:57:53 <ski> stj : e.g. consider `data LeafTree a = Leaf a | Branch (LeafTree a) (LeafTree a)' -- can this be made into a functor ? a monad ? an idiom ?
09:58:41 <Eduard_Munteanu> It sounds like more like a Hollywood movie :P
09:58:45 <ski> stj : also consider `data RoseTree a = Node a [RoseTree a]' and `data NestTree a = Zero a | Succ (NestTree [a])'
09:58:51 <Eduard_Munteanu> s/like more/more/
09:59:39 <ski> stj : also consider how to write folds for these types
09:59:45 <stj> ski: makes sense, but I'm going for intuition that would allow me to model solutions in terms of monads, not just recognize them... I guess that just comes with experience then
09:59:54 <mcstar> Eduard_Munteanu: would you like some more like?
09:59:58 <ClaudiusMaximus> armlesshobo: i found what i was looking for here http://www.haskell.org/haskellwiki/Template_Haskell#Template_Haskell_tutorials_and_papers (first link)  - it turned out to be quite simple
10:00:21 <ski> stj : afaik, yes
10:00:24 <Eduard_Munteanu> I would like would.
10:03:24 <hpaste> dmwit pasted “how to prove ski's version is the same as jg's version” at http://hpaste.org/68785
10:04:15 <jfischoff> I'll ask again, what is a way to track down a <<loop>>?
10:04:28 <mcstar> hm, phantom types could be used to implement units of measurements
10:04:49 <dmwit> jfischoff: :trace?
10:05:00 <jfischoff> ugh
10:05:03 <jfischoff> yeah I guess so
10:05:32 <jfischoff> how does it know it is a loop?
10:06:06 <dmwit> When you enter a thunk, you mark it as entered but not yet evaluated.
10:06:19 <dmwit> Then, the next time you enter it, if it's marked, you know you're in a loop.
10:06:46 <jfischoff> ok
10:07:01 <EEVIAC> if Data.Text is text with proper encoding and all that, and Bytestrings are just sequences of bytes, then how is String encoded?
10:07:24 <Clint> inefficiently
10:07:30 <dmwit> The encoding details of Text and String are not visible.
10:08:02 <dmwit> It happens that Text is encoded using UTF-16, and in GHC String is encoded in UCS-32, but there is no way to detect or use this fact from client code.
10:08:38 <EEVIAC> hmm. but does Text have to be utf-16?
10:08:52 <EEVIAC> what about encodeUtf8 et al.
10:09:24 <dmwit> encodeUtf8 surely doesn't return a value of type Text.
10:09:30 <copumpkin> Text is abstract
10:09:33 <EEVIAC> oh i see
10:09:37 <copumpkin> it is UTF-16 but most people shouldn't care
10:10:35 <ski> dmwit :)
10:11:02 <dmwit> Also, apparently it's called UTF-32 or UCS-4, but never UCS-32.
10:11:08 <dmwit> UCS-32 would indeed be inefficient.
10:12:32 <dmwit> ?pl (.) ($ flip ($)) (flip ($)
10:12:32 <lambdabot> (line 1, column 27):
10:12:32 <lambdabot> unexpected end of input
10:12:32 <lambdabot> expecting variable, "(", operator or ")"
10:12:32 <mcstar> but it could hold the alphabets of the whole universe
10:12:37 <dmwit> ?pl (.) ($ flip ($)) (flip ($))
10:12:38 <lambdabot> flip id
10:12:44 <dmwit> yay
10:12:59 <navaati> mcstar: sure, there are already packages dealing with mesure units
10:13:03 <dmwit> So, if ?pl were just taught the five Applicative laws, it could have done that derivation by itself...
10:13:30 <navaati> Text can hold the alphabets of the whole universe, i think ?
10:13:58 <geekosaur> unicode has a lot of cruft in it, but it's not quite *that* complete
10:13:59 <mcstar> ucs-32 would indicate 32 bytes per character i recon
10:14:06 <dmwit> navaati: Text can hold the alphabets of the Earth. The joke is that 32 words ought to be enough even for alien languages...
10:14:36 <dmwit> bleh, 32 bytes yes
10:15:00 <Enigmagic> bits?
10:15:04 <dmwit> no, bytes
10:15:21 <dmwit> That's the mistake I made above that spawned this whole joke thread. =)
10:15:35 <mcstar> a mistake worth having
10:15:36 <Enigmagic> chinese only needs 32 bits and that seems sufficiently alien to me :^)
10:16:01 <navaati> aren't the whole 16 upper bits of UTF32 already reserved for alien languages ?
10:16:38 <dmwit> No, the largest codepoint uses rather a lot of bits.
10:16:39 <armlesshobo> lol
10:16:42 <dmwit> > maxBound :: Char
10:16:43 <lambdabot>   '\1114111'
10:16:51 <dmwit> > showHex 1114111 ""
10:16:52 <lambdabot>   "10ffff"
10:17:07 <danharaj> ?? team oldmen[3]
10:17:08 <lambdabot>  team oldmen[3]
10:17:16 <danharaj> oops
10:17:18 <danharaj> wrong channel
10:17:50 <dmwit> top 11 bits are free, though, I guess =)
10:18:54 <tgeeky> dmwit: that's fine, it's important for some bits to be free-range. That way we don't feel so bad about putting the other bits in tiny cages.
10:19:11 <dmwit> > (0xffff - 0x0010) * 0x10000
10:19:12 <lambdabot>   4293853184
10:20:01 <armlesshobo> > cos 0
10:20:01 <lambdabot>   1.0
10:20:04 <ClaudiusMaximus> oh dear..     Exotic predicate type not (yet) handled by Template Haskell $sTy $t
10:20:05 <armlesshobo> > cos 180
10:20:06 <lambdabot>   -0.5984600690578581
10:20:12 <armlesshobo> > cos 360
10:20:13 <lambdabot>   -0.2836910914865273
10:20:14 <dmwit> > cos (pi / 2)
10:20:15 <lambdabot>   6.123233995736766e-17
10:20:18 <dmwit> > cos pi
10:20:19 <lambdabot>   -1.0
10:20:23 <armlesshobo> it's in radians...
10:20:30 <dmwit> Degrees are stupid.
10:20:34 <armlesshobo> :|
10:20:40 * armlesshobo backs away slowly
10:20:43 <dmwit> No, really.
10:21:01 <gtmanfred> > cos 180°
10:21:02 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
10:21:02 <armlesshobo> dmwit: pshhh. whatev
10:21:23 <armlesshobo> > cos pi/23
10:21:24 <lambdabot>   -4.3478260869565216e-2
10:21:24 <t7> "Degrees are stupid" to some degree
10:21:30 <tgeeky> ClaudiusMaximus: that ghc panic?
10:21:34 * armlesshobo slaps his knee in laughter
10:21:38 <tgeeky> + "is that" .. "a"
10:21:46 <dmwit> > let (°) = \x -> pi * x / 180 in cos (180°)
10:21:47 <rwbarton> @let (x°) = x * pi / 180
10:21:48 <lambdabot>   -1.0
10:21:48 <lambdabot>   Parse error in pattern: x �
10:21:51 <c_wraith> degrees are fantastic for their purpose - navigation.
10:21:58 <ClaudiusMaximus> tgeeky: it's not a panic, just a template haskell compile error
10:22:01 <rwbarton> that was weird
10:22:15 <dmwit> The only nice thing about degrees is that they're divisible by a lot of things.
10:22:16 <rwbarton> also nice idea dmwit!
10:22:18 <c_wraith> Imagine saying "bring it .0217 starboard"
10:22:24 <armlesshobo> lol
10:22:36 <armlesshobo> bring it pi over 180 starboard
10:22:41 <armlesshobo> much better
10:22:42 <armlesshobo> lol
10:22:45 <geekosaur> degrees make sense from a mechanical engineering type of view, I think, but not from a mathematical one
10:23:06 <tgeeky> geekosaur: they make sense from a mathematical one. You're in the rationals, not in the (transcendental, because of pi) reals
10:23:08 <dmwit> c_wraith: "bring it a quarter turn starboard"
10:23:09 <armlesshobo> > pi / 180
10:23:10 <lambdabot>   1.7453292519943295e-2
10:23:16 <ClaudiusMaximus> tgeeky: i also find it strange that it wanted me to add UndecidableInstances (for something that i didn't think was undecidable at all) and then wanted me to add ConstraintKinds (wtf)
10:23:17 <tgeeky> geekosaur: they are just arbitrary
10:23:17 <arcatan> degrees of freedom
10:23:22 <shapr> armlesshobo: That's rad
10:23:26 <shapr> Totally rad dude.
10:23:35 <tgeeky> ClaudiusMaximus: cool!
10:23:39 <tgeeky> the constraint kinds part
10:23:41 <c_wraith> dmwit: that's a bit more than a standard course correction
10:23:44 <armlesshobo> shapr: well, if you look at it from that angle...
10:23:51 <armlesshobo> it is
10:23:52 <armlesshobo> lol
10:24:02 <ClaudiusMaximus> tgeeky: and then after adding ConstraintKinds it gave the "Exotic ..." error
10:24:18 * tgeeky gandalfs: You will not pun! <smash>
10:24:19 <ski> shapr : heh, do you know where that term "rad" comes from ?
10:24:23 <dmwit> c_wraith: "a tenth" is not harder to say than "36", and "a twelfth" is not harder to say than "30", etc.
10:24:39 * Eduard_Munteanu guesses... Rad Scorpions? :P
10:24:43 <c_wraith> dmwit: both of which are still much larger than standard course corrections.
10:24:45 <armlesshobo> lol
10:24:48 <shapr> ski: Radians, I hope :-)
10:25:01 <armlesshobo> Eduard_Munteanu: good guess :)
10:25:12 <dmwit> > 0.0217 * 180 / pi
10:25:13 <lambdabot>   1.2433184154338865
10:25:23 <ski> well .. the *other* "rad", i mean
10:25:24 <dmwit> > 0.0217 * pi / 180
10:25:25 <lambdabot>   3.787364476827695e-4
10:25:42 <dmwit> c_wraith: alright, 1% then =)
10:25:56 <ClaudiusMaximus> tgeeky: i just wanted to do something like [d| instance $(constraint) $(thing) => Foo ($(box) $(thing)) where ... |]
10:26:20 <c_wraith> dmwit: congratulations, you've just invented gradians :)
10:26:40 <dmwit> c_wraith: Yes, I agree: 360 is divisible by a lot of things. But that doesn't make it canonical or good in any real way.
10:26:52 <mee> ski: radical
10:27:06 <shachaf> 360 also ~ 365.
10:27:47 <tgeeky> dmwit: physics counterexample: electrons rotate 720 degrees before returing to the same angle, not 360! :o
10:27:55 <ski> mee : .. oh. i first interpred that as in math radicals :)
10:28:08 <shachaf> dmwit: Are you really suggesting "a tenth" and "a twelfth" instead of non-reciprocal units?
10:28:11 <mee> heh
10:28:38 <shachaf> The advantage of "30" and "36" is that you can say "33" or "31.58" or "114" and it's obviously what it is.
10:28:39 <tgeeky> I don't think we're propsing anything other than arbitraryness of the choice
10:28:47 <ski> perhaps dmwit likes egyptian fractions ..
10:28:52 <tgeeky> I do :O
10:28:58 <Eduard_Munteanu> ski: and what's the correct interpretation? :/
10:29:18 <ski> Eduard_Munteanu : dunno, ask shapr ?
10:29:24 <Eduard_Munteanu> @shapr
10:29:25 * lambdabot orders her trained monkeys to punch
10:29:36 <Eduard_Munteanu> @get-shapr
10:29:36 <dmwit> shachaf: I'm suggesting radians or 0-1ians.
10:29:36 <lambdabot> shapr!!
10:29:44 <dmwit> 0-360ians are ridiculous.
10:29:49 <shachaf> dmwit: Seems reasonable.
10:30:01 * hackagebot cereal-conduit 0.0.6.1 - Turn Data.Serialize Gets and Puts into Sources, Sinks, and Conduits  http://hackage.haskell.org/package/cereal-conduit-0.0.6.1 (MylesMaxfield)
10:30:04 <ski> Eduard_Munteanu : well, `@ask shapr ..' :)
10:30:20 <ski> dmwit : how about `0' to `400' ?
10:30:34 <dmwit> 400 is arguably even worse than 360, because it has fewer divisors.
10:30:43 <dmwit> It's just as arbitrary, and doesn't even have the one good property of 360.
10:30:48 <tgeeky> you can prove to yourself the absurdity by picking a large primer number to be that number
10:31:00 <shapr> ski: Correct interpretation of what?
10:31:05 * Eduard_Munteanu picks ω :P
10:31:14 <ski> shapr : i dunno, ask Eduard_Munteanu :)
10:31:14 <mparodi_> is there a way to define a lambda function without arguments? something like:               let foo x = \ -> x+z where z = 1         (for example, in JavaScript it would be: function foo(x) {var z = 1; return function() {return x+z}})
10:31:14 <tgeeky> then you'll realize that you effectively have 0-1ians, as dmwit suggested
10:31:22 * ski . o O ( <http://en.wikipedia.org/wiki/Gradian> )
10:31:34 <Eduard_Munteanu> Of 'radical' :)
10:32:13 <tgeeky> mparodi_: foo has arguments, and the lambda there has arguments that you never introduced (two of them, in fact)
10:32:18 <`Jake`> does anyone know why realworldhaskell is down?
10:32:38 <tgeeky> not two of them actually
10:33:05 <mparodi_> tgeeky, but you can do        let foo x = \ _ -> x+z where z = 1
10:33:06 <mparodi_> and it works
10:33:23 <ClaudiusMaximus> `Jake`: something about dns resolution, maybe search recent logs of this channel for a numeric ip address which i remember being pasted here in the last few days
10:33:34 <mparodi_> I mean, it's not what I want to do, it's just to avoid the syntax error
10:33:39 <dmwit> mparodi_: let foo x = let z = 1 in x
10:33:46 <dmwit> eh
10:33:48 <dmwit> mparodi_: let foo x = let z = 1 in x+z
10:33:52 <`Jake`> ClaudiusMaximus: thanks!
10:34:14 <tgeeky> @let foo x = let z = 1 in x+z
10:34:14 <lambdabot>  <local>:3:0:
10:34:15 <lambdabot>      Warning: Pattern match(es) are overlapped
10:34:15 <lambdabot>               In...
10:34:20 <tgeeky> > foo 3
10:34:21 <lambdabot>   4
10:34:22 <ski> mparodi_ : or `foo x = x+z where z = 1'
10:34:35 <tgeeky> @let foolet x = let z = 1 in x+z
10:34:36 <lambdabot>  Defined.
10:34:44 <dmwit> Yes, though the "where" version doesn't translate to lambdas. Which he seemed to want, sort of...?
10:34:48 <ski> mparodi_ : why do you want a "function without arguments" ?
10:35:04 <tgeeky> mparodi_: you can also introduce the z using a forall
10:35:25 <ski> tgeeky ?
10:35:41 <cebrian> Hi, I'm trying to create a Network.PortNumber data instance reading from the argument command
10:35:59 <cebrian> but since the Network modules doesn't export constructors http://hackage.haskell.org/packages/archive/network/2.2.1.7/doc/html/Network.html
10:35:59 <tgeeky> ski: isn't that right? you can use a forall to bring the variable into scope?
10:36:18 <cebrian> I can't create it, but the compiler is able to infer the type
10:36:19 <ski> tgeeky : yes, but there's no such quantifiers in Haskell expressions
10:36:26 <cebrian> just by writting
10:36:27 <ski> (in Mercury goals, there are, as in lambdaProlog)
10:36:30 <cebrian> port = 4093
10:36:33 <cebrian> for instance
10:36:41 <ski> tgeeky : you can use it in types, though. and in the specification of laws
10:36:41 <tgeeky> ski: right, you'd have to do this in the type signature, which makes this not a lambda anymore
10:36:43 <jfischoff> cebrian: try fromIntegral
10:36:46 <tgeeky> ski: right, that's what I meant
10:36:50 <tgeeky> in the type
10:36:50 <ski> which ? :)
10:36:53 <ski> ok
10:36:53 <mcstar> tgeeky: i started thinking about that electron, and im building up more questions than answers...
10:37:03 <tgeeky> mcstar: which electron?
10:37:03 <Eduard_Munteanu> cebrian: it's a Num instance, so 4093 should do
10:37:21 <ski> cebrian : does `fromIntegral' work ?
10:37:25 <tgeeky> mcstar: oh, you are one of: Amr or Roshan?
10:37:25 <dmwit> cebrian: It has a Num instance, so you can use fromInteger to use a programmatically-determined port number.
10:37:28 <mcstar> any fermion in magentic field
10:37:40 <cebrian> jfischoff, Eduard_Munteanu,ski,dmwit yes
10:37:47 <cebrian> it was fromIntegral
10:37:50 <cebrian> thanks!!!
10:37:58 <tgeeky> perhaps not
10:38:24 <dmwit> tgeeky: You mentioned a few minutes ago that electrons rotate 4pi radians.
10:38:25 <Eduard_Munteanu> Shouldn't it work without fromIntrgeal?
10:38:26 <mcstar> tgeeky: i was thinking about the implication of the spinor quality on the spin-angular momentum coupling
10:38:34 <tgeeky> dmwit: ohh. right.
10:38:40 <c_wraith> dmwit: isn't that Num instance broken?
10:38:42 <mparodi_> <ski> mparodi_ : why do you want a "function without arguments" ? <-- I don't need a function without arguments right now, I'm just trying to see if it's possible as in other languages
10:38:53 <ski> Eduard_Munteanu : not if cebrian wants to get a number at run-time, and convert to a `PortNumber'
10:39:04 <Eduard_Munteanu> Oh.
10:39:19 <rwbarton> depending on your point of view, a "function of zero arguments" either isn't a thing that exists, or it is just the same as the value that it "returns" (when applied to those zero arguments)
10:39:21 <ski> mparodi_ : it is not possible
10:39:32 <ski> mparodi_ : every function in Haskell takes exactly one argument, by definition
10:39:34 <mparodi_> given the definition of foo I gave you in JS, you can do var bar = foo(5); and then bar() == 6
10:39:38 <dmwit> c_wraith: broken in what sense?
10:39:46 <mparodi_> ski, alright
10:39:58 <ski> mparodi_ : if you want to, you can make a function which takes a zero-tuple as argument
10:39:59 <Eduard_Munteanu> mparodi_: you can think of stuff like f :: IO Something
10:40:04 <dmwit> mparodi_: The JS function you wrote doesn't have no arguments.
10:40:13 <dmwit> mparodi_: So your understanding is incorrect.
10:40:19 <dmwit> (And your question, too, as a result.)
10:40:29 <rwbarton> it sort of looks like bar has no arguments...?
10:40:30 <tgeeky> mcstar: did you find your way to Möbius inversion in those questions?
10:40:47 <c_wraith> dmwit: oh, no, it's not.  It's the PortNumber constructor that is confusing. (It doesn't to a htons call on its argument.)
10:40:47 <ski> mparodi_ : `function foo(x,y) {..x..y..}' sortof corresponds to `foo (x,y) = ..x..y..' in Haskell, where `(x,y)' is a single argument, a two-tuple containing two parts
10:41:03 <mcstar> tgeeky: should have had I?
10:41:07 <dmwit> Well...
10:41:11 <ski> mparodi_ : so you can say `foo x = fun where z = 1; fun () = x + z'
10:41:14 <tgeeky> mcstar: no, but it does seem like it to me
10:41:26 <ski> mparodi_ : or `foo x = \() -> x + z where z = 1', which is the same thing
10:41:47 <dmwit> Okay, then it's a tossup what you mean by no arguments. I would call a declaration like fun foo() { ... } a function of one (unit) argument...
10:41:56 <dmwit> ?faq Can Haskell do that?
10:41:57 <lambdabot> The answer is: Yes! Haskell can do that.
10:41:58 <dmwit> =P
10:42:01 <mcstar> tgeeky: i just cant figure out, how does this fact affect spin and angular eigenstates
10:42:11 <dmwit> > let bar() = 6 in bar()
10:42:12 <lambdabot>   6
10:42:18 <tgeeky> mcstar: it's worth keeping in mind that the discovery that the electron has a spinor quality, was figured out much earlier than the fact of chirality.
10:42:19 <mcstar> like their basis functions cant be independent of one another
10:42:50 <mparodi_> ok, I won't use it anyway, don't worry :P
10:43:07 <dmwit> dmwit-- for chiding mparodi_ for dmwit's mistake
10:43:12 <ski> dmwit : yeah, but since we can't (directly) call `foo' on an "argument-list", this isn't first-class, so it's not completely correct to say that it's a single tuple argument
10:43:14 <mcstar> tgeeky: what do you mean? chirality? of what?
10:43:37 <mcstar> chirality just means non-invariance wrt mirroring
10:44:01 * ski wonders whether you can `karma-' yourself
10:44:16 <dmwit> no =/
10:44:17 <tgeeky> mcstar: right. There are four electron states, not two: [e+,e-] -> [e_left+,e_right+,e_left-,e_left-]
10:44:55 <mcstar> tgeeky: you just phrased it like, ppl didnt know chirality existed before they knew spinors
10:45:16 <dmwit> I think he just meant they didn't know *electrons* had chirality before they knew electrons had spinor qualities.
10:45:21 <tgeeky> yes.
10:45:53 <mcstar> you need it to treat relativisting non integer spin particles
10:46:00 <mcstar> tic*
10:46:29 <tgeeky> mcstar: this is for #haskell-blah
10:46:36 <tgeeky> mcstar: please join if you wish to continue. I'll be afk for a few.
10:46:36 <mcstar> though it is crazy that special relativity has some crazy non relativistic implications
10:46:42 <mcstar> ah k
10:46:44 <mcstar> sorry
10:47:03 <osa1> so I've just read the term "the least fixed point of a monotonic recursive definition" in a paper and I need to understand it. I have basic knowledge of lambda calculus. where should I start?
10:47:23 <Philippa> ski: most bots'll take it off you instead, assuming yourself=same nick
10:48:13 <ski> Philippa : hm, i thought that was what i was asking for ?
10:48:13 <Eduard_Munteanu> osa1: fixed point combinators and perhaps some denotational semantics (though mostly definedness)
10:48:23 <dmwit> osa1: Wikipedia. =)
10:48:26 <Eduard_Munteanu> osa1: but what are you having difficulties with?
10:49:10 <dmwit> osa1: Then you'll want to learn about the standard ordering they're probably talking about when they say "monotonic" and "least"; for that one, look up ... Scott domains? I think?
10:49:12 <osa1> Eduard_Munteanu: actually I already know fixed-points and Y combinators and I read a wikibooks page about haskell's fix but I don't think I get it.
10:49:39 <rwbarton> did you read http://en.wikibooks.org/wiki/Haskell/Denotational_semantics ?
10:49:47 <osa1> rwbarton: nope, thanks.
10:49:51 <dmwit> osa1: It's a defined-ness ordering, basically: values with "holes" for an undefined element. Values where the holes are deeper are bigger.
10:50:27 <dmwit> (so the least value of all is completely undefined)
10:50:57 <osa1> ok so I'll go through wikibooks page about denotattional semantics and return to you after that
10:50:57 <dmwit> (...and monotonic means "more-defined inputs don't magically make the output less-defined")
10:51:20 <ski>   _|_  =[  _|_ : _|_  =[  _|_ : _|_ : _|_  =[  _|_ : _|_ : []  =[  _|_ : 0 : []  =[  1 : 0 : []
10:51:23 <ski> e.g.
10:51:31 <monochrom> heh =[
10:51:36 <ski> `x =[ y' means `x' is less defined than `y'
10:51:56 <monochrom> ⊑ on a better keyboard :)
10:52:00 <ski> (well, "less or equally defined")
10:52:08 <dmwit> and neither 0 : _|_ =[ 1 : _|_ nor 1 : _|_ =[ 0 : _1_
10:52:19 <monochrom> "=[" ⊑ "⊑" :)
10:52:23 * ski doesn't have that sign on this keyboard
10:52:25 <Eduard_Munteanu> osa1: this might also come in handy, at least the first part: http://www.cl.cam.ac.uk/~gw104/dens.pdf
10:52:33 <osa1> Eduard_Munteanu: thanks
10:53:41 * tac-tics finds denotational semantics to be backwards :)
10:53:54 <tac-tics> Math should be given in terms of well-understood programming languages, not the other way around! xD
10:54:31 <ski> osa1 : for "monotonic", consider a "black box machine", that you tell some features of an argument, like "it's a non-empty list", "the tail is also non-empty", "the tail of the tail is empty", &c..
10:55:15 <ski> osa1 : then the machine spits out information about the result, like "it's a non-empty-list", "the tail is empty", "the head is the number three"
10:55:35 <dmwit> Most programming languages have a theorem that the definable functions are also monotonic. So it's not much of a constraint most of the time.
10:55:40 <ski> osa1 : then "monotonic" means that as you feed the machine more information, it can't retract information it has told you about the output
10:55:42 <monochrom> X should be given in terms of well-understood Y.
10:55:46 <ski> it can't "change its mind"
10:55:56 <monochrom> for some people, Y happens to be math
10:56:40 <csabahruska> hi
10:56:42 <csabahruska> I'd like to ask if is this code (ConstraintKinds) valid? http://pastebin.com/nnvi9tVP
10:56:44 <mauke> The paste nnvi9tVP has been copied to http://hpaste.org/68788
10:56:55 <dmwit> um. Most research languages have such a theorem, anyway. =)
10:56:57 <csabahruska> because GHC 7.4.1 gives this error message:  Not in scope: type constructor or class `Constraint'
10:57:00 <csabahruska> because GHC 7.4.1 gives this error message:  Not in scope: type constructor or class `Constraint'
10:57:11 <monochrom> import GHC.Exts
10:58:17 <jfischoff> dmwit: does that apply to logic programming?
10:58:30 <jfischoff> the theorem
10:59:03 <dmwit> Dunno! Open the paper on your favorite research logic programming language's denotational semantics and see if they prove it. ;-)
10:59:21 <ski> well, LP typically doesn't even support functions
10:59:24 <Eduard_Munteanu> I wonder if that's true for Haskell.
10:59:29 <Eduard_Munteanu> Sounds like it.
10:59:37 <jfischoff> dmwit:yeah…I still need to open prolog for dummies ;)
10:59:49 <ski> however, i think it's related to the Smyth (or is it Hoare ?) powerdomain partial order
11:00:11 <monochrom> casuality implies continuity; continuity implies monotonicity
11:00:30 * Eduard_Munteanu wonders if that's a typo or not :P
11:00:35 <monochrom> so, unless your language has non-causal constructs, it is monotonic, and more than monotonic
11:00:59 <Eduard_Munteanu> I'm casual, does that mean I'm monotonous? :P
11:01:11 <monochrom> I'm causal and monochromic!
11:01:26 <ski> "From Logic Programming to Prolog" by Krzysztof R. Apt at <http://homepages.cwi.nl/~apt/book.ps> maybe mentions such a theorem -- i'm not sure
11:03:19 <ski> or maybe "From Logic to Logic Programming" by Kees Doets at <http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=7244>
11:11:01 <t7> anyone seen this haste then?
11:11:04 <t7> looks cool
11:11:31 * ski . o O ( "Make Haste but Take Heed" )
11:12:21 <navaati> byorgey: all the geometry stuff (R2, Point, Angle, etc.) that you put in diagrams, there was no package already implementing it ?
11:14:46 <newsham> haste makes waste
11:17:01 <Diablo3> since #algorithms is silent:
11:17:03 <Diablo3>  Is there a name for a "maze"-heuristic that finds the goal by moving 1. east until obstacle is met then 2. south till obstacle is met and then 1 again and repeat until goal is met?
11:18:15 <shachaf> Doesn't sound like a very good heuristic.
11:18:32 <Diablo3> no but it isnt a maze
11:18:40 <Diablo3> and it always works for our game
11:18:45 <Diablo3> so just wondering
11:19:00 <shachaf> "Diablo3's game maze heuristic"
11:19:01 <sp3ctum> can someone access realworldhaskell.org?
11:19:06 <Draconx> Perhaps you could call it "dumb luck navigation"?
11:19:25 <Ptival> "let's hope it's southeast heuristic"
11:19:26 <ladr0n> sp3ctum: my friend said it was down yesterday
11:19:56 <ladr0n> sp3ctum: it's down for me currently too
11:20:43 <Saizan> i think it's common wisdom that always sticking to the same direction you'll eventually get out of a maze
11:21:14 <shachaf> Saizan: Is that the "1. go east until an obstacle is met; 2. goto 1" algorithm?
11:21:45 <Draconx> "1. go east until obstacle is met; 2; pass through obstacle; goto 1"
11:21:53 <sp3ctum> ok, ladr0n , thanks
11:22:03 <sp3ctum> maybe it'll come back up
11:22:09 <ladr0n> shachaf: Saizan described 1. go forward until an obstacle is met; 2. turn left; 3. goto 1
11:22:14 <shachaf> bos: Are you aware of this?
11:22:38 <ladr0n> anyway, doesn't that not work if there's a loop in the maze?
11:23:14 <shachaf> It doesn't work if the exit isn't on the perimeter of the maze.
11:23:28 <Saizan> shachaf: in practice it turns out to be "follow the wall on your right" (or left)
11:23:57 <shachaf> Saizan: Yes, I know. I was only misinterpreting your algorithm.
11:24:19 <Draconx> "sticking to the same direction" sounds quite different from "follow the wall on your right".
11:24:35 <tgeeky> wow. it looks like github is doing a whole windows push: http://windows.github.com/
11:24:43 <tgeeky> even adopting some of the windows UI elements
11:26:09 <ladr0n> as we all know, 90% of people use windows, therefore github had previously been missing out on 90% of their target market until now ;)
11:27:52 <tibbe> polux_: yt?
11:28:02 <t7> whats wrong with using just git
11:28:05 <t7> works fine for me
11:28:09 <tgeeky> ladr0n: well I've been developing on windows using github
11:28:29 <tgeeky> t7: that's like saying: what's wrong hands, I have bananas
11:28:41 <bos> shachaf: aware of what?
11:28:49 <shachaf> bos: realworldhaskell.org is down.
11:28:54 <tgeeky> you need hands (git) to use bananas (github)
11:29:01 <t7> why do we need window managers anyway
11:29:02 <alex404> Can anyone tell me why when I'm installing Chart-gtk via haskell cabal, it tries to build gtk, even though I've already installed gtk through arch linux? This wouldn't be a problem except that I can't seem to build gtk2hs either
11:29:28 <alex404> 'ghc-pkg list' lists gtk as being installed properly, but cabal still tries to build the Chart-gtk dependency
11:29:42 <tgeeky> t7: becuase baseball managers kept getting ejected
11:30:21 <t7> im not sure i like this windows 8 look
11:30:35 <tgeeky> me neither, though I haven't tried it yet. I don't particularly like it on github
11:33:18 <bos> shachaf: thanks for letting me know
11:37:28 <hpaste> robinhoode pasted “cabal problem” at http://hpaste.org/68789
11:38:51 <robinhoode> Anyone have this problem while installing Happstack? http://hpaste.org/68789
11:39:24 <alpounet> robinhoode, you should aks in #happs
11:39:39 <robinhoode> Ahh... wasn't aware it existed.
11:39:39 <polux_> tibbe: yes
11:39:41 <robinhoode> Thanks
11:39:58 <stepcut> robinhoode hack-handler-happstack is apparently very far out of date
11:40:00 <alex404> Might anyone know why when I try to install Chart-gtk it tries to rebuild gtk, even though I have gtk2hs installed.
11:40:11 <polux_> tibbe: sorry, didn't see your hilight
11:40:24 <stepcut> robinhoode: it's a  3rd party library and something that was never maintained by the happstack developers
11:40:49 <stepcut> you'll note that it depends on happstack 0.4. there have been 3 major releases since then
11:41:24 <robinhoode> Maybe just download the package itself and change the dependencies?
11:43:24 <geekosaur> alex404, no way for anyone here to guess without at minimum knowing what "ghc-pkg list" outputs on your system
11:44:56 <alex404> geekosaur: ghc-pkg list does display gtk-0.12.3
11:46:17 <geekosaur> 1) that may not be the only entry that matters; 2) I was trying to make a point... we cannot guess as to your system
11:46:30 <geekosaur> and you might not be able to guess as to what is relevant
11:47:06 <alex404> right, so what now? I'd be happy to answer any questions
11:47:12 <dmwit> t7: cabal can tell you
11:47:14 <dmwit> eh
11:47:18 <dmwit> alex404: cabal can tell you
11:47:27 <dmwit> alex404: cabal install Chart-gtk --constraint "gtk installed"
11:47:50 <dmwit> That should spew an error with some more information.
11:47:53 <alex404> Interesting. Here's what I got back: cabal: dependency expected
11:48:24 <alex404> I mentioned this before, but I did install gtk through the arch package (haskell-gtk) because I can't seem to build gtk directly via cabal
11:49:05 <dmwit> Your cabal-install may be too old for the "installed" constraint, in which case you should try
11:49:19 <dmwit> --constraint "gtk=x.y.z" where x.y.z. is from ghc-pkg list gtk
11:49:30 <mparodi> is there a standard function "replace" so that:      replace 1 'b' ['a', 'B', 'c']       returns      ['a', 'b', 'c']       ?
11:49:48 <dmwit> You may also want to double-check which package database gtk is installed to, and which package database you're trying to install Chart-gtk to.
11:49:49 <otters> how do I catch specifically a ThreadKilled exception?
11:49:58 <alex404> dmwit: Hmmm... I have the latest version of cabal-install though
11:50:06 <dmwit> mparodi: No, and it's likely you're doing something a bit fishy if you need it.
11:50:13 <dmwit> mparodi: However, there's splitAt, which gets you most of the way there.
11:50:18 * hackagebot storablevector 0.2.8.1 - Fast, packed, strict storable arrays with a list interface like ByteString  http://hackage.haskell.org/package/storablevector-0.2.8.1 (HenningThielemann)
11:50:21 <c_wraith> otters: limit the type of the argument to your handler function to ThreadKilled
11:50:30 <otters> ThreadKilled is an AsyncException
11:50:34 <stepcut> robinhoode: hack-handler-happstack already allows for the latest happstack.. it just doesn't compile because the API has changed. You would need to bring hack-handler-happstack up-to-date
11:50:56 <alex404> dmwit: Or scratch that, there's something fishy about my cabal install, so to say
11:51:00 <dmwit> alex404: cabal --version?
11:51:25 <alex404> dmwit: Yah, it was 0.10.2
11:51:29 <otters> and if I catch (..) (\(e :: AsyncException)) there can be a bunch of other types of async exceptions
11:51:40 <alex404> dmwit: But I would have assumed I'd have the latest version
11:51:46 <dmwit> otters: rethrow the exception if it's not the one you were hoping for
11:51:47 <alex404> dmwit: I'm just updating now
11:51:56 <otters> oh
11:51:57 <c_wraith> otters: oh. Then pattern match on it, and just use throwIO if it's not ThreadKilled
11:52:01 <otters> I see
11:52:25 <c_wraith> (use throwIO, not throw, if you're in an IO context like an exception handler)
11:52:37 <mparodi> dmwit, I'm doing an exercise in which you have a list of lists of '.' and a list of coordinates like [(1, 2), (3, 5)] so you have to change the '.' in these positions for a '#'
11:52:42 <mparodi> is it fishy? :P
11:52:58 <alex404> dmwit: Is the cabal-install package now called Cabal or something?
11:53:09 <dmwit> mparodi: Yes, complain to the guy who set the assignment. ;-)
11:53:23 <geekosaur> alex404, run "cabal --version" at a command line
11:53:34 <dmwit> alex404: There are two packages: Cabal and cabal-install.
11:53:35 <geekosaur> the Cabal library is not the cabal command
11:53:35 <mparodi> (The Craft of Functional Programming's author/s)
11:53:50 <ski> mparodi : i would define `(!!<-) :: Integral i => [a] -> i -> (a -> a) -> [a]'
11:54:32 <alex404> geekosaur: 0.10.2
11:54:56 <dmwit> mparodi: Anyway, lists are fine for pedagogical purposes because they are so simplistic; just be aware that when it comes time to write a real program, you should use a more suitable data structure.
11:55:37 <ski> mparodi : then you can say   (css !!<- y) $ \cs -> (cs !!<- x) $ \'.' -> '#'
11:55:45 <dmwit> alex404: Anyway, yes, you might consider running "cabal install --dry-run cabal-install", checking that it won't break anything, and then removing the "--dry-run".
11:55:58 <dmwit> Possibly with a "cabal update" stuck in first for good measure.
11:56:03 <ski> dmwit : lists can be fine for transmitting a data stream
11:56:04 <navaati> dmwit: however sometimes list are the right structure, aren't they ? (stack, loops, etc.)
11:56:14 <dmwit> Once you've updated cabal-install, --dry-run will be less important, because it will complain about breakage more loudly.
11:56:18 <Stalafin> This function definition from Learn You a Haskell, why does it need a '$' after the condition is passed to the filter? --- findKey key xs = snd . head . filter (\(k, v) -> key == k) $ xs
11:56:38 <dmwit> ski, navaati: Oh, certainly.
11:56:38 <rwbarton> because if not --- findKey key xs = snd . head . filter (\(k, v) -> key == k) xs
11:56:43 <alex404> dmwit: Will do. And fwiw" cabal install Chart-gtk --constraint "gtk-0.12.3" still returns: cabal: dependency expected
11:56:47 <rwbarton> this means  findKey key xs = snd . head . (filter (\(k, v) -> key == k) xs)
11:56:52 <dmwit> I just meant that indexing and lists don't really go together that well.
11:57:17 <Stalafin> rwbarton: and that would be wrong?
11:57:19 <ski> Stalafin : it doesn't, it could be written as  findKey key xs = (snd . head . filter (\(k, v) -> key == k)) xs  instead, or like
11:57:21 <rwbarton> but (filter (\(k, v) -> key == k) xs) is not a function, I cannot compose it with head
11:57:30 <dmwit> alex404: The syntax is --constraint gtk==0.12.3
11:57:30 <ski>   findKey key = snd . head . filter (\(k, v) -> key == k)
11:57:32 <rwbarton> and i do not want to produce a function anyways, in general it is all wrong
11:57:51 <geekosaur> Stalafin, compare:  (snd . head . filter (\(k, v) -> key == k)) xs   and:  snd . head . (filter (\(k, v) -> key == k) xs)
11:58:15 <Stalafin> Alright
11:58:24 <Stalafin> I understand, I guess.
11:58:26 <geekosaur> with the $ you get the former, without it the latter
11:58:31 <Stalafin> ski, rwbarton, geekosaur: thanks
11:59:18 <Stalafin> So basically, it first "composes" a new function, and then applies xs to it
11:59:32 <rwbarton> applies it to xs, rather, but yes
11:59:43 <alex404> dmwit: So it looks like actually cabal isn't detecting any of my dependencies. Whenever I try to install a package, it wants to install all the dependencies afresh. I tried to reinstall cabal-install because it complains about dependencies on base
11:59:46 <geekosaur> I would say that $ is inverted parentheses
11:59:48 <Stalafin> Because $ has such a low precedence
11:59:56 <gdoteof_> http://hpaste.org/68790
11:59:59 <rwbarton> yes
12:00:02 <monochrom> the syntax for --contraint is "gtk == 0.12.3" just like in *.cabal files
12:00:05 <gdoteof_> i am not sure why i have things out of scope in my where block
12:00:09 <rwbarton> everything to the left of $ is trouped
12:00:10 <rwbarton> *grouped
12:00:12 <alex404> dmwit: that should be, I tried to reinstall caba;-install but it complains...
12:00:31 <Stalafin> And what about left- and right-associativity? That is something that also confuses me.
12:00:33 <Taneb> If you have, say, xs :: Num a => [a], and do length xs, does Haskell choose a type for a,  or does it just calculate the list?
12:00:45 <gdoteof_> i grab some values from a monad (i think this is what is going on) and then refer to them in a where block, but they are showing up as out of scope
12:01:00 <Stalafin> So, why do you call '$' right-associative?
12:01:14 <Stalafin> And why is '.' left-associative?
12:01:22 <rwbarton> that becomes relevant when you write x $ y $ z
12:01:25 <rwbarton> or x . y . z
12:01:31 <rasfar> exp1 $ exp2 $ exp3 => exp1 (exp2 (exp3))
12:01:37 <ski> gdoteof_ : the equations after `where' only have access to the variables bound in the definiendum (and the other ones bound in the `where') -- use a `let' inside the `do', instead
12:02:12 <rwbarton> gdoteof_: the syntax is function args = expr where bindings
12:02:24 <rwbarton> so you can imagine that there are parentheses around the entire do-block
12:02:32 <monochrom> alex404: usually duplicate installs are caused by messed up suite of packages. see my http://www.vex.net/~trebla/haskell/sicp.xhtml for why cabal unilaterally decides to reinstall packages
12:02:35 <eikke> I have some old code using quickcheck, which has a property of signature [Word32] -> Word32 -> IO Bool
12:02:42 <eikke> I'm pretty suire this used to compile
12:02:53 <eikke> but doesnt anymore (maybe since now I'm on quickcheck 2)
12:02:59 <eikke> no instance Testable for "IO Bool"
12:03:02 <eikke> any help?
12:03:03 <rwbarton> (and, the where bindings are not inside the do block)
12:03:30 <alex404> monochrom: Cheers, I'm looking into it
12:04:14 <Stalafin> rasfar: so ... everything on the right is applied to everything on the left?
12:04:21 <pakaran> I notice that the real world haskell book's site is down
12:04:32 <pakaran> would anyone like to recommend another tutorial or free book?
12:04:46 <dmwit> alex404: What does ghc-pkg check say?
12:04:51 <pakaran> I'm a relatively experienced programmer...  phd candidate in comp sci...  looking to learn the language as a summer project
12:04:52 <monochrom> learnyouahaskell.com if you want the basics
12:05:19 <dmwit> ?where gentle
12:05:19 <lambdabot> http://www.haskell.org/tutorial/
12:05:26 <dmwit> ?where rwh
12:05:26 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
12:05:28 <alex404> dmwit: With regards to what? 'ghc-pkg list' seems to correctly list all the packages I've installed, whether through cabal or arch linux
12:05:29 <dmwit> ?where lyah
12:05:29 <lambdabot> http://www.learnyouahaskell.com/
12:05:42 <monochrom> "ghc-pkg check" does not detect all problems. in fact detects none of the problems described in my article
12:05:42 <dmwit> alex404: What does "ghc-pkg check" say?
12:05:43 <rasfar> Stalafin, do you mean on the right of "=>"? if so, "no". that is just meant as a translation symbol (translating the meaning of $)
12:05:43 <Stalafin> Learn You a Haskell is awesome :D
12:06:03 <hpaste> ski annotated “Handler/GamingSession.hs” with “scoping” at http://hpaste.org/68790#a68791
12:06:04 <gdoteof_> ski: rwbarton thanks
12:06:09 <ski> gdoteof_ ^
12:06:19 <alex404> dmwit: It only complains about Chart (which I would expect becuase I've been toying with it) and haddock for some reason
12:06:20 <Stalafin> rasfar: yeah, I meant.... a $ b $ c ---> c is applied to everything on the left (i.e. to a $ b)
12:06:43 <Philippa> hi pakaran - do you know which parts you need to learn how quickly?
12:06:50 <c_wraith> Stalafin: that's a bit backwards.. usually functions are applied to arguments, not the other way around
12:06:58 <pakaran> Philippa, long time!
12:07:03 <monochrom> to a large extent, "ghc-pkg check" is good only for the pretty trivial "did I accidentally delete some important files"
12:07:08 <Stalafin> c_wraith: yeah, you are right;
12:07:10 <rasfar> sorry, in that case (following the parenthetic translation), a $ b $ c is the same as "a" applied to "(b $ c)"
12:07:12 <pakaran> you were actually the one that suggested i get into haskell...
12:07:30 <Philippa> pakaran: Indeed! I should probably spend more time around at least some of the afp crowd again
12:07:35 <Philippa> *nod* now you mention it...
12:07:39 <alex404> monochrom: Do you have any idea why ghc-pkg list would list all packages correctly, but cabal doesn't seem to recognize them? I install everything globally, fwiw
12:07:42 <dmwit> monochrom: Not so: it's also good for the non-trivial "did I reinstall a dependency of thing X".
12:07:54 <pakaran> oh, and the rwh website is back up
12:07:57 <monochrom> well, of course, it doesn't hurt to try it first. but don't be relieved if it reports no error.
12:07:58 <pakaran> so i'll at least follow that
12:08:05 <rasfar> the application is still left-to-right !
12:08:05 <ski> ("afp" being "advanced functional programming" ?)
12:08:07 <pakaran> and if it makes sense to try things, i will
12:08:26 <rasfar> Stalafin, the application is still left (function) to right (argument)
12:08:56 <rasfar> only the grouping is affected by the associativity, not the direction of application
12:08:57 <Philippa> ski: heh, no
12:09:05 <dmwit> alex404: Paste a few dry-runs to hpaste.org.
12:09:07 <Philippa> pterry fandom
12:09:11 <monochrom> alex404, my article describes several such scenerios. see "corollary: pigeon drop con" for example
12:09:21 <dmwit> alex404: And read monochrom's article.
12:09:24 <ski> (there was such a course here which abbreviated to "AFP")
12:09:30 <monochrom> in all my scenerios, "ghc-pkg list" looks normal
12:09:31 <Philippa> ski: yeah, at UoN too
12:10:12 <pakaran> anyhow, though, honestly, my goal is to understand why people like haskell, and become more competent in using it, to the extent that it's the right tool for the job
12:10:24 <pakaran> (or, possibly, in cases where I can choose which tool to use, such as research work)
12:10:42 <pakaran> I don't think it's going to make a difference in my (very theoretical) phd, which i only have like a year left in in any case
12:10:49 <Philippa> *nod*
12:10:54 <Philippa> what's your PhD on, anyway?
12:11:07 <Philippa> (I'm still messing around with type inference, picked things up again a bit more recently)
12:11:08 <ski> pakaran : do you know any SML ? O'Caml ? Erlang ? Scheme ? Clean ? F# ?
12:11:11 <pakaran> complexity theory applied to public key crypto
12:11:17 <pakaran> getting into some work on interactive proofs
12:11:38 <monochrom> "ghc -v" contains a real check
12:11:44 <pakaran> ski, none of those.  scheme is the closest i come: had to do some common lisp for coursework a couple times
12:12:03 <Philippa> what are you using for proofs, out of interest?
12:12:16 <Philippa> (Agda vs Coq, round 1, fight!)
12:12:20 <pakaran> honestly, mostly, i'm frustrated at haskell not making sense to me, and want to prove to myself that i don't just have an entirely wrong thinking style
12:12:26 <Philippa> heh, fair enough
12:12:30 <pakaran> my proofs are presented in papers.
12:12:34 <dmwit> monochrom: Wait, what? Since the advent of hashes, won't ghc-pkg check complain about the pigeon-drop con?
12:12:36 <pakaran> when i said my research is very theoretical, i meant it
12:12:39 <pakaran> i use latex
12:12:39 <Philippa> tryhaskell.org might be a good place to start then
12:12:51 <ski> pakaran : well, it sounds like you just haven't learned any functional programming yet
12:12:55 <pakaran> (and it doesn't actually generate or check the proofs, which would make things much easier.)
12:12:55 <monochrom> dmwit: "reinstalled a dependency" counts as accidentally deleting some important files
12:13:06 <Philippa> eh, that's also common, it's just that "interactive" tends to leave me wondering what you're interacting with
12:13:21 <dmwit> monochrom: Does the pigeon-drop con count as one of your seconarios?
12:13:26 <ski> pakaran : learning a new programming paradigm, like the functional one, will, to some extent, be like learning to program all over again
12:13:36 <gdoteof_> if i have let minutes :: Int = someFunction;  and let pph :: Double = someOtherFunction
12:13:43 <dmwit> monochrom: "in all my scenerios, 'ghc-pkg list' looks normal"
12:13:48 <monochrom> "ghc-pkg check" has never checked for the pigeon-drop con. try it.
12:13:55 <dmwit> Oh, ghc-pkg list.
12:14:19 <gdoteof_> how can i do  let myfunc minutes pph = (minutes / 60) * pph
12:14:41 <monochrom> ho hrm, maybe it detects that
12:14:42 <ski> gdoteof_ : like that ?
12:14:43 <rwbarton> fromIntegral minutes
12:15:04 <dmwit> monochrom: Yes, I think it does.
12:15:06 <ski> hm, right
12:15:19 <pakaran> ski: yeah... at this point, i'm trying to figure out the purpose of "maybe".  It seems to be an attempt to avoid the use of null pointers, which every other language just implicitly allows in the type syste.
12:15:32 <gdoteof_> ah i was trying to do fromIntegral (minutes / 60 )
12:15:54 <pakaran> of course, those languages all also gain the ability to crash at runtime if they ever actually *do* anything with a null pointer...
12:16:18 <ski> @google billion dollar mistake null
12:16:20 <lambdabot> http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare
12:16:20 <lambdabot> Title: InfoQ: Null References: The Billion Dollar Mistake
12:16:22 <ski> pakaran ^
12:17:00 <pakaran> well, i do know that whether a pointer will be initialized before being used cannot, in general, be detected automatically
12:17:05 <ski> pakaran : also, `null' means you can get domain contagion
12:17:19 <pakaran> what does that mean?
12:17:38 <ski> let's say you have a finite map where you associate keys with values
12:18:04 <tac-tics> ski: Thanks for linking to that. I read somewhere on reddit or someplace there was  video of Tony Hoare talking about the "million dollar mistake", but I couldn't find it when I googled it ;(
12:18:07 <ski> and if you lookup a key, you get `null' if there wasn't such an association present
12:18:21 <ski> this now means that you can't associate any key to the `null' value
12:18:51 <ski> (since then you can't disntinguish between getting `null' as a result of missing association, and as a result of `null' being the value associated with the key)
12:18:56 <pakaran> well, i know that you can get memory corruption and all kinds of security problems with void*s
12:18:59 <pakaran> (as in C)
12:19:07 <pakaran> but you can't do those things with, say, a java Object
12:19:20 <ski> yeah -- though that's not the exact same problem
12:19:21 * ski nods
12:19:29 <monochrom> all haskell interpreters/compilers detect uninitialized pointers. statically.
12:19:43 <pakaran> monochrom, ... seriously?
12:19:54 <pakaran> because i suspect that's actually undecidable
12:19:59 <c_wraith> it's *really* hard to have an uninitialized pointer in Haskell.
12:20:04 <rwbarton> not if your language doesn't have uninitialized pointers
12:20:11 <c_wraith> since you can't have a name without a binding for it.
12:20:35 <pakaran> ...
12:20:36 <pakaran> wow
12:21:02 <ski> the "2006-02-03 Option types, optional parameters" entry at <http://mumble.net/~campbell/blag.txt> mentions "domain contagion", in the context of Scheme (where `#f' (the false value) plays the role of `null')
12:21:14 <alex404> So my library files seem to live in /usr/local/lib but my ghc-pkg list is listing from /usr/lib/ghc-7.4.1 could that be a problem?
12:21:15 <pakaran> and i assume that the false boolean value, the empty tuple, the empty list, the integer 0, and friends are all actual objects, of different actual types?
12:21:18 <monochrom> in haskell, you can't write "x =" and end it there. by the time you complete "x = 4", congrats, you have an initialized pointer.
12:21:19 <Philippa> pakaran: it may help to let go of machine code and pretend that set theory is your machine code instead?
12:21:26 <alex404> Everything installs fine
12:21:29 <Philippa> and yes, they are
12:21:37 <hhb13> Hi, new to Haskell. I'm trying to use conduits with a Datagram server. All examples are for TCP. Does anyone know of an example?
12:21:40 <alex404> I can compile against my installed libraries/use them in ghci
12:21:43 <pakaran> and, erm, most of those aren't false in an if statement?
12:21:47 <pakaran> that's pretty nice
12:21:49 <alex404> but it's just cabal that doesn't believe me that they're there
12:21:50 <Philippa> (well, () is "unit" rather than the empty tuple, but yes)
12:21:54 <rwbarton> only the first is valid in an if statement
12:22:00 <Philippa> right, we /mean/ the type system
12:22:06 <Eduard_Munteanu> pakaran: 'if' only works with Bool, no implicit conversions
12:22:26 <ski> > if "" then "no" else "yes"
12:22:27 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
12:22:27 <lambdabot>         against inferred type ...
12:22:47 <pakaran> that seems like it would prevent a LOT of problems
12:22:51 <monochrom> in an imperative language that Hoare would love to re-do, "var *x;" could be outlawed, "var *x = null;" could also be outlawed, you can only have "var *x=y;" or "var *x = new stuff;".
12:22:52 <dmwit> alex404: Start hpasting dry-runs with constraints asking for the versions you have installed.
12:22:58 <ski>         against inferred type `[GHC.Types.Char]'
12:23:07 <dmwit> alex404: Bonus points for hpasting the output of ghc-pkg list and ghc-pkg check.
12:23:30 <monochrom> notice that we are requiring all pointers to be initialized to non-null, not just all used pointers. that sidesteps the undecidability question.
12:23:35 <alex404> dmwit: Ok. I'll give you a dry run of Chart-gtk in a second
12:23:56 <pakaran> though...  one of the problems caused would be being unable to stump my students by using the "next" pointer in a linked list object directly in a conditional, to sneakily determine whether the item was at the tail of the list
12:23:58 <alex404> dmwit: Wait a second though
12:24:06 <pakaran> monochrom, yeah.
12:24:13 <pakaran> i was thinking a reduction from the dead code problem
12:24:13 <alex404> dmwit: Looking at a dry run for gtk for example
12:24:20 <ski> > lookup 'a' [('a',Just 3),('b',Nothing)]
12:24:21 <lambdabot>   Just (Just 3)
12:24:23 <ski> > lookup 'b' [('a',Just 3),('b',Nothing)]
12:24:23 <lambdabot>   Just Nothing
12:24:24 <monochrom> it is the same thing as saying: haskell detects runtime type errors, statically.
12:24:25 <ski> > lookup 'c' [('a',Just 3),('b',Nothing)]
12:24:26 <lambdabot>   Nothing
12:24:31 <ski> look, no domain contagion ^
12:24:49 <tac-tics> @type lookup
12:24:49 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
12:24:52 <dmwit> ski: pfft, lookup should clearly return -1 if it can't find the thing...
12:24:53 <monochrom> the trick is to be pessimistic and outlaw even "if True then 'x' else 4"
12:25:07 <hhb13> I was able to create a Datagram server based on the example here: http://book.realworldhaskell.org/read/sockets-and-syslog.html#sockets.udp.server but it resulted in too many dropped packets even with threading. I want to try conduits, but I'm having trouble.
12:25:12 <alex404> dmwit: Okay look at this from cabal install gtk --dry-run
12:25:15 <alex404> http://hpaste.org/68792
12:25:19 <tac-tics> > lookup 0 [(0, x) | x <- [1..]]
12:25:20 <lambdabot>   Just 1
12:25:20 <alex404> The weird thing is
12:25:24 <alex404> That it wants to update containers
12:25:35 <Eduard_Munteanu> monochrom: btw, any particular reason to do that?
12:25:39 <alex404> so it knows containers 0.4.2.1 is installed
12:25:45 <dmwit> 1. Why are you cabal install'ing gtk if you claim it's already installed?
12:25:52 <dmwit> 2. So add a constraint on containers.
12:25:54 <Eduard_Munteanu> monochrom: I guess it's particularly useless in Haskell, for one thing
12:26:04 <alex404> dmwit: I know that's not what you told me to do
12:26:06 <alex404> It's just weird
12:26:09 <Philippa> pakaran: not having to manipulate linked lists as opposed to cons lists quickly becomes a win - especially when you've done something slightly different from usual and are (correctly) forced to declare a new type instead. TANSTAAListNode, either
12:26:14 <Eduard_Munteanu> Mm, wait, it isn't.
12:26:14 <alex404> that cabal can find containers 0.4.2.1
12:26:20 <alex404> but not 0.5.0.0
12:26:26 <alex404> even though ghc-pkg list tells me I have them both installed
12:26:38 <monochrom> some clever lisp programs do that. some clever dependently typed programs do that, and proves type safety
12:26:40 <pakaran> yeah
12:26:49 <dmwit> alex404: You are misinterpreting the output of cabal-install.
12:27:00 <Eduard_Munteanu> Yeah, dependent if-then-else seems safer.
12:27:11 <dmwit> alex404: *and* you never ran ghc-pkg check as I asked you to, clearly, since you have broken packages.
12:27:13 <ski> pakaran : "using the \"next\" pointer in a linked list object directly in a conditional, to sneakily determine whether the item was at the tail of the list" -- elaborate ?
12:27:20 <alex404> dmwit: I did do that
12:27:26 <alex404> dmwit: I told you
12:27:36 <pakaran> not something i did in an actual class
12:27:39 <pakaran> but i knew someone who did
12:27:42 <alex404> dmwit: The only complaint I got was that Chart was weird
12:27:43 <pakaran> i think it may have been in C++
12:27:49 <ski> yes, but i'm not sure what you mean
12:28:00 <pakaran> so i may be getting details wrong
12:28:06 <dmwit> alex404: I don't believe you; cabal-install is complaining that cairo is broken.
12:28:08 <Eduard_Munteanu> Pointer comparison I guess?
12:28:09 <pakaran> but they initialized the pointers in a list node object to be null
12:28:14 <monochrom> alex404: try "ghc -v" and enjoy all the "unusable" and "shadowed" messages
12:28:37 <pakaran> then if no next node had been added after a given node, the node's "next" pointer would still be null
12:28:39 <Philippa> ski: TCMC strikes!
12:28:41 <pakaran> and thus false in a conditional
12:28:51 <ski> Philippa : it does ?
12:29:00 <Philippa> well, in terms of capacity to stump students, anyway :-)
12:29:09 <pakaran> thus resulting in code that very succinctly did operations on the list, without segfaulting by trying to follow null pointers
12:29:12 <alex404> dmwit: Right, well that's broken now, just give me a second... I'm going to clean things up a bit, and then I'll hpaste my ghc-pkg list and then my ghc-pkg check
12:29:13 <Eduard_Munteanu> You can use stuff like   IORef (Maybe SomeType)   to emulate some of that.
12:29:15 <Philippa> (though you then have confusion between [] and uninitialised)
12:29:19 <ski> pakaran : ah, i see, writing `if (blah)' instead of `if (blah != NULL)'
12:29:21 <pakaran> (and which, when subtly changed, would segfault)
12:29:40 <Philippa> ah, yeah. That's fairly idiomatic in C
12:29:47 <mparodi> argh, it's almost done! but I can't figure out why I have this problem: I can't do foo.bar where the types are:    foo :: [[Char]] -> IO ()    bar :: [(Int, Int)] -> [[Char]] -> [[Char]]
12:29:47 <mparodi> I bet the answer is pretty obvious :|
12:29:51 <Philippa> (less so in C++)
12:29:53 <pakaran> something like...
12:30:02 <alex404> monochrom: I used to love cabal! Why is it being so terrible to me!
12:30:06 <ski> @hoogle nullPtr
12:30:06 <lambdabot> Foreign.Ptr nullPtr :: Ptr a
12:30:12 <alex404> monochrom: It hates me. I know it.
12:30:12 <Botje> mparodi: foo . bar = \x -> foo (bar x)
12:30:13 <monochrom> I guess the provision of null helps build linked lists in a convenient direction
12:30:17 <navaati> @src Monad Maybe
12:30:17 <lambdabot> Source not found. You untyped fool!
12:30:23 <navaati> @src Maybe Monad
12:30:24 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
12:30:29 <Botje> mparodi: bar x will have type [[Char]] -> [[Char]], not the [[Char]] foo expects.
12:30:36 <navaati> f*ck you, lambdabot
12:30:38 <mparodi> Botje, but I don't see why I can't do (foo . bar) <arguments>
12:30:39 <ski> monochrom : *nod*, given the absense of TCMC
12:30:49 <pakaran> void delete() { if(prev) {prev.next = next}; if(next) {next.prev=prev})
12:30:50 <Eduard_Munteanu> Although sometimes you might want double IORefs to get mutability in the pointer itself.
12:30:58 <dmwit> ?src Maybe (>>=)
12:30:59 <lambdabot> (Just x) >>= k      = k x
12:30:59 <lambdabot> Nothing  >>= _      = Nothing
12:30:59 <Botje> mparodi: because you're then adding arguments to the foo expression.
12:31:00 <dmwit> navaati:
12:31:26 <Botje> mparodi: (foo . bar) x y = foo (bar x) y
12:31:32 <mparodi> for example: (foo . bar) [(1,1)] ["test", "test"]
12:31:33 <monochrom> sorry, what is TCMC? thanks
12:31:36 <pakaran> Philippa, what's TCMC?
12:31:43 <Philippa> Tail Call Modulo Cons
12:31:45 <ski> monochrom : "Tail-Call Modulo Cons(tructor)"
12:32:10 <Philippa> tail call, except you're allowed to say "and please shove the result in this uninitialised constructor slot"
12:32:11 <monochrom> oh, yeah, ocaml has that, z = 0 : z is allowed :)
12:32:12 <Eduard_Munteanu> mparodi: you want   (foo . bar [(1,1)]) ["test", "test"]
12:32:12 <mparodi> Botje, hmn.. ok. so you can never use (.) if the second function needs more than one argument?
12:32:25 <Botje> mparodi: sure you can.
12:32:34 <Botje> foo . bar 5 is okay, for example.
12:32:36 <ski> monochrom : yeah, but not composably
12:32:42 <Botje> or even foo . bar x y . baz z 3
12:32:49 * monochrom would use mfix :)
12:33:00 <dmwit> > ((f .) . g) x y
12:33:01 <lambdabot>   Ambiguous type variable `a' in the constraints:
12:33:01 <lambdabot>    `GHC.Show.Show a'
12:33:01 <lambdabot>      a...
12:33:05 <Botje> mparodi: but if you need to give two 'unknown' arguments to the second function it's a bit trickier.
12:33:06 <dmwit> > ((f .) . g) x y :: Expr
12:33:07 <lambdabot>   Ambiguous type variable `a' in the constraints:
12:33:07 <lambdabot>    `SimpleReflect.FromExpr ...
12:33:09 <monochrom> oh wait, mfix works because haskell already provides the non-strictness. oh well.
12:33:10 <dmwit> oh well
12:33:13 * Eduard_Munteanu ponders why equirecursive ADTs are so rare
12:33:18 * monochrom would use a non-strict language :)
12:33:19 <mparodi> Botje, no, I mean, with something like (f g z) where g or z needs more than one argument
12:33:29 <mparodi> err, f . g . z *
12:33:31 <Botje> mparodi: when in doubt, feed it to @pl and see what comes out :)
12:33:36 <Botje> @pl \x y -> f (g x y)
12:33:37 <lambdabot> (f .) . g
12:33:41 <dmwit> Eduard_Munteanu: Unfortunately common things become undecidable.
12:33:50 <Eduard_Munteanu> It was something about their denotational semantics, though surely there are simple implementations.
12:33:59 <mparodi> ah, interesting
12:34:16 <pakaran> when i said that detecting null references was undecidable
12:34:21 <ski> > (((f :: Expr -> Expr) .) . g) x y
12:34:22 <pakaran> basically the argument is
12:34:22 <lambdabot>   f (g x y)
12:34:22 <Eduard_Munteanu> dmwit: hm, perhaps. I wonder how Ocaml copes.
12:34:30 <pakaran> consider the following algorithm:
12:34:40 <dmwit> Ocaml has equirecursive ADTs?
12:34:43 <dmwit> Surely no.
12:34:52 <Eduard_Munteanu> Some flavor of ML surely does, AFAIR.
12:34:54 <pakaran> on input M, x, create a pointer named y.  run M on input x.  after it halts, give y some value.
12:35:03 <ski> OCaml allows equirecursive types
12:35:09 <dmwit> wow
12:35:16 <pakaran> if you can detect whether y is null (at the time it's referenced, say, by another thread), you can solve the halting problem
12:35:22 <monochrom> there is some type-wise thing that ocaml copes by making you add type annotations
12:35:27 <Philippa> pakaran: sure. You can, however, ask for a proof that the pointer won't be null and allow an arbitrarily powerful logic to be used, complete with universe count
12:35:33 <ski> dmwit : however, if you don't flip `-rectypes', it only allows them if it cycle goes through at least one object type
12:35:35 <Eduard_Munteanu> pakaran: perhaps, but here you can't build a null pointer to begin with.
12:35:57 <pakaran> yeah
12:36:05 <Philippa> and what Eduard_Munteanu said (but same difference, in some sense, plus Haskell doesn't know what a pointer is outside IO/FFI contexts)
12:36:07 <ski> dmwit : it's not hard to allow, it's just that it typically tends to turn type errors into strange inferred types
12:36:08 <pakaran> and a lot of problems that people solve every day are theoretically hard in general
12:36:38 <pakaran> behavior based virus detection, for example: essentially, we accept a certain small error rate, and accept that legitimate programs will not do certain things (like change their own code while running)
12:37:04 <pakaran> what's the type of an open fd, if it isn't a pointer?
12:37:08 <ski> pakaran : yea, so we approximate conservatively, just as we do with the type system
12:37:16 <dmwit> pakaran: Fd
12:37:28 <dmwit> (It's an abstract type.)
12:37:34 <pakaran> ah!  and if the open fails, i assume the type returned will NOT be a null pointer
12:37:35 <ski> monochrom : you can infer equirecursive types
12:37:43 <dmwit> Oh, it's not even abstract. newtype Fd = Fd CInt
12:37:48 <Eduard_Munteanu> File descriptors aren't pointers even in C/POSIX.
12:37:52 <monochrom> if the open fails, it throws an exception
12:38:08 <rwbarton> nothing is returned at all
12:38:12 <dmwit> pakaran: file descriptors aren't even pointers, but yes, it won't return something that isn't a valid file descriptor
12:38:23 <Eduard_Munteanu> But perhaps you meant FILE *
12:38:30 <pakaran> i may have.
12:38:34 <ski> pakaran : "change their own code while running" unfortunately disallows some cool things
12:38:40 <pakaran> some of my C++ work used mmap to work with files efficiently
12:38:49 <Eduard_Munteanu> ski: and some pretty common things too
12:38:49 <mparodi> <Botje> mparodi: (foo . bar) x y = foo (bar x) y <-- as I can see the confusion is that I thought it was equivalent to "foo (bar x y)" instead
12:38:54 <mk12> Is there an elegant way to take two Ints and produce a Maybe Int which is the smallest and above 0?
12:38:55 <navaati> dmwit: ah, thanks
12:38:57 <Philippa> pakaran: it helps to remember that (x86?) machine code and C are just two computational models among many
12:39:02 <Eduard_Munteanu> e.g. JITs, VMs, that sort of stuff
12:39:06 <mk12> I have "listToMaybe . sort . filter (> 0) $ [t0, t1]" but I feel like it should be simpler and not involve lists
12:39:13 <Philippa> for the most part, Haskell works best when you ignore the hardware per se
12:39:15 <dmwit> It's the same answer, anyway. openFile throws an exception rather than returning garbage when it fails.
12:39:23 <pakaran> Eduard_Munteanu, and for that matter, read strictly, execution of user scripts
12:39:24 <Philippa> (most of the things you can do to go faster make sense in a pen'n'paper way too)
12:39:38 <ski> mparodi : you can write `(foo .: bar) x y'
12:39:44 <Philippa> also, possible headfuck moment: you can describe FPLs that are clearly much lower level than C :-)
12:39:55 <pakaran> Eduard_Munteanu, i guess what i meant is that we accept that programs that do alter code while running, or load code, will do so in a fashion that looks very different to the kernel than a buffer overflow into an executable segment of memory.
12:40:18 <mparodi> ski, ".:" ? 1:6: Not in scope: `.:'
12:40:20 <pakaran> FPL?
12:40:25 <Philippa> Functional Programming Language
12:40:26 <ski> mparodi : given `(.:) = (.) . (.)', it can also be defined as `f .: g = (f .) . g' or `(f .: g) x y = f (g x y)'
12:40:56 <dmwit> mk12: f a b = guard (a > 0 && b > 0) >> return (min a b)
12:40:57 <ski> Eduard_Munteanu : and RTCG
12:41:16 <Eduard_Munteanu> Realtime Code Generation? *guess*
12:41:23 <dmwit> mk12: Oh, hm, do you want to return something if only one of them is greater than zero?
12:41:27 <ski> Run-Time Code Generation, yes
12:41:35 <Eduard_Munteanu> Ah, generally.
12:41:46 <mk12> dmwit: yes, if only one is positive I want to return that
12:41:48 <Eduard_Munteanu> Yeah, even the Linux kernel does that for quite a few things.
12:41:58 <Philippa> ski: OOI, how would you approach an ANF variant intended to support TCMC? I'm suddenly thinking adding linear references that you're allowed to use as lvars and a non-let bind form you're allowed to use in the tail position
12:42:13 <Eduard_Munteanu> Tracepoints, the BPF JIT etc.
12:42:18 <ski> Eduard_Munteanu : it's one thing you can do with partial evaluation -- e.g. generating code at run-time which is specialized to a certain network configuration and protocol, instead of having to interpret the config all the time
12:42:22 <pakaran> i do remember reading somewhere that parts of the Linux kernel are actually object oriented
12:42:29 <dmwit> mk12: Then use something like the Max monoid, I suppose.
12:42:30 <dmwit> :t Max
12:42:31 <lambdabot> Not in scope: data constructor `Max'
12:42:39 <rwbarton> you don't have to like this but "case minimum [0, a, b] of 0 -> Nothing; x -> Just x"
12:42:45 <rwbarton> er
12:42:47 <dmwit> let's see
12:42:48 <rwbarton> maximum
12:42:56 <rwbarton> wait
12:43:01 <rwbarton> the smallest and above 0?
12:43:03 <eikke> pakaran: sure, kinda like gobject
12:43:09 <Eduard_Munteanu> pakaran: a lot of C stuff uses OO concepts.
12:43:30 <mk12> rwbarton: Yes
12:43:33 <alex404> dmwit: Here's the ghc-pkc check and list: http://hpaste.org/edit/68792
12:43:53 <dmwit> alex404: uh
12:43:57 <mk12> rwbarton: If there is no positives, there is no answer, and if is one, it's that, and if there's two, its the smallest
12:44:00 <rwbarton> well basically you want a "minimumMaybe"
12:44:01 <Eduard_Munteanu> ski: are you talking about Oleg's paper on configurations?
12:44:09 <rwbarton> which is your listToMaybe . sort
12:44:11 <alex404> dmwit: ?
12:44:15 <dmwit> alex404: I think you'd better try again.
12:44:20 <ski> Eduard_Munteanu : hm, not really. i'm thinking about partial evaluation and program specialization
12:44:22 <rwbarton> I think your original is actually prett reasonable.
12:44:43 <Eduard_Munteanu> Ah.
12:45:28 <alex404> dmwit: Does this work? http://hpaste.org/68793
12:45:31 <ski> Philippa : i'm not sure how those forms would look like (abstract syntax)
12:45:40 <ski> what do you mean by "non-let bind form" ?
12:45:53 <mk12> rwbarton: Ok thanks, I guess I'll just stick to that then.. I'm still learning about functors and applicatives and monads, and wasn't sure if there was a way to apply them here to simplify things
12:45:59 <dmwit> alex404: Yes, and it says that cairo is broken.
12:46:10 <kopi> Hmm. Snap or Yesod which would be better to start with
12:46:29 <alex404> dmwit: Right, but that's only because that install of cairo is no longer there
12:46:35 <alex404> dmwit: I'm pretty sure that's not relevant
12:46:58 <dmwit> It looks pretty relevant to me.
12:47:07 <alex404> dmwit: The only thing I can think of is that some of my libs are in /usr/lib and others in /usr/local/lib. Does that not seem important at all?
12:47:24 <dmwit> That is not important at all.
12:47:26 <Philippa> ski: hmm. Perhaps let allows (linear) fresh references on the RHS as a way to do your partial consing? Then you have "bind <ref> <value>" or something as a value, though thinking about it that's not entirely good in non-tail position
12:48:08 * ski tries to recall a starting BNF for ANF
12:48:23 <Philippa> do notation :p
12:48:36 <kallisti> is it possible to put expressions in a NOINLINE?
12:48:49 <Philippa> (only with return elided)
12:48:52 <Eduard_Munteanu> Philippa: what's the idea, so you can't do stuff like x = 1 : x : x (or something that makes a tad more sense)?
12:49:30 <dmwit> mk12: let big x = MinPriority (guard (x>0) >> return x); f a b = getMinPriority (big a `mappend` big b)
12:49:37 <dmwit> actually, I'd write
12:49:46 <Philippa> Eduard_Munteanu: the idea is that references are single memory locations and they only exist to enable TCMC. Otherwise, make do with the variables you have
12:49:54 <dmwit> let ensure p x = guard (p x) >> return x; big = MinPriority . ensure (>0)
12:50:12 * kallisti has come across an utterly baffling bug in filesystem-trees
12:50:21 <Philippa> ski: prod me about this another night though and I'll spent a few minutes in a text editor and spit out some abstract syntax?
12:50:22 <dmwit> http://hackage.haskell.org/packages/archive/monoids/0.2.0.2/doc/html/Data-Monoid-Ord.html
12:50:26 <Eduard_Munteanu> Philippa: what's TCMC? (might need to look that up)
12:50:27 <ski> `<expr> ::= <val> | let <decl> ... in <expr>' and `<decl> ::= <var> <var> ... | <val>' and `<val> ::= <var> | \ <var> ... . <expr>' ?
12:50:40 <Philippa> Eduard_Munteanu: Tail Call Module Cons(tructor)
12:50:44 <Philippa> *modulo
12:50:58 <Eduard_Munteanu> Ah.
12:51:11 <dmwit> f = getMinPriority .: mappend `on` big
12:52:08 <mk12> dmwit: where is the (.:) from?
12:53:21 <dmwit> Oh, I dunno.
12:53:31 <dmwit> http://hackage.haskell.org/packages/archive/functors/0.1/doc/html/Data-Functor-Syntax.html has it I guess
12:53:57 <dmwit> honestly, though, there's nothing wrong with what you started with
12:54:07 <dmwit> I'm just playing with Haskell toys, not really making the code *better*.
12:55:40 <mk12> dmwit: Yea thanks, it might not be as clear at this point but it's still useful for me to figure out what that's doing
12:56:13 <dmwit> under MinPriority mappend `on` ensure (>0) -- my favorite one yet
12:57:45 <mk12> dmwit: I can't find "under" on hoogle..
12:58:10 <dmwit> http://hackage.haskell.org/packages/archive/newtype/0.2/doc/html/Control-Newtype.html
13:02:54 <dmwit> Actually, I'm confused.
13:08:24 <mk12> ok, new problem, how can I point-free "\a b -> f (g a b) a" where g returns a Maybe? :pf gives me "(f .) . g >>= flip" but it doesn't know about the types
13:08:40 <mk12> so the failure of g should propagate to that function
13:09:07 <rwbarton> well you should write the non-point-free Maybe-ful version first
13:09:21 <rwbarton> (and then not make it point-free)
13:09:21 <tgeeky> mk12:
13:09:22 <tgeeky> @pl \a b -> f (g a b) a
13:09:23 <lambdabot> flip =<< (f .) . g
13:09:32 <dmwit> Did you mean \a b -> g a b >>= \c -> f c a -- ?
13:09:37 <rwbarton> what do you mean by "g returns a Maybe" anyways
13:09:41 <dmwit> ?pl \a b -> g a b >>= \c -> f c a
13:09:42 <lambdabot> ap (flip . ((>>=) .) . g) (flip f)
13:09:48 <tgeeky> dmwit: yes, I bet he did
13:09:53 <RylandAlmanza> I'm looking to convert my [[Bool]] into a black and white image. I tried this http://www.haskell.org/haskellwiki/Library/PNG but it didn't work. I'm looking into juicy pixels, but it seems a bit overkill.
13:09:55 <rwbarton> or possibly fmap (flip f a) (g a b)
13:09:57 <ski> rwbarton : `g :: Foo -> Maybe (Bar -> Baz)' ?
13:10:42 <mk12> it might be easier to understand in its real context.. intersect :: Ray -> Surface -> Maybe Scalar    ,  extend :: Scalar -> Ray -> Vector
13:11:02 <mk12> the function I'm writing: pointOfIntersection :: Ray -> Surface -> Maybe Vector
13:11:23 <tgeeky> that doesn't make it easier for me :O
13:12:31 <mk12> I have intersect which gives a maybe value for how far along the ray the intersection is, I have extend which takes that length and the ray and gives me the actual point in space
13:12:58 <mk12> so the point full expression would be
13:13:23 <dmwit> ?pl foo ray surface = fmap (flip extend ray) (intersect ray surface)
13:13:24 <lambdabot> foo = ap ((.) . fmap . flip extend) intersect
13:13:34 <dmwit> readable
13:14:12 <mk12> actually I haven't figured out the point full expression because I'm not sure how to make the failure of intersect propagate to pointOfIntersection
13:14:17 <dmwit> foo ray surface = (`extend` ray) <$> intersect ray surface -- is still pretty readable
13:14:32 <ski>   foo = liftM2 (.) (fmap . flip extend) intersect
13:15:29 * hackagebot nonlinear-optimization 0.3.6 - Various iterative algorithms for optimization of nonlinear functions.  http://hackage.haskell.org/package/nonlinear-optimization-0.3.6 (FelipeLessa)
13:16:07 <mk12> dmwit: you're right, thanks, that works
13:17:07 <dmwit> djahandarie: I'd like to write this using the "newtype" package: getMinPriority (MinPriority (f x) `mappend` MinPriority (f y))
13:17:10 <dmwit> wat do?
13:17:27 <dmwit> (I've written an instance Newtype (MinPriority a) (Maybe a) already.)
13:17:28 <mk12> ski: that doesn't look too bad, I'll see if I can figure out what's going on, thanks
13:18:31 <5EXAAXLZJ> hello haskellers
13:18:41 <ClaudiusMaximus> RylandAlmanza: http://hackage.haskell.org/packages/archive/bitwise/0.1/doc/html/Codec-Image-PBM.html maybe
13:18:59 <alex404> Is there a discussion amongst the powers that be about adding ratings to haskell packages? It seems like some order has to be added to the zoo of packages...
13:19:00 <ski> mk12 : i would prefer dmwit's version
13:19:47 <dmwit> alex404: Yes, join the Hackage2 team and start hacking on it! =)
13:20:38 <alex404> dmwit: Ooooh. Cool. Also thanks for your help earlier. I think I've sorted out how to fix my problem at least.
13:20:51 <ClaudiusMaximus> RylandAlmanza: without having tested it, it'd probably be something like  BS.writeFile "out.pbm" . encodePBM . listArray ((0,0), (height - 1, width -1)) . concat
13:21:45 <kallisti> is there any reason to declare NOINLINE on a type-restricted renaming of unsafeCoerce?
13:22:05 <dmwit> Yes, if there are rewrite rules.
13:22:41 <kallisti> ohh...
13:22:43 <kallisti> yeah
13:23:06 <RylandAlmanza> Thanks ClaudiusMaximus, I'll check that out
13:23:12 * dmwit feels ultra smart because he just read that section of the GHC manual yesterday by accident
13:23:15 <mk12> ski: yea, it is more readable.. I see how it works now, it's just mapping the value inside — I should have figured that out, I just finished reading the functor section in LYAH.
13:23:54 <mk12> but I guess after reading about applicatives and monoids and monads they all became jumbled together in my mind..
13:24:01 <kallisti> dmwit: I didn't think inling would alter the type of expressions with regard to requiring rewrite rules to typecheck.
13:24:06 <kallisti> but I guess it would be difficult to avoid otherwise.
13:25:09 <mk12> is it conventional to always use <$> instead of fmap ? (when fully applying it)
13:25:31 * hackagebot happstack-yui 7351.2.0 - Utilities for using YUI3 with Happstack.  http://hackage.haskell.org/package/happstack-yui-7351.2.0 (DagOdenhall)
13:25:32 <kallisti> mk12: "pretty conventional" I'd say
13:25:36 <c_wraith> mk12: no.  Convention is generally "whichever results in fewer parens"
13:25:40 <armlesshobo> is "when" a keyword?
13:25:43 <armlesshobo> or a function?
13:25:47 <donri> :t when
13:25:48 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
13:25:50 <c_wraith> mk12: so you see things like fmap foo <$> bar
13:25:51 <monochrom> a function
13:25:53 <rwbarton> @src when
13:25:54 <lambdabot> when p s = if p then s else return ()
13:25:55 <dmwit> kallisti: It's not that it changes the type.
13:26:01 <armlesshobo> hmm
13:26:04 <dmwit> kallisti: It's that inlining eliminates the thing you might want to rewrite.
13:26:10 <armlesshobo> I tried :t when in my ghci shell
13:26:20 <armlesshobo> and it said it's not in scope. Do i need to import something?
13:26:27 <dmwit> kallisti: e.g. if your rewrite rule says "foo (bar x) -> x", and "foo" gets inlined so that your expression is "unsafeCoerce (bar x)", the rule won't fire.
13:26:29 <c_wraith> lambdabot has a ton of imports
13:26:29 <monochrom> import Control.Monad
13:26:31 <kallisti> dmwit: oh so it's just an efficiency concern
13:26:36 <kallisti> I'm trying to find semantic brokenness.
13:26:38 <armlesshobo> ahhhh oi
13:26:41 <armlesshobo> ok*
13:26:41 <armlesshobo> ty
13:27:58 <shurikas> does anybody know how many multiplications a standard Haskell implementation require to multiply n-digit numbers? n2?
13:28:04 <shurikas> n^2 I mean
13:28:10 <dmwit> > 32^2
13:28:11 <lambdabot>   1024
13:28:13 <dmwit> seems to work
13:28:16 <shurikas> well, really helpful
13:28:22 <dmwit> Oh, how many mulitplications.
13:28:25 <dmwit> ?src (^)
13:28:25 <lambdabot> x ^ 0            =  1
13:28:25 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
13:28:25 <lambdabot>   where f _ 0 y = y
13:28:25 <lambdabot>         f x n y = g x n
13:28:25 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
13:28:27 <lambdabot>                       | otherwise = f x (n-1) (x*y)
13:28:29 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
13:28:43 <shurikas> I am just looking at karatsuba's algorithm
13:28:54 <rwbarton> it uses gmp for Integer
13:29:01 <shurikas> and it's complexity is O(n lg3)
13:29:10 <rwbarton> and gmp will use different algorithms depending on the size of n
13:29:11 <dmwit> Oh, that's an even more exciting question than I thought. Yes, GMP uses an efficient multiplication.
13:29:19 <shurikas> and in article it states that standard implementation takes n^2
13:29:25 <shurikas> (language wasnt specified)
13:29:36 <c_wraith> "naive" would be more accurate than "standard"
13:29:41 <shurikas> yeah
13:30:08 <shurikas> well, they used PHP to implement algorithm
13:30:14 <armlesshobo> s/naive/careless/g  :P
13:30:14 <shurikas> I guess it takes n^2 there :)
13:30:17 <ski> mk12 : i don't like `<$>', i use `fmap' instead
13:30:33 <ski> (or `liftA' or `liftM')
13:30:56 <hpaste> dmwit pasted “exhausting” at http://hpaste.org/68796
13:31:11 <dmwit> mk12: Finally figured it out, in case you still care about this noodling. =)
13:31:13 <ClaudiusMaximus> > (+1) . (+1) `fmap` Just 40  -- this is one problem i have with `fmap`
13:31:14 <lambdabot>   Precedence parsing error
13:31:14 <lambdabot>      cannot mix `L..' [infixr 9] and `GHC.Base.fma...
13:31:35 <hpaste> shaswat pasted “TDD Haskell” at http://hpaste.org/68797
13:31:36 <shurikas> ok, thanks for an answer ;)
13:31:39 <dmwit> mk12: Don't think it's better than sort + listToMaybe, though. Just more fun and confusing. =)
13:31:54 <shurikas> it's just that I implemented multiplication using bit shifting and it was way slower than built-in haskell implementation
13:32:05 <ClaudiusMaximus> > (+1) . (+1) <$> Just 40  -- seeing if this works..
13:32:07 <lambdabot>   Just 42
13:32:26 <shurikas> although my implementation probably is far from what it could be
13:32:50 <mk12> dmwit: haha, impressing :-)
13:32:58 <hpaste> zhulikas pasted “multiplication” at http://hpaste.org/68798
13:33:12 <Phlogistique> > (+1) . (+1) . Just 40
13:33:14 <lambdabot>   Just 42
13:33:39 <geekosaur> um, Caleskell alert
13:33:44 <ClaudiusMaximus> i experimented once with splitting an Integer into high and low parts, and multiply/shifting/adding to try to speed something up, but ended up slower - my guess is that libgmp is faster than anything i could ever possibly write
13:34:14 <Phlogistique> a "Caleskell" package would be useful
13:34:40 <zhulikas> I am still up to try exponentiation with bit shifting as shiftL 1 1000000 is way faster than 2**1000000
13:35:13 <zhulikas> though it's 2... not sure how much the speed will change after I will be able to do a^b instead of 2^b
13:35:17 <pakaran> have you tried using ^ rather than **?
13:35:20 <Phlogistique> maybe I should create one and call it opinionated-prelude
13:35:24 <Phlogistique> or something
13:35:27 <pakaran> the later might be trying to approximate a transdencental function
13:35:33 * mgsloan mumbles something about it being super misleading to have a non-conventionally-preluded lambdabot
13:35:40 <pakaran> ...transdencental?  beyond teeth?
13:35:40 <ClaudiusMaximus> > bit 100 :: Integer
13:35:41 <pakaran> sigh
13:35:41 <lambdabot>   1267650600228229401496703205376
13:35:41 <dmwit> 2**1000000 is using a different type (Double) than shiftL 1 1000000 (Integer)
13:35:45 <geekosaur> generalized prelude
13:35:58 <S11001001> I love (.) as fmap
13:35:58 <zhulikas> ^ and **,,,
13:36:02 <zhulikas> I always used **
13:36:04 <zhulikas> damn
13:36:10 <kloplop321> > bit 333 :: Integer
13:36:11 <lambdabot>   174980057982640953949800178169409709228253554471456994914061648512796239935...
13:36:16 <ClaudiusMaximus> > scaleFloat 100 1 :: Double -- relies on the implementation being base2
13:36:17 <lambdabot>   1.2676506002282295e30
13:36:34 <pakaran> zhulikas, I believe ^ does actual integer exponention, including by squaring
13:36:44 <shashwat> I just started with HUnit, but my first code is giving an indecipherable error ( undefined references ). However it works in ghci.  What am I missing ? http://hpaste.org/68797
13:36:50 <kallisti> yes ^ is a recursive function.
13:36:57 <pakaran> zhulikas, where ** probably uses identities like x**y = e^(y log x)
13:37:05 <kallisti> also with a clever rewrite rule you could make 2**x a bitshift operation.
13:37:07 <mgsloan> geekosaur: sure, but would it make sense for the #C++ bot to use a generalized C++?
13:37:09 <dmwit> shashwat: Your third line is indented too much.
13:37:16 <kallisti> but you wouldn't want to use ** as your operator
13:37:22 <mgsloan> I'm not confused by it, but I can imagine being a noob and thinking it's rediculous.
13:37:23 <kallisti> you'd want to use a lower-level function
13:37:53 <geekosaur> mgsloan, I have certainly seen a (dunno if it's *the*) C++ bot speaking a generalized C++
13:37:58 <shashwat> dmwit: My mistake while pasting.  Indentation is ok in my file.
13:38:16 <ClaudiusMaximus> also note that (`scaleFloat` 1) isn't incredibly faster than (2**) for Double, but it is much much faster for the variable-precision package I wrote using something like (Integer, Int)
13:38:18 <mgsloan> geekosaur: really?  I guess that makes sense - certain adaptations need to be made for REPLage
13:38:27 <dmwit> shashwat: Why don't you paste the exact error as an annotation?
13:38:35 <geekosaur> undefined references... I am going to guess you used ghc without --make
13:38:42 <geekosaur> and are getting link errors
13:38:50 <zhulikas> oh, I guess I was using ^ after all...
13:38:58 <geekosaur> you need either --make or specify the -package
13:39:11 <dmwit> shashwat: (After removing the rogue indentation, it runs just fine here.)
13:39:25 <shashwat> dmwit: http://hpaste.org/edit/68797
13:39:40 <kallisti> I don't really get GHC's usage of -- and - in options
13:39:41 <dmwit> shashwat: Don't forget to hit submit. ;-)
13:39:45 <hpaste> shaswat annotated “TDD Haskell” with “TDD Haskell (annotation)” at http://hpaste.org/68797#a68799
13:40:04 <dmwit> shashwat: Ah. You're using an old ghc, and forgot to specify --make.
13:40:05 * geekosaur points to what he said earlier
13:40:51 <dmwit> High five, geekosaur!
13:41:24 <shashwat> dmwit: thanks.   But my earlier codes were running fine.
13:42:49 <kallisti> can someone explain why GHC arbitrary uses - for most options and -- for some?
13:43:09 <armlesshobo> so, when designing a program in haskell, do you guys normally write the "terminating functionality" first?
13:43:34 <geekosaur> shashwat, ghci follows them automatically.  this idfference is why --make is the default now in the most recent ghcs, but earier ones still require either --make or explicitly specifying packages
13:44:01 <geekosaur> it's also possible you had been using ghc 7.4.1 and then switched to the latest haskell platform (which uses 7.0.4)
13:44:14 <hpaste> “Jonathan Fischoff” pasted “weird linker error” at http://hpaste.org/68800
13:44:21 <kallisti> armlesshobo: I personally don't use that as a rule.
13:44:28 <kallisti> I write whatever is clearest in my mind.
13:44:31 <jfischoff> ^ any idea why I am getting that linker error?
13:45:07 <shashwat> geekosaur: I used $ghc code.hs --make and it gave no error.  However there was no a.out file generated.  Also I used brew for installing haskell platform so don't think ghc and haskell-platform have different version.
13:45:31 <geekosaur> jfischoff, you are on OS X and have a (or, *the*) collision between system and MacPorts iconv libraries
13:45:51 <armlesshobo> kallisti: i see. i'd figure one would write a function, and then the other function that calls the first one
13:45:56 <jfischoff> hmm
13:46:00 <jfischoff> thanks
13:46:05 <monochrom> there is a good chance "ghc code.hs --make" produces a file called "code"
13:46:17 <armlesshobo> jfischoff: use a real OS :P
13:46:18 <geekosaur> jfischoff, since MacPorts renamed the symbols in its own iconv to make it more bvious that bad things happen if a program expecting the modern iconv in MacPorts gets the ancient one Apple ships
13:46:32 <kallisti> armlesshobo: not really. I may not realize that I need the smaller function yet
13:46:34 <shashwat> monochrom: oops. O\It does.
13:46:39 <dmwit> shashwat: The file will be named "code".
13:46:49 <armlesshobo> kallisti: hmm. maybe I overthink too much lol
13:46:49 <jfischoff> armlesshobo: at iOS game company, that'll be a hard sell ;)
13:46:55 <armlesshobo> jfischoff: LOL, gotcha
13:47:02 <armlesshobo> :)
13:47:07 <dmwit> kallisti: hysterical raisins
13:47:14 <shashwat> dmwit: monochrom: thanks
13:47:18 <kallisti> dmwit: ah thanks.
13:47:33 <kallisti> armlesshobo: I typically just vomit out code and then make it look nice later.
13:47:51 <jfischoff> geeksosaur: thanks. I'm trying to figure out what I added in the last five minutes that could be affected by that
13:48:01 * kallisti trade secrets.
13:48:11 <dmwit> kallisti: There is a pattern, though: all one-dash things are -f, -X, -W, and maybe one or two others followed by an argument.
13:48:16 <dmwit> ...I think.
13:48:18 <kallisti> -d
13:48:23 <dmwit> right
13:48:33 <geekosaur> errr... -package
13:48:41 <kallisti> -ignore-dot-ghci
13:48:42 <weasels> can I somehow catch ThreadKilled in a thread created by forkIO?
13:48:43 <dmwit> Okay, no pattern.
13:48:48 <kallisti> lol
13:49:08 <kallisti> good to know
13:49:45 <hpaste> sizur pasted “blah-ingnore” at http://hpaste.org/68801
13:50:28 <kallisti> does Safe Haskell infer safeness even if there are RULES pragmas?
13:50:32 <kallisti> because it probably shouldn't
13:54:25 <kallisti> okay I'm fairly convinced that some sort of strange optimization bug is happening
13:55:36 * hackagebot statistics-dirichlet 0.6 - Functions for working with Dirichlet densities and mixtures on vectors.  http://hackage.haskell.org/package/statistics-dirichlet-0.6 (FelipeLessa)
13:59:10 <armlesshobo> :q
13:59:13 <armlesshobo> ... w/c
13:59:13 <armlesshobo> lol
14:00:19 <ski> you trying to quit on us, eh ?
14:03:40 <kopi> Yesod or snap which one to start
14:03:58 <monochrom> I suggest yesod
14:04:06 <barrucadu> I have used yesod and like it, I have not tried snap though
14:04:14 <Clint> same here
14:04:23 <monochrom> I have tried neither.
14:04:29 <kallisti> I'll play devil's advocate and recommend snap
14:04:32 <kopi> yesod it is
14:04:34 <kallisti> but I actually haven't used either.
14:04:36 <kopi> i  agree also
14:04:36 <Clint> someone recommend happstack now
14:04:43 <kopi> :P
14:04:46 <barrucadu> How about Haskell on a Horse?
14:04:54 <kopi> hah
14:04:54 <adnauseam> i reccomend happstack, it is excellent
14:04:59 <kopi> why
14:05:37 * hackagebot monadio-unwrappable 0.1 - Reversibly allow monad transformer stacks to run in IO  http://hackage.haskell.org/package/monadio-unwrappable-0.1 (AndrewMiller)
14:05:41 <adnauseam> i have no idea my friend, i also misspelled recommend
14:06:16 <kopi> ?
14:06:26 <adnauseam> yesod
14:06:42 <stepcut> happstack is great. It has extensive documentation and offers a wide variety of flexibility and options. happstack-lite is fairly similar to snap, or if you prefer a more yesod like system you can use happstack-server+web-route+hsp
14:06:46 <kopi> :D
14:06:46 <adnauseam> it has i think the largest community and support base
14:07:01 <kopi> and a book
14:07:03 <kopi> :D
14:07:04 <kallisti> yesod is the biggest bandwagon.
14:07:07 <adnauseam> and a book
14:07:19 <Clint> also the fastest-moving it seems
14:07:39 <tgeeky> it's also the first, in a few senses
14:07:45 <tgeeky> the first complete competitive solution
14:07:52 <tgeeky> so maybe that will haunt yesod in the long term
14:08:19 <kallisti> if this is a logic error it's not obvious to me at all.
14:08:20 <stepcut> tgeeky: for what definition of 'complete' ?
14:08:37 <tgeeky> stepcut: reached what we might honestly call 1.0
14:08:52 <stepcut> tgeeky: ?
14:09:15 <kallisti> that means they got tired of incrementing the lower major version and bumped the first one.
14:09:20 <tgeeky> stepcut: I mean, has enough features to provide a coherent single point of view for implementors (ala RoR, or any of the dozens of others)
14:09:35 <stepcut> tgeeky: and the others don't?
14:09:46 <tgeeky> stepcut: no
14:09:51 <stepcut> tgeeky: go on
14:10:04 <tgeeky> stepcut: all of the others are frameworks of frameworks
14:10:09 <tgeeky> they allow you to choose the specific components
14:10:17 <stepcut> tgeeky: so, yesod is complete because it does less?
14:10:26 <kallisti> because it's a consistent library.
14:10:58 <tgeeky> stepcut: that's not fair. Psychologically, putting boundries on the outside of something allows you to think less and focus on what's in the boundry
14:11:13 <gurrag> is there any way, using symbolic manipulation, to translate a non-curried function into a curried one?
14:11:39 <tgeeky> stepcut: and as far as I know, it's the first one with a book
14:11:58 <kallisti> gurrag: sure. just take the function definition and split it into nested lambdas
14:12:03 <stepcut> tgeeky: well, they just published the online documentation. The happstack crash course is just as comprehensive
14:12:24 <kallisti> gurrag: your language needs higher-order functions of course.
14:12:26 <tgeeky> stepcut: you view happstack and yesod as solutions to exactly the same problem?
14:13:19 <stepcut> tgeeky: pretty much.. just different ideas on how to do it
14:13:47 <tgeeky> oh. I view hapstack as something you might piggyback on to write "a yesod"
14:14:47 <stepcut> tgeeky: what does yesod offer that happstack doesn't? The primary thing yesod seems to offer is a strong suggestion that you use specific components (hamlet, persistent, etc)
14:15:05 <adnauseam> i need some guidance regarding foldr. i'm trying to implement a function that removes one string from another using foldr. now i've written this function: http://pastebin.com/hUB9fHe5  which basically is a quasi filter that removes 1 char from a string at a time
14:15:07 <mauke> The paste hUB9fHe5 has been copied to http://hpaste.org/68803
14:15:14 <tgeeky> stepcut: yes, the argument is almost that simple
14:15:29 <adnauseam> i think i' mkind of lost since i don't really understand the type of functions foldr really takes ..
14:15:37 <tgeeky> stepcut: I admit it's not that great of an argument for a very expert programmer, but it is for many of us
14:16:09 <mk12> is there some kind of prefixing convention to avoid record syntax polluting the namespace?
14:16:20 <stepcut> tgeeky: i think the thing to build on top of happstack is not yesod, but a CMS. There you can really pin down the tools used and provide a lot more out of the box functionality
14:16:29 <tgeeky> mk12: single letters (p,q,b), underscores, ...
14:16:30 <kallisti> mk12: yes
14:16:31 <tgeeky> mk12: no single convention
14:16:43 <kallisti> well, what tgeeky said. it's just done.
14:16:47 <kallisti> there's not one way to do so.
14:17:02 <tgeeky> stepcut: ok. but I don't view either as as CMS, so that's divergent to our original discussion
14:17:15 <azaq23> adnauseam: why do you try to do recursion there? that defeats the whole point of foldr (and makes no sense in the situation)
14:17:25 <mk12> do you think it would make more sense  to use the same one for all records e.g. the letter 'm', or prefix with the datatype's first letter?
14:17:27 <ski> adnauseam : you're missing a call to `foldr', yes ?
14:17:31 <adnauseam> azaq23: yeah i'm sort of panic-coding
14:17:32 <azaq23> oh wait
14:17:43 <tgeeky> mk12: no, not in general
14:17:46 <adnauseam> ski: i'm "prepairing" the foldr function
14:18:08 <stepcut> tgeeky: I am not sure what it would mean to build a yesod on top of happstack. I do think there is room to develop a 'best practices' guide for happstack though that picks the cream of the crop libraries and shows how to use them in an integrated manner
14:18:12 <mk12> tgeeky: so you're saying the second one, then?
14:18:16 <adnauseam> i've made it recursive so i can test that it runs, since i;'ve no idea what my accomulator is spposed tobe, and i'm failing at making it work with foldr
14:18:16 <ski> adnauseam : i'm not even sure what your `f' function is *meant* to do ..
14:18:30 <adnauseam> i'll rename it
14:18:34 <adnauseam> a momeny
14:18:45 <tgeeky> mk12: are you asking what to do in your code, or are you going to try to automate the naming of these?
14:18:46 <monochrom> are you required to shoehorn it into foldr?
14:18:51 <ski> adnauseam : you can annotate on the <http://hpaste.org/68803> page
14:19:02 <adnauseam> http://pastebin.com/hUB9fHe5
14:19:02 <mauke> The paste hUB9fHe5 has been copied to http://hpaste.org/68803
14:19:08 <tgeeky> mk12: oh, I see what you're saying. Yes, A single letter for each record or whatever is convenient
14:19:30 <adnauseam> ski: i will look into annotations
14:19:37 <mk12> tgeeky: I'm doing it by hand. You said 'no, not in general' so I wasn't sure if you meant use different letters or neither of the things I said
14:19:51 <tgeeky> mk12: it's really up to whatever makes it make sense to you
14:19:53 <mk12> tgeeky: oh ok
14:19:56 <adnauseam> and oh, shit, i didn't exactly change it did i, i broke it,
14:20:00 <adnauseam> give me a moment again
14:20:02 <gurrag> how big can an Integer get?
14:20:11 <kallisti> the size of available memory.
14:20:19 <hpc> @src Integer
14:20:19 <lambdabot> data Integer = S# Int#
14:20:19 <lambdabot>              | J# Int# ByteArray#
14:20:32 <gurrag> oh cool!
14:20:58 <adnauseam> http://pastebin.com/hUB9fHe5 now it's better and properly renamed
14:20:59 <mauke> The paste hUB9fHe5 has been copied to http://hpaste.org/68803
14:22:45 <adnauseam> if i do want to pass (a modified, foldr ready) version of this function to foldr, how can i get my accomulator to be an "empty string"
14:23:04 <gurrag> Does `Eq a` mean that `a` is something that supports being tested for equality?
14:23:06 <adnauseam> something along the lines of  foldr f "" str1 ?
14:23:14 <rwbarton> gurrag: yes
14:23:15 <adnauseam> yes
14:23:40 <monochrom> I am afraid that foldr doesn't talk about accumulators
14:23:54 <adnauseam> i thought of [], since "x" is 'x':[]
14:23:57 <adnauseam> hrm
14:24:43 <adnauseam> oh, it's foldl that has the accomulator
14:24:50 <adnauseam> grah
14:25:15 <adnauseam> so in foldr it'd be foldr f [] str
14:25:19 <kallisti> yes
14:25:23 <kallisti> or ""
14:25:28 <adnauseam> well atleast that's a step forward
14:25:40 <kallisti> > [] :: String
14:25:41 <lambdabot>   ""
14:25:52 <adnauseam> > 'a':""
14:25:53 <lambdabot>   "a"
14:25:59 <adnauseam> woah
14:26:01 <adnauseam> nice
14:26:16 <kallisti> strings are lists of charaters.
14:26:17 <adnauseam> sigh... thinking that foldr uses an accomulator all this time...
14:26:39 <adnauseam> the most dangerous thing is thinking you know something. god damnit if this continues i'll end up knowing nothing.
14:26:51 <kallisti> > foldr (const succ) 0 [5,32,6,12,6,2]
14:26:52 <lambdabot>   6
14:27:25 <adnauseam> waht.
14:27:40 <kallisti> foldr generalizes structurally recursion over a list. you can think of it as accumulating a value by traversing the list. in some sense, the accumulator is a state value.
14:27:46 <kallisti> *structural recursion
14:27:55 <adnauseam> hrm
14:27:57 <monochrom> > foldr (const succ) 0 [undefined, undefined, undefined]
14:27:58 <lambdabot>   3
14:28:00 <kallisti> or a simpler way to think of it
14:28:05 <adnauseam> oh o_0
14:28:07 <monochrom> may help you see what trick it is
14:28:14 <adnauseam> yeah, just noticed o_0
14:28:20 <tgeeky> monochrom: that's much less tricky compared to kallisti's
14:28:22 <tgeeky> ;)
14:28:32 <adnauseam> be gentle, i bruise easy
14:28:33 <adnauseam> =[
14:28:37 <monochrom> I intend to disenchant everything
14:28:38 <armlesshobo> what's the flag for ghc to not put debug info in the binary?
14:28:46 <kallisti> adnauseam: in foldr f z  you can think of f as replaing the :'s in the list, and z as replacing the []
14:28:49 <adnauseam> i was wondering what const succ did on the numbers really =P
14:28:50 <armlesshobo> i could have sworn there was a flag to disable that
14:29:01 <kallisti> adnauseam: it does nothing to them.
14:29:04 <gurrag> @t :
14:29:05 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
14:29:15 <adnauseam> kallisti: took me a bit to realize that, and monochrom
14:29:18 <geekosaur> :t (:)
14:29:19 <lambdabot> forall a. a -> [a] -> [a]
14:29:26 <adnauseam> :t const
14:29:27 <lambdabot> forall a b. a -> b -> a
14:29:43 <gurrag> what does the `.` mean in that type declaration?
14:29:53 <kallisti> it's the syntax to end a forall declaration
14:30:03 <monochrom> punctuation to separate the "forall a" from the rest
14:30:11 <monochrom> err, "forall a b"
14:30:28 <tgeeky> you can think of the prefix to a type signature: "forall a b c d e f g."
14:30:31 <djahandarie> dmwit, presumably something like ala MinPriority foldMap [f x, f y] if I understand the question correctly
14:30:38 <tgeeky> as something which lets you use a,b,c,d,e,f,g inside the type
14:30:46 <adnauseam> heh
14:31:00 <adnauseam> so it basically succ`ed the 0 and ignored what came after that, heh
14:31:01 <adnauseam> nice
14:31:14 <kallisti> adnauseam: so if you pass 1 : 2 : 3 : []  to foldr f z, it produces 1 `f` 2 `f` 3 `f` z
14:31:21 <kallisti> adnauseam: assuming `f` is right associative
14:31:29 <tgeeky> yep
14:31:33 <tgeeky> i'm working on a paper about this now
14:31:34 <geekosaur> armlesshobo, I don't think there's a ghc-spcific option, but try -optl-s
14:31:47 <armlesshobo> ok, will do
14:31:55 <gurrag> so forall is a guarantee that the type variables that follow can be of any type?
14:32:11 <kallisti> basically lambdabot is just being unecessarily verbose
14:32:32 <tgeeky> true, in this case, you can ignore what I'm saying :o
14:32:49 <kallisti> the type forall a b. a -> b is equivalent to just a -> b
14:33:15 <kallisti> there's an implicit forall on the outside of every type, that qualifies anything that wasn't explicitly qualified.
14:34:08 <gurrag> I see.  Thank you for all the help, kallisti
14:34:14 <tgeeky> is there a way to search hayoo or hoogle for kinds instead of types?
14:34:39 <monochrom> no, but that may be a great idea
14:34:42 <armlesshobo> geekosaur: isn't there a way to reduce the binary size?
14:34:57 <armlesshobo> geekosaur: right now it's 770kb, even after 'strip'
14:34:59 <tgeeky> monochrom: http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:*%20-%3E%20*%20-%3E%20*
14:35:17 <shapr> mmm, code
14:35:51 <geekosaur> I don't think so.  unless ghc itself was built wiht split-objs (which then makes compilation, or at least linking, much slower, I think)
14:35:53 <monochrom> there is no further way to reduce the binary size, unless you go dynamic linking
14:35:56 <gurrag> can Haskell make standalone binaries?
14:36:25 <copumpkin> GHC can
14:36:33 <adnauseam> kallisti: my f is a binary operation, namely a lambda of the form (\x y etc) x y
14:36:33 <copumpkin> (the main haskell compiler)
14:36:34 <monochrom> depends on compiler/interpreter. clearly, hugs (an interpreter) doesn't make standalone binaries
14:36:49 <kallisti> adnauseam: that's irrelevant
14:36:50 <ocharles> Hmmm, anyone free to help with some type/data family trickery? I have some values that can be stored in a database in 2 contexts. One context is for stuff that only has a primary key (generated by the database), and one where it has a primary key, but also a uuid gets generated.
14:36:51 <shapr> I like the new features in haskell-mode, even I can't get some of the features to work.
14:36:58 <kallisti> adnauseam: all functions passed to foldr are binary operations
14:37:05 <monochrom> on the upside, that means hugs type errors are postponed to run time, if that is what you want :)
14:37:10 <gurrag> can GHC statically link 3rd party Haskell libraries into the standalone binaries it generates? [i.e. Haskell bindings for OpenGL or SDL]
14:37:10 <adnauseam> wait, yeha it's irrelevant, i've just looked at foldr's def
14:37:15 <ocharles> I have 2 data types, Entity a = Entity { id :: Int, data :: a } and UUID a = UUID { id :: Int, uuid :: UUID, data :: a }
14:37:24 <geekosaur> gurrag, if you force libgmp to be linked statically, it comes down to whether your OS allows it (Solaris won't let you link statically if you use NSS; Linux's glibc will work but warn you of dire consequences if you copy the binary to another machine)
14:37:31 <kallisti> adnauseam: I'm assuming you've seen stuff like foldr (+) 0 ?
14:37:36 <adnauseam> yeah
14:37:45 <adnauseam> makes sense too, this one is being tricky though
14:37:52 <ocharles> I was going to have a type family to specify which context a certain entity has. So, type family Loaded a :: *, type instance Country = Entity Country, type instance Person = UUID Person
14:38:18 <adnauseam> hmm, i think the problem is that my lambda is actually an unary operation ?
14:38:23 <ocharles> The problem comes when I want to use instances against these type families. I could do: instance (Loaded Person ~ l) => Show l, but this ends up overlapping with other instances (like Show a => Show [a])
14:38:23 <kallisti> adnauseam: do you also see how the type of the second argument to foldr can be different from the type of the elements of the list? that's a pretty important thing to notice.
14:38:24 <adnauseam> not binary
14:38:29 * ski . o O ( ones run-time is another ones compile-time )
14:38:39 <ocharles> Should I stick with type families, or am I setting myself up for a world of pain?
14:38:44 <monochrom> "const succ" is a binary operation. const succ x y = (const succ x) y = succ y
14:39:01 <adnauseam> kallisti: yeah i've noticed that
14:39:12 <adnauseam> i think
14:39:21 <adnauseam> mhm
14:39:23 <kallisti> > foldr (:) [] [1,2,3]
14:39:24 <lambdabot>   [1,2,3]
14:40:19 <adnauseam> i'll toy with lambdabot in private for a bit and come back with an example of what i'm trying to do
14:40:38 <kallisti> adnauseam: as far as I can tell you want to remove substrings from a string
14:40:41 <kallisti> right?
14:41:02 <kallisti> I think that would be easier to implement as a recursive function rather than with foldr
14:41:08 <geekosaur> gurrag, for your last question, it depends on whether the static libraries are available and may depend on how dynamic the thing youre linking in is; some packages expect to be able to load their functionality as pliugins at runtime (like NSS that I mentioned earlier) and neither ghc nor any other compiler will be able to make a standalone executable reliably
14:41:08 <kallisti> but you could.
14:43:00 <adnauseam> kallisti: it's an academic exercise. implemented it recursively as well
14:43:09 <adnauseam> foldr is being tricky
14:43:14 <adnauseam> i'm also considering cps
14:43:16 <kallisti> adnauseam: I think to use foldr to implement substring removal you need to use a 3-tuple
14:43:18 <adnauseam> once that's done
14:43:22 <kallisti> at least a 2-tuple
14:43:30 <adnauseam> hmm
14:43:39 <kallisti> for example
14:44:31 <kallisti> > foldr (\x (len,sum) -> (len+1, sum+x)) (0,0) [1,1,2,3,5,8]
14:44:32 <lambdabot>   (6,20)
14:44:53 <kallisti> simultaneously takes length and sum in one traversal.
14:45:02 <adnauseam> myidea was to actually split the first substring into letters and go removing all letters of at substring in the main string:p it naturally goes overboard, but at least it answers the question
14:45:08 <adnauseam> hmm
14:45:48 <kallisti> what do you mean "by split the substring into letters"?
14:45:55 <kallisti> > id "hello"  -- splitting a string into letters
14:45:56 <lambdabot>   "hello"
14:46:29 <ski> > id ['h','e','l','l','o']  -- splitting a string into letters
14:46:30 <lambdabot>   "hello"
14:46:51 <adnauseam> to remove "abc" in "abccba",  i take 'a' and remove it from "abccba", and again for b and c
14:46:56 <SirFrancisDrake> hey there
14:47:09 <adnauseam> it ofcourse removes the whole string then
14:47:11 <kallisti> > filter (`elem` "abc") "abdb2u2jehbabada"
14:47:12 <lambdabot>   "abbbabaa"
14:47:20 <kallisti> > filter (`notElem` "abc") "abdb2u2jehbabada"
14:47:21 <lambdabot>   "d2u2jehd"
14:47:34 <SirFrancisDrake> is there a way to have an empty TVar Something?
14:47:37 <adnauseam> yeah.. my first function was a poor attempt at implementing filter
14:48:00 <adnauseam> implementing filter with old is however.. hrm
14:48:12 <adnauseam> foldr*
14:48:14 <ski> adnauseam : what would you get if you remoce `"abc"' from `"abacaba"' ?
14:48:20 <kallisti> foldr can't mimic filter very well, you'd need to use Maybe somewhere most likely.
14:48:33 <ski> @hoogle fnewr
14:48:33 <lambdabot> No results found
14:48:34 <rwbarton> SirFrancisDrake: maybe you want TMVar? or TVar (Maybe Something)
14:48:54 <adnauseam> ski: haven't thought of that, probably an error :/
14:48:54 <ski> kallisti ?
14:49:12 <SirFrancisDrake> rwbarton: not really, unfortunately
14:49:22 <adnauseam> hm
14:49:34 <kallisti> ski: oh wait nevermind
14:49:35 <Diablo3> > let java = 1; haskell = 0; in java > haskell
14:49:36 <lambdabot>   True
14:49:39 <kallisti> I'm just supid.
14:49:43 <Diablo3> supid sucks
14:49:59 <armlesshobo> lmao
14:50:07 <Luke> has anyone had any luck connecting to MS SQL Server with Haskell on Linux?
14:50:26 <Luke> I'm trying to use hdbc-odbc with the freetds driver
14:50:29 <kallisti> > let filter p = foldr (\x xs -> if p x then x:xs else xs) in filter (`notElem` "abc") "abcd"
14:50:30 <lambdabot>   Overlapping instances for GHC.Show.Show
14:50:30 <lambdabot>                              ([GHC....
14:50:32 <Luke> can't seem to connect
14:50:36 <ski> > foldr (\a f -> if even a && (a < 3 || a > 6) then (a :) . f else f) id [0,1,2,3,4,5,6,7,8,9] []
14:50:37 <lambdabot>   [0,2,8]
14:50:41 <SirFrancisDrake> rwbarton: suppose data A = A { p :: TVar B }, data B = B { pl :: [TVar A] }
14:50:43 <kallisti> > let filter p = foldr (\x xs -> if p x then x:xs else xs) [] in filter (`notElem` "abc") "abcd"
14:50:44 <lambdabot>   "d"
14:51:45 <adnauseam> yeah, i was trying to avoid a full solution =p
14:51:49 <SirFrancisDrake> rwbarton: creating B outside of STM monad is simple. Creating A outside STM isn't. But after that creation all I need is those TVar references
14:51:54 <adnauseam> but i see
14:51:56 <hayashi> > Just "saying, I" >> fail "to see the point in Java.  Any objections?"
14:51:57 <lambdabot>   Nothing
14:51:59 <hayashi> Good
14:52:14 <adnauseam> so trivial...
14:52:25 <adnauseam> ]it's almost sad...
14:52:39 * adnauseam goes and sits in the corner
14:53:06 <kallisti> adnauseam: foldr is nice and fundamental and important, but there's no reason to torture yourself using it to implement something "just because"
14:53:39 <ski> kallisti : except for the fun of it ;)
14:53:56 <kallisti> another reason is if a professor is telling you to do it
14:54:23 <shapr> Hm, I just realized it would sometimes be handy to get an explicit list of everything a module exports.
14:54:38 <shapr> And with hint wrapping the ghc-api, may be easy to do from haskell-mode
14:54:38 * ski imagines a manager telling you to implement all the web-scale stuff with `foldr'
14:55:08 <nand`> A monic morphism f is defined such that for any morphisms g,h: “f.g = f.h” implies “g = h”; but does this work in reverse? does “g = h” imply “f.g = f.h”?
14:55:09 <adnauseam> kallisti: i think it is the one function i'm really struggling to grasp
14:55:29 <nand`> wait, never mind; of course it must
14:55:35 <nand`> that's a silly question
14:55:37 <kallisti> > foldl (flip (:)) [] [1,2,3]
14:55:38 <lambdabot>   [3,2,1]
14:55:41 <monochrom> yes, the reverse is free, leibniz rule
14:55:49 * nand` hasn't fully woke up :)
14:56:35 <Luke> has anyone had any luck connecting to MS SQL Server with Haskell on Linux? I'm trying to use hdbc-odbc with the freetds driver. I'm getting the same issue this guy is: http://www.rhinocerus.net/forum/lang-haskell/576857-haskell-unixodbc-freetds.html
14:56:39 <Luke> 3 years ago
14:58:07 <kallisti> adnauseam: there's nothing particualarly difficult about it. I wonder why it's so confusing to you.
14:58:24 <adnauseam> me tooman
14:58:54 <adnauseam> i'm looking at the code now and it looks so tribial
14:58:56 <adnauseam> trivial
15:01:59 <Luke> zenzike: you around?
15:02:08 <adnauseam> does foldr in the filter implementation that you've given, actually takes x in chunks of the size of the first string ?
15:02:35 <kallisti> adnauseam: what
15:02:40 <kallisti> it doesn't do anything with strings
15:02:46 <kallisti> filter is a generic list function
15:02:48 <adnauseam> where in p x is then ==`ed to a three letter string, does x then also try to be a 3 letter string out of the second string ?
15:02:50 <kallisti> a string is a list of characters
15:03:00 <kallisti> no
15:03:09 <kallisti> filter is not black magic
15:03:30 <kallisti> you'd have to filter through every possible subsequence
15:03:31 <ski> > let filter p = foldr (\x xs -> if p x then x:xs else xs) [] in filter (`notElem` "abc") "abacabadabacaba"
15:03:32 <lambdabot>   "d"
15:03:59 <adnauseam> i'm wondering how x workshere in the lambda
15:04:08 <kallisti> x is a list element
15:04:15 <adnauseam> a single list element
15:04:18 <kallisti> yes
15:04:22 <kallisti> a string is... a list of characters
15:04:28 <kallisti> x is a character
15:04:35 <adnauseam> hrm
15:04:54 <adnauseam> wait a second, is the lambda pattern matching with x xs ?
15:05:08 <kallisti> it's pattern matching with the patterns x and xs, yes
15:05:14 <adnauseam> :O
15:05:15 <kallisti> those patterns match any possible input
15:05:21 <kallisti> ...so it's kind of a trivial thing to point out.
15:05:22 <adnauseam> i thought it needed to be a tupple
15:05:27 <kallisti> :t foldr
15:05:29 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
15:05:32 <kallisti> 2 argument function
15:05:37 <kallisti> believe in the type.
15:05:51 * hackagebot reform 0.1.1 - reform is an HTML form generation and validation library  http://hackage.haskell.org/package/reform-0.1.1 (JeremyShaw)
15:05:53 * hackagebot reform-happstack 0.1 - Happstack support for reform.  http://hackage.haskell.org/package/reform-happstack-0.1 (JeremyShaw)
15:05:55 * hackagebot reform-hsp 0.1.1 - Add support for using HSP with Reform  http://hackage.haskell.org/package/reform-hsp-0.1.1 (JeremyShaw)
15:05:57 <adnauseam> i only thought (x:xs) can be represented as that tupple
15:06:06 <kallisti> what?
15:06:12 <kallisti> there is no tuple in that type signature.
15:06:18 <kallisti> what tuple are you talking about?
15:06:19 <adnauseam> yeah
15:06:20 <crdueck> i've come across an issue with length's signature [a] -> Int, when i really need it to be [a] -> Integer. how can i get around this?
15:06:24 <adnauseam> oh wait a second
15:06:42 <nand`> so I guess I can strengthen “f.g = f.h implies g=h” to “f.g = f.h iff g=h” in the example earlier?
15:06:44 <adnauseam> i'm sorry dude, i'm involving you in my odd stream of thought trying to decipher this
15:06:56 <Saizan> crdueck: use fromIntegral to convert
15:07:05 <kallisti> :t genericLength
15:07:06 <lambdabot> forall b i. (Num i) => [b] -> i
15:07:49 <kallisti> @src genericLength
15:07:50 <lambdabot> genericLength []    = 0
15:07:50 <lambdabot> genericLength (_:l) = 1 + genericLength l
15:08:00 <adnauseam> the lambda always takes 2 elements x and xs since (\x xs..) 'a' ((\x xs..) 'b' ((...
15:08:22 <kallisti> adnauseam: yes
15:08:27 <adnauseam> holy shit :o
15:08:34 <kallisti> > foldr f z [a,b,c] :: Expr
15:08:35 <lambdabot>   f a (f b (f c z))
15:08:46 <adnauseam> dude, i understand now :o
15:09:32 <kallisti> and foldl is a left-associative variant
15:09:42 <kallisti> > foldl f z [a,b,c] :: Expr
15:09:43 <lambdabot>   f (f (f z a) b) c
15:10:14 <shachaf> foldl folds lists; foldr folds wrists.
15:10:30 <adnauseam> ought to get that on a tshirt o_0
15:10:51 * hackagebot reform-blaze 0.1 - Add support for using blaze-html with Reform  http://hackage.haskell.org/package/reform-blaze-0.1 (JeremyShaw)
15:11:56 <shapr> Hm, reloading with hint is not as easy as I'd hoped.
15:15:53 * hackagebot reform-happstack 0.1.1 - Happstack support for reform.  http://hackage.haskell.org/package/reform-happstack-0.1.1 (JeremyShaw)
15:16:18 <adnauseam> kallisti: is it worth implementing what i'm doing in CPS?
15:16:43 <kallisti> adnauseam: I don't know what the continuation would be.
15:16:46 <kallisti> but you could try. :)
15:16:51 <ski> nand` : yep
15:17:00 <adnauseam> oh lord.
15:17:40 * ski isn't sure what adnauseam is doing
15:18:22 <adnauseam> learning o_0
15:18:53 <ski> "implementing what i'm doing" -- implementing what ?
15:19:00 <nand`> ski: alright; using this strengthening I can go on to prove that if any composition if f is monic and (f.g) or (g.f) are monic; g is monic; same for epic, right?
15:19:22 <adnauseam> oh
15:19:23 <nand`> should be “prove that if f is monic”
15:19:38 <adnauseam> ski: the function hat removes a substring from another string
15:19:51 <ski> nand` : "any composition if f is monic" meaning ?
15:20:02 <nand`> ski: typo; see the sentence afterwards
15:20:14 <ski> adnauseam : i'm not sure what "removes a substring" means
15:20:39 <ski> nand` : still no clue
15:21:17 <ski> adnauseam : what should `remove "ab" "accb"' return ?
15:21:27 <ski> `remove "ab" "bcca"' ?
15:21:50 <ski> `remove "ab" "abcab"' ?
15:21:58 <nand`> ski: in other words, ‘f is monic’ & ‘f.g is monic’ iff g is monic; similarly ‘f is monic’ & ‘g.f is monic’ iff g is monic
15:21:58 <adnauseam> "cc"
15:22:10 <nand`> same is true for s/monic/epic
15:22:13 <adnauseam> and "c" respectively
15:22:40 <ski> adnauseam : so you want to remove all occurances of all the elements of the first list, from the second list ?
15:22:41 <rwbarton> surely 'g is monic' doesn't imply 'f is monic'
15:22:58 <rwbarton> so i think you have not phrased it quite right
15:23:01 <nand`> rwbarton: hmm, you're right; that's not a correct phrasing
15:23:23 <rwbarton> maybe, 'provided f is monic, the following are equivalent: ...'
15:23:29 <adnauseam> ski: yes - nowi'm thinking of how to implement it as continuation passing
15:23:31 <nand`> (‘f is monic’ & ‘f.g is monic’ -> ‘g is monic’) & (‘g is monic’ & ‘f.g is monic’ -> ‘f is monic’)
15:23:39 <nand`> holds true
15:23:42 <nand`> better?
15:24:00 <rwbarton> aha
15:24:10 <rwbarton> Those aren't both true though.
15:24:21 <ski>   monic (f . g) -> (monic f <-> monic g)  -- ?
15:24:39 <nand`> rwbarton: they are not? which half?
15:24:49 <monochrom> if f.g is monic, then g is monic. proof: g.x=g.y implies (leibniz) f.g.x=f.g.y implies (f.g monic) x=y
15:25:23 <solidus-river> how would i add multiple constraints to an input on a function, i'm just pulling this out of my arse but
15:25:29 <monochrom> "f is monic" is not used, and I doubt its usefulness
15:25:55 <solidus-river> functionName :: (Ord a, Show a) => a -> a
15:26:01 <rwbarton> and the other half is false, f may fail to be monic in a way that is not detected by g
15:26:10 <ski> solidus-river : should work, i think
15:26:17 <rwbarton> so that f.g is still monic
15:27:11 <khayyim> >>= is just a pipe, basically?
15:27:23 <ski> more or less, yes
15:27:26 <monochrom> "basically"
15:27:28 <saep> what if "f x = x^2", "g = (*1)" and "h= (*(-1))" ? :P
15:27:33 <ski> (`(>=>)' is more like a pipe)
15:27:41 <solidus-river> ski: thanks :)
15:28:42 <khayyim> I suppose I am about to run into >=> soon enough, then
15:28:51 <khayyim> What is the difference twixt the two?
15:29:09 <nand`> rwbarton: oh, I see the mistake I made now
15:29:38 <monochrom> (f >=> g) x  =  f x >>= g
15:29:38 <nand`> I saw g . (f.x) = g . (f.y) iff (f.x) = (f.y) and assumed g is monic; but this isn't necessarily true for morphisms which are not compositions of f
15:30:12 <monochrom> if you just lack that x parameter (e.g., getLine >>= putStrLn), you go with >>=
15:30:23 <khayyim> Okay, thanks
15:31:35 <monochrom> if you do have that parameter, e.g., (hGetLine >=> putStrLn) myhandle or hGetLine myhandle >>= putStrLn, you are free to use either
15:32:03 <nand`> in effect; (>=>) represents composition on functions of type “a -> m b” where m is a monad - it's even associative (f >=> g) >=> h  =  f >=> (g >=> h)
15:33:43 <ion> (const getLine >=> putStrLn) ()
15:33:44 <ion> ;-)
15:34:20 <khayyim> Is there a good math book I should be reading along with all this? Words like "associative" and "monic" and "composition" keep cropping up.
15:34:51 <adnauseam> discrete structures ?
15:35:12 <adnauseam> category theory ?
15:35:33 <monochrom> "associative" is basic algebra. "composition" is basic algebra or pre-calculus, function composition. "monic" is more abstract, category theory. for sets and functions, monic becomes injective
15:35:48 <adnauseam> it's alright to understand little of what the big guys are talking about though. step by step
15:35:58 <khayyim> Indeed.
15:36:48 <djahandarie> I don't really like the word "monic"
15:37:08 <monochrom> if f.g is injective, then g is injective. proof: g(x)=g(y) implies (Leibniz) f(g(x))=f(g(y)) implies (f.g injective) x=y
15:38:35 <monochrom> "monic" and "epic" seem to be inspired by "injective" and "surjective"
15:39:50 <rwbarton> I think "monomorphism" and "epimorphism" were earlier words
15:39:55 <khayyim> Thanks, all.
15:40:06 <monochrom> yes
15:40:31 <nand`> khayyim: I'm going through http://books.google.com/books/about/Basic_category_theory_for_computer_scien.html?id=ezdeaHfpYPwC&redir_esc=y
15:40:41 <monochrom> monochromism is a graph morphism that maps graphs to 1-colorable graphs :)
15:41:44 <djahandarie> @quote monochrom monochromism is a graph morphism that maps graphs to 1-colorable graphs :)
15:41:44 <lambdabot> No quotes match. My mind is going. I can feel it.
15:41:50 <djahandarie> Damn
15:41:59 <djahandarie> @remember monochrom monochromism is a graph morphism that maps graphs to 1-colorable graphs :)
15:41:59 <lambdabot> Done.
15:42:10 <hpaste> arun1 pasted “state monad & pipe” at http://hpaste.org/68805
15:42:13 <djahandarie> Getting old
15:42:22 <nand`> I didn't realize the similarity with monochrom's name until djahandarie pointed it out.. is that bad?
15:42:24 <djahandarie> Can't remember all these fangled lambdabot commands
15:42:51 <adnauseam> regarding tail recursion, saying that in f = t, f is recursive when t is variable means that t is never the same twice ?
15:42:54 <arun1> hello, can anyone help me understand why the code in my paste "state monad & pipe" fails to compile
15:42:59 <nand`> (in particular, since when he said “monochromism” a bug in my IRC software highlighted the “monochrom” portion of that word in the same color as monochrom's name)
15:43:12 <Peaker> arun1, why do you indent your code to the edge of the universe? :)
15:43:37 <ion> arun1: Add type annotations to top-level things and embrace the power of error messages.
15:44:07 <arun1> ah, textmate apparently did some funky stuff with spaces
15:45:04 <Peaker> arun1, you have a typo "jul" vs "jil" ?
15:46:01 <Peaker> arun1, jack uses "get" and "await" in the same monad. Is the Pipe monad an instance of MonadState? Does it give state monad features?
15:46:13 <hpaste> arun1 annotated “state monad & pipe” with “state monad & pipe (annotation)” at http://hpaste.org/68805#a68807
15:46:46 <arun1> no it doesn't Peaker but I want to
15:47:11 <arun1> Pipe monad only allows await and yield. I am wondering how to make a transformer that allows you to do both
15:48:44 <arun1> here is the declaration of pipe monad - http://hackage.haskell.org/packages/archive/pipes/1.0.2/doc/html/Control-Pipe-Common.html#t:Pipe .. I am trying to change the base monad to also do state
15:48:45 <nand`> type PipeState a b s m) = Pipe a b (StateT s m)  -- ?
15:49:40 <Peaker> arun1, Use StateT to transform it?
15:50:03 <rwbarton> before mucking about with pipe internals, have you considered applying StateT to Pipe or using a StateT monad as the internal monad of your Pipe?
15:50:04 <Peaker> (or Pipe to transform state, as nand` suggested)
15:50:21 <nand`> I'm never quite sure whether you want Pipe a b (StateT s m) or StateT s (Pipe a b m) for things like these
15:50:39 <nand`> it's always a bit of trickery by playing around with the type I actually want to implement and seeing which composition lets me realize it
15:50:55 * hackagebot wai-router 1.0.0.0 - Provides basic routing on URL paths for WAI.  http://hackage.haskell.org/package/wai-router-1.0.0.0 (MarekDolgos)
15:51:02 <rwbarton> are they actually different in this case?
15:51:16 <nand`> rwbarton: in this case I'm not sure, I have no idea how Pipe works
15:51:26 <nand`> but eg. with ErrorT they can be distinct
15:51:49 <rwbarton> yes, certainly
15:53:18 <arun1> I think I need Pipe a b (StateT s m) .. but that type alias PipeState doesn't typecheck
15:55:00 <arun1> pipe is essentially Pipe InputType OutputType baseMonad MonadFinalResultType
15:55:23 <arun1> only in my case basemonad has to maintain state
15:55:40 <rwbarton> yes, it looks fine...
15:56:08 <rwbarton> what kind of error are you getting?
15:56:32 <Peaker> arun1, if you have multiple monad capabilities implemented as transformer layers, you have to "lift" your actions to the right layer
15:56:40 <arun1>     Unexpected type `a b s m' where type variable expected
15:56:40 <arun1>     In the declaration of `PipeState (a b s m)'
15:56:57 <rwbarton> oh
15:57:06 <rwbarton> don't put those parentheses there
15:57:21 <Peaker> arun1, first, choose a monad type you'll be using.. what is it?
15:58:02 <arun1> Peaker, I need to yield values in the Pipe monad, guess I need to use lift for the state monand (get/put)
15:58:12 <Peaker> arun1, yes, or the other way around
15:58:13 <arun1> removing the () typechecked rwbarton, thanks
15:58:17 <adnauseam> what are examples of f=t where t is variable?
15:58:25 <kqr_> i'm confused about an issue wrt haskells strictness. i want to construct a tree where i don't beforehand know either depth or breadth of each branch, so there's no simple way to construct a data type for it. in lisp it's easy -- i'd just use nested lists -- but how do I do something similar in haskell?
15:58:37 <kqr_> staticness* i think, not strictness
15:58:57 <arun1> I am trying to write the signature of jil using PipeState now
15:59:07 <Peaker> kqr_, not sure how your question relates to strictness?
15:59:15 <kqr_> Peaker, no, i meant staticness
15:59:24 <ion> adnauseam: Variable?
15:59:32 <geekosaur> kqr_: recursive type.  think about how a list is defined, it's a recursive type
15:59:33 <Peaker> kqr_, data Tree a = Node a [Tree a]
15:59:53 <adnauseam> ion: http://www.haskell.org/haskellwiki/Tail_recursion variable o_0
15:59:54 <nand`> kqr_: do you want a rose tree?
15:59:54 <Peaker> kqr_, that's called a "rose tree". Each node has a value of type a and a list of children (which can be 0 or more)
15:59:56 <adnauseam> 1st axiom
15:59:57 <solidus-river> holy smoke learn you a haskell is loooong, just getting done with making types and type classes, with each chapter it gets longer
16:00:06 <kqr_> Peaker, oh
16:00:13 <adnauseam> solidus-river: i found beer helpful
16:00:18 <kqr_> Peaker, interesting, i didn't think of that
16:00:28 <kqr_> Peaker, is there any default implementation or should i just roll my own?
16:00:34 <adnauseam> just don't forget to spend 1-2hours outside in the sun
16:00:37 <Peaker> kqr_, the "containers" package has Data.Tree iirc
16:00:49 <Peaker> kqr_, http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html
16:00:52 <kqr_> Peaker, i'll take a look, thanks
16:00:56 * hackagebot wai-router 1.0.0.1 - Provides basic routing on URL paths for WAI.  http://hackage.haskell.org/package/wai-router-1.0.0.1 (MarekDolgos)
16:01:05 <adnauseam> ion: any idea what variable is supposed to be man ?
16:01:41 <adnauseam> i'm somewhat confused at how f must be in t, where also t is variable
16:01:59 <rwbarton> well t could be f
16:02:30 <adnauseam> variable here means interchangable then ?
16:02:55 <adnauseam> f a b = t a b, where t = f ?
16:03:53 <rwbarton> I think it means "a variable" as opposed to an application, a let-expression, a case-expression, a literal, ...
16:04:39 <adnauseam> hrm
16:04:51 <rwbarton> but the only way f can appear as a free variable in the expression t which is a variable is if t is just f itself
16:05:03 <adnauseam> righto!
16:06:26 <kylaline> Hello, how do you declare the expected type of type variables?
16:06:39 <nand`> kylaline: do you mean the expected kind?
16:06:57 <kylaline> yes
16:07:03 <nand`> (a :: * -> *)
16:08:36 <arun1> well, both Pipe and StateT take an 'm' and if I give them each other it looks like I have a recursive definition with PipeState.. any ideas on how to untangle? my def looks like this sofar jil:: PipeState String String (StateT String (Pipe String String ?) )
16:09:38 <hhb_> Does anyone have experience with conduits?
16:10:55 <nand`> arun1: eh, it would just be PipeState String String String wouldn't it
16:11:01 <nand`> since PipeState already includes the Pipe and StateT stuff
16:11:04 <mparodi> look at this example, the book I'm reading says that this holds: foldr f st (xs++ys) = f (foldr f st xs) (foldr f st ys)
16:11:11 <mparodi> but I believe it's not correct
16:11:46 <rwbarton> that is indeed not correct
16:12:09 <kylaline> nand`: (sorry, I didn't know what kind means but) I meant, eg in "data D x = D1 x | D2 x" , how do I specify that x should be Ord?
16:12:17 <nand`> when *is* it correct? only if f is associative?
16:12:40 <rwbarton> you would also need st to be the identity for f
16:12:59 <mparodi> http://paste.kde.org/483968
16:13:07 <mparodi> these are the types
16:13:11 <rwbarton> you can write a different valid right hand side for that equation, though
16:13:16 <nand`> kylaline: oh I see what you mean now; eg. data (Ord x) => D x = D1 x | D2 x  <- note that this definitions is considered bad practice
16:13:45 <weasels> why is it considered bad practice
16:14:11 <nand`> weasels: because then you need to put the Ord x constraint on every single function dealing with D, not just ones that actually require it
16:14:17 <mparodi> the problem is that f is of type a -> b -> b, and the right hand part says you can apply f (foldr f st xs) (foldr f st ys), but (foldr f st xs) is not of type "a"!
16:14:19 <weasels> oh
16:14:21 <kylaline> Thanks!
16:14:22 <mparodi> rwbarton, am I wrong?
16:14:25 <nand`> when really the data structure itself shouldn't be judging
16:14:28 <hpaste> arun1 annotated “state monad & pipe” with “state monad & pipe (annotation) (annotation)” at http://hpaste.org/68805#a68812
16:14:35 <rwbarton> that is a problem, yeah
16:14:47 <rwbarton> but for some specific f, it might be fine
16:14:48 <mparodi> alright, I found a bug on the book then u.u
16:14:56 <rwbarton> is it claiming that it holds for all f, st, xs, ys?
16:15:04 <nand`> sounds like it's fine for all monoids where f = mappend and st = mempty
16:15:22 <mparodi> this was supposed to holds for all f
16:15:23 <arun1> nand: thats right.. however it doen't seem to fit the inferred definition of my jil function
16:15:30 <rwbarton> another example, set xs = ys = [] and see what happens
16:15:48 <mparodi> ah, wait. no!
16:15:51 <mparodi> it says
16:16:21 <mparodi> f must be associative and st the identity for f
16:16:27 <mparodi> ok, it doesn't change anything, does it?
16:17:08 <nand`> arun1: the definition I gave isn't complete, you want something like :: PipeState String String String IO (); also there is the definition of PipeState?
16:17:17 <nand`> mparodi: then it's correct
16:17:25 <mparodi> why?
16:17:33 <kallisti> > foldr (\x -> (+1) *** (+x)) (0,0) [1,1,2,3,5,8] -- adnauseam
16:17:34 <lambdabot>   (6,20)
16:18:17 <mparodi> it only holds in case f is of type a->a->a
16:18:26 <nand`> because if f is associative then (a `f` b `f` c ...) `f` (a' `f` b' `f` c' ...) can have the parentheses restructured
16:18:34 <nand`> oh
16:18:36 <nand`> that you meant
16:19:36 <nand`> yeah; true, it only holds if f is assocative, st is the identity and f is closed over its codomain
16:20:01 <rwbarton> that is a presumption to talk about "associative"
16:22:16 <nand`> oh, indeed
16:22:24 <mparodi> <explanation needed>
16:22:57 <mparodi> f associative => f :: a -> a -> a
16:22:58 <mparodi> why?
16:23:46 <rwbarton> same way x even => x is a number
16:24:02 <nand`> mparodi: associativity states that, say (×)=f then (a × b) × c = a × (b × c); for this to work (×) needs to accept not only the variables a b and c but also a×b and b×c, respectively
16:25:16 <nand`> if both (a × b) × (c) and (a) × (b×c) are valid; it follows that the type of a×x is the type of a, and the type of b×c is the type of c
16:25:46 <nand`> that's only possible if all three involved types are the same
16:25:58 * hackagebot cpuid 0.2.2.1 - Binding for the cpuid machine instruction on x86 compatible processors  http://hackage.haskell.org/package/cpuid-0.2.2.1 (HenningThielemann)
16:26:34 * ski notes that `(.)' is associative
16:28:37 <nand`> oh; because (.) is polymorphic and thus can take different forms when used multiple times
16:29:42 <ski> right
16:29:52 <nand`> what I said earlier is only true for non-polymorphic functions; indeed the only non-polymorphic case of (.) is for (.) :: (a -> a) -> (a -> a) -> a -> a
16:29:58 <ski> (you basically used Hindley-Milner in your inference above)
16:30:00 <nand`> for some given a
16:31:05 <nand`> (where (.) is associative, that is)
16:31:14 <mparodi> let f = (\x y -> ord x + y)
16:32:01 <mparodi> ok, this f is not associative
16:32:09 <nand`> f :: Char -> Int -> Int; it can't be associative
16:32:14 <mparodi> yep
16:32:26 <mparodi> nice, then it holds always provided that f is associative
16:32:33 <nand`> (and st is the identity)
16:33:04 <mparodi> what a 'dark' exercise ¬¬
16:33:08 <hpaste> arun1 annotated “state monad & pipe” with “state monad & pipe (annotation) (annotation) (annotation)” at http://hpaste.org/68805#a68813
16:33:09 <ski> @type undefined `asTypeIn` \(.) a b c -> ((a . b) . c) == (a . (b . c))
16:33:10 <lambdabot> forall a. (Eq a) => a -> a -> a
16:33:23 <ski> @type undefined `asTypeIn` \(.) a b c -> [(a . b) . c,a . (b . c)]
16:33:24 <lambdabot> forall t. t -> t -> t
16:33:44 <nand`> ski: neat
16:33:59 <nand`> nice way to force type equality
16:34:06 <arun1> nand', rwbarton,Peaker thanks for the help… I fixed all the type signatures
16:34:26 <arun1> and got rid of the NoMonomorphismRestriction extension as well
16:35:42 <nand`> arun1: note that for local usage you may as well get rid of the ‘IO’ as well by defining PipeStateIO or whatever
16:35:50 <ski> arun1 : s/::/ ::/
16:35:51 <nand`> but that wouldn't necessarily shorten code
16:35:58 <Mathnerd314> :t asTypeIn
16:35:59 <lambdabot> forall a b. a -> (a -> b) -> a
16:36:12 <ski> @src asTypeIn
16:36:12 <lambdabot> a `asTypeIn` f = a where _ = f a
16:36:13 <lambdabot> infixl 0 `asTypeIn`
16:36:21 <ski> @type asAppliedTo
16:36:21 <lambdabot> forall t b. (t -> b) -> t -> t -> b
16:36:50 <ski>   f `asAppliedTo` a = f `asTypeIn` ($ a)
16:37:06 <ski> @type map `asAppliedTo` ord
16:37:07 <lambdabot> (Char -> Int) -> [Char] -> [Int]
16:43:51 <kqr_> Peaker and nand`: thanks guys, a rose tree was precisely what I wanted
16:44:49 <arun1> ok nand` , apparently the preflex bot is not allowing your nick to be granted karma :|
16:44:56 <arun1> worked for others
16:45:02 <nand`> doesn't matter
16:45:35 <mauke> preflex: karma nand`
16:45:35 <preflex>  nand` has no karma
16:45:50 <mauke> nand`++
16:45:52 <mauke> preflex: karma nand`
16:45:52 <preflex>  nand`: 1
16:46:01 <arun1> woa
16:46:05 <arun1> nand`++
16:46:10 <arun1> karma nand`
16:46:21 <nand`> you need to prefix preflex's name
16:46:28 <Peaker> kqr_, cool :)
16:46:29 <arun1> preflex: nand`++
16:46:36 <nand`> for the “karma command only”
16:46:40 <nand`> “karma”*
16:46:44 <nand`> preflex: karma nand`
16:46:44 <preflex>  nand`: 3
16:46:51 <nand`> nand`--
16:46:54 <nand`> nand`--
16:46:55 <nand`> preflex: karma nand`
16:46:55 <preflex>  nand`: 5
16:46:58 <arun1> preflex: karma nand`
16:46:58 <preflex>  nand`: 5
16:46:59 <nand`> ..
16:47:05 <nand`> mauke: what just happened there?
16:47:16 <mauke> free karma!
16:47:36 <nand`> ah well, it's just a number at the end of the day
16:47:42 <nand`> let's stop spamming the channel :P
16:48:39 * ski . o O ( `type Tree a = TreeK a Identity; data TreeK a k = LeafK (k a) | BranchK (TreeK a (\l -> TreeK a (\r -> k (l,r))))' )
16:49:38 <monochrom> wait, you can have lambda expressions in a data declaration?
16:49:55 <nand`> that's what I'm confused by as well
16:50:39 <ski> monochrom : you need to desugar it a bit to get it to work
16:51:58 <Mathnerd314> lambdas in types would be so useful...
16:53:14 <aristid> Mathnerd314: go to the dark side
16:53:32 <monochrom> come join the dark side!
16:53:47 <nand`> dark side?
16:53:47 <Mathnerd314> how do I join?
16:53:51 <ski>   type Tree a = TreeK a Identity
16:53:54 <ski>   data TreeK a k = LeafK (k a)
16:53:58 <ski>                  | BranchK (TreeK a (TmpLeft a k))
16:54:02 <ion> join :: DarkSide (DarkSide Force) → DarkSide Force
16:54:04 <ski>   newtype TmpLeft a k l = L (TreeK a (TmpRight k l))
16:54:06 <ski>   newtype TmpRight k l r = R (k (l,r))
16:54:13 <monochrom> ion++
16:54:13 <ski> ugly, but works
16:54:18 <aristid> Mathnerd314: http://wiki.portal.chalmers.se/agda/pmwiki.php
16:54:43 <aristid> Mathnerd314: but ion's proposal is beter
16:55:05 <nand`> ion: thanks, that was a hearty laugh :)
16:55:08 <ski> as an exercise, prove that `Tree' is a functor
16:55:48 <ski> also try writing down a couple of `Tree Integer's, e.g.
16:55:50 <Mathnerd314> ski: why not TreeK k a?
16:56:00 * hackagebot monadio-unwrappable 0.2 - Reversibly allow monad transformer stacks to run in IO  http://hackage.haskell.org/package/monadio-unwrappable-0.2 (AndrewMiller)
16:56:06 <ski> Mathnerd314 : if you prefer
16:57:16 <Peaker> Does UNPACK pragma work with a polymorphic type (that is instantiated to a monomorphic one at the use site?)
16:58:16 <Liskni_si> Peaker: Last time I tried, GHC issued a warning that it ignores the pragma.
16:58:24 <Peaker> Liskni_si, Yeah :(
16:58:40 <Peaker> so I'm supposed to make a monomorphic version just to make it unpacked? bummer
16:59:19 <Peaker> is there a hint for GHC to specialize/inline an instance for a particular type?
16:59:35 <sipa> yes, the specialize pragma
16:59:40 <Liskni_si> No idea. I used -funbox-strict-fields and choose not to care whether it ends up being unpacked or not. :-)
17:02:16 <Peaker> bummer, "pure" and "<*>" are not specializable
17:05:00 <shapr> howdy johnw
17:05:04 <shapr> How's code?
17:05:06 <johnw> hey shapr!
17:05:10 <johnw> code good
17:05:23 <johnw> just none of it in Haskell ;(
17:05:27 <shapr> Aw, too bad.
17:05:45 <johnw> i talked about haskell a lot with people last week, tho
17:05:57 <johnw> because there are a lot of correlations between that and C++ template metaprogramming
17:06:09 <shapr> STL as metaprogramming?
17:06:19 <johnw> no, not the STL
17:06:26 <johnw> the MPL
17:06:31 <johnw> (Boost.MPL)
17:06:38 <johnw> MPL = C++ MetaProgramming Library
17:06:49 <shapr> How is that connected to Haskell?
17:07:01 <johnw> you can translate simple Haskell programs into MPLl
17:07:03 <Peaker> C++ templates are an ugly purely functional programming language.. So there are some parallels with Haskell
17:07:26 <johnw> shapr: http://bartoszmilewski.com/2009/10/21/what-does-haskell-have-to-do-with-c/
17:07:44 <johnw> and also: http://aszt.inf.elte.hu/~gsd/s/cikkek/abel/haskelltmp.pdf
17:07:50 <ion> Is there do notation for C++ templates?
17:08:43 <shapr> Huh, interesting article.
17:09:10 <johnw> ion: I don't know enough to answer that
17:09:19 <monochrom> C++ template functions are usually Haskell polymorphic functions. that's the connection.
17:09:45 <ion> johnw: I was just making a bad joke.
17:09:59 <monochrom> heh
17:10:01 <johnw> ah :)
17:10:14 <johnw> as far as I know, no one has seriously attempted to implemented a Monad in C++ MPL
17:10:22 <nand`> ion: if there was, it'd almost feel like imperative programming in C++
17:10:26 <shapr> Yow, going from C++ to Haskell to C++ .. this paper is wild.
17:10:43 <monochrom> that's perverse
17:10:48 <shapr> Oh no, it's just from Haskell to YHC.Core to C++
17:10:59 <monochrom> ok, that is not perverse :)
17:11:37 <RylandAlmanza> Are there any socket libraries that come with the haskell platform? I would like to write an IRC bot for another channel, but I don't want to use any pre-made irc libraries.
17:11:53 <monochrom> look for the "network" package
17:12:11 <ion> hs2c++meta <Foo.hs >foo.cpp
17:12:17 <shapr> RylandAlmanza: Is it getting easier to write Haskell? Are you seeing how programs can be structured without objects?
17:12:22 <monochrom> if you use the haskell platform, you already have it
17:12:42 * monochrom uses Jackson structured programming
17:12:59 <shapr> johnw: I ran across some deep C++ compiler question in my CS255 class this past term, but forgot what it was before I had a chance to ask you.
17:13:01 <shapr> Next time...
17:13:03 <RylandAlmanza> shapr: Way easier! It's still hard, but I've come a long way from where I was a few days ago. Thanks for asking. :)
17:13:12 <shapr> RylandAlmanza: I'm glad you're making progress!
17:13:29 <nand`> ion: I.. that doesn't actually exist, does it?
17:14:07 <ion> nand: Probably not. You should implement it.
17:14:20 <nand`> fun school project that would be
17:14:26 <nand`> unfortunately I'd have to learn C++
17:14:38 <RylandAlmanza> monochrom: Wouldn't it be listed here, then? http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/index.html
17:15:02 <monochrom> no, no longer comes with GHC
17:15:47 <johnw> ion: something along those lines does exist
17:16:24 <johnw> ion: http://gergo.erdi.hu/projects/metafun/
17:17:05 <ion> Hehe, thanks.
17:20:33 <mgsloan> johnw: I think Bartosz Milewski / Eric Niebler were working on an MPL monad implementation.  It got a bit problematic
17:20:47 <mgsloan> so I guess that's what you mean by "seriously"
17:20:56 <johnw> yes, they were the main two people I was talking to about Haskell this past week :)
17:21:36 <mgsloan> gotcha :D
17:22:07 * mgsloan gtg - class is over heh
17:22:10 <johnw> i really miss haskell
17:22:25 <johnw> so I'm looking for ways to integrate it more into my life, despite any professional need atm
17:22:26 <mgsloan> yeah, haskell's that one girl
17:37:13 <shapr> johnw: Perhaps buy a sixteen core single die AMD system for $1000 and see how many ants you can simulate with STM?
17:37:52 <johnw> yeah, if only I didn't have to make money...
17:41:03 * hackagebot yesod-static 1.0.0.3 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-1.0.0.3 (FelipeLessa)
17:41:52 <kylaline> https://gist.github.com/2765704 <- this gives an error for the joker; what should I put in its place instead so that both D1 & D2 fit? If I put D, it also gives an error
17:42:59 <bland> I can't get cabal to install Text.JSON (dependency conflict).  Has anyone succeeded with this?
17:44:25 <siracusa> kylaline: You can't use the underscore for data constructors
17:44:38 <siracusa> or at least not like so
17:44:54 <kylaline> I guessed as much, but what should I put there instead?
17:45:44 <siracusa> I'd write a helper functions D a -> a and apply x to that function
17:46:08 <monochrom> you can't put anything there to mean the same thing.
17:46:22 <monochrom> I would just redesign the type D
17:47:06 <kylaline> okay.
17:48:29 <ski>   ... = MkD Bool x  -- maybe ?
17:54:13 <Gurrag> Is there any way to get GHCi for Windows not to "grab" Shift-backspace and instead treat it like normal backspace?
17:54:23 <Gurrag> [run from a DOS prompt window]
17:57:37 <RTU_> greetings comrads
18:03:45 <covi> Hi all. Why  (++) <$> "abc" <*> "def"  does not work?
18:05:29 <mgsloan> > (++) <$> pure "abc" <*> pure "def"
18:05:30 <lambdabot>   No instance for (GHC.Show.Show (f [GHC.Types.Char]))
18:05:31 <lambdabot>    arising from a use ...
18:05:36 <mgsloan> ah, nvm!
18:09:48 <Luke> hey guys, i'm trying to use HDBC. I have a Statement that works when i call 'execute' on it. but when I replace some of the values with ? and SqlValues, it fails to execute. any reason why execute would do this in it's replacements?
18:10:46 <covi> mgsloan: ? I don't understand. Can you please explain?
18:12:29 <mgsloan> covi: well, the applicative operators <$> and <*> are expecting members of applicative.  "abc" and "def" are applicative, because they are lists.  Lists are monads, and every monad implies an appropriate instance of applicative
18:13:13 <mgsloan> however, the function on the left of <$> operates on the members of the applicative functor (the type that's passed to it).  In the case of "abc" and "def" this is Char.
18:13:57 <mgsloan> so, the function should have type (Char -> Char -> Char), but instead it has type ([a] -> [a] -> [a])
18:14:09 <bland> Would someone please address the problem I'm having with Cabal?  Either that, or point me to a web page that explains it.
18:14:33 <dino-> I have a cabalized project with 3 executables and one test suite. When I do `cabal test` the test suite runs 3 times (suspiciously the same number of executable stanzas in my cabal file)
18:14:42 <mgsloan> > (curry fst) <$> pure "abc" <*> pure "def"
18:14:43 <lambdabot>   No instance for (GHC.Show.Show (f [GHC.Types.Char]))
18:14:43 <lambdabot>    arising from a use ...
18:14:46 <mgsloan> hrmm
18:14:55 <mgsloan> oh right, the pures shouldn't be there
18:15:00 <dino-> Does that sound familiar to anyone?
18:15:04 <mgsloan> > (curry fst) <$> "abc" <*> "def"
18:15:06 <lambdabot>   "aaabbbccc"
18:15:15 <shachaf> > pure <$> "abc" <*> "def"
18:15:16 <lambdabot>   "aaabbbccc"
18:15:32 <covi> :t <$>
18:15:33 <lambdabot> parse error on input `<$>'
18:15:38 <covi> :t (<$>)
18:15:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:16:04 <flebron> Hi. What's the idiomatic way to request that a type be a member of a typeclass, if it is to be used with some ctor of mine? Say, "data Eq a => Foo a = Something a | SomethingElse a"
18:16:07 <dino-> Luke: I'm wondering if that needs to be prepared first. But I'm just guessing.
18:16:30 <covi> mgsloan: I still don't understand. The strings are applicative functors, <$> is supposed to lift up the '++' and makes it applicable to the strings?
18:16:40 <flebron> (I'd like to have functions just request something of type Foo a, and not need a "Eq a => " in front of everything.)
18:16:41 <hpc> flebron: make the data type not care about the constraint, just assume it's there when you write the functions that work on it
18:16:51 <hpc> flebron: see also, the source of Map/Set/etc
18:16:59 <mgsloan> covi: It makes '++' applicable to the elements of the strings
18:16:59 <Luke> dino-: yeah I do. prepare, exec, fetchRows in that order
18:17:25 <mgsloan> covi: See how the function operates on "a" and "b"  (Char) and not "f a" and "f b" ([Char] aka String)
18:17:29 <Luke> dino-: exec does the replacement though
18:17:31 <flebron> Alright, thanks hpc.
18:17:43 <covi> mgsloan: I see!
18:18:07 <mgsloan> cool :D
18:18:59 <covi> So what can I do in this case? Use '++' to concatenate some strings with the applicative style
18:19:09 <dino-> Luke: Ah, I'm not sure what you're seeing then, the error or nature of failure.
18:20:19 <kuhrt> can someone help me disect/understand the type signature of the function composition operator
18:20:21 <kuhrt> (.) :: (b -> c) -> (a -> b) -> a -> c
18:20:29 <covi> (++) <$> ["abc"] <*> ["def"]
18:21:12 <covi> kuhrt: You can think of it as that it takes two functions, namely of types (b->c) and (a->b), and returns a new function of type (a->c)
18:21:19 <covi> > (++) <$> ["abc"] <*> ["def"]
18:21:21 <lambdabot>   ["abcdef"]
18:21:30 <hpaste> Luke pasted “HDBC” at http://hpaste.org/68815
18:21:34 <kuhrt> > :t (.)
18:21:35 <lambdabot>   <no location info>: parse error on input `:'
18:21:40 <Luke> dino-: ^
18:21:44 <covi> :t (.)
18:21:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:22:00 <kuhrt> :t (.)
18:22:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:22:08 <kuhrt> oh ok, that's how it works
18:22:30 <kuhrt> covi why is lambdabot different than ghci?
18:22:50 <covi> kuhrt: I don't know.
18:23:12 <kuhrt> covi: which one looks more correct to you? The one I pasted or lambdabot?
18:23:22 <mgsloan> covi / kuhrt: it's "caleskell"
18:23:46 <dino-> Luke: hm, can you show the code as well?
18:23:54 <Luke> yeah - real basic.
18:23:54 <dino-> (that looks evil, that error)
18:23:56 <kuhrt> mgsloan: is that another interpretor? What's the point
18:24:00 <mgsloan> the prelude for lambdabot is somewhat different, and has a better typeclass hierarchy for functor / applicative / monad
18:24:08 <covi> kuhrt: in lambdabot, (.) is just fmap
18:24:24 <mgsloan> kuhrt: the point is to confuse people looking for help.  I really don't know. I'm quite against it.
18:24:29 <covi> kuhrt: whereas in ghci, (.) has nothing to do with functors by default. that's what i think
18:25:00 <parcs`> mgsloan: it confuses some, it intrigues others
18:26:01 <kuhrt> covi: going back to my initial paste, your explaination made sense but what confused me is I thought the last value in type signatures was the return value (after the last '->') however it appears that there aren't any brackets around `a -> c`, why not?
18:26:04 <hpaste> Luke pasted “Query” at http://hpaste.org/68816
18:26:12 <Luke> dino-: ^
18:26:15 <kuhrt> covi: in other words why isn't it this: (.) :: (b -> c) -> (a -> b) -> (a -> c)
18:26:16 <mgsloan> parcs`: Sure!  I'm in full support of revising the prelude, but only both interfaces at once, not one at a time
18:26:32 <Luke> dino-: that works if I replace the strings directly. not if I use the exec replacement though
18:26:40 <dino-> kuhrt: There could be ( ) around the a -> c, but they're not needed at the end.
18:26:58 <dino-> Well, that's even not actually accurate. You really don't want them.
18:27:00 <kuhrt> parcs`: it looks like caleskell is more descriptive/verbose?
18:27:24 <kuhrt> dino-: why not? haha
18:28:11 <kuhrt> dino-: Because what's confusing me is it looks like `a` is a param, no?
18:28:28 <mgsloan> parcs`: I think it is bad to have (.) be in terms of functor, as it complicates type errors in the common case of operating on functions
18:28:30 <kuhrt> dino-: but in reality `a` is part of the return value, correct?
18:29:05 <mgsloan> parcs`: It's a clever observation, yes, but polymorphism distances type errors from their source.
18:29:20 <dino-> kuhrt: It actually could be supplied alone, and will be, later. Say if you give (.) the two functions. Now you have a new function from a -> c. And you will call that with an a
18:29:28 <mgsloan> and that's not a good property to have in your fundamental composition operator
18:29:38 <dino-> kuhrt: I see, it's barking about the ? for table names, is that what I'm seeing?
18:29:59 <dino-> Luke: I see, it's barking about the ? for table names, is that what I'm seeing?
18:30:02 <dino-> (oops)
18:30:18 <Luke> yeah
18:30:49 <Luke> dino-: I haven't seen anything against using the replacement for tablenames
18:30:55 <Luke> perhaps that's not the way to go though?
18:31:12 <mgsloan> parcs`: I think the way out of this mess will be to define fully generic modules, and then define modules that re-export type specialized versions of the same symbols.  Then, add a new language feature: local imports in where statements
18:31:13 <dino-> Luke: I'm not sure, only that I haven't (in very limited SQL experience) used ? for a table name.
18:31:25 <Luke> hmm ok thanks
18:31:29 <mgsloan> this will give us both full polymorphism and nice errors.
18:32:56 <dino-> Luke: Try to do that table name substitution with strings, maybe Text.Printf. See if it works.
18:33:14 <dino-> Luke: But I'm not clear on if that's legal SQL business.
18:33:33 <kuhrt> dino-: I think i understand in theory, but in practice not as much, could you demo a trivial use of (.) to show what you mean?
18:33:35 <mgsloan> parcs`: not to continue my rant :)  But, I think Caleskell is really in the vein of "avoiding success at all costs".
18:33:57 <mgsloan> It makes haskell seem more confusing and inconsistent than it should
18:36:08 <dino-> > ( (\x -> x * 2) . (\y -> y + 3) ) 2
18:36:10 <lambdabot>   10
18:36:26 <dino-> or..
18:36:34 <sipa> Luke: i think you can only replace values (expressions) by ? - how can the sql parse and typecheck without knowing the tables/fields being used?
18:36:45 <dino-> > (.) (\x -> x * 2) (\y -> y + 3) 2
18:36:47 <lambdabot>   10
18:37:03 <dino-> I just gave the (.) 3 arguments there, both times.
18:37:23 <kuhrt> dino-: gotchya.. ok thanks reading them over now
18:37:33 <dino-> But if you look at the first one, it's parenthesized off. So that's the (.) being given *two*
18:37:44 <dino-> And then that new function is being evaluated with 2.
18:37:50 <kuhrt> dino-: ah, yes
18:38:00 <kuhrt> kuhrt: that first example is currying?
18:38:10 <dino-> Can I do let bindings with lambdabot?
18:38:15 <mgsloan> Lambdabot is no the place to push a language design agenda.  I'm really peaved at this... Maybe once I finish my schoolwork I can send out an email about it
18:38:21 <sipa> dino-:
18:38:41 <dino-> kuhrt: I kind of prefer to call it partial application, but yes.
18:39:03 <sipa> > let a + b = 5 in 12.7 + ["bla"]
18:39:04 <lambdabot>   5
18:39:16 <geekosaur> dino-: let bindings are possible but not persistent.  there is also @let which goes into a persistent store (until all such are cleared all at once)
18:39:43 <dino-> > let f = (* 2) . (+ 3) in f 2
18:39:45 <lambdabot>   10
18:40:16 <dino-> kuhrt: Ok, so there we partially applied (.) to two functions and bound the new function (from a -> c) to f. Calling it later.
18:40:23 <mm_freak> mgsloan: i agree…  no doubt it takes some creativity to come up with (.) = fmap, but it isn't exactly useful, and there is a better way to generalize (.)
18:41:18 <kuhrt> dino-: ok
18:41:26 <mm_freak> kuhrt: currying can be summarized by two simple laws
18:41:28 <dino-> geekosaur: thank you!
18:41:33 <mgsloan> yeah - the category version is better, except even worse when it comes to over-polymorphisizing type errors that ought to be simple
18:41:35 <mm_freak> on type level:  a -> b -> c = a -> (b -> c)
18:41:40 <mm_freak> on value level:  f x y = (f x) y
18:42:02 <mm_freak> that is the gist of currying
18:42:29 <mm_freak> all functions take exactly one argument…  "multi-argument" functions are just single-argument functions that return a function
18:42:32 <kuhrt> mm_freak: handy gist, thanks for that
18:42:53 <mm_freak> and whenever you write f x y, you actually apply x to f, then y to the resulting function
18:42:58 <mm_freak> hence:  f x y = (f x) y
18:45:45 <dino-> mm_freak: That's a better way to describe it, yes. It's all functions of one argument to something else.
18:47:53 <mm_freak> i also think that partial application is not the same thing…  you can have partial application without currying
18:48:11 <kuhrt> mm_freak: how so? what's the difference?
18:48:41 <mm_freak> kuhrt: in languages with closures you can always construct a closure that partially applies a function
18:48:55 <kuhrt> mm_freak: right
18:51:12 <kuhrt> mm_freak: whereas with currying...? What's more about it?
18:51:58 <mm_freak> kuhrt: currying is the idea that a function maps values of a type to values of another type…  application performs this mapping
18:52:01 <mm_freak> that's it basically
18:52:37 <kuhrt> ok
18:52:38 <dmwit> Now to really confuse things.
18:52:40 <dmwit> :t curry
18:52:41 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
18:53:16 <mm_freak> what haskell does is to let the (->) notation be right-associative and application notation be left associative…  that is exactly the two laws i wrote above
18:53:41 <mm_freak> partial application then arises very naturally without the programmer even noticing it
18:54:12 <mm_freak> they aren't even "laws"…  they are just features of the haskell grammar
18:56:10 <mm_freak> in a C-like language currying would look like f(x)(y) and in C# IIRC the type would be Func2<A, Func2<B, C>>
18:56:19 <mm_freak> haskell has a more lightweight and "to the point" notation
18:56:48 * hackagebot ParserFunction 0.0.8 - Utilities for parsing and evaluating mathematical expressions.  http://hackage.haskell.org/package/ParserFunction-0.0.8 (EnzoHaussecker)
18:57:05 <monochrom> some old denotational semantics papers wrote f(x)(y) too
18:58:40 <kuhrt> so i'm not sure this is related but sometimes, it seems, (.) isn't necessary for instance:
18:58:58 <kuhrt> > (map succ) 2
18:58:59 <lambdabot>   No instance for (GHC.Num.Num [a])
18:58:59 <lambdabot>    arising from a use of `e_12' at <inter...
18:59:15 <kuhrt> > (map succ) [1,2]
18:59:16 <lambdabot>   [2,3]
18:59:22 <kuhrt> > (map . succ) [1,2]
18:59:23 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
18:59:26 <monochrom> Milner's type inference paper, too. "F(reverse)(x,y)" hehe
18:59:30 <mm_freak> kuhrt: (.) is used to compose functions, not to apply them
18:59:38 <kuhrt> mm_freak ah ok
18:59:50 <mm_freak> > (sin . cos) 3
18:59:52 <lambdabot>   -0.8360218615377305
19:00:36 <kuhrt> why doesn't `(map . succ) [1,2]` work?
19:00:49 <mm_freak> because that applies succ to [1,2], then map to the result
19:00:53 <mm_freak> and that's a type error
19:01:12 <mm_freak> notice that (map succ) and (map . succ) are not the same thing
19:01:41 <nand`> is the mtl's RWST internally implemented using StateT, ReaderT and WriterT?
19:01:49 <mm_freak> nand`: nope
19:01:53 <kuhrt> mm_freak why do the brackets for (map . succ) not act the same?
19:02:16 <kuhrt> i.e. making sure that occurs first, then the value `[1,2]`
19:02:17 <mm_freak> kuhrt: the brackets don't "act" at all…  they are just used for grouping application
19:02:20 <monochrom> wrong question. it is rather " " and "." not act the same
19:02:45 <mm_freak> kuhrt: look at the definition of (.)
19:02:53 <kuhrt> :t (.)
19:02:54 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:02:58 <mm_freak> (f . g) x = f (g x)
19:03:08 <mm_freak> first apply g, then apply f
19:03:41 <lpsmith> is there any fundamental reason why MVars can't be unpacked?   Or is the indirection a fundamental part of their operation?
19:03:53 <mm_freak> kuhrt: the type lambdabot gives is not the real type
19:04:02 <mm_freak> the real type is:  (b -> c) -> (a -> b) -> a -> c
19:04:20 <mm_freak> maybe clearer with an additional pair of parentheses
19:04:21 <kuhrt> (f . g . h) x = f (g ( h x ))?
19:04:28 <monochrom> yes
19:04:28 <mm_freak> (b -> c) -> (a -> b) -> (a -> c)
19:04:47 <mm_freak> lpsmith: what exactly do you mean by "unpacking MVars"?
19:05:01 <kuhrt> mm_freak: ya the extra parenthesis make it much clearer to me for now, that was something that got me into discussion with dino- before ha
19:05:35 <lpsmith> as in,   optimizing chan by defining   List a {-# UNPACK #-} !(MVar (List a))
19:06:20 <mm_freak> lpsmith: not sure, but that raises the question:  why would you want to unpack it?
19:06:49 <mm_freak> or rather:  why would you want to make it strict?
19:07:31 <lpsmith> to eliminate an indirection.   As for strictness, it's required for unpacking,  but I don't think it really makes much difference whether an MVar is strict or not.
19:07:43 <lpsmith> or rather,  a field of type mvar
19:07:59 <mm_freak> it does make a performance difference
19:08:31 <kuhrt> so to be totally clear `(map succ) [1,2]` is partial application and has nothing to do with map . succ which is function composition, further it would seem that `map . succ` doesn't seem too useful atoll since `succ` works on nums but `map` on lists
19:08:34 <mm_freak> strict fields are never faster than properly used nonstrict fields
19:08:55 <monochrom> that's right
19:09:03 <kuhrt> yay
19:09:17 <otters> why does catch require a function that takes a variable that needs a type signature, yet requires a GHC extension to be active to make that type signature valid?
19:09:22 <mm_freak> kuhrt: just expand yourself:  (map . succ) [1,2] = map (succ [1,2])
19:10:01 <kuhrt> mm_freak yup, ok, then everything clearly falls into place
19:10:10 <monochrom> does not require. you can use various non-extension means to nail the type
19:10:33 <tgeeky> is needing the extension to compile something the same as needing it to call something?
19:10:41 <mm_freak> otters: \x -> const (x :: SomeException) y
19:10:48 <mm_freak> that's one way
19:10:49 <otters> I see
19:10:55 <kuhrt> thanks so much for the help, starting to grasp the functional world; the concepts seem simple once clarified
19:11:06 <kuhrt> to oneself
19:11:09 <mm_freak> otters: you can also nail the type by letting 'x' be a constructor pattern
19:11:16 <mm_freak> \(SomeException x) -> …
19:11:36 <RTU_> num num num
19:11:40 <RTU_> num.
19:12:15 <mm_freak> kuhrt: it's just the subtle difference between (f x) y and f (x y) =)
19:12:33 <kuhrt> mm_freak: all the difference =)
19:12:56 <mm_freak> for me functional programming is really just:  "use folds instead of loops"
19:13:02 <mm_freak> map, filter, etc. are all folds
19:13:09 <otters> next question
19:13:15 <otters> this file imports Control.Exception
19:13:36 <otters> wait, never mind
19:13:55 <kuhrt> did anyone read this recent post about reducers? http://clojure.com/blog/2012/05/08/reducers-a-library-and-model-for-collection-processing.html
19:14:22 <kuhrt> how does haskell fair in comparison?
19:14:45 <monochrom> you use folds instead of loops because you use immutable data instead of mutable memory. there is nothing to loop over if you can't mutable memory
19:15:18 <monochrom> "for i=1 to 10: evaluate x+5" is a joke
19:16:05 <kuhrt> =)
19:16:21 <mm_freak> monochrom: well, loops can be constructive, but i get your point
19:16:22 <byorgey> kuhrt: see http://hackage.haskell.org/package/reducers
19:16:57 <mm_freak> my problem with loops is that they are too generic…  the genericity is the source of subtle bugs
19:17:09 <mm_freak> and it's also a lot more to write
19:17:53 <monochrom> I like generic recursion, despite your preference
19:19:22 <monochrom> I usually write the recursion, then tell you how to mechanically transform it away. for example see http://www.vex.net/~trebla/haskell/scanl.xhtml
19:19:27 <mm_freak> i like that one, too, but general recursion doesn't have the same problems as a loop in imperative languages
19:20:26 <mm_freak> especially when there is a static type system
19:20:50 <mm_freak> types in general recursion capture the structure of the algorithm, not just the types of variables involved
19:20:56 <mm_freak> hence far less potential for bugs
19:21:37 <mm_freak> it's a joke to use recursion to mutate a mutable variable like sometimes done in scheme
19:22:17 <otters> can .ghci have comments
19:22:39 <tgeeky> otters: yes
19:22:43 <monochrom> yes. starting telling it {- hello -}
19:22:49 <tgeeky> otters:  as well as --
19:22:59 <otters> hm
19:23:06 <otters> it gave me "parse error on input '--'"
19:23:33 <tgeeky> otters: -- this is a test
19:23:37 <tgeeky> that works for my .ghci
19:23:38 <otters> oh it worked
19:23:38 <monochrom> ask it {- can I take you out for dinner and movie? -} and it will not answer :)
19:23:39 <otters> it needs a space
19:23:41 <otters> afterwards
19:23:48 <tgeeky> otters: yes, exact same syntax as haskell
19:24:05 <monochrom> lesson for you to use {- -} instead
19:24:18 <tgeeky> no! those style of comments are bad, and you should feel bad!
19:24:46 <kuhrt> the reason brackets are neccessary in an exampe like `(f . g . h . i) 2` is because otherwise (i.e. f . g .h . i 2) function application would take the highest precedence and break function composing?
19:24:57 <monochrom> no, -- is bad
19:25:07 <solidus-river> is there a syntax for block comments in haskell?
19:25:33 <monochrom> yes. {- -} is block comment, unless I don't know what is block comment
19:25:41 <solidus-river> awesome!
19:25:52 <tgeeky> that's also a robot staring at you with eyes closed
19:27:23 <covi> Guys, do you mind sharing what your jobs are? I mean Haskell is so cool.
19:27:32 <otters> I'm a high school student
19:27:50 <covi> otters: me too, and sadly I'm graduating :(
19:27:50 <shapr> I'm a college student!
19:27:59 <mm_freak> otters: subtle syntax peculiarity…  comments start with the /token/ "--", not the string "--"
19:28:01 <otters> covi: my last day is tomorrow
19:28:09 <mm_freak> for example "---" is a regular operator
19:28:12 <monochrom> I do other students' homework
19:28:14 <tgeeky> i'm an ex-convict!
19:28:23 <covi> otters: sad
19:28:23 <tgeeky> that's not a job, though.
19:28:26 <zzo38> Actually I think in Haskell, two or more - together introduces a comment
19:28:31 <otters> going to college for comp sci
19:28:40 <tgeeky> zzo38: the comment token is literally: "-- "
19:28:41 <covi> which college, mind sharing, otters
19:28:47 <otters> u of cinci
19:28:49 <monochrom> no, actually, --- starts comment too. --| is a regular operator
19:28:49 <shapr> Hm, lambdabot uses mu-eval for its interpreter plugin, right?
19:28:56 <otters> and now BRB, showering
19:28:58 <tgeeky> monochrom: no, --- is valid haskell syntax
19:29:06 <tgeeky> monochrom: pretty sure?
19:29:09 <rwbarton> i thought --- is an operator but --a is a comment
19:29:15 <zzo38> tgeeky: I don't think so; -- followed by a letter also introduces a comment
19:29:20 <zzo38> It does not have to be space
19:29:29 <rwbarton> like mm_freak says, based on -- token
19:29:36 <monochrom> "An ordinary comment begins with a sequence of two or more consecutive dashes (e.g. --) and extends to the following newline." Haskell 2010 section 2.3.  "two or more"
19:29:42 <rwbarton> huh
19:29:44 <rwbarton> > 3 --- 5
19:29:45 <lambdabot>   3
19:29:51 <rwbarton> well, what do you know
19:29:53 <monochrom> I know that because I made that mistake here last year or something
19:29:54 <mm_freak> hmm
19:29:55 <zzo38> I think it can be --" and --` and --( and so on as well, but not --% and --^ and --> and so on
19:29:58 <mm_freak> > 3 --+ 4
19:29:59 <lambdabot>   Not in scope: `--+'
19:30:01 <mm_freak> ah
19:30:04 <mm_freak> weird
19:30:11 <mm_freak> i wonder why --- is not an operator
19:30:18 <tgeeky> > 3 --- 5
19:30:19 <lambdabot>   3
19:30:23 <zzo38> > 3 --" 5
19:30:24 <lambdabot>   3
19:30:27 <zzo38> > 3 --` 5
19:30:28 <lambdabot>   3
19:30:31 <zzo38> > 3 --( 5
19:30:32 <lambdabot>   3
19:30:33 <rwbarton> @type --- -- maybe monochrom is messing with us
19:30:34 <zzo38> > 3 --% 5
19:30:34 <tgeeky> something dirty is going on here
19:30:34 <lambdabot> <no location info>: not an expression: `'
19:30:35 <lambdabot>   Not in scope: `--%'
19:30:35 <monochrom> so as to let you write "------------------------------------------------" as a comment and for-human divider
19:30:40 <rwbarton> @type (---) -- maybe monochrom is messing with us
19:30:41 <lambdabot> parse error (possibly incorrect indentation)
19:30:42 <zzo38> > 3 --^ 5
19:30:44 <lambdabot>   Not in scope: `--^'
19:30:44 <tgeeky> @type (---)
19:30:44 <lambdabot> parse error (possibly incorrect indentation)
19:30:46 <zzo38> > 3 --> 5
19:30:47 <lambdabot>   Not in scope: `-->'
19:30:50 <tgeeky> lol
19:30:59 <zzo38> See? I did it correctly.
19:31:00 <tgeeky> > 3 --- 5
19:31:01 <lambdabot>   3
19:31:29 <rwbarton> so any --, ---, ----... token starts a comment
19:31:38 <tgeeky> oh. duh.
19:31:40 <mm_freak> > --
19:31:41 <lambdabot>   not an expression: `--'
19:31:41 * tgeeky feels stupid now
19:31:48 <mm_freak> > 3 --
19:31:49 <lambdabot>   3
19:31:49 <zzo38> rwbarton: Yes, as long as the token contains only two or more - and nothing else
19:32:05 <tgeeky> @let (--|) = text "sideways T"
19:32:05 <lambdabot>  Defined.
19:32:11 <tgeeky> > --|
19:32:12 <lambdabot>   <no location info>: parse error on input `--|'
19:32:16 <monochrom> ---| is an operator
19:32:23 <mm_freak> > (--|)
19:32:24 <lambdabot>   sideways T
19:32:39 <mm_freak> :t text
19:32:39 <monochrom> haha, who did it! who!
19:32:40 <lambdabot> String -> Doc
19:33:28 <tgeeky> > (--|--|--|--|)
19:33:29 <lambdabot>   [sideways T,sideways T,sideways T,sideways T]
19:33:53 <rwbarton> @type (--|--|--|--|)
19:33:54 <lambdabot> parse error (possibly incorrect indentation)
19:33:57 <byorgey> whaaat
19:34:02 <rwbarton> halp
19:34:30 <tgeeky> byorgey: that is weird
19:34:40 <zzo38> --|--|--|--| is also a operator name
19:34:54 <mm_freak> then you should be able to ask for its type
19:34:57 <tgeeky> you can ask for the type
19:35:07 <nand`> So I want to write a stateful computation that produces an RWST () action. I can't simple use “StateT s RWST ()” since that would conflict with RWST's MonadState instance, right? What's the appropriate solution here? Define my own newtype with differently-named functions?
19:35:18 <tgeeky> byorgey: it works in GHCi
19:35:27 <shachaf> I think @type's parser isn't the same as >'s.
19:35:29 <rwbarton> State s (RWST ())?
19:35:35 <shachaf> They do some validation of Haskell code before running it.
19:35:47 <rwbarton> :t (--|--|--|--|)
19:35:48 <lambdabot> parse error (possibly incorrect indentation)
19:35:48 <byorgey> nand`: sure, or you can explicitly use  'lift get' etc. to force it to use 'get' with the StateT part and not conflict with the RWST
19:36:14 <tgeeky> shachaf: but it is valid, so this is a bug of *some* sort
19:36:17 <byorgey> nand`: oh, or what rwbarton said, why do you have to use StateT?
19:36:17 <nand`> byorgey: that would work for me; I've never tried composing the same transformers before. Seems simple enough
19:36:22 <shachaf> tgeeky: Yes, it's a bug.
19:36:56 <nand`> byorgey: because I'm composing multiple stateful functions that, eventually at some point down the road, produce an RWST ()
19:36:57 <rwbarton> but just a bug in lamdbabot, or whatever lambdabot is using to parse
19:36:59 <mm_freak> it works in GHCi
19:37:02 <tgeeky> Redshift64: yeah
19:37:03 <tgeeky> mm_freak: yeah
19:37:05 <mm_freak> so perhaps it's a lambdabot bug
19:37:08 <nand`> and if I compose them without StateT I'd have to do all the plumbing manually
19:37:18 <zzo38> "StateT s RWST ()" is not a valid type, I think; the kind is wrong
19:37:39 <mm_freak> or perhaps it's an internet bug
19:37:52 <byorgey> nand`: I mean why StateT RWST instead of  State s (RWST ())
19:37:54 <nand`> zzo38: oh, err s/RWST/MyRWST/
19:38:01 <nand`> where MyRWST :: * -> *
19:38:07 <zzo38> nand`: OK
19:38:24 <tgeeky> ah yep. it's in lambdabot/plugin/Types.hs
19:38:27 <byorgey> "stateful functions that eventually produce an RWST ()" sounds like  State s (RWST ()) to me
19:38:43 <nand`> byorgey: yes; but I want to access the RWST part at any time
19:38:52 <nand`> maybe it'll help if I put it into context a bit:
19:38:56 <byorgey> ok, well then that's why =)
19:40:07 <tgeeky> the stripComments function in lambdabot is not correct.
19:42:02 <nand`> In my program, I have an over-arching state that contains a lot of stuff like my current peer connections, DHT table fragments and whatnot; plus reader for program configuration and writer for interacting with the connection handler. (I use “tell” to pass a new connection to the big bad :: IO () that's forking all of this) - the part I'm concerning myself right now is the interpreting of a single
19:42:05 <nand`> message, which sets and queries a state internally (it's processed from top to bottom according to some very specific rules) - right now, I have this “evaluation context” in my global state as a hack-around, but it really makes no sense there since it's strictly local to a single evaluation only
19:42:51 <zzo38> What would be laws for monad transformer and comonad transformer, such as,  fmap lower . lower . duplicate = duplicate . lower  would seem one law of homomorphism it seem to work except (Density []) but [] is not a comonad anyways. And, [] is a valid backward monoid transformer but not forward, Free is a backward monad transformer but not forward.....
19:48:27 <zzo38> I would also think   lift . join = join . lift . fmap lift
19:50:38 <zzo38> Are those supposed to be some of the laws of these classes?
19:51:12 <zzo38> (You would also have   extract . lower = extract   for comonad transformer and   return = lift . return   for monad transformer)
19:51:54 <rwbarton> lift should be a monad homomorphism, yes
19:53:28 <zzo38> rwbarton: Does the documentation mention that? It make sense to me but I don't know if they do to the documentation
19:55:06 <zzo38> They mention   return = lift . return   but not    lift . join = join . lift . fmap lift
19:55:33 <zzo38> The comonad transformer documentation mentions not any law as far as I can see
19:56:37 <rwbarton> i don't know
19:56:54 <otters> Can you get the package version number specified in the cabal file, in your code?
19:57:24 <zzo38> otters: Can you give an example what you are trying to make?
19:57:56 <otters> Well I'd like to be able to provide it to a server that the program connects to
19:58:21 <otters> But a sample would just be like main = do { vers <- getVersionNumber; putStrLn vers }
19:58:43 <zzo38> otters: I suppose you could tell it to include the .cabal file in the install directory
19:59:19 <otters> well it's not critical, I just wondered if there was a convenience function
19:59:29 <jmcarthur> there's some module that gets generated, isn't there?
19:59:35 <jmcarthur> under dist somewhere
19:59:43 <jmcarthur> i think there's a way to use it in your code
19:59:51 <otters> paths, right
20:01:07 <mefisto> I'm going through learn you a haskell and I'm confused about an aspect of functors. so if you do :t fmap (*2) it's fmap (*2) :: (Num a, Functor f) => f a -> f a ... so 'Functor' seems to be referring to the function itself? When it says "f a" I'm not clear what the f part means exactly
20:01:52 <zzo38> mefisto: The "f" means something which has instance of Functor class, such as [] or Maybe or IO
20:02:04 <jmcarthur> mefisto: it can mean many things, but yes, one thing f can be is something of the form ((->) a)
20:02:22 <jmcarthur> mefisto: in which case fmap = (.)
20:03:12 <mefisto> zzo38: jmcarthur: so mentally one can replace the "f" with like various type constructors or a partially applied function
20:03:13 <mefisto> right?
20:03:19 <jmcarthur> mefisto: but that's not what f is there. f is really not any specific thing in your example
20:03:31 <jmcarthur> mefisto: right. anything having kind  * -> *
20:03:51 <jmcarthur> mefisto: well, so long as it is an instance of Functor, of course
20:04:27 <mefisto> because that's required by the type declaration earlier
20:04:39 <mefisto> are all partially applied functions an instance of functor then?
20:04:49 <jmcarthur> umm
20:04:50 <mefisto> (as long as they only need 1 more argument)
20:05:03 <mefisto> (or more than that I guess)
20:05:07 <zzo38> For example,   fmap reverse getLine   is a I/O action which asks the user for a line of input but results in the reversed text. The type is    fmap reverse getLine :: IO String
20:05:15 <jmcarthur> not necessarily. the instance would have to be defined somewhere
20:05:22 <rwbarton> the partially applied function *type* (->) a is what is an instance of Functor
20:05:24 <jmcarthur> and i assume by "function" you mean "type constructor"?
20:05:54 <jmcarthur> @instances Functor
20:05:55 <lambdabot> ((,) a), ((->) r), ContT r m, Either a, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
20:05:59 <jmcarthur> those are a few
20:06:12 <jmcarthur> > fmap (*2) (1,2)
20:06:13 <lambdabot>   (1,4)
20:06:16 <jmcarthur> > fmap (*2) (Just 5)
20:06:17 <lambdabot>   Just 10
20:06:20 <jmcarthur> and so on
20:06:44 <mefisto> jmcarthur: I was referring to things of the form ((->) r) there... just making sure I understand correctly that the (->) in there can be any function
20:07:14 <zzo38> Any Monad is (should be) also Functor
20:07:30 <mefisto> zzo38: I haven't gotten to Monads yet :D
20:07:34 <jmcarthur> (->) is the type constructor for functions. it has kind * -> * -> *  (well, ghc will lie and say it has some other kind, but all you care about is the simpler one)
20:07:35 <zzo38> mefisto: (->) is a type of kind (* -> * -> *) it is not a functor
20:07:49 <jmcarthur> ((->) a), however, has kind * -> *
20:08:11 <jmcarthur> :k (->)
20:08:12 <lambdabot> ?? -> ? -> *
20:08:14 <jmcarthur> ^^ lies
20:08:43 <jmcarthur> :k ((->) Int)
20:08:44 <lambdabot> ? -> *
20:09:17 <augur> koninkje1away: ping
20:09:22 <foo42> :k Int
20:09:24 <lambdabot> *
20:09:45 <jmcarthur> the ?? and ? things are superkinds of *, i think
20:09:57 <zzo38> jmcarthur: Yes
20:10:08 <mefisto> also in ((->) r) is the r a type or an argument? I don't think I've gotten quite clear on where the border between type land and non-type-land lies
20:10:09 <jmcarthur> for unboxed thingies and such, iirc
20:10:28 <zzo38> mefisto: It is a type argument
20:10:38 <jmcarthur> mefisto: we routinely botch that terminology
20:11:07 <jmcarthur> mefisto: being pedantic, anything of kind * is a type. anything of any more complicated kind is really a type constructor
20:11:55 <jmcarthur> mefisto: and types are arguments to type constructors. other type constructors can also be arguments to type constructors
20:12:21 <jmcarthur> so if Foo :: (* -> *) -> * -> *, Foo's first argument is a type constructor, and its second argument is a type
20:12:52 <jmcarthur> :k ReaderT
20:12:53 <lambdabot> * -> (* -> *) -> * -> *
20:13:50 <jmcarthur> ReaderT r m a  -- r is a type, m is a type constructor, a is a type, ReaderT r m a is a type
20:15:07 <mefisto> zzo38: what is a "type argument"
20:15:24 <zzo38> mefisto: I think jmcarthur gave an example isn't it?
20:15:40 <jmcarthur> mefisto: a type argument is just a type that's being used as an argument to a type constructor
20:16:01 <jmcarthur> it's not distinct from a type in any meaningful sense
20:16:21 <mefisto> ok
20:17:13 <mefisto> thanks for your help
20:17:19 <jmcarthur> np
20:17:30 <jmcarthur> i hope it was actually helpful
20:18:40 <mefisto> I wrote out several pages of notes trying to nail this concept down... it's turning out to be the most challenging one in haskell for me so far
20:18:57 <jmcarthur> are you at all familiar with C++ templates or anything similar?
20:20:45 <jmcarthur> mefisto: a "type argument" might be something like a template parameter
20:21:07 <jmcarthur> mefisto: but if that argument is actually a type constructor, then it's more like a template template parameter
20:24:45 <ClaudiusMaximus> aarg.  my hack that worked in ghc-7.4.1 no longer works in ghc-7.4.2rc1, failing with     The exact Name `t_a9t2' is not in scope
20:24:48 <ClaudiusMaximus>       Probable cause: you used a unique name (NameU) in Template Haskell but did not bind it
20:25:14 <jmcarthur> that's what you get for using hacks
20:25:18 <jmcarthur> <-- king of hacks...
20:25:19 <ClaudiusMaximus> the hack was to generate an instance and then modify it
20:25:41 <ClaudiusMaximus> specifically because i haven't figured out how to generate an instance with constraints directly..
20:29:16 <hpaste> ClaudiusMaximus pasted “template haskell hell” at http://hpaste.org/68817
20:29:46 <ClaudiusMaximus> the hack is on line 42, and no longer works :(
20:31:58 <mefisto> jmcarthur: I never did any C++ although I have seen a liiiittle bit about the template snytax. I came from a web programming language which shall remain unnamed whose name begins with P
20:35:46 <ClaudiusMaximus> i think i'll just write it out by hand for now, i wanted to try the rc because it might reduce the gc_alloc_block_sync slowdowns
20:36:45 <JoeyA> I'm looking at the documentation of Shake, and one of the examples includes this line: addOracle ["ghc"] $ return ["7.2.1"]
20:36:57 <JoeyA> How does Shake know to pass --version or similar to the program?
20:37:01 <JoeyA> Is that specified elsewhere?
20:39:16 <Ralith> JoeyA: what I usually do in these situations is grep.
20:39:36 <solidus-river> how do you import a module in ghci?
20:39:56 <dmwit> :m + Foo.Bar
20:40:04 <dmwit> new GHCs allow import Foo.Bar as well
20:41:18 <solidus-river> hmm, it couldn't find System.Random has the name changed or have i just not installed the necissary module
20:42:09 <dmwit> JoeyA: I think (addOracle ["ghc"] $ return ["7.2.1"]) adds an *answer*.
20:42:35 <dmwit> solidus-river: Have you got the "random" package installed?
20:42:40 <dmwit> try "ghc-pkg list random"
20:42:43 <dmwit> at the command line.
20:43:34 <dmwit> JoeyA: If you want it to do something other than always answer ["7.2.1"], you have to write an Action that does the right thing, e.g. calls out to ghc --version.
20:45:06 <solidus-river> dmwit: /usr/lib64/ghc-7.4.1/package.conf.d
20:46:01 <dmwit> solidus-river: Install the "random" package, then.
20:46:10 <JoeyA> dmwit: Oh, okay.  I'm not familiar with the terminology of questions and answers.  Perhaps I should learn Shake first, then ask such questions.
20:46:38 <JoeyA> "... questions and answers" w.r.t. Shake, of course
20:46:46 <dmwit> right
20:52:04 <dmwit> solidus-river: And vote for this feature request that I just filed: http://hackage.haskell.org/trac/ghc/ticket/6119 =)
20:55:07 <solidus-river> dmwit: :P will do
21:03:17 <zzo38> Can you tell me what is the feature request?
21:04:15 <zzo38> Will System.Random properly provide a uniform choice of three values?
21:06:45 <zzo38> Since, no power of 2 is ever divisible by 3
21:07:14 <zzo38> But there are some ways to make it uniform such as the way TeXnicard uses
21:07:57 <dmwit> zzo38: It seems to be pretty uniform.
21:08:04 <dmwit> Prelude System.Random> f 1000000
21:08:04 <dmwit> (333349,333533,333118)
21:08:50 <dmwit> The feature request is to change the output of ghc-pkg list so that it says something like "no packages match the given query" instead of just printing an empty list of lines.
21:09:24 <zzo38> dmwit: Then it should print that message to stderr instead of stdout, if it does at all.
21:09:40 <dmwit> Don't tell me. Comment on the ticket.
21:10:02 <dmwit> (I don't agree with you. This is not an error condition.)
21:10:40 <dmwit> If it successfully searches the package database and returns 0 hits, that's not an error. That's a real answer to your query.
21:10:58 <dmwit> I'm just asking that the answer be printed differently than it currently is.
21:11:30 <zzo38> dmwit: I agree that it is not an error; however, it is not a package name either, so it should be on stderr so that if stdout is pipe to another program it will read the result list properly
21:12:03 <nand`> I'm not quite too sure what this is about but wouldn't you usually have a flag to distinguish between “raw” output (which would indeed be an empty list of lines) and a “human-friendly” output which would tell you about the error condition?
21:12:25 <nand`> s/error//
21:12:25 <dmwit> Yes, I would prefer the addition of a non-default "machine-readable" mode.
21:12:32 <zzo38> nand`: Well, that is another way
21:12:56 <mzero> dmwit - I'm not sure that changing the default output of that command is such a good idea - too many scripts might well depend on it
21:13:03 <mzero> at this point
21:13:15 <nand`> I know that some other utilities, eg. components of the gentoo package manager, somehow automatically detect whether or not their output is being piped to some other program; I don't know how it works but if I run it in a console I get human-readable output, but if I pipe it to something like cat I get the machine-processable version
21:13:19 <dmwit> Really? What scripts call ghc-pkg instead of just using the Cabal library?
21:13:48 <dmwit> Heck, who writes scripts for this stuff anyway?
21:13:49 <zzo38> But I prefer the UNIX way where a program does one thing and where anything that isn't the machine-readable output data is sent to stderr and then all program can be piped and `...` and so on
21:13:55 <dmwit> cabal is just too good to need anything else.
21:15:31 <nand`> zzo38: alternatively, it could be printed to stderr with a “verbose warnings” flag
21:15:36 <nand`> and treated as a warning, not an error
21:15:43 <dmwit> But again... while I don't agree with these complaints, other people might. So add them to the ticket!
21:15:48 <zzo38> user friendly (n.) 1. Programmer hostile.
21:16:12 <zzo38> nand`: Well, I suppose it might be considered a warning. But what I am saying is that stderr is not necessarily only for error messages.
21:16:17 <zzo38> dmwit: OK
21:17:06 <nand`> zzo38: right, that's what I was hinting at as well
21:18:34 <dmwit> programmers deserve a little hostility
21:21:14 <zzo38> I dislike that "dvilj" and its related programs require you to explicitly specify "-" if you want to use stdin/stdout; in my opinion it should just always use stdin/stdout, and if you want documentation you can read the man page
21:22:59 <zzo38> "dvilj < paper.dvi | lp" doesn't work; you need to specify "dvilj - < paper.dvi | lp" to get your document to print.
21:26:15 <flebron> What's the short way of writing f a b c = g $ h a b c?
21:26:31 <nand`> @pl f a b c = g $ h a b c
21:26:31 <lambdabot> f = ((g .) .) . h
21:27:02 <nand`> or f = g .:: h
21:27:11 <flebron> … yeah I think I'll stick with repeating parameters :p
21:28:45 <hhb_> I'm trying to get good performance out of a Datagram server, but I always loose the majority of packets. I don't have this problem in Java and C++. I'm using forkio and recvFrom sock. What should I being doing differently?  http://hpaste.org/68818
21:31:22 <hpaste> flebron pasted “LL1 parser” at http://hpaste.org/68819
21:31:38 <flebron> ^-- Stylistic comments? (Sort of beginner here)
21:31:54 <hhb_> BTW, I'm on Mac OS so I suppose that recvFrom should be kind of non-blocking as long as there are threads.
21:33:16 <kylaline> I can't figure out how to read 1 character. hSetBuffering stdin NoBuffering doesn't seem to help
21:35:52 <jtobin> all: is there a 'duh' way to more efficiently generate a pair of different random Ints within some bound?  present code (using MWC) looks something like: pairGen gen bound = do {a <- uniformR (1, bound) gen ; b <- uniformR (1, bound) gen ; if a == b then (pairGen gen bound) else return a b}
21:36:47 <strager> flebron: You can eta-reduce line 14
21:36:53 <mm_freak> hhb_: your main bottleneck is String
21:36:54 <strager> chop off the 's' from both sides
21:37:10 <flebron> Ah, yes.
21:37:15 <JoeyA> kylaline: What OS?
21:37:19 <strager> Any reason you're not using the State monad?
21:37:19 <mm_freak> jtobin: yes
21:37:25 <flebron> Thank you :)
21:37:31 <kylaline> JoeyA: windows 7
21:37:38 <flebron> strager: Learning purposes, reimplementing the wheel on purpose :)
21:37:58 <flebron> I also didn't know if I really needed the state monad - do I?
21:38:01 <strager> I see
21:38:02 <mm_freak> jtobin: first of all for efficiency try mersenne-random…  it has been faster than mwc-random in my benchmarks
21:38:04 <JoeyA> kylaline: Is it not working even after you press enter?
21:38:14 <flebron> Oh, right, I think I do.
21:38:19 <mm_freak> jtobin: then loop only for the second number…  let me write an example
21:38:20 <JoeyA> If so, it might be this bug: http://hackage.haskell.org/trac/ghc/ticket/2189
21:38:21 <strager> flebron: I comment what I'm parsing when I write parsers, either near the AST or near the parser =]
21:38:29 <flebron> Each character handling function can do something with the character, _and_ modify the stack.
21:38:34 <strager> Since you're not using parsec I can't see what you're really aprsing
21:38:35 <strager> parsing*
21:38:42 <JoeyA> (Windows is a second-class citizen regarding GHC IO support)
21:38:50 <flebron> Hence it can take a (Char, [Symbol]) and return a (Char, [Symbol]), which would seem to hint at State.
21:39:12 <kylaline> JoeyA: it works after enter; in cygwin it does the same
21:39:12 <jtobin> mm_freak: hmm that's the second recommendation i've gotten to try mersenne-random
21:39:24 <jtobin> mm_freak: so it must be true :)
21:39:33 <JoeyA> kylaline: Oh, okay.  That's because the *terminal* is not flushing its output per character, only per line.
21:39:33 <strager> flebron: Sounds reasonable.
21:40:10 <JoeyA> You have to do some trickery to convince the console to give you input a character at a time.  E.g. http://stackoverflow.com/a/421871 (that's for C/C++, though)
21:41:10 <mm_freak> jtobin: as a side note, mersenne-random is really inconvenient, mostly because it doesn't expose a System.Random interface…  personally i use cprng-aes
21:41:12 <kylaline> thanks!
21:41:15 <JoeyA> Err...
21:41:16 <strager> flebron: snake_casting_is_not VERY_COMMON_IN_HASKELL
21:41:20 <JoeyA> See http://stackoverflow.com/questions/2983974/haskell-read-input-character-from-console-immediately-not-after-newline
21:41:27 <mm_freak> jtobin: of course that's true for mwc-random as well
21:41:45 <flebron> strager, what is snake casting?
21:41:54 <JoeyA> kylaline: On Linux, hSetBuffering stdin NoBuffering >> getChar does return the character immediately (before pressing enter), at least with GHCi.
21:41:55 <strager> flebron: Oh, I see that you *aren't* using a state monad; your do block are for Maybe.
21:42:05 <strager> flebron: casing, sorrt.  this_style_of_writing
21:42:16 <flebron> Ah, what's preferred?
21:42:17 <hhb_> mm_freak: I thought recvFrom returned a ByteString and I thought I could some how put the expensive string work in a thread. http://hackage.haskell.org/packages/archive/network/2.3/doc/html/Network-Socket-ByteString.html#v:recvFrom
21:42:19 <kylaline> JoeyA: strange that it doesn't in cygwin/bash then
21:42:32 <strager> What the Prelude has.  lowerCamelCase and UpperCamelCase
21:42:49 <JoeyA> kylaline: Again, I think you're seeing a Windows-specific bug.
21:43:31 <mm_freak> hhb_: the point is not to go through a String at all
21:43:57 <JoeyA> Works for me with ghc (7.0.3 | 7.2.2| 7.4.1) under Ubuntu 10.04 64-bit.
21:44:32 <flebron> So I'm currently using Maybe to signal that a parse was unsuccessful. I'd like to report better errors, and I'm thinking Either. What is the correct way to add this additional behavior onto the program?
21:44:36 <mm_freak> hhb_: stuffWriter :: Chan String -> IO ()
21:44:52 <mm_freak>             (msg, _, host) <- recvFrom socket 4096
21:44:52 <mm_freak>             forkIO $ writeChan ch msg
21:45:02 <mm_freak> so it can't be a ByteString, because that would be a type error
21:45:27 <jtobin> mm_freak: i will certainly take a look at mersenne-random.  trying to squeeze out a bit of performance and this silly pairGen is the last particularly low-hanging fruit
21:45:33 <hhb_> mm_freak: but what if I will do even more expensive things with my message? I want to be able to do that in a thread and have the network not block.
21:45:40 <jtobin> mm_freak: a quicker PRNG and more sensible code will likely do the trick
21:45:50 <jake__> Hi, so I'm trying to use ghci as a calculator but am still fairly new. I'm not sure why this doesn't work: [ (magnitude z) * z | z <- [(0 :+ 1),(0 :+ 2),(0 :+ 3)] ]
21:46:03 <mm_freak> jtobin: well, the first step is to write an efficient function to extract a random number within a given bound
21:46:07 <jtobin> mm_freak: mwc seems fine for my applications mind you
21:46:14 <strager> flebron: I've used explicit-exception to do something like mzero with Either.  Worked well.
21:46:17 <mm_freak> jtobin: this can be done with no looping/branching, but with simple arithmetic
21:47:08 <jake__> The 0 :+ 1 are for the complex numbers. I get an occurs check
21:47:32 <hpaste> “Ertugrul Söylemez” pasted “Generate inequal random pairs” at http://hpaste.org/68820
21:47:42 <mm_freak> jtobin: next you can use the concept for generating a pair of different random numbers seen in the paste
21:47:56 <strager> jake__: You can't multiple a RealFloat with a Complex using *
21:47:58 <mm_freak> hhb_: nothing wrong with that
21:48:11 <mm_freak> hhb_: as said, your main bottleneck is String and perhaps a bit of Chan
21:48:19 <mm_freak> MVar is generally faster, but can cause congestion
21:48:31 <mm_freak> in most cases this is not a problem and it's easier to reason about performance
21:48:49 <hhb_> mm_freak: I see what you mean about the String v ByteString. Looking at the haddock, however, I don't see how to stay in ByteString
21:48:58 <strager> A Complex a, that is.
21:49:03 <mm_freak> hhb_: just process ByteString instead of String
21:49:07 <mm_freak> hhb_: or convert to Text
21:49:18 <jtobin> mm_freak: ah, `fix`
21:49:41 <jtobin> mm_freak: i saw that mentioned along with `until` in a SO post just before i came here
21:49:43 <mm_freak> yeah, fix is useful for conditional looping in IO
21:49:53 <mm_freak> fix $ \again -> …
21:50:19 <jtobin> merci.  let me check it out..
21:50:42 <mm_freak> you can also have arguments:  ($ x0) . fix $ \again x' -> … again (x' + 1) …
21:51:04 <hhb_> mm_freak: if I change to stuffWriter :: Chan ByteString -> IO () the msg in (msg, _, host) <- recvFrom socket 4096 is String. Not trying to be thick.
21:52:12 <mm_freak> hhb_: well, you don't want to use recvFrom in the first place…  the easy way is to go through Handle and use ByteString I/O
21:52:22 <mm_freak> hhb_: the cleaner and faster approach is to use conduits
21:52:42 <mm_freak> hhb_: http://www.yesodweb.com/book/conduits
21:54:15 <hhb_> mm_freak: I've been trying to make conduits work! I'm glad you said that. I have a question up on the list. https://groups.google.com/forum/?fromgroups#!topic/yesodweb/Az79rmJXAuk
21:54:19 <jake__> So I guess I can use fromIntegral to get it back to a regular Floating first?
21:55:55 <mm_freak> hhb_: my personal recommendation is not to use the server/client code from network-conduit…  instead write your own Source using e.g. sourceState
21:56:25 <mm_freak> the run* stuff is really for small, quick-n-dirty applications
21:58:28 <hhb_> mm_freak: So, Data.Conduit but not Data.Conduit.Network?
22:00:14 <mm_freak> hhb_: i'm not sure network-conduit can deal with UDP, much less whether it can do that according to your application
22:00:22 <mm_freak> network-conduit is great for TCP
22:01:06 <mm_freak> hhb_: no, network-conduit can't deal with UDP
22:03:37 <hhb_> mm_freak: right, I'm trying to make changes to it to allow UDP. So far I haven't had a good result.
22:07:16 <jake__> Thanks stranger, I just changed it to [ (magnitude z :+ 0) * z | z <- [(0 :+ 1),(0 :+ 2),(0 :+ 3)] ]
22:08:15 <flebron> @pl f a b c = either g h (parse a b c)
22:08:16 <lambdabot> f = ((either g h .) .) . parse
22:09:01 <RylandAlmanza> Any graphic libraries for haskell that will let me change the colors of individual pixels on a small screen?
22:10:11 <mm_freak> hhb_: no need to modify network-conduit
22:10:18 <mm_freak> hhb_: write your own Source, it's really easy
22:10:20 <mm_freak> use sourceState
22:10:40 <mm_freak> in other words, don't depend on network-conduit at all
22:11:45 <RylandAlmanza> Wait, I found one: http://hackage.haskell.org/packages/archive/AC-EasyRaster-GTK/1.1.3/doc/html/Graphics-EasyRaster-GTK.html
22:16:51 <flebron> @pl f s = return $ r t s
22:16:52 <lambdabot> f = return . r t
22:17:32 <mm_freak> hhb_: another important note:  use -threaded when compiling
22:18:13 <hhb_> mm_freak: thanks for the hints on ByteString. It made a huge difference. It seems I can continue on with Haskell! :)
22:19:15 <hhb_> mm_freak: -threaded even on Mac OS? What does -threaded do?
22:19:51 <mzero> builds with  the threaded RTS for GHC
22:19:57 <mzero> otherwise you get the unthreaded on
22:19:58 <mzero> one
22:20:14 <mzero> true on all platforms GHC supports
22:20:19 <hpaste> “Ertugrul Söylemez” pasted “Conduit source for UDP” at http://hpaste.org/68823
22:20:26 <mm_freak> hhb_: http://hpaste.org/68823
22:20:58 <mm_freak> hhb_: if you don't use -threaded various operations may block the entire application instead of just the containing thread
22:21:07 <mm_freak> this is true for network applications in particular
22:21:18 <mm_freak> rule of thumb:  if you use forkIO, use -threaded
22:21:31 <hhb_> mm_freak: that is building my app or building GHC?
22:21:39 <mm_freak> your app
22:21:46 <hhb_> mzero: thanks
22:21:54 <hhb_> OK, good to know
22:22:11 <mzero> :-)
22:22:19 <mzero> building your app
22:22:20 <mm_freak> in your cabal file just have:  "GHC-Options: -W -threaded"
22:22:41 <mm_freak> possibly you'll also want -rtsopts, but be sure not to expose such an application with the SUID bit =)
22:24:56 <hhb_> mm_freak: thanks for http://hpaste.org/68823 That would have taken me ages to work out.
22:25:26 <Polarina> hhb_, it took me ages myself. :/
22:25:30 <mm_freak> hhb_: you should read the tutorial i linked earlier…  conduits are easy to use
22:25:45 <mm_freak> just think simple…  there are sources, sinks and conduits and combinators to connect them
22:27:04 <mm_freak> with sourceState you can write arbitrary sources…  a simple source producing an endless stream of ones:  sourceState () $ \s -> return (StateOpen s 1)
22:28:40 <hhb_> mm_freak: cool, very cool.
22:34:01 <Hail_Spacecake> is there an exhaustive list of the differet types of ways you can pattern-match arguments of a function?
22:35:26 <dmwit> Hail_Spacecake: The Report is exhaustive for Haskell2010 with no extensions.
22:35:34 <dmwit> The GHC manual is exhaustive for GHC's extensions.
22:35:50 <hhb_> mm_freak: in your sourceUDP example with the use of recvFrom socket len. Is len the lifetime max or a per messsage max?
22:35:51 <shachaf> dmwit: I'm not completely sure about the latter. :-)
22:36:00 <dmwit> hm =)
22:36:21 <dmwit> As exhaustive a list as you're going to get, anyway.
22:36:42 <mm_freak> Hail_Spacecake: the rule of thumb is that you can have a pattern to the left of "=", "->" and "<-"
22:36:56 <mm_freak> hhb_: per message
22:43:31 <hpaste> danblick pasted “Optimization” at http://hpaste.org/68827
22:44:54 <Hail_Spacecake> mm_freak, well what constitutes a pattern?
22:45:27 <dmwit> Hail_Spacecake: http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17
22:45:34 <mm_freak> Hail_Spacecake: something you match against
22:45:36 <mm_freak> f x = …
22:45:39 <mm_freak> x is a pattern
22:45:49 <dmwit> mm_freak: You misunderstood the question, I think.
22:45:49 <mzero> Hail_Spacecake: http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17
22:45:56 <mzero> heh
22:46:01 <dmwit> He's not asking where patterns appear, he's asking what things can appear in a pattern.
22:46:02 <mm_freak> perhaps =)
22:46:11 <Hail_Spacecake> yeah
22:46:14 <mm_freak> well, constructors
22:46:15 <dmwit> The answer is: constructors, ~, and @.
22:46:19 <mm_freak> constructors and variables
22:46:19 <dmwit> and variables
22:46:27 <Hail_Spacecake> what is ~ ?
22:46:35 <dmwit> It's an irrefutable match.
22:46:37 <dmwit> Read the Report.
22:46:38 <hhb_> mm_freak: so, my UDP server is much faster now. With the -threaded version I lose about 25% of packets and with the no threaded version I lose 10%. I suppose as I learn more about threading, chan or even better conduits I should be on par with Java and C++ for this app.
22:46:40 <mzero> Hail_Spacecake: a variable, or a constructor with patterns -- essentially
22:46:42 <mm_freak> an irrefutable pattern…  one that always matches and can cause run-time errors if it doesn't
22:47:01 <Hail_Spacecake> so, if you have something liek myFunc (x:xs) = <whatever>
22:47:03 <dmwit> It really is quite readable.
22:47:08 <mzero> so      x        Right y        (f,g)          a : as         [ year, month, day ]
22:47:09 <mm_freak> hhb_: try again with MVar
22:47:10 <Hail_Spacecake> what you're really doing is matching on the list constructor :
22:47:10 <hpaste> danblick pasted “Optimization” at http://hpaste.org/68828
22:47:11 <Hail_Spacecake> right?
22:47:22 <dmwit> yes
22:47:24 <Hail_Spacecake> that's not anything special, it's literally the function :
22:47:29 <dmwit> yes
22:47:51 <shachaf> [ year, month, day ] is a special case.
22:47:51 <Hail_Spacecake> I could do let buildList = : and then match myFunc buildList x xs = ...
22:47:58 <dmwit> no
22:47:59 <mzero> those are all patterns --- execpt for the first, they are all Constructors (not functions technicall)     Right  ,   :   and : nested twice
22:48:01 <shachaf> No, you couldn't do that.
22:48:03 <mzero> in my examples
22:48:04 <dmwit> (:) is a constructor, buildList is not.
22:48:08 <Hail_Spacecake> oh
22:48:31 <shachaf> There are also a few other special cases. Well, if you want to consider them special.
22:48:40 <mm_freak> Hail_Spacecake: constructors in haskell always start with an upper-case letter or a colon
22:48:43 <shachaf> 5 is a pattern that uses (==) to match.
22:48:55 <dmwit> Ah, yes. Good point.
22:49:02 <Hail_Spacecake> 5?
22:49:08 <shachaf> As in "f 5 = ..."
22:49:09 <dmwit> And we completely forgot guards.
22:49:10 <mm_freak> "a :- B", here 'B' and ':-' are constructors
22:49:15 <shachaf> dmwit: Guards aren't patterns.
22:49:24 <dmwit> So yes, if you want the real answer, you must read the Report, or you're bound to forget some part of it.
22:50:00 <mzero> Hail_Spacecake: here's a way to think of it -- you can pattern match the structure of the data --- that is the way it is built up from constructors
22:50:08 <dmwit> shachaf: That's... sort of true in a technical sense. But they're allowed in many of the places that patterns are used.
22:50:11 <mm_freak> Hail_Spacecake: my recommendation is to go with your intuition here…  whenever it appears to be reasonable to have a pattern (i.e. something is matched), you can have a pattern
22:50:35 <shachaf> dmwit: It's not really just a technical sense.
22:50:42 <mm_freak> in some places you can have multiple patterns, and those can be enumerated:  'where', 'let' and 'case'
22:50:52 <mm_freak> note that your whole module is also a 'where' =)
22:50:53 <dmwit> > (\True | otherwise -> 3) True -- hum
22:50:54 <lambdabot>   <no location info>: parse error on input `|'
22:50:56 <mm_freak> module MyModule where …
22:51:03 <shachaf> f ( PATTERN_A ) ( PATTERN_B ) = ... matches on two patterns at once.
22:51:12 <shachaf> You can't do that with guards -- they're part of the =, not of the patterns.
22:51:18 <shachaf> (Or of the -> in the case of case of.)
22:51:40 <mm_freak> "in the case of case of" =)
22:51:58 <shachaf> mm_freak: I added that extra "of" just to make it work.
22:52:07 <danblick> I am kind of surprised to see that GHC isn't optimizing out all the (+1)s in a file like this: http://hpaste.org/68828 ( it's easier to see when i use 10,000 of them).  I tried -O3 -dno-debug-output ; any other ideas?
22:52:16 <Hail_Spacecake> mm_freak, that's my problem, I don't have a good intuition for what counts
22:52:22 <Hail_Spacecake> like, I get that (x:xs) is a common pattern
22:52:24 <dmwit> danblick: Give x a monomorphic type.
22:52:35 <dmwit> e.g. Integer
22:52:52 <shachaf> Hail_Spacecake: You'll get an intuition by reading and writing Haskell code.
22:52:53 <dmwit> danblick: Also, -O only goes up to 2 in GHC.
22:52:55 <shachaf> Or by reading the Report.
22:53:04 <mm_freak> Hail_Spacecake: i never read the report…  just write software =)
22:54:08 <dmwit> danblick: But, uh, ... what makes you think it's not optimizing that away? -ddump-simpl claims it's optimized away here.
22:54:13 <mm_freak> Hail_Spacecake: again the rule of thumb applies…  patterns are allowed to the left of "=", "->" and "<-"…  i know no exceptions out of my head
22:54:19 <mm_freak> and basically no place else
22:54:24 <dmwit> Main.main3 = __integer 10
22:55:22 <danblick> dmwit: sorry, I probably misspoke.  I'm just doing "od" on the binary and noticing that there's a lot of stuff there.  It may be that the machine code is efficient and I'm seeing something else.
22:55:25 <mm_freak> danblick: i'd be interested in how exactly you found out that it doesn't optimize it away
22:55:49 <dmwit> danblick: Yes, I think you are misinterpreting the output of "od".
22:55:57 <mm_freak> danblick: haskell binaries tend to be large anyway
22:56:04 <dmwit> danblick: Try compiling "main = print 10" and you'll see just how much code is required. =)
22:57:10 <dmwit> ghc produces two binaries of exactly 1137670 bytes for your program and for "main = print 10". =)
22:57:13 <danblick> thanks guys, looks like it it's going the right thing after all
22:57:40 <danblick> (good to know!)
22:57:44 <shachaf> dmwit: Are they the same binary?
22:57:52 <dmwit> no
22:58:59 <dmwit> (I would have boasted even harder if they were.)
23:00:10 <shachaf> Maybe it's a timestamp.
23:05:32 <dmwit> They're equal after "strip" is done with them.
23:05:41 <dmwit> Should have thought of that earlier.
23:09:57 <danblick> thanks dmwit :)
23:19:49 <mysticc_> > 2+3
23:19:50 <lambdabot>   5
23:22:13 <hpaste> mysticc pasted “pattern matching ” at http://hpaste.org/68829
23:22:44 <mysticc_> Is there a better way to do pattern matching as I am repeating the same code ?
23:23:25 <dmwit> Yes, change your data type to coalesce cases A,B,C,D.
23:23:54 <dmwit> data Tag = A | B | C | D; data RealThing a b = Whatever Tag a | WhateverElse b
23:24:18 <dmwit> Or, if there's an a in all the constructors, use record selection syntax.
23:24:31 <mysticc_> dmwit : I meant is there any other syntax without changing the datatype .. I just meant for general case where I have several patters but same rhs for them ..
23:26:03 <newsham> if you have a lot of functions that do the same thing to an "a" from many of your patterns, maybe you should write a function to apply something to the a's
23:26:58 <newsham> (but it might indicate that you should refactor your data type)
23:28:04 <mysticc_> newsham , dmwit :  I was reading the okasaki book and it mentioned that standard ml has such feature, so I thought is there something similar in haskell .
23:28:53 <mgsloan> mysticc_: you can also use SYB (scrap your boilerplate)
23:29:53 <mgsloan> well, assuming that none of the other constructors have the same type as "a"...  gmapT (g `extT` f)
23:29:53 <mysticc_> mgsloan: An example would be nice here.
23:30:14 <newsham> mysticc: what about:   http://hpaste.org/edit/68829
23:30:30 <newsham> where you just write that 1 time, then next time you just use doAll passing in diff f's and g's
23:30:55 <hpaste> newsh annotated “pattern matching ” with “pattern matching  (annotation)” at http://hpaste.org/68829#a68830
23:31:03 <mysticc_> mgsloan: Sorry to give the example, but it has nothing to do with the constructor,  I will just paste the code from okasaki book to tell what I actually meant.
23:31:17 <mgsloan> mysticc_: so, "gmapT (g `extT` f)" will apply f to every field that matches the type of f, and apply g to every field that does not
23:31:28 <mgsloan> mysticc_: ahh
23:32:17 <mgsloan> this was actually not what you wanted anyway, as your example does not re-package the results of f / g with the same constructor
23:32:31 <mgsloan> closer would be gmapQ, but nvm!
23:32:51 <newsham> you only have to do the repetitive thing once
23:35:22 * mgsloan mumbles something about TH
23:35:52 <hpaste> mysticc pasted “pattern matching ” at http://hpaste.org/68831
23:36:31 <mysticc_> mgsloan: this is what is there in standard ml from the okasaki book ..
23:36:38 <newsham> redblack tree ?
23:37:10 <newsham> mysticc: i'm not sure i understand how that relates to your earlier post.
23:37:45 <hpaste> mysticc pasted “pattern matching ” at http://hpaste.org/68832
23:37:55 <shachaf> unreadblack tree ?
23:38:05 <mysticc_> newsham: and what standard ml can do is above
23:38:11 <mysticc_> yeah , red black tree
23:38:46 <newsham> oh, because they share the same code for several defns
23:39:09 <mysticc_> newsham: Yeah , So I asked is there a similar thing in haskell ..
23:39:11 <newsham> can you do that with a "where" clause in haskell?
23:39:26 <mgsloan> mysticc_: One way would be to use my favorite thing to mess with lately, Template Haskell.  This would allow generating definitions.  People will think this is a very dirty approach, though.
23:39:48 <newsham> msgloan: dirty.  seems overkill for this
23:39:48 <mgsloan> newsham: where clauses are case-specific
23:40:02 <mysticc_> mgsloan: Yeah, for such little task , really overkill..
23:40:06 <mgsloan> newsham: I think TH will get cleaner as time goes on
23:40:24 <mgsloan> mysticc_: The non-overkill way to do it is embrace the code duplication
23:40:41 <mgsloan> the alternative is to introduce a helper definition which takes all of the variables
23:40:53 <mgsloan> but you will at minimum need to list all of the matched variables on the RHS
23:41:04 <mysticc_> I could always copy paste the same thing , but i would have been nicer if haskell had such syntactic sugar..
23:41:39 <mgsloan> which is my entire point - TH allows you to create new syntactic sugar, and I think that TH will become more accepted as it becomes more expressive and cleaned up
23:41:59 <mgsloan> well, TH has the potential for allowing you to create syntactic sugar..
23:42:16 <mgsloan> someone needs to make a PEG grammar for haskell :)
23:44:18 <mgsloan> it really is a shame that the "fundamentals-only" implementation of TH has alienated the haskell community from metaprogramming
23:45:03 <mgsloan> our abstractions are not powerful enough to do everything that you might want to do.  A lot more than usual, yes, but not everything
23:47:50 <newsham> msgloan: i've nothing against TH
23:47:55 <newsham> i've used it sometimes
23:48:04 <newsham> i just dont think this is a great reason to use it
23:48:45 <mgsloan> yup fair enough - this is just an opinion I've been meaning to voice for a while :D
23:49:57 <mgsloan> I think this could at some point be a good reason to use it - if people accept external haskell parsers in quasi-quotes as a reasonable thing to do, or if haskell parsing gets built into TH
23:53:49 <newsham> part of the problem is that patterns are syntax thats not a first class language element.
23:54:04 <newsham> your instinct is to use TH so you can manipulate them (they're firs class there)
23:54:33 <mgsloan> right.
23:54:39 <newsham> but wouldnt it be better to use something that is first class, like an automatically (TH!) generated deconstructor?
23:55:37 <mgsloan> newsham: sure!  But then you have to deconstruct the resulting tuple - which isn't such a bad thing
23:56:49 <mgsloan> your right, though, using TH here allows you to play with names and scoping, which is not the best for transparent readability
23:56:54 <roconnor> :)
23:57:15 <mgsloan> especially when our IDEs don't support viewing the splices..
23:58:40 <mgsloan> newsham: how about this - a TH thingie that brings the fields of a record into scope :)
23:59:20 <mgsloan> so, you deconstruct to this new record type, and then bring it into scope.  I think I've seen this called "using" in other languages - giving an implicit receiver to method calls
