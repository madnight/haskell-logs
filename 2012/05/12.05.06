00:00:13 <xil> works for me
00:00:20 <xil> you're putting that in the interpreter right?
00:00:34 <armence> xil: Yeah. I missed a :
00:00:37 <armence> Works for me now
00:00:39 <xil> ah
00:00:43 <xil> well there you go =]
00:00:46 <armence> Why is it not recognizing 23 as an Int?
00:01:10 <xil> I don't know the exact details, but I know that Haskell needs certain context clues to figure out a given value's type
00:01:23 <xil> whether or not an instance exists for it apparently isn't one of those clues
00:01:55 <xil> so it reads 23 as nothing but belonging to the class Num, which isn't enough for your class YesNo
00:02:09 <Enigmagic> :t 23
00:02:10 <lambdabot> forall t. (Num t) => t
00:02:20 <Enigmagic> :t (23 :: Int)
00:02:22 <lambdabot> Int
00:02:28 <xil> :t 100000000000000000
00:02:29 <lambdabot> forall t. (Num t) => t
00:02:33 <ion> The default defaulting rules don’t include Int, but they do include Integer AFAIU.
00:02:34 <xil> oh really
00:02:53 <xil> :t 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00:02:54 <lambdabot> forall t. (Num t) => t
00:02:57 <xil> I call bs on that one
00:02:59 <ion> But that might still not apply for that code.
00:03:29 <geekosaur> there's no point in defaulting to include Int
00:03:53 <armence> I'm not privy to there being an Int and an Integer type. What is the difference?
00:03:59 <ion> There’s no point in Int, mostly. :-)
00:04:03 <xil> Integer is unbounded
00:04:10 <ion> armence: A historical accident.
00:04:12 <xil> it's like BigInt in many other languages
00:04:22 <armence> ion: That makes sense to me. :)
00:05:30 <ion> Int shouldn’t be in Prelude. If you need a bounded integer type, you’ll probably want CInt for FFI or something like Int32 when you specifically want a certain bit size.
00:05:46 <xil> ion: is Int not faster than Integer?
00:06:08 <Veinor> xil: how often do you care?
00:06:23 <xil> Veinor: just a curiosity rather than actually caring about performance
00:06:31 <Cale> Int is a little bit faster
00:06:37 <Veinor> which is the reason length uses it
00:06:42 <ion> xil: Sure, but premature optimization is EBW.
00:06:58 <ion> Integer is pretty fast. :-)
00:06:58 <geekosaur> I think it depends on implementation, at least in Report-think
00:07:05 <armence> Int is 4 letters shorter than Integer... :)
00:07:36 <geekosaur> GHC will auto-specialize Integer, sort of, such that if it fits in a machine word it will be a machine word instead of a BigInt
00:07:59 <xil> ion: I might start using Integer more then. I really only use Int because it's there and is what I know from other languages =P
00:08:47 <xil> or when doing stuff like OpenGL which is just a bunch of C FFI
00:09:33 <zzo38> How do you inline a class method?
00:10:11 <Ralith> xil: you're using immediate mode opengl
00:10:14 <Ralith> i.e. gl1
00:10:22 <Ralith> that is very, very slow.
00:10:30 <xil> Ralith: huh?
00:10:31 <Ralith> gl is up to version 4 these days
00:11:03 <Ralith> xil: ?
00:11:19 <xil> Ralith: I mean, what makes you think I'm using GL1?
00:11:25 <Ralith> you are.
00:11:29 <Ralith> that is what.
00:11:35 <Veinor> ... ?
00:11:43 <xil> Ralith: but how do you know?
00:11:55 <xil> Ralith: is that just the limitation of the Haskell binding?
00:11:55 <Ralith> OpenGL is a specification
00:12:03 <Ralith> you are using the functions specified in version 1 of it.
00:12:07 <xil> Ralith: yeah and I have 2.1 support
00:12:14 <Ralith> your hardware might
00:12:16 <Ralith> your software isn't using it.
00:12:32 <xil> Ralith: yeah I meant my hardware. But then are you saying the Haskell binding is stuck in 1?
00:12:39 <dmwit> tgeeky_: Seems there's some bug: topLevel (Id One :+: Id One) (left unit) ==> [Left (Left (Left Unit)),Right (Right (Left Unit))]
00:12:42 <dmwit> =P
00:12:43 <Ralith> I don't know much about the haskell bindings.
00:12:48 <Ralith> I'd be surprised if they were that obsolete, though.
00:13:06 <xil> Ralith: wat? Then why am I using 1? How do you know I'm using 1?
00:13:18 <Ralith> because you're using the functions specified by version 1.
00:13:32 <xil> Ralith: oh oh oh, now I understand, haha, I think
00:13:39 <xil> Ralith: it's what's in the Haskell binding though
00:13:47 <Ralith> yes, it's in most OpenGL bindings.
00:14:05 <xil> I just assumed that it defaults to the newest version it can for each function
00:14:05 <Ralith> most OpenGL bindings implement the latest version of the specification, which encompasses the previous versions.
00:14:13 <xil> well yeah
00:14:15 <Ralith> functions do not have versions.
00:14:33 <Ralith> if you want to use modern opengl, and thereby not limit performance, you will need to use different functions.
00:14:42 <xil> can you give an example?
00:15:07 <Ralith> I don't know the haskell bindings, so I'll have to refer to the standard names
00:15:19 <xil> gopherit
00:15:46 <Ralith> but using DrawArrays instead of Begin/End/Vertex3 would be a good start
00:15:55 <Ralith> (that's a gl2 feature, iirc)
00:16:02 <Ralith> (though many gl1 impls support it as an extension)
00:16:28 <Ralith> (renderPrimitive almost certainly calls Begin/End internally, if that was unclear)
00:16:51 <Ralith> bear in mind, your code may not be GPU-limited, but you shouldn't be using the obsolete API regardless.
00:17:35 <Ralith> xil: the basic paradigm shift for 1 -> 2 is uploading data to the GPU once instead of per-frame
00:17:39 <xil> well I learned OpenGL on C++ and Java, and I guess I learned the GL1 way to do everything, so that carried over to Haskell for me
00:17:47 <xil> oh that would be amazing
00:17:58 <xil> I've always hated having to reupload geometry every frame
00:18:02 <xil> so wasteful
00:18:04 <Ralith> indeed
00:18:12 <Ralith> that's why 3D apps stopped doing it decades ago!
00:18:23 <Ralith> smack whoever taught you C++/Java opengl :P
00:18:35 <xil> myself =P
00:18:38 <Ralith> >_>
00:18:39 <xil> trial and error
00:18:46 <xil> haha
00:18:54 <Ralith> admittedly, online resources for learning opengl are by and large ancient and terrible
00:18:57 <Ralith> so not your fault
00:19:19 <xil> yeah, I learned a lot from just reading the API and trying things
00:19:22 <Ralith> the first big step for improving things is using vertex arrays (what DrawArrays handles) instead of immediate-mode.
00:19:23 <armence> xil: That's impressive, OpenGL is a pain to learn...
00:19:43 <xil> armence: thanks. It took me a while, but I was motivated at the time
00:19:51 <Ralith> then if you want to get fancy, the paradigm shift for 2 -> 3 is the excision of all fixed-function features
00:20:10 <xil> Ralith: what are fixed-function features?
00:20:47 <Ralith> all built-in drawing, lighting, shading, matrix manipulation, data processing features
00:20:50 <Ralith> and some other stuff
00:21:40 <Ralith> basically, you are given an API to establish and manipulate shaders, and an API to send data to them
00:21:49 <Ralith> and the rest is up to you
00:23:05 <Ralith> it makes 'hello world' a hell of a lot more complicated, but cleans things up a great deal.
00:23:07 <xil> Ralith: very interesting. Well I'll have to do a lot of reading up on these changes
00:23:24 <xil> Ralith: I'll start with DrawArrays and work up from there
00:23:39 <Ralith> http://www.arcsynthesis.org/gltut/ may be of interest
00:23:58 <YellowOnion> good tutorial
00:24:01 <Ralith> given that you can read C++
00:24:19 <YellowOnion> I can't read C++ still found it useful
00:24:47 <Ralith> well, it's very C-y C++
00:25:30 <YellowOnion> I only know python and trying to learn haskell, allowed me to make a basic OGL app in python
00:25:45 <YellowOnion> but yeah, easy
00:25:57 <xil> Ralith: this looks awesome, but also deep/dense. I'll have to read it when I'm not quite as tired
00:25:59 <YellowOnion> well the lang part
00:26:39 <YellowOnion> Ralith: hated seeing those nehe tuts around that were using OpenGL from 95
00:27:06 <YellowOnion> give or take a few years
00:27:43 <Ralith> yeah
00:27:48 <Ralith> basically all of the easily-found ones do :/
00:27:55 <Ralith> xil: good luck!
00:28:00 <YellowOnion> it's slow
00:28:09 <xil> Ralith: thanks =D
00:28:27 <Ralith> YellowOnion: worse still, it teaches very wrong ideas
00:28:38 <YellowOnion> yeah
00:28:48 <YellowOnion> I'm glad I picked up on it
00:29:23 <YellowOnion> it's probably the reason why people think OpenGL is slow/terrible/<insert uninformed opinion>
00:29:43 <Obfuscate> If you're going to do anything seriously with opengl, buy the latest superbible.
00:30:20 <YellowOnion> then you have to wait for it to get to your house :P
00:30:35 <YellowOnion> there's probably an ebook store somewhere though
00:36:19 <Taneb> Is Haskell 2011 a thing any more>
00:49:03 <geekosaur> 2011 was never a thing; the committee ruled out a 2011 fairly early on, because there didn;t seem to be a pressing need
01:18:19 <ymasory> i have an infinite list in 'IO [String]' and am trying to print them as they become available. However, 'list >>= (\x foldMap x putStrLn)' is accumulating instead of printing immediately. what is the correct way?
01:19:04 <ymasory> let >>= \x foldMap putStrLn x
01:23:49 <Taneb> ymasory, try "fmap unlines list >>= putStr"?
01:25:33 <ski>   putStr . unlines =<< list
01:26:50 <ski> @type Data.Traversable.foldMap
01:26:50 <lambdabot> Not in scope: `Data.Traversable.foldMap'
01:27:00 <ski> @type Data.Foldable.foldMap
01:27:01 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
01:56:23 <dmwit> or: list >>= mapM_ putStrLn
02:21:54 <ymasory> dmwit: i don't get it. unlines never terminates on an infinite list, so out does putStr ever run?
02:23:59 <Taneb> > take 10 (unlines (repeat "a"))
02:24:00 <lambdabot>   "a\na\na\na\na\n"
02:24:11 <Taneb> ymasory, laziness is your friend
02:24:54 <ymasory> Taneb: so that one i actually get for some reason
02:24:59 <dmwit> ymasory: unlines is lazy; yes, putStr runs
02:25:10 <ymasory> ok i think i understand now
02:25:30 <geekosaur> mapM_ won't terminate, but that doesn't mean it won't do anything either
02:25:31 <ymasory> thanks
02:29:20 <ymasory> does the fact that String is [Char] have anything to do with why this works. it allows one to take a partial result from unlines right?
02:30:02 <Taneb> Yes
02:31:00 <ymasory> Taneb: okay, and putStrLn reads its input in chunks then?
02:31:35 <dmwit> putStrLn reads its input in one-Char chunks, yes.
02:31:39 <dmwit> ?src putStrLn
02:31:40 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
02:31:44 <dmwit> ?src putStr
02:31:44 <ymasory> i think i get why i can't translate this to scala now. Strings aren't [Char] so you can't have a partial one. You would need to write a putStrLn that reads in Stream[Char] and reads it in chunks
02:31:45 <lambdabot> putStr s  = hPutStr stdout s
02:31:52 <ymasory> ahah
02:32:00 <ymasory> ok thanks all
02:32:15 <dmwit> ymasory: You should be able to translate the mapM_ putStrLn version just fine, though.
02:32:21 <ymasory> my mind was frozen on String being an indivisible unit
02:32:36 <geekosaur> this is why we have both lazy (chunked) and strict ByteStrings
02:33:04 <ymasory> dmwit: i don't get that one. And scalar lacks mapM and mapM_ for some reason. maybe type system makes it inexpressible, dunno. how does that version work?
02:33:10 <ymasory> *scalaz
02:33:32 <dmwit> I think you call it flatMap in scala.
02:33:45 <ymasory> dmwit: flatMap is bind
02:33:52 <dmwit> okay
02:34:00 <ymasory> dmwit: scala has no mapM. scalar has some related things like foldMap though
02:34:03 <ymasory> but no mapM
02:34:23 <ymasory> dangit stop spell correcting *scalaz
02:34:30 <dmwit> Anyway, how it works is by calling putStrLn on each element of the list.
02:34:58 <ymasory> won't that operation have to terminate prior to unsafePeformIO happening?
02:35:17 <dmwit> Where did unsafePerformIO come from?
02:35:50 <ymasory> that's what scalaz calls the function that runs an IO a to get an a out
02:36:10 <ymasory> i guess haskell just implicitly calls that on the result of main? dunno
02:36:32 <dmwit> No, good programs never call that "function" in Haskell.
02:36:41 <dmwit> I don't see how it's relevant to the way mapM_ works, either.
02:36:51 <dmwit> Since mapM_ has a monadic return type.
02:37:00 <dmwit> :t mapM_
02:37:01 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
02:50:58 <roconnor> > (2^31 - 1) `mod` 7
02:50:59 <lambdabot>   1
02:51:54 <avh> Hi, I was wondering what type a function that works on numbers and needs to divide them should take as input?
02:52:20 <avh> Division is in Fractional, but I guess I can also use Real and call realToFrac
02:52:27 <roconnor> @type div
02:52:28 <lambdabot> forall a. (Integral a) => a -> a -> a
02:52:36 <roconnor> > 3 `div` 2
02:52:38 <lambdabot>   1
02:52:41 <roconnor> > 3 / 2
02:52:42 <lambdabot>   1.5
02:54:01 <avh> I know. I guess I'm really wondering about what is normaly done, when you want your function to "just work" with all kinds of numbers.
02:54:19 <avh> Is it normal to just take a Real, call realToFrac and then return a Fractional?
02:54:50 <roconnor> avh: it is not normal
02:54:59 <avh> Or is it normal to have the caller convert
02:55:28 <roconnor> avh: you decide if you want to use `div` or (/) and use the appropriate one.
02:56:09 <avh> ok
02:56:12 <avh> thanks
02:56:56 <Phlogistique> question: why does the Prelude has fromInteger and toInteger but not fromInt nor toInt?
02:57:18 <Phlogistique> generally: I find the design of the numerical prelude surprising; is there a rationale to it?
02:58:05 <Phlogistique> and why no fromIntegral/toIntegral?
02:58:16 <c_wraith> :t fromIntegral
02:58:17 <lambdabot> forall a b. (Integral a, Num b) => a -> b
02:58:22 <Phlogistique> oh
02:59:27 <geekosaur> also note that fromInt/toInt are just specializations of fromEnum/toEnum
02:59:49 <geekosaur> (except I think Int is actially the intermediate representation there...)
03:00:25 <geekosaur> so fromEnum is actually toInt, sort of
03:00:41 <c_wraith> toIntegral doesn't exactly make sense.  If the source is a different Integral type, fromIntegral is the same thing. If it's not an Integral type, you need to specify what to do with the remainder, so you should use round/floor/ceiling instead
03:06:38 <Phlogistique> c_wraith: indeed
03:13:23 <reinoud> Hi
03:13:37 <Axman6> 'lo reinoud
03:13:38 <reinoud> is there a primer or some example code of how to use Data.Map ?
03:13:53 <Axman6> :t Map.insert
03:13:54 <lambdabot> Couldn't find qualified module.
03:14:01 <Axman6> :t M.insert
03:14:02 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
03:14:05 <dmwit> Not really, but the docs are pretty good.
03:14:09 <dmwit> What do you need to know?
03:14:12 <reinoud> i have looked at the docs yes
03:14:37 <Axman6> reinoud: what do you not understand? it's a pretty simple thing to use
03:14:58 <reinoud> well i seem to have implemented a quite sloppy one myself while hacking on this project and am looking now into switching over to Data.Map
03:15:25 <Axman6> what are you actually trying to do though?
03:16:06 <reinoud> I am implementing the cubical marching squares algorithm in Haskell. It works but its quite space wasting
03:16:46 <reinoud> i think it might be due to my ... euhh... sloppy way of keeping references in a list and updating the lists :-D
03:21:10 <fmap> reinoud: any concrete questions?
03:23:23 <reinoud> not yet :) i'm just starting the conversion :-D
03:23:57 <Ralith> unless you have a concrete question, you've also finished it.
03:28:47 <Axman6> well put
03:29:08 <Axman6> reinoud: we can't help you with details of what you need help with
03:29:16 <Franciman> gents, is there any djvu library for haskell?
03:36:00 <hayashi> Is there a good Haskell idiom for repeatedly spinning a monadic function (encapsulating a Maybe String) until its computation results in either Just "", in which case the whole thing terminates, or Just a, in which case a is fed to something else and the loop continues?
03:36:20 <hayashi> I'm worried that my current implementation is a recipe for gross stack overflowing.
03:37:13 <hayashi> (Same thing with an Either would work, too.  Or anything that can capture the idea of that computation failing and having to be re-run without the other effect)
03:40:17 <hayashi> (Basically the context is repeatedly asking a user for a database table name, trying to poke the database with the supplied table, catching any exceptions, dumping them to console, rolling back and looping back over into the user interaction construct, and exiting completely if the user specifies "".
03:40:19 <hayashi> )
03:41:39 <hayashi> actually thinking about it it's not as complicated as I've made out to myself
04:09:00 <reinoud> Axman6: for now, i wonder which insert* and/or update functions to use if i want to replace/update element X and add elements Y,Y+1,Y+2,... with Y = the next available index
04:10:27 <dmwit> replace/update element X: use insert
04:10:41 <dmwit> find minimal unused index: no such operation, I'm afraid
04:11:00 <dmwit> (though you can find the minimal/maximal used index)
04:11:37 <reinoud> i think i can use size since all elements in [0..Y-1] are guaranteed to be present
04:11:56 <reinoud> its not deleting entries, only modifying and adding
04:12:18 <dmwit> If your entries are dense, you might want to consider using Seq instead.
04:12:32 <dmwit> Or Array, if you don't resize often.
04:13:50 <reinoud> :help Data.Seq
04:14:00 <reinoud> > :help Data.Seq
04:14:01 <lambdabot>   <no location info>: parse error on input `:'
04:14:03 <reinoud> :)
04:14:13 <reinoud> :t Data.Seq
04:14:14 <lambdabot> Couldn't find qualified module.
04:14:30 <dmwit> ?hackage containers
04:14:31 <lambdabot> http://hackage.haskell.org/package/containers
04:20:03 <reinoud> :-)
04:21:07 <ski> @hoogle Data.Seq
04:21:07 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
04:21:07 <lambdabot> Data.Foldable sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()
04:21:08 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
04:21:21 <ski> @slap hoogle
04:21:21 * lambdabot hits hoogle with a hammer, so they breaks into a thousand pieces
04:24:28 <reinoud> Ok, so i should consider using Data.Sequence. I wonder if i should keep including the key value in the datatype itself
04:32:43 <kuznero> Hi all
04:33:55 <dmwit> howdy
04:41:57 <wpanyor> hello :)
04:42:15 <dmwit> howdy
04:47:50 <wpanyor> I have problem with installing categories package on haskell 2011.4.0.0. (winxp). On 'cabal install categories' it returns:
04:47:51 <wpanyor> Control\Categorical\Functor.hs:1:14:
04:47:51 <wpanyor>     Unsupported extension: ConstraintKinds
04:47:51 <wpanyor> cabal: Error: some packages failed to install:
04:47:51 <wpanyor> categories-1.0 failed during the building phase. The exception was:
04:47:51 <wpanyor> ExitFailure 1
04:48:07 <wpanyor> ccould someone help me.
04:48:10 <wpanyor> please
04:48:23 <dmwit> Upgrade GHC.
04:48:37 <dmwit> Also, in the future, please use a paste site like hpaste.org for long error messages.
04:48:54 <Franciman> anybody ever tried hoovooloo ? ( the haskell plugin for netbeans )
04:49:39 <wpanyor> ok. thx.
04:50:39 <fmap> wpanyor: you can also try some old version of categories package
05:01:31 * hackagebot arithmoi 0.2.0.4 - Efficient basic number-theoretic functions.  Primes, powers, integer logarithms.  http://hackage.haskell.org/package/arithmoi-0.2.0.4 (DanielFischer)
05:10:57 <Expez> What is the name of '<*>', i.e how do you read it out loud?
05:11:39 <dmwit> apply
05:11:44 <dmwit> :t (<*>)
05:11:46 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
05:11:53 <wpanyor> how to upgrade ghci7.0.4 (included in Haskell platform for winxp), to current version 7.4.1. It's seem that only separate install is possible.
05:12:03 <dmwit> You might consider reading it flip, too, but that's just a conceit. =)
05:12:12 <Expez> Thanks
05:12:13 <dmwit> wpanyor: That is correct.
05:13:34 <wpanyor> dmwit: and, what suggestion you have. Is there any way to use new ghci inside Haskel Platform.
05:14:51 <geekosaur> wpanyor, no
05:15:07 <dmwit> wpanyor: You may simply cabal install the packages that make up the Platform.
05:15:41 <geekosaur> the next HP release should be this month; I don't know that it will use 7.4.1 though.  7.4.1 has significant changes, and last I'd heard a number of Platform packages had not yet had compatible releases yet
05:15:51 <geekosaur> (maybe they have by now)
05:56:58 <wpanyor> dmwit: so, how to do cabal install separately from yet installed Haskell Platfor. Cabal is part of this platform, and then I get the same error message asa above 'Unsupported extension: ConstraintKinds' for categories package.
05:58:23 <LotteryWall> I will guess the lottery numbers behind the wall
05:59:07 <Philippa> the ones due next week'd be more useful
05:59:14 <byorgey> wpanyor: cabal-install is not the problem.  The problem is that the version of GHC which comes with the Platform does not support the ConstraintKinds extension.
05:59:34 <Philippa> at least, until we hit an equilibrium where everyone uses your numbers and gets their own money back from the jackpot. Hmm, except then fixed payouts might be worth more...
05:59:54 <byorgey> wpanyor: if you want it you will have to manually install the newest version of GHC (7.4.1) from here: http://www.haskell.org/ghc/download_ghc_7_4_1
06:02:29 <wpanyor> byorgey: thx, I installed it, but how to use it withouth haskel platform (which I uninstalled). I need cabal, i need haskell... what next?
06:02:56 <Saizan> wpanyor: the Cabal library comes with ghc
06:03:13 <Saizan> wpanyor: the cabal executable comes from the cabal-install package on hackage
06:03:37 <Saizan> wpanyor: you could also use the old one if you still have it
06:03:44 <Saizan> @hackage cabal-install
06:03:44 <lambdabot> http://hackage.haskell.org/package/cabal-install
06:04:18 <byorgey> easiest way to install cabal-install from scratch is not from Hackage, but to download it from http://www.haskell.org/cabal/release/cabal-install-0.14.0/cabal-install-0.14.0.tar.gz, unpack it, and run the 'bootstrap.sh' script
06:04:43 <byorgey> but yes, you can also use the one that came with the HP if you didn't delete it
06:05:22 <Saizan> is that tarball not the same as the one on hackage?
06:06:06 <byorgey> it is
06:06:06 <merijn> What would you people say is less painful way to produce a GUI for a program, writing a native GUI or just implementing a web interface and running a local webserver?
06:06:45 <byorgey> you're right, where you get the tarball is not important, the important point is that you can use the bootstrap.sh script
06:10:20 <wpanyor> Saizan: You said thet "the Cabal library comes with ghc", but there are no any exe, or any cabal that i can execute install.
06:11:34 <byorgey> wpanyor: the Cabal library is just a library that provides some of the functionality, it is not an executable.  It shows up in the list of installed packages if you type  'ghc-pkg list'.
06:11:56 <byorgey> the cabal executable depends on the Cabal library.
06:12:01 <byorgey> it does not come with GHC.
06:13:06 <Saizan> wpanyor: read my other messages too
06:17:41 <wpanyor> Saizan, OK. Now I have downloaded and extracted cabal-install-0.14.0, and how to execute script bootstrap.sh. I extracted cabal-install on desktop, and I have only installed ghc-7.4.1 on d:\ghc  (bin is in the path)?
06:20:25 <Saizan> wpanyor: i guess on windows it won't be easy to execute bootstrap.sh?
06:21:09 <wpanyor> Saizan, so what to do now, to install cabal executable?
06:21:32 * ski . o O ( "It is singular that nobody objects to `sqrt(- 1)' as involving any contradition, nor, since Cantor, are infinitely great quantities objected to, but still the antique prejudice against infinitely small quantities remain." )
06:21:44 <Saizan> wpanyor: http://www.haskell.org/cabal/release/cabal-install-0.14.0/cabal.exe <- there's a prebuilt binary, luckyly :)
06:22:16 <Saizan> wpanyor: put it somewhere that is on your %PATH%
06:23:30 <wpanyor> Saizan: wow!! thx.
06:25:23 <wpanyor> Saizan: after I downloaded cabal.exe, and put it on the path, is there neccessary to invoke "cabal install cabal-install"?
06:37:10 <romildo> @pl \t -> try (sat (==t))
06:37:10 <lambdabot> try . sat . (==)
06:39:24 <Saizan> wpanyor: no, i don't think so
06:51:47 <sebasmagri> Hi! anyone used to mongoDB?
06:51:58 <sebasmagri> how can I set a Timestamp() field?
06:53:35 <schlicht> So, i have to write a GUI for a Haskell-Framework/Tool. I know fundament Haskell. Whats the best way to go at this? Something like wxHaskell or GTK2Hs? Is there anythink else usable? Or should i write the Gui in C/C++ with whatever framework i want and glue it together with the FFI?
06:53:51 <schlicht> *fundamental
06:54:59 <Cale> schlicht: Those two libraries are good starting points.
06:56:23 <schlicht> Cale, any alternatives i can take a look at? i have time for research :)
06:58:39 <Philippa> just had a wonderful "how stupid am I?" realisation - if you want to keep stuff in applicative style but you have side-effecting "newFoo" operations and you want to use their results more than once, "withFoo" is your friend
06:58:46 <Cale> I don't know of anything else which is as in-depth as those. You might look into grapefruit, which is supposed to be an FRP library with a GTK backend.
06:59:13 <geekosaur> there are SDL bindings as well
07:00:39 <schlicht> ahh  i would be best if it could run on *unix, win and mac. my boss is using mac...
07:01:14 <Philippa> gtk2hs would be my first recommendation there
07:04:45 <schlicht> it looks like there are many gui projekts/bindings/libs, but not many really useable in production, or not?
07:05:43 <bitonic> schlicht: gtk2hs and wx are usable in production
07:06:40 <merijn> Speaking of GUIs, time to repeat my earlier unanswered question
07:06:42 <merijn> What would you people say is less painful way to produce a GUI for a program, writing a native GUI or just implementing a web interface and running a local webserver?
07:06:44 <Philippa> schlicht: we're an experiment-happy community, a lot of the projects have been getting on for research level
07:07:00 <Philippa> it'd be nice if we had a way to mark out research-oriented packages on hackage though
07:07:07 <bitonic> but gtk and wx are very much stable
07:07:13 <schlicht> bitonic, yeah, looks like these two are my only options
07:07:42 <bitonic> schlicht: well the only "big" library which is missing bindings is Qt really :)
07:07:55 <bitonic> (which is sad, but it'd be a huge amount of work so understandable)
07:08:03 <schlicht> why is that so?
07:08:08 <bitonic> schlicht: why is what so?
07:08:19 <schlicht> huge amount of work :)
07:08:23 <merijn> Qt only has a C++ interface, no?
07:08:30 <schlicht> more than i.e. gtk?
07:08:32 <merijn> You can't call C++ directly from haskell
07:08:33 <bitonic> schlicht: because Qt is huge
07:08:44 <bitonic> merijn: you can wrap the C++ in C, like they do with wx
07:08:54 <merijn> Sure, but you have to do it
07:08:59 <bitonic> schlicht: and uses strange stuff - e.g. that preprocessor thing
07:09:08 <merijn> Unlike wx where you can just implement haskell to call the existin C interface
07:09:11 <schlicht> mhm
07:09:11 <luite> merijn: hmm, how "standard" is your gui? can you build it with regular html? do you need interactive data grids etc?
07:10:36 <schlicht> but it was tried a few times to bind qt...nothing of that got far?
07:11:06 <alpounet> there's qthaskell
07:11:42 <merijn> luite: I'm unsure what I want yet, will probably need interactive data grids/context menu's/etc.
07:11:48 <bitonic> alpounet: oh well, I didn't know that
07:12:19 <schlicht> alpounet, but its "preview", what ever that means
07:12:43 <Philippa> does anyone have a sensible idiom for situations where you're writing high level code mapped from a spec where things get named, but the code wants you to be pointless? Say, if you've got good reason to be working within an Applicative but you still want to show the names?
07:12:56 <Philippa> (I realise I could grab the quasiquoter for applicative do)
07:13:05 <Philippa> (the problem generalises though)
07:13:18 <alpounet> schlicht, yeah but that's the (only?) most advanced one
07:14:07 <schlicht> alpounet, do you know anything aout HQK?
07:15:33 <luite> merijn: hmm, right. lots of data is often easier to work with locally, you can probably do most with a javascript gui library, but the code for those tends to be hard to maintain
07:16:12 <Saizan> Philippa: pure (\show names here -> ..) <$> .. <*> .. <*> .. ? i guess it's not sensible for lots of reasons
07:16:12 <alpounet> schlicht, i remember reading about it, but have never seen it used anywhere
07:17:06 <Philippa> Saizan: you get proximity problems if you're nesting stuff, which I will be
07:17:29 <Philippa> (linear proximity is bad enough, but when it's tree-structured it's that much more of a PITA)
07:18:11 <Saizan> you could annotate each argument with (\name -> name) <$> arg, but that's silly
07:18:53 <luite> merijn: the best way is to improve ghcjs, write bindings for some js gui framework!
07:19:52 <schlicht> okay, thanks everyone! i will dive into wx and gtk :)
07:22:14 <joelr> moin
07:28:27 <lamefun2> doPriestCheck x = if checkForSatan x then Posessed x else Pure x
07:28:46 <lamefun2> what do I write in function type definition to force x to be CheckableForSatan?
07:28:47 <merijn> luite: That's what I was afraid of :\
07:28:59 <merijn> luite: Man, writing end-user facing software sucks >.>
07:30:36 <merijn> On unrelated note, what could guess ghci to not show Debug.Trace messages?
07:31:06 <lamefun2> on a -> PriestCheck a  it says that no instance for (CheckableForSatan a) arising from a use of `checkForSatan'
07:31:27 <luite> merijn: the thunks being already evaluated
07:32:18 <merijn> luite: Is there any way to clear that? I'm trying to debug my Read instance, but after running once for a given input it won't run again for the same input
07:33:00 <merijn> Reloading doesn't seem to help
07:33:21 <merijn> Well, not without changing the source anyway
07:33:53 <luite> merijn: perhaps you can use functions instead of values where you use trace
07:34:13 <merijn> They're inside the ReadPrec monad
07:34:19 <solarus> lamefun2: checkForSatan :: CheckableForSatan a => a -> PriestCheck a
07:34:36 <merijn> There's not convenient way to add debug messages without rewriting tons of code
07:35:18 <hpc> @quote oasis
07:35:19 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
07:35:29 <hpc> you can cheat...
07:35:37 <merijn> hpc: I'm already using Debug.Trace
07:35:43 <hpaste> lamefun pasted “A strange error” at http://hpaste.org/68152
07:35:56 <merijn> hpc: But I only get output the first run of a codepath
07:35:59 <t7> someone make a step through debugger plox
07:36:04 <hpc> merijn: ah, righ
07:36:05 <hpc> t
07:36:08 <lamefun2> Ambiguous type variable `a0' in the constraints:
07:36:17 <lamefun2>  (CheckableForSatan a0) arising from a use of `doPriestCheck'
07:36:23 <lamefun2> and (Show a0) and (Num a0)
07:36:33 <merijn> So running multiple strings through my parser will cause some messages to be dropped
07:36:39 <merijn> Rendering them rather useless
07:37:23 <merijn> So I need some way to flush computed thunks from ghci, forcing recomputation
07:37:55 <merijn> Doing "modify source file -> reload" every GHCI statement is a bit to much work
07:38:30 <hpc> merijn: parameterize by ()
07:38:45 <hpc> (\() -> stuff) () -- no more saving of stuff
07:38:54 <hpc> probably
07:39:12 <merijn> hpc: Yes, but that's what I meant by "requires rewriting tons of code" :p
07:39:19 <hpc> ah
07:39:24 <hpc> didn't think it would be that bad
07:40:25 <merijn> Well, it means changing and moving the 30 or so trace messages I have. Which is just annoying if there's a better solution :p
07:40:31 <merijn> (Which apparently there isn't)
07:41:41 * hackagebot html-conduit 0.0.0 - Parse HTML documents using xml-conduit datatypes.  http://hackage.haskell.org/package/html-conduit-0.0.0 (MichaelSnoyman)
07:44:18 <merijn> hpc: Hmm, actually, doesn't even seem to work? I have "trace :: (Monad m) => String -> () -> m (); trace s = \() -> Debug.Trace.trace s $ return ()" and then use 'trace "some string" ()' in the ReadPrec monad and the output still happens only the first run
07:44:51 <mekeor> hackagebot: hehe -- version 0.0.0 :D
07:51:10 -ChanServ(ChanServ@services.)- dons set flags +F on shapr.
07:56:51 <merijn> argh
07:57:03 <merijn> Even rewriting all the debug statements doesn't help me
07:57:15 <merijn> They still only ever print once
07:58:06 <Botje> +F for +Friendly?
07:58:52 <dons> that's right :)
07:58:53 <dons> boing!
08:02:06 <joelr> what is the C type of a haskell closure (callback) in the ffi?
08:04:20 <joelr> never mind, it's HsFunPtr
08:09:19 <donri> is there a way to set what ghci uses for printing result values?
08:09:41 <nand`> since main :: IO () technically isn't a function; what's the appropriate way to reference it? “main constant”?
08:09:51 <Philippa> donri: it mostly just uses show
08:09:51 <donri> nand`: action
08:09:53 <hpc> nand`: action
08:10:06 <Philippa> action/computation/burrito
08:10:06 <donri> Philippa: or "print", but i want to override it (with groom)
08:10:07 <nand`> works for me
08:10:37 <hpc> nand`: in general, that's what you call any (Monad m => m a) value
08:10:38 <Philippa> donri: *nod*. It has to catch when something's an action first anyway, but you'd have to patch it I think
08:10:41 <hpc> (if that's how you are using it)
08:11:02 <Philippa> would be a good/useful patch to have made though, making ghci more hackable/abusable is good!
08:11:36 <nand`> hpc: just seems strange to use that term in general; eg. when using the list monad I prefer to speak of “possibilities” if that's how I'm using them
08:12:01 <hpc> Philippa: patch for ghci: "sub main { eval $_ while <>;} &main();"
08:12:01 <hpc> :D
08:12:11 <hpc> it's the ultimate in hackability
08:12:32 <lamefun2> Are there some accelerated graphics API in Haskell style?
08:12:51 <nand`> lamefun2: you mean like OpenGL but not as imperative?
08:12:57 <hpc> @hoogle gpipe
08:12:57 <lambdabot> package GPipe
08:12:57 <lambdabot> package GPipe-Collada
08:12:57 <lambdabot> package GPipe-Examples
08:13:07 <hpc> gpipe might not be actively maintained
08:13:26 <nand`> yeah, last time I tried building it I had to get some really really old versions of other libraries that didn't build under 7.4.1
08:13:55 <lamefun2> I don't care, I care about seeing best Haskell API design practices in area of graphics.
08:14:09 <nand`> “best” is subjective
08:15:14 <AndrewMarsh> GPipe seems pretty cool, will see what it would take to get it to work with current haskell. I was going to write my own graphics API.
08:17:07 <joelr> is it possible to pass a data type with multiple constructors to C and figure out which constructor is being passed?
08:17:39 <Peaker> joelr, why not use a tiny Haskell wrapper that converts the constructor to a specific value or such?
08:17:45 <Peaker> a specific CInt maybe?
08:17:48 <nand`> is it sane to implement “encode :: (Integer, Integer) -> ByteString” by treating the tuple as a complex number and encoding it in Quater-imaginary base?
08:17:51 <lamefun2> and what are "monad laws"?
08:17:51 <dons> yeah, try to do as much on the haskell side as possible
08:17:58 <dons> particularly pattern matching is a lot easier on the .hs side
08:18:08 <Peaker> nand`, why (Integer, Integer) when there's a Complex type?
08:18:22 <joelr> interesting… i come from ocaml where you could check the # of the constructor
08:18:36 <joelr> dons, Peaker: fair. let me expand on that… one moment
08:18:36 <Peaker> lamefun2, the Monad laws are laws that all instances of the Monad class should obey
08:18:37 <nand`> Peaker: because the integer pair I'm encoding doesn't necessarily have anything to do with a complex number, and I'm going to be separating them before and after encoding either way
08:18:46 <joelr> dons: you are gonna love this for sure
08:19:01 <merijn> lamefun2: The simplest way to describe the monad laws is "common sense"
08:19:19 <merijn> lamefun2: Stuff like "x >>= id" should be equal to "x"
08:19:42 <nand`> except it isn't
08:19:51 <joelr> consider this abstract c++ class: http://pastie.org/3868923
08:19:58 <merijn> err
08:19:58 <joelr> dons, Peaker: ^
08:19:59 <merijn> Wait
08:19:59 <Philippa> "do will behave in an approximately sequential manner" (where "approximately sequential" looks rather monoidal)
08:20:03 <nand`> shouldn't x >>= id be the same as join x?
08:20:12 <joelr> i'm trying to wrap it in haskell and implement the callbacks in haskell as well
08:20:22 <merijn> nand`: I fail, I guess I missed return there
08:20:37 <nand`> indeed :)
08:20:40 <west_roadie> I'd like to parallelise the following: reading a list from IO, and then applying a costly function to each element of the list
08:20:42 <merijn> I guess the simplest instance would be that "x >>= return" == "x"
08:20:50 <joelr> i will need to subclass this class in c++ and then dispatch to haskell from the methods. the thing is, i may not necessarily want to implement all the callbacks in haskell.
08:20:51 <west_roadie> at the moment I have something like
08:21:01 <Peaker> merijn, (>>= id) is join, (>>= return) is id
08:21:08 <dons> joelr: ok. seems reasonable. and you can mix and match
08:21:09 <Peaker> nand`, Ah, I don't really know that encoding, maybe it makes sense then :)
08:21:13 <joelr> i'm thinking of a "set callback" function in haskell and then keeping a table of what callbacks are actuallly set on the haskell side
08:21:18 <dons> do the hard stuff on the haskell side. the simple/fast stuffon the C++ side
08:21:23 <dons> yeah
08:21:26 <nand`> lamefun2: 1. return x >>= f = f x; 2. x >>= return = x; 3. (a >=> b) >=> c = a >=> (b >=> c)
08:21:31 <dons> register your callbacks in some table
08:21:33 <west_roadie> (parMap rseq) f <$> sequence (map parse [1..n])
08:21:34 <joelr> dons: would keeping an array of funptrs on the c++ side be a problem?
08:21:48 <joelr> dons: e.g. in ocaml i had to allocate a "block" and register it with the garbage collector
08:21:53 <dons> should be ok. they're marked as exported on the haskell side, right?
08:21:53 <west_roadie> and so it seems it just does it one by one and waits on the IO for the next one so it can't proceed, and spends 75% of the time IDLE
08:22:00 <Peaker> west_roadie, sequence (map f x) = mapM f x
08:22:03 <joelr> dons: should they be?
08:22:05 * liyang blinks 
08:22:09 <dons> foreign export ?
08:22:12 <liyang> OMG. It's a dons!
08:22:23 <Peaker> west_roadie, and (f x) y  = f x y
08:22:25 <Philippa> also, a liyang!
08:22:31 <dons> joelr: if they're dynamically created, sometimes you need to create a stableptr table on the haskell side too, but that's less common
08:22:33 <joelr> dons: so no way to keep it pure then?
08:22:35 <dons> usually foreign export is enough
08:22:46 <liyang> Philippa: I'm always here…
08:22:51 <joelr> dons: that one! i want to pass in a regular haskell function, e.g. a closure
08:23:03 <Philippa> liyang: fair enough. I guess I don't speak that often these days either
08:23:10 <dons> you'll need to store it on the haskell side, or the GC might take it away from you
08:23:10 <joelr> dons: i may want to close over some state or some such
08:23:23 <dons> keep the table on the .hs side, and have refs to it from C++
08:23:24 <Philippa> (I'm trying to remember where it was someone put an applicative do QQ on hackage now)
08:23:36 <joelr> dons: how can i keep a ref to that table from c++?
08:23:43 <dons> so some kind of stable ptr closure table in an MVar or similar. pass FunPtrs to C++
08:23:58 <Philippa> (found it)
08:24:08 <dons> i don't think it'll be too ard
08:24:13 <dons> hard. the callback model is fairly common
08:24:42 <joelr> dons: will need to check this table in c++ to make sure the callback is set, no?
08:25:12 <joelr> dons: e.g. in the AccountList method check to see if the account list callback was set
08:25:20 <dons> yeah, you'd lookup to see if the callback was handled. then dispatch to it.
08:25:37 <joelr> dons: so how do i do this lookup when the table is on the haskell side?
08:25:53 <dons> the closure would be in a table registered on the haskell side. lookup would have to check that table (or keep a bool-wise mirror of it)
08:26:28 <joelr> dons: this is a trading platform so lookup needs to be very fast, which is why i was thinking of keeping the table on the c++ side
08:26:36 <dons> i think you can do that.
08:26:47 <joelr> dons: how?
08:26:49 <dons> you just need to not drop references on the .hs side as well -- even if you don't use that table for access
08:26:59 <joelr> hmm
08:27:13 <dons> registering a callback: stores a funptr on the C++ side; adds an entry to a table on the haskell side (so it won't get GCd)
08:27:21 <dons> removing a callback removes the entry from both sides
08:27:30 <dons> calling just evals the funptr on C++ side
08:28:14 <dons> so, its like doing it all on the C++ side, but you also register the callbacks somewhere on the haskell side as well, so they don't get removed. stableptrs can be used to ensure the reference doesn't move around
08:28:36 <joelr> dons: get it now. one last question… the callbacks are all typed differently, e.g. the 1st and 3rd arguments are the same but the 2nd always changes
08:29:06 <dons> wrap them in a hetero thingy. e.g. a data type or existential.
08:29:07 <joelr> dons: would I store a constructor of a data type with multiple constructors (one per callback) on the haskell side?
08:29:20 <dons> i would
08:29:46 <joelr> dons: then how would i say from c++ that i'm referring to this or that callback in terms of types?
08:29:47 <dons> good hygiene - enumerate your protocol's cases by having a constructor for each one
08:30:15 <dons> i don't see an issue on the c++ side -- you can do what you want with types there.
08:30:21 <joelr> e.g. how would haskell know, when the callback is triggered that it's … hmm… maybe it doesn't matter because haskell -already- knows
08:30:30 <dons> yep
08:30:31 <joelr> the types
08:30:41 <dons> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-StablePtr.html is yr friend
08:31:43 <joelr> dons: thanks! trying to develop an algorithmic trading platform here. built around http://www.rithmic.com/home.html
08:32:53 <joelr> dons: so a list (set?) of stable ptrs on the haskell side then, just to make sure they don't get disposed of
08:33:36 <dons> yeah, turn yr closures into stableptrs, so they don't move around. that ref can then be used to call the haskell code.
08:33:38 <joelr> dons: and a case statement in "set callback" on the haskell side that converts the constructor to, say, an integer
08:34:06 <joelr> dons: and then pass the constructor # and closure to the c++ side. right?
08:34:14 <dons> yep. i think that'll be fine.
08:34:22 <joelr> dons: thanks a lot
08:34:31 <dons> just pay attention to the Foreign.* libraries
08:34:47 <joelr> dons: yes, reading up all i can about the ffi
09:03:12 <nand`> hmm
09:03:16 <nand`> all of my packages are broken now for some reason
09:03:49 <nand`> including but not limited to stuff like Control.Monad.Random
09:05:04 <kallisti> Dear Haskell,
09:05:05 <geekosaur> cabal decided upgrading to the latest mtl was a good idea?
09:05:12 <kallisti> someone on the internet has said that -Wall will warn about partial guards
09:05:38 <kallisti> now I, being the inquisitive fellow I am, had to wonder exactly how that would even be possible.
09:06:56 <c_wraith> kallisti: it's pretty easy for patterns, and it's easy to determine some cases for guards, too.
09:07:05 <kallisti> right I can understand patterns
09:07:16 <kallisti> perhaps if you factor guards into case expressions
09:07:19 <geekosaur> partial guards are possible for simple expressions involving finite enumerations; for the general case, apparently it cheats and warns if you leave off a catchall
09:07:29 <c_wraith> yeah, that's pretty much it.
09:07:33 <kallisti> ah
09:07:50 <nand`> ah, fixed all of my broken packages
09:07:56 <nand`> forgot to run haskell-updater after rebuilding GHC
09:08:16 <c_wraith> if your guards are like | x < 0 -> foo ; | x >= 0 -> bar, it won't know that's complete
09:08:48 <c_wraith> it just looks for a few things that it knows are guaranteed to be complete
09:14:33 <merijn> Hmm, does Data.Lens provide a way to export the lenses it generates using TH?
09:15:45 <navaati> hi
09:17:27 <navaati> is there a FIFO structure in the standard lib ? because lists feels more like LIFO (appending at the end is horrible)
09:18:35 <merijn> navaati: You can use two list and implement (amortised) O(1) appending :)
09:18:39 <BMeph> navaati: Appending "at the end" is what a LIFO structure would to. ;)
09:18:50 <BMeph> Err, would *do.
09:18:50 <merijn> At least, I thought it was O(1), much better than O(n) at any rate
09:18:57 <Saizan> navaati: there's Data.Sequence
09:19:10 <merijn> BMeph: I think he meant that "appending at the end (like list does)" is horrible
09:19:44 <finnrobi> navaati: http://www.haskell.org/ghc/docs/latest/html/libraries/containers-0.4.2.1/Data-Sequence.html <- check if this works for you?
09:19:49 <qaxk> hi, i'm just starting out with haskell, and i was wondering if there was a better way to do this: http://paste.lisp.org/display/129333
09:20:05 <BMeph> merjn: Well, _I_ meant that appending at the end is -> supposed <- to be horrible, if your structure is a FIFO one, as lists are. :)
09:20:47 <navaati> i meant appending at the end of a list (where end means the opposite of the head) is horrible (O(n))
09:20:50 <Philippa> navaati: the Report standard lib, or the Platform?
09:21:00 <navaati> yeah, Sequence seems cool
09:21:06 <BMeph> For that matter, why is reversing a Sequence O(n)? Why isn't it O(1)?
09:21:10 <rwbarton> qaxk, not really, unless you want to use an array
09:21:35 <qaxk> hmm, okay
09:22:19 <nand`> what does LIFO have to do with appending to the end? why not just append to the beginning, which is O(1) for lists?
09:22:35 <nand`> or did I misread something
09:23:24 <BMeph> nand`: Um, because if LIFO stands for "Last-In, First-Out," then appending at the end would make it the last thing in? :)
09:23:51 <nand`> but you don't take elements from the end, you take them from the beginning
09:23:53 <nand`> at least if you're sane
09:24:04 <navaati> nand`: i want a queue, but lists are stack if you only want to use O(1) operations : cons is push and head is pop
09:24:37 <nand`> navaati: indeed
09:25:02 <hpc> you can make a list into an O(1) queue in some special cases
09:25:18 <hpc> queueOfNumbers n = n : queueOfNumbers (n + 1)
09:25:26 <bitonic> BMeph: you could have Seq reverse O(1) tagging the "direction" of the queue but that'd be ugly
09:25:38 <ment> you can make list into an O(1) amortized queue
09:25:41 <ment> (FIFO)
09:25:57 <BMeph> bitonic: Why would it be ugly? Would anyone need to see it?
09:25:58 <navaati> well, seems that Sequence can be sanely used as either a queue and a stack, how is it implemented internally ? double-linked list ?
09:26:00 <hpc> ment: well, pair of lists
09:26:06 <ment> hpc: yeah
09:26:15 <bitonic> BMeph: no but the code would be annoying
09:26:18 <Enigmagic> navaati: 2-3 finger trees
09:26:27 <bitonic> BMeph: and it's probably not a common use case anyways
09:26:34 <navaati> ouch, yeah, more complicated than i thought
09:26:40 <rwbarton> Sequence also supports efficient concatenation
09:27:05 <rwbarton> not sure that this is compatible with O(1) reverse
09:27:05 <navaati> and i realized that all complexities are given amortized, which is not what i want…
09:27:08 <bitonic> BMeph: ah true, what rwbarton says
09:27:48 <Enigmagic> navaati: depending on the application, you could also look at Chans or TChans
09:28:29 <navaati> aren't these intended for concurency ?
09:29:02 <nand`> ment: how would this work?
09:29:15 <hpc> navaati: sure, but still useful in single-threaded cases
09:29:24 <merijn> navaati: Well, yes. But that doesn't mean you can't use them single-threaded :p
09:29:25 <hpc> MVar makes a good "nullable IORef"
09:29:40 <navaati> hum, they live in IO
09:29:42 <navaati> not good
09:29:53 <rwbarton> they are mutable queues, yes
09:30:24 <navaati> maybe a FIFO is actually impossible to make in a pure way ?
09:30:33 <rwbarton> no?
09:30:46 <bitonic> navaati: why? are you talking of some specific complexity?
09:30:52 <rwbarton> several solutions were already mentioned
09:31:16 <jtza8> Busy reading RWH, just curious though, is there a way to "inherit" from a type?
09:31:18 <navaati> (of course i'm talking about a FIFO with O(1) push and pop)
09:31:33 <bitonic> navaati: that's []
09:31:49 <byorgey> jtza8: no, Haskell does not have subtyping or inheritance
09:31:57 <merijn> jtza8: Not really, not in the usual OO interpretation
09:32:00 <ment> nand`: keep two lists Q [a] [a], when queueing: cons the second one, dequeue: head the first one
09:32:14 <hpc> jtza8: you can sometimes fake it with type classes, but pretend i didn't say that
09:32:14 <BMeph> navaati: I was trying to "hint" to you that stacks and lists are FIFO. Queues are LIFO. :)
09:32:14 <ment> nand`: in case the first one is empty reverse the second one and move it to the first one
09:32:26 <merijn> jtza8: You would usually use encapsulation (i.e. embed the type you're "inheriting" from in the new type)
09:32:49 <navaati> BMeph: sh*t, am i being confused as hell ?
09:32:49 <hpc> BMeph: you have it backwards
09:32:55 <madjestic> hey guys, I am looking for a graphics library for Haskell.  I find HOpenGL to be too low-level for my needs.  I am looking for something more like processing.org that would allow to quickly set up rendering of basic shapes and primitives, maybe basic animation...
09:33:03 <merijn> Like this: "data Foo; data Bar = Bar Foo Int" Bar effectively "inherits" Foo here
09:33:04 <nand`> ment: oh, amortized O(1)
09:33:12 <nand`> ment: missed that
09:33:29 <BMeph> hpc: Bah, you're right.
09:33:29 <hpc> madjestic: cairo?
09:33:32 <geekosaur> madjestic, SDL bindings maybe?
09:33:34 <merijn> jtza8: In my experience inheritance is a terrible idea anyway
09:33:40 <rwbarton> Sequence would also be amortized O(1)
09:33:40 <__zero> any list of haskell exercises?
09:33:41 <BMeph> navaati: Never mind, I'm a dummy today.
09:33:44 <navaati> madjestic: gloss
09:33:49 * BMeph goes to get some coffee
09:34:04 <byorgey> madjestic: gloss or diagrams, depending on what you want to do
09:34:17 * navaati <3 gloss
09:34:20 <merijn> jtza8: It only seems a good idea in things like Java because it's the only type of polymorphism they have
09:34:21 <kallisti> merijn: I think inheritance can be useful, but there are certainly other ways.
09:34:22 <hpc> madjestic: possibly also gtk/cairo
09:34:24 <nand`> __zero: there's http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
09:34:31 <madjestic> thanks, I'll look into it
09:34:38 <byorgey> if HOpenGL is too low-level, then gtk/cairo will be as well
09:34:42 <merijn> kallisti: Sure, I just meant that in most scenarios that isn't the case
09:34:59 <navaati> merijn: (actually no, they have interface polymorphism)
09:35:00 <jtza8> byorgey, merijn, hpc: Hmm... So if I were to have something like a 2D vector, it would be better to declare separate types for things such as points, unit vectors, etc.?
09:35:03 <merijn> kallisti: Even in scenario's like games there are better, more modular approaches
09:35:04 <bitonic> navaati: anyways, a purely functional non-amortised O(1) queue is not doable
09:35:40 <ment> nand`: someone should make a page with simple data structures like this (instead of pointing newbs to okasaki)
09:35:41 <byorgey> jtza8: you would certainly want a separate type for points.  I don't see why you need to distinguish unit vectors.
09:35:42 <navaati> bitonic: ah. that's what i was wondering but rwbarton said it was, so…
09:35:49 <merijn> jtza8: I would certainly try (as much as possible) to have different types for things which are different
09:35:58 <byorgey> jtza8: but if you did want to distinguish unit vectors, you could make a newtype wrapper around your 2D vector type
09:36:00 <bitonic> navaati: why do you need non-amortised? real time?
09:36:38 <navaati> bitonic: mostly curiosity : my event queue should not be bigger than a few elements
09:36:43 <ment> realtime haskell? wtf
09:37:00 <bitonic> navaati: ok so what you'll actually do is just use Seq :P
09:37:42 <navaati> even simpler : what i'll do is just use events++[event]
09:37:45 <bitonic> if it's a few elements [] is probably even better than Seq
09:37:46 <rwbarton> I didn't mean to say a purely function non-amortised O(1) queue is possible
09:38:03 <rwbarton> you left out quite a few of those conditions when you asked "is a FIFO impossible" :)
09:38:04 <AndrewMarsh> navaati: Just searched for haskell queue - http://www.randomhacks.net/articles/2007/02/08/haskell-queues-without-pointers
09:38:18 <AndrewMarsh> Haven't read it yet but might help your situation
09:38:25 <bitonic> AndrewMarsh: those will all be amortised O(1)
09:38:41 <merijn> I like the xmonad queue example I saw in an SPJ talk
09:39:01 <navaati> rwbarton: ah, sorry, i thought it was clear i wanted a non-amortized O(1) one
09:39:09 <jtza8> byorgey, merijn: I suppose my reason for wanting to "inherit" is so that I can use polymorphisim on the accessor methods due to the isomorphic nature of these types.
09:39:52 <merijn> "data Queue a = Queue [a] [a]" where the first is the front and the second the end. You append to the second list (in front, so O(1)) and pop from the start of the first list (also O(1)), when the first list is empty you reverse the second put it in the first slot
09:40:00 <AndrewMarsh> Yeah, sorry, wasn't paying enough attention
09:40:02 <madjestic> thanks, Gloss seems to be what I am looking for
09:40:18 <jtza8> byorgey, merijn: The thought of an accessor function such as vec2DX is unappealing.
09:40:20 * hayashi wishes there was just some quick way of saying (function x y _ z) returning a function that when applied to n fills in _ with n, without having to resort to full-on lambdas or fun with flip.
09:40:20 <merijn> jtza8: But you can just have true polymorphic operators without inheriting at all
09:40:47 <merijn> jtza8: Take a look at the haskell Numeric typeclass, for example
09:40:56 <rwbarton> anyways, according to okasaki, you can write a worst-case O(1) purely functional queue
09:41:17 <companion_cube> amortized O(1)?
09:41:19 <rwbarton> no
09:41:35 <jtza8> merijn: Thanks for the advice.
09:41:48 <merijn> jtza8: Things like (+) have the type "(Num a) => a -> a -> a", if you want a datatype to support (+) you can then just implement an instance of Num for that datatype
09:42:11 <bitonic> rwbarton: really? that's interesting
09:42:12 * bitonic goes to get the book
09:42:26 <merijn> jtza8: This means for example that you could allow your 2D vector type to support existing operators like (+) and (*)
09:43:30 <bitonic> navaati: and of course rwbarton is right, Okasaki has a chapter on "real time queues"
09:44:20 <merijn> jtza8: Which is exactly the point I was trying to make earlier. Often people think they want inheritance in situations where they really want polymorphism. This usually stems from inheritance being the only polymorphism in some languages
09:44:42 <navaati> "Purely Functional Data Structures" book ? looks interesting
09:46:23 <navaati> alternately i could use an array and pray that my event queue does not exceed a certain size
09:47:02 <hpaste> merijn pasted “Polymorphic equality” at http://hpaste.org/68153
09:47:29 <merijn> jtza8: For example check out that code example that lets "==" with a custom Vec2D datatype
09:48:33 <merijn> On unrelated note, do I want tagchup or tagsoup for parsing HTML?
09:49:23 <jtza8> merijn: Thanks for all the help.
09:49:44 <merijn> jtza8: np
10:03:56 <hayashi> @pl \x y -> f x y >> g x y
10:03:56 <lambdabot> ap (ap . ((>>) .) . f) g
10:04:23 * hayashi has once again asked too much of pl.
10:04:47 <hayashi> I ought to stop doing that and ask a human instead.
10:04:58 <geekosaur> secretly, often asking anything of @pl is asking too much of it
10:05:34 <geekosaur> the conflation of point-free and pointless has a point :)
10:06:11 <parcs`> :t (liftM2 . liftM2) (>>)
10:06:12 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) (m2 :: * -> *) a b. (Monad m, Monad m1, Monad m2) => m (m1 (m2 a)) -> m (m1 (m2 b)) -> m (m1 (m2 b))
10:06:32 <parcs`> :t (liftM2 . liftM2) (>>) `asTypeOf` \f g x y -> f x y >> g x y
10:06:32 <lambdabot> forall (m :: * -> *) a b t t1. (Monad ((->) t), Monad ((->) t1), Monad m) => (t -> t1 -> m a) -> (t -> t1 -> m b) -> t -> t1 -> m b
10:08:31 <parcs`> @pl \f g x y -> f x y >> g x y
10:08:31 <lambdabot> liftM2 (liftM2 (>>))
10:08:40 <rwbarton> cute
10:09:36 <hayashi> I'm not convinced I'll be making the change anytime soon =P
10:10:20 <rwbarton> @pl \f g x -> f x >> g x
10:10:20 <lambdabot> liftM2 (>>)
10:10:30 <rwbarton> @pl \f g x y z -> f x y z >> g x y z
10:10:30 <lambdabot> liftM2 (liftM2 (liftM2 (>>)))
10:10:55 <parcs`> > execWriter $ (tell >> tell) "hi"
10:10:56 <lambdabot>   No instance for (Control.Monad.Writer.Class.MonadWriter
10:10:56 <lambdabot>                    ...
10:12:07 <merijn> GHC is impressive at slowing down my system :p
10:13:25 <bitonic> merijn: try compilin the agda standard library
10:13:28 <bitonic> *compiling
10:13:56 <parcs`> try use flash on linux
10:14:08 <bitonic> agda stdlib beats flash, hands down
10:17:37 <merijn> It's probably a combination of stuffing 20GB over the network do my desktop while compiling a bunch of stuff
10:21:12 <Expez> In which OSS project can I find idiomatic Haskell code worth reading?
10:21:29 <ezyang> GHC!
10:23:59 <merijn> I've heard Xmonad is a pretty good one too
10:24:23 <Expez> Thanks, seems there's enough code to read in the GHC repo :)
10:24:56 <merijn> Expez: XMonad is likely to be simpler and smaller to start with, so it depends on what you're looking for
10:26:21 <Expez> merijn: yeah, but the man pages says it's only 1200 lines of code. Will read it though, as I'm using it atm
10:27:26 <merijn> It's about 2k LOC, last time I checked
10:27:43 <merijn> But 2k LOC of haskell can do still quite a lot and be interesting to read :p
10:28:12 <Expez> true
10:30:12 <rkrzr> if you specify type extensions in a cabal file, how does that interfere with the extensions specified in a module directly?
10:30:41 <c_wraith> rkrzr: they're OR'd together
10:31:11 <rkrzr> so the extensions in the cabal file are automatically put into all modules of that package?
10:31:13 <c_wraith> rkrzr: unless the module specifies the opposite of what the cabal file did, in which case it overrides it
10:31:34 <c_wraith> yes, they're added as compile flags for all modules
10:32:21 <rkrzr> so if I want to have one instance overlap another one, then I will add the OverlappingInstances pragma into the file with the instance that should be overridden?
10:32:41 <rkrzr> and not add it to the cabal file?
10:33:01 <c_wraith> In general, I don't use any extensions in the cabal file. It's easier to see what's going on that way
10:34:56 <rkrzr> c_wraith, yes that seems like a sensible approach since this confuses me already enough without invisible OR magic
10:35:36 <aristid> c_wraith: it's also easier to use ghci that way
10:36:31 <mdmarek> Anyone know how to do virtual-hosts with Wai+Warp ?
10:44:56 <navaati> mdmarek: i think you need to use a frontend server like nginx doing reverse-proxy
10:45:38 <parcs`> mdmarek: dispatch based on the serverName?
10:45:50 <merijn> If I want to do some webscraping, what's the best approach? Text.HTML.Tagsoup + Network.Download/Network.Curl.Download? (and which of the two download libraries do I want?)
10:49:02 <mdmarek> navaati: there has got to be a way of doing it, I know Happstack can do it in just a line of code, so I imagine Wai can also...
10:49:19 <mdmarek> I just don't know how yet
10:50:15 <mdmarek> parcs: yes, so if you request foo.com you go to App1, and if you request bar.com you go to App2
10:51:03 <parcs`> mdmarek: err, yeah: http://hackage.haskell.org/packages/archive/wai/1.2.0.1/doc/html/Network-Wai.html#v:serverName
10:51:34 <aristid> merijn: there's a new html-conduit package, maybe that is what you want
10:52:59 <mdmarek> parcs: do you know if anyone has already built on that, some module that combines with routing ?
10:53:09 <merijn> aristid: Looks to complicated for what I want, I just want (unless I'm looking at the wrong package?) I just want "fetch URL, extract data from HTML"
10:55:12 <mdmarek> I think I found a usabe example, http://www.yesodweb.com/blog/2011/06/cookbook
10:55:32 <parcs`> mdmarek: i was just going to say i bet yesod can do it :)
10:55:57 <mdmarek> Yeah, isn't Warp written by the same author?
10:56:57 <aristid> merijn: it has a function for parsing a lazy ByteString to a (XML) Document. i don't think that is complicated.
10:58:43 <mzero> Yesod and Wai are for serving HTTP / HTML - you are trying to parse it, yes?
11:05:22 <lamefun2> I haven't found anything magical in Monad class that could explain magicallness of IO. Is IO magical?
11:05:36 <geekosaur> nope
11:06:10 <kallisti> > let true x y = x; false x y = y; or x y = x true y; and x y = x y false; toBool b = b True False in toBool (false `or` true)
11:06:11 <lambdabot>   True
11:06:19 <mzero> no, even Monad isn't magical... just cool
11:07:03 <kallisti> lamefun2: IO is marginally magical, in that it relies on a primitive of the language rather than being defined by the language itself.
11:07:20 <geekosaur> @where IO_Inside
11:07:21 <lambdabot> I know nothing about io_inside.
11:07:22 * hayashi wonders why getChar isn't working magic until a newline is sent
11:07:23 <mzero> but Monad is just defined in the langauge's libraries
11:07:23 <geekosaur> bah
11:07:43 <kallisti> yes, there is nothing special about the Monad class, except that we give it nice syntax sugar in the form of do notation.
11:07:44 <mzero> hayashi: if your input is line buffered, that will happen well before your code
11:07:54 <otters> so I have a program that involves loading /usr/share/dict/words into memory, which is about 268,000 words
11:08:12 <otters> and I want the IO action that reads the file to not be lazy
11:08:41 <kallisti> so you want to load the entire file into memory instead of incrementally?
11:09:02 <otters> yes
11:09:14 <kallisti> I /think/ the strict ByteString file IO operators do this, but I'm not certain.
11:09:18 <otters> incremental won't help me
11:09:31 <kallisti> well it doesn't really hurt either.
11:09:43 <kallisti> assume you process the file linearly
11:09:45 <kallisti> *assuming
11:09:49 <otters> right
11:10:00 <hpc> the cheating way would be "do {contents <- readFile foo; evaluate (length contents); return contents}"
11:11:17 <otters> @where evaluate
11:11:17 <lambdabot> I know nothing about evaluate.
11:11:35 <geekosaur> @index evaluate
11:11:36 <lambdabot> Control.Exception, Test.QuickCheck, Debug.QuickCheck
11:11:38 <hayashi> mzero: Cheers
11:11:44 <mzero> hi ho
11:11:51 <kallisti> otters: conduits!
11:12:27 <ski> lamefun2 : `IO' is primitively implemented, just like `Int' and `Float' are
11:13:03 <ski> lamefun2 : so, `IO' is magical to the same extent that `Int' and `Float' are magical
11:14:18 <mzero> otters - which way are you reading the file - as String, as ByteString, or as Text --- in any event, the later two offer non-lazy reads
11:14:25 <otters> as Text
11:14:49 <otters> using Data.Text.IO
11:14:55 <otters> .hGetContents
11:15:22 <mzero> right - that isn't Lazy
11:15:26 <otters> right
11:15:31 <merijn> aristid: Hmm, I think I looked at the wrong conduit, then? I can't really find anything via Hoogle or Google for html-conduit, just HTTP and XML?
11:16:08 <mzero> is the worry reading it all at once? You can use hGetLine to read one at a time, just be sure to catch the error on EOF
11:16:08 <kallisti> shapr: finals over yet? :P
11:17:25 <merijn> aristid: Oh, I found it I think. There's just no docs on hackage yet
11:17:36 <aristid> merijn: hackage has not generated the api docs yet, that's how new it is. but it's just one small module: https://github.com/snoyberg/xml/blob/master/html-conduit/Text/HTML/DOM.hs
11:18:39 <aristid> merijn: note that xml-types and xml-conduit contain some utility functions to actually extract information from a Document
11:20:24 <merijn> aristid: The downside seems to be that I first have to figure out this whole conduit thing
11:20:54 <aristid> merijn: no.
11:21:08 <aristid> merijn: there's a function to parse directly from a ByteString
11:21:25 <aristid> merijn: so you _can_ learn conduits if you want more efficiency, but you don't need to.
11:21:43 <Enigmagic> otters: here's a different way... using conduits: https://gist.github.com/ebe14d772b248171a0c6
11:22:35 <aristid> merijn: and there is this (non-conduit, despite being in the -conduit package) way to extract information: http://hackage.haskell.org/packages/archive/xml-conduit/0.7.0.1/doc/html/Text-XML-Cursor.html
11:23:09 <merijn> aristid: Yeah, but that would just bring me back to my original Network.Download vs Network.Curl.Download question :)
11:23:26 <aristid> well _i_ would use http-conduit for that
11:23:30 <aristid> snoyman all the way down :P
11:24:54 <aristid> merijn: http-conduit actually has a non-conduit version of the request function too, which generates a ByteString.
11:26:44 <merijn> aristid: Ah, see, simpleHttp *is* useful for me :)
11:27:49 <merijn> That's much better than previous HTTP libraries I looked at (while working on something unrelated)
11:28:35 <aristid> yeah
11:29:20 <merijn> "please first specify 15 million uninteresting HTTP options before attempting to fetch a URL (and hope it doesn't redirect)"
11:29:21 <fmap> @hoogle Doc -> String
11:29:21 <lambdabot> Text.PrettyPrint.HughesPJ render :: Doc -> String
11:29:22 <lambdabot> Text.PrettyPrint render :: Doc -> String
11:29:22 <lambdabot> Text.PrettyPrint.HughesPJ renderStyle :: Style -> Doc -> String
11:29:47 <kallisti> merijn: the mere fact that it automatically adds Content-Length makes it better than then HTTP package.
11:29:52 <kallisti> s/then/the/
11:30:16 <merijn> kallisti: Yeah, man that sucked
11:30:30 * kallisti still needs to switch from HTTP to http-conduit in his webdriver code.
11:31:07 * merijn is reminded of the Python "X for Humans" talk
11:34:33 <zhulikas> @hoogle Int -> [a] -> [[a]]
11:34:33 <lambdabot> Prelude drop :: Int -> [a] -> [a]
11:34:34 <lambdabot> Data.List drop :: Int -> [a] -> [a]
11:34:34 <lambdabot> Prelude take :: Int -> [a] -> [a]
11:35:14 <zhulikas> more like 2 -> "12345" -> ["12", "23", "34", "45"]
11:35:15 <zhulikas> any ideas?
11:36:20 <hpc> :t \n -> take n . tails
11:36:22 <lambdabot> forall a. Int -> [a] -> [[a]]
11:36:36 <hpc> let ns = \n -> take n . tails in ns "12345"
11:36:41 <hpc> > let ns = \n -> take n . tails in ns "12345"
11:36:43 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
11:36:43 <lambdabot>         against inferred type ...
11:36:55 <aristid> > take 2 . tails $ [1..5]
11:36:57 <hpc> > let ns = \n -> take n . tails in ns 2 "12345"
11:36:57 <lambdabot>   [[1,2,3,4,5],[2,3,4,5]]
11:36:58 * hackagebot JuicyPixels-repa 0.3.1 - Convenience functions to obtain array representations of images.  http://hackage.haskell.org/package/JuicyPixels-repa-0.3.1 (ThomasDuBuisson)
11:36:58 <lambdabot>   ["12345","2345"]
11:37:07 <hpc> > let ns = \n -> map (take n) . tails in ns 2 "12345"
11:37:09 <lambdabot>   ["12","23","34","45","5",""]
11:37:09 <zhulikas> :)
11:37:14 <zhulikas> yeah, that.
11:37:16 <zhulikas> thanks
11:37:23 <zhulikas> well...
11:37:28 <zhulikas> ok, thanks
11:37:40 <biskup> Hi
11:37:40 <hpc> > let ns = \n -> takeWhile ((== n) . length) . map (take n) . tails in ns 2 "12345" -- this might have some efficiency problems...
11:37:42 <lambdabot>   ["12","23","34","45"]
11:37:49 <kane77> I am trying to compile gtksourceview2, but I get error: dist/build/Graphics/UI/Gtk/SourceView/Types.h:1:28: fatal error: gtksourceview2.h: No such file or directory
11:38:01 <biskup> i've madea new language in haskell- WIBIMze
11:38:03 <mm_freak_> how exactly would one implement linear types?  as a type function?
11:38:06 <mm_freak_> Linear Integer?
11:38:10 <zhulikas> I think I will just get rid of last elements
11:38:13 <mm_freak_> or is it a feature of the function arrow?
11:38:25 <biskup> write ums throw ~ strfunct()
11:39:15 <lamefun2> what is the best way to implement Canvas-like things (In OOP i'd do Canvas->DrawTriangle(x1, y1, x2, y2, x3, y3))?
11:39:37 <biskup> look at http://hask-hax.com/canvas/tutorials
11:39:58 <lamefun2> Firefox can't find the server at www.hask-hax.com.
11:39:59 <mm_freak_> lamefun2: you can also get good ideas by looking into the gloss library
11:40:35 <biskup> sorri,in saudi arabia domains ar .ar
11:40:37 <mm_freak_> in any case you need to decide whether you want a mutable or an immutable canvas
11:40:38 <biskup> try it agan with .ar
11:41:23 <lamefun2> IDK
11:41:27 <lamefun2> it'll mostly interface OpenGL
11:41:49 <biskup> opengl is gut. but try OpenBIT - it's more efficent
11:42:09 <ski> mm_freak_ : as in linear algebra ?
11:42:15 <biskup> sure
11:42:18 <mm_freak_> lamefun2: look into gloss:  http://hackage.haskell.org/package/gloss
11:42:23 <mm_freak_> it does exactly that
11:42:32 <mm_freak_> map a pure canvas to opengl operations
11:42:59 <mm_freak_> ski: as in restricted uniqueness types…  i don't know if this is related to linear algebra, but i'm reading wadler's paper right now
11:43:09 <biskup> rupsikupsidupsi
11:43:22 <biskup> skaggerak jor var svat
11:43:24 <biskup> ?
11:43:37 <ski> mm_freak_ : linear types /= uniqueness types
11:43:49 <ski> mm_freak_ : and in either case, you need type system support
11:44:07 <mm_freak_> ski: yes, i'm implementing a language, so right now i'm going to add that support
11:44:23 <biskup> da
11:44:23 <biskup> sd
11:44:24 <biskup> asd
11:44:24 <biskup> as
11:44:24 <biskup> das
11:44:24 <biskup> d
11:44:24 <biskup> qwe
11:44:25 <biskup> qw
11:44:25 <biskup> e
11:44:25 <mm_freak_> ski: as i understand them values of linear types must be applied exactly once
11:44:26 <biskup> qw
11:44:26 <biskup> e
11:44:27 <biskup> 12
11:44:27 <biskup> 31
11:44:28 <biskup> 23
11:44:44 <biskup>  Nasze zaktualizowane zasady użytkowania będą obowiązywały od 25 maja 2012 r. Dowiedz się więcej. Czy coś dzieje się w Twojej okolicy? Sprawdź, zrób zdjęcia i prześlij, aby wzbogacić artykuły Wikipedii o kulturze w Polsce. [edytuj] Kilogram kilogram (kg) Układ	SI Wymiar	 Jednostka	masy Typowe symbole wielkości	m, M w jednostkach SI	podstawowa w jednostkach CGS	 w jednostkach anglosaskich	 Kilogram – jednostka masy,
11:44:45 <biskup>  Nasze zaktualizowane zasady użytkowania będą obowiązywały od 25 maja 2012 r. Dowiedz się więcej. Czy coś dzieje się w Twojej okolicy? Sprawdź, zrób zdjęcia i prześlij, aby wzbogacić artykuły Wikipedii o kulturze w Polsce. [edytuj] Kilogram kilogram (kg) Układ	SI Wymiar	 Jednostka	masy Typowe symbole wielkości	m, M w jednostkach SI	podstawowa w jednostkach CGS	 w jednostkach anglosaskich	 Kilogram – jednostka masy,
11:44:45 --- mode: ChanServ set +o mauke
11:44:45 --- mode: mauke set +q *!*@gateway/web/freenode/ip.81.210.14.160
11:44:46 <lamefun2> biskup: buy Vista!
11:45:01 <lamefun2> Just buy it! It helps in case of mental problems!
11:45:13 <mm_freak_> lamefun2: don't feed the troll
11:45:22 <ski> mm_freak_ : basically you have a unique type if the corresponding value hasn't had it's reference duplicated *yet* -- and you have a linear type if the corresponding value can't be duplicated any *more* (it might have been duplicated in the part)
11:45:24 <kallisti> so is there no unsigned equivalent to Integer?
11:45:24 <lamefun2> Why not? It's fun!
11:45:39 <nand`> lamefun2: because it trains them to expect food from humans
11:45:42 --- kick: biskup was kicked by mauke (biskup)
11:45:46 <ski> mm_freak_ : and yes, linear logic is (vaguely) related to linear algebra
11:46:25 <lamefun2> Why is that bad? Feeding trolls is fun!
11:46:37 <ski> mm_freak_ : you can easily go from a unique value to an (ostensively) non-unique one -- and you can easily go from a non-linear value to a linear one
11:46:51 <mm_freak_> ski: i see
11:47:02 <ski> mm_freak_ : for details about the relation between them here, you might want to ask edwardk
11:47:02 <mm_freak_> ok, let me finish reading wadler's paper…  then i'll give it a try
11:47:04 --- mode: mauke set +b *!*@gateway/web/freenode/ip.81.210.14.160
11:47:41 <mm_freak_> anyway, the idea was to have safe destructive update
11:47:53 <mm_freak_> and i'd like to have that as implicit as possible
11:47:58 <ski> mm_freak_ : finally, it is not necessary to attach the uniqueness information to the types (as Clean does) -- you could also handle it separatedly, or e.g. attach it to instantiatedness infor (which is what Mercury does)
11:48:16 <mm_freak_> yeah, that was the idea
11:48:23 <ski> mm_freak_ : *nod*, that's the typical application of uniqueness types/modes
11:48:58 <mm_freak_> arraySet : Index -> a -> Unique (Array a) -> Array a
11:49:03 <mm_freak_> does that look reasonable?
11:49:04 --- mode: mauke set -o mauke
11:49:50 <ment> :t Unique
11:49:51 <lambdabot> Not in scope: data constructor `Unique'
11:50:03 <mm_freak_> ment: that's not haskell…  it's a language i'm implementing in haskell
11:50:17 <mm_freak_> it's just that this channel is the best one to ask these questions =)
11:51:08 <aristid> mm_freak_: shouldn't there be a Unique on the result, too?
11:51:17 <ment> mm_freak_: what could keep it from looking reasonable?
11:51:19 <mm_freak_> aristid: i don't see why
11:51:32 <aristid> mm_freak_: is it possible to create a Unique from an arrat?
11:51:35 <aristid> *array
11:51:38 <ski> mm_freak_ : note that `Unique' here is *not* a type constructor
11:51:52 <aristid> mm_freak_: if not, how do you chain array modifications?
11:51:54 <mm_freak_> ski: yeah, i know…  i sense that uniqueness is a feature of the function arrow
11:52:06 <ski> more or less, yes
11:52:07 <kallisti> :)
11:52:19 <mm_freak_> in other words:  arraySet : Index -> a -> Array a ~~> Array a
11:52:20 <ski> (well, not quite, but you can think of it like that for the while)
11:52:23 <lamefun2> mm_freak_: so gloss just feeds picture description into IO?
11:52:25 <mm_freak_> where (~~>) is the unique function arrow
11:52:31 <mm_freak_> lamefun2: yes
11:52:33 <ski> in Clean you'd say
11:52:39 <lamefun2> data Picture = ... | Pictures [Picture]
11:52:42 <aristid> mm_freak_: where can that function arrow type be used?
11:52:51 <mm_freak_> aristid: a value is unique as long as it is applied exactly once
11:52:52 <ski>   arraySet :: Index a *(Array a) -> *(Array a)
11:53:11 <ski> where `*' is your `Unique'
11:53:12 <aristid> mm_freak_: so you have some magic in the typechecker that counts how often it is used?
11:53:19 <mm_freak_> aristid: yeah
11:53:37 <lamefun2> wow
11:53:40 <mm_freak_> ski: why is the result unique?
11:53:40 <lamefun2> so simple?
11:53:52 <mm_freak_> lamefun2: sure
11:54:00 <ski> mm_freak_ : and yes, there should be a `Unique' in the result -- to promise that the result is the only reference to that array, so that you may use further in-place update on it
11:54:29 <ski> remember that it's easy to go from `*(Array a)' to `Array a' if you need to -- but hard to go the other way (copying)
11:54:59 <mm_freak_> ski: hmm…  is that a clean property?  because i can see how the result is unique iff it's applied exactly once
11:55:15 <ski> i'm not sure what you mean by "clean property"
11:55:20 <mm_freak_> Clean property
11:55:22 <lamefun2> purity above efficiency?
11:55:36 <mm_freak_> lamefun2: gloss is efficient…  note that haskell is lazy
11:55:36 * ski stares quizzingly at lamefun2
11:57:41 <ski> mm_freak_ : do you mean anything technical by "Clean property" ?
11:58:09 <ski> (also, i'm not sure how the result could be applied to anything -- it's an array, not a function)
11:58:11 <mm_freak_> ski: i mean:  is there any danger in having the uniqueness as an implicit property?  i.e. only the left side of the uniqueness function arrow specifies uniqueness
12:00:13 <ski> mm_freak_ : yes, certainly
12:00:46 <ski> your `arraySet' function might e.g. just fetch an already existing array which is hiding inside the `Index'
12:00:53 <ski> (or is global-extent, say)
12:01:23 <ski> the type system has no way of knowing you won't do this, unless you add the `*' around the return type as well
12:01:58 <ski> because adding it there promises that what is returned is the *unique* reference to the value in question
12:02:08 <lamefun2> and
12:02:32 <ski> (and so for `arraySet' to be well-typed, it must check this extra restriction)
12:03:06 <lamefun2> are functions in data X = X { xMember :: Int } just syntactic sugar for xMember :: X -> Int    xMember (X x) = x ?
12:03:20 <ski> almost
12:03:43 <ski> let's take an example with more than one field
12:04:03 <hpc> you also get to use record syntax in pattern matching
12:04:07 <hpc> so you can write
12:04:08 <ski>   data Person = P { name :: String , age :: Int }
12:04:25 <hpc> foo (X {xMember = bar}) = doThingsWith bar
12:04:44 <hpc> or
12:05:07 <hpc> rename p newName = p {name = newName} -- record "modification"
12:05:17 <mm_freak_> ski: i don't understand…  the returned array is the already updated array…  is there any danger in using it multiple times?  note that update operations require uniqueness, so if you want to update again there must be only one reference
12:05:19 <kallisti> lamefun2: xMember is a function with that type, yes. But you also get pattern matching syntax, as seen above.
12:05:23 <ski> now you can write `P { name = "Aludra" , age = 37 }' or  `P { age = 37 , name = "Aludra" }' instead of `P "Aludra" 37'
12:05:47 <lamefun2> so
12:05:57 <ski> mm_freak_ : the type doesn't promise at all that the returned value has any storage connection with the input array
12:06:00 <lamefun2> should I care that no two datas have same member names?
12:06:39 <ski> mm_freak_ : what would stop me from defining
12:06:41 <kallisti> you should be aware that record fields aren't in a special namespace.
12:06:46 <ski>   emptyArray :: Array a
12:06:50 <SideEffffECt> hello
12:06:52 <SideEffffECt> what difference does it make, when data type has (one, of course) type constructor with the same name, and when with different?
12:07:08 <ski>   arraySet index element array = emptyArray
12:07:08 <ski> ?
12:07:15 <ski> mm_freak_ ^
12:07:24 <kallisti> lamefun2: it's fairly common to prepend soemthing to the front of each field to disambiguate it from other fields on different types, but it's not really required; you can use the module system to remove ambiguity when needed.
12:07:38 <mm_freak_> ski: ah!  i see now
12:07:39 <mm_freak_> thanks
12:07:56 <mm_freak_> so it's not a matter of how the result is used, but how it's constructed
12:08:01 <Saizan> SideEffffECt: just the name
12:08:09 <mm_freak_> i guess i was too much thinking of primitive operations
12:08:20 <ski> mm_freak_ : it's a matter of maintaining the invariant of having exactly one reference to a value
12:08:35 <SideEffffECt> Saizan: and what about exporting from the module it's deffined in?
12:09:04 <mm_freak_> SideEffffECt: the type and constructor namespaces are entirely separate
12:09:16 <kallisti> lamefun2: record syntax is something of a weak spot in Haskell. It's not too bad, but it could be better.
12:09:18 <mm_freak_> i.e. there is nothing wrong with having:  data A = B; data B = A
12:09:32 <Saizan> SideEffffECt: still no difference
12:10:06 <Saizan> SideEffffECt: if you have an explicit export list the syntax is TypeName(ConstructorName)
12:10:14 <ski> mm_freak_ : that `arraySet' can omit the compile-time-scheduled freeing of the input array and allocation of the new array, contracting those into a single upate-in-place operation is "merely" an optimization that is allowed by knowing that we have the only reference to the input array (and after this operation it's dead, therefore the storage can be reused)
12:10:28 <lamefun2> Weak spot? So haskell isn't a perfect language of the future that magically prevents all bugs and security issues?
12:10:34 <SideEffffECt> Saizan: hmm, ok. so how is it with exporting anyway? when I export a data type, are it's constructors exported with it along automatically too?
12:11:07 <ski> mm_freak_ : and yes, one wouldn't *need* to set the result as unique here -- but then one couldn't use update-in-place on that in turn -- which we'd like to be able to do
12:11:20 <mm_freak_> ski: ok, got it
12:11:43 <ski> mm_freak_ : in practice, Clean uses uniqueness variables which a function can be polymorphic in
12:12:20 <Saizan> SideEffffECt: in an export list TypeName will export only the type but no consturctor TypeName(C1,C2) will also export the consturctors C1 and C2 and TypeName(..) will export all of them
12:12:44 <ski> mm_freak_ : so instead of `*(Array a)' you'll often see `u:(Array a)', where `u' can either mean "unique" or "non-unique", depending on which instance is used
12:12:47 <Ngevd> Is it possible to change the code page of output?
12:13:07 <mm_freak_> sounds reasonable
12:13:16 <mm_freak_> ski: now i would like to have both unique and linear types in the language…  linear types for world-style stuff, unique types for in-place update…  is that reasonable?
12:13:46 <merijn> kallisti, lamefun2: I've been playing with lenses lately and they make a lot of the record syntax annoyances disappear :)
12:13:48 <ski> mm_freak_ : this way you can write a single append function that will reuse the first input list if it is unique (modifying the last tail of it), returning a new unique list (in case the other input was also unique), otherwise copying the skeleton of the first list as usual
12:14:13 <Saizan> Ngevd: hSetEncoding stdout someEncoding should do
12:14:25 <navaati> merijn: do they solve the namespace clash problem ?
12:14:36 <mm_freak_> ski: that kind of polymorphism feels as hacky as haskell's function arrow kind
12:14:48 <ski> mm_freak_ : i'm not sure if you need to use linear types instead of unique types for the world -- Clean and Mercury certainly uses uniqueness for the world as well
12:14:48 <merijn> navaati: No, but updating and dealing with nested datatypes becomes very easy
12:14:51 <mm_freak_> at least in older GHCs
12:15:00 <Ngevd> Saizan, thanks
12:15:26 <ski> (and yes, i know the paper is called "Linear *Types* can Change the World!")
12:15:48 <mm_freak_> ski: i suppose it would suffice…  let me read wadler's paper on linear types for the basic theory behind it
12:15:52 <mm_freak_> then i'll give it a shot
12:17:10 <ski> mm_freak_ : hehe, Mercury actually has a very interesting mode and determinism system, where depending on how you call the append/3 predicate, can use it to (a) concatenate two lists; (b) try to match a prefix on a list, getting a suffix if successful; (c) split a list in half in all possible ways
12:17:26 <ski> mm_freak_ : logically, all these *modes* of append/3 are the same logical relation
12:18:22 <ski> mm_freak_ : Prolog will actually execute exactly the same code in all these cases -- Mercury however won't (partly because it tries to be more efficient), and so will statically determine which of a few separatedly compiled procedures to call
12:18:50 <ski> mm_freak_ : note though that you only write a single source implementation of append/3 -- it's just that this gets compiled to three different procedures
12:18:50 <lamefun2> uhm
12:19:26 <lamefun2> when should I use Data { m1 :: Type1, m2 :: Type2, ... } and when should I use Data Type1 Type2 ?
12:20:39 <ski> lamefun2 : use the former when you have many arguments and/or you expect to fiddle around with adding and/or removing arguments much
12:21:14 <lamefun2> why not just use the former always?
12:21:41 <ski> it's syntactically heavier
12:21:47 <lamefun2> it automatically gets me accessors
12:21:49 <byorgey> in order not to pollute the namespace with functions you will never use.
12:22:04 <ski> if you'll never use the accessors, it's not much point
12:22:12 <ski> e.g. for
12:22:16 <lamefun2> is Color R G B A worth to declare with the {}?
12:22:33 <ski> lamefun2 : borderline, i'd say
12:22:40 <byorgey> lamefun2: it totally depends on what you want to do with it
12:22:43 <ski> i'd probably not do it, others might
12:22:44 <lamefun2> what's the point of data structure when you don't access its members?
12:22:49 <Azel> do you often acces a component of the colour ?
12:23:05 <ski> lamefun2 : you can access them by pattern-matching positionally, as well
12:23:08 <navaati> lamefun2: you can always pattern-match on the Color constructor
12:23:24 <byorgey> foo (Color r g b a) = ...
12:23:36 <lamefun2> and also
12:23:47 <ski> (also, imo the derived `Show' instances for record-defined stuff is usually more ugly than the alternative)
12:23:49 <Azel> If you access two or three components at a time, it may not be wotrh it to create the accessors
12:24:00 <joelr> moin
12:24:18 <lamefun2> how do I name arguments?
12:24:23 <lamefun2> uhm, members
12:24:31 <joelr> is anyone using ghc 7.4.1 on the mac on top of the brew version of the haskell platform?
12:24:42 <joelr> just wondering if you are experiencing any problems
12:24:44 <lamefun2> decrypt: TrianglePic Triangle Triangle TriVertColors Texture
12:24:56 <lamefun2> should I make type aliases?
12:24:59 <lamefun2> or comments?
12:25:15 <navaati> type aliases are nice
12:25:37 <navaati> aspecially since they are propagated in functions etc.
12:25:40 <byorgey> type aliases are nice *if* they will get used in a bunch of places.  Not worth it just to document the arguments of a single function.
12:25:48 <byorgey> (IMO)
12:25:57 <lamefun2> type TriTexCoords = Triangle?
12:26:17 <ski>   compare :: Ord a => Comparator a  -- *cough*
12:26:21 <mm_freak_> ski: yeah, i've learned the basics of prolog a long time ago…  i liked it, but writing serious programs felt cumbersome in it…  maybe mercury has this improved
12:26:24 <byorgey> if you use Haddock comments you can document individual arguments and it shows up nicely in the generated documentation
12:26:49 <mm_freak_> particularly in prolog you had to name everything…  everything…
12:27:01 <byorgey> ski: cough?
12:27:02 <navaati> i definitely need to learn haddock…
12:27:16 <ski> mm_freak_ : Mercury has a static type system (with algebraic data types, parametric polymorphism, type classes, existentials) and a static mode/determinism system -- also a proper module system as well as closures
12:27:45 <ski> byorgey : would you like that type synonym to be used more ?
12:28:41 <byorgey> ski: I don't know, seems borderline to me.  I'm not sure what point you are trying to make.
12:28:43 <mm_freak_> ski: sure, and i see the merits of logic programming…  nice concept, but it failed for real applications
12:29:21 <SideEffffECt> Saizan: great, thx
12:30:14 <ski> byorgey : mostly that i (a long time ago) made a post to c.l.f arguing for using a lot of type synonyms in the standard library for a lot of similar cases
12:30:47 <ski> mm_freak_ : hm, forgot to say that Mercury also has functions
12:31:54 <byorgey> ski: ah, fair enough.  I think Comparator could be nice.  There's definitely a balance between concise type signatures and the number of type synonym definitions you have to remember in order to understand them.
12:32:09 <osa1> I'm trying to write a lexer with alex. do I have to use something like writer monad to collect strings or does alex contain helpers for collecting strings for lexemes? I was thinking moving to a "string" state when I read " and then collecting characters until I read " character again
12:32:15 <ktklam9> hi, does anyone know if the ad (automatic differentiation) package works with mutable vectors?
12:34:46 <lamefun2> eh
12:35:17 <lamefun2> and haskell apparently solves saint problem that makes people hate operator overloading: that there are dot product and cross product
12:36:13 <jfischoff> lamefun2: dot and cross products?
12:36:13 <lambdabot> jfischoff: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:36:28 <jfischoff> @messages
12:36:28 <lambdabot> dmwit asked 2d 21h 31m 1s ago: what MetaType is for
12:36:29 <lambdabot> dmwit asked 19h 15m ago: What editor do you use? You have large comment boxes with words inside denoting sections; does your editor have support for hiding/showing sections, or are you doing that
12:36:29 <lambdabot> yourself in wetware?
12:36:54 <lamefun2> you have only one * operator in most languages and vector can have dot products and cross products and can also be multipled on numbers that makes it ambigious
12:37:16 <lamefun2> I've seen it several times used as counter-argument for operator overloading
12:38:25 <ktklam9> if I have a matrix represented as a Vector (Vector a), what would be the most efficient way to implement a matrix transpose?
12:39:34 <hpaste> eh pasted “QUESTION ABOUT MARSHALLING POINTERS FROM A  PCAP DISPATCH” at http://hpaste.org/68159
12:40:10 <lamefun2> hm
12:40:29 <lamefun2> is there a way to overload just operator+?
12:40:41 <rwbarton> use C++
12:41:22 <jfischoff> lamefun2: don't use num. Your own prelude. Qualify Num and use something else..
12:41:55 <ski> `+' is already overloaded
12:42:12 <ski> you just need to make another instance of `Num'
12:42:53 <Botje> eh: could it be that dispatch always gives you the same ptr?
12:43:37 <Botje> eh: in which case you'd have to manually copy each packet to a new piece of memory and store that pointer.
12:44:10 <Botje> eh: also, that code is pretty hardcore. :)
12:44:36 <Botje> I'd use Data.IORef for the counters and update a Data.Sequence as you go along.
12:44:45 --- mode: ChanServ set +o mauke
12:44:46 --- mode: mauke set -q *!*@gateway/web/freenode/ip.81.210.14.160
12:46:45 --- mode: mauke set -o mauke
12:47:15 <kallisti> oh. I just realized a very simple way to do recursion via a fix-esque combinator.
12:47:23 <kallisti> er, with trees, specifically.
12:48:49 <ski> do tell
12:48:52 <Botje> kallisti: oleg already did it. in the type system ;)
12:49:12 <kallisti> f :: Monad m => (m [a] -> m (Tree a)) -> Tree a -> Tree a
12:49:28 <kallisti> er
12:49:36 <kallisti> f :: Monad m => (a -> m [a] -> m (Tree a)) -> Tree a -> Tree a
12:49:48 <kallisti> the second argument of the inner function recurses on the children.
12:50:28 <kallisti> return = f (\a c -> Node a <$> c)
12:50:43 <kallisti> actually
12:50:50 <kallisti> you don't need to return a tree
12:50:57 <ski> are you sure you'ren't missing an `m' somewhere ?
12:51:07 <kallisti> f :: Monad m => (a -> m [a] -> m b) -> Tree a -> m b
12:51:08 <eh> Thanks Botje, I believe that is correct. The packet is stored in the buffer, the pointer points to the buffer, and the buffer is cleared with each subsequent packet.
12:51:11 <kallisti> yeah at the end.
12:51:23 <jfischoff> kallisti: i wonder if using uniplate would be helpful
12:51:28 <kallisti> this lets you do pre/post order traversal
12:51:50 <ski> kallisti : s/[a]/[b]/ ?
12:52:16 <kallisti> no
12:52:23 <Botje> eh: I'd think you get a fresh bytestring everytime if you use the dispatchBS version
12:52:27 <kallisti> m [a] recurses on the children
12:52:35 <kallisti> oh wait
12:52:40 <ski> hm, actually i mean `[m b]'
12:52:41 <kallisti> yeah that would be m [b] then. :P
12:52:54 <kallisti> right. I assume sequence is applied.
12:53:04 <ski> yeah, but with `[m b]
12:53:09 <Botje> yes, it does a B.create
12:53:20 <ski> ' you can handle the children in any order
12:53:31 <kallisti> true.
12:53:39 <ski> maybe it would be nicer to factor out the node elements, though .. hm
12:53:53 <eh> I know that the packets are all the same length so I will just get the pointer and do a `memcopy' to some other location and store the pointer to that location?
12:53:54 <ski>   f :: Monad m => (a -> [(a, m b)] -> m b) -> Tree a -> m b
12:54:51 <ski> so each child is labelled with the root label of it, so you can decide better in what order to do them
12:55:03 <kallisti> ah yeah
12:55:25 <kallisti> honestly a better sequence type than [] would be nice.
12:55:41 <ski> well, `[]' is what `Tree' uses
12:55:55 <Botje> eh: you can grab the size of the packet from the PktHdr
12:56:01 <kallisti> right
12:56:14 <MrBusiness> what would you charge to write haskell bindings to 30 c structs and 101 functions?
12:56:15 <ski> and if you'd want to change the traversal function, you can just use `Reader' or `State'
12:56:18 <kallisti> ski: would Seq be a reasonable alternative to [] for a Tree structure?
12:56:25 <kallisti> or perhaps parameterize on the child container?
12:56:57 * ski would try to avoid premature specialization
12:58:38 <romildo> Can one easily get positions as offsets with Parsec? If so, how? Internally Parsec keeps the position as a (line,column) pair.
12:59:10 <ski> kallisti : hm, i suppose `Tree a' is almost `GenStream [] a'
13:02:15 <kallisti> ski: what/where is that?
13:02:35 <ski> hum, i dunno if it's in any lib
13:02:44 <ski> but you know
13:03:03 <ski>   newtype GenList ref a = GL (ref (GenListCell ref a))
13:03:09 <ski>   data GenListCell ref a = Nil
13:03:24 <ski>                          | Cons a (GenList ref a)
13:03:42 <ski> where `GenStream' is what you get if you remove the `Nil' constructor
13:04:03 <kallisti> right
13:06:35 <lamefun2> грь
13:06:39 <lamefun2> uhm
13:06:46 <lamefun2> couldn't imagine that picture description could be so simple
13:07:04 <lamefun2> without crazy class hierarchies
13:08:32 <kallisti> the simplest possible design is the best out of every design with the same capabilities.
13:10:37 <navaati> lamefun2: picture description of which lib ?
13:10:51 <lamefun2> gloss
13:11:20 <navaati> ah yeah, simple, efficient
13:11:43 <kallisti> :t traverse
13:11:44 <lambdabot> Not in scope: `traverse'
13:13:48 <lamefun2> can Haskell program have plugins or they are necesserily monolithic?
13:14:03 <jfischoff> lamefun2: yes it can
13:17:56 <osa1> which alex version do I need to have installed to run alex examples in it's github repo? I'm trying with latest alex and examples don't work
13:20:20 <shapr> kallisti: No, three finals in the next three days.
13:20:23 <shapr> kallisti: THEN code :-)
13:20:32 <kallisti> ha. fair enough.
13:21:25 <ski> @keal
13:21:25 <lambdabot> it is very easy to go off topic
13:25:44 <kallisti> ski: how about (a -> [m b] -> Maybe b) -> Forest a -> b ?
13:26:05 <kallisti> less obtuse to work with I think.
13:26:19 <kallisti> you just return Nothing if you want to omit a result, similar to mapMaybe.
13:27:02 <ski> i'm not sure for what purpose you want me to judge it
13:27:18 <kallisti> generic traversal/map/filter of nodes in a tree.
13:27:53 <mm_freak_> kallisti: a generic traversal combinator is a fold
13:28:25 <kallisti> yes but how do you go about writing filters with it? in the code I've been writing, I've used mapMaybe and explicit recursion.
13:28:28 <mm_freak_> not the one from Data.Foldable or Data.Traversable, but a type-specific fold
13:28:38 <kallisti> ah
13:28:40 <kallisti> yes.
13:28:43 <ski> let's say it's a tree representing a (sub)filesystem, and that i want to search down a particular path, returning the subfilesystem tree it's pointing to
13:29:14 * ski tries to recall who were talking about directories the other day
13:29:26 <mm_freak_> example:  data Tree a = Leaf a | Branch (Tree a) (Tree a)
13:29:51 <mm_freak_> the corresponding fold would have this type:  (a -> b) -> (b -> b -> b) -> Tree a -> b
13:30:11 <mm_freak_> see how the function arguments correspond to the constructors
13:30:53 <nand`> mm_freak_: what's the semantic on that? Why not just (a -> a -> a) -> Tree a -> a; together with a Functor instance?
13:31:01 <mm_freak_> fold l b (Leaf x) = l x; fold l b (Branch bl br) = b (fold l b bl) (bold l b br)
13:31:23 <mm_freak_> nand`: because that's not as generic
13:32:09 <mm_freak_> in particular a fold has an identity:  fold Leaf Branch = id
13:33:18 <ski>   nandFold Branch . fmap Leaf = id  -- i suppose
13:33:35 <nand`> that's what I was thinking as well
13:34:32 * ski recalls reading an argument in "Algebra of Programming" for the style mm_freak_ suggests
13:34:42 <ski> .. can't recall what it was, though :/
13:34:43 <mm_freak_> fmap Leaf :: Tree a -> Tree (Tree a);  nandFold Branch . fmap Leaf :: Tree (Tree a) -> …
13:34:51 <mm_freak_> uhm, no
13:34:58 <mm_freak_> maybe you're right
13:35:36 <mm_freak_> nandFold Branch :: (Tree a -> Tree a -> Tree a) -> Tree (Tree a) -> Tree a
13:35:37 <ski> maybe `build'-`fold'-fusion is a good argument
13:36:00 <ski> s//`asAppliedTo`/
13:36:58 <mm_freak_> ski: i was motivated by the work of bird
13:37:58 <ski> Bird and de Moor are great
13:39:01 <mm_freak_> nand`: how did you get the idea?  is there a more general concept i missed?
13:39:01 <ski> nand` : anyway, how would your preferred folding operation for `data Tree a = Tip | Node a (Tree a) (Tree a)' look like ?
13:39:45 * ski refrains from confounding nand` with a non-regular data type -- this time !
13:39:50 <nand`> mm_freak_: no, I just looked at the type signature of your fold and wondered
13:40:01 <mm_freak_> i see
13:40:10 <nand`> (nandFold Branch . fmap' Leaf $ mytree) == mytree
13:40:12 <nand`> just tested it
13:40:38 <mm_freak_> well, i'd rather have defined fmap in terms of my fold
13:41:01 <nand`> fmap = flip fold Branch ?
13:41:41 <mm_freak_> fmap f = fold (Leaf . f) (\l r -> Branch (fmap f l) (fmap f r))
13:41:44 <nand`> ski: I still have no idea
13:42:03 <ski> nand` : i was just looking for the type signature
13:42:31 <mm_freak_> in fact you can write all the usual instances up to Monad in terms of the same fold
13:43:01 <mm_freak_> generically speaking of course…  i'm not suggesting that the tree is a monad
13:43:35 <kallisti> mm_freak_: I was looking for something like mapMaybe for rose trees.
13:43:36 <ski> trees are commonly monads
13:44:00 <mm_freak_> in some cases it's also useful to have a Fold type
13:44:13 <nand`> mm_freak_: why not just: fmap f = fold (Leaf . f) Branch
13:44:25 <mm_freak_> nand`: as far as i see that's a type error
13:46:56 <nand`> fold :: (a -> b) -> (b -> b -> b) -> Tree a -> b and Leaf :: a -> Tree a; and Branch :: Tree a -> Tree a -> Tree a; given f :: (a -> b) the first argument is (a -> Tree b) and the second is (Tree b -> Tree b -> Tree b) therefore the end result is also Tree b and the final type is (a -> b) -> Tree a -> Tree b
13:46:58 <nand`> it seems to work fine in ghci
13:48:41 <mm_freak_> true
13:48:58 <mm_freak_> my head is already smoking from all the type theory and parser writing today =)
13:49:58 <nand`> that's good; builds up endurance
13:50:51 <mm_freak_> hmm!
13:51:20 <mm_freak_> i think if the data structure is a monad, the corresponding fold is a category!
13:55:59 <cvprog> how are the qt bindings for haskell, any tutorials on how to use them ?
13:59:32 <merijn> cvprog: I think they're all highly experimental
13:59:48 <merijn> I'm not aware of any stable Qt bindings
14:00:04 <cvprog> merijn: what about gtk?
14:00:30 <merijn> cvprog: gtk and wx both have stable bindings, but I dunno of the top of my head what they're calles
14:00:40 <merijn> Although gtk2hs seems a safe guess
14:02:02 * hackagebot OpenGLRaw21 1.2.0.1 - The intersection of OpenGL 2.1 and OpenGL 3.1 Core  http://hackage.haskell.org/package/OpenGLRaw21-1.2.0.1 (JakeMcArthur)
14:02:16 <lamefun2> how to get precise timestamps?
14:02:22 * ski peers curiously at mm_freak_
14:02:23 <cvprog> merijn: how than are gui apps built with haskell, i em looking to make a DAW i have the option of working with C++ or haskell i em looking at  http://leksah.org/index.html and wondering how they made their gui
14:03:01 <cvprog> merijn: i em most comfertable with qt than gtk as their is more support
14:03:32 <rwbarton> well you can see leksah dependencies for yourself here, http://hackage.haskell.org/package/leksah
14:03:36 <rwbarton> looks like gtk
14:03:46 <mzero> leksah is gtk
14:04:41 * mzero builds all his GUI apps as web servers!
14:05:03 <merijn> mzero: I'm seriously considering this
14:05:15 <merijn> But I'm not sure what I'll hate more...
14:05:32 <mzero> there's nothing crazy about it... except the horror of all that JavaScript you have write!
14:05:33 <merijn> JS/browser compatibility sucks, but GUI programming sucks too
14:05:39 <mm_freak_> ski: i think my constraints are too relaxed
14:05:50 <mzero> oh, JS/browser compatibility is a solved issue: jQuery!
14:06:00 <mzero> just code to that and stop worrying!
14:06:08 <mm_freak_> Fold l b . Fold l' b' = Fold (join . liftM l . l') undefined
14:06:14 <kallisti> shapr: if you have some time check out the code and let me know what you think
14:06:17 <mm_freak_> not sure by what to replace the 'undefined' there
14:07:03 * ski suggests mm_freak_ learn about Contraint Logic Programming
14:07:29 <mm_freak_> ski: if Fold has this definition, it works:  data Fold a b = Fold (a -> Tree b) (Tree b -> Tree b)
14:07:39 <mm_freak_> but that's very constrained
14:08:03 <cvprog> can a gui be programmed be program in another language and than call haskell functions for the functionality?
14:08:41 <kallisti> you could do that pretty easily with C
14:08:47 <mm_freak_> cvprog: why would you want to do that?  gtk2hs is a pretty straightforward translation of the C API, and there are also some high level libraries like reactive-banana
14:08:51 <kallisti> otherwise you'd have to rely on dynamically loading libraries.
14:08:55 <xplat> yes, you can call haskell from C or from anything with a C FFI
14:08:58 * Philippa suggests everyone learn about CLP!
14:09:27 <Philippa> is reactive-banana for folding UIs?
14:10:17 <xplat> i thought it was to make sliding animations easier
14:10:48 <ski> mm_freak_ : the `b's appears to have been lost ..
14:10:56 <Guest04564> http://slidetocode.com/2012/04/09/why-i-prefer-scheme-to-haskell/ thoughts on this article?
14:11:31 <ski> mm_freak_ : <http://comonad.com/haskell/Origami.hs> may or may not be interesting, for whatever you're trying to do
14:12:09 <hpc> is it just me or are gtk's event handlers kind of odd?
14:12:16 <merijn> Guest04564: Without reading the article I can state that Scheme and Haskell are both very interesting in their own ways and are suited to very different things
14:12:29 <Guest04564> merijn: yes :)
14:13:03 * merijn doesn't really do "this language is better than that language"
14:13:18 <mm_freak_> ski: i was just curious, but i'm going back to my language implementation now =)
14:13:20 <merijn> Learn as much as you can and then use whatever makes your life easiest :)
14:14:10 <merijn> With the exception of PHP and Cobol :p (Java is semi-okay, but most of its libraries and frameworks seem designed by braindead idiots...)
14:14:36 <ski> Guest04564 : there is `trace :: String -> a -> a' which you can use inplace of `display'-style debugging
14:20:18 <Plex-> what's the deal with leksah's constant compiling? unless that is really necessary, will get annoying
14:21:09 <lamefun2> what's the prefered way to hide implementation details?
14:21:29 <kallisti> typically through the module system.
14:21:35 <kallisti> you can choose what you wish to export.
14:21:36 <ski> Guest04564 : btw, note that you can use monads in Scheme as well
14:21:45 <lamefun2> when they are so large that they themselves need to be divided into modules
14:22:01 <kallisti> and for modules whose sole purpose is to be "internal" to the library, you can leave it out of the exposed-modules property when building with cabal.
14:22:16 <mm_freak_> i don't agree with the author of that article…  it directly contradicts my experience with haskell as a practical language to get things done
14:23:35 <Philippa> we have a lot of knowledge about common interfaces and conventions that's not as well-codified/documented as it could be, though
14:23:40 <Philippa> some people get it anyway, some people don't
14:24:03 <mm_freak_> yet there is no other language where i can learn new libraries as fast as in haskell
14:24:22 <Philippa> yeah, but that's because of those conventions
14:24:25 <mm_freak_> usually i just look into the haddocks…  and often the names and types tell everything there is to know
14:24:33 <merijn> mm_freak_: It varies with the library, though
14:24:48 <Philippa> the names, the types, the things we know about free theorems and the conventions it's highly likely haven't been broken (spot the monoids!)
14:24:49 <merijn> mm_freak_: Sometimes I wish there was a bit more high-level documentation :p
14:24:54 <Philippa> merijn: agreed!
14:25:04 <mm_freak_> sure…  learning edwardk's libraries takes a bit longer…  but it also pays off =)
14:25:24 <mm_freak_> Philippa: or in one word:  consistency
14:25:41 <merijn> For example, I need to do some HTML parsing and just the Haddocks of xml-conduit aren't really taking me anywhere (although I just found a post on the Yesod site, so maybe that'll help)
14:25:50 <mm_freak_> haskell is consistent…  even if the library's design sucks, usually you can still learn it by names and types…  at least as an experienced haskell programmer
14:26:12 <mm_freak_> merijn: i learned the whole conduit deal looking only into the haddocks
14:26:34 <Philippa> mm_freak_: yeah, and it's great /unless your brain hasn't made the right abstractions yet/. If it hasn't, you're going to have an unpleasant experience
14:26:46 <mm_freak_> michael writes great documentation, but the great thing is:  you really only need it for yesod, because it's so TH/QQ-heavy
14:26:48 <nand`> yeah that's the great thing about haskell; the type of something tells you basically all you need to know
14:26:59 <Philippa> so there's a significant class of people who aren't necessarily just stupid who are going to have a bad experience
14:27:13 <mm_freak_> nand`: usually you'll need the name as well
14:27:21 <merijn> mm_freak_: Maybe that works for learning all of conduit, but I just want to know Text.XML.Cursor and deal with HTML, without learning all this conduit stuff, as (at the moment) its irrelevant for what I want to do
14:27:28 <nand`> mm_freak_: true; otherwise something like (Num a) => a -> a is a bit.. ambiguous
14:27:43 <nand`> mm_freak_: but I meant apart from the name
14:30:28 <scooty-puff> why/when is touchForeignPtr necessary?
14:30:55 <scooty-puff> (for writing own touch<..> with Weak's)
14:31:54 <scooty-puff> if i performGC before a touchKey (in this case), the Key is still gc'd..
14:32:30 <lamefun2> how to discard last function's return value in IO () ?
14:33:12 <fmap> @hoogle void
14:33:12 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
14:33:12 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
14:33:12 <lambdabot> package void
14:36:37 <ski> scooty-puff : for artificially prolonging the extent of a `ForeignPtr', iiuc
14:42:36 <dmwit> lamefun2: Add a line that says "return ()" to your do block.
14:43:38 <merijn> dmwit: Well, void from Control.Monad also works
14:44:02 <merijn> And is arguably cleaner/clearer
14:44:30 <dmwit> depends
14:44:49 <dmwit> For a long do-block, I think it's not clearer.
14:44:58 <dmwit> For a point-free action, it may very well be clearer.
14:50:35 <nand`> void $ do
14:51:18 <dmwit> I'm well aware how to use it, thanks.
14:51:49 <merijn> Or just void on the last line, which seems less confusing
14:52:03 <merijn> void at the top would indeed make it easy to miss
14:52:24 <nand`> the question I ask myself here is whether it's important to know the action ends with an IO () inside the do block itself
14:53:18 <nand`> ie. is it confusing to not see the “void” or not when you don't really care about the return type inside the action itself (which for an IO () action is likely)
14:53:24 * ski cringes everytime he seees `Control.Monad.void'
14:55:04 <xplat> argh, dfkdsfs
14:56:01 <xplat> if a usb drive disconnects when it's attached, how do i get cryptsetup to realize it's gone so i can reattach it.  first one who says 'reboot' gets a free lollipop and a crowbar to the head.
14:56:37 <xplat> er, sorry, meant that for -blah
14:56:40 <dmwit> Don't know anything about cryptsetup, but how about just restarting cryptsetup?
15:04:56 <oddraisent> > parse ((many1 (noneOf "\n")) `sepBy` (string "\n") `endBy` (string "\n")) "" "string1\nstring2\nstring3\n"
15:04:57 <lambdabot>   Not in scope: `parse'Not in scope: `many1'Not in scope: `noneOf'Not in scop...
15:05:06 <oddraisent> How can I get ["string1", "string2", "string3"] ?
15:05:32 <ski> > lines "string1\nstring2\nstring3\n"
15:05:33 <lambdabot>   ["string1","string2","string3"]
15:05:54 <oddraisent> in parsec, obv
15:06:22 <oddraisent> Those query returns unexpected end of input
15:06:31 <oddraisent> this*
15:07:05 <xplat> dmwit: cryptsetup isn't a daemon, it's a program that adjusts things in the kernel.  the answer was 'use dmsetup to remove the mapping because it touches the same stuff at a lower level'.
15:10:07 <lamefun2> I have a Vector2 tuple (Double, Double)
15:10:15 <lamefun2> how to pattern-match it in let?
15:10:36 <lamefun2> let (x, y) = ?
15:14:17 <ski> how is the type defined ?
15:14:32 <sipa> let (Vector2 x y) = ... ?
15:14:52 * ski would avoid the brackets
15:15:34 <lamefun2> type Vector2 = (Double, Double)
15:15:46 <ski> then what you said first works
15:15:52 <sipa> ah
15:16:19 <ski> (you could also use `... where (x,y) = ...')
15:17:25 <merijn> Man, xml-conduit needs an easy way to print/show the name/attributes of the element a cursor is pointing to >.>
15:39:53 <strager> oddraisent: scrap the noneOf "\n"?
15:41:19 <strager> I never used endBy and it seems you're using it wrong
15:41:30 <strager> endBy looks to be like sepBy, but with a terminator.
15:43:09 <strager> parse (many1 (noneOf "\n") `endBy` char '\n') "" "string1\nstring2\nstring3\n"
15:43:12 <strager> Right ["string1","string2","string3"]
15:43:54 <strager> It seems you were treating endBy = (<*)
15:46:38 <Targen> What would be a reasonable way to write a point-free definition of if'?
15:47:05 <ezyang> "don't"
15:47:21 <strager> Let's ask lambdabot.
15:47:24 <Targen> (for a pointless enough definition of "reasonable". of course)
15:47:31 <strager> @pl \c t f -> if c then t else f
15:47:31 <lambdabot> if'
15:47:36 <strager> Cheater.
15:47:41 <strager> @src if'
15:47:42 <lambdabot> Source not found. Maybe if you used more than just two fingers...
15:47:42 <Targen> Yeah, I tried that. :)
15:48:14 <strager> @pl \c t f x -> (if c then t else f) x
15:48:14 <lambdabot> if'
15:48:26 <strager> Too smart.
15:48:55 <Targen> Exceedingly.  And I've been unable to find its definition.
15:49:28 <merijn> Targen: I don't think you can write if' point free
15:51:02 <Targen> It'd likely be possible to define it in terms of some other function that already includes some form of conditional, I suppose, but that'd be cheating :)
15:51:12 <strager> Well I reduced it to if' c = if c then const else const id
15:51:46 <conal> is the Void type in some standardish library on hackage?
15:52:01 <rwbarton> you can cheat with fromEnum
15:52:27 <strager> hehe
15:52:52 <Targen> conal: Data.Void.  Not sure what package it's in...
15:52:57 <ByronJohnson> conal: FWIW, the pipes package uses the void package
15:53:29 <conal> terrific. thanks a bunch!
15:53:30 <ByronJohnson> I'd probably use that
15:53:40 <strager> @pl \c t f = (if c then fst else snd) (,) t f
15:53:41 <lambdabot> (line 1, column 8):
15:53:41 <lambdabot> unexpected "="
15:53:41 <lambdabot> expecting pattern or "->"
15:53:48 <strager> @pl \c t f -> (if c then fst else snd) $ (,) t f
15:53:49 <lambdabot> (. (,)) . (.) . flip (flip if' fst) snd
15:53:58 <strager> if', blast!  =]
15:54:26 <scooty-puff> ski, related to my question from forever ago: https://github.com/sonyandy/glyph/blob/develop/src/Data/WeakIntMap/Base.hs#L78
15:56:17 <dmwit> strager: Why would you write it like that in the first place?
15:56:18 <dmwit> Surely
15:56:26 <dmwit> ?pl \c t f -> if c then t else f
15:56:27 <lambdabot> if'
15:56:29 <dmwit> =)
15:56:39 <conal> hm. i was expecting a no-constructor data type for Void.
15:56:54 <linduxed> ok so dropWhile takes a function and a list right?
15:57:04 <linduxed> it drops while the function returns true
15:57:13 <t7> correct
15:57:14 <linduxed> is there a way however to invert that?
15:57:18 <strager> @pl \a b -> [a,b]
15:57:19 <lambdabot> (. return) . (:)
15:57:22 <dmwit> conal: loop is still the only term of type Void
15:57:23 <rwbarton> invert in what way
15:57:23 <t7> put no . before your function
15:57:31 <t7> not*
15:57:32 <linduxed> to give the function, but make it not drop?
15:57:34 <linduxed> oh
15:57:37 <linduxed> not and dot
15:57:41 <rwbarton> er
15:57:42 <linduxed> will try that
15:57:45 <rwbarton> not drop?
15:57:49 <rwbarton> so does it do anything at all?
15:57:56 <t7> > dropWhile (not . (< 10)) [1..20]
15:57:57 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
15:57:59 <linduxed> sorry
15:58:07 <t7> hang on
15:58:09 <linduxed> meant to negate the Bool of the function
15:58:11 <linduxed> nonono
15:58:14 <t7> > dropWhile (not . (< 10)) [20,19..1]
15:58:15 <linduxed> you said it correctly
15:58:16 <lambdabot>   [9,8,7,6,5,4,3,2,1]
15:58:23 <linduxed> i just fuck up ö-P
15:58:25 <linduxed> :-P
15:58:29 <conal> dmwit: yeah. via a subtler argument. i wonder if ed was avoiding the EmptyDataDecls language extension.
15:58:36 <linduxed> but yeah, you figured out what i wanted to say
15:58:36 <dmwit> Yes, I believe so.
15:59:02 <dmwit> Recently he's been trying to carefully separate code that *requires* language extensions from code that is H98/2010
15:59:08 <conal> it's too bad that ghc doesn't accept the natural definition by cases of functions of Void.
15:59:27 <linduxed> hmmm
15:59:29 <dmwit> Yes, it is.
15:59:30 <strager> @pl \c t f -> [f, t] !! fromEnum c
15:59:31 <lambdabot> flip (flip . ((!!) .) . flip (:) . return) . fromEnum
15:59:32 <linduxed> that reminds me of something
15:59:40 <dmwit> I think there's a feature request for this, and SPJ basically said no.
15:59:42 <linduxed> what was the difference between $ and . ?
15:59:51 <strager> There, cheating.  There you go, Targen.
16:00:04 <otters> In do { x <- some_io_action; foo x; bar x } is the IO action executed once or twice?
16:00:08 <strager> linduxed: One applies, one composes.
16:00:10 <dmwit> conal: http://hackage.haskell.org/trac/ghc/ticket/2431
16:00:11 <Targen> strager: nice!
16:00:16 <strager> Not very helpful yeah ?  ;P
16:00:23 <parcs`> otters: which action?
16:00:27 <byorgey> linduxed: the difference is that they are different.  Don't try to understand the difference, just try to understand their actual definitions.
16:00:31 <otters> parcs`: some_io_action
16:00:33 <byorgey> @src ($)
16:00:34 <lambdabot> f $ x = f x
16:00:38 <byorgey> @src (.)
16:00:38 <lambdabot> (f . g) x = f (g x)
16:00:38 <lambdabot> NB: In lambdabot,  (.) = fmap
16:01:12 * conal reads the ticket
16:01:22 <rwbarton> some_io_action is executed once
16:01:25 <otters> okay
16:01:31 <linduxed> byorgey: ok thx
16:01:41 <rwbarton> then x is the result of that action, which is just an ordinary value of whatever type it is
16:01:49 <otters> that's what I thought
16:01:54 <dmwit> conal: My memory was incorrect; SPJ said "patches welcome".
16:02:06 * hackagebot chell 0.2.3 - A simple and intuitive library for automated testing.  http://hackage.haskell.org/package/chell-0.2.3 (JohnMillikin)
16:02:49 <conal> wow. no activity in on this ticket in four years.
16:08:47 <tgeeky_> dmwit: I sent a simple pull request. I hope it's right on your side.
16:09:47 <tgeeky_> dmwit: bah. it's not right. The changes listed in "diff" are right, but for some reason it insists on including a bunch of other commits.
16:11:18 <dmwit> I'm using GHC-7.4... I guess I just installed those things before you did.
16:11:39 <dmwit> Anyway, I'll certainly merge a patch that relaxes dependencies; I put them strict just because that's the safe thing to do. =P
16:12:06 * hackagebot MemoTrie 0.4.12 - Trie-based memo functions  http://hackage.haskell.org/package/MemoTrie-0.4.12 (ConalElliott)
16:12:15 <tgeeky_> dmwit: ok. I had to bump logict regardless.
16:12:55 <dmwit> "bump" it?
16:13:05 <dmwit> We're already depending on the very latest version...
16:14:02 <tgeeky_> dmwit: logict demands mtl < 2.1; the (only) version I have installed is == 2.1
16:14:08 <strager> @pl \c t f -> fromJust $ lookup (show c) [("True", t), ("False", f)]
16:14:09 <lambdabot> ((fromJust .) .) . (. ((. (return . (,) "False")) . (:) . (,) "True")) . (.) . lookup . show
16:14:19 <tgeeky_> so I had to cabal unpack, change that version, and compile it
16:14:19 <dmwit> aaah
16:14:24 <strager> Targen: Without fromEnum, but still using type classes ^
16:14:42 <dmwit> tgeeky_: Anyway, could you make a more minimal pull request with just the .cabal and .gitignore changes? (Or I can do that myself.)
16:15:06 <tgeeky_> dmwit: yes, I can. I was hoping that it would ignore all of the crap, since those commits all refer to files that were deleted in the final head
16:15:27 <dmwit> tgeeky_: Also, upper bounds should be given with < signs and two significant figures.
16:15:51 <dmwit> <= 0.3 will prevent you from using 0.3.1 even though the PVP says it's safe to use 0.3.1 anywhere it's safe to use 0.3.
16:15:56 <dmwit> < 0.4 will allow 0.3.anything
16:15:59 <Targen> strager: How likely is it that all that juggling would get optimized away?
16:16:11 <tgeeky_> dmwit: yes, I know that's how it should work, but until I put that transformers line like I did, I had reinstall requests
16:16:15 <strager> @pl \c t f -> maybe f (const t) (guard c)
16:16:15 <lambdabot> flip (flip . flip maybe . const) . guard
16:16:19 <strager> That looks nicer
16:16:24 <tgeeky_> dmwit: let me restart from your repo directly
16:16:30 <Targen> ah, guard
16:16:32 <strager> guard uses if under the hood I bet, though ;P
16:16:33 <dmwit> tgeeky_: Yes, I'm saying you should put transformers < 0.4, not <= 0.3.
16:16:38 <dmwit> tgeeky_: Because <= 0.3 is wrong.
16:16:46 <dmwit> And not <= 0.3.0.0
16:16:58 <dmwit> (which is also wrong)
16:17:16 <tgeeky_> dmwit: ok. I was just trying to do the bare minimum :O
16:17:39 <dmwit> This is why we have the PVP. =)
16:18:44 <strager> @pl \c t f -> maybe f (const t) (elemIndex True [c])
16:18:44 <irene-knapp> yes, the package versioning policy makes for some fine player-versus-player action
16:18:45 <lambdabot> flip (flip . flip maybe . const) . elemIndex True . return
16:18:58 <strager> Using 'maybe' makes things easier.
16:19:29 <dmwit> ?tell dolio You should relax logict's dependencies a bit: it works okay with mtl 2.1. =)
16:19:29 <lambdabot> Consider it noted.
16:19:43 <dolio> Okay.
16:19:43 <lambdabot> dolio: You have 1 new message. '/msg lambdabot @messages' to read it.
16:19:55 <strager> @pl \c t f -> maybe f (const t) (listToMaybe $ takeWhile (== True) [c])
16:19:56 <lambdabot> flip (flip . flip maybe . const) . listToMaybe . takeWhile (True ==) . return
16:19:56 <dmwit> wow!
16:20:09 <dmwit> It's like a ?get-dolio command!
16:20:32 <dmwit> strager: (== True) === id
16:20:38 <strager> oo right
16:20:51 <dmwit> you might also like
16:20:53 <dmwit> [c | c]
16:20:56 <strager> @pl \c t f -> maybe f (const t) $ listToMaybe $ takeWhile id [c]
16:20:56 <lambdabot> flip (flip . flip maybe . const) . listToMaybe . takeWhile id . return
16:21:04 <dmwit> > ([True | True], [False | False])
16:21:06 <lambdabot>   ([True],[])
16:21:28 <strager> @pl \c t f -> maybe f (const t) $ listToMaybe [c|c]
16:21:28 <dmwit> Though ?pl doesn't really understand list comprehensions.
16:21:28 <lambdabot> flip (flip . flip maybe . const) . listToMaybe . return . join (|)
16:21:36 <strager> @pl \c t f -> maybe f (const t) $ listToMaybe [ c | c ]
16:21:37 <lambdabot> flip (flip . flip maybe . const) . listToMaybe . return . join (|)
16:21:38 <dmwit> ...as you can see there. =)
16:21:47 <strager> yeah =]
16:22:04 <tgeeky_> dolio: if you're going to do that now, can I assume you'll use 0.5.1?
16:22:14 <dmwit> ?pl \c t f -> maybe f (const t) (guard c)
16:22:15 <lambdabot> flip (flip . flip maybe . const) . guard
16:22:25 <dmwit> :t \c t f -> maybe f (const t) (guard c)
16:22:26 <lambdabot> forall a. Bool -> a -> a -> a
16:22:36 <strager> Yeah, already got that one.  Trying to use something more obfuscated but still understandable.
16:22:52 <dmwit> Oh, well then:
16:23:16 <dmwit> :t \c t f -> fromMaybe f (replicate (fromEnum c) t)
16:23:17 <lambdabot>     Couldn't match expected type `Maybe a' against inferred type `[a1]'
16:23:18 <lambdabot>     In the second argument of `fromMaybe', namely
16:23:18 <lambdabot>         `(replicate (fromEnum c) t)'
16:23:24 <dolio> tgeeky_: Is that the right number, or 0.5.0.1?
16:23:28 <strager> hehe
16:23:41 <dmwit> :t \c t f -> head (replicate (fromEnum c) t ++ [f])
16:23:43 <lambdabot> forall a a1. (Enum a) => a -> a1 -> a1 -> a1
16:23:43 <tgeeky_> dolio: hehe. heck if I know. dmwit knos.
16:23:49 <dmwit> strager: =)
16:24:03 <strager> Works with data Off | On!  Brilliant!
16:24:04 <Targen> Interesting generalisation of the conditional :)
16:24:45 <dmwit> dolio: Both 0.5.1 and 0.5.0.1 are allowed (so you should choose the latter).
16:24:52 <dolio> Okay.
16:25:34 <strager> For Int, > 0 is true =D
16:25:55 <dmwit> ?pl \c t f -> head (replicate (fromEnum c) t ++ [f])
16:25:56 <lambdabot> ((head .) .) . flip flip return . (((.) . (++)) .) . replicate . fromEnum
16:26:01 <dmwit> yes... quite readable...
16:26:22 <strager> I think the `guard` solution is most readable, even after @pl
16:26:38 <dmwit> It would be even more readable if you changed the argument order a tad.
16:26:47 <dmwit> ?pl \f t c -> maybe f (const t) (guard c)
16:26:48 <tgeeky_> dmwit: done and done. much better.
16:26:48 <lambdabot> flip flip guard . ((.) .) . (. const) . maybe
16:26:55 <strager> nahhh =]
16:27:17 <dmwit> =)
16:27:33 <strager> flip flip
16:27:37 * strager cries
16:28:32 <strager> I was considering doing something with `error` and `unsafePerformIO` but my brain exploded thinking about it.
16:29:09 <dmwit> :t \c t f -> maybe f (const t) (unsafeCoerce c)
16:29:10 <lambdabot> Not in scope: `unsafeCoerce'
16:30:00 <dmwit> It has the right type, and it works, too.
16:30:40 <dmwit> ?pl \c t f -> (either `on` const) t f (unsafeCoerce c)
16:30:41 <lambdabot> flip (flip . (either `on` const)) . unsafeCoerce
16:30:45 <dmwit> not bad!
16:31:20 <dmwit> I think that's my new favorite, actually.
16:31:44 <Targen> I'm rather horrified :)
16:33:24 <dmwit> (`on` const) . (\c t f -> either t f c) . unsafeCoerce
16:33:34 <dmwit> Nto quite point-free, but damn near readable.
16:34:34 <dmwit> whoops, that middle thing has to be either f t c
16:38:18 <strager> I don't even.
16:40:13 <nejucomo> I have: data T x y = T (x y) y
16:40:47 <nejucomo> I want to do something like: instance (C x, C y) => C (x y) where ...
16:41:11 <nejucomo> -or: instance (C (x y), C y) => C (x y) where ...
16:42:00 <nejucomo> Can I define an instance T as long as (x y) and y are instances?
16:42:18 <dmwit> I'm pretty sure instance heads have to start with concrete type constructors. (not variables)
16:43:02 <dmwit> What instances you can define depends heavily on what type class you're talking about.
16:43:19 <dmwit> So you'll need to be a tad more concrete on that part of the question.
16:43:31 <dmwit> But the answer is probably "yes, you can do that, but you have the syntax wrong".
16:43:50 <nejucomo> It's my own class which is: class ToC t where toC :: t -> C  — basically.
16:43:57 <dmwit> Try something like instance (C (x y), C y) => C (T x y) where ...
16:44:10 <romildo> @pl  \x -> In . Ann x
16:44:10 <dmwit> You'll likely need to turn on UndecidableInstances.
16:44:11 <lambdabot> (In .) . Ann
16:44:22 <nejucomo> Hrm.
16:44:32 <nejucomo> Maybe I can make my T less general.
16:45:17 <dmwit> (For example, consider data T' y = T' (T T' y), and how the class search would happen for C (T T' y).)
16:45:51 <dmwit> (It would have to show that C (T' y), which would mean it would have to show C (T T' y) and you're back where you started.)
16:47:06 <dmwit> tgeeky_: So, have you played with topLevel at all yet?
16:48:06 <strager> So we're interviewing a candidate tomorrow.  I was going to ask about traversing a binary tree.  I couldn't figure out the time complexity of the two-line algorithm I wrote (in Haskell).  Should I feel bad?
16:48:23 <strager> (I trialed the question on myself, if that wasn't clear.)
16:49:34 <dmwit> Time complexity is tricky if you're not clear about what demands the context is making of your returned value.
16:49:51 <aavogt> often people pretend haskell is strict
16:50:47 <strager> Yes, but even then.
16:52:23 <hpaste> strager pasted “Binary tree traversal” at http://hpaste.org/68161
16:52:32 <strager> ^ There's the algo; really simple
16:53:08 <Axman6> well, depending what you do with the result, then that's anywhere from O(0) to O(n)
16:53:13 <strager> (Yes, [x] ++ ys can be written as (x:ys))
16:53:22 <strager> Axman6: Well of course =]  Pretend I'm showing it
16:53:26 <dmwit> (yes, GHC will rewrite that for you, so writing it that way is better)
16:53:40 <strager> writing it which way is better?
16:53:46 <dmwit> The way you did.
16:53:51 <strager> cool, didn't know
16:53:56 <dmwit> The way that expresses what you mean, rather than what you think is a fast way to compute what you mean.
16:53:57 <strager> I haven't done optimizations in Haskell.
16:54:16 <strager> (except using shows, but I should probably use something else for building large strings ;P)
16:54:47 <strager> See, my initial impression is that it's O(N), but I know ++ is O(N).
16:54:58 <strager> Would that affect things, and if so, how so and why?
16:56:09 <aavogt> maybe a shorter way to write the same function is to add a    deriving (Foldable)
16:56:27 <aavogt> and change the Tree constructor to be (Tree (Tree a) a (Tree a))
16:56:40 <aavogt> @hoogle toList
16:56:41 <lambdabot> Data.HashTable toList :: HashTable key val -> IO [(key, val)]
16:56:41 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
16:56:41 <lambdabot> Data.Text.Array toList :: Array -> Int -> Int -> [Word16]
16:56:53 <strager> But that's cheating.  This is an interview question.  ;P
16:57:37 <aavogt> if you got that answer, then your person knows ghc pretty well
16:58:03 <aavogt> which is probably at least as valuable as being able to write the function you gave
16:58:22 <strager> hehe
16:58:49 <dmwit> Probably not more valuable than having an inkling that that's the kind of thing that can be done for you, but not knowing how, though.
16:58:59 <strager> I mean, even in a strict language I'd like to uncover/"prove" the complexity of the algorithm.
16:59:19 <strager> dmwit: Hmm?  I don't understand that sentence.
16:59:23 <dmwit> written with less negatives: It's probably very nearly as valuable just to know that things like this can be done for you as it is to know how to get them to be done for you.
16:59:55 <strager> It looks like you said the same thing twice in that sentence.
16:59:56 <dmwit> strager: The complexity is O(n).
17:00:15 <dmwit> Knowing that a thing can be done and knowing how to do it are very different.
17:00:21 <strager> dmwit: Yes, but why?  Why doesn't ++ screw things up?  Isn't list concatenation typically O(N+M)?
17:00:23 <byorgey> the worst case is O(n^2), isn't it?
17:00:31 <dmwit> O(n) + O(n) is O(n)
17:00:33 <byorgey> if the tree is a degenerate left-leaning list
17:00:42 <dmwit> Oh, yes, I guess I was assuming some balance.
17:00:44 <dmwit> That's true.
17:01:12 <strager> Yeah, N /= M (in general)
17:01:15 <byorgey> proving it is O(n) if the tree is balanced seems nontrivial to me
17:01:21 <byorgey> though I believe it is true.
17:03:02 <strager> Okay, I think I'm going to conclude that I should never pose a question on time complexity with Haskell and expect an answer.  =]
17:03:14 <dmwit> Well, you get a recurrence like T(n) = T(n/2) + O(n/2) + T(n/2) -- for balanced trees
17:03:50 <dmwit> Apply the Master Theorem to conclude that T(n) is O(n). Done, right?
17:04:16 * strager never took computer science or researched algorithms.  /o\
17:04:52 <dmwit> oh
17:05:02 <dmwit> I suppose the Master Theorem doesn't say O(n) for that recurrence.
17:08:35 <dmwit> (...it says O(n log n), I think.)
17:10:44 <arun__> who should learn Haskell?
17:10:55 <Clint> i should
17:11:32 <arun__> probably I should be asking why should some one learn Haskell
17:12:25 <theorbtwo> arun__: It's like executable math -- which is good if you know math and want to program.
17:12:43 <theorbtwo> It's also good if you can program, but want something that forces you to look at programming from a different direction.
17:13:02 <dmwit> ?google why does functional programming matter
17:13:05 <lambdabot> http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf
17:13:05 <lambdabot> Title: Why Functional Programming Matters
17:13:14 <theorbtwo> ...especially if you haven't had much other exposure to functions that take functions and return other functions.
17:13:21 <arun__> How is it different from functional programming with C
17:13:24 <relation> is it somehow possible to remove element from Data.Sequence?
17:13:49 <dmwit> ?google composing functional contracts simon peyton-jones
17:13:51 <lambdabot> http://research.microsoft.com/~simonpj/papers/financial-contracts/contracts-icfp.htm
17:13:51 <lambdabot> Title: Simon Peyton Jones: papers
17:13:51 <Axman6> arun__: why should one learn C? Java? Python? Ruby?
17:13:57 <theorbtwo> C strikes me as just about the hardest possible langauge to do functional programming in.
17:14:19 <Axman6> arun__: C is an absolutely terrible language to do functional programming in
17:14:30 <Axman6> functions aren't even first class
17:14:57 <c_wraith> they're closer to first-class than they are in java...
17:15:00 <arun__> I dont understand why C is terrible ?
17:15:13 <theorbtwo> arun__: How do you create a new function in C?
17:15:18 <Axman6> it isn't terrible, it's a terrible functional language. there is a difference
17:15:21 <dmwit> relation: Use break(l/r), filter, splitAt.
17:15:29 <arun__> return type funname()
17:15:29 <arun__> {
17:15:33 <arun__> body
17:15:33 <arun__> {
17:15:35 <arun__> }
17:15:43 <Axman6> you can't do that at runtime though
17:15:49 <theorbtwo> arun__: No, at runtime.  My C isn't *that* bad.
17:15:57 <dmwit> arun__: If you don't know what functional programming is, don't ask why functional programming in C is hard.
17:16:01 <Axman6> arun__: just because C has functions doesn't mean it's a functional language
17:16:09 <dmwit> First, learn what functional programming is.
17:16:35 <HugoDaniel> C is great!
17:16:35 <arun__> thats what I was asking , I am not even comparing or praising any language
17:16:39 <dmwit> ("Functional programming" is a technical term that means more than just what the two words mean separately.)
17:16:58 <arun__> I am just interested in learning this language , but want to know already experienced people
17:17:12 <Axman6> dmwit: is that a quote of yours, or someone else's?
17:17:22 <dmwit> Mine, I suppose.
17:17:30 <theorbtwo> You asked "How is it different from functional programming with C".
17:17:30 <Axman6> @remember dmwit "Functional programming" is a technical term that means more than just what the two words mean separately.
17:17:30 <lambdabot> Good to know.
17:17:31 <relation> dmwit: i need something based on index position, like ifilter, but i will code it slightly inefficient
17:17:40 <theorbtwo> ...so we were trying to answer.
17:17:46 <dmwit> relation: splitAt is based on index position.
17:18:32 <relation> dmwit: yeah, this will do the job. thanks
17:18:53 <Axman6> arun__: what languages do you already know?
17:19:35 <arun__> I am not expert , but I use C, C++, Java
17:20:13 <dmwit> arun__: I strongly recommend reading the two papers I linked. They're written by functional programming experts, aimed at non-functional-programmers, to showcase the benefits of functional programming.
17:20:22 <Axman6> then you've never seen the wonders of higher order functions then? (functions which can accept and/or return other functions)
17:20:32 <dmwit> The writing has been revised multiple times; it will probably be higher quality than any off-the-cuff comments you get in this channel.
17:21:09 <JoeyA> You can express pure and higher-order functions in C (you can even have them type-checked with hacky use of GCC extensions, see http://ccodearchive.net/info/typesafe_cb.html ).  However, this isn't idiomatic.  The Haskell language represents these ideas very concisely.
17:21:50 <dmwit> Showing how to do functional programming in C isn't helpful if you don't think functional programming is helpful to begin with. Such a person will look at the horrible code required to make it work and be turned off.
17:22:15 <JoeyA> Err, "this isn't idiomatic" isn't quite true (there are definitely use cases of HOF in C), but it isn't nearly as pervasive as in Haskell.
17:22:58 <arun__> I guess those papers are a good start
17:25:42 <JoeyA> Is a "circuit diagram" a good way of thinking about arrows?
17:25:52 <JoeyA> (i.e. Control.Arrow)
17:26:43 <dmwit> I think so.
17:27:10 <Veinor> what's a good, lightweight library for parsing html into some kind of tree-like structure (and then later outputting it again)? hxt is pretty heavy
17:27:50 <JoeyA> Text.Regex (kidding)
17:27:55 <Veinor> i know in advance that the html is going to be fairly well-structured
17:28:03 <dmwit> tagsoup
17:30:12 <Veinor> i could do that, i guess? seems kind of silly
17:33:18 <aavogt> tagsoup doesn't give you something tree-like though
17:33:41 <aavogt> (unless it has changed in the past year or two)
17:34:36 <aavogt> Veinor: this might work with html http://hackage.haskell.org/package/hxt
17:34:57 <aavogt> but I've never tried it
17:35:10 <dmwit> Did you miss the part where he said hxt was too heavy? =P
17:35:37 <aavogt> yes
17:36:07 <Veinor> i do know hxt works, though
17:45:07 <rasfar> tagsoup does give you a tree actually, but it comes with a caveat, and it's a whole lot less convenient to work with than hxt
17:45:40 <rasfar> http://hackage.haskell.org/packages/archive/tagsoup/0.12/doc/html/Text-HTML-TagSoup-Tree.html
17:45:57 <rasfar> (not an endorsement!)
18:01:32 <nejucomo> Sometimes I have a type annotation in a where clause when defining an instance, and I want to constrain this inner signature to some of the class variables.  Is this possible with lexical types?
18:01:46 <nejucomo> (Is my description clear?)
18:03:20 <nejucomo> As in: class C t where f …  ;  instance C t => C (Foo t) where f … where g :: Blah -> t
18:04:03 <nejucomo> I just ran into a case where when I removed the inner type annotation, a type failure disappeared.
18:04:53 <Liskni_si> if you enable ScopedTypeVariables and give a type signature for f, I'd think it's got to work
18:05:10 <Liskni_si> no idea whether the t from the instance statement itself propagates anywhere
18:05:36 * nejucomo tries.
18:06:27 <nejucomo> Yes, ScopedTypeVariables to the rescue!  I wonder whether there are drawbacks to this extension, and if not, why it is not standard?
18:08:13 <Liskni_si> No idea.  Bureaucracy, perhaps.  :-)
18:08:36 <liyang> It's not standard Haskell 98 because it wasn't in the standard.
18:09:06 <liyang> It could break existing code, that's the only drawback.
18:09:58 <ClaudiusMaximus> nejucomo: you can also do things with type-restricted versions of functions (eg asTypeOf :: a -> a -> a ; asTypeOf = const), if you must avoid the extension - not sure if it's always possible, and when it is possible it's often inconvenient
18:10:31 <aavogt> liyang: forall is allowed in haskell98?
18:11:07 <aavogt> probably the reason it wasn't added to H2010 is because of some differences in implementation outlined here http://hackage.haskell.org/trac/haskell-prime/wiki/ScopedTypeVariables
18:11:15 <nejucomo> Good to know.  Fortunately for my hobby with 0 users, I have no need for legacy support.  ;-)
18:16:13 <otters> Is there a standard library function that applies a function to a value n times?
18:17:00 <rwbarton> iterate f x !! n
18:17:10 * hackagebot logict 0.5.0.1 - A backtracking logic-programming monad.  http://hackage.haskell.org/package/logict-0.5.0.1 (DanDoel)
18:37:10 * hackagebot Modulo 0.1.0.0 - Modular arithmetic via Numeric-Prelude  http://hackage.haskell.org/package/Modulo-0.1.0.0 (NikolayMurzin)
18:39:45 <nyingen> @quote
18:39:46 <lambdabot> jensechu says: lambdabot: I sewed a lambda for sshirokov.
18:39:52 <nyingen> @quote
18:39:52 <lambdabot> cowardlydragon says: [from a reddit comment thread] Don't get me started on monad. What is that, a man with a single testicle?
18:42:12 <t7> hahah
18:46:36 <aufwind> Is there something like enumeration in Python? [a for i, a in enumerate(my list) if somecodition()]
18:46:48 <aufwind> For haskell I mean?
18:47:03 <blackdog> aufwind: yep. list comprehensions exist.
18:47:15 <Axman6> map? filter? many other things...
18:47:19 <otters> they're ugly as hell, but they exist
18:47:36 <blackdog> [ i | i <- my_list, somecondition i]
18:47:58 <blackdog> otters: de gustibus non disputandum est
18:48:07 <otters> what
18:48:21 <strager> aufwind: Are you looking for 'i' specifically?
18:48:24 <blackdog> Axman6: hello, btw. what are you up to these days?
18:48:25 <aufwind> blackdog: Thanks I should have stated my question more clearly. I know about list comprehensions in Haskell. (Just learned them :-)) What I need is sort of an indexing of the elements in my_list.
18:48:32 <aufwind> strager: yes, I do! :-)
18:48:38 <strager> filter cond $ zip [0..] myList
18:48:46 <strager> where cond :: (Int, a) -> Bool
18:48:51 <Axman6> i quite like haskell list comprehensions, they make more sense to me than python ones. i don't use them very often however, because i find the higher order functions more useful
18:49:11 <blackdog> Axman6: ya. especially when you start going point-fre
18:49:21 <Axman6> blackdog: finishing my last semester of uni
18:49:25 <aufwind> Axman6: We are not allowed to use the built in functions in exercises. :-)
18:49:46 <strager> aufwind: comprehensions use builtins though ...
18:49:47 <Axman6> aufwind: that probably means you're supposed to write them from scratch
18:49:48 <sepp2k1> Axman6: What's the difference between Haskell and Python list comprehensions? Other than punctuation vs. keywords.
18:50:05 <otters> isn't a list comprehension syntactic sugar for do-notation which is syntactic sugar for >>=?
18:50:20 <aufwind> Axman6: In most of the cases, this is true. :-)
18:50:24 <tgeeky_> otters: it's a little more complicated than that, but yes.
18:50:30 <Axman6> sepp2k1: i don't know python list comprehensions very well, but i've just always had trouble reading all but the most basic ones
18:50:32 <tgeeky_> otters: the actual sugar itself is listed in the GHC manual
18:50:36 <otters> I see
18:51:12 <tgeeky_> otters: http://www.haskell.org/ghc/docs/7.2.2/html/users_guide/syntax-extns.html <-- search for "more formally"
18:51:36 <otters> Oh, neat
18:51:52 <otters> transform comprehensions?
18:52:18 <tgeeky_> otters: a list comprehension is a (un-?)special case of a monad comprehensions
19:11:24 <kallisti> is there any Windows equivalent for System.Posix.Files
19:24:38 <vodik> kallisti: System.Win32.Files?
19:25:11 <kallisti> aha
19:30:38 <kallisti> vodik: wow this library is a complete mess
19:31:24 <kallisti> vodik: I'm looking for a cross-platform library for filesystem stuff. System.Directory isn't complete.
19:31:30 <vodik> cab't say i've ever used it
19:31:32 <vodik> *can't
19:32:08 <vodik> ah, idk, i tend to use linux fulltime
19:32:15 <kallisti> me too..
19:33:31 <nand`> what do you mean? System.Posix.Files works on all POSIX-compliant systems; if that isn't cross-platform I don't know what is
19:33:43 <nand`> (note: it can work on windows too)
19:34:19 <vodik> you need cygwin then?
19:34:49 <nand`> windows has a built-in POSIX compatibility layer that can be enabled in the optional windows features or something similar
19:34:57 <nand`> and there's always SUA (which makes it fully POSIX compliant)
19:35:00 <nand`> but that's no longer supported
19:35:15 <vodik> i thought only certain windows versons do
19:36:49 <kallisti> so...
19:36:55 <kallisti> what is a shortcut in Windows?
19:37:03 <kallisti> I'm searching through this a
19:37:05 <kallisti> *API
19:37:13 <kallisti> for something about "symbolic links" or "shortcuts" etc
19:37:30 <nand`> they're also called “shell links” afaik
19:37:37 <nand`> but not symbolic links
19:41:29 <aristid> iirc windows has both link-files (application level) and symbolic links, but the latter are not understood by many applications
19:42:01 <nand`> I believe NTFS also has hard links
19:42:16 <strager> Yes, NTFS has hard links and kinda hard links which act like symlinks.
19:42:33 <strager> Just don't accidentally create a cycle with hard links ...
19:42:52 <strager> Programs just don't understand.  =[
19:45:59 <colah_> I've been messing around with template haskell/quasiquoters and am getting error messages I don't really understand: Couldn't match expected type `Int' with actual type `GHC.Prim.Int#' In the expression: 2# ...
19:46:42 <colah_> If someone could explain what the Int# type is and speculate on problems, that would be really appreciated.
19:47:01 <blackdog> it's an unboxed integer
19:47:19 <blackdog> you usually don't mess with it unless you're doing serious optimisation or FFI Stuff
19:47:30 <colah_> Yeah, not doing either.
19:47:35 <blackdog> colah_: you'd probably need to post code.
19:48:13 <colah_> OK. It's just hard to get it to a point where there isn't a huge amount of context around it people need to wade through...
19:50:26 <colah_> Eh, this is prety random, but I'm pretty sure that it's where my problem is: http://pastebin.com/qJN5BKpR
19:50:28 <mauke> The paste qJN5BKpR has been copied to http://hpaste.org/68166
19:51:02 <colah_> I'm playing around with making a symolic algebra library that will allow things like:
19:51:11 <colah_> expand [m| a+b     |] = expand a + expand b
19:51:11 <colah_> expand [m| a*(b+c) |] = expand (a*b) + expand (a*c)
19:51:35 <colah_> And just pattern match math sufficiently well for things to be nice.
19:52:49 <colah_> So one can really easily implement transformations on algebraic expressions.
19:53:37 <colah_> (Also interested in what people think of this as an idea...)
19:55:08 <strager> At compile time?
19:55:14 <strager> Why would you need/want it at compile time?
19:55:35 <strager> GHC has REWRITE pragmas which can do that sort of thing if you are looking to optimize evaluation.
19:56:19 <enthropy> the syntax is that for -XQuasiQuotes
19:56:20 <colah_> The qausiquoter gets expanded into an appropriate pattern to match and extract variables from appropriate expressions at compile time via view patterns :)
19:57:02 <enthropy> symbolic math isn't just about expanding expressions though
19:57:06 <strager> Yes, I understand.  But why would you need or want that?  What's your use case?  I'm just curious.
19:57:23 <strager> I haven't done TH and I have no idea on your problem and I'm too scared to dive in =D
19:57:28 <colah_> enthropy: Yep. I'm just getting strange type errors when expanding the quasiquoter.
19:58:12 <colah_> strager: It's entirely a matter of ellegant syntax. Sapir-Wharf and all that.
19:58:53 <strager> Oh I didn't see the pattern matching part
19:58:54 <strager> My bad
19:59:03 <strager> I thought = mean "transforms into"
19:59:27 <strager> So when I said "Yes, I understand", I didn't really understand =]
19:59:35 <colah_> enthropy: Of course. This is just me starting to play around with it. I'm also experimenting with methods of making things highly extensible for new types of expressions with the tagless DSL stuff.
20:00:04 <colah_> strager: yeah, wouldn't be to interesting if it wasn't for patter matching :)
20:31:25 <xplat> colah_: i think what you want to make already exists but doesn't embed in haskell and is called 'maude'
20:39:38 <wagle> is lambdabot's haskell prelude still different (more generalized types) than standard haskell?  where do I find the definitions?  not finding this on the lambdabot webpage (http://www.haskell.org/haskellwiki/Lambdabot)
20:43:21 <gienah> wagle: I don't think so, I think lambdabot uses the standard haskell prelude, what it uses is defined in ~/.lambdabot/State/L.hs
20:44:02 <gienah> wagle: lambabot prints out simplified source code, the source it prints is in ~/.lambdabot/State/source
20:46:32 <wagle> i may be just thinking about things like:
20:46:34 <wagle> (.) :: (Functor f) => (a -> b) -> f a -> f b
20:46:34 <wagle> (.) = fmap
20:47:00 <wagle> i thought there was a whole new prelude
20:48:21 <gienah> wagle: no that's just simplified source code from ~/.lambdabot/State/source
20:50:31 <wagle> gienah: thanks!
20:57:15 * hackagebot postgresql-simple 0.1.1 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.1.1 (LeonSmith)
20:57:18 <slack1256> how does cloud-haskell (remote package) stands vs erlang?
20:57:31 <slack1256> performance-wise also complexity-wise?
21:00:24 <Veinor> what's the lightest html parsing module?
21:00:46 <gienah> slack1256: there is work on the performance (its in development, not ready yet): https://github.com/haskell-distributed
21:00:46 <slack1256> Veirnor: tagSoup
21:01:13 <slack1256> gienah: cool thanks :D
21:02:16 <gienah> slack1256: so I guess you can just use hackage one, remote, for the moment, the performance will be improved later
21:05:19 <slack1256> gienah: cool thanks. I am doing a website portal for my college where students can submit for new classes at the beggining of the semester
21:05:41 <slack1256> so during 2 weeks we are a top with usage. so this will help to replace the old system
21:06:04 <slack1256> *website portal backend
21:17:28 <nyingen> @quote
21:17:29 <lambdabot> Porges says: State is stored in spacesuits. [via: reddit]
21:17:46 <nyingen> no it isn't
21:17:48 <nyingen> @quote
21:17:48 <lambdabot> urxvt-transparency says: http://lists.schmorp.de/pipermail/rxvt-unicode/2008q1/000552.html
21:18:56 <nyingen> I don't get it.
21:42:18 <scooty-puff> is there anything like MonadMap t where mapT :: (m a -> n a) -> t m a -> t n a
21:42:29 <scooty-puff> but maybe that stacked better
21:43:50 <c_wraith> you might be able to do that with monad-control or the equivalent
21:43:55 <c_wraith> maybe
21:44:02 <scooty-puff> k
22:16:20 <m3ga> @remember Axman6 "GHC Warning: Did you see that in an OOP textbook? You probably don't want to be doing that"
22:16:20 <lambdabot> Done.
22:17:17 <nyingen> @quote
22:17:17 <lambdabot> dylukes says: Yea, though I walk through the valley of the shadow of APL, I shall fear no evil, for I can string 6 primitive monadic and dyadic operators together.
22:17:44 <ivanm> heh
22:20:23 <colah_> splat: Thanks. maude looks interesting. The whole fun is seeing if I can make this work in Haskell, though. I'm not actually trying to do anything practical at the moment. :P
22:21:29 <Veinor> is there any way to have a plugin architecture that doesn't require ghc on the target system?
22:21:31 <colah_> xplat: ^^, got your nick wrong, silly me
22:22:11 <colah_> Oh, also, wide spread aplication of fromIntegral solved all my problems.
22:23:28 <ivanm> Veinor: use run-time based parsing, manipulation, etc.?
22:23:48 <ivanm> embed lua or some other language (I believe there's either a lua implementation or bindings to one on Hackage)
22:24:11 <Veinor> ivanm: yeah but the thing is, i need plugins to be able to define functions and suchlike
22:24:55 <mzero> Veinor: yes - you can use the GHC api directly to load code (same as ghci does), which causes ghc to be linked into your app
22:25:03 <mzero> then your users don't need ghc and stuff loaded
22:25:04 <Veinor> what's the memory overhead on that like?
22:25:28 <mzero> however, you still have to handle if they write code that accesses packages
22:25:36 <mzero> not as bad as you might think...
22:25:41 <Veinor> yeah, that's the problem :/ how do i deal with packages?
22:26:14 <mzero> not sure what you are trying to do
22:26:19 <Veinor> well
22:27:23 <Veinor> i'm writing a blog engine in haskell, and ideally i want users to be able to install plugins that, say, perform latexifying or show the latest commits to a repository
22:27:26 <Veinor> without having to recompile the engine
22:27:44 <mzero> Ah
22:28:12 <mzero> well, in that case, your users are going to want to probably depend on whole slews of packages you haven't anticipated
22:28:29 <Veinor> yeah :/
22:28:31 <mzero> which means, essentially, they'll need GHC installed in order to be able to install the packages they need
22:28:46 <Veinor> that's what i was afraid of
22:28:47 <mzero> hence, don't worry just use hsplugins
22:28:59 <mzero> well, with the platform, it sholdn't be too hard for them to install it
22:29:22 <Veinor> true
22:29:24 <mzero> think of it like saying: "bluxom is a blog engine written in python .... first install python...."
22:29:42 <Veinor> the difference is that you can install python on your production server with little issue
22:29:57 <Veinor> but i wouldn't want to compile my engine on a machine without at least a gig of ram
22:30:08 <Veinor> (also, python tends to come by default, byt haskell doesn't)
22:30:21 <mzero> yes... this is why PHP won
22:30:24 <mzero> :-(
22:30:27 <Veinor> yeah :(
22:30:30 <mzero> it was already there!
22:30:46 <Veinor> to be honest i think dynamic languages are better suited to blog engines for this reason
22:31:47 <Veinor> the silly idea i had was
22:32:01 <mzero> I don't understand -- if you want to invoke your Haskell based blog engine, parsing and running the "script" on each HTTP request --- go ahead and stick  #!runhaskell   at the top of your code!
22:32:14 <Veinor> i mean
22:32:17 <mzero> no need to compile it at all
22:32:51 <Veinor> ... hm, yeah
22:33:02 <mzero> eventually, linux distros will come with HP as a standard option, and we'll all be happy
22:33:38 <Veinor> imo all that needs to happen is that we need to solve cabal's dependency hell issue
22:33:48 <mzero> I'm pretty sure, BTW, that GHC has a special exception for the first line of a source file and if it starts #! it can deal!
22:34:01 <Veinor> that's horrifying
22:34:29 <Veinor> oh god you're right, it does
22:34:37 <mzero> :-)
22:34:52 <mzero> see, Haskell *IS* a scripting language
22:34:57 <Veinor> actually it's not the first line
22:35:05 <Veinor> it looks like ghc ignores any line starting with #!
22:35:52 <Dtgr> #! tells linux which program should be used for running this particular piece of code
22:37:33 <Dtgr> i would use the absolute path to runhaskell though
22:37:52 <strager> A common pattern is #!/usr/bin/env runhaskell
22:38:00 <mzero> nah, the right thing is
22:38:05 <mzero> is what strager said
22:38:09 <mzero> :-)
22:38:32 <Veinor> what's the difference between #!/usr/bin/env foo and #!foo?
22:38:51 <strager> man env
22:39:01 <mzero> linux doesn't do PATH search
22:39:05 <mzero> env does
22:39:12 <Veinor> ah
22:39:36 <strager> I figured it had something to do with that.  I don't think I've ever seen #! not followed by / (in a script of course)
22:40:15 <Veinor> anyway, my comedy option for the plugins problem is this
22:40:34 <Veinor> there's a repository of 'official' plugins. you go to a site, pick your list of plugins you want, and it compiles a binary for you!
22:41:21 <Enigmagic> along with a keylogger!
22:41:26 <Enigmagic> my favorite kind of binaries
22:41:54 <Veinor> yeah, as a bonus it also runs an sshd on a high port
22:42:06 <Veinor> so i can help maintain your site!
22:42:23 <Enigmagic> awesome!
22:43:05 <Veinor> i mean, who do you trust more: a compiler written by some faceless committe, or your good old friend veinor
22:43:57 <shachaf> Veinor: Since you're running sshd and a keylogger on my machine, I'd *better* trust you.
22:44:05 <shachaf> Otherwise I'm in an uncomfortable situation.
22:45:01 <mzero> Actually, Veinor, since you're running sshd and a keylogger on my server, can you just maintain it for me? kthxbai
22:47:49 <xplat> mzero: they say half of life is just showing up ... for PHP it's all of life
22:51:18 <elaforge> is there a thing where ghc accepts pattern guards without actually needing to turn on PatternGuards?
22:51:38 <elaforge> I just noticed it seems to accept them without any flags
22:51:52 <shachaf> Hey, it's elaforge.
22:51:59 <shachaf> Any flags at all?
22:52:10 <shachaf> Some extensions can be turned on by other extensions sometimes.
22:52:18 <elaforge> hey there
22:52:32 <elaforge> yeah, but I have files with no extensions (unless I'm missing something somewhere)
22:52:45 <elaforge> I notice because ghc is happy but haskell-src-exts wants the pragma
22:53:41 <shachaf> Odd. Do you have a simple test case or is this part of a large project?
22:54:03 <elaforge> just make a file with, like 'f arg | Just x <- arg = 1'
22:54:14 <elaforge> ghci loads it with no fuss
22:54:58 <elaforge> I suspect ghc doesn't run in standards mode by default
22:54:59 <shachaf> Oh, hmm.
22:55:07 <shachaf> Are pattern guards in Haskell 2010?
22:55:15 <elaforge> oh good question
22:55:23 <shachaf> Compiling with -XHaskell98 gives a warning.
22:55:43 <elaforge> aha
22:55:48 <elaforge> I'm a dummy, there it is
22:55:56 <elaforge> FFI, hierarchical modules, and pattern guards
22:56:12 <shachaf> Yep, that'd be the issue. :-)
22:56:18 <shachaf> I guess haskell-src-exts is still 98.
22:57:19 <elaforge> wait, I guess this means I can take out all the LANGUAGE FFI junk
22:58:54 <elaforge> ah, and haskell-src-exts has a haskell2010 mode, guess I just missed that
23:02:33 <elaforge> shachaf: btw, do I know you?
23:03:11 <shachaf> elaforge: Yes, we've met at bahaskell and such several times.
23:03:18 <shachaf> One time we met at the Caltrain station.
23:04:35 <elaforge> ah, I have enough trouble with face + name, without getting to face + name + irc name :)
23:04:57 <shachaf> Fortunately first name == IRC nick in this case. :-)
23:05:44 <elaforge> phooey that was going to be my excuse
23:06:27 <shachaf> elaforge: Oh, and I once drove you and zygoloid from Google to bahaskell, though that turned out to be kind of disastrous.
23:06:54 <elaforge> I'm assuming zygoloid isn't also his real first name?
23:07:01 <elaforge> I'm pretty sure I'd remember if that were the case
23:07:22 * hackagebot tagstream-conduit 0.3.1 - streamlined html tag parser  http://hackage.haskell.org/package/tagstream-conduit-0.3.1 (YiHuang)
23:08:04 <elaforge> and I think it wasn't that time we were rear-ended, so it can't have been *that* disastrous
23:08:47 <shachaf> Nope, just late.
23:09:04 <elaforge> oh that's totally normal :)
23:09:18 <shachaf> By more than half an hour.
23:09:28 <elaforge> yeah, still pretty normal :)
23:15:43 <elaforge> whohoo bug fixed, thanks for the help
