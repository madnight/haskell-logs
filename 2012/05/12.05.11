00:13:51 <efie> can anyone help me to achieve this:http://hpaste.org/68373 ?
00:14:06 <efie> I'm not sure what to do
00:16:07 <mmcdermo> efie: Do you have to use enumeration notation (..) ?
00:16:37 <mmcdermo> You could create a function ie)  myFn [1..4]
00:16:38 <rwbarton> efie, better to just say what you mean
00:16:55 <rwbarton> [((1,x),RIGHT) | x <- [1..4]]
00:17:12 <mmcdermo> rwbarton: nice
00:18:22 <efie> thanks! so I even do not need to make Dir an instance of Enum
00:26:25 <rudyl313> The following code: http://pastie.org/3893690 is producting this error: "`OptionSet' is applied to too many type arguments" ... can anybody explain what the issue is?
00:27:34 <mauke> rudyl313: OptionSet takes no arguments, apparently
00:27:43 <rwbarton> is that even allowed?
00:27:53 <rudyl313> mauke: but its a typeclass
00:28:06 <rudyl313> I am confuse
00:28:08 <rwbarton> line 6 is invalid
00:28:49 <rudyl313> rwbarton: I want to have the signature of the train function allow for any "options" type to be passed in
00:28:59 <mauke> rudyl313: and?
00:29:05 <rwbarton> then write a valid class declaration for OptionSet
00:29:06 <rudyl313> rwbarton: a classifier could any nature of parameters
00:29:32 <rudyl313> rwbarton: how can I better express that?
00:29:37 <rwbarton> ...
00:29:40 <mauke> s/better //
00:30:00 <rudyl313> mauke: I wasn't aware typeclasses took arguments
00:30:01 <rwbarton> I don't understand what you're asking and I'm also extremely confused how you are getting that error
00:30:07 <rwbarton> yes you are
00:30:14 <rwbarton> what is a class with no arguments
00:30:16 <rwbarton> nothing
00:30:33 <rudyl313> what are the arguements of the Eq typeclass?
00:30:40 <rwbarton> @src Eq
00:30:41 <lambdabot> class  Eq a  where
00:30:41 <lambdabot>     (==), (/=)   :: a -> a -> Bool
00:30:45 <mauke> ^ 'a'
00:30:46 <rwbarton> a is the argument
00:30:52 <rudyl313> I see
00:31:16 <rudyl313> so I can't just declare a typeclass with no requisite functions
00:31:28 <rwbarton> you can...
00:31:40 <rwbarton> I think you need to read some text about type classes.
00:31:47 <rudyl313> so should I just go "class OptionSet o"
00:32:04 <rwbarton> that will make your code compile at least
00:32:40 <rudyl313> rwbarton: apparently not
00:32:56 <rudyl313> Could not deduce (o ~ TreeOptions)     from the context (OptionSet o)       bound by the type signature for                  train :: OptionSet o => o -> DataFrame -> Tree
00:33:18 <rwbarton> that means somewhere else you have an invalid definition of train in an instance
00:33:22 <rudyl313> oh I guess thats in another source file
00:33:52 <rwbarton> as I was going to say, you will very quickly run into more problems since this "class OptionSet o" is useless
00:34:16 <rudyl313> argh
00:35:06 <rwbarton> (so does some new GHC version accept 0-argument type classes?)
00:35:51 <rudyl313> rwbarton: I suppose I am misusing them.. I just wanted to allow an type to be passed in as the first argument to "train"
00:36:25 <rwbarton> I recommend you not try to use type classes until you can solve your problems without them
00:36:51 <rwbarton> they are not the be all and end all of abstraction in haskell
00:37:47 <rudyl313> rwbarton: I see.. its just I'm building boosting algorithms that can take any weak classifier and "boost" them to become stronger... so I need some class called Classifier
00:38:27 <rudyl313> since the weak classifier could be any variety of classifier
00:38:28 <mauke> you never need classes
00:38:35 <rwbarton> right, you don't need a class
00:38:43 <rudyl313> humm
00:38:50 <rwbarton> if you think you need a type class, that is a good sign you should not use a type class
00:39:14 <rudyl313> I guess I don't know how to achieve the generic-ness then
00:39:20 <rwbarton> don't
00:39:55 <rwbarton> or you can use records parametrized on some type variables
00:40:29 <rudyl313> so why are typeclasses a feature of haskell if they are not to be used?
00:41:36 <rwbarton> I only said *you* shouldn't use them. :) You seem to be pretty new to Haskell.
00:41:59 <rudyl313> I'm not that new
00:42:02 <rudyl313> anyway
00:42:06 <rudyl313> thanks for the comment
00:42:09 <rudyl313> s
01:38:00 <jeltsch> Is there any effort to port Gtk2Hs to version 3 of GTK+?
01:52:05 * hackagebot generic-storable 0.1.0.0 - Generic implementation of Storable  http://hackage.haskell.org/package/generic-storable-0.1.0.0 (HideyukiTanaka)
01:55:35 <t7> does anyone know of a well known game written in a function language?
01:57:39 <womb> Hi guys!
01:58:17 <danr> t7 nikki and the robots?
01:59:42 <t7> bigger?
02:02:17 <davesq> I'm making a complete mess of trying to write a function to split a list into segments whenever a predicate holds. https://gist.github.com/2658510 Appreciate any hints on doing this properly.
02:03:13 <roconnor> davesq: you want to write this as an exercise?
02:04:07 <davesq> It was a question posed by a colleague who wanted to do something like this, but it's become an exercise for me.
02:04:26 <davesq> Is there a function to do this already?
02:04:57 <roconnor> davesq: yes, either in the prelude or the split package
02:05:16 <roconnor> davesq: suppose you have a list [a,b,c,d,e] and the predicate holds on b c and e, what is the output?
02:05:37 <roconnor> davesq: just to see if I understand the specification
02:05:59 <davesq> roconnor: [[a],[b],[c],[d],[e]]
02:06:22 <davesq> roconnor: I'm trying to use it like this: "hello|world|howdy||" `splitWhere` (=='|')
02:06:23 <davesq> ["hello","|","world","|","howdy","|","|"]
02:06:23 <roconnor> even b and c are not combined into one list?
02:06:31 <roconnor> ah
02:06:32 <roconnor> I see now
02:07:03 <Ralith> davesq: the term you probably wan tis 'tokenize'
02:07:48 <quicksilver> that's the basic splitting stragey of Data.List.Split I believe
02:08:04 <quicksilver> split (whenElt (=='|'))
02:08:14 <womb> parsec!
02:08:45 <quicksilver> I can't demo it because lambdabot doesn't have Data.List.Split
02:08:49 <roconnor> davesq: okay suppose you have a list "hello|world|howdy||" and magically you also have the answer for "ello|world|howdy||" which is ["ello","|","world","|","howdy","|","|"].  how would you add 'h' to this answer to get the answer to your full input?
02:08:51 <quicksilver> (AFAIK)
02:11:45 <womb>  split' (t:tokens) delimiter state result = case t ...
02:12:06 <womb> i always end up writing functions with 4-5 params and then adding wrapper function for them
02:12:35 <womb> i don't see where | let / in with this as more readable then just another function
02:13:06 <womb> and i learned i'm using tail recursive style by default
02:13:17 <womb> maybe i think more tail recursivly
02:13:41 <OODavo> Does the crazy typeclass magic and possible runtime resolution involved in the printf function mean that it should be avoided? Or is it in general safe to use?
02:13:54 <quicksilver> it's perfectly safe
02:14:25 <quicksilver> as to whether it's idiomatic haskell
02:14:30 <quicksilver> personally I don't really like that kind of overloading
02:14:34 <quicksilver> but it's a matter of taste.
02:15:04 <quicksilver> there are at least two common haskell printf libraries.
02:15:20 <quicksilver> (but only one in base)
02:15:34 <davesq> roconnor: Something like: let f x ((h:t):rest) = (x:h:t):rest  ??
02:16:28 <t7> is (->) a printf type?
02:17:04 <OODavo> Right. Thanks for the assurance. ^_^
02:17:17 <t7> how do multiple args work
02:17:34 <quicksilver> t7: multiple args work by (->) being a PrintfType, yes.
02:17:34 <roconnor> davesq: case recursiveCallGoesHere of  (rech:rect) -> (h:rech):rect  | [] -> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=h
02:17:37 <roconnor> gah
02:17:44 <roconnor> stupid Koversation
02:18:08 * roconnor disables autoreplace
02:18:11 <roconnor> davesq: case recursiveCallGoesHere of  (rech:rect) -> (h:rech):rect  | [] -> [[h]]
02:18:20 <t7> that is so crazy
02:19:20 <t7> how do i emulat that in ghci
02:19:37 <t7> > let f (a -> b) = a in f ((+) 123)
02:19:38 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
02:19:38 <lambdabot>         against inferred ...
02:19:58 <sipa> (a -> b) is not valid pattern sysntax
02:22:10 <Ralith> what would it mean, anyway?
02:22:17 <t7> (->) a b ?
02:22:25 <ibid> t7: what do you want to do?
02:22:33 <Ralith> what values do you expect a and b to have?
02:23:44 <t7> im getting confused with universes
02:24:05 <t7> changing the subject completely, can i typecheck a file without compiling?
02:26:44 <davesq> roconnor: thanks. i think i see what you're saying. i'll need to spend some time to see if I can apply it (you'll have to excuse me, I'm slower than you're average haskeller :))
02:27:08 <ibid> "your"
02:28:23 <davesq> ibid: i rest my case
02:29:36 <ibid> your/you're isn't a matter of slowness, it's just one more gotcha in the language
02:31:43 <davesq> ibid: i'm spending so much time trying to learn haskell i think i'm forgetting my first language.
02:31:57 <mekeor> lol
02:32:34 <ibid> (which i am not prone to, given that i learned most of my english from written material, where homophony isn't an issue)
02:33:03 <ibid> davesq: you know, english and C++ are a lot alike :)
02:33:14 <Saizan> (in fact, the better my pronounciation the worse my spelling gets)
02:34:12 <HugoDaniel> are there any xmpp haskell servers ?
02:38:40 <saep> >  let f xs = case break (=='|') xs of { (l,[]) -> [l] ; (l,r:rs) -> l:[r]:f rs } in f "Hello|World|howdy||"
02:38:41 <lambdabot>   ["Hello","|","World","|","howdy","|","","|",""]
02:40:48 <ikt_> I have a problem with FGL: http://hackage.haskell.org/packages/archive/fgl/5.4.2.4/doc/html/Data-Graph-Inductive-Graph.html#g:8 can anybody give me simple example of how to create a graph with one Node in it? I tried "insNode ((1,"a") :: LNode String) empty" but it does not work: "Ambiguous type variable `gr0' in the constraints: .."
02:42:06 * hackagebot authenticate 1.2.1.1 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-1.2.1.1 (MichaelSnoyman)
03:12:03 <davesq> roconnor: Is this what you meant? https://gist.github.com/2658510#L10 I'm currently a bit stuck trying to isolate the delimiters.
03:29:27 <hpaste> saep pasted “A possible solution to davesq's plit problem” at http://hpaste.org/68377
03:35:17 <roconnor> davesq: indeed that is what I meant ... apparently mysolution was wrong :/
03:35:38 <roconnor> davesq: I hadn't realized this was so tricky
03:38:07 <davesq> saep: That's a really nice impl, thanks.
03:38:26 <roconnor> saep: nice
03:39:53 <chris2> whats the recommended way to fold over an STArray?
03:40:29 <bitonic> chris2: did you ask this question yesterday? somebody did, and I think that the answer was "there is no "good" way"
03:40:36 <bitonic> you have to write it yourself
03:40:37 <chris2> i did
03:40:38 <chris2> ok
03:41:04 <chris2> but someone must have done it already :P
03:42:04 <bitonic> chris2: it's probably a few lines, using getBounds + range
03:42:16 <chris2> foldM and readArray...
03:42:22 <chris2> i'll try it myself
03:42:51 <bitonic> yeah, worst case you'll learn something :)
03:43:08 <davesq> Suggestions for good exercises to practice recursion? The 99 Haskell probs (http://www.haskell.org/haskellwiki/99_questions/1_to_10) is as good a place to start as any?
03:45:19 <merijn> davesq: Depending on how complicated you want I'm a big fan of reading the Prelude documentation and implementing it yourself
03:45:41 <merijn> (not just for recursion)
03:46:06 <merijn> Docs and functions are here (http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html) and you could even use QuickCheck to verify your function behaves the same as the prelude ones
03:47:19 <davesq> merijn: Cheers, I'll give that a go. I think I've been over-focussing on learning folds and neglected more standard recursion. :-\
03:47:56 <merijn> davesq: The miscellaneous functions and list operations sections are probably good places to start
03:48:22 <merijn> And the list operations are probably the simplest/clearest practice for recursion
04:11:37 <ildac> hi
04:13:43 <b52_> Hey
04:13:58 <b52_> Any idea how to test for consecutive custom type constructors? http://hpaste.org/68378
04:14:23 <merijn> b52_: derive Enum and check if the list is sorted?
04:14:29 <b52_> the type derives from Ord and Eq
04:14:32 <b52_> hmm Enum ?
04:14:44 <b52_> well [A, C] would be sourted, wouldnt it?
04:14:46 <merijn> Enum is the typeclasses for enumerable values
04:14:58 <merijn> Ah, consecutive only with no repeats?
04:15:15 <b52_> yes, with no repeat and no gaps
04:15:50 <merijn> derive enum and write a fold that checks whether "fromEnum prev + 1 == fromEnum next"
04:16:27 <b52_> what if my type has a Constructor with a parameter?
04:16:32 <b52_> does that work for enum ?
04:16:47 <ketil> I have a program using a bunch of tuples, and I need to reduce GC times.  Would unboxed tuples help me here?  Or should I just define my own data Triple = Triple !Int !Int !Double, or whatever?
04:17:00 <ketil> Looks from the docs as if unboxed tuples are rather restricted.
04:17:00 <merijn> b52_: Yes, but it might not work with deriving. You can just implement your own instance for Enum by hand, though
04:17:31 <merijn> b52_: I'd check first, maybe it does work with deriving Enum
04:17:38 <b52_> tried, didnt work
04:18:30 <merijn> ok, then you'd have to implement your own instance for Enum, or a similar function unrelated to enum
04:18:59 <merijn> But the "prev + 1 == next" approach seems the most promising/simplest to me
04:19:13 <poetix> Hello Haskellers
04:19:37 <otters> prev + 2 == next
04:20:12 <poetix> Any category theorists in the place?
04:22:04 <bitonic> poetix: just ask, you'll probably get an answer
04:22:21 <bitonic> poetix: there are other channels more specific to CT, but questions are accepted here
04:24:37 <hpaste> chris2 pasted “folding over starrays” at http://hpaste.org/68379
04:24:53 <chris2> can anyone help me get this ^ typed?
04:26:22 <LambdaDusk> is there anyway to force a haskell program to be compile with glibc 2.13 compatibility?
04:26:36 <ClaudiusMaximus> chris2: the fmap on line 7 is the wrong thing to use
04:27:17 <chris2> how else can i lift the f?
04:28:59 <ClaudiusMaximus> :t liftM2
04:29:00 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
04:29:14 <mekeor> Hi poetix
04:29:27 <chris2> isnt that the same?
04:29:32 <ClaudiusMaximus> :t fmap
04:29:33 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:29:40 <chris2> oh, two arguments
04:30:30 <mekeor> a function always has one argument..
04:30:31 <chris2>     Occurs check: cannot construct the infinite type:
04:30:31 <chris2>       m1 = (->) (m1 a20)
04:34:57 <chris2> why do i even use >> there
04:36:26 <poetix> bitonic: I'm curious about the last section of Moggi's paper on monads as notions of computation, where he shows that a strong monad can always be treated as a monad over a topos.
04:36:27 <ClaudiusMaximus> chris2: it might help to add explicit type annotations to narrow down the error locations, like foldArray :: (Ix i, MArray a e m) => (a1 -> e -> a1) -> a1 -> a i e -> m a1  -- which results from using 'range' instead of '[from..to]'
04:37:16 <chris2> i noticed the working code doesnt even do what i want
04:37:24 <chris2> it just adds indexes, not the values
04:37:58 <bitonic> poetix: don't ask me, I know next to nothing about CT :)
04:38:03 <poetix> bitonic: I'm wondering whether anybody's developed that part of the paper in any interesting directions - what does it mean you can do, what programming constructs or ways of reasoning about programs does it suggest?
04:38:23 <poetix> bitonic: OK. Anyway, that's my question, if anyone wants to have a go ;)
04:39:09 <ClaudiusMaximus> :t fmap sum . getElems
04:39:10 <lambdabot> Not in scope: `getElems'
04:39:27 <ClaudiusMaximus> :t fmap sum . Data.Array.ST.getElems
04:39:29 <lambdabot> forall a (f :: * -> *) (a1 :: * -> * -> *) i. (Num a, Functor f, Data.Array.Base.MArray a1 a f, Ix i) => a1 i a -> f a
04:39:35 <chris2> got it now
04:41:03 <ClaudiusMaximus> cool
04:41:21 <hpaste> chris2 annotated “folding over starrays” with “folding over starrays (annotation)” at http://hpaste.org/68379#a68380
04:41:40 <chris2> getElems makes a list, no?
04:43:01 <ClaudiusMaximus> yeah
04:43:22 <chris2> probably should be fusioned tho
04:44:10 <ClaudiusMaximus> unfortunately getElems does have problems (at least in my experience i got a few stack overflows...)
04:44:21 <chris2> thats why i use starray in the first place
04:44:25 <chris2> :)
04:45:55 <ClaudiusMaximus> chris2: this is what i came up with: foldArray f i a = foldl (\m i -> liftM2 f m (readArray a i)) (return i) . range =<< getBounds a  -- though it might have f flipped compared to what you want
04:46:18 <chris2> nice
04:55:28 <scopedTV> Is there a BSD-licensed alternative for hmatrix?
04:56:01 <scopedTV> I'm not interested in functions from the GSL.
04:57:23 * hackagebot BNFC-meta 0.3.0.2 - Deriving Quasi-Quoters from BNF Grammars  http://hackage.haskell.org/package/BNFC-meta-0.3.0.2 (JeanPhilippeBernardy)
04:59:23 <ClaudiusMaximus> scopedTV: there is a related ticket https://github.com/albertoruiz/hmatrix/issues/5
05:00:13 <scooty-puff> how would one write, using arrows, something that would be done using Applicative as f <$> m <*> n
05:00:27 <scooty-puff> so say i have arrow operations m  and n, both :: a b c
05:00:37 <scooty-puff> and f :: c -> c -> d
05:00:45 <scooty-puff> and would like to make it a b d
05:02:00 <quicksilver> combine with (***)
05:02:07 <quicksilver> and compose with pure (curry f)
05:02:09 <quicksilver> I think?
05:02:32 <quicksilver> :t \m n f -> (m *** n) >>> arr (curry f)
05:02:33 <lambdabot> forall (cat :: * -> * -> *) b c b' c' b1 c1. (Arrow cat) => cat b c -> cat b' c' -> (((c, c'), b1) -> c1) -> cat (b, b') (b1 -> c1)
05:02:41 <scooty-puff> well, (&&&) in this case - all arrows should recieve the same argument b
05:02:43 <ClaudiusMaximus> :t \f m n -> m &&& n >>> arr (uncurry f)
05:02:44 <lambdabot> forall (cat :: * -> * -> *) a c c' c1. (Arrow cat) => (c -> c' -> c1) -> cat a c -> cat a c' -> cat a c1
05:02:54 <homie> (curry f) (ketchup e) (mayonnaise g)
05:02:59 <homie> lol
05:03:00 <quicksilver> uncurry of course
05:03:02 <quicksilver> thanks ClaudiusMaximus
05:03:12 <ClaudiusMaximus> :)
05:03:38 <scooty-puff> is there a way to have this grow to 3 arguments, etc.?
05:03:46 <scooty-puff> i assume more call to uncurry, etc.
05:04:08 <blueonyx> hi, i'm rewriting some fortran to haskell and the result from levmar seems to be 10 magnitudes worse than the native fortran one, how to tackle this?
05:04:24 <ClaudiusMaximus> :t \f m n o -> m &&& n &&& o >>> arr (uncurry (uncurry f)) -- maybe, perhaps associativity screws it up?
05:04:26 <lambdabot> forall (cat :: * -> * -> *) a c c' a1 b c1. (Arrow cat) => (a1 -> b -> (c, c') -> c1) -> cat a (a1, b) -> cat a c -> cat a c' -> cat a c1
05:05:58 <ClaudiusMaximus> :t \f m n o -> (m &&& n) &&& o >>> arr (uncurry (uncurry f)) -- better..
05:05:59 <lambdabot> forall (cat :: * -> * -> *) a c c' c'1 c1. (Arrow cat) => (c -> c' -> c'1 -> c1) -> cat a c -> cat a c' -> cat a c'1 -> cat a c1
05:06:09 <scooty-puff> k
05:06:20 <scooty-puff> thank you
05:07:15 <scopedTV> ClaudiusMaximus: Ok. Yeah, too bad. Maybe I'll have to write this in C then.
05:07:54 <scopedTV> The "blas" package exists, but seems bitrotted.
05:29:48 <Jaak> do monad laws have to hold for undefined values as well? for example, undefined >>= return == undefined
05:31:35 <bitonic> Jaak: that depends on (>>=) and return, obviously
05:34:30 <chris2> i have some weird issue when i use let inside a do-block
05:34:52 <chris2> and put in in the new line
05:35:03 <Jaak> bitonic: i don't understand you what you mean by that
05:35:05 <bitonic> chris2: you don't need "in" in a do block
05:35:10 <chris2> ooh
05:35:14 <bitonic> Jaak: it depends on the strictness of >>= and return
05:36:20 <Jaak> yes, the law holding or not depends on the strictness, exactly. but does it have to in case of undefined
05:36:21 <byorgey> Jaak: that is a contentious question.
05:37:02 <Igloo> Yes it has to, but it often doesn't  :-)
05:37:11 <Jaak> ha :)
05:41:35 <bitonic> Jaak: but yes in practice most monad instances do not respect the monad laws taking that into account
05:42:09 <bitonic> there is a similar problem with parametricity
05:43:01 <bitonic> well similar, people pretend that parametricity holds for haskell but you can break it with strictness
06:21:28 <mysticc> I have a list say [x1,x2,...xn] :: [Int] and I want to apply f :: Int -> Int -> a on all nC2 combinations .. Is there any function which does that ?
06:22:56 <hpc> mysticc: pick a way of getting a list of those combinations, then map (\[x,y] -> f x y)
06:24:01 <bitonic> mysticc: you can do "\l f -> map (\(x : y : []) -> f x y) (permutations l)", but I'm not sure how efficient that is
06:24:31 <byorgey> that's not the same thing
06:24:40 <mysticc> hpc: What would be the optimum way to pick .. I chose list but basically I will be reading n elements so I can use any other datastructure also .. My n is very large here so I will have to be a concerned  about performance
06:24:57 <byorgey> > permutations [1,2,3]  -- no lists of length 2 in the output
06:24:58 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
06:25:08 <bitonic> byorgey: maybe I misunderstood, I thought he wanted to apply that function to all possible couples of elements?
06:25:22 <bitonic> byorgey: oh sorry, that pattern should be \(x : y : _)
06:25:35 <byorgey> that still doesn't work
06:25:58 <bitonic> > (\f l -> map (\(x:y:_) -> f x y) (permutations l)) (+) [1,2,3]
06:25:59 <lambdabot>   [3,3,5,5,4,4]
06:26:00 <mysticc> bitonic: that will be n^2
06:26:04 <byorgey> > map (\(x : y : _) -> (x,y)) (permutations [1,2,3,4])
06:26:05 <lambdabot>   [(1,2),(2,1),(3,2),(2,3),(3,1),(1,3),(4,3),(3,4),(3,2),(4,2),(2,4),(2,3),(4...
06:26:19 <byorgey> it has lots of repeats and also the same pairs ordered both ways.
06:26:39 <bitonic> byorgey: right
06:26:49 <quicksilver> [ f x y | x <- l, y <- l \\ [x] ]
06:26:54 <byorgey> > map (\(x:xs) -> map ((,) x) xs) . init . tails $ [1,2,3]
06:26:56 <lambdabot>   [[(1,2),(1,3)],[(2,3)],[]]
06:26:59 <quicksilver> strikes me as the simplest way
06:27:08 <quicksilver> I'm not sure how it compares efficiency wise
06:27:15 <mysticc> I want an efficient way also I am not limited to list , I can choose any other datastructue also .. My n is very large ..
06:27:15 <byorgey> > concatMap (\(x:xs) -> map ((,) x) xs) . init . tails $ [1,2,3,4]
06:27:17 <lambdabot>   [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
06:27:38 <scopedTV> Isn't this a join (liftM2 f) ?
06:27:46 <byorgey> scopedTV: no, it isn't
06:27:46 <scopedTV> Oh, not really.
06:28:02 <quicksilver> nope, my way is bad
06:28:03 <byorgey> I think the code I gave above is optimal for generating combinations
06:28:08 <quicksilver> assumes Eq instance.
06:28:18 <byorgey> it never throws anything out.
06:28:22 <rwbarton> if n is really very large you should probably be more concerned about how long it takes to compute f than how long it takes to do this picking two elements stuff
06:28:43 <hpc> or be concerned about chunking the list in some way
06:28:48 <mysticc> rwbarton: My f is basically bitwise xor here
06:29:02 <rwbarton> how large is "very large"
06:29:13 <scopedTV> combs [] = []; combs [x] = []; combs [x,y] = [(x,y)]; combs (x:xs) = map (x,) xs ++ combs xs ?
06:29:42 <byorgey> scopedTV: yep, that's basically equivalent to the code I gave above
06:29:43 <scopedTV> Ah, that's basically what byorgey wrote.
06:29:57 <hpc> scopedTV: with that definition you can leave out one of the [x] and [x,y] cases :P
06:30:05 <mysticc> rwbarton: like 10^4 ..
06:30:05 <scopedTV> Yeah.
06:30:16 <mysticc> thats the upper limit ..
06:30:29 <hpc> > 10^4
06:30:30 <lambdabot>   10000
06:30:37 <rwbarton> okay, that is within reason
06:30:48 <scopedTV>  n choose 2 is n(n-1)/2, that's really not too bad
06:31:03 <rwbarton> sometimes you ask and find out "very large" is like ten million
06:31:09 <hpc> > 10000^2
06:31:10 <lambdabot>   100000000
06:31:15 <rwbarton> then there's a problem :)
06:31:51 <hpc> rwbarton: i would just say that's "large", personally
06:31:57 <hpc> and save "very large" for billion+
06:32:12 <hpc> "very large" is when you get into being unable to load it all at once
06:38:50 <quicksilver> hpc: surely "large" is when it doesn't fit in your memory and "very large" is when it wouldn't even fit on your disk?
06:39:32 <scopedTV> And "a little bit large, but not too bad" is when it fills up more than 50% of available memory?
06:39:43 <Botje> sounds like eclipse
06:41:40 * scopedTV doesn't mind Eclipse that much, but that's probably very off-topic
06:42:08 <quicksilver> about once every six months someone comes in and asks for help with eclipsefp
06:42:23 <quicksilver> there never seems to be anybody else around who knows any answers though
06:42:49 <scopedTV> I thought that was more or less a dead project?
06:43:02 <byorgey> not at all.
06:43:08 <scopedTV> Ah, cool.
06:43:12 <quicksilver> it's like a horror film, scopedTV
06:43:13 <byorgey> it's actually looking quite nice these days.
06:43:18 <quicksilver> every time you think it's dead
06:43:23 <quicksilver> it comes lurching back
06:43:37 <byorgey> the only problem with it is Eclipse.
06:43:41 <scopedTV> I'll check it out sometime, although I'm probably staying with emacs+evil.
06:43:57 <quicksilver> I tried to understand eclipse and eclipse plugins about 5-6 years ago
06:44:18 <quicksilver> it seemed to me that it would work very well for, well, Java, and would work for other languages in proportion to their similarity to java
06:44:48 <quicksilver> I'm sure things have moved on, though, and also I may well have misunderstood some of what I saw.
06:47:49 <Zedrikov> Now there is leksah for haskell, though you do not have all what you could dream of in it…
06:48:04 <scopedTV> I've never used it.
06:49:04 <quicksilver> one of the best things about java and C# IDEs is the type-aware autocompletion and that just doesn't port to haskell
06:49:17 <quicksilver> because the reason it works is the "subject.verb" word order.
06:49:41 <hpc> quicksilver: and also because you have to declare each and every type everywhere you declare things
06:49:45 <hpc> which makes the job a bit easier
06:49:53 <hpc> don't have to worry about types changing due to code insertion
06:50:33 <quicksilver> yes although Im' not sure that's *vital*
06:50:56 <quicksilver> there are many cases when you can infer types from previous lines
06:51:06 <quicksilver> it does make it easier, I agree.
06:51:22 <Zedrikov> It is rather usable nowadays, what I miss is some refactoring stuff as well as column-wise edition. And for the autocompletion, it is not type aware (I guess it could in some extent, ie. when providing type signatures).
06:51:38 <quicksilver> I just use emacs' dumb autocompletion
06:51:49 <quicksilver> (in haskell as well as in other languages I program in)
06:52:03 <quicksilver> which does a reasonable job at not misspelling long identifier names
06:52:08 <quicksilver> (and typing them faster too)
06:52:17 <Zedrikov> leksah can do this as well.
06:52:25 <Zedrikov> (and probably yi too)
06:53:07 <quicksilver> which part, Zedrikov ?
06:53:32 <jonaskoelker> does the function "(0-)" have a shorter or more idiomatic name in haskell?
06:53:41 <hpc> negate
06:53:42 <scopedTV> negate
06:53:48 <jonaskoelker> thanks :)
06:53:56 <hpc> and for sections going the other way, subtract
06:54:25 <hpc> in theory, negate should even be faster
06:54:26 <Zedrikov> quicksilver: job at not misspelling long identifier names
06:54:37 <quicksilver> Zedrikov: *nod*
06:54:39 <hpc> for floats, it can just do some bitwise stuff instead of jumping all the way to floating math
06:54:43 <Botje> ((+) . negate)
06:54:59 <Botje> for maximum pointfreeosity!
06:55:21 <quicksilver> Zedrikov: problem is, yi and leksah have to offer something seriously compelling to convince me to learn a new editor. I have a lot of invested knowledge :)
06:56:10 <jonaskoelker> Botje: and pointlessness? ;)
06:56:35 <Zedrikov> quicksilver: for yi, you have configuration in Haskell instead of emacs lisp, I believe
06:57:02 <jonaskoelker> what's the (ahem) point of pointfree style?
06:57:19 <jonaskoelker> not that it isn't all kinds of cool, but is it just an academic kind of cool, or ...?
06:57:23 <Zedrikov> joanskoelker: it's free
06:57:47 <scopedTV> jonaskoelker: Sometimes it makes things clearer or more beautiful.
06:58:04 <scopedTV> jonaskoelker: f (g (h x)) is more verbose and less clear than f . g . h
06:58:15 <ski>   (f . g . h) x
06:58:28 <osfameron> and easier to compose
06:58:57 <ski> @quote compose
06:58:57 <lambdabot> lilac says: class Monad m where / return and Kleisli compose / must form a monoid
06:59:03 <blueonyx> is there any alternative to levmar?
06:59:27 <scopedTV> ski: Yeah. I meant like in a definition; print x = putStrLn (show x) vs print = putStrLn . show for example
06:59:51 <ski> aye, i know
07:00:44 <Zedrikov> quicksilver: and for leksah, you have documentation, for instance when you type "fold", its signature can appear in a window, and when you want to browse the functions of a module, you can also do it without opening some browser.
07:01:15 <quicksilver> the first part of that the emacs haskell mode does fine
07:01:29 <quicksilver> for the second part "opening some browser" has never struck me as a huge disadvantage
07:01:39 <quicksilver> I always have some browser open anyway
07:02:19 * ski finds the contant nagging about type in the minibuffer annoying, usually turns it off
07:02:49 <mysticc> @hoogle log
07:02:50 <lambdabot> Prelude log :: Floating a => a -> a
07:02:50 <lambdabot> Prelude logBase :: Floating a => a -> a -> a
07:02:50 <lambdabot> Network.CGI.Protocol logCGI :: MonadIO m => String -> m ()
07:12:47 <lamefun2> is it possible to compile programs that have main module that is not in root package? for example. MyProgram.Main?
07:13:27 <hpc> lamefun2: man ghc # search for --main-is
07:15:35 <lamefun2> and SDL binding lacks glSwapControl.
07:15:44 <lamefun2> how to submit a patch when I fix?
07:16:27 <merijn> lamefun2: Find out the maintainer and e-mail him/pull request?
07:16:58 <merijn> Hackage project pages lists emails/bug trackers/etc
07:17:50 <lamefun2> :t Graphics.UI.GLUT.$=
07:17:51 <lambdabot> parse error on input `Graphics.UI.GLUT.$='
07:18:34 <parcs`> lamefun2: what does glSwapControl do
07:18:41 <lamefun2> VSync
07:19:43 <parcs`> and where would you get this glSwapControl from?
07:19:49 <parcs`> because SDL sure doesn't have it
07:20:06 <parcs`> that is, SDL the library, not the haskell bindings
07:21:03 <parcs`> try 'grep -r glSwapControl /usr/include/SDL'
07:21:30 <lamefun2> parsec http://www.libsdl.org/cgi/docwiki.cgi/SDL_GLattr
07:21:34 <lamefun2> it's SDL_GL_SWAP_CONTROL
07:21:47 <lamefun2> in haskell it should be called glSwapControl because of naming convention
07:22:04 <lamefun2> Graphics.UI.SDL.glSwapControl
07:24:18 <parcs`> ah
07:24:37 <parcs`> for a workaround you can define glSwapControl = 16
07:27:22 <eacameron> Complaint: Haskell boasts one of the best type-systems out there (which I don't argue). It has amazing type-inference. But why can't it figure out which `lines` function I want to use when I import `Data.ByteString.Char8`?? If I run `lines` on a ByteString variable, shouldn't GHC be able to deduce that I want the ByteString version not the Prelude version??
07:27:35 <quicksilver> eacameron: it could, certainly.
07:27:39 <quicksilver> eacameron: that's just not how it works.
07:27:51 <quicksilver> people like the property that subexpressions have a well-defined principle type.
07:28:08 <quicksilver> "lines" on its own must have a sensible type which explains how it is applied to the arguments.
07:28:21 <quicksilver> if you want it to do different things depending on the arguments, put it in a typeclass
07:28:30 <quicksilver> which are the "organised" way to arrange ad-hoc overloads.
07:28:49 <scopedTV> isn't it a bit like TNDR?
07:28:54 <hpc> once you have overloading like that, you need a way to keep the overloadings from "overlapping"
07:28:54 <scopedTV> TDNR, I mean.
07:28:58 <eacameron> quicksilver: so why isn't lines in a typeclass like you said? I'm just curious
07:29:09 <quicksilver> it would be an example of TDNR in its widest sense, yes, scopedTV
07:29:10 <scopedTV> eacameron: Historical reasons, performance I suppose.
07:29:15 <quicksilver> eacameron: no reason at all.
07:29:17 <quicksilver> it just isn't.
07:29:27 <quicksilver> feel free to write one if you think it is important or useful.
07:29:31 <hpc> in theory, it could go in isString
07:29:40 <hpc> in practice, people just import stuff qualified
07:30:04 <eacameron> hpc: I realize that's what people do in practice. but they wouldn't have to do that if the inference picked the right function 90% of the time
07:30:04 <geekosaur> eacameron, it only does that for typeclass members, not general functions.  this feeds into the last go-round on the record handling bikeshed, which suggested using modules for records and then using types to select module functions in that way
07:30:07 <hpc> i think you will find that once you start moving string operations to isString, you end up moving all of them
07:30:23 <hpc> because they can't be split into "fundamental operations" and higher-level stuff
07:30:47 <lamefun2> Also, how is F# different from Haskell?
07:31:01 <hpc> lamefun2: many ways, mostly to do with .NET interop
07:31:20 <lamefun2> Is F# better/more advanced?
07:31:33 <quicksilver> F# is worse
07:31:38 <scopedTV> F# is different.
07:31:38 <quicksilver> and takes fewer characters to type
07:31:51 <quicksilver> F# isn't pure.
07:32:00 <scopedTV> F# is more like OCaml
07:32:16 <scopedTV> If you need to write .NET, it's fine I suppose.
07:32:32 <quicksilver> prior art on the string typeclass thing: http://hackage.haskell.org/packages/archive/tagsoup/0.8/doc/html/Text-StringLike.html http://hackage.haskell.org/packages/archive/web-encodings/0.2.6.2/doc/html/Web-Encodings-StringLike.html http://www.haskell.org/pipermail/haskell-cafe/2006-July/016504.html
07:32:38 <quicksilver> and surely lots more.
07:33:31 <quicksilver> oh, http://hackage.haskell.org/package/ListLike of course
07:33:48 <lamefun2> Haskell is, no matter how good it is, a mere programming language while F# is a Microsoft technology and part of Microsoft platform :(
07:34:04 <hpc> i would rather use a programming language than a platform
07:34:11 <geekosaur> still trolling, lamefun2?
07:34:13 <lamefun2> why?
07:34:31 <lamefun2> geekosaur: yes, why not? it's fun!
07:34:36 <geekosaur> did you ever do what I suggested the other day?  about looking up *who is behind ghc development?*
07:34:46 <geekosaur> or would that take too much fun out of your self-degradation?
07:34:50 <Franciman> microsoft?
07:35:06 <Clint> spoiler alert
07:35:25 <scopedTV> Where is Jon Harrop when you need him?
07:35:35 <lamefun2> geekosaur: Microsoft O_o?
07:35:40 <geekosaur> MSR Cambridge, to be specific
07:36:00 <hpc> geekosaur: the england cambridge? :P
07:36:15 <merijn> lamefun2: The main developers of GHC are employed by MS Research, yes
07:38:30 <lamefun2> What do they need it for?
07:38:37 <lamefun2> They already have F#
07:39:01 <Eduard_Munteanu> They had been working on Haskell long before F# AFAIK.
07:39:59 <jonaskoelker> how do I make haskell-mode show me the type of functions I cursor-over?
07:40:10 <Eduard_Munteanu> lamefun2: the nice thing about MSR is they let researchers do their thing, as far as I understand. Once in a while they kinda feel compelled to get something out of it :)
07:40:23 <quicksilver> MSR is a research division, their priorities are inhernetly more open-ended
07:40:33 <quicksilver> but big companies don't bet the farm on a single basket of eggs, anyway.
07:40:34 <Eduard_Munteanu> Hence F#, F* and that sort of stuff.
07:40:52 <quicksilver> (F# learnt some lessons from the haskell team too, I believe)
07:40:57 <lamefun2> Why do they work on free software O_O?
07:41:17 <quicksilver> research divisions often do work on public research
07:41:21 <quicksilver> it has always been thus
07:41:27 <merijn> lamefun2: Why not?
07:41:29 <quicksilver> they often need to do that, to attract the best staff.
07:41:48 <quicksilver> (but I'm not saying that's the answer to "why?")
07:42:18 <merijn> quicksilver: I have a more pragmatic theory based on business administration. And that is that it pays to outsource anything that is not a competitive advantage (because you can share the cost of maintenance with the community/other companies)
07:42:58 <Eduard_Munteanu> I guess so. Besides, researchers like to get their results published.
07:43:20 <merijn> Microsoft's competitive advantage is not technology, it's fame, enterprise sales, familiarity and product integration
07:43:53 <merijn> oh, and lock-in of course
07:43:57 <tac-tics> When it comes to compiler tech, I would disagree
07:44:05 <merijn> As a result, open sourcing any research is advantageous (you share research costs), while you're actual problems should lock you in
07:44:15 <merijn> err...
07:44:18 <merijn> s/problems/solutions
07:45:02 <quicksilver> merijn: GHC is currently utterly irrelevant to MS's competitive advantage.
07:45:18 <merijn> Yes, that was my point, wasn't it?
07:45:34 <Eduard_Munteanu> MS got more open-minded to FOSS in recent years. E.g. see their Hyper-V patches to Linux or stuff like that.
07:45:40 <quicksilver> well a strict business admin argumetnw ould then argue for it to be axed.
07:45:50 <quicksilver> but the motives are more subtle and longer-term
07:46:05 <Eduard_Munteanu> In which case it also helps them without giving away too much.
07:46:11 <merijn> Why can't business admin arguments be subtle and long-term?
07:46:17 <quicksilver> of couse they can
07:46:25 <quicksilver> I'm just saying you haven't made them :)
07:46:50 <quicksilver> I obviously don't know why MS funds MSR.
07:47:00 <merijn> I argued for why they're releasing it, I didn't try explaining why they do it in the first place :p
07:47:04 <quicksilver> but one reason is to give them a presence in cambridge to attract bright postgrads
07:47:13 <Eduard_Munteanu> Well, how big is MSR, really?
07:47:32 <tac-tics> Is size a good thing for research?
07:47:34 <Eduard_Munteanu> I don't think they're spending that much on non-vital projects, after all.
07:47:53 <quicksilver> one reason may actually be philanthropic - WGIII supports education and computer science
07:47:53 <scopedTV> From a business standpoint, things need more justification if they are bigger.
07:48:03 <quicksilver> (and MSR was set up while he was in charge)
07:48:40 <quicksilver> and of course, plenty of ideas within MSR *do* end up having commercial applications.
07:48:51 <quicksilver> They model-check their device drivers, I believe
07:50:43 <Eduard_Munteanu> Anyway, I guess paying the Simons isn't a problem at all, if you look at the big picture.
07:51:31 <lamefun2> Aren't there any patent traps in Haskell?
07:52:01 <Eduard_Munteanu> It's pretty cheap compared to the load of programmers working on other, even small projects, I guess.
07:52:11 <donri> na we fine, microsoft creates haskell
07:52:32 <quicksilver> lamefun2: there are patents in every line of code you ever write.
07:52:41 <quicksilver> if you're going to worry about it, you might as well not code.
07:52:48 <lamefun2> even in printf ("hello World!\n")?
07:53:15 <ClaudiusMaximus> better don't ask - if you know about patents the financial consequences can be several times higher
07:53:20 * Eduard_Munteanu imagines "Method of passing an arbitrary number of arguments to a given function." :P
07:53:23 <quicksilver> "Patent covering a device for emitting greetings to the world community as a whole in computer-readable format" (US Patent no 1787528391)
07:53:38 <Eduard_Munteanu> Hah.
08:02:00 <tac-tics> quicksilver: lololol
08:02:27 <tac-tics> quicksilver: Did you find that somewhere, or do we get to credit that to you?
08:02:58 <quicksilver> tac-tics: which?
08:03:35 <tac-tics> quicksilver: Patent covering a device for emitting greetings to the world community as a whole in computer-readable format" (US Patent no 1787528391
08:05:51 <quicksilver> tac-tics: I just made that one up Im' afraid
08:06:13 <tac-tics> quicksilver: shame shame
08:06:19 <tac-tics> @remember quicksilver "Patent covering a device for emitting greetings to the world community as a whole in computer-readable format" (US Patent no 1787528391)
08:06:19 <lambdabot> Done.
08:09:55 <rwbarton> There aren't quite that many patents filed.
08:10:07 <Clint> yet
08:10:11 <rwbarton> Yet.
08:12:09 <Eduard_Munteanu> Sadly, exFAT pending patent is quite funny too.
08:12:52 <Eduard_Munteanu> http://worldwide.espacenet.com/publicationDetails/biblio?CC=US&NR=2009164440&KC=&FT=E&locale=en_EP
08:12:58 <cg_morton> I've gotta say, the US patent website is pretty well designed
08:13:30 <Clint> just don't try doing any complex searches
08:17:01 <donri> software patents are like patents for things like "boiling water by applying heat"
08:18:04 <cg_morton> most patents are like that
08:18:59 <donri> heh
08:19:19 <cg_morton> you know somebody's patented, say, the doorstop
08:19:42 <cg_morton> rolls of paper
08:19:45 <Clint> pillows
08:19:53 <cg_morton> nonstick pans
08:19:59 <Clint> cookies
08:20:01 <efie> I have a list of type [(Int,Int)] and I want to map a function of type (Int,Int) -> (Int,Int) -> Bool ober it so that I get a list of functions who take one (Int,Int) and return a Bool. can I do this?
08:20:12 <Clint> yes
08:21:04 <donri> efie: just do it!
08:21:28 <efie> I tried map (\x -> isNeighbor x) [(1,1)] but I get an error (Neighbor is the function of type (Int,Int) -> (Int,Int) -> Bool)
08:21:42 <donri> that lambda can be reduced to "isNeighbor" btw
08:21:56 <S11001001> efie: a Show error?
08:22:04 <efie> S11001001: yes
08:22:20 <rwbarton> you don't need to write (\x -> isNeighbor x)
08:22:24 <S11001001> efie: can't show functions, try :t your-expression
08:22:27 <rwbarton> that is just a long way to say isNeighbor
08:22:27 <donri> yea functions don't have a Show instance normally
08:22:31 <eacameron> how do I map over a list and get a Data.Map out of it? Does that make any sense?
08:22:38 <Clint> fromList
08:22:39 <efie> rwbarton: ok
08:29:46 <eacameron> Clint: that means I have to construct the [(a, b)] list and then convert it to a map. that defeats the purpose since I'm only using Map for efficiency
08:30:13 <fmap> @hoogle getArgs
08:30:14 <lambdabot> System.Environment getArgs :: IO [String]
08:30:14 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
08:30:50 <quicksilver> eacameron: not really in any meaningful sense
08:31:02 <quicksilver> eacameron: that [(a,b)] list is being destroyed as fast as its being created
08:31:16 <quicksilver> eacameron: it never really exists so you stay in cache - which is what matters on modern CPUs.
08:31:28 <quicksilver> it may even fuse out of existence entirely.
08:31:36 <quicksilver> in haskell lists are our loops.
08:32:01 <Botje> wow
08:32:09 <Botje> toList/fromList fuses?
08:32:18 <Botje> cool
08:32:24 <rwbarton> he said "may"
08:32:32 <Botje> ah
08:32:34 <Botje> aww :(
08:32:46 <rwbarton> he said "may"!
08:32:58 <rwbarton> don't give up so fast :P
08:33:15 <quicksilver> it really doesn't matter much if it fuses, in most cases
08:33:27 <cg_morton> eacameron: so what exactly are you doing?
08:33:29 <quicksilver> a (:)-cell in a cache line is, what, two pointers?
08:33:48 <cg_morton> I'm imagining a list [a], function (a -> b), and you want a map with key b value a?  but of course that is a wild guess
08:33:50 <quicksilver> two pointers in a cache line are not often going to be your CPU bottleneck.
08:34:04 <rwbarton> also the number 1
08:34:15 <quicksilver> what it *won't* do is deforest the tuple, unfortunately.
08:34:25 <quicksilver> but again, that's not as scary as it sounds.
08:34:35 <rwbarton> anyways the Map is a lot bigger than the list.....
08:34:41 <quicksilver> trust the fromList.
08:35:57 <tac-tics> @type fromList
08:35:58 <lambdabot> forall a (m :: * -> *). (MonadRandom m) => [(a, Rational)] -> m a
08:36:12 <cg_morton> so I guess there are, in fact, over 200 distinct patents for door stops
08:36:23 <tac-tics> @src MonadRandom
08:36:23 <lambdabot> Source not found. :(
08:36:40 <quicksilver> tac-tics: not that fromList actually :)
08:36:43 <quicksilver> @type M.fromList
08:36:44 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
08:36:44 <tac-tics> I figured
08:36:50 <hpc> :t S.fromList
08:36:52 <lambdabot> forall a. (Ord a) => [a] -> S.Set a
08:36:52 <lamefun2> does Haskell have an RSVG binding?
08:37:08 <lamefun2> or any other free software SVG rendering library?
08:37:27 <quicksilver> cairo maybe lamefun2 ?
08:37:32 * hackagebot active 0.1.0.1 - Abstractions for animation  http://hackage.haskell.org/package/active-0.1.0.1 (BrentYorgey)
08:37:39 <lamefun2> that's just a vector drawing library
08:37:47 <quicksilver> I thought it did SVG
08:37:50 <lamefun2> I want something that'll parse SVG and return me a picture
08:38:01 <hpc> what kind of picture?
08:38:05 <quicksilver> cairo will do that, yes
08:38:13 <lamefun2> does it parse SVG?
08:38:13 <quicksilver> for some values of 'picture'
08:38:17 <quicksilver> yes.
08:38:31 <hamid> just a noob question: is this "Complex" module which is imported in the source I'm trying to compile should be included to ghc itslef ? or I should install it to my distro ?
08:38:39 <dcoutts> lamefun2: not cairo directly, but there's an extension lib that renders svg using cairo
08:38:42 <quicksilver> http://hackage.haskell.org/package/svgcairo
08:38:49 <dcoutts> lamefun2: and there's a Haskell binding for that
08:38:56 <dcoutts> ah, the one quicksilver points out
08:38:56 <luite> hamid: it's included with ghc, if it's Data.Complex at least
08:39:07 <byorgey> that package can *parse* SVG?
08:39:20 <hamid> luite, no. "import Complex"
08:39:32 <hamid> luite, actually trying to compile this http://www.ryanlothian.com/projects/haskell_fractals/
08:39:33 <luite> hamid: oh that's the old package name
08:39:39 <dcoutts> byorgey: you feed it a file or string containing svg and it renders it
08:39:47 <byorgey> I see, cool
08:39:51 <hamid> luite, ok! then that's just old. thanks :)
08:40:06 <dcoutts> byorgey: so in that sense it parses it, but it gives you back the rendered image, not an AST or something :-)
08:40:11 <hamid> I thought there is something wrong with my ghc.
08:40:15 <byorgey> right =)
08:40:18 <luite> hamid: you can try to change it into Data.Complex and see if it works then
08:40:35 <hamid> luite, hmm... let me try that
08:40:50 <luite> hamid: (you can still use the old module names if you build with the haskell98 package, but it's easier to just use the new names)
08:41:51 <hamid> luite, right now just want to compile this ;)
08:42:28 <hamid> luite, skipped that but some new errors appeared. yeah i'd try that too
08:42:42 <luite> hamid: can you paste those?
08:42:44 <byorgey> hamid: what are the new errors?
08:43:27 <hamid> http://pastebin.com/raw.php?i=93hvJzw0
08:43:30 <mauke> The paste 93hvJzw0 has been copied to http://hpaste.org/68385
08:44:10 <quicksilver> those both appear to be typos, hamid
08:44:15 <luite> hamid: those just look like typos :)
08:44:18 <quicksilver> mandle madel
08:44:21 <quicksilver> brof brot
08:44:36 <quicksilver> heh I can't even describe your typos without making more typos of my own.
08:44:52 <quicksilver> It's harder than it looks this typing lark. "mandle mandel" I meant.
08:44:52 <luite> they're contagious
08:44:53 <rwbarton> recursive typos
08:44:57 <hamid> i didn't write this actually :P
08:45:14 <hamid> anyway let my fix them
08:45:15 <hamid> :D
08:47:32 * hackagebot splice 0.6.0.2 - Cross-platform Socket to Socket Data Splicing  http://hackage.haskell.org/package/splice-0.6.0.2 (CetinSert)
08:47:35 <hamid> damn! it compiled :P
08:47:48 <hamid> thank you :)
08:49:09 <hamid> just for my curiosity. I know those *.o are objects. but what are those *.hi ?
08:49:17 <hpc> interface files
08:50:06 <hpc> iirc, it keeps information that ghci uses, which can't be put into object files
08:50:14 <hpc> types, etc
08:50:29 <hamid> hpc, aha. thank you.
08:53:12 <geekosaur> not just ghci; it's information used for inlining, etc.  it's also faster than parsing an entire source file to find out types, typeclasses/instances, etc. it defines
08:54:49 <hamid> look up table or something like that?
08:55:02 <quicksilver> it contains full type information (which has been type checked)
08:55:07 <quicksilver> and code fragments (for inlining)
08:55:29 <quicksilver> so it's a list of all exported symbols, their types, and code for some of them.
08:55:40 <hamid> got it... it
09:04:49 <efie> can I nest maps? in "map (\(f,ns) -> map (\n -> (lookUp f nodes, lookUp n nodes, 0)) ns) neighborsOnlyWithFrom" I get an " parse error (possibly incorrect indentation)" error
09:05:04 <quicksilver> you can nest maps
09:05:30 <rwbarton> "can I nest maps" cannot have any relation to "parse error (possibly incorrect indentation)"
09:05:45 <efie> hm ok
09:05:53 <hpc> check your parens
09:05:55 <byorgey> I don't see any parse errors in that code.  The error must be elsewhere.
09:05:59 <quicksilver> his parens are fine
09:06:04 <hpc> ah
09:06:13 <hpc> @where hpaste
09:06:13 <quicksilver> the error must be to do with context
09:06:14 <lambdabot> http://hpaste.org/
09:06:17 <quicksilver> or the way you've broken a line
09:06:18 <rwbarton> :t map (\(f,ns) -> map (\n -> (?lookUp f ?nodes, ?lookUp n ?nodes, 0)) ns) ?neighborsOnlyWithFrom
09:06:19 <lambdabot> forall a t t1 t2. (?neighborsOnlyWithFrom::[(a, [a])], Num t2, ?nodes::t, ?lookUp::a -> t -> t1) => [[(t1, t1, t2)]]
09:06:37 <byorgey> efie: if you are having trouble figureing out what is going on, feel free to paste your code on hpaste
09:06:53 <efie> byorgey ok, thanks :)
09:09:48 <hpaste> efie pasted “parse error (possibly incorrect indentation)” at http://hpaste.org/68386
09:10:08 <rwbarton> line 4 is bad
09:10:22 <efie> arg
09:10:36 <efie> I see.. thanks
09:12:04 <eacameron> cg_morton: I'm parsing the output from "uniq -c" and making a map of word, count pairs.
09:12:32 <eacameron> quicksilver: really? So it there's no performance hit to creating the [(a,b)] list on the way to Map?
09:13:11 <quicksilver> eacameron: much less than you'd imagine, just try it
09:13:15 <quicksilver> eacameron: the whole list is never created
09:13:21 <quicksilver> which means everything stays in cache
09:13:31 <quicksilver> which (to a lazy approximation) is "the only thing that matters" on a modern CPU
09:14:02 <hpc> (but not as lazy an approximation as you might think)
09:14:54 <rwbarton> much less than say having to parse the output of uniq -c
09:19:53 <eacameron> rwbarton: I realize it's probably small overhead, but is it `worth` the overhead is my question. I could just use [(a,b)] and forget Maps altogether
09:20:01 <eacameron> rwbarton: I guess I'll have to profile it
09:20:17 <quicksilver> depends what you're going to do with the data afterwards
09:27:33 * hackagebot ottparse-pretty 0.1.2.1 - Pretty-printer for Ott parse trees  http://hackage.haskell.org/package/ottparse-pretty-0.1.2.1 (BrentYorgey)
09:38:32 <Eiam> I'm going through Learn you a haskell and am puzzled by this
09:39:09 <Eiam> if ++ is the list operator to join lists, why do i have to say [[1,2,3,4],[1,2,3,4]] ++ [[1,1,1]] why can't it be ++ [1,1,1,1]
09:39:23 <scopedTV> Because of the types
09:39:26 <scopedTV> (++) :: [a] -> [a] -> [a]
09:39:27 <Eiam> i'd expect the first to give me yet another nested list
09:39:30 <hpc> Eiam: (++) joins a list of things and a list of the same things
09:39:45 <hpc> [[1,2],[3,4]] is a list of lists of nums
09:39:49 <hpc> [[Int]], we will say
09:39:50 <Eiam> ah right
09:39:51 <saml> Eiam, what do you expect [[1,2]] ++ [3,4]  to be?
09:39:52 <scopedTV> ++ is not really "joining".
09:39:54 <hpc> [1,1,1,1] :: [Int]
09:39:55 <Eiam> so its a list of lists that have to be joined
09:39:58 <Eiam> not a list plus a list
09:40:06 <scopedTV> "concatenating" is the usual terminology.
09:40:20 <Eiam> saml: [[1,2],[3,4]] was my expectation
09:40:26 <Eiam> saml: obviously in reality its an error
09:40:33 <saml> how come?  [3,4] is not [[3,4]]
09:40:41 <scopedTV> Eliel: Ah, no [3,4] ++ [1] = [3,4,1]
09:40:51 <monochrom> [[1,2,3,4],[1,2,3,4]] ++ [1,1,1]  is wrong level of lists
09:41:08 <Eiam> right, I get it. I didn't realize the 'type' extended so.. high
09:41:17 <Cale> It would be [[1,2],3,4], which is only *probably* a type error :)
09:41:28 <monochrom> nesting is a powerful, underappreciated concept
09:41:35 <Cale> (you might make an instance of Num for lists)
09:41:36 <saml> Eiam, you're probably looking for :    [3,4] : [[1,2]]
09:41:38 <scopedTV> Cale: if you don't have Num [a] :)
09:41:53 <saml> > [3,4] : [[1,2]]
09:41:54 <lambdabot>   [[3,4],[1,2]]
09:42:03 <Eiam> wait, why does that work and the other way doesn't?!
09:42:12 <scopedTV> No, : is different from ++
09:42:19 <saml> head is stronger than bottom
09:42:21 <mefisto> Cale: I thought everything in the list has to be of the same type... so [[1,2],3,4] is two types
09:42:21 <Eiam> ++ is append and : is prepend..
09:42:25 <scopedTV> x:xs is the list with first element x and rest xs
09:42:32 <Eiam> Cale: your example results in an error
09:42:34 <hpc> :t (:)
09:42:35 <lambdabot> forall a. a -> [a] -> [a]
09:42:40 <scopedTV> mefisto: Not necessarily, do you know about type classes and numeric literals?
09:42:50 <hpc> :t (Prelude.++) -- lambdabot has a funny definition
09:42:50 <scopedTV> Eiam: please don't pay attention to Cale's example at this stage :)
09:42:51 <lambdabot> forall a. [a] -> [a] -> [a]
09:43:09 <saml> Eiam, : means swallow left.   ++ means glue right
09:43:10 <Eiam> okay so I follow why [[]] ++ [] fails, the first is a list of lists, the second is a list, so the types don't match.
09:43:11 <mefisto> scopedTV: sort of... I too am going through learn you a haskell :D
09:43:22 <Eiam> I'm now working on why [] : [[]] works
09:43:25 <saml> 1 : []  means  [] swallows 1
09:43:31 <scopedTV> mefisto: well a numeric literal, like 37, really is "fromInteger 37"
09:43:35 <saml> [] ++ [1]  means [] glues [1]
09:43:49 <Eiam> why does the type matter in one case and not the other
09:43:58 <Eiam> sorry glue & swallow aren't terms im familiar with
09:44:02 <monochrom> the type matters in both cases
09:44:02 <scopedTV> Eiam: types always matter.
09:44:05 <jfischoff> for some reason my program hangs when compiled but works fine when run with ghci. The last step it is hanging on is writing out a lazy ByteString. Any ideas?
09:44:13 <monochrom> too many chefs
09:44:15 <scopedTV> Eiam: [[]] means "a list with one element, namely []"
09:44:18 <Eiam> scopedTV: yet []: [[]] works and [[]] ++ [] doesn't
09:44:20 <saml> Eiam, you glue the same things together.  but you swallow something smaller than you.
09:44:24 <mefisto> Eiam: I think the : puts the thing on the left inside a list for you
09:44:25 <scopedTV> Eiam: the latter also works.
09:44:48 <scopedTV> you should really understand (:) first imo
09:44:56 <Eiam> im just reading through the starting-out
09:45:14 <Eiam> scopedTV: it does not.. [[1,2],[3,4]] ++ [1,1] fails
09:45:15 <scopedTV> A list is either the empty list (that is, []) or it is an element plus the rest of the list (x:xs)
09:45:34 <Eiam> scopedTV: and [1,1]: [[1,2],[3,4]] works
09:45:40 <scopedTV> Yes, true.
09:45:47 <saml> [] is an empty room.  a girl enters it:  [girl].  a boy enters it. [boy, girl].   but a room with a girl cannot enter it. [[girl], boy, girl]  --this is bad
09:45:53 <Eiam> the rule i just established for the reason the first fails, falls apart in the second case
09:46:07 <saml> a room takes girls or boys, not another room. you can't put a room in a room
09:46:15 <scopedTV> Eiam: So, in (x:xs), x can be of type Integer, xs is of type [Integer]
09:46:18 <Eiam> saml: but you can with [1,1]: [[1,2],[3,4]]
09:46:33 <scopedTV> some lists are [], 1:(2:(3:[]))
09:46:35 <saml> Eiam, [[]] is a room of rooms!
09:46:51 <mefisto> Eiam: your mistake is thinking that ++ and : work the same way... I'm going through learn you a haskell too right now, in like chapter 8 :D
09:46:56 <Eiam> saml: so is [[1,2],[3,4]] ++ [1,1] ??
09:47:10 <saml> [] is an empty room.  a room with a girl enters it:  [[girl]].  a room with a boy enters it [[boy], [girl]]
09:47:12 <Eiam> mefisto: they are presented in the guide right next to each other
09:47:14 <Eiam> mefisto: in the same example
09:47:22 <saml> Eiam, ++ is glue
09:47:23 <Eiam> why wouldn' i think they are related, its presented as append and prepend
09:47:34 * hackagebot git-annex 3.20120511 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20120511 (JoeyHess)
09:47:35 <saml> oh man this is so complicated. let's give up
09:47:42 <saml> [] is actually a monad
09:47:44 <scopedTV> Eiam: they are related , but still different
09:47:46 <mefisto> Eiam: you said you're in the intro chapter right?
09:47:50 <Eiam> yeah
09:47:55 <Eiam> i actually have to AFK for a few have to go run a meeting
09:48:06 <Eiam> ill re-read and play the the ghci and see if it starts to click
09:48:12 <Eiam> thanks..
09:48:16 <monochrom> pay attention to types
09:48:19 <mefisto> Eiam: there's a lot of things that get introduced conceptually early on that you don't get the tools to fully understand until later
09:48:22 <womb> mam plan
09:48:27 <womb> i have a plan
09:48:31 <womb> weekend on haskell
09:48:35 <womb> what do you think guys ?
09:48:45 <scopedTV> you mean like a hackathon?
09:49:01 <saml> > let a ++ b = a Prelude.++ [b]  in [[1]] ++ [2]
09:49:02 <lambdabot>   Not in scope: `Prelude.++'
09:49:03 <womb> y
09:49:09 <womb> warpathon
09:49:16 <womb> hacking on warp
09:49:42 <monochrom> actually I don't find "append" and "prepend" to be accurate. x++y prepends x to y. b:c appends c to [b].
09:51:10 <jfischoff> does anyone know why my program hangs when compiled but not when run with ghci?
09:51:12 <monochrom> I know how to play word games like "append", "prepend", "glue", "swallow". I know how to twist them to justify anything. precisely why I disdain word games.
09:53:04 <monochrom> because ghci uses the threaded runtime, while the compiled program doesn't
09:55:12 <monochrom> the threaded runtime has this nice extra feature: if all haskell threads are idling, take this chance to run GC. this closes some files and cleans up some other stuff, possibly leading to undeadlocking some deadlocks
09:55:44 <jfischoff> monochrom: thanks I'll add threaded to my compiled program
10:03:53 <kkyqqp> is there a way to divide two integers without changing their type? I'm dealing with two very large numbers where one evenly divides the other, but it seems that when I change their type I get funny rounding errors
10:04:08 <jfischoff> div
10:04:13 <jfischoff> :t div
10:04:13 <lambdabot> forall a. (Integral a) => a -> a -> a
10:04:21 <kkyqqp> oh cool, thanks
10:06:42 <jfischoff> monochrome: worked like a charm. For my purposes a workaround is fine, but for future reference, is there a way to dig in and find what causes the hold up?
10:12:35 * hackagebot intervals 0.2.1.1 - Interval Arithmetic  http://hackage.haskell.org/package/intervals-0.2.1.1 (EdwardKmett)
10:27:35 * hackagebot adjunctions 2.4.0.2 - Adjunctions  http://hackage.haskell.org/package/adjunctions-2.4.0.2 (EdwardKmett)
10:29:36 <endojelly> hi
10:29:41 <endojelly> does this look like a valid state arrow?
10:29:50 <endojelly> it seems to work, but I'm not sure:
10:29:51 <endojelly> data StateArrow s a b = StateArrow {
10:29:51 <endojelly>   fun :: (a, s) -> (b, s)
10:29:51 <endojelly>   }
10:30:42 <parcs`> yeah
10:30:46 <endojelly> for the Category instance, id is just \(a,s) -> (a,s) in fun, and . is just StateArrow { (fun f) . (fun g) }
10:31:05 <endojelly> the reason I'm asking is, examples that I've seen look different
10:31:31 <parcs`> what examples?
10:31:53 <endojelly> just looking for it
10:32:30 <endojelly> something like that (I don't know if this is actually a working example):
10:32:31 <endojelly> newtype StatefulFunc a b = SF { unSF :: a -> (StatefulFunc a b, b) }
10:32:42 <Eduard_Munteanu> You could use Kleisli (State s) I guess.
10:32:52 <endojelly> in any case, I've seen the ... -> (State ... ) pattern quite often
10:33:00 <endojelly> and my StateArrow above has known of that.
10:33:21 <endojelly> but it's fine, yeah? I mean I think it looks fine and should work, but I was wondering if I forgot something, maybe?
10:35:13 <endojelly> parcs`, you think it's okay?
10:35:34 <ClaudiusMaximus> your version requires keeping track of the initial state 's' separately afaict, whereas the unSF version probably partially applies it when you create it, so i think it's safer as you can't inject invalid state (assuming smart constructors)
10:35:52 <ClaudiusMaximus> but i'm very n00b at arrows
10:36:11 <endojelly> ClaudiusMaximus, invalid state? interesting. such as?
10:36:38 <ClaudiusMaximus> endojelly: something that breaks a complicated invariant that isn't expressible easily in the type system
10:36:47 <parcs`> well Kleisli (State s) is just a -> s -> (b, s) which is the curried version of (a, s) -> (b, s).. and that StatefulFunc thing is the Automaton arrow, not a 'State' arrow
10:36:58 <endojelly> I see...
10:37:39 <ClaudiusMaximus> your version requires the state to be the same type throughout, whereas the other version can have it change - so i guess that's a difference too
10:38:23 <endojelly> parcs`, I figured the first part as well, but since I haven't looked at what "Kleisli Arrow" means yet (are Kleisli Arrows essentially monads?), I'm not sure about how Monads and Arrows really tie together, so I feared there was some fundamental difference
10:38:59 <endojelly> ClaudiusMaximus, aaah. yes, that's an interesting difference. (absolutely fine in my case, though: the state's type must stay the same)
10:39:12 <rwbarton> the kleisli construction takes a monad as input and produces an arrow as output
10:40:57 <parcs`> the automaton arrow can be considered a state-like arrow, but with the state internal and unaccessible from the outside
10:41:35 <parcs`> anyway the inventor of arrows uses your definition of a State arrow: http://hackage.haskell.org/packages/archive/arrows/0.4.4.0/doc/html/Control-Arrow-Transformer-State.html#v:elimState
10:41:45 <parcs`> err, scroll up :)
10:41:56 <endojelly> great thanks
10:47:38 * hackagebot scyther-proof 0.4.0 - Automatic generation of Isabelle/HOL correctness proofs for security protocols.  http://hackage.haskell.org/package/scyther-proof-0.4.0 (SimonMeier)
10:57:12 <[1]BillyJoe> I'm a C# programmer and now when Microsoft introduced F# I am getting interested in functional programmring in general. I know this is a strongly biased question, but I still hope for some useful answers :) If I decide to learn F#, what do I miss from Haskell/Lisp/other functional languages? What are the drawbacks/bad parts in F#? (I will use it for software with graphical user interfaces)
10:57:38 * hackagebot meta-par-accelerate 0.3.3 - Support for integrated Accelerate computations within Meta-par.  http://hackage.haskell.org/package/meta-par-accelerate-0.3.3 (RyanNewton)
10:57:43 <c_wraith> F# isn't a bad language. It's closest to the ML family
10:57:59 <acowley> Lumping Haskell and Lisp together makes answering that question rather hard.
10:58:12 <c_wraith> It is most limited by having to work with the C# object hierarchy, which doesn't play especially nicely with type inference
10:58:28 <[1]BillyJoe> c_wraith, I see.
10:58:29 <acowley> If you're doing GUI work and are invested in .NET, F# is almost certainly the right way to go.
10:58:43 <monochrom> you lose lazy evaluation and interesting types. you gain .net
10:58:54 <acowley> You also lose hackage
10:58:56 <parcs`> is f# purely functional+
10:58:58 <parcs`> ?
10:59:00 <acowley> no
10:59:07 <parcs`> ah, you lose that then :)
10:59:14 <c_wraith> No. It has to interoperate with C#, which completely obliterates any hope of that
10:59:18 <monochrom> oh, you also lose software transaction memory
10:59:29 <Saizan> you also lose the interesting module system compared to ML, iirc?
10:59:34 <[1]BillyJoe> acowley, the reason I "lumped them together" is because of my lack of knowledge in the area. And regarding .NET, yes I guess that makes F# the language of my choice.
11:00:13 <acowley> [1]BillyJoe: I understand, but for the sake of clarity, it's best to answer "What do I lose?" separately for your alternatives in the world of functional programming.
11:00:14 <c_wraith> so, yeah.  You lose a lot of interesting and powerful high-end stuff - but it's still not a bad language. It's about the best compromise possible when you're tied to .NET
11:01:06 <[1]BillyJoe> acowley, okay
11:01:31 <acowley> Using F# instead of Lisp means you lose the signal system, the macro system, a very dynamic REPL-driven development experience,  and the flexibility of Lisp's dynamic typing.
11:01:55 <[1]BillyJoe> Assuming I wasn't tied to a specific platform, what language/platform for GUI applications would you recommend?
11:01:59 <cg_morton> is functional programming really the right solution for GUI work?
11:02:11 <acowley> cg_morton: the jury is still out on that one :/
11:02:23 <ezyang> I think reactivity is a good idea.
11:02:38 <ezyang> But reactivity is not pure.
11:02:39 <acowley> [1]BillyJoe: I think F# is arguably the best choice, but Scala is another option.
11:02:48 <monochrom> functional reactive programming may be a right solution for GUI work and many other things. I haven't learned it though.
11:02:52 <Philippa> cg_morton: once upon a time we didn't know the difference between FP and OOP. Sometimes, this is still a good perspective
11:02:59 <[1]BillyJoe> acowley, those terms are new to me, but they go into a text file for later googling
11:03:37 <Philippa> F#'s type inference doesn't behave as pleasantly as languages without subtyping do. That's not a "you can't do stuff in the end product" thing, but it can be highly irritating in a way that doesn't necessarily map to other languages
11:03:43 <monochrom> in any case, there is nothing theoretically better than functional reactive programming yet
11:04:21 <cg_morton> I can see how the callback style relies on first class functions, certainly, but a GUI system is very much a state machine
11:04:37 <acowley> An experience every FRP advocate needs to have is trying to convince a skeptic who is already familiar with standard imperative GUI development that you're not just making things more complicated than they need to be with FRP.
11:04:56 <cg_morton> that is, any callback has to have any data it wants to work on in scope, either through global data or closures, right?
11:05:01 <[1]BillyJoe> I haven't really understood the difference between FP and FRP, but I'm currently trying to find out. Is the "reactive" part what makes the bridge between the functional and the imperative paradigm? Or am I all wrong here?
11:05:24 <acowley> cg_morton: but I can work with infinite streams of states in a functional manner
11:05:35 <cg_morton> I've always been a fan of immediate-mode GUIs anyway
11:05:39 <monochrom> the "reactive" part is about responding to events, not about imperative
11:06:05 <cg_morton> but that's not how .net works is it
11:06:08 <dolio> The reactive part is where people disappear down a rabbit hole and don't do anything productive for a decade. :)
11:06:25 <acowley> dolio: that stung :(
11:06:27 <monochrom> haha that is not very reactive, is it :)
11:07:03 <[1]BillyJoe> monochrom, I see. Well, FRP should be easy to understand on my own so I will drop that specific question for now.
11:07:13 <[1]BillyJoe> cg_morton, there are reactive libraries for .NET
11:07:17 <dolio> Actually people programming robots seem to do well.
11:07:21 * acowley attempts to guard his every coinductive step, but still disappoints the termination checker
11:07:28 <dolio> People making gui frameworks don't.
11:08:07 <conal> [1]BillyJoe: http://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming/1030631#1030631 might help
11:09:12 <cg_morton> the stackoverflow question on F# vs C# says "The advantages of C# are that it's often more accurate to "imperative"-applications (User-interface, ..."
11:09:23 <[1]BillyJoe> conal, I actually just read that, very well written :)
11:09:30 <lamefun2> about FRP, FRP is    function :: Time -> State?
11:10:44 <monochrom> to a large extent, I am unconvinced that "___ is traditionally a state machine" implies "___ needs a state machine, even in FP". historical counterexample: batch-mode computing is traditionally a turing machine, now look at lambda calculus
11:10:47 <conal> lamefun2: Time -> a for any a. (for "classic" frp)
11:11:08 <aristid> dolio: do you mean people programming robots with FRP, or generally?
11:11:17 <conal> aristid: generally
11:11:31 <conal> aristid: oh. nm.
11:11:40 <[1]BillyJoe> conal, I admit there are a few terms (like denotational semantics) that I am unfamillar with, but I think I get the most of it. However, I didn't really understand which things fall into the F and which fall into the R paradigm.
11:12:04 <aristid> conal: now i'm confused
11:12:21 <conal> [1]BillyJoe: the name "FRP" is an unfortunate choice. "continuous denotative temporal programming" is more descriptive.
11:12:36 <aristid> conal: you didn't talk about robots before, did you? or were you answering for dolio :P
11:12:45 <acowley> dolio: were you referring to my recent streaming work with robotics, or more like the early arrows papers?
11:13:45 <conal> aristid: i accidentally answered you
11:13:55 <acowley> I wish roboticists were more into FRP or at least its moral cousins
11:14:53 <byorgey> acowley: my impression is that many of your papers are of the form "I wish roboticists were more into X", for various awesome values of X
11:15:13 <acowley> byorgey: forall X in {things acowley wants to work on}
11:15:22 <lamefun2> hm. and how's  function :: State -> TimeInterval -> State called?
11:15:26 <[1]BillyJoe> conal, so FRP is not really using F and R together? I think I understand "continuous denotative temporal programming", it's like passing a wristwatch to a function instead of repeatingly passing "09:00:00", and then "09:00:01" etc.
11:15:45 <byorgey> acowley: wait, but don't you want to work on robots too?
11:15:59 <byorgey> or do you also wish roboticists were more into robots
11:16:21 <acowley> byorgey: It's actually cyclic for me. In the course of doing normal work I come to hate the tools available, so I patch together something ad hoc to help me. Then the next half of the cycle is me wishing other people shared my frustrations.
11:16:23 <aristid> byorgey: not impossible
11:16:35 <monochrom> conal would say "I wish functional programmers were more into functional programming" :)
11:16:57 <acowley> conal would also work the word denotative into his sentiment
11:16:58 <conal> monochrom: hah! you got that right. :)
11:17:01 <byorgey> acowley: hehe, that actually sounds quite reasonable =)
11:18:02 <byorgey> forall F in fields. exists p in F. p wishes Fers were more into F
11:18:04 <acowley> byorgey: My issue is that most people just accept their tools. I had a really interesting talk with a colleague a while ago where he (a happy C++ user) said something like, "I never really think about a programming language. It's just the tool I have."
11:18:08 <lamefun2> how does FRP deal with unpredictable events, like user input?
11:18:26 <conal> [1]BillyJoe: when people try to understand "FRP" as descriptive of FRP (rather than just a name), they often think they understand it when they don't. Moreover, "functional" is such a fuzzy notion, in contrast to "denotative".
11:18:56 <monochrom> extremely smart people tend not to get frustrated by bad tools and bad methods. their smartness overcome the bad tools with trivial ease. they also think that it is the same for everyone else, so they tend to say "what's the problem?"
11:19:00 <conal> lamefun2: by not trying to predict them.
11:19:09 <byorgey> acowley: sounds reasonable.  I mean, I never really think about my shoes.  They're just what's on my feet.  Cardboard, leather, spiky nails, doesn't really matter
11:19:30 <acowley> byorgey: Exactly, but you benefit from the existence of people who do think about shoes.
11:20:00 <byorgey> acowley: I was joking, but of course you're right =)
11:20:06 <acowley> monochrom: I disagree with that approximately 102%
11:20:53 <[1]BillyJoe> conal, I see.
11:21:10 <monochrom> well then, you have another explanation of why your colleagues happily embrace poor tools such as C++?
11:21:35 <acowley> monochrom: they've never even heard of functional programming
11:21:55 <aristid> monochrom: maybe they're not extremely smart?
11:22:36 <proq> aristid: possibly, or they just haven't gotten around to discovering/reading about it
11:22:58 <monochrom> I don't believe it matters. whether they have heard of alternatives or not, they can still think "there ought to be a better way" if they choose to.
11:23:07 <aristid> or maybe even extremely smart people can be ignorant in some areas
11:23:21 <cg_morton> when all you've got is a C++, you don't -have- to go looking for other tools, because it really can be used for any problem you encounter
11:23:41 <proq> they eventually end up implementing their own dialect over c++
11:23:59 <Nimatek> C++ while being ugly has improved a bit. Boost and all.
11:24:03 <[1]BillyJoe> If anyone have some good book/article recommendations about FRP in WPF, I'd be happy to know :) (But I guess such a book/article will be in F# and not Haskell...)
11:24:32 <aristid> [1]BillyJoe: i think haskell is used in way more articles and papers than F#
11:24:32 <proq> boost being a contender for dialect
11:25:00 <[1]BillyJoe> aristid, even in combination with WPF?
11:25:08 <monochrom> I mean, after all, John Backus did not heard of FP either
11:25:41 <aristid> [1]BillyJoe: what's WPF?
11:25:43 <cg_morton> C++ is a language that you don't start to question until you have to work with other people.  If you're just writing your own C++ code it can be pretty elegant
11:27:01 <parcs`> acowley: you have to draw the line somewhere. do you expect people to think about every single tool they're using?
11:27:14 <cg_morton> Javascript's the same way.  Smart people started using them for expressiveness and power, but then a lot of other less smart people came and showed just how precarious the balance was
11:27:16 <acowley> monochrom: Backus is a perfect example of why I disagree with you, though.
11:28:06 <acowley> parcs`: Not constantly, no.
11:28:07 <[1]BillyJoe> aristid, Windows Presentation Framework. It's Microsofts newest framework for graphical user interfaces. After reading your replies to my earlier question, I decided to ask in here because an answer from you guys might be a lot more useful than an answer from the Microsoft community itself I believe.
11:28:11 <monochrom> well, of course, I only say "tend to". among the smart people, 1% see problems with the status quo, 99% don't.
11:28:31 <acowley> monochrom: Backus invented the "first" high-level language and new methods for doing that work.
11:28:38 <aristid> parcs`: one might think that the programming language is a tool that _requires_ thinking about it even to be used
11:28:38 <proq> cg_morton: although c++ does make abuse very easy, other languages like obj-c also make it pretty easy
11:29:19 <aristid> [1]BillyJoe: oh. well then yes, it would probably be C# or F#
11:29:25 <acowley> monochrom: the only way you can say he overcame crummy tools through intelligence is by developing new tools
11:29:27 <aristid> [1]BillyJoe: assuming that even exists
11:30:33 <acowley> parcs`: I don't think anyone should constantly worry about their programming language, but I do think we all become blind to gross inefficiences in our work habits.
11:31:09 <[1]BillyJoe> aristid, true. I know there are reactive libraries that I will try to learn, and there is F#, but I don't know if they play well together for FRP.
11:31:26 <aristid> [1]BillyJoe: are you tied to F#?
11:31:37 <acowley> parcs`: The question is if you at some point notice the problem, and can see a way to improve things. Then you will go around trying to convince people to use your hammer invention to whack nails rather than the wet sponges they've grown used to employing.
11:32:18 <aristid> [1]BillyJoe: if you only want to _learn_ what FRP is, then i think the abundance of FRP libraries for haskell make it a better choice
11:32:40 <[1]BillyJoe> aristid, I don't even use it yet. But I am tied to WPF (tied in the sense that I know it). So I want to learn FRP in combination with WPF (if even possible)
11:33:50 <aristid> [1]BillyJoe: google finds this: http://lambda-the-ultimate.org/node/2906
11:33:59 <aristid> [1]BillyJoe: but... i'm not sure how good that is
11:36:12 <[1]BillyJoe> aristid, I'm reading to find out, thx :)
11:39:48 <HugoDaniel> i always get over excited when trying to explain to someone that haskell is the language of the future
11:40:20 <monochrom> that is unhealthy
11:40:43 <HugoDaniel> i know
11:40:45 <HugoDaniel> sucks
11:41:16 <acowley> It can be endearing, too. So you've got that.
11:41:40 <monochrom> "language of today" is better
11:42:59 <aristid> one would sure hope that a language better than haskell is the future
11:43:00 <c_wraith> Language of 20 years ago
11:43:13 <c_wraith> as opposed to C, which is the language of 40 years ago
11:43:24 <aristid> > 2012-1970
11:43:25 <lambdabot>   42
11:43:51 <aristid> those pesky numbers. thanks lambdabot
11:44:00 <c_wraith> you doubted me? :P
11:44:10 <otters> what's wrong with haskell ;P
11:44:22 <c_wraith> lots of stuff!
11:44:29 <aristid> c_wraith: i would never doubt you
11:44:43 <c_wraith> aristid: that's a bigger mistake than doubting me there :)
11:44:43 <lcfrs> Is there an option to build a smaller ghc? I tried messing around with mk/build.mk, but I'm not sure what flags to set. For example, I
11:44:43 <monochrom> what's wrong with haskell: just a programming language, not mathematics
11:45:02 <lcfrs> For example, I'd like to omit the interpreter and profiler.
11:45:18 <aristid> lcfrs: why?
11:45:57 <monochrom> there is probably a way to omit the interpreter
11:46:02 <byorgey> lcfrs: you can also try asking in #ghc
11:46:18 <conal> [1]BillyJoe: historical oddity: as i understand, WPF came out of FRP. the first instance of FRP was ActiveVRML, later renamed & reworked into DirectAnimation, and some of the key ActiveVRML/DirectAnimation folks (but not I) morphed it into WPF.
11:47:31 <aristid> conal: you were an ActiveVRML/DirectAnimation core folk?
11:47:42 * hackagebot profunctor-extras 0.3.2.3 - Profunctor extras  http://hackage.haskell.org/package/profunctor-extras-0.3.2.3 (EdwardKmett)
11:48:19 <conal> aristid: yeah. i designed ActiveVRML, which then renamed & reworked into DirectAnimation.
11:48:40 <aristid> conal: do you like how WPF ended up being?
11:50:43 <conal> aristid: as the product folks moved away from the original purely functional design (evolved from TBAG), I looked around and found haskell and reimplemented the design there. i called that system "RBMH" for "reactive behavior modeling in haskell", which was renamed "fran" as suggested by paul hudak.
11:51:10 <[1]BillyJoe> conal, that could be the case, I have no idea. Interesting if it is like that tough.
11:51:46 <conal> aristid: i disliked each of the steps away from the original denotative/functional design.
11:53:18 <conal> aristid: first it got wrapped in a COM/OO interface, and then the fine grain combinators got chunked up in fear of garbage collection, and then it got stateful.
11:53:22 <acowley> conal: do you have much contact with the folks at MS doing Rx?
11:53:49 <conal> acowley: not lately.
11:53:56 <aristid> conal: ah, so a combination of "it got to be more OOP" and "our garbage collector isn't good enough" made it so?
11:54:29 <aristid> acowley: what's Rx?
11:55:19 <conal> aristid: yeah. and maybe the twin goals of having it be a marked advancement *and* palatable to mainstream programmers.
11:55:25 <acowley> I think some of that is, arguably, pragmatics. Similar to how we talk about "falling back to" imperative programming techniques in Haskell if we don't yet know how to do things efficiently and purely.
11:55:40 <acowley> aristid: http://msdn.microsoft.com/en-us/data/gg577609
11:56:18 <conal> acowley: i like pragmatics a lot. as long as they don't interfere with ideals. and with progress.
11:56:50 <[1]BillyJoe> Microsoft improved the data binding and introduced the declarative XAML language with WPF, and later introduced LINQ in C#/VB.Net as well as a new language, F#. Maybe there is a long-time plan to gradually move away from the imperative paradigm without shocking the community?
11:57:21 <aristid> [1]BillyJoe: i doubt there is such a thing as a coherent, single plan
11:57:23 <conal> for instance, i see the imperative programming model as deeply unpragmatic, because it's too hard to program massively parallel machines correctly in that model.
11:57:29 <acowley> conal: And I have the utmost respect for that, but many (most?) are willing to trade some ideals for pragmatics. My career is essentially built around pragmatics interfering with progress, so you're preaching to the choir there :P
11:58:40 <[1]BillyJoe> aristid, well I'm just guessing of course, but I have thought about it earlier. Maybe...
11:58:40 <conal> acowley: yeah. most are willing to trade away their ideals rather than work hard on finding pragmatic+ideal
11:58:56 <conal> acowley: ... solutions.
11:59:04 <aristid> [1]BillyJoe: just remember that microsoft is not a single person
11:59:05 <lcfrs> aristid: I'm putting ghc on heroku and it has a 100MB limit
11:59:08 <lcfrs> byorgey: thanks!
11:59:18 <aristid> [1]BillyJoe: there are many people there with different goals and agendas
11:59:40 <aristid> lcfrs: how about compiling it outside heroku and sending the binaries there?
11:59:50 <[1]BillyJoe> aristid, true.
11:59:57 <lcfrs> thanks another way
11:59:59 <aristid> lcfrs: ghc can produce binaries with very few dependencies
12:00:02 <conal> often, though, myopic solutions are called "pragmatic" when they're not, since they cause practical problems.
12:00:17 <lcfrs> it's just most of the other buildpacks work by way of compiling it on the machine
12:00:24 <acowley> conal: idealistic solutions can also be myopic
12:00:26 <conal> so "ideal-vs-pragmatic" is a false dichotomy.
12:00:37 <aristid> [1]BillyJoe: and i doubt that high-level management at microsoft is familiar with functional programming
12:01:07 <conal> acowley: "idealistic" yes. when it means ignoring part of the essence of the problem.
12:02:15 <JoeyA> Ugh, HJavaScript doesn't parenthesize arithmetic expressions.  JBinOp (JInt 2) Times (JBinOp (JInt 3) Plus (JInt 4)) renders as "2 * 3 + 4;"
12:02:41 <conal> JoeyA: ouch! :(
12:02:48 <JoeyA> I'd submit a bug report, but there's no tracker link.
12:02:56 <conal> JoeyA: sadly haskell-src-exts also doesn't.
12:03:16 <conal> has anyone made an auto parenthesizer for haskell-src-exts?
12:03:24 <JoeyA> Then how are you supposed to represent such expressions?  Is there a paren constructor or something?
12:03:25 <acowley> conal: I think FRP with GUIs is a good example of this, though. We too often see cherry-picked examples where the FRP approach shines, but it is a struggle to replicate all the capabilities mainstream programmers enjoy.
12:03:53 <conal> acowley: good example of what?
12:04:56 <JoeyA> In any case, automatic parenthesizing isn't that hard; just do what showsPrec does.
12:05:03 <[1]BillyJoe> conal, Isn't pragmatism in this context often interpreted as "what concepts concepts are widely known/used by developers" rather than analying the concept itself?
12:05:16 <acowley> conal: the fact that the separation between idealism vs pragmatism is very hard to distinguish, and almost entirely subjective.
12:05:17 <conal> i agree that it's often difficult to come up with denotative ("genuinely functional") formulations of things. because doing so requires really understanding them.
12:05:18 <aristid> JoeyA: or put parens everywhere.
12:06:09 <conal> [1]BillyJoe: I don't know. now you have me wondering. there might be a surprisingly broad range of intentions behind those labels.
12:06:44 <acowley> [1]BillyJoe: there are mundane engineering considerations, too. Performance concerns and deadlines often drive a wedge into clean designs.
12:07:31 <aristid> acowley: things like "we can't have many small objects, or our garbage collector will choke"?
12:07:33 <[1]BillyJoe> aristid, that is above my knowledge. However, Anders Hejlsberg (who designed C#) probably doesn't take any big steps in that direction. He doesn't even like AOP.
12:07:36 <conal> acowley: is it? hm. i wouldn't have guessed that interpretation. i've been assuming it's just difficult and we haven't figured it out yet.
12:07:46 <aristid> [1]BillyJoe: who likes AOP.
12:07:58 <acowley> conal: I think that is compatible with what I said.
12:08:39 <acowley> conal: If we haven't figured it out yet, and this gross hack lets us limp across the finish line before the race is lost….
12:09:23 <conal> acowley: what race?
12:09:28 <acowley> That's basically how a lot of engineering goes. Success stories are when you realize the gross hack was divine inspiration after the fact :)
12:09:36 <acowley> conal: to beat a deadline
12:10:12 <[1]BillyJoe> aristid, maybe you don't need AOP with Haskell? I think you would like AOP in C# though. I do.
12:10:23 <acowley> I speak in a language that is poetry to my ears only. To confusion, this leads.
12:10:48 <conal> acowley: oh. i don't mind at all if you keep doing your gross hacks. or if others do. i'm just glad that a few people are still working toward the origial vision of denotative programming.
12:10:53 <conal> (original)
12:11:34 <apfelmus> Good evening.
12:11:43 <conal> apfelmus: howdy!
12:11:52 <acowley> conal: Yes, that is what I agree with. It goes back to Brent saying how he wears shoes every day but never really thinks about them, but it's good for everyone if some people do think about shoes.
12:11:57 <apfelmus> Hey Conal. :)
12:12:05 <nand`> X11 is a binding for Xlib; but is there a binding for xcb (which is supposed to deprecate Xlib)?
12:12:21 <aristid> hi apfelmus
12:12:25 <Clint> nand`: there's some "experimental" code somewhere
12:12:26 <acowley> apfelmus: Has anyone made any good suggestions regarding your HP compatibility issues?
12:12:37 <aristid> apfelmus: turns out the topic is frp and idealism right now :>
12:12:51 <apfelmus> aristid: Hehe.
12:13:04 <nand`> Clint: okay; so nothing solid yet I take it?
12:13:12 <apfelmus> acowley: Not that I know of.
12:14:02 <eacameron> Is there a way to count the number of elements in a list that meet criteria `f` without doing `(length . filter f) list` ?
12:14:21 <conal> eacameron: why wouldn't you want to use length . filter f ?
12:14:37 <Clint> nand`: http://cgit.freedesktop.org/xcb/xhsb/
12:14:39 <eacameron> conal: because I don't want to construct a list, I just want the length
12:15:02 <eacameron> conal: does laziness accomplish that implicitly?
12:15:06 <conal> eacameron: don't worry. that's the compiler's job.
12:15:10 <geekosaur> nand`. there's xhb on hackage
12:15:37 <eacameron> conal: cool. it's weird letting the compiler do so much for me... I haven't fully trusted it yet ;)
12:15:49 <conal> eacameron: laziness + gc means only a small part of the list will exist at any time. compiler fusion means not even that small part will exist.
12:16:23 <eacameron> conal: nice!
12:16:23 <nand`> Clint: no commits since 2006, excellent
12:16:34 <nand`> geekosaur: looks neat, thanks
12:16:38 <conal> eacameron: yep. it's a big shift. feel the fear and jump! good luck.
12:16:48 <Clint> huh
12:17:03 <kallisti> edwardk: to what degree do INLINE pragmas actually matter?
12:17:11 <JoeyA> I didn't even know git and xcb have been around that long.
12:17:14 <acowley> apfelmus: If I had a vote I'd say you should track the current GHC rather than the platform since wx isn't included in the HP, and its releases are so infrequent. Though I admit that's not the most helpful thing for newcomers.
12:17:14 <kallisti> I imagine it has more of an effect in -O than -O2
12:17:37 <hpaste> lamefun pasted “Why doesn't this comple, parse error on t?” at http://hpaste.org/68394
12:17:42 <lamefun2> why?
12:18:13 <JoeyA> lamefun2: microbeBehaviour = \t ->
12:18:31 <JoeyA> You can't use function-style patterns in record definitions.
12:18:50 <kallisti> hm, but it would be neat if you could. :D
12:18:59 <JoeyA> You can use RecordWildCards to get a similar effect
12:19:10 <JoeyA> stupidMicrobe (x, y) = Microbe {..} where
12:19:17 <JoeyA>    microbeBehaviour t = ...
12:19:30 <apfelmus> acowley: Well, the issue is even more complicated than that. The problem is actually this: if you use wx-0.13 or wx-0.90 or less with wxWidgets 2.9.3, then there is a bug that will crash a few of the reactive-banana-wx examples.
12:20:12 <apfelmus> acowley: That's why I'm restricting the dependency to wx-0.12 because that requires wxWidgets 2.8. But unfortunately, that only works with GHC-7.0, not with GHC-7.4.
12:20:21 <acowley> apfelmus: Ugh, what a mess.
12:20:48 <acowley> apfelmus: I ran into the problem because I needed a newer wxWidgets, and found that reactive-banana wouldn't work for me.
12:21:11 <conal> apfelmus: do you know of a simple & robust way to install wx on a mac? i still haven't succeeded.
12:21:28 * kallisti is tempted to rewrite getDirectoryContents using unsafeInterleaveIO
12:21:50 <apfelmus> conal: Ah, you had the problem with QuickTime, right?
12:21:57 <conal> apfelmus: yeah.
12:22:09 <kallisti> my test on recursively traversing my home directory results in a big slow-down on a particularly large directory.
12:22:26 <kallisti> where a lot of memory is allocated for the result list of getDirectoryContents.
12:22:33 <kallisti> I'm thinking if it were lazy this would disappear.
12:22:51 <acowley> conal: brew installed the latest wx for me with the --development (or something like that) flag. I think it worked okay, but not with reactive-banana of course.
12:22:56 <jonaskoelker> I want to say something like "if ("-h" `elem` options) usage();" in IO.  How do I do that most idiomatically?
12:23:07 <kallisti> :t when
12:23:08 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
12:23:16 <apfelmus> acowley: Ah, yeah. In fact, I even fixed the bugs relating to wxWidgets 2.9.3, but Jeremy tends to have long streaks of having no time to do anything.
12:23:23 <kallisti> when ("-h" `elem` options) usage
12:23:28 <conal> acowley: glad to know. thx. i've heard mixed results with brew.
12:23:29 <jonaskoelker> neato, thanks :)
12:23:35 <kallisti> (that's in Control.Monad btw)
12:23:50 <apfelmus> conal: That's a tough one. Basically, QuickTIme is a 32bit library. The only way I see is to build everything in 32bit, i.e. both your Haskell libraries and wxWidgets.
12:24:13 <jonaskoelker> for which I guess there's an extensive and elucidating manual? ;)
12:24:29 <conal> apfelmus: drag. and do you think i'd even use QT or just that it's hard to remove?
12:24:30 <ClaudiusMaximus> jonaskoelker: i guess you might also want exitSuccess at the end of your usage action, from System.Exit (iirc)
12:25:01 <aristid> apfelmus: if quicktime is 32bit, does apple give an alternative for 64-bit programs?
12:25:34 <edwardk> kallisti: INLINE is important when you have something like foldl where you want the inlining to be used on the wrapper to exploit extra strictness information for your fold, for instance.
12:25:40 <apfelmus> conal: You probably won't use it, but wxc and wxcore probably have references to it in case you would use it. I don't know how to remove them or even if they are there.
12:26:03 <jonaskoelker> ClaudiusMaximus: I have exitWith ExitSuccess
12:26:04 <conal> apfelmus: thx.
12:26:10 <edwardk> kallisti: it also makes orders of magnitude worth of difference in the performance of things like vector-algorithms, because it allows a LOT of stuff to stay unboxed, otherwise you wind up with a ton of boxed comparisons, etc.
12:26:30 <apfelmus> aristid: Yes, their new QuickTime X framework. It's not feature-complete, though, that's why they keep the old QuickTime around.
12:27:00 <aristid> apfelmus: oO
12:27:27 <kallisti> edwardk: neither of those examples seem to match my usage here: https://github.com/kallisti-dev/cond/blob/master/src/Control/Conditional.hs
12:27:30 <kallisti> so it probably isn't necessary.
12:27:37 <kallisti> but I'll leave it because it can't hurt either. :P
12:27:44 <apfelmus> conal: np :)
12:28:12 <apfelmus> acowley: If you really want to try reactive-banana, you can use the latest source versions.
12:28:14 <apfelmus> acowley:  https://github.com/HeinrichApfelmus/reactive-banana/tree/release-0.6.0.0
12:28:25 <[1]BillyJoe> Why are imperative language much more used than functional? I think there might be some interesting answers to that question, maybe related to ignorance, universities teaching what they consider to be "standard languages" and big companies supporting specific languages?
12:28:41 <apfelmus> acowley: and https://github.com/jodonoghue/wxHaskell
12:29:31 <wli> Outgrowths of macro assembler, 70's and earlier singlepass compilation, etc.
12:29:40 <acowley> apfelmus: do I need wxHaskell from the repo or is the latest from hackage okay? As I understand it, the hackage releases switched to wxWidgets 2.9
12:29:44 <ezyang> Hmm, I wonder if there's a way to make Pandoc explicitly render URLs when outputting to PDF.
12:29:45 <jonaskoelker> [1]BillyJoe: what you're saying is basically inertia, right?
12:29:52 <ezyang> like, as footnotes or something.
12:30:04 <jonaskoelker> I think that might be reasonable, although if FP lives up to its promises I'd expect the general consensus to shift
12:30:39 <nand`> Could one define an algorithm as a proof for a type?
12:30:40 <apfelmus> acowley: The latest version from the repo is also 2.9.3. Additionally, it contains my bug fixes for the reactive-banana-wx examples. Oh, and you can use wx from GHCi on Mac OS X without the annoying EnableGUI thing.
12:30:53 <kallisti> oh also this library now has a typeclass for boolean algebras, but my lack of theory knowledge probably means there's something lacking in it.
12:31:21 <wli> Nothing will change radically or completely. Imperative languages are here to stay indefinitely.
12:31:36 <acowley> apfelmus: Okay, I will give them a shot, thanks!
12:31:54 <apfelmus> acowley: My pleasure. :) Let me know if there are any problems.
12:31:55 <kallisti> wli: sure. I don't think that's too surprising.
12:32:10 <[1]BillyJoe> jonaskoelker, I would say "intertia" if FP hadn't been around for decades already. However, perhaps FP gets more and more useful when systems get more complex? In that case, the intertia argument would hold.
12:32:39 <kallisti> a think a smaller population of users means slower inertia.
12:32:45 <kallisti> *I
12:32:58 <apfelmus> acowley: I would love to release reactive-banana 0.6.0.0 on hackage right now, but I don't feel very good doing that without the bug fixes from wxHaskell.
12:33:00 <jonaskoelker> [1]BillyJoe: I think so wrt. complexity, but perhaps the biggest win is parallelism
12:33:11 <cg_morton> it's because functional programming is math, and most people hate math
12:33:22 <jonaskoelker> cg_morton: very prosaic, pithy and likely to be true
12:33:23 <jonaskoelker> =)
12:33:31 <acowley> apfelmus: Would jodonoghue let you push a new wxHaskell to hackage?
12:33:42 <acowley> apfelmus: Just as a patch release
12:33:46 <kallisti> edwardk: I was told I could split the Boolean typeclass into a Heyting algebra superclass, but I'm not sure what that entails.
12:34:03 <edwardk> kallisti: you remove ~ and add relative pseudocomplement
12:34:19 <jonaskoelker> "I was told I could split the Boolean typeclass into a Heyting algebra superclass, but I'm not sure what that entails." <--- why I love the FP community
12:34:27 <kallisti> oh. that sounds simple enough. as soon as I learn what relative pseudocomplement is.
12:34:27 <apfelmus> acowley: He said he wanted to test it on Windows and then release it himself. That were the last words I heard from him. ;)
12:34:32 <[1]BillyJoe> kallisti, you mean that since there are few users, it is spreading slowly? Well, I don't know if it is spreading, but that could be true.
12:34:47 <edwardk> kallisti: its not that bad actually =)
12:34:56 <acowley> apfelmus: famous last words :P
12:34:57 <kallisti> [1]BillyJoe: yes I mean that the small number of users results in a relatively slower growth of tools,
12:35:13 <apfelmus> acowley: Hehe, indeed. "Let me just test this on Windows.."
12:35:14 <edwardk> kallisti: basically what you lose is the not (not a) = a property, though you can ensure that not (not (not a)) = not a
12:35:43 <kallisti> edwardk: is "not" in this context the pseudcomplement thing?
12:35:47 <edwardk> kallisti: yes
12:35:57 <aristid> edwardk: and not (not (not (not a)) = not (not a)) presumably?
12:36:07 <edwardk> aristid; yeah that follows from the former
12:36:46 <jonaskoelker> so you can remove 2*not as long as there's a third (or fifth, seventh, (2*n+1)th) underneath
12:36:51 <kallisti> but really this is all lattices, hm. Another topic I need to learn.
12:37:06 <aristid> edwardk: oh of course. :D should have seen that
12:37:12 <edwardk> jonaskoelker: yeah, you can't get it out of the last one.
12:37:28 <kallisti> but it looks like there's a lot of overlap in operations, to the point that subclasses might not even define new methods, but instead just have new laws.
12:37:29 <jonaskoelker> sneaky... when do you want that?
12:37:35 <edwardk> kallisti: types in haskell form a heyting algebra-like construction through the curry-howard correspondence
12:38:06 <edwardk> in particular. consider type Not a = a -> forall b. b
12:38:12 <edwardk> or type Not a = a -> Void
12:38:20 <edwardk> @djinn-env
12:38:21 <lambdabot> data () = ()
12:38:21 <lambdabot> data Either a b = Left a | Right b
12:38:21 <lambdabot> data Maybe a = Nothing | Just a
12:38:21 <lambdabot> data Bool = False | True
12:38:21 <lambdabot> data Void
12:38:23 <lambdabot> type Not x = x -> Void
12:38:25 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
12:38:26 <lambdabot> class Eq a where (==) :: a -> a -> Bool
12:38:30 <edwardk> @djinn Not (Not a) -> Not a
12:38:30 <lambdabot> -- f cannot be realized.
12:38:31 <dbpatterson> Lemmih: wierd behavior with acid-state - a bunch of state disappeared on a restart of the application, but the events still exist in the log files. Is there any way to get debugging info, or otherwise figure out why this is happening?
12:38:34 <[1]BillyJoe> cg_morton, good point about math. I remember how many friends hated math in school, and being interested in something is a key factor to success.
12:38:35 <edwardk> @djinn Not (Not a) -> a
12:38:35 <lambdabot> -- f cannot be realized.
12:38:41 <edwardk> @djinn Not (Not (Not a)) -> Not a
12:38:41 <lambdabot> f a b = void (a (\ c -> c b))
12:38:44 <edwardk> there you go
12:39:20 <kallisti> edwardk: so a boolean algebra is just a 2-element bounded lattice?
12:39:25 <edwardk> given forall r. (a -> r) -> r you can't 'get the a out'
12:39:26 <edwardk> no
12:40:08 <jonaskoelker> kallisti: it could be a 2^n-element lattice
12:40:10 <Eduard_Munteanu> kallisti: boolean algebras aren't required to have only 2 elements
12:40:13 <aristid> edwardk: you're explicitly ignoring bottoms, right? :P
12:40:13 <edwardk> where did you get the assumption of two elements from? the data Bool data type has 2 elements, but its not necessary that you only have 0 or 1
12:40:17 <edwardk> aristid: no
12:40:33 <kallisti> edwardk: my lack of familiarity with any other boolean algebras.
12:40:38 <jonaskoelker> or (freakier) 2^(number of real numbers)-element lattic
12:40:56 <edwardk> aristid: the rules of a boolean algebra work when you apply them to Word, using bitwise or and and and choosing 0 as 0 and 1 as maxBound :: Word
12:41:02 <jonaskoelker> kallisti: there's an interesting theorem that says they're all basically a vector of 2-element boolean algebras
12:41:42 <jonaskoelker> (for some value of `vector')
12:41:46 <aristid> edwardk: how does that relate to my question?
12:41:52 <edwardk> jonaskoelker: yeah though the encoding of them in that fashion may be prohibitively expensive
12:42:11 <jonaskoelker> edwardk: i.e. as a [Bool]?
12:42:27 <aristid> edwardk: you can solve any type in haskell by just using general recursion, so the whole Not a thing seems rather pointless to me
12:42:33 <edwardk> aristid: i think i meant to reply to kallisti
12:42:38 <jonaskoelker> edwardk: or do you have a cost model for subsets of arbitrary sets? :-)
12:42:59 <edwardk> jonaskoelker: well, there is nothing stating that said vector space is finite dimensional, etc.
12:43:09 <edwardk> so you may have a pretty big space to tangle with
12:43:18 <Clint> how do i tell `cabal install` in a source tree to stop believing the dependency info from hackage and just cope with what's already installed?
12:43:37 <jonaskoelker> ah, yeah, okay.  Infinite(ly complex) data structures and kinda' hard to deal with
12:43:53 <kallisti> Clint: you can't. you'd have to fetch the package by source, change the cabal file by hand, and install that.
12:44:07 <jonaskoelker> I'm sure regular languages (can be made to) form a boolean algebra
12:44:12 <kallisti> Clint: caveat: make sure you know what you're doing.
12:44:24 <Clint> kallisti: er, the modified dependency is already installed
12:44:45 <edwardk> aristid: i actually find it to be quite useful as a reasoning tool. a lot of the codensity monad constructions look a lot like working in negated form
12:44:50 <ClaudiusMaximus> kallisti: have you seen my http://hackage.haskell.org/packages/archive/bitwise/0.1/doc/html/Data-Bits-Bitwise.html ?
12:45:03 <dcoutts> Clint: you can add installed constraints, e.g. --constraint='foo installed'
12:45:21 <aristid> edwardk: why not use, say, agda or epigram or coq for that?
12:45:26 <kallisti> ClaudiusMaximus: I haven't
12:45:38 <dcoutts> Clint: mind you it's not guaranteed to work. There are legit reasons it sometimes needs to rebuild things.
12:45:43 <edwardk> aristid: because i like actually having code compile in my lifetime, and i use codensity in production code
12:46:02 <kallisti> ClaudiusMaximus: looks nice
12:46:11 <edwardk> aristid: it improves the asymptotic performance of my code in a number of places and is a trivial addition once you have the right semantics
12:46:17 <Eduard_Munteanu> edwardk: b-b-but Agda also compiles to JS, so you can be all Web and hip and... :P
12:46:28 <kallisti> so "true" is top, "false" is bottom.
12:46:39 <edwardk> Eduard_Munteanu: agda running on js is evaluated strictly, so we go back to waiting for the universe to end when you abuse 'if'
12:46:40 <ClaudiusMaximus> kallisti: let me know if you have any suggestions, i do need to work on the package at some point to add useful instances (Eq, Ord, ...) to the array parts
12:46:50 <aristid> edwardk: but the reasoning needs to take place in your head, because haskell can't verify it, right?
12:46:50 <edwardk> kallisti: yep
12:46:52 <Clint> dcoutts: it's saying "cabal: dependency expected"
12:46:59 <Eduard_Munteanu> Heh, I never actually tried it.
12:47:15 <dcoutts> Clint: oh, that syntax is only valid in cabal-install-0.14+
12:47:22 <Clint> ah
12:47:25 <Clint> oh well, thanks
12:47:26 <edwardk> aristid: actually the heyting like reasoning i mentioned above is exact, because types form a constructive logic through the curry howard correspondence. so nothing is lost there
12:47:58 <edwardk> aristid: i can't provide a monad law here or there, but the reasoning we're talking about right now works fine
12:48:32 <edwardk> and the types are sufficiently polymorphic that the free theorems are very strong regardless
12:48:39 <jonaskoelker> food >>= stove >>= me
12:48:56 <dcoutts> Clint: otherwise you need to bump the version to indicate that it's really different from the source version
12:50:03 <lamefun2> has FRP been used in something complex already?
12:50:32 <edwardk> i write code in agda when i'm fishing for what the correct construction is and i have few guidelines other than laws and a guess at a shape. i write it in haskell when i have a pretty good idea what i want and the types are polymorphic enough that it'd be nigh impossible to get wrong code to compile at all without it being glaringly unsafeCoerced/undefined ;)
12:50:49 <edwardk> or when i just want to get it done
12:51:12 <Eduard_Munteanu> lamefun2: HXT is a bit FRP-ish
12:51:38 <cg_morton> "i write code in agda" <- crazy person
12:52:06 <Clint> dcoutts: oh, i can do that
12:52:08 <Eduard_Munteanu> Yeah, that's like saying you write proofs in C. :P
12:52:29 <dcoutts> Clint: upgrading cabal-install is also easy
12:53:28 <Clint> dcoutts: i thought it didn't work with ghc 7.4 yet
12:53:47 <dcoutts> Clint: cabal install 'cabal-install >= 0.14'
12:54:07 <dcoutts> Clint: you're thinking of the previous release, 0.10.x
12:55:03 <Clint> ah
12:56:44 <kallisti> edwardk: what is logical implication and biconditional in the context of a Bits instance?
12:57:17 <kallisti> comeplemtn p .|. q  and complement (p `xor` q) ?
12:57:21 <kallisti> *complement
12:57:23 <kallisti> or is there a better way?
12:57:35 <Eduard_Munteanu> I guess the implication for a Heyting algebra?
12:57:36 <edwardk> not off hand
12:57:44 * hackagebot comonads-fd 2.1.1.2 - Comonad transformers using functional dependencies  http://hackage.haskell.org/package/comonads-fd-2.1.1.2 (EdwardKmett)
12:57:46 * hackagebot comonad-extras 2.1.1.2 - Comonad transformers requiring extensions to Haskell 98  http://hackage.haskell.org/package/comonad-extras-2.1.1.2 (EdwardKmett)
12:58:25 <parcs`> when are you supposed to free a FunPtr that's being used as a finalizer of a ForeignPtr?
12:58:39 * parcs` doesn't like this FunPtr business
12:59:02 <edwardk> parcs`: you can always free it in the finalizer
13:00:27 <kallisti> I wonder what I should call this newtype.
13:00:49 <kallisti> instance Bits a => Boolean (??? a) where ...
13:01:36 <JoeyA> Flippant?
13:01:53 <JoeyA> What is the Boolean class?
13:02:06 <kallisti> Boolean algebra.
13:02:08 <edwardk> kallisti: NB: because Bits was designed in a haphazard manner you can't make Bits a superclass if you want Boolean Bool without pain
13:02:23 <edwardk> you'd need Num Bool
13:02:34 <kallisti> hm?
13:02:40 <Eduard_Munteanu> Then why not ... => Boolean a?
13:02:40 <edwardk> which will wind up an orphan, and you'll have to choose between the boolean ring and the boolean semiring
13:02:46 * hackagebot keys 2.1.3.2 - Keyed functors and containers  http://hackage.haskell.org/package/keys-2.1.3.2 (EdwardKmett)
13:02:48 <kallisti> I'm not making Bits a superclass of anything.
13:02:57 <edwardk> oh instance
13:03:02 <edwardk> sorry misparsed
13:03:36 <edwardk> kallisti: http://hackage.haskell.org/packages/archive/monoids/0.1.36/doc/html/Data-Ring-Boolean.html was an old boolean ring i had lying around
13:03:43 <kallisti> edwardk: yeah I've been looking at it.
13:04:11 <kallisti> pretty sure I have the code correct I just need a better name.
13:04:15 <kallisti> right now it's just newtype Bits
13:04:21 <kallisti> but that's causing ambiguous name errors.
13:04:23 <edwardk> yeah
13:04:55 <edwardk> http://hackage.haskell.org/packages/archive/monoids/0.1.36/doc/html/Data-Ring-Semi-Ord.html also works pretty well
13:05:07 <edwardk> at least for Bool
13:05:28 <parcs`> edwardk: but the finalizer must itself be a FunPtr
13:05:31 <edwardk> but you want a lattice structure when you go to do so in general
13:05:53 <edwardk> parcs`: yes, but you can ffi to make the finalizer, then free the finalizer in the finalizer ;)
13:06:05 <edwardk> parcs`: let me find an example of mine
13:06:06 <kallisti> edwardk: what is required to make Priority a lattice?
13:06:26 <kallisti> is an Ord constraint on the parameter sufficient?
13:06:34 <parcs`> edwardk: christ
13:06:49 <kallisti> *bounded lattice
13:07:18 <drdo> Can GHC static link everything? (including foreign libraries)
13:07:18 <edwardk> Priority just bolts bounds on the top and bottom for another ordering
13:07:24 <kallisti> right
13:07:29 * parcs` doesn't understand why you can't just use plain functions as finalizers for ForeignPtrs.. there's most likely a good reason
13:08:01 <acowley> I didn't know about Priority. I've been using a MinRig type for something similar of late.
13:08:08 <kallisti> edwardk: I don't know that I plan on creating a general lattice library. This isn't really an area I excel at.
13:08:24 <napping> parcs`: I think it just stores a single function pointer
13:08:35 <edwardk> kallisti: i have a few lattice-ish types in algebra but it hasn't been my focus
13:09:09 <edwardk> parcs`: most finalizers for ForeignPtrs invoke external APIs
13:10:00 <edwardk> and unlike the usual mechanism the finalization machinery for a foreignptr is tied to the actual underlying foreign pointer, not the particular ForeignPtr constructor
13:10:16 <edwardk> they _could_ use haskell functions, but it'd slow down the common case
13:10:25 <edwardk> where you usually just call something like free
13:11:23 <edwardk> parcs`: anyways, something like https://github.com/ekmett/foreign/commit/41dafb4ddf1fc09d1225b20f7aa6cef6c281a4ce#diff-0 should work
13:11:55 <parcs`> i had a feeling mfix would be necessary..
13:11:58 <edwardk> parcs`: i never shipped that module up to hackage though, so you'd need to copy the method and the foreign wrapper
13:12:06 <edwardk> you can do without the mfix, but it makes the code cleaner
13:12:14 <edwardk> without it you wind up making a ref and handing it in
13:12:15 <kallisti> what happens when you derive a typeclass for a newtype that can be derived normally?
13:12:23 <kallisti> does it do fancy newtype deriving or the regular deriving?
13:12:50 <edwardk> kallisti: its a bit of both ;)
13:12:59 <edwardk> kallisti: Show and Read get specialized, but most others just pass through
13:13:11 <kallisti> edwardk: but it won't automatically derive things like...
13:13:15 <rwbarton> and of course Typeable
13:13:22 <edwardk> yeah hence most =)
13:13:39 <kallisti> newtype Bitwise a = Bitwise {getBits :: a} deriving (Bounded, Enum, Eq, Ord)
13:13:51 <kallisti> does that create instance (Eq a) => Bitwise a where ...
13:13:52 <kallisti> etc
13:13:55 <kallisti> er
13:14:03 <kallisti> does that create instance (Eq a) => Eq (Bitwise a) where ...
13:14:15 <kallisti> I don't think it would.
13:14:18 <edwardk> yes, but the dictionary construction is just an identity function on the dictionary
13:14:43 <napping> are there any encodings for Java's "modified UTF8"?
13:14:51 <kallisti> is that not what I likely want?
13:14:59 <edwardk> it is what you want
13:15:04 <kallisti> oh good.
13:15:09 <rwbarton> that's why it does it :)
13:15:27 <edwardk> its pretty smart ;)
13:16:03 <kallisti> newtype Bitwise a = Bitwise {getBits :: a}
13:16:03 <kallisti>                   deriving (Num, Bits, Eq, Ord, Bounded, Enum, Show, Read,
13:16:06 <kallisti>                             Typeable)
13:16:09 <kallisti> anything else I might want?
13:16:12 <kallisti> (Sorry for the multiple lines)
13:16:29 <kallisti> I should have pre-formatted.
13:17:02 <kallisti> oh maybe Real, Fractional and friends
13:17:07 <edwardk> Data, Ix
13:17:22 <edwardk> well, there comes a point at which it gets ridiculous
13:17:35 <kallisti> lol
13:17:36 <edwardk> you can also add Functor, Foldable, Traverable, Monad, etc. when do you stop?
13:17:38 <kallisti> no such thing.
13:17:44 <kallisti> never quit.
13:17:47 <kallisti> all the instances.
13:17:47 <parcs`> edwardk: well if you want clean code i would suggest '\p' -> f p' <* freeHaskellFunPtr w' ;) thanks though
13:17:53 <parcs`> perhaps that function should be added to base
13:18:03 <kallisti> edwardk: I'm looking for the things that other numbers typically have.
13:18:41 <crdueck> hello, haskell beginner here. could someone please explain why this expression works in ghci but ghc complains if i try to compile? sprunge.us/MYNU
13:18:50 <edwardk> parcs`: when dealing with low level io crud like that i admit i tend to devolve to writing the simplest thing that works then cleaning it up, but good call. i don't have that code anywhere any more anyways
13:19:09 <edwardk> kallisti: ultimately if you are working bitwise with a fractional type you're doing it wrong
13:19:14 <rwbarton> haha
13:19:54 <kallisti> oh right
13:20:10 <kallisti> for some reason I thought people did bitwise stuff with floating point.
13:20:20 <acowley> they do
13:20:34 <kallisti> but not in Haskell, according to the instance list of Bits
13:21:42 <cg_morton> yo, crdueck, did you have an expression to show us?
13:22:00 <crdueck> cg_morton: its in this paste:  http://sprunge.us/MYNU
13:22:15 <acowley> kallisti: don't you want Haskell code to include things like http://en.wikipedia.org/wiki/Fast_inverse_square_root
13:22:59 <kallisti> deriving (Num, Bits, Eq, Ord, Bounded, Enum, Show, Read, Real, Integral,  Typeable, Data, Ix, Storable, PrintfArg)
13:23:02 <kallisti> weeeeee.
13:23:03 <rwbarton> crdueck, main needs to be an IO action, not a number of some kind
13:23:09 <cg_morton> well that page is a security risk for 'Potentially Unwanted Software'.  Could you paste it on hpaste.org?
13:23:10 <kallisti> acowley: what now? sorry I was busy deriving millions of instances.
13:23:14 <rwbarton> use "print ssq"
13:24:18 <kallisti> acowley: oh yes I actually need such a thing for my Quake clone.
13:24:55 <kallisti> that seems to be most of the instances that all the various Bits instances have.
13:25:37 <acowley> I wonder if there's a bettery way of dealing with that kind of deriving explosion.
13:25:40 <acowley> better, too
13:26:30 <kallisti> porbably.
13:26:31 <acowley> GHC and Haskell maintain a very fine line between explicit bondage and implicit shenanigans.
13:27:18 <acowley> porbability = probability + derp?
13:27:40 <kallisti> porbably
13:27:46 <saml> porbarly
13:28:08 <parcs`> newtype MyNewtype a = MyNewtype a; deriving instance (c a) => c MyNewtype
13:28:53 <kallisti> acowley: in my limited experience, Haskell shifts most of the burden onto the library designer to tediously implement all the nice implicit features that applications get to use.
13:29:18 <acowley> parcs`: And such instances could be overridden by explicit instances, but it means you will get instances you didn't anticipate, which means some code might type check when you would rather have seen an error.
13:29:48 <acowley> kallisti: Yes, but instances live in the DMZ between package authors.
13:31:07 <parcs`> acowley: in that case, explicitly enumerating the classes you want derived is the best way no?
13:32:12 <lamefun2> how to make a list of IO [Float] given a function IO Float?
13:32:19 <lamefun2> of a certain size
13:33:04 <parcs`> lamefun2: replicateM
13:33:19 <saml> [ioFloat1, ioFloat2]
13:33:41 <parcs`> that's [IO Float]
13:33:52 <saml> wait. so you have a Float value in monad and you want to turn that into monad of [Float]
13:34:36 <saml> replicateM :: Monad m => Int -> m a -> m [a]
13:35:25 <rwbarton> (btw IO [Float] is not a "list" and IO Float is not a "function")
13:35:40 <lamefun2> type Vector2 = (Float, Float)
13:35:50 <lamefun2> how to convert two IO Floats into IO Vector2?
13:35:52 <saml> use Double
13:36:06 <kallisti> liftM Vector2 iofloat1 iofloat2
13:36:11 <saml> > f <- (return 0.1); return (f, f)
13:36:12 <acowley> lamefun2: (,) <$> a <*> b
13:36:12 <lambdabot>   <no location info>: parse error on input `;'
13:36:18 <cg_morton> depends on what sort of floats you want, doesn't it.  More generally, you can do   ioFloat1 =>> floatGenerator
13:36:21 <kallisti> oh right
13:36:23 <lamefun2> :t <$>
13:36:24 <lambdabot> parse error on input `<$>'
13:36:30 <lamefun2> :t (<$>)
13:36:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:36:39 <kallisti> (<$>) = fmap
13:36:50 <lamefun2> :t (<*>)
13:36:51 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
13:37:34 <saml> liftM (,) (return 1) (return 2)   doesn't work
13:37:53 <hayashi> wouldn't that be liftM2?  *iunno*
13:37:54 * hackagebot numeric-prelude 0.3.0.2 - An experimental alternative hierarchy of numeric type classes  http://hackage.haskell.org/package/numeric-prelude-0.3.0.2 (HenningThielemann)
13:37:56 * hackagebot sox 0.2.2 - Play, write, read, convert audio signals using Sox  http://hackage.haskell.org/package/sox-0.2.2 (HenningThielemann)
13:37:58 * hackagebot sox 0.2.2.1 - Play, write, read, convert audio signals using Sox  http://hackage.haskell.org/package/sox-0.2.2.1 (HenningThielemann)
13:38:11 <cg_morton> > liftM2 (,) (return 1) (return 2)
13:38:12 <lambdabot>   No instance for (GHC.Show.Show (m (a1, a2)))
13:38:12 <lambdabot>    arising from a use of `M664...
13:38:34 <hayashi> :t liftM2 (,) (return 1) (return 2)
13:38:35 <lambdabot> forall a1 a2 (m :: * -> *). (Num a1, Monad m, Num a2) => m (a1, a2)
13:38:38 <saml> fmap is general version of liftM ?
13:38:44 <acowley> > fromJust $ liftM2 (,) (return 1) (return 2)
13:38:45 <lambdabot>   (1,2)
13:38:53 <kallisti> saml: it's the same thing but with different class constraints.
13:39:04 <cg_morton> liftM is monads, fmap is functors
13:39:07 <kallisti> they /should/ be equivalent, for almost every type you would ever encounter
13:39:11 <saml> oh okay
13:39:12 <kallisti> that is both a Monad and a Functor.
13:39:25 <saml> how can you do liftN ?
13:39:32 <saml> template haskell?
13:39:34 <cg_morton> but monads should be Functors anyway, just it's not a class constraint for historical reasons
13:39:37 <kallisti> there's liftM2, liftM3, etc
13:40:09 <kallisti> for "liftMN" I typically use the applicative syntax with <$> and <*>
13:40:28 <kallisti> f <$> a1 <*> a2 <*> a3 ...
13:41:54 <saml> @info (<*>)
13:41:54 <lambdabot> (<*>)
13:42:22 <saml> where is <*> defined? what module do I import? Data.Functor isn't it
13:42:31 <acowley> Control.Applicative
13:42:40 <cg_morton> @info Applicative
13:42:40 <lambdabot> Applicative
13:42:49 <acowley> @hoogle (<*>)
13:42:50 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
13:42:51 <saml> http://www.haskell.org/hoogle/?hoogle=%3C*%3E
13:43:00 <saml> i was looking at hayoo instead :P
13:43:46 <saml> >  (,) <$> (return 1) <*> (return 2)
13:43:47 <lambdabot>   No instance for (GHC.Show.Show (f (a, a1)))
13:43:47 <lambdabot>    arising from a use of `M1118...
13:44:00 <kallisti> lamefun2: (<*>) is something like lifted function application.
13:44:05 <kallisti> :t (<*>)
13:44:06 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
13:44:06 <acowley> I really like Hayoo's broader scope, but often have trouble finding what I'm looking for. The two are porbably not unrelated.
13:44:07 <kallisti> :t ($)
13:44:08 <lambdabot> forall a b. (a -> b) -> a -> b
13:44:10 <kallisti> notice the similarity
13:44:14 <parcs`> is there a ForeignPtr-like thing for not plain Haskell values, not just Ptrs? i think i asked this before, but i don't remember whether i received an answer
13:44:15 <cg_morton> > [(*3),(*5)] <*> [2,4]
13:44:16 <lambdabot>   [6,12,10,20]
13:44:24 <parcs`> s/not plain/plain/
13:45:02 <kallisti> parcs`: so it executes some code when the value is garbage collected?
13:45:07 <parcs`> yeah
13:45:27 <kallisti> I've wondered this myself.
13:45:45 <kallisti> I don't think such a thing would be very kosher.
13:46:13 <acowley> Me too, but I never found anything. You're left to use ForeignPtr and an unhealthy dose of unsafePerformIO :/
13:47:55 * hackagebot midi 0.2.0.1 - Handling of MIDI messages and files  http://hackage.haskell.org/package/midi-0.2.0.1 (HenningThielemann)
13:49:49 <parcs`> acowley: and with ForeignPtrs the thing needs to be Storable :(
13:49:50 <Croms> In GHCI, is it possible to show the available functions from a specific module with a command?
13:50:19 <parcs`> Croms: you can tab-complete the module name
13:50:25 <acowley> Croms: :browse Data.Functor
13:50:29 <parcs`> eg Data.List.<TAB>
13:50:35 <parcs`> or that, apparently
13:50:52 <cg_morton> well they have somewhat different effects
13:51:06 <ciaranm> they're not effects!
13:51:24 <cg_morton> they are!  they print to the console!
13:51:40 <Croms> Yeah, I knew about tab completion. Browse is what I'm looking for. Thanks.
13:52:55 * hackagebot synthesizer-dimensional 0.6.0.1 - Audio signal processing with static physical dimensions  http://hackage.haskell.org/package/synthesizer-dimensional-0.6.0.1 (HenningThielemann)
13:52:55 <kallisti> if a side-effect outputs to /dev/null, does it make a sound?
13:53:22 <acowley> kallisti: that of a fan slightly increasing its rpm?
13:53:48 <parcs`> yes, if /dev/null is a symlink to /dev/snd
13:53:53 <ciaranm> "side" effects? they doubly don't exist!
13:54:14 <acowley> Which is also why passively cooled computers should be avoided: the side effects are harder to hear.
13:54:20 <cg_morton> fan speed - the ultimate side effect.  No pure function is immune from effecting the real world
13:55:27 <parcs`> simply talking about Haskell affects the real world, thus making it not pure
13:55:53 <Eiam> damnit it went WAY off my buffer
13:55:58 <Eiam> and im about to walk into another meeting. argh
13:55:58 <cg_morton> you're right!  we all need to shut up, right now, for the sake of the language
13:58:13 <kallisti> hm, I need to one-up the terrible humor.
13:58:31 <kallisti> Tired of the symptoms of imperative languages? Try Haskell! Side effects may include:
13:59:06 <jonaskoelker> look, my code is almost lispy: "when (or [prin, (not (or [prin, samp, stat]))]) (print tree)" :-)
14:00:22 <parcs`> i smell a tautology
14:00:51 <acowley> he who smelt it, dealt it
14:01:03 <acowley> okay, that's my limit for the day
14:01:09 <jonaskoelker> kallisti: lol
14:02:47 <jonaskoelker> parcs`: where do you smell a tautology?
14:02:51 <ciaranm> if you've reached your limit, you must be continuous, so you can't stop
14:03:02 <jonaskoelker> lol
14:03:04 <kallisti> and [not prin, or [prin, samp, state]]    -- DeMorgen is a pretty cool guy. eh negates binary operations and doesn't afraid of anything.
14:03:32 <parcs`> jonaskoelker: prin || not prin
14:04:13 <kallisti> it's possible that the above is more efficient in some best-cases
14:04:21 <kallisti> due to short-circuiting shenanigans.
14:04:30 <jonaskoelker> parcs`: if prin=False, samp=True, it evaluates to False, no?
14:04:59 <jonaskoelker> kallisti: then use whenNot? ("unless"?)
14:05:29 <mightybyte> Design question:  I'm writing a library that has a computationally intensive, iterative numerical algorithm.  It is a pure algorithm that runs until some definition of convergence, but it is useful to print out information about each iteration.
14:05:45 <kallisti> jonaskoelker: by "the above" I meant "your code"
14:06:17 <gigi2> #haskell-blah	
14:06:23 <jfischoff> @quote oasis
14:06:23 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
14:06:28 <gigi2> s/#haskell-blah//
14:06:31 <mightybyte> I could use a number of approaches.  Pass in a flag to turn debug output on.  Pass in a file descriptor where the output is written.  Dump the output into a writer and return it., etc
14:06:33 <jonaskoelker> kallisti: more efficient, compared to what?
14:06:35 <kallisti> mightybyte: you can use the iterate function to create an infinite list of iterations, and then mapM to print out said useful info.
14:06:37 <gigi2> sorry....
14:06:51 <mightybyte> But all of those approaches feel ugly in one way or another.
14:06:58 <kallisti> this avoids muddling your pure logic with flags and stuff
14:07:26 <technopredator> Hi. I wanted to ask how much Lambda Calculus I need to learn to effectively use Haskell? Do I need to rean an entire book? I just want to have the right background to be an effective Haskell programmer, if that is possible
14:07:30 <acowley> What are the downsides of producing a list of intermediate values?
14:07:31 <mightybyte> kallisti: Yeah, I thought about that.
14:07:44 <jonaskoelker> technopredator: I'd guess you can pick it up on the way
14:07:53 <ciaranm> technopredator: haskell doesn't use the lambda calculus
14:07:56 * hackagebot enumset 0.0.4 - Sets of enumeration values represented by machine words  http://hackage.haskell.org/package/enumset-0.0.4 (HenningThielemann)
14:07:56 <mightybyte> But there is a catch.  The algorithm I just described is itself run iteratively with random inputs, so that isn't pure.
14:08:14 <kallisti> well, it can be pure.
14:08:22 <kallisti> you just specify the seed at the start.
14:08:30 <ciaranm> mightybyte: pass in randoms as the input
14:08:32 <mightybyte> acowley: I'm not sure.  It just feels wrong, and from past experience with Haskell memory leaks I kind of don't want to keep the whole list around.
14:08:45 <kallisti> you don't have to keep the whole list around
14:08:55 <mightybyte> ciaranm: Yeah, but passing in a random generator or seed feels ugly too.
14:08:58 <kallisti> it will be garbage collected as you iterate over it, assuming you don't store subsequences of it.
14:09:14 <ciaranm> mightybyte: 'randoms', the function, is your super awesome friendly friend
14:09:54 <mightybyte> ciaranm: Hmmm, I wasn't aware of that one.  I've been using mwc-random.
14:10:09 <acowley> When you don't want it, don't use it. The reason I asked is that you might be fine implementing your non-debug version as 'takeWhile keepGoing foo' but if it's important you probably should criterion that against your current version.
14:10:35 <DanBurton> I have a challenge for you guys: try to figure out what MagicMonad is! If it exists at all. https://github.com/DanBurton/bf-interp/blob/master/Parser.hs
14:10:57 <ciaranm> obviously MagicMonad is the free monad over fairy dust
14:11:11 <DanBurton> I knew it!
14:11:11 <parcs`> mightybyte: perhaps use continuation passing style for the next iteration?
14:11:18 <mightybyte> All of the solutions that include output printing feel ugly in the case that I don't care about the output.
14:11:59 <mightybyte> parcs`: Hmmm, interesting.  I'm familiar with the idea, but how are you thinking it would look?
14:13:31 <kallisti> DanBurton: some kind of StateT
14:13:40 <kallisti> perhaps with a list?
14:14:03 <DanBurton> kallisti: that's what I thought too, except I can't quite bend my brain around how to make it work
14:14:23 <acowley> I think I'd use a Seq
14:14:29 <technopredator> Doesn't use LC? I thought that was the code interpretation format as I have seen examples expressed just like LC
14:14:29 * kallisti would use a DList.
14:14:49 <DanBurton> It doesn't really matter, a simple stack is conceptually all that is needed
14:14:49 <acowley> You need to push and pop at both ends. How would DList help?
14:15:02 <DanBurton> oh don't let begin and end fool you
14:15:08 <kallisti> the types are different
14:15:10 <kallisti> for each
14:15:28 <DanBurton> when I say pushBegin and popEnd, what I mean is there are two different stacks, a "begin" stack and an "end" stack
14:15:38 <acowley> ….
14:15:51 * acowley was fooled
14:15:52 <DanBurton> perhaps that wording was...really bad
14:16:02 <acowley> do push and pop mean what I think they mean? :P
14:16:12 <kallisti> the DList would be for efficiently building the list.
14:16:13 <DanBurton> the idea is, "begin" is a stack that stores the beginning of a loop, and "end" is a stack that stores the end of a loop
14:16:28 <kallisti> *the list being the AST output, presumably
14:16:29 <DanBurton> yes, push and pop probably mean what you think they mean
14:16:57 <kallisti> I'm guessing TapeM is some kind of zipper structure?
14:17:28 <DanBurton> something like that
14:17:36 * kallisti has written a bf interpreter before and used a zipper. it works very well.
14:17:37 <DanBurton> u can see the files in the parent dir
14:17:45 <kallisti> I'm not sure why you need 2 stacks
14:17:56 * hackagebot algebra 2.1.1.2 - Constructive abstract algebra  http://hackage.haskell.org/package/algebra-2.1.1.2 (EdwardKmett)
14:17:59 <DanBurton> it's because of how I want to parse the program
14:18:37 <kallisti> oh I think I see.
14:18:42 <DanBurton> I want to parse it into a Program structure, which is perhaps too abstract for its own good https://github.com/DanBurton/bf-interp/blob/master/Program.hs
14:18:57 <technopredator> well I guess I'm on my own
14:19:28 <technopredator> let's see where this roads takes me...
14:19:38 <acowley> technopredator: don't worry about LC yet
14:19:52 <kallisti> DanBurton: the field of Control returns the execution of the loop followed by the program to be interpreted afterward?
14:20:04 <kallisti> or does it result in the loop itself?
14:20:28 <acowley> technopredator: Start by learning Haskell, then when you come back to the LC it will be second nature.
14:20:33 <DanBurton> Control is an action, so in this case, it's an action that can inspect the state of the tape, and then it produces the Program to be executed thereafter
14:20:41 <kallisti> right
14:20:42 <technopredator> ok
14:21:03 <technopredator> thx 4 d guidance
14:21:25 <acowley> technopredator: are you working through LYAH?
14:21:40 <DanBurton> it's a concept more general than loop, but the "branch" combinator and the "loopControl" derived from that should work for loops as expected
14:22:06 <kallisti> DanBurton: yes
14:22:22 <kallisti> it's similar to a continuation.
14:22:38 <technopredator> nope, but I got it, I just didn't know where to start, so many beginner books
14:22:51 <DanBurton> it looks so friggin cool, but parsing the brainfuck program from a string into this struct is sort of exploding my brain
14:23:17 <hpc> someone needs to write the concurrent brainfuck comonad
14:23:18 <DanBurton> right, it's similar to a continuation I suppose
14:23:32 <hpc> where it executes every instruction at once
14:23:48 <kallisti> good luck with that.
14:24:18 <DanBurton> i'll be happy if I manage to discover what MagicMonad is
14:24:23 <acowley> technopredator: we (#haskell) usually encourage people to start with LYAH because it's freely available, and very accessible. If whatever source you are currently working from isn't clicking for you, give LYAH a try. If what you have is working for you, stick with it!
14:25:00 <DanBurton> +1 LYAH worked great for me as introductory Haskell material
14:25:32 <technopredator> ok acowley, I'll give it a try, thx dude
14:25:56 <kallisti> DanBurton: what is this MagicToken business?
14:26:00 <kallisti> why not work directly with Program?
14:26:03 <technopredator> DanBurtoin: *thumbs up*
14:26:39 <technopredator> *cool community*
14:27:20 <DanBurton> kallisti: well I wrote out toProgramStep the way I thought it should work, and ended up with the push/pop combinators
14:27:31 <DanBurton> kallisti: then I just gave them the most general type I could imagine
14:27:45 <acowley> The community is haskell's best asset.
14:27:57 * hackagebot heaps 0.2.1.1 - Asymptotically optimal Brodal/Okasaki heaps.  http://hackage.haskell.org/package/heaps-0.2.1.1 (EdwardKmett)
14:28:00 <mightybyte> Haskell rocks though.  This algorithm I'm working on is 100x faster in Haskell than the previous implementation my coworker wrote in Mathematica.
14:28:08 <edwardk> mightybyte: =)
14:28:40 <jonaskoelker> neato =)
14:28:58 <kallisti> DanBurton: it seems to me like '[
14:29:02 <mightybyte> My code is full of imperative ugliness, but that's ok.
14:29:18 <kallisti> ' should just start a Program constructor
14:29:22 <kallisti> or the AST equivalent of it.
14:29:22 <mightybyte> Mutable vectors + forM FTW!
14:29:40 <kallisti> er I mean Control constructor
14:30:15 <kallisti> with the result being the rest of the parse.
14:30:54 <DanBurton> kallisti: that makes sense, but if possible, I want the '[' and ']' tokens to point to the same program
14:31:35 <technopredator> Any comment on D? they say is the next C++...
14:31:41 <DanBurton> in other words, when execution flow gets to ']', it is as if it warps back to ']'
14:31:56 <DanBurton> perhaps I'm trying for too much
14:32:34 <kallisti> DanBurton: okay so
14:32:47 <kallisti> you could have a stack of MagicMonads
14:32:55 <kallisti> that you push onto when you encounter [
14:32:59 <kallisti> then when you encounter ]
14:33:04 <kallisti> you pop it off and conditionally re-execute it.
14:33:40 <kallisti> so the '[' would result in a Control
14:33:44 <jonaskoelker> technopredator: is that a form of advertisement or a warning? =)
14:33:48 <kallisti> as well as popping its own code onto the stack...
14:33:59 <parcs`> mightybyte: sorry, it's not so much CPS as it is making the recursive case explicit: http://hpaste.org/68401
14:34:59 <DanBurton> I'm going to dive into the code and fiddle a bit
14:35:03 <DanBurton> thanks for the ideas, kallisti
14:35:10 <mightybyte> parcs`: Oooh, nice
14:35:21 <technopredator> Hehe, none, I just wanted to know what the programming community thinks about it, ebcause according to the ads it better than C++ in ways C++ will never be, I don't know... I'm just a n00b programmer..
14:35:26 <kallisti> DanBurton: toProgramStep ('[':cs) = let prgrm = Control (toProgramStep cs) in push prgrm >> prgrm; toProgramStep (']':cs) = ifM checkCondition pop (return (toProgramStep cs))
14:35:37 <kallisti> er
14:35:45 <kallisti> I think
14:36:38 <kallisti> that's a rough sketch of the idea anyway
14:36:38 <mightybyte> parcs`: I'll have to study that a bit.  Every time I read about fixpoints they seem relatively straightforward, but it always seems like I'm missing some deep insights about them.
14:36:40 <kallisti> there's some bits missing.
14:37:55 <kallisti> DanBurton: oh wait it would be much easier to the put condition at the [
14:37:57 * hackagebot wl-pprint-extras 1.6.3.2 - A free monad based on the Wadler/Leijen pretty printer  http://hackage.haskell.org/package/wl-pprint-extras-1.6.3.2 (EdwardKmett)
14:38:36 <kallisti> DanBurton: oh yeah that's really simple
14:39:44 <timthelion> @src foldr
14:39:44 <lambdabot> foldr f z []     = z
14:39:44 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:40:02 <timthelion> @t foldr
14:40:03 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
14:40:07 <timthelion> :t foldr
14:40:08 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:41:07 <kallisti> DanBurton: toProgram ('[':cs) = fix $ \self -> ifM checkCondition (pushBegin self >> toProgramStep cs) (?????)
14:41:13 <kallisti> *toProgramStep
14:41:37 <kallisti> it needs to somehow already know where its endpoint lies.
14:42:00 <kallisti> which suggests to me that you need a seperate parsing step before interpretation, or perhaps some knot-tying magic.
14:42:57 * hackagebot wl-pprint-terminfo 0.8.3.2 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-0.8.3.2 (EdwardKmett)
14:44:46 <adnap> why does cabal keep telling me there is a new version of cabal-install even after i instll it? it keeps "Building cabal-install-0.14.0..."
14:46:52 <vaflis> maybe old one is still registered with ghc and it messes things up
14:46:55 <Saizan> adnap: `which cabal` probably differs from where you're installing it
14:46:56 <vaflis> check ghc-pkg list
14:47:05 <Saizan> executables don't get registered.
14:48:07 <vaflis> oh, ok
14:48:31 <dbpatterson> Lemmih: ping
14:49:33 <Saizan> though cabal-install itself knows its version when it runs :)
14:49:39 <luite> hm, didn't lambdabot have a command to z-encode/decode names?
14:49:53 <dbpatterson> anyone around familiar with acid-state?
14:50:34 <dbpatterson> at some point, it managed to corrupt its own event-log, so now you can add events to it when it is running, but when it replays from disk, it will not replay any events past a certain point.
14:50:49 <dbpatterson> and I'd like to be able to uncorrupt it, but don't really know where to start.
14:51:27 <dbpatterson> (or at least, this is my best guess of what happened, based on it's behavior. I really have no idea if it is corrupted)
14:52:41 <kallisti> DanBurton: so I think you actually need a queue and a stack.
14:52:57 * hackagebot semigroupoid-extras 0.2.7.2 - Semigroupoids requiring Haskell extensions  http://hackage.haskell.org/package/semigroupoid-extras-0.2.7.2 (EdwardKmett)
14:52:59 * hackagebot numeric-extras 0.0.2.3 - Useful tools from the C standard library  http://hackage.haskell.org/package/numeric-extras-0.0.2.3 (EdwardKmett)
14:53:14 <nejucomo> What's the difference between a data with a single constructor and single constructor argument, and newtype?
14:53:43 <nejucomo> (Or- why doesn't the compiler always rewrite "data A = A X" as "newtype A = A X" ?
14:54:03 <Saizan> nejucomo: with newtype the constructor won't be there at all at runtime, which changes the semantics of pattern matches
14:54:13 <acowley> nejucomo: data has more bottoms
14:56:44 <kallisti> DanBurton: or how about this: instead of a begin stack you use a ReaderT and local.
14:57:01 <kallisti> ReaderT Program
14:57:06 <kallisti> er
14:57:10 <kallisti> ReaderT TapeP
14:57:33 <kallisti> and then local is how you "push" onto the stack.
14:57:58 * hackagebot graphs 0.4.0.3 - A simple monadic graph library  http://hackage.haskell.org/package/graphs-0.4.0.3 (EdwardKmett)
14:58:00 * hackagebot meta-par-accelerate 0.3.4 - Support for integrated Accelerate computations within Meta-par.  http://hackage.haskell.org/package/meta-par-accelerate-0.3.4 (RyanNewton)
14:58:02 * hackagebot reflection 1.1.5.1 - Reifies arbitrary terms into types that can be reflected back into terms  http://hackage.haskell.org/package/reflection-1.1.5.1 (EdwardKmett)
14:58:47 <nejucomo> Saizan, acowley: I only slightly understand each explanation.  Care to elaborate?
14:59:44 <acowley> What newtypes does lambdabot have in scope?
14:59:47 <acowley> > :k Sum
14:59:48 <lambdabot>   <no location info>: parse error on input `:'
14:59:51 <parcs`> All, Any,
14:59:57 <kallisti> DanBurton: you run the ReaderT by passing it a runtime error, which handles the case where there's an unbalanced ]
15:00:07 <twanvl> undefined === MyNewtype undefined, but undefined =/= MyData undefined
15:00:20 <Saizan> > case undefined of All _ -> ()
15:00:21 <lambdabot>   ()
15:00:22 <parcs`> > All undefined `seq` () -- All is a newtype
15:00:23 <lambdabot>   *Exception: Prelude.undefined
15:00:30 <nejucomo> If I have: "newtype A = C Int" and a function: "f :: A -> Int; f (C i) = i"  -then is what looks like a pattern match distinct from true pattern matches at runtime?
15:00:33 <parcs`> > Just undefined `seq` () -- Just is not a newtype
15:00:34 <lambdabot>   ()
15:00:55 <acowley> > (Just (error "BOOM!") `seq` "Done", All (error "BOOM!") `seq` "Done.")
15:00:56 <lambdabot>   ("Done","*Exception: BOOM!
15:01:09 <Saizan> you should also explain why it's not the same as a dta with strict fields though
15:01:43 <Saizan> nejucomo: yep, at runtime that f is the identity function
15:02:12 <nejucomo> acowley: Alright that helps a bit.
15:02:22 <nejucomo> I need to understand whnf better...
15:02:39 <mightybyte> Oh, I remember why I didn't want to use a lazy list.  When I print debug info I also do execution timing.
15:02:44 <acowley> nejucomo: We're all saying the same thing, so pick whichever example/explanation works for you :)
15:02:45 <mightybyte> parcs`: Your solution looks nice.
15:03:27 <parcs`> mightybyte: :)
15:06:41 <parcs`> nejucomo: in practice the difference between newtype and data is usually not relevant -- you should always use newtype when you can, because it's a 'free' speed up. but 'newtype's change the strictness semantics of the code, which is why the conversion is not done automatically (i assume)
15:06:45 <nejucomo> acowley: My current understanding is: newtypes do not have constructors at runtime; therefore apparent pattern matches are not actually "normal" pattern matches (having no runtime overhead) -and- as a consequence, there's no possibility of a value Head undefined existing at runtime.
15:07:34 <parcs`> all pattern matches and constructor invocations on/of newtypes essentially get erased at runtime
15:07:38 <nejucomo> Thanks for the clarification, oh haskelleers!
15:07:48 <acowley> I think of it more as WHNF pushing one level deeper. WHNF evaluation stops at a data constructor, but since there are no newtype constructors at runtime, WHNF evaluates the wrapped value.
15:07:53 <nejucomo> parcs`: Right.  That's a concise way to explain it.
15:07:58 * hackagebot representable-profunctors 0.4.2.3 - Representable profunctors  http://hackage.haskell.org/package/representable-profunctors-0.4.2.3 (EdwardKmett)
15:08:00 * hackagebot representable-functors 2.4.0.2 - Representable functors  http://hackage.haskell.org/package/representable-functors-2.4.0.2 (EdwardKmett)
15:08:02 * hackagebot representable-tries 2.4.0.2 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-2.4.0.2 (EdwardKmett)
15:08:17 <mzero> I'm having a bit of trouble getting a #define set during CPP preprocessing of a .hsc file
15:08:51 <mzero> I've set   if os(linux)   cc-options: "-D_GNU_SOURCE"    and    ghc-options: -D_GNU_SOURCE
15:09:05 <nejucomo> One possible implementation: "Remove all head-matches / constructor calls during compilation, but keep track of the distinct type."
15:09:08 <mzero> and neither of them makes it into the compile line during the preprocessing
15:09:27 <edwardk> mzero: cpp-options?
15:09:34 <edwardk> or something like that
15:09:47 <shapr> preflex: seen hylomorphism
15:09:47 <preflex>  Sorry, I haven't seen hylomorphism
15:10:07 <acowley> CPP-Options: -DFoo
15:11:06 <acowley> Of course, case doesn't matter and replace Foo with "_GNU_SOURCE"
15:12:24 <mzero> hmmm.. none of those cpp-options come out in the gcc line for the _hsc_make.c file
15:12:58 * hackagebot monad-products 0.2.1.2 - Haskell 98 monad products  http://hackage.haskell.org/package/monad-products-0.2.1.2 (EdwardKmett)
15:13:32 <mzero> hmmm… cabal doesn't seem to define cpp-options (at least not in my docs)
15:14:00 <acowley> mzero: It's what I use for CPP stuff in .hs files. But your use case may be different.
15:14:10 <mzero> oh - I see - it doesn't just not document
15:14:28 <mzero> well, I've got a .hsc file - perhaps I should have just named it .hs?
15:15:03 <acowley> mzero: If all you want is CPP, then you can use a .hs file with a {-# LANGUAGE CPP #-} pragma up top
15:15:24 <acowley> mzero: But if you're doing richer interop with C, then you will need hsc
15:15:39 <mzero> I kinda had belt and suspenders - named .hsc AND the LANGUAGE pragma
15:16:07 <acowley> If some is good, more is better! Except here.
15:17:25 <mzero> AHA - renamed .hsc to .hs and all went happier
15:17:54 <acowley> Just don't remove the LANGUAGE pragma or your pants will fall down.
15:17:59 * hackagebot monad-st 0.2.1.1 - Provides a MonadST class  http://hackage.haskell.org/package/monad-st-0.2.1.1 (EdwardKmett)
15:18:11 <mzero> what features require hsc?
15:18:31 <mzero> I'm using #const
15:18:54 <kallisti> nothing really requires hsc.
15:18:59 <acowley> mzero: it's typically used for accessing struct fields among other things, but you can also define C functions right in your .hsc file.
15:19:31 * kallisti notes that there's also a storable-record library for that use case.
15:20:27 <acowley> kallisti: From the storable-record docs, "I cannot promise that the generated memory layout is compatible with that of a corresponding C struct."
15:21:00 <kallisti> oh right
15:21:05 <kallisti> because C
15:23:01 * hackagebot prelude-extras 0.1.0.3 - Haskell 98 - higher order versions of Prelude classes  http://hackage.haskell.org/package/prelude-extras-0.1.0.3 (EdwardKmett)
15:23:03 * hackagebot syb-extras 0.2.2.1 - Higher order versions of the Scrap Your Boilerplate classes  http://hackage.haskell.org/package/syb-extras-0.2.2.1 (EdwardKmett)
15:23:05 * hackagebot profunctors 0.1.2.3 - Haskell 98 Profunctors  http://hackage.haskell.org/package/profunctors-0.1.2.3 (EdwardKmett)
15:23:22 <edwardk> pwd
15:23:29 <edwardk> er woops
15:23:34 <jfischoff> haha
15:23:54 <ion> rm -fr ~
15:24:17 <Philippa_> edwardk: I hope you don't use "er woops" as a password :p
15:24:29 <edwardk> ssh foo -l ekmett -p woops
15:24:42 <donri> Philippa_: pwd = print working directory, not password
15:24:57 <Philippa_> donri: subject to OS, but yeah
15:25:03 <donri> ah
15:25:48 <Philippa_> also subject to increasingly wonky memory. It's almost as if the first digit of my age is off
15:26:51 <kallisti> wonky memory is fun.
15:27:59 * hackagebot type-int 0.5.0.2 - Type Level 2s- and 16s- Complement Integers  http://hackage.haskell.org/package/type-int-0.5.0.2 (EdwardKmett)
15:29:05 <mzero> er - wait a bit - i *need* hsc, because I need to #include C headers (so I can get at some crazy constants, F_DUPFD_CLOEXEC in particular!)
15:30:12 <mzero> but I can't seem to get options into hsc2hs via cabal (pretty sure 'cause I'm dumb!)
15:30:39 <dcoutts> mzero: you probably want cpp-options
15:31:31 <mzero> I set those but they don't show up on the gcc line that gets printed when it compiles the _hsc.c file
15:32:38 <acowley> How are you using #ifdef that you want it to appear in the _hsc.c file?
15:33:59 <hpaste> mzero pasted “-D for hsc” at http://hpaste.org/68406
15:34:50 <hpaste> mzero pasted “the .hsc file” at http://hpaste.org/68407
15:35:06 <mzero> second paste is the .hsc file
15:35:12 <mzero> first has the cabal output and the .cabal file fragment
15:35:52 <acowley> Ohhhh, and HsUnix.h has the #ifdef _GNU_SOURCE
15:35:53 <acowley> ?
15:36:15 <mzero> well, no, it #includes <fcntl.h> … which deep in some chain has the #ifdef _GNU_SOURCE
15:36:30 <mzero> but, yeah
15:36:54 <acowley> so, hsc2hs can take a -D flag
15:37:08 <acowley> and there's cabal-install syntax for doing that
15:37:25 <mzero> find, but how do I get it there via cabal…. ? (holds breath...)
15:37:40 <acowley> mzero: if you're lucky, dcoutts will check here again in a moment :)
15:38:00 * hackagebot reducers 0.3.0.1 - Semigroups, specialized containers and a general map/reduce framework  http://hackage.haskell.org/package/reducers-0.3.0.1 (EdwardKmett)
15:38:10 <ymasory> how do i turn an IO IO a into an a?
15:38:29 <edwardk> ymasory:you don't
15:38:50 <ymasory> edwardk: what do you do when you're in the IO monad and need to call a function that also returns an io?
15:38:59 <edwardk> you use >>= or do sugar
15:39:07 <mzero> acowley - other than that, is that the "right" way to get those constants in… or should I be doing something else
15:39:18 <edwardk> do x <- action1; y <- action2; return (x + y)
15:39:20 <mzero> I admit to a bit of copy-n-paste coding to get that to work (it worked like a charm on my Mac)
15:39:31 <mzero> but no idea if that is the "modern" way of doing that sort of thing
15:39:33 <sully> ymasory: unsafePerformIO . join
15:39:35 <edwardk> ymasory: there are smarter ways once you know the basics though
15:39:37 <acowley> mzero: you're doing the right thing. You just need to work out how to get cabal to give hsc2hs the right option. I always forget this syntax.
15:39:42 <edwardk> sully: not helpful =P
15:40:00 <mzero> okay - let's hope dcoutts hasn't gone to bed...
15:40:05 <mzero> :-)
15:40:55 <acowley> it might be --hsc2hs-options=-D_GNU_SOURCE
15:43:12 <mzero> oy - if I give --gcc-options=-D_GNU_SOURCE on the cabal configure command line …. it works
15:43:58 <mzero> but you can't have that in the .cabal file
15:45:03 <Refried_1> Is it permitted to ask general (non-haskell-specific) pure-FP questions here?
15:46:15 <Saizan> Refried_1: yep
15:46:31 <acowley> Refried_1: Yes, but if you want to venture really off-topic there is #haskell-blah
15:46:59 <mzero> well… if it is leading to help making a good pure-FP algo., the folks here can help…. if you're tending toward language style pros-and-cons, there are other channels
15:47:06 <acowley> mzero: I always struggle trying to figure out cabal file syntax. Usually you can find an example of what you want somewhere.
15:47:19 <mzero> I'm a searchin' the inter-toobs
15:47:20 <ion> And if you want to talk about Haskell, which is off-topic on #haskell-blah, you can go to #haskell-blah-blah.
15:47:26 <Refried_1> haha
15:47:46 <acowley> blah is a monad
15:48:00 * hackagebot trifecta 0.51.0.1 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.51.0.1 (EdwardKmett)
15:48:21 <mzero> Acme.Blah
15:48:22 <refried__> Basically I'm trying to understand if there's a general strategy for interoperating with libraries that heavily rely on mutable objects
15:48:42 <mzero> yes - put those functions in IO
15:48:47 <acowley> We spell it IO
15:48:56 <refried__> haha *nod* ok.
15:49:04 <jonaskoelker> in a do block, can I catch an `Either IOError a' and do the `a' part in the same do block?  How does that look?
15:49:12 <refried__> it's pretty much always IO then.
15:49:14 <mzero> give your pure code and object of type   Foo   which is an *immutable* pointer to the underlying mutable state from the lib
15:49:17 <bernardoct> Hi everyone, does anyone here knows how to work with pandoc?
15:49:42 <mzero> then all the functions that get or set the underlying data (yes, even get) are of the form     Foo -> IO Data
15:49:47 <bernardoct> I'm having problems because the document I want to convert has non english characters such as ã and é
15:50:30 <refried__> mzero: ah...
15:50:35 <edwardk> refried__: that is one way to make an API. Another is to make up appropriate types that encapsulate what you want to do and not how to do it, and make an interpreter for those types that runs in IO, etc. there are multiple approaches.
15:50:56 <mzero> so, for example, the call into the library that allocates such mutable state will have the form    This -> That -> IO Foo
15:51:04 <mzero> take some parameters and return you a pointer
15:51:18 <refried__> edwardk: can you help me understand a small example of what you're describing?
15:51:34 <mzero> edwardk: wouldn't that approach be built up on primitives with the direct approach?
15:51:46 <refried__> mzero: can you help me understand the setter example?
15:51:54 <mzero> (assuming that the mutable state was provided by some extant C lib… which I think was the OP scenario)
15:52:05 <refried__> mzero: yes
15:52:05 <edwardk> mzero: probably
15:52:37 <mzero> if you have a C function that is like   setKnobZ(Foo*, int)
15:52:55 <edwardk> refried__: awkward to come up with a sufficiently small example to put on a line in irc., hrmm
15:53:06 <refried__> mzero: ah so  setX: Foo -> Int -> IO ... err no i'm confused
15:53:12 <mzero> then that will become       c_setKnobZ :: CFoo -> CInt -> IO ()
15:53:28 <mzero> sorry, I'm assuming setKnobZ is a void function
15:53:33 <mzero> we spell void    ()
15:54:13 <refried__> mzero: ah *nod*.  I've been using Scala which is neither pure nor Haskell; but I found the Frege page today ;-)
15:55:09 <refried__> edwardk: then maybe, what does "make up appropriate types that encapsulate what you want to do and not how to do it" mean?
15:55:46 <edwardk> refried__: data Expr = Add Expr Expr | Lit Int; eval (Add x y) = eval x + eval y; eval (Lit n) = n
15:56:13 <edwardk> now an Expr can be passed around, saying what you want to do, but you can eval it, to do it
15:56:23 <mzero> refried__: realize that if you really have that C function from a library, you can simply import it into Haskell thus:
15:56:38 <refried__> edwardk: ah
15:56:58 <refried__> mzero: ooh, ffi magic incoming? :-D
15:57:11 <mzero> foreign import ccall unsafe "Foo.h setKnobZ"    c_setKnobZ :: CFoo -> CInt -> IO ()
15:57:23 <mzero> after a suitable def of CFoo
15:57:45 <refried__> mzero: ah, ok, cool.
15:58:56 <mzero> the c_ prefix is just there to let you remember that this is the low level grungy wrapper around the lib ---- upon which you build up the much nicer library edwardk suggests you build!
15:59:40 <refried__> mzero: ah, i get ya
16:04:34 <bernardoct> Hi everyone, does anyone here knows how to work with pandoc?
16:04:36 <bernardoct> I'm having problems because the document I want to convert has non english characters such as ã and é
16:05:46 <mzero> I'm surprised it's an issue - is your doc in UTF-8?
16:05:58 <bernardoct> It is a html website
16:06:16 <bernardoct> All those characters are giving errors when I convert to any other format
16:06:24 <mzero> in what character encdoing?
16:06:59 <bernardoct> I don't know
16:07:03 <bernardoct> How can I find this out?
16:07:13 <bernardoct> The command I am typing is pandoc -s -r html -V lang=brazilian http://www.olavodecarvalho.org/convidados/0085.htm -o MST.markdown
16:07:39 <gabor> I have trouble writing a peek method (of the Storable class) for my GADT without resorting to unsafeCoerce. How do folks do this?
16:07:43 <mzero> load it up in a browser - and look at the encoding it choose
16:07:47 <mzero> I just did and it isn't utf-8
16:08:01 * hackagebot recursion-schemes 2.0.1.2 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-2.0.1.2 (EdwardKmett)
16:08:11 <mzero> it's Latin-1 (which means it may be Windows-1252)
16:08:38 <mzero> see the Pandoc README (http://johnmacfarlane.net/pandoc/README.html ) for how to convert this via iconv
16:08:49 <bernardoct> I see
16:09:00 <bernardoct> How did you find out the encoding?
16:09:14 <bernardoct> I openned the website but couldn't find out
16:09:29 <mzero> open the web page in my browser, and under the View menu is an Encoding submenu - just looked at what was checked
16:09:47 <mzero> my browser is Chrome, but I'm pretty sure ALL browsers have this menu … somewhere
16:10:23 <bernardoct> I see
16:10:41 <bernardoct> Mine is chromium on linux but it doesn't have this option
16:11:04 <bernardoct> It's weird that the encoding isn't utf8, because one of the headers of the page is <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
16:11:12 <mzero> wrench icon > Tools > Encoding
16:11:37 <acowley> I see a header: <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
16:12:05 <refried__> mzero: ok another random design question then:
16:12:07 <refried__> say I have object Foo with all these IO methods (what's the right terminology?), but I want to be able to treat it like an immutable object -- safely passed around where copies don't affect each other   (or maybe this is still thinking about it backwards?) -- would it be a good idea to build up an object that represents a list of mutations; and then internally apply the list to a new mutable object each time i want to read back a resu
16:12:10 <mzero> well, the meta tags are notoriously wrong
16:12:16 <bernardoct> heheh
16:12:19 <bernardoct> I see
16:12:25 <bernardoct> Thanks!
16:12:32 <bernardoct> It helped a lot :)
16:12:55 <mzero> refried__: what do you mean? Do you mean to copy the values out of the library held space?
16:13:01 * hackagebot tag-bits 0.1.1.1 - Provides access to the dynamic pointer tagging bits used by GHC.  http://hackage.haskell.org/package/tag-bits-0.1.1.1 (EdwardKmett)
16:15:23 <mzero> refried__: the way to think about this situation is the ground truth: you *ARE* holding an immutable value: the pointer to the state managed by the library
16:15:44 <mzero> you can pass that around all you want… only there is very little you do with it
16:16:09 <acowley> You can apply the identity function to it!
16:16:10 <rudyl313> what would be the most efficient way to find the most common element in a Vector?
16:16:11 <mzero> to read or write - you must use IO, since the values "through" the pointer are in mutable state land
16:16:39 <mzero> if you don't want to thread IO all through your code (and you shouldn't)
16:16:55 <refried__> mzero: I'm not 100% sure what I mean...  I guess I'm envisioning a physics library, and I want to modify the environment through library calls, which do mutate the underlying object, but I still want somehow set up an abstraction layer that allows me to have RT and hide the mutability of the object   (sorry, was typing through all your previous messages ;)
16:16:56 <mzero> you need to think of what is the right abstraction for dealing with that kind of data in a FP way
16:17:10 <refried__> *nod* :-\
16:17:12 <mzero> this is the higher-level design edwardk was talking about
16:17:20 <refried__> *nod*
16:17:50 <mzero> you can't really ---- either you write a non-FP program, using IO to mutate the underlying engine
16:18:08 <mzero> or you come up with an FP abstraction and manipulate THAT, not the underlying thing
16:18:16 <refried__> hmm *nod*
16:18:29 <mzero> so one way might be to…. build up the whole world state with nice, FP pure data structures all in Haskell
16:18:58 <mzero> and, when you "want to run the simulation with the fast C lib", dump that state into c lib managed state (the dumping is thus all in IO)
16:19:05 <mzero> run it, and then extract out the results
16:19:32 <refried__> there's no extracting out the results though, or is there?   i've seen a photo of a cat stuck in a shower lamenting IO
16:19:34 <mzero> on the other hand, if the lib is going to manage long lived state --- like the physics state of game over time
16:19:55 <mzero> then perhaps each "turn" you do indeed what you say: build up a set of operations, in pure-FP land….
16:20:01 <acowley> rudyl313: I can't think of anything clever.
16:20:15 <mzero> and after the logic has run (all pure), you apply those operations to the state (in IO)
16:20:20 <acowley> rudyl313: If you can take advantage of a small domain, do so
16:20:49 <refried__> mzero: hmm *nod*
16:21:00 <mzero> refried__: well, sure there is -- you can extract them as pure data, pass them to pure functions, so long as you do that FROM an IO action
16:21:03 <rudyl313> acowley: use a Map to store a element to count map? or convert to List and use the sort then group trick?
16:21:10 <refried__> mzero: i get ya
16:21:36 <acowley> rudyl313: what is the type of the elements of the Vector?
16:21:57 <mzero> do { stateOtheWorld <- getState foo;  let newActions = purActionComputation stateOtheWorld; applyActions newActions foo; }
16:22:05 <rudyl313> acowley: String
16:22:23 <acowley> rudyl313: Ah, then you probably want a trie
16:22:44 <rudyl313> acowley: can't say I know too much about tries
16:22:47 <refried__> mzero: i think once upon a time i'd tried to write a pure game... started at the bottom and was ok until i hit the draw loop at the top, and then was like *crk* disconnect.  :-)
16:22:56 * mzero wonders if rudyl313's problem is HW or an interview question...
16:23:21 <rudyl313> mzero: neither... working on a personal project
16:23:27 <refried__> mzero: this application I'm thinking of now is more simulation-oriented -- and restarting the simulation frequently from known point, then taking one computeNext() action and looking at the result,   will be the primary operation i guess
16:23:49 <rudyl313> mzero: trying to build a decision tree classifier...need to find the majority label in the leaf node
16:23:53 <refried__> mzero: I see what you mean in that "do" though
16:27:06 <mzero> > let findMostCommon = head . snd . maximum . map (length &&& id) . group . sort   in   findMostCommon "Hello world of Haskell"
16:27:08 <lambdabot>   'l'
16:27:34 <mzero> mind you, rudyl313 - that doesn't cover all the corner cases: empty input, or what if there is more than one element with the same maximal count?
16:27:52 <rudyl313> mzero: thanks...I've seen that solution .. but that applies to lists
16:27:56 <rudyl313> mzero: I have vectors
16:28:03 <rudyl313> mzero: guess I can just toList
16:28:17 <rudyl313> mzero: but worried what I pay in performance for that
16:28:28 <mzero> Ah, you have a vector of Strings?
16:28:31 <acowley> mzero gave you a list of chars
16:28:32 <mzero> … well….
16:28:36 <acowley> you have a vector of strings
16:28:39 <mzero> it works with both, acowley
16:28:50 <rudyl313> acowley: yes a Vector of Strings
16:29:28 <mzero> > let findMostCommon = head . snd . maximum . map (length &&& id) . group . sort   in   findMostCommon $ words "which witch is that which is the witch of the switch?"
16:29:29 <lambdabot>   "witch"
16:29:46 <acowley> Yes, but it becomes less desirable to do so
16:30:22 <rudyl313> I'm surprised the Vector lib doesn't have a sort
16:30:22 <parcs`> rudyl313: that is quite strange
16:30:37 <acowley> rudyl313: vector-algorithms
16:30:38 <parcs`> why are you using vectors?
16:30:39 <mzero> rudyl313: IF the vector is already sorted (in the vector), then toList run through the rest of that will be fast due to fusion
16:30:46 <mzero> it won't actually create the whole list ever
16:31:18 <rudyl313> mzero: very cool
16:32:13 <rudyl313> parcs`: I have to select elements using a random set of indices...and I have other ordered collections that need to also be fetched by those same indices.. so basically I want O(1) indexing
16:32:43 <rudyl313> parcs`: there might be a way around it but vectors work
16:33:09 <mzero> laters all
16:33:37 <bernardoct> mzero, I'm still having problems with the conversion
16:33:48 <parcs`> rudyl313: ah...
16:33:49 <bernardoct> I'm getting rÃ¡pido instead of rápido after the conversion
16:33:58 <bernardoct> Do you have an idea on how to fix it?
16:34:07 <rudyl313> bernardoct: he just left
16:34:16 <bernardoct> Ah, crap
16:34:23 <bernardoct> Thanks
16:35:06 <bernardoct> I am having problems with converting a website from ISO-8599-1 to utf8 with iconv
16:35:18 <bernardoct> I'm trying to use pandoc to create a ebook
16:35:23 <acowley> bernardoct: What was the pandoc command line you were using?
16:35:37 <bernardoct> The command I am typing is pandoc -s -r html -V lang=brazilian http://www.olavodecarvalho.org/convidados/0085.htm -o MST.markdown
16:37:24 <bernardoct> Do you have any idea on something I can do to convert this website to an epub?
16:37:29 <acowley> rudyl313: if one of the sorting algorithms in vector-algorithms works out fast enough for you, then keep things simple.
16:37:53 <rudyl313> acowley: thanks for the tip
16:37:56 <bernardoct> when I use this pandoc command the messes up with latin characters, such as é and ã
16:39:16 <sclv_> it has a charset of charset=iso-8859-1
16:39:31 <sclv_> you may want to manually convert it to unicode or something
16:39:40 <sclv_> and run pandoc on that.
16:40:08 <bernardoct> I am trying to use iconv
16:40:12 <bernardoct> But it's also messing up
16:40:19 <bernardoct> I'm getting rÃ¡pido instead of rápido after the conversion
16:40:30 <bernardoct> It's messing up in a different way though
16:40:50 <bernardoct> before I would get a black diamond with a ? inside
16:41:01 <bernardoct> Now I am getting this type of weird stuff :(
16:42:04 <acowley> bernardoct: iconv -f iso-8859-1 -t utf-8 0085.htm | pandoc -s -r html -V lang=brazilian -o MST.markdown
16:42:16 <acowley> bernardoct: I think that worked right for me
16:42:35 <bernardoct> for this I must have the page saved in my computer, right?
16:42:39 <acowley> I used wget to save the page
16:42:53 <acowley> since iconv didn't like the URL filename
16:43:00 <bernardoct> I see, that was clever
16:43:01 <ClaudiusMaximus> bernardoct: what are you using to view the output? maybe the viewer is getting it wrong
16:43:25 <bernardoct> I was converting to html and openning in the same browser
16:43:38 <bernardoct> ClaudiusMaximus: I was converting to html and openning in the same browser
16:43:49 <bernardoct> I'll try the command acowley told me here
16:43:56 <acowley> bernardoct: curl http://www.olavodecarvalho.org/convidados/0085.htm | iconv -f iso-8859-1 -t utf-8 | pandoc -s -r html -V lang=brazilian -o MST.markdown
16:44:01 <acowley> that does it in one shot
16:44:34 <ClaudiusMaximus> bernardoct: i ask because Ã¡ looks like 2 chars, which is what you might get from UTF-8 being misinterpreted as ISO-8859-1 or whatever
16:45:11 <bernardoct> acowley: that was awesome, it worked nicely here, thank you a lot!
16:45:24 <acowley> bernardoct: great!
16:45:47 <bernardoct> ClaudiusMaximus: I see, I think I was messing up something else then. Thanks!
16:46:38 <bernardoct> Well guys, since we're already on the topic here, do you know any way for me to convert all the pages in the directory in a batch way?
16:46:48 <bernardoct> There are a ton of texts there that I would like to convert
16:48:13 <efie> I have a questions regarding the Functional Graph Library, especially the "shortest path" function - it seems that it does not work? can anyone help me?
16:48:15 <hpaste> efie pasted “FGL - sp does not work?” at http://hpaste.org/68410
16:48:15 <bernardoct> Also, I am having another problem with pandoc that I couldn't find a way out on google or on my own
16:48:31 <bernardoct> This page that I am converting has two pictures
16:49:09 <bernardoct> But pandoc is getting a wrong path to the pictures when converting
16:50:06 <bernardoct> it writes in the conversion file /images/barra.jpg and then it looks up at that path instead of /path to the saved page/images/barra.jpg
16:50:10 <bernardoct> Do you know why?
16:51:06 <ClaudiusMaximus> efie: i'm wildly guessing you need to give each edge a weight of 1 instead of 0, otherwise all possible paths have the same total weight 0 ?
16:53:41 <bernardoct> I am getting pandoc: /images/barra.jpg: openBinaryFile: does not exist (No such file or directory) as output from that conversion if I don't have the fake folder on my / directory
16:53:47 <efie> ClaudiusMaximus: thanks a lot! That fixed it ... !
16:55:44 <ClaudiusMaximus> efie: :)
17:11:06 <haziz> Who?
17:13:36 <haziz_> What do people think of "Write Yourself a Scheme in 48 Hours"?
17:15:12 <vodik> educational if you have the foundations down
17:15:30 <efie> in my programm I have a list of arguments and function which I want to evaluate with the first element of the list, then I want to pause 1 second, than call the function again, now with the second element of the list as an argument ... and so on, until infinity (when the end of the list is reached, the first element should be taken again and so on) how can I do this "loop"?
17:16:49 <Eduard_Munteanu> efie: mapM(_) with a suitable function over the list
17:17:06 <Eduard_Munteanu> But I have to ask...
17:17:11 <Eduard_Munteanu> What do you do with the result?
17:17:28 <vodik> you also have forever to wrap it in if you want it to constantly repeate
17:17:32 <geekosaur> doesn't sound like any of that requires IO, offhand.  also I think cycle wants to be part of that somewhere?
17:17:49 <vodik> geekosaur: can you sleep in pure code?
17:18:03 <geekosaur> hm, point
17:18:04 <Eduard_Munteanu> I guess you could, just not nicely :)
17:18:31 <vodik> forever $ forM_ list $ \x -> f x >> threadDelay ...
17:18:35 <vodik> something like that?
17:18:43 <acowley> cycle list
17:18:51 <vodik> thats better
17:19:00 <acowley> and you don't need the forever
17:19:05 <acowley> err
17:19:13 <vodik> forM_ (cycle list) $ \x -> f x >> threadDelay ...
17:19:15 <acowley> I think that's right
17:19:20 <acowley> yeah
17:19:28 <efie> its an IO function, I want to print different things on the screen after a few seconds pause, and repeat this forever
17:19:51 <Eduard_Munteanu> That should do then.
17:20:11 <vodik> efie: you already have to use IO to sleep
17:22:02 <efie> ok thanks :) I will try it
17:36:34 <bernardoct> Hi again guys, I am trying to convert a html page saved on my desktop to an epub file but it is doing something wrong with the image's path
17:36:52 <bernardoct> I am getting pandoc: /images/barra.jpg: openBinaryFile: does not exist (No such file or directory)
17:36:59 <bernardoct> and sometimes pandoc: ./../images/barra.jpg: openBinaryFile: does not exist (No such file or directory)
17:37:08 <bernardoct> Does anyone here knows what can I do to fix that?
17:39:32 <DanBurton> well after some messing around with my brainfuck interpreter, I am finally giving up and leaving it to StackOverflow to see if anyone comes up with a good solution http://stackoverflow.com/questions/10560124/using-cont-to-acquire-values-from-the-future-and-the-past
17:41:53 <efie> thanks vodik, it works now!
17:46:45 <parcs`> DanBurton: what is loopControl?
17:47:52 <parcs`> never mind, found it
17:48:14 <vodik> DanBurton: if you want i can show you mine
17:49:19 <vodik> DanBurton: its not the best code, but i represent code like this: data Op = Op Char | Loop [Op]
17:49:43 <vodik> DanBurton: then looping is as simple as let loop = brainfuck l >> whenValue loop in whenValue loop
17:50:26 <vodik> where "brainfuck" evals a list of Ops, and whenValue checks that the current cell has a value
17:52:21 <DanBurton> parcs`: it creates a Control
17:52:31 <vodik> DanBurton: https://github.com/simongmzlj/challenges/tree/master/brainfuck
17:52:32 <DanBurton> parcs`: you can find it in the github repo
17:53:16 <DanBurton> vodik: nice
17:54:21 <DanBurton> I really want to explore my design decision for representing a Program, though
17:57:55 <Veinor> does anybody have a link to that paper that shows how you can generate a graph of a haskell data structure?
17:58:03 <Veinor> that violates referential transparency in order to expose sharing
17:58:05 * hackagebot diagrams-core 0.5.0.1 - Core libraries for diagrams EDSL  http://hackage.haskell.org/package/diagrams-core-0.5.0.1 (BrentYorgey)
17:58:18 <Veinor> http://ittc.ku.edu/~andygill/papers/reifyGraph.pdf ah
18:03:07 <pakaran> hi
18:03:20 <pakaran> what would cause this error?  in an example file I found on the web
18:03:22 <pakaran> Prelude> :l ThreadDelay.hs
18:03:22 <pakaran> ThreadDelay.hs:19:8:
18:03:22 <pakaran>     Could not find module `System.Event.Thread'
18:03:22 <pakaran>     Use -v to see a list of the files searched for.
18:03:22 <pakaran> Failed, modules loaded: none.
18:06:50 <Veinor> pakaran: where'd you get that? system.event.thread isn't public afaik
18:06:51 <byorgey> pakaran: presumably System.Event.Thread is a module from some library that you do not have installed.
18:07:09 <rwbarton> it seems to be a hidden module in base in my version of ghc (7.0.4)
18:07:48 <rwbarton> anyways, you should delete that import line and then figure out where the identifiers you get errors about should be imported from
18:08:12 <rwbarton> possibly Control.Concurrent
18:08:50 <pakaran> do you want to see the code causing the issue?
18:09:18 <pakaran> https://github.com/tibbe/event/blob/master/benchmarks/ThreadDelay.hs
18:09:25 <pakaran> it's supposed to benchmark the garbage collecter
18:09:47 <Veinor> pakaran: that code is no longer used in GHC, as far as i know
18:10:03 <byorgey> oh, it's pretty old.  says 2 years ago was the last edit.
18:10:30 <rwbarton> well hoogle says that ensureIOManagerIsRunning is in GHC.Conc.IO, so I guess you can import it from there instead
18:11:12 <kallisti> would it be possible to have a typeclass for which it's only possible for TH to generate instances?
18:11:35 <vodik> pakaran: i could get it running in ghci -System.Event.Thread and +GHC.Conc.IO
18:11:49 <rwbarton> kallisti: class PleaseDoNotDeclareInstancesOfThisClassManually a where ...
18:11:59 <Veinor> haha
18:12:05 <rwbarton> class MyRealClass a; instance PleaseDoNotDeclareInstancesOfThisClassManually a => MyRealClass a
18:12:14 <vodik> pakaran: remove the #ifdef/#endif and go for Control.Conccurent
18:12:48 * kallisti was hoping he could come with some reversible computing scheme with a TH verifier.
18:12:54 <kallisti> *come up
18:13:23 <pakaran> ok, now Control.Concurrent.STM is missing
18:13:30 <pakaran> should I remove that import line as well?
18:15:13 <vodik> pakaran: no, that you just must not have installed
18:15:16 <vodik> http://hackage.haskell.org/packages/archive/stm/latest/doc/html/Control-Concurrent-STM.html
18:15:21 <kallisti> rwbarton: basically a variant of LogicT where all computations are instances of a particular typeclass for which it's impossible to make instances of without the use of TH.
18:15:46 <kallisti> which has to verify that the computation and its inverse and just that.
18:16:01 <kallisti> (to some degree of accuracy)
18:17:00 <byorgey> pakaran: just  cabal install stm
18:17:34 <pakaran> byorgey, what's the command?
18:17:47 <byorgey> cabal install stm
18:21:56 <pakaran> ah, i didn't have cabal installed
18:21:56 <pakaran> thanks
18:38:34 <JoeyA> @quote
18:38:34 <lambdabot> BONUS says: i have not forsaken anybody!!!  i am just equal parts busy and lazy
18:51:59 <Eduard_Munteanu> preflex: xseen BONUS
18:51:59 <preflex>  BONUS was last seen on freenode/#haskell 1 year, 12 days, 6 hours and 24 minutes ago, saying: yeah i think that's better as well
18:53:32 <parcs`> bonus is apparently too cool to irc after writing a book :(
18:53:55 <JoeyA> Who's bonus?
18:54:28 <parcs`> the author of LYAH
18:58:22 <zzo38> pathfinder _ g h | g == h = return h; pathfinder s g h = WriterT ((\x -> (x, [x])) <$> (s !! h)) >>= pathfinder s g;    It is one way to find all the paths you can go.
18:59:15 <zachk> he might be ircing, just under a different nick
18:59:16 <zzo38> It could certainly to add more complicated things too
19:08:43 <coldpizza72i> How can i check if the first element in my list is a list?
19:08:51 <kallisti> um
19:08:58 <kallisti> look at its type signature?
19:09:36 <kallisti> if you have a list of lists, the only type of element it can contain is lists.
19:09:37 <zachk> coldpizza72i: check the type signature of the overall list it needs to be at least: [[a]] or deeper
19:10:01 <coldpizza72i> oh
19:10:25 <Elemir> Pythonist logic itt
19:12:26 <JoeyA> let firstItemIsList :: [[a]] -> Bool; firstItemIsList [] = error "List is empty.  What do I do?"; firstItemIsList (_:_) = True
19:13:08 * hackagebot hedis-tags 0.2.0 - Tags for hedis  http://hackage.haskell.org/package/hedis-tags-0.2.0 (AlexanderDorofeev)
19:19:53 <zachk> joeyA: what are you attempting to code, exactly?
19:22:05 <kallisti> not JoeyA, but coldpizza72i
19:22:15 <kallisti> it was an answer to a question.
19:22:42 <kallisti> any bets on what database I'll be using in my database class?
19:22:49 <kallisti> I'm guessing either MySQL or SQLite.
19:22:55 <vodik> shouldn't it be firstItemIsList ([_]:_) = True ?
19:23:14 <vodik> oh nm, guess that doesn't work
19:23:38 <vodik> i see, its all in the type
19:23:56 <kallisti> if you want to distinguish bottom from a list you'd have to do some case analysis.
19:24:06 <kallisti> but otherwise the first version is sufficient.
19:24:17 <kallisti> for... this "purpose"
19:24:30 <vodik> let firstItemIsList :: [[a]] -> Bool; firstItemIsList = not . null . take 1
19:25:33 <kallisti> I ask because I have a personal project where I want to use a database. I'm already familiar with postgres, so I want to learn a database that isn't postgres and isn't the one that my class is going to use.
19:26:38 <tgeeky> kallisti: that sounds like you're inviting yaks into your living room who need shaving
19:27:14 <zachk> vodik: wouldn't that crash on [] ?
19:27:29 <vodik> > take 1 []
19:27:30 <lambdabot>   []
19:27:32 <vodik> zachk: yup
19:27:45 <kallisti> tgeeky: yep. this year has been nothing but yak shaving.
19:27:48 <vodik> idk if its right though
19:28:05 <vodik> zachk: i mean it won't crash
19:41:03 <bernardoct> Hi guys, I am trying to convert a html page saved on my desktop to an epub file but it is doing something wrong with the image's path
19:41:07 <bernardoct> I am getting pandoc: /images/barra.jpg: openBinaryFile: does not exist (No such file or directory)
19:41:27 <bernardoct> for others I get pandoc: ./../images/barra.jpg: openBinaryFile: does not exist (No such file or directory)
19:41:30 <bernardoct> Does anyone here knows what can I do to fix that?
19:41:32 * gwern bans another spammer from hawiki. I wonder how many I've done.
19:41:38 <gwern> bernardoct: what are all the paths involved?
19:41:55 <bernardoct> Hang on, let me open the file again
19:42:26 <bernardoct> gwern: <img src="/images/titulo.jpg" wid......
19:42:27 <gwern> huh. I've done somewhere between 3000-3500 administrator actions on hawiki
19:42:51 <gwern> bernardoct: surely your root filesystem doesn't have a images/?
19:42:58 <bernardoct> gwern: and <img src="../images/titulo.jpg".....
19:43:05 <bernardoct> Yes
19:43:27 <bernardoct> Actually, I created a folder /images in the root filesystem and put the images there for it to work
19:43:31 <gwern> o.0
19:43:41 <tgeeky> gwern: hey. don't judge. that's pragmatism.
19:43:51 <bernardoct> gwern: but I don't want to need to do that
19:43:53 <gwern> tgeeky: no, I think I will judge
19:44:07 <bernardoct> gwern: depending on the path I get from a website it might not work
19:44:38 <bernardoct> gwern: Ah, by the way, I'm using pandoc for the task
19:44:40 <gwern> bernardoct: pandoc as far as I know, just follows the path as you write it, based on where you invoke it
19:45:09 <bernardoct> gwern: what do you mean?
19:45:31 <gwern> the ../ is relative to the pandoc process, not the file, I think is the sentence I mean
19:45:40 <bernardoct> gwern: if the website didn't have those figures it would work fine, which means it reads the page and all
19:46:08 <bernardoct> for it to have ../ I imagined it would work
19:46:14 <bernardoct> But it doesn't :(
19:48:35 <gwern> bernardoct: I've never managed to make my personal hakyll site with its absolute links (image or otherwise) work with both the final remote website and the local preview
19:49:15 <bernardoct> I see
19:49:47 <bernardoct> I gues I'll have to change the path at the html page and then convert it then
19:49:56 <bernardoct> gwern: well, thanks for the help!
19:52:15 <crdueck> i'm still having trouble intuiting typeclasses and instances, could someone explain why i get this error?  http://sprunge.us/BaAe
19:52:44 <yan_> what does a 'type' statement do inside a class definition?
19:52:58 <kallisti> yan_: that's a type family.
19:53:14 <kallisti> crdueck: you can't sqrt an integer
19:53:17 <kallisti> is what it's saying
19:53:22 * yan_ googles for type families
19:54:44 <kallisti> crdueck: sqrt is method on Floating. So you need to convert the Integer to some floating instance in order to call sqrt.
19:54:52 <kallisti> something like
19:55:10 <kallisti> intSqrt = floor . sqrt . fromIntegral
19:55:11 <kallisti> perhaps
19:55:29 <kallisti> or maybe round.
19:56:00 <crdueck> kallisti: okay, i was confused because "sqrt 4" works find in ghci, but thats because it was converting from an Int automatically correct?
19:56:19 <kallisti> yes. an integer literal is overloaded on any Num instance.
19:56:31 <kallisti> as though it were: fromIntegral (4 :: Integer)
19:58:10 <kallisti> http://hackage.haskell.org/packages/archive/arithmoi/0.2.0.3/doc/html/Math-NumberTheory-Powers-Squares.html  here's a module on Hackage with an efficient integer square root
19:58:49 <kallisti> it uses SPECIALISE pragmas and such to make it more efficient on specific integral types.
19:59:22 <tazjin> @src any
19:59:22 <lambdabot> any p =  or . map p
20:00:33 <tgeeky> kallisti: unless it includes benchmarks, you might not want to say that :o
20:00:42 <tgeeky> but arithmoi is an awesome package
20:00:57 <kallisti> it's certainly faster than the naive approach.
20:02:25 <kallisti> crdueck: but if efficiency isn't a concern and you don't want to install anything then floor . sqrt . fromIntegral should work fine for integer sqrt.
20:02:37 * kallisti has some similar code for calculating factors.
20:04:14 <kallisti> tgeeky: any idea what the moi in arithmoi means?
20:04:57 <tgeeky> kallisti: (arithm)etic (o)n (i)ntegers
20:05:02 <kallisti> ah
20:06:12 <cmears> Looks like also a Greek word
20:15:22 <cads> darn, now I want to research integer square root finding
20:17:17 * cads has been reading about general root finding algorithms
20:18:10 * hackagebot hedis-pile 0.6.0 - Caching mandatory data with Redis  http://hackage.haskell.org/package/hedis-pile-0.6.0 (AlexanderDorofeev)
20:26:19 <cads> Hmm, supposing you want to find sqrt(a), I bet root finding on y = x^2 - a with the newton method wouldn't be that bad
20:27:53 <cads> but I have a feeling that we could much better use the structure of the problem
20:28:10 * hackagebot wai-middleware-cache-redis 0.4.0 - Redis backend for wai-middleware-cache  http://hackage.haskell.org/package/wai-middleware-cache-redis-0.4.0 (AlexanderDorofeev)
20:30:54 <dangsos> sup shapr
20:42:45 <bernardoct> Hey everyone, is there a way to make pandoc ignore figures in a conversion, having only text in the output file?
21:08:10 <applicative> bernardoct: what are you converting from; what sort of  figures
21:08:41 <bernardoct> jpg
21:08:55 <bernardoct> I have those figures at the website but I want to creat a ebook with only text
21:09:29 <applicative> the text you are starting from is html?
21:09:37 <bernardoct> yes
21:10:13 <applicative> are you going direct to epub or whatever or first inspecting the markdown?
21:10:34 <bernardoct> it doesn't matter to me
21:10:54 <bernardoct> I am trying to go directly to epub now
21:11:06 <bernardoct> I haven't tryied to convert to markdown before
21:11:07 <applicative> do you want simply to delete the image references?
21:11:32 <bernardoct> I guess the whole image thing
21:11:46 <bernardoct> I just don't want the image to appear in the epub file because the image is too big
21:11:57 <bernardoct> And it would be a pain to have it in the ebook reader
21:12:46 <bernardoct> I tryied to see if there was a command "ignore images" like , or something as "text only" but I couldn't find it
21:12:58 <applicative> markdown has  the advantage that its just ordinary text, so you can see.  The image references are like ![PhilippaFoot](../Desktop/PhilippaFoot.jpeg)
21:13:59 <bernardoct> So then it would be easier to eliminate it with a shell script and sed command, right?
21:14:01 <applicative> no,  it kills off a lot of html but keeps image references.  If you know regular expressions you could kill them of
21:14:15 <applicative> right, you see my meaning
21:15:17 <applicative> if you know a programming language with a json library, you can morph the json output.  Did you install pandoc with cabal install, or download a binary
21:16:04 <bernardoct> via cabal install
21:16:11 <bernardoct> I don't have a clue on what json is hehehe
21:16:20 <applicative> there is the 'scripting with pandoc' way http://johnmacfarlane.net/pandoc/scripting.html
21:16:23 <bernardoct> I'm pretty much a beginner with this kind of stuff
21:16:56 <applicative> It doesn't matter.  Do  you have the haskell platform  and ghc and all, or did you get pandoc separately
21:17:28 <applicative> we can write a haskell script in one minute, but you need the compiler
21:18:03 <bernardoct> Well, I don't really know what haskell is
21:18:24 <bernardoct> I'm here because I typed pandoc irc on google and this came up
21:18:29 <applicative> how did you install pandoc?
21:18:37 <bernardoct> cabal install pandoc
21:18:46 <bernardoct> I installed cabal and then pandoc
21:19:03 <applicative> ok that answers it, you have the Glorious Glasgow Haskell Compiler.
21:19:13 <bernardoct> Uuuhh, how cool :)
21:19:15 <bernardoct> heheh
21:19:42 <bernardoct> Even though I don't really know what that means, I just know what a compiler is
21:20:01 <applicative> look at the scripting page http://johnmacfarlane.net/pandoc/scripting.html
21:20:14 <bernardoct> I took a look at it now
21:20:23 <bernardoct> I'll try to understand that and code some
21:20:28 <bernardoct> Thanks :)
21:20:39 <applicative> your case is similar to to the ones toward the bottom
21:21:09 <applicative> what operating system are you using?
21:21:21 <bernardoct> ubuntu
21:21:34 <applicative> ok
21:22:15 <applicative> the command will be a unix pipeline pandoc -f html -t json | runghc killimagereferences.hs | pandoc -f json -t epub
21:22:25 <applicative> or whatever we name the file.
21:23:15 <applicative> pandoc will parse it to the lingua franca json, we'll transform the json , pandoc will read it into epub
21:23:22 <applicative> this is the standard way now
21:23:29 <applicative> it seems
21:23:34 <bernardoct> I see
21:23:42 <kallisti> for some reason haskell-mode wants to interpret the inside of a quasiquote as still having Haskell indentation rules..
21:23:49 <kallisti> quite annoying
21:23:59 <applicative> so we have to figure out what the constructor of an image reference is in the Pandoc grammar or AST
21:24:01 <applicative> just a sec
21:24:02 <bernardoct> actually, I am creating a sh script to convert a lot of pages at the same time
21:24:14 <bernardoct> And I already have to run iconv to convert encoding
21:24:25 <bernardoct> the command I'm using inside the loop is iconv -f iso-8859-1 -t utf-8 $file | pandoc -s -r html -V lang=brazilian -o $file.epub
21:24:31 <bernardoct> ok, go there
21:24:51 <bernardoct> kallisti: I don't really get what you said
21:25:32 <kallisti> bernardoct: what part?
21:25:42 <applicative> oh yes, you must have utf8 or all hell breaks loose
21:25:44 <bernardoct> anything... :(
21:25:58 <kallisti> haskell-mode = emacs haskell mode
21:26:02 <kallisti> it does auto indents and syntax highlighting
21:26:16 <kallisti> a quasiquote can contain basically any string, yet haskell-mode still interprets it as though it's just Haskell code.
21:26:36 <applicative> https://github.com/jgm/pandoc-types/blob/master/Text/Pandoc/Definition.hs -- on line 144 is the bit of the definition of an inline
21:26:50 <applicative> rather of the Image kind of Inline
21:27:36 <bernardoct> kallisti: I guess I understood more or less :)
21:28:57 <bernardoct> applicative: how would I change this command to merge it with the pipeline you wrote earlier?
21:29:09 <bernardoct> sorry but all this is pretty confusing to me as I'm now
21:29:18 <applicative> well, i have to finish the haskell module
21:29:30 <applicative> or i did i'm testing it
21:29:37 <bernardoct> applicative: Ah, ok, sorry
21:30:10 <bernardoct> the page I'm trying to convert is http://www.olavodecarvalho.org/convidados/0085.htm
21:31:23 <hpaste> applicative pasted “remove images” at http://hpaste.org/68416
21:31:42 <bernardoct> I'm trying to get all the texts the guy has in his website and transform it in a ebook
21:31:48 <bernardoct> They are pretty long and a pain to read
21:31:51 <x[LGWs4x4i]uG2N0> i have an old haskell program that doesn't build with ghc 7, due to not finding the Network.Socket module
21:32:04 <applicative> here's the script its just like the one for 'removing links'
21:32:08 <x[LGWs4x4i]uG2N0> what should i do to make it work?
21:32:14 <bernardoct> The guy is a philosofer that has a website with lots of texts, so I'm trying to do this to send to him to be posted there for people to read
21:32:31 <bernardoct> applicative: I'll try it here
21:32:35 <bernardoct> applicative: thanks!
21:33:46 <applicative> so just save it as whatever.hs  then runghc whatever.hs is the middle link in the chain   pandoc -f html -t json | runghc whatever.hs | pandoc -f json -t epub
21:34:53 <bernardoct> I'll try it here and tell you if I was able to run it properly
21:34:55 <bernardoct> Hang on
21:35:00 <applicative> here you are using runghc  as an interpreter. You can also compile it, if it is slow.  ghc --make -O2 whatever.hs -o $HOME/bin/removeimages
21:35:31 <applicative> supposing you have some directory in path, i invented $HOME/bin for you since I have one
21:36:26 <applicative> the advantage of this method is that you can use the input relevant command line options on the left end of the pipeline, and the output options on the left
21:37:01 <applicative> so i don't know where the brazilian part comes in, I guess it must affect output
21:37:42 <applicative> it should be pandoc -f html -t json mydoc.html | runghc whatever.hs | pandoc -f json -t epub -o mydoc.epub or whatever, of course
21:38:20 <applicative> bernardoct: do you know about the Pandoc mailing list?  Questions like yours come up all the time
21:39:24 <applicative> there could be trivial errors, i couldn't test it because my pandoc library is broken, i'm trying to reinstall
21:41:56 <bernardoct> I'm redownloading the pages here to try again because I did something wrong with them
21:42:02 <bernardoct> I don't know about this list
21:42:11 <bernardoct> How do I join it?
21:43:27 <applicative> http://groups.google.com/group/pandoc-discuss
21:43:48 <tgeeky> jfischoff: did you make the "instance PPrint stuff"?
21:44:38 <jfischoff> tgeeky: yes and no. I made a Print class which I took out when I merged with dmwit
21:44:59 <jfischoff> tgeeky: if you see a better way, fix it
21:45:06 <tgeeky> jfischoff: can you figure out how to make: instance PPrint [UValue] where ppr = ???
21:45:10 <jfischoff> tgeeky: wait
21:45:20 <jfischoff> ha
21:45:31 <jfischoff> not even close
21:45:35 <tgeeky> that's his?
21:45:49 <jfischoff> yeah but I have faith in it
21:46:22 <tgeeky> jfischoff: ok. There isn't one for [UValue] but I'd like one. I'm (incorrectly) doing: ppr = show . head -- for now
21:46:52 <applicative> man pandoc takes forever to install esp if you have -prof inyour  cabal conf
21:47:11 <tgeeky> applicative: yeah. One big turnoff for me. :o
21:47:13 <jfischoff> tgeeky: I have a derivative grammar that might be easier to work with for simple things.
21:47:35 <tgeeky> jfischoff: sounds interesting. is it pushed? link?
21:47:45 <jfischoff> I could paste
21:47:50 <applicative> highlighting-kate is infinitely faster than before, for what its worth
21:47:50 <tgeeky> ok
21:49:30 <tgeeky> applicative: oh interesting. I thought this was written with alex lexers (or happy whatever-happy-makes?)
21:49:34 <tgeeky> was that illuminate?
21:49:36 <applicative> x[LGWs4x4i]uG2N0: did someone say it's in the Network package?
21:49:39 <jfischoff> tgeeky: I pushed my stuff: https://github.com/jfischoff/pi-eta-epsilon/blob/master/src/Language/PiEtaEpsilon/BNFMeta/Term.hs
21:49:56 <jfischoff> tgeeky: there is one for Value too
21:50:13 <bernardoct> applicative: I'm trying to work with the script you wrote to me but I am getting an error
21:50:22 <tgeeky> jfischoff: oh neat! this might be just what I was looking for.
21:50:24 <bernardoct> should I just past the 6 ou 7 lines of error here?
21:50:29 <applicative> no, he just did something to highlighting kate, it hadn't occured that it bothered people it was the longest install on hackage:)
21:50:37 <jfischoff> tgeeky:bnfc-metat
21:50:43 <jfischoff> bnfc-meta
21:50:47 <applicative> bernardoct: not surprising, my new pandoc is almost installed
21:51:09 <x[LGWs4x4i]uG2N0> applicative ghc did
21:51:16 <x[LGWs4x4i]uG2N0> when doing ghc --make
21:51:37 <applicative> do you have the network package? ghc-pkg list should show it
21:51:41 <bernardoct> applicative: alright, I'll be here waiting
21:52:17 <x[LGWs4x4i]uG2N0> applicative it turns out i don't!
21:52:22 <x[LGWs4x4i]uG2N0> thanks
21:52:41 <x[LGWs4x4i]uG2N0> is this a new thing? i'm pretty sure the network package used to come with ghc
21:52:54 <applicative> how  did you install ghc, x[LGWs4x4i]uG2N0
21:53:05 <applicative> i think it is now separated out into the 'haskell platform'
21:53:07 <x[LGWs4x4i]uG2N0> i installed the ghc port on freebsd
21:53:45 <applicative> do they have a port like haskell-network, or better haskell-platform?
21:54:16 <x[LGWs4x4i]uG2N0> ah yeah, there's haskell-platform
21:54:40 <x[LGWs4x4i]uG2N0> thanks again
21:54:45 <applicative> yeah you should install that, it includes a bunch of things that used to come with ghc
21:55:16 <tgeeky> jfischoff: ok. if I give you a patch with an example, will you write some doctests?
21:55:22 <applicative> and then various other swank things. some wont be of use, but it's sort of the standard lingua franca
21:55:35 <tgeeky> jfischoff: either way, are there examples of using what this quasiquoter creates?
21:55:42 <jfischoff> tgeeky: depends what is it ;)
21:56:04 <jfischoff> tgeeky: yes I have written some.
21:56:23 <applicative> somehow i know this pandoc install is going to fail at the end with some triviality about installing the man pages
21:56:27 <jfischoff> tgeeky: … and it is in the package unpack to see
21:56:31 <tgeeky> jfischoff: it's a think that runs comments of the form: -- >>> expression        \n -- result       as tests.
21:56:54 <applicative> x[LGWs4x4i]uG2N0: did you used to use haskell some time in the past?
21:57:02 <x[LGWs4x4i]uG2N0> applicative yeah
21:57:03 <tgeeky> s/think/thing/
21:57:17 <x[LGWs4x4i]uG2N0> i wrote a httpd back in 2005
21:57:23 <x[LGWs4x4i]uG2N0> or 2006
21:57:25 <applicative> the could be other curiosities, the type checker is changed.
21:57:48 <x[LGWs4x4i]uG2N0> that i want to use on a new machine :)
21:58:23 <jfischoff> tgeeky: that's right. You should just rewrite The type parser with bnfc-meta. I'm almost done with Term and Value.
21:58:33 <applicative> i dont know if already in ghc-7.0.4 they are enforcing Haskell-2010 or whatever, which means List  must be written Data.List,  Monad as Control.Monad, several little things
21:59:19 <applicative> if you have things like that there will be very obscure errors, you just have to change them
21:59:28 <x[LGWs4x4i]uG2N0> ah
22:00:29 <kallisti> SQL is neat.
22:00:32 <applicative> you also cant write "fib (n+1) = fib n + fib (n-1), but fib n =fib (n -1) + fib (n-2)
22:00:43 * kallisti just set up a rule in postgres that deletes a row when an update matches a given condition.
22:00:52 <kallisti> less logic for my code to care about. :P
22:01:25 <applicative> x[LGWs4x4i]uG2N0:  anyway, people here can explain them when they come up
22:01:42 <x[LGWs4x4i]uG2N0> i think i can figure it out
22:01:57 <applicative> bernardoct: sorry, i'm still compiling the cursed library...
22:02:22 <bernardoct> applicative: no problem, you're helping me a lot. Just take your time there
22:02:47 <applicative> x[LGWs4x4i]uG2N0: yes its trivial, the one about the import names is surprisingly opaque when you first bump into it
22:04:46 <applicative> bernardoct: oh i think i see what the error is, its a change in the library
22:05:38 <bernardoct> I imagined
22:05:46 <bernardoct> it said that something was deprecated
22:05:59 <x[LGWs4x4i]uG2N0> lol haskell-platform needs x11
22:06:28 <x[LGWs4x4i]uG2N0> i think i'll just install the network package
22:12:24 <hpaste> applicative annotated “remove images” with “remove images (annotation)” at http://hpaste.org/68416#a68417
22:13:00 <applicative> bernardoct: it's even easier than before, the page needs to be updated  ^^^
22:14:52 <applicative> with runhaskell removeimage.hs it's a little clunky.  you can test it doing ghc --make -O2 removeimage.hs then test it from the directory: pandoc -r html -w json my.html | ./removeimage etc
22:15:33 <applicative> runhaskell and runghc are the same command, unless you have another haskell implementation
22:15:35 <bernardoct> applicative: it worked!
22:15:49 <bernardoct> applicative: thanks man! Tha was really usefull!
22:15:56 <bernardoct> I see
22:16:00 <applicative> oh great. there are likely to be other difficulties, the list can help
22:16:10 <bernardoct> Ok, I'll fix my script now
22:16:19 <applicative> well good night!
22:16:20 <bernardoct> Alright, I'll join it now
22:16:26 <bernardoct> Good night!
22:24:38 <JoeyA> @hoogle (a -> Either header item) -> [a] -> [(header, [item])]
22:24:39 <lambdabot> Did you mean: (a -> Either Header item) -> [a] -> [(Header, [item])]
22:24:39 <lambdabot> No results found
22:26:55 <JoeyA> Is there a library function somewhere that groups items by header?  For example, given the list: [H 10, C 11, C 12, C 13, H 20, C 21, C 22, C 23]
22:28:14 <JoeyA> I want to group headers with their children, giving [10 # [11,12,13], 20 # [21, 22, 23]]
22:28:29 <JoeyA> (where # is an infix synonym of (,) for readability)
22:29:56 <JoeyA> I've run into this situation more than once.
22:30:31 <JoeyA> A better signature might be: (a -> Either header item) -> [a] -> ([item], [(header, [item])])
22:30:52 <JoeyA> (to allow for items that precede a header)
22:31:32 <JoeyA> I could implement this easily enough; I'm just wondering if someone's already done it for me.
22:32:26 <JoeyA> @djinn (a -> Either h i) -> [a] -> ([i], [(h, [i])])
22:32:26 <lambdabot> Error: Undefined type []
22:42:32 <mysticc> JoeyA: Thats a simple fold ..
23:08:17 <JoeyA> @hoogle [Either h i] -> ([i], [(h, [i])])
23:08:17 <lambdabot> No results found
23:23:40 <JoeyA> mysticc: Ah, thanks for pointing that out.  It is a simple right fold.
23:23:44 <hpaste> “Joey Adams” pasted “groupByHeader is a simple right fold” at http://hpaste.org/68418
23:29:24 <kallisti> haskell-mode really really messes up quasiquotes
23:29:28 <kallisti> to the point of being unusable
23:40:34 <oelewapperke> what does the !! operator mean in haskell ?
23:41:15 <Axman6> look at the type, test it and find out ;)
23:41:18 <Axman6> :t (!!)
23:41:19 <lambdabot> forall a. [a] -> Int -> a
23:41:30 <Axman6> > "Hello" !! 1
23:41:30 <lambdabot>   'e'
23:42:56 <oelewapperke> thanks. Can I see the source for it too ?
23:45:17 <Axman6> @src
23:45:17 <lambdabot> src <id>. Display the implementation of a standard function
23:45:20 <Axman6> @src (!!)
23:45:20 <lambdabot> xs     !! n | n < 0 = undefined
23:45:20 <lambdabot> []     !! _         = undefined
23:45:20 <lambdabot> (x:_)  !! 0         = x
23:45:20 <lambdabot> (_:xs) !! n         = xs !! (n-1)
