00:06:27 <dmwit> MaskRay: Could not reproduce
00:06:38 <dmwit> MaskRay: It tells me all about class Uniplate when I try that.
00:06:50 <jonaskoelker> dirty state in ghci?
00:07:08 <dmwit> State? In *my* Haskell??!
00:07:15 <jonaskoelker> ^_^
00:07:27 <jonaskoelker> dirty Reader in ghci? :-P
00:07:28 <MaskRay> i can not reproduce now after the upgrade of uniplate
00:08:22 <MaskRay> make sure it buried in the past and no longer regard it
00:20:25 <sp3ctum> @src or
00:20:26 <lambdabot> or    =  foldr (||) False
00:20:47 <sp3ctum> regarding that, does the compiler optimise it so that every element is not traversed?
00:21:32 <sp3ctum> ...since only one has to evaluate to True for the result to be True
00:21:59 <Iceland_jack> @src (||)
00:21:59 <lambdabot> True  || _ =  True
00:22:00 <lambdabot> False || x =  x
00:22:21 <Iceland_jack> the compiler doesn't evaluate what ever comes after a True ||
00:22:46 <sp3ctum> ah, smart
00:23:14 <sp3ctum> really beautiful!
00:25:50 <sp3ctum> lazy evaluation feels very natural to me. a natural way to work/write
00:25:59 <sp3ctum> perhaps it's in my nature :)
00:26:11 <Iceland_jack> heh
00:26:22 <sp3ctum> but i've also heard that it's a good trait for a programmer
00:26:38 <Iceland_jack> According to a programmer anyhow
00:26:44 <Iceland_jack> so take it with a grain of salt ;)
00:28:26 <sp3ctum> hehe, you might be right
01:13:10 <jtobin> anyone care to hazard a guess: why might a call to `main` work in ghci, but not when compiled?
01:13:25 <jtobin> compiled completely vanilla
01:15:25 <ehamberg> what happens? which version of ghc?
01:15:44 <ion> jtobin: Embrace the awesome power of error messages.
01:15:51 <shachaf> ion++
01:16:32 <jtobin> 7.4.1.  if i load a .hs file directly in ghci, i can call main and get an expected answer
01:17:21 <jtobin> when compiled (it compiles fine) it doesn't produce the same answer.  actually, i think i've just spotted the problem..
01:18:06 <jtobin> it's using STM.  multiple calls to `main` in ghci will produce different answers, some with long strings of errors.  every time i've run the compiled code i just get long strings of errors.
01:18:12 <JoshTriplett> Does some sensible means exist to make (Writer [String] (a -> b)) an instance of Category, such that I can have (.) :: Writer [String] (b -> c) -> Writer [String] (a -> b) -> Writer [String] (a -> c) ?
01:18:19 <jtobin> even though it's not compiled with -threaded, i guess i expected the output to match ghci's
01:18:37 <JoshTriplett> Seems like it ought to work, except that the type parameters appear in the wrong place for a straightforward instance declaration to work.
01:18:38 <jtobin> er, *since it's not compiled with -threaded, rather
01:19:32 <JoshTriplett> @hoogle m (b -> c) -> m (a -> b) -> m (a -> c)
01:19:33 <jtobin> i guess i've just got a thread synchronization problem
01:19:33 <lambdabot> Data.Generics.Schemes everywhereBut :: GenericQ Bool -> GenericT -> GenericT
01:19:42 <JoshTriplett> That was remarkably unhelpful. :)
01:19:50 <JoshTriplett> @hoogle Monad m => m (b -> c) -> m (a -> b) -> m (a -> c)
01:19:51 <lambdabot> Data.Generics.Schemes everywhereBut :: GenericQ Bool -> GenericT -> GenericT
01:22:36 <ClaudiusMaximus> JoshTriplett: "type paramters in wrong place" suggests to me "use a newtype wrapper to put them in right place"
01:22:48 <JoshTriplett> ClaudiusMaximus: Right, except that I'd like to not have the newtype wrapper. :)
01:23:26 <JoshTriplett> I'd love to write mf . mg rather than unMagic $ Magic mf . Magic mg.
01:24:07 <JoshTriplett> @pl liftM2 (.)
01:24:08 <lambdabot> liftM2 (.)
01:24:17 <JoshTriplett> Does "liftM2 (.)" have a name?
01:24:32 <shachaf> Not other than that.
01:24:35 <JoshTriplett> Sigh.
01:24:38 <ClaudiusMaximus> JoshTriplett: well, i ended up wasting 2 days and suffering much trying to do something similar without a newtype; note that you can't make instamces for partially applied type synonyms...
01:24:49 <JoshTriplett> ClaudiusMaximus: Yeah, I found that out by trying. :)
01:25:36 <JoshTriplett> Context: I want to construct a huge family of functions with associated descriptions, try them all out on a set of data, and report the associated descriptions of any functions that seem to work.
01:25:54 <JoshTriplett> So I figured I could construct the functions in the Writer monad, and use that to accumulate the descriptions.
01:26:26 <JoshTriplett> Having the ability to use (.) on those functions to combine them would help greatly.
01:30:22 <JoshTriplett> @pl length . filter pred f
01:30:22 <lambdabot> length . filter pred f
01:33:10 <ion> joshtriplett: (| mf . mg |), i think, but you’ll need a code preprocessor for that at the moment AFAIU.
01:33:24 <ion> joshtriplett: A.k.a. banana brackets.
01:33:31 <JoshTriplett> ion: I gave up and wrote mdot = liftM2 (.)
01:33:36 <JoshTriplett> And then used `mdot`.
01:36:35 <ion> Oh, it seems the Arrows extension uses (| … |) for something else.
01:36:56 <JoshTriplett> ion: I feel certain I could do something clever with TH, but I don't want to go there. :)
01:38:55 <absence> is pattern matching with a precise amount of underscores the only way to tell which data constructor was used?
01:39:06 <ion> Foo {}
01:39:54 <absence> ion: thanks
01:43:40 <dmwit> ?pl \mf x -> do { f <- mf; return (f x) }
01:43:41 <lambdabot> (line 1, column 13):
01:43:41 <lambdabot> unexpected "{"
01:43:41 <lambdabot> expecting variable, "(", operator or end of input
01:43:54 <dmwit> ?pl \mf x -> mf >>= return . ($x)
01:43:54 <lambdabot> flip (fmap . flip id)
01:44:26 <dmwit> JoshTriplett: If you would have a -> Writer blah b instead of Writer blah (a -> b), you could use (>=>).
01:44:42 <dmwit> :t flip (fmap . flip id) -- ?
01:44:43 <lambdabot> forall b (f :: * -> *) a. (Functor f) => f (a -> b) -> a -> f b
01:44:46 <JoshTriplett> @type (>=>)
01:44:47 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
01:45:00 <absence> can data constructors be passed to functions (e.g. "isType InputEvent someEvent")?
01:45:07 <JoshTriplett> absence: Yes.
01:45:14 <JoshTriplett> absence: A data constructor acts exactly like a function.
01:45:18 <dmwit> absence: Yes, but you won't be able to use them to pattern match after that.
01:45:29 <dmwit> absence: I mean isType can't use one of its arguments as part of a pattern.
01:46:04 <JoshTriplett> absence: Given "data D a b = Constructor a String b", Constructor :: a -> String -> b -> D a b
01:46:04 <dmwit> absence: However, see e.g. Typeable.
01:46:46 <shachaf> JoshTriplett: Given "data D a b where Constructor :: a -> String -> b -> D a b", Constructor :: a -> String -> b -> D a b!
01:47:26 <dmwit> absence: I meant Data, not Typeable.
01:47:28 <JoshTriplett> shachaf: Yes, I like that extension too, but that doesn't help explain the equivalence. ;)
01:47:33 <dmwit> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Data.html#v:toConstr
01:55:11 <newsham> http://www.meetup.com/dynamic/events/63061002/   slides and video
01:56:41 <nomeata> Hi. I’m collecting way to avoid sharing. I know about lifting a value under a lambda ([1..10000] becomes (\() -> [1..10000]) and church-encoding the data types. Any other approaches that I should consider?
01:57:02 <absence> dmwit: interesting. how do i make "InputEvent" into a Constr for the comparison?
02:02:08 <augur> now why the hell is this happening
02:02:21 <augur> with the definition
02:02:21 <augur> shuffle :: [a] -> [a] -> [[a]]
02:02:21 <augur> shuffle _ _ = []
02:02:28 <augur> and expression shuffle [2,3] (shuffle [5] [6,7])
02:02:32 <augur> i get the following type error:
02:02:41 <augur>     No instance for (Num [a0])
02:02:41 <augur>       arising from the literal `3'
02:02:41 <augur>     Possible fix: add an instance declaration for (Num [a0])
02:02:43 <augur>     In the expression: 3
02:02:45 <augur>     In the first argument of `shuffle', namely `[2, 3]'
02:02:47 <augur>     In the second argument of `($)', namely
02:02:49 <augur>       `shuffle [2, 3] (shuffle [5] [6, 7])'
02:02:57 <augur> well, the full expression is main = putStr $ show $ ...
02:03:17 <vertue> I am getting a SqlError *** Exception: SqlError {seState = "", seNativeError = 5, seErrorMsg = "disconnect: unable to close due to unfinalised statements"}
02:03:36 <vertue> i think it is on closing the connection
02:03:49 <vertue> but I am completely lost...
02:04:22 <quicksilver> augur: (don't paste so many lines)
02:04:27 <augur> quicksilver: :P
02:04:32 <quicksilver> augur: because you've made shuffle return a list of lists
02:04:40 <quicksilver> it cannot then be used as a parameter to itself
02:04:47 <augur> oh true
02:05:00 <augur> but when i just do shuffle [] [] i also get an error
02:05:00 <quicksilver> as for why that *exact* error
02:05:12 <quicksilver> that's because [2,3] is a list of Nums
02:05:21 <quicksilver> and your other parameter was a list of lists
02:05:26 <quicksilver> so it looked for a Num instance for lists.
02:05:26 <vertue> https://gist.github.com/2786825
02:05:29 <augur> actually i suppose it's a different error
02:05:33 <augur> that i can fix easily
02:05:35 <quicksilver> augur: you shouldn't : shuffle [] [] will give [] with that code.
02:05:41 <augur> quicksilver: thank you, im obviously an idiot :)
02:05:48 <quicksilver> I doubt that :)
02:05:56 <augur> quicksilver: yeah, its giving me an ambiguous type var error
02:05:57 <augur> so
02:06:34 <quicksilver> vertue: I'm afraid I'm not familiar with the sql lib can't help there.
02:06:53 <vertue> quicksilver: no problem
02:07:23 <vertue> It has been driving me up the wall for half a day so I thought - take a chance
02:10:28 <HugoDaniel> hi
02:12:22 <flori> Ï
02:16:39 <structuralist> can someone tell me how these two definitions are equivalent? http://ncatlab.org/nlab/show/Kleisli+category
02:25:36 <ClaudiusMaximus> nomeata: i avoid sharing with horrible hacks that will probably bite me with return of undead zombie space time leaks in the future, eg>  [ foo x y | x <- [1 .. 100000000], y <- [{- data dependency to avoid sharing this huge list -} x + 1 - x .. 100000000 ]
02:26:06 <womb> Hi all ! \o
02:28:02 <Peaker> ClaudiusMaximus, what happens if it is shared? Won't ghc fuse it into a loop anyway without lists?
02:28:33 <nomeata> ClaudiusMaximus: interesting, although in your case, you already duplicated the [1..10000000]. In “most” cases, GHC will not unshare that, but in simple cases (like this one, maybe) it will.
02:30:19 <ClaudiusMaximus> nomeata: the thing i'm avoiding sharing is the second list - the first list is no problem, the second list might stick around in memory (created when x ==1, needed again when x == 2)
02:30:43 <ClaudiusMaximus> nomeata: the fact that the upper bounds were the same is a bit confusing...
02:31:06 <ClaudiusMaximus> perhaps i should write better eg>  [ foo x y | x <- [1 .. 10], y <- [{- data dependency to avoid sharing this huge list -} x + 1 - x .. 100000000 ]
02:32:03 <nomeata> Ah, I see
02:32:08 <ClaudiusMaximus> Peaker: if it is shared, and not fuesd, you get a memory explosion
02:32:39 <ClaudiusMaximus> Peaker: i'm not sure if fusing can happend if it's shared
02:33:02 <ClaudiusMaximus> (in ghc at least)
02:33:09 <Peaker> ClaudiusMaximus, I'm confused, if it isn't shared -- then you'll still keep around a list of the same size?
02:33:36 <ClaudiusMaximus> Peaker: if it isn't shared, it can be garbage collected immediately as its only needed once
02:33:48 <Peaker> one of the copies can, but the other is still in use..?
02:33:59 <Peaker> oh, I see
02:34:02 <Peaker> never mind :)
02:34:52 <Peaker> GHC makes some kinds of undesirable sharing hard to get rid of.. you can try to hide something behind a (() -> a) function wrapper and that doesn't help either
02:49:20 <stonebuilder> Hey, I'm new to Haskell, I've gone through 'Learn you a Haskell' and written one or two basic projects to get into the swing. (not much io/monads)
02:49:30 <stonebuilder> I really like Haskell, how do you reccomend I continue learning ?
02:50:10 <kalven> write a monad tutorial
02:50:52 <stonebuilder> Seriously?
02:51:01 <k-zed> (no, they're trolling)
02:51:25 <stonebuilder> Thought so, haha.
02:52:48 <Saizan> stonebuilder: maybe real world haskell?
02:53:28 <shachaf> (That's the name of a book, not a project suggestion.)
02:55:31 <stonebuilder> Yeah, thanks. I figured. There are so many programming books with a title "Real World [Programming Language]"
02:55:31 <structuralist> stonebuilder: check out the typeclassopedia
02:56:02 <k-zed> typeclassopedia is great
02:56:26 <papyrus> there is  "Real world Ocaml"  comming soon.
02:56:31 <k-zed> my experience with real world haskell wasn't too great unfortunately
02:56:58 <stonebuilder> Hahahaha! "Then someone used fmap fmap fmap and my brain exploded."
02:58:02 <papyrus> k-zed:what is typeclassopedia ?
02:59:02 <papyrus> i am sorry i am not good to speak english.
02:59:22 <ClaudiusMaximus> @where typeclassopedia
02:59:23 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
03:00:11 <luite> what's the lambdabot command to do z decoding?
03:00:31 <quicksilver> I don't thinke it has one
03:00:34 <quicksilver> but preflex does
03:00:37 <luite> oh
03:00:50 <luite> that explains why i couldn't find it :)
03:01:07 <quicksilver> preflex: zdec foozuwib
03:01:07 <preflex>  foo_wib
03:01:23 <quicksilver> preflex zenc luite$$$makemoneyfast!!!
03:01:23 <preflex>  luitezdzdzdmakemoneyfastznznzn
03:01:38 <luite> preflex: zdec zszhzh
03:01:39 <preflex>  /##
03:02:00 <luite> preflex: zdec zlzezhzh
03:02:00 <preflex>  <=##
03:02:02 <papyrus> thanks  ClaudiusMaximus, lambdabot
03:02:18 <luite> hmm why is it missing those primops
03:05:12 <Saizan> structuralist: I haven't worked out the proofs, but since a free T-algebra (T(M),mu_M) is uniquely determined by the object M and a morphism between such algebras is a morphism T(M) -> T(N) from which you can get a M -> T(N) composing with return it seems it should work
03:17:35 <bartavelle> I am writing a library that needs to run a ruby script, and I would like to distribute it with the library. I am not sure on how to do it except write a rubyscript.hs which contains my script as a huge string and write it to a file before running it. There should be a better way, but what is it ?
03:18:33 <bartavelle> (if I want the library to be self contained)
03:18:53 <quicksilver> if it's being installed as a standard haskell library
03:19:01 <quicksilver> then it can have other files if it wants to
03:19:30 <quicksilver> http://neilmitchell.blogspot.co.uk/2008/02/adding-data-files-using-cabal.html
03:19:36 <quicksilver> that's ancient it might be easier now
03:19:38 <quicksilver> but that's the general idea
03:20:05 <bartavelle> humm
03:20:05 <quicksilver> http://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-data-files-from-package-code
03:20:27 <bartavelle> oh cool
03:20:40 <bartavelle> this looks perfect
03:27:01 <bartavelle> hum that was too easy, my project name is language-puppet, and it seems that Path_language-puppet is an invalid module name
03:31:40 <quicksilver> bartavelle: "with any hyphens in pkgname replaced by underscores"
03:31:48 <quicksilver> bartavelle: marvelous thing, documentation is ;)
03:34:52 <bartavelle> hahaha
03:34:53 <bartavelle> indeed
03:37:19 <fmap> is IORef a mutable multithread state and MVar is mutable multithread communication primitive?
03:37:39 <fmap> i don't seem to get a big difference though
03:38:08 <Peaker> fmap, IORefs are just a mutable ref... I think only atomicallyModifyIORef and readIORef are supposedly guaranteed semantics in multithreading
03:38:13 <shachaf> fmap: IORef is just a variable that you can read from or write into.
03:38:42 <Peaker> fmap, MVars is a mutable container of 0 or 1 refs which supports blocking when reading if empty and when writing if full
03:38:47 <shachaf> MVar is a thing that can be empty or full and trying to take its value when it's empty or put a value in when it's full blocks.
03:38:51 <shachaf> Just listen to Peaker.
03:38:55 * shachaf needs to goto sleep;
03:39:09 <Peaker> night shachaf!
03:40:15 <fmap> Peaker: can't i use MVar like IORef?
03:41:01 <Peaker> fmap, you could, but that could be overkill
03:41:03 <bitonic> fmap: no, MVars have the notion of "empty" and "full"
03:41:08 <bitonic> I mean, you can
03:41:20 <bitonic> but MVar are more powerful than IORefs
03:41:21 <Peaker> You could always keep the mvars full of 1 value and ignore the emptiness and always use modifyMVar to write to them
03:41:51 <Peaker> fmap, MVar's blocking semantics are pretty great for many purposes
03:42:02 <bitonic> Yeah, MVars are cool.
03:42:02 <Peaker> (Much simpler than other primitives often used for the same purposes)
03:42:51 <fmap> Peaker: so "things I can do with IORef" is roughly a subset of "things I can do with MVar"
03:42:59 <bitonic> fmap: not roughly. it is a subset
03:43:23 <fmap> okay, makes sense
03:43:23 <bitonic> and what you can do with MVars is a subset of what you can do with STM :P
03:44:58 <Peaker> If you can use an IORef (it is thread-safe if you modify via atomicallyModifyIORef) then it is probably going to be faster/better/simpler with an IORef
03:45:07 <Peaker> if you want to have threads sync/wait for each other, an MVar is much more useful
03:47:31 <ymasory> hi. what are some examples of semigroups that aren't monoids?
03:48:26 <bitonic> ymasory: non-empty lists
03:48:41 <ymasory> bitonic: that makes sense, thanks. any others?
03:49:00 <bitonic> ymasory: naturals >= than 1 :P
03:49:11 <ymasory> nice, thanks again
03:49:19 <ClaudiusMaximus> ymasory: minimum or maximum   (i think, dependds on type)
03:49:49 <ymasory> ClaudiusMaximus: i've never used minimum or maximum as a type (only as a function on ordered elements), so i'll take a look
03:50:17 <ClaudiusMaximus> well, that would be mappend, and i think a semigroup is just monoid without mempty?
03:50:29 <bitonic> ClaudiusMaximus: yeah you can have Monoid if the inner thing is Bounded
03:52:45 <Taneb> Hello
03:52:52 <HugoDaniel> hi
03:52:55 <HugoDaniel> can i mirror hackage ?
03:52:56 <HugoDaniel> :(
03:53:00 <HugoDaniel> it is so slooooowwww
03:53:05 <Peaker> I wish there was a nice tool that could count minimal size of Haskell code, ignoring optional types, imports, blank lines, etc.  Ideally in a number of tokens or such -- so project sizes can be roughly compared
03:53:12 <Peaker> number of lines is too rough
03:53:28 <absence> when using loop with arrows, how is the initial condition specified?
03:54:07 <Taneb> I'm pretty bored, I was going to make a monad tutorial but then I realised that would be futile
03:54:24 <merijn> Taneb: Write a monad tutorial tutorial? :)
03:54:46 <arbn> Has anyone here read "Purely Functional Data Structures"? Any thoughts or recommendations concerning it?
03:55:06 <Peaker> absence, http://stackoverflow.com/questions/6976944/how-does-arrowloop-work-also-mfix
03:55:12 <merijn> arbn: Haven't read it, but it seems to be highly regarded
03:55:21 <Peaker> Taneb, there are so many interesting Haskell projects to write :)
03:55:34 <edsko> when I say 'tryReadMVar :: MVar a -> IO (Maybe a)' -- then somebody will scream: but! what if?
03:55:42 * edsko is wondering why it's not in the library
03:56:17 <HugoDaniel> yay, just compiled the latest ghc snapshot for freebsd
03:56:29 <Peaker> edsko, http://www.haskell.org/pipermail/haskell-cafe/2004-September/006732.html
03:56:40 <edsko> yeah, I saw that thread, but I'm not convinced
03:56:48 <merijn> Is there a nice template haskell tutorial? I have a fairly trivial use case (bunch of functions with the same boiler plate code around their function body that I want to hide away)
03:57:15 <hpaste> edsko pasted “tryReadMVar” at http://hpaste.org/69004
03:57:18 <Peaker> merijn, can you paste that code?
03:57:44 <Peaker> edsko, that's implemented in the link I gave you
03:57:57 <edsko> yeah, I know. and people are saying it might race with other putMVars
03:58:03 <edsko> but that's true for modifyMVar too
03:58:10 <ClaudiusMaximus> edsko: you mean something like   do r <- tryTakeMVar v ; maybe (return ()) (putMVar v) r  the problem is another thread could putMVar in between
03:58:15 <Peaker> merijn, the wiki points at http://www.hyperedsoftware.com/blog/entries/first-stab-th.html
03:58:22 <arbn> merijn: OK. I've been coding in Haskell for about a year, and keep having the problem of not being able to pose my mental algorithms in a functional way. Hoping that the book will help me model the problems differently or implement familiar structures.
03:58:44 <absence> Peaker: ah, delay. thank :)
03:58:50 <edsko> ClaudiusMaximus: right (with a mask). yes, other threads could race for the putmvar, but the same goes for modifymvar and co.
03:58:54 <absence> s
03:59:24 <ClaudiusMaximus> true, but best keep quiet or they'll only go and remove modifyMVar and co too ;)
03:59:27 <merijn> Peaker: Sure, but I'm not sure whether the code will make sense out of context
03:59:58 <edsko> ClaudiusMaximus: from the docs: In particular, the bigger functions in this module (readMVar, swapMVar, withMVar, modifyMVar_ and modifyMVar) are simply the composition of a takeMVar followed by a putMVar with exception safety. These only have atomicity guarantees if all other threads perform a takeMVar before a putMVar as well; otherwise, they may block.
04:00:15 <edsko> so the same proviso goes for my tryReadMVar
04:00:30 <bitonic> merijn: the original paper is outdated but still a good reference
04:00:39 <Peaker> they may also block if the mvar is empty
04:00:51 <Peaker> a function named "tryX" seems to imply no-blocking
04:01:04 <merijn> Peaker: I have things like this: http://hpaste.org/69005
04:02:22 <merijn> I could (most likely) pass things in as an argument to the function, but then I'd have to do manually pass along all the arguments, which is a bit cumbersome
04:02:29 <quicksilver> the 'try' functions have race conditions IIRC
04:03:33 <Peaker> merijn, do all the functions look the same apart from the "undefined" payload?
04:04:02 <Peaker> merijn, why not write a combinator that takes that "undefined" as an argument and calls it with all the arguments it needs?
04:04:03 <merijn> Peaker: Yes
04:05:04 <merijn> Peaker: That ends up being rather unreadable :\
04:05:40 <absence> Peaker: the delay has to occur in front of the computation right? like "loop (second (delay someVal) >>> computation)" and not "loop (computation >>> second (delay someVal))"
04:05:45 <merijn> Not to mention the type signature becomes like two lines long in that scenario (because it essentially takes the current one and adds that with some extra added arguments as a new argument in front)
04:05:52 <hpaste> Peaker annotated “generic code” with “generic code (annotation)” at http://hpaste.org/69005#a69006
04:06:18 <Peaker> merijn, I have type signatures ~8 lines long :P
04:07:03 <merijn> That's exactly what I was thinking before, yeah. I was just wondering if I could do it more nicely using TH
04:07:34 <Peaker> merijn, I'm not sure I'm following you about what the downsides here are..
04:07:42 <Peaker> a slightly longer type signature isn't scary to a Haskeller? :)
04:08:20 <hpaste> Peaker annotated “generic code” with “generic code (annotation) (annotation)” at http://hpaste.org/69005#a69007
04:08:49 <mrkronecker> Hello! I've been using getLine in order to derive an input for a text adventure game. Unfortunately I seem to be having trouble with backspace/del! These don't seem to delete input, but rather add del characters. I've tested this on my own computer (running GHC 7.0.4) and a separate ubuntu server which runs GHC 6.12, and the outcome is the same. As I'm writing a text adventure game, I consider this to be a fair
04:08:49 <mrkronecker> ly serious issue. Does anyone know how it might be fixed?
04:08:50 <Peaker> merijn, I think TH is a huge hammer -- for the cases ordinary Haskell isn't good enough
04:09:03 <Peaker> kind of a "sin bin" for things the language doesn't solve yet
04:09:41 <merijn> mrkronecker: You probably want to adjust the terminal mode
04:09:45 <Peaker> mrkronecker, Maybe you want to use a terminal access library rather than read stdin directly?
04:09:47 * hackagebot blastxml 0.2 - Library for reading Blast XML output  http://hackage.haskell.org/package/blastxml-0.2 (KetilMalde)
04:10:02 <merijn> Set it to line buffered rather than raw
04:10:06 <merijn> or whatever it is now
04:10:14 <mrkronecker> Oh yes? Excellent. I didn't know that this existed
04:10:37 <mrkronecker> Thank you. I'll look it up
04:11:16 <merijn> mrkronecker: You want System.IO and then hSetBuffering
04:11:41 <merijn> Running "hGetBuffering stdin" in ghci returns "NoBuffering"
04:12:30 <Peaker> but ghci probably uses readline or some sane library to read from stdin?
04:13:48 <merijn> Probably
04:14:21 <merijn> Anyhoo, an unbuffered getLine would not be able to properly backspace. But you probably want to use bindings to ReadLine anyway
04:14:31 <merijn> Since that'll give you proper history, tab completion, that sorta thing
04:14:34 <fmap> I guess it uses haskeline
04:15:08 <Peaker> mrkronecker, did you consider using ReadLine?
04:16:50 <mrkronecker> I didn't! I'm looking at that now.
04:18:34 <navaati> absence : it's absolutely the same
04:18:41 <navaati> draw the diagram and you'll see why
04:18:42 <structuralist> Saizan: oh okay and then the other direction is just fmap and join… cool, thanks!
04:20:03 <navaati> (i think it's something like an associated law of ArrowLoop)
04:23:47 <Saizan> structuralist: btw, there's also ##categorytheory, even if it's not so active
04:25:38 <structuralist> heh thanks
04:38:22 <Peaker> I wish ScopedTypeVariables was on by default and didn't need "forall" :(
04:39:48 <merijn> In Data.Lens what would be the canonical way to write this: "myLens ^= val $ object", "(myLens ^= val) object" or something else entirely?
04:43:10 <merijn> Peaker: Actually, I just realised that passing the undefined value in as argument doesn't cut it
04:43:53 <merijn> As I have multiple functions like these and they refer to each other, but said references need the "full" function, which is not otherwise possible
04:44:59 <merijn> For example another function relying on transferField in a context where I can't create it by passing the "undefined" value in (as I don't know the undefined value there)
04:47:25 <Peaker> merijn, but if you do:   fullFunc = funcMaker $ \a b c d -> ... "undefined" payload here ...
04:47:33 <Peaker> merijn, for multiply full funcs, then they can refer to each other
04:48:26 <merijn> Peaker: Yes, but then I'm just piling layer upon layer to make it work
04:48:33 <merijn> hmm
04:48:44 <merijn> Sometimes I had programming >.>
04:48:50 <merijn> s/had/hate
04:48:56 <merijn> I can't even type anymore >.>
04:49:52 * hackagebot language-c-quote 0.3.1.2 - C/CUDA/OpenCL quasiquoting library.  http://hackage.haskell.org/package/language-c-quote-0.3.1.2 (GeoffreyMainland)
04:50:13 <merijn> Making a bunch of boilerplate functions to create boilerplate functions that will actually be used
04:50:14 <Peaker> merijn, I don't see any layers piling...
04:50:20 <ion> funcMaker? FunctionFactory!
04:50:37 <Peaker> merijn, why is there any boilerplate? It seems fully DRY (except for parameter list) in that solution
04:50:49 <Peaker> f1 = foo $ \a b c d -> ...
04:50:52 <Peaker> f2 = foo $ \a b c d -> ...
04:51:03 <Peaker> I don't think that's too verbose/boilerplate-y
04:51:10 <Peaker> (foo is of course written exactly once)
04:51:21 <merijn> What is foo in this context?
04:54:16 <vraid> what does \ a -> notation mean in haskell?
04:54:42 <Peaker> merijn, the function maker
04:55:10 <merijn> vraid: Lambda notation
04:55:11 <Peaker> merijn, (Converts "undefined" payload to full function)
04:55:21 <vraid> ah, thanks
04:55:32 <Peaker> I hate that \ and "do" can be an infix application arg, but not prefix application rag
04:55:33 <Peaker> arg
04:56:00 <merijn> vraid: "\a -> a + 1" is identical to "f a = a + 1", except in the latter scenarion you are assigning the name 'f' to the function
04:56:06 <Peaker> f $ \x -> ...      and f $ do ...         are valid,     but f \x -> ...    and f do ...   are not
04:56:32 <merijn> (in fact, "f = \a -> a + 1" is semantically identical to "f a = a + 1")
04:56:44 <Peaker> merijn, if not for the dreaded Monomorphism Restriction :(
04:56:53 <merijn> Oh, right
04:56:58 <merijn> I keep forgetting :p
04:57:03 <vraid> so lambda functions use only implicit typing?
04:57:13 <Peaker> vraid, Haskell in general uses "implicit typing"
04:57:14 <merijn> vraid: You can annotate them if you want
04:57:25 <Peaker> vraid, just like anywhere in Haskell, you can place type annotations if you want
04:57:27 <vraid> like \a::Integer -> ?
04:57:32 <merijn> :t \(a :: Int) -> a
04:57:33 <lambdabot> Int -> Int
04:57:37 <vraid> ah, got it
04:57:52 <quicksilver> Peaker: only the right hand side of an infix, further more.
04:57:55 <merijn> You can even pattern match/multiple arguments
04:57:58 <quicksilver> it is indeed a bit weird.
04:58:10 <merijn> (Of course if your pattern match fails you get a runtime exception)
04:58:17 <merijn> :t \(Just x) -> x
04:58:18 <lambdabot> forall t. Maybe t -> t
04:58:27 <quicksilver> it's a strange special case in a lexical syntax which was (apparently) motivated by the desire to minimise special cases.
04:58:31 <merijn> > (\(Just x) -> x) Just 5
04:58:32 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe (t -> t1)'
04:58:32 <lambdabot>         against i...
04:58:35 <Peaker> quicksilver, heh
04:58:38 <merijn> > (\(Just x) -> x) (Just 5)
04:58:39 <lambdabot>   5
04:58:45 <merijn> > (\(Just x) -> x) Nothing
04:58:46 <lambdabot>   *Exception: <interactive>:3:1-14: Non-exhaustive patterns in lambda
04:59:12 <Peaker> btw, it's really awful that you get warnings about missing patterns anywhere *except* in do notation because of "fail".. yet another reason "fail" must die
04:59:40 <Peaker> Runtime crashes should be preceded by compile-time warnings (at least if only total functions were used)
05:06:39 <nand`> Is there a word for a category in which every object has a morphism to every object?
05:07:01 <fmap> Peaker: maybe even a pattern match itself inside lambda should cause a warning
05:07:24 <Peaker> if it's partial yeah
05:09:31 <Saizan> nand`: if it's unique it's an indiscrete category
05:11:05 <nand`> Saizan: they are, indeed, unique
05:12:11 <Saizan> http://ncatlab.org/nlab/show/indiscrete+category
05:17:00 <kopi> Hi.What would be best linux distro for  haskell
05:17:39 <Peaker> kopi, I'm finding Debian's "unstable" branch to be a good source of up-to-date Haskell packages
05:17:49 <Peaker> But I've only used Debian/Ubuntu with Haskell
05:18:12 <merijn> OS X *ducks from the anti-troll artillery*
05:18:13 <covi> Debian is too stable... lol
05:18:24 <nand`> Gentoo has excellent haskell integration
05:18:36 <kopi> leksah or vim
05:18:37 <nand`> but the distro may not be your cup of tea
05:18:47 <Peaker> @photontorpedo
05:18:48 <lambdabot> what is haskell?
05:18:52 <Peaker> @photontorpedo
05:18:52 <lambdabot> what does haskell do better than java perl or ruby?
05:18:54 <gghh_> Hello. I remember a paper about "smart" side-effect programming in haskell. The problem is: say you want to implement a Turing Machine in Haskell, you'll have to pass your ribbon as an argument to all your functions, and those will give an updated ribbon as result, since you aren't allowed to hold a "state". Well, that paper from the late 90s was addressing this. Might have been titled "side effects in haskell" or something along this
05:18:55 <gghh_> line. Rings a bell to anybody?
05:19:02 <nand`> kopi: emacs or vim
05:19:07 <nand`> I don't think leksah is used that much
05:19:17 <Peaker> gghh_, the monad intro paper?
05:19:41 <gghh_> Peaker: might be. Have a link? I will recognize it if I see it.
05:19:42 <Peaker> gghh_, maybe this: http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf ?
05:20:58 <merijn> gghh_: Any specific reason you're looking for that one?
05:21:43 <merijn> (i.e. is there a specific question/topic you were looking into or do you really need *that* specific paper)
05:23:10 <kopi> So gento and vim
05:24:55 <covi> It seems that the majority of research on Haskell and functional programming takes place in Europe, not U.S. Is there any reason?
05:25:21 <bitonic> covi: better food
05:25:22 <gghh_> merijn: bah... not really. I am engaged with a friend to write an emulator for the CoreWar virtual machine, http://en.wikipedia.org/wiki/Core_War (a game where you write programs to fight other programs). It is the most procedural problem ever (implement an assembler), we wandered if there is a way to write it statelessly.
05:25:37 <Ptival> bitonic: huh... what about the UK? :D
05:26:01 <bitonic> Ptival: better food overall. and the UK is not that Europe cmon
05:26:05 <merijn> gghh_: Well, not in a sensible way. Even in haskell you will have state. The only thing that differs is what state and how do you use/access it
05:26:17 <bitonic> (note the use of Europe as an adjective)
05:26:24 <Ptival> ^^
05:26:27 <merijn> UK likes to think it's in the middle of the Atlantic...
05:27:42 <bitonic> covi: anyway, I don't think it's for any particular reason and there's a lot of FP research in the US anyway
05:27:55 <kopi> Gentoo seams pretty good
05:28:10 <kopi> Gentoo Linux is a versatile and fast, completely free Linux distribution geared towards developers and network professionals. Unlike other distros, Gentoo Linux has an advanced package management system called Portage. Portage is a true ports system in the tradition of BSD ports, but is Python-based and sports a number of advanced features including dependencies, fine-grained package management, "
05:28:10 <kopi> fake" (OpenBSD-style) installs, safe unmerging, system profiles, virtual packages, config file management, and more.
05:28:24 <gghh_> merijn: I'll see. I have seen/written too few haskell programs to have my personal feelings on that. I think I'll take this chance to get my hand (real) dirty.
05:28:43 <Transhumanist> what're the career opportunities in Haskell like?
05:28:51 <bitonic> kopi: there's no need to copy paste the gentoo website here :). And anyway, most linux distributions will do if you use the GHC binaries and cabal packages
05:29:11 <bitonic> Transhumanist: people will think you're smart for some reason. this can be both a good and bad thing
05:29:50 <Transhumanist> Haha. I mean what're the odds of actually scoring a job coding Haskell?
05:29:55 * hackagebot moe 2011.6.14 - html with style  http://hackage.haskell.org/package/moe-2011.6.14 (JinjingWang)
05:29:56 <Transhumanist> increasing?
05:30:00 <merijn> Transhumanist: Depends on the career you're in
05:30:01 <bitonic> Transhumanist: also, FP is growing incredibly fast, and if you're an expert in Haskell, you're an expert in a big slice of FP theory
05:30:17 <covi> bitonic: okay
05:30:18 <merijn> Transhumanist: My solution is just to not tell people I'm writing stuff in Haskell :)
05:30:25 <kopi> hah
05:30:30 <Botje> Transhumanist: you will write infinitely better code, both haskell and non-haskell.
05:30:38 <bitonic> Transhumanist: pretty low, Haskell is still a niche in the industry. but you have a better change of scoring Scala, clojure, or erlang jobs
05:31:04 <merijn> "Write a simulator to measure distributed reference counting behaviour" *some time passes* 'Here is your simulator implemented in haskell!'
05:31:08 <Transhumanist> Scala, Clojure or Erlang jobs sound better than C++ or Java jobs to me! ;)
05:31:25 <vraid> or, the horror, .NET
05:31:35 <Transhumanist> I wasn't going to mention it...
05:31:37 <merijn> .NET actually seems pretty ok, for a window platform
05:31:51 <covi> Do you prefer <$> or liftM?
05:31:58 <Transhumanist> I'll admit, C# seems cleaner than Java.
05:31:58 <merijn> F#, C# appears to less horrid than java and if you want to be really obscure F*
05:32:05 <bitonic> Transhumanist: in general if you're good at FP you're quite a rarity, and that makes you valuable :)
05:32:07 <ski> covi : i prefer `fmap' or `liftM'
05:32:25 <Transhumanist> FP is just plain prettier to code in.
05:32:43 <covi> ski: why not <$>? For readability?
05:32:59 <merijn> I'm a big believer in learning as many languages as possible and just referring to yourself as a programmer rather than an 'X programmer'.
05:33:17 <ski> covi : i would prefer if `<*>' had been named `<$>'
05:33:42 <Transhumanist> good philosophy, merijn.
05:33:44 <earthy> hm. why?
05:33:47 <merijn> Now that I have a reasonable understanding of haskell and Lisp and the basics in a bunch more imperative ones I'm reasonably confident I can code successfully in almost anything :p
05:33:48 * ski . o O ( "Hello, I'm an lambdaProlog programmer .." )
05:33:57 <earthy> ski: <$> mirrors $
05:34:02 <nilg`> guys, does haskell (I mean the compiler) supports COW (copy-on-writing)?
05:34:11 <ski> earthy : exactly
05:34:14 <merijn> nilg`: In what sense?
05:34:21 <bitonic> merijn: mah there's a lot of stuff in programming beyond PL knowledge...
05:34:28 <ski> earthy : `<$>' should be `$>' or something
05:34:42 <merijn> bitonic: oh sure, but I'm fairly confident about the other parts already :)
05:34:42 <earthy> so why should <*> be <$>?
05:34:51 <ski> because it mirrors `$'
05:35:03 <merijn> :t ($)
05:35:03 <lambdabot> forall a b. (a -> b) -> a -> b
05:35:06 <merijn> :t (<$>)
05:35:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:35:12 <ski> @type (<*>)
05:35:13 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
05:35:16 <nilg`> merijn: in the sense that if a function takes a list and return an almost similar list, are the similar elements copied in memory or not?
05:35:55 <merijn> nilg`: It'll reuse the common tail portion, yes
05:35:59 <bitonic> nilg`: Haskell data structures will share common pars
05:36:18 <nilg`> the "common tail portion"?
05:36:26 <bitonic> it's not really "copy on write", because there is no write. everything is immutable
05:36:26 <nilg`> tail as opposed to head?
05:36:38 <ski> nilg` : common elements will be shared, as will any common tail
05:36:43 <arbn> nilg: Think about the effects of laziness here.
05:36:56 <merijn> So "f (x:xs) = 1 : xs" will allocate one new head element and reuse the existing tail, for example
05:37:12 <nilg`> OK I see
05:37:13 <merijn> nilg`: Anything before the modified element has to be copied
05:37:30 <merijn> Because otherwise we'd update the original list
05:37:37 <ski> nilg` : still, the kept elements themselves aren't copied, only the references to them
05:37:56 <earthy> ofcourse, in actual running code, due to laziness, the copy may never be constructed
05:38:00 <quicksilver> there is no write, only allocate.
05:38:02 <hpaste> haisheng pasted “withBackend Error” at http://hpaste.org/69009
05:38:12 <ski> allocate&initialize
05:38:24 <quicksilver> and the only copying there is is that which the GC does.
05:38:43 <quicksilver> ski: true but from a suitable distance you can think of that as one thing.
05:38:51 * ski nods
05:40:29 <nilg`> also, I've implemented a brute force Fibonacci function (you know the stupid way) and compare the performance between C, D and Haskell
05:40:45 <nilg`> the Haskell version 5 times slower than the D and C version
05:40:54 <nilg`> why do you think that is?
05:41:07 <merijn> How did you implement fibonacci?
05:41:18 <merijn> The naive way is O(n^2) or something...terrible performance
05:41:28 <nilg`> the naive way indeed
05:41:31 <Botje> nilg`: you didn't compile with -O2 ?
05:41:36 <sipa> merijn: the naive way is O(fib(n)) :)
05:41:38 <bitonic> merijn: I hope he means he implemented it the naive way in all languages
05:41:57 <nilg`> oh I didn't know there is -O2 optimization on the haskell compiler...!
05:42:00 <merijn> nilg`: Did you implement it recursive in D and C too?
05:42:13 <bitonic> nilg`: it'll go much faster with -O2
05:42:15 <merijn> The non-recursive fibonacci is much faster, like this one
05:42:32 <nilg`> exact same way (naive and recursive) in all languages
05:42:43 <merijn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
05:42:43 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
05:42:44 <bitonic> nilg`: be sure to try to compile via LLVM as well
05:42:46 <vraid> merijn: known as a closed formula
05:42:56 <Transhumanist> is LLVM default?
05:43:08 <merijn> Transhumanist: Not yet, I think native code generation is default
05:43:09 <bitonic> Transhumanist: no
05:43:53 <bitonic> and the native code generator is faster in most cases, iirc
05:43:59 <bitonic> but you never know
05:44:09 <xnoise> hello: i have a noob question: why does this function definition works: replicate' :: Int -> a -> [a] and this does not: replicate' :: a -> Int -> [a] ?
05:44:39 <merijn> xnoise: They both work, providing you implement the function body properly
05:44:44 <Transhumanist> They both work.
05:45:08 <xnoise> it is implemented, but for some reason on second i receive: Couldn't match type `a' with `Int'
05:45:08 <xnoise>       `a' is a rigid type variable bound by
05:45:08 <xnoise>           the type signature for replicateElement :: a -> Int -> [a]
05:45:08 <xnoise>           at recursion.hs:47:1
05:45:34 <xnoise> if i invert the parameters it does work...
05:45:36 <Botje> xnoise: show code on hpaste.
05:45:41 <xnoise> just a sec
05:46:01 * merijn spots a helper function which was probably not updated accordingly :)
05:49:23 <ski> vraid : what merijn wrote was a closed formula, yes
05:49:52 <hpaste> “cristian datculescu” pasted “replicate” at http://hpaste.org/69010
05:50:24 <xnoise> merijn, the paste above is my function
05:50:47 <ski> xnoise : change the call to `replicate' into a recursive call to `replicateElement'
05:50:49 <merijn> xnoise: You use replicate which is a built in function
05:50:54 <merijn> :t replicate
05:50:55 <lambdabot> forall a. Int -> a -> [a]
05:51:01 <xnoise> errrrrmmmm
05:51:09 <merijn> So switching the type signature is a type error :)
05:51:21 <xnoise> stupid error, thanks alot
05:51:22 <xnoise> :)
05:51:30 <ski> (: np
05:51:45 <merijn> xnoise: It happens :)
05:52:58 <xnoise> yeah, i believe it does. should really pay more attention to my functions definitions :)
05:53:31 <covi> I have a list of [n1, n2, .., nn], how do I get a list of the sums [n1, n1+n2, n1+n2+n3, ..]? Fold does not work because it reduces to a value
05:54:03 <Eduard_Munteanu> covi: see scanl
05:55:02 <covi> Eduard_Munteanu: oops, thanks
05:56:52 <Eduard_Munteanu> > scanl (+) 0 [n1, n2, n3]
05:56:53 <lambdabot>   Not in scope: `n1'Not in scope: `n2'Not in scope: `n3'
05:57:58 <Eduard_Munteanu> > scanl (+) 0 [a, b, c]
05:58:00 <lambdabot>   [0,0 + a,0 + a + b,0 + a + b + c]
06:04:42 <covi> > foldl (\index n -> if n > 10 then index else index+1) 0 [1..11]
06:04:44 <lambdabot>   10
06:04:58 <covi> ^ is this a good method to achieve the purpose/
06:05:13 <covi> > foldl (\index n -> if n > 10 then index else index+1) 0 $ scanl1 (+) [1..11]
06:05:14 <lambdabot>   4
06:06:13 <Botje> isn't that fold just length . filter (10 <=) ?
06:06:29 <ymasory> given [IO Unit] how do i execute them all sequentially? how do i turn it into an IO Unit?
06:06:46 <jaxtr> ahh it's a wonderful day
06:06:46 <dolio> sequence_
06:06:58 <ymasory> thanks
06:08:07 <covi> Botje: you're right, thx
06:08:11 <S11001001> or use sequence if you want your list of units :)
06:08:37 <ymasory> thanks again
06:08:44 <Peaker> sipa, Is O(fib(N)) the same as O(2^n)?
06:10:17 <sipa> Peaker: hmm, fib(N) ~ G^N, with G the golden ratio base
06:10:40 <Peaker> and O(C^N) is the same for all C>1, right?
06:11:00 <Peaker> Yeah, it should be, just multiply N by whatever log factor and you get a tight bound
06:11:35 <Transhumanist> Isn't O(10^n) a shitload slower than O(2^n)?
06:11:51 <quicksilver> no, Peaker
06:12:02 <quicksilver> all the different exponentials are formally different O-classes
06:12:07 <Transhumanist> definitely
06:12:14 <quicksilver> although, in practices, people don't distinguish
06:12:19 <quicksilver> since they're all "much too slow to be useful"
06:12:38 <quicksilver> O(2.00000001^n) is asymptotically slower than O(2^n)
06:12:47 <Peaker> Hmm.. Say you have: O(2^N1) and O(4^N2),  if you multiply N1 by 2, you get O(4^N1)
06:12:57 <nand`> can “existSuccess” cause a race condition? eg. “hPut h foo >> hFlush h >> exitSuccess” <- h here is a handle to a remote socket
06:13:01 <nand`> exitSuccess*
06:13:13 <quicksilver> you can't multiple a formal variable by a number
06:13:15 <quicksilver> it's a formal variable
06:13:19 <quicksilver> it doesn't have a value.
06:13:47 <Peaker> quicksilver, IIUC:  O(f(n)) and O(g(n)) are the same class if there exist constants a,b such that f(a*n) < g(n) < f(b*n)
06:14:25 <vraid> sipa: fib(n) = floor((φ^n-(1-φ)^n)/sqrt(5))
06:14:29 <Peaker> (i.e: f(n) and g(n) are the same up to a constant multipler)
06:14:36 <jonaskoelker> Peaker, quicksilver: exists N: exists a, b: forall n > N: a*f(n) < g(n) < b*f(n)
06:14:37 <ski> shouldn't the products be on the outside ?
06:14:41 <quicksilver> yes.
06:14:45 <sipa> vraid: i know
06:14:54 <quicksilver> a f(n) < g(n) < b f(n)
06:15:00 <quicksilver> for some a,b and for all n > some n0
06:15:11 <covi> :t <$>
06:15:12 <lambdabot> parse error on input `<$>'
06:15:14 <luite> Peaker: the advantage of working with different exponential bases is that a lot of stuff drops out of your analysis, you can remove all polynomial factors if you just want to know which one grows faster
06:15:17 <covi> :t (<$>)
06:15:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:15:19 <Peaker> oh, that explains it.. so indeed 2^N and 4^N are different classes
06:15:26 <byorgey> covi: <$> is a synonym for fmap
06:15:45 <quicksilver> jonaskoelker: right, what you said while I was typing something similar :)
06:16:01 <luite> Peaker: (though they're still part of the big O complexity of course, but sometimes an "up to a polynomial of n" notation is introduced)
06:16:28 <Peaker> luite, yeah, so the "Exp" class is really a class of many classes "up to a polynomial of n" ?
06:16:33 <covi> :t fmap
06:16:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:16:50 <Gurragchaa> do you "implement" typeclasses?  Is that how it works?  If so, what "implements" [or "satisfies" etc] Functor?
06:17:08 <luite> Peaker: the c^n class then, but every c is a new class, even with this simplification
06:17:08 <bitonic> Gurragchaa: you instantiate type classes
06:17:09 <Peaker> Gurragchaa, The instances implement the methods of the type-class
06:17:56 <Peaker> luite, well, for 2^N and 4^N the only difference is that one grows as if N grew twice as fast, so it should be the same "up to a polynomial of N" or even "up to a linear multiplication of N"?
06:19:27 <luite> uh it doesn't really work that way, 2^(2n) is just 4^n of course. big O notation identifies things where the result is the same, up to a constant factor, not the input
06:19:58 <luite> if you start with a constant adn then multiply it by 2^n it's not exactly a constant anymore :p
06:20:21 <untitled> how would I search a string after some word? I can find the position of the word using "findIndex" but don't know how to proceed (e.g. get 1 from "blabla index=1" when I search fox "index=")
06:20:49 <quicksilver> untitled: try drop
06:20:54 <Peaker> luite, I understand -- I thought "up to a poly of N" meant that you could do a polynomial transform on N to get equality
06:21:02 <luite> oh right
06:21:06 <Peaker> luite, I guess I understood the term incorrectly.. however it sounds like a useful term
06:21:11 <untitled> quicksilver: right, thx
06:21:12 <luite> no it's just that p(n)c^n -> c^n
06:21:18 <luite> where p(n) is some poly
06:21:28 <ymasory> how would one turn an [Either a a] into an [a] ?
06:21:40 <Peaker> oh, I see, that connects all the complexity classes into coarser ones that depend less on the computing model used, I guess?
06:21:41 <ski> @type map (either id id)
06:21:42 <lambdabot> forall b. [Either b b] -> [b]
06:21:59 <luite> Peaker: once polynomials drop out, you probably have a bunch of exponential bases left, and then the highest one always wins
06:22:13 <ymasory> ski: thank you
06:22:35 <quicksilver> @djinn Either b b -> b
06:22:35 <lambdabot> f a =
06:22:35 <lambdabot>     case a of
06:22:35 <lambdabot>     Left b -> b
06:22:35 <lambdabot>     Right c -> c
06:22:43 <quicksilver> @. pl djinn Either b b -> b
06:22:44 <lambdabot> (line 3, column 12):
06:22:44 <lambdabot> unexpected ">" or "-"
06:22:44 <lambdabot> expecting variable, "(", operator or end of input
06:22:48 <quicksilver> :(
06:22:57 <bitonic> that'd be nice to have
06:23:17 <bitonic> but pl would choke on that input anyway
06:23:29 <quicksilver> it did choke on that input
06:23:38 <Peaker> quicksilver, I don't think @pl does pattern-matching-to-cata reductions
06:23:38 <bitonic> wait. @. exists?
06:23:43 <quicksilver> yes.
06:23:44 <bitonic> this is great.
06:24:13 <quicksilver> @. pl undo do { x <- f y; f x }
06:24:14 <lambdabot> f =<< f y
06:24:19 <ymasory> @type either
06:24:20 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
06:26:39 <quicksilver> Peaker: it doesn't do anything with pattern matching.
06:26:51 <quicksilver> (except maybe tuples?)
06:27:00 <quicksilver> Peaker: which is a shame because it wouldn't be hard to do.
06:27:11 <quicksilver> it's a shame @pl is an ugly hack instead of something beautiful :)
06:27:24 <quicksilver> @pl \(a,b) -> a
06:27:24 <lambdabot> fst
06:27:31 <quicksilver> yeah, tuples, special case though.
06:27:45 <bitonic> @pl \(Just a) -> a
06:27:46 <lambdabot> (line 1, column 8):
06:27:46 <lambdabot> unexpected "a"
06:27:46 <lambdabot> expecting operator or ")"
06:28:01 <sclv> quicksilver: i recall that pl is actually much better than an ugly hack :-)
06:28:06 <sclv> (you were probably joking though)
06:28:15 <bitonic> sclv: it is an hack, it's a set of hard coded rules
06:28:25 <bitonic> I think that's what quicksilver meant
06:28:35 <quicksilver> actually I don't mind the hard coded rules much
06:28:43 <quicksilver> it's got to be a rewrite system
06:28:49 <quicksilver> (although ideally the rules woudl be configurable)
06:28:58 <quicksilver> what I object to is the broken partial haskell parser
06:29:17 <quicksilver> to be fair, haskell-src-exts didn't exist then
06:29:32 <sclv> right, the parser is the weakest bit
06:30:23 <sclv> i mean this is not bad: https://github.com/benmachine/pointfree/blob/master/Plugin/Pl/Optimize.hs
06:30:26 <nand`> wait, why is there no (<<) = flip (>>) ?
06:30:46 <sclv> the other thing of course being that there's no non-heuristic way to simplify arbitrary expressions
06:31:41 <sclv> http://www.cas.mcmaster.ca/~carette/publications/simplification.pdf
06:31:43 <sclv> is good on this
06:35:41 <Peaker> Anyone want to clone/install these two:   git://github.com/Peaker/graphics-drawingcombinators.git   git://github.com/Peaker/bottle.git   and give some feedback if they install ok, work, etc?
06:37:26 <quicksilver> sclv: that's what I meant by "it's got to be a rewrite system"
06:38:09 <quicksilver> sclv: what I meant was, it's essentially arbitrary, but you have to work out your own metric on what is a "simplification" and also take your own care to make it confluent.
06:38:16 <quicksilver> assuming you want it to be.
06:38:33 <sclv> right.
06:38:35 <quicksilver> but, you can go quite a long way with a decently aesthetic approach to better.
06:39:01 <quicksilver> and replacing expicitly destruction with canonical catamorphisms is a plausible example
06:39:10 <quicksilver> in addition to the 'removing points' general idea.
06:39:15 <sclv> i agree -- i just don't think its that hard to add :-)
06:39:29 <sclv> and i don't think it makes pl hackish that its not there.
06:39:33 <sclv> just... less complete.
06:39:41 <quicksilver> no, what makes it hackish is that it can't parse case expressions at all
06:39:47 <sclv> there's a bunch of applicative/arrow stuff too
06:39:49 <quicksilver> @pl \(Left a) -> a
06:39:49 <lambdabot> (line 1, column 8):
06:39:49 <lambdabot> unexpected "a"
06:39:49 <lambdabot> expecting operator or ")"
06:39:50 <sclv> that it would be nice to have
06:39:54 <quicksilver> or, even patterns in general
06:39:58 <quicksilver> except for a tuple special case
06:40:17 <quicksilver> I'd say that patterns - and case expressions - are quite a big part of the haskell language :)
06:40:35 <quicksilver> especially if you're trying to make things point-free, since in patterns is where you find points.
06:40:53 <quicksilver> @pl f (Left a) = a
06:40:53 <lambdabot> (line 1, column 12):
06:40:53 <lambdabot> unexpected "="
06:40:53 <lambdabot> expecting variable, "(", operator or end of input
06:42:13 <sopvop> Is there any package to help with data validation? I tried making a few variants, but  they all suck.
06:49:15 <covi> I have a list xs, and a indexes list indexList. How do I return a list of corresponding elements? E.G. xs = "abc", indexList = [0,2], ansList = ['a', 'c']
06:49:27 <covi> (!!) <$> ZipList concatContents <*> ZipList randomLinesToDisplay
06:49:29 <covi> does not work
06:49:53 <covi> oops, I shouldn't use a ZipList here
06:50:56 <covi> turns out that (!!) <$> [xs] <*> indexList works well
06:51:10 <covi> but is this the common practice for this scenario?
06:51:17 <Phlogistique> map indexList (ansList !!)
06:51:27 <Phlogistique> map indexList (xs !!)
06:51:31 <Phlogistique> I mean
06:51:56 <Phlogistique> > let xs = "abc'; indexList = [0,2] in map indexList (xs !!)
06:51:57 <lambdabot>   <no location info>:
06:51:57 <lambdabot>      lexical error in string/character literal at end o...
06:52:06 <Phlogistique> > let xs = "abc'; indexList = [0,2] in map (xs !!) indexList
06:52:07 <lambdabot>   <no location info>:
06:52:07 <lambdabot>      lexical error in string/character literal at end o...
06:52:14 <Phlogistique> > let {xs = "abc'; indexList = [0,2]} in map (xs !!) indexList
06:52:15 <lambdabot>   <no location info>:
06:52:15 <lambdabot>      lexical error in string/character literal at end o...
06:52:19 <ski> could probably do better, given that `indexList' is sorted
06:52:20 <S11001001> Phlogistique: '
06:52:26 <Phlogistique> > let {xs = "abc"; indexList = [0,2]} in map (xs !!) indexList
06:52:27 <lambdabot>   "ac"
06:52:31 <covi> ski: sorted?
06:52:42 <covi> yeah, map (xs !!) indexList works well
06:52:49 <Phlogistique> ski: I don't think it was intended to be sorted
06:53:00 <Phlogistique> covi: sort "abc" == "abc"
06:53:04 * ski doesn't know
06:53:20 <ski> Phlogistique : i was talking about `indexList', not `xs'
06:53:27 <covi> my mind just keeps exploding. When I only know !! or map, I don't understand Applicative. When I know Applicative, I forget the more direct methods
06:53:40 <covi> common characteristics of n00bs?
06:58:17 <earthy> nah
07:02:11 <ymasory> is there a convenience method for mysum :: (Monoid m) => [m] -> m implemented with simple +
07:02:38 <covi> is gen <- getStdGen a good method to use, if the program is expected to generate different values everytime executed?
07:02:48 <fmap> @type mconcat
07:02:49 <lambdabot> forall a. (Monoid a) => [a] -> a
07:02:58 <ymasory> fmap: thank you
07:04:12 <ski> @let sortedIndices :: Integral i => [a] -> [i] -> [a]; sortedIndices as indices = foldr (\o k as -> case genericDrop o as of [] -> error "sortedIncides : index too large"; as@(a:_) -> a : k as) (\_ -> []) offsets as where offsets = zipWith (-) indices (0:indices)
07:04:13 <lambdabot>  Defined.
07:04:18 <ski> > sortedIndices "@abcdefg" [1,3,3,4,7]
07:04:20 <lambdabot>   "accdg"
07:04:43 <ski> Phlogistique,covi ^
07:05:00 <ymasory> is IO a monoid?
07:05:08 <ski> wrong kind
07:05:14 <quicksilver> IO () is a monoid
07:05:16 <ymasory> where the + would be sequence
07:05:22 <quicksilver> (although not an instance of the class)
07:05:35 <covi> ski: I see. thanks
07:05:37 <ymasory> a great, so is there some reason not to use mconcat on [IO ()] instead of sequence_ ?
07:05:51 <covi> ski: can you take a look at my randomness question?
07:06:13 <ski> covi : you probably want `newStdGen' rather than `getStdGen'
07:07:06 <ski> `getStdGen' will just grab the current global one (leaving it in place)
07:07:07 <covi> ski: I'll take a look, ty
07:07:19 <ski> `newStdGen' will generate a new one, each time it's executed
07:07:41 <ski> if you're only executing `newStdGen'/`getStdGen' once, it shouldn't matter
07:07:59 <ski> (but for compositionality, one should usually use `newStdGen' anyway)
07:08:00 <quicksilver> ymasory: the fact that there isn't a Monoid instance for IO ()
07:08:21 <quicksilver> and in haskell98/haskell2010 there can't be.
07:08:28 <quicksilver> it's a monoid but not a Monoid.
07:08:29 <ymasory> ah i see, thank you
07:08:42 <quicksilver> if there was an instance there still wouldn't be any advantage
07:08:42 <ymasory> quicksilver: out of curiousity, why can't there be?
07:08:51 <quicksilver> just two different ways to write the same thing.
07:09:02 <covi> ski: I see. From crude experiments it seems that newStdGen/mkStdGen heavily depends on machine time
07:09:10 <quicksilver> haskell98 doesn't permit instances for instantiations of type constructors.
07:09:20 <quicksilver> you can't write an instance for [String] or IO () or Either Int Char
07:09:22 <ymasory> quicksilver: thanks. i have to do this awkward translation from haskell to scalaz in my head. sometimes scalaz lacks a function and i have to find weird ways to do things :)
07:09:33 <quicksilver> (only from [a] or IO b or Either c d)
07:09:35 <ymasory> quicksilver: ah i see, thanks
07:09:44 <ski> covi : not `mkStdGen'
07:09:53 <ski> @type mkStdGen
07:09:54 <lambdabot> Int -> StdGen
07:09:59 <quicksilver> this is generally considered an unnecessary restriction
07:10:04 <quicksilver> but it seemed simpler at the time.
07:10:20 <ski> covi : it may be the global `StdGen' is initialized from time, i dunno
07:10:30 <node1243> hi, how to find a position where some substring starts in a string?
07:10:34 <covi> ah yeah
07:15:22 <covi> node1243: I want to know this too
07:15:31 <covi> after thinking for a while, I come up with nothin
07:16:44 <covi> and how to implement substring `subelem` string?
07:16:56 <`Jake`> is there any advantage if you use getStdGen and not newStdGen?
07:17:43 <ClaudiusMaximus> `Jake`: bonus race conditions / non-determinsism / un-reproducibility
07:18:08 <ion> λ> replicateM 10 getStdGen
07:18:10 <ion> [1862183975 1872071452,1862183975 1872071452,1862183975 1872071452,1862183975 1872071452,1862183975 1872071452,1862183975 1872071452,1862183975 1872071452,1862183975 1872071452,1862183975 1872071452,1862183975 1872071452]
07:18:18 <`Jake`> ClaudiusMaximus: so newStdGen is deterministic while getStdGen is not?
07:18:49 <ion> jake: Please see the documentation of getStdGen and newStdGen.
07:18:51 <ClaudiusMaximus> maybe not - i'm confused
07:18:58 <ion> That should make it clear.
07:18:58 <`Jake`> ok, I'll look at that
07:19:22 <ClaudiusMaximus> need food, can't think
07:20:24 <`Jake`> it turns out that newStdGen just "Applies split to the current global random generator, updates it with one of the results, and returns the other. "
07:21:42 <`Jake`> so I would guess that the "advantage" of getStdGen is that it doesn't change the global random generator, which is not necessarily an advantage, but might be sometimes
07:22:04 <fmap> > length . takeWhile not . map ("sub" `isPrefixOf`) $ tails "abcsubdef"
07:22:06 <lambdabot>   3
07:22:19 <shapr> @quote jmcarthur
07:22:20 <lambdabot> jmcarthur says: the worst thing about the jvm is java
07:22:23 <`Jake`> > getStdGen
07:22:24 <lambdabot>   No instance for (Data.Typeable.Typeable System.Random.StdGen)
07:22:24 <lambdabot>    arising fr...
07:22:30 <`Jake`> dang
07:22:42 <merijn> :t getStdGen
07:22:43 <lambdabot> IO StdGen
07:22:44 <covi> fmap: thanks
07:22:48 <covi> :t isPrefixOf
07:22:49 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
07:22:57 <covi> > tails [1,2,3,4]
07:22:59 <lambdabot>   [[1,2,3,4],[2,3,4],[3,4],[4],[]]
07:23:25 <fmap> covi: i'm sure there are more efficient ways though
07:24:59 <jonaskoelker> I hope I'm not butting in with my question here, but how'd you guys test an expression evaluator?  Generate random programs, run them and check their properties ith QuickCheck? O_o
07:25:08 <shapr> jonaskoelker: That would find the most bugs.
07:25:10 <jonaskoelker> (the language is pure and safe but not total)
07:25:23 <jonaskoelker> shapr: and might generate "while true: ..."
07:25:26 <`Jake`> that is actually quite interesting (for me anyways). I thought that newStdGen is non-deterministic, but in fact, with the same random global random generator, if you use newStdgen 5 times, you will always get the same 5 random generators.
07:25:55 <`Jake`> the same initial global rg
07:26:12 <jonaskoelker> `Jake`: I'd guess what it does is split (@hoogle split) an internal rg, store the left half and give the right half to the user (i.e. return it)
07:26:31 <jonaskoelker> thus, no surprise: since split is a deterministic function, the results are determined by the inputs =)
07:26:38 <jonaskoelker> @src newStdGen
07:26:39 <lambdabot> Source not found. Take a stress pill and think things over.
07:26:44 <`Jake`> jonaskoelker: yeah, that's what I copied from the documentation a few lines above, I just didn't know it before
07:26:46 <jonaskoelker> hur hur, lambdabot ;-)
07:27:08 <jonaskoelker> `Jake`, are you trying to imply that this channel isn't write-only? :D
07:27:52 <`Jake`> jonaskoelker: no, I will always explicitly say what I mean ;-)
07:28:09 <jonaskoelker> :)
07:31:29 <jonaskoelker> freaky debian package: shunit2, a shell script unit testing fw
07:32:13 <jonaskoelker> wth?!  If your shell script has _units_, you may be using a hammer when you wanted a steamroller
07:35:01 <merijn> jonaskoelker: I'd recommend you never look at BSD, then
07:49:45 <covi> any $ map isDigit "13"
07:49:51 <covi> > any $ map isDigit "13"
07:49:52 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
07:49:52 <lambdabot>         against inferred ...
07:50:04 <ski> > any isDigit "13d"
07:50:05 <lambdabot>   True
07:50:12 <ski> > all isDigit "13d"
07:50:13 <lambdabot>   False
07:50:18 <covi> :t any
07:50:20 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
07:50:31 <covi> ski: ty
07:50:32 <ski> > all isHexDigit "13d"
07:50:32 <lambdabot>   True
07:53:48 <ion> !units --help
07:53:54 <ion> Sorry, wrong channel.
07:55:20 <covi> why does not this work: http://hpaste.org/69016
07:55:23 <ski> @let forAny :: [a] -> Cont Bool a; forAny = cont . flip any
07:55:24 <lambdabot>  Defined.
07:55:30 <ski> @let forAll :: [a] -> Cont Bool a; forAll = cont . flip all
07:55:31 <lambdabot>  Defined.
07:55:41 <ski> > evalCont $ do c <- forAny "13d"; return (isDigit c)
07:55:42 <lambdabot>   True
07:55:49 <ski> > evalCont $ do c <- forAll "13d"; return (isDigit c)
07:55:50 <lambdabot>   False
07:56:54 <ski> > evalCont $ do m <- forAll [0 ..]; n <- forAny [0 ..] return (m < n)
07:56:55 <lambdabot>   <no location info>:
07:56:55 <lambdabot>      The last statement in a 'do' construct must be an ...
07:56:59 <ski> > evalCont $ do m <- forAll [0 ..]; n <- forAny [0 ..]; return (m < n)
07:57:02 <lambdabot>   mueval-core: Time limit exceeded
07:57:14 <ski> > evalCont $ do m <- forAll [0 .. 15]; n <- forAny [0 ..]; return (m < n)
07:57:16 <lambdabot>   True
07:57:28 <covi> ski: can you please take a look at this? I want to implement a simple argument handling: http://hpaste.org/69016
07:58:17 <dmwit> covi: Your "let" needs an "in".
07:58:45 <ski> i'd use an `if'-`then'-`else' instead of a `case'-`of' here
07:59:30 <dmwit> Wow, SPJ is a freaking machine.
07:59:46 <ski> also, i'd replace `rawArgs <- getArgs' with `arg:fileList <- getArgs'
07:59:51 <covi> In a do block, I learned that every line is supposed to be a monadic value. So what should I write after 'then' 'else' or 'in'
07:59:57 <fmap> covi: you need to repeat "do" after True -> if you want another do-block
08:00:05 <dmwit> Ticket created 11 hours ago, ticket closed as fixed 4 hours ago.
08:00:20 <ski> or maybe `arg@(read -> numLinesToDisplay):fileList <- getArgs'
08:00:22 <rwbarton> either 7 hours or 7 years
08:00:37 <ski> covi : an expression
08:00:37 <dmwit> hahaha
08:01:28 <k-zed> oh, lambdabot fails to build :(
08:01:54 <k-zed> google finds the error message in a hpaste, but no other comments...
08:01:57 <k-zed> http://hpaste.org/68566
08:03:13 <quicksilver> ski: yuck :)
08:03:24 <k-zed> for that matter, cabal install lambdabot --ghc-options=-XFlexibleInstances works
08:03:27 <k-zed> not sure i want to know
08:03:47 <ski> quicksilver : not any more than the existing code :)
08:03:53 <covi> dmwit: what should I write after `in`?
08:03:53 <quicksilver> ski: :)
08:04:07 <covi> 'in main' does not work as expectedc
08:04:47 <ski> covi : what do you want to do after having reached the `True' case, and bound `numLinesToDisplay' and `fileList' ?
08:05:42 <ski> covi : surely you can't expect to only write more code below the `case'-expression, since `numLinesToDisplay' and `fileList' will only be bound in one of the branches, not the other
08:06:00 <manish411> is there a function which can parse integers like char 'c' can parse characters
08:06:09 <manish411> in parsec library ??
08:06:15 <covi> ski: I want the two bindings to be available to the following code in the main do blcok
08:07:20 <armlesshobo> covi: then do it at the top?
08:07:34 <covi> armlesshobo: yeah
08:07:52 <ClaudiusMaximus> main = do{ args <- getArgs ; processedArgs <- case args of { ... } ; mainCode }  is a common pattern in my code
08:08:23 <dmwit> covi: After the "in", put the code that you want to execute that uses the variables you just bound.
08:08:53 <covi> dmwit: oops, that might be a little lengthy, because I want the variables to be available to all the following code
08:09:04 <merijn> In TH how do I check whether a function named foo exists?
08:09:13 <covi> ClaudiusMaximus: if you use case expressions, what do you put in each branch after the ->
08:09:38 <dmwit> covi: ...so?
08:09:59 <fmap> covi: i'd use unless instead of case expression here
08:10:07 <barrucadu> covi: No more lengthly than having the code after the let rather than in it
08:10:16 <dmwit> exactly
08:10:43 <ski> covi : is `numLinesToDisplay' meant to be an `Integer' ?
08:10:49 <covi> ski: yeah
08:10:52 <covi> :t unless
08:10:53 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
08:11:22 <navaati> is using a lot of IORef in event handlers the usual way to use gtk2hs ?
08:11:52 <fmap> unless (all isDigit (head rawArgs)) $ error usageMessage
08:12:23 <dmwit> navaati: pretty much, yup
08:12:43 <quicksilver> navaati: or just one IORef, perhaps
08:12:44 <hpaste> ski annotated “dasd” with “one possibility” at http://hpaste.org/69016#a69017
08:12:47 <quicksilver> or just one MVar.
08:12:49 <covi> unless seems good
08:12:59 <navaati> eww
08:13:03 <navaati> thanks
08:13:08 <quicksilver> or some sensible abstraction with lenses so each handle can 'see' the part of your program state it needs
08:13:21 <quicksilver> without it being aware that it is, ineed, stored in an IORef/MVar
08:13:27 <quicksilver> navaati: I don't see why it's eww
08:13:44 <quicksilver> gtk handlers are IO callbacks, IO has extensible state, so you use that to make your state available to the callback.
08:14:01 <covi> ski: got it, thanks
08:14:04 <quicksilver> you can certainly abstract away from it.
08:14:45 <navaati> yeah, yeah, it's just that… i've lost habit of mutable stuff
08:14:54 <navaati> but it's not that much a problem
08:15:49 <quicksilver> the difference between IORef Foo and State Foo is largely unimportant
08:16:00 <quicksilver> in both cases the actual Foo is immutable, like all haskell data
08:16:15 <quicksilver> you just have a slightly different mechanism for 'changing the Foo we're currently talking about'
08:19:30 <manish411> neone having experience with parsec library?
08:22:55 <dmwit> manish411: Don't ask to ask. Just ask.
08:23:28 <manish411> I need to parse an integer , what function should I use ?
08:24:07 <quicksilver> fmap read (many digit)
08:24:08 <quicksilver> perhaps
08:24:08 <mauke> depends on the format
08:24:39 <manish411> http://pastebin.com/jRnkfLaH
08:24:41 <sykora> quicksilver: that will give you a list of digits
08:24:41 <mauke> The paste jRnkfLaH has been copied to http://hpaste.org/69018
08:24:48 <manish411> dont know whats wrong with this code
08:25:29 <sykora> manish411: Text.Parsec.Char.digit returns a char
08:25:34 <mauke> manish411: 'in' is a keyword
08:25:38 <manish411> ok
08:25:43 <mauke> manish411: otherwise it's equivalent to in = digit
08:25:53 <mauke> which is likely Parser Char
08:25:55 <kallisti_> how is memory stored in IORefs garbage collected?
08:26:30 <kallisti_> I would guess that you need to do some sort of reference counting.
08:26:57 <dmwit> manish411: Use natural, integer, float, naturalOrFloat, decimal, hexadecimal, or octal from http://hackage.haskell.org/packages/archive/parsec/3.1.2/doc/html/Text-Parsec-Token.html ?
08:27:00 <mauke> kallisti_: no, it uses a garbage collector
08:28:27 <quicksilver> sykora: what?
08:28:49 <dmwit> Yeah, I think sykora somehow missed the "fmap read" entirely.
08:28:59 <quicksilver> sykora: many digit will give a list of digits, yes, and "fmap read" will parse it
08:29:07 <quicksilver> sykora: given the right context, into an Integer.
08:29:12 <parcs`> manish411: Text.Parsec.Token
08:29:14 <merijn> kallisti_: How is there memory stored in an IORef?
08:29:27 <dmwit> parcs`: too slow
08:29:29 <merijn> kallisti_: The IORef *is* the memory as far as I'm aware
08:29:29 <kallisti_> how is there... not?
08:29:34 <parcs`> dmwit: :(
08:29:34 <kallisti_> right.
08:29:41 <quicksilver> kallisti_: the IOREf contains a single pointer.
08:29:45 <merijn> So you just GC when the last IORef disappears, same as any data
08:29:55 <quicksilver> the GC is not *very* different from other haskell GC
08:30:15 <quicksilver> although in GHC's implementation the fact that it's mutable means it breaks a clever generational optimisation
08:30:23 <quicksilver> but that's not a big problem.
08:30:53 <kallisti_> ah I see
08:31:10 <kallisti_> I guess I thought that the mutability would make it not fit into Haskell's typical garbage collection scheme.
08:31:39 <kallisti_> but the reference itself is immutable.
08:33:11 <manish411> http://hpaste.org/new
08:33:22 <manish411> now it can identify ParsecT
08:33:26 <armlesshobo> like a constant pointer
08:33:32 <manish411> I mean cannot identify ParsecT
08:33:43 <armlesshobo> the address value is immutable, but the area of mem it points to is
08:33:49 <quicksilver> kallisti_: mutability isn't really relavant to GC in general.
08:33:58 <quicksilver> kallisti_: at least - if you stop the world.
08:34:01 <quicksilver> which GHC does.
08:34:27 <quicksilver> the only thing mutability does is break the 'pointers can only point back generations' invariant
08:34:38 <mauke> manish411: your url is wrong and your description of the error is wrong
08:35:00 <mauke> quicksilver: let x = () : x
08:35:29 <armlesshobo> lol
08:35:38 <manish411> http://hpaste.org/69019
08:36:20 <quicksilver> mauke: not sure what your point is?
08:36:50 <quicksilver> the (:)-cell is allocated first, then the x pointer is set, so it points back (or to the same) generation
08:36:51 <dmwit> quicksilver: I suppose his point is that even with immutability, pointers can point to equal generations.
08:36:56 <quicksilver> of course
08:37:10 <quicksilver> I didn't mean to exclude that case.
08:37:47 <dmwit> manish411: integer is not a primitive parser.
08:37:52 <dmwit> manish411: Did you even read the documentation?
08:37:58 <armlesshobo> dmwit: nope
08:38:00 <dmwit> manish411: There's an example of how to use it Right There.
08:38:23 <manish411> ya I quite new to parsing so having difficulty
08:38:39 <mikeplus64> http://quasimal.com/posts/2012-05-25-quasitext-and-quasiquoting.html if anyone is interested
08:38:52 <mikeplus64> just a little quasiquotation/template haskell tutorial
08:39:29 <chridi> hi
08:39:57 <chridi> I want to use Control.Concurrent.*.. but also haskell2010.. so i need only this package from base?
08:40:48 <everythingWorks> hey
08:40:53 <everythingWorks> anyone inhere uses eclipse?
08:41:09 <everythingWorks> (Because i have got some problem with my syntax highlighting :) )
08:41:24 <dmwit> chridi: I'm not sure I understand the question.
08:42:25 <chridi> dmwit: im using cabal... so i have to specify the packages i want to use.. i want to use control.concurrent (for STM), which is in base
08:42:54 <chridi> dmwit: then i used base.. but with this i got some problems from Network.Info... which they dont exist if i use haskell2010..
08:43:17 <chridi> if i use both.. cabal reports that the libraries overlap or so
08:43:54 <dmwit> Well, if you're using Control.Concurrent, I don't see that you can claim to just be using Haskell 2010.
08:44:11 <chridi> hmh..
08:44:26 <chridi> so my question is:  How can i use base only for Control.Concurrent?
08:44:44 <chridi> is this even possible?
08:44:50 <dmwit> Can we back up a bit?
08:44:56 <fwaht> what do i need to do to get haskell-mode-tag-find working?
08:45:02 <dmwit> "then i used base.. but with this i got some problems from Network.Info"
08:45:10 <dmwit> What is Network.Info, and what problems did you get?
08:45:16 <chridi> yes.. i wanted to "show" a IPv4 Address
08:45:56 <tgeeky__> http://hackage.haskell.org/packages/archive/network-info/0.2.0.1/doc/html/Network-Info.html <--
08:45:59 <dmwit> What does this have to do with choosing between "base" and "haskell2010"?
08:46:02 <tgeeky__> http://www.haskell.org/ghc/docs/latest/html/libraries/base/index.html <--
08:47:01 <tgeeky__> chridi: you probably do not want to specify haskell2010 in your .cabal file. You probably just want base.
08:47:02 <shapr> yay code!
08:47:21 <chridi> dmwit: i got a strange error from ghc, that it could not "show" this IPv4 address when using base
08:47:47 <chridi> tgeeky__: hmh.. i just want it to work ;)
08:47:53 <dmwit> chridi: I very doubt that this is base's fault.
08:48:08 <dmwit> You should specify that you want to use base, and figure out what you did wrong when trying to show your address.
08:48:08 <chridi> well
08:48:25 <chridi> it works now with base
08:49:26 <chridi> dmwit: I just wonderd why it worked in ghci but not in ghc
08:49:37 <chridi> but it works now with base... strange error
08:50:10 * hackagebot hbayes 0.4 - Inference with Discrete Bayesian Networks  http://hackage.haskell.org/package/hbayes-0.4 (alpheccar)
08:50:12 * hackagebot operational 0.2.1.0 - Implement monads by specifying operational semantics.  http://hackage.haskell.org/package/operational-0.2.1.0 (HeinrichApfelmus)
08:50:43 <chridi> so you recommend to always use base?
08:51:24 <everythingWorks> I've read now a few documents about foldl but i simply don't get it :/. Can you try to explain it by example, please? This is the factorial function: foldl (*) 1 [1..n]
08:52:00 <mauke> > foldl f z [a, b, c, d]
08:52:01 <lambdabot>   f (f (f (f z a) b) c) d
08:52:14 <mauke> > foldl (*) 1 [a, b, c, d]
08:52:15 <lambdabot>   1 * a * b * c * d
08:52:19 <dmwit> chridi: Not at all.
08:52:37 <dmwit> chridi: However, only packages striving to be Haskell-2010-compatible should depend on haskell2010.
08:52:48 <dmwit> If you're using Control.Concurrent, you obviously aren't striving for that very hard.
08:52:49 <chridi> okay
08:52:49 <everythingWorks> intresting, i got the basic idea
08:53:02 <chridi> all packages in haskell2010 are also in base?
08:53:17 <timthelion> If I have myGiantObject and I do foo = (something,myGiantObject) and then I check the condition (myGiantObject == snd foo) am I doing something hugely inefficient?
08:53:21 <everythingWorks> but why do we have to provide one single value and then a whole list? What is the purpose? I could let it take just one list, which would make it a bit less complex.
08:53:31 <fwaht> anyone know how to get tags working with haskell mode?
08:53:37 <dmwit> chridi: All modules in haskell2010 are also in base, yes.
08:53:38 <chridi> everythingWorks: you have a start value
08:54:06 <chridi> dmwit: okay.. so i'll use base.. thx :)
08:54:11 <everythingWorks> chridi: Yep, but why not let the start value be the first item of the list?
08:54:11 <dmwit> everythingWorks: The type of the extra value isn't necessarily the same as the type of the list elements.
08:54:26 <chridi> everythingWorks: for this you have foldl1
08:54:39 <everythingWorks> ah, i understand. dmwit can you give me an example, please?
08:54:41 <dmwit> timthelion: yes
08:54:55 <everythingWorks> chridi: thanks for the hint
08:55:12 <dmwit> ?src reverse
08:55:12 <lambdabot> reverse = foldl (flip (:)) []
08:55:17 <mauke> everythingWorks: what if the list is empty?
08:55:18 <dmwit> everythingWorks: there you go
08:55:33 <armlesshobo> mikeplus64: is this your sorcery?
08:55:46 <timthelion> dmwit: and why?  Isn't ghc smart enought to make foo = (something, pointerToMyGiantObject) and then check if the locations in memory are the same?
08:55:53 <everythingWorks> nice, ty.
08:56:01 <dmwit> timthelion: No, it's not.
08:56:14 * timthelion is dissapointed
08:56:33 <mauke> timthelion: how did you define == ?
08:56:44 <Luke> hey guys, i'm trying to convert an HDBC SqlValue with fromSql (specifically a SqlDouble constructor) but ghci is saying I need to add a (Convertable SqlValue) instance.... any idea why this would happen? I can see the instance exists already in the HDBC module.
08:56:56 <timthelion> mauke: that's a good question.
08:57:15 <absence> mm_freak_: http://hpaste.org/69020 <- things are finally starting to shape up :) do you see something that's very stupid?
08:57:43 <mikeplus64> armlesshobo: hm?
08:57:50 <mikeplus64> the quasimal post? yeah
08:58:59 <timthelion> mauke: theoretically, ghc could(and potentially should) do a binary level implimentation of == it will always work(I think?) and it will be faster in most cases and much faster in the case where the location is the same.  It doesn't matter though, I can work arround this without problem
08:59:47 <armlesshobo> mikeplus64: i like it. it's very interesting :)
09:00:02 <mikeplus64> thanks
09:00:19 <mauke> timthelion: memory addresses aren't constant. the garbage collector moves objects
09:00:22 <armlesshobo> mikeplus64: i'm glad you included fibonacci sequence. I thought I was going to be let down :P
09:00:29 <armlesshobo> mikeplus64: but you shined through on that one lol
09:00:35 <mikeplus64> :)
09:00:48 <mikeplus64> almost redefined natural numbers using type level programming but didn't quite get there
09:00:55 <dmwit> timthelion: It is not the same, and never will be.
09:01:05 <timthelion> mauke: that doesn't matter, so long as the GC doesn't move the object during the == test
09:01:13 <dmwit> timthelion: let x = x in x == x should never return
09:01:36 <mauke> timthelion: "so long as" - yeah, that's pretty much the problem, isn't it?
09:02:12 <timthelion> mauke: only in improperly written parallel code
09:02:20 <mauke> timthelion: what?
09:02:24 <dmwit> Yeah, what?
09:03:01 <timthelion> well, we could lock the GC for the time it took to process ==
09:03:12 <mauke> how?
09:03:27 * timthelion realises that could take as much time as doing a binarry equality check would save...
09:03:32 <nand`> What's the correct way to handle an error like “<socket: 5>: hIsEOF: illegal operation (handle is closed)”?
09:04:02 <ion> Avoid doing that operation.
09:04:06 <mauke> timthelion: first off, you'd have to teach ghc that any implementation of (==) is "magic", no matter where it's defined
09:04:16 <mauke> timthelion: second, what if you run out of memory during the call to (==)?
09:04:53 <timthelion> mauke: :D == doesn't have to allocate any memory
09:05:00 <mauke> timthelion: why not?
09:05:05 <quicksilver> timthelion: of course it does
09:05:13 <quicksilver> (==) can contain arbitrary code
09:05:25 <quicksilver> and the thunks on either side of it can also contain arbitrary code
09:05:34 <mauke> which is the bigger problem
09:05:34 <quicksilver> and only the implementation of (==) controls how much those thunks will be forced
09:05:43 <timthelion> ah, yeah, sorry... C guy here, forgot about first class functions, lazyness and all that ...
09:05:43 <nand`> ion: I'm not sure how to avoid it
09:05:46 <quicksilver> and how much will be allocated in that process.
09:06:15 <timthelion> ok, you guys are right
09:06:16 <nand`> ion: I have one thread in an endless hIsEOF -> process -> recurse loop; and another thread needs to close the socket for program logic reasons
09:07:45 <zenzike_> Luke: that sounds a little odd
09:08:07 <nand`> note that it already works fine, since I have a SomeException e handler that simply prints the exception to the screen when it happens in a thread (for debugging reasons), and I have a ‘finally’ making sure the affected resources get cleaned up properly
09:08:14 <Luke> zenzike_: I figured it out. I was leaving the type variable unbound =/
09:08:26 <nand`> I just want to hide the error message now
09:08:38 <zenzike_> Luke: ah, phew :-)
09:08:44 <Luke> zenzike_: (SqlValue a) is the type =) I needed to tell it I was expecting a double - my fault
09:08:54 <navaati> is there an example somewhere on using diagrams with gtk ?
09:09:04 <Luke> zenzike_: you're the maintainer of hdbc?
09:09:07 <zenzike_> Luke: yes indeed, it can't guess that for you
09:09:09 <zenzike_> Luke: yep
09:09:22 <Luke> zenzike_: thanks =) it's super useful to me
09:09:28 <Luke> works great too
09:09:39 <zenzike_> glad to hear it
09:10:09 <zenzike_> if you get stuck then try sending an email to the cafe too: I don't always listen to irc
09:10:31 <Luke> zenzike_: thanks
09:12:03 <dmwit> navaati: maybe try #diagrams
09:13:42 <jfischoff> does anyone know what steps to modify to build ghc from the github repo?
09:13:53 <jfischoff> I'm trying to build the ios branch
09:14:10 <bitonic> jfischoff: doesn't the author of that release patches?
09:14:32 <jfischoff> bitonic: no longer
09:14:40 <bitonic> jfischoff: so where is this iphone branch?
09:15:06 <jfischoff> bitonic:https://github.com/mietek/ghc
09:15:44 <jfischoff> bitonic: there are other repositories for other packages … which might be needed to boot ghc I don't know
09:16:30 <bitonic> jfischoff: I don't follow you, that's a fork of the ghc repo, but it's not any particular branch
09:16:49 <jfischoff> bitonic: the other repositories are packages-base, packages-Cabal, hsc2hs
09:16:49 <jfischoff> \
09:16:56 <jfischoff> bitonic: the branch is ios
09:17:04 <bitonic> ok
09:17:09 <jfischoff> you can see it in the drop down
09:17:35 <Luke> is there some way to use applicative functors to build a type with a data constructor of three arguments from a list of 3 elements?
09:17:35 <bitonic> jfischoff: so what problems are you having? I'd attempt to build it normally from that branch
09:17:48 <kallisti_> Luke: no
09:18:01 <kallisti_> you need to just pattern match directly
09:18:05 <Luke> kallisti_: what about form a tuple of 3 elements?
09:18:16 <Luke> kallisti_: thanks. that's what I'm doing now
09:18:20 <kallisti_> (,,) <$> x <*> y <*> z
09:18:21 <kallisti_> sure
09:18:22 <jfischoff> bitonic: the first step before building is to call ./sync-all get, which fails
09:18:34 <Luke> kallisti_: awesome - thanks
09:18:58 <jfischoff> bitonic: I think I know why, but I'm not sure exactly how to fix it ....
09:19:06 <mietek> Hello
09:19:09 <bitonic> jfischoff: fails how?
09:19:25 <bitonic> jfischoff: that shouldn't have anything to do with that specific branch
09:19:38 <mietek> The author of the ios patches is blackh, but he's not online now
09:20:10 <jfischoff> mietek: I just need help building from ghc from github in general.
09:20:25 <mietek> GHC on github is just a mirror of the official repos
09:20:31 <mietek> So you should be able to follow the official instructions
09:20:42 <bitonic> jfischoff: I guess you are already following this page: http://hackage.haskell.org/trac/ghc/wiki/Building/GettingTheSources
09:20:49 <mietek> http://hackage.haskell.org/trac/ghc/wiki/Building
09:20:52 <mietek> Race.
09:21:28 <jfischoff> so I have a ghc HEAD from the official repositories, and I can build from that fine
09:23:27 <jfischoff> the github one is failing because from what I can gather from looking at sync-all it builds addresses for remote repositories based on the address of the ghc main repository. However it can't find the other repositories
09:23:46 <jfischoff> I'll hpaste the error if that would help
09:24:45 <nand`> ion: never mind, I figured out how to fix my problems; avoid hIsEOF entirely and switch to lazy IO
09:24:58 <jfischoff> mietek: does sync-all work for you?
09:25:13 <jfischoff> mietek: or is it unnecessary?
09:26:30 <mietek> Have you tried using  -r http://darcs.haskell.org/
09:26:31 <mietek> ?
09:27:19 <jfischoff> mietek: does that have the iOS branch?
09:27:42 <mietek> jfischoff: no, it does not.
09:29:31 <jfischoff> mietek: then I am not why I should do that. sync-all is looking for the repository ghc-tarballs.git
09:33:46 <jfischoff> mietek: I'm going to copy and paste the directory from my other ghc clone which builds fine, if you any other suggestions let me know.
09:35:32 * jfischoff is making progress
09:35:56 <`Jake`> Are Integers significantly slower than Ints?
09:36:06 <c_wraith> Not usually
09:36:14 <parcs`> jfischoff: change the remote url to http://darcs.haskell.org/ghc.git
09:36:18 <rwbarton> it depends
09:36:21 <c_wraith> Until they get aboslutely huge, at which point they're much more correct
09:36:28 <sclv> should be about 2x as slow or so?
09:36:39 <sclv> at max.
09:36:42 <jfischoff> parks`: how?
09:36:44 <`Jake`> ok, thanks
09:36:49 <sclv> there's an additonal branch/indirection at least.
09:37:00 <rwbarton> max meaning best case?
09:37:04 <rwbarton> for Integer?
09:37:04 <c_wraith> sclv: only in the same range.  can be thousands of times slower when they're thousands of times bigger.
09:37:08 <sclv> worst case
09:37:11 <sclv> c_wraith: yeah
09:37:12 <parcs`> jfischoff: git remote set-url origin http://darcs.haskell.org/ghc.git
09:37:13 <rwbarton> sometimes Int can allow further optimizations
09:37:17 <sclv> i mean for int sized integers.
09:37:32 <parcs`> jfischoff: you generally can't build ghc from the github repository
09:37:33 <sclv> i'm speculating having read about how gmp works
09:37:38 <sclv> but not having profiled carefully.
09:37:42 <parcs`> it's just a mirror that's useful for the initial cloning
09:37:49 <parcs`> because it's fast
09:38:04 <jfischoff> parcs`: ah and there in lies my confusion
09:38:04 <rwbarton> like putting your loop variables in registers
09:38:12 <sclv> also, yeah, you can't unbox an Integer like an Int.
09:38:20 <sclv> and unpack and etc.
09:38:40 <sclv> so for tight inner loop stuff where you want everything to fuse into a strict loop
09:38:45 <sclv> you'll lose elsewhere too.
09:41:59 <ion> Ooh, i like the apparent simplicity of http://hackage.haskell.org/packages/archive/pipes/2.0.0/doc/html/Control-Pipe.html
09:43:30 <burbul> What I have to do to be able to use Unicode characters in Haskell source?
09:43:57 <burbul> (Haskell platform 2011.2.0.1)
09:43:58 <ion> !google haskell unicode source
09:44:12 <ion> Hmm. What was the command again?
09:44:14 <ion> @google haskell unicode source
09:44:17 <lambdabot> http://www.haskell.org/haskellwiki/Unicode-symbols
09:44:17 <lambdabot> Title: Unicode-symbols - HaskellWiki
09:44:40 <burbul> ah -- sorry
09:44:43 <burbul> That was stupid of me
09:44:44 <c_wraith> depends on if you want unicode syntax, or just unicode identifiers and constants
09:44:52 <c_wraith> the latter needs no special work
09:45:00 <burbul> I just want to be able to use it inside a string literal, and I was told that would work out of the box
09:45:13 <burbul> (By a friend who is very into Unicode)
09:45:17 <burbul> But if I type
09:45:18 <burbul> a = "xxxλyyy"
09:45:21 <c_wraith> It does, assuming the file's encoding matches what ghc expects
09:45:33 <ion> Type that in what?
09:45:39 <burbul> Leksah
09:45:51 <c_wraith> It's possible ghc specifically looks for UTF-8, regardless of system encoding
09:46:12 <burbul> Leksah displays it correctly, but it's possible that it's not actually saving it correctly... let me check
09:46:37 <c_wraith> yeah, it's also possible leksah is interfering, due to its magic unicodization of source (which I rather dislike anyway)
09:46:57 <burbul> I have the magic switched off. But  notepad2 reckons the encoding is ANSI, which would explain the problem...
09:47:05 <ion> ಠ_ಠ
09:47:17 <ion> What does file(1) say about it?
09:47:43 <c_wraith> if he's mentioning notepad2, he's probably not on a unix system...
09:49:04 <Luke> can I use fmap or something with uncurry to uncurry a tuple of a size greater than 2?
09:49:05 <burbul> Windows + cygwin, I'm afraid -- should have mentioned that earlier
09:49:44 <Luke> put another way: what's the preferred way to apply a tuple of 4 as arguments to a function of arity 4?
09:49:56 <mietek> jfischoff: I think the idea is to do the initial cloning of all packages from mainline, and then set the remote for all packages which need ios patches to the github/ios repositories.
09:49:58 <burbul> GAH! Leksah forces the encoding back to ANSI every time I save..
09:50:01 <bartavelle> quick question : can I write a tls client using mutual authentication with the tls package ?
09:50:05 <edwardk> uncurry4 f (a,b,c,d) = f a b c d
09:50:12 <bartavelle> according to the documentation it seems it works
09:50:27 <ion> luke: Are you sure you want 4-tuples in the first place?
09:50:28 <bartavelle> except it ends with Alert [(AlertLevel_Fatal,InternalError)] just after the handshake
09:50:29 <bartavelle> humm
09:50:30 <edwardk> ~(a,b,c,d) if you really want to care about strictness at the expense of performance
09:50:52 <burbul> Though the manual says "Leksah reads and writes files encoded in UTF-8."
09:51:19 <Luke> ion: i'm making a Cartesian product of 4 dimensions
09:51:45 <edwardk> in general i tend just cps the code and call the function directly rather than toss around a tuple that will just be applied, but that depends on the problem
09:51:47 <Luke> edwardk: thanks
09:52:02 <ion> luke: ok :-)
09:52:04 <Luke> edwardk: what package is uncurry4 in?
09:52:15 <edwardk> luke: its nowhere. i wrote it right there
09:52:35 <Luke> edwardk: ooh - yeah I have my own written... i was wondering if there was a clever way to use something else
09:52:40 <edwardk> nope
09:53:01 <edwardk> there is very little you can do with tuples of length > 2
09:53:05 <Luke> ion: the alternative would be to call the function in the list comprehension generating the cartesian product which would result in a list of IO actions
09:53:15 <Luke> edwardk: gotcha - thanks
09:53:34 <edwardk> luke: you are taking a cartesian product of what?
09:53:49 <Luke> basically possible "configs" if you will
09:53:55 <edwardk> > (,,,) <$> [1,2] <*> [3,4] <*> [5,6] <*> [7,8]
09:53:56 <lambdabot>   [(1,3,5,7),(1,3,5,8),(1,3,6,7),(1,3,6,8),(1,4,5,7),(1,4,5,8),(1,4,6,7),(1,4...
09:54:17 <Luke> yeah thta'd do it
09:54:30 <edwardk> why go through the tuple at all though? just put f instead of (,,,) in there
09:54:31 <Luke> [(s, f, a) | s <- x, f <- y, a <- z]
09:54:44 <Luke> edwardk: because it's an IO function
09:54:50 <Luke> also, I want to call a non IO function with the same arguments
09:55:09 <edwardk> you can get a list of io actions that way, then use sequence to smash it flat in the IO case
09:55:21 <Luke> which would result in a [(IO Int, String)] which is awkward
09:55:54 <ion> What’s wrong with sequence acts?
09:56:14 <ion> Oh, there’s a “, String” i missed.
09:56:38 <Luke> yeah that's the awkward part - I want to apply the cartesian product to an IO function as well as a non IO function
09:56:49 <Luke> I guess I could map them both separately and then zip the results or something
09:57:26 <edwardk> just get the io action out of the way early, using traverse/sequence and then you're back to playing with pretty pure functions
09:57:55 <Luke> good call
09:58:05 <Luke> I'll just pass the function as an argument to the cartesian product generator
09:58:21 <edwardk> note the 'cartesian product generator is just liftAn
09:58:24 <edwardk> for some n
09:58:25 <edwardk> =)
09:58:34 <Luke> ?
09:58:40 <edwardk> :t liftA3
09:58:40 <lambdabot> forall a b c d (f :: * -> *). (Applicative f) => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
09:58:46 <edwardk> where f = []
09:59:00 <edwardk> > liftA2 (+) [1,2,3] [4,5,6]
09:59:01 <lambdabot>   [5,6,7,6,7,8,7,8,9]
09:59:07 <Luke> oh awesome!
09:59:09 <edwardk> > liftA2 (,) [1,2,3] [4,5,6]
09:59:10 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
09:59:11 <Luke> thanks
09:59:21 <edwardk> > liftA3 (,,) [1,2,3] [4,5,6] [1,2]
09:59:21 <lambdabot>   [(1,4,1),(1,4,2),(1,5,1),(1,5,2),(1,6,1),(1,6,2),(2,4,1),(2,4,2),(2,5,1),(2...
09:59:37 <edwardk> > liftA3 (\x y z -> x * y + z) [1,2,3] [4,5,6] [1,2]
09:59:38 <lambdabot>   [5,6,6,7,7,8,9,10,11,12,13,14,13,14,16,17,19,20]
10:01:26 <Luke> edwardk: yup - this looks bad ass now - thanks a lot
10:02:21 <Luke> is there a clever way to get the function argument last instead of first for point-free?
10:03:06 <shirt> what's the simplest way to convert Data.Text to Data.ByteString?
10:03:26 <monochrom> first choose an encoding
10:03:27 <Luke> encodeUft16BE
10:03:31 <Luke> or whatever the encoding
10:03:44 <Luke> utf*
10:03:44 <monochrom> haha that's evil
10:03:47 <`Jake`> @src (^^)
10:03:48 <lambdabot> x ^^ n      =  if n >= 0 then x^n else recip (x^(negate n))
10:04:10 <jfischoff> mietek: ah, thanks for the clarification :)
10:04:16 <`Jake`> @src recip
10:04:17 <lambdabot> Source not found. Do you think like you type?
10:04:19 <ion> Yeah, encodeUtf16BE should do it. :-D
10:04:44 <ion> jake: (1/)
10:04:52 <`Jake`> oh, thanks
10:04:59 <monochrom> the result will probably be recognized by wordpad :)
10:05:08 <tehgeekmeister> waaaaaaaiiiit.  it isn't possible to, without using unsafePerformIO, or equivalents, to leak values you've retrieved by IO, from the IO monad, is it?
10:05:19 <mietek> jfischoff: I'm not sure; I'm actually trying it right now.
10:05:22 <tehgeekmeister> because it looks like i just did that on accident.
10:05:22 <`Jake`> I was confused because I actually wanted to see the source of **...
10:05:27 <`Jake`> @src (**)
10:05:28 <lambdabot> Source not found. There are some things that I just don't know.
10:05:33 <`Jake`> oh well
10:05:36 <`Jake`> hackage will help me
10:05:45 <nand`> isn't (**) a class method
10:05:49 <nand`> ..
10:05:50 <ion> tehgeekmeister: You’re free to call pure functions from IO code.
10:05:51 <nand`> wow
10:05:54 <nand`> did I just say that?
10:05:55 <monochrom> I would love to know what is the accident
10:05:59 <ion> tehgeekmeister: And give them whatever values you want to.
10:06:43 <tehgeekmeister> ion: no, i mean i'm reading a bunch of values from a file, and returning them from a function, and somehow IO isn't in the type.
10:07:05 <barrucadu> Paste the code.
10:07:08 <tehgeekmeister> (still checking to make sure this works like i think it does, however.  totally confused by this.)
10:08:06 <nand`> Maybe MonadIO or other similar abstractions (that internally include IO) are in the type?
10:08:23 <jfischoff> mietek: fyi, what I did, clone the master from github, pull the ios branch,  git remote set-url origin http://darcs.haskell.org/ghc.git, then follow the instructions for building. which I guess means I don't have the correct branch for some packages….
10:08:34 <ion> tehgeekmeister: readFile, getContents et al. do a horrible abomination called lazy IO.
10:08:42 <mietek> jfischoff: you're missing the other ghc clones I have on my github
10:08:55 <tehgeekmeister> ion: i'm not doing any of that.
10:08:57 <mietek> jfischoff: I think.
10:09:04 <tehgeekmeister> ion: also, they still wrap their results in the IO monad.
10:09:18 <jfischoff> mietek: Yeah, I think so too just wanted to see what would happen if I tried to build
10:09:33 <ion> tehgeekmeister: Just paste the code. :-)
10:09:48 <mietek> jfischoff: the other ghc *forks* I mean
10:09:55 <jfischoff> yeah
10:10:23 <mietek> jfischoff: also, the ios branch might be a few days behind master... blackh isn't available very often
10:10:33 <mietek> jfischoff: and I haven't had time to start helping
10:10:47 <luite> shapr: don't think it'll be ready today, still dealing with some float issues (and there might be more), plus i have to fix a few things in my dynamic linker to reduce the huge number of requests
10:10:59 <jfischoff> mietek: I think its fine. It said it was ahead by three commits
10:11:12 <ninegrid> when I try and use IO from GHCi i get the error that it failed to load interface for IO it apart of the hidden package haskell98,  do I have to use haskell98 to work with IO?
10:11:49 <ski> tehgeekmeister : possibly `IO' is hidden inside your return type, inside a `type' synonym, or a `data' or `newtype' declaration
10:12:07 <tehgeekmeister> ski: that seems likely
10:12:15 <tehgeekmeister> i lifted some IO inside the state monad
10:12:44 <nand`> tehgeekmeister: well what *is* the type of your function that you suspect is leaking IO?
10:12:57 <shapr> luite: Aw, that's too bad
10:12:57 <rwbarton> ninegrid: import System.IO not import IO
10:13:09 <shapr> luite: If you get anything at all reading, I'd like to see it!
10:13:10 <tehgeekmeister> https://gist.github.com/596a463f9469bce69d38
10:13:23 <luite> shapr: i still have some hours to work on it today, at wat time do you have your meeting?
10:13:42 <shapr> luite: Just over an hour from now.
10:13:52 <luite> hm, ok, not going to make that
10:13:56 <rwbarton> haha
10:14:06 <luite> but otherwise i can show something later this weekend
10:14:09 <rwbarton> Num (Control.Monad.Trans.State.Lazy.State (m [(s, String)]) [(s, String)])
10:14:16 <rwbarton> ^ this means you did something wrong
10:14:28 <tehgeekmeister> oh, yeah, i didn't notice that.
10:14:29 <tehgeekmeister> it clearly does.
10:14:30 <nand`> tehgeekmeister: like I said, that includes MonadIO
10:14:32 <rwbarton> some very, very wrong :)
10:15:20 <shapr> luite: Sounds good
10:15:25 <edwardk> luke: not really
10:15:28 * shapr tries to fix webcam
10:15:57 <Luke> ?
10:16:00 <nand`> tehgeekmeister: judging by the huge Num constraint on that State stuff I'm judging the ‘s’ in your signature actually hides the IO
10:16:04 <tehgeekmeister> the Num s bit is right.  The other Num instance is totally wrong.
10:16:08 <nand`> or something similar to it
10:16:54 <rwbarton> maybe you mixed up the arguments to a replicate
10:17:01 <rwbarton> or something of that nature
10:17:04 <shirt> is there something like "cabal build" that won't do a full compile+link, but will only typecheck?
10:17:04 <tehgeekmeister> no, no use of replicate
10:17:06 <tehgeekmeister> about to paste the code
10:17:13 <nand`> step one: give it the proper type signature
10:18:01 <hpaste> tehgeekmeister pasted “crazy num instance” at http://hpaste.org/69022
10:19:32 <rwbarton> note also that the type signature for filterColumn does not mention m except in the context
10:19:43 <rwbarton> @type evalState
10:19:44 <lambdabot> forall s a. State s a -> s -> a
10:19:54 <nand`> “return $ reverse $ snd =<< get” <- that can't be right; are you sure you don't mean (return . reverse . snd) =<< get
10:20:17 <nand`> or are you processing that in the list monad?
10:21:03 <rwbarton> oh you got evalState backwards
10:21:12 <rwbarton> nice
10:21:26 <rwbarton> (also there are other problems of course)
10:21:50 <rwbarton> yeah I find myself wanting flip evalState a lot for situations like this
10:22:35 * nand` wonders if tehgeekmeister is using the Num instance for tuples or why he's somehow combining ‘1’ with ‘snd’
10:23:03 <tehgeekmeister> back
10:24:35 * nand` wonders how exactly HLint differentiates between a warning and an error
10:24:39 <rwbarton> nand`, the 'get' on line 20 is in the [] monad of course :D
10:24:39 <burbul> I got to the bottom of my Leksah problem... even if you don't have 'to candy' switched on, it converts your unicode characters to ascii equivalents when saving. So e.g. α is saved as alpha.
10:24:46 <burbul> Anyone have any idea how I could stop this happening?
10:24:50 <rwbarton> hence Control.Monad.State.Class.MonadState (a, [(s, String)]) []
10:25:09 <tehgeekmeister> nand`: that's exactly what i meant.  changing it now.
10:25:28 <rwbarton> tehgeekmeister, did you see what i wrote about evalState
10:26:00 <rwbarton> you should probably fix that first, otherwise you will be working in a strange fantasy land where 1 is the action and that do block is the initial state
10:26:03 <tehgeekmeister> rwbarton: just now
10:26:23 <mm_freak_> absence: sharingWire . (ev1 <|> ev2)
10:26:29 <tehgeekmeister> oh, wow, how did that ever compile?
10:26:34 <mm_freak_> if either event occurs, sharingWire receives their input
10:26:37 <rwbarton> a number of minor miracles
10:26:40 <nand`> rwbarton: shh, don't give Cale any ideas
10:26:46 <mm_freak_> (assuming that ev1 and ev2 are inhibiting identity wires)
10:27:23 <ninegrid> rwbarton: thanks, but seems what i'm reading is a bit outdated because IO.openFile returns IO Handle and IO.hGetContents wants just Handle, so it complains
10:27:35 <rwbarton> ninegrid, you should read a tutorial on IO then
10:27:46 <rwbarton> or if you are reading a tutorial on IO, find a better one to read instead :)
10:27:47 <ninegrid> indeed
10:28:40 <nand`> tehgeekmeister: what exactly is the “filterColumn” function supposed to do by the way?
10:28:48 <fmap> nand`: errors are simple things like "concat . map", warnings are somewhat more disputable
10:28:48 <rwbarton> openFile is supposed to return IO Handle and hGetContents takes a Handle, that is how IO has worked since Haskell 98
10:28:56 <nand`> is the intermingling of IO and processing really necessary or can you lazily read into some structure and process that instead?
10:29:10 <nand`> fmap: oh, okay
10:29:16 <tehgeekmeister> oh, i mixed two different algorithms inside of filterColumn, too.  eep.  fixing that.
10:29:19 <mietek> jfischoff: bah, I have no idea how we're supposed to use sync-all
10:29:44 <mietek> jfischoff: it seems to me that doing an initial sync-all from mainline, then manually updating each git repo to point to my fork on github should work.
10:30:13 <jfischoff> mietek: yeah that's seems reasonable, I'll give that a shot
10:30:23 <tehgeekmeister> nand`: i'm building a really simple column oriented store.  this function is to filter entries in a column, and return a list of them and their indices.
10:30:53 <nand`> “list of them and their indices” <- sounds like some form of zip; “filter entries” <- sounds like some form of “filter” primitive
10:31:47 <tehgeekmeister> yes, it is like both of those.  but without using lazy IO (which might actually be a good fit here, for once), i can't use either of those.
10:31:50 <tehgeekmeister> not directly.
10:32:12 <nand`> I don't know what a “column oriented store” is to offer advice, unfortunately
10:32:27 <rwbarton> it looks like it means "a text file"
10:32:43 <nand`> https://en.wikipedia.org/wiki/Column-oriented_DBMS <- this?
10:32:50 <tehgeekmeister> yep
10:32:52 <nand`> looks like a [Row]
10:33:00 <tehgeekmeister> no
10:33:05 <c_wraith> no, that's exactly what it isn't
10:33:20 <nand`> oh
10:33:26 <tehgeekmeister> ([a], [b], ...)
10:33:27 <nand`> I see now, that's for a row-oriented database
10:33:35 <rwbarton> i guess it means each column is in its own text file
10:33:36 <tehgeekmeister> where the lists are the same length
10:33:47 <nand`> @hoogle [[a]] -> [[a]]
10:33:47 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
10:33:47 <lambdabot> Prelude concat :: [[a]] -> [a]
10:33:47 <lambdabot> Data.List concat :: [[a]] -> [a]
10:33:47 <tehgeekmeister> rwbarton: could be binary, but that's an implementation detail.
10:34:31 <nand`> only problem with “transpose” is typing unfortunately :(
10:34:50 <otters> @src transponse
10:34:51 <lambdabot> Source not found. My mind is going. I can feel it.
10:34:51 <tehgeekmeister> nand`: none of those do what i want at all.
10:34:53 <otters> @src transpose
10:34:53 <lambdabot> transpose []             = []
10:34:53 <lambdabot> transpose ([]   : xss)   = transpose xss
10:34:54 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
10:35:21 <absence> mm_freak_: did you have a particular wire in mind for the sharing? i've also figured out how to get rid of the explicit loop, annotation coming soon :) meanwhile, is there a better way to define idleEvent, renderEvent, etc (the inhibiting identity wires)? it feels a bit clumsy
10:37:06 <absence> is there a tool that will convert arrow syntax into "arrow primitives" or what they're called?
10:37:48 <mm_freak_> absence: no, just a generic wire
10:37:59 <mm_freak_> it gets input, if either event occurs
10:38:13 <mm_freak_> and yes, there is such a tool, a preprocessor, because arrow syntax is only supported by GHC
10:38:22 <sclv> absence: http://hackage.haskell.org/package/arrowp
10:38:25 <mm_freak_> btw, there is 'do rec' for arrows as well
10:38:29 <mm_freak_> it uses ArrowLoop in that case
10:38:47 <donri> anyone got an example use of quotePat or quoteType of QuasiQuoter? never seen those used
10:39:15 <absence> sclv: thanks
10:39:34 <sclv> donri: the original paper had some
10:39:36 <donri> actually not sure i've seen quoteDec used either...
10:39:56 <donri> sclv: aha, thanks
10:40:16 <sclv> also colah's been doing lots of cool stuff with quoteType: https://github.com/colah/pattern-power
10:40:21 <sclv> https://github.com/colah/HaskSymb
10:40:33 <absence> mm_freak_: do rec makes my head spin, i haven't gotten around to reading arrow tutorials thoroughly :) but i'll manage without ArrowLoop for now, mkPure takes care of it
10:40:47 <MagneticDuck> hey there
10:41:00 <MagneticDuck> took a little break but now I'm back into learning haskell... a bit rusty
10:41:13 <MagneticDuck> question: is there any fast way to write this:
10:41:28 <MagneticDuck> (\(_, x) (_, y) -> compare x y)
10:41:28 <MagneticDuck> ?
10:41:31 <sclv> padshaskell uses decls as well i think
10:41:40 <sclv> but i don't want to dl the source code to check.
10:41:49 <rwbarton> comparing snd
10:41:53 <edsko> MagneticDuck: compare `on` snd?
10:41:56 <MagneticDuck> aah
10:41:57 <MagneticDuck> ty
10:41:59 <rwbarton> or that
10:42:02 <thoughtpolice> MagneticDuck: compare `on` snd
10:42:18 <MagneticDuck> people like an easy question every now and then eh?
10:42:19 <MagneticDuck> ^^
10:42:38 <edsko> it's a relief after tracking down a concurrency problem all day! :-)
10:42:44 <MagneticDuck> heh
10:43:14 <MagneticDuck> I have to relearn everything. Tip to people learning haskell: don't take too many breaks. ._.
10:43:27 <MagneticDuck> or maybe you learn it better...
10:44:55 <otters> @pl \((_,x) (_,y) -> compare x y)
10:44:56 <lambdabot> (line 1, column 9):
10:44:56 <lambdabot> unexpected "("
10:44:56 <lambdabot> expecting operator or ")"
10:45:03 <otters> @pl \(_,x) (_,y) -> compare x y
10:45:03 <lambdabot> (. snd) . compare . snd
10:45:08 <otters> aw man
10:47:29 <Kaide> @ty compareBy
10:47:30 <lambdabot> Not in scope: `compareBy'
10:47:30 <S11001001> f x `g` f y can't be "on"ed for polymorphic f
10:47:33 <Kaide> @ty comparing
10:47:34 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
10:47:44 <Kaide> @ty comparing snd
10:47:45 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> Ordering
10:48:30 <Kaide> comparing snd is what you want
10:48:39 <S11001001> @ty snd x `compare` snd y
10:48:40 <lambdabot>     Couldn't match expected type `(a, b)' against inferred type `Expr'
10:48:40 <lambdabot>     In the first argument of `snd', namely `x'
10:48:40 <lambdabot>     In the first argument of `compare', namely `snd x'
10:48:41 <Kaide> the lambda expression is also quite readable as it
10:48:42 <nand`> note the monomorphism
10:48:53 <nand`> as S11001001 mentioned
10:48:53 <Gurragchaa> Are there any chess engines written in Haskell?
10:48:54 <jfischoff> mietek: I built and got an error "terminfo missing". I'm doing a clean build and crossing my fingers
10:48:57 <donri> :t on
10:48:58 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
10:49:33 <HugoDaniel> how can i generate the haddocks of the packages i install with cabal to read offline ?
10:49:41 <donri> HugoDaniel: --enable-documentation
10:49:56 <donri> or uncomment the relevant line in ~/.cabal/config
10:50:06 <HugoDaniel> ah cool
10:50:12 <S11001001> @ty \x y -> snd x `compare` snd y
10:50:12 <lambdabot> forall a a1 b. (Ord b) => (a, b) -> (a1, b) -> Ordering
10:50:18 <HugoDaniel> then they should go somewhere like ~/.cabal/doc right ?
10:50:25 <donri> ~/.cabal/share/doc i think
10:50:27 <S11001001> like so :)
10:50:56 <donri> haddock will tell you where it put it at install-time
10:51:28 <everythingWorks> [leksah] can i somehow clear all preferences so i will see the "welcome/hello world" haskell script which is normally just shown at the first start?
10:52:21 <donri> everythingWorks: maybe there's a ~/.leksah directory or similar?
10:52:59 <donri> try: find ~ -type d -iname '*leksah*'
10:53:07 <everythingWorks> donri: yep, i just foound it in this very moment
10:53:26 <everythingWorks> but very good guess! :)
10:53:56 <everythingWorks> namely, it was /user/michael/.leksah-0.12/leksah-welcome/src/Main.hs
10:56:43 <everythingWorks> found a mistype (if any leksah guy is here) in the "first start script": Line 27, "addd" should be "add"
10:56:49 <everythingWorks> mistyping*
11:00:23 * hackagebot GTALib 0.0.1 - A library for GTA programming  http://hackage.haskell.org/package/GTALib-0.0.1 (KentoEmoto)
11:01:53 <everythingWorks>  (and one in line 50, "leksah-wellcome" should be "leksah-welcome" [sigh, i think no one minds :( ] )
11:05:24 * hackagebot XmlHtmlWriter 0.0.0.0 - A library for writing XML and HTML  http://hackage.haskell.org/package/XmlHtmlWriter-0.0.0.0 (MatthewMirman)
11:07:11 <hpaste> tehgeekmeister pasted “time to use enumerator?” at http://hpaste.org/69024
11:08:05 <tehgeekmeister> okay, i have a test version of filterColumn working, but it's way too strict.  I think the most elegant way to fix this is enumerator, but that probably won't be the fastest way.
11:08:25 <tehgeekmeister> (as in performant, not quick to write.)
11:11:54 <eacameron> I forked a Bayesian classification algorithm and made a Haskell version, but I'm fairly new to haskell and I'm highly unsatisfied with some of my code (though it works). Would anyone like to take a stab at seeing how it could be improved. It's a pretty small file: https://github.com/CovenantEyes/bayes_on_redis/blob/master/haskell/lib/BayesOnRedis.hs#L52
11:12:44 <andares> hey, when should unsafePerformIO be used?
11:13:02 <tgeeky> if you have to ask, never
11:13:02 <lambdabot> tgeeky: You have 1 new message. '/msg lambdabot @messages' to read it.
11:13:48 <c_wraith> basically, unsafePerformIO should be used when it results in something correct. It's up to you (the programmer) to prove the result has the semantics you intend.
11:14:07 <c_wraith> (and that those semantics are compatible with the type signature)
11:15:34 <c_wraith> an example of an easy case is when binding to a native call that's referentially transparent. unsafePerformIO is fine there (and even inserted implicitly by the compiler), because it can't have side effects.
11:16:06 <c_wraith> an example of a really complicated case is conal's unamb function.
11:16:40 <c_wraith> Which, well - his series of blog posts on it are the only place to go for good information on it.
11:16:56 <tgeeky> andares: dud that help?
11:16:59 <tgeeky> s/dud/did/
11:17:09 <c_wraith> http://conal.net/blog/posts/functional-concurrency-with-unambiguous-choice  this explains unamb
11:18:05 <andares> referentially transparent?
11:18:14 <tgeeky> "pure"
11:18:15 <andares> I don't ask for myself; I'm reading the source code of mp3decoder
11:18:25 <andares> ah, so a stateless function written in C for example.
11:19:44 <tommd> Yes, though one must be aware of C functions that aren't truely stateless.  A common issue is when the C function returns a pointer that is actually statically allocated and not fresh off the heap.
11:21:49 <c_wraith> Or, like crypt, is pure in terms of input and output, but uses a mutable scratch buffer
11:22:01 <c_wraith> and concurrent use results in corrupting it
11:22:10 <c_wraith> since it's a static buffer
11:23:04 <tommd> Yep.  There were at least a couple bugs due to such C code.
11:24:08 <c_wraith> Of course, using unsafePerformIO doesn't cause that bug - it's a different class of problems.
11:24:35 <tehgeekmeister> hmmm.
11:24:41 <newsham> p = getpwnam("anonymous);   (meanwhile in another part of town.... x = getpwnam("root"); ....)     printf("%s\n", p->pw_name);
11:25:31 <tehgeekmeister> i'm always befuddled by how to do IO driven programming efficiently in haskell.  i want to get beyond this phase.
11:25:45 <newsham> practice makes perfect
11:26:01 <c_wraith> how to write efficient code, or how to efficiently write code?
11:26:16 <tehgeekmeister> more the former, but a bit of the latter
11:26:34 <tehgeekmeister> newsham: i'm missing some bit of understanding.  practice isn't the key for right now.
11:26:59 <newsham> writeFile "out" =<< map toUpper <$> readFile "in"      -- applicative style is awesome
11:27:57 <tehgeekmeister> anybody can do cool toy stuff using lazy io.
11:28:22 <tehgeekmeister> maybe i should just use lazy io.  hmm.
11:29:06 <zezikaro> Hi, i just bought the 'learn you a haskell' book. And i'm seeing lots of individual examples... But I wonder what sort of projects can be done?
11:29:45 <newsham> zezikaro: window manager, revision control, web app, etc..
11:30:01 <tehgeekmeister> i think i have to use lazy io or enumerators, if i want to process input from a file as a stream and feed the results to another arbitrary computation
11:30:03 <newsham> pretty much anything you can do in other languages
11:30:21 <zezikaro> What would be the preferred starting program?
11:30:29 <zezikaro> they seem pretty complex examples
11:31:32 <absence> mm_freak_: http://hpaste.org/69020 <- does the annotation look better? it's not a problem to use the same inhibiting identity wire multiple times right?
11:31:33 <newsham> maybe some turtle-art, or a program that asks you questions to try to guess what you're thinking, or a memory game...
11:31:44 <newsham> what kinda programs do you normally like to write in other languages?
11:34:29 <newsham> a small network chat client and server would be fun if you're more into net protocol type work
11:40:26 <zezikaro> newsham I've written a java game engine, and a game in C#/XNA, and a bunch of PHP websites
11:40:36 <zezikaro> like a music site for users to upload songs/comment etc
11:40:44 <newsham> so prob starting with some small games would be fun
11:40:57 <zezikaro> games in haskell must be crazy D:
11:41:18 <newsham> http://www.haskell.org/haskellwiki/Game_Development might be helpful
11:43:06 <zezikaro> thanks
11:44:12 <nand`> the preferred starting program would be the identity
11:44:21 <zezikaro> what's that?
11:44:26 <nand`> main = return ()
11:44:31 <nand`> actually, don't do that
11:44:34 <newsham> not a very fun game :(
11:44:53 <nand`> because “main = return ()” is a horrible way to start learning Haskell :P
11:45:10 <monochrom> try to do a website with haskell. randomly pick one of these webapp libraries: happstack, snap, yesod
11:45:20 <fmap> @hoogle String -> TypeQ
11:45:20 <lambdabot> Language.Haskell.TH.Quote quoteType :: QuasiQuoter -> String -> Q Type
11:45:21 <lambdabot> Prelude fail :: Monad m => String -> m a
11:45:21 <lambdabot> Control.Monad fail :: Monad m => String -> m a
11:45:21 <newsham> i'd recommend using snap
11:45:22 <kallisti_> @hoogle (//)
11:45:22 <lambdabot> Data.Array.IArray (//) :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e
11:45:23 <lambdabot> Data.Array (//) :: Ix i => Array i e -> [(i, e)] -> Array i e
11:45:25 <nand`> “a = a” <- brilliant starter program that showcases quite a few of Haskell's features
11:46:22 <stepcut> I'd recommend happstack, great documentation, and happstack-lite is super easy to get started with.
11:46:23 <kallisti_> I've heard good things about main = putStrLn "Hello, World!"
11:46:27 <nand`> then again, it's arguable whether that actually showcases laziness and tail call recursion or not
11:46:50 <kallisti_> it showcases newbie confusion at why you would use such an example.
11:46:56 <nand`> but it definitely showcases recursion and polymorphy
11:47:21 <kallisti_> for some value of "showcases"
11:47:24 <kallisti_> a :: a
11:47:25 <kallisti_> a = a
11:47:29 <kallisti_> might be more clear
11:47:31 <nand`> yeah
11:47:37 <kallisti_> or. even more confusing.
11:47:42 <nand`> a = a :: a
11:47:45 <kallisti_> looks pretty esoteric
11:47:57 <newsham> here's a simple game http://www.gamedev.net/topic/501730-haskell-pong/
11:48:53 <zezikaro> it's funny that the "hello world" example is in like chapter 8 of learn you a haskell for great good
11:49:07 <zezikaro> after talking about the craziest stuff ever for the past 7
11:49:22 <absence> mm_freak_: also, why do prefab wires that inhibit use Left mempty instead of Left ()?
11:49:34 <nand`> who needs a hello world, all it does is showcases I/O capability which hardly any abstract calculus implements :P
11:49:55 <newsham> nand: are you trolling?
11:50:11 <newsham> try #haskell-blah
11:50:13 <nand`> newsham: not deliberately trying to, no
11:51:42 <zezikaro> will haskell be learnable if you don't know much math concepts
11:51:50 <mauke> zezikaro: I think so
11:51:54 <nand`> zezikaro: yes, though you may not appreciate it as much
11:52:05 <nand`> zezikaro: it's certainly possible to learn Haskell first and learn the math concepts later if they interest you
11:52:25 <mauke> I mean, I still don't know any category theory
11:52:25 <nand`> as long as you develop an understanding of how things work it essentially boils down to the same
11:53:25 <nand`> though I'd say a mathematical background will certainly help if you try to, say, construct a rigorous proof about certain Haskell functions
11:53:36 <nand`> (and by that I mean a background in Haskell's underlying theory)
11:53:42 <absence> http://hpaste.org/69026 <- can this be done in a less clumsy way?
11:53:55 <tehgeekmeister> so, when is it sane to use lazy io?
11:54:19 <c_wraith> tehgeekmeister: in scripts that have hard upper bounds on the amount of things they open
11:54:34 <c_wraith> tehgeekmeister: and don't have unbounded runtimes
11:54:36 <mauke> absence: all of your 'otherwise' are wrong
11:54:49 <zezikaro> if 'fst' is first
11:54:52 <zezikaro> why isn't it 'lst'
11:54:57 <tehgeekmeister> c_wraith: what about long running programs that always fully consume each handle they have open, and then seek it back to 0?
11:55:08 <tgeeky__> zezikaro: you mean last?
11:55:16 <`Jake`> snd is second
11:55:23 <zezikaro> fst (1, 2) => 1
11:55:23 <tgeeky__> zezikaro: (fst,snd) go together
11:55:27 <nand`> absence: “otherwise” simply means “True”
11:55:29 <c_wraith> tehgeekmeister: if you can assure yourself that you are always doing that, and will continue to always do that through any modifications to the code in the future...
11:55:34 <nand`> absence: you probably want _ in place of otherwise
11:55:38 <tgeeky__> zezikaro: they are specific to 2-tuples.
11:55:42 <`Jake`> @src otherwise
11:55:43 <lambdabot> otherwise = True
11:55:47 <tgeeky__> > fst (1,2,3)
11:55:48 <lambdabot>   Couldn't match expected type `(a, b)'
11:55:49 <lambdabot>         against inferred type `(t, t1...
11:55:53 <zezikaro> oh
11:55:55 <tgeeky__> zezikaro: see?
11:55:57 <nand`> that reminds me
11:55:57 <zezikaro> what does snd stand for?
11:55:59 <zezikaro> thanks
11:56:01 <tgeeky__> zezikaro: second
11:56:10 <zezikaro> heh
11:56:11 <absence> nand`: why does it even compile then?
11:56:13 <zezikaro> thanks
11:56:15 <tgeeky__> zezikaro: yep
11:56:16 <nand`> besides the strictness, what kinds of problems arise when making (1,2,3) syntactic sugar for (1,(2,(3,())))?
11:56:34 <mauke> absence: because you're simply creating another name for 'event'
11:56:46 <hpaste> ClaudiusMaximus annotated “asdf” with “asdf (annotation)” at http://hpaste.org/69026#a69027
11:56:46 <mauke> absence: that is, you're binding the value to a fresh variable called 'otherwise'
11:56:58 <tehgeekmeister> c_wraith: pretty sure by design, though if it changed, it'd likely enough mean the program was being replaced with something else anyway, so i think it's probably okay.
11:57:39 <nand`> mauke: come to think of it, that's no different from using _
11:57:49 <nand`> (other than the name being shadowed, obvious)
11:57:54 <mauke> right
11:58:15 <S11001001> nand`: the types (,) x and (,,) x y would overlap
11:58:19 <ClaudiusMaximus> absence: i annotated with how i'd do it
11:58:41 <mauke> S11001001: is that a bad thing?
11:58:43 <tehgeekmeister> c_wraith: i'm implementing a column oriented store, which will always be used for aggregate analysis, so, by design, i basically always have to consume a whole file.  i imagine i could do some range-based queries in the future, but it'd probably be efficient enough at that point to just read the whole file in again.
11:59:36 <c_wraith> tehgeekmeister: the other thing you need to be aware of, then, is if your aggregates hold on to memory and the input is big enough to cause issues
11:59:39 <absence> ClaudiusMaximus: thanks, that's a bit better
11:59:57 <nand`> mauke: I figure it'd break stuff like case ... of (x,y) ->   (is this actually (x,(y,())) or (x,y) ?)
12:00:10 <nand`> at least as far as the sugar is concerned
12:00:34 <mauke> ok, so we need better sugar
12:00:37 <tehgeekmeister> c_wraith: i'm leaving that dangerous by design, to make it simple.  aggregates that could be big will be streamed back to disk, rather than held in memory.
12:00:44 <nand`> it's just a shame, since “fst”, “snd” and so should really work on all n-tuples
12:00:49 <nand`> imo
12:01:02 <c_wraith> tehgeekmeister: you're taking quite a big chance on being bit, then
12:01:04 <nand`> (where n >= the number in question, obviously)
12:01:21 <tehgeekmeister> c_wraith: how so?  if it's too big a chance, then i'll reconsider.
12:01:28 <tehgeekmeister> also, lazy IO seems to be too slow.
12:01:39 <tehgeekmeister> still waiting for my benchmark to complete, but we'll see.
12:01:42 <c_wraith> *String* IO is slow.
12:01:50 <tehgeekmeister> right, i forgot to switch it over to text
12:01:51 <c_wraith> lazy bytestring IO is pretty fast
12:01:56 <mauke> class Fst b a | a -> b where fst :: a -> b
12:02:03 <nand`> c_wraith: what about lazy Text IO?
12:02:11 <mauke> instance Fst a (a, b) where fst (a, _) = a
12:02:35 <c_wraith> should be similar to lazy bytestring, in that it uses big contiguous chunks of memory with one allocation, instead of many small allocations and pointer-chasing
12:02:45 <c_wraith> Text does more work, though, so will always be slower.
12:02:47 <nand`> mauke: then you need to implement infinite instances for all tuple types though; unless there's something I'm missing
12:03:05 <untitled> what do I do when I need things like structs in C and a global list of them?
12:03:07 <c_wraith> Text is also much more correct, when you're dealing with arbitrary textual data
12:03:10 <mauke> nand`: well, s/infinite/6 or so/
12:03:22 <tehgeekmeister> bytestring should work for me.
12:03:33 <mauke> nand`: anyone who uses bigger tuples has bigger problems anyway
12:03:38 <tehgeekmeister> c_wraith: still, what are the concerns?  do you think it's worth the cost of enumerators?
12:03:40 <nand`> http://hackage.haskell.org/packages/archive/tuple/0.2.0.1/doc/html/Data-Tuple-Select.html <- makes me cringe
12:03:48 <nand`> mauke: true, beyond 3 I reconsider
12:04:04 <c_wraith> tehgeekmeister: it's just really easy to end up not consuming resources you thought you had, if your grasp of laziness/strictness is off at all.
12:04:13 <mauke> nand`: the instances of Eq/Ord/Read/Show are similarly limited :-)
12:04:22 <nand`> generalized “fst”, “snd” and “thd” (or whatever) would be nice in Prelude, after that I'm happy :)
12:04:40 <newsham> easy enough to make your own outside of prelude
12:04:48 <c_wraith> thud
12:05:09 <mauke> sevenOfNine :: (a, b, c, d, e, f, g, i, j) -> g
12:05:12 <nand`> I suppose I'll make my own Prelude one of these days and load it in GHCi as default
12:05:14 <`Jake`> > fromInteger (5 :: Int)
12:05:15 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
12:05:15 <lambdabot>         against inf...
12:05:23 <nand`> seems like it's what all of the cool kids are doing
12:05:25 <tehgeekmeister> c_wraith: yeah, my grasp on that isn't great, but at the same time i do plan on explicitly evaluating every byte of the files used, or, in the cases where i know i won't, seeking back to 0 anyway.
12:05:26 <`Jake`> weird, that doeswork in ghci
12:05:46 <`Jake`> oh no, it doesn't
12:05:46 <nand`> `Jake`: why wouldn't it?
12:05:57 <mauke> nand`: because Int /= Integer
12:05:59 <`Jake`> nand`: because of integer and int
12:06:04 <nand`> oh
12:06:07 <nand`> misread as fromIntegral
12:06:34 <`Jake`> ok, got my mistake, too
12:14:46 <tehgeekmeister> guh.  doing it with bytestrings is much more painful.  no convenient way to split on lines, so far as i can tell.
12:16:51 <Saizan> tehgeekmeister: there's .Char8.lines if you are ok with the encoding
12:17:07 <tehgeekmeister> ah, that'll help.  thanks.
12:17:18 <nand`> there's LBS.split but you'll have problems with the Word8
12:17:18 <tehgeekmeister> (i can control encoding, so it will.)
12:17:28 <tehgeekmeister> nand`: yeah, that's what i found.
12:18:00 <nand`> LBS.split 10  -- more evil than (fromIntegral $ ord '\n') though
12:19:23 <nand`> but may actually make more sense if you're dealing with a strictly binary format where the usage of an actual 10 literal is implied, eg. by its specified encoding
12:20:43 <EEVIAC> anyone have any idea why running this code in parallel actually results in a slowdown of 10% http://hpaste.org/69028
12:20:47 <EEVIAC> instead of a speedup
12:21:34 <EEVIAC> if i call pmultprimes instead of multprimes (and compile with -threaded and pass +RTS -N when running the program)
12:29:09 <untitled> hi, I'm new to haskell, got a problem: what do I do when I need things like structs in C and global mutalbe lists of them?
12:29:41 <ClaudiusMaximus> EEVIAC: try +RTS -N -s   to see what the threads are doing, paste the output as an annotation
12:30:30 <untitled> and how do I even "keep" a list somewhere?
12:31:30 <ClaudiusMaximus> untitled: do you need to interact with C?  or trying to translate some C-like concepts?
12:32:25 <untitled> translate
12:32:25 <nooodl> "global mutable lists" sounds not very haskell-y :)
12:32:42 <nooodl> structs are easy, though
12:33:04 <nooodl> take a look at this http://learnyouahaskell.com/making-our-own-types-and-typeclasses
12:33:06 * nand` does his best to refrain from mentioning IORef, Typeable and ImperativeHaskell
12:33:21 <ClaudiusMaximus> mutable lists are probably only used in C because it's too hard to write/use a better data structure
12:33:24 <barrucadu> nand`: That's some good not-mentioning there :P
12:33:59 <ClaudiusMaximus> (or maybe that's just me being rubbish at C)
12:34:03 <untitled> I know about types and typeclasses, just stuck with the idea, that I can't keep this list somewhere to add to it later
12:34:24 <ClaudiusMaximus> why do you want to add to it later?
12:34:32 <untitled> can't even figure out how to create such a thing
12:34:55 <untitled> well, picture yourself a telephone book, I kinda wan't to implement it
12:35:04 <untitled> adding names and addresses myself
12:35:15 <nand`> untitled: what you should be doing is focusing less on “how can I emulate feature X used to solve problem Y methodically” and rather focus on “how do I solve problem Y by breaking it down into pure sub-problems Z”?
12:36:06 <untitled> nand`: sure, that's what I'm trying to do, I only need some data to use and to store
12:36:13 <tehgeekmeister> nand`: it'll probably be a binary format in the future, so that's good to consider.  thanks for your help.
12:36:15 <nand`> what you'd be doing is something like “addToBook :: Name -> TelephoneBook -> TelephoneBook” that takes an existing telephone book and adds a new one
12:36:35 <nand`> a new name*
12:36:48 <nand`> so, instead of “storing” the book somewhere; you “pass it around” in function calls
12:36:54 <untitled> right
12:37:07 <tehgeekmeister> nand`: i've got it working efficiently enough now, even if it's not as beautiful as could be.  next comes making it useful, and then, maybe beautiful.
12:37:15 <nand`> (of course, this “passing around” can be abstracted away by stuff like State but if you're a beginner that might be getting too far ahead)
12:37:27 <tehgeekmeister> (unfortunately, i ended up using lazy io.  D= )
12:37:38 <nand`> hey, I use lazy IO all the time
12:37:48 <untitled> ok, thanks
12:38:04 <nand`> hmm
12:38:33 <nand`> is there an efficient isomorphism between char8 ByteStrings and word8 ByteStrings?
12:38:58 <luite> yes they're the same type
12:38:58 <ion> Hmm. Aren’t they the same thing inside?
12:39:01 <nand`> untitled: if you want to learn more about the “Haskell way” of solving problems, I recommend going through LYAH if you aren't/haven't already
12:39:11 <ion> So… unsafeCoerce? ;-)
12:39:15 <luite> no not necessary
12:39:19 <luite> they're really the same
12:39:23 <ion> ah
12:39:26 <nand`> okay
12:39:31 <luite> exported from different modules, but defined in the same Internal module
12:40:02 <untitled> nand`: well, I've read two books already, can do small things, like 1 problem at a time, now trying to develop a more complicated system
12:41:14 <nand`> so Data.ByteString.Lazy.Char8 is just an alternate interface with differently typed functions?
12:41:59 <nand`> (I'm considering using Data.ByteString.Lazy.Char8.lines to split up my packets)
12:42:15 <geekosaur> yes, and a bit more danger (because it will silently drop the upper bits of Char-s given to it)
12:42:45 <nand`> yeah; I'm re-processing them as Text where appropriate either way
12:42:50 <nand`> (using UTF-8)
12:43:11 <nand`> the ByteString is just for interaction with Network handles
12:43:52 <Tarty> Hi.
12:44:01 <shachaf> hi Tarty
12:44:17 <Tarty> I'm trying to learn the ST Monad from this wiki page: http://www.haskell.org/haskellwiki/Monad/ST
12:44:44 <Tarty> They have an example at the end of computing Fibonacci numbers in constant space
12:45:13 <Tarty> I ran the code with large values on n and I get a stack overflow, so clearly it's not really 'constant space'
12:45:32 * hackagebot XmlHtmlWriter 0.0.0.1 - A library for writing XML and HTML  http://hackage.haskell.org/package/XmlHtmlWriter-0.0.0.1 (MatthewMirman)
12:45:54 <ClaudiusMaximus> Tarty: writeSTRef y (x'+y')   should probably be   writeSTRef y $! (x'+y')
12:46:07 <Tarty> What would that do?
12:46:32 <Tarty> But yeah, my question is, how can you make that evaluation strict.
12:46:42 <Tarty> so it actually takes constant space.
12:46:45 <nand`> @src ($!)
12:46:45 <lambdabot> f $! x = x `seq` f x
12:46:56 <Tarty> @src ($!)
12:46:56 <lambdabot> f $! x = x `seq` f x
12:47:05 <DMcGill> so $! makes it strict
12:47:11 <Tarty> oh, that's how that works :P sorry.
12:47:19 <nand`> lambdabot is pure, it seems
12:47:30 <nand`> (actually, it isn't. @quote)
12:49:25 <DMcGill> Tarty: does it work now?
12:49:45 <Tarty> Yep, works perfectly!
12:50:23 <DMcGill> anybody with an account want to edit the wiki?
12:50:32 <nand`> hmm; given a data “Foo = Foo Bar Bat” is there any difference between a strict State Foo and a non-strict State Foo?
12:50:46 <ClaudiusMaximus> Tarty: how large was large?  the original doesn't stack overflow for me in ghci with  fibST 100000
12:50:52 <arcatan> DMcGill: I'll fix it
12:51:08 <Tarty> Claudius > 1000000
12:51:24 <Tarty> oh, I added a mod 1000000 after the addition ;)
12:52:03 <Tarty> Otherwise I think printing the Integer will take way too long
12:54:26 <ClaudiusMaximus> Tarty: hehe.  when compiled, i get the stack overflow; adding $! makes it take a long time but it does complete (and floods my term with digits)   maybe ghci just has a larger stack by default
12:54:31 <DMcGill> couldn't you compute fibb in constant space purely if we were careful about garbage collection?
12:55:05 <ClaudiusMaximus> DMcGill: it's a page giving a simple example for Control.Monad.ST
12:55:46 <Tarty> Hm
12:55:59 <jpf_> can someone explain what the second line of this means?:
12:56:02 <jpf_> data Ref m a where
12:56:02 <jpf_>     Ref :: ModifyRef sr m a => !sr -> Ref m a
12:56:04 <Tarty> So the reason for the stack overflow was the buildup of a huge addition thunk?
12:56:18 <ClaudiusMaximus> Tarty: yep
12:56:22 <DMcGill> fair enough, but it was a genuine question of mine rather than a 'why don't you do it this way'
12:56:26 <Tarty> I thought it was the recursive call in fibST'
12:56:48 <nand`> Tarty: nope, that's tail recursive
12:57:00 <Tarty> ah. Good to know!
12:57:10 <nooodl> !wtf Wr
12:57:20 <nooodl> whoops, wrong channel :O
12:57:35 <eacameron> Should this search work? http://www.haskell.org/hoogle/?hoogle=runRedis   (this function exists in Database.Redis [hedis package])
12:57:42 <shapr> hoi nooodl, are you learning Haskell?
12:58:07 <DMcGill> jpf_: looks like a GADT to me, see http://www.haskell.org/haskellwiki/GADT
12:58:07 <jpf_> "ModifyRef sr m a" doesn't look like any type constraint that I've ever seen
12:58:12 <ClaudiusMaximus> DMcGill: i'd probably do it by defining a strict 2x2 matrix type and using (^) internally
12:58:16 <arcatan> eacameron: http://www.haskell.org/hoogle/?hoogle=runRedis+%2Bhedis
12:58:29 <nooodl> not very actively; i lurk here sometimes
12:58:31 <jpf_> but this is my second third day with the language :/
12:58:37 <eacameron> arcatan: is that by design?
12:58:42 <jpf_> third*
12:58:43 <arcatan> eacameron: Hoogle doesn't search all the Hackage by default, but you can tell it to search specific packages with +package syntax
12:58:59 <eacameron> arcatan: understood! thanks!
12:59:13 <arcatan> eacameron: if you need to search the whole Hackage, you can use Hayoo http://holumbus.fh-wedel.de/hayoo/hayoo.html
12:59:19 <Tarty> Well, thanks a lot #haskell. See you all later.
13:02:15 <untitled> nand`: can you write a fast'n'dirty example for me, my brain just won't get it.. like: get user input "add contact"/"print contact" and how to maintain the book inside the program?
13:03:26 <armlesshobo> untitled: what is it you're trying to do?
13:03:28 <nand`> “get user input” sounds conspicuously like IO
13:03:43 <armlesshobo> agreed
13:03:59 <untitled> didn't I mention IO?
13:04:05 <untitled> yes, it's there too
13:04:27 <nand`> if you know how to “add contact” and “print contact” purely, and you in addition know how to use the IO monad to process user input (with pure functions), then you can put the two together
13:04:37 <untitled> armlesshobo: a phonebook maintained by user
13:05:08 <armlesshobo> untitled: are you planning on storing it in a DB?
13:05:11 <hpaste> ClaudiusMaximus pasted “matrix ^ fib” at http://hpaste.org/69029
13:05:28 <DMcGill> so rather than have a mutable phonebook object, you instead pass it around each function like `add contact phonebook'
13:05:30 <nand`> untitled: for your phonebook you may be interested in http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Map.html#t:Map
13:05:34 <untitled> armlesshobo: no, want the program to "keep" the state of the book
13:05:48 <armlesshobo> oh
13:06:07 <untitled> nand`: what I don't understand is how do I keep the currect state of the book :)
13:06:14 <untitled> current*
13:06:29 <Taneb> Hello
13:06:29 <armlesshobo> untitled: you'd have to pass it around
13:07:20 <nand`> (contact, book') <- getContact name book  <- then use book' from then on; preferably to do something like tail recurse (with the phone book as one of the arguments)
13:07:44 <DMcGill> or if getContact was pure, you'd use `let' instead of `<-'
13:07:49 <nand`> (of course, this passing around of state can be abstracted away as has been mentioned before. If that's what you want to learn; and you know about monads, you can consider reading up on the State monad)
13:08:03 <nand`> DMcGill: totally my bad there
13:08:10 <nand`> of course it would be pure
13:08:25 <untitled> mmmok
13:09:02 <nand`> I should mention that the State monad is an immensely useful tool for this but also a very dangerous one if used where inappropriate
13:09:21 <barrucadu> If you're just starting out, learning how to do it without State is probably for the best
13:09:37 <nand`> agree
13:12:40 <nand`> :t join seq
13:12:41 <lambdabot> forall a. a -> a
13:15:16 <nand`> does pattern matching against a type with only one constructor (and ignoring the parameters with _) ever evaluate if the value you're matching against is _|_ ?
13:17:18 <c_wraith> yes
13:17:42 <DMcGill> I believe it doesn't for newtype though
13:17:47 <c_wraith> assuming the pattern matches are refutable, ie case expression or function arguments
13:18:22 <c_wraith> irrefutable pattern matches (including newtype constructors, yes) and pattern matches in a let binding, don't
13:19:39 <nand`> c_wraith: interesting
13:20:19 <nand`> especially the thing about newtypes; they're just type level differentiations with the exact same internal representation, right?
13:20:53 <c_wraith> yes..  Though it isn't necessarily obvious that means that pattern-matching on their constructors can have different semantics.
13:21:02 <c_wraith> (depending on how deeply you think it through)
13:27:21 <EEVIAC> ClaudiusMaximus: sorry, i was afk
13:27:24 <EEVIAC> http://hpaste.org/69028
13:28:10 <EEVIAC> (for those of you who didn't see the question: running this program in parallel results in a slowdown instead of a speedup, can't figure out why)
13:31:01 <ClaudiusMaximus> EEVIAC: so it's spending most time in GC - when that happens i generally throw a sledgehammer at it like  +RTS -A256M ...   maybe also worth compiling with -feager-blackholing ?
13:31:44 <greymalkin> I'm running through "Learn you a..." and I notice that almost every function in the early chapters is preceded by it's type definition... is this common practice, or mostly there for the exposition?
13:32:07 <S11001001> greymalkin: former
13:32:25 <EEVIAC> ClaudiusMaximus: thanks, i'll try that. what does -feager-blackholing do though?
13:32:46 <S11001001> greymalkin: browse any random source on hoogle for demonstration
13:33:11 <greymalkin> Huh. I would have expected more 'inference' from the type inferencing system to be in use.
13:33:56 <rwbarton>   GC    time    8.51s  (  0.60s elapsed)
13:34:02 <rwbarton> how many processors are you running this on exactly?
13:34:08 <EEVIAC> two
13:34:19 <rwbarton> does anyone understand the math here then
13:35:40 <S11001001> greymalkin: inference is about more than top-level definitions
13:36:07 <greymalkin> I have to say... I'm *really* liking haskell.  It seems like the perfect client-side counterpart to erlang (on the server).
13:36:31 <EEVIAC> yeah haskell is awesome for a million reasons
13:37:01 <nand`> can the funky bit/byte-wise sectioning Erlang has done with some form of haskell templates/QQ?
13:37:27 <nand`> (and sufficiently constructed pattern matches)
13:37:36 <greymalkin> Specifically, I had fallon in love with erlang's pattern-matching function definitions and really missed them on the client side.
13:37:42 <EEVIAC> i like that haskell is stealing ideas from erlang now (see cloud haskell)
13:38:33 <c_wraith> quasiquoting can generate patterns, so yes, you can do bit-pattern matching with it (and generating view patterns)
13:38:34 <ClaudiusMaximus> EEVIAC: i added an annotation showing some results here - +RTS -A256M really helps time (but uses much more ram...)
13:38:48 <c_wraith> ...  I hope you can generate view patterns
13:40:17 <rwbarton> EEVIAC: anyways this program has very little parallelism, it's not too surprising that the parallel version is a bit slower due to overhead of the threaded runtime (am I reading this right, it takes 11.17s on 2 processors and 10.57s on 1 processor?)
13:40:33 <EEVIAC> that's weird, adding -A256M actually slows it down for me (from 10 seconds to 13)
13:41:31 <nand`> greymalkin: although inference can be used it's considered good form to put top level type definitions in for a number of reasons: 1. error messages (if you screw up and the compiler infers some bogus type, you'll get errors later on and not in the function definition itself) 2. the programmer (makes it easier to remember what functions do) 3. better for prototyping (if you make it practice to write down the
13:41:33 <nand`> type of something you want to implement first, it tends to become much clearer how to actually do so or whether it's even possible)
13:41:43 <EEVIAC> rwbarton: how so? if i swap the nth prime function with a fibs function, it runs approx. two times faster with -threaded
13:42:01 <rwbarton> the computation of primes is shared anyways
13:42:05 <rwbarton> is your fib memoized?
13:42:11 <EEVIAC> no, just a dumb fib
13:42:18 <rwbarton> right
13:42:42 <EEVIAC> wait, these primes share?
13:42:46 <rwbarton> almost all the work goes into actually computing the first 300001 elements of primes
13:42:53 <rwbarton> yes, because primes is a top-level binding
13:43:07 <rwbarton> a CAF in the lingo
13:43:07 <EEVIAC> i thought i'd have to do manual memoization to get sharing between those
13:43:08 <ClaudiusMaximus> with a monomorphic type, and no arguments
13:43:11 <rwbarton> right
13:43:27 <rwbarton> well, unless you turn off the monomorphism restriction the first is automatic :)
13:43:53 <rwbarton> EEVIAC, you did manual memoization :)
13:44:01 <EEVIAC> haha, i see
13:44:51 <EEVIAC> thanks for the help
13:50:29 <shapr> luite: oh hai!
13:50:41 <luite> hi, long time no see
13:50:45 <luite> how are your kids doing?
13:50:45 <shapr> haha
13:50:50 <shapr> I don't have kids! yet...
13:50:58 <shapr> I'm not even married! That's later this month.
13:51:00 <luite> oh, not that long then, i guess
13:51:03 <shapr> luite: How are your kids?
13:51:04 <shapr> haha
13:51:20 <luite> don't have kids either, and i'm not even getting married this month
13:51:27 <kallisti_> hm
13:51:46 <shapr> howdy kallisti_!
13:51:47 <luite> shapr: do you have interesting on-topic thing to talk about?
13:51:48 <kallisti_> counting list length with natural numbers would be more efficient than the default strict computation.
13:51:51 <kallisti_> shapr: hey
13:52:15 <shapr> luite: Yes, I wanted to tell you about our first quick hack of a tryhaskell clone using scotty and hint!
13:52:25 <shapr> Heck, let me check the source into github and you can try it...
13:52:30 <luite> shapr: oh how interesting!
13:52:31 <kallisti_> because then you could have length ls > 5  be short-circuiting, for example.
13:52:56 <kallisti_> shapr: btw filter is broken right now.
13:52:59 <kallisti_> I need to upload the bugfix.
13:53:04 <shapr> kallisti_: More efficient would be using "atLeast n" so it can be lazy and work on infinite lists!
13:53:13 <shapr> kallisti_: Ah, I used flatten and then filter
13:53:24 <luite> shapr: i did not know that you could use haskell for the web. i thought it was only useful for calculating fibonacci, and parsing fibonacci numbers
13:53:34 <shapr> kallisti_: But I've been meaning to ask you for a way to write this snippet of code using more of your lib
13:53:35 <nand`> kallisti_: would it stack overflow for very large naturals?
13:53:47 <shapr> luite: haha
13:53:50 <kallisti_> shapr: using peano numbers is going to be the same efficiency, modulo constant factors.
13:54:00 <kallisti_> and it's also more general and works with existing numeric functions
13:54:25 <shapr> luite: We chose scotty because it's very simple, have you seen my jsonclock code on github?
13:54:35 <luite> shapr: yeah
13:54:48 <luite> yesod code wouldn't have been much longer though
13:54:49 <nand`> I do think that “length” returning an Int is odd though, since lengths can never be negative
13:54:54 <shapr> oh?
13:55:23 <kallisti_> using lazy natural numbers for list length would also work reasonably well with infinite lists
13:55:27 <hpaste> cem pasted “help” at http://hpaste.org/69034
13:55:32 <shapr> luite: What would yesod add?
13:55:34 <kallisti_> length ls < 5   would evaluate to False for infinite lists.
13:55:37 <luite> shapr: but at least with yesod it's easy to get lost in the api at first
13:55:49 <shapr> Yah, that's one advantage to scotty, the api is TINY
13:55:55 <shapr> But hey, I should go buy the yesod book anyway.
13:56:02 <nand`> sortBy (comparing length) <- infinite lists are sorted to the end
13:56:06 <shapr> It's for business purposes... so I'll take it off my taxes.
13:56:09 <nand`> wait
13:56:23 <nand`> that would fail for comparing two infinite lists
13:56:27 <kallisti_> yes
13:56:37 <nand`> I suppose it works for one though
13:56:42 <luite> shapr: i guess more built-in functionality, and monad transformer instances ;p
13:57:01 <shapr> ok, that's a good point.
13:57:16 <shapr> Apfelmus was talking about happstack-lite as an alternative that has monad transformer instances already.
13:57:28 <stepcut> sweet!
13:57:56 <kallisti_> shapr: well the whole library is pending a fairly significant rewrite
13:58:21 <luite> shapr: if you're just serving json then many templating things in yesod aren't really that useful
13:58:52 <stepcut> shapr: are you going to create a nice in-browser Haskell editor with syntax highlighting and error insertion ?
13:59:05 <shapr> stepcut: Couldn't I steal that from someone else?
13:59:18 <stepcut> shapr: dunno.. I was hoping to steal it from you
13:59:20 <shapr> oh
13:59:24 <shapr> I saw something recently...
13:59:26 <stepcut> :)
13:59:27 * shapr checks browser history
13:59:32 <luite> shapr: but you still get some use from the static subsite, automatic representation choosing (so you can have json and html at a single url), routing etc
13:59:44 <stepcut> there are a number of in-browser code editors.. but I don't know if any support haskell syntax
14:00:01 <shapr> stepcut: Seen any really good in-browser code editors?
14:00:02 <luite> shapr: hehe i know apfelmus isn't a huge fan of yesod's quasiquoters :p
14:00:08 <kallisti_> shapr: in particular I want to make it store information about symbolic links and directories/files
14:00:20 <kallisti_> so you can ask questions about that in pure code.
14:00:21 <stepcut> shapr: not really. Haven't really looked yet though
14:00:49 <shapr> kallisti_: That would be nice.
14:00:53 <kallisti_> and then there would be multiple filters for different kinds of path filtering. you would filter paths differently from the way you filter directories.
14:01:03 <kallisti_> which fixes this weird behavior of the current filter.
14:01:25 <RylandAlmanza> I'm recording a darcs repo, and it's asking what the patch name is
14:01:29 <RylandAlmanza> What should I call it?
14:01:30 <luite> shapr: (i don't think they'd be a problem for this app though, that's more likely to be an issue when you have very strict routing requirements, like when converting an existing site, preserving all urls)
14:01:31 <kallisti_> s/paths/files/
14:01:55 <stepcut> RylandAlmanza: just give a short description of what the patch does..
14:02:24 <RylandAlmanza> Thanks, stepcut
14:02:32 <stepcut> RylandAlmanza: no problem
14:02:57 <kallisti_> shapr: you could also use lazy IO on the directory/symbolic polling, to minimize the number of polls required
14:03:08 <kallisti_> but I wonder at what point the lazy IO gets out of hand.
14:04:29 <luite> shapr: anyway i dont think the choice is particularly important, i converted my app from snap to yesod in a week or so
14:04:33 <kallisti_> I could add a "refresh" function, which re-syncs a tree with the current filesystem. that would make it more viable for long-term storage.
14:04:59 <kallisti_> for things like GUI file browsers, for example.
14:05:20 <stepcut> luite: now convert it to happstack! And write a blog post about what you liked best and worst about each system :)
14:05:27 <luite> hehe
14:05:46 <luite> stepcut: i used happstack for a while in an older version because it was based on a modified gitit
14:07:27 <luite> shapr: are you going for a console interface first, like ghci?
14:07:27 <stepcut> luite: you'll be back!
14:07:58 <shapr> So, what's to prefer about happstack vs yesod vs other options?
14:10:43 * hackagebot glpk-hs 0.3.2 - Comprehensive GLPK linear programming bindings  http://hackage.haskell.org/package/glpk-hs-0.3.2 (LouisWasserman)
14:11:15 <stepcut> shapr: what to prefer depends on what you want :) Like.. if you want simple, then you should prefer it because happstack-lite is very simple. If you like type-safety, then you should like it because of web-routes, reform, etc
14:11:38 <stepcut> shapr: if you like freedom and flexibility, you should like it because it has a wide range of supported options
14:12:05 <stepcut> shapr: if you like good documentation, you should learn it because it has a great 'book' and a extensive haddock documentation
14:12:44 <luite> ^ - don't use glpk-hs, it has a bug where it reports that your linear program is solved to optimality if it's actually infeasible
14:13:01 <stepcut> shapr: on a deeper level, you might choose happstack because it prefers to embrace more Haskellish solutions like combinators rather than code generation solutions like quasi-quotes
14:13:05 <luite> and the author doesn't seem to reply to email
14:13:19 <shapr> luite: He's active on G+
14:13:26 <shapr> luite: Perhaps he missed your bug report?
14:13:34 <luite> you possibly, i'll mail him again
14:13:37 <luite> err
14:13:38 <luite> yeah possibly
14:14:00 <hdev> say i have a library and need to change a single function in there, do I have to patch the library code?
14:14:19 <luite> yes
14:14:44 <luite> or implement it yourself in a differnt module
14:14:57 <luite> but you can't really change the behaviour of existing functions
14:15:10 <stepcut> hdev: in some cases you might be able to make a copy of the function locally, but other callers of the function would still get the standard library version then
14:16:54 <luite> if you use ghcjs you could do some ffi call to replace the function :)
14:18:12 <hdev> thanks, i'm used to interpreted untyped languages and have been searching for a way to do that - i'm not sure what impact it has if two projects need different versions of that library
14:19:34 <kallisti_> shapr: I could also add support for testing for character/block devices, named pipes, and sockets.
14:19:44 <kallisti_> but I'm not sure how well that would work.
14:25:43 <kallisti_> edwardk: do you have any code dealing with predicates? i.e. a -> Bool
14:25:56 <kallisti_> edwardk: as in like, various semigroups/monoids for these
14:26:03 <djahandarie> Boolevil
14:26:06 <parcs`> > True ++ False
14:26:07 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Bool.Bool)
14:26:08 <lambdabot>    arising from a use of...
14:26:26 <kallisti_> > All True ++ All False
14:26:28 <lambdabot>   All {getAll = False}
14:27:22 <parcs`> :t All
14:27:24 <lambdabot> Bool -> All
14:29:23 <Dtgr> does the filename of the file need to be same as the name of the module that's in the file?
14:29:42 <kallisti_> it's recommended but not technically required.
14:29:55 <kallisti_> that's how it finds modules by default
14:30:00 <kallisti_> (it being GHC)
14:30:16 <Dtgr> how do you import them from a file that has a different name?
14:30:38 <Cale> Dtgr: by specifying them on the commandline where you run GHC
14:30:55 <Dtgr> ah okay
14:30:57 <Dtgr> thanks :)
14:31:19 <kallisti_> I actually can't find the specific option
14:31:24 <Cale> (but don't do that, it's inconvenient for everyone involved)
14:32:15 <kallisti_> unless it's an undocumented feature of -i
14:34:38 <Dtgr> well, I'm just wondering. restrictions like that just reminds me of java
14:34:58 <Dtgr> which is obviously horrifying
14:35:05 <kallisti_> edwardk: ah nevermind. I found what I was looking for.  a -> All or a -> Any  are semigroups.
14:35:21 <b_jonas> Dtgr: I don't like it either. why can't I just easily put more than one namespace in a compilation unit?
14:35:30 <b_jonas> Compilation units and namespaces should be separate.
14:35:43 <kallisti_> because these compilation units are hard to find without explicit path lists and build scripts
14:36:09 <b_jonas> I can easily divide a namespace to more than one compilation unit though: just define part of it elsewhere and import everything. That wouldn't work in java I guess.
14:39:07 <Cale> But there is the practical problem of what GHC should do to find the modules that you import, and being forced to specify all the modules in your project on the commandline is just as inconvenient.
14:40:45 * hackagebot cpsa 2.2.9 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-2.2.9 (JohnRamsdell)
14:42:03 <Cale> I think it would be nice to have the ability to define modules A.B and A.C inside A.hs though
14:45:51 <b_jonas> Cale: how about if you could define any module in file A.hs as long as that file also defines module A and you import module A before trying to import any of the other modules in that file?
14:46:11 <b_jonas> So when you import A, ghc finds A.hs and reads all the modules and knows what it's read and won't try to search for them.
14:47:04 <kallisti_> but now you need to define the order in which modules are searched.
14:47:26 <Cale> I guess that could work. Seems like it could be slightly confusing though. It would mean that trying to remove the import of A from another module which no longer needs A, but needs some other module from that file would then fail.
14:48:16 <Cale> (you would be forced to import A, or else build your project differently)
14:48:17 <armlesshobo> hmm. just finished my first little "project" with haskell
14:48:19 <b_jonas> but yes, maybe searching A.B inside A might also work
14:48:23 <kallisti_> we could just have an include directive!! yeaaah
14:48:26 <armlesshobo> i'm almost afraid of having you guys critique it LOL
14:48:56 <kallisti_> include $HOME/lib/myProject.hs
14:49:04 <kallisti_> import SomethingFromMyProject
14:49:06 <b_jonas> Cale: that's a problem only if you accidentally define a module in two different files, right?
14:49:17 <Cale> b_jonas: uh, nope.
14:49:27 <Cale> b_jonas: er, oh, you mean the A.B thing?
14:49:32 <b_jonas> armlesshobo: why aren't you using pointfree? why are you using pointfree.
14:49:34 <kallisti_> it means that in order to use in modules in A.hs, you need to import A
14:49:40 <armlesshobo> what
14:49:50 <Cale> Yeah, I guess you could have both A.hs containing module A.B, and A.B.hs and A/B.hs
14:49:54 <b_jonas> armlesshobo: yes, we'll critique you no matter what you do
14:50:26 <Cale> but you can already have the latter two, so we already have that kind of ambiguity about the physical location of the module
14:50:35 <b_jonas> armlesshobo: hpaste.org will critique you for too many parenthesis, we will complain for too few parenthesis
14:50:36 <armlesshobo> b_jonas: lol
14:51:02 <kallisti_> I will complain because it doesn't use my favorite libraries.
14:51:03 <armlesshobo> b_jonas: i'm more concerned about formatting, than style, really
14:51:05 <kallisti_> such as the ones I've written.
14:51:07 <armlesshobo> lol
14:51:38 <armlesshobo> "Sorry, kallisti_, but your libraries weren't deemed 'deep' enough. We're going to have to remove them from this project. Thank you"
14:51:53 <b_jonas> Cale: or you could have the same module under different include paths
14:51:55 <armlesshobo> s/deep/robust/
14:52:01 <armlesshobo> etc
14:52:01 <armlesshobo> lol
14:52:10 <b_jonas> Cale: or one in your source tree and one installed earlier
14:53:34 <kallisti_> armlesshobo: agile, perhaps?
14:53:52 <fmap> Is there a way to generate comments with TH?
14:53:59 <armlesshobo> so, to make your type monadic, you just make instance of Monad with your type?
14:54:24 <armlesshobo> kallisti_: "Sorry, we no longer request communications with you. Thank you"
14:54:28 <armlesshobo> kallisti_: lol
14:54:37 <kallisti_> armlesshobo: it should also satisfy the monad laws.
14:54:43 <armlesshobo> kallisti_: right.
14:54:54 <kallisti_> but we can't enforce that.
14:54:57 <armlesshobo> true
14:55:01 <armlesshobo> well
14:55:09 <kallisti_> there are some libraries that define Monad instances purely for notational convenient.
14:55:10 <armlesshobo> you could, just not directly touching the code lol
14:55:29 * kallisti_ can't remember the names of these, but he's seen them! promise.
14:55:45 * hackagebot repa-v4l2 0.1.0.0 - Provides high-level access to webcams.  http://hackage.haskell.org/package/repa-v4l2-0.1.0.0 (ChristianGosch)
14:56:33 <ClaudiusMaximus> (that seems to need a package i wrote and didn't get around to uploading...)
14:57:42 <armlesshobo> kallisti_: how is it convenient to do that?
14:58:22 <kallisti_> armlesshobo: it's convenient because it allows you to exploit do notation.
14:58:49 <armlesshobo> kallisti_: ahhh. I see
14:59:07 <danr> cool, repa access to webcam
15:02:50 <hiptobecubic> looks like only still images?
15:03:36 * kallisti_ wonders if the Haskell community could ever reach a consensus on what a revised base library should look like.
15:03:45 <danr> hiptobecubic: there's grab function
15:03:50 <ClaudiusMaximus> if you can wait an hour, i should have its deps uploaded...
15:03:56 <danr> grab :: MonadIO m => V4lCamT m (Image U Word8)
15:05:23 <danr> hiptobecubic: and if you use gloss you can view it, I presume
15:05:28 <danr> http://gloss.ouroborus.net/
15:05:36 <armlesshobo> :q
15:05:38 <armlesshobo> ...
15:05:49 <hpc> [sudo] password for armlesshobo:
15:06:01 <armlesshobo> buttsbuttsbutts
15:06:04 <armlesshobo> gdi
15:06:05 <armlesshobo> ...
15:06:10 <armlesshobo> fooled again
15:06:12 <hpc> haha
15:06:39 <rwbarton> just pretend :q was a smiley
15:06:45 <armlesshobo> :O
15:06:58 <armlesshobo> pretty bizarre smiley
15:07:25 * kallisti_ thinks that bits and pieces of the cond package could go into Prelude and Control.Monad
15:07:39 <kallisti_> at which point you could generalize other functions with boolean arguments
15:08:00 <kallisti_> which would then make semigroups/monoids like All and Any easier to use.
15:08:04 <kallisti_> or at least more convenient.
15:25:48 * hackagebot v4l2 0.1 - interface to Video For Linux Two (V4L2)  http://hackage.haskell.org/package/v4l2-0.1 (ClaudeHeilandAllen)
15:32:01 <HairyDude> wibble
16:16:32 <tgeeky> wobble
16:22:49 <tgeeky> nand`: ping
16:51:43 <applicative> moo
17:05:17 <tgeeky> The cow goes: baaaaa. <Stewie> It most certainly does not!
17:08:07 <strager> @quote
17:08:07 <lambdabot> danderson says: the path to [Haskell] enlightenment is long, but the previous pilgrims have opened nice little pubs along the way, so it's a pleasant trip
17:09:50 <Ralith> this place has the best quotes
17:17:32 <monochrom> s/pubs/burrito places/ :)
17:25:01 <zzo38> Is there program in Haskell to encode QR-codes? If so, can I use it with "dvi-processing" package?
17:32:48 <aristid> @hackage qrcode
17:32:48 <lambdabot> http://hackage.haskell.org/package/qrcode
17:33:42 <aristid> @hackage haskell-qrencode
17:33:42 <lambdabot> http://hackage.haskell.org/package/haskell-qrencode
17:34:05 <aristid> zzo38: i hope one of these is good :)
17:34:56 <zzo38> Yes it looks like that can be used, and then the matrix can be converted to a Node or PageObject which can then be printed out.
17:36:09 <zzo38> To reduce the number of rules on the page, an algorithm could be used to find rectangular blocks full of black cells. Do you know of such thing?
17:37:58 <zzo38> I could then add other barcodes too; for 1D barcodes it would be simpler to do.
17:43:37 <zeellos> hi
17:43:53 <applicative> zeellos hi
17:44:03 <zeellos> i'm in LP class =)
17:44:19 <zzo38> I have made dvi-processing to draw a filled triangle. But currently it does not draw the following shapes: unfilled triangle, polygon, filled circle, unfilled circle, line segment (with specified thickness), curve, bar chart, pie chart, horoscope chart, function graph, world map, Venn diagram, shaded area, scatter plot, flowchart, etc
17:45:05 <zeellos> i'm learning haskell in classroom LP =)
17:45:44 <zeellos> sort doesn't work in hugs why ?
17:46:01 <monochrom>  :m + Data.List
17:46:03 <hpc> the first problem is you are using hugs ;)
17:46:19 <monochrom> err, :m + List
17:46:20 <hpc> hugs is ancient, and you're probably better off with ghc unless your professor says otherwise
17:46:43 <zeellos> what's the solution? a current compiler?
17:46:55 <hpc> @where ghc
17:46:55 <lambdabot> http://haskell.org/ghc
17:46:58 <monochrom> sort doesn't "work" in ghci either. you need the same :m + Data.List or List
17:46:58 <hpc> @where platform
17:46:58 <lambdabot> http://hackage.haskell.org/platform/
17:47:02 <zeellos> thanks
17:47:09 <hpc> also what monochrom said
17:49:44 <monochrom> http://xkcd.com/763/
17:49:49 <zeellos> 204 mb  in linux
17:50:49 <eldj> la clase no la vale
17:51:05 <homie> fwiw
17:51:11 <monochrom> ":m + List" is only 9 bytes
17:52:57 <zeellos> en clase de LP
17:53:32 <zeellos> por el team
17:53:47 <zeellos> Pedro
17:54:04 <zezikaro> What is the name of the 'in' in this let a = a in map toUpper "foo"
17:55:16 <monochrom> name? could you just call it "in"?
17:55:27 <zezikaro> It's so i can google what the heck is happening there
17:56:34 <strager> zezikaro: It's part of a 'let' expression
17:56:38 <strager> like 'of' is part of 'case ... of'
17:56:50 <strager> http://www.haskell.org/haskellwiki/Keywords#let
17:57:04 <eldj> haskell es xurreta
17:57:11 <monochrom> then I'll just answer you. either read the Haskell 2010 Report for syntax, or in short, the syntax goes "let {lots of definitions} in <expression>". inside the expression, you may assume those definitions
17:57:50 <zezikaro> haskell is hard =[
17:58:00 <Transhumanist> No, just different.
17:58:12 <Phlogistique> [A
17:58:12 <Transhumanist> But it's fun and once you get past the initial learning curve, it's beautiful.
17:58:15 <monochrom> in your example, there is a definition"a = a", but it is not actually used. you're just looking at map toUpper "foo" itself
17:58:55 <monochrom> a more interesting example is: let x=2+2 in x*x. you get (2+2)*(2+2)
17:59:16 <gg_> que haciendo dj ?
17:59:18 <hpaste> jpf_ pasted “hidden modules” at http://hpaste.org/69041
18:00:07 <jpf__> does anyone know how to solve that error? http://hpaste.org/69041
18:00:19 <gg_> que haciendo dj?
18:00:27 <eldj> programando potencia n haskell
18:00:34 <jpf__> i've already tried ghc-pkg expose heap
18:00:36 <gg_> ya hiciste el trabajo de lp?
18:00:41 <eldj> todavia falta
18:00:47 <monochrom> you are not supposed to import Data.Heap.Item, are you?
18:00:51 <gg_> es para hoy dia el trabajo
18:00:58 <eldj> GG
18:01:01 <gg_> fue ps
18:01:04 <gg_> con fe nomas
18:01:10 <eldj> con fe n l final
18:01:18 <gg_> haskell es fija en el final
18:01:27 <eldj> java con web tmb
18:01:31 <jpf__> monochrom, okay, then what?
18:01:56 <applicative> jpf__:its not exported.  hack the cabal  file
18:02:10 <applicative> or figure out why its not exported
18:02:39 <jpf__> applicative: that's aweful, i'll try
18:03:58 <applicative> you can just comment out line line 28  I notice this package has not been updated since 2009
18:05:08 <Eduard_Munteanu> gg_: this is an English-speaking channel.
18:05:30 <Eduard_Munteanu> You might get better results if you ask English questions :)
18:05:42 <hpc> or as they say in german: "no habla francois"
18:06:09 <gg_> eduard racist !!
18:06:24 <Eduard_Munteanu> I wonder if that makes me a linguist, rather.
18:06:29 <sipa> french in french is francais... or was that intentiomal as well?
18:06:29 <Eduard_Munteanu> I guess not.
18:06:39 <hpc> sipa: close enough :D
18:07:23 <sipa> francois is a common given name, related to "frank"
18:07:55 <eldj> c cierran
18:08:13 <monochrom> import Data.Heap; h = singleton 1 :: MinHeap Int.  there is no need to import Data.Heap.Item or hack anything
18:08:43 <monochrom> and "h = MinHeap 1" is probably full of errors
18:09:36 <applicative> jpf__: it looks like  Data.Heap reexports everything  Data.Heap.Item exports, except for a function  splitF
18:09:38 <gg_> se cierran con el español
18:09:51 <ymasory> is there an official repo for the learn you a haskell source? all i can find is https://bitbucket.org/fernandg/learn-you-a-haskell-for-great-good/src
18:09:53 <geekosaur> ...is #haskell-es still alive?
18:10:14 <Eduard_Munteanu> Doesn't look like it.
18:10:37 <hpc> ymasory: the point of LYAH is for you to type it yourself, not git clone ;)
18:10:44 * hpc doubts there is a repo
18:10:54 <gg_> creen un chat en español
18:11:01 <gg_> se cierran
18:11:19 <homie> hah
18:11:22 <applicative> jpf__: type errors you commit with the materials from Data.Heap are likely to refer to Data.Heap.Item, but you shouldn't need to get your hands on it
18:12:08 <Eduard_Munteanu> hpc: arguably that should be all Literate Haskell :P
18:13:39 <Eduard_Munteanu> Actually, I'm not sure it isn't.
18:14:45 <homie> if you look fo tha heisencat it's gone to #physics!
18:14:56 <homie> lol
18:16:46 <donri> how do you define instances for classes imported qualified in ghc 7.0?
18:17:13 <monochrom> can it be "instance M.Class where M.method = undefined"?
18:17:13 <applicative> instance A.Foo Int where foo = fromIntegral
18:17:32 <donri> monochrom: Parse error in pattern
18:17:40 <donri> for M.method
18:17:41 <applicative> you dont qualify the left hand side
18:17:44 <monochrom> perhaps not "M.method"
18:17:46 <donri> but simply "method" is a name error
18:17:49 <ymasory> hpc: thanks
18:17:58 <donri> at least for associated types
18:18:09 <monochrom> if the method names are not exported, you are stuck
18:18:09 <applicative> ah associated types
18:18:57 <monochrom> and exporting associated types takes extra effort and tricks, probably the author neglected that
18:19:16 <donri> well it works in ghc 7.4 or with non-qualified imports
18:19:37 <monochrom> that's strange then
18:19:51 <hpc> hmm, it occurs to me that you can almost kinda sorta get traditional OOP out of type classes with associated data families
18:19:58 <donri> presumably something that was fixed in 7.4? but was just wondering if there was a workaround for 7.0
18:20:20 <hpc> namely, abstract classes
18:21:29 <donri> also, why can you not have a class and a type with the same name in scope?
18:21:45 <donri> is that really ambiguous as it claims?
18:21:54 <hpc> donri: classes and types share a namespace
18:22:01 <hpc> i don't think it's ambiguous, but better safe than sorry
18:22:18 <hpc> actually, it might be ambiguous
18:22:23 <hpc> with polykinds and constraint kinds
18:22:49 <donri> sure but at that point types and value constructors can be ambiguous :p
18:22:56 <hpc> heh
18:23:16 <hpc> nah, for that you need data kinds
18:23:19 <monochrom> the haskell 98 committee foresaw polykinds and constraint kinds. they saw it coming!
18:25:21 <donri> looks like associated types are imported from the top-level of the module and not the Class(..)
18:25:30 <donri> so that's the work around
18:26:46 <applicative> the rules in http://www.haskell.org/haskellwiki/GHC/Type_families#Import_and_export are really gruesome.
18:27:41 <donri> heh
18:38:54 <NemesisD> whats the least painful way to have cabal(-dev) reinstall all of my dependencies with profiling enabled
18:39:28 <strager> Use your system's package manager =>
18:39:59 <NemesisD> use my distro's package manager to install haskell libraries from hackage?
18:42:56 <strager> At least in Debian and Ubuntu, there are packages for the -prof versions of each lib (including base and all that).
18:43:00 <Saizan> NemesisD: nuking ~/.ghc and restart with profiling enabled in ~/.cabal/config
18:44:24 <NemesisD> Saizan: i just remembered i was using cabal dev so it just required adding --enable-library-profiling to my makefile and nuke cabal-dev/
18:44:34 <NemesisD> i am entirely sold on cabal-dev now
18:45:10 <strager> yup
18:45:11 <strager> else ifeq (profile,$(config)) CABAL_CONFIG_FLAGS += --enable-optimization=1 --enable-library-profiling --enable-executable-profiling -fprofile
18:45:31 <strager> (in my Makefile)
18:47:06 <NemesisD> didnt know about --enable-optimization
18:48:22 <zeellos> i just installed ghc-7.4.1 by typing sudo apt-get install ghc
18:48:32 <zeellos> but when i want to install platform
18:48:36 <zeellos> show this error
18:48:38 <zeellos>  The Haskell Platform version 2011.4.0.0 requires ghc-7.0.4   It is recommended that you upgrade to ghc-7.0.4
18:49:06 <zeellos> isn't there current version in haskell website?
18:50:28 <Eduard_Munteanu> I guess that version of HP might depend on an older version of GHC?
18:51:15 <geekosaur> zeellos, that is cthe current haskell platform.  ubuntu 12..04 has its own so-called platform built against its ghc
18:51:20 <Eduard_Munteanu> zeellos: did you try getting HP through the package manager?
18:51:40 <strager> zeellos: Ubuntu's haskell-platform is NOT the 'real' Haskell platform.  But install it anyway.
18:51:43 <geekosaur> (there should in theory be an updated platform soon; supposedly by the end of th emonth)
18:53:08 <zeellos> zeellos: did you try getting HP through the package manager? ... how ?
18:53:56 <strager> zeellos: apt-get install haskell-platform
18:55:11 <zeellos> :D it work
18:55:21 <zeellos> downloading
19:01:18 <zeellos> i just installing haskell-platform but i can't running it, i try haskell-platform, hp, HP, ... in terminal
19:02:40 <gienah> zeellos: the haskell-platform is a set of haskell libraries, and a few development tool executables, it doesn't include an ide or anything like that
19:03:07 <rodayo> Is there an in built function that tells you if a list contains an element?
19:03:20 <dmwit> zeellos: Try ghci.
19:03:24 <rodayo> Something like :: a -> [a] -> Bool
19:03:27 <applicative> > elem 'a' "abv"
19:03:27 <lambdabot>   True
19:03:42 <rodayo> applicative, awesome, thank you
19:03:55 <dmwit> ?hoogle a -> [a] -> Bool
19:03:56 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
19:03:56 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
19:03:56 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
19:04:01 <cozachk> is 512 megs enough memory to compile ghc?
19:04:17 <dmwit> rodayo: Learn to ask in a way the automatic tools can answer. =)
19:04:34 <dmwit> cozachk: I doubt it. Maybe if you manage to get it to use gold or something like that.
19:04:46 <dmwit> (Linking is usually the memory-intensive stage.)
19:04:56 <cozachk> gold?
19:04:59 <gienah> cozachk: probably no, ghc head has some cross compiler stuff to build a stage1 compiler
19:05:03 <dmwit> ?google gold linking
19:05:05 <lambdabot> http://www.flyertalk.com/forum/british-airways-executive-club/1329029-ba-gold-linking-pnrs.html
19:05:10 <dmwit> hm, not quite
19:05:27 <dmwit> Anyway, the ld replacement.
19:06:42 <ion> @google gnu gold linker
19:06:44 <lambdabot> http://en.wikipedia.org/wiki/Gold_(linker)
19:06:44 <lambdabot> Title: gold (linker) - Wikipedia, the free encyclopedia
19:07:15 <cozachk> pure gold ? ;)
19:09:28 <zeellos> thanks, i run ghci, but sort doesn't work  why?
19:10:11 <zeellos> Not in scope: `sort'     Perhaps you meant `sqrt' (imported from Prelude)
19:10:21 <dmwit> import Data.List
19:11:33 <zeellos> Prelude> import Data.List?
19:11:36 <strager> Yes
19:12:08 <zeellos> :O it work
19:12:13 <zeellos> thanks :)
19:13:14 <zeellos> how do i do it automatically?
19:14:21 <rodayo> I'm writing a function that gives a list of the fridays in the year that occur on prime-number days, like Fri 13th. I've used a list comp. : primeFridays y = [[d] | d <- (daysInYear y), isFriday d, isPrimeDay d]  but I get an error saying " Couldn't match expected type `Day' with actual type `[t0]'" - my guess is I need to specify what datatype the list will contain. Is that right or there some other problem?
19:15:23 <dmwit> zeellos: echo import Data.List > ~/.ghci
19:16:00 <zeellos> thanks dmwit u r master !!
19:16:05 <dmwit> rodayo: It's impossible to know without more context/type declarations, but are you sure you wanted [d] at the beginning?
19:16:16 <dmwit> Perhaps just [d | ...]
19:18:44 <applicative> dmwit no, echo import qualified Data.Vector.Unboxed as V > ~/.ghci
19:18:45 <rodayo> dmwit, oh i see - yep that did the trick.
19:19:16 <rodayo> thanks
19:20:17 <zeellos> i have this message *** WARNING: /home/ronald/.ghci is writable by someone else, IGNORING!
19:20:52 <zeellos> i put echo import Data.List > ~/.ghci and sudo echo import Data.List > ~/.ghci
19:21:06 <zeellos> i have the same message
19:21:07 <dmwit> Why would you use sudo for that?
19:21:20 <zeellos> i try it both
19:21:23 <dmwit> Why?
19:21:28 <strager> sudo wouldn't do anything
19:21:34 <dmwit> sudo *does* do something.
19:21:36 <dmwit> That's the problem.
19:21:38 <strager> Don't sudo unless you know what you're doing; you're setting yourself up for failure
19:21:46 <strager> it echoes as su, but not much else =]
19:21:54 <zeellos> i try without sudo, too , the same problem
19:21:58 <strager> chmod a-w ~/.ghci
19:22:08 <dmwit> zeellos: Change ownership of ~/.ghci back to your user.
19:22:09 <strager> or chmod 644
19:22:11 <dmwit> strager: Not the problem.
19:22:34 <strager> How did you determine that that isn't the problem?
19:22:45 <dmwit> By thinking about it.
19:22:47 <strager> It could either be the permission bits or the uid/gid.
19:23:25 <dmwit> Not unless zeellos has also changed the umask for his superuser, which he certainly hasn't if he made such a rookie mistake.
19:24:17 <zeellos> :O work with chmod a-w ~/.ghci thanks dmwit, thanks strager it was impossible to me do it alone
19:24:40 <dmwit> ....
19:24:43 <strager> dmwit: echo x > y is indistinguishable from sudo x > y
19:24:48 <strager> er
19:24:50 <strager> sudo echo x > y
19:24:51 <dmwit> You just made it impossible to change .ghci, even for yourself.
19:24:55 <strager> The piping isn't done under sudo
19:25:01 <kylaline> Hello. What's the shortest way to apply f to every second element of a list?
19:25:22 <dmwit> strager: ...you're quite right, of course. Apologies.
19:25:56 <strager> oh you're right; I forgot a-w is ~222
19:25:59 <dmwit> kylaline: Use chunk from Data.List.Split.
19:26:09 <strager> I keep thinking a means "the lower octave"
19:26:35 <strager> o-w is the appropriate thing to do
19:26:37 <dmwit> zeellos: You'll probably want to chmod o+w ~/.ghci.
19:26:42 <dmwit> bleh
19:26:45 <dmwit> o is other
19:26:48 <dmwit> what's owner?
19:26:49 <strager> u+w =]
19:26:51 <strager> user
19:26:54 <dmwit> u+w
19:26:55 <kylaline> dmwit: thanks
19:26:57 <strager> u user, g group, o other, a all
19:27:01 <strager> Silly UNIX =]
19:29:48 <zeellos> your conversation is too high to my knowledge
19:31:39 <dmwit> zeellos: chmod u+w ~/.ghci
19:31:42 <dmwit> thank us later
19:32:41 <zeellos> chmod a-w ~/.ghci it work , but is chmod u+w ~/.ghci  right?
19:32:59 <dmwit> The permissions are stateful.
19:33:17 <strager> chmod 644 ~/.ghci
19:33:20 <ion> chmod 644 .ghci
19:33:23 <strager> Less problems!
19:33:27 <dmwit> The second is only necessary because the first was done without thinking.
19:33:48 <strager> 644 is rw-r--r--
19:33:54 <dmwit> Well, it's necessary because the first was done and independent of thinking. =)
19:34:39 <zeellos> chmod 644 or a-w?
19:34:48 <strager> 644; explicit octals are safest
19:34:58 <strager> (for this kind of thing)
19:34:58 <dmwit> zeellos: man chmod first
19:35:03 <strager> hehe
19:35:05 <dmwit> Then make your choice.
19:35:21 <strager> "Haskell sucks; I gotta learn to use apt and haskell-platform and chmod and ghci and import Data.List!"
19:36:51 <hughfdjackson> :p i'm actually pretty sure that there's a far more legitimate 'high barrier to entry' complaint to be made
19:36:59 <shapr> hughfdjackson: Like what?
19:37:34 <hughfdjackson> that the IO model (and most people want to to IO pretty quickly in programs) uses both a difficult to understand ..thing (construct?) in monads
19:38:00 <shapr> hughfdjackson: I think objects are probably more difficult.
19:38:01 <hughfdjackson> and also a sugar that misleads by disguising the mechanism
19:38:04 <strager> I got by with just 'print' inside of 'do' for a while.
19:38:12 <shapr> But I admit, they're not immediately necessary for getline and putline.
19:38:31 <zeellos> may be was intentionally to learn moe things than ghci, or would be easy like sudo apt-get  install  vim
19:38:37 <zeellos> more*
19:38:41 <hughfdjackson> it's really hard to be objective in something like this; we're all coloured by our backgrounds
19:39:02 <hughfdjackson> and also by our predilictions
19:39:12 <hughfdjackson> i find it very hard to use something that just works(tm)
19:39:16 <shapr> I remember how much mental effort I spent learning OOP, it was more than I spent learning monads.
19:39:49 <hughfdjackson> the basics of OOP took me far less time than the basics of monads
19:40:02 <shapr> Part of that is because monads are very clearly plumbing, and objects weren't at the time.
19:40:02 <hughfdjackson> OOP has a really natural analog in the real world
19:40:06 <shapr> It does?
19:40:13 <hughfdjackson> yea; objects in the real world
19:40:16 * applicative !!!??
19:40:19 <hughfdjackson> an object does stuff and has attributes
19:40:45 <hughfdjackson> at that level, i found OOP very natural
19:40:58 * applicative ?!!
19:41:07 <hughfdjackson> applicative: :p cat got your tongue?
19:41:40 <strager> I became deenlightened on OOP after learning Haskell.  =[
19:41:41 <shapr> I think prototype-oriented programming makes more sense. Having a separate inheritance and instance hierarchy is weird.
19:41:49 <strager> *classical OOP
19:41:55 <hughfdjackson> shapr: for sure :3
19:41:55 <strager> I still like prototypes =]
19:42:02 * hughfdjackson spends most of his time in javascript
19:42:02 <shapr> I think a lot of parts of OOP are unnatural, but I suspect that's true of most programming abstractions.
19:42:04 <Ralith> "instance hierarchy"?
19:42:05 <hughfdjackson> as strager well knows
19:42:11 <strager> =D
19:42:33 <strager> That's two people from #bbg I've seen here.
19:42:38 <hughfdjackson> :D
19:42:42 <hughfdjackson> who else?
19:42:52 <strager> justicefries
19:42:52 <shapr> me me! Wait what?
19:42:58 <shapr> What's bbg?
19:43:05 <strager> A channel on Browser Based Gaming
19:43:08 <hughfdjackson> shapr: channel for browser based games
19:43:09 <strager> Flash, HTML5, etc.
19:43:11 <hughfdjackson> damnit, beaten to it
19:43:14 <shapr> Ralith: I can't inherit from an instance, and I can't change values on a class.
19:43:16 <strager> Mostly development
19:43:29 <strager> Not inheriting from an instance always confused me.
19:43:35 <hughfdjackson> :D if you feel like making one, feel free to join us in bbgchallenge6
19:43:41 <shapr> Ralith: Prototype-oriented programming (Self, NewtonScript, JavaScript, etc) have a single hierarchy.
19:43:50 <hughfdjackson> http://github.com/hashbbg/bbgchallenge6
19:43:51 <Ralith> shapr: so does conventional OOP...
19:43:55 <hughfdjackson> :# okay, plug over
19:44:04 <Ralith> instances do not have their own distinct hierarchy.
19:44:12 <shapr> Ralith: No, I must explicitly create instances from a class hierarchy.
19:44:18 <shapr> There's a split there.
19:44:23 <Ralith> there's no second hierarchy.
19:44:33 <shapr> Ok, fair enough.
19:44:35 <Ralith> :P
19:44:39 <otters> will cabal-dev ghci generate the Paths_* module?
19:44:39 <shapr> But it's still a weird split that makes no sense.
19:44:46 <strager> In prototypal languages, 'classes' are 'instances' of other 'classes'.
19:44:54 <strager> It's a more unified model.
19:45:35 <hughfdjackson> people spend a long time talking about inheritence; a disproportionate amount of time vs its usefulness
19:45:39 <Ralith> I know how prototype systems work.
19:45:40 <shapr> hughfdjackson: I still believe that monads are a simpler abstraction than objects, but I don't know if I can come up with any way to quantify that.
19:46:00 <Ralith> does plato's allegory make sense to you?
19:46:06 <Ralith> because that's all class-based oo is.
19:46:08 * hackagebot QuasiText 0.1.2.2 - A QuasiQuoter for Text.  http://hackage.haskell.org/package/QuasiText-0.1.2.2 (MikeLedger)
19:46:11 <strager> They're 'simpler' as in 'less moving parts', I think.
19:46:24 <hughfdjackson> shapr: i suspect it's that you and i just have fundamentally different backgrounds or .. preferred mental model
19:46:32 <Ralith> he didn't say "more complicated", he said "makes no sense"
19:46:42 <shapr> I dunno, I started with visual basic, then went to java, then python 1.4
19:46:50 <hughfdjackson> oh :/ well..
19:46:52 * applicative counts  the moving parts in (>>=) and return
19:47:25 <shapr> Ralith: Ok, I believe that separating instances from class definitions is unnecessary, :-P Is that better?
19:47:26 <hughfdjackson> yea, i'm not arguing about the level of complexity in implementation; moreso the level of necessary understanding to have an intuitive feel for the use of one or the other
19:47:43 <otters> or rather, is there a convenience function for getting the current cabal package version number?
19:47:51 <shapr> cabal install cabal ?
19:47:58 <boxo> is there an extension that would let me freely use 'where' in expressions, like 'let'
19:48:00 <strager> The State and Maybe monads are really simple and I can't think of really good, small examples of really simple OOP classes.  (Stream (file, socket, memory, etc.) is a good example, but it's by no means simple.)
19:48:08 <Ralith> shapr: sure--but "not necessary" is very different from "not a good idea"
19:48:28 <strager> otters: man ghc-pkg
19:48:29 <otters> shapr is that directed at me
19:48:29 <shapr> Ralith: Do you think the separation of classes and instances is a good idea?
19:48:31 <otters> oh
19:48:37 <Ralith> shapr: I don't know whether it is or not.
19:48:42 <Ralith> I think both are clearly effective.
19:48:45 <otters> strager: I meant from inside the package itself
19:48:47 <shapr> otters: Well, that will show you the version number, but it may also install a newer version at the same time :-)
19:48:52 <Ralith> given that neither are obviously inferior, I don't think it really matters.
19:49:02 <shapr> ok then
19:49:10 <Ralith> well, class-based has slightly stronger typing in its favor.
19:49:14 <Ralith> I'm a fan of that.
19:49:16 <strager> otters: I have in my code: #if MIN_VERSION_containers(0, 5, 0)
19:49:25 <strager> which means "if containers >= 0.5.0"
19:49:27 <strager> Is that what you want?
19:49:41 <otters> well, I'd like to actually print out the current version
19:49:42 <applicative> otters once in a while someone exports version = "blah.11.1"
19:50:01 <strager> otters: Why's that?  For licensing reasons?
19:50:31 <otters> strager: it's an IRCd and I'd like to put the version number in RPL_MYINFO
19:50:45 <otters> I don't *have* to, or I could change the hardcoded value with updates, but I mean...
19:50:47 <strager> Version number of what, exactly?  The 'current' package?
19:50:59 <otters> Yeah, you know, the package version found in the cabal file
19:51:54 * applicative thinks ah, ghc-stage1 is hard at work; reason is overtaking this stupid machine
19:52:51 <strager> otters: https://github.com/haskell/cabal/blob/master/Cabal/Distribution/Simple/Build/Macros.hs#L39
19:53:03 <strager> Try VERSION_mypackage ?
19:53:13 <strager> nope; externalPackageDeps
19:53:25 <otters> huh?
19:53:47 <strager> cabal includes some #defines itself into your project.
19:53:57 <madmod> strager: The book Elemental Design Patterns shows some small examples of oo design patterns http://www.amazon.com/Elemental-Design-Patterns-Jason-Smith/dp/0321711920
19:54:10 <strager> I was thinking that perhaps VERSION_mypackage could reference your own package's version.
19:54:24 <strager> But the source shows that only externalPackageDeps is used.
19:54:38 <otters> I don't really understand what I should be doing
19:54:52 <strager> madmod: I'm not looking for design patterns; I'm looking for reuseable and useful OOP pieces of code that are simple.
19:54:59 <strager> otters: Nevermind.  =]
19:55:19 <strager> In your cabal file you can include a preprocessor define.
19:55:25 <madmod> strager: I thought that's what design patterns are =]
19:55:44 <strager> I want an implementation ;P
19:55:50 <strager> like Maybe or State
19:56:04 <strager> the implementation of those monads are a few lines of code.
19:56:08 <strager> And they're very powerful.
19:56:19 <madmod> I'm not going to argue that
19:56:30 <strager> So is there something like that for OOP?
19:56:36 <otters> strager: like what?
19:56:40 <strager> It seems to me that OOP can only abstract "larger" things.
19:56:52 <madmod> oo does require a lot more "boilerplate" to interface between code
19:57:05 <strager> otters: Can't say I know how to do it exactly.  Have you use CPP with Haskell, or have you programmed in C or C++?
19:57:16 <monochrom> @quote hpc design
19:57:17 <lambdabot> No quotes match. Do you think like you type?
19:57:17 <otters> no
19:57:17 <Eduard_Munteanu> strager: arguably OOP languages are usually more wordy
19:57:22 <otters> Well, I have programmed in C
19:58:05 <strager> Not even talking about syntax, just concept.
19:58:39 <strager> otters: In Haskell, with a preprocessor ({-# LANGUAGE CPP #-}), you can do some basic CPP things like you can in C or C++.  #define FOO bar, #ifdef BAZ, etc.
19:58:44 <monochrom> almost by definition, design patterns are not going to be library code like State, Monad, or State's instance of Monad. https://plus.google.com/102208456519922110915/posts/LXxRByiCMV4
19:58:49 <otters> strager: in a cabal file?
19:59:05 <strager> otters: What you can try is adding such a #define in the cabal file, as an option to the compiler (so the #define is applied globally).
19:59:11 <otters> oh
19:59:13 <monochrom> a thing remains a design pattern precisely because the language doesn't let you make it library code
19:59:14 <madmod> oop lends it self to having many scopes, which usually requires more explicit interfaces
19:59:35 <strager> ghc-options: -DMYIRCD_VERSION=0.1.0
19:59:41 <strager> Or rather
19:59:46 <strager> or I dunno
19:59:55 <strager> You can figure it out, I'm sure =]
20:00:10 <strager> monochrom: Good point
20:00:30 <monochrom> it is hpc's point :)
20:00:31 <otters> then how do I get at that value in the code?
20:00:41 <monochrom> "unabstracted abstraction" nails it
20:00:57 <madmod> monochrom: design patterns themselves are language independent
20:01:03 <Eduard_Munteanu> So nothing interesting up to isomorphism? :P
20:01:22 <strager> otters: Just type MYIRCD_VERSION, assuming LANGUAGE CPP
20:01:55 <zeellos> please helpme with my script
20:01:56 <zeellos> let quicksort1 (x:xs) = if ( length (x:xs) == 0) then [] else ( quicksort1 ( filter ( < x) xs)) ++ [x] ++ (quicksort1(filter ( >= x) xs)) in quicksort1 [4,5,6,3,2,1]
20:02:00 <monochrom> the command pattern is language-dependent: it exists in java and python, it doesn't exist in haskell, haskell has full-fledged lambda
20:02:01 <zeellos> it's quicksort
20:02:05 <zeellos> but doesn't work
20:02:36 <monochrom> the visitor pattern doesn't exist in CLOS. CLOS has real multiple dispatch
20:02:37 <zeellos> Non-exhaustive patterns in function quicksort1
20:02:37 <otters> aha!
20:02:41 <Eduard_Munteanu> "quicksort"
20:02:44 <otters> the constant isn't accessible from cabal-dev ghci
20:02:46 <otters> but it's there
20:03:04 <zeellos> please can you give me the correction
20:03:04 <Eduard_Munteanu> zeellos: what if you give it an empty list
20:03:04 <applicative> zeellos: how could the length of x:xs be zero?
20:03:08 <otters> the only question is, how do I transform -Dkversion=0.0 into -Dkversion={version defined in cabal file}
20:03:18 <zeellos> (x:xs) = []
20:03:26 <Eduard_Munteanu> Um, no.
20:03:26 <monochrom> many design patterns in java would be library code in lisp, because as a last resort you can always use macros
20:03:41 <zeellos> how is the correct
20:03:46 <zeellos> plz in my code
20:04:04 <Eduard_Munteanu> zeellos: you need to pattern-match on [] specifically
20:04:06 <applicative> > let quicksort1 [] = []; quicksort1 (x:xs) = ( quicksort1 ( filter ( < x) xs)) ++ [x] ++ (quicksort1(filter ( >= x) xs)) in quicksort1 [4,5,6,3,2,1]
20:04:08 <lambdabot>   [1,2,3,4,5,6]
20:05:00 <applicative> zeellos, pattern matching is the way forward
20:05:28 <otters> I don't think a cabal file has the concept of variables
20:05:37 <Eduard_Munteanu> zeellos: what you did was like comparing Just _ to Nothing. That's never true.
20:06:04 <Eduard_Munteanu> Never equal, that is.
20:07:00 <monochrom> design patterns are language-"independent" as long as you only consider a bunch of pretty similar languages. just like some old-geezers kept saying "if you know one language, it's trivial to pick up another". if you know only C, is it trivial to pick up prolog?
20:07:05 <Eduard_Munteanu> x:xs means "some element x consed to another list xs", so by definition it can't be empty.
20:07:57 <otters> strager: how do I reference the version defined in the cabal file in other places in the cabal file?
20:10:25 <newsham> ?src sort
20:10:26 <lambdabot> sort = sortBy compare
20:10:29 <newsham> ?src sortBy
20:10:30 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
20:10:36 <monochrom> ha ha ha
20:10:44 <strager> otters: Can't say I know
20:10:50 <newsham> huh, i did not know that
20:11:05 <otters> well frick
20:11:14 <monochrom> you need to find the author of the @src file, and thank him/her :)
20:11:59 <otters> where the cabal experts at
20:12:17 <newsham> "Design patterns" == algorithms for humans because they cant be encoded in their silly languages
20:32:04 <RylandAlmanza> Anyone successfully installed darcs 2.8.1 on windows using cabal?
20:32:33 <_madmod_> why do I need to wrap negative numbers in () in haskell?
20:33:31 <irene-knapp> because - is an operator
20:33:39 <_madmod_> ah ok
20:33:39 <strager> Because it thinks the - is the binary subtraction operator
20:34:24 <geekosaur> the syntax of haskell leads to a bit of weirdness with unary operators that can also be binary operators.  this is difficult to fix without complicating other things (notably sections)
20:37:51 <_madmod_> so is "(+(-1)) 1" the shortest way to write decrement then?
20:39:52 <Eduard_Munteanu> > pred 5
20:39:53 <lambdabot>   4
20:40:07 <Eduard_Munteanu> > map pred [1,2,3]
20:40:08 <lambdabot>   [0,1,2]
20:40:42 <_madmod_> what about -2?
20:41:03 <Eduard_Munteanu> I'd use 'subtract'.
20:41:07 <Eduard_Munteanu> :t subtract
20:41:08 <lambdabot> forall a. (Num a) => a -> a -> a
20:41:22 <Eduard_Munteanu> > map (subtract 2) [1,2,3]
20:41:23 <lambdabot>   [-1,0,1]
20:41:25 <shachaf> _madmod_: (-1+)
20:41:34 <shachaf> But the "standard" way is probably (subtract 1).
20:52:51 <newsham> ?type (+1+)
20:52:52 <lambdabot> parse error on input `)'
20:53:01 <newsham> ?type (-1-)
20:53:02 <lambdabot> forall a. (Num a) => a -> a
20:53:39 <newsham> thats gotta be worth something in an obfuscated haskell program
20:54:08 <ion> :-)
20:54:09 <Veinor> > (-1-) 2
20:54:10 <newsham> ?type (-0-).(-1-).(-2-).(-3-).(-4-)
20:54:10 <lambdabot>   -3
20:54:11 <lambdabot> forall a. (Num a) => a -> a
20:56:15 <newsham> > (-0-) 3
20:56:16 <lambdabot>   -3
20:56:33 <newsham> thats kinda fun syntax for negate
20:58:51 <shachaf> Hmm, it even works for -0.0 :: Double.
21:00:28 <siracusa> :t (- 0.0 -)
21:00:29 <lambdabot> forall a. (Fractional a) => a -> a
21:00:57 <otters> do cabal files support variables
21:01:23 <newsham> > (\h a s k -> (-h-).(-a-).(-h-).(-a-).(-h-).(-a-)) 1 3 3 7
21:01:25 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
21:01:25 <lambdabot>    arising from a use of `...
21:01:34 <newsham> > (\h a s k -> (-h-).(-a-).(-h-).(-a-).(-h-).(-a-)) 3 1 3 3 7
21:01:36 <lambdabot>   1
21:02:27 <kylaline> Hello again. Can I make a "where" apply to a single guard somehow?
21:04:55 <geekosaur> no, they explicitly scope over all guards.  use let within a single guard
21:05:45 <geekosaur> cf. http://www.haskell.org/pipermail/haskell-prime/2006-November/001910.html
21:05:57 <kylaline> ok, thanks
21:06:30 <zzo38> How common are things like this and does it have a name?  data X :: * -> * where { X :: XC x y => x -> X y; }; class Typeable x => XC x y | x -> y where { ... };
21:07:02 <zzo38> I have also been thinking of (Free (CoYoneda f))
21:10:50 <Uplink> salut les gars
21:11:18 <Uplink> hello everyone
21:11:51 <zzo38> Hello
21:12:07 <Uplink> this is my first time in irc
21:12:37 <Uplink> so you use Haskell?
21:12:40 <zzo38> Yes.
21:12:58 <zzo38> If this is your first time in IRC, did you read the RFC and/or the irssi documentation already?
21:13:34 <Uplink> no I don't know the major protocols
21:13:37 <tgeeky__> that's pretty hardcore. Wanna use IRC. Must read RFC first
21:13:57 <Uplink> haha
21:14:28 <zzo38> It is useful to understand the protocol for whatever protocol service you are using on internet, but depending on the client and what you are trying to do, it might not be necessary.
21:14:40 <tgeeky__> zzo38: I understand. I kid.
21:14:54 <newsham> oh come on.. thats a bit much for "want to use irc"
21:15:01 <zzo38> tgeeky__: But, I did read the RFC first before using IRC
21:15:06 <newsham> not to mention that the rfc is wrong
21:15:12 <tgeeky__> We should set up proxies for new internet users that just redirect them to a page with a list of WWW, HTTP, TCP, etc RFCs
21:15:39 <zzo38> The RFC is not wrong. The server and/or client may be wrong, but my IRC server and my IRC client follow the RFC correctly.
21:16:06 <Uplink> 10+ internet points for me discovering irc
21:16:36 <newsham> hrmm.. the updated the irc rfc
21:16:43 <newsham> they
21:17:28 <zzo38> My IRC server (it is running on the computer I am connecting to here from) accepts SUMMON command too
21:18:15 <tgeeky__> if you're the only person on an IRC server, is it really an IRC server? Ala, what is the sound of one hand clapping?
21:18:52 <ski> Uplink : have you found some tutorial or book to follow ?
21:18:59 <Uplink> So I heard ~30% of the Haskell community uses the OS X platform and is having a bit of a library problem. Is this true?
21:19:31 <tgeeky__> Uplink: 30% seems awfully high
21:20:05 <zzo38> ski: The thing that my VERSION response does not mention is PuTTY, since that is only a terminal emulator which can connect to PHIRC, it is not part of PHIRC
21:21:09 <ski> zzo38 : but it reports the OS the client is running on, yes ?
21:21:18 <zzo38> ski: Yes.
21:21:51 <Uplink> ski: im using learn you a haskell for great good and functional systems in Haskell has their lecture notes online
21:21:54 <zzo38> Once someone broadcasted a VERSION request in the middle of another message, and they say my client was the only one that responded.
21:22:05 <ski> Uplink : ok, sounds good
21:22:12 <zzo38> Uplink: There are many things you can learn Haskell. Including this channel.
21:22:16 <Uplink> ski: what do you know about?
21:22:37 <Uplink> ski: im looking for some Cambridge stuff
21:22:53 <Uplink> ski: where are you from?
21:23:30 <Uplink> zzo38: I imagine so...
21:23:40 <ski> if you do `/whois ski ski', then my domain name should give a clue
21:23:58 <zzo38> I like mathematics too, and use that too in Haskell. Including category theory.
21:24:09 * ski likes tea
21:24:18 <zzo38> But it is possible to program Haskell without those kind of mathematics; but I find it can be understood by mathematics.
21:25:47 <ski> (i'm not sure what "Cambridge stuff" you're looking for)
21:27:27 * Ralith sometimes uses tea in programming haskell
21:27:59 <Uplink> ski: Isn't there a close link between Cambridge and Haskell?
21:28:21 <ski> i'm not sure ?
21:28:48 <ski> (GHC is named after Glasgow ..)
21:30:24 <ski> Uplink : btw, if/when you're wondering about something (e.g. some code which isn't working, or which you think possibly could be improved), you could paste it at <http://hpaste.org/new/haskell>, and ask in here
21:30:34 <Uplink> ski: Hmm... ill go look for the lambda papers at school. Thanks for your help.
21:31:56 <Uplink> ski: not that i'd like to terminate this convo, because you seem helpful
21:32:40 <zzo38> How do I tell it to omit the warning for the lack of associated datatype declaration of a class instance?
21:33:07 <Uplink> ski: thanks
21:33:52 <ski> Uplink : many of us keep the irc client open most of the time in here, even when not actively looking at it
21:34:53 <Ralith> Uplink: SPJ works at Cambridge.
21:34:54 <Ralith> iirc.
21:34:57 <Ralith> so yeah, close link
21:35:20 <ski> @quote SPJ
21:35:21 <lambdabot> SPJ says: "If it compiles, it works."
21:36:43 <Uplink> ski: I think i'll do that too
21:37:44 <ski> Uplink : in irssi, you can type `/away' to mark yourself as away .. the same again to undo
21:37:48 <zzo38> Do you know the answer to my question? Is there any?
21:38:28 <greymalkin> Uplink, ski: although you need a message after the '/away' to mark away, and none afterwards to clear it
21:39:29 <ski> oh, i forgot that
21:39:37 <ski> zzo38 : on a superficial scan over the warning flags, i can see no such flag
21:41:07 <Uplink> ski: I'm going to log; it's getting kind of late here in NY. All the best.
21:41:34 <Uplink> ciao going to log
21:41:43 <ski> good night
21:44:37 <zzo38> The pastebin I like best is sprunge; no web browser required.
21:46:11 <ski> <paste.lisp.org> has emacs integration -- iirc <hpaste.org> also does
21:46:47 <zzo38> I don't know emacs; I just used the command-line program to redirect output to sprunge and input from sprunge
21:47:09 <zzo38> s/don't know emacs/don't know if sprunge can be use with emacs/
21:47:54 <ski> do you use vim ?
21:48:10 <ski> (.. or maybe you use your own editor as well ?)
21:48:12 <zzo38> At FreeGeek I do.
22:16:02 <zzo38> I managed to implement a restrictive category class, meaning the objects can be restricted.
22:16:51 <zzo38> So, I could make up the Kleisli category for Set.
22:22:29 <zzo38> data SKO x where { SKO :: Ord x => x -> SKO x; }; instance Eq (SKO x) where { SKO x == SKO y = x == y; }; instance Ord (SKO x) where { compare (SKO x) (SKO y) = compare x y; }; newtype SetKleisli x y = SetKleisli (SKO x -> Set (SKO y));
22:22:59 <zzo38> id = SetKleisli S.singleton; SetKleisli g . SetKleisli f = SetKleisli (S.fold S.union S.empty . S.map g . f);
22:25:41 <zzo38> Do you like this?
22:28:23 <ski> @type S.fold S.union S.empty .: S.map
22:28:24 <lambdabot> forall a a1. (Ord a, Ord a1) => (a1 -> S.Set a) -> S.Set a1 -> S.Set a
22:28:52 <ski> i'm not sure i like `Set (SKO y)'
22:30:15 <zzo38> I have also made the functions setKleisli and runSetKleisli which hide the SKO
22:30:16 <ski> given `SetKleisli x y' and `SetKleisli y z' we need to get `Ord y' and `Ord z' to implement `(.)'
22:30:49 <ski> i'm wondering whether it would be better to put the `Ord' constraints inside `SetKleisli'
22:31:11 <zzo38> It might work
22:31:21 <ski> hm, though i'm not sure if `id' works, then
22:31:47 <ski> @type S.singleton
22:31:48 <lambdabot> forall a. a -> S.Set a
22:33:59 <ski> hmm, i think my suggestion doesn't work
22:34:10 <greymalkin> Learn-you seems to ignore talking much about tail recursion -- does lazy execution make the focus on tail recursion mostly moot?
22:34:40 <ski> not completely
22:35:04 <ski> but often you can make an incremental process, instead of making a tail-recursive one
22:35:42 <zzo38> Putting the constraint inside SetKleisli doesn't work, for the reason you specified.
22:36:02 * ski nods
22:37:21 <greymalkin> Ah. I'm just so used to having tail recursion pounded into me from every other functional language I've learned that it's instict to use accumulators and reverse lists when I was done.
22:37:26 <zzo38> getSKO :: SKO x -> x; getSKO (SKO x) = x;   setKleisli :: (Ord x, Ord y) => (x -> Set y) -> SetKleisli x y; setKleisli f = SetKleisli (S.map SKO . f . getSKO);   runSetKleisli :: (Ord x, Ord y) => SetKleisli x y -> x -> Set y; runSetKleisli (SetKleisli f) = S.map getSKO . f . SKO;
22:37:46 <zzo38> bindSet :: (Ord x, Ord y) => SetKleisli x y -> Set x -> Set y; bindSet x y = runSetKleisli (x . setKleisli (const y)) ();   joinSet :: Ord x => Set (Set x) -> Set x; joinSet = runSetKleisli (setKleisli id . setKleisli id);
22:37:58 <greymalkin> It actually felt a bit dirty writing a fibonacci generator which prepended to the results of the recursive call...
22:43:10 <ski> the idea is that if you have an incremental producer, and a good consumer that "collapses" the data, it will run in constant space
22:43:18 <ski> > let produce n = fix (\loop i -> if i == n then [] else i : loop (i+1)) 0; consume ns = foldr (\n k sum -> k (sum + n)) id ns 0 in consume (produce 5)
22:43:19 <lambdabot>   10
22:43:53 <ski> > let produce n = fix (\loop i -> if i == n then [] else i : loop (i+1)) 0; consume ns = foldr (\n k sum -> k $! sum + n) id ns 0 in consume (produce 5)  -- actually this
22:43:54 <lambdabot>   10
22:44:56 <ski> > foldr (\a k as -> k (a : as)) id "abcd" []
22:44:57 <lambdabot>   "dcba"
22:45:12 <greymalkin> Huh... Um... tell me that lambdabot won't get caught in an infinite loop if there was no bound on that...
22:45:46 <parcs`> > last [1..]
22:45:50 <lambdabot>   mueval-core: Time limit exceeded
22:45:52 <ski> well, of course it will get stuck if it was to try summing an infinite list
22:46:23 <mm_freak_> absence: no, you can use the same wire as often as you want…  prefab wires use mempty for the sake of having an exception type as polymorphic as possible…  to override the inhibition value you can do this:  inhibitingWire <|> inhibit . pure myValue
22:46:34 <greymalkin> parcs`: I wasn't quite brave enough to try so soon
22:47:20 <ski> `last [1 ..]' should of course run in constant space
22:47:46 <ski> (or maybe a better term here is "bounded")
22:48:02 <mm_freak_> absence: also if 'do rec' makes your head spin, ArrowLoop is probably much worse =)
22:48:10 <greymalkin> space, yes. Time was the killer for lambdabot
22:48:16 <zzo38> I suppose you could make the Kleisli category of other monads that cannot be instance of the Monad class, too.
22:48:22 <greymalkin> Since last is a perfect consumer...
22:48:42 <ski> @type GHC.Base.build
22:48:43 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
22:49:03 <greymalkin> But something like 'reverse [1..]' would break the space bounding, as well as time.
22:49:08 <ski> (using that yields good producers)
22:49:20 <greymalkin> Am I getting it?
22:49:46 <ski> possibly
22:49:50 <mm_freak_> absence: you can refer to a value that is produced later, as long as the dependencies allow it
22:50:18 <greymalkin> cool.
22:50:38 <zzo38> edwardk: Why is the right and left Yoneda both called Yoneda in the library I have looked? Shouldn't the left Yoneda be called CoYoneda so that it can be given a different name?
22:50:58 <ski> (greymalkin : ooi, are you used to any of Scheme,Erlang,Clean,SML,OCaml,F# ?)
22:51:26 <edwardk> the problem is CoYoneda is kind of the wrong name, its a contravariant version, not co =)
22:51:28 <greymalkin> ski: Scheme, Erlang, and a bit of LISP
22:51:34 <edwardk> which is one reason why i switched
22:51:50 <ski> greymalkin : s/LISP/Common Lisp/ ?
22:51:58 <zzo38> edwardk: Then call it LeftYoneda
22:52:24 <edwardk> i don't like the fact that they both currently have the same name, but it becomes a bigger mess when i work with adjunctions to/from Hask^Op
22:52:36 <greymalkin> ski: Yes, but I wrote it as Scheme -- it was a short contract and they couldn't find anyone that could wrap their heads around the code.
22:52:43 <edwardk> to relate it to left kan extension?
22:53:01 <zzo38> edwardk: Yes
22:53:05 <edwardk> I really don't like that name
22:53:43 <edwardk> ultimately the contravariant yoneda lemma doesn't have many applications (ski's IORef example to the contrary) so its not a big deal
22:53:46 <greymalkin> So, while I might have been able to see this consumer/producer (which, as per your implication, is in LISP?) I didn't have time to when I had the chance.
22:53:47 <ski>   data CoYoneda f b = forall a. FMapIncl (a -> b) (f a)  -- this one ? isn't it also covariant ?
22:54:10 <zzo38> ski: I do mean that one. I called it the left Yoneda
22:54:35 <mgsloan> yokoneda
22:55:59 <zzo38> edwardk: One use is (Free (CoYoneda f)) where f is some GADT of actions which can be performed, then you can make the monad which does these actions and where these actions can also be manipulated on the monad too
22:56:01 * ski isn't that fond of using "left" and "right" in the names, either
22:56:46 <zzo38> ski: Well, you don't have to use the words "left" and "right" in the names of the types, but they are the right Yoneda and the left Yoneda, even if you call them something else.
22:56:55 <edwardk> stop the presses ski and i agree about naming for once ;)
22:57:51 <edwardk> gotta run
22:57:52 <ski> (e.g. i think something like "pre-inverse" and "post-inverse" is better than "right inverse" and "left inverse")
22:58:21 <zzo38> ski: OK, use that if you want
22:58:39 <zzo38> ski: What is IORef example to the contrary?
22:59:10 <ski> well, `CoYoneda IORef' is `IOReadRef' (and it's a functor, of course)
22:59:28 <ski> while `CoYonedaOp IOREf' is `IOWriteRef' (a covariant functor)
23:00:05 <ski>   data CoYonedaOp f a = forall b. FMapInclOp (b -> a) (f a)  -- something like that
23:00:16 <ski> er, sorry
23:00:31 <ski> `IOWriteRef' is of course a *contra*-variant functor
23:00:56 <NemesisD> hi all. im trying to track down a nasty memory leak in an app of mine. I'm running with +RTS -hm -p -RTS, i ran once with a small work set (used about 9% memory by the end), one with a large one, using about 26%, both claim a total alloc of only about 247MB
23:01:27 <ski> (and s/f a/f b/ -- i'm a bit tired atm)
23:02:17 <zzo38> And, does (Free (CoYoneda f)) meaningful to you too?
23:02:33 <ski> possibly, i'm not sure
23:02:39 <ski> hm ..
23:02:52 <ski> `Free f' is a monad, given that `f' is a functor, yes ?
23:03:00 <zzo38> ski: Yes.
23:03:05 <ski> right
23:03:24 <ski> i think it makes sense -- at least mostly
23:03:44 <zzo38> And, (CoYoneda f) is always a functor
23:03:59 <ski> yes :)
23:04:14 <ski> does the monad laws hold for `Free f' ?
23:04:20 <zzo38> (Although not always meaningful; for example, (CoYoneda Endo) is not meaningful)
23:04:22 <ski> iirc, they only hold for a quotient
23:04:43 <zzo38> ski: Yes, I think the monad laws do hold, but it is not a forward monad transformer.
23:04:52 <ski> (iirc, edwardk had an example with `CoDensity Endo' or something)
23:05:14 <zzo38> ski: Yes, (Codensity Endo) is list monad.
23:05:36 <ski>   data Free f a = Return a | JoinIncl (f (Free f a))  -- i need to see it in front of me
23:05:50 <zzo38> You even get list concatenation for free if the Plus class does not have Functor as a superclass
23:06:54 <ski>   fmap ab (Return a) = Return (ab a); fmap ab (JoinIncl fma) = JoinIncl (fmap (fmap ab) fma)
23:08:13 <ski>   return = Return; join (Return ma) = ma; join (JoinIncl fmma) = JoinIncl (fmap join fmma)
23:09:18 <ski>   join (return ma)  =  join (Return ma)  =  ma  -- ok
23:13:57 * greymalkin slaps forehead
23:14:22 <greymalkin> I just got to the $ operator -- one of my biggest question marks while I've been reading other code... and that's all it is.
23:14:28 <greymalkin> hehe
23:14:45 <ski> heh
23:14:56 <ski> now, please don't overuse it :)
23:15:33 <greymalkin> ski: I'm not allergic to ^e; I'll use it almost never
23:15:54 <ski> whence `^e' ?
23:16:09 <greymalkin> end-of-line in emacs?
23:16:23 <greymalkin> Also in most shells...
23:16:26 <ski> oh
23:16:57 * ski was suspecting it was some kind of bracket-match thing in some unknown editor
23:17:48 <greymalkin> No, but I miss '%' from Vim since I switched editors
23:18:34 <ski> what does that do in vim ?
23:19:21 <greymalkin> It moves to the matching brace of the one you're on.
23:19:35 <greymalkin> Handy once a paren has been closed to get back to the front.
23:20:56 * ski often uses `C-M-f',`C-M-b',`C-M-u',`C-M-d',`C-M-k',`C-M-SPC'
23:22:33 * greymalkin will now often be using those too.
23:24:33 <greymalkin> I only switched to emacs about a year ago, so I still have more than a bit to learn ;)
23:25:03 <ski> for sexpy code, paredit might be interesting
23:26:53 <ski> <http://mumble.net/~campbell/emacs/paredit.html>,<http://mumble.net/~campbell/emacs/paredit.el>
23:26:56 <gienah> greymalkin: for the % match-paren stuff: http://pastie.org/3969966
23:30:53 <greymalkin> ski, gienah: Awesome, thanks!
23:33:12 <ski> yw :)
23:38:49 <greymalkin> I'm definitely going to avoid '$'
23:39:18 <greymalkin> I hate thinking about operator precedence.
23:39:50 <otters> avoid $??
23:39:54 <otters> goodness me that is ambitious
23:42:10 * ski mostly uses it in the combination `foo x $ \y -> ..y..' (and not always then)
23:43:54 <greymalkin> My brain still prefers foo x (\y -> ..y..)
23:44:07 <greymalkin> Same number of characters (counting the space), explicitly clear.
23:44:18 <greymalkin> But I imagine it's a matter of taste.
23:44:33 <ski> the potential trouble there is if `..y..' is several lines long
23:46:23 <greymalkin> I admit that I am not capable of judging this case; being that I started learning Haskell about 25 hours ago.
23:48:34 * ski grins
