00:51:31 <Taneb> What do Alternative's some and many do?
00:57:04 <strager> @src some
00:57:04 <lambdabot> some v = some_v
00:57:04 <lambdabot>   where many_v = some_v <|> pure []
00:57:05 <lambdabot>         some_v = (:) <$> v <*> many_v
00:57:07 <strager> @src many
00:57:07 <lambdabot> Source not found. My pet ferret can type better than you!
00:57:23 <strager> many v = some v <|> pure []
00:58:02 <plat0> Am I right in thinking that Blaze does not ensure that the HTML5 it outputs is valid?
00:58:14 <arcatan> Taneb: i'm not sure if they make sense for all Alternative instances, but think for example applicative parser combinators
01:03:29 <Taneb> arcatan, thanks
01:03:40 <Taneb> strager, thanks
01:33:20 <solrize> Server not found
01:33:20 <solrize>       
01:33:20 <solrize>       
01:33:21 <solrize>       
01:33:21 <solrize>       
01:33:22 <solrize>       
01:33:24 <solrize>         
01:33:26 <solrize>         
01:33:28 <solrize>           Firefox can't find the server at www.realworldhaskell.org.
01:33:30 <solrize> ??
01:33:48 <mauke> less spam, please
01:34:02 <solrize> sorry about the blank lines
01:34:30 <ChristianS> solrize: works for me
01:34:31 <solrize> looks like the domain expired and bos has to straighten it out
01:34:36 <solrize> hmm
01:34:44 <solrize> dns propagation
01:34:54 <mauke> preflex: seen bos
01:34:54 <preflex>  bos was last seen on #haskell 2 days, 4 hours, 22 minutes and 30 seconds ago, saying: sure
01:35:22 <solrize> so does the book say anything about how to use ContT ?
01:45:48 <jonaskoelker> I can see www.realworldhaskell.org at 64.85.165.110---and book.[RWH].org works fine too
01:47:41 <jonaskoelker> no mention of ContT in any of the seven obvious candidate chapters
01:50:29 <solrize> jonaskoelker, thanks!
01:51:08 <jonaskoelker> solrize: welcome :)
01:57:52 <tobiassjosten> Are there any naming convention/tradition for Haskell projects?
01:59:42 <c_wraith> I think the best way to answer that is to just look through hackage and see what patterns leap out
01:59:43 <c_wraith> if any
02:02:01 <b_jonas> the convention is to use names unrelated to what the project does so people can't find the modules they should use
02:06:07 <jonaskoelker> e.g. I'm going to call my dice roller "hyperdeterminism" ;-)
02:06:26 <tobiassjosten> Haha. Gotcha.
02:08:25 <b_jonas> jonaskoelker: as in http://noentropy.org/ ?
02:09:38 <jonaskoelker> connecting...
02:09:58 <jonaskoelker> but as in xkcd.com/221 :-)
02:10:28 <jonaskoelker> maybe [connecting...] is the point?
02:13:01 <b_jonas> jonaskoelker: yes, xkcd.com/221 was already a very stale joke after noentropy.net existed and Knuth has asked whether 2 is a random number decades ago in his book
02:13:30 <jonaskoelker> ^_^
02:13:41 <jonaskoelker> you say stale, I say independently discovered :-P
02:14:27 <mxweas> isn't the xkcd joke based off the playstation jailbreak?
02:28:02 <earthy> mxweas: that is what I recall
02:28:21 <earthy> but it still goes to serve that computer science doesn't really learn its history
02:46:49 <jonaskoelker> what?  Time _isn't_ semilinear? O_o
02:47:50 <hiptobecubic> what is semilinear?
02:47:59 <jonaskoelker> a half-line
02:48:41 <hiptobecubic> jonaskoelker, probably should have guessed that...
02:53:45 <hpaste> jonaskoelker pasted “monad transformer trouble” at http://hpaste.org/68731
02:54:26 <jonaskoelker> anyone care to help me get my monads sorted out?
02:54:42 <jonaskoelker> (note: the name should be read as Sample', not sample-a-prime-number)
02:54:56 <jonaskoelker> ("the [module] name [...]")
02:56:47 <hpaste> jonaskoelker pasted “monad transformer error” at http://hpaste.org/68732
03:07:34 * hackagebot arithmoi 0.3.0.0 - Efficient basic number-theoretic functions.  Primes, powers, integer logarithms.  http://hackage.haskell.org/package/arithmoi-0.3.0.0 (DanielFischer)
03:28:31 <ClaudiusMaximus> jonaskoelker: seems there is no instance, as your error message says - either it's an oversight in the library, or it's not possible to write one safely - i don't know which is the case here, and i'm unlearned about monad transformers
04:00:58 <EvilMachine> hello guys… i just tried something: http://pastebin.com/CvNjMvMD … and: I get the following errors: http://pastebin.com/Bmf5VNtg
04:01:04 <mauke> The pastes CvNjMvMD Bmf5VNtg have been copied to http://hpaste.org/68734 http://hpaste.org/68735
04:01:05 <EvilMachine> (i’m still a noob. :)
04:01:33 <EvilMachine> I get that I have to force both to be the same actual type. But how?
04:01:57 <EvilMachine> And actually, I would *like* them to be of any type, as long as it’s that class.
04:02:08 <EvilMachine> (I know, I may misunderstand something :)
04:03:20 <EvilMachine> The goal is basically, to have an interface independent of the actual type, because i want different implementations to be able to attack themselves to the data structure.
04:03:32 <EvilMachine> attack=attach
04:04:46 <mrkronecker> I run ghc. Is it possible to list what dependencies a program I'm making uses? I seem to have lost track!
04:05:26 <EvilMachine> mrkronecker: in general, it’s possible for all executables. i just forgot the name of the tool. :/
04:05:30 <cebrian> Hi, I'm using Thrift in a project and I'd like that cabal takes care of recompiling sources when changed the service definition
04:05:38 <EvilMachine> mrkronecker: or do you mean, like, imports.
04:05:52 <cebrian> is there any way for cabal to run such generators automatically?
04:06:18 <ClaudiusMaximus> mrkronecker: make a .cabal file, then add dependencies as needed?  (maybe cabal init does that nowadays too?)
04:06:38 <mrkronecker> Oh, certainly. But that's what I'm trying to do, actually.
04:06:48 <mrkronecker> I'm trying to write my cabal file and add dependencies
04:06:59 <mrkronecker> But I don't have a solid idea of what my dependencies are!
04:07:26 <EvilMachine> mrkronecker: is the project big?
04:07:31 <ClaudiusMaximus> i tend to  cabal configure && cabal build, see what errors are spat out about hidden packages, repeat
04:07:45 <ClaudiusMaximus> but it's not really fun
04:07:47 <EvilMachine> mrkronecker: because you could certainly look up where your imports come from…
04:08:08 <mrkronecker> I'll just do that then. Thank you!
04:08:24 <alpounet> mrkronecker, when doing ghc --make of your project, if you pass it the -v option, don't you see ghc loading libraries while it builds your modules?
04:08:26 <EvilMachine> mrkronecker: or just try compiling on a system that has nothing installed, and watch it complain. ^
04:08:29 <EvilMachine> ^
04:08:43 <EvilMachine> alpounet: thanks. :)
04:08:57 <mrkronecker> alpounet: Ah! Excellent. That works. Thank you.
04:09:14 <alpounet> cool :)
04:09:14 <ClaudiusMaximus> cebrian: i never used Thrift, but i have used 'shake' for tracking dependencies in one project (but not for building; despite that being shake's purpose)
04:10:23 <cebrian> ClaudiusMaximus: shake is kind of SBT for Haskell?
04:10:40 <ClaudiusMaximus> sbt?
04:10:50 <cebrian> Scala's SBT
04:11:02 <ClaudiusMaximus> better read the docs here, i don't know scala or scala's sbt http://hackage.haskell.org/package/shake
04:11:58 <cebrian> ok, just one question about popularity, is shake intended as a replacement for cabal?
04:12:02 <ClaudiusMaximus> no
04:12:10 <bitonic> is there a concise, list comprehension-less version of this: [m | Just m <- ms]? sadly `(\(Just m) -> m) <$> ms)' doesn't work, since we're not in do notation
04:13:34 <b_jonas> bitonic: Data.Maybe.catMaybes
04:14:00 <HugoDaniel> hi
04:14:27 <ClaudiusMaximus> cebrian: the docs say "If ghc --make or cabal is capable of building your project, use that instead. Custom build systems are necessary for many complex projects, but many projects are not complex. "
04:15:03 <bitonic> b_jonas: right, thanks.
04:15:51 <cebrian> I thought generating code from a specification wasn't so strange at all. Thanks I'll take a look at shake
04:17:17 <ClaudiusMaximus> cebrian: there might be a way with cabal too, worth investigating (though last time i checked maybe a year ago cabal hooks were painful/awkward)
04:18:12 <cebrian> ClaudiusMaximus: Ok, so if you suspect that cabal should have something related I still prefer to stick with the official build system
04:18:18 <cebrian> I'll research the docs
04:23:11 <ClaudiusMaximus> (actually it seems i last checked 2 years ago, so it's probably improved)
04:25:12 <EvilMachine> what is the general meaning of this type of error messages: http://hpaste.org/68735
04:26:05 <Nafai> With threads in haskell, is it possible to say "Call this function in 1 second"?  Basically the equivalent of Python/Twisted's reactor.callLater(1, foo)
04:27:14 <companion_cube> Nafai: maybe you can create a new thread with threadDelay >> callfunction?
04:28:33 <Nafai> yeah, that looks like it
05:12:52 <bitonic> I needed this function in Control.Concurrent.Chan: https://github.com/bitonic/sockjs-haskell/blob/master/Chan.hs#L102
05:13:08 <bitonic> is it worth it to send a patch request, or are there any particular problems with that function?
05:14:30 <hpc> bitonic: perhaps you want getChanContents
05:16:46 <bitonic> hpc: no, that just produces an infinite lazy list
05:17:02 <bitonic> I want to stop when the chan is empty at that moment
05:17:05 <hpc> oh, hmm
05:17:09 <hpc> i see what you mean
05:19:30 <Phlogistique> is there any tutorial out there on computing time/space complexity of lazy programs?
05:20:02 <tazjin> > 1/0
05:20:03 <lambdabot>   Infinity
05:20:09 <hpc> Phlogistique: don't think so; it's rather tricky for haskell programs
05:21:16 <b_jonas> Phlogistique: how about the Chris Okasaki book?
05:21:38 <Phlogistique> Are there some general rules that can be applied? e.g. is the time complexity for a non-strict program always lesser than the time complexity for the same program evaluated in a strict way?
05:21:47 <Phlogistique> b_jonas: purely functional data structures?
05:21:53 <b_jonas> Phlogistique: yes, that book
05:22:15 <b_jonas> I should borrow it again and try to understand more than last time
05:24:14 <b_jonas> Phlogistique: but it doesn't really answer your question
05:24:22 <b_jonas> maybe you need a different book, but I don't know which one
05:28:05 <Phlogistique> b_jonas: thanks
05:39:33 <ClaudiusMaximus> bitonic: i'd find a drainChan very useful, as long as there's a proof that it never blocks (compare with http://hackage.haskell.org/trac/ghc/ticket/4154 ) -- at the moment i keep a list in an mvar instead of using chans
05:55:41 <statusfailed> Is cabal install --reinstall world a bad idea?
05:56:39 <byorgey> probably.  Why do you want to do that?
05:56:44 <statusfailed> also, is setting "shared: True" the same as "--enable-shared"? because compiling with --enable-shared fails for me, and the other doesn't
05:56:55 <statusfailed> byorgey: i'm trying to use Hint, and it complains about needing mtl with "shared" enabled
05:57:55 <byorgey> hmm, I don't know, I've never seen that before
05:58:25 <statusfailed> I get this exact error when trying to compile a program using hint: http://ideone.com/2nxI9
05:59:07 <statusfailed> oh, i've been using runhaskell, maybe that's the problem
05:59:16 <statusfailed> (nope)
06:03:59 <byorgey> statusfailed: that error doesn't say anything about needing mtl with "shared" enabled
06:04:31 <byorgey> oh, that error is from ideone
06:04:40 <byorgey> statusfailed: you didn't seem to include an error message with that paste
06:05:21 <statusfailed> byorgey: hang on, i'll paste the error i'm getting, sorry
06:07:27 <osa1_> does anyone here know some examples of using alex and parsec together?
06:07:31 * mcstar feels he is too stupid for haskell
06:07:57 <chu> I am too!
06:08:57 <mcstar> i wrote a functional prefix trie some time ago, it worked, it was easy, and it was like 8 times slower to construct, than the c++ one, now i thought id write a mutable one, in IO, and i just suck at it
06:09:22 <ohgodno> hallo, i am reading about tail recursion on haskell.org. my question is: how should i understand t0 and other variants of it in sentances such as t is "\var -> t0" and f occurs tail recursively in t0; ?
06:09:45 <mcstar> it consumes a shitload of memory, it is incredibly slow, and i cant even run the original problem size
06:10:35 <byorgey> mcstar: I would hardly conclude that you are too stupid for haskell.  predicting and controlling efficiency + memory usage can be quite tricky.
06:11:07 <byorgey> ohgodno: I think there t0 is just being used to stand for an arbitrary expression
06:11:12 <mcstar> thanks for cheering me up
06:11:34 <ohgodno> oh i see, thanks mr byorgey
06:11:49 <hpaste> kamaji pasted “Error compiling hint” at http://hpaste.org/68739
06:11:54 <byorgey> mcstar: does it at least give correct answers?
06:11:57 <statusfailed> byorgey: There's the error i'm seeing
06:12:19 <statusfailed> Oddly, my .cabal/config file contains "shared: True", but if I omit the --enable-shared it compiles fine!
06:12:27 <statusfailed> (doesn't work though)
06:12:55 <mcstar> byorgey: yes, i think it did(now i broke it, but it was ok before)
06:13:11 <byorgey> statusfailed: that's the error you're seeing when trying to reinstall hint.  what about the error that led you to believe you need to do that in the first place?
06:14:02 <byorgey> mcstar: in that case you are clearly not too stupid for haskell =)
06:14:51 <statusfailed> byorgey: that was this one: Could not find module `Language.Haskell.Interpreter'
06:14:54 <statusfailed> I had to google it
06:16:04 <byorgey> statusfailed: that indicates to me that you just need to  'cabal install hint'.  Why do you think you need to --enable-shared?
06:16:18 <jjl_> Hi, I'm having difficulty using records inside of modules. I keep getting an error about things I think I've imported. http://pastebin.com/KmVqsGxm <-- very short code
06:16:20 <mauke> The paste KmVqsGxm has been copied to http://hpaste.org/68740
06:16:23 <statusfailed> byorgey: google told me to :)
06:16:32 <statusfailed> byorgey: I already tried cabal install hint, and it didn't help
06:16:46 <byorgey> statusfailed: link?
06:17:31 <statusfailed> byorgey: http://stackoverflow.com/questions/8701583/building-a-haskell-interpreter-hint-as-dynamic-library-useable-from-c-miss
06:18:30 <byorgey> jjl_: can you paste the error as well?
06:19:12 <byorgey> statusfailed: and are you trying to call Haskell from C or C++ or whatever that question is talking about?
06:19:32 <byorgey> statusfailed: and did you get the error "Perhaps you haven't installed the "dyn" libraries for package `hint-0.3.3.2'"  ?
06:19:39 <hpaste> jjl_ annotated “pastebin.com/KmVqsGxm” with “pastebin.com/KmVqsGxm (annotation)” at http://hpaste.org/68740#a68741
06:19:56 <statusfailed> byorgey: no, but it was one of only two hits on google
06:20:10 <byorgey> statusfailed: well, then I don't think that applies.
06:20:24 <byorgey> statusfailed: can you please paste the output of 'ghc-pkg list'?
06:20:28 <jjl_> byorgey: it seems to point to a scoping thingy that confuses me
06:20:42 <byorgey> jjl_: oh, you are only exporting the type Crit from the module Crit
06:20:57 <byorgey> jjl_: if you want to export its constructor too, you have to write  module Crit ( Crit(..) )
06:21:11 <byorgey> or  module Crit ( Crit(Crit) )
06:21:21 <statusfailed> byorgey: I have several broken packages, and the list is quite long, should I still paste it?
06:21:27 <byorgey> you have made things extra fun for yourself by using the same name for three different things =)
06:21:34 <byorgey> statusfailed: yes please
06:23:34 <jjl_> byorgey: i went for Crit(..) and it still gives the second error. I also tried to export 'name' and it remains the same
06:23:45 <hpaste> kamaji pasted “ghc-pkg list summary ” at http://hpaste.org/68742
06:23:53 <ocharles> Hi, I'm considering writing a "HdbcT" monad transformer, and I was wondering if people think that's sensible
06:23:56 <stj> fmap (+2) ((,) 2) 5 -- what's wrong with this?
06:24:06 <statusfailed> byorgey: pasted ^
06:24:09 <ocharles> idea being you can call Hdbc actions from within anything that has an instance of HdbcT
06:24:17 <byorgey> jjl_: did you try  C.name ?
06:24:32 <stj> I've been trying to find definition of instace Functor ((,) e) but couldn't find it? Hoogle didn't help out :/
06:24:55 <jjl_> byorgey: that fixes it. but why on earth when it's a record do i need to qualify the field name there?
06:25:13 <jjl_> i know i need to when retrieving the data, but it seems silly when setting it
06:25:18 <byorgey> jjl_: because Haskell records are dumb
06:25:20 <hpc> ocharles: it could be sensible, if you are really sneaky about it
06:25:38 <byorgey> stj: needs more parentheses
06:25:41 <hpc> ocharles: all i think you need though is (MonadReader Connection m, MonadIO m) though
06:25:53 <byorgey> stj: fmap (+2) (((,) 2) 5)
06:25:55 <jjl_> byorgey: *nod*. I've been trying to get my head around data-lens but i'm failing miserably
06:26:21 <hpc> ocharles: the tricky part is that you can't make an IO transformer
06:26:31 <statusfailed> jjl_: I had a list of useful explanations of it, would you like them?
06:26:37 <jjl_> statusfailed: please :)
06:26:44 <ocharles> hpc: can't I just require that the base is MonadIO and liftIO?
06:26:47 <hpc> so what you'll probably end up with instead of a transformer is a monad you can stick at the bottom of the stack
06:26:52 <stj> byorgey: oh I see what's going on, thanks :)
06:27:02 <statusfailed> jjl_: http://twanvl.nl/blog/haskell/overloading-functional-references http://www.nadineloveshenry.com/haskell/lensExamples.html http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio
06:27:08 <hpc> ocharles: i figure you would want to keep track of the connection to the db as well
06:27:22 <jjl_> statusfailed: saw the last two, still rather confused
06:27:22 <statusfailed> jjl_: there's 3 urls there, sorry- I'm not sure if they were directly applicable to data-lens, but they might help!
06:27:26 <ocharles> hpc: yea, or a db pool
06:27:32 <statusfailed> jjl_: the first one is pretty good
06:28:04 <jjl_> statusfailed: looks it already :) i'm confused about how i might update nested structures with it across STM though
06:28:19 <ocharles> I was thinking my HdbcT would just be a ReaderT with a DB connection as its environment and a requirement that the base is MonadIO
06:29:05 <statusfailed> byorgey: I think i'm just going to delete my .ghc and .cabal and retry everything
06:29:42 <byorgey> statusfailed: no need to delete .cabal
06:30:07 <statusfailed> byorgey: doesn't it keep a record of what's installed?
06:30:20 <byorgey> statusfailed: no. It just has cached package downloads
06:30:34 <byorgey> .ghc is where the package database is kept
06:30:34 <statusfailed> byorgey: oh, ok! thanks
06:30:37 <statusfailed> that should save some time!
06:30:42 <byorgey> indeed =)
06:36:08 <hpc> is there an explanation of FRP that doesn't describe it as archery in a windtunnel, and has actual examples?
06:38:46 <hpaste> mcstar pasted “mutable prefix trie” at http://hpaste.org/68743
06:40:30 <mcstar> and this is an accompanying profiling http://imgur.com/AAw1Z
06:40:48 <mcstar> if anyone would be so kind and take a look at it
06:42:37 <yukifag> Hello everyone. I wonder is there more elegant way of integer division than (fromIntegral a)/(fromIntegral b)? I hoogled for some (Integral a, Real b) => a->a->b function but without success.
06:42:55 * hackagebot oi 0.1.0 - Purely Functional Lazy Interaction with the outer world  http://hackage.haskell.org/package/oi-0.1.0 (NobuoYamashita)
06:44:02 <hpc> :t (/) `on` fromIntegral
06:44:03 <mauke> yukifag: that's not integer division
06:44:03 <lambdabot> forall b a. (Fractional b, Integral a) => a -> a -> b
06:44:04 <statusfailed> byorgey: Welp, that worked. Thanks for your help :)
06:44:08 <hpc> :t div
06:44:09 <lambdabot> forall a. (Integral a) => a -> a -> a
06:44:18 <mcstar> yukifag: you want floor?
06:44:48 <hpc> yukifag: you either want to define it once as (//) or something, or just use div
06:45:07 <yukifag> I need some function that gets two Ints and returns Real.
06:46:42 <yukifag> Maybe I'm wrong with 'integer division' term.
06:46:44 <mcstar> then what hpc said is correct
06:46:51 <mcstar> yeah, it isnt int div
06:48:56 <hpc> in any event, Real doesn't have enough of an API to support division
06:49:07 <hpc> the best you're getting is a Fractional result
06:49:15 <mauke> @src Real
06:49:15 <lambdabot> class  (Num a, Ord a) => Real a  where
06:49:15 <lambdabot>     toRational      ::  a -> Rational
06:49:38 <yukifag> hpc: Ok.
06:51:34 <mcstar> any ideas why my code is soo massively inefficient? (it was the same with Data.Array.IO, not just with vector)
06:52:51 <mcstar> Productivity   4.6% of total user, 4.6% of total elapsed, sounds terribly bad also
06:52:55 * hackagebot ADPfusion 0.0.1.1 - Efficient, high-level dynamic programming.  http://hackage.haskell.org/package/ADPfusion-0.0.1.1 (ChristianHoener)
06:53:11 <hpc> mcstar: for starters, fromList' = insert em
06:53:21 <hpc> er
06:53:30 <hpc> fromList' = mapM_ (insert em)
06:53:47 <hpc> though that probably isnt' what makes it slow
06:53:49 <mcstar> i used that too, thats not the problem
06:54:58 <yukifag> Anyway hoogle is silent about  (Integral a, Fractional b)=>a->a->b. It's not that long to reinvent this wheel but I don't want.
06:55:07 <mcstar> for comparison, c++ version runs in 2.5 seconds, thats 210K words, this one runs in a bit more time, but with 10K words
06:57:56 * hackagebot Nussinov78 0.0.1.2 - Nussinov78 using the ADPfusion library.  http://hackage.haskell.org/package/Nussinov78-0.0.1.2 (ChristianHoener)
06:57:57 <mcstar> hpc: that changed dropped productivity from 4.6 to 4 percent :(
06:58:02 <mcstar> -d
07:04:03 <Saizan> mcstar: make your PFTrie have strict fields
07:04:26 <Saizan> mcstar: change Just $ to Just $!
07:04:45 <mcstar> Saizan: where do i put the ! in a record syntax?
07:05:00 <Saizan> mcstar: and WM.write (..) (..) to WM.write (..) $! (..)
07:05:07 <rwbarton> before the type
07:05:13 <mcstar> k
07:05:16 <Saizan> mcstar: !Bool
07:05:49 <mcstar> i tried putting it in front of the field name, silly me
07:06:11 <Saizan> also, you should probably swap line 24 and 25
07:06:32 <Saizan> unless that breaks correctness for some reason i'm not seeing
07:06:50 <ClaudiusMaximus> Saizan: those changes reduced productivity from 4.6 to 1.2% for me
07:06:57 <Saizan> if you swap them you get go to be tail-recursive
07:07:15 <mcstar> Saizan: yeah i see that, and i think it should be corrrect
07:07:18 <rwbarton> it would affect the multithreaded semantics but it's not clear that either version is "correct"
07:07:26 <rwbarton> in the presence of multiple threads
07:09:03 <ClaudiusMaximus> > (ord maxBound, 256) -- also, Char is unicode
07:09:04 <lambdabot>   (1114111,256)
07:09:31 <mcstar> that shouldnt matter
07:09:36 <Saizan> ClaudiusMaximus: even swapping 24 and 25?
07:09:43 <mcstar> i use a vector of 256 elements
07:09:50 <mcstar> Saizan: no change in speed
07:10:36 <ClaudiusMaximus> Saizan: yes
07:11:45 <ion> Huh. I darcs cloned lambdabot: Warning: CRC errors found. These are probably harmless but should be repaired.
07:12:10 <ion> darcs gzcrcs --check didn’t find anything wrong in the clone.
07:12:14 <hpaste> mcstar pasted “to test the trie” at http://hpaste.org/68744
07:12:53 <mcstar> http://liquid-phynix.minus.com/lYwJXSlqce8sq
07:13:05 <mcstar> this is the link to the dictionary file
07:13:27 <Saizan> how big is n?
07:14:31 <mcstar> 10K
07:14:58 <mcstar> http://liquid-phynix.minus.com/mdEhkijBO/
07:15:05 <mcstar> this link will actually work
07:15:18 <mcstar> minus sometimes gives wrong links...
07:16:46 <Saizan> keeping 10K lines as [String] in memory is not going to be optimal, but the profile still suggests they are not an important factor
07:17:02 <ClaudiusMaximus> does the C++ algorithm also allocate a whole new array block to store possibly 1 bit of data at the end of a word?
07:17:53 <Saizan> also, you should "return $! b && b'", but the number of boxed arrays is probably what's putting pressure on the gc
07:20:49 <mcstar> ClaudiusMaximus: the c++ class has a bool member, and a vector<PFTrie> of 256 elements
07:21:32 <mcstar> and i fully initialize it with NULL
07:21:39 <mcstar> so thats actually a PFTrie*
07:22:09 <hpaste> mcstar pasted “prefix trie c++” at http://hpaste.org/68745
07:22:48 <mcstar> Saizan: the prefix trie itself does not store strings
07:23:11 <mcstar> it stores other prefix tries at given indices of the array
07:24:44 <Saizan> mcstar: i mean the "words" in your testing code
07:25:10 <roconnor> @type
07:25:11 <lambdabot> <no location info>: not an expression: `'
07:25:21 <roconnor> @type \f x -> (.) <$> f <*> x
07:25:22 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Applicative f1) => f1 (a -> b) -> f1 (f a) -> f1 (f b)
07:25:39 <Saizan> mcstar: btw !words = .. is just forcing the first cons cell of the list, i.e. doing almost nothing
07:26:06 <mcstar> Saizan: yeah, i just put it there for good luck, i read about WHNF since then
07:26:12 <roconnor> @type \f x -> (Prelude..) <$> f <*> x
07:26:13 <lambdabot> forall b c a (f :: * -> *). (Applicative f) => f (b -> c) -> f (a -> b) -> f (a -> c)
07:27:58 <mcstar> Saizan: does my code resemble idiomatic imperative hasekell code at all? how would you go about writing a mutable trie like this?
07:28:34 <mcstar> at this point im absolutely out of clues
07:28:55 <mcstar> maybe i should redo it in ocaml
07:29:11 <rwbarton> I think spending 1-2k per node is just going to cause you unrecoverable problems...
07:29:25 <Saizan> well, I'd tend not to
07:30:47 <Saizan> aren't there optimized immutable tries on hackage?
07:31:08 <mcstar> the point of the exercise was to familiarize myself with haskell
07:31:17 <mcstar> i dont need that data structure at all
07:32:07 <mcstar> http://hpaste.org/68330 this is an old paste of mine, the immutable version
07:32:16 <Saizan> if I were to need something mutable of medium-big size I'd stick to unboxed stuff, btw
07:33:06 <kallisti> I think my Haskell code and the Java server I'm talking to speak different kinds of base64 encoding.
07:33:16 <kallisti> that's the only explanation that makes sense.
07:33:17 <mcstar> but you can only store primitive types in an unboxed vector, right?
07:34:02 <mcstar> rwbarton: 1-2 kbytes per 256-element vectors?
07:34:10 <Saizan> mcstar: or products of them
07:34:30 <rwbarton> 256 * [4 (32-bit) or 8 (64-bit) bytes per pointer] = 1-2 k
07:34:30 <Saizan> mcstar: or anything you can reasonably convert to a product and back
07:35:27 <mcstar> rwbarton: right, but i guess haskell uses much more space
07:35:29 <rwbarton> 256 is not such a small number
07:36:31 <mcstar> Saizan: im sorry, i dont follow you, you mean a product type?
07:36:59 <Saizan> mcstar: tuples, essentially
07:37:11 <hpaste> jonaskoelker pasted “anyone care to help me lift getRandomR through my monad stack?” at http://hpaste.org/68746
07:37:36 <mcstar> i still dont see where does help me
07:37:36 <rwbarton> mcstar, why do you think that? i'm looking at http://imgur.com/AAw1Z and it seems pretty consistent with 1-2 k per node * 10000 words * a few "distinct" letters per word
07:37:51 <rwbarton> mcstar, it doesn't help you unless you are going to effectively do your own memory management
07:38:14 <jonaskoelker> anyone care to help me sort my monad headache out?
07:38:19 <rwbarton> or you can use malloc :)
07:39:10 <mcstar> rwbarton: a prefix trie does a lot of sharing
07:39:17 <mcstar> you cant just multiply with 10K
07:39:24 <rwbarton> i understand
07:39:34 <rwbarton> you could just count yourself how many nodes are in your trie
07:39:38 <rwbarton> i can only estimate
07:39:41 <mcstar> yes
07:41:09 <kallisti> does anyone know what the first argument to the Socket constructor is?
07:41:41 <rwbarton> if you run with -A100m you might get much better performance
07:41:49 <mcstar> and the problem doesnt scale well, 10K: 2.7s, 20K: 8s, 40K: 26s
07:41:59 <rwbarton> sort of cheating though
07:42:19 <rwbarton> oh do I mean -A...
07:42:40 <mcstar> -A helps
07:44:04 <mcstar> it is still quite bad though
07:44:29 <mcstar> 3 secs for the loading phase in the 40K case
07:45:19 <byorgey> jonaskoelker: err, what is the type of sample?
07:45:41 <ohgodno> correct me if i'm wrong, but a naive factorial function is NOT tail recursive, right ?
07:45:57 <mcstar> now i could load 100K words, in 18 secs, but productivity is down to -0.3%
07:46:10 <mcstar> ohgodno: *
07:46:24 <byorgey> ohgodno: correct.
07:46:25 <jonaskoelker> if I comment out the getRandomR line, "sample :: (MonadReader (Map Varname [Number]) m, MonadError [Char] m) => Exp -> m [Number]"
07:47:18 <byorgey> jonaskoelker: and getRandomR is from the MonadRandom package, right?
07:47:32 <jonaskoelker> afai[k/ct], yeah
07:48:38 <byorgey> jonaskoelker: and with the getRandomR line?
07:48:49 <byorgey> do you get an error, or you get some other type?
07:48:59 <jonaskoelker> error
07:49:34 <byorgey> jonaskoelker: can you please paste the error too, then?
07:49:35 <ohgodno> byorgey: thanks man
07:49:41 <hpaste> jonaskoelker pasted “the error” at http://hpaste.org/68747
07:49:55 <jonaskoelker> I knew you were going to say that :-)
07:50:11 <byorgey> well then why didn't you paste it before? =P
07:50:30 <jonaskoelker> slow browser =)
07:50:33 <mcstar> rwbarton: for 219153 words, there are 2237728 nodes in the full trie(i get this from the c++ version, since it was easier to do)
07:50:45 <byorgey> I see, the problem is that the MonadRandom package does not declare a MonadRandom instance for ErrorT
07:51:37 <mcstar> thats ~4.2GB
07:51:50 <jonaskoelker> so... I have to declare one myself?
07:52:03 <jonaskoelker> or perhaps reshuffle my monad sandwhich?
07:52:33 <byorgey> jonaskoelker: reshuffling will not help, because then you will end up needing a MonadError instance for RandT (which is not declared either =)
07:53:09 <ohgodno> hmm, is tail recursion then faster than normal recursion, seeing that it seems to be iterative rather than recursive ?
07:53:21 <byorgey> jonaskoelker: you can either use  lift (getRandomR (1,nv))  or declare an instance of MonadRandom (ErrorT ...)  yourself
07:53:24 <ohgodno> is tail recursion at all recursion o_0 ?
07:53:32 <byorgey> jonaskoelker: declaring your own instance is very easy
07:53:43 <ibid> ohgodno: tail recursion absolutely is recursion
07:53:49 <jonaskoelker> byorgey: how'd that look?
07:53:56 <byorgey> jonaskoelker: check out the instances for StateT, ReaderT etc. defined in http://hackage.haskell.org/packages/archive/MonadRandom/0.1.6/doc/html/src/Control-Monad-Random.html
07:54:00 <jonaskoelker> thanks for the lift hint, I was probably looking for something like that
07:54:02 <byorgey> just copy them and change to ErrorT
07:54:14 <Saizan> ohgodno: tail recursion is faster if you are using the result of the recursive call in a strict way
07:54:23 <byorgey> making an instance essentially just automates the process of adding a call to 'lift', so you don't have to do it manually
07:54:44 <byorgey> ohgodno: it really has less to do with speed and more to do with memory use.
07:54:54 <ohgodno> hmm, tail recursion seems to be a recursion of if statements or conditions, rather than a recursion of operations
07:55:09 <jonaskoelker> byorgey: so either lift at call site, or put lift in a can and call it an instance? :-)
07:55:15 <byorgey> jonaskoelker: right =)
07:55:25 <byorgey> ohgodno: that doesn't really make sense
07:55:27 <ohgodno> i'm guessing naive recursions use more memory but are easier on the cpu, and tail recursions use less memory, but use more cpu
07:55:58 <jonaskoelker> oh cool.  An idea I've fiddle with: I have this simple expression tree for dice rolling, and I want to do two operations on it: 1. sample distribution, 2. compute distribution [...]
07:56:02 <byorgey> ohgodno: it really doesn't have anything to do with the CPU.
07:56:03 <mcstar> no
07:56:14 <ohgodno> then i'm reading too much into the concept
07:56:19 <byorgey> ohgodno: also, tail recursion is not really that important of a concept in Haskell, because of laziness.
07:56:19 <ohgodno> i'll calm down and give this another read
07:56:39 <ohgodno> hmm
07:56:39 <mcstar> it is much more important in scheme or common lisp
07:56:41 <jonaskoelker> byorgey: do you think it would be feasible and/or a good idea to define the semantics in terms of a monadic traversal, then supply one or the other monad (sandwich) depending on which operation I'm doing?
07:57:13 <ohgodno> does haskell really remove all need for tail recursion?
07:57:37 <byorgey> jonaskoelker: sounds reasonable
07:57:44 <jonaskoelker> ohgodno: no, reverse [1..] will stack overflow, you better make that tail recursive =)
07:57:51 <byorgey> ohgodno: it replaces the need for tail recursion with a need for something else
07:58:18 <jonaskoelker> (that was a joke, btw...)
07:58:29 <ohgodno> oh i see o_0
07:58:30 <ibid> more to the point, in haskell tail recursion is generally not special
07:58:37 <ohgodno> byorgey: what's that something else? o_0
07:58:38 <ibid> like it is in other languages
07:58:50 <ohgodno> ibid: i see
07:59:11 <byorgey> ohgodno: the important concept is called 'guarded recursion'
07:59:40 <ohgodno> yeah i\m getting a permission error on that section of the website o_0
07:59:44 <byorgey> ohgodno: which is when all recursive calls occur as arguments to one or more data constructors
07:59:48 <ohgodno> i'll google another version
07:59:55 <ohgodno> hmm
08:00:09 * byorgey should really make a Haskell wiki page about that, it seems to keep coming up
08:01:01 <ohgodno> it would be nice ;>
08:01:03 <ohgodno> :>
08:01:40 <mcstar> i never heard about guarded recursion before
08:02:38 <mcstar> Saizan: it seems there is an -A -H value, when the speed is optimal, around 800M
08:02:50 <mcstar> not that totally bad
08:02:52 <ohgodno> i think i am starting to understand
08:03:00 <ohgodno> : is an example of guarded recursion
08:03:17 <mcstar> Saizan: could you tell me more about an unboxed version?, how could i implement that?
08:03:26 <hpc> guarded recursion is what other languages would call "recursion"
08:03:36 <hpc> unguared recursion is what other languages would call "stack overflow"
08:03:44 <hpc> or "infinite loop"
08:04:04 <mcstar> hpc: Unguarded Recursion, what a catchy phrase for a site
08:04:27 <jmcarthur> oh it's mcstar
08:04:35 <mcstar> jmcarthur: hey!
08:04:44 <jmcarthur> going for some haskell now, eh?
08:04:49 <copumpkin> lispy: you know, twitter allows owners of a trademark to request inactive twitter handles, and twitter.com/galois is inactive
08:04:51 <mcstar> for some time, yes
08:05:06 <jmcarthur> well i knew that you knew some but didn't know if it was an ongoing pursuit
08:05:31 <mcstar> jmcarthur: im considerably better since we last spoke
08:05:48 <jmcarthur> awesome
08:08:23 <d-snp> hey guys, I'm looking for a function with this description: Integral -> [Word8]
08:08:32 <d-snp> how would I find it if it exists?
08:09:57 <copumpkin> there are many choices to make when writing that function, assuming you mean Integral i => i -> [Word8]
08:10:11 <copumpkin> or at least two
08:10:15 <d-snp> I have a bunch of data, Word16, Word32, ByteString, and I want to convert them all to [Word8] so I can feed them to Data.HMAC
08:10:20 <ocharles> d-snp: hoogle and hayoo
08:10:49 <rwbarton> well ByteString to [Word8] is "unpack"
08:10:55 <rwbarton> for the others you could use the binary package
08:10:59 <rwbarton> to convert them to ByteString
08:11:36 <d-snp> hmm
08:12:02 <Saizan> mcstar: since you've arrays within arrays it wouldn't be easy to do an unboxed version, i think
08:12:05 <d-snp> thanks that will do fine
08:12:26 <Saizan> mcstar: i guess this is what rwbarton was pointing to with his cp,,emt about manual memory management
08:13:05 * d-snp moves Saizan's right hand one position to the left
08:13:14 <mcstar> you mean, make an unboxed vector of some pointer type, and store the pointers of the newly created tries?
08:13:27 <jmcarthur> mcstar: what are you trying to do?
08:13:44 <Saizan> d-snp: thanks
08:14:04 <mcstar> jmcarthur: i was implementing a prefix trie, and found it to be of inferior performance compared to the c++ version
08:14:11 <mcstar> a mutable one
08:14:30 <jmcarthur> how inferior?
08:14:37 <mcstar> but it seems, it gets better if haskell allocates bigger chunks of memory
08:14:51 <mcstar> well, initially like a factor of 20
08:15:55 <jmcarthur> by allocating bigger chunks of memory do you mean tweaking GC settings?
08:16:01 <mcstar> Saizan: another thing, maybe i could preallocate some huge vector, and the nodes would only contain offsets in that big array
08:16:11 <mcstar> jmcarthur: i mean -A -H rtsopts
08:16:17 <jmcarthur> yeah i see
08:16:31 <jmcarthur> that tends to help when you are doing something that uses a fair bit of memory, i think
08:16:43 <rwbarton> mcstar: yes that is the kind of manual memory management i had in mind
08:16:46 <jmcarthur> -H does at least. i use -A much less often
08:17:15 <ohgodno> so a tail recursion then is a careful recursive call that terminates on a non recursive element while passing the main calculation as an accumulator value to itself ?
08:17:30 <mcstar> ok, now i have a better picture of the problem, which turns out doesnt really exist, thanks guys
08:19:01 <rwbarton> mcstar: or another thing you could try is have a 256-element mutable array of indexes into another (maybe mutable) array of pointers that's stored in the node
08:19:18 <rwbarton> that way you at least aren't storing 250 pointers to Nothing in every node
08:20:44 <mcstar> so that the index can be unboxed?
08:21:55 <Saizan> ohgodno: it seems you bolted together different concepts there
08:24:06 <mcstar> afaik tail recursion is when you dont do anything with the return value, and you can simply rebind arguments of the recursion(ofc, in the end you will return the return value)
08:25:24 <hpaste> ClaudiusMaximus annotated “prefix trie c++” with “prefix trie c++ (annotation)” at http://hpaste.org/68745#a68749
08:25:39 <Saizan> ohgodno: http://www.haskell.org/haskellwiki/Tail_recursion <- this page seems to get it mostly right, excet that even in haskell tail-recursion is a big deal if you are processing the result of the recursive call with a strict function
08:26:24 <Bob_> Hey guys.. ih have a quick question
08:26:55 <mcstar> ClaudiusMaximus: Productivity  94.3% whoa, congratulations!
08:27:10 <mcstar> ill give a good hard read to that code
08:27:23 <mcstar> are you loading the whole dictionary?
08:27:23 <Bob_> I have some code with Severl main modules which are in different subfolders. How can i import something from 1 main module into another with this subdfolders?
08:28:48 <mcstar> ClaudiusMaximus: i see, 90K words
08:29:27 <ClaudiusMaximus> mcstar: i don't suggest you write code like that in Haskell, i was just bored...
08:29:40 <mcstar> ClaudiusMaximus: im glad you were bored
08:30:20 <mcstar> i want to put this topic aside for now, but i will come back to your code
08:30:25 <jmcarthur> it looks only slightly worse than the C++ version
08:30:28 <jmcarthur> :)
08:31:13 <d-snp> I feel so trapped in do notation, I don't understand what I'm doing at all
08:31:15 <Saizan> seems like harrop could still troll us about array performance :)
08:31:45 <mcstar> lol, i read his F# for scientists, and am readin his ocaml for scientist
08:31:48 <mcstar> s
08:32:09 <jmcarthur> harrop is well-known for trolling haskellers :)
08:32:55 <copumpkin> not just haskellers :)
08:33:06 <Peaker> d-snp, why don't you avoid "do" notation for a bit until you get what's behind it then?
08:33:35 <Peaker> Harrop taught me that I am a team of experts
08:33:58 <mcstar> harrops ocaml code looks a bit horrendous, but thats might be ocaml's fault
08:34:31 <mcstar> gtg now
08:34:38 <jmcarthur> one can write reasonable code in ocaml sometimes
08:35:08 <jmcarthur> oddly enough, that only lasts until you start thinking about performance
08:35:24 <ohgodno> i think once one is accustomed to haskell code, everything else starts to look overworked and strangely twisted
08:35:30 <hpc> @remember Peaker
08:35:30 <lambdabot> Incorrect arguments to quote
08:35:35 <hpc> @remember Peaker Harrop taught me that I am a team of experts
08:35:35 <lambdabot> Nice!
08:35:43 <ohgodno> lol
08:35:55 <d-snp> lol Peaker, I wish I could
08:36:01 <jmcarthur> harrop flatters us as much as he trolls us ;)
08:36:15 <jmcarthur> d-snp: why can't you?
08:36:17 <roconnor> @seen edwardk
08:36:18 <lambdabot> Unknown command, try @list
08:36:23 <roconnor> preflex: seen edwardk
08:36:23 <preflex>  edwardk was last seen on #haskell 1 day, 18 hours, 44 minutes and 54 seconds ago, saying: since it rules out a lot of useful reader-like monads
08:36:29 <d-snp> well, I'm in an eternal struggle with the awkward squad
08:36:37 <jmcarthur> @undo do { x <- foo; y <- bar; return (x + y) }
08:36:37 <lambdabot> foo >>= \ x -> bar >>= \ y -> return (x + y)
08:36:56 <d-snp> yeah.. much clearer what's going on :(
08:36:57 <hpc> @pl foo >>= \ x -> bar >>= \ y -> return (x + y)
08:36:58 <lambdabot> (`fmap` bar) . (+) =<< foo
08:37:02 <hpc> lol
08:37:02 <jmcarthur> noooo
08:37:18 <d-snp> wait what
08:37:27 <jmcarthur> = liftM2 (+) foo bar
08:37:27 <Peaker> I converted his F# parallel quicksort to Haskell, and it turned out virtually the same (same token count, some fewer lines).  Then he said it took a "team of experts to write" :)
08:37:57 <jmcarthur> lol
08:38:13 <d-snp> what was the monad fold called again? I want to call a monad returning function for every element of a list
08:38:24 <roconnor> @ask edwardk: do you think there should be a function of type something like (Functor f) => Store s a -> (s -> f s) -> f a in Control.Comonad.Trans.Store?  and if so, what should it be called?
08:38:24 <lambdabot> Consider it noted.
08:38:35 * roconnor worries about that :
08:38:41 <roconnor> @ask edwardk do you think there should be a function of type something like (Functor f) => Store s a -> (s -> f s) -> f a in Control.Comonad.Trans.Store?  and if so, what should it be called
08:38:41 <lambdabot> Consider it noted.
08:38:45 <Peaker> d-snp, whenever you want to apply a pure func to pure val, you do:  f x       pure func to impure val:    f <$> x     impure func (a->m b) to impure val:   f =<< x      pure func to multiple impure args:  f <$> x <*> y ..   or:  liftM2 f x y
08:39:03 <Peaker> d-snp, you probably want mapM which is sequence on the result of map
08:39:31 <Peaker> d-snp, also, the function is returning a "monadic value" or "action", not "a monad".   "a monad" is the type itself which is the Monad instance. For example "Maybe" is a monad. (Just 5) is not a monad
08:40:46 <d-snp> hmm
08:41:35 <hpaste> d-snp pasted “mapM and runPut” at http://hpaste.org/68750
08:41:40 <d-snp> I think it's mostly runPut I don't fully understand
08:42:00 <d-snp> oh nice it gives warnings and errors
08:42:25 <Peaker> d-snp, yeah, that's hlint :)
08:42:48 <Peaker> why do you pack every address byte in its own 32-bit thingie?
08:42:59 <Peaker> oh, sorry, it's not that
08:43:09 <Peaker> it's a 32-bit value in each item
08:43:30 <Peaker> d-snp, is there a problem with that code?
08:43:37 <rwbarton> at least one of those functions has a confusing name
08:43:38 <d-snp> yes, the ipv6 is 4 32-bit values, I need to convert it to [Word8]
08:43:45 <Peaker> addr_bytes should be called "addr_words" or such?
08:43:55 <d-snp> exactly
08:44:01 <d-snp>     Couldn't match expected type `()' with actual type `[b0]'
08:44:02 <rwbarton> @type runPut
08:44:03 <lambdabot> Not in scope: `runPut'
08:44:05 <rwbarton> @hoogle runPut
08:44:06 <lambdabot> No results found
08:44:11 <d-snp> it expects Put, but gets PutM [b0]
08:44:12 <rwbarton> use mapM_
08:44:26 <Peaker> http://hackage.haskell.org/packages/archive/binary/latest/doc/html/Data-Binary-Put.html#v:runPut
08:44:35 <d-snp> awesome that worked, time to google the difference
08:44:41 <ohgodno> is there a way to make ghci show a function's code ?
08:44:49 <Peaker> d-snp, type Put = PutM ()
08:45:01 <Peaker> d-snp, Put is actually a contrived thing, meant to support "do" syntax even though it makes little sense
08:45:03 <d-snp> ohh ignore the results is what the _ does
08:45:08 <rwbarton> yes
08:45:33 <Peaker> d-snp, mapM there results in   PutM [..]  and mapM_ results in  PutM ()   which is Put.  And runPut expects Put (PutM ()) and not (PutM [..])
08:46:04 <Peaker> I think it would be nicer if Put was just a simple Monoid and instead of do syntax, the common way was "mconcat", instead
08:46:22 <Peaker> and maybe some syntax sugar for indent/newline-based lists rather than [] and comma-based
08:47:50 <d-snp> I think 30% of the lines in this file contains either 'putWord' or 'getWord'
08:49:31 <d-snp> oh yeah it compiled, thanks guys :)
08:49:40 <d-snp> I'll share with you the horror that is this function
08:50:48 <hpaste> d-snp annotated “mapM and runPut” with “makeCookie” at http://hpaste.org/68750#a68752
08:51:14 <d-snp> oh I have a bunch of redundant $'s
08:52:24 <d-snp> do you think it could be prettier somehow? it takes a lot of arguments
08:54:11 <rwbarton> the putLazyByteString $ runPut $ ... is unnecessary
08:54:33 <rwbarton> just get rid of line 20 and replace line 31 with line 21
08:55:26 <d-snp> ah that makes sense, thanks
08:55:39 <jmcarthur> d-snp: Cookie could be a separate data type from the serialized version. one would be the nice, convenient record, the other would just be a bytestring, and you can convert back and forth
08:55:50 <jmcarthur> d-snp: that would allow you to avoid all that ugly argument passing stuff
08:56:45 <d-snp> jmcarthur: it actually is separated like that
08:57:10 <jmcarthur> d-snp: but your record *contains* the bytestring...
08:57:28 <jmcarthur> d-snp: i'm arguing that maybe it shouldn't
08:57:29 <d-snp> yeah temporarily
08:57:31 <jmcarthur> ah
08:57:41 <jmcarthur> well, your argument passing will go away when you change that
08:57:42 <d-snp> it is going to be MAC'ed, so hashed
08:58:11 <jmcarthur> i see. the hash still doesn't need to be stored with it explicitly though
08:58:34 <jmcarthur> since it's just a function of the other data
08:58:52 <d-snp> it's not exactly, it's a function of the data in the cookie, and a few things besides the cookie
08:59:08 <d-snp> but I get your point
08:59:49 <lpsmith> I don't suppose somebody who is familiar with Network.Socket would have some insight into this:  http://hpaste.org/68729
09:02:01 <Peaker> d-snp, you can use: mapM_ putWord32be [cookieCreationTime, peerVerificationTag, windowCredit] and same for other sequences
09:02:09 <Peaker> (to unify same-type fields in sequence)
09:02:21 <Peaker> though that's not necessarily an improvemen
09:02:34 <Peaker> it is pretty declarative as it is:  type name
09:03:51 <roconnor> @type \s -> fmap ($ s)
09:03:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => a -> f (a -> b) -> f b
09:04:00 <d-snp> the documentation here: http://hackage.haskell.org/packages/archive/Crypto/4.2.0/doc/html/Data-HMAC.html is a bit sparse, do you perhaps know wether the hmac function returns an infinitely long hash, or is it bounded somehow?
09:08:05 <d-snp> lpsmith: so the socket didn't get closed upon receiving the FIN? maybe that is useful somehow? I'm not really familiar with Network.Socket, but maybe it has a function that lets you explicitly check wether the connection has finished and should be closed
09:08:43 <hpc> d-snp: it has a link to the paper that has all the detailed docs
09:09:04 <lpsmith> d-snp, exactly
09:09:27 <applicative> Peaker: he cant use mapM_ on a list, since the  elements are of different types, no?
09:09:49 <lpsmith> I haven't found a way of checking whether or not a socket has been closed though,  other than to use recv with a really short timeout
09:10:19 <lpsmith> but I find it very odd that the socket is accepting a message after it has been closed,  and that the client side should be aware of it
09:10:52 <lpsmith> admittedly,  I'm no expert on the finer details of TCP sockets
09:11:59 <d-snp> I think it's just not closed
09:12:15 <lpsmith> well, it hasn't been closed on the client side
09:12:21 <lpsmith> but it was closed on the server side
09:14:35 <bitonic> ClaudiusMaximus: damn you're right, it deadlocks...
09:15:48 <lpsmith> Are application-level protocols expected to be able to signal when one side wants to close the connection?    That seems a little odd to me...
09:16:31 <geekosaur> <d-snp> lpsmith: so the socket didn't get closed upon receiving the FIN? maybe that is useful somehow? I'm not really familiar with Network.Socket, but maybe it has a function that lets you explicitly check wether the connection has finished and should be closed
09:16:48 <geekosaur> TCP somewhat infamously does not really have such a concept
09:17:46 <geekosaur> also, beware:  is the socket closed, or was shutdown() called on it?  significant difference (and I haven't poked at networkk library closely)
09:17:50 <lpsmith> right, but my complaint is that I don't seem to have any way to *know* that I received a FIN and that I should close the socket,   unless I build that into the application-layer protocol.
09:17:52 <bitonic> ClaudiusMaximus: wait, but it deadlocks with readChan as well. so it's not a problem inherent to my function
09:18:16 <lpsmith> geekosaur, sClose calls close,  not shutdown.
09:18:38 <bitonic> ClaudiusMaximus: it's simply that if a thread is trying blocking reading from the chan and the main thread tries to read as well, well you have a deadlock :P
09:23:00 * hackagebot arithmoi 0.4.0.0 - Efficient basic number-theoretic functions.  Primes, powers, integer logarithms.  http://hackage.haskell.org/package/arithmoi-0.4.0.0 (DanielFischer)
09:23:02 * hackagebot darcs2dot 0.1.0.0 - Outputs dependencies of darcs patches in dot format.  http://hackage.haskell.org/package/darcs2dot-0.1.0.0 (SoenkeHahn)
09:25:17 <Peaker> applicative, they're all given as arguments to the same monomorphic function, so I don't think so
09:25:58 <Peaker> (though I did mean to unify just those that are being put by the same function)
09:26:33 <jonaskoelker> what's the least ugly accumulation: (1) acc ++ more, (2) reverse more ++ acc [and reverse acc when done], (3) (more++).acc [and apply acc to [] when done]?
09:27:17 <Peaker> jonaskoelker, (3) can be more nicely done using dlist
09:27:19 <jonaskoelker> AIUI, ShowS is (a la) 3 so I assume it's accepted, maybe even encouraged...
09:27:31 <jonaskoelker> dlist?
09:27:44 <Peaker> @package dlist
09:27:44 <lambdabot> http://hackage.haskell.org/package/dlist
09:27:55 <hpc> http://hackage.haskell.org/packages/archive/dlist/0.5/doc/html/Data-DList.html
09:28:29 <hpc> incidentally, DList a = Endo [a]
09:28:31 <covi> Hi guys I'm a newbie. Is Haskell the best (or the relatively most advanced) functional programming language?
09:28:40 <Peaker> jonaskoelker, I like (3) but (2) is accepted too
09:28:55 <hpc> if you ever find you need to accumulate over more complex structures, you can go all the way and make your function polymorphic in Monoid m => Endo m
09:28:59 <jonaskoelker> Peaker: is there anything bad about "(more++).acc"?
09:29:26 <Peaker> covi, Possibly the most advanced practical/main-stream functional programming language.  Agda/Coq/Epigram are more advanced FPL's but "research-y", less practical for real programs
09:29:34 <hpc> covi: since you are in #haskell, you should already know what kind of answers you will get ;)
09:30:02 <Peaker> jonaskoelker, I'd say it requires more effort to understand, as opposed to using dlist which wraps this idiom in a nice type that makes the intent clear
09:30:05 <hpc> haskell is definitely good for learning functional programming, independent of if it is a good language
09:30:16 <hpc> because it lacks an escape hatch back into imperative style
09:30:33 <ion> *cough*unsa…
09:30:35 <Peaker> IO? :)
09:30:37 <jonaskoelker> :D
09:30:38 <covi> hpc: IO?
09:30:54 <covi> Peaker: how about Lisp and its dialects?
09:30:57 <hpc> IO isn't really the escape it looks like ;)
09:30:58 <rwbarton> ffi :)
09:31:10 <hpc> well, it is
09:31:12 <Peaker> covi, Many of us here don't feel that most Lisp dialects are "functional", at least not in the same sense as Haskell
09:31:12 <jonaskoelker> ffi = nuke from orbit :-)
09:31:26 <hpc> but it really hurts to use
09:31:35 <ion> jonaskoelker: What’s your preferred solution for interfacing with C code?
09:31:41 <jonaskoelker> writing in C ;-)
09:32:03 <Peaker> covi, Lisp is more about "code is data" than referential transparency, equational reasoning, denotational semantics, and other Haskelly stuff
09:32:37 <hpc> put another way, haskell is more about "data as code"
09:32:47 <jonaskoelker> as an addendum to what Peaker's saying, I've found that with clojure's main data structures (list, list2 aka vector, set, map) being immutable, you get a long way towards the benefits of FP
09:32:48 <covi> Peaker: thanks for the nouns... these nouns seldom appear in learn you a haskell. Where am I expected to learn them from?
09:32:50 <Peaker> covi, "code is data" is cool, allows extending the language in interesting ways, at the syntactic level.  However, referential transparency, equational reasoning, purity, are cooler IMO :)
09:32:59 <hpc> ie, the reasoning you can apply to "computation that produces a FOO" is roughly the same as that of reasoning about the FOO itself
09:33:42 <jonaskoelker> [and of course, higher-order functions and a concise syntax for anonymous functions are both nice]
09:34:06 <covi> hpc: I see, your explanation is quite clear
09:34:08 <applicative> covi, if you havent learned a bit of some lisp, you should; if you havent learned a bit of SML/ocaml/Haskell you should learn, uh, Haskell
09:34:19 <hpc> applicative: haha
09:34:37 <hpc> also, when you decide to learn lisp, pick scheme or something like that
09:34:43 <hpc> not common lisp ;)
09:34:45 <jonaskoelker> clojure?
09:35:19 <covi> applicative: why do you think lisp is good?
09:35:32 <jonaskoelker> hpc: why not?  which difference is relevant to covi's situation?
09:35:37 <covi> hpc: yeah I am going to take a course on Sicp with Scheme this fall
09:36:54 <covi> hpc: yeah, why no common lisp in particular?
09:37:29 <hpc> common lisp is quirky and not really that interesting
09:38:01 * hackagebot regex-posix 0.95.2 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-posix-0.95.2 (ChrisKuklewicz)
09:38:11 <hpc> scheme's call-cc will keep you busy for quite a while :D
09:39:08 <jonaskoelker> hpc, tried clojure?
09:39:15 <hpc> i haven't
09:39:28 <jonaskoelker> heard about it?
09:39:30 <hpc> yeah
09:39:36 <jonaskoelker> impression?
09:39:51 <hpc> dunno
09:39:53 <bitonic> jonaskoelker: he says he hasn't tried it :P
09:39:56 <hpc> all i know is it's JVM lisp
09:39:59 <jonaskoelker> oh, ok
09:40:18 <jonaskoelker> you might have seen snippets, listened to Hickey's talks, ...
09:40:19 <Peaker> covi, I don't have a good resource beyond (the mediocre for learning) wikipedia
09:40:33 <covi> Where did you guys learn Haskell from? Lyah is good, but I don't think it's good enough
09:40:34 <Peaker> covi, probably a lot of it is covered by "Why Functional Programming Matters"
09:40:42 <Peaker> covi, almost none of which applies to any Lisp, I think
09:40:53 <bitonic> covi: LYAH is definitely good enough to start
09:40:53 <jonaskoelker> Peaker, have you tried clojure?
09:40:59 <Peaker> jonaskoelker, nope
09:41:04 <jonaskoelker> ^_^
09:41:05 <jonaskoelker> you should
09:41:07 <applicative> have you studied LYAH, its actually extremely sound.
09:41:07 <bitonic> "Proramming Haskell" is another nice book for beginners
09:41:16 <hpc> LYAH gets you to the point of being able to learn on your own
09:41:20 <Peaker> jonaskoelker, Maybe :-) I'm not sure I want to go back to unityping though
09:41:24 <hpc> from there, just hang out in #haskell and write your own code
09:41:35 <covi> I'm currently on the Applicative Functors section of LYAH.
09:41:39 <jonaskoelker> Peaker: there's some static inferencing against java interfaces...
09:41:47 <Jeanne-Kamikaze> I second what hpc said
09:41:53 <covi> And I think, oh man, Haskell is just so... right.
09:41:54 <Peaker> covi, I learned before LYAH existed, with "Gentle intro to Haskell" and "Yet another Haskell tutorial", both of which were unsatisfactory for me.. I just let the knowledge and trial&error sink in slowly
09:42:18 <covi> Peaker: I see
09:42:19 <hpc> i started with LYAH, then wrote an IRC bot
09:42:28 <applicative> after that you can work through Real World Haskell -- though its irritatingly out of date despite being recent, because of the revolution the authors effected on leading libraries
09:42:47 <bitonic> Peaker: "Programming in Haskell" is excellent and it's been around for a long time
09:43:07 <Peaker> bitonic, only in dead tree format, no?
09:43:13 <bitonic> Peaker: oh, yes.
09:43:26 <Peaker> I preferred online tuts at the time
09:44:15 <bitonic> I'm sure there are good lecture notes as well, Haskell is used in a lot of courses
09:44:30 <Peaker> covi, I found the idea and benefits of denotational semantics are explained nicely in many of conal's papers/blog posts
09:45:04 <covi> Peaker: conal.net/blog this guy?
09:45:23 <Peaker> covi, yeah
09:45:54 <covi> Peaker: thanks, will read it
09:45:54 <Peaker> covi, equational reasoning/referential transparency  lets you treat   a = b  relationships as true equality (except in diverging programs), and replace one by the other with only performance differences.  In Haskell, you can very safely take a sub-expression and move it to "let" or "where" mechanically with little thought, without worrying about changing some order of effects or such
09:45:55 <applicative> the other two tutorials that I really made a leap in proficiency from are the unlikely http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial and http://www.slideshare.net/tibbe/highperformance-haskell
09:46:07 <Peaker> covi, it's really nice at letting you think less as you apply mechanical refactorings to code
09:47:30 <Peaker> covi, Haskell taught me that pattern matching is a better fundamental branching mechanism than boolean branching (especially if you have types).. Lisps suffer from Boolean Blindness too: http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
09:48:01 * hackagebot regex-pcre 0.94.3 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-pcre-0.94.3 (ChrisKuklewicz)
09:48:09 <hpc> lisps have limited pattern-matching, but it's limited to a few magic special cases in the let macro
09:48:22 <covi> You are not talking in English :)  thanks for the links and I'll do my learning
09:48:48 <Peaker> covi, I can explain any term you'd like :)
09:48:55 <Peaker> covi, do you know "pattern matching" ?
09:48:55 <ocharles> If I'm working on a project which is going to consistent of at least 2 modules, each of which I want separate test suites, what tool should I be using?
09:49:01 <ocharles> cabal-dev, cabal-meta, something else?
09:49:46 <ocharles> Ie, I have '$project-foo', '$project-data' and '$project-server', where '$project-server' depends on '$project-data' and '$project-data' depends on '$project-base'
09:50:32 <covi> Peaker: yes I know. But I feel that though I know and I use, but I don't master.
09:50:49 <Peaker> covi, do you know the definition of the Maybe type? And the "isJust" and "fromJust" functions?
09:50:50 <covi> Peaker: e.g. I can't recite what can be matched against and what can't
09:51:01 <covi> Peaker: I know the Maybe type.
09:51:20 <applicative> Peaker thats an excellent post by R. Harper on boolean blindness
09:51:27 <Peaker> applicative, yeah it is :)
09:51:33 * byorgey also highly recommends that post
09:51:33 <Peaker> covi, here is "boolean blindness" by example:   if isJust x then ... use (fromJust x) ...   else  ... dont use x ...
09:52:05 <Peaker> covi, the correct (pattern matching) way to do it instead is:    case x of Just y -> ... use y ... ; Nothing -> ...           and to avoid "fromJust" like the plague
09:52:59 <Peaker> covi, do you see the difference between these two examples?  In one, we've reduced our Maybe information to a single bit, branched on it, and then used the branching as an indication on whether we're allowed to use the content of the Maybe -- without any way for the compiler to help us
09:52:59 <covi> Peaker: why we *have* to avoid fromJust?
09:53:01 * hackagebot RNAFold 1.99.1.2 - RNA secondary structure prediction  http://hackage.haskell.org/package/RNAFold-1.99.1.2 (ChristianHoener)
09:53:31 <covi> Peaker: I see.
09:53:33 <Peaker> covi, because it is unsafe: it means you must keep mental track of all the branching/if's you've done to know what is allowed and what is forbidden, and if you fail, you will get a runtime error (in 3AM, presumably :) )
09:54:04 <covi> Peaker: you are right. It's clear.
09:54:17 <applicative> its a defect in the Prelude that it doesn't have more functions that return Maybes
09:54:36 <Peaker> covi, so pattern-matching is a way to do if/branching such that the compiler gains information from your branching, so you don't have to keep mental track, and you don't have to use unsafe functions that fail at runtime
09:55:00 <Peaker> covi, whereas boolean blindness is reducing all information to a single bit, and branching on that, such that the compiler can't help at all
09:56:15 <covi> I can see that boolean blindness is prevalent in imperative languages..
09:57:26 <hpc> covi: it gets even more fun when you realize that nullable objects in languages like java let you carry blindness from function to function
09:57:42 <hpc> check for null in one function, then call another function that assumes something isn't null
09:58:11 <tgeeky> calling me with null? that would *never* happen!  (2 weeks later) bug report
09:58:24 <hpc> :D
09:58:34 <covi> hpc: but isn't that the only way to do the job? Java has no pattern matching.
09:58:44 <hpc> sadly, yeah
09:59:42 <covi> Man, the industry almost deems java/c++ as prereqs.
10:00:31 <tgeeky> industry has a way of systematically choosing the first workable solution to a problem, rather than the best solution to a problem
10:00:51 <tgeeky> I hesistate to say best, though.
10:02:01 <tgeeky> That is, I will always have to type This is a link to "Some.Longass.Module.Name.Here#02" even if I've done "import qualified Some.Longass.Module.Name.Here as SLMNH" ...?
10:02:06 <tgeeky> err
10:02:29 <tgeeky> is it possible to somehow hyperlink with haddock using the shortened name for a module?
10:03:00 <tgeeky> in the above case, I want to do: "SLMNH#anchor02
10:05:32 <tgeeky> there isn't a #haddock either. No better place to ask.
10:12:14 <jmcarthur> even haskell has some form of boolean blindness when you compare it to languages that can manipulate proof objects
10:14:40 <ohgodno> are transitive closures an important subject to study when learning haskell ?
10:15:18 <tgeeky> ohgodno: that's a property of a relation, yes? If so, no -- most Haskellers don't use relations often.
10:15:41 <byorgey> ohgodno: where did you see something about transitive closures?
10:16:33 <ohgodno> my databases and discrete structures course - and i seem to understand concepts better when i learn them through haskell - so i thought there was a text somewhere that covers it
10:16:43 <ohgodno> just my own twisted logic
10:17:14 <byorgey> oh, I see.  no, I'm not aware of any.
10:17:35 <byorgey> I've certainly seen Haskell code that computes/uses transitive closures.  But it's not really something you need to know about to understand Haskell itself.
10:19:26 <ohgodno> understood, i'll read it independently of my haskell readings and see where that leads. i'm rather certain our professor will ask us to implement something similar - since he cooperates with our math professor and they both plant exercises within eachother that makes use of the other's teachings
10:21:03 <ermines> "base-4.0.0.0 was excluded because of the top level dependency base -any"
10:21:08 <ermines> that seems counterintuitive
10:21:28 <monochrom> and taken out of context
10:21:32 <geekosaur> it's code for "library requires a different version of GHC than you have"
10:21:45 <ermines> I see
10:21:50 <geekosaur> older cabal-install is really bad at reporting that kind of thing
10:21:58 <ermines> yeah, I have base-4.3 available
10:22:05 <ermines> 4.3.1.0 to be precise
10:22:06 <geekosaur> the most recent version is better, but I think you still need to expicitly request it
10:22:24 <geekosaur> what are you trying to install?
10:22:55 <ermines> my own package
10:24:41 <monochrom> I think it's time to bet that you have a different problem
10:24:57 <ermines> I fixed it
10:30:32 <Peaker> jmcarthur, Yeah, Haskell has plenty of boolean blindness (though maybe it is no longer "boolean" blindness?). But my main point was that having pattern matching rather than conditional branching as a fundamental primitive makes sense, and contradicts what virtually all languages do
10:32:01 <bitonic> uhm. it's a pity that Haskell signals for incomplete pattern matches even if the thing you'd have to pattern match is an empty data declaration. having something like Agda's () but simpler would be nice. what's the idiomatic way of treating `Void'?
10:33:15 <Mathnerd314> @hoogle absurd
10:33:15 <lambdabot> No results found
10:33:27 <bitonic> Mathnerd314: ah, rigt.
10:33:28 <bitonic> *right
10:34:12 <Peaker> CPU profiling my badly performing application is giving seemingly nonsensical results
10:34:27 <Peaker> (Major cost centres that just compose other functions that do all the work, and have no logic in themselves)
10:47:17 <mcstar> nice discussion before
10:47:20 <fmap> @pl \a b ->  f >>= \ i -> g >>= \ j -> t a b i j >> return (i, j)
10:47:20 <lambdabot> (((f >>=) . ((g >>=) .)) .) . flip flip ((return .) . (,)) . (liftM2 (liftM2 (>>)) .) . t
10:47:40 <mcstar> clojure gained some performance in recent times, i check shootout sometimes
10:49:05 <mcstar> btw, that benchmark is getting a bit ridiculous
10:49:14 <mcstar> do you guys check the codes?
10:49:31 <ermines> so System.Event's registerFd takes a file descriptor for an argument
10:49:39 <Peaker> fmap, That seems like a case for do notation :)
10:49:42 <mcstar> probably the most readable ones are the fotran ones
10:50:07 <mcstar> (slightly joking)
10:50:27 <jmcarthur> the shootout calls for some constraints that end up making a lot of code quite unidiomatic in various languages
10:50:56 <mcstar> and i say, that is a bad representation of a language on the site
10:51:31 <mcstar> it would need better and longer running programs, half of them measure numeric performance
10:52:26 <ermines> wait, handleToFd closes the handle?
10:53:24 <mcstar> jmcarthur: i remember seeing this code when i was learning common lisp, and went WTF http://shootout.alioth.debian.org/u64/program.php?test=mandelbrot&lang=sbcl&id=1
10:54:05 <monochrom> because there would be much inconsistency if you were allowed to use both the handle and the fd
10:54:31 <applicative> mcstar: which benchmark is getting ridiculous, or you just mean its all crazy code
10:55:41 <applicative> the lisp translation of C is pretty good
10:55:41 <mcstar> applicative: im just saying, ppl shouldnt go as far as they do, to make their language as performant as possible
10:55:58 <mcstar> why not just use fortran if you need numeric performance, right?
10:58:08 <monochrom> in real work, people actually don't go too far into performance. you are just seeing people going out of whack on these shootout sites. you should opine, instead, that people shouldn't care so much about shootouts.
10:58:52 <mcstar> so, religion, again
10:59:08 <monochrom> then again, how can we demand people to care less about shootouts, if they also care about the olympic games
10:59:18 <applicative> they're nonsense, but people should improve the haskell ones they're out of date, there have only been corrections for compiler errors for a couple years
10:59:49 <mcstar> i run into Julia the other day
11:00:06 <mcstar> it seems to be a performant language, for numeric computations
11:00:17 <mcstar> but has lisp heritage
11:00:22 <mcstar> and its on the llvm
11:00:52 <mcstar> sorry for the advertisement, but i would like ppl to know that it exists, cause for instance ive been looking for such a language
11:01:05 <applicative> I was fiddling with the k-nucleotide one, which has sunk, it clear that with some of the new libraries it could be much  simpler and faster  ... I think
11:02:35 <mcstar> applicative: you can get ocaml like performance with haskell nowadays, correct?
11:03:20 <applicative> mcstar, on the stupid shootout haskell used to be way ahead of ocaml on everything, not that it proves anything
11:03:43 <mcstar> i see, harrop hired some phds
11:03:44 <hpc> the stupid shootout?
11:03:49 <hpc> that's one i would think php would win :D
11:04:11 <applicative> you can win that one in any language
11:06:04 <applicative> i wish a version of ghci could do something like the plots Julia and suchlike languages have
11:06:23 <applicative> who wants a repl that just displays a string
11:06:42 <mcstar> you can call gnuplot
11:07:38 <jjl_> i find string based repls quite handy personally
11:07:57 <applicative> yes, there are actually a number of things sort of like it in haskell.
11:09:02 <peeler> how do I use the state monad with a wxhaskell callback? e.g., set ctrlInput [on anyKey ::= onKeydown]; onKeyDown :: TextCtrl() -> Key -> MyState IO ()
11:09:22 <cheater__> applicative: #diagrams
11:09:36 <applicative> ha, okay
11:10:02 <applicative> I got carried away looking at the sine curve on the Julia lang page
11:10:36 <monochrom> haha
11:11:16 <bookerz> I've got a Control.Monad.Random question that stems from my lack of understanding about monads in general...
11:11:21 <bookerz> Let's say that I've got monadic value myRand :: Rand StdGen Int that I'm going to feed to some function myFunc.  And let's say that I want to give another function doubleFunc a value that's twice whatever number myRand gets.  I've noticed I can't just pass in (doubleRand = liftM (*2) myRand), because when myRand and doubleRand are each evaluated in their respective functions their values will not come from the same tick of the RNG.
11:11:31 <mcstar> applicative: plotting is the worst developed part of Julia
11:11:41 <bookerz> The Control.Monad.Random docs give evalRandIO: "Evaluate a random computation in the IO monad, using the random number generator supplied by getStdRandom."
11:11:57 <bookerz> What exactly goes on when I transform my Rand StdGen Int into an IO Int?  Once I do can I think of the resultant value as an actual number?
11:12:21 <applicative> mcstar: sexy website for it though, I'm plotting away.
11:13:12 <mcstar> :)
11:13:29 <pckt> gnuplot best plots.
11:14:00 <applicative> maybe I just like Julia's webdev people
11:14:53 <kallisti> I just made something horrible
11:15:10 <kallisti> "http://" ++ maybe "" (++ (maybe "" (':':) mPass ++ "@")) mUser ++ addr ++ maybe "" (':':) port
11:15:10 <mcstar> it has a nice type system, and generic functions http://julialang.org/manual/types/
11:15:12 <peeler> no one knows how to pass a state monad to a callback?
11:15:22 <kallisti> peeler: I do
11:15:31 <kallisti> callback stateMonad
11:15:37 <peeler> kalven: how do I use the state monad with a wxhaskell callback? e.g., set ctrlInput [on anyKey ::= onKeydown]; onKeyDown :: TextCtrl() -> Key -> MyState IO ()
11:15:40 * kallisti might need some context.
11:15:47 <peeler> oops, that was supposed to  be kallisti
11:16:09 <kallisti> oh you want to thread a state through a Wx callback?
11:16:11 <kallisti> you can't do that.
11:16:28 <kallisti> well.. you could, but there isn't much point
11:16:37 <peeler> why not?
11:16:39 <kallisti> you'll have to do a lot of explicit runStateT plumbing
11:16:54 <kallisti> it's in the type: the function should return an IO ()
11:17:09 <peeler> yes, so?
11:17:27 <applicative> "Describing Julia in the lingo of type systems, it is: dynamic, nominative, parametric and dependent." dependent??
11:17:29 <kallisti> well... you won't get any nice implicit state stuff
11:17:35 <kallisti> you'll have to runStateT to get the IO action
11:17:36 <kallisti> on each call
11:17:38 <peeler> the entire program relies on the onKeyDown function
11:17:46 <peeler> that's where everything follows from in it
11:18:04 <kallisti> unless I'm missing something here, I think you'd want an IORef.
11:18:13 <kallisti> or an MVar or something similar.
11:18:24 <peeler> thanks ill look into those
11:18:55 <kallisti> peeler: since the callback returns an IO, there's no way to implicitly thread a State monad between each consecutive call.
11:19:12 <peeler> oh
11:19:28 <kallisti> so you'll have to resort to mutable variables, I think.
11:19:51 <kallisti> unfortunately WxHaskell isn't incredibly high level.
11:20:23 <peeler> does the banana library fix that aspect of wxhaskell?
11:21:02 <kallisti> I don't know much about reactive-banana (or FRP in general), but I would imagine it doesn't require to resort to mutable variables for state.
11:21:10 <kallisti> *you
11:21:23 <kallisti> because it's implemented entirely in Haskell, whereas WxHaskell is a bunch of foreign calls.
11:22:25 <peeler> kallisti: is there a way to get inside the wxhaskell event loop, because then i could start my state from inside that
11:22:28 <kallisti> (that doesn't mean that WxHaskell couldn't use a special monad for callback functions with a MonadState instance.. it just doesn't)
11:22:31 <peeler> i think
11:22:51 <kallisti> peeler: I don't know. the low level stuff is in wx-core but good luck with that.
11:23:29 <peeler> so basically making gui apps in haskell is a pain in the ass, currently?
11:23:32 <kallisti> honestly IORefs (or MVar if you need locks) are probably the easiest choice
11:23:32 <peeler> or am i just doing something weird
11:23:45 <kallisti> peeler: no that sounds accurate.
11:24:01 <peeler> ok thanks for your help :)
11:24:11 <jmcarthur> IMO, no harder than any other language really. it's just that it feels more unnatural in haskell since it's so imperative
11:24:13 <mcstar> kallisti: how about the qt binding?
11:24:22 <beefcube> newbie question: i'm trying to understand an example of GetOpt use, containing the line: ReqArg (\arg opt -> return opt { optInput = readFile arg }) "FILE" , however the constuctor for ReqArg is: ReqArg (String -> a) String, how does that even work?
11:24:27 <kallisti> well, I should say s/in Haskell/in WxHaskell/
11:24:33 <kallisti> because that's the only GUI library I have experience with.
11:24:34 <jmcarthur> we don't have very good *functional* gui libs
11:24:34 <Modius> Does one of haskell's inner types use an RB tree?
11:24:41 <Modius> I mean, the immutable containers.
11:24:45 <hpc> peeler: i am slowly finding ways of making it nicer
11:25:03 <hpc> one good trick is to use ContT
11:25:04 <hpc> http://hpc.dyndns-web.com:8000/blog/view.cgi?id=11
11:25:30 <kallisti> more importantly, would an immutable red-black tree algorithm even be efficient?
11:26:34 <Modius> Depends on your definition of efficient.  It may be one of the better sorted immutable containers.  I was just wondering, and wondering if it was based on the old dons code
11:26:51 <Modius> I ported it, and it's correct against the test battery I sent up; but doesn't reuse much of the old structure.
11:27:00 <Modius> I think HE got most of it out of the Okasaki book, then added a delete.
11:27:38 <kallisti> actually nevermind red-black doesn't seem to rely too much on mutability.
11:27:48 * kallisti is a bit rusty on his tree algorithms.
11:29:55 <kallisti> I should find a good book on functional data structures.
11:30:07 <kallisti> my data structures class in C++ is useless here. :P
11:30:18 <Modius> I think there's a focus on correctness; but not the importance of sharing.
11:30:59 <Modius> I've thought about it a lot as I make heavy use of "take a pointer to this huge map at point A - while someone's still building up a modded version on another thread, which I'll grab later".  Without sharing, you end up with basically huge  copies kept in ram.
11:31:05 <ski> kallisti : "Purely Functional Data Structures" by Chris Okasaki ?
11:32:20 <kallisti> ski: I have that one bookmarked actually. I just didn't mention it. :P
11:32:28 <kallisti> because I don't know if it's good or not.
11:32:32 <mcstar> okasaki writes on his blog, that his wife is perflexed that book is still sold, when revenue checks arrive
11:33:12 * ski thinks it's good
11:35:38 <ocharles> Anyone know how I could move from "PropertyM SomeMonad a" to "PropertyM IO a" ?
11:35:59 <kallisti> not without more information about what that means.
11:36:23 <ocharles> I'm trying to use monadic quick check on stuff in my own custom application monad, which is basically a ReaderT DatabaseConnection IO
11:36:34 <ocharles> let me paste what I have at the moment, I think that'll be helpful
11:37:06 <ocharles> https://gist.github.com/a98aaf387f66890361a7
11:37:19 <ocharles> I need to move from PropertyM DatabaseContext a to PropertyM IO a, for monadic IO to work
11:40:36 <ocharles> DatabaseContext is an instance of MonadIO, if that helps
11:42:15 <joe9> anyone using implicitCAD here?
11:42:25 <joe9> just came across it. not sure if it is any good.
11:42:34 <joe9> wanted to check if there are any users here.
11:44:16 <ski> ocharles : hm, i wonder how `PropertyM' is defined ..
11:44:39 <ocharles> ski: as a continuation: http://hackage.haskell.org/packages/archive/QuickCheck/2.4.2/doc/html/Test-QuickCheck-Monadic.html
11:44:55 <ocharles> which is a bit beyond me sadly
11:45:13 <applicative> newtype PropertyM m a = MkPropertyM { unPropertyM :: (a -> Gen (m Property)) -> Gen (m Property) }
11:45:23 <applicative> oh
11:45:39 <ski> hm .. so invariant
11:46:50 <applicative> another excellent definition:  monadicIO = monadic morallyDubiousIOProperty
11:47:07 <ocharles> heh
11:47:21 <ocharles> there's some sort of rose tree behind it all, but i don't know what a rose tree is so that doesn't help me :)
11:47:47 <jmcarthur> a rose tree is a fancy name for one of the most generic possible trees
11:47:55 <ski>   `data Tree a = Node a [Tree a]' is a rose tree
11:47:58 <ocharles> oh
11:48:53 <jmcarthur> ski: can't rose trees be empty?
11:49:06 <copumpkin> typically not, in the usual presentation I've seen
11:49:09 <copumpkin> (Cofree [])
11:49:10 <jmcarthur> ah
11:49:14 <applicative>  `data Tree a = Node a [Tree a] } Nil'
11:49:18 <applicative>  `data Tree a = Node a [Tree a] | Nil'
11:50:20 <applicative> Since the list can be empty you'd get too many representations of emptiness
11:51:03 <d-snp> hey, how can this happen: There is no available version of crypto that satisfies -any ?
11:51:09 <ski> you could use `Maybe (Tree a)' ..
11:51:32 <applicative> right
11:52:26 <bookerz> ok -- so experimenting has shown that even the IO Int myRand in myRand = evalRandIO( getRandomR (0,100) ) can evaluate to different numbers in every context it's evaluated in.  What do I gotta do to ensure that every function I pass myRand to ultimately gets the same number?
11:53:12 <applicative> d-snp: what version of ghc are you using
11:53:15 <ocharles> so is it likely to be possible to move from PropertyM DatabaseContext to PropertyM IO?
11:53:15 <ski> bookerz> :t evalRandIO
11:53:46 <jmcarthur> bookerz: why not just use a generator instead of the IO versions of these things?
11:54:17 <jmcarthur> oh is this to use Control.Monad.Random or something?
11:54:24 <d-snp> applicative: nvm it was case sensitive >_>]
11:54:57 <jmcarthur> bookerz: i'd try using evalRand instead of evalRandIO
11:55:07 <bookerz> Because the simplest examples of random numbers involve evalRandIO, and I'm trying to figure out the language as I go
11:55:14 <ski> ocharles : hm, i think we probably need to know more about `DatabaseContext' as well ..
11:55:23 <ocharles> ok, I'll paste that
11:55:23 <bookerz> Which would involve passing a generator explicitly, yes?
11:55:31 <applicative> he mentioned it's a monadio instance
11:55:34 <jmcarthur> correct
11:56:02 <jmcarthur> at least at the point that you use evalRand. you still don't have to pass it explicitly throughout your use of the MonadRandom interface
11:56:03 <ski> @type System.Random.newStdGen
11:56:04 <lambdabot> IO StdGen
11:56:09 <ocharles> DatabaseContext is at https://gist.github.com/66fdf34065da0101c541
11:56:39 <jmcarthur> you just have to make sure to use the same generator each time you use evalRand if you want to always get the same results
11:56:39 <ski> bookerz : i suspect your `evalRandIO' uses `newStdGen', which modifies a global state to get a fresh generator
11:57:30 <d-snp> do I need to do more than 'import Data.HMAC' to include this library? http://hackage.haskell.org/packages/archive/Crypto/4.2.5/doc/html/Data-HMAC.html I have installed the Crypto package
11:57:39 <bookerz> so... I don't want the same results every time I run my program.  I just want to be able to pull a number out of the generator and then pass this number to other functions
11:57:49 <ski> (ocharles : .. of course, it doesn't help that i'm not really familiar with monadic QuickCheck)
11:57:58 <d-snp> it says it can't load the module :S
11:58:15 <jmcarthur> bookerz: then get the number and pass it around instead of calling some randIO function each time
11:58:15 <bookerz> Maybe I'm just evaluating them in the wrong place
11:58:17 <ocharles> ski: np
11:58:27 <applicative> we want to go from (a -> Gen (DatabaseContext Property)) -> Gen (DatabaseContext Property)  to  (a -> Gen (IO Property)) -> Gen (IO Property) given liftIO
11:59:12 <d-snp> oh nvm it failed to build :S
11:59:14 <ski> bookerz : still waiting for the type of `evalRandIO'
11:59:28 <ocharles> applicative: yea, that sounds right
11:59:33 <jmcarthur> ski: evalRandIO :: Rand StdGen a -> IO a
11:59:35 <bookerz> jmcarthur: which will make the functions that I pass it to take "Int"s rather than "Rand StdGen Int"s or "IO Int"s
11:59:40 <jmcarthur> ski: it's in the MonadRandom package
11:59:52 <bookerz> ski: sorry -- thought you were asking rhetorically :-)
11:59:52 <jmcarthur> bookerz: exactly
12:00:32 <bookerz> jmcarthur: Then thanks...  I think I can figure this out.
12:00:51 <jmcarthur> bookerz: you can think of many monads as ways to build up computations rather than as the values you eventually get from them
12:00:59 <ClaudiusMaximus> bitonic: ah, shame - it would have been handy
12:01:25 <jmcarthur> bookerz: so Rand StdGen Int is the type of something that *when executed* will give you some random Int
12:01:32 <ski> bookerz : ok, so why are you passing around `myRand' ?
12:01:36 <jmcarthur> bookerz: it's not an Int itself
12:01:48 <bookerz> jmcarthur: sort of analogously to lazy computation
12:02:16 <bookerz> ski: because I've got different functions that take the same inputs
12:02:17 <jmcarthur> eh, somewhat loosely
12:02:23 <bookerz> heh
12:02:33 <jmcarthur> lazy computation will always give you the same results
12:02:49 <jmcarthur> executing a monad doesn't necessarily (it depends on the inputs and, if IO is involved, the real world)
12:02:53 <ski> bookerz : not quite. `myRand' must be executed in a context of the `IO'-monad, which will read the current global PRNG state (modifying it) from the `IO'-context
12:02:59 <bitonic> ClaudiusMaximus: no wait - what I'm saying is that it's ok :P
12:03:32 <ski> bookerz : so the next time you execute it, the state that is passed around in the `IO' monad will be different, and so `myRand' will (probably) give a different result when executed
12:04:22 <bookerz> ski: but can it be evaluated within, say, a do block and then passed from within that do block as a constant number to other functions?
12:04:30 <jmcarthur> bookerz: Rand g a  is implemented as  g -> (a, g). its output depends on its input. evalRandIO generates a fresh input each time
12:05:07 <jmcarthur> bookerz: when you bind the result you can pass the *result* around
12:05:09 <applicative> ocharles: hm, i'm stuck, it seems like i need lowerIO as well as liftIO, so to say
12:05:15 <ski> bookerz : the *result* of executing `myRand' can be passed around, yes
12:05:38 <ocharles> applicative: I'm also stuck
12:05:53 <ocharles> i keep circling around what I want to do (run each property in a transaction), but I always fall short somewhere
12:05:54 <bookerz> I think I've been playing fast-and-loose with the difference between a monadic value and its result
12:06:04 <jmcarthur> bookerz: think of it like you would think of a C function  int randomInt();  ... you could pass the function pointer around, but executing it could give you different results each time. alternatively, you execute it once and pass the result around
12:06:08 <ski> bookerz : yeah, those are different things
12:06:43 <bookerz> jmcarthur: actually, that's a pretty clear explanation
12:06:53 <jmcarthur> it's not 100% accurate though
12:06:54 <ski> bookerz : about as different as an `int' in C, and an `int (*)(void)' (which may mutate some state)
12:07:30 <jmcarthur> monads give you a lot more power than C function pointers :)
12:09:38 <bookerz> thanks for the help, you two
12:10:48 <jmcarthur> np
12:17:43 <colah> GHC has decided it hates me :(
12:17:44 <colah> cabal: dependencies conflict: ghc-7.0.4 requires containers ==0.4.2.1 however
12:17:44 <colah> containers-0.4.2.1 was excluded because ghc-7.0.4 requires containers
12:17:44 <colah> ==0.4.0.0
12:18:45 <colah> (I was playing around with GHC HEAD earlier and had that isntalled in /usr/local, but it shouldn't be effecting anything at the moment, since I deleted the symlinks for ghc, etc, in /usr/local/bin)
12:19:35 <colah> Anyone know how I can get GHC to forgive me for not being content with the version that came installed with my computer? :P
12:20:03 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml#pigeon for how you got there
12:21:50 <monochrom> in the future, use cabal-install version 0.14 or above. it has a check to prevent this state pre-emptively
12:22:10 <monochrom> (i.e., it refuses to "upgrade" some packages)
12:23:10 <colah> monochrom: Thanks! Now I just need to figure out how to fix this...
12:24:19 <ocharles> applicative: yuck. I made a work around for now changing to runDBProperty :: ((DatabaseContext a -> IO a) -> PropertyM IO a) -> Property
12:24:30 <ocharles> So the test is given a way to 'lower' database actions to IO
12:24:53 <monochrom> how to fix it depends on how many packages you are ready to kiss goodbye
12:27:07 <ski> ocharles> :t rollback
12:27:09 <ski> ocharles> :t run
12:27:26 <ski> i'm not sure yet what `monitor' really does
12:27:32 <colah> In this case, I just did "rm -rf .ghc/i386-linux-7.0.4/
12:27:47 <colah> Now reinstalling my dependencies. We'll see what happens.
12:27:52 <ocharles> ski: rollback :: DatabaseContext (), run :: http://hackage.haskell.org/packages/archive/QuickCheck/2.4.2/doc/html/Test-QuickCheck-Monadic.html
12:28:12 <ocharles> ski: rollback is actually HasPostgres m => m (), rather
12:28:24 <ski> oh, missed `run' there
12:28:51 <colah> So, where to I make libations to the gods GHC and Cabal?
12:29:10 <colah> That my package installs may go without horrendous problems?
12:39:57 * applicative feels that when he makes a hash of things installing ghc-head he cant blame his problems on cabal install or ghc, quite.  But maybe.
12:44:30 <applicative> ocharles, I couldn't get rid of a dependency on a 'Postgres' (not sure what they are)   https://gist.github.com/27831ec7becc85754f22
12:47:10 <applicative> acch, its a muddle even so i think
12:50:11 <ocharles> I need to start making more functions called tallyho
12:51:02 <sp3ctum> suggestion: jaiho
12:51:17 <sp3ctum> .. jive ho? jibe ho? weird language, English
13:02:11 <ku> why are these syntaxes equivilant in haskell?
13:02:19 <ohgodno> is it normal to experience horror when first learning about cps ?
13:02:22 <ku> []:([]:[]) vs []:[]:[]
13:02:27 <ku> > [[],[]]
13:02:28 <lambdabot>   [[],[]]
13:02:37 <hpc> ohgodno: yes
13:02:42 <hpc> but it's not horrible
13:03:10 <ohgodno> hpc: converting the arrows seems to be like being hit in the face with a hammer
13:03:19 <ohgodno> but.. i am sure this will get better
13:03:20 <sipa> ku: why is a+(b+c) equal to a+b+c?
13:03:22 <ku> I'm just trying to wrap my head around the difference when brackets are not option for this syntax (because of partial application)
13:03:31 <ku> (:) [] ((:) [] [])
13:03:50 <dschoepe> ku: Because (:) associates to the right.
13:04:04 <hpc> ku: let's make your example not extremely confusing ;)
13:04:09 <hpc> > 1:2:[]
13:04:09 <lambdabot>   [1,2]
13:04:13 <hpc> > 1:(2:[])
13:04:14 <lambdabot>   [1,2]
13:04:17 <hpc> > 2:[]
13:04:18 <lambdabot>   [2]
13:04:21 <hpc> > 1:[2]
13:04:22 <lambdabot>   [1,2]
13:04:22 <ohgodno> ku: : is associative
13:04:25 <hpc> voila!
13:04:50 <ski> ohgodno : *right* associative
13:04:56 <ski> (it's not associative)
13:04:56 <monochrom> x:y:z is shorthand for x:(y:z)
13:05:21 <ku> so in haskell most things are right associative, i.e. any regular function
13:05:23 <monochrom> in []:[]:[], the third [] is of a different type from the first and second
13:05:27 <ku> but infix functions are different?
13:05:31 <jjl_> now explain that in terms of precendence and "wrapping brackets" ;)
13:05:34 <aavogt> what does the fixity have to do with partial application?
13:05:50 <dschoepe> ku: When you define an operator that's not built-in like (:), you can specify whether you want it to be left- or right-associative
13:05:56 <kaf3ii> data A f = Nil | A (f (A f))
13:05:56 <kaf3ii> i want to make this structure an instance of Eq, how should the instance declaration head look like?
13:06:17 <monochrom> no, in haskell, most things are left or right or neither depending on what the Haskell Report says and what actual code says
13:06:39 <ku> dschoepe: ah ok! that helps understand at a high level, I wasn't aware of the possibility to modify that behaviour
13:06:42 <hpc> kaf3ii: that's tricky
13:06:46 <ski> ku : "so in haskell most things are right associative, i.e. any regular function" -- no `f x y' means `(f x) y', not `f (x y)'
13:07:02 <ku> monochrom: ok
13:07:15 <hpc> kaf3ii: i actually forget; there's a trick to keep GHC from looping or something like that, and i can't remember what it is
13:08:01 <ku> ski: woops I meant the inverse (most things **left** associative in haskell)
13:08:04 <kaf3ii> hpc: ok
13:08:08 <ski> ku : ok, fine
13:08:13 <hpc> and i can't find the code i have that does something similar
13:08:20 <ski> ku : ideally we'd like `instance (forall a. Show a => Show (f a)) => Show (A f)' -- but we can't say this
13:09:19 <ski> ku : one solution is to invent a class, such that `Show1 f' encodes `forall a. Show a => Show (f a)' -- another is to say `instance Show (f (A f)) => Show (A f)', and turn on `UndecidableInstances'
13:10:00 <hpc> oh, that's what it was
13:10:09 <mcstar> where is 'when'?
13:10:11 <ski> (note that the latter trick won't necessarily work in more complicated situatations)
13:10:15 <ski> @index when
13:10:16 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
13:10:23 <mcstar> thx
13:10:25 <ohgodno> ski: oh true
13:11:07 <ski> ku : of course, you only turn on it in the module defining the instance ..
13:11:34 <ohgodno> hpc: do you know a gentle introduction to cps ?
13:12:06 <ku> ski: would it be accurate to say that, generally, infix operations tend to be right associative and prefix functions tend to be left? Are there any usual heuristics to know?
13:12:14 <hpc> ohgodno: just cps, or Cont?
13:14:18 <ohgodno> hmm,
13:14:23 <ohgodno> hpc: just cps for now ?
13:14:42 <ohgodno> i don't think it wise to go into Cont without understanding cps first
13:14:47 <hpc> gimme a sec to do some hpasting
13:14:52 <ohgodno> thanks man
13:14:56 <hpc> i think i can come up with something good
13:16:27 <ski> ohgodno : eli's <http://tmp.barzilay.org/cont.txt> might be interesting
13:16:37 <ski> (it's using Scheme, though)
13:17:31 <beefcube> ok, what is the purpose or term of the use of "foos" in pattern matching? data Foos = Foos { optV :: Bool } .. foomaker :: (Foos -> Foos)  .. foomaker foos = foos { optV = True }, this isn't what I'm used to seeing in haskell so far, and I can't find documentation on it
13:18:16 <hpc> beefcube: it's record modification syntax
13:18:21 <ski> ku : the "invisible" juxtaposition operator, application, applying an `operator' expression to an `operand' expression as in `operator operand' is always left-associative
13:18:41 <hpc> foo {bar = baz} -- make another record exactly like foo, except with the bar field set to baz
13:19:18 <ski> ku : usually infix operators are declared either as (a) left-associative, using `infixl'; (b) right-associative, using `infixr'; or (c) non-associative, using `infix'
13:20:03 <beefcube> hpc: alright :/ thx
13:20:04 <ohgodno> heme
13:20:08 <ohgodno> ski: that is one massive file dude. it seems to be really well written though. and scheme is alright. luckily there isn't much to learn in terms of syntax when it comes to scheme
13:20:32 <ocharles> applicative: hmm, seems to be a problem with that paste
13:21:07 <ski> ku : also note that each infix operator has a precedence -- the associativity of the operators `++' and `**' in `foo ++ bar ** baz' are only considered in case the precedence is the same
13:21:17 <ocharles> applicative: on line #8, you liftIO . a2io, but a2io produces a Gen (DatabaseContext Property), not an IO a
13:21:46 <ski> ohgodno : i think i learned CPS by reading papers that used it -- can say how gentle that is, though :)
13:22:16 <ski> (specifically reading about CPS-transformation, and applications of continuations)
13:22:41 <ski> er, s/can/can't/
13:23:01 <hpc> ohgodno: okay, so beginner brain-bending:
13:23:08 <hpc> ohgodno: consider what this value means:
13:23:17 <ski> ohgodno : if you want to ask about something in that page, eli is in #scheme ..
13:23:18 <hpc> :t \f -> f "banana"
13:23:19 <lambdabot> forall t. ([Char] -> t) -> t
13:23:53 <hpc> ohgodno: it "contains" a string, in some sense
13:24:14 <hpc> and the 'f' there is the continuation
13:24:24 <hpc> which very informally, is "what happens next" to the string
13:24:32 <ocharles> it's worth emphasizing that (\f -> ...) is the whole value
13:24:37 <ocharles> ie, something you'd pass around
13:24:44 <hpc> yeah
13:25:07 <hpc> @let banana = \f -> f "banana"
13:25:08 <lambdabot>  Defined.
13:25:13 <hpc> > banana length
13:25:14 <lambdabot>   6
13:25:18 <hpc> > banana text
13:25:19 <lambdabot>   banana
13:25:25 <ski> ohgodno : seeing examples of functions written in CPS might also help
13:25:29 <hpc> > banana (\_ -> "oh crap")
13:25:30 <Mathnerd314> @src Cont return
13:25:30 <lambdabot> return a = Cont ($ a)
13:25:31 <lambdabot>   "oh crap"
13:28:11 <ski> > let product :: Num n => [n] -> n; product [    ] = 1; product (n:ns) = n * product ns  in  product [2,3,5,7]
13:28:12 <lambdabot>   210
13:28:16 <ski> > let product :: Num n => [n] -> n; product [    ] = 1; product (n:ns) = n * product ns  in  product [2,3,5,7,undefined]
13:28:18 <lambdabot>   *Exception: Prelude.undefined
13:28:21 <ski> > let product :: Num n => [n] -> n; product [    ] = 1; product (n:ns) = n * product ns  in  product [2,3,0,5,7,undefined]
13:28:22 <lambdabot>   *Exception: Prelude.undefined
13:28:39 <ski> @let productCPS :: Num n => [n] -> (n -> o) -> o; productCPS [    ] k = k 1; productCPS (n:ns) k = productCPS ns (\prod -> k (n * prod))
13:28:40 <lambdabot>  Defined.
13:28:49 <hpc> ohgodno: http://hpaste.org/68757
13:29:00 <ski> > productCPS [2,3,5,7] (\prod -> prod)
13:29:01 <lambdabot>   210
13:29:05 <ski> > productCPS [2,3,5,7,undefined] (\prod -> prod)
13:29:06 <lambdabot>   *Exception: Prelude.undefined
13:29:08 <ski> > productCPS [2,3,0,5,7,undefined] (\prod -> prod)
13:29:10 <lambdabot>   *Exception: Prelude.undefined
13:30:09 <hpc> ohgodno: if we evaluate divide 100 50 show, we get:
13:30:10 <ski> @let shortCircuitProductCPS :: Num n => [n] -> (n -> n) -> n; shortCircuitProductCPS [    ] k = k 1; shortCircuitProductCPS (0:_ ) _ = 0; shortCircuitProductCPS (n:ns) k = shortCircuitProductCPS ns (\prod -> k (n * prod))
13:30:12 <lambdabot>  Defined.
13:30:18 <ski> > shortCircuitProductCPS [2,3,5,7] (\prod -> prod)
13:30:20 <lambdabot>   210
13:30:22 <hpc> divide 100 50 show
13:30:23 <ski> > shortCircuitProductCPS [2,3,5,7,undefined] (\prod -> prod)
13:30:25 <lambdabot>   *Exception: Prelude.undefined
13:30:28 <hpc> show (100 `div` 50)
13:30:29 <hpc> show 2
13:30:30 <hpc> "2"
13:30:31 <ski> > shortCircuitProductCPS [2,3,0,5,7,undefined] (\prod -> prod)
13:30:33 <lambdabot>   0
13:30:46 <ski> ohgodno : consider that example ?
13:31:38 <hpc> ohgodno: evaluating divide 100 0 show, we hit the first pattern of divide and return "error: stuff"
13:33:37 <ski> of course, we can also define a short-circuit version of the original `product'
13:33:39 <hpc> ohgodno: http://hpc.dyndns-web.com:8000/blog/view.cgi?id=11 -- i have been told this is also a very good introduction to CPS, but it does so through ContT and gtk, so you might be overwhelmed
13:34:04 <ski> but it'll still perform the multiplications it's seen, so far
13:34:46 <JoeyA> Is there a type system trick that forces an argument to *not* be polymorphic?  Specifically, I'm trying to make a DSL for JavaScript, and I want to make the "function" constructor require at least one return statement in the supplied block.
13:34:46 <ski> @let shortCircuitProduct :: Num n => [n] -> n; shortCircuitProduct [    ] = 1; shortCircuitProduct (0:_ ) = 0; shortCircuitProduct (n:ns) = n * shortCircuitProduct ns
13:34:47 <lambdabot>  Defined.
13:34:58 <ski> > shortCircuitProduct [2,3,5,7]
13:34:59 <lambdabot>   210
13:35:01 <ski> > shortCircuitProduct [2,3,5,7,undefined]
13:35:03 <lambdabot>   *Exception: Prelude.undefined
13:35:03 <ski> > shortCircuitProduct [2,3,0,5,7,undefined]
13:35:05 <lambdabot>   0
13:35:27 <ski> > shortCircuitProduct [2,3,0,5,7,undefined] :: Expr
13:35:27 <ski> > shortCircuitProductCPS [2,3,0,5,7,undefined] (\prod -> prod) :: Expr
13:35:29 <lambdabot>   2 * (3 * 0)
13:35:29 <lambdabot>   0
13:35:55 <navaati> JoeyA: a type-system trick like "giving a type signature" ? but i may not understand your problem
13:36:22 * hpc should revisit javascript generation...
13:36:42 <navaati> javascript generation is evil
13:36:52 <hpc> it is, but such a fun evil
13:37:08 <navaati> really ? i would have tought it is hell
13:37:14 <JoeyA> I've seen HJavaScript, and I'll probably take a lot of ideas from it.
13:37:18 <jjl_> it's a terrible problem to solve and it's terrible solving it
13:37:31 <hpc> navaati: http://hpc.dyndns-web.com:8000/blog/view.cgi?id=9 - http://hpc.dyndns-web.com:8000/blog/view.cgi?id=10
13:37:38 <hpc> navaati: i warn you, they are poorly edited
13:38:12 <JoeyA> But I don't plan to use HJavaScript, partly because I'd have to fork it (it's a darcs repo hosted on patch-tag, and I prefer git and github).
13:39:03 <jjl_> i wanted to like patch-tag, but it's not a patch on github :(
13:39:19 <jjl_> i have issues with darcs' support for binaries
13:39:27 <JoeyA> Also, I plan to do things a little differently; mainly, treat the concrete definition as "internal" so bindings to e.g. jQuery can use their own types for things.
13:39:45 <JoeyA> I have issues with darcs' support for me trying to use it like git.
13:40:13 <JoeyA> e.g. how do I "git show" a commit, when none of the commits show hashes when I say darcs changes?
13:40:44 <jjl_> you need to not think of things in terms of git to get on with darcs
13:40:47 <applicative> ocharles: sorry, wandered off;  it started as pseudocode since I can't  compile it, it should have been fmap liftIO ... maybe? https://gist.github.com/27831ec7becc85754f22
13:41:01 <jjl_> i agree it's a comfortable mental model once you're used to it, but darcs is brilliant in its own way
13:42:05 <JoeyA> $ darcs send
13:42:08 <JoeyA> Launching the missiles...
13:42:26 <jjl_> darcs send is a brilliant way of managing projects
13:42:36 <jjl_> i happen to prefer github's pull requests, but darcs send is still awesome
13:44:17 <RylandAlmanza> So, what makes darcs the dominant revision control system for haskell? Is it just that it's made using haskell?
13:44:38 <jjl_> RylandAlmanza: it suits maths brains in its design
13:45:13 <jmcarthur> RylandAlmanza: i'd say that's the primary reason, but darcs has its own inherent advantages as well
13:45:17 <JoeyA> I don't think darcs is the dominant RCS for Haskell (at least not these days).  A lot of packages use github.
13:45:46 <jjl_> RylandAlmanza: you know darcs was originally c++, right?
13:45:50 <JoeyA> E.g. GHC, almost every dependency of yesod-platform (I could be wrong).
13:46:15 <jmcarthur> i, too, think git has most likely taken over the majority of active haskell projects
13:46:16 <JoeyA> err, GHC doesn't use github, I don't think
13:46:19 <RylandAlmanza> jjl_: I wasn't aware of that. I'm new to the haskell community.
13:46:21 <JoeyA> (uses git, though)
13:46:37 <JoeyA> http://darcs.haskell.org/ghc.git/
13:46:48 <jjl_> RylandAlmanza: DR found haskell would be the solution to a lot of bugs he was writing
13:47:43 * sm doubts most hackage packages are using git
13:48:05 <RylandAlmanza> Well, I really feel like I should learn darcs, but what really puts me off is the fact that there's no services as great as github for darcs as there is for git.
13:48:11 <jmcarthur> sm: me too. i only think the majority of *active* haskell projects are probably using git
13:48:17 <RylandAlmanza> (In my opinion.)
13:48:21 <sm> I see what you mean, maybe
13:48:27 <jmcarthur> RylandAlmanza: that's a pretty uncontroversial opinion i think
13:48:40 <jmcarthur> i still prefer darcs though
13:48:41 <sm> RylandAlmanza: not yet, it just needs building
13:48:42 <absence> is anyone using netwire?
13:48:50 <sm> there's darcsden as well as patch-tag
13:49:26 <jjl_> sm: is it worth using yet?
13:49:57 <RylandAlmanza> sm: I'm actually considering making a better service myself. I'm an experienced web developer, but unfortunately, I'm very new to haskell and functional programming. I could make it in a different language no problem, but that wouldn't be as fun. :)
13:50:15 * jjl_ thought bitbucket (hg) was okay, but still not close to github
13:50:16 <navaati> haskell for web is great
13:50:48 <RylandAlmanza> navaati: Do you use haskell for web, then?
13:51:04 <RylandAlmanza> What framework do you use (if any?)
13:51:10 <mgsloan> the best thing about darcs is its CLI.  Github's social aspects / higher contribution potential far outweigh these conveniences, though
13:51:39 <jmcarthur> RylandAlmanza: happstack, yesod, and snap are all excellent web libraries. and the best part is you can mix and match different pieces of them to your desire
13:52:22 <jmcarthur> RylandAlmanza: http://softwaresimply.blogspot.com/2012/04/hopefully-fair-and-useful-comparison-of.html
13:52:45 <Ralith>  /wind 23
13:52:47 <Ralith> er
13:53:08 <navaati> ok, i've played with it, not any serious stuff. but frameworks like yesod seems cool (and easy !) to use, with the additional haskell magic spice
13:53:53 <stepcut> RylandAlmanza: I used happstack, it's great!
13:54:12 <stepcut> s/used/use/
13:54:23 <jmcarthur> mgsloan: i think the best thing about darcs is how easy it is to just throw patches around. this goes deeper than just an intuitive interface. it goes all the way down to its model.
13:54:41 <jmcarthur> i've used both snap and happstack and like them both
13:55:03 <jmcarthur> i haven't given yesod a fair shot yet, but i lean toward the snap approach generally
13:55:15 <Eduard_Munteanu> Can you find existing templates for any of those?
13:55:32 <jmcarthur> Eduard_Munteanu: web site templates?
13:55:37 <stepcut> jmcarthur: how would you describe the difference between the snap and happstack approaches ?
13:55:58 <jmcarthur> Eduard_Munteanu: afaik all three have project starters included
13:56:15 <Eduard_Munteanu> jmcarthur: basically, I want to use them as some sort of toolkit and avoid touching HTML et al. altogether.
13:56:32 <jmcarthur> stepcut: i don't know that i'd say they difference is that huge between those two. they have made some different minor choices. nothing quite like the difference between either of them and yesod
13:56:46 <mgsloan> jmcarthur: true!  and I haven't experienced much actual collaboration using darcs.  The thing is, is how often are truly divergent, out of order patches used?
13:57:19 <mgsloan> while I do love the conceptual purity of it, if it makes the common case of linear patch histories inefficient, then that's bad
13:58:05 <Eduard_Munteanu> jmcarthur: so more like a WYSIWYM description of pages, I don't require any fancy layout / looks.
13:58:40 <stepcut> I like darcs because I can just check out a repo locally, create a patch, and darcs send it to the maintainer. Then I can wipe out my local repo. I feel like I am wasting bits every time I have to fork some github project just to send a patch
13:58:52 <mgsloan> I feel like if we're trying to capture dependencies between patches, then at that point we may aswell go all the way to the level of semantic analysis.
13:59:53 <mgsloan> stepcut: true, but that dynamic of github is very interesting.  It really encourages contributions, because your github repo-count is incremented.  Very good for one's github resume
14:00:06 <stepcut> :(
14:00:11 * stepcut has guests, gotta run
14:01:08 <mgsloan> it's not exactly ideal, and a little disingenuous, but it's good that there's larger reward for contribution
14:01:29 <mgsloan> I bet / hope github has a clever way of storing blobs that take advantage of duplication
14:02:56 <ku> ski: back, thanks for the explainations, really helpful
14:03:08 * hackagebot hsx-jmacro 7.1.1 - hsx+jmacro support  http://hackage.haskell.org/package/hsx-jmacro-7.1.1 (JeremyShaw)
14:04:53 <serialhex> mgsloan: if they're using freeBSD or a solaris deriv, then ZFS will take care of that easily.  i think they're trying to do that with btrfs, but idk if/when
14:05:27 <serialhex> ...i dont know if there is a working zfs on linux, and i dont know what they're gunning @ github
14:06:25 <mgsloan> It'd certainly make sense for them to use a system like that - ZFS is seriously cool stuff!
14:07:56 <serialhex> yes it is!  btrfs looks like it's getting there... but not quite yet
14:08:03 <sipa> serialhex: zfs-fuse
14:08:12 <sipa> works very well, actually
14:09:19 <serialhex> sipa: thanks for the info
14:09:57 * RylandAlmanza gives up his plan to make a github-like service for darcs
14:10:11 <serialhex> RylandAlmanza: why?
14:10:35 <c_wraith> there are at least two already
14:10:41 <c_wraith> better to contribute to one of them, probably
14:10:42 <RylandAlmanza> lol, that project would be a bit large for just me. I don't have a designer, and I'm not very creative. I'd probably just blatantly copy github
14:11:14 <sipa> serialhex: i even heard the next debian's installer will support zfs (to some extent)
14:12:48 <serialhex> sipa: really?  thats pretty spiffy.... i'll have to see if arch has an official package....
14:13:35 <navaati> btrfs is better than zfs on linux : easier to setup, better integration with the rest of the system
14:13:43 <jmcarthur> Eduard_Munteanu: oh you mean that kind of templates
14:13:50 <jmcarthur> Eduard_Munteanu: each has its own convention for that
14:15:06 <jmcarthur> Eduard_Munteanu: yesod has some type-safe template haskell dsl sort of thing. snap has a spiffy xml-ish thing where you can define customized tags via haskell. happstack is a bit more open ended here, but convention is to go with something like hsx i think
14:15:26 <jmcarthur> or blazehtml or something, perhaps
14:15:45 <jmcarthur> i really like snap's heist
14:15:59 <jmcarthur> again, it's not tied to snap in any way
14:16:21 <ku> jmcarthur: heist seems great, just wish it was white-space sensitive like haml/hamlet etc.
14:16:41 <Veinor> what's considered the canonical FRP paper?
14:16:52 <jmcarthur> hmm
14:17:06 <jmcarthur> Veinor: fran, maybe? since it was kind of the kickstarter...
14:17:24 <jmcarthur> can't say it's really the most motivating (don't think many are)
14:17:49 <Veinor> Eduard_Munteanu: note that you can use heist in yesod if you want to, and you can probably use hamlet (yesod's templating system) in snap (i've never tried)
14:17:58 <Veinor> jmcarthur: well, i'm more looking for something about what FRP is exactly
14:18:07 <jmcarthur> ah
14:18:08 <tgeeky> Veinor: conal elliot's paper
14:18:12 <Veinor> link?
14:18:16 <jmcarthur> tgeeky: he has several
14:18:18 <tgeeky> there probably isn't a bettter expositor than he
14:18:35 <jmcarthur> i'd go through the fran paper and the push pull paper
14:18:50 <jmcarthur> yampa might also be worth it though, since it introduces afrp
14:18:54 <tgeeky> probably use hamlet (yesod's templating system) in
14:18:54 <tgeeky>                 snap (i've never tried)
14:18:55 <tgeeky> err
14:18:59 <tgeeky> http://conal.net/papers/push-pull-frp/
14:19:32 <Veinor> i thought that said 1999 and was thinking 'huh conal's been around a lot longer than i thought'
14:19:51 <tgeeky> he has
14:19:56 <jmcarthur> Veinor: the core of frp, though, is that you can fully define a behavior for something in one place. its definition includes exactly the other reactive things that it depends on.
14:20:52 <Veinor> what if you have two mutually-dependent things
14:21:09 <jmcarthur> then you define them in a mutually recursive manner
14:21:21 <hpc> or TIME PARADOX
14:21:24 <Veinor> oh, right
14:22:23 <jmcarthur> anyway, this is in contrast to the usual stateful way of describing these things which doesn't constrain the dependencies to one place in your code
14:22:39 <jmcarthur> you can change a state here and then change it in another seemingly unrelated palce
14:22:41 <jmcarthur> *place
14:23:27 <jmcarthur> Veinor: conal's publications page has stuff as far back as 1982
14:23:55 <jmcarthur> the fran paper was from 1997
14:27:24 <Codex_> What you think of C++'s support of pure functional programming?
14:28:09 <companion_cube> without a GC, I think it's weak
14:28:29 <Codex_> companion_cube: it doesn't seem to have any memory problems whatsoever
14:29:14 <hpc> wait, are we talking about C++ or templates?
14:30:03 <companion_cube> Codex_: pure functional programming requires persistent data structures, which requries lots of small memory allocations
14:30:12 <companion_cube> and that is difficult to manage without a GC
14:31:11 <Codex_> companion_cube: it's not done like that. It's using c++'s classes/objects with all-const member functions. Data modifications are all found in compile-time.
14:31:58 <companion_cube> oh
14:32:34 <Codex_> but the memory problem is already solved in it.
14:32:43 <jmcarthur> how is it solved?
14:32:57 <Codex_> by not passing ownership around.
14:33:31 <Codex_> once you put member functions const and use reference data members, the memory thing just solves itself
14:33:49 <jmcarthur> i'm not quite sure what you mean, but this topic usually invokes associations with using data linearly, to me
14:33:54 <jmcarthur> which is pretty limited
14:34:09 <Codex_> what you mean by data linearly?
14:34:29 <jmcarthur> you can only consume it once instead of retaining it
14:36:13 <jmcarthur> in haskell i can use some persistent data structure and get backtracking almost for free. if i understand you correctly, this would still not be the case in purely functional C++
14:36:15 <Codex_> it's more like it just creates data structure, and then any part is available and lazy eval works.
14:36:37 <Codex_> but it constantly jumps between c++ interfaces.
14:37:14 <jmcarthur> this isn't making any sense to me. sorry, but i don't think i can really make any intelligent points in this conversation
14:38:01 <jmcarthur> it's been a while since i've used C++, and when i did write purely functional code in C++ i don't think my code had the properties you are talking about
14:38:13 <jmcarthur> so i must be missing some fundamental piece
14:38:52 <Codex_> jmcarthur: it's a specific pattern that is behind some difficult-to-find blocks in c++ language.
14:39:52 <Codex_> jmcarthur: it has blocks like "not using forward declarations" and "order of classes in header files is fixed" etc.
14:40:54 <Codex_> but the const member functions is giving the most important part, which is "pure" functional part.
14:42:48 <sm> jjl_: if you're already using darcs, yes it's worth using, if you're happy with github then not
14:43:16 <jmcarthur> Codex_: what does that have to do with purely functional programming?
14:43:27 <dmwit> If I have two threads, one of which only reads, can I use an IORef?
14:43:36 <jmcarthur> the other stuff i mean
14:43:40 <Codex_> jmcarthur: well, if you never modify any data...
14:43:53 <jmcarthur> Codex_: i mean all this stuff about forward declarations and such
14:44:23 <jmcarthur> dmwit: if they never have to block waiting on each other then i don't see why not
14:44:36 <dmwit> okay, great
14:44:39 <Codex_> jmcarthur: that's the reason why the support is difficult to use
14:44:58 <jmcarthur> dmwit: you can even sometimes use an IORef with multiple reading and writing threads if the modifications to the shared data are purely functional by using atomicModifyIORef
14:45:25 <dmwit> Oh, yes, I meant to put that in my question. In my scenario is it safe to not use the atomic write?
14:45:53 <jmcarthur> dmwit: the atomicModifyIORef action is only needed when you need to atomically read, modify, and write the value
14:46:03 <dmwit> okay
14:46:59 <jmcarthur> Codex_: those restrictions do indeed sound very linear in style to me
14:47:13 <jmcarthur> not quite the same, but similar restrictions
14:47:20 <ocharles> applicative: you are an absolute STAR
14:47:20 <ocharles> applicative: surprised i missed the obvious fmap, but this is finally working
14:47:20 <ocharles> now I can create arbitrary instances inside my database, and quick check my database! very fun :)
14:47:48 <dmwit> applicative++
14:49:29 <A1kmm_> Does anyone know of a way to define bracket that works on MonadIO rather than IO?
14:49:31 <ocharles> applicative: for the record, https://gist.github.com/76492077db2e289b245a is what i've ended up with
14:49:32 <A1kmm_> i.e. bracket' :: MonadIO m => m a -> (a -> m b) -> (a -> m c) -> m b
14:49:56 <dmwit> A1kmm_: No, it's not possible in general.
14:50:16 <ocharles> A1kmm_: maybe you want http://hackage.haskell.org/packages/archive/lifted-base/0.1.1/doc/html/Control-Exception-Lifted.html#g:9
14:50:28 <hpc> A1kmm_: http://blog.ezyang.com/2012/01/monadbasecontrol-is-unsound/ -- iirc, you don't want to
14:50:31 <A1kmm_> dmwit: Because there is no atomic way to turn off exception delivery?
14:50:55 <dmwit> http://blog.ezyang.com/2012/01/modelling-io/
14:51:24 <hpc> er
14:51:24 <hpc> http://blog.ezyang.com/2012/01/modelling-io/
14:51:29 <hpc> yeah, that
14:51:38 <copumpkin> A1kmm_: there's a whole bunch of work on figuring out the correct way to do that :/
14:51:43 <copumpkin> I don't think anyone has a conclusive answer
14:53:31 <Codex_> jmcarthur: try this c++ class and it'll give a way to try it: template<class T, class K> class Function {virtual K Map(T t) const=0; }; and then write few implementations of it.
14:53:56 <Codex_> jmcarthur: that's the basis of the functional part.
14:54:57 <Peaker> When CPU profiling Haskell, what cost centre is IO counted in?
14:55:45 <jmcarthur> shouldn't IO not be counted in a CPU profile at all?
14:55:59 <nejucomo> I can't find liftIO in mtl.  What's the mtl equivalent?
14:56:39 <jmcarthur> nejucomo: http://hackage.haskell.org/packages/archive/mtl/2.1.1/doc/html/Control-Monad-Trans.html
14:56:54 <jmcarthur> nejucomo: specially, the module Control.Monad.IO.Class that's included in that module
14:57:05 <dmwit> nejucomo: liftIO is in transformers
14:57:51 <nejucomo> huh, I wonder why I don't have the haddock for that.
14:57:53 * nejucomo runs reinstall.
14:58:48 <Peaker> jmcarthur, IO actions have computations in them, and some of them are opaque/hidden behind 3rd parties/ffi
14:59:27 <nejucomo> I've been confused several times between discrepencies in mtl versus transformers.  Are they complementary?
14:59:28 <Peaker> I'm getting nonsensical results in my CPU profile
14:59:46 <dmwit> Peaker: I don't know for sure, but I expect that you can make a cost center for IO actions, and that time spent in that action counts towards that cost center.
15:00:02 <dmwit> Peaker: However, keep in mind that the RTS isn't running during FFI calls, probably.
15:00:05 <hpc> nejucomo: mtl depends on transformers
15:00:34 <nejucomo> Uh oh.  Cabal says if I reinstall transformers that will break mtl, parsec, network, and many other important libraries.
15:00:36 <Peaker> The CPU profile is telling me that 12% of my time is spent in this def: viewStore = View.store
15:00:53 <Peaker> and View.store is just a record of actions
15:00:56 <dmwit> nejucomo: You should not reinstall transformers.
15:01:08 <Peaker> The Glorious Glasgow Haskell Compilation System, version 7.4.1 <-- is CPU profiling broken?
15:01:15 <dmwit> nejucomo: You should not reinstall any library listed as coming with GHC.
15:01:16 <dmwit> ?where hhl
15:01:17 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/
15:01:43 <hpc> Peaker: wonky cost centers?
15:01:49 <dmwit> Peaker: It's likely that running any of the actions in that record counts towards the viewStore cost center.
15:01:51 <nejucomo> dmwit: Ah, so I can import that package into ghci.  I just don't have the documentation for it.
15:01:53 <Peaker> hpc, I've not done any custom cost centres
15:01:54 <jmcarthur> i was under the impression (haven't tried it yet) that 7.4.1 had drastically *improved* profiling tools
15:02:17 <hpc> Peaker: i mean, i think that's what is wrong
15:02:24 <jmcarthur> Peaker: you used --auto-all and --caf-all or anything?
15:02:35 <Peaker> in my .cabal: ghc-prof-options:    -O0 -Wall -auto-all -caf-all -rtsopts
15:02:35 <hpc> but i probably wouldn't be able to tell even if i had your code
15:02:40 <jmcarthur> ah
15:03:29 <nejucomo> Is it possible to only update documentation for a package with cabal (without --reinstall) ?
15:04:07 <Peaker> dmwit, awesome! I added SCC pragma to each of the record fields, and it got more specific, thanks :)
15:04:44 <dmwit> nejucomo: I suppose you can cabal unpack && cabal haddock
15:04:58 * ski wonders whether Codex_ is using some kind of ref-counting smart pointers for the sharing ..
15:05:09 <Codex_> ski: no
15:05:56 <Codex_> ski: it's a std::vector + references as links between objects + constructors.
15:06:28 <ski> so how do you handle the case of a collection (or finite map), implemented as a tree, where you insert into it, getting a new tree (sharing most of its structure with the old tree) ?
15:07:17 <Peaker> so automatic cost centres aren't that great...
15:07:51 <Codex_> ski: yes, that works by push_backing one node to the end of std::vector and then linking that object via constructor to all old objects.
15:08:56 * ski isn't very familiar with C++, so doesn't know how `std::vector' is implemented (assuming an array that is sometimes reallocated)
15:09:42 <vraid> ski: it's reallocated when the size exceeds a new power of two
15:09:49 * ski nods
15:09:59 <Codex_> ski: like a tree would be one function P create_array(P *array, int count); and it'd just find the objects, create new node, push it to vector, link it to old objects and return handle.
15:11:03 <ski> Codex_ : yeah, but in general a whole path could need to be relinked, meaning more than one new node
15:11:22 <Codex_> ski: whole path?
15:12:18 <ski> say we're using some kind of BST (AVL or red-black or something)
15:13:16 <ski> then to insert, we follow the branches from the root, turning left alt. right depending on how the value (or key) to be inserted compares with the value (or key) in the current node
15:14:01 <ski> until we reach a tip of the tree, where we create a new node for the value (/ key-value pair)
15:14:12 <ski> if we were doing mutable trees, we'd be done here
15:14:29 <Codex_> well, the algorithm that keeps BST balanced might create large amount of new nodes :)
15:14:48 <ski> but if we want to be able to keep old references to the tree, unchanged, we also need to regenerate the nodes on the path from the root to the newly created node
15:14:50 <hpaste> Peaker pasted “SCC weirdness” at http://hpaste.org/68758
15:15:16 <Peaker> How is it that the aNameRef SCC gets charged 9.1% and the aDataRef one isn't taking it (aNameRef is trivially defined in terms of aDataRef)? Also there are no setter calls here, so all the costs should be from the getter, which also isn't charged. How come?
15:15:20 * ski is atm just trying to make sure we're talking about the same thing ..
15:16:03 <Codex_> ski: keeping old references is not a problem since you never remove any nodes from the std::vector.
15:16:07 <Peaker> time profiling is hard when you don't know what the profile results mean
15:16:12 <ski> Codex_ : yeah, but if the tree is "balanced enough", it should be proportional to the logarithm of the number of nodes in the tree (which is of course the point)
15:16:17 <jmcarthur> Codex_: ah, so you're talking about a world where you never gc
15:16:49 <Codex_> jmc: yup
15:16:57 <jmcarthur> then that doesn't solve any problems at all...
15:17:03 <jmcarthur> you're just going to run out of memory
15:17:03 <ski> jmcarthur : i suspect Codex_ is thinking about a local, manual, region-allocation and -deallocation -- when we're done with all the tree versions, we deallocate the `std::vector'
15:17:19 <jmcarthur> that's what it sounds like
15:17:59 <NolraiFib> How do I tell if the type for my domain spicific language is an monad, or just an arrow?
15:18:27 <dmwit> Can you implement the monad operations?
15:18:28 <ski> NolraiFib : try implement the primitives, and check the laws ?
15:18:29 <geekosaur> NolraiFib, try to define either bind and return, or fmap and join
15:18:32 <dmwit> If so, do they satisfy the laws?
15:18:34 <geekosaur> and insure that ... that
15:18:37 <Codex_> jmc: the memory actually worked like this: Env e; I interface(e); P p = interface.create_array(array, 10); // when Env disappears, the memory is freed.
15:18:56 <jmcarthur> NolraiFib: first, of course, it must have the right kind. then you have to be able to write reasonable implementations of return and bind. finally, you have to make sure that they satisfy the monad laws
15:19:13 <jmcarthur> Codex_: right, but that's not until the end of your entire algorithm
15:19:18 <Codex_> yup
15:19:25 <jmcarthur> Codex_: so if your algorithm is the entire program... you will never free anything
15:19:26 <Codex_> never does it in middle of the algorithm
15:19:48 <Peaker> the rules for CAFs and SCCs are so weird. If I define: f x = g "a" x   or  f = g "a"   I get different profiling results about time spent in f and g
15:19:53 <jmcarthur> heh, this sounds like C++ dual to Haskell's ST
15:20:09 <ski> Codex_ : so you must have control over how long (in the worst case) any datastructures that are backed by `env' must live, yes ?
15:20:31 <dmwit> Peaker: Well, those two functions can be significantly different.
15:20:58 <ski> Codex_ : i.e. if you need to return anything referencing such data-structures, that means that that function must take the respective `env' as argument ?
15:21:04 <dmwit> f x = g "a" x -- cannot reuse any data defined in g "a" when called with different values for x
15:21:33 <Codex_> ski: only the I like interfaces are taking env as constructor parameter.
15:21:49 <jmcarthur> Codex_: this idea can be generalized a bit. look into memory management with regions
15:22:11 <NolraiFib> Thanks all! I feel a little silly for asking the awnser was a bit obvious..
15:22:13 <Peaker> dmwit, yeah, I defined g points-free w.r.t x too, with lots of "where"d vars
15:22:16 <Peaker> dmwit, so it probably mattered
15:22:18 <Peaker> what is the benefit of "-caf-all"?
15:22:41 <hpc> Peaker: you can profile stuff like
15:22:50 <hpc> fibs = 0:1:zipWith (+) fibs (tail fibs)
15:23:01 <hpc> (and probably other things too)
15:23:10 <ski> Codex_ : jmcarthur is referring to <http://en.wikipedia.org/wiki/Region-based_memory_management> and the ML Kit
15:23:13 <Peaker> but doesn't -auto-all already cover that?
15:23:21 <jmcarthur> Codex_: but what you are describing is far from "solving the memory management problem"
15:23:38 <jmcarthur> regions get a bit closer, but then you are doing something like memory management anyway
15:23:38 <hpc> CAFs are handled for separately for reasons i don't know
15:23:41 <Peaker> oh, I see, without -caf-all, it attributes costs to the module, with -caf-all it attributes it to the CAFs, it's just a question of granularity?
15:23:54 <hpc> ah, that
15:24:02 <ski> Codex_ : i'm not quite sure what purpose `interface' serves here, but surely it's some kind of indirection -- i.e. it contains a reference to `env' ?
15:24:03 <hpc> if that's from the ghc manual
15:25:22 <jmcarthur> Codex_: think of it this way. the purpose of a GC is to make it appear that you have infinite memory. what you are doing is simply removing the GC without providing an alternative.
15:25:23 <Codex_> ski: yes, contains reference to env, and env keeps the std::vector, and then pure functions in the interface just pushes the data to env
15:26:08 * ski nods
15:27:17 <Hail_Spacecake> I'm trying to write a function that will change lower case ascii characters to uppercase
15:27:21 <Hail_Spacecake> and I came up with: changeToUpper :: Char -> Char
15:27:21 <Hail_Spacecake> changeToUpper c = if elem c lowercase
15:27:21 <Hail_Spacecake>     then uppercase !! (indexOf c lowercase)
15:27:21 <Hail_Spacecake>     else c
15:27:21 <Hail_Spacecake>         where lowercase = ['a'..'z']
15:27:21 <Codex_> jmcarthur: yes, I'm just relying that computers already have enough memory. (and my data is small enough)
15:27:22 <Hail_Spacecake>               uppercase = ['A'..'Z']
15:27:24 <Hail_Spacecake> --rewrite this with maybe's
15:27:26 <Hail_Spacecake> --or better yet just figure out whatever the haskell builtin is
15:27:28 <Hail_Spacecake> indexOf :: Eq a => a -> [a] -> Int
15:27:30 <Hail_Spacecake> indexOf element [] = 1000000
15:27:32 <Hail_Spacecake> indexOf element (x:xs) = if element == x then 0
15:27:34 <Hail_Spacecake>     else 1 + indexOf element xs
15:27:36 <Hail_Spacecake> er
15:27:38 <jmcarthur> Hail_Spacecake: don't paste so much here
15:27:40 <Hail_Spacecake> http://codepad.org/B7vbfqjW
15:27:41 <dmwit> Hail_Spacecake: Use hpaste.org in the future, please.
15:27:41 <Hail_Spacecake> sorry
15:27:42 <jmcarthur> hpaste.org
15:27:48 <Hail_Spacecake> meant to paste the pastebin link
15:27:59 <jmcarthur> > map toUpper "foo"
15:28:00 <lambdabot>   "FOO"
15:28:02 <ski> Codex_ : i'm not saying this is bad at all. still, you have to follow a certain discipline to use this -- something which isn't automatically checked (or automatically handled for you) iiuc
15:28:23 <dmwit> Hail_Spacecake: Also, you should not write this function; it's harder than you might think at first. Use the "text" package on Hackage instead.
15:28:40 <NolraiFib> Do StateT and PrompT comute?
15:28:46 <dmwit> http://hackage.haskell.org/packages/archive/text/0.11.2.1/doc/html/Data-Text.html#g:8
15:28:47 <ski> Codex_ : what region inference systems do, otoh, is *infer* where to allocate the regions (and therefore also when it's safe to free them)
15:28:57 <Hail_Spacecake> dmwit, well I wanted to do it as a learning exercise
15:28:59 <NolraiFib> s/comute/commute
15:29:07 <dmwit> alright
15:29:12 <Hail_Spacecake> but yeah this seemed like kind of a hacky way of doing it
15:29:14 <Hail_Spacecake> although it does work
15:29:15 <Peaker> I have   aDataRef str def = {-# SCC "aDataRef" #-} ...    and    aNameRef = aDataRef "Name" ""               and aNameRef gets all the blame for all the CPU work. That's weird
15:29:16 <jmcarthur> Hail_Spacecake: for the record, your function can be implemented as just (map toUpper)
15:29:57 <mcstar> ClaudiusMaximus: are you around?
15:30:00 <jmcarthur> well, that's for strings. i guess i didn't make sure that's the end goal;
15:30:05 <Hail_Spacecake> toUpper doesn't seem to be in scope
15:30:11 <jmcarthur> Hail_Spacecake: it's in Data.Char i think
15:30:17 <dmwit> ?index toUpper
15:30:18 <lambdabot> Data.Char
15:30:39 <jmcarthur> @src toUpper
15:30:39 <lambdabot> Source not found. My mind is going. I can feel it.
15:30:55 <ski> @type Data.List.findIndex
15:30:56 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
15:30:57 <Hail_Spacecake> also note that I had to write an indexOf function
15:30:58 <ski> Hail_Spacecake ^
15:31:04 <Hail_Spacecake> now, maybe I didn't need to do that
15:31:10 <Hail_Spacecake> but that also seems like a function that would be built in
15:31:27 <jmcarthur> :t lookup
15:31:29 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
15:31:41 <ski> @type Data.List.findIndex . (==)
15:31:42 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
15:32:08 <dmwit> :t \c -> lookup c $ zip ['a'..'z'] ['A'..'Z']
15:32:09 <lambdabot> Char -> Maybe Char
15:32:28 <Codex_> ski: I havent tried how well it works if I create complex algorithms that create large number of nodes for the tree. That's the only use case which I would think might need some work.
15:32:37 <Hail_Spacecake> like, in general
15:33:10 <Hail_Spacecake> is my strategy of "make a list of characters, find the index of the lowercase in that, and then return the character at the same index of the uppercase list" the right strategy to be doing?
15:33:16 <Hail_Spacecake> or is there a more efficient way of thinking about this problem?
15:33:27 <dmwit> There is a more efficient strategy for this problem.
15:33:35 <jmcarthur> Hail_Spacecake: most people do math on the ascii representation, but that's not even correct for unicode
15:33:46 <jmcarthur> Hail_Spacecake: it's really best *not* to write this particular function yourself :)
15:33:47 <Hail_Spacecake> I'm just asking to improve my knowledge, I know that I'd use toUppper for a real application
15:34:26 <jmcarthur> Hail_Spacecake: for ASCII, you can just do a bit of arithmetic on the numeric representation
15:34:39 <dmwit> For a real application, you should not use Data.Char.toUpper.
15:34:41 <ski> Codex_ : i think the main problem with more complex algorithms would be the cognitive burden of figuring out in which regions to allocate which stuff (including that if you goof up, you'll likely get non-working code, not merely inefficient)
15:34:42 <Eduard_Munteanu> jmcarthur, Veinor: I see. I also wonder if there's something like Markdown that supports forms and other kinds of things besides text.
15:34:57 <Hail_Spacecake> jmcarthur, yeah if this were C you'd do 'A' + (thisChar - 'a') or something, but I don't know if Haskell gives you access to the numeric represenation of chars like that
15:35:03 <Veinor> Eduard_Munteanu: ?
15:35:06 <jmcarthur> Eduard_Munteanu: pandoc's markdown allows some html. i wonder if it would allow forms :)
15:35:08 <Peaker> http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/profiling.html  speaks of "individual" and "inherited" times in the profile result. I get only one pair of times, how come?
15:35:10 <dmwit> Hail_Spacecake: Yes, you can do that.
15:35:18 <jmcarthur> :t ord
15:35:19 <lambdabot> Char -> Int
15:35:20 <jmcarthur> :t chr
15:35:21 <lambdabot> Int -> Char
15:35:24 <Veinor> actually
15:35:26 <ski> > chr (ord 'A' + (ord 'f' - ord 'a'))
15:35:27 <lambdabot>   'F'
15:35:30 <Hail_Spacecake> dmwit, not in haskell? since + doesn't take type char?
15:35:32 <Veinor> > 'A' + ('z' - 'a')
15:35:33 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
15:35:33 <lambdabot>    arising from a use of `GHC....
15:35:39 <jmcarthur> Hail_Spacecake: ord and chr
15:35:40 <ski> Hail_Spacecake : yes
15:35:44 <dmwit> Hail_Spacecake: You just need to cast more explicitly than in C.
15:35:45 <Veinor> oh i guess that makes sense
15:35:53 <mcstar> jmcarthur: i managed to improve on my prefix trie, ClaudiusMaximus's version runs half as fast as mine, but his one is basically a C program, mine uses only IO
15:35:57 <Hail_Spacecake> oh
15:36:12 <Hail_Spacecake> ah just like python
15:36:17 <Hail_Spacecake> wrt ord and chr
15:36:28 <jmcarthur> could also probably use toEnum and fromEnum
15:36:36 <Eduard_Munteanu> Hm, perhaps hamlet can take in Markdown as well, I wonder...
15:37:01 <Veinor> i don't think it can
15:37:17 <ski> Peaker : hm, weren't you thinking a bit about passing storage explicitly to functions in C which needed to allocate ?
15:37:25 <Eduard_Munteanu> It would be nice not having to deal with HTML at all.
15:37:49 <Eduard_Munteanu> Just like GTK doesn't require X API calls templating :P
15:38:03 <Peaker> ski, Yeah, and realized it's basically a reified stack
15:38:29 <ski> Peaker : hm, so not more related to regions, then ?
15:39:18 <Peaker> void f(int x) { { int y; ... }  {char z; ... } }        What I want is a data-type like   f.stack   which is a struct like { struct { int x } params; union { struct { int y; } a; struct { char z; } b; } locals }
15:39:49 <dmwit> wut
15:39:50 <Peaker> ski, I'm not sure -- the idea is that user-level threads can become really really cheap if the worst-case stack is explicitly allocated
15:40:06 <ski> hm, so a single activition frame, then ?
15:40:17 <Peaker> what do you mean by activation frame?
15:40:57 <ski> well, this `f.stack' doesn't look like it contains (references to) the rest of the stack, i.e. the activation frame of the caller of `f', and of its caller, &c.
15:41:31 <Peaker> ski, yeah, I missed that now :)  A return-address/async-callback is in there too
15:41:37 <ski> ok
15:42:18 <Peaker> currently we manually do this in our async code...
15:42:23 <ski> hm, so how does this help (green, i assume) threads ?
15:43:11 <Peaker> it makes stack allocations a static rather than dynamic thing (compile-time assurances without over-committing much memory for stacks)
15:43:43 <Peaker> so if you want your async engine to handle millions of concurrent things, it's nice that each can get its own "thread" without allocating even a full 4KB to each
15:43:47 <ski> you mean static per a single function call ?
15:44:35 <Peaker> if the function calls other functions, the reified stack of that function will contain nested reified stacks of the functions it calls -- so such a reified stack represents the stack of a thread
15:44:36 <ski> (otherwise, how do you handle recursion ?)
15:45:01 <Peaker> but recursion is a problem here, it would create an infinite struct, you have to put an explicit worst-case bound on it
15:45:28 <ski> tail calls are maybe problematic, as well (to express)
15:46:45 <Peaker> Normally under this method: void f() { local defs; g(); h(); }    f.stack { struct { local defs; } locals; union { g.stack a; h.stack b; } };
15:47:09 <Peaker> (and locals would also have the callback/return address)
15:47:22 * ski nods
15:47:25 <Peaker> If you want TCO, you just put the "locals" in a struct with g.stack, such that when the union selects h.stack, f.locals disappear
15:48:27 <ski> hm, ok
15:48:36 <ski> so tail-recursion would work, at least
15:48:43 <Peaker> btw, if the threads are also cooperative (likely) you can actually use 2 stacks -- one for variables that need to persist across yield points (context switches) and one for those that don't, and thus you can make the threads even cheaper
15:49:33 <ski> (`f' tail-calling `h' tail-calling `f' tail-calling `h' tail-calling `i' tail-calling `f' tail-calling ...)
15:49:34 <Peaker> with ordinary threading frameworks, even the cheapest threads contain lots of temporal/redundant data in their stacks that explicit event handlers would not keep around
15:49:38 <Peaker> ski, yeah
15:50:30 <Peaker> If you have reified stacks with persistent/non-persistent variables, you can keep around in the thread's stack (the expensive part) only the exact things that you would put there in an explicit event data allocation using manual event handling
15:53:00 <ski> hm -- i wonder how to handle higher-order functions
15:54:10 <Peaker> I guess you could do that with parameteric polymorphism/templates if you parameterize the function and its reified stack over the type of stack of the function its given
15:54:36 <Codex_> ski: that might be difficult I think
15:55:50 <ski> templating/expansion seems hard to avoid if you want to do it fully statically, yes
15:57:11 <ski> hm .. and then there's closures, hm
16:10:19 <Peaker> what is the precedence of {-# SCC ... #-} ?
16:11:30 <hpc> precedence?
16:11:36 <hpc> it's parsed as a comment
16:12:27 <shachaf> It's not quite parsed as a comment.
16:13:26 <Peaker> found a ticket about it.. it apparently parses like a lambda, extending as far right as it can
16:16:33 <Peaker> hmm.. https://github.com/Peaker/bottle/blob/master/codeedit/Editor/Main.hs#L80 is said to be taking ~10% of all runtime, but all it does is call other heavy code, and doesn't do anything heavy on its own
16:18:17 <otters> aww why can't I use ← instead of <-
16:18:23 <Peaker> when I defined SCC's inside a top-level def, does the top-level SCC still get charged directly and appear in the top-time-spenders?
16:18:26 <sipa> otters: you can?
16:18:37 <otters> nah, I get a "not in scope: ←"
16:18:56 <sipa> otters: http://www.haskell.org/haskellwiki/Unicode-symbols
16:19:16 <Peaker> I wish people kept code ascii for now.. unicode editing is a world of pain
16:19:51 <alpounet> Peaker, i think so
16:21:01 <Peaker> alpounet, time-profiling seems so hard so far :(
16:21:13 <Peaker> I can't get a sense of where I'm spending time.. Maybe I just don't have too many hotspots
16:21:44 <otters> can I have a socket created with listenOn not actually open until I want to write to/read from it?
16:22:35 <sipa> Peaker: it's something that's almost guaranteed to be easier in an imperative language...
16:23:21 <Peaker> sipa, I think it's more a laziness issue than a functional issue
16:23:25 <otters> rather, connectTo
16:23:29 <otters> I don't care about listenOn
16:23:38 <sipa> Peaker: agree
16:24:10 <Peaker> otters, you could make a record with read/write actions that connect lazily
16:24:26 <alpounet> Peaker, and the other SCCs (the ones you put inside mainLoopDebugMode) do not help ?
16:24:32 <otters> how would I make it connect lazily
16:26:14 <Peaker> alpounet, don't seem to make a difference
16:26:26 <Peaker> alpounet, I add SCCs to parts of mainLoopDebugMode and I still get 9% of my time spent in it
16:26:47 <alpounet> but something neglectable for these "subparts" ?
16:27:29 <andares> hey, can someone give me an example of functions being used as applicative functors?
16:29:07 <andares> I'm having trouble thinking about what that would be.
16:30:28 <hpaste> Peaker pasted “Lazy IO values” at http://hpaste.org/68760
16:30:40 <Peaker> otters, Here's an example ^^
16:31:03 <otters> hm
16:31:04 <Peaker> > liftA2 (/) sum length [1,2,3,4,5,6]
16:31:06 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
16:31:06 <lambdabot>    arising from a use o...
16:31:14 <Peaker> > liftA2 (/) sum genericLength [1,2,3,4,5,6]
16:31:15 <lambdabot>   3.5
16:31:30 <Peaker> @type liftA2 (/) sum genericLength
16:31:31 <lambdabot> forall a. (Fractional a) => [a] -> a
16:32:21 <Peaker> andares, The functions sum and genericLength are used as Applicatives
16:32:35 <Peaker> alpounet, oh, sorry, I didn't see you responded
16:32:47 <mparodi__> why foo is not updated when I do: let bar x = 123 \n let foo x = bar x \n let bar x = 321 --?
16:32:53 <Peaker> alpounet, Negligible sub-parts? I don't know, I marked virtually everything in there as its own SCC
16:32:58 <mparodi__> foo 1 is still 123
16:33:18 <Peaker> mparodi__, "let" doesn't do destructive updates
16:33:34 <alpounet> mparodi__, because at the moment foo is defined
16:33:37 <Peaker> mparodi__, the second "let bar x =" is defining a whole new "bar" that is said to "shadow" the outer bar
16:33:45 <alpounet> for the compiler, bar is still constant equal to 123
16:34:13 <alpounet> i mean, it's the function that gives you back 123 whatever argument you give it
16:34:32 <applicative> > let even_or_small = (||) <$> even <*> (<6) in map even_or_small [1 ..12]
16:34:33 <lambdabot>   [True,True,True,True,True,True,False,True,False,True,False,True]
16:34:47 <mparodi__> alright, it makes sense.. is there a way to update foo without redefining it?
16:35:22 <byorgey> mparodi__: no, you cannot update anything in Haskell.
16:35:34 <sipa> Variables aren't.
16:35:49 <alpounet> mparodi__, i guess you are (relatively) new to haskell. are you learning with a book?
16:35:50 <byorgey> (this is a feature, not a bug ;)
16:36:22 <alpounet> if not, i'd suggest LYAH, it'll tell you a lot about this, among many, many, many other things
16:36:23 <mparodi__> <alpounet> mparodi__, i guess you are (relatively) new to haskell. are you learning with a book?
16:36:25 <mparodi__> yep ^
16:36:46 <mparodi__> I'm trying weird things in order to understand how it works
16:36:49 <alpounet> LYAH = Learn You A Haskell
16:36:51 <alpounet> @where lyeah
16:36:51 <lambdabot> I know nothing about lyeah.
16:36:54 <mparodi__> I don't really need to do that, don't worry :P
16:36:55 <alpounet> @where lyah
16:36:55 <lambdabot> http://www.learnyouahaskell.com/
16:37:10 <mparodi__> I'm reading The Craft of Functional Programming
16:37:57 <alpounet> mparodi__, well, the point is that in haskell, things are different. you don't update variables etc, you just compute new stuffs from values you have around
16:38:08 <otters> which makes gc easier
16:38:22 <sipa> and most of all, makes reasoning about code easier
16:38:24 <andares> hm, I don't really understand liftA2.
16:38:35 <sipa> :t liftA2
16:38:36 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
16:38:36 <otters> :t liftA2
16:38:37 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
16:38:39 <otters> oh you
16:39:12 <alpounet> mparodi__, a good and simple example of that is for/while loops becoming recursive functions. instead of updating some 'i' variable like you'd do in C, Java etc, the function calls itself with some new arguments.
16:39:42 <sipa> andares: it takes an operation that normally operates on 2 arguments, and lifts that to an equivalent operation on applicative versions of those arguments
16:39:55 <otters> ((->) r) is an applicative
16:40:02 <otters> which is easier to write (r ->)
16:40:09 <otters> although that's not valid
16:40:40 <andares> applicative versions?
16:40:42 <otters> andares: so if you substitute that in for "f" in liftA2's type signature, you get (a -> b -> c) -> (r -> a) -> (r -> b) -> (r -> c)
16:41:02 <mparodi__> alpounet, I know but in that case it's somehow different. you're invoking bar, and bar is another function that is defined somewhere else, you would expect that if you redefine bar you change the behavior of foo
16:41:05 <applicative> it is sometimes pointed out that in this case <*> is the S combinator
16:41:21 <mparodi__> now I know it create another "bar"
16:41:25 <mparodi__> creates*
16:41:31 <otters> :t liftA2 (+) succ pred
16:41:32 <lambdabot> forall a. (Num a, Enum a) => a -> a
16:41:47 <otters> > liftA2 (+) succ pred 3
16:41:48 <lambdabot>   6
16:41:49 <geekosaur> mparodi__, part of your confusion is that you're using do notation so you can't see that the two "bar"s are not in the same scope
16:41:51 <alpounet> mparodi__, well, not in haskell, actually! because when foo is defined, it captures altogether what's used in its "body"
16:41:53 <andares> otters: ah, so it sort of applies r->a and r->b to r to get an a and b, then uses them as operands to (a->b->c)!
16:41:56 <otters> yes
16:42:06 <andares> confusing! I don't have this applicative thing down.
16:42:15 <alpounet> so it really doesn't care about the other bar
16:42:16 <otters> so it does (succ 3) and (pred 3) and then applies (+) to both
16:42:16 <mparodi__> <geekosaur> mparodi__, part of your confusion is that you're using do notation so you can't see that the two "bar"s are not in the same scope
16:42:17 <geekosaur> it's let bar ... in let foo ... = bar ... in let bar ...
16:42:24 <mparodi__> what's the do notation, geekosaur?
16:42:26 <geekosaur> each "in" indicates an inner scope
16:42:30 <otters> andares: the ((->) r) monad/functor is /really/ weird
16:42:34 <otters> for people who aren't used to it
16:43:08 <otters> andares: an easier example is fmap, which for (r ->) is synonymous with (.)
16:43:10 <otters> :t fmap
16:43:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:43:12 <geekosaur> I assume you are typing this inside ghci, so you are getting it implicitly.  if you haven't reached that point yet... suffice it to say that it's a trick of syntax which is sometimes confusing
16:43:18 <otters> (a -> b) -> (r -> a) -> (r -> b)
16:43:42 <otters> :t (.)
16:43:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:43:47 <otters> oh, same thing
16:43:47 <geekosaur> and in ghci, each line is a different scope that can see but not modify earlier lines/scopes
16:44:04 <otters> well, ghci yields (b -> c) -> (a -> b) -> a -> c
16:44:34 <andares> otters: so liftA2 is a generalization of fmap?
16:44:35 <sipa> (b -> c)    ->    ((a->b) -> (a->c))
16:45:27 <mparodi__> ok, I think I got why it doesn't work as I expected. thanks guys!
16:45:37 <otters> no, liftA2 and fmap are not related
16:45:49 <otters> well, actually, they sort of are
16:45:52 <byorgey> andares: yes, you can think of it that way
16:46:05 <byorgey> sure they are
16:46:05 <otters> liftA2 is just fmap with another argument, isn't it
16:46:12 <alpounet> mparodi__, cool, do not hesitate to come back with other questions
16:46:18 <byorgey> liftA2 is like fmap but for binary instea d of unary functions
16:46:22 <otters> yeah
16:46:28 <andares> otters: oh, is there an identity function Haskell defines?
16:46:30 <otters> man, silly me
16:46:34 <otters> :t id
16:46:35 <andares> or do you just write out \x -> x
16:46:35 <lambdabot> forall a. a -> a
16:46:37 <andares> ahh
16:46:43 <byorgey> the interesting point is that Functor is not strong enough to define liftA2.
16:47:06 <byorgey> but once you have liftA2 you get all other liftAN for free.
16:47:08 <andares> so fmap f x is the same as liftA2 f id x, right?
16:47:23 <byorgey> andares: no, that doesn't type check
16:47:28 <andares> wait, d'oh.
16:47:30 <andares> I should have checked the kind.
16:48:12 <alpounet> Peaker, bottle looks cool by the way, please announce it on reddit or something when you have a first version up on hackage, will remind me to try it out
16:49:01 <andares> byorgey: is Functor just not strong enough because it expects (a->b) instead of (a->b->c)?
16:49:54 <byorgey> andares: I mean, you could imagine using fmap somehow, perhaps multiple times, in order to implement liftA2
16:49:59 <otters> fun fact: for ((->) r), pure is equivalent to const
16:50:01 <byorgey> but if you try it you will find that you cannot.
16:50:17 <andares> @type const
16:50:18 <lambdabot> forall a b. a -> b -> a
16:50:34 <alpounet> const x y = x
16:50:37 <otters> @type pure
16:50:39 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
16:50:48 <byorgey> note that  (a -> b -> c) = (a -> (b -> c)), i.e. all functions are really one-argument functions
16:51:03 <byorgey> so you CAN use fmap on a function of type  a -> b -> c
16:51:22 <Peaker> alpounet, Sure, but it's very preliminary :)
16:51:34 <Peaker> alpounet, did you try to run it, or just from checking out the code?
16:51:49 <byorgey> put another way, any function which expects something of type  (a->b) will happily accept an argument of type  (c->d->e), with a = c  and b = d -> e
16:52:06 <alpounet> Peaker, heh. just checked out the code a bit and the cabal file. would you happen to have a screenshot or two to share?
16:52:22 <andares> huh.
16:52:35 <andares> :t <*>
16:52:36 <lambdabot> parse error on input `<*>'
16:52:43 <andares> :t (<*>)
16:52:43 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:53:41 <Peaker> alpounet, much of the fun is in the smooth OpenGL animations, and wouldn't be felt in a screenshot, but I can send if you want.. Or you can build it by git-cloning git://github.com/Peaker/graphics-drawingcombinators.git - installing that, and then installing bottle
16:54:01 <andares> so if you had ((->) r) that you were doing <*> over, i'd look like (r -> (a->b)) -> (r -> a) -> (r -> b), right?
16:54:20 <byorgey> yep
16:54:33 <Peaker> andares, Yeah, though it is useful for understanding to re-write that type without the redundant () (since -> is right-associative)
16:54:44 <Peaker> andares, for example,  (r -> (a -> b)) is the same as (r -> a -> b)
16:54:54 <andares> ah, true.
16:55:12 <andares> I had no idea you could do that with functions. my mind is melting.
16:55:36 <Peaker> alpounet, Now the problem is that when having too many entities on screen, the 60 frames per second animations are no longer held up, and I get less than that at 100% cpu, which is a real bummer
16:55:49 <XexonixXexillion> > ((+) <*> succ) 5
16:55:49 <lambdabot>   11
16:55:59 <andares> it seems like it's actually some functor between a category of functions from a -> b and something else.
16:56:05 <alpounet> Peaker, i'm on windows right now, so i'll try installing it but i can't promise it'll work :P
16:56:06 <Peaker> (f <*> g) x  = f x (g x)
16:56:25 <Peaker> alpounet, ah, Windows is always so difficult :)
16:56:33 <alpounet> Peaker, uh? how "much" is "too much entities"?
16:56:35 <andares> and you know f is of type a->b->c?
16:56:58 <andares> is that just a property of applicability?
16:59:29 <shachaf> What abstracts the pattern foo [] = undefined; foo [x] = x; foo (x:x':xs) = foo (...x...x'...xs)?
17:00:45 <Peaker> alpounet, Not that much, unfortunately :) Thus, the CPU profiling
17:00:53 <alpounet> uh, alright
17:00:58 <Peaker> alpounet, Maybe 100 or such
17:01:29 <alpounet> Peaker, getting an error while building graphics-drawingcombinators. 'unless' not in scope in Graphics/DrawingCombinators.hs
17:01:42 <dekuked> hey does anyone know when realworldhaskell will be back up?
17:02:39 <Peaker> alpounet, weird.. let me see if I messed up that push
17:03:07 <alpounet> (line 350)
17:03:49 <Peaker> alpounet, is the git hash 687454e5032 ?
17:03:54 <byorgey> shachaf: {fold,scan}{l,r}1?
17:03:54 <Peaker> (you can use git log -1 to see it)
17:03:58 <dmwit> ?djinn (a, Either b c) -> Either (a, b) (a, c)
17:04:00 <lambdabot> f (a, b) =
17:04:00 <lambdabot>     case b of
17:04:00 <lambdabot>     Left c -> Left (a, c)
17:04:00 <lambdabot>     Right d -> Right (a, d)
17:04:15 <Peaker> alpounet, oh, I see!
17:04:22 <Peaker> alpounet, it's #ifdef'd out in my build, I'll fix it, sec
17:05:18 <alpounet> Peaker, in the meantime, i just wrote it myself
17:05:23 <Peaker> alpounet, can you try "git pull" and rebuild?
17:07:40 <dekuked> also, does anyone know what zlib I'm supposed to install in debian for a cabl install cabal-install to work? it says * Missing header file: zlib.h
17:07:40 <dekuked> * Missing C library: z
17:07:53 <dekuked> I've installed zlib-bin and zlibc
17:08:04 <alpounet> Peaker, pulled. now it annoys me with FTGL, that i don't have here, despite it not being specified with -f
17:08:14 <byorgey> dekuked: you probably need something like zlib-dev
17:08:19 <alpounet> dekuked, you probably also need the -dev version
17:08:35 <alpounet> (that's the one that contains the header file)
17:08:36 <Peaker> alpounet, a cabal bug?
17:08:45 <alpounet> Peaker, i have no clue
17:08:58 <Peaker> alpounet, maybe remove ftgl dep from .cabal file?
17:09:00 <alpounet> when i do cabal configure, it just doesn't care about FTGL
17:09:10 <alpounet> when i then do cabal install, bam
17:09:11 <Peaker> but then the linkage fails?
17:10:18 <geekosaur> dekuked, zlib1g-dev
17:10:25 <geekosaur> (debian stable at least)
17:10:32 <Dowal> hey guyes
17:10:39 <Dowal> quick syntax question.
17:10:47 <Peaker> alpounet, at the dep check of the install process? Maybe the flag isn't being passed on in install?
17:10:48 <Dowal> I have my main = xmonad =<< statusBar myBar myPP toggleStrutsKey defaults
17:11:07 <alpounet> Peaker, that's the contrary
17:11:13 <alpounet> it looked for Graphics.Rendering.FTGL
17:11:28 <Dowal> what is the correct syntax to add the withUrgencyHook NoUrgencyHook?
17:11:34 <alpounet> it "automatically" activates the ftgl flag when cabal installing
17:11:38 <alpounet> not when cabal configuring
17:11:44 <Dowal> I'm trying to follow pimp your xmonad #4
17:12:12 <Peaker> alpounet, I have no idea how cabal decides to set up flags.. maybe you can manually edit the .cabal file for now?
17:12:42 <alpounet> Peaker, anyway, i just removed all the if/else in cabal
17:12:43 <alpounet> it worked
17:12:47 <alpounet> git cloning bottle now
17:13:03 <Peaker> alpounet, cool, I think "cabal install bottle" should hopefully work then..
17:13:20 <byorgey> Dowal: you should also try asking in #xmonad
17:13:23 <geekosaur> Dowal, you can apply it to defaults or to xmonad.  "xmonad . withUrgencyHook NoUrgencyHook =<< ..." or "(withUrgencyHook NoUrgencyHook defaults)"
17:13:23 <Peaker> (unfortunately, due to poor maintainership from the bitmap* packages guy, need to do the graphics-drawingcombinators hack)
17:13:37 <geekosaur> and yes, #xmonad is preferable for xmonad-related questions
17:13:57 <alpounet> Peaker, if it's not a regression in any regard, you could ask luqui to upload that fix
17:14:23 <Peaker> alpounet, it's basically inlining the BSD code from the bitmap package to fix a bug that he won't
17:14:31 <Peaker> and luqui has been ignoring my pull requests/mails for a while
17:14:32 <Dowal> byorgey, will do next time. As it was a syntax related question I thought I'd ask here first
17:14:42 <alpounet> Peaker, oh...
17:14:53 <Dowal> geekosaur ! awesome so function composition was the right way
17:14:57 <alpounet> that's going to be annoying if bottle gets released and has some (relative) success
17:15:18 <geekosaur> one of the right ways, at least
17:15:51 <Dowal> thanks!
17:16:42 <Peaker> alpounet, it's going to take years... it's very preliminary work, and it's an ambitious project
17:17:48 <alpounet> Peaker, yeah, that gives some time to think about a workaround i guess :P anyway, installing the dependencies for bottle... i have to install berkeley db uh
17:19:01 <McManiaC> hey guys, the configure script of the "curl" package can't find my curl library (freebsd, located in /usr/local/lib) - what can I do?
17:19:19 <McManiaC> I tried cabals --extra-dir flags but it doesnt work
17:20:05 <NolraiFib> What's bottle?
17:20:09 <applicative> hmm, knukevec4minus: internal error: evacuate: strange closure type 61440
17:20:21 <applicative> does this mean I have to leave the building?
17:20:48 <alpounet> Peaker, i think it'll wait at least until tomorrow, getting tired. will keep you posted!
17:22:21 <gienah> McManiaC: you could try configure --verbose=3 and look at the output, and maybe try --extra-include-dirs as well as --extra-lib-dirs
17:28:33 <zzo38> Can you use something like this for random number generators?    class GenRandom x where { genRandom :: Free ((->) Bool) x; };
17:29:30 <gienah> McManiaC: another guess is to check this prints at least -lcurl : pkg-config --libs libcurl # tweaking PKG_CONFIG_PATH if necessary
17:30:58 <McManiaC> gienah: λ nils@n-sch.de. pkg-config --libs libcurl
17:30:59 <McManiaC> -L/usr/local/lib -lcurl
17:31:26 <McManiaC> gienah: and I used both those --extra flags
17:31:29 <McManiaC> for cabal
17:33:02 <gienah> McManiaC: I guess you need to try configure --verbose=3 and look at the output (as it will say it can't find the library in circumstances where it can't perform its test link)
17:33:24 <zzo38> Which way works better for random number generator in Haskell? Maybe you also want to be able to specify a parameter what to ask? Then you can, for example, specify the range of numbers to generate. It has to be a power of 2, but if it isn't, one way to fix this is, generate a number with the number of bits needed, and if it is not in range, try again until you get a value in the requested range.
17:34:59 <Eduard_Munteanu> gienah: hey. I see you contributed the latest agda package in Portage. However it doesn't give me the agda-mode executable, any idea why?
17:36:34 <zzo38> Another way is notice that, in Pokemon Card, the card DIGGER results in hitting yourself 2/3 chance and hitting opponent's card 1/3 chance.
17:36:52 <gienah> Eduard_Munteanu: I'll try building it and check (thanks for reporting)
17:38:17 * hackagebot GLUT 2.1.2.2 - A binding for the OpenGL Utility Toolkit  http://hackage.haskell.org/package/GLUT-2.1.2.2 (ChrisDornan)
17:39:15 <andares> hey, is it possible for ghci to derive applicative? :)
17:40:13 <zzo38> andares: Can you elaborate on that?
17:40:46 <gienah> Eduard_Munteanu: I didn't know there was was a agda-mode executable, sci-mathematics/agda with emacs use flag includes: /usr/share/emacs/site-lisp/agda/agda2-mode.el
17:41:04 <andares> I guess that for a given type, it could try to implement Applicative for it such that it satisfies the laws of applicative functors. I don't know too well what I mean, though.
17:41:52 <zzo38> andares: There may be many possible applicatives for a certain type; however, Functor can be derived since it is only one.
17:42:28 <zzo38> And, if you have fmap you then can define Applicative by liftPair instead of (<*>) except that the classes are not designed to let you to do that.
17:42:30 <andares> ah, okay.
17:43:22 <robstewartuk> has 'anyP' been removed from dph ? http://goo.gl/oInJb but not in http://goo.gl/rSl6E
17:43:26 <JoshTriplett> What should I use if I want showIntAtBase for an arbitrary number type rather than just Int?
17:43:40 <RylandAlmanza> Is there a floor function in haskell?
17:43:51 <zzo38> RylandAlmanza: Yes
17:43:53 <alpounet> @type floor
17:43:53 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
17:44:11 <RylandAlmanza> Cool, thanks
17:44:26 <applicative> > floor 3
17:44:27 <lambdabot>   3
17:44:35 <favonia> JoshTriplett: showIntAtBase :: (Integral a) => a -> String ?
17:44:44 <weasels> :t floor
17:44:45 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
17:45:13 <JoshTriplett> favonia: Silly me for making assumptions based on the name; I'd seen a reference mentioning that it required an Int.
17:45:14 <JoshTriplett> Nevermind.
17:45:34 <Eduard_Munteanu> gienah: hm, I just removed my ~/.emacs, and it seems to work without 'agda-mode'. I thought you needed to do 'agda-mode setup', but perhaps not if it's a system-wide install.
17:45:43 <zzo38> (Commutative applicatives are those for which (<*>) = flip (<**>)) (I think)
17:46:43 <zzo38> (Or, fmap swap . liftPair = liftPair . swap) (I would think)
17:46:58 <applicative> zzo38 did you see there  is now the MonadZip class, which requires liftPair under the name of mzip; it is used by the 'MonadComprehension' extension
17:47:41 <zzo38> applicative: That is for monads not for applicatives in general, though
17:47:56 <applicative> yes, it just complicated the chaos
17:48:06 <applicative> complicates rather
17:49:08 <Eduard_Munteanu> gienah: though I think it makes sense to include agda-mode as well so you don't need to alter ~/.emacs (since it calls 'agda-mode locate' if setup has been run)
17:49:42 <applicative> it has the effect though that the 'ZipList' applicative instance for lists is secretly available without the ziplists
17:50:52 <gienah> Eduard_Munteanu: thanks, I'll try it later and check it works
17:51:00 <zzo38> applicative: Yes, it does allow that, you can make the zipped applicative for something
17:51:16 <applicative> > [x * y | x <- [1..10] | y <- [1,10..100]]
17:51:17 <lambdabot>   [1,20,57,112,185,276,385,512,657,820]
17:52:02 <applicative> > [x * y | x <- [1..10] | y <- [0,10..100]]
17:52:03 <lambdabot>   [0,20,60,120,200,300,420,560,720,900]
17:52:07 <Eduard_Munteanu> Neat, thanks.
17:54:08 * applicative kant haskell today he has the dumb
17:55:04 <hpc> applicative: it's the typechecker's fault for not knowing what you wanted
17:56:09 <applicative> but I always think to myself "Even if no one else understands me, still, the Glasgow Haskell Compiler understands me"
17:56:47 <hpc> @remember applicative Even if no one else understands me, still, the Glasgow Haskell Compiler understands me
17:56:47 <lambdabot> Done.
17:57:11 <hpc> The Glorious Glasgow Haskell Compilation System
17:57:48 <hpc> i wonder if the number of superfluous words in the name of a compiler is like people who buy big trucks to compensate for something...
17:57:52 <weasels> what do you guys use for logging
17:58:04 <hpc> weasels: chainsaw, usually
17:58:09 <applicative> three by five cards?
17:58:10 <zzo38> Why is it not permitted to enter "data instance" if "type instance" is expected?
17:58:18 <hpc> for the big ones, get one of those giant machines
17:58:22 <weasels> hpc: I don't see it on hackage
17:58:31 <hpc> weasels: joke :P
17:58:37 <weasels> yeah, I was trolling
17:58:39 <hpc> heh
17:58:55 <hpc> man, chainsaw would make an awesome name for a logging lib
17:59:06 <zzo38> hpc: I suppose so.
17:59:10 <weasels> think it's time
17:59:12 <weasels> to make that lib
17:59:33 <hpc> usually when i want to log something, i just "2> logfile"
17:59:46 <weasels> yeah
17:59:51 <weasels> I was thinking about colored output and stuff like that
17:59:55 <weasels> maybe I should just write my own
17:59:55 <zzo38> hpc: Yes I would think that better
17:59:58 <weasels> putstrln helper
18:01:00 <weasels> so like, would it be possible to have a function that takes x and executes "putStrLn x" if x is a string and "print x" otherwise
18:01:30 <hpc> actually, yes
18:01:32 <zzo38> weasels: Probably with -XOverlappingInstances it could be done
18:01:34 <hpc> but it's horrific
18:01:38 <zzo38> Maybe other ways too
18:01:41 <weasels> okay, maybe I won't bother then
18:01:47 <hpc> zzo38: it takes something more recent than that, i thought
18:02:06 <weasels> I'll just use Text.Printf
18:03:14 <zzo38> instance Show x => F x where { f = print; }; instance F String where { f = putStrLn; };
18:03:25 <JoshTriplett> I can't seem to set the fixity of an operator in ghci.  Does ghci not support fixity declarations?
18:03:27 <weasels> nop
18:03:38 <weasels> JoshTriplett: not directed at you
18:03:41 <weasels> but I don't think it does
18:03:48 <JoshTriplett> Sigh.
18:03:54 <JoshTriplett> Guess I'll have to load a module.
18:04:02 <geekosaur> what version?  7.4.1 supports more than earlier versions did, but possibly not fixity yet
18:04:35 <JoshTriplett> geekosaur: 7.4.1
18:04:59 <JoshTriplett> Can I load a module by path in ghci?
18:05:10 <geekosaur> :l /path/to/file
18:05:23 <hpc> don't you have to :m+ afterwards?
18:06:26 <hpc> oh, doesn't look like it
18:06:50 <zzo38> You also need {-# LANGUAGE OverlappingInstances, FlexibleInstances, UndecidableInstances, TypeSynonymInstances #-} but yes you can make up that function which is putStrLn or print depending on its type using the code I wrote here
18:07:16 <hpc> wow
18:07:23 <geekosaur> JoshTriplett, if it's a compiled module, you probably need :set -i/path/to/module/root and then :m +whatever
18:07:25 <weasels> I'm just gonna give it a go
18:07:29 <hpc> one would expect UndecidableInstances to imply the first two
18:07:34 <weasels> actually, no
18:07:41 <JoshTriplett> geekosaur: Not particularly complicated, and :load seems to work.
18:07:42 <hpc> also, you don't need type synonym instances if you write instance [Char]
18:08:02 <JoshTriplett> geekosaur: Though I find it annoying that I get all the compilation messages at ghci startup if I do that in .ghci.
18:08:02 <zzo38> Yes, you can write [Char] instead, and I do not know what implies what for sure
18:08:16 <geekosaur> compiled, not complicated.  that is, :l loads .hs files not .hi files
18:08:40 <JoshTriplett> geekosaur: Oh, heh, misread that.  No, .hs will work fine.
18:08:44 <geekosaur> hrm.  but it *is* compiling them
18:08:56 <JoshTriplett> geekosaur: Granted, but I'd like it to shut up about it unless something goes wrong. :)
18:09:05 <JoshTriplett> (And I don't particularly want the prompt to say *Main> either.)
18:09:21 <geekosaur> I wonder if :set -v0 works.  (prompt can be changed also, but I do not recall how; try :help)
18:10:34 <JoshTriplett> geekosaur: That works nicely, thanks!
18:10:58 <JoshTriplett> geekosaur: What's the default -v, so I can set it back to normal?
18:11:18 <geekosaur> I believe it's -v1
18:11:26 <JoshTriplett> (Or better yet, does some means exist to set it temporarily so that I can still "ghci -vsomething" and not get royally confused about why that doesn't work?)
18:15:59 <geekosaur> hm, I don;t see a way to get the current -v option
18:16:08 <JoshTriplett> geekosaur: Oh well.  I'll live.
18:16:46 <JoshTriplett> One annoying thing: :l puts me in the context of that module, so that I can see everything that module imports, not just the things that module exports.
18:22:08 <otters> so what does the # signify in haskell source
18:22:45 <ion> Which #?
18:23:43 <otters> like
18:23:45 <otters> packCString#
18:24:01 <otters> or Addr#
18:24:33 <JoshTriplett> otters: Take a look at the MagicHash extension.  It typically means "unboxed".
18:25:14 <ion> or primitive operations
18:25:49 <rwbarton> it doesn't actually mean anything except as a convention
18:26:26 <rwbarton> except that you can only use it in identifiers when the MagicHash extension is enabled
18:27:03 <otters> unboxed
18:27:04 <otters> hm
18:31:14 <JoshTriplett> :hoogle showIntAtBase
18:31:23 <JoshTriplett> @hoogle showIntAtBase
18:31:23 <lambdabot> Numeric showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
19:03:22 * hackagebot wai-app-file-cgi 0.6.0 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.6.0 (KazuYamamoto)
19:13:23 * hackagebot mighttpd2 2.6.0 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.6.0 (KazuYamamoto)
19:21:54 <gwern> @quote
19:21:55 <lambdabot> Einskell says: Make everything as monad as possible, but not monadder.
19:22:57 <CoconutCrab> monad can be used as an adjective too?
19:24:02 <JoeyA> Monad monad monad monad monad monad.
19:25:44 <ion> Buffalo buffalo
19:26:04 <ion> Monad monad Monad monad monad monad Monad monad.
19:27:09 <JoeyA> Monad monad, monad monad mooonad monad, monad?
19:28:44 <Eduard_Munteanu> CoconutCrab: "monadic", yeah
19:30:26 <JoeyA> > (fmap fmap fmap) (++ " fmap") [["fmap", "fmap"], ["fmap"]]
19:30:31 <lambdabot>   [["fmap fmap","fmap fmap"],["fmap fmap"]]
19:35:40 <JoeyA> With some EDSLs, the code stays within the Haskell runtime system, meaning the interface lets you use e.g. Applicative or Monad, as well as arbitrarily deep recursion.  However, for an EDSL that generates code to run outside of Haskell (e.g. JavaScript), you don't get these luxuries.
19:35:52 <JoeyA> What's some good reading material for the latter kind of EDSL?
19:36:18 <JoeyA> (an example of the former type is http://twdkz.wordpress.com/2012/05/10/composable-value-editors/ )
19:37:18 <JoeyA> "Monad Reification in Haskell ..." came up on Reddit very recently.  That might be relevant.
19:41:30 <Nafai> I'm trying to life spawnPipe from XMonad.Util.Run to use in my own program, but am having issues getting the imports right to have this compile: https://gist.github.com/2760342
19:43:05 <JoeyA> Nafai: MonadIO is from the transformers package: http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-IO-Class.html
19:44:01 <JoeyA> "MonadIO m => String -> m Handle" is a generalization of "String -> IO Handle"
19:44:08 <RylandAlmanza> So, in haskell's do notation, is there a return value?
19:44:26 <shachaf> RylandAlmanza: "return value" is a kind of vague term here.
19:44:36 <shachaf> For example, you might be thinking of the function "return".
19:45:06 <JoeyA> Nafai: For now, try changing it to read spawnPipe :: String -> IO Handle
19:45:15 <Eduard_Munteanu> JoeyA: Atom perhaps?
19:45:35 <Eduard_Munteanu> The EDSL for writing embedded code.
19:45:50 <Nafai> JoeyA: k, it's confusing because the XMonad contrib, there is no such import
19:46:23 <Eduard_Munteanu> http://hackage.haskell.org/package/atom
19:47:10 <JoeyA> Eduard_Munteanu: Indeed.  Is there a paper or blog series or something reviewing the challenges of designing it?
19:47:17 <JoeyA> (I thought I saw one somewhere)
19:47:24 <Eduard_Munteanu> Hm, I don't know about that.
19:48:16 <Eduard_Munteanu> JoeyA: check that homepage, he's got something on Atom there.
19:50:51 <JoeyA> There's "Monitoring Distributed Hard Real-Time Systems", but that looks like it's about the domain (hard real time, space shuttles, etc.) and not about the interesting part (how Haskell comes into the picture).
19:51:09 <JoeyA> (for certain values of interesting)
19:51:55 <aavogt> Nafai: what's wrong with just depending on XMonadContrib and importing spawnPipe as it's already written?
19:52:44 <Eduard_Munteanu> JoeyA: http://leepike.wordpress.com/2009/05/05/an-atomic-fibonacci-server-exploring-the-atom-haskell-dsl/
19:52:57 <Eduard_Munteanu> JoeyA: however, I'm not sure what you expect to find
19:54:40 <JoeyA> Eduard_Munteanu: The thought process behind the design of Atom or similar.
19:55:10 <Nafai> aavogt: Oh, you know, I really wasn't thinking of the easy route... :)
19:55:37 <Eduard_Munteanu> JoeyA: it's basically a code generator with nice combinators, AFAIU.
19:56:33 <Eduard_Munteanu> So you pretend to write that in Haskell, and you get "equivalent" C code.
19:58:21 <JoeyA> Eduard_Munteanu: Thanks for the help.  For now, I think I'll just read the "Monad Reification" blog post.
20:01:58 <JoeyA> And it links to "Compiling Embedded Languages" <http://conal.net/papers/jfp-saig/>, which appears to hit very close to what I'm looking for.
20:07:37 <nejucomo> b
20:13:28 * hackagebot yaml 0.7.0.1 - Low-level binding to the libyaml C library.  http://hackage.haskell.org/package/yaml-0.7.0.1 (MichaelSnoyman)
20:19:21 <Clint> http://hdiff.luite.com/cgit/yaml/commit?id=0.7.0.1 is fascinating
20:27:49 <Mathnerd314> Clint: as opposed to http://hdiff.luite.com/cgit/yaml/commit/?id=0.7.0.1&ignorews=1 ?
20:28:36 <Clint> Mathnerd314: yes, exactly
20:29:51 <Mathnerd314> hmm, I wonder when luite's semi-secret project will be released
20:31:06 <ku> Can someone confirm that because of right-associativity haskell sees: 3 / fromIntegral (length [1,2,3])
20:31:16 <ku> like: 3 / (fromIntegral (length [1,2,3]))
20:31:51 <alpounet> that's because of function application having a higher precedence
20:32:09 <ku> ah right
20:32:15 <alpounet> (than /, that is)
20:32:17 <ku> the function application happens first, then the `/`
20:32:23 <alpounet> yup
20:32:23 <ku> ok
20:32:26 <ku> thanks
20:32:31 <shachaf> That's the right associativity to have.
20:33:36 <ku> do you know of a good quick-reference that lists the precedences in haskell and explains associativity clearly/completely?
20:38:12 <JoeyA> ku: http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-820004.4.2
20:39:29 <RylandAlmanza> How can I go through a list and do something based on the value of each item?
20:39:50 <RylandAlmanza> I need to render squares in SDL based on a list of Bools
20:39:55 <JoeyA> ku: For operators not listed (namely, operators defined by other modules, like <$> in Control.Applicative), open ghci, import the module, and type :i <$>
20:40:20 <JoeyA> If it doesn't say something like "infixl 4 <$>", then it has the default fixity (infixl 9).
20:40:44 <JoeyA> RylandAlmanza: mapM_
20:40:47 <JoeyA> :t mapM_
20:40:48 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
20:41:09 <JoeyA> e.g. mapM_ putStrLn ["Three", "Two", "One", "Liftoff!"]
20:41:28 <RylandAlmanza> thanks, JoeyA
20:41:36 <shachaf> ThoeyA
20:42:14 <JoeyA> RylandAlmanza: There's also forM_, which is just mapM_ with the arguments flipped.  That lets you write it almost like a for loop.
20:42:33 <JoeyA> forM_ [1..10] $ \i -> print i
20:42:42 <JoeyA> (need to import Control.Monad for that)
20:44:03 <RylandAlmanza> > mapM_ (if True then 1 else 0) [True, False, True, False]
20:44:04 <lambdabot>   No instance for (GHC.Show.Show (m ()))
20:44:04 <lambdabot>    arising from a use of `M460222922...
20:44:55 <strager> > map (\x -> if x == True then 1 else 0) [True, False, True, False]
20:44:56 <lambdabot>   [1,0,1,0]
20:45:06 <strager> > map fromEnum [True, False, True, False]
20:45:08 <lambdabot>   [1,0,1,0]
20:45:11 <RylandAlmanza> thanks. I have a lot to learn
20:45:18 <strager> mapM is for actually *doing* things.
20:45:33 <RylandAlmanza> well, that's what I want to do
20:45:59 <RylandAlmanza> What if you made it print a string for each true value?
20:46:30 <strager> mapM_ (\x -> when (x == True) $ putStrLn "hello") [True, False, True, False]
20:46:52 <shachaf> when (if (x==True) then True else False)
20:46:57 <Veinor> x == True is the same thing as x, though
20:46:58 <strager> or you'd probably use forM like JoeyA suggested
20:47:13 <strager> Whatever Veinor ;P
20:47:15 <Veinor> ... is that actually true even in the presence of bottom? i wonder
20:47:18 <strager> I don't use booleans!
20:47:20 <RylandAlmanza> ok, now here's where it gets tough
20:47:21 <shachaf> Veinor: Yes.
20:47:45 <strager> I don't think I've ever used [Bool] before.
20:47:46 <shachaf> flip replicateM_ (putStrLn "hi") . length . filter id
20:47:52 <RylandAlmanza> I actually have a list of lists to iterate through and print a string, not just a list
20:48:10 <strager> Do you want to iterate and receive each list, or each element?
20:48:17 <RylandAlmanza> each element
20:48:21 <shachaf> RylandAlmanza: I think you should probably read an introduction to how I/O works in Haskell.
20:48:30 * hackagebot oi 0.1.1 - Purely Functional Lazy Interaction with the outer world  http://hackage.haskell.org/package/oi-0.1.1 (NobuoYamashita)
20:48:52 <strager> forM_ xss $ \xs -> forM_ xs $ putStrLn . show
20:49:29 <JoeyA> Answers in #haskell are automatically sorted by readability descending.
20:49:30 <strager> Or just, mapM_ f $ concat xss
20:49:56 <JoeyA> Surely you can do something with concatMap, and turn concatMap into =<<
20:49:59 <strager> @remember JoeyA Answers in #haskell are automatically sorted by readability descending.
20:50:00 <lambdabot> Nice!
20:50:29 <strager> mapM_ (mapM . f) xss  -- Genius!
20:50:39 <shachaf> #haskell is such a terrible IRC channel.
20:50:43 <shachaf> Why am I even in here?
20:50:57 <strager> I think it's awright.
20:52:34 <JoeyA> Though I'd do it as forM_ (filter f xs) $ \x -> ...
20:54:15 <JoeyA> As opposed to using 'when' inside the loop body.  Simply 'cuz it turns an impure thing into a pure thing.
20:55:46 <strager> Smart.
20:56:23 <strager> I think I actually have that mapM_ (when ...) pattern somewhere in one of my projects.
20:57:24 <strager> Nope; guess not.
21:08:32 * hackagebot cereal-conduit 0.0.6 - Turn Data.Serialize Gets and Puts into Sources, Sinks, and Conduits  http://hackage.haskell.org/package/cereal-conduit-0.0.6 (MylesMaxfield)
21:33:34 * hackagebot portaudio 0.2.1 - Haskell bindings for the PortAudio library.  http://hackage.haskell.org/package/portaudio-0.2.1 (AnilVaitla)
21:37:42 <RylandAlmanza> Anyone gotten this to work? http://www.haskell.org/haskellwiki/Library/PNG
21:38:37 <dmwit> RylandAlmanza: No, but you should use a real library.
21:40:28 <dmwit> e.g. devil, JuicyPixels, cairo, etc.
21:42:02 <dmwit> I didn't think my advice was so bad as all that... =/
21:44:26 <alpounet> hah
21:53:21 <Eduard_Munteanu> Or he could generate an image in a simpler pixmap format.
21:58:35 * hackagebot pipes 2.0.0 - Compositional pipelines  http://hackage.haskell.org/package/pipes-2.0.0 (GabrielGonzalez)
22:45:54 <avaitla> is anyone here familiar with https://github.com/ekmett/ad?
22:47:29 <shachaf> edwardk is probably familiar with it.
22:47:32 <shachaf> I guess he's not here right now.
22:49:36 <nanothief> @djinn (a -> b) -> Maybe a -> Maybe b
22:49:37 <lambdabot> f a b =
22:49:37 <lambdabot>     case b of
22:49:37 <lambdabot>     Nothing -> Nothing
22:49:37 <lambdabot>     Just c -> Just (a c)
22:49:58 <pdxleif> 7.4.2 GHCi says it'll support ARM - does that mean I can have a Haskell REPL on my Android?
22:50:19 <shachaf> pdxleif: Supprting ARM isn't sufficient for supporting Android.
22:50:25 <yitz> preflex: seen edwardk
22:50:25 <preflex>  edwardk was last seen on #haskell 2 days, 8 hours, 58 minutes and 56 seconds ago, saying: since it rules out a lot of useful reader-like monads
22:50:38 <shachaf> Someone (kmc) did an Android port of sorts, but I don't think it was ever publicly released.
22:51:09 <pdxleif> Bummer - it'd be nice to have.
22:51:30 <pdxleif> I was thinking a Scala one wouldn't be to hard, given that it runs on a Java platform, but that'd be so much more verbose.
23:38:56 <Taneb> "snoc" is a fun word to say
23:38:59 <Taneb> snoc snoc snoc
23:40:02 <shachaf> Maybe it should be called "pros".
23:44:17 <geekosaur> that sonds more like a record proposal }:>
23:51:46 <dolio> Don't knock my snoc or I'll clean your clock.
23:52:21 <Taneb>  http://brawlinthefamily.keenspot.com/2008/11/12/103-dededoo/
23:53:46 <jtobin> snoc snoc snockin' on heaven's door
23:54:23 <jtobin> ♪
23:55:15 <homie> ?
23:57:03 <Nafai> I have a line like this: "import System.FilePath (FilePath, (</>))" but ghc is telling me the import is redundant.  The only other thing I import is fromMaybe from Data.Maybe.  What is ghc unhappy about?
23:57:26 <Taneb> FilePath is in Prelude
23:57:59 <Taneb> Yeah, I think that'd be it
