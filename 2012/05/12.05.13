00:00:05 <Cale> well, almost
00:00:18 <Cale> except that maxE has a special case for []
00:01:15 <Cale> coldpizza72i: http://cale.yi.org/share/Folds.svg
00:01:40 <ninegrid> CarlosBoBLopez: consider this list [0.0,0.01..1.0] and others like it
00:01:54 <CarlosBoBLopez> ninegrid: ok
00:02:33 <coldpizza72i> Cale: didn't you say this should work " maxE lst = fold max lst "?
00:02:36 <Cale> coldpizza72i: you might like to look at that where the behaviour of various folds and scans has been depicted in terms of what they do to the code graphs (this is closely related to what actually goes on in memory, but the evaluation sort of bypasses the point shown in most cases)
00:02:38 <coldpizza72i> foldr*
00:02:44 <Cale> foldr1
00:03:13 <coldpizza72i> o
00:03:18 <Cale> > foldr1 max (words "here are some words")
00:03:19 <lambdabot>   "words"
00:03:28 <Cale> > foldr1 max []
00:03:29 <lambdabot>   *Exception: Prelude.foldr1: empty list
00:03:32 <Cale> ^^ but watch out1
00:03:50 <CarlosBoBLopez> ninegrid: I'll keep that expression in mind while I study this. Very interesting result.
00:04:26 <CarlosBoBLopez> 1.0000000000000007
00:04:28 <CarlosBoBLopez> oh my lol
00:04:29 <mauke> @src maximum
00:04:30 <lambdabot> maximum [] = undefined
00:04:30 <lambdabot> maximum xs = foldl1 max xs
00:05:41 <YeOldeTroller> Good morning, mentlgen!
00:05:59 <ninegrid> CarlosBoBLopez: this is why you never use floating point to do finance
00:06:50 <CarlosBoBLopez> ninegrid: what type would you use instead?
00:07:05 <Cale> CarlosBoBLopez: usually fixed point
00:07:08 <ninegrid> CarlosBoBLopez: you can do it in integer... or some fixed precision
00:07:23 <Cale> CarlosBoBLopez: So, counting pennies, or tenths of pennies or something
00:08:16 <CarlosBoBLopez> ninegrid: what type in haskell satisfies those conditions?
00:08:31 <Cale> That said, 'never' might be a little strong. There are a lot of optimisation methods and such which aren't really well-suited to fixed point, I think.
00:08:39 <ninegrid> CarlosBoBLopez: the Rational type Cale demonstrated to you earlier
00:08:40 <Cale> CarlosBoBLopez: There's a Data.Fixed
00:08:54 <CarlosBoBLopez> ninegrid: I see.
00:09:07 <CarlosBoBLopez> Cale: Haha. Thanks!
00:09:19 <Cale> > 91.2 / 10 :: Fixed E2
00:09:20 <lambdabot>   9.12
00:09:24 <Cale> > 91.2 / 100 :: Fixed E2
00:09:25 <lambdabot>   0.91
00:09:42 <Cale> ^^ much harsher rounding error though
00:10:32 <CarlosBoBLopez> Oh my.
00:11:04 <Cale> Rational will have no rounding error
00:11:07 <CarlosBoBLopez> Cale: Wait that expression gives me a "not in scope" error
00:11:14 <Cale> import Data.Fixed
00:12:22 <CarlosBoBLopez> cale:ok. now I'm getting the ".91" lol
00:12:44 <CarlosBoBLopez> cale: nvm
00:13:02 <CarlosBoBLopez> cale: nvm its working correctly
00:14:09 <CarlosBoBLopez> alright I'm going to bed. Good night guys.
00:14:14 * hackagebot variable-precision 0.2 - variable-precision floating point  http://hackage.haskell.org/package/variable-precision-0.2 (ClaudeHeilandAllen)
00:14:55 <CarlosBoBLopez> Thanks for all the help.
00:16:00 <CarlosBoBLopez> Haskell's great. The reason I came across this. Was because I was prototyping a function to get the leading number off any number.
00:16:16 <CarlosBoBLopez> blah cash = if (cash / 10) > 9 then blah (cash / 10) else (if cash < 10 then cash else cash / 10)
00:16:47 <CarlosBoBLopez> meaning if I enter 1923242. I'll get 1.
00:17:54 <CarlosBoBLopez> I'll be back soon. ;)
00:18:47 <coldpizza72i> Cale: so now i got another pattern function that I'm not sure how to turn into fold
00:19:37 <coldpizza72i> duplicate [] = [] ‚Ä¶ duplicate [x] = [x,x] ‚Ä¶ duplicate (x:xs) = [x,x] ++ duplicate xs
00:20:13 <coldpizza72i> I'm not sure if fold is a better way to go or not, but this kind of follows the pattern you were mentioning before
00:21:29 <Ralith> seems simple enough
00:22:02 <coldpizza72i> Ralith: do you know how to turn it into using fold
00:22:12 <Ralith> your folding function should just glue the element onto the accumulator twice
00:23:32 <coldpizza72i> ok
00:23:34 <Polarina> Is GHC able to optimize immutable arrays (for certain code) to efficient mutable array operations? I can't seem to find anything on this topic.
00:23:40 <liyang> > concatMap (\ x -> [x, x]) [1,2,3]
00:23:41 <lambdabot>   [1,1,2,2,3,3]
00:24:16 <coldpizza72i> huh
00:27:16 <coldpizza72i> Ralith: dup x = [x,x] and dup lst = foldl (dup ++) lst ?
00:28:02 <Ralith> that seems plausible.
00:28:15 <Ralith> probably need a . in there
00:29:19 <coldpizza72i> can't get it to work
00:30:44 <Ralith> oh, you're trying to give both of those the same name?
00:30:45 <Ralith> why?
00:30:48 <Ralith> they do different things.
00:31:05 <coldpizza72i> oops
00:31:16 <coldpizza72i> no i wasnt
00:31:29 <coldpizza72i> I'm in interactive i didn't give a name to the second
00:31:41 <coldpizza72i> mistyped in here
00:32:40 <Ralith> what function are you passing to foldl?
00:32:59 <coldpizza72i> (dup ++)
00:33:21 <Ralith> what error are you getting?
00:33:36 <coldpizza72i> ouldn't match expected type `[a]' against inferred type `t -> [t]'
00:33:49 <mauke> that's because dup isn't a list
00:34:02 <Ralith> coldpizza72i: ++ is an infix operator.
00:34:23 <Ralith> (dup ++) returns a function that appends the list 'dup' to whatever is passed to it.
00:34:33 <Ralith> since 'dup' isn't a list, this fails to compile.
00:34:52 <coldpizza72i> but dup x = [x,x]
00:35:15 <shachaf> Right, so "dup x" is a list.
00:35:17 <shachaf> "dup" isn't.
00:35:27 <mm_freak> coldpizza72i: (++) wants an [a] as argument
00:35:33 <Ralith> coldpizza72i: type ':t dup' into ghci
00:35:33 <mm_freak> you're giving it an a -> [a]
00:35:39 <mm_freak> so it's a type error
00:35:40 <Ralith> coldpizza72i: and ':t (++)'
00:35:48 <coldpizza72i> i see
00:36:11 <Ralith> and ':t (dup undefined)' for further illustration
00:36:40 <coldpizza72i> I'm not sure how to fix this
00:38:22 <Ralith> coldpizza72i: the code you have written tries to apply (++) to dup.
00:38:26 <Ralith> that obviously isn't what you wanted it to do.
00:38:29 <Ralith> what did you want it to do?
00:39:08 <coldpizza72i> [1,2,3] -> [1,1,2,2,3,3]
00:39:11 <coldpizza72i> wtc
00:39:13 <coldpizza72i> etc
00:39:22 <mm_freak> coldpizza72i: see concatMap
00:39:40 <mm_freak> > concatMap (\x -> [x + 1, x - 1]) [10, 20, 30]
00:39:41 <lambdabot>   [11,9,21,19,31,29]
00:39:47 <coldpizza72i> mm_freak: can i make my own with folds?
00:39:55 <mm_freak> an own concatMap?
00:40:07 <coldpizza72i> my own duplicate
00:40:17 <Ralith> coldpizza72i: no, the code you wrote to pass to foldl, not the full thing.
00:40:21 <Ralith> what did you want that particular bit to do?
00:40:31 <mm_freak> coldpizza72i: yes, you can write it in terms of foldr
00:42:14 <coldpizza72i> i want it to take an element duplicate it into a list and concatenate the list by folding
00:42:29 <mm_freak> coldpizza72i: that's not the way to do it with a fold
00:42:46 <mm_freak> of course it's possible, but you would need a separate concatenation step at the end
00:42:52 <coldpizza72i> mm_freak: what is the way
00:43:30 <mm_freak> coldpizza72i: well, see the identity fold:
00:43:32 <mauke> :t foldr (fmap (join fmap) (:))
00:43:33 <lambdabot> forall a. [a] -> [a] -> [a]
00:43:42 <mm_freak> > foldr (\x -> (x:xs)) [] [1,2,3]
00:43:44 <lambdabot>   Not in scope: `xs'
00:43:47 <mm_freak> > foldr (\x xs -> (x:xs)) [] [1,2,3]
00:43:48 <lambdabot>   [1,2,3]
00:43:57 <mm_freak> i'm giving the arguments to the folding function intentionally
00:44:41 <mm_freak> x is the head element and you add elements to the head of the "list constructed so far"
00:44:54 <mm_freak> now figure out how to do that in a way that every element gets added twice
00:46:13 <mauke> :t foldr (fmap (join fmap) (:))mzero"orezm"
00:46:14 <lambdabot> [Char]
00:46:21 <coldpizza72i> whats \x
00:46:31 <Ralith> coldpizza72i: perhaps you should read an introductory haskell tutorial.
00:46:33 <mm_freak> coldpizza72i: it's a lambda function
00:46:44 <mm_freak> > (\x -> 2*x + 1) 3
00:46:45 <lambdabot>   7
00:46:47 <coldpizza72i> oh
00:47:11 <mm_freak> coldpizza72i: but i second Ralith's suggestion
00:49:34 <coldpizza72i> foldr (\x xs -> (x:x:xs)) [] [1,2,3]
00:49:52 <coldpizza72i> > foldr (\x xs -> (x:x:xs)) [] [1,2,3]
00:49:52 <lambdabot>   [1,1,2,2,3,3]
00:49:58 <mauke> > foldr (fmap (join fmap) (:))mzero"orezm"
00:49:59 <lambdabot>   "oorreezzmm"
00:50:34 <shachaf> > foldr (fmap fmap join fmap (:))mzero"orezm"
00:50:35 <lambdabot>   "oorreezzmm"
01:05:54 <coldpizza72i> mm_freak: why does there have to be " [] " between the function and the list?
01:06:18 <mm_freak> coldpizza72i: again, i second Ralith's suggestion
01:06:21 <mm_freak> @where lyah
01:06:21 <lambdabot> http://www.learnyouahaskell.com/
01:06:45 <ninegrid> coldpizza72i: Do it.
01:07:13 <coldpizza72i> i am doing it
01:09:08 <coldpizza72i> i see
01:09:13 <coldpizza72i> i like this website
01:09:22 <Cale> coldpizza72i: remember it was foldr f z
01:09:26 <Cale> coldpizza72i: [] is the z there
01:10:14 <Cale> coldpizza72i: You can think of foldr f z xs as replacing each (:) in xs with f, and replacing [] with z
01:10:30 <Cale> > foldr (:) [] [1,2,3,4,5]
01:10:31 <lambdabot>   [1,2,3,4,5]
01:10:42 <Cale> > foldr (\x xs -> x:xs) [] [1,2,3,4,5]
01:10:43 <lambdabot>   [1,2,3,4,5]
01:10:52 <Cale> > foldr (\x xs -> (x*2):xs) [] [1,2,3,4,5]
01:10:53 <lambdabot>   [2,4,6,8,10]
01:11:07 <Cale> > foldr (\x xs -> x:x:xs) [] [1,2,3,4,5]
01:11:08 <lambdabot>   [1,1,2,2,3,3,4,4,5,5]
01:12:09 <Cale> So there, we replace the (:) which adds each element to the rest of the list with a function which adds it twice.
01:12:32 <Cale> and we don't want to change how the list ends, so [] is replaced with []
01:17:01 <coldpizza72i> > map (\[x] -> x) [[1],[3]]
01:17:01 <lambdabot>   [1,3]
01:17:16 <coldpizza72i> > map (\[x] -> x) [[1],[3,2]]
01:17:17 <lambdabot>   [1,*Exception: <interactive>:3:5-13: Non-exhaustive patterns in lambda
01:17:47 <coldpizza72i> Cale: I'm not sure how to add an additional pattern here
01:18:22 <coldpizza72i> to lambda
01:19:50 <mauke> you can't
01:20:59 <coldpizza72i> mauke: so if I want a function that takes a list s.t. every element is a list and flattens that layer off, would you say folds are not the way to go?
01:21:29 <mauke> :t concat
01:21:30 <lambdabot> forall a. [[a]] -> [a]
01:21:44 <mauke> @src concat
01:21:45 <lambdabot> concat = foldr (++) []
01:21:47 <coldpizza72i> ohhh
01:23:33 <coldpizza72i> >concat [[1],[[3,5]]]
01:23:53 <coldpizza72i> wtf
01:24:11 <coldpizza72i> > concat [[1],[[3,5]]]
01:24:12 <lambdabot>   No instance for (GHC.Num.Num [t])
01:24:12 <lambdabot>    arising from a use of `e_1135' at <int...
01:25:05 <mm_freak> coldpizza72i: multipattern lambdas are (unfortunately) not supported by haskell, but that's just a syntactic limitation‚Ä¶  you can always use 'case' inside a lambda
01:25:09 <yitz> > concat [[1],[3,5]]
01:25:09 <lambdabot>   [1,3,5]
01:25:41 <lol> ciao
01:25:45 <lol> !list
01:25:55 <coldpizza72i> yitz what if i want [[1],[[3,5]]] to return [ 1, [3,5] ]
01:26:06 <mm_freak> coldpizza72i: that's a type error
01:26:12 <yitz> coldpizza72i: those are two different types. lists are homogeneous.
01:26:21 <coldpizza72i> ohhhh
01:26:25 <coldpizza72i> oops
01:26:48 <mm_freak> you should get a "no instance" error for that one
01:26:53 <mm_freak> > [1, [3, 5]]
01:26:54 <lambdabot>   No instance for (GHC.Num.Num [t])
01:26:54 <lambdabot>    arising from a use of `e_1135' at <int...
01:28:23 <mm_freak> by the second list element the type checker infers that the list elements must be lists, too (of type [t] for some unspecified type t)
01:28:55 <mm_freak> then it tries to interpret the first element as a list, which fails, because there is no rule to turn an integer literal into a list
01:35:55 <Taneb> Hello!
01:36:36 <coldpizza72i> I gotta go, but thanks for the help everyone
01:41:57 <mekeor> hi, Taneb :-)
01:44:22 * hackagebot hoauth2 0.2.2 - hoauth2  http://hackage.haskell.org/package/hoauth2-0.2.2 (HaishengWu)
01:56:18 <Franciman> hi all
01:56:30 <Taneb> Hello
01:57:49 <Franciman> i have finally found a good editor for haskell <3
01:58:00 <Taneb> Yay!
01:58:08 <Taneb> Gedcom is annoyingly rigid
01:59:36 <Peaker> Franciman, which?
01:59:46 <Franciman> Peaker, emacs
01:59:50 <Franciman> ghc-mod seems quite cool
02:00:02 <donri> there's ghcmod for vim too
02:00:06 <Franciman> yes
02:00:12 <Peaker> I dislike all the indent modes for emacs
02:00:18 <Franciman> but I like more the default colors of emacs
02:00:24 <Franciman> and I don't like changing colors xD
02:00:49 <donri> :)
02:00:53 <donri> whatever floats your boat
02:01:33 <donri> i think vim has broader support for colorschemes and syntax highlighting
02:01:50 <donri> but emacs has more powerful features
02:02:31 <Franciman> Peaker, I have not tried it yet
02:02:40 <Franciman> vim's ones are better?
02:03:05 <Franciman> *tried none yet
02:03:38 <donri> vim has worse indenting for haskell AFAIK, i've tried to improved that in my https://github.com/dag/vim2hs
02:04:07 <Franciman> vim2hs :: Vim -> Haskell
02:04:10 <Franciman> lol
02:04:14 <donri> :)
02:04:18 <donri> naming is hard, man
02:04:23 <Ralith> donri: I'm not sure why you would htink vim has more support for syntax hilighting.
02:04:34 <Ralith> (or color schemes)
02:04:39 <donri> Ralith: yea i'm not sure either :)
02:04:56 <Ralith> ^^
02:04:58 <donri> i think i've been told vim is better at embedding languages inside others
02:05:08 <Ralith> that may be the case
02:05:09 <donri> and vim certainly seems to have more colorschemes available
02:05:22 <Ralith> where have you been looking for emacs ones?
02:05:28 <Ralith> 'cause there's a gigantic list out there
02:05:34 <donri> ah ok
02:05:50 <donri> i had some "package management" system in emacs when i tried it
02:06:03 <Ralith> it's just that until 22 or 23 or so the color scheme system didn't ship with it
02:06:32 <Ralith> the thing about emacs is one of the basic skills for using it is finding useful and relevant addons
02:08:55 <donri> is there a useful starter guide listing popular addons?
02:09:16 <opqdonut> the emacs wiki is pretty good
02:09:28 <opqdonut> http://emacswiki.org/
02:13:29 <b52> Does anyone have a good tutorial on testing in haskell and how to prepare an existing project to do so?
02:14:14 <donri> @where rwh
02:14:14 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
02:14:19 <donri> it has a chapter on testing
02:14:54 <donri> http://batterseapower.github.com/test-framework/ is also useful
02:16:07 <b52> i orded that book yesterday
02:17:30 <fmap> Is there a safe way to upgrade to containers-0.5.0.0?
02:17:49 <donri> safe?
02:18:44 <fmap> donri: I read something like cabal install containers will lead to cabal issues
02:19:32 <donri> fmap: you should manage your project with cabal, then you can depend on containers >= 0.5 and maybe try building it in cabal-dev
02:20:05 <donri> or, well, containers == 0.5.* to be more pvp
02:21:18 <Peaker> The pvp sucks :P
02:23:07 <b52> donri: how do you guys organise your projects to run tests automated?
02:23:09 <Franciman> pvp == ?
02:23:45 <donri> b52: cabal has support for test-suites, though it was a bit broken before the latest releases
02:23:53 <donri> @where pvp
02:23:54 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
02:24:20 <donri> b52: another option is having a flag for building the tests
02:24:42 <b52> anything considered as best practice?
02:24:43 <donri> b52: https://github.com/dag/kibr/blob/master/kibr.cabal#L107
02:24:49 <Peaker> 80% of my problems with cabal were a result of over-conservative version constraints (due to the pvp) and 80% of those could be fixed simply by removing the pvp constraints manually
02:26:16 <donri> Peaker: packages will fail to build after a while if they don't have careful constraints
02:26:28 <Peaker> and if they do
02:26:38 <Peaker> IME they fail more often if they do
02:26:51 <Peaker> and in ways that require more cabal foo to diagnose
02:34:48 <kallisti> is there no way to wait indefinitely?
02:35:40 <yitz> stable releases should definitely have upper version constraints on all dependencies
02:36:15 <yitz> i can understand why people might want to skip some of the upper bounds on a package in active development.
02:36:53 <yitz> but any package with missing upper bounds on any of its constraints should be considered bitrotted and unreliable if it is more than a month or two old.
02:47:59 <ferh332> how can I make Unboxed record?
02:48:33 <ferh332> I need to put it in Data.Vector.Unboxed
02:49:33 <ferh332> by the way, hello :)
02:50:26 <sipa> data UnboxedCoordinate = UnboxedCoordinate { x :: !Int, y :: !Int }
02:50:41 <bitonic> ferh332: you need to create an instance for the MVector type family
02:50:47 <bitonic> ferh332: http://hackage.haskell.org/packages/archive/vector/0.9.1/doc/html/Data-Vector-Unboxed.html gives an example
02:52:59 <ferh332> bitonic: I am kind of new to haskell but which has more performance: unboxed vector or storable vector?
02:53:53 <Ralith> not prematurely optimizing.
02:53:56 <bitonic> ferh332: I'd say unboxed, I've never used Storable. what do you need to do?
02:54:06 <bitonic> ferh332: you probably don't need any of those
02:56:24 <bitonic> well, I've never used Storable vectors. I'd assume that it uses Storable to manage memory manually
02:56:34 <ferh332> bitonic, I need to implement voxel chunks. the voxel will be 64bit, the chunk will have 50x50x50 of voxels, so I need to keep my memory at minimum (then I will compress that chunk).
02:57:40 <bitonic> ferh332: uhm ok. the thing is that `vector' uses various advanced features of the type system, so it's probably better to learn haskell in some other way. you can try anyway if you're brave, but make sure you understand what's going on :P
02:58:40 <ferh332> erlang is not so new to me ;)
02:59:13 <bitonic> ferh332: erlang has little to do with haskell. apart immutability
02:59:32 <ferh332> yea, I know..
02:59:45 <ferh332> but its better than knowing java :
02:59:47 <ferh332> :D
02:59:58 <bitonic> which is a rare feature that both have. and erlang doesn't even have references of any kind - just process dictionaries
03:01:09 <bitonic> ferh332: so did you just start using haskell?
03:01:21 <jonaskoelker> hi all.  I'm trying to parse an expression language with happy.  I want to feed it a prefix (e.g. "1 + ") and have happy spit out (Left "end of file reached").  How do I do that?
03:02:33 <bitonic> jonaskoelker: have you read the alex/happy documentation?
03:02:33 <ferh332> bitonic, ~ month with it, but no professional haskell programming.
03:02:45 <jonaskoelker> bitonic: flipped through
03:03:10 <bitonic> jonaskoelker: I'm pretty sure they do explain how to use the grammars you define :)
03:03:11 <bitonic> jonaskoelker: are you having any particular issues?
03:03:22 <Eduard_Munteanu> Cale: are you attempting to bore the trolls to the death? :)
03:03:40 <jonaskoelker> I have %error { parseError } and parseError tks = Left $ show tks, but get "Internal Happy error"
03:03:58 <Eduard_Munteanu> SailorR has been in there before with some trolly statements.
03:04:07 <bitonic> ferh332: well so you're not that new to it, do you understand how type classes work?
03:04:52 <ferh332> bitonic: I think yes, but who knows :))
03:05:12 <bitonic> ferh332: well make sure you understand those
03:05:25 <bitonic> then you have to look at how type and data families work
03:07:39 <ferh332> bitonic: yes, I'll check the classes again. But the biggest problem is that I need not so simple task to do: I need mutable data for that chunks of voxels
03:08:01 <bitonic> ferh332: are you sure you need mutable data?
03:08:04 <ferh332> bitonic: and they are not so small of memory :D
03:10:38 <ferh332> bitonc, I feel that I will, or I wont have performance at all... try to calculate 32x32x32 * 8Bytes = 32 * 8 KBytes = 256KBytes. And then update those in "kind of real time" (thats one chunk)
03:11:17 <ferh332> bitonic, I dont know will non mutable data will work. :/
03:11:43 <bitonic> ferh332: I have no experience with voxels (or graphics for that matter :P) but I'm just suggesting to evaluate the situation carefully and not on gut feelings :P
03:11:51 <bitonic> since you're probably much more used to mutable data
03:13:29 <ninegrid> . o 0 ( and eager evaluation )
03:17:03 <ferh332> bitonic: may be that's true. So you say that I should benchmark it and see how it works?
03:18:02 <ninegrid> ferh332: do you have a gpu?
03:21:55 <ferh332> yea
03:23:56 <ferh332> ninegrid: but I don't need to display them(voxels), they are for computations
03:24:41 <ninegrid> you don't have to display them
03:25:39 <ninegrid> ferh332: maybe this would be a good overview for you http://bit.ly/KYQLoE
03:27:14 <ferh332> ninegrid: it feels promising :)
03:27:48 <ferh332> going to read. I'll be back! ;)
03:29:18 <ferh332> thank you ;)
03:31:23 <bitonic> ferh332: well you should think about it before coding and benchmarking :P
03:31:56 <mm_freak> is there any advantage of happy over parser combinators?
03:32:08 <bitonic> mm_freak: happy is not a parser combinator
03:32:19 <mm_freak> bitonic: reread the question
03:32:35 <mm_freak> or should i say reparse? =)
03:32:53 <bitonic> mm_freak: right. the advantage I can think of is that with happy you write a grammar, and not code
03:33:07 <ferh332> bitonic, its 10 days of thinking till now :D
03:33:15 <bitonic> so it's much more clear by looking at it what the code will look like
03:33:50 <mm_freak> that's it?  no fundamental advantage?
03:34:31 <bitonic> mm_freak: well that't the fundamental difference... I'd say that writing a parser with those parser generator is much easier if you know what the grammar looks like
03:34:36 <bitonic> mm_freak: oh also, performance
03:34:49 <bitonic> you have stronger guarantees about the performance of your parser
03:35:02 <mm_freak> hmm?  i'd expect combinators to be faster
03:35:22 <mm_freak> but i mean something different by "fundamental"
03:35:39 <mm_freak> like the ability to express operators and their associativity directly, or the ability to parse left-recursive grammars
03:35:46 <Bytter_> how do I use the bot to find a function of a specific type?
03:35:59 <mm_freak> @hoogle a -> a
03:36:00 <lambdabot> Prelude id :: a -> a
03:36:00 <lambdabot> Data.Function id :: a -> a
03:36:00 <lambdabot> GHC.Exts breakpoint :: a -> a
03:36:08 <bitonic> mm_freak: no, happy generates LALR parsers, which are fast, with parsec or similar you can write horribly inefficient parsers
03:36:25 <Bytter_> @hoogle Œ±->(Œ≤->Œ≥)->(Œ±->Œ≤->(Œ±->Œ≥))
03:36:26 <lambdabot> Warning: Unknown type
03:36:36 <bitonic> mm_freak: you can parse left-recursive grammars with yacc/happy
03:36:43 <mm_freak> bitonic: well, when it comes to performance i'd probably compare to attoparsec, which is extremely fast
03:36:47 <Bytter_> @hoogle a->(b->c)->(a->b->(a->c))
03:36:47 <lambdabot> No results found
03:36:50 <Bytter_> hmmm
03:37:11 <mm_freak> Bytter_: that doesn't look like a sensible type
03:37:22 <Bytter_> mm_freak: it's the type of the S combinator in SKI calculus
03:37:30 <bitonic> mm_freak: in terms of complexity, happy still offers you much stronger guarantees, and attoparsec and parsec are the same. the performance of parser combinators parsers is in the hands of the developers.
03:37:32 <mm_freak> :t \_ f _ x _ -> f x
03:37:33 <lambdabot> forall t t1 t2 t3 t4. t -> (t2 -> t4) -> t1 -> t2 -> t3 -> t4
03:37:46 <mm_freak> Bytter_:
03:37:50 <mm_freak> :t (<*>)
03:37:52 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
03:37:59 <mm_freak> set f = (e ->)
03:38:11 <Bytter_> hey! the applicative is very, very near
03:38:28 <Bytter_> so, is the S combinator an applicative lift of a function?
03:38:30 <bitonic> mm_freak: iirc LALR parsers are linear in respect to the input, so you know your happy parser is going to be linear. when using parser combinators you can make a mess
03:38:38 <mm_freak> Bytter_: (<*>) /is/ the S combinator in the (e ->) functor
03:38:43 <mm_freak> and 'pure' is the K combinator
03:38:57 <mm_freak> Applicative is a generalization of SK
03:39:26 <mm_freak> bitonic: with parsec you have strong guarantees‚Ä¶  you only destroy them when you use 'try'
03:39:32 <Bytter_> mm_freak: that blew my mind... awesome :P
03:39:40 <mm_freak> but you can limit the damage easily
03:39:55 <bitonic> mm_freak: and lookAhead, and <|>,  and whatever. you will have to look ahead sometimes with top-down parsers
03:40:09 <bitonic> I mean you always have to look ahead.
03:40:23 <lamefun2> So not all monads have to encapsulate side effects?
03:40:37 <mm_freak> lamefun2: monads aren't about /side/ effects
03:40:40 <mm_freak> monads are about effects
03:40:52 <mm_freak> Maybe has the monadic effect that there may not be a result
03:41:03 <bitonic> mm_freak: what I mean by guarantees is that you *know* that the parser is going to have certain time/space properties
03:41:11 <bitonic> with parser combinators, you don't
03:41:37 <bitonic> this was one of the main motivations for parser generators against recursive descent parsers in the first place
03:41:44 <mm_freak> bitonic: as far as i've seen with parsec you actually do‚Ä¶  unless you use 'try' you have a maximum lookahead of one character‚Ä¶  the situation is worse with attoparsec
03:42:14 <mm_freak> of course attoparsec is generally still much faster
03:42:37 <isson> hello.
03:42:40 <bitonic> mm_freak: yeah, "unless". unless you use "try", unless you use "lookAhead", unless you get the state and you put it back manually (which is how try is implemented). you have no guarantees
03:42:52 <mekeor> isson: hi, what's up?
03:43:07 <isson> i am sorry for my poor english.
03:43:12 <mekeor> no problem.
03:43:14 <isson> i have  a question.
03:43:19 <mekeor> it's fine so far. just ask.
03:43:27 <isson> main = putStrLn "A"
03:43:31 <mm_freak> bitonic: this is about the same as laziness‚Ä¶  you have to understand what you're doing, of course
03:43:36 <isson> will be evaluated, so print "A"
03:43:42 <isson> i think.
03:43:53 <isson> first,  main = undefined
03:43:55 <bitonic> mm_freak: with yacc/happy, you don't have to understand what you're doing. you just write the grammar and you have a performant parser
03:44:05 <mm_freak> bitonic: i see
03:44:18 <isson> so, main value need to be print, so undefined will be evaluated.
03:44:37 <isson> so, putStrLn "A" will be executed
03:44:42 <isson> right?
03:45:09 <mm_freak> isson: the runtime evaluates 'main' to an action it can execute
03:45:22 <mm_freak> that involves evaluating 'putStrLn "A"'
03:45:36 <isson> hmm...
03:45:37 <mm_freak> the function application is performed yielding an action that prints "A"
03:45:46 <mm_freak> that action is then executed
03:45:53 <mm_freak> notice the difference between evaluation and execution
03:46:09 <mm_freak> evaluation yields an action, and execution performs that action
03:46:14 <mm_freak> the two are interleaved in haskell
03:46:29 <mm_freak> main = x >> y >> z
03:46:34 <mm_freak> (>>) is nonstrict
03:46:58 <mm_freak> so it evaluates to an action that performs x, and then [further evaluation needed]
03:47:22 <mm_freak> the action is executed and (>>) then causes the next action to be executed‚Ä¶  that action has to be evaluated, which is y >> z
03:47:24 <isson> hmm...
03:47:25 <mm_freak> etc.
03:47:36 <isson> thanks a ton~
03:47:39 <isson> but..
03:47:51 <isson> main = (putStrLn "A", putStrLn "B)
03:48:00 <mm_freak> that's a type error
03:48:08 <isson> sorry.
03:48:16 <isson> main = return (putStrLn "A", putStrLn "B")
03:48:25 <isson> main = return (undefined, undefined)
03:48:32 <ninegrid> isson: what is the value of putStrLn "A"
03:48:34 <mm_freak> that does nothing
03:49:03 <isson> ninegrid, it's value of type IO a
03:49:08 <mm_freak> isson: write a type signature for 'main = return (putStrLn "A", putStrLn "B")'
03:49:20 <mm_freak> main :: ?
03:49:27 <isson> main :: IO (IO (), IO ())
03:49:30 <ninegrid> isson: no that is the value of putStrLn,  what is the value of IO a when you put the "a" in the slot?
03:49:31 <mm_freak> yeah
03:49:44 <mm_freak> whatever action 'main' is, it is executed and the result is ignored
03:50:03 <mm_freak> ninegrid: isson is right
03:50:11 <mm_freak> the value 'putStrLn "A"' is an action
03:50:31 <mm_freak> putStrLn itself is a function
03:51:41 <isson> hmm...
03:52:05 <mm_freak> isson: i recommend always writing a type signature at least for 'main'
03:52:07 <ninegrid> mm_freak: alright, that is what i was trying to point out, but forget me i am confused because the result in other langs is unit (void)
03:52:08 <isson> thanks a ton..but I cannot understand...
03:52:30 <mm_freak> isson: i think you do understand, you just don't realize =)
03:52:32 <mm_freak> think simple
03:52:33 <tomh> hey guys, juist built an old project of me and noticed the alex-options and happy-options are now unknown fields in cabal, is this a recent change?
03:53:43 <Guest18724> tomh: interesting. i would ask dcoutts about that
03:54:02 <mm_freak> isson: what is your exact issue?  are you trying to understand how execution works?
03:54:26 <isson> hmm..
03:54:54 <yitz> preflex: xseen dcoutts
03:54:54 <preflex>  dcoutts was last seen on freenode/#ghc 1 day, 12 hours, 23 minutes and 18 seconds ago, saying: (perhaps a few exceptions, but not much)
03:55:11 <tomh> ah ok, well it still seems to work though
03:55:26 <isson> mm_freak. please.wait a minute. I am saving your explains into files.
03:56:08 <yitz> tomh: ok good. do let dcoutts know about it though. he doesn't seem to be around. you can use the @tell command in lambdabot to leave him a message here. or email him.
03:56:24 <tomh> alright
03:58:54 <isson> thanks a ton , mm-freak, ninegrid. I need a time to think your explanation.
03:59:19 <ninegrid> isson: please do not give my explination further thought
03:59:35 <isson> ok. thanks ninegrid.
04:00:10 <mm_freak> isson: again, just think simple
04:00:23 <mm_freak> evaluation yields actions, execution performs actions
04:00:57 <mm_freak> and the two take turns
04:01:16 <mm_freak> now have fun =)
04:01:23 <ninegrid> mm_freak: for example, if i were to do in ML:  let x = print "A", the resulting value of x would be () which is unit, or "undefined" is this the same issue?
04:01:48 <mm_freak> ninegrid: i don't think so, in particular the result in haskell would be of type IO ()
04:02:03 <mm_freak> because 'x' would be the same as 'print "A"'
04:02:03 <ninegrid> mm_freak: what do I call ()
04:02:06 <mm_freak> unit
04:02:24 <ninegrid> alright, so evaluating x again and again would print again and again?
04:02:31 <mm_freak> no
04:02:41 <mm_freak> evaluating x yields the action that prints once
04:02:49 <ninegrid> alright then it is similar, it is just a stronger type of unit?
04:02:50 <mm_freak> executing x prints
04:03:00 <mm_freak> ninegrid: you never execute in haskell
04:03:25 <mm_freak> in haskell IO is an action language (a DSL), and using it you express an action
04:03:34 <ninegrid> mm_freak: that would be the same in ML, the value of unit is bound to x
04:03:34 <mm_freak> the compiled program can be thought of as an interpreter for that language
04:03:43 <mm_freak> and you can have infinite actions, thanks to haskell's laziness
04:03:49 <ninegrid> mm_freak: the difference is that unit in haskell is decorated with IO
04:03:51 <mm_freak> main = putStrLn "Hello world" >> main
04:03:58 <ninegrid> when bound to x that is
04:04:07 <mm_freak> ninegrid: it's not decorated‚Ä¶  IO () and () are fundamentally different things
04:04:26 <mm_freak> IO () is the type of actions that, when executed, yield a value of type ()
04:04:32 <mm_freak> and () is the type of the value ()
04:04:34 * hackagebot PortFusion 1.0.3.1 - CORSIS PortFusion : high-performance distributed reverse / forward proxy & tunneling solution for TCP  http://hackage.haskell.org/package/PortFusion-1.0.3.1 (CetinSert)
04:05:35 <mm_freak> a value of type IO () is /not/ a value of type ()‚Ä¶  there is no decoration going on, you simply have two different things
04:05:52 <ninegrid> i follow you
04:05:54 <mm_freak> notice that on the type level there is conceptually no difference between IO and Maybe
04:06:17 <ninegrid> IO () is nothing and IO a is just?
04:06:32 <mm_freak> no, stay on the type level‚Ä¶  Nothing and Just are value level
04:06:38 <mm_freak> Maybe is a type constructor
04:06:44 <mm_freak> it takes a type and results in a type
04:06:46 <ninegrid> okuok
04:06:49 <mm_freak> IO does the same
04:06:55 <ninegrid> whoops, *ok
04:07:22 <mm_freak> data Maybe a = Just a | Nothing
04:07:39 <mm_freak> data Expr a = Add (Expr a) (Expr a) | Lit a
04:07:46 <Franciman> hey people can you suggest me a good Postscript library for Haskell?
04:07:54 <mm_freak> data IO a = {- an expression language for real world actions -}
04:12:44 <mm_freak> Franciman: i see two relevant libraries on hackage
04:12:58 <Franciman> that is?
04:13:11 <mm_freak> http://hackage.haskell.org/package/wumpus-core
04:13:13 <mm_freak> http://hackage.haskell.org/package/hps
04:14:11 <Franciman> mm_freak, have you ever used one of them? If so which one do you suggest?
04:15:20 <mm_freak> Franciman: no, sorry‚Ä¶  just wanted to point out that hackage is the first place to look in
04:16:15 <haiswu> join #haskellcn
04:16:24 <haiswu> test
04:17:12 <Franciman> ah ok, yes you're right, I just wanted to know whether you'd had  good experiences with a library in particular
04:20:16 <isson> mm_freak?
04:20:43 <isson> are  you there?
04:22:43 <hiptobecubic> isson, "ping" is what you're looking for :)
04:22:58 <isson> hmm...
04:23:14 <isson> sorry for my poor english.
04:23:48 <isson> main = putStrLn "A" will be evaluated to action ,
04:24:07 <isson> and the haskell runtime execute the action,
04:24:16 <isson> so , putStrLn "A" is executed.
04:24:50 <isson> main = return (putStrLn "A", putStrLn "A")
04:25:42 <isson> will be evaluated to return ( a value of IO a , a value of IO„ÖÅ)
04:25:46 <Taneb> Is there a better way to say:
04:25:46 <Taneb> Maybe (Text, Maybe (Text, Maybe Text))
04:26:00 <ion> taneb: [Text]? :-P
04:26:09 <ion> Not exactly the same, but somewhat similar.
04:26:14 <Taneb> It needs to be between 0 and 3
04:26:47 <isson> but, main = return (putStrLn "A", putStrLn "B")  do not print anything.
04:26:49 <Taneb> I'm trying to be compliant to the Gedcom specifications, which is REALLY ANNOYING
04:28:25 <ion> do { (actA, actB) <- return (putStrLn "A", putStrLn "B"); actB } will print B, for instance. return someAction :: IO (IO ‚Ä¶) where only the outer one will be executed if that is assigned to main.
04:31:18 <fmap> isson: Why would it print something if you just inject some tuple into IO?
04:33:42 <fmap> main = return (print 7) won't print anything too
04:33:59 <isson> why?
04:34:51 <isson> it is because lazy evaluation ?
04:35:00 <isson> is it because lazy evaluation?
04:37:10 <hpc> isson: it's because evaluation is different from execution
04:37:22 <hpc> isson: suppose you wrote in C:
04:37:30 <isson> hmm...
04:37:40 <hpc> void print() {printf("%d", 7);}
04:37:58 <hpc> int main() {return &print;}
04:38:24 <ion> ‚Äúreturn‚Äù takes a value and returns an IO action that, when executed, results in that value. If the value just happens to be another IO action, nothing will execute it implicitly.
04:38:38 <hpc> evaluating is the equivalent or calculating the value of &print
04:38:42 <hpc> essentially
04:39:58 <isson> hmm..
04:40:39 <timthelion> Is the uglyness that is line 91 https://github.com/timthelion/gridhaskell-haskarrow/blob/master/CellMethods.lhs#L91 (I cannot put a newline after the = due to parsing errors, a bug or merely a design flaw in Haskell?
04:43:15 <isson> thanks, ion.  hpc.
04:44:11 <ion> If you have a value of type IO (IO a), you can convert it to an IO a (where the side effects of both the outer and the inner one will be executed) with join.
04:44:13 <ion> @type join
04:44:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
04:44:31 <hpc> timthelion: not a bug; your indentation is just ridiculous :P
04:45:01 <hpc> timthelion: try factoring things out into something like
04:45:03 <timthelion> hpc: well there's no good way to lessen the indentation.
04:45:19 <mgsloan> timthelion: https://github.com/tibbe/haskell-style-guide
04:45:23 <hpc> cellPutCell stuff | condition = (a, b)
04:45:36 <hpc>                  | otherwise = (foo, bar)
04:45:39 <hpc>   where
04:45:42 <hpc>     foo = ...
04:45:43 <mgsloan> timthelion: I prefer an even lesser indentation version of this (only one space before where)
04:45:45 <hpc>     bar = ...
04:46:17 <mgsloan> i guess I shoulda linked to https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
04:47:01 <isson> thanks ion..
04:47:22 <timthelion> hm, perhaps I can unident the where now.  Before, I had a let at the beginning, and it wouldn't let me.
04:48:01 <ion> join action = do { innerAction <- action; innerAction }
04:49:52 <timthelion> hpc: perhaps you're right
04:51:37 <isson> ion : you said "ìreturnî takes a value and returns an IO action that, when executed, results in that value. If the value just happens to be another IO action, nothing will execute it implicitly
04:51:37 <isson> "
04:54:35 <roha> is there a type of kind (* -> *) which can't be made an instance of functor?
04:54:53 <Taneb> Okay, I'm going to use Gramps XML rather than GEDCOM
04:55:03 <Taneb> roha, Set?
04:55:08 <Taneb> @kind Set
04:55:09 <lambdabot> Not in scope: type constructor or class `Set'
04:55:15 <Taneb> @kind Data.Set.Set
04:55:16 <lambdabot> * -> *
04:55:32 <Taneb> > fmap (+1) $ Data.Set.singleton 2
04:55:33 <lambdabot>   Not in scope: `Data.Set.singleton'
04:55:43 <danr> > S.singleton 2
04:55:44 <lambdabot>   fromList [2]
04:55:55 <Taneb> > fmap (+1) (S.singleton 2)
04:55:56 <lambdabot>   No instance for (GHC.Base.Functor Data.Set.Set)
04:55:57 <lambdabot>    arising from a use of `G...
04:55:57 <hpc> > succ <$> S.singleton 2
04:55:58 <lambdabot>   No instance for (GHC.Base.Functor Data.Set.Set)
04:55:58 <lambdabot>    arising from a use of `D...
04:56:00 <hpc> :(
04:56:20 <Taneb> Most manipulations of Sets require the contents to have an Ord instance
04:56:20 <roha> Hmm, so you can't make it a functor because of a possible singleton set?
04:56:33 <Taneb> No, because of the requirement of Ord
04:56:42 <Taneb> :t S.insert
04:56:43 <lambdabot> forall a. (Ord a) => a -> S.Set a -> S.Set a
04:56:56 <Taneb> :t S.map
04:56:57 <lambdabot> forall a b. (Ord a, Ord b) => (a -> b) -> S.Set a -> S.Set b
04:57:16 <Taneb> If it weren't for those Ords, it'd be a brilliant Functor
04:57:44 <Taneb> Similarly, HashSet requires a Hashable instance
04:57:47 <bitonic> Taneb: you can define a functor instance for set
04:57:51 <bitonic> *Set
04:57:59 <Taneb> Can you?
04:58:05 <bitonic> I mean, you could.
04:58:15 <Taneb> How?
04:58:27 <bitonic> the problem is that Set.map had Ord constraints
04:58:34 <bitonic> but to map over a binary tree
04:58:38 <bitonic> you don't need that constraint
04:59:06 <bitonic> now it might be a good decision to have constraints on all Set functions
04:59:22 <bitonic> but there is nothing at the type level tha prevents you from removing the Ord constraints from Set.map
04:59:43 * hackagebot PortFusion 1.0.3.2 - high-perf. distributed reverse / forward proxy & tunneling solution for TCP  http://hackage.haskell.org/package/PortFusion-1.0.3.2 (CetinSert)
04:59:57 <roha> so you can't (or shouldn't) make Set an instance of functor because it would't be possible to map ANY a -> b function over it?
05:00:13 <roha> since a -> b would have to have Ord constraints?
05:00:15 <Taneb> :t S.mapMonotonic
05:00:17 <lambdabot> forall a b. (a -> b) -> S.Set a -> S.Set b
05:00:21 <Taneb> Hmm
05:00:24 <bitonic> (I'm using Data.Set as an example of binary tree here, assuming that you don't modify the structure of the tree while mapping)
05:00:24 <Taneb> Interesting
05:00:27 <Taneb> roha, I don't know!
05:00:28 <bitonic> Taneb: oh, so it does exist.
05:00:35 <bitonic> then `fmap = mapMonotonic'
05:00:41 <bitonic> ah.
05:00:43 <bitonic> wait.
05:00:45 <bitonic> right.
05:00:50 <bitonic> Taneb, roha: sorry, I'm totally wrong.
05:01:12 <bitonic> you need to re-order the tree after you map, so you need the Ord constraint.
05:02:24 <bitonic> roha: with ConstraintKinds you can have a functor with constraints
05:02:33 <bitonic> roha: e.g. http://hackage.haskell.org/packages/archive/rmonad/0.7/doc/html/Control-RMonad.html
05:02:55 <bitonic> but otherwise no, you can't have a Functor instance because `fmap :: (a -> b) -> f a -> f b'
05:03:10 * bitonic needs to run
05:04:13 <roha> bitonic, ok thanks!
05:04:33 <Taneb> roha, also IORef needs to have the IO monad to modify
05:04:36 <bitonic> roha: apparently, you don't even need ConstraintKinds
05:04:56 <bitonic> right, you can do it with type families, cool
05:07:27 <cheater__> http://news.ycombinator.com/item?id=3966632
05:08:07 <roha> another quick question about one of the exercises on: http://www.haskell.org/haskellwiki/Typeclassopedia
05:08:27 <roha> is this sentence true or false: The composition of two Functors is also a Functor.
05:08:38 <timthelion> hpc: You mean like this? https://github.com/timthelion/gridhaskell-haskarrow/blob/master/CellMethods.lhs#L78
05:08:47 <roha> id say its false since something like [[1,2,3]] can't be mapped over with fmap?
05:09:18 <hpc> roha: sure it can
05:10:26 <roha> ok youre right it could. but fmap isn't implemented like that for lists, right?
05:10:51 <Axman6> sure it is. but we're talking about lists of lists, or the composition of two functors
05:11:20 <roha> ah sorry i interpreted the "composition of two functors" as something like list of list
05:11:24 <roha> or tupel of two tupels
05:11:57 <Axman6> well  Just [1,2,3] is also the composition of two functors isn't it?
05:12:06 <Axman6> (Maybe [Int] say)
05:12:19 <Taneb> :t fmap . fmap
05:12:20 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
05:13:00 <Peaker> > (fmap . fmap) (+100) [[1,2],[3,4]]
05:13:02 <lambdabot>   [[101,102],[103,104]]
05:13:17 <Peaker> > (fmap . fmap . fmap) (+100) [[Just 1,Nothing],[Just 3,Just 4]]
05:13:19 <lambdabot>   [[Just 101,Nothing],[Just 103,Just 104]]
05:13:29 <roha> hmm, thanks. i need to play around with that in ghci for a while :)
05:13:41 <Peaker> The idea is that you can also do something like:
05:13:55 <Peaker> newtype Compose f g a = Compose (f (g a))
05:13:59 <Peaker> which is the type-level mirror of:
05:14:06 <Peaker> (.) f g x = f (g x)
05:14:21 <Axman6> > fmap (fmap show) [[1,2,3]]
05:14:23 <lambdabot>   [["1","2","3"]]
05:14:31 <Peaker> And then you can define:   instance (Functor f, Functor g) => Functor (Compose f g) where fmap = ...
05:14:34 <Axman6> > fmap (fmap show) $ Just [1,2,3]
05:14:35 <lambdabot>   Just ["1","2","3"]
05:16:32 <roha> yea that makes sense. thanks :)
05:26:49 <mekeor> > fmap (map show) $ Just [1,2,3] -- is better :P
05:26:49 <lambdabot>   Just ["1","2","3"]
05:28:00 <hpc> > show .: Just [1,2,3] -- is even more betterer
05:28:02 <lambdabot>   Just ["1","2","3"]
05:28:12 <ion> FSVO
05:28:25 <hpc> (.:) = fmap fmap fmap
05:31:44 <Peaker> mekeor, (fmap . map) is SECish and much nicer
05:33:43 <ion> SEC?
05:33:50 <hpc> semantic editor combinators
05:34:00 <ion> Thankes
05:35:03 <hpc> basically, they let you "modify" a function by using the combinators to drill down into the type of the function and applying a function to just that part
05:35:15 <felix_> hi
05:35:21 <kopi> HI.What does this mean
05:35:22 <kopi> LLVM now supports NVIDIA GPU's
05:35:33 <ion> Probably exactly that. :-)
05:35:42 <kopi> for the haskell community
05:35:47 <felix_> what does the PlyKind extension do?
05:35:54 <felix_> *PolyKinds
05:36:15 <hpc> felix_: suppose you wrote a data type like so:
05:36:20 <ion> kopi: It means to the Haskell community that LLVM now supports nVidia GPUs.
05:36:31 <kopi> :P
05:36:33 <hpc> data Const a b = Const a -- ignore the type 'b' and hold a value of type 'a'
05:36:41 <kopi> so no amd love
05:36:51 <hpc> felix_: now you can have stuff like (Const 5) :: Const Int Bool
05:36:51 <kopi> only on nvidia gpus
05:37:05 <hpc> felix_: but you can't have that same thing be of type Const Int []
05:37:09 <hpc> or something like that
05:37:17 <hpc> because in the definition of Const, b :: *
05:37:29 <hpc> polykinds lets b be polymorphic
05:37:35 <felix_> oh ok
05:37:38 <hpc> b :: i-forget-the-notation
05:37:48 <felix_> thanks for the explanation :)
05:37:50 <hpc> and you can have (Const 5) :: Const Int Either, or whatever
05:38:18 <ion> I have a Const Int Either. How do i extract the Either from it?
05:38:27 <hpc> haha
05:38:47 <felix_> has this any practical use?
05:38:58 <felix_> where obviously practical doesn't mean "in the real world"
05:39:07 <hpc> of course, why would it? :D
05:39:23 <hpc> felix_: you can use
05:39:25 <hpc> er
05:39:54 <hpc> just off the top of my head, i think you could combine it with GADTs
05:39:59 <hpc> though that would be freaky-strange
05:40:19 <kopi> So the only choice for gpu programming is cuda in haskell
05:41:05 <felix_> ok
05:42:45 <Axman6> kopi: Accelerate also has an experimental OpenCL backend
05:44:48 * hackagebot carettah 0.1.2 - A presentation tool writtten with Haskell.  http://hackage.haskell.org/package/carettah-0.1.2 (KiwamuOkabe)
05:44:49 <kopi> Thanks will look into it still hope for haskell 1.0 version
05:45:44 <Axman6> 1.0 version of what?
05:47:02 <hiptobecubic> Axman6, do you know of any proper comparison benchmarks for accelerate? I couldn't find any
05:47:24 <kopi> ghc 1.0 :P
05:47:31 <hiptobecubic> Accelerate vs normal C-Cuda
05:48:19 <Axman6> hiptobecubic: it's likely to be slower, because afaic it doesn't do any of the optimisations you'd do in hand coded cude when it comes to rereferencing things in memory
05:48:31 <Axman6> kopi: ghc is already at version 7.4, you know this right?
05:48:56 <hiptobecubic> Axman6, i would be shocked if it wasn't slower, I'm just curious about how much so
05:49:13 <kopi> hmm my fault sorry
05:49:26 <kopi> i thought it was 0.7.4
05:49:29 <absence> http://hpaste.org/68462 <- is there some way to make that more applicative (or other suitable abstraction) and less imperative?
05:49:39 <Axman6> pretty sure it's comparable, maybe within a factor of 2 or less usually? maybe have a look at some of Manuel's papers?
05:49:50 * hackagebot hs-logo 0.5.1 - Logo interpreter written in Haskell  http://hackage.haskell.org/package/hs-logo-0.5.1 (DeepakJois)
05:49:52 <absence> that's a Binary.Get monad btw
05:51:49 <isson> hmm...
05:52:02 <Axman6> absence: why? it's quite clear what's going on. making it more applicative would just remove a lot of useful meaning, so future readers would have to go and look at the definition of Header to difure out what all the things you're parsing mean
05:52:59 <absence> Axman6: in order to learn
05:54:02 <Axman6> well in this case, i don't think you'll get anything much better, without making it much more convoluted
05:56:03 <absence> ah, that's fine then :)
05:57:25 <yitz> absence: i'll agree with Axman6 here, that's beautiful code.
05:57:44 <yitz> (actually not just here, i usually agree with Axman6.)
05:57:56 <Axman6> i think the last line is a bit long, but clear enough
05:58:01 <Axman6> aww, shucks :P
05:58:19 <yitz> :)
05:59:31 <absence> thanks, i'll keep it in that direction then. it would still be interesting/educational to see what it would look like even if i don't use it. is there a tool like pointfree that can "obfuscate" it into applicative style so i can get a better feel for where to stop?
06:00:29 <Axman6> well, the problem is that I think you _need_ to use Monad to get the reaults you want. Applicative doesn't let you use the results of one computation in another
06:01:18 <Axman6> you _might_ be able to hack it together actually, but the easiest way I can see of doing that is to use lots of nested lambdas, and that'll get ugly quickly
06:01:30 <Axman6> ok, now I'm curious! I'll see what I can do :P
06:02:58 <absence> curiosity is awesome :D
06:04:52 <hpaste> Axman6 annotated ‚Äúasfd‚Äù with ‚Äúasfd (annotation) (Ugly layout)‚Äù at http://hpaste.org/68462#a68466
06:04:59 <Axman6> absence: ^^
06:05:07 <Axman6> but it's totally not worth it
06:05:47 <Axman6> and inverts the ordering of things, which will be confusing in the future
06:07:00 <hpc> Axman6: what the french toast
06:07:22 <hpc> yeah, i would stick with Monad too :P
06:08:42 <Axman6> hmm. now I'm failing to see what you can do with Monad that you can't do with Applicative. Maybe this is just not an example that demonstrates the difference
06:09:04 <absence> i see what you mean. does it work though? doesn't <$> lift a pure function? the lambda isn't pure
06:09:31 <Axman6> :t (<$>) -- this is just fmap
06:09:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:10:51 <Axman6> @hoogle (<==)
06:10:52 <lambdabot> No results found
06:11:01 <Axman6> @hoogle (<--)
06:11:01 <lambdabot> No results found
06:12:20 <absence> what i mean is, the return type of the lambda is Get Something. if you fmap it further, won't you get Get Get Something?
06:12:44 <twanvl> Axman6: with a monad which computation is executed can depend on earlier results; with Applicative it can't, and the 'shape' of the computation is always fixed
06:13:34 <twanvl> for example, you can't do {x <- getInt ; replicateM x y} with applicative
06:14:08 <absence> Axman6: it won't compile until i wrap the whole thing in a join (so monad is needed)
06:21:04 <qnikst> hello, how can I require only positive Int in quiccheck?
06:21:39 <hiptobecubic> qnikst, i think you can specify some kind of generator function for the inputs
06:22:02 <hiptobecubic> qnikst, you could also have invalid inputs default to 'pass', although that's not a great approach
06:22:02 <ion> http://hackage.haskell.org/packages/archive/QuickCheck/2.4.2/doc/html/Test-QuickCheck.html#t:Positive
06:22:22 <ion> prop_foo (Positive n) = somethingWith n
06:22:26 <qnikst> thanks
06:22:53 <ion> hiptobecubic: (==>) is always a better alternative to *that*. :-P
06:24:06 <ClaudiusMaximus> @check \x -> x >= 0 ==> ((^2) . round . sqrt . fromIntegral) x == x  -- but i think this generates and discards some test cases unless it has superpowers
06:24:07 <lambdabot>   Not in scope: `==>'Precedence parsing error
06:24:07 <lambdabot>      cannot mix `GHC.Classes.>=...
06:25:16 <Axman6> i think it will try and generate 100 test cases that are valid by default
06:26:49 <ClaudiusMaximus> Axman6: here i get *** Gave up! Passed only 0 tests.
06:27:14 <Axman6> o.O
06:27:25 <ClaudiusMaximus> Axman6: running quickCheck $ \x -> x > 999999999 ==> ((^2) . round . sqrt . fromIntegral) x == x  in my ghci
06:27:28 <Axman6> have you specified the types?
06:27:41 <Axman6> tell it you want Int
06:28:04 <ClaudiusMaximus> Axman6: same result with Int and Integer
06:28:13 <ion> \(Positive x) -> let y = x + 999999999 in ‚Ä¶
06:28:30 <ClaudiusMaximus> ion: good call :)
06:29:00 <Axman6> ion: if the types are Int, then that's actually likely to produce many negative values
06:29:17 <Axman6> > (maxBound  - 100) + 999999999 :: Int
06:29:18 <lambdabot>   -9223372035854775910
06:31:30 <ClaudiusMaximus> @check (< 9000)
06:31:32 <lambdabot>   "OK, passed 500 tests."
06:31:39 <angstrom> is there a recursion scheme or something for folding a list not with a single function, but rather with a list of functions?
06:31:56 <Axman6> use verboseCheck if you want to see what's being generated
06:32:08 <sipa> > map ($) [(+1),(*2),(-3)] [4,3,5]
06:32:09 <lambdabot>   Couldn't match expected type `[t1] -> t'
06:32:09 <ClaudiusMaximus> angstrom: foldr (.) id  ?
06:32:09 <lambdabot>         against inferred type `[a ...
06:32:21 <Axman6> zipWith?
06:32:28 <sipa> > zipWith ($) [(+1),(*2),(-3)] [4,3,5]
06:32:30 <lambdabot>   [5,6,-3]
06:32:31 <angstrom> sipa: that's what I'm doing now :-)
06:33:23 <ClaudiusMaximus> > foldr (.) id (take 7 $ cycle [succ, pred]) EQ
06:33:25 <lambdabot>   GT
06:33:34 <hiptobecubic> What was that weird idiom in the list monad for generating power sets?
06:34:00 <ClaudiusMaximus> hiptobecubic: filterM something something
06:34:05 <hpc> > filterM (const [True, False]) [0, 1]
06:34:06 <lambdabot>   [[0,1],[0],[1],[]]
06:34:12 <hiptobecubic> hpc, ah yes. thanks
06:34:52 <hpc> > filterM (const [True, False]) [0..] -- it should be productive on infinite lists
06:34:54 <lambdabot>   *Exception: stack overflow
06:34:57 <hpc> or not
06:35:04 <hiptobecubic> hpc, :D
06:35:12 <hpc> > filterM (const [False, True]) [0..] -- perhaps...
06:35:14 <lambdabot>   *Exception: stack overflow
06:35:18 <hpc> eh
06:35:27 <hiptobecubic> Wasn't there one using bind?
06:35:43 <ClaudiusMaximus> hpc: it has to reject all of [0..] before it can give the first [] ?
06:35:46 <hpc> hiptobecubic: i think that was just filterM expanded
06:35:47 <angstrom> ClaudiusMaximus: that looks quite nice too. thanks
06:35:53 <hiptobecubic> hpc, oh
06:36:00 <hpc> @src filterM
06:36:01 <lambdabot> Source not found. Where did you learn to type?
06:47:40 <Chaze> terminology question. i can "lift" a function into another function working on different data. How is the process called of (sic) lifting the data?
06:48:05 <Chaze> so a the process of turning (a -> b) into (Maybe a -> Maybe b) is "lift"
06:48:21 <Chaze> whats the more simple process of simply wrapping an a into maybe b?
06:48:30 <Chaze> *(Maybe a)
06:48:56 <hpc> :t fmap
06:48:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:48:59 <hpc> Chaze: ^
06:49:05 <Eduard_Munteanu> :t return
06:49:06 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
06:49:18 <Eduard_Munteanu> Depends what you need.
06:49:20 <hpc> oh, terminology question
06:49:24 <Chaze> hhm, i'm not talking of the haskell function
06:49:29 <Chaze> how is that process called
06:49:31 <Chaze> in general
06:50:01 <Eduard_Munteanu> Chaze: mm, applying a functor?
06:50:03 <hpc> transformation, i suppose?
06:50:22 <Chaze> i think you can't get anymore specefic than "transformation"..
06:50:28 <Chaze> specific*
06:51:24 <yitz> Chaze: in category theory it's called "applying a functor". but you'll get some raised eyebrows if you try to use that one outside of here. ;)
06:51:30 <Eduard_Munteanu> Applying a functor to an arrow is what fmap does. You get the objects simply by applying the type constructor.
06:59:31 <Guest95536> hello
07:13:48 <hpaste> Modius pasted ‚ÄúExcerpt from functional RB tree‚Äù at http://hpaste.org/68468
07:14:36 <Modius> In the fragment I just pasted, I don't understand what the T B a z b and T _ a z b = ... do or have to do with eachother.  T is the type constructor for the non-empty tree node
07:14:58 <Modius> Does T get redefined locally somehow in the "where" section?
07:18:53 <navaati> hi
07:19:58 <Axman6> Modius: it's pattern matching on all the values in and ignoring the first value, and assigning the second the name a, the thiurd z and the last b
07:20:00 <geekosaur> "T _ a z b = ins s" defines a, z, and b by taking apart the result of ins s
07:22:06 <Modius> So it's kind of the equivalent of just saying "ins s - but let all the code below have these variables bound"
07:22:09 <Guest95536> hello
07:22:34 <Modius> I'm Hmm - no I was mistaken strike my last remark
07:23:08 <Guest95536> http://hpaste.org/new/haskell
07:23:36 <navaati> i've got a function of a type similar to "send :: forall a. a -> IO ()" and an other one of type similar to "getEvent :: forall a. IO a", would there be a type-system trick to say that in a particular scope i want the 'a' in send to be the same that the a in getEvent ?
07:24:05 <Modius> This code belongs in a better/easier to find place than some dead page in oz.
07:26:01 <hiptobecubic> is mwc the fastest RNG we have?
07:29:52 * hackagebot http-conduit 1.4.1.3 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.4.1.3 (MichaelSnoyman)
07:29:53 <yitz> navaati: what can you do with a function of that type? certainly you can't actually send anything, not knowing anything about a.
07:31:33 <yitz> hiptobecubic: afaik people use something like the ffi binding to mersenne when they need something fast. what's mwc?
07:31:58 <geekosaur> I think that *is* the ffi binding to mersenne
07:32:05 <yitz> ah
07:33:04 <yitz> hiptobecubic: there's some package that leverages hardware crypto on modern cpus to generate random numbers. not sure if that's faster or not.
07:35:18 <navaati> yitz: i'm binding to a C interface that accepts a pointer to void in an action and later generates an event with that same pointer given back to the user, so that he can know which action this event refers to
07:35:39 <navaati> so i'm gonna use StablePtr
07:36:01 <yitz> navaati: oh that's a horrible interface. ugh. leave it to c.
07:36:03 <navaati> a solution would be to use Data.Dynamic, but it's a bit ugly
07:36:48 <twanvl> in haskell you would probably just put an event handler into the pointer, and call that
07:36:52 <navaati> or i could make the haskell binding less flexible than in C and simply pass an id
07:37:07 <navaati> twanvl: ah, pretty clever !
07:37:12 <yitz> navaati: so in c you obviously cast that pointer. you'll have no choice but to do the same. i would try to do it in c before it sullies your haskell, but if not, unsafeCoerce might be your only option.
07:37:26 <ClaudiusMaximus> @hoogle castFun
07:37:27 <lambdabot> Foreign.Ptr castFunPtr :: FunPtr a -> FunPtr b
07:37:27 <lambdabot> Foreign.Ptr castFunPtrToPtr :: FunPtr a -> Ptr b
07:37:55 <yitz> ClaudiusMaximus: that actually sounds like no fun at all.
07:38:01 <navaati> :t castPtrToStablePtr
07:38:02 <lambdabot> Not in scope: `castPtrToStablePtr'
07:38:05 <navaati> more adapted
07:38:23 <navaati> ah, damn : castPtrToStablePtr :: Ptr () -> StablePtr a
07:38:30 <navaati> still dangerous, though
07:38:54 <navaati> twanvl: by "an event handler, you mean an IO () ?
07:39:02 <twanvl> yes
07:39:14 <twanvl> or (X -> IO()) if you have some more information
07:39:37 <t7> It seems silly how ghci doesnt import the imported modules if your code doesnt typecheck
07:39:38 <yitz> i like twanvl's idea (in case you haven't figure that out)
07:39:41 <navaati> yeah. seems it's The Right Way
07:39:51 <navaati> thanks :)
07:39:59 <ClaudiusMaximus> http://www.haskell.org/haskellwiki/GHC/Using_the_FFI#Callbacks_into_Haskell_from_foreign_code
07:40:03 <yitz> t7: yes. i think there's a feature request about that.
07:40:03 <t7> i mean i wanna figure out why its not typing. so i probly wanna :t on some module functions?!
07:40:26 <t7> ah ok
07:40:36 <yitz> t7: find it and vote for it. ;)
07:42:24 <Taneb> @source even
07:42:25 <lambdabot> even not available
07:43:21 <fmap> @src even
07:43:22 <lambdabot> even n = n `rem` 2 == 0
07:45:20 <absence> Axman6: http://hpaste.org/68462 <- this is somewhat interesting/"fun", but not really clearer. what do you think?
07:47:46 <ferh332> ninegrid: may be you have more documents on voxel and graphics?
07:51:46 <t7> whats the infix for fmap again?
07:51:53 <mm_freak> t7: <$>
07:51:58 <t7> cheers
07:52:09 <mm_freak> you need to import Control.Applicative
07:52:19 <t7> i thought it was functor or something
07:52:27 <mm_freak> yes
07:52:39 <mm_freak> C.A defines it as a convenience alias for fmap
07:52:43 <hpc> @quote golf
07:52:43 <lambdabot> Jafet says: caleskell is the standard golf course.
07:52:55 <hpc> @quote golf.*Monad
07:52:56 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
07:53:01 <hpc> @quote Monad.*golf
07:53:02 <lambdabot> No quotes match. You untyped fool!
07:53:04 <hpc> pah
07:53:12 <mm_freak> @quote golf monad
07:53:12 <lambdabot> No quotes for this person. My pet ferret can type better than you!
07:53:16 <mm_freak> uh
07:53:24 <hpc> basically, import Control.Monad, Control.Applicative, Control.Arrow
07:53:31 <hpc> and you have all the combinators you could ever need
07:53:44 <mm_freak> caleskell is not really consistent with Control.Category
07:53:52 <mm_freak> and i prefer the Category way of generalizing (.)
08:00:37 <everythingWorks> Im on linux and im using the "ghci" program, how can i load a module i've just written and stored into a file?
08:00:49 <everythingWorks> after loading, i'd like to call some method, for example "fac"
08:00:52 <mm_freak> everythingWorks: :l
08:00:52 <everythingWorks> I tried this:
08:00:57 <everythingWorks> :load fac.hs
08:00:59 <everythingWorks> fac 42
08:01:05 <everythingWorks> the module load seems to work..
08:01:11 <everythingWorks> but the execution of the function doe snot work
08:01:21 <jgr> everythingWorks: thought about lazyness?
08:01:26 <mm_freak> everythingWorks: did you compile the module?
08:01:27 <everythingWorks> It looks like it waits for more input
08:01:36 <jgr> everythingWorks: :t fac, please
08:01:41 <everythingWorks> mm_freak: when i load it, it sais it has been compiled/interpreated
08:01:44 <Taneb> everythingWorks, it looks like it's really slow
08:01:55 <mekkz> Is fac the function name AND the module name?
08:02:02 <mm_freak> everythingWorks: then i second jgr's request‚Ä¶  what's the type of 'fac'?
08:02:22 <mm_freak> mekkz: if anything, the module name would be Fac
08:02:37 <mm_freak> for :l ghci does not require module name = file name
08:02:51 <everythingWorks> http://dl.dropbox.com/u/6559846/hs_.PNG
08:03:02 <mekkz> Yes, but everything was calling the function "fac 42"
08:03:13 <mm_freak> everythingWorks: then please paste the source code
08:03:15 <jgr> everythingWorks: then it's just really slow.
08:03:16 <everythingWorks> mekkz: it's the same for "fac 2"
08:03:18 <mm_freak> @where hpaste
08:03:18 <lambdabot> http://hpaste.org/
08:03:23 <Taneb> Is fac "fac 0 = 1; fac n = n * (fac n - 1)", by any chance?
08:03:39 <mm_freak> Taneb: unlikely
08:03:41 <Taneb> Or something similar
08:03:43 <mm_freak> that would be fast enough
08:03:48 <everythingWorks> taneb: yes it is
08:03:48 <mekkz> why unlikely
08:03:48 <mm_freak> at least for 2
08:03:55 <Taneb> mm_freak, told you so
08:04:05 <Taneb> mm_freak, he said 42
08:04:16 <jgr> Taneb: in the link he posted, it was 2
08:04:35 <Taneb> jgr, in the original question, he said 42
08:04:42 <everythingWorks> 42 or 2, it does'nt matter in this case.
08:04:44 <mm_freak> that has the same speed as the foldl variant
08:04:46 <mm_freak> foldl (*) 1 [1..1000]
08:04:47 <Taneb> Hmm
08:04:52 <mm_freak> finishes within milliseconds here
08:04:55 <jgr> Taneb: i know, but doesn't matter :)
08:05:06 <mm_freak> everythingWorks: anyway, please paste the module on hpaste
08:05:10 <jgr> everythingWorks: could you please paste the source of fac?
08:05:15 <Taneb> > let fac 0 = 1; fac n = n * (fac n - 1) in fac 2
08:05:16 <lambdabot>   *Exception: stack overflow
08:05:16 <everythingWorks> yes, one moment!
08:05:27 <mm_freak> oh Taneb
08:05:28 <Taneb> There's the problem
08:05:29 <mm_freak> i see it now
08:05:32 <mm_freak> ok =)
08:06:13 <mm_freak> then i'm surprised that doesn't blow everythingWorks' memory
08:06:23 <Taneb> It just hangs
08:06:34 <Taneb> everythingWorks, try putting brackets around the n - 1
08:06:35 <everythingWorks> yep.
08:06:51 <mm_freak> it should blow the memory, because it will build an infinite expression
08:07:10 <everythingWorks> why does this give an overflow?
08:07:18 <mm_freak> everythingWorks: fac n - 1 = (fac n) - 1
08:07:19 <Taneb> Because it's parsing it as (fac n) - 1
08:07:34 <Axman6> which will never terminate
08:07:37 <everythingWorks> i understand! :D
08:07:43 <jgr> unless n is 0
08:07:45 <jgr> :)
08:08:05 <jgr> (well, in which case, the rule would never be applied :p)
08:08:09 <Taneb> mm_freak, I get a stack overflow message in ghci running that
08:08:24 <everythingWorks> aaaaaaaaand... working! :D
08:08:26 <mm_freak> Taneb: if you compile it i'd expect a heap overflow instead, but i'm not sure
08:08:39 <everythingWorks> ( with fac (n-1) )
08:08:41 <mm_freak> (don't try without +RTS -M512m)
08:09:25 <mm_freak> > let x = x in x
08:09:28 <ion> > let fac n = snd (facs !! n); facs = (0,1) : map (\(n,f) -> ((n+1), (n+1) * f)) facs in fac 42
08:09:29 <lambdabot>   mueval-core: Time limit exceeded
08:09:29 <lambdabot>   1405006117752879898543142606244511569936384000000000
08:09:51 <everythingWorks> mm_freak why do you think it should be a heap overflow?
08:09:53 * hackagebot dbmigrations 0.5 - An implementation of relational database "migrations"  http://hackage.haskell.org/package/dbmigrations-0.5 (JonathanDaugherty)
08:10:04 <mm_freak> everythingWorks: because it builds an expression, which is a heap operation
08:10:14 <mm_freak> at least for compiled code
08:10:16 <everythingWorks> I *assume* the problem is, that inf. function calls are made, where each function call stores itself and its arguments on the stack
08:10:23 <mm_freak> GHCi evaluates slightly differently
08:10:41 <everythingWorks> (which leads to an overflow)
08:11:05 <mm_freak> > let fac n = (let x = n * (x - 1) in x) in fac 2
08:11:09 <lambdabot>   mueval-core: Time limit exceeded
08:11:26 <mm_freak> there we go‚Ä¶  i think strictness analysis is the reason why it blows the heap instead of the stack
08:12:23 <everythingWorks> does the "Num" type have a range or is it infinite? :D
08:12:32 <mm_freak> everythingWorks: Num is a type class
08:12:47 <mm_freak> a class of types with certain common functions like (+)
08:12:57 <mm_freak> can be Int, Integer, Double, Complex, etc.
08:13:10 <mm_freak> Integer is unbounded
08:13:23 <mm_freak> > 3^10000 :: Integer
08:13:24 <lambdabot>   163135018534262587430325672918115471681213245358253799393482032619182573081...
08:13:48 <everythingWorks> but Int isnt, right?
08:13:54 <mm_freak> correct
08:13:56 <mm_freak> > 3^10000 :: Int
08:13:57 <everythingWorks> > 3^10000 :: Int
08:13:58 <lambdabot>   781293612478825281
08:13:58 <lambdabot>   781293612478825281
08:14:01 <everythingWorks> ;)
08:14:11 <Taneb> > (minBound, maxBound) :: (Int, Int)
08:14:13 <lambdabot>   (-9223372036854775808,9223372036854775807)
08:14:29 <mm_freak> Int is guaranteed to be at least 29 bits, i think
08:14:40 <Taneb> lambdabot uses 64?
08:14:44 <mm_freak> yeah
08:14:45 <ion> Int shouldn‚Äôt exist in Prelude.
08:14:51 <mm_freak> ion: why?
08:14:51 <Cale> In practice, it's a power of 2
08:15:06 <everythingWorks> In my machine, it uses 32 bit :)
08:15:14 <Cale> I don't know of any implementation of Haskell which ever made use of that provision
08:15:40 <Cale> (the extra couple bits it's allowed to reserve for tags)
08:15:47 <mm_freak> Cale: i've read somewhere that early haskell implementations used one of the bits to indicate the evaluation state
08:15:50 <t7> @hoogle Set.filter
08:15:51 <lambdabot> Data.Set filter :: Ord a => (a -> Bool) -> Set a -> Set a
08:15:51 <lambdabot> package bloomfilter
08:15:51 <lambdabot> package hxt-filter
08:16:23 <ion> mm_freak: If you want an integer, use Integer. If you want an ‚Äúint‚Äù for FFI, use CInt. If you want an integer of a certain bit width, use IntNN. What‚Äôs the justification for Int?
08:16:27 <Taneb> Is there a better way to say \foo -> foo {bar = baz (bar foo)} ?
08:16:40 <mm_freak> ion: it's usually a machine word integer
08:16:43 <mekkz> (minBound, maxBound) :: (Integer, Integer)
08:16:51 <mm_freak> so it's reasonable to use Int for 'take' and similar functions
08:17:10 <mm_freak> 'take' is ultimately bounded by the available memory, so using Integer would be pretty pointless
08:17:45 <mm_freak> even though it's not specified you can expect Int to be "the fast machine integer type"
08:17:57 <Cale> Except that lists might be much larger than will fit in memory
08:18:01 <Cale> even finite ones
08:18:13 <ion> taneb: http://hackage.haskell.org/package/data-lens http://hackage.haskell.org/package/data-lens-template
08:18:16 <Cale> even in programs which will run and terminate without exhausting the machine resources
08:18:17 <Cale> lol
08:18:22 <hpc> http://hpaste.org/68471 -- this isn't working for me
08:18:39 <Taneb> ion, problem is, I'm defining lenses?
08:18:42 <hpc> it works exactly as it should when given "source", but does nothing at all when given "client"
08:18:51 <Taneb> Ooh, didn't see the template one
08:18:51 <hpc> and doesn't even reach the end of listen
08:19:40 <mm_freak> hpc: hSetBuffering handle LineBuffering
08:19:45 <mm_freak> or NoBuffering
08:19:53 <mm_freak> or use a proper stream processing abstraction like conduit
08:20:21 <Taneb> Basically, I have the line:
08:20:21 <Taneb> personLens n = lens ((IM.! n) . pepl) (\person familyTree -> familyTree {pepl = IM.insert n person $ pepl familyTree})
08:20:26 <Taneb> And I want it neater
08:20:31 <everythingWorks> Is ghci just for testing programs?
08:20:42 <everythingWorks> .. or should i execute all my haskell programs within it?
08:20:44 <Cale> consider something like length [1 .. 2^31] on a 32 bit machine.
08:20:52 <Cale> everythingWorks: Mainly for testing
08:20:56 <hpc> mm_freak: where? it works for source, but not client
08:21:03 <everythingWorks> Cale okay! thanks
08:21:06 <mm_freak> Taneb: Data.Lens.Common has ready-made lenses for many things including IntMap
08:21:06 <hpc> oh, nvm
08:21:09 <hpc> i see what you mean
08:21:16 <mm_freak> hpc: after accepting
08:21:19 <Cale> everythingWorks: If your programs are simple enough that you don't need a proper user interface, it can be quite convenient
08:21:30 <mm_freak> Taneb: also note that Lens is a Category
08:21:37 <Cale> everythingWorks: But your program will run much much faster if compiled with optimisations.
08:21:38 <Taneb> mm_freak, problem is, I have a type which is three IntMaps
08:21:48 <everythingWorks> Cale: I think so too! :D
08:21:53 <mm_freak> Taneb: cascaded?
08:21:59 <ferh332> what do you think, which has more performance: Data.Vector.Unboxed or Data.Vector.Storable?
08:22:01 <hpc> woot
08:22:09 <mm_freak> ferh332: Unboxed
08:22:13 <everythingWorks> How can i give my program command line options, so i may run it as an actual linux program like this:
08:22:21 <everythingWorks>  ./fac 10
08:22:35 <mm_freak> ferh332: the runtime is free to move unboxed vectors around, while storable vectors have to stay where they are in memory
08:22:46 <twanvl> ?type getArgs
08:22:47 <lambdabot> Not in scope: `getArgs'
08:22:55 <Taneb> data FamilyTree = FamilyTree {name :: Text, pepl :: IntMap Person, fmls :: IntMap family, evns :: IntMap Event}
08:23:13 <Cale> :t System.Environment.getArgs
08:23:14 <lambdabot> IO [String]
08:23:15 <mm_freak> Taneb: you can use data-lens-template to derive lenses for FamilyTree
08:23:22 <confab> :t (=?)
08:23:23 <lambdabot> Not in scope: `=?'
08:23:27 <confab> bleh
08:23:38 <mm_freak> Taneb: the just use it like:  intMapLens x . fmls
08:23:54 <everythingWorks> kk
08:24:05 <mm_freak> as said, Lens is a Category‚Ä¶  you can compose lenses to get deeper into the structure
08:25:04 <hiptobecubic> yitz, i was thinking about something like that as well... the ffi
08:25:08 <Taneb> Hmm
08:25:19 <hiptobecubic> yitz, http://hackage.haskell.org/packages/archive/mwc-random/latest/doc/html/System-Random-MWC-Distributions.html
08:25:56 <hiptobecubic> yitz, is what i'm using now, which I guess is reasonably fast? But the profiler says that i'm spending the majority of my time just generating random numbers rather than doing the actual computation that i'm interested in
08:26:14 <hiptobecubic> I've never used the ffi before though...
08:26:21 <Taneb> Actually...
08:26:30 <Taneb> I'm not sure if a Lens is what I want at all
08:26:44 <mm_freak> Taneb: likely it is =)
08:26:55 <Taneb> All the things are so interlinked!
08:27:28 <mm_freak> Taneb: lenses are graphlike, not treelike, so there is nothing wrong with traversing the structure with lenses
08:27:52 <Taneb> I need to learn more of these lenses...
08:28:29 <mm_freak> children . child "julia" . children . person "jim"
08:28:39 <ferh332> mm_freak: one more question: If I need to have multidimension Data.Vector and the Vector contains some record, which will be mostrly read or updated as a storage. Is there a way to have performance without using mutable storage.
08:28:40 <mm_freak> that's the children of jim's child julia
08:29:28 <mm_freak> ferh332: what are the operations you perform?  are you updating individual elements a lot?
08:29:44 <Taneb> Can I say "a husband of a daughter of someone who was at this event"?
08:29:56 <mm_freak> Taneb: sure
08:30:43 <mm_freak> Lens should be a profunctor
08:31:13 <mm_freak> @tell edwardk it would be convenient if Lens were a profunctor
08:31:14 <lambdabot> Consider it noted.
08:31:14 <ferh332> mm_freak: just updating the record in the multidimension vector. yes, a lot of read/ and moderate update. no creation
08:31:37 <mm_freak> ferh332: random update?  or are you always updating all elements in one go?
08:31:48 <ferh332> mm_freak. Random
08:31:57 <mm_freak> ferh332: then you probably don't want a Vector at all
08:32:01 <mm_freak> try IntMap instead
08:33:35 <ferh332> mm_freak: and why intMap is better?
08:34:19 <Taneb> Are tuples profunctors?
08:34:23 <ferh332> mm_freak: one more problem is that my storage should be very memory efficient
08:35:05 <sebasmagri> Hey, I'm getting ExitFailure 127 for every cabal file which needs to compile something in C... do anyone knows why could it be?
08:35:32 <mm_freak> ferh332: O(log n) update of immutable maps
08:36:14 <Taneb> Nevermind, I've just encountered profunctors for the first time, I don't know how they work
08:36:15 <mm_freak> well, IntMap has an upper bound on the complexity, so theoretically it's even constant, but practically it's logarithmic
08:36:35 <mm_freak> Taneb: bifunctors are tuple-like
08:36:40 <mm_freak> profunctors are function-like
08:37:05 <mm_freak> ferh332: packed vectors are of course the most memory-efficient
08:37:10 <mm_freak> at least if you never do deletion
08:37:27 <Taneb> There's a whole world of Profunctors and Bifunctors and Categories out there, and it's magical
08:37:44 <hpaste> e_works pasted ‚Äúcommand line args‚Äù at http://hpaste.org/68472
08:37:59 <everythingWorks> I tried interpreting the first arg as Integer :)
08:38:38 <mm_freak> everythingWorks: i strongly recommend writing type signatures for top level definitions like main, parse and fac
08:38:52 <mm_freak> in fact i recommend writing them /before/ you write the implementation
08:39:24 <everythingWorks> mm_freak: At the top of each module all the type definitions and below all implementations?
08:39:47 <bitonic> everythingWorks: that doesn't matter. most people prefer at the top of the implementation.
08:39:51 <mm_freak> everythingWorks: i usually keep signature and definition together
08:39:55 <bitonic> I've seen them at the tom of each module as well
08:40:10 <everythingWorks> i understand :D
08:40:13 <mm_freak> having them at the top is a bit inconvenient
08:41:00 <everythingWorks> Do you have an idea what the "problem" in parsing the 1st arg could be here?
08:41:13 <mm_freak> everythingWorks: write the types
08:41:24 <mm_freak> once you've done that i'll ask you some questions that lead you to the solution =)
08:41:38 <everythingWorks> okay :)
08:43:56 <Taneb> That's the problem with wandering about when on IRC
08:47:30 <ferh332> mm_freak, In fact it would be good that I could reuse vectors. I'll tell you little more. I have some data in HDD, the data is divided to same size chunks, the chunk has same size records. on event I need to load the chunk, decompress it and store to RAM (some data structure),  Then the chunk records are viewed/modified. when data is not neded it is compressed/serialized to hdd again. one...
08:47:32 <ferh332> ...chunk is about 300KB. may be you have some Ideas
08:47:36 <ferh332> ?
08:48:23 <t7> i keep using $ in the shell now
08:49:13 <mm_freak> ferh332: that question is more involved‚Ä¶  it really depends on the exact application domain
08:49:26 <mm_freak> but it sounds like i would use an IntMap representation in memory
08:49:34 <mm_freak> probably with vectors as individual elements
08:49:46 <mm_freak> IntMap (Vector MyRecord)
08:50:32 <ferh332> mm_freak: its kind of "soft real time" app
08:50:49 <roha> where can i find the source code for the functor/monad instances for ((->) r)?
08:51:23 <mm_freak> roha: in the base library, but i invite you to the mental exercise to write them yourself
08:51:26 <mm_freak> start with Functor
08:51:31 <c_wraith> Control.Monad.Instances has the Monad instance
08:51:33 <ferh332> mm_freak: I am grateful for your time, thank you :)
08:52:06 <mm_freak> ferh332: as far as i can help =)
08:52:17 <mm_freak> roha: (r ->) is really similar to Reader r
08:52:19 <roha> mm_freak, i did the functor but i think its wrong :)
08:52:31 <Axman6> roha: are the types correct?
08:52:44 <mm_freak> roha: if it typechecks it's most likely correct
08:52:47 <t7> can i make this nicer: subs s (Scheme bs t) = Scheme bs (subs (Map.filterWithKey (\k _ -> not $ k `Set.member` bs) s) t)
08:52:54 <t7> hlint didnt offer anything
08:52:54 <roha> yes, but it's basically just   data F a b = F a b
08:52:56 <mm_freak> there is not much potential to write a wrong Functor instance for (r ->) =)
08:53:25 <roha> and then instance Functor (F a)
08:53:26 <mm_freak> t7: not really
08:53:54 <Axman6> roha: that has nothing to do with writing a fiunctor instance for (r ->) though
08:53:57 <mm_freak> @djinn (a -> b) -> (e -> a) -> e -> b
08:53:57 <lambdabot> f a b c = a (b c)
08:54:16 <mm_freak> ok, if it typechecks, it must be either correct or an infinite loop =)
08:55:57 <roha> Axman6, i tried to make a wrapper for (r ->) since (r ->) already is an instance of functor. but i believe im really just completely on the wrong track, hehe
08:56:05 <everythingWorks> mm_freak: I've no idea :o
08:56:23 <mm_freak> everythingWorks: what's the type of fac?
08:56:37 <mm_freak> answer that without asking ghci
08:56:41 <Axman6> roha: well the first step is to figure out the function fmap for (r ->) should have. then write a function called something like fmap_function with that type
08:56:46 <everythingWorks> Integer -> Integer i'd guess
08:57:01 <mm_freak> everythingWorks: yeah, that's a reasonable type
08:57:02 <Axman6> uh, function? type*
08:57:08 <mm_freak> now what's the type of 'parse'?
08:57:11 <Axman6> i should go to bed, it's almost 2
08:57:22 <everythingWorks> [char] -> IO a
08:57:25 <ferh332> mm_freak, some more questions. Should I use mutable data for such a thing?
08:57:29 <everythingWorks> (whatever this 'IO a' means ;) )
08:57:29 <mm_freak> everythingWorks: no
08:58:03 <mm_freak> everythingWorks: view it in isolation‚Ä¶  'parse' should really just parse a string to a number
08:58:16 <everythingWorks> String -> Integer :)
08:58:35 <everythingWorks> ( or [Char] -> Integer which should be the same)
08:58:49 <roha> Axman6, ok thanks. I'll try again
08:59:04 <mm_freak> everythingWorks: correct, and yes, that's the same
08:59:20 <mm_freak> everythingWorks: now rewrite 'parse' such that it really does what its name suggests =)
09:00:01 <everythingWorks> okay, done :)
09:00:17 <mm_freak> everythingWorks: code?  i assume it's only one line, so just paste it here
09:00:27 <everythingWorks> parse str = read str :: Integer
09:00:40 <mm_freak> did you write a type signature?
09:00:44 <everythingWorks> yes
09:00:48 <everythingWorks> parse :: String -> Integer
09:00:51 <mm_freak> then the type annotation is not necessary
09:01:07 <mm_freak> parse = read
09:01:08 <everythingWorks> okay
09:01:10 <mm_freak> =)
09:01:37 <mm_freak> no what is the type of the function that parses a string to an integer and returns the integer's factorial?
09:01:55 <mm_freak> s/^no/now/
09:02:34 <everythingWorks> String -> Integer
09:07:01 <ferh332> mm_freak?
09:07:30 <mm_freak> everythingWorks: correct‚Ä¶  and how would you write that function?
09:07:48 <mm_freak> everythingWorks: remember:  you have String -> Integer1 and Integer1 -> Integer2
09:07:53 <mm_freak> you want String -> Integer2
09:07:58 <mm_freak> do you see a pattern there? =)
09:14:56 <everythingWorks> mm_freak yes ;)
09:15:16 <mm_freak> ferh332: sorry, but this is really all information i can offer
09:15:35 <everythingWorks> may it be >> parse >>= fac ?
09:15:39 <mm_freak> everythingWorks:
09:15:40 <mm_freak> no
09:15:50 <mm_freak> :t (Prelude..)
09:15:51 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
09:17:14 <omg911> is there a function to print all digits of a double (without reverting to scientific notation)?
09:17:32 <everythingWorks> mm_freak was this :t for me?
09:17:35 <ferh332> mm_freak. ok, thank you again :) sorry for the bother :)
09:17:45 <mm_freak> everythingWorks: yes
09:17:55 <ion> omg911: In binary or hex?
09:18:02 <mm_freak> omg911: printf can do that
09:18:10 <omg911> in base 10
09:18:20 <ion> omg911: That would potentially return infinite strings.
09:18:33 <mm_freak> > printf "%0.8" (1/7 :: Double) :: String
09:18:34 <lambdabot>   "*Exception: Printf.printf: formatting string ended prematurely
09:18:39 <mm_freak> > printf "%0.8f" (1/7 :: Double) :: String
09:18:40 <lambdabot>   "0.14285714"
09:18:45 <omg911> well i can truncate it...
09:18:55 <omg911> mm_freak: thanks
09:19:16 <everythingWorks> mm_freak sorry..
09:19:17 <ion> omg911: If truncation is okay,
09:19:18 <hiptobecubic> you can import two modules into the same namespace with qualified!?
09:19:20 <ion> > show (1/7 :: Double)
09:19:21 <lambdabot>   "0.14285714285714285"
09:19:34 <mm_freak> hiptobecubic: yes
09:19:43 <mm_freak> import qualified Data.Text as T
09:19:45 <mm_freak> import qualified Data.Text.IO as T
09:19:53 <hiptobecubic> Damn.
09:20:13 <hiptobecubic> I wish I had known that yesterday ... :/
09:20:34 <everythingWorks> i don't know what it does o0
09:20:36 <ion> > quickCheck $ \x -> (read . show :: Double -> Double) x == x
09:20:36 <lambdabot>   Not in scope: `quickCheck'
09:20:40 <ion> @check $ \x -> (read . show :: Double -> Double) x == x
09:20:41 <lambdabot>   <no location info>: parse error on input `$'
09:20:49 <ion> asdf
09:20:51 <ion> @check \x -> (read . show :: Double -> Double) x == x
09:20:53 <lambdabot>   "OK, passed 500 tests."
09:23:14 <everythingWorks> mm_freak can you tell me the solution? ;)
09:23:39 <mm_freak> everythingWorks: type :t (.) into ghci
09:26:31 <everythingWorks> mm_freak yes? :)
09:26:45 <mm_freak> compare the types‚Ä¶  look for a pattern
09:26:53 <mm_freak> you have A -> B and B -> C
09:26:57 <mm_freak> you want A -> C
09:27:29 <everythingWorks> normally i'd just call toC(toB(A))
09:27:37 <hpc> @src (.)
09:27:38 <lambdabot> (f . g) x = f (g x)
09:27:38 <lambdabot> NB: In lambdabot,  (.) = fmap
09:31:08 <everythingWorks> This is nice, but i don't see how this gonna solve the type conversation :/
09:31:11 <everythingWorks>  -> Couldn't match expected type `IO b' against inferred type `Integer'
09:31:46 <Cale> everythingWorks: What's your question?
09:32:05 <everythingWorks> How to read an integer from a command line (arg)
09:32:06 <Cale> everythingWorks: That seems to indicate that you haven't run an IO action that you meant to run
09:33:05 <Cale> main = do [x] <- getArgs; let { n = read x }; ... do stuff with n ...
09:33:46 <Cale> You might have to tell it that n is meant to be an Integer somewhere if the rest of the program doesn't make it clear.
09:33:58 <Cale> (but usually it will)
09:34:41 <Cale> This will simply fail with a pattern match failure if the program is passed any number of args other than 1
09:34:54 <Cale> If you'd rather do something nicer you might want a case expression
09:35:06 <Taneb> Dammit
09:35:32 <Cale> do xs <- getArgs; case xs of [x] -> doStuffWith x ; _ -> printHelpfulMessage
09:36:01 <Taneb> printHelpfulMessage is the best function
09:36:44 <everythingWorks> :)
09:37:29 <everythingWorks> thanks Cale ;)
09:38:17 <Taneb> Okay, I have a type Person with a field fams which is an IntSet
09:39:16 <Taneb> And I have a type Family with two Ints and an IntSet
09:39:28 <Taneb> These are stored in an IntMap each
09:39:50 <Taneb> So the Ints in Fams represent all the families which the person is part of
09:40:27 <Taneb> And all the Ints in the Family type represent people in the family
09:41:51 <Taneb> And I'm trying to write lenses so that if you (am I allowed to use "modify"?) modify a person's fams field using the lens, it alters those Familiews
09:41:55 <Taneb> * Families
09:42:09 <Taneb> This is harder than I anticipated; I can't see how to do it
09:42:20 <mietek> pcapriotti: hello
09:42:42 <Taneb> Any ideas?
09:43:00 <Cale> Taneb: Well, what's the type going to be?
09:43:15 <Taneb> Which type?
09:43:29 <Cale> Taneb: The type of the lens, or even just the type of the modify function
09:43:45 <Cale> What are the things which it's taking and producing?
09:43:52 <Taneb> Lens FamilyTree Person
09:44:59 <Cale> okay, brb, pancakes :D
09:45:10 <Taneb> Where FamilyTree is defined as data FamilyTree = FamilyTree {name :: Text, people :: IntSet Person, families :: IntSet Family}
09:45:12 <Taneb> L
09:45:14 <Taneb> *K
09:46:20 <isson> mm_break, are you there?
09:46:29 <roconnor_> Taneb: I got a little lost in your description
09:48:22 <Taneb> data Person = Person {name :: Text, fams :: IntSet}; data Family = Family {hed1 :: Int; hed2 :: Int; cdrn :: IntSet}; data FamilyTree = FamilyTree {pepl :: IntMap Person, fmls :: IntMap Family}
09:48:39 <Taneb> (the actual data types are slightly more complicated, and I know my naming sucks)
09:49:12 <roconnor_> Taneb: IntSet Person and IntSet Family makes no sense to me
09:49:26 <Taneb> I meant IntMap
09:49:35 <Taneb> ... I said IntMap
09:50:08 <Taneb> Oh, I didn't the first time
09:50:37 <Cale> okay
09:51:18 <Taneb> Shall I paste the whole mess?
09:51:32 <Cale> So, let's do it in terms of put and get. I'm assuming that get is easy. Updating a Person with put will require both the people and the families maps to be updated
09:51:33 <roconnor_> Taneb: Is there some sort of invariant in these structures that you expect to always hold?
09:52:41 <Cale> Taneb: wait, IntSet Person?
09:52:45 <Taneb> roconnor_, every person referenced by the Ints in each Family has the Int referencing the family in their fams IntSet
09:52:47 <Cale> Do you mean IntMap?
09:52:50 <Taneb> Ys
09:53:17 <Taneb> I'll just paste the whole, slightly more complicated than I've been saying, badly programmed mess
09:53:29 <hpaste> Taneb pasted ‚ÄúFamily Tree so far: lens problem‚Äù at http://hpaste.org/68473
09:55:39 <Cale> Taneb: okay, so for every Family in the IntMap, you need to look and see if the person belongs to that family, and if not, remove it, and if so, insert it
09:55:56 <Taneb> The problem is, where in the family to insert it
09:56:28 <Taneb> hed1, hed2, or cdrn
09:56:38 <Cale> Oh, it could go in multiple places?
09:56:46 <Taneb> Yeah
09:56:47 <Cale> Okay, then this is simply impossible :D
09:57:00 <roconnor_> What if there are two people with the same name?
09:57:15 <Taneb> They're indexed by an Int, not their name
09:57:20 <Taneb> (in the IntMap)
09:58:05 <Cale> Taneb: If the lens parameter doesn't uniquely determine where the person is supposed to go, you'll have to extend it with information saying where.
09:58:52 <Taneb> Or make it invalid to add a person to a family from the peson
09:58:55 <Taneb> *person
09:59:36 <Taneb> Which I think is a lot more possible
09:59:41 <aristid> :t \f -> fmap f Control.Category.id
09:59:41 <lambdabot> forall a b (cat :: * -> * -> *). (Control.Category.Category cat, Functor (cat a)) => (a -> b) -> cat a b
09:59:44 <roconnor_> making the lens operation fail at runtime is a direction one would proceed with hesiation.
09:59:53 <aristid> @hoogle (a -> b) -> cat a b
09:59:54 <lambdabot> Control.Arrow arr :: Arrow a => (b -> c) -> a b c
09:59:54 <lambdabot> Control.Monad.Trans.Reader reader :: (r -> a) -> Reader r a
09:59:54 <lambdabot> Control.Monad.Reader reader :: (r -> a) -> Reader r a
10:00:11 <Taneb> roconnor_, I'd make it just ignore any added families
10:00:23 <roconnor_> Taneb: then it won't satisfy the Lens laws
10:00:46 <aristid> i do get the impression that for some things Arrow _is_ a good choice.
10:01:02 <roconnor_> such as the put-get law (or is it the get-put law?)
10:01:46 <roconnor_> Taneb: perhaps you don't want to use a Lens here
10:02:05 <roconnor_> or your Lens type needs to be subtly different
10:02:16 <Taneb> Damn, yeah
10:02:53 <Taneb> I could just be evil and have an illegal lens?
10:03:28 <ferh332> how to make record unbox? to store it in Vector.Unboxed
10:04:16 <byorgey> Taneb: the lens laws aren't just to make theoreticians happy.  If you use a lens that doesn't satisfy the laws then you are likely to get weird and unexpected results.
10:04:52 <Taneb> Really?
10:05:01 <roconnor_> Taneb: you should use fclabels for that :P
10:05:41 <hpc> i would say in general, those kinds of laws are there for a reason
10:05:50 <hpc> if they didn't matter, they wouldn't be specified
10:06:21 <Taneb> So... runtime error?
10:06:39 <hpc> Taneb: or incorrect answers
10:06:44 <stepkut> any idea how I get ghci to use the haskell98 package and not load base ?
10:06:54 <hpc> stepkut: why?
10:07:00 <Taneb> hpc, I mean, I should trigger a runtime error
10:07:22 <stepkut> hpc: because base and haskell98 both contain Prelude causing conflicts.
10:07:32 <stepkut> hpc: in GHC 7.4 anyway
10:07:40 <hpc> stepkut: i mean, why do you want haskell98?
10:07:57 <stepkut> hpc: because HsColour requires it
10:08:03 <hpc> oh
10:08:12 <stepkut> hpc: :)
10:08:17 <hpc> uh
10:08:25 <roconnor_> Taneb: maybe you should rethink your operations
10:08:27 <stepkut> hpc: I may submit a patch to fix that as well :p
10:08:39 <hpc> yeah, uh
10:08:44 <hpc> i would say to use package imports
10:08:50 <hpc> and noimplicitprelude
10:09:11 * stepkut remembers, :set -hide-package=base
10:09:23 <stepkut> I was trying, :set -package=-base, which is not right :)
10:09:28 <Taneb> roconnor_, in what way?
10:09:31 <stepkut> hide-package is what I needed. Thanks!
10:09:37 <roconnor_> Taneb: perhaps what you really want is a boolean valued lens to a relationshop between a person and a family
10:09:58 <Taneb> How would that work if I try to set it to True?
10:10:12 <roconnor_> Taneb: it would add a person to the family
10:10:25 <roconnor_> Taneb: I don't really know what your ultimate aims are
10:10:29 <Taneb> In what position!
10:10:42 <roconnor_> that is a good question
10:10:44 <Taneb> It's exactly the same problem
10:12:34 <roconnor_> But in general I was thinking a person doesn't often change their entire family assocation at once. ... which is what your operation that you are trying to write would do.  It seem unusual.
10:12:50 <roconnor_> I was trying to think of a more fine-grained approach
10:12:58 <Taneb> I'm trying to define a lens for lensiness
10:13:18 <Taneb> Which would mean that a lot of other functions would be a hell of a lot easier to defined
10:15:07 <roconnor_> Sometimes changing the type of the lens helps.  The types do not have to literally be substructures.  For example there is a Lens (IntMap k) (Maybe k) even though there is no Maybe types in IntMap.
10:15:55 <Taneb> I'm gonna make three lenses
10:15:57 <theorbtwo> roconnor_: Marrige, divorce, adoption.
10:16:04 <theorbtwo> It's not *that* uncommon.
10:17:08 <t7> mm_freak: hows your thing coming along?
10:17:40 <roconnor_> Taneb: perhaps you don't want a lens to a Person, but rather a lens to a new data type that doesn't yet exist because it isn't a literal substructure.
10:17:47 <ferh332> how can I store record to Vector.Unboxed?
10:17:49 <roconnor_> Taneb: like the Maybe type for IntMap, but more sophisticated
10:18:02 <Taneb> Hmm
10:18:09 <Taneb> I can't think of one at the moment
10:20:35 <mm_freak> t7: i'm implementing a small test language to see how to compile things
10:24:14 <isson> mm_freak
10:24:45 <isson> may i ask something ?
10:27:29 <t7> mm_freak: have you got a github?
10:29:27 <monochrom> Vector.Unboxed is not for records. Vector.Storable may work if your record is an instance of Storable.
10:30:47 <bitonic> monochrom: you can make it work for a record
10:31:05 <bitonic> unpacking the record to a tuple
10:31:13 <bitonic> and defining the right instances of MVector and Vector
10:31:33 <bitonic> Unboxed is not for datatypes with multiple constructors
10:31:41 <monochrom> yeah, I erred
10:32:22 <ferh332> bitonic: so if I have only one constructor?
10:32:54 <bitonic> ferh332: you already asked this morning, and I directed you to this: http://hackage.haskell.org/packages/archive/vector/0.9.1/doc/html/Data-Vector-Unboxed.html , which gives an example for Complex
10:33:04 <bitonic> a record will be similar to complex but with more fields
10:33:18 <ferh332> yea, I know, but it uses tuples
10:33:40 <bitonic> ferh332: yep you'll have to "convert" your record into a tuple
10:33:44 <ferh332> aren't there other way?
10:34:01 <bitonic> ferh332: no you don't understand, you won't see tuples at all in your code
10:34:05 <bitonic> that's the cool think
10:34:18 <bitonic> it'll use tuples to actually store the data, but it will be transparent
10:34:32 <ferh332> so its like storage system to vector for my data?
10:34:37 <bitonic> ferh332: yes
10:35:20 <bitonic> ferh332: again, make sure you understand type classes and there type families, you need it to understand that module
10:35:29 <bitonic> *then
10:36:02 <t7> whats upsidedown U in set theory again?
10:36:05 <t7> intersection?
10:36:07 <monochrom> hrm, Data.Vector.Unboxed.Base's page is a 404
10:36:14 <sipa> t7: yes
10:36:15 <monochrom> yes intersection
10:36:41 <sipa> didn't you learn that at... age 10 or something?
10:36:56 <monochrom> or age 18
10:37:06 <ferh332> yes, I know.. but what those multipoint does? :D
10:37:10 <sipa> quite sure i learned that in elementary school
10:37:16 <ferh332> yes, I know.. but what that multipoint does? :D
10:37:45 <navaati> sipa: wow, what crazy sort of elementary school did you go to oO ?
10:38:06 <sipa> navaati: nothing special
10:38:07 <barrucadu> sipa: I want to send my future children to your school, it sounds incredible :P
10:38:38 * barrucadu did set theory at ~15/16
10:38:39 <t7> @hoogle when
10:38:40 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
10:38:40 <lambdabot> System.Posix.Terminal WhenDrained :: TerminalState
10:38:40 <lambdabot> Test.QuickCheck.Property whenFail :: Testable prop => IO () -> prop -> Property
10:39:27 <parcs`> sipa: i assume you're not from usa? :)
10:39:35 <t7> @hoogle Bool -> m a -> m a
10:39:36 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
10:39:36 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
10:39:36 <lambdabot> Data.Graph.Inductive.Internal.Queue queuePut :: a -> Queue a -> Queue a
10:39:36 <bitonic> barrucadu: in Italy I think everybody does very basic set theory at school
10:39:52 <sipa> parcs`: no, belgium
10:39:53 <monochrom> I am not too thrilled about what knowledge is taught. I am more concerned with what attitude towards knowledge is taught.
10:40:02 <sipa> barrucadu: learning regulations may have changed 15 times since then, but i'm quite sure at the time every school had to teach it here
10:40:19 <navaati> in france it's more at 17~18, and not for everybody though, only scientific sections
10:40:39 <navaati> bh, i'm jealous
10:40:41 <mm_freak> t7: not yet
10:40:45 <navaati> s/bh/bah/
10:40:45 <mm_freak> isson: sure, just ask
10:41:13 <sipa> barrucadu: i actually believe set theory was removed from the curriculum since then
10:41:28 <barrucadu> Alas
10:41:37 <sipa> (maybe not too bad, i doubt many of the teachers understood it well enough to explain it in a useful way to children)
10:42:16 <Saizan> i got the basic set operations in elementary school too
10:42:17 <petre> hi guys!
10:42:29 <bitonic> sipa: mah, basic basic set theory is dead simple, simpler than arithmetic
10:43:03 <bitonic> I'm pretty sure they still teach it in italy, I definitely remember learning it
10:43:35 <monochrom> boolean algebra is very simple, too
10:44:17 <Franciman> bitonic, yes they do
10:44:19 <monochrom> so simple that the fine distinction between "x implies y" and "y implies x" are never taught
10:44:37 <Franciman> my teacher teached that last week
10:44:44 <Franciman> *teached me
10:44:54 <absence> can anyone describe what things like (join .) or (fmap .) do/are in an intuitive way? i can follow the type signatures, but a metaphor or something would be nice
10:45:35 <barrucadu> Franciman: "taught me"
10:45:45 <Franciman> oh yes thanks
10:45:58 <Franciman> maybe in 100 years this will be correct
10:46:32 <navaati> absence: well (join .) transforms a function from a to m m b into a functions from a to m b, i don't see a more intuitive way of saying it‚Ä¶
10:47:01 <navaati> maybe it does something interesting in the (r ->) monad‚Ä¶
10:47:09 <monochrom> perhaps (join .) and (fmap .) are better not to be taken out of context
10:49:04 <t7> @hoogle Set (Set a) -> Set a
10:49:05 <lambdabot> Data.Set deleteMax :: Set a -> Set a
10:49:05 <lambdabot> Data.Set deleteMin :: Set a -> Set a
10:49:05 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
10:49:08 <stepkut> ooo. turns out I was pulling from an old hscolour repo.. the newest version does not depend on haskell98 anymore :)
10:49:20 <t7> is Set a monad?
10:49:27 <monochrom> no
10:49:30 <t7> damn
10:50:04 <monochrom> the hoogle answer is missing "Ord a =>"
10:50:15 <absence> i was hoping to understand some kind of pattern. e.g. when i think "i need to transform a -> m (m b) to a -> m b" it would be nice to "know" that i need to use (.) in that particular way instead of finding different ways to express the problem and hoping pointfree will come up with something
10:50:30 <navaati> for m = (r ->), (join .) :: (a -> r -> r -> b) -> a -> r -> b, so it somewhat "repeats the 2nd argument", it's contrived though (and i'm not sure if i'm correct)
10:51:51 <navaati> > (join .) (\_ -> (+)) undefined 3
10:51:52 <lambdabot>   6
10:52:13 <Taneb> Is there anything bad about defining lenses so that they might fail at runtime under certain conditions
10:52:23 <bitonic> Taneb: yeah
10:52:47 <bitonic> Haskell people don't like runtime crashes
10:53:09 <hpc> coincidentally, nobody else likes runtime crashes either :P
10:53:14 <Franciman> lol
10:53:30 <monochrom> I would just write "transform g x = join (g x)" and either not worry about pointfree or worry about pointfree retrospectively
10:53:56 <bitonic> hpc: ok. Haskell people don't like partial functions :P
10:54:32 <Taneb> Even if I explicitly state the conditions on which it may fail?
10:55:46 <monochrom> perhaps people just don't expect lenses to be non-total. you can have non-total functions elsewhere, and people are fine with them
10:55:51 <Franciman> bitonic, they seem a little bit picky
10:55:52 <mzero> Taneb: I think most of us much prefer that interfaces never fail, and if they have "exceptional" conditions, that they return Maybe
10:55:54 <Franciman> :P
10:56:23 <mzero> that way, it is up to the user of the interface to decide (and hence document) in their code "this never happens, so I'm calling fromJust"
10:56:35 <mzero> rather than the interface making the decision unilaterally
10:57:54 <Taneb> Using Maybe would... probably not be possibl
10:57:55 <Taneb> e
10:58:59 <bitonic> Taneb: you should aim to never expose those functions, and use them only for internal use where you know that the preconditions are satisfied
10:59:11 <Taneb> Okay
10:59:26 <bitonic> but you should use them only when really necessary
10:59:32 <bitonic> so not often
11:00:23 <Taneb> I leave the function in for now, because it's long and I don't want to have to rewrite it if it proves to be the best possible solution
11:00:36 <Taneb> Actually...
11:01:03 <Taneb> I... I don't think I need that at all
11:01:04 <Taneb> Thanks, #haskell!
11:02:32 <mzero> ... and thus the monk was enlightened!
11:03:05 <bitonic> it is possible to export a type family without leaving the possibility to instantiate it? I wouldn't think so, since you can't do that with typeclasses, but you never know...
11:05:40 <monochrom> I can do that with type classes. module M(MyClass) where class MyClass t where myop :: t -> t. since myop is not exported, other people will have problems writing instances.
11:06:04 <bitonic> monochrom: they can still create instances.
11:06:08 <monochrom> but that trick does not work for type family. I don't know how to prevent other people's instances.
11:06:27 <bitonic> monochrom: that trick doesn't work with typeclasses either, you can still create broken instances, which is even worse
11:06:50 <monochrom> oh haha, broken instances, I guess that is allowed
11:07:05 <bitonic> I mean instances with no methods
11:07:11 <monochrom> right
11:07:53 <monochrom> essentially Data.Array and Text.Printf do it
11:08:25 <monochrom> perhaps don't even export the type class :)
11:09:05 <Taneb> Are profunctors sorta like backwards arrows?
11:09:10 <bitonic> monochrom: what I usually do is `class Foo a where ...', in an internal module, and then re-define `class Internal.Foo a => Foo a'
11:09:11 <monochrom> (it only prevents other people from writing certain types. it cannot prevent uses.)
11:10:03 <monochrom> "class (does not matter) => Foo a" has its problems
11:10:18 <bitonic> monochrom: why?
11:10:52 <monochrom> the check for the "does not matter" part is kind of postponed
11:11:34 <bitonic> monochrom: ? it's not an instance it's a class declaration
11:11:47 <monochrom> oh, sorry, right, nevermind
11:11:50 <bitonic> and the user won't be able to define any instance, since it has no access to Internal.Foo
11:16:16 <monochrom> haha, "what happened to systems A through E"
11:16:51 <c_wraith> they were found... defective
11:19:58 * hackagebot hissmetrics 0.1 - Unofficial API bindings to KISSmetrics.  http://hackage.haskell.org/package/hissmetrics-0.1 (FelipeLessa)
11:24:59 * hackagebot hissmetrics 0.1.1 - Unofficial API bindings to KISSmetrics.  http://hackage.haskell.org/package/hissmetrics-0.1.1 (FelipeLessa)
11:33:29 <t7> bitonic_: i got hindley milner working using a constraint solver now
11:33:30 <t7> wooo
11:34:59 * hackagebot haskeline 0.6.4.7 - A command-line interface for user input, written in Haskell.  http://hackage.haskell.org/package/haskeline-0.6.4.7 (JudahJacobson)
11:35:04 <monochrom> that's neat
11:40:17 <Saizan> t7: which solver?
11:40:54 <t7> the one in "generalizing the hindley milner type inference algo"
11:41:07 <t7> it only has 3 constraints
11:49:59 * hackagebot hissmetrics 0.2 - Unofficial API bindings to KISSmetrics.  http://hackage.haskell.org/package/hissmetrics-0.2 (FelipeLessa)
11:54:09 <coldpizza72i> parse error on input `=' http://hpaste.org/68475
11:54:11 <mm_freak> t7: what about your language?  any progress?
11:54:30 <coldpizza72i> nevermind
11:54:35 <coldpizza72i> i see the problem
11:58:45 <t7> mm_freak: no still looking for a whole in the market
11:59:23 <mm_freak> t7: what do you mean?
11:59:36 <t7> i mean a hole
11:59:59 <t7> i was thinking about adding inference and tagged unions to C or something
12:02:31 <mm_freak> you want to make a functional C?
12:03:08 <t7> no garbage collection or closures or anything
12:03:22 <t7> just a bit more safety
12:03:43 <mm_freak> wow, you're giving up a lot, when i consider that you started with a dependently typed functional language =)
12:04:05 <mm_freak> note that the IO monad is one of the main sources of haskell's I/O safety
12:04:23 <mm_freak> in particular the fact that (>>=) has a type
12:05:37 <conal> the other being not using I/O ;)
12:06:06 <mm_freak> by having C-like semantics you really have C-like safety
12:06:31 <mm_freak> you can have a more expressive type system, but the basic problem of imperative languages remains untouched
12:11:00 <t7> I would like to see a purely functional language without GC, and strict by default
12:11:07 <t7> for low level things
12:11:33 <hash`> You mean like assembly? mov AX BX
12:11:42 <hpc> t7: like a language where the IO monad is State Tape?
12:11:54 <hpc> or State RAM, or whatever
12:12:02 <strager> @src seq
12:12:02 <lambdabot> Source not found. Do you think like you type?
12:12:53 <mm_freak> t7: even the strict, low level unlambda language needs GC
12:13:24 <opqdonut> yeah, you get reference cycles the moment you use recursion
12:13:37 <mm_freak> you can prevent some GC by avoiding recursion and by adding uniqueness types
12:13:47 <hiptobecubic> what's a reference cycle?
12:14:05 <hash`> Is it possible in Haskell - or does it even make sense to ask the question - is it possible to find the name of a variable at runtime?
12:14:16 <mm_freak> hash`: no
12:14:18 <hpc> hash`: doesn't make sense
12:14:44 <hpc> everything "source-codey" about a haskell program gets compiled away
12:15:08 <opqdonut> well, it's possible
12:15:11 <opqdonut> since profiling is possible
12:15:17 <hash`> The issue is that I'm working on an EDSL and I'd like the output source to have some semblance to the input.
12:15:29 <opqdonut> oh
12:15:35 <hpc> opqdonut: you compile with profiling, and it adds the markers
12:15:40 <opqdonut> yeah
12:15:49 <hash`> Hmmmm.
12:15:52 <opqdonut> hash`: then you'll need to use template haskell or a preprocessor
12:16:00 <mm_freak> hash`: the usual way is to save the variable names
12:16:05 <mm_freak> explicitly that is
12:16:25 <opqdonut> like, a = Var "a" something something
12:16:33 <hpc> or you can ship the .hi files with your code and do evil with it
12:16:48 <hash`> Yea, that's pretty ugly. All solutions sound ugly.
12:17:00 <mm_freak> hash`: not at all
12:17:06 <mm_freak> it's just that haskell is not PHP =)
12:17:25 <Taneb> If Haskell was PHP...
12:17:32 <hpc> heh, reminds me of a bit of lua code a friend of mine wrote
12:17:39 <hpc> that randomized every symbol table in the program
12:17:47 <hpc> and then randomized itself
12:17:50 <Taneb> f [x] = g x would be equivalent to f xs = map g xs
12:23:14 <hash`> So what about template haskell, can I declare a variable using it and get the name?
12:25:29 <mm_freak> hash`: just don't insist on making a connection between source code and executable code
12:25:42 <mm_freak> this is just the wrong way of thinking in haskell and will lead you nowhere
12:25:50 <hash`> Well, it looks like template haskell depends on profiling.
12:25:56 <mm_freak> you /will/ write more, less readable code
12:26:02 <mm_freak> for no gain
12:26:21 <hash`> In general I agree, but there is some gain here, although the gain is aesthetic :)
12:26:59 <mm_freak> as a language implementor i can tell you, you're mistaken =)
12:27:02 <hash`> If I require readable output in the destination language, I need to name the variable. The user is already naming the variable, so having them do it twice is odd.
12:27:24 <hash`> It's even possible they could error and write different names in cod.
12:27:26 <hash`> Code.
12:27:39 <hash`> E.g., let x = var "y"
12:27:57 <mm_freak> what are you writing anyway?
12:28:35 <hash`> A compiler to Cuda. The reason we're not using existing stuff is it's internal and we have some specific needs.
12:28:43 <mm_freak> a DSL or a separate language?
12:28:48 <hash`> EDSL
12:29:27 <mm_freak> and you want the names for error messages and such?
12:29:51 <hash`> Absolutely. What if there's a compile error in the Cuda?
12:30:17 <mm_freak> you can use TH helpers, but personally i'd just go with duplicating
12:30:23 <hash`> varhb27436777c vs. my_int
12:30:38 <mm_freak> in a language i'd design it would look like this anyway:  newVar "x" $ \x -> ‚Ä¶
12:30:53 <mm_freak> where the "x" is really a description, not necessarily just a duplication of the name
12:31:38 <mm_freak> or you write a separate language and a parser for it‚Ä¶  then you would just use compiler-style error messages with source code positions
12:32:19 <hash`> Considering the vast majority of what I want is in Haskell and this is a small part of it, it would make more sense to embed it.
12:32:29 <mm_freak> the final method is to statically ensure that compilation must succeed
12:32:48 <hash`> mm_freak: What do you mean?
12:32:49 <mm_freak> if the compilation fails at run-time this is a bug or some kind of system error
12:33:02 <hash`> Ahhh. But the compilation could fail at the other end.
12:33:18 <hash`> Then I have no way to trace back why.
12:33:37 <mm_freak> well, simple numbers would suffice‚Ä¶  let your DSL interpreter auto-generate variable numbers
12:33:43 <absence> uhm, this is strange. in ghci i write let d = show . head, then :t d results in d :: [()] -> String instead of the expected [a] -> String. why is that?
12:33:44 <mm_freak> the same expression will use the same numbers
12:34:10 <hash`> Simple numbers coming from where?
12:34:30 <mm_freak> hash`: from the interpreter
12:34:43 <mm_freak> or the compiler
12:34:49 <mm_freak> whatever you do with the DSL expression
12:35:13 <hash`> How do those numbers correlate between the output source and input source?
12:35:19 <mm_freak> absence: you need to add a type signature
12:35:56 <mm_freak> hash`: newVar $ \x -> ‚Ä¶
12:36:00 <mm_freak> x now has a number
12:37:01 <hash`> I'm still missing the key part to understanding this, do I pass this number in when I call newVar?
12:37:15 <mm_freak> hash`: no
12:37:32 <mm_freak> newVar :: (Expr -> Eval a) -> Eval a
12:37:53 <mm_freak> where Eval might be a simple state monad that keeps a variable name counter
12:37:53 <absence> mm_freak: "let d = show . head :: Show a => [a] -> String" still gives [()]
12:38:25 <mm_freak> absence: you have to write a type signature for 'd' itself
12:38:53 <mm_freak> let d :: (Show a) => [a] -> String; d = show . head
12:39:00 <hash`> I see, that's what I thought. But then I have to know which Monad, so i'd need a counter monad, and it would be very difficult to correlate with source.
12:39:27 <mm_freak> hash`: evaluate :: Eval Expr -> Expr
12:40:24 <absence> mm_freak: ahh, so that's how you do it. thanks :)
12:42:33 <hash`> But that still won't correlate with anything in the source code, right? I mean, I won't know what file the variable was declared in, I won't know what line, all I'll know is that it's the nth variable declared.
12:42:44 <hash`> If I add a new variable anywhere they all get shifted...
12:42:55 <hash`> Well, on average, half get shifted.
12:44:35 <hash`> That gives me a unique name, which is the absolute minimum of what I need, but it doesn't give me correlation.
12:45:56 <hash`> Even knowing the name isn't enough, I need a notion of scope as well.
12:46:13 <hash`> Otherwise I'd have a conflict between the same names.
12:48:19 <mm_freak> hash`: the point is:  the variable names are always the same‚Ä¶  you can basically construct a map of variables
12:49:35 <ferh332> what could be the problem:
12:49:59 <ferh332> data SS = SS { id :: Int, k :: [Char] } deriving(Eq, Show)	
12:50:01 <ferh332> newtype instance Vector.Vector (SS a b) = V_SS (Vector.Vector (a, b))
12:50:19 <ferh332> got error:`SS' is applied to too many type arguments
12:50:20 <ferh332>     In the type `SS a b'
12:50:22 <ferh332>     In the newtype instance declaration for `Vector.Vector'
12:53:04 <ferh332> anyone :)
12:57:03 <parcs`> perlite: SS is applied to too many type arguments
12:57:07 <parcs`> it takes 0, you have it 2
12:57:16 <parcs`> gave
12:58:16 <ferh332> how should declare newtype instance.. then?
12:58:22 <ferh332> how should I declare newtype instance.. then?
13:02:28 <applicative> newtype V_SS = V_SS (Vector.Vector (Int, [Char))
13:03:04 <ferh332> http://hackage.haskell.org/packages/archive/vector/0.7/doc/html/Data-Vector-Unboxed.html
13:03:14 <ferh332> I think its not it
13:03:54 <applicative> data.vector.unboxed cant hold [Char] ferh332 , but I'm probably  not understanding yte
13:03:56 <applicative> yet
13:04:09 <absence> what would f = join . ap look non-pointfree? it's invalid, i just want to get a better feeling of what goes wrong
13:04:20 <ferh332> oh, sorry
13:04:48 <ferh332> it should be not [Char] but Word64
13:05:02 * hackagebot hissmetrics 0.2.1 - Unofficial API bindings to KISSmetrics.  http://hackage.haskell.org/package/hissmetrics-0.2.1 (FelipeLessa)
13:05:24 <ferh332> but it dowsnt work not for that :/
13:07:27 <ferh332> but it doesnt work. its not that problem :/
13:12:37 <applicative> you can declare  data SS = SS { id :: Int, k :: Word }  to be of the class Unbox
13:20:45 <ferh332> hmm..
13:30:50 <absence> is there a "best practice" when it comes to liftM/liftA vs ap/(<*>)?
13:31:24 <hpc> absence: stick with (<*>) unless something else looks nicer, in general
13:32:36 <mm_freak> absence: no, there isn't
13:32:45 <mm_freak> it's entirely a matter of taste
13:33:10 <mm_freak> for example, contrary to what hpc said i usually prefer liftA* over (<*>)
13:35:29 <absence> ah, thanks :)
13:37:34 <xplat> ‚ÄúThe function fromSing has an interesting type: it maps singletons to ordinary values, but the type of the result depends on the kind of the singleton parameter. So, if we apply it to a value of type Sing 3 we get the number 3, but, if we apply it to a value of type Sing "hello" we get the string "hello".‚Äù
13:37:46 <xplat> how does this work without something like 'kindclasses'?
13:38:17 <jfischoff> anyone know a concise way to filter a rose tree's nodes recursively?
13:38:39 <hpc> xplat: wat, i don't see how that's anything more than parametric polymorphism
13:38:48 <hpc> fromSing :: Sing a -> a
13:38:58 <hpc> oh wait, nvm
13:39:00 <hpc> i see now
13:39:04 <hpc> data kinds
13:39:17 <monochrom> oh yuck, data kinds :)
13:40:43 <shachaf> jfischoff: Just writingg out the filter function the longhand recursive way isn't concise enough for you?
13:40:46 <shachaf> @src filter
13:40:47 <lambdabot> filter _ []     = []
13:40:47 <lambdabot> filter p (x:xs)
13:40:47 <lambdabot>     | p x       = x : filter p xs
13:40:47 <lambdabot>     | otherwise = filter p xs
13:40:54 <mm_freak> xplat: see the reflection library
13:41:12 <mm_freak> well, actually not the library‚Ä¶  better see the paper on which it's based
13:41:23 <xplat> which paper?
13:41:25 <mm_freak> the latest version of the library is quite esoteric =)
13:41:38 <mm_freak> search for "functional pearls prepose"
13:41:44 <mm_freak> the paper is called implicit configurations
13:42:08 <xplat> hm, i think this is a little different.  (i've read implicit configurations)
13:42:26 <mm_freak> xplat: the basic idea is the same‚Ä¶  a type leading to a value
13:42:42 <mm_freak> just combine with associated types or fundeps
13:45:04 * hackagebot haskore 0.2.0.3 - The Haskore Computer Music System  http://hackage.haskell.org/package/haskore-0.2.0.3 (HenningThielemann)
13:45:24 <xplat> mm_freak: the version in IC is 'unikinded' while this version is kind-polymorphic -- the issues are different
13:46:18 <xplat> or at least, they could be different
13:47:00 <dropdrive> Hi, I recently found some very high (video) quality video lectures on the net, but I can't seem to locate them now.  They were in English, but possibly from Germany?  (Not the 2005/2006 Giesl videos)
13:47:07 <xplat> maybe it just treats the fact that all Sing n for n :: Nat have an integer representation as a 'pure coincidence'
13:47:30 <dropdrive> They were videos of a introductory Haskell class, it seemed.
13:47:53 <xplat> while unsatisfying i suppose that seems eminently implementable ...
13:48:33 <absence> sometimes i end up with the pattern join $ f <$> a <*> b <*> c. is it common to bake the join into a new operator like this "f <$> a <*> b `newoperator` c"? if so, is there a common name for that operator?
13:51:04 <hpc> absence: (=<<)?
13:52:34 <absence> hpc: doesn't compile
13:52:47 <hpc> er, hmm
13:53:07 <absence> couldn't match expected type m a with actual type a0 -> m a
13:54:00 <hpc> yeah, trying to think of what the type would be
13:54:13 <hpc> :t \f x -> join $ f <*> x
13:54:14 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Applicative m) => m (a1 -> m a) -> m a1 -> m a
13:54:31 <hpc> :t flip
13:54:32 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
13:54:38 <hpc> huh
13:56:18 <kallisti> shapr: I'm most likely going to redesign the sturcture of FSTree
13:56:24 <absence> right. i have the operator, i just don't know what to call it :P
13:56:52 <timthelion> Is there a formal name for
13:56:54 <hpc> @pl \f x -> join $ f <*> x
13:56:55 <timthelion> > take 20 $ iterate (\(a, b) -> (a==b, not b)) (True,True)
13:56:55 <lambdabot> (join .) . (<*>)
13:56:56 <lambdabot>   [(True,True),(True,False),(False,True),(False,False),(True,True),(True,Fals...
13:57:06 <hpc> absence: yeah, no clue
13:57:15 <timthelion> sorry for interuping you lambdabot
13:57:22 <hpaste> applicative pasted ‚ÄúUnbox SS‚Äù at http://hpaste.org/68478
13:57:49 <timthelion> Is there a formal name for the lambda that I've defined there, which gives a next binary pair?
13:57:52 <applicative> ferh332: are  you still here?  This  cut and paste  from the Complex  example seems to work ^^^\
14:17:24 <ferh332> yea, I am here :)
14:20:11 <hpaste> applicative annotated ‚ÄúUnbox SS‚Äù with ‚ÄúUnbox SS (annotation)‚Äù at http://hpaste.org/68478#a68480
14:20:31 <applicative> oh
14:21:29 <ferh332> thankyou for unbox SS
14:21:31 <ferh332>  :)
14:21:35 <applicative> I dont know if doing that is any simpler than just using vectors of pairs and translating to and from SS's when you deal with values
14:22:18 <applicative> but it's all cut and paste and find-and-replace, from his Complex example, which was a good idea for an illustration
14:24:11 <ferh332> ok, thanks :)
14:24:41 <ferh332> I am grateful
14:25:04 * hackagebot gsasl 0.3.4 - Bindings for GNU libgsasl  http://hackage.haskell.org/package/gsasl-0.3.4 (JohnMillikin)
14:26:45 <hpaste> ‚ÄúJonathan Fischoff‚Äù pasted ‚Äúrose tree filter‚Äù at http://hpaste.org/68481
14:26:49 <jfischoff> shachaf: ^ is that what you meant?
14:28:05 <hpaste> ‚ÄúJonathan Fischoff‚Äù annotated ‚Äúrose tree filter‚Äù with ‚Äúrose tree filter (annotation)‚Äù at http://hpaste.org/68481#a68482
14:30:32 <shachaf> jfischoff: Why does RoseTree have two constructors?
14:30:42 <shachaf> A leaf can just be a node with no children.
14:30:55 <jfischoff> true
14:31:22 <shachaf> (Is that a partial lens? Eugh.)
14:32:06 <jfischoff> ha
14:34:12 <hpaste> ‚ÄúJonathan Fischoff‚Äù annotated ‚Äúrose tree filter‚Äù with ‚Äúrose tree filter (annotation) (annotation)‚Äù at http://hpaste.org/68481#a68483
14:34:16 <xplat> data Rose a = Rose a [Rose a]
14:35:09 <shachaf> Yep, what xplat said.
14:35:17 <jfischoff> shachaf: ^ as per your suggestions
14:35:59 <shachaf> jfischoff: Yes, something like that.
14:36:06 <shachaf> If you insist on using lenses, anyway.
14:36:11 <jfischoff> no
14:36:26 <jfischoff> would the version without lenses be easier to understand?
14:36:50 <shachaf> It's just as easily filterR p (Rose x xs) | p x = Just $ Rose x (mapMaybe (filterR p) xs) | otherwise = Nothing or something like that.
14:37:22 <shachaf> I guess this function is slightly trickier than I thought.
14:37:26 <shachaf> Deciding what it should do is, anyway.
14:37:27 <jfischoff> ah
14:37:32 <ferh332> ok, going to sleep, see ya next time :)
14:38:12 <jfischoff> shachaf: it is much better then my first attempt, so much thanks for the filter src tip :)
14:39:33 <shachaf> jfischoff: Are you going to bahaskell this week?
14:40:01 <jfischoff> shachaf thanks for the reminder, yes.
14:40:05 * hackagebot gnutls 0.1.2 - Bindings for GNU libgnutls  http://hackage.haskell.org/package/gnutls-0.1.2 (JohnMillikin)
14:40:07 * hackagebot network-protocol-xmpp 0.4.2 - Client library for the XMPP protocol.  http://hackage.haskell.org/package/network-protocol-xmpp-0.4.2 (JohnMillikin)
14:41:23 <jfischoff> shachaf: are you?
14:41:30 <shachaf> jfischoff: That's the plan.
14:41:34 <shachaf> conal: Are you?
14:41:39 <shachaf> (Going to bahaskell this week.)
14:41:56 <jfischoff> conal?
14:43:32 <conal> shachaf: very unlikely this time. who's talking about what?
14:44:04 <jfischoff> hey conal
14:44:13 <conal> jfischoff: hi
14:44:13 <shachaf> Let me check.
14:44:26 <shachaf> "At our May meeting Myles Maxfield is going to talk about a functional JPEG decoder that he has been working on."
14:45:02 <shachaf> I somehow suspect there the JPEG decoder doesn't decode into ‚Ñù¬≤ -> Œ±. :-)
14:45:37 <jfischoff> has anyone ever used Multiplate before. Any tutorials?
14:45:44 <jfischoff> examples, etc ...
14:46:34 <jfischoff> shacaf: I feel like I can write filterR generically with multiplate
14:47:45 <shachaf> jfiscoff: Generically enough to cover what other types?
14:48:27 <jfischoff> shacaf: Trees that have leafs that refer to a different type of tree
14:48:58 <jfischoff> shacaf: my expression tree is split up between several types
14:49:21 <shachaf> jfiscoff: Ah, I see.
14:51:00 <jfischoff> shachaf: I could write filterR for my type, but if there was a way to write it once and for all that might be worth any additional complexity.
14:51:48 <shachaf> jfischoff: I guess in this context it might be reasonable.
14:52:40 <conal> shachaf: thx.
14:53:06 <jfischoff> shachaf: I hope so :)
15:11:31 <haziz> Why do people describe Haskell's syntax as elegant? I am finding it terse and cryptic, and the indentation rules impenetrable! And this is coming from someone who is most comfortable with C, whose own syntax is far from elegant.
15:11:51 <pingveno> Are you just learning Haskell?
15:12:02 <haziz> Yes
15:12:10 <pingveno> That's part of the reason :)
15:12:56 <pingveno> The syntax is very different from, say, C.
15:13:18 <companion_cube> the concepts are different too
15:13:31 <pingveno> That's one way to put it. :)
15:13:41 <companion_cube> and haskell's elegance comes from the ease to manipulate those concepts through the syntax
15:14:06 <haziz> Actually it has adopted a lot of bad habits and syntax. The concepts are certainly different.
15:14:16 <jfischoff> shachaf: I think I might be able to use partial lenses to make the more generic filterR
15:14:52 <haziz> I meant to say it has adopted a lot of bad habits and syntax from C. The concepts are certainly different.
15:14:54 <shachaf> filter returning Maybe is annoying.
15:15:03 <shachaf> I guess you'd get the same thing for a non-empty list.
15:15:09 <shachaf> haziz: Which bad habits and syntax?
15:15:45 <jfischoff> shachaf: returning Maybe makes using partial lenses easier
15:15:48 <pingveno> I'm just learning Haskell at this point. I like a lot about it, but its error handling makes me sad.
15:15:58 <adimit> cabal is driving me *craaaazy*. Please help me. I posted what I'm getting at hpaste. It's telling me transformers-3 "was selected instead" but WHY? my program's .cabal doesn't specify any bounds on transformers.
15:16:01 <hpaste> adimit pasted ‚ÄúcaBLA‚Äù at http://hpaste.org/68485
15:16:13 <haziz> && ||, using indices starting with 0, and I am not a C newbie.
15:16:21 <jfischoff> pingveno: have you learned about the RWST monad transformer?
15:16:46 <shachaf> adimit: Probably one of your dependencies depends on it.
15:16:55 <pingveno> jfischoff: No
15:17:01 <shachaf> haziz: && and || aren't syntax, they're library functions.
15:17:05 <adimit> shachaf: how on earth do I find out which? I'm depending on a lot of stuff!
15:17:10 <jfischoff> pingveno: then don't worry things will get better :)
15:17:24 <shachaf> RWST :-(
15:17:37 <rwbarton> Wouldn't you want ERWST?
15:17:39 <shachaf> haziz: 0 seems to me like the most sensible thing for indices to start with.
15:17:42 <pingveno> I'm under the impression that there are multiple ways to do error handling, no?
15:17:43 <jfischoff> pingveno: you should make ERWST monad transformer.
15:17:52 <pingveno> Very, very different ways.
15:17:56 <shachaf> That would be the WERST monad transformer.
15:17:57 <rwbarton> Or CRWST for extra fun
15:18:14 <jfischoff> haha
15:18:19 <shachaf> pingveno: There are a few different ways. Some are more sensible than others.
15:18:32 <shachaf> rwbarton: Using Cont is just giving up.
15:18:57 <jfischoff> seriously I do a lot work in monads very similar to that
15:19:25 <hpc> jfischoff: the WERST monad ever!
15:19:34 <shapr> kallisti: How so?
15:19:49 <rwbarton> I wrote a program using something like CRST once.
15:19:51 <rwbarton> It didn't work.
15:20:01 <shachaf> The program or CRST?
15:20:07 * hackagebot yampa-glut 0.1.0 - Connects Yampa and GLUT  http://hackage.haskell.org/package/yampa-glut-0.1.0 (NikolayOrlyuk)
15:20:09 <pingveno> shachaf: The "a few different ways" is the problem. Coming from a Python background, I'm used to one basic way to do eerror handling.
15:20:10 <rwbarton> The program
15:20:21 <rwbarton> pingveno, even in python you have two already
15:20:29 <pingveno> ?
15:20:40 <rwbarton> you have None, and then you have exceptions
15:20:41 <kallisti> shapr: it would be nice to store a record of information about each file path;  whether or not it's a directory, symlink, etc
15:21:03 <jfischoff> shapr: Context = ERWST String Config Log MutableState
15:21:09 <pingveno> None is only used sometimes.
15:21:15 <kallisti> but is still a form of error handling
15:21:20 <kallisti> as None often represents a failed state
15:21:25 <shachaf> pingveno: That is precisely your complaint, isn't it? :-)
15:21:50 <shapr> jfischoff: Je ne comprend pas!
15:21:53 <kallisti> pingveno: in Haskell we have similar things
15:21:59 <shachaf> I don't trust monad transformers.
15:21:59 <shapr> jfischoff: Jag √§r mycket f√∂rvirrad!
15:22:09 <shapr> shachaf: That's just because you've seen the movies, right?
15:22:23 <shachaf> Movies?
15:22:30 <shapr> The transformers movies?
15:22:33 <shachaf> Oh.
15:22:34 <jfischoff> jfischoff: what's the problem?
15:22:37 <shachaf> I haven't seen those.
15:23:35 <jfischoff> no seriously what's the problem?
15:23:43 <shapr> jfischoff: Do have code that derives arbitrary for a given data type?
15:24:22 <jfischoff> besides makeArbitrary, no
15:24:41 <jfischoff> but I bet I could with new generics
15:24:51 <shapr> @Hoogle makeArbitrary
15:24:51 <lambdabot> Maybe you meant: google hoogle
15:24:57 <shapr> @hoogle makeArbitrary
15:24:57 <lambdabot> No results found
15:25:05 <jfischoff> derive makeArbitrary
15:46:58 <t7> > (\(x :: forall a. a -> a) -> (x x 2, x 3)) (\x -> x)
15:46:58 <lambdabot>   (2,3)
15:51:51 <xemdetia> I am trying to work with ghc-7.4.1 but cabal is not detecting hsc2hs in my path. Is there some setting I am missing?
15:52:51 <xemdetia> Question retracted, messed up a symlink and only thought to check it now. :(
15:55:43 <xplat> 0 is the most sensible thing for indices to start with, for precise technical reasons
15:58:10 <boccato> Would anyone recommend some good screencast / podcast on haskell?
15:59:41 <haziz> Is Haskell taught more in Universities and college in Europe compared to the US?
16:01:15 <applicative_> boccato what sort of thing are you looking for?
16:02:04 <boccato> I watched a nice tutorial on starting on yesod. That kind of thing, or maybe some class.
16:02:11 <boccato> I found this one: http://videoag.fsmpi.rwth-aachen.de/?course=12ss-funkprog
16:02:29 <boccato> Will check if it is good. Found it on redit/haskell.
16:02:59 <boccato> But I was wondering if anyone knew of good videos to learn haskell or some of its libraries.
16:03:05 <applicative_> ah a university class.  there was a long bunch of tutorial vidoes by Erik Meier
16:03:21 <frontendloader> http://www.haskell.org/haskellwiki/99_questions/1_to_10 for #7 here, is there some way to do pattern matching based off of the type of argument passed to a function?
16:03:36 <boccato> It would be nice to see people that work with haskell on a daily basis using it.
16:03:53 <frontendloader> like if the argument is type [a] do this, and if it is a do that
16:04:18 <applicative_> boccato that's an  interesting idea here are the Meijer ones http://channel9.msdn.com/Shows/Going+Deep/Lecture-Series-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-1
16:04:34 <applicative_> if you can tolerate MS things
16:05:07 <boccato> I just loved his shirt!
16:05:39 <mpreisler> howdy, I am having trouble with list comprehension that I can't google out. I want to construct an infinite list using a function that takes the "so far" list and returns the next member for it. I am trying it this way: http://pastebin.com/iNTQR4hE
16:05:41 <mauke> The paste iNTQR4hE has been copied to http://hpaste.org/68488
16:05:54 <mpreisler> there is probably something I am misunderstanding as the list stops at 2 elements
16:06:33 <applicative_> whats the definition of next_member
16:06:58 <fmap> It's not a comprehension btw.
16:07:06 <coldpizza72i> http://hpaste.org/68489 shouldn't this work?
16:07:06 <boccato> applicative_: What kind of MS things?
16:07:37 <applicative_> boccato: it's just that its on that website, people carp sometimes
16:07:56 <applicative_> like fmap says its not a comprehension, its a singleton
16:07:58 <mpreisler> applicative_: I am trying it with next_member list = (last list) + 1 so far
16:08:02 <mpreisler> to keep it super simple
16:08:02 <applicative_> > [1]
16:08:02 <lambdabot>   [1]
16:08:10 <boccato> Oh, I thought was something during the lectures. Thanks for the pointer!
16:08:50 <applicative_> boccato: anyway you might try it.  the standard written tutorial is learn you  a haskell
16:08:57 <applicative_> @where lyah
16:08:57 <lambdabot> http://www.learnyouahaskell.com/
16:09:05 <fmap> > iterate (+1) 1
16:09:06 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
16:09:27 <fmap> @src iterate
16:09:28 <lambdabot> iterate f x =  x : iterate f (f x)
16:09:32 <applicative_> boccato: but something more like the yesod things would be nice
16:09:57 <coldpizza72i> I'm getting  parse error on input `='
16:10:00 <boccato> applicative_: I am reading this one and Real World Haskell. Loving the experience so far, but kind of lost a bit.
16:10:03 <wo0kie> lol I'm terrible with inductive proofs
16:10:05 <mpreisler> btw, I know I can simply do [1..] and get the same thing but I am trying to learn possible ways to construct infinite lists, so just take it as an example
16:10:06 <wo0kie> true story
16:10:33 <ciaranm> wo0kie: try coinduction. it's infinitely more fun,
16:10:49 <fmap> mpreisler: what you want looks like iterate function
16:11:08 <wo0kie> D:
16:11:32 <mpreisler> fmap: nope, iterate only takes the previous result into account, I want to take the whole previous list into account
16:11:41 <applicative_> boccato: yes there are a lot of things going on, and different ways of looking at them, the best way to learn isn't obvious yet
16:11:47 <wo0kie> would one of you be so kind as to tell me if I'm on the right track with this proof?
16:11:49 <wo0kie> http://pastie.org/3907363
16:11:58 <wo0kie> (this is hw btw)
16:12:43 <ciaranm> wo0kie: you don't need to use induction for an associativity proof
16:12:55 <wo0kie> oh
16:13:47 <wo0kie> hmm, well I'm going off an example my professor gave me
16:13:54 <ciaranm> you just show that a * (b * c) = (a * b) * c for arbitrary a, b and c
16:14:07 <wo0kie> http://www.cs.rit.edu/~mtf/teaching/20113/psfp/lectures/lecture13/Proofs.txt (second one)
16:14:09 <wo0kie> hmm
16:15:04 <ciaranm> there's induction there for distributivity because he's proving stuff in a silly order
16:15:52 <applicative_> coldpizza72i: did someone already say, you want == not = since you're making an equality (==) test, not giving a definition(=)
16:16:01 <fmap> mpreisler: isn't it easily derived from iterate?
16:16:19 <coldpizza72i> oops
16:16:51 <wo0kie> ok I'll see if I can't shorten it a bit, thanks ciaranm :)
16:17:46 <ciaranm> wo0kie: you want to be basing it on the && example, not the distributivity example
16:17:52 <mpreisler> fmap: lemme look closer at it, I am a haskell newbie so it is likely to be so :)
16:18:15 <wo0kie> http://pastie.org/3907385
16:18:20 <wo0kie> that's the one I was basing it off :)
16:18:36 <ciaranm> right. no induction.
16:19:41 <ciaranm> there is a general proof that associativity over three things gives you associativity all over the place, but i highly doubt you'll ever be asked to produce it, since it's just an exercise in writing out ugly stuff
16:20:00 <wo0kie> yeah I hope not lol :)
16:20:05 <wo0kie> bad enough with proofs as it is
16:20:16 <ciaranm> it's not at all difficult. it's just really boring.
16:20:17 <applicative_> boccato: I dont know if they will be of use yet, but I learned a huge amount about avoiding inefficient nonsense from http://www.slideshare.net/tibbe/highperformance-haskell  http://www.scs.stanford.edu/11au-cs240h/notes/performance.html#(1)
16:20:17 <wo0kie> (been about 3 years since I last did them in CS Theory)
16:20:24 <wo0kie> ah :)
16:21:11 <applicative_> boccato: the second explains how he implemented a particular library, in potentially mind numbing detail
16:21:31 <boccato> =)
16:22:17 <boccato> applicative_: Seems interesting, I'll keep them for future study, I don't think I can follow it still.
16:22:52 <applicative_> yes, i was meaning to keep them in mind.
16:23:32 <ciaranm> wo0kie: really though, your problem likely isn't "proofs". it's probably just that you need to see lots of examples of good proofs, and then to do some yourself. a good way to do that is to take a Real Analysis class, since then you can't rely upon intuition
16:23:58 <wo0kie> ah :)
16:24:02 <wo0kie> that makes sense
16:24:16 <wo0kie> we only had one class that came close to proofs
16:24:24 <wo0kie> and it was only a 10 week class :\
16:24:59 <ciaranm> that's not a good situation to be in. get yourself on some first / second year maths classes. analysis, topology and early abstract algebra are good bets.
16:25:09 <wo0kie> ok :)
16:25:12 <wo0kie> thanks
16:25:33 <ciaranm> plus you'll need those to understand category theory anyway :P
16:28:11 <applicative_> boccato: Oh I forgot, it's pretty elementary, but our fearless leader Simon P J gave a nice long tutorial a few years ago, explaining some features of XMonad as an example
16:28:29 <applicative_> boccato: I remember learning quite a bit from it http://blip.tv/oreilly-open-source-convention/oscon-2007-simon-peyton-jones-a-taste-of-haskell-part-i-329701
16:28:40 <boccato> XMonad the window manager?
16:28:55 <jmcarthur> yes
16:28:56 <applicative_> boccato: yeah
16:29:35 <applicative_> he has nothing to do with xmonad but chose it as an example
16:30:13 <jmcarthur> i think that talk is a good motivator for haskell, but not much of a tutorial, really. then again, i already knew haskell by the time i saw that talk
16:30:56 <applicative_> jmcarthur: yes, i think i agree with that, i didn't know much haskell when i saw it so learned a bit.
16:30:59 <boccato> applicative_: What do you use for developing? (meaning editor and other tools)
16:31:29 <applicative_> hah, i'm a light weight, I mostly use textmate on  a mac
16:32:00 <applicative_> but some of the great haskell masters do too, so maybe it's not so bad
16:32:52 <boccato> :)
16:32:57 <boccato> Any bundles?
16:33:15 <boccato> I am using sublime 2.
16:33:36 <boccato> So I can use it on mac at home and the same on win at work.
16:33:50 <applicative_> oh, i don't know if the haskell bundle works with sublime 2, mine is full of ridiculous hacks.
16:35:01 <applicative_> i mean if the textmate bundle works, i tried sublime text with linux, but couldn't figure it out, but i didnn't devote much thought to it
16:36:49 <boccato> Have you tried the TM 2 beta?
16:40:48 <applicative_> boccato: not really, I looked at it briefly.
16:41:39 <applicative_> someone should figure out how to get haskell and sublime text together for the reason you mention that you can move between platforms like with emacs. maybe someone has
16:42:48 <applicative_> i wrote a little about using textmate  here a while back http://stackoverflow.com/questions/5682339/setting-up-textmate-for-haskell-programming-on-mac-os-x
16:44:38 <boccato> Cool, I was looking at that link =)
16:50:13 <boccato> applicative_: Is it possible to interact with the terminal in TM? I miss this from sublime.
16:50:50 <applicative_> no, thats one of  the annoying bits, i have to go back and forth.
16:51:32 <applicative_> i can open it from textmate and so on, but it isn;t integrated
16:55:16 <boccato> That's the thing I love the most in emacs. But for some reason I never quite adapted to it.
17:00:10 * hackagebot hs-GeoIP 0.2 - Haskell bindings to the MaxMind GeoIPCity database via the C library  http://hackage.haskell.org/package/hs-GeoIP-0.2 (OzgunAtaman)
17:07:00 <t7> there was a new SPJ video recently
17:07:09 <t7> anyone know the name?
17:08:20 <ion> I‚Äôd like to see it, too.
17:11:10 <boccato> This one? http://channel9.msdn.com/Blogs/Charles/YOW-2011-Simon-Peyton-Jones-Closer-to-Nirvana
17:11:12 <t7> http://skillsmatter.com/podcast/home/haskell-cloud/js-4179 this might have been it
17:11:34 <ion> Thankes
17:12:08 <coldpizza72i> shouldn't this work primes x = [a | a <- [2..x], x `mod` a /= 0]
17:14:54 <coldpizza72i> > [a | a <- [1..15], 15 `mod` a /= 0]
17:14:55 <lambdabot>   [2,4,6,7,8,9,10,11,12,13,14]
17:15:35 <coldpizza72i> oh never mind that doesn't make sence
17:19:07 <applicative_> > let  divisors x = [a | a <- [2..(x-1)], x `mod` a == 0] in  divisors 15
17:19:08 <lambdabot>   [3,5]
17:21:49 <applicative_> > let prime x = null [a | a <- [2..(x-1)], x `mod` a == 0]  in map (\x -> (x,prime x) ) [2..12]
17:21:50 <lambdabot>   [(2,True),(3,True),(4,False),(5,True),(6,False),(7,True),(8,False),(9,False...
17:22:12 <mietek> Anyone familiar with the pipes package?
17:22:26 <applicative_> that would be pretty clunky, but it says 'no divisors but itself and 1'
17:22:34 <applicative_> which one mietek
17:22:38 <mietek> Why is the Producer formed by plugging the input with (), but the Consumer formed by plugging the output with Void?
17:22:55 <mietek> applicative_: there is pipes and pipes-core. Question applies to both, I think.
17:23:04 <applicative_> mietek: they argued about this ad inf.  I never got  clear on what was really rational
17:23:15 <applicative_> yes it applies to both
17:23:34 <mietek> applicative_: on cafe? Do you remember the thread subject?
17:24:22 <applicative_> let me look there was reddit nonsense and some in discussion with the conduit version that pipe-ified
17:24:30 <mietek> Cool, thanks.
17:24:44 <mietek> Also, I'd like to say I'm really lost with regards to the whole stream processing stuff.
17:25:09 <mietek> Iteratees, enumerators, enumeratees... Conduits... Pipes.
17:25:40 <mietek> I think Pipes is the first one I'm able to comprehend, apart from that one bit with () and Void.
17:25:52 <nh2> I just joined and the topic is already set to my question :)
17:26:14 <aristid> mietek: currently the most used (in new projects) is conduits i think, and it isn't that complex to understand either
17:26:45 <nh2> I built some simple server on TCP sockets with network-conduit. Now I want HTTP as well. What way do I go? Warp?
17:27:24 <mietek> aristid: I read about conduits on the Yesod blog and in the book, and I think they seem needlessly complicated.
17:27:42 <mietek> I find the examples presented on http://www.yesodweb.com/book/conduits completely unconvincing.
17:28:29 <Clint> mietek: they've been simplified after that was written
17:28:30 <nh2> mietek: I agree, went through that yesterday. There should really be more / nicer examples. But it works now
17:29:04 <mietek> Clint: good to know, but what should I read then?
17:29:58 <aristid> mietek: i didn't say they are the simplest thing on earth. what i said was is that they can be understood. and they work. pipes meanwhile are not controversial in the question whether they actually work for all use cases, which weighs heavier IMHO
17:30:19 <aristid> -not controversial+controversial
17:30:39 <mietek> aristid: can you give an example scenario where pipes wouldn't work?
17:31:50 <aristid> mietek: i didn't try them myself, but the question seems to be how they behave in the error case
17:32:30 <Clint> mietek: beats me, i'm still stuck back at conduit 0.2
17:32:40 <aristid> Clint: 0.2? why that?
17:33:41 <Clint> aristid: hledger-web hasn't caught up with modern yesod yet
17:34:17 <aristid> Clint: hit up sm :D
17:34:24 <Clint> i did that already
17:35:04 <aristid> Clint: so basically it's a matter of time?
17:35:18 <aristid> Clint: you could look at virthualenv tho
17:36:32 <applicative_> mietek: there is some fighting about it in the comments here but its not what i'm looking for  http://twanvl.nl/blog/haskell/conduits-vs-pipes
17:37:24 <mietek> applicative_: looking at it nevertheless; thanks.
17:38:31 <Clint> aristid: yeah, i expect it to be resolved by the end of the month
17:42:35 <mietek> applicative_: so... Void is a type which has no values?
17:43:05 <applicative_> yes you cant construct one,  there are other ways of going about it
17:43:11 <sipa> only bottom :)
17:43:22 <mietek> Right.
17:43:28 <mietek> Makes more sense now, thanks.
17:46:45 <applicative_> mietek originally he used () at both ends, calling it Zero (data Zero = Zero) I think the idea to change appears in the original public discussion, http://www.reddit.com/r/haskell/comments/rbgvz/conduits_vs_pipes_using_void_as_an_input_or/
17:46:57 <applicative_> whoops thats not the one i mean
17:48:01 <applicative_> http://www.reddit.com/r/haskell/comments/ohjg7/a_new_approach_to_iteratees/
17:48:54 <applicative_> theres discussion spread through both. On one end we have an unconstructable type, on the other a dull no-information type
17:49:49 <applicative_> http://www.reddit.com/r/haskell/comments/reft1/pipeslike_conduit/ maybe
17:51:26 <mietek> applicative_: thanks again.
18:04:02 <applicative_> mietek: in a version of pipes i was writing I used  Conduitlike names for reimplementation of () and Void, data Source = Source, data Sink = Sink Sink;
18:04:42 <mietek> I like the naming used in pipes.
18:05:01 <applicative_> then you dispense with type synonyms  and write Pipe Source b m r and Pipe a Sink m r
18:05:01 <mietek> Oleg code makes my head hurt.
18:05:21 <jfischoff> @quote oleg
18:05:21 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
18:05:40 <jfischoff> @quote oleg
18:05:40 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
18:05:53 <jfischoff> @quote Oleg
18:05:53 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
18:06:11 <jfischoff> as exercise for the reader ;)
18:06:35 <applicative_> its funny,  i understand the iteratee and enumerator  libraries much better after hacking on pipe a bit.  It's not just better names, its a clearer idea
18:08:39 <kallisti> I think caffeine addiction is a prerequisite to being a programmer.
18:09:02 <ion> I don‚Äôt have a caffeine addiction.
18:09:05 <geekosaur> not that funny; I am under the impression that was the point.  iteratee and enumerator were exploring the concept; pipes are the next generation, learning from the first
18:09:07 <burbul> Could anyone tell me if this is idiomatic?
18:09:08 <burbul> guard (not must_cancel_all) >> ["* <- *"]
18:09:23 <burbul> (The context is that I want to print "* <- *" only under certain conditions)
18:09:39 <jfischoff> kallasti: you must enjoy intense concentration
18:09:44 <parcs`> burbul: you're in the [] monad right?
18:09:48 <burbul> yes
18:09:56 <burbul> That's what I'm doing, but I'm not sure whether there's more idiomatic way of saying
18:10:09 <parcs`> burbul: then i would use "* <- *" <$ guard (not must_cancel_all)
18:10:15 <burbul> 'if P, then [], else S'
18:10:30 <burbul> I'm not familiar with <$
18:10:37 <burbul> @src (<$)
18:10:38 <lambdabot> (<$) = (<$>) . const
18:10:46 <burbul> @src (<$>)
18:10:46 <lambdabot> f <$> a = fmap f a
18:11:17 <burbul> Is it just the control.applicative equivalent of guard?
18:11:35 <parcs`> no
18:11:50 <parcs`> a <$ b is like b >> return a
18:12:09 <burbul> ah
18:12:10 <burbul> thanks
18:12:26 <burbul> That was very helpful!
18:13:17 <applicative_> geekosaur: maybe that is right.  I was wondering though, when I was trying to write a 'stream fusion'y version of pipes, that the oleg version has an advantage in mostly using plain function composition instead of <+< and so on
18:14:26 <geekosaur> it does have that --- but it can't be made exception safe, as I understand it
18:14:44 <applicative_> I can't get the leading pipes a libary would export up against each other so I could write a rule
18:15:55 <applicative_> but I haven't got too far.  I was following the remarks at the end of this post https://personal.cis.strath.ac.uk/~raa/posts/2012-01-06-streams.html
18:16:16 <applicative_> even if doesnt work i totally understand stream fusion now, which was pleasing
18:20:46 <redonculus> whew!
18:21:37 <moebius_eye> Hey, I have a newbie question here. Is haskell build to mess with my head?
18:21:40 <moebius_eye> :)
18:21:53 <redonculus> would someone be kind enough to explain this to me: http://hackage.haskell.org/packages/archive/webdriver/0.3/doc/html/src/Test-WebDriver-Commands-Wait.html
18:22:08 <redonculus> i am trying to understand monads and hope this will do it
18:26:02 <shapr> redonculus: Have you read through the standard tutorials?
18:27:00 <redonculus> sort of
18:27:16 <redonculus> i understand most of the syntax
18:27:23 <luite> what's the quickest way to build a ghc tree far enough that the ghc-prim package can be built?
18:27:23 <shapr> Do you understand what it does?
18:27:29 <redonculus> but the intention eludes me
18:27:36 <redonculus> the why of it all
18:27:49 <shapr> moebius_eye: Yes, Haskell stretches your head into new shapes that can hold big ideas :-)
18:28:18 <redonculus> shapr: in what ways, specifically?
18:28:20 <shapr> redonculus: Um, it's a convention that lets you abstract away some picky details.
18:29:12 <shapr> The description of a monad is really simple, but that didn't help me much at all until I saw how the abstraction could be used.
18:29:19 <shapr> Objects were the same way for me the first time through.
18:29:47 <shapr> redonculus: Which tutorial(s) have you read?
18:30:06 <redonculus> lyah
18:30:14 <shapr> Ah, I haven't gotten to that one yet.
18:30:44 <redonculus> i think it takes a different approach
18:31:00 * shapr goes to look at lyah
18:31:22 <shapr> redonculus: So you read a fistful of monads?
18:31:52 <shapr> ooh, lyah does applicative first, neat!
18:32:15 <shapr> Hm, I need to learn applicative, I should read through this.
18:32:17 <redonculus> lol
18:32:49 <shapr> I mean, I vaguely understood control.applicative when it was exciting and new four years ago, but I didn't use it, so it didn't stick.
18:32:50 <redonculus> i read it several times, and each time it was different
18:33:31 <shapr> Can you come up with any sor of more specific question?
18:33:43 <shapr> redonculus: Do you see how the maybe monad is useful?
18:34:06 <redonculus> i've also read this http://bartoszmilewski.com/
18:34:41 <redonculus> i couldn't make the connection
18:35:45 <shapr> redonculus: You mean this one? http://fpcomplete.com/the-downfall-of-imperative-programming/
18:36:45 <shapr> redonculus: Yah, I read that post. I agree with his thoughts.
18:37:01 <redonculus> thank you for that link
18:37:02 <shapr> I thought he said something like "STM is the worst multicore approach, except for all the others."
18:37:06 <shapr> Which is funny, and accurate.
18:37:10 <redonculus> lol
18:38:04 <shapr> And STM is doable in a pure language, and insanely painful in a mutable language.
18:38:48 <shapr> redonculus: So, can you describe to me what you do understand about monads?
18:40:51 <redonculus> sorry, was reading the article
18:41:21 <redonculus> i'm not quite sure what they mean
18:41:44 <shapr> Er, who what?
18:41:57 <redonculus> i'm still reading and asking questions as much as i can
18:42:26 <shapr> In a nutshell, monads are an abstraction in the way that objects are an abstraction.
18:42:46 <shapr> You can use this abstraction to hide plumbing details that you don't want to think about when you're writing useful code.
18:43:41 <shapr> That's what you say to your manger :-)
18:43:56 <redonculus> lol
18:44:12 <redonculus> so you look at data in terms of sets
18:44:20 <redonculus> rather than properties
18:44:32 * shapr thinks about that
18:44:48 <shapr> That doesn't ring any bells for me.
18:45:48 <shapr> Can you explain that more?
18:48:15 <shapr> I'd say monads let me divide something into multiple 'layers' of work, and I can be sure those layers won't run over each other, but will still work together.
18:49:06 <shapr> I guess I see my average use of monads more like the layers in TCP/IP, where IP runs underneath TCP.
18:53:05 <monochrom> I agree it is fair to say that objects are there to hide plumbing, too
18:53:12 <luite> hmm, i don't really understand how monads are like that :(
18:56:04 <monochrom> no no, instead, object is like the state monad, not the other way round. s.push(3); s.push(1); s.push(4); s.pop(); s.push(1)... see the state threading there?
18:56:52 <shapr> luite: Think of how the Gen monad happily feeds the previous seed in to get the next 'random' number, and that can be layered on top of the list, io, or whatever monads. They all work, and nobody bumps anybody else.
18:59:32 <luite> shapr: hmm, it still doesn't really feel like layering to me unless you add monad transformers
18:59:41 <luite> but those are quite bumpy
18:59:44 <shapr> luite: Yah, that's a point.
19:00:00 <shapr> luite: How would you describe monads?
19:02:59 <shapr> luite: How do they 'feel' to you?
19:03:12 <luite> shapr: hmm, never really thought about describing them in a way that's not close to what they actually are (the type class when talking in a haskell context)
19:04:04 <luite> i feel that a description never gets the point across as clearly as a few examples
19:04:11 <shapr> I agree with that.
19:04:59 <monochrom> yeah, I just go with Phil Wadler's sequence of examples, and the parser combinator monad
19:05:54 <monochrom> for a really short elevator pitch, I just use dons's "programmable semicolon"
19:06:29 <luite> yeah that works especially in a do-block context :)
19:06:58 <luite> but doesn't really help understanding how they work, only that different do blocks can do entirely different things
19:07:05 <shapr> Yah, programmable semicolon is a good way to describe it.
19:07:16 <luite> it's i nteresting that ghc can sometimes complain about semicolons that aren't in your code :p
19:07:17 <shapr> luite: Maybe that does help?
19:07:25 <shapr> redonculus: different do blocks can do entirely different things.
19:07:32 <monochrom> it's an elevator pitch. 30 seconds is too short for any real content
19:10:14 * hackagebot diagrams-cairo 0.5.0.2 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-0.5.0.2 (BrentYorgey)
19:13:39 <byorgey> ^^^ just a minor update to allow building with mtl-2.1.*
19:14:14 <byorgey> bigger things are in the works ;)
19:15:16 * hackagebot diagrams-contrib 0.1.1.1 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-0.1.1.1 (BrentYorgey)
19:15:18 * hackagebot cabal-meta 0.2.1 - build multiple packages at once  http://hackage.haskell.org/package/cabal-meta-0.2.1 (GregWeber)
19:18:01 <carter_> byorgey yay about fixing that MTL thing :)
19:18:39 <byorgey> carter: yeah, though I am now running into the <glib.h> inclusion problem building gtk
19:18:53 <carter> byorgey on a mac?
19:19:04 <byorgey> nope, linux
19:19:25 <geekosaur> carter, this is a problem introduced by the most recent glib/gtk upgrade
19:19:33 <byorgey> it's not a mac-specific thing, looks like some kind of incompatibility between gtk and the ... right
19:19:41 <geekosaur> various things need to be updated for compatibility with the new versions
19:20:00 <carter> geekosaur byorgey  -- i had that problem so I rolled back to the gtk  et al that mac homebrew had in early march
19:20:55 <byorgey> thankfully I already have a version built that works, I was just trying to rebuild everything from scratch with cabal-dev prior to uploading
19:21:08 <carter> yeah
19:21:13 <byorgey> but it looks like everything built fine with the exception of gtk, so I just uploaded anyway =P
19:21:50 <geekosaur> carter, yes, but that's a but harder to do on e.g. debian
19:21:52 <byorgey> the next major release of diagrams will have a native SVG backend as the default in place of cairo, which will be a joyous day indeed
19:22:27 <carter> byorgey --- so the fact that once I get my HasCol lib out, and I start playing with my "ggplot 2 layer"
19:22:27 <byorgey> though cairo will still be supported.  I just won't have to try to help new users get it installed.
19:22:54 <carter> i'll have no choice but to work on how to "prune" svg plots that have lots and lots of points
19:22:55 <carter> :)
19:23:28 <byorgey> nice =)
19:23:49 <carter> the context being that if you're rendering raster style its ok if you have 1mllion points defining a curve,  but svg.... not so much
19:25:07 <carter> which in turn is a funny backtrack to having an effective notion of resolution agian
19:25:09 <carter> again
19:34:53 <luite> hmm, a raster backend without external dependencies would also be nice
19:36:01 <luite> but font rendering would be a lot of work to implement
19:36:51 <byorgey> luite: indeed.
19:37:17 <byorgey> even one without text support seems like it would be a lot of work.
19:37:28 <byorgey> but if someone wants to work on it I sure won't stop them =)
19:38:50 <carter> byorgey --- If I manage to get 50+% of my other currenct projects done by mid summer, or at least in alpha status
19:38:58 <carter> byorgey ask me nicely and i'll have a go
19:39:12 <carter> I may be one of its consumers
19:39:14 <byorgey> carter: haha, ok, I won't hold my breath =)
19:39:28 <carter> byorgey --- yeah, I have enough other things on my plate
19:43:40 <carter> byorgey though it may be less engineering work than making a good "point eliminator/ simplifier" for vector backends
19:44:28 <Axman6> hmm, anyone know of a bytestring builder library, that allows you to reference previous parts of the bytestring which have been created already? this would be particularly useful for some of the LZ compression algorithms
19:46:02 <carter> Axman6 --- wouldn't slices working?
19:46:18 <Axman6> been thinking of the design of such a thing. could work quite well if you could specify the maximum amount of the previous buffer you needed to reference (most of these algorithms have a maximum distance for the buffer you can look at)
19:46:23 <Axman6> slices?
19:46:32 <carter> maybe i'm not familiar with the ___-builder libs
19:46:47 <carter> but with the bytestrings themselves, you can pick out slices of them
19:46:56 <Clint> Axman6: is https://github.com/meiersi/bytestring-builder/blob/master/bytestring-builder.cabal what you want?
19:48:16 <Axman6> well it's a builder, but I need to be able to back reference the bytestring that's already been built. I have a feeling I could get away with first parsing the compression blocks themselves, then building with back references later
19:53:27 <kallisti> @quote terminals 1970
19:53:28 <lambdabot> No quotes for this person. Your mind just hasn't been the same since the electro-shock, has it?
19:53:35 <kallisti> @quote can't be reasoned with
19:53:35 <lambdabot> No quotes for this person. I can't hear you -- I'm using the scrambler.
19:53:37 <kallisti> :(
19:54:58 <JoeyA> @quote 1970s terminals
19:54:59 <lambdabot> No quotes for this person. Sorry.
19:55:03 <JoeyA> @quote 1970s
19:55:03 <lambdabot> ray says: when you're dealing with programmers you are often dealing with people who voluntarily use 1970s terminals. they cannot be reasoned with
20:00:25 <JoeyA> @quote prayer
20:00:26 <lambdabot> preaux says: in my family when someone was sick, we would get together and cook, talk about the good time we have with the person, and hope for their recovery, its kinda like a cajun prayer meeting
20:00:26 <lambdabot> with seafood and beer
20:00:32 <JoeyA> bah, wrong quote
20:00:51 <JoeyA> @quote prayer
20:00:52 <lambdabot> preaux says: in my family when someone was sick, we would get together and cook, talk about the good time we have with the person, and hope for their recovery, its kinda like a cajun prayer meeting
20:00:52 <lambdabot> with seafood and beer
20:03:31 <tgeeky> hmm.
20:03:40 <tgeeky> lambdabot even has comedic linebreaks
20:04:19 <JoeyA> @quote comedic
20:04:20 <lambdabot> No quotes match.
20:04:43 <tgeeky> see. funny!
20:05:15 * hackagebot neither 0.3.1.1 - Provide versions of Either with good monad and applicative instances. (deprecated)  http://hackage.haskell.org/package/neither-0.3.1.1 (MichaelSnoyman)
20:05:21 <JoeyA> quote game: type @quote X, then pick a word Y from the result and @quote Y
20:05:46 <tgeeky> @quote JoeyA
20:05:46 <lambdabot> JoeyA says: LLVM: The easy-to-use compiler infrastructure nobody knows how to use.
20:06:36 <jfischoff> @quote LLVM
20:06:36 <lambdabot> JoeyA says: LLVM: The easy-to-use compiler infrastructure nobody knows how to use.
20:06:43 <Axman6> so, i'm writing a library for parsing bytestrings at the bit level. would I be a horrible person if I made my parser an instance of Num so that I could write do { x <- 4; y <- 5; return (x,y)}, where 4 :: BitParsable a => BitParser a and would try and take n bits and parse them into something of type a
20:06:45 <jfischoff> @quote how
20:06:45 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
20:06:58 <jfischoff> @quote nobody
20:06:58 <lambdabot> spj says: "In summary, Haskell is a language everybody talks about and nobody uses."
20:07:24 <tgeeky> jfischoff: FWIW, I think you ended the game
20:07:44 <mauke> please redirect quote games to #haskell-blah
20:07:47 <jfischoff> my bad guys
20:07:50 <tgeeky> Axman6: yes, you would be a horrible person.
20:07:56 <Axman6> i thought so
20:07:58 <JoeyA> Axman6: Why not use a newtype wrapper with a short name?
20:08:08 <JoeyA> e.g. do { x <- B 4; y <- B 5; return (x, y)}
20:08:37 <JoeyA> or what about do { x <- bit 4; y <- bit 5; return (x, y) }
20:08:45 <Axman6> I need a better name for the function that does that then. i've got bitGetN :: BitParsable a => Int -> BitParser a
20:08:48 <mauke> I'd call it "bits"
20:09:28 <Axman6> the class is class BitParsable a where bitGet :: BitParser a; bitGetN :: Int -> BitParser a
20:09:36 <Axman6> and I hate those names
20:10:09 <Axman6> bits is a much better name than bitGetN though. any ideas for a replacement to bitGet?
20:10:27 <Axman6> (get would be a terrible name, since this is already a State monad =)
20:11:28 <JoeyA> x <- B.get 4; y <- B.get 5
20:11:58 <Axman6> maybe bget and bgets?
20:13:18 <JoeyA> Can't think of where else that name would be used.  Sounds good to me.
20:14:07 <Axman6> done
20:16:19 <Axman6> my current implementation is kinda crappy, in that I just turn the ByteString into [Bool] and parse that. I have no way of doing things like keeping track of the position in the ByteString which means I can't easily to partial parsing (parse a binary header, then return the rest of the bytestring that can be used later)
20:16:34 <Axman6> I think I could implement it though. maybe I'll do that now
20:25:17 * hackagebot shelly 0.8.0.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.8.0.1 (GregWeber)
20:40:17 * hackagebot shelly 0.8.0.2 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.8.0.2 (GregWeber)
20:46:37 <carter> question: since when does installing hakyll also install snap server?
20:47:44 <carter> oops, nevermind, previous erver
20:47:49 <carter> *previewserver
20:53:27 <cads> will a typical computer floating point implementation of a continuous uniform random variable taking values in the closed interval [0.0, 1.0] actually attain a value of 0.0 or 1.0?
20:55:19 <cads> it seems like the chance of attaining any given value is some small number d > 0, and that 1.0 and 0.0 should be generated with probability d
21:22:50 <nanothief> If I have a newtype Box a = Box {unwrap :: a}, and a value x :: (Functor f) => f (Box a), will fmap unbox x take any time to perform at runtime?
21:26:52 <mzero> I suspect it depends on the Functor
21:27:15 <mzero> and if the fmap for it is available to inlined
21:27:19 <Axman6> nanothief: newtypes have no runtime overhead, their representation is exactly the same as the value being wrapped
21:27:51 <mzero> yes, but the question amounts to.... is    fmap id   always optomized away?
21:28:16 <nanothief> mzero: yeah, that is another way of putting it
21:28:36 <mauke> mzero: my guess would be no
21:29:35 <mzero> I suspect that for Functors where the compiler has ready access to an inlineable version of fmap, and in a context where it can deduce the percise type, then yes, nanothief, i bet it will be optomized out
21:30:01 <mzero> but if you are doing so in a context where f isn't known to the compiler, then probably not
21:30:35 <mzero> in any case, is this curiosity, or do you have reason to worry that this may affect actual performance?
21:31:09 <nanothief> it was more curiosity, however it could make some operations very inefficient if it wasn't true
21:31:36 <nanothief> however as the type f should always be known at compile time, I don't think it will be a problem now
21:32:10 <nanothief> ... actually with laziness, it probably wouldn't have been a problem anyway
21:33:34 <mauke> fmap_unwrap :: (Functor f) => f (Box a) -> f a
21:33:39 <mauke> fmap_unwrap = unsafeCoerce
21:33:58 <Cale> heh, and you can do tricks like that
21:34:22 <Cale> There are also lots of other things you can get away with using rewrite rules to avoid realToFrac
21:34:39 <Cale> in silly cases where you know the representation is the same and you can unsafeCoerce
21:34:51 <Cale> (like what happens with GL and C types)
21:35:45 <nanothief> nice :), although I don't think it is important enough to manually code that optimisation in for my case
21:36:59 <Cale> Yeah, in your case, that's going to pretty much be a very tiny constant cost
21:37:13 <Cale> even if it is polymorphic
22:15:20 * hackagebot process-conduit 0.4.1 - Conduits for processes  http://hackage.haskell.org/package/process-conduit-0.4.1 (HideyukiTanaka)
22:39:02 <jjxtsys> act
23:05:21 * hackagebot accelerate 0.12.0.0 - An embedded language for accelerated array processing  http://hackage.haskell.org/package/accelerate-0.12.0.0 (ManuelChakravarty)
23:05:23 * hackagebot accelerate-io 0.12.0.0 - Read and write Accelerate arrays in various formats  http://hackage.haskell.org/package/accelerate-io-0.12.0.0 (ManuelChakravarty)
23:05:25 * hackagebot accelerate-cuda 0.12.0.0 - Accelerate backend for NVIDIA GPUs  http://hackage.haskell.org/package/accelerate-cuda-0.12.0.0 (ManuelChakravarty)
23:05:27 * hackagebot accelerate-examples 0.12.0.0 - Examples using the Accelerate library  http://hackage.haskell.org/package/accelerate-examples-0.12.0.0 (ManuelChakravarty)
23:07:29 <Axman6> whooo, new Accelerate!
23:07:40 <ion> cool
23:08:08 <hamid> cuda... there is no plan for opencl?
23:08:33 <Axman6> "New in 0.12.0.0: Full sharing recovery in scalar expressions and array computations. Two new example applications in package accelerate-examples: Real-time Canny edge detection and fluid flow simulator (both including a graphical frontend). Bug fixes."
23:08:44 <Axman6> hamid: there's an experimental fork on github somewhere
23:08:56 <hamid> cool!
23:09:03 <Axman6> "New in 0.12.0.0: Full sharing recovery in scalar expressions and array computations. Two new example applications in package accelerate-examples: Real-time Canny edge detection and fluid flow simulator (both including a graphical frontend). Bug fixes."
23:09:03 <hamid> Axman6: thanks ;)
23:09:19 <Axman6> which pleases me a lot =D
23:09:36 <Axman6> whoops, i mean to paste: "An experimental OpenCL backend is available at https://github.com/HIPERFIT/accelerate-opencl and an experimental multicore CPU backend building on the Repa array library is available at https://github.com/blambo/accelerate-repa."
23:09:45 <oddraisent> putNick (Storage s) c n = modifyMVar_ s $ return . M.insert c n
23:10:01 <oddraisent> How can `$ return .' be rewritten?
23:10:55 <ion> (return . ‚Ä¶)
23:12:02 <oddraisent> ion: thanks
23:16:32 <Axman6> oddraisent: what's the type of s btw?
23:31:53 <ion> SPJ said this in a talk: ‚ÄúIn Erlang, at least, you can do independent garbage collection within one of these processes, and also within Cloud Haskell.‚Äù Independent GC has been implemented for Haskell?
23:33:26 <c_wraith> cloud haskell
23:33:29 <c_wraith> is multiple processes
23:33:41 <c_wraith> Each process gets its own GC
23:34:29 <ion> The processes are lightweight share-nothing threads that may or may not exist on the same physical computer. The GC in Erlang processes is independent of other processes.
23:34:49 <ion> I was wondering if something similar has been implemented in GHC.
23:40:22 * hackagebot msgpack-idl 0.2.0 - An IDL Compiler for MessagePack  http://hackage.haskell.org/package/msgpack-idl-0.2.0 (HideyukiTanaka)
23:48:47 <frankd> hello
23:48:54 <kallisti> filesystem-trees is coming along nicely.
23:49:08 <kallisti> I'm using it for actual projects so I have a feel for the kinds of functions it should export.
23:49:35 <jgr> hi frankd
23:50:33 <frankd> I can't downloads haskell give me a site url
23:51:03 <kallisti> did you try installing the Haskell Platform?
23:51:14 <kallisti> @hoogle Haskell Platform
23:51:15 <lambdabot> Did you mean: :: Haskell Platform
23:51:15 <lambdabot> package haskell-platform-test
23:51:16 <kallisti> er
23:51:18 <kallisti> @google Haskell Platform
23:51:21 <lambdabot> http://www.haskell.org/platform
23:51:21 <lambdabot> Title: Download Haskell
23:51:32 <frankd> hello everyone I can't open the http://hackage.haskell.org/platform/
23:52:14 <kallisti> can you give us some more infoA?
23:52:53 <frankd> The connection to the server was reset while the page was loading.
23:53:34 <kallisti> sounds like a networking issue then
23:54:03 <frankd> i am a chinese china network error ?
23:54:47 <kallisti> maybe. what OS are you using?
23:55:06 <frankd> windows xp sp3 and hakintosh 10.6.4
23:55:17 <kallisti> er, which one of those are you using right now?
23:55:26 <frankd> XP
23:55:43 <kallisti> http://lambda.haskell.org/platform/download/2011.4.0.0/HaskellPlatform-2011.4.0.0-setup.exe  try this link then
23:56:49 <frankd> thank you it is working
23:57:00 <frankd> nice man
23:57:01 <kallisti> strange that the download page wasn't loading.
23:57:24 <frankd> maybe i am in the GWF
23:57:55 <kallisti> I somehow doubt that's the problem.
23:57:58 <kallisti> but who knows.
23:59:16 <frankd> thank you all
23:59:30 <kallisti> no problem. feel free to ask more Haskell related questions. :)
23:59:45 <frankd> i must go to teach my students byebye :)
23:59:51 <kallisti> later.
23:59:55 <liyang> Haskell is banned in China. Its adherents follow the non-state-approved "Church of the Least Fixed Point", which is a subversive organisation opposed to the harmonious nature of our great nation.
23:59:58 <frankd> later
