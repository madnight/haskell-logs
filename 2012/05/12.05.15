00:00:51 <shachaf> > typeOf (undefined :: Bool) == typeOf (undefined :: Int)
00:00:52 <lambdabot>   False
00:01:05 <shachaf> Hmm, I don't know if you can trust typeOf...
00:01:25 <ski> hm, actually, now i realize this isn't enough
00:01:48 <ski> (i also need proof the types are equal)
00:02:39 * ski is currently attempting to do `instance Typeable a => Read (Bar a)'
00:10:14 <rodayo> Getting an error saying " No instance for (Floating Int)       arising from a use of `sqrt'" with this function: mag (Vector a b c) = sqrt $ a^2 + b^2 + c^2  the vector type is defined with 3 Ints for the coordinates. Any ideas?
00:11:08 <liyang> What's sqrt (2 :: Int)?
00:11:36 <shachaf> The answer is obviously (sqrt 2) :: (sqrt Int)
00:11:47 <liyang> > sqrt (realToFrac (2 :: Int) :: Double)
00:11:48 <lambdabot>   1.4142135623730951
00:13:48 <rodayo> Alright I got it. Changed it to : sqrt $ realToFrac(a^2 + b^2 + c^2)
00:14:03 <ski> > (sqrt . fromIntegral) (2 :: Int)
00:14:05 <lambdabot>   1.4142135623730951
00:14:07 <rodayo> I gotta get better with these datatype conversions
00:15:13 <liyang> rodayo: there are only two you need to remember: fromIntegral and realToFrac.
00:15:22 <ski> > realToFrac (1%3)
00:15:23 <ski> > fromIntegral (1%3)
00:15:24 <lambdabot>   0.3333333333333333
00:15:25 <lambdabot>   No instance for (GHC.Real.Integral (GHC.Real.Ratio t))
00:15:25 <lambdabot>    arising from a us...
00:15:47 <liyang> (And I should have used fromIntegral with the sqrt example.)
00:15:54 <liyang> (Not that it makes any difference.)
00:16:19 <liyang> Oh and of course there's floor, round and ceiling.
00:16:54 <rodayo> liyang, those functions behaved strangely for me when i first tried them out. someone here said i need to play with "mono local binds"
00:18:59 <ski> hm .. `class Instance1 cl f where dict1 :: f i -> cl i *> ()' might be useful
00:19:54 <liyang> If they're not behaving how you'd expect them to, add some type signatures (or take out subexpressions and put them in a where-clause with a type signature) and GHC will tell you what's wrong.
00:22:01 <ski> (then i could say `instance Instance1 Read Bar', `instance Instance1 Eq Bar', &c. instead of carrying the kitchen sink with me at all times)
00:30:22 <newsham> > showCReal 100 (sqrt 2)
00:30:23 <lambdabot>   "1.414213562373095048801688724209698078569671875376948073176679737990732478...
00:31:55 * hackagebot yesod-platform 1.0.4.1 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.0.4.1 (MichaelSnoyman)
00:49:55 <moebius_eye> I want to multiply two arrays between them. is it possible?
00:50:32 <moebius_eye> Well, I'm shure it is. My question is more like "how?"
00:50:50 <cheater__> write a function which iterates indices of both arrays.
00:51:15 <moebius_eye> recursively?
00:51:31 <moebius_eye> I thought there would be a more clear and simple way to do this.
00:51:50 <jfischoff> list comprehension
00:51:50 <lambdabot> jfischoff: You have 1 new message. '/msg lambdabot @messages' to read it.
00:52:02 <cheater__> moebius_eye: no, using the list monad
00:52:02 <jfischoff> @messages
00:52:02 <lambdabot> dmwit asked 6h 9m 7s ago: Any idea why I'm getting these? http://hpaste.org/68528
00:52:07 <fmap> what arrays?
00:52:40 <stobix> (map $ uncurry your_multiply_function) . (zip (toList firstArray) (toList secondArray)) -- maybe?
00:52:53 <sopvop> is there a function like  [a,b,c] -> a <*> b <*> c, or better  f -> [a,b,c] -> f a <*> f b <*> f c?
00:52:59 <jfischoff> ?tell dmwit: I think a ghc < 7.4 thing.
00:52:59 <lambdabot> Consider it noted.
00:54:23 <cheater__> stobix: when multiplying two arrays the way you do it, the second one needs to be transposed
00:54:44 <cheater__> and there are some other problems
00:54:46 <moebius_eye> cheater__: I don't understand.
00:55:11 <cheater__> moebius_eye: do you know the definition of the result of array multiplication?
00:55:23 <stobix> cheater__: oh. I'm not really sure what "array" means in the haskell world, so I kinda guessed. :)
00:55:33 <moebius_eye> I'm very new to Haskell actually ^^'
00:55:40 <cheater__> that's mathematics
00:55:41 <cheater__> not haskell
00:56:24 <fmap> perhaps he confuses arrays with lists
00:56:48 <moebius_eye> Yes. I mean lists.
00:56:51 <cheater__> if M = A * B then m_ij = dotproduct A_i B^j      where A_i means the i'th row and B^j means the j'th column
00:56:56 <cheater__> ok
00:57:10 <cheater__> in this case, there are many ways to "multiply" two lists
00:57:13 <cheater__> how do you want to do this?
00:57:14 <stobix> then my solution still holds. :)
00:57:16 <cheater__> multiply term by term?
00:57:33 <moebius_eye> But, waht I want to do is this : f [a,b,c] [d,e,f] -> [a*d, b*e, c*f]
00:57:39 <stobix> (if one skips the toList )
00:58:08 <quicksilver> moebius_eye: zipWith (*)
00:58:18 <quicksilver> > zipWith (*) [1,2,3] [4,5,6]
00:58:19 <lambdabot>   [4,10,18]
00:58:42 <moebius_eye> Nice! thank's quicksilver
00:58:56 <cheater__> yeah zipWith
00:59:16 <quicksilver> > liftM2 (*) [1,2,3] [4,5,6]
00:59:17 <lambdabot>   [4,5,6,8,10,12,12,15,18]
00:59:22 <quicksilver> for the outer product, incidentally.
01:00:02 <fmap> > [x*y | x <- [1,2,3] | y <- [4,5,6]]
01:00:03 <lambdabot>   [4,10,18]
01:01:04 <cheater__> actually can you somehow make a listcomp which does the same as liftM2 (*) ?
01:01:09 <quicksilver> yes
01:01:24 <quicksilver> > [ x*y | x <- [1,2,3], y<-[4,5,6] ]
01:01:25 <lambdabot>   [4,5,6,8,10,12,12,15,18]
01:01:33 <quicksilver> this is the most 'normal' thing for a list comp to do.
01:01:33 <cheater__> ah, right
01:01:36 <cheater__> of course
01:01:43 <cheater__> the difference between |  and ,
01:01:44 <quicksilver> fmap was demonstrating the weirdo GHC parallel list comp extension
01:01:51 <cheater__> right
01:02:00 <quicksilver> which nobody uses :)
01:02:00 <cheater__> i didn't know it was an extension
01:03:08 <cheater__> > [ [a, b, c] | a <- "abc" | b <- "def" | c <- "xyz" ]
01:03:09 <lambdabot>   ["adx","bey","cfz"]
01:03:26 <cheater__> > [ [a, b, c] | a <- "abc" | b <- "def" , c <- "xyz" ]
01:03:27 <lambdabot>   ["adx","bdy","cdz"]
01:03:35 <cheater__> > [ [a, b, c] | a <- "abc" | b <- "def", c <- "xyz" ]
01:03:36 <lambdabot>   ["adx","bdy","cdz"]
01:03:39 <cheater__> why?
01:03:58 <quicksilver> dunno, looks wrong to me
01:04:05 <cheater__> i would have expected adx ady adz bdx bdy bdz cdx cdy cdz
01:04:56 <quicksilver> I'd have expected 'e' and 'f' to get a lookin somewhere
01:06:20 <quicksilver> oh
01:06:29 <quicksilver> because they get shortened to the shortest branch
01:06:30 <quicksilver> of course.
01:06:32 <cheater__> sorry you're right
01:06:37 <quicksilver> and "abc" is a branch of length three.
01:06:49 <quicksilver> so you just get the first three elements of "def","xyz"
01:06:52 <cheater__> i would have actually expected
01:06:56 <quicksilver> maybe this is why nobody uses parallel list comps :P
01:06:56 <cheater__> adx ady adz bex bey bez cfx cfy cfz
01:06:56 * hackagebot filesystem-trees 0.0 - Recursively manipulate and traverse filesystems as rose trees.  http://hackage.haskell.org/package/filesystem-trees-0.0 (AdamCurtis)
01:07:01 <cheater__> that's the one i would expect
01:07:07 <cheater__> that was the logic i had in mind
01:07:49 <cheater__> > [ [a, b] | a <- "abc" | b <- "def"]
01:07:50 <lambdabot>   ["ad","be","cf"]
01:07:50 <quicksilver> I think you need to nest to get that logic.
01:08:02 <cheater__> > [ [x, a, b] | x <- "xyz", a <- "abc" | b <- "def"]
01:08:02 <lambdabot>   ["xad","xbe","xcf"]
01:08:10 <quicksilver> length of shortest branch.
01:08:21 <quicksilver> > zip [1..3] [10..20]
01:08:22 <lambdabot>   [(1,10),(2,11),(3,12)]
01:08:24 <quicksilver> see ?
01:08:32 <quicksilver> everything after the end of the shortest branch is just ignored.
01:08:33 <cheater__> hmm
01:08:35 <cheater__> yeah
01:08:46 <cheater__> i would have said "shortest sequence"
01:08:57 <mrkronecker> If I know that I'm going to be using increasing (integer) keys, is it a bad idea to use Data.Map (which apparently uses a binary tree) for mapping purposes? Like, does that generate some wildly imbalanced tree?
01:09:00 <cheater__> this "branch" thing confused me but i got it through the zip example
01:09:13 <quicksilver> mrkronecker: no. Data.Map balances itself.
01:09:23 <mrkronecker> Cool, thanks!
01:09:24 <quicksilver> mrkronecker: however if you're using integer keys you might as well use IntMap
01:09:34 <quicksilver> which is similar but a slightly cleverer structure, and faster.
01:09:35 <mrkronecker> Oh? I'll look at that
01:09:37 <mrkronecker> Thank you.
01:09:58 <cheater__> > [ [x, a, b] | a <- "abc", x <- "xyz"| b <- "def"]
01:09:58 <lambdabot>   ["xad","yae","zaf"]
01:10:34 <cheater__> meh, doesn't work without nesting
01:11:05 <mrkronecker> Wow, that's weird
01:11:26 <mrkronecker> > [[x, a, b] | a <- "abc", x <- "xyz", b <- "def"]
01:11:27 <lambdabot>   ["xad","xae","xaf","yad","yae","yaf","zad","zae","zaf","xbd","xbe","xbf","y...
01:11:36 <mrkronecker> Aha. That's better.
01:12:31 <cheater__> yeah but now we want a mixed product
01:12:51 <cheater__> two of the vectors get dotted while one gets crossed
01:16:57 * hackagebot hstatistics 0.2.3 - Statistics  http://hackage.haskell.org/package/hstatistics-0.2.3 (VivianMcPhail)
01:26:58 * hackagebot webdriver 0.3.1 - a Haskell client for the Selenium WebDriver protocol  http://hackage.haskell.org/package/webdriver-0.3.1 (AdamCurtis)
01:39:24 <etpace_> Bit offtopic: In the polymorphic lambda calculus (PLC), does the paramter in function abstraction need to be explicitly typed for typechecking to be decidable?
01:46:27 <Ptival> etpace_: yes
01:52:35 <Alan> wow, i seem to have a real inability to understand GADTs
01:52:54 <Alan> every time i read about them, it feels like i understand them, but then i don't really understand what i've gained
01:53:51 <Ralith> when in doubt, use them in a practical project
01:53:55 <Ralith> when that fails, implement them
01:54:10 <Ralith> this is how you can learn anything
01:55:04 <t7> when confused, read the paper
01:55:11 <t7> then go and cry in bed
01:55:13 <Alan> haha
01:55:14 <Alan> :p
01:55:38 <Alan> actually, i think i'm starting to get it, but still not certain
01:56:49 <Hail_Spacecake> why is :type || an error
01:56:52 <Hail_Spacecake> but :type (||) is fine?
01:57:02 <quicksilver> because || isn't an expression, Hail_Spacecake
01:57:13 <quicksilver> and :type takes the type of an expression
01:57:35 <Hail_Spacecake> || is a function, right?
01:57:39 <Hail_Spacecake> just like, say, head?
01:58:20 <t7> everything is a function *ducks*
01:58:28 <Hail_Spacecake> I mean, it must be a function, because || has type Bool -> Bool -> Bool
01:58:43 <Hail_Spacecake> and yeah everything in haskell is a function
01:58:45 <Hail_Spacecake> p. much
01:58:56 <Hail_Spacecake> but what privileges head over ||
01:59:02 * Alan is interested to see how this gets explained
01:59:02 <Hail_Spacecake> such that I can do :type head but not :type || ?
01:59:08 <t7> you cant :t || because its not applied to anything
01:59:21 <quicksilver> Hail_Spacecake: || does not have type Bool -> Bool -> Bool
01:59:23 <Hail_Spacecake> if I do :type head I'm not applying head to anything either
01:59:23 <t7> you can turn || into a prefix function by doing this (||)
01:59:26 <quicksilver> Hail_Spacecake: || is not an expression.
01:59:30 <quicksilver> Hail_Spacecake: head is an expression.
01:59:38 <quicksilver> Hail_Spacecake: it's just a boring matter of syntax
01:59:47 <Hail_Spacecake> is this because || is infix?
01:59:48 <Alan> (operator) is an expression, but operator isn't?
01:59:49 <Ptival> it's just convention for operators
01:59:56 <quicksilver> Hail_Spacecake: yes, it is because || is infix
02:00:07 <quicksilver> and by the way "everything in haskell is a function" is not true.
02:00:08 <Hail_Spacecake> an operator is just a function that is infix (and therefore takes exactly two arguemnts)?
02:00:11 <Alan> I guess it gives the parser a hand?
02:00:15 <Hail_Spacecake> (ignoring the thing about currying)
02:00:35 <quicksilver> operators can take more than two arguments
02:00:45 <Hail_Spacecake> what's an example of that?
02:00:50 <quicksilver> but, yes, an operator is just an infix function
02:01:03 <Hail_Spacecake> is "infix function" and "operator" exactly synonymous?
02:01:18 <quicksilver> probalby not exactly synonymous, no
02:01:23 <HugoDaniel> is there any convenience function that converts a Maybe Bool to a Bool ?
02:01:25 <quicksilver> `div` is a function used infix
02:01:30 <quicksilver> but it's not an operator.
02:01:45 <Hail_Spacecake> so operators are functions that you don't need to put `` around to use infix?
02:01:49 <Alan> operators don't parse as valid identifiers?
02:02:01 <quicksilver> depending what you mean by identifier, Alan
02:02:02 <Ptival> Hail_Spacecake: you can't do :type (`elem`) but you can do :type (1 `elem`)
02:02:14 <fmap> @hoogle Maybe a -> a
02:02:14 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
02:02:15 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
02:02:15 <lambdabot> Data.Monoid First :: Maybe a -> First a
02:02:24 <fmap> HugoDaniel: ^
02:02:42 <HugoDaniel> thanks fmap :)
02:02:44 <quicksilver> you might say that operators are symbolic identifiers which must syntactically be used infix.
02:02:49 <HugoDaniel> fmap now thats a cool nick
02:02:59 <Hail_Spacecake> Ptival, well that makes sense, 1 `elem` returns a function that is presumably not infix because you didn't wrap *that* in ``
02:03:03 <t7> too many characters
02:03:04 <Alan> quicksilver: the way i read it is that () allows the parser to try and parse a "spazzy" identifier when it's expecting an identifier
02:03:10 <Hail_Spacecake> spazzy?
02:03:21 <Alan> non-alphanumeric
02:03:41 <quicksilver> () allows infix operators in prefix position, yes.
02:03:45 <Hail_Spacecake> so why is alphanumeric treated differently from non-alphanumeric?
02:03:50 <Hail_Spacecake> I mean, if || was defined as "or" instead
02:03:54 <Ptival> Hail_Spacecake: I was just emphasizing that elem used as an infix behaves the same with regards to :type
02:04:18 <quicksilver> Hail_Spacecake: I think, because it makes it slightly easier to parse code in your head without knowing all the definitions.
02:04:25 <Veinor> hmm. on the one hand, i like hsenv's solution of 'trick everything into thinking everything's fine so your stuff doesn't have to prepent cabal-dev to everything'
02:04:32 <quicksilver> it's not the only choice, though.
02:04:34 <Hail_Spacecake> well haskell made the point that || is just a function like any other
02:04:36 <Ptival> I think it's just that you usually use alphanumeric prefix, and operators infix
02:04:36 <Hail_Spacecake> which made sense to be
02:04:39 <Hail_Spacecake> *to me
02:04:46 <Veinor> what Ptival said
02:04:50 <quicksilver> agda permits infix operators which don't look different
02:04:51 <Hail_Spacecake> but now apparently it's not, because you have to use it differently wrt things like :type
02:05:07 <quicksilver> but it makes it more confusing to parse "a b c"
02:05:24 <Veinor> cabal-dev seems to have the property that it's got a nicer codebase, though; hsenv has this weird MyMonad thing
02:05:27 <quicksilver> Hail_Spacecake: yes. it's just a syntactic thing. (||) is just a function like any other.
02:05:28 <t7> infix is evil
02:05:39 <etpace_> Ptival: Do you have an example why? removing the explicit typing doesnt make it any-less syntax directed, why cant we go the "hm" route of instantiating it as fresh and emitting constraints, is it that unification of forall-types is tricky?
02:05:49 <quicksilver> but operators are syntactically special, to be used infix.
02:06:20 <Hail_Spacecake> can you define that yourself?
02:06:32 <Hail_Spacecake> or does every user-defined function require `` to be infix?
02:06:56 <quicksilver> Hail_Spacecake: you can define your own operators, certainly.
02:07:02 <Alan> Hail_Spacecake: it's not really "used differently", since :t (id) works, it's just necessary to wrap an operator in () to make it an expression
02:07:02 <Veinor> > let x !||! y = x + y in 2 !||! 3
02:07:03 <lambdabot>   5
02:07:20 <Ptival> etpace_: this probably has to do with RankNTypes, since HM is decidable :\
02:08:36 <etpace_> I've come across "bidirectional typing" which seems to eliminate some explicit typing, so maybe it is not required for the pLC, just a lot easier
02:12:14 <Ptival> etpace_: what is "it" that is not required?
02:12:57 <quicksilver> @where+ everything-is-not-a-function http://conal.net/blog/posts/everything-is-a-function-in-haskell
02:12:57 <lambdabot> I will remember.
02:16:13 <t7> when people say system-f type inference is undecidable, do they mean without type annotations?
02:16:23 <t7> because then it isnt really systemf, is it?
02:16:26 <Taneb> How is Kleisli pronounced?
02:16:53 <Enigmagic> t7: what would type inference look like with type annotations? :)
02:17:11 <t7> infereing
02:17:24 <t7> inferring the type after application?
02:17:44 <quicksilver> type inference is undecidable means "if you remove all annotations the process for recovering them is undecidable"
02:17:55 <t7> could you say that simply typed lambda calc has inference ?
02:18:18 <ibid> type inference is also called type reconstruction - the idea is, if you remove the type annotations, can you still figure out the types?
02:18:38 <Ptival> t7: yes, without type annotations
02:21:54 <Ptival> t7: and STLC should be inferred by Damas-Milner algorithm as a monomorphic subset of Hindley-Milner type system
02:23:56 <t7> so if i can solve type inference for systemf i would get a prize?
02:24:25 <quicksilver> you'd be widely discounted as a fraud, since it has been proved to be undecidable.
02:24:29 <ibid> t7: you'd be labeled as a kook, most likely
02:24:40 <t7> what is the proof is wrong
02:24:48 <t7> has anyone even read it?
02:24:59 <ibid> t7: yes
02:25:03 <cheater__> there's got to be a nominal decision though, right?
02:25:26 <quicksilver> you don't even need to read the proof, you just need to demonstrate a term which obviously admits two "non-confluent" types
02:25:36 <cheater__> as in, a causal algorithm
02:26:14 <ibid> quicksilver: that doesn't prove undecidability, just ambiguity
02:26:40 <t7> what about a type system that allows multiple possible types?
02:26:41 <ibid> quicksilver: and a type reconstruction system that finds all possible typings would certainly be useful
02:27:29 <quicksilver> ibid: hmm yes.
02:27:32 <cheater__> what if that's an infinite set
02:27:33 <t7> get your turing award nominations ready guys, im going in
02:27:37 <cheater__> or even an uncountable set
02:27:41 <Ptival> t7: you can read the proof if you want to
02:27:48 <ibid> t7: but yeah, if you can demonstrate a working type reconstruction system and prove it correct and convince others of that you have done so, you'd likely get recognition
02:27:51 <quicksilver> ibid: although type inference is commonly understood to imply a unique result?
02:27:57 <cheater__> or even a set where describing its structure would take more information than the program
02:27:59 <Ptival> it reduces to semi-unification problem, which is undecidable
02:28:04 <Ptival> so you'd have to read that to :)
02:28:14 <ibid> t7: the difficulty is in the third part, as people are likely to assume you've got it wrong
02:28:17 <Ptival> and follow the chains of reduction until you hit the false one!
02:28:32 <cheater__> haha
02:29:11 <t7> What about systemf with the odd type annotation ?
02:29:20 <t7> or does it need lots?
02:29:22 <ibid> quicksilver: the common cases are unambiguous, yes, so people do expect that.  but i don't think people would refuse to accept a useful ambiguous system
02:30:50 <t7> i guess people would use it more if it only needed the occasional annotation
02:33:53 <cheater__> that's how i use haskell
02:34:02 <cheater__> i only add annotations when ghc is too dumb
02:34:19 <t7> yeah but thats only type classes right?
02:34:27 <t7> oh any poly morphic arguements
02:35:54 <Ptival> or extensions
02:36:29 <Ptival> t7: for the monomorphic stuff, you don't have to write it down
02:37:09 <Ptival> well, unless you want to enforce monomorphism of a polymorphic thingy for some reason
02:37:44 <Ptival> (do people do that for performance reasons?)
02:38:22 <Enigmagic> Ptival: yes
02:38:28 <Taneb> Or to make haddock documentation more understandable, in some cases
02:39:00 <Enigmagic> but i always put type annotations on top level definitions anyways... it's rarely for performance reasons
02:39:13 <t7> you get a warning if you dont, right?
02:39:20 <Enigmagic> yeah
02:39:23 <t7> or is that only for non functions
02:39:34 <Enigmagic> it's for any top level definition
02:39:41 <Ptival> well, documenting the toplevel things is good
02:40:31 <moebius_eye> Is anyone using the leksah IDE ?
02:40:40 <Enigmagic> it's more common that i'll need to add a SPECIALIZE pragma for perf than a type annotation somewhere, but it happens sometimes
02:40:49 <moebius_eye> I have this error here: "GHCi debugger is not running.  Would you like to start it?" on linux (debian lenny)
02:40:52 <t7> what about some hypothetical language with dependant arrows... maybe i can infer types
02:40:59 <t7> or is that cheating?
02:41:18 <t7> that probably doesnt count as inference
02:41:55 <Ptival> Enigmagic: ok, thanks
02:42:39 <t7> this might just be crazy enough to work :|
02:42:59 <t7> actually this might just be retarded hindley milner
02:50:48 <t7> has anyone ever heard of a calculus like this: \x . x   :   (X : *) -> X
02:51:00 <t7> but note that its not dependant, ie you cant have Types as terms
03:00:10 <Taneb> I'm probably the only person who's ever want Word4
03:00:28 <Botje> word 2011 was bad enough :)
03:00:36 <Taneb> :P
03:00:59 <Alan> Taneb: you say that, but actually i could really do with a Word4 at the moment too...
03:01:13 <Taneb> Or maybe a template haskell thing
03:05:59 <Taneb> Or instance Num UArray Word8 Bool
03:06:05 <Taneb> But I'm rambling
03:10:36 <dcoutts> Taneb: note that UArray Bool is represented as a bitmap, so might be helpful (but it's not Num)
03:11:10 <Taneb> dcoutts, I mean creating a Num instance for it
03:11:57 <Taneb> Or a Num instance for a newtype wrapper?
03:12:11 <Joshua_MG> hi all. I'm not a haskel programmer (C programmer actually) but I'm looking for a simple definition of "what is a functional programming langugae". Could you help me?
03:12:38 <t7> wikipedia :)
03:12:48 <Taneb> That's a difficult question
03:12:57 <burbul> The Wikipedia article does look pretty good.
03:13:01 <t7> a functional language has first class functions
03:13:12 <burbul> -- i.e. functions that you can pass around just like you might pass around integers
03:13:22 <burbul> -- and you can create them at runtime
03:13:34 <Taneb> I'd say (but I'm far from an expert) that a Functional programming language is one where the manipulation of functions is at the core of the language.
03:13:45 <Taneb> But burbul's sounds right
03:14:11 <Joshua_MG> yep, burbul has put the spot to something that I was migssing
03:14:15 <cheater_> Joshua_MG: a language is functional if you can reason about programs written in it like you can reason about functions in mathematical analysis and abstract algebra.
03:14:25 <cheater_> Joshua_MG: that's the simplest way to put it.
03:14:52 <Joshua_MG> thanks all
03:15:18 <cheater_> Joshua_MG: programs in so called non-functional languages cannot be reasoned about this way, in fact very disjoint branches of mathematics have had to be created to analyse such programs
03:15:19 <burbul> Another important element is that in functional languages, people try and avoid _changing the values of variables_
03:15:41 <burbul> [ in fact, in Haskell it's completely impossible, as I understand it]
03:15:45 <cheater_> that has nothing to do with the language being functional or not
03:15:55 <cheater_> it has to do with the language being descriptive
03:15:56 <burbul> cheater_ : strictly speaking know, but
03:16:00 <burbul> *no, but
03:16:14 <burbul> I think that if you want to understand what functional programming is about it's a very important thing to get your head around
03:16:14 <cheater_> either you're speaking strictly or you're speaking bs
03:16:39 <burbul> Well, I don't want to get into an argument about this
03:16:55 <cheater_> there's a correlation of languages being functional and descriptive
03:17:03 <cheater_> but there is no causation
03:17:03 <cheater_> and it's not the important aspect
03:17:21 <cheater_> no, it's important to get your head around the concept you present if you want to understand haskell
03:17:59 <cheater_> which is from what i've seen often where the world of functional languages starts and ends for anyone who makes the statement you just have
03:18:16 <burbul> All I meant was that when I was first exposed to a functional language (Scheme) this was the biggest barrier in understanding the style that programs were typically written in. since Joshua_MG comes from a C background I wanted to make that point.
03:18:41 <burbul> I'm perfectly aware that you can mutate the values of variables in, say, Scheme
03:18:44 <cheater_> yes, but again that has to do with descriptivity of values, not their functional nature
03:19:00 <burbul> But it's considered bad style in a way that is typically novel to C programmers.
03:19:08 <cheater_> just because the first time you've eaten italian it was spaghetti doesn't mean noodles are made out of tomatoes
03:19:29 <burbul> Anyway, I came here to ask a different question...
03:19:35 <cheater_> which is the kind if logic you are applying
03:19:39 <hpc> cheater_: obviously, it means all tomatoes are made of noodles
03:19:45 <cheater_> hpc: oh right
03:20:08 <cheater_> besides haskell has the IO monad which, on the utilitarian level, lets you reassign variables
03:20:17 <cheater_> and it is used often
03:20:31 <cheater_> so let's not get ahead of ourselves
03:20:50 <burbul> Suppose I have a recursive data type with a number of constructors, and another datatype which is essentially the same except that I want to disallow one constructor.
03:21:04 <burbul> So for example I have a data type of (logical) statements whose constructors are called things like
03:21:14 <burbul> 'Disjunction', 'Conjunction'
03:21:18 <cheater_> <burbul> -- i.e. functions that you can pass around just like you might pass around integers < this is not a very good definition by the way Joshua_MG, since it implies php and python are functional languages
03:21:27 <cheater_> and so is bash and javascript
03:21:42 <hpc> cheater_: and any language where integers aren't first-class values ;)
03:21:55 <hpc> burbul: make the second data type, Bar
03:21:55 <cheater_> this is not what functional languages are about
03:22:01 <burbul> And in some contexts I need a data type of logical statements disallowing (say) disjunctions
03:22:10 <hpc> burbul: then, data Foo = Bar Bar | OtherConstructor ...
03:22:29 <burbul> Yes... I could do that, but it doesn't feel like a terribly clean solution.
03:22:30 <cheater_> functional languages are about the ability to use a massive amount of existing mathematical knowledge to analyse programs, create useful techniques, and apply them in ways idiomatic to the language
03:22:43 <burbul> For a start I want to rule out different things in different places.
03:22:52 <burbul> I don't think there's a particularly clean solution to this, but I thought I'd ask...
03:23:29 <hpc> burbul: you could probably also go with the newtype/smart-constructor approach
03:23:36 <burbul> I don't know about that -- sounds interesting?
03:23:36 <hpc> but that might be just as bad
03:23:44 <burbul> I.e. I don't know about smart constructors
03:23:50 <burbul> Let me Google them
03:23:51 <hpc> it's what Ratio uses
03:24:11 <hpc> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Real.html#Ratio
03:24:22 <hpc> the constructor (:%) isn't exported
03:24:25 <burbul> oh, wait, you just mean a manually written function that creates something of a particular datatype?
03:24:26 <hpc> and (%) is
03:24:41 <hpc> which constructs a value by reducing the numerator/denominator, then calling (:%)
03:25:06 <burbul> That blocks pattern matching, right?
03:25:15 <burbul> I.e. you can't subsequently pattern match against a Ratio?
03:25:16 <hpc> yes, to the outside
03:25:28 <hpc> though view patterns still work
03:25:31 <burbul> Yes... that's a bit of a pain, at least for the applications I'm thinking of.
03:26:43 <burbul> I think probably what I really want is some way of constructing a subtype of an existing (recursively defined) type.
03:31:39 <burbul> Hmm... constraint kinds look as if they might be interesting: http://blog.omega-prime.co.uk/?p=127
03:34:40 <lpvb> what happened to the strict version of foldl?
03:35:45 <Taneb> @hoogle foldl'
03:35:45 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
03:35:45 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
03:35:45 <lambdabot> Data.ByteString.Char8 foldl' :: (a -> Char -> a) -> a -> ByteString -> a
03:36:08 <lpvb> o nvm
03:57:09 * hackagebot syntactic 0.9 - Generic abstract syntax, and utilities for embedded languages  http://hackage.haskell.org/package/syntactic-0.9 (EmilAxelsson)
04:15:32 <tzxn3> u finally understand monads
04:15:38 <tzxn3> *I
04:15:44 <tzxn3> :p
04:16:03 <EEVIAC> now write a tutorial about them
04:16:07 <hpc> haha
04:16:12 <danr> :p
04:16:21 <liyang> Oh no you don't!
04:16:37 <hpc> tzxn3: next step, mtl!
04:16:43 <tzxn3> :p
04:16:45 <danr> hpc: yeah that's a good suggestion
04:17:10 <tzxn3> i was just about to make that joke
04:17:19 <hpc> tzxn3: ignore Cont though; it's rather freaky
04:17:28 <tzxn3> but EEVIAC beat me to it :(
04:23:48 <Ptival> do you understand monads categorically?
04:24:04 <Ptival> or operationally?
04:24:09 <Ptival> or axiomatically?
04:24:24 <Ptival> or burritally?
04:24:42 <Ptival> also, philosophically
04:24:53 <sipa> Ptival: astronautically
04:25:00 <Ptival> space monads!
04:25:09 <Ptival> I see, now the spacesuit makes sense
04:25:16 <Ptival> wonder about the nuclear waste though
04:26:49 * hpc proposes the next bad metaphor after monads be "continuations are like wearing roller skates in a maple syrup factory"
04:26:58 <EEVIAC> haha
04:27:40 <Ptival> seems legit
04:29:03 <hpc> and after that, "dependent types are like a time machine for your nose"
04:31:10 <liyang> or theologically?
04:31:38 <quicksilver> "conduits are like an enema for your soul"
04:31:47 <hpc> haha
04:33:45 <meric> Can the haskell type system model IS-A relationships? say,is it possible to make it so  a value of type N can be used as argument of a NP -> NP function, because N is-a NP?
04:34:31 <quicksilver> No, but also Yes.
04:34:43 <quicksilver> haskell doesn't directly support subtyping
04:34:47 <quicksilver> (which is good, since subtyping is vile)
04:34:52 <hpc> you can fake it with type classes, if you are feeling gross
04:34:54 <quicksilver> however there are all kinds of ways of modelling it.
04:35:11 <meric> Ok...
04:35:20 <quicksilver> in fact, there are so many different ways to model subtyping that every single haskell binding to an object-oriented library chose a different way :)
04:39:13 <fmap> Why System.Info functions aren't in IO?
04:39:43 <quicksilver> it's a bug.
04:39:52 <Cale> Is it really?
04:40:03 <quicksilver> well that is my opinion, stated as fact :)
04:40:12 <quicksilver> it is a question of perspective.
04:40:13 <Cale> Those are just baked in String constants.
04:40:16 <aristid> fmap: they are determined at compile time
04:40:33 <quicksilver> I'd like to think that constants are subject to equational reasoning *independent* of choice of compiler or runtime.
04:40:50 <Cale> They don't actually "do" anything to determine the architecture that the program is running on.
04:41:09 <quicksilver> for example, I'd like to think that the expression (System.Info.os == "linux") has a denotation
04:41:10 <Cale> If they did do something at runtime, then I would expect them to be in IO
04:41:15 <Cale> but they don't :P
04:41:26 <quicksilver> and that denotation would be either True or False, since it's Bool
04:41:41 <quicksilver> and I'd like all haskell expressions with a Bool denotation to be independent of choice of compiler/runtime/platform.
04:41:48 <Cale> Well, it is either True or False :D
04:41:51 <quicksilver> It is a fairly hardline view and I"m not saying it's terrible important.
04:41:54 <quicksilver> you know what I meant.
04:41:57 <Cale> ;)
04:42:05 <RichyB> quicksilver, it gets *really* annoying in some cases.
04:42:21 <RichyB> quicksilver, consider function sizeof :: Storable a -> Int.
04:42:24 <Cale> I think it's probably okay for the denotations of programs to be different on different architectures and OSes.
04:42:56 <RichyB> If you make that IO Int, you have to write "sizeFoo <- sizeOf (undefined :: Foo)" all over the place in code that uses Storables.
04:43:29 <quicksilver> RichyB: sure.
04:43:37 <quicksilver> RichyB: you don't even have to go that far, to be honest
04:43:46 <Cale> But I don't know. It *would* be annoying if completely different methods were required to analyse programs on one architecture relative to another, but I'm okay with small variations :)
04:43:49 <quicksilver> just asking for the denotation of 2^32 :: Int
04:43:58 <quicksilver> is enough to expose a platform issue.
04:44:35 <quicksilver> Cale: I'd like, for example, chunks of pure code to be able to migrate between servers on heterogenous systems
04:44:42 <quicksilver> Cale: without having to worry that would change the denotation.
04:44:49 <Cale> We're a long way from that being realisable :)
04:44:53 <quicksilver> I appreciate that we don't actually have haskell RTSes that work like that
04:45:00 <quicksilver> but I'd like to think we had a foundation where it was sound.
04:45:31 <RichyB> Maybe you need to enforce a Haskell subset where Int isn't allowed, only Integer and {Int,Word}{8,16,32,64}.
04:46:17 <RichyB> Massive headache that most existing functions like "length" use Int though.
04:46:34 <quicksilver> Cale: you might have a supercompiler which does a pre-compilation stage
04:46:51 <quicksilver> Cale: and which potentially gets the wrong answer for 'constant' expressions if they could vary from run to run
04:47:42 <Cale> I guess the meaning of those String constants just becomes slightly different in that world
04:48:09 <quicksilver> you say that as if it's not blindingly obvious that that is a bad thing ;)
04:48:26 <Cale> They're the information about the build platform, not the platform that the program is running on.
04:49:12 <Cale> So, they're constants, but you wouldn't be able to rely on them to tell you what platform your program's code is running on, which might be inconvenient for you :D
04:51:10 <Cale> It's too bad that make -j4 can't put the terminal output in the order which it would be in without the -j4 :D
04:53:19 <hpc> Cale: it's too bad ghc doesn't have -j
04:53:46 <opqdonut> Cale: gnu parallel knows how to do that
04:54:02 <opqdonut> might be difficult to inject into the makefile, of course
04:54:06 <quicksilver> hpc: yeah, if only there was a parallel haskell extension or something that the GHC developers could use.
04:54:16 <Cale> haha
04:55:06 <quicksilver> in fact ISTR one of the simons admitting that GHC used too much unsafePerformIO to parallelise simply
04:55:12 <quicksilver> :-(
05:12:13 * hackagebot Kleislify 0.0.3 - Variants of Control.Arrow functions, specialised to kleislis.  http://hackage.haskell.org/package/Kleislify-0.0.3 (DylanJust)
05:12:15 * hackagebot Kleislify 0.0.4 - Variants of Control.Arrow functions, specialised to kleislis.  http://hackage.haskell.org/package/Kleislify-0.0.4 (DylanJust)
05:54:57 <Refried_1> so the State monad doesn't actually do anything like encapsulate impurity, where ST and IO do, right?
05:55:16 <Taneb> Yeah
05:55:26 <Franciman> which other monads to that?
05:55:41 <Axman6> sort of. ST encapsulates pure algorithms which use use mutation
05:55:49 <Taneb> ST is a box where you can put your impurity in, IO is a wall where you can shut your impurity out
05:56:15 <jonaskoelker> but only certain kinds of impurity (e.g. flipping bits in memory, not on disk)
05:56:21 <jonaskoelker> (right?)
05:56:24 <Axman6> yeah
05:56:30 <Refried_1> jonaskoelker: you mean ST?
05:56:43 <Axman6> the actions are guaranteed to be pure outside of runST
05:56:47 <Taneb> ST can't interact with the outside world, it's in a box
05:56:51 <Franciman> only ST and IO present impurity, right?
05:57:12 <Franciman> other monads like Parsec Parsers or State
05:57:14 <Franciman> don't
05:57:32 <jonaskoelker> refried__: yeah
05:57:32 <Axman6> yes
05:57:39 <Axman6> well, there's a few more, like STM
05:57:49 <Axman6> but STM can only be used from IO
05:57:54 <Franciman> oh yeah I forgot it
05:57:58 <refried__> what's STM?
05:58:04 <Taneb> Monad transformers with IO or ST in them
05:58:05 <Axman6> software transactional memory
05:58:10 <Franciman> for software transactional memory
05:58:18 <Franciman> Taneb of course
05:58:36 <Taneb> (this may be obvious)
05:59:04 <refried__> is that for some sort of rollback, or .. yeah maybe looks like it
06:00:16 <Axman6> it gives you ACID guarantees on certain memory references
06:00:34 <jonaskoelker> except the D part
06:00:58 <jonaskoelker> "CIA" guarantees? ;-)
06:01:20 <Axman6> what's the D again?
06:01:23 <jonaskoelker> durability
06:01:30 <Axman6> hmm, ok
06:01:36 <jonaskoelker> ... as opposed to picking java for your next project, which gives you "CYA" guarantees vis-a-vis your boss
06:01:42 <jonaskoelker> =)
06:05:11 <stobix> "CIA"?
06:05:19 <donri> roconnor: is it a law for partial lenses that: get (set x) == Just x?
06:05:30 <stobix> "Caught In Action"
06:05:31 <donri> roconnor: or can it be lawfully Nothing?
06:08:44 <quicksilver> Franciman: ST and IO are both pure, that's rather the point of them.
06:09:19 <Franciman> yeah
06:09:26 <Franciman> actually yes
06:09:49 <hpc> technically, in GHC, ST is impure, and IO is a specialization of ST
06:09:55 <hpc> but at the API level, they are both pure
06:11:27 <Saizan> and yet they describe side-effecting computations
06:11:29 <mietek> Anyone using Xmonad on Ubuntu 12.04?
06:11:42 <refried__> stobix: CIA is the US intelligence agency
06:12:08 <Axman6> mietek: the people in #xmonad do
06:12:16 <mietek> Axman6: cheers
06:12:18 * hackagebot newtyper 0.1 - Extra functions for the Control.Newtype typeclass  http://hackage.haskell.org/package/newtyper-0.1 (DylanJust)
06:12:28 <donri> Saizan: so does recipe = "set the oven to 200 degrees celcius..." :)
06:13:52 <stobix> refried__: well, yes. I thought it was a certificate as well, or something. Nevermind then. :)
06:16:11 <Taneb> ...was my analogy with the box and the wall accurate at all?
06:16:39 <quicksilver> hpc: "technically, in GHC, ST is impure" <-- I disagree with this statement.
06:16:55 <quicksilver> Taneb: it made intuitive sense to me :) I didn't think about it too hard.
06:17:17 <Taneb> :)
06:17:27 <hpc> quicksilver: i mean, if you are looking at it from the inside, it's implemented with mutation of "pure" values
06:17:45 <rwbarton> perhaps one should say "runST is impure"
06:18:48 <dolio> Why would one say that?
06:19:20 <Taneb> In my analogy, runST is like opening the box, destroying the impurity and letting you look inside
06:19:35 <hpc> quicksilver: okay, fair
06:19:44 <hpc> STRef mutates, though
06:20:14 <Taneb> stToIO is like throwing the box over the wall
06:20:43 <Taneb> Or something?
06:20:52 <Taneb> Here my analogy breaks down
06:21:31 <Taneb> I'd say ST is a way of simulating impurity in a pure environment
06:21:45 <opqdonut> nah, it's not simulating
06:21:48 <Taneb> Anything you can do with ST, you can do messily with State and big tuples
06:22:05 <opqdonut> yeah, State simulates mutability, ST actually is safe mutability
06:22:29 <roconnor> donri: the law is something like case (getPL l a) of Nothing -> getPL l (setPL l c a) == Nothing  | Just b -> getPL l (setPL l c a) == Just a
06:23:04 <quicksilver> hpc: IMO, the distinction you are drawing is confusing implementation details with semantics.
06:23:29 <roconnor> dolio: The categorical phrasing of all the laws of partial lenses is that runPLens is a coalgebra for the (Coproduct Identity (Store b)) comonad.
06:23:31 <roconnor> er
06:23:34 <quicksilver> hpc: the notion of 'purity' is a semantic notion which relates to the validity of equational / denotational reasoning
06:23:39 <roconnor> donri: The categorical phrasing of all the laws of partial lenses is that runPLens is a coalgebra for the (Coproduct Identity (Store b)) comonad.
06:23:49 <quicksilver> hpc: how things are implemented using GHC primitives is not relevant.
06:23:51 <dolio> roconnor: Great. :)
06:23:59 <quicksilver> which doesn't mean it isn't interesting, or good to understand it, etc.
06:24:12 <Axman6> all thunks are implemented using mutation behind the scenes
06:24:17 <quicksilver> quite.
06:24:22 <Axman6> which i guess is no different
06:24:26 <quicksilver> that's the point I was going to make but forgot about it, Axman6 :)
06:24:27 <quicksilver> thanks.
06:24:31 <roconnor> dolio: sorry I mean donri
06:24:37 <Axman6> teamwork
06:25:29 <roconnor> donri: sorry I screwed up the law
06:25:39 <roconnor> ase (getPL l a) of Nothing -> getPL l (setPL l c a) == Nothing  | Just b -> getPL l (setPL l c a) == Just c
06:25:45 <roconnor> *case
06:29:44 <donri> ah that works for my case i think
06:29:56 <donri> (partial record fields)
06:30:14 <donri> roconnor: do you get notified for github pull requests?
06:30:31 <donri> i don't want to rush a response, just checking that you got it ;)
06:31:22 <roconnor> er, I don't have my github password at work :/
06:31:32 * roconnor needs to learn how to use mozilla sync
06:31:39 <donri> aha
06:31:45 <donri> https://github.com/roconnor/data-lens-fd/pull/1 anyway
06:32:08 <roconnor> ah yes, I seem to recall seeing that befor
06:32:23 <roconnor> I'm unsure how I feel about it yet.
06:32:31 <donri> aye
06:33:22 <roconnor> donri: shouldn't it be summon = asks . get ?
06:33:34 <t7> > let f (x :: forall a. a -> a) = x in f not
06:33:35 <lambdabot>   Couldn't match expected type `a'
06:33:35 <lambdabot>         against inferred type `GHC.Bool.Bo...
06:34:24 <donri> roconnor: sure, i just tried to write it like 'access'. isn't it the same thing?
06:34:50 <donri> in my own code i have summon = asks . getL
06:36:21 <roconnor> donri: indeed ... I didn't write access. :)
06:38:20 <refried__> hey, so in this blog post: http://www.casualmiracles.com/2012/01/03/a-small-example-of-the-scalaz-io-monad/   umm. he says some stuff, and the top commenter says "Mixing regular impure functions (such as println) with the effectful functions using IO monad is asking for trouble. You should wrap usage of impure functions with io or use their monadic counterparts."  and links to an example, but the paste site he used is down -- can anyone e
06:38:29 <donri> in any case, *some* MonadReader API would be nice to have for (in my case) acid-state Query events
06:38:47 <refried__> later on he talks about IO a  vs IO IO a
06:38:53 <roconnor> donri: there is an analogy between MonadState:Lens and MonadReader:projections ... so in some sense access is a reasonable operation of MonadState, but if you want to use lenses with MonadReader you should use (getL l) to get the projection function and use that, since the setter are incompatible with MonadReader.
06:38:59 <refried__> or maybe that doesn't apply in haskell, just noticed this is a scala article
06:39:14 <roconnor> donri: but as you said, maybe some MonadReader sugar would be nice.
06:39:19 <roconnor> anyways
06:40:48 <donri> i also have (%.) = flip liftM . summon, but you said you dislike adding operators and i'm not even sure myself about that name
06:41:37 <roconnor> @hoogle mapReader
06:41:38 <lambdabot> Control.Monad.Trans.Reader mapReader :: (a -> b) -> Reader r a -> Reader r b
06:41:38 <lambdabot> Control.Monad.Reader mapReader :: (a -> b) -> Reader r a -> Reader r b
06:41:38 <lambdabot> Control.Monad.Trans.Reader mapReaderT :: (m a -> n b) -> ReaderT r m a -> ReaderT r n b
06:41:45 <donri> and in any case it you could use <$> with summon for similar effects?
06:42:23 <roconnor> donri: do you use the MonadState stuff too?
06:42:27 <donri> yep
06:42:32 <donri> for acid-state Update events
06:42:50 <donri> where Update is a MonadState instance and Query a MonadReader
06:42:55 <roconnor> how do you feel about assignment returning a non "m ()" value?
06:43:02 <donri> i love it
06:43:07 <roconnor> interesting
06:43:13 <donri> roconnor: http://hpaste.org/65370
06:43:16 <donri> makes that possible
06:43:30 <roconnor> I have one person who hates it, and doesn't data-lens because of it, and one person who loves it.
06:44:15 <donri> isn't there a "void" defined somewhere that you could just stick at the end of your state computations?
06:44:18 <roconnor> the problem is you cannot write (when foo (nextKey += 1))
06:44:24 <roconnor> ya you have to write
06:44:29 <roconnor> the problem is you cannot write (when foo (void (nextKey += 1)))
06:44:39 <roconnor> but this is a bit of a pain if you do it a lot.
06:44:51 <donri> :t when
06:44:52 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
06:44:56 <donri> ah yea
06:45:11 <donri> Data.Lens.Void? ;)
06:45:20 <roconnor> well good to know your opinion
06:45:28 <roconnor> I guess I won't be changing the behaviour
06:45:48 <roconnor> donri: ya, that is not a bad idea.
06:46:02 <roconnor> make a new module with operators returning void.
06:46:12 <arcatan> refried__: in Haskell, the impure functions are always in IO (unless you use unsafePerformIO), so that doesn't directly apply to Haskell
06:46:28 <roconnor> donri: though it may make code harder to read ... but probably not.
06:47:00 <roconnor> some horrible things might be possible with typeclasses
06:47:06 <donri> hah
06:47:14 <t7> can i infer type applications if i supply all types for abstractions in system f?
06:47:14 <roconnor> I'm not sure I want to go there
06:48:43 <refried__> arcatan (or anyone): are there any elegant tools for generating ffi declarations, or is it gerenally a painful manual job?
06:49:46 <byorgey> Cale: do you have copies of the articles etc. that used to be on cale.yi.org anywhere?
06:49:54 <byorgey> in particular http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
06:50:00 <donri> roconnor: I know, (+=∅) awesome!
06:50:15 <roconnor> @quote unicode
06:50:15 <lambdabot> elliott says: "with a lot of unicode" is like agda's @faq. "yes, agda can do that with a lot of unicode!"
06:50:24 <roconnor> @quote edwardk unicode
06:50:25 <lambdabot> edwardk says: i used to be a huge proponent of unicode syntax everywhere, then i used agda ;)
06:50:35 <donri> ;)
06:50:54 * donri wasn't serious, if that wasn't clear
06:51:14 <roconnor> it was clear :D
06:51:29 <donri> wait, so if it was clear i was serious? english, oh you!
06:52:26 <Cale> byorgey: no
06:52:31 <donri> I do like unicode... when my editor transparently displays ASCII as it.
06:52:41 <byorgey> Cale: oh, sad =(
06:52:44 <Cale> byorgey: Well, maybe, but I need an IDE/SATA adapter to find out
06:52:50 <byorgey> heh
06:52:50 <Cale> The hard drive that was on is failing
06:52:52 <arcatan> refried__: there's at least c2hs but I've never used it. here's a tutorial, though: http://blog.ezyang.com/2010/06/the-haskell-preprocessor-hierarchy/
06:53:05 <refried__> thanks
06:53:18 <Cale> The OS on it wasn't bootable, but it might be possible to recover that old stuff if I could install it in another machine
06:53:23 <parcs`> refried__: i use bindings-DSL and hsc2hs
06:53:50 <mogz> I wonder: is there a way to find the priority of an operator directly from GHCi? Without googling it?
06:54:08 <donri> mogz: :i (==)
06:54:12 <byorgey> Cale: just curious since someone noticed the link to it from the Typeclassopedia was broken.  I tried the Wayback Machine but it doesn't have any copies.
06:54:24 <mogz> oooh nice
06:54:25 <mogz> :)
06:55:37 <parcs`> refried__: bindings-DSL + hsc2hs is more powerful than c2hs i think
06:55:39 <mogz> and how to call it for function application? Seems tricky : d
06:56:28 <donri> mogz: what do you mean?
06:56:53 <mogz> well, the "space" operator is untraceable this way is it ?
06:57:05 <donri> :i space
06:57:52 <mogz> nah I mean function application, like "sum [1, 2]", the space between sum and the list
07:00:46 <donri> mogz: i think it is infixr 10... don't take my word for it though :p
07:01:31 <mogz> nah I think it's infixl
07:01:37 <arcatan> yeah, infixl
07:01:46 <mogz> else map (+ 1) list wouldn't parse correctly I guess
07:01:55 <donri> i can't even tell right from left in the real world so yea
07:02:01 <mogz> : d
07:03:22 <EvanR> left is up cross forward ;)
07:03:33 <EvanR> i have to do that every time
07:05:46 <quicksilver> mogz: juxtaposition binds tighter than anything else.
07:05:56 <mogz> ok :)
07:06:02 <quicksilver> and it binds like this: f a b c d == (((f a) b) c) f)
07:06:08 <quicksilver> oops that last f is a d.
07:06:23 <quicksilver> so yes, it binds to the left as mogz said.
07:07:26 <hpaste> mizu_no_oto pasted “floyd-warshall” at http://hpaste.org/68542
07:10:32 <mizu_no_oto> Could anyone help me optimize that code a little bit?  In particular, the parallel version is running slower than the sequential version
07:11:54 <refried__> parcs`: what does "more powerful" mean?
07:12:20 * hackagebot approx-rand-test 0.0.3 - Approximate randomization test  http://hackage.haskell.org/package/approx-rand-test-0.0.3 (DanielDeKok)
07:12:42 <mizu_no_oto> here's an image of the eventlog from threadscope: http://imgur.com/UB3tE  (btw, where would be a good place to post the eventlog if anyone wanted to take a look at it?)
07:17:57 <mizu_no_oto> Also, does anyone have any suggestions to optimizing the code at all?  For a 100 vertex graph, it's currently taking ~10 sec for the sequential version, 11 sec for the parallel version with only one core, and 16 sec for the parallel version using 7 threads (on my quad-core system).  This seems fairly slow
07:30:05 <dumael> mizu_no_oto: strictness? bigger heap?
07:33:33 <td123> mizu_no_oto: don't have anything specific, but min' could be written like: min' = liftA2 min
07:34:20 <td123> nvm..
07:34:22 <liyang> Or min' a b as min <$> a <*> b
07:34:43 <td123> he's returning the other value if one of them is nothing :P
07:35:00 <mizu_no_oto> yeah.  Slightly different semantics, but the same type
07:35:42 <mizu_no_oto> There actually is an Ord instance for Maybe, but it has the inverse semantics - i.e. Nothing is treated as negative infinity rather than positive infinity
07:37:21 * hackagebot hissmetrics 0.3 - Unofficial API bindings to KISSmetrics.  http://hackage.haskell.org/package/hissmetrics-0.3 (FelipeLessa)
07:42:58 <liyang> ah, didn't see the code. I suppose you could write min' a b = min <$> a <*> b <|> a <|> b
07:43:34 <liyang> Not that that would help the parallel code.
07:44:00 <hpaste> ClaudiusMaximus annotated “floyd-warshall” with “floyd-warshall (annotation)” at http://hpaste.org/68542#a68543
07:45:29 <parcs`> does the 'isJust (memoDist ...)' guard inhibit parallelism
07:45:32 <parcs`> ?*
07:45:33 <lambdabot> Maybe you meant: . ? @ v
07:46:05 <ClaudiusMaximus> parcs`: not sure, but at least there's no point possibly computing it twice
07:46:17 <ClaudiusMaximus> (though the memo should handle that, i guess)
07:46:54 <ClaudiusMaximus> note that while it completes in 2.7s less wall-clock time, it uses almost double the cpu time...
07:47:21 <t7> > let f (x :: forall a. forall a. Int) = x in x 2
07:47:22 <lambdabot>   Conflicting definitions for `a'
07:47:22 <lambdabot>  Bound at: <interactive>:1:19
07:47:22 <lambdabot>            <i...
07:47:41 * parcs` doesn't know how to read the threadscope graphs
07:48:17 <ClaudiusMaximus> parcs`: it helps if you have the interactive program and zoom in to see the details
07:48:51 <ClaudiusMaximus> but i think the top wiggly line shows how many cores are operational
07:49:02 <t7> > let f (x :: forall a. forall b. Int) = x in x 2
07:49:03 <lambdabot>   Couldn't match expected type `t1 -> t'
07:49:03 <lambdabot>         against inferred type `Simpl...
07:49:08 <ClaudiusMaximus> (as in, actually computing things rather than gc or waiting to gc)
07:49:36 <t7> :t (2 :: forall a. forall b. Int)
07:49:37 <lambdabot> Int
08:03:33 <Axman6> mizu_no_oto: floyd warshall usually uses an array doesn't it? you can use laziness to compute the values you're after quite easily (assuming i'm remembering what floyd warshall does correctly)
08:04:01 <Axman6> hmm, i guess you're already doing that
08:04:40 <ClaudiusMaximus> i think some of the problem might be in the 3 traversals to get length/minimum/maximum of the vertices list (but i haven't tested that yet)
08:12:23 * hackagebot hspec-discover 0.0.0 - Automatically discover and run Hspec tests  http://hackage.haskell.org/package/hspec-discover-0.0.0 (SimonHengel)
08:13:57 <Taneb> Still haven't got my hackage account
08:20:45 <t7> how does how does rank n inference work
08:20:58 <bitonic> t7: it doesn't, it's undecidable
08:22:24 * hackagebot template 0.2.0.7 - Simple string substitution  http://hackage.haskell.org/package/template-0.2.0.7 (JohanTibell)
08:24:33 <mizu_no_oto> ClaudiusMaximus:  Switching to `using` parBuffer numCapabilities rdeepseq makes the parallel version run in 1/3 the time as the sequential version, thanks
08:25:28 <Saizan> t7: SPJ has published a few papers over the years on what GHC tries to do wrt inference in the presence of rank-n types
08:25:47 <quicksilver> Saizan: none of them are correct any more :)
08:25:52 <quicksilver> but they do explore the design space a bit.
08:27:24 * hackagebot reactive-banana 0.6.0.0 - Practical library for functional reactive programming (FRP).  http://hackage.haskell.org/package/reactive-banana-0.6.0.0 (HeinrichApfelmus)
08:27:26 * hackagebot reactive-banana-wx 0.6.0.0 - Examples for the reactive-banana library, using wxHaskell.  http://hackage.haskell.org/package/reactive-banana-wx-0.6.0.0 (HeinrichApfelmus)
08:27:26 <Saizan> yeah, boxy types, first class polymorphism, and there's a new proposal too
08:37:17 <ClaudiusMaximus> mizu_no_oto: i made it go a little bit faster still, by copy/pasting arrayRange from Memo and making it use parBuffer internally too..
08:37:26 <ClaudiusMaximus> mizu_no_oto: but it's a bit ugly
08:38:17 <ClaudiusMaximus> actually the big win was with  +RTS -N -A1G   -- uses 4GB instantly with 4 cores, but doesn't need to GC at all
08:39:25 <ClaudiusMaximus> i guess that could be considered cheating though
08:41:59 <forrestv> would it make any sense for "all (\x -> True) [1..]" to evaluate to True?
08:43:37 <quicksilver> forrestv: it makes logical sense in some appropriate logical setting.
08:43:47 <quicksilver> forrestv: it doesn't make sense in haskell.
08:44:23 <forrestv> which setting? and why?
08:44:25 <ClaudiusMaximus> forrestv: sure, if you can prove it (which 'all' can't, because it doesn't know enough about the values inhabiting the type) - i kinda used something related in my 'bitwise' library
08:45:41 <quicksilver> forrestv: well it's perfectly logical to say that "all" elements of the list (repeat True) are True.
08:45:50 <quicksilver> so you can prove that, in certain systems.
08:46:03 <quicksilver> but important things about haskell means that haskell cannot (and should not) be able to do that.
08:46:36 <forrestv> why should not?
08:46:46 <ClaudiusMaximus> Data.Bits.Bitwise.all (const True) (42::Integer)
08:46:46 <ClaudiusMaximus> True
08:47:29 <quicksilver> forrestv: because it conflicts with the "meaning" of infinite lists in haskell.
08:47:41 <quicksilver> all has to check every item
08:47:46 <ClaudiusMaximus> but that relies on knowing that  there are only 4 functions :: Bool -> Bool
08:47:50 <quicksilver> it can't cheat; it has an operational description.
08:48:05 <quicksilver> and checking every item takes forever
08:49:14 <ClaudiusMaximus> (total functions, because   Data.Bits.Bitwise.all (const (error "partial functions cause problems")) (42::Integer)
08:49:17 <ClaudiusMaximus> *** Exception: partial functions cause problems
08:51:14 <forrestv> quicksilver, there's no sane way to "optimize" something that takes forever to something that doesn't?
08:51:48 <ClaudiusMaximus> :t ?all (\x -> True) [1..]
08:51:49 <rwbarton> that's not really an optimization
08:51:49 <lambdabot> forall t t1 t2. (?all::(t1 -> Bool) -> [t2] -> t, Num t2, Enum t2) => t
08:52:10 <rwbarton> I guess that is why you used quotes.
08:52:59 <quicksilver> forrestv: if you ask that question in a very general or abstract way
08:53:06 <quicksilver> then, yes, that kind of thing is possible in some settings.
08:53:19 <quicksilver> it's just that this *particular* optimisation is not permissible in haskell because it changes the language.
08:54:35 <Gurrag> [newbie question]  Can the Haskell 98 Report be used as an introduction to the language?  Is it outdated/obsolete?
08:55:03 <Taneb> It's more... dense and technical
08:55:31 <Taneb> I wouldn't reccomend it as introduction ever.
08:56:42 <geekosaur> (it is out of date but still mostly valid.  not that the 2010 report is any more appropriate as an introduction.)
08:57:47 <Franciman> do you think that forall will ever be added to the standard?
08:58:05 <quicksilver> it seems likely
08:58:08 <Gurrag> Will studying Category Theory provide a beginning to "grokking" Haskell?
08:58:14 <quicksilver> because ScopedTypeVariables is pretty useful.
08:58:18 <quicksilver> and not very controversial.
08:58:36 <Taneb> Gurrag, category theory may help but I find it a lot harder than just using Haskell
08:58:36 <quicksilver> Gurrag: in my opinion, no.
08:58:59 <quicksilver> no more than learning newtonian physics will help you grok driving a car.
08:59:17 <Franciman> quicksilver, is there a way to simulate it? ( scopedtype var )
08:59:27 <Franciman> without extensions of course
08:59:40 <quicksilver> not quite sure what you mean by 'simulate' scopedtypevariables
08:59:58 <Taneb> Have the same thing without actually having it, I'd assume
09:00:03 <Franciman> yes
09:00:10 <quicksilver> Taneb: I am familiar with the meaning of the word 'simulate' :P
09:00:25 <quicksilver> but in the particular case of ScopedTypeVariables it depends what you'd consider "the same thing"
09:00:59 <Taneb> I'm not familiar with ScopedTypeVariables.
09:01:02 <quicksilver> I believe you can always find a way to write the type signature for a particular term but you may have to change the term
09:01:30 <quicksilver> ...those changes can be denotationally irrelevant, adding helpers like 'asTypeOf' whose intention is to let you describe the types
09:01:34 <quicksilver> without changing the meaning.
09:01:51 <quicksilver> I'm not aware of a proof of this piece of folklore
09:01:56 <quicksilver> and in some cases it can be quite tortuous.
09:01:57 <jfischoff> gurrag: this is helpful as a beginner: http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
09:04:09 <Gurrag> Thank you for the link, I'll read that.
09:06:51 <Taneb> How is UArray i Bool stored in memory? A bunch of bits, with each bit representing a bool?
09:07:20 <Franciman> I guess not
09:07:28 * hackagebot temporal-media 0.3.0 - data types for temporal media  http://hackage.haskell.org/package/temporal-media-0.3.0 (AntonKholomiov)
09:07:30 * hackagebot temporal-music-notation 0.2.0 - music notation  http://hackage.haskell.org/package/temporal-music-notation-0.2.0 (AntonKholomiov)
09:07:32 <Franciman> since some cpus make it awkward to access bits
09:07:32 * hackagebot temporal-music-notation-western 0.2 - western music notation  http://hackage.haskell.org/package/temporal-music-notation-western-0.2 (AntonKholomiov)
09:07:35 * hackagebot temporal-music-notation-demo 0.2 - generates midi from score notation.  http://hackage.haskell.org/package/temporal-music-notation-demo-0.2 (AntonKholomiov)
09:07:37 * hackagebot click-clack 1.0 - Toy game (tetris on billiard board). Hipmunk in action.  http://hackage.haskell.org/package/click-clack-1.0 (AntonKholomiov)
09:07:40 <Taneb> Hmm, yeah
09:07:56 <navaati> Taneb: the bits are packed, so the representation is space efficient
09:09:49 <geekosaur> yeh, thought I'd seen that Bool was specialized in UArray.  (haskell lets you do that kind of thing...)
09:10:07 <Franciman> geekosaur how?
09:10:33 <navaati> it's possible with data families, but i'm not sure it's the way it's done for UArrays
09:11:26 <Franciman> oh yes true, type families
09:11:38 <geekosaur> UArray predates data families.  UArray is a typeclass
09:12:02 <rwbarton> right, you don't need anything beyond ordinary type classes
09:12:30 <rwbarton> conceptually the UArray is just the bounds and a pointer to a bunch of memory, and type class functions determine how that bunch of memory is accessed
09:12:58 <Franciman> hey dudes can you define a type in a typeclass?
09:13:17 <tac-tics> Franciman: nope
09:13:20 <geekosaur> associated types are an extension
09:13:21 <tac-tics> types can only be declared at the top-level
09:13:24 <navaati> Franciman: with associated data families, yes
09:13:25 <Franciman> ok thats
09:13:31 <Franciman> *thanks
09:13:40 <andares> hey, is there a better problem set than project euler to practice on?
09:13:45 <navaati> but as rwbarton said, for UArray : data UArray i e = UArray !i !i !Int ByteArray#
09:13:54 <navaati> @where h99
09:13:55 <lambdabot> I know nothing about h99.
09:13:59 <navaati> @where H99
09:14:00 <lambdabot> I know nothing about h99.
09:14:04 <navaati> @where H-99
09:14:04 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
09:14:08 <navaati> yay
09:14:20 <navaati> andares: this ^
09:14:29 <andares> ooh shiny. thanks!
09:15:04 <andares> I like that it all hails from Prolog :p
09:17:53 <Taneb> Is it possible to hide bits of code made with template haskell for the code outside the TH-generated stuff?
09:18:10 <zzing> What is the proper name for a 'variable' in haskell, given that it can't actually change?
09:18:35 <Taneb> zzing, can you give me an example of a "variable"?
09:18:42 <sipa> let x = 5 in x
09:19:07 <zzing> Taneb: a value given a name, say a parameter to a function
09:19:14 <shachaf> zzing: The same as the name used in mathematics, presumably.
09:19:56 <quicksilver> zzing: the correct name is variable.
09:20:06 <quicksilver> zzing: there is nothing wrong with variables being immutab;e.
09:20:31 <quicksilver> the word 'variable' was not intended to mean mutability although it's easy to assume it was
09:20:44 <quicksilver> mathematically, a variable might vary from invocation to invocation
09:20:51 <quicksilver> or it might vary by your position on a graph
09:20:52 <quicksilver> etc.
09:21:06 <Taneb> Can anyone answer my slightly harder question?
09:21:21 <quicksilver> I didn't understand it.
09:21:31 <geekosaur> neither did I
09:21:32 <quicksilver> why are you trying to hide TH-code from non TH-code?
09:21:38 <quicksilver> is "put it in a different module" an answer?
09:22:01 <zzing> ok, I think that makes sense to me
09:22:32 <geekosaur> zzing, if you insist that variable can't mean that, you could use "binding"; some of us do that to make things easier for people who insist that a variable can only ever what Java says a variable is
09:22:42 <geekosaur> ^ever^ever be
09:22:45 <Taneb> I want to make a data type with Template Haskell, but hide the actual constructors (like Data.Set does)
09:23:04 <quicksilver> the way to hide constructors is to put it in a module
09:23:06 <Peaker> Taneb, the hiding is done by not putting them in your module's export list
09:23:12 <quicksilver> TH is not really relevant to that piece
09:23:26 <Taneb> I want to hide them from the rest of the module
09:23:45 <Peaker> Taneb, that's not really possible... modules are the unit of hiding stuff
09:24:04 <Peaker> Taneb, why not throw it in its own module?
09:24:05 <quicksilver> in fact, hiding stuff is pretty much all modules are for.
09:24:08 <Taneb> ...Could I create a separate module with Template Haskell?
09:24:18 <quicksilver> no, unfortunately in GHC modules have to be files
09:24:24 <quicksilver> (and vice versa)
09:24:31 <quicksilver> this is a shame sometimes.
09:24:38 <zzing> geekosaur: I only use it on a context I have used previously. Now java, that is just dirty.
09:24:48 <Peaker> I like the simplicity of 1 file ~ 1 module
09:25:20 <geekosaur> I admit I used Java as the example with malice aforethought, but Java didn;t invent that particular usage, reallt
09:25:39 <zzing> geekosaur: fortran? :P
09:26:00 <robinbb> > 2 + 3 + 4
09:26:01 <lambdabot>   9
09:26:14 <robinbb> > (+) 3 4
09:26:15 <lambdabot>   7
09:26:59 <robinbb> > map (+ 2) [1..4]
09:27:00 <lambdabot>   [3,4,5,6]
09:27:03 <Taneb> Aha, I've found what I wanted
09:27:07 <Taneb> newName
09:27:15 <geekosaur> the point is, you learned how some languages use cariables and incorrectly inferred what aspects of that usage are actually part of the meaning of "variable".  which leads you to think Haskell is somehow using something that is not a variable, or that Hakll is misusing the term variable
09:27:44 <tac-tics> They call them variables, but I've never seen them vary.
09:27:45 <Taneb> Actually, would that work?
09:28:06 <Taneb> No, it wouldn't
09:28:11 <Taneb> Or...
09:28:33 <rwbarton> Taneb, the rest of the module could still do things like write a standalone deriving Show instance for your type
09:28:50 <geekosaur> this isn't just a question of functional programming btw... BLISS (DEC's systems programming language) likewise has variables that are immutable, and it's quite imperative/non-functional
09:28:57 <Taneb> I want the type to be visible, but not its constructors (am I being weird?)
09:29:26 <saep> just export "DataType" and not "DataType(..)"
09:29:30 <geekosaur> if they're defined in that file, they are going to be visible in that file.  this is true whether TH is involved or not
09:29:55 <Franciman> Taneb, no it's very common
09:30:04 <Franciman> that's an abstract data type pattern
09:30:15 <Taneb> But within a single module
09:30:24 <Franciman> ahh
09:30:48 <Taneb> I'll write some code and paste it, give me half an hour
09:30:53 <Taneb> (see if it'd work)
09:47:32 * hackagebot air 2012.5.15 - air  http://hackage.haskell.org/package/air-2012.5.15 (JinjingWang)
09:47:34 * hackagebot air-extra 2012.5.15 - air-extra  http://hackage.haskell.org/package/air-extra-2012.5.15 (JinjingWang)
09:47:36 * hackagebot temporal-music-notation 0.2.1 - music notation  http://hackage.haskell.org/package/temporal-music-notation-0.2.1 (AntonKholomiov)
09:48:20 <DanBurton> hey, #haskell, a question about MonadFix
09:48:32 <DanBurton> Identity is an instance, right?
09:48:59 <rwbarton> it should be, at least
09:49:14 <DanBurton> and MonadFix m => StateT s m is also, as is MonadFix m => MaybeT m
09:49:32 <DanBurton> yet I'm getting this error: No instance for (MonadFix (MaybeT (State [TapeP])))
09:50:25 <navaati> @faq is Identity an instance of MonadFix
09:50:25 <lambdabot> The answer is: Yes! Haskell can do that.
09:50:47 <tac-tics> You haskellers and your fixpoints!
09:52:33 * hackagebot hack2-contrib 2012.5.15 - Hack2 contrib  http://hackage.haskell.org/package/hack2-contrib-2012.5.15 (JinjingWang)
09:58:32 <chrisdone> i want to put an interface to GHC's type-checker online, but i want it to be safe. common concerns?
09:58:32 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
09:58:35 <DanBurton> hrm, apparently the MaybeT instance isn't available for me; when I copy/pasted that instance into my source, it started working
09:59:04 <DanBurton> ah I have transformers 2.2, the docs are for 3.0
10:00:16 <luite> chrisdone: make sure that you limit its memory usage
10:00:23 <luite> since it's very easy to create huge types
10:00:29 <strager> chrisdone: Ever look at Safe Haskell?
10:00:50 <strager> You certainly want to disable Template Haskell.
10:01:05 <luite> chrisdone: ghcjs has a shiny new github organization btw, wanna join? :p
10:01:06 <chrisdone> luite: ah, of course, you're the man to ask. :-) so only memory usage is a concern? there are no clever extensions (pretty sure template haskell runs *after* the initial type-checking phase) that can be cheeky?
10:01:20 <chrisdone> luite: sure :-)
10:01:35 <edwardk> chrisdone: technically template haskell and type checking wind up interleaved
10:01:55 <chrisdone> edwardk: oh, really? i thought it was type-check→run TH→repeat?
10:02:28 <edwardk> that would be one way to interleave ;)
10:02:39 <edwardk> not sure how well staged it is at this point
10:03:12 <chrisdone> hm, in that case i'll disable OPTIONS and whitelist LANGUAGE
10:03:32 <luite> chrisdone: ok i can add you later. Hamish Mackenzie has been hacking on ghcjs recently, it has a linker that removes all unused code (including primops since last week) now, uses the google closure lib for bigints (implementing the integer-gmp primops), and we're working on making it a full compiler flavour for cabal
10:03:57 <luite> Victor doesn't have much time for hacking on it anymore, so we asked him to transfer the repository
10:05:39 <geekosaur> does the naive encoding of Mu still throw the typechecker in a loop?
10:06:13 <chrisdone> luite: sounds pretty cool. does that reduce the output size substantially?
10:06:17 <luite> chrisdone: yes
10:06:18 <mm_freak> geekosaur: yes
10:06:19 <lambdabot> mm_freak: You have 1 new message. '/msg lambdabot @messages' to read it.
10:07:08 <luite> chrisdone: but to be truly useful, i think some client-friendly libs still need to be built
10:07:16 <mm_freak> edwardk: wouldn't that be a useful thing to do?  (generalized profunctors)
10:08:09 <chrisdone> luite: "client"-friendly?
10:08:10 <luite> chrisdone: and a lot of work needs to go into optimization. it uses trampolines, so stack overflows for recursion aren't a problem, but performance probably is (someone's working on a test suite that will include some benchmarks)
10:08:26 <luite> chrisdone: yeah, with a focus on code size
10:08:39 <geekosaur> chrisdone: for your online typechecker, see above re Mu.  I think it's listed as a known bug in the GHC manual
10:08:50 <chrisdone> luite: ah, sure
10:09:13 <chrisdone> geekosaur: right, ghc's time and memory usage have to be constrained
10:09:32 <luite> chrisdone: i'm trying to get diagrams working with it, but the generated javascript code for that (without dead code elimination) is 20MB or so, you can gzip it nicely to around 2
10:09:42 <luite> because it has so many huge dependencies
10:09:57 <luite> without dead code it would be much smaller obviously
10:10:01 <chrisdone> luite: makes sense, haskell libraries are very derivative
10:10:40 <chrisdone> luite: so closure isn't eliminating the dead code?
10:10:56 <luite> chrisdone: i'm working on making it easier to install now, hopefully cabal install ghcjs -fboot will build a fully working compiler with core libs soon
10:11:11 <luite> chrisdone: oh for my own stuff i'm not eliminating dead code
10:11:30 <luite> since i want to use it for wolfgang, where you don't know in advance which code will be called
10:12:05 <luite> the ghcjs linker exports a few haskell functions to javascript, and builds a few big javascript bundles for those
10:12:24 <luite> for example if i export f and g, then it builds f.js, g.js and common.js
10:12:34 <luite> so a page that only uses f, doesn't need to load everything
10:12:47 <chrisdone> right
10:12:50 <luite> dependencies are tracked per function
10:13:18 <chrisdone> a cabal install ghcjs would be pucka
10:13:30 <luite> yeah i'm working on that, but it's tricky to build the core libs properly
10:13:40 <luite> since ghc uses makefiles for that, not cabal
10:14:11 <luite> and cabal needs to be patched for it to be really usable
10:14:22 <luite> since it cannot copy .js files yet
10:14:48 <luite> you get a separate package db for ghcjs (in ~/.ghcjs/ )
10:14:51 <chrisdone> copy where from where?
10:15:02 <luite> from the cabal packages library dir
10:15:47 <luite> when you link your javascript application, it just uses the installed cabal dependencies to collect their js code, does dependency analysis to build the bundles, and then outputs those bundles i was talkinga bout, and a small loader
10:15:55 <chrisdone> that makes sense. binary and js being just two build outputs
10:15:59 <luite> yeah
10:16:34 <luite> i think we can cheat by hiding .js files in the .a, but a cabal patch would be good to have (Hamish already made a patch, but we probably need to use it a bit first before submitting it for review)
10:18:29 * chrisdone clones the repo and tries running the steps in the README…
10:19:40 <luite> chrisdone: well it's really a work in progress atm
10:19:55 <luite> the non-integrated compiler build scripts just don't work properly
10:20:18 <luite> the integrated compiler means you patch ghc so that it outputs .js files for everything
10:20:20 <chrisdone> i'm downloading the ghc too
10:20:37 <luite> but the standalone one should be the one to be used in the future
10:20:38 <edwardk> mm_freak: yes, i even use them in various places in my code. i just don't usually label them as such. i may add them to categories at some point ;)
10:20:55 <luite> chrisdone: you now have push/pull access
10:21:23 <navaati> how do you deal with all the system specific details of the libs ? for example, how is implemented a simple putStrLn ?
10:21:52 <edwardk> i used to label 'prep' lmap in https://github.com/ekmett/multipass/blob/master/Data/Pass/Prep.hs for instance ;)
10:22:49 <edwardk> since virtually every one of those is a Hask -> k profunctor
10:22:57 <luite> chrisdone: depending on how much time it takes me to get the new booter working, try again in a few days or weeks :)
10:23:31 <luite> chrisdone: but if you want a full patched ghc, then go ahead
10:25:59 <luite> chrisdone: there's #ghcjs for discussion
10:27:13 <chrisdone> luite: maybes… i'm preparing to put online a hj compilation service. insert haskell; recieve javascript. i might abandon it if the outlook in ghcjs is good
10:27:15 <luite> oh looks like apfelmus has made reactive-banana compatible with the uhc js backend
10:27:26 <chrisdone> oooo
10:27:40 * hackagebot csound-expression 0.3.3 - Csound combinator library  http://hackage.haskell.org/package/csound-expression-0.3.3 (AntonKholomiov)
10:28:59 <luite> chrisdone: it's all a bit experimental atm, in particular installation. oh it requires the closure compiler (and therefore a jvm) for linking
10:31:32 <chrisdone> i might wait then and see what you guys do
10:31:48 <luite> oh i didn't want to kill your project :p
10:32:22 <luite> chrisdone: hamishmack wants to eventually run leksah with it
10:32:33 <chrisdone> that's monstrous
10:32:42 * hackagebot hspec-discover 0.0.1 - Automatically discover and run Hspec tests  http://hackage.haskell.org/package/hspec-discover-0.0.1 (SimonHengel)
10:32:57 <luite> hehe i guess it will be a while before that's possible
10:33:13 <chrisdone> leksah uses gtk no?
10:33:17 <luite> yeah
10:33:27 <luite> but i guess that part would need to be rewritten
10:33:28 <chrisdone> so how would it run leksah?
10:33:57 * chrisdone waits for “GTK+ in the browser!”
10:34:17 <navaati> it already exists, in a different way though : there is this broadway backend
10:35:03 <chrisdone> i think i've seen that one that connects to a local x server?
10:35:05 <geekosaur> someone's also got an X server in the browser, for still another way to do it
10:35:13 <chrisdone> yeah i saw that one
10:35:53 <luite> i guess some yui2hs would be more likely though :)
10:36:09 <luite> or whatever javascript gui framework is hot
10:36:14 <chrisdone> fortunately we can start from scratch in the browser and not feel too bad about it
10:36:34 <chrisdone> some nice FRP/CLIM/WPF stuff or whatever we want
10:36:44 <luite> maybe that's even better
10:36:55 <navaati> CLIM/WPF ?
10:37:03 <HugoDaniel> i love yui
10:37:04 <HugoDaniel> :)
10:37:24 <HugoDaniel> ive been using it for 4 years now
10:37:36 <chrisdone> navaati: http://en.wikipedia.org/wiki/Common_Lisp_Interface_Manager
10:37:36 <chrisdone> navaati: http://en.wikipedia.org/wiki/Windows_Presentation_Foundation
10:40:31 <chrisdone> navaati: both are rather solid and similar approaches to UIs. i don't really understand FRP (not that i have tried hard to yet), to compare it with these
10:41:41 <navaati> i knew about WPF but it's a lib, not a paradigm like FRP, so…
10:42:06 <navaati> are you refering to the "let's describe GUI's using a descriptive language" paradigm ?
10:42:06 <chrisdone> well, it's a conceptual framework, like CLIM. the implementation is irrelevant
10:43:00 <DanBurton> I can't quite see what I've done wrong with this. Anyone have some extra time to code review? https://github.com/DanBurton/bf-interp
10:43:01 <navaati> (aka XUL, WPF, QML, <the java stuff i can't remember the name>, etc.)
10:43:28 <luite> chrisdone: i want to ask michael snoyman for comments when the ghcjs installation stuff is done. i think he'll also be interested
10:43:53 <luite> and the haste guy already has some client-side frp thing
10:43:57 <luite> for his own compiler
10:45:22 <chrisdone> navaati: really WPF has arbitrary styling ability which makes CSS look silly, retaining a separation of styling from business logic among other advantages, i don't think XUL is so clever or QML
10:45:44 <luite> oh that sonds interesting
10:46:06 <chrisdone> luite: sure, i should hope most serious haskell web devs will be interested in this!
10:46:16 <navaati> ah, interesting since QML and XUL rely on CSS for styling
10:48:57 <luite> chrisdone: hm, dunno. it's still a fairly heavyweight approach, i think it will be very hard to get to "native" javascript performance in terms of code size and speed
10:49:48 <chrisdone> navaati: i didn't have the book for long, but iirc the developer exposes some methods/properties in the class of some UI ‘thing’, and the designer uses them in the XML description language. if you want a rotating border that consists of a music video on a button you can do it. you'd be mad, but it's that flexible, and it's all vector zoomable stuff, no pixels, and runs on DirectX (i.e. sits on the gpu). i feel it's UIs done right, at
10:49:48 <chrisdone> least, one approach done right
10:50:41 <chrisdone> luite: how much slower than js is it?
10:51:01 <chrisdone> luite: like this test? total n acc = if n == 0 then acc else total (n - 1) (acc + n)
10:51:03 <luite> chrisdone: haven't tested yet, there are no official tests, but i expect the worst
10:51:08 <navaati> hum, i think QML is really pretty close to that
10:51:48 <luite> chrisdone: will do that soon, when my thingie comiles again :)
10:52:09 <luite> chrisdone: it will use arbitrary precision integers for that though :)
10:52:24 <luite> chrisdone: (that have the disadvantage that they block all threads)
10:52:26 <byorgey> navaati: btw, the answer to your earlier question about gradients in diagrams is simply "no one has gotten round to implementing it yet".
10:52:37 <byorgey> http://code.google.com/p/diagrams/issues/detail?id=21
10:53:13 <chrisdone> luite: ah, they use some global cache or w/e?
10:53:26 <luite> chrisdone: no, but javascript is single threaded
10:53:58 <chrisdone> luite: not following?
10:54:13 <navaati> byorgey: ah, thanks for the answer. doh, sad, it's still not a total replacement for cairo thus. hum… maybe it should not be too difficult to hack this together, tho
10:54:35 <byorgey> navaati: no, it shouldn't be too hard to hack together
10:54:43 <luite> the haskell code can fake multithreading by switching, but integer operations call out to the google closure lib.
10:54:44 <byorgey> navaati: and it's not really intended to be a replacement for cairo.
10:54:45 <chrisdone> luite: ah, you mean in the calculations in the bigint lib there's no yielding?
10:54:51 <luite> chrisdone: it will block the schedulre
10:54:53 <luite> yeah
10:54:57 <chrisdone> sure, i'd expect that. not so bad is it?
10:55:16 <luite> no, i guess it's similar to the single threaded runtime for native code
10:55:37 <chrisdone> seems like the only reason to use threads in the browser is for abstraction rather than speed anyhoo
10:55:41 <luite> maybe web workers can be used in the future for things that might take long
10:55:46 <chrisdone> that would be cool
10:55:49 <byorgey> navaati: it's intended to be much higher-level than cairo.  So I expect there will always be low-level things you can do with cairo that diagrams won't really give you any way to accomplish
10:55:59 <byorgey> though there's no reason gradients should be one of those things.
10:56:40 <navaati> yep. must a feature in gradient be supported by all backends, or is there some sort of "capabilities" system ?
10:57:06 <byorgey> there is a capabilities system
10:57:06 <navaati> s/in gradient/in diagrams/
10:57:21 <byorgey> (where "capability" = "type class instance")
10:57:40 <navaati> yeah, that's kinda what i meant :)
10:57:56 <byorgey> =)
10:58:39 <Taneb> Writing TH is harder than it looks
10:58:40 <chrisdone> luite: i noticed that i can possibly translate tail calls to for loops…
10:58:46 <chrisdone> tail recursion modulo cons, for sure
10:59:17 <DanBurton> hey if you have a `StateT s (StateT s')` stack, do `get` and `put` work on s or s' ?
11:00:36 <Botje> s, i think
11:00:52 <int-e> s, since that's what the MonadState instance for StateT s does.
11:00:54 <Botje> since lift :: m a -> t m a, so lift get will work on s'
11:01:17 <chrisdone> luite: i mean “map f [] = []; map f (x:xs) = f x : map f xs” is “for(var out = []; !null(out); out = cons(f(out.car),out));”
11:01:21 <luite> chrisdone: yes, i don't think that's done yet, since it directly translates stg to javascript at this point, maybe it will be useful to look at the new cmm codegen for 7.6 (or later), that splits the cmm into two pahses, one without and one with explicit stack
11:01:26 <chrisdone> luite: i think this would be a serious speed boost
11:01:33 <luite> chrisdone: yeah me too
11:01:56 <luite> but i'm not sure how to do it yet, don't know this part of the ghc code very well
11:01:57 <DanBurton> ah yes that makes sense, thanks Botje and int-e
11:02:43 * hackagebot hspec-discover 0.0.2 - Automatically discover and run Hspec tests  http://hackage.haskell.org/package/hspec-discover-0.0.2 (SimonHengel)
11:02:48 <luite> chrisdone: but that will give more complications, long loops must yield to the scheduler somehow
11:03:35 <chrisdone> luite: yeah… not sure how much i like this scheduler stuff hamish is adding, but oh well
11:04:12 <luite> chrisdone: having a scheduler would really help with file IO at least
11:04:54 <chrisdone> i'm personally not even thinking about file io for a browser. maybe i should be?
11:04:56 <navaati> file IO in the browser ? wut ?
11:05:24 <luite> navaati: loading remote json "files" for example
11:05:25 <chrisdone> navaati: well, there's local storage. but ghcjs, i think, reads files from the server
11:06:50 <luite> anyway it's all really experimental atm, i think we'll see what works and what doesnt when we have more tests and benchmarks
11:07:09 <navaati> yeah, actually having FileName contains things like /home/navaati/lol.txt is a unix specific thing, it could perfectly be urls…
11:07:22 <luite> achudnov is planning to build a test suite with selenium
11:07:37 <chrisdone> i've wrote about 25 tests, but only specific to my compiler. basically checking the evaluation model works :p
11:07:58 <chrisdone> selenium? hm
11:08:00 <luite> i hope that we will be able to use the ghc test suite, or at least easily import their tests
11:08:19 <chrisdone> ghc test suite :o
11:08:25 * chrisdone looks in the ghc source repo
11:08:40 <luite> the parts that are relevant that is
11:09:02 <chrisdone> for some reason i didn't think of looking at ghc's test suite
11:09:03 <luite> chrisdone: mvars should be supported now for example, but no tests yet
11:09:15 <luite> i'm sure ghc has some :)
11:10:04 <chrisdone> yeah. i think people can't really trust a compiler until it has tests. don't use stuff that isn't in the test suite and you'll be safe, ostensibly
11:11:31 <chrisdone> https://github.com/ghc/testsuite
11:11:53 <chrisdone> sweeeet!
11:12:51 <worldsayshi> A Cabal question: I have two versions of a package installed. How do I determine which is in use?
11:14:06 <chrisdone> worldsayshi: throw in -v somewhere usually makes it explicit
11:15:40 <chrisdone> worldsayshi: e.g. cabal clean; cabal configure -v3
11:15:56 <lpsmith> You know,  the lack of type-safe sums in most "high level" programming environments really is infuriating.
11:17:29 <chrisdone> lpsmith: like which high-level programming environments?
11:18:16 <lpsmith> Well, sql is what I'm working with at the moment.
11:18:26 <arcatan> what's a type-safe sum?
11:18:29 <chrisdone> it has sum types?
11:18:33 <chrisdone> hum
11:18:49 <lpsmith> chrisdone, no, it doesn't,  but it should
11:18:57 <chrisdone> ah, heh
11:18:57 <lpsmith> arcatan, like the Either type
11:19:14 <chrisdone> @google sum type
11:19:16 <lambdabot> http://en.wikipedia.org/wiki/Tagged_union
11:19:16 <lambdabot> Title: Tagged union - Wikipedia, the free encyclopedia
11:19:16 <lpsmith> C has unsafe sums,  namely the union type
11:19:26 <arcatan> ah, okay
11:20:03 <mdmkolbe> How do I tell cabal to set a preprocessor define (e.g. pass -DDEBUG to ghc)?
11:20:17 <chrisdone> --ghc-options=
11:20:33 <worldsayshi> chrisdone: I don't really understand what you mean. clean and configure is for when installing a package..?
11:21:10 <chrisdone> worldsayshi: what do you mean by in use then? surely a package has to be using it?
11:21:39 <worldsayshi> in use in the system.
11:22:41 <worldsayshi> I have two versions of gloss installed. Which one do I get if I ímport it into my project?
11:22:41 <chrisdone> worldsayshi: it depends on each library/program and what it feels like using in its package description
11:23:34 <worldsayshi> chrisdone: So if not in a package maybe it uses the latest?
11:24:17 <worldsayshi> or if many packages fits the description..
11:24:31 <worldsayshi> *many versions
11:24:43 <chrisdone> worldsayshi: oh right. dunno about its choice with -make or ghci
11:26:05 <worldsayshi> chrisdone: Seems logical it would choose the last... Thanks for the help anyway!
11:29:16 <chrisdone> worldsayshi: oh, yeah. just use -v on ghc/ghci and it shows
11:32:15 <chrisdone> worldsayshi: e.g. i just used Data.Text and i compile with ghc --make -v  and i see:  -L/home/chris/.cabal/lib/text-0.11.1.13/ghc-6.12.3
11:37:04 <chrisdone> worldsayshi: i suspect whether it uses the latest package or not depends on what else it depends on. maybe package A relies on package B-0 so it will use that despite package B-1 being installed. not sure
11:37:24 <worldsayshi> chrisdone: Hmm, I assume this: 'hiding package gloss-1.6.1.1 to avoid conflict with later version gloss-1.7.0.1' means it's using 1.7.0.1 then.
11:38:04 <chrisdone> worldsayshi: sounds plausible. what does it say in the -L args?
11:41:52 <worldsayshi> Should '-L ...' be printed to terminal when running 'ghc --make -v Test.hs'?
11:42:12 <worldsayshi> I don't get anything with '-L' in it..
11:42:50 <chrisdone> odd, i see it in my output
11:43:20 <chrisdone> worldsayshi: what about ghc --make -v Test.hs -fforce-recomp
11:45:23 <worldsayshi> chrisdone: Nothing
11:45:35 <worldsayshi> No '-L' that is
11:45:55 <worldsayshi> I get -I flag though
11:46:38 <worldsayshi> Isn't that for c modules though? gloss doesn't contain native parts I believe...
11:46:49 <worldsayshi> Well.. It does in extension
11:46:57 <worldsayshi> Using opengl
11:47:03 <chrisdone> worldsayshi: beats me then
11:48:13 <worldsayshi> thanks though
11:48:27 <chrisdone> welcome :)
11:51:18 <leino> I have an executable that will spit out many lines very quickly. I want to get those lines into my Haskell program in a non-blocking manner. can someone point me to the correct function?
11:51:46 <leino> System.Process.readProcess seems to be blocking
11:53:51 <chrisdone> leino: you can use that module with createprocess which will return three handles stdin/stdout/stderr and you can read from the pipe as you like
11:57:46 <medfly> hi
11:57:47 * hackagebot exists 0.2 - Existential datatypes holding evidence of constraints  http://hackage.haskell.org/package/exists-0.2 (GaborLehel)
12:02:21 <kamal_> Q. I have interest in Algorithms and wish to solve Pearls of Functional Algorithm Design by Richard Bird. http://www.amazon.com/Pearls-Functional-Algorithm-Design-Richard/dp/0521513383/ref=sr_1_1?ie=UTF8&qid=1337108463&sr=8-1
12:03:29 <kamal_> I want to ask whether I should learn haskell from something like Learn Haskell for great good or just go for functional programming language book by bird.
12:03:33 <leino> chrisdone: oh boy, I thought there'd be an easier way :). doesn't seem _too_ bad, though. but I'll definitely write a little helper function. thanks!
12:08:03 <byorgey> kamal_: read both in parallel.
12:08:25 <kamal_> byorgey: thanx
12:09:07 <byorgey> I think most people end up learning stuff about Haskell from several different sources.
12:09:21 <kamal_> i do have idea of imperative laguages, and just tell me if I learn haskell of functional language in general, will I be able to understand Prolog and Scheme better
12:09:29 <hpaste> strager pasted “Elegance, please” at http://hpaste.org/68547
12:09:35 <strager> For some reason I can't make that nice and pretty ^
12:09:58 <strager> oops, mispaste
12:10:06 <chrisdone> leino: (inh,outh,errh,pid) <- createProcess (shell "whatever") -- and you're done
12:10:07 <byorgey> also, if you're interested in Pearls of Functional Algorithm Design, just start reading through it, and when you get to something you don't understand go learn about it.
12:10:10 <Eliel> kamal_: if you manage to learn haskell properly, you'll also have learned functional thinking.
12:10:21 <hpaste> strager annotated “Elegance, please” with “Elegance, please (annotation)” at http://hpaste.org/68547#a68548
12:10:30 <byorgey> kamal_: you will understand Scheme better.  I don't know how much it will help with Prolog.
12:10:34 <leino> LYAHFGG is a nice and gentle introduction to Haskell, the language. "Real World Haskell" (RWH) is good for practical Haskell, though I find it a bit tedious to read (but that might just be because the real world is tedious)
12:10:41 <Eliel> kamal_: the latter will help with any functional language as well as imperative languages to some extent.
12:10:46 <kamal_> oh i mean will i be able to learn Prolog and Scheme "earlier" not better.
12:11:53 <leino> chrisdone: yeah I just realized :). all those types looked scary
12:12:02 <byorgey> kamal_: you mean will you be able to learn them faster?
12:12:13 <byorgey> kamal_: or are you asking whether you should learn them before you learn Haskell?
12:12:14 <chrisdone> leino: i had the same reaction when i first saw it. it's quite nice in the end
12:12:15 <kamal_> yes, i'm asking
12:12:21 <kamal_> i have still not learnt them
12:12:36 <kamal_> i will learn haskell first
12:12:44 <byorgey> kamal_: sure, after learning Haskell you will certainly be able to pick them up faster
12:12:46 <kamal_> just for that book i told you of algorithms
12:12:53 <kamal_> ok thanx
12:12:58 <kamal_> finally thanx to all
12:13:05 <kamal_> i am off to start learning :)
12:13:09 <chrisdone> imperative, functional and logic are kind of the three main paradigms. but certainly haskell's pattern matching and declarative style will help more with prolog than any imperative langs i know
12:13:26 <leino> kamal_: good luck, and dont forget to write programs
12:15:31 <Eiam> why is it called learn you a haskell
12:16:16 <mefisto> to distinguish it from boring o'reilly books, I'd wager
12:16:40 <chrisdone> Eiam: it's borat speak. for great good!
12:16:57 <nand`> Have any attempts been made to write an operating system in mostly Haskell? say, one that's compatible with commonly used desktop platforms (x86 PC/BIOS)
12:16:58 <Eiam> ah okay never saw those
12:17:57 <leino> kamal_: also, consider this one: http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/  .  I can't recommend it since I havent read it much, but it looks quite comprehensive
12:18:46 <armlesshobo> nand`: I think so
12:18:57 <armlesshobo> nand`: but from what I know, I think the project was abandoned
12:19:07 <leino> nand: I saw a paper about it a while back, but I can't remember the title
12:19:21 <Eiam> im going through the original one, learn you as haskell
12:19:34 <Eiam> its been going OK, got distracted with some other work stuff
12:19:49 <Eiam> -s
12:19:50 <armlesshobo> LYAH is the most entertaining introduction to a language I've ever encountered
12:20:23 <Eiam> well, i don't need entertainment
12:20:38 <Eiam> i've ready so many programming books… im used to boring haha
12:20:58 <chrisdone> nand`: House was such an OS. it worked afaik, but nothing happened after that
12:21:25 <armlesshobo> lol
12:21:40 <Eiam> I fell asleep reading javascript: the good parts no fewer than 4 times
12:21:54 <Eiam> the ruby programming language I fell asleep atleast twice, possibly more
12:22:09 <nand`> chrisdone et al.: I see
12:22:25 <nand`> what about attempts to reimplement a set of GNU-compatible coreutils in Haskell?
12:22:59 <Taneb> I'm trying to learn C from a textbook written pre-ANSI
12:22:59 <nand`> I'd be interested in transitioning to a largely Haskell-run operating system, possibly with non-Haskell components like linux or X.org providing the fundament
12:23:20 <nand`> I've been interested in developing a Haskell-based shell for this purpose
12:23:21 <Eiam> nand`: why?
12:23:27 <nand`> Eiam: language familiarity
12:23:30 <Eiam> no
12:23:33 <Eiam> i mean why a haskell OS
12:23:38 <jfischoff> nand`: coreutils == one step closer to a typesafe shell
12:23:51 <strager> nand`: Check out Plush, a POSIX shell mzero's working on.
12:24:03 <nand`> Eiam: language familiarity; I don't feel comfortable with many languages other than Haskell; this list does not include C to note one
12:24:24 <Eiam> nand`: whats the language of the OS have anything to do with  anything at all?
12:24:31 <nand`> so I have difficulties modifying, contributing back to, developing or fixing bugs in non-Haskell programs
12:24:38 <nand`> Eiam: suppose I want to contribute to the OS
12:24:42 <Eiam> oh dear
12:24:45 <Eiam> i see, okay
12:25:27 <nand`> strager: interesting; I've also been thinking of a shell that's sort of a hybrid between GHCi and something like bash; which lets me evaluate haskell expressions at any time in a GHCi-similar fashion eg. by prefixing with “> ” LHS-style
12:25:48 <nand`> and maybe use them inside larger expressions the way $() works in bash
12:27:08 <nand`> what about shells not only written in Haskell but basically tied into haskell itself? like a set of (... -> IO ()) functions that work well with GHCi to emulate a comfortable environment; the only problem I see with this is the inevitability of lots of strings
12:27:54 <nand`> but a set of syntactic sugar that transforms “convenient representations” to their haskell counterparts might work well
12:27:59 <nand`> again a step towards a type-safe shell
12:28:27 <geekosaur> there's already some packages in that direction on hackage, I believe
12:29:43 <DanBurton> Will these Char hacks work like I think they will for implementing a brainfuck interpreter? https://github.com/DanBurton/bf-interp/blob/master/Tape.hs
12:29:52 <DanBurton> I'm running into trouble and I'm not sure where the problem is
12:33:41 <nand`> DanBurton: why not use Word8 instead of Char?
12:33:48 <nand`> > (255 :: Word8) + 1
12:33:50 <lambdabot>   0
12:35:06 <nand`> DanBurton: also note that your implementation won't wrap around eg. for left (Tape [] _ _)
12:35:22 <nand`> which I believe is in the brainfuck specification, but I'm not sure
12:37:26 <shapr> nand`: Actually, House is still somewhat being developed as LightHouse
12:42:29 <rasfar> not sure what the current status is, but linspire was committed to the use of Haskell for systems programming
12:42:32 * chrisdone pounces on shapr
12:42:38 <shapr> howdy chrisdone!
12:43:10 <shapr> I just upgraded both desktop and laptop to Ubuntu 12.04, and got xmonad installed on my desktop. I'm not upgrading emacs libs.
12:43:13 <shapr> er NOW
12:43:31 <chrisdone> <burns>excellent</burns>
12:43:49 <shapr> chrisdone: Do you use magit?
12:43:55 <chrisdone> i do indeed!
12:44:26 <shapr> Ok, I'll stick with that one then.
12:44:38 <chrisdone> heh? :D
12:45:01 <chrisdone> i never tried anything else but for sure i love magit
12:45:07 <shapr> I took a quick poll and magit seems most popular.
12:45:13 <chrisdone> ah okies
12:45:45 <rasfar> there was also just talk about http://www.idris-lang.org on #blah
12:46:16 <DanBurton> nand`: I just used Char for the sake of putChar and getChar
12:46:56 <nand`> DanBurton: not like you can't just define your own versions of those that return a Word8
12:47:04 <yan_> is it wrong to think of a monoid as absolutely anything that can accumulate anything else?
12:47:15 <DanBurton> indeed
12:47:18 <DanBurton> @nand
12:47:19 <lambdabot> parse error (possibly incorrect indentation)
12:47:21 <byorgey> yan_: yes, that doesn't really make sense
12:47:38 <nand`> yan_: monoid = anything with an associative dyadic operator that has an identity element
12:47:55 <yan_> byorgey: ahh so 'accumulation' is only one operation
12:48:02 <shapr> So like, + is a monoid on integers, right?
12:48:13 <byorgey> shapr: along with 0, yes
12:48:17 <ismail> hey guys! whats the name of a good irc server i can connect with my chatzilla?
12:48:19 <nand`> integers build a monoid over (+, 0)
12:48:22 <yan_> byorgey: oh hey, you wrote typeclassopedia, right?
12:48:25 <nand`> they also build a monoid over (*, 1)
12:48:27 <byorgey> yan_: yes, I did
12:48:42 <yan_> cool! loved reading it, thank you
12:48:59 <shapr> Monoids get especially interesting when you have a bunch of cores or a bunch of separate systems and you can distribute a monoidal calculation across them.
12:49:03 <byorgey> yan_: well, it's more that 'accumulation' is rather vague.  What exactly does it mean?
12:49:08 <byorgey> yan_: thanks, glad you enjoyed it!
12:49:20 <shapr> byorgey++ -- for being awesome
12:49:25 <nand`> shapr: aka foldMap
12:49:29 <byorgey> shapr: thanks!
12:49:34 <nand`> (if that's the function I'm thinking of)
12:49:36 <nand`> :t foldMap
12:49:37 <lambdabot> Not in scope: `foldMap'
12:49:39 <nand`> hmm
12:49:41 <byorgey> shapr: and good point re: parallelization.
12:49:52 <nand`> ah yes, it is
12:50:14 <byorgey> it's funny, I was just writing something about semigroups and monoids and then flipped over to #haskell to see yan_'s question =)
12:50:18 <shapr> byorgey: But, they are equally interesting when you want do incremental parsing, for obvious reasons.
12:50:41 <ismail> hey guys. i entered this channel via the site tryhaskell.org. But i installed now chatzilla. Now i need the name of a server which i can connect to. Can someone plz tell me a server name which is good for joining haskell channel?
12:50:44 <DanBurton> Oh. My. Gosh. I finally realized what I did wrong, and it is the stupidest thing ever T_T just had to change `loopControl = branch is0` to `loopControl = branch (not <$> is0)` *facepalm*
12:50:51 <shapr> yan_: Are you building up to monads, or are you just wondering what you can do with monoids?
12:50:57 <zomg> ismail: this one :P
12:50:57 <nand`> shapr: you might be interested to note that any set of data that can be processed with both a left fold and a right fold is proven to be possible with an associative combinator, which smells monoid
12:51:01 <shapr> ismail: I think you got here.
12:51:03 <byorgey> shapr: indeed.  And note that all you really need for parallelization or incremental parsing is a semigroup.
12:51:05 <yan_> byorgey: the way i'm thinking of it is i'd use a monoid whenever a collection of operations produce an intermediate result that needs to be folded into a final value.. i realize that's one use for it but it's just how i look at their raison d'etre
12:51:16 <yan_> shapr: more of the latter
12:51:17 <shapr> Oh really?
12:51:22 <ismail> what is the name of this server?
12:51:29 <yan_> shapr: just wrapping my head around different type classes + concepts
12:51:33 <zomg> ismail: irc.freenode.net
12:51:37 <shapr> byorgey: Oh that makes sense!
12:51:43 <ismail> zomg: thank you!
12:51:43 <shapr> You don't require an identity.
12:51:46 <byorgey> shapr: it's the associativity that's the really important bit.  Having an identity element can be nice, but it's not required.
12:52:03 <nand`> DanBurton: this is one of those moments in which haskell shines. Your implementation was fine all along, it's just a logic error - no subtle bugs :P
12:52:13 <shapr> I wish we could make up commutative monads somehow.
12:52:18 <byorgey> I used to think it wasn't really that important of a distinction, but I have been coming across more and more things that are semigroups but not monoids.
12:52:21 <nand`> shapr: MonadPlus?
12:52:35 <ismail> cu later
12:52:37 <shapr> nand`: Does that allow for commutative 'execution' ?
12:52:41 <nand`> oh, commutative
12:52:41 <byorgey> and I've actually wasted time trying to shoehorn them into Monoid  =)
12:52:42 <shapr> ismail: Come back and see us!
12:52:42 <shapr> aww
12:52:43 <nand`> nvm
12:52:46 <nand`> mplus is associative
12:53:11 <shapr> In some ways monads over-sequence.
12:53:30 <shapr> byorgey: Like what? Got any good examples of interesting semigroups?
12:54:21 <nand`> lists
12:54:22 <byorgey> shapr: sure.  bounding boxes, for one.
12:54:25 <S11001001> non-empty list
12:54:26 <nand`> then again, they're monoids as well
12:54:50 <shapr> I keep forgetting chrisdone lives in an entirely different time zone.
12:55:10 <ismail6> Hey guys. I have a list of type [(Int,Int,Int)], how can i sort this list with respect to the first element?
12:55:27 <tromp_> :t sortBy
12:55:27 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
12:55:28 <byorgey> shapr: in fact, most of the interesting examples I know of are some sort of variation on the theme of "finite bounds"
12:55:30 <nand`> sortBy (comparing $ \(a, _, _) -> a)
12:55:34 <byorgey> but that seems to come up repeatedly for me.
12:55:52 <tromp_> :t comparing
12:55:53 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
12:56:00 <shapr> byorgey: This sounds like a blog post, have you already written it?
12:56:18 <tromp_> @hoogle  \(a, b,c_) -> a
12:56:18 <lambdabot> Parse error:
12:56:18 <lambdabot>   \(a, b,c_) -> a
12:56:18 <lambdabot>   ^
12:56:22 <tromp_> @hoogle  \(a, b,c) -> a
12:56:23 <lambdabot> Parse error:
12:56:23 <lambdabot>   \(a, b,c) -> a
12:56:23 <lambdabot>   ^
12:56:28 <nand`> it's a little bit easier for [(Int, Int)] which is just sortBy (comparing fst); but there's no general purpose “fst3 :: (a, b, c) -> a”
12:56:31 <byorgey> shapr: heh, no, I haven't, but you're right that I need to write it up one way or another.
12:56:31 <nand`> @hoogle (a, b, c) -> a
12:56:32 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
12:56:32 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
12:56:56 <nand`> note that I usually define “fst3”, along with “snd3” and “thd3” when I need it
12:56:56 <shapr> byorgey: I'd certainly be interested.
12:57:00 <byorgey> shapr: I'm currently sorting out a bunch of thoughts related to diagrams etc., which will turn into some papers and/or blog posts.
12:59:16 <nand`> What's the name for a monoid that also has an operation (inv :: a -> a) satisfying (x `mappend` inv x == mzero) for all x?
12:59:21 <nand`> Was that just an algebraic ring?
12:59:31 <opqdonut> that's a group
12:59:35 <shapr> byorgey: Anything you can discuss right now?
12:59:44 <shapr> byorgey: Or will that prevent you from publishing later?
12:59:53 <byorgey> shapr: no, I can discuss any of it now
13:00:15 <shapr> So, how are bounding boxes semigroups?
13:00:32 <luite> shapr: he's still going to bed pretty early :)
13:01:10 <byorgey> shapr: so a bounding box is a pair of coordinates (x1,y1) (x2,y2) with x1 <= x2  and y1 <= y2
13:01:49 <byorgey> shapr: the composition of two bounding boxes is the smallest box which contains both, which you can compute just by taking the min of the x1's and y1's, and the max of the x2's and y2's
13:02:15 <byorgey> it's not hard to see that this is associative, because max and min are associative.
13:03:03 <byorgey> but there's no identity bounding box -- for the same reason that the real numbers (or integers or...) only form a semigroup, not monoid, under max and min
13:04:22 <byorgey> shapr: does that make sense?
13:04:59 <JoeyA> > [max 0 (max (0/0) (1/0)), max (max 0 (0/0)) (1/0)]
13:05:00 <lambdabot>   [0.0,Infinity]
13:05:02 <shapr> byorgey: That's really cool.
13:05:08 <nand`> doesn't even need to be two-dimensional
13:05:13 <nand`> ranges are semigroups as well
13:05:18 <JoeyA> @quote 1394
13:05:19 <lambdabot> No quotes match. Where did you learn to type?
13:05:24 <byorgey> indeed, bounding boxes easily generalize to any number of dimensions
13:05:27 <JoeyA> @quote IEEE
13:05:27 <lambdabot> dmwit says: For basically all good properties P, IEEE 754 is not P.
13:05:45 <flixil> Hello, I'm trying to solve the EulerProblem #6 but the code doesn't compile. http://paste2.org/p/2024379  I'm trying to keep it generic and not polute the function finalVersion with magic numbers like 1 or 100.
13:06:25 <byorgey> shapr: however, if you want a monoid but you only have a semigroup, you can always simply add an extra special element which acts as the identity
13:06:38 <shapr> Why would you want that?
13:06:48 <flixil> Could I get a tip on how to square the sum of the possible infinite list ns? How can I tell haskell that the list is not gonna be infinite?
13:07:04 <rwbarton> flixil: you forgot a "sum"
13:07:13 <rwbarton> your sumOfSquares is a list
13:07:35 <byorgey> shapr: well, going back to the bounding box example, if you're using them to bound some sort of geometric primitives which you can combine, you might want some sort of "null/empty primitive"
13:07:41 <flixil> rwbarton: ohh i was looking on my mistake on somewhere completly different
13:07:49 <flixil> I was confused with the error message :) thanks a lot
13:08:14 <nand`> you could also write map (^2) ns to make it more readable and elegant at the same time :)
13:08:38 <byorgey> also, this example is not hypothetical at all =)
13:08:50 <byorgey> except that diagrams uses something more sophisticated and cool than bounding boxes.
13:09:48 <shapr> What does it use?
13:10:49 <byorgey> the basic idea is to have a function which takes as input a direction (i.e. vector) and tells you "how far you have to go" in that direction to reach the "boundary" of the diagram
13:10:52 <nand`> flixil: if you're beginning haskell it might help for now to include the type signatures for every definition, which would have likely showed you where the error “actually” occured
13:10:55 <byorgey> you can read about it here: http://hackage.haskell.org/packages/archive/diagrams-core/0.5.0.1/doc/html/Graphics-Rendering-Diagrams-Envelope.html
13:11:11 <nand`> since otherwise haskell will infer a type that has nothing to do with the type you expect for it, and subsequently the error will be somewhere entirely else
13:11:24 <nand`> but if you tell haskell what the type *should* be it will complain right away if it infers something different
13:11:34 <jix> byorgey: I guess they have to be convex?
13:11:45 <byorgey> jix: yes, they are necessarily convex
13:12:05 <nand`> flixil: also you asked “how do you tell Haskell that a list is infinite” <- you don't, if the list is infinite the resulting computation just takes infinite time to complete, nothing special about it
13:12:22 <infame> Just a question, (x:xs), x = first item, xs is the rest of the list?
13:12:31 <flixil> nand` is there something like step by step execution like in inference logic languages or procedural languages?
13:12:35 <byorgey> infame: yep
13:12:49 <infame> Alright. Thanks. :)
13:13:03 <nand`> flixil: I'm not actually sure, there might be something like step by step evaluation in GHCi, I've never really worked with its debugging tools
13:13:12 <flixil> nand`: to see how the program is executing and so on... I'm still puzzled with circular programs
13:13:25 <rwbarton> one way is to ask Cale why a program produces a particular output
13:13:32 <infame> Starting to actually like haskell. To the contrary to what I thought during the introduction to haskell <3
13:13:33 <nand`> yes, that's the best way
13:13:40 <rwbarton> and to ask him about the difference between strict and lazy evaluation
13:13:55 <infame> Haskell is like a... breath of fresh air, if you will...
13:14:02 <flixil> Who is Cale?
13:14:04 * shapr breathes deeply
13:14:07 <byorgey> infame: =)
13:14:11 <shapr> flixil: He's a helpful and smart dude who spends time here.
13:14:46 <JoeyA> @quote Cale
13:14:46 <lambdabot> Cale says: Int is a correctness-damaging premature optimisation
13:14:53 <shapr> I agree!
13:14:58 <JoeyA> @quote Cale
13:14:58 <lambdabot> Cale says: The perfect programming language is mathematics, but that only runs on mathematicians.
13:15:05 <byorgey> haha
13:15:13 <nand`> the correct type is obviously (Integral a) => a
13:15:26 <flixil> why between `  ` i can only put a function and not an expression that leads to a funtion?
13:15:42 <nand`> flixil: because it's defined that way
13:15:54 <rwbarton> it is a limitation of the syntax, imagine trying to nest ``s for example
13:15:55 <nand`> flixil: note that a `b` c = flip b a c
13:16:04 <nand`> so you can just use flip (your expression)
13:16:06 <hpc> um, no
13:16:10 <nand`> err
13:16:13 <hpc> a `b` c = b a c
13:16:13 <nand`> what am I saying
13:16:15 <infame> infix functions <3
13:16:19 <hpc> (`b` c) = flip b c
13:16:21 * nand` needs more sleep
13:16:29 <hpc> heh
13:17:06 <flixil> rwbarton: I don't see any reason for it... I was thinking of something like `f.g`
13:17:20 <nand`> it might make sense if you define nested ` to be illegal
13:17:23 <rwbarton> what about a `f `o` g` b
13:17:32 <owst> In my project's cabal file, I should be able to use an Alex-generated lexer within my test-suite section, right? I'm able to use it in my executable with no problems, but the module cannot be found in the test-suite...
13:17:56 <nand`> rwbarton: the last time this came up I suggested using the position of whitespace to determine whether it's an opening or closing `
13:18:04 <nand`> but I don't agree that's the best solution
13:18:08 <DanBurton> phew, what a wall of text. I'm putting a bounty on my SO question because I really want to learn more about Cont http://stackoverflow.com/questions/10560124/using-cont-to-acquire-values-from-the-future-and-the-past
13:18:11 <nand`> then there's `(  )`
13:18:12 <owst> I've tried adding the same other-modules and build-tools entries from my executable section.
13:18:32 <flixil> nand`: this begging looking like ascii art
13:18:39 <armlesshobo> lol
13:18:47 <JoeyA> Why not allow the $( ... ) syntax like Bash?  :-)
13:18:51 <nand`> heh
13:18:53 <JoeyA> Screw TemplateHaskell
13:19:09 <nand`> $(a) = unsafePerformIO a
13:19:13 <JoeyA> lol
13:19:16 <hpc> DanBurton: http://hpc.dyndns-web.com:8000/blog/view.cgi?id=11
13:19:27 <JoeyA> Or just use [ and ].  Nobody uses lists anymore these days.
13:20:16 <hpc> you could define $[_] in agda
13:20:18 <nand`> nah, use [ and ] and change list syntax to { } instead, more compatible with other languages
13:20:52 <S11001001> compatibility with other languages
13:20:59 <JoeyA> What other languages?  [] is fully JSON-compliant.
13:21:02 <DanBurton> hpc: thanks!
13:21:11 <nand`> well, I was thinking of languages like C or Java
13:21:16 <JoeyA> ah
13:21:19 <nand`> which use { } for list declaration if my memory serves correctly
13:21:24 <JoeyA> yup
13:21:25 <DanBurton> oh... *those* languages /glare
13:21:26 <nand`> array declaration*
13:21:38 <nand`> DanBurton: isn't that the reason haskell uses the “class” keyword?
13:21:42 <nand`> :P
13:21:51 <DanBurton>  /glare @ spj
13:21:52 <JoeyA> Structures, too: {.a = 3; .b = 4;} (don't know about Java, but C99 lets you do that)
13:22:44 <DanBurton> in any event, Haskell lists shouldn't be confused with arrays, because the representation is completely different
13:23:35 <DanBurton> though several languages use [ and ] for arrays, too
13:24:00 <DanBurton> python, ruby, javascript
13:24:50 <DanBurton> we should use pointy brackets < and > like in math
13:24:57 <Benjamin_> what would be the effect of replacing <=  with < in defination of qsort
13:25:09 <flixil> DanBurton: that looks like a vector for me
13:25:26 <nand`> aren't < > used for tuples in math?
13:25:33 <DanBurton> I suppose
13:25:34 <nand`> well, so are ( )
13:25:56 <nand`> Benjamin_: which qsort?
13:26:02 <JoeyA> OCaml uses [| 1,2,3 |] for arrays (not lists).
13:26:02 <DanBurton> Benjamin_: the difference merely determines what order things end up in that are considered the same
13:26:16 <flixil> JoeyA: that looks like a Matrix :)
13:26:25 <Benjamin_> qsort[2,2,3,1,1]
13:26:37 <nand`> if you're referencing the definition I think you are, changing < to <= would probably end up with the first element of each sequence of identical elements ending up at the end after a single pass
13:26:40 <JoeyA> Perhaps Haskell should use [1,2,3] for arrays and [|1,2,3|] for lists, since we've already flipflopped : and ::.
13:26:57 <flixil> Benjamin_: depends if you can differentiate between things you say are the same
13:26:58 <nand`> (since all <= elements get filtered out and put at the beginning)
13:27:10 <DanBurton> JoeyA: I kind of wish we would un-flip-flop : and ::
13:27:18 <nand`> and since that happens on successive passes as well, it sounds like it would reverse equal sequences
13:27:37 <JoeyA> Yeah.  When I write types on paper, :: is tedious to write.
13:27:37 * DanBurton contemplates abandoning Haskell for Idris
13:28:06 <Benjamin_> So what would qsort return when using < with qsort[2,2,3,1,1]
13:28:09 <geekosaur> lists are still the fundamental data collection in many ways; it's the functional representation of a basic loop
13:28:09 <flixil> Btw haskell circular programming reminds me of a combinational circuit with retroalimentation or neuronal webs
13:28:11 <JoeyA> I probably shouldn't write types on paper, since paper generally doesn't perform type checking.
13:28:48 <flixil> JoeyA: not even electronic paper?
13:29:16 <nand`> JoeyA: but isn't that what makes it so fun?
13:29:18 <ohgod_> hello gentlemen
13:29:19 <nand`> manual type checking
13:29:50 <Benjamin_> bye
13:29:55 <nand`> Benjamin_: [1,1,2,2,3]
13:30:05 <rwbarton> guess the quicksort wasn't quick enough
13:30:06 <DanBurton> hpc: "for all intents and purposes" - holy crap, you used this phrase correctly on the Internet! (re: the Cont link you sent)
13:30:53 <nand`> DanBurton: enlighten me, how is it possible to use that phrase incorrectly?
13:31:17 <geekosaur> the most popular mangling I see is "for all intensive purposes"
13:31:24 <geekosaur> which, ugh
13:31:26 <DanBurton> ^ that's what i meant
13:31:44 <nand`> geekosaur: oh, you're talking about things like that
13:32:03 <nand`> DanBurton rather
13:32:08 <DanBurton> I should have said "you correctly formulated that phrase"
13:32:12 <geekosaur> of course, I also had someone complain about correct use of "faze" as a "spelling mistake"... glah
13:32:45 <DanBurton> I hate English sometimes, and it's my native language
13:33:03 <shachaf> DanBurton: Are you seriously such a pedant about that phrase that you feel it necessary to point out the wrong usage of the phrase even when it's used *correctly*?
13:33:30 <nand`> DanBurton: I thought this was about using words like “irony” to represent something that has little in common with irony, or using a word such as “bemused” while thinking it means the opposite
13:33:52 <nand`> DanBurton: don't hate a language, hate its speakers
13:33:54 <danr> nand`: What does "bemused" mean?
13:34:10 <nand`> danr: “deeply thoughtful; preoccupied” or “perplexed and bewildered”
13:34:13 <shachaf> danr: The opposite.
13:34:19 <magicman> Intensive porpoises.
13:34:21 <nand`> most people seem to think it means “not amused”
13:34:26 * magicman relurks.
13:34:30 <danr> nand`: confusing indeed
13:34:32 <DanBurton> shachaf: apparently so. I have seen several misuses of the phrase, and I can't even remember the last time I saw it correctly used on the Internet.
13:35:31 <DanBurton> magicman: -___-
13:35:58 <nand`> I recall using and seeing it very often, often enough to make me wonder where you saw it being written incorrectly
13:36:20 <eacameron> I just found out about `concatMap`. What's the point of that function since you can just do `concat $ map ...` or something like that?
13:36:51 <geekosaur> @src (>>=) []
13:36:51 <lambdabot> Source not found. There are some things that I just don't know.
13:36:54 <shachaf> eacameron: It turns out to be a reasonably common combination.
13:36:59 <DanBurton> This is probably an indication of the difference in quality between the internet websites we typically read, nand` ;)
13:37:10 <shachaf> (NO POINT WHATSOEVER! THAT'S THE POINT! Ahem.)
13:37:25 <nand`> DanBurton: I'd hardly call 4chan/g/ a “quality” website
13:37:27 <geekosaur> (>>=) in the list monad is concatMap
13:37:47 <shachaf> That's probably the real reason, yes.
13:37:57 <DanBurton> flip concatMap, technically
13:38:07 <andares> geekosaur: is there a reason not to just have >>= without a synonym?
13:38:33 <shachaf> andares: There are bigger problems with the Haskell standard library than this.
13:39:02 <eacameron> shachaf: "problems"?
13:39:19 <DanBurton> I really need to get back to my Prelude replacement someday =/ I got sort of discouraged trying to break list-y functions into various typeclasses
13:39:45 <shachaf> Good -- that would be a terrible thing to do to list-y functions.
13:39:52 <JoeyA> http://codepad.org/EhOK1OtD  << Smallest program demonstrating an ambiguous type variable (unless someone can write an even smaller version!)
13:40:16 <nand`> shachaf: why? what happens when you break map/fold/whatever into Functor f =>, Foldable f => etc.?
13:40:35 <nand`> well apart from type ambituities
13:40:44 <JoeyA> The problem with generalizing all the Prelude functions is that users will end up with a lot of ambiguous types.  Haskell really needs better instance selection rules, in my opinion.
13:40:45 <shachaf> Foldable is just Tolistable.
13:40:54 <DanBurton> JoeyA: impressive
13:41:33 <DanBurton> "Haskell really needs better instance selection rules" - totally agree
13:41:47 <rwbarton> also writing (for example) 'map' instead of 'fmap' gives useful information to the reader of the code
13:41:53 <DanBurton> I'd love to be able to specify my own defaulting for typeclasses other than Num
13:42:00 <rwbarton> which is often the same person as the writer of the code, particularly when that code does not compile on the first try
13:42:01 <geekosaur> there is a lot of historical baggage in the Prelude.  often there's no point in asking why
13:42:10 <nand`> JoeyA: main=error$show[]
13:42:12 <JoeyA> Actually, main=readLn is shorter, and even complains about the monomorphism restriction.
13:42:37 <geekosaur> and the problem with this is?
13:42:50 <nand`> or main=print[]
13:43:20 <JoeyA> main=readLn is one char shorter
13:43:33 <nand`> yeah
13:43:47 <Hail_Spacecake> what is wrong with
13:43:48 <Hail_Spacecake> transform "" = ""
13:43:48 <Hail_Spacecake> transform s:sx = s : (" " ++ transform sx )
13:43:56 <Hail_Spacecake> I'm getting a parse error in pattern
13:44:06 <JoeyA> transform (s:sx)
13:44:08 <exFalso> paren
13:44:17 <JoeyA> : doesn't bind that tightly.
13:44:51 <rwbarton> "transform s" looks like a function application which binds more tightly than an operator like :
13:44:54 <exFalso> does anyone know whether there is a solaris binary bundle for 7.4.1 somewhere?
13:44:56 <Hail_Spacecake> ah
13:45:04 <Hail_Spacecake> hm
13:45:06 <rwbarton> so you get (transform s):sx = ... which is nonsense
13:45:13 <nand`> JoeyA: I like how you use $ instead of a space to give the impression of a shorter code
13:45:18 <Hail_Spacecake> now when I actually run it I get non-exhaustive patterns in function transform
13:45:31 <Hail_Spacecake> but shouldn't the first pattern matching def take care of that?
13:45:39 <JoeyA> nand`: print$error"" is shorter than print(error"")
13:45:54 <nand`> oh, wait
13:45:56 <nand`> ignore what I said
13:46:02 <Hail_Spacecake> oh
13:46:03 <Hail_Spacecake> bah
13:46:05 <nand`> in my mind “error""” looked like one parameter
13:46:18 <Hail_Spacecake> the new let in ghci threw out the old one
13:46:24 * nand` *really* needs more sleep
13:46:26 <JoeyA> '$error""' is shorter than ' undefined'
13:46:29 <Hail_Spacecake> so is there a way of defining a multiline thing like that in ghci?
13:46:38 <Hail_Spacecake> or otherwise putting all the patterns on the same line?
13:46:39 <DanBurton> exFalso: solaris and ghc 7.4.1, that's an interesting combination
13:46:50 <DanBurton> (no clue)
13:46:59 <nand`> let a True = 1; a False = 2
13:47:37 <Hail_Spacecake> thanks
13:47:38 <nand`> Hail_Spacecake: know what's even more fun? defining a data type in GHCi, then defining a function for it using let; then re-defining the data type as something else
13:47:56 * hackagebot paragon 0.1.15 - Paragon  http://hackage.haskell.org/package/paragon-0.1.15 (NiklasBroberg)
13:48:03 <JoeyA> I think having precedence rules for class instance resolution would be pretty reasonable.  We already do that for operators.
13:48:15 <JoeyA> I don't know how it'd work, though.
13:48:28 <Hail_Spacecake> nand`, that would just break that function if you tried to execute it, right?
13:48:40 <andares> hm, these 99 haskell problems seem a bit too simple.
13:50:27 <nand`> Hail_Spacecake: type mismatch
13:50:52 <nand`> “Couldn't match expected type `main::Interactive.X' with actual type `X'”
13:51:44 <nand`> Hail_Spacecake: of course it gets fun if you do it twice in a row
13:51:48 <nand`> in which case you get:
13:51:54 <nand`> “Couldn't match expected type `main::Interactive.X' with actual type `main::Interactive.X'”
13:52:11 <DanBurton> andares: have you tried the 20 intermediate problems?
13:52:29 <andares> what number are those?
13:52:38 <DanBurton> those aren't part of the 99
13:52:41 <andares> nope.
13:52:41 <DanBurton> it's a separate thing
13:52:51 <DanBurton> @google 20 intermediate haskell problems
13:52:55 <lambdabot> http://blog.tmorris.net/20-intermediate-haskell-exercises/
13:52:55 <lambdabot> Title: λ Tony’s blog λ » Blog Archive » 20 Intermediate Haskell Exercises
13:53:21 <DanBurton> that's them ^
13:53:39 <andares> … huh, cool format.
13:53:42 <andares> I'll give it a try.
13:54:37 <nand`> Fluffy sounds like Functor without any laws
13:55:24 <nand`> which is, of course, an ingenious way to show how Functor and Monad work without scary names
13:55:33 <nand`> (except for the no laws thing)
13:56:27 <nand`> I like “apple”
13:56:54 <c_wraith> `ap`ple
13:57:04 <c_wraith> (did I just give something away?)
13:57:35 <c_wraith> huh.  What's unclear about apple is what order the effects should go in.
13:57:38 <nand`> but where's the “Applicative”-similar exercise?
13:57:50 <c_wraith> There are actually two implementations of that type that are useful
13:58:33 <JoeyA> Of this type?  apple :: (Misty m) => m a -> m (a -> b) -> m b
13:58:40 <c_wraith> yes
13:59:52 <DanBurton> well, sure, one would be the ma first and then the mf, and the other would be the effects reversed
14:00:01 <c_wraith> yep
14:00:05 <copumpkin> that's why he should ask for indexed applicatives
14:00:21 <copumpkin> then the order would be in the types
14:01:07 <rwbarton> you could also execute the ma ten times, and throw out all but the third result
14:01:21 <c_wraith> rwbarton: that's less useful as a general-purpose function
14:01:28 <rwbarton> true
14:01:48 <nand`> for sake of the exercise I think the point is “find any implementation which satisfies the type and does not use magic functions like error or coerce”
14:02:03 <DanBurton> if it were (Misty m) => m a -> m (a -> a) -> m a, then you could have some real fun
14:02:09 <DanBurton> * m (a -> m a) rather
14:02:11 <rwbarton> I think you're not supposed to implement sequence as "return []" though
14:02:50 <JoeyA> Right, discarding arguments is not allowed.
14:03:00 <JoeyA> (err, should not be)
14:03:30 <DanBurton> unless there is nothing you can do with them
14:03:38 <DanBurton> e.g. Nothing >>= _
14:03:57 <rwbarton> I guess it is a good exercise in making types line up, but I feel like it overglorifies the types somewhat
14:04:03 <rwbarton> there's more to life than a type system you know :)
14:04:17 <DanBurton> are you sure you're on the right irc channel? o_O!
14:04:24 <nand`> now if it introduced laws that would be more interesting
14:04:39 <JoeyA> It's also important to know what "Fluffy" and "Misty" represent, and where they're applicable.
14:04:41 <rwbarton> I mean it's important to write the function you are trying to write rather than some other function which happens to have the same type...
14:04:53 <DanBurton> actually I think it was a great exercise for me to learn to lean more on the type system.
14:05:09 <JoeyA> This is the reason I still don't quite grasp CoMisty
14:05:18 <nand`> otherwise all of middle school comes down to “implement f :: Num a => a -> a”
14:06:11 <c_wraith> JoeyA: I think edwardk has written about CoMisty several times.  That might help you.  Or maybe not. :)
14:06:22 <edwardk> =P
14:06:41 <edwardk> what is Misty?
14:06:48 <JoeyA> http://blog.tmorris.net/20-intermediate-haskell-exercises/
14:07:02 <nand`> but I think all of edwardk's CoMisty implementations were purely on the type level
14:07:05 <nand`> so they might not help much
14:07:07 <c_wraith> aka FuzzyWarmThing
14:07:08 <JoeyA> It's a type class with methods banana :: (a -> m b) -> m a -> m b and unicorn :: a -> m a
14:07:19 <edwardk> ah
14:07:54 <edwardk> Fluffy = flipped Functor, Misty = Monad done right
14:08:08 <DanBurton> shhh
14:08:08 <edwardk> you should do class Fluffy m => Misty m where though
14:08:12 <shachaf> edwardk: I think you mean Monad done left.
14:08:15 <shachaf> (=<<)
14:08:58 <nand`> edwardk: what do you mean “flipped Functor”?
14:09:07 <edwardk> i'd move furry' out of Misty's dictionary as well
14:09:23 <edwardk> nand`: oh, i guess it isn't flipped, nevermind
14:09:40 <DanBurton> oh hey `state` is in `MonadState` now, is that new?
14:09:49 <nand`> oh okay, I was just confused thinking there was something painfully obvious I'm missing
14:10:03 <DanBurton> @type state
14:10:03 <lambdabot> forall s a. (s -> (a, s)) -> State s a
14:10:07 <edwardk> DanBurton: yeah, i added it a couple months ago
14:10:12 <DanBurton> nice
14:10:33 <edwardk> we've been trying to get it introduced since December or so, it finally managed to jump through all the hoops ;)
14:10:52 <edwardk> (actually the libraries request was first introduced like 6 months before that even)
14:12:05 <DanBurton> is it possible to eliminate liftIO in similar fashion? Or is there some reason that IO actions should just be typed directly to IO?
14:12:48 <nand`> main :: MonadIO m => m () -- doesn't make a lot of sense
14:13:08 <nand`> wait nvm, would still work
14:13:22 <nand`> since MonadIO IO is fulfilled
14:13:44 <c_wraith> DanBurton: It's hard to implement forkIO in terms of an abstract class like MonadIO
14:13:48 <JoeyA> Could state :: (s -> (a, s)) -> m a be implemented in terms of get and put?  Namely: state f = do {s <- get; let (a, s') = f s; put s'; return a}
14:14:00 <c_wraith> DanBurton: and more generically, any function that has IO arguments
14:14:07 <JoeyA> (in reference to http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-State-Class.html#v:state)
14:14:53 <edwardk> JoeyA: it is by default
14:15:06 <rwbarton> replacing all IO actions by MonadIO m => m actions is a kind of fake generalization
14:15:08 <JoeyA> Ah
14:15:14 <edwardk> JoeyA: but it can be usually be implemented more efficiently directly
14:15:28 <edwardk> JoeyA: using get and put means round tripping through the monad stack twice at least
14:15:41 <edwardk> whereas state can usually be done in one pass
14:15:59 <JoeyA> I wish MonadWriter included something like listen, which snuffs out the output of the computation rather than duplicating it.
14:16:00 <edwardk> this can mean a noticable performance increase
14:16:05 <DanBurton> it even has a lazy pattern on the match to f s, interesting
14:16:35 <edwardk> DanBurton: i don't particularly agree with that, but it was the version least likely to piss someone off
14:16:44 <hpc> edwardk: only if your stack of monads is deep as hell ;)
14:17:08 <edwardk> in particular i view the Control.Monad.Trans.*.Lazy as non monads
14:17:10 <JoeyA> Sure, you can combine listen and censor to do the same thing, but the documentation doesn't make this obvious.
14:17:30 <edwardk> this is why i removed the .Lazy and .Strict distinction in comonad-transformers.
14:17:50 <edwardk> I'll never win the war with transformers and the mtl though, so I'm letting sleeping bad ideas lie ;)
14:18:27 <JoeyA> How are *.Lazy non-monads?
14:19:04 <JoeyA> They don't follow the monadic laws due to something involving bottoms?
14:19:32 <DanBurton> I am wondering this too
14:19:44 <edwardk> JoeyA: fmap f undefined = WriterT (Identity (undefined, undefined))
14:20:16 <edwardk> it makes up a lot of structure from nothing
14:20:52 <ismail6> hello there. i installed now the haskell platform via repo with zypper. But my ghci is still loading just a few packages. How can i tell it to load more packages?
14:21:27 <DanBurton> ismail6: which packages are you missing? Does it have all of the packages that are supposed to be in the Platform?
14:21:58 <absence> is there a pattern or something that somehow avoids having to maintain and synchronise two specifications of a binary file format when using Binary.Put/Get?
14:22:29 <JoeyA> SafeCopy (though I've never used it)
14:22:47 <geekosaur> also, packages being available does not mean packages are imported by ghci at startup
14:22:58 <ismail6> DanBurton: i am missing nearly every package. I updated the repo dev_language_haskell, installed it with dup, and it took quite a lot of time. After starting ghci the "sort" function is still out of scope.
14:23:23 <rwbarton> that's because it's in the Data.List module
14:23:41 <ismail6> oh. how can i load it on startup?
14:23:49 <geekosaur> ":m +Data.List" or call it Data.List.sort
14:23:53 <absence> JoeyA: interesting
14:24:01 <geekosaur> put :m or import lines in ~/.ghci to always import them
14:24:02 <rwbarton> I guess you can add that first line to your ~/.ghci?
14:24:22 <flixil> I think i can use a let inside a list comprehension, but I don't understand why this fails after adding the floor floor and sqrt function
14:24:23 <flixil> pythagoreanTriplet =  [ (a,b,c) | a<-[1..], b<-[1..], let c=floor (sqrt(a^2 + b^2)), a^2+b^2==c^2
14:24:35 <geekosaur> ("import" requires ghc 7.4.1 or maybe 7.2.1)
14:25:20 <DanBurton> flixil: what's wrong with what you've got?
14:25:42 <geekosaur> you can;t actually use a do-like ket in a list comp that way, can you?
14:25:48 <geekosaur> well, maybe with MonadComprehensions
14:25:53 <geekosaur> er, do-like let
14:25:54 <rwbarton> yes, you can
14:25:57 <DanBurton> you can
14:26:04 <flixil> I got this long error DanBurton http://paste2.org/p/2024482
14:26:12 <rwbarton> @type floor
14:26:14 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
14:26:19 <DanBurton> > [ z | x <- [1..4], y <- [5..9], let z = x + y]
14:26:20 <lambdabot>   [6,7,8,9,10,7,8,9,10,11,8,9,10,11,12,9,10,11,12,13]
14:26:34 <geekosaur> oh.  that error does tell you the problem, somewhere down inside
14:26:45 <geekosaur>     Possible cause: the monomorphism restriction applied to the following:
14:26:56 <DanBurton> it's The Dread Monomorphism Restriction
14:27:06 <rwbarton> the real problem is you tried to take the square root of what you intended to be an integer
14:27:23 <DanBurton> @type (^)
14:27:23 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
14:27:25 <adnauseam> alo guys, how do i go read Char :: Int ?
14:27:37 <adnauseam> how do i go about reading a Char as an Int
14:27:53 <rwbarton> you can make the Char into a String
14:27:55 <flixil> DanBurton: what is the Dread Monomorphism Restriction? I mean... What is a monomorphism to begin with?
14:27:55 <rwbarton> > ['x']
14:27:57 <lambdabot>   "x"
14:28:09 <adnauseam> heh, yeah, that would work
14:28:11 <rwbarton> @hoogle digitToInt
14:28:12 <lambdabot> Data.Char digitToInt :: Char -> Int
14:28:14 <DanBurton> adnauseam: do you want '9' to be 9, or its ascii value?
14:28:16 <rwbarton> or you can use that
14:28:23 <adnauseam> '9' -> 9
14:28:31 <DanBurton> digitToInt is what you want then
14:29:00 <adnauseam> going '9' -> "9" -> 9 sounded to simple/wrong to me and i thought there's a better way
14:29:18 <absence> JoeyA: though looking at the examples it still seems like you end up with file format details in both putCopy and getCopy
14:29:21 <hpc> digitToInt is what you want
14:29:22 <adnauseam> DanBurton: i'm trying to avoid using external libs
14:29:24 <DanBurton> > let myDigitToInt = (subtract (ord '0')) . ord in myDigitToInt '9'
14:29:25 <lambdabot>   9
14:29:28 <shachaf> Note that digitToInt is unsafe.
14:29:32 <shachaf> And so is DanBurton's function.
14:29:51 <rwbarton> > digitToInt 'y'
14:29:52 <lambdabot>   *Exception: Char.digitToInt: not a digit 'y'
14:29:57 <rwbarton> looks safe to me
14:29:59 <DanBurton> adnauseam: Data.Char is in base, which I'd hardly consider external
14:30:03 <flixil> DanBurton: so with an explicit signature it should work.. I tried with pythagoreanTriplet :: [(Integer,Integer, Integer)]   with no luck
14:30:04 <shachaf> rwbarton: _|_ is safe now?
14:30:10 <rwbarton> yes
14:30:24 <geekosaur> :t (^)
14:30:25 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
14:30:28 <rwbarton> DanBurton's is unsafe though, since it produces garbage
14:30:30 <adnauseam> yeah i've got an `elem` (take 10 $ ['0' ..])
14:30:30 <shachaf> Fine, it's partial.
14:30:32 <rwbarton> on invalid input
14:30:33 <adnauseam> to cover that
14:30:48 <ismail6> geekosaur: could you tell me how to change the prompt back to something else?
14:30:58 <shachaf> rwbarton: It can also produce undefined behavior. :-)
14:31:00 <DanBurton> both are "safe" if you operate under the assumption that the function is given valid input
14:31:01 <andares> what does the type declaration ((->) t) mean?
14:31:03 <adnauseam> oh DanBurton now i see your function, thank yuo
14:31:03 <shachaf> rwbarton: However:
14:31:07 <shachaf> > digitToInt 'a'
14:31:08 <lambdabot>   10
14:31:11 <rwbarton> hmm
14:31:12 <geekosaur> ismail6, huh?
14:31:17 <DanBurton> adnauseam: that won't help you much, since ord is also in Data.Char
14:31:57 <ismail6> geekosaur: i mean its like "Prelude Data.List>" now. But i want to change the Prompt to something else. I don't need to see the loaded module.
14:32:05 <rwbarton> "digit" meaning hex digit does seem mildly surprising
14:32:13 <shachaf> ismail6: :help
14:32:23 <DanBurton> andares: ((->) in out) is the same as (in -> out)
14:32:24 <shachaf> In particular :set prompt ...
14:32:51 <DanBurton> andares: ((->) t) is partially applied at the type level
14:32:53 <ismail6> shachaf: thank you very much
14:33:02 <shachaf> :set prompt should take an IO String.
14:33:04 <companion_cube> boarf
14:33:04 <companion_cube> osef
14:33:06 <companion_cube> oops
14:33:10 <DanBurton> @kind ((->) t)
14:33:11 <lambdabot> Not in scope: type variable `t'
14:33:14 <DanBurton> @kind ((->) Int)
14:33:15 <lambdabot> ? -> *
14:33:26 <andares> DanBurton: so ((->) t) is just some function that takes in something of type t?
14:33:28 <flixil> rwbarton: is there a problem taking the square root of an Integer?
14:33:29 <shachaf> @kind ((->) ?t)
14:33:31 <lambdabot> parse error on input `?t'
14:33:36 <shachaf> No type-level ImplicitParams? :-(
14:33:52 <rwbarton> yes, you can only take the square root of things that are instances of ... Floating I think
14:33:56 <rwbarton> @type sqrt
14:33:57 <lambdabot> forall a. (Floating a) => a -> a
14:34:04 <rwbarton> because the result is again of the same type
14:34:06 <DanBurton> andares: well ((->) t) does not describe any values, because it is a type constructor. You need to give it another type, and *then* it will describe functions that take in something of type t
14:34:30 <andares> so it's like Maybe?
14:34:34 <DanBurton> precisely
14:34:45 <andares> but with its input specified.
14:34:58 <andares> so Maybe Int could be specified as ((->) Int)
14:34:59 <DanBurton> (->) takes in two types
14:35:18 <DanBurton> well not exactly
14:35:31 <andares> @kind (Maybe Int)
14:35:32 <lambdabot> *
14:35:33 <DanBurton> (->) has kind * -> * -> *, while Maybe has kind * -> *
14:35:40 <andares> huh.
14:35:57 <DanBurton> that just means -> needs two types, while Maybe only needs one
14:36:01 <andares> I thought that the first * was in and the second out.
14:37:01 <rwbarton> flixil: you can use fromInteger to convert Integer to many other types, including (here) Double
14:37:04 <rwbarton> then take sqrt
14:37:06 <rwbarton> then convert back with floor
14:37:27 <DanBurton> andares: there is ambiguity in this discussion since -> is used at both the type level and the kind level
14:37:47 <shachaf> So ambiguous. :-(
14:37:57 <DanBurton> the kind * -> * -> * means * -> (* -> *), similar to how functions are curried
14:37:58 <rwbarton> universe ambiguity
14:38:07 <shachaf> copumpkin: Why don't you use ->_1 for functions that work with Sets in Agda?
14:38:23 <copumpkin> why would I?
14:38:23 <DanBurton> so when you apply just one type to (->), you get something of kind * -> *
14:38:33 <edwardk> DanBurton: technically (->) has kind ?? -> ? -> * ;)
14:38:45 <flixil> rwbarton: yes, fromInteger did the trick :)
14:38:56 * rwbarton boxes edwardk 
14:38:58 <DanBurton> edwardk: is that a universal truth, or a ghc hack?
14:38:59 * edwardk shuts up
14:39:00 <hpc> edwardk: were you able to remember that, or did you cheat and look it up? ;)
14:39:12 <edwardk> hpc: remember, i've had to implement a kind checker
14:39:19 <hpc> ah, nice
14:39:39 <edwardk> DanBurton: depends on the compiler, there isn't a standard for the other kinds
14:39:46 <andares> DanBurton: ah, I think it's the kind level I'm working on.
14:40:13 <shachaf> copumpkin: I mean, why don't you need to?
14:40:14 <edwardk> and iirc jhc allows unboxed tuples in argument position or something like that
14:40:19 <DanBurton> in Agda or Coq, it's all the same level anyways xD
14:40:32 <copumpkin> well, you'd want two subscripts presumably, right?
14:40:40 <copumpkin> because the domain and range might live at different levels
14:40:44 <shachaf> True.
14:41:11 <shachaf> Does _->_ have a type in Agda?
14:41:27 <copumpkin> not really, no
14:42:47 <tac-tics> shachaf: A -> B in dependently typed languages is syntactic sugar for (_ : A) -> B
14:43:10 <tac-tics> shachaf: since (x : A) -> ... is a binder, you can't package it up in a section like you can in Haskell
14:43:33 <shachaf> Makes some sense.
14:44:25 <tac-tics> of course, there are ways to encode essentially the same thing
14:44:34 <tac-tics> You just have to be careful how you talk about them
14:48:07 <adnauseam> DanBurton: i'm failing at turning your let .. in into a where syntax, can you help me out ?
14:48:10 <adnauseam> myDigitToInt = (subtract (ord '0')) . ord in myDigitToInt '9'
14:48:26 <adnauseam> i tried where myDigitToInt = (subtract (ord '0'))  but it fails
14:48:28 <rwbarton> couldn't you write something like A -> (A -> Set) -> Set
14:48:52 <rwbarton> er
14:48:58 <rwbarton> (A : Set) -> (A -> Set) -> Set
14:49:10 <rwbarton> modulo universe worries
14:49:17 <copumpkin> yeah
14:49:32 <copumpkin> then you'd need to take universe levels into account
14:49:32 <shachaf> Do people write point-free types?
14:49:38 <copumpkin> and the fact that the first Set can itself be a universe level
14:49:50 <rwbarton> okay
14:49:51 <copumpkin> but yeah, that'd be correct
14:49:59 <copumpkin> it's also the type of Sigma, conveniently enough
14:50:31 <kallisti> shapr: so filesystem-trees is on Hackage now.
14:50:42 <shapr> yay!
14:51:14 <adnauseam> shouldn't ( where myDigitToInt a = (subtract (ord '0')) . ord a ) work ?
14:51:57 <c_wraith> adnauseam: no, ord a isn't a function
14:52:15 <kallisti> shapr: I suspect it'll only take a few days before huge terrible bugs are discovered
14:52:24 <shapr> Well, that's why you publish code :-)
14:52:39 <kallisti> it is? I thought you made the code stable before release?
14:52:54 <kallisti> I have a lot to learn about software development.
14:53:05 <jonaskoelker> adnauseam, c_wraith: there is an equivalent to 'ord' with a different name, though
14:53:57 <adnauseam> jonaskoelker: Ord ? o_0
14:54:05 <jonaskoelker> no, fromEnum
14:54:21 <adnauseam> wooh, i'll try it
14:54:36 <shapr> kallisti: Who makes code stable before release?
14:54:58 <adnauseam> jonaskoelker: getting other errors with it :/
14:55:10 <jonaskoelker> adnauseam: what's the precedence of (.) vs. function application?
14:55:14 <adnauseam> it's way too frustrating to do this while half dead.
14:55:15 <kallisti> shapr: I thought that was the goal anyway
14:55:30 <jonaskoelker> adnauseam: half dead?  Sick, hung over, sleepy?
14:56:01 <shachaf> jonaskoelker: Function application is the third-stickiest thing in Haskell syntax.
14:56:06 <adnauseam> sick and awake since 7am, have had 4 courses today as well
14:56:08 <shachaf> After record syntax.
14:56:11 <adnauseam> it's nearly midnight
14:56:29 <jonaskoelker> adnauseam: then we're timezone buddies :)
14:56:34 <kallisti> shapr: wait what's the first stickiest..
14:56:44 <jonaskoelker> glue
14:56:44 <adnauseam> hallo hallo mein freund:}
14:56:53 <jonaskoelker> hej oppe nordfra :D
14:57:00 <adnauseam> nederland!
14:57:02 <kallisti> shapr: did you ever start that playlist thing?
14:57:02 <adnauseam> :o
14:57:06 <c_wraith> record update and (in patterns only), @ bindings
14:57:17 <kallisti> oh right
14:57:19 <geekosaur> ord is a function.  ord a is not a function.  translation:  "ord a" doesn't combine with the "." operator, which wants something whose type is a function
14:58:08 <jonaskoelker> ($\in$ dk)
14:58:09 <adnauseam> hmm, i think i'm starting to understand
14:58:42 <jonaskoelker> adnauseam: newly converted to the light side of the force? ;-)
14:59:07 <adnauseam> jonaskoelker: 2 month old noob ;p
14:59:26 <jonaskoelker> enjoy the ride :)
14:59:31 <adnauseam> i'm starting to love haskell
14:59:45 <armlesshobo> so, for composition ',' would f . g . h = f(g(h))?
15:00:00 <jonaskoelker> soundsa boot rite
15:00:07 <adnauseam> and i'm starting to garner hate toward my professors, they're teaching us haskell with scheme examples
15:00:16 <jonaskoelker> o_O
15:00:19 <adnauseam> i know...
15:00:26 <armlesshobo> that's like a close but no cigar situation
15:00:28 <armlesshobo> lol
15:00:55 <jonaskoelker> (lambda (mylist) (let (x (head mylist)) (xs (tail mylist)) ...))
15:01:03 <adnauseam> *wrists*
15:01:04 <adnauseam> =/
15:01:34 <Peaker> \(x:xs) -> ...
15:01:38 <ohgod_> ..
15:01:46 <jonaskoelker> $
15:02:07 <shachaf> adnauseam: You know, if you want to learn Haskell, and you don't like how your professors are doing it, you can just do it without them. :-)
15:02:10 <jonaskoelker> (mapcar fromInteger xs)
15:02:15 <shachaf> Much more productive than hating them.
15:02:21 <owst> Should I be able to use a alex-generated module in a test-suite section of a .cabal file?
15:02:40 <owst> Or rather, in my test-suite, should I be able to test my Lexer?
15:02:49 <ismail6> Is there a module for Combinatory Logic?
15:03:52 <adnauseam> shachaf: i am doing just that- it's just frustraing having 8 hours of that a week
15:04:46 <jonaskoelker> (bad pun alert) while variable naming conventions are good, it's not ys to apply them to an xs
15:05:27 <mogz> ahah
15:05:40 <adnauseam> hah *looks awkwardly around*
15:05:45 <adnauseam> >.>
15:05:45 <jonaskoelker> :D
15:06:00 <jonaskoelker> sorry
15:06:03 <adnauseam> =D
15:06:10 <Peaker> I don't get the "an xs" part. (axis?)
15:06:13 <jonaskoelker> an excess
15:06:20 <Peaker> oh, silly me :)
15:06:45 <jonaskoelker> I thought that was my job
15:06:50 <jonaskoelker> being silly
15:06:52 <adnauseam> oh motherf... ord is in Data.Char
15:06:55 <adnauseam> goddamnmit
15:07:13 <armlesshobo> so, when a function pattern looks like "foo [bar] = ..." does [bar] match a list with a size of at least 1?
15:07:15 <geekosaur> that was already mentioned
15:07:20 <hpc> armlesshobo: exactly one
15:07:20 <adnauseam> hmm...
15:07:23 <geekosaur> so why do you need to only use Prelude?
15:07:25 <jonaskoelker> we should go ahead and create letmehooglethatforyou.com :-)
15:07:32 <mogz> [x] is syntactic sugar for x:[]
15:07:33 <armlesshobo> hpc: oooh. exactly one. ok.
15:07:35 <mogz> so exactly one y
15:07:42 <armlesshobo> so
15:08:04 <armlesshobo> so, in "foo (a) = ...", (a) is a list of at least one?
15:08:08 <geekosaur> anyway if you really can't use anything outside the Prelude, try toEnum
15:08:13 <adnauseam> geekosaur: i'm just stretching my own muscles - i know one shouldn't reinevent the wheel, i'd still like to know what's it made of. i promise to import everything else after this.
15:08:25 <adnauseam> stretching\flexing
15:08:26 <kallisti> armlesshobo: no. parentheses have no special meaning other than to group patterns
15:08:31 <mogz> nah, a is a variable
15:08:35 <geekosaur> but you may need to specify the type in that case
15:08:36 <kallisti> a will match anything
15:08:37 <Gwern-away> > 7.8 - 5.2 / 3
15:08:38 <lambdabot>   6.066666666666666
15:08:39 <kallisti> of the correct type.
15:08:44 <jonaskoelker> armlesshobo: no, but in "foo as@(a:atail) = ...", as is a list of at least one element
15:08:47 <Gwern-away> CURSE YOU PEMDAS
15:08:49 <Gwern-away> > (7.8 - 5.2) / 3
15:08:50 <lambdabot>   0.8666666666666666
15:08:51 <kallisti> to match a list of at least one element, you would use:   (x:xs)
15:09:14 <jonaskoelker> Gwern-away: the dalai lama would admire your calmness :P
15:09:43 <Gwern-away> jonaskoelker: the dalai lama counsels not seeking vengeance - but he has not suffered as I have under the tyrrany of PEMDAS
15:10:03 <jonaskoelker> Gwern-away: ever thought about going lisp?
15:10:06 <jonaskoelker> ;)
15:10:16 <adnauseam> what if...
15:10:23 <jonaskoelker> then else...
15:10:29 <Gwern-away> jonaskoelker: you might as well ask me if I've ever thought about going to anal sex
15:10:38 <Gwern-away> it's just perverted and I'm obviously not into that
15:10:49 <Gwern-away> no offense to any fags here
15:11:26 <adnauseam> i do: read ((\xs -> head xs : []) xs) :: Integer :o
15:11:27 <jonaskoelker> Gwern-away: I once heard this one---saying 'java is great because it runs everywhere' is like saying anal sex is great because it works on both genders
15:11:44 <Gwern-away> (so did I)
15:12:11 <jonaskoelker> do you recall where?  paulgraham.com?  javasucks.com?
15:12:23 <ben> what's wrong with anal sex?
15:12:24 <adnauseam> IT WORKS
15:12:24 <Gwern-away> no
15:12:27 <adnauseam>  ithink....
15:12:28 <nand`> “java runs everywhere.. except when your JVM has the wrong vendor string”
15:12:33 <jonaskoelker> :D
15:12:48 <adnauseam> oh shit
15:12:53 <jonaskoelker> ben: nothing except for personal antipreference
15:13:00 <adnauseam> i don't know if :: Int will work a function
15:13:07 <jonaskoelker> somewhat commonly held, I think
15:13:12 <ben> so there's nothing wrong with java except for personal antipreference? i'm not a fan of this metaphor
15:13:14 <jonaskoelker> work that function, baby...
15:13:28 <alpounet> ben, nothing. but saying it's good just because it works on all genders seems pretty flawed
15:14:31 <adnauseam> would (read ((\x -> head x : []) xs) :: Int) work inside a function in file ?
15:14:43 <adnauseam> well. no
15:15:37 <jonaskoelker> you can put type signatures onto any value you like, and as long as you match up the parens correctly you should be good
15:16:08 <jonaskoelker> (by correctly, I don't actually mean correctly, I probably tend to put them unnecessarily, but just sprinkle and experiment with removal)
15:18:56 <jonaskoelker> m3ga: mega-nerd.net? :D
15:19:42 <m3ga> jonaskoelker: yes
15:19:51 <jonaskoelker> awesome domain name
15:20:06 <m3ga> also have mega-nerd.com :-)
15:20:28 <jonaskoelker> and mega-nerd.biz? :-P
15:20:50 <m3ga> no, but it do wish i got giga-geek.(com|net)
15:21:16 * jonaskoelker runs for tera-dork.net
15:21:45 <hpc> yotta-doofus.gov
15:21:52 <adnauseam> now i got  myToInteger ys = (read ((\x -> head x : []) ys)) :: Integer in a where claus
15:22:00 <adnauseam> and i've tested it, and it should work
15:22:10 <nand`> huh, http://monad.com
15:22:16 <m3ga> jonaskoelker: you're in .dk. i'll be visiting .dk for icfp :-)
15:22:17 * tac-tics enjoys http://tac-tics.net
15:22:18 <adnauseam> it's bitching about this one though head xs  `elem` (take 10 ['0' ..]) = myToInteger xs * m $ tail xs
15:22:31 <jonaskoelker> cool; when/where?
15:22:35 <adnauseam> saying it doesn't match Integer with [Char] -> Integer
15:22:36 <adnauseam> what.
15:22:37 <adnauseam> why.
15:22:46 <m3ga> jonaskoelker: around sept 15
15:22:59 <jonaskoelker> I'll be outta' school by then
15:23:08 <jonaskoelker> if I'm lucky :)
15:24:03 <mm_freak> the RTS is written in C, right?
15:24:17 <nand`> adnauseam: is it just me or is that an awfully complex way of saying read [head ys] ?
15:24:31 <adnauseam> SUCCESS HAHA
15:24:38 <mauke> (take 1 ys)
15:24:45 <adnauseam> i know it could be cleaner dude
15:24:51 <adnauseam> but i've got a fever
15:24:53 <adnauseam> :/
15:25:04 <nand`> myToInteger = read . take 1
15:25:35 <adnauseam> the function is supposed to read digits in a string and give their product
15:26:06 <mauke> > digitToInt '1'
15:26:07 <lambdabot>   1
15:26:13 <nand`> > product . map (read . return) $ "12345"
15:26:15 <lambdabot>   120
15:26:29 <adnauseam> yes but
15:26:30 <mauke> > product . map digitToInt $ "12345"
15:26:32 <lambdabot>   120
15:26:45 <adnauseam> > product . map (read . return) $ " here be numbers 12345"
15:26:46 <lambdabot>   *Exception: Prelude.read: no parse
15:26:58 <adnauseam> i needed to extract digits
15:27:02 <adnauseam> from a string
15:27:07 <nand`> > concatMap (Product . digitToInt) "12345"
15:27:08 <lambdabot>   Couldn't match expected type `[b]'
15:27:08 <lambdabot>         against inferred type `Data.Mono...
15:27:09 <adnauseam> then gief back products
15:27:16 <mauke> > product . map digitToInt . filter isDigit $ " here be numbers 12345"
15:27:18 <lambdabot>   120
15:27:20 <nand`> oh
15:27:27 <adnauseam> digit to int is in an external function, i wanted to only use prelude
15:27:38 <nand`> > foldMap (Product . digitToInt) "12345"
15:27:39 <lambdabot>   Not in scope: `foldMap'
15:27:39 <mauke> adnauseam: prelude is external
15:27:44 <nand`> blast
15:27:48 <adnauseam> mauke dude don't mess me up even more :p
15:28:13 <nand`> return is prelude so is read
15:28:15 <nand`> iirc
15:30:39 <adnauseam> nand`: all i know is that it works. this sonvabeach works
15:30:55 <adnauseam> i shal declare success, and move on to the next exercise
15:31:05 <hpc> :t foldMap
15:31:06 <lambdabot> Not in scope: `foldMap'
15:31:18 <nand`> > digitToInt 'a'
15:31:19 <lambdabot>   10
15:31:26 <nand`> oh I see what it did there
15:31:30 <nand`> > digitToInt 'z'
15:31:31 <lambdabot>   *Exception: Char.digitToInt: not a digit 'z'
15:31:54 <hpc> > map digitToInt "0123456789abcdefghijkl"
15:31:55 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,*Exception: Char.digitToInt: not a d...
15:32:45 <nand`> @hoogle foldMap
15:32:45 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
15:32:45 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
15:34:01 <nand`> does Base64 include the capital alphabet before the lower case alphabet?
15:34:02 <adnauseam> here's what i've got : http://pastebin.com/kxCGabe6
15:34:04 <mauke> The paste kxCGabe6 has been copied to http://hpaste.org/68554
15:34:07 <nand`> otherwise that would be a nice little expansion
15:34:42 <nand`> oh, it works completely differently
15:34:44 <nand`> A is 0
15:35:05 <nand`> and 0 is 52 (obviously)
15:35:31 <chavezgu_> is "Learn you a haskell" a good book to learn haskell?
15:35:38 <nand`> it's a good book to learn you a haskell
15:36:44 <adnauseam> it's a very good book
15:37:07 <flixil> for a greater good
15:37:16 <hpc> for great good, even
15:38:18 <flixil> The pics are very entertaining
15:39:58 <chavezgu_> ok, thanks :)
15:40:12 <hpaste> nand` annotated “pastebin.com/kxCGabe6” with “pastebin.com/kxCGabe6 (annotation)” at http://hpaste.org/68554#a68555
15:40:17 <chavezgu_> xmonad got me into learning haskell
15:41:18 <nand`> learning haskell got me into xmonad
15:41:50 <hpc> learning xmonad got me into not using X11
15:42:21 <nand`> hpc: what do you use instead?
15:42:30 <hpc> nand`: bare terminal
15:42:43 <hpc> and ssh from windows... :P
15:45:48 <rasfar> you can use xmonad natively on windows? or you quit using xmonad altogether?
15:46:38 <mm_freak> i can see how one could hate X11, but i don't exactly see the improvement in going to windows instead
15:47:03 <hpc> mm_freak: the issue was level of effort to get it to look like something more recent than an Apple II
15:47:53 <mm_freak> that's why i don't use xmonad
15:47:56 <mm_freak> i use compiz =)
15:48:00 <nand`> rasfar: you can use xmonad natively on windows :)
15:48:03 <hpc> heh
15:48:19 <nand`> XMing is an X11 server for Windows; not sure if it needs SUA to run or not
15:48:33 <nand`> also not sure if xmonad needs some .POSIX; if it does just grab the native POSIX implementation for windows (aka SUA)
15:48:43 <hpc> nand`: don't think so
15:49:06 <hpc> but it's been a while since i have had to install it
15:49:32 <hpc> oh, SUA is a posix thing
15:49:34 <hpc> definitely not
15:51:28 <rasfar> ah right XMing, no need for VM then
15:53:11 <rasfar> i'm with Cale in not caring for tiling WM's; surprised xmonad hasn't been generalised to suit other tastes.
15:55:01 <chavezgu_> mm_freak: but you can use xmonad in kde or gnome
15:55:10 <chavezgu_> kde looks pretty to me.
15:59:39 <rasfar> any plans for compizity with xmonad?
16:03:52 <mm_freak> chavezgu_: i really want compiz for some of its nice features
16:04:10 <mm_freak> compiz is not only about eye candy…  it's actually useful
16:04:23 <nand`> I thought compiz was all about spinning cubes
16:04:46 <mm_freak> nand`: that's just an effect…  compiz is very keyboard-friendly
16:04:59 <nand`> interesting
16:05:10 <nand`> so is xmonad :)
16:05:41 <mm_freak> sure, but i just can't get comfortable with a tiling WM…  also i'd miss the eye candy =)
16:05:54 <nand`> yes, that's the most important bit :)
16:06:44 <mm_freak> if i ever figure out how to write compositing window managers in haskell i will probably write my own =)
16:06:47 <hpc> i think i could get back into linux desktops if there existed a WM/DE that was configurable, and had a "send-to-back" shortcut i could bind to alt+esc
16:06:59 <rasfar> presentation is important; we're visual-oriented!
16:07:02 <hpc> and ran on an older system
16:07:06 <mm_freak> hpc: KDE is very flexible
16:07:10 <hpc> without looking like terribleness
16:07:29 <nand`> hpc: xmonad should be able to trivially do that
16:07:40 <nand`> but then again, tiling
16:07:43 <hpc> nand`: and easy to install :P
16:07:53 <mm_freak> i'm using it, although i'm not really exhausting its capabilities…  most of what i need is provided by the combination of urxvt, zsh, compiz and emacs
16:07:58 <nand`> “emerge xmonad” && echo 'exec xmonad' >> ~/.xinitrc
16:08:03 <hpc> last i tried it exploded in my face
16:08:11 <nand`> move the ” to the end
16:08:12 <hpc> and it's hard to configure, at least for me
16:08:45 <nand`> the problem with xmonad is incredible amounts of boilerplate in the “configuration file”
16:08:49 <mm_freak> after all most of what i do happens in the terminal, in emacs or in firefox =)
16:08:49 <Ke> perhaps one should use .xsession instead of .xinitrc
16:08:56 <Ke> especially on gentoo
16:08:58 <nand`> mostly due to clunky list comprehensions on lists of tuples
16:09:25 <nand`> I've never heard of .xsession
16:09:49 <Ke> it's the "custom X session" in login manager menu
16:09:59 <nand`> mm_freak: if you're a heavy keyboard user you'll love pentadactyl, which you probably already use :P
16:10:03 <mm_freak> you choice of whatever .x* file you use depends on the display manager rather than the distribution
16:10:07 <nand`> Ke: I see. I don't have a login manager
16:10:14 <mm_freak> nand`: never heard of it
16:10:23 <nand`> mm_freak: do you know vimperator?
16:10:33 <mm_freak> nand`: yes
16:10:46 <nand`> pentadactyl is a fork with slightly more vim-closeness and better programmability
16:10:56 <nand`> I've never used vimperator personally, but I love pentadactyl
16:11:01 <mm_freak> well, i really prefer the emacs way of editing
16:11:05 <nand`> it makes the entire firefox Gtk UI obsolete
16:11:11 <nand`> or whatever UI that is
16:11:27 <gwern> @quote
16:11:28 <lambdabot> JelloBiafra: says: The conveniences you demanded are now mandatory.
16:11:33 <mm_freak> and i've only found one emacs extension for firefox, which i didn't really like
16:11:35 <nand`> is it Gtk or Qt? Or something entirely different? I keep forgetting; irrelevant - it renders the entire firefox UI obsolete except for the pentadactyl console
16:11:46 <mm_freak> btw, firefox can be used with a keyboard just fine…  i seldomly need the mouse
16:12:00 <nand`> mm_freak: firefox has some amounts of keyboard interaction out of the box, but that's only for very basic navigation
16:12:18 <nand`> you can't, for example, control focus or copy a link's target address or zoom in on an image etc. easily
16:12:22 <mm_freak> nand`: not at all…  as said, i'm using the keyboard almost exclusively
16:12:34 <mm_freak> you can =)
16:12:52 <rasfar> At top level it must be Gtk since it had the annoying little tab at the bottom-right, and the vanishing scrollbars, in recent editions.
16:12:57 <nand`> out of the box? how do you, say, focus the contents of an iframe?
16:12:57 <mm_freak> people are compelled to use context menus with the mouse…  i use them with the keyboard
16:13:20 <nand`> rasfar: I think it's gtk because browser.display.use_system_colors uses Gtk colors
16:13:21 <rasfar> (or i may be forgetting; managed to get rid of both of those some time ago)
16:13:31 <mm_freak> nand`: "focus"?
16:13:45 <nand`> mm_freak: I actually do that too, with the handy little “show context menu” button - I only use it for NoScript, because that doesn't have a pentadactyl command
16:13:58 <mm_freak> nand`: tell me what you want to achieve, not how i would execute your way of achieving it ;)
16:13:58 <nand`> mm_freak: eh, say you want to scroll down inside an iframe, but not the rest of the page
16:14:03 <nand`> eg.*
16:14:05 <adnauseam> what's the chat channel called ?
16:14:18 <adnauseam> #haskell-chat ?
16:14:22 <nand`> -blah
16:14:29 <adnauseam> thanks man
16:14:43 <rasfar> xmonad with compositing would allow you to do nifty things like squeeze or lens content in marginalised tiles
16:15:18 <mm_freak> i find the concept of desktops obsolete anyway, but all window managers still like to feed corpses
16:15:27 <mm_freak> i'd love to write my own WM in haskell
16:15:38 <mm_freak> but compositing is a requirement
16:15:45 <nand`> mm_freak: I'd stick to a single console but I just can't come to terms with how screen etc. work
16:16:00 <mm_freak> nand`: no, i want graphics =)
16:16:11 <mm_freak> i don't use screen much
16:16:18 <nand`> I like xmonad's modes of tiling windows and I've gotten used to them and interacting with them; if I had the same functionality inside screen I would be sold instantly and abolish X11 entirely
16:16:21 <nand`> then again, I'd still need firefox. blast
16:16:38 <nand`> I don't use screen at all, I use tmux when I really have to; and dtach otherwise
16:16:41 <geekosaur> nand`, I do wonder if you've seen tmux
16:16:46 <geekosaur> ah, there :)
16:16:49 <nand`> geekosaur: I don't like tmux either :)
16:16:50 <rasfar> i spent quite a few years on a DEV vt and I think I know I prefer multiple windows
16:16:54 <rasfar> *DEC
16:16:58 <nand`> I don't think I'd like any text-only based “window manager”
16:17:10 <mm_freak> what's the difference between screen and tmux?
16:17:20 <nand`> mm_freak: sane keybindings, more ugly colors
16:17:29 <tensorpudding_> license, age, the people involved, configuration language
16:17:36 <mm_freak> "more ugly colors"?  screen doesn't really use colors at all
16:17:54 <nand`> but tmux does; and they're all ugly - and it's not worth the effort to fix them
16:18:00 <hpc> tmux fixes a few annoying things screen does
16:18:13 <hpc> and annoyingly misses some stuff screen has
16:18:14 <tensorpudding_> tmux uses colors?
16:18:18 <mm_freak> does tmux work better than screen with urxvt?  screen fails to map complicated key combinations properly
16:18:25 <nand`> tensorpudding_: I get this hideous green bar at the bottom
16:18:26 <tensorpudding_> it's been too long since i configured it
16:19:00 <mm_freak> key combinations that work in urxvt directly stop working in screen
16:19:17 <nand`> mm_freak: all of tmux's key combinations work because they're all combos with ^B
16:20:00 <nand`> eg. ^Bc to open a new terminal
16:20:01 <geekosaur> screen's command key can be changed.  I use ctrl-_ or ctrl-] instead of the default ctrl-a
16:20:02 <tensorpudding> you can change it though
16:20:10 <tensorpudding> i use ^u
16:20:32 <irene-knapp> I use control-snowman
16:20:36 <irene-knapp> my keyboard has a snowman key
16:20:38 <irene-knapp> no, not really
16:20:41 * Clint chokes.
16:20:52 <irene-knapp> but if it did, it would make sense to use it for that, since nothing else would :)
16:20:53 <nand`> I prefer my xmonad bindings; I use capslock + hjkl to navigate, capslock + shift + enter to open a new terminal and capslock + shift + c to send a close signal (or :q in the terminal)
16:21:02 <ion> tmux lacks a serial port terminal or a telnet client. :-P
16:21:21 <nand`> irene-knapp: I prefer usage of the “any key”
16:21:26 <irene-knapp> cute, yes
16:22:17 <nand`> http://www.getdigital.de/products/Any_Key/lng/en
16:23:04 <mm_freak> nand`: that's not what i mean
16:23:14 <mm_freak> i mean mapped keycodes
16:23:33 <nand`> mm_freak: oh, you mean stuff that gets passed to the application? I think most of those work, with the exception of ^B
16:23:57 <ion> Also, i’ve encountered screen crashes. Tmux has been stable so far.
16:24:00 <geekosaur> wouldn;t doubling it pass one on?
16:24:08 <nand`> they all work in dtach for me; and tmux uses dtach internally
16:24:25 <nand`> geekosaur: probably
16:24:25 <geekosaur> although in screen it's ^Aa to pass ^A to the app
16:24:38 <geekosaur> since ^A^A is swap to previous screen
16:24:48 <nand`> geekosaur: ^B^B works in tmux
16:25:02 * nand` is off to sleep, it's late enough already
16:25:03 <ion> Huh? Isn’t dtach completely distinct from tmux?
16:25:21 <nand`> ion: I thought dtach was the detaching component of tmux
16:25:38 <nand`> (on top of which the tmux multiplexing component is layered)
16:25:51 <nand`> my memory might be hazy
16:26:00 <geekosaur> I thought tmux didnt have the detaching stuff, so you would have to use it *with* dtach to get it
16:26:27 <geekosaur> maybe you have some distribution's canned setup that combines them
16:27:15 <ion> I don’t think so, but i could still be wrong.
16:29:39 <geekosaur> ok, looks like I'm behind a bit myself; last time I looked at tmux there was no detached session support, but that was some time ago
16:29:40 <ion> grepping the tmux source tree for dtach doesn’t yield any results. I’m pretty sure they don’t share code.
16:37:27 <lispy> Anyone here have real-life connections with ross?
16:45:45 <adnauseam> just to be on the safe side, 2 is a digit, and 32 is a number, right ?
16:46:10 <copumpkin> uh
16:46:17 <adnauseam> yes it is
16:46:20 <copumpkin> ok
16:46:22 <adnauseam> wikipedia agrees atleast
16:46:35 <adnauseam> numbers are made of digits
16:46:35 <Axman6> 2 is also a number no?
16:46:39 <c_wraith> F is a digit, sometimes
16:46:45 <hpc> neither of them is both like themselves
16:46:47 <Axman6> or are you going to turn my whole world inside out?
16:46:49 <adnauseam> 2 is made of the digit 2
16:46:50 <adnauseam> :p
16:46:56 <copumpkin> 32 might be a digit base > 33
16:47:01 <ion> axman6: It’s a free man, not a number!
16:47:08 <adnauseam> oh you're being a wiseass now :p
16:47:16 <copumpkin> I'm always an ass, and sometimes wise
16:47:18 <hpc> ion++ for the EXCELLENT reference
16:47:30 <adnauseam> wut reference :o
16:47:44 <hpc> https://en.wikipedia.org/wiki/The_Prisoner
16:47:55 * applicative is trying to remember sage remarks of copumpkin
16:48:09 <alpounet> @quote lax
16:48:09 <lambdabot> wli says: Monads are like constipation. Comonads are like Ex-Lax.
16:48:10 <copumpkin> @quote copumpkin
16:48:11 <lambdabot> copumpkin says: matlab is horrible as far as language design goes[.] it's fairly convenient for doing stuff in but I need to shower after every time I use it
16:48:13 <hpc> ooh, christopher nolan is considering a film version
16:48:15 <adnauseam> woo, british series. *adds to watch list*
16:48:18 <alpounet> @quote endofunctor
16:48:18 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
16:48:23 <alpounet> here's one.
16:48:26 <hpc> if he does, he should film it at the Hotel Portmeirion
16:48:32 <copumpkin> @quote pumpkin
16:48:33 <lambdabot> pumpkin says: "roconnor would have strangled me if I had given any more information than a Maybe."
16:48:39 <adnauseam> @quote adnauseam
16:48:39 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
16:48:41 <adnauseam> :[
16:48:46 <adnauseam> i am error.
16:48:59 * applicative concedes sagacity
16:49:59 * copumpkin bows
16:51:40 <c_wraith> That particular error message means that lambdabot once had a quote for you, but it was deleted.
16:52:39 <hpc> why is that error even possible?
16:53:21 <c_wraith> because lambdabot stores quotes as Map Username [Quote]
16:53:35 <c_wraith> and when you delete a quote, it stores a new Map with that removed from the list
16:53:50 <c_wraith> But it doesn't remove the key from the Map if it was the last quote
16:53:58 <ion> That’s not a reason, just an excuse. :-P
16:54:02 <c_wraith> And "getRandItem" assumes it's passed a non-empty list
16:54:09 <c_wraith> I'm explaining why it happens.
16:54:13 <c_wraith> Not why it *should* happen.
16:54:25 <c_wraith> I ran a local fork of lambdabot once where I fixed that.
16:54:43 <c_wraith> Sadly, that code got incinerated
16:54:50 <hpc> does lambdabot still live on darcs, or did it move to github like cabal?
16:55:03 * hpc would like to get commit powers and push fixes for some of these things
16:55:07 <hpc> especially this one:
16:55:09 <hpc> @djinn-ver
16:55:09 <lambdabot> ersion 2009-09-04.
16:55:13 <c_wraith> ersion
16:55:14 <hpc> "ersion" lol
16:55:31 <hpc> the fix is s/18/17
16:55:32 <ion> :-D
16:55:57 <ion> How about this one?
16:56:31 <ion> Hmm. Was it fixed already?
16:56:55 <hpc> i am considering abandoning my long-term project of fixing lambdabot
16:56:57 <ion> It seems it was. :-)
16:57:05 <hpc> because there doesn't appear to be anyone around to apply my fixes
16:58:12 <c_wraith> preflex: seen gwern
16:58:12 <preflex>  gwern was last seen on #haskell 46 minutes and 45 seconds ago, saying: @quote
16:58:27 <c_wraith> last I heard, gwern was committing stuff to lambdabot
16:58:33 <c_wraith> So..  There's still someone working on it around
16:59:21 <hpc> i also want a hackage account, but have yet to get a reply
16:59:32 <hpc> i forget when i sent the email requesting it
16:59:54 <hpc> should i just send it again?
17:00:02 <c_wraith> hpc: are you the person who just started a thread on -cafe about that?
17:00:10 <hpc> no
17:00:14 <c_wraith> it seems no new hackage accounts have been created in a while
17:01:20 <hpc> is this waiting-for-hackage2 idleness, or vanished-into-thin-air idleness?
17:01:33 <c_wraith> not sure
17:01:39 <kallisti> shapr: http://hackage.haskell.org/packages/archive/filesystem-trees/0.0/doc/html/System-File-Tree.html  want to debug my documentation? :>
17:01:48 * shapr boings
17:01:53 <shapr> kallisti: Yes, but after avengers :-)
17:02:05 <c_wraith> oh. the guy who creates accounts just responded, so he hasn't vanished into thin air
17:02:07 <hpc> shapr: have fun
17:02:11 <shapr> wheee!
17:02:18 <hpc> yaaay
17:02:27 <shapr> c_wraith: Ross Paterson, right?
17:02:30 <c_wraith> yess
17:02:38 <c_wraith> err, with fewer 's's
17:02:39 <shapr> He's a nice guy.
17:02:41 <shapr> haha
17:03:13 <c_wraith> seems he's missed a few requests, but has been creating accounts.
17:03:22 <c_wraith> I'd recommend just sending him a followup email.
17:03:28 <hpc> cool
17:03:49 <hpc> ill email him again, i suppose
17:13:09 * hackagebot happstack-jmacro 7.0.2 - Support for using JMacro with Happstack  http://hackage.haskell.org/package/happstack-jmacro-7.0.2 (JeremyShaw)
17:20:42 <kallisti> wow I didn't realize Miranda was so similar to Haskell.
17:21:14 <hpc> kallisti: except its notation for polymorphic types is unforgivably bad :P
17:21:20 <kallisti> yes I see that
17:21:28 <hpc> other than that, it really is
17:22:08 <kallisti> there's no way for 2 type variables to refer to the same type?
17:22:34 <heatsink> I think *, **, ***, etc are type variable names in Miranda
17:22:46 <heatsink> so if you use * in several places, it's the same type
17:22:59 <rasfar> yep
17:23:12 <kallisti> oh..
17:25:40 <applicative> Turner was a master, I think he can be forgiven ***
17:27:33 <rasfar> what is harder to forgive was the hike in academic licence fees around '92, which left me without an FPL right after I was hooked!
17:27:43 <newsham> lots of people talking about miranda lately
17:27:56 <newsham> rasfar: first hits free!
17:28:14 <hpc> newsham: i think someone decided to teach FP with miranda at some uni, and it kind of spilled out from there
17:28:17 <rasfar> yeah, i noticed too; and now i'm reading A History of Haskell and there's quite a lot about it in there as well; newsham, haha
17:28:28 * applicative is a trademark of Research Software Ltd.
17:28:45 <rasfar> i think lots of people were teaching miranda at that time (Bird & Wadler's text)
17:29:17 <mm_freak> haskell is very influenced by miranda…  in fact SPJ's original book on writing compilers for FP languages uses miranda
17:29:18 <applicative> no typeclasses, what a mercy!
17:29:30 <rasfar> well, C was so much faster that I felt compensated, as I was doing scientific computing anyhow
17:30:17 <applicative> was the Miranda compiler especially terrible?  I remember seeing references to commercial uses.  I think...
17:30:45 <mm_freak> i think the basic building blocks existed back then
17:30:54 <mm_freak> but it certainly didn't use an STG machine
17:30:58 <rasfar> it was a great compiler, but we're talking time-sharing on the easly Sun Sparc machines here
17:31:14 <newsham> *heart* C
17:31:33 <hpc> the miranda website is static html inside an iframe
17:31:43 <hpc> oh, inside a regular frame
17:31:53 <mm_freak> GHC's RTS is written in C, right?
17:31:58 <hpc> yes
17:32:13 * applicative ♡ haskell
17:32:32 <adnauseam> @hoogle tails
17:32:32 <lambdabot> Data.List tails :: [a] -> [[a]]
17:32:32 <lambdabot> Data.ByteString tails :: ByteString -> [ByteString]
17:32:32 <lambdabot> Data.ByteString.Char8 tails :: ByteString -> [ByteString]
17:32:53 <newsham> i wish more of GHCs rts was in haskell :(
17:32:58 <newsham> or something other than C
17:33:00 <shachaf> mm_freak: And C--
17:33:05 <mm_freak> hmm
17:33:19 <hpc> <3_ : (l : Language) -> l \== agda -> True
17:33:28 <rasfar> it's frustrating to learn that Haskell was available back then, but somehow I never found out until 2002. ML dialects were presented as the alternative at the time.
17:33:31 <mm_freak> i'm about to write the RTS for my language now…  C would be a reasonable choice, but i'm afraid i'm trading efficiency for portability here
17:34:03 <applicative> rasfar, and what was your objection to ML
17:34:10 <mm_freak> C's performance shortcomines will be noticable at that level
17:34:16 <newsham> mmfreak: what about security and correctness?
17:34:23 <hpc> mm_freak: obviously write an RTS-generator in haskell
17:34:39 <mm_freak> newsham: that's a concern, too
17:34:48 <mm_freak> but i don't want to invent yet another language
17:35:06 <shachaf> newsham: Those are easy: Just don't make mistakes.
17:35:07 <applicative> mm_freak: what is this language like?
17:35:11 <shachaf> (Patent pending.)
17:35:19 <heatsink> What do you want to do that's inefficient in C?
17:35:20 <rasfar> i didn't adjust well to the syntax I suppose; someone had written a Miranda to LML translator, but this was pre-internet days and never managed to get there
17:35:24 <mm_freak> hpc: the RTS should be a fixed code base…  the compiler would generate the supercombinators and the node graph to be executed by the RTS
17:35:42 <mm_freak> applicative: it's designed as a dependently typed low level language
17:35:49 <rasfar> the clean syntax of Miranda along with the applicative style was what had me hooked
17:35:56 <mm_freak> for implementing kernels, ciphers, etc.
17:36:03 <newsham> shachaf: unfortunately most programmers are incapable of dealing with strings or dynamic allocation or even addition in C without making mistakes :(
17:36:16 <applicative> rasfar, yes, ML's syntax is such a disappointment.
17:36:30 <mm_freak> heatsink: C's ABI is a bit unfortunate at least on 32 bit x86 platforms
17:36:36 <mm_freak> it's not that bad on 64 bits
17:36:55 <shachaf> newsham: Nonsense. They're just not trying hard enough.
17:37:01 <rasfar> anyway, i'm indulging in nostalgia, whatever -- a lot of strong feelings from those times
17:37:19 <heatsink> So it's the overhead of frequent function calls to/from the RTS?
17:37:22 <applicative> i don't see why the ML crowd didn't just conced that Turner was the one who knew how to design syntax and so  on
17:37:25 <mm_freak> what are the alternatives to C anyway?
17:37:38 <mm_freak> portability among at least most x86 systems is a requirement
17:37:40 <heatsink> Restart the C-- project
17:37:40 <applicative> val this ; fun that ; ....
17:37:50 <rasfar> mm_freak: FORTRAN!
17:38:01 <mm_freak> rasfar: seriously?
17:38:12 <rasfar> for your purposes, no actually
17:38:21 <geekosaur> I would argue that 32 bit x86 is what is unfortunate.  hard to do much of anything with that few registers
17:38:22 <newsham> pypy? :)
17:38:24 <applicative> fortran is somewhat handsomer than C
17:38:31 * applicative is a total aesthete
17:38:41 <newsham> irdis lang?
17:38:46 <heatsink> There aren't that many programming languages that _don't_ need an RTS of their own
17:38:58 <mm_freak> idris compiles to a sublanguage called EPIC, which is then compiled to C
17:39:18 <newsham> there's nothing wrong with compiling to C (or another lang)
17:39:44 <mm_freak> newsham: i'm not asking for a language to compile to, but rather a language to write the RTS and the primitive operations in
17:40:55 <mm_freak> i guess i'll just go with C (or even C++)
17:41:29 <heatsink> If you have to write a large amount of RTS code that's not a garbage collector, then it might be more of a sign that you need another intermediate language
17:42:49 <mm_freak> i'm designing my compiler in such a way that the compiler really just compiles to a set of supercombinators and a graph for reduction
17:42:59 <mm_freak> the language is already intermediate…  it's the core language
17:43:31 <mm_freak> the supercombinators quickly expand to a new subgraph, and that's all they do
17:43:35 <newsham> mmfreak: i wish there was some RTSless subset of ghc that could be used to do ghc's rts
17:43:47 <newsham> ie. maybe something using linear logic to implement the GC?
17:44:25 <mm_freak> newsham: the RTS is also an execution machine, so you would be running into the chicken/egg problem
17:44:32 <heatsink> So can I say the graph is the program, and the RTS is an interpreter for it?
17:44:54 <mm_freak> heatsink: the combination of supercombinators and graph is the program, and the RTS is the interpreter
17:45:02 <mm_freak> but yes, that's the basic idea
17:46:12 <heatsink> I'm not sure how the supercombinators are implemented.  Does the compiler produce both machine code and data structures?
17:47:00 <mm_freak> heatsink: a naive compiler produces data structures and code in a special language in which you express graphs
17:47:15 <mm_freak> the G code
17:47:49 <mm_freak> an even more naive compiler doesn't even need G code…  it just saves the function template and the RTS expands it
17:48:06 <mm_freak> that's called template instantiation, which gets along without supercombinators, but is very slow
17:48:43 <adnauseam> mm, what's @ relevance to lists ?
17:48:48 <adnauseam> in terms of pattern matching
17:48:57 <mm_freak> adnauseam: if you have x@y, then x is an alias for y
17:49:06 <mm_freak> that's not related to lists, but to patterns in general
17:49:09 <heatsink> The reason I'm asking is that the choices involved in making the RTS depends on whether the compiler's output is purely interpreted, or partly interpreted and partly native code.  It sounds like yours is purely interpreted.
17:49:18 <geekosaur> basically lets you assign a name to a subpattern
17:49:42 <mm_freak> adnauseam: in x@(x0:xs) the x0 is the head element, xs is the tail and x is the whole list
17:49:45 <adnauseam> mm_freak: excuse my ignorance please, but what does it mean to be an alias of something? is it not the same as being its synonym ?
17:49:53 <adnauseam> another permutation of?
17:50:07 <JoeyA> > let f a@b@c@d@e = [a,b,c,d,e] in f 5
17:50:08 <lambdabot>   [5,5,5,5,5]
17:50:24 <geekosaur> the example mm_freak just gave you should explain it
17:50:37 <adnauseam> yes, i think it is. working it out now!
17:50:44 <adnauseam> i think it odes*
17:50:46 <adnauseam> does*
17:50:51 <adnauseam> oh god.. >.<
17:50:56 <mm_freak> heatsink: don't mistake "interpreted" as "parsed and pattern-matched"…  every compiled haskell program is interpreted on a very low level, but the interpreter itself is the running code in a sense
17:51:34 <mm_freak> heatsink: if you have "f x" and "f" is a primitive function, it is just called with the "x" node as its argument
17:52:25 <mm_freak> the whole expression is represented as a graph:  "App PrimF x", where x is a subgraph…  after evaluation, that application node is replaced by its result
17:52:50 <mm_freak> this is interpretation, but not really the way you would normally understand it
17:53:18 <rasfar> if you were to draw a timeline of the activity in FPL implementation research, where would the apexes be?
17:53:53 <mm_freak> rasfar: around the first years of haskell probably
17:53:59 <mm_freak> the time when the G machine was invented
17:54:00 <rasfar> it would be great if there was a practical revolution in computer architecture which suited graph reduction more directly
17:54:28 <mm_freak> rasfar: there have been architectures supporting this eval/apply approach, but they never made it into mass production
17:55:32 <heatsink> mm_freak, I guess you can write the interpreter as a C loop that implements whatever "calling convention" and "stack" you choose.
17:55:33 <rasfar> (okay, thanks) -- ah, pity ... wonder if dynamically-reconigurable FPGA could be a platform with decent cost and availability?
17:55:53 <mm_freak> heatsink: yeah, although it isn't really going to be a loop =)
17:56:13 <rasfar> if not for large applications, at least for moderate researchy stuff
17:56:40 <mm_freak> rasfar: nowadays GPUs are cheaper than FPGAs =)
17:57:02 <rasfar> yeah, but the architecture is still rather rigid
17:58:27 <Twey> rasfar: http://www.cs.york.ac.uk/fp/reduceron/
17:58:37 <heatsink> Are you trying to make it efficient?  Although I don't know much about the actual programs you're working with, a reasonable guess is that memory management will make up a large part of the execution time.
17:58:55 <rasfar> we need more experimental architecture! a survey of the suitability of various unconventional computing paradigms for FP would be interesting...
17:58:57 <heatsink> I mean, trying to design the low-level RTS around efficient execution
17:59:32 <rasfar> Twey, thanks, looking
17:59:39 <mm_freak> heatsink: a naively implemented execution machine without any GC will be very inefficient
17:59:51 <mm_freak> but we have powerful technology like the G machine
18:00:16 <mm_freak> that one is rather complicated to implement, but it will make GC the main bottleneck
18:00:27 <rasfar> ah, from the same place whence comes Lava
18:00:35 <mm_freak> then my language will have uniqueness types such that GC is reduced to a minimum
18:01:44 <mm_freak> in any case, GC is limited to the graph nodes, which is basically the reason haskell programs are so fast even in the presence of GC
18:04:16 <adnauseam> is any interchangable with fmap ?
18:04:54 <adnauseam> mm, wait nvm
18:08:56 <rasfar> Twey, that
18:09:03 <rasfar> 's (oops) very interesting, thank-you
18:16:36 <hpc> bleh
18:16:40 <hpc> 1. get hackage account
18:16:43 <hpc> 2. cabal sdist
18:17:14 <JoeyA> 3. ???
18:17:14 <hpc> 3. find out that you either have to deal with warnings with every sdist, or bump the cabal version number for the package and wait for hackage to get updated to accept it
18:26:46 <mietek> Is reddit's blackh here?
18:27:02 <heatsink> mm_freak, then it seems like you could do a reasonably efficient RTS in C, and the rest is a bit beyond my knowledge
18:32:14 <Nevin_> Hi there
18:33:00 <Twey> Nevin_: Hello
18:35:09 <Nevin> May I ask a newbie question?
18:35:23 <Twey> Nevin: It's positively encouraged
18:35:34 <Nevin> Are there any example of Hakell
18:35:36 <Nevin> Haskell connection to Sybase?
18:37:00 <Twey> Nevin: I don't think we currently have any bindings to Sybase
18:37:40 <Twey> Perhaps someone will prove me wrong
18:38:01 <mietek> Who's taking care of the github clone of GHC git repos?
18:38:04 <Nevin> Twey: Hummm... that's what I am suspecting.... I am trying to use Haskell in my company's new project
18:38:12 <mietek> A clone of package-transformers appear to be missing.
18:38:26 <Nevin> but we are a Sybase shop so that's something I have to use
18:38:47 <hpaste> moebius_eye pasted “what's wrong with this please? ” at http://hpaste.org/68557
18:39:19 <moebius_eye> Is recursive programming a bad thing to do in haskell?
18:39:49 <Twey> Nevin: If you're dedicated enough you could write your own binding.  The Haskell FFI is quite nice to use.
18:39:57 <Twey> moebius_eye: Not at all
18:40:07 <rasfar> moebius_eye you want Integer -> Integer -> Integer (curried)
18:40:51 <Twey> moebius_eye: It's often better to use a high-level function that captures the control pattern you need, but if one doesn't exist, recursion is generally the way to go (and they're all ultimately implemented in terms of recursion, anyway).
18:40:54 <Nevin> Twey: I suppose :P
18:41:21 <Twey> Nevin: It's really not that hard.  It's mostly boilerplate.
18:42:31 <rasfar> and you can then upload it to hackage where it will be enshrined for eternity
18:42:42 <Twey> Hehe, indeed
18:42:52 <moebius_eye> Twey: with the two arrows, really?
18:42:58 <Nevin_> Twey: I guess so. Still in the learning stage
18:43:06 <rasfar> moebius_eye, yes (that was me)
18:43:20 <Twey> moebius_eye: I think you were answering rasfar
18:43:27 <moebius_eye> ah, sorry thanks
18:43:38 <rasfar> (thanks Twey :)
18:43:54 <Twey> Sorry, I was scrolled up trying to see what the question was in the first place
18:44:54 <rasfar> np, thanks was sincere.  moebius_eye, it takes getting used to, but there is a rationale behind writing the types that way.
18:46:30 <Twey> Why is the ‘newtype’ optimization not applied automatically by the compiler when it detects a ‘data’ declaration that could be a ‘newtype’?
18:46:55 <shachaf> Twey: Because it changes semantics.
18:47:15 <Twey> How?
18:47:19 <Twey> Oh, never mind
18:47:22 <shachaf> @google newtype vs data
18:47:22 <Twey> I remember now
18:47:24 <lambdabot> http://www.haskell.org/haskellwiki/Newtype
18:47:25 <lambdabot> Title: Newtype - HaskellWiki
18:48:31 <Twey> data introduces a new ⊥ at the constructor level, whereas newtype doesn't
18:53:15 <ninly> Does cygwin cause buffering issues with getLine or something? I'm having trouble reproducing results of code copied from LYAH, but only in cygwin.
18:53:34 <shachaf> ninly: Why are you asking in here instead of in #cygwin? :-)
18:54:29 <ninly> shachaf: didn't know better? i just wondered if it was an "oh yeah, that's easy" issue
18:55:07 <shachaf> You might try setting buffering explicitly or something.
18:55:45 <ninly> i'll take a look at that, thanks. buffering was just a guess on my part, because it's mentioned in LYAH.
18:58:01 <fryguybob> ninly: I think ghci gives you a warning about something if you run under cygwin.
19:00:30 <jmcarthur> ninly!
19:00:42 <ninly> jmcarthur!
19:01:38 <ninly> fryguybob: indeed. though i'm running compiled code in this case. but you're right, ghci doesn't seem to play well with cygwin-bash
19:02:00 <jmcarthur> doesn't ghci work natively in windows?
19:02:08 <fryguybob> yes
19:02:20 <adnauseam> hrm, why can't i comapre int with Integer? isn't int part of the Ord class ?
19:02:43 <geekosaur> yes, but you still need to compare the same type
19:02:48 <jmcarthur> adnauseam: you can compare two Ints or two Integers precisely because they are instance of the Ord class
19:02:56 <ninly> jmcarthur, yes it does. the code works fine when i run in the native environment, BUT ... i was following instructions in LYAH (he recommends using cygwin ... oh well)
19:03:01 <geekosaur> Ord a => a -> a -> Bool
19:03:02 <jmcarthur> adnauseam: but that doesn't mean you can compare different types of values with each other
19:03:04 <aavogt> @type \x y -> compare x (fromIntegral y) :: Integer -> Int -> Ord
19:03:05 <lambdabot>     Class `Ord' used as a type
19:03:05 <lambdabot>     In an expression type signature: Integer -> Int -> Ord
19:03:05 <lambdabot>     In the expression:
19:03:19 <aavogt> @type \x y -> compare x (fromIntegral y) :: Integer -> Int -> Ordering
19:03:20 <lambdabot>     Couldn't match expected type `Integer -> Int -> Ordering'
19:03:20 <lambdabot>            against inferred type `Ordering'
19:03:20 <lambdabot>     In the expression:
19:03:38 <adnauseam> mrmhmm
19:03:59 <jmcarthur> @type \x y -> compare (x :: Int) (y :: Integer)
19:04:00 <lambdabot>     Couldn't match expected type `Int' against inferred type `Integer'
19:04:00 <lambdabot>     In the second argument of `compare', namely `(y :: Integer)'
19:04:00 <lambdabot>     In the expression: compare (x :: Int) (y :: Integer)
19:04:09 <jmcarthur> that's the error message we're looking for
19:04:22 <adnauseam> me thinks i'll use a lambda to fix this then
19:04:29 <jmcarthur> huh?
19:04:44 <jmcarthur> you will have to convert one of your values into the type that matches the other
19:04:51 <adnauseam> imight be talking out of me arse, not sure if this can be done
19:04:58 <aavogt> @type (\x y -> compare x (fromIntegral y)) :: Integer -> Int -> Ordering
19:04:59 <lambdabot> Integer -> Int -> Ordering
19:05:08 <Twey> @quote fromIntegral
19:05:08 <lambdabot> lilac says: <drdozer> gha! I'm drowning in the haskell number hierarchy again <lilac> drdozer: magic 8-ball says 'add calls to fromIntegral'
19:05:11 <jmcarthur> if you want to compare an Int with an Integer, I would convert the Int to an Integer, then compare them
19:05:36 <adnauseam> sounds good to me
19:16:29 <fryguybob> ninly: Which particular example isn't working for you?
19:21:17 <ninly> fryguybob: it's about halfway into Input and Output, the demonstration of forM that asks about color associations
19:25:37 <fryguybob> That works for me with everything I have here.
19:28:00 <ninly> weird. it's really not serious, i can work in windows (if necessary). thanks for looking, though.
19:31:38 <xil1> hey everyone. Hoogle having known problems?
19:32:37 <fryguybob> xil1: Works for me.
19:32:39 <xil1> Data.Map isn't loading properly for me. Only loads a few things
19:32:44 <xil1> http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Map.html
19:33:32 <xil1> @hoogle adjust
19:33:33 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
19:33:33 <lambdabot> Data.IntMap adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
19:33:33 <lambdabot> Data.Map adjust :: Ord k => (a -> a) -> k -> Map k a -> Map k a
19:34:04 <xil1> was hoping for links =/. Well I'm trying to figure out what Data.Map.adjust does if the key isn't in the map
19:34:33 <Axman6> probably nothing
19:34:44 <Axman6> gives you back the original tree
19:34:53 <xil1> Axman6: okay, thanks
19:35:03 <Axman6> but, it's also easy enough to test ;)
19:35:28 <xil1> that's true
19:43:37 <kallisti> so there's not really one way to do a filter on a tree that satisfies all use cases..
19:45:10 <adnauseam> take a chainsaw to its stem :|
20:06:40 <dmner> Hey, got a question related to intermediate datastructures and how to  use/design around
20:07:10 <dmner> so I am implementing adaptive supersampling, and normally you store the samples (in case you have to use them again) as some are used more than once
20:09:05 <dmwit> What's the question?
20:09:09 <dmner> I'm just not sure how to implement or design around (do something else instead, more stateless) the problem
20:09:35 <dmner> I could just resample every time, but that would be incredibly slow
20:09:42 <dmwit> If it's normal to store samples, I don't see why you shouldn't store samples.
20:09:57 <dmwit> The question as stated so far is too vague to answer meaningfully.
20:10:14 <dmner> give me a second to better explain
20:14:34 <rasfar> a perfect case for a single-assignment array by the sounds of it
20:15:55 <dmner> single-assignment array?
20:16:02 <hpaste> dmner pasted “Sampling Question” at http://hpaste.org/68558
20:16:12 <dmwit> As far as I'm concerned, it sounds like a perfect case of somebody who needs to read some Conal blog posts.
20:16:15 <rasfar> oh never mind, this is ray tracing right?
20:16:21 <dmner> yeah...
20:16:24 <rasfar> heh
20:16:49 <rasfar> everyone needs to read some Conal blog posts :)
20:16:52 <dmwit> dmner: http://conal.net/blog/posts/exact-numeric-integration
20:17:13 <dmwit> and
20:17:40 <dmwit> http://www.alvyray.com/memos/MemosCG.htm#PixelIsNotSquare
20:17:41 <dmwit> perhaps
20:17:55 <dmwit> Though the latter may be old news for somebody already familiar with adaptive supersampling.
20:18:53 <dmner> thanks dmwit, haven't read any of Conal's posts before
20:19:07 <dmwit> However, if you still want to do adaptive supersampling for whatever reason, then I strongly suggest one of the many automatic pure-function-memoizers available on Hackage.
20:19:45 <dmwit> They're very easy to plug in to an existing project, and likely to be near-optimal in terms of access speed for repeated computations.
20:21:02 <dmwit> http://hackage.haskell.org/package/MemoTrie for example (you'll be pleased to note the overlap in authorship here between my previous suggestion and this one =)
20:22:06 <newsham> http://pastebin.com/G1hdB7yc <- build error (using fbsd ports.. guh) trying to get ghc7.0.4 installed
20:22:11 <mauke> The paste G1hdB7yc has been copied to http://hpaste.org/68559
20:22:21 <dmner> alright, I feel really dumb for not realizing the link to memoization. thanks again dmwit
20:22:36 <newsham> anyone know why?
20:23:40 <rasfar> (yeah interesting, thanks, i wasn't aware of those, useful for DP too)
20:36:14 <xrl> Why am I getting an error about MonadResource and MonadThrow not being in scope? http://hpaste.org/68560 . I expect them to be exported by Data.Conduit ( https://github.com/snoyberg/conduit/blob/master/conduit/Data/Conduit.hs#L55 )
20:36:32 * shapr throws a monad into a conduit
20:36:48 * moebius_eye is confused again
20:38:10 <shapr> moebius_eye: What are you confused about?
20:38:36 <hpaste> moebius_eye pasted “about that” at http://hpaste.org/68561
20:39:15 <jmcarthur> ?seen mmorrow
20:39:16 <lambdabot> Unknown command, try @list
20:39:22 <jmcarthur> err...
20:39:24 <shapr> preflex: seen mmorrow
20:39:24 <preflex>  mmorrow was last seen on #ghc 2 years, 119 days, 41 minutes and 40 seconds ago, saying: * mmorrow is rtfm'ing
20:39:47 <shapr> jmcarthur: nickserv reports the same amount of time
20:42:03 <dmwit> moebius_eye: Can you phrase your question in the form of a question?
20:42:37 <dmwit> xrl: Could you post the exact error? Also, what version of the "conduit" package have you got installed? (Use ghc-pkg list conduit to find out.)
20:43:33 <hpaste> xrl annotated “about that” with “about that (annotation)” at http://hpaste.org/68561#a68562
20:43:51 <xrl> dmwit: I added that to the bottom of the existing paste
20:43:57 <xrl> as hpaste said ;)
20:47:41 <dmwit> I notice those two things only appeared in Data.Conduit in conduit-0.3 and later; have you got a recent enough version installed?
20:48:07 <dmwit> (and being used by cabal? check your .cabal file to see what it depends on)
20:48:48 <shapr> So, I just upgraded to Ubuntu 12.04, and now I have ghc 7.4.1 instead of ghc 7.0.x
20:48:59 <dmwit> yay!
20:49:04 <shapr> cabal install is not a happy camper, is the best solution to blow away ~/.ghc and start over?
20:49:12 <Axman6> shapr: thats the default ghc in 12.04?
20:49:17 <shapr> Axman6: yup
20:49:47 <dmwit> You can safely blow away ~/.ghc, but cabal-install should be smart enough to handle multiple GHC installs. What's going wrong?
20:50:56 <moebius_eye> dmwit: when you use words on a String, it produces a [String] right?
20:51:03 <shapr> dmwit: it's upset about base-* versions, it wants them to be 4.2+ or < 4.4 and yet, it says 4.5 is selected instead
20:51:12 <dmwit> :t words
20:51:13 <lambdabot> String -> [String]
20:51:14 <Clint> you'll need to upgrade every single library
20:51:19 <dmwit> moebius_eye: affirmative
20:51:27 <shapr> Clint: Are you hydo?
20:51:32 <Clint> am i.. what?
20:51:36 <Axman6> shapr: good to hear =)
20:51:36 <shapr> Ok, I guess not.
20:51:39 <dmwit> shapr: I doubt that will be fixed by blowing away ~/.ghc, then.
20:51:51 <shapr> I'm doing cabal install cabal-install
20:51:54 <moebius_eye> :type map toUpper
20:51:55 <dmwit> shapr: It sounds to me like some package wrote a too-strict version dependency.
20:52:03 <moebius_eye> :t map toUpper
20:52:04 <lambdabot> [Char] -> [Char]
20:52:05 <dmwit> gotta run
20:52:08 * shapr waves
20:52:14 <Clint> the 7.0-compiled libraries aren't binary-compatible
20:52:49 <moebius_eye> map words
20:52:55 <moebius_eye> :t map words
20:52:56 <lambdabot> [String] -> [[String]]
20:53:28 <moebius_eye> :t unwords map words
20:53:29 <lambdabot>     Couldn't match expected type `[String]'
20:53:29 <lambdabot>            against inferred type `(a -> b) -> [a] -> [b]'
20:53:29 <lambdabot>     In the first argument of `unwords', namely `map'
20:56:12 <shapr> moebius_eye: What are you trying to do?
20:56:57 <shapr> moebius_eye: map is given a function and a list of things to apply that function to
20:57:00 <rasfar> moebius_eye, it's a lot easier if you also paste the compiler error messages
20:57:15 <newsham> *sigh* some files in ~/.ghc/* were causing problems.
20:57:22 <newsham> finally figured that out, now ghc-7.0.4 is building
20:57:48 <rasfar> shoutEachWord l = unwords . map shoutWord . words
20:58:12 <rasfar> the RHS is still a function
20:59:15 <rasfar> (er, i didn't express that very well)
20:59:52 <newsham> shoutEachWord l = (unwords . map shoutWords . words) l
20:59:56 <rasfar> if you just drop the "l" from the left hand side (and the "t" in the other error) it'll work
21:00:27 <rasfar> (or what newsham suggests, but you may find the extra parentheses a nuissance)
21:01:48 <newsham> i meant it more as a way to see what the problem was
21:01:52 <newsham> than as a recommendation of what to do
21:02:32 <newsham> whats the point of addresses like kallisti (~eris@wikipedia/The-Prophet-Wizard-of-the-Crayon-Cake) ?
21:02:33 <rasfar> i tried what you did first, but forgot the parentheses, so they were a nuissance to me at least =D
21:02:57 <newsham> why doesnt freenode jsut get rid of user@host if they want to make them nonsensical?
21:04:08 <mauke> newsham: were they sensical before?
21:04:45 <rasfar> you can also write
21:04:45 <rasfar> shoutEachWord l = unwords $ map shoutWords $ words l
21:04:45 <rasfar> which is what I usually do
21:05:35 <newsham> mauke: luxurymode (~luxurymod@pool-108-29-90-177.nycmny.fios.verizon.net) is definitely more sensical than kallisti (~eris@wikipedia/The-Prophet-Wizard-of-the-Crayon-Cake)
21:05:44 <mauke> why?
21:06:15 <DaDaDOSPrompt> anyone here use Haskell for tensor analysis?
21:06:23 <newsham> because one has a routable IP address that is commonly understood
21:06:35 <mauke> what good is that?
21:06:37 <newsham> and the other has some magic string that the irc ops decided to put there
21:06:57 <newsham> *shrug* same good as any other IP address
21:06:57 <mauke> and that "magic string" tells you they're a member of the wikipedia project
21:07:03 <newsham> useful for making packets go somewhere, at the least
21:08:13 <rasfar> moebius_eye: so in summary, these are all equivalent:
21:08:16 <rasfar> shoutEachWord = unwords . map shoutWord . words
21:08:16 <rasfar> shoutEachWord l = (unwords . map shoutWord . words) l
21:08:16 <rasfar> shoutEachWord l = unwords $ map shoutWord $ words l
21:08:44 <newsham> shoutEachWord = \l -> (unwords . map shoutWord . words) l
21:13:11 <xil1> hi again everyone. So I had some version of Text.Regex installed but now when I compile it says it can't find it. Anyone know what package to install with cabal?
21:14:21 <moebius_eye> rasfar: but that doesn't tell me why t doesn't work...
21:14:41 <newsham> ?google text.regex hackage
21:14:43 <lambdabot> http://hackage.haskell.org/packages/archive/regex-compat/0.92/doc/html/Text-Regex.html
21:14:43 <lambdabot> Title: Text.Regex
21:15:31 <xil1> newsham: so regex-compat then
21:15:46 <newsham> I think thats what you want
21:15:53 <xrl> dmwit: that was a good idea to clear out old Data.Conduit. Now it complains about an ambiguous constraint: http://hpaste.org/68563
21:16:56 <rasfar> morbius_eye: true, but a quibble! :p I'm finding it hard to cobble an explanation that satisfies me.
21:17:24 <Clint> xrl: why do you have m1 instead of m?
21:17:44 <rasfar> you defined the pattern variable "l" but never used it. not that that's a sin per se...
21:18:02 <xrl> Clint: dayum, good catch!
21:18:05 <rasfar> but in this case it explains your error
21:18:16 <rasfar> i have to go, bubye
21:18:17 * hackagebot guess-combinator 0.1 - Generate simple combinators given their type  http://hackage.haskell.org/package/guess-combinator-0.1 (EtienneLaurin)
21:18:19 * hackagebot guess-combinator 0.1.1 - Generate simple combinators given their type  http://hackage.haskell.org/package/guess-combinator-0.1.1 (EtienneLaurin)
21:18:50 <xrl> Clint: that got me all the way through compiling
21:20:13 <Clint> fabulous
21:26:27 <hpaste> xil pasted “type help” at http://hpaste.org/68564
21:26:43 <xil1> hi everyone. I need some help debugging the above pasted error
21:27:10 <shachaf> First step is probably to find the code.
21:27:23 <shachaf> Anyway, the error is what it says.
21:27:31 <shachaf> "(String (Side (String, String) String))"
21:27:34 <mauke> o_O
21:27:37 <xil1> yeah just noticed that
21:27:42 <xil1> that first String shouldn't be there
21:27:51 <xil1> *facepalm*
21:28:06 <shachaf> GHC is an amazing Haskell debugging tool. It's a pity people don't use it more.
21:28:55 <mauke> @quote sensible,
21:28:56 <lambdabot> augustss says: ghc had a bug once where it deleted the source file if it had a type error. Quite sensible, I think.
21:29:08 <xil1> yay, compiled. Thanks y'all =]
21:29:40 <shachaf> preflex: seen augustss
21:29:40 <preflex>  augustss was last seen on #haskell 189 days, 3 hours, 57 minutes and 32 seconds ago, saying: > div (-1) 2
21:43:18 * hackagebot filesystem-trees 0.1 - Recursively manipulate and traverse filesystems as lazy rose trees.  http://hackage.haskell.org/package/filesystem-trees-0.1 (AdamCurtis)
22:07:35 <copumpkin> @tell edwardk looks like Max is working on unboxed tuple arguments
22:07:35 <lambdabot> Consider it noted.
22:08:18 * hackagebot sodium 0.3.0.1 - Sodium Reactive Programming (FRP) System  http://hackage.haskell.org/package/sodium-0.3.0.1 (StephenBlackheath)
22:19:05 <davesque> how can i determine if a number has a fractional part in haskell?
22:19:44 <kallisti> there are many different kinds of numbers
22:19:48 <kallisti> what kind of number are you dealing with?
22:19:51 <davesque> if a float
22:20:01 <mm_freak> davesque: see the RealFrac class
22:20:13 <kallisti> floor x == x
22:20:15 <mm_freak> > properFraction 3.4
22:20:16 <lambdabot>   (3,0.3999999999999999)
22:20:20 <kallisti> ah
22:20:22 <kallisti> much better
22:20:34 <davesque> ahh, okay
22:20:51 <davesque> figured there might be a library function
22:21:03 <mm_freak> another way is to use the RealFloat instance
22:21:26 <davesque> how can you do that?  i'm not very experienced :P
22:21:31 <mm_freak> > decodeFloat 100.25
22:21:32 <lambdabot>   (7054466603810816,-46)
22:21:37 <mm_freak> > decodeFloat 100
22:21:38 <lambdabot>   (7036874417766400,-46)
22:21:50 <mm_freak> ok, that's not very useful
22:22:00 <mm_freak> use RealFrac =)
22:22:35 <davesque> okay, i'll look into that :)
22:22:37 <mm_freak> kallisti's way is valid, but fails for subtle rounding errors
22:33:49 <newsham> > map decodeFloat [1, 10, 100]
22:33:50 <lambdabot>   [(4503599627370496,-52),(5629499534213120,-49),(7036874417766400,-46)]
22:34:07 <newsham> > map decodeFloat [1, 2, 4, 8, 16]
22:34:08 <lambdabot>   [(4503599627370496,-52),(4503599627370496,-51),(4503599627370496,-50),(4503...
22:35:39 <newsham> ?type encodeFloat
22:35:40 <lambdabot> forall a. (RealFloat a) => Integer -> Int -> a
22:35:51 <newsham> > encodeFloat 1 1
22:35:52 <lambdabot>   2.0
22:36:09 <newsham> > decodeFloat 2.0
22:36:10 <lambdabot>   (4503599627370496,-51)
22:36:29 <newsham> normalization?
23:16:29 <lpvb> hey does anyone know what this error means: https://gist.github.com/2340793
23:19:09 <shachaf> It means that it cannot open shared object file: No such file or directory
23:19:14 <lpvb> yes
23:19:41 <lpvb> but libncurses.so is in /usr/lib
23:19:42 <shachaf> So you should arrange for the file to be available.
23:19:46 <lpvb> so why is it looking in gcc
23:19:55 <lpvb> how do I do that?
23:20:02 <shachaf> OK, but it's looking in /lib
23:20:27 <shachaf> Oh, no, it's not.
23:20:52 <shachaf> I don't know -- maybe strace it to see what it's actually doing.
23:21:00 <shachaf> That's usually my approach. :-)
23:21:18 <lpvb> sounds complicated
23:23:55 <mm_freak> what was that LaTeX package called for typesetting inference rules?
23:29:44 <mm_freak> found it
23:45:11 <hpaste> lpvb pasted “lambdabot build error” at http://hpaste.org/68566
23:45:33 <lpvb> does anyone know how to deal with that error ^^ ?
23:46:18 <Eduard_Munteanu> lpvb: um, do what the error message suggests?
23:46:44 <lpvb> how do I pass that flag to cabal?
23:47:32 <lpvb> @Eduard_Munteanu
23:47:32 <lambdabot> Unknown command, try @list
23:48:12 <Eduard_Munteanu> lpvb: I guess you should edit the sources, push the fix upstream and cabal install in the meanwhile :)
