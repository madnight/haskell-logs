00:00:23 <mysticc> shachaf: Atleast all of them which are asked here as a part of some homework ..
00:00:52 <shachaf> That *might* be the case.
00:01:38 <dmwit> hm
00:01:53 <dmwit> I'm pretty sure I didn't invent this joke, but the oldest quote I can find on Google for it is me.
00:02:39 <shachaf> dmwit: main = print "2008-05-29"
00:06:30 <danr> How do you make Oxford brackets in latex?
00:08:01 <mysticc> danr: What is oxford bracket ?
00:08:09 <dmwit> Are Oxford brackets the |[ ones?
00:08:16 <danr> dmwit: yes
00:08:18 <danr> well [|
00:08:20 <danr> I'd say
00:08:26 <danr> \llbracket, detexify now says
00:08:26 <dmwit> If so, \llbracket and \rrbracket
00:08:37 <danr> or \textlbrackdbl, but that's just annoying
00:08:38 <dmwit> Yes, I was going to point to detexify next.
00:08:39 <danr> dmwit: thanks
00:08:42 <dmwit> Wonderful tool. =)
00:08:46 <danr> yeah, I had forgotten it
00:18:34 <Dacicus2> Hi, clintm.
00:18:36 <Dacicus2> How can I go about switching from Unity back to GNOME 2? Thanks.
00:18:51 <clintm> Unity is written in Haskell?!?!? omg!!
00:19:10 <Dacicus2> Hi, ttt--.
00:19:55 <clintm> Dacicus2: I just had to do that last night, as a matter of fact.
00:19:57 <Dacicus2> How are you doing, clintm?
00:20:34 <clintm> ugh
00:21:17 <blackdog> clintm: the sarcasm, it comes in waves :)
00:24:22 <clintm> blackdog: apparently, I'm too tired to come up with something witty or charming to say about any of this.
00:24:39 <clintm> I think I'll just go figure out why my block isn't showing up on au instead.
00:25:16 <Dacicus2> Hi, nofd.
00:25:32 * nofd hi
01:16:23 <womb> k
01:16:28 <womb> > 7*7
01:16:30 <lambdabot>   49
01:17:34 <mysticc> lmao on this http://soundcloud.com/marak/the-git-rap
01:17:50 * mysticc should make a darcs rap 
01:19:19 <merijn> I want a map with a fixed set of keys (i.e. it doesn't return Maybe for lookups and makes sure all keys are present) I don't suppose there's a way to enforce this in the type system?
01:19:20 <mysticc> womb: what was k for ?
01:19:46 <shachaf> merijn: What sorts of keys?
01:19:57 <shachaf> data Key = A | B | C
01:20:17 <merijn> shachaf: String, but I could define a special datatype for it and replace my strings with named constructors
01:21:24 <shachaf> conal has a "total map" data type.
01:21:31 <shachaf> I'm not sure if it'll do what you want.
01:21:57 <mm_freak_> byorgey: i fail to see the virtues of locally nameless…  in fact the changes in the code were to support the newly formed named variables
01:22:22 <merijn> shachaf: Got a link for that?
01:22:42 <shachaf> @google conal total map
01:22:45 <lambdabot> https://github.com/conal/total-map
01:22:53 <shachaf> But I don't think it's what you want because it has a "default value" thing.
01:25:26 <merijn> shachaf: Yeah, that also doesn't guarantee the presence of all keys. So I might just be better of just using Data.Map and fromJust
01:25:39 <womb> mysticc: i had router burned yesterday and i typed by accident today k
01:25:59 <womb> mysticc: sorry for this, i'm not parsec can't go back in token stream :(
01:26:08 <shachaf> merijn: You could make a separate type for it.
01:26:30 <merijn> shachaf: Yeah, but what does that gain me?
01:26:40 <shachaf> Niceness?
01:26:42 <shachaf> Is there a class Enumerable that can give you all the inhabitants of a type?
01:26:56 <merijn> Enum?
01:26:58 <dmwit> shachaf: I've used the name "Universe" for that before.
01:27:06 <shachaf> merijn: Hardly.
01:27:08 <dmwit> I don't think there is one on Hackage, though.
01:27:20 <dmwit> class Universe a where universe :: [a]
01:27:21 <hayashi> @pl \x -> a *> f x *> g x
01:27:21 <lambdabot> ap ((*>) . (a *>) . f) g
01:27:27 <shachaf> dmwit: I've seen that used in Somethingplate with a different meaning.
01:27:44 <merijn> Hmm, I was thinking to small, I guess
01:27:44 <shachaf> merijn: Niceness in that your type would actually reflect the sorts of things you do with it.
01:27:48 <hayashi> oh pointfree, you never fail to disappoint
01:27:54 <dmwit> Pick a better name if you want. Anyway, the answer seems to be "no", I think.
01:27:55 <shachaf> Even if the implementation ends up being the same.
01:28:10 <shachaf> dmwit: That's unfortunate. It seems like a useful type.
01:28:28 <shachaf> There's a question of whether infinite types should be instances or not. :-)
01:28:44 <shachaf> In this case you don't want it, but in some others you probably would.
01:29:13 <shachaf> merijn: This is a different type in various ways -- operations like "delete" don't make sense on it, while others are total.
01:29:45 <shachaf> (Hmm, it might be that conal's type would do what you want, actually. I'm not sure.)
01:30:59 <mysticc> merijn: Do you know all the keys beforhand .. and do not insert in the maps afterwards ?
01:31:05 <merijn> mysticc: Yes
01:31:39 <shachaf> merijn: How do you actually use this map?
01:31:46 <merijn> Basically the Map represents positions on a fixed gameboard, so I'm only updating or looking up positions
01:31:46 <shachaf> It might be that the best representation for it is just a function.
01:31:55 <shachaf> Oh, you are inserting.
01:32:44 <mysticc> Isn't TH can do that ..
01:33:07 <mysticc> I mean to generate new type for each key and typeclass etc ..
01:33:20 <shachaf> Why would you want that?
01:33:53 <mysticc> shachaf: A typesafe store ..
01:49:54 <MaskRay> foraging for haskell source dependency visualization tool
01:52:20 <yitz> MaskRay: http://packdeps.haskellers.com/
01:53:26 * hackagebot codemonitor 0.1 - Tool that automatically runs arbitrary commands when files change on disk.  http://hackage.haskell.org/package/codemonitor-0.1 (RickardLindberg)
01:53:39 <yitz> MaskRay: ah that's just tables though. you're looking for a graphical visualization?
01:55:18 <MaskRay> interconnection of modules in a library
01:55:29 <MaskRay> graphmod?
01:56:53 <mysticc> :k is to report kind .. there was something similar to report the kind and also simplify the type ?
01:56:54 <lambdabot> parse error on input `..'
01:58:03 <shachaf> mysticc: :kind! ?
01:58:24 <mysticc> shachaf: wth .. I was trying :k! since then :)
01:58:31 <mysticc> thanks
01:58:37 <MaskRay> yitz: sorry for not describing clear, but i need a graph visualization tool to show dependencies of various modules in a library
01:59:05 <yitz> MaskRay: my fault you were clear. :)
02:00:47 <yitz> MaskRay: but i suppose you could cannibalize the packdeps source code to gather all the deps from hackage, then just feed it to any generic graph visualization tool.
02:01:57 <MaskRay> insert an edge from A to B provided A.hs contains a line 'import NotALibName.B'
02:02:25 <yitz> MaskRay: ahh modules in a library. wow i'm really groggy today.
02:03:00 <MaskRay> your tips are helpful
02:09:55 <t7> cannibalized...
02:10:05 <t7> sounds like american english to me
02:10:27 <kuribas> Is haskell signal processing fast enough, or is it better to use C ?
02:10:51 * t7 sighs
02:11:31 <kuribas> I found this: http://hackage.haskell.org/package/dsp
02:11:35 <blackdog> kuribas: as with everything else: depends on your application.
02:11:53 <kuribas> blackdog: Generating a frequency response graph from a sinesweep.
02:12:04 <kuribas> (using gnuplot)
02:12:07 <blackdog> but in general it's not terribly hard to come close to C performance, and you can always drop down through the FFI if you need to.
02:12:27 <blackdog> so how will you know if it's fast enough?
02:13:06 <kuribas> If I don't need to wait more than a minute or so...
02:22:34 <womb> :O
02:22:46 <womb> i think i'm gone die from boredom today int he office
02:23:34 <t7> oh ppor you
02:23:39 <t7> i have 4 laptops infront of me
02:23:51 <t7> actually my job is easy
02:23:55 <t7> im gonna shut up
02:24:32 <yitz> t7: sorry about that. when i'm this groggy i start babbling in american english.
02:26:13 <mm_freak_> byorgey: forget it…  i just now read the paper by conor mcbride and james mckinna
02:26:20 <mm_freak_> i'll try again
02:27:28 <mm_freak_> i had free indices where i should have abstracted them away…  apparently in this system free indices are always wrong
02:27:45 <teneen> Is any type with a kind (* -> *)  a Functor?
02:27:57 <mm_freak_> teneen: Maybe
02:28:15 <mm_freak_> Either a, [], (e ->)
02:28:17 <mm_freak_> and many more
02:28:29 <dmwit> no
02:28:33 <teneen> mm_freak_: So there exists no counterexample?
02:28:40 <dmwit> For example, newtype NotAFunctor a b = NotAFunctor (b -> a)
02:28:47 <mm_freak_> oh
02:29:01 <mm_freak_> i didn't read "any" as "every" =)
02:29:25 <teneen> dmwit: That's the example I was looking for, thanks!
02:30:17 <mm_freak_> well, you can always define fmap f = id
02:30:39 <mm_freak_> then naturally fmap id = id and fmap f . fmap g = fmap (f . g)
02:31:27 <dmwit> id does not have the right type
02:31:36 <mm_freak_> ah, right
02:50:08 <kuribas> Has anyone tried DSP?  Is it much slower than fftw, because it is a native haskell library?
02:51:27 <mm_freak_> kuribas: i have no experience with DSP, but nowadays number crunching is very fast in haskell…  "written in haskell" doesn't imply "slow", so just try it out
02:52:13 <kuribas> mm_freak_: ok, thanks.
02:53:09 <mm_freak_> womb: if you're that bored, implement a dependently typed language in haskell =)
02:53:14 <kuribas> The code contains: "{-# specialize fft :: Array Int (Complex Float) -> Array Int (Complex Float) #-}".  Does that mean to optimise for number crunching?
02:53:19 <mm_freak_> that's mind-blowing and never gonna be boring ;)
02:53:58 <mm_freak_> kuribas: that makes sure special code is generated for the given type…  that code can be optimized using all static information available
02:54:25 <kuribas> Oh, I see.
02:54:26 <mm_freak_> kuribas: optimization that can't necessarily be applied to a polymorphic function
02:55:02 <mm_freak_> example:  test = return >=> return
02:55:07 <womb> mm_freak_: dependently | depended type system in haskell is a big chunk of work.
02:55:11 <mm_freak_> this stays the way it is as a polymorphic function
02:55:19 <mm_freak_> womb: it's not that bad
02:55:34 <kuribas> "The logic is based on FFTW." Nice :-)
02:55:56 <mm_freak_> kuribas: when you add a SPECIALIZE pragma for that function, the compiler might be able to optimize it to simply 'return'
02:56:47 <dmwit> mm_freak_: No offense, but that was a pretty bad explanation of the SPECIALIZE pragma.
02:56:48 <mm_freak_> womb: the type system is the least of your problems in such a language…  implementing lambda calculus properly is the biggest chunk of work =)
02:57:04 <mm_freak_> dmwit: why?
02:57:19 <mm_freak_> or what would be a better one?
02:57:25 <Franciman> hi all
02:57:40 <Franciman> is it cheaper to pack a string to bytestring, or to unpack a bytestring to a string?
02:57:44 <womb> mm_freak_:  http://en.wikipedia.org/wiki/Dependent_type#First_order_dependent_type_theory you don't like me :)
02:58:18 <dmwit> kuribas: Type classes incur a bit of overhead in GHC: they're implemented via dictionary passing. Because of this, some tight loops are broken by the need to unpack and repack the dictionary all the time. The SPECIALIZE pragma eliminates this problem by choosing the dictionary at compile time, re-enabling tight loops.
02:58:27 <mm_freak_> Franciman: depends on your notion of "cheap"
02:58:32 * hackagebot fclabels 1.1.2 - First class accessor labels.  http://hackage.haskell.org/package/fclabels-1.1.2 (SebastiaanVisser)
02:58:37 <mm_freak_> Franciman: the latter doesn't do anything until you start consuming the string
02:59:04 <mm_freak_> Franciman: going from String to ByteString is a strict operation, at last for strict ByteStrings
02:59:33 <Franciman> I just gotta compare a string and a bytestring
02:59:45 <Franciman> and their size is small, like 4 chars
02:59:59 <dmwit> Converting the String to ByteString is not safe.
03:00:09 <mm_freak_> Franciman: then go the latter way
03:00:12 <dmwit> (Unless you are using a good encoding library.)
03:00:30 <mm_freak_> womb: the theory is heavy, but i'm serious…  the implementation isn't that complicated…  most of the hard work goes into the lambda calculus itself and you would run into it even in the untyped lambda calculus
03:00:31 <Franciman> unpacking then?
03:00:33 <Franciman> :)
03:00:43 <dmwit> Converting from ByteString to String using unpack may be safe, depending on the details of the ByteString.
03:01:02 <dmwit> (Again, it's more correct to use a good decoding library.)
03:01:11 <Franciman> it's guaranteed to be ASCII
03:01:17 <dmwit> You say that now.
03:01:22 <dmwit> Don't blame me when there's tears tomorrow.
03:01:38 <Franciman> lol, sorry
03:01:59 <mm_freak_> Franciman: you should watch this:  http://www.youtube.com/watch?v=3kEfedtQVOY
03:02:56 <Franciman> what the hell is that ?
03:03:13 <mm_freak_> it's a talk very relevant to the issue dmwit addresses
03:03:25 <mm_freak_> anyway…  the message is:  you shouldn't be using ByteString in the first place
03:03:31 * dmwit <3 #haskell
03:03:36 <Franciman> oh ok
03:03:38 <mm_freak_> if you can, you should use Data.Text for text
03:03:50 <dmwit> "Oh, you want to convert four bytes into a String? Watch this hour-long video on the right way to do that first."
03:03:53 <dmwit> =P
03:03:58 <mm_freak_> hehe
03:04:04 <Franciman> :)
03:04:28 <dmwit> But yes, I'll happily get behind the "don't use ByteString for text in the first place" message.
03:04:29 <mm_freak_> well, at least i didn't name an 80 pages paper =P
03:04:35 <Skola_> I find my self often using something like (zipWith (-) (tail xs) xs)
03:04:37 <Skola_> Is there a better way to do this?
03:04:42 <dmwit> nope
03:04:43 <JesusIsLord> Skola_: zip`ap`tail
03:04:49 <dmwit> There are other ways, but no better ways.
03:04:56 <JesusIsLord> but that's more golfing than useful
03:05:13 <dmwit> Scratch that, zipWith (-) (drop 1 xs) xs is better.
03:05:17 <Franciman> well thanks for the help
03:05:38 <Skola_> why is that better?
03:05:41 <dmwit> > zipWith (-) (tail []) []
03:05:41 <lambdabot>   *Exception: Prelude.tail: empty list
03:05:48 <dmwit> > zipWith (-) (drop 1 []) []
03:05:49 <lambdabot>   []
03:06:00 <ClaudiusMaximus> > zipWith subtract [] (tail [])
03:06:02 <lambdabot>   []
03:06:10 <JesusIsLord> yeah but for (zipWith (-) xs (tail xs)) it doesn't matter
03:06:12 <dmwit> Yes, tail is okay if it's in the other argument.
03:06:51 <dmwit> But using tail instead of drop 1 is just a good habit to lose anyway. =)
03:07:03 <ClaudiusMaximus> yep
03:07:08 <mm_freak_> well, there might be a better way…  let me look up that one hour video i found about that problem
03:07:13 <dmwit> hehehe
03:08:02 <Franciman> well actually it's not real text, it is a binary stream
03:08:11 <Franciman> and the first four bytes are ASCII encoded
03:08:17 <mm_freak_> Franciman: a binary ASCII stream? =P
03:08:19 <Franciman> and represent a ID
03:08:27 <Franciman> no, just the first 4 bytes are ASCII
03:08:31 <Franciman> then it becomes UTF8
03:08:40 <dmwit> Why don't you pack a [Word8]?
03:08:45 <dmwit> Then nobody has any complaints about anything.
03:08:47 <Franciman> though we might say anything is UTF8
03:09:03 <mm_freak_> definitely not
03:09:12 <dmwit> Many things are not UTF8.
03:09:16 <mm_freak_> there are byte sequences that are not valid UTF8
03:09:23 <Franciman> FORM is?
03:09:31 <Franciman> * "FORM"
03:09:58 <mm_freak_> any sequence of bytes with the high bit unset is valid UTF8
03:10:15 <Franciman> then it's surely UTF8
03:10:25 <JesusIsLord> what about the "NUL" character?
03:10:39 <Franciman> it can't be there
03:10:43 <mm_freak_> JesusIsLord: i think that's also in the character set
03:11:06 <mm_freak_> Franciman: your statements indicate that you really should watch that video…  not just because of your current issue
03:11:11 <dmwit> As I learned on reddit today, '\NUL' is represented as two adjacent zero bytes in UTF8.
03:11:24 <dmwit> So not all byte sequences with all high bits unset are UTF8.
03:11:25 <Franciman> mm_freak_, I guess so, too
03:11:25 <Franciman> :S
03:11:47 <mm_freak_> dmwit: huh?  according to the spec that would be two NUL characters…  at least according to the parsing rules for UTF-8
03:11:51 <dmwit> Franciman: Probably packing string literals is going to be fine.
03:11:59 <dmwit> Franciman: Is that what you're doing?
03:12:12 <dmwit> mm_freak_: It's likely that I misunderstood the comment.
03:12:19 <Franciman> I haven't done anything yet, first asked here
03:12:20 <dmwit> The guy was a bit terse.
03:12:32 <Franciman> btw, it's fine
03:13:31 <dmwit> Packing a String that is determined at runtime is not recommended. Packing a String literal which you have verified to only have codepoints below 256 is probably fine, provided the thing you want is the bytes that correspond to those codepoints.
03:13:37 <mm_freak_> Franciman: anyway, as your question is about efficiency:  if the string you are comparing against is static and used multiple times turn it into CAF…  that should give the highest throughput
03:13:45 <mm_freak_> CAF is just a top-level non-function
03:14:02 <JesusIsLord> monomorphic* ?
03:14:03 <Franciman> yeah, that's what I do
03:14:10 <mm_freak_> yeah, add monomorphic
03:14:21 <dmwit> If you are just checking a magic number, I would recommend using getWord32le or some such thing and comparing against a Word32 constant.
03:14:24 <dmwit> You won't get faster than that.
03:14:25 <Franciman> I have several CAFs, with all the possibles strings
03:15:28 <Franciman> I think in the end I'll rely on Data.Binary.Get
03:15:48 * dmwit -> bed
03:15:50 <dmwit> ?localtime
03:15:51 <Franciman> night
03:15:54 <lambdabot> Local time for dmwit is Tue May  1 06:15:29 2012
03:16:02 <womb> guys what to omit to build fastest possible code in haskell. are there any obviouse performance traps ?
03:16:21 <mm_freak_> womb: String
03:16:38 <mm_freak_> night dmwit
03:17:00 <mm_freak_> womb: wait…  fastest way to build haskell code or way to build fastest haskell code?
03:19:05 <womb> mm_freak_: best performance code which is still not bad to write and readable
03:19:20 <womb> mm_freak_: why string is bad and why should i use something different like ByteString ?
03:19:41 <mm_freak_> womb: String = [Char]
03:19:48 <mm_freak_> i.e. a linked list of character codes
03:20:01 <womb> i'm looking into haskell only because the performance is really good i'm not type freak of PhD student :D
03:20:04 <mm_freak_> womb: getting rid of finite lists is a good start
03:20:10 <Franciman> 1 byte is useful, 4 bytes are wasted for the link
03:20:29 <mm_freak_> Franciman: note:  Char /= Word8
03:20:34 <mm_freak_> more like Word32
03:20:35 <womb> i know that String ++ String is bit killa
03:20:36 <womb> :D
03:20:41 <Franciman> oh really ?
03:20:41 <mm_freak_> womb: not at all
03:20:55 <mm_freak_> String can be fast, if you know where to use it =)
03:20:57 <blackdog> womb: the profiling tools are pretty good in haskell. general advice is to just write it as simply as you can then profile.
03:20:57 <Franciman> it also supports UTF?
03:21:07 <mm_freak_> Franciman: unicode
03:21:10 <mm_freak_> Franciman: Char is not encoded
03:21:25 <mm_freak_> it contains the raw unicode codepoints
03:21:27 <Franciman> I should definetely whatch that video
03:21:31 <Franciman> lol
03:21:36 <womb> that was my approach in Ruby, Erlang and Node.js and i never ended up having time to profile...but also never needed to.
03:21:36 <mm_freak_> hehe
03:21:49 <mm_freak_> Franciman: just as haskell the video was an eye opener =)
03:21:56 <ChristianS> but ByteString is for bytes, not for text (unicode), in spite of the somewhat misleading name.
03:21:57 <womb> usually if i got performance around ~20k req/sec it was more thne needed
03:22:10 <mm_freak_> womb: don't worry…  haskell code is usually Fast Enough
03:22:18 <ChristianS> Data.Text is the faster [Char] alternative.
03:22:22 <alpounet> there was a pretty cool blog post about charsets, encodings etc a few days ago
03:22:28 <JesusIsLord> haskell code is generally way faster than Ruby or Python
03:22:30 <mm_freak_> womb: but if you really want to get to the edge the first step is to get rid of finite lists
03:22:31 <blackdog> womb: if you can get ruby to run fast enough, i take my hat off to you :)
03:22:47 <mm_freak_> womb: note that you get rid of /finite/ lists
03:22:52 <mm_freak_> infinite lists are fine
03:22:58 <bitonic> jaspervdj: two questions: 1) do you plan to switch websockets to conduits and 2) how hard would it be to implement hixie-76, considering that I have no websockets experience?
03:23:07 <mm_freak_> use Data.Sequence, Data.Map, Data.Text, etc.
03:23:18 <mm_freak_> there is a fast data structure for just about any purpose
03:23:57 <womb> blackdog: its not that hard, use cuba framework but memory footprint is insane.
03:25:17 <womb> when you get into point where your solution requires more then 8 gb of rame to run smoothly on your load you start to refactor ;p that why i went erlang way and i'm now trying to switch some things into haskell.
03:25:39 <womb> i would love to be maths freak but i'm not i'm a guy who hits the wall of reality ;p
03:25:42 <bitonic> jaspervdj: ah wait, hixie-76 = hybi-00
03:26:36 <blackdog> womb: a lot of things are easier in haskell. having tangled with stuff like eventmachine in ruby, it's really nice to be able to just spin off a cheap thread and not worry about it.
03:27:29 <jaspervdj> bitonic: I might port it to conduit, but I want to support both snap and wai
03:27:53 <jaspervdj> bitonic: and supporting them both is currently easier using enumerator
03:27:58 <womb> blackdog: you read my mind, eventloop is easy and all reactor things to write untill you get into problems and you have to refactor it.... reasoning about fork-join model is just easy
03:29:02 <mm_freak_> womb: IMO haskell is not a mathematical language
03:29:07 <mm_freak_> it's a natural language
03:29:13 <bitonic> jaspervdj: ok. Another thing, in the github readme I see Rfc6445, but it's not there in the haddock docs
03:29:44 <jaspervdj> bitonic: the hybi10 implementation is compatible with it
03:29:51 <bitonic> jaspervdj: understood, thanks :)
03:30:50 <mm_freak_> the "natural" part of that opinion needs some justification and you can find it in my recent -beginners post:  http://article.gmane.org/gmane.comp.lang.haskell.beginners/9877
03:30:59 <womb> mm_freak_: you probably have more experience in it then me. :) I simply need to learn more :)
03:32:06 <bitonic> jaspervdj: so I won't have problems in using `websockets' as a library with `warp', right? (which is why I asked about conduits)
03:32:57 <womb> mm_freak_: for me haskell requires some tools for easier package managment like cabal-dev included by default into cabal and easy setup and also easy productiond peloyment tool like ruby has capistrano :) That would make it nuke! imo :)
03:33:42 <mm_freak_> womb: for some reason i find regular cabal to be easier to work with than cabal-dev
03:33:53 <mm_freak_> but i cheat:  i make backups before i update
03:36:57 <Franciman> mm_freak_, the Get monad is amazing, it's saved me from watching that loooooong vid ( for now )
03:37:03 <womb> mm_freak_: Data.Text is wow good !!!
03:38:01 <womb> just by very basic example https://gist.github.com/2567091 i could roll on with hindu, swe, polish chars https://gist.github.com/2567091
03:38:04 <womb> yay!!!
03:40:03 <mm_freak_> Franciman: the video doesn't address your exact problem…  it is a general discussion about what's wrong with your current thought patterns
03:40:03 <womb> ok sorry for spamming :D i will shut now :D let me play with Data.Text =)
03:40:21 <Franciman> yeah in fact, I'll read it
03:40:33 <mm_freak_> womb: String can handle all those, too, but Data.Text is more convenient and in most cases faster and always requires less memory
03:41:37 <mm_freak_> womb: you would want to use String when your processing is designed such that you process one or two characters at a time
03:43:13 <mm_freak_> i.e. when you use the string like a stream of characters, not as an array of them
03:44:58 <Franciman> people, to check whether the first 4 chars of a byte string match a determinate pattern
03:45:28 <Franciman> I cannot use pattern matching ( e.g. ('x':'k':'k':rest) ) like for strings
03:45:30 <Franciman> right?
03:45:33 <womb> mm_freak_: i'm using 64bit build of Haskell i had problems with hGetsContext and unicode characters he was blowing up
03:45:38 <JesusIsLord> Franciman: correcft
03:45:45 <womb> mm_freak_: with regular string
03:45:54 <Franciman> must check for equality in a guard so
03:50:03 <mm_freak_> Franciman: you can use a combination of OverloadedStrings and ViewPatterns
03:50:11 <mm_freak_> f (B.take 4 -> "blah") = …
03:50:39 <Franciman> I'll just use (==)
03:50:47 <mm_freak_> that was my point =)
03:50:48 <Franciman> in this case it's more appropriate
03:50:55 <Franciman> of course, thanks :)
03:50:55 <mm_freak_> ByteString is not an algebraic type
03:52:24 <Franciman> yes
03:53:21 <mm_freak_> apropos ADTs
03:54:52 <mm_freak_> i have found that when a monad is based on an AST-like data structure (including lists and trees) you should write a bird-style folding combinator…  then Functor, Applicative and Monad can all be simple one- or two-liners
03:56:01 <mm_freak_> that's always possible, but not always useful…  but it's very useful for recursive types
03:56:14 <Franciman> nice
04:01:03 <Doodu> http://www.facebook.com/TBNew/info
04:01:56 <mysticc> I was doing kind level programming , but stuck at how to check if two types are same .. type Instance Eq a b = <A type if a==b else B type> ?
04:03:37 <merijn> I think you can do use ~ in GHC for checking for type level equality
04:03:59 <quicksilver> he's gone merijn
04:04:20 <merijn> aww
04:04:26 <merijn> Was I at least right?
04:04:44 <quicksilver> yes.
04:04:51 <merijn> Close enough for me :p
04:05:25 <merijn> mysticc: You can use ~ in GHC to check for type level equality
04:07:18 <meric> So I have a recursive loop function. Each iteration I want to check if an argument has been checked before. To add the arguments to memory, I thought of using a hash map (which is passed through the loops). But if I insert a argument into a hash map each iteration (new hash map created), wouldn't it be much slower than using a shared hash map?
04:07:37 <JesusIsLord> why not use Data.Map ?
04:07:58 <meric> When i use Data.Map insert it doesn't copy the Map?
04:08:06 <JesusIsLord> no, only partially
04:08:11 <merijn> meric: Only the tree from the changed node to top
04:08:19 <meric> Ahh awesome
04:08:20 <merijn> so O(log n)
04:08:40 <JesusIsLord> thanks to immutability most of the data can be shared between the old Map and the new Map
04:09:18 <JesusIsLord> this is one of the reasons haskellers like trees more than hashtables
04:09:30 <mm_freak_> merijn: btw, you need TypeFamilies for ~
04:10:06 <mm_freak_> this is really exciting:  fold :: Fold a -> MyType -> a
04:10:10 <mm_freak_> because Fold is a Functor
04:11:12 <mm_freak_> and you can derive complicated operations from the identity fold Fold MyType
04:11:21 <merijn> Man, when I look at the source of stuff like Control.Comonad.Trans.Store I really feel completely unable to grok haskell >.>
04:12:28 <quicksilver> mm_freak_: do you? I thought ~ was used in the translation of GADTs as well, now.
04:13:00 <mm_freak_> quicksilver: you're right…  GADTs suffice
04:13:11 <mm_freak_> merijn: when you remove all the layers of constructors it boils down to the gist, which is really just a function
04:13:28 <mm_freak_> merijn: interpret Array a b as a function from a to b
04:13:30 <quicksilver> merijn: it's not really a haskell grokking problem, is it - it's just that edwardk's code is very efficient for reuse.
04:13:39 <quicksilver> merijn: so it's more a question of grokking his libraries.
04:14:06 <merijn> quicksilver: By "efficient for reuse" you mean "so abstract it blows your mind", right? :)
04:14:16 <quicksilver> perhaps that is what I mean.
04:14:22 <mm_freak_> merijn: so abstract that you never write the same thing twice
04:14:36 <quicksilver> but more concretely I just meant that you need to understand extend and extract
04:14:48 <quicksilver> in order to understand instances which are, themselves, written in terms of extend and extract.
04:15:07 <merijn> I just wanted to have a different implementation for mapLens, thinking "how hard could it be". But I can already tell this will take the rest of my afternoon :p
04:15:10 <quicksilver> I doubt you have any problem with the actual haskell syntax part.
04:16:19 <merijn> To be fair, I didn't say the syntax was going to be the problem, just the abstraction level :p
04:16:44 <hpaste_> mysticc pasted “Type equalities” at http://hpaste.org/67908
04:16:49 <mysticc> merijn:
04:16:58 <mysticc> Any help with the above ^^
04:18:08 <quicksilver> you can't "really" do that, mysticc
04:18:16 <mysticc> quicksilver: Why ?
04:18:24 <quicksilver> because instances are open
04:18:37 <quicksilver> however there are reams of literature on what you can do
04:18:56 <quicksilver> mysticc: http://okmij.org/ftp/Haskell/typeEQ.html
04:20:01 <mm_freak_> merijn: recently edwardk stated that he might simplify the internals of data-lens
04:20:35 <mm_freak_> what is hidden behind the Store layer is really just this:  newtype Lens a b = Lens (a -> (b, b -> a))
04:21:22 <merijn> Yeah, I think I've figured out how to do what I want
04:21:55 <mm_freak_> merijn: i wonder what you want to achieve though…  data-lens is suitably general while being easy to use and very fast
04:22:44 <merijn> mm_freak_: It's just the mapLens that's unsuitable for me. As I have a map with a fixed unchanging set of keys, so it's very inconvenient that it will stuff everything inside a Maybe
04:23:06 <mm_freak_> merijn: then write your own lens for it
04:23:13 <mm_freak_> no need to reinvent lenses =)
04:23:17 <mm_freak_> use the 'lens' function
04:23:43 <DMcGill> When reading a file, is there a simple eof character in the same way that there are end of line ones?
04:23:45 <merijn> I can't believe I overlooked that one >.>
04:24:13 <merijn> DMcGill: There's no EOF character, even though some heathen languages pretend their is
04:24:22 <mm_freak_> DMcGill: there is a character for that, but you don't get it for EOF
04:24:53 <mm_freak_> EOF corresponds more to an event than a character
04:25:44 <mm_freak_> the EOF /character/ is rather for humans…  you can hit ctrl-d to exit a shell and most other stdin-reading programs…  ctrl-d sends the EOF character
04:26:16 <merijn> Well, at least I learned something about Lenses/Store :p
04:26:31 <mm_freak_> merijn: it would be terrible if you couldn't write your own lenses ;)
04:26:35 <DMcGill> thanks, I'll probably make a new parsing primitive that checks if the input is null (I'm making a parser combinator/generator library)
04:26:43 <merijn> mm_freak_: More a condition than an event
04:27:13 <liyang> More of an experience than an event.
04:27:16 <mm_freak_> DMcGill: yes, all parser combinator libraries have that primitive
04:27:47 <hpaste_> newbie pasted “NFData instance of Unboxed Vector” at http://hpaste.org/67910
04:28:25 <haskell_newbie> Which one is valid  instance.  seq or deepseq ?
04:28:52 <haskell_newbie> my code is working with seq but when I am changing it to deepseq
04:29:09 <haskell_newbie> it says Main: <<loop>>
04:31:43 <Svarg> if it's an unboxed vector wouldn't seq be all you want? since unboxed values are strict anyway
04:32:21 <quicksilver> haskell_newbie: deepseq is just a wrapper around rnf
04:32:46 <quicksilver> haskell_newbie: so by defining rnf using deepseq you are creating an infinite loop, hence <<loop>>
04:32:52 <Ngevd> Hello
04:32:55 <JesusIsLord> hi Ngevd
04:33:24 <Ngevd> I've rewritten my family tree library using text and cereal
04:33:47 <haskell_newbie> quicksilver: So how to evaluate the whole vector rather than WHNF
04:34:26 <Svarg> haskell_newbie: if it's an unboxed vector you don't have to - everything stored in it will be strict
04:34:53 <Ngevd> So...
04:35:30 <haskell_newbie> Svarg , quicksilver Thank you
04:35:59 <Svarg> no problem
04:36:11 <Ngevd> Now what? :/
04:36:36 <mm_freak_> Ngevd: while we're on topic write a useful lens for it =)
04:36:58 <mm_freak_> see the data-lens package
04:38:36 <Ngevd> intMapLens seems useful?
04:38:43 <Ngevd> Saying that, I don't know what a Lens is
04:40:27 <mm_freak_> Ngevd: a lens is an abstraction to focus on fields of a record, where you have abstract notions of "field" and "record"
04:40:47 <mm_freak_> in a map a "field" can be a map element and the map itself is the "record"
04:41:36 <mm_freak_> and "to focus" means that you can get and manipulate that particular "field"
04:41:54 <Ngevd> mm_freak_, that... would actually be really useful
04:42:09 <mm_freak_> (fstLens ^= x) (a, b) = (x, b)
04:43:44 * hackagebot tfp 0.6 - Type-level programming library using type families  http://hackage.haskell.org/package/tfp-0.6 (PeterGavin)
04:47:01 <Ngevd> mm_freak_, yeah, intMapLens is precisely what I want
04:48:17 <Ngevd> Wow, yeah, that IS really useful
04:49:47 <mm_freak_> sure =)
04:50:20 <Ngevd> My FamilyTree type is IntMap Person
04:50:58 <mm_freak_> http://strictlypositive.org/notanum.ps.gz ⇐ in this paper conor defines a calculus with variables, application and universal quantification…  simplified:  data Expr = Var Name | App Expr Expr | Forall Expr Expr
04:51:22 <mm_freak_> he is using de bruijn indicies, so i wonder why Forall takes two expressions…  could somebody shed some light onto that?
04:51:44 <Ngevd> The first Expr should be a Var
04:51:53 <JesusIsLord> wild guess: domain?
04:51:59 <Ngevd> As in, you'd say ForAll (Var Foo) Bar
04:52:00 <mm_freak_> yes, it's domain
04:52:04 <JesusIsLord> (forall x. x > 10. x > 0)
04:52:15 <Ngevd> That works too
04:52:18 <mm_freak_> Ngevd: no, it's de bruijn indices…  conor calls the first expression "domain"
04:52:23 <Ngevd> Ah
04:52:30 <Ngevd> JesusIsLord is right, then
04:52:48 <mm_freak_> JesusIsLord: i don't know how to parse that
04:53:05 <JesusIsLord> (forall x: x > 10 : x > 0) means (forall x :: x > 10 ==> x > 0)
04:53:18 <Ngevd> mm_freak_, if you have an x that is more than 10, no matter what, that x is more than 0
04:53:26 <mm_freak_> JesusIsLord: are you saying that "domain" is really just another name for "type"?
04:53:59 <mm_freak_> because i've been assuming that his calculus is untyped
04:54:30 <mm_freak_> (mostly because there is no Set type)
04:54:55 <Ngevd> mm_freak_, I don't think so. It's more like restriction
04:54:59 <mm_freak_> oh, btw, replace "Var Name" by "Var Index", obviously
04:55:07 <Ngevd> If A is true, then B is true
04:55:21 <DMcGill> I have a type that I've made a monad but not a functor. Is there an equivalent to (<*) or will I either have to define it myself or make a functor instance?
04:55:32 <mm_freak_> hmm…  i see…  i guess i was wrongly assuming that it's a lambda calculus
04:55:51 <JesusIsLord> mm_freak_: i was just guessing. i don't know. :)
04:55:55 <JesusIsLord> DMcGill: <*> is ap
04:55:56 <mm_freak_> DMcGill: there is no predefined (<*) for monads
04:56:38 <Svarg> mm_freak_: i would think the first argument to Forall would be the type
04:56:40 <DMcGill> it's simple enough to define, do {x <- m1; m2; return x}  I believe
04:56:44 <Ngevd> :t liftM2 const
04:56:45 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m a1
04:56:49 <Ngevd> :t (<*)
04:56:50 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
04:57:02 <DMcGill> Ngevd: thanks, exactly what I was looking for
04:57:12 <Ngevd> :)
04:57:14 <Ngevd> No problem!
04:57:20 <mm_freak_> Svarg: but there are no types in that calculus
04:57:31 <mm_freak_> or at least i don't see how to construct them
04:57:57 <mm_freak_> DMcGill: just define Functor and Applicative instances
04:58:03 <mm_freak_> it's good style to do that anyway
04:58:09 <Svarg> how does forall work in an untyped calculus? forall is basically a type level lambda, it introduces a type variable
04:58:33 <Ngevd> fmap = LiftM; pure = return; (<*>) = ap
04:58:58 <Ngevd> Svarg, it's a restriction on the values that the second Expr apply to?
04:58:59 <Ngevd> Maybe?
04:59:04 <Ngevd> I haven't actually read the thing
04:59:34 <Svarg> i'm having a look through the paper atm
05:01:03 <mm_freak_> Svarg: the definition is on page 4
05:01:23 <mm_freak_> it's a bit extended…  i simplified it for the sake of my question
05:01:24 <Svarg> hmm i think i have the wrong version of the paper (looked for a pdf version so didn't use your link)
05:03:05 <mm_freak_> i read using KDE's okular…  it reads ps, pdf, dvi and a bunch more…  it also transparently removes .gz and .bz2 layers, so it's great for the web
05:03:59 <womb> :t (%)
05:04:00 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
05:04:40 <Svarg> mm_freak_: hmm, yeah that is strange
05:05:13 <hpaste_> merijn pasted “lens error?” at http://hpaste.org/67911
05:05:37 <merijn> Can anyone spot the error in that example?
05:06:58 <quicksilver> looks like you have two types called 'Lens' in scope, merijn
05:08:30 <Svarg> mm_freak_: perhaps types are introduced with names? the F constructor
05:08:43 <mm_freak_> Svarg: that might explain it, yeah
05:08:49 <mm_freak_> just a bit weird
05:08:52 <Svarg> yeah
05:09:18 <mm_freak_> anyway, i'll try to implement it
05:09:20 <quicksilver> merijn: perhaps your version of Data.Lens.Template is compiled against a different "data-lens" than the one that provides "Data.Lens.Lazy"
05:09:43 <Svarg> i'm not sure why but i don't like the idea of mixing debruijn indices with names.. but i haven't had enough experience with either in the context of implementing dependently typed languages
05:09:47 <merijn> quicksilver: ugh...isn't cabal supposed to handle that?
05:10:06 <merijn> quicksilver: I just ran "cabal install data-lens" and "cabal install data-lens-template"
05:10:23 <merijn> oh bollocks
05:10:39 <merijn> Looks like you're right, I see two different versions of data-lens
05:11:04 <merijn> What's the best way to uninstall both?
05:13:02 <quicksilver> @tell merijn would be interesting to understand why that didn't pick the same version of data-lens in each case; however the simple work around is to see which version your copy of data-lens-template is using and unregister the other.
05:13:02 <lambdabot> Consider it noted.
05:13:03 <mm_freak_> Svarg: well, i made an experiment before reading that paper…  in my experiment it turned out to be useless, because i don't have anything in my calculus the names could refer to…  but since everybody seems to use this approach i decided to read the paper
05:13:15 <quicksilver> merijn: would be interesting to understand why that didn't pick the same version of data-lens in each case; however the simple work around is to see which version your copy of data-lens-template is using and unregister the other.
05:13:43 <mm_freak_> Svarg: now locally nameless means that you never have free de bruijn indices, so my experiment didn't implement the idea as supposed
05:13:58 <mm_freak_> that's why i'm giving it another try now
05:14:33 <mm_freak_> my current sample language is untyped, btw
05:15:20 <Svarg> ah
05:16:05 <t7> untyped!
05:16:12 <mm_freak_> i think the basic idea is to turn application into something resembling 'let'
05:16:16 <t7> might aswel be back in the stone age
05:16:33 <mm_freak_> t7: it's just a sample language where i explore the locally nameless implementation
05:16:41 <mm_freak_> types would just complicate the core experiment
05:16:43 * t7 googles locally nameless
05:16:52 <mm_freak_> t7: http://namebinding.wordpress.com/2009/10/14/i-am-not-a-number-im-a-free-variable/
05:17:06 <merijn> quicksilver: Ah, yeah. Unregistering the newer data-lens fixed it :)
05:17:06 <lambdabot> merijn: You have 1 new message. '/msg lambdabot @messages' to read it.
05:17:13 <merijn> quicksilver: Thanks
05:17:24 <koala_man> let's say you have a bunch of points distributed uniformly randomly in space with an average nearest neighbor distance of 1, and you randomly remove half the points from the set
05:17:42 <koala_man> what happens to the average neighbor distance?
05:19:16 <hiptobecubic> koala_man, increases by something like factor of sqrt 2?
05:19:19 <ziman> i'd say it depends on the dimension of the space
05:19:20 <byorgey> "uniformly randomly in space"? you mean like on [0,1] x [0,1] ?
05:19:22 <hiptobecubic> i'm guessing
05:19:34 <byorgey> ziman: ah, excellent point =)
05:19:36 <hiptobecubic> i was assuming euclidean 2d, but yes
05:21:26 <mm_freak_> byorgey: could you shed some light on the sample calculus conor uses in the paper about locally nameless?
05:21:34 <timtheli1n> hpast dead again???
05:21:43 <mm_freak_> he has universal quantification, but i don't see any types
05:21:46 <koala_man> byorgey: for example. with an equal probability of a point being anywhere
05:21:56 <koala_man> hiptobecubic: any reasoning behind that guess?
05:22:45 <byorgey> mm_freak_: which page?
05:22:50 <hiptobecubic> koala_man, if you imagine the points to be uniformly distributed but not random, i'd expect something like that
05:24:03 <byorgey> mm_freak_: well, it looks like Expr ARE types.
05:24:19 <hiptobecubic> in 2D space
05:24:26 <koala_man> hiptobecubic: you mean if they were on a grid or other pattern?
05:24:33 <byorgey> I don't think it really matters too much.  It's just an example to illustrate the technique.
05:24:50 <hiptobecubic> koala_man, i haven't written anything down so I don't want to place any money on this. but yes more or less
05:25:44 <koala_man> hiptobecubic: but then it would depend on the pattern. if square, a node would have 4 neighbors of distance 1, while if triangles, it would have 6. so you'd have to remove all of those to increase the distance
05:26:38 <koala_man> guess I could do some simulations
05:28:15 <hiptobecubic> koala_man, ah yeah no. I misunderstood a bit. If you're only considering a single neighbor then sure, it's pretty difficult to comment on this. simulation seems like a reasonable approach
05:28:25 <prabuinet> hi, can anybody explain me this: const (+1) 3 5
05:28:34 <hiptobecubic> :t const
05:28:36 <lambdabot> forall a b. a -> b -> a
05:28:51 <mm_freak_> byorgey: hmm, i see…  thanks…  although it might be too late now, it's page 4
05:29:03 <hiptobecubic> prabuinet, so the const function essentially 'ignores' the second argument
05:29:03 <prabuinet> which function is applied first, const or (+) ?
05:29:28 <hiptobecubic> > const a b c
05:29:29 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr -> t'
05:29:29 <lambdabot>         against infe...
05:29:41 <hiptobecubic> const 1 2
05:29:44 <hiptobecubic> >const 1 2
05:29:55 <hiptobecubic> > const 1 2  -- damnit :D
05:29:56 <lambdabot>   1
05:30:12 <hiptobecubic> > const 1 2 + 3
05:30:13 <lambdabot>   4
05:30:28 <prabuinet> hiptobecubic, right but in my case i have (+) in between
05:30:37 <sabrehagen> what's the preferred paste site in this channel?
05:30:39 <hiptobecubic> > (const (+1) 2) 3
05:30:40 <lambdabot>   4
05:30:43 <hiptobecubic> sabrehagen, hpaste i think
05:30:48 <sabrehagen> hiptobecubic: thanks
05:31:06 <hiptobecubic> "const a b"  becomes just "a"
05:31:22 <hiptobecubic> so const (+1) 2 becomes just (+1)
05:31:26 <Svarg> prabuinet: the (+ 1) is lazily evaluated - it's a thunk, doesn't get used until the whole const expression is evaluated
05:31:29 <hiptobecubic> which is then applied to 3
05:31:57 <hiptobecubic> even if it weren't lazily evaluated, it evaluates to a function which takes a value and adds one to it
05:32:34 <hiptobecubic> so "const (+1)"  is a function which takes an argument of any type and returns the function (+1)
05:33:09 <hiptobecubic> then we feed it "2", so (+1) is returned. then we feed that "3"
05:34:50 <prabuinet> hiptobecubic, const (+1) 3 returns (+1) , right?
05:37:36 <alpounet> :t const (+1) 3 -- prabuinet
05:37:37 <lambdabot> forall a. (Num a) => a -> a
05:37:47 <quicksilver> the order of evaluation doesn't matter for this example
05:38:11 <quicksilver> const (+1) 3 2 would be the same in a strict / innermost first language too.
05:38:25 <otters> > const (+1) 2 3
05:38:26 <lambdabot>   4
05:39:00 <prabuinet> is there any expansion for the word `const`?
05:39:05 <JesusIsLord> "constant function"
05:39:13 <ment> :t const
05:39:14 <lambdabot> forall a b. a -> b -> a
05:39:16 <prabuinet> thanks
05:39:28 <JesusIsLord> a constant function is for example f, where f(x) = 37, like in mathematics
05:39:37 <JesusIsLord> it does not depend on its argument.
05:39:47 <otters> it's a -1-ary function!
05:39:59 <JesusIsLord> all functions in Haskell are.
05:40:00 <prabuinet> ok
05:40:09 <otters> no, -1
05:40:14 <otters> for some definitions of arity
05:40:30 <JesusIsLord> I misread.
05:41:16 <Sakako> Technically, it's a 1-ary function
05:41:32 <Sakako> or even a 2-ary function
05:41:34 <otters> Sure, technically
05:41:55 <Sakako> it still requires input
05:42:29 <Sakako> isn't it defined something like... const f _ = f?
05:43:37 <JesusIsLord> Sakako: what is a "2-ary function"?
05:44:06 <JesusIsLord> Sakako: I'd write const x _ = x, f need not be a function.
05:44:37 <JesusIsLord> Sakako: "2-ary suggests" that it has to take 2 arguments, which is not the case.
05:45:02 <otters> const x = \_ -> x
05:45:04 <JesusIsLord> Even f :: (Integer,Integer)->Bool is not "2-ary" IMO, it accepts one argument of type (Integer,Integer).
05:45:14 <JesusIsLord> otters: That's the same.
05:45:17 <mm_freak_> wow, now i get the point of locally nameless
05:45:21 <otters> I like it better though
05:45:30 <JesusIsLord> Marginally, but yeah.
05:45:41 <mm_freak_> Lam . abstract "f" $ Lam . abstract "x" $ App "f" "x"
05:45:44 <mm_freak_> this is awesome
05:45:55 <hpc> JesusIsLord: by now you may have learned that arity is a totally useless distinction in haskell... ;)
05:45:58 <byorgey> mm_freak_: =D
05:46:01 <Sakako> ;)
05:46:05 <JesusIsLord> hpc: right.
05:46:08 <JesusIsLord> ;)
05:46:12 <mm_freak_> byorgey: thanks for that =)
05:46:16 <byorgey> mm_freak_: sure =)
05:46:26 <Sakako> As a rule of thumb, functions of type t1 -> t2 -> ... -> tn have n-1 arity
05:46:52 <mm_freak_> is it sensible to talk of arity for haskell functions?
05:46:58 <Sakako> Well, that's the thing I suppose
05:47:08 <Sakako> > const (+1)
05:47:09 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> a -> a)
05:47:09 <lambdabot>    arising from a use...
05:47:16 <hpc> my own definition of arity is "count the arrows down the right of the parse tree"
05:47:24 <Sakako> `const` definitely needs two inputs
05:47:25 <hpc> and leave type variables as type variables
05:47:26 <mm_freak_> Sakako: with that notion it is hard to justify the associativity rule for the function arrow
05:47:32 <mm_freak_> a -> b -> c = a -> (b -> c)
05:47:37 <hpc> (so really, my definition is n+k-arity
05:47:38 <hpc> )
05:47:41 <Sakako> hmm
05:48:16 <Sakako> Well, my point is that const x returns a lambda function which just returns x
05:48:16 <hpc> it corresponds more closely to (->) as exponentiation
05:48:17 <mm_freak_> and the former is basically just syntactic sugar for the latter
05:48:27 <hpc> with arity being the height of the outermost tower of power
05:48:34 <Sakako> the full function const does want two inputs
05:48:40 <hpc> and it's just easier for me to think about
05:48:42 <JesusIsLord> Sakako: maybe it wants 37.
05:48:45 <mm_freak_> Sakako: it wants one input
05:48:48 <Sakako> > const 2 "string"
05:48:49 <lambdabot>   2
05:48:51 <hpc> but it's not even remotely the "correct" definition
05:48:58 <JesusIsLord> const (\_ _ _ _ _ _ _ _ -> 37) "hello"
05:49:04 <mm_freak_> Sakako: note that the type variables in const's type are polymorphic
05:49:09 <mm_freak_> so they can be functions
05:49:10 <Sakako> Of course they are
05:49:18 <Sakako> but!
05:49:20 <mm_freak_> just like 'fix' can have any "arity" you want
05:49:24 <mm_freak_> or 'id'
05:49:31 <mm_freak_> > id sin 3
05:49:32 <lambdabot>   0.1411200080598672
05:49:35 <mauke> > flip id 3 sin
05:49:37 <lambdabot>   0.1411200080598672
05:49:58 <mauke> > flip flip 3 id sin
05:50:00 <lambdabot>   0.1411200080598672
05:50:17 <Sakako> That's not really a good example of what you're trying to say
05:50:26 <mm_freak_> Sakako: to establish a sensible notion of arity you first of all must assume monomorphism everywhere
05:50:28 <Sakako> as haskell is lazy and will try and evaluate flip first
05:50:34 <hpc> > flip flip flip 3 succ id sin
05:50:35 <lambdabot>   Ambiguous type variable `f' in the constraint:
05:50:35 <lambdabot>    `GHC.Base.Functor f'
05:50:35 <lambdabot>     ...
05:50:36 <hpc> :(
05:50:45 <mm_freak_> that has nothing to do with laziness, Sakako…  it has to do with types
05:50:48 <mm_freak_> id :: a -> a
05:50:55 <mm_freak_> 'a' can be x -> y
05:50:58 <Sakako> Of course it can
05:51:12 <Sakako> but when you're using id sin 3 as your function
05:51:17 <Sakako> it's not really displaying anything
05:51:32 <mm_freak_> it is…  it is displaying for example that ($) is just an instance of 'id'
05:51:41 <mm_freak_> by your notion 'id' has arity 1
05:51:41 <Sakako> hmm
05:51:46 <hpc> :t id
05:51:47 <mm_freak_> and ($) has arity 2
05:51:47 <lambdabot> forall a. a -> a
05:51:50 <hpc> :t id sin
05:51:51 <lambdabot> forall a. (Floating a) => a -> a
05:51:54 <mm_freak_> but ($) and id are the same function
05:51:59 <mm_freak_> > sin `id` 3
05:52:00 <Sakako> :t id sin 3
05:52:00 <lambdabot>   0.1411200080598672
05:52:00 <lambdabot> forall a. (Floating a) => a
05:52:07 <Sakako> :t flip id 3 sin
05:52:08 <lambdabot> forall b. (Floating b) => b
05:52:13 <JesusIsLord> "arity" is a pointless concept. It can be useful to stress to beginners that every function takes exactly one argument in Haskell.
05:52:16 <Sakako> they're the same though
05:52:20 <hpc> :t let id x = x; y = id sin x in id
05:52:21 <lambdabot> forall t. t -> t
05:52:24 <hpc> :(
05:52:30 <hpc> :t id `asAppliedTo` sin
05:52:31 <lambdabot> forall a. (Floating a) => (a -> a) -> a -> a
05:52:34 <hpc> there we go
05:52:40 <hpc> :t const
05:52:41 <lambdabot> forall a b. a -> b -> a
05:52:47 <Sakako> argh
05:52:47 <hpc> :t const `asAppliedTo` const
05:52:48 <lambdabot> forall b a b1. (a -> b1 -> a) -> b -> a -> b1 -> a
05:52:53 <Sakako> (a -> a) -> a -> a
05:52:56 <Sakako> is the same type as
05:53:00 <Sakako> (a -> a) -> (a -> a)
05:53:02 <mm_freak_> Sakako: the point is:  in a curried language the only sensible notion of arity is that all functions are of arity 1
05:53:06 <Sakako> since -> is right-associative
05:53:20 <Sakako> Well, maybe I'm being nonsensical
05:53:31 <hpc> Sakako: you're on the right track
05:53:32 <hiptobecubic> isn't there a lambdabot command to put parens around everything
05:53:34 <mm_freak_> Sakako: exactly…  but by your notion (a -> a) -> a -> a has arity 2, while (a -> a) -> (a -> a) has arity 1
05:53:44 <Sakako> No, that's not right at all
05:53:48 * hackagebot wumpus-core 0.52.1 - Pure Haskell PostScript and SVG generation.  http://hackage.haskell.org/package/wumpus-core-0.52.1 (StephenTetley)
05:53:51 <Sakako> oh wait
05:53:52 <Sakako> hmm
05:53:54 <hpc> Sakako: just pretend arity doesn't exist in haskell
05:53:55 <Sakako> yes.
05:54:05 <hpc> and use the types, luke
05:54:09 <JesusIsLord> hpc: it's not even "pretending", is it? :)
05:54:11 <Sakako> :3
05:54:12 <hpc> heh
05:54:25 <mm_freak_> well, arity does exist, but it's not very useful =)
05:54:30 <mm_freak_> just think of 'printf'
05:54:36 <JesusIsLord> I'd rather not.
05:54:37 <JesusIsLord> haha
05:54:39 <Sakako> XD
05:54:44 <hpc> pppsh, printf?
05:54:46 <hiptobecubic> printf still kind of blows my mind
05:54:46 <hpc> :t (=~)
05:54:47 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
05:54:49 <mm_freak_> then add higher rank types to make it even worse
05:54:55 <hpc> printf is weak tea
05:54:58 <hpaste_> sabrehagen pasted “typing” at http://hpaste.org/67916
05:55:00 <sabrehagen> hi, i'm trying to make a typesafe data type. i'm still quite new to these things. i *think* it's a form of GADT. What I have done is pretty pretty basic, but that's because i'm really not sure what to do.
05:55:19 <JesusIsLord> sabrehagen: you're on the right track.
05:55:29 <JesusIsLord> sabrehagen: you want "Term t" to be a "term of type t" ?
05:56:00 <sabrehagen> JesusIsLord: i believe so
05:56:09 <JesusIsLord> sabrehagen: the syntax is a bit different though. data Term t where { And :: Term Bool -> Term Bool -> Term Bool; Smaller :: Term Integer -> Term Integer -> Term Bool; ... }
05:56:29 <JesusIsLord> add data Bool and data Integer at toplevel, add GADTSyntax and EmptyDataDecls as extensions
05:56:35 <Sakako> Hmm. I think this "arity" problem arises because, let's face it, I really don't know any Haskell
05:56:38 <mm_freak_> sabrehagen: for this particular example a GADT will only use heavier syntax…  of course aesthetically speaking i'd still go with the GADT =)
05:57:19 <mm_freak_> Sakako: the insistence on having a real notion of arity comes from non-curried languages, where arity is a useful concept
05:57:20 <hiptobecubic> Sakako, well it's easy. Every function is of arity 1. The end.
05:57:43 <mm_freak_> but in haskell you really don't want to think in arity
05:58:11 <mm_freak_> it will stand in your way, because you will miss expression opportunities you would see if you wouldn't wire your brain to assume fixed arities everywhere
05:58:12 <sabrehagen> JesusIsLord: {-# LANGUAGE GADTs, EmptyDataDecls #-} and data Bool and data Integer in my code?
05:58:16 <Sakako> I never really have call to code in it, is probably the problem :p
05:58:22 <hiptobecubic> If you need a function of arity 2, you just haev a function of arity 1 which returns a second function (also arity 1), and 1 + 1 is two so you are victorious.
05:58:25 <JesusIsLord> sabrehagen: yes, plus what I said about data Term t ...
05:58:32 <Sakako> Ah, yep
05:58:38 <hpc> http://hpaste.org/67918 -- here's a simple GADT
05:58:44 <Sakako> that's the whole thing with passing into higher-order functions right?
05:58:54 <hpc> with all the right syntax and stuff
05:58:56 <sabrehagen> JesusIsLord: ahh yes, i missed that, thanks
05:59:15 <mm_freak_> Sakako: that's not really related to higher order functions…  it's currying
05:59:26 <dekuked> what's a gadt
05:59:34 <JesusIsLord> dekuked: a generalized algebraic data type.
05:59:47 <mm_freak_> every function is of arity 1…  multiple arguments = functions returning functions
05:59:58 <hpc> dekuked: in a GADT, you can match on type variables
05:59:58 <Sakako> Hm. The only thing I really know about currying is it lets you convert things from tuples.
06:00:09 <quicksilver> not really tuples.
06:00:09 <JesusIsLord> Sakako: "things"?
06:00:09 <hpc> like the paste i wrote above (http://hpaste.org/67918)
06:00:13 <mm_freak_> Sakako: which other language do you know?
06:00:16 <hiptobecubic> Sakako, what language are you most familiar with/
06:00:18 <parcs`> Sakako: LYAH explains all these things well if you are willing to read a book
06:00:26 <Sakako> I have read LYAH
06:00:28 <quicksilver> tuples are are just an ugly way to "represent" curry within haskell
06:00:33 <quicksilver> they're not really what currying is.
06:00:36 <Sakako> Ah, okay.
06:00:41 <hpc> :t curry
06:00:42 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
06:00:44 <hpc> :t uncurry
06:00:45 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
06:00:48 <Sakako> So the function `curry` is more of a misnomer?
06:00:58 <quicksilver> currying is the map from functions which take multiple arguments to functions which just take one argument (and return a function)
06:01:05 <quicksilver> haskell doesn't actually *have* functions with multiple arguments
06:01:09 <quicksilver> so we can't really represent that
06:01:13 <quicksilver> but tuples are like a model of it.
06:01:15 <Sakako> Oh.
06:01:17 <Sakako> OH!.
06:01:19 <Sakako> I see.
06:01:20 <mm_freak_> Sakako: in C you write f(x, y, z)
06:01:31 <mm_freak_> now think you would have to write:  f(x)(y)(z)
06:01:46 <Sakako> or just f x y z?
06:01:52 <quicksilver> in javascript, for example, function(a) { return function(b) { return (a+b) } }
06:01:53 <JesusIsLord> Sakako: mimicking C syntax.
06:01:54 <mm_freak_> yeah, in haskell you write f x y z
06:02:04 <quicksilver> is the curried version of function(a,b) { return (a+b) }
06:02:05 <Sakako> oh right
06:02:13 <mm_freak_> and note the left-associativity of application:  f x y = (f x) y
06:02:19 <mm_freak_> this is currying
06:02:31 <Sakako> Ahhh.
06:02:33 <hpc> :t const
06:02:33 <lambdabot> forall a b. a -> b -> a
06:02:35 <mm_freak_> or rather this is the gist of currying
06:02:35 <Sakako> I guess that makes sense
06:02:36 <hpc> :t const False
06:02:37 <lambdabot> forall b. b -> Bool
06:02:41 <hpc> :t const False True
06:02:41 <lambdabot> Bool
06:03:04 <Sakako> so (const False) is a function
06:03:14 <JesusIsLord> Sakako: yes
06:03:15 <mm_freak_> in (f x) y the "f x" is a function in its own right
06:03:17 <Sakako> is (const False True) technically a function too?
06:03:22 <JesusIsLord> Sakako: no
06:03:28 <JesusIsLord> Sakako: it's a value of type Bool
06:03:30 <hpc> (const False True) = False
06:03:36 <Sakako> Yeah, I get that
06:03:38 <JesusIsLord> Sakako: functions are values of type a -> b (for some a, b)
06:03:41 <hpc> (const False) = \_ -> False
06:03:46 <Sakako> Oh, so they need to return something
06:03:52 <hpc> hence "const", for "constant function"
06:03:52 <mm_freak_> Sakako: polymorphism complicates this a bit
06:04:01 <mm_freak_> const x y /can/ be a function
06:04:04 <koala_man> hiptobecubic: simulations indicate that the nearest neighbor distances increases by sqrt(2) when halving nodes, like you sort of said.
06:04:08 <Sakako> but only if x is a function?
06:04:12 <mm_freak_> yes
06:04:12 <JesusIsLord> Sakako: yes
06:04:13 <koala_man> while the average distance between all stays the same
06:04:15 <hpc> (const x y) = x
06:04:26 <Sakako> so it's basically \xy.x
06:04:28 <hpc> yes
06:04:31 <hpc> it's exactly that
06:04:33 <Sakako> er
06:04:34 <Sakako> yeah
06:04:35 <Sakako> exactly
06:04:37 <mm_freak_> well, almost
06:04:40 <hiptobecubic> koala_man, it's what I actually said, i think. But I can't take much credit there, it wasn't as well thought out as it could have been.
06:04:41 <tromp> AKA K
06:04:47 <hpc> \x.\y.x
06:04:48 <Sakako> aka church-true
06:04:50 <hpc> but yeah
06:05:03 <Sakako> (\x.\y collapses to \xy iirc)
06:05:07 <mm_freak_> the translation to lambda calculus would be:  forall A B. \(x : A) (y : B) -> x
06:05:09 * hpc forgets if λcalc is curried
06:05:27 <Sakako> Lambda calculus isn't typed though
06:05:32 <Sakako> so in that
06:05:37 <Sakako> everything is literally a function
06:05:40 <mm_freak_> "lambda calculus" is a family of calculi
06:05:42 <hiptobecubic> untyped-lambda calculus isn't
06:05:50 <Sakako> ah, ok
06:06:11 <koala_man> hiptobecubic: yes, you said it, and then you said you'd misunderstood the problem. in any case, I'm impressed
06:06:12 <Sakako> Every time I've heard of lambda calculus that wasn't untyped it's been noted, like "typed lambda calculus"
06:06:56 <mm_freak_> Sakako: "lambda calculus" is ambiguous…  you'll want to refer to "untyped lambda calculus", if you want to assume no types
06:07:02 <hiptobecubic> koala_man, I was imagining taking the "appropriate" number of nearest neighbors for a given uniform configuration
06:07:18 <hiptobecubic> koala_man, glad it worked though. Any reason to test or just curious?
06:07:20 <hpc> mm_freak_: or if you want to assume turing-completeness, or pretty much anything :P
06:07:27 <Sakako> :p
06:07:27 <mm_freak_> hehe yeah
06:07:32 * hpc has always seen "lambda calculus" default to "untyped"
06:07:33 <hpaste_> sabrehagen pasted “wikibooks” at http://hpaste.org/67919
06:07:41 <Sakako> that's what I'm saying hpc
06:07:52 <hpc> indeed
06:08:06 <sabrehagen> i'm looking at a GATDs example on wikibooks, isn't it lacking in its ability to check if booleans are equal?
06:08:09 <mm_freak_> i've seen "lambda calculus" default to "no assumptions"
06:08:20 <Sakako> No assumptions?
06:08:23 <sabrehagen> found here: http://hpaste.org/67919
06:08:32 <tromp> no assump == ambiguous
06:08:33 <JesusIsLord> sabrehagen: yes, correct
06:08:51 <Sakako> No assumptions just seems like it wants to default to something else
06:08:55 <quicksilver> I think lambda calculus is a syntactic system.
06:08:56 <sabrehagen> JesusIsLord: is it possible to add that functionality without making an ambiguous reference?
06:09:02 <quicksilver> type theory is a higher level thing.
06:09:11 <JesusIsLord> sabrehagen: well you could add If :: Expr Bool -> Expr a -> Expr a.
06:09:14 <mm_freak_> Sakako: most texts about "lambda calculus" are type-correct
06:09:17 <quicksilver> you can attempt to apply all kinds of typing rules to classify lambda calculus terms
06:09:24 <quicksilver> without changing the calculus itself
06:09:27 <Sakako> Yeah, quicksilver's on the right track, at least in my understanding
06:09:33 <JesusIsLord> sabrehagen: alternatively, you could write Eq :: Eq a => Expr a -> Expr a -> Expr Bool
06:09:33 <hpc> JesusIsLord: need another Expr a branch in there
06:09:39 <JesusIsLord> hpc: yeah, ty.
06:09:43 <hpc> or that
06:09:43 <mm_freak_> quicksilver: that line blurs the more you move towards dependent types
06:10:15 <hpc> many people use GADTs to write typed DSLs
06:10:15 <sabrehagen> JesusIsLord: hmm, okay. thanks.
06:10:26 <JesusIsLord> sabrehagen: then equality for booleans would become something like If x y (Not y)
06:10:41 <Sakako> Sorry if I'm misunderstanding stuff. I'm stuck in a modal logic purely-syntax mood.
06:10:51 <sabrehagen> JesusIsLord: ahh i see, kind of a workaround?
06:10:53 <Sakako> Due to an assignment being due in... 14 hours.
06:11:08 <JesusIsLord> sabrehagen: Yes, in some way.
06:11:26 <JesusIsLord> sabrehagen: You could also add EqBool :: Expr Bool -> Expr Bool -> Expr Bool
06:11:34 <JesusIsLord> sabrehagen: There are many solutions.
06:11:38 <quicksilver> mm_freak_: doesn't make any difference until the types start to appear in your term language.
06:11:52 <quicksilver> mm_freak_: once you have that, it's no longer (just) lambda calculus.
06:12:05 <koala_man> hiptobecubic: I was considering dbscan on huge datasets, if you reduce them by dropping nodes
06:12:11 <mm_freak_> quicksilver: are you saying that \(A : Set) -> A is not a term from a lambda calculus?
06:12:11 <koala_man> I mean points
06:12:16 <quicksilver> as long as your term language is simply lambda calculus that's all it is - a syntactic rewrite system for terms.
06:12:23 <quicksilver> mm_freak_: yes, that's exactly what I'm saying.
06:12:29 <mm_freak_> ok, i get your point
06:12:37 <quicksilver> mm_freak_: lambda calculus does not have type annotations in its syntax.
06:13:11 <mm_freak_> it just appears to be bold to say that "typed lambda calculus is not calculus"
06:13:12 <quicksilver> much like the fragment of haskell without type annotations, it's still useful and expressive.
06:13:14 <Sakako> An alternate way I've seen "typed lambda calculus" written is as "lambda calculus with types"
06:13:35 <quicksilver> (and aren't there some dialects of ML that don't permit type annotations in expressions, only on declarations?)
06:13:40 <mm_freak_> s/not calculus/not lambda calculus/
06:13:55 <mm_freak_> i don't know any
06:14:00 <sabrehagen> JesusIsLord: I'm confused as to how to type Con Val in http://hpaste.org/67916. Would you say Con Term Val?
06:14:09 <mm_freak_> not allowing type annotations indicates a weak type system
06:14:10 <quicksilver> mm_freak_: 1st rule of lambda club: if you're not in barendregt, you're not coming in.
06:14:48 <quicksilver> mm_freak_: not at all. Not requiring type annotations indicates a strong (fully inferred) type system.
06:15:01 <JesusIsLord> sabrehagen: no.
06:15:09 <mm_freak_> quicksilver: not "weak" in the sense of "weak typing", but in the sense of "not powerful"
06:15:15 <quicksilver> sure.
06:15:26 <Sakako> Lambda calc's lack of typing gives problems
06:15:34 <JesusIsLord> sabrehagen: ConBool :: Bool -> Expr Bool; ConInteger :: Integer -> Expr Integer
06:15:36 <Sakako> when you say \xy.y
06:15:39 <Sakako> or \sz.z
06:15:47 <Sakako> is it "false" or is it "zero"?
06:16:07 <mm_freak_> Sakako: lack of types isn't bad for a theoretical construct like the lambda calculus
06:16:07 <Sakako> they're the same thing
06:16:20 <Sakako> Yeah, it's not meant for DOING things, of course XD
06:16:28 <Sakako> that's why haskell needs types
06:16:37 <Sakako> or even why typed lambda needs types
06:16:41 <statusfailed> Can I have where clauses in anonymous functions?
06:16:52 <mm_freak_> well, scheme is for doing things…  and it's essentially a translation of lambda calculus with some syntactic sugar
06:17:00 <mm_freak_> statusfailed: no
06:17:00 <quicksilver> yes, statusfailed, however.....
06:17:00 <JesusIsLord> statusfailed: no. ... where ... is not an expression.
06:17:14 <mm_freak_> statusfailed: you can have 'let'
06:17:23 <quicksilver> you can't attach them directly to the lambda, because where only attaches to declarations
06:17:24 <mm_freak_> and you can have 'where' in 'let'
06:17:43 <statusfailed> let in \x -> y where y = ... ?
06:18:12 <statusfailed> is that just gross though? :P
06:18:15 <sabrehagen> JesusIsLord: Gah, it makes perfect sense when you write it. Why can't I just see that when I try to work it out!
06:18:20 <mm_freak_> statusfailed: no, that's a syntax error
06:18:30 <mm_freak_> statusfailed: 'where' is attached to definitions, not expressions
06:18:40 <mm_freak_> let x = y where y = z in …
06:18:46 <statusfailed> oh I see
06:19:06 <quicksilver> let x = \y -> blah where .... in x
06:19:06 <statusfailed> but then I might as well just use let, right?
06:19:09 <quicksilver> if you really want
06:19:15 <quicksilver> you probably might as well use let, yes.
06:19:25 <statusfailed> ok
06:19:26 <statusfailed> thanks all
06:19:52 <mm_freak_> statusfailed: 'let' and 'where' are equally powerful…  in fact 'where' is just syntactic sugar for 'let'
06:21:59 <applicative> > let y = (1,'a') ; x = z where (z,_) = y in x
06:22:00 <lambdabot>   1
06:22:31 <t7> mm_freak_: u ever mess around with hindley milner?
06:23:03 <mm_freak_> t7: not really…  i want to experiment with an own approach to value/type inference
06:23:28 <t7> its a pain in the bum
06:23:50 <t7> but i got it working with help from bitonic
06:24:04 <mm_freak_> t7: isn't your language dependently typed?
06:24:37 <bitonic> t7: HM is unification + a couple of rules
06:24:55 <bitonic> I remember Saizan posting 5 lines of Prolog implementing HM
06:25:09 <t7> yeah but the rules seem ambigious
06:25:21 <mm_freak_> bitonic: "prolog" as in the language or as in haskell's type system? =P
06:25:35 <t7> when i look at the type rules on wikipedia, there is loads of stuff in other peoples implementation that isnt in the wiki pic
06:25:37 <sabrehagen> JesusIsLord: When I compile, I'm getting the error Invalid type signature: Or :: Term Bool -> Term Bool -> Term Bool, Should be of form <variable> :: <type>, but no complaints about any other line. Why would this be?
06:25:59 <JesusIsLord> sabrehagen: I'm not sure. Could you paste your code?
06:26:02 <sabrehagen> JesusIsLord: sure
06:26:15 <mm_freak_> t7: the original HM is designed to infer types in polymorphic lambda calculus
06:26:19 <bitonic> mm_freak_: Prolog as in the language
06:26:23 <mm_freak_> no contexts, no type classes, etc.
06:26:46 <mm_freak_> and implicit rank-1 universal quantification
06:27:02 <hpaste_> sabrehagen pasted “full_code” at http://hpaste.org/67920
06:27:12 <sabrehagen> JesusIsLord: pasted above
06:27:31 <JesusIsLord> sabrehagen: I'm not sure why you have those semicolons.
06:27:32 <hpc> sabrehagen: semicolons
06:28:07 <sabrehagen> JesusIsLord: hmmm, looks like C was subconsiously getting through...:/
06:28:21 <JesusIsLord> sabrehagen: you can use ; and { in Haskell as well ;) but please don't
06:28:28 <sabrehagen> JesusIsLord: sorry for the retarded mistakes...
06:28:54 <JesusIsLord> No problem, error messages aren't always obvious.
06:29:06 <quicksilver> not quite sure why those semicolons are illegal
06:29:13 <t7> JesusIsLord: is your name ironic
06:29:14 <quicksilver> they seem reasonable to me
06:29:18 <JesusIsLord> t7: Very.
06:30:03 <t7> i find it hard to accept that someone with the mental capacity to learn haskell could believe such things
06:30:12 <JesusIsLord> Religious debates to -blah please ;)
06:30:14 <hpc> quicksilver: the semicolons probably end the data definition
06:31:05 <mm_freak_> t7: his name is just a type annotation
06:31:05 <quicksilver> hpc: I thought data ..where was a layout block with semis between members and it was always legal to choose to make them explicit.
06:31:33 <td123> mm_freak_: haha
06:32:35 <applicative> Smaller makes a Term Bool I expect
06:32:52 <JesusIsLord> applicative: good catch.
06:35:32 <sabrehagen> JesusIsLord: I have an instance which I have to match which has "show (Con v) = show v" predefined. Rather than having separate Bool and Integer constructors, should I write Con :: a -> Term a?
06:36:45 <dekuked> just out of curiosity, is haskell being used in any AAA sort of game titles? I remember seeing that presentation by epic a while ago...
06:36:46 <JesusIsLord> sabrehagen: you should be aware that if you unpack Con x, x will be fully polymorphic. You cannot do anything with fully polymorphic values. Calling show on them, for example, is impossible.
06:36:49 <Plex-> Configuring cairo-0.12.3 The pkg-config package cairo-pdf is required but it could not be found - any ideas what I should do here?
06:37:32 <Plex-> I have tried finding that package myself, but maybe I used the wrong terms, couldn't find anything
06:37:58 <JesusIsLord> sabrehagen: I'm not sure what you mean by "an instance which I have to match"
06:38:30 <Plex-> also to be clear: that occurs when cabal install cairo
06:38:50 * hackagebot wumpus-basic 0.24.0 - Basic objects and system code built on Wumpus-Core.  http://hackage.haskell.org/package/wumpus-basic-0.24.0 (StephenTetley)
06:39:22 <sabrehagen> JesusIsLord: hmmm, i understand what you're saying, but given that I have to match an interface, wouldn't the interface then contradict the idea of strict typing?
06:39:26 <hpaste_> sabrehagen pasted “formula” at http://hpaste.org/67921
06:40:18 <JesusIsLord> sabrehagen: oh, like that. I think you can do Con :: t -> Term t then.
06:40:19 <sabrehagen> JesusIsLord: my code is there, both the stuff i've written and the stuff that has been provided. you'll see what i mean by "an instance which I have to match" there.
06:40:33 <sabrehagen> JesusIsLord: okay, cheers.
06:40:37 <sexy> hi all
06:40:46 <JesusIsLord> sabrehagen: I did not know about the Show t => context in your instance.
06:40:49 <JesusIsLord> Hi sexy.
06:41:33 <sabrehagen> JesusIsLord: regardless, doesn't this mean somebody could pass in something other than an int or a bool and undermine the whole GADT?
06:41:50 <quicksilver> yes but it wouldn't be very useful
06:41:55 <quicksilver> since none of the other operators work on it
06:41:57 <JesusIsLord> sabrehagen: No. People could do that, but then they cannot pass them to other constructors.
06:42:15 <sabrehagen> JesusIsLord: ahh okay
06:42:27 <JesusIsLord> sabrehagen: e.g. Con "a string", you cannot use this on And, Or, Smaller, Plus or any of your other constructors.
06:42:53 <sabrehagen> JesusIsLord: right
06:42:55 <fmap> Plex-: you should install cairo-pdf via packet manager on your system
06:43:10 <Sakako> Could you make it something like an instance of Maybe Bool?
06:43:14 <Sakako> or Maybe Int?
06:43:30 <JesusIsLord> Sakako: not sure what you mean there.
06:43:41 <sexy> My Skype ID: sexy.girl6546542
06:43:44 <Sakako> I think the issue is more that one wouldn't want it to be possible to pass the wrong thing in?
06:43:45 <sexy> ADD ME
06:43:46 <JesusIsLord> @where ops
06:43:47 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
06:43:51 --- mode: ChanServ set +o quicksilver
06:43:58 --- mode: quicksilver set +b *!*sexy@90.148.63.*
06:43:59 --- kick: sexy was kicked by quicksilver (thanks but, well, no thanks)
06:44:03 <JesusIsLord> ty
06:44:32 <Sakako> Like an error-handling clause or something.
06:45:52 <JesusIsLord> I don't think that's possible.
06:46:17 <JesusIsLord> you define functions like: eval :: Term t -> t; errors are not possible.
06:46:29 <JesusIsLord> (unless somebody included an infinite term somewhere or a _|_)
06:46:42 <Sakako> but what about if you try and pass a non-Term object?
06:46:48 <JesusIsLord> the compiler will catch that.
06:46:53 <JesusIsLord> during compilation time.
06:46:56 <statusfailed> How should I do something like this? let f = \x -> (x, y) where y = x + 1 in state f
06:46:56 <Sakako> Oh right, you have to compile.
06:47:00 <Sakako> d'oh
06:49:15 <quicksilver> statusfailed: \x -> let y = x+1 in (x,y)
06:49:19 <JesusIsLord> GADTs are a way to increase type safety, the set of valid values becomes smaller; you cannot write Smaller (Con True) (Con 37) anymore.
06:49:20 <quicksilver> statusfailed: would be the simplest way.
06:50:04 <Sakako> What happens if you do?
06:50:10 <JesusIsLord> This wouldn't typecheck.
06:50:10 <Sakako> Oh.
06:50:14 <Sakako> Compiler error. :p
06:50:29 <Sakako> I keep thinking that it's an interpreted language somehow.
06:50:31 <JesusIsLord> Smaller :: Term Integer -> Term Integer -> Term Bool, but Con True :: Term Bool.
06:51:00 <JesusIsLord> interpretation is a different issue from static/strong typing.
06:51:10 <JesusIsLord> Haskell is statically/strongly typed
06:51:14 <Sakako> Yeah
06:51:14 <Rakin05> hey guys. i've got this code http://pastebin.com/JYHnKn29 and trying to iterate over the BookInfo list. is this the right solution i got here?
06:51:20 <mauke> The paste JYHnKn29 has been copied to http://hpaste.org/67922
06:51:24 <JesusIsLord> ghci interprets your code
06:51:29 <Sakako> Yeah, it does
06:51:33 <Sakako> that's why I get confused :p
06:51:35 <JesusIsLord> (converts to bytecode, but it's slower than ghc)
06:51:40 <Sakako> You can't do everything with ghci thuogh
06:51:46 <JesusIsLord> ghci does check your code for type errors
06:52:10 <JesusIsLord> Rakin05: that's probably not what you want.
06:52:14 <Sakako> > True + 1
06:52:15 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
06:52:15 <lambdabot>    arising from the literal `1'...
06:52:37 <JesusIsLord> Rakin05: line 6, showBooks (b:bs) = ...; you never use b here.
06:52:58 <Rakin05> JesusIsLord: is there a better solution for this?
06:53:02 <JesusIsLord> Rakin05: yes.
06:53:12 <JesusIsLord> Rakin05: but first let's walk through the way I would not write it =)
06:53:24 <JesusIsLord> Rakin05: do you know how to concatenate two strings?
06:53:34 <Rakin05> JesusIsLord: yeah ++
06:54:02 <JesusIsLord> oh now i see another problem. What exactly would you like showBooks to do?
06:54:29 <Rakin05> JesusIsLord: just show there values
06:54:35 <JesusIsLord> Rakin05: print to the screen?
06:54:44 <Rakin05> JesusIsLord: exactly
06:55:03 <JesusIsLord> Rakin05: generally in haskell we try to separate input-output from pure computation
06:55:26 <JesusIsLord> Rakin05: so the haskell way would be to write showBooks :: [BookInfo] -> String, where you completely lay out how to print it.
06:55:37 <JesusIsLord> for example, with newlines in between, or however you would like it.
06:55:54 <Rakin05> JesusIsLord: okay, got that
06:56:19 <JesusIsLord> Rakin05: so then the question is again, what would you like showBooks :: [BookInfo] -> String to do exactly?
06:56:59 <Rakin05> JesusIsLord: nothing special actually. just print there values.
06:57:01 <JesusIsLord> newlines in between?
06:57:21 <JesusIsLord> if you write showBooks = show you get a decent default actually.
06:57:51 <JesusIsLord> the default way to show a list is starting with "[", ending with "]", and "," in between values
06:58:37 <Rakin05> JesusIsLord: with newlines would be nice. but what i actually want is some training for iterating over lists. recursion flips my mind after 6 Years Java
06:58:43 <JesusIsLord> ah.
06:59:11 <JesusIsLord> Rakin05: well lists have two constructors. a list can be empty, or it can be a value + the rest of the list.
06:59:26 <Rakin05> JesusIsLord: yeah head and tail
06:59:28 <JesusIsLord> so if you write something over lists, you should write a case for both cases
06:59:36 <JesusIsLord> so, showBooks [] = ....
06:59:41 <JesusIsLord> and, showBooks (b:bs) = ....
07:00:02 <JesusIsLord> you should write a definition* for both cases
07:00:32 <merijn> Rakin05: The (or one of the) mistakes in your original paste is that "showBooks b" can match both empty list and head+tail, so it always picks the first definition and never uses the second
07:01:49 <Rakin05> merijn: but if i have the head of the list, and the tail like in showBooks (b:bs), how can i than extract the values of each BookInfo in bs?
07:02:01 <JesusIsLord> Rakin05: you do this recursively (often)
07:02:09 <Sakako> showBooks bs
07:02:12 <Sakako> is your friend
07:02:25 <JesusIsLord> Rakin05: so you write showBooks (b:bs) = ... something in terms of b and showBooks bs
07:02:47 <Sakako> That way when you get to the tail of the list, you call showBooks [], which you've already got defined
07:02:51 <JesusIsLord> for example, you can sum a list like  sum [] = 0; sum (x:xs) = x + sum xs
07:03:38 <JesusIsLord> similarly, you can write showBooks [] = ...; showBooks (b:bs) = ... use b and showBooks bs here ...
07:03:57 <hpaste_> merijn annotated “pastebin.com/JYHnKn29” with “map example” at http://hpaste.org/67922#a67923
07:04:11 <merijn> Rakin05: Take a look at the annotation I just pasted
07:05:16 <Rakin05> merijn, JesusIsLord, Sakako: thank you guys so much for your help
07:05:53 <merijn> Rakin05: You could do the pattern match used by "showOneBook" directly in showBooks, i.e. "showBooks ((Book i str list) : bs) =", but I figured that'd be a bit confusing
07:06:18 <merijn> You can nest pattern matches arbitrarily deep, it just becomes a bit confusing after 2 levels
07:06:30 <merijn> So you'd usually use helper functions instead
07:07:51 <Rakin05> merijn: i think recursion is the one thing i quite don't understand. like i said after 6 years java my mind thinks in imperative terms :-D
07:08:14 <merijn> Rakin05: What are you reading to learn Haskell?
07:08:28 <Rakin05> merijn: Real World Haskell
07:08:39 <iDolfHatler> is it a bug, that this does not typecheck? if not, can anybody explain to me why it does?
07:08:39 <iDolfHatler> http://hpaste.org/67924
07:08:46 <merijn> Rakin05: RWH can be a bit...terse
07:08:47 <Sakako> you know what's a really bad book for learning Haskell?
07:08:49 * hackagebot wumpus-drawing 0.9.0 - High-level drawing objects built on Wumpus-Basic.  http://hackage.haskell.org/package/wumpus-drawing-0.9.0 (StephenTetley)
07:09:00 <Sakako> Thompson's "The Craft of Functional Programming"
07:09:09 <Rakin05> Sakako: maybe RHW???? :-D
07:09:10 <merijn> Rakin05: If you often find yourself confused you might want to read "Learn You a Haskell for Great Good"
07:09:39 <merijn> Rakin05: It starts more slowly and explains everything in more detail. RWH glosses over quite some detail and assumes you'll figure it out yourself
07:09:41 <Sakako> I'm currently using Thompson as a coaster for my chocolate thickshakes.
07:09:42 <merijn> @lyah
07:09:42 <lambdabot> Unknown command, try @list
07:09:45 <merijn> err
07:09:47 <merijn> @where lyah
07:09:48 <lambdabot> http://www.learnyouahaskell.com/
07:10:04 <Rakin05> merijn: thx for the tip. will try that in future
07:10:14 <merijn> Learn You a Haskell happens to also be available online for free :)
07:10:21 <Rakin05> <-- has to go for bbq :-D bye all
07:10:32 <JesusIsLord> enjoy.
07:10:45 <Sakako> Speaking of which, I think it's time for a break.
07:10:59 <Sakako> See you guys in about half an hour.
07:11:18 <iDolfHatler> I don't really understand that bug - isn't "b" more specific than "forall b . b"?
07:13:51 * hackagebot wumpus-tree 0.20.0 - Drawing trees  http://hackage.haskell.org/package/wumpus-tree-0.20.0 (StephenTetley)
07:13:52 <yan_> is anyone aware if i can make Network.Curl download directly into a file handle?
07:15:23 <bitonic> iDolfHatler: you need to re-construct the tuple
07:15:31 <bitonic> f (x, y) = (x, y)
07:15:50 <scooty-puff> when is manual monad inlining and explicit unboxing most useful?  i am going to define a type class for references (instances including IO and ST) where the pure version would just be a wrapper around StateT
07:16:06 <bitonic> iDolfHatler: also, your nickname is probably against some rule
07:16:29 <iDolfHatler> bitonic: thanks! can you give me any resources as to why that is? :)
07:16:33 <scooty-puff> so s -> m (a, s), or S -> m (a, S), or data Pair a = Pair a !S; S -> m (Pair a), etc.
07:16:47 <bitonic> iDolfHatler: you actually need to replace `b' with `b''
07:17:08 <bitonic> the thing is that it's all implicit in haskell (the quantifications and substitutions)
07:17:31 <bitonic> but really, change your nickname
07:17:41 <byorgey> scooty-puff: http://hackage.haskell.org/package/ref-mtl  ?
07:18:03 <iDolfHatler> bitonic: sorry, I've had it for a long time now and I'll keep using it.. but I can change it now if it makes you uncomfortable :)
07:18:17 <scooty-puff> perhaps evu-braan
07:18:23 <scooty-puff> ok, bad joke
07:18:35 <byorgey> I really don't see why iDolfHatler needs to change their nick.
07:18:59 <JesusIsLord> it's an obvious anagram of "adolf hitler".
07:19:01 <bitonic> ...whatever
07:19:39 <scooty-puff> byorgey: may not be reading the source for that package right - do they impl a pure version (i will prob use the type class, though)
07:19:43 <iDolfHatler> bitonic: anyway, thanks for your help - I'm not really sure I understand _why_ i need to reconstruct the tuple though :(
07:20:02 <byorgey> scooty-puff: I don't know, I just remembered that such a type class already existed, haven't used it myself
07:20:21 <bitonic> iDolfHatler: because when you're returning the tuple the `c' has already been substituted with some other type, while the `b' would still be polymorphic
07:20:40 <byorgey> iDolfHatler: the rules for dealing with higher-rank types in GHC are somewhat mysterious.
07:20:53 <byorgey> iDolfHatler: apparently it is only willing to instantiate top-level 'forall's
07:20:55 <scooty-puff> byorgey: k
07:21:11 <bitonic> byorgey: I think it makes sense in this case
07:21:18 <byorgey> in particular it is not willing to instantiate a forall nested inside a tuple
07:21:19 <scooty-puff> iDolfHatler: i have not seen what you are dealing with (code, etc.), but ScopedTypeVariables can sometimes help
07:21:45 <scooty-puff> though maybe not - sounds like impredicative types or something..
07:21:52 <bitonic> It would be somewhat risky to automatically instantiate quantifications inside a tuple
07:22:12 <byorgey> bitonic: why?
07:22:31 <byorgey> (not necessarily disagreeing, just curious)
07:22:31 <bitonic> byorgey: well not risky, but I wouldn't expect that behaviour
07:22:41 <bitonic> it probably has subtle implications
07:22:45 <byorgey> well, I agree with you there.
07:22:49 <iDolfHatler> I'm trying to change the type of "Source" in the conduit library from "type Source = Pipe Void o m ()" to "type Source = Pipe (forall i.i) o m ()"
07:23:08 <byorgey> iDolfHatler: hehe, fun =)
07:23:12 <mm_freak_> byorgey: if you implement locally nameless properly, do you entirely stop dealing with indices?
07:23:22 <quicksilver> byorgey: not just mysterious but liable to change from version to version.
07:23:26 <mm_freak_> or is it just to ease making expressions?
07:23:32 <quicksilver> byorgey: it's best to be conservative I think
07:23:32 <byorgey> quicksilver: yes, that too.
07:23:43 <byorgey> agreed.
07:23:47 <iDolfHatler> byorgey: I'm not really sure it will be better, but currently I'm just trying to see if it's possible :)
07:24:32 <byorgey> mm_freak_: you have to deal with indices when you implement 'open' + 'close' (or 'abstract' and 'instantiate' as McB/McK call them).  But that is the ONLY place you should ever have to work directly with indices.
07:24:37 <scooty-puff> iDolfHatler: would type Source i = Pipe Void i o m () or newtype Source = ... work?
07:24:51 <bitonic> iDolfHatler: what's the point of doing that? I don't see any particular advantage. `forall a. a' and `Void' are similar in the sense that only _|_ inhabits them but how is `Void' better?
07:24:58 <bitonic> sorry, how is `forall a. a'
07:25:00 <bitonic> (better)
07:25:05 <mm_freak_> byorgey: so you need a name supply for almost everything, right?
07:25:15 <byorgey> mm_freak_: yes, that's true
07:25:21 <mm_freak_> ok, thanks
07:25:22 <scooty-puff> does Void satisfy any odd type class?
07:25:32 <mm_freak_> scooty-puff: Monoid
07:25:34 <bitonic> scooty-puff: Void has no members
07:25:40 <mm_freak_> oh
07:25:44 <mm_freak_> Void, not Unit =)
07:25:47 <iDolfHatler> bitonic, scooty-puff: as I said I'm not sure there is any advantage in practice - but what I'm _trying_ to do is be able to use a Source inside a Pipe monad
07:26:17 <iDolfHatler> that is a source should be usable inside _any_ Pipe monad with a compatible output
07:26:39 <mm_freak_> well, Void can satisfy most type classes, as long as it doesn't require constructing values
07:27:01 <mm_freak_> instance Eq Void where _ == _ = False
07:27:24 <bitonic> scooty-puff: well, no member apart _|_, obviously :P
07:27:31 <byorgey> I would expect  instance Eq Void where _ == _ = True  =)
07:27:41 <iDolfHatler> mm_freak_: but mySource <*> myPipe wouldn't work though
07:27:47 <mm_freak_> byorgey: i wouldn't expect anything as you're never going to observe it =)
07:27:58 <mm_freak_> could just as well say _ == _ = undefined
07:28:00 <byorgey> mm_freak_: indeed, I was joking =)
07:28:06 <mm_freak_> hehe ok
07:28:12 <bitonic> mm_freak_: (undefined :: Void) == (undefined :: Void) :)
07:28:14 <mm_freak_> iDolfHatler: huh?
07:28:15 <bitonic> but yeah
07:28:27 <bitonic> the implicit assumption is that we don't cheat like that :P
07:28:32 <mm_freak_> hmm
07:28:34 <bitonic> Void is mainly documentation
07:28:45 <mm_freak_> now that you say it…  actually you could observe the result of (==) for Void
07:28:51 <bitonic> mm_freak_: of course
07:28:54 <mm_freak_> _ == _ = True is nonstrict
07:29:10 <bitonic> !a == !b = undefined would work
07:29:27 <mm_freak_> that's just _ == _ = undefined
07:29:37 <bitonic> no
07:29:39 <JesusIsLord> sure
07:29:49 <bitonic> denotationally yes
07:29:51 <JesusIsLord> it's _|_ one way or the other
07:30:00 <bitonic> but that instance of Void might be some other flavour of _|_ :P
07:30:01 <mm_freak_> sure, the error message you get could be different
07:30:02 <yitz> preflex: seen t7
07:30:02 <preflex>  t7 was last seen on #haskell 59 minutes and 59 seconds ago, saying: i find it hard to accept that someone with the mental capacity to learn haskell could believe such things
07:30:09 <t7> :O
07:30:46 <yitz> t7: i just tried to spell the pragma "GeneralisedNewtypeDeriving", and GHC rejected it. you need to use the letter "z" !!
07:30:55 <mm_freak_> when i code i assume all flavors of ⊥ to be the equal
07:31:02 <yitz> t7: a guess an american like me deserves it
07:31:23 <mm_freak_> yitz: see the arithmoi library
07:31:26 <mm_freak_> "factorise"
07:31:49 <bitonic> mm_freak_: it depends if you think denotationally or operationally :P
07:32:16 <mm_freak_> bitonic: the former when designing code, the latter when optimizing
07:32:26 <bitonic> well, and debugging
07:32:38 <womb_> > 7*7
07:32:38 <mm_freak_> debugging?  what's that?
07:32:39 <lambdabot>   49
07:33:05 <bitonic> womb_: why do you keep doing that? why always 7*7?
07:33:20 <mm_freak_> i remember that there is this word "debugging" from my C++ times, but i forgot what it means
07:33:31 <bitonic> mm_freak_: yeah right :P
07:34:46 <kini> Is there any particular rationale behind the rightmost generator in a list comprehension being the innermost loop?
07:34:57 <iDolfHatler> bitonic: how about this - is there any easy way to fix the too?
07:35:00 <iDolfHatler> http://hpaste.org/67926
07:35:04 <womb_> bitonic: because 7*7 is 49
07:35:07 <kini> To me (knowing nothing of Haskell) it seems like the other way is more natural
07:35:28 <bitonic> iDolfHatler: you need to reconstruct the data type here as well
07:35:34 <bitonic> you can probably have an helper function
07:35:39 <bitonic> that does the conversion
07:36:09 <bitonic> forall a b. T (forall a. a) (forall a. a) -> T a b
07:36:10 <mauke> womb_: are you a spambot?
07:36:24 <womb_> mauke: you ask me this each week
07:36:38 <mauke> I can just ban you
07:36:45 <womb_> dont do it ;<
07:36:48 <mauke> why not?
07:36:54 <womb_> i'm not a spam bot
07:37:02 <mauke> then stop behaving like one
07:37:06 <kini> for example if x <- xs were the innermost loop in [f x | x <- xs, y <- ys], then [[f x | x <-s] | y <- ys] would flatten to [f x | x <- xs, y <- ys], right?
07:37:12 <kini> and with the current behavior it doesn't
07:37:39 <iDolfHatler> bitonic: thanks :)
07:38:22 <kini> I also wondered about this behavior in Python when I learned it long ago, but I guess it originated in Haskell :)
07:38:43 <quicksilver> kini: I think that for most intended uses of list comprehension the order isn't really supposed to be important
07:38:58 <quicksilver> but I can't make any concrete guess as to why its' this way around.
07:39:14 <JesusIsLord> x <- xs, y | Just x == y <- ys  ?
07:39:31 <JesusIsLord> this is probably invalid, lol
07:39:38 <bitonic> iDolfHatler: you're welcome
07:39:41 <kini> quicksilver: hmm, I see...
07:39:46 <osfameron> wow, what a nick
07:40:03 <kini> do you mean that list comprehensions are just generally used to create sets to iterate some operation over and people don't care what order they're in?
07:40:11 <mauke> osfameron: heh, which one?
07:40:12 <JesusIsLord> kini: often, yes.
07:40:15 <kini> what would you usually use to create a specifically ordered list, then?
07:40:19 <quicksilver> kini: in particular not caring which order the interleaving happens.
07:40:31 <byorgey> I think they're that way around because it corresponds to >>=
07:40:33 <JesusIsLord> kini: oh you can still use list comprehensions. or map.
07:40:36 <quicksilver> kini: the ordering within the actual index lists is of course predictable.
07:40:51 <quicksilver> > [ (x,y) | x <- [1..], y <- "abc"]
07:40:52 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c'),(4...
07:40:53 <JesusIsLord> or the do monad.
07:40:59 <JesusIsLord> err, list monad*
07:41:10 <quicksilver> kini: this way round the first one is the only one which can usefully be infinite.
07:41:10 <byorgey> > [1..] >>= \x -> "abc" >>= \y -> return (x,y)
07:41:11 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c'),(4...
07:41:18 <quicksilver> kini: maybe that seemed natural.
07:41:24 <osfameron> mauke: "JesusIsLord".  I'm not especially into religious sanctity, but it makes me slightly uncomfortable, in the way "kwisatz_haderach" did when someone had it as a nick.
07:41:28 <osfameron> dunno why
07:41:33 <osfameron> >> -blah I guess
07:41:38 <kini> quicksilver: I don't see how that's more natural than letting the last one be infinite...
07:41:43 <bitonic> osfameron: I prefer JesusIsLord to iDolfHatler ehe
07:41:46 * adnauseam seconds osfameron's notion
07:41:51 <adnauseam> same thing goes to iDolfHatler
07:41:54 <JesusIsLord> osfameron: i would think iDolfHatler would be far more offensive, but w/e.
07:41:56 <mauke> osfameron: ... you're not in #haskell-blah
07:42:03 <osfameron> mauke: yeah, good point
07:42:05 <adnauseam> but aye, what mauke said
07:42:19 <bitonic> they're all jokes anyways. but yeah hitler is far worse than jesus.
07:42:48 <adnauseam> bitonic: debatable ;p
07:42:56 <parcs`> why can't people just have normal nicks
07:43:02 <adnauseam> but i'll zip it
07:43:14 <adnauseam> parcs`: ego
07:43:24 <kini> quicksilver: perhaps I'll ask on stackoverflow, maybe someone there will know The Real Reason (tm) :)
07:43:27 <adnauseam> and youth
07:43:50 <quicksilver> kini: or a karma whore will come up with something snarky aligned with dominant groupthink, anyway ;)
07:44:00 <ment> @hoogle [(k,v)] -> [(k,[v])]
07:44:00 <lambdabot> Data.Graph.Inductive.Query.Dominators dom :: Graph gr => gr a b -> Node -> [(Node, [Node])]
07:44:11 <byorgey> I am really offended by "adnauseam", it makes me think of nausea.  And also parcs`, I hate parks because this one time I got bit by a dog in a park.
07:44:39 <adnauseam> byorgey: makes me think of the borg. how dare you assimilate picard.
07:44:41 <normalNick> and 'byorgey', yipe
07:44:47 <JesusIsLord> byorgey: shocked @ comparing nausea to Hitler. but I'll change my nick if somebody is bothered by it.
07:45:04 <byorgey> normalNick: it's because of my ego. and youth.
07:45:14 <adnauseam> :[
07:45:17 <normalNick> right
07:45:20 * adnauseam hugs everyone 
07:45:28 <t7> you should read that encyclopaedia dramatica page 'offended'
07:45:52 <adnauseam> it is a good page
07:45:56 <bitonic> I agree with byorgey that the terms for "offensice nicks" are pretty arbitrary. Still, I doubt you wouldn't ban "IHateNiggers" or similar, and you also removed vixen!
07:46:07 <quicksilver> I'm offended by the nickname byorgey because I once read a blog post by someone called Brent Yorgey and it made me feel nauseous.
07:46:21 <byorgey> quicksilver: if I ever meet him I'll mention it.
07:46:24 <scopedTV> genocide != nausea. DUCY???
07:46:33 <scopedTV> you make me sick
07:46:38 <adnauseam> ah sorreh
07:46:40 <adnauseam> :[
07:46:51 * applicative agrees at least that vixen wasn't as bad as nixon
07:46:55 <quicksilver> if the rhetoric was not clear, my point is that this discussion is silly. Let's move on.
07:47:39 <applicative> yes, how come my ghci started having a segmentation fault every other time I open it
07:48:02 <adnauseam> applicative: any other instances of ghc running? tried free -m ?
07:48:03 <applicative> i guess thats between me and my operating system
07:48:13 <applicative> hm
07:48:24 <adnauseam> ps aux | grep ghc
07:48:29 <adnauseam> and see what's using up the ram
07:48:41 <t7> whats a 'normal' nick?
07:48:52 * hackagebot fclabels 1.1.3 - First class accessor labels.  http://hackage.haskell.org/package/fclabels-1.1.3 (SebastiaanVisser)
07:49:14 <adnauseam> t7 - quicksilver asked us to stop that line of enquiery. just use common sense or google what common sense, otherwise you'll get banned
07:49:18 <applicative> hey, I only have three instances running ...
07:49:42 <importantshock> Oh hey, look at that. new fclabels.
07:50:18 <applicative> adnauseam: I will study if it's something like that, it still seems to be sort of random
07:50:34 <applicative> adnauseam: thanks
07:50:50 <adnauseam> sure thing man
07:51:02 <parcs`> mm_freak_: does netwire have a 'switch' combinator or something like it? i'm trying to model something that's bouncing off two walls and i think i need a 'switch'
07:52:47 <mm_freak_> parcs`: in netwire you would model the direction as a sum of wires
07:53:25 <mm_freak_> but if you want to model it as a switch you'll have to write a custom wire…  just look into the .Events module
07:54:24 <applicative> scopedTV: by the way, my understanding was that ImpredicativeTypes is quasi-deprecated.
07:54:27 <parcs`> mm_freak_: could you provide an idiomatic example? this is what i have:
07:54:32 <hpaste_> parcs pasted “netwire” at http://hpaste.org/67927
07:57:03 <parcs`> oo
07:57:07 <parcs`> i think i got it
07:59:05 <applicative> is proc notation really pretty simple once you study it?
07:59:10 <byorgey> applicative: no
07:59:28 <quicksilver> proc notation seems to make one particular pattern of arrow use simpler
07:59:34 <applicative> I've never applied myself to it, so I wondered
07:59:35 <quicksilver> it never seemed to help when I used them
07:59:42 <quicksilver> although it's possible I misunderstood.
07:59:50 --- mode: quicksilver set -o quicksilver
08:00:01 <mm_freak_> parcs`: if you're patient…  right now i have stuff to do, sorry
08:00:20 <parcs`> mm_freak_: okay
08:00:46 <parcs`> applicative: i think so
08:08:28 <hpaste_> scooty-puff pasted “Use System.Mem.Weak?  Would need artificial strong references..” at http://hpaste.org/67928
08:08:52 <parcs`> stupid frp
08:09:23 <mun> hi
08:09:32 <mun> in logic, how are sorts and types different?
08:09:36 <scooty-puff> so was going to add weak references as the values for the IntMap, but would need to somehow make it known to the gc that a Ref represents a strong reference..
08:10:02 <PatrickRobotham> mun: Types are collections of values, kinds are collections of types, sorts are collections of kinds.
08:10:41 <byorgey> PatrickRobotham: I'm not sure that's the way those terms are used in formal logic.
08:10:56 <byorgey> mun: where are you seeing these terms used?
08:11:14 <hpc> https://en.wikipedia.org/wiki/Many-sorted_logic
08:11:59 <hpc> looks like a primitive type system for logic, to me
08:12:07 <mun> byorgey, http://en.wikipedia.org/wiki/First-order_logic
08:12:21 <mun> byorgey, specifically, 'one-sorted' vs 'many-sorted'
08:14:55 <mun> PatrickRobotham, does that mean a many-sorted logic doesn't actually have types?
08:14:57 <byorgey> I think 'sorts' are a very weak sort of types.  You just have a flat set of sorts, and a given quantifier ranges only over things of a particular sort.  But there's no structure to the sorts beyond that.
08:14:59 <mun> but rather, just sorts?
08:15:22 <byorgey> whereas 'types' would be used to refer to e.g. type theory, where you have a very rich set of types: sum and product types, function types...
08:16:34 <quicksilver> I think the different word is used because the 'sorts' classify elements/individuals, byorgey, which is different from the normal interpretation of types as propositiosn.
08:17:21 <quicksilver> I'm not sure though and it could just be historical.
08:22:46 <importantshock> Wow, the stuff that fclabels has for working with MonadState is really cool.
08:23:33 <quicksilver> importantshock: data-lens has similar stuff too, doesn't it?
08:24:36 <quicksilver> http://hackage.haskell.org/packages/archive/data-lens-fd/2.0.1/doc/html/Data-Lens.html
08:24:39 <quicksilver> lots of MonadState there.
08:25:16 <importantshock> looks like in versions 2.10 that was generalized
08:26:43 <importantshock> wait ignore me i am conflating these packages
08:35:55 <Philonous> Is there a way to get an exhaustive list of all Exceptions an IO action may throw?
08:36:38 <scooty-puff> heh
08:36:49 <scooty-puff> you can with ErrorT
08:37:06 <scooty-puff> where each exception is a data constructor
08:37:52 <scooty-puff> or do you mean another static analysis tool (outside of type checking)?
08:38:10 <quicksilver> Philonous: the answer to your question is No.
08:38:13 <Philonous> scooty-puff:  No, that's no good. I mean IO exceptions. For example, how do I know what exceptions System.IO.hGetChar might throw
08:38:29 <quicksilver> you can't possibly know, unfortunately.
08:38:38 <quicksilver> haskell asynchronous exceptions are not checked, by design
08:38:44 <quicksilver> because they are asynchronous.
08:39:07 <iDolfHatler> bitonic: isn't there an extension or something that I can use to make ghc instantiate the types automatically?
08:39:22 <Philonous> quicksilver:  Ah, ok, I mean synchronous exceptions. Obviously you might recieve any exception asynchronously at any time (save for mask, of course)
08:39:30 <scooty-puff> Philonous: at best, you might be able to use wrappers around the IO calls you are making, and specifically annotate each call with what might be thrown (via constraints), and then at main know what might be thrown
08:39:35 <bitonic> iDolfHatler: not that I know of
08:39:41 <iDolfHatler> :(
08:39:52 <iDolfHatler> then my use-case doesn't really make sense, sadly
08:40:02 <quintessence> Philonous: for any interesting property P, the answer to "Is there a way to determine whether an (arbitrary) IO action has preperty P?" is no.
08:40:05 <scooty-puff> but would be an honor system type of thing though
08:40:11 <Philonous> scooty-puff:  Right, but for that I need to know what can be thrown. Which is exactly what I'm asking ;)
08:40:17 <scooty-puff> yeah..
08:40:28 <quicksilver> Philonous: basically, IO exceptions are around the asynchronous model and the design is that they are unchecked.
08:40:33 <quicksilver> even the synchronous ones.
08:40:49 <quicksilver> for checked excpetions you can build stuff out of ErrorT or whatever
08:41:03 <quicksilver> (although taking sums of two arbitrary sets of exceptions at the type level is clunky)
08:42:20 <scooty-puff> so is there a way with ghc to say "treat this value as if it were strong referenced by this other value, even though its not"?
08:42:25 <scooty-puff> *strongly
08:42:46 <Philonous> quicksilver:  Ah, no, I don't need to know during run time. I mean either an (preferably exhaustive) list for standard library functions or a tool that will parse code and derive them
08:44:41 <Philonous> quicksilver:  Actually, never mind. I just managed to miss the part in the documentation of said functions where it states what errors they may cause.
08:44:44 <scooty-puff> (via c is fine with me)
08:45:51 <quintessence> scooty-puff: You can do data WithRefs a = WithRefs a [Dynamic] and stick the strong references in the list, but (for C interop reasons) I suspect there's a better way.
08:46:41 <scooty-puff> that would work in the general case, but need to make it so the strong ref doesn't really exist - the Ref is just an Int
08:46:45 <scooty-puff> newtype Ref s a = Ref Int
08:47:08 <scooty-puff> so guess would have to ensure the Int isn't unboxed, or something..
08:50:36 <mm_freak_> locally nameless is really great
08:50:39 <mm_freak_> lambda $ \f -> lambda $ \x -> return (App f x)
08:52:29 <mm_freak_> now let's see if i can implement evaluation in this system
08:54:11 <Ngevd> Cabal's just given me the weirdest error
08:54:21 <Ngevd> "cabal: There is no installed version of base"
08:54:29 <scopedTV> that's probably not all.
08:55:38 <mm_freak_> byorgey: according to the paper open/close don't modify indices…  how exactly would i implement application without touching them?
08:56:15 <j_radon> can I define functions with similar syntax as []?
08:56:16 <mm_freak_> oh, wait
08:56:21 <mm_freak_> i don't need to touch them…
08:56:28 <quicksilver> j_radon: no. lists are special.
08:56:31 <Ngevd> Got the problem
08:56:36 <mm_freak_> j_radon: you can define custom operators, but they can only be infix
08:56:38 <Ngevd> Cabal file didn't list dependencies
08:58:14 <byorgey> mm_freak_: you don't need to touch them.  open/close don't modify indices, but they do work with indices in the sense of figuring out which indices correspond to a given binder
08:58:25 <byorgey> mm_freak_: the point is that if you only use indices for bound variables, they never need to be modified.
08:58:38 <mm_freak_> yeah, i just realized that
08:58:45 <mm_freak_> there are no free indices anymore
08:58:46 <byorgey> it's only indices for free variables that cause problems and require incrementing or decrementing.
08:59:04 <j_radon> so there's no way to, for instance, typeset integrate :: Integrand -> Measure -> Value as say \ f mu -> (\int) f (\d) mu?
09:00:03 <mm_freak_> j_radon: no, that's a syntax error
09:00:44 <j_radon> oh well
09:00:45 <j_radon> thanks
09:05:46 <mm_freak_> byorgey: to evaluate a lambda abstraction to normal form i would 'open' the lambda (turn index 0 into a free name) and then call the evaluator recursively on the opened expression, right?
09:06:13 <byorgey> mm_freak_: yes, and then close it again
09:06:29 <mm_freak_> great stuff…  i think i'll implement a combinator for that
09:06:56 <byorgey> sure.  Of course you have to be careful not to pick a free name that is already in use.
09:07:11 <mm_freak_> yeah, i have a monad for unique name generation now
09:07:36 <byorgey> right, good
09:08:08 <mm_freak_> apropos…  do you use a name stack or simply some integer value?
09:09:49 <ymasory> what is the type of a list lazily filled with records from a database? IO List a, or, List IO a?
09:10:07 <mm_freak_> ymasory: the list itself is of type [Record] or something
09:10:21 <mm_freak_> the action to get the list is of type IO [Record]
09:10:22 <quicksilver> depends what you mean by "lazily"
09:10:35 <shachaf> ymasory: Probably closer to the former than the latter, but keep in mind that lazy I/O may well be evil in your use case.
09:10:43 <quicksilver> IO [a] would be a common case
09:10:59 <quicksilver> but if the records are coming in incrementally then it's "cheating" with so-called lazy IO
09:11:08 <shachaf> [IO a] wouldn't make sense unless you know e.g. the length of the list in advance.
09:11:29 <quicksilver> [IO a] would let you ask for the records in any order too
09:11:36 <quicksilver> might be handy but not often the way these things work
09:11:39 <mm_freak_> shachaf: unless that list itself is generated lazily =)
09:11:55 <ymasory> okay. so what would be the preferred data structure if not list? the use case is that the underyling implementation is JDBC, so the cursor is advancing row by row until the query has no more results
09:12:08 <mm_freak_> shachaf: btw, good news…  i didn't go back to names =)
09:12:31 <quicksilver> ymasory: some kind of explicitly IO cursor would be the best type for that.
09:12:32 <shachaf> mm_freak_: Actually it could be not-evil -- e.g. do { len <- getLength; return (mapM getRecord [1..len]) }
09:12:59 <quicksilver> ymasory: there is a trendy family of data types for this called 'enumeratee'
09:13:11 <quicksilver> trendy but, many people find, fiddly.
09:13:22 <ymasory> quicksilver: i'll take a look, thanks
09:13:29 <ymasory> quicksilver: why fiddly?
09:13:33 <mm_freak_> quicksilver: i think nowadays the trendy name is "conduit"
09:13:42 <quicksilver> mm_freak_: I'm out of touch.
09:13:45 <quicksilver> :)
09:14:18 <byorgey> the REALLY trendy name is "sluices"
09:14:22 <byorgey> you probably haven't heard of them.
09:14:27 <mm_freak_> ymasory: he's talking about iteratees…  that's a stream processing abstraction, and processing rows from a database is considered stream processing
09:14:52 <mm_freak_> nowadays i'd recommend the 'conduit' library over iteratees
09:15:28 <ymasory> mm_freak_: thanks
09:16:21 <mm_freak_> byorgey: am i likely to run into problems with integers as free names?  would you recommend the qualified name approach from the paper over simple integers?
09:16:49 <Philonous> The documentation of hPutBuf states that "it may fail with ResourceVanished". It doesn't mention which Exception type IOErrorType that is. Does someone know what to look for?
09:18:11 <byorgey> mm_freak_: for simple things, integers as free names is probably fine.  I haven't really used the qualified name approach myself so can't really comment on its relative merits.
09:18:16 <byorgey> although I can see the appeal.
09:19:08 <mm_freak_> ok, thanks for your help
09:26:24 <bgamari> Are there any well established conventions for naming lenses?
09:26:40 <bgamari> It seems many people use underscores instead of CamelCase for lenses
09:29:00 <mm_freak_> bgamari: just name them as you would name the corresponding fields
09:29:35 <mm_freak_> and no, underscores are not common…  what is common is that lenses are derived automatically using template haskell, in which case the real fields are prefixed with underscores
09:29:46 <mm_freak_> i.e. _myField is the field and myField is the corresponding lens
09:33:50 <gwern> hm. network.url is mangling my URLs with utf8 in them
09:34:05 <gwern> 'exportURL $ Data.Maybe.fromJust $ importURL "Ryszard Kapuściński"' ~> "Ryszard%20Kapu%5bciDski"
09:34:42 <danr> Is there any documentation about the changes from using force to the computeP in repa?
09:36:13 <gwern> what I need is Ryszard%20Kapu%C5%9Bci%C5%84ski - which differs from the previous
09:37:47 <bgamari> mm_freak_: Alrigh
09:37:49 <bgamari> Thanks
09:39:03 <bgamari> So now cabal apparently warns you about breakable due to reinstalls. Granted, this is a step in the right direction but I take it that the problem still isn't fixed?
09:39:13 <bgamari> the error message could really be more helpful
10:34:36 --- topic: '["Haskell Platform 2011.4: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.1: http://is.gd/vkWMMa ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","admin/spam issues: #haskell-ops "]'
10:34:36 --- topic: set by glguy on [Wed Apr 18 20:44:31 2012]
10:34:36 --- names: list (clog SyntaxNinja c_wraith larches bos pheaver esap edwardk Guest45594 yitz Mathnerd314 allbery_b fragamus dMazz timtheli1n nejucomo master_of_master jamiltron ppseafield Nordvind tobias1 raichoo path[l] zk saep hrolf dimituri gusto SG11 gemelen warrenharris jamil_1 boccato bru` chazor rtharper gehmehgeh danvet ortmage hdev iocor sizz_ schlicht pikhq mononofu theorbtwo hajimehoshi tertl5 roha osa1 erkin mkscrg plucas tensorpudding_ luxurymode corruptmemory)
10:34:36 --- names: list (dschoepe ymasory twopoint718 augur zachk jfischoff donri kanak PatrickRobotham Ngevd l0st1 conal vyom xraycat areil_ mdhopkins tac-tics jmelesky xcvd gwicke Eduard_Munteanu Anoq wli asante pejusify ahihi2 jrib Jeanne-Kamikaze noam kk` adlan kadoban getpwnam uniquenick ttt-- mun cheater Vert quintessence PhilRod_ drbean cg_morton dolio pcavs paulius_ Axman6 everythingWorks ajhager amathew ggherdov descender gg7 aconbere kini jimmyrcom asflierl)
10:34:36 --- names: list (ClaudiusMaximus edon Targen scooty-puff Azel joe9 drmegahertz iDolfHatler qued_____ edsko azaq23 stefan-_ mceier adu polux_ saml copumpkin vodik iulian nus nighty- djfxc monad imphasing Philonous importantshock hiptobecubic rgr Sakako smerz Vorpal Shammah hanDerPeder homie`` decltype roconnor_ nonefool merijn dgpratt jeltsch tashbear agumonkey ceii MK_FG delihiros hive-mind byorgey EarlGray mysticc finnrobi sunfun ksf _null ftrvxmtrx_ ceii__)
10:34:36 --- names: list (MercurialAlchemi trin_cz sm mornfall phyrex1an petermw freiksenet fmap PreciousMetals tufisi milli scopedTV Dodek jem777 lambdabot gredman linduxed azm SoupE Dybber OlegYch|h [[zz]] owst aavogt Chaze niklasb milessabin janbanan amiri kevinqcs ronniy ivan\ mah_b shintah Y_Less DuoSRX Palmik piotr_ nohonor Zedrikov Sgeo clintm Shanachan m3ga julmuri andersk treyka Catnaroek jmcarthur meanburrito920 dan64 btby wespee ragusa fukushima juhp niloc132 nexx)
10:34:36 --- names: list (macUzer AlbireoX otto_s MrNibbles akosch mm_freak_ koninkje_away The_third_bug ninegrid vili EyesIsMine JaffaCake kurthindenburg mefisto tromp sgronblo waterlaz Taggnostr2 tavelram_ abbe Lemon quaestor Baughn fxkr luis shoerain kniu TML julmae- dan MasseR HaudRex chops_ gentleben alvis` perlite bmfx macron kallisti xinming_ Cale ketil Shadow^Dancer wolong zaltekk tgeeky proq junsuijin dmwit gbeshers timthelion dom_1 Phlogistique dsouza Dtgr gienah Eiam)
10:34:36 --- names: list (morolin kish jnials dabradley foopq_ Enigmagic tarmstrong sclv spanner Excureo epsil Karmaon SHODAN Boney Spockz fireglow EvanR kmels dylukes nsxt_ ville levitation[A] k-zed birkenfeld iFire lucian Mitar araujo Ornedan matthiasgorgens1 Skola mauke slowpoke jonke sShintah blast_hardcheese squimmy ftrvxmtrx dywi untwisted Fnar Zenith77|2 starblade lomeo amiller seolfor hamishmack ngochai mjo ozataman Ralith peterhil` wtetzner The_third_man almostsix alek_b)
10:34:36 --- names: list (hackagebot hashbrowncipher acfoltzer zaiste dimmy rsimoes mercury^ dessos nighty^ hundskatt `micro Damn3d- stepcut profmakx OnionKnight pettter septic ion gwern Jonno_FTW Deewiant Jaxan hvr em davesq Nimatek happyclam Philippa niko And[y] kephas lulf aib mcglk Twey davidL tessier yonahw irene-knapp otters dirthead DustyDingo Tesseraction ormaaj ipuustin JamesJRH preflex ben geofft brisbin sporous Lennier xian elnn_ hiato yeltzooo LeninParty anonus Vq)
10:34:36 --- names: list (ace2001ac snorble_ AtnNn Elemir mkaito parcs` blackdog Plex- smarter jbauman neptunepink kakos kekimmo skiold keseldude b52 Khisanth wunki_off sanjoyd codekoala Apocalisp xsysstar florent_ Jaak edwinb akahn wto wires ski comak adimit dsfox Innominate schroedinbug albel727 olsner vold traviscline dom96 peddie silver __main__ Lemmih knyppeldynan mrno_ cods endojelly myme ment kaol Botje absentswett saurik_ l4mbd4 Modius` bcoppens jml xnyhps joeytwiddle)
10:34:36 --- names: list (sawjig tsuraan_ SimonRC drdo gerard0 tempire jix stilgart AntiSpamMeta dp_wiz pcapriotti frigga1 quuxman tamiko mdmkolbe Dashkal Luke Bwild wilfredh sykora tew88 otterdam c1de0x ocharles joe-generic Paks xarch thetallguy smly- mattp_ rhapsodhy Valodim zorzar_ robinbb brainproxy __class__ Tene `0660_ copton_ LauJensen mimi_vx mrdomino zenzike_ edwtjo_ flori_ Sunhay Martty alpounet sunnavy rwbarton arkx_ mikeplus64 Utkarsh k6b hassing RogueShadow)
10:34:36 --- names: list (training4zombies dropdrive liesen SamB_XP hiredman R496 thirsteh average_drifter shachaf r126f ZenWare aristid-ic FalkoPeters bobry warpy Nisstyre brweber2_ NimeshNeema mndrix lopex puzza007 nkpart srid arnihermann_ ocharles_ Xorlev xrl tomh si14 mimico_afk IbnFirnas SeanTAllen tsou Nemykal welterde yrlnry Nshag identity_ gentz martiert ArchGT int-e _root_ jeff_s_ pyrtsa caligula jyyou zw01 moonlite Eliel saruman_ gwillen Counter-Strike zygoloid jaxtr tg)
10:34:36 --- names: list (klugez deggis kobsu bddn vmeson frontendloader Gracenotes nyingen suiside mbernstein ja_ alang setmeaway barrucadu helgikrs mee andrewsw wagle wting petanqk shutdown_-h_now hayashi gdeest kaitocracy wavewave Will| amiddelk olahol dnm Yarou ahf emias herself chris2 thetallguy1 kleini\ Urchin sordina1 i1126 agundry monochrom joachifm pantski bezik Masxmasx sipa solarus inr electrogeek jrockway hpaste_ noj Guest23437 ray Nereid phrst jlaire idnar integral)
10:34:36 --- names: list (samek ricky Derander prti opqdonut xaimus anssik chr1s_ Arnar dju noddy gereedy brendyn fabjan kalven quicksilver sagelywizard dcolish dax Wooga sohum zmoazeni_ Saizan nibalizer shepheb popx Belgarion0 cjay kosmikus eintopf Varakh Entroacceptor CosmicRa` chra Ptival hpc fall_ DrMahogny Munksgaa1d anders^^ adnam lnostdal mjhan_ tlockney mm|swarm zeiris bxc dominikh tazjin lispy dumael lpsmith wereHamster danr rmunroe ByronJohnson audunska_ brett)
10:34:36 --- names: list (thoughtpolice_ Vulpyne_ seabot Zarathu Tinned_Tuna sjl kiddesr_ duairc_ mokus dowski aliak_ flux Gilly angstrom luite jrk bogner sajith pqmodn FireFly norm2782 majuscule def-lkb oddraisent KitB dkasak scgilardi ppilate mehitabel locci clsmith fwg identity1 mlh tzxn3 pfoetchen CindyLinz nimred ccasin jamiely_desktop1 qtplatypus Nanar newsham ps-auxw lebastr reacocard ziman tsuraan__ fattrat Clex koala_man elgot Astro- ibid marienz jlouis rcj_ pdxleif)
10:34:36 --- names: list (companion_square kloeri jd10 jlewis @ChanServ ciaranm confound guerrilla aszlig Razz smop chee1 statusfailed cschneid Clint idoru Guest69499 Yahovah BlastHardcheese Ke cynick taruti nathanel_ yan_ Athas kategeek Veinor aristid absence ernst FUZxxl jackhill obcode mroman_ @Igloo jrslepak_neu srh jabirali deavid companion_cube aluink rhodesd ousado earthy canard Starfire Gothmog_ bens joni6128 pou kkris sully alexsdutton Gcool majoh dqd dino- dixie boyscared)
10:34:36 --- names: list (joe_k_ osfameron lokydor_ pi8028 froztbyte tridactyla Liskni_si Redshift64 dilinger Raynes brixen BigEndian mrshoe chipdude tomku mantovani mietek routin saiam robbert tomaw s4msung colah mrLite eyck jayne ivan` Maxdamantus othiym23 Aikawa liyang ybit thorkilnaur mendez srcerer snarkyboojum KaneTW Adios thoughtpolice levi seats _janne johs zomg pyykkis bd_ jaspervdj gdsx_ ehamberg limetree strlen Obfuscate PHO_ Draggor henr_k nihtml cmrn Pursuit fryguybob)
10:34:36 --- names: list (beppu dcoutts ChristianS ft BrianHV xplat ahkurtz_ sig_wall felipe_ SonicvanaJr mtbeedee davean kissyboy tafryn Laney Ayvee simsaladin noplamodo adnap mjrosenb McManiaC LeNsTR pharaun djanatyn gseitz eno mrd etpace tauntaun nand` mn90018 stepnem djahandarie mateu cola_zero jgr pr kizzo rvchangue Internet13 willb nlogax brandonw Cerise jssanders totte BMeph mike2 maloi hugin certainty tomprince hyko ggreg mux koeskoes anachron adnauseam)
10:36:21 <hpaste_> scooty-puff pasted “Doesn't work well (space leak) with writeRef, modifyRef, but works..” at http://hpaste.org/67934
10:37:31 <scooty-puff> wasn't sure if the k@(I# i), k' = I# i part was completely necessary (lines 94 - 96)
10:38:57 <danr> What is the intended monad for computeP in repa?
10:41:08 <c_wraith> danr: looks like it doesn't matter.
10:41:28 <c_wraith> danr: except that it should be strict in its effects
10:41:56 <c_wraith> danr: http://hackage.haskell.org/packages/archive/repa/3.1.3.3/doc/html/src/Data-Array-Repa-Eval.html#now
10:42:05 <Saizan> scooty-puff: so that v' doesn't reference k' too?
10:42:08 <c_wraith> danr: the now function is the one that introduces the monadic constraint
10:42:51 <osa1> so now I have a haskell program and I want to convert it to a cabal package, but I have no idea how can I know what versions and what libraries my package depends on. I'm only using some basic libraries like base and mtl but I don't know versions or other packages. is there an easy way to do that?
10:43:07 <scopedTV> trial and error
10:43:36 <c_wraith> osa1: set them to the exact versions you're using, wait for bug reports. :)
10:44:00 <scooty-puff> no - so the Weak should make a strong link from k to v, but the map should not, otherwise, the map would keep the value alive anyways - so the idea being once the Ref wrapper of k is dropped off, all strong references will be gone
10:44:10 <scooty-puff> or, any provided here anyways
10:44:30 <osa1> c_wraith: yeah that's what I was thinking. so I'll remove my .ghc and .cabal folders and then install pacakges until my app starts working, is it the only way to know what packages my app needs?
10:44:52 <scooty-puff> if i used k' in mkWeak, then the referred v may be gc'ed too early - while a Ref still exists
10:45:10 <c_wraith> osa1: well, if you're building with cabal, the app won't build until everything you need is in your build-depends section for the executable
10:45:20 <scooty-puff> Saizan: thats the intent anyways
10:45:44 <osa1> c_wraith: oh, so I don't need to remove installed pacakges
10:45:49 <c_wraith> osa1: correct
10:46:01 <osa1> ok, thanks
10:47:25 <Saizan> scooty-puff: i'm afraid i don't know System.Mem.Weak well enough to help
10:47:32 <scooty-puff> k
10:51:18 <hiptobecubic> scooty-puff is a great name.
10:52:19 <scooty-puff> pretty intimidating, though
10:54:56 <c_wraith> That was a great episode of Futurama. (All the time travel episodes are)
11:10:28 <pirosb3> hi guys! I wanted to ask you.. what are the pros of having referential transparency? I just dont get it
11:12:52 <c_wraith> pirosb3: Have you never wanted to understand what a function does without having to figure out the state of several global variables at the point it's called?
11:14:00 <pirosb3> c_wraith: the only reason I thing it would be great is caching on memory crunching functions
11:14:37 <pirosb3> how does a function work under the hood? how can referential transparency improve?
11:14:43 <quintess`> pirosb3: if you change a function but make sure it returns the same results, or if you call a function and don't use the result, you can be sure nothing else in your program has changed
11:14:52 <c_wraith> pirosb3: That turns out to usually not be any kind of optimization. The real benefits are to *the programmer*, not the compiler.
11:15:32 <pirosb3> so basically the benefits lie in the fact that these operation could also be called in a random order
11:15:41 <pirosb3> as they never change the internal state, correct?
11:16:39 <c_wraith> that's a minor detail.  the big thing is *they're easy to understand*.
11:17:08 <pirosb3> okay, are there any side effects?
11:17:16 <pirosb3> like what is bad about it?
11:17:26 <c_wraith> Once you know what a function does, you're done. There are no complex states to keep track of. There are no effects on other code.
11:18:25 <c_wraith> The only thing that makes referential transparency tough in most languages is that IO is usually represented as functions that cannot be made referentially transparent
11:18:42 <c_wraith> Haskell takes a different approach to IO that neatly sidesteps that problem.
11:19:27 <pirosb3> but how can you make IO referentially transparent?
11:19:40 <c_wraith> by making it not functions.
11:19:49 <c_wraith> You introduce a different abstraction - "actions"
11:20:00 <pirosb3> im probably a noob compared you you guys but I see IO really hard to return the same result
11:20:02 <c_wraith> And then you give rules for composing IO actions in a natural-feeling way
11:20:18 <pirosb3> okay, one last thing
11:20:27 <pirosb3> I heared about this "lazy" stuff of Haskell
11:20:46 <c_wraith> And the way that actions are constructed is referentially transparent.  Execution of actions is something entirely different
11:20:46 <pirosb3> basically as functions are referentially transparent they get exectuted when they want
11:20:55 <scopedTV> pirosb3: that's a reasonable formulation.
11:21:07 <pirosb3> or at least when they REALLY need to be called
11:21:10 <scopedTV> "values are evaluated as they're demanded"
11:21:38 <scopedTV> > let ones = 1:ones in take 10 ones
11:21:38 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
11:21:43 <pirosb3> as these functions are not computed when told them but only when they are needed, couldnt this slow up the process
11:21:46 <pirosb3> of the application
11:21:53 <mauke> pirosb3: why?
11:22:11 <pirosb3> lets say you want the application to process everything in a certain moment
11:22:12 <mauke> given that some stuff may never be needed, wouldn't it be a speed up?
11:22:13 <scopedTV> pirosb3: yes this is possible in fact. GHC has a strictness analyzer that avoids lazy evaluation if possible.
11:22:40 <pirosb3> lol :)
11:22:44 <scopedTV> mauke: needless jumps/thunks?
11:22:51 <pirosb3> what I am thinking is say
11:22:53 <quintess`> pirosb3: each value only gets computed once and saved after that, so the total time is about the same
11:22:59 <pirosb3> okay, this is a wired example
11:23:14 <pirosb3> so say we are applying mvc
11:23:20 <pirosb3> or some similar pattern
11:23:29 <pirosb3> you want all the processing to be done in the c
11:23:36 <pirosb3> before showing ANYTHING to the user
11:23:50 <pirosb3> once all the processes have returned their answer
11:23:56 <pirosb3> you get to show your result
11:24:02 <scopedTV> ah, but you can control this in Haskell.
11:24:11 <pirosb3> with "lazy mode" doesnt this work out bad?
11:24:15 * hackagebot jmacro 0.5.7 - QuasiQuotation library for programmatic generation of Javascript code.  http://hackage.haskell.org/package/jmacro-0.5.7 (GershomBazerman)
11:24:17 * hackagebot timeplot 1.0.8 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-1.0.8 (EugeneKirpichov)
11:24:19 <mauke> pirosb3: bad how?
11:24:21 <pirosb3> groovy
11:24:27 <mauke> I don't see the problem
11:24:47 <pirosb3> okay say I have a function which calculates the nth fib
11:24:57 <pirosb3> which takes loooads of time, lots of load
11:25:12 <scooty-puff> is it possible to enforce lack of sharing?
11:25:12 <pirosb3> i call my function and this returns immediately (lazy mode)
11:25:18 <pirosb3> when I want to display that value
11:25:24 <scooty-puff> such that two StableName's would never be equal?
11:25:25 <pirosb3> it automatically calculates it for me
11:25:37 <mauke> pirosb3: yes
11:25:41 <scopedTV> pirosb3: yes one can "force" the value in Haskell.
11:25:44 <pirosb3> say that it calculates it for me in the wrong way
11:25:48 <pirosb3> wrong time
11:25:50 <mauke> huh?
11:26:04 <scopedTV> so I can force the calculation in a background thread, and not calculate it on a GUI thread (for example)
11:26:13 <mauke> oh, yes
11:26:17 <pirosb3> I dont know if this is ACTUALLY a problem, im just trying to understand
11:26:17 <scopedTV> if you don't do this, you will get the behavior you described.
11:26:23 <pirosb3> I want you gurus to tell me!
11:26:31 <scopedTV> pretty good question :)
11:26:33 <pirosb3> okay groovy
11:26:50 <pirosb3> thx, just curious :)
11:27:03 <pirosb3> what is haskell used most for?
11:27:18 <scopedTV> pirosb3: I use it for calculations in computational geometry
11:27:40 <pirosb3> wow
11:27:50 <mauke> my window manager is written in haskell
11:27:55 <scopedTV> yes, mine too.
11:27:55 <pirosb3> :)
11:27:57 <scopedTV> xmonad.
11:28:01 <jfischoff> pirosb3: I use for game data processing.
11:28:04 <pirosb3> you guys look like a great community
11:28:06 <scopedTV> darcs is a Haskell program, a revision control system.
11:28:10 <pirosb3> have a great vibe
11:28:18 <pirosb3> what do you mean game data processing?
11:28:19 <scopedTV> there are three web frameworks.
11:28:45 <pirosb3> what are the advantages of using haskell as a web gframework?
11:28:47 <hpaste_> mefisto pasted “beginner question” at http://hpaste.org/67938
11:29:00 <scopedTV> for me? strong and static typing.
11:29:06 <jfischoff> pirosb3: games produce a lot of text like data and art assets that need to converted into a format the engine can understand. I do that with haskell.
11:29:19 <scopedTV> mefisto: identation is incorrect
11:29:28 <pirosb3> what are the strengths and weaknesses of the language?
11:29:30 <scopedTV> mefisto: make sure the ( and the b are in the same column in line 9, 10
11:29:43 <pirosb3> it is also declarative to some extent right?
11:29:48 <scopedTV> pirosb3: very much so
11:29:56 <jfischoff> pirosb3: the biggest weakness is not that many people know it
11:30:14 <pirosb3> that's a pity, the logo is really cool
11:30:38 <scopedTV> weakness: lack of uptake (still, but it's not so bad anymore); if you want realtime or code swapping or other vary advanced features you need a RTS for that supports them
11:30:51 <pirosb3> what is the difference between declarative and functional?
11:31:25 <mefisto> scopedTV: oh... interesting, ok. thanks
11:31:45 <mauke> I think the difference is that functional has a clear direction
11:32:09 <pirosb3> kk
11:32:12 <pirosb3> cool
11:32:20 <pirosb3> it was really great speaking to you guys
11:32:26 <pirosb3> might pop in here more ofthen
11:35:26 <timtheli1n> It's a pitty, even Haskell's strong type system cannot prevent bad coding practices :(
11:36:56 <jfischoff> That's a feature. Haskell is pragmatic you see. :)
11:38:30 <scooty-puff> anyone know how System.Mem.Weak.mkWeak uses the key?
11:39:55 <dgpratt> I believe I understand why it does not, but still I wish that Haskell was somehow able to capture non-termination in its type system
11:40:14 <timtheli1n> The problem, is that I kept on adding |'s to the data.  You know. data DisplayCell = DisplayCellCode foo | DisplayCellComment foo | DisplayCellArguemnt foo | DisplayCellFoo foo | DisplayCellBar foo... And then I have functions that only take a DisplayCellBar, yet there is no way to make their type restricted to DisplayCellBar...  The closest I can define the type is to DisplayCell
11:41:22 <Quantumplation> So, i'm starting the implementation for some research I'm doing.  Trying to come up with the best way to structure the data in Haskell.
11:41:53 <timtheli1n> Quantumplation: I can give you a link to a package demostrating how NOT to do it :D
11:41:55 <quintessence> scooty-puff: it puts it in a table so the GC can run the finalizer (and clear the reference) when it frees the key
11:42:16 <timtheli1n> But really, how SHOULD I have written DisplayCell?
11:42:36 <jfischoff> timtheli1n: paste it. You have the write goal. Your functions should be total
11:42:58 <jfischoff> timtheli1n:goto run, I'm sure someone else will be able to help
11:44:28 <scooty-puff> quintessence: how are keys compared?
11:44:29 <timtheli1n> https://github.com/timthelion/gridhaskell-haskarrow/blob/master/DisplayCell.lhs that's where you find it, Display cells are packed into a list which is then Displayed in a http://imageshack.us/f/94/gridediteditcell.jpg/ table
11:44:29 <Quantumplation> I have a set of Tiles, which can be visualized as 3D cubes.  each face of the cube has a "glue", which is just some unique identifier (string, int, whatever).  Tiles can't rotate, and two tiles can merge into a "super tile" if opposite faces share a "strength 2 glue" (ie, the top face of one and the bottom face of another)
11:45:45 <scooty-puff> quintessence: i assume by ptr comparison - in that case: how can i assure myself that two values definitely are not equal - even with optimizations
11:45:45 <timtheli1n> So I need a function drawDisplayCells :: [DisplayCell] -> Table -> IO... But also a function drawDisplayCellCode :: DisplayCellCode -> VBox -> IO
11:46:20 <Quantumplation> Supertiles can then merge into larger supertiles, if there is some arrangement such that either a face from one and an opposite face from another have a strength two glue (and there's no overlaps in that configuration), or you can find two pairs of strength-1 bonding faces.
11:46:42 <timtheli1n> How can I make a list of DisplayCells, and at the same time, be able to restrict drawDisplayCellCode which only ever takes DisplayCellCode..?
11:46:49 <Quantumplation> My original idea is to have data Face a = Left a | Right a | Top a | ... etc.
11:48:07 <Quantumplation> so that I can pattern match on the Face type to return the opposite
11:48:24 <Quantumplation> but I'm thinking that might create some overly verbose code
11:48:26 <timtheli1n> Perhaps I should have made DrawableDisplayCell a type class...
11:49:02 <mah_b> Quantumplation: maybe you could paste a bit of your code?
11:49:19 <Quantumplation> mah_b: I don't have code yet
11:49:26 <Quantumplation> I'm trying to come up with how to structure the data
11:49:31 <quintessence> scooty-puff: having two keys (perhaps unexpectedly) equal can only make the finalizer run later than it would if they were different. The GC can already collect things as late as it likes, so this isn't a problem in theory
11:49:49 <Quantumplation> then I was thinking I could just store type Tile = [(a,a)], an array of "direction pairs".  that allows it to extend into arbitrary dimensions
11:49:56 <Quantumplation> 2D, 3D, etc.
11:50:14 <Quantumplation> so, it would be like, [(top, bottom), (left, right), (front, back)]
11:50:44 <Quantumplation> but i'm not sure if that would work well either
11:51:15 <Hipolitus> Hello
11:51:58 <zachk> hi
11:54:08 <Hipolitus> Is there a implemention of some interpreter implemented in Haskell?
11:54:21 * hackagebot aws 0.4.1 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.4.1 (AristidBreitkreuz)
11:54:23 <Clint> yes
11:54:23 <timtheli1n> > concatMap $ zipWith (++) ["H","p","l","t","s","H","l","o"] ["i","o","i","u",":","e","l"]
11:54:24 <lambdabot>   Couldn't match expected type `a -> [b]'
11:54:24 <lambdabot>         against inferred type `[[GH...
11:55:05 <Hipolitus> Hello timtheli1n :)
11:55:13 <timtheli1n> Hmm
11:56:22 <Hipolitus> > zipWith (++) ["H","p","l","t","s","H","l","o"] ["i","o","i","u",":","e","l"]
11:56:24 <lambdabot>   ["Hi","po","li","tu","s:","He","ll"]
11:56:31 <timtheli1n> > concat $ zipWith (++) ["H","p","l","t","s","H","l","o"] ["i","o","i","u",":","e","l",""]
11:56:33 <lambdabot>   "Hipolitus:Hello"
11:56:38 <timtheli1n> :D
11:56:39 <Hipolitus> >concat zipWith (++) ["H","p","l","t","s","H","l","o"] ["i","o","i","u",":","e","l"]
11:56:48 <Hipolitus> ops
11:56:50 <tgeeky> can someone think up of a reason to wrap this: http://code.google.com/p/ceres-solver/ in Haskell? Maybe convince bos to do it?
11:57:01 <bos> ha ha
11:57:30 <c_wraith> C++ is hard to wrap,  unfortunately.
11:57:52 <scopedTV> ugh yeah, that's one of my main problems with C++ actually
11:58:02 <scopedTV> rather, why I would not use haskell sometimes
11:59:16 <tgeeky> I am way too stupid (read: likely to shoot myself in the face) to use C++.
11:59:17 <Hipolitus> I'm searching something like this http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
11:59:32 <Hipolitus> but a little more simple
11:59:45 <scopedTV> tgeeky: haskell > C++ obviously
11:59:47 <timtheli1n> c_wraith: but rapping c++ :D... I put a main paren close paren, f*kin currlybraket printf,An a nutha paren hangin there, like a f*kin b*tch
11:59:53 <scopedTV> but at least with C libraries you can easily link
11:59:57 <scooty-puff> quintessence: problem i am worried about is that a key should be used as the key in an intmap, which holds weak values.  the weak values were created by another key, that will be held on to to maintain the value is strongly held - BUT, the key used as the key in the int map should not hold the weak value (was not used in the mkWeak function)
11:59:59 <Hipolitus> C++, ummm, for sufering I prefer Scala
12:00:05 <scooty-puff> ok, that was longer than i wanted
12:00:12 <dino-> I just had an amazing monads day with Haskell. Wow.
12:00:19 <scopedTV> why is Scala so bad? because it's very big?
12:00:35 <Hipolitus> yes
12:00:43 <c_wraith> Scala just tries to do everything at once.  The result is huge and has lots of strange corners
12:00:50 <Hipolitus> tell us dino-
12:00:57 <dino-> By moving one small amount of early IO code outside of my trans stack and using the result of that in the Reader, I was able to turn a vast swath of this project into pure code by completely elminating IO.
12:01:09 <tromp> maybe it's trying to be too big to fail
12:01:10 <dino-> Literally dozens of actions in this transformer.
12:01:27 <c_wraith> dino-: sounds satisfying
12:01:29 <Hipolitus> somebody knows a simple interpreter example?
12:01:43 <dino-> Viciously controlling side-effects ftw
12:02:10 <Hipolitus> dino-: can we see the code?
12:02:14 <hpaste_> scooty-puff pasted “Illustration” at http://hpaste.org/67940
12:02:20 <scooty-puff> quintessence: see the paste
12:02:38 <dino-> Hipolitus: yes.. but it's big. I'll push to the repo
12:03:05 <Hipolitus> bitbucket ?  github?
12:03:12 <dino-> darcs, my own server
12:03:33 <dino-> It's hosted, by me, but just haven't pushed yet. Will do now.
12:04:10 <scooty-puff> quintessence: in the paste, i know the intmap could grow unbounded for forever $ newRef True, or whatever
12:04:14 <dino-> c_wraith: speaking of side-effects, not so easy to avoid them in Scala either.
12:04:25 <scooty-puff> but would forever $ newRef giantObject
12:04:36 <scooty-puff> would like that to fail later than it otherwise would
12:05:44 <scooty-puff> (pretending giantObject is really mkGiantObject >>= newRef)
12:07:08 <scooty-puff> meh, maybe i should just stop worrying about it
12:07:16 <dino-> Hipolitus: It's the epub-tools project, here: http://ui3.info/d/proj/epub-tools.html  darcs repo: $ darcs get http://ui3.info/darcs/epub-tools
12:08:28 <scooty-puff> i can either have a leak due to repeated modification, or  leak due to new references..
12:09:22 <scooty-puff> f it, removing the Weak stuff
12:10:08 <quintessence> scooty-puff: I think people build non-leaking weak datastructures by using the finalizer to clean up when an element gets freed
12:10:26 <quintessence> but I've never used the Weak stuff, I just read the paper.
12:10:32 <scooty-puff> k
12:10:35 <c_wraith> Yeah, that's what you have to do.
12:10:50 <scooty-puff> (do you have a link to the paper handy?)
12:11:43 <quintessence> http://community.haskell.org/~simonmar/papers/weak.pdf
12:12:43 <scooty-puff> what do you do if you have a map to weak values, some references strongly referencing those values, and then "update" the references by IntMap.adjust'ing the weak values (creating a new Weak key'ed to the original key) - problem here is that original key will still be strongly referenced, so now you have two values considered as strong referenced by that original key (due to the two mkWeak calls)
12:13:27 <scooty-puff> actually, that paper will prob cover that
12:16:04 <osa1> how are this two patterns overlapping: http://pastebin.com/uzjisTku ?
12:16:06 <mauke> The paste uzjisTku has been copied to http://hpaste.org/67941
12:16:29 <scopedTV> osa1: [_] means "a list with exactly one entry."
12:16:37 <scopedTV> (_:xs) means "a list with at least one entry"
12:22:52 <keep_learning> Hello all
12:23:08 <scopedTV> hi keep_learning
12:23:39 <keep_learning> I saw this automatic parallelization for C code http://www.ece.lsu.edu/jxr/pluto/index.html
12:24:02 <keep_learning> is there  any plans in the near future with automatic parallelization with Haskell code
12:25:48 <dmwit> No.
12:25:49 <hpc> keep_learning: there's no automated way to find the ideal granularity
12:26:59 <dmwit> However, there are many resources for making parallelization annotations cheap.
12:27:26 <dmwit> Check out Data Parallel Haskell, the work on strategies for parallel computation, and the IVar line fo work.
12:28:04 <dmwit> (here "cheap" means "takes little programmer effort" or maybe "only requires small changes to the source text")
12:29:07 <dmwit> You might also like the work on STM, though that is more about concurrency than parallelism.
12:30:30 <zaltekk> when you differentiate between concurrency and parallelism, are you using concurrency to mean on a single machine and parallelism to mean on multiple machines? or drawing the line at cpu cores?
12:31:17 <hpc> concurrency is "multiple threads"
12:31:17 <keep_learning> Sorry , disconnet
12:31:27 <keep_learning> *disconnected
12:31:29 <hpc> parallelism is "compute pure values at the same time"
12:31:59 <hpc> x `par` y `pseq` f x y -- compute x and y at the "same time", then return (f x y)
12:32:11 <hpc> forkIO and friends are concurrency primitives
12:32:48 <dmwit> I would use "distributed" to talk about computing on multiple machines.
12:33:05 <zaltekk> hmm. okay then
12:33:24 <hpc> parallelism is more or less "i don't care what the order is, so do both at the same time if you can"
12:33:28 <dmwit> The difference between parallel and concurrent is that with concurrency, you expect (and, generally, want) the program to behave differently if things get scheduled differently.
12:33:41 <hpc> concurrency is "run these at the same time, and they may or may not have side effects, deadlocks, etc"
12:33:49 <dmwit> With parallel, you always want the same thing to happen (though perhaps at different speeds) no matter the schedule.
12:40:17 <dmwit> keep_learning: Oh, you got disconnected? Did you see our answers?
12:40:29 <dmwit> However, there are many resources for making parallelization annotations cheap.
12:40:32 <dmwit> Check out Data Parallel Haskell, the work on strategies for parallel computation, and the IVar line fo work.
12:40:39 <dmwit> Check out Data Parallel Haskell, the work on strategies for parallel computation, and the IVar line fo work.
12:40:42 * Clint gets deja vu
12:40:49 <dmwit> (here "cheap" means "takes little programmer effort" or maybe "only requires small changes to the source text")
12:40:50 <keep_learning> some of answers
12:40:58 <dmwit> You might also like the work on STM, though that is more about concurrency than parallelism.
12:41:09 <dmwit> okay, done, sorry rest of channel for the repeat spam
12:46:26 <adimit> I am confused. I was going to see if I can understand how GHC works "under the hood." So far so good, but some methods in GHC.Prim have me confused. Specifically the *Char# ones. They all have the same "implementation": let x in x = x. This should be equivalent to id? But then gtChar# and geChar# etc. do the Right thing. Am I correct to assume that some process during the build just replaces these with,
12:46:28 <adimit> say, C implementations?
12:47:15 <scopedTV> let x = x in x you mean?
12:47:28 <adimit> scopedTV: of course.
12:47:35 <scopedTV> this is not "id", this is _|_
12:47:39 <rwbarton> can you paste a whole definition?
12:47:42 <keep_learning> dmwit,  For automatic parallelization , I was thinking that let say we want to compute  a  list. Rather then using explicit par and pseq  , the compiler itself will break the list into chunks with some analysis ( which is large enough for parallelism )
12:48:11 <adimit> rwbarton: it's best to just look at it here: http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.2.0.0/src/GHC-Prim.html#Char%23
12:48:14 <dmwit> keep_learning: May I reiterate my suggestion to look at Data-Parallel Haskell?
12:48:32 <rwbarton> mysterious
12:48:39 <adimit> all functions in the entire module seem to follow the same pattern!
12:48:43 <keep_learning> dmwit, Oh Thank you
12:49:08 <adimit> scopedTV: yes, it's _|_, silly me. Sorry, wasn't paying attention.
12:49:09 <dmwit> (That is literally the first suggestion I made...)
12:49:10 <scopedTV> I think your hunch might be correct, but I don't know.
12:49:27 <rwbarton> i would have expected something like a primop declaration
12:50:14 <adimit> the file bears the comment "this is a generated file" right at the top, so I guess there's some magic behind the build process.
12:50:34 <rwbarton> aha
12:50:44 <adimit> also, Char#'s definition as Char# (and the same for Int# etc.) is mighty useless the way it's there.
12:51:42 <adimit> The utility lives in utils/genprimopcode in the GHC source tree. Oh well, I'll keep poking.
12:52:37 <tazjin> The file doesn't just say "This is a generated file", it also says "It is not code to actually be used. Its only purpose is to be consumed by haddock."
12:53:02 <tazjin> i.e. this is not the actual implementation, it's just the file used to generate the documentation
12:53:04 <adimit> tazjin: then what *does* generate these functions and data type declarations?
12:53:56 <Igloo> They're wired-in, e.g. in compiler/prelude/TysWiredIn.lhs
12:54:03 <rwbarton> compiler/prelude/primops.txt.pp from a source distribution
12:54:28 <adimit> ah, thanks, Igloo and rwbarton!
12:59:32 <singpolyma> is there a common module for doing a recursive directory copy in haskell?
13:13:48 <adimit> ooh. GHC is confusing.
13:14:25 * hackagebot jmacro 0.5.8 - QuasiQuotation library for programmatic generation of Javascript code.  http://hackage.haskell.org/package/jmacro-0.5.8 (GershomBazerman)
13:14:27 * hackagebot secure-sockets 1.2.4 - Secure point-to-point connectivity library  http://hackage.haskell.org/package/secure-sockets-1.2.4 (DavidAnderson)
13:18:41 <roha> hmm, does somebody have an idea for a little haskell project? mainly to get some practice but if it could be helpful to others, that would be even better! an xmonad extension perhaps?
13:19:30 <tazjin> adimit: Have you read this paper http://community.haskell.org/~simonmar/papers/aos.pdf ?
13:20:32 <adimit> tazjin: yes, though it's been a while.
13:22:47 <adimit> it gives a very nice bird's eye view, but the details of the code are what's currently confusing me. No help though, gotta read it, break it, fix it, and see what comes :-)
13:30:02 <hiptobecubic> I'm trying to figure out how to use Repa and I see the following type signature...
13:30:33 <hiptobecubic> computeUnboxedP  :: (Monad m, Data.Vector.Unboxed.Base.Unbox e,  repa-3.1.3.3:Data.Array.Repa.Eval.Fill.Fill r1 U sh e) =>     Array r1 sh e -> m (Array U sh e)
13:30:57 <hiptobecubic> Why is this monadic?
13:31:17 <c_wraith> hiptobecubic: look at now
13:31:34 <hiptobecubic> c_wraith, sorry what?
13:31:39 <c_wraith> http://hackage.haskell.org/packages/archive/repa/3.1.3.3/doc/html/src/Data-Array-Repa-Eval.html#now
13:31:43 <hiptobecubic> ohh it's function
13:31:47 <c_wraith> that's the sole reason it's monadic
13:32:01 <c_wraith> basically, to use effect sequencing to ensure the calculation actually happens.
13:32:05 <hiptobecubic> i guess http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Repa_Tutorial#The_force_function_has_the_loops  is too out of date to be useful now
13:32:23 <hiptobecubic> anyway thanks
13:33:35 <Eduard_Munteanu> Mmm, that doesn't make much sense... why not return arr directly?
13:33:53 <ericmj> Can I use hWaitForInput with a Handle set to binary mode and will it wait for a single byte instead of trying to decode a character?
13:34:12 <c_wraith> I'm not sure *why* repa chose that approach.  I'm just reporting what I see from looking at the code
13:34:26 * hackagebot weather-api 0.1.0 - Weather api implemented in haskell  http://hackage.haskell.org/package/weather-api-0.1.0 (PeterGoncharov)
13:34:39 <c_wraith> ericmj: if you want single bytes, you should be using bytestring IO. But then the rest of what you say sounds right.
13:35:19 <ericmj> Will hWaitForInput work with bytestring IO?
13:36:34 <c_wraith> @hoogle hWaitForInput
13:36:35 <lambdabot> System.IO hWaitForInput :: Handle -> Int -> IO Bool
13:36:35 <lambdabot> GHC.IO.Handle hWaitForInput :: Handle -> Int -> IO Bool
13:36:37 <c_wraith> yes
13:36:52 <ericmj> great, thanks
13:37:47 <c_wraith> ericmj: oh, wait. I misremembered its documentation. Looks like it won't return always. Hmm.  There's some way to do this.
13:37:59 <hiptobecubic> c_wraith, is that the most reasonable way to do this then? I am trying to parallel map over an array and return a plain unboxed vector
13:38:21 <hiptobecubic> My original idea was:   samples = R.toUnboxed . R.computeUnboxedP $ R.map f seeds
13:38:59 <hiptobecubic> But maybe "deepSeqArray" is also a possibility
13:39:34 <hiptobecubic> although deepSeqArray doesn't mention parallelism at all, so I don't know what it does
13:39:45 <c_wraith> hiptobecubic: not sure. I haven't actually used repa. It's just that someone else asked the same question this morning.
13:39:52 <hiptobecubic> funny
13:39:58 <ericmj> c_wraith: what do you mean it wont return always? hWaitForInput?
13:40:28 <c_wraith> ericmj: yeah, it attempts to do character decoding. It will block if it receives a byte that doesn't represent a full character
13:40:55 <ericmj> even if the handle is set to binary mode?
13:43:19 <c_wraith> ericmj: yeah. binary mode is unfortunately named.
13:43:47 <hpaste_> ocharles pasted “Overlapping instances” at http://hpaste.org/67947
13:44:03 <ocharles> Is there anyway to write the above paste, without getting an error about overlapping instances?
13:44:26 <ocharles> What i'm trying to do is have a naive 3 way merge for stuff that can be considered equal, but overriding merge logic for certain data typs (Sets, in this case)
13:44:40 <ocharles> But as Set a is also Eq a, there are overlapping instances
13:45:16 <reinoud> Hi folks,
13:45:17 <c_wraith> ericmj: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent.html#v:threadWaitRead is the primitive I was thinking of, but it works with FDs, rather than Handles
13:45:43 <reinoud> what is the most logical explanation about what could be wrong with my program when i get "Stack space overflow: current size 8388608 bytes."
13:46:20 <c_wraith> reinoud: usually, building up a giant thunk and then attempting to evaluate it.
13:46:51 <jfischoff> c_wraith: can you get that if you recurse infinitely?
13:47:19 <ment> is "reverse" O(n)?
13:47:28 <scopedTV> ment: yes.
13:47:46 <ClaudiusMaximus> ocharles: personally i'd do newtype EqMerge a = EqMerge a ; instance Eq a => Mergeable (EqMerge a) where ...   and write a mergeEq helper that wraps/unwraps the newtype
13:48:03 <ocharles> ClaudiusMaximus: i had a feeling a newtype would be my only option
13:48:12 <ocharles> i hadn't thought as far as the mergeEq helper though, that could work...
13:48:34 <ericmj> c_wraith: Okay, that seems to be what I am looking for. Is there any practical difference between a Fd and a Handle?
13:48:48 <ClaudiusMaximus> ocharles: the problem is that instance ... => Merge a  overlaps with everything, because the left of the => isn't taken into account when looking for a match
13:49:02 <ocharles> ClaudiusMaximus: if I have mergeEq, is there much point in the new type at all?
13:49:06 <IboS> hi
13:49:14 <ocharles> i might as well move the Eq instance to mergeEq
13:49:17 <IboS> why java is full of viruses ?
13:49:21 <ClaudiusMaximus> ocharles: well, probably not
13:49:33 <ocharles> ClaudiusMaximus: yea, that always catches me atm
13:49:39 <scopedTV> IboS: because it's dysfunctional.
13:49:43 <scopedTV> haskell is functional and has no viruses
13:49:44 <cleardance> Lol in #java someone said to IboS that virus questions should be asked in #haskell
13:49:47 <ocharles> i need to remember that what I "intuitively" think will happen is not how the search actually happens
13:49:57 <IboS> last time i went on a website which asked me to install jvm and  i lost my datas
13:49:57 <ClaudiusMaximus> ocharles: but it depends if you write some code that generically needs any mergeable thing, and then you can feed it a wrapped version
13:50:08 <c_wraith> ericmj: well, yes. The practical difference is that they are different types, and have different functions available, etc. You can convert between them, but be aware that extracting the Fd from a Handle closes the Handle, so you'll need to construct a new Handle from the Fd. It's a bit silly.
13:50:18 <scopedTV> cleardance: lol
13:50:36 <IboS> who's the president of java so i can send him a letter
13:52:20 <reinoud> tnx... hmmm this algorithm is then not really suited for Haskell... it needs to build a world model datastructure and then extract data from it. I guess it gets either too lazy OR too eager to evaluate and things go wrong. Or there is just one case that is keeping stuff around :-/ hmmm
13:52:38 <adimit> IboS: Susilo Bambang Yudhoyono — who is the president of Indonesia, but since Java is part of Indonesia, I guess that's what you meant.
13:52:39 <ment> scopedTV: well, that pretty much solves my queueing problem
13:52:47 <scopedTV> how to get help from #haskell. say "it's not really suited for Haskell"...
13:52:56 <c_wraith> reinoud: usually, problems like that can be solved pretty easily - you just need to know where (and how) to make an accumulator strict
13:52:59 <ericmj> c_wraith: Okay, so I can't use the Fd and the Handle at the same time. But you say that handle i closed, say if I have an open socket connection, the connection wont be closed. right?
13:53:50 <c_wraith> ericmj: if you extract the Fd from a Handle, the Handle will become invalid, but the connection will remain open.
13:54:16 <c_wraith> ericmj: I should back up a second, though, and ask what you're really doing. It's possible you don't need this complexity.
13:58:17 <ericmj> i have a thread which only do sockets receives and puts the data in a mvar. the thing is i want to to be able to cancel the thread and keep the socket alive. so i use throwTo to cancel the thread, but then the thread can receive the exception between receive and putMVar and i will lose data. so i want to wait on data and mask for exceptions while i do the receive and putmvar.
13:58:57 <ericmj> there might be a simpler way...
13:59:50 <c_wraith> masking exceptions won't even work during blocking reads/writes. They explicitly unmask, regardless of what you do.
14:00:02 <Peaker> today I realized that polymorphic variants are sort of a duel to a structural record system, and that Haskell could really benefit from both :)
14:00:23 <tromp> > log 6 / log 2
14:00:23 <lambdabot>   2.584962500721156
14:00:38 <scopedTV> tromp: there's also logBase :)
14:00:46 <hpc> @src logBase
14:00:47 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
14:00:47 <tromp> :t logBase
14:00:48 <lambdabot> forall a. (Floating a) => a -> a -> a
14:00:53 <c_wraith> But will things really be throwing async exceptions to your threads, and then expecting them to still be working properly? Hmm
14:00:57 <scopedTV> > logBase 2 6
14:00:58 <lambdabot>   2.584962500721156
14:01:00 <ericmj> c_wraith: but it wont be a blocking read, since i am sure there will be data availble to read when i do the reading
14:01:05 <Peaker> The fact we have to rigidly declare all of our record products and all of our sums and give them names, means we really can't have nice fine-grained products/sums in sub-expressions that capture the exact ranges of values -- which usually leads to broader types than necessary and unsafety
14:01:29 <c_wraith> ericmj: unfortunately, the IO manager doesn't distinguish between those cases
14:01:29 <tromp> > 4/logBase 2 6
14:01:30 <lambdabot>   1.5474112289381665
14:01:39 <ericmj> c_wraith: so how should i cancel my receiving thread?
14:03:32 <c_wraith> ericmj: not sure. I haven't had to deal with that use case.
14:03:55 <jfischoff> Peaker: Can you give an example?
14:03:57 <scooty-puff> when can i be certain i need to mark NOINLINE a call to unsafePerformIO?
14:04:06 <scooty-puff> so for allocating an IORef
14:04:14 <scopedTV> you never need to do it, since you wrote unsafePerformIO.
14:04:29 <scopedTV> so your IO action has no side effects, or at least you odn't care how often they are executed.
14:04:38 <scooty-puff> Peaker: this feels like it relates to extensible records
14:04:47 <scooty-puff> i use them when building the symbol table for a compiler in multiple passes
14:04:59 <scopedTV> at least you told that to the compiler.
14:05:06 <scooty-puff> each pass may add or use data from each symbol's associated record
14:06:41 <Peaker> jfischoff, for structural records, a small function that builds 80% of the record, and an outer function building the rest of the 20%
14:06:43 <ericmj> c_wraith: Will hGetBufNonBlocking unmask?
14:07:14 <Peaker> jfischoff, you want to be able to easily encode the result of the small function as a type -- but you're force to make a sub-record, which breaks down if you have a different 80% built by another function
14:07:17 <c_wraith> ericmj: I'm not sure. I'd say "check the source", but that might end up being a long dive into the guts of the IO manager
14:07:36 <Peaker> jfischoff, or you could make a duplicate of all these fields in another record, but that's very cumbersome
14:07:38 <hiptobecubic> c_wraith, "Repa 3.1 no longer requires the explict use of now. The parallel computation functions are all monadic, and automatically apply deepSeqArray to their results."
14:07:55 <ericmj> Yeah, I am still thinking there must be an easier way to do this
14:08:05 <c_wraith> hiptobecubic: that just means they apply now themselves :)
14:08:24 <quintessence> ericmj: you could have the worker poll a ref or mvar at points where it's safe to stop, and have the main thread write to that when it wants the worker to stop
14:08:25 <Peaker> jfischoff, For polymorphic variants -- imagine having a case statement do a special handling of 1 case, and then in all other cases, you have common handling. However, the common handling itself passes the case'd value to another function. Now the type being passed is overly broad and contains the constructor we've already ruled out
14:08:45 <Peaker> scooty-puff, extensible records are pretty much structural records, aren't they?
14:09:20 <ericmj> quintessence: no i cant, because waiting on IO is blocking. So I cant read from a mvar at tthe same time
14:09:44 <Peaker> jfischoff, in my current project, I keep hitting annoying cases where having the sum/product tailored for the exact value I'm buliding would be possible if only anonymous sums/products were possible in Haskell
14:10:18 <hiptobecubic> c_wraith, yes
14:11:06 <dmwit> ericmj: I suspect that you'll need to back up an abstraction level if you want better advice.
14:11:27 <jfischoff> Peaker: are tuples not product types?
14:12:03 <jfischoff> Peaker: is it that you want something like a tuple with field names?
14:12:05 <acowley> when you project them, do they not yield components?
14:12:21 <Peaker> jfischoff, yeah, tuples are a good approximation of anonymous product types, so the problem there is less severe. But they're not records, so it's a bit annoying that you have to return something like (Int, Int, String) where you want these to fill particularly named 3 fields in a larger record
14:12:51 <jfischoff> \me:jfischoff nods
14:12:56 <acowley> If you tickle an Either, does it not slap you?
14:13:05 <Peaker> jfischoff, with sums the problem is much worse, you're not going to return nested Eithers
14:13:26 <acowley> jfischoff: You still have a key bound to your own name, don't you?
14:13:26 <jfischoff> Peaker: completely agree.
14:13:56 <jfischoff> acowley: I'm don't know. What does it mean to have a key bound to your name?
14:14:27 <dmwit> Like, do you have a button on your keyboard that puts your name into the text you're typing?
14:15:02 <jfischoff> not that i know of
14:15:58 <anachron> I have a function which returns "State PureMT Int". I would like to use this function from within a monad of type "StateT PureMT IO ()", but wrapping it in runState and using get/put causes unacceptable overhead (2x running time). Is it possible to do this in a more efficient way?
14:16:33 <dmwit> Make the function be more polymoprhic.
14:16:58 <dmwit> Make it be MonadState m PureMT => m Int.
14:17:28 <c_wraith> flexiblecontexts, ohnoes!
14:17:40 <anachron> dmwit: will try that, thanks
14:17:57 <scooty-puff> Peaker: extensible records might be able to be thought of sort of like anonymous records, depending on how they are implemented (if order of record name matters, etc.)
14:18:00 <hiptobecubic> So i guess this has to be done in a monad?
14:18:17 <scooty-puff> but it makes it so you can use constraints to say what a record passed as an argument must contain
14:18:18 <Cale> hiptobecubic: what does?
14:18:35 <c_wraith> hiptobecubic: you could always make m Maybe
14:18:42 <hiptobecubic> Cale, I'm just trying to learn how to use Repa. The tutorial on the wiki is out of date
14:19:07 <c_wraith> hiptobecubic: then pattern-matching on the constructor will force the computation
14:19:08 <scooty-puff> Peaker: so you could have f produce {one: Int, two: String}, which is called by g, and have g add in three: Bool
14:19:13 <hiptobecubic> c_wraith, hmmm yes I guess so...
14:19:26 <scooty-puff> so g would produce {one:..., two:..., three:...}
14:19:42 <Peaker> scooty-puff, yeah
14:19:44 <scooty-puff> though only haskell libs exist for it - so the syntax is a little verbose
14:20:27 <hiptobecubic> Cale, computeUnboxedP :: (Fill r1 U sh e, Monad m, Unbox e) => Array r1 sh e -> m (Array U sh e)
14:20:42 <quintessence> Peaker: As far as I can tell, a record system is "extensible" if it can type the operation that adds a (known) field to some (unknown) type of record
14:21:12 <hiptobecubic> It seems strange to put it in a Maybe for the express purpose of taking it out again but I guess that's how it works?
14:21:39 <hiptobecubic> The examples all have everything running in main where you can just lean on IO and "do arr <- Repa.whatever"
14:21:47 <c_wraith> hiptobecubic: you're right, it is a bit strange. But.. That's how it's written.
14:21:59 <scooty-puff> optional may be implicit conversion between records of the same set of names (or have order just not matter), if the unknown record must have a Lacks constraint, prob other things
14:22:10 <hiptobecubic> I'm not very monadic yet
14:22:15 <anachron> dmwit:     Kind mis-match
14:22:15 <anachron>     The second argument of `MonadState' should have kind `* -> *',
14:22:15 <anachron>     but `PureMT' has kind `*'
14:22:32 <c_wraith> anachron: then he got the arguments backwards. swap them. :)
14:22:40 <c_wraith> MonadState PureMT m
14:23:15 <Peaker> quintessence, that sounds useful, though maybe even something weaker could be nice
14:23:27 <lesshaste> juliohm, hi
14:24:22 <Cale> hiptobecubic: okay, the use of monad there is *totally* nonessential, and I don't actually understand why it's involved in that type signature
14:24:26 <juliohm> lesshaste, hi, i can't remember exactly if is possible or not, but that's not a big problem right now for me. ;-)
14:24:58 <lesshaste> julmuri, sure... I just like it when they tell me things here :)
14:25:20 <julmuri> ;o
14:25:37 <hiptobecubic> Cale, i guess it's to make sure you get parallel computation and don't let it lazy drift to the end of the program and run on one thread that's trying to wrap things up
14:25:40 <Cale> hiptobecubic: My guess is that they're having it work in an arbitrary monad just so that it helps you keep track of the order in which things are being computed strictly, because that operation does a deepSeq
14:26:00 <Cale> But they're literally just wrapping the thing up in return
14:26:29 <Cale> So you can use the identity monad if you want
14:26:42 <hiptobecubic> Cale, hmm
14:26:43 <lesshaste> julmuri, oops. sorry
14:26:49 <lesshaste> juliohm, ^^
14:26:54 <hiptobecubic> Cale, I guess I'll go read how that works
14:27:01 <Cale> hiptobecubic: Well, it's just:
14:27:05 <c_wraith> well. if you use non-strict identity, you won't end up actually forcing the evaluation
14:27:11 <Cale> newtype Identity a = Identity a
14:27:17 <c_wraith> and that's non-strict identity
14:27:23 <Cale> runIdentity (Identity x) = x
14:27:48 <Cale> instance Monad Identity where return = Identity; (Identity x) >>= f = f x
14:28:38 <Cale> hiptobecubic: So it's a monad where  v <- x  and  let v = runIdentity x  are essentially the same thing.
14:28:58 <hiptobecubic> Sounds simple enough.
14:29:02 <c_wraith> Cale: using non-strict identity means that you're no longer controlling the time when the evaluation takes place, though.
14:29:33 * hackagebot anydbm 1.0.7 - Interface for DBM-like database systems  http://hackage.haskell.org/package/anydbm-1.0.7 (JohnGoerzen)
14:29:45 <Cale> What do you mean by nonstrict identity?
14:30:03 <Cale> That's a newtype wrapper, so the constructor isn't real :)
14:30:17 <c_wraith> For this particular case, I mean that >>= doesn't evaluate its first argument
14:30:25 <c_wraith> unlike with strict identity, where it does
14:30:41 <Cale> oh, sure
14:30:46 <Cale> I guess you could do that :)
14:31:03 <c_wraith> the only difference is that strict identity is data Identity a = Identity a :)
14:31:20 <hpc> c_wraith: Identity !a?
14:31:22 <c_wraith> Subtle how changing from newtype to data *adds* strictness
14:31:29 <hpc> oh, nvm
14:31:31 <c_wraith> hpc: if you want - not necessary for this case
14:31:38 <hpc> yeah, i see what you did there
14:31:52 <Cale> Yeah, pattern matching on a data constructor will do evaluation
14:32:03 <Cale> while pattern matching a newtype is irrefutable and so doesn't evaluate
14:32:13 <anachron> c_wraith: thanks
14:32:43 <jfischoff> Cale: "irrefutable" mean in that context?
14:33:08 <jfischoff> Cale: is that related to the ~ symbol?
14:33:11 <Cale> jfischoff: yes
14:33:45 <jfischoff> Cale: Is there something I should read to get a better understanding?
14:33:46 <Cale> ~ makes pattern matching happen lazily
14:34:11 <Cale> (and fail hard if the pattern didn't actually match once you need the value of a variable that was matched)
14:34:31 <Cale> > case [1,2,3] of ~[] -> "hello"
14:34:32 <lambdabot>   "hello"
14:34:42 <Cale> > case [] of ~(x:xs) -> "hello"
14:34:43 <lambdabot>   "hello"
14:34:47 <Cale> > case [] of ~(x:xs) -> x
14:34:48 <xplat> one thing i don't get about ghc-mod
14:34:48 <lambdabot>   *Exception: <interactive>:(3,0)-(4,21): Irrefutable pattern failed for patt...
14:34:55 <Cale> > case [] of ~(x:xs) -> "hello" ++ x
14:34:57 <lambdabot>   "hello*Exception: <interactive>:(3,0)-(4,21): Irrefutable pattern failed fo...
14:35:09 <xplat> who are these people who can type Meta-Tab into emacs and have emacs actually receive it?
14:35:36 <ocharles> i can
14:35:46 <dmwit> xplat: xmonad users
14:35:47 <jfischoff> Cale: Weird. What if there were too options in the first case. Would it still pick the first?
14:35:51 <EvanR> is there a library which takes care of sending values over a socket and getting them back one by one
14:35:56 <ocharles> i am indeed, an xmonad user
14:35:59 <EvanR> so i dont have to write a parser and protocol etc
14:36:02 <Cale> yes...
14:36:11 <Cale> > case [1,2,3] of ~[] -> "hello"; (x:xs) -> "goodbye"
14:36:12 <lambdabot>   "hello"
14:36:17 <dmwit> EvanR: binary?
14:36:21 <dmwit> ?hackage binary
14:36:22 <lambdabot> http://hackage.haskell.org/package/binary
14:36:25 <Cale> A pattern ~pat will always match instantly without checking
14:36:26 <EvanR> ok
14:36:33 <dmwit> ?hackage cereal
14:36:34 <lambdabot> http://hackage.haskell.org/package/cereal
14:36:51 <jfischoff> Cale: what is the main use case? It seems dangerous
14:36:57 <juliohm> lesshaste, :-)
14:37:14 <xplat> jfischoff: it's handy for mutual recursion
14:37:23 <Cale> Well, every pattern binding in a let or at the top level secretly has ~ stuck on the front of it
14:37:24 <xplat> and other recursions
14:37:47 <Cale> so when you write
14:38:15 <Cale> > let (evens, odds) = (0 : map (+1) odds, map (+1) evens)
14:38:16 <lambdabot>   not an expression: `let (evens, odds) = (0 : map (+1) odds, map (+1) evens)'
14:38:24 <Cale> > let (evens, odds) = (0 : map (+1) odds, map (+1) evens) in (take 10 evens, take 10 odds)
14:38:25 <lambdabot>   ([0,2,4,6,8,10,12,14,16,18],[1,3,5,7,9,11,13,15,17,19])
14:38:46 <Cale> That's really ~(evens, odds) = ...
14:38:51 <hiptobecubic> Cale, "samples = R.toUnboxed . runIdentity $ do R.computeUnboxedP $ R.map f seeds"
14:39:04 <hiptobecubic> it compiles but it seems so.... stupid
14:39:53 <jfischoff> Cale: Okay I can follow that. I'm not sure how it helps with recursion though. Is that because you might not want to evaluate the intermediate structures you need to?
14:39:57 <xplat> so what is a suggested alternate binding for the Meta-Tab thing if you don't use xmonad?
14:40:06 <EvanR> ok so binary lets you encode and decode stuff, but how to stream values
14:40:21 <EvanR> like how will the decoder know where to stop
14:40:40 <Cale> oh, I guess this example kinda sucks...
14:40:46 <Cale> let me find a better one
14:40:47 <parcs`> EvanR: once it has fully constructed a value
14:40:49 <xplat> EvanR: actually i would have thought protobufs were better for your use ...
14:41:02 <xplat> but maybe not
14:41:29 <EvanR> decode and decodeFile operate on a whole single bytestring or file
14:41:32 <EvanR> not a stream
14:41:36 <bitonic> jfischoff: that helps in the case that you have `foo x y ~(z, k) = if ... condition not dependent on z or y ... then <something not dependent on z or y> else <recurse using z and y>'
14:41:39 <Cale> jfischoff: It's really rare to actually need ~ in a pattern match, but when you need it, it's fairly convenient
14:42:10 <bitonic> jfischoff: in this case if the condition is true you won't evaluate the tuple constructor, thus making the function more lazy
14:42:24 <Cale> It basically just helps you avoid using functions like fst, snd, head, tail, etc.
14:42:28 <bitonic> @src scanr
14:42:28 <lambdabot> scanr _ q0 []     =  [q0]
14:42:28 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
14:42:28 <lambdabot>     where qs@(q:_) = scanr f q0 xs
14:42:32 <Cale> (though it's equally unsafe)
14:42:35 <EvanR> like the receiver needs to do a IO action for each event it gets on the socket
14:42:36 <bitonic> no, not this wait
14:42:54 <EvanR> as soon as it arrives totally, and maybe do error handling for malformed bytes
14:43:02 <EvanR> guess i need a parser
14:43:08 <bitonic> there was a Prelude function that is nicely defined with ~, mhm...
14:43:19 <parcs`> EvanR: no you don't, just use cereal :)
14:43:23 <EvanR> oh
14:43:25 <parcs`> it has a runGetPartial function
14:43:26 * EvanR checks cereal
14:44:08 <parcs`> i would use cereal combined with an incremental IO library to do what you want
14:45:52 <Cale> > let next = (+1); process = (*2); client x (r:rs) = x : client (next r) rs; server (r:rs) = process r : server rs; requests = client 0 responses; responses = server requests in responses
14:45:56 <lambdabot>   mueval-core: Time limit exceeded
14:46:05 <Cale> > let next = (+1); process = (*2); client x ~(r:rs) = x : client (next r) rs; server (r:rs) = process r : server rs; requests = client 0 responses; responses = server requests in responses
14:46:06 <lambdabot>   [0,2,6,14,30,62,126,254,510,1022,2046,4094,8190,16382,32766,65534,131070,26...
14:46:27 <t7> what is this ~ ?
14:46:32 <t7> :type (~)
14:46:43 <bitonic> @src partition
14:46:43 <parcs`> type equality constraint
14:46:44 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
14:46:44 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
14:46:44 <lambdabot>                               | otherwise = (ts, x:fs)
14:46:47 <bitonic> jfischoff: ^^^
14:46:54 <parcs`> or a lazy pattern binding
14:46:55 <Cale> When pat is any pattern, then ~pat is a pattern which matches immediately without checking that the pattern actually matches the data
14:46:58 <parcs`> or a tilde
14:47:30 <Cale> and only checks that the pattern matches (and fails if it doesn't) once you use one of the variables bound by the pattern
14:47:31 <t7> > let f ~(x,y) = x in f 123
14:47:32 <lambdabot>   123
14:47:42 <t7> yuck
14:47:45 <jfischoff> thanks guys. I will try to play with it.
14:47:49 <Cale> haha
14:47:51 <parcs`> t7: hehe
14:47:52 <Cale> that's cute
14:47:56 <Cale> 123 = (123,123) there
14:48:00 <parcs`> > let f ~(x,y) = x in True
14:48:00 <lambdabot>   True
14:48:02 <parcs`> > let f ~(x,y) = x in f True
14:48:03 <lambdabot>   Couldn't match expected type `(t, t1)'
14:48:03 <lambdabot>         against inferred type `GHC.B...
14:48:07 <Cale> because there's a Num instance for pairs
14:49:05 <bitonic> Cale: what the hell? why does that work?
14:49:11 <bitonic> what t7 posted
14:49:24 <EvanR> > (2,2) + (2,2)
14:49:25 <lambdabot>   (4,4)
14:49:28 <EvanR> > (2,2) * (2,2)
14:49:29 <lambdabot>   (4,4)
14:49:41 <EvanR> > (2,2) * 2
14:49:42 <lambdabot>   (4,4)
14:49:50 <bitonic> > (1, 2) + (3, 4)
14:49:51 <lambdabot>   (4,6)
14:50:05 <t7> > 2 * (1,2)
14:50:06 <lambdabot>   (2,4)
14:50:28 <parcs`> > 2 :: (Int, Int)
14:50:29 <bitonic> > 123 :: (Int, Int)
14:50:29 <lambdabot>   (2,2)
14:50:30 <lambdabot>   (123,123)
14:50:33 <parcs`> ;0
14:50:40 <bitonic> > 123 :: (Int, Double)
14:50:41 <lambdabot>   (123,123.0)
14:51:00 <bitonic> > 123 :: (Int, (Double, Rational))
14:51:01 <lambdabot>   (123,(123.0,123 % 1))
14:51:03 <bitonic> yeeee
14:51:11 <bitonic> Cale: was this really necessary :P?
14:51:48 <EvanR> > 123 (Int, (Double, (Rational, (Complex Float, Word))))
14:51:49 <lambdabot>   Not in scope: data constructor `Int'Not in scope: data constructor `Double'...
14:51:52 <EvanR> > 123 :: (Int, (Double, (Rational, (Complex Float, Word))))
14:51:53 <lambdabot>   (123,(123.0,(123 % 1,(123.0 :+ 0.0,123))))
14:52:14 <allbery_b> Num has enough defaulting magic attached to it that I am not sure this kind of thing is a good idea
14:52:21 <parcs`> > 2 :: (Bool -> (Int, Int -> Int), Double)
14:52:21 <lambdabot>   (*Exception: showsPrec: No overloading for function
14:52:22 <EvanR> hehe
14:52:31 <EvanR> implementing haskell must be worse than c++
14:52:44 <allbery_b> am imagining some weird type inference that would let ghc force random garbage to typecheck
14:52:53 <t7> EvanR: at least its easy to parse
14:53:34 <parcs`> too much ad hoc polymorphism will turn haskell into php
14:54:47 <hpc> parcs`: oh, that reminds me
14:54:59 * hpc is writing "php-haskell-prelude"
14:55:03 <hpc> "php" for short
14:55:14 <bitonic> recursive acronym ftw
14:55:25 <t7> backronym*
14:55:28 <EvanR> double recursion
14:55:30 <bitonic> yeah, that
14:55:34 <parcs`> t7: the ghc parser and lexer combined is actually like 4.5k loc
14:56:27 <bitonic> parcs`: that's probably nothing compared to a C++11 parser
14:56:42 <hpc> ...wat
14:56:56 <hpc> cabal-installing a single module that doesn't import Prelude
14:56:59 <hpc> it still wants base
14:57:03 <frontendloader> does c++11 have a repl now?
14:57:23 <bitonic> frontendloader: I don't think the C++ standard dictates a REPL, no.
14:57:30 <zaltekk> i think the gcc tests alone are over 700k loc
14:57:58 <jfischoff> frontendloader: there have been c interpreters for awhile, I think c++ also
14:58:14 <parcs`> ##c++ has a cool c++ bot
14:58:16 <allbery_b> base contains more than the prelude.  consider that unl;ess you include some really interesting pragmas (or avoid doing nearly everything) the compiler generally needs a fromIntegral and maybe fromRational around
14:58:18 <bitonic> I wouldn't be surprised to find the cleanest parser in clang
14:58:22 <bitonic> parcs`: written in haskell! geordi
14:58:26 <frontendloader> I know I've seen one before, I was just curious if something like that made it into the 11 standard
14:58:27 <hpc> allbery_b: ah
14:58:37 <parcs`> bitonic: oh it is? cool
14:58:48 <hpc> forgot about those
14:59:00 <bitonic> parcs`: http://weegen.home.xs4all.nl/eelis/geordi/
14:59:04 <bitonic> it's a very restricted C++
14:59:42 <allbery_b> do notation requires (>>=) etc.  haskell-the-language has a lot of hidden dependencies on the base library providing various things
15:06:48 <t7> do notation is translated before type checking... i thought...
15:08:06 <c_wraith> t7: yes, it is.
15:08:17 <c_wraith> > do 5 :: Int
15:08:17 <lambdabot>   5
15:09:09 <t7> the last statement in a do must be a blah
15:09:36 <Peaker> t7, that's just a superficial syntax rule... No "<-" in last do stmt
15:09:44 <IboS> hi
15:09:45 <quintessence> I thought GHC typechecked before desugaring to give better error messages?
15:10:06 <scopedTV> hi IboS did you write your letter yet?
15:10:16 <Sakako> > do 5 :: Float
15:10:17 <lambdabot>   5.0
15:10:33 <hpc> in theory, it could desugar to typecheck, then get an error location and "re-sugar" for the error message
15:16:04 <jfischoff> whats extension so you can pattern match and get all the record fields i.e. Thing {..} =  ..?
15:16:34 <c_wraith> RecordWildCards, I think
15:16:45 <jfischoff> sounds right
15:35:25 <bitonic> hpc: you can't typecheck type classes before desugaring to core
15:35:34 <bitonic> and you need to do the inference before
15:35:53 <hpc> oh
15:35:57 <bitonic> and in Haskell inference = type checking, so... you have to do it before desugaring
15:36:18 <bitonic> well the inference and the type checking are done together
15:36:32 * hpc has a confuse
15:37:19 <bitonic> hpc: wait: what desugaring are we talking about? I assumed to Core
15:37:30 <hpc> bitonic: do-notation and the like
15:37:44 <bitonic> hpc: ooops, sorry. assuming too much again. my bad.
15:37:46 <hpc> Core is a compilation step i thought
15:37:52 <hpc> not a "desugaring"
15:37:52 <bitonic> quintessence: forget all I said.
15:38:16 <bitonic> hpc: I'd call it desugaring. the most compiley step is the denesting of patterns maybe
15:38:41 <bitonic> it's relatively straightforward
15:39:04 <bitonic> but sorry, I had completely misunderstood
15:39:56 <hpc> np
15:40:17 * hpc has made the "too lazy to scroll up" mistake before ;)
15:44:09 <Domain4sale>  NLLL.com domain is for sale http://www.ebay.com/itm/330722589905
15:51:35 <QinGW> hi
15:57:40 * hpc is tempted to register ⊥.net
15:58:19 <adimit> bottom.net is parkedе
15:58:23 <adimit> *parked
15:58:35 <Hacklab> Is it possible to start a plain GHCi session within Eclipse?
16:00:02 <hpc> in eclipse, everything is possible
16:00:17 <hpc> (except performance)
16:01:05 --- mode: hitchcock.freenode.net set +o ChanServ
16:01:46 --- mode: hitchcock.freenode.net set +o Igloo
16:01:50 <Hacklab> hpc: not worried about performance, I just want to start a plain vanilla GHCi session so that I don't get Prelude Main as my prompt.
16:02:30 <hpc> is your concern about the prompt, or about Main being loaded?
16:02:38 <hpc> :set prompt λ
16:03:01 <Hacklab> hpc: no my concern is Main getting loaded
16:03:04 <hpc> ah
16:03:09 <hpc> hmm
16:03:16 <hpc> you're using eclipsefp?
16:03:25 <Hacklab> hpc: yeah.
16:04:09 <Hacklab> hpc: I just want to start a session without  a link to any project.
16:04:54 <hpc> Hacklab: aha, this should work even with vanilla eclipse
16:05:11 <hpc> Run -> External Tools -> configuration
16:05:12 <hpc> or whatever
16:05:26 <hpc> then doubleclick "Program" on the LHS
16:05:30 <hpc> and set it up to run ghci
16:06:57 <hpc> then to run it, there's a button on the toolbar next to the green "run" circle
16:07:03 <hpc> that's the same circle with a toolbox beneath it
16:07:35 <copumpkin> :t Data.Foldable.foldMap
16:07:36 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
16:08:02 <Hacklab> hpc: that's great! As you can see I'm a complete newbie at this stuff.
16:09:33 <hpc> i rarely use eclipse, i just went through the menus and that looked like it could be it
16:09:41 <hpc> this trick works remarkably often ;)
16:12:31 <Hacklab> hpc: yep that worked! I learnt something about eclipse!
16:14:39 <acowley> Is there a zipper library I could learn to use in less time than it would take to work out a zipper interface for my data structure?
16:15:19 <hpc> @hoogle zipper
16:15:19 <lambdabot> package zipper
16:15:20 <lambdabot> package instant-zipper
16:15:20 <lambdabot> package ListZipper
16:16:06 <hpc> i have no idea what to make of zipper
16:16:22 <ben> pants, for example
16:16:43 <acowley> cut me some slacks, man
16:17:28 <acowley> hpc: yes there are several options on hackage, but some user comments would help me make my decision. Most of these packages don't include examples, so getting up and running will take some investment.
16:18:37 <jmcarthur> oftentimes (as in this case, i suspect) the more generic solution can be as difficult or more difficult to comprehend than the specialized case
16:19:49 <acowley> jmcarthur: yeah, that is my feeling, too
16:19:54 <jmcarthur> acowley: but check this out http://conal.net/blog/posts/another-angle-on-zippers
16:20:03 <jmcarthur> acowley: there is a corresponding library for it, and the explanation is pretty good
16:20:12 <jmcarthur> i think it's a two parter, but don't remember
16:20:58 <jmcarthur> ah, that is the second part
16:21:04 <jmcarthur> http://conal.net/blog/posts/differentiation-of-higher-order-types/
16:21:07 <jmcarthur> part 1 ^^
16:21:41 <jfischoff> I've used this with some success http://hackage.haskell.org/package/syz-0.2.0.0
16:38:51 <xil> hey everyone. So I'm trying to code A* and am struggling a bit. I know just fine how to code it in a procedural language and I know how to emulate that process in Haskell, but I feel like it's not the proper way to program in Haskell. Namely, I don't take advantage of laziness; I'm still figuring out how to write lazily.
16:43:01 <jfischoff> xil: I can't help you but maybe if you past it someone will be inspired. I also struggle to use laziness to my advantage
16:43:57 <xil> jfischoff: not a bad idea. I'll get started on that =]
16:51:41 <nyingen> @quote
16:52:39 <bitonic> @quote quote
16:52:52 <bitonic> > "is lambdabot down?"
16:53:16 <bitonic> Cale: ^^^ (you probably already know)
16:53:23 <nyingen> @where lambdabot
16:53:28 <Cale> nope, I didn't notice
16:53:30 <Cale> thanks
16:54:17 <Cale> I think it often manages to come back on its own, but it takes a very long time to realise that it's been disconnected from the network.
16:55:45 <byorgey> is there a way to decide whether one is connected or not, other than "I haven't heard anything for a long time"?
16:56:06 <bitonic> byorgey: IRC has a PING command
16:56:11 <byorgey> ah
16:56:11 <bitonic> that the server sends every tot seconds
16:57:03 <acowley> byorgey: I always assumed that's why Internet trolls troll.
16:57:23 <shachaf> bitonic: The client can also send it to the server to check.
16:57:45 <bitonic> shachaf: yeah that's the use case I was referring to
16:58:39 <byorgey> acowley: "I'm lonely and unsure whether I'm still connected to {the Internet,other human beings}, so let's see if I can make some people mad?"
17:00:18 <acowley> byorgey: Exactly. I fully expect lambdabot to start periodically trolling #haskell in its next version. <lambdabot> How do I get a String out of IO? This is a ridiculous language, and your types are silly!
17:00:33 <otters> getting a String out of IO is easy
17:00:51 <otters> with a little help from System.IO.Unsafe
17:01:00 <byorgey> but types really ARE silly?
17:01:01 <mauke> const "hi"
17:01:17 <proq> byorgey: yes.  you can privmsg a bot
17:05:48 <dangsos> shapr you here?
17:06:41 <dangsos> guess not ><  anyone here familiar with the c++ sort() function?
17:07:01 <dangsos> cant figure how to sort structs inside an array by one of their string data members
17:07:53 <acowley> Just newtype up the Ord instance you want, then write a Haskell -> C++ compiler.
17:08:21 <dangsos> acowley that should only take a few minutes right?
17:08:30 <dangsos> :)
17:08:49 <acowley> dangsos: I think you supply a class that has a method for comparing the relevant types.
17:09:16 <acowley> bbiab
17:09:53 <dangsos> acowley:  hmm ill trying writing a member function that compares the string, but I'm not 100% how to use it after that...ill play with it
17:10:43 <nyingen> acowley: lambdabot already has @troll_haskell but it's called @protontorpedo
17:10:52 <dangsos> i mean i know how to compare strings, and I know how to compare strings inside an array of structs....just not sure how to do it with sort()
17:16:43 <bitonic> dangsos: erm this is a channel to talk about Haskell
17:17:10 <bitonic> dangsos: you can try ##c++ or #haskell-blah
17:19:17 <dangsos> bitonic: i know, but im a friend of shapr and was hoping to find him here (he was telling me about coding his c++ project and getting more help than in #c++)
17:19:56 <dangsos> bitonic: and c++ usually just says 'google it' and 'you didn't google har enough' lol
17:21:05 <nyingen> you can always send private messages
17:21:41 <shachaf> dangsos: shapr wasn't asking C++ questions in the actual #haskell channel.
17:23:00 <dangsos> shachaf: according to shapr he was asking c++ in haskell :P (of course he may have meant he was asking in a message)
17:28:28 <bitonic> dangsos: it was probably in #haskell-blah
17:28:48 <bitonic> he was complaining about it (C++) earlier
17:30:03 <dangsos> bitonic: this was last night, but you may be right...he's always trying to get me to come hangout here but he's nvr here when I am >,<
17:30:08 <mjrosenb> I can't declare a typeclass over something that doesn't have kind *, right?
17:30:20 <shachaf> mjrosenb: Why not?
17:30:37 <shachaf> See e.g. Monad
17:30:50 <mjrosenb> @src Monad
17:30:51 <lambdabot> class  Monad m  where
17:30:51 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
17:30:51 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
17:30:51 <lambdabot>     return      :: a -> m a
17:30:51 <lambdabot>     fail        :: String -> m a
17:31:04 <mjrosenb> shachaf: I'm thinking something like class Foo (Bar a) where ...
17:31:20 <bitonic> mjrosenb: why would you include the Bar there?
17:31:39 <bitonic> I mean what does that mean? anyways, no.
17:31:43 <bitonic> you can't do that.
17:31:43 <shachaf> m's kind is * -> * in this case.
17:31:50 <shachaf> What behavior are you after?
17:32:40 <mjrosenb> I'm trying to define (Arraylike (C a)) => (!!!) :: C a -> int -> Maybe a
17:33:19 <shachaf> Why can't the class just be "class ArrayLike t"?
17:33:22 <bitonic> mjrosenb: can't you just include the C in the type sig of (!!!)?
17:33:23 <mjrosenb> s/int/Int/
17:33:58 <mjrosenb> bitonic: I'm trying to have C be the variable
17:34:08 <mjrosenb> which doesn't make sense since C is a capital
17:34:49 <ClaudiusMaximus> class ArrayLike t where (!!!) :: t a -> Int -> Maybe a -- i've done things similar to this
17:34:50 <mjrosenb> bitonic: how would I include C in the sig of (!!!) without specifing what C is?
17:35:09 <shachaf> mjrosenb: Then use a lower-case c instead?
17:35:17 <bitonic> mjrosenb: well then why not `ArrayLike c a ...'?
17:35:25 <bitonic> uppercase C is not a variable in Haskell
17:35:58 <mjrosenb> right, I kept trying to add an argument to c, which does not parse
17:36:00 <mjrosenb> thanks!
17:54:44 * hackagebot blaze-svg 0.3.3.0 - SVG combinator library  http://hackage.haskell.org/package/blaze-svg-0.3.3.0 (DeepakJois)
17:55:21 <damowe> hi :)
17:55:36 <shachaf> @hi damowe
17:55:36 <lambdabot> No match for "damowe".
17:55:48 <damowe> xD
17:56:01 <damowe> can anyone help me with guarded recursion?
17:56:09 <shachaf> Who knows?
17:56:28 <shachaf> If you ask a question you might find out, though.
17:56:46 <shachaf> Unless your question is just whether someone can help you with it. In which case I guess you asked it, but I don't know the answer.
17:56:57 <damowe> I'm trying to solve euler problem 255
17:56:58 <damowe> :)
17:57:22 <damowe> I meant project euler problem #255
17:57:52 <damowe> seriously this is not a school problem, I'm just trying to learn Haskell :)
17:58:16 <shachaf> Solving "Project Euler" problems is probably a bad approach for learning Haskell. :-)
17:58:27 <damowe> haha
17:58:31 <damowe> who knows :)
17:59:08 <shachaf> Anyway, searching the Google for «euler problem 255» brings up your Twitter page.
17:59:13 <shachaf> Their actual website seems to be down.
17:59:20 <damowe> please, can you see my code (http://hpaste.org/67951), help to know why it seems to be leaking memory?
17:59:46 <damowe> yes, that's true, seems to be down :)
18:06:04 <ClaudiusMaximus> > (7 * 10) ** (fromIntegral (length (show (maxBound :: Int))))
18:06:05 <lambdabot>   1.1398895185373143e35
18:08:50 <dmwit_> I don't see any guarded recursion here.
18:10:23 <acowley> It's OG guarded recursion: guards and recursion.
18:12:07 <dmwit> Anyway, perhaps you would enjoy using b `seq` heronRec b c r in applyHeronRec.
18:12:15 <dmwit> Not 100% sure that's the problem, but it looks a likely one.
18:12:34 <dmwit> Can I ask why you're working so hard to make things look tail-recursive, though?
18:12:47 <dmwit> That's generally not as good a strategy in Haskell as it is in other functional language.s
18:13:30 <ClaudiusMaximus> i think they left already
18:13:44 <dmwit> Oh, so they did.
18:28:14 <nyingen> @protontorpedo
18:28:15 <lambdabot> or does it become a mishmash of code?
18:28:19 <nyingen> @protontorpedo
18:28:20 <lambdabot> is haskell more powerful than perl? or scheme?
18:33:51 <dmwit> ?faq Can Haskell do more than Perl or Scheme?
18:33:52 <lambdabot> The answer is: Yes! Haskell can do that.
18:36:48 <Mathnerd314> perl 6 was implemented in Haskell first, iirc
18:37:36 <nyingen> @protontorpedo
18:37:36 <lambdabot> is it fun to program in haskell?
18:38:56 <acowley> RebindableSyntax doesn't allow rebinding of []?
18:39:23 <eviltwin_b> I think what is now called rakudo came first but got stuck due to a hiatus in development of parrot, which led to pugs being written
18:40:21 <dmwit> acowley: Well, to be fair, constructors are a bit more special than if/then/else.
18:40:27 <dmwit> Since they can be used in patterns.
18:40:29 <Mathnerd314> acowley: you can rebind monad comprehensions
18:41:38 <acowley> dmwit: True. I'm not complaining too much, but it does seem a tad unfortunate given the awesomesauceness of RebindableSyntax for dealing with do notation.
18:42:10 <acowley> Mathnerd314: I wanted the whole enchilada! [] for empty lists, and an mixfix type constructor!
18:42:25 <Mathnerd314> [] = mempty
18:43:18 <Mathnerd314> I guess you could rebind it using that
18:44:22 <dmwit> > exp 1 - 2.718281828459045 :: CReal
18:44:23 <lambdabot>   0.0000000000000002353602874713526624977572
18:45:27 <leimy> > fix error
18:45:28 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
18:45:38 <leimy> Oops
18:45:51 <leimy> That made it super unhappy
18:47:41 <dmwit> fix error throws an exception. Which exception does it throw? Well, it throws a thunk which, when evaluated, throws an exception.
18:47:51 <dmwit> I find this very amusing.
18:49:29 <leimy> It's also kind of a funny thing to write.
18:49:49 <leimy> Because when my boss tells me to fix error I feel like I should just shut down too.
18:50:38 <MaskRay_> hardly find any article on monad-control but this http://www.yesodweb.com/blog/2011/08/monad-control
18:51:15 <romildo> I want to define a parser for natural numbers using Parsec. So I have written:
18:51:19 <romildo> pNum = fmap read (many1 (satisfy isDigit))
18:51:39 <romildo> But it fails with the error No instance for (Stream s0 m0 Char) arising from a use of `satisfy'
18:51:51 <romildo> Any clues?
18:54:35 <romildo> nonetheless, In ghci, the following works:
18:54:39 <romildo> parse (fmap read (many1 (satisfy isDigit))) "" "2342ab" :: Either ParseError Int
18:54:45 <romildo> Right 2342
19:00:25 <applicative> romildo: which Parsec module are you  importing?  Often you need some type signatures or NoMonomorphismRestriction to avoid these errors
19:01:08 <romildo> applicative: Text.Parsec (parsec-3.1.2)
19:01:47 <zolaric> help
19:03:52 <applicative> try the compatibility one Text.ParserCombinators.Parsec which has plain string parsers?
19:15:53 <mysticc_> romildo: I think you have to explicitly define types of each parser ..
19:32:47 <Plex-> from "learn you a haskell": findKey key = foldr (\(k,v) acc -> if key == k then Just v else acc) Nothing <-- would this not cause the entire list to be evaulated when unnecessary? I realize it is an example (in the book), but then the book goes on to suggest using foldr for things like that
19:32:55 <Plex-> or is there some sort of lazy-magic that I cannot comprehend yet
19:34:00 <parcs`> the latter ;)
19:34:05 <c_wraith> Plex-: the magic is in the second argument to the function passed in
19:34:20 <c_wraith> Plex-: the second argument is "the rest of the computation"
19:34:32 <c_wraith> Plex-: if the second argument isn't used, the rest of the computation is never performed
19:34:50 <monochrom> it evaluates the whole list if key is not found
19:36:05 <Plex-> well, I don't quite get it yet, but if it doesn't evaluate the list after the first match, then that is brilliant
19:36:40 <ski> you should think of `acc' as `foldr (...) Nothing kvs', where `kvs' is the "rest of the list"
19:37:02 <ski> note that `acc' is only used in the function argument in the `else' branch
19:37:16 <ski> meaning that it will only be computed if that branch is chosen
19:38:34 <monochrom> expand your foldr back into explicit recursion. findKey key ((k,v):xs) = if key==k then Just v else who_cares
19:39:12 <monochrom> so, if key==k happens, you get Just v. what about "the rest of the list", the "recursive call"? oh who cares
19:39:39 <ski> (yeah, really "the result of the recursive call")
19:40:18 <Plex-> appreciate it
19:40:40 <ski> Plex- : you might have fun pondering the `partition' function
19:40:45 <ski> @src partition
19:40:46 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
19:40:46 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
19:40:46 <lambdabot>                               | otherwise = (ts, x:fs)
19:40:58 <ski> specifically, why's there a `~' in there ?
19:41:16 <ski> (and what would happen if it wasn't there)
19:41:23 <monochrom> that is way more advanced :)
19:41:41 <monochrom> see my http://www.vex.net/~trebla/haskell/lazy.xhtml for lazy evaluation
19:41:43 <ski> yeah, you might want to save this one for later :)
19:43:02 <Plex-> yea, that one is a bit intimidating right now :P
19:43:05 <|Steve|> Is there a way to get useful runtime error messages from ghci?
19:43:23 <|Steve|> "*** Exception: Error in array index" is pretty useless.
19:46:23 <|Steve|> I actually worked out which array it was, but I'm still curious.
19:47:18 <byorgey> |Steve|: ghci has little to do with it.  It's just that the array indexing code happens to contain a call to 'error "Error in array index"' or something like that, which I agree is pretty useless.
19:47:52 <byorgey> the only way to get more information would be to include more information in the error message in the first place.
19:48:19 <|Steve|> byorgey: So ghci cannot figure out where in the code its happening even since it is interpreting the code.
19:48:21 <|Steve|> ?
19:49:24 <jfischoff> byorgey: is there anyway to use the new stack trace functions to get a stack trace of an error (you don't have the source for)?
19:53:06 <ymasory> is 'putStrLn("foo")' the same as '_ <- putStrLn("foo")' inside do notation? meaning does haskell automatically bind the IO monad even though there's no "receiver"?
19:54:48 <jfischoff> I have a question about sharing. If I have data Tree a = Leaf | Node a [Tree], but I have "tied the knot" so I instead of a tree I've made a dag. Is there anyway that functions Tree a -> b, could tell the difference?
19:55:15 <c_wraith> ymasory: if there's no bind, the desugaring uses ">>" instead of ">>=". However, that should be semantically equivalent
19:55:54 <jmcarthur> jfischoff: not without ghc hackery
19:56:12 <jfischoff> jmcarthur:awesome. Thanks!
19:56:17 <jmcarthur> jfischoff: and for the record, i don't think "tie the knot" is a typical term for normal sharing like this
19:56:24 <jmcarthur> normally it's for recursion, i think
19:56:32 <jmcarthur> *recursive data structures
19:56:35 <jfischoff> yep
19:56:37 <ymasory> c_wraith: thank you
19:57:05 <jfischoff> jmcarthur: I didn't know what to call it. I guess "used sharing" ?
20:00:53 <jmcarthur> that's basically right, yeah
20:01:36 <jmcarthur> jfischoff: i would have said "some subtrees might be shared"
20:01:52 <ski> jmcarthur : you'd need some kind of indirection with identity (hash-consing would be one option)
20:02:06 <jfischoff> jmcarthur: that's even better :)
20:02:13 <ski> er, jfischoff ^
20:03:34 <jfischoff> ski: are you saying that Hashable like instances are using the raw pointer address for hashing?
20:04:14 <ski> i'm not sure what `Hashable' does
20:04:34 <ski> (but no, i wasn't saying anything about using raw pointers)
20:05:19 <ski> rather, i was suggesting that one could use an index into a datastructure (e.g. an `Int') as a *substitute* for a memory address
20:06:59 <rudyl313> how do people typically do randomization in an application that needs to do a lot of randomzing? I'm thinking about having each function take a StdGen and having the return value be a tuple of the desired return value and the updated StdGen... is there are better way to do it? (maybe fetch the StdGen manually in each function .. requiring a IO return value)
20:07:16 <ski>   newtype GenTree ref a = GT (ref (GenTreeCell ref a))
20:07:22 <ski>   data GenTreeCell ref a = Tip
20:07:23 <ski>                          = Node a [GenTree ref a]
20:07:42 <ski> you can now consider `GenTree Identity', which is basically the same as your `Tree'
20:08:00 <ski> you can also consider `GenTree IORef', where each node is mutable
20:08:50 <ski> and you can consider `GenTree Index' where `data Index a = I Int', to be used as an index in some data structure which contains the actual values
20:08:56 <ski> jfischoff ^
20:09:23 <ski> @where DecoratingStructures
20:09:24 <lambdabot> <http://web.archive.org/web/20051126143527/http://haskell.org/hawiki/DecoratingStructures>
20:09:24 <ski> @where IndirectComposite
20:09:24 <lambdabot> <http://web.archive.org/web/20051126141834/http://haskell.org/hawiki/IndirectComposite>
20:09:31 <ski> are also a bit relevant
20:09:36 <gentleben> can you compose a view with Data.Label such that one of the lenses in the middle is a maybe?
20:10:59 <ski> rudyl313 : you can hide `StdGen -> (a,StdGen)' as `State StdGen a'
20:11:07 <ski> rudyl313 : you can also consider using
20:11:10 <ski> @type split
20:11:11 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
20:11:18 <ninegrid> http://texas.irgeeks.us/~dan/vimrc.png
20:11:28 <ninegrid> almost completely migrated to vim
20:11:34 <ski> (from ?)
20:11:39 <rudyl313> ski: thanks for the tips!
20:11:53 <ninegrid> wrong chan
20:12:01 <ninegrid> ski: you threw me off
20:12:28 <ski> (aka `ECHAN')
20:12:31 <ski> ninegrid : heh
20:12:49 <ninegrid> this is embarassing :/
20:13:19 <ski> it happens to all of us now and then
20:13:35 <tgeeky_> ninegrid: also, for me, the link is broken
20:14:08 <ion> ditto
20:14:38 <tgeeky_> ninegrid: I'm not sure if that should add or subtract from your embarassment.
20:15:12 <ninegrid> tgeeky_: it is multiplicative
20:15:18 <ninegrid> im moving to another town
20:15:31 <ski> tgeeky_,ion : s/ir/irc/
20:16:15 <ninegrid> i have to patch a font
20:16:41 <ion> How many DPI does your display have? The font looks quite small to me. Mine is something like 96 DPI.
20:17:12 <ninegrid> ion: this is for my eee
20:17:23 <ninegrid> eee 901, it is terribly small
20:19:30 <tgeeky_> ninegrid: that's a pretty damn sophisticated and rather nice setup. hopefully I can steal it soon.
20:20:53 <ninegrid> i grew up on vi, then when for some reason i got sucked into the visualstudio hype in 2005
20:21:43 <ninegrid> but now i am going to move back to it
20:21:56 <ninegrid> starting with my eee, then my other home machines, and then work
20:28:57 <Veinor> philosophical question: do i write filesystem monitoring code that polls every 10 seconds, thus working cross-platform but being IO-intensive, or do i use inotify, which is linux-specific but efficient
20:30:36 <Veinor> well if i go the latter i can later add support for kqueue, which gets me BSDs, and realistically since this is a web app i only care about linux and bsd
20:46:03 <gwern> Veinor: isn't there a library on ackage abstracting over the OS-pushes and a generic poll fallback?
20:47:46 <Veinor> not as far as i can tell
20:48:03 <gwern> oh. opportunity, then!
20:48:32 <c_wraith> Veinor: one of the GSoC projects includes this as a component
20:48:56 <Veinor> oh, nice
20:52:52 <sabrehagen> If I have (\a -> f $ \b -> a+b) and then write (\a -> f $ \b -> a+b) 5, how does this reduce to f $ \b -> 5+b?
20:53:12 * parcs` just concocted an interface for computing serializable differences between values of arbitrary types using ghc generics
20:54:12 <jfischoff>   parcs`: do you need any help?
20:55:26 <hpaste_> parcs pasted “stuff” at http://hpaste.org/67952
20:56:57 <ski> sabrehagen : by beta-reduction
20:57:35 <jfischoff> parks`: yes oh yes. Okay let me derail you. What about a type safe diff?
20:57:50 <jfischoff> s /parks`/parcs`
20:58:36 <jfischoff> http://hackage.haskell.org/package/gdiff
20:59:11 <parcs`> oo, quite similar
20:59:32 <parcs`> holy crap that's complex though
21:00:01 <jfischoff> parks`: but you don't have to deserialize the scene graph from the patched file
21:00:25 <jfischoff> parcs`: its faster
21:00:40 <Veinor> oh it looks like inotify doesn't recurse :(
21:01:20 <Veinor> i mean it makes a certain amount of sense
21:01:58 <jfischoff> jfischoff:parks` I wrote a terrible gdiff-th package. But I do know how to write the instances pretty mechanically. Honestly if you --dumpsplices its almost there.
21:02:11 <Cale> sabrehagen: that's just how lambda works?
21:02:30 <parcs`> jfischoff: i don't understand what you mean by "having to deserialize the scene graph from the patched file"
21:02:35 <Cale> sabrehagen: Or are you asking in terms of some particular machine implementation of Haskell?
21:03:17 <lispy> hello
21:03:36 <jfischoff> parks`: its a binary diff right?
21:04:03 <lispy> did someone say scenegraph?
21:04:41 <jfischoff> I love saying scenegraph
21:06:38 <Cale> sabrehagen: Whenever you have (\x -> e) f where e and f are expressions, then the beta rule says that this is equivalent to e[f/x]　where this denotes the expression e where every free occurrence of x has been replaced by f.
21:07:31 <lispy> I always find the order of [f/x] counter intuitive
21:07:46 <Cale> It makes more sense if you think of multiplication and division :)
21:08:24 <Cale> It's meant to look a bit like we're multiplying by f and dividing out x
21:09:05 <lispy> hmm
21:09:28 <Cale> (but don't read too much into that, it's just notation)
21:09:32 <lispy> Cale: where did you learn that mnemonic?
21:09:57 <parcs`> jfischoff: it checks equality of each field and if a field is not equal then it just stores the latest version in the delta value
21:10:26 <kulakowski> lispy: I've also heard the same trick, but no idea where
21:10:35 <Cale> I seem to recall using the same notation for substitution at some point in an algebraic geometry course
21:10:40 <jfischoff> parks` Oh. That sounds very similar
21:11:50 <parcs`> jfischoff: yeah.. it seems that gdiff can compute diffs between values of different types?!
21:12:35 <jfischoff> parcs`: Within a universe that is fixed.
21:13:08 <lispy> 
21:13:54 <Cale> lol, I think my mom forgot that we'd had a power outage when she set up the coffee to brew automatically
21:13:58 <Cale> midnight coffee
21:14:11 <Cale> goot default timer setting
21:15:53 <nyingen> in the old days, your VCR would have recorded Hard Copy or whatever comes on at midnigh
21:16:58 <nyingen> what is the value () called?
21:17:31 <Cale> I call it the empty tuple
21:17:43 <Cale> The type () is called the unit type
21:17:46 <blackdog> nyingen: you sometimes hear "unit" too
21:17:48 <Cale> sometimes
21:17:55 <Cale> So sometimes () is also called unit
21:18:35 <nyingen> A friend was asking me how it's different from
21:18:59 <nyingen> er, how it's different from _|_...clearly it's completely different, but I wasn't sure how to explain how
21:19:26 <nyingen> mostly because I'm actually not sure what () is, despite using it every day
21:19:34 <Cale> Well...   case undefined of () -> 5   will be undefined
21:19:43 <Cale> while   case () of () -> 5   will be 5
21:19:49 <nyingen> hm, interesting
21:19:50 <parcs`> how is true different from false? :)
21:20:18 <Cale> So the type () has two values, one terminating, and one nonterminating
21:20:44 <Cale> (in the semantics, where we identify failures using error/undefined and simply failing to terminate)
21:22:07 <Catnaroek> One question... How does the design of the "IO t" type interact with the existence of multiple platforms? How do I create IO values that are valid actions on specific platforms only?
21:22:09 <Cale> In the definedness ordering, _|_ < (), and every computable function from () to another type will preserve that ordering.
21:22:27 <Cale> well, in the sense that if x <= y, then f x <= f y
21:23:01 <Cale> and in general, x <= y means that y can be obtained from x by substituting occurrences of _|_ in the structure with other values
21:23:36 <Cale> Catnaroek: Usually IO actions are fairly cross platform, unless you start using libraries which are only available on one platform or another.
21:23:48 <lispy> Cale: FYI, I'm upgrading some packages on the lambdabot server. I don't expect to break anything, but I just figure I should mention it
21:23:51 <Cale> Catnaroek: There's no formal way in which we normally keep track of that
21:23:57 <Cale> lispy: okay :)
21:24:26 <Catnaroek> Cale: So the only way to implement platform-specific actions would be to implement them in an imperative language and use the FFI?
21:24:43 <Cale> Catnaroek: oh, you just want to know what platform you're running on?
21:24:56 <Catnaroek> Nope.
21:25:19 <Catnaroek> I just wondered what would happen if I run a Haskell program on platforms that, for example, don't have conventional file systems.
21:25:22 <Cale> file:///usr/local/share/doc/ghc/html/libraries/base-4.5.0.0/System-Info.html#v:os
21:26:02 <Cale> Well... if the FilePath strings can't be interpreted as filenames, they throw exceptions
21:26:13 <Cale> (all the actions which take FilePath arguments)
21:26:40 <Cale> So if you use very unix-specific paths in your Haskell program, it might not run correctly on Windows right away.
21:26:58 <Cale> But just using '/' as a path separator on Windows is okay
21:27:29 <Cale> There are a few libraries to help with that, notably one by Neil Mitchell...
21:27:42 <Cale> http://hackage.haskell.org/package/filepath
21:27:57 <Catnaroek> Oh.
21:28:05 <Cale> It abstracts out some of the differences in filepath construction/deconstruction on different OSes.
21:28:29 <Cale> But there's really only two cases in practice on all the machines where you can realistically run Haskell code right now
21:28:36 <Cale> (Windows, and everything else)
21:30:06 <ski> Catnaroek : also `maxBound :: Int'
21:30:19 <Catnaroek> Yep, I know about maxBound and minBound.
21:30:42 <Catnaroek> I was worried about IO specifically.
21:31:03 <Catnaroek> Kind of... does a different IO type have to be designed for every platform?
21:31:13 <Catnaroek> (Even if it exposes the same interface.)
21:31:50 <ski> i suppose that might make more sense if we could transfer `IO'-actions between processes (e.g. over network)
21:32:27 <Catnaroek> I haven't thought about that specifically, that yeah, that could be an example.
21:32:46 <Catnaroek> And it would be really nice to have.
21:33:05 <Catnaroek> (Although I guess insecure.)
21:33:36 <Veinor> ok, i think i can't use inotify for this
21:34:02 <Veinor> the reason being: inotify events trigger a reread of the list of posts on disk. which itself triggers more inotify events
21:34:42 <Saizan> Catnaroek: in practice GHC uses an uniform representation for IO everywhere, what changes are the available primitives
21:35:15 <Cale> It would be really really cool even if we could do things like serialise an IO action as a ByteString and write it to disk as an executable program, even in a platform-restricted way.
21:35:28 <Saizan> Catnaroek: and that's usually handled by CPP or simply providing some packages instead of others, i.e. on windows you won't get the unix package
21:35:37 <Cale> and then all we need is callCC for IO, and we'd have a way to save state in a Haskell program :)
21:37:16 <ski> Catnaroek : there's some attempts to provide more restricted versions of `IO', e.g. only supporting affine linear I/O (see e.g. <http://www.haskell.org/haskellwiki/Top_level_mutable_state#Proposal_2.28c.29:_Use_a_new_monad>) -- but this isn't for the same purpose
21:38:12 <ski> Cale : you can serialize closures in O'Caml, but only between processes running the same program, compiled by the same compiler version, for the same platform
21:39:09 <Saizan> ski: what happens when you happen to be closing over a Handle or a reference type?
21:39:24 <ski> (Cale : though `call-with-current-continuation' doesn't capture the mutable state (only the control state) of the program (or the executing thread))
21:39:44 <ski> Saizan : you get an exception saying that you can't marshall those, iirc
21:42:57 <Cale> ski: ah right, it wouldn't capture all the IORefs etc.
21:55:39 <ski> Saizan,Cale,Catnaroek : Joachim Durchholz' "FPL Marshalling survey, third edition" in 2003-11-25 at <http://groups.google.com/group/comp.lang.functional/msg/12ca9d4de6506201> might be interesting
21:55:49 <Catnaroek> kenne see
21:55:51 <Catnaroek> lemme*
22:01:46 <ymasory> is it possible to write a function with this signature? I can't figure it out: IO [a] -> (a -> IO b) -> IO [b]
22:02:50 <c_wraith> ymasory: yes, that's certainly possible.
22:03:07 <ymasory> c_wraith: what's the general idea? i'm lost in a maze of binds and maps
22:03:17 <ymasory> i can't figure out how to combine the inner and outer IO
22:04:07 <c_wraith> ymasory: hmm. it's be easiest to start by seeing what you have so far.
22:04:09 <c_wraith> @where hpaste
22:04:10 <lambdabot> http://hpaste.org/
22:04:22 <c_wraith> that's a good spot to put what you have so far
22:04:50 <ymasory> c_wraith: not in haskell :(
22:05:58 <c_wraith> ymasory: well, start with the tools you have. What are those tools?
22:08:03 <ymasory> c_wraith: well if I had an 'a -> b' function i could use two maps to do 'IO [a] -> IO [b]'
22:08:39 <ymasory> one map and i would need an `[a] -> [b]'
22:08:53 <c_wraith> well, ignoring the target return type...
22:08:58 <ymasory> which i'll write 'List a -> List b' because i'm not used to haskell
22:09:08 <c_wraith> What can you do with an IO [a] and an a -> IO b ?
22:09:33 <c_wraith> as in, what type can you come up with, with values of those types?
22:09:49 <ymasory> well a map would make IO List IO b which is no good
22:10:09 <c_wraith> ymasory: map alone is not sufficient for that.
22:11:04 <ymasory> really? IO[List[A]] and an A -> IO[B]  doesn't make a IO[List[IO[B]]] ?
22:11:18 <c_wraith> ymasory: it does, but it needs more than map
22:11:45 <ymasory> not sure what you mean, i feel like map and the A -> IO[B] function is all you need
22:11:52 <ski> no
22:11:56 <c_wraith> you can't pass IO [a] in the place of [a]
22:12:00 <ski> you also need `sequence'
22:12:01 <c_wraith> they are different
22:12:12 <ski> .. or you can write it all with manual recursion
22:12:15 <quintessence> ymasory: it's not, as you just pointed out -- you need sequence or mapM
22:12:23 <ski> (or `forM')
22:13:03 <copumpkin> huh?
22:13:35 <copumpkin> I think we're getting confused by ymasory's notation
22:13:44 <copumpkin> his last question looks like scala syntax
22:13:49 <ymasory> copumpkin: yeah
22:13:50 * ski isn't
22:13:59 <copumpkin> IO[List[A]] and an A -> IO[B]  doesn't make a IO[List[IO[B]]] ?
22:14:05 <copumpkin> fmap and map together should get that
22:14:12 <copumpkin> with no sequence
22:14:32 <ymasory> yeah i'm not familiar with the difference between the two. doesn't come up much in scala
22:15:52 <copumpkin> :t fmap (map (undefined :: a -> IO b)) :: IO [a] -> IO [IO b]
22:15:53 <lambdabot> forall a b. IO [a] -> IO [IO b]
22:16:13 <c_wraith> copumpkin: that wasn't his final goal, though
22:16:24 <copumpkin> oh, I just tuned in at the [01:10:42] <ymasory> really? IO[List[A]] and an A -> IO[B]  doesn't make a IO[List[IO[B]]] ?
22:16:52 <copumpkin> oh I see now
22:18:10 <ymasory> copumpkin:  my goal is to write IO [a] -> (a -> IO b) -> IO [b]
22:18:41 <copumpkin> in that case, yeah, you need more
22:19:52 * hackagebot splice 0.6 - Cross-platform Socket to Socket Data Splicing  http://hackage.haskell.org/package/splice-0.6 (CetinSert)
22:21:02 <ymasory> copumpkin: thanks
22:21:17 <copumpkin> np
22:35:00 <sabrehagen> Hi, if I have (\a -> f $ \b -> a+b), and write (\a -> f $ \b -> a+b) 5, how does it reduce to f $ \b -> 5+b?
22:36:43 <ski> <ski> sabrehagen : by beta-reduction
22:37:00 <sabrehagen> ski: could you explain the process please?
22:38:02 <ski> Cale also left you some comments, which you can see near the end of <http://tunes.org/~nef/logs/haskell/12.05.01>
22:38:16 <ski> sabrehagen : consider
22:38:31 <ski>   (\x -> ..x..x..x..) 5
22:38:54 <ski> and assume that those three `x's in `..x..x..x..' are all the (free) occurances of `x' in there
22:39:06 <ski> then this, by definition of beta-reduction, reduces to
22:39:09 <ski>   ..5..5..5..
22:39:16 <ski> e.g. if you define
22:39:33 <ski>   f = \x -> (x,\y -> x + y)
22:39:35 <ski> then
22:39:39 <ski>   f 5
22:39:51 <ski> simplifies to (by definition of `f')
22:39:58 <ski>   (\x -> (x,\y -> x + y)) 5
22:40:06 <ski> and then this reduces, by beta-reduction, to
22:40:14 <ski>   (5,\y -> 5 + y)
22:40:31 <sabrehagen> ski: let me process that...
22:40:34 <ski> you could alternatively think of it as reducing to
22:40:46 <ski>   let x = 5 in (x,\y -> x + y)
22:40:48 <sabrehagen> ski: sorry, keep going, and i'll read it all through and get back to you
22:41:32 <ski> in general, `(\x -> ..x..x..x..) (..argument here..)' would then reduce to `let x = ..argument here.. in ..x..x..x..'
22:42:08 <sabrehagen> ski: hmm, okay, what you say makes sense. let me see if i can appy that to the thing from before.
22:42:08 <ski> the advantage of this view is that it preserves sharing (which is what happens in a lazy implementation)
22:42:22 <ski> as an example, consider
22:42:29 <ski>   f = \x -> x + x
22:42:38 <ski> then consider the following reduction sequence
22:42:41 <sabrehagen> ski: okay
22:42:47 <ski>      f (2 * 3)
22:42:59 <ski>   =  (\x -> x + x) (2 * 3)
22:43:10 <ski>   =  (2 * 3) + (2 * 3)
22:43:14 <ski>   =  6 + (2 * 3)
22:43:17 <ski>   =  6 + 6
22:43:20 <ski>   =  12
22:43:54 <ski> most implementations here would actually only evaluate `2 * 3' once here (the first time, then the next time just reuses the result)
22:44:01 <ski> we could write this as
22:44:06 <ski>      f (2 * 3)
22:44:16 <ski>   =  let x = 2 * 3 in x + x
22:44:43 <sabrehagen> ski: okay
22:44:45 <ski>   =  let x = 6 in x + x  -- note that the multiplication is only done at this point because the first argument of `+' wants to evaluate `x'
22:45:03 <ski>   =  let x = 6 in 6 + x  -- accessing the computed value of `x'
22:45:10 <Cale> If you're the sort of person who likes that sort of thing, you can think of both of the x's in that let expression as pointers to the same value, which is 6
22:45:24 <ski>   =  let x = 6 in 6 + 6  -- accessing the cached value for the second `x', instead of recomputing it
22:45:46 <sabrehagen> ski: so why doesn't it cache the multiplication?
22:45:49 <ski>   =  6 + 6  -- garbage-collecting the `x', which is now not referenced anymore
22:45:53 <ski>   =  12
22:46:32 <ski> sabrehagen : typical implementations *do* cache the value of `x' (the argument of the function `\x -> x + x' in the specific application here)
22:47:07 <ski> (and the garbage-collecting step doesn't need to happen at this point, it can happen later as well)
22:47:19 <shinji_> hi there
22:47:24 <ski> hello shinji_
22:47:47 <sabrehagen> ski: alright, thanks :)
22:49:17 <ski> sabrehagen : monochrom's <http://www.vex.net/~trebla/haskell/lazy.xhtml> might also be useful
22:49:53 <ski> sabrehagen : btw, note that usually, we'd write the definition of `f' like `f x = x + x' instead
22:50:16 <ski> and then the start of the first (nave) reduction sequence above would look like
22:50:21 <ski>      f (2 * 3)
22:51:09 <ski>   =  (2 * 3) + (2 * 3)  -- using the `f (2 * 3) = (2 * 3) + (2 * 3)' *instance* of the general definition of `f x = x + x' for every `x' (here `x' is set to `2 * 3')
22:51:14 <ski>   =  ...
22:52:15 <sabrehagen> ski: great, that really helps. i'll now try and apply that to my original problem. thanks :)
22:55:29 <ski> sabrehagen : yw :)
22:56:51 <sabrehagen> ski: So returning to the original problem, if I have (\a -> f $ \b -> a+b), and write (\a -> f $ \b -> a+b) 5, i get that 5 subs in for a, resulting in "f $ \b -> 5+b", but i'm not sure what f is. is that a new function that takes some parameter b + 5 as input?
22:57:25 <ski> `f' is a variable which has already been defined/bound
22:57:41 <ski> in this case, it's a variable which contains/references a function value
22:58:11 <ski> (btw, note that `f $ \b -> 5+b' can simpler be written like `f (\b -> 5+b)')
22:59:36 <ski> (also, `(+)' is also a variable which contains some value -- presumably an addition function in this case :)
23:00:33 <sabrehagen> ski: i'm about to get autokicked from this computer, i'll be back in a min!
23:00:41 <ski> ok
23:01:18 <nyingen> auto-kicked?
23:01:47 <ski> > (\(+) -> 2 + 3) (*)  -- note how the local variable `(+)' here is bound to a multiplication function
23:01:48 <lambdabot>   6
23:02:00 <ski> nyingen : presumably a public computer of some kind, e.g. in a library
23:02:37 <ski> @src on
23:02:38 <lambdabot> (*) `on` f = \x y -> f x * f y
23:03:31 <ski> that could also have been written as
23:03:40 <ski>   ((*) `on` f) x y = f x * f y
23:04:49 <ski> > zipWith (max `on` square) [-2,3,-4] [3,2,-2]
23:04:50 <lambdabot>   Not in scope: `square'
23:04:58 <ski> > zipWith (max `on` (^ 2)) [-2,3,-4] [3,2,-2]
23:04:59 <lambdabot>   [9,9,16]
23:06:58 <nyingen> @type max `on` (^ 2)
23:06:59 <lambdabot> forall a. (Ord a, Num a) => a -> a -> a
23:09:16 <ppilate_> @hoogle on
23:09:16 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
23:09:16 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
23:09:17 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
23:09:30 <nyingen> how is this different than composition
23:10:22 <ski> it applies the given function twice
23:11:21 <ski> > sortBy (compare `on` length) (words "The quick brown fox jumpes over the lazy dog")
23:11:22 <lambdabot>   ["The","fox","the","dog","over","lazy","quick","brown","jumpes"]
23:11:34 <ski> sorts by length of the words
23:11:39 <nyingen> I see
23:11:57 <ski> > sortBy ((compare `on` length) `mappend` compare) (words "The quick brown fox jumpes over the lazy dog")
23:11:58 <lambdabot>   ["The","dog","fox","the","lazy","over","brown","quick","jumpes"]
23:12:17 <ski> first sorts by length, then for words of the same length, applies the usual lexicographic ordering
23:13:11 <ski> see Cale's <http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx> for more on this use of `mappend'
23:16:13 <MaskRay_> does cabal-install support socks5 proxy?
23:17:45 <ski> > sortBy ((compare `on` length) `mappend` (compare `on` map toUpper)) (words "The quick brown fox jumpes over the lazy dog")  -- case-insensitive sorting
23:17:46 <lambdabot>   ["dog","fox","The","the","lazy","over","brown","quick","jumpes"]
23:24:53 <ski> wb sabrehagen
23:24:57 <ion> (Note that if you’re *really* going to do case-insensitive sorting, you’ll want something like Data.Text.toCaseFold.)
23:25:15 <sabrehagen> ski: hi, thanks :P
23:26:14 <ski> (yeah, i was worrying that `toLower'/`toUpper' wouldn't correctly handle some signs -- there might also be cases where you want to look at subsequent chars, instead of individually ..)
23:26:27 <sabrehagen> ski:  i read over what you said and it makes sense now, syntactically it's confusing, but with analysis i get it now :)
23:27:28 <ymasory> i have an IO [String] and now I'd like to print every string in that list to the terminal. What result type should I be looking for?
23:27:34 <ymasory> I'm shooting for IO ()
23:27:49 <ski> yep
23:27:55 <ymasory> so i guess i need a [String] -> ()
23:28:00 <ymasory> but that seems silly
23:28:20 <ski> `[String] -> IO ()' would be fine
23:28:23 <ymasory> oh wait, bind with an [String] -> IO ()
23:28:26 <ymasory> beat me to it
23:28:31 * ski nods
23:28:32 <ymasory> thanks
23:28:50 <ski> also, `forM_'/`mapM_' might be nice here
23:29:14 <ski> @type forM_ :: [a] -> (a -> IO ()) -> IO ()
23:29:15 <lambdabot> forall a. [a] -> (a -> IO ()) -> IO ()
23:29:24 <ski> @type mapM_ :: (a -> IO ()) -> [a] -> IO ()
23:29:25 <lambdabot> forall a. (a -> IO ()) -> [a] -> IO ()
23:31:01 <ymasory> ski thanks
23:31:18 <Cale> ski: I like how even though that post of mine you linked to has been archived on reddit and can no longer be voted on, refreshing the page seems to produce various results for its score.
23:31:48 <kulakowski> Cale: They add noise, for deterring bots or something.
23:32:18 <Cale> hmm
23:32:54 <ymasory> ski: my only problem is that if the list is really huge I don't want to accumulate the [String] into one giant string for one putStrLn call
23:33:13 <ion> So use forM_/mapM_
23:33:29 <ymasory> ski: i guess i could flatmap again over the elements of the string, makeing a String -> IO ()
23:34:20 <ion> @type mapM_ `asTypeIn` \mapM_ -> mapM_ undefined (undefined :: [String])
23:34:21 <lambdabot> forall (m :: * -> *) b. (Monad m) => (String -> m b) -> [String] -> m ()
23:38:20 <ymasory> ion: that will leave me with a [IO String] ?
23:39:12 <ion> @type mapM_ `asTypeIn` \mapM_ -> mapM_ (undefined :: String -> IO ()) (undefined :: [String])
23:39:12 <lambdabot> (String -> IO ()) -> [String] -> IO ()
23:39:49 <ion> @hoogle String -> IO ()
23:39:49 <lambdabot> Prelude putStr :: String -> IO ()
23:39:49 <lambdabot> System.IO putStr :: String -> IO ()
23:39:49 <lambdabot> Prelude putStrLn :: String -> IO ()
23:46:42 <ymasory> ion: not available in my language. oh well
23:47:36 <ion> What isn’t?
23:47:52 <ymasory> ion: mapM doesn't exist in scala.
23:48:39 * ion looks at the channel name
23:48:47 <QF-MichaelK> Now, I know that I'm probably asking a very biased bunch of fine gentlemen, but...  Is haskell one of the more natural languages to do problems like the euler project?
23:48:59 <ymasory> ion: thanks anyway
23:49:40 <ion> ymasory: I don’t know scala, but surely you can do the equivalent of mapM_ without concatenating the list of strings first.
23:50:15 <ymasory> ion: maybe. i don't get how mapM does what it does so i need to first. scalaz doesn't have it either in the latest stable, although i see it in the trunk
23:50:32 <ion> @src mapM_
23:50:32 <lambdabot> mapM_ f as = sequence_ (map f as)
23:50:37 <ion> @src sequence_
23:50:37 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
23:51:27 <ion> It makes a list of [putStr firstString, putStr secondString, putStr thirdString] and then returns an action that executes them one by one.
23:51:38 <ymasory> ohh i see
23:51:40 <ymasory> thanks
23:52:18 <ymasory> ion: oh so like mapMonad, where the monad of choice is IO?
23:52:44 <ion> yeah
23:54:32 <ymasory> ion: so that list is [() -> IO ()] ?
23:54:44 <ymasory> or just [IO ()]
23:54:55 <ymasory> i guess there is no () -> * in haskell
23:56:08 <hpaste_> sabrehagen pasted “Types Question” at http://hpaste.org/67955
23:56:16 <ion> Just [IO ()]
23:56:19 <ion> @type sequence_
23:56:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
23:56:34 <sabrehagen> hi guys, i just posted a question in the hpaste above. would somebody mind taking a look at it?
23:57:37 <shachaf> Hey, I remember that question.
23:57:48 <sabrehagen> shachaf: from last night?
23:58:02 <shachaf> Are you the same person?
23:58:07 <sabrehagen> shachaf: yep!
23:58:28 <shachaf> Is this a question from a class or something? I thought it was someone else.
23:59:20 <sabrehagen> shachaf: Yes, it's a university assignment. I have always used the same alias, so maybe somebody else was asking. As I hope you can see from the wording of my question, I'm looking for a point in the right direction, not answers :)
