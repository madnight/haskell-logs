00:08:19 <solidus-river> what's the syntax for defining an infix function?
00:08:34 <solidus-river> or do you have to define them with escape dashes
00:08:35 <shachaf> The same as the syntax for calling it.
00:09:32 <solidus-river> so could you then define a function as a (==') b = if a == b True else False
00:09:37 <solidus-river> then use it via
00:09:40 <solidus-river> a ==' b
00:10:26 <shachaf> solidus-river: You don't call it as "a (==') b".
00:10:35 <shachaf> You call it as "a ==' b"
00:10:39 <shachaf> So that's how you define it. :-)
00:11:19 <solidus-river> cool~
00:11:43 * shachaf wonders what the '~' means.
00:12:00 <shachaf> Also the syntax is "if COND then A else B".
00:12:09 <shachaf> Also "if X then True else False" is the same as "X". :-)
00:12:45 <ibid> shachaf: usually, a backup file :-P
00:13:57 <solidus-river> what defines a block in haskell, just same number of indents?
00:14:22 <ibid> i don't think haskell has any blocks in the conventional sense
00:14:49 <ibid> but yeah, all subsequent lines have to be aligned with the first token of the "block"
00:14:59 <ibid> unless explicit braces are used
01:54:07 <ClaudiusMaximus> woohoo, shake is awesome - just need to test what happens if i run it in a forkIO thread and then killThread it...
02:02:45 <ClaudiusMaximus> oh dear, it seems neither "killThread myShakeThread" nor "throwTo myShakeThread UserInterrupt" do anything useful :/
02:02:47 <solidus-river> whats the process of taking a function that takes multiple paramaters and currying it?
02:03:06 <solidus-river> is there any literature on currying functions?
02:03:12 <navaati> :t curry
02:03:12 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
02:03:21 <navaati> :t uncurry
02:03:21 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
02:03:33 <navaati> that
02:03:40 <ClaudiusMaximus> @hoogle curry3
02:03:40 <lambdabot> No results found
02:03:43 <ClaudiusMaximus> :(
02:04:30 <solidus-river> well, right, thats what currying is, but whats the actual process to take a function from one state (how i'm used to thinking of it) and currying it
02:05:53 <ClaudiusMaximus> curry :: ((a, b) -> c) -> a -> b -> c ; curry f a b = f (a, b)   -- pretty much the only way to do it
02:06:19 <ClaudiusMaximus> @@ @djinn @type curry
02:06:20 <lambdabot>  f a b c = a (b, c)
02:07:16 <solidus-river> i guess i'm searching for the underlying logic that makes one able to do that conversion
02:07:51 <solidus-river> plus a b = a + b, what does plus a look like?
02:08:13 <navaati> ah, you're talking about partial application, not currying !
02:08:56 <navaati> and so i guess you're asking what is the internal representation of closures
02:09:12 <navaati> well the answer is "it depends" (of the compiler)
02:09:19 <mauke> solidus-river: plus a b = a + b is syntactic sugar for plus = \a -> \b -> a + b
02:09:59 <navaati> but a na√Øve representation is simply to store a pair (plus,a)
02:10:34 <solidus-river> ahh, muake: that made the connection awesomely
02:11:01 <solidus-river> navaati: along with the tuple :P
02:11:07 <ClaudiusMaximus> solidus-river: all functions in haskell take exactly one argument, they may return another function which takes one more argument, etc;  :: a -> b -> c   associates like  :: a -> (b -> c)
02:12:00 <solidus-river> I think i need to think about lazy evaluation more, i'm having a hard time understanding how haskell can be so quick with so many seemingly reduntant function applications but i guess if they dont get evaluated untill they are needed it makes up for some of the overhead?
02:12:22 <navaati> solidus-river: GHC performs a LOT of inlining
02:13:05 <navaati> but lazy evaluation adds overhead, yeah, it's true
02:13:49 <sjoerd_visscher> tgeeky: are you there?
02:13:56 <roconnor> the nice thing about a lazy language is that functions get to be used for *abstraction* rather than for evaluation hinting.
02:14:35 <navaati> roconnor: you mean that in strict languages, people use functions to control evaluation ?
02:14:59 <roconnor> navaati: I don't know if that is what they use functions for, but it happens none-the-less.
02:16:30 <roconnor> I think even in strict languages people use functions for abstraction, and the evaluation hinting is simply a side effect that is often, but not always benign.\
02:19:59 <absence> i'm looking at the netwire tutorial on the wiki, which puts everything in the IO monad. what's the way to make it pure instead? Wire e (Kleisli Identity)?
02:20:26 <navaati> absence: yep
02:21:13 <absence> thanks
02:21:29 <sjoerd_visscher> doesn't Wire e (->) work?
02:21:43 <navaati> nop
02:22:01 <navaati> Wire is a data family which is only instanciated for (Kleisli m)
02:30:01 <womb> Hi
02:30:06 <womb> i'm back!
02:30:11 <Taneb> Hello!
02:30:19 <krawczyk> Hi!
02:30:23 <womb> guys web startup in haskell
02:30:33 <womb> snap + mongodb + backbone
02:30:42 <womb> provide json api (REST)
02:30:49 <womb> so snap will not generate content
02:31:01 <womb> or i should for this use just customised warp
02:31:18 <womb> i played with warp adds bit "crap" but performance wise it nukes
02:31:33 <womb> any ideas ?
02:31:40 <womb> i don't want to use yesod
02:32:17 <Taneb> How do I put an upper bound on a cabal dependancy?
02:32:36 <Taneb> something like base >= 4 && < 5
02:32:51 <absence> navaati: how does stepWire work though? it doesn't seem to have a monad in it
02:33:41 <Taneb> Here goes!
02:34:11 <navaati> it returns a "(>~) a (Either e b, Wire e (>~) a b)" where (>~) is (Kleisli m) aka a wrapper around (a -> m b)
02:35:19 <navaati> so you give stepWire your wire, then you pattern match on Kleisly, then you give to the resultant function your input value
02:36:05 <navaati> if m == Identity, you pattern match on Identity. you get a pair (Either e b, Wire e (>~) a b)
02:36:14 <navaati> and you're done
02:41:12 <hpaste> Bas pasted ‚ÄúTokenizer ugly (any suggestions?)‚Äù at http://hpaste.org/68620
02:42:08 <bas_> Anyone care to take a look? I'm basically looking for a method to replace the pattern matching with something more flexible or consistent
02:42:21 <bas_> It's purely a learning project for me
02:43:02 <hpaste> Bas pasted ‚ÄúTokenizer ugly w/ comments‚Äù at http://hpaste.org/68621
02:43:06 * hackagebot family-tree 0.1 - Family trees with lenses  http://hackage.haskell.org/package/family-tree-0.1 (NathanVanDoorn)
02:43:18 <Taneb> :)
02:43:21 <Taneb> That's-a me!
02:44:13 <bas_> hehe yeah
02:44:31 <bas_> good example :p ["That","'s-a","me","!"]
02:44:58 <bas_> what would that supposed to be?
02:45:14 <bas_> ["That","'s","-","a","me","!"] ?
02:45:46 <Taneb> ["That's-a","me","!"], I think
02:48:09 <bas_> oh man, the first random quote from IRC is already completely ambiguous : D
02:49:18 <bas_> Interessante package btw
02:49:52 <Taneb> I hope people find it useful
02:51:01 <bas_> How about your family tree? How many nodes until you end up in my country?
02:51:22 <Taneb> Which country is that?
02:51:31 <bas_> Netherlands
02:51:43 <Taneb> My dad's parents were from the Netherlands
02:51:53 <bas_> :}
02:52:13 <bas_> you know what your last name means? (and do you care?)
02:52:26 <Taneb> "From Doorn", it's a town near Utrecht
02:52:39 <mauke> dead as a doorn ale
02:52:41 <bas_> cool, you know more than me
02:52:54 <bas_> doorn means thorn
02:53:06 <absence> navaati: i think i understand :) is there a way to combine stepWire with giving the input to the resulting function, or is that what stepWireM is for?
02:53:17 <bas_> as in those things on rose branches
02:53:25 <Taneb> Apparently, the town's name comes from the norse god Thor
02:53:34 <bas_> that's way cooler than my version
02:53:39 <bas_> Donar
02:53:43 <mauke> what a prick
02:55:18 <navaati> absence: ah, things are easier with stepWireM, and since the only actual implementation of netwire is with the Kleisli arrow, well stepWireM is the function to use
02:55:40 <navaati> (can you recall me it's signature ? my netwire install is broken)
02:56:15 <navaati> (but i don't understand what you mean by "combine stepWire with giving the input")
02:56:20 <bas_> doorn = thorn, as in the old placename of Thornspiic, now Doornspijk. Old Frisian: thorn :>
02:57:45 <bas_> but you are right, your names comes from Doorn = Thorhem
02:57:57 <bas_> your story is the right one :}
03:00:11 <absence> navaati: http://hpaste.org/68622
03:01:20 <navaati> absence: i meant the signature of stepWireM :)
03:02:06 <absence> navaati: sorry, look again :)
03:03:05 <navaati> hum, so yeah, since there is no (->) instance for (>~), stepWireM is better to use
03:05:03 <navaati> if there was a (->) instance, the type of stepWire would be "Wire e (->) a b -> (->) a (Either e b, Wire e (->) a b)" aka "Wire e (->) a b -> a -> (Either e b, Wire e (->) a b)" so you could feed directly your input, but‚Ä¶ there is no such instance
03:05:09 <t7>  cmon haskell platform! its may! i want data declarations in ghci
03:05:12 <mm_freak> absence: stepWire is really just for completeness‚Ä¶  in any serious application you will want to use stepWireM =)
03:05:47 <navaati> mm_freak: do you imply that serious applications require an underlying monad ? (IO ? Eww)
03:06:02 <mm_freak> in the current version yes
03:06:07 <mm_freak> you can use Identity of course
03:06:27 <navaati> ah, in the current version yeah of course
03:06:35 <mm_freak> in fact if all your wires are pure wires (the WmPure constructor), then stepWireM is the only function that actually uses the monad‚Ä¶  the wire itself will be entirely pure
03:06:44 <absence> navaati: and that would essentially make it stepWireM :) (because "(Identity (Right result, _)) = stepWireM next input" does work)
03:07:56 <navaati> absence: i don't understand why you ignore the result of the first application of stepWire(M) and then use it on the next wire but the old input‚Ä¶
03:09:06 <absence> navaati: that's quite possibly a bug on my part, my test system ignores input. thanks for pointing it out
03:09:49 <mm_freak> absence: as a small design hint:  netwire is designed in such a way that your main application wire would have a fully polymorphic input type
03:10:13 <mm_freak> type MyWire = Wire LastException MyMonad
03:10:20 <mm_freak> app :: MyWire a Something
03:11:00 <mm_freak> of course you can design your application differently, but that's the way i use netwire
03:11:06 <navaati> mm_freak: which means that your system never takes input ? wtf ?
03:11:36 <navaati> ah, you get input data directly by doing IO calls in the wire ? baaah
03:11:57 <mm_freak> navaati: netwire applications make use of effects (not necessarily IO effects)
03:12:05 <mm_freak> your monad could be a simple reader monad
03:12:16 <mm_freak> then you would have something like:  curEvent :: MyWire a Event
03:12:24 <mm_freak> curEvent inhibits, if there is no event
03:12:41 <mm_freak> this is a lot simpler than feeding events as signals
03:12:42 <navaati> ah, so it's explicitly encouraged by the design‚Ä¶ hum, i may come back to animas‚Ä¶
03:13:03 <mm_freak> animas won't make you happy
03:13:12 <navaati> why ?
03:13:27 <mm_freak> the reason i designed it that way is that events should be handled by signal inhibition‚Ä¶  this is impossible if the event itself is a signal
03:13:57 <mm_freak> just like you have a 'time' wire that gives the current local time you have a 'curEvent' wire that gives the current event (or inhibits)
03:14:08 <mm_freak> there is no conceptual difference between time, system event or whatever else
03:14:22 <mm_freak> that's what makes netwire innovative compared to yampa/animas
03:14:52 <mm_freak> animas is difficult to use because events are signals themselves, so you have a nasty Event wrapper and lots and lots of switches
03:14:56 <mm_freak> this is unnecessary in netwire
03:15:17 <absence> what's the main difference compared to reactive banana? the use of arrows?
03:15:28 <navaati> well, in my tests i used things like "injectEvent" and i must admit it got quite ugly
03:16:21 <navaati> (also, i used a reader monad to supply current time, by making an instance of MonadClock‚Ä¶)
03:16:23 <mm_freak> absence: reactive-banana uses the classic notion of FRP, where you have behaviors (time-varying values) and events
03:16:40 <mm_freak> netwire uses time-varying signal networks instead
03:16:44 <mm_freak> that's the basic idea of AFRP
03:16:56 <navaati> mm_freak: so ok, i'm starting to understand how netwire is supposed to be used
03:16:59 <mm_freak> navaati: you shouldn't have to use injectEvent much
03:17:25 <mm_freak> a typical netwire application has two layers
03:17:37 <mm_freak> one library of application-specific wires and the application itself
03:17:47 <mm_freak> app-specific wires should include event wires
03:17:55 <mm_freak> you should /produce/ events, not inject them
03:18:42 <navaati> hum‚Ä¶ well, here is my test code, which integrates with gloss : https://gist.github.com/2717970
03:18:53 <mm_freak> make a few very basic event wires‚Ä¶  then all other events are just compositions of those
03:19:13 <mm_freak> event1or2 = event1 <|> event2
03:19:20 <mm_freak> where event1 and event2 can be arbitrary wires
03:19:54 <absence> mm_freak: so in netwire there is maybe a signal or maybe not (for events), and in banana there are two distinct types for always signal and occasionally signal (i.e. event)?
03:20:26 <navaati> i ran into problems because of inhibition : i had to do tricks (using holdWith) so that the system continues to evolve even when there is no events
03:21:35 <mm_freak> absence: in reactive-banana the concept is entirely different‚Ä¶  you have event streams, which you can think of as Event a = [(Time, a)]
03:21:53 <mm_freak> but yes, the way you use them is pretty yampa-style
03:22:14 <mm_freak> navaati: you shouldn't use tricks there
03:22:16 <mm_freak> just use <|>
03:22:29 <navaati> in which way ?
03:22:43 <navaati> :t (<|>)
03:22:43 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
03:22:46 <mm_freak> (gotEvent1 >>> thisCase) <|> (gotEvent2 >>> thatCase) <|> allOtherCases
03:23:44 <navaati> and how do i say "when got event1, from now on this case, when got event 2, from now on that case"
03:23:54 <navaati> (which is quite a common need, i guess)
03:26:17 <mm_freak> navaati: a single switch or continuous?
03:27:23 <mm_freak> for the first there are many ways to do it‚Ä¶  one simple way is to use 'swallow', another is 'while' or 'until'
03:27:26 <navaati> uh ? what do you mean ? what i meant is, for example, when you press left the object starts to go left (and continues to go left even when the event is finished)
03:27:34 <mm_freak> for the second you can use the edge events
03:30:57 <navaati> anyway, ok now i see why it's pointless to make an (->) instance
03:31:03 <mm_freak> navaati: of course for that specific case you would use a bounded integral wire‚Ä¶  unfortunately that one isn't predefined
03:31:25 <mm_freak> it will be in the next version, whenever i get around to finish it
03:31:29 <navaati> "bounded integral wire" ?
03:31:49 <mm_freak> well, it's not pointless to have (->) instances‚Ä¶  it's just a lot of duplicate work for which i haven't really found time =)
03:32:02 <mm_freak> one ugly thing about (->) is that you wouldn't have time anymore
03:32:17 <navaati> yeah, so no integrals, etc.
03:32:44 <mm_freak> a bounded integral is an integral that can't leave certain bounds
03:32:58 <mm_freak> useful for collision detection etc.
03:33:00 <navaati> oh, btw, maybe you would be interested in integrating this : https://gist.github.com/2718028
03:33:15 <navaati> trivial but still usefull
03:34:21 <mm_freak> navaati: i specifically chose not to implement particular instances‚Ä¶  those should be left to the application/library
03:34:42 <navaati> well, you implemented instances for IO‚Ä¶
03:35:01 <mm_freak> yes, because they are the only sensible instances you could implement for IO =)
03:35:08 <mm_freak> everything else is pretty app-specific
03:35:15 <mm_freak> i know how predefined instances can get very annoying (MonadRandom is an example of that)
03:36:25 <mm_freak> MonadRandom is pretty much useless in a serious application‚Ä¶  i mean who would ever think that someone might actually pass the PRNG state around in a state monad?  the predefined instances make this impossible (unless you enable some ugly extensions)
03:36:26 <jonkri> hi mm_freak :)
03:36:39 <mm_freak> that's basically the reason i decided to write my own variant of that class instead of just using MonadRandom
03:36:42 <mm_freak> jonkri: hi there =)
03:36:52 <absence> navaati: i tried running the gloss example: Segmentation fault/access violation in generated code
03:37:04 <navaati> wtf oO
03:37:15 <absence> that's bad is it? :D
03:37:51 <navaati> eeerrrr‚Ä¶ does your opengl stack work ?
03:38:16 * hackagebot hakyll 3.2.8.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.2.8.0 (JasperVanDerJeugt)
03:38:17 <absence> i think so
03:39:02 <mauke> mm_freak: what's the problem with MonadRandom?
03:39:02 <navaati> i swear i didn't put any unsafeCoerce nor any peek in the code !
03:39:06 <absence> if you by stack mean the haskell specific part of it. it certainly works otherwise
03:39:36 <navaati> no, i meant the whole stack. i mean, does gloss alone works ?
03:39:45 <mm_freak> mauke: the predefined instances
03:39:49 <mm_freak> like this one:  MonadRandom m => MonadRandom (StateT s m)
03:40:22 <absence> navaati: not sure, i installed gloss right now. i had some extremely simple gpipe stuff running earlier though
03:40:26 <mm_freak> this is a very annoying instance effectively disabling me to have the PRNG state in a state monad
03:40:26 <navaati> also, try reducing the fps‚Ä¶ (240 in the definition of main)
03:40:46 <navaati> (hummm, gpipe is so tasty :D)
03:41:12 <absence> it certainly is cute
03:41:42 <navaati> try running "displayInWindow "My Window" (200, 200) (10, 10) white (Circle 80) " in ghci
03:43:21 <absence> what module contains displayinwindow?
03:44:04 <navaati> Graphics.Gloss
03:44:58 <absence> i get "not in scope" o_O
03:48:02 <absence> ah, api changed. display (InWindow ...)
03:48:19 <absence> well, it segfaults
03:48:25 <absence> gloss bug then
03:48:46 <navaati> yep. not the first time i see problems with it
03:48:48 <navaati> sad
03:54:02 <romildo> @pl \p -> p /= "." && p /= ".."
03:54:03 <lambdabot> liftM2 (&&) ("." /=) (".." /=)
03:55:33 <navaati> :t on
03:55:34 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
03:56:47 <absence> navaati: new version of haskell platform any day now i guess. hopefully a ghc upgrade will do the trick :)
03:57:05 <navaati> i think it was t7 that was asking
03:58:31 <absence> t7?
03:59:08 <t7> what do you want?
03:59:56 <fmap> > map (and . sequence [(/= "."), (/= "..")]) $ [".", "..", "abc"]
03:59:58 <lambdabot>   [False,False,True]
04:00:23 <navaati> didn't you ask about the new haskell platform something like one hour ago ?
04:01:49 <navaati> oh, ok, sorry, i thought absence was answering to you, while he was talking about the gloss bug ><
04:03:06 <absence> ah, you had me all confused :D
04:04:29 <schlicht> is there a version of map, that gives a counter/the postion of the current element to the function?
04:05:00 <hpc> :t \f list -> map f (zip [0..] list)
04:05:00 <lambdabot> forall b t b1. (Num t, Enum t) => ((t, b1) -> b) -> [b1] -> [b]
04:05:17 <nand`> :t \f -> zipWith f [0..]
04:05:18 <lambdabot> forall a b c. (Num a, Enum a) => (a -> b -> c) -> [b] -> [c]
04:05:28 <hpc> or zipWith... :P
04:05:32 <kingping> Hi. What would you recommend me to use for simple mail parsing? In particular I just need to extract a couple of attachments out of a message which is given me as the string.
04:05:48 <hpc> kingping: try attoparsec
04:06:07 <schlicht> kay, thanks :)
04:06:30 <hpc> or try hsemail, perhaps
04:06:33 <hpc> http://www.haskell.org/hoogle/?hoogle=mail
04:07:04 <hpc> i can't really comment on a package where the modules are all RFC numbers though...
04:13:28 <t7> does anyone bother with TDD in haskell
04:13:38 <t7> or just trust that it works if it type checks
04:15:21 <hpc> t7: i trust my ability to catch errors by reading code than i trust unit tests
04:15:33 <hpc> and as a bonus, it makes a good way to decide when to refactor
04:15:43 <hpc> just keep refactoring until there are obviously no bugs
04:16:02 <t7> yeah i cant really relate the the ruby crowd
04:16:52 <hpc> after learning agda, my opinion of TDD is "oh how cute, you limit your proof objects to refl"
04:21:18 <RichyB> hpc, "refl"?
04:22:20 <hpc> say you wrote a GADT
04:22:30 <hpc> data Equals a b where Refl :: Equals a a
04:22:42 <hpc> refl is Refl, but dependently typed
04:22:46 <hpc> so it can express equality of values
04:22:59 <hpc> your unit tests essentially become
04:23:02 <t7> why do you need b ?
04:23:11 <hpc> test1 : f 15 == "bob"
04:23:14 <hpc> test1 = refl
04:23:47 <hpc> t7: because it needs to be of kind * -> * -> *
04:24:06 <hpc> it's the same reason you don't define equality as "(==) a a = True"
04:24:17 <hpc> b is a parameter, as it were
04:24:37 <t7> @src (==)
04:24:37 <lambdabot> x == y = not (x /= y)
04:25:02 <navaati> hahaha :D
04:25:12 <navaati> @src (/=)
04:25:12 <lambdabot> x /= y = not (x == y)
04:25:22 <WashIrving> :D
04:25:23 <navaati> u mad ?
04:25:54 <t7> ah i get it
04:26:48 <RichyB> hpc, so, if I perform a pattern match, case (Equal e1 e2) of ‚Üí e3 -- then in e3, I can assume that e1 and e2 are identically typed and it'll typecheck?
04:27:14 <hpc> RichyB: yeah
04:27:27 <hpc> inside the case you have an (e1 ~ e2) context
04:27:33 <RichyB> er
04:27:47 <RichyB> that should be case (Refl e1 e2), oops.
04:27:54 <hpc> RichyB: no, just Refl
04:28:18 <hpc> but yeah, you're getting it
04:28:31 <RichyB> ? But Refl :: a -> a -> Equals a a
04:28:33 <t7> thats clever
04:28:40 <RichyB> Surely I need two arguments for Refl.
04:28:43 <hpc> RichyB: Refl :: Equal a a
04:28:43 <t7> you agda guys arnt so dumb
04:28:54 <RichyB> hpc, oh! Yes.
04:29:03 <RichyB> I blame record syntax for making me dumb. ¨_¨
04:29:24 <hpc> t7: in agda it doesn't look remotely as clever because that's just the tip of the iceberg :D
04:31:16 <navaati> case p of { n<0 -> blah; n<m -> blih }‚Ä¶ agda is good
04:31:18 <t7> what calculus is idris based on?
04:31:57 <mekeor> t7: #idris ? =)
04:32:05 <mekeor> t7: lambda-calculus? :)
04:32:29 <t7> haha
04:33:11 <matthew-_> sorry, I'm having a brain death moment. Why can I not seem to do lets within do-blocks in ghci?
04:33:24 <matthew-_> do { let x = (1,2); return 5 } doesn't work
04:33:30 <matthew-_> (ghci 7.4.1)
04:34:05 <mekeor> matthew-_: just remove the do-block.
04:34:20 <mekeor> > let x = (1,2); 5
04:34:21 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
04:34:30 <mekeor> > 5
04:34:31 <lambdabot>   5
04:34:37 <matthew-_> mekeor: no no, I really need this to be in a do
04:34:48 <mauke> matthew-_: let { x = (1, 2) };
04:34:55 <kingping> let x = 42 >> return 13
04:35:11 <ion> > do let { x = 42 }; x
04:35:12 <lambdabot>   42
04:35:14 <matthew-_> ahh! mauke: thank you
04:35:44 <mekeor> kingping: that'd mean "let x = { 42 >> return 13 }", actually.
04:36:38 <kingping> Indeed, (>>) is infix here.
04:36:45 <matthew-_> so let will always introduce a new scoping?
04:36:53 <matthew-_> > do { let { x = (1,2) }; let { x = True }; return x }
04:36:54 <lambdabot>   No instance for (GHC.Show.Show (m GHC.Bool.Bool))
04:36:55 <lambdabot>    arising from a use of ...
04:37:12 <matthew-_> whatever. I'm trying to work out why that doesn't result in a pattern match failure
04:38:29 <mauke> matthew-_: because x is an infallible pattern
04:39:03 <matthew-_> mauke: right - my head's confused by years of Erlang!
04:41:08 <matthew-_> > do { x <- Just []; let { [y] = x }; return y; }
04:41:09 <lambdabot>   Just *Exception: <interactive>:3:25-31: Irrefutable pattern failed for patt...
04:41:14 <matthew-_> > do { x <- Just []; [y] <- return x ; return y; }
04:41:15 <lambdabot>   Nothing
04:41:31 <matthew-_> right, so if the pattern match in the let fails, we go to error, rather than fail
04:41:37 <bitonic> matthew-_: you can't imagine how many times I banged my head on Erlang unification at the beginning after years of Haskell...
04:41:54 <matthew-_> bitonic: oh I can :)
04:42:06 <bitonic> in Prolog it's much more natural, imo
04:42:59 <bitonic> but ofc some times it's neat
05:00:10 <navaati> :t fmap fmap fmap
05:00:10 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
05:00:42 <navaati> :t fmap fmap
05:00:43 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
05:00:51 <navaati> :t fmap . fmap
05:00:51 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
05:08:22 <navaati> :t Writer
05:08:23 <lambdabot> Not in scope: data constructor `Writer'
05:12:58 <Aune> So, Im getting "cabal: error while loading shared libraries: libgmp.so.3". What is the prefered fix to this?
05:13:18 <edsko> @pl (\_ -> q >> p `onCtrlC` q)
05:13:18 <lambdabot> const (q >> p `onCtrlC` q)
05:13:41 <mauke> Aune: recompile
05:13:59 <absence> is it possible to import a module and get all identifiers qualified except a specific one unqualified?
05:14:04 <Aune> mauke, darn. That was what I was afraid of.
05:14:13 <byorgey> sounds like your libgmp got changed/updated
05:14:25 <dcoutts_> Aune: sounds like you got a cabal binary that's not ok for your system (or you really don't have gmp installed, it's a prerequisite for ghc)
05:14:40 <fmap> absence: import two times
05:15:12 <fmap> import qualified M as N; import M (foo)
05:16:15 <Aune> Yeah, my computer club recently updated their systems to Ubuntu 12 and now things dont work as they used too. I was hoping I wouldnt have to recompile since that takes a lot of time. But.. Oh well.
05:16:40 <absence> fmap: ahh, thanks
05:17:15 <ClaudiusMaximus> Aune: possibly you just need to install cabal-install from the repository?
05:18:17 <tazjin> Aune: sudo ln -s /usr/lib/libgmp.so.10.0.1 /usr/lib/libgmp.so.3
05:18:21 <Aune> ClaudiusMaximus, that would be nice. Will look into that possibility
05:18:41 <Aune> tazjin, Sadly, I am not root.
05:19:28 <tazjin> Aune: Hrrm, I think there's some sort of cabal parameter that controls library directories, but I could be wrong
05:19:51 <navaati> pure for ZipList is (ZipList . repeat), right ?
05:20:00 <byorgey> yes
05:21:09 <ClaudiusMaximus> environment variables maybe?  LD_LIBRARY_PATH or something like that..  make a symlink as tazjin suggests, but in a directory you own, then add that directory to the LD_LIBRARY_PATH environment variable?  but sounds messy and possibly crashy to me...
05:21:52 <Aune> There seems to be a new Haskell Platform due soon, anyone know the exact date?
05:22:35 <Aune> I can only find "due May 2012".
05:24:10 <tazjin> I don't think the platform includes libgmp though
05:24:50 <ladr0n> Yeah, libgmp is just part of the OS.
05:26:02 <Aune> Yeah, but if I need to rebuild anyway to build against an up to date version of libgmp then I might as well wait until the new platform is released and build it then.
05:26:36 <Aune> Given that the new version will arrive in the next few days
05:26:41 <tazjin> Aune: Try mkdir ~/lib && ln -s /usr/lib/libgmp.so.10.0.1 ~/lib/libgmp.so.3 and run cabal with --extra-lib-dirs=~/lib
05:27:25 <dcoutts_> note that's not guaranteed to work, they're not fully ABI compatible, that's why the version bump
05:28:06 <gienah> debian and fedora patched ghc for libgmp: https://bugs.gentoo.org/411925
05:28:29 <gienah> and the upstream ticket: http://hackage.haskell.org/trac/ghc/ticket/5743
05:30:08 <Aune> tazjin, I think I will do this as a temporary solution. I will rebuild when the new platform arrives though.
05:30:46 <tazjin> Aune: Yeah, it's not really meant to be a permanent solution, but better than not being able to do anything until the new platform arrives
05:35:19 <Aune> tazjin, Yeah. Thank you for the help.
05:44:02 <geers> Is there a OpenSSL library for Haskell ?
05:44:36 <hpc> @hoogle ssl
05:44:36 <lambdabot> Codec.Compression.Zlib.Internal compressLevel :: CompressParams -> CompressionLevel
05:44:37 <lambdabot> Codec.Compression.Zlib.Raw compressLevel :: CompressParams -> CompressionLevel
05:44:37 <lambdabot> Codec.Compression.Zlib compressLevel :: CompressParams -> CompressionLevel
05:44:52 <hpc> :P
05:45:10 <fmap> HsOpenSSL probably
05:47:28 <fmap> @hackage HsOpenSSL
05:47:28 <lambdabot> http://hackage.haskell.org/package/HsOpenSSL
05:47:42 <absence> has anyone used Data.Vec? how do i convert Vec2 a to Vec4 a and supply the two last values?
05:47:54 <geers> Ok thanks. How about system the system interface
05:49:03 <ClaudiusMaximus> absence: f (x :. y :. ()) z w = x :. y :. z :. w :. ()  iirc
05:49:20 <geers> I will try, thanks
05:49:25 <ClaudiusMaximus> absence: there's probably some function with insanely long type signature to do it for you
05:50:53 <absence> ClaudiusMaximus: ugh, thanks ;)
05:51:10 <ClaudiusMaximus> absence: btw, Vec fails to build on recent ghc, i did send a patch to the maintainer several months ago, and did get a reply, but no new version on hackage yet..
05:52:25 <absence> ClaudiusMaximus: that's okay, i'm on 7.0.3 :D
05:53:36 <hpaste> ClaudiusMaximus pasted ‚Äúpatch for Vec so it builds with recent ghc‚Äù at http://hpaste.org/68624
06:20:40 <ski> hpc : i would write it as `data Equals a :: * -> * where ...' or `data Equals :: * -> * -> * where ...'
06:20:53 <ManuRocca> ciao
06:20:55 <ManuRocca> !list
06:21:10 * ski stares blankly
06:21:41 <hpc> ski: :P
06:21:45 <hpc> hmm
06:21:51 <hpc> there's an old-locale package
06:21:54 <hpc> but no locale package
06:33:13 <navaati> ski : i know the 1st version is better (at least in Agda) but i can't remember why‚Ä¶ do someone know ?
06:34:03 <quicksilver> hpc: yeah it was going to be deprecated but nobody ever wrote a replacement.
06:34:20 <hpc> haha
06:35:07 <ski> navaati : with the former, the first argument is a parameter instead of an index -- i don't recall the difference, though
07:04:04 <Phlogistique> any tutorial on computing time/space complexity of lazy programs?
07:07:48 * applicative only heard that the School of Hard Knocks offers free tutorials daily
07:12:55 <applicative> wow, simonpj has taken a copy of my variant of rampions redblack trees for ghc's regression suite
07:13:33 * applicative beams with pride over his 30 seconds of thought and editing
07:14:38 <quicksilver> :)
07:15:05 <armlesshobo> :)
07:15:43 <sp3ctum> ClaudiusMaximus, what is the (:.) operator in your example?
07:16:20 <quicksilver> it's normally (f .) . g
07:16:26 <quicksilver> or a generalisation of that.
07:16:38 <quicksilver> hmm no, that's .:
07:16:43 <quicksilver> :. will be a constructor.
07:16:44 <quicksilver> ignore me :)
07:17:58 <Jaak> (.:) = flip (:.)
07:18:05 <Jaak> (kidding ofcourse)
07:18:24 <sp3ctum> uh..
07:18:50 <shapr> oh hai!
07:19:21 <nand`> sp3ctum: http://hackage.haskell.org/packages/archive/Vec/0.9.8/doc/html/Data-Vec-Base.html
07:20:31 <sp3ctum> nand`, ok, thankyou
07:55:53 <noumena> Hello, Haskell people.  I'm trying to get from Text to Ptr a. Got any clever ideas?
07:57:53 <quicksilver> Ptr a in what format, for what purpose?
07:58:53 <applicative> Data.Text.Foreign asForeignPtr :: Text -> IO (ForeignPtr Word16, I16)
07:59:25 <noumena> Ptr CChar, so that I can call a foreign exported Haskell function
08:00:04 <noumena> Sorry, so that I can export a "string" from haskell back to C#
08:00:15 <mgolechn> why aren't you all writing J?
08:00:36 <shapr> mgolechn: I do like J actually, it has a nice ancestry back to APL
08:00:40 <applicative> mgolechn: what makes you think we aren't
08:00:51 <shapr> mgolechn: And I like Joy, and K and PostScript and fun languages like that.
08:01:02 <bitonic> I don't like PostScript.
08:01:05 <shapr> oh I do!
08:01:12 * applicative thinks, PostScript?
08:01:25 <bitonic> I guess it can be "fun" ehe
08:01:34 <shapr> But I like Haskell more than all the others.
08:01:42 <shapr> So that's why I write Haskell when I get a chance.
08:01:56 <shapr> mgolechn: What about you? What do you like to write?
08:02:06 <armlesshobo> words
08:02:09 <mgolechn> english
08:02:11 <mgolechn> quenya
08:02:12 <mgolechn> and J
08:02:18 <mgolechn> also, math
08:02:40 <shapr> mgolechn: Those all sound like fun things to write.
08:02:46 <shapr> mgolechn: Have you tried Haskell?
08:04:11 <mgolechn> haskell? you fruity faggot, eat a dick
08:04:22 <shapr> Hm, well that was interesting.
08:05:33 <armlesshobo> lol wat
08:05:50 <byorgey> oh, someone from the UWaterloo CS Club again?
08:06:00 <shapr> byorgey: Yah, probably that same guy I banned before.
08:06:30 <shapr> I think he has anger management issues.
08:06:36 <armlesshobo> lmao
08:06:43 <bitonic> http://csclub.uwaterloo.ca/ . who would have thought.
08:06:44 <c_wraith> that seems more like a trolling club
08:07:52 <byorgey> no, I think it's legit, shepheb is from there too =)
08:08:09 <armlesshobo> you should make a complaint
08:08:12 <armlesshobo> to them
08:08:16 <armlesshobo> and get them in trouble :)
08:08:19 <shapr> Which leads me to think that troll user was likely the same guy I banned previously.
08:08:19 <armlesshobo> >:D
08:08:34 <armlesshobo> you should get him kicked out of the club lol
08:08:52 <shapr> armlesshobo: Eh, I can only hope he improves.
08:09:01 <shapr> armlesshobo: I'd rather spend my time doing creative productive things.
08:09:19 <shapr> If he continues to make insulting comments, then I might do something about it.
08:09:25 <armlesshobo> shapr: and banning him repeatedly is productive? :P
08:09:39 <shapr> Hm, not really.
08:09:47 <shapr> armlesshobo: I'll think about it.
08:10:02 <shapr> armlesshobo: Are you writing any code today?
08:10:07 <armlesshobo> nothing interesting
08:10:38 <armlesshobo> either code for work or whatever haskell attempts I make while following the book
08:10:42 <armlesshobo> (LYAH)
08:11:14 <shapr> What do you write for work?
08:12:28 <armlesshobo> C/C++
08:13:31 <nand`> instance Monad m => ArrowApply (Kleisli m) where app = Kleisli (uncurry runKleisli) -- is this correct?
08:14:56 <path[l]> where's a good place for programming career advice
08:15:15 <shapr> path[l]: Depends on your career?
08:15:32 <shapr> path[l]: It's off-topic here on #haskell, but you could ask on #haskell-blah
08:15:49 <quicksilver> nand`: if it type-checks it can't be wrong, there is only one possible non-trivial instance ;)
08:16:02 <path[l]> well it's not a career is haskell anyway :/. It's just a software thing. I've got to decide between 2 job offers in the bay area
08:16:13 <byorgey> nand`: yes, that's correct
08:16:22 <nand`> awesome
08:16:43 <byorgey> Control.Arrow actually defines  app = Kleisli (\(Kleisli f, x) -> f x)  but that's equivalent
08:16:55 <Taneb> Issue 1 with family-tree fixed!
08:17:00 <byorgey> \o/
08:31:19 <donderom> Hi! Is there any reason why hackage's response time is so slow?
08:31:25 <s2r2> dear #haskell.  I'm trying to combine 'cabal install' something on Debian, using Debian's packages for ghc, cabal-install, platform and some of the dependencies.  Now cabal install still wants to install one dependency, say, text, in the newest version, although it already is installed (as a packages from Debian) and the newer version doesn't seem needed (it's not enforced at least).   Is there any way to stop this, i.e., tell cabal to be h
08:31:48 <hpc> srh: don't combine cabal-install and apt
08:32:23 <hpc> for exactly that reason
08:33:30 <s2r2> hpc: ok.  So to install something from hackage that is not packaged, I just 'cabal install' it with all the dependencies that are pulled. Hmm this means I should not use any Debian packages for dependencies at all, actually, right?
08:33:33 <applicative> s2r2: maybe study http://www.vex.net/~trebla/haskell/sicp.xhtml
08:33:43 <dcoutts_> s2r2: yes, you can tell it to use a specific version, e.g. --constraint='text == 1.0.0' or whatever
08:34:10 <s2r2> applicative: thanks for the pointer
08:34:12 <Clint> s2r2: i use debian packages unless they're too old
08:34:32 <dcoutts_> s2r2: it's fine to use distro packages, the only thing to be aware of is that upgrading distro packages can break your user packages (because the distro package manager is not aware of them)
08:34:49 <s2r2> dcoutts_: I see. thanks for the pointer to --contraints
08:35:17 <applicative> s2r2 I'm not sure about monochrom's final advice but the discussion helped me get clearer
08:35:41 <dcoutts_> s2r2: there is/was also a specific issue with having the same version of the same package installed in both global and user package dbs, that's now less problematic with cabal-install-0.14+
08:36:35 <applicative> hm, just installed 0.14
08:37:22 <s2r2> dcoutts_: Debian's cabal-install is 0.10.2.  So I should first use the stock cabal-install to update cabal-install..?
08:38:03 <dcoutts_> s2r2: you can do that yes, just watch out for $PATH issues
08:38:39 <s2r2> dcoutts_: ok thank
08:39:04 <s2r2> you
08:39:29 <Clint> s2r2: and 0.14 will be in testing at the end of the month
08:39:39 <s2r2> Clint: I just noticed... :)
08:40:01 <s2r2> ok.  I'll be happy with what's there and give it a try using constraints.  Thanks a lot everyone.
08:46:00 <applicative> dcoutts_: are you in Oxford?
08:46:14 <dcoutts_> applicative: yes
08:46:40 <applicative> ha, so am I for  the week , maybe I will make a pilgrimage to Well-Typed
08:46:42 <applicative> just kidding
08:46:46 <dcoutts_> :-)
08:46:56 <dcoutts_> can see our fancy offices in Oxford ;-)
08:47:10 <applicative> i can imagine the vast reception area
08:47:38 <hpc> > 0xford
08:47:39 <lambdabot>   15
08:47:43 <hpc> wat
08:47:51 <applicative> what??
08:47:52 <dcoutts_> applicative: sadly not very good timing, I'm flying off to California soon
08:48:02 <applicative> ah
08:48:04 <ClaudiusMaximus> > 15 ord
08:48:05 <lambdabot>   15
08:48:08 <hpc> oh
08:48:14 <hpc> lol function numbers
08:48:36 <dcoutts_> applicative: when are you here 'til?
08:48:48 <dcoutts_> applicative: there's also OxHUG on tuesdays
08:48:54 <applicative> Tuesday I guess
08:49:45 <hpc> @remember hpc > 0xford <lambdabot>   15
08:49:46 <lambdabot> Good to know.
08:50:05 <applicative> maybe I should found a local HUG, but I'm afraid my neighbor Robert Harper would firebomb us
08:50:17 <copumpkin> lol
08:50:20 <barrucadu> I wonder if there's a HUG in York‚Ä¶
08:50:21 <applicative> as corrupting youth
08:50:39 <barrucadu> No :(
08:51:42 <micahjohnston> has anyone hre done anything with Haskell on the iPhone?
08:51:43 <micahjohnston> here*
08:52:42 <armlesshobo> micahjohnston: don't know if you can, just yet
08:52:58 <micahjohnston> armlesshobo: I know it's been done at some point, however experimental it is
08:53:28 <osfameron> there was also something alleging to be Haskell on Arduino, though it seemed like it was a minilanguage, and you still had to write C also.
08:53:51 <armlesshobo> micahjohnston: have checked this out already? http://www.haskell.org/haskellwiki/IPhone
08:53:57 <hpaste> nand` pasted ‚ÄúArrowMonad instance‚Äù at http://hpaste.org/68631
08:53:59 <micahjohnston> armlesshobo: yeah, I've been looking there
08:54:04 <armlesshobo> ok
08:54:09 <nand`> it type checks, but can it be improved? looks rather ugly --^
08:54:10 <micahjohnston> armlesshobo: I wanted to talk to someone in person to see if they could give me advice
08:54:18 <armlesshobo> ah, gotcha
08:54:23 <quicksilver> lots has been done with haskell on the iphone
08:54:45 <quicksilver> unfortunately I think most of it is not quite usable for casual users yet
08:54:59 <quicksilver> http://www.haskell.org/pipermail/iphone/2012-March/000120.html
08:57:16 <quicksilver> http://hip-to-be-square.com/~blackh/ghc-iphone-new/v5/
08:57:57 <micahjohnston> yeah, that's the impression I got
08:58:26 <quicksilver> if you're happy compiling GHC from source and fairly comfortable with iPhone dev in general
08:58:29 <quicksilver> you should be able to get it going
08:58:32 <T-Guy> guess what, found the channel on channel list and I'm serching wikipedia to know wtf Haskell is !!!
08:58:35 * quicksilver hasn't tried yet
08:58:43 <micahjohnston> cool, thanks
09:03:43 <armlesshobo> is it possible to make a type only have one possible value of a fixed sized list?
09:05:36 <quicksilver> data Foo = This | Or | That | But | Nothing | Else
09:05:38 <quicksilver> armlesshobo: ?
09:06:01 <armlesshobo> quicksilver: ok
09:06:11 <womb> ADT
09:06:36 <armlesshobo> I'd like the type to be a fixed sized list
09:06:43 <armlesshobo> is that possible at all?
09:06:43 <womb> armlesshobo: best nick evar
09:07:02 <armlesshobo> womb: lol ty
09:07:23 <womb> armlesshobo:  you can have 2 type data Lol = Lol Foo Foo Foo Foo Foo
09:07:25 <womb> record syntax
09:07:41 <armlesshobo> hmmm
09:07:41 <armlesshobo> ok
09:08:21 <quicksilver> armlesshobo: fixed size list of what?
09:08:22 <womb> http://learnyouahaskell.com/making-our-own-types-and-typeclasses
09:08:37 <womb> like this data Person = Person String String Int Float String String deriving (Show)
09:08:46 <gdoteof> can i get the equivalent of :t from within a haskell program for debugging?
09:08:57 <armlesshobo> quicksilver: any type
09:09:05 <womb> data Hobos = Hobos Foo Foo Foo deriving (Homeless)
09:09:17 <hpc> gdoteof: use Typeable, probably
09:09:26 <quicksilver> armlesshobo: well, the simplest thing is just data FourStrings = FS String String String String
09:09:29 <nand`> you might be interested in something like Data.Vec which includes something like Vec5 for a list with 5 elements
09:09:32 <hpc> or something like that; it's right up there with trace in terms of horridness
09:09:39 <quicksilver> or data FourX a = FX a a a a
09:09:43 <hpc> so be sure to keep it out of the finished program ;)
09:10:08 <nand`> Vec4 String -- example: "foo" :. "bar" :. "baz" :. "baz" :. ()
09:10:15 <quicksilver> there are more sophisticated and complex possibilities but it really depends what you're trying to do.
09:10:33 <quicksilver> the built-in type (a,a,a,a) may well be sufficient.
09:10:53 <armlesshobo> my goal is to try to write a simple tictactoe game with what I've learned from reading LYAH
09:11:43 <nand`> maybe something like a 3x3 matrix would be most appropriate
09:11:54 <quicksilver> for tic tac toe I probably wouldn't bother enforcing the length in the type system
09:12:00 <quicksilver> I'd just go for a list-of-lists
09:12:07 <armlesshobo> hm ok
09:12:09 <quicksilver> (which happens to be three lists of length three)
09:12:25 <quicksilver> there are trade-offs all over, it depends what you're trying to learn ;)
09:12:34 <nand`> data TicTacToe a = TicTacToe { topLeft :: a, topMid :: a, topRight :: a ... }
09:13:29 <rwbarton> data Triple a = Triple a a a ; type Grid = Triple (Triple Square)
09:13:51 <rwbarton> many options yes
09:13:58 <nand`> data TicTacToe a = ((a, a, a), (a, a, a), (a, a, a)) -- works too
09:14:03 <womb> tuple
09:14:04 <womb> !
09:14:05 <womb> ftw
09:14:16 <armlesshobo> :O
09:14:30 <nand`> might result in the cleanest pattern matching :)
09:14:33 <tromp_> for tictactoeyou'd just use a bitmap
09:14:37 <quicksilver> the advante of list of lists
09:14:48 <quicksilver> is that lists are a useful type with loads of predefined functions on
09:14:53 <nand`> is being able to easily check rows and columns -^
09:14:56 <quicksilver> so it might be easier to write the code that works on it.
09:15:03 <womb> list of list would be my default
09:15:14 <nand`> (colums using transpose :: [[a]] -> [[a]])
09:15:40 <nand`> might be possible to check diagonals easily too using some sort of zipWith
09:16:05 <nand`> second advantage: tic tac toe can be generalized to different lengths this way; as long as it's assumed the playing field is square
09:17:54 <nand`> > zipWith (!!) ["X..", ".X.", "..X"] [0..]
09:17:55 <lambdabot>   "XXX"
09:18:59 <andrus> Is there a way to make `read "abc" :: String` or `read "\"abc\"" :: String` work?
09:19:16 <quicksilver> > read "\"abc\"" :: String
09:19:17 <lambdabot>   "abc"
09:19:25 <quicksilver> andrus: in what respect does it fail to work?
09:19:44 <aristid> andrus: "abc" is already a String, so read "abc" makes little sense. read "\"abc\"" also already works
09:20:15 <nand`> Is there no ‚ÄúallEqual :: Eq a => [a] -> Bool‚Äù ?
09:20:17 <andrus> I think I was actually getting an error from haskell-mode for vim's :GHCi
09:21:14 <quicksilver> nand`: (==1).length.group
09:21:16 <quicksilver> nand`: :P
09:21:31 <nand`> quicksilver: surprisingly simple :)
09:22:05 <andrus> aristid: The reason I want to read a string to a string is because I have written a generic `get` function to use with HXT, so in many cases I want to `get` some text in XML as an Integer or String
09:22:05 <nand`> quicksilver: fails on [] though
09:22:11 <nand`> (<=1)
09:22:15 <applicative> armlesshobo: i was just looking in the 'operational' package, which has a simple setup for terminal tic tac toe -- the IO and game logic is otherwise very fancy
09:22:16 <quicksilver> nand`: as it should.
09:22:23 <quicksilver> nand`: arguably, anyway :)
09:22:24 <nand`> all elements in [] are equal though :P
09:22:45 <sjoerd_visscher> they are all different too
09:22:46 <armlesshobo> applicative: hmm. i'll have to check it out. thank you :)
09:22:47 <andrus> aristid: there might be a better way to do it than just chaining `arr read` to the end of my fn
09:22:50 <rwbarton> you could plausibly want either behavior on []
09:22:56 <hpaste> applicative pasted ‚Äúbasic types tictactoe‚Äù at http://hpaste.org/68634
09:23:00 <quicksilver> nand`: and.(zipWith(==)`ap`tail) is perhaps the more "obvious" answer.
09:23:06 <quicksilver> and it also fails on the empty list
09:23:15 <quicksilver> I maintain this is not unreasonable, like rwbarton said.
09:23:32 <applicative> armlesshobo: thats just the basic types ^^^
09:23:36 <quicksilver> analogous to 'maximum' and 'minimum' not being defined on ampty lists.
09:23:45 <rwbarton> raising an error on [] is good, it forces you to think about what you want :)
09:24:12 <applicative> armlesshobo: in the example he goes on to show how easy it is to do the IO either with a second human player or very dim AI  :)
09:24:32 <applicative> armlesshobo: but for that he's using his rather complicated abstractions
09:25:12 <rwbarton> of course once you do work out what you want, you should handle the empty list case somehow (unless you know it is impossible for some reason)
09:26:24 <nand`> ‚Äúfor all a in xs. for all b in xs. a == b‚Äù is how I would define ‚Äúevery element being equal‚Äù
09:27:17 <hpc> all $ (==) <$> xs <*> xs
09:27:32 <rwbarton> I recall we had this discussion before, when the question of how to define "constant function" came up and in particular whether the function from the empty set to itself is constant
09:27:32 <pls> hi, all. i've a question: i developped an app in flash that receives a haskell response to do a parser.
09:27:40 <quicksilver> hpc: that feels inefficient though
09:27:45 <pls> the problem is the new lines in haskell is represented to two ascii characters CR + LF.
09:27:58 <pls> However, the parser in flash waits a new line character as only LF and, because of this, the parser doesn't work well.
09:28:07 <pls> The question: anyone knows how could i create new lines in haskell with the LF character only? thanks in advance
09:28:11 <quicksilver> that's not haskell, pls
09:28:15 <rwbarton> "stop using windows"
09:28:20 <quicksilver> that's the international standard for network traffic.
09:28:24 <rwbarton> or open your files in binary mode
09:29:03 <quicksilver> ASCII text transmitted across the network *must* use the two-character sequence:  CR LF
09:29:10 <jonaskoelker> rwbarton: "for all x: for all x': f(x) = f(x')" vs "exists y: for all x: f(x) = y"?
09:29:33 <rwbarton> jonaskoelker, exactly
09:29:54 <jonaskoelker> both kinda' make sense...
09:30:08 <rwbarton> poll your friends!
09:30:12 <nand`> hpc: s/all/and/
09:30:40 <hpc> ah right
09:30:47 <nand`> gets me all the time
09:30:52 <quicksilver> anyhow, (pls) - http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#t:NewlineMode
09:31:08 <nand`> but yeah, that definition seems ‚Äúelegant‚Äù (if horribly inefficient) and returns true on [] :)
09:31:22 <jonaskoelker> maybe "non-varying" and "single-valued" are better names for "constant" and "constant", respectively :-)
09:31:31 <hpc> nand`: it also works on types with broken Eq instances
09:31:40 <nand`> hpc: what do you mean?
09:31:54 <nand`> oh; a == b and b == c but a /= c
09:31:58 <hpc> yeah
09:32:18 <pls> ok, i will change the app to support create a new line as CR LF, thanks to all
09:32:29 <nand`> I don't think support for broken instances should be a design goal though :P
09:32:51 <jonaskoelker> I think that's how PHP and Perl are designed ;-)
09:33:03 <hpc> jonaskoelker: perl isn't that bad, but php is
09:33:09 <nand`> not exactly stunning examples of great design goals, I'm sure ;)
09:33:25 <rwbarton> the second definition has an easy category-theory-esque formulation: f : A -> B is constant if there exists a factorization f : A -> () -> B
09:33:32 <jonaskoelker> I'll stand semi-corrected: php is a _lot_ worse than perl, though I still think perl has its issues
09:33:37 <hpc> perl has string equality, which converts to string before compare
09:33:46 <hpc> and numerical equality, which converts to numbers before compare
09:33:56 <jonaskoelker> (in fact a mind-bogglingly lot worse)
09:34:08 <hpc> if you're using either in the wrong place, that's a mistake on your end imo
09:34:22 <hpc> but you at least get the choice of which to use :P
09:34:27 <rwbarton> and yet perl has values which are neither string nor numbers :P
09:34:27 <jonaskoelker> true :)
09:34:38 <jonaskoelker> let eq = (==) `on` show
09:34:40 <jonaskoelker> :-)
09:34:50 <hpc> rwbarton: i have never compared arrays or hashes for equality :P
09:34:55 <jonaskoelker> perl-style equality semantics in haskell
09:35:14 <hpc> jonaskoelker: not quite
09:35:19 <jonaskoelker> no?
09:35:23 <hpc> eq x y = show x == show y
09:35:32 <hpc> x and y can have different types
09:35:35 <jonaskoelker> right
09:35:56 <jonaskoelker> is it false in all those cases?
09:36:17 <geekosaur> :t (==) `on` show
09:36:19 <lambdabot> forall a. (Show a) => a -> a -> Bool
09:36:25 <jonaskoelker> (the perl one)
09:36:30 <rwbarton> "34" eq 34
09:36:30 <geekosaur> :t \x y = show x == show y
09:36:31 <lambdabot> parse error on input `='
09:36:38 <geekosaur> :t \x y -> show x == show y
09:36:39 <lambdabot> forall a a1. (Show a, Show a1) => a -> a1 -> Bool
09:36:52 <jonaskoelker> oh
09:37:00 <nand`> rwbarton: show "34" is "\"34\"" which is /= "34"
09:37:09 <rwbarton> oh Haskell show
09:37:27 <nand`> jonaskoelker: show (x :: Integer) = show (x' :: Int) but they have differing types
09:37:30 <rwbarton> well perl eq can be true when x and y have different types, I thought that was the question
09:37:34 <rwbarton> but maybe not
09:37:43 <jonaskoelker> nand`: for small values of x :-)
09:37:47 <jonaskoelker> thanks, good example
09:37:48 <hpc> hmm, yeah
09:37:59 <jonaskoelker> that was my question
09:37:59 <hpc> looks like you need to rework Eq entirely to support perly equality
09:38:02 <nand`> maybe I should have used something like ‚Äú1234‚Äù instead of x and x'
09:38:04 <jonaskoelker> :D
09:38:12 <nand`> since what I said is not always true, depending on x and x'..
09:38:30 <nand`> perhaps an addendum: if fromIntegral x == fromIntegral x'
09:39:23 <tobiassjosten> @src words
09:39:24 <lambdabot> words s = case dropWhile isSpace s of
09:39:24 <lambdabot>     "" -> []
09:39:24 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
09:39:39 <Eliel> nand`: would that have to evaluate x to figure out the whole thing evaluates to true?
09:39:58 <nand`> Eliel: which?
09:40:06 <Eliel> 18:36 < nand`> perhaps an addendum: if fromIntegral x == fromIntegral x'
09:40:14 <nand`> Eliel: presumably yes
09:40:23 <jonaskoelker> (depending on what fromIntegral does)
09:40:26 <rwbarton> barring an eccentric Num instance
09:40:44 <nand`> rwbarton: darn those eccentric/trivial instances ruining everybody's day
09:40:56 <rwbarton> well yeah, it wouldn't be that eccentric, just the zero ring
09:41:22 <nand`> maybe a num instance that isn't actually a ring
09:42:11 <nand`> s/fromIntegral x /x /
09:42:16 <nand`> fixed, now it's always Integer
09:42:25 <tobiassjosten> What's the deal with adding ' to functions?
09:42:37 <rwbarton> foo' = "like foo, but different"
09:42:44 <nand`> tobiassjosten: it's called ‚Äúprime‚Äù and used to denote things that are slightly different but not the same
09:42:57 <quicksilver> foldl' is stricter than foldl, for example
09:42:58 <rwbarton> often different in strictness properties
09:43:22 <nand`> or sometimes used as helper functions with slightly different type signatures
09:43:31 <tobiassjosten> I recognize it from math. But does defining a func' somehow inherit something from your func definition?
09:43:36 <nand`> no
09:43:49 <quicksilver> it's just a naming convention
09:43:49 <nand`> it's just a name
09:44:06 <tobiassjosten> Ahh, I see. Thanks! Been curious about it but it's hard to google for. :)
09:45:19 <jonaskoelker> I love the fact that haskell has a continued fractions library :-)
09:45:35 <nand`> which one is that?
09:47:37 <jonaskoelker> 's on hackage
09:47:42 <jonaskoelker> http://hackage.haskell.org/package/continued-fractions
09:47:45 <ski> rwbarton : "constant function" seems to mean that the image is a singleton. maybe one could call it subconstant or something when we only know the image is a subsingleton
09:50:49 <pejusify> does anybody know a C-channel, which is not invite only (like #c)? =)
09:51:19 <ski> have you tried ##c ?
09:51:32 <tromp_> how do you get invited there:-?
09:52:25 <pejusify> ##c? isn't that impossible? or is that a joke, i don't understand? ;)
09:53:02 * ski doesn't understand what pejusify doesn't understand
09:53:26 <path[l]> same
09:53:28 <pejusify> argh..
09:54:06 <ski> pejusify : why not just try typing `/join ##c', and see what happens ?
09:55:01 <pejusify> i did. colloquy tells me, that i need to identify with freenode.net to join ##c.
09:55:03 <osfameron> I was surprised by ##channels when I first came across them too
09:55:40 <path[l]> damn, I thought that was an actual channel. ##channels
09:56:28 <pejusify> so there is no c-channel!? wtf..
09:56:37 <tac-tics> Do people still use c?
09:56:40 <tac-tics>  /troll
09:56:40 <ski> afaics, ##c is not invite-only
09:56:45 <path[l]> there is. There is no ##channels channel
09:57:09 <pejusify> u r kdding me :/
09:57:10 <ski> pejusify : why not identify ?
09:58:10 <pejusify> ok, is ask in here: is it common that c compilers are giving u errors that make no sense? :D
09:58:46 <ski> #c has +i set (invite only); while ##c doesn't, though it does have +r, which i assume means that you have to be registered (and identified) to be ablt to talk (or maybe even to join)
09:59:35 <ski> pejusify : i think the quality of error messages could often be improved, yes
10:01:15 <jonaskoelker> pejusify: with time you learn to make sense of them :)
10:01:29 <pejusify> more precisely: i get a type mismatch error, which tells me, that a function which has an int as return type can't be compiled, because the compiler expected a boolean as return type!?
10:01:41 <jonaskoelker> e.g. "missing close paren at end of input" proooobably means you missed a paren somewhere in the middle of what you was just coding on
10:01:57 <jonaskoelker> o_O ?!
10:02:19 <OMGTallMonster> pejusify: But... C doesn't have booleans?
10:02:21 <jonaskoelker> is there something typedeffy going on in your context?
10:02:30 <pejusify> that's what i thought, too
10:02:31 <strager> @pl \c acc -> showCharLiteral c . acc
10:02:32 <lambdabot> (.) . showCharLiteral
10:02:32 <jonaskoelker> are you using stdbool.h? c99?
10:02:59 <pejusify> i'm using C0
10:03:05 <pejusify> so, no.
10:03:07 <jonaskoelker> C0?
10:03:23 <pejusify> yes, a small subset of C
10:03:23 <rainman1985> Hello, I'm having trouble proving some haskell functions using structural induction. I have the proof per se, but I can't get to prove the lemma which leads to the proof. Here's what I have so far. Refer to point b). https://www.dropbox.com/s/466cylt4j7nsgv7/haskell.pdf
10:03:42 <jonaskoelker> pejusify: with what compiler?
10:03:43 <rainman1985> It would be great if someone could help with the proof of the lemma
10:03:48 <pejusify> cc0
10:04:39 * jonaskoelker punts
10:05:49 <pejusify> what r u punting?
10:07:37 <rainman1985> Anybody?
10:09:14 * ski would prefer if the proof were given in plain text ..
10:11:26 <xraycat> rainman1985: why is it sumLisT(‚Ä¶)=sumList(‚Ä¶) and not ==?
10:12:25 <rainman1985> yes, it ought to be ==, it's a typo, sorry
10:15:27 <andrus> Is there a better way to effectively change `read` for String -> String than creating a Read' class? like https://gist.github.com/424083
10:15:52 <ski> xraycat : hehe, i would rather ask why it uses `==' rather than `=' ;)
10:16:22 <rainman1985> I just went with '==' since the literature I am using also uses that
10:18:53 <ski> andrus : why would you want that ?
10:20:15 <andrus> ski: i'm reading unquoted strings from xml nodes, so read "1" :: Int works fine but read "abc" :: String does not
10:21:54 <ski> maybe make a parser ?
10:22:14 <ski> anyway, having `String -> a' in there is noncompositional
10:22:42 <xraycat> rainman1985: is the lemma a haskell expression as well (and to be intepreted as one)?
10:23:02 * ski doesn't like the `input' as well
10:23:22 <andrus> ski: i was wondering if i could use OverlappingInstances to redefine read instance for String
10:23:56 <ski> andrus : better to make your own function
10:24:40 <rainman1985> It doesn't have to be interpreted by the Haskell interpreter, if that's what you mean...
10:25:04 <rainman1985> but the proof must follow the principle of structural induction...
10:26:15 <rainman1985> The proof must rely on the function definitions... it's pretty similar to induction in maths, except we are using data structures and functions here...
10:27:06 <rainman1985> But as far as the lemma goes, I cannot even reliably prove the basic case, that of the empty list
10:27:43 <rainman1985> I need to define a second lemma to prove the basic case, and I have no clue about the induction step.
10:28:23 <rainman1985> http://www.doc.ic.ac.uk/~jb/teaching/reasoning-about-programs/induction-4up.pdf
10:29:03 <rainman1985> The slides with the title "Induction: revList" should give an idea of how it works
10:29:04 <ski> the induction statements looks weird
10:29:06 <xraycat> yeah, I had to do some structural induction with algebras
10:30:23 <xraycat> rainman1985: my problem was (probably stupid) what yields [1,2,3] == [3,2,1]?
10:30:42 <rainman1985> not equal
10:30:46 <rainman1985> false
10:31:05 <xraycat> ok, as it would in haskell
10:31:29 <rainman1985> but sumList([1,2,3]) == sumList([3,2,1]) would yield true
10:32:01 <ski> i.e. "Prove `P(Link(a, LinkedList a))' must hold, if `P(LinkedList a))' also holds" looks weird
10:32:02 <xraycat> ah, missed the sumList, nevermind :o
10:32:34 <rainman1985> This is the induction step
10:32:40 <rainman1985> @ski.
10:32:40 <lambdabot> Unknown command, try @list
10:32:57 <ski> it should be saying something like "Prove `P(Link(a, ll))' must hold, if `P(ll))' also holds"
10:33:34 <rainman1985> okay, my formulation is confusing somehow, ill fix that
10:34:29 <ski> (or i suppose replacing `a' by `x', but more clarity)
10:35:22 <ski> (the `Link (a, LinkedList)' in the definition is merely a kind of template, with types in places of the argument values which should have those types)
10:36:07 <rainman1985> yes
10:36:14 <newsham> sumList([1,2,3]) == sumList([3,2,1])   should be pretty easy.. just "evaluate" each side and then use reflexivity when they're the same number
10:36:27 <newsham> sum a,b,c vs sum c,b,a would be harder
10:37:17 <ski> so, in part two, you should be assuming `sumList (asRevList ll) = sumLinkedList ll', and be trying to prove `sumList (asRevList (Link (x, ll))) = sumLinkedList (Link (x, ll))'
10:38:41 <ski> rainman1985 : do you see what i mean ?
10:38:48 <rainman1985> not really..
10:38:57 <rainman1985> the second part
10:38:59 <ski> you have said
10:39:19 <rainman1985> ah, yes
10:39:20 <newsham> you assume the property holds for list "ll" and then you try to prove it also holds for a slightly longer list with one additional element on the front
10:39:22 <rainman1985> I see what you mean..
10:39:24 <xraycat> newsham: the rest should be as "easy" with case differentiation
10:39:41 <rainman1985> yes
10:39:49 <rainman1985> thats the idea of structural induction..
10:40:09 <ski>   sumList (asRevList (Link (a, LinkedList a)))  == sumList (joinLists (asRevList (LinkedList a)) [a])  by [asRL.1]
10:40:13 <ski>                                                 == ...
10:40:18 <ski> this is nonsense, from the beginning
10:40:49 <ski> maybe you can see through the nonsense, interpreting it in the proper way -- but i doubt it
10:41:00 <rainman1985> "a" stands for the type
10:41:20 <ski> yes, and the type has no business appearing here inside values
10:42:02 <ski> it ought to start like
10:42:12 <ski>   sumList (asRevList (Link (x, ll)))  == sumList (joinLists (asRevList ll) [x])  by [asRL.1]
10:42:15 <ski>                                       == ...
10:42:31 <rainman1985> okay, and then?
10:42:35 <ski> `x' here is a value of type `a', and `ll' is a value of type `LinkedList a'
10:43:39 <rainman1985> yes
10:45:12 <ski> fixing this, what you've written looks ok
10:45:22 <ski> though you need to state a slightly more general lemma
10:46:21 <ski> (did you invent the lemma yourself, or was it suggested to you ?)
10:46:39 <rainman1985> I invented it myself
10:47:05 <ski> well, it looks true, so hopefully it should be provably
10:47:22 <rainman1985> it makes sense, but Im having a hard time proving it
10:47:35 <ski> i would try to reduce it to commutativity of addition
10:48:22 <ski> (btw, do you see how you need to generalize the lemma ?)
10:48:39 <rainman1985> No
10:48:44 <rainman1985> Generalize?
10:49:18 <ski> you've stated it like
10:50:02 <ski>   sumList (joinLists (x:xs) (y:ys))  =  sumList (joinLists (y:ys) (x:xs))
10:50:18 <rainman1985> yes
10:50:22 <ski> but in this form you can't apply it as a step in the proof of the main result
10:50:40 <ski> (hint : `ll' is not of the shape `x:xs')
10:51:21 <rainman1985> asRevLists returns a list...
10:51:26 <rainman1985> asRevList*
10:51:37 <ski> oh, right, `asRevList ll'
10:51:47 <ski> but you still can't be sure that this is a non-empty list
10:52:02 <ski> `x:xs' only matches non-empty lists
10:52:19 <rainman1985> That is correct, I thought of doing a case-by-case analysis on that at first
10:52:30 <ski> that could be possible
10:52:44 <ski> but in this case there's a much easier solution (generalizing the lemma)
10:53:24 <rainman1985> I still don't understand what you mean by "generalizing the lemma2, sorry.
10:53:27 <rainman1985> lemma*
10:53:30 <ski> why should the lemma only talk about non-empty lists ?
10:53:31 <rainman1985> lemma"*
10:53:38 <ski> wouldn't the statement hold for empty lists as well ?
10:53:43 <rainman1985> It would
10:53:51 <rainman1985> nevermind, I got it
10:53:52 <rainman1985> :)
10:54:49 <ski> anyway, i would suggest proving the lemma by splitting it into two symmetric parts
10:55:26 <ski> in the middle you'd have an expression with two calls to `sumList'
10:55:27 <_Mikey> Hi guys,
10:55:45 <ski> lo _Mikey
10:55:58 <_Mikey> I'd just like to say thanks for all the help and knowledge you provided me with over the last 9 months
10:56:05 <rainman1985> I dont see how it needs generalization though, asRevList and sumList take care of all the cases
10:56:21 <ski> _Mikey : on behalf of the channel, yw :)
10:56:30 <_Mikey> I handed in my dissertation a couple weeks ago so I'm technically free of the obligation to code in Haskell b
10:56:41 <_Mikey> ut I enjoy it so you'll still be seeing me ;)
10:56:41 <rainman1985> the lemma holds true in any case
10:56:51 <ski> @where HBC
10:56:52 <lambdabot> The Chalmers Haskell-B Compiler by Lennart Augustsson (augustss) at (darcs get) <http://www.cse.unsw.edu.au/~dons/code/hbc>,<http://darcs.augustsson.net/Darcs/hbc> -- Alternatively, the Hierarchical
10:56:52 <lambdabot> Bayes Compiler <http://www.cs.utah.edu/~hal/HBC/>
10:58:38 <ski> rainman1985 : you want to go from `sumList (joinLists (asRevList ll) [x])' to `sumList (joinLists [x] (asRevList ll))'
10:58:57 <ski> rainman1985 : and `[x]' is really just sugar for `x:[]', so it matches the `y:ys' in the lemma
10:58:58 <rainman1985> Yes
10:59:11 <ski> but `asRevList ll' doesn't match the `x:xs' in the lemma
10:59:31 <ski> meaning that you can't apply the lemma (as currently formulated) here
11:02:51 <rainman1985> Maybe I've been sitting around this problem for too long, but I still can't see what you are trying to say.
11:03:39 <ski> well, i'm trying to not give away the whole answer :)
11:03:45 <rainman1985> data LinkedList a = End | Link (a, LinkedList a)
11:03:51 <rainman1985> so either End or Link
11:04:24 <rainman1985> would work for asRevList
11:04:47 <ski> i'm not sure what you mean here
11:05:03 <rainman1985> nevermind..
11:05:09 <ski> `asRevList' returns something of type `[a]', not something of type `LinkedList a'
11:05:19 <rainman1985> Yes
11:05:43 <rainman1985> quoting: "<ski> but `asRevList ll' doesn't match the `x:xs' in the lemma"
11:05:50 <rainman1985> I was trying to make sense of this..
11:05:53 <ski> yes
11:06:03 <ski> e.g. `asRevList ll' might be the empty list
11:06:41 <rainman1985> Why would that be a problem?
11:06:56 <rainman1985> joinLists would still handle it..
11:07:09 <ski> because `x:xs' in `sumList (joinLists (x:xs) (y:ys))  =  ...' is not an empty list
11:07:37 <ski> the lemma says that if you join two *non-empty* lists, and then sum the elements, it doesn't matter in which order you join the lists
11:07:39 <rainman1985> Ah
11:07:40 <rainman1985> I get it now
11:07:49 <rainman1985> yes
11:08:03 <hsimon> good evening. I have a question about parsec
11:08:08 <ski> but since `asRevList ll' could be an empty list, that case isn't handled by the lemma
11:08:17 <rainman1985> yes, that's perfectly valid.
11:08:19 <hsimon> I'm trying to extract a substring where what comes before can be arbitrary
11:08:25 <hsimon> so far i have this:
11:08:26 <ski> rainman1985 : my suggestion here is to *make* this case also being handled by the lemma
11:08:32 <hsimon> do { manyTill anychar (lookAhead pattern); pattern }
11:08:42 <hsimon> but it seems awfully complicated
11:08:53 <ski> i.e. change the lemma to handle all (finite, defined) lists, not just non-empty ones
11:08:54 <rainman1985> sumList(joinLists [x] [y]) == sumList( joinLists [y] [x])
11:09:00 <hsimon> isn't there like a non-greedy "many"?
11:09:16 <ski> rainman1985 : that only handles lists of length one -- hardly an improvement
11:09:27 <rainman1985> ouch
11:09:56 <rainman1985> sumList(joinLists x y) == sumList(joinLists y x)
11:10:08 <ski> yes, that's fine
11:10:11 <rainman1985> where x,y of type [a]
11:10:11 <xraycat> couldn't you just drop the sumList as well?
11:10:13 <rainman1985> okay
11:10:19 <ski> though i would now rename `x' and `y' to `xs' and `ys' :)
11:10:25 <rainman1985> yes
11:10:31 <ski> (just for the benefit of the reader)
11:10:46 <rainman1985> but this still doesnt prove the lemma though
11:10:54 <xraycat> (argh, same mistake)
11:11:02 <ski> xraycat : no, list concatenation isn't commutative
11:11:25 <xraycat> yeah, missed it again, I better shut up :-)
11:11:32 <rainman1985> I admit I screwed up with the syntax, I had too much reading for one day.
11:12:31 <ski> rainman1985 : i hope you don't mind me being a bit stern on the syntax issue -- if you confuse the syntax, i think it's too easy to forget what you really meant
11:12:54 <ski> (too easy for yourself to forget that, i mean)
11:13:00 <rainman1985> Yes
11:13:45 <ski> > sum ([2,3,5] ++ [7,11])
11:13:46 <lambdabot>   28
11:14:04 <ski> > sum ([7,11] ++ [2,3,5])
11:14:06 <lambdabot>   28
11:14:12 <ski> > sum [2,3,5] + sum [7,11]
11:14:13 <lambdabot>   28
11:14:22 <rainman1985> :)
11:14:41 * ski hopes that gives some kind of usable hint
11:15:10 <rainman1985> I understand the hint, the addition operation is commutative, but I don't see how I can use it
11:15:32 <nejucomo> I just defined: ffmap = fmap . fmap ‚Äî then I started to wonder if there couldn't be a Functor instance‚Ä¶  Is it possible?
11:15:43 <nejucomo> I can't figure out a valid instance head.
11:15:50 <nejucomo> :t fmap . fmap
11:15:51 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
11:16:02 <ski> i think the lemma could be proved fully by a reference to a slightly simpler lemma, used *twice* (and also using commutativity of addition)
11:16:16 <nejucomo> Oh well.  I'll stick with fmap . fmap for now.
11:16:32 <rainman1985> ski: is that another hint?
11:16:33 <rainman1985> :)
11:16:41 <ski> maybe :)
11:17:30 <ski> rainman1985 : note that i have no idea if this is the simplest way to prove what you want to prove or not ..
11:17:46 <ski> it feels like it could work, though
11:17:48 <rainman1985> I know, but as long as it proves it
11:18:02 <ski> (though maybe you need to prove one or two more lemmas as well)
11:18:23 <rainman1985> As I said, I was able to prove the basic case (where either xs or ys is []) by introducing another lemma
11:18:47 <rainman1985> but I had no clue for the induction step, so that I decided to ask here
11:18:47 <ski> *nod*, as soon as it eventually ends somewhere
11:20:27 <khayyim> Is this the appropriate channel for noob questions apropos Haskell?
11:20:32 <ski> yes !
11:20:41 <khayyim> Most excellent. Thanks.
11:20:59 <ski> have you already found a tutorial or book ?
11:21:25 <khayyim> I'm at the I/O section of Real World Haskell.
11:21:41 <solidus-river> is htere any performance bonus to function composition as opposed to letting the functions evaluate and input into another, or is purely for mapping / filter etc of the composition of two or more functions over data more easily
11:22:17 <solidus-river> i guess my question is on the compiler level does it actually take the two functions and make a brand new 3rd out of it, or does it take the two functions and keep them stored as logic in a third function
11:22:30 <kallisti> there can be performance benefits. For example, there DList data structure allows O(1) concatenation via function composition
11:22:34 <ski> solidus-river : what's the difference ?
11:22:44 <solidus-river> ski: thats my question
11:22:48 <solidus-river> ski: is there a difference :P
11:23:03 <solidus-river> ski: aside from readability
11:23:12 <kallisti> there can be, but with optimization, typically not.
11:23:27 <ski> `f . g' is basically the same as `\x -> f (g x)'
11:23:32 <kallisti> yes
11:23:59 <ski> in case `f' and `g' are replaced with larger expressions, those might be evaluated only once in the former case, but each time the function is called in the latter case
11:24:26 <rainman1985> ski: the base case only takes me here: sumList(joinLists [] ys) == sumList(ys)
11:24:42 <newsham> ski: but what of rewrite rules?
11:24:42 <hsimon> anyone got an idea how to do this? (question about parsec from before) Basically I'd like a "manyTill" that returns the end token instead.
11:24:44 <ski> (this doesn't apply in the case where you bind `f' and `g' to those large expressions)
11:25:10 <newsham> are there rewrite rules that operate on f.g that dont operateo on \x -> f (g x) ?
11:25:18 <khayyim> What is a good starter project for Haskell? In my short programming experience, for example, stuff like magic 8 ball and Drug Wars clones helped me understand imperative stuff like BASIC. RWH has shown me a few examples, but it look like it will be a while before it gets to a "real" program.
11:25:23 <kallisti> solidus-river: but DLists performance benefits aren't really because composition is more efficient that application. It simply defers execution of concatenation so that it can build up a chain of conses.
11:25:50 <hpc> khayyim: try writing an IRC bot
11:25:50 <kallisti> then converting to a list applies all of the conses
11:26:19 <hpc> khayyim: if you are creative enough to come up with cool commands for it, that can keep you learning constantly for at least three months
11:26:36 <hpc> easily
11:26:39 <newsham> khayyim: for early stuff, things that read in text and do things with them are easy enough
11:26:44 <khayyim> hpc, thanks, I hadn't thought of that.
11:26:58 <ski> rainman1985 : base case of the lemma?
11:27:01 <newsham> like capitalizing all the words, or reversing the words on a line, etc
11:27:22 <afarmer> nejucomo: I think you'd need some kind of type level composition... http://pastebin.com/EeMBMn98
11:27:24 <mauke> The paste EeMBMn98 has been copied to http://hpaste.org/68636
11:27:24 <khayyim> newsham, Hrm, yes, I may be looking too far ahead at the moment. Good points.
11:27:52 <newsham> small helpers for work you might have to do, like reading in some text file and suming the numbers in it
11:27:53 <afarmer> nejucomo: not really convenient though
11:29:11 <rainman1985> ski: Yes
11:29:12 <newsham> if you like graphics, make some turtle art in haskell :)
11:29:33 <ski> rainman1985 : well, i was thinking of *not* proving the lemma via induction ..
11:30:01 <rainman1985> hm, how else could you prove it?
11:30:37 <ski> <ski> i think the lemma could be proved fully by a reference to a slightly simpler lemma, used *twice* (and also using commutativity of addition)
11:30:49 <rainman1985> I think that was somehow implied by the exercise, since in a)i) it requires me to state the Principle of Structural Induction for [a].
11:31:05 <rainman1985> okay
11:31:07 <ski> yes, you surely need to use induction at least once
11:31:18 <ski> but not necessarily in all the sub-results
11:31:33 <ski> anyway, there are probably many solutions here
11:31:34 <rainman1985> What would be the simpler lemma?
11:31:44 <ski> you don't have to do it my way :)
11:31:56 <ski> i was hoping you could figure out that
11:31:57 <rainman1985> If I had "my way" I wouldnt be asking here
11:32:02 <ski> (i gave a hint for it a bit up)
11:32:23 <ski> (.. involving lambdabot)
11:33:14 <newsham> how about:    last(xs) + sum(allbutlast(xs)) = head(reverse(xs)) + sum(tail(reverse(xs)) ?
11:33:30 <newsham> too much pain?
11:33:38 <kallisti> that proof has slow execution time
11:34:30 <rainman1985> sumList(joinLists xs ys) = sumList xs + sumList ys
11:34:30 <ski> we need more efficient proofs !
11:34:45 <ski> rainman1985 : looks promising, yes ?
11:35:57 <rainman1985> Okay, I get your idea, clever :)
11:36:03 <rainman1985> Thank you
11:36:26 <rainman1985> So this would be the lemma which needs proof
11:36:29 <ski> this lemma is one part of a proof that `sumList' is a monoid homomorphism
11:37:24 <rainman1985> sumList(joinLists xs ys) == sumList xs + sumList ys == sumList ys + sumList xs == sumList(joinLists(ys xs))
11:37:42 <ski> nice eh :)
11:37:53 <ski> (except s/(ys xs)/ys xs/)
11:38:42 <rainman1985> Let's see if I'll be able to prove this one..
11:44:08 <rainman1985> ski: it worked like a charm.
11:44:16 <rainman1985> Thank you so much
11:44:20 <ski> (: yw
11:56:46 <krakrjak> I'm having a little trouble with a simple program I wrote that hunts NULL bytes in files.
11:57:09 <krakrjak> It's really slow when parsing very large files.  I suspsect it's the use of lines that's causing the problem.
11:57:13 <krakrjak> Can someone take a look?
11:57:18 <hpaste> krakrjak pasted ‚Äúnullfinder‚Äù at http://hpaste.org/68639
11:57:47 <solidus-river> interesting performance question
11:58:16 <S11001001> krakrjak: perhaps you should try stream-stream? *plug*
11:58:43 <krakrjak> maybe...  I figured this would be really easy just using the basics...
11:58:59 <S11001001> sorry, totally wrong channel
11:58:59 <hpc> krakrjak: you know that you are checking for "\n\NUL\n", right?
11:59:05 <S11001001> ugh
11:59:12 <hpc> you split it into lines, then check to see if any of the lines are "\NUL"
11:59:35 <krakrjak> hpc: no... didn't know that.  If finds NULLs just fine...
11:59:53 <solidus-river> would it be faster to remove duplicates from a list using nub, or using nub' xs = (transpose . group) xs !! 0
12:00:02 <krakrjak> hpc: really?  I thought elem would check for \NUL in any of the lines.
12:00:06 <ziman> also, I'd definitely go with bytestrings
12:00:25 <hpc> krakrjak: replace "\NUL" with '\NUL', and (lines contents) with contents
12:00:38 <hpc> and fix the type of checkForNulls
12:00:44 <hpc> and it should be nice and quick
12:00:58 <ziman> solidus-river, the two behave differently
12:01:02 <ziman> > nub "aba"
12:01:03 <lambdabot>   "ab"
12:01:08 <krakrjak> hpc: that gives moon language.
12:01:12 <ziman> > (transpose . group) "aba" !! 0
12:01:14 <lambdabot>   "aba"
12:01:22 <krakrjak> checkForNulls takes [String] not String
12:01:26 <hpc> > '\NUL' `elem` "abcdefg"
12:01:27 <lambdabot>   False
12:01:39 <hpc> change the type to String -> Bool
12:01:56 <hpc> you're looking for the null Char in a [Char]
12:02:01 <hpc> [Char] = String
12:02:37 <krakrjak> hpc: thank you.  So the whole time (and I had to add lines in later) I was doing it wrong by having \NUL in "" instead of ''?
12:02:56 <rwbarton> yes
12:03:04 <krakrjak> ok.  good to know.
12:03:06 <rwbarton> you don't need 'lines' at all, do you?
12:03:09 <ski> > '\0'
12:03:10 <lambdabot>   '\NUL'
12:03:13 <rwbarton> i see hpc already said this
12:03:14 <rwbarton> okay
12:03:14 <krakrjak> I was wondering why `elem` was freaking out
12:03:23 <hpaste> hpc annotated ‚Äúnullfinder‚Äù with ‚Äúnullfinder (annotation)‚Äù at http://hpaste.org/68639#a68640
12:03:34 <hpc> that should work
12:03:37 <ski> > '\^@'
12:03:38 <lambdabot>   '\NUL'
12:03:50 <hpc> ski: o.O
12:04:00 <hpc> > '\^C'
12:04:00 <lambdabot>   '\ETX'
12:04:07 <hpc> > map chr [0..]
12:04:07 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
12:04:08 <rwbarton> i was about to say technically you can't have null bytes in the middle of unicode characters, but even more technically you are actually correct!
12:04:09 <ski> > '\^?'
12:04:11 <lambdabot>   <no location info>:
12:04:11 <lambdabot>      lexical error in string/character literal at chara...
12:04:17 <hpc> oh, that's cool
12:04:18 <ski> ):
12:04:26 <krakrjak> hpc: thanks for the annotation.  This isn't meant to work correctly on Unicode files.
12:04:41 <hpc> > '\^
12:04:42 <lambdabot>   <no location info>:
12:04:42 <lambdabot>      unexpected end-of-file in string/character literal...
12:04:43 <hpc> er
12:04:44 <krakrjak> hpc: I had a very specific need and haskell came to my rescue again!
12:04:45 <ski> > '\BEL'
12:04:46 <hpc> > '\^J'
12:04:46 <lambdabot>   '\a'
12:04:47 <lambdabot>   can't find file: L.hs
12:04:47 <krakrjak> Thanks for the help!
12:05:32 <OMGTallMonster> http://imgur.com/6JugH
12:05:46 <arcatan> huh
12:05:50 <OMGTallMonster> Recursion is beautiful. :)
12:07:04 <solidus-river> is it fairly easy in haskell to write a permutation generator for a list?
12:07:17 <krakrjak> ok.  This is much better than before.  Still very slow.  The C++ version can complete in about 8-10 seconds on a large file.  This new version without the lines call is MUCH better, but runs in about 1 minute 20 seconds.
12:07:31 <krakrjak> Where can I look next to whiddle the time down?
12:07:31 <hpc> > let perms = filterM (const [True, False]) in perms "abc"
12:07:31 <ski> solidus-river : generating all permutations ? -- yes
12:07:32 <lambdabot>   ["abc","ab","ac","a","bc","b","c",""]
12:07:38 <hpc> oh wait, that's powerset
12:07:44 <rwbarton> krakrjak: yes, string processing with String will be slow
12:07:48 <rwbarton> krakrjak: are you compiling with -O2 ?
12:07:57 <krakrjak> rwbargon: I can try that.
12:08:05 <hpc> you can get permutations from that though
12:08:10 <hpc> not efficiently, but easily
12:08:25 <hpc> i think
12:08:27 * ski imagines hpc pondering `sortByM'
12:08:31 <rwbarton> solidus-river: do you specifically want to write it yourself? because...
12:08:34 <rwbarton> > permutations "abc"
12:08:36 <lambdabot>   ["abc","bac","cba","bca","cab","acb"]
12:08:49 <krakrjak> rwbarton: is there a better place to do this?  Like in ByteString or somesuch?
12:08:53 <hpc> ski: oh crap, i keep forgetting what "permutation" is...
12:08:59 <rwbarton> krakrjak, yes
12:09:02 <hpc> sortByM would be... quite strange
12:09:47 <rwbarton> krakrjak: if you care about your program's performance, always compile with -O2, though I don't know how much it will help in this particular instance
12:10:33 <hpc> krakrjak: if you import the lazy bytestring module, i think your code will work fine, with minimal modification
12:10:47 <ski> solidus-river : for more fun, generate an infinite list of all permutation with finite support
12:10:57 <hpc> you just have to replace '\NUL' with 0, and do some qualified imports
12:10:59 <hpc> and you're set
12:11:15 <rwbarton> and replace some foo by B.foo, yep should be easy
12:11:36 <krakrjak> twbarton: didn't change in this I/O bound job.  In fact -O2 made it a second and a half slower (not significant).
12:11:54 <krakrjak> hpc: thanks for the tip!
12:13:20 <guddu_> guddu
12:13:42 <ski> ski_
12:14:05 <guddu_> recusive definition for a mul
12:14:16 <guddu_> using inc add and dec
12:15:09 <guddu_> mul n 0 = 0 >mul n 1 = n >mul n m = (mul (add n 1) (dec m))
12:16:08 <ski> the last clause seems strange
12:16:23 <solidus-river> rwbarton: haha, yeah, i just want to practice writing something in haskell
12:16:29 <solidus-river> although its cool that theres built in permutations
12:16:43 <ski> @index permutations
12:16:43 <lambdabot> bzzt
12:16:48 <ski> @hoogle permutations
12:16:49 <lambdabot> Data.List permutations :: [a] -> [[a]]
12:16:49 <lambdabot> package action-permutations
12:17:31 <guddu_> do u have idea of mul recursion
12:17:45 <guddu_> i can only use mul add and inc
12:18:34 <ski>   3 * 5  =  3 * (4 + 1)  =  3 * 4 + 3 * 1  =  3 * 4 + 3
12:18:55 <tmp-name> Does the cabal build system make some checks when rebuilding, in order to only compile the new files, or is this handled by ghc?
12:20:09 <tmp-name> there is a GHC flag: -fforce-recomp
12:21:06 <dcoutts_> tmp-name: cabal delegates that to ghc --make
12:21:22 <tmp-name> ok. thanks!
12:27:22 <rainman1985> Hi again, to anyone that is listening..., I still have a question regarding another exercise I am supposed to solve. Exercise 3 in this link: https://www.dropbox.com/s/zp8gugdj45t4kjq/haskell.pdf . I managed to determine the inferred variable types and function signatures myself, but I'm still unsure which of the there defined inferrence rules apply.
12:28:04 <rainman1985> That's what I have so far: x of type Strung
12:28:05 <rainman1985> asNum :: String->Num
12:28:05 <rainman1985> repeater :: Num->String->[String]
12:28:05 <rainman1985> repeatAsNum:: String->[Num]
12:28:11 <rainman1985> String*
12:28:15 <ski> `Num' is not a type
12:28:46 <guddu_> Define the infinite stream of odds using intStream  and filter.
12:28:58 <guddu_> i have no idea what these are
12:29:01 <hpaste> timthelion pasted ‚ÄúDoes this diff help me?‚Äù at http://hpaste.org/68643
12:29:06 <guddu_> totally new to haskel
12:29:06 <rainman1985> its a class
12:29:18 <timthelion> Hello, I'd like some pointers as to why I'm getting a stack overflow.
12:29:35 <ski> rainman1985 : yeah, so `[Num]' is nonsense
12:29:36 <timthelion> I have a working version(from before the diff that I just posted)
12:29:41 <rainman1985> What type is inferred in that case?
12:29:47 <rainman1985> Int?
12:29:51 <timthelion> I cannot find anything in the diff though that would cause such an overflow:(
12:30:37 <ski> rainman1985 : a type variable, i think
12:30:45 <gdoteof> how can i arbitrarily format a UTC Time to get something like (Decemeber 12th, 2001 14:33)
12:31:01 <Clint> gdoteof: use Data.Time.Format
12:31:21 <ski> rainman1985 : hm
12:32:03 <ski> hm, yes
12:32:23 <rainman1985> I also cannot find anywhere any documentation or reading material about haskell's type inferrence rules
12:32:30 <ski> guddu_ : presumably `intStream' is given to you ?
12:32:46 <rainman1985> And the ones there are on the Appendix, I cannot understand that well.
12:34:40 <ski> you could start by assuming
12:34:46 <ski>   x :: _a
12:35:03 <ski> where `_a' stands for some, as yet unknown, type
12:35:07 <rainman1985> yes
12:35:12 <krakrjak> what am I missing about using '\NUL' `LB.elem` x ?  Seems like the '\NUL' is not appreciated or tolerated in this method.
12:35:16 <rainman1985> that's how I got the signatures I showed...
12:35:39 <ski> note that `x :: _a' can be seen as short for `x :: () => _a'
12:35:50 <rainman1985> but I yet don't know how and where the listed type-inference rules are applied
12:35:58 <timthelion> no one knows how I might solve this?  The only hint I got so far is that GC is taking 70% of the time...
12:35:58 <ski> then you have
12:36:02 <Clint> krakrjak: what's the type signature of LB.elem?
12:36:20 <ski>   asNum :: (Read a,Num a) => String -> a
12:36:46 <rainman1985> Yes, so from there, I infer that x :: String
12:36:48 <rainman1985> correct?
12:36:59 <krakrjak> elem :: Word8 -> ByteString -> Bool
12:37:02 <ski> for each use of a polymorphic operation like this, it is best to use type instantiation, replacing the type variables with fresh ones
12:37:04 <ski> i.e.
12:37:05 <Clint> krakrjak: and what's the type of '\NUL'?
12:37:16 <ski>   asNum :: (Read _b,Num _b) => String -> _b
12:37:26 <krakrjak> Clint: Char
12:37:27 <ski> now we consider `asNum x'
12:37:31 <Clint> krakrjak: so there's your problem
12:37:41 <krakrjak> Clint: is Char not a Word8?
12:37:45 <Clint> it is not
12:37:48 <krakrjak> ok
12:37:50 <Clint> you'll need to convert it
12:38:02 <rwbarton> in this case you may as well "convert" it by hand
12:38:11 <ski> according to the rule for function application, `_a', the type of `x', must be the same as the argument type of `asNum'
12:38:22 <rwbarton> Word8 is a numeric type so you can just write 0
12:38:25 <ski> i.e. we need `_a = String' in this case
12:38:35 <ski> and then we get
12:38:43 <ski>   asNum x :: (Read _b,Num _b) => _b
12:38:49 <krakrjak> rwbarton: duh!!!  Thanks again.
12:39:12 <ski> rainman1985 : following ?
12:39:26 <rainman1985> I didnt understand the "asNum x :: (Read _b,Num _b) => _b" bit
12:39:43 <rainman1985> what happened to String -> a?
12:39:56 <ski> this is an instance of `f e :: (Cons_f,Cons_e) => tau', in the conclusion of the rule for function application
12:40:09 <krakrjak> YAY!!!  That's even faster than the C++ code now!
12:40:14 <ski> `sigma' corresponds to `String' and `tau' to `_b'
12:40:19 <rainman1985> ski: I get it now
12:40:20 <rainman1985> sorry
12:40:42 <ski> rainman1985 : but note that we can't forget the equation `_a = String' which must hold for this to work
12:40:53 <hpaste> krakrjak annotated ‚Äúnullfinder‚Äù with ‚Äúnullfinder (Lazy ByteString Version)‚Äù at http://hpaste.org/68639#a68644
12:41:14 <ski> in this case, this is such a simple equation, so we can just replace `_a' everywhere (i.e. in `x :: _a') with `String', and then forget about `_a'
12:41:30 <rainman1985> okay
12:41:33 <ski> but we could also have waited 'til the end until looking at `_a = String'
12:41:44 <ski> next, we have a call to
12:41:53 <ski>   repeater :: Num b => b -> a -> [a]
12:41:59 <ski> first, we rename as before
12:42:09 <ski>   repeater :: Num _c => _c -> _d -> [_d]
12:42:18 <rainman1985> yes
12:42:20 <ski> then we consider `repeater (asNum x)'
12:42:32 <rainman1985> Function application again?
12:42:39 <ski> what is the type that we get for this expression, and do we get any equations here as well ?
12:42:48 <ski> yes, this is a function application expression
12:43:24 <ski> (the expression `repeater' is applied to the expression `asNum x')
12:43:43 <rainman1985> Did we define a variable for the return type of 'asNum'?
12:44:07 <ski> <ski>   asNum x :: (Read _b,Num _b) => _b
12:44:13 <rainman1985> Yes
12:44:30 <ski> we got a type for *this* application of `asNum' to an argument
12:44:48 <ski> (and the type here happened to be a type variable, though we also got a couple of class constraints)
12:44:52 <rainman1985> then we have _c = _b, _d = String
12:45:37 <ski> hehe, you're taking two steps at once here :)
12:45:40 <ski> but yes
12:45:46 <rainman1985> what did I forget..?
12:45:57 <ski> you didn't forget anything
12:46:18 <ski> only i asked about `repeater (asNum x)', but you answered basically for `repeater (asNum x) x'
12:46:45 <gdoteof> Clint: thanks.  how about UTCTime to in-a-specific-timezone?
12:47:18 <Clint> @hoogle UTCTime -> LocalTime
12:47:18 <ski> well, you did forget to say the inferred type for this application
12:47:19 <lambdabot> Data.Time.LocalTime utcToLocalTime :: TimeZone -> UTCTime -> LocalTime
12:47:19 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
12:47:19 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
12:47:46 <rainman1985> 'repeater (asNum x)' :: [_b]
12:48:00 <ski> no
12:48:22 <rainman1985> 'repeater (asNum x)' :: Num b => [_b]
12:48:39 <ski> closer, but no
12:49:30 <solidus-river> so what does haskell do to avoid a runtime error if it gets Nothing?
12:49:38 <ski> (if you're confused by taking many steps at once, then i suggest you don't)
12:49:43 <solidus-river> does it just stop the execution of that path of functions?
12:49:59 <solidus-river> i dont see how using Maybe <type> is better than saying it should return a type and getting a runtime error
12:50:01 <ski> solidus-river : `Nothing' is a value like any other value, no need to stop anything
12:50:18 <hpc> solidus-river: have you ever written code like
12:50:21 <hpc> foo = bar();
12:50:25 <solidus-river> but then functions further up the line wouldn't necissarily know how to deal with nothing, right?
12:50:29 <hpc> if foo == null, return;
12:50:30 <rainman1985> I need to step back a little, write your first explanations down, process them, and I'll have a better grasp.
12:50:37 <hpc> quux = schnoz(); ...
12:50:44 <solidus-river> or does nothing just return null equivalent of whatever type the next function expects as input?
12:50:51 <rwbarton> solidus-river, they do necessarily know how to deal with nothing
12:50:55 <ski> solidus-river : well, by the types, they either must deal with it, or pass the buck on, so to speak
12:50:58 <rwbarton> the type system ensures this
12:51:07 <hpc> solidus-river: the way it stops computing after Nothing is roughly the same as that conditional in the middle
12:51:09 <ski> solidus-river : there is no `null'
12:51:15 <hpc> @src Maybe (>>=)
12:51:15 <lambdabot> (Just x) >>= k      = k x
12:51:15 <lambdabot> Nothing  >>= _      = Nothing
12:51:16 <lucian> solidus-river: in haskell you must always explicitly handle both the Just a and Nothing cases
12:51:19 <solidus-river> ah, so if you use a Maybe all other functions interacting with that should be able to deal with the case of Nothing
12:51:38 <lucian> solidus-river: and this is enforced at compile time
12:51:46 <rwbarton> if a function returns a Maybe x, you can only pass its result to something that expects a Maybe x...
12:52:00 <solidus-river> ah, so you dont have to specify it in the function types but you just have to have a case to handle it
12:52:03 <hpc> solidus-river: in other words, the power of Maybe is not that you can have null values, but that *nothing else can*
12:52:05 <ski> lucian : could be implicitly, by helper functions
12:52:07 <solidus-river> is there an implicit handler that is attached if you dont specify one?
12:52:24 <lucian> ski: sure, but it's still explicit somewhere
12:52:29 * ski nods
12:52:44 <ski> solidus-river : no implicit handlers
12:52:46 <rwbarton> solidus-river: does a type error at compile time count? :)
12:52:46 <solidus-river> whats the implicit handler for Nothing and Just a do on onothing
12:52:53 <solidus-river> lol
12:52:56 <rwbarton> seriously
12:52:58 <solidus-river> kk
12:53:09 <rwbarton> there is very little implicit anything in general
12:53:20 <lucian> if something returns Maybe a you must unpack it from there, handling both Just a and Nothing
12:53:24 <solidus-river> well, I'm confused because I've been writing my own functions and loading them with GHCi in this tutorial
12:53:30 <solidus-river> and its never griped about not daeling with just or nothing
12:53:37 <shurikas> I am looking for a similar function to map, but I also need an index of element to which a function is applied
12:53:37 <ski> solidus-river : if you get something of type `Maybe Int', then you can't treat it as something of type `Int', period
12:53:57 <shurikas> @hoogle ((a, Int) -> b) -> [a] -> [b]
12:53:57 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
12:53:57 <lambdabot> Data.Tuple curry :: ((a, b) -> c) -> a -> b -> c
12:53:57 <lambdabot> Data.Generics.Aliases ext2Q :: (Data d, Typeable2 t) => (d -> q) -> (forall d1 d2. (Data d1, Data d2) => t d1 d2 -> q) -> d -> q
12:54:02 <shurikas> something like that
12:54:17 <rwbarton> zipWith f xs [0..]
12:54:20 <lucian> solidus-river: it didn't gripe, it just printed Just 5 for you, or something, which is different from 5
12:54:24 <shurikas> oh, thanks
12:54:24 <solidus-river> ski: so how to I insert a handler for Nothing in a function i define?
12:54:37 <ski> solidus-river : you pattern-match
12:54:43 <solidus-river> so
12:54:48 <solidus-river> function <nothing> = []
12:54:50 <solidus-river> or somethign like that
12:54:51 <solidus-river> ?
12:54:54 <ski> e.g. yes
12:54:59 <solidus-river> sorry, function Nothing = []
12:55:03 <ski> or
12:55:10 <ski>   foo x = case blah x of
12:55:14 <ski>     Nothing -> ...
12:55:21 <ski>     Just y  -> ..y..
12:55:27 <solidus-river> kk, well thats the first huge logical gap I've found in this tutorial, up to this point its been really good (learnyouahaskell)
12:55:59 <solidus-river> but you don't need to state a handler for Just y, right? and handling Nothing doesnt necissarily change the type of the function?
12:56:19 <ski> you need to handle both `Nothing' and `Just y'
12:56:25 <solidus-river> or do you have to specify Maybe Int -> Maybe Int everywhere
12:56:35 <solidus-river> er, Maybe a => a -> a
12:56:36 <ski> usually you don't need to do that, no
12:56:37 <rwbarton> there is no "state a handler"
12:56:40 <rwbarton> nothing magical about Maybe
12:56:58 <rwbarton> you just receive a Maybe Int value and pattern match on it or do whatever you like and return whatever you like
12:57:05 <ski> a `Maybe Int' is just a container that contains at most one `Int' value
12:57:27 <rwbarton> pattern matching like ski showed with the case expression is the most basic way to consume a Maybe Int value
12:57:38 <tac-tics> most basic and bestest way
12:57:52 <tac-tics> @type fromJust
12:57:53 <lambdabot> forall a. Maybe a -> a
12:57:58 <tac-tics> > fromJust (Just 3)
12:57:58 <lambdabot>   3
12:58:03 <tac-tics> > fromJust Nothing
12:58:04 <lambdabot>   *Exception: Maybe.fromJust: Nothing
12:58:07 <ski> solidus-river : if the function wouldn't benefit from you passing a `Maybe Int' rather than an `Int' to it, then you'd just pass an `Int' (and if you have a `Maybe Int' you check if there's an `Int' there *before* calling the function)
12:58:10 <tac-tics> Don't let exceptions happen to yoU!
12:58:58 <ski> solidus-river : iow, saying `foo :: Maybe Blah -> ...' isn't very common
12:59:13 <ski> sometimes you'll see it for "optional" arguments
13:00:39 <lucian> and if you match a Nothing, you could decide something based on that, like showing an error message
13:00:51 <ski> or supplying a default value
13:01:13 <ski> solidus-river : if you have any code you're pondering, you're welcome to show it
13:02:17 <solidus-river> http://www.pastie.org/3927119
13:02:37 <solidus-river> ski: so declairing Maybe v in the function type is just a nice thing to do and not required to use nothing or just?
13:02:59 <solidus-river> or if i declair findKey like that I dont need to handle Maybe Int etc in its input type?
13:03:22 <adamt> solidus-river: hpaste has haskell syntax highlighting.
13:03:34 <adamt> oh, pastie does as well, just not instantly, nvm..
13:03:36 <ski> the function isn't declared to take any argument with a "`Maybe'-type"
13:04:33 <ski> solidus-river : declaring `Maybe v' instead of `v' is never "just a nice thing to do"
13:04:45 <ski> one means one thing, the other means another thing
13:05:36 <ski> just like a string and a list of strings are very different, so a string and a `Maybe'-string are very different
13:05:41 <solidus-river> http://www.pastie.org/3927119
13:05:46 <solidus-river> so that would not throw any type errors?
13:06:02 <adamt> (also, if you use hpaste it can be automatically linked in this channel)
13:06:18 <ski> solidus-river : two errors in there
13:06:47 <ski> (a) mind your bracketting. `foo bar baz' means `(foo bar) baz', not `foo (bar baz)'
13:06:47 <solidus-river> where?
13:06:59 <ski> (b) a number is not a `Maybe'-number
13:07:09 <rwbarton> also did you mean succ'?
13:07:10 <solidus-river> so i would have to do this
13:07:13 <rwbarton> on line 10
13:07:54 <solidus-river> http://www.pastie.org/3927119
13:08:15 <ski> `Maybe Num a' is nonsense
13:08:19 <ski> probably you meant
13:08:33 <ski>   succ' : Num a => Maybe a -> Maybe a
13:08:35 <ski> or maybe
13:08:38 <ski>   succ' : Num a => Maybe a -> a
13:09:06 <ski> still, you need to write an explicit `Just' in the other case here
13:09:17 <solidus-river> grr, this tutorial does not go over maybe well at all... maybe it goes over it later on, i should write the author although i don't know if he would welcome critisism on it
13:09:38 <nexion> I'm trying to write my first monad, but I'm not sure how to create the runner function for it to go into that monad from IO
13:09:45 <nexion> I've posted the code at http://hpaste.org/68645
13:09:45 <ski> BONUS would probably welcome criticism
13:09:52 <ski> preflex: xseen BONUS
13:09:53 <preflex>  BONUS was last seen on freenode/#haskell 1 year, 18 days, 41 minutes and 53 seconds ago, saying: yeah i think that's better as well
13:10:33 <hpc> did he die or something?
13:10:48 <solidus-river> http://www.pastie.org/3927119
13:11:13 * adamt thinks solidus-river likes to link to pastes manually
13:11:16 <ski> nexion : maybe you wanted `data ServiceTask a = ServiceTask (Maybe (IO a))' ?
13:11:26 * ski thinks so too
13:11:44 <rwbarton> solidus-river: how far have you gotten in LYAH?
13:11:45 <ski> (in fact 'tis the same link each time :)
13:12:01 <hpaste> solidus-river pasted ‚ÄúMaybe?‚Äù at http://hpaste.org/68646
13:12:11 <solidus-river> lol, there :P
13:12:33 <ski> solidus-river : again, bracketing
13:12:47 <ski>   succ' Just x
13:12:47 <solidus-river> hmm, in the Just x match?
13:12:48 <ski> means
13:12:52 <ski>   (succ' Just) x
13:12:53 <ski> not
13:12:55 <adamt> isn't L10 troublesome? (a maybe + 1)
13:12:57 <ski>   succ' (Just x)
13:13:13 <solidus-river> oh, so i dont need to use fromJust?
13:13:25 <ski> i don't think there's a need to use recursion here
13:13:38 <solidus-river> no but it keeps me from repeating code if i use recursion
13:13:54 <ski> huh ?
13:14:06 <solidus-river> so if i make
13:14:20 <solidus-river> succ' Just x = succ' $ Just x
13:14:30 <solidus-river> it will call succ' on x and match the last of x = x + 1
13:14:31 <ski> then you get an infinite loop
13:14:36 <solidus-river> instead of me having to rewrite x + 1
13:14:42 <solidus-river> ski so i would want
13:14:48 <ski> (assuming you fix the bracketting error, i.e.)
13:15:05 <ski> the last line
13:15:11 <ski>   succ' x = x + 1
13:15:15 <ski> will not work
13:15:21 <rwbarton> what is succ' supposed to do anyways?
13:15:24 <rwbarton> succ' (Just 3) = ?
13:15:44 <avpx> x + 1 implies x :: Num
13:15:47 <avpx> Erm
13:15:48 <solidus-river> succ' Just x = succ' (fromJust (Just x))
13:15:52 <rwbarton> augh
13:15:56 <avpx> Well, that x :: (Num a) => a
13:16:11 <rwbarton> well in a sense you are getting closer...
13:16:13 <solidus-river> avpx but i declaired A has to be of type Num a to a
13:16:23 <solidus-river> lol damnit
13:16:56 <ski> (rwbarton : hm, yes. i think we need to ask what the purpose is here -- otherwise i fear solidus-river will just get even more lost ..)
13:17:13 <rwbarton> i think starting with what you want the function you're writing to do is a good place :)
13:17:14 <solidus-river> the purpose of succ' is to just add 1 to a Num
13:17:26 <solidus-river> i'm just using it as a dumb example to try to find out how to work with Maybe
13:17:28 <ski> and if there's no number there ?
13:17:31 <ski> give an error ?
13:17:46 <solidus-river> yeah, i guess, if it gets Nothing give an error
13:17:49 <solidus-river> otherwise add one
13:17:50 <rwbarton> so, like I asked before... succ' (Just 3) = ?
13:17:58 <ski> ok, then you *don't* want any recursion in there
13:17:58 <solidus-river> i think that should be
13:18:03 <solidus-river> oh
13:18:07 <rwbarton> there is no "should"
13:18:10 <solidus-river> succ' (Just 3) = 4
13:18:13 <rwbarton> you're writing the function, you get to pick!
13:18:14 <rwbarton> okay
13:18:19 <rwbarton> so if I have
13:18:21 <rwbarton> succ' (Just x)
13:18:22 <lucian> solidus-river: if you haven't already, try reading Learn You a Haskell
13:18:22 <rwbarton> what is that
13:18:26 <rwbarton> lucian: haha recursion
13:18:38 <ski> lucian : i think that's what solidus-river is currently doing, tyvm
13:18:46 <lucian> ski: oh
13:18:47 <solidus-river> lucian: thats what i'm reading right now, unfortunately he starts throwing around Maybe in there without really explaining how to handle it or how it is handled
13:18:49 <ski> (:
13:18:59 <lucian> it's tail-recursive, so it's ok
13:18:59 <rwbarton> solidus-river: how far have you gotten in LYAH?
13:19:08 <adamt> solidus-river: Maybe just accept Maybe for now and move on? :)
13:19:13 <lucian> solidus-river: sure he does, read carefully
13:19:29 <lucian> solidus-river: just forget about null and other languages for a while
13:19:48 <ski> solidus-river : the first case is when you get an input of shape `Nothing' -- and that's good
13:19:51 <rwbarton> he mentions Maybe in chapter 7 but doesn't really explain how to deal with it until chapter 8, that is why I ask
13:19:55 <ski> solidus-river : there is only one case left, then
13:20:02 <solidus-river> i'm in chapter 7
13:20:05 <solidus-river> so thats where i'm hung up
13:20:14 <solidus-river> maybe i should just accept it as a black bock and keep reading
13:20:24 <solidus-river> but i think he shouldn't mention things before explaining htem
13:20:46 <solidus-river> or at least up to this point he's given a really good explanation of everything before using it
13:20:50 <adamt> you would never get anybody to learn haskell if you start by explaining everything. ;)
13:21:33 <ski> solidus-river : well, would you mind if i write what i *think* you indended with  succ'  here ?
13:21:33 <solidus-river> haha, than have a note, (dont worry about Maybe for now, will be explained later)
13:21:43 <solidus-river> ski: definitely, that would be really helpfull
13:21:49 <rwbarton> here is the first mention of Maybe
13:21:55 <rwbarton> "But it returns that element wrapped in a Maybe value. We'll be covering algebraic data types more in depth in the next chapter but for now, this is what you need to know..."
13:22:10 * solidus-river has failed at reading :\
13:22:17 <rwbarton> :)
13:22:30 <ski>   succ' :: Num a => Maybe a -> a
13:22:31 <akosch> adamt: you're right, I'm reading the denotational semantics right now :)
13:22:35 <ski>   succ'  Nothing  = error "Cant find a successor of Nothing!"
13:22:37 <ski>   succ' (Just x)  = x + 1
13:22:42 <ski> solidus-river : that's it
13:23:20 <solidus-river> ski: ah, so if i wanted to use recursion to break down on repitition i should have used straight pattern matching and dunn succ' (Just x) = succ' x
13:23:23 <ski> so the function explicitly handles the two possible cases
13:23:49 <ski> in general yes -- but that doesn't make any sense with `Maybe'
13:23:56 <ski> (since it's a non-recursive datatype)
13:23:57 <solidus-river> because if succ' was a quite complicated function duplicating it for a very similar use case would possible be pretty harmfull to maintaining the code
13:24:06 <adamt> akosch: I have no idea what you're talking about. ;)
13:24:11 <mekeor> heh. just noticed that 'Maybe (Maybe (Maybe (Maybe ‚Ä¶' is natural numbers.
13:24:14 <otters> succ' = fromJust . fmap succ
13:24:37 <ski> > In Nothing :: Mu Maybe
13:24:38 <lambdabot>   In Nothing
13:24:44 <rwbarton> solidus-river, you wouldn't need to duplicate the function, you could just call the original function in the Just case
13:24:51 <ski> > fix (In . Just) :: Mu Maybe
13:24:54 <lambdabot>   In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (J...
13:24:59 <akosch> adamt: it explains _EVERYTHING_ http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
13:25:01 <otters> this Just In
13:25:51 <adamt> akosch: I'm afraid to even start reading that.
13:25:51 <rwbarton> solidus-river, in your http://hpaste.org/68646 line 10 will never be reached because any Maybe a value will match either Nothing or Just x
13:26:07 <rwbarton> solidus-river, line 10 is also a type error because you can't add 1 to a Maybe a value
13:26:14 <rwbarton> but anyways, this will all be more clear after chapter 8
13:26:20 <adamt> akosch: Is it actually a good read, or is it something you read when you're ready to enter Haskell-nirvana and only need the last push?
13:26:36 <akosch> adamt: I suggest watching the video :)
13:26:46 <ski> solidus-river : i think the kind of duplication you're thinking of can't be the case with `Maybe' -- at least not with a single function
13:26:52 <akosch> adamt: just a sec I'll get a link
13:27:06 <akosch> adamt: http://videoag.fsmpi.rwth-aachen.de/?course=12ss-funkprog
13:27:45 <akosch> adamt: it's the last one available (11.05.2012), and contrary to the page it is in english
13:28:04 <otters> this denotational semantics article is fascinating
13:28:31 <adamt> akosch: Oh ok, because my german skills are non-existing.
13:28:55 <akosch> otters: yeah, I'm baffled myself. does any other language have this?
13:29:24 <otters> akosch: I can't tell, I'm just toeing the line between partial comprehension and complete confusion
13:29:58 <adamt> So it's actually worth looking at, and not some stupid trolling attempt at confusing the newcomer? :P
13:30:08 <c_wraith> no other language embraces denotational semantics quite like haskell does
13:30:17 <hpc> c_wraith: maybe agda ;)
13:30:29 <mm_freak> i think haskell is better at that than agda
13:30:31 <akosch> adamt: it's especially useful if you want to implement a compiler for Haskell
13:30:51 <otters> heh
13:30:58 <otters> 0 `shaves` 0 gives me an infinite loop
13:31:00 <ski> c_wraith : SML has a formal semantics. though operational iirc
13:31:40 <rwbarton> strict or total pure languages will have a different denotational semantics picture
13:31:51 <akosch> I wonder how denotational semantics would look like for lisp
13:32:11 <ski> akosch : there is one denotational semantics in the R5RS for Scheme
13:32:20 <solidus-river> akosch: they would have a tun of parenthesis?
13:32:23 <solidus-river> *ton
13:32:42 <otters> "more defined"
13:32:43 <otters> lol, what
13:32:44 <akosch> ski: wow, I have to get my hands on that!
13:33:43 <solidus-river> akosch: (((Int) (a)) -> (((a)->(a)) -> (a))) <-- lisp
13:33:44 <ski> otters : what about it ?
13:33:58 <solidus-river> :P
13:34:10 <akosch> solidus-river: :)
13:34:18 <solidus-river> does anyone know the link to the ncurses based skii game written for the obfuscated lisp contest?
13:34:21 <otters> it's even more fun when you make type signatures prefix instead of infix
13:34:32 <adamt> akosch: What's the runtime of the video?
13:34:34 <solidus-river> it was like a horrible one liner
13:34:58 <akosch> adamt: I have no idea, I watched it on almost double speed
13:34:59 <ski> solidus-river : is that supposed to be some CPS-based semantics ?
13:35:17 <adamt> i find the parenthesis-argument against lisp/scheme/.. pretty silly, since the same people probably never counted the number of paranthesis in a regular c/java application.
13:35:37 <otters> well, it's obviously about nested parens, not just parens
13:35:45 <solidus-river> adamt: i think most arguments about syntax are silly, withe every syntax there is a good and bad way to do it
13:35:48 <otters> and to be fair, lisp has way more of those
13:35:54 * ski . o O ( `paredit-mode' )
13:36:07 <lucian> adamt: people really hate that they have less variation and somewhat more parentheses, for some reason
13:36:24 <solidus-river> adamt: i love the people who are now arguing against english readable sentences as syntax and saying they are stupid because you can write really odd while loops with them that dont make sense, but 100% of the time that logic is doable in a way that makes perfect sense with the syntax
13:36:27 <ski> after a while you don't notice them that much
13:36:29 <lucian> C-ish have { } () [], etc
13:36:37 <lucian> of course it's silly
13:36:38 <solidus-river> its like writing horribly obfuscated c saying that its proof that c syntax is "bad"
13:36:38 <adamt> If they just complained about losing their way in the nesting, then that's fine, but people just saying "oh boy look at all those ()'s.." =/
13:36:44 <solidus-river> when really your "bad" at writing c
13:36:58 <otters> "oh boy look at all those ()s" is an implicit "that's too many ()s to keep track of"
13:37:52 <ski> you shouldn't keep track of them, your editor should
13:38:16 <adamt> i have a scheme class right now, i'm tired of all the whiners complaining about lack of loops and too many paranthesis. just agree with me lol.
13:38:22 <ski> (also you should not indent code in non-standard ways)
13:38:30 <lucian> adamt: they are silly, yes :)
13:38:44 <lucian> adamt: just write a loop macro for them or something
13:38:45 <ski> what ? Scheme `do' have `do'
13:39:25 <snifcjo> I'd like to hear if someone has made mobile applications with Haskell, for example for Android? (Some general opinions how it is?)
13:39:28 <adamt> ski: They aren't tought nasty tricks like that. :)
13:39:46 <adamt> Anyways, enough () talk i suppose.
13:39:49 <ski> it's a beautiful trick, not nasty
13:40:03 <lucian> oh, and you can write a cond with less (), like clojure's
13:40:05 <lucian> and so on
13:40:06 <flebron> Is (->) an actual operator? I can say -> is an instance of some typeclass, but I can't say x = (->).
13:40:19 <ski> lucian : only it's more ugly :)
13:40:44 <ski> flebron : i think you should be able to say `type Foo = (->)'
13:40:49 <hpc> flebron: (->) is syntax that behaves like a type constructor
13:40:55 <hpc> flebron: see also:
13:40:57 <hpc> :k Maybe
13:40:58 <lambdabot> * -> *
13:41:00 <lucian> ski: clojure's cond? i prefer it
13:41:06 <hpc> > (\x -> x) "bacon"
13:41:07 <lambdabot>   "bacon"
13:41:10 <flebron> Oh, OK, a type ctor and not a type. Cool, thanks.
13:41:19 <hpc> > case True of True -> "bob"
13:41:20 <lambdabot>   "bob"
13:41:22 <ski> lucian : hehe
13:41:40 <ski> (a type ctor is a type)
13:41:53 <flebron> hpc, why do I get:
13:41:56 <flebron> > :k (->)
13:41:57 <lambdabot>   <no location info>: parse error on input `:'
13:42:07 <ski> flebron : GHC magic
13:42:08 <flebron> OK well I get (->) :: ?? -> ? -> *
13:42:19 <akosch> could the bottom type in haskell semantics denote something else besides non-termination?
13:42:23 <flebron> Why ?? and ? and not * -> * -> *?
13:42:29 <ski> read `??' and `?' as if it haf said `*'
13:42:37 <ski> unless you want to know about unboxed types
13:42:49 <Cale> akosch: It's not a type, usually...
13:42:50 <rwbarton> akosch: "bottom type"?
13:42:57 * ski . o O ( s/haf/hath/ ? )
13:43:04 <akosch> rwbarton: http://en.wikipedia.org/wiki/Bottom_type
13:43:15 <rwbarton> oh
13:43:30 <Cale> akosch: But the bottom value just represents non-termination, which includes any kind of failure of the program to produce a value.
13:43:45 <flebron> ski, do I want to know about unboxed types?
13:43:53 * hackagebot prelude-generalize 0.3 - Another kind of alternate Prelude file  http://hackage.haskell.org/package/prelude-generalize-0.3 (AaronBlack)
13:43:53 <akosch> Cale: so besides running forever, it could also just crash? :)
13:43:58 <Cale> akosch: right
13:44:07 <ski> flebron : i don't know, let me ask flebron ..
13:44:13 <flebron> hehe
13:44:15 <ski> flebron : .. do you want to know about unboxed types ?
13:44:28 <flebron> ‚Ä¶ yes!
13:44:29 <Cale> akosch: and  error :: String -> a  does this, as well as  undefined :: a
13:44:33 <rwbarton> the name "bottom type
13:44:35 <ski> @src Int
13:44:36 <lambdabot> data Int = I# Int#
13:44:42 <rwbarton> " isn't really used among Haskell people afaik
13:44:51 <ski> flebron : `Int#' is an unboxed type, it has kind `#' (not `*')
13:44:51 <rwbarton> as Haskell does not have subtyping
13:45:00 <flebron> So we have #, ?, ??, and *.
13:45:13 <hpc> flebron: we also have Constraint (that one is new)
13:45:18 <ski> flebron : `Int' contains `_|_', but `Int#' doesn't (it's already evaluated)
13:45:25 <akosch> Cale: yeah, I was wondering about them. I couldn't implement something like them in pure Haskell myself, right?
13:45:29 <hpc> and (#) for unboxed tuple types
13:45:30 <hpc> i think
13:45:32 <ski> yes
13:45:40 <hpc> and that should be it
13:45:46 <Cale> akosch: Well, you can sort of implement undefined
13:45:50 <ski> there was a kind `!' for some while
13:45:52 <flebron> So what Haskell knows is that the type instance cannot be undefined?
13:45:59 <akosch> Cale: how?
13:46:00 <flebron> Err, type element. God I spoke terribly.
13:46:05 <Cale> undefined | False = undefined
13:46:25 <rwbarton> and error is itself "pure Haskell" in a certain sense
13:46:37 <Cale> (which will fall through and crash)
13:46:45 <ski> flebron : `??' is the join of `*' and `#'. and `?' is the join of `??' and `(#)'
13:46:45 <rwbarton> but if you mean, can you write error without using error, then not really
13:46:46 <akosch> Cale: isn't this cheating? :)
13:46:58 <Cale> akosch: yes
13:47:06 <Cale> akosch: well, maybe
13:47:13 <flebron> ski, and by join you mean as in the lattice of definedness?
13:47:13 <rwbarton> it doesn't really seem like cheating to me
13:47:22 <akosch> rwbarton: yeah, I was wondering about that
13:47:22 <Cale> It kind of depends on what the rules are
13:47:30 <rwbarton> right
13:47:32 <ski> flebron : i mean as in the subkinding hierarchy of kinds
13:48:28 <Cale> If you don't like making use of other ways to crash the program, then you'll have to settle for an infinite loop
13:48:32 <Cale> undefined = undefined
13:48:39 <akosch> Cale: I guess undefined is part of haskell so you can use it to define your own version, but I was thinking about a definition which doesn't use undefined
13:48:44 <Cale> (which might die in finite time anyway)
13:48:48 <rwbarton> the infinite loop is definitely not cheating
13:48:54 <Cale> akosch: I'm not using the existing one
13:49:02 <hpaste> timthelion pasted ‚Äú4 hour bug...‚Äù at http://hpaste.org/68649
13:49:03 <Cale> akosch: I'm defining a new one recursively
13:49:11 <rwbarton> or if you prefer, undefined = x where x = x
13:49:11 <timthelion> the nasties bugs are so simple :)
13:49:16 <timthelion> nastiest
13:49:23 <akosch> Cale: ok, but undefined = undefined would just run forever. what about crashing?
13:49:31 <Cale> undefined | False = undefined
13:49:35 <Cale> won't run forever
13:49:38 <ski> <Cale> (which might die in finite time anyway)
13:49:38 <Cale> The guard will fail
13:49:55 <hpc> undefined = undefined will get caught by the loop checker, i think
13:50:03 <akosch> Cale: ok, incomplete pattern... very clever I must admit :)
13:50:05 <hpc> your program will die with "<<loop>>"
13:50:18 <Cale> hpc: usually, yeah
13:50:21 <timthelion> > let undefined = undefined in undefined
13:50:25 <lambdabot>   mueval-core: Time limit exceeded
13:50:25 <Cale> hpc: I think maybe with -threaded it won't.
13:50:31 <akosch> hpc: there is a loop checker?
13:50:40 <rwbarton> you could imagine a pathological Haskell implementation that enters an infinite loop on pattern match failure
13:50:44 <hpc> akosch: yeah, but it barely catches anything and it might as well not exist
13:50:46 <opqdonut> "undefined | False = undefined" is basically 'undefined = error "foo"'
13:51:02 <rwbarton> and that doesn't have error and doesn't have things like 1/0 and so on
13:51:13 <rwbarton> or 1 `div` 0 rather
13:51:17 <timthelion> > print "hi"
13:51:17 <lucian> hmm, i guess catching definition loops is hard in a lazy language
13:51:18 <lambdabot>   <IO ()>
13:51:25 <Cale> akosch: GHC implements values as pointers to code which is supposed to return the computed value on the stack to whatever is pattern matching it
13:51:38 <timthelion> > "\me scratches his head \n"
13:51:39 <lambdabot>   <no location info>:
13:51:39 <lambdabot>      lexical error in string/character literal at chara...
13:51:48 <hpc> undefined = unsafePerformIO $ geoIP >>= launchMissiles
13:52:00 <Cale> akosch: When a value is entered the first time, the first thing that happens is that the pointer is re-written to point at a piece of code which fails with an exception "<<loop>>"
13:52:22 <timthelion> > "\\me scratches his head \n"
13:52:23 <lambdabot>   "\\me scratches his head \n"
13:52:26 <Cale> akosch: and then once the value is computed, it's rewritten again to point at a piece of code which returns the computed value immediately
13:52:33 <timthelion> damn you lambda bot!
13:52:45 <ski> @read "/me /you"
13:52:45 <lambdabot>  /me /you
13:52:58 <Cale> akosch: So if, in computing a value, that very same value is needed, you get a crash.
13:53:34 <hpc> > text "\x01ACTION hello\x01"
13:53:35 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
13:53:47 <akosch> Cale: I think I get it, this is simple but won't catch more deeply nested ones, right?
13:53:49 <Cale> Note, when I say "computing" here, I mean "detemining the top level data constructor"
13:53:52 <Cale> right
13:54:01 <Cale> determining*
13:54:38 <Cale> It won't catch a lot of kinds of nontermination, but it catches a few.
13:54:58 <akosch> Cale: if you're in a loop with just 2 values which require eachother, then this already won't catch it?
13:56:23 <Cale> Nope, it'll catch that
13:56:24 <akosch> Cale: I mean something like a = b and b = a
13:57:52 <akosch> Cale: won't it just go from trying to enter a then b then a, etc.
13:59:12 <akosch> Cale: I tried this in ghci and got an endless loop as a result
13:59:33 <Cale> ghci uses the threaded runtime
13:59:39 <Cale> which can't throw an exception in this case
14:00:01 <Cale> The reason is that two threads can start evaluating a value at very nearly the same time
14:00:29 <Cale> and you don't want one of them to get an exception when this happens, you want it to wait for the other thread to compute the value
14:00:50 <Cale> and so you should get a zero-CPU-usage pause
14:01:41 <akosch> Cale: I see, thanks for explaining
14:01:43 <Cale> (also called a grey-hole, I believe, whereas the code which dies with the loop exception is called a blackhole)
14:02:00 <hpc> Cale: huh, so that's how it works
14:02:45 <Cale> But if you write something like   let f x = f x in f 0
14:02:48 * hpc would very much like to see a series of "this is how ghc does $awesome_thing" articles
14:02:57 <Cale> that'll use 100% CPU and won't be caught
14:04:19 <akosch> Cale: ok, I can see why it can't catch that with the method you described
14:06:30 <tsuraan_> What is the normal way to constrain the type of a function that is stored in a type?  i.e., I want to have "data Foo a = Foo Int (a -> a)", but I also want to ensure that "a" is a Num
14:06:50 <tsuraan_> it looks like there's a deprecated DatatypeContexts thing that didn't work very well, or something
14:06:55 <tsuraan_> http://hackage.haskell.org/trac/haskell-prime/wiki/NoDatatypeContexts
14:07:05 <tsuraan_> so I'm guessing that's not what I want
14:07:17 <akosch> Cale: it could maybe catch this by checking if evaluating f x required evaluating f x, it still wouldn't work for f x = f (x+1) though
14:08:27 <tsuraan_> it looks like I can do "data Foo = Foo Int (Num a => a -> a)" using RankNTypes.  Is that a normal thing to do?
14:08:53 * hackagebot ralist 0.1.0.0 - Random access list with a list compatible interface.  http://hackage.haskell.org/package/ralist-0.1.0.0 (LennartAugustsson)
14:09:50 <flebron> tsuraan_, but that has different semantics than the original one
14:10:21 <flebron> In the original, Foo is a type ctor, that for each a, gives you some type. In the second, Foo is a type, and it requires a function that accepts all possible Num types.
14:10:45 <tsuraan_> ah, ok.  I'm pretty certain I don't want the latter there
14:11:24 <flebron> how about data (Num a) => Foo a = T Int (a -> a)
14:11:50 <hpc> flebron: that's worse than not having a constraint at all
14:12:04 <tsuraan_> that's the one that wants DatatypeContexts, which are I think broken or something?
14:12:09 <hpc> because it makes you put (Num a) => ... on everything
14:12:15 <tsuraan_> but yeah, that was what I thought I wanted
14:12:18 <hpc> even if it doesn't care what 'a' is
14:12:34 <RylandAlmanza> Two quick questions. What does it mean when you put a ! before a type? for example: symbol  :: !Char
14:12:43 <hpc> RylandAlmanza: it makes the field strict
14:12:44 <copumpkin> whoa, RylandAlmanza in #haskell
14:12:45 <tsuraan_> should I just hide the constructor for my type, and put the constraint on my publicly available init function?
14:12:58 <hpc> copumpkin: eh?
14:13:06 <RylandAlmanza> Hey, copumpkin
14:13:15 <kuznero> Can anybody advice how is it possible to enumerate all data constructors of a type: e.g. "data MyType = This | That", how do I get list ["This", "That"] ?
14:13:22 <RylandAlmanza> copumpkin: Decided to try out functional programming. :)
14:13:23 <copumpkin> RylandAlmanza: didn't you have a shoe on your head? or was that someone else?
14:13:24 <copumpkin> nice!
14:13:35 <RylandAlmanza> yeah, I had a shoe on my head
14:13:40 <RylandAlmanza> lol
14:13:41 <hpc> kuznero: data MyType = ... deriving (Bounded, Enum)
14:13:42 <copumpkin> excellent
14:13:42 <sipa> kuznero: [lowerBound..upperBound]
14:13:50 <hpc> :t [minBound .. maxBound]
14:13:50 <lambdabot> forall a. (Bounded a, Enum a) => [a]
14:13:56 <sipa> right, that
14:13:57 <kuznero> hpc, sipa, great! thanks a log!!!
14:14:05 <sipa> ignore me
14:14:47 <RylandAlmanza> thanks, hpc
14:18:01 <__zero> is there any implementation of a parallel mapM ?
14:18:45 <hpc> __zero: you mean like mapM_ (forkIO . f)?
14:18:58 <hpc> or something that accumulates the results, too?
14:20:15 <__zero> hpc: something that accumulates them
14:20:28 <__zero> i want to have the result in a list
14:20:31 <hpc> ah, hmm
14:20:44 <hpc> lemme paste something horrible that might work :P
14:21:12 <S11001001> ordinary pmap followed by sequence seems right
14:22:07 <hpc> actually, that's a good point
14:22:08 <rwbarton> > print undefined
14:22:09 <lambdabot>   <IO ()>
14:22:19 <hpc> __zero: do you want parallel evaluation or parallel execution?
14:22:28 <hpc> ie, `par' or `forkIO'?
14:22:35 <rwbarton> perhaps one should say 'concurrent execution'
14:22:48 <hpc> yes, that
14:23:13 <rainman1985> ski: will you hopefully be there in about 10-15 minutes? I have some last questions...
14:23:22 <crdueck> i want to store a file as a list of lines, where lines are lists of words. whats the best way to do that? I'm still getting used to IO in haskell
14:24:01 <hpc> :t unwords . map unlines
14:24:01 <lambdabot> [[String]] -> String
14:24:05 <hpc> er
14:24:11 <hpc> :t map words . lines
14:24:12 <lambdabot> String -> [[String]]
14:24:15 <hpc> crdueck: ^
14:24:47 <hpc> :t mapM
14:24:47 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
14:24:49 <saml> hello
14:24:59 <saml> can you have opengl glut example?
14:25:17 <hpaste> hpc pasted ‚Äúhorrible-badness‚Äù at http://hpaste.org/68650
14:25:22 <__zero> back?
14:25:32 <hpc> __zero: http://hpaste.org/68650 -- this should work, but i don't vouch for its safety
14:25:40 <hpc> or rather, it might not work
14:25:45 <hpc> but it looks like it does
14:25:55 <hpc> have fun :P
14:27:08 <__zero> thanks ill try it in a sec
14:28:17 <krakrjak> hpc: what about using STM to make that a little more safe?
14:28:32 <hpc> krakrjak: safety is for babies :D
14:28:41 <hpc> also i don't see how STM could make that safer
14:29:31 <rwbarton> did you answer __zero's question without him answering about parallel evaluation or concurrent execution?
14:29:37 <rwbarton> or did I miss it?
14:30:08 <krakrjak> Where you have putMVar and takeMVar you might instead use putTMVar and takeTMVar
14:30:22 <rwbarton> Also, can't you just delete "unsafeInterleaveIO $ "?
14:30:31 <rwbarton> oh, no, never mind
14:30:51 <hpc> krakrjak: that puts you in STM, where you can't do IO
14:31:29 <krakrjak> can't do IO....  hrm...  I'm not so sure hang tight.
14:31:45 <rwbarton> shouldn't do IO?
14:33:10 <rwbarton> anyways you should be able to rewrite this as something like  mapM takeMVar $ mapM (spark . f) xs where spark action = do { result <- newMVar; forkIO $ action >>= putMVar result; return result }
14:33:30 <__zero> hpc: do i have to compile with any special flags for the code you gave me?
14:33:45 <krakrjak> you can use liftBase composed with atomically $ takeTMVar var to get into IO
14:35:17 <krakrjak> something like liftBase . atomically $ takeTMVar result
14:36:29 <__zero> hpc: oh god this is so fast
14:41:57 <ski> rainman1985 : maybe
14:42:51 <ghorn> http://stackoverflow.com/questions/10643901/compile-time-code-rewriting-outside-of-template-haskell-scope
14:43:01 <ghorn> is this possible?
14:44:30 <adamt> akosch: Damn you. It's not supposed to be interesting to listen to a man talking about whether (_|_, 5) is more or less defined than (5, _|_) etc.
14:45:26 <eacameron> I was looking at an example on StackOverflow and I came across this. What does the @ mean? map (\xs@(x:_) -> (x, length xs)) . group . sort
14:45:33 <acowley> adamt: What's the argument for calling one more defined than the other?
14:45:57 <adamt> acowley: there's none. Can't be compared.
14:46:11 <acowley> eacameron: it is a pattern alias. The identifier xs is bound to the entire list whose head is bound to x.
14:46:18 <adamt> do people use utf-8 in here, or strict ascii/latin 1?
14:46:20 <acowley> adamt: good!
14:46:34 <ski> a bit of both
14:46:49 <eacameron> acowley: that's not in some language extension?
14:46:59 <ski> eacameron : it's in the base language
14:47:17 <nexion> I can't figure out how to implement >>= for: data ServiceTask a = ServiceTask (Maybe (IO a)), can someone guide me in the right direction or link a similar example?
14:47:29 <nexion> I'm trying to match the signature: >>= :: ServiceTask a -> (a -> ServiceTask b) -> ServiceTask b
14:47:38 <nexion> but that IO component is making it complicated
14:47:38 <eacameron> ski: oh my...never seen that before
14:47:52 <ski> nexion : hm, actually now that i think about it, it should be `IO (Maybe a)'
14:48:01 <ski> (i was thinking about `MaybeT IO a')
14:48:14 <ski> nexion : .. sorry to have confused you
14:48:15 <adamt> acowley: what's good? that i listened, or that it's sensible? ;)
14:48:21 <nexion> that's ok :)
14:48:22 <ski> eacameron : have you seen `~' then ?
14:48:31 <eacameron> ski: nope...
14:48:37 <rwbarton> there should be a page somewhere with "little-known features of Haskell 98"
14:48:39 <ski> that's also in the base language :)
14:48:40 <acowley> adamt: that it's sensible!
14:48:50 <eacameron> ski: i must have missed that chapter ??
14:48:50 <nexion> ski, why would it be IO (Maybe a) instead of the other way around?
14:49:01 <nexion> (so I understand)
14:49:06 <acowley> adamt: Although I was rather curious to hear an argument for an ordering.
14:49:15 <ski> nexion : because `Maybe (IO a)' means that you maybe have an `IO'-action, or maybe nothing at all
14:49:23 <adamt> acowley: I'm sure it would be different for php. :P
14:49:26 <nexion> ah
14:49:31 <nexion> but it's an IO action either way
14:49:32 <ski> nexion : but `IO (Maybe a)' means that you have an `IO'-action which maybe returns an `a' result
14:50:13 <rwbarton> your data ServiceTask a = ServiceTask (Maybe (IO a)) doesn't seem to me to be a monad btw
14:50:20 <ski> nexion : given `Maybe (IO a)' and `a -> Maybe (IO b)', there's no sensible way to build `Maybe (IO b)'
14:50:27 <rwbarton> so it is good that you couldn't figure out how to implement (>>=) :)
14:50:31 <acowley> adamt: I think those examples are some of the most intriguing with regards to lazy evaluation.
14:51:03 <rainman1985> ski: I'll pick it up where we left...
14:51:06 <nexion> ski, would this be correct then?
14:51:08 <nexion> instance Monad ServiceTask where
14:51:08 <nexion>   -- >>= :: ServiceTask a -> (a -> ServiceTask b) -> ServiceTask b
14:51:08 <nexion>   ServiceTask a >>= b = b a
14:51:08 <phy> a performance question, today I wrote a small program which worked fine but then I put some of the helper functions in a separate file and now it's noticeably slower (about 4x). Any ideas what might be causing this?
14:51:19 <ski> eacameron : `~' is mostly useful when you're doing knot-tying tricks
14:51:40 <rainman1985> but you're busy now, maybe I'll talk a bit later?
14:52:02 <eacameron> ski: Haskell's good at those...
14:52:16 <ski> nexion : no, since the type of your variable `a' here is `IO (Maybe a)', not `a'
14:52:31 <ski> @src partition
14:52:31 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
14:52:32 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
14:52:32 <lambdabot>                               | otherwise = (ts, x:fs)
14:52:47 <ski> eacameron : ^ that's an example use of `~'
14:53:25 <eacameron> ski: excellent example...now to understanding what on earth it's doing ...
14:53:41 <zzo38> Is (fmap lower . lower . duplicate = duplicate . lower) supposed to be a law for comonad transformer or not? (also the similar question for monad transformer)
14:53:50 <ski> eacameron : more specifically, understand why they didn't just omit the `~' in there :)
14:54:49 <ski> nexion : i think the simplest here is "follow the types"
14:55:45 <nexion> let's rename a and b to avoid confusion
14:55:49 <nexion> >>= :: ServiceTask x -> (x -> ServiceTask y) -> ServiceTask y
14:56:00 <ski> (>>=) :: ServiceTask x -> (x -> ServiceTask y) -> ServiceTask y
14:56:16 <nexion> x is IO (Maybe a)
14:56:22 <ski> no
14:56:33 <rwbarton> (sorry to interject an irrelevant side note but you presumably want 'newtype' not 'data' in your definition of ServiceTask)
14:56:36 <ski> `x' is a type variable
14:57:21 <ski>   ServiceTask a >>= b = ..a..b..
14:57:24 <ski> we know
14:57:37 <ski>   ServiceTask a :: ServiceTask x
14:57:46 <ski>   b :: x -> ServiceTask y
14:57:54 <ski>   ..a..b.. :: ServiceTask y
14:58:01 <rwbarton> (I would just erase the newtypes before embarking on this calculation)
14:58:06 <nexion> okay, I'm with you so far
14:58:33 * ski would rename the data constructor to not have the same name as the type constructor -- just for clarity
14:59:05 <ski> so, say
14:59:20 <ski>   newtype ServiceTask a = MkServiceTask (IO (Maybe a))
14:59:24 <ski> so we had
14:59:26 <nexion> sure
14:59:31 <ski>   MkServiceTask a :: ServiceTask x
14:59:41 <ski> what does that say about `a' ?
15:01:13 <nexion> this is a part I don't understand
15:01:22 <nexion> well..
15:01:35 <ski> if `MkServiceTask a' (the left argument) has type `ServiceTask x'
15:01:40 <ski> then what type must `a' have ?
15:01:57 <nexion> IO (Maybe a)
15:02:00 <ski> yes
15:02:08 <ski> or .. almost :)
15:02:18 <ski>   a :: IO (Maybe x)
15:02:22 <ski> note the `x' in there
15:02:32 <nexion> er.. yeah
15:02:40 <ski> because we decided to use the name `x' in the type `ServiceTask x'
15:02:44 <nexion> yup
15:03:07 <ski> so, summing up the situation so far, we've got
15:03:13 <ski>   a :: IO (Maybe x)
15:03:17 <ski>   b :: x -> ServiceTask y
15:03:22 <ski> and we want to construct
15:03:23 <ski>   ..a..b.. :: ServiceTask y
15:03:47 <ski> where `..a..b..' stands for some yet-unwritten expression which will probably involve `a' and `b'
15:04:10 <ski> now, we see that if we had an `x', then we could feed it to `b', to get a `ServiceTask y'
15:04:10 <nexion> so we need to go from a to Maybe x
15:04:14 <nexion> and pattern-match
15:04:19 <nexion> to get x
15:04:50 <ski> .. but we can't seem to get an `x' directly (there is no `runIO', remember)
15:05:02 <ski> nexion : yep, but something like you say is what we want to do
15:05:15 <krakrjak> do { val <- a; b . fromMaybe val} ??
15:05:19 <ski> we just have to do a little other stuff first, to reach that position
15:05:38 <hpaste> Phy pasted ‚ÄúPoisson Solver‚Äù at http://hpaste.org/68652
15:05:49 <bgamari> How liberal can one be in the "left-to-right" semantics of Traversable?
15:05:58 <ski> seeing as we can't apply `b' directly to an `x' (where would it come from ?), and that we can't extract an `x' directly out of `a'
15:06:03 <ski> we turn to consider
15:06:06 <ski>   ..a..b.. :: ServiceTask y
15:06:24 <bgamari> If I have a data-structure with no intrinsic ordering (but one can be assigned), would it be a bad idea to make it traversable?
15:06:33 <ski> this has type `ServiceTask y' -- and we could always construct something of that type by applying the data constructor
15:06:44 <nexion> can we get 'Maybe x' from a?
15:06:56 <acowley> bgamari: No it wouldn't be a bad idea
15:06:57 <edwardk> bgamari: i'm generally willing to make things like hashed containers traversable
15:07:06 <ski> we already have `a' (a value), no need to get to it
15:07:09 <edwardk> as long as it has a stable ordering
15:07:13 <acowley> bgamari: If you want a different ordering, you can always newtype it and write a different instance
15:07:40 <phy> Can any body explain why if i put imap2D and (#) in a separate module i get a 4x perfromance hit in http://hpaste.org/68652
15:07:47 <nexion> but a :: IO (Maybe x), and the goal is x to feed into b, correct?
15:07:56 <bgamari> acowley, edwardk: Sure, alright. Thanks!
15:08:00 <bgamari> that makes me feel better
15:08:04 <phy> it's not the nicest of code but still please help
15:08:09 <ski> bgamari : a version of `Traversable' which assumes the applicative functor / monad is commutative might be nice
15:08:50 <krakrjak> ski, nexion: is this not a good approach to the problem? do { val <- a; b . fromMaybe val}
15:08:57 * hackagebot lca 0.1 - Logarithmic online lowest common ancestor calculation  http://hackage.haskell.org/package/lca-0.1 (EdwardKmett)
15:09:00 <edwardk> ski: i tend to just exploit the fact that those commutative cases tend to be distributive, and use that to pull them out
15:09:09 <ski> krakrjak : maybe, maybe not -- in any case, we can't apply it yet
15:09:27 <armlesshobo> is there a way to do a data statememnt in ghci?
15:09:32 <ski> edwardk : hm, distributive in which sense ?
15:09:38 <krakrjak> ski: ok.  Is there a better way to execute the IO action than in a do block?
15:09:46 <c_wraith> armlesshobo: in a sufficiently new ghci
15:09:48 <edwardk> Data.Distributive from the 'distributive' package
15:09:54 <c_wraith> armlesshobo: that is, ghc 7.4+
15:10:11 <ski> krakrjak : no, but we haven't reached the point of being able to write an `IO'-action, yet
15:10:27 <nexion> ski, regarding your comment about no runIO, do you mean that we can't pull an IO value into the current monad?
15:10:32 * ski ponders suggesting moving to #haskell-overflow
15:10:39 <nexion> sure, let's
15:10:57 <krakrjak> ski: ok.  I've just seen that when you have types like IO (m a0) then to get must the bare m a0 you perform the do binding.
15:11:11 <ski> krakrjak : you could follow us, if you wish to
15:11:24 <krakrjak> ski: I really want to.  I'm enjoying it.
15:11:28 <c_wraith> Is there any variant of hunit that supports running tests concurrently out of the box?
15:11:41 <krakrjak> ski: unfortunately I have to run.  Is there an hpaste I can follow later?
15:12:02 <ski> krakrjak : oh -- i dunno
15:12:32 <krakrjak> ski: if not I'll just log this and read when I get a chance later tonight.  Keep after it.  I'm learning a lot.
15:12:44 <RylandAlmanza> So, I'm about to start a simple game in haskell. Anyone know if the sdl bindings for haskell are ok?
15:13:03 <acowley> ghc-mod is very eager to highlight my typing in pink.
15:13:20 <c_wraith> oh.  test-framework appears to do what I think I want
15:15:18 <rainman1985> ski: would you have some time now? I don't believe there is much left to it, but I'm still uncertain
15:15:50 <edwardk> hrmm i should probably make sure travis tries to run haddock
15:16:56 <c_wraith> travis-ci?
15:17:00 <ski> rainman1985 : currently defining a monad in #haskell-overflow
15:17:12 <rainman1985> sorry :)
15:18:57 * hackagebot lca 0.1.0.1 - O(log n) online lowest common ancestor calculation  http://hackage.haskell.org/package/lca-0.1.0.1 (EdwardKmett)
15:19:06 <edwardk> c_wraith: yeah
15:19:25 <edwardk> c_wraith: started setting up all my repos to get travis to build the platform version, so i can keep my local machine bleeding edge
15:19:48 <edwardk> but just ran into a problem where a repo had broken haddocks and travis wasn't telling me
15:20:04 <edwardk> so now i need to add after_script: cabal haddock to about 40 repos ;)
15:20:13 <acowley> ooh, that's a really good use of travis ci
15:20:31 <edwardk> acowley: its also about 2 minutes worth of work per repo
15:20:36 <acowley> the gap between the platform and the current release is a pretty nasty place
15:21:06 <edwardk> i took the time to set up the bug-reports link to point to the github issues page as well, since i had to touch everything
15:22:11 <edwardk> i found almost a dozen issues with my platform support, so it was worth it
15:22:22 <edwardk> places where i couldn't build on the platform, etc.
15:22:34 <edwardk> now 'ad' builds clean on the platform
15:22:57 <edwardk> and all my repos don't emit warnings about mkTyCon3 or crash on the platform, etc.
15:23:28 <edwardk> the only one thats still broken i think is order-statistics, and that just won't build clean on the platform because of an issue with statistics i think
15:25:56 <adamt> akosch: are all the videos in english?
15:27:05 <phy> can I get attention of some performance guru. It doesn't really matter but it would be nice to know why such a trivial change degrades performance so much
15:27:23 <hpc> phy: what's the difference?
15:30:13 <phy> 6 second as it is
15:30:31 <phy> 24 seconds after functions are moved to separate module
15:30:43 <hpc> i mean, what's the change
15:30:46 <hpc> oh
15:30:47 <hpc> huh
15:30:52 <nand`> maybe something to do with inlining?
15:30:58 <hpc> compiling with -O2?
15:31:09 * hpc agrees with nand`
15:31:13 <phy> yup -O2 -fllvm
15:32:13 <phy> <hpc> tried to put inline pragma doesn't work
15:34:34 <Mathnerd314> compare the core
15:35:08 <strager> @pl return . id
15:35:09 <lambdabot> return
15:35:14 <strager> derp.
15:37:12 <phy> hpc nand any other idea?
15:37:20 <hpc> what Mathnerd314 said
15:37:25 <nand`> no idea sorry, haskell performance is still a black box for me
15:38:21 <acowley> phy: put some code on hpaste
15:38:30 <adamt> nand`: it seems to be for most :)
15:39:48 <phy> what's the option for dumping core?
15:39:58 <alpounet> phy, putting functions in another module will just indeed remove automatic inlining
15:40:55 <phy> acowley original code is here http://hpaste.org/68652 sorry that formatting is not nice
15:42:11 <phy> alpounet shouldn't putting {-INLINE foo-} in front of those removed functions fix it
15:42:23 <alpounet> it should yes
15:42:33 <phy> it didn't work for me
15:42:40 <alpounet> unless ghc decides not to inline them despite the pragma...?!
15:42:47 <nand`> maybe the new module you put them into wasn't compiled with the correct optimization flags? try deleting temporary files and re-building it all
15:43:20 <phy> perhaps
15:44:33 <phy> nand not that either
15:45:43 <acowley> phy: you could try adding SPECIALIZE pragmas.
15:47:40 <alpounet> phy, there are a bunch of stuffs you may want to check here
15:47:40 <acowley> But I'm surprised the INLINE hammer didn't have any effect.
15:47:47 <alpounet> adding some strictness may help
15:48:02 <alpounet> verifying that the functions you want to get inlined actually do
15:48:25 <alpounet> and profiling may reveal other stuffs
15:56:05 <phy> alpounet how do all this
15:56:15 <phy> i am quote a newbie
15:56:50 <alpounet> phy, regarding the strictness, well you can gather some information here and there about it, no particular resource to point you to sorry
15:57:01 <alpounet> for the profiling, just read the profiler's manual
15:57:06 <alpounet> it's pretty easy to use
15:57:19 <alpounet> basically just some options to pass to ghc and some others to run your program with
15:57:23 <phy> about strictness I thought Vector is a strict type
15:58:33 <alpounet> phy, also there's a talk by Johan Tibell
15:58:37 <mgsloan> ah, maybe since the the definitions are only being used locally, GHC compiles the monomorphic version?  (this is probably the same as the suggestion to use the SPECIALIZE pragma)
15:58:39 <phy> if you like may be I can post the links to my dropbox for those files
15:58:39 <alpounet> about high performance haskell
15:58:57 <alpounet> you may want to check it out
15:59:14 <alpounet> i don't have the time to take a closer look at the code
15:59:20 <alpounet> may do so tomorrow if you're around
15:59:34 <phy> what about high pereformance haskell
15:59:46 <alpounet> there's a talk about it
15:59:57 <phy> k
16:01:06 <Hail_Spacecake> what is the "import section" of a haskell program?
16:01:09 <Hail_Spacecake> cf. http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing
16:02:05 <acowley> phy: Did you try SPECIALIZE?
16:02:34 <phy> was searching for what it does
16:03:47 <acowley> It lets you ask for versions of a polymorphic function to be compiled at specific types.
16:04:22 <acowley> A nice aspect is that if you mark your library functions as INLINABLE, you can SPECIALIZE in the client module.
16:04:35 <acowley> Although, I thought that you wouldn't need to do so
16:07:26 <rainman1985> ski: Hate to be such a pain, but could we quickly sort out the last questions please? Thanks. :)
16:07:40 <phy> acowley specializing works
16:07:54 <phy> but it's not the nicest thing to do though
16:08:12 <acowley> phy: Can you try using INLINABLE instead of INLINE?
16:08:21 <acowley> phy: and take out the SPECIALIZE
16:08:21 <ski> rainman1985 : you didn't join #haskell-overflow yet ..
16:08:35 <rainman1985> sorry
16:08:36 <rainman1985> I did
16:08:43 <rainman1985> now
16:09:04 <phy> Ok doing it right away
16:09:10 <acowley> phy: I agree that SPECIALIZE is has the smell of C++ about it.
16:09:18 <phy> can we comment out pragmas?
16:09:49 <acowley> What I do is to delete the first #
16:10:02 <acowley> that way it becomes a comment, but is not a pragma
16:11:15 <phy> acowley that  works too
16:11:26 <phy> care to explain the black magic?
16:12:06 <rwbarton> no magic, just that {-# starts a pragma while {- starts a comment
16:12:09 <acowley> phy: A guess is that your functions were big so GHC really didn't want to INLINE them. INLINABLE, on the other hand, makes GHC SPECIALIZE at the call site.
16:12:21 <rwbarton> oh maybe i misunderstood
16:12:40 <homie> oh man
16:12:46 <acowley> phy: In that case, what you wanted to happen was specialization rather than inlining.
16:13:56 <acowley> Before we had INLINABLE, we hit things with INLINE and got on with it.
16:14:23 <phy> ok tell me whether I am right
16:14:54 <acowley> Politically?
16:15:18 <phy> what inlining does to replace the call to function by its body
16:15:43 <acowley> Yes.
16:15:53 <phy> while specializing restricts the functionto particular type
16:16:23 <acowley> Correct.
16:16:28 <phy> or does in restricts the inlined function to particular type?
16:16:49 <rwbarton> it makes a copy of the function, right? that's specialized to the type, and then gets used when the function is called at that type
16:17:14 <acowley> rwbarton: right
16:17:16 <geekosaur> that's my understanding.  the generic one is still there but a type-specialized copy is made, and that can be a candidate for inlining
16:18:10 <phy> so specializing does not imply inlining?
16:18:20 <acowley> It does not.
16:19:11 <acowley> phy: There are lots of knobs to turn here. Take a look at http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#specialize-inline
16:19:54 * roconnor is proving the four colour theorem on his laptop
16:20:41 <acowley> roconnor: how many stickers will you need?
16:21:59 <roconnor> stickers?
16:22:19 <acowley> I figured stickers are a good way to color a laptop. Less mess than paint.
16:22:25 <roconnor> :)
16:22:27 <irene-knapp1> they don't stay on as well
16:22:40 <roconnor> ssrcoq  -q  -dont-load-proofs -I .. -I .   -compile job001to106
16:22:40 <irene-knapp1> you really want enamel paint.  but for the love of nerdery, please use a stencil.
16:22:55 <acowley> ssrcoq?
16:22:58 <roconnor> oops, I should be musing on #haskell-blah
16:22:59 <phy> thanks a lot acowley
16:23:04 <acowley> phy: np!
16:23:23 <roconnor> acowley: ssrcoq is coq with the ssreflect plugin compiled in.
16:24:09 <acowley> Stickers are a great coloring method. Witness the many failed attempts to cheat at Rubik's cube by taking advantage of their perceived lack of permanence.
16:24:15 <irene-knapp1> hahaha
16:24:17 <irene-knapp1> fair enough
16:24:27 <roconnor> building job107to164.vo
16:24:48 <acowley> I've always been scared to invest in SSReflect since it's already hard enough to find Coq examples when you run into trouble.
16:24:50 <roconnor> hmm there appear to be 633 jobs
16:25:02 <roconnor> acowley: I think you are right to be scared
16:25:08 <roconnor> at this point in time.
16:26:17 <roconnor> ssreflect works very well for the tasks it is designed for ... once you get over its very steep learning curve. ... but I'm not even sure it is possible to learn it on your own, though Tim Griffon seems to have.
16:27:38 <acowley> I find learning Coq to be incredibly frustrating if you're not working closely from one of the main books.
16:27:53 <acowley> And even then you end up learning only a slice.
16:29:18 <acowley> The value of blog posts and simple-minded stack overflow questions can not be overstated. With Coq, I typically find an undocumented library someone wrote some years ago that uses a plugin or style that has gone out of vogue.
16:29:56 <roconnor> acowley: I think most Coq developments start from scratch :D
16:30:19 <acowley> Yeah, which is a crippling problem.
16:31:00 <acowley> Although I suppose there is some satisfaction to be had in the first twenty minutes of a project when you begin by defining a boolean type, etc.
16:31:28 <roconnor> it isn't crippling, but it is very bad.  Part of the problem is that interfacing different developments is even harder than it is in Haskell.  In fact it is way harder ... This is something that ssreflect is trying to address ... though I'm not yet certain how successful we are.
16:32:52 <roconnor> In Haskell we have Maybe, List and other Prelude glue, and recently we barely got Bytestring in to glue between projects.  We sort of have mtl-glue but there are monadlib and alternatives.
16:33:32 <acowley> We also have a much more unified sense of idiom.
16:33:51 <acowley> Compare CPDT with SF with Coq'Art
16:34:04 <roconnor> acowley: true, but idioms don't help you share types between projects.
16:34:42 <roconnor> Typeclasses help quite a bit.
16:34:58 <acowley> I think they do. Perhaps not on a technical level, but on a practical level it is hard to marry intended usage between different libraries.
16:35:14 <acowley> For instance, some people go in for functors, other people records.
16:35:18 <roconnor> well we are trying to design very sophisticated typeclases in ssreflect.
16:35:30 <roconnor> to solve the interfacing problem.
16:35:52 <acowley> Well that's another thing, do you know how hard it is to search for documentation for something like `
16:36:07 <acowley> @google coq `
16:36:11 <lambdabot> http://coq.inria.fr/
16:36:11 <lambdabot> Title: Welcome ! | The Coq Proof Assistant
16:36:23 <roconnor> heh
16:36:39 <Costin> hey, we need help testing a phone number: 213-416-1560, access code is 492-302-232# -- can you guys call in?  it's for testing a conference calling platform.
16:36:45 <acowley> roconnor: Please write a "modern coq" tutorial for Haskellers. I'd love to know more about how SSReflect is built.
16:37:24 <roconnor> I'd like to understand it too :D
16:38:32 <roconnor> there are 3 components that make up these sophisticated type classes in ssreflect, yet, I only understand 2 of them :/
16:38:53 <roconnor> (It's nice that I can usually use it without understanding how it works.)
16:39:11 <roconnor> (but I cannot make my own sophisticated type classes)
16:57:05 <WTF> :9
17:04:05 <gurrag> is there such a thing as a "professional" [i.e. paid] Haskell developer?
17:04:52 <gurrag> to put it another way, can one make money coding in Haskell?
17:05:11 <DasIch> Gurrag: yes
17:05:11 <hpc> yes
17:05:43 <gurrag> awesome
17:10:10 <mm_freak> is there something like do-notation for RMonad?
17:10:31 <hpc> RMonad is the ConstraintKinds Monad?
17:10:42 <c_wraith> You can make do-notation work with RebindableSyntax
17:10:47 <hpc> i think you can use ... that
17:10:56 <mm_freak> hpc: yeah
17:11:19 <mm_freak> c_wraith: is there a tutorial?
17:11:48 <c_wraith> I've seen examples of using RebindableSyntax, but I can't remember where
17:11:49 <mm_freak> and do i need to shadow Monad for that?
17:12:19 <mm_freak> hmm‚Ä¶  i'll go with combinators =)
17:13:25 * shapr hugs dstcruz 
17:15:52 <mm_freak> huh?  the rmonad library doesn't even use ConstraintKinds
17:15:53 * ski ghci shapr
17:18:10 <otters> > let f@(1:t) = 1:1:zipWith (+) f t in take 20 f
17:18:11 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
17:18:18 <otters> neat!
17:18:33 <shapr> howdy ski !
17:18:59 <mm_freak> > let f@(1:t) = 1:1:zipWith (+) f t in f
17:19:00 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
17:19:04 <mm_freak> welcome to the lazy world =)
17:19:57 <mm_freak> > fix (\f@(_:t) -> 1 : 1 : zipWith (+) f t)
17:20:01 <lambdabot>   mueval-core: Time limit exceeded
17:20:35 <dmwit> I think he was commenting on the cute trick to avoid calling tail, not on the laziness.
17:20:48 <otters> "cute" indeed
17:20:53 <dmwit> At least, that's what I thought was "neat"! =D
17:20:57 <otters> yeah
17:21:09 <hpc> what i thought was neat was that you could match on '1' there
17:21:10 <otters> I'm trying to figure out how that's even possible
17:21:10 <mm_freak> just wanted to point out that the "take" is equally unnecessary =)
17:21:24 <dmwit> oh, yes =)
17:21:33 <otters> f is a list, but it's defined in terms of itself
17:21:58 <mm_freak> i wonder why the fix variant didn't work
17:22:09 <dmwit> > let f = 1:f in f -- otters, it's quite common, actually
17:22:10 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:22:21 <dmwit> > let f = 1 : map (+1) f in f
17:22:22 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:22:24 <rwbarton> probably just lambdabot moodiness?
17:22:29 <otters> yes, but
17:22:31 <otters> I'm still fairly new to this
17:22:34 <hpc> :t fix (\f@(_:t) -> 1 : 1 : zipWith (+) f t)
17:22:35 <lambdabot> forall a. (Num a) => [a]
17:22:39 <rwbarton> > fix (\f@(_:t) -> 1 : 1 : zipWith (+) f t)
17:22:43 <lambdabot>   mueval-core: Time limit exceeded
17:22:50 <mm_freak> @undef
17:22:50 <rwbarton> hmm
17:22:52 <hpc> strictness
17:23:00 <shachaf> Œª‚ä•
17:23:09 <hpc> > fix (\f -> 1 : 1 : zipWith (+) f (tail f))
17:23:10 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
17:23:17 <rwbarton> oh right, of course
17:23:21 <rwbarton> > fix (\f@~(_:t) -> 1 : 1 : zipWith (+) f t)
17:23:22 <ski> > fix (\f@ ~(_:t) -> 0 : 1 : zipWith (+) f t)
17:23:22 <lambdabot>   <no location info>: parse error on input `@~'
17:23:23 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
17:23:27 <hpc> yeah, that
17:23:31 <mm_freak> oh
17:23:35 <otters> oh no
17:23:36 <otters> why does that work
17:23:45 <hpc> ~ makes it an irrefutable match
17:23:59 <dmwit> Wow, that's subtle.
17:24:02 <otters> so if it can't match
17:24:04 <ski> > let fibs@(_:rest) = 0 : 1 : zipWith (+) fibs rest in fibs
17:24:05 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
17:24:07 <otters> t gets bottom?
17:24:09 <hpc> and defers the actual matching, but gives t a name anyway
17:24:11 <rwbarton> correct
17:24:15 <otters> neato
17:24:28 <otters> okay I need to step back a little bit
17:24:30 <otters> and rethink my life
17:24:30 <rwbarton> let bindings are like that by default
17:24:46 <ski> > let f ~(Just x) = (0,x) in f Nothing
17:24:47 <lambdabot>   (0,*Exception: <interactive>:3:4-22: Irrefutable pattern failed for pattern...
17:24:52 <ski> > let f ~(Just x) = (0,x) in fst (f Nothing)
17:24:53 <lambdabot>   0
17:24:56 <ski> > let f (Just x) = (0,x) in fst (f Nothing)
17:24:57 <lambdabot>   *Exception: <interactive>:3:4-21: Non-exhaustive patterns in function f
17:25:33 <otters> I love laziness
17:25:47 <mm_freak> > let fix f = f (fix f) in fix (\xs'@(_:xs) -> 1 : 1 : zipWith (+) xs' xs)
17:25:48 <lambdabot>   *Exception: stack overflow
17:25:55 <mm_freak> hmm, ok
17:26:09 <hpc> that definition of fix has no sharing
17:26:17 <hpc> hence stack overflow instead of timeouting
17:26:32 <otters> oh, that's why it's defined with a "let"
17:26:34 <otters> I always wondered
17:26:39 <hpc> it doesn't make the connection that f (fix f) = fix f
17:26:54 <mm_freak> i thought the sharing might make a difference, but i was wrong
17:27:04 <mm_freak> that's why i tried it
17:27:26 <dmwit> Sharing never makes a semantic difference, only a speed difference.
17:27:29 <mm_freak> well, it makes sense anyway‚Ä¶  sharing isn't supposed to make a difference =)
17:27:34 <dmwit> (albeit sometimes a dramatic one!)
17:27:44 <hpc> dmwit: or rather, it doesn't make a semantic difference until you run out of memory
17:27:50 <hpc> (operationally)
17:27:54 <dmwit> memory isn't part of my semantics
17:27:55 <dmwit> ;-)
17:28:41 <hpc> argh
17:28:50 <hpc> i want to rewrite my irc bot in haskell again
17:28:57 <hpc> now that i am on a "threads everywhere" binge
17:29:11 <Clint> simpleirc isn't terrible
17:29:15 <otters> don't rewrite, refactor
17:29:20 <dmwit> How did you write an IRC bot without threads everywhere?
17:29:22 <hpc> it's in perl right now
17:29:29 <otters> refactor anyway
17:29:31 <dmwit> oh
17:29:48 <hpc> i wanted it to be self-modifying so i could make minor fixes without spamming quit-joins
17:29:54 <shapr> Has anyone else played with Scotty?
17:29:57 <shapr> @hackage scotty
17:29:57 <lambdabot> http://hackage.haskell.org/package/scotty
17:30:19 <luite> shapr: hm there were some questions on it recently in the #yesod channel
17:30:35 <shapr> luite: Ah, I missed those questions.
17:30:40 <blackdog> shapr: i'm using it for a small piece of ninjablocks
17:30:46 <blackdog> works fine so far.
17:30:52 <shapr> blackdog: Oh, nifty... PS. Saw ninjablocks on Beagleboard's site :-)
17:30:57 <luite> shapr: i forgot who it was, maybe blackdog :p
17:31:09 <mm_freak> scotty seems nice
17:31:39 <mm_freak> but it looks a lot like happstack
17:31:57 <luite> it's a whole lot simpler
17:32:16 <shapr> Though I'm especially interested in the soon to be released layers on top of scotty, namely sunroof.
17:32:40 <shapr> Have you guys seen http://www.ittc.ku.edu/csdl/fpg/node/125 ?
17:32:43 <luite> blackdog: was it you who had a problem with state in scotty, that it was impossible (was it?) to pass around the state that you needed?
17:33:34 <shapr> blackdog: Do you have some demo code you could send my way?
17:33:55 <luite> shapr: hm hadn't seen it
17:34:13 * shapr grabs the scotty repo
17:34:24 <mm_freak> scotty seems to be quite active‚Ä¶  i like its simplicity
17:34:38 <blackdog> luite: no. i'm just passing state in MVars. seems to work fine.
17:34:50 <mm_freak> but i guess for serious applications you want to go with yesod
17:34:59 <luite> shapr: it looks similar to chrisdones thing
17:35:08 <shapr> Which thing?
17:35:37 <luite> hm, what was it called, ji or something?
17:35:42 <blackdog> shapr: i don't think my stuff would be very useful, it's lamost identical to the examples, i think?
17:35:48 <shapr> ok
17:36:18 <BMeph> > let loeb mf = fmap (\f -> f (loeb mf)) mf in loeb [(!!5), const 1, ap (+) (!!0) (!!1), const 0, (`div` 2).(!!6), ap (+) (!!4) (!!2), const 10]
17:36:19 <lambdabot>   Couldn't match expected type `[a] -> a'
17:36:19 <lambdabot>         against inferred type `[a1]'
17:36:30 <BMeph> Pity.
17:36:32 <luite> mm_freak: hm, if it's a wai app, then you can still use your scotty project for part of your site, while you use yesod for the parts that use a database or form validation etc
17:36:59 <mm_freak> luite: you can't really combine WAI applications
17:37:32 <mm_freak> you can make them listen on different ports and use something like nginx to route, but that's not really "using scotty in parts of the app"
17:38:27 <blackdog> mm_freak: i'm writing what i think is a serious app, but it's split into a bunch of interacting pieces - yesod would be overkill
17:39:08 <luite> mm_freak: yesod-static runs wai-app-static as a subsite
17:39:46 <luite> the latter is a wai Application, yesod-static just adds some Route types
17:40:13 <Guest54795> :NICK tungsten
17:40:53 <ski> shapr : hiya
17:41:00 <mm_freak> luite: true
17:43:24 <BMeph> > let loeb mf = fmap (\f -> f (loeb mf)) mf in loeb [(!!5), const 1, ap ((+).(!!0)) (!!1), const 0, (`div` 2).(!!6), ap ((+).(!!4)) (!!2), const 10]
17:43:25 <luite> shapr: i think chrisdone abandoned his ji approach because of limits in scalability and flexibility, and started working on having "real haskell" on the client instead
17:43:27 <lambdabot>   mueval-core: Time limit exceeded
17:44:30 <luite> shapr: haha that's a very recent paper, it uses the new ghcjs url :)
17:46:14 <dmwit> BMeph: cycle detected: index 0 depends on index 5, which depends on index 2, which depends on index 0
17:46:34 <luite> shapr: ooh it's the successor of blank-canvas, cool :)
17:47:46 <dmwit> > let loeb mf = fmap (\f -> f (loeb mf)) mf in loeb [(!!5), const 1, ap ((+).(!!0)) (!!1), const 0, (`div` 2).(!!6), ap ((+).(!!4)) (!!3), const 10]
17:47:47 <lambdabot>   [5,1,6,0,5,5,10]
17:49:55 * BMeph salutes dmwit
17:50:12 <JoeyA> Has anyone proposed a variant of typeclasses that cannot have methods, meaning ambiguity is allowed?
17:50:29 <JoeyA> Perhaps it could be called "newclass"
17:50:37 * ski port salutes BMeph
17:51:51 <JoeyA> (similar to how "newtype" is just type magic, and does not change the representation of its underlying value)
17:56:42 <Polarina> I am trying to make a TCP reverse proxy with conduit but I am not having much luck with getting data through. This is what I have so far: http://codepad.org/AVN3qBVs
18:00:22 <dmwit> JoeyA: Why would that be useful?
18:03:21 <andrewc> hello
18:04:02 <Ralith> JoeyA: newtype doesn't seem very magic to me
18:05:31 <dmwit> andrewc: howdy
18:05:57 <andrewc> im considering learning haskell, but i dunno if there is much practical use
18:06:04 <andrewc> currently i know c, c++ , java and python
18:06:24 <ion> Well, that will make you a better programmer in C, C++, Java and Python.
18:06:29 <geekosaur> mind stretching is always a good thing; even if you can only work in ... that
18:06:37 <andrewc> haskell is good for project euler at least :P
18:06:58 <morolin> andrewc: have you done much functional programming, or taken a good data structures class?  Do you feel productive in the languages that you know?
18:07:18 <andrewc> im doing that tryhaskell.org tutorial at the moment. I feel productive in python haha
18:07:22 <geekosaur> functional techniques are still applicable in all of those (and increasingly so as time goes by; C++ is gradually picking up functional stuff, I expect Java will do so as well)
18:07:23 <cwl> is there an iterateN :: Int -> (a->a) -> (a->a), like iterate but only return the (n-1)th element
18:07:42 <ion> iterate ‚Ä¶ !! n
18:07:57 <cwl> iterateN n f x = iterateN (n-1) (f x)
18:08:07 <cwl> ion: it's slow
18:08:10 <morolin> I've found that Haskell makes you think about some data structures in a way that can be useful for making you a better programmer, but it can also be a pain to learn because of a lot of banalities. If you like up-front debugging, and don't a CS theory background, it can be useful to learn to bend your brain around it.
18:08:21 <morolin> However, I wouldn't learn it just to learn it.  You won't learn it that way. =)
18:08:38 <cwl> ion: visiting element in list at n is O(n)
18:08:42 <rwbarton> ...
18:08:42 <luite> geekosaur: i'd say that most of the effort learning haskell is lost if yo just learn it to apply functional techniques to python, java or c++
18:08:52 <andrewc> haha, im just using it for some maths problems and for fun. btw, how do i get ghci to exit at the end of a script?
18:08:54 <morolin> Pick a project that you want to do that you think could be effectively implemented with more complex data structures than you're familiar with, and then learn haskell to complete that project.
18:08:56 <ion> cwl: Iterating N times is less than O(n)?
18:08:56 <rwbarton> so is applying a function n times
18:09:45 <cwl> ion: nope,but the coefficient is different
18:09:47 <rwbarton> the only overhead is that possibly you create and destroy n cons cells
18:09:51 <JoeyA> andrewc: :q
18:10:01 <hpc> and iterate will fuse
18:10:07 <andrewc> so just put that at the end of the script JoeyA ?
18:10:07 <JoeyA> or :quit
18:10:14 <JoeyA> Yup.
18:10:15 <andrewc> k
18:10:17 <ion> cwl: Did profiling show the difference is significant in your code?
18:10:18 <cwl> ion: it cost another O(n) after the result is computed
18:10:25 <cwl> ion: nope
18:10:36 <JoeyA> andrewc: Why don't you write a program instead of a GHCi script?
18:10:40 <cwl> ion: I don't know how to profile :P
18:10:42 <geekosaur> luite, I disagree, the thought processes are still helpful
18:10:57 <andrewc> because i dont see the point in compiling a thing every time if im just playing around to learn
18:10:59 <cwl> ion: how to do that?
18:11:04 <hpc> cwl: a good ghetto profiler is :set +s
18:11:07 <hpc> in ghci
18:11:09 <JoeyA> andrewc: Run it with runghc
18:11:19 <andrewc> oh ok, thats what i want then
18:11:20 <cwl> hpc: thanks
18:11:24 <andrewc> thanks
18:11:48 <ski> andrewc : typically you write into a file, save it, then `:reload' inside GHCi to get it to catch up, when developing
18:11:55 <hpc> it's not 100% accurate to real compiled code, but it should be enough to show that those cons cells don't matter that much
18:12:24 <monochrom> haskell is in much practical use. some people write web apps. some people write iOS apps. some people implement finance algorithms. you won't hear much about particularly the last one, unless you have access to fairly obscure job postings
18:12:45 <andrewc> right, ski, i guess thats cause haskell doesnt have state so much so your development you can test stuff out more
18:13:16 <luite> geekosaur: people keep saying that, but i still don't see it. i mean, some things you pick up in the beginning, immutability, higher order functions, laziness, can be readily applied, but that's only a very small part of properly learning haskell
18:13:33 <ski> andrewc : there's typically less need for faking a context just to test something, yes
18:14:05 <Yarou_> what is the "proper" way to learn haskell, one wonders
18:14:18 <monochrom> more state => more work to set up pre-test
18:14:28 <ion> yarou: Monad tutorials.
18:14:32 * ion ducks
18:14:35 <Yarou_> i don't think i properly know English
18:14:37 <Yarou_> yet i use it every day
18:14:44 <luite> Yarou_: i mean until the point that you can write large applications in it
18:14:54 <JoeyA> A noun is like a burrito...
18:15:26 * monochrom learned a proper subset of haskell. and a proper subset of english. now that's proper!
18:15:36 <luite> hee
18:15:37 <luite> hehe
18:15:40 <cwl> ion: yes, visiting is slow
18:15:41 <JoeyA> What about the intersection of Haskell and English?
18:16:13 <cwl> ion: sorry, I'm wrong
18:16:25 <geekosaur> luite, you're talking about mechanisms.  I am talking about how you think about problems.
18:16:27 <geekosaur> I will grant that people that dont think about their problems won't gain anything... but it's not clear how much they could gain anyway
18:16:46 <hpc> > (intersection `on` S.fromList) "Haskell" "English"
18:16:47 <lambdabot>   Not in scope: `intersection'
18:16:52 <hpc> > (S.intersection `on` S.fromList) "Haskell" "English"
18:16:53 <lambdabot>   fromList "ls"
18:17:02 <mgsloan> joeyA: I have a plan for that.  You just treat all out-of-scope tokens as comments, and use the type system to resolve fixities
18:17:16 <luite> geekosaur: hm, what do you mean by mechanisms and problems?
18:17:20 <mgsloan> :P (yes, I'm mostly joking)
18:17:24 <ion> > "Haskell" `(S.intersection `on` S.fromList)` "English"
18:17:25 <lambdabot>   <no location info>: parse error on input `('
18:17:25 <cwl> ion: iterate f x !! n is very fast
18:17:30 <ski> hpc : now call `system'
18:17:30 <geekosaur> oh dear
18:17:34 <cwl> faster than iterateN
18:17:48 <hpc> @src iterate
18:17:48 <lambdabot> iterate f x =  x : iterate f (f x)
18:17:50 <geekosaur> luite, on some level I'm having an "if you have to ask" reaction
18:17:52 <cwl> iterateN 1000000 (+1) 0 costs 1.3 secs
18:18:11 <luite> geekosaur: which means "i don't want to explain", right?
18:18:13 <cwl> iterate (+1) 0 !! 1000000 costs 0.69 secs
18:18:32 <JoeyA> > Just $1--that's cheap!
18:18:33 <lambdabot>   Just 1
18:18:56 <rwbarton> are you doing this in ghci or something? both those times are way too high
18:19:24 <ion> cwl: For better benchmarking, use Criterion and compile the code outside ghci.
18:19:27 <cwl> iterateN need to check if n is less than 0, it has two branch
18:19:28 <rwbarton> it should be more like 0.01 s
18:20:09 <JoeyA> iterate (+1) 0 !! 1000000 doesn't evaluate the thunk until the end.
18:20:30 <geekosaur> luite, meaning I am not sure *how* to explain because I am feeling like the point I am trying to make doesn;t have a hook to hang on
18:20:35 <JoeyA> It's forcing the conses of the list returned by iterate, but not the values themselves.
18:20:43 <rwbarton> oh, I guess I had too much faith in the optimizer, iterate (+1) 0 !! 1000000 stack overflows yes
18:20:54 <geekosaur> I am not talking about tools, I am talking about reasoning.  I am hearing back about tools.
18:21:29 <geekosaur> and, sadly, quite often when that happens I find that I am talking to someone who does not reason about problems, they just throw tools at them until they stick
18:22:10 <geekosaur> (not everyone does that, by far, but many programmers do.  it's a largeish chunk of what people here *really* mean when they complain about e.g. Java)
18:22:14 <Yarou_> reasoning is too hard, it requires using your brain
18:22:18 <JoeyA> > let iterate' f !x = x : iterate' f (f x) in iterate' (+1) 0 !! 1000
18:22:19 <lambdabot>   1000
18:22:48 <cwl> ion: why iterateN costs more memory than iterate
18:22:55 <luite> geekosaur: but i eman, you mention thinking about problems. usually when people mean thinking the haskell way, they mean laziness, fold/map, ummutable values. like i said, i think that's only a very small part of learning haskell. i think that if you want to improve your python it would be much more effective to learn those concepts directly in python
18:23:39 <cwl> iterateN 0 f x = x ; iterateN !n f !x = iterate (n-1) f (f x)
18:24:05 <JoeyA> Shouldn't that last iterate be iterateN ?
18:24:40 <luite> geekosaur: (of course doing a lot of programming will probably improve your skill across the board, but i'm just arguing that learning haskell is a particularly ineffective way to improve your python, i could be wrong of course...)
18:24:45 <geekosaur> luite, those are tools.  the reasoning behind them is more important, and more applicable.  learning how to apply that in a given language is also important, but useless if you do not understand the concepts --- and Haskell can make the concepts easier to "reach"
18:24:53 * monochrom does not "reason" about problems. he throws reasoning techniques at problems until they stick. now what are you going to make of it? :)
18:25:06 <shergill> i was just going through oleg's implicit configurations paper. i had a question: what's the benefit of that approach vs, say, using a state monad?
18:25:17 * hpc throws fruit at coworkers until they stick
18:25:26 <hpc> then they are sufficiently grossed out to just do it for me
18:25:30 <geekosaur> I suppose you could argue that last if you are willing to ignore that your other languages do not *force* you to think in terms of equational reasoning, so you can always wimp out of it
18:25:30 <hpc> :D
18:25:31 * ion throws coworkers at fruit until they stick
18:25:52 <geekosaur> (as an example)
18:26:46 <shergill> this is the paper in question: http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf and the associated haskell package: http://hackage.haskell.org/packages/archive/reflection/1.1.5.1/doc/html/Data-Reflection.html
18:28:11 * monochrom is actually serious. Polya's "how to solve it" and Disjktra's "let the symbols do the work" etc. throws problem-solving heuristics at problems. and don't you infer that I learn nothing. I learn after seeing what works. after accumulating enough data / experience, next time I tend to know what to throw first and it will work the first time. that is learning.
18:28:28 * rasfar throws sticks at fruit until they're coworkers (picture snowpeople...)
18:29:45 <monochrom> oh haha, if you throw snoys at fruit until you pile up a snoyman, you get an author of a great web app lib :)
18:31:04 <luite> geekosaur: perhaps i was thinking too much in terms of monad transformers, gadts, type families, iteratees etc after all
18:31:17 * monochrom does not believe in certain unmeasurable definitions of "understanding"
18:32:10 * ski does not believe in certain unmeasurable subsets of `|R^3'
18:32:12 * monochrom believes in the Turing test. if it goofs like a human, it is a human
18:32:31 <JoeyA> I'm looking at Data.Reflection too, and wondering "why not a Reader monad"
18:32:41 * hpc measures understanding in angstroms per (second * liter) ^ (1/15)
18:33:54 <monochrom> on webster's dictionary: intelligence: ... 5. the ability to perform computer functions
18:36:34 <JoeyA> Remind me to never say "Webster's dictionary defines [x] as" anymore.
18:37:22 <ion> @remember hpc * hpc measures understanding in angstroms per (second * liter) ^ (1/15)
18:37:23 <lambdabot> I will remember.
18:38:30 <lpsmith> How do people handle network socket timeouts?    I can think of some hackish ways involving an extra thread and threadDelay and whatnot
18:38:33 <applicative> cwl: Data.Vector.Unboxed has an iterateN
18:39:33 <applicative> main = print $ V.iterateN 1000004  (+1) 0 V.! 1000000 with -fllvm takes 0.011 sec
18:39:45 <JoeyA> lpsmith: System.Timeout.  Though on Windows, you hang yourself instead.
18:40:12 <rwbarton> heh, my estimate 0.01 s was pretty close :)
18:40:33 <JoeyA> In all seriousness, for Windows, see my writeup about it here: http://hackage.haskell.org/packages/archive/network-socket-options/0.2/doc/html/Network-Socket-Options.html#g:6
18:41:08 <lpsmith> JoeyA, thanks
18:41:21 <JoeyA> lpsmith: Is this for a PostgreSQL connection socket?
18:41:39 <lpsmith> no
18:41:43 <JoeyA> Oh, okay.
18:42:05 <lpsmith> Actually,  timeout is implemented how I thought...
18:42:07 <JoeyA> For network operations going through GHC's IO manager, the link I posted is relevant.
18:42:29 <applicative> lpsmith: I started making a special package for you  https://github.com/michaelt/modules/blob/master/Modules.hs
18:42:54 <lpsmith> applicative, :)
18:45:24 <lpsmith> JoeyA, though I have thought about moving postgresql-simple to GHC's IO manager instead of kernel threads.
18:45:27 <applicative> it seems those modules dont clash at all
18:45:50 <lpsmith> problem is I tend to use qualified imports pretty aggressively
18:45:55 <lpsmith> this doesn't quite work for that.
18:46:14 <JoeyA> lpsmith: You mean by using async calls and threadDelay?
18:46:21 <JoeyA> (err, the PostgreSQL async API)
18:46:32 <lpsmith> well, not threadDelay, but threadWaitRead/threadWaitWrite.
18:46:36 <lpsmith> yes
18:47:21 <lpsmith> Problem is I don't really have a high-concurrency postgres app to test with, to see if it's really worthwhile
18:47:54 <lpsmith> probably webapps with connection pooling would be decent test-bed.
18:48:30 <lpsmith> or rather, any app that has a large-ish number of connections pooled in a similar fashion
18:50:46 <JoeyA> Right
18:52:05 <lpsmith> Well, the fact that we can't use System.Timeout with postgresql-simple at the moment is a good argument for the move
18:52:30 <lpsmith> regardless of other performance considerations
18:52:40 <JoeyA> lpsmith: Thanks for picking up my recent pull request.  (github never sent me a notification)
18:52:57 <lpsmith> oh,  no problem
18:56:07 <lpsmith> actually, the app I am working on could use timeouts on postgresql sockets,  although it's not critical at the moment because the connection is going over a higher-end and well configured LAN;  if the connection is cut (which could happen) it _should_ fail pretty quickly,  instead of having to worry about timeouts
18:56:28 <lpsmith> that aspect isn't tested yet though
18:56:50 <lpsmith> though I can see situations where I'd need timeouts,  maybe somewhere down the future.
18:57:22 <JoeyA> I suppose you could set socket options.
18:57:58 <lpsmith> ehh,  maybe.   I'd rather make what I need async, managed by GHC
18:58:06 <JoeyA> (the socket options API in Network.Socket is broken, since it doesn't account for varying representations of option values)
18:59:02 <lpsmith> Well, thanks for giving me a good justification for moving to async and GHC's IO manager  :)
18:59:46 <lpsmith> Not my highest priority at the moment,  but hopefully I can get to that in a few weeks.
18:59:51 <JoeyA> Or just use my network-socket-options package ;-)
18:59:58 <lpsmith> lol
19:03:10 <JoeyA> Note that threadWaitRead currently doesn't work for sockets on Windows: http://hackage.haskell.org/trac/ghc/ticket/5797#comment:5
19:18:47 <illissius> I don't suppose anyone is awake at this hour, but anyone know what's up with http://hpaste.org/68307 ?
19:19:10 <illissius> e.g. whether the problem is known, whether it's been fixed, whether it's on my end, etc.
19:22:28 <applicative> illissius: funny, it doesn't happen with me i'm using ghc-4.1.2
19:23:06 <rwbarton> 4.1.2, really?
19:24:18 <siracusa> probably incompatible packages
19:24:58 <applicative> The Glorious Glasgow Haskell Compilation System, version 7.4.1.20120508
19:25:23 <applicative> lost and gained a few digits there
19:25:57 <illissius> I'm on 7.4 too, though probably not as new
19:27:15 <illissius> incompatible packages is my suspicion too but I don't want to bother edwardk with it if I don't know whether it's something on my end and/or whether 213 people have already bothered him about it
19:27:59 <rwbarton> I assume you've done a cabal update?
19:28:07 <illissius> rwbarton: yes
19:28:15 <applicative> Control.Monad.Trans.Identity has the instance alright
19:29:27 <hpaste> applicative annotated ‚Äúsemigroupoids‚Äù with ‚Äúsemigroupoids (annotation)‚Äù at http://hpaste.org/68307#a68659
19:29:52 <applicative> its this ^^^ there is some disagreement with your transformers?
19:30:41 <applicative> this is a little  confusing
19:31:51 <RylandAlmanza> Can someone tell me how to fix this? The function should take the list length as a parameter, and generate a list of random Booleans with a length of t.
19:31:54 <hpaste> RylandAlmanza pasted ‚ÄúList of random Bools with a length of t‚Äù at http://hpaste.org/68660
19:31:56 <illissius> I seem to have 0.3.0.0
19:32:04 <applicative> i have transformers-0.3.0.0
19:32:10 <applicative> hmm
19:32:28 <rwbarton> random thought: what if you add transformers-0.3.0.0 to the cabal install line
19:33:24 <applicative> maybe, do you have another transformers?
19:33:27 <rwbarton> RylandAlmanza: you shouldn't use System.Random like this, it won't be very random at all
19:34:00 <rwbarton> RylandAlmanza: use randoms instead
19:34:13 <RylandAlmanza> rwbarton: Got an example handy?
19:34:13 <illissius> rwbarton, doesn't seem to make a difference
19:34:20 <rwbarton> @type randoms
19:34:21 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
19:34:26 <illissius> is there any clean way to just wipe all my installed packages and start fresh?
19:34:28 <applicative> RylandAlmanza: i was going to say, randoms
19:34:31 <rwbarton> > take 10 (randoms (mkStdGen 17)) :: [Bool]
19:34:32 <lambdabot>   [True,False,True,False,False,True,True,False,False,True]
19:34:50 <applicative> hah, i just did it illissius
19:35:04 <RylandAlmanza> woah
19:35:06 <Eduard_Munteanu> illissius: you kinda have to kill ~/.cabal and ~/.ghc (assuming you didn't do global installs)
19:35:10 <RylandAlmanza> so much better than my code
19:35:24 <illissius> Eduard_Munteanu: I think I did, though.
19:35:26 <Eduard_Munteanu> Erm, and assuming Windows :)
19:35:33 <illissius> also Linux :)
19:35:34 <rwbarton> randoms produces an infinite list of random values
19:35:35 <Eduard_Munteanu> s/Windows/Linux
19:35:37 <RylandAlmanza> rwbarton: Did the 17 just come off the top of your head, or is there a reason you picked it?
19:35:38 <illissius> right.
19:35:43 <Eduard_Munteanu> Sorry, strange typo :)
19:35:44 <rwbarton> using the specified starting state
19:35:48 <illissius> braino
19:35:55 <rwbarton> I just picked it arbitrarily
19:36:03 <RylandAlmanza> ok, thanks
19:36:19 <applicative> rwbarton knows that 17 is *the* random number
19:36:58 <otters> > take 10 (randoms (mkStdGen 17)) :: [Bool]
19:36:59 <lambdabot>   [True,False,True,False,False,True,True,False,False,True]
19:37:03 <Eduard_Munteanu> Dunno how global installs work though, I only do distro installs for global stuff.
19:37:13 <applicative> when i was a student, math professors used it, 'its true of 17' was a funny way of saying its true generally
19:38:29 <illissius> applicative: you mean you wiped your packages? same as Eduard_Munteanu, or do you happen to know what to do about global ones?
19:38:31 <Eduard_Munteanu> Well, none of those are remotely true random, not even in the initial seed.
19:38:44 <JoeyA> "When life and love are new"  It's true of 17
19:40:12 <applicative> illissius: actually i got rid of everything and installed the speculative ghc-7.4.2 binary for osx
19:40:47 <illissius> oh, hm. I wonder if I still have the installer around
19:41:55 <applicative> illissius: this muddle with semigroupoids doesn't seem like devastating proof of disaster...
19:42:03 <applicative> not that i can figure it out
19:42:51 <applicative> illisius, did you install the global ones with your package manager?
19:43:08 * Eduard_Munteanu erases the locally-installed cabal stuff pretty often
19:43:16 * applicative too
19:43:40 <illissius> applicative: what do you mean by disaster? and no, no package manager, just cabal, but both global and local
19:43:45 <applicative> i keep the haskell platform sacred, global etc
19:44:15 <applicative> hmm, do you need to do `cabal install --global`?
19:44:36 <illissius> I honestly have no idea :)
19:44:43 <applicative> i mean because theres more than one user
19:45:04 <illissius> there aren't. it's better to stick to local installs in that case?
19:45:23 <applicative> have you read monochrom's explanation i think it may be a little out of date but i adopted his idea
19:45:43 <applicative> http://www.vex.net/~trebla/haskell/sicp.xhtml
19:46:41 <applicative> the idea is you get everything you'll ever need from your package manager all at once.  then only use cabal install --user (the default)
19:46:45 <illissius> I should probably use cabal-dev or something but I haven't mustered the arseability to learn it
19:47:03 <applicative> yes, i use cabal dev but am still a noob
19:47:15 <rwbarton> this is like what I do, except I just use the binary installer from the GHC web site and cabal install --user everything
19:47:40 <applicative> that's what i do on os x.
19:48:13 <applicative> the haskell platform installer is too out of date, but i  would do that with it
19:48:39 <illissius> applicative: re: link, I think I saw it but haven't read it -- might do so now. thanks
19:49:00 <applicative> it's helpful even if you don't buy it, as i think many dont
19:49:24 <applicative> it used to be that arch was so up to date you could in theory only ever use pacman
19:49:41 <monochrom> haha!
19:49:50 <Eduard_Munteanu> Mm, last time I looked at arch it didn't have a lot of Haskell-related packages.
19:49:57 <applicative> speak of the devel and his imp appears
19:49:59 <Eduard_Munteanu> New, yeah, just not a lot.
19:50:29 * monochrom is not a devel or devil!
19:50:45 <applicative> i didn't have a problem, but in the end i broke everything from general unix incompetence :)
19:51:27 <illissius> devel : devil :: daemon : demon?
19:51:48 <monochrom> hahaha
19:51:55 <applicative> monochrom, or monochrom-devel
19:52:27 <applicative> i told illissius to read your screed on cabal , monochrom -devel
19:52:54 <Eduard_Munteanu> Is that lan -san for Japanese? :P
19:53:01 <Eduard_Munteanu> s/lan/like/
19:53:09 <applicative-stab>  applicative-stable is too  long?
19:53:25 <illissius> stab is fine too
20:08:47 <illissius> woo. finally managed to wipe and reinstall things properly. and I still get the same error with semigroupoids.
20:12:17 <applicative> does ghc-pkg list show any other versio n of transformers?
20:14:42 <illissius> nope
20:16:52 * applicative , at this point, would start butchering the offending file in semigroupoids
20:18:30 <illissius> applicative: you said you also have GHC 7.4 and transformers 0.3.0.0, and semigroupoids installed fine?
20:18:56 <lpsmith> illissius, what error?   GHC 7.something introduced <> into Data.Monoid which clashes with semigroupoid
20:19:22 <lpsmith> Besides, I tend to redefine (++) a la caleskell anyway
20:19:25 <lpsmith> :t (++)
20:19:26 <lambdabot> forall m. (Monoid m) => m -> m -> m
20:19:29 <applicative> yeah, but i have whatever is most recent to be packaged as a binary 7.4.1.2xxx, dont  know if that matters
20:19:33 <illissius> lpsmith: nah, not that. Foldable/Traversable instance clash with transformers
20:19:46 <illissius> http://hpaste.org/68307
20:20:04 <applicative> lpsmith will figure it out :)
20:21:02 <illissius> but yeah, going by the #if in Data.Traversable.Instances this is not supposed to happen so I don't get it either
20:21:56 <applicative> yes its like something is going wrong with the cpp
20:23:25 <applicative> maybe you should just comment the line out in the .cabal file and have done with it
20:23:40 <dabblego> I use (<>) from Data.Semigroup
20:24:34 <applicative> > text "hello" <> space <> text "dabblego"
20:24:35 <lambdabot>   hello dabblego
20:24:36 <lpsmith> yeah, that is odd
20:24:47 <lpsmith> and I'm no expert on the haskell build process :-/
20:25:27 * applicative uses Text.PrettyPrint.<>
20:25:32 <illissius> could my cabal-install being oldish matter at all?
20:25:55 <applicative> illissius: i was wondering about that too.  I installed the new cabal-install today too
20:26:21 <applicative> but its hard to see how it could matter.
20:26:50 <illissius> doesn't cabal-install just runghc Setup.hs files, which in turn use the Cabal library that came with GHC?
20:28:13 <irene-knapp1> not exactly
20:28:27 <applicative> no, my old cabal does right
20:28:31 <irene-knapp1> it compiles Setup.hs files into a binary (hidden away in dist/) and then execs that binary
20:28:44 <irene-knapp1> this is usually what you want as it ensures that the latest available version of the Cabal library will be used
20:29:02 <irene-knapp1> but if you are maintaining Cabal itself it's a pain because it's another way to have a stale copy
20:30:01 <luite> what's the best way to let it use a nonstandard cabal library (say from a Cabal-mygreatpatch package)?
20:30:03 <clinton> I'm getting the following error when trying to install ixset: "cabal: Couldn't read cabal file "ixset\\1.0.3\\ixset.cabal"
20:30:11 <clinton> any idea how to solve it?
20:31:02 <irene-knapp1> luite: well, it depends on whether you're doing it on a really regular basis
20:31:28 <irene-knapp1> luite: if you just need it once or twice, you can install the Cabal-mygreatpatch package, right
20:31:54 <irene-knapp1> it might be possible to add that package in build-depends (little-known fact that the build-depends libs are also available to Setup.hs, hence at configure-time)
20:32:19 <irene-knapp1> but I suspect it would have symbol clashes with generic Cabal so you'd have to resolve that issue somehow
20:32:30 <luite> irene-knapp1: it's for installing existing pacakges, so it'd have to be done without modifying the .cabal
20:32:53 <irene-knapp1> okay.  if you need or want it for every package on your system, another option is to let the -mygreatpatch thing replace the Cabal library in the user or global package repo.
20:32:58 <irene-knapp1> by giving it the same name
20:33:02 <irene-knapp1> your package repo will show up as broken
20:33:20 <luite> hm i don't think that's a great solution...
20:33:23 <irene-knapp1> but in practice it will continue to work, and you can un-break it by reinstalling the version of Cabal that came with GHC
20:33:23 <irene-knapp1> yeah
20:33:31 <irene-knapp1> the truly-long-term solution is to fork Cabal
20:33:56 <irene-knapp1> because I needed to make my package reliably buildable, and it was clear that it would never be so without patches which were never going to be accepted into mainline Cabal, that's what I eventually did
20:33:58 <irene-knapp1> mine is called Faction
20:34:10 <irene-knapp1> there are a ton of places in the source that the name has to be changed so it can coexist with standard Cabal
20:34:19 <otters> nful
20:34:22 <irene-knapp1> it wasn't fun
20:34:27 <otters> mm, good old x-chat
20:34:39 <otters> why *wouldn't* you want focus to switch to a new tab when you get connected, regardless of what you're doing with other tabs?
20:34:40 <luite> (real use case: ghcjs must install .js files with Cabal, the current lib doesn't support it, there's a Cabal patch ready, but i'd like to let ghcjs use a forked version for a while until the changes can be merged back into Cabal)
20:34:45 <irene-knapp1> oh, hmmmm
20:35:03 <irene-knapp1> okay, then if I were in your situation I'd do the break-the-package-repo approach
20:35:37 <irene-knapp1> the practical implications of breaking the repo are almost none, and it's possible to reinstall the standard GHC version when you want to revert, by copying the control file back into place and recaching
20:36:04 <irene-knapp1> the only case where a broken repo matters that I'm aware of is when you are trying to install a package which depends on a broken package
20:36:12 <irene-knapp1> but almost nothing depends on the Cabal library, oddly :)
20:36:58 <luite> hmm, that'd be a bit tricky since when the Cabal lib and cabal-install are built with different versions, you can run into trouble with generated files... i think :)
20:37:21 <irene-knapp1> oh, yeah, I've always done it with installing both the Cabal lib and cabal-install at the same time and from the same tree
20:37:29 <irene-knapp1> you install the Cabal lib first, then cabal-install
20:37:43 <irene-knapp1> for bonus points you can use the very cabal-install that you are replacing to do the installs :)
20:37:51 <irene-knapp1> which saves you running the bootstrap script :)
20:38:13 <luite> ooh, cabal-install has a --cabal-lib-version command line options
20:38:16 <irene-knapp1> oh cool!
20:38:27 <irene-knapp1> I wonder if that's new
20:38:40 <luite> could be, i have 0.14
20:38:43 * irene-knapp1 nods
20:50:45 <RylandAlmanza> Ok, I've been staring at my text editor trying to figure out how to do something in haskel for about an hour now. Anyone have some free time and patience?
20:51:46 <RylandAlmanza> I've got a list of lists (Yes, I know this is inefficient. I'll worry about that later,) to represent a 2d tilemap
20:52:41 <RylandAlmanza> And it's a list of lists of bools [[Bool]]
20:53:28 <RylandAlmanza> I need a function that, given the list, an x value, and a y value, counts all of the cells around it that are True
20:53:55 <RylandAlmanza> I can supply working OOP code if needed
20:54:08 <m_stone> bos: thank you again for the help yesterday -- the new withString is really very pleasant to use.
20:54:16 <ben> are you implementing the game of life? :)
20:54:24 <bos> m_stone: cool
20:55:52 <RylandAlmanza> ben: Almost. I'm implementing a cave generating algorithm with cellular automata
20:56:09 <ben> is the list of list a list of rows or a list of columns?
20:56:12 <m_stone> bos: the good news is that, this morning, I was able to get enough of my compiler implemented to run it against my test suite.
20:56:24 <m_stone> bos: the bad news is that only about *half* the tests pass.
20:56:31 <bos> ;-P
20:56:39 <m_stone> the most interesting failure so far concerns integer comparisons.
20:56:52 <m_stone> the comparisons pass for negative integers and for zero but not for positive integers.
20:57:06 <rwbarton> how about, (1) write a function that takes x and y (possibly not in bounds of the array) and returns True if there is a cell with True at position (x, y), (2) write a function that given a cell (x, y), generates the list of eight (four?) adjacent positions, (3) use some filter and map and length
20:57:23 <RylandAlmanza> ben: Rows. So, if x = 10, and y = 13, you would access it backwards (list!!13!!10
20:58:03 <RylandAlmanza> )
20:59:15 <m_stone> the setup is that, on one side, I do "%2 = alloca i64; store i64 1, i64* %2" and on the other, I do "%3 = alloca i64; call i32 @0(i32 1, i8* %0, i32 %1, i64* %4)"
20:59:25 <ben> yeah, i'd probably start with length . filter id . concat ... and then figure out the corner cases when x/y = 0/width/height
21:00:22 <clinton> For the benefit of anyone reading these logs regarding the 'ixset' error I was receiving: "cabal install cabal-install-0.14.0" fixed the problem.
21:00:30 <m_stone> the call on the right-hand side calls parses a string into an Int64 with (readSigned readDecimal), then pokes the result into the i64* that it receives when called.
21:01:38 <m_stone> bos: the fun bit is that, when I load %2 and %3 and send them both to an (Int64 -> IO ()) staticFunction that calls print on them, they come out differently.
21:02:17 <m_stone> bos: specifically, the left-hand one prints decimal(0x0100000000000000) while the right one prints out 1
21:05:10 <m_stone> bos: I confess that I am at somewhat of a loss as to how to debug this one further. :-)
21:09:11 <bos> m_stone: don't really have time to help, i'm afraid
21:09:25 <bos> m_stone: have you tried just writing the bitcode out by hand and running it?
21:09:45 <m_stone> bos: some, but I can do so some more.
21:12:16 <m_stone> bos: anyhow, thanks for listening!
21:12:24 <bos> sure
21:19:25 * hackagebot shelly 0.9.0 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.9.0 (GregWeber)
21:29:22 <hpaste> ramier pasted ‚Äúimporting‚Äù at http://hpaste.org/68661
21:29:43 <ramier> why doesn't my code snippet work? i can't import my own module
21:30:10 <ramier> whenever i load, i get Poker/Random.hs:5:9: Not in scope: data constructor `Clubs'
21:30:34 <ramier> err, 'Five' in this case
21:30:47 <MasseR> You haven't imported the module where Clubs etc are declared
21:30:52 <MasseR> Or perhaps exported those names
21:31:06 <rwbarton> is most of Poker.Base omitted from the paste?
21:31:10 <ramier> yea
21:31:14 <ramier> it's longer than just that
21:31:56 <rwbarton> looks fine to me...
21:32:15 <ramier> hmm, and in ghci i just do :l Poker.Random and i get
21:32:21 <ramier> [1 of 2] Compiling Poker.Base       ( Poker/Base.hs, interpreted )
21:32:22 <ramier> [2 of 2] Compiling Poker.Random     ( Poker/Random.hs, interpreted )
21:32:23 <ramier> Poker/Random.hs:7:9: Not in scope: data constructor `Five'
21:32:24 <ramier> Failed, modules loaded: Poker.Base.
21:33:52 <ramier> im an idiot disregard everything above
21:34:25 * hackagebot prelude-generalize 0.3.1 - Another kind of alternate Prelude file  http://hackage.haskell.org/package/prelude-generalize-0.3.1 (AaronBlack)
21:59:05 <hpaste> liyang pasted ‚ÄúreadSampleVar broken?‚Äù at http://hpaste.org/68664
21:59:36 <liyang> Am I not understanding how SampleVars ought to behave, or is that a bug?
22:08:15 <RylandAlmanza> rwbarton: Still here? I'm stuck at this step: "write a function that given a cell (x, y), generates the list of eight (four?) adjacent positions" I'm having a really hard time grasping how to do things recursively. Here's how I would do it in c++:
22:08:19 <hpaste> RylandAlmanza pasted ‚ÄúHow I would do it in C++‚Äù at http://hpaste.org/68665
22:11:33 <rwbarton> you don't need to use recursion at all for this step, you can just list them if you like
22:11:48 <rwbarton> neighbors (x, y) = [(x-1, y-1), (x-1, y), (x-1, y+1),  -- ...
22:12:00 <rwbarton> or you could use a list comprehension
22:15:01 <rwbarton> In fact, you could reasonably write that whole function with a list comprehension + length
22:15:36 <RylandAlmanza> rwbarton: I know that I don't need to use recursion, but I would like to if possible just so I can get used to it. For example, what if I wanted to get all the cells within 3 cells of the cell I specifiy? I wouldn't have to write that all out manually, would I?
22:16:02 <rwbarton> well
22:16:07 <rwbarton> you can use things like [x-3..x+3]
22:16:17 <rwbarton> > [3..9]
22:16:18 <lambdabot>   [3,4,5,6,7,8,9]
22:16:30 <rwbarton> you can implement that using recursion yourself if you like
22:16:42 <rwbarton> real Haskell programs often don't use much explicit recursion
22:17:17 <RylandAlmanza> really? I got the idea somewhere that recursion in haskell was used as much as loops in other langauges
22:17:49 <rwbarton> ultimately the functions that are commonly used are implemented using recursion
22:17:54 <shachaf> That's a pretty vague statement.
22:18:21 <shachaf> Is "for x in xs; ...x...; end" in Ruby a loop?
22:19:14 <geekosaur> one hopes you mean xs.each { |x| ... }
22:19:18 <rwbarton> (I don't speak Ruby, does that secretly mean map?)
22:19:49 <dolio> No.
22:20:25 <MasseR> rwbarton: I think usually those each, foreach etc functions are like map, but ran for their side-effects
22:20:53 <shachaf> geekosaur: Well, I was disguising it a bit. :-)
22:21:21 <rwbarton> "if it matches /^(for|while|do) .*/, it's a loop"
22:21:21 <shachaf> (for_in_ is syntax for _.each{|_| } .)
22:22:04 <shachaf> The point is that "loop" is just a word, and "loop vs. recursion" is an implementation detail anyway.
22:49:39 <sopvop> Hello #haskell
22:49:52 <Enigmagic> omghi2u
22:52:02 <sopvop> So, what would be better: data UserID = UsedID Text, or newtype UserID = UserID Text? newtype is safer, right?
22:52:55 <strager> I dunno about 'safer', but it certainly makes the intent of "I'm wrapping a value for type safety" clearer.
22:53:14 <donri> sopvop: newtype is generally preferred where it is possible. i tend to stick to data types if i thikn it might be necessary later on. that doesn't really apply to user ids though.
22:54:29 <donri> (there are reasons newtype isn't automatic for data, though i don't fully know them)
22:57:06 <ramier> my poker hand evaluator can generate and evaluate 3 million hands a second
22:57:53 <adu> wow
22:58:25 <adu> ramier: if I give you some conditions for 7-card hands, can you tell me how rare they are?
22:58:30 <sopvop> from haskell wiki: data can only be replaced with newtype if the type has exactly one constructor with exactly one field inside it
22:59:02 <ramier> oooh, that's my next project, see if my evaluation probabilities match real probabilities
22:59:27 * hackagebot keter 0.1 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-0.1 (MichaelSnoyman)
23:02:19 <adu> ramier: For example: 2/2/2 (triple pair), 2/2/3 (full house + pair), 2/5 (‚Ä¶ + pair), 2/4 ("crack house"), 3/4 ("full castle"), 3/3 ("two triples")
23:03:11 <adu> given such combos, what is the probability of getting a "straight and a pair"?
23:05:58 <ramier> um, i have to write a bunch more code
23:06:03 <adu> ok
23:06:06 <ramier> ill get back to you in a few
23:06:14 <adu> days?
23:06:19 <ramier> ?!
23:06:19 <lambdabot> Maybe you meant: . ? @ v
23:06:46 <adu> a few what?
23:06:53 <ramier> a few long periods of time
23:06:56 <adu> heh
23:07:21 <ramier> i think im going to spend the time learning about applicative functors
23:08:32 <DarthArachides> @list
23:08:32 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
23:09:08 <DarthArachides> source chaff
23:10:28 <DarthArachides> type fmap read
23:10:33 <DarthArachides> @type fmap read
23:10:34 <lambdabot> forall a (f :: * -> *). (Read a, Functor f) => f String -> f a
23:10:37 <DarthArachides> @source chaff
23:10:38 <lambdabot> chaff not available
23:11:45 <ramier> i just realized that the way i wrote my card deck randomization, take 5 $ randomDeck actually takes advantage of the laziness and doesn't create a full randomDeck!
23:11:55 <ramier> !!!!
23:12:31 <adu> :)
23:12:54 <adu> not even the computer knows what's next
23:13:48 <ramier> that's why it was quicker than i thought; it doesn't need to generate 3 million random decks, just 3 million (take 7 randomDeck)
23:30:42 <mikeplus64> with attoparsec, is the "best" way to match a word simply takeTill (== ' ') ?
23:30:52 <mikeplus64> (best meaning best performance)
23:40:50 <RylandAlmanza> AH! I've done it! I've counted the adjacent living cells! And it only took me a few hours! lol, thanks, rwbarton
23:52:44 <phryk> I'm trying to figure out quasiquotation‚Ä¶ Both RWH and LYAH don't say anything about them, the page on the haskell wiki tells me how to define my own quasiquoters, and I don't find the wikipedia page on quasi-quotation isn't really helping me either. Basically all I want to know is what an expression like '[foobar|Some other String|] means‚Ä¶
23:55:19 <arcatan> phryk: it runs Some other String through the quasiquoter foobar, which generates a Haskell syntax tree based on it
23:55:42 <ibid> wwhat it means depends on foobar :)
23:56:06 <phryk> arcatan: So it can do anything?
23:56:08 <arcatan> you could have a s-expression quasiquoter and then say [sexp|(foo bar)] and it could mean the same as List [Atom "foo", Atom "bar"] or something like that
23:56:40 <arcatan> for various definitions of anything, yeah. (it is run at the compile time)
23:57:49 <phryk> Ah so it's just a code generator‚Ä¶? I Initially thought quasiquoters were more like lisp macros‚Ä¶
23:58:32 <ibid> not code generator in the normal sense of the word
