00:00:44 <dcoutts_> guest__: other-extensions: DefaultSignatures
00:02:26 <guest__> dcoutts_: excellent! thanks.
00:03:14 <dmwit> dcoutts_: That's not in the documentation...
00:04:04 <opqdonut> hmm, weird
00:04:10 <opqdonut> i have something like "fb n = a `par` (b `pseq` a+b)"
00:04:18 <opqdonut> when I look at -ddump-simpl, the pseq has disappeared
00:04:30 <opqdonut> (and most times I run the code, the spark fizzles)
00:04:58 <opqdonut> if I write the equivalent code in the Eval monad, I reliably get a converted spark
00:06:11 <guest__> dcoutts_: hmm.. I've got "cabal-install version 0.14.0 using version 1.14.0 of the Cabal library"
00:06:25 <guest__> dcoutts_: but it complains: Unknown extensions: DefaultSignatures
00:06:30 <guest__> dcoutts_: still builds though..
00:06:40 <guest__> dcoutts_: is there a newer cabal; I thought that was the latest
00:10:45 <opqdonut> oh, hmm, maybe the pseq just gets inlined
00:11:20 <opqdonut> the spark does get converted even with the par-pseq version if I make the input slightly bigger
00:15:21 <guest__> dcoutts_: According to this: http://hackage.haskell.org/packages/archive/Cabal/1.14.0/doc/html/Language-Haskell-Extension.html
00:15:35 <guest__> dcoutts_: DefaultSignatures didn't quite make it to cabal hackage release
00:15:48 <guest__> dcoutts_: maybe it's in the dev version
00:17:35 <isson> hello.
00:18:00 <isson> i am sorry that i am not good to speak englsi. i have a question.
00:18:09 <isson> english
00:18:45 <opqdonut> does anyone know where the spark classification (converted,pruned,fizzled,dud,overflowed) is documented? the ghc manual only talks of converted and pruned
00:19:00 <isson> lambda function..like (\x -> x + 1) ..
00:19:25 <dcoutts_> guest__: looks like the ghc devs did not register it yet, perhaps they think it's not ready for publicly distributed packages
00:19:28 <isson> i think it is a expression that returns function .
00:19:41 <isson> is right?
00:25:56 <Eduard_Munteanu> isson: can you rephrase that?
00:26:08 <mm_freak> absence: note the difference between () and forall a. a
00:26:11 <Eduard_Munteanu> What is an expression?
00:26:19 <Eduard_Munteanu> Oh.
00:26:35 <mm_freak> absence: you can pass () to a wire expecting a fully polymorphic input
00:26:35 <Eduard_Munteanu> isson: it is an anonymous function
00:27:04 <isson> hmm...
00:27:05 <Eduard_Munteanu> :t (\x -> x + 1)
00:27:06 <lambdabot> forall a. (Num a) => a -> a
00:27:12 <Eduard_Munteanu> > (\x -> x + 1) 2
00:27:13 <lambdabot>   3
00:27:19 <mm_freak> absence: in your application you would unify 'a' with ()
00:27:39 <isson> hmm...
00:27:44 <isson> "->" is operator ?
00:28:12 <isson> or syntactic constructor ?
00:28:12 <Eduard_Munteanu> isson: it's language syntax
00:28:26 <isson> oh... thanks.
00:28:44 <Eduard_Munteanu> Well, it depends on the context. In types, (->) does behave like an infix operator.
00:28:58 <Eduard_Munteanu> (->) a b   ===    a -> b
00:29:18 <Eduard_Munteanu> But the meaning is completely different.
00:29:27 <Eduard_Munteanu> (in that case)
00:29:53 <dmwit> isson: Yes, (\x -> x + 1) is an expression that returns a function.
00:29:58 <isson> i don't understand "lke an infix operator" , it means it is a operator in that context ?
00:30:08 <dmwit> isson: And in that expression, (->) is not an operator. =)
00:30:24 <dmwit> isson: Yes, in types, (->) is an operator.
00:30:41 <dmwit> Int -> Int can also be written (->) Int Int if you prefer.
00:31:25 <dmwit> (In comparison: "(->) (\x) (x + 1)" doesn't make sense.)
00:32:01 <isson> thanks dmwit. i can understand it now.
00:32:19 <dmwit> \o/
00:37:48 <absence> mm_freak: yes, that's what i don't understand. my wire expects a fully polymorphic input (i think, readerWire :: MyWire3 a Double) but when i pass () to it, or "", i get the error message i mentioned
00:43:21 <RylandAlmanza> I'm trying to use this library: http://hackage.haskell.org/packages/archive/AC-EasyRaster-GTK/1.1.3/doc/html/Graphics-EasyRaster-GTK.html
00:43:46 <RylandAlmanza> It has a wait_event function, that returns IO ()
00:44:07 <RylandAlmanza> I'm not quite sure how to get data from that. Is it even possible?
00:44:08 <mm_freak> absence: could you paste the relevant portions of the code?
00:44:26 <flux> rylandalmanza, you cannot. probably there is some other function to get the actual event.
00:44:32 <flux> or maybe it uses callbacks
00:44:39 <flux> all this without looking at the documentation :)
00:46:49 <absence> mm_freak: http://hpaste.org/68875 (the ill-named "event" is a wire of course)
00:47:21 <RylandAlmanza> thanks flux. Also, is there any other graphics library which would let me manipulate individual pixels? SDL took a lot of work just to change the color of a pixel, and it doesn't work on mac. gtk is easier, but it's hard to install on windows.
00:48:07 <luite> it doesn't?
00:48:26 <RylandAlmanza> luite: That's what I've heard. Haven't actually tried it on a mac
00:48:45 <flux> I'm surprised to hear Gtk is simpler for putpixel than sdl
00:48:52 <RylandAlmanza> I usually use linux, but I like my apps to be cross platform
00:49:05 <luite> oh that would be disappointing, is it just the haskell bindings? it looks like they have downloads for OS X
00:49:22 <RylandAlmanza> Yeah, just the haskell binding
00:49:37 <flux> Sdl has for some time come with pixel access functions, but they are in the sdlgfx library. maybe there are haskell bindings for that?
00:50:14 <RylandAlmanza> time for another hackage search, I guess
00:50:22 <luite> RylandAlmanza: if you have a simple sdl test i can try if you want
00:50:26 <luite> on mac
00:51:06 <mm_freak> absence: keymouse :: IORef (MyWire3 a Double) -> U.Key -> U.KeyState -> U.Modifiers -> U.Position -> IO ()
00:51:10 <mm_freak> this is the problem
00:51:15 <mm_freak> change the 'a' there to ()
00:51:53 <mm_freak> and i assume you use IORef because GLUT works with callbacks
00:52:21 <RylandAlmanza> luite: I don't have an example at the moment, thanks though! I'll let you know if I try sdl again
00:54:45 <mm_freak> absence: i think that could work with this type:  IORef (forall a. MyWire3 a Double), but that alone already needs two type system extensions
00:55:09 <mm_freak> also i'm not entirely sure whether it would work
00:55:11 <absence> mm_freak: ioref due to callbacks yes. is it only the type of the callback that should use ()? the one for the wire should still be a?
00:55:21 <mm_freak> yes
00:55:41 <mm_freak> the wire should be /defined/ with 'a', but /used/ with ()
00:56:12 <absence> ah. that's ... confusing :D i'll check it out later and see if i can wrap my head around it. running late for work now, so gotta run. thanks!
00:56:26 <mm_freak> you're welcome‚Ä¶  g'night =)
00:56:31 <mm_freak> ah
00:56:38 <mm_freak> you're running late‚Ä¶  well g'run =P
01:05:38 <womb> random question
01:05:50 <womb> any ideas how to do timeout on forkIO thread ?
01:06:58 <mm_freak> womb: like kill it after a certain amount of time?
01:12:07 <hpaste> ‚ÄúErtugrul S√∂ylemez‚Äù pasted ‚ÄúTiming out a thread‚Äù at http://hpaste.org/68877
01:12:18 <mm_freak> womb: see the paste‚Ä¶  that's one way to do it
01:13:20 <mm_freak> use case:  you can do this with many threads and wait for the first thread to answer or timeout all of them
01:14:09 <mm_freak> in that case you can also get along without STM‚Ä¶  have the answerVar be an MVar (Maybe Answer) and have one thread that just delays and then puts a Nothing
01:15:08 <dmwit> RylandAlmanza: I think it's mildly amusing that you rejected JuicyPixels as overkill, yet days later are still trying to get anything working.
01:15:50 <dmwit> Usually when I think "overkill" I'm thinking "takes more than 30 minutes to use for a 5 minute job".
01:16:51 <womb> mm_freak: yes
01:16:58 <RylandAlmanza> dmwit: I eventually went with JuicyPixels for that problem. This is a different one, though. I could use juicy pixels for this, but things on the screen will be rapidly changing, so I don't want to write and load an image to and from the disk every frame
01:17:19 <dmwit> Oh, that makes me much happier, especially for you.
01:17:29 <RylandAlmanza> :)
01:17:34 <dmwit> =D
01:17:48 <womb> hpaste: thanks bro
01:18:33 <dmwit> womb: I'm pretty sure mm_freak is the hand inside that particular puppet at the moment.
01:18:48 <dmwit> womb: see e.g. /whois mm_freak
01:18:54 <hpaste> ‚ÄúErtugrul S√∂ylemez‚Äù annotated ‚ÄúTiming out a thread‚Äù with ‚ÄúTiming out a thread (no STM)‚Äù at http://hpaste.org/68877#a68878
01:19:05 <mm_freak> womb: see the paste again‚Ä¶  i just added another way to do it
01:19:25 <mm_freak> it launches 100 threads with a random timeout producing an answer and one timeout thread that produces Nothing
01:19:50 <mm_freak> and yes, hpaste is just a bot‚Ä¶  it was my paste =P
01:23:53 <womb> mm_freak: i understand it! i feel so smart ow
01:24:22 <womb> now*
01:24:34 <mm_freak> i'm sorry to disappoint you‚Ä¶  concurrency is very easy in haskell, so it's not a big deal =P
01:25:31 <womb> well still i have problems from time to time understand all things (syntax wise)
01:25:48 <womb> whenei use subset of syntax like each noob :D
01:26:01 <mm_freak> perhaps we should approach the difficulties of C++‚Ä¶  people seem to be drawn to difficult languages
01:26:16 <womb> C++ is ez
01:26:31 <mm_freak> that's why they write large web portals in PHP‚Ä¶  i always knew that all programmers have a masochistic side =)
01:26:33 <womb> if you have problems you can do reinterpated_cast<void*>
01:27:20 <mm_freak> yeah, there is one thing haskell isn't good at
01:27:21 <womb> i never used STM in haskell maybe i should start digging into it
01:27:25 <mm_freak> shooting yourself in the foot =)
01:27:35 <mm_freak> womb: dig into concurrency first
01:27:45 <mm_freak> STM then comes quite naturally
01:27:48 <womb> well i found that i have to refactor my types when i started writing interpreter for a simple language
01:28:18 <womb> well i had 2 years of concurrency at uni :D so i think i know a bit about theory
01:28:31 <womb> i'm more into actor model / message passing thing
01:28:34 <mm_freak> write a small broadcast chat server‚Ä¶  if you're successful, you have understood most of what concurrency is about
01:28:47 <womb> because i did few things in erlang and back in C time shared memory made me cry few times
01:28:53 <mm_freak> then write the same using STM‚Ä¶  that quickly gives you an idea why STM is great
01:29:11 <mcstar> mm_freak: hi, are you there?
01:29:30 <mm_freak> womb: you can use the actor model in haskell, but there are many other models, too
01:29:38 <mm_freak> mcstar: yeah‚Ä¶  how can i help?
01:29:54 <mcstar> mm_freak: i put to use your yesterday's code
01:30:09 <womb> well actually i could use STM to build a work que and forkIO to build actuall workers
01:30:21 <mcstar> i didnt see it the first time i looked at it, so you have Map's in the nodes
01:30:31 <mm_freak> womb: you don't need STM for that
01:30:46 <mm_freak> mcstar: yeah
01:30:57 <mm_freak> mcstar: what's Array in your code is a Map in mine
01:31:21 <womb> mm_freak: if you have many threads puting in and many threads consuming you need to be able to atomicly add and addomicly pop things
01:31:43 <quicksilver> Chan works fine for that womb.
01:31:44 <mcstar> mm_freak: these are the numbers, on 200K words: my IO version, loads them in 5.5 secs, and checks them in 0.5secs, yours loads them in 2.3secs, and checks them in 10 secs
01:31:59 <mm_freak> womb: not necessarily‚Ä¶  put a delivery agent inbetween, for example
01:32:15 <mm_freak> Chan is also fine for that use case, but Chan is a bit unpredictable in terms of performance
01:32:16 <womb> or channel like quick said
01:32:34 <mcstar> mm_freak: maybe theres some lazyness going on, so we just better compare sum time
01:32:36 <womb> well multithreaded solutions are unpredictable :D
01:33:02 <womb> ok back to work i will try it out at home today
01:33:02 <mm_freak> mcstar: yes, my variant is very quick to construct, but slow to query
01:33:16 <womb> like germans say TANKS! mm_freak
01:33:48 <mm_freak> womb: tanks?  like fuel tanks?
01:33:50 <mcstar> mm_freak: the trie's main point would be fast lookup, i guess, anyway, i dont think the structure is fully generated, but some things gets evaluated right when i check the items in it
01:34:20 <womb> tanks like "thanks" but with german accent
01:34:22 <mm_freak> mcstar: that's also possible, yes
01:34:39 <mm_freak> womb: ah, that would rather be "sanks" =)
01:34:55 <womb> sanks doesn't sound like invading poland ;-F
01:35:44 <mm_freak> womb: germans don't have "th", so they replace it by either "d" or "s"‚Ä¶  the type of "th" in "thanks" would be pronounced as an "s"
01:35:57 <mm_freak> and "then" would become "den" =)
01:36:11 <womb> mm_freak: i will try to spawn 40000000 threads on timeouts and check performance
01:36:39 <womb> not "Den" but "Dem"
01:36:42 <mm_freak> womb: that's a lot‚Ä¶  the RTS can handle something up to 10^6 threads on my system
01:37:11 <womb> i need something between 10k - 100k to be able to say "i'm production ready"
01:37:14 <mm_freak> womb: no, that's the turkish germans‚Ä¶  they don't have Nominativ or Dativ, they have Dominativ:  "dem haus, weisch du"
01:37:25 <womb> i soo wanna finish my project in haskell and deploy it
01:37:45 <womb> ich heisse Jakub
01:37:54 <womb> my german is not perfect
01:38:14 <mm_freak> hehe
01:38:17 <mm_freak> hei√üe =)
01:39:35 <womb> wierd B
01:39:36 <womb> rocks
01:40:53 <mm_freak> womb: side note, if you're using threads, compile your program with -threaded
01:41:20 <mcstar> mm_freak: i just want to point out, the IO version is not totally useless...
01:42:02 <mm_freak> mcstar: i wasn't saying that, but i wouldn't use it, even if for the sole inconvenience of having IO operations all over the place
01:42:12 <womb> mm_freak: i r not the dumbest thing on earth :D
01:43:06 <mm_freak> mcstar: there are many ways to optimize my version‚Ä¶  in practice i would probably implement it as a type family
01:43:19 <womb> anyway thy -threaded is not "standard" option ?
01:43:25 <mcstar> mm_freak: when did immutability help you the most in practice?
01:43:27 <womb> it is something about being pure and shaved ?
01:43:51 <mm_freak> mcstar: good question‚Ä¶  my mutable variables come in the form of MVars and AcidStates usually
01:44:12 <mm_freak> womb: -threaded has some cost
01:45:44 <mm_freak> mcstar: and those are only pseudomutable‚Ä¶  i don't use them for the ability to mutate, but to communicate between threads and have a database with ACID properties without having to use one of the big DBMSes
01:58:25 <womb> mm_freak: i will also go back to RWH and read again concurrency chapter
02:00:33 * hackagebot numeric-limits 0.1.0.0 - Various floating point limit related constants.  http://hackage.haskell.org/package/numeric-limits-0.1.0.0 (LennartAugustsson)
02:01:36 <yitz> mm_freak: recently someone suggested an improvement to mvars (or maybe it was chans). JaffaCake's response was interesting.
02:01:53 <yitz> mm_freak: basically, he said fine, if you do the work, but really the way forward is stm.
02:02:39 <yitz> mm_freak: so it looks like non-stm is not getting mindshare anymore in ghc. in some sense, you might even say it's deprecated.
02:08:01 <RylandAlmanza> How do I get something from a tuple that isn't the first or second element?
02:08:43 <mcstar> > let (_,_,c) = (1,2,3) in c
02:08:44 <lambdabot>   3
02:09:27 <RylandAlmanza> thanks :)
02:16:00 <nomeata> Recently, a website similar to try-haskell was discussed on -cafe that had real-time error display, but I cannot find it any more. Does anyone remember the link?
02:16:30 <nomeata> Ok, got it, haskellonline.org
02:26:12 <mm_freak> yitz: that's fine to me, since non-STM STM performs like non-STM anyway, at least according to my benchmarks
02:26:21 <mm_freak> just add a few more IO wrappers
02:26:29 <mm_freak> like putTMVarIO
02:45:45 <edsko> @pf \resolved vst -> return $ RemoteEndPointClosing resolved vst
02:45:45 <lambdabot> Maybe you meant: bf pl
02:45:50 <edsko> @pl \resolved vst -> return $ RemoteEndPointClosing resolved vst
02:45:50 <lambdabot> (return .) . RemoteEndPointClosing
03:00:43 * hackagebot pdfinfo 0.1.3 - Wrapper around the pdfinfo command.  http://hackage.haskell.org/package/pdfinfo-0.1.3 (ChrisDone)
03:04:36 <Rumpelstiltskin> Hi, I'm getting some weird behaviour I was wondering if anyone could help me with: http://pastebin.com/4rvWuTBY
03:04:38 <mauke> The paste 4rvWuTBY has been copied to http://hpaste.org/68891
03:05:00 <quicksilver> Rumpelstiltskin: that is simply not how case works.
03:05:34 <quicksilver> Rumpelstiltskin: case x of y -> does not compare 'x' with the current value of 'y'
03:05:41 <Rumpelstiltskin> quicksilver. Oh yeah you are right
03:05:46 <Rumpelstiltskin> seems so obvious now
03:05:50 <quicksilver> it always matches, and binds a new variable 'y' to the value of x
03:05:58 <Rumpelstiltskin> it'll be binding it to a variable called whatever
03:06:12 <Rumpelstiltskin> thanks!
03:06:14 <quicksilver> :)
03:12:07 <womb> Mvars are part of STM or i'm getting confused ?
03:12:23 <womb> MVars
03:12:42 <bitonic> womb: you're getting confused, MVars are mutable variables that live in IO
03:12:52 <shachaf> How can you be confused about whether you're getting confused?
03:13:04 <womb> recursive confusion
03:13:05 <womb> ?
03:13:07 <womb> ok
03:13:10 <womb> bitonic: thanks
03:13:16 <edsko> @pl \msg -> sendMany sock msg `onException` tryIO (N.sClose sock)
03:13:16 <lambdabot> (`onException` tryIO (N.sClose sock)) . sendMany sock
03:13:24 <Eduard_Munteanu> Fix your confusion :P
03:14:28 <bitonic> edsko: you know, you can install "pointfree" :P
03:14:35 <edsko> yeah, I really should :)
03:14:47 <dmwit>  ?pl spam is normal, don't fret it.
03:14:48 <luite> edsko: hi, where can i find the network patches?
03:15:07 <edsko> luite: they have been integrated into the stable branch of network
03:15:10 <dmwit> If you're doing many all in a row, /msg lambdabot, otherwise most of us have filters in wetware that mean we don't even see the traffic go by.
03:15:50 <edsko> luite: https://github.com/haskell/network
03:17:04 <luite> edsko: realli? i don't see them in the commits
03:17:27 <edsko> luite: huh? when I got to that page it says "Use darwin_HOST_OS, not darwin_TARGET_OS"
03:17:39 <edsko> as the latest commit on the stable branch
03:17:44 <luite> edsko: oh is that all? i thought there was something where you needed to zero memory on allocate?
03:18:11 <luite> oh bah
03:18:15 <luite> it looks like it does that
03:18:22 <luite> <- stupid
03:18:31 <edsko> luite: yes, that is correct
03:18:36 <luite> :(
03:18:51 <edsko> hehehe. that was in response to your earlier message, not your later :)
03:18:59 <luite> hehe
03:19:42 <edsko> as it turned out, Network.Socket.Internal *did* have the code to zero out the memory (it was part of peekAddrInfo or something like that), which I had missed in my earlier patch. the bug was that this zeroing-out code was enabled when darwin_TARGET_OS was set, which is the wrong flag to use (should have been darwn_HOST_OS)
03:19:51 <edsko> so with that modification the zeroing-out code gets compiled in
03:19:54 <luite> ah right
03:20:05 <edsko> bitonic: pointfree installed :)
03:20:36 <edsko> huh, it is really the same thing?
03:20:40 * edsko is getting different answers 
03:21:11 <edsko> luite: so it was a serious bug, and more serious than I had thought before, because this 'peekÖ' code is used in multiple places
03:23:33 <bitonic> edsko: it should be, yes
03:24:00 <edsko> bitonic: shell being too clever for its own good :)
03:24:13 * edsko opened a private dialog with lambdabot here, more convenient :)
03:43:02 <bookerz> Is there a version of Prelude.iterate that works when f returns a monad?  Like (a -> m a) -> a -> [m a]
03:43:31 <mm_freak> bookerz: not predefined
03:43:44 <mm_freak> also the type makes little sense
03:43:53 <bookerz> :-)
03:43:55 <mm_freak> it would be:  (a -> m a) -> a -> m [a]
03:44:20 <bookerz> mm_freak: because the applications would need to be sequential to make sense?
03:44:51 <mm_freak> nope, because the type you gave can only produce a list of a number of same actions
03:45:08 <mm_freak> the only way to construct a value of 'm a' is to apply the function to the argument
03:45:17 <mm_freak> this is not what 'iterate' does
03:45:28 <hpc> :t iterate
03:45:29 <lambdabot> forall a. (a -> a) -> a -> [a]
03:45:55 <younder> what a lameass function!
03:46:29 <bookerz> But isn't that what iterate does?  Apply a function to an argument?  [a, f a, f f a,...]
03:46:31 <hpc> :t let it f a = let f' = f >=> f in f : it f' a
03:46:31 <lambdabot> <no location info>:
03:46:31 <lambdabot>     not an expression: `let it f a = let f' = f >=> f in f : it f' a'
03:46:35 <hpc> :t let it f a = let f' = f >=> f in f : it f' a in it
03:46:35 <lambdabot> forall a (m :: * -> *) t. (Monad m) => (a -> m a) -> t -> [a -> m a]
03:46:48 <hpc> :t let it f a = let f' = f >=> f in f a : it f' a in it
03:46:48 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m a) -> a -> [m a]
03:46:54 <bookerz> :-)
03:47:02 <quicksilver> bookerz: yes, indeed, but you can't do that with (a -> m a)
03:47:05 <mm_freak> :t \f x = liftM (x :) (f x >>= iterateM f)
03:47:07 <lambdabot> parse error on input `='
03:47:10 <quicksilver> bookerz: because the result type is not the same.
03:47:11 <mm_freak> :t \f x -> liftM (x :) (f x >>= iterateM f)
03:47:12 <lambdabot> Not in scope: `iterateM'
03:47:17 <quicksilver> "m a" is not "a"
03:47:21 <hpc> @hoogle iterateM
03:47:21 <lambdabot> No results found
03:47:32 <mm_freak> :t fix (\again f x -> liftM (x :) (f x >>= again f))
03:47:33 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m a) -> a -> m [a]
03:47:38 <bookerz> quicksilver: nod.  There'd need to be some sort of binding between applications
03:47:48 <mm_freak> there you go
03:47:49 <hpc> quicksilver: he did say "a version of" :P
03:48:15 <mm_freak> bookerz: note also that this function isn't very useful in most monads
03:48:59 <quicksilver> bookerz: which is why your type would be wrong.
03:49:06 <quicksilver> bookerz: (and why mm_freak's type is better)
03:49:16 <mm_freak> if the monad is functionlike, the internal function cannot be strict, otherwise you will just loop forever
03:49:33 <mm_freak> likely trashing your memory while you do so =)
03:49:37 <bookerz> mm_freak: that makes sense
03:49:37 <quicksilver> but since that involves forcing an infinite effect
03:49:49 <quicksilver> it would only work in certain monads which can lazily produce parts of infinite effects
03:50:07 <bookerz> which is what I'm hoping for, here
03:50:10 <hpc> mm_freak: it can be strict just fine; it returns a list of [f a, f <=< f $ a, f <=< f <=< f $ a, ...
03:50:12 <bookerz> I'll just take from the list
03:50:22 <younder> Why is there no IterateM?
03:50:28 <mm_freak> hpc: that's not what it returns
03:50:47 <mm_freak> you can't express what it returns as a list
03:51:01 <quicksilver> younder: because there is more than one possible way you might write it.
03:51:05 <bookerz> I'm trying to apply this to a function that, more or less, produces a random walk on a graph structure
03:51:15 <quicksilver> hpc: that's an interesting possibility but of course duplicates effects in suprising ways
03:51:17 <hpc> 06:46 < hpc> :t let it f a = let f' = f >=> f in f a : it f' a in it -- mm_freak: what about this isn't what i just said?
03:51:18 <younder> Seems to me it could be quite usefull..
03:51:35 <quicksilver> hpc: if you actually use the contents of that list
03:51:39 <mm_freak> bookerz: fold the graph
03:52:03 <mm_freak> bookerz: that is: define a monadic folding combinator for your graph
03:52:41 <bookerz> So I've got a 'step' function (Graph -> Dist Graph)
03:52:52 <mm_freak> bookerz: if you don't know what that is, just recurse explicitly =)
03:52:55 <bookerz> mm_freak: interesting...
03:53:06 <mm_freak> bookerz: you can also use a zipper
03:53:20 <bookerz> mm_freak: explicit recursion, I think I could do
03:53:24 <mm_freak> the zipper has the advantage that you can easily avoid already visited nodes without mutation
03:53:46 <bookerz> mm_freak: :-) Haven't gotten to that chapter in LYAH yet
03:53:48 <younder> My favorite book at the moment is 'Purely functional data structures'
03:54:42 <younder> Perhaps that could help some of your problems
03:56:14 <mm_freak> bookerz: then just recurse =)
03:56:25 <bookerz> younder: actually, that book seems reasonably priced
03:56:30 <bookerz> younder: thanks for the pointer
03:56:33 <mm_freak> iterateM is very rarely what you want and almost never does what you would expect =)
03:56:55 <bookerz> mm_freak: heh.  Alright.
03:57:00 <bookerz> I'll take the easy way this time
03:57:11 <spa313> hey, I was wondering: why is length defined the way it is, i.e. using another function len, rather than just something like length (x:xs) = 1 + length xs? what makes the former way more efficient?
03:58:18 <mm_freak> bookerz: of course there is a variation of iterateM that indeed has the type you wanted‚Ä¶  it's hpc's alternative that will repeat effects
03:58:45 <quicksilver> spa313: a naive compilation of length (x:xs) = 1 + length xs builds up an enormous thunk and then reduces it.
03:58:50 <mm_freak> :t \f x -> map ($ x) (iterate (>=> f) return)
03:58:51 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m a) -> a -> [m a]
03:58:56 <quicksilver> spa313: that uses O(n) memory as it does so.
03:59:16 <mm_freak> in any case, that's probably even less what you wanted =)
03:59:20 <hpc> @src length
03:59:20 <lambdabot> Source not found. I've seen penguins that can type better than that.
03:59:26 <spa313> quicksilver: ahh, thanks.
04:00:24 <bookerz> mm_freak: probably less because why now?
04:00:49 <mm_freak> bookerz: it's just a way of selecting from a number of compositions of 'f'
04:01:11 <mm_freak> in particular it doesn't produce a list of intermediate values, but only the final value
04:01:30 <mm_freak> :t \f -> iterate (>=> f) return
04:01:31 <lambdabot> forall (m :: * -> *) c. (Monad m) => (c -> m c) -> [c -> m c]
04:03:19 <mm_freak> i wouldn't even know what to call that combinator‚Ä¶  it's not iterateM
04:03:48 <mm_freak> btw, there is one way to make sense of iterateM, namely the iterateM_ variant
04:04:09 <mm_freak> :t fix (\again f x -> f x >>= again f)
04:04:10 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m a) -> a -> m b
04:04:29 <mm_freak> that's iterateM_, which can be useful sometimes
04:05:12 <bookerz> mm_freak: :-)  It's going to take me a little while to make sense of any of these
04:05:19 <mm_freak> iterateM_ (\x -> x + 1 <$ print x) 0
04:05:25 <mm_freak> prints 0, then 1, then 2, then 3, etc.
04:05:50 <bookerz> interesting...
04:06:21 <mm_freak> but i'd just use 'fix' there =)
04:06:34 <mm_freak> ($ 0) . fix $ \again x -> print x >> again (x + 1)
04:07:50 <ski> @type let subst :: Monad m => (var -> m var) -> (m var -> m a); subst s mv = subst s . s =<< mv in subst
04:07:51 <lambdabot> forall var (m :: * -> *) a. (Monad m) => (var -> m var) -> m var -> m a
04:07:54 <younder> It is H=OT in Norway now..
04:08:14 <mm_freak> it is P=NP in other parts of the world now
04:08:24 <koala_man> younder: where in Norway?
04:08:37 * ski . o O ( "Bergen" )
04:08:41 <younder> P=NP is also interesting.. :)
04:09:06 <peropaal> Oslo her
04:09:21 <younder> been working on that a bit
04:10:40 <younder> Any of you working the millennium problems?
04:10:52 * hackagebot protocol-buffers 2.0.8 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/protocol-buffers-2.0.8 (ChrisKuklewicz)
04:10:54 * hackagebot protocol-buffers-descriptor 2.0.8 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification  http://hackage.haskell.org/package/protocol-buffers-descriptor-2.0.8 (ChrisKuklewicz)
04:11:00 <manish411> hi!!
04:11:02 <koala_man> Oslo here too o/
04:11:05 <ski> hello manish411
04:11:16 <peropaal> o_O
04:11:34 <manish411> can neone help me with some doubts using parsec library
04:11:34 <manish411> ??
04:11:53 <dmwit> manish411: Don't ask to ask. Just ask.
04:11:56 <ehamberg> manish411: just ask your question and you'll find out. :)
04:12:00 <manish411> ok
04:12:10 <manish411> http://sprunge.us/WBVH
04:12:12 <manish411> here
04:12:18 <manish411> is my code and my query
04:13:20 <dmwit> protip: you can actually use ' in your identifier names
04:13:28 * ski . o O ( <http://web.archive.org/web/20020305083813/http://glacierglen.dhs.org/Wallpaper/Buarbreen1024x768.jpg> )
04:13:38 <manish411> pardon my english
04:13:40 <dmwit> so you could call it e' instead of edash (which incidentally is particularly wierd since dash is -)
04:13:44 <younder> koala_man, Oslo
04:13:55 <manish411> ok
04:14:26 <dmwit> manish411: Did you know about the "eof" parser?
04:14:34 <dmwit> :t Text.ParserCombinators.Parsec.eof
04:14:35 <lambdabot> forall tok st. (Show tok) => Text.ParserCombinators.Parsec.Prim.GenParser tok st ()
04:14:36 <manish411> yes
04:14:51 <manish411> but can it identify end of string too?
04:14:54 <younder> sorry I got a bit delayed.. was thinking about P=NP
04:15:07 <dmwit> What do you mean "too"?
04:15:12 <dmwit> That's all it does.
04:15:46 <manish411> ok my problem is i cannot identify the end of string
04:15:47 <hpc> "This parser only succeeds at the end of the input."
04:15:47 <younder> I love that problem, it's beautiful symmetry
04:15:56 * hackagebot protocol-buffers 2.0.9 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/protocol-buffers-2.0.9 (ChrisKuklewicz)
04:19:23 <ski> manish411 : you know you can omit the `{',`;',`}'s, right ?
04:19:44 <manish411> yes I do
04:19:49 <manish411> cannot identify the end of string
04:19:49 <manish411> <hpc> "This parser only succeeds at the end of the input."
04:19:49 <manish411> <younder> I love that problem, it's beautiful symmetry
04:19:49 <manish411> * hackagebot protocol-buffers 2.0.9 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/protocol-buffers-2.0.9 (ChrisKuklewicz)
04:19:49 <manish411> * Philippa has quit ()
04:19:50 <manish411> * Nimatek has quit (Ping timeout: 244 seconds)
04:19:52 <manish411> * silas1 (silas@nat/redhat/x-rtirimuwddatpyno) has joined #haskell
04:20:23 <manish411> e' :: Parser String
04:20:23 <manish411> e' = do {
04:20:23 <manish411>            char '+'
04:20:23 <manish411>            ;t
04:20:23 <manish411>            ; e'
04:20:23 <manish411>            }
04:20:24 <manish411>            <|> eof
04:20:34 <manish411> ok so I think this might solve my problem
04:20:38 <dmwit> Please don't make multiline pastes in here.
04:21:03 <dmwit> The normal way to use eof is to build your parsers without eof.
04:21:11 <manish411> what do u think?
04:21:11 <manish411> roger dat
04:21:12 <dmwit> Then you take your single top-level parser and compose it thus:
04:21:15 <dmwit> topLevel <* eof
04:21:26 <mm_freak> also your syntax is extremely ugly‚Ä¶  learn layout =)
04:21:35 <navaati> haskell is relater to system Fœâ, right ?
04:21:40 <t7> not sure if obnoxious or troll...
04:21:41 <mm_freak> navaati: yes
04:21:55 <navaati> 'k, thanks
04:25:00 <chra> Help, please: ghc 7.4.1 with -XTypeFamilies and -XConstraintKinds, "type family X a :: Constraint" gives Not in scope: type constructor or class `Constraint'. What have I forgotten?
04:25:09 <ski> manish411 : is there a point in returning `"correct"' ?
04:25:29 <dmwit> chra: import GHC.Exts or some such thing
04:25:57 * hackagebot protocol-buffers-descriptor 2.0.9 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification  http://hackage.haskell.org/package/protocol-buffers-descriptor-2.0.9 (ChrisKuklewicz)
04:25:59 * hackagebot hprotoc 2.0.9 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/hprotoc-2.0.9 (ChrisKuklewicz)
04:26:02 <chra> dmwit: Oh, thanks. It worked.
04:27:19 <Stalafin> After I have cloned a git repo, how can I use cabal to configure, build and install the cloned package?
04:28:11 <hpc> Stalafin: cd into it and 'cabal install'
04:28:23 <hpc> with whatever other options you feel like setting
04:28:45 <Stalafin> hpc: ah, thanks
04:28:56 <Stalafin> My mistake was that I also issued the package's name
04:29:00 <Stalafin> So it searched hackage
04:29:21 <fmap> cabal install package_name.cabal would also work
04:29:55 <Stalafin> Under which circumstances does "cabal list --installed" not list packages I have installed?
04:30:15 <Stalafin> E.g., I have installed package foo, its located in .cabal/bin/, but cabal list --installed will not show it
04:30:30 <Stalafin> (its executable is in .cabal/bin
04:30:46 <younder> Finally got 'Vivaldi the for seasons going' feel alive now
04:32:13 <hpc> Stalafin: it might not get registered, if it doesn't compile as a library as well
04:32:41 <hpc> i am not sure though, so wait for a second opinion :P
04:32:58 <Stalafin> weird :/
04:33:15 <Stalafin> the package is also located in .cabal/packages/hackage.haskell.org/
04:34:47 <younder> Was lulled into summer by a beautiful blond (still Vivaldi)
04:37:08 <younder> http://www.youtube.com/watch?feature=endscreen&NR=1&v=g65oWFMSoK0
04:38:02 <younder> recommended, best violin performance ever
04:38:22 <Stalafin> vivaldi is nice
04:38:39 <Hail_Spacecake> suppose I have a string someStr = "hi\n\nlow"
04:38:48 <Hail_Spacecake> how can I make those newlines display properly in ghci?
04:39:54 <ehamberg> putStrLn someStr
04:40:16 <ehamberg> or ‚ÄúputStr someStr‚Äù if you don't want an newline at the end.
04:44:12 <applicative> http://www.youtube.com/watch?v=j4oWgBlHIVY violin spam attack
04:48:15 <younder> http://www.youtube.com/watch?feature=iv&src_vid=TZCfydWF48c&v=nbpAFzyrx5o&annotation_id=annotation_159379'
04:48:51 <younder> Spam attack deluxe 'the full four seasons'
04:49:23 <younder> I must admit my favorite music
04:53:44 <applicative> > text "hi" $$ space $$  text "ho"
04:53:45 <lambdabot>   hi
04:53:45 <lambdabot>  
04:53:45 <lambdabot>  ho
04:54:41 <younder> got a question applicative ?
04:54:45 <applicative> Hail_Spacecake: Text.PrettyPrint is pure
04:55:18 <applicative> so you can display text inside ghci without  tasteless calls to putStrLn
04:55:22 <younder> so it is
04:55:31 <younder> and..
04:56:16 <younder> Hey,  I like pure too..
04:56:22 <hpc> you don't need text, even
04:56:22 <applicative> > vcat $ map (text.show) [1..3]
04:56:24 <lambdabot>   1
04:56:24 <lambdabot>  2
04:56:24 <lambdabot>  3
04:56:31 <hpc> newtype S = S String
04:56:34 <Hail_Spacecake> so if I import Text.PrettyPrint
04:56:39 <hpc> instance Show s where show (S s) = s
04:56:41 <Hail_Spacecake> how do I get access to the functions in it?
04:56:41 <applicative> lambabot is putting a space
04:56:50 <applicative> import Text.PrettyPrint
04:56:58 <Hail_Spacecake> okay, but now what?
04:57:09 <applicative> Hail_Spacecake: I just mention it as nice to now
04:57:09 <Hail_Spacecake> I can tab-complete Text.PrettyPrint.<a bunch of things>
04:57:19 <hpc> Hail_Spacecake: use text
04:57:21 <applicative> know
04:57:21 <hpc> :t text
04:57:22 <lambdabot> String -> Doc
04:57:38 <applicative> ghci has a special rule  for things of the Doc type
04:57:42 <hpc> > text "this has\nNEWLINES"
04:57:43 <lambdabot>   this has
04:57:43 <lambdabot>  NEWLINES
04:57:49 <younder> text.PrettyPrint does the work  for you
04:57:49 <Hail_Spacecake> ah
04:58:40 <younder> see, wonderful yes?
05:00:28 * ski doesn't like such `Show' instances ..
05:02:28 <younder> ski: show does sound a lot like snow doesn't it?
05:03:23 <Hail_Spacecake> suppose I have a char and I want to get a string that has n instances of that char
05:03:33 <Hail_Spacecake> there's a built-in that does that, I know, I just can't remember the name offhand
05:04:57 <quicksilver> > replicate 10 '-'
05:04:57 <lambdabot>   "----------"
05:06:01 <younder> replicate 20 'f'
05:06:18 <ski> younder : yeah, snow would be nicer than this heat
05:06:34 <younder> so it would
05:07:27 <hughfdjackson> please excuse my massive ignorance
05:07:50 <hughfdjackson> but what does '$$' mean in `text "45" $$ space $$ text "foo"`?
05:07:53 <Botje> hughfdjackson: what can we do to remove some of it?
05:07:58 <younder> no
05:08:02 <hughfdjackson> :D edify
05:08:17 <Botje> hughfdjackson: from what library is this?
05:08:20 <hughfdjackson> :/ google doesn't like searching for $$, and double dollar doesn't seem to throw anything useful up
05:08:26 * ski remembers walking on glaciers in Jostedalsbreen
05:08:33 <hughfdjackson> Text.PrettyPrint, i'm assuming
05:08:38 <hughfdjackson> :3 i think you just answered my question
05:08:45 <hughfdjackson> for some reason i thought it was generic like $
05:08:55 <Botje> the docs say it's "above"
05:09:06 <hughfdjackson> :D cheers
05:09:09 <Botje> and they have an example, too
05:09:13 <Botje> http://hackage.haskell.org/packages/archive/pretty/latest/doc/html/Text-PrettyPrint.html
05:09:32 <hughfdjackson> much obliged
05:10:41 <edsko> luite: any luck?
05:11:05 <Hail_Spacecake> what do I need to import to get ord and chr?
05:11:26 <Botje> Data.Char
05:11:32 <Botje> @hoogle ord
05:11:32 <lambdabot> Prelude class Eq a => Ord a
05:11:32 <ski> @index ord
05:11:32 <lambdabot> Data.Ord class Eq a => Ord a
05:11:32 <lambdabot> Prelude data Ordering :: *
05:11:33 <lambdabot> Data.Char
05:11:49 <Botje> stupid hoogle.
05:12:06 <ski> .. oh
05:12:25 * ski was just about to ask who replaced `index' with `hoogle'
05:15:51 <danr> Anyone remembers the function to see how many threads your graphics card has with accelerate?
05:16:01 <danr> or knows, even
05:20:47 <applicative> hughfdjackson:
05:20:49 <applicative> foldr (<>) empty $ map char "hello"
05:20:54 <applicative> foldr ($$) empty $ map char "hello"
05:20:59 <applicative> > foldr (<>) empty $ map char "hello"
05:21:00 <lambdabot>   Ambiguous occurrence `empty'
05:21:00 <lambdabot>  It could refer to either `Control.Applicative...
05:21:11 <applicative> curse you lambdabot
05:21:23 <applicative> > foldr (<>) Text.PrettyPrint.empty $ map char "hello"
05:21:24 <lambdabot>   Not in scope: `Text.PrettyPrint.empty'
05:21:27 <applicative> grrr
05:22:02 <hughfdjackson> :D i shall try it in ghci
05:22:04 <applicative> > foldr (<>) (text "") $ map char "hello"
05:22:04 <lambdabot>   hello
05:22:11 <applicative> > foldr ($$) (text "") $ map char "hello"
05:22:12 <lambdabot>   h
05:22:12 <lambdabot>  e
05:22:12 <lambdabot>  l
05:22:12 <lambdabot>  l
05:22:12 <lambdabot>  o
05:22:19 <hughfdjackson> haha :D classy
05:22:37 <manish411> guys how to parse left recursive grammer using parsec without removing left recursion ??
05:23:16 <adimit> manish411: why not rewrite the grammar? Factoring out left recursion is a common normalization step.
05:23:56 <quicksilver> manish411: you can't.
05:23:59 <manish411> adimit , yes I have implemented that, but there is a function called buildParseTree which is a shortcut for
05:24:05 <merijn> I'm running into a "Prelude.undefined: thread blocked indefinitely in an MVar operation", anyway to get a stack trace of where this happens?
05:24:09 <manish411> it , I heard
05:24:22 <quicksilver> parsec is a recursive descent design, it will inherently loop on a left-recursive input
05:24:23 <manish411> that it can ease things out
05:24:39 <quicksilver> so you have to remove the left recursion one way or another.
05:26:04 * hackagebot Haschoo 0.1.2 - Minimalist R5RS Scheme interpreter  http://hackage.haskell.org/package/Haschoo-0.1.2 (MattiNiemenmaa)
05:26:06 * hackagebot list-tries 0.4.2 - Tries and Patricia tries: finite sets and maps for list keys  http://hackage.haskell.org/package/list-tries-0.4.2 (MattiNiemenmaa)
05:26:34 <manish411> http://www.ninebynine.org/Software/Swish-0.2.1/HaskellRDF/Parsec/doc/parsec.html ok here is a tutorial in which the writer makes a parser for left-recursive grammer using ParsecExpr library
05:26:36 <_gaffer> Hi. I'm just working through the "Roll your own IRC bot" tutorial (http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot) and it seems ghc doesn't like the code as it is on the wiki page.
05:26:37 <tsanhwa> hi, I make a cabal package which use HDBC-sqlite3, and when I cabal install it, I get a error from ld.exe: cannot find -lsqite3. someone help me, thank you
05:26:50 <manish411> check under the heading Expressions
05:26:55 <_gaffer> Anyone familiar with this issue by any chance?
05:27:13 <tsanhwa> I install HDBC-sqlite3 sucessfully. I build on windows.
05:27:44 <hpaste> ‚Äú_gaffer‚Äù pasted ‚ÄúRoll your own IRC error‚Äù at http://hpaste.org/68897
05:28:24 <_gaffer> ^ that one, I mean
05:29:50 <merijn> _gaffer: The code is to generic, GHC can't infer which exception type you're trying to catch
05:30:08 <merijn> _gaffer: You want to add a type annotation that specifies which exception you want to catch
05:30:52 <_gaffer> merijn: I'm a bit new to all this, and taking the code straight from the wiki gives the same error. Could you point me in the right direction, by any chance?
05:31:01 <absence> i have a "getTime :: MonadClock t m => m t" and there's an "instance MonadClock Double IO". i'd like to use a Reader monad instead, but "instance MonadClock Double (Reader MyReaderType)" causes ghc to complain "All instance types must be of the form (T t1 ... tn) where T is not a synonym." what am i doing wrong?
05:31:43 <_gaffer> starting to think I may have overreached with this tutorial :)
05:31:59 <roconnor> absence: you either need a newtype wrapper for (Reader MyReaderType), which is good to do anyways, or you need advanced typeclass features of ghc.
05:32:20 <merijn> _gaffer: I think the default exception mechanism was changed since it was written
05:34:07 <_gaffer> merijn: Thanks. Looks like I've got something new to learn!
05:34:25 <merijn> _gaffer: Take a look at the documentation for Control.Exception
05:34:42 <merijn> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Exception.html#g:3
05:35:19 <_gaffer> merijn: will do. Determined to get further with learning Haskell this time than earlier, abortive attempts
05:35:35 <merijn> _gaffer: The problem is that const will accept any input and thus the compiler can't know which exception(s) you are trying to catch
05:35:53 <manish411> guys what is expression grammer??
05:35:53 <absence> roconnor: "newtype MyReader = Reader ReaderState" results in kind mismatch (excepts * -> *, gets *), and "newtype MyReader a = Reader ReaderState a" results in the error "the constructor of a newtype must have exactly one field"
05:36:02 <merijn> A simple (but not very robust!) solution would be to replace the const with "\e :: SomeException -> return ()"
05:36:43 <merijn> Might need parenthesis around "e :: SomeException"
05:37:03 <_gaffer> Hmm, yeah, I saw that and thought it might be the dodgy way forward
05:37:09 <roconnor> absence: You need a constructor name for a newtype
05:37:20 <merijn> Any suggestions on how to obtain a stack trace when I run into a "thread blocked on an MVar indefinitely" error?
05:37:20 <roconnor> newtype MyReader a = MyReader (Reader ReaderState a)
05:37:46 <roconnor> absence: you can define a projector at the same time:
05:37:53 <roconnor> newtype MyReader a = MyReader { unMyReader :: Reader ReaderState a}
05:37:56 <quicksilver> merijn: I don't think you can, although I could be wrong.
05:38:09 <merijn> quicksilver: Not what I wanted to hear >.<
05:39:59 <merijn> Fairly odd, too. As all my MVar interactions are done using modifyMVar...
05:40:45 <merijn> oh...
05:41:03 <Botje> merijn: could it happen that your modifying function tries to take the MVar as well?
05:41:16 * merijn just realised he might have an infinite loop in one of the MVar modification functions
05:42:05 <absence> roconnor: thanks. now i get illegal instance declaration: "Only one type can be given in an instance head."
05:42:48 <roconnor> absence: can you paste your class definition?
05:42:52 <donri> -XMultiParamTypeClasses ?
05:43:46 <donri> or not, missed the question
05:44:10 <absence> roconnor: it's not mine, but here it is: http://hpaste.org/68899
05:44:16 <roconnor> donri: I think multiparametertypeclasses must already be enabled or otherwise therewould be earlier errors
05:44:26 <_gaffer> well, zero points for reading comprehension for me. The solution is right there in the wiki as "catch (runReaderT run st) (\(SomeException _) -> return ())"
05:44:30 <merijn> Actually...even dumber
05:44:36 <merijn> I was linking the wrong code :p
05:44:56 <merijn> _gaffer: It happens :)
05:45:16 <roconnor> absence: which instance gives you the error message?
05:45:22 <_gaffer> merijn: Ah well, it got me to join the #haskell channel, so there's a win there
05:45:29 <nooodl> hi #haskell! i'm having some trouble with type errors, and it's driving me crazy: http://codepad.org/E7MiMRuJ
05:45:46 <nooodl> i'm trying to figure out viewRange's type signature, but i'm doing something wrong
05:45:52 <Botje> nooodl: fromIntegral res
05:46:07 <Botje> and you will need to do the same for i
05:46:28 <absence> roconnor: instance MonadClock Double MyReader
05:46:47 <nooodl> Botje: the weird thing is, there aren't any errors if i just leave out the type signature entirely
05:47:08 <Botje> nooodl: yes, because haskell then automatically infers that res :: Double
05:47:16 <Botje> (and even that xres and yres :: Double)
05:48:01 <nooodl> whoa
05:48:10 <Botje> :t let res = 20; _ = 5 / res in res
05:48:11 <lambdabot> forall t. (Num t) => t
05:52:17 <roconnor> absence: ah, maybe you need to build your module with MultiParameterType classes?
05:52:29 <roconnor> donri: so you were probably right
05:52:32 <donri> roconnor: but it needs to be enabled in both modules if they're separate
05:52:38 <donri> yea
05:52:39 <ClaudiusMaximus> nooodl: with -XMonomorphismRestriction (which lambdabot seems to have turned off?) Botje's example gives   :: (Fractional t) => t   (in my ghci)
05:53:21 <absence> roconnor: it does suggest that, i just wanted to make sure i had the code right before enabling extensions
05:54:39 <Oni^> how to do same when using fold: pmod3 xs = [x | x <- xs, mod x 3 /= 0] ?
05:55:27 <Botje> Oni^: you can just use filter for that.
05:55:39 <donri> but it's so much more fun to just enable random extensions and pray to the gods it compiles
05:57:00 <Botje> or ‚Äì if this is homework ‚Äì figure out how to write filter as a fold first :)
06:00:28 <ski> > foldr (\n -> if n `mod` 3 == 0 then id else (. (n :))) reverse [0 .. 9] []
06:00:30 <lambdabot>   [1,2,4,5,7,8]
06:00:55 <zenzike> tsanhwa: are you still having problems with HDBC?
06:01:42 <Oni^> thanks ski
06:02:06 <ski> Oni^ : note that it can be done in a more sane way
06:02:25 <ski> (iow, don't hand in that :)
06:12:31 <applicative> Oni^: first write it out as a recursive definition oni [] = []; oni (x:xs) = if x `mod`... then ... else....   ; then write it with an explicit fold and you will see the purpose of the fold combinators
06:14:37 <luite> edsko: nope, unfortunately it still segfaults
06:15:01 <luite> it might be a bug in ghc itself, don't know :(
06:15:07 <edsko> damn it
06:15:50 <applicative> i've been getting tons of segfaults since installing ghc-7.4 but I think they're mostly my-faults really
06:16:32 <edsko> luite: I was more hopeful when i discovered that the bug affected more functions
06:26:08 * hackagebot SoOSiM 0.1 - Abstract full system simulator  http://hackage.haskell.org/package/SoOSiM-0.1 (ChristiaanBaaij)
06:46:09 * hackagebot http-types 0.6.11 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.6.11 (AristidBreitkreuz)
07:01:06 <shapr> GOOD MORNING #HASKELL!
07:01:08 * shapr boings cheerfully
07:01:23 <shapr> How's everybody coding this fine morning?
07:01:37 <mkramer> no coffee yet
07:01:47 * hiptobecubic drools on the floor
07:01:57 <shapr> mkramer: quick! coffee is necessary to code!
07:02:07 * shapr hits hiptobecubic with a shot of intravenous coffee
07:02:13 <younder> Listening  to Mozart requiem
07:02:41 <younder> My favorite piece of work.
07:07:06 <matthiasgorgens> Is there something like an MVar that can only be written once?
07:07:22 <Axman6> it's usually called an IVar
07:07:23 <younder> Listened to Vivaldi 'The four seasons' before.
07:07:48 <Axman6> the monad-par package is one place you can find them (though they're used in a quite specific context)
07:08:14 <younder> http://www.haskell.org/pipermail/haskell/2007-December/020006.html
07:08:20 <matthiasgorgens> Axman6: I found them (via hoogle) in ivar-simple and data-ivar.
07:08:56 <matthiasgorgens> Axman6: thanks!
07:09:10 <younder> NOP
07:10:13 <younder> Efficiency is a virtue
07:10:24 <matthiasgorgens> shapr: morning?
07:10:36 <shapr> GOOD MORNING matthiasgorgens!
07:10:46 <shapr> Hur m√•r du idag?
07:10:59 <younder> morn . and the lot
07:11:03 <shapr> Oh wait, nederlands?
07:11:11 * hackagebot dbus-th 0.1.0.0 - TemplateHaskell generator of DBus bindings  http://hackage.haskell.org/package/dbus-th-0.1.0.0 (IlyaPortnov)
07:11:13 * hackagebot hs-java 0.3.1 - Java .class files assembler/disassembler  http://hackage.haskell.org/package/hs-java-0.3.1 (IlyaPortnov)
07:11:25 <shapr> younder: See, I listen to bouncy energetic music for coding.
07:11:33 <younder> Jeg snakker Norsk ogsÂ
07:11:59 <shapr> I only do English and Swedish, but I'm taking Portugu√™s in the fall!
07:12:03 * shapr dances cheerfully.
07:12:20 <shapr> I have to figure out of Aarne Ranta's Grammatical Framework has a Portugu√™s grammar or not.
07:12:31 <shapr> That was my favorite piece of language-teaching Haskell code.
07:12:37 <younder> It doesn't
07:12:50 <shapr> Aw, are you involved with GF?
07:13:05 <matthiasgorgens> good afternoon, shapr.
07:13:08 <sipa> girlfriend? galois field?
07:13:16 <sipa> Ah. Grammatical Framework.
07:13:16 <shapr> grammatical framework :-)
07:13:21 <shapr> @where GF
07:13:21 <lambdabot> Grammatical Framework, dependently typed FPL, categorial grammar formalism, supporting multilingual grammar applications for e.g. natural language processing, at <http://www.grammaticalframework.org/
07:13:21 <lambdabot> >. (An old `Alfa' interface is at <http://web.archive.org/web/*/http://www.cs.chalmers.se/~hallgren/Alfa/Tutorial/GFplugin.html>)
07:14:04 <younder> I'm involved in cryptology.
07:15:16 <shapr> Oh, I don't do anything with crypto. I once made an abortive attempt to implement RFC3161 in Java, and that was enough for me.
07:18:08 <younder> I recommend http://www.amazon.com/The-Code-Book-Science-Cryptography/dp/0385495323/ref=sr_1_3?ie=UTF8&qid=1337782622&sr=8-3
07:20:53 <vraid> that's a good history of cryptography
07:21:12 * hackagebot oi 0.2.0.1 - Library for purely functional lazy interactions with the outer world.  http://hackage.haskell.org/package/oi-0.2.0.1 (NobuoYamashita)
07:21:19 <arcatan> shapr: no finnish anymore? :(
07:21:35 <earthy> whoa, shapr.
07:22:46 <younder> I am writing a functional compiler, I call Formula,in Haskell.
07:23:08 <shapr> hyv√§√§ huomenta arcatan!
07:23:13 <shapr> hoi earthy!
07:23:24 <shapr> younder: Neat, what does it do?
07:23:58 <arcatan> shapr: :)
07:24:13 <younder> shapr, It is for parallel programming
07:26:36 <shapr> younder: Are you using NDP under the hood?
07:27:33 <younder> No i trust my 6 core I7. then I go to amazon for full power
07:32:29 <Cale> younder: NDP is nested data parallelism
07:33:58 <womb> goo.gl/YUFvb lol lol lol last tweet on haskell
07:33:58 <womb> :D
07:34:00 <Cale> younder: http://www.youtube.com/watch?v=NWSZ4c9yqW8 there's a talk about it here
07:34:03 <younder> Cale haven't heard of that.
07:36:00 <younder> cale thanks for that
07:37:03 <Cale> It's still quite experimental, but edging toward usability in GHC.
07:40:09 <fmap> Are there any workarounds to help vty-ui not die on unicode input?
07:44:58 <cheater> hi
07:47:55 <cheater> fmap: try compiling my vty tutorial and see if it still dies
07:48:03 <cheater> fmap: maybe it's something in your app? (?)
07:50:07 <byorgey> womb: hehehe, I love it =)
07:50:41 <byorgey> I want that on a t-shirt
07:58:01 <fmap> cheater: well, vty is certainly unicode-aware so various vty examples work fine
07:58:15 <fmap> the problem is with specific vty-ui widgets
07:58:23 <cheater> fmap: oh
07:58:32 <cheater> fmap: sorry, i didn't realize vty-ui was a separate thing
07:58:47 <shapr> womb: I want that in a higher resolution, who made it?
07:59:21 <womb> you need to check twitter :)
07:59:30 <applicative> \me grrrr new pipes library too hard for poor applicative
07:59:35 <applicative> grrrr new pipes library too hard for poor applicative
07:59:38 <armlesshobo> is there a command or something in ghci to get a snippet of info about a function or type?
07:59:39 <applicative> and so on
07:59:39 <womb> this guy @robstewartUK
07:59:45 <armlesshobo> like, more than just the signature
07:59:45 <womb> shapr: check this guy @robstewartUK
07:59:52 <applicative> :t tells you type
07:59:52 <byorgey> applicative: there is :info
07:59:53 <lambdabot> parse error on input `type'
08:00:01 <armlesshobo> i know of :i and :t
08:00:03 <applicative> :i tells you other info
08:00:16 <byorgey> there's nothing other than those
08:00:28 <applicative> armlesshobo: you may getting close to the limit...
08:00:31 <Saizan> there's hoogle --info if you have hoogle installed
08:00:38 <byorgey> it would be really cool if there was a way to have docstrings, but there isn't
08:01:18 <Saizan> iirc there's a page on the wiki explaining how to integrate hoogle in ghci
08:01:44 <byorgey> oh, hehe, applicative and armlesshobo both have nicks beginning with 'a' that are the same length and given the same (hard-to-read, dark blue) color by my IRC client
08:02:07 <byorgey> I only just now realized they are separate =)
08:02:13 <applicative> class Armlesshobo where ...
08:02:16 <armlesshobo> byorgey: or are we?
08:02:24 <armlesshobo> :|
08:02:26 <applicative> class Armlesshobo a where ...
08:02:28 <byorgey> well, I suppose I have no way to know for sure
08:03:03 <byorgey> armlesshobo: if I asked you what applicative would say if you asked him if he was not you, what would you least want to reply?
08:03:37 <armlesshobo> byorgey: i would say the opposite of what he would say to you
08:04:00 <byorgey> aha! then you really must be the same!
08:04:03 <byorgey> LOGIC FTW
08:04:08 <armlesshobo> LOL
08:04:57 <codensity> I remember reading an interview with the late Goedel, saying
08:05:13 <codensity> Logic is very powerful, the a priori  is greatly neglected
08:05:56 <smithw> Hi, is there a Windows COM bindings module for Haskell? I couldn't find anything on google...
08:05:58 <codensity> ... just after after arguing for a truly bizarre form of fatalism ....
08:09:39 <codensity> smithw: looks like you'll have to enquire again when one of the Windows wizards is around.
08:10:22 <yitz> smithw: not exactly. but there is good support for ffi to windows dlls. so you would write the com bindings in the usual way in c, then connect to them via ffi. there is a good article on the wiki with instructions, look for it.
08:11:00 <yitz> smithw: disclaimer: i am *not* a windows guru. but i saw the wiki article. :)
08:11:16 <armlesshobo> i'm not a windows guru, but i play one on IRC
08:11:17 <armlesshobo> :)
08:11:32 * codensity was about to say "hail yitz guru"
08:11:40 <armlesshobo> LOL
08:11:47 <yitz> codensity: whew. got out of it just in the nick of time.
08:13:34 <applicative> smithw, even if these folks don't count others do. Many of their nicks begin with 'p'
08:33:32 <smithw> yitz, applicative, thanks... I was just wondering if I could write simple MSOffice macros in haskell. I usually do it in python, but if I have to go to C, I guess it's a little too much. but thank you guys for your time :)
08:35:40 <fmap> Okay, I rephrase my question. Is there a way to know what specific Prelude.head says "Prelude.head: empty list"?
08:35:58 <Clint> what?
08:36:10 <tac-tics> > head []
08:36:11 <lambdabot>   *Exception: Prelude.head: empty list
08:36:24 <Cale> fmap: Don't use head, instead pattern match, or use a lambda.
08:36:28 <tac-tics> fmap: How many Preludes do you use?
08:36:49 <Cale> (\(x:xs) -> x)  will give an error which includes the line number on which it was written.
08:36:54 <S11001001> @hoogle NonEmpty
08:36:54 <lambdabot> Test.QuickCheck.Modifiers NonEmpty :: [a] -> NonEmptyList a
08:36:55 <lambdabot> Test.QuickCheck NonEmpty :: [a] -> NonEmptyList a
08:36:55 <lambdabot> package NonEmpty
08:38:41 <fmap> That's not my head, this head is in some module I (possibly indirectly) depend on.
08:39:05 <navaati> "That's not my head" hahaha
08:40:19 <armlesshobo> are there flags that reduce the size of the compile binary?
08:40:34 <navaati> -Os
08:40:46 <navaati> iirc
08:41:06 <navaati> but you must get used to it : haskell binaries are super fat
08:42:15 <Axman6> use strip
08:43:46 <armlesshobo> lol after strip it's 873kb
08:43:47 <armlesshobo> lol
08:43:55 <navaati> oO
08:44:09 <armlesshobo> i could have sworn at one point i was able to bring it down to like 10k
08:44:12 <navaati> i usually end up with 20MB binaries‚Ä¶ i need to test this
08:44:48 <armlesshobo> ahhh
08:44:49 <armlesshobo> that's why
08:44:52 <armlesshobo> it's statically linked
08:44:53 <armlesshobo> lol
08:44:55 <armlesshobo> :|
08:45:13 <armlesshobo> how do i tell it to not statically link anything?
08:45:29 <navaati> -dynamic, i think
08:45:30 <armlesshobo> -dynamic
08:45:31 <armlesshobo> yes
08:45:32 <armlesshobo> :)
08:46:07 <navaati> (hum, not so much efficient : on a yampa+gloss example i go from 10MB to 5)
08:46:27 <armlesshobo> that's a 50% decrease
08:46:28 <armlesshobo> lol
08:46:38 <navaati> yeah but that's still fat
08:46:44 <applicative> smithw: hm, that's irksome, I still wonder if you're just here at an unhappy moment.  Did you notice,  speaking of Office that pandoc now writes docx?
08:47:43 <armlesshobo> hmm
08:48:00 <armlesshobo> it seems i'm at the mercy of available shared libs
08:48:03 <armlesshobo> for haskell
08:48:19 <akosch> applicative: pandoc now writes docx!?! great, but how? does it generate the xml directly?
08:48:25 <applicative> yes
08:48:34 <armlesshobo> since I'm using Data.String.Utils, it can't find a dynamic lib for it
08:48:41 <applicative> it's an ordinary writer,  it compresses it
08:49:35 <quicksilver> there is also the strip-objs stuff, which  generates smaller static libs by putting each symbol in a separate object file
08:49:46 <quicksilver> makes the linker work really really hard but results in smaller binaries
08:49:48 <applicative> akosch, it upset me a little since I had been working as a preliminary on a writer for the plain xml format, but it's just  as well
08:49:48 <quicksilver> I think.
08:49:50 <akosch> applicative: I'm want to generate docx myself, but haven't found anything related in haskell yet (I have an existing C# project which uses the OOXML sdk, which I need to port)
08:49:51 <shapr> akosch: Whoa, seriously?
08:50:48 <applicative> akosch you should be able to write 'programmatically' if you can fit it with the pandoc types
08:51:12 <akosch> applicative: I was thinking of abstracting the docx part into a .NET executable, which I then can wrap like a library
08:51:21 <applicative> akosch: it should be noticed that it's all gpl'd which affects some uses
08:51:25 <akosch> applicative: but it would be much nicer in plain old Haskell
08:52:09 <akosch> applicative: well GPL isn't necessarily an issue for me, but I have to double-check. thanks for mentioning!
08:54:23 <applicative> akosch: here's the writer https://github.com/jgm/pandoc/blob/master/src/Text/Pandoc/Writers/Docx.hs
08:55:20 <applicative> akosch: it uses a default "reference.docx" to hold the styles and so on, like a latex preamble
08:57:39 <krakrjak> > :t return
08:57:39 <lambdabot>   <no location info>: parse error on input `:'
08:57:44 <krakrjak> :t return
08:57:45 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
09:01:02 <akosch> applicative: problem is, I need to parse complete docx files, alter them and write them out again...
09:02:36 <armlesshobo> when I do readFile, does the file get locked? or does it get locked, read, and then unlocked automagically?
09:02:50 <armlesshobo> does the file stay locked?*
09:03:10 <navaati> what kind of locking do you refer to ? i don't think there is such a thing
09:03:45 <armlesshobo> navaati: well, i'm trying to write something that reads contents of a file, replaces some patterns with new patterns and write the new contents back
09:04:06 <armlesshobo> so I do a readFile and then a writeFile after the contents are changed
09:04:48 <navaati> hum, be carefull with this approach
09:05:22 <armlesshobo> navaati: what would you recommend?
09:06:00 <navaati> you should ensure, because of lazy evaluation, that the file is fully read before writing again into it
09:06:21 <armlesshobo> navaati: wb :)
09:09:02 <armlesshobo> would it be better to do openFile, hGetContents, close the file, change the contents, open it back up, hPutStr, and then close it?
09:09:06 <armlesshobo> navaati: ^
09:10:07 <navaati> nop, because there is still a risk that you close the file because the data are read
09:11:18 <rwbarton> in general it is better to avoid reading and then writing to the same file at all
09:11:52 <rwbarton> for example what if your program crashes right after opening the file for writing
09:13:24 <rwbarton> if you have to do this, the common thing to do is write to a temporary file and then once you've finished writing and closed the file, move it over the input file
09:15:19 <armlesshobo> rwbarton: ok, sounds a lot better
09:22:22 <applicative> akosch: I see a docx parser too. When I was studying the specification and all I had trouble getting the going xml parsers in haskell to read the darn stuff, there are many MS curiosities
09:23:46 <applicative> akosch: it would be an interesting thing to work on.  for your purposes though you'd also need to see you could squeeze the content you want through the pandoc types
09:26:52 <applicative> akosch: if you could, though, there are swank ways of making global transformations inside the pandoc type
09:30:08 <fmap> cheater: I've revisited your tutorial. Actually inputting Œ± (or another unicode) crashes it as well.
09:32:06 <cheater> fmap: interesting
09:36:02 <covi> Hi guys, I have two questions regarding I/O: (1) Can I lazily get number of lines of a file? (2) Can I get a specific line of a file?
09:37:16 <Axman6> how could you lazily get the number of lines in a file lazily? you have to read the whole file to know how many new line characters it has
09:38:11 <covi> Axman6: I see. How to read a file into a list of all lines?
09:38:56 <Axman6> fmap lines $ readFile "foo.txt"
09:38:57 <rwbarton> well here is the most straightforward way:  do { foo <- readFile "myFile"; ... (lines foo) ... }
09:39:34 <covi> Axman6: thanks
09:39:48 <covi> rwbarton: fmap will be more concise. Thanks
09:40:25 <andares> argh, figuring out how to implement traverse is harrdd
09:40:51 <navaati> :t traverse
09:40:52 <lambdabot> Not in scope: `traverse'
09:41:20 <krakrjak> Axman6: use Data.ByteString.Lazy for a performance boost.  lines in Prelude is SLOW on large files.
09:41:29 <andares> it's the thing with type signature [a] -> (a -> m b) -> m [b]
09:42:51 <andares> my idea was to first return [a] to get m [a], then do >>= to get [a] back, then >>= again to get a, then apply (a-> m b) to get m b, and then do >>= to get b out of m b but use the identity map and hope things fall into place type-wise.
09:42:59 <andares> but I think I'm really over-thinking this.
09:44:20 <Cale> traverse :: Applicative f => (a -> f b) -> t a -> f (t b)
09:45:02 <andares> yeah.
09:45:13 <Cale> What's your t?
09:45:21 <andares> [].
09:45:21 <navaati> oh, strange‚Ä¶ but i don't see how it's possible : doesn't t need to be an applicatve ?
09:45:34 <andares> it is an applicative :p
09:45:37 <Cale> [] is already an instance of Traversable
09:45:49 <Cale> Or you just want to understand how to write that instance?
09:45:54 <andares> Cale: I'm doing it as a practice problem but I'm banging my head against the wall.
09:46:10 <Cale> Well, you'll want to use the Applicative combinators, rather than Monad
09:46:22 <Cale> <$> (or fmap) and <*>
09:46:29 <andares> :t <*>
09:46:30 <lambdabot> parse error on input `<*>'
09:46:33 <Cale> :t (<*>)
09:46:34 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
09:46:46 <andares> right, I just implemented that actually :p
09:47:22 <Cale> also pure
09:47:24 <andares> so if I could transmute (a -> f b) into f (t a -> t b)
09:47:25 <Cale> :t pure
09:47:26 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
09:47:42 <andares> then I could use <*> trivially.
09:47:44 <Cale> Let's think about it recursively.
09:48:04 <Cale> traverse f []
09:48:49 <Cale> will have to be  pure []
09:49:01 <Cale> because we don't have any elements to apply f to
09:49:01 <andares> naturally.
09:49:10 <Cale> traverse f (x:xs)
09:49:19 <andares> now here I ran into trouble.
09:49:23 <covi> I want to write a function [IO String] -> [String], but I don't know how to do that. Any help?
09:49:38 <Botje> covi: you can't.
09:49:42 <applicative> covi, if  the files are unicode, you can use fmap T.lines (T.readFile blah) with Data.Text ; if ascii you can get an easy count with  fmap B.count '\n' (B.readFile blah)using Data.ByteString.Lazy.Char8
09:49:50 <Botje> not if you want to use the IO Strings in a meaningful way.
09:49:53 <applicative> covi, no you dont want that
09:50:09 <covi> I'm confused...
09:50:10 <applicative> covi, say more about what you want
09:50:19 <Cale> we want to apply f to x, giving an f b, and we want to traverse xs, giving an f [b], and then we want to connect the results together again
09:50:21 <applicative> it's okay, it happens all the time :)
09:50:22 <Axman6> you can write [IO String] -> IO [String] though
09:50:33 <covi> I have a list of file paths, and I want to read their contents correspondingly into a list of contents
09:50:49 <andares> Cale: but I can't connect them because they're f [b] and f b instead of [b] and b.
09:50:52 <applicative> covi, the question to ask, is what are you going to do with that [String] once you get it?
09:50:57 <Cale> Well, we want to (:) the results of those Applicatives.
09:51:03 <Cale> and we have liftA2
09:51:09 <covi> applicative: map lines them
09:51:09 <andares> :t liftA3
09:51:09 <Cale> which does that
09:51:10 <lambdabot> forall a b c d (f :: * -> *). (Applicative f) => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
09:51:12 <andares> d'oh
09:51:17 <andares> :t liftA2
09:51:18 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
09:51:24 <Cale> :t liftA2 (:)
09:51:25 <lambdabot> forall a (f :: * -> *). (Applicative f) => f a -> f [a] -> f [a]
09:51:38 <applicative> fmap (map lines) iostringthing
09:51:44 <Cale> or we can do it more directly, using  (:) <$> f x <*> traverse f xs
09:51:48 <andares> hm, I see.
09:52:00 <andares> wait.
09:52:13 <applicative> covi, or better, since mapping lines is a pure operation, what are you going to do next?
09:52:30 <applicative> what if the final output action you want to see?
09:52:51 <andares> :t (<$>)
09:52:53 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:52:55 <Cale> :t \f x y -> f <$> x <*> y
09:52:56 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> f a1 -> f b
09:52:57 <covi> [[lines of first file], [lines of 2nd file]] etc
09:53:01 <covi> applicative: ^
09:53:04 <andares> okay, just fmap.
09:53:12 <Cale> :t [\f x y -> f <$> x <*> y, liftA2]
09:53:13 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => [(a -> a1 -> b) -> f a -> f a1 -> f b]
09:53:18 <covi> applicative: fmap (map lines) [readFile "test.hs"] does not work
09:53:20 <Cale> ^^ they're actually the same :)
09:53:22 <applicative> you want to print these things, sacethem
09:53:40 <applicative> covi, no, that would be fmap lines (readFile...)
09:53:55 <applicative> I though you had an IO [String]
09:54:06 <andares> :t (:) <$>
09:54:07 <lambdabot> parse error (possibly incorrect indentation)
09:54:25 <applicative> oh i see, you put readFile in []
09:54:36 <Cale> :t ((:) <$>)
09:54:37 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f ([a] -> [a])
09:55:50 <applicative> main = do { filecontentses <- mapM readFile ["a.txt","b.text"]; print $ covi'spurefunction filecontentses}
09:56:01 <Gurragchaa> Are there any displays of example code using Monads?  I'm still having a hard time understanding what a Monad is.
09:56:36 <applicative> covi, main will be something like that the main business will be writing a function [String] -> something, where the something is what you want printed
09:56:59 <Eduard_Munteanu> Gurragchaa: sure, quite a bit. Did you go through LYAH? ...
09:57:02 <Eduard_Munteanu> @where lyah
09:57:02 <Cale> Gurragchaa: A monad is a type constructor which supports a specific API (minimally, return and (>>=), and lots of things defined in terms of those two)
09:57:02 <lambdabot> http://www.learnyouahaskell.com/
09:57:21 <covi> applicative: I'm confused. readFile :: String -> IO String, and that statement will return something of type :: IO String.
09:57:27 <applicative> the function covi'spurefunction :: [String] -> [Int] or whatever
09:57:31 <Cale> Gurragchaa: Lots of libraries fall into the pattern of defining operations which are the same "shape" as this, and so Monad captures this pattern and gives it a name.
09:57:31 <applicative> yes, covi
09:57:35 <Eduard_Munteanu> Gurragchaa: you might want to look at specific monads, stuff like State, Reader and such.
09:57:43 <covi> applicative: it's automatically printed in my ghci.
09:58:12 <Botje> Sometimes I think a daily monad class would make a lot of things easier :)
09:58:18 <applicative> yes, but ghci can be a little misleading where you are reflecting on this stuff
09:58:26 <Eduard_Munteanu> Gurragchaa: as for what it is, think of it as a common "pattern" certain concepts fit.
09:58:39 <applicative> since it is appying print for you, or if it's a string it's applying putStrLn
09:59:03 <covi> I want my program works as a standalone script, so I should manually write putStrLn right?
09:59:11 <Cale> There are a few other things in the libraries which are like this too. Functor, Applicative and Arrow among them.
09:59:13 <applicative> so you dont notice the crucial bit, that what beging with readFile, must end with an io action
09:59:31 <Cale> (common "shapes" that library APIs have in them)
10:00:06 <coppro> What's the usual way of keeping track of objects through multiple references when working with state, when a change to one needs to update all access pathways to it? Using an ID numbering system?
10:00:19 <applicative> covi right your script will look some like I said.  main = mapM readFiles [....] >>= \strings -> writeFile "log" (covifunction string)
10:00:23 <applicative> for example
10:00:40 <applicative> main = mapM readFiles [....] >>= \strings -> putStrLn (covifunction string)
10:01:05 <covi> My mind blows (sorry for this cliche).
10:01:09 <applicative> in between you must write covifunction, which has nothing to do with IO it's  just  Strings to whatever
10:01:12 <covi> Haven't met >>=
10:01:49 <applicative> it's the same as the do bit I wrote above, its easier in irc to write, less easy in practive
10:01:57 <Cale> Gurragchaa: For example, imagine a library for constructing parsers (for turning text into datastructures). Such a library might have a type constructor Parser where a value of type Parser t is something which eats some portion of an input string before producing a value of type t.
10:02:17 <covi> applicative: thanks for your great help. I guess I have to go back to LYAH's I/O section :)
10:02:20 <applicative> a >>= f is the same as do x <-a; f x
10:02:35 <Cale> Gurragchaa: It might also define a parser which doesn't eat any of the input, but immediately accepts and returns some specific value:  return :: t -> Parser t
10:02:52 <applicative> or maybe I should write it a >>= \x -> f x
10:03:07 <Cale> Gurragchaa: and it might give a way to take the result of some first parser in determining how to parse the remainder of the input
10:03:22 <Cale> (>>=) :: Parser a -> (a -> Parser b) -> Parser b
10:03:38 <Cale> Would take a parser which parses the first part of the input with its left parameter
10:04:05 <andares> Cale: thanks, that makes sense now. although I have no idea how I'd ever have gotten to that conclusion, this stuff seems impossible.
10:04:06 <Cale> and a function which would be applied to the result of the first parser, to give a parser for reading the rest of the input
10:04:29 <Cale> andares: As you become more familiar with what Applicative can do, it becomes more obvious.
10:04:32 <andares> it just seems like these functions work a kind of magic sometimes.
10:05:43 <Cale> coppro: Your question is a little unclear to me...
10:06:06 <applicative> covi, do you want the script to take arguments for the files, or are  the files going to be built into the script
10:06:10 <krakrjak> andares: I'm with you.  It does seem like magic for a while.
10:06:36 <krakrjak> andares: then the light bulb goes off.  In haskell there are thousands of light bulbs that have to go off before it flows like water.
10:06:40 <Cale> Gurragchaa: These two things would let us make Parser an instance of Monad, which would give us all of Control.Monad and many other libraries which are abstracted over a choice of monad, for free.
10:06:57 <andares> this seems true.
10:07:04 <coppro> Cale: Ok, suppose I'm working with state. My state contains a bunch of objects, each of which have conceptual references to the others.
10:07:11 <Cale> Gurragchaa: For example, we'd get  sequence :: [Parser a] -> Parser [a], which would take a list of parsers, and give a parser producing lists of results (concatenation of parsers)
10:07:43 <krakrjak> andares: I just spent 15 minutes showing a colleague the following: fmap (length . lines) $ readFile "foo.txt"
10:07:49 <Gurragchaa> couldn't that be done with vanilla functional code?
10:07:51 <coppro> (suppose each object has three adjacent objects, say)
10:08:01 <krakrjak> andares: he almost got discouraged while I tried every other form that doesn't work first :)
10:08:01 <covi> :t mapM
10:08:02 <Cale> Gurragchaa: yes.
10:08:02 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
10:08:15 <coppro> so I conceptually have three references to any object, from its neighbors
10:08:19 <andares> krakrjak: hehe
10:08:24 <Cale> Gurragchaa: Monads are entirely composed of vanilla functional code.
10:08:34 <Eduard_Munteanu> Gurragchaa: yes, but you'd have to thread the state manually.
10:08:41 <Cale> Gurragchaa: With the possible exception of some built-in ones like IO.
10:08:52 <covi> mapM print [1,2,3]
10:08:54 <coppro> but obviously I cannot make them all different, since that would store three copies of the same thing and changing one copy would not change the other two
10:09:13 <genneth> @seen benmos
10:09:14 <lambdabot> Unknown command, try @list
10:09:15 <Cale> (but IO just happens to be a monad, there's nothing magical about the way in which it's a monad, the magic is in how IO actions get executed)
10:09:15 <covi> mapM print [1,2,3] will print 1 2 3 in ghci, but whatif I write it in a standalone script? Anything to add?
10:09:29 <genneth> how does lambdabot's 'seen' command work these days?
10:09:36 <Cale> genneth: It doesn't.
10:09:36 <Gurragchaa> Will studying category theory help in learning Haskell?
10:09:43 <rwbarton> covi: you should use mapM_, but otherwise no
10:09:46 <applicative>  you can write main = mapM_ print [1,2,3]
10:09:48 <rwbarton> well, except "main = "
10:09:52 <Gurragchaa> seems that's where Monads come from
10:10:15 <covi> :t mapM_
10:10:16 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
10:10:16 <S11001001> studying Haskell helps in learning category theory
10:10:17 <applicative> covi: mapM_ doesn't return anything, mapM will return [(),(),()] in this case, which is not very desirable information
10:10:19 <Cale> Gurragchaa: It's useful, but if you're just interested in learning Haskell, unnecessary
10:10:26 <coppro> Cale: in C, I would handle this with pointers, since each object could retain a pointer to the underlying object. In Haskell, is there an equivalent idiom?
10:10:27 <covi> applicative: ty!
10:10:41 <covi> rwbarton: thanks :) guess you're pretty comfortable with IO
10:10:44 <krakrjak> Gurragchaa: I think so.  I'm learning more deeply about the structure of haskell and the enlightenment seems to come from a better understanding of functors, applicative and monads.  All seems like category theory to me.
10:11:14 <tac-tics> krakrjak: It's tutrles all the way down. And then you start talking about the category of turtles.
10:11:26 <Cale> Gurragchaa: If you're studying mathematics, by all means, learning category theory will be a nice distraction from learning Haskell with some benefits to both it and other areas of mathematics.
10:11:28 <krakrjak> tac-tics: hahahaha!
10:11:40 <Cale> Gurragchaa: But if you're hoping to write programs, it's just a distraction :)
10:12:30 <krakrjak> Gurragchaa: You can definitely write useful programs and have fun with almost 0 category theory knowledge.  I say almost 0 because you'll know some after using Haskell, even if you don't realise it.
10:12:37 <Cale> If, on the other hand, you're interested in writing really beautiful programs, and finding new abstractions to apply to programming, there's a lot of inspiration which can come from CT.
10:12:47 <Gurragchaa> I'm really interested in learning CT anyway so, I might as well
10:13:02 <tac-tics> What if you want to write really beautiful programs that other programmers can maintain? ;P
10:13:03 <applicative> covi, if the script reads "main = mapM_ print [1,2,3]" then you can do 'runhaskell myscript.hs' or else 'ghc --make -O2 myscript.hs' to make a myscript executable
10:13:27 <covi> applicative: i see =)
10:13:27 <Cale> tac-tics: That's the nice thing about abstractions, is that once you specialise them, they become invisible.
10:13:38 <Cale> (mostly! :)
10:13:43 <tac-tics> "My program is so beautiful, only PhDs in mathematics can fix bugs in it. No lousy web developers getting their dirty mitts on it!" :P
10:14:02 <Eduard_Munteanu> Gurragchaa: now it's a good time to spam about ##categorytheory   :P
10:14:12 <Cale> tac-tics: You can take things from CT, and specialise them into Haskell, and anyone who didn't already know wouldn't be able to tell that they were there.
10:14:14 <applicative> covi: the -O2 is just a standard optimization level, there are a million flags of course
10:14:27 <tac-tics> Cale: for sure.
10:14:32 <Cale> tac-tics: Or be able to tell that they came from CT.
10:14:46 <tac-tics> I couldn't tell you what monads have to do with functors, but I do love me some do-notation.
10:14:46 <Cale> (they might just translate into some part of a library API)
10:15:08 <krakrjak> tac-tics: big do fan myself.
10:15:19 <applicative> covi, are you accustomed to using pipes in the terminal,  echo abc | ... > a.txt and so on?
10:15:21 <covi> applicative: my feeling so far is, one can't write anything in Haskell if he does not really understand.
10:15:28 <covi> applicative: yeah :)
10:15:50 <krakrjak> covi: you're wrong I have plenty of examples of code I wrote...
10:16:01 <covi> krakrjak: I'm a n00b dude
10:16:03 * tac-tics never learned what "Applicative style" actually way.
10:16:15 <applicative> note the interact function  it will make sometehing you can pipe strings through  you write main = interact covi, then you covi :: String -> String
10:16:18 <krakrjak> covi: not for long at this rate! :)
10:16:49 <krakrjak> covi: have you had fun learning the language?
10:16:53 <covi> I once read the interact function, but it just disappeared in my memory
10:17:08 <applicative> so to reverse a file you write main = interact covi; covi = reverse ; then cat a.txt | runhaskell covi.hs will print the reversed file, to take an idiotic example
10:17:30 <covi> krakrjak: Man, tons of fun. I have already abandoned serious work in order to have fun Learning Haskell
10:17:47 <krakrjak> covi: same here!
10:18:06 <covi> applicative: thanks for the example, gotcha
10:18:33 <tac-tics> IIRC, isn't applicative just a monad that can't control its own destiny?
10:18:45 <coppro> Cale: does that summarize the situation mostly?
10:18:59 <covi> applicative: main = interact reverse; right?
10:19:05 <applicative> yeah, try that
10:19:08 <covi> Concise. Elegant.
10:19:35 <krakrjak> way to move the ; that takes guts
10:19:40 <covi> applicative: I wonder how many years of experience you have had with haskell
10:20:02 <applicative> i don't know maybe 3?  But i'm not a programmer
10:20:28 <krakrjak> applicative: that's too bad.  looks like you missed a calling :)
10:20:41 <applicative> so my Haskell knowledge is a strange combination of advanced and primitive
10:20:55 <coppro> ^
10:21:23 <krakrjak> I think mine is in the sewers, but can occassionally reach the heavens (by accident of course).
10:25:20 <Cale> coppro: IntMaps can be used to simulate anything you could do with pointers, more or less.
10:25:23 <covi> Why mapM_ readFile [Path1, Path2] will not print the contents of my files to terminal?
10:26:09 <covi> To my poor knowledge of type system, it should return IO ()
10:26:14 <coppro> Cale: That was one option, but there's no more canonical one for that sort of issue?
10:26:18 <Cale> covi: Because the _ at the end of mapM_'s name is an indication that you don't care about the result, and it should be discarded.
10:26:50 <covi> Cale: the result of what? The sequenced IO action's result?
10:27:07 <Cale> coppro: If you're in IO, there's IORef and lots of other kinds of mutable references which work more or less like pointers.
10:27:11 <applicative> mapM readFile ["a.txt", "b.txt"] is the action that discovers the contents of the two files, and then throws them away
10:27:28 <Cale> applicative: nope, that one keeps them :)
10:27:38 <applicative> sorry mapM_ readFile is what I was talking about
10:27:43 <applicative> or am I wrong?
10:27:50 <Cale> That's right
10:28:01 <Cale> mapM readFile is what covi is looking for
10:28:10 <Cale> mapM_ readFile discards the results
10:28:25 <applicative> Cale, yes, but the he needs to do something with the result of the action.
10:28:41 <covi> :t mapM
10:28:42 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
10:29:17 <covi> So since m is IO here, I can do  contents <- mapM readFile fileList here right?
10:29:21 <applicative> covi try e.g. main = mapM readFile [...] >>= \strings -> mapM putStrLn strings
10:29:36 <applicative> that will print them to screen in sequence
10:30:05 <applicative> or main = do stringlist <- mapM readFile [...]; mapM_ putStrLn strings
10:30:12 <applicative> i keep leaving of the underscore
10:30:24 <applicative> to Cales justified annoyance
10:30:45 <covi> applicative: yeah I am now doing exactly your second solution! I got it!
10:31:03 <coppro> Cale: is there an equivalent for State?
10:31:16 <Cale> coppro: With State, you'd use IntMap
10:31:25 <Cale> coppro: There's ST
10:31:25 <coppro> hrm
10:31:32 <coppro> ST is threading, right? I don't want that.
10:31:37 <Cale> no
10:31:46 * hackagebot shakespeare-js 1.0.0.3 - Stick your haskell variables into javascript/coffeescript at compile time.  http://hackage.haskell.org/package/shakespeare-js-1.0.0.3 (GregWeber)
10:31:53 <applicative> covi: with the first, mapM you actually want the list of strings, with the second, you use mapM_ because you aren't 'returning' anything, it's the end of the line
10:32:12 <coppro> Cale: Oh. What's it for then.
10:32:15 <coppro> Apparently I'm stupid.
10:32:17 <Cale> ST basically just gives you STRefs and STArrays which are mutable references and arrays respectively
10:32:36 <Cale> together with runST which will run an ST action, producing a pure result
10:33:09 <Cale> runST :: forall a. (forall s. ST s a) -> a
10:33:29 <Cale> newSTRef :: a -> ST s (STRef s a)
10:33:45 <Cale> readSTRef :: STRef s a -> ST s a
10:34:02 <Cale> writeSTRef :: STRef s a -> a -> ST s ()
10:34:35 <coppro> hmm... that might be what I want
10:34:46 <Cale> The key thing about runST's type is that it ensures that no STRef escapes in the result of the action.
10:34:57 <Cale> (preserving referential transparency)
10:35:05 <edwardk> or if they do that you can't do anything with them
10:35:19 <coppro> right
10:35:39 * coppro still can't intuit Haskell program design at all
10:36:15 <Cale> Yeah, you can smuggle them out with a datatype which will forget the 's', but this will make them unusable.
10:36:58 <Cale> So it's local state only.
10:37:07 <Cale> Still, I rarely if ever use ST.
10:37:47 <tommd> I'm slightly surprised by the lack of Hackage packages using ST for vector operations.
10:37:49 <Cale> I don't think I've ever actually managed to come up with a situation in which ST was the best possible thing for me to use. I'm not saying they don't exist, but it seems fairly rare.
10:38:33 <c_wraith> ST seems to be the best way to write shuffle - it fits nicely in the ST model.
10:38:39 <Eduard_Munteanu> I wonder, can you hide that ugly 's' somehow with implicit args?
10:39:18 <tommd> You can find conversions between immutable and mutable vectors in Data.Vector, you can find sorting algorithms from vector-algorithms, but no package provides a high performance "sort this immutable vector" using the almost-trivial combination of the two.  Things like that surprise me.
10:39:19 <Eduard_Munteanu> Or whatever they're called in Haskell.
10:40:15 <c_wraith> But other things that fundamentally depend on mutability, like Union-Find trees...  ST just doesn't seem to be a good fit.
10:40:36 <rwbarton> you could "hide" it by not writing type signatures...
10:42:24 <Nolrai23> Okay, I have GADT enabled, "data DogmaAction input output =     MoveCard {src :: Location, dest:: Location } :: DogmaAction () Bool" should parse right?
10:42:39 <rwbarton> no
10:42:46 <rwbarton> 'where', not '='
10:42:52 <Nolrai23> Doh!
10:43:03 <rwbarton> also i'm not sure about the record syntax
10:43:51 <hpaste> ‚ÄúJonathan Fischoff‚Äù pasted ‚Äúcabal or cabal-dev issue‚Äù at http://hpaste.org/68913
10:44:02 <joelr> how do you figure out the error location with attoparsec when, for example, parsing a multi-line file?
10:44:07 <joelr> good day
10:44:21 <jfischoff> ^ installing some packages with cabal-dev. Any ideas what that error means?
10:44:42 <jfischoff> or more importantly how to resolve it?
10:46:46 <tgeeky> jfischoff: https://github.com/creswick/cabal-dev/issues/34
10:47:14 <tgeeky> I am on OS X Lion (64-bit) as described before. The solutions seems to be manually changing cabal-config.in to add the $pkgid back in there.
10:47:19 <tgeeky> jfischoff: it's cabal-dev's fault
10:47:40 <jfischoff> thanks tgeeky
10:48:47 <honza> anyone have any luck compiling helium on osx?
10:48:48 <Cale> joelr: I'm not sure if attoparsec keeps track of the location it's at in the input.
10:49:15 <joelr> Cale: i thought so :-( i guess parsec3 it is
10:49:28 * joelr is trying to re-implement iWantSandy
10:55:08 <Cale> joelr: Yeah, parsec is much better suited to parsing human-writable/readable file formats.
10:55:26 <joelr> Cale: natural language in this case
10:55:46 <joelr> Cale: For example‚Ä¶ Sandy, remind me about my haircut appointment on July 6 1-2pm
10:55:51 <Liskni_si> it quite sucks that aeson uses attoparsec and hence gives no sensible error meesages
10:56:21 <tgeeky> can't you drop out attoparsec and drop in parsec?
10:56:24 <tgeeky> or does it not work that way
10:56:35 <Cale> Pretty nearly
10:57:05 <Cale> Probably won't be an *exact* drop in replacement, but should be very easy to adapt.
10:57:08 <joelr> can you use iteratees with parsec3? should you?
10:57:27 <Cale> I don't personally use iteratees for anything, so I couldn't tell you.
10:58:25 <Cale> Iteratees seem appropriate for very high bandwidth work where performance is really important for that reason.
10:58:44 <joelr> Cale: what about memory consumption?
10:58:47 <Cale> If you're manipulating a single line of text like that, I don't see the cost/benefit working out in their favour.
10:59:10 <joelr> Cale: i thought, for example, that parsec required all the input to be available which required large amounts of memory on large files
10:59:58 <Cale> Parsec can parse lazy String/Text/ByteStrings
11:01:39 <Cale> and I'd hope it doesn't retain the beginning of the string while parsing
11:01:44 <Cale> But I could be wrong
11:01:54 <jfischoff> tgeeky: I guess there is a .cabal/config and a cabal-config.in? Where is cabal-config.in?
11:02:36 <tgeeky> jfischoff: dunno. is the first one you mention ~/.caba/config?
11:02:43 <tgeeky> with an l
11:02:49 <jfischoff> yeah
11:03:05 <tgeeky> i think you want the cabal-dev specfic cabal file
11:03:05 <joelr> can you have separate types for, say, statements and expressions? these would be recursive
11:03:06 <tgeeky> maybe
11:03:25 <joelr> well, maybe not statements and expressions
11:03:31 <tgeeky> joelr: decls
11:03:32 <jfischoff> tgeeky: so when I update the cabal-dev file, the second I compile it reverts back
11:03:43 <tgeeky> ah, then we need to find that .in file
11:03:50 <joelr> tgeeky: what's that? (decls)
11:03:55 <jfischoff> tgeeky: cool I'll do a find
11:03:55 <tgeeky> joelr: declerations
11:04:29 <joelr> tgeeky: what do you mean?
11:05:43 <tgeeky> joelr: I was trying to say which kind of thing will require recursion
11:05:53 <joelr> tgeeky: right, of course
11:06:00 <joelr> so how do you do this in haskell?
11:06:19 <tgeeky> oh, just write out the types. recursion (and mutual recursion) is perfectly fine
11:06:35 <joelr> tgeeky: this cannot be done at the ghci prompt, though, can it?
11:06:58 <Cale> joelr: If you want to do mutual recursion at the GHCi prompt, everything needs to go in one command.
11:06:58 <tgeeky> joelr: with ghc 7.4 I think it might be possible
11:07:00 <joelr> it complains about the future type not being defined yet, e.g. when you are defining declarations and expressions has not been defined yet
11:07:18 <joelr> Cale: how do you do that in one command? separate with semicolon?
11:07:20 <tgeeky> joelr: here's an example language with expressions and declerations
11:07:22 <tgeeky> https://gist.github.com/707890
11:07:23 <Cale> joelr: yeah
11:07:28 <joelr> Cale: thanks
11:07:31 <Cale> joelr: But most people create a file in which to place their declarations...
11:07:37 <tgeeky> joelr: there's also a flag with 7.4.1 that automatically makes all entries mult-line
11:07:41 <Cale> joelr: You never know when you might want to save what you've done.
11:07:43 <joelr> tgeeky: cool, thanks
11:07:56 <joelr> Cale: you have a point
11:08:13 <tgeeky> joelr: hehe. just because something's possible doesn't make it a good idea
11:08:20 <joelr> indeed
11:08:33 <Cale> You can keep a text editor open alongside ghci and :r to reload whenever you save the file
11:08:50 <tgeeky> there is a place to edit haskell files on the web now
11:10:23 <jfischoff> tgeeky: FYI, the cabal-config.in is the haskell library location: for example /Users/jonathan.fischoff/Library/Haskell/ghc-7.4.1/lib/cabal-dev-0.9.1/share/admin/cabal-config.in
11:10:51 <tgeeky> jfischoff: yeah, sorry. I found that out rather quickly, but got distracted with other conversations
11:10:57 <tgeeky> but yeah - it's the file that comes with cabal-dev
11:11:05 <tgeeky> so fix the file as they say (something with $pkgid) and then reinstall cabal dev
11:11:08 <tgeeky> and then retry
11:11:21 <jfischoff> tgeeky: roger that
11:11:21 <tgeeky> you might need to bump the version to 0.9.2, or unregister the cabal-dev you have installed
11:11:37 <jfischoff> lets hope not
11:16:49 * hackagebot factual-api 0.2.0 - A driver for the Factual API  http://hackage.haskell.org/package/factual-api-0.2.0 (RudigerLippert)
11:26:51 * hackagebot pdfinfo 0.1.3.1 - Wrapper around the pdfinfo command.  http://hackage.haskell.org/package/pdfinfo-0.1.3.1 (ChrisDone)
11:33:02 <armlesshobo> is there a way to build dynamic libraries for the libraries i installed with cabal?
11:37:01 <tgeeky> what do you mean by dynamic?
11:38:06 <jfischoff> .so, .dll I'm guessing
11:38:11 <jfischoff> shared
11:40:42 <edwardk> preflex: xseen byorgey
11:40:42 <preflex>  byorgey was last seen on freenode/#haskell 3 hours, 36 minutes and 39 seconds ago, saying: LOGIC FTW
11:42:15 <tgeeky> LOGIC FTW is what Bertrand Russell said right before he commited suicide by adding machine, isn't it?
11:42:20 <tgeeky> I hope byorgey is ok
11:44:05 <ifnspifn> only problem was the adding machine could only accomplish an incomplete murder
11:44:58 <ifnspifn> Godel was unavailable for comment at the trial
11:59:12 <Veinor> what's up with hackage and not building docs?
11:59:50 <tgeeky> Veinor: it takes a while. sometimes a long while
12:00:14 <alpounet> iirc, they're built twice a day
12:00:16 <Veinor> there's stuff from 9 days ago that hasn't been done
12:00:19 <Veinor> http://hackage.haskell.org/package/shakespeare-css
12:00:28 <Nolrai> Is there a language option to allow constructors to have an common feild name?
12:00:52 <geekosaur> ?
12:00:54 <Veinor> Nolrai: you can do this for multiple constructors for a single type
12:01:03 <tgeeky> Veinor: something might be wrong with that package. The last version (Apr 9) didn't ever get docs made either
12:01:36 <Nolrai> Oh I see the problem.
12:01:38 <Veinor> tgeeky: yeah, but it doesn't even have a 'build failed'
12:01:45 <tgeeky> Veinor: nope. it doesn't.
12:02:04 <shapr> Are strict ByteString values contiguous utf-8 values in memory, roughly like C arrays?
12:02:17 <Veinor> http://hackage.haskell.org/package/cryptocipher-0.3.4 does have docs, though, so i don't know what's going on
12:02:22 <Gurragchaa> Just out of curiosity, what is the shortest non-terminating Haskell program?
12:02:41 <Gurragchaa> `last [1..]' ?
12:02:47 <tgeeky> > fix (1:)
12:02:48 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
12:03:09 <shapr> main = putStrLn $ show [1..]
12:03:23 <Veinor> main = print 1 >> main
12:03:31 <tgeeky> mine is still shortest :o
12:04:11 <tgeeky> Veinor: I don't know. Maybe it's something to do with the usual dependency problems around text?
12:04:36 <chris2> a bit ot, but perhaps people in here know this: there is a CS department in the US, which uses proof-carrying code for its door locks. anyone know which one it is or what the system is called?
12:04:44 <Veinor> actually
12:04:59 <Veinor> main=main>>main will only terminate with a stack overflow
12:05:32 <Veinor> tgeeky: i interpreted it as 'shortest .hs file that compiles to a program', not 'shortest value that cannot be fully forced'
12:05:53 <Gurragchaa> Honestly I should have specified the latter
12:06:02 <Veinor> in that case it's just fix(1:)
12:06:33 <Veinor> ... except fix isn't in prelude
12:07:06 <Veinor> last[1..] might actually terminate depending on which type it picks
12:08:00 <nyingen> are there any statistics about the popularity of Haskell vs the popularity of Scala in various areas (academia, open source software, etc)?
12:08:22 <tgeeky> nyingen: yes, there are
12:08:30 <tgeeky> can't help you find them, though
12:09:05 <nyingen> tgeeky: you've seen some or you just believe they exist?
12:09:56 <tgeeky> well, I've heard SPJ cite language popularity statistics in his talks
12:10:04 <tgeeky> and i have to assume they include scala
12:10:25 <tgeeky> @quote "talks about"
12:10:25 <lambdabot> No quotes for this person. That's something I cannot allow to happen.
12:14:39 <tac-tics> @quote
12:14:40 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
12:14:43 <tac-tics> :<
12:14:48 <tac-tics> @quote
12:14:48 <lambdabot> sheep1e says: The fourth character presumably represents both "runtime" and "Writer monad", a kind of Haskell pun in Japanese.
12:25:38 <armlesshobo> @quote
12:25:38 <lambdabot> nomeata says: Haskell is basically Swiss: Small, Efficient, and it's fun to explore the higher parts.
12:25:52 <shapr> ha
12:25:58 <shapr> @quote edwardk
12:25:58 <lambdabot> edwardk says: i spend a lot of time hated
12:26:19 <armlesshobo> @quote shapr
12:26:19 <lambdabot> shapr says: I've toked on so many lambdas I'm getting dependent types
12:26:27 <armlesshobo> lmso
12:26:36 * shapr snickers
12:26:39 <armlesshobo> lmao*
12:26:56 <edwardk> nah, you're getting married. and you'll probably have dependents of your own soon enough
12:28:21 <armlesshobo> lol
12:28:34 <armlesshobo> @quote fmap
12:28:34 <lambdabot> applicative says: if you are only beginning to learn Haskell, don't let them talk to you about monads. ask them about fmap
12:28:57 <Peaker> applicative is just jealous
12:29:31 <Peaker> that he can't join too
12:29:39 <armlesshobo> awwwww snap
12:29:47 <ski> @quote please.talk
12:29:48 <lambdabot> Dave_Benjamin says: please talk to your son or daughter about parametric polymorphism
12:30:16 <armlesshobo> @quote body
12:30:17 <lambdabot> edwardk says: 'hey ghc devs can you fix this thing that might or might not be a bug so we can break a huge pile of invariants in your compiler to put go faster stripes on something nobody uses? k
12:30:17 <lambdabot> thx'
12:30:54 <armlesshobo> @quote magic
12:30:54 <lambdabot> ghc says: magic number mismatch: old/corrupt interface file?
12:31:08 <ski> @ghc
12:31:08 <lambdabot> ghc says: parse error in data/newtype declaration
12:31:25 <armlesshobo> @quote >>=
12:31:25 <lambdabot> monochrom says: one ring to rule them all! and in your monad >>= them!
12:31:31 <armlesshobo> :O
12:31:37 <armlesshobo> that it incredible
12:31:38 <armlesshobo> lmao
12:31:49 <edwardk> now that reflection is so much faster i should revisit my old regex monoid
12:31:56 <byorgey> edwardk: looking for me?
12:31:56 <edwardk> (the quote reminded me)
12:33:05 <shapr> edwardk: ha, true that... though I hope to wait till I finish my degree.
12:33:45 <shapr> edwardk: reflecting what?
12:34:07 <edwardk> https://github.com/ekmett/reflection/blob/master/fast/Data/Reflection.hs
12:34:18 <edwardk> which should win any obfuscated haskell contest ;)
12:34:42 <shapr> If you say it's obfuscated, I don't even want to read the source. I'd lose SAN points.
12:35:14 <edwardk> it coerces a 'const a' into a dictionary for class Reifies s a | s -> a where reflect :: proxy s -> a
12:35:31 <shapr> I don't even know what that means.
12:35:52 <byorgey> don't tell edwardk you don't know what something means, he is likely to try to teach it to you
12:35:59 <byorgey> ;)
12:36:56 <ski> "Data and procedures and the values they amass, -- Higher-order functions to combine and mix and match, -- Objects with their local state, the messages they pass, -- A property, a package, the control point for a catch- -- In the Lambda Order they are all first-class. -- One Thing to name them all, One Thing to define them, -- One Thing to place them in environments and bind them, -- In the Lambda Order they are all first-class. ---- R2RS"
12:37:21 <edwardk> shapr: the old way reflection worked was it took some haskell term you gave it, and then made a stable ptr to it, then converted that stable ptr into a number, turned that number into a type and then reflected that number back out of type land and into a term, where it could be dereferenced. the new way is we just magically make up a dictionary by abusing the internals of hugs and ghc
12:37:32 <shapr> byorgey: clearly he was already typing :-)
12:38:03 <shapr> edwardk: Well, the first way certainly sounds overcomplicated.
12:38:20 <edwardk> shapr: well the first way is correct regardless of the way you implement typeclasses
12:38:29 <edwardk> the new way definitely won't work on, say, jhc
12:38:40 <shapr> Oh, I see.
12:40:18 <edwardk> i wonder if i can remove the $! from that code
12:41:28 <sclv> oh christ that is evil
12:41:51 <sclv> really truly horribly evil.
12:42:16 <sclv> i'm alwys stunned when i see something like that.
12:42:18 <Saizan> evil++
12:42:45 <sclv> edwardk: who figured out that dirty trick first, you, ehird, or someone else?
12:42:55 <ski> @quote evil
12:42:55 <lambdabot> Pseudonym says: All hail the Evil Mangler!
12:42:57 <armlesshobo> evil+1
12:43:08 <armlesshobo> @quote vim
12:43:08 <lambdabot> mauke says: @quote vim
12:43:12 <armlesshobo> lol
12:43:13 <armlesshobo> @quote vim
12:43:14 <lambdabot> synx says: Emacs and Vim provide no benefits over a real IDE.
12:43:14 <edwardk> sclv: i think it was ehird who had the idea to try it, not sure which of us got it to work first
12:43:27 <Saizan> edwardk: it should become a language extension
12:43:43 <armlesshobo> anyone here have github project I can look at?
12:43:51 <edwardk> i can eliminate the $!
12:43:55 <edwardk> so the code becomes that much cleaner
12:43:56 <sclv> i mean there's a perverse logic. yr. just making dictionary-passing explicit.
12:43:56 <armlesshobo> I just wanna study formatting and coding styles
12:44:10 <edwardk> reify a k = unsafeCoerce (Magic k) (const a) Proxy
12:44:11 <tgeeky> armlesshobo: look at edwardk's trifecta
12:44:21 <edwardk> yeah
12:44:36 <edwardk> it is serendipitous that dictionaries that have a single member are represented directly _as_ the member though
12:45:27 <edwardk> that makes it clear that i'm coercing a function that takes (forall s. Reifies s a => proxy s -> a)  and passing it 'const a' as the Reifies s a argument, and the Proxy as the second
12:45:54 <sclv> haha yes. things like this remind me of that story of the dude who wrote a tron game and didn't include bounds-checking code and since he was writing straight to the memory buffer the lightcycle ran off the screen and actually overwrote other memory.
12:46:22 <edwardk> well, appropriate given the source material ;)
12:46:29 <sclv> exactly.
12:46:34 <keep_learning> Hello all
12:46:39 <sclv> just this sudden collapse of layers of abstraction.
12:46:53 <edwardk> i had a lightcycle style bbs door back around 92-93, but alas i have no cool anecdotes like that ;)
12:47:01 * hackagebot reflection 1.1.6 - Reifies arbitrary terms into types that can be reflected back into terms  http://hackage.haskell.org/package/reflection-1.1.6 (EdwardKmett)
12:47:16 <keep_learning> I am trying to understand HOOPL and going through the papers ( http://research.microsoft.com/en-us/um/people/simonpj/papers/c-- )
12:47:57 <keep_learning> But only thing I missing is  take a Haskell code and apply HOOPL optimization
12:48:00 <edwardk> its a shame i need the actual Magic newtype
12:48:02 <armlesshobo> edwardk: what's your username on github?
12:48:05 <edwardk> ekmett
12:48:26 <edwardk> https://github.com/ekmett/
12:48:33 <shapr> Any blaze-html users around? What happened to Text.Blaze.Html.text in 5.x ?
12:48:34 <sclv> keep_learning: hoopl isn't just for haskell code, as i recall
12:48:44 <sclv> its much more generic.
12:48:46 <keep_learning> I tried to search  Haskell code optimized using HOOPL
12:48:55 <sclv> hoopl doesn't optimize haskell code.
12:49:09 <sclv> hoopl is a system for writing rules for optimizing generated code in general.
12:49:50 <sclv> there was work on using hoopl in ghc for the new codegen
12:50:02 <sclv> but i don't know if it made it into ghc yet?
12:50:14 <keep_learning> sclv, I want to  use it for Haskell system  and I am beginner in Compiler technology
12:50:42 <keep_learning> I just want to wrap my head around HOOPL and say use it for Haskell code
12:50:42 <edwardk> shapr: i use it just a little, but no idea
12:51:20 <edwardk> ah i haven't updated to 0.5 is why
12:52:26 <keep_learning> sclv, It optimize the Cmm code generated by GHC ( pardon me if I sound stupid ;) )
12:53:28 <sclv> here's some info on how hoopl is getting integrated in ghc: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/NewCodeGen
12:53:57 <thoughtpolice> sclv: it's been in the compiler for a while now (hoopl is a boot lib.) you can use it with -fnew-codegen iirc
12:54:15 <thoughtpolice> sclv: simon mar is working on bringing it up to par with the current one in terms of speed, before it can replace it as default
12:54:17 <sclv> thoughtpolice: thanks.
12:54:38 <thoughtpolice> but he believes it should be able to give better code on average. right now the compile-time hit is too big for him though
12:54:42 <thoughtpolice> may happen by 7.6
12:54:53 <Gurragchaa> Will Haskell be safe from the fallout, if any, of Oracle v Google?
12:55:36 <sclv> i'm pretty sure haskell doesn't use any java APIs :-)
12:55:53 <S11001001> they're comin' after that glasgow cash pile
12:56:12 <byorgey> shapr: some of the generic functionality got moved to blaze-markup
12:56:42 <byorgey> shapr: use toHtml to get Markup, then use renderMarkup from  Text.Blaze.Renderer.Text  from the blaze-markup package
12:56:48 <byorgey> (I think)
12:57:29 <keep_learning> thoughtpolice Is there any blog , code which demonstrate how to use HOOPL for Haskell code ?
12:57:30 <byorgey> disclaimer, I haven't used it, I just know about the blaze-markup stuff because vyom made some of those changes as part of supporting blaze-svg, which in turn supports diagrams-svg
12:59:08 <thoughtpolice> keep_learning: ghc compiles haskell to core, then stg, then c--. hoopl is only used for optimizing the c--. it's a library designed for dataflow optimizations on imperative code. read this paper here: http://research.microsoft.com/en-us/um/people/simonpj/papers/c--/ (the one at the top)
12:59:17 <sclv> keep_learning: ezyang blogged a bit about using hoopl in the context of his work on the new ghc codegen: http://blog.ezyang.com/category/ghc/
12:59:57 <thoughtpolice> unfortunately there aren't really any good examples of using hoopl outside of ghc; you really need to understand the design of the library before you can fully understand how the optimizations work
13:00:04 <keep_learning> sclv, thoughtpolice Thank you
13:00:07 <thoughtpolice> i had some code a long time ago that used hoopl on a GRIN like intermediate language
13:00:11 <thoughtpolice> but i did not save it anywhere :(
13:00:14 <ezyang> Hoopl is pretty neat. There's some good examples on toy C-like languages in the repo.
13:00:24 <keep_learning> thoughtpolice :(
13:00:25 <thoughtpolice> oh yeah, there is that example in the repo
13:00:29 <thoughtpolice> i stand corrected!
13:00:31 <gdoteof> if i have a Day; and I want to get the midnight of that day for a specific timezone as a UTCTime?
13:00:53 <gdoteof> i guess, how would i.  ( to make the sentence closer to gramatically correct'
13:01:14 <hilhil> I'm building a datatype of lambda-expressions, and would like all the variables to be distinct (to avoid having to alpha-convert).
13:01:35 <hilhil> Data.Unique would do the trick, but means all my code has to be in the IO monad
13:01:55 <hilhil> which is overkill -- I don't need global uniqueness, just uniqueness inside some domain
13:02:11 <hilhil> Is there a better solution?
13:02:59 <keep_learning> thoughtpolice  Is there  any way to view to  generated c-- code from Haskell code ?
13:03:18 <S11001001> hilhil: how are you drawing variables?
13:03:27 <thoughtpolice> keep_learning: pass ghc the '-ddump-cmm' flag
13:03:32 <thoughtpolice> if i remember correctly
13:04:01 <keep_learning> thoughtpolice Thank you
13:04:10 <thoughtpolice> keep_learning: if you enable the new codegen with -fnew-codegen, there's another flag that dumps every copy of c-- inbetween every optimization pass done by hoopl
13:04:14 <gdoteof> @hoogle Day -> TimeOfDay -> TimeZone -> UTCTime
13:04:14 <lambdabot> Text.Regex.Base.RegexLike makeRegexOpts :: RegexMaker regex compOpt execOpt source => compOpt -> execOpt -> source -> regex
13:04:14 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
13:04:15 <lambdabot> Data.Sequence zipWith3 :: (a -> b -> c -> d) -> Seq a -> Seq b -> Seq c -> Seq d
13:04:16 <thoughtpolice> but i can't rememeber what it is
13:04:19 <thoughtpolice> ezyang might
13:04:41 <gdoteof> well.  i don't see the relevancy there =D
13:04:48 <hilhil> S11001001: from the integers would do fine.
13:04:49 <ezyang> -ddump-cmmz, for sufficiently recent GHC
13:04:58 <hilhil> (Is that the answer you were looking for?)
13:05:44 <S11001001> hilhil: add State Int to your lambda-producing function, then
13:05:58 <thoughtpolice> hilhil: maybe the value-supply package would be to your liking
13:06:10 <hilhil> I'll look into those -- thanks.
13:06:15 <thoughtpolice> you generate an initial Supply inside IO, but can pull values from the supply inside pure code
13:06:25 <hilhil> Ah, that's nice!
13:06:29 <keep_learning> ezyang, I am uisng ghc-7.4.1
13:07:44 <thoughtpolice> hilhil: if you just wanted an infinite list of unique values, you could do like '(map supplyValue . split) `liftM` newEnumSupply'
13:07:50 <thoughtpolice> i think; it's been a while since i used it
13:08:38 <hilhil> I'll go look into it.
13:11:08 <keep_learning> ezyang, One more thing , Its almost week I am trying to wrap my head around this HOOPL concept. Considering me a Haskell newbie How much time it should take to completely understand or at least write something substantial using HOOPL ( Just a query ).
13:11:33 <hilhil> "This function, together with modifySupply forms a comonad on Supply."
13:11:39 <hilhil> ^^ what does that mean?
13:12:53 <Dtgr> is there a function to convert Int (or Word16 or whatever) to network byte order?
13:13:42 <shachaf> Perhaps Data.Binary has what you want.
13:13:53 <gdoteof> how do I get a `UTCTime` from `Day` `TimeZone` and `TimeOfDay`
13:17:13 <Veinor> @type LocalTime
13:17:14 <lambdabot> Not in scope: data constructor `LocalTime'
13:17:53 <Veinor> gdoteof: use LocalTime :: Day -> TimeOfDay -> LocalTime, and then localTimeToUTC :: TimeZone -> LocalTime -> UTCTime
13:18:20 <Veinor> so utc = localTimeToUTC tz $ LocalTime day tod
13:19:46 <Veinor> @pl \tz day tod -> f tz $ lt day tod
13:19:46 <lambdabot> (. lt) . (.) . f
13:19:56 <Veinor> @pl \tod day tz -> f tz $ lt day tod
13:19:57 <lambdabot> (flip f .) . flip lt
13:20:27 <gdoteof> Veinor: thanks.  again.
13:21:31 <Veinor> no problem!
13:28:03 <RylandAlmanza> I'm back with another question! I bet you guys are excited!
13:29:35 <S11001001> @pl \flip join x y -> join flip y x x
13:29:36 <lambdabot> flip flip id . ((ap . (flip .) . flip) .) . flip id
13:29:59 <danr> @unpl flip flip id
13:30:00 <lambdabot> (\ c f -> c f (\ g -> g))
13:30:14 <Veinor> RylandAlmanza: shoot
13:30:22 <S11001001> fresh
13:31:41 <RylandAlmanza> Thanks, Veinor. Give me a second to put it on hpaste
13:34:01 * tgeeky_ seems to recall that some part of haskell's type system are relations? what was that?
13:34:14 <jfischoff> typeclasses?
13:34:22 <jfischoff> multi parameter that is
13:35:27 <jfischoff> tgeeky_:http://byorgey.wordpress.com/2010/06/29/typed-type-level-programming-in-haskell-part-i-functional-dependencies/
13:36:54 <younder> still into Vivaldi,  spring
13:37:19 <hpaste> RylandAlmanza pasted ‚ÄúTranslating [[Bool]] to [[Tile]]‚Äù at http://hpaste.org/68917
13:37:35 <RylandAlmanza> Veinor: ^
13:37:55 <younder> some love's can't be quenched
13:39:27 <hpaste> a pasted ‚Äúa‚Äù at http://hpaste.org/68918
13:40:51 <Veinor> RylandAlmanza: hmm, not sure offhand
13:41:35 <RylandAlmanza> Veinor: That's ok. Thanks for taking a look. :)
13:42:33 <Veinor> if you don't care about efficiency, you could always use that technique to construct walkable :: [[Bool]], then generate an xyTuple :: [[(Integer, Integer)]] that consists of all the appropriate (x, y) tuples
13:43:12 <Veinor> then zipWith (map (\(x, y, w) -> Tile x y w)) xyTuple walkable
13:47:09 * hackagebot kan-extensions 2.5 - Kan extensions, the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-2.5 (EdwardKmett)
13:48:11 <younder> http://www.youtube.com/watch?v=g65oWFMSoK0'
13:48:17 <younder> class act
13:55:44 <joelr> what is the meaning of := here? "data Decl = Var := Expr"
13:55:58 <kitbuilder> hello
13:56:23 <tgeeky_> jfischoff: good link, but after reading part of it I think I need relations on values no matter what.
13:56:55 <kitbuilder> so, I'm new here. I'm thinking about learning Haskell as my first "big boy" language
13:56:56 <Eduard_Munteanu> joelr: infix constructor
13:57:12 <joelr> Eduard_Munteanu: thanks
13:57:21 <joelr> makes sense
13:57:36 <tgeeky_> jfischoff: furthermore I need relations f :: a -> b, and converses, fInv :: b -> a, and relations over products and over compisition
13:58:00 <Eduard_Munteanu> kitbuilder: well... welcome! :D
13:58:21 <jfischoff> tgeeky_: are you dealing isomorphisms?
13:58:26 <jfischoff> soley?
13:58:36 <kitbuilder> Thank you Eduard. Would anyone here care to answer a few newbish questions for me?
13:58:56 <Eduard_Munteanu> If you ask, yeah.
13:59:13 <tgeeky_> jfischoff: umm. nope. I don't think so
13:59:30 <user99> I'm about to install ghc to attempt in a learning attempt. as well....what would the 'ghcbootstrap' be (installing via gentoo)?
13:59:37 <Eduard_Munteanu> kitbuilder: BTW, there's LYAH as a learning resource, if you're looking for a free book...
13:59:40 <Eduard_Munteanu> @where lyah
13:59:40 <lambdabot> http://www.learnyouahaskell.com/
13:59:51 <kitbuilder> Thanks. Can Haskell be used to create client/server software?
13:59:55 <armlesshobo> so, monads optionally have possible actions associated with them?
14:00:00 <tgeeky_> jfischoff: if you're so inclined
14:00:03 <kitbuilder> ie, the client/server model
14:00:07 <tac-tics_> kitbuilder: Let's find out :)
14:00:09 <user99> Eduard_Munteanu, ;) reading that one now
14:00:18 <tac-tics_> @faq can haskell be used to create client/server software?
14:00:19 <lambdabot> The answer is: Yes! Haskell can do that.
14:00:27 <armlesshobo> IO is a monad, but it performs its action and returns whatever underlying type it has
14:00:37 <tgeeky_> jfischoff: www.iis.sinica.edu.tw/~scm/pub/icfp055fp-mu.pdf <--
14:00:46 <tgeeky_> jfischoff: page 3, bottom right "A Relational Perspective"
14:01:04 <Eduard_Munteanu> user99: equery u ghc -a   tells you  - - ghcbootstrap    : Internal: Bootstrap GHC from an existing GHC installation.
14:01:05 <ion> An ‚ÄúIO a‚Äù is a representation of an action that, when executed, results in an ‚Äúa‚Äù value.
14:01:13 <Eduard_Munteanu> user99: so don't bother, leave it alone :)
14:01:13 <kitbuilder> tac-tics_: thank you. But would you happen to have any tutorials or resources for building client/server
14:01:18 <kitbuilder> ?
14:01:19 <tgeeky_> jfischoff: the final theorem (the goal of the paper) is in section 5 "Generalizing to Trees"
14:01:35 <jfischoff> tgeeky_: sounds interesting, I'll take a look after a commit
14:01:40 <user99> Eduard_Munteanu, thx...I set +doc and +llvm though
14:01:55 <tgeeky_> jfischoff: there is this package on hackage 'relacion' which is about relations (implemented as a pair of IntMaps I think)
14:01:58 <user99> grapefruit looks nice i but I gather use cabal to install it?
14:02:01 <tac-tics_> kitbuilder: Have you seen the usual tutorials for haskell? It sounds like something you'd find in Real World Haskell
14:02:05 <Eduard_Munteanu> user99: you can also set +binary, compiling GHC takes a while.
14:02:11 <tgeeky_> jfischoff: it's in spanish (which I have a translated copy of)
14:02:23 <Eduard_Munteanu> If you want to reduce build time, that is.
14:02:31 <byorgey> armlesshobo: that doesn't really make sense
14:02:40 <user99> Eduard_Munteanu, np here...4 cores should get it done fairly quickly though I only have 2GB tmpfs
14:02:55 <byorgey> armlesshobo: we just use the word 'action
14:02:58 <user99> might need to set notmpfs?
14:03:01 <kitbuilder> tac-tics_: I haven't looked through them extensively, but am looking for specific links / tutorials that mention that stuff
14:03:07 <byorgey> er, we just use the word 'action' to talk about values of type IO
14:03:22 <Eduard_Munteanu> user99: grapefruit the toolkit? That's a research FRP GUI toolkit, probably not a good idea if you're just starting
14:03:27 <byorgey> armlesshobo: of type   IO a  for some a, I mean
14:03:29 <tac-tics_> kitbuilder: http://book.realworldhaskell.org/read/extended-example-web-client-programming.html
14:03:35 <tac-tics_> Is that close to what you want?
14:03:46 <kitbuilder> tac-tics_: let me check
14:03:57 <user99> Eduard_Munteanu, gathered as much...just looking ahead to see what can be done. and it looks interesting
14:03:59 <user99> thx
14:04:03 <Eduard_Munteanu> user99: and yeah, you can cabal-install stuff that's not available in Portage.
14:04:10 <user99> k
14:04:10 <Eduard_Munteanu> Try Gtk2Hs instead for a GUI toolkit.
14:04:20 <Eduard_Munteanu> There's also a Haskell overlay, mind.
14:04:24 <user99> tyvm sir
14:05:02 <kitbuilder> tac-tics_: eh, not exactly what I'm working on, but it's a helpful link indeed :)
14:05:27 <tac-tics_> kitbuilder: perhaps http://book.realworldhaskell.org/read/sockets-and-syslog.html
14:05:48 <user99> not as clasy as younders utube...but still entertaining. I like this one...http://www.youtube.com/watch?v=XBOQcQO0IFI
14:05:53 <kitbuilder> tac-tics_: ahh, much better :)
14:07:11 * hackagebot kan-extensions 2.6 - Kan extensions, the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-2.6 (EdwardKmett)
14:09:28 <hpaste> RylandAlmanza pasted ‚ÄúThanks, Veinor, I think I'm close‚Äù at http://hpaste.org/68920
14:16:02 <uniquenick> anyone know of any good tutorials or examples on using attoparsec?
14:16:18 <hpc> uniquenick: look for parsec stuff; the API is the same
14:16:37 <Gracenotes> so. sometimes I effectively implement an unwrapped state monad in other languages and think "what am I doing" :|
14:16:39 <younder> the beauty of Vivaldi never sises to amaze me!
14:17:16 <user99> younder, you might enjoy the Animusic "Resonant Chanber" since you like strings
14:17:31 <uniquenick> hpc: that's what I tried, but the RWH parsec chapter uses stuff that isn't in attoparsec
14:17:32 <ski> (younder : s/sises/ceases/)
14:17:39 <hpc> Gracenotes: at work, all the perl is effectively ReaderT (IORef Form) IO
14:18:04 <younder> quite right ski
14:18:45 <younder> http://www.youtube.com/watch?v=8x4GC0-Z0ZI
14:19:15 <younder> Such a wonderful work..
14:22:45 <younder> user99:  I do
14:26:32 <joelr> is anyone using parsimony over parsec?
14:27:14 <younder> user99:  That was amazing!
14:27:58 <armlesshobo> what do you all use Haskell for? (out of curiosity)
14:28:21 <user99> younder, You would also like Acoustic Curves I think
14:28:28 <younder> I am writing a formula compiler
14:28:45 <hpc> i wrote my website in haskell + hdbc
14:29:12 <hpc> for a while my irc bot transformed over my website monad to get access to the database
14:29:23 <hpc> now it's self-modifying perl... :P
14:29:40 <younder> Haskell is just a great language. write whatever you want in it
14:32:49 <younder> ?? Noone likes haskell
14:32:50 <lambdabot>  Noone likes haskell
14:33:23 <younder> well I for one love it
14:33:50 <armlesshobo> @quote love
14:33:50 <lambdabot> vincenz says: Binkley: the sex is all in the operational semantics, denotational semantics only deals with love
14:34:10 <younder> lol
14:34:23 <armlesshobo> right on
14:34:23 <armlesshobo> lol
14:35:18 <jfischoff> @quote hate
14:35:19 <lambdabot> PaulGraham says: An algorithm for lazy evaluation of research papers: Just write whatever you want and don't cite any previous work, and indignant readers will send you references to all the papers
14:35:19 <lambdabot> you should have cited.
14:36:12 <monochrom> that is just lazy evaluation for one section
14:36:36 <younder> I recognise him from comp.lang.lisp
14:37:37 <andares> hey, if I have newtype State s a = State { state :: (s -> (s,a)) }, is there a way I can pattern match (s -> (s,a))?
14:37:48 <andares> (in a function that takes State s a)
14:38:00 <younder> yes
14:39:08 <andares> so if I have a function f t :: State s a -> State s a or something, can I just treat t like it's t :: (s -> (s,a))?
14:41:03 <Saizan> andares: check the type of state
14:41:32 <andares> I know I can do it via calling state, but I was hoping I could do it in the function header itself.
14:41:42 <Peaker> andares, nitpick:  state :: s -> (s, a)  (the parens not needed)
14:41:59 <andares> right, oops
14:42:09 <Peaker> andares, f :: State s a -> ???   ;  f (State x) = ???
14:42:41 <andares> ?
14:43:06 <Saizan> you can pattern match on the State constructor
14:43:18 <Saizan> to get at the function wrapped in
14:43:35 <Saizan> and you do so by writing code like f (State x) = ..
14:47:58 <user99> Eduard_Munteanu, I see now why you suggested the 'binary', nevertheless I am on vacation and time/deadlines are not a real issue ;-P
14:48:28 <Eduard_Munteanu> Hah :)
14:48:34 <andares> Saizan: I don't know what the state constructor looks like though.
14:48:51 <andares> well, in theory I do but in practice I don't know record syntax well enough.
14:51:03 <Peaker> andares, data State s a = State (s -> (s, a))      -- the latter "State" is the data constructor, and it has one arg, so you pattern match on it via:  f (State x) = ...
14:51:17 <Peaker> andares, when you wrap the field in a record as you did, it is still usable positionally, as though there was no record
14:51:27 <andares> ah, okay.
14:51:53 <Peaker> you can also pattern-match the field with record syntax:   f (State { state = x }) = ...
14:52:10 <Peaker> this is the weirdest corner of Haskell syntax, because the = sign in the pattern matcher actually defines its RHS!
14:52:57 <ski> it's not really weirder than `f (Foo x) = ...' "defining" `x'
14:52:59 <Gracenotes> hm, yeah. If I say that the empty set and the original set is a partition of the original set, I'm not going to get very far with my structural recursion.
14:53:27 <edwardk> ‚Ä¶ you probably want a newtype
14:53:40 <ski> Peaker : `f (let a*a = b in a) = ..b..' would be more fun
14:54:25 <RylandAlmanza> Veinor: Did you reply to my last hpaste? I just had some internet troubles
14:56:23 <Peaker> (so the above defines "x" to be the "state" field of the argument)
14:56:37 <Veinor> RylandAlmanza: sorry, i can't help right now i kind of became really busy :/
14:56:39 <Veinor> maybe someone else?
14:57:16 <RylandAlmanza> No problem, Veinor. Go back to work! :)
14:59:20 <d-snp>  Couldn't match expected type `Integer' with actual type `Int'
14:59:21 <d-snp> :(
14:59:31 <ion> fromIntegral
15:00:14 <d-snp> yeah.. but there's so many fromIntegrals in my code
15:00:41 <Gracenotes> where do the Ints come from mainly? list functions?
15:00:44 <monochrom> add more. or rewrite completely
15:01:25 <Gracenotes> or is it just inconsistency
15:01:26 <andares> I'm trying to define <*> for newtype State s a = State { state :: (s -> (s,a)) }, and I have f <*> (State g) = (\(_,a) -> f a) . g but that isn't working.
15:01:39 <andares> could anyone put me back on the right track?
15:02:47 <tgeeky_> andares: is that even possible?
15:02:50 <andares> the error I get is that it can't match actual type 'a0 -> c0' with 'State s b' expected.
15:02:52 <andares> ?
15:03:10 <tgeeky_> andares: <*> is from Applicative
15:03:16 <tgeeky_> which is weaker than a monad, which is what State is?
15:03:24 <edwardk> State mf <*> State ma = State (\s -> case mf s of (f,s') -> case ma s of (a, s'') -> (f a, s''))
15:03:29 <tgeeky_> evidently not
15:03:35 <edwardk> or something like that
15:04:00 <edwardk> er case ma s'
15:04:10 <andares> edwardk: ach, actually I'm trying to define (>>=), sorry.
15:04:26 <andares> I'm doing this practice problem from that list of 20 intermediate haskell problems.
15:04:33 <andares> so it's called banana and not terribly usefully named.
15:05:23 <edwardk> State ma >>= f = State (\s -> case ma s of (a, s') -> do something with runState (f a) s' }
15:05:34 <andares> runState?
15:05:51 <edwardk> newtype State s a = State { runState :: s -> (a, s) }
15:05:58 <edwardk> runState :: State s a -> s -> (a, s)
15:06:07 <tgeeky_> andares: you've called it "state"
15:06:09 <andares> ah
15:06:10 <edwardk> runState (State s) = s
15:09:30 <user99> Eduard_Munteanu, "configure: WARNING: unrecognized options: --with-compiler, --with-gcc"  ;-0 I don't see those set in the ebuild so guessing Makefile tried to set them.
15:09:32 <andares> hm, the case thing is kind of boggling me.
15:11:55 <andares> like why isn't it cas ma of (a, s') rather than case ma s?
15:11:58 <d-snp> :S ByteString.Lazy has no sendTo :S
15:12:21 <andares> ohhhh, I get it. it's an "action", s is its argument.
15:14:02 <Nisani> how do i make a custom show for a type in record syntax?
15:14:04 <rwbarton> d-snp: how about using sendManyTo and fromChunks
15:14:08 <Peaker> andares, "ma" is the field of the "State" constructor, so its type is (s -> (s, a))
15:14:23 <Peaker> Nisani, you mean the type was defined with record syntax?
15:14:30 <Nisani> yes
15:14:36 <Nisani> if i use deriving show it uses it
15:14:47 <Nisani> its own definitoin
15:14:49 <d-snp> oh that's great rwbarton, hadn't found that one yet
15:15:04 <andares> so I have banana f g = State (\t -> case g t of (s', a) -> (state (f a)) t), but it doesn't like g
15:15:11 <Sagi> oh hi d-snp :-)
15:15:42 <rwbarton> though this may not really be what you want, since i expect sendManyTo will want to demand the entire list of ByteStrings which will force your whole lazy ByteString into memory, which makes me wonder why you have a lazy ByteString at all
15:15:56 <Peaker> andares, that function doesn't seem to make sense
15:16:08 <Peaker> andares, s' is discarded, and you give the original 't' state
15:16:22 <Eduard_Munteanu> user99: hm, might be harmless, dunno
15:16:24 <Peaker> andares, also:  (state (f a)) t == state (f a) t
15:16:40 <Peaker> andares, also, "g" is probably wrapped in a State constructor too?
15:16:46 <Peaker> andares, so:  banana f (State g) = ... ?
15:16:49 <andares> oh god so many things wrong with it..
15:17:07 <Nisani> anyone?
15:17:26 <andares> Peaker: it is indeed wrapped in a State constructor. I could unwrap it.
15:17:27 <Peaker> Nisani, instance Show YourType where show (YourType fields) = ...
15:17:48 <Peaker> Nisani, IOW, same as Show for any other type
15:18:14 <andares>   banana f (State g) = State (\t -> case g t of (s', a) -> state (f a) s')
15:18:17 <andares> I think this is more sensible.
15:18:43 <andares> I'm kind of confused why I have to use the data constructor though, since f should be of type a -> State s b.
15:19:13 <c_wraith> andares: the data constructor needs to wrap the entire function, not just the result of it
15:19:13 <d-snp> hey Sagi :D
15:19:48 <c_wraith> andares: because the State constructor wraps a function, not a value
15:20:15 <edwardk> andares: you need to take the State s b apart at that point and get an (b,s) out of it
15:20:33 <edwardk> so you need to 'open' the resulting state action, and apply it to your modified state s'
15:20:34 <shachaf> "out of it" by applying the function.
15:20:48 <monochrom> andares: do you already know everything about "newtype"?
15:20:59 <d-snp> it compiles, and pushed to github, goodnight:)
15:21:51 <andares> monochrom: not everything, I don't think, but I was under the impression that it can be used to create a new type with one constructor, in such a way that things are internally the underlying type from which it's constructed.
15:21:54 <edwardk> andares: the problem is if you just try to use banana f (State g) = f ‚Ä¶ you don't have a state to use to get an a to apply f to in the first place
15:22:46 <edwardk> thats what makes you make a State action, so you can see the starting state, apply it to your initial state action, leaving the modified state and the 'a' so you can continue
15:23:20 <andares> I can't use g to get an a though, edwardk?
15:23:25 <monochrom> the impression is right, but it doesn't help you write actual code.
15:24:16 <monochrom> namely, it doesn't tell you when and why you have to pattern-match against that constructor, and when and why you have to tag on that constructor
15:24:52 <andares> I know why I have to pattern-match against that constructor: because newtype functions syntactically like data, no?
15:24:53 <edwardk> andares: if you can feed it a starting s, yes
15:25:09 <andares> edwardk: ohh, I see what you mean, although I'm still a little fuzzy on it.
15:25:26 <andares> so you create a \s -> ‚Ä¶ so that you can feed it a starting s?
15:25:31 <edwardk> andares: yep
15:26:18 <edwardk> banana f (State g) = State (\s -> case g s of (a, s') -> state (f a) s')
15:27:02 <armlesshobo> any idea what library allows me to move a file to another directory?
15:27:26 <armlesshobo> copyFile ok?
15:27:29 <andares> edwardk: pretty much exactly what I have.
15:29:55 <andares> huh. I'm done.
15:30:09 <andares> I don't know what to do now.
15:32:56 <shapr> andares: What did you finish?
15:33:08 <andares> the 20 intermediate Haskell problems.
15:33:23 <shapr> Are there advanced problems?
15:33:29 <armlesshobo> lol
15:33:52 <armlesshobo> your certificate will arrive in 3-5 business days
15:35:45 <shapr> I really like the new features in the latest version of haskell-mode
15:40:47 <andares> I'm just not sure what I should do with this language :p
15:42:10 <Peaker> andares, what do you do with other languages? :)
15:42:14 <monochrom> if you are in school and in programming classes, use this language for them henceforth
15:42:54 <acowley> shapr: What's new? I've been pretty jazzed this week because I decided to try ghc-mod again and it's working very nicely.
15:42:57 <andares> sadly I just graduated. didn't get do use anything functional besides lisp in a parser I wrote.
15:43:11 <andares> I haven't done anything with other languages either :p I'm out of ideas.
15:43:16 <andares> need a good summer project.
15:44:18 <monochrom> re-do all past coursework with this language
15:44:21 <shapr> acowley: If you've not used Chris Done's new changes, there's lots of good stuff.
15:45:01 <shapr> acowley: typing "import " gives you intelligent module autocompletion, though I've not tested that thoroughly.
15:45:22 <shapr> As in, I don't know if it's smart enough to dig through my .cabal file to find possible modules to import.
15:45:26 <acowley> Ah, I watched some of his demo video but it seemed a bit to heavy handed with cabal integration
15:45:32 <monochrom> pun: chris done is not done :)
15:46:05 <acowley> I really do like how he's pushing it. I should try it out some time.
15:46:05 <shapr> The haskell process buffer is much more polite. Long errors are ellipsed (?) after the first line, and tab shows you all of it.
15:46:10 <shapr> acowley: It's worth it!
15:46:22 <acowley> Yes, his pretty printing stuff looked great.
15:46:33 <shapr> It now automatically builds and uses TAGS
15:46:43 <acowley> I'll bask in the ghc-mod glow a bit longer before changing things up again, though
15:46:45 <monochrom> on a more serious note, I don't actually like "just git-pull" or "just darcs-pull". I want official releases
15:47:25 <shapr> acowley: the inferior haskell process can be either ghci or cabal-dev
15:47:33 <acowley> yeah, it's frustrating when you're trying to work with what turns out to be a janky version just due to bad luck with when you pulled
15:47:39 <shapr> Meaning you can work with hackages you don't yet have installed
15:47:42 <acowley> I'm still torn on cabal-dev
15:48:06 <acowley> I love that it generally just works, but it was a lot of work to deal with
15:49:06 <acowley> I have so many of my own packages that I work with, updating one felt like launching a cascade of minor frustrations
15:49:24 <shapr> Why so?
15:51:47 <acowley> When you rely on a single cabal database, updating one library finds its way into your downstream code pretty much on its own. With cabal-dev, I had to pay closer attention to make sure dependent local packages were in sync due to the reliance on sdist copying.
15:51:48 <shapr> I remember being so dazzled by auto-insert-mode the first time I saw someone using emacs. My emacs powers are so far beyond that!
15:52:04 * shapr feels the power ... until the next type error..
15:52:28 <acowley> The amount of recompiling involved was also a bit of a downer.
15:53:59 <acowley> None of those things are major, but they were friction. I've been tempting the ~/.cabal fates for the past few months and haven't had the rug pulled out from under me by cabal-install yet. It will probably happen again, and I'll rush back to cabal-dev's embrace.
15:55:54 <Saizan> the newer cabal-install is less happy to do dangerous stuff, i'm told
15:56:12 <acowley> indeed it is
15:57:02 <acowley> There was a certain insane charm to the way it used to innocently whistle while utterly destroying itself.
16:02:05 <palmfrond> in writing a document, is there anything wrong with not right-aligning roman numerals?
16:02:13 <palmfrond> it makes them too close to the text they denote
16:02:23 <palmfrond> i'd like to left align them
16:02:47 <palmfrond> this also has nothing to do with haskell, but haskell users are typically brighter
16:04:32 <monochrom> brighter doesn't imply more conforming to worldly conventions
16:04:33 <jfischoff> acowley: have you tried virtualenv? I ask because I just started using cabal-dev and wasn't sure which way to go
16:04:47 <byorgey> palmfrond: uh, can't you add more space following the right-aligned roman numerals?
16:05:39 <S11001001> palmfrond: otoh, haskell users are likely to left-align every last bit of everything
16:05:47 <byorgey> letting minor typesetting concerns dictate larger stylistic choicse seems Wrong (tm)
16:06:57 <acowley> jfischoff: I didn't try virtualenv as I tried cabal-dev first and it did indeed get me out of a versioning jam.
16:07:19 <jfischoff> good to hear
16:07:20 <acowley> byorgey: I think you should have superscripted and capitalized the ‚Ñ¢
16:07:49 <byorgey> I should have, but that would have taken about ten times as long
16:08:14 <acowley> byorgey: typographic infelicities are the downfall of modern society
16:08:20 <shapr> palmfrond: LaTeX? M-x align-regex?
16:08:49 <acowley> byorgey: also, my IRC client did the magic thing to ‚Ñ¢ automatically, which rather surprised me.
16:08:59 <byorgey> wow, fancy!
16:09:25 <acowley> Yes, but now I must live in constant fear that a #haskell regular takes the name ‚Ñ¢ and I can no longer address him or her without whispering upwards.
16:10:10 <byorgey> "‚Ñ¢ Erroneous Nickname"  <--- I tried it
16:10:44 <shapr> haha
16:10:47 <shapr> byorgey++
16:11:14 <Flink> This may be a biased place to ask this, but, well, I want to learn a programming language. I only have experience in css really. This close friend of mine who does all sorts of Haskelly things says I should learn Haskell, that it's worth it, etc - I'm sure it's a good language.
16:11:29 <Flink> But after a lot of work trying it, it's just really difficult with the syntax and all
16:11:35 <Flink> Should I just start with something like Python?
16:11:48 <achudnov> Flink, yes
16:11:49 <shapr> Flink: If you only know css, both Haskell and Python will be equally challenging.
16:12:05 <shapr> Flink: So I'd say it depends on your goal.
16:12:13 <shapr> Flink: If you want a commercial programming job, Python is a better starting point.
16:12:14 <Flink> I'm more focused towards web-based things
16:12:26 <achudnov> as in "Flink, don't start with Haskell"
16:12:32 <tromp_> python is much easier to grok
16:12:32 <shapr> Flink: If you want to be a wizardly programmer, I'd suggest starting with Haskell and then learning Python.
16:12:56 <achudnov> shapr, if only he doesn't kill himself in the process :-/
16:12:58 <Peaker> how do I use flymake with haskell-mode (which I presume includes ghc-mod inside it?)
16:13:02 <Flink> I don't want to be a software engineer as much as I'd like to make websites. And I know Haskell has fancy things like Happstack.
16:13:12 <Peaker> or are Haskell-mode and ghc-mode mutually-exclusive?
16:13:18 <Flink> Then again, I'm sure Python has web frameworks as well and it sounds like I may not stab myself after trying to learn it for a bit
16:13:19 <achudnov> Peaker, install ghc-mod and it should work out of the box
16:13:31 <achudnov> Peaker, there's a hook in haskell-mode to load ghc-mod with it
16:13:40 <achudnov> Peaker, look at the ghc-mod installation guide
16:13:47 <shapr> Flink: Python is certainly popular for web frameworks, I've gotten paid to build websites with several Python web frameworks.
16:13:49 <S11001001> Flink: you hit limits trying to make websites without being a software engineer
16:13:50 <acowley> Peaker: The way I understand it is that ghc-mod extends haskell-mode. But I don't know how it would interact with chris done's recent fanciness
16:14:07 <sipa> Flink: haskell and python use a very different way of approaching problems; i believe learning the imperative way first (what most regular programming languages use) first kinda hardwires your brain to think like that
16:14:18 <shapr> I agree with sipa.
16:14:33 <Flink> And I hear about how Haskell wires your brain in that other languages end up seeming cumbersome to use
16:14:37 <Peaker> haskell-mode comes with "haskell-mode_flymake.el" is that another variant of flymake support?
16:14:43 <Flink> because Haskell is concise and all. Hrmph.
16:14:54 <achudnov> Flink, so true :(
16:14:54 <shapr> Flink: Python was previously my favorite language, but after five or six years, I realized Python has limits that Haskell does not.
16:15:10 <hpc> i basically went from java to haskell
16:15:16 <shapr> hpc: How was that?
16:15:18 <hpc> and ended up learning to program all over again
16:15:30 <hpc> i literally cannot write java anymore
16:15:47 <hpc> it no longer makes sense in my head
16:16:05 <Flink> And S11001001: I see what you mean...I suppose what I meant is that I'd be using some language more for web development than software development
16:16:10 * stepcut has never used Python but is an expert Haskell programmer.. try to convince me to switch ...
16:16:20 <Peaker> I don't think languages don't make sense anymore. They just feel so weak and wrong :)
16:16:23 <shapr> Before Python, Java was my favorite language... but nowadays I strongly dislike writing Java.
16:16:41 <Eduard_Munteanu> Heh. I still write C reasonably, though yeah, I sometimes wish to take shortcuts.
16:16:53 <Peaker> when using other languages, all I can see is boolean blindness
16:16:58 <shapr> Flink: When you have trouble learning Haskell, do you ask here on #haskell?
16:17:00 <Gurragchaa> Lisp is pretty easy to get into if you want to explore functional programming
16:17:14 <Peaker> Gurragchaa, Not sure why Lisp is considered "Functional"
16:17:22 <Flink> Not particularly
16:17:50 <achudnov> Peaker, because lisp *is* functional?
16:17:52 <Eduard_Munteanu> @quote kmc.*functional
16:17:52 <hpc> Peaker: because it has macros ;)
16:17:53 <lambdabot> No quotes match. Sorry.
16:17:53 <Flink> I usually just curl up in my chair and stare at whatever I'm attempting
16:18:03 <ski> Gurragchaa : Scheme is nice
16:18:06 <hpc> also because to a certain extent, it is functional
16:18:12 <shapr> Flink: We like to be helpful here on #haskell, ask us next time you get stuck!
16:18:21 <Flink> Okay shapr, I will do that :)
16:18:23 <ski> (Scheme is a Lisp?
16:18:27 <ski> s/?/)/
16:18:29 <shapr> Flink: But why not try learning Python as well to see if you're missing out?
16:18:31 <hpc> scheme is indeed lisp
16:18:46 <hpc> scheme is almost a lisp-like ML, even
16:18:48 <nexion> is there a Map that allows duplicates (by storing the values in a list) and automatically cleans up the key when the last value for that key is removed?
16:18:56 <Flink> Shapr, I did start learning Python in a class at school. Though i didn't really get far because I was just teaching myself since my computer teacher doesn't know about computers
16:19:11 <Flink> That was a while ago though. It was okay, but I never got to the point of making anything besides a horribly convoluted text adventure game.
16:19:19 <shapr> Hey that's something.
16:19:32 <jfischoff> yeah I still haven't gotten to that point
16:19:33 <shapr> Have you considered making a text adventure game in Haskell?
16:19:41 <Flink> Yes
16:19:48 <Flink> If I could get to that point in Haskelling I'd be more motivated
16:19:51 * ski remembers text adventure games written with `goto'
16:19:54 <Flink> But
16:20:01 <Flink> I feel like it would involve monads for i/o, wouldn't it?
16:20:15 <Peaker> achudnov, in what sense is lisp "functional"?
16:20:24 <Peaker> hpc, joking, I presume :)
16:20:34 <shapr> Flink: I think you might be able to use interact
16:20:37 <shapr> :t interact
16:20:37 <lambdabot> (String -> String) -> IO ()
16:20:38 <achudnov> Peaker, in the sense that it has first-class functions
16:20:48 <Peaker> achudnov, Ah, so why not Python?
16:20:54 <achudnov> Peaker, i.e. being able to pass functions as arguments and shit
16:21:03 <Flink> I see
16:21:17 <achudnov> s/i.e./e.g./
16:21:21 <shapr> Flink: Are you going through one of the free online Haskell books to teach yourself?
16:21:28 <hpc> achudnov: most lisps aren't much for the "and shit" part though :P
16:21:34 <S11001001> Flink: and really to be fair you can't come to #haskell and ask what language to use without weird sampling issues
16:21:41 <Peaker> achudnov, Why is Lisp mentioned in that context -- so many languages can pass functions as arguments and shit
16:21:43 <achudnov> hpc, well I hate lisps for other reasons
16:21:49 <shapr> S11001001: true that :-)
16:21:51 <Flink> S11001001: I knew it'd be biased :P
16:21:52 <achudnov> Peaker, true
16:21:59 <Flink> I think I secretly want to learn Haskell because it seems like a cool language
16:21:59 <achudnov> Peaker, JavaScript can
16:22:13 <Flink> that sets you apart from just learning something like Java in school or something.
16:22:22 <achudnov> the question seemed to be as of why lisp is considered functional, no?
16:22:23 <Peaker> achudnov, and Ruby, and C#
16:22:33 <parcs`> Flink: so you want to stand out from your peers? ;)
16:22:41 <Flink> Shapr: Yeah, I read through a few chapters (up to types I think) in Learn You a Haskell. And just tonight I went through Try Haskell to refresh myself
16:22:43 <Peaker> achudnov, Ruby, Python, Javascript, C# are all not considered functional, whereas Lisp is, and it isn't any more "functional" than them
16:22:46 <jfischoff> I think the cool kids use Agda now
16:22:49 * achudnov remembers the abomination of C# 3.0 (?)
16:23:00 <Flink> Yes. Although only one of my peers, the one who knows Haskell, actually does programming
16:23:09 <achudnov> Peaker, they are considered multiparadigm
16:23:13 <hpc> jfischoff: they do, but secretly continue to use haskell when they need to execute their code
16:23:16 <Eduard_Munteanu> nexion: sounds pretty easy to make one.
16:23:18 <Peaker> achudnov, Lisp is the same as them
16:23:28 <ski> Peaker : which lisp ?
16:23:35 <shapr> achudnov: I actually enjoyed C# 3.0, it had lambdas and LINQ and ended up being pretty sexy.
16:23:38 * achudnov chooses Coq over Agda anytime, jfishcoff
16:23:39 <Peaker> ski, CL is the most common one, I suppose
16:23:42 <shapr> Or was that .net 3.0? I forget
16:23:52 <jfischoff> hpc: no doubt
16:23:55 <Peaker> how can I make the flymake integration check more than syntax?
16:23:58 <achudnov> Peaker, whatever makes you happy
16:23:58 <shapr> Flink: So, what is causing you difficulty?
16:24:17 <shapr> Flink: Is there anything specific we could do to assist you?
16:24:30 <achudnov> Peaker, ghc-mod checks types I believe
16:24:39 <nexion> Eduard_Munteanu, yep.. but worth asking in case one exists :)
16:24:59 <achudnov> Peaker, in fact I'm using it right now and it positively gives me lots of type errors
16:25:04 <Flink> Shapr: It's the state where I know what map does, but I'd need to consult an example to get the syntax right, and then I wouldn't really what to use it for.
16:25:06 <Peaker> achudnov, It shows me flymake errors on my parse errors, but apparently not on missing names
16:25:18 <Flink> I know I'm not going to learn Haskell and make a social networking site for cats the next day
16:25:23 <Flink> but getting past that block is tough
16:25:35 <achudnov> it will show parse errors first
16:25:40 <shapr> Flink: Funny, that's actually a startup I want to implement :-P
16:25:51 <Flink> Shapr: I would register my cat on that
16:25:53 <achudnov> Peaker, it can't show name resolution and type errors if it can't even parse the program
16:26:03 <Peaker> oh in fact, somehow flymake is only showing parse errors and only in the import section (?)
16:26:19 <achudnov> Peaker, code snippet, pl0x?
16:26:35 <shapr> Flink: I don't have cats at the moment, but if I did, I would too.
16:26:57 <shapr> I seriously want to make a social network website for cats.
16:27:08 <hpaste> Peaker pasted ‚ÄúMy code‚Äù at http://hpaste.org/68921
16:27:41 <Flink> My cat's statuses / interests would just be catnip and food, sadly
16:27:44 <shapr> Ya know, video and audio recognition of your cat should then play any recently recorded snippets of your cats internet friends...
16:27:54 <shapr> Flink: I was thinking of automating it.
16:28:00 <Flink> Ooooo
16:28:12 <Peaker> achudnov, oh I know
16:28:35 <Peaker> achudnov, ghc only looks at the import section when deciding what needs to be built, so probably flymake is not checking my file in whole
16:28:43 <Peaker> (but only reads the imports indirectly)
16:28:55 <Peaker> so that means flymake is running the wrong command
16:28:56 <shapr> Flink: No idea if it would work or not, but it would be fun to try!
16:29:59 <achudnov> Peaker, ghc-mod will check the current buffer
16:30:06 <achudnov> no matter if it gets imported or no
16:30:36 <achudnov> Peaker, so which line is it complaining at?
16:30:57 <Peaker> achudnov, it only complains if I mess up imporst
16:31:00 <Peaker> otherwise no complaints
16:31:03 <achudnov> ah
16:31:09 <achudnov> then it's fine
16:31:11 <Peaker> and every time it forgets my project :(
16:31:22 <achudnov> Peaker, imho, nothing to complain about there :)
16:31:25 <Peaker> and then when it starts a project it gives my focus to the ghci prompt buffer
16:31:30 <achudnov> Peaker, do you have a .cabal file?
16:31:34 <Peaker> achudnov, yeah
16:31:44 <Peaker> this feels very quirky so far
16:32:06 <palmfrond> would it be appropriate to say: "thank you for the product. please deliver me also the assets developed in course"
16:32:11 <palmfrond> the use of course is what i wonder here
16:32:23 <palmfrond> i mean that, things developed in the proces of building product, i'd like those
16:32:35 <achudnov> ghc-mod just looks for the .cabal file and goes from there... so if it isn't complaining about imports, it should be fine...
16:32:36 <shapr> palmfrond: This is probably better asked on #haskell-blah
16:32:56 <int80_h> http://stackoverflow.com/questions/10729291/lifting-trouble-with-resourcet
16:33:22 <achudnov> Peaker, now that I think of it, I've never had to deal with "projects" in either haskell-mode or ghc-mod...
16:33:29 <Peaker> achudnov, what do you mean? I jam the keyboard anywhere other than imports and flymake ignores it
16:33:43 <Flink> shapr: I would definitely try out that. My cat could use some social networking. I think it'd be better than just lying on the floor all day
16:33:55 <Peaker> achudnov, it doesn't ask you if you want to make a project?
16:34:00 <Peaker> (every time you start emacs?)
16:34:00 <achudnov> Peaker, it compiles on timer and when you save
16:34:06 <achudnov> Pealer, no
16:34:13 <achudnov> s/Pealer/Peaker
16:34:13 <Peaker> achudnov, even when I save -- it only complains about problems in imporst
16:34:26 <Peaker> maybe I should get a "Stable" version of haskell-mode and not from github
16:34:42 <shapr> oh you're using chris done's haskell-mode version
16:34:50 <achudnov> Peaker, no, I have like 2.8.0
16:35:01 <achudnov> the latest release version
16:35:09 <shapr> Peaker: Try M-x customize-mode and set the process type to ghci
16:35:10 <achudnov> got it from ELPA, I think
16:35:26 <Peaker> oh I have haskell-mode debian package too
16:36:56 <Peaker> shapr, that's the "project" stuff? "cabal-dev" selection?
16:36:59 <achudnov> Peaker, I've had problems with ghc-mod not checking files at all. Usually 'cabal clean' and removing the cabal-dev directory helps.
16:37:03 <Peaker> I like cabal-dev, why can't it remember my project?
16:38:00 <shapr> Peaker: the ghci setting is easier to satisfy
16:38:27 <shapr> Peaker: I changed my haskell-mode init settings to match those that are included with haskell-mode
16:38:32 <shapr> That makes things easier.
16:39:03 <int80_h> Is it bad form to post stackoverflow questions here?
16:39:26 <Peaker> shapr, changed it, flymake still doesn't work
16:39:29 <Pseudonym> It depends on the question and how helpful stackoverflow was.
16:39:34 <Peaker> damn, nothing seems to be working :(
16:39:36 <Pseudonym> A link would probably make more sense.
16:39:43 <shapr> Peaker: I don't know about flymake working with chrisdone's haskell-mode
16:39:55 <achudnov> Peaker, did you try 'ghc-mod check <file.hs>' from command line?
16:39:58 <shapr> int80_h: If it's a Haskell question, it's not bad form to ask the question here.
16:40:02 <achudnov> just to make sure it works
16:40:19 <Pseudonym> Besides, how are we going to know it was asked there?
16:40:23 <shapr> Peaker: If you want flymake, it might be better to switch back to an older version of haskell-mode
16:40:23 <int80_h> okay I'll put it up on hpaste
16:40:39 <int80_h> well I pasted the SO url not long ago
16:40:50 <int80_h> but hold on I wil put it in hpaste
16:41:20 <Veinor> int80_h: what version of conduit are you using?
16:42:23 <Peaker> ok, I removed haskell-mode/ghc-mod and installed the debian packages of those, and now it works!
16:42:50 <int80_h>  Veino : I believe it's 0.4.2. GHC would use the most recent right?
16:43:06 <Veinor> int80_h: cabal-dev ghc-pkg check conduit
16:43:10 <shapr> Is there an easy way to have all the haddocks for my hackages available locally?
16:43:26 <Veinor> er, list conduit not check conduit
16:44:12 <Peaker> shapr, enable ~/.cabal/config/  documentation: True
16:44:15 <absence> mm_freak: is this starting to look sensible? http://hpaste.org/68923
16:44:16 <shapr> thanks
16:44:48 <int80_h>  Veinor: installing cabal-dev
16:45:04 <Veinor> int80_h: well, if you don't have cabal-dev installed then just ghc-pkg list conduit
16:45:11 <mm_freak> absence: left <- (specialKeyHeld (-1) U.KeyLeft -< ())  <|> (constant 0 -< ())
16:45:29 <mm_freak> that's just:  left <- specialKeyHeld (-1) U.KeyLeft <|> constant 0 -< ()
16:45:34 <Peaker> I hate how stupid emacs TAGS are..
16:45:42 <Peaker> (no regard for scope whatsoever)
16:45:56 <mm_freak> absence: it's becoming more reasonable, but try with less arrow style and more applicative style
16:46:10 <int80_h> conduit-0.4.1.1 is in red and conduit-0.4.2 is in black
16:46:10 <shapr> chrisdone's haskell-mode seems to handle TAGS politely and correctly
16:46:19 <mm_freak> that particular code will look much nicer in applicative style
16:46:28 <int80_h> Veinor: conduit-0.4.1.1 is in red and conduit-0.4.2 is in black
16:46:43 <Peaker> shapr, if you have multiple modules giving the same name, I think the TAGS file cannot cope with that in general, regardless of the nice wrappers around it chrisdone did
16:47:36 <absence> mm_freak: that looks so much nicer :D thanks. i'll try applicative style when i've gotten it right
16:49:03 * RTU slaps akosch with a big red brick
16:49:08 <absence> mm_freak: is it the right way to do things otherwise, with require and hold?
16:49:48 <Veinor> int80_h: that's odd, it compiles fine for me
16:51:06 <mm_freak> absence: as you're taking the sum of movements this seems reasonable
16:52:33 <absence> mm_freak: cool. i think you mentioned something about avoiding the use of () as input earlier, or do i confuse matters?
16:54:06 <hpaste> ‚ÄúErtugrul S√∂ylemez‚Äù annotated ‚Äúsadf‚Äù with ‚Äúsadf (applicative style)‚Äù at http://hpaste.org/68923#a68924
16:54:12 <mm_freak> absence: see the annotation
16:54:14 <mm_freak> applicative style =)
16:54:31 <mm_freak> in fact in the next version instead of "liftA2 (+) left right" you will be able to write:  left ^+^ right
16:54:34 <mm_freak> =)
16:55:16 <ski> preflex: xseen preflex
16:55:33 <absence> O_O
16:55:41 <absence> mm_freak: love it
16:56:21 <preflex>  what
16:56:26 <mm_freak> actually the next version will likely depend on base 4.5
16:56:28 <shapr> preflex: That's what I said.
16:56:33 <mm_freak> so i might even provide Num instances
16:56:38 <mm_freak> so you can write left + right =)
16:57:37 <absence> mm_freak: sounds very nice :)
16:58:40 <mm_freak> integral . (left + right)  where left = (-1) . keyLeft <|> 0;  right = 1 . keyRight <|> 0
16:58:56 <mm_freak> that's AFRP at its best =)
16:59:06 <mm_freak> s/integral/integral 0/
17:00:16 <absence> mm_freak: is keyLeft = require . hold (keyPressed (U.SpecialKey U.KeyLeft)) ?
17:00:33 <kallisti> > fix pred
17:00:34 <lambdabot>   *Exception: Prelude.Enum.().pred: bad argument
17:00:39 <mm_freak> absence: i'd implement keyPressed as an identity-like wire
17:01:43 <adamvh> Hey all.
17:02:06 <adamvh> What would you say is the current state of the art for Haskell / emacs integration?
17:02:09 <absence> mm_freak: using the low-level mk*** functions?
17:02:19 <mm_freak> adamvh: the haskell mode
17:02:36 <mm_freak> absence: if keyPressed is the lowest level interface, yes
17:02:54 <mm_freak> you can use arrM, if you like, but i'd prefer mkGenM
17:04:47 <shapr> adamvh: I'm fond of chrisdone's recent improvements to haskell-mode
17:05:48 <adamvh> shapr: Is there a public repo?
17:05:54 <adamvh> I've seen his blog posts
17:05:58 <adamvh> but no link ot a repo
17:06:03 <Veinor> http://github.com/haskell/haskell-mode
17:06:12 <shapr> adamvh: https://github.com/haskell/haskell-mode
17:06:27 <adamvh> Ah I see - the contributions are not separate from the main mode
17:06:29 <adamvh> thanks
17:06:30 <achudnov> shapr, could you link to the changelog, please?
17:06:58 * achudnov wants to see if he develops the same fondness
17:07:19 <absence> mm_freak: do you mean mkGen?
17:08:30 <mm_freak> absence: hmm‚Ä¶  apparently for some reason i didn't have mkGenM in that version
17:08:35 <mm_freak> well, mkGenM = WmGen
17:08:41 <mm_freak> in other words, just use the constructor
17:08:46 <mm_freak> it's better than mkGen
17:09:19 <mm_freak> and there is mkFixM for stateless wires
17:09:30 <isson> is there a commercial project using haskell? really? i am wondering about that.
17:10:13 <hpc> isson: facebook uses haskell to do automated refactoring of their horrid php code, if that counts
17:10:25 <andares> hpc: why'd they go with haskell?
17:10:28 <andares> also yuck php
17:10:29 <parcs`> google uses haskell here and there too
17:10:41 <isson> oh~
17:10:46 <andares> if only Microsoft would.
17:10:47 <parcs`> andares: automatic refactoring is all about AST manipulation, which pattern matching excels at
17:10:51 <achudnov> hps, proof link?
17:11:05 <andares> parcs`: ah, true.
17:11:20 <achudnov> s/hps/hpc/
17:11:37 <andares> why don't people use Haskell?
17:11:41 <andares> just hard to find good coders for?
17:12:00 <Clint> people don't?
17:12:07 <parcs`> lots of people use haskell, but businesses don't for many reasons
17:12:19 <parcs`> not involving the language directly
17:12:22 <hpc> achudnov: http://cufp.galois.com/2009/slides/PiroLetuchy.pdf
17:12:43 <hpc> @google stack overflow haskell in industry
17:12:45 <lambdabot> http://stackoverflow.com/questions/2284875/why-is-haskell-used-so-little-in-the-industry
17:12:45 <lambdabot> Title: functional programming - Why is Haskell used so little in the industry? - Stack  ...
17:13:21 <achudnov> hpc, oh I know about the use at Google; was just curious about FB
17:13:28 <hpc> achudnov: that was facebook
17:13:33 <achudnov> cheers for the link though
17:13:34 <mm_freak> andares: simon peyton jones, one of the key people in the haskell community, works for microsoft, and AFAIK is even being paid to work on haskell
17:13:37 <achudnov> ah, okay, thanks!
17:13:47 <andares> ooh really? I'll have to look him up.
17:14:06 <achudnov> mm_freak, doesn't Simon Marlow work there too?
17:14:06 <andares> I know the F# people are Haskell enthusiasts but I didn't know whether they all used F# or Haskell.
17:14:29 <hpaste> ronwalf pasted ‚ÄúAmbiguous occurrence‚Äù at http://hpaste.org/68925
17:14:33 * hpc expects most improvements to F# are prototyped in ghc first
17:14:43 <hpc> worst case scenario, it doesn't work
17:14:50 <hpc> best case, they do the work for you
17:15:23 <hpc> (er, "they" being other contributors)
17:15:25 <ronwalf> It's been too long since I've been coding!  Why the heck am I getting an ambiguous occurrence for that code (GHC 7.4.1)
17:15:26 <mm_freak> dunno
17:15:40 <andares> hpc: I don't think they mean to steal ghc, just that the only way they can use a functional language in their codebase is to use F#.
17:15:46 <parcs`> ronwalf: did you read the full error message?
17:15:50 <andares> since pretty much everyone in the company uses .NET languages these days.
17:16:06 <hpaste> ronwalf annotated ‚ÄúAmbiguous occurrence‚Äù with ‚ÄúAmbiguous occurrence (annotation)‚Äù at http://hpaste.org/68925#a68926
17:16:13 <monochrom> Prelude.mapM_ and Data.Vector.mapM_
17:16:25 <shachaf> ronwalf: It might be the "mapM_ primport Data.Vector as V"
17:16:26 <ronwalf> Yeah, but it's imported as qualified
17:16:29 <monochrom> and yes the error message says what I say
17:16:40 <parcs`> andares: no it's not
17:16:44 <ronwalf> as V?
17:16:50 <monochrom> I see no "qualified". do as string search
17:16:51 <shachaf> "import qualified" imports something qualified.
17:16:54 <ronwalf> crap
17:17:02 <ronwalf> How does that syntax pass, then?
17:17:10 <shachaf> It imports it unqualified as V.
17:17:29 <monochrom> the syntax passes as Haskell 2010
17:17:29 <hpc> how does line 3 pass parsing?
17:17:33 <ronwalf> I'm trying to think  of a use case for that
17:17:57 <hpc> monochrom: o.O how?
17:18:14 <monochrom> I just mean the line "import Data.Vector as V"
17:18:32 <tgeeky> everyone mapM_ primports these days
17:18:37 <hpc> monochrom: "mapM_ primport Data.Vector as V"
17:18:47 <monochrom> right, I don't know about that one
17:18:57 <tgeeky> hpc: it never gets to primort because it can't resolve which mapM_ to use
17:18:59 <tgeeky> i'd guess
17:19:01 <ronwalf> I would have expected a syntax error without the 'qualifed'
17:19:20 <shachaf> ronwalf: You should read about how "import" works, then. :-)
17:19:23 <Veinor> > let primport = undefined; mapM_ = undefined; as = undefined in mapM_ primport Data.Vector as V
17:19:24 <lambdabot>   Not in scope: data constructor `Data.Vector'Not in scope: data constructor ...
17:19:28 <ronwalf> It seems to import as bot qualified and unqualified ?
17:19:34 <Veinor> if Data.Vector and V were in scope it'd work!
17:19:52 <Veinor> wouldn't typecheck, but it'd work
17:20:05 <shachaf> It wouldn't parse either.
17:20:11 <nyingen> any Scala haters here?
17:20:12 <shachaf> Oh.
17:20:13 <shachaf> Maybe it would.
17:20:17 * shachaf sighs.
17:20:21 <monochrom> it turns out that "as" is not a keyword
17:20:30 <Veinor> yeah, as isn't a keyword
17:20:32 <tgeeky> it's just part of the import syntax
17:20:40 <monochrom> > let as x y = x||y in True `as` False
17:20:41 <lambdabot>   True
17:20:45 <ronwalf> So what /does/ that line do?
17:20:55 <parcs`> ronwalf: yes. actually, "import Foo.Bar" imports Foo.Bar qualified and unqualified too
17:20:55 <ronwalf> Import the 'as' module?
17:21:02 <shachaf> ronwalf: I recommend reading about the "import" syntax. :-)
17:21:02 <tgeeky> import (qualified?) Modulename as Mod
17:21:14 <shachaf> We can write out an explanation in here but it wouldn't be as good as one that you can find online.
17:21:19 <tgeeky> if you use qualified, then you'll get Mod.x, Mod.y, and Mod.z
17:21:32 <tgeeky> if you don't use qualified, then you'll get: x, y, z, and Mod.x, Mod.y, and Mod.z
17:21:35 <tgeeky> that's it
17:21:41 <parcs`> ronwalf: 'import qualified' means to import the module only qualified, just 'import' means to import it both qualified and unqualified, and 'as' changes teh qualifier
17:21:55 <tgeeky> ronwalf: http://www.haskell.org/haskellwiki/Import
17:21:58 <hhb_> Hi, I'm having a TChanIO problem. In this program I read about 700,000 Datagram packets from a socket. I get about 100% of packets. However, if I put a threadDelay(1000000 * 60) above forever inside the consumer, I watch the memory usage grow (good) and then after 60 seconds it quickly goes done. But I only have about 260000 items of output. Can you help? http://hpaste.org/68841
17:22:36 <monochrom> it's amusing or saddening that people show disbelief at Haskell syntax
17:23:02 <tgeeky> monochrom: perhaps it's quantum disbelief, and it's both
17:23:11 <jaxtr> :L-o
17:23:27 <ronwalf> Ok, I get it, but that's kinda terrible
17:23:39 <tgeeky> ronwalf: the joke or the syntax?
17:23:42 <ronwalf> Why would I want to import as both qualified and unqualified at the same time
17:23:43 <monochrom> you don't have to use it
17:23:47 <ronwalf> Syntax
17:24:05 <tgeeky> ronwalf: uhh. If you're writing a Prelude.
17:24:11 <tgeeky> ronwalf: if you're writing something to replace the Prelude
17:24:27 <ronwalf> tgeeky: Then use separate lines!
17:24:38 <monochrom> dude, you don't have to use it
17:24:39 <absence> mm_freak: http://hpaste.org/68927 <- it seems much more complicated
17:24:50 <ronwalf> monochrom: I just expected it to throw an error
17:24:58 <tgeeky> ronwalf: if you do: import Mod, then you get "x,y,z and Mod.x, Mod.y, and Mod.z"
17:25:13 <tgeeky> ronwalf: so this doesn't directly have to do with the "as" part
17:25:38 <ronwalf> Ok, now it makes sense
17:25:39 <monochrom> well, too bad for you then
17:25:48 <ronwalf> monochrom: ass
17:25:48 <tgeeky> monochrom: hehe
17:25:51 <hpaste> RM pasted ‚ÄúConcurrent Channels threadDelay‚Äù at http://hpaste.org/68928
17:25:58 <tgeeky> ronwalf: hehe. He is right, though. Just like House.
17:26:06 <mm_freak> absence: just use mkFixM
17:26:23 <otters> if module Foo imports qualified module Bar as B and exports module B, will any of the functions from Bar be in scope if Foo is imported somewhere else?
17:26:39 <tgeeky> otters: ouch. my head hurts
17:26:42 <Peaker> open unqualified imports are nice.. for throwaway shell scripts
17:26:47 <otters> sorry tgeeky
17:26:52 <otters> I tried to word it easy
17:26:55 <tgeeky> hehe.
17:26:59 <hpc> hhb_: above forever?
17:27:01 <parcs`> otters: you can't export a module qualified
17:27:03 <hpc> hhb_: so you have
17:27:04 <monochrom> for that case, see my http://www.vex.net/~trebla/haskell/module.xhtml
17:27:07 <otters> parcs`: that explains it
17:27:25 <hpc> consumer chan = do
17:27:27 <hpc>   delay
17:27:27 * hackagebot TTTAS 0.4.2 - Typed Transformations of Typed Abstract Syntax  http://hackage.haskell.org/package/TTTAS-0.4.2 (MarcosViera)
17:27:31 <hpc>   forever $ do ...
17:27:32 <hpc> ?
17:27:45 <hhb_> So, this version outputs about 99.99% of UDP packets: http://hpaste.org/68841 This version outputs only about 30%: http://hpaste.org/68928 Why would threadDelay cause any problem for the channel?
17:27:50 <tgeeky> otters: that would be a nice feature though (exporting qualified) -- because then you could write modules which just change the namespace
17:27:58 <parcs`> otters: everything will get exported unqualified, and ghc will ensure that there are no ambiguous occurrences in the export list
17:28:01 <tgeeky> otters: it sounds very hard to track
17:29:00 <hpc> hhb_: my guess would be timing and UDP crap
17:29:01 <otters> yeah
17:29:10 <otters> I'm trying to avoid import hell here, but I'm doing a very bad job of it
17:29:21 <otters> is it bad practice to export Prelude?
17:29:21 <hpc> hhb_: if you do it TCP, do you see 100% of lines?
17:29:25 <otters> with some functions hidden
17:29:33 <otters> do they stay hidden when you export the module?
17:29:41 <tgeeky> export Prelude?
17:29:48 <parcs`> yes, to the last question
17:29:53 <otters> okay
17:30:17 <monochrom> if I import your module, I can always import other stuff from Prelude myself. your hiding isn't real hiding
17:30:27 <otters> I'm trying to export Data.ByteString.Char8 because my whole library uses ByteStrings rather than Strings
17:30:34 <otters> but ByteString and Prelude have a bunch of name clashes
17:30:34 <tgeeky> otters: the logic is, hidden prevented them from coming into scope, so it won't be there to export
17:30:45 <otters> and if I import ByteString as qualified, then I can't export it
17:30:48 <hhb_> hpc: TCP would be nice, but the source is UDP so I am stuck with it. Can I assume that it has nothing to do with TChan, TVar and IO Monad? It is just an unbounded linked list right?
17:30:53 <otters> so my choices are
17:31:01 <otters> import Prelude, hide all the functions that clash with ByteString
17:31:01 <monochrom> you should really see my http://www.vex.net/~trebla/haskell/module.xhtml for every fine print and corner case of import and export
17:31:03 <Peaker> otters, use ByteString qualified
17:31:04 <tgeeky> otters: import Prelude hiding whatever; import ByteString; import ByteString qualified; done.
17:31:08 <otters> oh
17:31:25 <Peaker> tgeeky, I hate open unqualified imports like that
17:31:39 <hpc> hhb_: it's highly unlikely the problem is in STM
17:31:46 <tgeeky> Peaker: I didn't mean to mean that, I was just being terse
17:31:52 <hhb_> import Prelude hiding (putStrLn)
17:32:15 <hhb_> import Prelude as Pre (putStrLn)
17:32:31 <otters> if I hide everything in Prelude that conflicts with ByteString, it's going to be a long hide list
17:32:35 <tgeeky> Peaker: i meant to say: import Prelude hiding (some,things); import Data.ByteString.Lazy; import qualified Data.ByteString.Lazy as BSL
17:32:36 <hhb_> ER, import qualified Prelude as Pre (putStrLn)
17:32:54 <otters> ugh
17:32:58 <hpc> hhb_: try with plain old Chan, and i expect you will see similar levels of loss
17:33:10 <hhb_> otters: it is good to be needed :)
17:33:11 <Peaker> tgeeky, "import Data.ByteString.Lazy" is open unqualified, and should be disallowed IMO
17:33:43 <tgeeky> isn't that what many packages tell you to do?
17:33:44 <Peaker> tgeeky, any new name being exported from it may clash with any name defined in the importing module in the future.. and when you see a name it's hard to tell where it's coming from
17:34:00 <Peaker> If they do, they should be fixed to stop telling that :)
17:34:04 <monochrom> many packages tell you to "import qualified Me as M
17:34:31 <Peaker> I've already been bit by packaged being broken because they used open unqualified imports
17:35:02 <hhb_> hpc: by why the loss only in the version where I delay consumer for a minute? If I consume and produce from the start I get no loss. When I delay consuming I am doing less!
17:35:09 <tgeeky> lots of packages give you instructions to write 2 import lines
17:35:22 <tgeeky> i can't find any examples
17:35:41 <Clint> tgeeky: http://hackage.haskell.org/package/openpgp
17:35:42 <monochrom> is "open unqualified" redundant? or what do you mean by "open" and what do you mean by "unqualified"?
17:35:50 <Clint> er, not that one
17:37:03 <absence> mm_freak: will mkFixM be able to hold? i.e. holding down the left key causes a single key down event, but i want it to produce until i receive key up
17:37:06 <Peaker> monochrom, open is no () list of names
17:37:13 <Peaker> monochrom, unqualified is without "qualified" word
17:37:33 <Peaker> it is ok to do: import Foo (bar), or import qualified Foo, but horrible to do: import Foo
17:37:43 <tgeeky> Peaker: ah. I was incorrect
17:37:50 <tgeeky> the recommendation is to get the types and classes in unqualified
17:37:54 <tgeeky> and then bring everything else in qualified
17:38:01 <tgeeky> like: http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-IntMap.html
17:38:06 <mm_freak> absence: make a keyDown and keyUp as primitive, then make a keyPressed as a composite
17:38:11 <Peaker> In Python, the syntax is:   from Foo import bar, or import Foo, but horrible to do: from Foo import *
17:38:20 <Peaker> "from X import *" makes it clear why it is such a bad idea
17:38:39 <tgeeky> Peaker: hopefully all of this will go away when we have "modules 2.0"
17:38:39 <Peaker> and indeed such imports are shunned by the Python community.. this is one of the only things I wish Haskell copied from Python
17:38:51 <tgeeky> Peaker: shunning isn't strong enough
17:38:55 <Peaker> tgeeky, like in ML-esque languages?
17:39:14 <Peaker> they seem to like the "open Module;" which does something similar, iiuc
17:39:16 <tgeeky> Peaker: nope, I don't know anything about that
17:39:26 <otters> this is a clusterfuck
17:39:41 <tgeeky> otters: http://hackage.haskell.org/packages/archive/bytestring/0.9.2.1/doc/html/Data-ByteString-Lazy.html
17:40:01 <Peaker> it would be nicer if:  import Foo(..)   was used to get all the names   and import Foo   was just a qualified import
17:40:04 <tgeeky> otters: there is also a too; fix-imports I think
17:41:36 <XexonixXexillion> Is there anyway in parsec to set it so that if the parser fails, to just ignore that failed parse and continue to the next character?
17:42:37 <shachaf> And do what?
17:43:37 <XexonixXexillion> and to pretend that that character never existed
17:44:04 <monochrom> "try myparser <|> anyChar" answers your literal question but probably not your real question
17:47:46 <absence> mm_freak: i've made the identity/inhibit primitives (they both take a key parameter to specify which key to check the state for, right?) but i'm having trouble with the composite keyPressed
17:48:27 <XexonixXexillion> monochrom: If I do that, the parser has not failed. I want a way to handle parser fails
17:48:56 <mm_freak> absence: use your logic =)
17:49:10 <mm_freak> it's a bit tricky to figure it out
17:49:41 <mm_freak> absence: netwire's inhibition is really just logic‚Ä¶  think of conjunctions of negations
17:50:08 <structuralist> what does universality mean in "universality of fold"?
17:50:55 <structuralist> universal property?
17:51:28 <monochrom> univerality of list's foldr (for example) is this: if you have a function f that satisfies "f [] = c" and "f (x:xs) = op x (f xs)", then f = foldr op c
17:52:18 <monochrom> for another example, my http://www.vex.net/~trebla/haskell/scanl.xhtml uses univerality of scanl
17:52:43 <monochrom> or perhaps you may say "some version of universality of scanl"
17:53:15 <structuralist> so it doesn't mean that any function of a list can be expressed as a fold?
17:53:41 <monochrom> no
17:54:56 <structuralist> okay thanks
17:58:47 <absence> mm_freak: logic isn't my strong side unfortunately :) could you give me a hint: does this involve the hold function?
18:40:41 <tsanhwa> hi, I made a cabal package that uses HDBC-sqlite3 on Windows. when I cabal install it, I got an error from ld.exe: cannot find -lsqlite3. what's the matter?
18:41:43 <Saizan> tsanhwa: do you have the C sqlite3 lib installed?
18:43:00 <tsanhwa> Saizan: yes
18:43:25 <tsanhwa> Saizan: I also installed HDBC-sqlite3, which require sqlite3 lib
18:43:36 <tsanhwa> sqlite3.dll
18:44:00 <Saizan> i don't know then
18:44:21 <shashwat> Why <foldl (++) "" ["a", "b", "c"]> works while <foldl (++) "" ['a'..'c']> fails ?
18:44:23 <gienah> tsanhwa: cabal configure --verbose=3 might give some hints
18:44:34 <tsanhwa> Saizan: thanks
18:44:49 <tsanhwa> gienah: ok, let me try
18:45:10 <Saizan> shashwat: 'a' is a single Char, while "a" is a list of one Char
18:45:57 <shashwat> Saizan: which means ['a'..'c'] = a list of 3 chars.
18:46:22 <Saizan> shashwat: right, but foldl (++) "" expects a list of lists
18:46:49 <gienah> tsanhwa: this might give some hints (not sure if directly applicable or not, or could be out of date): http://blog.johantibell.com/2011/01/setting-up-haskell-development.html
18:47:59 <tsanhwa> gienah: ok. the error seems that sqlite3.dll is not placed where ld understand
18:49:19 <dmwit> The void package has 14 versions. O_o
18:49:27 <tsanhwa> gienah: it seem I have basically similar environment as the blog. I use mingw too
18:50:00 <shashwat> Saizan: So how can I convert something like ['a'..'c'] into ["a", "b", "c"] ?  Or am I trying to fix a wrong problem ?
18:50:20 <Saizan> shashwat: map (:[])
18:50:35 <gienah> tsanhwa: I'm not really sure how to fix it, some ideas are: 1) to make this work: pkg-config --libs sqlite3
18:50:52 <gienah> tsanhwa: should return something like: -lsqlite3
18:51:01 <Saizan> > foldl (++) "" (map (:[]) ['a','b','c'])
18:51:03 <lambdabot>   "abc"
18:51:35 <Saizan> @check \xs ->  foldl (++) "" (map (:[]) xs) == (xs :: String)
18:51:37 <lambdabot>   "OK, passed 500 tests."
18:52:02 <shashwat> Saizan: thanks.
18:52:03 <gienah> tsanhwa: 2) to use the cabal configure --extra-lib-dirs= and --extra-include-dirs= options
18:52:05 <Saizan> seems a very complicated way to write the (strict) identity function :)
18:52:14 <dmwit> > map return "abc"
18:52:15 <lambdabot>   No instance for (GHC.Show.Show (m GHC.Types.Char))
18:52:15 <lambdabot>    arising from a use of...
18:52:20 <dmwit> > map return "abc" :: [String]
18:52:21 <lambdabot>   ["a","b","c"]
18:52:28 <shashwat> Saizan: I was trying to solve http://www.reddit.com/r/dailyprogrammer/comments/u0tdt/5232012_challenge_56_easy/
18:52:37 <gienah> tsanhwa: 3) placing the sqlite3.dll somewhere in the PATH
18:52:51 <shashwat> Saizan: foldl (\x y -> concat[x, y, x]) "a" ["b", "c"]
18:53:31 <shashwat> Saizan: this was my working solution for a small case, had to extend until 'a'..'z'
18:54:44 <Ralith> odd that ghc gives a 'no instance' there rather than an ambiguity error
18:55:43 <Saizan> > foldr (\x y -> x ++ [y] ++ x) "a" "bc"
18:55:44 <lambdabot>   Occurs check: cannot construct the infinite type: b = [b]
18:55:56 <Saizan> > foldr (\y x -> x ++ [y] ++ x) "a" "bc"
18:55:58 <lambdabot>   "acabaca"
18:56:17 <Saizan> > foldl (\x y -> x ++ [y] ++ x) "a" "bc"
18:56:19 <lambdabot>   "abacaba"
18:56:54 <tsanhwa> gienah: thank you so much, I will try them
18:59:27 <saml> hey, is there crossplatform file modification watcher?
18:59:39 <saml> something like http://packages.python.org/watchdog/
18:59:53 <kallisti> Ralith: well, because there /could/ be an instance for Show (m Char)
19:00:02 <kallisti> but it didn't find one.
19:00:14 <kallisti> if the Show constraint wasn't required by lambdabot then it would be ambiguous.
19:00:49 <Ralith> o
19:01:26 <kallisti> > maxBound
19:01:27 <lambdabot>   ()
19:01:42 <kallisti> (more lambdabot weirdness)
19:01:57 <otters> > maxBound :: Int
19:01:58 <lambdabot>   9223372036854775807
19:02:07 <qtplatypus> saml: I only know of System.INotify but that isn't portable.
19:03:38 <saml> yah and fs-event seems to be orphanded
19:05:28 <Saizan> Ralith: GHC is not really consistent on when it throws an ambiguity error, for example it seems it's impossible to trigger one if a multiparam typeclass is involved
19:07:52 <otters> you can't have IO exception handlers in non-IO monads, can you?
19:08:10 <kallisti> you can have them in monad transformers over IO
19:08:21 <otters> well that's what confuses me
19:08:26 <kallisti> but not via Control.Exception, you either have to write your own code, or use another library.
19:08:35 <otters> like what?
19:08:39 <kallisti> lifted-base is an example, and MonadCatchIO
19:08:47 <kallisti> (both on hackage)
19:08:55 <otters> well let me see
19:09:13 <kallisti> lifted-base is kind of complicated to set up.
19:09:44 <kallisti> unless you're just using mtl transformers, and not your own type.
19:11:33 <hpaste> ‚Äúhaskell wikibook‚Äù pasted ‚ÄúComputing points‚Äù at http://hpaste.org/68930
19:12:32 <ku> can someone observe the differences between the two functions^?
19:12:59 <ku> "We cheated a little when moving from the second version of pts to the third one: they do not do exactly the same thing. Can you spot what the difference is?" ... "Please do the exercise above before continuing: it is quick to do and really important."
19:13:09 <ku> the problem is I don't see the difference
19:14:32 <qtplatypus> ku: How meany times are the values compared in the diffrent versions?
19:15:11 <byorgey> ku: there are inputs for which the two functions give different answers.
19:15:31 <byorgey> I can't say much more without giving away the answer.
19:15:37 <ku> ok
19:15:44 <ku> thanks for not giving it away
19:16:37 <ku> oh of course
19:16:43 <ku> negative values
19:16:48 <byorgey> you got it =)
19:16:51 <ku> =)
19:16:52 <ku> thanks
19:16:55 <ku> duh haha
19:18:39 <ku> is there any way to do something like this notation in haskell: 0 < x <= 6
19:21:53 <otters> kallisti: MonadCatchIO just saved my life
19:21:55 <otters> thank you
19:41:42 <monochrom> haskell weekly news!
19:42:25 <monochrom> hrm, the quotes of the week section is weak! just one quote?!
19:57:25 <hashcurl> What's best for unit testing in Haskell? QuickCheck, HUnit, ... ?
19:57:51 <boccato> If I want to make an app for OSX, is there a good binding for Cocoa? Or should I go straight to GTK+ or make a web interface?
19:58:00 <ezyang> HUnit is pretty standard.
19:58:09 <ezyang> QuickCheck is not unit testing, but it's better :-)
19:58:17 <Axman6> QuickCheck isn't really a unit testing framework
19:58:52 <dmwit> boccato: Well, there's MacOSGtk. =)
19:59:04 <dmwit> Don't know of a Cocoa binding, to answer the direct question.
19:59:55 <boccato> I found one but it seems pretty old.
20:00:03 <boccato> hashcurl: http://www.markhneedham.com/blog/2012/05/20/haskell-my-first-attempt-with-quickcheck-and-hunit/
20:00:12 <boccato> hashcurl: might be usefull
20:01:18 <boccato> I am starting and trying both right now, HUnit is pretty simple to get if you have done unit testing before, so I am trying a little harder to use quick-check so I learn a new thing :)
20:02:02 <blackdog> hashcurl: i've been enjoying hspec
20:02:30 <blackdog> you can use either hunit or QC tests in it, and hspec-discover is quite sweet too - automatically finds your tests.
20:02:39 * hackagebot cabal-debian 1.22 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-1.22 (DavidFox)
20:20:49 * hackagebot hOpenPGP 0.3 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-0.3 (ClintAdams)
20:23:57 <chare> Can someone explain to me how functional languages avoid the parallelism/concurrency problem that nonfunctional languages have?
20:24:54 <dmwit> What's the parallelism/concurrency problem that functional languages avoid?
20:25:08 <chare> well that is the question
20:25:18 <parcs`> chare: purity is the important thing
20:25:20 <chare> i'm trying to understand what the value of functional languages are
20:25:36 <tgeeky_> chare: do you understand what the value of the Spanish language is?
20:26:00 <chare> what?
20:27:12 <tgeeky_> chare: I'm being pedantic; but the value of any programming language is that it's useful to someone
20:27:13 <blackdog> chare: he's suggesting that you're aware there's a problem with imperative languages and concurrency. What's that problem, to you?
20:27:37 <tgeeky_> chare: the key point (as parcs said) is purity
20:27:44 <chare> what does purity mean
20:28:04 <dmwit> The question is ill-formed. You asked how to avoid problem X, but didn't say what problem X was.
20:28:15 <dmwit> So it's not even clear that functional languages avoid problem X.
20:28:20 <dmwit> (At least to me.)
20:28:33 <tgeeky_> chare: it means that we decide to throw up a barrier between all of the things which don't have side effects (which are "pure" or "referrentially transparent")
20:28:43 <newsham> chare: "equals means equal"
20:28:44 <tgeeky_> and things which do have side effects
20:28:48 <chare> so what does all this i hear about parallelism/concurrency in relation to functional languages about?
20:28:57 <dmwit> chare: Well, what is it you hear?
20:29:10 <chare> I don't understand what they are saying
20:29:14 <chare> if I did i wouldn't be here
20:29:26 <newsham> lack of mutatable data makes some parallelism problems go away
20:29:28 <tgeeky_> chare: if they are saying that there's no tradeoff, than they're idiots
20:29:49 <tgeeky_> chare: let's back up a little bit.
20:29:59 <tgeeky_> chare: are you sure you know the difference between paralleism and concurrency?
20:30:03 <chare> no
20:30:12 <tgeeky_> ok, before we get to either then
20:30:23 <tgeeky_> what languages have you ever programmed in?
20:30:36 <chare> C, C++, Java, Python, Go
20:31:05 <tgeeky_> chare: ok. Would you agree that, in some sense, coding in Java is "safer" than coding in C?
20:31:14 <chare> yes
20:32:05 <tgeeky_> Imagine then, that you're writing some code, and you (like you would in java or C), list all of the things that go into a function (its arguments, or paramters) as well as all of the things that "come out" of the function (its return values)
20:32:32 <chare> right, i don't understand why thats not just a normal method in java
20:32:38 <tgeeky_> it would be
20:32:50 <tgeeky_> so, i'll name the function but you don't get to see the body
20:32:53 <tgeeky_> just the signature
20:33:03 <tgeeky_> (I don't know the proper syntax, so I'm going to BS it:)
20:33:21 <tgeeky_> int addTwo (int, int)
20:33:58 <tgeeky_> now, you call this function (and you dutifully put two ints in)
20:34:06 <tgeeky_> and you get an int out
20:34:17 <tgeeky_> no surprise. Then, you do it again.
20:34:25 <tgeeky_> Would you be surprised to get a different answer?
20:34:42 <chare> cosmic ray comes and changes memory address giving me a different answer, DAMN THOSE COSMIC RAYS
20:34:54 <tgeeky_> ok, you run it a third time
20:35:08 <dmwit> Even if the machine correctly performed the code you wrote, you will often get different answers from the same inputs to a given function in Java.
20:35:15 <dmwit> Look at System.random() or whatever it's called.
20:35:29 <dmwit> You *expect* it to give different results many times in a row.
20:35:38 <dmwit> Despite giving the same (that is, none) inputs.
20:35:56 <tgeeky_> chare: that is really where it drove home for me.
20:35:59 <chare> ok the whole functional part makes sense to me, but how does this help in parallelism
20:36:02 <dmwit> And in particular, if you call such a function from two threads, you can break things.
20:36:11 <dmwit> Because they'll both be trying to change some internal (shared) state.
20:36:17 <tgeeky_> chare: ah, because paralleism is just calling the functions repeatedly (but in parallel)
20:36:21 <dmwit> If you disallow internal shared state, this problem disappears.
20:36:53 <chare> if you have multiple threads executing in rather random interleaving matter then how do you make sense of a "function" that comes out the same every time
20:37:05 <chare> since it depends on the ordering
20:37:11 <dmwit> Parallelism does not depend on the ordering.
20:37:14 <dmwit> Only concurrency does.
20:37:15 <tgeeky_> chare: that's concurrency
20:37:21 <chare> ok concurrency then
20:37:40 <dmwit> That is why I was asking you to clarify what problem you thought got solved by functional languages.
20:37:46 <dmwit> Concurrency is not a solved problem.
20:37:56 <chare> so then parallelism is what...
20:38:00 <newsham> you might have heard "Do not communicate by sharing memory; instead, share memory by communicating." in golang before.
20:38:03 <dmwit> (Though we do have several neat techniques that you can't use in languages that can't make purity guarantees, like STM. =)
20:38:32 <dmwit> Parallelism is using more cores to compute the same result one core could compute, but faster.
20:38:38 <tgeeky_> chare: parallelism is the genuine speedup gotten by using more hardware
20:38:47 <chare> isn't that concurrency?
20:38:50 <dmwit> No.
20:39:01 <dmwit> Concurrency is having two threads of execution simultaneously.
20:39:06 <chare> thats speedup?
20:39:12 <dmwit> Not necessarily.
20:39:15 <tgeeky_> it might result in speedup
20:39:19 <tgeeky_> it might result in horrible slowdown
20:39:23 <dmwit> Concurrency is often just used to handle multiple clients (e.g. in a web server) rather than to be faster.
20:39:25 <tgeeky_> (or infinte slowdown, if you deadlock)
20:39:38 <dmwit> It's a latency-improving rather throughput-improving technique.
20:40:10 <tgeeky_> chare: either way, functional programming languages make these problems explicit, and let you tackle them directly.
20:40:21 <tgeeky_> chare: in Haskell, there are several (3+) approaches to both problems
20:40:40 <dmwit> Concurrency can be useful even on a single core: witness basically all operating systems since Windows 3.1.
20:41:10 <chare> ok so if I want a B-tree that lets multiple threads write to it I stick something like a mutex to protect to ensure only one write at a time, in functional languages i would express this as...?
20:41:21 <dmwit> You can run multiple programs on one CPU; this doesn't improve the speed at which they run (in fact it hurts, because you need to do context switching), but it dramatically improves responsiveness.
20:41:30 <dmwit> chare: The same way.
20:41:34 <tgeeky_> chare: a BTree of (Mvars, TVars, or something like that)
20:41:36 <dmwit> Concurrency is still concurrency.
20:41:44 <dmwit> We have a different name than mutex, that's all.
20:41:50 <tgeeky_> chare: but the GHC compiler can be rather more clever about it
20:41:58 <newsham> chare: there's a lot of diff ways actually.  you could share a variable, you could use a message passing channel, etc.
20:42:30 <tgeeky_> chare: back to my "addTwo" example.
20:42:58 <tgeeky_> chare: the compiler could potentially store in memory every possible pair of arguments to addTwo, and store every possible result
20:43:01 <chare> so message passing channel reminds me of go which is not functional, are you saying that functional languages don't have a functional specific way of expressing this?
20:43:30 <tgeeky_> chare: the compiler can *know* that the function addTwo isn't going to do anything outside of generating a single Int
20:43:43 <tgeeky_> chare: it won't write to disk, it won't read from the screen, it won't activate the pipebomb
20:43:46 <dmwit> We have two techniques that other languages don't have: pure parallelism and STM for concurrency.
20:44:25 <dmwit> We also have all the techniques you know and love from other languages: message-passing, shared memory, mutexes, etc.
20:44:41 <tgeeky_> and also all of the techniques inspired from really, really smart mathemiticans and computer scientists
20:44:54 <dmwit> Some concurrency problems can be made simpler with STM; but not all.
20:45:15 <newsham> mmm STM
20:45:19 <dmwit> Some parallel tasks can be written more simply with our pure parallel annotations; but again, you still need to know what you are doing. It's not a magic bullet that just turns everything into easy-mode.
20:45:20 <newsham> composable atomic operations ftw
20:45:30 <chare> i'm still confused about how this b-tree is expressed in functional languages, since there is no mutation first off on a write
20:45:42 <tgeeky_> chare: it's not there at first
20:45:50 <newsham> chare: you can have mutable shared state, and you can use immutable data types too
20:45:50 <tgeeky_> chare: but it's added back in with a little effort
20:46:07 <dmwit> chare: You're being mislead. There is mutability in Haskell and other functional languages,
20:46:09 <chare> you make changes and the entire history of the b-tree is suppose to be there right?
20:46:10 <newsham> for example you can build a new btree that is mostly made up of parts of the old btree
20:46:15 <newsham> but has some slight differences in it
20:46:27 <tgeeky_> chare: the point is; the decision was to *start* without mutable shared state (start with pure functions) and ONLY allow impure functions where necessary, and keep careful track of it
20:46:32 <newsham> and then swap a mutable reference to point to the new one
20:46:40 <dmwit> However, we can also separate *statically* those functions which use mutable state and those which don't. This doesn't matter for concurrency problems, but it does for problems with parallelism.
20:46:59 <chare> so tgeeky_ you saying that all the stuff like mutex and all that is nonpure and there is nothing to get around that
20:47:00 <tgeeky_> and it matters for the compiler (and your brain) to *reason* about the program
20:47:06 <dmwit> chare: yes
20:47:10 <tgeeky_> chare: yes, but that's great
20:47:32 <tgeeky_> chare: I like the cell wall analogy
20:47:33 <newsham> chare: when you have impure code in haskell its clearly marked as such.
20:48:07 <tgeeky_> chare: imagine you're sitting inside the nucleus of a cell, and you want to communicate some information with someone outside (of the nucleus)
20:48:40 <tgeeky_> in other languages, the solution is to completely rid yourself of the barrier that is the cell wall, allowing all kinds of communication in and out
20:48:49 <tgeeky_> in haskell, the solution is exactly the solution cells actually use
20:48:56 <newsham> tgeeky: now now.. be faire :)
20:49:00 <newsham> erlang, golang, etc..
20:49:04 <tgeeky_> well,
20:49:06 <tgeeky_> in C
20:49:12 <tgeeky_> i always compare to C
20:49:18 <tgeeky_> because it doesn't get any more dangerous
20:49:19 <chare> ok so i think i understand why people like pure functions, but i don't understand why i hear about functional languages in the context of the whole paralellism/concurrency (whichever one of the two they meant).
20:49:33 <tgeeky_> chare: STM (which is awesome, and was invented by Haskellers)
20:49:41 <chare> wtf is STM
20:49:47 <tgeeky_> chare: software transactional memory
20:49:56 <tgeeky_> there's a great 15 minute video
20:50:00 <tgeeky_> if you have the patience
20:50:04 <newsham> chare: there are some cases where you can get some parallelism for free in your pure code.
20:50:23 <newsham> and there are some great tools that being mostly pure give you when dealing with concurrency
20:50:39 <chare> wikipedia seems to indicate STM is not functional language specific?
20:51:06 <newsham> ?google beautiful concurrency
20:51:08 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/beautiful.pdf
20:51:09 <lambdabot> Title: Beautiful concurrency
20:51:55 <tgeeky_> chare: C is a functional language
20:52:32 <newsham> consider "map-reduce" programming.. by restricting what forms programs can take on you can build very scalable execution implementations.
20:52:47 <parcs`> chare: stm is pretty much pure-language-specific
20:53:02 <tgeeky_> chare: if you look at the list of languages: http://en.wikipedia.org/wiki/Software_transactional_memory
20:53:20 <tgeeky_> chare: the non-functional ones are: perl, smalltalk, and "other"
20:53:28 <tgeeky_> perl is excluded because it comes from Haskell in Perl6
20:54:11 <tgeeky_> chare: either way, we've already "admitted" that STM isn't a silver bullet
20:54:16 <chare> ok new question if i write a program in Go using channels, what do I gain by moving to a functional language in terms of concurrency/parallelism issues that I avoid
20:54:31 <tgeeky_> chare: that depends on the program of course
20:54:46 <newsham> go has a great concurrency model.
20:54:50 <newsham> haskell has it too
20:55:00 <newsham> haskell has more, too..  if you're happy with that model, you're fine
20:55:05 <chare> so there isn't an obvious "super bullet" beyond csp channel model?
20:55:06 <newsham> haskell lets you shop around a little
20:55:18 <newsham> csp isnt a "super bullet" either.
20:55:20 <Axman6> chare, regarding your query about why pure functions, in theory anyway, you can run any part of a pure function in any order, including at the same time. it is possible to get parallelism for free
20:55:23 <newsham> its just a great concurrency model
20:55:36 <tgeeky_> chare: Haskell is more of a "bullet emporium"
20:55:50 <tgeeky_> chare: you are encouraged to try each kind of bullet, shoot your victim, see the results
20:55:55 <Axman6> it doesn't matter where a pure function is run, it is guaranteed to always return the same result for the same inputs.
20:56:23 <newsham> (haskell has other advantages over go ;-)
20:56:32 <Axman6> NULL
20:56:33 <Axman6> >_>
20:56:40 <newsham> ?google music of streams
20:56:42 <lambdabot> http://www.shoutcast.com/
20:56:42 <lambdabot> Title: Free Internet Radio - SHOUTcast Radio - Listen to Free Online Radio Stations
20:56:46 <newsham> blah, bad url
20:56:54 <tgeeky_> chare: Haskell is not designed to compete with every other langauge on its best strengths
20:57:00 <newsham> ?google mcilroy music of streams
20:57:02 <lambdabot> http://www.cs.dartmouth.edu/~doug/music.ps.gz
20:57:04 <tgeeky_> chare: and frankly, that's not fair to ask of any language
20:57:04 <chare> ok so I'm still unsure if I want to use a functional language over something like Go, I don't believe in the get parallelism for free since everything I've ever seen involves mutating file system, databases, etc.
20:57:24 <tgeeky_> chare: mapreduce is something you would do that involves all of those things
20:57:28 <newsham> doug mcilroy's paper is a great example of something thats beautiful in haskell..  he's one of the old timer bell labs unix guys, too :)
20:58:13 <tgeeky_> chare: the parallelism that comes for free... comes for free. It doesn't really matter if the data came from disk or the network or not
20:58:50 <tgeeky_> chare: there is a single, recent, consolidated paper about this
20:59:26 <chare> anyone here of clojure? why is this language suddenly getting attention?
20:59:33 <Axman6> chare, it seems you've only been exposed to uninteresting programs ;)
20:59:39 <tgeeky_> chare: community.haskell.org/~simonmar/par-tutorial.pdf
20:59:57 <tgeeky_> chare: observe, in that paper -- how *tiny* code changes (almost trivial changes)
21:00:00 <newsham> chare: because it runs in jvm and in browsers..    its the portable, supported lisp that peopel always wanted but were to afraid to ask for :)
21:00:06 <tgeeky_> result in fantastic speedup
21:00:10 <newsham> also popularity breeds popularity
21:00:19 <Axman6> clojure is popular because it shared many of the great features of haskell, and interacts with Java easily
21:00:47 <tgeeky_> chare: all of those problems in that paper are well known, important problems, whose known best implementations are heavily optimized in imperative languages
21:01:12 <tgeeky_> and yet haskell competes with tiny amounts of code that aren't hand-optimized in assembly or whatever
21:02:16 <tgeeky_> anyway, back to the point about Spanish:
21:02:25 <chare> Let me ask another question to see if I understand what you guys are getting at
21:02:34 <tgeeky_> To understand what makes Spanish beautiful to people who speak Spanish, they would need to tell you in Spanish
21:03:01 <chare> You saying hypothetically I could write a pathfinding algorithm in haskell that could be auto parallelized (since pathfinding doesn't mutate anything in the world)
21:03:29 <Axman6> no, we don't do much auto parallelisation
21:03:55 <tgeeky_> chare: you mean like pathfinding in a game world or something like that?
21:04:03 <chare> REAL TIME STRATEGY GAME BABY
21:04:04 <Axman6> because it's extremely hard to get right. we provide the tools that make it extremely easy to get your algorithms to run in parallel with minimal effort however
21:04:39 <tgeeky_> chare: that does rely on mutable state, it's just not the state of the gameworld, it's pathfinding state
21:04:46 <tgeeky_> chare: but I'd guess it can be done efficiently
21:04:49 <chare> if auto parallelization isn't happeing then how is it that haskell competes with heavily optimized imperative languages???
21:04:52 <chare> like you said about
21:05:05 <tgeeky_> chare: GHC is very smart
21:05:07 <Axman6> by doing the parallelisation by hand
21:05:17 <tgeeky_> and it's backed by GCC, which is pretty damn smart too
21:05:51 <tgeeky_> chare: almost all of the things that make functional programming great, are related to your (or your compiler's) ability to *reason* about the code you write
21:06:00 <Axman6> it's extremely easy. you tell the compiler which computations might be beneficial, and the compuler takes of scheduling everything at runtime on as many cores as you have available
21:06:00 <chare> so where is the gain coming from if imperative languages can do paralelilzing by hand too
21:06:09 <Axman6> GHC doesn't use GCC anymore
21:06:23 <tgeeky_> Axman6: as of?
21:06:37 <Axman6> doing parallelisation by hand in other languages is a) painful, abd b) difficult to get right
21:06:44 <Axman6> and*
21:07:04 <rwbarton> some languages can solve (a) more or less
21:07:05 <Axman6> tgeeky_ as of when we started using the native code generator in GHC, and the LLVM backend too
21:07:27 <Axman6> yeah, Go is an example of a language where getting parallelism isn't too hard. getting it right is still fairly hard
21:08:11 <parcs`> chare: usually what's compared is parallel haskell code vs sequential c/whatever code
21:08:39 <tgeeky_> chare: if you're totally convinced of your infallability, then by all means, go ahead and write your parallel and concurrenct code in C or Go or whatever. Don't be surprised when your airplane crashes though :o
21:09:00 <Axman6> having channels makes life easier in Go, but it doesn't prevent race conditions
21:09:16 <chare> so a function is composed of other functions like it depends on them, and dependency is like a directed graph and you're saying you can execute this graph in a parallel way so long as the directed edge dependencies are considered?
21:09:18 <Axman6> when you're working with pure values, there's no chance of race conditions
21:09:59 <tgeeky_> chare: even if it's cyclic, yes
21:10:20 <chare> and that is where the auto parallelization comes from?
21:10:23 <Axman6> chare, we're saying you can tell the compiler that certain parts of the graph might be execute faster if run in parallel, and you can annotate your code to tell it which bits
21:11:11 <Axman6> let fib 0 = 0; fib 1 = 1; fib n = let a = fib (n-1); b = fib (n-2) in a + b -- Sequential algorithm
21:11:31 <Axman6> let fib 0 = 0; fib 1 = 1; fib n = let a = fib (n-1); b = fib (n-2) in a `par` b `pseq` a + b -- Parallel algorithm
21:13:13 <chare> ok next question you mentioned race condition
21:13:31 <Axman6> that says execute the values a and b in parallel, then execute a + b. just so you understand
21:14:26 <chare> and the reason they don't autoparallelize i assume is that the overhead can be not worth it in many cases and thats why you have to explicitly tell it to parallelize?
21:14:49 <parcs`> yes
21:14:50 <Axman6> well, if you parallelise everything, then there's a lot of overhead, yes
21:15:04 <chare> so when you mentoined race conditions
21:15:06 <parcs`> you can theoretically parallelize everything in a pure language
21:15:09 <chare> can you give an example
21:15:14 <Axman6> the overhead is extremely low in GHC, but not negligable when it's that prevalent
21:15:52 * hackagebot sbv 2.1 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  http://hackage.haskell.org/package/sbv-2.1 (LeventErkok)
21:17:08 <dmwit> "Changing the +RTS -N setting at runtime." <- AWESOME
21:17:24 <tgeeky_> dmwit: I know right?
21:17:27 <Axman6> heh, i haven't had to deal with a race condition in so long, i can't think of any cannonical ones
21:17:55 <tgeeky_> dmwit: using haskell/GHC is like christmas 4 or 5 times a year
21:17:55 <newsham> modifyIORef ?
21:17:57 <qtplatypus> Axman6: dining philosphers
21:18:01 <chare> so instead of getting race conditions, in haskell you can only get computations of the wrong number?
21:18:14 <tgeeky_> Axman6: philosophisizing dinosours?
21:18:32 <dmwit> "Holes in terms." <- DOUBLE AWESOME
21:18:35 <dmwit> oh my goodness
21:18:39 <dmwit> this is better than Christmas
21:19:03 <tgeeky_> hehe
21:19:13 <tgeeky_> dmwit: btw, you used: http://hackage.haskell.org/packages/archive/bimap/0.2.4/doc/html/Data-Bimap.html in a stackoverflow answer
21:19:26 <tgeeky_> dmwit: isn't it weird that there isn't an Ord instance on Bimap?
21:19:37 <chare> You guys mentioned thinking about the pure parts, and the impure parts: needing to use mutex in b-tree, writes, databases, etc...
21:19:38 <newsham> a race condition only happens when something changes (mutation)
21:19:45 <tgeeky_> and instead there are Ord Ord constraints on many of the functions
21:19:45 <newsham> how do you race when there's no mutation?
21:19:54 <chare> so if you're advocating mutex in b-tree, what is this book about: http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
21:20:30 <dmwit> tgeeky_: Is that weird?
21:20:35 <tgeeky_> chare: hehe. you can't use our own dogma against us
21:20:37 <newsham> chare: okasaki's data structures are immutable.  you pass in an old tree to an update function and it returns you a new one
21:20:38 <tgeeky_> dmwit: yes?
21:20:40 <newsham> without altering the old one
21:20:52 * hackagebot chell 0.3 - A simple and intuitive library for automated testing.  http://hackage.haskell.org/package/chell-0.3 (JohnMillikin)
21:20:58 <chare> ok but then if there are two threads wanting to write to it...
21:21:07 <newsham> okasaki doesnt talk aobut two threads wanting to write it
21:21:19 <chare> ok that makes so much more sense
21:21:23 <dmwit> tgeeky_: I guess if you want it you could stick a "deriving instance Ord Bimap" in your code. It seems like a reasonable thing to have in the library, too.
21:21:26 <newsham> but if you wanted to do that in haskell, it would be really easy to do it in an "atomically" block in STM
21:21:26 <dmwit> Send a patch! =)
21:21:27 <Axman6> chare, there is no writing to it, there is only creating new trees
21:21:47 <newsham> by using the atomically block to update a "reference" to "THE" tree.
21:21:47 <Axman6> and those new trees can use most of the old tree, so this is usually quite efficient
21:21:56 <newsham> you'd use the pure functions to create the new "THE" tree, and then update its reference
21:22:07 <newsham> and if you raced agaisnt another thread doing that, STM would make that other thread stop and do it again after the conflict
21:22:07 <tgeeky_> dmwit: I was comparing it to: http://hackage.haskell.org/packages/archive/relacion/0.1/doc/html/Data-Relacion.html
21:22:19 <Axman6> newsham, i'd use an IORef and atomicModifyIORef personally, unless i needed transactions
21:22:31 <tgeeky_> dmwit: hopefully you can-a read-a the espanish-a
21:22:35 <newsham> axman: *nod*  but morally the same idea...
21:22:43 <dmwit> tgeeky_: Google Translate can.
21:22:44 <chare> and the reason this isn't horribly inefficient is because of the garbage collector underlying?
21:22:56 <chare> garbage collector gets rid of old trees that can't be referenceed?
21:22:57 <Axman6> well, that's part of it
21:22:59 <tgeeky_> dmwit: hehe trust me, it makes *less* sense after translate
21:23:00 <Axman6> yes
21:23:10 <newsham> chare: modifying a persistent tree isnt really that inefficient.. but yes, GC gets rid of unneeded stuff
21:23:20 <newsham> but most of a modified tree is common with the old tree
21:23:22 <tgeeky_> dmwit: I am biased, since I kind of know spanish
21:23:42 <newsham> err.. I shouldnt have said "modifying" :)
21:23:46 <newsham> but you know what i meant
21:23:51 <dmwit> Google Translate does seem to muck about with type signatures a fairly lot. =P
21:23:55 <tgeeky_> dmwit: hehe
21:24:13 <tgeeky_> dmwit: evidently all of these data declerations are instructions for a Telemundo dating game
21:24:36 <tgeeky_> dmwit: anyway, glad you pointed me to bimap
21:24:40 <newsham> tgeeky: you could do the same in golang..  have a function which creates a new updated btree, then pass it in a message to the guardian of THE btree
21:24:41 <tgeeky_> well... pointed someone
21:24:48 <newsham> err not tgeeky, that was for chare
21:24:52 <tgeeky_> chare: ^^
21:25:03 <newsham> its a general technique, not a haskell specific idea
21:25:21 <newsham> so go grab okasaki's book and use it in your lang of choice :)
21:25:48 <Axman6> chare, do you know much about Erlang?
21:25:55 <chare> it has channels
21:25:57 <chare> thats about it
21:25:58 <chare> like go
21:26:08 <newsham> erlang does CSP like golang does, no?
21:26:17 <chare> i thought it did
21:26:44 <chare> can anyone confirm?
21:27:34 <tgeeky_> nope, too lazy
21:27:51 <newsham> google says different but similar.
21:27:52 <tgeeky_> chare: one feature that is specific to Haskell (and not all funpro) is laziness
21:27:56 <newsham> http://www.informit.com/articles/article.aspx?p=1768317
21:28:08 <tgeeky_> chare: it's great to be able to tell the boss that laziness is a good thing (and it is!)
21:28:29 <newsham> tgeeky: almost.. you get limited lazy data types by explicitly asking for them in other langauges.  ie. generators, iterators, channels
21:28:44 <chare> So how hard is it to take data structures from this book and implement them in Haskell. In other words is moving a data structure imperative implementatiton to a functional one automatic or hard?: http://www.amazon.com/Introduction-Algorithms-Thomas-H-Cormen/dp/0262033844/ref=sr_1_1?ie=UTF8&qid=1337833448&sr=8-1
21:29:06 <Axman6> Erlang's CSP is far more robust than Go's though. and its channels work across networks
21:29:11 <tgeeky_> newsham: that doesn't feel right though
21:29:40 <Axman6> Erlang also has a share nothing architecture. the only communication is done through channels, there's no implicit communication in memory
21:30:11 <newsham> chare: you cant directly translate an arbitrary imperative data structure into a functional one.  you can implement imperative data structs in haskell by going impure
21:30:53 * hackagebot chell-hunit 0.2 - HUnit support for the Chell testing library  http://hackage.haskell.org/package/chell-hunit-0.2 (JohnMillikin)
21:30:55 * hackagebot chell-quickcheck 0.2 - QuickCheck support for the Chell testing library  http://hackage.haskell.org/package/chell-quickcheck-0.2 (JohnMillikin)
21:30:57 <Axman6> Haskell doesn't stop you doing anything at all, it just makes it clear when you're doing evil things (Mutation and IO)
21:31:16 <chare> ughh you telling me that writing data structers in functional languages isn't automatic?
21:31:31 <newsham> tgeeky: python generators are pretty close to haskell lists.  just more syntax heavy (and some other restrictions, like difficulty making recursive data)
21:31:43 <Axman6> uh what?
21:31:44 <rwbarton> it's not like it was automatic in C either
21:31:51 <rwbarton> people just figured out what works well in C
21:32:02 <newsham> chare: you want us to say everything is automagic in haskell? :)
21:32:07 <Axman6> yeah... what language gives you data structures automatically? (hint, none)
21:32:23 <chare> YOU GUYS WERE DOING SO GOOD, making functional languages sound so good, THEN YOU DROP THE BOMBSHELL
21:32:25 <parcs`> it's automatic in the sense that most data structures have been packaged up into a library by now
21:32:35 <tmiw> I'd run an OS written in Haskell.
21:32:36 <tmiw> :D
21:32:37 <newsham> no bombshell and no silver bullets
21:32:43 <parcs`> you don't have to write your own hash table for the nth time, like in a c projech
21:32:59 <Axman6> chare, what exactly do you think we've just said? you seem to be implying that the compiler can read minds and produce complex data structures out of nowhere
21:33:00 <newsham> pure functional lazy programming is great and there are downsides and workarounds
21:33:25 <chare> so using a pure functional language if i ever need to do some kind of data structure i'm going to have to think hard NOO I DON'T WANT TO THINK
21:33:39 <newsham> or you import something from the stdlib
21:33:45 <mgsloan> This is a bit of a crazy idea, but I must say, it'd be pretty awesome to figure out a tracing C++ --> Haskell conversion (e.g. use runtime observations to increase the number of invariants believed to be held by the code)
21:33:50 <rwbarton> typically if writing your program doesn't require thinking at all it doesn't really matter what language you write it in
21:33:50 <newsham> haskell is no cure for not thinking
21:34:08 <Axman6> chare, we never said that, we said that if you want to use IMPERATIVE DATA STRUCTURES, you can implement those yourself too
21:34:16 <newsham> if you want to not think, you can always IRC
21:34:35 <chare> isn't writing a mutation based data structure a lot easire to think about than a purely functional one?
21:34:46 <tgeeky_> chare: think about or reason about?
21:34:53 <newsham> depends.  if you've done it all your life you might find it a lot easier
21:34:54 <tgeeky_> and for you, or the compiler
21:35:00 <newsham> if you've done functional data structs all your life you might not
21:35:01 <Axman6> data Tree key value = Node key value (Tree key value) (Tree key value) | Leaf key value -- Binary tree
21:35:10 <tgeeky_> if the answer is: for the compiler, then: hell no
21:35:30 <chare> tgeeky: SCREW THE COMPILER, I'M MORE IMPORTANT
21:35:41 <Axman6> chare, in my experience, no. imperative data structures are far more easy to get wrong
21:35:42 <newsham> true.  programmer time is more important than compiler time.
21:36:09 <mgsloan> yeah, the output of this would certainly need to be massaged to be of any use.  Could be interesting, though, particularly if they developed a suite of rewrite rules and customizable post-processes / lists of refactorings to apply
21:36:43 <mgsloan> in other words, you could develop a re-applicable strategy for porting a particular library
21:36:57 <mgsloan> so that you can continue to do so, even when the original code changes
21:37:02 <chare> so in erlang if you want to implement a data structure it has to be purely functional?
21:37:03 <Axman6> data MTree key value = Node key value (IORef (MTree key value)) (IORef (MTree key value)) | Leaf key value -- A binary tree with mutable branches
21:37:28 <Axman6> i would guess they also have ways to perform mutation, but I don't know what they are
21:38:59 <wgd> okay
21:39:10 <wgd> sorry, wrong channel
21:39:52 <chare> what is meant by erlang being a purely functional language vs haskell not being purely functional
21:40:27 <c_wraith> I don't think erlang has any mutable data, actually - except for the implicit message queues
21:40:38 <wgd> and the process dictionary
21:40:38 <chare> so then how does erlang write to a database?
21:40:46 <Axman6> haskell is pure by default
21:41:03 <c_wraith> erlang is definitely not pure - it allows side effects
21:41:04 <Axman6> you can interract with C in erlang, so binding to libraries isn't hard. Same in Haskell
21:41:10 <c_wraith> wgd: oh, right
21:41:58 <Axman6> chare: no one would say that Erlang is a more pure language than Haskell, you use side effects all the time in Erlang (sending data over a channel is a side effect)
21:42:24 <Axman6> hmm, you can call C from Erlang right? I haven't touched it in ages
21:43:07 <chare> so would it be more correct to say that "purely functional language" means a language that does not allow a side effect approach if there exists a functional approach.
21:44:39 <newsham> a purely functional language is a language without assignments and mutable state
21:44:54 <Axman6> and that's the default in Haskell
21:44:55 <tgeeky> chare: that's close enough
21:45:26 <chare> why would i want to use lisp(((()))()()()()()()()()())))))))?
21:45:28 <newsham> haskell kinda has three languages.. one of em is an IO language construction kit that you can use to build up programs with side effects in
21:45:37 <newsham> using pure code
21:45:53 <chare> explain to me why i would want lisp over haskell?
21:45:57 <tgeeky> chare: for the same reason that you use English. historical raisins.
21:46:12 <Axman6> but we also have mutable state and IO, but those are explicitly marked in the type system. you can tell from the type of something whether it can or can't do something evil like access the network in the middle of computing a polynomial
21:46:22 <newsham> some people like lisp for its simple syntax, which allows for the use of macros.. also it is dynamically typed, which some people find cute
21:46:26 <newsham> and other people dont
21:46:26 <chare> do peolpe like typing this in lisp: ()()()()()()()()()()()()?
21:46:33 <Iceland_jack> newsham: cute?
21:46:38 <otters> people don't type that in lisp
21:46:42 <newsham> as in "awww.. isnt that cute?!"
21:46:51 <Iceland_jack> interesting
21:47:10 <hamid> nice subject :D
21:47:11 <chare> why does lisp have goddamn parens everywhere?
21:47:14 <Axman6> chare: you're boardering on trolling now. if you want to keep asking interesting questions, by all means go on, but trolling isn't something we're interested in
21:47:29 <Axman6> because lisp programs are their own AST
21:47:33 <shachaf> chare: This isn't really a channel for insulting LISP, as much as it may seem like one.
21:50:46 <Iceland_jack> chare: your questions have an interesting tone of entitlement
21:56:12 <chare> why are csp channels not ubiquitous among imperative languages
21:57:36 <ozataman> hi all. anybody know a good library for formatting numbers? (# of decimal points, etc.)
21:57:57 <Axman6> probably because most imperative languages don't have anything stopping you sharing things implicitly in memory, and this is generally not a good thing
21:58:03 <dmwit> ozataman: Numeric?
21:58:10 <Axman6> ozataman: printf, comes with GHC I believe
21:58:15 <dmwit> or printf if that's your cup of tea
21:58:20 <dmwit> It's not mine, personally.
21:58:27 <Axman6> > printf "%2.2f" pi :: String
21:58:28 <lambdabot>   "3.14"
21:58:36 <dmwit> Everything you can do with printf you can do with Numeric, and without the dangers.
21:59:09 <Axman6> the dangers are pretty minor no?
21:59:10 <ozataman> Axman6: I gave printf a try, but it had some  behavior I didn't want.. can't remember. maybe I should look again
21:59:15 <Axman6> also what can you do with Numeric?
21:59:29 <ozataman> dmwit: thanks, that sounds a bit more idiomatic. what's a good way to run ShowS again outside the context of Show instance?
21:59:43 <dmwit> apply to ""
21:59:48 <dmwit> ?src ShowS
21:59:49 <lambdabot> type ShowS = String -> String
21:59:59 <ozataman> ah ok, easy enough
22:00:15 <shachaf> I wish the type of ShowS captured what it was fully. :-(
22:00:25 <shachaf> (I.e. that it's always a function of the form (x++).)
22:00:48 <shachaf> Is there a reasonable way of doing that?
22:01:47 <ozataman> dmwit: sweet, works pretty well
22:02:08 <ozataman> Axman6: showFFloat (Just 2) pi
22:02:17 <ozataman> Axman6: sorry, and then apply that to ""
22:03:25 * Axman6 still prefers printf :\
22:03:48 <chare> Real time strategy game in haskell with 60 frames per second feasible?
22:04:14 <rwbarton> @faq Real time strategy game in haskell with 60 frames per second feasible?
22:04:14 <lambdabot> The answer is: Yes! Haskell can do that.
22:04:20 <c_wraith> probably difficult in the current GHC, due to the garbage collector limitations
22:04:36 <chare> why would the gc cause problems
22:05:07 <c_wraith> there can be some pretty hefty pauses
22:05:13 <chare> not generational?
22:05:28 <c_wraith> It is generational - but stuff still escapes the nursery
22:05:35 <chare> what do you mean?
22:05:54 <rwbarton> generational means there are still non-generation-0 collections...
22:05:57 <c_wraith> oh.  Just that eventually you need to collect stuff outside the nursery, and that can get bad
22:06:38 <chare> so does that mean real time strategy game in go with 60 fps is also unfeasible?
22:08:13 <hamid> is that a bug ? I mean you ghc will fix that ?
22:10:04 <wgd> Whether or not you trigger worst-case GC performance depends on your allocation patterns. I wouldn't be surprised to see a game not have too much trouble, since most data is either going to be ephemerally computed each frame, or a core data structure that hangs around for the life of the program.
22:11:35 <wgd> Also important to keep in mind that a lot of RTS games run their core logic at 10-20 FPS, and only the graphics go faster (since keeping game logic synchronized over the internet at 60 FPS is much harder than at 20)
22:14:31 <dessio> hello
22:18:03 <dmwit> howdy, dessio
22:20:33 <dessio> hi, dmwit,
22:20:54 <dessio> i'm trying haskell now.
22:21:46 <dmwit> \o/
22:23:23 <dessio> Cool haskell.
22:24:00 <Axman6> what've you learnt so far?
22:24:27 <dessio> just a newbie.
22:25:31 <andares> wgd: ah, that's pretty clever.
22:26:46 <dessio> Lesson 2 completo!
22:26:57 <dessio> hoooohoooooo!
22:28:17 <pharaun> i don't know bout haskell but in lots of other garbage collected games often you want to try to pre-allocate as much as you can and see if you can't reduce the amount of object creation/destruction to help prevent/reduce "work" for the gc
22:29:28 <pharaun> now i'm not familiar at all with haskell gc but if it becomes a issue i would try looking at reducing the amount of new/old data that you generate then shortly latter let go etc..
22:30:18 <jonaskoelker> how'd you do that in Haskell?  It's not like vector<int> also takes an allocator<...> as a type argument ;-)
22:32:00 <andares> jonaskoelker: so is there no way at all to handle memory allocation?
22:32:05 <pharaun> :D as far as i know :p this is probably of no help :p was just commenting on what i've seen with other GC languages
22:32:46 <jonaskoelker> I wouldn't know how, at least.  Also, that would seem to break all sorts of abstraction layers
22:32:49 <wgd> I've never liked that approach, it seems like throwing away the entire point of garbage collection, which is to let you not have to worry about where your objects are coming from or when they're not needed any more.
22:33:39 <jonaskoelker> (@wgd et al.) but if you want to performance-tweak your memory management, don't you need to break at least some layers of abstraction?
22:34:42 <Axman6> andares: we have access to malloc and free, and other things i'm sure
22:35:00 <andares> :t malloc
22:35:01 <lambdabot> Not in scope: `malloc'
22:35:26 <andares> I would think that there might be abstract ways to handle memory allocation.
22:36:00 <andares> I don't know how Haskell's memory management works, but I'd think that it is some kind of reference-counter thing and that maybe there's some abstract way to represent references to a calculation?
22:36:29 <pharaun> wgd: indeed, but problem is the whole halt the world garbage collection can be bad for game performance, if you could somehow segment it down or better manage it it would probably work better
22:36:37 <wgd> I think Haskell uses generational mark+sweep collection
22:37:02 <dmwit> What is this now?
22:37:42 <dmwit> malloc seems like an unidiomatic way to allocate extra memory.
22:37:52 <wgd> Err, s/Haskell/GHC/. Also I just looked it up and it appears to be copying up to 30% of heap usage, then switches to mark+sweep after that.
22:38:00 <dmwit> Just build an (IO/ST)[U]Array that's bigger than you need.
22:38:27 <dmwit> Or generally any old data structure that's bigger than you need.
22:38:45 <wgd> But then you have to implement your own heap manager on top of the array, malloc gives you that for free
22:40:56 <pharaun> indeed, however i do think that lots of games tend to use custom malloc anyway
22:42:24 <dmwit> I don't understand this response. If you're pre-allocating memory, you're already implementing your own heap manager, whether you use malloc or something more idiomatic.
22:44:42 <wgd> dmwit: My point was that if you use malloc you are leveraging the heap manager that's built in to malloc, but if you preallocate arrays of objects you have to manually keep track of which ones are available at any given time.
22:45:04 <dmwit> If you're using malloc to allocate more memory than you need right now, you have to do that anyway.
22:45:07 <dmwit> That's *my* point.
22:46:43 <pharaun> think bout it the malloc/lots of other allocation is tweaked for the normal/average performance
22:46:53 <pharaun> the game ones are going to be more tweaked to their specific usage
22:47:14 <wgd> dmwit: I think I misunderstood you then. I was interpreting references to 'malloc' to mean "use malloc to allocate certain key data structures so the garbage collector doesn't have to trace them"
22:48:01 <dmwit> I still don't see why you would use malloc there. Just build the data structure. It will grow out of the nursery, and the GC will stop looking at it very often.
22:48:28 <newsham> premature optimization?
22:49:08 <wgd> Most definitely
22:51:13 <dmwit> malloc is appropriate when you need a Ptr (e.g. when interfacing with the FFI)
22:53:25 <pharaun> i suppose. i should go look up a few haskell based games to see how they deal with it
22:53:57 <dmwit> Tricky task.
22:54:12 <dmwit> Are there any really high-performance, open-source Haskell games?
22:54:41 <dmwit> Nikki and the Robots, maybe.
22:55:47 <newsham> wxAstroids? :)
22:56:18 <dmwit> Sure, there's a few games: RainCat, etc.
22:56:31 <dmwit> I'm not sure they really required the level of tuning people are talking about here, though.
22:56:36 <dmwit> (Not sure Nikki does, either.)
22:57:11 <dobblego> with view patterns, does this match only a single-element list? expr -> [(k, v)]
22:57:25 <dmwit> Depends what "expr" is.
22:57:29 <dmwit> If it's "id", then yes.
22:57:50 <dobblego> expr = Data.Map.toList iirc
22:58:01 <dmwit> Then it matches only single-element Maps.
22:58:26 <dmwit> f (expr -> pat) = bar is approximately f x = case expr x of pat -> bar
22:58:29 <dobblego> ah right of course
22:58:33 <dobblego> yes thanks
22:58:58 <dmwit> (I say approximately because the former only commits when "pat" matches, whereas the latter always commits.)
22:59:49 <pharaun> dmwit: point taken, still curious tho :)
23:01:02 <dmwit> Curious enough to try to get hired by that company making iphone games in Haskell? =)
23:04:20 <dmwit> "malloc" appears only in some C++ code interfacing to Qt in the Nikki source base.
23:04:52 <shachaf> dmwit: That company is still around?
23:05:01 <dmwit> dunno
23:16:25 <Jetic> Hello
23:16:42 <Jetic> ...
23:16:43 <shachaf> G'day.
23:16:46 <Jetic> ?
23:16:52 <shachaf> What?
23:16:55 <Jetic> Hello
23:17:16 <Jetic> Guten Morgen
23:17:19 <Jetic> ?
23:17:21 <Jetic> Bonjour?
23:17:31 <Jetic> Ko ni ji wa?
23:17:45 <shachaf> Jetic: Do you have a question?
23:22:11 <pharaun> dmwit: aw
23:44:40 <dessio> jetic is japanese?
23:55:55 <Axman6> dessio: Jetic is as new here as you are
