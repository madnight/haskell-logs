00:00:19 <rodayo> I was underthe impression that getContents works on a file
00:00:35 <rodayo> I can't stop... =P
00:01:40 * hackagebot paragon 0.1.10 - Paragon  http://hackage.haskell.org/package/paragon-0.1.10 (NiklasBroberg)
00:02:14 <rodayo> Oh I get it now. getContents forms a string so I can just go through the string instead. Thx
00:04:12 <rodayo> Did you start out with haskell or did you also have to transition into it from OO or something imperative?
00:04:53 <shachaf> Doesn't matter much what other people did.
00:05:11 <shachaf> Knowing about "OO" will probably not help you learn Haskell.
00:05:27 <rodayo> shachaf, kinda makes it harder imo
00:05:45 <shachaf> Probably not significantly.
00:06:26 <rodayo> maybe it's just me...I was just wondering how long it takes to get a handle on something so different
00:10:29 <mm_freak_> knowing OO can make it /significantly/ harder, because of the way OO is usually taught
00:11:20 <mm_freak_> of course the human brain is flexible…  with some patience you can adapt to the haskell way of thinking
00:14:18 <rodayo> mm_freak_ yep, even with the most trivial of tasks I'm finding myself getting stuck =P it's quite different
00:15:25 <Ptival> can you reason with types?
00:15:32 <jfischoff> rodayo:yes but don't get discouraged. We all went through that to varying degrees
00:16:23 <rodayo> =) I ain't giving up yet. I have a course on programming languages this coming semester. I'm sorta trying to get a head start
00:18:06 <Ptival> knowing some Haskell will definitely help
00:20:07 <mm_freak_> rodayo: in haskell it is important to think naturally
00:20:17 <mm_freak_> whenever something makes sense, it's probably right
00:21:28 <rodayo> mm_freak_ i agree. I'm finding in most cases when my work compiles it works exactly as I expect it to. But maybe that's because I'm forced to think about it more
00:22:24 <mm_freak_> rodayo: IMO it's a misconception that you're forced to think more…  it feels that way because a lot of rewiring is going on in your brain, but once you become fluent you may very well find yourself thinking /less/ in haskell
00:22:33 <mm_freak_> this is because haskell is an incredibly natural language
00:23:00 <mm_freak_> ones = 1 : ones  -- 1 prepended to ones?  that's 1 prepended to 1 prepended to ones…  an infinite list of ones?  would make sense the way the code is written…  and yeah, that's indeed what this is…  simple, no?
00:24:05 <monochrom> [ x | x<-[1..], x<5 ] is also a natural way to hope that you get [1,2,3,4]
00:25:45 <bbloom> does the haskell community have a try-only puzzle site similar to 4clojure.com ?
00:25:51 <rodayo> mm_freak_, i suspect that will happen. But I meant since I'm starting out I'm forced to really think before I hit the keyboard
00:25:52 <bbloom> try-online* i mean
00:26:14 <mm_freak_> rodayo: you can also hit the keyboard and let the type system think =)
00:28:16 <rodayo> To each their own I guess.
00:32:30 <rodayo> I'm calling it a night. So long everyone...
00:37:58 <abdulsattar> Why does GHC 7.4.1 build need libgmp.so.3 on Ubuntu 12.04 server?
00:38:29 <monochrom> because that's for Integer
00:39:06 <abdulsattar> we have libgmp.so.10 in Ubuntu 12.04
00:39:54 <shachaf> abdulsattar: You could install libgmp3-dev or something.
00:40:31 <abdulsattar> Funny thing is the same build works on Ubuntu 12.04 desktop version without any issue
00:40:41 <abdulsattar> shachaf: I'll try that
00:43:58 <abdulsattar> shachaf: Still doesn't work. Same error, libgmp.so.3 not found
00:45:29 <monochrom> http://packages.ubuntu.com/search?keywords=gmp&searchon=names&suite=precise&section=all  may help
00:46:37 <womb> Hi all
00:47:27 <abdulsattar> monochrom: thanks. But that's what I installed and I still get the same error
00:50:16 <Altazimuth> I'm teaching myself Haskell during my free time at school and I was wondering what a good compiler for Haskell is. Any suggestions would be much appreciated.
00:50:32 <Cale> Altazimuth: GHC
00:50:47 <Altazimuth> Much appreciated
00:50:48 <geekosaur> which that?  lib32gmp3 or libgmp3c2? and are you on a 32bit or 64bit install?
00:51:01 <Dread> GHC is used by every Haskeller I know.
00:51:53 <geekosaur> (libgmp3c2 is the correct answer anyway unless you somehow forced a 32-bit ghc on 64-bit ubuntu; also need libgmp3-dev)
00:52:06 <Altazimuth> geekosaur: I don't know the specs of the school computers, I'd imagine x86 architecture, I know we run XP.
00:52:26 <shachaf> Altazimuth: I think geekosaur is talking to abdulsattar. :-)
00:52:31 <geekosaur> Dread, lots of people still use winhugs for some reason (actually it looks like some schools still use it)
00:52:35 * Altazimuth facedesks
00:53:01 <geekosaur> sorry, yes, that was to abdulsattar who's trying to solve a libgmp.so.3 issue on the latest ubuntui
00:54:37 <Altazimuth> I'm just trying to move as far away from the language we're being taught at school as possible.
00:57:13 <Altazimuth> I would say the name of it but I fear the IRC may track down my school and burn it to the ground for teaching the language.
00:57:25 <geekosaur> (re winhugs, winghci seems to not be well known, probably because it's not part of base ghc; maybe it should be, I don't think there's much reason for winhugs any more with it around)
00:58:10 <shachaf> Altazimuth: MUMPS, eh?
00:58:34 <geekosaur> heh
00:58:34 <Altazimuth> shachaf: VB.NET
00:58:48 <Dread> Most schools teach VB
00:58:57 <Altazimuth> It's an ugly language
00:59:20 <Altazimuth> I'm discarding all memory of the thing asap
00:59:31 <Dread> You'll probably be taught Java next
00:59:45 <Dread> or you already learned it
00:59:48 <Dread> right?
00:59:53 <Altazimuth> Not learnt it yet
01:00:06 <Altazimuth> But yeah, 2 more years of VB then Java
01:00:21 <Dread> 2 years of VB? Whoa what?
01:00:30 <Altazimuth> Actually 4 years in total
01:00:50 <geekosaur> (VB was a long series of "you had how long to fix this, why is it still broken?!" for me...)
01:01:01 <earthy_> VB.NET is not all that bad
01:01:18 <Altazimuth> I hate how it's so grittle
01:01:21 <Dread> earthy_, because it has .net at the end
01:01:31 <earthy> yeah, it's a CLR surface syntax
01:01:41 <earthy> with a few weird twists, granted, but still
01:01:58 <Altazimuth> Is the Haskell Platform any good? The GHC part of the website recommends it over flat GHC
01:02:18 <shachaf> It's GHC + some libraries.
01:02:26 <earthy> altazimuth: you want the platfrom
01:02:30 <shachaf> You can get it, but it won't work with the latest version of GHC, I think.
01:02:31 <Altazimuth> shachaf: Bloated libraries?
01:02:33 <earthy> plain GHC gives you very little to work with
01:02:37 <Botje> if you're going to be working through LYAH or RWH you want the platform.
01:03:04 <shachaf> Extremely bloated. Best stick to writing straight machine code if you know what's good for you.
01:03:23 * geekosaur *eyeroll*
01:03:23 <Altazimuth> 01110110?
01:03:46 <monochrom> I recommend haskell platform
01:03:59 <geekosaur> platform is mostly useful libraries you'll find yourself wanting; it's the "batteries included" distribution, where the compiler just comes with the libraries needed to build the compiler
01:04:44 <monochrom> with only two exceptions: you really hate some of its included libraries; you really hate the included ghc version
01:04:45 <geekosaur> there's lots of other libraries but they're on hackage and if you install the platform they're just a command ("cabal install ...") away if you ever need them
01:05:01 <Altazimuth> Now to find the exe location, can't make start menu icons on school comps
01:05:18 <Altazimuth> can barely do anything on these things, can't even run exes off of flash drives because the technitians are pond scum
01:05:34 <koala_man> yes, that's a very scummy thing to not want people to do on public computers
01:06:10 <monochrom> well, public computers for compsci students are different.
01:06:21 <Altazimuth> and as I'm doing compsci
01:07:21 <Altazimuth> It makes things incredibly difficult, and the technitians forgot to make us not be able to run custom exes from our user areas, so we can bypass their silly security procedures
01:07:23 <monochrom> unless you expect every compsci instructor to be Dijkstra (who would not let you test your programs), forbidding exe is like the anti-thesis to compsci education
01:07:37 <Cale> Altazimuth: Actually, there is at least one Haskell person working on VB.net now.
01:08:56 <monochrom> it is also why compsci public computers should not use windows to begin with. so students can run programs and there are still fewer vulnerabilities
01:08:57 <Cale> Altazimuth: It's significantly better than previous versions of VB now at least, in that it has first class functions/subroutines.
01:11:37 <koala_man> haha
01:13:17 <Cale> (Specifically, Erik Meijer is working on the .net languages at Microsoft)
01:13:30 <koala_man> Function(x) x*2 End
01:13:58 <Cale> I'll admit that's pretty much the worst syntax for a lambda expression ever
01:14:28 <Cale> With the exception of not having lambda expressions in your language at all.
01:15:12 <shachaf> Cale: Which part is so bad about it? The "End"?
01:16:12 <Cale> A combination of that and the fact that you have to type Function at the beginning, which is long already
01:16:25 <shachaf> Not much longer than "lambda".
01:16:39 <Cale> I didn't say that scheme's syntax was good :)
01:16:45 <shachaf> True.
01:16:46 <Cale> But this is worse
01:17:08 <Cale> C# chose pretty good notation
01:17:31 <shachaf> Ruby has lambda {|x| x*2 }, inconsistently with the use of "end" for everything else in the language.
01:17:35 <Cale> x => x*2
01:17:37 <Cale> in C#
01:17:42 <shachaf> I guess you can lambda do |x| x*2 end
01:18:00 <shachaf> It also has proc {|x| x*2 }, which is subtly different.
01:19:04 <Cale> Mathematica has  Function[x,x*2] which you can also write as #*2&
01:19:32 <eviltwin_b> it's not inconsistent; do ... end and { ... } are the same but for precedence, which avoids some syntactic anomalies with respect to blocks in some contexts
01:19:59 <shachaf> eviltwin_b: I would forgive them if everything was done with lambdas, like it ought to be.
01:20:07 <Cale> (which desugars to  Function[Times[Slot[1],2]]
01:20:08 <Cale> )
01:20:48 <eviltwin_b> maybe it will be someday; lambdas actually came into it fairly late, I think it's still evolving a but
01:20:49 <eviltwin_b> bit
01:21:24 <eviltwin_b> unfortunately that leads to ruby's *real* problem which is that it deprecates language elements and breaks language features in point releases, making it a rather painful moving target
01:21:42 <eviltwin_b> it really needs to exit the rapid evolution phase...
01:21:58 <sopvop> ouch
01:22:25 <sgronblo> Could someone help me figure out how to use quickcheck's forAll?
01:22:34 <sgronblo> It's just making me feel stupid atm
01:22:35 <Cale> whoa, I just noticed how many people are here... 816 even after the netsplit
01:22:52 <shachaf> Cale: This channel is too big.
01:23:23 <Cale> sgronblo: sure
01:24:17 <sgronblo> I'm kind of confused over these Gen, Testable, Property types.
01:24:19 <Cale> sgronblo: forAll is used when you want to supply your own Gen a random generator
01:24:45 <Cale> Gen t is the type of random generators which produce random values of type t
01:24:49 <Cale> Gen is a monad
01:24:51 <sgronblo> Trying to restrict the input of values to my function I'm testing to be positive integers.
01:25:06 <Cale> oh, in that case, there's already a nice way
01:25:18 <Cale> (you could use forAll, but there's also a newtype)
01:25:28 <sgronblo> I'm all ears.
01:25:32 <Cale> http://hackage.haskell.org/packages/archive/QuickCheck/2.4.2/doc/html/Test-QuickCheck-Modifiers.html#t:Positive
01:25:40 <Cale> This is an instance of Arbitrary
01:25:48 <Cale> which will only give positive values
01:26:11 <Cale> So you can write  \(Positive x) -> (sqrt x)^2 - x < 0.0001
01:26:23 <Cale> @check \(Positive x) -> (sqrt x)^2 - x < 0.0001
01:26:24 <lambdabot>   Not in scope: data constructor `Positive'
01:26:32 <Cale> ah, well, it'd need to be imported
01:26:50 <Cale> (and I botched that test :)
01:26:58 <Cale> \(Positive x) -> abs ((sqrt x)^2 - x) < 0.0001
01:27:10 <HugoDaniel> :)
01:28:13 <Cale> You could also write   forAll (fmap abs arbitrary) (\x -> abs ((sqrt x)^2 - x) < 0.0001)
01:28:33 <sgronblo> I am definitely seeing that quickcheck could be quite powerful but I'm still held back by my poor knowledge of Haskell.
01:29:29 <Cale> There's also NonNegative
01:29:45 <Cale> which I guess is what would really be equivalent to that forAll I wrote
01:30:23 <Cale> as well as NonZero, and a bunch of other newtype wrappers which use custom generators for arbitrary and shrink
01:32:27 <Cale> sgronblo: are you familiar with how to write IO actions?
01:32:30 <sgronblo> http://pastebin.com/wpUYQWVX this is what I am trying to accomplish
01:32:31 <mauke> The paste wpUYQWVX has been copied to http://hpaste.org/67996
01:33:06 <sgronblo> I was reading LYAH about a year ago and not had much time to study Haskell recently. But yesterday I had a few hours but got stuck at this point.
01:33:38 <merijn> sgronblo: What's the use of the where clause there?
01:33:39 <Cale> sizesShouldBeLteLineSize (Positive lineSize) strings = all (\e -> length e <= lineSize) $ Formatter.format lineSize strings
01:33:39 <lambdabot> merijn: You have 1 new message. '/msg lambdabot @messages' to read it.
01:35:12 <sgronblo> Oh thanks
01:35:17 <Ptival> that where clause!
01:35:37 <sgronblo> What about it?
01:35:51 <Ptival> why did you write it?
01:35:58 <merijn> sgronblo: What is it for? Just to enforce the types? If so, why not just write a type signature?
01:36:03 <Cale> Ptival: he was trying to constrain the types of the parameters
01:36:06 <sgronblo> I copy and pasted it from some random tutorial online
01:36:18 <sgronblo> I couldn't find any good quickCheck tutorials at all
01:36:25 <merijn> Now I'm sad :(
01:36:43 <sgronblo> Saw both that where syntax and another syntax for constraining the types and I think someone in here said the where one was better
01:36:55 <Ptival> maybe I can see the point in "I want to specify types for parameters, but don't want to be bothered about the return type" :d
01:37:21 <merijn> sgronblo: You have both let and where for local clauses, but you don't want to use them for constraining types
01:37:47 <merijn> sgronblo: You'd normally just write a type signature for the function to do that
01:38:05 <sgronblo> I already have a type signature for the format function
01:38:07 <Cale> sometimes that's a really nice trick
01:38:35 <sgronblo> If by type signature you mean "format :: Int -> [String] -> [[String]]"
01:38:53 <Ptival> yes
01:38:56 <sgronblo> Oh look at that
01:38:56 <Cale> sgronblo: Right, and that's enough in this case
01:39:00 <sgronblo> Didn't need the where
01:39:03 <Cale> right
01:39:19 <sgronblo> Well I blame the halfassed tutorials I found yesterday
01:39:31 <sgronblo> I was confused why I would need to repeat the type signature
01:39:43 <Cale> You might have needed a signature for the number argument if we weren't explicitly pattern matching it (which lets it infer the type as well)
01:40:07 <Cale> also, if format was more polymorphic
01:40:18 <Cale> you might've needed to pin the types of things down more
01:40:41 <sgronblo> So how does the Positive lineSize thing work? Looks like calling a function on a parameter?
01:40:54 <sgronblo> Or well type constructor
01:40:59 <sgronblo> But those are functions too right
01:41:05 <Cale> It's pattern matching away the Positive data constructor
01:41:58 <Cale> QuickCheck will generate random values of type  Positive Int
01:42:26 <Cale> which will use the instance of Arbitrary for Positive
01:42:49 <Cale> which, as it sounds like, only generates positive values of the numeric type
01:43:03 <sgronblo> Why isn't it like myProp :: (Positive x) => Int -> String -> Bool, and then the definition?
01:43:04 <Cale> and we just strip away the newtype tag, and use the Int inside
01:43:27 <Cale> (Positive x) =>  means that x is some type which is an instance of the typeclass Positive
01:43:35 <Cale> (or any type, rather)
01:43:49 <Cale> and x would have to occur on the right side of the => as well then
01:44:03 <Cale> (or else the constraint is pointless)
01:44:05 <sgronblo> Oh that's true
01:44:21 <Cale> and then, which operations would that typeclass have?
01:44:37 <sgronblo> So myProp :: (Positive x) => x -> String -> Bool, and then the definition?
01:45:12 <Ptival> sgronblo: Positive is not a typeclass
01:45:14 <Cale> That would mean that the property is polymorphic, and for any type x which is an instance of the Positive class
01:45:25 <Cale> it could operate on values of that type
01:45:40 <Cale> But there is no Positive typeclass.
01:45:49 <Cale> (what methods would it have?)
01:46:19 <Cale> Or even if it had no methods, the constraint wouldn't let quickCheck do anything
01:46:33 <sgronblo> Ah yeah type class means that certain functions can be called on eh "things belonging to that type class"?
01:46:38 <Cale> yeah
01:47:01 <Cale> more or less, anyway :)
01:47:02 <sgronblo> But in this case it's just that the Positive means that the parameter satisfies some property.
01:47:12 <sgronblo> Gotta start somewhere :)
01:47:16 <Cale> We want the Positive to exist at the value level
01:47:23 <mm_freak_> sorry for asking this OT question, but i can't think of a better place to ask this:  what's the correct syntax?  "A, B and C are each X" or "A, B and C each are X"? =)
01:47:40 <womb> Does Haskell has a perfromance focused priority que in standard library ?
01:47:41 <Cale> mm_freak_: I like the first better
01:47:48 <danr> mm_freak_: first sounds better IMO
01:47:58 <mm_freak_> ok, thanks
01:49:08 <Cale> womb: maybe try http://hackage.haskell.org/package/PSQueue
01:49:24 <womb> thanks i was looking at some random code and i was scared
01:49:38 <womb> btw i read about forkIO and channels last night... this is awesome
01:49:41 <bitonic> womb: what's "standard library"? if you mean "Haskell platform",
01:49:41 <Cale> (it's not a standard library, but it's a good library)
01:50:17 <bitonic> Cale: that does more than what womb wants
01:50:23 <Cale> It does
01:50:39 <Cale> I've used it as a priority queue before with reasonably good results
01:50:40 <womb> bitonic: for me everything on "platform" is standard,
01:50:46 <womb> things i can use by default
01:50:50 <bitonic> so it's probably slower than a classic priority queue
01:51:00 <sgronblo> Is the Positive newtype something limited to quickCheck?
01:51:03 <Cale> asymptotically it's equivalent
01:51:09 <Cale> :)
01:51:16 <Cale> sgronblo: Pretty much
01:51:23 <womb> oh.. i need something around 14k inserts / sec and ~14k pops / sec
01:51:31 <eviltwin_b> not standard yet; I think it's on track for getting into containers at some point
01:51:34 <sgronblo> It feels a little like guards
01:51:35 <bitonic> Cale: yeah but asymptotically is not enough :P I'd expect the finger tree to have a much hiher overhead
01:51:36 <Cale> sgronblo: It's just a tag to tell the Arbitrary instance to only generate positive values
01:52:04 <Cale> bitonic: yeah, this is not a finger tree...
01:52:17 <bitonic> Cale: oh! ok.
01:52:39 <bitonic> is it the tournament thing?
01:52:40 <Cale> fingertree-psqueue is a quick hack that I did in one day
01:52:43 <Cale> yeah
01:52:47 <sgronblo> Like what if you could just define a f (Positive x) = something instead of having to do f x | x < 0 = error "no negative values plz"
01:53:02 <Cale> and the fingertree version is indeed slower
01:53:13 <Cale> sgronblo: Wouldn't work
01:53:23 <Cale> sgronblo: because Positive t is not the same type as t, for one
01:53:38 <Cale> sgronblo: and secondly, it doesn't *enforce* the constraint that the thing is positive
01:54:11 <Cale> newtype Positive a = Positive a deriving ( Eq, Ord, Show, Read, Num, Integral, Real, Enum )
01:54:18 <Cale> instance (Num a, Ord a, Arbitrary a) => Arbitrary (Positive a) where
01:54:18 <Cale>   arbitrary =
01:54:18 <Cale>     (Positive . abs) `fmap` (arbitrary `suchThat` (/= 0))
01:54:18 <Cale>   shrink (Positive x) =
01:54:18 <Cale>     [ Positive x'
01:54:19 <Cale>     | x' <- shrink x
01:54:21 <Cale>     , x' > 0
01:54:23 <Cale>     ]
01:54:28 <Cale> (sorry for paste)
01:54:43 <Cale> That's the entire source code related to Positive in QuickCheck
01:56:07 <Cale> It just implements  arbitrary  a little differently -- by ensuring that the generator doesn't give 0 (using suchThat, which will re-roll the generator until the condition is satisfied), and then taking the absolute value, and wrapping the result in Positive
01:56:15 <Cale> we could also write that as
01:56:34 <danr> Cale: there's a bug in that code :)
01:56:37 <Cale> arbitrary = do x <- arbitrary `suchThat` (/= 0); return (Positive (abs x))
01:56:38 <danr> > abs (minBound :: Int)
01:56:39 <lambdabot>   -9223372036854775808
01:57:12 <sgronblo> Ok, I can understand your explanation but not the code :)
01:57:44 <sgronblo> What is the shrink for btw? Is that for creating a smaller input that still violates a property?
01:57:54 <t7> @type lift
01:57:55 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
01:57:59 <Cale> yeah, for making smaller things to also try, once a counterexample is found
01:58:27 <Cale> QuickCheck will do random tests until it finds something which fails, and then it starts trying shrinks
01:58:35 <Cale> of the failing case
01:58:55 <Cale> and it does that recursively until it can't find anything smaller which still fails
01:58:57 <sgronblo> So in this case how is it shrinking it
01:59:24 <sgronblo> That's a list comprehension or?
01:59:27 <Cale> yes
01:59:44 <Cale> shrink (Positive x) = [Positive x' | x' <- shrink x, x > 0]
02:00:17 <Cale> so it just removes anything which isn't positive from the list of shrinks on the original type
02:00:32 <Cale> and wraps the results in the Positive data constructor
02:01:01 <sgronblo> Ok, so it would have created a set of shrunk Ints for example if it was a Positive Int?
02:01:04 <Cale> yeah
02:02:06 <sgronblo> "Produces a (possibly) empty list of all the possible immediate shrinks of the given value." What is an immediate shrink?
02:02:52 <Cale> Well, the instances decide that, but they're going to be the next things which are tried when we find a failing test case.
02:03:11 <Cale> and then if one of the shrinks also fails the test, we try its shrinks
02:03:38 <sgronblo> What I don't really get is if you find one random element that happens to violate a property how can you make more elements with the same properties that caused the property to be tested to fail?
02:03:54 <Cale> You can't -- it's just guessing and trying.
02:03:59 <mbuf> if a URL returns an option to download and save a .csv file instead of returning the csv content in the body of the request, how can I download, and parse the csv file?
02:04:08 <Cale> shrink specifies what to guess
02:04:28 <Cale> based on an already failing test case
02:04:44 <Cale> and arbitrary specifies how to guess when we have no knowledge yet
02:05:14 <sgronblo> Well let's say we would be generating addresses or something would the shrink for an Arbitrary address then try to generate a set of other addresses with like same country, same city, same length of country name, same length of city name etc?
02:05:59 <Cale> sgronblo: It's hard to imagine how to make an address "simpler"
02:06:22 <Cale> sgronblo: so in that case, it might just omit various parts of the address, or use smaller street numbers or something
02:06:39 <sgronblo> Ah yeah we're talking about making something simpler yeah, not about figuring out the subset of the Arbitrary that causes the property to fail.
02:07:50 <Cale> Yeah, it's just trying to make the failing test case simpler, so that the user is presented with something nicer sometimes than the first testcase which was found to fail
02:08:00 <sgronblo> Where can I see how Arbitrary Int is shrunk?
02:08:27 <Cale> http://hackage.haskell.org/packages/archive/QuickCheck/2.4.2/doc/html/src/Test-QuickCheck-Arbitrary.html#Arbitrary
02:08:46 <Cale> Search for Arbitrary Int, and you'll see that it uses  shrinkIntegral  (which is polymorphic)
02:09:08 <Cale> and then search for shrinkIntegral, and you'll see what it tries
02:09:24 <Cale> shrinkIntegral x = nub $ [ -x | x < 0, -x > x ] ++ [ x' | x' <- takeWhile (<< x) (0:[ x - i | i <- tail (iterate (`quot` 2) x) ])]
02:10:09 <HugoDaniel> ouch
02:10:09 <Cale> where << is defined there as something like  abs a < abs b
02:10:10 <HugoDaniel> :)
02:10:22 <Cale> (but it tries to avoid overflow in that case)
02:10:41 <Cale> So it tries to negate x if it's negative
02:10:45 <Cale> (to make it positive)
02:11:05 <sgronblo> That's a long expression
02:11:05 <Cale> and it tries dividing x by 2 a bunch
02:11:16 <Cale> and subtracting the results from x
02:11:59 <sgronblo> So basically trying to generate smaller numbers but in a bit more clever way than [-x..x]
02:12:13 <Cale> ghci> shrink 32768
02:12:14 <Cale> [0,16384,24576,28672,30720,31744,32256,32512,32640,32704,32736,32752,32760,32764,32766,32767]
02:12:52 <Cale> yeah
02:12:58 <sgronblo> ah cool
02:13:16 <t7> > shrink 512
02:13:17 <lambdabot>   Not in scope: `shrink'
02:13:23 <t7> hax
02:13:26 <Cale> ghci> shrink 512
02:13:26 <Cale> [0,256,384,448,480,496,504,508,510,511]
02:13:30 <ocharles> i imagine that was a copy and paste :)
02:13:37 <Cale> It was
02:13:38 <ocharles> unless cale is his own repl
02:13:46 <Cale> That is a good idea though
02:13:50 <Cale> XChat plugin :)
02:14:44 <Cale> ghci> shrink (-512)
02:14:44 <Cale> [512,0,-256,-384,-448,-480,-496,-504,-508,-510,-511]
02:16:13 <sgronblo> Hmm, so f x:xs doesn't match a list with only one element?
02:16:25 <merijn> sgronblo: It does
02:16:33 <Cale> You probably mean f (x:xs)
02:16:36 <mux> no, it matches a list with at least one element
02:16:37 <merijn> sgronblo: xs can be []
02:16:44 <Cale> f x:xs means (f x):xs
02:16:48 <mux> he said "only one element"
02:17:02 <MaskRay> what does the defaulting shrink mean?
02:17:20 <sgronblo> Ah yeah I meant f (x:xs)
02:17:24 <Cale> MaskRay: hm?
02:17:31 <MaskRay> it does not make much sense to me
02:17:42 <sgronblo> So should it match or not?
02:17:46 <MaskRay> or too abstruse
02:18:08 <Cale> MaskRay: Well, it generates a reasonable sampling of numbers between n/2 and n-1
02:18:10 <sgronblo> mux and merijn seem to claim different things
02:18:21 <Cale> MaskRay: as well as 0, and if the number is negative, its positive friend
02:18:29 <mauke> sgronblo: no
02:18:43 <mauke> sgronblo: your question was ambiguous
02:18:44 <merijn> sgronblo: No, you just parsed my response wrong
02:19:00 <merijn> sgronblo: "It does" refers to "f (x:xs) does match a list with only one element"
02:19:00 <Cale> MaskRay: remember, the goal is just to try a bunch of things which might also fail the test, but which will be smaller or simpler than the failing case we found
02:19:24 <merijn> English is terribly ambiguous for backreferencing
02:19:34 <Cale> MaskRay: if none of the shrinks fails the test, we just give up and report the one we found to fail
02:19:43 <mux> yeah, your question could be interpreted in two different ways, that's all
02:19:52 <Cale> MaskRay: Otherwise, the first one which fails, we take it and try to shrink it more
02:20:39 <Cale> (this can suck if your test is expensive, but there's a newtype wrapper to prevent shrinking)
02:20:39 <MaskRay> Cale: i see. so there is no one-size-fit-all approach, any reasonable one is selectable
02:20:44 <Cale> yeah
02:20:51 <Cale> But this one has some nice properties
02:21:07 <Cale> It doesn't produce anything which is in between n/2 and 0
02:21:19 <Cale> because it'll get (some of) those on the next shrink
02:21:23 <t7> http://chrisdone.com/hj/ <- i like this approach to translating haskell, but it does mean having to write implementations of standard monads/functions like State et al :(
02:21:59 <Cale> it tries to make things positive when it can, which is nice because thinking about negative numbers when we don't have to is sometimes annoying
02:23:12 <Cale> and it tries the small magnitude things first (after maybe trying abs x and then 0), which means that if the thing fails on lots of small numbers, it won't take too many shrinks to work its way down
02:24:00 <Cale> (it'll basically divide by 2 a bunch until it can't anymore, and then be a little more gentle about it)
02:25:39 <Cale> also, it always has n-1 in the list
02:25:52 <MaskRay> it tries to seek to a position (half) first and moves towards the original number if the test passes
02:25:52 <Cale> (or n+1 in the case of a negative number)
02:26:00 <Cale> yeah
02:26:39 <MaskRay> quite reasonable
02:26:48 <Cale> which means that if the property fails for all sufficiently large numbers, it'll find the exact smallest case
02:27:29 <Cale> (well, I mean, if it fails for all numbers larger than n, say, and passes for all smaller ones)
02:28:46 <Cale> ghci> quickCheck (< 56)
02:28:47 <Cale> *** Failed! Falsifiable (after 70 tests and 2 shrinks):
02:28:47 <Cale> 56
02:29:14 <Cale> It seems like the Arbitrary instance for Integer doesn't try very large values
02:29:53 <Cale> (well, it's sized, but it doesn't get to very large sizes in 100 tests, at least)
02:30:45 <Cale> arbitrarySizedIntegral = sized $ \n -> let n' = toInteger n in fmap fromInteger (choose (-n', n'))
02:31:09 <ennui> i'd like to build a function that takes two arbitrary functions of the same type plus a tuple of parameters and calls both functions to check if they return the same value. this seems to be too high-order for the type system. what's the workaround?
02:32:21 <Cale> Well, what would you be using that for?
02:33:05 <ennui> to stochastically check a huge list of function pairs if they are equivalent.
02:33:22 <Cale> So you know how many parameters they have
02:35:22 <ennui> is_same f f' (a b c) && is_same g g' (a b) && is_same h h' (b c d e)   <<  i'd like to use the function like this
02:35:39 <navaati> hi
02:35:39 <Cale> So a is a function
02:36:51 <Cale> or it's meant as a parameter to f?
02:36:56 <ennui> for the first call to is_same: if f :: a -> b -> c -> d then (a b c) :: (a b c)
02:36:58 <Cale> and you wrote the tuple without its commas?
02:37:08 <ennui> oh sorry, i forgot the commas
02:37:22 <ennui> (a, b, c)
02:37:32 <Cale> Well, if you uncurry f and f' first
02:37:36 <Cale> then you could just write
02:37:47 <Cale> isSame f f' x = f x == f' x
02:38:36 <Cale> another option is just writing separate versions for the few different numbers of parameters you have
02:38:49 <Cale> isSame2 f f' (x,y) = f x y == f' x y
02:38:58 <Cale> isSame3 f f' (x,y,z) = f x y z == f' x y z
02:39:15 <Cale> and then you're probably done, maybe write isSame4 :)
02:40:27 <ennui> so there's no universal currying that unpacks n-tuples?
02:40:31 <Cale> There's probably some typeclass hackery you could write to make this happen automatically, but realistically, this is a lot simpler.
02:40:47 <mauke> ennui: there are no universal n-tuples
02:40:59 <Cale> Each tuple type is separate
02:41:15 <Cale> Each length of tuple is a completely separate type constructor and data constructor
02:41:15 <Jacco> is there anybody here that has had some experience with GLFW for opengl?
02:41:40 <ennui> yes. so i'm left to repeating myself for each possible function arity.
02:41:52 <frontendloader> vim with auto-indenting set seems to screw up on lines that end in a paren
02:41:56 <frontendloader> tails x = x : (tails . tail $ x)
02:42:13 <frontendloader> results in the next line being indented
02:42:15 <ennui> generalizing that would be too complicated?
02:42:34 <Cale> More or less. I'm sure you could get something with typeclass hackery which would let you write  isSame f f' x y  when f and f' were functions of two parameters whose result was then Eq-able
02:42:46 <Cale> but there would be instance overlap
02:42:49 <sgronblo> Ok, next quickcheck problem... How can I restrict my [String] elements to be shorter than a certain length?
02:43:07 <Tinned_Tuna> sgronblo: length xs < n ==>  will do it
02:43:09 <Cale> because there's no way to ensure that function types aren't instances of Eq, basically (and they might very well be)
02:43:19 <ennui> Cale: ok, got it. thanks for helping me out!
02:43:20 <Tinned_Tuna> but you'll throw away a lot of your strings, you'd be better off using a generator.
02:44:00 <Tinned_Tuna> or, alternatively, convert any [String] you're given to one of a shorter length using take n xs
02:44:06 <Cale> ennui: So, there are other things you could do, but they're fancy, and this is much simpler.
02:44:10 <alpounet> sgronblo, you could get an arbitrary number between 1 and some n, and then give that to some generator that generates a string of the length you just got
02:44:37 <alpounet> or what Tinned_Tuna said, yes hah
02:44:40 <sgronblo> So I gotta umm do something like instance Arbitrary [String] where arbitrary = something produces a list with only strings of this length?
02:44:56 <Cale> sgronblo: you can't write a new instance of Arbitrary for [String]
02:45:01 <Cale> because one already exists
02:45:12 <Cale> but you can use  forAll  to plug in a new generator
02:45:29 <Cale> (which it'll use instead of the arbitrary for [String])
02:45:40 <sgronblo> Yeah that sounds the easiest, if I knew how to use it.
02:45:43 <Tinned_Tuna> sgronblo: what Cale said, but yes using Arbitrary would work "best", but if you just want to modify an existing test, it may not be best.
02:46:14 <Tinned_Tuna> sgronblo: prop_length_restricted xs = my_test xs' where xs' = take n xs
02:46:42 <Tinned_Tuna> if you want it to have a more dynamic length restriction, you'll have to use the generator.
02:48:24 <sgronblo> Whee, it worked.
02:48:48 <Cale> ghci> quickCheck $ forAll (fmap (map (take 10)) arbitrary) (all (\x -> length x <= 10))
02:48:48 <Cale> +++ OK, passed 100 tests.
02:48:58 <Cale> you can combine the approaches :)
02:49:05 <sgronblo> I just did a where truncatedStrings = map (take lineSize) strings
02:49:13 <Cale> yeah
02:49:16 <Tinned_Tuna> Cale: why you so godly at haskell?
02:49:17 <Cale> quite reasonable
02:49:37 <sgronblo> Well this was an interesting exercise
02:49:47 <Cale> Tinned_Tuna: I started in 2001, and have been programming in very little else since 2002 or so
02:49:51 <merijn> Tinned_Tuna: He was trained by monks in a monastery in the Himalaya
02:50:02 <merijn> Cale: I like my background story better :)
02:50:08 <Tinned_Tuna> Cale: what's your profession ?
02:50:13 <sgronblo> I still would like to eventually try to use quickCheck to verify some stuff that's more business logicish.
02:50:18 <Cale> I'm a Haskell programmer.
02:50:19 <Tinned_Tuna> merijn: those monks where Hutton and Peyton-Jones ;-)
02:50:41 <Tinned_Tuna> Cale: lucky :-) Freelance or permanently employed somewhere?
02:50:55 <sgronblo> And se if it's better than the current kinda crappy testing I do at work with Rails.
02:50:56 <Cale> Working for a startup (iPwn Studios) on a game for iPhones and other mobile devices.
02:51:11 <merijn> Cale: That sorta thing always gets me wondering, why do people refer to themselves as X programmers? I always just think of myself as a programmer, regardless of language...
02:51:18 <Tinned_Tuna> sgronblo: I envy Ruby/Rails testing (from Java)
02:51:51 <Tinned_Tuna> though , I've only every seen it written, I've not seen it "in action" myself. But I've had a look over the Diaspora code base, and the tests seem to be broadly very nice.
02:51:56 <Cale> merijn: Well, I'm a mathematician first, and if I didn't get to program in Haskell or a handful of other languages that are acceptable to me, I wouldn't do it.
02:51:57 <sgronblo> I think we had slightly less disfunctional testing on the Java project I worked on at my previous company
02:52:33 <Tinned_Tuna> sgronblo: I think ruby's test framework makes it a tad easier to make lots of tests quickly.
02:52:53 <sgronblo> That's not our problem either :)
02:53:02 <Cale> Basically, I refuse to program in anything without first class functions and a good type system.
02:53:03 <Tinned_Tuna> Although, I did stumble upon something nice in TestNG recently, it looks like you can do things similar to quickCheck's generators using TestNG
02:53:09 <sgronblo> The problem is that our test suite takes way too long to run already
02:53:15 <sgronblo> And it isn't getting any faster
02:53:46 <sgronblo> And we have a lot of logic tests that basically call a controller, retrieve data from database, spit out html, parse html to see if the right values are there... facepalm
02:54:03 <Cale> (though I can program in lots of other stuff, I'd probably try to find employment in another industry before taking a job writing Java code, say)
02:54:23 <sgronblo> When the thing that is really being tested is the transformation/logic applied to the data retrieved from the database.
02:54:35 <Tinned_Tuna> Cale: Java's not that bad, you just have to accept programming tied up, effectively.
02:55:04 <HugoDaniel> the feature i like most in haskell are nested multi-line comments
02:55:07 <HugoDaniel> killer feature
02:55:18 <sgronblo> Yeah I hate PHP and bash scripting much more than Java
02:55:52 <Tinned_Tuna> sgronblo: did you see the huge list of PHP greivances that went round reddit and news/ycombinator recently?
02:55:56 <QF-MichaelK> are there haskell browser based games out there?
02:55:57 <sgronblo> Yeah
02:56:06 <Cale> We've understood how to implement first class functions efficiently for at least 20 years, if not longer, and we've understood their importance to programming for longer than electronic computers were around.
02:56:08 <t7> :t let fix f = f (fix f) in fix
02:56:10 <lambdabot> forall t. (t -> t) -> t
02:56:21 <sgronblo> I've cringed at a lot of them myself too
02:56:40 <Fisix_AIX> Hello, how would this http://fpaste.org/TuuY/ be written in haskell ?
02:56:58 <HugoDaniel> Cale++
02:57:13 <mauke> Fisix_AIX: that program does nothing
02:57:30 <sgronblo> Has anyone here used quickcheck for some sort of "web app" though. As in the kind of app people would be using Rails for.
02:57:34 <Fisix_AIX> mauke, I know
02:57:41 <Cale> Fisix_AIX:   main = return ()
02:57:42 <navaati> i've to deal a lot with foreign APIs based on a sort of object oriented model using object ids. Which is the nicest translation in haskell of this kind of APIs ?
02:57:43 <mauke> Fisix_AIX: main = return ()
02:57:56 <Tinned_Tuna> Fisix_AIX: Do you need count to just be 1000000? If so, why not just let count = 1000000]
02:57:57 <sgronblo> I'm curious about how well it works for creating more advanced things than just ints and lists and so on.
02:58:42 <sgronblo> It seems like it has the potential to uncover some problems that would be difficult to figure out to write a specific test case for.
02:59:27 <Cale> count = head (takeWhile (< 100000000) (iterate (+1) 0))
02:59:38 <Cale> er, oops
02:59:41 <Cale> dropWhile :)
02:59:47 <Cale> count = head (dropWhile (< 100000000) (iterate (+1) 0))
03:00:59 <Fisix_AIX> Cale, Thanks
03:01:14 <sgronblo> But yeah so far I've only seen these kind of demonstrational toy examples for quickCheck.
03:01:20 <Cale> It takes my machine 2.5 seconds to print count
03:01:23 <nonefool_> how would one write a rewrite rule to replace a function on a data familiy Foo r with a specific function on Foo Double ? the rules I tried to write don't fire
03:01:25 <Cale> (after compiling with -O2)
03:02:48 * magicman shudders at his BASIC days when making more and more ridiculous FOR loops was *the* way to pause the machine for a bit.
03:03:17 <Tinned_Tuna> mmmm, the world's most inefficient sleep()
03:03:54 <magicman> Eventually, I started to use PLAY "p8". Which is better, but not really :p
03:04:10 <magicman> I'm still not sure if there was an *actual* sleep()-like thing. I know I never used it.
03:05:22 <navaati> i remember having looked for it and not finding it. Maybe there was a way to do syscall in basic…
03:05:29 <Tinned_Tuna> I have a PIC book which recommends using ridiculous loops for wait.
03:05:40 <navaati> (is sleep() a syscall ?)
03:05:47 <mauke> usually, no
03:05:58 <earthy> it *really* depends.
03:06:27 <mux> it will end up calling a syscall
03:06:38 <navaati> Tinned_Tuna: yeah, PIC are horrible : the timer cannot awake the chip from sleep state, so…
03:06:41 <earthy> sleep(3) *may* be implemented using alarm(2)
03:06:44 <mux> it's usually the kernel's job to a process to sleep
03:06:45 * hackagebot edenmodules 1.1.0.0 - Semi-explicit parallel programming library  http://hackage.haskell.org/package/edenmodules-1.1.0.0 (MischaDieterle)
03:07:03 <mauke> I just thought about that
03:07:05 <mux> sleep(3) will end up calling nanosleep(2) on FreeBSD
03:07:22 <mauke> sleep via alarm is more complicated than it looks
03:08:01 <navaati> what are the FRP libs currently alive ?
03:09:29 <HugoDaniel> navaati: elerea
03:10:00 <HugoDaniel> its simple and works nicely for most use cases
03:11:21 <navaati> hum, seems more complicated than yampa, but i'll check
03:11:57 <navaati> is animas an alive project ?
03:16:01 <danr> navaati: I would say elerea is quite a lot simpler than Yampa
03:21:29 <Cale> Sodium is alive
03:21:52 <QF-MichaelK> Na...
03:22:02 <Cale> It's not what we're using at iPwn, but it's by one of us :)
03:22:59 <navaati> so there are : elerea, animas, sodium, reactive-banana, netwire (is it alive ?)… will be difficult to make a choice…
03:23:12 <shachaf> Does this so-called "iPwn" actually exist?
03:24:04 <mm_freak_> navaati: from the choice between elerea, animas, reactive-banana and netwire i can only recommend reactive-banana and netwire
03:24:05 <Cale> It does
03:24:33 <Cale> and yeah, we're still working on this game engine :)
03:24:46 <navaati> reactive-banana is applicative-style and netwire is arrow-style, right ?
03:25:06 <mm_freak_> navaati: both are applicative-style
03:25:30 <mm_freak_> netwire has arrowic instances, too, though
03:25:31 <Cale> It's been kind of a crazy project, making FRP work well enough to do it on an iPhone, as well as constructing an action RPG with some collision physics in it. :)
03:26:15 <Cale> and we're still not quite there yet, but we've been making steady progress
03:27:37 <QF-MichaelK> Any demo's screenshots of the progress?
03:27:42 <QF-MichaelK> wow ' fail
03:28:50 <QF-MichaelK> Cale: ?
03:30:37 <Cale> I don't have any current ones on hand, and I'm not sure if I'm meant to be releasing things like that :)
03:30:47 <Cale> We would like to get some more of the artwork onto the website
03:31:00 <t7> Cale is this a startup or something?
03:31:11 <Cale> but we'd need a web person for that, the rest of us are busy with other stuff :)
03:31:20 <Cale> t7: yeah
03:31:35 <QF-MichaelK> What sort of web stuff do you need done?
03:31:36 <t7> how much investment have you secured ?
03:31:50 <mm_freak_> Cale: if you want a yesod guy, /msg me =)
03:31:55 <Cale> t7: I don't know
03:32:14 <t7> im not sure my sentence was well formed
03:32:30 <Cale> Personally, I'm not involved in the financials of the company
03:33:30 <QF-MichaelK> Also, Cale, I've been meaning to ask you: Do you do Project Euler challenges?
03:33:42 <Cale> QF-MichaelK: I've done a few
03:33:57 <merijn> Cale: The resulting code would be an interesting Haskell case study, although I guess publishing the code of a for-profit game isn't very likely to happen
03:34:18 <QF-MichaelK> quake did it
03:34:26 <Cale> merijn: Well, we hope to cut out some useful generic bits and release them
03:34:47 <merijn> QF-MichaelK: Personally I think Project Euler challenges are overrated as programming challenges/exercises. I would actually argue they're downright bad for that purpose
03:35:01 <Cale> Like, at the very least, our redesign of the Arrow hierarchy
03:35:06 <QF-MichaelK> merijn: what would you recommend instead?
03:35:44 <shachaf> merijn: You should put your argument on the wiki and in @where so people don't have to repeat it over and over again. :-)
03:36:32 <merijn> QF-MichaelK: They're more useful for practicing math tricks then useful programming. They focus mostly on numeric knowledge than on actual program structuring knowledge
03:36:56 <danr> merijn: agreed!
03:37:04 <merijn> QF-MichaelK: TheDailyWTF had a bunch of challenges that were more suited, let me see if I can find a link
03:37:55 <mm_freak_> while i don't think the PE exercises are particularly useful for learning haskell, they do give some insight into algorithm writing in haskell
03:38:17 <ment> swimming is a good excersise
03:38:25 <mm_freak_> from them i learned how to construct an array/vector lazily instead of going through the trouble of iterating in ST
03:38:58 <mauke> http://www.spoj.pl/
03:39:26 <frontendloader> online judges are all about edge cases and formatting
03:39:56 <mauke> oh shit, someone managed to pull even on http://www.spoj.pl/ranks/BRAINF_K/
03:40:16 <mm_freak_> "Haskell (ghc 6.10.4)"
03:40:21 <mm_freak_> quite outdated
03:40:59 <merijn> QF-MichaelK: Hmm, I can't find it again now. I guess I would say the simplest things is to write simple commandline tools and work up from there
03:41:02 <mauke> good enough
03:41:44 <merijn> QF-MichaelK: One of the first things I wrote (learning python) was something to rename all my mp3s/video automatically based on a regex, fixing numbering and those sorts of things
03:42:47 <linduxed> i was wondering what the "normal" way is to format this code across multiple lines:  data Point = Point { xVal :: Double, yVal :: Double, name :: String } deriving (Show)
03:43:13 <linduxed> should i get the commas at the start of the line?
03:43:29 <linduxed> should the last bracket be indented to the height of the commas in that case?
03:43:30 <mm_freak_> linduxed: use whatever style you like most
03:43:37 <linduxed> mm_freak_: hmmm, ok then
03:43:51 <merijn> linduxed: I line break after {, indent everything once, comma at the end of line and then dedent the last bracket. I know others use the , first style, but that confuses my C reflexes
03:44:06 <mm_freak_> linduxed: intentionally there is no real standard…  the standard is to write code as readable as possible
03:44:53 <linduxed> merijn: yeah that was my thought, although the commas-first-no-dedent-last-bracket looks nice too
03:45:02 <linduxed> mm_freak_: i guess that's a good point
03:45:32 <mm_freak_> i find that style confusing as hell…  i prefer the same as merijn
03:45:40 <QF-MichaelK> merijn: Hm, seems like good advice, I was hoping to prepare myself for going into something like a masters in CS/Physics/Math
03:46:00 <blackdog> linduxed: i rather like that one, just because you can cut and paste any line without extra editing.
03:47:03 <mm_freak_> blackdog: not any more than with the other style
03:47:07 <merijn> QF-MichaelK: Ha, you're learning haskell. You're already overqualified for starting ;p
03:47:11 <merijn> QF-MichaelK: Oh, I found the code challenges I meant: http://thedailywtf.com/Series/Bring_Your_Own_Code.aspx
03:47:19 <mm_freak_> blackdog: you can't cut/paste the first line
03:47:26 <mm_freak_> with the other style you can't cut/paste the last line
03:48:07 <mm_freak_> i wish there was an indentation-based record syntax
03:49:05 <merijn> QF-MichaelK: Seriously, I learned more (well, maybe about as much) during two years of hanging out here as I did during 2 years of CS master (and I went to a university I still consider good)
03:50:05 <QF-MichaelK> merijn: To be honest, I'm more of a Haskell fanboy at this point.  Thanks for the link, these look much more reasonable than the Euler challenges
03:50:36 <merijn> QF-MichaelK: Just working through Learn You a Haskell will get you quite far too
03:51:09 <QF-MichaelK> merijn: Yeah I've been working with that, it's pretty amazingly written.
03:51:31 <merijn> Another exercise (scroll carefully, the solutions is spoiled immediately below the question!) is: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
03:52:50 <merijn> That one is good because it's a nice no nonsense intro to monads without making them seem all complicated
03:54:20 <t7> @hoogle (x, y) -> m z -> m (x, y, z)
03:54:21 <lambdabot> Data.Graph.Inductive.Graph inn :: Graph gr => gr a b -> Node -> [LEdge b]
03:54:21 <lambdabot> Data.Graph.Inductive.Graph out :: Graph gr => gr a b -> Node -> [LEdge b]
03:54:53 <bitonic> merijn: dan piponi is great
03:55:00 <QF-MichaelK> merijn: This is perfect, thank you.  I have to come hang out here more often... *falls for Haskell again*
03:55:34 <t7> :t f (x, y) mz = fmap (\z -> (x, y, z)) mz
03:55:35 <lambdabot> parse error on input `='
03:55:44 <t7> :t \f (x, y) mz -> fmap (\z -> (x, y, z)) mz
03:55:46 <lambdabot> forall t t1 t2 a (f :: * -> *). (Functor f) => t -> (t1, t2) -> f a -> f (t1, t2, a)
03:55:49 <t7> :t \(x, y) mz -> fmap (\z -> (x, y, z)) mz
03:55:50 <lambdabot> forall t t1 a (f :: * -> *). (Functor f) => (t, t1) -> f a -> f (t, t1, a)
03:57:40 <t7> :t \(x, y) mz -> fmap (\z -> (x, y, z)) (mz :: StateT Int Maybe Int)
03:57:42 <lambdabot> forall t t1. (t, t1) -> StateT Int Maybe Int -> StateT Int Maybe (t, t1, Int)
03:59:37 <t7> haskell is like a puzzle
04:00:01 <t7> solve the puzzle before you are allowed to compile and have a coffee
04:00:03 <mm_freak_> do lambda bindings share like 'let'?
04:00:18 <mm_freak_> i.e. (\x -> f x x) complicatedExpr
04:00:29 <Cale> yes
04:00:41 <mm_freak_> great
04:00:59 <Cale> That's what makes lazy evaluation different from outermost-first evaluation
04:01:55 <mm_freak_> Cale: as far as i see, lazy evaluation doesn't imply that the expression is evaluated only once in a compiled language
04:05:59 <t7> bitonic: are you there :3
04:08:25 <Cale> mm_freak_: lazy evaluation is outermost first evaluation with the additional feature that whenever a bound variable occurs more than once in its scope, any evaluation done to the expression it's bound to is shared between the occurrences
04:08:28 <rks063> hello everyone
04:08:59 <rks063> is there any irc channel where softwares are provided for download
04:09:17 <Cale> rks063: You mean like GHC? You can get it from the web
04:09:35 <Cale> http://hackage.haskell.org/packages/archive/pkg-list.html and most other things from here
04:09:56 <mm_freak_> Cale: i can't confirm that…  in an AST-manipulating evaluator this is unlikely to be what happens
04:10:02 <angstrom> is there an arrow that does something like `both f = \(x, y) -> (f x, f y)'?
04:10:48 <mm_freak_> angstrom: f *** f
04:10:57 <Cale> mm_freak_: Well, if it has to remain a tree (not a graph), then you can just beta reduce lambdas by transforming them into let
04:11:01 <angstrom> mm_freak_: fair enough
04:11:06 <fmap> join (***)
04:11:18 <danr> @type join (***)
04:11:18 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
04:11:40 <Cale> (\x -> x * x) (5 + 5) -> let x = 5 + 5 in x + x
04:11:41 <hpaste> mbuf pasted “No output” at http://hpaste.org/68001
04:12:09 <mbuf> the URL returns an option to download a .csv file instead of the contents of the .csv file
04:12:26 <mbuf> how can I read the file contents or atleast download it for processing?
04:12:29 <mm_freak_> that would be quite possible, although i wouldn't introduce a let statement just for that
04:19:13 <applicative> mbuf isn't the trouble that its  https ?
04:19:59 <mbuf> applicative: when I use the URL on the browser, it gives an option to download and save the file; anything to be changed for the https?
04:20:24 <merijn> mbuf: The webserver is serving the wrong MIME-type and its confusing your browser
04:20:42 <applicative> but curl "https: blah" is giving me the lines about ghc agda
04:20:56 <mbuf> merijn: I see
04:20:57 <bitonic> t7: yes
04:21:10 <bitonic> actually, yes :3
04:21:59 <applicative> to do https I think you need something other than Network.HTTP, e..g  HTTP.Conduit
04:22:03 <mbuf> applicative: yes, curl on the terminal works
04:22:36 <merijn> mbuf: You could check what MIME-type your browser is getting (I'm assuming your browser has some way to inspect the response headers) and then add that MIME-type to the ones opened by your browser
04:22:48 <mbuf> merijn: I see
04:22:58 <t7> haha im trying todo mutualy recursive let bindings like: Let [(Id, Exp)] Exp .  Have you tried something like that?
04:23:49 <bitonic> t7: no
04:24:16 <bitonic> and I don't understand what you mean with `Let [(Id, Exp)] Exp'
04:25:12 <t7> like let x = 1; y = 2; in x
04:25:15 <applicative> > let a = 1; b = 2 ; c= 3 in a + b
04:25:16 <lambdabot>   3
04:25:39 <t7> but i want todo let x = 1; y = x + 2; in y + 3
04:26:10 <mm_freak_> t7: why don't you just add a fixed point combinator?
04:26:18 <mm_freak_> i have no let statements at all in my language
04:26:27 <t7> mm_freak_: i have a Rec
04:26:35 <t7> but i still cant do mutual recursion
04:28:31 <merijn> How do I compose lenses from data-lens? (^.) and (^$) only work if I directly pass in a value...
04:28:34 <mm_freak_> you can…  it's just not trivial =)
04:28:41 <mm_freak_> merijn: Control.Category
04:28:57 <merijn> mm_freak_: I have a feeling that is going to make me sad...
04:29:23 <mm_freak_> merijn: why?  it's a natural way to compose lenses
04:29:41 <merijn> mm_freak_: In the sense of I dunno how to use it :p
04:29:54 <merijn> And everything with Category in it tends to make me cry
04:31:59 <mbuf> merijn: applicative I tried using Network.HTTP.Conduit with main = simpleHttp reqString >>= L.putStr and got "HandshakeFailed (Error_Protocol ("certificate has unknown CA",True,UnknownCa))"
04:32:00 <merijn> Oh, wait. I can get away with "import Control.Category ((.))" and hiding Prelude..?
04:35:36 <bitonic> t7: wait what you cited is not mutual recursion
04:35:48 <HugoDaniel> hackage is slow
04:35:51 <bitonic> (let x = 1; y = x + 2; in y + 3)
04:36:46 <t7> let x = y; y = x; in x
04:36:55 <bitonic> t7: ok, that's something different
04:37:02 <t7> bitonic: i was just pointing out that order didnt matter
04:37:27 <t7> but i didnt even get that right :)
04:37:37 <bitonic> t7: it's just a matter of scanning the file before for let bindingd, assigning them the most general type, and then refining it
04:37:45 <bitonic> and that should be fine
04:37:57 <t7> yeah im adding fresh variable for each binding
04:38:13 <t7> then infer each one, and then unify or something
04:38:16 <t7> il figure it out
04:38:24 <bitonic> good luck
04:38:30 <mm_freak_> merijn: usually you would want to import Control.Category and import Prelude hiding ((.), id)
04:39:18 <madjestic> hey, Cale is there a site for the project?  I assume you are working on some game project, right?
04:40:08 <aristid> @hoogle swap
04:40:09 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
04:40:09 <lambdabot> Control.Concurrent.MVar swapMVar :: MVar a -> a -> IO a
04:40:09 <lambdabot> Graphics.UI.GLUT.Window swapBuffers :: IO ()
04:40:24 <Cale> yes, ipwnstudios.com, but our website is boring at the moment
04:41:46 <merijn> There's no left associative ($), right?
04:46:40 <madjestic> thanks, Cale.  That's inpiring
04:48:53 <t7> @hoogle s Either a -> s a
04:48:54 <lambdabot> Did you mean: s (Either s s) a -> s a
04:48:54 <lambdabot> Control.Monad.Trans.Identity runIdentityT :: IdentityT m a -> m a
04:48:54 <lambdabot> Control.Applicative unwrapMonad :: WrappedMonad m a -> m a
04:49:09 <t7> @hoogle s (Either e) a -> s a
04:49:10 <lambdabot> Did you mean: s (Either e s) a -> s a
04:49:10 <lambdabot> No results found
04:49:11 <hiptobecubic> Cale, it says you've been working on it for two years?
04:49:41 <Cale> hiptobecubic: I've been with them for less than that, but yeah.
04:50:09 <hiptobecubic> Cale, is that a normal time frame to produce a game? I don't know, I never have.
04:50:20 <Cale> I never have either
04:50:31 <merijn> @hoogle (a -> b) -> a -> b
04:50:32 <hiptobecubic> It seems long, although I realize you're bootstrapping yourselves up and not using any established tools.
04:50:32 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
04:50:32 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
04:50:32 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
04:50:45 <Cale> right
04:50:50 <hiptobecubic> :i ($!)
04:51:02 <merijn> hiptobecubic: That's just strict function application, I think
04:51:19 <hiptobecubic> merijn, ah, sure. ok
04:51:29 <merijn> 2 years seems short for a game (although I guess long for one for handheld devices)
04:52:11 <hiptobecubic> Cale, what about functional reactive programming "avoids many of the pitfalls, inefficiencies, and limitations that traditionally plague game development" ?
04:52:17 <merijn> Double Fine put their production time at 8 months for Double Fine Adventure and they're an experienced game studio developing a 2D adventure game. I imagine the time/complexity ramps up quickly from there
04:52:35 <Cale> hiptobecubic: well, it will, once we establish it :D
04:52:42 <bd874> is it possible to declare multiple variables in a let statement ?
04:52:46 <hiptobecubic> Cale, :D
04:52:51 <merijn> bd874: Sure
04:53:13 <hiptobecubic> Cale, I suppose I probably don't know enough about reactive programming OR the "traditional pitfalls" for you to have answered that anyway.
04:53:39 <bd874> then what is wrong with http://pastebin.com/cQpVTEJL ?
04:53:41 <mauke> The paste cQpVTEJL has been copied to http://hpaste.org/68002
04:54:18 <Cale> hiptobecubic: The problem is that while FRP is a great idea, nobody had ever implemented it in a really practical way for these sorts of applications before.
04:54:49 <merijn> bd874: Nothing, it works fine when I copy+paste it
04:55:19 <merijn> bd874: Do you use tabs?
04:55:36 <bd874> yes
04:55:42 <merijn> That's your problem
04:55:49 <bd874> ?
04:55:53 <merijn> tabs are 8 spaces so your indentation is wrong
04:56:17 <merijn> In other words (much like in python) don't use tabs
04:56:35 <hpc> or if you do use tabs, use them EVERYWHERE and in exactly the right way
04:56:44 <hpc> (but don't do that, do what merijn said)
04:56:53 <bd874> merijn: doesn't make a difference here
04:57:14 <earthy> replace each tab by 8 spaces, then fix the indentation.
04:57:19 <merijn> I literally copy and pasted the hpaste code and it runs immediately
04:58:11 <hpc> if you are in vim, you can do s/\t/        /g
04:58:25 <bd874> I useally :expandtab
04:58:40 <merijn> bd874: I will save you a lot of time
04:59:14 <merijn> bd874: https://github.com/merijn/dotfiles/blob/master/vimrc
04:59:18 <t7> @pl mapM (infer env') (map snd bs) >>= mapM (return . fst)
04:59:19 <lambdabot> mapM (return . fst) =<< mapM (infer env') (map snd bs)
04:59:24 <merijn> See the section labelled "tab specific settings"
05:00:09 <merijn> If you prefer a different indentation (i.e. more or less than 4) change the softtabstop and shiftwidth settings
05:01:20 <Botje> bd874: you can :set list to see spaces and tabs explicitly.
05:02:29 <t7> bitonic: this is harder than i thought
05:03:43 <bitonic> t7: is it?
05:03:59 <t7> maybe i should be translating
05:06:28 <magicman> Tabs are not 8 spaces. Tab stops are 8 characters apart, and a tab is enough spaces to reach the next nearest tab stop. <space><space><tab><code> will have <code> indented 8 spaces.
05:06:34 <magicman> (still don't use tabs, though <_<)
05:09:03 <merijn> magicman: The GHC compiler disagrees with you
05:09:10 <merijn> Which is all that matters in this context
05:09:22 <magicman> Then the GHC compiler should lrn2report >_> http://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-17800010.3
05:09:43 <merijn> On unrelated note, anyone know where I can find an example of combining State/Maybe using transformers?
05:10:54 <Cale> I wish the report and GHC just said that tab characters are a lexical error outside of comments
05:11:07 <merijn> Cale: Word.
05:11:32 <magicman> Aye.
05:12:11 * hpc wants to see the next revision of the report say tabs are one space
05:12:19 <hpc> and the next revision after that, 7 spaces
05:12:23 <hpc> and after that, 113
05:12:47 <magicman> Oh, and my code that's "main = stuff\n  where\n        stuff = print stuff2\n      \tstuff2 = 3 + stuff3\n \tstuff3 = 8\n" compiles just fine.
05:13:25 <magicman> (indentations per line are: 2 spaces before where, 8 spaces before stuff, 6 spaces and tab before stuff2, 1 space and tab before stuff3)
05:13:53 <fmap> @quote elliott yell
05:13:54 <lambdabot> elliott says: What do we do with people who paste code blocks on IRC? We yell at them.
05:14:10 <magicman> Admittedly, this is 7.0.4, though I doubt that has changed since then :p
05:15:11 <merijn> No nice transformer tutorial on combining State/Maybe? I saw some tutorials on monad transformers but they didn't really seem to cover what I want to know/do
05:15:32 <merijn> (Or weren't sufficiently clear/general for me to generalise from)
05:15:56 <bitonic> merijn: well once you know how to use monad transformers, you can simply use `StateT s Maybe'
05:16:08 <Tomsik> Why the tab hating?
05:16:22 <merijn> bitonic: Yeah, but I'm not sure I understand them (which I guess means that I don't)
05:16:50 <bitonic> merijn: ok, what did you read on monad transformers?
05:16:59 <Tomsik> merijn: perhaps just look on specific instances
05:17:11 <bitonic> tbh I'm not sure I have any good tutorial, I'm sure RWH covers them in a way or another
05:17:19 <merijn> The sigfpe post and the wikibook
05:17:27 <merijn> And at some point RWH too
05:17:29 <bitonic> merijn: isn't the sigfpe post for monads only?
05:17:50 <merijn> bitonic: http://blog.sigfpe.com/2006/05/grok-haskell-monad-transformers.html
05:18:23 <bitonic> oh ok, that post.
05:19:04 <marcot> Hi.  How can I define a class context for a type family?
05:19:36 <marcot> I have a type family which I want to use as a parameter of Data.Map, but ghc needs to know that the type that it's going to instantiate it is on class Ord.
05:19:56 <merijn> My basic problem is, I have "State (Maybe Foo) ()" and have code I want to run on Foo and up with "State Bar ()" and I'm not sure what the best way to proceed is
05:20:07 <bitonic> marcot: foo :: Ord (Bar a) => Map (Bar a) quux
05:20:25 <bitonic> merijn: no, you don't have `State (Maybe Foo) ()'
05:20:30 <bitonic> I mean
05:20:32 <bitonic> you can.
05:20:35 <magicman> Wait... The "Maybe Foo" is the type you use as state? That's not a Monad Transformer.
05:20:43 <bitonic> but that has nothing to do with monad transformers
05:20:49 <merijn> magicman: I don't have a transformer right now
05:20:51 <bitonic> you're just putting a Maybe value in the state
05:20:58 <magicman> Also, that was rather arbitrary capitalization, sorry <_<
05:21:08 <merijn> I was just looking whether I can remove/simplify my code using transformers
05:21:21 <hpc> The One True Monad Transformer? ;)
05:21:23 <bitonic> merijn: if you have something of that type, monad transformers won't help
05:21:30 <bitonic> unless you're doing something weird, paste the code
05:21:47 <merijn> bitonic: Actually I have a Map in my state and using focus to obtain an entry from that map (if present)
05:22:04 <merijn> (focus being one of the State API functions for lenses)
05:22:07 <hpc> @hoogle (s -> s') -> State s a -> State s' a
05:22:08 <lambdabot> Control.Monad.Trans.State.Lazy withState :: (s -> s) -> State s a -> State s a
05:22:08 <lambdabot> Control.Monad.Trans.State.Strict withState :: (s -> s) -> State s a -> State s a
05:22:08 <lambdabot> Control.Monad.State.Lazy withState :: (s -> s) -> State s a -> State s a
05:22:36 <marcot> bitonic: Sure, I didn't thought about putting the restriction on the function, I was planning to put it on the type family.  Thanks, this is perfect.
05:23:01 <bitonic> merijn: well I don't see why would you need a monad transformer there, it's better if you just paste the code :)
05:25:40 <merijn> The main problem is that I'm not entirely sure about the structure/implementation of the code :p
05:25:45 <hpaste> merijn pasted “blah” at http://hpaste.org/68003
05:28:50 <merijn> I need to do stuff in the undefined in move (at the bottom), but that requires a bunch of annoying "if isJust x then foo else bar" code and I will write more such functions
05:29:22 <merijn> Although I guess I could replace onJust (which I'm not really using at the moment) with a variation of maybe
05:30:41 <womb> :t (+)
05:30:42 <lambdabot> forall a. (Num a) => a -> a -> a
05:30:55 <womb> yeah this is pro when you can pass functions
05:31:02 <womb> i love first class functions
05:32:04 <ennui> is there an option for ghci to stop printing infinite lists after n elements?
05:32:10 <hpc> ennui: no
05:32:15 <hpc> just (take n)
05:32:19 <ennui> ok, thanks
05:38:20 <t7> ah its not working :'(
05:38:48 <womb> take n
05:38:58 <womb> > take 5 [1..]
05:38:59 <lambdabot>   [1,2,3,4,5]
05:41:30 <hpc> @pl let window from size = take size . drop from in window
05:41:30 <lambdabot> flip ((.) . take) . drop
05:41:55 <hpc> @pl let f x = x (f x) in f
05:41:55 <lambdabot> fix (ap id)
05:42:03 <hpc> :t ap id
05:42:04 <lambdabot> forall a b. ((a -> b) -> a) -> (a -> b) -> b
05:42:09 <hpc> o.O
05:42:17 <hpc> :t let f x = x (f x) in f
05:42:18 <lambdabot> forall t. (t -> t) -> t
05:42:55 <hpc> @djinn ((a -> b) -> a) -> (a -> b) -> b
05:42:55 <lambdabot> f a b = b (a b)
05:43:16 <hpc> oh, wow
05:44:42 <Ptival> not so impressive when you think about it...
05:44:50 <hpc> yeah
05:45:10 <hpc> i just forgot i knew it
05:46:05 <hiptobecubic> is this as nice as it sounds? http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
05:46:24 <Ptival> hiptobecubic: how nice does it sound?
05:46:27 <hpc> hiptobecubic: if you mean "does it sound not even remotely nice", yes
05:46:56 <hpc> the technique is good for things that aren't really type classes
05:46:59 <hpc> like isomorphisms
05:51:10 <Ptival> I hope these japanese people aren't infringing creative commons :s
05:51:11 <donri> hiptobecubic: (+) num'Int 3 5 -- does it still sound nice?
05:51:59 <Ptival> hiptobecubic: http://www.reddit.com/r/haskell/comments/t2yy2/scrap_your_type_classes/c4j409r
05:53:50 <Tomsik> That's just stilly
05:53:53 <Tomsik> silly*
05:54:13 <Tomsik> Why'd we need data constructors then? Let's just encode them as lambda-terms
05:56:50 <linduxed> could someone suggest a prettier way to do the following? https://gist.github.com/2585439
05:57:36 <Botje> linduxed: have a case for (a:b:c:xs) and one for _
05:57:53 <Botje> linduxed: or, if you don't need a,b or c: (_:_:_:_)
05:58:05 <mauke> inputList@(_ : _ : _ : _ : _)
05:58:19 <Botje> eh, yes, that.
05:58:23 <Tomsik> f x | length (take 4 x) <= 3 = x
05:58:24 <linduxed> well, the valid cases really are the a,b,c and the a:b:c:xs case
05:58:26 <Ptival> Botje: you're actually capturing [a, b, c] here :)
05:58:33 <Tomsik> f x | otherwise = magic
05:59:07 <Tomsik> if you don't care about taking length of the whole list f x | length x <= 3
05:59:08 <Tomsik> :P
05:59:16 <linduxed> anything smaller than three points is irrelevant
05:59:23 <mauke> | null (drop 3 xs)
05:59:59 <Botje> mauke: ooh, clever.
06:04:00 <MaskRay> This is an excerpt from XMonad.Layout.MultiToggle i'm making attemp to understand:
06:04:11 <MaskRay> class (Eq t, Typeable t) => Transformer t a | t -> a where transform :: (LayoutClass l a) => t -> l a -> (forall l'. (LayoutClass l' a) => l' a -> (l' a -> l a) -> b) -> b   type variables *l l'* refer to layouts and *t* the layout transformer.
06:04:22 <MaskRay> I have some superficial yet not decent understanding, the third type *(forall l'...)* represents a continuation.  Given a untranformed layout (or perhaps transformed, every transformed layout is itself a valid layout, so double transformation does no harm)
06:05:14 <MaskRay> we can easily calculate the transformed (given *l*, output *l'*)
06:05:58 <MaskRay> and we need to provide a mechanism to convert an already transformed layout to its original form
06:07:02 <MaskRay> but as there are many possible layouts, we cannot deduce whether the second argument *l* given is the layout transformed by us
06:07:59 <MaskRay> nevertheless, we can still provide  l' a -> l a (the l' and l are not abstract)
06:08:48 <Catnaroek> Help!
06:08:48 <Catnaroek> http://stackoverflow.com/questions/10432001/deep-function-currying-in-c-using-template-metaprogramming
06:09:23 <Botje> MaskRay: looks fine so far. what is your question?
06:10:26 <MaskRay> so the type of transformer can be understood as: given  t and l a (l is arbitrary), we provide l' and l'' (if l is exactly a transformed layout)
06:10:42 <MaskRay> the two values (layouts) are feed to the continuation
06:10:51 <mauke> what is l''?
06:11:19 <Catnaroek> sorry, wrong channel
06:11:22 <MaskRay> l'' may be undefiend(bottom) if l is not a transformed layout itself,
06:11:32 <mauke> huh?
06:11:44 <MaskRay> but as the continuation should check the type, so it does no matter
06:12:28 <MaskRay> i'd like to know, how is the type conceived? rather ingenious to me
06:13:03 <mauke> I see no l''
06:14:09 <MaskRay> l'' does not exist in the type. it's just an expediency to describe
06:16:05 <MaskRay> i means, *transformer* may given a  l_2  if the l (as the second argument) is effectively a l'
06:16:06 <mauke> I don't get it
06:16:06 <mauke> transform takes two arguments, a value that describes how to transform, and a layout (what to transform)
06:16:36 <mauke> it returns two values, the transformed layout and a function to undo the transformation
06:16:49 <MaskRay> the latter is evaluated only when l is effctively a transformed layout
06:17:00 <MaskRay> forget my l''
06:17:31 <mauke> why?
06:17:43 <mauke> transform doesn't care whether l is transformed itself
06:17:50 <MaskRay> yes
06:18:08 <MaskRay> the continuation cares
06:18:08 <mauke> no
06:19:21 <Ngevd> Hello
06:19:21 <MaskRay> ?
06:19:21 <kini> I found this odd statement in the gentle introduction: "In general, given that x has type t1 and exp has type t2, then \x->exp has type t1->t2."
06:19:45 <kini> am I right in thinking that this doesn't really make sense?
06:19:45 <mauke> kini: no
06:19:46 <MaskRay> this continuation and the rank2type used here are rather intriguing . how are they conceived?
06:19:46 <mauke> makes perfect sense to me :-)
06:20:00 <mauke> MaskRay: do you know existential types?
06:20:10 <kini> mauke: in \x->exp, x cannot have a type, can it? It must be an unbound variable
06:20:20 <mauke> kini: it must have a type
06:20:26 <mauke> every expression does
06:20:37 <kini> hmm
06:20:45 <mauke> kini: also, \x->exp binds x so it isn't unbound
06:20:53 <MaskRay> mauke: very shallow knowledge. i've only got in touch with existential types in some wiki articles
06:21:05 <mauke> MaskRay: well, because that's what this is
06:21:49 <mauke> MaskRay: the caller doesn't know the type of the resulting transformed layout l', only that it is an instance of LayoutClass
06:22:33 <mauke> i.e. exists l'. (LayoutClass l a) => l' a
06:22:33 <mauke> er. LayoutClass l'
06:23:04 <hpc> isn't exists just sugar for higher-rank foralls?
06:23:16 <mauke> hpc: if you apply a CPS transformation, yes
06:26:19 <kini> mauke: I see that ":t someundefinedvariable" gives me an error in GHCi, but "someundefinedvariable" is still an expression, right?
06:26:19 <mauke> instead of exists b. a -> b you get a -> (forall b. b -> r) -> r
06:26:19 <MaskRay> mauke: how can it infer whether the layout should be untransformed or transformed?
06:26:19 <hpc> :t thisnamedoesn'texist
06:26:19 <lambdabot> Not in scope: `thisnamedoesn'texist'
06:26:20 <hpc> > thisnamedoesn'texist
06:26:20 <mauke> MaskRay: what is "it" here?
06:26:20 <lambdabot>   Not in scope: `thisnamedoesn'texist'
06:26:20 <mauke> MaskRay: and why does it have to infer anything?
06:26:20 <MaskRay> mauke: the caller
06:26:20 <mauke> kini: depends on your definition of expression
06:26:20 <Ngevd> The hackage guy still hasn't responded
06:26:20 <kini> I'm just trying to decipher the sentence
06:26:20 <kini> it says "given that x is of type t1 and y is of type t2" (I replace exp with y since exp is in the Prelude)
06:26:20 <MaskRay> mauke: oh, the caller could hold a value to indicate wheter the layout is transformed
06:26:20 <kini> so surely that refers to when x and y are bound to values?
06:26:20 <mauke> kini: it's talking about the future
06:26:20 <byorgey> kini: I agree that statement does not make sense
06:26:20 <mauke> kini: x and y don't exist yet. it's talking about the components of \x -> y
06:26:20 <kini> byorgey: yay, maybe I'm not crazy after all :)
06:26:20 <mauke> MaskRay: ?
06:26:28 <quicksilver> byorgey: I don't. The statement made perfect sense.
06:26:48 <MaskRay> mauke: how is the type of *transformer* linked up with existential types?
06:27:02 <kini> OK, if you just, without any context, check the type of \x->3 (which should be a valid expression I believe), it will be a -> Integer, right?
06:27:06 <kini> > :t \x->3
06:27:07 <lambdabot>   <no location info>: parse error on input `:'
06:27:10 * hackagebot compdata 0.6 - Compositional Data Types  http://hackage.haskell.org/package/compdata-0.6 (PatrickBahr)
06:27:11 <kini> oops
06:27:14 <byorgey> well, let's just say there is a lot of context missing.  in \x -> x + 2,  the bare identifier 'x' by itself does not 'have a type'
06:27:15 <kini> :t \x -> 3
06:27:16 <lambdabot> forall t t1. (Num t1) => t -> t1
06:27:31 <quicksilver> byorgey: inside that expression it does.
06:27:48 <MaskRay> mauke: the caller stores a Nothing to indicate the layout is untransformed, and Just layout' transformed
06:27:52 <kini> quicksilver: only when you actually call the function, no?
06:27:56 <byorgey> it should say something more like 'If exp has type t2 *under the assumption that* x has type t1, then \x -> exp has type  t1 -> t2'
06:28:07 <quicksilver> kini: not at all
06:28:07 <byorgey> i.e. it should be implication, not and
06:28:09 <MaskRay> Either may be more appropriate
06:28:41 <quicksilver> kini: typing is a syntactic notion - derivable purely from the structure of terms
06:28:41 <quicksilver> kini: nothing gets 'called'
06:28:41 <kini> byorgey: shouldn't it be ", then \x->exp has *at least* type t1 -> t2", or something?
06:28:46 <quicksilver> byorgey: that would be the more normal formulation, certainly.
06:28:57 <quicksilver> byorgey: and perhaps it's a bit clearer but it's also a bit more fiddly.
06:29:16 <byorgey> quicksilver: well, I would argue it is more correct. And the other version is simply confusing.
06:30:05 <mauke> MaskRay: data Transformed l a = forall l'. (LayoutClass l' a) => Transformed (l' a) (l' a -> l a)
06:30:05 <kini> byorgey: "If x has type Int under the assumption that x has Int, then \x -> x has type Int -> Int" is not true, is it?
06:30:05 <byorgey> kini: it is true.
06:30:05 <mauke> MaskRay: transform :: (LayoutClass l a) => t -> l a -> Transformed l a
06:30:13 <byorgey> kini: that is not the most general type of \x -> x, but \x -> x can certainly be given that type.
06:30:13 <kini> :t \x -> x
06:30:13 <lambdabot> forall t. t -> t
06:30:26 <byorgey> :t (\x -> x) :: (Int -> Int)
06:30:26 <lambdabot> Int -> Int
06:30:36 <mauke> :t \x -> (x :: Int)
06:30:37 <kini> byorgey: oh, I figured that "foo has type bar" meant that it was talking about the unique type of foo
06:30:37 <lambdabot> Int -> Int
06:30:41 <bitonic> quicksilver: what do you mean "derivable purely from the structure of terms"? I wouldn't say that is true in the general case
06:31:18 <mauke> bitonic: it doesn't depend on values
06:32:26 <bitonic> mauke: that's not what quicksilver is saying. From what I understand he means that the type can always be inferred from the structure of the terms, but that is not always true
06:32:26 <MaskRay> mauke: these are gotten by peeling out the first two arguments of *transform* and the trailor *b* of continuation?
06:32:26 <MaskRay> s/out/off/
06:32:40 <quicksilver> bitonic: there exist terms which are poorly typed, certainly.
06:32:53 <quicksilver> bitonic: but my point was that it is a static properoty.
06:33:37 <quicksilver> bitonic: kini said something about "not until it's called"; I was saying that typing is never a dynamic property - it never depends 'how you are called' or 'when you are called'.
06:33:37 <quicksilver> a term either type checks or it doesn't - statically - and it has a unique most general type if it does. (In haskell).
06:33:37 <kini> quicksilver: I meant the type of "x", not of the the construct "\x -> exp"
06:33:47 <kini> is that less incorrect?
06:33:49 <quicksilver> kini: within an expression every subexpression also has a type.
06:33:49 <bitonic> quicksilver: ok, so you're talking specifically about Haskell types. I thought it was a more general remark
06:34:06 <quicksilver> kini: (and that is still a static property)
06:35:05 <kini> quicksilver: so then what is the type of the subexpression "x" within "\x -> y"? just "a"?
06:35:05 <quicksilver> kini: yes.
06:35:09 <kini> <mauke> :t \x -> (x :: Int)
06:35:09 <kini> And here, it is Int, I guess.
06:35:34 <kini> hmm
06:37:11 <MaskRay> mauke: is the Transformed you give store comonad?
06:38:02 <mauke> uh, no idea
06:40:15 <kini> or is it?
06:40:48 <kini> in "\x -> (x :: Int)", do you consider the type of x to be "a" or "Int"? I.e. is it dependent on its context in the larger expression?
06:41:35 <Ptival> kini: it has to be Int here
06:41:46 <t7> i wish i could step through a haskell program
06:41:55 <gdeest_> There is no "implicit conversion"
06:41:59 <byorgey> kini: it is dependent on context.
06:42:14 <kini> I don't suppose you can treat \ <thing> -> <thing> as a binary operator and create something like (\x ->)?
06:42:24 <kini> byorgey: OK, I guess there is a monotonicity condition though, right?
06:42:33 <kini> as you add context the type can only shrink
06:43:05 <kini> no, (\x ->) wouldn't make sense because you're murdering scope there I guess
06:43:12 <Ptival> yes
06:43:25 <Ptival> you would need to pass it something where x appears free
06:43:27 <Botje> "murdering scope" sounds like a nice tool.
06:43:39 <quicksilver> kini: you can treat \ <thing> -> <thing> as a binary operator in the term construction language, yes.
06:43:45 <barrucadu> [#-LANGUAGE MurderScope -#}
06:43:51 <Ptival> lol
06:43:53 <kini> barrucadu: haha
06:43:57 <quicksilver> kini: (but not in haskell itself, where names and binding are not first class)
06:44:25 <kini> quicksilver: the rabbit hole gets deeper and deeper! :D Well I guess I will understand that once I've read some more...
06:44:32 <kini> anyway, I guess my question is answered for now :)
06:44:35 <quicksilver> kini: if you look at the rules of a formal typing system such as H-M (which haskell is an extension of) then it does behave that way
06:44:43 <barrucadu> I think MurderScope would only allow one name to be in scope at a time - adding a new binding deletes all others :)
06:44:49 <quicksilver> although it's not normal to use the word "operator" for strict syntactic constructs in my experience.
06:44:55 <quicksilver> but that's just a convention.
06:44:57 <byorgey> kini: the monotonicity is simply inherent in the type system.  You don't need to impose it as an external condition.
06:45:07 <kini> quicksilver: "operation", then?
06:45:22 <quicksilver> constructor, maybe, or primitive, or connective
06:45:25 <kini> byorgey: I didn't mean it as an external condition... I'm as much a "the type system"-newbie as a Haskell-newbie :)
06:45:43 <byorgey> kini: ok, I wasn't sure what you meant, I was just clarifying.
06:45:48 <kini> yup, thanks!
06:46:15 <quicksilver> there are programming languages in which variable names are real and you really can abstract over them at the language level
06:46:27 <quicksilver> e.g. lisp.
06:46:47 <quicksilver> but this has its own set of shortcomings.
06:47:01 <kini> am I right in guessing that that is the vaunted "homoiconicity" property of lisp?
06:48:15 <quicksilver> well I think it's related.
06:48:31 <quicksilver> If programs are data then it's not unreasonable to expect you can manipulate variable names.
06:49:08 <kini> I see
06:50:01 <kini> you know, I actually think that the sentence I quoted makes sense now... sort of
06:50:07 <kini> (the statement: "In general, given that x has type t1 and exp has type t2, then \x->exp has type t1->t2.")
06:50:17 <kini> except the if is backwards :)
06:50:45 <kini> If \x->exp has type t1->t2, then x has type t1 and exp has type t2
06:50:56 <MaskRay> how to express data (LayoutClass l a) => EL l a = forall l'. (LayoutClass l' a) => EL (l' a) (l' a -> l a) without DatatypeContexts (deprecated)
06:51:42 <Cale> MaskRay: Delete the (LayoutClass l a) which occurs immediately after 'data'
06:52:47 <Cale> (along with the =>)
06:53:24 <Cale> In fact, you might even want to make that nicer by turning it into:
06:53:33 <Cale> data EL l a where
06:53:38 <MaskRay> Cale: so it's just an additional type constraint ?
06:53:54 <MaskRay> GADT?
06:54:15 <Cale>   EL :: (LayoutClass l a, LayoutClass l' a) => l' a -> (l' a -> l a) -> EL l a
06:54:22 <Cale> yes
06:54:29 <Ptival> kini: yes (well, usually we go the other way around)
06:54:33 <Cale> That's probably what was originally intended
06:54:40 <Cale> (but not what the code actually meant)
06:54:48 <kini> Ptival: the other way around?
06:55:23 <kini> I guess you mean, if we want x to be restricted to type t1 and exp to type t2, then we should set the type of \x->exp to be t1->t2?
06:55:25 <Cale> MaskRay: basically, it would place an additional constraint on the constructor function, but pattern matching the constructor wouldn't discharge that constraint
06:55:51 <Ptival> kini: http://upload.wikimedia.org/wikipedia/en/math/b/5/4/b54cbce9efe4eafd545bcfcbe9796ba0.png
06:56:03 <Cale> MaskRay: So it's an extra restriction which can't really serve much purpose, since you still need the same constraint on every function which works with data of this type
06:56:28 <Cale> MaskRay: But with the GADT, it will discharge that constraint by pattern matching
06:56:40 <kini> Ptival: that's unreadable, thanks to firefox now having dark gray backgrounds for standalone images - what article was that on?
06:56:55 <Cale> (So by pattern matching the EL constructor, your code will locally "discover" that LayoutClass l a)
06:56:58 <Ptival> kini: http://en.wikipedia.org/wiki/Simply_typed_lambda_calculus rule (3)
06:57:05 <kini> thanks :)
06:57:19 <Ptival> kini: I see two ways of reading this
06:57:25 <xplat> i wish ghc-mod had something like 'agda-mode locate'
06:58:05 <Cale> MaskRay: In terms of the implementation, the EL values will actually carry around the typeclass dictionaries for those constraints.
06:58:20 <Ptival> kini: one is "if (x : sigma implies e : tau), then \x -> e : sigma -> tau"
06:58:21 <kini> sorry, bbl...
06:58:44 <Ptival> kini:  the other is "to show that \x -> e : sigma -> tau, we must show that x : sigma implies e : tau"
06:58:55 <MaskRay> i still cannot find out how to use ghc-mod with emacs so veered to vim...
06:59:20 <MaskRay> vim's indent-mode for haskell is always annoying me
06:59:40 <Ptival> I resort to manual indenting :(
07:00:10 <xplat> as it is i have to hardcode the path in my .emacs and must remind myself to change it when i upgrade
07:00:54 <Cale> It's the typed version of the deduction theorem :)
07:01:21 <Cale> Or, maybe I should say, the valued version
07:01:31 <xplat> i can't even get ghc-mod to print out its version in a sane format so i can greenspun my own shell command
07:02:45 <Cale> because the types are what corresponds to the usual version of natural deduction, that  (A |- B) |- (A -> B)
07:03:03 <dimituri> > I resort to manual indenting :(
07:03:03 <dimituri> is there a commonly accepted style guide anyway?
07:03:04 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:03:17 <Cale> lol
07:03:43 <Cale> http://urchin.earth.li/~ian/style/haskell.html -- this is a very uncontroversial style guide
07:04:08 <dimituri> and this one https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md ?
07:04:59 <Cale> That one has some things I do differently myself
07:05:11 <t7> grrr my hm isnt working now
07:05:19 <t7> brb gonna go hang myslef
07:05:36 <sykora> For some reason, I can't bring myself to put commas at the beginning, rather than the end.
07:06:14 <Cale> dimituri: In particular, I like for the 'then' and 'else' parts to start in a deeper column than the 'if'
07:06:50 <Cale> and I tend to like starting do-blocks on the same line as the 'do', but I will often start the do-block on a new line
07:08:17 <Cale> dimituri: but basically, as long as you're not using tabs, and you're lining things up nicely, you can't go wrong
07:08:19 <dimituri> the latter sounds more appealing
07:08:36 <Ngevd> Is there anything like Url -> Handle anywhere?
07:08:43 <Cale> I mean, I'll write
07:08:47 <Cale> foo x y z =
07:08:54 <Cale>   do firstThing x y
07:08:57 <Ngevd> Url -> IO Handle, more likely
07:08:58 <Cale>      ...
07:09:48 <fmap> @hoogle URL -> IO Handle
07:09:48 <lambdabot> Network connectTo :: HostName -> PortID -> IO Handle
07:09:48 <lambdabot> System.IO openBinaryFile :: FilePath -> IOMode -> IO Handle
07:09:48 <lambdabot> GHC.IO.Handle.FD openBinaryFile :: FilePath -> IOMode -> IO Handle
07:09:54 <linduxed> what was the built in method to join ["a","b","c"] into "abc" ?
07:09:59 <dimituri> Cale: oh that. okay, that look weird
07:10:16 <quicksilver> Ngevd: that would be strange, because HTTP responses at least are more structured than a plain handle.
07:10:41 <Cale> Ngevd: there's http://hackage.haskell.org/package/download-curl (and without the -curl, which is similar) -- doesn't give you a Handle, but it goes one step further
07:10:42 <fmap> > join ["a","b","c"]
07:10:42 <lambdabot>   "abc"
07:11:08 <linduxed> not in scope
07:11:32 <Cale> see also http://hackage.haskell.org/package/HTTP
07:11:32 <Ngevd> Hmm
07:11:34 <Ngevd> Thanks
07:12:06 <Cale> which is better if you're going to be doing back and forth communication, or you actually care about http in any way
07:13:11 <Cale> Network.Browser gives you sessions with redirect following and cookies and whatnot
07:13:13 <jix> linduxed: it's from Control.Monad but there is also concat in Prelude
07:13:27 <linduxed> jix: thx, i found concat
07:13:51 <ocharles> linduxed: fwiw, you want [[a]] -> [a], which generalises to m (m a) -> m a
07:13:55 <ocharles> you could find that with hoogle
07:14:21 <byorgey> @hoogle [[a]] -> [a]
07:14:22 <lambdabot> Prelude concat :: [[a]] -> [a]
07:14:22 <lambdabot> Data.List concat :: [[a]] -> [a]
07:14:22 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
07:15:30 <hjulle> Is it possible to install multiple versions of the "base" package?
07:15:46 <byorgey> hjulle: no.
07:16:05 <rwbarton> you shouldn't be installing any version of the base package--use whatever your ghc came with
07:16:07 <byorgey> hjulle: the 'base' package is tightly tied to whatever compiler version you have installed
07:16:16 <linduxed> does haskell generally use underscore or camelcase for method names?
07:16:36 <byorgey> hjulle: are you having some particular problem trying to install something else?
07:16:41 <merijn> linduxed: camelCase
07:16:53 <hjulle> Installing the package mathlink
07:17:08 <linduxed> merijn: ok, then i had the right feeling
07:17:23 <hjulle> byorgey: Should install an older version of ghc to solve this?
07:17:58 <quicksilver> either install the version of GHC that mathlink definitley works with
07:18:13 <quicksilver> or edit the .cabal file and investigate if it compiles OK with a newer version
07:18:19 <quicksilver> (it might, if it doesn't depend on anything that changed)
07:18:34 <hjulle> quicksilver: How would I do that?
07:22:07 <hjulle> What is the correlation between ghc version and the base-version? (where do you find it?)
07:22:14 * hackagebot ghc-events-parallel 0.4.0.0 - Library and tool for parsing .eventlog files from parallel GHC  http://hackage.haskell.org/package/ghc-events-parallel-0.4.0.0 (MischaDieterle)
07:22:15 * hackagebot edentv 4.1.0.0 - A Tool to Visualize Parallel Functional Program Executions  http://hackage.haskell.org/package/edentv-4.1.0.0 (MischaDieterle)
07:22:46 <byorgey> hjulle: (1) cabal unpack mathlink  (2) cd mathlink  (3) edit mathlink.cabal and increase the version upper bounds on the build-depends, and also increase the version number of mathlink  (4) cabal install
07:23:04 <byorgey> hjulle: what version of ghc do you have?
07:23:12 <byorgey> you may need to remove the haskell98 dependency as well
07:23:25 <hjulle> byorgey: Thanks, 7.0.4
07:25:39 <byorgey> hjulle: ok, I just tried it.
07:27:32 <hjulle> byorgey: Did it work for you?
07:27:42 <byorgey> hjulle: in particular, you need to: increase the upper bound on 'base' to < 4.4; increase the upper bound on 'mtl' to < 2.2; increase the upper bound on 'containers' to < 0.5
07:27:59 <byorgey> well, I seem to be having trouble getting my newer version of 'cabal' to work with GHC 7.0.4, but that shouldn't be a problem for you
07:31:39 <byorgey> hmm, has anyone ever seen the error  unrecognized option `--disable-benchmarks'  ?
07:31:46 <byorgey> dcoutts?
07:33:40 <dekuked> what's a good way to learn about iteratees?
07:35:36 <rwbarton> i would suggest reading this:
07:35:38 <rwbarton> @hackage pipes
07:35:39 <lambdabot> http://hackage.haskell.org/package/pipes
07:38:24 <rwbarton> because (a) it is conceptually more coherent than the original iteratee implementation, and (b) it is thoroughly documented
07:39:12 <merijn> How would I write a function "(a -> b) -> State a c -> State b c"?
07:39:36 <merijn> I seem to be missing some obvious but crucial step
07:40:13 <rwbarton> you can't
07:40:33 <rwbarton> @djinn (a -> b) -> (a -> (a, c)) -> (b -> (b, c))
07:40:33 <lambdabot> -- f cannot be realized.
07:40:40 <dekuked> rwarton: thank you!
07:41:08 <parcs`> merijn: perhaps you want b -> a
07:41:31 <parcs`> @djinn (b -> a) -> (a -> (a, c)) -> (b -> (b, c))
07:41:31 <lambdabot> f a b c =
07:41:31 <lambdabot>     case b (a c) of
07:41:31 <lambdabot>     (_, d) -> (c, d)
07:41:32 <merijn> rwbarton, parcs`: yeah, maybe I screwed up my type signature?
07:41:55 <merijn> Actually, I probably did
07:42:20 <parcs`> that looks useless
07:42:30 <merijn> I want to change the type of data in the state, but can't figure out how to do this
07:43:01 <byorgey> the state type is covariant, so you need  (b -> a) -> State a -> State b
07:43:30 <byorgey> wait, actually, it's invariant, isn't it
07:43:36 <merijn> byorgey: I don't actually want that function itself, I thought that type described what I wanted, but it doesn't as I just realised
07:43:51 <byorgey> and I meant "contravariant" in my first statement of course.  gah.
07:43:56 <rwbarton> you would need both (a -> b) and (b -> a)
07:44:01 <byorgey> right
07:44:04 <merijn> I want to write: "State a () -> State (Maybe a) ()"
07:45:57 <rwbarton> well that you can certainly do, since it's effectively   (a -> a) -> (Maybe a -> Maybe a) which is just fmap
07:46:16 <merijn> But all the varying typeclasses such as MonadState make me unsure what I'm looking for typesignature wise
07:46:19 <rwbarton> (assuming you want the fmap semantics and not some other one)
07:47:32 <merijn> rwbarton: Ok, so...how?
07:47:43 <rwbarton> @type State
07:47:44 <lambdabot> Not in scope: data constructor `State'
07:47:48 <rwbarton> ugh
07:48:01 <parcs`> @type state
07:48:02 <lambdabot> forall s a. (s -> (a, s)) -> State s a
07:48:08 <rwbarton> well I mean you can just unpack everything, the details will depend on the version of mtl
07:48:22 <rwbarton> @type runState
07:48:23 <lambdabot> forall s a. State s a -> s -> (a, s)
07:48:51 <rwbarton> @type \st -> state $ first fmap . runState st
07:48:52 <lambdabot> forall s a b (f :: * -> *). (Functor f) => State s (a -> b) -> State s (f a -> f b)
07:48:58 <rwbarton> uh
07:49:01 <rwbarton> @type \st -> state $ second fmap . runState st
07:49:03 <lambdabot>     Occurs check: cannot construct the infinite type: a = f a
07:49:03 <lambdabot>       Expected type: f a -> f b
07:49:03 <lambdabot>       Inferred type: a -> b
07:49:05 <rwbarton> hmm
07:49:20 <t7> :t ($)
07:49:22 <lambdabot> forall a b. (a -> b) -> a -> b
07:49:32 <rwbarton> oh blargh
07:51:01 <merijn> This seems like it shouldn't be such a hard/rare thing to want...
07:51:39 <pcapriotti> @type \x -> get >>= put . fmap (execState x)
07:51:40 <lambdabot> forall (m :: * -> *) a a1 (f :: * -> *). (MonadState (f a) m, Functor f) => State a a1 -> m ()
07:52:02 <rwbarton> @type \st -> state $ ((),) . fmap (\s' -> execState st s')
07:52:03 <lambdabot> Illegal tuple section: use -XTupleSections
07:52:06 <Mathnerd314> how  do you go from s -> a to Maybe s -> a ?
07:52:08 <pcapriotti> that should specialize to what you need
07:52:12 <rwbarton> @type \st -> state $ (,) () . fmap (\s' -> execState st s')
07:52:13 <lambdabot> forall a a1 (f :: * -> *). (Functor f) => State a a1 -> State (f a) ()
07:52:34 <rwbarton> merijn, it seems pretty odd to me
07:52:37 <rwbarton> odd/specific
07:52:40 <merijn> Mathnerd314: Using maybe/fromMaybe
07:53:19 <rwbarton> @type mapState
07:53:20 <lambdabot> forall a s b. ((a, s) -> (b, s)) -> State s a -> State s b
07:53:23 <merijn> rwbarton: For Maybe, perhaps. But in general wanting to run some State computation on a subset of existing State...
07:53:23 <rwbarton> can also use this
07:53:35 <rwbarton> well why didn't you say so!
07:53:45 <rwbarton> i think the lens libraries have a function to do exactly that
07:54:00 <merijn> rwbarton: I'm using data-lens, but it doesn't solve my entire problem
07:54:00 <rwbarton> "Maybe a" isn't really a "subset" of "a", though...
07:54:04 <t7> > let fix f = f (fix f) in fix
07:54:05 <lambdabot>   Overlapping instances for GHC.Show.Show ((t -> t) -> t)
07:54:05 <lambdabot>    arising from a u...
07:54:06 <byorgey> I don't see how mapState helps...
07:54:08 <merijn> As mapLens returns Maybe
07:54:08 <t7> :t let fix f = f (fix f) in fix
07:54:09 <lambdabot> forall t. (t -> t) -> t
07:54:10 <parcs`> merijn: http://hackage.haskell.org/packages/archive/data-lens/2.10.0/doc/html/Data-Lens-Lazy.html#v:focus
07:54:13 <rwbarton> oh sorry
07:54:19 <rwbarton> byorgey, right
07:55:09 <byorgey> Maybe a is a *superset* of a, which is more to the point
07:55:15 <merijn> parcs`: focusing on a mapLens gives me "State (Maybe a) ()", and I have a function that runs on a
07:55:54 <byorgey> so you can make a State computation which has no effect on Nothing and has the behavior of the original computation on Just
07:55:55 <rwbarton> right, okay, thinking backwards today.
07:56:01 <rwbarton> but Maybe a might not contain an a at all
07:56:14 <merijn> rwbarton: In which case I just want to do nothing
07:56:30 <parcs`> merijn: there is http://hackage.haskell.org/packages/archive/data-lens/2.10.0/doc/html/Data-Lens-Partial-Common.html#v:justLens
07:56:31 <merijn> Hence why I'm trying to write "State a () -> State (Maybe a) ()"
07:56:41 <parcs`> but partial lenses do not seem to have a 'focus' combinatorl
07:57:05 <dekuked> rwbarton: sorry to ask, but do you know where I could find a tutorial about pipes?
07:57:07 <t7> bitonic: does yout ml-w type rec fix = f -> f (fix f)  correctly?
07:57:19 <merijn> parcs`: And would also require reimplementing mapLens to be a partial lens
07:57:30 <bitonic> t7: I don't have recursive lets, I just have a `fix' primitive
07:57:36 <merijn> parcs`: I tried that first but got stuck there too
07:57:37 <rwbarton> dekuked, did you see http://hackage.haskell.org/packages/archive/pipes/1.0.2/doc/html/Control-Pipe.html ?
07:57:42 <bitonic> that you can use like this: `fix f. ....'
07:57:51 <byorgey> merijn: wait a minute. actually, I'm not sure this can actually work now that I think about it a bit more.
07:57:57 <bitonic> where you can use the `f' in the `...'
07:58:00 <merijn> Basically it boils down to mapLens being ridiculously impractical to actually do something with
07:58:15 <byorgey> merijn: oh! I see, it can work but only because the return type is specifically ()
07:58:20 <merijn> byorgey: Yup
07:58:34 <merijn> Otherwise you're boned, of course
07:58:44 <rwbarton> that is what makes me say it is odd/specific
07:59:05 <dekuked> rwbarton: no, I did not. Thank you for pointing that out!
07:59:18 <byorgey> rwbarton: yeah, I agree
07:59:26 <rwbarton> not that it is necessarily an unusual thing to want to do, but it is a very specific thing to want to do and it's hardly surprising that there might not be a convenient way to write it
07:59:28 <merijn> rwbarton: Basically I want to update inside the Maybe, but I can't use focus to get in there.
07:59:44 <rwbarton> it might make sense to include it in a lens library, though
07:59:59 <dekuked> rwbarton: but there is no mention of sockets on that page...
08:00:02 <MaskRay> parcs`: how are those symbols coined ^= ^%= %= ~=   seeking for a mnemonic verse
08:00:12 <byorgey> @type \s -> state $ maybe ((), Nothing) (second Just . runState s)
08:00:13 <lambdabot> forall a. State a () -> State (Maybe a) ()
08:00:15 <parcs`> MaskRay: no idea
08:00:17 <byorgey> merijn: ^^^
08:00:21 <merijn> byorgey: \o/
08:00:53 <rwbarton> there were a couple earlier too, < pcapriotti> @type \x -> get >>= put . fmap (execState x) < rwbarton> @type \st -> state $ (,) () . fmap (\s' -> execState st s')
08:01:05 <parcs`> MaskRay: well actually ~= is lazy set because the = denotes assignment and ~ denotes laziness (via lazy pattern matches)
08:01:07 <byorgey> oh, didn't see those
08:01:29 <parcs`> MaskRay: the % is 'mod' so %= modifies something
08:01:38 <t7> bitonic: like this     Rec "fix" (Abs "f" (Ap (Var "f") (Ap (Var "fix") (Var "f")))
08:02:06 <bitonic> t7: again, I don't have recursive let. so the answer is "no". you have to express all recursion with `fix', which is a primitive.
08:02:07 <merijn> rwbarton: oh, heh. I only now spot how your previous one works
08:02:18 <rwbarton> I think it is kind of ugly
08:02:33 <parcs`> MaskRay: similarly != is strict assignment, !%= is strict modification, %%= is just another form of assignment, and the rest look like their C counterparts
08:03:01 <rwbarton> @type modify
08:03:02 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
08:03:05 <t7> oh sorry
08:03:19 <rwbarton> @type \x -> modify $ fmap $ execState x
08:03:20 <lambdabot> forall (m :: * -> *) a (f :: * -> *) a1. (MonadState (f a) m, Functor f) => State a a1 -> m ()
08:03:32 <t7> you have like fix :: (a -> a) -> a   i guess
08:04:04 <pcapriotti> @type modify . fmap . execState
08:04:06 <lambdabot> forall (m :: * -> *) b (f :: * -> *) a. (MonadState (f b) m, Functor f) => State b a -> m ()
08:04:14 <pcapriotti> :)
08:04:17 <byorgey> hah, crazy =)
08:04:28 <MaskRay> parcs`: your explanations deserv to be included in the doc
08:05:49 <bitonic> t7: it's not an ordinary function, it's just a keyword. so if you do `fix f. <term>' you can use `f : forall a. a' in <term>
08:06:49 <t7> fix f. \a -> a (f a)
08:06:51 <parcs`> MaskRay: yeah there should probably be some mnemonic explanations there.. i guess the author didn't get around to it yet
08:06:57 <t7> does that work?
08:07:35 <bitonic> t7: let me try, it should
08:07:51 <parcs`> MaskRay: he is known for his very well thought-out but somewhat documentation-lacking libraries :P
08:08:57 <donri> scumbag edwardk: writes awesome package, doesn't document.
08:09:29 <copumpkin> the type are all the documentation you need
08:09:35 <copumpkin> real programmers don't use comments
08:09:47 <donri> real programmers don't need types
08:09:58 <donri> oops wrong channel
08:10:02 * copumpkin slaps donri 
08:10:06 <quicksilver> data-lens-fd has *some* documentation
08:10:06 <Ngevd> real programmers don't need programs.
08:10:11 <quicksilver> that makes it better than average :)
08:10:37 <merijn> quicksilver: You mean 4 lines? :p
08:10:39 <dekuked> wait, pipes doesn't support udp? http://hackage.haskell.org/packages/archive/pipes-network/0.0.2/doc/html/Control-Pipe-Network.html
08:10:40 <dmwit> step 1. become PhD candidate working on lenses
08:10:49 <dmwit> step 2. understanding edwardk's lens package is trivial
08:10:53 <dmwit> That's what I did.
08:11:11 <pcapriotti> dekuked: patches welcome
08:11:19 <quicksilver> merijn: that's 4 lines more than comonad-transformer had ;)
08:11:27 <quicksilver> parcs`: "< parcs`> MaskRay: the % is 'mod' so %= modifies something"
08:11:33 <quicksilver> parcs`: I'd actually never spotted that.
08:11:42 <quicksilver> it's kind-of ugly as puns go :)
08:11:45 <dekuked> uh, well, I kind of need something with udp support
08:11:49 <dekuked> and I'm a n00b
08:12:05 <quicksilver> UDP is unreliable
08:12:11 <dekuked> I know...
08:12:12 <quicksilver> not sure it fits the pipe abstract very well
08:12:20 <quicksilver> doesn't pipes assume data is stream-like
08:12:22 <quicksilver> ?
08:12:40 <dekuked> it seems to, at least by my glancing at it
08:12:52 <dekuked> what's the best way of handling udp stuff in haskell though?
08:13:02 <quicksilver> directly with the network package I imaigne
08:13:11 <dekuked> ah okay. thank you!
08:13:14 <bitonic> t7: I get this:
08:13:15 <bitonic> blah : (0 -> 0) -> 0
08:13:17 <bitonic> blah = fix f. \a . a (f a)
08:13:24 <bitonic> which is correct
08:13:34 <t7> im doing something wrong then
08:13:39 <t7> :(
08:14:13 <dmwit> why not blah = fix f. f?
08:14:23 <merijn> @pl \x -> (flip subtract x &&& id) . (`div`2) $ x
08:14:23 <lambdabot> (. (`div` 2)) =<< (&&& id) . (-)
08:14:31 <dmwit> A tight loop is the canonical inhabitant of empty types.
08:14:39 <bitonic> dmwit: that's just undefined
08:14:48 * dmwit doesn't know any context
08:15:03 <dmwit> I guess undefined is undesirable for some reason...?
08:15:12 <dmwit> But if we're talking about a 0 type I don't see how you can have a desirable inhabitant.
08:15:25 <bitonic> dmwit: that `0' is just a type variable.
08:15:29 <dmwit> aha
08:15:46 * bitonic couldn't be bothered to convert numbers to letters
08:15:58 <t7> i get 3 -> 2 -> 2
08:15:59 <dmwit> No, no, not your fault, mine for making assumptions.
08:16:26 <t7> (3 -> 2) -> 2
08:16:32 <bitonic> dmwit: I feel you I'm great at assumptions as well on this chan :D
08:16:46 <Tomsik> Isn't it cannonicaly O instead of 0?
08:17:21 <bitonic> Tomsik: what's canonically O? the empty type? afaik it's canonically _|_/Void
08:17:46 <Tomsik> No, no, I mean when talking about single-base-type-types
08:17:53 <Tomsik> like (O -> O) -> O
08:18:04 <Tomsik> When talking about if type is inhabited or not
08:18:13 <Tomsik> (bottom doesn't count)
08:18:19 <bitonic> Tomsik: I don't follow. (0 -> 0) -> 0 === forall a. (a -> a) -> a in my little langauge
08:18:21 <bitonic> *language
08:18:57 <Tomsik> I think we're talking about two different things, heh.
08:19:04 <bitonic> I think so as well :P
08:23:50 <dekuked> I'm trying to follow a tutorial, but I'm getting this error: https://gist.github.com/2586446
08:24:17 <mauke> what tutorial?
08:24:43 <byorgey> dmwit: also, \a -> a (f a)  =/=  f
08:24:52 <donri> dekuked: use "let" in ghci
08:25:04 <donri> let x = y
08:25:28 <byorgey> dekuked: better, put your definitions in a .hs file and then load it into ghci using :load
08:25:38 <byorgey> and then when you make changes to the file just  :reload  in ghci
08:25:50 <byorgey> which you can abbreviate to  :l  and  :r  respectively
08:26:02 <dekuked> http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/
08:26:37 <dekuked> okay, I guess I'll just start :loading the files then. was kind of hoping prelude was like the python shell :(
08:26:56 <strager> Prelude's like a library.
08:27:08 <Mathnerd314> bitonic: does your language have a name yet?
08:27:14 <Mathnerd314> or is it still too small?
08:27:15 <strager> I dunno what it's called in Python, but it's like the BCL in C# or the standard library in C/C++.
08:27:15 <donri> Prelude is like the builtins module in Python
08:27:57 <donri> dekuked: ghci works kinda like the python interactive shell if you use "let"
08:28:03 <dekuked> oh, I guess I misunderstood. I thought it was just a shell.
08:28:19 <donri> the ghci prompt shows modules in scope, which defaults to "Prelude"
08:28:35 <bitonic> Mathnerd314: it's just a demo to give a minimal example of the HM inference
08:28:57 <merijn> dekuked: Prelude is the name of the standard library
08:29:05 <bitonic> Mathnerd314: https://github.com/bitonic/ml-w , the inference is fairly well commented, and the code is very portable
08:29:32 <bitonic> Mathnerd314: I wrote it as a coursework for the type systems course at my uni
08:31:48 <Mathnerd314> ah
08:32:04 <Mathnerd314> and t7 is doing basically the same thing?
08:32:16 <donri> are there 313 other math nerd on freenode right now?
08:32:23 <bitonic> Mathnerd314: I think that t7 wants to create a real language
08:32:44 <byorgey> donri: at least.
08:32:45 <Mathnerd314> donri: doubt it
08:32:56 <donri> byorgey: by nick i mean
08:33:04 <byorgey> ;)
08:33:36 <byorgey> Presumably 314 is a reference to the first three digits in the decimal expansion of one-half tau.
08:33:40 <mefisto> donri: notice that there are 872 users in thsi channel :D
08:34:16 <bitonic> byorgey: it took me a few seconds to understand :D
08:34:34 <Mathnerd314> > tau
08:34:35 <lambdabot>   Not in scope: `tau'
08:34:47 <byorgey> @package tau
08:34:48 <lambdabot> http://hackage.haskell.org/package/tau
08:34:57 <bitonic> oh yeah, I remember that
08:35:02 <bitonic> @let tau = pi * 2
08:35:03 <lambdabot>  <local>:12:0:
08:35:03 <lambdabot>      Multiple declarations of `L.tau'
08:35:03 <lambdabot>      Declared at: <local...
08:35:08 <mauke> > τ
08:35:10 <lambdabot>   6.283185307179586
08:35:14 <bitonic> > L.tau
08:35:16 <lambdabot>   6.283185307179586
08:35:19 <bitonic> uhm.
08:35:44 <byorgey> > tau
08:35:46 <lambdabot>   6.283185307179586
08:36:05 <byorgey> bitonic: someone must have @let-defined it privately right before you did =)
08:36:18 <mauke> don't you love side effects?
08:36:30 <tgeeky> mauke: only with recreational drugs
08:36:47 <byorgey> lambdabot is a shared mutable variable!
08:37:02 <tgeeky> byorgey: the best!
08:37:05 <copumpkin> the horror!
08:37:23 <byorgey> > iamasharedmutablevariable
08:37:25 <lambdabot>   True
08:38:33 <donri> @let True = False
08:38:34 <lambdabot>  Defined.
08:38:46 <magicman> Ohshi...
08:38:52 <Mathnerd314> > iamasharedmutablevariable
08:38:52 <bitonic> byorgey: damn
08:38:54 <lambdabot>   True
08:39:04 <donri> > True
08:39:06 <lambdabot>   True
08:39:07 <donri> :(
08:39:08 <magicman> > true
08:39:10 <lambdabot>   True
08:39:13 <bitonic> > False
08:39:13 <magicman> > if true then 1 else 2
08:39:13 <strager> > undefined
08:39:14 <lambdabot>   False
08:39:14 <lambdabot>   can't find file: L.hs
08:39:15 <lambdabot>   *Exception: Prelude.undefined
08:39:20 <magicman> > if true then 1 else 2
08:39:20 <tgeeky> > let false in True
08:39:21 <lambdabot>   <no location info>: parse error on input `in'
08:39:21 <lambdabot>   can't find file: L.hs
08:39:27 <strager> > let x = x in x
08:39:31 <lambdabot>   mueval-core: Time limit exceeded
08:39:43 <tgeeky> this must be how people of the future try to kill androids.
08:40:00 <magicman> Bah, I had the nicest type error set up, too >_>
08:40:01 <donri> > fromEnum true + 1
08:40:01 <Mathnerd314> > let True = False in True
08:40:02 <lambdabot>   No instance for (GHC.Enum.Enum Text.PrettyPrint.HughesPJ.Doc)
08:40:03 <lambdabot>    arising fr...
08:40:03 <lambdabot>   can't find file: L.hs
08:40:13 <bitonic> > fix error
08:40:14 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
08:40:21 <strager> hehehe
08:40:23 <bitonic> it's exceptions all the way down
08:40:37 <donri> error error on the wall...
08:42:40 <ben> What's "let True = False in" doing?
08:42:49 <ben> Is it just doing lazy pattern matching that can never be forced?
08:42:55 <Botje> yep.
08:44:47 <quicksilver> > let Right "in" = Left "out" in 6
08:44:48 <lambdabot>   6
08:44:59 <quicksilver> it is a bit strange but it would be more inconsistent to reject it.
08:45:04 <c_wraith> I really think binding that don't actually bind a name shouldn't be allowed
08:45:24 <c_wraith> > let 1 = 2 in 1
08:45:25 <lambdabot>   1
08:45:50 * roconnor begins all his haskell files with 0 = 1
08:45:50 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
08:46:40 <parcs`> i think they should, because why not
08:47:10 <tgeeky> robbert: that made me think of the movie Contact. I imagine a different version where the sophisticated alien species sends us mathematics that we assume is bullshit (2 + 2 = 5) so we just ignore it. :o
08:47:20 <tgeeky> roconnor: that made me think of the movie Contact. I imagine a different version where the sophisticated alien species sends us mathematics that we assume is bullshit (2 + 2 = 5) so we just ignore it. :o
08:47:31 <mauke> > let 2 + 2 = 5 in 5
08:47:32 <lambdabot>   5
08:47:40 <bitonic> tgeeky: that made me think of the movie Memento
08:47:52 <donri> > let a + b = a + b + 1 in 2 + 2
08:48:00 <donri> :)
08:48:00 <lambdabot>   mueval: ExitFailure 1
08:48:00 <lambdabot>  mueval: Prelude.undefined
08:48:39 <mauke> > let 1 2 = 3 in ()
08:48:42 <lambdabot>   <no location info>: Parse error in pattern
08:49:39 <roconnor> > let 2 + 2 = 5 in 2 + 2
08:49:40 <lambdabot>   5
08:50:34 <mauke> > let a (2 -> 3) = () in a
08:50:35 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> ())
08:50:35 <lambdabot>    arising from a use of ...
08:50:43 <donri> lexically scoped lies
08:50:45 <mauke> > let a (2 -> 3) = () in a 1
08:50:46 <lambdabot>   *Exception: <interactive>:3:4-18: Non-exhaustive patterns in function a
08:50:51 <mauke> interesting
08:50:55 <tgeeky> dmwit: https://github.com/technogeeky/pi-eta-epsilon/blob/master/dualities.hs
08:51:00 <t7> bitonic: just spent about 2 hours tracking it down. it was my unification algo haha
08:51:14 <t7> it was ignoring all TVar -> TVar subs
08:51:27 <t7> but it should only ignore TVar x -> TVar x
08:51:33 <quicksilver> > let 2 x = 3 in 4
08:51:34 <lambdabot>   <no location info>: Parse error in pattern
08:51:43 <quicksilver> mauke: that is peculiar in some ways.
08:51:44 <mauke> > let a (2 -> 2) = () in a 1
08:51:45 <lambdabot>   ()
08:51:53 <quicksilver> it restricts function bindings to actually be real names
08:51:58 <quicksilver> but not value bindings?
08:52:02 <quicksilver> that doesn't seem consistent.
08:52:18 * hackagebot monadIO 0.10.1.2 - Overloading of concurrency variables  http://hackage.haskell.org/package/monadIO-0.10.1.2 (ThomasDuBuisson)
08:53:45 <tgeeky> dmwit: only cosmetic changes so far
08:55:22 <dekuked> is there an easy way to reset the ghci?
08:55:57 <tgeeky> dekuked: :r reloads
09:02:13 <parcs`> anyone know what the p parameter in the GHC.Generics stuff is for: http://www.haskell.org/ghc/docs/7.4.1/html/libraries/ghc-prim-0.2.0.0/GHC-Generics.html
09:02:46 <dekuked> can someone help me understand this?: https://gist.github.com/2586800
09:03:00 <dekuked> basically I don't really understand the Nothing/Maybe/Just thing
09:03:29 <quicksilver> dekuked: well your fragments don't make sense but I assume there was a function name in front
09:03:41 <quicksilver> doSomething Nothing (Just 1) (Just 2)
09:03:44 <zachk> Maybe is can contain Nothing or Just somethingElse
09:03:54 <quicksilver> dekuked: in this context, Maybe is being used for 'optional parameters'
09:03:56 <mauke> dekuked: there is no "Nothing (Just x) (Just y) paradigm"
09:03:58 <benmachine> http://hpaste.org/68007 if anyone can explain to me why this example doesn't trigger numeric defaulting I'd be grateful
09:04:02 <quicksilver> put Nothing for 'not there'
09:04:09 <quicksilver> and "Just x" for 'value x'
09:04:38 <quicksilver> benmachine: at a guess, because runST is an ugly special case.
09:04:48 <quicksilver> benmachine: I don't think you can compose functions with runST.
09:05:35 <benmachine> quicksilver: yes but the error I get refers to the numeric literal 5
09:05:48 <benmachine> and goes away when I give it an explicit type
09:05:59 <benmachine> just the literal, not anything else
09:06:35 <quicksilver> benmachine: could still be a side effect of the way the type-checker special-cases runST?
09:06:58 <benmachine> quicksilver: sure, but kind of a weird one, do you think it's a bug?
09:07:45 <dekuked> mauke, quicksilver, zachk: thank you for explaining that
09:08:00 * zachk tips his hat 
09:08:04 <parcs`> hah, just made ghc throw an irrefutable pattern exception
09:12:18 <dekuked> how many namespaces are there in haskell? just 2 (one for types, the other for values)?
09:18:45 <tromp_> then what is the namespace of Modules?
09:19:28 <DijkstraGroupie> @hoogle Modules
09:19:30 <lambdabot> System.Posix.DynamicLinker.Module moduleSymbol :: Module -> String -> IO (FunPtr a)
09:20:51 <quicksilver> dekuked: those are the main ones. As tromp points out, modules are another namespace.
09:21:17 <quicksilver> classes could be a separate namespace from types but, in fact, it's not legal to have a class and type with the same name.
09:28:39 <stj> why is there a confusion between Main.+ and Prelude.+ here? If I use function (+) on something, isn't it obvious what overloaded function should be used? Or is there a problem because (+) is reserved for Nums?
09:29:10 <stj> what would be a neat way to define a Vector Double Double Double, together with function such as dot product, cross product, addition, multiplication, abs etc.
09:29:46 <benmachine> stj: what "here" do you refer to?
09:29:49 <Saizan> stj: haskell doesn't have that kind of overloading
09:30:01 <Saizan> stj: we only have typeclasses
09:30:08 <quicksilver> stj: in general, defining somethign with the same name as a Prelude thing is an ambiguity.
09:30:14 <stj> Saizan: so (+) is only available for instances of Num?
09:30:24 <quicksilver> stj: it's legal, but you should either hide it from the prelude to us it.
09:30:24 <jgr> :t (+)
09:30:26 <lambdabot> forall a. (Num a) => a -> a -> a
09:30:33 <stj> great :)
09:30:34 <quicksilver> stj: not at all. you can use (+) if you want in whatever way you want.
09:30:39 <quicksilver> but you should hide the Prelude one if you do.
09:30:50 <quicksilver> HOWEVER... making Vector an instance of Num might be a better answer
09:30:52 <chris2> i have this code http://sprunge.us/CgfI and wonder if it would be nicer if i used the list monad
09:30:54 <quicksilver> to what your'e actually trying to do
09:31:01 <jgr> you could define a instance of Num and implement + yourself.
09:31:05 <quicksilver> since it is for precisely this kind of thing Num is a typeclass.
09:31:12 <stj> do you maybe have a suggestion, what operator or function name would you use for vector addition, subtraction and multiplicatoin?
09:31:15 <benmachine> you then have to have (*) on vectors though
09:31:26 <benmachine> stj: I've seen .+. used?
09:31:31 <quicksilver> benmachine: not necessarily. You coul djust define (*) = error "* not supported".
09:31:37 <quicksilver> worse things have been done.
09:31:37 <benmachine> quicksilver: true
09:31:46 <stj> jgr: there's a problem: if I make Vector an instance of Num, how can I define abs (Vector x y z) then?
09:31:58 <quicksilver> stj: you just error out on the methods you don't like.
09:32:02 <stj> it should be a Vector, but I want it to be a Double
09:32:15 <quicksilver> however personally I do prefer to use different operator names
09:32:20 <stj> quicksilver: I like abs, I just don't like that abs :: a -> a
09:32:21 <quicksilver> I tend to use ^+^ for vector addition.
09:32:34 <quicksilver> (mnemonic : ^ on boths sides - vector on both sides)
09:32:41 <quicksilver> and then *^ for scalar multiplication
09:32:46 <benmachine> stj: there is some doubt as to whether Num is sensibly defined :)
09:32:53 <quicksilver> (mnemonic: ^ on only one side - vector on only one side)
09:33:02 <stj> quicksilver: interesting, I like this
09:33:03 <benmachine> stj: (e.g. abs on a Complex Double returns a Complex Double)
09:33:32 <parcs`> check out the combinators that vector-space provides
09:33:36 <stj> benmachine: hm yeah, I could just use Vector (x*x+y*y+z*z) 0 0
09:34:29 <benmachine> stj: I think it's probably better to not define it at all :)
09:34:35 <benmachine> (i.e. use error)
09:34:38 <quicksilver> yes, as parcs` hints there are many many vector pacakges on hackage.
09:34:48 <t7> is it possible to derive a writer from a parser (in theory) ?
09:34:58 <quicksilver> I wasn't sure whether you wanted a good vector pacakge, or whether you wanted to explore the language.
09:35:16 <quicksilver> t7: depends how you define a parser.
09:35:35 <quicksilver> t7: if the parser contains , for every primitive, the text form of that primitive, then yes, it is.
09:35:46 <quicksilver> t7: there are papers about such things.
09:36:08 <stj> benmachine: I don't like that... it's quite inconsistent :(
09:36:48 <stj> I won't make Vector an instance of Num... after all it isn't really a number
09:38:13 <Naereen> hello !
09:38:25 <Naereen> Is anybody here ?
09:38:26 <jfischoff> t7: reversible programming is something I fond of. In general if the just composition (of isomorphisms) is used the programs are easy to reverse.
09:38:39 <parcs`> Naereen: just you and 869 strangers
09:38:50 <Naereen> Ok
09:39:01 <quicksilver> t7: ah here it is
09:39:03 <quicksilver> t7: http://hackage.haskell.org/package/invertible-syntax
09:39:07 <Naereen> Is this forum active for anything interesting ?
09:39:11 <quicksilver> t7: there is a paper accompanying that package.
09:39:20 <quicksilver> Naereen: haskell programming is very interesting, yes.
09:39:21 <t7> ah awesome :D
09:39:39 <quicksilver> t7: there have been other things in the past, hopefully that paper has links in its bibliography.
09:39:39 <Bytter> is there a way to do something like this: map ($ [1, 2, 3]) [length, head] , but with a tuple, like (length, head) ?
09:39:41 <parcs`> Naereen: yes this channel is often praised for its interestingness
09:39:56 <Naereen> I'm a Ocaml programmer, Is anybody already know Ocaml ?
09:40:03 <Bytter> or, in other words, are tuples applicative functors?
09:42:25 <benmachine> Bytter: tuples are applicative functors but not in the way you seem to want
09:42:38 <benmachine> Bytter: see, however, the &&& function from Control.Arrow
09:42:52 <parcs`> > flip flip [1, 2, 3] [length, head]
09:42:54 <lambdabot>   [3,1]
09:42:56 <danr> benmachine: are you thinking of the writer monad?
09:43:00 <benmachine> danr: yes
09:45:09 <Bytter> benmachine: &&& seems close to what i'm looking at, thanks
09:45:56 <fmap> > join (***) ($ [1,2,3]) (length, head)
09:45:57 <lambdabot>   (3,1)
09:46:40 <Bytter> > (length &&& head) [1, 2, 3]
09:46:41 <lambdabot>   (3,1)
09:46:44 <Bytter> yay!
09:47:42 <fmap> too easy to understand
09:48:34 <Bytter> fmap: eheh
09:49:33 <Tomsik> :t join (&&&)
09:49:34 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, c)
09:49:43 <Tomsik> :t join (***)
09:49:43 <parcs`> > (flip flip [1, 2, 3] . uncurry (:) . second pure) (length, head)
09:49:44 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
09:49:45 <lambdabot>   [3,1]
09:50:59 <parcs`> > ((flip (&&&) =<< (. tail)) head . flip flip [1, 2, 3] . uncurry (:) . second pure) (length, head)
09:51:01 <lambdabot>   (3,1)
09:51:15 <parcs`> the only way, the best way
09:51:32 <EvanR> theres one way to do it
09:51:34 <EvanR> tm
09:52:13 <Mathnerd314> if you decode all of those into lambdas I bet you get equivalent things
09:52:42 <Tomsik> It's lambdas all the way down.
09:53:13 <Tomsik> world = Turle:world
09:53:20 <EvanR> Ll^`'.
09:55:33 <hiptobecubic> edwardk, any fabulous thesis ideas float by your desk?
09:55:39 <parcs`> @pl \(f, g) x -> (f x, g x)
09:55:39 <lambdabot> uncurry (liftM2 (,))
09:55:46 <edwardk> nothing off hand
09:55:46 <copumpkin> hiptobecubic: thousands, but he charges $10k per idea
09:55:51 <copumpkin> sssh
09:56:00 <edwardk> for $10k i could probably come up with something ;)
09:56:19 <EvanR> not enough
09:56:22 <hiptobecubic> Sure, me too. For 10k i can do a lot of things :)
09:56:54 <hiptobecubic> but it would be a shame for the idea to be worth more than the 8 months of work i have to put into it
09:57:04 <hiptobecubic> Actually no, it wouldn't nevermind.
09:57:22 <hiptobecubic> It would be a shame the other way around I guess.... I'll get my checkbook
10:00:31 <stj> oh, I have another thought... is it a good idea to define Vector as type Vector = (Double,Double,Double) ? The good thing is that it's much easier to type (5,2,1) than Vector 5 2 1
10:01:14 <bitonic> stj: it's not a bad idea in itself, but instantiating that might not be a great idea
10:01:25 <EvanR> how often do you hard code vectors in the source
10:01:46 <EvanR> thats not Zero
10:01:48 <benmachine> EvanR: (x,y,z)
10:01:52 <edwardk> hiptobecubic: no problem. i take paypal
10:02:09 <EvanR> benmachine: i ask again
10:02:10 <benmachine> EvanR: bwim, you don't have to hardcode values to use the vector constructors
10:02:18 <stj> bitonic: why is that so? can you elaborate?
10:02:21 <EvanR> yes
10:02:25 <benmachine> pretty much any function that takes one, surely?
10:02:28 <hiptobecubic> edwardk, Well I have 9 dollars... and a rubik's cube from Optiver.
10:02:40 <hiptobecubic> Collectors edition. Probably worth millions.
10:02:44 <stj> EvanR: that's a valid point :)
10:02:46 <edwardk> stj: you can always use shorter names V 5 2 1   and (5,2,1) are the same length
10:03:05 <EvanR> or v = Vector
10:03:11 <edwardk> yeah
10:03:17 <edwardk> though you can't match with that
10:03:21 <stj> hm, that's ugly... can someone argue why is using (Double,Double,Double) a bad idea?
10:03:30 <edwardk> stj: sure. lets say you have
10:03:32 <bitonic> stj: because if you instantiate that than through all your codebase (and other code if you're releasing that as a library) (Double, Double, Double) will mean vector
10:03:34 <edwardk> data V a = V a a a
10:03:40 <edwardk> now you can define lots of combinators
10:03:42 <EvanR> how often are you gonna match on vector components (except in the lib)
10:03:51 <edwardk> instance Functor V where fmap f (V a b c) = V (f a) (f b) (f c)
10:04:04 <edwardk> Traversable, Foldable, Applicative, Monad
10:04:06 <edwardk> all those things work
10:04:08 <kallisti> GHC's garbage collector is generational copying right?
10:04:16 <edwardk> they actually make it really easy to define vector operations as well
10:04:21 <hiptobecubic> kallisti, yes I think. Whatever that means.
10:04:22 <EvanR> mark and sweep right
10:04:25 <edwardk> instance Num a => Num (V a) where (+) = liftA2 (+)
10:04:35 <stj> I see, good... I'll go with Vector Double ...
10:04:49 <stj> but I won't make vector an instance of num
10:05:20 <EvanR> make it a monoid ;)
10:05:27 <stj> maybe I change my mind later though :) I need more experience... btw, I'm about to code a ray tracer
10:05:43 <kallisti> oh it looks like there's also mark and sweep as well
10:05:50 <hiptobecubic> aren't monads monoids already? in a generalized way i guess
10:05:54 <edwardk> sure. another thing you can do is observe that every (classical) vector space is a free vector space, and so you can make combinators for things like
10:06:05 <EvanR> :t (>>)
10:06:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
10:06:17 <edwardk> (^+^)   :: (Applicative f, Num a) => f a -> f a -> f a; (^+^) = liftA2 (+)
10:06:17 <EvanR> :t (mappend)
10:06:18 <lambdabot> forall a. (Monoid a) => a -> a -> a
10:06:29 <edwardk> under the assumption that your applicative is a representable functor
10:06:31 <kallisti> once the program exceeds a certain percentage of the allowed heap size, GHC uses mark compact collection.
10:06:47 <edwardk> or even (Representable f, Num a) => f a -> f a -> f a
10:07:09 <edwardk> then you can define things like scalar multiplication easily as well
10:07:13 <applicative> if I have a big unboxed vector of ints how do I best write the corresponding file with them all shown on separate lines
10:07:38 <edwardk> (*^) :: (Functor f, Num a) => a -> f a -> f a; (*^) a = fmap (a*)
10:07:56 <edwardk> thats how i actually implement it in a raytracer of mine
10:08:20 <edwardk> the nice thing is because the numeric types are polymorphic i can do things like use automatic differentiation on all my numeric types, vectors, quaternions, etc.
10:08:44 <edwardk> which gives me lots of extra power over and above the boring triple of doubles representation ;)
10:09:15 <applicative> i can read such a file into a vector rapidly with Data.Vector.Unboxed unfold and Data.ByteString.Char8.readInt; but the naive writing I'm capable of is totally clogged
10:09:17 <edwardk> lerp alpha u v = alpha *^ u ^+^ (1 - alpha) *^ v  -- etc
10:09:32 <hiptobecubic> applicative, bytestrings?
10:10:32 <hpaste> applicative pasted “moronic sort test” at http://hpaste.org/68009
10:10:44 <edwardk> another nice thing about this representation is that matrices become very easily indexed as well
10:11:13 <applicative> I am using bytestrings, but something like Builder is needed?  I cant find a connection with the vector package though
10:12:07 <parcs`> edwardk: do you recommend a particular vector/matrix library?
10:12:28 <hpaste> zaphix pasted “Alex monadUserState problems” at http://hpaste.org/68010
10:12:34 <hpaste> applicative annotated “moronic sort test” with “moronic sort test (annotation)” at http://hpaste.org/68009#a68011
10:12:59 <applicative> or rather that ^^ the other was a proof that reading and sorting were instantaneous
10:13:20 <zaphix> Re: my paste, can someone help me out with understanding expected Alex behavior?  I would think that if I fed the generated lexer the string "foo bar\n" using the lexer spec as given, I should get the @ident rule firing for the rule "@ident"
10:13:25 <benmachine> aw I was hoping that applicative's link would demonstrate the moronic-sort algorithm
10:13:40 <zaphix> and furthermore, the input string would be (presumably) "foo"
10:14:09 <nand`> I'm having some difficulties defining the order of monad transformer compositions. I want to define MyMonad as a composition of (ErrorT String), (WriterT [Int]) and (StateT MyState) and finally IO; in a way that lets me easily define: run :: MyMonad () -> Either String (MyState -> (MyState, [Int]))
10:14:14 <applicative> haha, benmachine i  can do that too. I was claiming that vector-algorithms radix sort is the natural way of doing this sort of thing
10:14:20 <benmachine> edwardk: btw, what do you mean by (classical) re: free vector spaces?
10:14:26 <nand`> in short; I want to define computations that have the ability to either fail or transform a state while producing output
10:14:29 <applicative> but the writing is beyond  me
10:14:57 <nand`> sorry; run :: MyMonad () -> IO (Either String (MyState -> (MyState, [Int])))
10:15:27 <edwardk> parcs: i have a little one baked into my raytracing engine (it consists of just a few modules), but for the most part i use what i used in 'ad' which is i turn to traversable or functor to deal with indices for vector types, and sidestep the whole issue
10:15:44 <benmachine> @unmtl ErrorT String (StateT MyState (WriterT [Int])) ()
10:15:44 <lambdabot> Plugin `unmtl' failed with: `WriterT [Int] (Either String (), MyState)' is not applied to enough arguments.
10:15:51 <benmachine> huh.
10:16:01 <benmachine> @unmtl ErrorT String (StateT MyState (Writer [Int])) ()
10:16:01 <lambdabot> MyState -> (Either String (), MyState, [Int])
10:16:07 <benmachine> oh
10:16:34 <edwardk> benmachine: i mean that the result that proves that every vector space is a free vector space (unlike how there do exist non-free modules) uses classical logic, so you need double negation elimination, and its not a result you can always claim in a constructive computational environment
10:16:35 <benmachine> and I forgot IO anyway
10:16:42 <nand`> @unmtl StateT MyState (WriterT [Int] (ErrorT String IO)) ()
10:16:43 <lambdabot> MyState -> IO (Either String ((), MyState, [Int]))
10:16:51 <edwardk> benmachine: i don't have a counter example, but i also don't have a proof that works that none exists ;)
10:17:24 <benmachine> edwardk: but vector spaces are still characterised by dimension, it's just that we can't always find a dimension?
10:17:31 <applicative> Ah, smashing improvement.  I was stupidly using lazy bytestring to write when I'm just writing one little line after another
10:18:08 <edwardk> benmachine: correct. you can make that claim classically, but you may not be able to compute that dimension constructively
10:18:52 <benmachine> edwardk: hmm. what if you are classical but you don't take choice, so you can't prove every vector space has a basis?
10:18:56 <edwardk> benmachine: in 'algebra' i represent a free module as a function from a basis or a representable functor with a given basis representation
10:19:10 <edwardk> benmachine: not sure. haven't worked it out in detail
10:19:26 <aristid> how far on the evilness scale is OverlappingInstances? i think it'd give me a nice amount of convenience
10:19:42 <benmachine> aristid: second only to Incoherent, in my view
10:19:54 <edwardk> aristid: it is pretty much off the bad end of the scale
10:20:00 <benmachine> I would personally never use it
10:20:06 <rwbarton> Incoherent is slightly worse than Overlapping which is much worse than any other extension
10:20:27 <edwardk> Overlapping and Incoherent instances are usually a sign that you've done something terribly wrong and should be sucking it up and using a newtype somewhere
10:20:34 <benmachine> heh
10:21:11 <edwardk> in fact with more recent type system extensions i'm pretty sure that incoherent is as evil as it gets ;)
10:21:25 <edwardk> with constraint kinds, you can do horrible horrible things in the presence of incoherent instances
10:21:33 <rwbarton> my suspicion is that overlapping instances already gives you those horrible things
10:21:40 <edwardk> and overlapping instances as well
10:21:40 <edwardk> yeah
10:21:54 <applicative> the hatred of newtyping is the root of all evil
10:21:55 <c_wraith> I don't even understand incoherent instances. The logic seems to match the name
10:22:11 <c_wraith> applicative: actually type String = [Char] is the root of most
10:22:12 <aristid> well, what i'm trying to do is have a configuration type that can store configuration for a number of services, and can be passed around
10:22:21 <benmachine> edwardk: which horrible things?
10:22:34 <edwardk> incoherent instances is okay, when all you get out of it is a performance optimization with no other observable effects
10:22:37 <applicative> c_wraith: hm, maybe
10:22:40 <benmachine> c_wraith: eh, there are worse things in the world
10:22:48 * byorgey would be interested to see an example of  ConstraintKinds + OverlappingInstances --> horrible things
10:22:51 <aristid> what i have right now is something like this: data Config = Config { commonStuff :: Blah , service1Config :: Service1Config, service2Config :: Service2Config }
10:23:11 <edwardk> benmachine: you can make a forall a. Dict (Foo a) using the constraints package, then use unification to instantiate it for the more refined type
10:23:12 <rwbarton> unsafeCoerce is the horrible thing I had in mind
10:23:38 <edwardk> byorgey: i'll see if i can dig up my toy
10:23:39 <rwbarton> I haven't tried to actually implement this though because I don't really care about understanding exactly *how* bad OverlappingInstances is :P
10:23:47 <aristid> now with overlapping instances i could do something like data BaseConfig = { commonStuff :: Blah } and data WithService s o =  WithService s o
10:24:07 <aristid> and then i'd have WithService Service1Config (WithService Service2Config BaseConfig)
10:24:11 <byorgey> see, I was under the impression that Overlapping was only kind of bad, and Incoherent was horrible
10:24:22 <byorgey> which is why I'm interested to see an example of Overlapping --> horrible
10:24:24 <aristid> and i could use overlappinginstances to get those configs out
10:24:28 <benmachine> edwardk: I don't follow but I'm not that worried about it :P
10:24:37 <aristid> so that'd be evil?
10:25:22 <bitonic> byorgey: the manual has it
10:25:28 <edwardk> benmachine: a representable functor 'f' is a functor such that forall a, there exists an x such that 'f a' is isomorphic to 'x -> a'
10:25:28 <Ngevd> Hello
10:25:31 <mekeor> hi
10:25:46 <bitonic> byorgey: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-overlap , search for "Warning"
10:26:04 <edwardk> benmachine: class Representable f where type Key f; tabulate :: (Key f -> a) -> f a; index :: f a -> Key f -> a
10:26:07 <byorgey> bitonic: ah, thanks
10:26:11 <benmachine> edwardk: okay
10:26:26 <edwardk> benmachine: given that its easy to construct the functor, distributive law, monad, applicative, even a comonad
10:26:33 <Ngevd> Any news on the disappearing hackage guy
10:26:36 <bitonic> byorgey: it's pretty tricky
10:27:17 <byorgey> Ngevd: he hasn't disappeared.  He just doesn't respond very quickly.
10:27:19 <aristid> barely 886 nicks, and the channel is already hard to follow oO
10:27:21 <bitonic> byorgey: all in all I think that "Don't use Overlapping" is a good guideline. and the Overlapping solution is probably not the nicest one anyways
10:27:22 <hpc> edwardk: that looks like a useful thing for agda to have
10:27:23 <edwardk> benmachine: an (infinite) free module can be represented as just a function e -> r  for some basis e. i say infinite because classically we put the infinity in the wrong place and require that the vector have only a finite number of non-zero entries.
10:27:26 <Ngevd> byorgey, okay
10:27:35 <Ngevd> I guess I'm just impatient
10:27:53 <aristid> bitonic: did you see my specific problem, too? :)
10:27:57 <benmachine> edwardk: wait wait, I was talking about the Dict thing
10:28:01 <bitonic> aristid: nope
10:28:06 <benmachine> although this is interesting too so I might just go with it
10:28:28 <rwbarton> wrong place, what
10:28:46 <benmachine> (although I didn't understand what you meant by constructing the monad etc.)
10:28:53 <hpaste> aristid pasted “Test for configuration with OverlappingInstances” at http://hpaste.org/68013
10:29:34 <edwardk> benmachine: in my experience, the correct constructive definition is to choose to use an infinite free module, but use the fact that its constructive to change the way we construct the covectors for that space, so covectors become (e -> r) -> r where the result arrow is subject to a linearity condition. this ensures that you only inspect the e -> r a finite number of times, moving the finite number of non-zeroes to the covectors, rath
10:29:35 <edwardk>  the vectors where it couldn't be enforced
10:29:51 <aristid> thanks hpaste, good bot. what i'm thinking about is using such a mechanism to have a kind of extensible configuration
10:29:58 <edwardk> (e -> r) -> r forms a monad that works a lot like Cont, in fact return, >>=, etc are all linear operators.
10:30:18 <benmachine> edwardk: "non-zeroes to the covectors, rath"
10:30:28 <edwardk> the only thing you can't do with it that you can do with Cont more or less is multiply the resulting r's (due to linearity) and you can't use callCC
10:30:41 <edwardk> 'rather than the vectors where it couldn't be enforced'
10:31:18 <edwardk> basically i use infinite free modules where the covectors are constrained to inspect the vector at a finite number of points rather than finite free modules where the covectors can inspect the vector at infinitely many points
10:31:39 <edwardk> using the representability of a functor which is representable by the basis of your vector space gives you a way to memoize these
10:32:08 <edwardk> and you get a monad for covectors, which means kleisli arrows of the covector monad are linear transformations
10:32:29 <edwardk> a -> Covector r b   is a linear transformation from a vector space with basis b to one with basis a
10:32:39 <benmachine> edwardk: (incidentally, "the vectors where it couldn't be enforced" got split into a new message, suggesting something is trying to split your lines but doing it wrong)
10:32:42 <edwardk> and all the usual tensoring operations just follow as the usual monadic operations
10:33:03 <edwardk> benmachine: textual probably cuts off the lines a dozen characters too late
10:33:20 <aristid> bah, now i know that overlappinginstances are evil evil evil, but don't know a good alternative
10:33:52 <edwardk> rwbarton: did that explanation make sense?
10:34:22 <rwbarton> I was just rankled at the term "wrong"
10:34:24 <edwardk> https://github.com/ekmett/algebra/blob/master/Numeric/Covector.hs is the covector monad in question
10:34:37 <edwardk> well, wrong in the sense that it seems wrong to me from a constructive point of view =P
10:34:55 <rwbarton> well it is surely the right definition of "free module" regardless of classical logic
10:35:05 <rwbarton> it's just that free module seems to be not the notion that you want
10:35:07 <edwardk> if you use the classical presentation then things get all screwed up when you add infinite dimensional vecto spaces
10:35:31 <rwbarton> possibly "vector space" is not even the notion that you want
10:35:44 <rwbarton> if you want the dual thing to be like a normal free vector space on e
10:35:50 <edwardk> yes, hence why i said, i wanted an infinite free module with restrictions on the covectors, because otherwise when you allow 'e' to be an infinite basis (as it becomes when you work with covectors) everything goes to hell
10:36:04 <rwbarton> anyways I wasn't paying a whole lot of attention since there seemed to be no theory behind it :P
10:36:29 <edwardk> what i have now is that vectors are e -> r, and covectors are (e -> r) ->_L r subject to the linearity on the arrow i labeled _L
10:37:41 <edwardk> the usual formulation is some mishmash where vectors are something like [(e,r)] which you have to normalize the crap out of, but then the relationship between covectors and vectors for that space really only work for the finite cases
10:38:44 <edwardk> this is sort of the main difference between HaskellForMaths (which uses the [(e,r)] approach) and the 'algebra' package
10:39:13 <benmachine> aristid: I don't think I understand why you want a typeclass for this - why use the same 'get' name for getting A and getting B?
10:39:15 <edwardk> the monad in haskell for maths you kind of need to constantly apologize for because it keeps mucking up your normalization
10:39:30 <edwardk> the one in algebra for covector is never violating any laws
10:39:38 <aristid> benmachine: so i don't have to create many get functions
10:39:51 <stj> suppose I have data Vector = Vector { getX :: Double, getY :: Double, getZ :: Double } -- now, why isn't it possible to instantiate a vector as Vector 0 0 0?
10:40:12 <benmachine> stj: isn't it?
10:40:20 <edwardk> rwbarton: as for theory i can spent a lot more time belaboring it, but i was giving a quick off the cuff explanation to benmachine, not writing a dissertation ;)
10:40:36 <benmachine> edwardk: I think it was beyond me a little >_>
10:40:40 <benmachine> I mean I got some of it but
10:40:41 <edwardk> stj: that works fine
10:40:58 <tgeeky> stj: those are 0 values, not 0 types (not Void)
10:40:59 <benmachine> aristid: how many functions would it be, really?
10:41:15 <edwardk> benmachine: fair nuff =)
10:41:15 <tgeeky> stj: if that's what you were thinking of
10:41:39 <aristid> benmachine: well, currently 4. could end up being 30
10:41:45 <rwbarton> I don't really care. I just don't like when people say things like "classically we put the infinity in the wrong place". free is a technical term and there is no doubt about the right definition. people may get confused that the free module is not actually free, or something
10:41:59 <benmachine> aristid: but surely it is only as many as you have types anyway
10:42:08 <benmachine> aristid: so it's not like, a lot of *extra* complexity
10:42:17 <edwardk> rwbarton: ah. in that sense, i agree with you
10:42:28 <hpaste> stj pasted “instantiating Inter” at http://hpaste.org/68014
10:42:37 <benmachine> rwbarton: if it helps, I read "wrong" as "inconvenient" or "awkward"
10:42:51 <aristid> benmachine: what do you mean with extra?
10:43:12 <aristid> benmachine: it'd be as many extra functions as there are services, which of course each have a configuration type
10:43:23 <benmachine> aristid: I mean, you only need a lot of get functions if you already are dealing with a lot of types
10:43:23 <edwardk> rwbarton: by 'wrong' i meant 'in a place that mucks up a perfectly good construction in a constructive logic' ;)
10:43:34 <benmachine> aristid: by which time you already need a lot of handling code for them
10:43:36 <kallisti> sjl: the problem is Intert
10:43:44 <kallisti> sjl: Inter $ (Vector 5 5 2) 11 False
10:43:51 <aristid> benmachine: this is the whole handling code
10:43:54 <kallisti> is the same as Inter (Vector  5 5 2 11 False)
10:44:03 <benmachine> stj: drop the $
10:44:14 * applicative has done his best on the 'surely haskell can't be that slow' front, a week late alas http://stackoverflow.com/questions/10357663/python-faster-than-compiled-haskell/10436356#10436356
10:44:14 <stj> oh, sorry guys... my bad
10:44:40 <tgeeky> @src ($)
10:44:40 <lambdabot> f $ x = f x
10:45:29 <edwardk> sjl: if you are going to go monomorphic with Double you may want to use
10:45:45 <stj> about records... do you have some kind of good naming scheme? it's very easy to pollute the namespace with lots of function names... and, do you find that cumbersome and ugly?
10:45:54 <edwardk> data Vector = Vector { getX :: {-# UNPACK #-} !Double, getY :: {-# UNPACK #-} !Double, getZ :: {-# UNPACK #-} !Double }
10:46:08 <edwardk> sjl: that will make it slightly more strict
10:46:18 <stj> edwardk: no idea what monomorphic here means
10:46:33 <kallisti> the opposite of polymorphic
10:46:34 <stj> edwardk: what does that do, how's it stricter?
10:46:38 <edwardk> stj: as opposed to data Vector a = Vector { getX, getY, getZ :: a }
10:46:43 <stj> I see
10:47:04 <stj> oh... those UNPACKs confuse me
10:47:09 <stj> I know about bangs
10:47:34 <edwardk> The data Vector a = makes up a box, with pointers to boxed doubles. data Vector = Vector !Double !Double !Double also makes a box with 3 pointers to boxed doubles
10:47:51 <applicative> vector defined edwards way are more like Int or Double themselves
10:47:53 <edwardk> the data Vector = Vector {-# UNPACK #-} !Double …. version makes up a single box with 3 machine doubles stored in it
10:48:06 <benmachine> applicative: the text package has some facilities for showing things without going via String
10:48:08 <edwardk> rather than 3 calculations that when forced each will yield a double
10:48:19 <applicative> benmachine: hmm, i will look
10:48:28 <benmachine> applicative: http://hackage.haskell.org/packages/archive/text/0.11.2.0/doc/html/Data-Text-Lazy-Builder-Int.html
10:48:41 <tgeeky> edwardk: that sounds like a C struct kind of thing. more low level.
10:49:25 <stj> edwardk: a bit ugly, but I like what it does
10:49:41 <benmachine> edwardk: aren't strict fields sometimes unboxed even without the ugly pragmas?
10:49:48 <edwardk> Vector a b c ^+^ Vector d e f = Vector (a + d) (b + e) (c + f)   -- means different things in each. your original formulation it winds up lazily evaluating each addition only when you finally look at that field, in the UNPACK'd version matching on the vectors brought into scope machine level doubles, and constructing the new Vector packed them back in, so there is only one lazy thunk constructed, for the whole new Vector
10:49:55 <edwardk> bens: -funbox-strict-fields
10:50:02 <edwardk> benmachine: i don't tend to use it
10:50:03 <tgeeky> edwardk: so that would be the same for some rediculious 125-vector space or whatever. It would give you all 125 values at once, or none?
10:50:17 <edwardk> tgeeky: yep
10:50:46 <edwardk> tgeeky: the benefit of using the !'s is that there is only one place for a bottom to hide (at the top) and that the compiler can know it doesn't need to jump into the thunk to evaluate it.
10:51:14 <kallisti> -funbox-strict-fields sound lioke a bad idea. Since not all strict records benefit from unboxing.
10:51:20 <edwardk> i have a lot of code where i wind up very carefully using both ! and {-# UNPACK #-} !  in different places, and -funbox-strict-fields removes a performance optimization tool from my toolbox
10:52:13 <tgeeky> edwardk: neat! Is that the same thing as saying that each letter in Vector a b c ... z is in WHNF? Or HNF?
10:52:24 <edwardk> tgeeky: WHNF yeah
10:52:36 <benmachine> edwardk: apparently there is a NOUNPACK pragma these days
10:52:46 <benmachine> so -funbox-strict-fields only chagnes the default
10:52:50 <stj> edwardk: is there a clear definition somwhere on the internet saying what a thunk is? I've been trying to find it but none are satisfying
10:52:55 <edwardk> tgeeky: where as with the unpack its actually secretly a Double# that gets wrapped in a double constructor when you match on it
10:53:09 <edwardk> benmachine: ah neat
10:53:15 <kallisti> edwardk: what happens you attempt to unpack, say, a HashMap
10:53:22 <kallisti> *when you
10:53:37 <edwardk> stj: you may find the ghc commentary useful. also the eval/apply vs push/enter paper
10:54:23 <nand`> I can use SomeException to catch any exception; but can I exclude ExitSuccess from this? (or re-throw it)
10:54:41 <kallisti> stj: in very non-technical terms it's a machine representation for unevaluated code.
10:54:45 <edwardk> stj: http://research.microsoft.com/apps/pubs/default.aspx?id=67488
10:54:56 <kallisti> nand`: yeah you can use cast from Data.Typeable to pattern match it.
10:55:06 <stj> edwardk: awesome, thanks
10:55:07 <kallisti> because all Exceptions are also Typeable.
10:56:08 <nand`> kallisti: that works, thanks
10:56:10 <edwardk> stj: http://research.microsoft.com/apps/pubs/default.aspx?id=67083 may also be useful
10:56:14 <tgeeky> edwardk: I was thinking about this last night. MagicHash is just a rule that says it's possible to use "#" in places you otherwise couldn't. But there isn't a rule about the number of "#"s you can use, right? Couldn't you make a rule that things like "Double##" is a pair of doubles, "Double####" is a 4-tuple of doubles?
10:56:35 <benmachine> kallisti: can't you also use fromException or something
10:56:47 <edwardk> tgeeky: what is the difference from that and just using (# Double#, Double# #) which you can say today?
10:56:59 <edwardk> tgeeky: that representation has the benefit of being able to mix and match types
10:57:13 <edwardk> e.g. (# Double#, State# RealWorld, Int #)
10:57:34 <tgeeky> edwardk: compactness. For 16-doubles, it might be: (Double####, Double####, Double####, Double####)
10:57:40 <tgeeky> and they would expand out, in place
10:57:40 <kallisti> benmachine: oh. yeah.
10:57:48 <tgeeky> so you have the benefit of mixing and matching still
10:57:50 <kallisti> nand`: yeah you can use fromException as well. I forgot about that.
10:57:51 <edwardk> tgeeky: well, in practice if you need 16 doubles you're going to be screwed anyways by the stg calling conventions ;)
10:58:02 <benmachine> nejucomo: fromException might be neater
10:58:06 <benmachine> aaah
10:58:12 <benmachine> nejucomo: I suck at tab completion, ignore me
10:58:17 <benmachine> and you already said it anyway
10:58:30 <edwardk> i rather prefer the existing unboxed tuples, i think the Double#### approach would be just one-off sugar
10:58:32 <kallisti> nand`: the default implementation of fromException is cast, but it can also be overriden since it's a method of Exception.
10:58:38 <tgeeky> edwardk: well, the general pattern I'm talking about of course is handling repunits in the haskell namespace
10:58:42 <nand`> kallisti: right
10:59:01 <edwardk> type Double4# = (# Double#, Double#, Double#, Double#) ;) done, now your language proposal is more or less in a library ;)
10:59:18 <tgeeky> edwardk: hehe, touche on that particular example.
10:59:43 <nand`> kallisti: do you know what exception type “user interrupt” is? (from C^c)
10:59:57 <kallisti> AsyncException
11:00:08 <kallisti> the constructor is called UserInterruot
11:00:11 <kallisti> spelled correctly
11:00:13 <edwardk> anyways, the times are few and far between when I am passing around a huge homogeneous mass of arguments like there
11:01:02 <edwardk> more common are examples like https://github.com/ekmett/precision/blob/master/src/Numeric/Rounded.hs#L93
11:01:04 <kallisti> knowing the type is unneccessary though. if you just do  case fromException e of Just UserInterrupt -> ...; _ -> ...
11:01:17 <edwardk> where i still have up to a half dozen things coming back in an unboxed tuple, but they are rather heterogenous
11:01:19 <kallisti> it will infer AsyncException
11:02:02 <DaBob> hi
11:02:03 <edwardk> (well, there i'm constraining myself to a few results, and a few arguments to avoid overflowing the register support of foreign prims)
11:02:54 <tgeeky> edwardk: this package is very cool.
11:03:32 <edwardk> tgeeky: it has some issues until copumpkin gets around to fixing the gc hack
11:03:52 <DaBob> i got an error and i realy dont know why ;) im a beginner with haskell maybe someone canhelp me with this...
11:03:53 <edwardk> tgeeky: but it should work pretty well after that. (right now it works great from ghc but sporadically from ghci)
11:04:24 <DaBob> This is my code: data Codebaum a = Leave a | Node (Codebaum a) (Codebaum a)  kodiere :: Eq a => (Codebaum a) -> [a] -> [Int] kodiere _ [] = [] kodiere (Node l r) x:xs = [1]
11:04:53 <kallisti> edwardk: did I ever show you my IncoherentInstances hack in interpolatedstring-perl6  that could probably be rewritten as RULES but I can't seem to get any of them to fire properly...  ?   (what a sentence)
11:04:54 <DaBob> and the error i get is: parse error in pattern kodiere
11:05:25 <edwardk> kallisti: not off hand
11:05:35 <edwardk> kallisti: just using it to get a performance boost?
11:05:39 <kallisti> yes.
11:05:47 <edwardk> then i have no objection ;)
11:05:58 <kallisti> I do have to constraint a typeclass though
11:06:03 <edwardk> i used to have a lot of those
11:06:07 <kallisti> I mean
11:06:15 <kallisti> as in, "if you don't follow this rule unexpected things will happen"
11:06:26 <edwardk> *nods*
11:06:37 <ennui> DaBob: try this one http://pastie.org/paste/3855049
11:06:39 <edwardk> i require that to use Data.Constraint.Unsafe.applicative as well ;)
11:07:07 <kallisti> basically the optimization is that there's no need to convert to/from String in order to interpolate one IsString into the same IsString.
11:07:08 <edwardk> if you have an applicative for the monad in question that isn't compatible with the monad then the result is undefined
11:08:02 <kallisti> http://hackage.haskell.org/packages/archive/interpolatedstring-perl6/0.9.0/doc/html/Text-InterpolatedString-Perl6.html see the ShowQ class.
11:08:06 <edwardk> fair nuff, kind of like the realFrac RULES for Double -> Double and Float -> Float
11:08:15 <edwardk> which are actually semantics changing
11:08:21 <kallisti> ShowQ itself is not incoherent (though it is overlapping with the Shoq a => ShowQ a instance)
11:08:32 <kallisti> there's an internal class that does the optimization.
11:08:38 <DaBob> ok thanks very much ennui xD
11:08:51 <edwardk> have you measured a performance difference?
11:08:55 <kallisti> nope.
11:09:03 <kallisti> it just seems wrong
11:09:08 <kallisti> to convert needlessly.
11:09:31 <kallisti> (aka I have a bad habit of premature optimization)
11:09:41 <edwardk> i can empathize ;)
11:10:45 <kallisti> but it can interpolate Text into Strings and Strings into Text and Text into Text and ByteString into ByteString, and it's still equally efficient as the previous version in all of the cases where the 2 types are the same.
11:10:51 <kallisti> totally worth horrible typeclass hacks. :P
11:11:31 <ennui> here are two versions of a trivial two-line function. what's more preferable/idiomatic: the first or the second version? http://pastie.org/paste/3855035
11:11:35 <hpaste> nand` pasted “exception handler” at http://hpaste.org/68016
11:11:42 <kallisti> actually interpolating with ByteStrings might result in runtime errors, no?
11:11:59 <nand`> disregard my paste, I just realized what's wrong
11:12:16 <kallisti> oh nevermind.
11:12:19 <kallisti> yeah I alreay tested that.
11:12:58 <jfischoff> edwardk: I noticed that data-lens is getting more arrow like. Is arrow choice-like functionality on the way?
11:12:58 <kallisti> edwardk: I guess there's actually no real benefit to using RULES
11:13:07 <kallisti> edwardk: since both are potentially semantics changing
11:13:19 <nand`> any ideas how I can write something similar in nature to what I pasted but that actually works? all I can think of is nesting lots of fromException (aka cast) but that has me indent a further line for each match
11:13:22 <edwardk> jfischoff: not sure what roconnor intends on that front.
11:13:31 <edwardk> kallisti: yeah
11:14:00 <tgeeky> kallisti: I always get the feeling when I say something like that, that some GHC internal library crucially depends on it to make performance reasonable.
11:17:25 <Dtgr> :t flip
11:17:26 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
11:18:34 <parcs`> tgeeky: realToFrac and fromIntegral rely on RULES to be reasonably efficient
11:18:51 <edwardk> realToFrac makes me sad every time i see it
11:19:34 <parcs`> why?
11:19:43 <hpaste> nand` annotated “exception handler” with “exception handler (annotation)” at http://hpaste.org/68016#a68017
11:19:54 <nand`> ^- any ideas to improve this?
11:20:00 <edwardk> i've taken to just making a class FromFloat f where fromFloat :: Float -> f   and class FromDouble d where fromDouble :: Double -> d  -- so i don't have to rely on horrible non-semantics preserving transformations
11:20:10 <kallisti> heh, you could actually define (orphan) IsString and ShowQ instances for Builder and the interpolate Builders together Perl 6 style.
11:20:11 <edwardk> that way at least my code runs the same in ghc and ghci
11:21:22 <kallisti> nand`: you could always just use multiple exception handlers
11:21:24 <kallisti> with catches
11:22:05 <nand`> kallisti: that sounds like a better idea
11:22:17 <kallisti> or even nested exception handlers
11:22:22 <parcs`> you also have to make sure to define RULES for newtype wrappers of numeric types otherwise fromIntegral and realToFrac will be like 15x slower
11:22:29 <kallisti> if you put the UserInterrupt and ExitSuccess handlers on the outside
11:22:37 <kallisti> otherwise they'll rethrow and then the SomeException handler will catch it.
11:22:48 <kallisti> (catches prevents all of these issues from happening at all, though)
11:23:08 <parcs`> i'm not sure why RULES don't fire for newtype wrappers
11:23:43 <kallisti> edwardk: oh my. I just realize 2 out of 3 contributions to Hackage are unsafe hacks. :P
11:24:36 <edwardk> kallisti: i've lost count of mine =)
11:24:51 <kallisti> I think unsafe-promises has legitimate uses though.
11:25:00 <kallisti> in terms of simplifying code
11:25:07 <edwardk> *nods*
11:25:29 <hpaste> nand` annotated “exception handler” with “exception handler (annotation) (annotation)” at http://hpaste.org/68016#a68020
11:25:40 <edwardk> i've actually constructed something similar in the past, and i'm a fan of the approach
11:25:59 <kallisti> it's very clean, as long as you're marginally careful.
11:26:34 <kallisti> it reminds me of something like "par for IO computations"
11:26:36 <tgeeky> edwardk: yeah, but we trust your hacks. your hacks are cheeky and fun. his hacks are cruel and tragic. which makes them not hacks at all, really. evil hacks!
11:26:43 <tgeeky> --> http://www.youtube.com/watch?v=MFZG8KQJni8
11:26:54 <edwardk> =)
11:27:31 <kallisti> nand`: looks good to me.
11:27:32 <tgeeky> i'm pround that 100% of my hackage publications are safe-inferred!
11:27:38 <tgeeky> pround? proud.
11:27:44 <kallisti> actually so is unsafe-promises apparently
11:27:50 <kallisti> I'm not sure how it goes about inferring safety.
11:28:08 <tgeeky> kallisti: probably not through the package name, at least.
11:28:12 <kallisti> I would think unsafeInterleaveIO raises some flags.
11:28:26 <kallisti> but I guess not.
11:28:50 <edwardk> safe-inferred is pretty easy to get even for stuff that makes me queasy to consider safe ;)
11:29:26 <kallisti> oh, maybe I should add a TotallyTrustworthyIPromise pragma then
11:29:53 <kallisti> I even tested it for about 30 minutes in GHCi, spotted a bug, and fixed it.
11:29:57 <kallisti> that's pretty legitimate.
11:30:37 <edwardk> kallisti: better than what i usually do =P
11:31:04 <edwardk> {-# LANGUAGE ItCompilesSoOfCourseItIsCorrect #-}
11:31:25 <kallisti> yeah I've found how horrible of a mistake that is to make
11:31:30 <kallisti> with webdriver.
11:31:40 <kallisti> where there's runtime error potential everywhere.
11:31:51 <edwardk> works a lot better when you don't actually have any concrete types. then parametricity gives you a lot of extra correctness guarantees ;)
11:31:58 <kallisti> but your code isn't very IO heavy.
11:32:04 <kallisti> so that's a pretty reasonable assumption.
11:32:04 <edwardk> yeah most of it isn't
11:32:55 <edwardk> the algebraic/categorical stuff works pretty well that way. other stuff i just try to parameterize the bejeezus out of, mostly because it helps enforce correctness, even if i later make the types more concrete
11:33:19 <benmachine> I only have one package on hackage that I actually wrote myself, and it was mostly "hey look at this cool idea" rather than "hey look at this thing you can actually use"
11:33:42 <kallisti> edwardk: write a magically compile-time safe JSON parser and I'll definitely use it. :P
11:33:51 <Eidel> "MyData = Empty | Double" and "MyData d = Empty | Double" Whats the difference?
11:33:57 <zzo38> Which other alternative Prelude files are there? I tried to make up one such things too
11:34:23 <tgeeky> zzo38: air. AwesomePrelude. NumericPrelude.
11:34:23 <kallisti> Eidel: they're both syntax errors
11:34:35 <kallisti> but I'm guessing you mean
11:34:41 <kallisti> data MyDate = Empty | Double
11:34:44 <kallisti> *data
11:34:52 <kallisti> and then the difference is that the second one has a type parameter
11:34:59 <kallisti> that does nothing. it's a phantom type.
11:35:05 <hpc> Eidel: it's roughly the difference between (x = True) and (f x = True)
11:35:11 <hpc> Eidel: only at the type level
11:35:25 <hpc> Eidel: in your second example, 'd' is a phantom type
11:35:30 <zzo38> It is like (Constant Bool)
11:35:48 <Eidel> Ok
11:35:51 * kallisti is bad at explaining things today; and typing.
11:36:09 <Eidel> Thanks
11:36:17 <Eidel> I think i understand =P
11:36:26 <zzo38> tgeeky: What features are their similarity and difference, and what is their similarity and difference to my program, and what opinions doyou have of such things too?
11:37:05 <tgeeky> zzo38: my opinions don't matter. Air is meant to feel something like ruby, and I enjoyed reading it. It does some tricks with ($) and (.) that I like too.
11:37:22 <kallisti> edwardk: for my next project I'm going to try out takusen. I'm interested in how it can possibly manage to make SQL queries more runtime-safe.
11:37:24 <tgeeky> zzo38: never used AwesomePrelude, but supposedly it's pretty awesome.
11:37:29 <tgeeky> zzo38: I don't know of your prelude.
11:38:15 <zzo38> tgeeky: That is why they would call it AwesomePrelude, I suppose. But, I will show you what I have so far:   http://sprunge.us/EWiI   In case anything you think is wrong or omitted, tell me I could correct it
11:38:24 <tgeeky> dmwit: jfischoff: https://github.com/technogeeky/pi-eta-epsilon/blob/master/dualities.hs#L126 . I can't tell if that's more or less readable than before, but it's somewhat cute
11:38:50 <kallisti> there's also a postgres library that uses a TH hack to verify the correctness of queries at compile-time by actually reading from the database.
11:38:56 <kallisti> I'm not sure if I like that approach.
11:39:26 <tgeeky> zzo38: are you trying to make sure all the functions in the Prelude are total?
11:39:52 <zzo38> tgeeky: Not entirely.
11:40:27 <jfischoff> tgeeky: works for me. I'll add this to some changes I haven't pushed yet. Mainly separated the syntax and evaluator, added some Arbitrary instances
11:40:48 <tgeeky> jfischoff: ok. at some point I'm going to need to figure out how to run the machine, etc.
11:40:53 <zzo38> The way I have it, some of the error messages may change if optimization is enabled, but the operation of the program in general should never change with or without optimization.
11:42:02 <Eidel> Does anyone know what the '!' in !(MyData a) is used for?
11:42:13 <tgeeky> zzo38: you have Peano (and church) encodings for the naturals, but don't have anything whatever to say about Ord?
11:42:18 <zzo38> Eidel: It is used for strictness setting
11:42:34 * hackagebot circ 0.0.2 - A Compiler IR Compiler.  http://hackage.haskell.org/package/circ-0.0.2 (TomHawkins)
11:42:39 <zzo38> tgeeky: What would you expect to say about Ord?
11:42:39 <tgeeky> Eidel: think of it as saying "I need this now!"
11:43:12 <tgeeky> zzo38: I figured you would provide ord for Peano numbers?
11:43:30 <Eidel> tgeeky: Hmm seems like a strange thing to define
11:43:30 <zzo38> I do have the function called atLeast which is like a short circuiting Ord
11:43:36 <zzo38> tgeeky: OK, I will add that instance
11:44:22 <tgeeky> zzo38: it's a pretty interesting mix. I have a personal prelude project going on, and I have some ideas about things I'd like to do.
11:45:20 <tgeeky> zzo38: one of the important ones to me was to have a Haddock annotation that is an "explanation for why one is making a change" to the Prelude.
11:46:17 <zzo38> tgeeky: But the Haddock annotations are for the individual functions and types isn't it? If I wanted to explain the entire package that goes in the .cabal file isn't it?
11:48:20 <tgeeky> zzo38: yes. The point is, you better have a damn good reason for changing the Prelude. Say, you think it's abhorent that the Prelude has partial functions. I don't remember the list, but let's say it's (head, !!, tail). You make a differential Prelude which imports hiding (head, !!, tail), exports those three, and have annotations for the set which say "I didn't want any partial functions in the Prelude."
11:49:14 <tgeeky> zzo38: each custom Prelude might would have a set of these things, which are just the changes you are proposing.
11:49:17 <avpx> Would someone please explain to me why this kind of instance is illegal? http://pastebin.com/QHKQT5ca
11:49:19 <mauke> The paste QHKQT5ca has been copied to http://hpaste.org/68023
11:49:30 <dekuked> hey, what does this mean?: https://gist.github.com/2588066
11:49:30 <tgeeky> lol!
11:49:43 <dekuked> what does the *Poly* mean?
11:49:48 <dekuked> I get the rest, just not that part
11:49:52 <ben> It's a new name
11:50:06 <ben> a Shape is either a Circle foo bar or a Poly foo
11:50:17 <zzo38> tgeeky: The reason I have different head !! tail is to generalize to different types:   tail :: MonadLogic m => m x -> m x;  (!!) :: (Copeanoid i, Foldable t) => t x -> i -> x;  head :: Foldable t => t x -> x;   (I have also added pragmas to make them use the old one when the type matches)
11:50:31 <dekuked> ah, okay
11:50:56 <ben> It's apparently a Shape that consists of a list of Vectors, so probably a polygon with those vertices
11:51:11 <zzo38> So, the reason doesn't have to do with partial functions.
11:51:22 <tgeeky> zzo38: right, but you do have a reason for doing it -- so you'd list that instead.
11:52:01 <avpx> I'm wondering why generally you can't have an instance like "instance (Foo a) => Bar a where ..."
11:52:18 <avpx> Instead one has to introduce a wrapper so that it can look more like "instance (Foo a) => Bar (C a) where ..."
11:53:01 <ppilate> @hoogle many
11:53:02 <lambdabot> Text.ParserCombinators.ReadP many :: ReadP a -> ReadP [a]
11:53:02 <lambdabot> Control.Applicative many :: Alternative f => f a -> f [a]
11:53:02 <lambdabot> Text.ParserCombinators.ReadP many1 :: ReadP a -> ReadP [a]
11:53:07 <ppilate> hm
11:53:09 <parcs`> avpx: because it's not allowed :P
11:53:15 <ppilate> Hi, everyone
11:53:15 <zzo38> tgeeky: But I do have convList which can be used like a total kind of head
11:53:16 <avpx> parcs`: But why?
11:53:31 <zzo38> I will now add the total kind of !! as well
11:53:37 <tgeeky> zzo38: please publish your module on a place like github
11:53:42 <avpx> parcs`: What kinds of problems would be introduced?
11:54:01 <ClaudiusMaximus> avpx: instace search works more like "instance Foo a => Bar a" meaning i've got an a, so I can  Bar a, now I need  Foo a
11:54:06 <zzo38> tgeeky: I will post it on Hackage once a version is done.
11:55:13 <Mathnerd314> avpx: you can get nontermination. see http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/type-class-extensions.html#undecidable-instances
11:57:49 <Mathnerd314> and there's an example like you gave here: http://lukepalmer.wordpress.com/2008/04/08/stop-using-undecidable-instances/ (Num a => Group a)
11:57:54 <zzo38> x !!! n = either Just (const Nothing) $ foldl (\y x -> y >>= maybe (Left x) Right . predP) (Right n) x;
11:57:56 <tgeeky> dmwit: estas aqui?
11:58:13 <avpx> Mathnerd314: Hilariously, that is what I'm trying to do
11:58:27 <avpx> Mathnerd314: Which is to say, create a Group class and say "instance (Num a) => Group a where ..."
12:01:00 <Mathnerd314> "In this case it was actually good that you had to do that though, since Num forms more than one group, it’s good to mark which one you mean."
12:01:19 <avpx> Mathnerd314: This was also essentially my work around
12:01:47 <zzo38> Mathnerd314: But you cannot divide by zero
12:02:11 <lamefun2> hello
12:02:15 <avpx> zzo38: The nonzero elements of Num form a group]
12:02:20 <avpx> How about that
12:02:23 <lamefun2> how can haskell be used for games? how to program a game loop in it?
12:02:47 <avpx> zzo38: I mean really, it's implicit that we're either talking about the underlying additive group of the ring or the group of units
12:03:01 <Mathnerd314> lamefun2: look under http://hackage.haskell.org/packages/archive/pkg-list.html#cat:game
12:03:13 <zzo38> avpx: Even in that case I think not. The only group that Num by itself forms is addition, since Num does not necessarily imply fractions.
12:03:13 <mauke> lamefun2: what's the obstacle?
12:03:20 <lamefun2> lack of state
12:03:29 <avpx> zzo38: Every ring has a group of units
12:03:43 <zzo38> lamefun2: Yes it can be used
12:03:43 <mauke> lamefun2: huh?
12:03:47 <zzo38> avps: OK
12:04:01 <lamefun2> I have to write a function that recives a game world and then returns a game world for the next frame?
12:04:13 <mauke> lamefun2: that's one way to do it
12:04:15 <zzo38> lamefun2: Yes that is one way.
12:04:21 <avpx> zzo38: I get what you're saying though :)
12:04:57 <avpx> Mathnerd314: Thanks for the blog link. It's more verbose and informative than other resources I was reading on the subject.
12:05:16 <mauke> lamefun2: you can write C in Haskell
12:05:18 <Mathnerd314> avpx: I just googled UndecidableInstances :p
12:05:56 <avpx> Mathnerd314: Most of the "official" resources on the subject are pretty terse and difficult to understand for someone who (like me) isn't intimately familiar with the workings of the Haskell type system
12:06:02 <mauke> that is, everything you can do in C has a more or less direct translation in haskell
12:08:23 <lamefun2> can I have entity type in Haskell? inheritance?
12:08:52 <zzo38> lamefun2: Perhaps describe more precisely what you want?
12:08:53 <mauke> what's an entity type?
12:09:00 <mauke> no inheritance
12:09:47 <lamefun2> For example, Entity -> Character -> SomeCharacter hierarchy
12:10:02 <mauke> huh?
12:10:23 <Botje> lamefun2: haskell does not have inheritance or subtyping.
12:10:28 <zzo38> lamefun2: Type classes can have superclasses in Haskell, but it might not necessarily be as you are look at
12:10:32 <mauke> is 'hierarchy' a variable here?
12:10:38 <int-e> meh, ocaml is driving me nuts. [a,b] is a list of length 1 :-( (containing a pair)
12:10:52 <lamefun2> class Entity; class Character extends Entity; class SomeCharacter extends Character;
12:10:57 <danr> int-e: hmm how do you write list delimiters? ; ?
12:11:02 <mauke> lamefun2: no classes, no inheritance
12:11:05 <int-e> danr: yep
12:11:12 <zzo38> lamefun2: There is class in Haskell but it is different to other programming languages
12:12:09 <mauke> > maxBound :: Char
12:12:10 <lambdabot>   '\1114111'
12:12:11 <avpx> It seems to me that Haskell classes are most akin to interfaces in OOP
12:12:33 <lamefun2> is there a moderately complex platformer example?
12:13:33 <Botje> platformer? like in platformer games?
12:14:06 <mauke> found http://youtu.be/gVLFGQGRsDw
12:15:01 <Botje> heh heh. cool.
12:15:56 <lamefun2> mauke: O_O
12:17:00 <kallisti> hm. is there any package that converts between enumerator and conduit? or is that generally not possible?
12:21:44 <zzo38> I have also added three monad operations <>>= bind2 bind3 do you find these to be useful or any others which I may have forgotten?
12:22:19 <stj> is it possible to define something like this? data My = A | B; data Other { get :: A }
12:22:39 <stj> i.e. to force get to be of type My, but more specifically, A
12:23:15 <Botje> A is a data constructor, not a type
12:23:30 <stj> ok, makes sense
12:24:32 <kallisti> can you UNPACK fields in sum types?
12:24:33 <ezyang> What's the best way to turn a UTF-8 encoded CString into a String?
12:24:46 <ezyang> kallisti: Yes.
12:25:50 <kallisti> ezyang: I never found a function to do it directly. I believe I traversed the CString until null char (or until a certain length) while accumulating the characters into a list.
12:26:08 <quicksilver> ezyang: here is the old way of doing it (write it yourself, as in takusen) http://hackage.haskell.org/packages/archive/Takusen/0.8.5/doc/html/Foreign-C-UTF8.html
12:26:10 <kallisti> you might be able to simplify this with a sequence and a fold.
12:26:26 <ezyang> ugh
12:26:37 <quicksilver> ezyang: I would think that GHC must have the capability to do that since 7.2/4 since it now considers the encoding of libc calls
12:26:42 <kallisti> oh no. not actual programming!
12:26:43 <quicksilver> I dunno if they exposed it though
12:27:08 <ezyang> well, I tried using peekCString with LANG set
12:27:15 <Eidel> If you have a datatype with only two values, can you negate the value? like with booleans and ! in Java
12:27:17 <ezyang> but it didn't seem to work
12:27:44 <kallisti> Eidel: you can, but not by using "not"
12:27:48 <kallisti> which only works on Bools
12:27:52 <kallisti> you need your own function
12:28:00 <Eidel> kallisti: Ah. Of course :)
12:28:10 <kallisti> myNot Value1 = Value2
12:28:12 <zzo38> You can also just use the Bool type
12:28:14 <kallisti> myNot Value2 = Value1
12:28:21 <zzo38> You could make the other type to simply be a type synonym of Bool
12:28:34 <kallisti> yes that's an option as well.
12:28:46 <benmachine> or define a function for converting it and use fromBool . not . toBool
12:28:53 <quicksilver> ezyang: I'm fairly sure you can patch together http://hackage.haskell.org/packages/archive/base/4.3.0.0/doc/html/GHC-IO-Encoding.html and http://hackage.haskell.org/packages/archive/base/4.3.0.0/doc/html/GHC-IO-Buffer.html to do the right thing
12:28:58 <Eidel> zzo38: Ah, smart!
12:29:40 <quicksilver> ezyang: that's certainly the intended purpose of GHC.IO.Buffer but it doesn't seem to have exactly the primitive you want
12:29:49 <ezyang> quicksilver: I'm going to complain to GHC HQ :-)
12:29:56 <mauke> ezyang: http://hackage.haskell.org/packages/archive/utf8-string/0.3.7/doc/html/Data-ByteString-UTF8.html looks fairly straightforward
12:30:01 <kallisti> Eidel: it can also be the wrong choice, depending on what your type represents.
12:30:29 <ezyang> CString -> ByteString -> String seems... silly.
12:30:59 <zzo38> Do you know if there are other types which should be     swap :: f x y -> f y x;  -- swap . swap = id
12:31:14 <ezyang> I guess I should go and modernize all of this code >:-(
12:31:18 <kallisti> ezyang: you could always just program in a language that has literally every piece of code possible written as a function.
12:31:20 <mauke> ezyang: why?
12:31:25 <whittle> Eidel: If you’re doing that with a lot of types, you could define a Reversible class. Once a type defines fromBool and toBool, it could get reverse for free!
12:31:31 <Botje> ezyang: it's a great stress test of the fusion system though >:)
12:31:50 <mauke> ezyang: Ptr CChar -> ByteString can be done in O(1)
12:31:57 <mauke> if you're willing to use unsafePack, that is
12:32:43 <ezyang> mauke: I'm not, and the Ptr is not managed by GHC
12:32:59 <mauke> doesn't matter if you force the String
12:34:41 <Mathnerd314> zzo38: Writer
12:35:00 <Mathnerd314> and/or Reader
12:35:20 <zzo38> Mathnerd314: Yes, it is effectively like (,) but it is a type synonym so it won't work. And Reader is like (->) which won't work
12:35:33 <nand`> is there some generalization of (Map a b, Map b a) that basically offers an efficient bijection between sets?
12:35:35 <zzo38> Since that would require a bijection
12:36:22 <Mathnerd314> Map?
12:36:29 <nand`> Data.Map
12:37:24 <Mathnerd314> that was to zzo38 :p
12:37:27 <nand`> oh
12:37:46 <zzo38> Mathnerd314: No because that requires Ord
13:03:26 <Mathnerd314> zzo38: what about (Functor f, Swap s) => Swap (f s)
13:03:48 <zzo38> Mathnerd314: Yes that works.
13:04:59 <zzo38> O no, wait it doesn't.
13:05:10 <zzo38> The type is wrong, and it conflicts with the instance for (,)
13:09:40 <Mathnerd314> I guess there just aren't that many two-parameter datatypes
13:12:46 <danr> (->), Either, State, Reader, Writer, usw
13:12:53 <danr> (,) of course ;)
13:13:46 <Mathnerd314> usw?
13:14:50 <rwbarton> usw = German etc.
13:15:31 <Mathnerd314> but none of those have a Swap instance :p
13:15:54 <Mathnerd314> Reader and Writer are synonyms for (->) and (,)
13:16:13 <shachaf> Iso a b = (a -> b, b -> a)
13:16:16 <DaBob> is there any inbuild function to sort a list of [(a, b)] to predicate b?
13:16:27 <shachaf> DaBob: sortBy (compare `on` snd)
13:16:41 <DaBob> good idea thx xD
13:17:05 <zzo38> Mathnerd314: Except Either which does
13:18:40 <Mathnerd314> shachaf: where's it defined?
13:18:48 <shachaf> A few lines above in IRC.
13:19:17 <Mathnerd314> :p
13:20:28 <xil> hey everyone. What are the chances that hlint returns "no suggestions"
13:21:26 <danr> xil: well, chances are 100% if there are no suggestions to give...
13:21:32 <xil> haha
13:21:39 <c_wraith> given how much I dislike "if", hlint will never say that to me.
13:22:13 <danr> xil: my experience with hlint is that eventually I learn all suggestions from hlint and wrote in that fashion before running hlint, so I quite usually get no suggestions
13:22:25 <Mathnerd314> c_wraith: what do you use instead?
13:22:39 <c_wraith> guards if I can, case otherwise
13:22:40 <xil> danr: well I've never used it before and I'm still pretty noob, so I'm surprised there aren't suggestions, but the program isn't that large yet, so we'll see
13:22:58 <xil> c_wraith: I usually create a function (?) :: Bool -> ( a, a ) -> a
13:23:09 <c_wraith> and hlint really hates "case foo of True..."
13:23:37 <zzo38> Intead of "if" I define a function called "bool"
13:24:36 <rwbarton> You people are crazy. :)
13:24:52 <zzo38> rwbarton: OK. Crazy in what way(s)?
13:25:04 <Botje> CRAZY PRICES CRAZY!
13:25:21 <kallisti> ezyang: also you can't use UNPACK on sum types, it seems. or maybe it's Bool or something
13:25:45 <kallisti> Bool and Integer aren't being UNPACK'd on my sum type.
13:25:48 <rwbarton> right, UNPACK only works on single-constructor types iirc although that could change in the future
13:26:47 <rwbarton> it would require splitting the constructor in which the field appears into several constructors though
13:27:39 <parcs`> what happens if you give an UNPACK annotation to a polymorphic parameter
13:28:04 <Botje> explosions.
13:28:07 <zzo38> parcs`: Maybe it will be a kind error?
13:28:14 <rwbarton> I would guess nothing, or possibly an error
13:28:46 <DaBob> arrr from which module comes "on" ?^^
13:29:34 <mauke> @hoogle on
13:29:34 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
13:29:34 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
13:29:34 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
13:29:42 <mauke> @hoogle comparing
13:29:42 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
13:29:44 <parcs`> rwbarton: i don't get an error, so perhaps the answer is nothin
13:30:04 <zzo38> Why don't you get a kind mismatch error for doing that?
13:30:38 <rwbarton> btw are you talking about a type variable? like data Foo a = Foo {-# UNPACK #-} !a
13:31:01 <c_wraith> That's also currently not possible.
13:31:22 <kallisti> no
13:31:22 <rwbarton> right, i am just checking what parcs` means by polymorphic
13:31:26 <kallisti> oh.
13:31:43 <kallisti> I thought you were talking to me. nevermind.
13:34:26 <parcs`> rwbarton: yeah
13:34:30 <parcs`> c
13:34:36 <parcs`> c_wraith: ghc doesn't complain for me
13:35:09 <kallisti> with -Wall I'm assuming
13:35:12 <parcs`> yeah
13:35:23 <parcs`> Wall 4 life
13:37:26 <parcs`> okay if i actually compile something then ghc will complain, but only if -O is used.
13:37:40 <zzo38> xil: If you made a function (?) what did you set its fixity to?
13:37:50 <xil> zzo38: left it at default
13:38:17 <xil> I'm not well versed on fixity, so I try not to use it without parentheses if it's inline
13:39:49 <navaati> (->) and Kleisly Identity are basically the same thing, right ?
13:40:06 <zzo38> navaati: Yes
13:40:20 <zzo38> The Kleisli category of the identity monad is the same as the base category
13:41:36 <navaati> hum. netwire only has instances for (Kleisly m)...
13:42:06 <zzo38> navaati: ?
13:43:40 <navaati> well, for example stepWire http://hackage.haskell.org/packages/archive/netwire/3.1.0/doc/html/Control-Wire-Session.html#v:stepWire is parametrized over an arrow which must be a member of the WireToGen class
13:44:08 <navaati> and this class only has an instance for (Kleisli m)
13:44:23 <whittle> When using a qualified import, how do I reference a data constructor?
13:44:44 <navaati> but since m can be Identity, i guess it should be possible to make directly (->) an instance of this class
13:45:04 <navaati> (i think the type system actually proves it possible, but i'm not sure of this)
13:45:05 <zzo38> navaati: Yes it would, and they should have done so
13:58:07 <fmap> Is there some paper like "Why you want use pipes/conduit/etc"?
13:58:15 <xil> so if I have "pos <- newIORef ( 0, 0, 10 ) :: type" then does the type apply to the tripple, or the whole "newIORef (...)"? That is, does the type declaration have lowest precedence in terms of fixity?
13:58:36 <c_wraith> xil: it refers to the entire preceding expression
13:59:24 <xil> c_wraith: does that include if I have operators like $ in the preceding expression?
13:59:47 <c_wraith> xil: yes
13:59:52 <xil> c_wraith: thanks =D
14:08:32 <whittle> When using Data.Aeson.decode, is there any way to find out what it’s failing on?
14:11:08 <EvanR> whittle: well, if you use the parser directly
14:11:12 <EvanR> attoparsec will tell you
14:12:43 <EvanR> whittle: try fromJSON instead
14:17:09 <marcot> Is there a package that has an instance of Network.TCP.HStream for Text?
14:17:14 <ozataman> anyone ever run into a situation where a program (web app) sitting idle continuously uses 3% CPU? I've checked everything and it should honestly not be doing anything.
14:17:26 <marcot> Or any other way for me to get a file through HTTP using Text?
14:17:34 <marcot> I mean Data.Text.
14:17:47 <hpc> ozataman: i had that
14:17:53 <mauke> ozataman: what OS?
14:17:55 <hpc> ozataman: it was a memory leak that ghc didn't optimize out
14:18:05 <EvanR> marcot: use bytestring and convert to text
14:18:17 <ozataman> hpc: I see. any chance it was related to FFI?
14:18:30 <ozataman> mauke: it's there on linux. let me confirm with os x.
14:18:34 <hpc> in my case, no
14:18:38 <marcot> EvanR: Ok, thanks.
14:18:43 <whittle> EvanR: Thank you! I got it out with fromJSON . fromJust . decode
14:18:45 <hpc> no clue what yours is, just pointing at places to look
14:18:54 <mauke> ozataman: is anything visible in strace?
14:18:59 <EvanR> whittle: fromJust sounds like a mistake
14:19:08 <hpc> :t fromJSON
14:19:09 <lambdabot> Not in scope: `fromJSON'
14:19:13 <hpc> @hoogle fromJSON
14:19:14 <lambdabot> No results found
14:19:23 <marcot> EvanR: You mean Data.ByteString.Char8, or any of them?
14:19:25 <hpc> why not fromJSON <$> decode?
14:19:26 <ozataman> mauke: haven't checked strace yet. let me see.
14:19:33 <EvanR> fromJSON :: FromJSON a => Value -> Result a
14:19:50 <EvanR> marcot: Data.ByteString?
14:19:54 <EvanR> no Char8
14:19:58 <whittle> EvanR: hpc: Because I’m a Haskell newb.
14:20:00 <marcot> EvanR: Ok.
14:20:17 <EvanR>  > fromJust Nothing
14:20:17 <hpc> whittle: ah, groovy
14:20:22 <hpc> (<$>) = fmap
14:20:24 <EvanR> *universe collapses in on itself*
14:20:34 <hpc> for Maybe, fmap f Nothing = Nothing; fmap f (Just x) = Just (f x)
14:20:58 <whittle> hpc: Okay. I saw that when I was learning functors.
14:21:06 <whittle> I just don’t know when to apply it, yet.
14:21:11 <dekuked> what's the most optimized way to read a binary file?
14:21:56 <bitonic_> dekuked: it depends
14:22:08 <EvanR> is it a terabyte file
14:22:17 <dekuked> nah, less that 10 gigs
14:22:31 <EvanR> better not load it all at once
14:22:40 <bitonic_> well if the size fits in memory you can just use Data.ByteString.readFile, otherwise the lazy version
14:22:45 <dekuked> yep, and I'm running a simple operation on each item
14:22:51 <Botje> dekuked: most optimized for what operation?
14:22:59 <EvanR> iteratees
14:23:19 <mauke> what's an item?
14:24:23 <dekuked> optimized for transforming it into a new type
14:24:31 <dekuked> and printing it out basically
14:24:52 <dekuked> the items are collected packets from a pcap file
14:24:56 <whittle> hpc: Data.Aeson.fromJSON <$> Data.Aeson.decode $ aByteString says that it can’t match Data.Aeson.Types.Internal.Value with Maybe a0.
14:25:22 <hpc> whittle: whoops
14:25:27 <Botje> dekuked: so read one packet at a time :)
14:25:27 <hpc> fromJSON <$> (stuff)
14:25:36 <hpc> my bad
14:25:59 <hpc> fromJSON <$> (decode bytestring)
14:26:22 <whittle> hpc: Ah!
14:27:10 <dekuked> man I just have to say, haskell is really cool
14:27:38 <dekuked> only on the 4th chapter of rwh and it's just awesome; all I know is java/python and a bit of lisp
14:28:07 <EvanR> good
14:28:09 <EvanR> lol
14:28:16 <bitonic_> dekuked: there's a library to read pcap files
14:28:20 <EvanR> whittle: anyway, none of this gives you the message for why a parse failed
14:28:43 <whittle> hpc: Okay, so the Maybe ends up on the outside of the Result.
14:28:49 <whittle> EvanR: No, it does!
14:28:54 <EvanR> how
14:29:07 <Botje> butterflies.
14:29:11 <EvanR> >_>
14:29:44 <EvanR> first you get Nothing, then fromJSON Nothing...
14:29:53 <EvanR> er
14:30:08 <whittle> EvanR: Data.Aeson.decode returns a Maybe Data.Aeson.Value.
14:30:23 <EvanR> yeah Nothing if failed to decode
14:30:34 <whittle> And decoding to a Value always works.
14:30:41 <hpaste> ozataman pasted “strace results” at http://hpaste.org/68036
14:30:52 <ozataman> mauke: I get a large number of these after a while ^
14:31:04 <whittle> It’s converting to the instance of FromJSON that I created that’s failing.
14:31:09 <Altazimuth> So I'm teaching myself Haskell with "Learn You a Better" and it told me specifically which compiler to use but not what text editor to use (I'm on win 7 64-bit), what should I use?
14:31:10 <dekuked> in this: https://gist.github.com/2589661 is the maybe/just a way of handling the idea that a function would fail when running? So it's like a try/except but functional?
14:31:41 <ozataman> mauke: the 2-3% CPU drain is also present on 64-bit os x
14:31:43 <whittle> And using Data.Aeson.fromJSON throws an error when it can’t make the conversion.
14:32:04 <EvanR> whittle: i thought you were asking about the original parse error from the bytestring
14:32:50 <EvanR> dekuked: its like in other languages where something may return null or nil or undefined or whatever
14:32:53 <EvanR> only better
14:33:16 <ricli85> in a haskell thread (started with forkIO) I run an external process
14:33:28 <ricli85> I would like to kill that external process when I kill the thread
14:33:30 <whittle> EvanR: Oh, sorry, no. I explained it wrong initially. Fortunately, your advice got me straightened out even though I was asking the wrong question.
14:33:32 <ricli85> how can I do that?
14:33:55 <EvanR> ricli85: sounds like you want a child process
14:33:59 <EvanR> instead of a forkIO thread
14:34:40 <marcot> Can I use Data.Regex with Data.Text?  I could only use it with ByteString.
14:36:20 <ricli85> I have multiple worker threads that do stuff... some of those threads might run external programs
14:37:03 <ricli85> but when a worker thread is killed, I want the external program (if there is one) to be killed as well
14:37:24 <whittle> dekuked: RWH is very good, and I’m working my way through it, too.
14:37:33 <navaati> ricli85: maybe you could setup something like a thread finalizer, if the haskell thread system permit that
14:37:43 * hackagebot digestive-functors-heist 0.3.1.0 - Heist frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-heist-0.3.1.0 (JasperVanDerJeugt)
14:38:15 <EvanR> navaati: execute the command to end the external process from the same io action that kills the thread
14:38:44 <whittle> dekuked: Just a heads-up, though: I had trouble when I got to chapter 8 and hit monads, so I switched to LYH, read chapters 11 and 12, and was able to come back to it.
14:39:54 <whittle> Although, obviously I’m still wrapping my head around all of that, I found LYH’s method of building up to monads to be a better introduction.
14:40:03 <dekuked> whittle: thanks!
14:40:28 <whittle> dekuked: You’re entirely welcome.
14:42:13 <dekuked> also, sorry for all the questions, but how does one create a String?
14:42:46 <dekuked> I'm stuck here, https://gist.github.com/2589723, because I don't get how that type hasn't been introduced
14:44:14 <whittle> dekuked: What do you mean by "create a String"?
14:44:41 <whittle> dekuked: A string is [Char]
14:44:43 <EvanR> > "a string"
14:44:45 <lambdabot>   "a string"
14:44:47 <dekuked> well, that function is expecting a String, not a [Char]
14:44:55 <Jeanne-Kamikaze> it's a type synonym
14:44:58 <EvanR> type String = [Char]
14:45:10 <dekuked> ah
14:45:19 <EvanR> > 'a':'b':'c':[]
14:45:21 <lambdabot>   "abc"
14:46:07 <whittle> You’ll get more detail when you get to the type keyword, but type synonyms can be used interchangably. The compiler thinks they’re pretty much the same thing.
14:46:22 <EvanR> they are exactly the same
14:52:28 <bitonic_> http://jeltsch.wordpress.com/2012/04/30/dependently-typed-programming-and-theorem-proving-in-haskell/ "Dependent types are types that are parameterized by values. In Haskell, however, parameters of types have to be types again. So we represent values by types" wat
14:52:46 <bitonic_> that's the whole point about dep. types
14:53:45 <whittle> In Aeson, how should I go about representing a JSON array of objects where those objects may have different sets of keys?
14:54:00 <ezyang> Cute little webapp I've been working on: http://logitext.ezyang.scripts.mit.edu/main
14:54:14 <ezyang> pick an example and try clicking around the sequent tree
14:54:26 <kallisti> whittle: depends.
14:54:26 <Mathnerd314> bitonic_: restriction goes away with -XDataKinds
14:54:46 <whittle> I tried to make it the list of type that has multiple data constructors, but I get the error "when expecting a sum (:+:), encountered Object instead".
14:55:12 <bitonic> Mathnerd314: no they don't,
14:55:15 <ozataman> bah.. cabal modular solver still can't figure out seemingly simple stuff. locks itself into the latest version of a dep upfront, then bails when a later package doesn't work with it.
14:55:18 <jfischoff> ezyang: what system are you using?
14:55:26 <kallisti> whittle: it sounds like you're trying to use Object directly instead of your own type.
14:56:00 <bitonic> Mathnerd314: you can do quite weird type-level programming but they're not dependent types
14:56:09 <kallisti> whittle: oh wait nevermind, I misread.
14:56:13 <whittle> kallisti: Depends on what?
14:56:13 <whittle> kallisti: Nice nick, btw. Are you a Pope of Discordia, or do you just like apples?
14:56:36 <kallisti> I am the one and only certified Pope.
14:57:04 <whittle> kallisti: Awesome, me too.
14:58:23 <kallisti> whittle: I would need way more information to recommend anything.
15:00:38 <Mathnerd314> bitonic: right. I don't think you can write f :: (x :: Bool) -> if x then String else Int
15:00:44 <bitonic> Mathnerd314: you can't
15:01:00 <Mathnerd314> thoguh perhaps there's a way to emulate it?
15:01:36 <bitonic> Mathnerd314: no
15:01:44 <kjartan> hello I'm a haskell programmer just you like oyu guyz :3
15:02:19 <whittle> kallisti: In brief, I’m attempting to parse search results from the CrunchBase API. Search results maybe of any of 5 types (the documentation describes the different types of result as belonging to different "namespaces").
15:02:23 <hpaste> whittle pasted “CrunchBase API search” at http://hpaste.org/68039
15:02:25 <siracusa> bitonic: With type families you can, no?
15:02:29 <bitonic> Mathnerd314: you can exploit type families and datakinds to do that kind of type level programming but it's different
15:02:47 <rwbarton> right but you can define data True; data False; data If t a b where Yes :: a -> If True a b; No :: b -> If False a b
15:02:56 <bitonic> siracusa: but the two levels are still always going to be separated. you can't write useful programs and prove properties for them
15:03:10 <rwbarton> f :: If x () () -> If x String Int
15:03:22 <whittle> If I am asking too much, please tell me so. I’m quite new to Haskell and unaccustomed to not knowing what good design looks like.
15:03:37 <bitonic> rwbarton: sure but you can't do the interesting part (writing programs/proofs)
15:03:48 <rwbarton> well proofs are out the window from the start
15:04:00 <Mathnerd314> what if you could automatically lift functions to the type level?
15:04:04 <bitonic> well for various reasons, and this is one of them
15:04:22 <bitonic> Mathnerd314: no, type familes are not as expressive as haskell functions. for one, they have to be total, iirc.
15:04:31 <dmwit> tgeeky: Why the huge indentation?
15:04:39 <bitonic> also, you can't bring any value to the type level
15:04:49 <dmwit> ?ask jfischoff what MetaType is for
15:04:49 <lambdabot> Consider it noted.
15:04:50 <Mathnerd314> bitonic: -XDataKinds :p
15:05:02 <navaati> which one has the best performances, netwire or animas ?
15:05:26 <bitonic> Mathnerd314: yeah that's what I meant, you can't use that to lift any value
15:05:36 <Mathnerd314> bitonic: oh?
15:05:48 <navaati> Mathnerd314: only simple ones
15:06:01 <jfischoff> dmwit: didn't mean to leave it in there. But to do antiquote for the quasiquoter you need a ast with the antiquate options
15:06:01 <lambdabot> jfischoff: You have 1 new message. '/msg lambdabot @messages' to read it.
15:06:11 <tgeeky> dmwit: uhh. In the case of the data declerations, etc - it's just the way I prefer to lay things out. For the associator part, because I wanted to show the alignment of the L's and R's
15:06:17 <bitonic> Mathnerd314: I mean you can't lift values at all, you can only construct them at the type level from the beginning
15:06:42 <augur> dmwit: next time you see me online
15:06:54 <augur> tell me to write up something about plural logic
15:06:58 <augur> bai
15:07:10 <jfischoff> dmwit: which I would like to have eventually. Either we make a new ast for the quasiquoter or the regular ast has the antiquote junk in it. There are pluses and minus to both approaches
15:07:23 <Mathnerd314> bitonic: yeah, but if you can lift functions then you can lift expressions and then everything is a type
15:09:22 <rwbarton> there's also the whole 'reflection' approach
15:11:53 <jfischoff> rwbarton: were talking about quasiquoters?
15:13:16 <bitonic> Mathnerd314: type families declarations work in a very different way from ordinary functions anyways... eg. if you have a `Foo a :: *' you are going to declare instances for a restricted set of `a' considering that `a' ranges over *
15:15:44 <rwbarton> jfischoff: no, "fake dependent types"
15:16:21 <jfischoff> rwbarton: oh well.
15:17:10 <mefisto> maybe when light table comes out, someone will make haskell support for it :D
15:17:27 <tgeeky> dmwit: https://github.com/technogeeky/pi-eta-epsilon/blob/master/dualities.hs <-- that's a recenter layout
15:18:11 <tgeeky> dmwit: I don't know what else to say but, it's very readable "to me" :)
15:18:24 <Mathnerd314> bitonic_: sure, but if you have a Foo a :: Nat then you're going to declare instances for everything
15:18:46 <tgeeky> dmwit: though lots of the spacing in the functions is off, as I'm in the middle of figuring them out
15:27:25 <ezyang> jfischoff: Unholy combination of Coq, Haskell and Ur/Web
15:29:21 <jfischoff> ezyang: woah. the unholy trinity.
15:29:47 <ezyang> Or holy, depending on how you look at it :-)
15:30:03 <monochrom> "holy smoke" :)
15:30:30 <monochrom> "holy batman! coq haskell and ur/web!"
15:33:01 <ezyang> Anyway, right now it's just normal sequent calculus for prop logic; the backend supports classical first order logic but I haven't coded up the UI yet
15:34:43 <oddraisent> How can `ErrorT String IO String' value could be constructed from the readProcessWithExitCode response?
15:35:03 <tgeeky> @hoogle readProcessWithExitCode
15:35:03 <lambdabot> System.Process readProcessWithExitCode :: FilePath -> [String] -> String -> IO (ExitCode, String, String)
15:36:14 <ozataman> anybody have any idea why GHC would issue thousands of futex syscalls when it's supposed to be fully idle?
15:37:08 <ozataman> GHC runtime, that is
15:37:23 <ezyang> prolly pthreads?
15:37:45 * hackagebot hGelf 0.1 - Haskell GELF library  http://hackage.haskell.org/package/hGelf-0.1 (AndyGeorges)
15:50:21 <hpaste> dmwit pasted “ArrayList lol” at http://hpaste.org/68041
15:51:34 <c_wraith> dmwit: is that just to answer that SO question?
15:51:53 <lispy> hello
15:52:00 <avpx> Hi.
15:52:08 <lispy> How is code?
15:52:19 <avpx> Is good.
15:52:30 <lispy> Excellent.
15:52:41 <lispy> Are we still on target for taking over the world?
15:52:55 <dmwit> c_wraith: Just to prove to those naysayers that amortized O(1) cons and snoc are possible.
15:53:11 <c_wraith> amortized, yes. I think they were saying worst-case isn't
15:53:59 <lispy> Do we have any GSoC students in here?
15:54:04 <lispy> If so, how are projects going?
15:54:36 <dmwit> tgeeky: I'm big on whitespace, but damn, man, start those evalIso clauses on the next line.
15:55:08 <dmwit> Give me one indentation level at each syntactic separator, not 10. =P
15:55:25 <dmwit> jfischoff: urgh, that's annoying
15:56:30 <jfischoff> dmwit: antiquotes?
15:57:38 <jfischoff> dmwit: or the spacing?
15:58:40 <dmwit> jfischoff: antiquotes
15:58:55 <jfischoff> * nods *
15:59:25 <jfischoff> jfischoff: its too bad BNFC-meta is so limited because it generates all that for you.
15:59:28 <jfischoff> ha
15:59:36 <jfischoff> dmwit I mean
15:59:37 <jfischoff> n
16:01:17 <dmwit> yeah
16:02:37 <oddraisent> How can this http://hpaste.org/68042 be rewritten?
16:03:12 <jfischoff> dmwit: Have you thought about how to generate the arbitrary fold/unfold functions for data types? Its related to derivative/one-hole contexts I would guess, but I don't remember a precise description in the papers.
16:04:05 <jfischoff> dmwit: in there example code, they manual wrote them for naturals and lists, but that won't scale :)
16:05:03 <Botje> oddraisent: return (response >>= getStatus)
16:05:22 <Botje> that >>= is actually the bind of Either e
16:07:35 <oddraisent> Botje: so I have ← and return then. Seems like there is another simplify step
16:08:45 <Botje> oh, sure. if you want.
16:08:49 <Botje> but it's a bit iffy.
16:09:26 <Botje> (getStatus =<<) `fmap` runErrorT ...
16:09:43 <Botje> I think.
16:10:22 <hpc> > iterate succ 1
16:10:23 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
16:10:30 <hpc> hmm
16:11:28 <dmwit> jfischoff: Sorry, fold and unfold?
16:11:35 <dmwit> We don't have recursive types here, do we?
16:11:59 <jfischoff> dmwit: yeah, but we will.
16:12:00 <oddraisent> Botje: thanks
16:12:05 <dmwit> (They made some crazy comments at the end about recursive types and algebraic numbers, but it didn't sound as though they had completed the thoughts...)
16:12:06 <jfischoff> :)
16:12:19 <Botje> oddraisent: hmmm. now I'm not so sure you want >>=...
16:12:20 <jfischoff> dmwit: exactly
16:12:51 <jfischoff> dmwit: but I think the folds and unfolds can be generated from the types
16:12:54 <Botje> ah, no. you want >>=. never mind.
16:12:56 <jfischoff> somehow
16:13:01 <Botje> i need to go sleep real soon now, i think :)
16:13:17 <augur> dmwit: THANKS ALOT
16:13:19 <augur> :(
16:13:21 <tgeeky> dmwit: oh. the spacing on the evalIsos is just to push everything over so I can see the LHS of the equations
16:13:23 <dmwit> augur: eh?
16:13:34 <dmwit> augur: write about plurals or something
16:13:38 <augur> :P
16:13:57 <dmwit> augur: Why the sad face...?
16:14:07 <Botje> oddraisent: also, I find it iffy to mix two different monads in the same line :)
16:14:49 <hpc> hmm
16:14:55 <oddraisent> I cannot remember how can I avoid parenteses from (getStatus =<<) <$> runErrorT callMocp
16:15:02 <hpc> > if False then True else if True then False else True
16:15:03 <lambdabot>   False
16:15:06 <hpc> ...
16:15:21 <Botje> you can't. it's an operator section.
16:15:45 <oddraisent> Botje: I should, with `>>=` somehow
16:16:08 <hpc> i am getting a parse error on the line after the last line of this module
16:18:02 <dmwit> jfischoff: Let's not get ahead of ourselves. We haven't even got a full evaluator for the stripped down pi language yet, let alone pi-eta-epsilon, and you're already trying to figure out how to solve problems in pi-eta-epsilon-mu. =P
16:18:14 <hpc> oh
16:18:15 <hpc> nvm
16:18:41 <tgeeky> dmwit: hehe.
16:19:18 <jfischoff> dmwit: too late :)
16:20:52 <Botje> only in #haskell would pi-eta-epsilon-mu be a valud language name.
16:20:57 <hpc> > group . iterate succ $ 0
16:20:59 <lambdabot>   [[0],[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16]...
16:21:03 <hpc> hmm
16:21:08 <Botje> also, if you reverse the letters you get MEEP :)
16:21:14 <tgeeky> meep meep!
16:21:45 <jfischoff> it should be an involution
16:21:50 <zzo38> OK
16:21:58 <jfischoff> meeppeem
16:22:46 * hackagebot prelude-generalize 0.1 - Another kind of alternate Prelude file  http://hackage.haskell.org/package/prelude-generalize-0.1 (AaronBlack)
16:22:58 <zzo38> Now I sent this file is it good to you?
16:23:17 <tgeeky> zzo38: to who? me?
16:23:27 <tgeeky> zzo38: it only matters what hackage compile script thinks of it, the rest of us be damned
16:23:31 <zzo38> tgeeky: Including, but not limited to, you
16:24:03 <zzo38> It does compile on my computer, so that part is OK.
16:24:55 <Botje> heh. I often get mails from students "help, it doesn't compile! code attached!" and it compiles just fine for me
16:25:17 <zzo38> I have added a few more things to the file since I told you before
16:25:42 <zzo38> Including a few bitwise operation
16:26:24 <tgeeky> dmwit: so I fooled around with slightly more than just indentation. I was trying to write an unfoldable instance for some of the data declerations, but none of them are paramterized. So I needed something of kind * -> *, but only had *.
16:28:24 <tgeeky> dmwit: it seemed to me the only thing that might make sense being unfolded is Context (and therefore Term and V?)
16:33:54 <acowley> You know, I kind of agree with Henning's last mail on the Constant functor naming thin on cafe, but I'm still smarting from his naming tendencies so now I don't know what to think (c.f. gnuplot simple :: C graph => T graph -> T graph)
16:35:26 <dmwit> tgeeky: hm, yeah, I'm not sure
16:35:48 <tgeeky> dmwit: presumably there are some Applicative and Alternative instances we haven't specified
16:36:45 <tgeeky> dmwit: but just from your original code -- aren't we missing Factor?
16:36:56 <dmwit> It's not clear to me at all why we would want any of these instances you're naming.
16:37:02 <dmwit> We aren't missing Factor.
16:37:48 <tgeeky> dmwit: that's just once instance.
16:37:55 <dmwit> we have Introduce (DistributivePlus t1 t2 t3) and Eliminate (DistributivePlus t1 t2 t3), one of those is the one you're referring to
16:37:55 <Cale> acowley: what'd he have to say?
16:37:59 <tgeeky> dmwit: oh, I see what you're saying.
16:38:07 <acowley> He was advocating longer names
16:38:25 <acowley> in the dicussion between Constant, Const, or K
16:38:29 <Cale> LOL
16:38:32 <acowley> and similar for Identity
16:38:48 <acowley> I should suggest Data.Functor.Constant.T
16:39:07 <dmwit> Yes, that seems like a sufficiently long name.
16:39:08 <Cale> The guy who names everything T or C is arguing for longer names!
16:39:10 <Cale> hahaha
16:39:13 <quintess`> acowley: that has an ML flavor
16:39:56 <dmwit> It is pretty funny, but I'm sure you know that as far as he's concerned, the name is Something.Really.Specific.T, not T.
16:40:32 <acowley> dmwit: I think the worst part is that you can totally see where he's coming from with that scheme, but when you try to find your way around the code, especially the haddocks, it's insane
16:40:44 <dmwit> Yes, haddock needs a bit of help.
16:41:02 <dmwit> I really do blame haddock for the mess, not Henning.
16:41:09 <Cale> I blame Henning too.
16:41:16 <acowley> I think also that helpfully chosen names can serve as short, in-place documentation
16:41:30 <Cale> I *hate* being forced to qualify things, and this is somehow especially true in type signatures.
16:41:50 <acowley> I blame Henning because I really wanted to use his code!
16:42:11 <Cale> I've actually considered writing a dehenning tool
16:42:21 <Cale> But it's pretty tricky
16:42:43 <acowley> import qualified Something.Realy.Specific as Mnemonic
16:42:56 <Cale> Still, it would be nice to upload <packagename>-sane versions to Hackage for all of this packages which had the names fixed.
16:43:04 <tgeeky> just do: Something.Really.Specific as SRS :o
16:43:05 <palmfrond> i need smart ppl, stat! you know blueprints? like for old machines and architectural drafting? well there's always that info area which describes the title of the document itself, author, date of creation, etc. i /dont/ mean legend, as this would refer to the content data of the blueprint's schematic. what is the name of that info area? annotation? header? i can't find any "blueprint architectural
16:43:05 <palmfrond>  drafting format standards" in a web search.
16:43:07 <acowley> if I need to do that, I might as well provide useful names to the types and classes
16:43:42 <Cale> palmfrond: And you're asking in a channel about programming in Haskell?
16:43:45 <acowley> tgeeky: then you want to pull something in from Something.Rather.Silly and end up with SRS2 or some nonsense
16:43:46 <hpc> is it possible to get GHC to do defaulting on a type constrained by Ord?
16:43:50 <ion> import qualified Richard.Matthew.Stallman as RMS
16:44:10 * hpc wants to write an evilSort :: [()] -> [()]
16:44:10 <tgeeky> tg: nah. just use defualting.
16:44:13 <Cale> palmfrond: Why does it matter what it's called? Call it whatever you want.
16:44:14 <acowley> Haskellers are architectural astronauts
16:44:25 <ion> hpc: unsafeCoerce
16:44:26 <monochrom> http://www.vex.net/~trebla/haskell/module.xhtml
16:44:31 <Pseudonym> acowley: Bananas in space?
16:44:38 <hpc> ion: it needs to not be obvious
16:44:51 <Cale> palmfrond: All of those names seem entirely reasonable.
16:44:51 <hpc> this is for php-haskell-prelude
16:44:56 <kallisti> I'm at a complete loss as to why this parser is failing
16:45:05 <kallisti> though it seems to be something to do with my whitespace parser.
16:45:12 <ion> > (() < (), () == (), () > ())
16:45:12 <lambdabot>   (False,True,False)
16:45:36 <acowley> Yes, we should have sent bananas before chimps. Our strategy lacked a sufficiently functional foundation.
16:45:46 <palmfrond> anyone else? heh
16:46:04 <palmfrond> i would like hear acowley's idea
16:46:24 <acowley> Great! Which of my ideas would you like to hear about?
16:46:25 <palmfrond> i am indeed an architectural astronaut, and it's nice of you to notice. =)
16:46:42 <palmfrond> an answer to my question from you
16:46:47 <acowley> I would go with "Signature Area" for the blueprint question
16:47:01 <acowley> because I think inspectors have to sign there, too, don't they?
16:47:05 <kallisti> there must be something I'm not understanding about attoparsec
16:47:23 <tgeeky> palmfrond: I would just go with "Details"
16:47:36 <ion> hpc: Ah. instance Num String where { a + b = show (read a + read b :: Integer); … }; instance IsString Integer where { fromString :: read } etc? :-)
16:47:42 <ion> fromString = read
16:47:45 <palmfrond> hmm
16:47:51 <palmfrond> both really awesome thoughts
16:48:11 <tgeeky> someone is on drugs
16:48:12 <tgeeky> bbl
16:48:14 <palmfrond> Details keeps it basic, Signature Area really captures nicely a regular use of blueprints.
16:48:41 <hpc> aha!
16:48:43 <palmfrond> however being more specific, it's by definition less abstract. so for this, i'll go with details
16:48:44 <Cale> palmfrond: http://www.hnsa.org/doc/pdf/blueprint.pdf defines it as the "title block"
16:48:45 <hpc> extended default rules
16:48:48 <palmfrond> thank you both
16:48:51 <palmfrond> whoa!?!?!?
16:49:17 <Cale> Now start talking about Haskell or get out :)
16:49:25 <hpaste> “attoparsec help” pasted “kallisti” at http://hpaste.org/68046
16:49:34 <kallisti> can someone tell me why this parser isn't matching this input?
16:49:43 <ion> I like it when code pastes people.
16:49:47 <palmfrond> cale, which chapter please?
16:49:51 <palmfrond> i'd like to read surrounding context
16:49:57 <acowley> The blueprint is functorial with respect to the signatures. In fact, you could draw another blueprint in the title block...
16:50:03 <palmfrond> you and i both know my mind is made for haskell. that will come.
16:50:12 <palmfrond> hmm
16:50:22 <palmfrond> "functorial" lolz back at you.
16:50:23 <NihilistDandy> palmfrond: Chapter 1
16:50:26 <palmfrond> k sec
16:50:48 <palmfrond> INFORMATION BLOCKS !!
16:50:56 <kallisti> is "many anyChar" not doing what I think it does?
16:51:07 <NihilistDandy> What a weird name for a block of information.
16:51:31 <palmfrond> The title block is located in the lower-right corner of all blueprints and drawings prepared according to MIL-STDs. It contains the drawing number, name of the part or assembly that it represents, and all informa- tion required to identify the part or assembly.
16:51:31 <palmfrond> It also includes the name and address of the govem- ment agency or organization preparing the drawing, the scale, drafting record, authentication, and date
16:51:44 <palmfrond> cale you are practically an internet master
16:51:48 <palmfrond> thank you :)
16:52:12 <Cale> palmfrond: All I did was put "parts of a blueprint" into google
16:52:15 <palmfrond> please, how did your search go to find your way to this ?
16:52:22 <Cale> palmfrond: and that was practically the first thing which came up
16:52:26 <palmfrond> parts, yes, outstanding!
16:52:33 <palmfrond> great terminology
16:52:45 <kallisti> hlep attoparsec
16:53:07 <palmfrond> you kept it simple, obvious, high level/generic. "parts"
16:53:16 <palmfrond> i'm excited to get into haskell
16:53:32 <acowley> kallisti: can you throw a complete program demonstrating the problem up on hpaste?
16:53:36 <NihilistDandy> I got a subcontractor job with a web firm this week. Once I've got my feet wet, I think I'll start leveraging some Yesod goodness and then try to get my boss into Haskell :D
16:53:46 <NihilistDandy> If for no other reason than to get him away from PHP
16:54:17 <palmfrond> is there any legitimate reason nowadays why someone wouldn't use haskell as the best language for any software need?
16:54:23 <palmfrond> really, anything(s) at all.
16:54:24 <kallisti> acowley: possibly
16:54:33 <palmfrond> it's critical to know a tool's proper limits
16:54:39 <palmfrond> tools*
16:54:53 <boccato> If I want to access oracle what is the best library?
16:55:01 <hpc> boccato: hdbc-odbc
16:55:04 <acowley> palmfrond: if the target platform isn't supported by GHC
16:55:14 <boccato> Any chance it works on a mac?
16:55:16 <jfischoff> Cale: what is like writing haskell for the iPhone?
16:55:19 <palmfrond> how obscure would that platform be acowley ?
16:55:24 <hpc> palmfrond: or if you can't handle enormous executables
16:55:32 <acowley> palmfrond: the iPhone for example
16:55:50 <palmfrond> really enormous? what are we talking? say a basic minimal web browser in haskell
16:56:14 <Cale> jfischoff: You still have to be a bit more performance conscious than you would be with a desktop, but otherwise, it's similar.
16:56:16 <NihilistDandy> I think most of the arguments against Haskell are "it's hard" and "I don't like their GC" and "language Foo is just better"
16:56:38 <hpc> palmfrond: compiled binaries produced by GHC tend to be much larger than in other languages
16:56:42 <NihilistDandy> But that's a bit generalized~
16:56:49 <palmfrond> like 5GB?
16:57:05 <rasfar> are ghc programs still statically linked on the iPhone?
16:57:13 <rasfar> *ghc-compiled that is
16:57:16 <kallisti> acowley: that's pretty much the problem though
16:57:21 <NihilistDandy> Although shared libs seem to be helping that where they're supported
16:57:21 <hpc> actually, it seems to be getting better now
16:57:22 <kallisti> that parser fails, so it backtracks
16:57:25 <blackdog> hpc: erik castro de lopo had some idea about that - apparently there's some trick you can pull with linking
16:57:26 <kallisti> and then the next parser after it fails.
16:57:31 <hpc> hello-world is only some 600K
16:57:42 <blackdog> but every function has to be in its own link section
16:58:01 <hpc> blackdog: i just run strip after compiling
16:58:04 <jfischoff> Cale: what is the worst part compared to straight objective c programming?
16:58:09 <hpc> it shrinks it down most of the way to sanity
16:58:13 <Cale> palmfrond: Like, if you're programming a microcontroller with 256k of memory, using Haskell directly might not be the best option. There are libraries in Haskell for real-time programming with tight space constraints, though they're for metaprogramming (your program will run to emit another program)
16:58:14 <rasfar> strip only saves me 40% or so
16:58:38 <blackdog> hpc: i get an 18k binary with -dynamic, but i suppose that's cheating.
16:58:44 <NihilistDandy> The best language to write C in is Haskell :D
16:58:59 <jfischoff> palmfrond: a lot times you have to use what your given.
16:59:02 <palmfrond> cale, what is the emitted program written in please?
16:59:07 <hpc> oh, you might have to interface with a library in another managed language
16:59:12 <NihilistDandy> palmfrond: Whatever your emitter writes
16:59:13 <Cale> jfischoff: I couldn't say, as I've never written a significant amount of Objective C, but probably the hardest general thing at the moment is going to be getting the toolchain set up. Thankfully much of that is going into GHC proper now. :)
16:59:16 <hpc> interop between haskell and say, java or python
16:59:18 <hpc> is famously horrid
16:59:21 <blackdog> hpc: but even with strip, you've got code there that's not used - apparently the standard linker can't strip out all the stuff you don't use.
16:59:25 <kallisti> acowley: oh maybe not
16:59:27 <palmfrond> NihilistDandy?
16:59:28 <kallisti> I isolated that parser
16:59:30 <Cale> palmfrond: C or assembly?
16:59:31 <kallisti> with the input in the comment
16:59:39 <ion> hpc: And PHP?
16:59:45 <hpc> and php ;)
16:59:46 <palmfrond> haskell apps can be 'emitted' as C apps?
16:59:53 <kallisti> oh wait yeah it fails
16:59:58 <kallisti> it's returning Right []
17:00:04 <blackdog> Cale: wondering if you know: i was a bit surprised to find GHC bundled on the ARM distro of ubuntu. would that be an unregisterised build?
17:00:05 <kallisti> which means that many parsed nothing.
17:00:05 <jfischoff> Cale: are we talking cross compilation out of the box?
17:00:09 <Cale> palmfrond: i.e. you write a Haskell program which itself writes a C program when you run it (but also guarantees a bunch of constraints)
17:00:19 <palmfrond> yes
17:00:23 <palmfrond> that's amazing, how does it work please?
17:00:37 <Cale> jfischoff: yeah, or close to it anyway
17:00:47 <kallisti> Left "not enough bytes"
17:00:49 <kallisti> what...
17:00:49 <palmfrond> how can a compiler know how to take my app in haskell, and generate the C for it???
17:00:57 <blackdog> palmfrond: that's not what he's saying
17:00:59 <jfischoff> Cale: do you know what version its suppose to come out in?
17:00:59 <hpc> @where ffi
17:00:59 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/haskellch8.html
17:01:23 <blackdog> although if you use jhc, it compiles down to C... usually doesn't work for an arbitrary selection of hackage packages, though
17:01:26 <kallisti> acowley: so yeah I changed many to many1, and it says "not enough bytes"
17:01:28 <kallisti> I don't understand why..
17:01:35 <Cale> jfischoff: Well, I think it's in HEAD now...
17:01:58 <Cale> Honestly, blackh knows this part better than I do :)
17:01:59 <palmfrond> k i'm confused now
17:02:14 <jfischoff> Cale: Sweet, just got my weekend project.
17:02:26 <Cale> palmfrond: Yeah, you're confused. The Haskell compiler turns your Haskell program into machine code.
17:02:44 <Cale> palmfrond: You run that program and it spits out C code for the microcontroller.
17:03:24 <Cale> jfischoff: If you get stuck or want more information, you should talk to Stephen Blackheath
17:03:41 <jfischoff> Cale: just email him?
17:03:44 <Cale> yeah
17:04:01 <NihilistDandy> palmfrond: http://en.wikipedia.org/wiki/Automatic_programming
17:04:09 <jfischoff> Cale: cool
17:04:26 <Cale> He's the guy who actually wrote the stuff
17:04:33 <Cale> palmfrond: Let me find you a talk
17:05:15 <Cale> palmfrond: http://dmcc.acm.org/pres/?query=/dmcc///confdata/ICFP2008/2008-09-26_09h56
17:05:50 <Cale> there's a talk on writing realtime systems to control hybrid hydraulic vehicles in a Haskell DSL for realtime applications
17:05:57 <kallisti> http://hpaste.org/57146  oh look here's a paste with the exact same error
17:06:17 <palmfrond> cale, oh you mean it spits out the machine code
17:06:31 <Cale> palmfrond: yes, or code in some other low-level language
17:06:34 <Cale> in this case it's C
17:06:40 <palmfrond> spitting out C source code wouldn't be much different would it?
17:06:48 <palmfrond> vs compiled code
17:06:50 <Cale> http://hackage.haskell.org/package/atom
17:06:51 <Cale> ^^
17:06:55 <palmfrond> sec
17:07:21 <palmfrond> holy shit
17:07:32 <palmfrond> er, whoa
17:08:38 <c_wraith> atom is pretty amazing
17:09:37 <NihilistDandy> Why the atto- in attoparsec?
17:10:02 <c_wraith> it's a joke
17:10:03 <Cale> NihilistDandy: I guess it's meant to be small :)
17:10:19 <NihilistDandy> I thought so, but I wasn't sure what the joke was :D
17:10:25 <c_wraith> https://www.google.com/search?q=attoparsec+in+inches
17:10:37 <Cale> one attoparsec is about 3 centimetres
17:10:54 <NihilistDandy> Right, that was the first thing I found
17:11:27 <NihilistDandy> Microfortnight :D
17:12:48 * hackagebot sqlite 0.5.2.2 - Haskell binding to sqlite3  http://hackage.haskell.org/package/sqlite-0.5.2.2 (AdamWick)
17:12:59 <Cale> http://en.wikipedia.org/wiki/List_of_unusual_units_of_measurement -- lol
17:13:51 <NihilistDandy> Sounds like an opportunity to increase job security.
17:14:35 <Pseudonym> @google pi seconds in nanocenturies
17:14:37 <lambdabot> http://www.johndcook.com/blog/2010/10/14/duffs-rule/
17:14:38 <lambdabot> Title: Pi seconds equals one nanocentury — The Endeavour
17:15:39 <Cale> > 69 ** pi ** sqrt 5 :: CReal
17:15:41 <lambdabot>   602191201246327206194369.188281984752755166804379279849082971168
17:16:07 <Cale> > 69 ** pi ** sqrt 5 :: Double
17:16:08 <lambdabot>   6.021912012463285e23
17:16:23 <c_wraith> um
17:16:40 <c_wraith> What?
17:16:49 <Cale> Avogadro's number :)
17:17:02 <c_wraith> oh, I missed the e23 in the double
17:18:47 <Cale> > let protonMass = 1.67262158 * 10^(-27); electronMass = 9.10938188 * 10^(-31) in protonMass / electronMass
17:18:48 <lambdabot>   *Exception: Negative exponent
17:18:52 <Cale> oh, derp
17:18:57 <Cale> > let protonMass = 1.67262158 * 10^^(-27); electronMass = 9.10938188 * 10^^(-31) in protonMass / electronMass
17:18:58 <lambdabot>   1836.1526633023311
17:19:08 <Mathnerd314> :t (^^)
17:19:09 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
17:19:13 <Mathnerd314> :t (^)
17:19:14 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
17:19:33 <Cale> > (exp 8 - 10) / ((1 + sqrt 5) / 2)
17:19:34 <lambdabot>   1836.1530151397576
17:20:02 <hpaste> acowley annotated “kallisti” with “kallisti (annotation)” at http://hpaste.org/68046#a68048
17:20:38 <BMeph> Cale: Looking up "furlongs per fortnight"? ;)
17:20:53 <Cale> BMeph: Trying out some of the recent approximations on xkcd
17:20:57 <Cale> http://xkcd.com/1047/
17:21:16 <Cale> > 6 * pi^5
17:21:17 <lambdabot>   1836.1181087116884
17:21:32 <kallisti> acowley: oh I found the problem btw..
17:21:42 <kallisti> and yes it involved doing that
17:21:51 <kallisti> except I don't use try because I'm a bad person.
17:32:02 <Cale> > 4 / foldl (\n r -> (2*n-1) + n^2 / r) 0 [1..100]
17:32:04 <lambdabot>   -3.9603960396039604e-2
17:32:08 <Cale> > 4 / foldr (\n r -> (2*n-1) + n^2 / r) 0 [1..100]
17:32:10 <lambdabot>   3.141592653589793
17:32:56 <ion> > 4 / foldr (\n r -> (2*n-1) + n^2 / r) 0 [1..100] - pi
17:32:57 <lambdabot>   0.0
17:33:11 <NihilistDandy> What a surprising result.
17:33:13 <ion> > 4 / foldr (\n r -> (2*n-1) + n^2 / r) 0 [1..100] - pi :: CReal
17:33:17 <lambdabot>   mueval-core: Time limit exceeded
17:33:23 <NihilistDandy> s/ing/ed/
17:33:41 <Cale> What a surprised result?
17:33:50 <NihilistDandy> <lambdabot>  0.0
17:33:54 <Cale> oh I see
17:34:40 <Cale> > map (4/) $ scanr (\n r -> (2*n-1) + n^2 / r) 0 [1..100]
17:34:42 <lambdabot>   [3.141592653589793,1.0929581789406508,0.6597923663254877,0.4722281359693536...
17:34:57 <Cale> of course...
17:39:23 <anoob> amazing: http://tryhaskell.org :D
17:39:51 <Cale> > 2 + foldr ((recip .) . (+)) 0 (concat [[1,2*k,1] | k <- [1..10]])
17:39:53 <lambdabot>   2.7182818284590455
17:41:00 <Cale> > 2 + foldr ((recip .) . (+)) 0 (concat [[1,2*k,1] | k <- [1..10]]) :: CReal
17:41:02 <lambdabot>   2.7182818284590452353602874647260310349526
17:41:07 <Cale> > exp 1 :: CReal
17:41:08 <lambdabot>   2.7182818284590452353602874713526624977572
17:41:36 <rasfar> anoob: you should try also http://haskellonline.org/ which was just announced some moments ago on the haskell-cafe mailing list, and tell us what you think...
17:41:54 <anoob> rasfar, thanks, i'll check it
17:42:13 <rasfar> (i haven't even visited it myself yet, but it seemed a timely recommendation) :p
17:45:04 <tgeeky> dmwit: ok. regardless of any nonsense, the next step is essentially writing all of the < ... > |-> [...], and such machine transition rules
17:45:28 <anoob> let seems to be complicated to me :P
17:45:31 <tgeeky> dmwit: or in the case that we're actually done with that, we need to write the stepper and unstepper functions?
17:45:40 <NihilistDandy> rasfar: Neat. Hadn't seen that on the list, yet. Need to check my email :D
17:45:58 <Cale> > let x = 5 in x * x
17:45:59 <lambdabot>   25
17:46:26 <Cale> > let x = 3; y = 4 in x^2 + y^2
17:46:27 <lambdabot>   25
17:46:54 <Steve|Office> mapM_ runs actions in order, right?
17:46:59 <Cale> Steve|Office: right
17:47:43 <greyEAX> hello can anyone tell me why himerge is missing from haskell.org?
17:47:56 <Cale> Steve|Office: Effectively,   mapM_ f [] = return (); mapM_ f (x:xs) = do f x; mapM_ f xs
17:48:10 <Cale> Steve|Office: except that it's actually defined more concisely in terms of sequence_
17:48:20 <Steve|Office> Cale: Okay, thanks.
17:48:44 <Steve|Office> I'm trying to figure out why my Haskell code and my C++ code differ.
17:48:56 <Cale> anoob: If you have questions about how let works, just ask :)
17:49:07 <Cale> Steve|Office: in result?
17:49:08 <anoob> Cale, thanks
17:49:29 <Cale> anoob: One subtlety is that you can make recursive definitions.
17:50:05 <Steve|Office> Cale: Yeah. I'm trying to create a permutation of [0,n) using a (bad) algorithm used elsewhere.
17:50:10 <Cale> > let ones = 1 : ones in ones
17:50:12 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:50:30 <Cale> > let fac 0 = 1; fac n = n * fac (n-1) in fac 10
17:50:31 <lambdabot>   3628800
17:50:53 <anoob> take it easy :P
17:50:55 <Cale> :)
17:51:11 <anoob> to much information, my brain will explode :P
17:51:27 <Steve|Office> > let fac n = product [2 .. n] in fac 10
17:51:28 <lambdabot>   3628800
17:52:11 <anoob> it's a function definition and a call at the same time?
17:52:21 <Cale> let <declarations> in <expression>
17:52:37 <Cale> is an expression which makes the declarations available for use in the contained expression
17:52:57 <copumpkin> Steve|Office: I'm glad you didn't include the 1 in there! that'd cause an unacceptable slowdown :)
17:53:05 <Cale> So you can say what the values of things are locally, and compute some result in terms of them
17:53:13 <anoob> my oop and structured knowledge will not be useful here :P
17:53:22 <copumpkin> anoop?
17:53:22 <Steve|Office> copumpkin: I actually included it at first and then changed it before pressing enter. =)
17:53:28 <copumpkin> where the an- prefix means "without"
17:53:46 <lispy> greyEAX: himerge?
17:54:10 <greyEAX> its an emerge frontend for gentoo linux
17:54:11 <lispy> greyEAX: what do you mean by missing from haskell.org? (please elaborate)
17:54:13 <greyEAX> written in haskell
17:54:14 <greyEAX> http://www.haskell.org/haskellwiki/Himerge
17:54:17 <greyEAX> the page exists
17:54:20 <greyEAX> but the download does not
17:54:26 <Cale> anoob: It's similar to declaring some local constant variables, except that it can be put anywhere you can put an expression
17:54:31 <lispy> ah
17:54:40 <Cale> (in say Java or something, I don't know what you're familiar with)
17:54:41 <ion> > let fac n = snd (facs !! n); facs = (0,1) : map (\(n,f) -> ((n+1), (n+1) * f)) facs in fac 10
17:54:42 <lambdabot>   3628800
17:55:00 <Cale> I guess in Java you can't define functions locally :)
17:55:21 <lispy> greyEAX: there was a server move at one point and a lot of links that that got broken. You'll need to find another copy of the repo (or look on hackage)
17:55:25 <Cale> (unless things have changed since I last used it)
17:55:26 <anoob> Cale, php/javascript
17:55:29 <avpx> Cale: You sort of can.
17:55:49 <lispy> greyEAX: http://hackage.haskell.org/package/himerge
17:55:58 <Steve|Office> Cale: You can make anonymous classes.
17:56:19 <avpx> Cale: You have to instantiate an interface and provide an implementation for a method, so it's a bit roundabout, but you can definitely do it
17:56:33 <Cale> Javascript has let too :)
17:56:53 <Cale> (though its let works a little differently, it doesn't allow recursion)
17:58:05 <Cale> https://developer.mozilla.org/en/New_in_JavaScript_1.7#let_expressions
17:58:21 <avpx> > let s (x:xs) = x:s [n | n <- xs, (n `mod` x) > 0] in takeWhile (<100) . s $ [2..]
17:58:23 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
17:58:35 <anoob> Cale, i see ...
17:58:58 <Steve|Office> How is "if p1 then e1 else if p2 then e2 else e3" grouped?
17:59:14 <Cale> maximal munch
17:59:16 <Steve|Office> There's only one valid way, right?
17:59:21 <avpx> I'm pretty sure it's if p1 then e1 else (if p2 then e2 else e3)
17:59:30 <Cale> if p1 then e1 else (if p2 then e2 else e3)
17:59:31 <Cale> yeah
17:59:41 <ion> Oh, “let” makes scoping between {…} much nicer in JavaScript.
18:00:28 <NihilistDandy> hsenv is my favorite thing in the world, now :D
18:02:13 <Cale> Steve|Office: it's harder to be ambiguous when every if must have an else
18:05:41 * sipa nukes fukushima
18:05:58 <Cale> wat
18:11:06 <chenwj> hi
18:11:49 <QinGW> hi
18:12:52 * hackagebot prefix-units 0.1.0 - A basic library for SI/binary prefix units  http://hackage.haskell.org/package/prefix-units-0.1.0 (IustinPop)
18:23:06 <zachk> what is a simple example of using view patterns with pattern guards?
18:32:36 <dmwit> tgeeky: Yes, that's what I'm working on now.
18:43:25 <rasfar> NihilistDandy: sorry was afk; oh great, then when you catch up on the list, you can see my blunder re. HSE on the "Haskell source AST zipper" thread. :-/
18:44:01 <rasfar> what do people use for navigation within an AST in Haskell, anyways?
18:44:20 <NihilistDandy> rasfar: Haha.
18:44:29 <rasfar> :-p
18:45:00 <otters> a razor and a note
18:46:21 <rasfar> maybe it doesn't come up that much? lol otters! but really, you can do generic traversals with SYB easily enough, but for crawling around in a specific fashion, hope to see some experience reports on that topic.
18:50:51 <rodayo> Is there a way to fetch some subset of the later portions of a list? Like fetching [6,7,8] from [1,2,3,4,5,6,7,8]?
18:51:35 <tgeeky> > (drop 5) [1..9]
18:51:36 <lambdabot>   [6,7,8,9]
18:51:40 <tgeeky> > (drop 5) [1..8]
18:51:41 <lambdabot>   [6,7,8]
18:52:51 <rodayo> okay great thx
18:53:04 <kallisti> I'm surprised there's no recursive directory walk.
18:57:21 <shapr> kallisti: Built into the libs?
18:57:26 <shapr> kallisti: I want that also.
18:57:47 <kallisti> well it's simple to implement, but it's one of those things I would expect to be standard.
18:57:56 <Roklobsta|2> hello haskell boffins.
18:57:57 <shapr> I agree.
18:58:14 <shapr> kallisti: Clearly you should write it and put it on Hackage.
18:58:22 <shapr> Either that or I'll do it after finals.
18:58:37 <kallisti> shapr: that seems to be something I'm doing a lot of lately. so sure.
18:58:37 <shapr> god morgon Roklobsta|2
18:58:39 <Roklobsta|2> i have a question... would haskell be any good as a real time DSP platform?
18:59:36 <shapr> If you mean the GHC runtime, it's not friendly to real-time applications because of the unpredictability of resource usage (cpu/mem).
18:59:49 <shapr> Roklobsta|2: But Haskell would be excellent at generating real-time code.
18:59:52 <Roklobsta|2> by that i mean having simple functions doing DSP chained together like GNURadio.
19:00:03 <kallisti> as a programming language, Haskell fits naturally with DSP.
19:00:22 <Roklobsta|2> i am happy to compile a fast binary I don't want interpreted code.
19:00:25 <shapr> I know they got Haskell working with real-time garbage collection... on garbage trucks.
19:01:19 <rodayo> What's with this: Suppose arr=[1..9] and you do a "let ptr = 4" then (arr !! ptr) throws an error because it expects an Int and gets an Integer instead. But if you do (arr !! (fromIntegral ptr)) you get 5 but if you do "let b = fromIntegral ptr" then arr !! b will still throw an error
19:01:41 <shapr> It's hard to find the garbage truck Haskell article, garbage collection is too common.
19:01:52 <kallisti> rodayo: it sounds like you have MonoLocalBinds on
19:02:05 <kallisti> are you using fancy type-level extensions?
19:02:24 <rodayo> kallisti, i haven't heard of such extensions. I'm using ghci just as I got it from apt-get
19:02:38 <kallisti> hm. I see
19:02:43 <kallisti> well an explicit type signature will fix the problem
19:02:55 <kallisti> integer literals in Haskell are overloaded on many different types
19:03:05 <kallisti> in your case
19:03:10 <Roklobsta|2> kallisti: so if I kepp the dsp functions as pure functions and chain them together any old how will the compiled code move the data around quickly and efficiently, or isthere some sort of expensive message and data passing between the function going on behind the scenes?
19:03:12 <kallisti> it seems to be defaulting to Integer
19:03:14 <rodayo> A type signature for (!!)?
19:04:11 <kallisti> Roklobsta|2: Haskell has the most aggressive inlining I know of, specifically because it can get away with it as a result of referential transparency. There are options that will let GHC show you optimizations such as inlined functions and rewrite rules (I don't remember the option name off-hand)
19:04:20 <kallisti> rodayo: right, but that's why I suggest MonoLocalBinds
19:04:33 <kallisti> because then it would default to Integer in the local binding, unless you specified a type signature.
19:04:40 <kallisti> but... I don't ghci enables that by default
19:04:50 <kallisti> oh wait, it might
19:04:53 <rodayo> kallisti, i'll look into that then i guess...
19:04:56 <kallisti> yeah that makes sense.
19:05:02 <kallisti> since it's interactive
19:05:13 <kallisti> Prelude> let x = 2
19:05:14 <kallisti> Prelude> :t x
19:05:14 <kallisti> x :: Integer
19:05:25 <kallisti> it can't infer the type of x based on expressions that don't exist yet.
19:05:31 <Roklobsta|2> kallisti: ok, secondly if I used fixed point data types will GHC end up using native SSE integer data types, like 64 bit integers and MAC like opcodes?
19:05:33 <kallisti> so it defaults to Integer.
19:05:52 <kallisti> Roklobsta|2: uh... no idea.
19:06:07 <kallisti> it will usually be "bixed" by pointers
19:06:24 <kallisti> but, again, some optimizations will unbox these data structures if the compiler can determine it's safe to do so.
19:06:32 <kallisti> also you're free to use unboxed typed, but they tend to be a pain to program with.
19:06:36 <kallisti> *types
19:07:11 <Roklobsta|2> kallisti: I am interested in writing some DSP applications using Haskell for it's simplicity but I am also after realtime performace, like using all 4 or 8 cores in an i5/i7 with SSE2 opcodes.
19:07:38 <kallisti> none of that really implies "real time"
19:07:48 <kallisti> unless you're using a special real time OS and not a regular desktop system.
19:08:06 <Roklobsta|2> ok, maybe not real time by definition but fast enough to consume and process the data in real time.
19:08:32 <kallisti> that should be possible, yes.
19:09:06 <kallisti> well, I suppose it fits under real time.
19:09:09 <Roklobsta|2> i should just suck it an see as an experiment.
19:09:25 <kallisti> but usually when people say "real time" they're talking about embedded software or something where there's extreme time constraints.
19:09:26 <Roklobsta|2> good excuse to learn I/O monads and haskell anyway.
19:09:53 <Roklobsta|2> kallisti: i appreciate that.  I guess I mean fast enough to process the data without overruns
19:10:16 <Roklobsta|2> as the data will be up to 6.8MB/sec
19:10:21 <Roklobsta|2> from an ADC
19:10:52 <kallisti> what is an ADC?
19:11:04 <kallisti> in this context
19:11:10 <kallisti> oh probably analog-to-digital
19:11:13 <kallisti> duh. :P
19:12:43 <kallisti> if it's not fast enough, you can always interface with C
19:12:48 <kallisti> there's actually a csound API in Haskell
19:13:09 <Roklobsta|2> ew i am not processing audio, it's for software defined radio.
19:13:41 <kallisti> well, I don't think csound requires its data to be audio data either.
19:14:41 <Roklobsta|2> gawd I ran csound once back in 1994 on a 486.  it was sluh-ow.
19:16:05 <kallisti> presumably it's been improved in 17 years.
19:16:17 <kallisti> I was under the impression it was "good for real time"
19:16:29 <kallisti> (whatever that means)
19:17:43 <kallisti> Roklobsta|2: as far as dealing with data as pure functions, I wouldn't advise attempting that with inputs
19:17:56 <Roklobsta|2> how come?
19:17:59 <Roklobsta|2> i am naive.
19:18:00 <kallisti> you'd want both a function representation as well as a discrete variable-sample-rate representaton.
19:18:11 <kallisti> which is essentially a list.
19:18:20 <kallisti> of ordered pairs.
19:18:34 <Roklobsta|2> what like time,sample?
19:18:40 <kallisti> yes
19:18:41 <Roklobsta|2> or index,sample?
19:18:52 <kallisti> no you don't need an index.
19:18:57 <kallisti> if you mean like...
19:19:03 <kallisti> > zip [1..] "hello"
19:19:05 <lambdabot>   [(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]
19:19:09 <Roklobsta|2> oh
19:19:09 <kallisti> not that kind of index.
19:19:48 <kallisti> but a list naturally represents a discrete-time signal.
19:19:52 <tgeeky> dmwit: how's it going?
19:20:01 <dmwit> tgeeky: Just pushed an evaluator for pi terms.
19:20:06 <dmwit> No constraint solving at all yet.
19:20:06 <kallisti> *discrete time domain
19:20:20 <tgeeky> dmwit: checking. you gonna be around for a while?
19:20:30 <dmwit> I'm pretty much done for the day, I think.
19:20:34 <tgeeky> kk
19:20:51 <dmwit> I'll be around for chat, but I'm not sure I'll be able to do anything that requires concentration.
19:20:52 <kallisti> Roklobsta|2: and it's pretty straight-forward to convert a "continuos" function representation to a discrete signal
19:20:58 <dmwit> (Like start a constraint solver. =P)
19:21:01 <kallisti> and probably vice versa, but it will be trickier to make it efficient.
19:21:41 <Roklobsta|2> ok.  well, I am about to embark on doing some DSP stuff so I am sitting on the fence, do I do the usual C route or try something in Haskell?
19:21:44 <tgeeky> dmwit: understanding/implementing the stepper functions and whatnot was the same place I got stuck in the partial-isomorphism and invertible-syntax implementation.
19:22:03 <tgeeky> dmwit: bask in this: http://nkwiatek.com/
19:22:12 <rodayo> Does this error sound weird to anyone else: " Couldn't match expected type `[Word8]' with actual type `Word8'     Expected type: [[Word8]]       Actual type: [Word8]" . First it says it expects [Word8] then it says it expects [[Word8]]. Or am I reading it wrong?
19:22:16 <kallisti> Roklobsta|2: I can't say anything about your performance requirements, really. I'm no expert. I think Haskell is a great language for DSP in general though.
19:22:23 <kallisti> for "most purposes"
19:22:24 <dmwit> heh
19:22:31 <kallisti> and it's a hell of a lot easier than C. :P
19:22:40 <dmwit> tgeeky: Really, though? The paper seemed pretty clear on how to do stepping (if not constraint solving).
19:23:46 <Roklobsta|2> kallisti: according to you... a good example of what i'd like to do is something like the data and processing flows detailed on this page (scroll down).  http://www.holmea.demon.co.uk/GPS/Main.htm
19:25:10 <tgeeky> dmwit: really. I get that the rules on the right of page 4 should pretty much spell it all out
19:26:39 <dmwit> Actually, I'm using the rules on page 8 (since I assume we want to do eta and epsilon eventually).
19:27:13 <kallisti> Roklobsta|2: so far the most computationaly intensive process in all of this is the FFT
19:27:23 <kallisti> which we have a interface to C code for.
19:27:27 <dmwit> Is that your website? I seem to be able to fill the screen with paragraph marks, at which point it's stable -- which doesn't seem right, if I understand how friction works.
19:28:03 <tgeeky> dmwit: nope. and it's some degenerate navier-stokes algorithim
19:30:59 <tgeeky> dmwit: ah. you only need four steppers.
19:31:53 <Roklobsta|2> kallisti: oh for FFTW?
19:32:12 <kallisti> yes
19:32:16 <shapr> tgeeky: Not talking about stepper motors?
19:32:33 <tgeeky> shapr: nope
19:32:55 * hackagebot containers 0.5.0.0 - Assorted concrete container types  http://hackage.haskell.org/package/containers-0.5.0.0 (JohanTibell)
19:45:19 <mgsloan1> hmmm, why is ifThenElse not in the Prelude?
19:46:03 <ion> Rather bool :: a -> a -> Bool -> a to match maybe and either and be more useful with pointless code.
19:46:14 <mgsloan> that means that the "RebindableSyntax" extension will break normal (non-prelude hiding) code...
19:46:50 <mgsloan> I'm working on writing Haskell's desugarings as template haskell transformations
19:47:02 <mgsloan> anyone seen code for this somewhere?
19:47:20 <mgsloan> but now I can't decide how to desugar if...
19:47:31 <mgsloan> as I can't test extension flags
19:52:49 <augur> ski: opinion http://en.wikipedia.org/wiki/Plural_quantification#Formal_Definition
20:00:13 <tgeeky> dmwit: ok. so what I should have been thinking, is to divide up the the transitions listed on page 4 (resp. page 8) like you have. I just went and colored <"active"> states green, and ["stop"] states red. Looking at how you broke it up, for instance on the last stepEval (reverse, ascending) it looks like these all correspond to ["stop"]<|   |->   ["stop"]<|. And vice versa for the top stepEval. This works except for the "Base iso" 
20:01:24 <dmwit> tgeeky: The "descending" boolean corresponds to whether the brackets are "<>" or "[]".
20:01:41 <dmwit> tgeeky: And the "forward" boolean corresponds to whether the triangle on the bottom right is "|>" or "<|".
20:02:00 <tgeeky> dmwit: exactly as I deduced from the coloring scheme. :o
20:02:07 <tgeeky> (but not without the assistance of your code)
20:02:58 <dmwit> oh, yes, I can parse your sentence now
20:02:59 <dmwit> sorry
20:04:02 <zachk> how do I mix view patterns with pattern matching?
20:09:45 <tgeeky> dmwit: ok. I think I'll try to duplicate your implementation by hand for some learning. Do you think any of the things we're doing now should be promoted to the kind level, or would that just introduce hassle?
20:11:46 <ski> > let map _ [] = []; map f ((f -> b):(map f -> bs)) = b:bs in map even [0,1,2,3]  -- zachk, like that ?
20:11:47 <lambdabot>   [True,False,True,False]
20:12:10 <ski> augur : what about it ?
20:13:16 <dmwit> Promote anything you want. =)
20:13:41 <rodayo> Does anyone see what I did wrong in line 27 and 28 in this code: http://pastie.org/3857096 I included the errors in the paste as well
20:13:57 <augur> ski: http://en.wikipedia.org/wiki/Plural_quantification#Formal_Definition
20:14:24 <rodayo> Does anyone see what I did wrong in line 27 and 28 in this code: http://pastie.org/3857096 I included the errors in the paste as well
20:14:30 <ski> augur : yes ?
20:14:40 <augur> skiold: i want your opinions on it!
20:14:42 <parcs`> rodayo: yes
20:14:46 <augur> ski even
20:14:53 <augur> (afk, /msg please)
20:15:16 <rodayo> parcs`, so what's wrong with it? It's really bugging me...
20:15:25 <ski> i think to some extent this is "cheating"
20:16:08 <ski> rodayo : maybe you wanted `... ++ [...] ++ [...]' ?
20:17:02 <rodayo> ski, :D Good catch. The mid portion wasn't a list
20:17:20 <zachk> ski: why doesn't this work : f (id->x:(^2)->y:id->z:zs) = (x,y,z)
20:17:20 <zachk>  
20:17:56 <ski>   f ((id -> x):((^ 2) -> y):(id -> z):zs) = (x,y,z)
20:17:56 <ski> ?
20:18:50 <ski> > let f (reverse -> a:as) = (a,as) in f ["abc","def","ghi"]
20:18:51 <lambdabot>   ("ghi",["def","abc"])
20:18:58 <ski> > let f ((reverse -> a):as) = (a,as) in f ["abc","def","ghi"]
20:18:59 <lambdabot>   ("cba",["def","ghi"])
20:19:08 <ski> note the difference
20:19:55 <ski> (also, is there any point in using `id' in your example ?)
20:20:21 <tazjin> @hoogle Eq a => [a] -> [a] -> Bool
20:20:22 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
20:20:22 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
20:20:22 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
20:20:47 <tazjin> > isInFixOf "og" "hoogle"
20:20:48 <lambdabot>   Not in scope: `isInFixOf'
20:20:54 <tazjin> > isInfixOf "og" "hoogle"
20:20:55 <lambdabot>   True
20:22:09 <ski> @let co (isInfixOf "co" -> word) = word; co word = "co" ++ word
20:22:09 <lambdabot>   ViewPatterns is not enabled
20:22:27 <ski> > let co (isInfixOf "co" -> word) = word; co word = "co" ++ word in co "cooperative"
20:22:28 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
20:22:28 <lambdabot>         against inferred type ...
20:22:38 <ski> er, right :)
20:22:51 <ski> > let co (stripPrefix "co" -> Just word) = word; co word = "co" ++ word in co "cooperative"
20:22:52 <lambdabot>   "operative"
20:23:01 <ski> @type stripPrefix
20:23:02 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Maybe [a]
20:28:46 <tazjin> > let g = mkStdGen 52748; d = ["Pizza", "Spaghetti", "Bread rolls", "Pudding", "fast!"] in d !! (fst $ randomR (0, length(d)) g)
20:28:47 <lambdabot>   "*Exception: Prelude.(!!): index too large
20:28:58 <tazjin> Meh
20:29:02 <tazjin> > let g = mkStdGen 52748; d = ["Pizza", "Spaghetti", "Bread rolls", "Pudding", "fast!"] in d !! (fst $ randomR (0, length(d)-1) g)
20:29:03 <lambdabot>   "Pizza"
20:29:37 <tazjin> There's some kind of online ghci right? I don't wanna abuse lambdabot whenever I don't have one in reach
20:29:59 <tgeeky> tazjin: you can do everything you can do in #haskell in private chat
20:30:21 <tgeeky> tazjin: and there's tryhaskell, and the new "haskell typechecker" which is sort of like ghci, on reddit/haskell
20:30:36 <tazjin> Oh nice, thanks for the info
20:44:24 <nyingen> @quote
20:44:25 <lambdabot> AchimSchneider says: Finite automata don't go bottom in any case, at least not if you don't happen to shoot them and their health drops below zero.
20:45:04 <flebron> Ok, so. Typeclass intuition time. For Functor, my intuitions are: 1) The category theoretical (a -> b) -> (F a -> F b) one, lifting functions by passing them through the functor. 2) If the functor is somehow a "box", then I can apply functions to things inside that "box". For Monad, I have "Computations inside a context, being able to change the way in which these computations are chained based on the context." So questions, 1) Are those intuitions reas
20:45:04 <flebron> onable? 2) What should I be thinking for Applicative, and (supposing I had (Pointed F) => Applicative F, what about Pointed?
20:45:27 <heatsink> yes.
20:45:28 <lambdabot> heatsink: You have 3 new messages. '/msg lambdabot @messages' to read them.
20:45:47 <flebron> I have a vague "now I can fmap functions of any arity" intuition for Applicative, but that seems sort of cheating. I think the real magic is somewhere near "It allows F (a -> b) to distribute the functor application to inside the types, giving F a -> F b."
20:45:52 <tgeeky> flebron: this is the kind of thing that would be better asked on stackexchange, for what it's worth
20:46:48 <flebron> Ah, I sort of fear the exchanges after a scary venture into math.se, where, in my mind, There Be Dragons (of the higher algebraic and topological kind).
20:46:50 <dmwit> flebron: Applicative is for types that have a notion of "zip", like list's zip.
20:47:15 <dmwit> They have a 0-ary zip (namely, pure) and a 2-ary zip (namely, <*>), and you can build all the other n-ary zips from those two.
20:47:23 <ski> flebron : for idioms / applicative functors : you can think of them a bit like monadic actions/computations, except that the "wiring" of it is fixed in advance, it can't depend on data provided at run-time (e.g. you can't make an applicative parser which decides what to parse next depending on what it has already parsed : e.g. you can't first parse a number `n', then parse a Foo, `n' times)
20:48:33 <tgeeky> dmwit: really? that's weird. they both have even arity. I would have assumed you'd need at least one odd arity thing to be able to construct anything?
20:48:36 <ski> flebron : an alternative for applicative functors is `zipA :: Applicative i => i a -> i b -> i (a,b)'
20:48:40 <flebron> dmwit: How is it like zip? zip's type doesn't seem to be F (a -> b) -> F a -> F b...
20:48:47 <tgeeky> ski: 'alternative' there is a bad word :o
20:49:03 <ski> er, s/alternative/alternative primitive/ :)
20:49:31 <dmwit> flebron: consider what pure (,) looks like =)
20:49:37 <dmwit> f (a -> b -> (a,b))
20:49:44 <flebron> That I did sort of understand, that Applicative is fixed in that way - F (a -> b) becomes F a -> F b, and not some other sort of computation chaining.
20:50:24 <ski> @type \ia ib -> pure (,) <*> ia <*> ib
20:50:24 <lambdabot> forall a a1 (f :: * -> *). (Applicative f) => f a -> f a1 -> f (a, a1)
20:50:27 <augur> ski: how's it cheating :D
20:51:06 <ski> @type let zipA ia ib = pure (,) <*> ia <*> ib in \iab ia -> fmap (uncurry ($)) (zipA iab ia)
20:51:06 <lambdabot> forall b b1 (f :: * -> *). (Applicative f) => f (b -> b1) -> f b -> f b1
20:51:17 <dmwit> tgeeky: Well, maybe calling it zip isn't fair. It's more like zipWith ($).
20:51:26 <dmwit> tgeeky: And no, you don't need any odd arity ones.
20:51:37 <dmwit> tgeeky: For 1-ary zip, consider
20:51:48 <dmwit> :t \f t -> pure f <*> t
20:51:49 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
20:52:11 <dmwit> There's a coherence law that says that's equal to fmap, but that's sort of secondary.
20:53:57 <ski> augur : i don't see how big a difference to this it would be, if we take the usual first-order predicate logic, and add variables for (sub)sets, and quantifiers over those (but do *not* allow such (sub)set terms as arguments of predicates)
20:54:42 <augur> skiold: im not sure there would be a difference. boolos' point is that you dont need sets at all just to talk about multiple things at once
20:55:15 * ski thinks "skiold" means "shield" in old norse or something
20:55:24 <kallisti> the IsString instance in ByteString.Char8 should probably not be broken, methinks.
20:56:15 <flebron> dmwit, ok, I see the type of pure (,) and of <*>… how are they "generalized zips"? What is the abstract notion of "a zip" that is being encapsulated by these two?
20:56:31 <tgeeky> flebron: best reference here is the original applicative paper
20:56:32 <augur> skiold: change your username
20:56:32 <ski> augur : well, if you take "dont need sets" to mean "dont need sets in the object language", then (probably) ok -- (uncertainty because : what is `\bar(y)', if not a set ? :)
20:56:56 <augur> ski: dont need sets in the domain
20:57:04 <flebron> tgeeky: Is that typeclassopedia?
20:57:10 <ski> augur : should we continue talking only in ##logic ?
20:57:15 <augur> sure
20:57:18 <tgeeky> flebron: No, but it is certainly referenced in typeclassopedia. http://www.soi.city.ac.uk/~ross/papers/Applicative.html
20:57:37 <dmwit> flebron: Not sure I can answer that generically. But if you look at a few instances of Applicative, you'll find that the way they behave is by aligning values in similar "positions" in the two structures.
20:57:40 <kallisti> http://a-dimit.blogspot.com/2012/04/strings-in-haskell.html
20:57:45 <dmwit> flebron: ...like a zip
20:57:46 <kallisti> is ByteString actually "commonly misused"?
20:58:27 <flebron> One I remember is for []: fs <*> xs [f x | f <- fs, x <- xs]
20:58:47 <flebron> And the Maybe one inherited from its monadness, where applying Nothing is Nothing, and the rest works as expected.
20:58:54 <kallisti> yes the Applicative [] instance is exactly the same as a zipWithN
20:59:14 <dmwit> ?src [] (<*>)
20:59:14 <lambdabot> (<*>) = ap
20:59:20 <dmwit> not quite like
20:59:30 <dmwit> But the Applicative ZipList instance is exactly the same as zipWithN. =)
20:59:31 <kallisti> oh wait what am I saying.
20:59:44 <kallisti> yeah ZipList is what I meant. honest. >_>
21:00:01 <dmwit> kallisti: I wonder the same thing. But that post is surely religious about debunking the use of ByteString for text.
21:00:32 <kallisti> the Applicative [] instance is more like a generalized cartesian product.
21:00:34 <flebron> In the [] case it seems that everything is being collided with everything, not just things in equal positions
21:00:40 <kallisti> yes
21:01:08 <kallisti> > (,) <$> [1,2,3] <*> [4,5,6]
21:01:09 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
21:01:10 <flebron> i guess you could map (,) xs or something
21:01:11 <flebron> yeah haha
21:02:02 <kallisti> > [negate, recip] <*> [4,5,6]
21:02:03 <lambdabot>   [-4.0,-5.0,-6.0,0.25,0.2,0.16666666666666666]
21:02:23 <flebron> (Also I've been told Arrows are a nightmare, so I shan't try to understand them until I've got Applicative and Pointed down.)
21:02:27 <kallisti> but it can do more than just cartesian producty stuff.
21:03:15 <dmwit> Does Tree have an Applicative instance?
21:03:31 <flebron> I've only made them Functors :o
21:03:41 <tgeeky> dmwit: it has an Unfoldable instance, so it must have an Applicative instance? :o
21:03:53 <kallisti> > [(:+ 0), (0 :+)] <*> [4,5,6]
21:03:54 <lambdabot>   [4.0 :+ 0.0,5.0 :+ 0.0,6.0 :+ 0.0,0.0 :+ 4.0,0.0 :+ 5.0,0.0 :+ 6.0]
21:04:21 <flebron> What is :+ 0 and 0 :+?
21:04:29 <kallisti> :+ is the constructor for Complex
21:04:35 <dmwit> Hm, it does have one, but it's not the one I want it to have.
21:04:46 <dmwit> I wanted the ZipTree one. =P
21:04:55 <flebron> ah
21:05:08 <kallisti> > let e = exp 1; i = 0 :+ 1 in e**(i*pi) + 1 :: CReal
21:05:09 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
21:05:10 <lambdabot>         against infe...
21:05:16 <kallisti> > let e = exp 1; i = 0 :+ 1 in e**(i*pi) + 1 :: Complex CReal
21:05:19 <lambdabot>   0.0 :+ 0.0
21:05:19 <tgeeky> dmwit: ok. must sleep. thanks for the discussions and your dilligent work :)
21:05:28 <flebron> hehe :)
21:06:23 <kallisti> > let e = exp 1; i = 0 :+ 1 in e**(i*pi) + 1 :: Complex Rational
21:06:24 <lambdabot>   No instance for (GHC.Float.RealFloat
21:06:24 <lambdabot>                     (GHC.Real.Ratio GH...
21:06:30 <kallisti> hm. right.
21:06:50 <kallisti> I guess CReal is what you want for perfect accuracy complex calculations.
21:07:07 <kallisti> or Decimal.
21:12:59 * hackagebot tablestorage 0.1.0.3 - Azure Table Storage REST API Wrapper  http://hackage.haskell.org/package/tablestorage-0.1.0.3 (PhilFreeman)
21:13:53 <kallisti> shapr: I think it would be good to base a directory walking library on trees.
21:14:26 <kallisti> and then have a conversion typeclass Tree FilePath -> t FilePath
21:14:50 <kallisti> (though I don't really think it's needed)
21:15:44 <flebron> Suppose I see this, how am I supposed to parenthesize it? return (:) ‘ap‘ c ‘ap‘ sequence cs
21:16:11 <flebron> I know : is usually insanely high precedence, but it's inside () now, so I've no clue.
21:16:19 <kallisti> flebron: left associative
21:16:32 <kallisti> ((return (:) `ap c) `ap` sequence cs)
21:16:50 <flebron> Ah. Thanks :) Hence using $ to create ( …… )
21:16:56 <kallisti> flebron: (:) is called an operator section. it refers to the operator as a function
21:17:02 <kallisti> > (:) 0 [1,2,3]
21:17:03 <lambdabot>   [0,1,2,3]
21:17:09 <flebron> Right, but I'm thinking it loses its precedence?
21:17:17 <kallisti> precedence no longer makes any sense, so yes.
21:18:26 <flebron> Thanks
21:18:29 <kallisti> > let cons = (:) in 0 `cons` [1,2,3]
21:18:30 <lambdabot>   [0,1,2,3]
21:19:48 <kallisti> flebron: you may be noticing that return is very similar to pure, and ap is very similar to <*>
21:21:57 <whittle> kallisti: Precendence no longer makes sense because function application has the highest precendence, correct?
21:22:14 <kallisti> I mean precedence isn't involved at in parsing (:)
21:22:23 <kallisti> it's just... there. it's the name of a function.
21:22:33 <kallisti> *involved at all
21:24:31 <flebron> kallisti, I know pure is just the theory name of return, and ap is an alias for <*>
21:25:03 <flebron> Pure would also be called "eta" in the monoid object case
21:25:14 <kallisti> they're semantically equivalent for every type on which both are defined, but they're not the same in terms of their type.
21:25:19 <kallisti> they both use different typeclass constraints.
21:26:04 <ski> (`return' is also often called `eta' -- more generally, the "unit" in an adjunction is conventionally called `eta' (and the "counit", corresponding to `extract' in a comonad, `epsilon'))
21:32:23 <kallisti> shapr: also the most general function(s) could include a list of options, for various details like following symbolic links that point to directories, excluding directories, etc.
21:32:49 <flebron> Is it a faux pas to use "pure" when referring to a monad, or "return" when referring to an applicative functor?
21:33:21 <dmwit> etiquette?
21:33:25 <dmwit> in MY programming language?
21:33:43 <kallisti> flebron: well it's not really possible..
21:33:47 <kallisti> pure always refers to an applicative
21:33:52 <kallisti> return always refers to a monad.
21:34:27 <kallisti> (and all monads happen to be applicatives by definition.)
21:35:57 <ski> @wn faux pas
21:35:58 <lambdabot> *** "faux" wn "WordNet (r) 3.0 (2006)"
21:35:58 <lambdabot> faux
21:35:58 <lambdabot>     adj 1: not genuine or real; being an imitation of the genuine
21:35:58 <lambdabot>            article; "it isn't fake anything; it's real synthetic
21:35:58 <lambdabot>            fur"; "faux pearls"; "false teeth"; "decorated with
21:36:00 <lambdabot> [7 @more lines]
21:36:06 <kallisti> so if you can avoid an unnecessary Monad constraint in your type, then do so.
21:36:34 <kallisti> but you don't have to. most people don't.
21:36:43 <ski> flebron : however, not all instances of `Monad' are instances of `Applicative'
21:36:53 <flebron> That's… historical, right?
21:36:55 <whittle> If you have a type that’s an instance of Applicative and Monad, is it kosher to treat it as Applicative in one function, then use that function as an argument to (>>=) elsewhere?
21:37:12 <kallisti> ski: oh wait. I thought it was the other way.
21:37:24 <ski> kallisti : both ways
21:37:27 <flebron> Same as Applicative having a pure but not requiring a Pointed typeclass.
21:37:51 <ski> kallisti : however, every instance of `Monad' *could* (and arguably *should*) be an instance of `Applicative'
21:38:03 <kallisti> oh I see what you mean
21:38:04 <kallisti> right.
21:38:05 <flebron> (It is sort of fun how this stuff is built from one side on the typeclass aspect, and entirely differently on the category theoretical side)
21:38:43 <ski> whittle : probably -- though i think we'd need more details to judge the specific case
21:39:02 <ski> flebron ?
21:40:12 <hpaste> whittle pasted “Monad on applicative” at http://hpaste.org/68060
21:40:42 <whittle> ski: Please be gentle with me; I’m new to Haskell.
21:41:52 <kallisti> dmwit: if Word8 had more convenient literals I would be more opposed to ByteString.Char8, but otherwise I'm not.
21:42:04 <kallisti> because it's way too convenient for me to not use out of principle. :P
21:43:38 <BMeph> Is there a channel for bitching about^W^W discussing Haskell records, and what different solutions allow?
21:45:01 <ski> whittle : in this case the type in question, which is an instance of `Applicative' and `Monad', is `Parser', correct ?
21:45:11 <whittle> ski: Yes.
21:45:14 <kallisti> BMeph: I thought that was what #haskell was for.
21:45:18 <c_wraith> BMeph: try #python :)
21:45:21 <flebron> ski: On the cat theory side you don't really care about "just pointed" or "just applicative", you just grab a monoid object in the category of endofunctors, and you get those things for free. You do care about Functor though.
21:45:28 <ski> whittle : it should be fine, yes
21:46:03 <ski> flebron : sometimes you care about pointed, categorically
21:46:24 <whittle> ski: Thank you. Any advice on how to improve this code, or in general as a Haskeller?
21:46:36 <ski> flebron : e.g. the category of sets with partial functions being equivalent to the category of pointed sets, with homomorphisms
21:47:12 <flebron> Ah, I've never cared about partial functions, I've only seen them in the context of computability :)
21:47:18 <ski> whittle : hint made three suggestions at the end of your paste
21:48:20 <ski> flebron : hm, with homotopy, i think you want pointed, connected, spaces
21:48:48 <whittle> How about that! I didn’t even know hpaste did that!
21:48:48 <ski> (well, path-connected)
21:49:57 <ski> whittle : where is the `s' argument of `mkResult' coming from ?
21:50:41 <ski> hm, now i see where it's coming from -- in `parseJSON'
21:50:43 <hpaste> whittle annotated “Monad on applicative” with “Monad on applicative (annotation)” at http://hpaste.org/68060#a68061
21:51:32 <ski> whittle : wrong bracket-pair :)
21:51:37 <hpaste> whittle annotated “Monad on applicative” with “Monad on applicative (annotation) (annotation)” at http://hpaste.org/68060#a68062
21:52:03 <ski> (though maybe the one you removed can also be safely removed -- it would depend on the precedence of `.:', which i don't know)
21:52:19 <ski> an alternative would be to replace
21:52:25 <ski>   ... >>= mkResult v
21:52:26 <ski> with
21:52:32 <ski>   mkResult v =<< ...
21:52:43 <ski> i'm not sure which you find most readable
21:53:53 <hpaste> whittle annotated “Monad on applicative” with “Monad on applicative (annotation) (annotation) (annotation)” at http://hpaste.org/68060#a68063
21:54:46 <ski> (btw, there is no usually need to annotate with code which hasn't changed from the last paste)
21:54:51 <whittle> ski: I like the =<< version, I just didn’t know about it until you mentioned it.
21:54:56 <ski> ok
21:55:20 <ski> (er, s/no usually need/usually no need/)
21:55:30 <whittle> Ah, got it.
21:56:32 <ski> e.g. instead of writing
21:57:12 <ski>   z <- f x >>= g y . h a >>= i
21:57:17 <ski> i think it would be nicer to write
21:57:32 <ski>   z <- i =<< g y . h a =<< f x
22:01:34 <whittle> I think the part of Haskell that’s continuing to stagger me is the diversity of kinds of function composition.
22:02:12 <ski> `=<<' and `>>=' isn't really function composition, though
22:02:22 <ski> (they're sortof variants of application)
22:03:48 <Luke> when you hold a lens in a ReaderT, what effect does modL have?
22:04:11 <whittle> Right. I just don’t know a word that better describes the many ways Haskell gives you to stick computations together.
22:04:45 * ski nods
22:04:50 <ski> @hoogle modL
22:04:50 <lambdabot> No results found
22:13:03 <NemesisD> what's the recommended time/time format library for haskell?
22:13:19 <NemesisD> i noticed that the time package depends on old-locale
22:16:19 <dmwit> NemesisD: time is the recommended package
22:17:10 <Cale> Weirdly, I don't think there is a new locale package.
22:18:58 <whittle> Perhaps it’s not the package that’s old, but the locales? Like it’s all about the Ottoman Empire and Tsarist Russia?
22:24:13 <flebron> Isn't it sort of ironic that pure does the exact opposite of giving you a pure value? It takes a pure value, and gives you an impure one :s
22:24:33 <flebron> Granted, it's well behaved. But still :s
22:25:14 <dmwit> The point is that it gives you an Applicative value that acts as if it were pure.
22:26:25 <dmwit> (Due to the law pure f <*> v = fmap f v.)
22:27:15 <flebron> Right right.
22:27:28 <flebron> Do people use pure with non functions?
22:27:51 <flebron> Sane people, I mean.
22:28:41 <dmwit> Sure, why not?
22:29:12 <flebron> What good thing comes of it? All I know is that identity, and that it's useful for higher arity functions to be fmappable.
22:29:39 <ezyang> Sometimes you have a function that expects something monadic, and pure is the most convenient to zot it into the right form
22:30:24 <flebron> Well wouldn't that be return?
22:30:43 <ezyang> erm, sorry, "applicative", in this case :-)
22:30:44 <flebron> (I'm looking for pure as in the Applicative pure, not the Monad's return)
22:30:48 <ezyang> or pointed functorially
22:30:52 <ezyang> to be pedantic
22:30:56 <|Steve|> How does pure differ from return?
22:31:16 <ezyang> @src pure
22:31:16 <lambdabot> Source not found. Just try something else.
22:31:18 <flebron> Typeclass restriction
22:33:41 <ski> flebron : e.g. `sequenceA'
22:34:20 <|Steve|> Is there an example of an Applicative Functor that isn't a Monad?
22:34:30 <dmwit> ZipList is the canonical example.
22:35:28 <rwbarton> it actually is a monad
22:36:27 <|Steve|> pure = undefined for ZipList?
22:36:57 <ski> no, `ZipList . repeat'
22:37:18 <ion> steve: What would you expect pure (+1) <*> ZipList [0..4] to do? What should pure (+1) return for that to work?
22:37:53 <|Steve|> I haven't the slightest clue what the point of ZipList is, honestly. I'm reading about it now.
22:38:05 <ski> > getZipList (pure (+1) <*> ZipList [0..4])
22:38:05 <lambdabot>   [1,2,3,4,5]
22:38:27 <ski> > getZipList (pure (+) <*> ZipList [0..4] <*> ZipList [100,200,300])
22:38:28 <lambdabot>   [100,201,302]
22:38:42 <ion> There should not be a return in the first place, Monad should be a subclass of Applicative instead.
22:39:35 <ski> @src transpose
22:39:36 <lambdabot> transpose []             = []
22:39:36 <lambdabot> transpose ([]   : xss)   = transpose xss
22:39:36 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
22:39:40 <ski> hmpf
22:39:59 <ski>   transpose = foldr (zipWith (:)) (repeat [])
22:40:15 <ski>   transpose = foldr (liftA2 (:)) (pure [])
22:41:03 <ski> (and this is basically `sequenceA')
22:42:17 <ion> > Data.Traversable.sequenceA [[0,1,2],[3,4,5]]
22:42:17 <lambdabot>   [[0,3],[0,4],[0,5],[1,3],[1,4],[1,5],[2,3],[2,4],[2,5]]
22:43:22 <ski> > (getZipList . Data.Traversable.sequenceA . map ZipList) [[0,1,2],[3,4,5]]
22:43:23 <lambdabot>   [[0,3],[1,4],[2,5]]
22:45:07 <|Steve|> > getZipList $ pure (+1) <*> ZipList [0 .. 4]
22:45:09 <lambdabot>   [1,2,3,4,5]
22:45:14 <|Steve|> That's what I'd expect it to do.
22:45:35 <|Steve|> I guess I'd expect pure f = ZipList $ cycle [f] or something.
22:46:14 <ski> yep
22:46:30 <ski>   cycle [f] = repeat f
22:46:35 <|Steve|> I guess cycle [f] is the same as repeat f which it looks like is actually the implementation.
22:47:31 <|Steve|> Oh, I just needed to read farther down the wikibook page for Applicative Functors. It shows exactly that.
22:50:08 <kini> Is there a way to retrieve the "fixity" of an infix operator in GHCi?
22:50:28 <geekosaur> :info (op)
22:50:46 <kini> thanks!
22:53:39 <ski> (brackets not necessary)
22:58:38 <tac-tics> Is an endofunctor just a functor from a category C to itself?
22:58:40 <kini> The Gentle Introduction refers to 1/0 as producing an error, and being a "non-terminating expression"
22:58:52 <kini> but GHCi seems to have no problem with it - it returns Infinity
22:59:00 <kini> is the Gentle Introduction just out of date on this point?
22:59:42 <tac-tics> > 1 / 0
22:59:43 <lambdabot>   Infinity
22:59:59 <|Steve|> tac-tics: Yes.
23:00:15 <tac-tics> kini it's possible that GHC does its own thing. Haskell '98 is pretty sorely underspecified.
23:00:21 <tac-tics> |Steve|, hm
23:00:23 <tac-tics> thanks
23:00:24 <|Steve|> At least mathematically. I have no idea if Haskell has an Endofunctor class.
23:00:28 <kini> tac-tics: oh, ok
23:00:51 <zzo38> I started making something called WizardCard for implementing Magic: the Gathering and other similar things, this is what I have in a parser so far:   http://sprunge.us/TJjZ   I used the Prelude.Generalize and so far the only thing is a parser. It is a use of >>= with Parsec, with the registerString function.
23:00:52 <dmwit> Functor is Haskell's Endofunctor class.
23:01:07 <zzo38> dmwit: Endofunctors on (->) category, specifically
23:01:09 <tac-tics> I was just curious, since I've heard "A monad is just a monoid in the category of endofunctors" countless times
23:01:16 <dmwit> kini: Where does it say that?
23:01:26 <tac-tics> But I never bothered to look up what the hell an endofunctor was
23:01:50 <|Steve|> I have a very hard time relating Haskell's names for things to their mathematical equivalent.
23:02:13 <zzo38> tac-tics: I do not understand that statement either, but I know what endofunctor is; a monad on some category is a endofunctor on that category together with two operations eta (return) and mu (join) satisfying some laws.
23:02:23 <|Steve|> E.g., I know what a functor is and what laws it behaves but I have a hard time associating that Functor and fmap.
23:02:23 <kini> :t it
23:02:24 <lambdabot> Not in scope: `it'
23:02:39 <kini> dmwit: http://www.haskell.org/tutorial/functions.html section 3.3
23:02:44 <|Steve|> s/behaves/obeys/
23:02:49 <zzo38> |Steve|: If you know that it is for endofunctor on (->) category, then can you understand it?
23:03:02 <|Steve|> What's the (->) category?
23:03:05 <tac-tics> |Steve|, yeah. Honestly, I'm surprised so many people in this channel have any idea how the two relate at all
23:03:20 <|Steve|> What are its objects and morphisms?
23:03:23 <dmwit> kini: That does not say 1/0 is a non-terminating expression. It says 1/0 is a run-time error.
23:03:29 <dmwit> And it's correct, too.
23:03:36 <zzo38> |Steve|: The (->) category is the main category of Haskell, where morphisms are the functions and objects are the types. (In Haskell, categories are identified by the type for its morphisms)
23:04:35 <kini> dmwit: oops, you're right - I misread
23:04:50 <kini> dmwit: but I still don't see a run-time error...
23:05:06 <kini> GHCi just prints "Infinity", and then ":t it" yields "it :: Double"
23:05:10 <zzo38> |Steve|: Will it makes sense to you now? You can understand?
23:05:24 <|Steve|> zzo38: I'm trying to make sense of your parenthetical.
23:05:41 <dmwit> kini: Ah, yes, well... pick a better type. =)
23:05:48 <dmwit> > 1/0 :: Rational
23:05:49 <lambdabot>   *Exception: Ratio.%: zero denominator
23:06:01 <|Steve|> zzo38: But yes, once you explained what the (->) category is, it does become clear.
23:06:24 <zzo38> Do you understand the parenthetical sentence now?
23:06:46 <ski> |Steve| : it would also be possible to make a class for functors from `*' to `* -> *', e.g.
23:06:50 <|Steve|> No. I'm not sure what you're trying to say.
23:07:26 <|Steve|> What do you mean by "type for its morphisms"?
23:07:41 <zzo38> |Steve|: What I mean is, (->) is the type for the morphisms in that category, therefore we call it (->) category.
23:08:44 <ski> |Steve| : we need (a) a kind `k' for the objects of the category, (b) a type with kind `k -> k -> *' for the morphism classes
23:08:45 <|Steve|> What is (->)?
23:08:56 <ski>   (->) :: * -> * -> *
23:08:56 <|Steve|> Apparently it has kind ?? -> ? -> *.
23:09:11 <ski> (the `??' and `?' is GHC extensions, you can ignore it)
23:09:12 <|Steve|> I've never seen :kind show question marks before.
23:09:40 <zzo38> |Steve|: (->) is the type for functions in Haskell. The question marks means that unboxed types are also possible; you can ignore them.
23:09:41 <ski> it is a generalization, to allow functions taking and returning unboxed stuff
23:09:49 <tac-tics> I think I've decided generic programming is too much like category theory. Conclusion: It's not useful for people who work for a living.
23:10:34 <|Steve|> Okay.
23:12:28 <zzo38> But I am interest in mathematics too; and I could figure out such things as free category of a quiver, and the Initialize comonad and Finalize monad which can be used with any category having initial/final objects, and a few other things too
23:13:17 <ski> if you want to express functors from the category with objects/types of kind `* -> *' (and more or less natural transformations as morphisms) to the category with objects/types of kind `*' (and with ordinary haskell functions as morphisms), then you need to implement a mapping function of type `forall f g. (forall x. f a -> g a) -> (t f -> t g)', where `t' is the functor in question
23:14:01 <ski> (er, s/forall x/forall a/)
23:14:15 <whittle> tac-tics: I’m used to hearing that sort of statement from programmers in other languages about most of the things that are really basic in Haskell.
23:14:22 <ski> ("more or less" because we're not assuming `f' and `g' to be functors here -- if they were, then functions of type `forall a. f a -> g a' would be natural transformations from `f' to `g')
23:15:05 <whittle> tac-tics: But to be completely honest, I’m totally lost about almost all of this.
23:15:37 <zzo38> I think it is possible for some categories to implement a fully faithful functor from that category to the free category of the subset of that category's quiver
23:15:49 <earthy> tac-tics: back in '99 I actually ran into a distinct need for generic programming while doing actual programming work
23:16:10 <zzo38> (If what I am saying seems meaningless to you, then try again.)
23:21:23 <solidus-river> i wish xmonad had a quick command to fulscreen the active window
23:21:26 <solidus-river> and then unfullscreen it
23:21:36 <solidus-river> although i know #haskell is not #xmonad
23:21:53 <dmwit> Have you considered doFullFloat and then retiling?
23:22:03 <dmwit> Or adding Tall to your layouts and switching to and from it?
23:22:29 <solidus-river> doFullFloat looks like it requires a mouse interaction though, which will be inneficient
23:22:46 <dmwit> eh?
23:22:49 * solidus-river spells words wrong regularly
23:23:03 * hackagebot repa 3.1.4.1 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-3.1.4.1 (BenLippmeier)
23:23:04 <solidus-river> reading through the guide, it looks like to doFullFloat you need to hold mod and drag the window ith the mouse
23:23:06 <augur> any good videos come out lately?
23:23:10 <dmwit> Oh, doFullFloat is a ManageHook, not an action.
23:23:40 <dmwit> Anyway, Tall is the right way, and the first way I suggested was just before I could think properly.
23:23:53 <dmwit> You can also make a key that jumps to the Tall layout.
23:23:56 <dmwit> See LayoutCombinators.
23:27:09 <zzo38> Some things such as Kleisli for the Kleisli category of some monad on (->) and Endo for endomorphisms on (->); but we can do similar things on arbitrary categories, using Starling to represent Kleisli category of some monad on some other category, and Warbler to represent endomorphisms of some other category.
23:28:04 * hackagebot gloss-raster 1.7.4.2 - Parallel rendering of raster images.  http://hackage.haskell.org/package/gloss-raster-1.7.4.2 (BenLippmeier)
23:28:06 * hackagebot gloss-raster 1.7.4.3 - Parallel rendering of raster images.  http://hackage.haskell.org/package/gloss-raster-1.7.4.3 (BenLippmeier)
23:33:04 * hackagebot repa 3.1.4.2 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-3.1.4.2 (BenLippmeier)
23:33:44 <tac-tics> earthy, what need was that?
23:33:50 <tac-tics> (for generic programming?)
23:38:06 * hackagebot gloss-examples 1.7.4.2 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.7.4.2 (BenLippmeier)
23:39:43 <whittle> :t liftIO
23:39:43 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
23:40:36 <ennui> here are two versions of a trivial two-line function. what's more preferable/idiomatic: the first or the second version? http://hpaste.org/68064
23:44:12 <whittle> ennui: I’m new to Haskell, but my understanding is that the second, point-lesser implementation is more Haskell-y.
23:44:32 <whittle> I also personally think it’s easier to read and understand.
23:45:06 <ennui> great, thanks! i'd love to hear on more opinion.
23:45:51 <ChristianS> i second the second
23:46:40 <dmwit> My opinion is "go with your heart".
23:47:09 <nexx> I think the second is a little bit better
23:50:11 <ennui> alright, thanks! (i'm still acquiring my taste for haskell)
23:58:01 <Phlogistique> hi
23:58:25 <Phlogistique> I need a container with at least append and random access in O(1)
23:58:46 <kalven> glhf
23:59:02 <Phlogistique> and if possible I'd like to trigger garbage collection of the head when I don't need it anymore
23:59:06 <dmwit> Phlogistique: See the StackOverflow question.
23:59:11 <Phlogistique> (so basically, a Deque)
23:59:17 <dmwit> Just asked today.
23:59:25 <Phlogistique> (but not the "fully functional" one
23:59:31 <Phlogistique> dmwit: cool, thanks
23:59:47 <dmwit> Modify the uncons and unsnoc operations to overwrite the cell they get rid of with undefined or some such thing for the garbage collection property.
