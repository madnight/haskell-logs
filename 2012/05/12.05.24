00:08:55 <absence> mm_freak_: the best i've managed so far is keyPressed key = require . hold ((True <$ keyDown key) <|> (False <$ keyUp key)) but even if it's more applicative it's still not using identity
00:16:07 * hackagebot time-lens 0.2 - Lens-based interface to Data.Time data structures  http://hackage.haskell.org/package/time-lens-0.2 (RomanCheplyaka)
00:17:06 <mm_freak_> absence: i think i should add explicit boolean operators to netwire =)
00:29:20 <absence> mm_freak_: would that help people like me to understand how to make the above code better, or would it facilitate better code?
00:43:50 <mm_freak_> absence: better code
00:43:58 <mm_freak_> i'm working on a new version right now
00:46:05 <Rudi> Hi all!
00:46:25 <Rudi> Er. Just curious - I've been wanting to ask this question for a long time.
00:46:35 <Rudi> What made you guys take up Haskell?
00:47:06 <shachaf> Cosmic turbulence.
00:47:37 <dmwit> It seemed cleaner (and more awesome) than any language I had seen before.
00:47:53 <dmwit> But you're asking the wrong question.
00:48:14 <dmwit> The right question is "if you could sell Haskell to old you knowing what new you knows, what features would you push"?
00:48:22 <dmwit> I picked it up for bad reasons. But now I know the good reasons.
00:49:01 <dmwit> 1. Safe by default, and unsafe only with a marker that it's unsafe is a huge maintenance boon.
00:49:15 <shachaf> dmwit: No, we want the dirt!
00:49:20 <shachaf> We want to make fun of oldmwit.
00:49:25 <dmwit> 2. A good type system that doesn't get in your way is a huge help, especially for refactoring.
00:49:43 <dmwit> shachaf: The dirt is I picked it up because (a -> b -> c) meant a -> (b -> c).
00:49:46 <shachaf> kmc had some nice slides to answer the question dmwit is answering.
00:49:53 <shachaf> @google why learn haskell keegan
00:49:57 <lambdabot> http://ugcs.net/~keegan/talks/why-learn-haskell/talk.pdf
00:49:57 <lambdabot> Title: Why learn Haskell?
00:49:57 <koala_man> I'm writing python now. oh god, how I miss strong, static typing
00:50:03 <dmwit> ...oh, excellent!
00:50:13 <dmwit> I'll stop listing, then. Go look at kmc's talk. =)
00:50:23 <dmwit> Also...
00:50:28 <dmwit> ?google why functional programming matters
00:50:32 <lambdabot> http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf
00:50:32 <lambdabot> Title: Why Functional Programming Matters
00:50:42 <dmwit> Though that's probably starting to show its age.
00:50:58 <vertue> I find myself using a lot of map (map f) a type stuff
00:50:59 <shachaf> "Why Functional Programming Mattered in 1990"
00:51:05 <ziman> Rudi, it appeared unbelievably... straightforward to me. Like, data Color = Red | Green | Blue; name Red = "red"; name Green = "green"; recursive definitions atc.
00:51:05 <vertue> is there a shorthand
00:51:15 <ziman> this got hooked me up and I wanted to know how this can work :)
00:51:24 <Rudi> Wow.
00:51:26 <shachaf> @let shorthand f = map (map f)
00:51:28 <lambdabot>  Defined.
00:51:40 <shachaf> @ty shorthand
00:51:42 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
00:51:49 <absence> mm_freak_: does that mean that the code i wrote is good enough for now? looking forward to see the next version btw :)
00:51:53 <vertue> thanks
00:52:02 <Rudi> Guess I came to the right place..
00:52:02 <vertue> I should have known
00:52:08 <shachaf> vertue: lambdabot calls it (.:)
00:52:11 <shachaf> In general, not really.
00:52:20 <shachaf> Rudi: Keep in mind that you're going to get a lot of misinformation and wrong answers in this channel.
00:52:39 <shachaf> Lots of people like Haskell for all the wrong reasons.
00:52:51 <dmwit> I lied. I am going to continue.
00:52:59 <Rudi> :|
00:53:13 <dmwit> Lots of programs have invariants in them that it makes sense to document and/or enforce in various ways.
00:53:34 <dmwit> Often, these invariants can be checked statically and easily... but only if you've got a good type system.
00:53:34 <Rudi> Maybe the best reason behind going in for Haskell = "learning for its own sake"..?
00:53:40 <Rudi> Just saying.
00:53:45 <shachaf> dmwit: That way lies Agda.
00:54:08 <dmwit> Rudi: That's why I came. But it's not why I stayed. =)
00:54:17 <dmwit> shachaf: yes =)
00:54:23 <shachaf> dmwit: In kmc's slides he made the point not to focus on the type system because the benefits of that only really come up when you know the language fairly well.
00:54:37 <dmwit> I don't even think that's true.
00:54:41 <shachaf> There are lots of nice things about the language that would be nice even if it was dynamically typed.
00:54:45 <dmwit> Here's an example everybody can relate to, straight from xmonad:
00:54:46 <Rudi> Hmm.
00:55:03 <dobblego> @remember shachaf There are lots of nice things about the language that would be nice even if it was dynamically typed.
00:55:04 <lambdabot> It is stored.
00:55:08 <dmwit> X has a concept of XID's. Everything you do with X uses an XID: windows have an XID, events have an XID, buttons have an XID.
00:55:27 <dmwit> In C, there's no way to prevent yourself from accidentally sending a window XID to a function expecting a button XID.
00:55:32 <shachaf> dmwit: Sure there is.
00:55:35 <dmwit> In Haskell, there is: you make a newtype.
00:55:48 <shachaf> struct Window { XID xid; }; struct Button { XID xid; };
00:55:56 <dmwit> shachaf: Okay, strike that comment. I didn't want to say "C bad, Haskell good" anyway.
00:55:58 <shachaf> struct Window w; struct Button b;
00:55:59 <dmwit> Just "Haskell good".
00:56:11 <shachaf> dmwit: Sure, but you can do this particular thing in lots of type systems.
00:56:16 <dmwit> Yep!
00:56:17 <Rudi> Oh. Right.
00:56:19 <Rudi> Well.
00:56:21 <dmwit> It's a common thing to want.
00:56:22 <shachaf> You can even do it in a dynamically-typed language and it'll get turned into a runtime error.
00:56:26 <Rudi> Eye-opening, I'd say.
00:56:30 <dmwit> And it's an example of the kind of static checking you want.
00:56:37 <dmwit> Haskell has that kind of static checking... and much more. =)
00:57:04 <dmwit> shachaf: avoiding runtime errors (aka bugs) are the whole point of doing this =)
00:57:24 <shachaf> dmwit: Not really. Compile-time error > Runtime error > e.g. silent corruption.
00:57:42 <mm_freak_> absence: for now yes =)
00:57:49 <shachaf> It *is* true that Haskell's type system catches a lot of things that you might not think of as type errors in other languages.
00:57:56 <shachaf> Like NULL pointer dereferences.
00:59:27 <shachaf> dmwit: A type system that catches things at runtime is still better than nothing.
00:59:28 <younder> thats actually a good thing..
00:59:39 <dmwit> That's interesting, I haven't even gotten to laziness or functional programming yet.
00:59:50 <younder> I like Haskell's type system
00:59:55 <dmwit> shachaf: I'll keep my type system that catches things at compile time, thank you very much.
01:00:10 <younder> It produces robust code
01:00:16 <shachaf> I guess you won't be upgrading to GHC 7.6, then!
01:00:44 <dmwit> I wrote up why I think laziness matters here: http://stackoverflow.com/questions/7868507/non-trivial-lazy-evaluation/7868790#7868790
01:01:26 <dmwit> Functional programming is a bit harder to motivate in the cramped communication available to us over the Internet.
01:01:43 <shachaf> Rudi: Really, you should read the FAQ.
01:01:51 <shachaf> This question has been asked in here probably hundreds of times.
01:01:53 <shachaf> @where faq
01:01:54 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
01:01:59 <younder> If it wasn't lazy it would be very inefficient creating tonns of temporary data strucures. I have a background from Lisp I should know
01:02:47 <dmwit> That's odd. Usually people blame laziness for lousy performance.
01:02:56 <dmwit> Or rather, they blame laziness for making it difficult to understand performance.
01:02:58 <Rudi> No offense
01:03:22 <Rudi> FAQs..nah. I wanna know why *you* guys like it.
01:03:47 <Rudi> You're the ones, hacking on it out there..
01:04:02 <dmwit> Who exactly do you think wrote the FAQ?
01:04:14 <dmwit> non-Haskell people?
01:04:32 <shachaf> Well, it *is* true that the person who wrote the FAQ is a non-#haskell person.
01:05:06 <shachaf> Rudi: It's very inefficient to have people type out the same answers to the same questions in IRC over and over and over. :-)
01:05:09 <dmwit> Uh, Keegan has done the majority of the edits and goes by kmc here in #haskell.
01:05:25 <shachaf> preflex: seen kmc
01:05:26 <preflex>  kmc was last seen on #git 34 days, 21 hours, 2 minutes and 58 seconds ago, saying: i don't know why that wouldn't update the remote branch, after a successful push -f
01:05:42 <dmwit> Only two edits are not by him; one of them is Ehird who goes by ehird` or something like that here, and the other is a 26-byte edit.
01:05:44 <shachaf> I think he left #haskell permanentlyish.
01:05:50 <shachaf> ehird is elliott
01:05:56 <dmwit> Once a #haskellian, always a #haskellian.
01:05:58 <dmwit> =)
01:06:29 <dmwit> (#haskellite? #haskeller?)
01:06:45 <dmwit> #haskolyte
01:06:58 <dmwit> Bringing FP to the masses.
01:07:35 <Rudi_> Point
01:07:50 <Rudi_> Bringing FP to the masses
01:08:01 <Rudi_> Pity the masses aren't exactly too interested.
01:08:33 <mm_freak_> while interest is low, dinterest/dt is quite high right now
01:08:40 <Rudi_> Haha
01:08:57 <Rudi_> Funny
01:08:59 <Rudi_> I've noticed
01:09:06 <Rudi_> Everytime I talk about FP
01:09:15 <Rudi_> I start feeling hungry
01:09:18 <mm_freak_> although humorously stated it wasn't actually a joke
01:11:09 <arbn> There's much more interest in _talking_ about FP than in actual FP-ing.
01:11:24 <younder> Just went though Simon P. Jones talk on paralell computation
01:12:35 <qtplatypus> arbn: That depends on who you are.
01:13:02 <younder> Went though a similar one by Guy Steele on fortress a while back
01:13:17 <arbn> qtplatypus: Who I am?
01:13:32 <younder> platypus :)
01:14:48 <qtplatypus> arbn: "There's much more interest in _talking_ about FP than in actual FP-ing." I was saying that isn't universal.
01:15:33 <younder> I recommend 'the art of paralell programming' by Maurice Herlihy and Nir Sahavith
01:16:10 <arbn> qtplatypus: Oh, yeah. Not everyone is that way. I just see FP thrown about in conversation much more than I see software being written that way.
01:16:57 <younder> FP is a callword a panacea. used unintelligently it will be your peril
01:17:38 <qtplatypus> younder: I can't parse your first sentence.
01:18:14 <younder> FP is a call-word, a panacea. Used unintelligently it will be your peril..
01:18:18 <younder> (better)
01:18:28 <qtplatypus> Thankyou.
01:19:41 <absence> is there a general preference for "f1 . f2 . f3 $ a" versus "f1 $ f2 $ f3 a"?
01:20:11 <absence> or is it one of those taste things :)
01:20:17 <younder> well that $is more noisy. I prefer the .
01:20:41 <absence> then we agree
01:20:49 <arbn> Composition just _feels_ nicer than application. :P
01:21:09 <qtplatypus> (f3 >>> f2 >>> f1) a
01:21:25 <roconnor> absence: f1 . f2 . f3 $ a is prefered because of the associativity of . there are more (moral) subexpressions in it than in "f1 $ f2 $ f3 a"
01:21:34 <qtplatypus> but I know I'm odd like that.
01:22:03 <roconnor> qtplatypus: q >>= (f3 >>> f2 >>> f1) ?
01:22:05 <roconnor> er
01:22:08 <roconnor> qtplatypus: a >>= (f3 >>> f2 >>> f1) ?
01:22:15 <dmwit> Someday $ will be infixl and this won't even be a question any more.
01:22:29 * dmwit puts on his dreamy hat
01:22:44 <absence> roconnor: good point, didn't think of that
01:22:46 <qtplatypus> roconnor: sure
01:35:53 <hpaste> codertux pasted “dfs” at http://hpaste.org/68941
01:36:01 <codertux> hi, can someone give some homework help? I have to write a haskell program that performs a depth first traversal of a graph represented as an adjacency matrix and returns a list of back edges.
01:37:53 <younder> rdundatnt bracket
01:38:34 <dmwit> codertux: I guess the complaint is some kind of infinite type, or maybe that it can't show Int ~ [Int] or something like that?
01:39:04 <dmwit> codertux: Notice that you want the list comprehension to return a list of Int values, which means the thing before the | in [ ... | ... ] should be an Int.
01:39:12 <dmwit> codertux: But you've written a thing that's an [Int] there.
01:39:19 <qtplatypus> codertux: What have you tried?
01:39:38 <dmwit> codertux: You can fix this a few ways, but maybe you should take a shot at fixing it yourself with this explanation first before we give more hints. =)
01:39:47 <qtplatypus> Sorry I missed your hpast comment.
01:42:13 <codertux> thank you :) I'll try to dwell on it a while
01:47:17 <arcatan> @src reverse
01:47:18 <lambdabot> reverse = foldl (flip (:)) []
01:48:19 <arcatan> @src foldl'
01:48:19 <lambdabot> foldl' f a []     = a
01:48:19 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
01:55:30 <hpaste> codertux pasted “dfs” at http://hpaste.org/68942
01:55:56 <codertux> dmwit: ^^ took another shot at it, still no go
02:01:51 <dmwit> codertux: What is the return type of dfs?
02:02:13 <dmwit> I think your previous code was closer to being right than this version is. =)
02:03:34 <codertux> dmwit: awesome, lol. I'm trying to help a friend actually and neither of us know much haskell :)
02:04:11 <codertux> dmwit: so, the return type of dfs is [Int], to answer your first question
02:04:47 <dmwit> Yes, I know. =)
02:05:05 <dmwit> But look where it's used: in an if-then-else where the other thing isn't returning an [Int].
02:05:08 <dmwit> That's not okay.
02:05:20 <codertux> dmwit: hmmm, you have a point
02:07:41 * codertux is totally lost
02:08:20 <dmwit> Okay, here's a hint.
02:08:39 <dmwit> > [x | xs <- [[1..5], [7..10]], x <- xs]
02:08:40 <lambdabot>   [1,2,3,4,5,7,8,9,10]
02:08:43 <dmwit> compare
02:08:51 <dmwit> > [xs | xs <- [[1..5], [7..10]]]
02:08:52 <lambdabot>   [[1,2,3,4,5],[7,8,9,10]]
02:09:03 <dmwit> There's also
02:09:08 <dmwit> > concat [[1..5], [7..10]]
02:09:09 <lambdabot>   [1,2,3,4,5,7,8,9,10]
02:12:01 <adamt> If i want both a x86 and x86_64 ghc installed, what do i need to be vary about?
02:12:27 <bartavelle> is there some sample code somewhere for properly spawning a unix process, feeding its stdin, and getting either stdout or stderr upon completion ? (and properly timeouting)
02:13:03 <adamt> Would i also need two versions of cabal and cabal-install, or is cabal not archspecific?
02:16:15 * hackagebot nemesis 2012.5.24 - a Rake like task management tool  http://hackage.haskell.org/package/nemesis-2012.5.24 (JinjingWang)
02:21:15 * hackagebot nemesis 2012.5.24.1 - a Rake like task management tool  http://hackage.haskell.org/package/nemesis-2012.5.24.1 (JinjingWang)
02:23:17 <yitz> @type \f g -> fmap f . traverse g
02:23:18 <lambdabot> Not in scope: `traverse'
02:23:31 <yitz> @type \f g -> fmap f . Data.Traversable.traverse g
02:23:32 <lambdabot> forall b (f :: * -> *) a b1 (t :: * -> *). (Applicative f, Data.Traversable.Traversable t) => (t b1 -> b) -> (a -> f b1) -> t a -> f b
02:31:16 * hackagebot disassembler 0.2.0.0 - Disassembler for X86 & AMD64 machine code  http://hackage.haskell.org/package/disassembler-0.2.0.0 (MartinGrabmueller)
02:36:41 <codertux> dmwit: still lost it :( back to square one, can I have some more hints?
02:37:21 <codertux> i've tried to do it without list comprehension, but no luck
02:41:08 <Peaker> Just yesterday I installed haskell-mode and ghc-mod and they seemed to work. Today, not sure what happened, but they no longer do. This seems so brittle :(
02:46:17 * hackagebot harpy 0.5.0.0 - Runtime code generation for x86 machine code  http://hackage.haskell.org/package/harpy-0.5.0.0 (MartinGrabmueller)
02:48:55 <bartavelle> it seems nobody wrote a library for safely interacting with execve'd processes
02:51:29 <adamt> weird, doing cabal-install bootstrap, it says compiling the "text" package failed. then i retry and all is good. *shrughs*
03:08:02 <younder> all my love is for vivaldi
03:09:05 <younder> http://www.youtube.com/watch?v=pe-MIDDfckw
03:14:22 <fmap> Why Safe Haskell disables -XGeneralizedNewtypeDeriving extension? Documentation says "It can be used to violate constructor access control, by allowing untrusted code to manipulate protected data types in ways the data type author did not intend, breaking invariants they have established." but I can't think of any particular example.
03:17:00 <dmwit> fmap: http://www.haskell.org/pipermail/haskell/2010-March/021948.html
03:17:23 <younder> Because it is unsafe? duh
03:18:02 <dmwit> fmap: Exercise for the reader: cause a segfault with GNT.
03:18:34 <dmwit> codertux: My hint is to use two bindings instead of just one in your comprehension.
03:18:53 <dmwit> Currently you have [something complicated | e <- incidentEdges something something].
03:19:22 <dmwit> I suggest playing with [something new here | e <- incidentEdges something something, x <- something complicated]
03:19:30 <younder> I can cause a segfula with c++  any day :)
03:19:33 <rtharper_> @src unfoldr
03:19:33 <lambdabot> unfoldr f b  = case f b of
03:19:33 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
03:19:33 <lambdabot>    Nothing        -> []
03:20:50 <younder> In Haskell it is more spectacular..
03:26:22 * hackagebot effects 0.2.2 - Computational Effects  http://hackage.haskell.org/package/effects-0.2.2 (SjoerdVisscher)
03:26:40 <fmap> dmwit: Oh. I'll try to understand, thanks.
03:29:02 <womb> Hi
03:29:09 <dmwit> howdy
03:34:38 <younder> http://www.youtube.com/watch?v=nbpAFzyrx5o&feature=related
03:34:47 <younder> the best ever
03:35:03 <younder> I so love it
03:35:37 <dmwit> Maybe you should take further Vivaldi love to #haskell-blah.
03:35:51 <younder> Perhaps I should get back to programming
03:37:35 <younder> Anyone here use NASM?
03:38:52 <younder> It is really cool.. I am using it for a assembler in Haskell.
03:39:57 <younder> It uses Perl to translate .dat tables
03:41:11 <younder> If you don't like C,  Haskell works fine too :)
03:42:17 <adamt> how much memory is actually required to build cabal-install?
03:42:31 <adamt> clearly 768MB is too little.
03:42:37 <younder> about 64M
03:42:56 <adamt> Let me rephrase. How much memory is actually required to link cabal-install?
03:42:59 <younder> It is pretty HUGE
03:43:42 <dmwit> younder has no idea.
03:43:44 <dmwit> Neither do I.
03:43:58 <dmwit> 768M isn't much, though -- how old is your machine?
03:44:33 <adamt> It's a VPS
03:44:43 <fmap> when I tried to build it on my gentoo vps I ended with 512MB RAM and 1GB swap.
03:44:58 * adamt mumbles something about 768MB actually being rather a lot, all things considered
03:45:29 <hpaste> “@onlyshk” pasted “dropWhile” at http://hpaste.org/68950
03:46:07 <shk> Hello, haskellers
03:46:43 <shk> Why dropWhile not cut string by \"? in http://hpaste.org/68950
03:46:59 <adamt> fmap: okay, i'll just make a temporary swap file to increase my totals to match yours.
03:47:40 <younder> I live on a machine with 4Gb and it would not hold
03:48:47 <younder> It fails miserably in that build. Perhaps 8 Mb
03:49:17 <fmap> shk: should it?
03:49:26 <fmap> > dropWhile (< 5) [1..10]
03:49:27 <lambdabot>   [5,6,7,8,9,10]
03:49:30 <adamt> younder: Are you smoking or what? You're making no sense what so ever.
03:50:32 <fmap> shk: the first symbol of your string is not a punctuation so dropWhile ≡ id
03:50:38 <younder> I got a new machine a 64Gb i7 which should crunch whatever.
03:52:20 <Nealefelaen> shk: you probably want: takeWhile
03:52:33 <Nealefelaen> takeWhile (\c -> not $ isPunctuation c) str
03:52:54 <adamt> Ok, on this 32-bit machine it seems like 8-900MB of memory was enough, which was just a tad more than i had.
03:53:31 <shk> <Nealefelaen>,<fmap>, thank you for your helps
03:55:14 <younder> adamt, No But I have smoking machine
03:55:38 <younder> +++++++++++++++++
03:59:35 <younder> I totally upgraded!
04:11:30 * hackagebot graph-rewriting 0.7.0 - Monadic graph rewriting of hypergraphs with ports and multiedges  http://hackage.haskell.org/package/graph-rewriting-0.7.0 (JanRochel)
04:11:32 * hackagebot graph-rewriting-layout 0.5.1 - Force-directed node placement intended for incremental graph drawing  http://hackage.haskell.org/package/graph-rewriting-layout-0.5.1 (JanRochel)
04:15:10 <gdoteof> is it true that ghc is only using one core to compile?
04:15:32 <gdoteof> and if so, is that something that is likely to change in the next 6-12 months?
04:16:34 * hackagebot graph-rewriting-strategies 0.2 - Evaluation strategies for port-graph rewriting systems  http://hackage.haskell.org/package/graph-rewriting-strategies-0.2 (JanRochel)
04:16:36 * hackagebot graph-rewriting-lambdascope 0.5 - Implementation of Lambdascope as an interactive graph-rewriting system  http://hackage.haskell.org/package/graph-rewriting-lambdascope-0.5 (JanRochel)
04:16:38 * hackagebot graph-rewriting-gl 0.6.9 - OpenGL interface for interactive port graph rewriting  http://hackage.haskell.org/package/graph-rewriting-gl-0.6.9 (JanRochel)
04:24:19 <yitz> gdoteof: right currently one core
04:24:32 <yitz> gdoteof: it will change. hard to say exactly when.
04:24:47 <yitz> gdoteof: there are two different things people are working on.
04:25:21 <yitz> gdoteof: one is a way to have cabal work in parallel, compiling different packages in parallel on different cores.
04:26:33 <yitz> gdoteof: another is that since the ghc team is working hard on supporting parallel in general, i imaging eventually they'll get around to putting in some parallel constructs in ghc itself.
04:26:55 <yitz> gdoteof: though probably they'll hold off on that for a while until things start to mature and stabilize.
04:28:37 <gdoteof> yitz: thanks.  i suspected it was only a matter of time.
04:38:01 <aristid> yitz: wouldn't something like just parallelising ghc --make be a good first step?
04:38:34 <hpc> yitz: i think a better first step would be pipelining cabal
04:38:42 <hpc> 1. download first package
04:38:59 <hpc> 2. start compiling first package, and simultaneously download the second package
04:39:02 <hpc> ...
04:39:21 <aristid> a problem with a truly parallel cabal would be confusing error messages
04:39:31 <aristid> because they would be harder to localise to a single package
04:39:37 <hpc> true
04:39:58 <hpc> you can always buffer the output, or label it with the package name
04:40:19 <aristid> might help a bit
04:40:22 <hpc> or print everything in chronological order, then collect errors at the end
04:40:29 <hpc> so some stuff gets printed twice
04:40:52 <hpc> the lack of pipelining is a huge annoyance in apt too
04:41:06 <hpc> when i update, the time spent downloading packages is almost exactly the same as the time spent installing them
04:41:16 <aristid> pipelining itself can be done without parallelising the builds themselves
04:41:35 <hpc> indeed
04:41:43 <hpc> all you need is a "download thread" and a "build thread"
04:42:02 <Ke> nowadays most people have network connections that are so fast it doesn't matter
04:42:08 <hpc> and a tiny bit of "keep one ahead of the other" mvar-ing
04:42:22 <Ke> the thing used to annoy me in 2005
04:42:52 <hpc> Ke: some of us do still use linuxes on really old systems
04:42:52 <aristid> digression: i'm starting to really hate ubuntu. it's very hard to know at a glance which window is active, and the settings UI has no way to make the colors something other than black for active, black for inactive (technically more dark gray than black)
04:43:04 <hpc> and internet speeds are not as fast as you think they are
04:43:06 <aristid> so i always end up typing ls in irc
04:43:11 <hpc> ESPECIALLY in the US/Canada
04:43:15 <hpc> or third-world countries
04:43:34 <aristid> or people in rural regions almost everywhere
04:44:01 <hpc> not to mention that hard drive performance has historically grown slower than any other component but network speed
04:44:16 <adamt> It's just pure lazyness that apt and most other package managers can't download in the background, really, there's no excuses for it.
04:44:22 <hpc> so even with your superfast tubes, installing 100 debian-testing updates every week still hurts
04:44:47 <hpc> at least in apt's case, part of it is that they wrote it in sh
04:44:48 <aristid> hpc: and SSDs are still painfully expensive (but worth it)
04:45:01 <Ke> portage can download packages in bg and ~safely run multiple instances in parallel
04:45:32 <Ke> ie. it's not dependency safe, but there is a monitor for fs access
04:45:45 * hpc wishes more programmers would stop using "concurrency is hard" languages like java...
04:46:25 <Ke> for these kind of cases there is nothing non-trivial even for C/pthreads
04:46:47 <hpc> indeed
04:47:11 * hpc can already think of a few ways to implement this with exactly one mutex
04:47:35 <hpc> hell, you could even do it with a lockfile in /tmp
04:48:39 <hpc> dl thread writes "here's how far i am downloaded" to file, install thread waits for it to move forward before installing
04:49:13 <gdoteof> hpc: as someone who was writing haskell while traveling through latin america up until about 3 weeks ago, spot on on the internet speeds
04:49:48 <adamt> hpc: just stick a queue between the threads
04:49:54 <gdoteof> not to mention compiling on a 1.6ghz cpu
04:50:06 <gdoteof> (did have an ssd though!)
04:50:08 <hpc> adamt: yes, that's the good way to do it ;)
04:50:29 <adamt> gdoteof: i ran gentoo on a pentium-m 1.2GHz with 256MB ram, don't you complain :)
04:50:39 <adamt> Only thing it failed compiled for me was openoffice.
04:50:45 <gdoteof> adamt: when?
04:50:46 <adamt> *compiling
04:50:57 <hpc> i am currently running an IRC bot, website, mysql server, and irssi off a medium-end laptop from 2006
04:50:59 <adamt> gdoteof: 2006-2008 i think.
04:51:34 <hpc> it's also where i do all my haskell coding :P
04:51:47 <gdoteof> hpc: are you compiling with it?
04:51:51 <hpc> yes
04:51:57 <gdoteof> adamt: well w/e.  this was 2012 =P
04:52:01 <hpc> and then for GUI stuff i X-forward
04:52:10 <hpc> it keeps me very sensitive to performance, needless to say
04:52:20 <gdoteof> makes sense.
04:52:30 <adamt> gdoteof: Yes, just dismiss my pains of having the laptop compile updates for many many hours every other night lol.
04:52:41 <gdoteof> i run mysql+apache as well as mongo+yesod on this netbook all the time
04:53:34 <gdoteof> i am wanting to resurect a medium old 2.6 dual core.  it has a slow hard drive in it; but i guess it will be better for compiling
04:54:00 <adamt> You can always stick a lot of memory in it, and compile from tmpfs
04:54:15 <hpc> gdoteof: good for compiling, but i bet it sucks for linking
04:54:18 <hpc> :P
04:54:34 * gdoteof should probably learn about tmpfs 
04:54:50 <gdoteof> it has 4 gigs of slow ram
04:55:18 <hpc> gdoteof: run df; you probably already have a tmpfs or three
04:55:50 <gdoteof> hpc: yep.  one.  1.1gigs; using 800kb
04:55:54 <adamt> having installed arch linux on ext3 (which is a huge mistake) i was running the package management from tmpfs. =/
04:57:13 <hpc> it looks like ghc has been using my /tmp
05:05:10 <arch_is_awesome> Hello, I was wondering if Haskell was interpreted or compiled.
05:05:53 <bitonic> arch_is_awesome: Haskell is a language, not a compiler
05:05:57 <mauke> arch_is_awesome: the answer is no
05:06:03 <bitonic> the most widely used implementation, GHC, does both
05:06:18 <arch_is_awesome> So, you can use: ghc file.hs ?
05:06:33 <mauke> yes
05:06:42 <hpc> that compiles it
05:06:51 <arch_is_awesome> How about interpreting it?
05:06:55 <hpc> runghc
05:07:04 <arch_is_awesome> Thanks
05:07:17 <hpc> or ghci
05:07:20 <arch_is_awesome> Also, what's the difference between base 3 and base4?
05:07:26 <mauke> the version number
05:07:33 <arch_is_awesome> That's it?
05:07:48 <hpc> the difference is you don't want base 3
05:07:53 <arch_is_awesome> So, it's not like Python 3 which isn't backwards compatible?
05:08:06 <mauke> python 3 is a different language
05:08:12 <mauke> base is a library
05:08:13 <arch_is_awesome> I know.
05:08:14 <hpc> different versions of ghc come with different versions of base
05:08:21 <arch_is_awesome> Ah.
05:08:33 <hpc> if you have the wrong version of base, you also have the wrong version of ghc, so don't try installing a different version of base :P
05:08:52 <arch_is_awesome> Okay, I have ghc 7.4.1
05:09:09 <arch_is_awesome> Thanks, bye.
05:09:11 <hpc> you have base-4.5.0.0
05:09:22 <arch_is_awesome> Thank you
05:09:46 <arch_is_awesome> One more thing: has the language changed much in the past two years?
05:09:55 <hpc> yes
05:10:10 <hpc> the most recent version of the spec was released in 2010
05:10:14 <arch_is_awesome> So, getting a book on haskell published in 2010 isn't a good idea?
05:10:29 <adamt> go read learnyouahaskell... and real world haskell, problem solved
05:10:36 <hpc> ah, depends on the book
05:10:39 <arch_is_awesome> http://www.amazon.com/Learn-You-Haskell-Great-Good/dp/1593272839/ref=sr_1_3?s=books&ie=UTF8&qid=1337827504&sr=1-3 ?
05:10:44 <arch_is_awesome> (That's 2011)
05:10:53 <adamt> arch_is_awesome: you can browse it online if you're tight on money.
05:10:58 <hpc> LYAH is reasonably up-to-date
05:11:18 <hpc> most of the changes to the language were just making certain ghc extensions into official things
05:11:37 <arch_is_awesome> http://learnyouahaskell.com/chapters this?
05:11:43 <adamt> yes
05:11:49 <hpc> @where rwh
05:11:49 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
05:11:51 <hpc> also that
05:12:33 <arch_is_awesome> One more thing, what, exactly does purely functional mean?
05:12:54 <mauke> arch_is_awesome: no side effects
05:12:59 <adamt> Depends on the context. :>
05:13:10 <sipa> it means it's pure fun
05:13:10 <hpc> https://en.wikipedia.org/wiki/Functional_programming -- this explains "functional"
05:13:10 <mauke> that is calling a function with the same argument always returns the same value
05:13:22 <adamt> sipa++
05:13:31 <hpc> https://en.wikipedia.org/wiki/Purely_functional -- also this
05:13:33 <arch_is_awesome> mauke: Thanks..
05:13:46 <adamt> It also means that your C# buddies will laugh at you. :)
05:13:58 <merijn> Wasn't there a default type class? Can't find it on Hoogle
05:14:08 <mauke> Data.Default
05:14:08 <hpc> arch_is_awesome: basically, it means if you write a square root function, it can't return one answer for sqrt(2) once, then a different answer the second time
05:14:17 <merijn> mauke: Thank you
05:14:28 <hpc> arch_is_awesome: and it can't do IO things, like print to the screen or open files
05:14:34 <arch_is_awesome> Okay, so it's kind of like lisp?
05:14:42 <mauke> no, lisp isn't anything like that
05:14:50 <hpc> i don't think any lisps are pure
05:15:00 <arch_is_awesome> Common Lisp...
05:15:08 <mauke> Common Lisp is basically Perl
05:15:13 <mauke> minus syntax, plus macros
05:15:13 <adamt> I haskell was pure it would be rather uninteresting for many things as well.
05:15:17 <adamt> *If haskell
05:15:20 <aristid> mauke: oO
05:15:22 <merijn> arch_is_awesome: Some Scheme afficionados consider Scheme a functional language, but most Lispers certainly don't consider Lisp in general to be purely functional
05:15:38 <arch_is_awesome> Is just functional, not pure... I think: https://en.wikipedia.org/wiki/Lisp_%28programming_language%29
05:15:45 <arch_is_awesome> Thanks, anyways, GTG>
05:15:53 <mauke> arch_is_awesome: everyone calls it "functional" but I don't believe it
05:16:07 <merijn> arch_is_awesome: In that sense Python and Go are functional too
05:16:09 <aristid> mauke: the type system of perl is quite unique and different from lisp. in a very limited way. perl has "static" types
05:16:11 <arch_is_awesome> Hm. So haskell can't print?
05:16:22 <adamt> arch_is_awesome: Yes it can
05:16:23 <merijn> arch_is_awesome: Sure it can
05:16:27 <mauke> arch_is_awesome: depends :-)
05:16:30 <aristid> lambdabot can't
05:16:42 <arch_is_awesome> [08:14] <hpc> arch_is_awesome: and it can't do IO things, like print to the screen or open files
05:16:43 <Botje> Haskell doesn't print, the interpreter running it can.
05:16:43 <aristid> but that's because it's disabled for security reasons:)
05:16:58 <adamt> arch_is_awesome: not everything is purely functional in haskell. ;)
05:17:05 <arch_is_awesome> Ah.
05:17:05 <aristid> adamt: yes it is
05:17:16 <hpc> arch_is_awesome: yeah, i should have probably said "evaluation can't cause IO things to happen"
05:17:21 <arch_is_awesome> Thanks you.
05:17:23 <mauke> arch_is_awesome: a program written in Haskell can do anything a C program can do
05:17:30 <mauke> but it doesn't happen by calling functions
05:17:32 <hpc> arch_is_awesome: you can still do IO in haskell, but there's a definite distinction between evaluating a value, and executing IO
05:17:46 <hpc> for instance:
05:17:47 <hpc> :t sqrt
05:17:48 <lambdabot> forall a. (Floating a) => a -> a
05:17:57 <arch_is_awesome> Arrows?
05:17:57 <hpc> pure calculation from number to number
05:18:02 <hpc> :t getLine
05:18:02 <lambdabot> IO String
05:18:15 <mauke> :t length
05:18:16 <lambdabot> forall a. [a] -> Int
05:18:21 <mauke> slightly simpler type
05:18:24 <mauke> :t ord
05:18:25 <lambdabot> Char -> Int
05:18:26 <mauke> simplest
05:18:30 <hpc> IO <foo> is the type of IO computations that produce a <foo>
05:18:32 <arch_is_awesome> What are the arrows?
05:18:34 <adamt> aristid: The poor bloke is confused, can we just tell him that haskell can do stuff that is considered unpure and leave out the details?
05:18:44 <mauke> arch_is_awesome: X -> Y is the type of a function that takes an X and returns a Y
05:18:45 <adamt> arch_is_awesome: Go read learn you a haskell and you'll understand.
05:18:58 <arch_is_awesome> Thanks!
05:19:18 <hpc> arch_is_awesome: "func :: foo -> bar -> baz" is the same as "baz func(foo, bar)"
05:19:24 <aristid> adamt: it isn't unpure though :P
05:19:25 <hpc> more or less
05:19:27 <mauke> arch_is_awesome: => is very different; it separates constraints from the rest of the type
05:19:34 <adamt> aristid: Point taken :>
05:19:42 <hpc> oh, he left
05:19:48 <mauke> that is, it looks like ...constraints here... => ...normal type here...
05:19:49 <aristid> adamt: if you say "purity is good" and "haskell isn't always pure", then that gives the wrong impression
05:20:37 <aristid> technically, haskell isn't always pure, if you allow for things like unsafePerformIO, i guess
05:20:42 <bitonic> hey! haskell is always pure
05:20:45 <bitonic> aristid: that's not Haskell
05:20:57 <aristid> bitonic: it
05:21:05 <aristid> bitonic: it's not in the standard?
05:21:17 <bitonic> aristid: no, iirc
05:21:21 <hpc> strictly speaking, GHC haskell is an impure lazy language with monadic plumbing and some very good assumptions about when it's needed
05:21:26 <mauke> I'm pretty sure it's in the FFI
05:21:28 <adamt> aristid: In my opinion it's better to lie a bit, than to give people the impression that you can't even do the traditional hello, world-program in haskell. ;)
05:21:33 <bitonic> mauke: oh right. haskell2010.
05:21:34 <aristid> bitonic: nice. well then my (and your) statement that haskell is pure is true
05:21:34 <hughfdjackson> how do you classify things like the IO monad as pure?
05:21:44 <mauke> hughfdjackson: wat
05:21:54 <hughfdjackson> :p that's why i'm asking
05:21:57 <bitonic> aristid: I think mauke is right, it was included in haskell2010
05:21:59 <mauke> hughfdjackson: how do you classify things like lists as pure?
05:22:05 <Bytter_> what book do you guys reccomend on equational reasoning in Haskell?
05:22:15 <aristid> hughfdjackson: you purely build IO statements, and then those are executed
05:22:24 <hughfdjackson> :D this i understand
05:22:30 <merijn> hughfdjackson: Because things in the IO monad always returns the same thing for the same input?
05:22:32 <bitonic> aristid, mauke: google doesn't fine unsafePerformIO in the standard actually
05:22:38 <hughfdjackson> its just.. that seems quite a thin line between purity and impurity
05:22:40 <mauke> @where report
05:22:40 <bitonic> so yeah, haskell is pure!
05:22:40 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
05:22:46 <hughfdjackson> a 'off on a technicality' sort of thing
05:22:58 <nand`> I consider something as pure when it's referentially transparent
05:23:04 <nand`> but there might be some things this definition doesn't cover
05:23:05 <mauke> hughfdjackson: it makes a big difference for the language itself
05:23:07 <hpc> merijn: more like "values of type (IO A) always evaluate to the same sequence of actions" :P
05:23:13 <merijn> hughfdjackson: The trick is to see that "IO String" is not something that returns a string, it returns' a "computation" that will return a string'
05:23:27 <merijn> hpc: Untrue, think of if else branches
05:23:29 <hughfdjackson> merijn: :D my reading had gotten me this far
05:23:41 <aristid> hughfdjackson: i don't think it's a technicality, it's an essential part of haskell :)
05:23:45 <nand`> in particular; let g = getLine in g >> g is the same as (getLine >> getLine)
05:23:47 <merijn> hughfdjackson: It can take a while for the full reality of this statement to sink in
05:23:49 <hughfdjackson> perhaps with some more practical application i'll understand better that the distinction goes way beyond pedantic
05:23:51 <adamt> merijn: but then the returned computation is unpure.
05:23:59 <bitonic> hughfdjackson: it goes a long way beyond pedantic
05:23:59 <merijn> adamt: No
05:24:02 <hpc> merijn: i count both branches and the condition itself as part of the sequence
05:24:11 <bitonic> it makes a huge difference, if we're using the word "pure" in the same way
05:24:19 <merijn> hughfdjackson: I had a nice example I described once. Give me a sec to work it out again
05:24:32 <mauke> hughfdjackson: I may have said this before but it's a bit like how javascript can't sleep()
05:24:41 <nand`> it's unpure as soon as it leaves haskell and enters the evaluation black box located in the real world
05:25:01 <hughfdjackson> mauke: :3 while ( +new Date < init + 1000 );
05:25:02 <hughfdjackson> hehe
05:25:03 <aristid> i think ezyang had a nice blog post about this
05:25:06 <hughfdjackson> i totally get what you mean though
05:25:24 <hughfdjackson> it's in the fabric of the language, and that gets you some awesome benefits, even if it seems functionally equivilent
05:25:52 <mauke> new motto: haskell is functionally equivalent~
05:25:56 <hughfdjackson> merijn: cheers matey
05:27:36 <nand`> is there any procedure for automatic optimization of pure programs by evaluating certain expressions at compile time?
05:27:50 <mauke> constant folding?
05:28:09 <Jaak> supercompilation?
05:28:13 <RichyB> drugs?
05:28:18 <nand`> eg. say I have some function “f :: Int -> String; f = show” and I write in my source code somewhere “f 5”, would it be possible to recognize situations like this where it can be replaced by an equivalent "5" string literal?
05:28:32 <mauke> yes
05:28:40 <mauke> even perl does this
05:28:41 <RichyB> nand`, yes.
05:28:51 <RichyB> mauke, really? oO
05:29:04 <mauke> constant folding is pretty simple
05:30:56 <bitonic> mauke: not if you have side effects
05:31:15 <RichyB> bitonic, *gcc* does a lot of constant folding. ;)
05:31:21 <mauke> bitonic: so you check that first
05:31:32 <mauke> of course in haskell that check is const False
05:31:33 <bitonic> RichyB: for simple arithmetic expressions and the like. doing it at a more complex scale is very tricky
05:31:41 <nand`> mauke: how would it handle something like, say, ($) (f 5) 3 where f :: Int -> Int -> Int
05:31:53 <bitonic> mauke: the "check for side effects" test is undecidable, or at least an exact one is
05:31:58 <mauke> nand`: first you inline ($)
05:32:01 <bitonic> you probably want a very conservative one
05:32:02 <mauke> bitonic: it doesn't have to be exact
05:32:08 <bitonic> mauke: yeah
05:32:20 <mauke> nand`: (\f x -> f x) (f 5) 3
05:32:22 <bitonic> but you are probably going to end up with something very simple
05:32:26 <opqdonut> @src ($!)
05:32:26 <lambdabot> f $! x = x `seq` f x
05:32:46 <mauke> nand`: then you evaluate to (f 5) 3
05:32:52 <mauke> nand`: and then maybe inline f
05:33:01 <nand`> or constant fold it?
05:33:20 <bitonic> mauke: there's also the problem of non-terminating functions. I just wouldn't call compile time evaluation a "simple" subject :P
05:33:48 <mauke> sure, if you want a fairly general system
05:34:16 <mauke> but something like 'f 3 where f = show' can be handled even by a stupid algorithm
05:34:20 <bitonic> sure.
05:35:22 <Eduard_Munteanu> BTW, how much constant folding does GHC do?
05:35:46 <Botje> as much as possible?
05:36:05 <bitonic> Botje: I don't think so
05:36:09 <bitonic> actually, definitely not
05:36:22 <Eduard_Munteanu> Nah, I don't think it'd precompute stuff like sum [1.9999999]
05:36:30 <Eduard_Munteanu> s/\./../
05:36:40 <bitonic> (and again, some times there is no "as much as possible", e.g. infinite computation)
05:36:41 <nand`> “as much as possible” can't be true; otherwise a program like “main = print $ someReallyReallySlowComputation 3” would take forever to compile and run in very short time
05:37:06 <bitonic> nand`: well most of the time you'd prefer that.
05:37:16 <bitonic> nand`: ofc you can enable/disable optimizations
05:37:31 <bitonic> but I'd want my compiler to evaluate a slow computation which is computable at compile time
05:37:40 <bitonic> e.g. converting string literals to Text/ByteString
05:37:44 <bitonic> which GHC does, iirc
05:38:12 <timthelion> -Wall produced more than 10KLOC of output.  So it doesn't fit in my scroll back buffer, yet when I did | more some weird shit happened but still didn't work.
05:38:22 <Eduard_Munteanu> Well, can you control it by some parameter? What compilation phase does that?
05:38:24 <mauke> that reminds me, I once wrote a slow program to compute the digits of pi in lisp
05:38:25 <timthelion> timthelion @ What to do???
05:38:27 <Eduard_Munteanu> e.g. the simplifier?
05:38:41 <bitonic> Eduard_Munteanu: I was simply referring to the various -O
05:38:50 <mauke> I "optimized" it by using macros to shift half of the computation over to compile time
05:38:50 <bitonic> which most likely will turn those things on/off
05:39:07 <mauke> timthelion: this is where an understanding of unix basics would help :-)
05:39:07 <Eduard_Munteanu> Yeah, though it's more than an on/off thingy, I guess.
05:39:17 <hpaste> merijn pasted “Imperative Haskell!” at http://hpaste.org/68957
05:39:18 <Eduard_Munteanu> I was wondering if it's tunable.
05:39:23 <timthelion> mauke: thank you for the belittling comment :D
05:39:28 <mauke> timthelion: every process has three communication channels by default
05:39:37 * Eduard_Munteanu goes grep man ghc
05:39:39 <mauke> timthelion: one for input (stdin), two for output (stdout, stderr)
05:39:44 <merijn> hughfdjackson: Not sure if those kinds of examples clarify why the difference between computation and impurity is important?
05:39:46 <bitonic> Eduard_Munteanu: I'm pretty sure it is, I mean you can even tell GHC at which phase trigger RULEs
05:39:59 <nand`> mauke: fastestPiDigits = "3.1415926" ++ undefined
05:40:00 <timthelion> mauke: so how do I pipe from stderr?
05:40:08 <mauke> timthelion: | connects the first process's stdout to the second process's stdin
05:40:30 <mauke> timthelion: you can use 2>&1 to redirect file descriptor 2 (stderr) to file descriptor 1 (stdout)
05:40:33 <merijn> nand`: You can use '2>' to redirect stderr, or '2>&1' to merge stderr with stdout
05:40:44 <timthelion> mauke: thanks.
05:40:49 <Botje> and in a sensible shell you can pipe stderr with |&
05:40:58 <Botje> sadly, not many shells are sensible :(
05:41:05 <merijn> Botje: You can do that with any shell 2>&1 >/dev/null
05:41:13 <nand`> what about the hsh? :)
05:41:19 <timthelion> yay, it works
05:41:51 <merijn> The latter redirect stdout to /dev/null, the former redirects stderr to stdout, discarding stdout and using stderr in any pipes
05:41:59 <timthelion> merijn: yeah, but on arch /dev/null don't exist.
05:42:09 <mauke> haha, what
05:42:23 <merijn> wat
05:42:35 <merijn> I don't believe you
05:42:41 <timthelion> merijn: perhaps you're right
05:42:49 * timthelion just liked
05:42:51 <timthelion> lied
05:43:17 * timthelion thought that it didn't exist, since it wasn't in his tab completion, but apparently that was due to bash being stupid.
05:43:40 <Eduard_Munteanu> I also wonder if unfolding/inlining has an effect on constant folding.
05:43:44 <nand`> timthelion: bash completes /dev/null for me
05:44:04 <mux> it's largely impossible for a unix-like system not to have /dev/null
05:44:09 <Eduard_Munteanu> Damn, I should look at GHC's internals sometime.
05:45:45 <hughfdjackson> merijn: :D errm
05:45:52 <hughfdjackson> did i miss a post of yours?
05:46:01 <hughfdjackson> mauke's comments helped clarify a lot
05:46:23 <merijn> hughfdjackson: lambdabot pasted it: hpaste.org/68957
05:46:26 <hughfdjackson> oh :D
05:46:37 <timthelion> my lord -Wall is over the top.  "This binding for point shadows..." when I have fooPoint (Foo point) = point...
05:46:42 <hughfdjackson> much obliged
05:47:06 <bitonic> timthelion: -Wall is all good, apart from the "ignoring return value in do notation" thing
05:48:10 <timthelion> bitonic: the idea that I "should not" reuse a name defined in a lower scope in a higher scope is rather bogus.
05:48:41 <bitonic> timthelion: it's not
05:48:50 <bitonic> I've had subtle errors before because of that
05:48:50 * timthelion was really excited when he found out he COULD reuse names.
05:49:03 <bitonic> expecially is the two names share the type as well. which is often the case
05:49:23 <bitonic> then you can't use the thing in the higher scope
05:49:26 <timthelion> In my case, it's always the case, since I'm just unpacking values.
05:49:47 <timthelion> the case that the types are the same that is
05:49:51 <bitonic> timthelion: yeah, that sucks, because it's really easy to get confused between the two. or at least, in my experience.
05:49:58 <bitonic> and the compiler won't complain
05:50:18 * timthelion just hates coming up with new names for thing
05:50:19 <timthelion> s
05:50:35 <bitonic> ehhh I know.
05:51:05 <timthelion> I mean, what should I write "unpackedPoint"???
05:51:21 <fmap> foo, foo', foo'', ..
05:51:25 <hughfdjackson> merijn: mind bending
05:51:27 <hughfdjackson> but very helpful
05:51:29 <timthelion> fmap: that's even worse :D
05:51:30 <fmap> infinite source of new names
05:51:31 <Botje> GUIDs.
05:51:31 <hughfdjackson> :D thanks a lot
05:51:57 <merijn> hughfdjackson: I've been doing quite a bit of imperative haskell lately, it's really neat :D
05:52:07 <timthelion> fmap: I only do that when I'm inside a single scope...
05:55:12 <fmap> timthelion: if you just need to unpack you can use view patterns i guess
05:59:29 <hughfdjackson> merijn: is this imperative just by style (use of the do-notation specifically)
05:59:38 <hughfdjackson> or is this that haskell variation going around
05:59:42 <hughfdjackson> or .. was it a library?
06:00:57 <d-snp> hey merijn what do you mean with imperative haskell?
06:01:25 * shapr yawns
06:01:27 <merijn> hughfdjackson: It's just imperative in the sense that it's all in the IO monad
06:01:41 <merijn> hughfdjackson: The IO monad is essentially and embedded DSL for writing imperative programs
06:01:48 <hughfdjackson> https://github.com/mmirman/ImperativeHaskell/blob/master/Main.hs <-- this is what i was thinking of
06:01:59 <hughfdjackson> :D it does seem rather that way
06:02:01 <merijn> Oh, no. That's just a silly joke
06:02:09 <hughfdjackson> the do notation is initially incredibly confusing
06:02:13 <merijn> It's funny, but not what people commonly mean
06:02:22 <hughfdjackson> i'm with you ^^
06:03:31 <merijn> d-snp: Well, just what I said. Programming in an imperative style and using quite a bit of state
06:07:15 <d-snp> oh, I'm doing that and I'm not enjoying it at all :P
06:12:11 <hpaste> timthelion pasted “What possible naming convention could prevent a warning here?” at http://hpaste.org/68958
06:12:23 <timthelion> ^^
06:12:54 * timthelion won't use just p, because he hates single letter variable names.
06:13:29 <nand`> pt maybe
06:14:12 <lucian> i've seen getFoo used for record syntax
06:14:12 <timthelion> m, that's just as bad as p, you can't tell from "pt" what "pt" refers to, which is what I like about "point", it's meaning is fully transparent
06:14:16 <lucian> instead of just foo
06:14:33 <timthelion> lucian: a possibility
06:14:34 <lucian> how about aPoint?
06:14:39 <nand`> point'
06:14:41 * nand` runs
06:14:54 <timthelion> lucian: what does the a stand for?
06:15:01 <lucian> timthelion: a point
06:15:06 <timthelion> ;)
06:15:20 <timthelion> I think I'll use getFoo
06:15:24 <lucian> destPoint
06:15:30 <untitled> what's the best way to parse line line "cmd arg1 arg2=<int> arg3=<list of ints>, where args can be in any order and whitespaces may occur around '=' and ','
06:15:43 <untitled> line like*
06:15:53 <lucian> timthelion: if i were you i'd just describe in more detail what it is, depending on context
06:16:09 <timthelion> lucian: as a comment?
06:16:16 <lucian> timthelion: no, i mean as a name
06:16:18 <untitled> in <list of ints> ints are separated by ',', btw
06:16:26 <lucian> so destinationPoint, or intermediaryPoint or something
06:16:38 <timthelion> lucian: a good plan too
06:17:10 <danr> timthelion: if you use RecordWildCards (or NamedFieldPuns), you can bring point to scope without the warning
06:17:22 <danr> by PathDestination{..} or PathDestination{point}
06:18:49 <timthelion> danr: danr also a possibility, I thought about it, but wondered if it wouldn't look awkward.
06:19:16 <timthelion> so far in this case I probably like renaming the feilds as gets.
06:19:36 <nand`> timthelion: maybe you could just use the actual “point” function where the situation allows for it
06:19:53 <nand`> though that might get ugly, eg. destination pathDest@(PathDestination _ _) = point pathDest
06:20:17 <nand`> s/_ _/_/
06:20:35 <timthelion> I like the patern matching syntax, because it shows exactly what I'm using, and what I'm ignoring.
06:20:47 <nand`> agreed
06:21:02 <nand`> (personally, I use ‘p’ for bindings like these)
06:21:16 <timthelion> nand`: {} is better than _'s because if you ever change PathDestination to have another feild you don't have to change your code.
06:21:20 <nand`> the only time I stray away from non-descriptive variable names is when the body is sufficiently large
06:21:44 <nand`> timthelion: oh, true; I did actually notice that and change it in my recent code a while ago
06:21:47 <nand`> seems I forgot all about it again
06:21:52 * timthelion has seen a lot of pasted code here, that he never figured out simply because every variable was single letter.
06:25:03 <tzxn3> is there any way to make a game without having a massive data structure containing the entire game state being passed around?
06:25:13 <tzxn3> if so, how is that avoided?
06:26:04 <tzxn3> I recognise there's the state monad, but all that really does is hide the passing around of the state
06:26:06 <timthelion> lucian: one small problem with using getFoo :D  path{Path.getPoint = relocatePoint (Path.point path) relocations,
06:26:19 <timthelion> getPoint = ... WTF???
06:26:25 <nand`> tzxn3: maybe some of the existing Haskell games, eg. Frag, could provide clues?
06:26:45 <tzxn3> I'm not good enough at practical code to understand them
06:26:47 <nand`> but I don't know if they use lots of state or not
06:27:03 <nand`> tzxn3: it was somebody's research paper, written rather clearly last time I checked
06:27:07 <timthelion> tzxn3: There is a package called reactiveBanana
06:27:10 <nand`> but I didn't read the whole thing
06:27:11 <timthelion> that you could look at
06:27:21 <nand`> and yeah, functional reactive program can model some things like this
06:27:41 <tzxn3> okay, thanks
06:27:55 <nand`> programming*
06:29:03 <lucian> timthelion: yeah, i don't like getFoo
06:29:06 * timthelion never understood why FRP is the way it is.
06:29:17 <tzxn3> it's just always seemed to me like a glaring elephant in the room, how does one implement things that traditionally rely heavily on state cleanly and efficiently?
06:29:40 <nand`> some things appear to rely on state that really don't
06:29:54 <timthelion> tzxn3: I developed my own method... https://github.com/timthelion/gridhaskell-haskarrow/blob/244dae0202c18c294c5b5151019005c50f33faa9/ThreadObject.lhs
06:30:20 <timthelion> tzxn3: It is working well in the program that file belongs to.  But I have yet to write any howto's...
06:30:24 <timthelion> too busy using it.
06:30:30 <nand`> alternatively, the underlying functionality can be abstracted very far from the actual state
06:31:48 <nand`> is that valid LHS? I thought you needed “> ”, not just “>”
06:32:00 <timthelion> nand`: it compiles and runs
06:32:07 <tzxn3> timthelion: how does that differ from IORefs?
06:32:44 <timthelion> tzxn3: I have "onGet" and "onPut" functions.  So that when I change an object, it can be automatically be redrawn on screen.
06:32:59 <timthelion> automatic integration with undo-redo as well.
06:33:45 <timthelion> so I have 99% pure code, that changes the objects value, and then in some other place, I have a little bit of drawing code which puts that value on the screen.
06:34:14 <tzxn3> aren't mutable objects inherently impure?
06:35:14 <nand`> tzxn3: with IO they aren't
06:35:29 <merijn> tzxn3: Only if you can mutate them in a way that violates referential transparency
06:35:29 <timthelion> tzxn3: yes, and no.  My code is pure in that I have a "pure" tail recursive loop, rather than any actual mutation.  But I need mvars to comunicate between threads.  Basically, I have a whole bunch of tail recursive pure threads, which comunicate through impure MVars.
06:35:45 <merijn> timthelion: MVars are pure
06:36:21 <timthelion> merijn: that's not true >>= and >> in the IO monad are not pure.  The functions that you bind are pure, but the binds themselves are not.
06:36:28 <merijn> They are pure
06:36:32 <merijn> Their implementation is not
06:36:37 <tzxn3> I don't know anything about concurrency really P:
06:36:38 <nand`> >>= in the IO monad *is* pure
06:37:06 <timthelion> tzxn3: concurency in haskell is the easiest thing in the world.  Read the awkward squad by PSJ.
06:37:25 <nand`> example: let a = (foo >> bar) in a >> a   -- same as foo >> bar >> foo >> bar
06:37:27 <merijn> timthelion: I challenge you to provide one example of >> and >>= breaking referential transparency (not counting unsafe*, of course)
06:37:28 <timthelion> merijn: do you have another name fore the distiction?
06:37:50 <timthelion> Perhaps we should use the words "naked" and "monadic"
06:38:07 <timthelion> and say that my base loop is naked, but the MVar use is monadic.
06:38:23 <merijn> Sure, I will agree with that, but monadic != impure
06:38:29 <timthelion> happy?
06:38:32 <tzxn3> aren't objects of type IO a simply theoretical IO actions that *could* happen? ;)
06:38:35 <timthelion> good :D
06:38:40 <tzxn3> and >>= just binds the theoretical results
06:38:46 <tzxn3> to another theoretical Io action
06:38:47 <tzxn3> ;P
06:38:48 <nand`> tzxn3: more or less
06:38:48 <merijn> tzxn3: They are computations that can returns a type of value
06:39:06 <merijn> tzxn3: That's the most common intuition for them, yes
06:39:14 <timthelion> tzxn3: no, bind in IO says "Preform the action described by the function which I am currently unpacking."
06:39:18 <nand`> by the time anything in Haskell gets executed, I consider it no longer inside Haskell
06:39:29 <merijn> nand`++
06:39:42 <quicksilver> timthelion: no, it doesn't.
06:39:51 <quicksilver> timthelion: bind doesn't cause actions to be performed
06:39:51 <timthelion> sigh
06:40:08 <tzxn3> bind in IO is basically sequencing, isn't it?
06:40:12 <merijn> timthelion: It's an important distinction
06:40:17 <quicksilver> > (putStrLn "hello" >>= \x -> putStrLn "world") `seq` 5
06:40:17 <lambdabot>   5
06:40:19 <nand`> tzxn3: (>>) in IO is, yes
06:40:29 <merijn> timthelion: Because "readLine >>= doStuff" doesn't cause readline to be executed
06:40:29 <tzxn3> yeah >>
06:40:34 <tzxn3> which is a special case of bind
06:40:40 <quicksilver> timthelion: ^^ that bind is evaluated, but no action is performed.
06:40:45 <tzxn3> yeah
06:40:54 <tzxn3> my understanding is >>= will simply return a new IO action
06:40:57 <nand`> (>>=) is composition of computations ;)
06:41:03 <tzxn3> that IO action doesn't necessarily have to be performed
06:41:11 <merijn> tzxn3: It essentially constructs more complex actions/computations from smaller ones, yes
06:41:32 <nand`> uh
06:41:34 <merijn> tzxn3: Up until main, which will then actually be implemented
06:41:36 <nand`> (>=>) is, my bad
06:41:38 <tzxn3> yeah
06:41:46 <merijn> err
06:41:51 <merijn> s/implemented/executed
06:42:40 <nand`> (>>=) could be considered, I dunno, computational application? note the similarity between ($) :: (a -> b) -> a -> b and (=<<) :: (a -> IO b) -> IO a -> IO b
06:43:08 <nand`> then again, that would really be ap :: IO (a -> b) -> IO a -> IO b
06:43:32 * nand` gives up trying to find a synonym for “bind” and sticks with “bind”
06:44:42 <nand`> merijn: I suppose it emphasises that Haskell is, in its purest form, a programming language - it describes programs (ie. computations)
06:44:53 <tzxn3> I think of bind as a special sort of mapping
06:45:21 <nand`> tzxn3: especially considering the fact that bind is just fmap + join
06:45:33 <tzxn3> aye
06:46:15 <Eduard_Munteanu> tzxn3: IMO, it's more like application
06:46:24 <nand`> hmm
06:46:30 <nand`> I found a reasonable analogy to bind
06:46:33 <nand`> “piping”
06:46:50 <nand`> eg. contrast “foo | bar” in shells with foo >>= bar
06:46:52 <dmwit> http://okmij.org/ftp/Computation/monadic-shell.html
06:47:00 <dmwit> Oleg did it! Oleg did it!
06:47:12 <nand`> dmwit: indeed, I did remember that article
06:47:23 <nand`> (while searching for a usable haskell shell a while back, sadly without fruit)
06:47:26 <Eduard_Munteanu> (<<<) gives composition for Kleisli arrows, and (>>=) is "application" in a similar sense.
06:47:31 <tzxn3> I'm never sure of the correct pronouns to use with functors
06:47:32 <tzxn3> :P
06:47:52 <Eduard_Munteanu> Them functors? :P
06:47:54 <byorgey> ze
06:47:59 <tzxn3> not pronouns
06:48:00 <tzxn3> uh
06:48:06 <merijn> nand`: I've been tempted to write one, but IMO it'd have to integrate with a terminal multiplexer like tmux/screen and possibly even an editor
06:48:09 <byorgey> pronominals?
06:48:12 <tzxn3> prepositions
06:48:13 <tzxn3> :P
06:48:13 <nand`> (>>>) = (>=>) for Kleisli with different types, right?
06:48:16 <byorgey> Dr. is appropriate
06:48:29 <Eduard_Munteanu> Erm, right, I mean (<=<) more specifically.
06:48:35 <tzxn3> how far can the box analogy be stretched?
06:48:41 <nand`> merijn: I'd be mainly interested in the concepts of a type safe shell
06:48:47 <Eduard_Munteanu> nand`: yeah
06:49:04 <byorgey> tzxn3: which analogy is that?
06:49:06 <Eduard_Munteanu> (>>>) is more general,
06:49:16 <Eduard_Munteanu> :t (>>>)
06:49:17 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
06:49:19 <Eduard_Munteanu> :t (>=>)
06:49:20 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
06:49:29 <merijn> Can you have typeclass restrictions on datatypes? If so, what's the reason to not use them?
06:49:43 <merijn> nand`: Not as nice as you'd think
06:49:45 <nand`> The only problem with typed shells I see is that a single command can have many different “return types” depending on the parameters used, and maybe even runtime behavior
06:49:49 <merijn> nand`: PowerShell is typed
06:49:58 <merijn> And it mostly ends up being annoying
06:49:59 <byorgey> merijn: yes, but soon no; the reason not to use them is that they hardly do anything
06:50:01 <tzxn3> functors as containers
06:50:05 <nand`> merijn: I've seen it in action, but I wasn't particularly impressed because of its verbosity and .NET-ishness
06:50:38 <byorgey> tzxn3: it can be taken fairly far, though only for certain functors
06:50:43 <dmwit> data Constrained a where Constrained :: Ord a => a -> Constrained a
06:50:46 <merijn> nand`: Typed shells means having to implement quite a bit of boiler plate functionality. Which is wasted effort when most scripts are run once or infrequently enugh to not be worth investing the effort
06:50:59 <dmwit> merijn: There's no reason not to use them (in that form).
06:51:15 <byorgey> oh sure, constraints on constructors is fine
06:51:31 <byorgey> I thought merijn was specifically talking about   data Ord a => Constrained a where ...
06:51:35 <merijn> byorgey: I was mostly just wondering because currently I have to annotate all my functions with "(Default a) => MyType a"
06:51:45 <nand`> merijn: at the very least, treating non-Haskell commands as lazy String -> IO String (or similar) to allow them to be sequenced with pure functions might be interesting; hsh does something similar (but it has no special syntax so using it as a general purpose shell is annoying)
06:52:00 <dmwit> I dunno, the question never mentioned that syntax as far as I can see.
06:52:19 <byorgey> dmwit: indeed, it was just my particular interpretation, which may or may not have had any relation to reality =)
06:52:27 <dmwit> heh
06:52:38 <byorgey> merijn: and what's wrong with that?
06:52:53 <merijn> dmwit, byorgey: Essentially I have a data type parameterised over a value which should be an instance of Default. But lacking a way to annotate this in the datatype results in annotating all functions with the typeclass
06:53:12 <merijn> byorgey: It's cumbersome and makes the function signatures very long at no benefit to the code?
06:53:13 <dmwit> Right, but byorgey (and I) don't see that as being a problem.
06:53:30 <merijn> I'm just lazy, ok :(
06:53:47 <byorgey> merijn: you can certianly put a Default constraint on the MyType constructor(s)
06:53:52 <nand`> what I would be interested in is the ability to easily evaluate Haskell expressions in a fashion similar to GHCi within my “normal” shell
06:54:36 <byorgey> merijn: though that may or may not get rid of the need for the constraints on functions
06:54:39 <dmwit> nand`: ghc -e
06:54:42 <byorgey> but if it doesn't, then you certainly need them
06:55:49 <dmwit> Actually, I guess I'd be a bit surprised if I ran across some functions that hid typeclass constraints in the constructors.
06:56:03 <byorgey> so would I.
06:56:09 <nand`> dmwit: thanks, didn't know about that - it doesn't cover the usage case of being able to define my own local names, types, instances etc. like I can do in GHCi. I've experimented with the idea of a “ghcid” (GHCi daemon) that keeps a running GHCi session that I can interact with from any shell using a “ghcidc”, conveniently aliased to some symbol
06:56:32 <nand`> just never actually implemented it
06:56:49 <nand`> but being able to use stuff like :t or :k from a regular shell without having to start or switch to a GHCi session can come in handy
06:57:10 <dmwit> zsh on acid? =)
06:57:23 <tzxn3> also, concurrency is easy if you know what you're doing
06:57:26 <nand`> Never used zwh, no comment
06:57:28 <nand`> zsh*
06:57:29 <tzxn3> I have no idea what I'm doing
06:57:36 <merijn> tzxn3: Ha, I beg to differ
06:57:51 <merijn> I know what I'm doing an concurrency is still a b****
06:58:02 <sykora> @pl f *** f
06:58:02 <lambdabot> f *** f
06:58:34 <fmap> join (***) f
06:58:37 <merijn> sykora: join (***)
06:58:42 <merijn> :t join (***)
06:58:43 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
06:59:13 <nand`> also, what would be fun is the ability to *embed* this behavior into larger expression eg. the way bash's `` and $() work, maybe providing something like (hehe) λ(some haskell . expression $ here) that would run and replace it in-place (though I can do this with $(ghc -e 'foo') already)
06:59:40 <sykora> :t join
06:59:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
07:00:03 <nand`> that type signature eerily reminds me of functors from C -> C×C
07:00:17 <nand`> (re: join (***))
07:00:24 <dmwit> ?pl \f -> f *** f
07:00:25 <lambdabot> join (***)
07:00:34 <dmwit> But beware! This comes with a hidden cost: f is now monomorphic.
07:00:48 <dmwit> To be more precise, the two arguments to (***) have the same type.
07:01:38 <ski> (`f' is monomorphic, yes)
07:02:16 <sykora> > join (***) . (+1) $ (1, 1)
07:02:17 <lambdabot>   No instance for (Control.Arrow.Arrow (,))
07:02:18 <lambdabot>    arising from a use of `Control...
07:02:36 <fmap> > ((+1) *** (+1)) (1 :: Int, 1 :: Double)
07:02:37 <lambdabot>   (2,2.0)
07:02:39 <dmwit> > join (***) (+1) $ (1,1)
07:02:40 <lambdabot>   (2,2)
07:02:46 <fmap> > join (***) (+1) (1 :: Int, 1 :: Double)
07:02:47 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
07:02:47 <lambdabot>         against inferred type ...
07:02:54 <sykora> > join (***) (+1) $ (1, 1.5)
07:02:55 <lambdabot>   (2.0,2.5)
07:03:05 <sykora> ah, it's inferring both floats
07:03:13 <nand`> :t 1.5
07:03:13 <lambdabot> forall t. (Fractional t) => t
07:03:25 <dmwit> sykora: You just made a hidden payment. =)
07:03:28 <nand`> what does Fractional t => t default to?
07:03:35 <dmwit> Double, I suspect.
07:03:52 <quicksilver> the default defaults are Integer for everything which can be Integer
07:03:55 <quicksilver> Double for everything else.
07:04:02 <sykora> > join (***) (++[]) $ ([1, 2], "ab")
07:04:03 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
07:04:03 <lambdabot>    arising from the literal `1...
07:04:08 <sykora> bingo
07:04:12 <nand`> quicksilver: thanks, suspected as much
07:04:18 <quicksilver> lambdabot, however, is non-standard
07:04:40 <dmwit> sykora: Of course, this doesn't mean ?pl is lying to you.
07:04:59 <dmwit> > (\f -> f *** f) (++[]) ([1,2], "ab") -- has the same problem
07:05:00 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
07:05:00 <lambdabot>    arising from the literal `1...
07:05:08 <sykora> of course
07:05:13 <Cale> > (1,1.5) + 1
07:05:14 <lambdabot>   (2,2.5)
07:05:15 <Cale> :D
07:05:25 <nand`> > 1 2
07:05:25 <lambdabot>   1
07:05:46 <quicksilver> > 1 (2,3)
07:05:46 <lambdabot>   1
07:05:48 <Cale> Lambdabot has some modules which define instances of Num for functions and pairs
07:05:50 <quicksilver> it's all nonsense :)
07:05:59 <sykora> > (\f (x, y) -> (f x, f y)) (++[]) ([1, 2], "ab")
07:06:00 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
07:06:01 <lambdabot>    arising from the literal `1...
07:06:07 <Cale> > (2,3) 1
07:06:08 <lambdabot>   Couldn't match expected type `t1 -> t'
07:06:08 <lambdabot>         against inferred type `(t2, ...
07:06:15 <nand`> > flip [(+1), (*2), (/3)] $ 5
07:06:16 <quicksilver> lambdabot imports Newbie.ConfusingNonsense
07:06:17 <lambdabot>   [6.0,10.0,1.6666666666666667]
07:06:32 <nand`> perhaps my favorite is still (.) = fmap
07:06:33 <sykora> > (,3) 1
07:06:34 <lambdabot>   Illegal tuple section: use -XTupleSections
07:06:45 <Cale> > (2,3) + ((1,4),5)
07:06:46 <lambdabot>   ((3,6),8)
07:07:04 <sykora> Cale: what just happened?
07:07:08 <dmwit> > let g :: (forall a. [a] -> [a]) -> [a] -> [b] -> ([a], [b]); g f x y = (f x, f y) in g (++[]) [1,2] "ab"
07:07:10 <lambdabot>   ([1,2],"ab")
07:07:16 <nand`> > (1,2) 3
07:07:16 <lambdabot>   Couldn't match expected type `t1 -> t'
07:07:16 <Cale> sykora: type inference :D
07:07:16 <lambdabot>         against inferred type `(t2, ...
07:07:28 <merijn> sykora: 2 added to 1 and 4 (first part of tuple) and 3 added to 5 (second part of tuple)
07:07:33 <nand`> > (2 + (1,4), 3 + 5) -- sykora
07:07:34 <lambdabot>   ((3,6),8)
07:07:36 <Axman> > 2 :: (Int,Int)
07:07:36 <sykora> churning, churning, got it
07:07:37 <lambdabot>   (2,2)
07:07:44 <nand`> > ((2+1, 2+4), 3+5) -- sykora
07:07:45 <lambdabot>   ((3,6),8)
07:07:49 <Cale> sykora: The literal 2 is fromInteger (2 :: Integer)
07:07:54 <merijn> lambdabot is filled with lies and confusingness :p
07:08:03 <byorgey> you mean lies and awesomeness
07:08:09 <Axman> and it's all Cale's fault!
07:08:10 <Cale> sykora: and there's an instance of that for pairs which just does  fromInteger n = (fromInteger n, fromInteger n)
07:08:19 <merijn> confusion and awesomeness are suprisingly similar
07:08:21 <nand`> Caleskell strikes again
07:08:35 <Cale> It's really Conal's vector-space package :)
07:08:46 <Cale> which has all this Num-related stuff in it :)
07:09:15 <Cale> actually, I think he's separated that into a NumInstances package now
07:09:17 <byorgey> which is actually used in diagrams when computing cubic splines =)
07:09:20 <Cale> (but I haven't updated that)
07:09:25 <byorgey> see, real-world useful stuff!
07:09:54 <quicksilver> the num instances are not required to make the stuff useful, though
07:10:03 <quicksilver> the num instances are just a trivial - and occasionally confusing - shortcut
07:11:54 <adamvh> How do you put a type constraint on a constructor you declare with data?
07:12:29 <adamvh> As in if I want a "complex" type whose real and complex part can be any instance of Num
07:12:58 <copumpkin> you don't
07:13:11 <copumpkin> the existing complex type does it and everyone hated it, so they took the feature out of the language
07:13:16 <Axman> don't put them on the data declaration. they infect all functions that have to use the type from then on
07:13:29 <adamvh> I see...
07:13:31 <Cale> However!
07:13:32 <copumpkin> @src Complex
07:13:32 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
07:13:42 <Cale> If you're allowed GADT syntax with GHC
07:13:46 <Cale> then you can usefully do it
07:14:02 <copumpkin> yeah, but it's kind of horrible to have something that looks parametric but isn't :)
07:14:06 <copumpkin> but ah well
07:14:14 <Cale> data Complex a where Cx :: (Num a) => a -> a -> Complex a
07:14:30 <Cale> will make the Cx data constructor carry a Num dictionary around with it.
07:14:56 <untitled> how to take and drop first element of [String]?
07:14:58 <Axman> that's not great for performance is it?
07:15:02 <adamvh> Huh
07:15:05 <untitled> is there an existing function?
07:15:09 <byorgey> untitled: take 1, drop 1
07:15:10 <copumpkin> Axman: nothing really wrong with it
07:15:13 <mm_freak_> untitled: take and drop?
07:15:18 <copumpkin> pattern match on it
07:15:25 <Axman> untitled, your questions doesn't make much sense, can you give an example?
07:15:28 <Cale> Axman: It's not much worse or better than any other way of getting the typeclass dictionary where it's going.
07:15:29 <copumpkin> that'll force you to deal with the empty case, too
07:16:06 <adamvh> Is it something that's specialized out at compile time?
07:16:25 <Axman> not necessarily i believe
07:16:32 <copumpkin> no
07:16:42 <copumpkin> not if you bundle it into the constructor like that
07:16:58 <copumpkin> if you just use the conventional approach
07:17:01 <copumpkin> then you can specialize it
07:17:08 <copumpkin> (optionally)
07:19:11 <Cale> Though in practice, it can be quite a lot of work to get it to usefully specialise things all the way through a long chain of definitions (once you have polymorphic functions written in terms of polymorphic functions in terms of others, and so on -- you'll need specialisation pragmas for all of them)
07:19:34 <copumpkin> yeah
07:20:58 <joe9> anyone seen this error: http://codepad.org/jpTQs5MG
07:21:05 <joe9> this is from cabal install Extra
07:21:12 <joe9> any suggestions on how to fix this.
07:22:17 <dmwit> Contact the maintainer of Extra.
07:22:25 <Cale> I'd start by looking at the source code of Extra/SSH.hs and try to figure out why it expects those things to be in scope. It's not obvious whether they're imported from some other module which is in a different package or what.
07:22:41 <dmwit> And yes, in the meantime Use the Source.
07:22:51 <Cale> It might be that a dependency of Extra has changed what it exports.
07:25:30 <yitz> the way to take the first element of a list is maybe (do something) (NE.take 1) . NE.nonEmpty (using Data.List.NonEmpty, from the semigroups package)
07:26:05 <dmwit> ...or just "take 1".
07:26:16 <dmwit> listToMaybe . take 1 if you *insist* on using Maybe somewhere.
07:26:32 <yitz> dmwit: also good approachs
07:26:45 <yitz> dmwit: but i wanted to plug the semigroups package
07:28:48 <joe9> cale, dmwit: yes, that was it. unixutils 1.50 is very different from 1.48.1
07:30:18 <syntaxfree> so  how is Hakell doing in numerical computing these days?
07:30:40 <syntaxfree> I need an alternative to Matlab, because Octave (the open source interpreter the company I'm consulting for is using) just isn't cutting it.
07:31:06 <yitz> joe9: a package without upper bounds on its cabal dependencies bitrots very quickly. this one hasn't been updated in over a year, so there are likely many dependency problems.
07:31:08 <syntaxfree> I was looking at Incanter, a Clojure dialect, but it seems moribund. And I first learned programming in Haskell, it's still my default mode of thinking.
07:31:25 <quicksilver> Matlab is a massive, massive piece of software
07:31:32 <quicksilver> replicating it in haskell would be a life's work
07:31:48 <quicksilver> replicating that part of it your client actually uses might only take 10 minutes
07:31:49 * hackagebot hack2-interface-wai 2012.5.24 - Hack2 interface of WAI  http://hackage.haskell.org/package/hack2-interface-wai-2012.5.24 (JinjingWang)
07:31:51 <quicksilver> depends what they do :P
07:32:01 <yitz> quicksilver: replacing it in Octave probably would be too
07:32:13 <syntaxfree> This is the thing.
07:32:49 <syntaxfree> I develop in Matlab. My main work is in statistics, I don't need to deliver code, so I just prototype in Matlab. Now, Octave is like 90% compatible with Matlab. But it's slow.
07:33:28 <aristid> syntaxfree: and matlab would be fast enough?
07:33:32 <syntaxfree> and yesterday I hit an emergency because Octave didn't have some library, I thought it'd just be a matter of, um, comandeering it from the Matlab toolboxes, but Octave *doesn't support objects*.
07:34:08 <dmwit> Matlab is vastly faster than Octave.
07:34:16 <syntaxfree> Julia looks promising.
07:34:47 <syntaxfree> julialang.org. But it makes even less promises about Matlab compatibility than Octave. It's Matlab-like. Impressive benchmarks, though.
07:34:50 <aristid> syntaxfree: and why can't you just use matlab for the non-prototype version? too expensive?
07:35:34 <syntaxfree> well, yeah. And code would have to be delivered to a client eventually.
07:36:02 <yitz> syntaxfree: what library do you need?
07:36:08 <syntaxfree> I said I'm doing "consulting"  but I'm doing some coding on the side in exchange for equity. So the "client" can't be assumed.
07:36:43 <syntaxfree> I already fixed that problem. I stole some code, wrote some code, made it run. But I'm considering outside-the-Matlab-ecosystem alternatives.
07:37:04 <syntaxfree> which is why I'm here. To inquire how is numerical computing in Haskell these days.
07:37:09 <dmwit> It's really, really hard to say if Haskell will suit your needs with a description as vague as "Octave sucks".
07:37:22 <syntaxfree> I'm getting some pressure to do Python, but NumPy makes me joints ache.
07:37:38 <syntaxfree> Ok, I was asking a vaguer question.
07:38:25 <syntaxfree> Suppose I go into #python and ask "How is numerical computing in Python these days?". The answer I'm expecting is "Well, NumPy exists, and it's $this_stable, but has $these_problems"
07:38:43 <syntaxfree> same for Clojure->Incanter.
07:39:10 <syntaxfree> I'm not in emergency mode, I'm shopping around for platforms for future development.
07:40:09 <dmwit> I guess I'm not really allowed to complain about the question, since I don't even know the answer to any of the possible better questions.
07:40:15 <hpaste> timthelion pasted “What kind of warning is that???” at http://hpaste.org/68960
07:40:21 <timthelion> ^^
07:40:23 <timthelion> ???
07:40:56 <dmwit> The warning looks pretty clear to me.
07:41:08 <timthelion> But is there really anything wrong with my code?
07:41:14 <dmwit> No.
07:41:17 <dmwit> Warnings are not errors.
07:41:24 <dmwit> (unless you -Werror)
07:41:42 <Cale> Is that with -Wall?
07:41:52 <timthelion> I know, but what is it complaining about?  Is there any reason I should change that?  yes, I have -Wall
07:42:02 <dmwit> It's a code documentation thing.
07:42:07 <Cale> Yeah, -Wall likes to complain about all kinds of spurious non-issues.
07:42:13 <dmwit> If you write "_ <- forkIO $ blah" it's more clear that you know what you're doing.
07:42:18 <Cale> ;___;
07:42:47 <timthelion> ok
07:42:57 <Cale> I still wouldn't write it that way. :P
07:42:59 <dmwit> I should be clear: this is the sentiment held by the people who invented and implemented that warning.
07:43:06 <Cale> I would just turn off -Wall at this point :)
07:43:09 <dmwit> Dunno if I agree with it; I haven't done enough industrial Haskell to know.
07:43:46 <timthelion> dmwit: Perhaps I agree, simply because I just looked up forkIO and hadn't realised it even returned a value :)
07:43:55 <dmwit> =)
07:44:06 <timthelion> not that my program doesn't work...
07:44:31 <timthelion> I just turned on -Wall today, on a 5.5K LOC project... And it's been 4 hours of hacking.
07:44:44 <timthelion> perhaps only 3 hours.
07:44:45 <dmwit> Really, though, is there a reason not to just go ahead and return the ThreadId from that function?
07:44:47 <timthelion> but I'm not done yet
07:44:52 <Cale> Yeah, you often don't need the thread ID returned by forkIO, unless you plan to kill that thread violently later in your program.
07:45:01 <Cale> (or send it exceptions to catch)
07:45:18 <quicksilver> or massage it gently with the asynchronous bliss which is exceptions-as-communication
07:45:35 <timthelion> No thanks.
07:45:53 <fmap> timthelion: isn't "do stuff; return ()" just "void $ stuff"?
07:46:11 <timthelion> fmap: that would also work I guess.
07:46:12 <dmwit> There are many ways to skin this cat, yes.
07:46:24 <Cale> fmap: well, yes, though void was only added by the same people as wanted that warning message :P
07:46:51 <dmwit> hah
07:47:01 <Cale> (though I guess it can be handy to have a name for that, given all the badly-designed functions around, which take parameters of type  IO ()  when they should be taking parameters of type  IO a
07:47:05 <Cale> )
07:47:43 <Saizan> void is not a good name though
07:47:50 <timthelion> Cale: why would you confuse us by asking for an arbitrary value which will be discarded ;)
07:48:08 <Cale> timthelion: The thing is, the type will actually tell you that it must be discarded.
07:48:10 <timthelion> Cale: remember, haskell programmers are no more inteligent than the Computers they program...
07:48:32 <Cale> If you had something like  IO a -> IO ThreadId
07:48:44 <otters> I have a module that works with ByteStrings a lot and thus exports Data.ByteString.Char8, with the result that if you import the module you get a lot of naming conflicts between Prelude functions and ByteString functions
07:48:47 <Cale> Then the value of type a returned by the action can't go anywhere, or be used by anything.
07:48:50 <otters> how can I best resolve this?
07:48:54 <timthelion> Cale: then you use the darned void function, it's simple....
07:49:44 <Cale> (and the type system would enforce it)
07:50:22 <Cale> otters: um, either don't export Data.ByteString.Char8, or let your users know that they'll have to import your module qualified?
07:50:30 <Cale> (Or import the Prelude hiding stuff)
07:51:12 <otters> hm
07:51:25 <otters> I guess I'll have to not export Data.ByteString.Char8
07:51:33 * user99 time emerge ghc -->real	320m52.346s
07:51:33 <user99> user	217m23.924s
07:52:39 <paczesiowa> is it possible to write a function of type :: Either String a -> a, that would fail on compile time (with the specified error)?
07:52:58 <Zippo> I have an existing Haskell application that was written for Haskell 6.2 but will not build under 6.10.4.
07:53:17 <timthelion> paczesiowa: ????
07:53:36 <Cale> paczesiowa: Not really, no.
07:54:06 <timthelion> Zippo: you mean GHC? Haskell is versioned by the year, 98 and 2010
07:54:08 <Cale> paczesiowa: What if its input came from user input, say?
07:55:02 <fmap> Zippo: paste errors
07:55:03 <paczesiowa> Cale: I don't care about user input, the argument will be a top level value, easily computable (with TH probably) during compilation
07:55:18 <Zippo> BUILDINT.txt says that "it should build on any platform which supports GHC 6.2" I'm just trying to get it to build.  I want to understand why it's not building correctly too.
07:55:22 <dmwit> paczesiowa: Then just have the TH throw the error or put a value there.
07:55:40 <paczesiowa> dmwit: what about that nice error msg?
07:55:47 <Zippo> Just here in the channel?
07:55:49 <dmwit> What about it? TH does error messages.
07:55:56 <fmap> @where hpaste
07:55:56 <lambdabot> http://hpaste.org/
07:56:14 <fmap> Zippo: there ^
07:56:28 <paczesiowa> dmwit: but can I make TH/GHC display any error message (it should be human readable)?
07:57:46 <rwbarton> paczesiowa: well these seem to work all right: http://hpaste.org/68961
07:57:56 <hpaste> merijn pasted “RankNTypes error?” at http://hpaste.org/68962
07:57:59 <dmwit> paczesiowa: Yes.
07:58:08 <merijn> I'm getting a compiler error I don't understand
07:58:09 <timthelion> Hm, Prelude in haskell2010 polutes a lot.  All those simple words like head, tail, first, last, ect are taken...
07:58:26 <mcstar> haha
07:58:27 <dmwit> paczesiowa: There's fail, and there's also report.
07:58:32 <hpaste> zippo pasted “MD5-errors” at http://hpaste.org/68963
07:58:38 <merijn> timthelion: "import qualified Prelude" and than import what you want directly?
07:58:40 <Zippo> http://hpaste.org/68963
07:59:08 <merijn> GHC says I should enable RankNTypes, but I'm suspicious of enabling extensions without understanding why I need them...
07:59:15 <dmwit> merijn: That's not how you do it.
07:59:29 <dmwit> merijn: You need to use GADT syntax if you're trying to do what we talked about earlier.
07:59:33 <rwbarton> more likely you just want to s/\(Field a\) => //g
07:59:34 <merijn> dmwit: Probably, I was refactoring my old code. But not sure to do what I want
07:59:37 <dmwit> (So no records for you, I'm afraid.)
07:59:47 <merijn> dmwit: No, this is actually a different case then my earlier example
07:59:55 <timthelion> merijn: Perhaps.
08:00:10 <dmwit> Okay. What were you hoping this annotation would mean, then?
08:00:51 <dmwit> (Who gets to choose what a is, the guy making a value of type Info or the guy using a value of type Info?)
08:01:11 <merijn> dmwit: The guy making Info
08:01:26 <dmwit> Then listen to rwbarton and just don't write the class constraint here3.
08:01:30 <merijn> dmwit: I need to pass a bunch of callbacks throughtout my program
08:02:08 <dmwit> Hey, neat, e3. is a perfectly cromulent typo in both qwerty and dvorak.
08:02:21 <merijn> (Actually, I think the a in the Info data declaration is unneccessary now, but when I remove it GHC also complains)
08:03:30 <merijn> dmwit: I have those functions already and I need a convenient container to pass them throught the initialisation process of my program
08:03:48 <timthelion> dmwit: to think, that your inteligence, goes to determining the cromulence of typo's between Dvořak and Qwerty.
08:03:51 <merijn> I accept that maybe Info is not what I want, but I'm unsure what I do want in that scenario
08:04:40 <dmwit> timthelion: Dvořak is the composer, Dvorak is the keyboard inventer. =)
08:05:20 <Zippo> There are more errors, but they are of the same type as the one I posted.
08:05:23 <dmwit> merijn: Info seems useful. Just delete the class constraint everywhere in the data declaration.
08:05:48 <timthelion> dmwit: he simply didn't know that his name was supposed to be spelt Dvořák...
08:06:07 <dmwit> Zippo: I expect the fix is to change "bounds" to "getBounds".
08:06:17 <fmap> Zippo: I'd guess StorableArray is MArray not a IArray
08:06:22 <fmap> so no "bounds"
08:06:53 <dmwit> Other massaging may be necessary if it's expecting a pure result from bounds.
08:06:59 <mcstar> what was Qwerty's last name?
08:07:01 <timthelion> dmwit: the irony, is that Qwerty is better for Czech which is composed mainily of consonants.
08:07:25 <parcs`> merijn: the a in Info s a and the a in eg infoNew :: (Field a) =
08:07:35 <parcs`> are different
08:08:15 <parcs`> the type of the data constructor Info will be Loc -> (forall a. Field a => ....) -> .... -> Info s b
08:08:24 <parcs`> which is a Rank-2 type
08:09:41 <merijn> dmwit: Ah, this seems like it might work
08:10:39 <Zippo> MD5.lhs:149:38: Not in scope: `getBounds'
08:10:41 <yitz> mcstar: that question is related to the question of which characters follow "dvorak" on the top row of the keyboard.
08:11:32 <rwbarton> the fields in http://hpaste.org/68962 are not polymorphic, they just have weird types
08:11:46 <rwbarton> for example you can write data Foo a = Foo { x :: Num a => a }, and then Foo 3 :: Foo Char
08:12:10 <rwbarton> this isn't a useful thing to do
08:12:15 <dmwit> ?index getBounds
08:12:15 <lambdabot> bzzt
08:12:16 <Zippo> The import statement:
08:12:17 <Zippo> import Data.Array.IArray (bounds,listArray,(!))
08:12:23 <dmwit> ?hoogle getBounds
08:12:24 <lambdabot> Data.Array.MArray getBounds :: (MArray a e m, Ix i) => a i e -> m (i, i)
08:12:29 <dmwit> Zippo: ^^
08:13:07 <rwbarton> if you try to extract with x (Foo 3 :: Foo Char), you get a "No instance for (Num Char)" error
08:13:38 <dmwit> ?remember yitz <mcstar> What was Qwerty's last name? <yitz> Which characters follow "dvorak" on the top row of the keyboard?
08:13:39 <lambdabot> Good to know.
08:13:45 <dmwit> Is it dishonest if it's not an exact quote?
08:14:02 <yitz> dmwit: haha fine with me
08:14:11 <byorgey> yes. so?
08:14:18 <byorgey> ;)
08:14:20 <dmwit> =D
08:14:55 <mcstar> yitz: on second thought, qwerty sounds more like a family name, so i should have asked first name :(
08:15:22 <nand`> mcstar: he's obviously “Qwerty Dvorak”
08:15:30 <dmwit> rwbarton: You're right, that is weird. Are those sentences precise?
08:16:25 <armlesshobo> nand`: lol
08:16:29 <dmwit> via testing: they are precise
08:16:30 <parcs`> rwbarton: that is strange. i'm not sure how higher-rank constraints work anymore
08:16:44 <rwbarton> the type of Foo becomes Foo :: (Num a => a) -> Foo a
08:16:52 <dmwit> Ah. ah!
08:16:58 <dmwit> So weird. =)
08:17:07 <Zippo> dmwit so I would have something like import Data.Array.MArray (getBounds)
08:17:11 <dmwit> No, wait, I still don't get it.
08:17:27 <rwbarton> which is a non-Haskell 98 type, it is not exactly higher rank, but certainly a weird thing to put a class constraint in that kind of position
08:17:28 <dmwit> Why does writing x (Foo 3 :: Foo Char) determine that 3 :: Char?
08:17:48 <dmwit> From my reading the type of 3 should be unconnected to the type argument to Foo.
08:17:50 <rwbarton> x :: Num a => Foo a -> a -- according to ghc
08:17:52 <rwbarton> why
08:17:59 <dmwit> Yes, why?
08:18:07 <rwbarton> the a in "data Foo a = ..." is the same a as in "x :: Num a => a"
08:18:11 <rwbarton> imagine if there is no Num constraint
08:18:26 <dmwit> But, but...
08:18:27 <armlesshobo> a would be of any type
08:18:32 <byorgey> but then why does Foo have the type it does?
08:18:36 <rwbarton> "Num a => " does not introduce an existential
08:18:36 <dmwit> Yeah!
08:18:42 <rwbarton> hmm?
08:18:57 <dmwit> Foo :: (Num a => a) -> Foo a -- are these a's truly related?
08:19:02 <rwbarton> yes, same a
08:19:06 <dmwit> whaaaat
08:19:06 <armlesshobo> yes
08:19:06 <byorgey> oh, I see, in  (Num a => a) -> Foo a  there is only one 'a'
08:19:09 <rwbarton> yes
08:19:10 <armlesshobo> type constraint
08:19:32 <danr> isn't that a malformed context/type?
08:19:33 <ski> `x :: Num a => Foo a -> a' is the same as `x :: Foo a -> (Num a => a)', surely ?
08:19:34 <Saizan> imagine data Num a = .. and s/=>/->/
08:19:35 <byorgey> its first argument is just a higher-order "function" requiring a Num dictionary
08:19:35 <rwbarton> and i can write values of type Num a => a, even when a is not an instance of Num, like 3
08:19:40 <mcstar> dmwit: this follows directly from intuitionistic logic! XD
08:19:41 <armlesshobo> that implies that the only types that are allowed are those that derive from Num
08:20:05 <rwbarton> because... 3 :: Num a => a
08:20:07 <rwbarton> so Foo 3 :: Foo a
08:20:10 <rwbarton> for any a
08:20:18 <armlesshobo> [Char] is not of type Num so it's not valid
08:21:05 <rwbarton> ski: yes, or at least ghc thinks so. i remember we had some discussions about these kinds of types earlier
08:21:24 <rwbarton> id :: (C a => a) -> (C a => a)
08:21:28 <rwbarton> caused many problems for ghc
08:21:59 <ski> GHC lifts `forall a. 's and `constr =>'s out of the right argument of `->'
08:22:37 <ski> armlesshobo : s/not of type/not in class/
08:22:45 <rwbarton> yes, which is all well and good in HM but causes problems with these contrived examples
08:22:46 <mcstar> can i execute multiline code here?
08:22:52 <armlesshobo> ski: ah, yes. thank you for the correction :)
08:23:09 <ski> mcstar : if you rewrite it in a single-line
08:23:23 <mcstar> ski: i dont think its possible, the first is a type declaration
08:23:48 <rwbarton> like a data declaration?
08:23:54 <ski> lambdabot doesn't accept type (or class or instance) declarations anyway
08:23:56 <Eduard_Munteanu> mcstar: let x :: Int; x = 3 in x
08:24:01 <ski> (it does accept type signatures, though
08:24:02 <ski> )
08:24:02 <Eduard_Munteanu> > let x :: Int; x = 3 in x
08:24:04 <lambdabot>   3
08:24:14 <mcstar> Eduard_Munteanu: thanks, thats totally not what i want
08:24:34 <mcstar> > type Just = Maybe
08:24:35 <lambdabot>   <no location info>: parse error on input `type'
08:24:37 <mcstar> > Just 3 :: Just Int
08:24:37 <lambdabot>   Not in scope: type constructor or class `Just'
08:24:59 <Eduard_Munteanu> Ah.
08:25:20 <Zippo> I'm not clear on what I should try next.  As I said, I'm guessing something was most likely changed or deprecated in the switch from 6.2 to 6.10.
08:25:28 <dmwit> ?let type Just = Maybe
08:25:28 <armlesshobo> mcstar: lmao
08:25:29 <lambdabot>  Invalid declaration
08:25:32 <dmwit> aww
08:25:43 <Zippo> I haven't modified the source code at all other than these attempts to get it to initially compile.
08:25:56 <dmwit> Zippo: What's the most recent error?
08:26:03 <ski> > let reverse :: [a] -> [a]; reverse (as :: [a]) = loop as id where loop :: [a] -> ([a] -> [a]) -> [a]; loop [] k = k []; loop (a:as) k = loop as $ \bs -> a : k bs in reverse "reverse"
08:26:04 <lambdabot>   "esrever"
08:26:38 <tac-tics> > reverse . reverse $ "reverse"
08:26:38 <absence> is it possible to run a "Reader r" action in a "ReaderT r IO" monad?
08:26:39 <lambdabot>   "reverse"
08:26:42 <Eduard_Munteanu> BTW, does lambdabot treat '?'- and '@'- commands differently?
08:26:46 <ski> mcstar : that'd work, yes -- but why would one do that ?
08:26:53 <ski> Eduard_Munteanu : not to my knowledge
08:27:05 <Zippo> When I changed "hashPtrElems hash ptr (rangeSize (bounds array)))" to "hashPtrElems hash ptr (rangeSize (getBounds array)))" I got this error MD5.lhs:149:38: Not in scope: `getBounds'
08:27:11 <dmwit> absence: Yes, but it's usually easier to make your Reader r action more polymorphic.
08:27:18 <mcstar> ski: it was another more elucidating exmaple of Foo x :: Foo Int
08:27:27 <dmwit> absence: So that it has type MonadReader m r => m a instead of (e.g.) Reader r a.
08:27:29 <nand`> MonadReader m =>
08:27:38 <nand`> or m r
08:27:47 <dmwit> absence: For most actions, this is as easy as just changing or removing the type signature.
08:27:51 <nand`> isn't it MonadReader r meither way
08:27:54 <merijn> mcstar: You realise both Foos in that line are different, right?
08:28:05 <dmwit> nand`: I wouldn't be surprised.
08:28:07 <mcstar> merijn: thats why it was more lucidating!
08:28:09 <absence> dmwit: good idea, thanks
08:28:11 <mcstar> e*
08:28:15 <user99> in the following snippet what is the '<-'  operator called? [x*2 | x <- [1..10]]
08:28:23 <dmwit> user99: "bind"
08:28:25 <ski> mcstar : i think it's nicer to *not* have a data constructor and a type constructor which are named the same ..
08:28:43 <merijn> ski: Depends whether you only have on constructor or not
08:28:44 <ski> user99 : `x <- [1..10]' there is a "generator"
08:28:51 <mcstar> ski: im not arguing with that, i just wanted to shed light on, that 1 Foo was a type, and the other was a constructor
08:28:55 <dmwit> user99: Though you could reasonably pronounce it other ways; "in" seems quite natural in many situations.
08:28:59 <Eduard_Munteanu> If you're using transformers, isn't Reader r = ReaderT r Identity   anyway?
08:29:00 <ski> user99 : so, maybe "generate", if not "bind"
08:29:01 <parcs`> :t mapReaderT (return . runIdentity)
08:29:02 <lambdabot> forall (n :: * -> *) a r. (Monad n) => ReaderT r Identity a -> ReaderT r n a
08:29:11 <merijn> user99: It's syntactic sugar for the bind operation in the list monad (you can ignore anything from this line that you don't understand)
08:29:13 <dmwit> [ x*2 | x <- [1..10] ] => "ex times two for x in one to ten"
08:29:15 <armlesshobo> so, is 'do' solely responsible for making a monad perform an action?
08:29:19 <nand`> dmwit: “from” can work too
08:29:32 <Eduard_Munteanu> (because I wonder what the question actually was)
08:29:33 <merijn> armlesshobo: No, do doesn't even perform actions
08:29:43 <Kaidelong> armlesshobo: do is just syntax sugar
08:29:47 <Kaidelong> what do you mean by action?
08:29:47 <armlesshobo> right
08:29:49 <merijn> armlesshobo: do is just syntactic sugar for lambda's and (>>=)
08:30:00 <Kaidelong> the only IO that gets done is that that you name "main"
08:30:00 <user99> there went the light bulb ' for x in' did it thx guys ;-)
08:30:07 <merijn> @undo do {x <- foo; bar x}
08:30:07 <lambdabot> foo >>= \ x -> bar x
08:30:10 <mcstar> ./programname performs the actions
08:30:12 <rwbarton> merijn: so what you wrote in http://hpaste.org/68962 basically means that when I want to construct a value of type Info s a, I get to assume that a is an instance of Field (specifically when I am producing the infoNew, infoIn, ... fields), even if it isn't really one.
08:30:36 <rwbarton> merijn: then when someone else tries to use the Info s a, if a didn't turn out to be an instance of Field after all, oops error.
08:30:42 <merijn> rwbarton: I seem to have solved the issue by moving the typeclass constraint to the functions calling the functions in Info s a
08:30:48 <armlesshobo> I'm just trying to figure the secret of monads
08:30:49 <armlesshobo> lol
08:30:51 <rwbarton> yes, that sounds like a good idea.
08:30:58 <Kaidelong> there is no secret
08:30:59 <ski> user99 : list comprehensions are meant to resemble set/ZF comprehensions like `{x | x^2 > 3}' in math (set theory)
08:31:04 <Kaidelong> not worth worrying about honestly
08:31:08 <Kaidelong> if you must know
08:31:25 <Kaidelong> do x; y <- z; a;
08:31:26 <merijn> armlesshobo: The secret is that they're really kinda simple and there's just not that much to "get" about them
08:31:26 <Kaidelong> is the same as
08:31:39 <Kaidelong> x >> z >>= \y -> return a
08:31:48 <sipa> armlesshobo: once you realize what monads are, you'll probably say "oh, it's just that?"
08:32:01 <armlesshobo> that's what I want to get to
08:32:01 <armlesshobo> lol
08:32:04 <nand`> armlesshobo: best read 30 different tutorials
08:32:12 <Kaidelong> yeah you probably are more interested in IO specifically
08:32:13 <nand`> especially the one about burritos. I like that one
08:32:14 <merijn> I disagree
08:32:18 <merijn> Most tutorials are mostly awful
08:32:22 <armlesshobo> yes
08:32:22 <sipa> the only way to really understand monads, is by writing a monad tutorial
08:32:24 <nand`> merijn: I was making a joke :)
08:32:30 <Kaidelong> okay so IO works like this
08:32:37 <merijn> nand`: New people don't understand jokes like that
08:32:41 <Kaidelong> you can make these things of the IO type, they're like programs
08:33:01 <Kaidelong> they can call one another and return values
08:33:08 <merijn> armlesshobo: Mostly I think the best way is to study the Maybe, List and Either monads and the type signatures of the monad typeclass.
08:33:11 <Kaidelong> the one that you name "main" is the one that gets run
08:33:19 <nand`> merijn: I see. I hoped it was easy enough to sense the irony, seeing as that “reading 30 tutorials” is never a reasonable piece of advice for anything
08:33:24 <nand`> except perhaps doing research on tutorials
08:33:47 <Kaidelong> if you know Windows PowerShell
08:33:49 <merijn> Learn You a Haskell has a good explanation too, there's also a blog post called "You could have invented monads" which is also pretty good
08:33:50 <mcstar> nand`: everything is bigger these days, should have said 100 tutorials
08:33:51 <Kaidelong> it is very much like that
08:34:01 <sipa> armlesshobo: i think the best way is not to try to understand monads at all; just try to understand IO and its operations, and forget that they are in fact an instance of monads
08:34:07 <Kaidelong> it also can be thought of like the UNIX shell except the pipes are typed
08:34:09 <sipa> armlesshobo: the generalization will follow naturally
08:34:15 <Kaidelong> which is basically what powershell is
08:34:25 <merijn> jQuery is another nice monad example
08:34:42 <tac-tics> merijn: There should be a series. "You could have invented functors" "You could have invented natural transformations" "You could have invented pointed functors"
08:35:09 <Kaidelong> anyway IO is a monad for two reasons, related to the "output" the program gives
08:35:12 <mcstar> i could have invented monads with global variables
08:35:16 <mcstar> in c
08:35:19 <merijn> tac-tics: "You could invented nested universes and the calculus of constructions"
08:35:23 <nand`> the best way to understand monads is to find your own way to understand monads
08:35:25 <Kaidelong> the first reason is that if the output is itself another program, you can eliminate the nesting
08:35:34 <parcs`> "you could have invented haskell"
08:35:41 <sipa> can we write a TutorialMonad t ?
08:35:48 <Kaidelong> the second is that if you have a pure function from one type to another, you also have a function from a program that returns that type to a program that returns the other type
08:35:49 <nand`> “You could have invented naive set theory, but could you have discovered Russell's paradox?”
08:35:59 <tac-tics> merijn: You could have invented lazy evaluation (And since you're a lazy student, maybe you already have!)
08:35:59 <sipa> which is used to build and combine monad tutorials?
08:36:11 <Kaidelong> but you can see IO in all other kinds of ways
08:36:11 <tac-tics> sipa: lol
08:36:16 <parcs`> you could have invented a monad tutorial
08:36:18 <nand`> tac-tics: I think I'd rather lazily invent evaluation
08:36:28 <Eduard_Munteanu> newtype GrokT m a   :P
08:36:33 <tac-tics> @remember sipa can we write a TutorialMonad t ? which is used to build and combine monad tutorials?
08:36:33 <lambdabot> Nice!
08:36:56 <nand`> would have to be a TutorialMonadT; otherwise you can't intermingle it with side-effects and continuations
08:36:56 <Axman> what, no TutorialMonadT?
08:37:06 <merijn> tac-tics: Ha, most students have invented laziness years ago
08:37:28 <user99> mcstar global variables take up a lot of memory better to import as a separate library perhaps
08:37:35 <absence> dmwit: i'm having trouble getting it to compile. i have type MyReader = Reader SomeType, what would it look like with MonadReader?
08:37:39 <tac-tics> Now that I think about it, isn't that the point of RateMyProfessor.com. To be an implementation of "strictness analysis"?
08:37:41 <merijn> tac-tics: I challenge you to find one person that calculates 15479274+39173 in 0*(15479274+39173)
08:37:43 <mcstar> haskell is only different, because you cant escape the type system, but i dont think this monad thingy is a big deal
08:37:59 <mcstar> ppl feel they dont understand it, cause they actually think its more complicated than they are
08:38:06 <dmwit> absence: You wouldn't be able to use a type alias.
08:38:36 <dmwit> absence: But you would replace MyReader a with MonadReader SomeType m => m a
08:39:35 * ski . o O ( `type MyReader m = MonadReader SomeType m' )
08:39:48 <rwbarton> ssh
08:40:13 <tac-tics> Now that I think about it
08:40:28 <Eduard_Munteanu> Um, does that work? Class context synonyms?
08:40:28 <tac-tics> I should look up all the professors who's papers and theseses I've read through haskell on RateMyProfessor
08:40:42 <merijn> What's a good Template Haskell intro?
08:41:31 <absence> ski: if only :)
08:42:22 <mcstar> (Sum[(-1)^n/n, {n,1,Infinity}]+Log[2])*(543545555455*4665473324784264374), WWHD?
08:42:38 <Eduard_Munteanu> Dunno, I thought they might've added something like that, given ConstraintKinds and all that stuff :)
08:43:45 <Zippo> Would pasting more code in context help, or what else can I do?
08:44:34 <fmap> Zippo: did you import getBounds from Data.Array.MArray
08:44:35 <fmap> ?
08:44:55 <byorgey> Eduard_Munteanu: it does work now, with ConstraintKinds
08:45:38 <byorgey> absence: in Haskell, dreams really do come true
08:48:29 <Zippo> This was my import
08:48:30 <Zippo> import Data.Array.MArray (getBounds
08:49:10 <Zippo> This is my error: Could not deduce (Data.Array.Base.MArray StorableArray e ((,) (i, i))) from the context (Ix i, Storable e) arising from a use of `getBounds' at MD5.lhs
08:49:19 <zzing> Is there a means to write a program that can deal with tuples of n length at compile time, such as get the third element of an n element tuple. What I am asking is equivalent to certain templating features of C++. I know regular pattern matching will not suffice.
08:50:01 <nand`> What's a good formal introduction to modern set theory, possibly/preferably in connection with computer science?
08:50:04 <dmwit> Zippo: Wow, that's more exciting.
08:50:14 <nand`> (and Haskell, obviously)
08:50:22 <mm_freak_> nand`: set theory or type theory?
08:50:32 <dmwit> Zippo: You will have to use getBounds a bit differently than bounds was used.
08:50:38 <nand`> mm_freak_: set theory
08:50:43 <dmwit> Zippo: Since getBounds has monadic return type.
08:50:53 <absence> dmwit: do i have to rewrite all the type signatures then?
08:51:04 <dmwit> absence: Yes.
08:51:18 <dmwit> absence: Or rather, no: only the type signatures of the things you want to use. =)
08:51:37 <nand`> I've seen a lot of concepts, analogies, proofs or definitions based on Set theory while reading up on Category theory
08:51:46 <dmwit> absence: But don't blame me, you're the one that gave them a monomorphic type. =P
08:52:14 <dmwit> nand`: I have a good book, let me look at its title.
08:52:47 <nand`> I should note that I liked “Basic Category Theory for Computer Scientists” by Benjamin C. Pierce; something similar in spirit for set theory would be lovely
08:52:48 <absence> dmwit: yes, in a type alias :/
08:53:01 <fmap> zzing: You can write getThirdElement functions for all defined tuples.
08:53:14 <tgeeky_> nand`: I can send you like 20 set theory books
08:53:23 <tgeeky_> and you can choose for yourself
08:53:38 <dmwit> nand`: Hm, I used to have a book.
08:53:40 <zzing> fmap: doesn't that require knowing the number of elements?
08:53:45 <rwbarton> zzing: well there is template haskell
08:53:52 <zzing> rwbarton: I was afraid of that
08:53:52 <nand`> tgeeky_: preferably something easy to understand and follow along :)
08:53:57 <tac-tics> Why do Haskellers choose the absolutely worst variable names?
08:54:04 <zzing> Is there a decent simple intro to that?
08:54:05 <nand`> tac-tics: like?
08:54:11 <tac-tics> nand`: I totally lost my copy of Basic Catetgory Theory for Comp Scis :<
08:54:13 <dmwit> zzing: You can used 2-tuple encoded n-tuples.
08:54:15 <rwbarton> your question is not very well specified though in terms of what you actually want to do
08:54:22 <tac-tics> nand`: They abbreviate everything
08:54:23 <copumpkin> tac-tics: as opposed to partially losing it?
08:54:27 <dmwit> zzing: e.g. use (a,(b,(c,(d,())))) instead of (a,b,c,d)
08:54:32 <tgeeky_> nand`: one sec. switching computers
08:54:38 <dmwit> zzing: HList even makes this mildly more convenient than you might think.
08:54:42 <absence> dmwit: hm, keeping the type alias and running a new reader inside the ReaderT one should do the trick though :)
08:54:54 <tac-tics> copumpkin: Yes. There's a deterministic proof term showing I don't know where it is :<
08:54:59 <Eduard_Munteanu> Admittedly, you don't see such variable names in "good" C code.
08:55:02 <S11001001> tac-tics: probably that sticking ' at the end of a name is legal
08:55:03 <rwbarton> for example, why does a list (rather than a tuple) not meet your needs
08:55:17 <Eduard_Munteanu> Well, with a few exceptions like 'i' for loop counters.
08:55:29 <zzing> rwbarton: a list must have the same type, a tuple does not
08:55:53 <rwbarton> how can you know what the types of the components of the tuple are, if they may be different and you do not even know how many there are
08:55:55 <user99> length' xs = sum [1 | _ <- xs]  an example snippet from  lyah throws errors here with my ghc. (7.4.1)
08:56:07 <nand`> I prefer short functions with short variables over huge methods with VeryBigCamelCaseNamesThatBasicallyRequireTabCompletionToTypeSanely
08:56:32 <user99> leading V not valid
08:56:35 <tac-tics> Like, if you have a type in Haskell for representing "Type Terms", most haskellers will choose the name "TT" instead
08:56:43 <Taneb> Hello
08:56:46 <tac-tics> and you have to guess what each abbreciation stands for!
08:56:53 <tac-tics> It's obvious once you figure it out
08:57:06 <zzing> rwbarton: I want the compiler to do the work for me.
08:57:13 <rwbarton> ...
08:57:14 <tac-tics> but global names ought to be longer than 2 and 3 characters each
08:57:16 <user99> tac-tics, catch 22
08:57:16 <absence> mm_freak_: if i want to use a wire network from one monad in a wire from another monad, do i call stepwire from that wire or is there a better solution?
08:57:24 <zzing> The compiler will know what the sizes are when it is used
08:57:35 <nand`> user99: that code snippet works for me
08:57:42 <nand`> also 7.4.1
08:57:49 <user99> hrmmm
08:57:57 <gdoteof> user99: what is your error
08:58:00 <dmwit> I feel as though I'm being ignored.
08:58:27 <user99> <interactive>:19:11: parse error on input `='
08:58:44 * Eduard_Munteanu ponders mentioning HList :P
08:58:46 <gdoteof> user99: post that file
08:58:49 <nand`> do { _ <- dmwit }
08:58:49 <gdoteof> to hpaste
08:59:14 <rwbarton> you can't just enter a definition like "length' xs = sum [1 | _ <- xs]" into ghci directly
08:59:23 <user99> no file just a paste into the Prelude>
08:59:36 <user99> doing it wrong?
08:59:43 <nand`> user99: what rwbarton said; ghci has special syntax for this (that shouldn't be confused with regular Haskell)
08:59:52 <nand`> “let length' xs = sum [1 | _ <- xs ]”
08:59:55 <gdoteof> user99: put a `let` infront
09:00:03 <user99> let gotcha
09:00:11 <nand`> without the trailing ‘in’, will define it for all subsequent GHCi evaluations
09:00:33 <Bytter_> does anyone know if someone ever tried to capture the algorithmic complexity of a program in its type?
09:00:38 <zzing> dmwit: My attentions are divided.  What is HList, google does not find this.
09:00:38 <merijn> Can I rename functions in a module's export list?
09:00:39 <Zippo> If I'm reading this correctly import Data.Array.IArray (bounds,listArray,(!))
09:00:45 <zzing> The 2-tuple thing sounds interesting
09:00:52 <nand`> zzing: hoogle does :)
09:00:55 <nand`> @hoogle HList
09:00:55 <lambdabot> package HList
09:00:59 <dmwit> ?hackage HList
09:00:59 <nand`> http://www.haskell.org/hoogle/?hoogle=HList
09:00:59 <lambdabot> http://hackage.haskell.org/package/HList
09:01:04 <Zippo> bounds was declared as a Data.Array.IArray
09:01:12 <dmwit> Also it's the first hit on Google here.
09:01:14 <mm_freak_> absence: are you asking for Wire e (Kleisli m') a b -> Wire e (Kleisli m) a b?
09:01:41 <user99> http://pastebin.com/4t5Mi7rq
09:01:43 <mauke> The paste 4t5Mi7rq has been copied to http://hpaste.org/68964
09:01:43 <dmwit> Zippo: You are not reading it correctly. bounds is declared *in* Data.Array.IArray
09:01:46 <zzing> oh sorry, I don't mean google. I mean DuckduckGo :P
09:01:53 <nand`> user99: you mixed up the names
09:01:54 <nand`> ‘x’ and ‘xs’
09:01:59 <nand`> should both be the same
09:02:00 <dmwit> Zippo: StoreableArray is not an immutable array, however.
09:02:02 <merijn> zzing: In general you want to use Hoogle for haskell stuff anyway
09:02:53 <nand`> zzing: it's a bit down on the first page in DDG for me, marked “HackageDB: HList-0.2.3”
09:03:07 <dmwit> zzing: HList is also in the top page of results in DDG here.
09:03:08 <user99> k thx was just trying to figure out what it was supposed to do on myh own ;-( in other words muddying the water
09:03:09 <nand`> there's even a “haskell” suggestion at the right that pulls up a lot of relevant results :)
09:03:12 <Zippo> dmwit: so bounds is a public method of Data.Array.IArray?
09:03:20 <zzing> I am suffering through a miranda class dealing with database operators, so she is writing stuff like 'join_third_of_4_with_second_of_2, and expecting haskell to be able to do this better.
09:03:35 <user99> the let works though
09:03:45 <dmwit> Zippo: This is not OO. There are not methods, public or otherwise.
09:04:09 <dmwit> Zippo: Data.Array.IArray is a module -- a collection of functions, data types, and type classes.
09:04:21 <nand`> and type instances!
09:04:27 <dmwit> Zippo: bounds is a function defined in that module. It happens to be a typeclass method, but that's irrelevant here.
09:04:41 <absence> mm_freak_: i think so
09:04:54 <dmwit> Zippo: getBounds is a function defined in another module. It happens to be a typeclass method too, but that's irrelevant, too.
09:05:22 <dmwit> Zippo: bounds and getBounds have different types. bounds returns a value without side-effects. getBounds returns a value that may need to do some side-effects before answering.
09:05:43 <dmwit> Zippo: bounds can only be used on immutable arrays; getBounds can only be used on mutable arrays.
09:05:49 <dmwit> Zippo: StorableArray is a mutable array.
09:05:58 <merijn> Is there a way to export a function foo as "foosMoreDescriptiveName" in the module's export list?
09:06:04 <absence> mm_freak_: e.g. for using a wire network with a Reader monad from a wire in the IO monad
09:06:05 <Zippo> dmwit: OK, so when I say import Data.Array.IArray (bounds,listArray,(!)) I'm putting the bounds function in scope so I don't have to call it as Data.Array.IArray.bounds?
09:06:12 <dmwit> Zippo: The upshot of all this is that, when switching from bounds to getBounds, you'll need to change a bit of code: the import needs to change, and you need to use it differently.
09:06:25 <dmwit> Zippo: That's nearly right, yes.
09:06:34 <rwbarton> you are putting it in scope so that you can call it at all
09:06:49 <dmwit> Zippo: (It wouldn't even be available as Data.Array.IArray.bounds if you didn't import it. But you have the right idea about what import does now, I think.)
09:07:09 <matthiasgorgens1> I am trying to find the size of a file, but I want to handle the case if the file doesn't exist.  Is the following the right approach to avoid race conditions: Try to get the filestatus, and catch an exception if the file doesn't exist?
09:07:09 <nand`> Zippo: note that omitting the (bounds,...) stuff would pull in *all* the functions from that module
09:07:16 <nand`> Zippo: and you still wouldn't need Data.Array.IArray. to call them
09:07:23 <dmwit> matthiasgorgens1: That sounds good to me.
09:07:23 <nand`> Zippo: but adding the () imports *only* those functions
09:07:42 <Zippo> dmwit: OK, but I still don't understand why I have to change from bounds to getBounds in the first place.
09:08:04 <dmwit> matthiasgorgens1: (And it still surprises me sometimes that some people think checking if the file exists first and then getting its status is not a race condition.)
09:08:36 <mm_freak_> absence: there is no generic way to do it…  this requires a natural transformation from m' to m, which is always ad hoc
09:08:38 <dmwit> Zippo: I suppose the interface to StorableArray changed some time in the years between GHC 6.2 and GHC 6.10.
09:09:36 <mm_freak_> absence: my suggestion is to just go with ReaderT
09:09:52 <fmap> Zippo: StorableArray is not an instance of typeclass providing bounds (now)
09:10:19 <dmwit> Zippo: (I would point out that GHC 6.10 is now also several years old.)
09:11:03 <Zippo> dmwit: It's what macports installed by default.
09:11:23 <matthiasgorgens1> dmwit: if you lock the file, than checking first might work.
09:11:49 <rwbarton> depending on what you plan to do after checking the file's size, you may have other race conditions to worry about
09:11:50 <matthiasgorgens1> dmwit: OK.  so is there a way to catch only the `file doesn't exist' exception?  I don't want to mask other errors.
09:12:01 <dmwit> Oh, yes, Mac. Every once in a while I wish I believed in a deity so I could thank them I'm not using one.
09:12:22 <matthiasgorgens1> dmwit: mac's don't seem to bad, if you put a sensible operating system on them.
09:12:39 <dmwit> heh, but then why pay for the OS in the first place? Just get cheap hardware. =)
09:12:48 <matthiasgorgens1> I thought you paid for looking cool.
09:12:50 <absence> mm_freak_: is it really a good idea to put a lot of code that shouldn't use IO in an IO monad though?
09:12:59 <dmwit> Anyway, it should be possible to only catch DNE exceptions, or at least rethrow any exception that isn't a DNE.
09:13:02 <matthiasgorgens1> It's like burning money to impress people.
09:13:24 <matthiasgorgens1> dmwit: DNE?
09:13:29 <matthiasgorgens1> oh, does not exist?
09:13:30 <dmwit> sorry, does-not-exist
09:13:55 <absence> mm_freak_: (i assume you meant ReaderT r IO)
09:15:21 <dmwit> I don't know how to do it precisely, but a bit of documentation diving/experimentation ought to set you aright.
09:15:40 <dmwit> ?hoogle catch
09:15:40 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
09:15:40 <lambdabot> System.IO.Error catch :: IO a -> (IOError -> IO a) -> IO a
09:15:40 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
09:16:16 <matthiasgorgens1> dmwit: thanks.
09:25:17 <hpaste> ClaudiusMaximus pasted “handling doesNotExist” at http://hpaste.org/68965
09:25:36 <matthiasgorgens1> ClaudiusMaximus: thanks!
09:27:26 <mm_freak_> absence: i did and you have a point there…  this is a tradeoff between safety and convenience
09:27:45 <mm_freak_> of course you can't arbitrarily lift IO actions to ReaderT, so if you want to make mistakes, you have to make them deliberately =)
09:30:26 <denezt> Hellos
09:30:52 <denezt> ne body heres
09:31:12 <denezt> gess nt
09:31:22 <denezt> bies
09:35:47 <dmwit> ?pl f `ap` return x
09:35:48 <lambdabot> f `ap` return x
09:35:52 <dmwit> bummer
09:37:44 <jfischoff> what? fixed points are awesome ;)
09:38:19 <dmwit> ?hoogle Applicative f => f (a -> b) -> a -> f b
09:38:20 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
09:38:20 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
09:38:20 <lambdabot> Control.Applicative liftA :: Applicative f => (a -> b) -> f a -> f b
09:39:11 <nand`> ?pl \f x -> f `ap` return x
09:39:11 <lambdabot> (. return) . ap
09:39:31 <dmwit> I asked the question I meant to ask.
09:39:41 <bitonic> dmwit: `f' and `x' are free vars there, there are no points
09:39:48 <dmwit> I know.
09:39:50 <bitonic> ah.
09:40:05 <dmwit> But ?pl does more than just remove points.
09:40:07 <bitonic> so... why would you hask pl to remove non-existent points?
09:40:09 <bitonic> ah.
09:40:16 <nand`> dmwit: for example?
09:40:17 <dmwit> ?pl id for example
09:40:17 <bitonic> like what?
09:40:18 <lambdabot> for example
09:40:31 <bitonic> oh well. I didn't know
09:40:41 <bitonic> so is there a set of laws it can use?
09:40:47 <nand`> ?pl x >>= return
09:40:47 <lambdabot> x
09:40:56 <dmwit> bitonic: right
09:41:30 <dmwit> In fact, I'm fairly sure the way it works is by first expanding everything into some horrible combinator calculus and then running its simplifier on the result.
09:41:43 <bitonic> brrrr.
09:42:00 * hackagebot hfsevents 0.1 - File/folder watching for OS X  http://hackage.haskell.org/package/hfsevents-0.1 (LuiteStegeman)
09:42:11 <dmwit> luite++
09:42:46 <nand`> ?pl \f -> concat . map f
09:42:47 <lambdabot> (=<<)
09:42:53 <tgeeky_> now all we need is to combine (inotify, hfsevents, and ______ for Windows)
09:42:57 <nand`> was expecting “concatMap”
09:42:59 <nand`> but I guess that works
09:43:06 <luite> tgeeky_: someone's working on that for gsco
09:43:08 <luite> gsoc
09:43:13 <tgeeky_> luite: cool!
09:43:16 <rwbarton> ?pl \x -> x + 0
09:43:16 <lambdabot> id
09:43:28 <tgeeky_> luite: the combination of the three, or just the windows part?
09:43:55 <syntaxfree> was expecting the spanish inquistion
09:44:02 <nand`> tgeeky_: did you want to send me some book recommendations?
09:44:16 <tgeeky_> nand`: not yet. I got distracted by phone calls.
09:44:23 <tgeeky_> nand`: and I was going to send you *books* not recommendatins
09:44:31 <tgeeky_> well, e-books at least
09:44:34 <nand`> tgeeky_: in digital form?
09:44:36 <nand`> ah
09:45:02 <nand`> can't read e-books in the train :)
09:45:08 <luite> tgeeky_: the combination
09:45:21 <tgeeky_> nand`: better than not having free e-books
09:45:23 <luite> tgeeky_: there are already some bindings for the windws one on hackage
09:45:37 <nand`> tgeeky_: indeed; worst comes to worst I can still print them out
09:46:12 <luite> mac fsevents was still missing, there was the lower level kqueue interface, but that is too inefficient for watching large folders (you need a file descriptor per file you watch)
09:47:46 <dmwit> Linux doesn't have anything good for watching large (deep) folders. =/
09:48:40 <tgeeky_> @tell tgeeky to gather up and send set theory books to nand`
09:48:40 <lambdabot> Consider it noted.
09:48:59 <tgeeky_> @tell nand` to send "tgeeky" your email address
09:49:00 <lambdabot> Consider it noted.
09:49:05 <nand`> .
09:49:05 <lambdabot> nand`: You have 1 new message. '/msg lambdabot @messages' to read it.
09:49:17 <arcatan> what could it be!
09:49:18 * shapr boings cheerfully
09:49:25 * arcatan boings
09:49:32 <shapr> dmwit: inotify?
09:49:40 <shapr> arcatan: heippa hei arcatan!
09:49:57 * shapr plays with Aeson for json purposes.
09:50:00 <dmwit> shapr: inotify still needs a watch per file (some files may be directories)
09:50:03 <shapr> @hackage aeson
09:50:03 <lambdabot> http://hackage.haskell.org/package/aeson
09:50:12 <nand`> @tell tgeeky_ to send them to nand@lavabit.com, but not to tell anybody my e-mail address!
09:50:12 <lambdabot> Consider it noted.
09:50:14 <shapr> dmwit: Oh, I thought it could watch a subtree.
09:50:23 * shapr sends nand` an email...
09:50:30 <pnathan> So I am trying to get a ghc7 on ppc64. Does anyone have any recommendations?
09:50:57 <dmwit> Nope, sadly it doesn't.
09:51:11 <shapr> pnathan: Send me a copy when you get it working, I bet it'll work on my ps3 then!
09:51:43 <pnathan> Lol! This is company work... :/ cant send it outside
09:51:47 <solirc> Is there any scientific evidence, that using dependent types to ensure that a program is semantically correct?
09:52:01 <solirc> Say a paper that I could cite?
09:52:06 <shapr> pnathan: Ah, but your ppc64 binary of ghc7 should be fine to send outside of the company.
09:53:01 <pnathan> :( no. So I guess its not commonly available?
09:54:15 <solirc> Oh, I left out a half a sentence above.
09:54:56 <solirc> It should be "that using dependent types to ensure that a program is semantically correct is a lot of work"
09:55:07 <shapr> pnathan: A quick google search implies it's available as an rpm
09:55:41 <shapr> pnathan: http://gentoohaskell.wordpress.com/2012/03/11/ghc-7-4-in-the-gentoo-tree/
09:56:10 <shapr> pnathan: But if you're on a ps3 or other cell hardware, I doubt that will use the SPEs
09:57:09 <pnathan> Its actually a kooky IBM server config.
09:57:51 <Saizan> solirc: maybe the CompCert project has something about how much work it was
09:58:56 <dmwit> solirc: Oh, goodness. Cite any of the certified compiler papers.
09:59:13 <dmwit> Or the work on secure operating systems and such.
10:00:06 <dmwit> ...and I now see Saizan beat me to the punch on that anyway.
10:00:13 <NemesisD> hi all. was recently reading something on the yesod blog and they mentioned to run the command "strip" on the executable. what does this achieve?
10:00:39 <dmwit> http://linux.about.com/library/cmd/blcmdl1_strip.htm
10:00:42 <dmwit> also "man strip"
10:00:49 <bitonic> NemesisD: man strip?
10:00:53 <bitonic> damnit.
10:01:14 <NemesisD> i know about man i just don't know what "removing symbols and sections" accomplishes
10:01:35 <dmwit> Would it help if it said "debugging symbols" instead of "symbols"?
10:01:51 <NemesisD> a bit. is that for performance?
10:02:07 <tgeeky_> NemesisD: mostly executable size
10:02:26 <NemesisD> tgeeky_: that's probably handy, my haskell bins are huge
10:02:30 <bscarlet> NemesisD: more for binary size, or sometimes to avoid leaking too much implementation information
10:03:01 <dmwit> Dynamic linking will help much more than strip if you care about executable size.
10:03:32 <NemesisD> strip brought one of my executables from 21M to 13M
10:04:03 <dmwit> Dynamic linking will take it from 21M to 1M.
10:04:22 <NemesisD> dmwit: i hit my head on this issue every time but one of the big problems that I *think* has to do with linking is if I want to compile for my production env (different distro of linux) i end up having to go set up a VM to compile it for the target environment
10:04:52 <NemesisD> i presume i'm using static linking but i guess it still depends on system libraries and that's why i can't just compile on my native distro
10:05:12 <bitonic> NemesisD: GHC links everything statically by default. But I'd say that's a good idea most of the times.
10:05:18 <dmwit> Static linking includes the libraries in your executable.
10:05:32 <dmwit> Which is supposed to mean that you don't need to make a VM.
10:05:49 <dmwit> But if you're making a VM anyway, then you should certainly use dynamic linking.
10:06:03 <bitonic> well, every haskell library, it doesn't statically link stuff like gmp and libc, but iirc linking libc statically is hard.
10:06:10 <NemesisD> dmwit: i'd love to figure out a way to not have to use a VM. i don't have the hard drive space on my dev machine to host more VMs
10:06:14 <dmwit> Oh, yes, that's a good point.
10:06:28 <NemesisD> shoot i wonder if thats my stumbling point
10:07:06 <NemesisD> that sounds like a dealbreaker
10:20:15 <solirc> Saizan, dmwit: I'll look into it.
10:47:41 <shapr> Is there an introduction to aeson somewhere?
10:49:12 <shapr> grr, github css is too light colored for me..
10:49:21 <luite> hm i don't know one, but i have some experience with it
10:49:43 <shapr> luite: I want to write a json clock that gets time from a scotty server and displays it in a webpage.
10:49:45 <luite> perhaps if you say what you want to send as json i can give a hint on ho to do that
10:50:18 <shapr> So, Haskell CalendarTime or UTCTime? converted to json, and then displayed in an element or something.
10:50:27 <luite> shapr: do you want to send the separate parts (minuts, hours etc) as separate json fields, or as a singlefield?
10:50:40 <shapr> For the first step, a singlefield seems easiest.
10:50:57 <shapr> I know how to do json and ajax stuff in Python, but not in Haskell.
10:51:04 <shapr> So, I'm trying to port my cluefulness over...
10:51:16 <hpaste> shashwat pasted “Test errors with HUnit” at http://hpaste.org/68969
10:51:33 <luite> multiple fields are also fairly easy, say you have minutes :: Int, hours :: Int, seconds :: Int, then you get your json object with: object ["minutes" .= minutes, "hours" .= hours, "seconds" .= seconds]
10:51:35 <byorgey> shapr: just serialize your cluefulness as a json message
10:51:42 <shapr> byorgey: hah, I wish :-)
10:52:26 <hpaste> shashwat annotated “Test errors with HUnit” with “Test errors with HUnit (annotation)” at http://hpaste.org/68969#a68971
10:52:32 <luite> shapr: enable the extension OverloadedStrings for this to work
10:53:45 <luite> shapr: want a full source code file as an example?
10:53:49 <shapr> Sure!
10:53:51 <byorgey> shashwat: your headTest3 does not type check, since it expects the second and third arguments to have the same type
10:54:01 <luite> shapr: k one moment :)
10:54:23 <byorgey> shashwat: but "empty list" is a String, and  head' []  has type... well, actually, I guess it *could* have type String, so never mind, it does type check
10:54:40 <shapr> Speaking of online typechecking: Has everyone seen http://haskellonline.org/ ?
10:54:45 <shashwat> byorgey: How can I test this then ?
10:54:59 <byorgey> but head' []  does not return the string "empty list", it crashes and prints "error : empty list", which is quite different
10:55:08 <shashwat> shapr: never heard of it.  Let me check.
10:55:25 <byorgey> shashwat: use assertFailure  instead of  assertEqual
10:56:30 <shashwat> byorgey: let me look at it.  Thanks.
10:57:04 <byorgey> shashwat: note that there is no way to test the actual content of the error message, at least not if you are just using a call to 'error'
10:57:16 <byorgey> any call to error is basically the same as any other
10:57:21 <strager> shashwat: It's not trivial to assert _|_.
10:58:21 <shashwat> byorgey: In prelude source head is written exactly in similar fashion.  Shall I change it to create some exception with a message and catch it ? :|
10:58:51 <byorgey> shashwat: why?
10:58:52 <strager> shashwat: You can't 'create some exception' without IO (or some other exception-y monad)
10:59:21 <shashwat> strager: I see.  I didn't knew that.
10:59:48 <strager> You can do something like: catch (head' [] `seq` True) (const False)
10:59:53 <strager> within IO
11:00:00 <strager> I think that will work.  Try it in the console.
11:00:17 <shachaf> strager: You can do it but, uh, don't?
11:01:08 <younder> IO is fine
11:01:29 <strager> shachaf: Well he's unit testing so I assume he wants to do something like that
11:01:41 <shachaf> Unit testing for _|_? :-(
11:01:51 <shashwat> strager: What is 'within IO'.  GHCi have IO by default if I understood correctly ?
11:01:57 <byorgey> changing 'head' to do something more sophisticated in the empty list case = putting lipstick on a pig.
11:02:05 <strager> shashwat: Yeah =[
11:02:18 <strager> er, shachaf: Yes;  shashwat: Correct.
11:02:19 <shachaf> shashwat: Uh-oh. You should probably read an introduction to IO in Haskell before continuing.
11:02:40 <shachaf> @google introduction to io in haskell
11:02:41 <byorgey> no! don't!
11:02:42 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
11:02:42 <lambdabot> Title: Introduction to IO - HaskellWiki
11:02:44 <byorgey> no IO needed.
11:02:52 <younder> rofl
11:02:56 <shachaf> Er, before continuing with anything that uses IO.
11:03:03 <shachaf> If you can get away without using IO, that's much better.
11:03:04 <shashwat> byorgey: I started with simple case.  I was planning to implement some haskell functions and unit-test it.  My first example failed me.
11:03:16 <strager> byorgey: How can you check for _|_ without IO?
11:03:24 <byorgey> shashwat: using assertFailure
11:03:28 <shachaf> strager: You can't check for _|_, period.
11:03:29 <byorgey> like I already said
11:03:34 <shachaf> You can check for undefined but that's the devil.
11:03:37 <strager> shachaf: Well, not 100% but yes =]
11:04:15 <byorgey> sigh. There's no need to be so pedantic with beginners.  Of course you can't check for infinite loops, but that's not what shashwat is dealing with here.
11:04:16 <younder> Well I love your attitude
11:04:41 <shachaf> byorgey: I admit that I joined mid-conversation.
11:04:49 <younder> But we need a bit of direction here
11:04:57 <shachaf> byorgey: But checking for a particular _|_ seems like a bad idea to me, in general.
11:05:24 <byorgey> shachaf: shashwat is just learning how to write unit tests, including one that tests that 'head []' crashes.  Is that so bad?
11:05:47 <younder> yes, that is devastating
11:05:51 <byorgey> hehe
11:05:54 <shashwat> :'(
11:06:16 <hpaste> luite pasted “aeson demo for shapr” at http://hpaste.org/68972
11:06:26 <shapr> luite: w00t!
11:06:57 <younder> That shows that your system is totallyy fucked
11:07:10 <nand`> solution: rewrite head to not crash
11:07:15 <byorgey> shashwat: in general it's good design to write only functions which never crash.  but since you were looking at 'head' as an example you can be forgiven for thinking it's normal =)
11:07:22 <luite> shapr: that's basically how you construct json objects with aeson
11:07:22 <younder> You need to fix that
11:07:44 <byorgey> shashwat: but many people (including me) think that 'head' is a big mistake and should never have been included in the standard library
11:07:52 * nand` wonders how catch and unsafePerfomIO play together
11:08:04 <luite> shapr: now if you want to serialize UTCTime to JSON, then you probably don't want an object but a JSON string
11:08:18 <nand`> is it possible to write “crashes :: a -> Bool” ?
11:08:29 <shashwat> byorgey: I see.  Thanks for the tip. :)
11:08:29 <nand`> (using unsafe trickery)
11:08:35 <byorgey> nand`: yes, it is
11:08:41 <byorgey> @package spoon
11:08:41 <lambdabot> http://hackage.haskell.org/package/spoon
11:08:46 <younder> JSON is fine
11:08:51 <nand`> oh right, forgot about that
11:09:00 <byorgey> shashwat: instead there should be   head :: [a] -> Maybe a
11:09:15 <c_wraith> doesn't spoon break monotonicity, which is a problem for... something... ?
11:09:21 <younder> THATS the problem
11:09:32 <shachaf> c_wraith: Yes, spoon is a problem in the general case.
11:09:34 <byorgey> c_wraith: what do you mean by monotonicity?
11:09:37 <nand`> head :: MonadError e m => [a] -> m a
11:09:39 * nand` hides
11:09:51 <shachaf> But in the specific case spoon can be reasonable.
11:09:54 <c_wraith> byorgey: of definedness..  it can convert a less-defined value to a more-defined value
11:10:10 <byorgey> c_wraith: oh, I see.  Yes, probably.
11:10:23 <shashwat> byorgey: We can't type declare in ghci ?
11:10:25 <younder> squishy
11:10:33 <c_wraith> I'm not sure about the theory which declares that to be a problem, but I'm told it exists.
11:10:33 <luite> shapr: aeson already provides a ToJSON {(and FromJSON) instance for UTCTime, so if you have t :: UTCTime, you can do something like object ["time" .= t]
11:10:37 <byorgey> shashwat: you can in ghci 7.4.  not in earlier versions.
11:10:49 <luite> shapr: and it will encode it to some standard format time that you can parse in javascript
11:10:50 <shapr> luite: Ok, I'll try that.
11:10:57 <younder> Bee more concrete
11:14:20 <shapr> luite: Aeson's Value type explains many things.
11:14:38 <strager> :q
11:14:42 <strager> wrong window.
11:14:47 <younder> This is all totally fucked I am going to retire
11:15:01 <shapr> younder: Are you sure you have the right window?
11:15:38 <luite> shapr: yeah that's the main type, the ToJSON and FromJSON classes are there to convert haskell values to aeson Value, but you don't need to use them, if you want you can just build the Value directly
11:15:54 <younder> noj, I am not sure of anything anymore
11:16:32 <younder> All I feel is just a massive total confusion
11:16:41 <shapr> younder: Are you having a Haskell problem?
11:17:22 <younder> I am having a identity problem
11:17:32 <shapr> This sounds like a discussion for #haskell-blah
11:18:06 <younder> So huge it absolves your petty issues
11:18:14 <newsham> > fix id
11:18:18 <lambdabot>   mueval-core: Time limit exceeded
11:18:26 <shapr> younder: dude, move it to #haskell-blah
11:18:27 <newsham> guh, is that a fix problem or an identity problem?
11:19:06 <mcstar> newsham: you just need a faster implementation to avoid timelimit
11:19:57 <shapr> luite: I had a vague idea that aeson did more than marshal to json, am I wrong?
11:27:09 <luite> where did shapr go!
11:29:15 <hpaste> uniquenick pasted “broken parser” at http://hpaste.org/68973
11:29:47 <uniquenick> anyone with attoparsec experience able to help me figure out what's wrong with that parser?
11:30:27 <uniquenick> *Main> parse parser "{a,b,c}"
11:30:27 <uniquenick> Fail "a,b,c}" ["}"] "Failed reading: satisfyWith"
11:33:50 <mcstar> can someone explain me this parsing madness? i mean why is this good/important (im not a real software developer, but computational scientist)
11:34:04 <mcstar> i see this everywhere, there are tutorials, examples, chapters on this...
11:34:07 <c_wraith> which parsing madness?
11:34:10 <c_wraith> oh, that one.
11:34:13 <c_wraith> parsing is *hard*
11:34:42 <mcstar> hard to do it right/flexible?
11:34:42 <c_wraith> As an accessible example, have you ever seen what passes for html on the wild wild web?
11:34:56 <S11001001> mcstar: parsing is discovering structure of unstructured data
11:35:06 <c_wraith> The amount of errors (as compared to what the spec says is correct) is amazing.
11:35:21 <c_wraith> yet browsers have to deal with it, and handle it in some kind of sane way
11:35:43 <mcstar> so basically, the problem is that data is serialized, and it doesnt mean a thing wo parsing it?
11:35:48 <c_wraith> yep
11:35:49 <mcstar> and there are a shitload of formats..
11:36:06 <c_wraith> and there are a lot of things that write stuff that's vaguely against the rules of the formats involved
11:36:23 <c_wraith> so parsers have to be smart enough to deal with that stupidity
11:36:25 <mcstar> c_wraith: but look at lisp, code/data is stored in its natural form: a tree
11:36:40 <c_wraith> mcstar: lisp is allowed to say "this is ill-formed" and reject it
11:36:55 <strager> uniquenick: I've only used Parsec, not attoparsec, but maybe you need to put a 'try' around the use of quotedColumns?
11:36:59 <c_wraith> mcstar: many applications have to say "this is ill-formed, but I'll do the best I can"
11:37:11 <mcstar> c_wraith: isnt that dangerous?
11:37:25 <c_wraith> mcstar: if you do it wrong.  This is part of why parsing is *hard*
11:37:49 <Saizan> also, there are lots of extra features you might ask of your parser, but even getting good error messages is not trivial
11:38:14 <mcstar> i thought the main point of parsec was its composability, so i take it from your answers, it also doest it *right*
11:38:25 <c_wraith> well.  parsec gives you tools to do it right.
11:38:30 <mcstar> wait no, it cant do it right, sionce you supply the meaning
11:38:31 <c_wraith> That's..  not exactly the same thing
11:38:34 <c_wraith> exactly
11:39:26 <mcstar> what else is to parse except html?
11:39:31 <mcstar> is there *
11:39:56 <mcstar> just some popular examples, pls
11:40:06 <c_wraith> mcstar: there's also the linguistics/computational connection - parsing various grammars corresponds to different computational models, which makes it an interesting research question.
11:40:08 <mauke> http, css, javascript
11:40:15 <mauke> irc, jpg, png, gif
11:40:22 <osfameron> haskell
11:40:28 <c_wraith> config files
11:40:35 <uniquenick> a simple array format :(
11:40:41 <c_wraith> csv files
11:40:46 <osfameron> weather forecasts, xml, json
11:40:49 <mauke> json, smtp, pop3
11:40:53 <mauke> sql
11:41:15 <mcstar> but there are tools already to deal with lot of these examples
11:41:40 <uniquenick> strager: same thing, I think attoparsec always backtracks on failure so you don't need to wrap much in trys
11:41:41 <mauke> and?
11:41:54 <c_wraith> it's not like new data formats aren't being invented constantly.
11:42:32 <mcstar> is it harder to do, when the data is not on disk/all at once?
11:43:03 <c_wraith> not with modern tools.
11:43:15 <c_wraith> Though producing incremental results can be challenging, even with them
11:44:16 <c_wraith> and sometimes, that's important.
11:44:19 <mcstar> mauke: take the picture formats, why would you want to parse them? just copy a certain number of bytes into a standardized struct, and you have all the info you need
11:44:30 <mauke> mcstar: no, you don't
11:44:34 <c_wraith> mcstar: you clearly have no clue what's in modern image formats :)
11:44:41 <mauke> s/modern //
11:44:44 <mcstar> i didnt say i have a clue
11:44:45 <hiptobecubic> BOP
11:45:04 <mcstar> i wrote bitmaps and pgm images so far
11:45:06 <c_wraith> they have variable-length headers, metadata segments, etc, etc
11:45:36 <c_wraith> you have to parse the format to understand the meaning of the bytes.
11:45:36 <mcstar> c_wraith: i just didnt think it was that complicated...
11:45:38 <mauke> pgm already has variable headers
11:47:23 <mcstar> sorry, ppm
11:47:36 <c_wraith> heck, I've been playing with mp3 decoding recently.  There's hilarity in that.  neither id3 nor id3v2 are part of the mp3 spec.
11:47:40 <mcstar> simple ascii format :)
11:47:51 <mauke> http://netpbm.sourceforge.net/doc//pgm.html
11:47:53 <mauke> that's not ascii
11:47:54 <c_wraith> they're just extra data tacked on to the file
11:48:00 <mcstar> mauke: ppm is
11:48:04 <mauke> mcstar: no
11:48:08 <mcstar> yes
11:48:14 <mauke> mcstar: http://netpbm.sourceforge.net/doc//ppm.html
11:48:20 <armlesshobo> so, fmap is only for types that derive the Functor class
11:48:35 <mauke> "Each sample is represented in pure binary by either 1 or 2 bytes. If the Maxval is less than 256, it is 1 byte. Otherwise, it is 2 bytes. The most significant byte is first."
11:48:43 <mcstar> http://netpbm.sourceforge.net/doc//ppm.html
11:49:11 <Cale> armlesshobo: Well, you can write the instance by hand too.
11:49:20 <geekosaur> mauke: there are both binary and text forms of all the netpbm formats
11:49:32 <armlesshobo> Cale: like map, but for more than just lists
11:49:46 <Cale> right
11:49:49 <armlesshobo> which is itself from Functor
11:49:53 <mauke> geekosaur: yes, but that's "plain PPM" and explicitly not the default
11:49:59 <Cale> Also, like composition, but for more than just functions :)
11:50:23 <mcstar> default?
11:50:25 <Cale> The instance of fmap for (->) e has type  (a -> b) -> (e -> a) -> (e -> b)
11:51:08 <Cale> which is exactly the same type as composition
11:51:28 <armlesshobo> Cale: that's what makes it a functor
11:51:36 <Cale> (and in fact, that's what the instance does:  fmap f g = f . g  or  fmap f g x = f (g x))
11:51:37 <armlesshobo> it's part of the definition
11:51:37 <Cale> yep
11:53:39 <mcstar> so, can this parsec thing parse binary formats?
11:53:50 <Cale> For IO actions, you have  fmap :: (a -> b) -> IO a -> IO b, which acts analogously with composition, producing an action which runs the given action of type IO a, and applies the function a -> b to its result.
11:54:02 <Cale> mcstar: yes, you can use parsec with ByteStrings
11:54:36 <Cale> mcstar: Though attoparsec might be more suitable for human-unreadable formats where you want more performance.
11:54:46 <mcstar> i just have a feeling, that binary formats look different than human readable ones(for efficiency for example)
11:55:12 <geekosaur> mcstar, parsec does not care what it looks like
11:55:31 <Cale> also see the binary and cereal packages
11:55:53 <mcstar> ok, but do binary formats tend to have the same structure as human readable ones? thats what im trying to get at i think
11:56:25 <newsham> human readable protocols tend to have a more complex grammar
11:56:42 <mcstar> aham
11:56:43 <newsham> binary protocols usually have a few complex fixed-sized data types glued together
11:56:43 <mauke> binary formats tend to rely more on byte offsets
11:57:22 <newsham> the Binary package is great for writing data marshallers for those
11:57:33 <mcstar> and in human readable ones, whitespace usually doesnt matter i guess
11:58:10 <mcstar> well, thanks for the clarifications
11:59:17 <xivix> Can anyone explain the rationale behind the argument order of Parsec's sepBy and endBy?
11:59:21 <xivix> They seem backwards.
11:59:35 <newsham> ?type sepBy
11:59:36 <lambdabot> Not in scope: `sepBy'
11:59:51 <xivix> It's `sepBy parser separator`, rather than `sepBy separator parser`
12:00:47 <newsham> seems odd to me :)
12:00:48 <xivix> ?type Text.ParserCombinators.Parsec.sepBy
12:00:49 <lambdabot> forall tok st a sep. Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> Text.ParserCombinators.Parsec.Prim.GenParser tok st sep -> Text.ParserCombinators.Parsec.Prim.GenParser tok st [a]
12:00:52 <ski>   parser `sepBy` separator
12:01:26 <newsham> ahh infix
12:01:26 <xivix> ski: Thanks, that makes more sense. Also why it's so abbreviated, it works better as an infix then.
12:02:03 <xivix> ski: Much appreciated.
12:03:30 <S11001001> armlesshobo: just don't fall into the "typeclasses are like OO interfaces" trap :)
12:03:48 <armlesshobo> S11001001: lol. it's obvious that they're not lol
12:03:50 <andares> eww. they're like algebraic structures really.
12:04:07 <armlesshobo> S11001001: my mind tried going there earlier when I was first introduced to them :P
12:04:36 * armlesshobo had never heard of algebraic structures until learning haskell
12:04:59 <mcstar> is that correct to say, that parsing is THE solution for security between untrusted peers? i mean, if everyone trusted each other, you could just send data, and load into memory wo worrying about anything
12:05:27 <mauke> no, you couldn't
12:05:50 <mcstar> well, yeah different architectures..
12:05:53 <earthy> adresses of references would probably be wrong
12:05:53 <mcstar> but conceptually
12:05:56 <armlesshobo> wolf in sheeps clothing
12:06:14 <earthy> not even conceptually
12:06:45 <earthy> there's a difference between an efficient transfer format and one efficient in use
12:06:47 <mcstar> reference would be offset from a base pointer(from 0 in this case)
12:07:08 <mcstar> k
12:07:23 <mcstar> mauke: what about the first part of m question?
12:07:28 <mcstar> my*
12:07:42 <earthy> parsing does not imply security
12:08:17 <Flink> After I updated Linux, when I try to launch ghci in terminal I get the error "/usr/local/lib/ghc-7.2.2/ghc: error while loading shared libraries: libgmp.so.3: cannot open shared object file: No such file or directory"
12:08:17 <Flink> What should I do to fix this? thanks
12:08:18 <mcstar> im not talking about security in the cryptographic sense
12:09:29 <armlesshobo> Flink: install libgmp
12:09:46 <mauke> Flink: recompile ghc
12:10:47 <Flink> armlesshobo, what destination do I use for instal libgmp? And mauke, how do I do that?
12:10:55 <mcstar> it seems necessary to me, to actually interpret the data that is received, before you execute it
12:11:18 <armlesshobo> Flink: which distro do you use?
12:11:32 <Flink> Ubuntu
12:11:33 <mcstar> Flink: its possible that those 2 things werent updated at once
12:12:08 <armlesshobo> Flink: sudo apt-get install libgmp-dev libgmp3-dev libgmp3c2
12:12:28 <armlesshobo> Flink: that should handle everything for you
12:13:15 <Flink> Alright armlesshobo, things are working now, thank you
12:13:34 <armlesshobo> Flink: you're welcome :)
12:14:47 <shapr> luite: I'm back!
12:14:52 <luite> you're back!
12:15:04 <mcstar> ill be bach
12:16:40 <luite> shapr: it's mostly that, converting to/from haskell types. there is some "magic" going on for deriving the ToJSON and FromJSON instances automatically through Generic or Template Haskell, but as lng as you don't have dozens of types to serialize (or if you just want more control over the field names in the json) you can just define then manually
12:17:00 <shapr> sounds good
12:17:58 <luite> shapr: fromjson is slightly more complicated because of the Parser and Result types, for things that can go wrong, i can add some basic examples for those as well
12:18:10 * shapr looks
12:18:45 <shapr> Hah, aeson includes DotNetTime
12:19:21 <luite> if you've already used attoparsec and parsec before, and are familiar with applicative parsers then it's probably clear how to use them
12:19:43 <shapr> I am familiar with parsec, it's one of my favorites.
12:21:47 <`Jake`> usually, in ghc, the special case is handled before the usual case in pattern matching. for example in GHC.Base: the helper funtion go of the funtion foldr starts with "go [] = z" and not with "go (y:ys) = ...") Wouldn't it be faster if you did it the other way round, because one less patern would need to be checked before the usual case is handled?
12:23:38 <`Jake`> and I guess usual case is not the proper term
12:23:57 <sclv> as far as i recall, pattern matching gets compiled into something much more clever than just a linear set of tests.
12:24:19 <`Jake`> sclv: ok, thanks, that would make sense
12:24:20 <sclv> something like that would produce a branch on the construtor
12:24:27 <`Jake`> ok
12:24:38 <peddie> `Jake`: don't you have to check at every call whether it's [] or (y:ys)?
12:25:15 <`Jake`> peddie: no, if it's (y:ys), then you wouldn't have to check if it's [], because you know that it isn't
12:25:30 <peddie> how do you know it's (y:ys)?
12:25:52 * ski . o O ( s/(y:ys)/y:ys/ )
12:26:06 <`Jake`> well, yeah
12:26:16 <peddie> ski: ok thanks
12:26:17 <shachaf> ski: s/\(/\\(/ s/\)/\\)/
12:26:29 <shachaf> Hmm, my regexp is broken too. :-(
12:26:31 <Flink> How do you display a message in terminal that displays after you type in something using readLn? As in, typing "start" which will then cause text to display
12:26:42 <Flink> Or just having text display when the code is loaded into ghci
12:26:49 <shachaf> Flink: You probably want getLine, not readLn, for reading strings.
12:27:08 <`Jake`> peddie: if you pattern match against y:ys first, but I just learned that that is not exactly how it is compiled
12:27:08 <Flink> Okay
12:27:34 <`Jake`> peddie: i.e. then you would know that if it is y:ys
12:27:38 <peddie> `Jake`: how do you think pattern match is implemented?  I think it's a check whether it's [] or y:ys
12:28:11 <armlesshobo> peddie: i normally check for [] first
12:28:30 <`Jake`> Well, you can theoretically implement a funtion (\(x:xs) -> x) without pattern matching against []
12:28:35 <armlesshobo> and I aim to make it so that the last pattern matches can assume no possible exceptions
12:28:48 <hpaste> jonaskoelker pasted “what's the most idiomatic?” at http://hpaste.org/68975
12:29:19 <jonaskoelker> anyone care to look at three lines of my code?
12:30:04 <sclv> jonaskoelker: yeah none of them is awesome.
12:30:15 <sclv> but if you only really want a separate function for the pattern match
12:30:23 <sclv> consider just using `maybe` instead
12:30:35 <rata_> hi all
12:30:43 <sclv> maybe oneCase otherCase =<< asks (lookup v)
12:31:07 <jonaskoelker> or mirror that around >>=, I assume
12:31:17 <jonaskoelker> is one preferred to the other?
12:31:27 <sclv> i prefer =<<
12:31:32 <sclv> but tastes vary
12:31:38 <sclv> the usual explanation i give is that if i write
12:31:44 <sclv> f . g . h $ h
12:31:52 <sclv> or $ x rather
12:32:05 <sclv> that's a chain of things that get applied one after another to the thing at the end of the line.
12:32:09 <`Jake`> peddie: Well, you can theoretically implement a funtion (\(x:xs) -> x) without pattern matching against []
12:32:12 <sclv> =<< keeps things in that same order
12:32:27 <sclv> f =<< g =<< h...
12:32:29 <jonaskoelker> fwiw, I think they're all better than {env <- ask; if v `member` env then (win) else (lose)}.  Agree?
12:32:42 <jonaskoelker> sclv: interesting property
12:33:37 <peddie> @src head
12:33:38 <lambdabot> head (x:_) = x
12:33:38 <lambdabot> head []    = undefined
12:34:47 <`Jake`> that's interesting. I thought it would throw an empty list error
12:37:03 <peddie> but this function isn't really what you were talking about before (without `fix` at least), because you were talking about a recursive one
12:37:19 <int80_h> I have a file that can only compile using Cabal. I want to run individual functions within this file via ghci. I'm pretty sure I can't just use the executable Cabal creates in ghci. How can  generate an object file that can be used by ghci?
12:37:56 <hpaste> jonaskoelker pasted “maybe is nice! :-)” at http://hpaste.org/68978
12:38:18 <jonaskoelker> sclv: thanks for that `maybe' suggestion, that's really succint and clear, IMO
12:38:18 <hhb_> Hi, with attoparsec, is there a way to do a takeTill (== ' ') that actually includes the space, but discards it? My parsers look like { field1 <- takeTill(== ' '); satisfy (== ' '); field2 <- takeTill (== ' '); } and I'd like to get rid of the satisfy (== ' ') in between each field.
12:38:58 <`Jake`> peddie: yeah, but pattern matching in recursive funtions works the same way as in non-recursive ones, doesn't it? I don't really get your point here. I guess we're kinda talking at cross-purposes.
12:39:38 <peddie> `Jake`: you asked whether it would be faster to write the ``common case'' first
12:40:16 <peddie> `Jake`: and in this case, the code that GHC generates will have to check whether it's an empty list or one with at least one element at every function call, right?
12:41:08 <`Jake`> peddie: Well, i learned from sclv that pattern matching was implemented in a different way than I thought it was, so my argument wasn't really valid anymore after that point
12:41:13 <peddie> `Jake`: so I don't think changing the order you write the statements will speed things up
12:41:35 <peddie> `Jake`: OK, just trying to explain why that is without trying to tell you exactly how pattern matching is implemented :)
12:42:56 <jonaskoelker> is it preferred (more idiomatic) to use throwError over fail?
12:43:17 <`Jake`> peddie: ok, thanks :) I just stumbled upon "how do you think pattern match is implemented?  I think it's a check whether it's [] or y:ys", because it can't be like this in a funtion like (\(x:xs) -> x), but I guess I didn't fully understand you. I do now, I think.
12:43:27 <jonaskoelker> [I'd guess there's a guarantee that it's the _error_ monad thait fails, rather than some arbitrary monad in your stack, if you use throwError...]
12:44:09 <monochrom> (\(x:xs) ->  x) [] is a run-time error. there is still a check.
12:44:32 <rwbarton> in the end it is just branching on whether a number is 0 or 1
12:45:05 <`Jake`> monochrom: Yeah, know. But not a check whether it's [] or _:_, right? Just a check whether it's _:_ or not
12:45:22 <rwbarton> "not" is equivalent to "[]"
12:45:24 <rwbarton> there is no other possibility
12:46:14 <jonaskoelker> I think Jake's question might be whether it's isCase _:_ vs. for c in cases: if input matches c: go_do_it
12:46:36 <jonaskoelker> `Jake`? ^^
12:46:54 <rwbarton> my point is if you first test for [] and it does not match, then you do not have to "test" for (x:xs), you know it matches
12:47:00 <`Jake`> Uhm.. don't fully understand what you are trying to say, sorry^^
12:47:01 <rwbarton> or vice versa
12:47:15 <monochrom> well, presumably, if you have "data X = B | C | D", you can ask how much check there is in (\B -> 0).
12:47:40 <rwbarton> yes, for three or more constructors it may become more interesting
12:47:47 <jonaskoelker> Jake, no worries.  I think it's something similar to what monochrom just said
12:48:39 <`Jake`> exactly... So it implicitly checks if it's [], because it's the only other possibility, but not explicitly. I guess a list wasn't the best example in the first place
12:51:34 <`Jake`> > head []
12:51:36 <lambdabot>   *Exception: Prelude.head: empty list
12:51:52 <monochrom> GHC-generated code tests for only B in (\B -> 0)
12:51:53 <hhb_> In attoparsec, is there some technique that would be like takeThrough(== ' ') that would give me the option to throw out the ' '?
12:52:03 <`Jake`> weird. The sourcecode lambdabot shows doesn't match the sourcecode that is used.
12:52:23 <`Jake`> @src head
12:52:24 <lambdabot> head (x:_) = x
12:52:24 <lambdabot> head []    = undefined
12:55:00 <monochrom> lambdabot's @src command uses a hand-written file. not meant to track real implementations
12:55:04 <byorgey> `Jake`: the output of the @src command comes from a text file.
12:55:23 <palmfrond> style enquiry: if you had to put model objects (MYCar, vs say MyCarView/Controller, etc) into a category, what would the name of that category be?
12:55:54 <`Jake`> ok, I guess they just used a simpler version of head because the rest of the implementation is obvious
12:56:04 <hpaste> RM pasted “Attoparsec Question” at http://hpaste.org/68979
12:56:41 <hhb_> I hope that Parser question is clear
12:57:05 <byorgey> palmfrond: careful using the word 'category' around here ;)
12:57:12 <byorgey> however, I don't actually understand your question
12:57:26 <palmfrond> if you put their files into folder in your filesystem
12:57:41 <palmfrond> i'd put all of my view and view controller files in the "interface" folder
12:57:56 <byorgey> palmfrond: oh.  models? types? stuff?
12:57:58 <palmfrond> but what about model files?
12:58:05 <byorgey> does it really matter that much?
12:58:08 <palmfrond> i was thinking Entity
12:58:15 <byorgey> sure, great
12:58:23 <palmfrond> uh, NVM to you thanks
12:58:29 <byorgey> =)
12:58:33 <palmfrond> if you don't want to participate in my question, don't. i expect nothing
12:58:43 <palmfrond> but don't close the door on it, maybe others have input. thanks
12:59:35 <byorgey> palmfrond: point taken, sorry for that.  But your question is somewhat off-topic.
12:59:52 <palmfrond> thank you. and yea, you are right. i'll ask in -blah
13:01:03 <hpaste> int80_h pasted “using an object file with ghci” at http://hpaste.org/68980
13:03:03 <rata_> does it mean something when I see a lot of "ghc-prim:GHC.Types.:" in the heap profile?
13:07:00 <danr> rata_: it's a cons
13:07:01 <danr> (:)
13:07:11 <hiptobecubic> I'm finding it very difficult not to treat type classes like OO
13:07:32 <rata_> ah ok, thanks danr
13:07:43 <jonaskoelker> hiptobecubic: well, they are kinda' like vtables...
13:09:01 <absence> mm_freak_: if i have something like "keyMouseHandler . keyMouseEvent <|> postRedisplay . idleEvent <|> renderStuff . renderEvent" is it possible for both keyMouseHandler and renderStuff to share a wire (e.g. integral)?
13:09:09 <rwbarton> except they aren't attached to data in the same way
13:09:38 <jonaskoelker> true dat
13:09:38 <danr> jonaskoelker: vtables are for method overriding in inheritance, right? maybe I got this wrong, but if it is I do not see the connection ;)
13:10:10 <jonaskoelker> danr: I think v is for virtual, as in, it's a table of all those C++ methods declared "virtual", i.e. "yes" ;-)
13:11:18 <danr> jonaskoelker: ghc compiles typeclasses with dictionaries that are passed as extra arguments. there is no extra information for every value - such as a vtable - that is carried around
13:11:55 <jonaskoelker> danr: right; I think most C++ binary interfaces only carry a pointer to the vtable; GHC instead passing the pointer alongside the (rest of the) object
13:12:28 <jonaskoelker> (so the C++ vtable is per class, not per object)
13:12:36 <rata_> how do I see a "stack profile"?
13:12:44 <danr> jonaskoelker: oh of course only a pointer to the vtable
13:13:11 <danr> jonaskoelker: hm ok I now get your point, you see the dictionary as a vtable supplied as an extra argument?
13:13:22 <jonaskoelker> danr: exactly
13:14:14 <hiptobecubic> ok i read the wiki article on vtables
13:14:54 <ski> however, the methods in a type class doesn't take as an implicit argument a "self" value
13:14:55 <danr> hiptobecubic, jonaskoelker: well it's still an implementation technique, so I'm not sure if it would help you to actually understand the difference between typeclasses and OO
13:14:56 <hiptobecubic> Is that what ghc is doing then? Passing the table of pointers to the proper implementations?
13:15:11 <ski> also, type classes can have multiple type parameters
13:15:12 <hiptobecubic> danr, sure, but it's a new and interesting question
13:15:40 <ski> (also, "OO" can mean a lot of things ..)
13:15:47 <ski> @where object-oriented
13:15:47 <lambdabot> http://community.schemewiki.org/?object-oriented-programming
13:16:10 <jonaskoelker> ski: yeah, they take an explicit self argument, except the self suffers from multiple personality disorder :D
13:16:15 <danr> hiptobecubic: http://www.haskell.org/haskellwiki/OOP_vs_type_classes
13:16:26 <danr> might be a better start :)
13:16:35 <ski> jonaskoelker : except there is no need for there to be a "self" argument at all
13:16:44 <jonaskoelker> ski: right, I agree
13:17:06 <danr> hiptobecubic: papers on how to implement typeclasses http://www.haskell.org/haskellwiki/Research_papers/Type_systems#Type_classes
13:17:07 <ski> you could also have `class Foo a where bar :: Set a -> ...'
13:17:10 <hiptobecubic> I wrote something a few weeks ago trying to make some sense of a (really terrible) copy-pasted program computing some properties of random numbers. I was just learning about how type classes work and I pretty much wrote the whole thing as data declarations and type class instances
13:17:59 <hughfdjackson> surely the ability to have side-effectful methods against objects is the core of OO
13:18:14 <hughfdjackson> :D at least, i can't imagine a definition for it that doesn't involve that that still has some meaning
13:18:26 <c_wraith> It's possible to do OO without side effects
13:18:28 <Saizan> hughfdjackson: you'd be surprised
13:18:32 <c_wraith> pretty painlessly, even
13:18:58 <hughfdjackson> as time goes on, the less i'm surprised that i would be surprised ;)
13:19:32 * hughfdjackson will read that scheme and haskellwiki articles
13:19:40 <ski> hajimehoshi : "Objects in Caml -- 3.13  Functional objects" <http://caml.inria.fr/pub/docs/manual-ocaml/manual005.html#toc30>
13:19:55 <hughfdjackson> cheers, ski
13:20:10 <danr> ski: interesting, ty
13:20:54 <otters> hahaha
13:20:59 <otters> "it is simple, safe, and well documented"
13:22:32 <mastodonhq> so i started learning haskell, and i've found myself confused, why is [(True,[]),(False,[['a']])] not [(Bool,[]),(Bool,[[Char]])] ? is it because [] is zero width ?
13:22:43 <ski> hughfdjackson : hm, actually that link was meant for you
13:22:54 <byorgey> mastodonhq: all the elements of a list must have the same type
13:23:07 <byorgey> mastodonhq: so the type of a list is simply that one, single type enclosed in [ ]
13:23:18 <byorgey> not a list of the types of the elements.
13:23:23 <ski> @type [(True,[]),(False,[['a']])]
13:23:24 <lambdabot> [(Bool, [[Char]])]
13:23:32 <mastodonhq> err byorgey I may have written that wrong
13:23:47 <mastodonhq> direct copy: [(True, []), (False, [['a']])]
13:24:02 <byorgey> that's the same as what you wrote before.
13:24:29 <byorgey> are you still confused?
13:24:30 <hughfdjackson> ski: :D i'd guessed, no worries
13:25:39 <mastodonhq> byorgey yeah i little i assumed that it would be [(Bool, []),(Bool, [['a']])] and not [(Bool, [[Char]])
13:25:48 <mastodonhq> *missed a ]
13:26:11 <ski> @type ['a','b']
13:26:13 <lambdabot> [Char]
13:26:15 <ski> @type ['a',False]
13:26:17 <lambdabot>     Couldn't match expected type `Char' against inferred type `Bool'
13:26:17 <lambdabot>     In the expression: False
13:26:17 <lambdabot>     In the expression: ['a', False]
13:26:23 <byorgey> mastodonhq: so what should be the type of [1,2,3]?  [Int, Int, Int]?
13:26:25 <armlesshobo> @info Functor
13:26:25 <lambdabot> Functor
13:26:38 <armlesshobo> @info Char
13:26:38 <lambdabot> Char
13:26:42 <armlesshobo> close
13:26:42 <armlesshobo> lol
13:26:43 <mastodonhq> byorgey: that would appear so shouldn't it ?
13:26:49 <byorgey> mastodonhq: this is what I was saying before, all elements of a list have the same type, so when you write the type of a list you write a single type in brackets
13:26:58 <byorgey> mastodonhq: in fact, [1,2,3] has type  [Int]
13:27:11 <byorgey> meaning "this is a list where all the elements have type Int"
13:27:30 <byorgey> [Int, Int, Int] is a syntax error
13:27:31 <mastodonhq> so [] has no type and is essentially void ?
13:27:33 <geekosaur> amlesshobo: there is no @info, it's being edit-corrected to something else (probably @echo)
13:27:38 <ski> mastodonhq : given a list `[e0,e1,e2,...,e]', the type of this list is written as `[T]', where `T' is the type of each element `e0',`e1',`e2',...,`e' (they all have to have the same type)
13:27:56 <byorgey> mastodonhq: no, [] is the empty list, it has type [a]
13:27:58 <armlesshobo> [(1, True)] would be of type [(Num, Bool)]
13:28:05 <byorgey> a is a 'type variable' meaning it can stand for any type.
13:28:13 <ski> armlesshobo : except `Num' isn't a type
13:28:21 <armlesshobo> right
13:28:27 <armlesshobo> Num t => t
13:28:27 <mastodonhq> @type [(True, []), (False, [['a']])]
13:28:28 <lambdabot> [(Bool, [[Char]])]
13:28:35 <byorgey> that means [] can have type [Int], or [Bool], or [[Char]]
13:28:52 <ski> @type ([] :: [Int])
13:28:53 <lambdabot> [Int]
13:29:01 <ski> @type ([] :: [(String,Int -> Bool)])
13:29:02 <lambdabot> [(String, Int -> Bool)]
13:29:02 <joelr> what's 1 & 2 in haskell?
13:29:27 <joelr> do i need Data.Bits?
13:29:27 <geekosaur> you looking for bitwise ops?  (.&.) in Data.Bits
13:29:30 <ski> joelr : do you mean treating the integers as bitstrings ?
13:29:30 <byorgey> mastodonhq: in this particular example, GHC figures out that the [] must have type [[Char]], because it has to have the same type as [['a']]
13:29:41 <joelr> ski: yes
13:29:49 <ski> > 1 .&. 2
13:29:50 <lambdabot>   Ambiguous type variable `a' in the constraint:
13:29:50 <lambdabot>    `Data.Bits.Bits a'
13:29:50 <lambdabot>      a...
13:29:51 <mastodonhq> oh thank you byorgey
13:29:53 <ski> > 1 .&. 2 :: Integer
13:29:54 <lambdabot>   0
13:30:03 <joelr> ski: thanks
13:30:14 <mastodonhq> byorgey: that makes a lot more sense
13:30:26 <byorgey> mastodonhq: great, glad I could help
13:30:30 <int80_h> what is the name of the haskell channel intended for chit-chat?
13:30:39 <ski> #haskell-blah ?
13:30:56 <int80_h> huh I just went there and it looked like I had just created the channel
13:31:12 <int80_h> oh I used an underscore
13:31:40 <mastodonhq> byorgey: to clarify am i to assume because of the second tuple the [] is just shorthand for the second element of the second tuple?
13:31:57 <mastodonhq> *shorthand for the type of the second element
13:31:58 <byorgey> mastodonhq: no, [] is always the empty list
13:32:27 <byorgey> mastodonhq: I think you are mixing up types and values.
13:32:31 <byorgey> mastodonhq: [] is a value, not a type
13:32:50 <byorgey> (yes, everyone, I know you can also use it in types, shush)
13:32:54 <armlesshobo> lol
13:33:24 <armlesshobo> see, when i try explaining different things about haskell to my friends they thing I've gone mad
13:33:29 <burbul> Does anyone here use Leksah?
13:33:36 <ski> @. kind type []
13:33:37 <armlesshobo> burbul: i've dabbled with it before
13:33:38 <lambdabot> *
13:33:44 <burbul> I'm having trouble getting it to accept a 'if os' in the .cabal file...
13:33:56 <mastodonhq> byorgey: what i meant was that if the second value of the tuple is [[Char]] then if i used [] as the second value of the first haskell will assume it to be the same type as the second tuples second element ?
13:34:07 <byorgey> mastodonhq: yes
13:34:13 <byorgey> mastodonhq: but it is not shorthand for anything.
13:34:13 <mastodonhq> byorgey: ahh thank you
13:34:21 <burbul> I get things like "Can't activate package C:\Mohan\alms\postparse\postparse\postparse.cabal: 12: user error (Construct not supported at this position: IfBlock 12 "os(windows)" [F13 "build-depends" "Win32 -any"] [])"
13:34:30 <byorgey> mastodonhq: it's just that [] can have lots of different types
13:34:35 <mastodonhq> byorgey: didn't really me shorthand more of shortcut
13:34:38 <mastodonhq> *mean
13:34:42 <byorgey> mastodonhq: so the type that gets chosen may depend on the context in which it is used
13:34:45 <ski> mastodonhq : no the second value of the type is not `[[Char]]', it has *type* `[[Char]]'
13:35:06 <byorgey> mastodonhq: it's not a shortcut either.  nothing is short. =)
13:35:10 <mastodonhq> ski: excuse my lack of understanding of terminology
13:35:23 <ski> mastodonhq : np, just attempting to clear it up :)
13:35:37 <mastodonhq> ski: I'm mostly a hobby programmer and have no formal university training ;p
13:35:50 <mastodonhq> and thus lack knowledge of terms
13:36:21 <Saizan> re OO, i've just found a nice exchange of comments between dreyer and cook here http://lambda-the-ultimate.org/node/3668
13:36:22 <ski> with some practice, you'll absorb the terms
13:36:57 <mastodonhq> I'm beginning to love haskell it takes more up front thinking to accomplish things ;p and hopefully I'll absorb the terms like you said ski
13:37:06 <byorgey> mastodonhq: no one minds if you don't know the right terminology, it's just hard to tell the difference between someone who is using slightly wrong terms for correct ideas, and someone who is confused.  So don't take corrections personally =)
13:37:45 <hiptobecubic> danr, interesting wiki article
13:37:47 <mastodonhq> byorgey: I don't :P I've been corrected so many times I've come to embrace it because it helps me convey my problem better
13:37:54 <byorgey> indeed =)
13:38:04 <joelr> my ghci can't find foldl' is it fold1 these days?
13:38:10 <joelr> foldll1
13:38:14 <danr> joelr: import Data.List
13:38:17 <hiptobecubic> danr, maybe i get it a bit more, but there is still the problem that type classes *can* be used just like OO and so it's natural for an OO programmer to do so
13:38:18 <joelr> argh
13:38:25 <jonaskoelker> foldlalr1? ;-)
13:38:36 <danr> cdddadaddr?
13:39:19 <jonaskoelker> lisp_variable_name ::= c(a|d)*r
13:39:20 <jonaskoelker> ^_^
13:42:34 <ski> `cr' ?
13:42:45 <jonaskoelker> the identity function :)
13:43:01 <ski> i suppose
13:43:08 <jonaskoelker> it does the null traversal...
13:43:48 <joelr> is there a point version of \acc x -> acc .&. fromEnum x ?
13:43:59 <jonaskoelker> @pl \acc x -> acc .&. fromEnum x
13:43:59 <lambdabot> (. fromEnum) . (.&.)
13:44:00 <joelr> an elegant point version that is
13:44:07 <joelr> hmm
13:44:09 <joelr> jonaskoelker: thanks
13:44:12 <ski> joelr : it already is pointful
13:44:37 <jonaskoelker> joelr, don't thank me, thank the bot ;-)
13:44:42 <jonaskoelker> it did all the hard work :D
13:44:49 <joelr> :D
13:54:03 <mm_freak_> absence: that's why i want to introduce boolean combinators, but you can do it the following way:  keyboard . keyEv <|> render . (idleEv <|> renderEv)
13:54:37 <mm_freak_> hmm, considering this it seems like it wouldn't be necessary to have boolean combinators
14:02:25 <andares> hey, can I get ghci to tell me the fixity of an operator?
14:02:37 <joelr> @t swap
14:02:37 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
14:02:41 <joelr> hmm
14:02:46 <joelr> :t swap
14:02:48 <lambdabot> Not in scope: `swap'
14:02:59 <fmap> :i (+)
14:03:05 <fmap> andares: ^
14:03:14 <joelr> :i swap
14:03:14 <ski> @type snd &&& fst
14:03:16 <lambdabot> forall a c. (a, c) -> (c, a)
14:03:34 <joelr> trying to find out where swap is
14:03:39 <ski> @index swap
14:03:40 <lambdabot> bzzt
14:03:43 <joelr> what module
14:03:48 <fmap> Data.Tuple
14:03:57 <joelr> fair
14:03:59 <joelr> thanks
14:04:03 <ski> @type Data.Tuple.swap
14:04:05 <lambdabot> Not in scope: `Data.Tuple.swap'
14:05:02 <andares> :i (**^)
14:05:27 <ski> lambdabot doesn't understand `:i'
14:12:50 <mm_freak_> is there a library implementing a type class that relates sequences to individual elements?  like Text/Char, ByteString/Word8, [a]/a, etc.
14:13:59 <stepcut> related in what way? Sounds a bit like zippers
14:15:09 <mm_freak_> well, i want to write a function that processes "strings" in groups of characters…  for that function i basically need 'take' and 'tail'
14:18:38 <jonaskoelker> :i []
14:18:42 <jonaskoelker> > :i []
14:18:44 <lambdabot>   <no location info>: parse error on input `:'
14:19:04 <jonaskoelker> stuff that into ghci --> [a] doesn't seem to implement any interesting classes
14:19:49 <jonaskoelker> random question: "spiffification" or "enspiffyment"?
14:20:51 <Paprikachu> http://ideone.com/6JKKm
14:20:58 <hpc> jonaskoelker: spuffed
14:21:01 <Paprikachu> the answer is somewhere in the output
14:21:02 <hpc> it's an irregular verb ;)
14:21:24 <jonaskoelker> hpc: "I spaffed my code yesterday"?
14:21:26 <byorgey> enspiffled
14:21:36 <hpc> exactly
14:21:43 <ski> hm, `Show',`Read',`Eq',`Ord',`Functor',`Applicative',`Alternative',`Monad',`MonadPlus'
14:21:43 <byorgey> "I have spuffed my code thrice"
14:21:54 <jonaskoelker> "spaffed" sounds... nsfw
14:22:37 <geekosaur> sounds like making something more secure to me
14:23:00 <jonaskoelker> a la `buffed'?
14:24:58 <byorgey> mm_freak_: ListLike?
14:25:03 <byorgey> @package ListLike
14:25:03 <lambdabot> http://hackage.haskell.org/package/ListLike
14:33:46 <otters> um
14:35:59 <zachk> so a .cabal needs prelude and haskell98, but then it is ambigous, how does one resolve that?
14:36:11 <zachk> er prelude in base and haskell98 creates a conflict
14:36:31 <Clint> you get rid of haskell98
14:38:05 <otters> so I have an attoparsec parser, and in one of the subparsers I'm trying to match a letter and then a list of more letters
14:38:36 <otters> but letter_ascii *> takeWhile (inClass "...") just gives me the result of the takeWhile
14:38:41 <otters> which I know is how *> is designed
14:38:51 <otters> but I don't know which operator will return the result of both
14:39:26 <c_wraith> (,) <$> letter_ascii <*> takeWhile ..
14:39:31 <c_wraith> to return them as a tuple
14:39:42 <c_wraith> But basically, this is exactly what applicative was designed for
14:40:50 <otters> huh
14:40:51 <zachk> Clint: when I dispose of haskell98, cabal then wants module Maybe
14:41:05 <Clint> zachk: you should use Data.Maybe instead
14:41:25 <zachk> it's not my code, I am just trying to get some older packages from hackage to build
14:41:26 <strager> (:) <$> letter_ascii <*> takeWhile etc  -- Will build a string if you want that
14:41:53 <zachk> though thanks for the advice, Clint
14:42:12 <Clint> s/you/they/
14:43:50 <strager> I build a bunch of helpers to get around repeating yourself with string concats, etc.
14:43:58 <strager> basically, liftM2 (:) and friends
14:44:10 <companion_cube> :t liftM2 (:)
14:44:11 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m [a1] -> m [a1]
14:57:31 * hackagebot yall 0.2 - Lenses with a southern twang  http://hackage.haskell.org/package/yall-0.2 (BrandonSimmons)
15:01:33 <jonaskoelker> does anyone know of a good probability distribution monad library?
15:02:17 <c_wraith> There was a paper about a probability monad a while ago.  I don't think the code from it was on hackage, though
15:02:38 <c_wraith> oh.  there seems to be at least one on hackage
15:02:42 <c_wraith> @hackage probability
15:02:43 <lambdabot> http://hackage.haskell.org/package/probability
15:04:03 <jonaskoelker> tried it?
15:05:11 <c_wraith> nope
15:36:24 <absence> mm_freak_: i don't understand.. does that cause render to be called whenever there is a idleevent or renderevent? i want to use the same wire (e.g. updateGameWorld) in both the keyboard and render handlers, and they need to share the state (like integral wires)
15:40:46 <kwos> hello :)
15:43:34 <nicu_> hi, I have a problem with haddock documentation created when installing new packages with cabal on windows
15:45:19 <nicu_> the generated html files have all links in the form j:\Users\...\doc\...\xxx.html
15:45:36 <nicu_> but firefox says, it cannot open that link
15:45:57 <nicu_> actually it should be a file:/// before all this
15:46:56 <nicu_> I wonder if this is only on windows so and if there is a solution to this
15:50:53 <rata_> I've discovered which fields in my data structures I need to make strict to avoid an stack overflow in the optimized case... how do I know what to change now to make it work in the unoptimized case?
15:51:57 <absence> mm_freak_: i guess it would have to be something like postRedisplay . idleEvent <|> keyMouseOrRender . (keyMouseEvent <|> renderEvent) but then i need some way for keyMouseOrRender to detect which event fired and choose key/mouse or render behaviour accordingly. that means keyMouseEvent and renderEvent can't be identity, or?
15:59:00 <jonaskoelker> how do I uninstall packages with cabal?
16:02:43 <ifnspifn> Heya, super quick question. I've made it ALL THE WAY to the second question in http://www.haskell.org/haskellwiki/99_questions/1_to_10, and although I've solved it, I'm totally unsure as to why another of my potential solutions doesn't work
16:03:10 <ifnspifn> So, the goal is to make a function that takes the second to last element in a list. Why wouldn't the following work:
16:03:28 <ifnspifn> myButLast l = last . (take (length l - 1))
16:04:25 <shachaf> "foo . bar" is a function.
16:04:44 <ifnspifn> right, so shouldn't "foo . bar l" be that function applied to l?
16:04:53 <rata_> jonaskoelker: afaik it's not possible
16:05:19 <shachaf> ifnspifn: First, "foo . bar l" is "(foo) . (bar l)".
16:05:42 <hughfdjackson> foo . bar $ l?
16:05:44 <shachaf> ifnspifn: Second, you don't have "foo . bar baz"
16:05:52 <hughfdjackson> :| i could be embarressingly wrong on that
16:06:03 <shachaf> (By the way, if you were actually writing this function you wouldn't want to use length.)
16:06:13 <ifnspifn> because it's O(n)?
16:06:35 <jonaskoelker> no, that can't be dodged
16:06:45 <shachaf> That's sort of the reason. :-)
16:06:56 <shachaf> As jonaskoelker mentioned, your function is going to have to traverse the whole list anyway.
16:07:06 <jonaskoelker> ... you have to move past O(n - 2) elements to get to the second last
16:07:11 <ifnspifn> I think I see what you mean, shachaf. I'm defining myButLast to be a total function (as opposed to a partial function), but then expect it to be used as a partial function
16:07:36 <shachaf> But "length" is usually the wrong way to approach list traversal no matter what. You'll get better list-habits if you avoid it wherever you can, for now.
16:07:45 <shachaf> ifnspifn: myButLast can't be total...
16:08:12 <jonaskoelker> unless it's _defined_ to evaluate to bottom in [] and [_] ;-)
16:08:50 <shachaf> jonaskoelker: No, that's still not total.
16:08:54 <shachaf> "total" has a meaning. :-)
16:08:59 <ifnspifn> maybe Im' using "total" incorrectly
16:09:00 <ifnspifn> ah, right
16:09:02 <jonaskoelker> dangit :|
16:09:29 <jonaskoelker> mathematicians give a slightly different, related meaning, yes?
16:09:31 <shachaf> Anyway, first get this function working.
16:09:38 <jonaskoelker> snd'ed
16:09:40 <shachaf> Then you can make it nice. :-)
16:09:40 <ifnspifn> I guess I meant "foo = bar . baz" is 'partial', while "foo x = bar . baz x" is 'total'
16:09:54 <jonaskoelker> "fully applied"?
16:09:55 <shachaf> ifnspifn: Oh, no, that's a completely different meaning.
16:10:14 <shachaf> You're confusing two uses of the word "partial" here.
16:10:40 <shachaf> But that doesn't matter so much.
16:10:54 <shachaf> Anyway: "foo = bar . baz" isn't the same function as "foo x = bar . baz x"
16:11:08 <shachaf> It's the same function as "foo x = (bar . baz) x", or as "foo x = bar (baz x)"
16:11:18 <shachaf> This is very important to understand. :-)
16:11:25 <ifnspifn> ahhhh, that DOES make sense :]
16:11:53 <jonaskoelker> whereas the latter is "bar . (baz x)", correct?
16:12:18 <shachaf> Yes.
16:12:22 <jonaskoelker> [e.g. concat . (map (\x -> [x])))
16:12:26 <shachaf> Which means that "baz x" and "bar" are functions.
16:12:41 <shachaf> jonaskoelker: Now you're just *trying* to make things complicated.
16:12:50 <jonaskoelker> no, that was an accident :|
16:13:21 <jonaskoelker> I think I'll leave the teaching to the master :)
16:16:35 <ifnspifn> myButLast = last . init
16:16:40 <ifnspifn> eh? eh?
16:17:24 <ifnspifn> I guess I should start memorizing the list functions now... they're pretty darn handy
16:17:32 <dbo> greets
16:18:15 <nikoLaufs> is anyone afk?
16:19:11 <parcs`> is that a trick question
16:19:13 <nikoLaufs> i ws reading the work on seL4 kernel about how the team made a haskell prototype abstraction of the kernel
16:19:39 <nikoLaufs> and how they used a theorem prover (isabelle) to prove the IL (handcoded in C)
16:20:02 <nikoLaufs> my question is: how do you create an abstract representation of a kernel in haskell
16:21:14 <nikoLaufs> lnks: lambda-the-ultimate.org/node/3916
16:27:11 <nikoLaufs> ?
16:28:08 <Saizan> nikoLaufs: they haven't made it public?
16:29:00 <nikoLaufs> from the provided pdf (@ the lnk) they did w/o going into too much detail
16:29:49 <nikoLaufs> eg enough detail a haskell adept could understand, but not enough for this haskell n00b
16:30:10 <nikoLaufs> i can program in asm, c and c++. thats about it
16:30:11 <Saizan> let's see
16:30:13 <madhadron> And by Haskell adept you mean human decompiler?
16:30:35 <Saizan> madhadron: aren't we all?;)
16:31:05 <nikoLaufs> lol no, i mean someone who can program in haskell. i can decomp a haskell/prolog/scheme/nausicaa prog and figure out whats what and where to stick it
16:31:29 <madhadron> Saizan, I like to think of myself as a unique and special snowflake, but in the end, yeah, that's probably it.
16:31:46 <nikoLaufs> or just look at haskells/schemes/javas/pythons/etc bytecode passed to the vm and figure it out from there
16:32:07 <nikoLaufs> anywho...yeah. i'm totally lost b/c
16:32:15 <nikoLaufs> idk
16:32:55 <c_wraith> the binaries that result from ghc-compiled code look basically nothing like the binaries you'd get out of C compiler
16:33:26 <madhadron> c_wraith, Yes, that's true.
16:33:40 <madhadron> They implement different virtual machines
16:34:01 <nikoLaufs> true, but for every vm they have to have p-code -->asm
16:34:21 <nikoLaufs> eg bytecode *eventually* turned to asm
16:34:25 <madhadron> No, I meant that the conceptual virtual machines the languages describe are very different
16:34:49 <madhadron> Anyway, I'll stop rambling.
16:34:50 <nikoLaufs> yeah. i'm treating the vms as a black box, only looking @ input/output
16:35:02 <nikoLaufs> NOT the vm itself
16:35:31 <c_wraith> if you want to understand ghc-generated code, you probably should study the STG machine, which is a formal model GHC was built on top of.  Though it has a lot of differences in the details
16:36:02 <c_wraith> but knowing about STG at least lets you identify things in memory.
16:36:06 <nikoLaufs> well, it's not so much that, i need help with the process, the 'how' they constructed the haskell prototype of a kernel
16:36:32 <nikoLaufs> if i have the process i can google teh rest, i'm not a n00b
16:37:40 <gabemc> @help
16:37:40 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:38:12 <nikoLaufs> @help
16:38:12 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:39:48 <nikoLaufs> learning how to build a tcp stack from the ground up is hard, if impossible, if you don't know what you need, what you need to know, which functions to call, what ntohl, etc. is. Learning from the ground up takes too long. learning an 'overview' of how tcp/ip works, how networking works, etc. makes the process faster, smoother and easier to learn. that's all i ask :|
16:39:59 <Saizan> nikoLaufs: from what i understand their Haskell code is pretty lowlevel and close to what you'd do in not-so-optimized C, they must have added some primitives for accessing enough of the CPU and other devices though
16:40:55 <nikoLaufs> ok. how did they represent c kernel programs/headers
16:41:13 <nikoLaufs> as functions?
16:41:33 <parcs`> is there a combinator for combining (a -> a -> Ordering)s
16:42:13 <rwbarton> mappend?
16:42:15 <dobblego> parcs`: there is on or mappend, but probably not quite there
16:42:37 <dobblego> > mempty :: Ordering
16:42:38 <lambdabot>   EQ
16:42:41 <nikoLaufs> @Saizan like i know they used isabelle/HOL, as a theorem prover. but they could only use it once they translated the kernel c code into a haskell prototype then into a functional representation
16:42:41 <lambdabot> Unknown command, try @list
16:44:30 <Saizan> nikoLaufs: i've just skimmed it, but they say that e.g. the C semantics in HOL represent e.g. memory as a function from addresses to values
16:44:36 <parcs`> @pl \a b -> comparing fst a b `mappend` comparing snd a b
16:44:36 <lambdabot> ap (ap . (mappend .) . comparing fst) (comparing snd)
16:45:30 <rwbarton> doesn't the (->) r instance for Monoid take care of that automatically?
16:45:42 <Saizan> nikoLaufs: but i don't think the C goes through the haskell prototype at that point, the Haskell one was used before that
16:45:48 <rwbarton> > sortBy (comparing snd `mappend` comparing fst) [(1, 3), (2, 4), (3, 1), (4, 2)]
16:45:48 <lambdabot>   [(3,1),(4,2),(1,3),(2,4)]
16:45:49 <parcs`> rwbarton: oh right. awesome!
16:46:02 <parcs`> forgot that one existed
16:47:44 <otters> > sortBy (comparing snd `mappend` comparing fst) [(1,2),(1,1),(2,1),(2,2)]
16:47:46 <lambdabot>   [(1,1),(2,1),(1,2),(2,2)]
16:47:50 <otters> sweet
16:48:16 <parcs`> apparently i'm just duplicating the Ord (a, b) instance..
16:50:56 <applicative> @check \xs -> sortBy (comparing snd `mappend` comparing fst) xs == sort xs
16:50:56 <lambdabot>   "OK, passed 500 tests."
16:51:42 <parcs`> @check \xs -> sortBy (comparing snd `mappend` comparing fst) xs == xs
16:51:43 <lambdabot>   "OK, passed 500 tests."
16:52:01 <parcs`> @check \xs -> sortBy (comparing snd `mappend` comparing fst) xs == (xs :: [Int])
16:52:02 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
16:52:09 <parcs`> @check \xs -> sortBy (comparing snd `mappend` comparing fst) xs == (xs :: [(Int,Int)])
16:52:10 <lambdabot>   "Falsifiable, after 3 tests:\n[(3,3),(-3,-3),(3,-4)]\n"
16:52:15 <parcs`> @check \xs -> sortBy (comparing snd `mappend` comparing fst) xs == sort (xs :: [(Int,Int)])
16:52:16 <lambdabot>   "Falsifiable, after 4 tests:\n[(-3,-2),(4,0),(0,-1),(-4,-5),(-2,3)]\n"
16:52:32 <parcs`> it's fst then snd, i meant
16:52:57 <applicative> @check \xs -> sortBy (comparing fst `mappend` comparing snd) xs == sort xs
16:52:58 <lambdabot>   "OK, passed 500 tests."
16:53:11 <applicative> am I comparing ()s?
16:53:28 <parcs`> yeah
16:53:28 <applicative> quickcheck is not too helpful with facts about ()
16:55:36 <applicative> @check \xs -> sortBy (comparing fst `mappend` comparing snd) xs == sort (xs :: [(Int,Int)]) -- at last
16:55:37 <lambdabot>   "OK, passed 500 tests."
17:08:48 <applicative> @check \x y -> x == y
17:08:48 <lambdabot>   "OK, passed 500 tests."
17:08:57 <mauke> @check (==)
17:08:58 <lambdabot>   "OK, passed 500 tests."
17:09:16 <ghorn_> help with GADTs? http://stackoverflow.com/questions/10746926/type-problems-when-recovering-gadt-from-adt
17:09:29 * applicative is glad to find lambdabot is a fellow spinozist
17:17:08 <parcs`> @check True
17:17:09 <lambdabot>   "OK, passed 500 tests."
17:17:38 <parcs`> @check otherwise
17:17:39 <lambdabot>   "OK, passed 500 tests."
17:18:39 <parcs`> @check id
17:18:40 <lambdabot>   "Arguments exhausted after 0 tests."
17:18:57 <parcs`> hey, you're supposed to unify to Bool -> Bool
17:19:18 <parcs`> @check (id :: Bool -> Bool)
17:19:19 <lambdabot>   "Falsifiable, after 1 tests:\nFalse\n"
17:24:23 <Saizan> ghorn_: one option would be to have maybegexprOfExpr :: Expr -> Maybe (GExpr sh) as a method of Shape
17:26:19 <Saizan> ghorn_: others are available if you are ok with making a gadt for shapes, which means you have to decide on a fixed "grammar" for them though
17:27:40 <ghorn_> Shape is from repa so I'd make a wrapper either way
17:27:48 <ghorn_> what are other options?
17:38:07 <Saizan> well, you can have a data RShape sh where RDIM0 :: RShape DIM0; RDIM1 :: RShape DIM1; ..
17:38:07 <Saizan> gexprOfExpr :: RShape sh -> Expr -> Maybe (GExpr sh); gexprOfExpr RDIM0 (ESum lsh k) = Just (GSum $ GRef (shapeOfList lsh) k) etc..
17:38:07 <Saizan> using Nothing when the RShape given doesn't match the value of Expr given
17:38:09 <Saizan> here you're doing type-checking, essentially
17:38:09 <Saizan> you could also do type-inference with a type like data AnyGExpr where AnyGE :: RShape sh -> GExpr sh -> AnyGExpr
17:38:09 <Saizan> and gexprOfExpr :: Expr -> AnyGExpr
17:38:09 <Saizan> you might also get away without the RShape sh field in AnyGExpr, depending on if the function you're going to call on the GExpr is polymorphic enough
17:38:09 <Saizan> but you might want to add a Shape sh => in there though
17:38:09 <Saizan> ghorn_: am i making sense?
17:41:30 <ptrf> 17
17:41:32 <ptrf> hov
17:41:39 <ptrf> oh, sorry...
17:42:38 <sipa> ?
17:44:41 --- mode: holmes.freenode.net set +o ChanServ
17:45:01 <applicative> rata_ I dont think anyone can answer the question in the abstract except as monochrom did
17:45:32 <rata_> applicative: well, you are right
17:45:39 <rata_> why so many server splits
17:45:54 <applicative> lightening somewhere
17:46:01 <rata_> hahahaaha
17:46:47 <rata_> but it seems quite difficult to make a minimal example
17:46:56 <rata_> well, at least it works when optimized
17:47:17 <rata_> it's just that it would be so nice if it worked in both cases
17:47:52 <applicative> its many modules? I mean so you cant just paste it?
18:01:55 <rata_> this is the offending function: https://github.com/rhz/thermokappa/blob/master/Types.hs#L67
18:05:34 <qtplatypus> >  "abc" >>= (:"123")
18:05:35 <lambdabot>   "a123b123c123"
18:05:54 <qtplatypus> Why does the list monad work like that?
18:06:14 <geekosaur> @src [] (>>=)
18:06:15 <lambdabot> xs >>= f     = concatMap f xs
18:08:47 <geekosaur> apply all members of the list to the operation, dropping any that fail; this acts as a selection or winnowing operation, allowing you to collect all valid results from all operations; combined with laziness this gives you what is effectively backtracking
18:14:46 <qtplatypus> geekosaur: Thanks very healpful
18:49:16 <ku> what is the generally community opinion on abbreviated function names like: putStrLn
18:49:39 <ku> in terms of crypticness vs typability
18:49:47 <ku> or rather readability vs typeability
18:50:24 <ku> so far my take is that haskell has a bias toward cryptic, fst vs first for instance
18:50:34 <geekosaur> this is a community that likes x:xs for variables... short is popular as is cryptic
18:51:40 <ku> kind of a shame IMO, it makes the language appear more intimidating than it actually is at times
18:52:05 <ku> and literally harder to undertand in other cases
18:52:13 <ku> to learn, anyway
18:52:17 <dmwit> I dunno.
18:52:23 <dmwit> I think the more modern libraries use better names.
18:52:24 <monochrom> libraries on hackage tend to have longer exported names. I think the common style is longer names for larger scope, shorter names for smaller scope
18:53:00 <dmwit> I think the Prelude was just written before there was a really good understanding of what the Haskell aesthetic ought to be for readability, etc.
18:53:04 <ku> monochrom: that heuristic is sane enough, I don't mind that
18:53:26 <ku> I can understand stuff like x:xs
18:53:41 <ku> just the fst, putStrLn, etc. that get under my skin =p
18:53:54 <ku> dmwit: ah ok
18:53:55 <dmwit> Put Prelude.Ku up on Hackage and start using it. =)
18:53:55 <Saizan> compare 1st and fst
18:54:36 <ku> nice comparison, but that doesn't really make it demo better
18:54:59 <ku> fst on its own could just as well be a mechanical term for car engines
18:55:26 <ku> snd seems like send
18:56:04 <ku> not to complain too much, I was mostly interested in getting a sense for idiomatic haskell
18:56:36 <parcs`> well 'first' and 'second' are taken elsewhere in the stdlib
18:56:45 <parcs`> so what do you suggest, fstTuple and sndTuple?
18:56:46 <ku> dmwit: maybe I will?! =p
18:56:57 <parcs`> or firstTuple* and ...
18:57:22 <dobblego> regardless of name, I wish fst :: (a, b) @> a instead of (a, b) -> a
18:57:24 <ku> parcs`: well then your ahead of me, haven't gotten there yet, I wouldn't posit that I have a better system
18:57:58 <rwbarton> -ln is an old convention
18:58:00 <geekosaur> it might be worth noting that, given that only 2-tuples are supported like that and they're already considered to be somewhat obfuscated compared to an appropriate ADT, fst/snd might be a misplaced concern
18:59:10 <covi_> I have a vague explanation why the solution to exercise 4 here (http://blog.sigfpe.com/2007/04/trivial-monad.html) is join x = x >>= id, but I'm not sure. Can somebody help me sort it through?
18:59:12 <ku> geekosaur: certainly: I was wondering more if the crypticness continues throughout haskell or not
18:59:35 <ku> the answer seems to be... in modern haskell "no"
18:59:54 <geekosaur> in some ways yes, in some ways no.  most of it is abbreviations that are at least well understood in the mathematical community
19:00:20 <dmwit> covi_: Don't ask to ask, just ask.
19:01:04 <covi_> dmwit: okay
19:01:12 <rwbarton> stuff like (>>=) is "cryptic" I guess but the name is not the hard part of understanding it
19:02:11 <pharaun> as long as you don't approach java or objective-c level of verboseness a little bit of verboseness can be a good thing
19:02:14 <covi_> since id :: a -> a, and bind :: (a -> W b) -> W a -> W b. I am assuming that Haskell first infers a = W b, so therefore (W a) = W (W b), therefore the join function returns the unwrapped (W b).
19:03:11 <dmwit> That explains the types, yep. Do you have an explanation of the behavior?
19:03:29 <rwbarton> covi_: yes. well, "unwrapped" makes me a bit uncomfortable, more like ... "joined"
19:03:36 <ku> rwbarton: for sure, anyways in the case of symbols I consider them quite apart from A-z function names
19:03:41 <dmwit> I guess the question isn't really about behavior.
19:04:06 <covi_> dmwit: behavior? can you please explain a bit?
19:04:17 <parcs`> dobblego: what does that mean?
19:04:22 <ku> pharaun: I would just focus on making it read well, and not thinking about other arbitrary criteria
19:04:26 <covi_> rwbarton: I don't get why "joined" is a more appropriate name here
19:04:48 <dobblego> er sorry, mixing languages
19:04:55 <rwbarton> ... is it bad that i think a burrito analogy is actually appropriate here
19:04:56 <dmwit> covi_: I was sort of asking what you thought this function actually *does*, now that you know the types happen to work out. =)
19:04:56 <pharaun> ku: i was just poking fun :)
19:05:00 <dobblego> type (@>) a b = Lens b a
19:05:16 <pharaun> i generally prefer it to read well and if that leads it to be a little verbose that works for me
19:05:19 <ku> pharaun: =)
19:05:24 <parcs`> ah
19:05:44 <pharaun> but just need to be careful that you don't end up with foobarMovesThisFunctionOverThereBecauseWeCanDoSo() kind of thing
19:05:48 <rwbarton> "unwrapped" sounds like you are taking one of the Ws and throwing it away, but actually you're smushing the two Ws together
19:06:02 <dmwit> covi_: But I retracted my question, because it's too hard to answer without choosing a particular monad to talk about.
19:06:35 <covi> dmwit: Well, it "unwrapps"  one layer of a monadic type
19:06:36 <geekosaur> it's in some ways more like lifting than smushing or unwrapping
19:06:40 <rwbarton> no it doesn't unwrap
19:06:48 <rwbarton> sorry, it is hard to explain
19:07:01 <ku> pharaun: I've played with differing lengths of function names and often if I start letting things get too long it's actually quite a bit harder to read. The spaces " " used for function invocation become overwhelmed in a sea of letters, and the generally the signal-to-noise ratio gets worse, etc.
19:07:24 <pharaun> yeah that's my problem too :\
19:07:32 <rwbarton> let us take the list monad [] as an example
19:07:50 <ku> pharaun: usually a shorter and more descriptive name exists, it just takes time to discover =)
19:08:14 <rwbarton> if i have [[a]] I can view that as a two-step process producing an a where i make a choice at each step
19:08:28 <rwbarton> when i apply join, i make both choices at once
19:08:32 <rwbarton> to get something of type [a]
19:08:40 <pharaun> ku: indeed, again, naming is a hard thing :)
19:08:48 <rwbarton> but the two choices are still there, they're just combined into one step
19:09:16 <covi> rwbarton: this explanation is clear to me
19:09:21 <rwbarton> good :)
19:09:25 <covi> but I still don't get why "unwrap" is a bad choice
19:10:00 <rwbarton> unwrap sounds like an operation like W a -> a
19:10:35 <rwbarton> here that might be something like "take the first choice" (if there is one, otherwise undefined)
19:10:36 <covi> so W (W a) -> W a or a more layed thing shouldn't be called as unwrap?
19:10:53 <geekosaur> not when you can't remove all the layers that way, no
19:10:54 <rwbarton> well the type W (W a) -> W a does not determine a single operation...
19:11:02 <rwbarton> the one that joins layers is called "join"
19:11:08 <Drakeson> I am having trouble with ghc in my setup, and it cannot find most modules.  How can I find out which paths are searched for the modules?
19:11:13 <covi> i see
19:11:17 <covi> this is clear now, thanks
19:11:20 <rwbarton> if you happen to have an operation of type forall a. W a -> a then you can write down at least two more operations
19:12:03 <rwbarton> for example, if i take head :: [a] -> a, i can build head :: [[a]] -> [a] or map head :: [[a]] -> [a]
19:12:16 <rwbarton> these are more like "unwrapping" one of the two layers
19:12:53 <monochrom> Drakeson: ghc does not search directories. it just reads a metadata file, end of story. use "ghc-pkg list" to see what packages you have. see my http://www.vex.net/~trebla/haskell/sicp.xhtml for the full story
19:13:13 <covi> rwbarton: i see
19:13:50 <Drakeson> monochrom: Thanks :)
19:16:02 <ku> how do I run a haskell script in a shell session?
19:16:37 <ku> oh i see I can pass ghci a file?
19:16:49 <rwbarton> runhaskell/runghc
19:16:51 <geekosaur> runhaskell foo.hs # or runghc foo.hs; dependong on what and how you installed stuff, runhaskell might choose a different default implementation
19:17:06 <ku> ok thanks
19:30:54 <JoeyA> In a GADT declaration (e.g. data T a b where), do the type variables here have any correspondence to those that appear in constructor signatures?
19:31:21 <JoeyA> Or would "data T sea food where" be equivalent?
19:32:15 <BMeph> JoeyA: It depends.
19:41:17 <hpaste> “Jason Kuhrt” pasted “Interactive triangle area” at http://hpaste.org/68988
19:41:45 <hpaste> “Jason Kuhrt” pasted “Interactive triangle area” at http://hpaste.org/68989
19:42:06 <ku> Can anyone offer a suggested improve to ^
19:42:18 <ku> improvement*
19:42:47 <ku> the location of the read invocation seems suboptimal, I was hoping to be able to do something like:
19:43:03 <ku> base = read <- getLine
19:44:10 <rwbarton> as it so happens there is readLn for this purpose
19:44:13 <rwbarton> @src readLn
19:44:13 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
19:44:26 <rwbarton> or you can write
19:44:32 <rwbarton> base <- fmap read getLine
19:45:26 <ku> rwbarton: thanks, I had tried readLine
19:47:57 * hackagebot yaml 0.7.0.2 - Low-level binding to the libyaml C library.  http://hackage.haskell.org/package/yaml-0.7.0.2 (MichaelSnoyman)
19:49:18 <JoeyA> Hmm, it'd be nice if a default method implementation could implement a function for some data constructors of a type, and leave implementation of the rest to the instance method.
19:49:51 <dmwit> BMeph: Really? On what?
19:49:58 <dmwit> I thought the variables were just unrelated.
19:50:04 <dmwit> no "depends"
19:51:26 <dmwit> JoeyA: The usual trick is to write a "fooDefault" which handles some of the constructors and call it as a last case in the real instance declaration.
19:51:49 <dmwit> e.g. instance Foo Bar where foo (Baz x) = bleh; foo otherwise = fooDefault otherwise
19:51:58 <JoeyA> dmwit: Well, then I lose compile-time exhaustiveness checking...
19:52:00 <aavogt> maybe involving template-haskell will let you re-gain some checking
19:52:23 <dmwit> Yes, that's true.
19:52:27 <JoeyA> Unless the GADT implementation is smart enough to treat the pattern 'x' as "any pattern for which the RHS accepts the type of x"
19:52:42 <aavogt> maybe it's not worth it (since your warnings will not be very understandable since they will not correspond to code you actually write)
19:53:03 <JoeyA> Then I could make the default function rank-2.
19:54:46 <zachk> is there a way to define an operator (+*+)::Int->Double->Double and also as (+*+):Double->Int->Double ?
19:55:19 <dmwit> Yes, use a multi-parameter typeclass or type families.
19:55:42 <aavogt> you end up writing two definitions (plus the class)
19:55:55 <zachk> thank you
19:56:12 <dmwit> Oh, it can be even simpler in this case, though.
19:56:39 <aavogt>   "class C a b c | a -> b, b -> a, a b -> c" can be expressed as a type family?
19:56:54 <dmwit> class CastsToDouble a where cast :: a -> Double; x +*+ y = cast x + cast y
19:57:22 <aavogt> that's allows  +*+ :: Double -> Double -> Double, doesn't it
19:57:31 <dmwit> Yes. Is that a problem?
19:57:43 <aavogt> no idea, it might be
19:58:12 <dmwit> aavogt: Those functional dependencies certainly can be.
19:58:21 <dmwit> class C a where type family B a; type family C a
19:58:40 <dmwit> I guess you lose the b -> a dependency.
19:58:41 <dmwit> hum
20:01:41 <Gurragchaa> @src last
20:01:41 <lambdabot> last [x]    = x
20:01:41 <lambdabot> last (_:xs) = last xs
20:01:42 <lambdabot> last []     = undefined
20:01:58 <Gurragchaa> beautiful
20:02:16 <Gurragchaa> stuff like this is what makes me excited to learn Haskell
20:03:16 <DallaRosa> hello. haskell newb here
20:03:16 <dmwit> aavogt: type family From b; type family To a; class (From (To a) ~ a) => Foo a where type family C a
20:03:59 <dmwit> You can stick the To type family inside the class if you prefer.
20:04:29 <dmwit> DallaRosa: howdy
20:05:01 <DallaRosa> started the tryhaskell tutorial and they mentioned a haskell channel on freenode
20:05:09 <DallaRosa> so I decided to check it out :)
20:05:36 <aavogt> so when you define the (+*+) you get the same inference as with the fundeps by specifying something like: (From a ~ b) => a -> b -> c
20:05:47 <Gurragchaa> so what happens when last [] returns undefined?  Does execution halt?
20:06:00 <DallaRosa> never done functional programming but realized I've gotta expand my horizons
20:06:06 <dmwit> (+*+) :: a -> To a -> C a
20:06:16 <aavogt> Gurragchaa: you get an exception that you probably won't catch
20:06:17 <dmwit> (+*+) :: Foo a => a -> To a -> C a -- I mean
20:07:10 <aavogt> in which case your program will exit with a rather unhelpful error message when you decide to look at what (last x) actually is
20:07:23 <aavogt> > "hi dalla" ++ last []
20:07:24 <lambdabot>   "hi dalla*Exception: Prelude.last: empty list
20:07:58 * hackagebot network-enumerator 0.1.3 - Enumerators for network sockets  http://hackage.haskell.org/package/network-enumerator-0.1.3 (JohnMillikin)
20:08:27 <aavogt> dmwit: do you think in type families, or in functional dependencies?
20:08:37 <dmwit> no =)
20:09:50 <aavogt> well did you think of this To and From in terms of what the fundeps I wrote, or in terms of what the fundeps actually accomplish in terms of type inference
20:10:06 * aavogt isn't really sure there's much of a distinction there
20:10:35 <dmwit> I started from your fundeps, but only because that's what you asked for, not because they fundeps made sense to me.
20:11:48 <aavogt> so to re-phrase the original question "how do I make a class that has as-far-as-possible only these two instances (+*+)::Int->Double->Double and also as (+*+):Double->Int->Double"
20:12:38 <aavogt> aso to re-phrase the original question "how do I make a class that has instances with only these two methods with maximum type inference (+*+)::Int->Double->Double and also as (+*+):Double->Int->Double"
20:13:54 <dmwit> Well, it really is unclear what the right generalization is from just those two examples.
20:14:05 <mzero> hi DallaRosa, welcome to the channel - feel free to come ask questions as you go through it
20:14:14 <mzero> after try haskell - try LYAH
20:14:17 <mzero> @where LYAH
20:14:17 <lambdabot> http://www.learnyouahaskell.com/
20:14:40 <aavogt> dmwit: no generalization! Just accept the two examples
20:15:55 * BMeph is amused by people that try to answer what they think is the next question you will ask, when you ask a question... :)
20:16:13 <dmwit> BMeph: I'm not even talking to zachk any more, just exploring. =)
20:16:29 <mzero> BMeph: speculative execution
20:16:50 <dmwit> aavogt: If I take exactly those two lines with no generalization, my answer is: type error.
20:17:17 <dmwit> aavogt: If I've assigned (+*+) the monomorphic type Double -> Int -> Double, I can't also assign it another (different) monomorphic type.
20:17:29 <dmwit> So to make the question sensible, we must agree that it must be generalized somehow.
20:18:11 <BMeph> dmwit: I thought you were talking to aavogt...ah, I don't think you've got it yet. ;þ
20:18:20 <dmwit> My suggestion: (+*+) :: (ToDouble a, ToDouble b) => a -> b -> Double -- is not clearly wrong. Your suggestion is not clearly wrong either.
20:18:55 <BMeph> mzero: More like pre-emptive cache-dumping...with all of the performance penalties it implies. ;)
20:20:36 <dmwit> aavogt: Here's another suggestion that's not clearly wrong: type family Swap a; type instance Swap Int = Double; type instance Swap Double = Int; class (Swap (Swap a) ~ a) => Add a where add :: (Swap a ~ b) => a -> b -> Double
20:21:22 <dmwit> (But it generalizes in a very different direction from the other two!)
20:21:39 <copumpkin> :O
20:22:35 <aavogt> hmm, the actual implementation of Swap could end up rounding
20:22:54 <dmwit> what?
20:23:00 <dmwit> Swap is a type function. How do you round types?
20:23:49 <crdueck> how do i derive my own instances of typeclasses like Ord? for example, for lists, min is determined by the sum of the lists, not lexicographically?
20:23:50 <copumpkin> by having type-level computable reals!
20:23:59 <copumpkin> and type-level doubles, if not
20:24:06 <dmwit> =D
20:24:16 <dmwit> crdueck: Make a newtype.
20:24:22 <copumpkin> although I don't think you can round computable reals, at least not to integers
20:24:37 <copumpkin> oh, I guess you can
20:24:55 <dmwit> Sure, pass it a claim that you want zero digits after the decimal point. =)
20:25:02 <dmwit> or one
20:25:38 <aavogt> but as usual some won't be computable in a reasonable time
20:26:13 <crdueck> dmwit: i cant supply a new ordering for lists?
20:26:21 <dmwit> No.
20:26:44 * aavogt needs to experiment a little with that Swap to see that working
20:29:35 <dmwit> crdueck: I should modify my answer a bit: the answer is only "no" if we're talking practically.
20:29:46 <dmwit> If you don't import any module that uses the current Ord instance for lists, then you can define your own.
20:29:59 <dmwit> But that's a bit theoretical, since the Prelude (and hence practically everything) has the Ord instance for lists.
20:30:11 <dmwit> For library types this may be workable, but in practice you just make a newtype.
20:33:23 <aavogt> dmwit: there's one case where it doesn't play nicely with defaulting http://hpaste.org/68990
20:34:54 <dmwit> I'd call that a GHC bug actually.
20:35:16 <dmwit> It's not an occurs check failure, because unification doesn't apply to type families.
20:35:21 <dmwit> It still shouldn't compile, though. =)
20:35:33 <dmwit> (Side note: your MPTC with FD doesn't compile that either.)
20:35:43 <aavogt> yep just noticed that
20:35:55 <aavogt> there must be a way to make the FD work
20:36:08 <dmwit> It's not really related to defaulting.
20:37:09 <aavogt> my naive understanding of type classes is that you could be able to choose an instance that would otherwise be ambiguous without defaulting
20:38:00 <dmwit> Hm, I'm not really sure how defaulting and MPTCs go together.
20:38:53 <hpaste> “Joey Adams” pasted “Spurious "non-exhaustive" warning with GADTs and newtype” at http://hpaste.org/68991
20:39:04 <JoeyA> Is this related to #3927 ?
20:39:32 <JoeyA> Namely, I get "Pattern match(es) are non-exhaustive" for patterns that are impossible to implement when I use newtypes.
20:39:49 <JoeyA> If I use 'data' instead of 'newtype', I don't get that warning.
20:40:02 <dmwit> aavogt: Only numeric classes get defaulted.
20:40:12 <JoeyA> (this is on GHC 7.4.1)
20:40:26 <dmwit> aavogt: (According to section 4.3.4 of the Report.)
20:40:44 <dmwit> aavogt: So these new classes we're defining will never have defaulting applied to them.
20:41:57 <aavogt> there's still a Num a => involved somewhere because of the literals used
20:42:11 <aavogt> but I guess you're right that it doesn't apply
20:43:31 <dmwit> "An ambiguous type variable v is defaultable if: 1. v appears only in constraints of the form C v, where C is a class" <- we're already hosed by this one
20:44:02 <dmwit> "2. at least one of these classes is a numeric class, and 3. all of these classes are defined in the Prelude or a standard library." <- for completeness
20:44:40 <crdueck> dmwit: i see that i need to define either compare or (<=) for an order instance. I see lots of examples for an Eq instance but i cant find any for Ord. Could you show me how I'd define (<=) so that the lists are compared by the sum of their elements?
20:45:03 <dmwit> xs <= ys = sum xs <= sum ys
20:45:07 <dmwit> well
20:45:19 <dmwit> SumList xs <= SumList ys = sum xs <= sum ys
20:46:03 <crdueck> where SumList is the constructor for the new data type i've made?
20:46:13 <dmwit> right
20:46:16 <crdueck> okay thanks
20:48:01 * hackagebot hack2-interface-wai 2012.5.25 - Hack2 interface of WAI  http://hackage.haskell.org/package/hack2-interface-wai-2012.5.25 (JinjingWang)
20:50:00 <JoeyA> (this is on GHC 7.4.1)
20:50:07 <JoeyA> whoops
20:54:14 <dmwit> JoeyA: Not sure whether it's related to #3927, but it definitely looks like a bug.
20:54:29 <JoeyA> dmwit: I'm writing a bug report now.
21:03:02 * hackagebot hack2-handler-warp 2012.5.25 - Hack2 warp handler  http://hackage.haskell.org/package/hack2-handler-warp-2012.5.25 (JinjingWang)
21:07:47 <dmwit> aavogt: http://hackage.haskell.org/trac/ghc/ticket/6123
21:16:10 <zzing> @src or
21:16:10 <lambdabot> or    =  foldr (||) False
21:16:55 <zzing> Is there a way to have two predicates such as (=="cs") and (=="bs") and compose them together so that I could have a predicate that tests for equality of the same parameter with "cs" or "bs"?
21:17:29 <Clint> yes
21:17:46 <JoeyA> (`elem` ["cs", "bs"])
21:18:16 <zzing> @src elem
21:18:16 <lambdabot> elem x    =  any (== x)
21:18:21 <JoeyA> :t liftA2 (&&) (== "cs") (== "bs")
21:18:22 <lambdabot> [Char] -> Bool
21:19:15 <zzing> :t any
21:19:16 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
21:19:44 <zzing> @src any
21:19:45 <lambdabot> any p =  or . map p
21:19:56 <parcs`> hmm, i wonder if given 'data Foo a b = Foo a b' and 'data Bar a b = Bar a b' whether 'f :: Foo a b -> Bar a b' is a no-op
21:20:17 <dmwit> parcs`: It depends how f is implemented.
21:20:23 <dmwit> f (Foo a b) = Bar a b -- not a no-op
21:20:29 <dmwit> f = unsafeCoerce -- a no-op
21:20:36 <parcs`> hmm, yeah
21:21:01 <parcs`> ghc theoretically could turn it into a no-op
21:21:03 <zzing> :t or . map
21:21:04 <lambdabot>     Couldn't match expected type `[Bool]'
21:21:04 <lambdabot>            against inferred type `[a] -> [b]'
21:21:04 <lambdabot>     Probable cause: `map' is applied to too few arguments
21:22:40 <mzero> parcs`: I don't think GHC could turn that into a no-op unless they were both newtypes
21:23:06 <parcs`> well, right now it can't
21:23:15 <mzero> Well.. perhaps it could - if the tag value for Foo and Bar ended up the same
21:23:27 <zzing> :t elem
21:23:28 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
21:23:53 <parcs`> yeah i guess that's a +1 for newtypes
21:29:53 <dobblego> is there a library on top of System.Directory that does something better than throw an exception for e.g. createDirectory?
21:31:49 <dmwit> Like what?
21:31:55 <dmwit> There's createDirectoryIfMissing.
21:37:00 <dobblego> like return a data type of possible errors instead
21:42:16 <dmner> hey guys I am having a problem installing some packages with cabal (namely hlint and its dependencies)
21:42:35 <hpaste> dmner pasted “package conflicts” at http://hpaste.org/68995
21:42:38 <dmwit> dobblego: I don't think so.
21:42:50 <dobblego> ok ta
21:43:21 <dmwit> You reinstalled libraries that came with GHC. Don't do that.
21:43:37 <dmwit> Undo it now if you can, or reinstall GHC if you can't.
21:44:23 <dmner> wondering how that happened, but alright so I've done a ghc-pkg and the user/system lists only overlap on binary and bytestring
21:45:24 <hpaste> llayland pasted “help with functional dependency” at http://hpaste.org/68996
21:51:17 <dmner> so dmwit, I removed binary and bytestring and all dependent libraries so user/global ghc-pkg lists are completely different
21:51:31 <dmner> so it now tries to compile
21:52:11 <dmner> but no good
21:52:13 <dmner> ok time to reinstall ghc
21:53:18 <dmwit> llayland: You might like something like "instance (args ~ (a,b), ret ~ c) => PairFunc (a -> b -> c) args ret"
21:53:19 <llayland> I'm having  a bit of trouble with fundeps. http://hpaste.org/68996  would anybody mind taking a look?
21:53:26 <dmwit> not sure if the ret equality is necessary
21:53:50 <llayland> that was quick
21:57:18 <llayland> I'm not familiar with the tilde in in the instance contstraints,  can you give me a keyword to google?
22:00:05 <dmner> llayland: equality constraint I think
22:00:13 <dmner> http://www.haskell.org/haskellwiki/GHC/Type_families#Equality_constraints
22:01:40 <llayland> ah, I hadn't gotten to type families yet.  Thanks dmwit and dmner.  off to do more reading
22:02:29 <dmner> I may be wrong btw
22:02:55 <dmner> then again I can tag everything I say with that (or should tag everything I say)
22:03:56 <dmwit> You're not wrong.
22:05:13 <dmner> awesome, also reinstalling ghc and all my libs solved the problem
22:12:47 <andares> is the Galois company a big player in the Haskell world?
22:13:04 <ezyang> Yep
22:20:50 <andares> I think I'm going to go unpack cabal packages to just read the code and get a sense for it.
22:37:35 <solidus-river> if i'm doing in import as part of a module, where should i put the import line?
22:37:46 <solidus-river> inside the where for the module exports or before
22:38:18 <aavogt> you can't put an import before the where that follows module
22:38:31 <solidus-river> well i meant before the module definition i guess
22:38:52 <dmwit> Q: "Where should I put an import?" A: "If GHC accepts it, you put it in the right place."
22:39:10 <JoeyA> solidus-river: You mean, to have your module re-export said module?
22:39:22 <solidus-river> http://www.pastie.org/3964721
22:39:36 <solidus-river> haha, here, is there a slicker way to do that qualified import which the module requires i guess is my question
22:40:07 <dmwit> "slicker"?
22:40:21 <dmwit> Can you give a more objective way to judge alternative imports?
22:40:21 <solidus-river> arguably better
22:40:38 <dmwit> No, there is no better way.
22:44:04 <aavogt> solidus-river: you could tell the people who use your module to also import Data.Foldable as F, then refer to F.product, F.sum etc. which I think you've unnecessarily re-written
22:44:46 <dmwit> Seems like that file has a number of errors.
22:44:59 <aavogt> in which case your module should only contain (and export) the type definition and foldable instance
22:45:03 <dmwit> fromList and toList's types look particularly suspect.
22:45:03 <solidus-river> dmwit: where? i just added the sum prod contains and toList functions
22:45:13 <aavogt> @hoogle toList
22:45:14 <lambdabot> Data.HashTable toList :: HashTable key val -> IO [(key, val)]
22:45:14 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
22:45:14 <lambdabot> Data.Text.Array toList :: Array -> Int -> Int -> [Word16]
22:45:28 <dmwit> Also, I would have expected the import to be Data.Foldable, not just Foldable.
22:46:22 <solidus-river> oh your right toList is very wrong, and so is fromList :X going through learn you a haskell so i havent actually tried compiling or running this
22:46:49 <dmwit> How does "I haven't tried compiling this" follow from "I'm going through LYAH"?
22:46:52 <solidus-river> fromList :: (Ord a) => [a] -> Tree a
22:47:25 <aavogt> why do you think that definition is wrong?
22:47:39 <dmwit> definition is fine; type is weird
22:48:07 <solidus-river> dmwit: is the type i just "typed" (teehee) more correct?
22:48:19 <solidus-river> or am i missing something larger
22:48:44 <dmwit> Yes, it looks better.
22:49:20 <dmwit> > (0/0)
22:49:21 <lambdabot>   NaN
22:49:28 <dmwit> > compare (0/0) (0/0)
22:49:29 <lambdabot>   GT
22:52:02 <aavogt> solidus-river: maybe you know this already, but you don't have to give type signatures most of the time
22:52:48 <aavogt> you can get ghci to do some of the thinking for you, since it can tell you what types your functions seem to have
22:53:02 <solidus-river> aavogt: yeah, but the tutorial said it was good for documentation which so far I definitely agree with, and in either case its good while i'm first learning to keep me on my toes
22:53:41 <aavogt> (which in some cases are not the ones you expect; maybe because they can be more general, or because there's a mistake/inconsistency in the code)
23:12:55 <jonaskoelker> I'm trying to write a probability distribution monad;  I want (Map a Rational) to be a Monad instance, but the (Ord a) requirement from Map appears to not be compatible with this.  Is there a (canonical?) way around this?
23:14:15 <solidus-river> I'm confused, in waht order is "(*) <$> [1] <$> [6] <$> [3]" evaluated?
23:14:26 <solidus-river> whoa, scratch that, typo
23:14:35 <solidus-river> I'm confused, in waht order is "(*) <$> [1] <*> [6] <*> [3]" evaluated?
23:15:00 <solidus-river> is that even a valid statement?
23:15:03 <solidus-river> would thatn produce
23:15:14 <solidus-river> [1*] <*> [6]
23:15:15 <solidus-river> then
23:15:30 <solidus-river> [6] <*> [3]
23:15:33 <solidus-river> and that would be nonsense?
23:15:47 <jonaskoelker> > (*) <$> [1] <*> [6]
23:15:48 <lambdabot>   [6]
23:15:53 <jonaskoelker> > [6] <*> [3]
23:15:54 <lambdabot>   [6]
23:16:04 <jonaskoelker> solution: try it and see :-)
23:16:08 <solidus-river> why is [6] <*> [3] 6?
23:16:10 <solidus-river> er
23:16:13 <solidus-river> [6]
23:16:29 <solidus-river> > (*) <$> [1] <*> [6] <*> [3]
23:16:30 <lambdabot>   [6]
23:16:32 <jonaskoelker> @src <*>
23:16:32 <lambdabot> Source not found.
23:16:36 <jonaskoelker> @src (<*>)
23:16:37 <lambdabot> Source not found. stty: unknown mode: doofus
23:16:47 <jonaskoelker> ^_^
23:16:50 <jonaskoelker> bug in bot?
23:16:51 <geekosaur> both (<$>) and (<*>) are left associative
23:17:21 <geekosaur> no, @src is just an old database predating Control.Applicative (and somewhat sparse in its coverage of anything not in the Haskell '98 Prelude)
23:17:45 <geekosaur> dunno if anyone's interested in updating it; I'm under the impression the bot's codebase is becomeing a bit musty...
23:18:28 <jonaskoelker> I was more thinking "ssty: unknown mode: doofus"
23:18:38 <jonaskoelker> stty even.  Am I poking at some command line?
23:19:08 <solidus-river> i'm not going to try it but i wonder how it would handle a request to evaluate an infinite list :P
23:19:09 <ChristianS> lambdabot is just trying to be funny
23:19:19 <jonaskoelker> oh.  Phew :)
23:19:24 <geekosaur> no, the bot was written originally by an openbsd junkie, and he used the openbsd password-incorrect insults as error messages
23:19:30 <ChristianS> @botsnack
23:19:30 <lambdabot> :)
23:19:58 <jonaskoelker> is it some kind of tamabotchi?
23:20:24 <geekosaur> solidus-river, it has both a timeout and an output limit
23:20:24 <solidus-river> ooo, lets play the left right game!
23:20:31 <geekosaur> > [1..]
23:20:32 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
23:20:49 <jonaskoelker> left right game?
23:21:28 <solidus-river> tamagotchi, one of the staple ways to make your pet happy without making it fat or sick, you guess if it is thinking left or right and if you get it right it get excessively happy
23:21:32 <solidus-river> :)
23:22:03 <jonaskoelker> so there's an O(2) algorithm for making it one unit happier?
23:22:48 <solidus-river> jonaskoelker: well you'd have to initiate the game first, but ones its runnin i guess so, but you could make it less happy to, so it would be an (2) algorithm for modifying its state of happiness
23:22:59 <solidus-river> * O(2) :P
23:23:12 <jonaskoelker> while we're OT, here's an appalingly bad joke: "what do you mean 'not your type', I'm Either Man Woman!"
23:23:47 <jonaskoelker> oh, it gets correspondingly less happy if I make a wrong guess?
23:23:52 * solidus-river just got spittle on monitor laughing too close to screen
23:23:56 <solidus-river> jonaskoelker: yeah
23:24:49 <jonaskoelker> print that on a shirt and you can out-nerd even xkcd ^_^
23:53:53 <MaskRay> :m + Data.Generics.Uniplate Data.Generics.Multiplate
23:53:57 <MaskRay> :i Uniplate
23:54:03 <MaskRay> Top level: Not in scope: data constructor `Uniplate'
23:54:25 <MaskRay> what's the matter? the latter module shadows Uniplate?
