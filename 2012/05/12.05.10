00:00:17 <yitz> or rather one that is still unfixed
00:20:43 <Peaker> reading the above question about hiding with qualified imports finally made me realize what the point of "hiding" in a qualified import is
00:21:25 <Peaker> I think all the unknown-namespace-mergers supported in Haskell are a mistake.  Just require only known subsets of namespaces to be merged or don't perform a merge at all
00:21:34 <Peaker> Parsec can be P, and ParserCombinators can be PC
00:38:17 * hackagebot sbv 2.0 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  http://hackage.haskell.org/package/sbv-2.0 (LeventErkok)
00:48:25 <bartavelle> I wrote a library that is extremely slow. I would like to profile it, "cabal install -p"'ed it, but the .prof files only shows my dummy Main function as using 100% CPU and some functions from the other libs
00:48:32 <bartavelle> everything but mine actually
00:48:40 <bartavelle> did I forget something when building it ?
00:52:33 <Lemmih> bartavelle: -auto-all
00:52:58 <bartavelle> i already do ghc -prof -rtsopts -auto-all -caf-all -fforce-recomp
00:53:19 <Lemmih> bartavelle: For the library as well?
00:53:33 <bartavelle> no but I build it with cabal
00:53:39 <bartavelle> should I alter my cabal file ?
00:53:43 <bartavelle> I guess so
00:53:44 <Lemmih> bartavelle: GHC-Prof-Options: -auto-all
00:53:51 <bartavelle> ah thanks
00:54:32 <Lemmih> -auto-all is quite aggressive and won't give good results in all cases. That's why it isn't on by default.
00:55:21 <bartavelle> ah yes much better
01:00:59 <Lolcats4Purity> Question time. How do I define my own "polymorphic values" in the same way 2 is a (Num t) => t?
01:02:50 <Cale> Well, the numeric literal 2 is special syntax for  fromInteger (2 :: Integer)
01:03:42 <Cale> Lolcats4Purity: So, the answer is just to make a typeclass which creates a value of the type that it's parametrised by
01:04:09 <Cale> s/which creates/with a method that creates/
01:05:47 <Lolcats4Purity> Cale: Okay, thanks.
01:05:54 <Lolcats4Purity> :)
01:12:48 <Ngevd> Hello
01:13:18 * hackagebot jack 0.6.2 - Bindings for the JACK Audio Connection Kit  http://hackage.haskell.org/package/jack-0.6.2 (HenningThielemann)
01:28:19 * hackagebot edenmodules 1.1.0.1 - Semi-explicit parallel programming library  http://hackage.haskell.org/package/edenmodules-1.1.0.1 (MischaDieterle)
01:42:58 <berdario> Hello, I want to write a function Maybe Integer -> (a->b) -> (a->b) like python's lru_cache http://docs.python.org/dev/library/functools.html#functools.lru_cache
01:43:47 <berdario> I'm attempting a project euler problem, I started with python, but then I thought that it may be easier to write it in haskell... it was fine until I had to memoize the results
01:43:58 <berdario> I read the relevant wiki page: http://www.haskell.org/haskellwiki/Memoization
01:45:49 <lamefun2> Is there a lightweight OpenGL wm abstraction that has built-in VSync?
01:48:09 <Ralith_> what does that mean?
01:49:15 <berdario> in particular the wonderous2 example is what seems the most close to what I'm trying to do
01:49:37 <roha> quick newbie question about typeclasses: if i have this data type ^^^^^
01:49:41 <hpaste> roha pasted “RWH question about type classe” at http://hpaste.org/68318
01:49:43 <roha> ^^^^
01:49:50 <berdario> that is: since the space of the inputs is too large, I have to use a cutoff, but instead of specifying a fixed one, I'd like to use an LRU
01:50:03 <roha> if i do:      5 :: SymbolicManip Int,    ghci returns      Number 5
01:50:11 <berdario> I installed this package: http://hackage.haskell.org/packages/archive/lrucache
01:50:34 <berdario> and it seems to work fine... but it seems kinda hard of injecting its sideeffect into my code
01:51:10 <roha> somehow i dont quite get why that works
01:52:37 <roha> why can one omit the value constructor Number?
01:52:39 <berdario> after thinking about it for a while, I thought that maybe the only way out of it was to use unsafePerformIO
01:52:51 <berdario> and I wrote this thing: http://ideone.com/2ozG4
01:53:09 <berdario> but I get a lot of "Not in scope: `readIORef'"
01:53:38 <Ralith_> roha: integer literals are of type Num a => a
01:54:01 <Ralith> that is to say, they are a literal value of anything which implements Num
01:54:38 <berdario> Ralith: could you please give me a hint about this?
01:54:53 <roha> but what if i had multiple value constructors like: Number1 a, Number2 a    in the same data type that is an instance on Num
01:55:20 <Ralith> roha: what about it?
01:55:35 <Ralith> all that matters is that it implements Num.
01:55:46 <roha> if i would write:  5 :: SymbolicManip Int, how would he know i i mean Number1 5 or Number2 5
01:55:47 <Ralith> berdario: don't use unsafePerformIO
01:55:59 <Ralith> roha: through the implementation of Num.
01:56:11 <Ralith> instance, rather.
01:56:48 <roha> hmm, through the line: fromInteger i = Number (fromInteger i) ?
01:57:01 <Ralith> yep.
01:57:24 <berdario> Ralith: what should I use instead?
01:57:36 <roha> ah ok, thanks!
01:58:02 <berdario> Ralith: I want to use my function inside a list comprehension, so I don't think that I can do it easily by passing outside the state (the cache) each time
01:58:53 <Ralith> I don't really have the time to solve that for you atm, sorry.
01:58:59 * Ralith is up much too late
01:59:24 <applicative> berdario I think the most commonly used package is http://hackage.haskell.org/packages/archive/data-memocombinators/0.4.3/doc/html/Data-MemoCombinators.html
01:59:45 <lamefun2> hello
02:00:03 <lamefun2> what if I have a really huge data structure with most options that can be left at default value?
02:00:24 <berdario> Ralith: oh, ok... thanks anyway
02:00:41 <t7> who does the haskell weekly news?
02:00:51 <berdario> applicative: thanks, I'll look into that
02:01:03 <Ralith> lamefun2: make a smart constructor function.
02:02:08 <roha> sorry, about the previous question: if i enter into ghci:    5 :: SymbolicManip Double,   it returns Number 5.0
02:02:10 <applicative> you should be able to stick a bounds limit into the 'fib = Memo.integral fib'...' example there, that is like wondrous2
02:02:24 <roha> but fromInteger 5.0 fails ofc.
02:02:40 <roha> 5.0 :: SymbolicManip Double   the same
02:03:20 * hackagebot hedis 0.5 - Client library for the Redis datastore: supports full command set,  pipelining.  http://hackage.haskell.org/package/hedis-0.5 (FalkoPeters)
02:03:21 <t7> i think everyone in here has /ignore'd me
02:03:38 <applicative> berdario: for readIORef do import Data.IORef
02:03:57 <roha> i didn't provide a function in the instance declaration to convert double literals into SymbolicManip :O
02:05:23 <Saizan> t7: has there been much HWN lately?
02:05:56 <t7> weekly :)
02:06:05 <t7> but this week it looks different
02:06:12 <t7> new website or something
02:07:24 <applicative> roha 5.0 can't be interpreted as an Int or Integer
02:08:20 * hackagebot alex 3.0.2 - Alex is a tool for generating lexical analysers in Haskell  http://hackage.haskell.org/package/alex-3.0.2 (SimonMarlow)
02:08:45 <applicative> to use those literals you also need,  if i remember, class Num a => Fractional a where   (/) :: a -> a -> a   recip :: a -> a   fromRational :: Rational -> a
02:09:41 <applicative> fromIntegral lets it understand 5, 6 ,7 ; fromRational lets it understand 5.0, 6.2 etc
02:10:23 <roha> but if i have a data type like     Number a = Number a, where Number a is an Instance of Num
02:10:32 <roha> and if i do      5.0 :: Number Double
02:11:00 <roha> i dont get why that works because the only thing i can specify in the Instance declaration is fromInteger
02:12:58 <applicative> right, it first reads "5.0" as a Rational, then looks for your definition of fromRational, which doesnt exist yet.  You need to implement division basically
02:13:19 <Saizan> :t 5.0
02:13:19 <applicative> instance Fractional a => Fractional (SymbolicManip a) where ...
02:13:19 <lambdabot> forall t. (Fractional t) => t
02:13:30 <Saizan> :t fromRational
02:13:31 <lambdabot> forall a. (Fractional a) => Rational -> a
02:13:36 <applicative> Saizan is much more lucid
02:14:01 <roha> yeah but it does return  a value of type Number Double eventough i didnt provide fromRational
02:14:03 <Saizan> so Number a is also an instance of Fractional i'd guess
02:14:40 <Saizan> can you show the code?
02:14:45 <applicative> Doubles can be Numbers in  your sense since they're in Num;  that
02:14:45 <roha> sec
02:15:01 <Pedromdrp> hello, I am having a problem with mysql-simple
02:15:06 <Pedromdrp> I am trying to do a very simple query
02:15:12 <applicative> is enough for integer literals not fractional literals
02:15:14 <Pedromdrp>  foo :: IO [String]  foo = do    conn <- connect defaultConnectInfo { connectDatabase = "tutoring" }    xs <- query_ conn "select email from users"    return xs
02:15:33 <t7> whats the error?
02:15:39 <Pedromdrp> conn.hs:10:10:     No instance for (Database.MySQL.Simple.QueryResults.QueryResults                        String)       arising from a use of `query_'     Possible fix:       add an instance declaration for       (Database.MySQL.Simple.QueryResults.QueryResults String)     In a stmt of a 'do' expression:         xs <- query_ conn "select email from users"     In the expression:       do { conn <- connect                      (def
02:15:55 <t7> aha
02:15:55 <roha> Saizan, its an example from RWH: http://hpaste.org/68318
02:16:08 <Pedromdrp> what?
02:16:12 <t7> what type does query_ take?
02:16:18 <t7> as an arguement
02:16:36 <Pedromdrp> query_ :: QueryResults r => Connection -> Query -> IO [r]
02:16:39 <roha> so 5.0 :: SymbolicManip Double   yields   Number 5.0    eventough i can't see an implementation of fromRational
02:17:09 <womb> Hi!
02:17:11 <t7> Pedromdrp: you have this: {-# LANGUAGE OverloadedStrings #-}  ?
02:17:11 <roha> what the hell
02:17:25 <roha> Saizan, wait i think i just made a mistake
02:17:25 <Pedromdrp> {-# LANGUAGE OverloadedStrings #-}   import Control.Monad  import Database.MySQL.Simple  import qualified Data.Text as Text
02:17:31 <Saizan> roha: with just that code i get an error if i try 5.0 :: SymbolicManip Double
02:17:31 <Pedromdrp> so yes I have that
02:18:36 <roha> Saizan, yeah youre right. i messed that up in my head! sorry :)
02:18:54 <Saizan> Pedromdrp: i think the foo :: IO [String] signature is your problem
02:19:23 <hpaste> Pedromdrp pasted “code” at http://hpaste.org/68319
02:19:24 <Saizan> Pedromdrp: btw, in the future use a pastebin like hpaste.org for code and errors
02:21:39 <applicative> roha: try instance Fractional a => Fractional (SymbolicManip a) where;  a / b = Arith Div a b ; fromRational i = Number (fromRational i)
02:22:08 <applicative> then try asking about 6 :: SymbolivManip Double
02:22:56 <Saizan> Pedromdrp: use "foo :: IO [Only String]"
02:23:07 <Saizan> Pedromdrp: as the type signature
02:23:13 <Pedromdrp> ok I wil try
02:24:20 <roha> applicative, thanks
02:28:46 <Jed_84> hi again
02:28:56 <Jed_84> I have a function foo :: Ord a => [a] -> [a]
02:29:10 <Jed_84> I need to specify both "Ord" and "Eq" for "a"
02:29:22 <Jed_84> is it possible to do that?
02:29:25 <ehamberg> (Ord a, Eq a) =>
02:29:26 <bitonic> Jed_84: (Ord a, Eq a) => ...
02:29:38 <bitonic> Jed_84: note that you don't need to do that
02:29:41 <bitonic> Ord implies Eq
02:29:47 <bitonic> Jed_84: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Ord
02:30:23 <bitonic> a == b === a <= b && b <= a
02:31:00 <Saizan> Ord is enough
02:32:47 <adamt> I have a warning i would like to (try) to remove; the offending code is really tiny.
02:32:50 <hpaste> adamt pasted “help make this warning go away :)” at http://hpaste.org/68320
02:34:13 <Saizan> adamt: you can add type signatures
02:34:32 <merijn> adamt: The warning states that it can't really determine the type of the input of realToFrac (probably because the time function is polymorphic too?)
02:34:51 <merijn> adamt: Adding a type signature would make it disappear
02:35:11 <Saizan> ?type realToFrac
02:35:12 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
02:35:21 <Saizan> ?type floor
02:35:22 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
02:35:46 <adamt> This is the part where i state something about being unsure where to add the signature; should it be added to the dayDelta sig?
02:35:50 <Saizan> it's the result of realToFrac (which is also the input of floor) that is ambiguous
02:36:18 <merijn> Saizan: Ah, right. Because it doesn't know which result to pick as input to floor?
02:36:43 <Saizan> adamt: e.g. floor $ (realToFrac $ diffUTCTime end start / (60 * 60 * 24) :: Double)
02:36:55 <Saizan> i guess that's more properly called a type annotation
02:37:50 <adamt> And gone it is. Thank you for your help.
02:38:13 <Saizan> merijn: yeah, both functions are polymorphic with inputs and output types that aren't connected, so type inference doesn't have much to work with
02:43:29 <bartavelle> anyone knows of a nice template system that works at runtime ?
02:43:52 <bitonic> bartavelle: heist?
02:44:46 <bartavelle> I will take a look
02:45:27 <adamt> i think you could feed templates into hamlet as well at runtime if you want to, using whamlet
02:45:53 <bartavelle> those are the "competting" ones from yesod & snap right ?
02:46:16 <adamt> That would be correct.
02:46:27 <bartavelle> the problem with template engines in haskell is that google will return everything about "template haskell"
02:47:11 <adamt> actually, on second thought, i'm not actually sure hamlet would work. go look at heist first. ;)
02:47:33 <bartavelle> yes I asked because I believed that was the point of yesod : compile time validation
02:49:07 <berdario> my wifi died :/
02:49:19 <adamt> Yeah, the templates are turned into actual code at compile time, sorry man.
02:49:28 <berdario> applicative: thanks, that was definitely simpler than what I was doing before
02:50:22 <berdario> but having a limit like that wondrous2 example isn't what I'm trying to achieve... and this doesn't get me any closer to a python's lru_cache function
02:50:25 <bitonic> bartavelle: well the only templating system that uses TH extensively is the various yesod stuff
02:50:41 <bitonic> bartavelle: blaze-html and heist are runtime (I'm not sure you'd call blaze-html a templating sytem)
02:50:51 <bitonic> and hsp is a preprocessor
02:51:17 <berdario> applicative: in fact... by starting with a small problem space I strangely get a slow down of about 1.3x
02:51:19 <bitonic> bartavelle: btw, do you have some reason to be against compile-time templates?
02:51:22 <bartavelle> yes
02:51:29 <bartavelle> I am not writing a web application
02:51:34 <bartavelle> I am writing a puppet replacement
02:51:44 <bartavelle> templates can be changed while the daemon is running
02:52:09 <bitonic> uhm, ok. You'll have to be careful then :)
02:52:17 <bartavelle> yes
02:52:19 <bartavelle> ;)
02:57:56 <bartavelle> actually if someone has a working ruby interpreter that would be more useful than a specific template library
02:58:49 <bitonic> bartavelle: ? what do you mean?
02:58:58 <adamt> a ruby interpreter running in haskell
02:59:00 <bitonic> a ruby interpreter in haskell?
02:59:30 <bitonic> bartavelle: such a thing doesn't exist afaik, sorry. it'd be quite a lot of work.
03:00:34 <bartavelle> yes I figured, when I tried writing mine ...
03:00:52 <adamt> I'm really struggling to not make a nasty comment about ruby.
03:01:26 <bartavelle> but as I strive at achieving full compatibity with puppet, I will probably write my own template engine that emulates a subset of ruby anyway ...
03:01:38 <bitonic> bartavelle: you mean ruby string templates?
03:01:44 <bartavelle> that erb thingie
03:02:05 <bitonic> ah
03:02:07 <bartavelle> unforutnately it can host arbitrary ruby expressions
03:02:11 <bitonic> yeah.
03:02:28 <bartavelle> and I found that pretty useful ... except it is horribly slow
03:05:53 <ski> yan_ : there ought to be one
03:21:43 <sanjivsahayam> hello!
03:22:06 <srhb> sanjivsahayam: Hi there.
03:23:19 <sanjivsahayam> I have quick question about randomR. It doesn't seem to be quite that random
03:24:17 <sanjivsahayam> I've got a gist here with some code: https://gist.github.com/2652253. I might be using it incorrectly?
03:24:37 <srhb> sanjivsahayam: No, it is indeed deterministic.
03:25:24 <sanjivsahayam> yes, but even if create new generators with different seeds?
03:25:29 <srhb> sanjivsahayam: Have a look here: http://learnyouahaskell.com/input-and-output#randomness
03:25:47 <srhb> sanjivsahayam: Oh sorry.
03:26:06 <sanjivsahayam> did u have a look @ my gist?
03:26:15 <srhb> No - sorry :-)
03:26:40 <sanjivsahayam> I cycle through a hundred seeds but get the same value
03:26:55 <sanjivsahayam> if I up it to over a million then I get differing values
03:26:59 <sanjivsahayam> weird
03:27:44 <srhb> sanjivsahayam: Well, you should use the second value to prime it
03:28:04 <sanjivsahayam> I'm using randomR. You give it a range
03:28:13 <srhb> sanjivsahayam: There's no error that is happening, just that 6 will be generated for mkStdGen 1..100
03:28:20 <srhb> If you're picking between 1 and 6
03:28:48 <sanjivsahayam> hmm
03:28:59 <srhb> sanjivsahayam: You can check this first by increasing your range to say 1-1000
03:29:21 <srhb> sanjivsahayam: But the correct way is to generate one number, and then using the seed (second value in return tuple from randomR) for the next
03:29:34 <srhb> sanjivsahayam: Otherwise there's no guarantee on the distribution of random numbers.
03:29:43 <sanjivsahayam> oh right.
03:30:51 <sanjivsahayam> If I use randomRs instead of randomR I get what I expected! :)
03:31:01 <srhb> sanjivsahayam: Yes, that's the shortcut :)
03:31:15 <Elemir> @type randomRs
03:31:15 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
03:31:22 <sanjivsahayam> awesome!
03:31:59 <srhb> sanjivsahayam: Check it's implementation, and you'll see that what I said is exactly what randomRs does.
03:32:30 <hayashi> If you're writing functions returning IO, what's the best naming convention for those?  Would you start using verb names to show that the functions are returning actions, or still preferably use nouns?
03:33:33 <srhb> hayashi: I wouldn't, but that's just me. :-) The type is plenty information for me.
03:35:01 <ski> hayashi : depends
03:35:14 <ski> sometimes verbs would be appropriate
03:35:17 <ski> as with e.g.
03:35:34 <ski>   select :: MonadPlus m => [a] -> m (a,[a])
03:35:43 <ski> (where `m' is typically `[]')
03:35:57 * hayashi wonders about IO () actions, and how to give them noun-based names =P
03:36:15 <hayashi> like printing/putting etc.
03:36:23 <ski> maybe you should show some example type signature ?
03:37:15 <hayashi> Well, I was just wondering in general
03:37:51 <hayashi> given that when you're returning IO a it's not an a but rather a sequence of actions that will result in an a on execution, it just seems a bit strange to name a function returning IO a after the a
03:37:53 <ski> if you have `IO ()', then i think in many cases there wouldn't be a sensible name
03:38:47 <ski> i suppose you could do stuff like `printer :: Show a => a -> IO ()', instead of `print'
03:38:47 <merijn> hayashi: I use verbs
03:39:24 <ski> `ioForker',`handleContentsGetter',&c.
03:39:34 <merijn> And so do many standard libraries, for example writeChan/readChan in Control.Concurrent.Chan
03:39:59 <merijn> modifyMVar, forkIO, hGetContents, putStrLn, all verbs
03:40:15 <merijn> And renaming them to nouns results in Java ridiculousness as illustrated by ski's names
03:40:23 <t7> vect-opengl
03:40:28 <t7> where have you been all my life :D
03:42:02 * ski . o O ( "Execution in the Kingdom of Nouns" by Steve Yegge at <http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html> )
03:43:27 <merijn> That's an excellent article, yeah
03:47:41 <hpc> ski: that article is everything i dislike about java :D
03:48:32 <merijn> hpc: Aside from the incompetent community and godawful library design you mean, right?
03:50:38 <hpc> yes, that too
03:50:54 <hpc> i think it started with the verbs, though
03:51:14 <hpc> and from there, there was no choice but to make a bad STL that only idiots would use
04:02:51 <t7> Balazs Komuves
04:02:57 <t7> im gonna kill ya!
04:03:42 <t7> just converted all my code to use the vect lib because it has matrix inverse. then i get a runtime error saying matrix inverse not implemented :(
04:04:57 <asda8> does foldM from control.monad cause the same kinds of space-leaks as foldl?
04:06:43 <ClaudiusMaximus> t7: 'Vec' has a working inverse afaik (and hairy types), 'hmatrix' definitely does but is kinda heavyweight dependency-wise if that's all you need
04:07:34 <Saizan> asda8: yes, but you should be able to fix them from within the stepping function
04:08:36 <asda8> Saizan: how exactly? I don't even use the "accumulator" for anything I just need the result of the last computation returned
04:09:44 <asda8> maybe there is a better function for this, I mean running an IO action for each element of the list, then returning the result of the last one
04:10:37 <Saizan> ?type foldM
04:10:37 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
04:11:03 <Saizan> foldM (\_ x -> f x) shouldn't cause any foldl-like space leak
04:11:16 <t7> ClaudiusMaximus: is it the invert function? takes like 1000ms to compute in ghci :|
04:12:19 <asda8> Saizan: that's exactly what I'm doing, but I think I'm looking at a space-leak
04:12:55 <Saizan> asda8: must be somwhere else, maybe in f itself
04:13:55 <asda8> Saizan: hm, f just writes x to a file (hPutStr)
04:14:30 <t7> damn i cant use hmatrix :(
04:15:14 <Saizan> asda8: must be doing something else if it has an interesting result?
04:15:53 <asda8> Saizan: I guess...
04:17:14 <ClaudiusMaximus> t7: i sometimes keep 2 matrices around for each transformation (forward + reverse), so that i don't have to compute inverses
04:17:22 <ClaudiusMaximus> t7: doesn't always apply
04:17:50 <t7> well i only need the reverse to be honest, (its for a camera)
04:18:14 <t7> but i was gonna have lots of nice functions for transforming objects using 4*4 matrix
04:19:42 <t7> i just have to remember to apply reverse rotations and stuff
04:22:45 <hpaste> ClaudiusMaximus pasted “affine 2D bitransforms” at http://hpaste.org/68324
04:23:10 <ClaudiusMaximus> t7: ^^ thats what i wrote to keep track of pairs of matrices
04:24:03 <t7> yeah but i wont need the inverse for anything other than the camera
04:40:54 <bitonic> jaspervdj: pardon my noobness... when using the websockets library is there a way to kill the connection explicitly? or will it just be closed after the iteratee is ran? because that doesn't seem to be the case
04:43:42 <bitonic> jaspervdj: well actually I don't think it depends on the library, but on how I'm running the iteratee right? So I guess I have to look at `wai-websockets' to find the answer
04:43:52 <byorgey> t7: you know what, I just realized the numeric-prelude package DOES have quaternion inverse
04:44:10 <byorgey> t7: it is just hidden in the Field instance, it's the 'recip' method
04:44:41 <t7> can i just (-1 *) the position too?
04:44:50 <t7> to get the reverse transform
04:44:53 <byorgey> no
05:17:00 <hayashi> Grah.  Anyone know what the best way of getting a recent version of the Haskell Platform on debian stable would be?
05:17:19 <hayashi> I could just install testing or sid, but then I'll get shouted at for mixing releases~
05:17:23 <hpc> @where platform
05:17:24 <lambdabot> http://hackage.haskell.org/platform/
05:17:34 <hpc> follow the instructions there
05:18:21 <hpc> if you don't think 7.0.4 is recent enough, you can go all the way and install 7.4.1 and the github version of cabal
05:18:29 <Alan> hmm, so here's a fun one... I'm trying to work with bitstrings, is there a convenient way of defining them so that I could pattern match against splits of them?
05:18:53 <hpc> Alan: as a tree, most likely
05:19:05 <hpc> though then you need to build your trees so the splits are in the desired places
05:19:14 <Alan> well that's the awkward part
05:19:42 <Alan> I'm on about conditional decoding of a Word16 into something else
05:20:18 <Alan> so if the first 4 bits are 0xF, i might do one thing, if they are 0x0 I might split the rest up differently
05:20:28 <hpc> ah
05:20:41 <Alan> although i guess i could at least define a set of possible splits first..
05:20:54 <hpc> foo word = let (a, b, c, d) = split word in ...
05:21:18 <hpc> then define split however
05:21:51 <Alan> if i did that i'd basically have the decoding logic split up a bit more than is clean...
05:21:54 <Alan> hmm
05:22:19 <Alan> I don't think i can define my problem well enough to get specific help yet
05:22:25 <Alan> so i should probably go back to trying things...
05:22:25 <Alan> heh
05:22:26 <hpc> i would think of it more as split being the "lexer" of sorts
05:22:31 <Phlogistique> asda8: I think you want forM?
05:22:46 <hpc> splitting the word into tokens you can do stuff with
05:22:54 <parcs`> hayashi: i'm not sure about haskell platform but the linux binaries on the ghc website were built against debian stable, so they should "just work"
05:34:53 <Bytter> are there binaries available for agda on osx?
05:35:03 <Bytter> cabal is failing to install it due to happy
05:35:55 <Bytter> it complains the binary doesn't exist, but it does: cabal: ../ghc-7.4.1/lib/happy-1.18.9/bin/happy: does not exist
05:36:43 <merijn> What's the canonical way to write a function definition with a single guard? Guard on the same line or on the next line?
05:37:39 <hpc> Bytter: got the haskell platform?
05:37:44 <hpc> er, nvm
05:37:49 <hpc> Bytter: cabal install happy --global
05:38:20 <hpc> then try again
05:38:38 <Bytter> hpc already did
05:38:42 <hpc> ah
05:38:50 <hpc> oh, i see
05:38:56 * hpc missed "but it does"
05:38:59 <hpc> uh
05:39:15 <Bytter> Installing executable(s) in /Library/Haskell/ghc-7.4.1/lib/happy-1.18.9/bin
05:39:15 <Bytter> cabal: ../../../../../Library/Haskell/ghc-7.4.1/lib/happy-1.18.9/bin/happy:
05:39:16 <Bytter> does not exist
05:39:25 <hpc> does it have chmod +x?
05:39:29 <Bytter> but when I go to the directory, happy executable is there :-\
05:39:42 <lamefun2> Haskell SDL binding lacks glSwapControl
05:40:00 <Bytter> hpc: yep
05:40:04 <Bytter> hpc: and it runs
05:40:09 <hpc> hmm
05:40:19 <Bytter> λ ./happy
05:40:19 <Bytter> Usage: happy [OPTION...] file
05:40:46 <flux> what is glswapcontrol? google has exactly one match, a typo perhaps?
05:41:22 <hpc> Bytter: ghc-pkg list | grep happy # maybe the version is out of range...
05:41:28 <hpc>   build-tools:      happy >= 1.15 && < 2,
05:41:29 <hpc>                     alex >= 2.3.1 && < 3.1
05:42:17 <hpc> oh wait, i suck again
05:42:22 <hpc> happy-1.18.9/bin/happy
05:42:27 <Bytter> ;)
05:42:45 <hpc> that's about the limit of my ability to debug others' problems :P
05:42:59 <hpc> im stumped
05:44:06 <lamefun2> FFI was added in 2010 and before that Haskell couldn't use external libraries?
05:44:31 <hpc> lamefun2: the FFI was standardized, if anything
05:44:37 <hpc> GHC has had it for a while
05:44:56 <hpc> but technically, yes
05:45:04 <Philippa> the FFI was originally an addendum to H98
05:45:12 <srhb> Data Parallel Haskell is not included in the current Haskell Platform, is it?
05:45:23 <hpc> srhb: don't think so
05:45:40 <Philippa> so it was standardised before 2010, whether or not you consider it part of Haskell 98 proper
05:46:18 <t7> is there any usage stats for hackage?
05:47:44 <rribeiro> Hello all, I'm with some doubts on haskell's type system (since I'm implementing a type inference algorithm as part of my thesis), more specifically, my doubt is constraint entailment.
05:48:01 <rribeiro> Does someone knows a bit of constraint entailment ?
05:53:08 <bitonic> rribeiro: just ask, if somebody knows you'll get an answer :)
05:54:07 <Saizan> more specifically?
05:54:27 <rribeiro> The problem is, I want to prove a constraint Eq [a] using Jones entailment relation
05:54:43 <rribeiro> The problem is, How?
05:55:07 <rribeiro> its thesis, is hard to follow, since there's no examples
05:55:28 <oddraisent> Is there any workable ffmpeg module? hs-ffmpeg's last updated was in 2009
05:55:42 <srhb> oddraisent: Have you tried it?
05:56:00 <Saizan> rribeiro: do you have a link and a page number for this entailment relation?
05:58:19 <rribeiro> Saizan: http://research.microsoft.com/en-us/um/people/simonpj/papers/constraints/jfp-outsidein.pdf , page 54
05:58:32 <oddraisent> srhb: have anybody tried it?
05:58:33 <womb> Hi guys!
06:01:24 <jeff_s_> I'm playing with a bit of code that c_wraith helped me with, http://hpaste.org/68288#a68290 , and I'm wondering if the use of seq is really necessary when evaluate is being called directly after.
06:01:59 <jeff_s_> It doesn't seem to be, but I can't say I understand the difference between seq and evaluate.
06:02:13 <Saizan> rribeiro: Fig. 18?
06:02:24 <rribeiro> Saizan: yes
06:02:58 <rribeiro> Saizan: I know to prove Eq [a] must be an instance like Eq a => Eq [a] in context
06:03:05 <applicative> jeff_s_: I don't see how you need both
06:03:36 <rribeiro> Saizan: The problem is: after the matching of instance head's, how to prove the constraint Eq a, introduced by instance context?
06:03:38 <applicative> jeff_s_: for Int, so called 'weak head normal form' is complete evaluation anyway
06:03:57 <Saizan> rribeiro: you must have that in context too
06:04:44 <rribeiro> Saizan: But see, the problem is, how to match an instance, say Eq Int, to a constraint Eq a? There no match between them?
06:04:49 <rribeiro> Saizan: But see, the problem is, how to match an instance, say Eq Int, to a constraint Eq a? There no match between them!
06:05:37 <Saizan> rribeiro: in fact you can't discharge Eq a with an Eq Int instance
06:05:53 <Saizan> assuming a is a type variable here
06:06:19 <rribeiro> Saizan: How?
06:06:20 <Saizan> if it's a meta-variable it has to be instantiated in some other way before you can proceed further
06:06:59 <Saizan> rribeiro: how what?
06:07:00 <rribeiro> Saizan: I'm assuming that "a" in constraint Eq a must be an "fresh" variable
06:07:46 <rribeiro> Saizan: So, there's no substitution S such that S Eq Int = Eq a
06:08:46 <Saizan> rribeiro: i said you _can't_, in case you missed the negation there
06:09:17 <rribeiro> Saizan: ohhh by bad... Sorry
06:10:24 <applicative> jeff_s_: hm, I see better.  My guess would be the other way, that c_wraith wanted seq inside atomicallyModify above all; are you seeing any difference with and without
06:11:35 <rribeiro> Saizan: So my point is, in presentations of Haskell type inference algorithms, constraints must be provable by entailment. My doubt is how to construct such a proof of Eq [a], since we cannot prove Eq a... I can't figure out what I'm missing
06:11:36 <Saizan> though for example if you typecheck foo :: forall a. Eq a => a -> Bool; foo x = [x] == [x]; then when you try to discharge the constraint Eq [a] generated by the use of (==) your Q has both Eq a and (forall a. Eq a => Eq [a])
06:12:07 <Saizan> rribeiro: does my last example help?
06:12:19 <Axman6> hmm, does Bas van Dijk frequent #haskell? I've never connected a nick with the name
06:14:49 <Saizan> the Eq a gets added to the set of available constraints as you typecheck the RHS of foo, (though i guess the ||- relation gets also run in reverse to deduce such signatures)
06:17:25 <Saizan> i'm referring to the rule BindA in Fig. 4
06:18:13 <rribeiro> Saizan: I got the point here... Since, when I type foo x y = x == [y], I need to put the constraint Eq a, for some fresh a, that is generated by instantiating the type of ==
06:19:06 <rribeiro> Saizan: and this Eq a will be used to entail the constraint Eq [a] that will be need by this definition
06:20:13 <Saizan> rribeiro: no, you rather discover that you need Eq a from the fact that you need Eq [a] and the existence of the forall a. Eq a => Eq [a] instance
06:20:56 <hpc> and the assumption that this is the only instance for [a]
06:22:30 <Saizan> rribeiro: in the rule Bind of Fig.4, "Q1" is an output of the recursive call
06:23:53 <Saizan> rribeiro: and in FancyQ U Q ||- Q1, the output is Q
06:24:10 <Saizan> (if we want to give an algorithmic reading to the rules)
06:24:29 <rribeiro> Saizan: So, \cal{Q}, Eq a ||- Eq [a]
06:25:31 <Saizan> yeah
06:25:39 <Saizan> which makes Q = Eq a
06:27:15 <rribeiro> Saizan: Now, I believe that I've got the point, thanks for your help!
06:27:50 <Saizan> rribeiro: np :)
06:29:53 <Saizan> (in logic programming terminology Q1 would be nonground rather than a variable though, because you know it contains \cal(Q) as a minimum)
06:30:40 <womb> Guys i'm planning to build something simple on top of warp like "sinatra" what do you think ?
06:30:45 <womb> i have only one problem
06:30:54 <womb> i wanna build routing around pattern matching
06:30:59 <womb> is it good idea you think ?
06:31:16 <Eduard_Munteanu> What's "sinatra"?
06:31:26 <womb> very simple ruby framework
06:31:37 <danr_> isn't it an mpd client?
06:32:00 <Eduard_Munteanu> Perhaps you want to take a look at Yesod for ideas?
06:32:14 <danr_> aha. sinatra-mpd is built on sinatra
06:32:34 <womb> i saw yesod and for me yesod is "not haskell but new dsl" i would love to have something simple for building fast json apis
06:32:45 <womb> Aeson + Warp + Mongodb
06:33:09 <parcs`> mongodb is web scale!
06:34:17 <applicative> jeff_s_: The whole thing seems to go a little faster if you use atomicModifyIORef'  instead of atomicModifyIORef in your original simple definition.  Or maybe that was what was being explained
06:34:26 <parcs`> womb: what mongo bindings would you use?
06:34:54 <womb> i found some haskell monog binding
06:35:05 <womb> are there any reasons to use other then
06:35:08 <womb> let me grep for name
06:35:40 <womb> mondoDB ( https://github.com/TonyGen/mongoDB-haskell )
06:36:39 <HugoDaniel> hi
06:36:48 <HugoDaniel> im trying to write a haskell module
06:37:04 <HugoDaniel> that goes into a folder of a haskell project and reads some haskell files and modifies them
06:37:11 <HugoDaniel> like adding elements to a const list and other stuff
06:37:30 <HugoDaniel> its just a helper to manage a big haskell project
06:37:38 <HugoDaniel> but i dont know how to do this :/
06:37:48 <HugoDaniel> how can i read a haskell file and modify a const list there ?
06:38:39 <applicative> HugoDaniel: haskell-src-exts ?
06:38:48 <HugoDaniel> applicative: cool
06:38:51 <HugoDaniel> let me check it
06:38:56 <HugoDaniel> what about template haskell ?
06:39:01 <HugoDaniel> can't i use it for this ?
06:39:07 <HugoDaniel> or its purpose is diff ?
06:40:03 <applicative> HugoDaniel: That sounds more like what you want,but I don't know template haskell.  Its part of my religion...\
06:40:35 <parcs`> womb: ah. well if you want a lightweight type-safe routing solution check out web-routes and web-routes-boomerang for existing implementations. see how it's done in happstack at http://www.happstack.com/docs/crashcourse/WebRoutes.html#web-routes
06:40:59 <applicative> haskell-src-exts can parse and write
06:41:21 <yitz> HugoDaniel: TH would be if you want to annotate the original code in a way that gets expanded at compile time. It doesn't walk through a tree of modules and processes them.
06:42:36 <HugoDaniel> yitz: cool thanks :D
06:43:54 <HugoDaniel> so next question is: where can i read about haskell-src-exts and learn it ?
06:44:27 <bitonic> HugoDaniel: it's pretty intuitive
06:44:47 <bitonic> HugoDaniel: http://hackage.haskell.org/packages/archive/haskell-src-exts/1.13.2/doc/html/Language-Haskell-Exts-Parser.html this is to parse modules
06:45:00 <bitonic> HugoDaniel: and this is the datatype that you get: http://hackage.haskell.org/packages/archive/haskell-src-exts/1.13.2/doc/html/Language-Haskell-Exts-Syntax.html#t:Module
06:45:08 <bitonic> which is of course pretty huge
06:45:19 <bitonic> but there isn't nothing particularly strange
06:45:19 <HugoDaniel> oh cool
06:45:30 <HugoDaniel> yes, its straight forward
06:45:32 <HugoDaniel> very nice good
06:49:57 <mreh> is it theoretically possible cabal (the library) will compile and not work properly on a GHC version it was never tested on?
06:50:14 <mreh> i was trying to get cabal-dev working on ghc-6.12
06:50:43 <mreh> and getting weird errors, not finding packages that were just installed moments ago
06:51:46 <HugoDaniel> OH HMM
06:51:49 <HugoDaniel> sorry
06:52:06 <HugoDaniel> is there anything similar to haskell-src-exts for .cabal files ?
06:52:06 <mreh> heh
06:54:30 <Axman6> bleh, people writing code in Go need to add more comments -_-
06:55:25 <mreh> that must look ridiculous written in black and white beads on a grid
06:56:56 <HugoDaniel> :)
06:56:57 <shinji_> hi there
06:57:11 <HugoDaniel> hackage is so slowww
06:57:25 <bitonic> yeah hackage is pretty crap recently
06:57:47 <applicative> HugoDaniel: http://hackage.haskell.org/packages/archive/Cabal/1.14.0/doc/html/Distribution-PackageDescription-Parse.html
06:58:16 <applicative> http://hackage.haskell.org/packages/archive/Cabal/1.14.0/doc/html/Distribution-PackageDescription-PrettyPrint.html
06:58:45 <shinji_> hi i'm a beginner in haskell
06:58:59 <bitonic> shinji_: you're in the right place
06:59:08 <applicative> shinji_: indeed
06:59:09 <shinji_> ha, thx
06:59:45 <shinji_> i'm reading Learn You a Haskell for Great Good
06:59:56 <shinji_> there's an example
07:00:01 <mreh> who's idea was that title?
07:00:18 <applicative> It's so brilliant, the title
07:00:19 <mreh> whose, SORRY
07:00:20 <shinji_> data Barry t k p = Barry { yabba :: p, dabba :: t k }
07:00:32 <shinji_> instance Functor (Barry a b) where
07:00:41 <shinji_>  fmap f (Barry {yabba = x, dabba = y}) = Barry {yabba = f x, dabba = y}
07:00:48 <mreh> Learn Haskell Make Benefit Glorious Country is better
07:00:52 <shinji_> wonder if i can do
07:01:10 <shinji_> data Barry p t k = Barry { yabba :: p, dabba :: t k }
07:01:24 <shinji_> instance Functor (Barry a b) where
07:01:42 <applicative> shinji_: then t would have to be a type constructor
07:01:59 <applicative> I mean something like Maybe a  rather than Int
07:01:59 <shinji_> fmap f (Barry {yabba = x, dabba = t k}) = Barry {yabba = f x, dabba = t (f k)} ?
07:02:23 <shinji_> seems this pattern matching does not work
07:02:45 <Axman6> shinji_: t is a type constructor, like [] (which when applied to a type forms the type [a]) or Maybe (Maybe applied to the type a forms Maybe a)
07:02:57 <shinji_> yeah
07:03:02 <shinji_> i see
07:03:26 <applicative> fmap f (Barry {yabba = x, dabba = tk}) = Barry {yabba = f x, dabba = fmap f tk)}
07:03:26 <shinji_> so any idea in what way i can do it
07:03:50 <Axman6> but you're pattern matching on t in the definition oif fmap, which doesn't make much sense. what would t be if you had Barry Int [] String?
07:04:37 <applicative> fmap f (Barry {yabba = x, dabba = ts}) = Barry {yabba = f x, dabba = map f ts} of course
07:05:13 <applicative> wait scrapt that.  Only the k field is being acted on
07:05:21 <shinji_> yeah
07:05:54 <applicative> in data Barry t k p = Barry { yabba :: p, dabba :: t k }
07:06:10 <applicative> the functor will act on the yabba field, so it's no problem
07:06:32 <shinji_> yeah..that's right
07:06:39 <shinji_> but here i want it to act on k
07:06:50 <Axman6> then t needs to also be a functor
07:06:54 <applicative> barrymap :: (p -> q) ->  Barry t k p -> Barry t k q
07:07:27 <applicative> you need to reorder the parameters, or am I in a muddle
07:07:30 <Axman6> and you can have fmap f (Barry {yabba = x, dabba = y} = Barry { yabba = x, dabba = fmap f y}
07:07:33 <applicative> data Barry t p k = Barry { yabba :: p, dabba :: t k }
07:08:13 * Axman6 gets very confused when the type parameters used in the Functor instance aren't named a and b :P
07:08:14 <applicative> barrymap :: (k -> j) ->  Barry t p k -> Barry t p j
07:08:17 <shinji_> alright
07:08:34 <applicative> Axman6: that's what was getting me wrong above :)
07:09:06 <applicative> the general operation in the type system is given by dropping the last parameter.
07:09:20 <applicative> thats what the 'functor' is
07:09:57 <shinji_> that' very helfull
07:10:06 <shinji_> thanks alot guys
07:10:41 <applicative> shinji_: not that in this case you will need a functor constraint on t
07:11:03 <applicative> instance Functor t => Barry t p where ...
07:11:10 <applicative> note, rather
07:11:24 <applicative> instance Functor t => Functor (Barry t p) where ...
07:11:41 * applicative exhibits customary error proneness
07:12:22 <shinji_> i see so t has to be a functor
07:12:54 <applicative> I think you'll see the  necessity when you try to insert f in the dabba :: t k field
07:13:33 <applicative> fmap f (Barry {yabba = x, dabba = y} )= Barry { yabba = x, dabba = fmap f y} as Axman6 said.
07:13:53 <rwbarton> this is a pretty fancy example for LYAH
07:13:54 <applicative> you use the fmap definition for the t functor, which can be anything
07:14:17 <applicative> shinji_ was introducing a swank complication
07:15:08 <shinji_> right...seems i need some time to think about it
07:15:31 <shinji_> this type and functor thing is really hard
07:16:48 <scopedTV> you'll get the hang of it =)
07:17:04 <scopedTV> I find other things hard now.
07:17:15 <scopedTV> Surely that'll change for you as well :)
07:17:46 <bitonic> functors will scar you emotionally.
07:18:13 <shinji_> em...t can basically take anything a form a new type
07:18:32 <shinji_> so to transform k to another thing
07:18:37 <applicative> functor is the best concept in haskell
07:19:06 <shinji_> alright
07:19:20 <applicative> If I had learned it in junior high I would be more rational today...
07:20:06 <scopedTV> And rationality is a positive trait?
07:20:08 <applicative> but it's one of those things, the explanations are hopeless, you just need to work some examples
07:20:28 <applicative> scopedTV: I wasn't sure that was quite the predicate I wanted...
07:25:37 <hpaste> donri pasted “put in .ghci for colored and pretty printed value showing :)” at http://hpaste.org/68337
07:25:39 <mizu_no_oto> Is there a way to parallelize memoization/dynamic programming?  I'm currently using memocombinators and the parList Strategy.  When I run the un-memoized (i.e. slow as a snail) version, it runs in parallel (i.e. using more than one cpu). When I run the memoized version, it only uses a single cpu.
07:32:45 <Axman6> mizu_no_oto: very much depends on what you're doing, how you're memoising things
07:38:08 <rwbarton> there is no magic bullet for parallelization either, if your algorithm is inherently sequential with each value depending on the previous one, how can you hope to parallelize it?
07:39:11 <opqdonut> btw a list sounds kind of bad if you're doing anything like random access
07:42:53 <womb> would you name your kid haskell for lulz ?
07:43:18 <dmwit> womb-- for "for lulz"
07:45:11 <quicksilver> I named my kid php. He's not laughing now.
07:45:46 <srhb> I'm sure he had some great late 90's though.
07:50:18 <zzing> @src ($)
07:50:19 <lambdabot> f $ x = f x
07:56:42 <srhb> When ghci gives me type signatures a la Monad m1 => ... is the "m" in "m1" simply lowercase type class first letter, or hardcoded?
07:56:54 <zzing> What is the name given to the function ($) to identify the concept?
07:57:01 <srhb> function application
07:57:20 <srhb> Function application operator, I guess.
07:57:26 <danr_> srhb: the m probably comes from another function that has a constraint Monad m => ..
07:57:28 <srhb> Or simply "apply"
07:57:30 <zzing> I am in a class right now that uses miranda. It is missing so many things. :-(
07:57:36 <danr_> i think there was a post on reddit about this some year ago...
07:57:45 <t7> template haskell is a mind f**k
07:57:46 <srhb> danr_: Ah, that;s not what I meant.
07:58:34 <srhb> danr_: m1 is indeed a monad that comes from somewhere. The question is, why does ghci choose the name "m1" to identify it with. And if I had a type class Flobbergooks, would its types be represented as f, f1, f2..?
07:58:34 <danr_> srhb: ok... then what did you mean?
07:59:00 <srhb> I guess it's probably faster if I simply test it instead of trying in vain to explain. :P
07:59:08 <rwbarton> he answered your question as you meant it i think
07:59:21 <srhb> Oh.
08:00:06 <rwbarton> you used some function like (>>=) whose type has a (Monad m) constraint, and so it introduced a type variable to play the role of (>>=)'s m but m was already taken so instead it picked m1
08:00:23 <srhb> Ah, yes, got it. I misunderstood danr_ :)
08:00:42 <danr_> alright :)
08:00:44 <rwbarton> so it came from the type signature written by whoever wrote (>>=) or whatever the function was
08:00:45 <srhb> And the first m is hardcoded somewhere?
08:00:49 <srhb> Right
08:01:18 <srhb> So if >>= had a type signature Monad q, henceforth I'd get q
08:01:23 <srhb> qn*
08:02:18 <rwbarton> i think so, yes
08:02:28 <HugoDaniel> is there something like haskell-src for .cabal files ?
08:02:31 <rwbarton> this is all just guesswork, nobody really knows how it picks the names :)
08:02:40 <dcoutts> HugoDaniel: Cabal library
08:02:47 <srhb> Sure. :-) It doesn't matter anyway, I was just curious.
08:03:17 <t7> whats the point of OGL package
08:03:20 <t7> i dont understand
08:03:27 <t7> just wrap IO in GL ?
08:04:27 <HugoDaniel> dcoutts: cool, are there any examples on how can i parse and add modules to the exposed-modules of a .cabal file ?
08:05:03 <dcoutts> HugoDaniel: leksah does that I think, the leksah author sent in some patches to fix the pretty printer so that he could do that
08:05:25 <dcoutts> HugoDaniel: so in theory you just parse, modify, pretty print
08:05:33 <HugoDaniel> yes :)
08:05:35 <HugoDaniel> thats what i want
08:05:37 <HugoDaniel> great stuff
08:05:43 <HugoDaniel> let me check leksah then
08:05:52 <dcoutts> HugoDaniel: note that it does not preserve whitespace etc
08:05:57 <dcoutts> nor comments etc
08:06:08 <byorgey> but in practice you parse, modify, pretty print, curse when it doesn't do exactly what you want, rinse, repeat?
08:06:49 <dcoutts> byorgey: yeah, it's not a refactoring style where it preserves everything, ordering etc
08:07:17 <byorgey> hehe, yeah, I remember thinking about some of these same issues when working on cabal init
08:07:31 <dcoutts> byorgey: e.g. cabal's sdist --snapshot modifies things by string replacement
08:08:03 <byorgey> since it would also be nice if you could re-run cabal init to change some of your original choices
08:08:07 <HugoDaniel> dcoutts: no problem :)
08:08:20 <dcoutts> byorgey: off and on for a while now I've been writing a new lexer and parser, partly with the idea that we should be able to do edits while preserving whitespace etc
08:08:27 <byorgey> oh, cool =)
08:09:01 <luite> for people interested in web stuff: the ghcjs repository has been moved to https://github.com/ghcjs  interested people are welcome to join the organization (Hamish Mackenzies recent improvements still need to be merged, so wait an hour or so if you want to hack on it)
08:09:23 <dcoutts> the HaRe approach seems like a reasonable way, they parse to an AST that does not contain the whitespace, but then when writing it back out again they merge the token stream from the original, with the token stream from pretty printing
08:09:35 <applicative> haskell-src-exts doesnt do that sort of thing, comments for example are gone, if I remember
08:10:09 <dcoutts> applicative: right, but the same trick could in theory be done there. That's the nice thing, the AST doesn't need to have the comments etc.
08:10:26 <byorgey> dcoutts: oh, interesting.  I don't know if that will work for .cabal files though, because you have to deal with ordering of fields
08:10:32 <dcoutts> the tricky bit is obviously in how you merge the token streams
08:10:35 <byorgey> i.e. the ordering of fields in the .cabal file is not reflected in the AST
08:10:43 <applicative> yes
08:10:47 <byorgey> whereas ordering would be reflected in the AST for Haskell source
08:11:36 <dcoutts> byorgey: my plan is to do two stage parsing, first do tree outline parsing that does actually preserve everything, then parse individual fields to get the Cabal AST
08:11:49 <byorgey> ah, I see, cool
08:11:52 <dcoutts> byorgey: then pretty printing would go back to the outline tree, and we merge those two
08:12:04 <dcoutts> that's the theory :-)
08:12:04 <byorgey> yes, I see, the merging would be two-stage then as well
08:12:34 <byorgey> dcoutts: there's a lot of interesting work along these lines to do with bidirectional programming, lenses, complements etc.
08:12:39 <applicative> the error statements are incredibly cruel; not that one deserves better...
08:12:49 <byorgey> I wonder if anything in the literature can help.  It's obviously a rather difficult problem.
08:13:09 <dcoutts> byorgey: thing is we don't really want to force complexity on all users of the Cabal lib.
08:13:25 <dcoutts> byorgey: best effort at preserving layout etc is almost certainly enough
08:13:31 <byorgey> yeah, that's true
08:14:23 <byorgey> dcoutts: anyway, I do solemnly promise that if you DO get such a best-effort round-tripping parser/pretty-printer working, I will try to port cabal init to make use of it
08:14:32 <dcoutts> byorgey: ta :-)
08:14:47 <byorgey> i.e. if you run 'cabal init' and it finds an existing .cabal file, it will ask you if you want to start over or just modify the existing file, or something like that
08:15:03 <dcoutts> byorgey: it'd be handy for things like adding deps or modules that we discover
08:15:15 <byorgey> dcoutts: ah, yeah, that would be really cool!
08:16:14 <byorgey> there's now code to auto-discover deps, but if you run 'cabal init' very early on there won't be anything to discover.  So it would be cool if you could just say 'cabal init --infer-more-deps' and just have it automagically add more as you work on the code
08:16:49 <dcoutts> byorgey: or when cabal build fails, it asks you if you'd like to add a dep on 'foo'
08:16:57 <byorgey> yeah, that would be sweet =)
08:17:05 <dcoutts> or when it discovers that you're using modules you didn't declare in other-modules
08:17:09 <byorgey> right
08:17:14 <dcoutts> or language extensions...
08:17:43 <byorgey> well, language extensions are orthogonal since presumably those should be added to your .hs files instead of the .cabal file.  But that would be cool too.
08:18:02 <dcoutts> byorgey: we like them to be declared in other-extensions
08:18:11 <dcoutts> just like dependencies
08:18:18 <dcoutts> they are dependencies of sorts
08:18:25 <byorgey> hmm, I guess that's true
08:18:36 <byorgey> but aren't they then enabled for *every* .hs file?
08:18:41 <dcoutts> byorgey: we corrected that misfeature about the 'extensions' field
08:18:51 <dcoutts> there's now default-extensions and other-extensions
08:18:57 <byorgey> ahhhh
08:19:07 <byorgey> so what does other-extensions do?  is it just documentation?
08:19:21 <dcoutts> we check that the compiler you configure with supports them
08:19:30 <byorgey> ah, cool cool
08:19:37 <byorgey> didn't know about that field
08:19:52 * byorgey makes a todo to add that field to all his packages
08:19:55 <zzing> @src head
08:19:55 <lambdabot> head (x:_) = x
08:19:55 <lambdabot> head []    = undefined
08:19:57 <dcoutts> byorgey: if you use cabal-version: >=1.10 then Cabal will tell you about it
08:20:30 <byorgey> dcoutts: ok. I think I've only ever needed >= 1.8
08:21:11 * dcoutts notes cabal init should probably use  >=1.10 these days
08:21:13 <srhb> err.. Is this mapM: \xs f -> foldr (\x acc -> acc >>= (\t -> f x >>= \h -> return (h:t))) (return []) xs  ?
08:21:31 <scopedTV> it looks like it, surely
08:21:32 <srhb> oh I suppose it's forM..
08:21:35 <dcoutts> byorgey: and probably also use default-language: Haskell2010
08:22:02 <scopedTV> hmm, maybe not
08:22:04 <byorgey> dcoutts: makes sense.  want me to submit a patch?  or is it easier for you to just do it?
08:22:14 <dcoutts> byorgey: I'd be happy for you to make a patch
08:22:19 <byorgey> dcoutts: ok, will do
08:22:22 <dcoutts> thanks
08:22:27 <marijn`> Argh. I upgraded GHC and now my program won't compile (Could not find module `System'). Where is System.getArgs (or equivalent) found in a recent GHC?
08:22:46 <ClaudiusMaximus> merijn: System.Environment
08:22:51 <dcoutts> @hoogle getArgs
08:22:51 <lambdabot> System.Environment getArgs :: IO [String]
08:22:51 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
08:22:57 <ClaudiusMaximus> oops, marijn`
08:23:05 <byorgey> @pl \xs f -> foldr (\x acc -> acc >>= (\t -> f x >>= \h -> return (h:t))) (return []) xs
08:23:06 <lambdabot> flip (flip foldr (return []) . ((=<<) .) . flip flip ((return .) . flip (:)) . (((.) . (>>=)) .))
08:23:19 <byorgey> @pl \f xs -> foldr (\x acc -> acc >>= (\t -> f x >>= \h -> return (h:t))) (return []) xs
08:23:19 <lambdabot> flip foldr (return []) . ((=<<) .) . flip flip ((return .) . flip (:)) . (((.) . (>>=)) .)
08:23:30 <srhb> So.. beautiful.
08:23:41 <marijn`> ClaudiusMaximus: that still gives me the 'could not find module System' error. any extra package (apt? cabal?) I should fetch?
08:24:19 <dcoutts> marijn`: you need to change the import decl so it's not importing System anywhere, but System.Environment
08:24:23 <marijn`> ClaudiusMaximus: ignore that. it *did* solve the problem
08:24:24 <ClaudiusMaximus> marijn`: don't think so, maybe you need to import System.Environment as System
08:24:32 <marijn`> ClaudiusMaximus: thanks!
08:24:35 <ClaudiusMaximus> ok
08:24:37 <ClaudiusMaximus> :)
08:26:48 <byorgey> srhb: I think it's like forM, except with the effects performed right-left
08:27:51 <srhb> Sounds right
08:28:10 <srhb> It's not exactly easy to decipher when implemented like that.
08:28:17 <byorgey> > let mroF xs f = foldr (\x acc -> acc >>= (\t -> f x >>= \h -> return (h:t))) (return []) xs in runWriter $ mroF [tell [1] >> return 1, tell [2] >> return 2]
08:28:23 <Saizan> \xs f -> foldr (\x acc -> liftM2 (:) (f x) acc) (return []) xs  -- this is forM
08:28:36 <donri> haskell-src-exts has an "exact-printer" and an "annotated AST"
08:29:10 <byorgey> hmm, is lambdabot dead?
08:29:36 <magicman> @botsnack
08:29:40 <lambdabot> :)
08:29:40 <lambdabot>   Couldn't match expected type `Control.Monad.Trans.Writer.Lazy.Writer
08:29:40 <lambdabot>       ...
08:29:51 <scopedTV> > 2 + 4
08:29:53 <lambdabot>   6
08:29:53 <byorgey> oh, just napping
08:30:21 <byorgey> > let mroF xs f = foldr (\x acc -> acc >>= (\t -> f x >>= \h -> return (h:t))) (return []) xs in runWriter $ mroF [1, 2] (\n -> tell [n] >> return n)
08:30:22 <lambdabot>   ([1,2],[2,1])
08:34:33 <Eelis> how can i make --disable-optimization the default in my .cabal file without using the ghc-options field?
08:34:34 <lambdabot> Eelis: You have 1 new message. '/msg lambdabot @messages' to read it.
08:35:59 <int-e> Eelis: optimization: False  should do the trick.
08:36:18 <donri> dcoutts: default-language doesn't seem to be documented, is it a global property?
08:36:19 <Eelis> int-e: i tried that, but that makes Cabal warn about an unrecognized field
08:36:27 <int-e> hmm
08:36:44 <Eelis> int-e: i'm talking about a package's bla.cabal file, not ~/.cabal/config or something like that
08:36:55 <HugoDaniel> is there any map reversed ?
08:37:07 <HugoDaniel> that starts applying the function by the end of a list ?
08:37:14 <scopedTV> reverse . map f
08:37:20 <parcs`> Eelis: 'ghc-options: -O0' perhaps
08:37:31 <Eelis> parcs`: notice "without using the ghc-options field" :)
08:37:38 * parcs` didn't notice that :P
08:38:23 <dcoutts> donri: it's much like extensions, lives in the same places
08:38:35 <HugoDaniel> is it possible to see source code for a given function i ghci ?
08:38:43 <HugoDaniel> i wanted to check out how reverse works
08:38:44 <int-e> Eelis: yes, I misunderstood. I suspect it's not supported by design -- the reasoning being that this should be the user's choice rather than the package developer.
08:39:07 <geekosaur> HugoDaniel: not generally
08:39:10 <Eelis> int-e: i would be sympathetic to that rationale except that when ghc tries to optimize my code, it crashes
08:39:23 <Eelis> int-e: so my package is not buildable without --disable-optimization
08:39:33 <parcs`> Eelis: why avoid the ghc-options field?
08:40:31 <Eelis> parcs`: well, i figured that since cabal supports --disable-optimization, it already knows how to instruct ghc not to do optimization without me having to spell out the command line option
08:40:42 <Eelis> so spelling that out seemed like a step backwards
08:40:57 <Eelis> oh damn, dinner, back in 30m
08:41:21 <ikt_> why can i not say fmap (\x->x+1) (Right 3) at the ghci terminal?
08:41:48 <Saizan> import Control.Monad.Instances
08:42:27 <int-e> Eelis: I would use ghc-options in that case then, or even an OPTIONS_GHC pragma in the affected source file.
08:42:27 <strager> @pl \ex -> report str ex >> return (Left ex)
08:42:27 <lambdabot> ap ((>>) . report str) (return . Left)
08:42:46 <parcs`> ikt_: or import Control.Applicative
08:42:54 <int-e> Eelis: since it appears to be a compiler specific workaround
08:43:07 <womb> :t \->
08:43:08 <lambdabot> parse error on input `\->'
08:43:14 <womb> :t \-> ()
08:43:15 <lambdabot> parse error on input `\->'
08:43:21 <womb> :t \ x -> ()
08:43:21 <scopedTV> womb: you need a variable.
08:43:22 <lambdabot> forall t. t -> ()
08:43:28 <scopedTV> :t \_ -> ()
08:43:29 <lambdabot> forall t. t -> ()
08:43:38 <parcs`> :t \_->()
08:43:39 <lambdabot> forall t. t -> ()
08:43:45 <womb> :t \_ -> ()
08:43:47 <lambdabot> forall t. t -> ()
08:43:52 <int-e> Eelis: the only other possibility I can think of is to have a custom Setup.hs twiddle with the build infos ... which is no fun at all.
08:44:03 <womb> it should be called dash-rocket not lambda
08:45:34 <dcoutts> Eelis: I don't understand your requirements
08:45:36 <martiert> Hi. I'm quite new to haskell. I have gotten a IO [FilePath] using getDirectoryContents from System.Directory. I wish to do a list comprehension on this list, but get the error: Couldn't match expected type [t0] with actual type IO [FilePath] can anyone tell me how to do this, or link me to some sites that explaines it?
08:45:53 <ikt_> importing Control.Monad.Instances worked for me, how can see how Either is an instance of Fuctor there? I cannot find it under "source" at http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Monad-Instances.html
08:46:34 <byorgey> martiert: see http://www.haskell.org/haskellwiki/Introduction_to_IO
08:47:15 <byorgey> martiert: short answer: you want something like  do { files <- getDirectoryContents;  ... some sort of list comprehension using files ... }
08:47:32 <byorgey> martiert: but read that link for more info.
08:48:25 <parcs`> ikt_: http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/src/Control-Monad-Instances.html
08:49:12 <byorgey> ikt_: note that link you pasted is for GHC 6.12.2 and base-4.2.0.1.  Presumably you have a newer version of GHC than that.
08:49:20 <martiert> byorgey: yeah, that's what I want. Actually I wish to define a function :: IO [FilePath] -> [String], but I don't know how to do that, and that link don't explain how to
08:49:27 <byorgey> martiert: you can't.
08:49:32 <ikt_> ok, thanks
08:49:37 <dcoutts> Eelis: why would you want to disable optimisation without just doing ghc-options: -O0 ?
08:49:58 <byorgey> martiert: because if the function does any IO then it must have a return type involving IO
08:50:00 <dcoutts> Eelis: if your package really does not work with ghc -O, then that's already highly ghc specific
08:50:56 <ikt_> If I put the definition of "instance Functor (Either a) where..." in a file and load it into ghci, I get " No instance for (Functor (Either a0))       arising from a use of `fmap'..." when I say "fmap (\x->x+1) (Right 3)", why?
08:51:10 <martiert> byorgey: so it's not possible to turn a IO list into a list of strings?
08:51:35 <scopedTV> ikt_: That's weird. Can you paste your code, so I can try it?
08:51:44 <ikt_> sure, wait a second
08:52:12 <byorgey> martiert: no, it isn't.  Note that something of type  'IO [String]' is not actually a list.  It is a description of how to do some I/O operations which will eventually result in a list of Strings.
08:52:14 <ikt_> scopredTV: bwah, no it works. sorry
08:52:22 <scopedTV> :) ok
08:52:33 <byorgey> martiert: something of type [String] is simply a list of Strings, it is not allowed to do any I/O when it is computed
08:52:46 <byorgey> martiert: so a type like  IO [String] -> [String]  would be lying about the fact that some I/O happened
08:53:05 <scopedTV> Yes, so IO [String] is an action that, when performed, does some IO and yields a list of Strings
08:53:16 <martiert> byorgey: ok, so I have to execute the IO after doing getDirectoryContents? The IO hasn't happends while it's a IO [String]?
08:53:33 <mauke> you can't execute IO
08:53:39 <scopedTV> martiert: no, you can compose actions to get larger actions
08:53:40 <quicksilver> byorgey: A type like IO [String] -> [String] is quite honest, it honestly says that it never uses its parameter :-)
08:53:42 <scopedTV> for example
08:53:58 <byorgey> quicksilver: heh, well, I don't think that's the function martiert had in mind =)
08:54:05 <scopedTV> do { es <- getDirectoryContents; putStrLn "Hello world"; print es }
08:54:27 <byorgey> martiert: you have to combine getDirectory contents with some other IO action(s), using the (>>=) operator
08:54:32 <scopedTV> this is an action that, when performed, reads the directory, prints "Hello world", and then prints all the entries in that directory.
08:54:39 <byorgey> martiert: or do-notation, which is just syntax sugar for (>>=)
08:54:43 <scopedTV> its type will be IO ()
08:55:15 <byorgey> martiert: anyway, I suggest you read through that page I linked carefully
08:55:31 <byorgey> martiert: Haskell's way of handling IO definitely takes some getting used to.
08:55:39 <ksf> does anyone have experience with sodium?
08:55:43 <ksf> the frp library, that is?
08:56:27 <zzing> Does Parsec have any ability to automatically handle whitespace for me? (I am coming from the idea of Boost Spirit that has a whitespace scanner)
08:56:37 <martiert> ok, guess I'll have to carefully reading that article. I thought all actions were performed after the getDirectoryContents, and so the return from getDirectoryContents "/home/user" should be safe to use as a string, but I'll do some more reading then
08:56:41 <martiert> thanks
08:57:01 <mauke> martiert: actions are never performed
08:57:08 <ksf> zzing, if with automatic you mean "can I write a tokeniser in parsec", then yes.
08:57:41 <scopedTV> mauke: the "main" action is performed, isn't it?
08:57:53 <scopedTV> that's basically that the runtime does
08:57:56 <mauke> yes
08:58:08 <mauke> but that's outside of haskell proper
09:00:45 <martiert> "a line of the form v <- x will cause the action x to be run, and the result bound to the variable v" will then v be an IO action?
09:00:56 <scopedTV> no
09:01:04 <scopedTV> (well, it could be, but often not)
09:01:17 <scopedTV> if x is of type IO a, then v will be of type a.
09:01:35 <mauke> also, the whole thing is hypothetical
09:01:44 <martiert> scopedTV: ok, so doing v <- x when x is IO [String] will make v a [String]?
09:01:54 <ikt_> http://hpaste.org/68174 - can anyone explain me why it is not ok to say "furry _ foo = foo" since "EitherLeft (Right v)" is not changed?
09:02:03 <byorgey> martiert: yep
09:02:10 <scopedTV> martiert: Correct.
09:02:11 <mauke> ikt_: it has the wrong type
09:02:27 <martiert> nice, then I understand more of why the stuff I tried didn't work:P
09:02:32 <mauke> > ([] :: [Int]) :: [Char]
09:02:33 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
09:02:33 <lambdabot>         against inferred type...
09:02:44 <mauke> ikt_: ^ similar error
09:02:45 <scopedTV> Yeah, Haskell rigorously separate actions from "pure" values
09:03:00 <mauke> actions are pure values :-)
09:03:07 <scopedTV> mauke: Yeah, I know. :)
09:03:10 <scopedTV> that's the other cool thing.
09:03:12 <mauke> (they just don't do anything)
09:03:38 <martiert> and, just to see if I understand this correctly, there is no way for me to actually return this v, which is a result of an action, since IO might change from each call to the function, thereby giving a different v?
09:03:49 <scopedTV> No, you can use it.
09:04:01 <scopedTV> martiert: do { x <- getLine; return x }
09:04:06 <mauke> martiert: you can literally 'return' it :-)
09:04:15 <mauke> but that changes the type
09:04:29 <martiert> so that will return it as a [String]? or a IO [String]?
09:04:35 <mauke> :t return
09:04:36 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
09:04:41 <byorgey> IO [String].
09:04:52 <scopedTV> martiert: The type will be IO [String]
09:04:59 <scopedTV> return is of type  a -> IO a
09:05:05 <byorgey> martiert: I think you understand correctly.  There's no way to give 'v' as the literal result.  You can use it, but only as part of a further IO action.
09:05:29 <ikt_> mauke: what type does it have? I thought because of "instance Fluffy (EitherLeft t)" it is clear that foo :: (EitherLeft (Left v)) or foo :: (EitherLeft (Right v)) and because it is the 2 part of the pattern matching it only can be  (EitherLeft (Right v))
09:06:10 <byorgey> martiert: you asked about 'returning' it which is perhaps confusing the issue, because there is a function called 'return', but it doesn't do what I think you meant by that word =)
09:07:19 <martiert> byorgey: yeah, seems like I understand it then. Kind of cool though, that haskell is so extreme about the functional paradigm. But I can ofcourse pass v further as a [String] though? Like do { dirs <- getDirectoryContents path; someFunctionThatTakesStrings dirs }, since the result from someFunction will be safe
09:07:19 <mauke> ikt_: EitherLeft (Left v) is not a type
09:07:48 <scopedTV> martiert: Yes, you can pass v along as a [String]
09:08:12 <mauke> ikt_: foo :: EitherLeft t a
09:08:21 <scopedTV> martiert: however if someFunctionThatTakesStrings is of type [String] -> Integer, say, you need to write return (someFunctionThatTakesStrings dirs)
09:08:31 <byorgey> martiert: yes, as long as someFunctionThatTakesStrings results in an IO (something)
09:08:52 <martiert> scopedTV: but the result from that again must be return, and thereby become IO [String]. So basically an IO function can only return a IO?
09:09:17 <mauke> wait, which part is the "IO function"?
09:09:32 <Eelis> int-e: the OPTIONS_GHC idea seemed ideal, but it just doesn't work. maybe it's because the source file in question is not the main one. "ghc-options: -O0" does work, and i guess it's what i'll use, thanks
09:09:43 <scopedTV> martiert: no no, it's not an IO function, it's an IO action. You can compose them (do first this, then that).
09:10:00 <scopedTV> You can't "escape" (i.e. there is no function IO a -> a)
09:10:07 <Eelis> int-e: it's pretty nasty though, ghc is now invoked with both -O and -O0 at the same time, but the -O0 is later so i guess it overrides :/
09:10:15 <martiert> scopedTV: true, forgot that. Yeah. Haskell IO needs some getting used to. But still quite cool as it is strict
09:10:21 <byorgey> martiert: right.  ultimately, you can never use an IO action and result in something which is not an IO action. Though along the way you may make use of non-IO things.
09:10:27 <mauke> martiert: do you happen to know javascript/XMLHttpRequest?
09:10:44 <martiert> mauke: no
09:10:57 <mauke> oh well
09:11:20 <martiert> why?
09:11:22 <scopedTV> martiert: We like to separate IO actions from functions if possible; functions are easier to test.
09:11:27 <byorgey> for example  do { dirs <- getDirectoryContents; print (someComplicatedFunction dirs) }  -- here  someComplicatedFunction could have type   [String] -> Int
09:11:33 <mauke> martiert: because javascript's I/O works the same way
09:11:44 <mauke> except without the types
09:11:55 <Eelis> int-e: maybe i should just file a bug report about ghc crashing on my code..
09:12:57 <ikt_> mauke: and what is wrong withe type of foo :: EitherLeft t a?
09:12:58 <martiert> scopedTV: yeah, I definately see the reason, just quite different from what I'm used to coming from C++. Thinking of an ideal functional paradigm it's fantastic, as you have marked all functions which has side-effect by IO
09:13:18 <scopedTV> they're not really functions.
09:13:21 <byorgey> martiert: yes, exactly =)
09:13:30 <scopedTV> at least i don't call them that. But in C++ they're called functions, yeah.
09:13:38 <mauke> ikt_: nothing per se, but the result must have the type EitherLeft t b
09:14:11 <ikt_> ah, now I understand :)
09:14:17 <martiert> scopedTV: well, as it's functional programming, I like to think of it as function, or procedures might be more appropriate(?)
09:14:29 <scopedTV> procedure is fine. I use "action".
09:14:41 <byorgey> martiert: something of type   String -> IO [String]  is a function.  Something of type   IO [String]  is not a function.
09:14:45 <scopedTV> functions really are things of type a -> b
09:15:06 <mauke> martiert: getLine is a constant, not a function
09:15:08 <scopedTV> I/O actions are things of type IO a, for some a
09:15:37 <scopedTV> note that IO a is not special, you can make lists of IO actions for example
09:15:53 <scopedTV> [getLine, putStrLn "37", getLine, getDirectoryContents "/"]
09:15:59 <scopedTV> this has type [IO ()]
09:16:00 <martiert> byorgey: yeah, I was thinking of the function, the IO [String] I did think of as a type, but that I definately think of as an action now, as it's a huge difference from a type
09:16:14 <ikt_> scopredTV: whats with let f :: Int; f = 3 - that is a function which just returns a specific result, isn't it?
09:16:16 <mauke> scopedTV: type error
09:16:29 <scopedTV> Err. Of course.
09:16:36 <mauke> ikt_: I don't call that a "function"
09:16:49 <mauke> ikt_: I mean, if you do, what's the difference between "function" and "value"?
09:16:51 <scopedTV> ikt_: That's not a function.
09:17:08 <scopedTV> ikt_: a function is something of type a -> b for some a, b.
09:17:10 <anonanon> anybody know how to ask lamdabot to +o me (in my own server instance)
09:17:20 <martiert> so thank you so much for an increased understanding of Haskell. I'll go eat dinner now, and most likely bug you guys later
09:17:35 <anonanon> I've tried '@echo MODE +o myusername' to no avail...
09:17:36 <scopedTV> no problem, i hope we could help.
09:17:52 <martiert> scopedTV: you most definitely did
09:18:34 <martiert> btw, is a database access also considered an IO action? as the database might change? it should at least, but not sure
09:18:42 <scopedTV> sure it is.
09:18:44 <martiert> good
09:18:54 * hackagebot MemoTrie 0.5 - Trie-based memo functions  http://hackage.haskell.org/package/MemoTrie-0.5 (ConalElliott)
09:19:07 <mauke> well, you could FFI import stuff without IO ...
09:19:08 <zzing> If I were wanting to parse a programming language is it best to use Parsec's Token module then Parse?
09:19:09 <scopedTV> executeSql connection "DROP TABLE programming_languages" will be of type  IO () or something.
09:19:11 <martiert> then I'll go eat my lassagna before my girlfriend kills me fore just nerding all night! buy
09:19:20 <int-e> anonanon: you need to provide a channel name for MODE.
09:20:01 <ikt_> mauke: calling this a value makes me think of f as a 'mutable' variable (though of course its not); well I'll stick to value if its common then :)
09:20:07 <anonanon> thx int-e, but even '@echo MODE #haskell +o myusername' isn't working
09:20:17 <scopedTV> ikt_: "value" is fine, yeah
09:20:29 <hpaste> qgel pasted “replace all elemets by minimum” at http://hpaste.org/68342
09:20:50 <mauke> ikt_: er, why do you think of "value" as a mutable thing?
09:20:53 <qgel> how could i check how many passes this does over a list? I'm hoping only one because of lazy evaluation? is that right?
09:21:15 <scopedTV> qgel: No, two.
09:21:33 <ikt_> mauke: good question
09:21:38 <mauke> qgel: why does repMin' exist?
09:21:57 <scopedTV> qgel: You could really write this as repMin xs = map (const r) xs where r = minimum xs
09:22:15 <hpaste> mauke annotated “replace all elemets by minimum” with “replace all elemets by minimum (annotation)” at http://hpaste.org/68342#a68343
09:22:50 <hpaste> mauke annotated “replace all elemets by minimum” with “replace all elemets by minimum (annotation) (annotation)” at http://hpaste.org/68342#a68344
09:22:59 <scopedTV> qgel: As soon as a value in the list is demanded, the whole list is traversed to find the minimum.
09:23:12 <hpaste> mauke annotated “replace all elemets by minimum” with “replace all elemets by minimum (annotation) (annotation) (annotation)” at http://hpaste.org/68342#a68345
09:23:56 * hackagebot vector-space 0.8.1 - Vector & affine spaces, linear maps, and derivatives  http://hackage.haskell.org/package/vector-space-0.8.1 (ConalElliott)
09:23:58 * hackagebot ad 1.5.0.1 - Automatic Differentiation  http://hackage.haskell.org/package/ad-1.5.0.1 (EdwardKmett)
09:24:23 <qgel> scopedTV: Ok, thanks, I'll have to think some more about how to do it in one pass over the list then
09:24:39 <scopedTV> Well, I don't think that's possible, or we misunderstand each other.
09:25:43 <scopedTV> The minimum is computed only once, if that is what you mean.
09:25:47 <mauke> scopedTV: repMin xs = let (m, ys) = repMin' m xs in ys
09:26:12 <scopedTV> It's not O(n^2).
09:26:27 <qgel> scopedTV: It's homework, so I don't want to ask for an answer. The task is to do it in just one pass over the list
09:26:42 <scopedTV> Hm.
09:27:44 <scopedTV> Perhaps your teacher wants to disallow  repMin xs = replicate (length xs) (minimum xs)
09:28:20 <qgel> the naive approave needs to passes over the list (one for minimum, one for map), I guess i have to keep some kind of 'reference' when looking for the minimum that i can just update when i have found the real minimum
09:28:33 <mauke> qgel: that's more or less correct
09:28:42 <qgel> that was what i tried to do
09:28:45 <mauke> except haskell doesn't just let you update things!
09:28:54 * hackagebot unboxed-containers 0.0.2.4 - Self-optimizing unboxed sets using view patterns and data families  http://hackage.haskell.org/package/unboxed-containers-0.0.2.4 (EdwardKmett)
09:29:18 <scopedTV> qgel: Perhaps your teacher wants you to write  repMin xs = replicate l m where (l,m) = lengthAndMinimum xs
09:29:20 <hpc> solution, another function that takes the current min as a parameter
09:29:29 <mauke> scopedTV: no
09:29:37 <qgel> i know that, thats why i wanted to keep each function application in my code unevaluated until i know the min, then apply them (which i guess does not count as a pass over the list)
09:29:52 <scopedTV> mauke: Why not? As an exercise in "tupling" ?
09:30:01 <mauke> qgel: well, that kind of thing happens automatically because Haskell is lazy
09:30:07 <scopedTV> I think qgel'
09:30:11 <hpc> isn't what scopedTV said the way you have to do it?
09:30:12 <scopedTV> s solution is fine. Not 100% sure.
09:30:18 <mauke> qgel: (and yes, lazy evaluation is a kind of "update once" method)
09:30:28 <mauke> scopedTV: didn't you see my solution?
09:30:37 <mauke> hpc: no
09:30:48 <hpaste> qgel annotated “replace all elemets by minimum” with “excercise” at http://hpaste.org/68342#a68346
09:30:58 <scopedTV> mauke: No. Was it the annotations?
09:31:07 <qgel> i think the excercise might clear things up more then i could
09:31:15 <mauke> scopedTV: no
09:31:35 <scopedTV> Then I did not see it, no. Did you paste it?
09:32:40 <hpc> oh, now i see how to do it
09:33:00 <scopedTV> Ah, the exercise indeed clarifies it.
09:33:01 <mauke> qgel: you know what, your original code is actually pretty close
09:33:19 <qgel> I'm more looking for a way to verify if i get it right, so I don't stumble in the dark forever ^^
09:33:27 <mauke> qgel: you just have to rewrite minimum/map as a single function
09:33:54 <qgel> that return the tuple i suppose?
09:33:58 <mauke> qgel: yes
09:34:13 <qgel> OK, I will try that, thank you
09:35:19 <scopedTV> I'm not sure why the exercise introduces repMin'
09:36:33 <mauke> how would you do it without?
09:36:58 <scopedTV> I'd write repMin xs = replicate l m where (l,m) = lengthAndMin xs
09:37:09 <scopedTV> and then write lengthAndMin somewhere; that traverses the list once.
09:38:30 <mauke> but replicate is another pass
09:38:50 <scopedTV> I don't see what a "pass" is, then.
09:38:51 <qgel> I guess they do it because it is supposed to be an excercise in lazy evaluation? I don't see how that comes to play in your solution
09:38:55 * hackagebot comonad-extras 2.1.1.1 - Comonad transformers requiring extensions to Haskell 98  http://hackage.haskell.org/package/comonad-extras-2.1.1.1 (EdwardKmett)
09:38:57 * hackagebot representable-functors 2.4.0.1 - Representable functors  http://hackage.haskell.org/package/representable-functors-2.4.0.1 (EdwardKmett)
09:39:05 <mauke> I mean, why bother computing the length, then doing replicate, when you can just return the right list in the first place?
09:39:24 <scopedTV> Because it's clearer what's going on.
09:39:40 <mauke> it also doesn't solve the issue
09:40:11 <scopedTV> Yeah, I do not understand Haskell, so much is clear. I never have understood any evaluation model nor how to reason about efficiency.
09:40:59 <mauke> "Using lazy programming, it is possible to find the minimum and replace all elements in one iteration."
09:41:06 <mauke> replicate iterates a second time
09:41:14 <scopedTV> What in the world is "replacement"
09:41:39 <byorgey> dcoutts: is the default-language flag documented somewhere?
09:42:16 <byorgey> in particular I'm wondering whether it is a global flag or needs to be stuck in a Library or Executable stanza
09:42:35 <byorgey> and also whether cabal init should prompt for it
09:42:40 <byorgey> (and what the choices are)
09:49:27 <monochrom> oh rep-min? using lazy programming, it is possible in one explicit traversal and one hidden traversal
09:50:00 <monochrom> (and a hidden replication of the input tree)
09:50:03 * jonaskoelker takes a deep whiff of the air
09:50:10 <hpaste> scooty-puff pasted “Help with type errors” at http://hpaste.org/68347
09:50:13 <scopedTV> This is folklore?
09:50:18 <jonaskoelker> ahhh, the near-french arrogance of functional programmers =)
09:51:03 <scooty-puff1> so i guess i'm scooty-puff1 now..
09:51:10 <scooty-puff1> anyways, in the paste http://hpaste.org/68347
09:51:17 <scooty-puff1> i list the issues i am having
09:53:55 * hackagebot adjunctions 2.4.0.1 - Adjunctions  http://hackage.haskell.org/package/adjunctions-2.4.0.1 (EdwardKmett)
09:53:57 * hackagebot kan-extensions 2.4.0.1 - Kan extensions, the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-2.4.0.1 (EdwardKmett)
09:55:00 <jonaskoelker> ,2+2
09:55:05 <jonaskoelker> !2+2
09:55:10 <jonaskoelker> bot?
09:55:13 <barrucadu> > 2+2
09:55:14 <lambdabot>   4
09:55:25 <hpaste> qgel annotated “replace all elemets by minimum” with “new repMin'” at http://hpaste.org/68342#a68348
09:55:31 <jonaskoelker> thanks, barrucadu :)
09:56:10 <jonaskoelker> hmm... does it do pointfree-ification?
09:56:20 <scopedTV> @pl
09:56:21 <lambdabot> (line 1, column 1):
09:56:21 <lambdabot> unexpected end of input
09:56:21 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
09:56:30 <scopedTV> @pl \x y -> x + y
09:56:31 <lambdabot> (+)
09:56:39 <scopedTV> pl is "pointless"
09:57:14 <jonaskoelker> ah, thanks, scopedTV :)
09:57:19 <strager> I have a Writer which 'tell's some strings.  I'd like to write all the strings it tells to stdout (using putStrLn).  I'm doing (effectively) execWriter >>= mapM_ putStrLn, but it seems it only prints when the writer is done, and not lazily like I expected.
09:57:29 <qgel> mauke: was this the repMin' function you meant?
09:58:10 <monochrom> what happens to repMin' [] r? why do you forbid it?
09:58:27 <monochrom> why do people never think of the empty list?
09:58:37 <qgel> because there is no minimum of the empty list
09:58:43 <scopedTV> So?
09:58:46 <cg_morton> strager: what's not lazy about that?
09:58:46 <monochrom> oh, sorry
09:58:47 <Saizan> strager: is this WriterT over IO?
09:58:48 <scopedTV> every element is replaced.
09:58:56 * hackagebot representable-tries 2.4.0.1 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-2.4.0.1 (EdwardKmett)
09:58:57 <scopedTV> repMin [] = [] imo
09:59:25 <strager> Saizan: Yes; WriterT IO [String] a
09:59:50 <strager> Can I not interleave IO like that?  =[
09:59:59 <Saizan> nope
10:00:35 <strager> Is there else I can do?  I'm not restricted to WriterT; I just want to "notify" someone far outside
10:00:50 <strager> (I'm using this for warning/error reporting/collection, etc.)
10:00:58 <strager> Is there something else **
10:01:06 <qgel> monochrom: what did you mean by 'hidden replication of the input tree' ?
10:01:07 <Saizan> since you're in IO you could just print as you go along
10:01:37 <Saizan> or maybe use concurrency by sending this stuff to a Chan and have another thread deal with it
10:01:43 <monochrom> well, I thought you were doing rep-min for a tree. change "tree" to "list"
10:02:04 <mysticc> How to get the ith character of a bytestring ?
10:02:08 <strager> I guess you're right; I can have my 'tell' wrapper print if I'm in IO
10:02:26 <strager> mysticc: http://www.haskell.org/hoogle/?hoogle=Int+-%3E+ByteString+-%3E+Word8
10:02:36 <qgel> ok, but still what is the hidden replication? I don't think I understand where it occurs
10:02:58 <monochrom> if your input list is [2,1,3], then you will build up a lazy expression 2 `min` 1 `min` 3. that replicates the input list.
10:03:27 <qgel> ahh, thanks
10:03:31 <mysticc> @hoogle Int->ByteString->Word8
10:03:32 <lambdabot> Data.ByteString index :: ByteString -> Int -> Word8
10:03:32 <lambdabot> Data.ByteString.Unsafe unsafeIndex :: ByteString -> Int -> Word8
10:03:32 <lambdabot> Data.Data gmapQi :: Data a => Int -> (forall d. Data d => d -> u) -> a -> u
10:03:56 * hackagebot algebra 2.1.1.1 - Constructive abstract algebra  http://hackage.haskell.org/package/algebra-2.1.1.1 (EdwardKmett)
10:05:55 <schlicht> the wxhaskell docu is kind of ... short, or am i looking at the wrong one?
10:05:58 <ymasory> what's the nicest way to take the sum of (Monoid m) => [Maybe m]?
10:06:58 <monochrom> use catMaybes to reduce the problem to (Monoid m) => [m]
10:08:30 <ymasory> monochrom: thanks
10:08:44 <mekeor> can i pattern match on a constructor of a data-type which isn't an instance of Eq?
10:08:55 <ymasory> monochrom: the name of the function is catMaybe?
10:09:10 <mekeor> @hoogle catMaybe
10:09:10 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
10:09:11 <scopedTV> mekeor: Sure.
10:09:29 <mekeor> scopedTV: cool, okay, great, thanks.
10:10:35 <monochrom> in pattern matching, only numeric literals need Eq
10:10:38 <tromp_> > 9*product[1..9]
10:10:39 <lambdabot>   3265920
10:11:17 <tromp_> > 1594548/3265920
10:11:18 <lambdabot>   0.4882385361552028
10:11:19 <mekeor> monochrom: ah, okay.
10:11:40 <mekeor> tromp_: you can also PM lambdabot, just fyi.
10:11:56 <tromp_> thx for suggestion, mauke
10:12:18 <mekeor> mekeor… doesn't matter though…
10:12:25 <edwardk> preflex: xseen roconnor
10:12:25 <preflex>  roconnor was last seen on freenode/#haskell-blah 6 hours, 16 minutes and 3 seconds ago, saying: sipa: what are you speaking about?
10:12:45 <roconnor> here
10:13:35 <xplat> why do i get this?  Symbol's function definition is void: inferior-haskell-load-file
10:15:45 <mekeor> xplat: if nobody answers and you can't find a solution yourself, i'd suggest the haskell-mode-ML.
10:16:26 <xplat> it seems haskell-site-file.el contains an autoload for it, but nothing loads haskell-site-file.el
10:21:04 <tazjin> @hoogle (m a, m b) -> m (a, b)
10:21:05 <lambdabot> No results found
10:21:28 <hpc> :t uncurry $ liftM2 (,)
10:21:29 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
10:23:00 <mysticc> What is the complexity of (//) operation for immutable arrays ?
10:23:37 <Saizan> O(n) where n is the size of the array
10:24:37 <mysticc> Saizan: Is it possible to update a single index in O(1) ?
10:25:20 <srhb> mysticc: What kind of immutable arrays are you using? Probably yes.
10:25:23 <Saizan> mysticc: nope
10:25:59 <mysticc> srhb: Data.Array
10:26:09 <srhb> Saizan: Really? Are you sure? Isn't that exactly the point of immutable arrays rather than lists, assuming you don't use the old copy?
10:26:34 <Saizan> every modification of the array requires creating a whole new one, so you benefit from doing a bunch of them all at once if you can
10:27:01 <Saizan> srhb: you can lookup in O(1) but you can't update even a single location in O(1)
10:27:31 <srhb> Saizan: Oh. Thanks for clarifying that. I thought both operations would indeed be O(1)
10:27:33 <scooty-puff1> is it possible to have a reader's env be the continuation (from callCC) of a ContT it wraps, and be useful?
10:27:45 <scooty-puff1> i do not know how to write the type - rank-2 types don't quite work
10:27:50 <mysticc> Saizan: Is there any data structure in which it is possible (immutable).
10:27:51 <Eduard_Munteanu> srhb: you only get that with mutable arrays
10:27:56 <Eduard_Munteanu> e.g. ST(U)Array
10:28:08 <hpaste> scooty-puff1 pasted “i.e.:” at http://hpaste.org/68350
10:28:17 <Saizan> srhb: DiffArrays did try to do something like that, but they ended up being quite slow most of the time
10:28:22 <mysticc> Eduard_Munteanu: Then I will have to do all operation inside the state monad
10:28:27 <Saizan> mysticc: Data.Sequence gets quite close
10:28:30 <srhb> Eduard_Munteanu, Saizan: Thanks. :)
10:28:34 <Eduard_Munteanu> Or if the compiler is smart enough to do some mutation behind your back, but GHC doesn't do this AFAIK.
10:28:44 <srhb> Eduard_Munteanu: That was exactly what I thought was happening.
10:28:59 * hackagebot reducers 0.3 - Semigroups, specialized containers and a general map/reduce framework  http://hackage.haskell.org/package/reducers-0.3 (EdwardKmett)
10:29:02 <Eduard_Munteanu> Seq is O(log n)-ish however, or something like that.
10:30:29 <Saizan> O(log(min(i,n-i)))
10:34:01 * hackagebot compressed 0.3 - Compressed containers and reducers  http://hackage.haskell.org/package/compressed-0.3 (EdwardKmett)
10:34:03 * hackagebot profunctors 0.1.2.2 - Haskell 98 Profunctors  http://hackage.haskell.org/package/profunctors-0.1.2.2 (EdwardKmett)
10:34:05 * hackagebot semigroupoid-extras 0.2.7.1 - Semigroupoids requiring Haskell extensions  http://hackage.haskell.org/package/semigroupoid-extras-0.2.7.1 (EdwardKmett)
10:34:07 * hackagebot marionetta 0.1.0.3 - A study of marionetta movements.  http://hackage.haskell.org/package/marionetta-0.1.0.3 (PaoloVeronelli)
10:38:08 <lamefun2> how to yield magic from monads?
10:39:00 * hackagebot profunctor-extras 0.3.2.2 - Profunctor extras  http://hackage.haskell.org/package/profunctor-extras-0.3.2.2 (EdwardKmett)
10:41:01 <cg_morton> lamefun2: probably something like:  magic <- magicMonad
10:41:23 <S11001001> magic <$> monad
10:41:53 <hpc> unsafePerformMagic
10:42:06 <hpc> http://tvtropes.org/pmwiki/pmwiki.php/Main/DangerousForbiddenTechnique
10:42:11 <srhb> Which, despite its name, is always safe.
10:42:14 <srhb> fsvos
10:42:39 <edwardk> 'return magic'
10:42:54 <srhb> That's not quite "from" monad, is it?
10:43:07 <edwardk> const magic :: Monad m => m a -> Magic
10:43:17 <srhb> :>
10:49:01 * hackagebot representable-profunctors 0.4.2.2 - Representable profunctors  http://hackage.haskell.org/package/representable-profunctors-0.4.2.2 (EdwardKmett)
10:49:03 * hackagebot trifecta 0.51 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.51 (EdwardKmett)
10:50:18 <edwardk> @tell eelis recursion-schemes should now work with containers 0.5 like you wanted
10:50:18 <lambdabot> Consider it noted.
10:50:45 <Eelis> edwardk: thanks! enough stuff now compiles that i can compile my own program again :)
10:50:46 <lambdabot> Eelis: You have 1 new message. '/msg lambdabot @messages' to read it.
10:51:06 <edwardk> in theory everything i have should be compatible with containers 0.5 except for order-statistics
10:51:06 <edsko> @undo do x <- return (Left 5) ; print x
10:51:07 <lambdabot> return (Left 5) >>= \ x -> print x
10:51:14 <edsko> @undo do Left x <- return (Left 5) ; print x
10:51:14 <lambdabot> return (Left 5) >>= \ a -> case a of { Left x -> print x; _ -> fail ""}
10:51:14 <edwardk> which sadly depends on statistics which depends on parallel
10:51:30 <edwardk> i removed a couple of parallel dependencies to unblock myself
10:51:42 <edwardk> but performance shouldn't be unduly compromised
10:52:20 <nurpax> I'm new to forkIO and dealing with concurrency with processes.  I'd like to implement an Ircbot where my main thread would process IRC messages while another thread forks a process and reads its output line by line.  I'd like the main thread to act on these lines asynchronously.  Should I use something like the Control.Concurrent.Chan?
10:53:06 <lamefun2> So it's not the fact that IO is a monad that makes it magical?
10:53:53 <edwardk> IO isn't magical. it just takes the real world, and gives you back an answer and a whole new world.
10:54:02 * hackagebot recursion-schemes 2.0.1.1 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-2.0.1.1 (EdwardKmett)
10:54:04 <roconnor> edwardk: how can you say that?
10:54:11 <nurpax> actually I tried the 'Chan' part so that I forkIO with a loop that gets a line from the process and then writes it on the Chan.  but I'm a bit at loss as to how I should deal with waiting for the process to eventually exit
10:54:15 <edwardk> roconnor: with sarcasm
10:54:42 <edwardk> and by typing on a keyboard
10:54:58 <jfischoff> lamefun2: a monad is just a way to encapsulate the evil
10:55:34 <edwardk> roconnor: i had to push out bumped versions of data-lens-template and data-lens-fd, you may also want to check that they are compatible with your 2.10 versions and/or ship versions that are.
10:55:56 <whittle> I have written two packages, let’s call them A and B, where A depends on B. B builds fine and works in GHCi. When I attempt to import from B in A, I get an unknown symbol error during the linking phase. Where should I start debuggin?
10:56:05 <edwardk> roconnor: i tried catching you on irc, but we've been ships in the night for the last couple of weeks
10:57:07 <edwardk> lamefun: you can remove all of the magic from IO if you want to move the magic out to the runtime system that drives your language
10:57:13 <roconnor> edwardk: I'm in Paris
10:57:22 <edwardk> that would explain the time shifting =)
10:57:43 <roconnor> edwardk: I did push data-lens-template and data-lens-fd with updated dependencies
10:57:45 <roconnor> eventually
10:58:10 <edwardk> ah k, i'll check to make sure i didn't break anything
10:58:39 <jfischoff> roconnor: I've been meaning to ask you about the direction of data-lens. Are you going to add more arrow like functionality, beside first/second ?
10:59:13 <edwardk> jfischoff: what else works?
10:59:17 <roconnor> jfischoff: is there more functionaly that can be added?
10:59:18 <jfischoff> no idea
10:59:49 <edwardk> lenses sadly don't really have many other well-known categorical properties you can exploit
11:00:03 <jfischoff> for the partial lenses it seems like some arrow choice like functionality should be possible
11:01:02 <roconnor> jfischoff: possibly more so for the multilenses I am developing
11:01:34 <jfischoff> roconnor: interesting, what are multilenses?
11:01:37 <tgeeky> roconnor: what would be a more categorical sounding name for this developing project? this isn't multiplate, right?
11:02:06 <jfischoff> hey tgeeky
11:02:11 <tgeeky> jfischoff: hello
11:02:46 <roconnor> jlaire: lenses point to 1 substructure, ; partial lenses point to 0 or 1 substructures ; multilenses point to 0 or more substructures.
11:02:48 <roconnor> er
11:02:51 <roconnor> jfischoff: ^^
11:03:00 <jfischoff> tgeeky: been working on the pi-eta stuff. I need to really work on my unification skills
11:03:05 <roconnor> jfischoff: multilenses are morally the same thing as biplates from uniplate
11:03:29 <tgeeky> roconnor: woohoo! more multiplate work! <3
11:04:07 <jfischoff> roconnor: yes, multi lenses are what I want. I need a way to combine lenses to clean up my code.
11:04:27 <tgeeky> jfischoff: before you say that, you probably need to read his paper
11:04:29 <hpaste> scooty-puff1 pasted “Help merging ReaderT and ConT” at http://hpaste.org/68355
11:04:43 <scooty-puff1> cleaned up post from earlier
11:04:46 <tgeeky> jfischoff: or check out the code (multiplate)
11:05:03 <jfischoff> tgeeky: which paper? the multi plate paper?
11:05:13 <tgeeky> jfischoff: yep
11:05:24 <jfischoff> yeah I've only skimmed it
11:07:55 <jfischoff> roconnor: I'm using Either String instead of Maybe for my partial lenses. Is there a way to design the partial lenses, perhaps using type classes, so alternative error handling strategies can be used?
11:11:25 <stobix_> hi! Is there something similar to the Num class for binaries? I want to use my data type with "and", "or" and the likes.
11:11:50 <jfischoff> stobix_:look at Data.Bits
11:12:07 <stobix_> jfischoff: will do, thanks
11:14:35 <teneen> Why is fromList in Data.Map.Lazy strict?!
11:14:59 <tgeeky> teneen: because you need the whole list all at once?
11:15:42 <copumpkin> teneen: strict in what?
11:16:01 <teneen> copumpkin: it uses foldStrict
11:16:14 <teneen> Why can't I have a lazy infinite Map?
11:16:22 <copumpkin> because the data structure doesn't allow that
11:16:24 <c_wraith> you can't have an infinite map anyway
11:16:29 <c_wraith> the data structure is spine-strict
11:16:34 <copumpkin> I'm sure it's lazy in the values still
11:16:50 <c_wraith> the Lazy map is only Lazy in the values put in it.
11:17:01 <c_wraith> I'm not sure when this is something you *want*, but there probably is some case.
11:17:24 <copumpkin> think of the various dynamic programming exercises with lazy arrays
11:17:30 <copumpkin> the same idea works for lazy-value maps
11:17:39 <c_wraith> yeah, that was the only thing I could come up with
11:17:42 <copumpkin> and they're more flexible if a tad less efficient
11:18:07 <copumpkin> well, a data structure I use a lot is a heterogeneous trie, with a map-branching node
11:18:11 <c_wraith> a tad less efficient? With common use cases, they use n times as much memory
11:18:20 <c_wraith> where n is the number of modifications you perform to the map
11:18:22 <copumpkin> you could construct tries of infinite lists using lazy values
11:21:30 <hpaste> scooty-puff1 annotated “Help merging ReaderT and ConT” with “Help merging ReaderT and ConT (annotation)” at http://hpaste.org/68355#a68356
11:22:05 <dcoutts> byorgey: default-language and other-languages are like default-extensions and other-extensions, they live in the per-component sections
11:23:03 <teneen> Is there some package which allows infinite efficient trees?
11:23:15 <c_wraith> teneen: sure.
11:23:25 <c_wraith> depending on your definition of infinite
11:23:33 <EvanR> not finite
11:23:36 <EvanR> *bam*
11:23:44 <c_wraith> infinite tries are relatively easy to make lazy
11:23:49 <teneen> c_wraith: I want to memoize a sparse function
11:23:50 <dcoutts> byorgey: there's two choices for default-language, Haskell98 or Haskell2012. You only need other-languages if the component uses modules with a mix of language pragmas.
11:23:51 <c_wraith> infinite binary trees? not so much
11:24:02 <teneen> c_wraith: I do not want to use memocombinators
11:24:13 <c_wraith> teneen: is the input something you can make into a trie?
11:24:38 <teneen> yes
11:25:11 <c_wraith> because memocombinators is implemented in terms of http://hackage.haskell.org/package/data-inttrie
11:25:39 <c_wraith> Which is an infinite trie
11:26:03 <teneen> Can I do something similar with a tree?
11:26:27 <c_wraith> Not comparison-based
11:26:44 <c_wraith> the thing that makes it work with a trie is that it isn't comparison-based
11:27:02 <gwern> @dice 1d2
11:27:02 <lambdabot> 1d2 => 2
11:27:24 <tac-tics> dice monad?
11:27:39 <c_wraith> you can lazily construct the entire input space (even if it's infinite) with a trie, and there will only ever be one correct path to the node corresponding to each value
11:28:48 <teneen> c_wraith: I want to implement it myself. I'm not really familiar with tries. Is there a good introduction somewhere?
11:29:16 <whittle> I have written packages A and B, where A depends on B. Package B gets a clean bill of health from HLint and builds without warning or error. When I list B as a build-depends in A.cabal and import a function from a module in B, during linking I get an unknown symbol error. Does anyone have any advice on how to debug this? I would appreciate just knowing which package I should be investigating.
11:29:33 <roconnor> jfischoff: I don't think I will add Either String be doing that; in fact, I'm planning to hide the Maybe represenation;  It has already cause too many problems :D.
11:29:52 <roconnor> jfischoff: in general I recommend always using Maybe for things that can fail in one way.
11:30:01 <dcoutts> whittle: list all the modules in the library in either exposed-modules or other-modules. That's the only way that Cabal knows they should be included in the library.
11:30:11 <roconnor> jfischoff: it is then upto the caller to use turn it into an Either String
11:30:33 <c_wraith> teneen: hmm. come to think of it, the only descriptions I've seen have been terrible, for such a simple concept
11:30:39 <whittle> dcoutts: Got it. Thanks.
11:31:35 <teneen> c_wraith: I understand the concept but I never implemented it nor have I seen a simple decent implementation
11:32:04 <c_wraith> well, most implementations use a lot of crazy optimizations
11:33:38 <teneen> c_wraith: I guess I'll have to do some reading about them. Anyways thanks a lot :)
11:33:49 <stobix_> Hm. Data.Bits wasn't really what I was looking for. I am playing around with negabinaries, and it seemed like a good idea to use "or" as the ring-based addition I want to implement normal addition... Defining something like foo a b = if a+b > 1 then 1 else a+b; does not have the constraints on a and b to be eihter 0 or 1. It feels kinda sloppy.
11:34:38 <stobix_> (oh. sorry for grammar/semantical mistakes. My head is kinda in a haze from having a cold right now.)
11:35:21 <jfischoff> roconnor: I agree, Maybe is not fundamental to partial lenses.
11:37:12 <jfischoff> roconnor: I agree with your comment about maybe in general. When I use a lens on a sum type, I want to know what constructor is in use and what was expected. It is such a common use case, that it is noise to convert the error later, as opposed to build it into the lens. Maybe I am misusing partial lenses though...
11:38:01 <roconnor> jfischoff: I'm thinking of having pesudo-constructors that convert partial lenses to and from a -> Either a (Store b a)
11:38:11 <roconnor> or rather
11:38:27 <roconnor> a -> (Identity :+: Store b) a
11:38:39 <roconnor> so you get the full coalgebra functionality
11:39:03 <roconnor> jfischoff: it is an interesting proposal; but it is somewhat specific to field of a constructor.
11:39:30 <roconnor> jfischoff: maybe it is functionaly that the data-lens-template could generate.
11:39:50 <roconnor> ... btw if someone want to extend data-lens-template to support partial lenses, that'd be great
11:41:26 <jfischoff> roconnor: Yeah, it is very specific, but common and yes data-lens-template could generate it. I'll extend the data-lens-template if you can figure out a good way to make the type of lenses I'm using with data-lens.
11:42:03 <hpaste> “Jonathan Fischoff” pasted “either lens th code” at http://hpaste.org/68357
11:42:28 <jfischoff> ^ some simple code to generate the either lenses I was talking about
11:45:30 <hpaste> “Jonathan Fischoff” pasted “Either String Lens” at http://hpaste.org/68358
11:45:32 <roconnor> jfischoff: it is easy to tell what constructor was given, but I don't see how it is possible to know what constructor(s) was "expected".
11:46:11 <jfischoff> wait am I doing that...
11:46:26 <roconnor> jfischoff: I think you need to build your own data structure to wrap around a partial lens to "remember" this information.
11:48:16 <jfischoff> roconnor: I just mean the error is like "you used a lens for Constructor1 but you actually had a value with Constructor2"
11:48:36 <roconnor> jfischoff: yes, but how do you tell if a lens is for Constructor1
11:48:46 <roconnor> for example, the nullLens works on no constructors
11:49:01 <roconnor> and you can have lenses that work on two or more constructors
11:49:10 <roconnor> *partial lenses that work on two or more constructors
11:49:12 <jfischoff> roconnor: if the lens is generate for a data type you know
11:49:17 <jfischoff> sure
11:49:53 <monochrom> Data.Map.Lazy does not mean that the map is lazy. it means that some operations such as insertWith are lazy. and not lazy in the map. instead, lazy in some keys and values.
11:50:02 <roconnor> jfischoff: right, ... I think I'd recommend a wrapper around a partial lens that remembers what the lens was for
11:50:25 <Eelis> i've noticed that with a UTF-8 locale, peekCString now simply drops invalid byte sequences instead of replacing them with the replacement character "�". is this intentional? can i rely on this?
11:50:47 <jfischoff> roconnor: is the wrapper a lens?
11:51:11 <jfischoff> I just trying to make sure I understand how you compose the wrapped lenses
11:51:34 <monochrom> actually, can't be lazy in keys either. only lazy in values.
11:51:36 <whittle> dcoutts: Thanks for the advice. That did it.
11:52:20 <roconnor> jfischoff: data ELens a b = { ctrName :: String plens :: PartialLens a b }
11:52:50 <roconnor> jfischoff: er, I have no idea how to compose these lenses
11:53:17 <monochrom> of course, the opening paragraphs of Data.Map.Lazy says that, too
11:53:20 <roconnor> I guess you need to concatinate teh ctrName ... at which point you probably want a more sophisticated data type than String.
11:54:41 <jfischoff> I see. On error you would get something like a lens call stack, as opposed to just the location where the error occured
11:54:46 <roconnor> right
11:54:57 <jfischoff> which I like more
11:54:57 <roconnor> and idlens would give you the empty callstack
11:55:03 <roconnor> well idelens
11:55:10 <jfischoff> interesting
11:55:19 <roconnor> but idlens cannot fail :D
11:58:23 <jfischoff> so this ties back to what I was thinking before. I would like to be able to substitute ELens for PartialLens and have all the combinators for lenses stay the same. (getL, setL, modL, etc)
11:58:59 <roconnor> jfischoff: hmm; I guess I'd write a module with a compatible interface and switch modules.
11:59:01 <jfischoff> err getPL, etc
11:59:26 <jfischoff> yeah that would work
11:59:50 <roconnor> alterantively we could write at type class ... but I think the module approach would be better
11:59:52 <jfischoff> but it seems like there is partial lens interface lurking here that could made into a type class
12:00:26 <jfischoff> I guess it is better before the proper classes emerge
12:01:35 <roconnor> I wonder what xplat would do
12:01:50 <jfischoff> wwxd
12:01:55 <roconnor> :D
12:07:07 <edwardk> what would xplat do has a nice ring to it
12:08:03 <jfischoff> more reason to make #haskell the superhero cartoon.
12:08:14 * edwardk is afraid
12:09:07 <edwardk> all i ask is that i get portrayed as a sympathetic villain, if you must make me a supervillain
12:10:50 <jfischoff> you wish, e -> k is more like Data from the Goonies
12:10:55 <mgsloan>  knights of the cartesian closed category
12:11:25 <edwardk> jfischoff: hahaha
12:12:12 <edwardk> you should know me well enough to know that i'd be parametric in the category type ;)
12:12:16 <edwardk> e a k ;)
12:12:21 <jfischoff> haha
12:12:43 <jfischoff> Category a => e a k
12:12:50 <jfischoff> err a ek
12:13:25 <edwardk> nah, Semigroupoid
12:18:08 <Franciman> hey people, where can I find a tutorial on how to add haskell mode and autocompletion and anything else is important to develop to emacs?
12:18:59 <donri> Franciman: https://github.com/haskell/haskell-mode#haskell-mode-for-emacs does that help?
12:19:02 <srhb> http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs
12:19:13 * hackagebot haskell-src-exts 1.13.3 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/haskell-src-exts-1.13.3 (NiklasBroberg)
12:19:28 <kallisti> Franciman: understanding how the module system works would be a good place to start.
12:19:29 <hpaste> scooty-puff1 annotated “Help merging ReaderT and ConT” with “Help merging ReaderT and ConT (annotation) (annotation) - This works!” at http://hpaste.org/68355#a68360
12:19:36 <kallisti> Franciman: assuming you don't already
12:23:16 <edwardk> i'm pretty sure ddarius would wind up being portrayed as some android like the vision, too young to know all he knows
12:24:33 <edwardk> copumpkin is clearly some neil gaiman or garth ennis character, something like john constantine, just using agda rather than magic for his incantations
12:24:50 <copumpkin> lol
12:25:50 <Franciman> ok thanks
12:26:18 <Franciman> and what about autocompletion?
12:27:08 <b52> i want a convert for String -> MyType
12:27:22 <b52> should I create a read instance for MyType ?
12:27:26 <kallisti> no
12:27:27 <monochrom> that is "parsing"
12:27:35 <kallisti> there's a typeclass for you called IsString
12:27:37 <kallisti> in Data.String
12:27:42 <quicksilver> deriving Read might be all you need.
12:27:49 <b52> quicksilver: the mapping isn ot 1:1
12:27:57 <quicksilver> IsString seems very unlikely to be what you want.
12:28:18 <Eduard_Munteanu> Generally, you want read . show = show . read = id or close.
12:28:23 <quicksilver> if deriving Read isn't enough then youpresumably have to write a proper parser.
12:28:27 <monochrom> IsString merely gives you a place to put your parser. does not write the parser for you.
12:28:36 <b52> monochrom: i know
12:28:39 <b52> its simple string pattern matching
12:28:47 <b52> but isstring looks fine
12:30:56 <b52> http://paste.xinu.at/7apj/ thars what i wanted
12:31:14 <monochrom> well, I just find it odd to suggest "IsString" in the context of the question. it is like, Q: "I am writing an IRC bot" A: "put it in a directory called MyBot". Thank you very much!
12:31:44 <kallisti> it was a question of "where should I define this?"
12:32:10 <donri> b52: don't use IsString for that
12:32:27 <b52> donri: what else?
12:32:31 <quicksilver> That strikes me as an abuse of literal overloading.
12:32:34 <donri> b52: why not simply a "suite" function?
12:32:49 <b52> dunno
12:32:53 <monochrom> oh well, perhaps it was
12:32:59 <b52> i asked what would be a good way
12:33:03 <b52> cause i dont know
12:33:06 <donri> b52: or don't derive Show automatically and make Read/Show work like that
12:33:19 <kallisti> b52: to be safer you could wrap the result in a Maybe
12:33:28 <quicksilver> mind you, most use of literal overloading strikes me as abuse, since I don't like it. But if it is to be used at all, it is mostly for types where fromString is a total function, and the type really does represent sequences of chars.
12:33:31 <kallisti> but I've seen similar uses of IsString so  -shrug-
12:34:45 <b52> http://paste.xinu.at/FpWku/
12:35:05 <b52> damn tabs
12:35:27 <donri> b52: what's it for anyway? are you actually getting those strings from the outside?
12:35:34 <b52> yes
12:35:43 <kallisti> oh, then yeah you want to use Maybe most likely
12:35:45 <kallisti> to avoid runtime errors.
12:35:48 <kallisti> from arbitrary input.
12:35:53 <b52> the input will match
12:35:58 <b52> no worries
12:36:06 <srhb> Famous last words.
12:36:07 <srhb> :-)
12:36:24 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.glasgow.user/22065/ hehe
12:36:29 <donri> b52: screw it, why even use haskell! everything will always work as i expect!
12:36:38 <b52> ?
12:37:04 <donri> sorry, joking
12:37:46 <monochrom> well, it is entirely possible that the input grammar is unrestrictive and there is no parse error, ever
12:37:57 <donri> b52: a lot of the motivation for the strong type system is that programs rarely work exactly like you expect
12:38:35 <monochrom> only surprising parses, but no parse errors
12:38:42 <srhb> And a lot of the motivation for Maybe is "why not"
12:38:43 <donri> so making your suite function return a Maybe forces you to consider the Nothing case everywhere
12:39:11 <fmap> Are there any non-trivial json examples parsed by aeson?
12:39:33 <kallisti> fmap: what do you mean by non-trivial?
12:39:38 <donri> (well, you can have partial pattern matches, but you can also have ghc warn for those)
12:39:41 <kallisti> I have a library whose core logic is more or less a bunch of JSON parsing.
12:39:55 <kallisti> @hackage webdriver
12:39:55 <lambdabot> http://hackage.haskell.org/package/webdriver
12:41:24 <fmap> kallisti: well, like http://stackoverflow.com/questions/7670072
12:41:29 <fmap> but working
12:43:02 <kallisti> head $ o .: "query" .: "pages" is a type error I believe.
12:43:08 <kallisti> because .: wraps the result in a Parser
12:43:35 <fmap> kallisti: sure, his code doesn't work
12:43:47 <b52> http://paste.xinu.at/91T1kj/ is that fine ?
12:44:03 <fmap> kallisti: i'll take a look at webdriver, thanks
12:44:14 <kallisti> o .: "query" >>= (.: "pages")
12:44:16 <kallisti> should work
12:44:32 <kallisti> and of course he should be binding those names with <- (id, names, and links), not using let.
12:49:41 <scooty-puff1> anyone have the link for the c-sytle haskell article/blog post from a while ago?
12:50:59 <b52> omfg i love monads :D
12:51:18 <b52> http://paste.xinu.at/4i1/ error handling for free :D
12:52:15 <kallisti> if you import Control.Applicative
12:52:29 <kallisti> you could write it like this:  Card <$> toSuite [last s] <*> toValue (init s)
12:52:32 <roconnor> b52: check out (Card <$> toSuite [last s] <*> toValue (init s))
12:52:37 <kallisti> roconnor: ha! I win!
12:52:37 <roconnor> damn
12:52:38 <roconnor> too slow
12:52:40 <scooty-puff1> anyways, this is probably similar: http://hastebin.com/raw/luqepapiyi
12:52:42 <b52> holy moly
12:52:44 <b52> :D
12:52:46 <b52> <3 you guys :D
12:53:08 <donri> maybe you should make toSuite take a Char instead ...
12:54:21 <roconnor> b52: with haskell there is always a more awesome way to write code ... unfortunately this fact somewhat stalls actually making progress with your code. :D
12:54:25 <monochrom> yes, the Maybe monad is nice
12:54:53 <roconnor> monochrom: it is commutative.
12:55:50 <monochrom> my http://www.haskell.org/haskellwiki/Dynamic_programming_example illustrates a great beautification by the Maybe monad
12:55:52 <b52> anyway to remove the "toCard "" = Nothing" defintion?
12:56:32 <monochrom> toCard s = do { guard (not (null s)); suite <- ... }
12:59:15 * hackagebot semigroups 0.8.3.2 - Haskell 98 semigroups  http://hackage.haskell.org/package/semigroups-0.8.3.2 (EdwardKmett)
13:01:09 <kallisti> b52: yeah but I think it's probably the cleanest way to do.
13:01:51 <kallisti> you could do what monochrom suggested above with guard
13:01:55 <kallisti> but that's more code.
13:04:04 <b52> http://paste.xinu.at/cd8hT/ any improvments to that one`?
13:06:33 <EvanR> :t guard
13:06:34 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
13:06:56 <vodik> b52: guard (card /= 5) >> return (Hand ...)
13:07:21 <vodik> missed the length bit, opps
13:08:38 <vodik> b52: or you could use guards
13:08:49 <kallisti> b52: so you want parse errors to magically disappear when forming a hand?
13:09:01 <kallisti> that's what catMaybes does.
13:09:44 <kallisti> you could instead use sequence
13:09:52 <kallisti> which will return Nothing if any of the toCards fail.
13:10:00 <kallisti> > sequence [Just 1, Just 2, Just 3, Nothing, Just 4]
13:10:01 <lambdabot>   Nothing
13:10:06 <kallisti> > sequence [Just 1, Just 2, Just 3, Just 4]
13:10:07 <lambdabot>   Just [1,2,3,4]
13:11:10 <vodik> > mapM (\x -> guard (x /= 5) >> return x) [ Just 1, Just 2 ]
13:11:10 <b52> how can i verify the length ?
13:11:11 <lambdabot>   No instance for (GHC.Show.Show (m [Data.Maybe.Maybe t]))
13:11:11 <lambdabot>    arising from a ...
13:11:24 <vodik> > mapM (\x -> guard (x /= 5) >> return x) [ 1, 2 ]
13:11:26 <lambdabot>   No instance for (GHC.Show.Show (m [a]))
13:11:26 <lambdabot>    arising from a use of `M70916074...
13:11:30 <vodik> bah
13:11:35 <b52> side question, how to test if all element in a lit are the same?
13:11:57 <vodik> b52: you mean all elemnts in a list are the same?
13:12:14 <kallisti> b52: guard lets you put conditions in a MonadPlus
13:12:16 <b52> thats exactly what i wrote
13:12:21 <kallisti> > guard (3 > 2) >> Just 2
13:12:22 <lambdabot>   Just 2
13:12:23 <monochrom> all (head xs ==) xs
13:12:26 <kallisti> > guard (2 > 3) >> Just 2
13:12:27 <lambdabot>   Nothing
13:12:46 <kallisti> so the whole thing fails if the guard fails.
13:13:38 <fmap> > and $ zipWith (==) <*> tail $ [1,1,1,1,1]
13:13:39 <lambdabot>   True
13:14:15 * hackagebot contravariant 0.2.0.2 - Haskell 98 contravariant functors  http://hackage.haskell.org/package/contravariant-0.2.0.2 (EdwardKmett)
13:14:17 * hackagebot charset 0.3.1.2 - Fast unicode character sets based on complemented PATRICIA tries  http://hackage.haskell.org/package/charset-0.3.1.2 (EdwardKmett)
13:19:16 * hackagebot groupoids 0.2.1.2 - Haskell 98 Groupoids  http://hackage.haskell.org/package/groupoids-0.2.1.2 (EdwardKmett)
13:20:17 <b52> i got a list of Values, how can i determe if they are consecutive ?
13:20:33 <kallisti> b52: why do they need to be consecutive?
13:20:34 <b52> i probably need to sort them
13:20:36 <kallisti> yes
13:21:01 <kallisti> note that sort xs == xs   won't necessarily compute the entire sort.
13:21:09 <kallisti> if it fails early.
13:21:13 <b52> kallisti: im doing an exercice we did today using c#: compare two poker hands
13:21:25 <kallisti> but yeah you want to sort hands.
13:21:36 <monochrom> what did you do in c# for this then?
13:21:43 <kallisti> or you want to use an unordered data structure such as a set.
13:21:46 <b52> we didnt finish the task :D
13:22:13 <fmap> > and $ zipWith (<) <*> tail $ [1,2,3,4,5]
13:22:14 <lambdabot>   True
13:22:29 <b52>  > and $ zipWith (<) <*> tail $ [1,2,3,4,6]
13:22:36 <b52> > and $ zipWith (<) <*> tail $ [1,2,3,4,6]
13:22:37 <lambdabot>   True
13:22:42 <b52> should be false
13:24:00 <fmap> > and $ zipWith (\a b -> a - b == 1) <*> tail $ [1,2,3,4,5]
13:24:02 <lambdabot>   False
13:24:06 <fmap> oh
13:24:10 <fmap> > and $ zipWith (\a b -> a - b == -1) <*> tail $ [1,2,3,4,5]
13:24:11 <lambdabot>   True
13:24:23 <kallisti> > let ls = sort [3,2,4,1,6] in zipWith (==) ls (iterate (+1) (minimum ls))
13:24:24 <lambdabot>   [True,True,True,True,False]
13:24:26 <kallisti> oh..
13:24:35 <kallisti> > let ls = sort [3,2,4,1,6] in and $ zipWith (==) ls (iterate (+1) (minimum ls))
13:24:36 <lambdabot>   False
13:27:34 <b52> does that only work with integers?
13:29:16 * hackagebot setops 0.1.2 - Uniform names (and Unicode operators) for set operations on data structures.  http://hackage.haskell.org/package/setops-0.1.2 (eelis)
13:29:41 <johnnyfreak> hi all
13:29:41 <fryguybob> vyom_: Does it complain if you add  title :: Diagram SVG R2  ?
13:29:54 <fryguybob> oops :D
13:31:00 <fmap> :t \xs -> and $ zipWith (\a b -> a - b == -1) <*> tail $ xs
13:31:01 <lambdabot> forall b. (Num b) => [b] -> Bool
13:31:07 <johnnyfreak> i'm learning haskell, someone can help me with this problem? i want to have afst access to the nth element of a list and neighbours without recalculating the entire list each time. How can i achieve it?
13:31:07 <applicative> hi johnnyfreak
13:31:26 <monochrom> use an array
13:31:52 <applicative> don't use a list maybe
13:31:58 <johnnyfreak> ok
13:32:01 <johnnyfreak> so arrays
13:32:08 <fmap> b52: You can probably generalize to Enum and Eq
13:32:10 <applicative> what is in the lists, johnnyfreak
13:32:14 <johnnyfreak> can i use them also with over 1 million elements?
13:32:20 <fmap> :t \xs -> and $ zipWith (\a b -> succ a == b) <*> tail $ xs
13:32:22 <lambdabot> forall b. (Enum b, Eq b) => [b] -> Bool
13:32:30 <monochrom> yes
13:32:44 <applicative> what are the elements?
13:32:51 <johnnyfreak> floats
13:32:59 <johnnyfreak> random generated float in a distribution
13:33:04 <johnnyfreak> a give distribution
13:33:06 <applicative> I'm just wondering if they can be unboxed
13:33:06 <johnnyfreak> *given
13:33:10 <applicative> so yes
13:33:14 <Eduard_Munteanu> An unboxed array might do then.
13:33:44 <johnnyfreak> ok, thanks, i'll study and try to use them so
13:33:55 <applicative> what library should he use?
13:34:17 * hackagebot charset 0.3.1.3 - Fast unicode character sets based on complemented PATRICIA tries  http://hackage.haskell.org/package/charset-0.3.1.3 (EdwardKmett)
13:34:42 <johnnyfreak> Data.Array?
13:36:26 <vodik> vectors don't give O(1) lookups, do they?
13:36:50 <Eduard_Munteanu> vodik: what vectors? Like in that vector package? I guess they should.
13:37:14 <vodik> yes, the package
13:37:17 <vodik> *thaT*
13:37:39 <jfischoff> it would be weird if they didn't but I guess it is possible
13:38:04 <applicative> I was wondering about Data.Vector.Unboxed, just because I like it so much but I'm not sure about lookup
13:38:56 <Eduard_Munteanu> http://hackage.haskell.org/packages/archive/vector/0.9.1/doc/html/src/Data-Vector.html#Vector
13:39:28 <applicative> sure enough.
13:39:42 <applicative> johnnyfreak: check out dons ' tutorial http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial
13:40:09 <johnnyfreak> thanks so much
13:40:51 <vodik> Eduard_Munteanu: you're right, my bad. it is O(1)
13:40:58 <applicative> Its often incredibly simple to convert from list code to Data.Vector.Unboxed, there is the menace of qualified imports and V.map and so on of course
13:46:45 <vodik> any resouces on how people handle callbacks with FFI? especially since it seems like its up to me to call freeHaskellFunPtr?
13:47:02 <vodik> im having fun with callbacks
13:52:39 <b52> if i pattenr match (c:cs) how can i bind (c:cs) as whole
13:52:46 <b52> i mean the unmatched value
13:52:52 <vodik> b52: with the @ symbol
13:52:53 <b52> there was some snytax
13:52:57 <vodik> b52: x@(c:cs)
13:53:02 <b52> ah thanks
13:53:04 <vodik> x referse to the whole value
13:53:33 <vodik> technically you could also just use (c:cs) to rebuild the original value again
13:58:22 <ikt> is there a way to write  \x -> setCursor x >> putStr "-"  nicer? I tried to use the  function composition operator (.) but because of the arguments it does not seem to work?
13:58:59 <S11001001> @pl \x -> setCursor x >> putStr "-"
13:59:00 <lambdabot> (>> putStr "-") . setCursor
13:59:21 <ikt> hm thanks
13:59:27 <ikt> do you think it is nicer?
13:59:31 <bitonic> ikt: that's not nicer,
13:59:39 <bitonic> a lambda is much clearer
13:59:44 <ikt> ok
14:00:22 <bitonic> ikt: it's a matter of taste, but I think most people would prefer the pointed version
14:01:53 <mikeplus64> function composition is convenience, so if you're worrying about whether or not to use it, then the answer is that you probably shouldn't
14:02:01 <Powerfoo`> Is there a way in STM (in GHC) to 1) have some control over thread priorities and 2) mapping of threads onto OS threads?
14:03:42 <kcsrk> (2) Mapping threads onto OS threads, boundThreads under Control.Concurrent might be what you are looking for..
14:06:27 <Powerfoo`> kcsrk: sounds like it. However, I'm a bit wary about what the doc says about the performance overhead.
14:10:05 <kcsrk> It is expensive, as you tend to create a OS thread for every bound thread. But why do you want to bind threads of OS threads? there might be a less expensive solution..
14:10:58 <b52> ah damn it, haskell is nais
14:11:09 <b52> to said i dont have to work with it :(
14:11:26 * hackagebot categories 1.0.3 - Categories  http://hackage.haskell.org/package/categories-1.0.3 (EdwardKmett)
14:11:39 <ikt> when I try to print ´  or  ` to the terminal I get a lexical error - do I have to change sth at my windows terminal or within the haskell program?
14:14:38 <tgeeky> ikt: depending on exactly what you're talking about, my preferred choice on windows is to simply use Console2
14:15:20 <Powerfoo`> kcsrk: The idea was to put communicating threads on the same OS thread to avoid context switching. Or is this thought flawed?
14:15:22 <tgeeky> ikt: are you running haskell in cmd.com or command.com?
14:16:04 <ikt> Itgeeky: I type "cmd" in the "execute" window
14:16:18 <lcfrs> I'm working on a Heroku buildpack for Haskell. I've got GHC compiling and cabal installing things. However, I'm having trouble with the absolute paths in GHC's shell-wrapper. Is there a make flag to have them be relative instead?
14:16:43 <ikt> tgeeky (don't know exactyl what you mean)
14:18:49 <ikt> tgeeky: console2 sounds nice, I will check it out
14:19:04 <Powerfoo`> kcsrk: I just found forkOn (GHC.Conc.Sync), which seems to do exactly what I was after.
14:19:18 <Eduard_Munteanu> Powerfoo`: what would that avoid context switching for?
14:22:56 <Powerfoo`> Eduard_Munteanu: I'd think that in this case communication between light-weight threads would stay on the same OS thread.
14:23:32 <kcsrk> Not on the same OS thread but on the same Capability.. But forkOn is a good approximation..
14:24:16 <monochrom> I understand the desire to reduce the cost of interaction between two threads, but being a control freak is not the only way. for example, if you allow only one capability, and you only forkIO, then all threads are already on the same OS thread
14:24:18 <navaati> omg, command.com really still exist oO ?
14:25:33 <monochrom> IMO you really need to see my http://www.vex.net/~trebla/haskell/ghc-conc-ffi.xhtml for how haskell threads map to os threads. with 99% probability all your guesses are wrong.
14:25:38 <tgeeky> navaati: of course
14:25:55 <Powerfoo`> monochrom: That's true. However, how about an application where you have some "important" threads that communicate with each other and whose performance is critical, and some less important threads such as a logger. Hence my question about thread-scheduling prioritization.
14:26:23 <Powerfoo`> monochrom: Thanks for the link, I'll have a look.
14:26:33 <navaati> damn… *that* is backward-compatibility…
14:29:29 <hayashi> @pl \f x = f (bar x)
14:29:29 <lambdabot> (line 1, column 6):
14:29:30 <lambdabot> unexpected "="
14:29:30 <lambdabot> expecting pattern or "->"
14:29:35 <hayashi> nyeh
14:29:39 <hayashi> @pl \f x -> f (bar x)
14:29:39 <lambdabot> (. bar)
14:29:42 <hayashi> yeah, thought so.
14:32:55 <Alan> @pl \f x y -> f (bar x) (bar y)
14:32:56 <lambdabot> flip flip bar . ((.) .) . (. bar)
14:33:14 <Alan> ... i think i'll stick with the verbose version.....
14:33:53 <hayashi> @pl \a b c d e f g h i j -> a (f g) (h (i j)) (c b)
14:33:55 <lambdabot> (((const . const) .) .) . (. flip id) . (.) . flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .) . flip flip (.) . ((flip . (((.) . (.) . (.)) .)) .) . (.)
14:34:16 <Alan> ...
14:34:21 <geekosaur> pl is flipping people the dot again
14:34:30 <Bytter> does anyone know if there is a virtual appliance, or a suitable distribution with agda2 pre-installed?
14:34:46 <S11001001> alan: manually, f (bar x) (bar y) is f `on` bar
14:34:46 <Bytter> i'm loosing my patient here trying to get it to install on my machine
14:35:08 <bitonic_> Bytter: no, I don't think there is. what problems are you having?
14:35:16 <bitonic_> btw, there's #agda as well
14:35:46 <Alan> S11001001: "manually"?
14:35:47 <zzo38> Is there any bijective map type?
14:35:58 <S11001001> Alan: like, not using @pl
14:36:04 <Alan> S11001001: ah, i see
14:36:06 <Alan> hoogling it now
14:36:35 <Alan> :t on
14:36:36 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
14:36:43 <Alan> damn, that's not actually general enough
14:36:59 <S11001001> or it is too general :)
14:37:00 <Alan> unless i'm missing something
14:37:25 <rwbarton> :t \bar f x y -> f (bar x) (bar y)
14:37:26 <lambdabot> forall t t1 t2. (t -> t1) -> (t1 -> t1 -> t2) -> t -> t -> t2
14:38:22 <Ayvee> Oracle is suing Google for using "symbolic references" in Android.  It's beyond sad.
14:38:27 <Alan> well in my case, x and y are the same type, but f is (a -> b -> c)
14:38:52 <jfischoff> zzo38: do mean something for storing a function and its inverse?
14:39:11 <S11001001> Alan: you need rank 2 for that
14:39:27 <Alan> S11001001: hmm?
14:40:17 <monochrom> http://hackage.haskell.org/package/bimap may be a bijective map type
14:40:44 <Alan> well i think at this point i'm just going to make the code incomprehensible if i managed to succeed in these schemes anyway...
14:41:01 <S11001001> Alan: you need your 2nd arg to `on` to have different types, right?
14:42:04 <Alan> S11001001: i think so
14:42:14 <Alan> > decodeArity2 n i c = let (a, b) = splitChunkAt n c
14:42:15 <Alan> >                      in  i (decode a) (decode b)
14:42:15 <lambdabot>   <no location info>: parse error on input `='
14:42:15 <lambdabot>   can't find file: L.hs
14:42:28 <Alan> that's what i'm currently trying to refactor :P
14:42:38 <Alan> oh, i missed the type !
14:42:51 <Alan> decodeArity2 :: (Encodable a, Encodable b) => Int -> (a -> b -> Instruction) -> Chunk -> Instruction
14:43:03 <Alan> Encodable is what defines decode
14:44:16 <zzo38> jfischoff: No, I mean like Map except that the values are keys too
14:44:58 <jfischoff> zzo38: ah, hopefully you saw monochrom's link
14:45:36 <zzo38> jfischoff: Yes
14:46:58 <zzo38> But I don't like them using return and fail for the lookup functions; they should be pure and empty
14:47:41 <zzo38> Other than that it is good
14:47:46 <monochrom> Data.Map used to do that. that's why. so bimap is just being old
14:48:42 <monochrom> it was also a time when people were very excited about monad.
14:49:30 <Alan> @pl \x y -> let (a, b) = foo y in bar (baz x a) b
14:49:30 <lambdabot> (line 1, column 13):
14:49:30 <lambdabot> unexpected "("
14:49:30 <lambdabot> expecting "()", natural, identifier or "in"
14:49:45 <Alan> bah
14:49:50 <zzo38> Data.Map just uses Maybe always. It should still be specialized to Maybe whether or not the function is generalized
14:50:16 <monochrom> no no no
14:51:04 <Alan> @pl \(x, y) -> foo (bar x) y
14:51:04 <lambdabot> uncurry (foo . bar)
14:51:55 <zzo38> You can see this one I have made many generalized:   http://hackage.haskell.org/packages/archive/prelude-generalize/0.2/doc/html/Prelude-Generalize.html
14:52:49 <monochrom> http://www.haskell.org/ghc/docs/6.8.1/html/libraries/containers-0.1.0.0/Data-Map.html#v%3Alookup
14:53:19 <bitonic> zzo38: ahahaha all the functions in MonadLogic
14:53:27 <bitonic> drop :: (Copeanoid i, MonadLogic m) => i -> m x -> m x
14:53:29 <bitonic> this is amazing
14:53:36 <zzo38> bitonic: Not all of them, but many are
14:53:37 <Alan> yes
14:53:37 <monochrom> (thank God the historical evidence is still there, lest you would think I was crazy)
14:53:38 <Alan> that worked :D
14:53:40 <adnauseam> what's the difference between Num and Integram ?
14:53:50 <adnauseam> Integral*
14:53:59 <bitonic> @info Num
14:53:59 <lambdabot> Num
14:54:03 <bitonic> @src Num
14:54:04 <lambdabot> class  (Eq a, Show a) => Num a  where
14:54:04 <lambdabot>     (+), (-), (*)           :: a -> a -> a
14:54:04 <lambdabot>     negate, abs, signum     :: a -> a
14:54:04 <lambdabot>     fromInteger             :: Integer -> a
14:54:07 <bitonic> @src Integral
14:54:08 <lambdabot> class  (Real a, Enum a) => Integral a  where
14:54:08 <lambdabot>     quot, rem, div, mod :: a -> a -> a
14:54:08 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
14:54:09 <zzo38> But I have accidentally forgot to export the Function class from this module
14:54:10 <lambdabot>     toInteger           :: a -> Integer
14:54:31 <adnauseam> oh thank you
14:54:37 <zzo38> Which, I guess, mean you cannot create new instances
14:55:56 <bitonic> zzo38: what's with all the braces and semicolon?
14:56:57 <bitonic> zzo38: http://hackage.haskell.org/packages/archive/prelude-generalize/0.2/doc/html/src/Prelude-Generalize.html#drop this looks automatically generated
14:57:16 <zzo38> bitonic: I always turn off the layout parser and use my own layout, this is just I prefer this way. Other modules that use it are not required to use semicolons
14:57:30 <zzo38> bitonic: Well, it is not automatically generated. I wrote all of the codes by myself.
14:57:46 <bitonic> zzo38: why would you import/export like that? it's impossible to read
14:58:29 <monochrom> oh, you're the Peanoid guy, I remember now
14:58:30 <zzo38> Why do you think it is automatic?
14:59:00 <bitonic> zzo38: because I wouldn't think that a human could do that :P no offense eh
14:59:20 <bitonic> I mean if you like it that, I just find it hard to read.
14:59:56 <zzo38> drop = flip church (msplit >=> maybe mzero snd);
15:00:06 <aristid> bitonic: what lambdabot says about Num isn't accurate anymore :P
15:00:13 <bitonic> aristid: ah, true.
15:00:28 <zzo38> I think it is relatively easy and certainly does not look like an automatic program!!
15:00:58 <bitonic> zzo38: the no-line-breaks imports are not easy to follow
15:01:23 <bitonic> also, I'd import things qualified instead of importing hiding almost everything
15:01:42 <zzo38> OK
15:01:47 <bitonic> I'd also define `data Peano = Zero | Succ Peano', but that's another story :P
15:02:08 <zzo38> Probably you are right about that too
15:02:38 <bitonic> also, is Copeanoid really the dual of Peanoid? It doesn't look like it
15:03:27 <zzo38> bitonic: It is not really the dual.
15:03:46 <adnauseam> why doesn't 5 `(+)` 10 work? (+) 5 10 works :|
15:03:54 <bitonic> adnauseam: you can't do that
15:04:14 <zzo38> It is sort of like dual, like Foldable can be translated to a Alternative
15:04:58 <Bytter> does a cofunctor works with abritrary functions, or just a strict known subset?
15:06:11 <adnauseam> bitonic: why
15:06:17 <adnauseam> because of the () ?
15:06:26 <adnauseam> are they parsed differently?>
15:06:41 <zzo38> For example you can see that many of my functions will take some Foldable as input and some Alternative as output
15:06:44 <monochrom> no reason
15:07:31 <vodik> adnauseam: because it expects an identifier and ( and ) aren't valid characters for that
15:08:09 <adnauseam> well it should :[ but nvm =]
15:10:01 <monochrom> asking "why" on most syntactic restrictions is in itself illogical to begin with. do you expect that the language design was crafted by human subjective judgement or calculated by objective machine rules?
15:10:24 <vodik> adnauseam: (`sutract`) is also invalid, but understandibly so, so i image ` and ( are handled simiarliy
15:10:27 <adnauseam> i was trying to explain infix notation to a friend
15:10:40 <adnauseam> and was embaressed by (+) because i thought it'd work
15:11:05 <adnauseam> but now i understand
15:11:09 <adnauseam> im learning myself
15:11:10 <adnauseam> ;
15:11:10 <adnauseam> ;p
15:11:28 <monochrom> you are welcome to lament. and I thought your "why" was just lamenting at first. but then you pressed the question harder
15:11:45 <adnauseam> my apologies ;p
15:11:51 <adnauseam> *offers cookies and virgins*
15:15:15 <Solaris> What is Haskell?
15:15:31 <monochrom> a programming language
15:15:39 <zzo38> Solaris: It is the name of a programming language
15:15:56 <EvanR> the answer to a question on jeopardy
15:16:11 <Solaris> what do you program?
15:16:25 <monochrom> other humans
15:16:38 <monochrom> actually, delete "other"
15:16:51 <Eduard_Munteanu> Heh.
15:17:07 <zzo38> Solaris: Wikipedia probably has some information about Haskell programming language too.
15:17:25 <parcs`> monochrom: are you implying that you program yourself or that you're not human
15:17:51 <monochrom> you may enjoy investigating some of the web pages listed in the topic line
15:18:17 <monochrom> parcs`, I am not sure :)
15:18:33 <monochrom> a bit of both
15:18:49 <albel727> hmm, where did the metawiki go...
15:19:08 <Eduard_Munteanu> I thought it was all black and white for you. :P
15:19:15 * monochrom follows the law of excluded "you must choose one and prove it"
15:19:16 <Solaris> What cool stuff can you do in Haskell that you can't do in C++ for instance?
15:19:48 <donri> Solaris: have programs work correctly once they compile :)
15:20:05 <Eduard_Munteanu> http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/    -- but this certainly isn't an easy read if you're just starting out ;)
15:20:33 <ski> Solaris: it's harder to work with infinite data structures in C++
15:20:43 <bitonic> adnauseam: then why can't you do (`foo`) x y?
15:20:44 <Solaris> "infinite data structures"
15:20:46 <monochrom> my google+ avatar is roughly speaking 256 shades of grey! https://plus.google.com/102208456519922110915/posts
15:20:52 <Solaris> Like an array without limits?
15:20:52 <ski> > [0 ..]
15:20:53 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
15:20:58 <zzo38> Solaris: Use mathematical abstractions, use infinite data structures, represent I/O as an object, etc
15:21:09 <Eduard_Munteanu> And "you can't do" is a bit of an overstatment, it's more like a matter of language expressivity.
15:21:23 <zzo38> Solaris: It is a list, which is different from a C array
15:21:24 <Solaris> Give me an example of an application for windows that is programmed in Haskell
15:21:26 <ski> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs  -- list of all fibonacci numbers
15:21:27 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:21:33 * hackagebot speculation 1.4.1.1 - A framework for safe, programmable, speculative parallelism  http://hackage.haskell.org/package/speculation-1.4.1.1 (EdwardKmett)
15:21:43 <bitonic> Solaris: ghc, darcs
15:22:16 <Eduard_Munteanu> pandoc too maybe
15:22:31 <monochrom> yeah pandoc is of more general interest
15:23:18 <chris2> whats the recommended way to fold over an STArray?
15:23:29 <EvilMachine> ski: in a way, you could call any function in any language a infinite data structure (with one or multiple index parameters).^^
15:23:38 <Solaris> What's so special about darcs? What does it do exactly?
15:23:55 <Eduard_Munteanu> Solaris: do you know 'git'?
15:24:04 <bitonic> Solaris: it's a very neat distributed version control system
15:24:05 <ski> EvilMachine: yes, though it's usually not memoed
15:24:20 <bitonic> Solaris: one of the first of its kind and still the one with the best high-level concepts - imo
15:24:23 <Eduard_Munteanu> Or something a bit more different... SVN, CVS etc.?
15:24:41 <Solaris> Control system? Like I can control my heating system from over hte internet so I can have a hot bath when I get home?
15:24:53 <Eduard_Munteanu> No.
15:24:58 <monochrom> STArray probably doesn't come with a fold, but vector does, if you don't mind switching to vector. http://hackage.haskell.org/package/vector
15:25:00 <EvilMachine> Eduard_Munteanu: so darcs is like git? Also fully distributed, able to octopus merge, and all the nice stuff git is known for? that would be cool.
15:25:09 <zzo38> But, a list in Haskell, consists of: either an empty list, or a pair consisting of a value and another list of the same type.
15:25:13 <Eduard_Munteanu> Solaris: source code management
15:25:37 <jfischoff> Solaris: Once you program in Haskell it is hard to go back to other languages http://lukeplant.me.uk/blog/posts/why-learning-haskell-python-makes-you-a-worse-programmer/
15:25:38 <bitonic> EvilMachine: it's actually more powerful than git in terms of branching/merging: http://www.youtube.com/watch?feature=player_embedded&v=iOGmwA5yBn0
15:25:57 <Solaris> So you wrote code that handles code?
15:26:08 <bitonic> EvilMachine: the same applies to darcs
15:26:10 <Eduard_Munteanu> EvilMachine: heh. I'm not sure how fully-distributed darcs is though, now that you mentioned it :/
15:26:25 <monochrom> sorry, vector's mutable version probably doesn't come with a fold either. but it's possible to temporarily cast a mutable vector to an immutable, which has several folds
15:26:29 <EvilMachine> jfischoff: i found, that haskell brought me to a whole new level in coding in all languages. now i can even code elegantly in abominations like PHP.
15:26:40 <zzo38> I can easily program in many programming languages; C, AWK, Haskell, Forth, ...
15:26:52 <EvilMachine> bitonic: woah, if dacrs was a woman, i would have a boner now.
15:27:19 <zzo38> EvilMachine: To me too, you can stil program in more programming languages
15:27:33 <bitonic> EvilMachine: :)
15:28:19 <jfischoff> EvilMachine: its made me a better programmer, although my functional inspired PHP code was probably not a huge win
15:28:29 <monochrom> hehe
15:28:31 <Solaris> What has darcs and haskell made that's actually any good for anything other than jsut more programming? I mean I used C code to make a sky-dish follow the sun and I didn't use anything fancy, just 4 sensors and 2 motors really
15:29:01 <EvilMachine> now i’m at a level, that i could teach anyone all programming languages at *once*. After it, all the person would need, is a table of the concrete code elements to use in that language.
15:29:12 <zzo38> Solaris: Sensors? Motors? But that is a feature of the hardware!
15:29:15 <Solaris> Forgive my 20th century quaintness, but what practical use is this wonderful language? My imagination is not so good
15:29:22 <tgeeky> zzo38: don't feed
15:29:25 <Solaris> I was doing this on an arduino with 32kb memory
15:29:30 <Solaris> 16mhz atmega
15:29:38 <tgeeky> monochrom: ... ?
15:29:45 <Solaris> I know mono
15:29:51 <EvilMachine> jfischoff: lol. In the most recent JavaScript versions, functional programming works surprisingly well. Which makes me like it more and more.
15:29:54 <zzo38> Solaris: Well, if you don't like it them don't use them. But you should learn first before deciding if you like or don't like it. Wikipedia has some information too
15:29:59 <Nimatek> Solaris: How's the 70's grandpa?
15:30:20 <Solaris> Don't remember it, I can tell you about the 80's though
15:30:24 <Solaris> I had a BBC micro in them days
15:30:24 <Eduard_Munteanu> There's also some theoretical interest to it.
15:30:29 <Solaris> And floppies were actually floppy
15:30:38 <jfischoff> EvilMachine: no doubt. Have you used this http://osteele.com/sources/javascript/functional/
15:30:44 <monochrom> tgeeky: ?
15:30:45 <zzo38> EvilMachine: That is true especially Mozilla JavaScript can do many of these things
15:30:59 <EvilMachine> Solaris: the point of haskell is *generic concepts*. like how you can apply very abstract concepts to a billion of cases. something you could neither see nor implement in C.
15:31:07 <EvilMachine> Solaris: like the fold function.
15:31:17 <EvilMachine> Solaris: or monads
15:31:24 <Solaris> Fold function?
15:31:33 <Solaris> Monads?
15:31:35 <ski> or being able to refactor more aggressively
15:31:38 <rwbarton> there are people who use Haskell to program on the Arduino
15:31:46 <Solaris> Do they?
15:32:05 <EvilMachine> Solaris: let’s raise the glasses to 7 inch floppies with 120kB on them! :)
15:32:14 <jfischoff> rwbarton: killer. do you have a link?
15:32:38 <rwbarton> for example http://leepike.wordpress.com/2010/05/31/twinkle-twinkle-little-haskell/ and also the post linked to in the first sentence of the main text
15:32:41 <rwbarton> using Atom
15:32:54 <EvilMachine> Solaris: the fold function is like the generic solution to all loops. everything you could do with a while, for, or anything like that. it’s always surprising how much can be replaced by a simple fold.
15:32:59 <ski> (EvilMachine : 8.5 ?)
15:33:08 <monochrom> them floppies: https://plus.google.com/u/0/102208456519922110915/posts/6yqnZ3XoP7K
15:33:25 <EvilMachine> Solaris: you can think of monads as a cool way to redefine, what the semicolon between two statements actually does.
15:33:27 <Solaris> So its basically a fancy Goto line 15, got it
15:33:42 <Eduard_Munteanu> No.
15:33:50 <EvilMachine> Solaris: that e.g. allows you to do aspect oriented programming very nicely
15:34:03 <EvilMachine> Eduard_Munteanu: yes, i was simplifying a lot. :)
15:34:14 <ski> > foldr (+) 0 [10,20,30,40] :: Expr
15:34:15 <lambdabot>   10 + (20 + (30 + (40 + 0)))
15:34:30 <EvilMachine> Solaris: if Goto is the lowest low level way of doing loops, folding is the highest high level way.
15:34:32 <monochrom> People, do not fall for such provocative tactics as "So its basically a fancy Goto line 15, got it". Just drop it.
15:34:38 <zzo38> Solaris: OK I will explain to you. What it means is that, data and action are treated as the same kinds of things in Haskell; that is the job!!
15:34:45 <Eduard_Munteanu> It's also one way to separate side-effects like IO and keep the language pure.
15:35:01 <tgeeky> monochrom: I figured you were an op and was wondering about the trolling status of Solaris?
15:35:13 * tgeeky forgets the command to list ops
15:35:21 <EvilMachine> monochrom: honestly, i don’t think he’s trolling. he’s just thinking in the way that he knows. there’s no shame in that. we were once like that too.
15:35:34 <zachk> Solaris: write an X server in 1k loc
15:35:45 <zachk> er manager
15:35:49 <monochrom> I am not saying trolling. I am saying provocative tactics.
15:35:51 <Eduard_Munteanu> Solaris: just out of curiosity, how did you stumble upon #haskell?
15:35:57 <Eduard_Munteanu> (the IRC channel I mean)
15:36:27 <EvilMachine> monochrom: also, this: http://xkcd.com/1053/
15:36:29 <EvilMachine> :)
15:36:30 <Solaris> I started learnign programming by 10 "hello world" 20 /nWould you like to play a game y/n?" 30 getchar(a) 40if getchar ==y goto line 70 50 if getchar==n "goodbye" 60 else goto line 30
15:36:34 * hackagebot tagged 0.4.2.1 - Haskell 98 phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-0.4.2.1 (EdwardKmett)
15:36:38 * ski did too
15:36:48 <EvilMachine> ski: 8.5? hmm, i guess you are right…
15:37:00 <Solaris> But the langauge has all changed, its just alienated me
15:37:00 <zzo38> Solaris: In what programming language is that?
15:37:06 <Solaris> I can hack Counterstrike in assembly piece of piss
15:37:13 <Solaris> These newfangled high level languages are martian to me
15:37:13 <EvilMachine> monochrom: lol.
15:37:24 <mauke> Solaris: what languages do you know?
15:37:41 <zzo38> You are not required to use them if you dislike them; but at least it may be good idea to consider it at once
15:37:46 <Solaris> 0x0004F9E9  noflash
15:37:46 <Solaris> 0x04F8840F existing
15:38:01 <EvilMachine> Solaris: I started on GWBasic on a Commodore PC 10. It did physically hurt. ^^
15:38:19 <Solaris> Search readonly memory on counterstrike in Cheatengine, find the 2nd value down, always the 2nd value it finds change it it to 0x0004F9E9 I know this because its a Jump equals
15:38:21 <Solaris> I understand assembly
15:38:25 <Solaris> I'm not stupid
15:38:28 <EvilMachine> Solaris: do you like math?
15:38:29 <vraid> Solaris: newfangled? try some lisp then
15:38:29 <Solaris> I'm jsut old fashioned
15:38:31 <Solaris> Sure
15:38:39 <vraid> older than C
15:38:47 <EvilMachine> Solaris: because haskell comes very natural, if you just think of it as “computer math”
15:38:49 <Eduard_Munteanu> Great, then you should enjoy the fancy math behind Haskell :P
15:38:53 <mauke> Solaris: what languages do you know?
15:39:07 <EvilMachine> Solaris: the analogies go very far. you can often literally write down math in haskell, and run it.
15:39:19 <zzo38> Another programming language to consider learning is Forth, too. Is good idea many programming languages learning
15:39:25 <EvilMachine> Solaris: i respect that. :)
15:39:26 <Solaris> 16 and 32 bit assembly, C, C++, VB, Delphi
15:39:30 <Solaris> Old stuff
15:39:46 <EvilMachine> Solaris: aah, Delphi! Great times. :D
15:39:47 <mauke> aah, both kinds
15:39:48 <Solaris> And Basic
15:39:51 <mauke> 16 *and* 32 bits
15:39:52 <lispy> Go learn how ld-linux.so works :)
15:39:53 <Philippa> y'know what? Let's teach Solaris some CPS
15:40:17 <Philippa> Solaris: do you know what a tail call is?
15:40:20 <Eduard_Munteanu> Haskell is basically an extension of Miranda down at its core, which is an 80s language as well :)
15:40:28 <Solaris> tail call? nope
15:40:42 <Philippa> okay. It's a function call that's in "tail position" - the last thing a function does
15:40:57 <EvilMachine> Solaris: if we were a bit condescending in here, i’m sorry for that. (i know i can be like that sometimes.) i hope it doesn’t prevent you from enjoying Haskell. :)
15:41:09 <Solaris> Like in C where you got  return(null); }
15:41:18 <mauke> Solaris: you don't have that in C
15:41:26 <Philippa> unlike ordinary calls, you can compile them by throwing away the current activation record (that's "stack frame" to you, but we sometimes litter them about the heap) and building a new one in its place before jumping to what you tail called
15:41:27 <mauke> Solaris: and that's not a function call
15:41:33 <Philippa> so a tail call is like a goto with parameters
15:41:34 * hackagebot order-statistics 0.1.0.2 - L-Estimators for robust statistics  http://hackage.haskell.org/package/order-statistics-0.1.0.2 (EdwardKmett)
15:41:36 <Philippa> that make sense?
15:41:37 <Solaris> Return(0) } ;
15:41:45 <mauke> what the heck
15:41:50 <Philippa> (anyone about to say that you don't want to think about the stack like that in Haskell, don't)
15:42:15 <EvilMachine> Philippa: seconded
15:42:17 <zzo38> Like   return more_function(x); }
15:42:19 <Philippa> Solaris: "return" is always a tail call, yeah. But it tail calls something you don't hold onto explicitly - the function that called /you/
15:42:21 <acowley> What's the current hotness for avoiding runtime newtype wrapping/unwrapping traversals?
15:42:21 <lambdabot> acowley: You have 1 new message. '/msg lambdabot @messages' to read it.
15:42:45 <adnauseam> how do i define a tripple with let ?
15:42:50 <Philippa> but you don't have to jump there, you could jump somewhere else. Just like you could in machine code
15:42:52 <Solaris> Right so your language intuitively creates an array, copies all the entries of your existing array into the new array and you don't have to have a thousand functions to tell it to do this them malloc and clear mem etc
15:42:55 <monochrom> wait, newtype wrapping/unwrapping does not exist in run time
15:42:59 <Eduard_Munteanu> acowley: hmm, runtime and newtype don't really mix in the same sentence :/. What do you mean?
15:43:00 <Solaris> So your language does that all for you right?
15:43:07 <adnauseam> doing let (,,) :: a->b->c-> (a,b,c) didn't work
15:43:08 <lispy> > let (a,b,c) = (1,'a',2) in (a,b,c)
15:43:09 <lambdabot>   (1,'a',2)
15:43:13 <mauke> Solaris: what does that have to do with tail calls?
15:43:18 <EvilMachine> adnauseam: t1 = (1,2,3) -- ← that’s a triple, no?
15:43:22 <EvilMachine> adnauseam: let t1 = (1,2,3) -- ← that’s a triple, no?
15:43:30 <zzo38> adnauseam: Well, the function (,,) already exists and does that
15:43:32 <acowley> Eduard_Munteanu: If I have newtype T  = T …, and I have a line of code that says fmap T x
15:43:34 <adnauseam> EvilMachine: i'm trying to define (,,)
15:43:40 <Philippa> folks, can I take this one?
15:43:43 <mauke> adnauseam: you can't
15:43:45 <adnauseam> zzo38: i'm trying to show a friend
15:43:48 <Philippa> it's easier if I handle anything that makes me WTF my own way :-)
15:43:50 <adnauseam> mauke: oh alright
15:44:05 <acowley> Eduard_Munteanu: I think that fmap will still lead to a traversal, even though it's not changing the representation
15:44:14 <Philippa> Solaris: arrays? But Haskell doesn't make us deal with memory allocation directly, no
15:44:17 <Eduard_Munteanu> Oh, hm.
15:44:19 <zzo38> You can't because it is build-in (a feature I don't like much; I would like to define everything inside the programming language itself, using macros and other features)
15:44:32 <EvilMachine> adnauseam: i noticed. sorry, i misunderstood.
15:44:38 <Solaris> So how do you free up memory after you're done with that amount?
15:44:45 <acowley> I think I can do a rewrite rule that just does unsafeCoerce
15:44:53 <Philippa> Most Haskell implementations use a garbage collector
15:45:04 <Solaris> Otherwise your memory will get full of thousands of "timestamps" of the same array + or - a few values
15:45:18 <Eduard_Munteanu> acowley: are you sure about that? I'd think stuff like 'fmap id' could be optimized away. That can be benchmarked too, I guess.
15:45:22 <Philippa> Okay, you're asking about how we emulate mutability?
15:45:30 <Philippa> (Which, yes, isn't unrelated to tail calls in practice)
15:45:40 <Philippa> (but wasn't why I was trying to talk about them)
15:45:58 <mauke> basically, any non-C language doesn't require manual memory management
15:46:15 <mauke> regardless of mutability
15:46:15 <Eduard_Munteanu> Yeah, think Java or other stuff.
15:46:16 <acowley> Eduard_Munteanu: if fmap id is optimized away it is almost certainly a special case. I'm not really sure how a more general optimization for newtype wrapping would work tbh.
15:46:16 <Philippa> mauke: Solaris has been programming long enough to have met a lot of non-C languages that don't require it
15:46:30 <EvilMachine> Solaris: haskell uses a garbage collector.but it’s not a wasteful/inefficient as traditional ones. thank to how haskell works, as far as i know, it’s much easier to detect what to throw away.
15:46:35 <Philippa> I know what you /mean/ by non-C, but
15:46:38 <EvilMachine> (although i can’t say i know this well)
15:46:40 <Eduard_Munteanu> acowley: T is basically id up to erasure
15:46:53 <acowley> Eduard_Munteanu: Yes, but rewrite rules are syntactic
15:46:56 <mauke> Philippa: I think I mean C, C++ and Pascal :-)
15:47:17 <Eduard_Munteanu> acowley: yeah, I don't mean it could be optimized through fusion.
15:47:19 <monochrom> how dare you include my favourite Pascal there!
15:47:22 <Philippa> mauke: then my comment stands
15:47:49 <Solaris> Do you still have pointers to pointers?
15:47:55 <cinema> \seen dons
15:48:02 <ski> preflex: xseen dons
15:48:02 <preflex>  dons was last seen on freenode/#haskell 4 days, 7 hours, 13 minutes and 31 seconds ago, saying: just pay attention to the Foreign.* libraries
15:48:03 <EvilMachine> Solaris: can I recommend http://book.realworldhaskell.org/read/ ? The “real world” might appeal to you. (As it did to me. :)
15:48:37 <cinema> ski, thanks
15:48:43 <Eduard_Munteanu> Solaris: generally you don't use pointers, but yeah, you can get something similar
15:49:09 <Philippa> Solaris: Haskell doesn't need to know about pointers at all most of the time. The FFI will let you do pointers to anything including other pointers though, yes. You can program with all the stars you like
15:50:07 <Philippa> Solaris: I was trying to explain something fairly significant through explaining Continuation Passing Style to you by the way - I'm still not clear if you understand that as opposed to knowing how to emulate C with it
15:50:49 <EvilMachine> Philippa: giving him a link to a good website where somebody thought a lot about how to explain it may help. :)
15:50:50 * ski . o O ( `gcc -fsibling-calls ...' )
15:50:51 <Philippa> but I could certainly define a reasonable single-threaded functional language that's meaningfully lower level than C
15:51:23 <Philippa> EvilMachine: you say that like I /haven't/ thought about how to explain CPS to particular audiences
15:51:37 <Solaris> So you can pass any data type between functions and it isn't fussy about "oh no, this is a long you're feeding me, I only accept floats" bugger, make a new value called float x and convert long y to float x
15:51:45 <Solaris> Is that what you're saying?
15:51:51 <Philippa> nobody said that, because it isn't true
15:52:03 <Philippa> Haskell's type system will force you to do any actual conversions yourself
15:52:21 <ski> > (1 :: Int) + (3.4 :: Float)
15:52:22 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
15:52:22 <lambdabot>         against inferred type ...
15:52:33 <ski> > fromIntegral(1 :: Int) + (3.4 :: Float)
15:52:34 <Solaris> What does "Continuation Passing Style" mean then?
15:52:34 <lambdabot>   4.4
15:52:51 <ski> Solaris : you know assembler, yes ?
15:53:02 <Philippa> Solaris: This'll take a little while. Did you understand what a tail call is, and how it relates to jumps?
15:53:13 <Solaris> I'm better with DISassembler and rewriting existing code and I have Assembled pic chips sure
15:53:31 <Solaris> I only get involved with assembly now for hacks
15:53:46 <Solaris> Always will be the most powerful
15:53:59 <ski> Solaris : assume you have a routine `foo' ending in `jsr bar' followed by `rts' -- then you can replace those two last instructions by a `jmp bar'
15:54:13 <Solaris> right
15:54:17 <mauke> what's a jsr?
15:54:24 <ski> this is tail-call optimization
15:54:39 <zzo38> mauke: jump to sub routine
15:54:44 <Solaris> Jump to subroutine
15:55:09 <LnL> Can anyone explain why this skips the first el `[ i : is | i : is <- ["", "b"] ]`
15:55:20 <ski> whoever called `foo' (say `mumble') has a return address on the stack that `foo' will return to -- now we just forward that to `bar' so that `bar' returns directly back to `mumble', instead of first getting back to `foo'
15:55:29 <rwbarton> LnL, because "" doesn't match i : is
15:55:34 <monochrom> because "" does not match the pattern i:is
15:55:46 <EvilMachine> Philippa: sorry, I didn’t mean it so sound like that. :)
15:55:56 <monochrom> yes, list comprehension skips things that fail the pattern
15:56:19 <monochrom> > [ n | 0@n <- [1, 0, 2] ]
15:56:20 <lambdabot>   <no location info>: parse error on input `@'
15:56:25 <tac-tics> LnL: It's bad form to use patterns that can fail in a list comprehension
15:56:30 <monochrom> > [ n | n@0 <- [1, 0, 2] ]
15:56:31 <lambdabot>   [0]
15:56:32 <rwbarton> no it's not!
15:56:34 <ski> Solaris : this means that when we write recursion, if the recursive call is the *last* call in the function, it will effectively be a jump -- so this means we can do iteration through recursion
15:56:35 <mauke> tac-tics: what
15:57:00 <monochrom> there is no calling fail in a list comprehension. fail is for Monad
15:57:17 <Solaris> This language sounds highly algorithmic to me
15:57:18 <monochrom> list comprehension doesn't actually use Monad code
15:57:22 <ski> > let loop [] acc = acc; loop (n:ns) acc = loop ns (acc+n) in loop [1,2,3,4] 0  -- this sums a list, using tail-recursion
15:57:23 <lambdabot>   10
15:57:55 <EvilMachine> #haskell… the only channel, where I can happily say I’m sorry or wrong, because people are just so nice. :)
15:58:02 <Philippa> Solaris: it's good at algorithmic things, yes
15:58:30 <Solaris> So i can do runge kutta piece of piss then
15:58:40 <Eduard_Munteanu> @undo [ n | n@0 <- [1, 0, 2] ]
15:58:41 <lambdabot> concatMap (\ a -> case a of { n@0 -> [n]; _ -> []}) [1, 0, 2]
15:58:45 <Philippa> but arguably it's not algorithmic at all: we don't have a fully-specified order of evaluation for function parameters, even
15:59:02 <ski> Solaris : this is comparable to `for (acc = 0, node = list; node != NULL; node = node.next) { acc += node.data; }'
15:59:03 <Philippa> but yes, RK'd be easy
15:59:18 <acowley> I think Solaris just came up with a new slogan for haskell
15:59:25 <EvilMachine> Solaris: either my english reading ability is broken, or… I just have no idea what that meant… ^^
15:59:30 <Solaris> whoa there, you didn't define what node.data means
15:59:31 <rwbarton> @faq Can Haskell do runge kutta piece of piss?
15:59:32 <lambdabot> The answer is: Yes! Haskell can do that.
15:59:32 <monochrom> (algorithmic doesn't require that fully-specified order either)
15:59:36 <Philippa> "piece of piss" = easy
15:59:44 <Solaris> yeah
15:59:50 <Eduard_Munteanu> ...
15:59:55 <Eduard_Munteanu> What part of UK is that? :P
16:00:01 <Philippa> Solaris: turns out most people here don't know what taking the piss is, either
16:00:07 <Philippa> Eduard_Munteanu: national
16:00:10 <monochrom> (algorithmic and mutable cells, now that does require a known order)
16:00:15 <Eiam> @faq can haskell replace javascript in the browser?
16:00:15 <lambdabot> The answer is: Yes! Haskell can do that.
16:00:21 <ski> Solaris : this is assuming something like `typedef struct _node { int data; struct _node *next; } node;'
16:00:30 <Eiam> lambdabot: think I caught you in a lie.
16:00:51 <EvilMachine> Philippa: what is a "runge" ? and a "kutta"? ^^
16:00:54 <acowley> I just think it's a funny way of describing the expressivity of Haskell.
16:01:00 <ski> @google runge kutta
16:01:02 <lambdabot> http://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods
16:01:02 <lambdabot> Title: Runge–Kutta methods - Wikipedia, the free encyclopedia
16:01:05 <EvilMachine> Eiam: lambdabot promised cake?
16:01:25 <Philippa> acowley: haskell makes most things a piece of piss once you know how they work though
16:01:34 <Philippa> (which makes the ones that aren't even more infuriating)
16:01:35 <Solaris> ski that function you said sounds a lot like SQL
16:01:37 <acowley> Didn't someone write a web browser in Haskell not that long ago?
16:01:49 <ski> Solaris : ok. why do you say that ?
16:02:08 <EvilMachine> @faq can haskell *
16:02:08 <lambdabot> The answer is: Yes! Haskell can do that.
16:02:11 <Eduard_Munteanu> Probably the keywords like 'in'?
16:02:16 <Philippa> Solaris: there's an interesting relation[ship] between the two languages' styles, yes
16:02:16 <Eduard_Munteanu> I wouldn't focus on those.
16:02:28 <EvilMachine> @faq can haskell not do anything.
16:02:29 <lambdabot> The answer is: Yes! Haskell can do that.
16:02:32 <Philippa> not just that: Haskell's style is also declarative
16:02:36 <zzo38> @faq Do you like this?
16:02:36 <lambdabot> The answer is: Yes! Haskell can do that.
16:02:47 <ski> Solaris : my `loop' was just meant as an example of tail-calls in general, and tail-recursion in particular. showing how we do iteration with recursion in Haskell (though we can define our own `while',`for',&c. if we want them)
16:03:03 <Philippa> @faq Should people who piss about with the bot while a serious conversation's happening be made to reconsider?
16:03:04 <lambdabot> The answer is: Yes! Haskell can do that.
16:03:04 <Eiam> my god, its like lambdabot returns the same response for all @faq questions! ;)
16:03:15 <Eduard_Munteanu> Yeah, I was worried he read it like LET FOO = X IN BAR BAZ :)
16:03:21 <Solaris> Basically that for loop is going to keep flipping through node.data with the node.next function I'm assuming is also coded elsewhere until its found a match of which node matches list and then return the acc number counter to identify which node is the match
16:03:29 <ski> Solaris : e.g. there's `forM_ ["Hello","World"] $ \word -> putStrLn word', where `forM_' is just a library function
16:04:36 <zzo38> But it is currying so even    forM_ ["Hello","World"] putStrLn    is working
16:05:15 <acowley> I love how lambdabot's faq command is a trigger for OCD programmers to attempt an exhaustive search of the input space.
16:05:27 <monochrom> yes Eiam, @faq is const, @hackage is id
16:05:29 <EvilMachine> Solaris: list comprehensions are *a lot* like SQL select statements btw: http://en.wikipedia.org/wiki/List_comprehension#Haskell
16:05:38 <edwardk> @faq is lambdabot's faq command a trigger for OCD programmers?
16:05:39 <lambdabot> The answer is: Yes! Haskell can do that.
16:05:57 <monochrom> but your further experiments should go in PM
16:06:14 <edwardk> @hackage speculation
16:06:15 <lambdabot> http://hackage.haskell.org/package/speculation
16:06:18 <EvilMachine> Philippa: what serious conversation? ^^
16:06:30 <Eduard_Munteanu> I wonder why they even wrote QuickCheck... you could prod a #haskeller :)
16:06:36 * hackagebot ad 1.5.0.2 - Automatic Differentiation  http://hackage.haskell.org/package/ad-1.5.0.2 (EdwardKmett)
16:06:38 <edwardk> not quite id, its more like ("http://hackage.haskell.org/package/" ++)
16:06:41 <Philippa> EvilMachine: Solaris is trying to learn
16:07:19 <ski> Solaris : no, `node.next' just selects the next element node in the list
16:07:39 <ski> Solaris : this is just a silly "sum all numbers in the list" example
16:07:43 <kallisti> http://dl.dropbox.com/u/16495819/2012-05-10_19-03-18_1366x768.png
16:07:46 <kallisti> any idea what's happening here?
16:07:58 <kallisti> emacs won't clear old frames until I change workspaces
16:08:00 <kallisti> or move it in some way.
16:08:05 <ski> (and `node.next' was supposed to be C, for comparision)
16:08:16 <kallisti> like resizing the window will make it clear old frames
16:08:26 <acowley> One day lambdabot will respond to a single faq query with a different answer and all the #haskellers present will forever be telling the moral equivalent story of, "One time, I saw a 2."
16:08:27 <Philippa> ski: I find not everybody's used to switching languages at the rate we do in here :-)
16:08:35 <EvilMachine> Philippa: agreed. and it’s a good thing. :)
16:09:08 <kallisti> only appears to be happening with emacs
16:09:27 <Eiam> @gettingstarted
16:09:27 <lambdabot> Unknown command, try @list
16:09:45 <ski> Solaris : so, maybe i should have said this more explicitly, but the point of my example was to show how a particular C pattern translates into Haskell, specifically how iteration with `for' (or `while', or `do'-`while') translates into recursion
16:10:01 <ski> @where LYAH
16:10:01 <lambdabot> http://www.learnyouahaskell.com/
16:10:06 <EvilMachine> Philippa: Est ce-que you dir there sëcher? :D
16:10:08 <ski> Eiam : were you looking for that ^
16:10:08 <kallisti> oh wait wrong window..
16:10:27 <Eiam> ski: I'm hoping its a more enjoyable experience than learn you some erlang
16:10:29 <Solaris> So its basically the same but the way you write it is all different
16:10:41 * ski hasn't read LYSE
16:10:46 <zachk> > foldl (:) [] "Hello World!"
16:10:47 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
16:11:18 <Eduard_Munteanu> Solaris: another interesting (related) idea is you can generalize control flow using higher-order functions.
16:11:30 * ski isn't really sure here why Philippa was bringing up CPS and tail-calls from the start
16:11:50 <vraid> even C++ compilers can handle tail-call optimization
16:11:51 <Philippa> ski: build a "low-level" model, then rise on up
16:12:02 <Solaris> I.e. task switching, packet switching, optimising memory allocation to the simultaneous tasks?
16:12:07 <EvilMachine> Solaris: Eduard_Munteanu’s comment is related to that “define what the semicolon means” thing i mentioned before.
16:12:14 <ski> Solaris : hm, i suppose i should say that it's very easy in Haskell to break out common code, refactoring, to a much greater extent that is normally done in most other languages
16:12:33 <Philippa> CPS is often surprisingly natural for low-level coders so long as it's explained the right way (which, um, isn't by everyone else piling in the explanation, though yours is appreciated)
16:12:48 * ski agrees
16:13:01 <Eduard_Munteanu> Anyway, and if you're ok with some math, you might find some of the theoretical aspects behind it (those related to category theory or type theory) interesting.
16:13:02 <EvilMachine> Solaris: as in: monads are like higher-order higher-order functions… kinda. (what i want to say: it’s one level higher than even the step from functions to high-level ones)
16:13:17 * EvilMachine hopes he doesn’t write nonsense. ;)
16:13:21 <ski> Philippa : if you'd like to continue, i'll try to keep bay :)
16:13:24 <Solaris> Evilmachine, now you're talking metaphysics
16:13:36 <Philippa> ski: I should really be trying to sleep, it's been a long week!
16:13:47 <Solaris> Keep it in hex, assembly or C so us poor folks who were educated in teh 20th centry can understand
16:13:48 <ski> hehe .. /me is also a bit tired atm
16:15:20 <ski> Solaris : well, you know `qsort',`bsearch' and various callback-accepting functions -- well doing this kind of thing is very easy and natural in Haskell (and one finds oneself doing it much more than in many other languages therefore, making code easier to read and maintain, also making it more concise)
16:15:30 <Philippa> Solaris: you can build a language where the only calls you're allowed are tail calls, which is usable as an intermediate language for a compiler but also has strong mathematical properties. We call that language "continuation passing style". Would you like me to explain why?
16:15:51 <EvilMachine> Solaris: just thing: 1) static data; 2) function processing static data; 3) function processing functions; 4) monad processing how functions process functions (ok, this is not exactly right, but you get the drift)
16:15:58 <Solaris> Phillipa yes
16:16:00 <EvilMachine> thing=think
16:16:05 <Eduard_Munteanu> Solaris: certain things like special control flow, handling failure, side effects etc. can actually be approached in a unified manner. That common interface is what we call a monad.
16:16:17 * ski thinks Solaris probably isn't ready yet to attempt to grasp monads
16:16:39 <Eduard_Munteanu> Ah, I wasn't trying that. More like providing incentives :)
16:16:44 <acowley> Simultaneous knowledge injection of CPS and monads. #haskell is optimistic!
16:16:58 <Philippa> Solaris: okay. So suppose I'm writing main - start of my program's execution, right? - and I want to call something in that language. I have to tell it where to go afterwards, but this language doesn't know what a return address is. What I do is pass in /the rest of main/. The rest of main is what we call a "continuation"
16:17:10 <Solaris> Try me, show me the source code of what monad does in a lower level language and I'll get it
16:17:24 <Philippa> So CPS is a style where instead of function calls returning to you, you pass your continuation to it
16:17:47 <EvilMachine> ski: i disagree. monads are actually pretty easy because of their simple elegance. they are just ususally really badly explained. (it’s better to leave away the analogies)
16:17:48 <Philippa> Solaris: Monads are an abstract pattern, you can't describe the pattern itself in lower-level languages. You can describe it /as/ one, though
16:18:02 <ski> well, it's hard to get a grip on what monads *do* and what they're good for -- since there's usually nothing comparable in most other languages -- first you have to understand a lot of examples, and then discover how monads can make all those both shorter and more managable
16:18:33 <Philippa> Solaris: does that quickie explanation of continuation passing style make sense?
16:18:46 <ski> EvilMachine : well, you need to be familiar with common use of higher-order functions, first, i think
16:18:51 <Solaris> Haskell was coded from lower level languages, some bright spark must have come up with the code for it
16:19:04 <Philippa> Rest of chan: is it okay if ski and I do most of the talking here? We're getting into pedagogical arguments, I imagine they're confusing
16:19:26 <Philippa> Solaris: Haskell was eventually implemented in them, but languages like it are usually conceived with pen and paper or similar
16:19:53 <EvilMachine> ski: that may be. although i think “imagine a function that you can pass a function to, and that can return a function” is reasonably simple. :)
16:20:02 <nominolo> Solaris: Lazy ML and Miranda came before and inspired Haskell
16:20:36 <ski> (EvilMachine : except that many programmers aren't very comfortable with the idea -- but let's stop the meta-discussion for the moment now, ok ?)
16:20:41 <zachk> Solaris: have you ever played with Scheme?
16:20:57 <EvilMachine> ski: one could then add: “such a function could define a function, that calls the the passed-in function and then does some more” “it would then return that function”
16:21:11 <Philippa> Solaris: we can teach you the basics of some of the maths if you want, it's pretty simple but it's computing without the machines-we-call-computers
16:21:16 <EvilMachine> ski: okay. but only because it’s you, totally random stranger. ;)
16:21:24 <Philippa> instead it's very algebraic
16:21:36 * hackagebot WebBits 2.2 - JavaScript analysis tools  http://hackage.haskell.org/package/WebBits-2.2 (AndreyChudnov)
16:21:40 <Solaris> Right so basically c is hi(a){blabla return(bla)]; main{int bla, woo; woo==hi(bla) return{bla}} whereas haskell is like... what exactly? You don't have to return a value with a function?
16:21:54 <Solaris> Does that mean haskell is all global
16:22:03 <Solaris> no values are function bound
16:22:31 <Philippa> Solaris: let's run with the maths side for a moment? It might explain better
16:22:33 <Eduard_Munteanu> Solaris: no.
16:23:05 <Solaris> Maths shoot, makes more sense
16:23:23 <ski> Solaris : in Haskell, it's more like every function looks like `foo_t frob(bar_t bar) { return (..big expression here..); }' (though this is an over-simplification)
16:23:33 <Eduard_Munteanu> Solaris: functions are first-class values in Haskell.
16:23:35 <Philippa> Solaris: If I write x |-> x + 1, give or take the bad ASCII, what does that mean to you?
16:23:49 <Philippa> Eduard_Munteanu: too many cooks. ski and I've got this, 'k?
16:24:07 <Eduard_Munteanu> Alright.
16:24:34 <Philippa> Solaris: sorry if that's a little patronising btw, just fishing for notation in common
16:24:38 <Solaris> Ohh I get it now, Haskell can return something abstract like root(-1) identity to infinity and or (-infinity)
16:24:48 <Solaris> No that's fine
16:24:59 <Philippa> the exact range of stuff Haskell can return is more complicated than that
16:25:08 <Philippa> You still have to be constructivist about things :-)
16:25:19 <Solaris> Constructivist?
16:25:27 <Solaris> As in using structures
16:25:27 <ski> (Haskell can't compute incomputable stuff, i think Philippa means)
16:25:34 <Philippa> okay, can I show you one of the smallest vaguely-usable programming languages known to humanity, that's also mathematical?
16:25:43 <Solaris> sure
16:25:53 <Philippa> Solaris: yeah, and you only have the structures you've actually built - otherwise you just have ways to try to build them
16:26:04 <zachk> > reverse "Hello world!"
16:26:05 <lambdabot>   "!dlrow olleH"
16:26:21 <zachk> > foldr (:) [] "Hello world!"
16:26:22 <lambdabot>   "Hello world!"
16:26:29 <Philippa> okay. This language is called the "lambda calculus". Unfortunately I have to write \ instead of a lambda because I have no lambda key. Fortunately, Haskell uses \ for it too :-)
16:26:36 * hackagebot stable-maps 0.0.3.2 - Heterogeneous maps keyed by StableNames  http://hackage.haskell.org/package/stable-maps-0.0.3.2 (EdwardKmett)
16:26:46 <zachk> > foldl (flip (:)) [] "Hello World!"
16:26:46 <EvilMachine> Philippa: here is one for you:λ
16:26:48 <lambdabot>   "!dlroW olleH"
16:27:10 <Philippa> So the lambda calculus has three things in its (abstract) syntax. The first thing is variables - there's an infinite alphabet of them, and they're just identifiers like in algebra
16:27:20 <tgeeky> dmwit: https://github.com/technogeeky/pi-eta-epsilon/commit/d8d13c4ec167d1efc86b472e0d8a7fe7be9dd88b
16:27:42 <Philippa> sometimes we say a variable is "bound" to something. That something will be another term/expression/program in the lambda calculus for now
16:27:59 <Philippa> but there's no notion of memory or anything. Does that make sense so far?
16:28:13 <Solaris> So you can have an unknown value x and its happy with an undefined value?
16:28:28 <zachk> it is happy with an unevaluated value
16:28:31 <ski> each variable will have to get a value, before it can be used
16:28:42 <tgeeky> dmwit: note I don't claim usefulness, but check it out.
16:28:49 <Philippa> actually, an unbound variable is just itself
16:28:56 <Philippa> (zachk, ski: pure lambda calculus!)
16:29:13 <Philippa> so if you run the program "x" without x bound in the context, what you get is "x"
16:29:28 <Philippa> so far this is a bit boring, right? I'd better introduce a way to do something
16:29:30 * ski was thinking cbv/cbn here .. maybe you want applicative/normal order
16:29:32 * zachk looks around frowardly 
16:29:54 <Philippa> you need two components to that: functions, and function application
16:30:09 <Philippa> I'll show you application first, because the syntax is a little unusual
16:30:16 <Philippa> All lambda calculus functions take exactly one parameter
16:30:33 <Philippa> so you write an application like this: (f x). That's equivalent to calling f with x as a parameter
16:30:43 <Solaris> OK, so say I've got an unknown neighbour's wifi key x but I've got lots of known data packets stored as a structure of arrays. And I think I know what some of the cleartext is, haskell can algorithmically use simultaneous equations and elimination to break the code?
16:31:02 <Philippa> Solaris: step back for a moment and just look at exactly what I'm showing you?
16:31:37 * hackagebot pointed 2.1.0.2 - Haskell 98 pointed and copointed data  http://hackage.haskell.org/package/pointed-2.1.0.2 (EdwardKmett)
16:32:33 <Philippa> Solaris: okay, so we know there might be some functions and how to call them, but not what a function looks like or what happens when you call it. Let's fix that?
16:33:21 <Philippa> a function in the lambda calculus looks like this: \ <variable> . <term>
16:33:27 <Philippa> so \x . x is the identity function
16:33:52 <Philippa> The variable is the parameter to the function
16:34:03 <ski> `\x . x' is *the* function which, given an input (call it `x'), returns `x'
16:34:41 <Philippa> yeah. Though the actual rule that matters is something called "beta reduction", which is an algebraic rule
16:34:41 <ski> (note that the function hasn't been given a name, in the programming language -- the function is just a value, just like `42 + 2' is a value, it doesn't have to be given a name)
16:35:04 <Solaris> so \x . x is haskells way of doing a c x(x);
16:35:17 <ski> `\x . x' isn't quite Haskell -- it's lambda-calculus
16:35:39 <nexion> I'm wondering why this gives a type error:  :t (randomRIO (0 :: Integer, 2 ^ (16 :: Int))) >>= show
16:35:40 <Solaris> like all that dy/dx I had to do yonks ago?
16:35:41 <EvilMachine> Wow. JS list comprehensions are really close to HS ones: http://en.wikipedia.org/wiki/List_comprehension#JavaScript_1.8
16:35:46 <Philippa> Solaris: (x){return x;}
16:36:00 <ski> lambda-calculus is sortof the "machine code" of functional programming languages -- except it doesn't operate with memory and instructions, it operates with values, expressions, and functions
16:36:11 <relation> hi, is there a simple way to generate haddock and gather all html files? such that the documentation can be embedded on CD for example? links to Prelude and so on.. thanks
16:36:14 <nexion> shouldn't show receive Integer?
16:36:37 * hackagebot constraints 0.3.0.1 - Constraint manipulation  http://hackage.haskell.org/package/constraints-0.3.0.1 (EdwardKmett)
16:36:53 <Philippa> yeah. Given the beta reduction rule, it's actually turing complete. And beta reduction is 'just' that function calls do what you expect, except that you can evaluate any specific function call ("reducible expression" or "redex") you want
16:37:21 <Philippa> I guess I should put some examples in a pastebin quickly, or possibly put them in here
16:37:37 * ski isn't sure whether Solaris knows the term "turing complete"
16:37:52 <Philippa> okay, this function is a little bit stranger than the identity function: "\x . (\y . x)"
16:37:53 <gienah> relation: you can hack the script: gen_contents_index
16:38:16 <ski> nexion : replace `show' with e.g. `print', or with `doIt . show'
16:38:17 <mauke> nexion: the problem is in what show returns
16:38:39 <nexion> it works with print
16:38:45 <relation> gienah: ok, thanks i will look at it
16:38:57 <nexion> and this works too:
16:38:58 <Philippa> Solaris: Suppose I call that "tru" for a moment - so tru = "(\x . (\y . x))" and = works like in maths
16:38:59 <gienah> relation: you could hack it something like this, and run it in a directory where you want the haddock index file: http://hpaste.org/50164
16:39:15 <nexion>   newSiteIdInteger <- randomRIO (0 :: Integer, 2 ^ (16 :: Int))
16:39:15 <nexion>   let newSiteId = LT.pack $ show $ newSiteIdInteger
16:39:17 <EvilMachine> Philippa: (while also listening to you:) i think you would have to explain the "beta reduction" concept.
16:39:24 <Solaris> So = is no longer this value now beomes that value anymore?
16:39:40 <Philippa> Solaris: correct. It's what it means in day-to-day maths instead
16:39:58 <Philippa> that the two things on either side are equivalent and you can replace one with the other
16:40:10 <Solaris> to me == is my day to day maths cos I haven't been in a  lecture theatre in over a decade
16:40:29 <Philippa> Solaris: would you be okay if we take this to #haskell-overflow? We'd have fewer interruptions there
16:40:31 <nexion> mauke: doesn't show return String?
16:40:35 <Solaris> sure
16:40:40 <mauke> nexion: yes
16:40:48 <mauke> nexion: that's the problem
16:41:05 <Philippa> Solaris: cool, see you there
16:41:11 <nexion> I'm missing something
16:41:21 <nexion> randomRIO is IO Integer
16:41:25 <EvilMachine> wow, there is -overflow too? Listing: #haskell, #haskell-blah, #haskell-in-depth, #Gentoo-Haskell, and now also #haskell-overflow. ^^
16:41:25 <mauke> yes
16:41:30 <EvilMachine> what else is there?
16:41:37 * hackagebot free 2.1.1.1 - Monads for free  http://hackage.haskell.org/package/free-2.1.1.1 (EdwardKmett)
16:41:41 <Philippa> EvilMachine: -overflow's one of the older ones actually
16:41:42 <nexion> >>= show, show gets Integer as the arg
16:41:51 <nexion> and returns String
16:41:54 <monochrom> for certain languages L, there are #haskell-L
16:41:54 <mauke> nexion: yes
16:42:01 <Eduard_Munteanu> EvilMachine: there are a few more I can't remember right now :)
16:42:02 <EvilMachine> Philippa: i thought so. overlaps a lot with -in-depth and -blah.
16:42:05 <nexion> String is what I'm after
16:42:08 <mauke> nexion: no
16:42:15 <Eduard_Munteanu> Oh... #haskell-math IIRC
16:42:22 <mauke> nexion: you can't have String
16:42:25 <Eduard_Munteanu> Nope, dead.
16:42:34 <mauke> nexion: look at the type of (>>=)
16:42:35 <EvilMachine> Eduard_Munteanu: right now, i wouldn’t be surprised by #haskell-for-hello-kitty-chainsaws anymore. ;)
16:42:49 <nexion> oh
16:42:50 <monochrom> that's perverse :)
16:42:53 <nexion> I see
16:43:05 <EvilMachine> monochrom: they exist! (the chainsaws)
16:43:10 <relation> gienah: thanks!
16:43:13 * Eduard_Munteanu thinks of registering #haskell on memebase :P
16:44:28 <Eduard_Munteanu> gienah: btw, do you have anything to do with the agda ebuilds?
16:44:57 <nexion> mauke, what's a nice way to make it a one-liner?
16:45:28 <mauke> nexion: liftIO
16:45:35 <mauke> what
16:45:36 <mauke> no
16:45:39 <mauke> nexion: liftM
16:47:51 <Eduard_Munteanu> Good to see mauke 'wat's himself as well :)
16:48:28 <monochrom> haha
16:52:55 <nexion> ok, I see what was happening; thanks mauke :)
16:54:03 <angstrom> given `data Bla = X | Y | Z', `data A = ABla Bla | ABar' and `data B = BBla Bla | BFoo' I need to convert between A and B quite a bit, like `case x of ABla b -> BBla b' and vice versa. is there a nice way to do this?
17:07:11 <siracusa> angstrom: What's bad about case?
17:07:28 <Eduard_Munteanu> angstrom: not really. What exactly do you have in mind?
17:08:53 <FrostyX> probably i couldnt write ...
17:08:56 <FrostyX> I am new in haskell. First I saw it in xmonad configuration
17:08:59 <FrostyX> two days ago :)
17:09:34 <hpc> FrostyX: brace yourself for strangeness and learning :P
17:09:42 <angstrom> siracusa, Eduard_Munteanu: don't really know. I thought, maybe there was a nice abstraction/approach for this, which I'm not aware of. otherwise I'll just define some functions
17:10:51 <FrostyX> can you see what I write now ? Something strange appeared to me .. :-D
17:11:01 <angstrom> the problem is, that right now there's a bunch of case-ofs wherever I need to make a conversion. sure it works, but it feels kinda meh
17:11:07 <Eduard_Munteanu> angstrom: your particular datatype looks like Maybe Bla, perhaps you want to use something like that? I was asking about the specific application.
17:12:58 <angstrom> Eduard_Munteanu: fair enough. I'm having a datatype `Value' and `Environment' and `Stack' which both can contain `Value's. as already mentioned, I need to convert between them on certain cases
17:13:43 <angstrom> Eduard_Munteanu: Environment and Stack also contain other stuff, besides Values
17:14:57 <Eduard_Munteanu> angstrom: do they always contain a Value?
17:15:27 <Eduard_Munteanu> If so, you could use record syntax to avoid pattern-matching.
17:15:54 <Guest25789> hpc: yes, haskell seems like funny language :-D
17:17:45 <angstrom> Eduard_Munteanu: Environment no, and Stack is in fact a [Value]. I'm already using *some* record syntax, where I know what's in there
17:18:11 <vraid> what has to be added to this for the list to have an end? [ x | x <- [1..], x < 50 ]
17:18:47 <angstrom> [1..49]
17:18:57 <vraid> is it possible to do in another way?
17:19:12 <vraid> using [1..]
17:19:18 <angstrom> no
17:19:20 <monochrom> depends on what you really, really want
17:19:23 <vraid> ok, thanks
17:20:05 <Eduard_Munteanu> You could also try takeWhile, depending on your usecase.
17:20:10 <Eduard_Munteanu> :t takeWhile
17:20:11 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
17:20:28 * applicative recommends Ctrl-C
17:20:46 <monochrom> but it is the main reason why I disagree with "haskell is just like math". expecting [ x | x <- [1..], x < 50 ] to terminate is precisely the harmful result of "haskell is just like math"
17:20:57 <monochrom> haskell is just a programming language
17:21:07 <Eduard_Munteanu> Yeah, fair.
17:21:39 <applicative> the program will yield  the correct result, just give it time
17:21:48 <applicative> its just like math
17:21:53 <monochrom> ok hahaha
17:23:23 <t7> C is kinda like haskell
17:23:29 <t7> but in the IO monad all the time
17:23:35 <t7> any everything is an IO Ref
17:23:40 <monochrom> the braces and semicolons help
17:23:41 <t7> but global
17:23:54 <monochrom> but you're missing pointer arithmetic
17:24:18 <monochrom> setjmp, longjmp
17:24:21 <t7> yeah its just like a data Value = Value | Ptr Value
17:24:34 <t7> yeah jumps are hard to translate
17:24:35 <Eduard_Munteanu> I guess some weird string of unsafePerformIOs might actually give you that :P
17:26:00 <applicative> we have GOTO 's defined in Haskell
17:26:23 <FrostyX> crap, everythink is wrong today. I am out of history. Who helped me ? I forget your name. So sorry. Much please write me PM
17:27:06 <Eduard_Munteanu> FrostyX: hpc replied to you
17:27:28 <Eduard_Munteanu> FrostyX: but if you have a question, you should just ask it directly.
17:27:55 <FrostyX> not hpc. the other guy
17:28:01 <applicative> @google amuse lennart goto
17:28:03 <lambdabot> http://augustss.blogspot.com/
17:28:03 <lambdabot> Title: Things that amuse me
17:28:37 <monochrom> that is, http://augustss.blogspot.ca/2009/02/more-basic-not-that-anybody-should-care.html
17:29:07 <FrostyX> I changed managehook and layouthook but dont know what next cause of deleted history :(
17:29:45 <applicative> it's so twisted, this BASIC
17:29:57 <monochrom> http://bit.ly/5mwtRQ logs this channel. you may be able to find stuff
17:52:21 <kallisti> shapr: o hai
17:59:16 <kallisti> "Flymake: Configuration error has occured while running (ghc.mod check newmark.hs). Flymake will be switched OFF"
17:59:26 <kallisti> any idea what this is about. I just upgraded ghc-mod
17:59:50 <vraid> is there a more concise way to do  [ a*b | a <- xs, b <- xs ]
18:00:37 <ski> > liftM2 (*) [2,3] [300,400,500]
18:00:38 <lambdabot>   [600,800,1000,900,1200,1500]
18:01:12 <dabblego> @type join (liftA2 (*))
18:01:13 <lambdabot> forall a (f :: * -> *). (Num a, Applicative f) => f a -> f a
18:01:20 <dabblego> > join (liftA2 (*)) [1,2,3]
18:01:21 <lambdabot>   [1,2,3,2,4,6,3,6,9]
18:02:13 <dabblego> > let xs = [1,2,3] in [ a*b | a <- xs, b <- xs ]
18:02:13 <EvilMachine> hmm… what exactly is lifted here?
18:02:14 <lambdabot>   [1,2,3,2,4,6,3,6,9]
18:02:26 <dabblego> list monad/applicative
18:02:42 <EvilMachine> > let xs = [1,2,3] in [ a*b | a <- xs, b <- xs ] == join (liftA2 (*)) [1,2,3]
18:02:42 <dabblego> the join is on ((->) t)
18:02:43 <lambdabot>   True
18:03:00 <dabblego> @check \xs -> [ a*b | a <- xs, b <- xs ] == join (liftA2 (*)) (xs :: [Int])
18:03:03 <lambdabot>   "OK, passed 500 tests."
18:03:09 <applicative> > let xs = [1..3]; ys = [1] in (*) <$> xs <*> ys
18:03:10 <lambdabot>   [1,2,3]
18:03:52 <applicative> vraid with the unimplemented 'idiom brackets' you would write (|xs * ys|)
18:04:07 <dabblego> pretty
18:04:08 <EvilMachine> that’s just perverse. luckily, i like it kinky. ^^
18:04:23 <vraid> i think i'll stick to the implemented features
18:04:49 <EvilMachine> seconded… until i am at the level where i can suggest improvements myself.
18:05:10 <ion> applicative: That would be nice, i guess.
18:05:23 <monochrom> the problem with unimplemented features is that you can only write blogs and books on them
18:05:27 <applicative> hey  ... there is a preprocessor ...  http://hackage.haskell.org/package/she  at least one hackaged package uses it
18:06:20 <EvilMachine> what I really don’t like is: unspeakable meaningless symbols. because 1. you can’t google ’em, 2. you can’s speak ’em, 3. they are not descriptive. so people like me just have no way to store them in the brain.
18:06:33 <EvilMachine> :(
18:06:42 <EvilMachine> they look pretty though
18:06:49 <monochrom> I saw a book of chapters by futurists on what they believe the world will be like 50 years in the future. we need a similar book for haskell, too
18:07:09 <EvilMachine> especially when you, like me, go crazy and use tons of unicode symbols. ;)
18:07:11 <luite> does future ahskell have flying cars?
18:07:54 <EvilMachine> i think it’s inavoidable for haskell to become a living entity and its own universe at the same time.
18:08:16 <EvilMachine> like “infinitely small from the outside, but infinitely large from the inside”
18:08:19 <sipa> it isn't yet?
18:08:22 <EvilMachine> lol
18:08:33 <sipa> have you tried reaching the Core?
18:08:35 <EvilMachine> well, at least it isn’t trying to annihilate the universe yet.
18:08:41 <EvilMachine> YET
18:08:52 <EvilMachine> (or maybe it’s so smart, that we just don’t notice)
18:08:57 <luite> core isn't really part of haskell though, only of some implementation
18:09:14 <monochrom> I have reached the core
18:09:22 <EvilMachine> that’s right. haskell has no heart. ;))
18:09:30 <sipa> luite: see, it's already trying to confuse you
18:09:50 <luite> EvilMachine: i went straight past the core and found that it had no spine either
18:09:53 <sipa> the greatest trick the devil ever pulled was convince the world he didn't exist
18:11:08 <monochrom> if you are 20 and you don't use haskell, you have no core. if you are 40 and you still use haskell, your brain has exploded
18:11:42 <monochrom> perhaps better be:
18:11:51 <monochrom> if you are 20 and you don't use haskell, you have no core. if you are 40 and you still use haskell, you have no brain, it exploded
18:13:44 <hpc> i use agda
18:13:48 <hpc> 20 years is far too long a fuse
18:15:00 <EvilMachine> I think Haskell is http://en.wikipedia.org/wiki/Yog-Sothoth
18:15:23 <EvilMachine> “It was an All-in-One and One-in-All of limitless being and self — not merely a thing of one Space-Time continuum, but allied to the ultimate animating essence of existence's whole unbounded sweep — the last, utter sweep which has no confines and which outreaches fancy and mathematics alike. It was perhaps that which certain secret cults of earth have whispered of as YOG-SOTHOTH, and which has been a deity under othe
18:15:23 <EvilMachine> r names; that which the crustaceans of Yuggoth worship as the Beyond-One, and which the vaporous brains of the spiral nebulae know by an untranslatable Sign…”
18:16:14 <EvilMachine> (The sign is λ btw. ^^)
18:16:15 <monochrom> tl;dr
18:16:16 <applicative> was that composed by a program?
18:17:01 <EvilMachine> applicative: yes, it was. The HP Lovecraft 1.0. (They make more than printers and servers.)
18:18:23 <EvilMachine> Unrelated note: If i’d work at HP, I would *definitely* give my program that name. ^^
18:19:05 <EvilMachine> PHP is http://en.wikipedia.org/wiki/Nyarlathotep
18:19:12 <EvilMachine> and with that, I’m off. :)
18:20:36 <kallisti> what's the efficiency of CReal compared to Decimal?
18:20:48 <kallisti> I'm not too familiar with how CReal is implemented, other than it's a function
18:20:58 <kallisti> doing some kind of base-2 magic
18:21:01 <kallisti> I think
18:22:25 <applicative> it has been talked up by jmcarthur I remember, who pointed it out to me
18:22:46 <applicative> it is really cool
18:23:23 <applicative> he was preferring it to Rational, I think, for practical purposes
18:25:13 <applicative> I wonder if more recent type extensions could make it cooler.  It arbitrarily makes accuracy cut off at the equivalent of 40 decimal points or something
18:25:58 <rwbarton> that is just showCReal
18:26:05 <applicative> but if you change it to 1000 its still surprisingly fast
18:26:10 <applicative> no it goes deeper
18:26:14 <rwbarton> well and (==)
18:26:17 <applicative> if i remember
18:26:23 <applicative> right ==
18:26:29 <rwbarton> (==) is a bit silly to talk about anyways
18:26:34 <applicative> yes
18:26:47 <rwbarton> the value itself doesn't have any fixed precision
18:27:13 <applicative> maybe i was wrongly swayed by ==
18:27:39 <ski> > let f (a :: b) = a in f ()
18:27:40 <lambdabot>   A pattern type signature cannot bind scoped type variables `b'
18:27:40 <lambdabot>    unless th...
18:27:46 <ski> > let f :: a -> a; f (a :: b) = a in f ()
18:27:46 <applicative> also the ord instance
18:27:48 <lambdabot>   ()
18:27:54 <ski> > let f :: a -> a; f (a :: b) :: b = a in f ()
18:27:55 <lambdabot>   <no location info>: Parse error in pattern
18:28:00 <ski> :/
18:28:33 * ski wonders when result type ascriptions stopped working
18:29:12 <applicative> rwbarton: yes it isn't so bad as i remembered; just those, and show and signum all for the same obvious  reason
18:29:47 <ski> (hm, still seems to work in hugs, even without the type signature)
18:30:43 <applicative> rwbarton: of course the values are okay, if we forget about Int I was  imagining more  functions were affected
18:32:10 <applicative> ski hugs gives me ERROR - Haskell 98 does not support pattern type annotations
18:32:21 <applicative> wait, it told me why
18:32:22 <ski> you need to call it like `hugs -98'
18:33:04 <ski> (though istr recent Hugs also understands `LANGUAGE')
18:33:28 <applicative> ski, the answer is ()
18:33:33 <ski> yeah
18:33:57 * applicative again contemplates a Committee to Save Hugs
18:37:32 <ski> INTERNAL ERROR: findBtyvsInt
18:37:35 <ski> interesting
18:40:27 <ski> @hoogle (m a -> t m b) -> (t m a -> t m b)
18:40:27 <lambdabot> No results found
18:40:33 <applicative> i wonder if there's any way to get ghci to open with the kitschy ascii art the way hugs does, and Idris
18:40:44 <ski> it did before
18:40:50 <applicative> i mean, the way it did when i first installed it
18:43:05 <applicative> at least ghc -V still calls itself "Glorious"
18:43:56 <aristid> applicative: do you fear the "glorious" might go away too? /o\
18:44:12 <applicative> it's too horrible to imagine!
18:44:25 <aristid> yes!
18:48:08 * ski . o O ( .. do i really want `Traversable11 t => (a -> FreshId b) -> (t IdVar a -> FreshId (t IdVar b))' here ? )
18:51:03 <ski> hm, i suspect i want something like `traverse11 :: Applicative i => (forall a b. (a -> b) -> (f a -> i (g a))) -> (forall a b. (a -> b) -> (t f a -> i (t g a)))'
18:51:15 <ski> (yeah, that's a bit of a mouthful ..)
18:51:35 <ski> (er, s/g a/g b/, i.e.)
18:52:08 <Ralith> there comes a time when one-letter variable names cease to scale
18:52:25 <tgeeky> Ralith: when you have 27 variable names
18:52:51 <ski> conjecture : if `Functor f' and/or `Functor g', then `forall a. f a -> g a' is iso to `forall a b. (a -> b) -> (f a -> g b)'
18:52:52 <Ralith> of course not
18:53:01 <Ralith> that's when you start using symbols!
18:53:15 <tgeeky> one letter symbols?
18:53:30 <Ralith> it's unicode, I'm sure such a thing exists
18:53:34 <barrucadu> So, the scaling starts to fail when you exhaust all of unicode?
18:53:40 * ski is already using symbols in `lookupMap1 :: Eq1 key => Map1 key value -> (key i -> Maybe (value i))' here ..
18:53:57 <Ralith> barrucadu: or that's what a lot of people seem to think, anyway :P
18:54:16 <barrucadu> Aww, ghci doesn't support *all* of unicode :(
18:54:22 <barrucadu> (for identifiers, at least)
18:54:28 <barrucadu> <interactive>:5:5: parse error on input `∃'
18:56:06 <applicative> > let (∃) = (+) in 2 ∃ 3
18:56:07 <lambdabot>   5
18:57:06 <applicative> > let (∃) = elem in 2 ∃ [3]
18:57:06 <lambdabot>   False
19:00:41 <ski> hm, if i have `type NatTransf f g = forall a. f a -> g a', what should i call `forall a b. (a -> b) -> (f a -> g b)' ?
19:05:20 * ski notes the stunning silence ..
19:07:26 <ski> .. i suppose the type is the same as `forall a. f a -> Yoneda g a', and also the same as `forall b. CoYoneda f b -> g b'
19:08:15 <ski> .. meaning it could be written like `NatTransf f (Yoneda g)' or like `NatTransf (CoYoneda f) g'
19:09:40 <ski> note to self : it might not work to flatten the node elements of a tree with infinite branches into a list in the naïve way ..
19:11:26 <tgeeky> can anyone tell me how in the heck I can write the Unfoldable term for "LProduct (Context a) (Term a) UValue" in: https://github.com/technogeeky/pi-eta-epsilon/blob/is-valueF-unfoldable/src/Language/PiEtaEpsilon/Evaluator.hs
19:11:37 <tgeeky> or is it impossible
19:11:54 <ski> hm -- i wonder if i could zip the result i'm trying to construct with my input, to get an "environment", which i can then use to construct the result i want ..
19:13:57 <ski> tgeeky> :t unfold
19:16:52 <ku> why can't haskell infer that: double double x
19:17:13 <ku> means: double (double x)
19:17:35 <ski> because it means `(double double) x'
19:18:03 <ku> why doesn't it begin with the first double function?
19:18:21 <ski> because that's not how the syntax works
19:18:28 <ku> i mean why doesn't it begin with the most-right-ward one
19:18:43 <ski> we want `foo bar baz' to mean `(foo bar) baz', to get currying with light syntax
19:18:51 <ku> ah ok
19:19:05 <ski> and we don't want to make the way things parse dependent on the types
19:19:07 <ku> so the benefit becomes apparent in a currying context? I'm not there yet..ha
19:19:34 <ski> we want to be able to understand the expressions we've written as trees, *before* we attempt to give types to thinks
19:19:47 <ku> hm
19:20:01 <tgeeky> ski: uhh... are you asking me?
19:20:06 <ski> tgeeky : yes
19:20:24 <tgeeky> ski: unfold :: (Unfolder f, Unfoldable t) => f a -> f (t a)
19:20:36 <tgeeky> ski: UTerm :: t (UTerm t v) -> UTerm t v
19:21:44 <ku> ski: also wouldn't haskell actually be passing the first double 2 arguments? double and x?
19:22:20 <ski> yes, but "passing two arguments" here is really just a short way of saying "passing a single argument, getting a function back, then passing a single argument to that function"
19:22:47 <ku> ski: ah ok... is that behaviour related to currying?
19:22:51 <ski> yes
19:22:53 <ski> consider
19:23:01 <ski>   > map succ [0,1,2]
19:23:06 <ski> > map succ [0,1,2]
19:23:07 <lambdabot>   [1,2,3]
19:23:54 <ski> > let incrementThem xs = map succ xs  in  map incrementThem [[],[0],[1,2],[3,4,5],[6,7,8,9]]
19:23:55 <lambdabot>   [[],[1],[2,3],[4,5,6],[7,8,9,10]]
19:24:01 <ski> > let incrementThem = map succ  in  map incrementThem [[],[0],[1,2],[3,4,5],[6,7,8,9]]
19:24:02 <lambdabot>   [[],[1],[2,3],[4,5,6],[7,8,9,10]]
19:24:23 <ski> > let incrementThem = \xs -> map succ xs  in  map incrementThem [[],[0],[1,2],[3,4,5],[6,7,8,9]]
19:24:24 <lambdabot>   [[],[1],[2,3],[4,5,6],[7,8,9,10]]
19:24:31 <ski> > map (\xs -> map succ xs) [[],[0],[1,2],[3,4,5],[6,7,8,9]]
19:24:32 <lambdabot>   [[],[1],[2,3],[4,5,6],[7,8,9,10]]
19:24:37 <ski> > map (map succ) [[],[0],[1,2],[3,4,5],[6,7,8,9]]
19:24:39 <lambdabot>   [[],[1],[2,3],[4,5,6],[7,8,9,10]]
19:24:52 <ski> these are all different ways of writing the same thing
19:25:09 <ku> thanks! I will take a closer look at them
19:25:14 <ski> note how in the last one (and in the next-to-first one), we're calling `map' with only a single argument
19:25:14 <mauke> TMTOWTDI!
19:25:28 <ski> then `map' returns a *function* that is still waiting for the input list
19:25:42 <ku> ok
19:25:57 <ku> so its partial-function-application
19:26:01 <applicative> > id id 4
19:26:01 <lambdabot>   4
19:26:02 <ski> and in the `map (map succ) [...]' example, the function that `map succ' returns is passed to the outer `map' (which calls it on every list in the list of lists)
19:26:17 <mauke> > 2 + 3
19:26:19 <lambdabot>   5
19:26:21 <mauke> > (+) 2 3
19:26:23 <lambdabot>   5
19:26:23 <ku> the function takes two params but you pass it one argument to produce another function that will take the 2nd specifies param (in the originating function)
19:26:24 <ku> sort of?
19:26:27 <mauke> > ((+) 2) 3
19:26:28 <lambdabot>   5
19:26:31 <ski> ku : yes
19:26:46 <ku> interesting, makes sense
19:26:49 <mauke> technically, every function takes exactly one argument
19:27:18 <applicative> namely the one it juxtaposed to
19:27:21 <ku> so a function that takes 5 params can be said to curry 4 times?
19:27:21 <applicative> it's
19:27:36 <ski> ku : note that if `map' had been defined so as to call it like `map (succ,[...])', it would have been harder to make the above things (in a short, nice way)
19:28:00 <applicative> and besides, we have uncurry map
19:28:16 <applicative> > uncurry map (succ , [1])
19:28:17 <lambdabot>   [2]
19:28:32 <ski> > let uncurriedMap = uncurry map  in  uncurriedMap (succ,[0,1,2])
19:28:33 <lambdabot>   [1,2,3]
19:28:38 <mauke> :t uncurry
19:28:40 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
19:29:25 <applicative> if , if a then if b then c, then, if both a and b then c
19:30:05 <ski> @type uncurry uncurry
19:30:06 <lambdabot> forall a b c. (a -> b -> c, (a, b)) -> c
19:30:21 <ski> @type uncurry curry
19:30:22 <lambdabot> forall b b1 c. ((b, b1) -> c, b) -> b1 -> c
19:30:32 <ski> @type curry
19:30:33 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
19:31:13 <applicative> @type uncurry id
19:31:13 <lambdabot> forall b c. (b -> c, b) -> c
19:32:09 <applicative> it's a sort of modus ponens
19:32:40 <ski> tgeeky : anyway, you have an `f a', and you want to get an `f UValue', i think
19:33:06 <ski> tgeeky : maybe you could try first getting an `f (Const UValue a)' ?
19:33:41 <ski> tgeeky : i'm not sure if there is any instance for `Unfoldable (Const c)', though ..
19:34:09 <tgeeky> ski: probably not, but I could make one
19:34:10 <tgeeky> (\fa -> (LProduct <$> unfold fa <*> unfold fa))
19:34:10 <tgeeky>   :: Unfolder f => f a -> f (UValue -> Context a)
19:34:18 <ski> (or maybe my suggestion wouldn't work anyway -- i'm not sure)
19:34:38 <ski> yeah, you're missing a `<*> ...' at the end
19:34:55 <tgeeky> :: Unfolder f => f a -> f UValue -> f (Context a)
19:35:39 <ski> what methods does `Unfolder' provide ?
19:35:55 <tgeeky> ski: http://hackage.haskell.org/packages/archive/unfoldable/0.5.0/doc/html/Data-Unfolder.html
19:36:03 <tgeeky> ski: choose and chooseInt
19:37:07 <ku> is there a way to save partially applied functions for later use? i.e. mapsucc = map succ ... later ... mapsucc [1,2,3]
19:37:29 <tgeeky> @let mapsucc = map (succ)
19:37:30 <lambdabot>  Defined.
19:37:34 <tgeeky> @type mapsucc
19:37:34 <lambdabot> forall a. (Enum a) => [a] -> [a]
19:37:40 <tgeeky> > mapsucc [1,2,3]
19:37:41 <lambdabot>   [2,3,4]
19:37:46 <tgeeky> ku: yes
19:37:53 <ku> tgeeky: ah ok thanks
19:38:06 <ku> tgeeky: why the parenthesis to make it work?
19:38:14 <ski> no need
19:38:18 <tgeeky> ku: just habit
19:38:30 <tgeeky> mainly because I was thinking
19:38:40 <tgeeky> @let mapplus1 = map (+ 1)
19:38:41 <lambdabot>  Defined.
19:38:47 <tgeeky> > mapplus1 [1,2,3]
19:38:49 <lambdabot>   [2,3,4]
19:39:13 <tgeeky> @src succ
19:39:13 <lambdabot> Source not found. Just try something else.
19:39:18 <tgeeky> @type succ
19:39:19 <lambdabot> forall a. (Enum a) => a -> a
19:39:19 <ski> @type succ
19:39:20 <lambdabot> forall a. (Enum a) => a -> a
19:39:45 <ku> but when I try in ghci: let mapsucc = map (succ)
19:39:53 <ku> it errors out with message:
19:40:00 <ku> <interactive>:1:20:
19:40:00 <ku>     Ambiguous type variable `b0' in the constraint:
19:40:00 <ku>       (Enum b0) arising from a use of `succ'
19:40:00 <ku>     Probable fix: add a type signature that fixes these type variable(s)
19:40:00 <ku>     In the first argument of `map', namely `(succ)'
19:40:01 <ku>     In the expression: map (succ)
19:40:01 <ku>     In an equation for `mapsucc': mapsucc = map (succ)
19:40:23 <ski> this is the DMR (Dreaded Monomorphism Restriction) in action
19:40:44 <ski> you can disable it with `:set -XNoMonomorphismRestriction'
19:40:53 <ku> ha i was talking about monomorphism the other day here, people were quite firey about it =)
19:41:20 <blackdog> ku: that's right :)
19:41:35 <ku> ski: can it be expected that a deployed app can rely on such a setting?
19:41:38 <ski> basically, the DMR was invented, because it was thought newbies would be less confused about certain pieces of code, if it was present
19:41:44 <tgeeky> just put the ':set -XNoMono...' in your ~/.ghci file and forget about it
19:41:45 <ku> i mean is it normal to develop to such a setting in haskell?
19:42:13 <tgeeky> ku: absolutely
19:42:25 <ski> ku : if you add `{-# LANGUAGE NoMonomorphismRestriction #-}' to the top of a module, it's be applied automatically for that module
19:42:38 <ku> ski: oh ok awesome
19:43:04 <ku> i'm just thinking in terms of distribution and code sharing, it seems doubtful that everyone can be sure their settings are the same?
19:43:18 <ku> but if it can be specified in the module too then great...
19:43:28 <tgeeky> MR isn't a big enough thing to worry about
19:43:37 <tgeeky> and it really mostly bites you at the ghci prompt, not in regular modules
19:43:46 <ku> ah ok
19:43:59 <blackdog> ku: if it turns out you do need it in packaged code, you can set a LANGUAGE pragma
19:44:29 <ski> ku : there are two other ways to defuse the DMR : (a) make it an explicit function definition (`mapsucc xs = map succ xs' in your case) -- this can't be done if it *isn't* a function; (b) add an explicit type signature
19:45:03 <ski> ku : if you do any of those two things (or both), you'll not need to rely on `NoMonomorphismRestriction', since the DMR won't even fire
19:45:41 <ku> ski: ironic that a feature meant to help newbies is hindering one in my case
19:45:47 <ski> ku : e.g. in your case, you could have said `let mapSucc :: Enum a => [a] -> [a]; mapSucc = map succ'
19:46:29 <ski> (and you can ask the interactor with `:t map succ' for what type signature you need ..)
19:46:38 <ski> @type map succ
19:46:39 <lambdabot> forall a. (Enum a) => [a] -> [a]
19:47:31 <ku> thanks for all the help, very insightful
19:47:36 <ski> yw
19:48:07 <tgeeky> ku: there is *much* to learn by reading the GHC docs
19:49:15 <ski> tgeeky : `(Bounded a, Enum a) => Unfoldable (Constant a)'
19:50:16 <tgeeky> so I should try doing what again?
19:50:20 <tgeeky> <*> Constant UTerm?
19:50:52 <ski> hm, maybe
19:51:39 <tgeeky> i've been kindly blindly doing this stuff anyway
19:51:43 <tgeeky> this Unfoldable class is pretty amazing though
19:51:46 <ski> well, more like `<*> (unConstant <$> unfold fa)', i suspect
19:52:08 * ski has never seen these classes before, not exactly sure what they do
19:52:25 <tgeeky> ski: generate all the things!
19:52:29 <Unresolved> Chapter 3 Digital COmic: https://www.youtube.com/watch?v=lCqwVYuPZu8
19:52:35 <ski> yeah, but the devil is in the details :)
19:52:36 <tgeeky> ski: cabal install unfoldable, and check out the examples
19:52:43 <tgeeky> it's pretty cool
19:54:11 <ski> i'm not quite sure how you're meant to unfold non-parametric data types
19:54:33 <tgeeky> ski: hehe. if you look at the changelog of my version of pi-eta-epsilon vs. dmwits
19:54:40 <tgeeky> you'll see that I spent some time paramterizing everything
19:55:13 <ku> tgeeky: I've been starting with http://en.wikibooks.org/wiki/Haskell but the section regarding DRM and double double x could use some of the explainations you imparted here IMO
19:55:30 <tgeeky> ku: I mean the Haskell Report
19:55:43 <ski> `unfold :: (Unfoldable t,Unfolder f) => f a -> f (t a)' obviously requires a parametric thing
19:56:01 <tgeeky> ku: http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/
19:56:02 <ski> hm
19:56:03 <ku> tgeeky: will checkit out
19:56:07 <ku> tgeeky: thanks
19:56:24 * ski isn't quite sure of the role of the unfolder here ..
19:56:37 <tgeeky> ski: I'm not either, which makes this kind of silly
19:56:46 <tgeeky> ski: I don't even think it makes sense, but I also don't see why I can't just write the damn thing
19:57:15 <tgeeky> ski: i wrote unfolders for all the things in: https://github.com/technogeeky/pi-eta-epsilon/blob/is-valueF-unfoldable/src/Language/PiEtaEpsilon/Syntax.hs
19:57:32 <zxspectrum> hi all. I have a Monad m => Maybe (m ()) instance. is there a simple way to run the monad action if it has one, or do nothing on Nothing?
19:57:34 <ski> i suspect the `a' here is actually used to carry a state/seed
19:57:43 <tgeeky> ski: nope! I introduced it!
19:57:53 <ski> tgeeky ?
19:58:16 <zxspectrum> right now I have: maybe (return ()) id $ x, which seems like more than is necessary
19:58:18 <ski> tgeeky : are you sure you specified the type signature of `unfold' ?
19:58:25 <tgeeky> ski: before I started trying to write unfolders, this was: data Context = Box | Fst Context Term | Snd Term Context
19:58:52 <tgeeky> ski: I already have an Unfoldable instance for Term
19:59:02 <ski> zxspectrum : `Monad m => MaybeT m ()'
19:59:10 <tgeeky> ski: oh. maybe I should just paramterize UValue
19:59:25 <ski> tgeeky : that could work -- if it's sensible
19:59:31 * ski can't tell whether it is
19:59:38 <zxspectrum> ski, it's actually the result of a map lookup
19:59:40 <tgeeky> ski: well I don't know if it is or not, but it's worked for everything else so far
20:00:06 <ski> zxspectrum : i don't think that changes my answer ..
20:01:21 <ski> tgeeky : anyway, often when looking at abstract code like this, there's a feeling that things sortof make sense, only that you don't know what the sense actually is :)
20:02:08 <tgeeky> ski: all I know is that if I run functions like "typeRand" and "typeShapes"
20:02:10 <ski> (i.e. you build some kind of feel for the structure of the sense, but you're still left in the dark as to the contents)
20:02:14 <tgeeky> i get all kinds of amazing things
20:02:36 <tgeeky> ski: yeah, I have been doing things that the typechecker permits blindly for a few hours now :)
20:03:14 <zxspectrum> ski, I thought you were suggesting I change the type signature, and runMaybeT? (sorry, I don't know much about monad transformers)
20:04:53 <ski> zxspectrum : hm, wait
20:05:09 <tgeeky> ski: woohoo!
20:05:10 <tgeeky> (\fa -> LProduct <$> unfold fa <*> unfold fa <*> unfold fa)
20:05:10 <tgeeky>   :: Unfolder f => f IntVar -> f (Context IntVar)
20:05:21 <ski> zxspectrum : sorry, i thought you wanted to give `Nothing' if the input returned `Nothing', otherwise process the contents
20:05:53 <zxspectrum> nope, I just want to run the action on Just, otherwise do nothing
20:06:42 <c_wraith> so then you want a function missing from the standard library, but redefined often - whenJust :: Maybe a -> (a -> IO ()) -> IO ()
20:06:53 <ski> @type Data.Foldable.mapM_
20:06:54 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Foldable.Foldable t, Monad m) => (a -> m b) -> t a -> m ()
20:06:55 <ski> @type Data.Foldable.mapM_ return
20:06:56 <lambdabot> forall a (m :: * -> *) (t :: * -> *). (Monad m, Data.Foldable.Foldable t) => t a -> m ()
20:07:04 <tgeeky> ski: so now I'm again in the same position, but for IntVar, I think
20:07:05 <ski> @type Data.Foldable.sequence_
20:07:06 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Foldable.Foldable t, Monad m) => t (m a) -> m ()
20:07:16 <ski> zxspectrum : i think you want one of those
20:07:18 <c_wraith> I guess Foldable.mapM_ will do
20:07:52 <ski> `t' is `Maybe', in your case
20:08:23 <ski> it will iterate over all elements of the `Maybe ...'
20:08:55 <ski> so either there's only `Nothing', and it does nothing, or there's `Just x', and it does whatever it is you want to do with `x'
20:09:31 <zxspectrum> hm, I was trying sequence_ earlier and it wanted a list. didn't think Maybe was Foldable
20:09:33 <ski> tgeeky : i think that code won't work
20:09:39 <tgeeky> ski: me too :)
20:09:39 <c_wraith> @instances Foldable
20:09:40 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
20:09:40 <ski> it ought to be polymorphic, but isn't
20:09:53 <c_wraith> @instances-importing Data.Foldable Foldable
20:09:53 <lambdabot> Maybe, []
20:10:23 <ski> zxspectrum : `sequence_' in `Data.Foldable' is more generic than the usual `sequence_'
20:10:28 <ski> @index sequence_
20:10:29 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
20:11:39 <zxspectrum> ah, there's the problem
20:11:40 <ski> tgeeky : hmm -- maybe we can go via `f (UTerm ValueF (Constant IntVar))' somehow ..
20:12:13 <zxspectrum> thanks, it's working
20:12:17 <ski> tgeeky : is `UTerm ValueF' a `Functor' ? `Traversable' ?
20:12:45 <tgeeky> Uter t is a functor, applicative, and alternative
20:12:49 <tgeeky> it's not traversable
20:14:25 <ski> hm, is `UTerm ValueF' in `Unfoldable' ?
20:14:50 <tgeeky> it's defined, but currently empty
20:14:54 <tgeeky> (there are no ways to unfold it yet)
20:15:03 <ski> but there will be (hopefully) ?
20:15:23 <tgeeky> ski: I'm not sure. This is kind of where this problem all started. there *is* an instance Unfoldable ValueF
20:16:02 <ski> maybe you can get away with lifting yourself in the hair here, so to speak
20:17:56 <ski>   ... <*> ((fmap getConstant . getCompose) <$> unfold fa)
20:18:02 <ski> something like that *might* work
20:18:09 <ski> (assuming you flesh out that other instance)
20:18:33 <ski> tgeeky : are you following my line of thought ?
20:18:54 <tgeeky> ski: uhh, no but I can certainly sort of blindly try them
20:19:03 <ski> this is meant to use the generic `instance (Unfoldable p, Unfoldable q) => Unfoldable (Compose p q)', as well as the `Constant' stuff
20:19:16 <ski> the idea is that
20:19:22 <ski>   fa :: f a
20:19:55 <ski>   unfold fa :: f (Compose (UTerm ValueF) (Constant IntVar) a)
20:20:25 <ski>     getCompose :: Compose (UTerm ValueF) (Constant IntVar) a -> UTerm ValueF (Constant IntVar a)
20:20:39 <ski>   getConstant :: Constant IntVar a -> IntVar
20:20:55 <ski>   fmap getConstant :: UTerm ValueF (Constant IntVar a) -> UTerm ValueF IntVar
20:21:23 <ski>   fmap getConstant . getCompose :: Compose (UTerm ValueF) (Constant IntVar) a -> UTerm ValueF IntVar
20:21:37 <ski>   (fmap getConstant . getCompose) <$> :: f (UTerm ValueF IntVar)
20:21:42 <ski> (.. if you can follow that)
20:21:45 <ski> er
20:21:53 <ski>   (fmap getConstant . getCompose) <$> unfold fa :: f (UTerm ValueF IntVar)
20:22:11 <tgeeky> aha
20:22:24 <tgeeky> no instance of Unfoldable (Const IntVar))
20:22:26 * ski here just sortof backwards-followed the types
20:22:29 <tgeeky> i must be using a different const
20:22:46 <tgeeky> aha!
20:22:50 <ski> yeah, this is using `Constant'
20:22:55 <tgeeky> now I need (Bounded IntVar, Enum IntVar)
20:23:06 <ski> yeah -- so the question is whether those exist
20:23:14 <ski> or even if they'd be sensible
20:23:21 <ski> if they're not, this idea fails :)
20:23:32 <tgeeky> hehe :)
20:23:46 * ski isn't really sure what `IntVar' is, and where it's coming from
20:24:05 <tgeeky> I don't think so. The only time things like maxBound or minBound are checked is inside:   instance (Unifiable t, Applicative m, Monad m) => BindingMonad ...
20:24:08 <tgeeky> ski: unification-fd package
20:25:43 <tgeeky> also there's this: deriving instance BindingMonad ValueF IntVar (PEET m)
20:25:54 <ski> hm, i suppose maybe we'll want to monadically generate these `IntVar's dynamically, instead of sortof randomly grabbing ones from a statically determined set
20:26:13 <tgeeky> ski: yes! I tink so. I'm thinking I might need 'chooseMonadDefault'
20:26:22 * ski is looking at <http://hackage.haskell.org/packages/archive/unification-fd/0.7.0/doc/html/Control-Unification-IntVar.html>, atm
20:26:38 <tgeeky> i really don't have a clue how unification (or how this package specifically) works
20:27:16 <ski> "I'm thinking I might need 'chooseMonadDefault'" -- i'm not so sure
20:27:56 <ski> hm, the unfoldr isn't monadic, but at least applicative
20:28:01 <ski> that maybe is enough
20:28:19 <ski> but we still need a way to do the dynamic generation, then
20:28:52 <tgeeky> :r
20:29:46 <ski> hm, these two packages are meant to be used together ?
20:29:53 <ski> (or at least one with the other)
20:29:57 <tgeeky> ski: which?
20:30:08 <ski> `unification-fd' and `unfoldable'
20:30:17 <tgeeky> ski: almost surely not
20:30:19 <ski> i'm asking if the former is meant to be used with the latter
20:30:24 <tgeeky> ski: in that regard, I'm sure what I'm doing is completely new
20:30:30 <ski> ok
20:30:49 <ski> then possibly the implementer of `unfoldable' hasn't thought of your situation
20:31:04 <tgeeky> i was hoping he'd join tonight
20:31:37 <tgeeky> I don't see why IntVar shouldn't be Bounded, but I doubt it's Enum
20:32:17 <ski> i'm not sure if it could be `Bounded', now that i (think i) better understand it
20:32:33 <ski> if it's anything like `STRef s', i'd be surprised if it sensibly could
20:33:09 <tgeeky> ski: there is a STVar version
20:33:14 <ski> `STRef s' (and `IORef', for that matter) behaves a bit like a datatype with an unknown number of constructors
20:33:22 * ski nods
20:33:35 <tgeeky> but that doesn't have any of these applicative and alternative instances
20:33:49 <ski> the "constructors" are only determined dynamically, by performing certain monadic actions
20:34:12 <ski> yeah, those are probably less flexible
20:34:30 <ski> but i think `IntVar' should share many of the conceptual properties of the others
20:34:35 <tgeeky> ski: I suppose if this does work.... I don't know what the end result will be.
20:34:52 <tgeeky> if you can unfold contexts... that seems like a pretty insanely powerful tool for QuickCheck
20:35:05 <ski> i mean, if it's just implemented by an `Int', then one could concievable just get an `Int', converting it to an `IntVar'
20:35:20 <tgeeky> ski: that would probably fail 100% of the time though :o
20:35:20 <ski> however, i don't think that'd work (it'd probably crash, or behave strangely)
20:35:24 <tgeeky> even if it does typecheck
20:35:42 <ski> since presumably it needs to register the `IntVar's actually creates in some kind of state
20:35:50 <jfischoff> tgeeky: I bet new generics could derive instances for QuickCheck also
20:36:08 <tgeeky> jfischoff: hehe. You haven't seen the mess I've got myself into
20:36:18 <tgeeky> jfischoff: check my github... better yet i'll give you a link
20:36:27 <jfischoff> I'm confused with the code. its above me
20:36:32 <ski> tgeeky : hm, noticing `arbitraryDefault' now -- ok
20:36:35 <jfischoff> sure
20:36:50 <tgeeky> jfischoff: https://github.com/technogeeky/pi-eta-epsilon/tree/is-valueF-unfoldable/src/Language/PiEtaEpsilon
20:36:55 <ski> tgeeky : so i think to get what you want, probably a generalization of the `Unfoldable' interface would be needed
20:37:03 <tgeeky> jfischoff: it should build, so you can git clone it
20:37:23 <jfischoff> cool, I'll post my small about of stuff in a few
20:37:58 <tgeeky> jfischoff: in particular, check out: valuefShapes, valuefRand, typeShapes, typeRand.
20:38:07 <tgeeky> jfischoff: isoShapes, isoRand ...
20:38:19 <tgeeky> jfischoff: I haven't a clue if these are useful or not, maybe you can inspect them and find out
20:38:52 <ski> tgeeky : so, i think the best conclusion i can draw (given that i don't really know either package) is that you want/need a weaker generalization of `Unfoldable' -- the less weak, the better, i think
20:38:54 <tgeeky> jfischoff: but from inspecting those and the rest of the functions I put in Syntax.hs, this seems like it might be very useful in QuickCheck
20:39:08 <tgeeky> ski: so a tiny generalization, or a big one?
20:39:11 <ski> tgeeky : e.g. if you can get away with commutative monads or applicatives, that's probably better
20:39:15 <ski> tgeeky : i'm not sure
20:39:32 <tgeeky> ski: I'm waiting on dmwit to let me know if any of this makes sense (though he's not familar with unfoldable)
20:39:40 <jfischoff> tgeeky: do they work?
20:39:45 <tgeeky> jfischoff: yes, try them out
20:39:46 <ski> tgeeky : in any case, a generalization which means that `arbitraryDefault :: (Arbitrary a, Unfoldable t) => Gen (t a)' will be impossible to define
20:40:05 <ski> (since you can't possible have that, and generate `STRef s's)
20:40:08 <tgeeky> ski: yeah. I realized that a while ago, I think...
20:40:18 <jfischoff> I'll take your world for it. So do we have instances for all of our types?
20:40:20 <tgeeky> this is sort of a different way to generate these things than Arbitrary
20:40:31 <jfischoff> s /world/word
20:40:40 <tgeeky> jfischoff: I can paste some output to help convince you
20:40:44 <tgeeky> jfischoff: I don't know the answer to that
20:40:54 <jfischoff> I believe you
20:41:21 <ski> preflex: xseen wren
20:41:21 <preflex>  wren was last seen on freenode/##javascript 1 year, 296 days, 41 minutes and 37 seconds ago, saying: Enter text here...
20:41:24 <tgeeky> jfischoff: well, like I said... I see a huge amount of output, but I don't know if it's actually useful to do anything
20:41:28 <ski> (hm, probably not the same)
20:41:49 <jfischoff> i wonder if it is the same output as before...
20:42:47 <jfischoff> wait do you have shrinks?
20:43:00 <tgeeky> jfischoff: nope, and I don't think that matters with this interface
20:43:02 <tgeeky> but I'm not sure yet
20:43:12 <jfischoff> shrinks are great with grammars
20:43:34 <jfischoff> it makes testing parsers much easier
20:43:56 <jfischoff> anyway, they are also derivable.
20:45:37 <ski> tgeeky : think this is probably as far as we come for the moment ..
20:45:45 <ski> tgeeky : .. will need to get some sleep
20:46:16 <tgeeky> ski: you're not kidding. thanks for all of the help and guidance though
20:46:20 <tgeeky> ski: much appreciated!
20:46:23 <ski> yw
20:46:23 <tgeeky> ski++
20:46:57 <shapr> kallisti: o hai kallisti! HAIL ERIS!
20:47:50 <jfischoff> tgeeky: I am almost 100 percent confident if you can derive arbitrary you can derive shrink
20:48:13 <shapr> jfischoff: Yah?
20:48:14 <kallisti> shapr: I'm at that point in development where I'm having second thoughts on the effectiveness of the overall design.
20:48:25 <shapr> kallisti: How so?
20:48:32 <jfischoff> I think shrinks are simplier
20:48:34 <shapr> What would you like to change to, and why?
20:48:36 <kallisti> I'm not sure if I have a sane way to do exception handling, in particular.
20:48:49 <kallisti> with recursive operations like deletion, move, copy, etc.
20:48:50 <jfischoff> with QC?
20:49:19 <shapr> jfischoff: Wouldn't traversable let you shrink any sequence?
20:49:29 <shapr> kallisti: How are you handling it now?
20:49:34 <kallisti> shapr: the tryRemoveWith is my attempt to fix that problem, by allowing an exception handler to be passed to handle each individual removal operation, in the event that an exception occurs.
20:49:38 * shapr goes to look at kallisti's repo
20:49:44 <kallisti> the default behavior is all-or-nothing. if a file fails then the whole thing stops.
20:49:48 <kallisti> which I think is not ideal.
20:49:49 <hpaste> tgeeky pasted “p-e-e syntax unfolding” at http://hpaste.org/68367
20:49:57 <kallisti> but I'm not sure if "ignore all errors lolololol" is a better solution.
20:49:59 <tgeeky> jfischoff: ok: http://hpaste.org/68367
20:50:08 <jfischoff> Yeah I bet, can't you make zippers with traversable?
20:50:27 <shapr> kallisti: I like the samurai principle myself.
20:51:04 <shapr> kallisti: What don't you like about stop if fail?
20:51:14 <tgeeky> jfischoff: as you can see, this seems to be generating every possible thing :o
20:51:22 * shapr thinks
20:51:36 <shapr> rm -rf announces a failed file, but continues.
20:51:50 <shapr> I wonder if the whole process stops without -f ?
20:51:51 <jfischoff> tgeeky:what madness are you getting yourself into :0
20:52:02 <tgeeky> jfischoff: I know right?
20:52:06 <jfischoff> prolog?
20:52:45 <shapr> kallisti: It's no longer at https://github.com/kallisti-dev/directory-trees
20:52:53 <kallisti> shapr: it's filesystem-trees
20:52:57 <kallisti> there's already directory-tree
20:53:08 <shapr> Ah
20:53:09 <jfischoff> tgeeky: I've been wondering recently how powerfully our unification could be?
20:53:09 <kallisti> (but it's not very good imo)
20:53:48 * shapr clones 
20:54:24 <kallisti> shapr: so you think fail if a single operation fails is a good approach?
20:54:32 <shapr> kallisti: Ah, so you're also a southeasterner with me and tgeeky?
20:54:34 <kallisti> it seems kind of sloppy to me. you leave the directory in a sloppy state.
20:54:41 <kallisti> yes. I live in Georgia.
20:54:52 <shapr> Yah, but what would be better than stop everything when something fails?
20:55:07 <kallisti> that's what I'm unsure of.
20:55:19 <kallisti> providing functions with custom exception handlers is probably good though.
20:55:22 <shapr> Perhaps make that the default, but allow a switch that continues and just reports failure?
20:55:27 <kallisti> maybe a particular application would prefer to ignore exceptions, or do something else.
20:55:35 <kallisti> but then the question becomes: what's the best callback function type?
20:55:48 <shapr> Right, sometimes I want to delete everything in a directory, but I'm okay with leaving the files I don't own.
20:55:49 <kallisti> a simple error handler is limited in the capacity it can recover from exceptions.
20:56:16 <shapr> So, ATLcon would be a fun Haskell meetup then.
20:58:17 <kallisti> I have no clue what we would do.
20:58:21 <kallisti> but okay! :P
20:58:28 <shapr> Write code!
20:58:33 <shapr> Like hac phi
20:58:39 <shapr> hac atl?
20:58:42 <kallisti> oh god but then I'd have to know how to pronounce Haskell code.
20:58:54 <shapr> I've never figured that out.
20:59:24 <kallisti> "yeah then you write less-than less-than equals return dot open bracket plus 1 close bracket"
20:59:26 <shapr> What the heck do I call <*> and &&& and all those other guys?
20:59:41 <kallisti> er greater-than
20:59:45 <shapr> I think >>= is bind
20:59:49 <kallisti> well yeah..
20:59:52 <shapr> At least the monad papers call it that.
20:59:52 <kallisti> contrived example.
21:00:02 <shapr> but what's =<< ?
21:00:06 <shapr> reverse bind?
21:00:08 <kallisti> reverse bind? flippy bind?
21:00:16 <shapr> ooh, I like flippy bind
21:00:19 <shapr> I'm stealing that one.
21:00:58 <mm_freak> <*> is "applied to"
21:01:07 <shapr> We just have to find a venue for twenty or thirty people, and then get them to show up.
21:01:16 <shapr> mm_freak: Do you live in the southeastern USA?
21:01:24 <mm_freak> no, in germany
21:01:36 <mm_freak> you can also call it S, if you like
21:01:37 <shapr> mm_freak: Ok, so what's ($) ?
21:01:44 <mm_freak> also "applied to"
21:01:49 <BMeph> BBIAB - lovely Windows restarting...
21:02:09 <shapr> I just call it dollar sign.
21:02:17 <kallisti> bling
21:02:21 <shapr> haha
21:02:45 <mm_freak> if it's Reader e or (e ->), i like to call <*> "S"
21:03:12 <shapr> Is that the S from SKI?
21:03:16 <mm_freak> yeah
21:03:26 <shapr> preflex: seen ski
21:03:26 <preflex>  ski was last seen on #haskell 17 minutes and 3 seconds ago, saying: yw
21:03:31 <mm_freak> <*> generalizes S, 'pure' generalizes K
21:03:36 <kallisti> shapr: is my code legible?
21:03:49 <shapr> Yup, nothing scary so far.
21:04:04 <shapr> A bunch of erlang guys once wrote a library in Haskell. *That* was scary.
21:04:29 <kallisti> I'm bad at reading most peoples code
21:04:32 <shapr> I have to figure out what lens really means.
21:04:40 <kallisti> but I can never tell if it's because their code is unreadable or if I'm just better at writing code than reading.
21:04:54 <mm_freak> logger :: MVar Msg  {-# NOINLINE logger #-}
21:05:06 <kallisti> shapr: do you understand them enough to read my code?
21:05:20 <vertue> Hi, wondering if anyone give me some pointers on how to do something like open all csv files in a folder for parsing?
21:05:23 <kallisti> I basically overload some lenses so that I can refer to both rose trees and FSTrees via the same interface.
21:05:39 <shapr> I can accept that for the time being, and go back and figure out what it really does later.
21:05:59 <mm_freak> kallisti: i understand other people's haskell code just fine, if they obeyed some elementary style rules…  for every other language i suck at reading
21:06:00 <ozataman> vertue: csv-conduit or csv-enumerator might help you out
21:06:01 <kallisti> I just think of them as a getter function paired with a setter function.
21:06:06 <kallisti> but there are some other bits I don't fully understand.
21:06:07 <mm_freak> like:  write a type signature for every top level definition
21:06:32 <ozataman> Veinor: the conduit version at this point requires you to know how to use conduit, csv-enumerator provides a more regular haskell interface
21:06:36 <ozataman> Veinor: sorry, mt
21:06:42 <vertue> sorry the csv was just an example
21:06:48 <ezyang> Does Pandoc support reading in "author" bibliographic information from ReST?
21:06:53 <vertue> could be any file type
21:07:02 <kallisti> shapr: the unsafeCoerce is for efficient newtype wrapping/unwrapping. there was actually considerable overhead with mapping newtype wrappers/unwrappers over lists.
21:07:04 <mm_freak> shapr: Lens a b is really just (a -> b, b -> a -> a)
21:07:08 <mm_freak> intuitively
21:07:12 <mm_freak> a getter and a setter
21:07:34 <mm_freak> data-lens' Lens type boils down to:  newtype Lens a b = Lens (a -> (b, b -> a))
21:07:34 <vertue> just want to do something like getDirectoryContents then readfile everything that matches a pattern
21:07:55 <mm_freak> vertue: you have to implement the recursive traversal yourself
21:08:06 <vertue> ouch...
21:08:18 <vertue> was hoping someone else had done that.
21:08:25 <kallisti> this problem sounds strangely applicable to the library I'm currently working on. :P
21:08:36 <vertue> I am still very noob with IO stuff
21:08:47 <shapr> kallisti: hahaha
21:08:51 <mm_freak> vertue: not a very common thing to do, and the code is really straightforward enough that for the few cases where this is needed it can be written by hand
21:09:08 <kallisti> filter (".csv" `isSuffix`) =<< getDirectory "my/directory"
21:09:09 <ezyang> Apparently, you need to {indent} :Author: authorname
21:09:11 <shapr> Wait what? walking a directory tree *is* very common!
21:09:15 <ezyang> hooway sourcedivin'
21:09:20 <mm_freak> vertue: if it's just a little tool for yourself and you use zsh you can also exploit zsh's recursive traversal feature
21:09:28 <mm_freak> ./myprog **/*.csv
21:09:50 <kallisti> vertue: I'm currently working on high-level library for directory manipulation/processing, but there's no official release yet.
21:10:01 <vertue> cool,
21:10:03 <kallisti> the code has been pretty well bugtested, for what's there.
21:10:07 <mm_freak> shapr: walking a tree is common and implemented…  walking a directory tree is not that common
21:10:11 <vertue> let me know is you need some testing
21:10:31 <kallisti> vertue: code is here https://github.com/kallisti-dev/filesystem-trees
21:10:36 <shapr> mm_freak: I disagree, I often want to do that.
21:10:46 <kallisti> there's a cabal file but the dependency constraints are pretty lenient atm
21:10:56 <kallisti> (read: non-existent)
21:11:01 <mm_freak> shapr: ah, the "i am everybody" fallacy =)
21:11:16 <vertue> ah...
21:11:23 <shapr> mm_freak: I recently wanted to automatically generate playlists for my Sansa ClipZip, but walking a directory tree was too painful after a few hours of trying to do it.
21:11:32 <shapr> I wanted to clean up my music files, but walking a directory tree is ...
21:11:44 <kallisti> vertue: let me know if you want some help setting it up and trying it out.
21:11:59 <mm_freak> shapr: huh?  it's about a 10-liner…  i've done it a few times
21:12:01 <shapr> I wanted to find all my Haskell source files and collect their creation and modification dates to get an activity graph, but walking a directory tree...
21:12:15 <shapr> mm_freak: Do you have code handy? I'd like to see how you did it.
21:12:22 <kallisti> it's a simple thing to do.
21:12:27 <kallisti> but, tedious, and it shouldn't take 10 lines.
21:12:43 <mm_freak> shapr: gimme a minute to code it
21:12:47 <shapr> ok
21:13:02 <kallisti> shapr: what do you think about the newtype?
21:13:07 <kallisti> originally I had  type synonym
21:13:09 <shapr> kallisti: may be able to exploit mm_freak's results to see if there's some other handy way to do this :-)
21:13:24 <shapr> Seems okay to me :-)
21:13:36 <kallisti> the benefit of a newtype is that you can convery with types whether or not results confirm to the expected representation for a filesystem subtree
21:13:41 <kallisti> *convey
21:14:04 <vertue> kallisti: thank for the link but way over my head...
21:14:07 <kallisti> for example, a generic map on a FSTree wouldn't be resulting in a FSTree, it would result in a Tree.
21:14:18 <kallisti> because I don't know what you did to my representation anymore.
21:15:29 <kallisti> shapr: also I'm pretty sure zipWithDestM could be rewritten more efficiently.
21:15:34 <kallisti> but I was lazy.
21:17:08 <shapr> Hm, does look like it could be simpler, but nothing springs to mind
21:17:18 <kallisti> vertue: basically getDirectory "my/directory" retrieves a (lazy) representation of your directory and its subdirectories as a tree.
21:17:28 <kallisti> then you can apply operations on that. for example filtering based on file extension
21:17:51 <kallisti> filter (".csv" `isSuffixOf`) =<< getDirectory "blah"
21:18:13 <kallisti> mapM_ doStuffToFiles . toTree =<< filter (".csv" `isSuffixOf`) =<< getDirectory "blah"
21:18:34 <kallisti> (the toTree shouldn't be required in the actual first release)
21:18:42 <kallisti> (but for now it is)
21:19:02 <jfischoff> tgeeky: I think i might be confused what a Term is used for. I assumed it was an umbrella type to connect Types and Values but I don't see that ...
21:19:43 <vertue> ok most of that makes sense except the =<<
21:19:53 <kallisti> (=<<) = flip (>>=)
21:20:00 <kallisti> is >>= or flip new to you as well?
21:20:09 <tgeeky> jfischoff: keep in mind, I have changed pretty much all the types in the package (everywhere you see a paramter 'a', that's me)
21:20:10 <vertue> yeah... <blush>
21:20:18 <kallisti> flip f x y = f y x
21:20:23 <vertue> ok
21:20:30 <kallisti> aka it takes a function and produces a new function with the first 2 arguments reversed.
21:20:36 <vertue> and >>=?
21:20:49 <hpaste> “Ertugrul Söylemez” pasted “Recursive directory walk” at http://hpaste.org/68368
21:20:55 <mm_freak> shapr, vertue: see paste
21:21:04 <jfischoff> tgeeky: I was referring to dmwit's code.
21:21:08 <kallisti> >>= applies the result of a monad to a function that also returns a result of that monad.
21:21:11 <kallisti> >_>
21:21:34 <kallisti> in do notation do {x <- m; y}  is the same as m >>= (\x -> y)
21:22:12 <vertue> mmm... I think I have some reading to do
21:22:14 <mm_freak> to just get all files call it like:  dirWalk dir [] (\d ds -> return (d:ds))
21:22:15 <kallisti> if this is also new, I recommend reading a good tutorial/book on Haskell.
21:22:25 <shapr> vertue: We all do :-)
21:22:34 <vertue> struggling through learn you a haskell
21:22:42 <vertue> so I'll get there
21:22:45 <jfischoff> tgeeky: I pushed a small commit to my branch
21:22:46 <mm_freak> that's my combinator to walk a directory tree =)
21:22:52 <kallisti> vertue: cool. good luck to you.
21:22:53 <shapr> vertue: this is the place to get more help!
21:23:03 <vertue> thanks
21:23:04 <jfischoff> tgeeky: https://github.com/jfischoff/pi-eta-epsilon/tree/master/src/Language/PiEtaEpsilon
21:23:17 <vertue> and thanks for the example mm_freak
21:23:36 <kallisti> shapr: perhaps I should hide the internal representation?
21:23:46 <kallisti> maybe "toTree" should actually be prependPaths
21:24:31 <shapr> I'm rebuilding cabal so it will stop complaining about some of the fields in the cabal file.
21:24:45 <kallisti> oh. yeah I specify like 0 constraints.
21:24:51 <kallisti> what is it complaining about?
21:25:02 <shapr> default-extensions
21:25:07 <kallisti> oh, yes.
21:25:13 <shapr> Oh, I don't have 7.2
21:25:17 <kallisti> I should probably require a different cabal version
21:25:24 <kallisti> I have cabal-version: >= 1.6
21:25:31 <kallisti> but does 1.6 have default-extensions?
21:25:39 <mm_freak> kallisti: no
21:25:46 <shapr> I just installed cabal 1.14
21:25:48 <mm_freak> that's 1.10 IIRC
21:26:24 <mm_freak> yeah, 1.10 introduces Default-extensions
21:27:23 <kallisti> ah okay. I'll fix that then.
21:28:09 <kallisti> shapr: you wouldn't need 7.2
21:28:11 <mm_freak> kallisti: "cabal configure" should warn you about that anyway
21:28:12 <kallisti> *shouldn't
21:28:26 <shapr> I dunno then.
21:28:27 <kallisti> maybe I missed it.
21:28:38 <kallisti> shapr: the 7.2 thing is a condition in the cabal file.
21:28:43 <kallisti> because that's when -XTrustworthy started existing.
21:28:45 <zofodraziw> quick question: Say we have myAdd1 x y = trace ("myAdd1
21:28:47 <zofodraziw> oops
21:29:13 <zofodraziw> sorry about that. let's try again with a pastebin
21:29:27 <mm_freak> @where hpaste
21:29:27 <lambdabot> http://hpaste.org/
21:29:32 <kallisti> shapr: what kind of errors are you getting?
21:29:44 <kallisti> aside from default-extensions
21:29:46 <shapr> kallisti: it's a warning
21:29:52 <kallisti> cabal configure
21:29:56 <kallisti> wrong window. :P
21:30:06 <kallisti> silly focus-follows-mouse
21:30:15 <shapr> kallisti: Warning: filesystem-trees.cabal: Unknown fields: default-extensions (line 15)
21:30:23 <shapr> I prefer sloppy focus, but unity won't give me that.
21:30:31 <shapr> oh HEY, finals are over! I can FIX THIS!
21:30:38 <shapr> Yay! It's xmonad time!
21:30:39 <mm_freak> just as a side note
21:30:43 <kallisti> mm_freak: no warning with >= 1.6 and default-extensions
21:30:50 <mm_freak> there is a library called "directory-tree"
21:30:53 <kallisti> perhaps because I'm actually using GHC 7.0
21:30:55 <kallisti> mm_freak: yes
21:31:01 <kallisti> it's no good though.
21:31:08 * kallisti promises.
21:31:11 <mm_freak> it happens to be preinstalled on my system, but i have no idea what it's worth
21:32:00 <kallisti> I think it overcomplicates things a bit.
21:32:06 <hpaste> zofodraziw pasted “trace behavior” at http://hpaste.org/68369
21:32:24 <kallisti> and it uses unsafePerformIO to implement lazy IO, for reasons I'm not too clear on.
21:32:39 <zofodraziw> I'd be glad if you guys could help me with me quick question. thanks!
21:32:54 <mm_freak> i see
21:33:37 <mm_freak> zofodraziw: sure, just ask
21:34:38 <zofodraziw> I pasted the code to http://hpaste.org/68369. I get two different behaviors for myAdd1 and myAdd2. I don't understand why
21:34:56 <kallisti> shapr: I was thinking it would be fun to do something with zippers.
21:35:01 <shapr> That would be nifty.
21:35:05 <kallisti> maybe a mapWithZipper.
21:35:09 <shapr> That would be roughly "cd", right?
21:35:17 <mm_freak> zofodraziw: what's the difference in behavior?
21:35:18 <kallisti> well, not really
21:35:25 <kallisti> I was thinking of using it as a cursor in traversal.
21:35:34 <shapr> Explain?
21:35:48 <kallisti> so that you could do a map but also reach up/down/left/right to other files and do stuff with those if you need to.
21:36:09 <zofodraziw> mm_freak: myAdd2 displays 5,4,3,2,1 and myAdd1 displays 1,2,3,4,5
21:36:10 <shapr> Sounds like fun to me.
21:36:14 <kallisti> you traverse the tree, moving the zipper cursor around and passing the zipper to each node.
21:36:35 <kallisti> I have absolutely no idea when you would want to do such a thing
21:36:41 <shapr> I'll try to write the playlist builder with filesystem-trees tomorrow after sleep :-)
21:36:48 <mm_freak> zofodraziw: are you sure the pasted code is really the code you used?  i see no semantic difference between the two functions
21:36:51 <shapr> kallisti: Are you a grad student?
21:37:07 <kallisti> junior undergrad.
21:37:11 <shapr> Ah, me too!
21:37:18 <mm_freak> zofodraziw: it sounds like you confused foldl and foldr
21:38:10 <kallisti> shapr: things that are currently missing are maps and folds.
21:38:25 <kniu> hey guys
21:38:27 <zofodraziw> mm_freak: yes, I am sure. I am also quite surprised. I just tried again now to be sure
21:38:28 <kallisti> which would have results that "escape" FSTree
21:38:35 <kniu> what do you call that proof thing where you write a horizontal line
21:38:38 <kallisti> because they no longer represent a filesystem tree.
21:38:45 <kniu> and the stuff on top implies the stuff on the bottom?
21:38:49 <zofodraziw> mm_freak: I was expecting both to output 1,2,3,4,5
21:39:02 <kniu> and what is the name for the set of things on top?
21:39:15 * kallisti is unfamiliar with that notation.
21:39:34 <kallisti> shapr: so currently do a mapM sort of thing you need to call flatten first.
21:39:37 <kallisti> and then mapM on that.
21:39:47 <shapr> Hm, I'll try it.
21:39:47 <rwbarton> without optimizations they both produce 1,2,3,4,5
21:40:00 <shapr> I won't have much feedback until I actually use the code to do something :-)
21:40:43 * kallisti recommends backups.
21:40:44 <kallisti> :)
21:41:10 <kallisti> I did do some bug testing to make sure that the code matches the behavior I was looking for.
21:41:14 <kallisti> but I may have missed something
21:41:16 <shapr> haha
21:41:28 <shapr> I could try writing QC tests.
21:41:39 <shapr> In fact, that's an excellent way to learn a library.
21:41:54 <shapr> tgeeky: Are you trying to autoderive arbitrary and shrink?
21:41:55 <kallisti> I am absolutely terrible at writing tests with a library.
21:41:58 <rwbarton> kniu: sequent
21:42:10 <rwbarton> or maybe a rule
21:42:10 <shapr> I really enjoy writing software tests, especially with QuickCheck.
21:42:12 <kniu> rwbarton, thanks
21:42:15 <ezyang> Inference rule
21:42:17 <kallisti> I typically just play around with my code in ghci until it does what I expect on a bunch of different cases.
21:42:21 <kniu> what about the set of things on top?
21:42:23 <ezyang> A |- B <-- sequent
21:42:24 <kallisti> but constructing those cases in a disciplined way escapes me for some reason.
21:42:27 <rwbarton> sequent is the turnstile thing, right
21:42:31 <rwbarton> Silly logic terminology
21:42:31 <kniu> oh, right
21:42:46 <kniu> premises?
21:42:51 <shapr> kniu: http://en.wikipedia.org/wiki/Rule_of_inference
21:43:13 <shapr> Neat, I didn't know those were called inference rules.
21:43:22 <kallisti> shapr: for moveTo I remove all empty directories. does that make sense?
21:43:38 <kallisti> you may be moving only part of a directory instead of the whole thing
21:43:42 <zofodraziw> mm_freak: any ideas why?
21:43:42 <shapr> kallisti: No, it should keep empty directories.
21:43:55 <kallisti> that doesn't correspond to how I expect move to work in the simplest case though
21:44:02 <shapr> kallisti: Huh? move part of a dir?
21:44:14 <kallisti> moveTo "test2" =<< getDirectory "test"
21:44:26 <kallisti> this moves the whole directory. with that approach there are a bunch of empty directories left behind.
21:44:48 <kallisti> currently moveTo deletes empty directories in the tree.
21:44:52 <kallisti> after the move operation
21:44:56 <kallisti> if they're empty, they disappear
21:45:11 <kallisti> which means in the simplest case you end up with no skeleton directories.
21:45:15 <shapr> Why are there empty directories left behind?
21:45:36 <kallisti> what else would I do?
21:45:47 <shapr> I don't understand something about this.
21:45:57 <kallisti> it's an arbitrary tree of directories and files. I can't just "move the directory"; I have to move each individual file.
21:45:59 <tgeeky> shapr: nope, I don't think so
21:46:02 <mm_freak> kniu, rwbarton: IIRC that's an "inference rule"
21:46:04 <shapr> kallisti: Right, sure.
21:46:12 <tgeeky> shapr: I'm just playing with unfolding and this pi-eta-epsilon (negative-fractional types) paper
21:46:25 <mm_freak> zofodraziw: no, i'm sorry
21:46:33 <mm_freak> the two functions appear to be equivalent to me
21:46:35 <shapr> tgeeky: Oh, was jfischoff auto-deriving arbitrary?
21:46:35 <mm_freak> but…
21:46:39 <kallisti> shapr: imagine you're writing the recursive move code.
21:46:47 * shapr imagines
21:46:48 <rwbarton> zofodraziw: my guess is something to do with strictness analysis
21:46:58 <mm_freak> if you write "1 + (2 + (3 + (4 + 5)))", then the evaluation order is really undefined
21:47:01 <rwbarton> anyways there is no particularly good reason why they should produce the same output
21:47:06 <mm_freak> and the strictness of "+" matters
21:47:06 <kallisti> you have an arbitrary filesystem subtree. The only way to do it in a general way is to move each individual file.
21:47:08 <tgeeky> shapr: yeah, I think he's interested in it
21:47:15 <kallisti> there is no movement of directories.
21:47:29 <kallisti> as a whole.
21:47:35 <shapr> Sure, but why does that leave behind empty directories?
21:47:42 <mm_freak> zofodraziw: for example notice the subtle difference between the two functions that for the first function the /result/ depends on the trace
21:47:47 <kallisti> because moving every file in a directory doesn't delete the directory?
21:47:53 <mm_freak> for the second function the trace is forced earlier
21:47:59 <kallisti> (with my implementation it does)
21:48:08 <mm_freak> that's the subtle difference between "f !x = y" and "f x = x `seq` y"
21:48:10 <shapr> Wouldn't deleting a directory be part of a move of that directory to some other name or location?
21:48:16 <kallisti> (because I do that as a special case; if the directory is empty after the move operation, I delete it)
21:48:29 <kallisti> shapr: you're not moving directories
21:48:37 <kallisti> an FSTree can contain arbitrary subsections of a directory
21:48:42 <shapr> Why wouldn't it be empty after a move? error? lack of permissions?
21:48:51 <mm_freak> zofodraziw: and yes, that actually explains it
21:48:52 <zofodraziw> mm_freak: why would that result in an inverted printout? I can't seem to wrap my head around that
21:48:53 <kallisti> I don't move the directory, at all, ever.
21:49:23 <kallisti> I create the new directory structure, move the files individually into those new directories, then delete all empty directories in the source location.
21:49:29 <rwbarton> zofodraziw: here is a theory
21:49:33 <shapr> Ok, that makes sense to me.
21:49:38 <mm_freak> zofodraziw: ok, let's use 1 + (2 + 3) as a simplified example…  if '+' is myAdd1, then the expression itself doesn't force anything yet, so the result i expect is 2,1
21:49:43 <rwbarton> ghc cannot see that myAdd1 is strict in y because it cannot see through the trace
21:49:47 <shapr> I thought you were deleting empty subdirs in the 'destination'.
21:49:48 <kallisti> shapr: do you see why deleting the directory isn't implicit to a move operation?
21:49:51 <kallisti> oh. no.
21:50:04 <rwbarton> but in myAdd2, it can see that it is strict because in the first case it returns undefined anyways and in the second case it returns x + y
21:50:16 <kallisti> shapr: it may be the case that someone doesn't want that behavior for some reason.
21:50:19 <kallisti> I don't know.
21:50:19 <shapr> kallisti: Because your source may not be empty if you have an arbitrary subset of the source, right?
21:50:21 <mm_freak> zofodraziw: if it's myAdd2, then the expression itself (the evaluation of (+) itself, not its result) will cause the trace effect
21:50:24 <kallisti> shapr: yes
21:50:33 <shapr> That makes sense.
21:50:35 <kallisti> I'm ultimately dealing with files, not whole directories.
21:50:40 <rwbarton> so when it evaluates myAdd2 1 (myAdd2 2 (myAdd2 3 (myAdd2 4 (myAdd2 5 0)))) it can reduce the inner argument first to save stack space (and generally be more efficient)
21:50:54 <kallisti> though you /could/ have an FsTree that contains only directories
21:51:17 <rwbarton> with -O0 there is no strictness analysis and then myAdd2 behaves as myAdd1
21:51:30 <kallisti> but moveTo would basically create an empty skeleton of the source directory.
21:51:33 <kallisti> in that case.
21:52:06 <luite> is there a strict readFile in the base libs?
21:52:10 <shapr> Bizarre, I've just been thinking in boring unix filesystem terms.
21:52:34 <kallisti> yeah it dawned on me that I can't rely on niceties of posix calls.
21:53:09 <kallisti> without some clever abstraction
21:53:16 <kallisti> that escapes me.
21:53:36 <kallisti> clearly I need to document that behavior fairly well.
21:53:48 <kallisti> copy is pretty straightforward, but move is tricky to make sense of.
21:54:02 <shapr> Yes, document :-)
21:54:24 <kallisti> but in the simplest cases it will work how you expect.
21:54:31 <kallisti> getDirectory "test" >>= moveTo "test2"
21:54:45 <kallisti> works like a mv in *sh
21:54:56 <shapr> I like that.
21:56:22 <kallisti> I'm not even sure if moving arbitrary subsections of a filesystem is a useful operations
21:56:26 <kallisti> copying, sure.
21:58:06 <zofodraziw> rwbarton: I just tried it and it seems you are right. Thanks!
21:58:34 <mm_freak> how would you typeset inference rules in LaTeX?
21:58:45 <mm_freak> using \frac or \array feels wrong
21:58:47 <zofodraziw> mm_freak: It seems that it has to do with the compiler optimizing, as rwbarton said. Mystery solved. Thanks a lot for your help
21:59:10 <kallisti> shapr: some things are not ideal. System.Directory.removeDirectory is actually an all-or-nothing thing. I can't make any guarantees that you're not left with some intermediate state as a result of a single permission error on a file.
21:59:15 <rwbarton> zofodraziw, one thing you can test is replace "undefined" in myAdd2 by something like 0, then i expect the behavior changes
21:59:24 <mm_freak> zofodraziw: yeah, as said the two functions are semantically equivalent…  it your problem shows the danger of side effects in a lazy language =)
21:59:32 <shapr> kallisti: Well, document it and caveat emptor
21:59:53 <shapr> But I'll have more to say tomorrow when I try to generate playlists for my music player.
22:00:12 <mm_freak> the notion of "semantic equivalence" is broken, as soon as you introduce side effects
22:01:26 <kallisti> shapr: yeah at least with this library you can make backups rather painlessly. :>
22:11:30 <shapr> kallisti: I do like that...
22:20:05 <kallisti> what would be a good name for a numeric type with a concept of "truth"
22:20:16 <kallisti> like a C integer or a scripting language number.
22:20:32 <ziman> mm_freak, there are several packages, for example bussproofs
22:20:41 <kallisti> I was thinking TruthyNum. :)
22:20:54 <ziman> mm_freak, for typesetting inference trees, that is
22:27:42 <mm_freak> kallisti: IntAndBoolAtTheSameTimeBecauseMyLanguageSucks
22:27:48 <mm_freak> ziman: thanks
22:27:53 <kallisti> well I'm pondering a Haskell implementation
22:28:02 <mm_freak> god please no
22:28:04 <kallisti> now that I have an entire library of conditional operators overloaded on a generic Bool conversion typeclass. :)
22:28:10 <kallisti> IT SEEMS LIKE THE NEXT LOGICAL STEP no?
22:28:35 <kallisti> at least it's typesafe. you know what you're getting.
22:29:09 <kallisti> http://hackage.haskell.org/package/cond-0.3  could have TruthList and friends as well.
22:29:15 <kallisti> it'll make the Python programmers happy.
22:29:18 <kallisti> think about it.
22:29:30 <kallisti> *TruthyList
22:32:04 <kallisti> mm_freak: also it would allow me to create a package even more offensive than the ones that already exist.
22:32:09 <kallisti> that's pretty impressive
22:32:31 <mm_freak> it you prefer broken boolean logic over type theory, yes
22:34:07 <mm_freak> kallisti: i don't like it…  i didn't subscribe to static, strong typing just to have all my safety destroyed by unifying Bool with everything else
22:34:27 <kallisti> in a newtype wrapper that explicitly specifies the behavior.
22:34:31 <kallisti> with a silly name.
22:34:35 <kallisti> everything is fine.
22:34:41 <kallisti> all is how it should be.
22:35:09 <Veinor> kallisti: i like Truthy
22:35:40 <mm_freak> kallisti: this is too much hiding of semantics…  it approaches PHP
22:35:53 <mm_freak> if there is any predicate on a list, i want to express it explicitly
22:36:14 <mm_freak> you could call that type PhpStupidity
22:36:32 <kallisti> me too. but it's pretty neat that we can build that kind of behavior from the ground up, and in a very strong static type system.
22:36:51 <kallisti> it would just be a sort of "proof of concept" thing really.
22:37:28 <kallisti> you could probably even do something like Perl junctions.
22:38:22 <mm_freak> if you feel like you die if you don't tell everybody about it, please at least release it as an ACME package
22:38:32 <mm_freak> such that everybody knows that YOU ARE STUPID IF YOU USE THIS
22:39:45 <kallisti> well I'm not entirely sure it satisfies the laws of boolean algebra.
22:39:53 <kallisti> which I've kind of required of these things.
22:40:07 <kallisti> of Boolean anyway, not ToBool
22:40:25 <kallisti> Boolean would give you the Perlish constructs like   $numA || $numB
22:40:25 <mm_freak> you can derive 1 = 2
22:40:27 <mm_freak> so no
22:41:10 <kallisti> how so
22:42:50 <mm_freak> well, you could argue that this derivation is illtyped, but you really just need to see why PHP is broken
22:43:20 <mm_freak> http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/
22:43:26 <mm_freak> see "operators" section
22:43:27 <kallisti> I'm quite familiar with languages that place an inherent boolean contexton all values.
22:43:57 <mm_freak> well, if you can prove transitivity it's probably not that bad
22:44:20 <kallisti> Perl's operators are a bit less broken than this.
22:44:35 <kallisti> by dividing numeric operators from string operators
22:44:48 <kallisti> == is numeric equality, eq is string equality. operands are interpreted as such.
22:45:23 <kallisti> === compares values and type… except with objects, where === is only true if both operands are actually the same object!
22:45:26 <kallisti> whut
22:46:51 <kallisti> oh this article mentions that
22:47:55 <kallisti> actually most of this stuff is explicitly fixed by Perl.
22:48:02 <mm_freak> a combination of dynamic typing and a boolean semantics to everything is always broken
22:48:02 <mm_freak> so perl is no less broken than PHP regarding this
22:48:28 <kallisti> I don't think it's broken. I think we have high standards.
22:48:35 <kallisti> it's unsafe, mostly.
22:50:24 <kallisti> Okay, I lied. There are “SPL types” which also infect variables: $x = new SplBool(true); $x = "foo"; will fail. This is like static typing, you see.
22:50:27 <kallisti> I lol'd
22:51:22 <mm_freak> what's "like static typing" in a dynamic language?
22:51:28 <mm_freak> is there a compiler that complains?
22:51:35 <kallisti> I think it just does runtime checks.
22:51:41 <mm_freak> then it's not static
22:51:47 <kallisti> that was the humor
22:51:47 <mm_freak> may be strong, but not static
22:51:47 <kallisti> ..
22:51:55 <kallisti> it was not meant to be taken literally, I believe.
22:51:57 <mm_freak> i didn't understand that one =)
22:52:16 <mm_freak> anyway, IMO dynamic languages are broken by design…  all of them
22:52:55 <mm_freak> mixed with imperative programming you effectively prevent yourself from being productive
22:52:56 * dabblego high-five
22:53:40 <mm_freak> that's why websites in PHP need half a year to implement and are almost always discovered to be broken after release
22:54:09 <mm_freak> and that's why facebook needs ugly hacks to get somewhere near reasonable performance
23:03:18 <mauke> I don't understand how a boolean typeclass destroys static type safety
23:04:02 <mauke> also, x && y = if toBool x then y else x; x || y = if toBool x then x else y
23:05:07 <mm_freak> mauke: the issue is with type inference…  your program is less specified
23:05:23 <mauke> huh?
23:05:35 <mauke> are you arguing against typeclasses in general?
23:06:31 <mm_freak> no
23:06:46 <mm_freak> but i'm arguing against assigning implicit semantic meaning
23:06:58 <mm_freak> implicit semantics is /the/ source of bugs
23:07:03 <mauke> I don't get it
23:07:31 <mm_freak> mauke: OverloadedStrings is a good example
23:07:33 <newsham> since bugs are deviation from the spec, the more explicit your spec is the more bugs you have
23:07:41 <mauke> haha
23:07:50 <mm_freak> lol
23:08:14 <mauke> mm_freak: and OverloadedIntegers?
23:08:46 <mm_freak> mauke: even though nothing serious i have indeed run into some problems with the overloaded integers of haskell
23:09:06 <mm_freak> run-time bugs because something supposed to be Integer was in fact an Int
23:09:17 <mauke> is Functor ok?
23:09:30 <mm_freak> yes
23:09:50 <mauke> what's the difference?
23:10:05 <mm_freak> the difference is that "fmap" is not put in front of something implicitly
23:10:28 <mauke> the same thing applies to toBool
23:11:07 <mm_freak> i'm saying that if there is some semantics that allows going from a list of strings to a boolean i want to be explicit about them
23:11:33 <mm_freak> Truthy is either dangerous or useless
23:11:57 <mauke> toBool is explicit
23:12:14 <mm_freak> what does toBool do for [(Char, [String])]?
23:12:19 <ziman> do you mean that the conversion to Bool is kind-of arbitrary, while fmap is a rigid categorical concept?
23:12:22 <mauke> not . null
23:12:57 <mm_freak> mauke: are you sure?  why wouldn't it check that none of the strings of the second components contains a permutation of "abcd"?
23:13:11 <mm_freak> "toBool" is so vague that it's effectively PHP
23:13:19 <mm_freak> ziman: exactly
23:13:22 <mm_freak> that's my point
23:13:31 <mm_freak> toBool is vague and the conversion is arbitrarily chosen by the author
23:13:38 <mauke> I see your point but I don't agree
23:14:11 <mauke> data [] a = [] | (:) a ([] a)
23:14:16 <mauke> data Bool = False | True
23:14:35 <mm_freak> mauke: what's true?  Left or Right?
23:14:36 <mauke> associating [] with False seems natural to me
23:14:58 <mauke> mm_freak: good question. I'm not sure I'd define an instance for that
23:15:02 <mm_freak> what's true?  Leaf or Branch?
23:15:02 <mauke> but if anything, Right = True
23:15:21 <mm_freak> i see how Right = True feels right, but it's arbitrary
23:15:27 <mauke> generalizing from lists, empty = false
23:15:34 <mm_freak> Either by itself is just "+" on types
23:16:29 <mm_freak> and i don't really subscribe to the idea that [] must be false, just because of the order the constructors are enumerated in
23:17:06 <mauke> wasn't [] = false in lambda calculus?
23:17:48 <mauke> > "ab" `mplus` "cde"
23:17:49 <lambdabot>   "abcde"
23:18:02 <mm_freak> mauke: that's arbitrary
23:18:17 <mm_freak> \t f -> f is just as valid as \f t -> f for booleans
23:19:18 <mauke> my mind tells me you're right but my heart is still with perl
23:19:25 <ziman> instance Truthy (Bool -> Bool -> Bool) where toBool f = f True False
23:19:27 <ziman> :)
23:19:29 <mauke> yay, preconceptions
23:19:40 <mm_freak> hehe
23:20:26 <mm_freak> if anything my instance for [] would be:  instance (Truthy a) => Truthy [a] where toBool = all toBool
23:20:46 <mm_freak> for which toBool [] is actually True
23:21:05 <mm_freak> and then i'd call that class All, not Truthy
23:21:39 <mauke> what would you call my proposed || for lists?
23:22:28 <mm_freak> no idea
23:23:24 <mauke> this is all lisp's fault, of course
23:24:02 <mm_freak> hehe
23:24:15 <hpaste> mmcdermo pasted “Javascript EDSL Phantom Type Issues” at http://hpaste.org/68371
23:24:26 <mmcdermo> So, I'm looking for any design suggestions
23:24:46 <mmcdermo> Basically I'm using phantom types to add type-safety to some values that contain javascript chunks (text)
23:25:01 <mmcdermo> But that leads to the issue of not being able to mappend them together easily
23:31:36 <ziman> mmcdermo, does mappend need to be recursive? isn't that just string concatenation?
23:32:30 <ziman> I mean, inside.
23:32:32 <ziman> how about creating (><) :: Val Expression a -> Val Expression b -> Val Expression b; Val l >< Val r = Val (l ++ ";\n" ++ r) ?
23:33:13 <mmcdermo> ziman: Here it is, yeah. In the actual EDSL I have a slightly more complex type Val part typ = { str :: Text, dependencies :: DepType, definitions: DefType }
23:33:29 <mmcdermo> But the (><) operator suggestion would work just as well!
23:34:45 <mmcdermo> Also, stirring the pot...
23:34:58 <mmcdermo> Opinions on wrapping things in WriterT just to gain access to do notation =D?
23:35:31 <kallisti> mmcdermo: there's nothing particularly offensive about WriterT
23:36:16 <kallisti> but if you want to do something "just to gain access to do notation" I would use Identity or something.
23:36:21 * kallisti has no context btw
23:36:41 <mmcdermo> kallisti: mmcdermo pasted “Javascript EDSL Phantom Type Issues” at http://hpaste.org/68371
23:37:24 <kallisti> mmcdermo: oh so it outputs Javascript
23:37:28 <mmcdermo> kallisti: Glad it's not an offensive notion
23:37:39 <kallisti> I'm somewhat confused as to why mappend places ;\n betwen its terms.
23:37:43 <mmcdermo> kallisti: Yep just concatenating javascript chunks
23:37:43 <killerstorm> hi. I'm interested in topic of implicit parallelization. As I understand, pH ("parallel haskell") implements it, in a same way it was implemented in Id, but I really do not understand how it works, what it is able to do, how it controls side effects and so on. Can somebody recommend a good article on this topic? (It doesn't need to be about Haskell, any language will do -- I'm just interested in concept)
23:38:10 <mmcdermo> kallisti: Well the idea is that only declarations would get mappended (ie) alert("foo") but not "foo"
23:38:12 <kallisti> mmcdermo: I think a better approach would be to use a custom abstract data type. instead of dealing explicitly with javascript chunks and some weak phantom typing.
23:38:21 <mauke> @where dph
23:38:22 <lambdabot> http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
23:38:34 <killerstorm> I know that SPJ said that implicit parallelization didn't work very well, unlike data parallel stuff, but data parallel isn't as exciting
23:38:39 <kallisti> mmcdermo: and then you could use a monad to chain together statements with \n; and such
23:38:43 <mmcdermo> kallisti: I've been waiting for such a response =p
23:39:12 <mmcdermo> kallisti: Would you put this together with GADTs or just ADTs
23:39:36 <kallisti> I'm not entirely sure. Most likely GADTs I guess.
23:39:42 <kallisti> but it may not be necessary.
23:39:52 <kallisti> you could have a declaration seperate from an expression, for example.
23:40:01 <kallisti> no need to make a distinction via phantom types there.
23:40:56 <kallisti> I would just start with an ADT and then change to a GADT if you need it.
23:41:01 <mmcdermo> kallisti: Fair point; ab tthe separation of declarations from expressions
23:41:18 <kallisti> yeah those are just different ADTs
23:41:25 <mmcdermo> kallisti: my struggle was forseeing how I would allow a function to take either a declaration or an expression as an argument without.. well an Either
23:41:41 <kallisti> first of all, why can functions accept declarations?
23:41:48 <kallisti> wouldn't that make the declaration an expression?
23:42:02 <mmcdermo> I was having that debate as well; but consider that in JS
23:42:11 <mmcdermo> ehh lost my example mid way
23:42:26 <mmcdermo> the primary reason is for filling in function bodies etc
23:42:39 <mmcdermo> one sec while I check why I needed to accept either expressions or declarations
23:42:53 <kallisti> oh are you talking about anonymous blocks?
23:42:57 <mmcdermo> Ahh here we go
23:43:04 <mmcdermo> Yeah anonymous blocks were a little tricky
23:43:07 <mmcdermo> the real place I used it was here
23:43:13 <mmcdermo> $("#mySelector) is an expression
23:43:19 <mmcdermo> $("mySelector").hide() can be either
23:43:30 <kallisti> I guess I should be asking what the use is for this library. because the usage would partially determine the complexity.
23:44:09 <mmcdermo> kallisti: Mostly learning, but also because I'd like to be able to write JS from a higher level
23:44:21 <mmcdermo> I figured the best place to start would be a highly composable EDSL type thing
23:44:35 <kallisti> if your goal is a sophsticated Javascript EDSL then I would go with a full abstract syntax tree.
23:44:57 <mmcdermo> kallisti: Would certainly aid in my pursuit of learning
23:45:18 <kallisti> well, it seems as though an option for declarations is "an arbitrary expression", no?
23:45:26 <kallisti> maybe I don't really understand the distinction
23:45:59 <mmcdermo> kallisti: That sounds more precise
23:46:40 <mmcdermo> the real goal was simply to catch at compile time, for example, having a string etc at the top level
23:46:53 <mm_freak> is there any difference between "thunk" and expression tree node?
23:47:12 <mauke> mmcdermo: like 'use strict'; ?
23:47:30 <kallisti> mm_freak: I believe there's a significant difference performance-wise.
23:48:56 <kallisti> mmcdermo: but yeah it looks like declarations are a monoid rather than a monad.
23:49:00 <mmcdermo> mauke: Yet another wonder of JS =D. I'd have to do some tweaking to allow that
23:49:29 <kallisti> you can't just wrap it in WriterT and get a Monad. the Monad instance for WriterT requires a Monad constraint on the inner monad.
23:49:57 <kallisti> do syntax isn't much of a win. you can just use lists.
23:50:05 <kallisti> mconcat, for example.
23:50:07 <mmcdermo> kallisti: Good to know; had only done some preliminary investigation
23:50:19 <kallisti> mconcat [declaration1, declaration 2, ...]
23:50:24 <kallisti> with identiation this is pretty reasonable.
23:50:39 <kallisti> but I think Expressions could possibly form a monad, since they have a result.
23:50:46 <mmcdermo> I agree; also much clearer what's going on under the hood
23:50:58 <kallisti> but I don't know if you need to do that. if you're just compiler JS rather than executing it, there's no need for IO.
23:51:15 <kallisti> *compiling
23:52:10 <mmcdermo> Yeah if I needed IO that'd be necessary... Hmm
23:52:37 <kallisti> I guess there's nothing wrong with the current representation. except that it seems difficult to manipulate in any structured way
23:52:45 <mm_freak> i see
23:52:53 <mmcdermo> Sort of misses the "composable" goal :)
23:53:22 <mmcdermo> Not entirely, but certainly doesn't do heavy lifting for you
23:53:44 <kallisti> mmcdermo: are you aware of the various JS backends for Haskell compilers?
23:54:01 <osa1> I'm trying to match strings that laid to multiple lines in the source with alex, "@string = . # [\"]" macro doesnt work, can anyone help me? shouldn't "." match every character?
23:54:01 <kallisti> there's a lot of work that needs to be done in terms of foreign function interfaces though.
23:54:12 <mmcdermo> kallisti: Looking at recent news in that aarea inspired me to investigate this actually
23:54:43 <osa1> whoa, I've replaced "." with "[. \n]" and now it works. whatever.
23:54:48 <mmcdermo> kallisti: I don't have a massive amt of experience with Haskell but I do know that I much prefer haskell to writing JS
23:55:11 <kallisti> mmcdermo: btw <> is in the latest version of Data.Monoid in base
23:55:42 <mmcdermo> kallisti: Awesome; that'll save me defining the operator
23:55:48 <kallisti> so to be safe you'd want to do an explicit export list on Data.Monoid
23:56:01 <kallisti> [to avoid importing (<>) and creating an ambiguous name error at compilation
23:56:09 <mmcdermo> Annndd yes that'd be quite necessary - Thanks for the heads up!
23:56:11 <kallisti> or maybe a CPP could fix that.
23:56:33 <kallisti> explicit export lists in general are good ideas.
23:57:08 <mmcdermo> Good to know; This is a fine example of why they're necessary
23:57:23 <mmcdermo> I hadn't thought about it much
23:57:48 <mmcdermo> I can see how a nice interface could be created to a full abstract syntax tree representation, using template haskell
23:58:03 <mmcdermo> but I'm having a little trouble pondering how it'd be done nicely without it
23:58:30 <mmcdermo> http://hackage.haskell.org/package/HJScript-0.5.0 is a pretty thorough template haskell implementation for ex
23:58:53 <mmcdermo> Suppose it's research time =)
