00:03:26 <teneen> edwardk: Thanks
00:03:33 <str4nger> hello, just came over from http://tryhaskell.org/
00:03:47 <dmwit> welcome
00:06:03 <yitz> edwardk: i looked inside the pdf. it's all bmp images, no text.
00:06:37 <yitz> i.e. each page is rendered as one big bitmap
00:06:38 <edwardk> yitz: guess i'll go back to using keynote
00:07:54 <yitz> or at least make them pngs or jpegs or something
00:08:19 <edwardk> well, that was what it spat out when i exported =/
00:09:43 <yitz> or use OOo or libreOffice. a little more clunky, but you'll get something useful when you export.
00:10:14 <edwardk> yeah, for this i wound up needing the tree structures, which is why i bothered with powerpoint
00:10:30 <dmwit> You have no idea how much better Keynote/PowerPoint are than the OO offerings.
00:10:52 <edwardk> i don't enjoy generating them through graphviz and the various OO alternatives
00:10:56 <yitz> dmwit: yeah i know, they're very clunky
00:11:32 <yitz> edwardk: you could lay out the pages in inkscape. it's a lot more work, but then you end up with svgs.
00:11:50 <edwardk> the problem is 'a lot more work' =)
00:11:56 <yitz> yep
00:12:04 <dmwit> These are advices for people who don't Get Things Done. =P
00:12:23 <edwardk> i spent several hours putting together the slides i have there, wasting a week on a less efficient process doesn't really appeal ;)
00:12:46 <yitz> dmwit: that's the logic for just make sure to use Windows and keep everything inside Office. unfortunatey, there is something to that.
00:13:23 <edwardk> yitz: well, those were at least put together on a mac, though admittedly with office. mostly because keynote's supports for building diagrams is pretty rudimentary
00:13:27 <dmwit> Well, if you want a serious offering, I would say beamer is quite usable.
00:13:49 <dmwit> It is not egregiously hard to use, produces good-looking output, and doesn't suck at exporting to PDF.
00:14:20 <edwardk> that's not a bad idea. especially for some of my more formula heavy presentations
00:14:23 <dmwit> There is a bit of investment to learn tex/beamer if you haven't already, but at least it's a one-time cost instead of an every-time cost.
00:14:43 <edwardk> yeah, i've just already invested the time in learning powerpoint/keynote ;)
00:14:50 <dmwit> right
00:15:08 <edwardk> heck, there is pandoc. i just want it to not look terrible =P
00:15:11 <alang> i sort of have to re-learn beamer every time i use it
00:15:13 <dmwit> haha
00:15:33 <yitz> edwardk: we're working on a powerpoint plugin for the dita-ot. then you could write your slides in dita, and publish to ppt, pdf, html, etc.
00:18:04 <edwardk> yitz: i used to have to programmatically generate powerpoint slides for tracking books for defense programs, so i got pretty comfortable with all the minutiae you can use. i'll probably hold off until something comes along that is clearly superior at "getting stuff done". =/
00:18:19 <edwardk> to paraphrase dmwit
00:18:49 <edwardk> i have lots of bad habits. dolio cries a little inside every time he sees me abuse vim
00:20:17 <yitz> edwardk: i often have an emacs window and a vim window open at the same time, then start mixing up their keystrokes. as bad as that?
00:21:15 <yitz> how to page down: go into visual block mode, go back out, then hit ^f.
00:21:18 <edwardk> yitz: i have a tendency to mix and match os cut and paste with vim cut and paste, flit between a dozen or so vim windows, and have some pretty long keystroke sequences that are obviously suboptimal that i use over and over again
00:21:42 <edwardk> :10000000  as go to end of file is the one that makes him cry the most
00:21:50 <yitz> haha
00:22:16 <yitz> edwardk: you should save that in a register
00:22:27 <edwardk> or just hit G
00:22:29 <yitz> edwardk: you can name the register 'G'
00:22:59 <dmwit> that sounds like a migration plan
00:23:15 <dmwit> first retrain from :1000000 to :^RG
00:23:20 <dmwit> then to just G
00:23:38 <yitz> dmwit:  kind of like how to quit smoking
00:24:08 <dmwit> How to quit smoking: first make a macro that smokes for you?
00:24:15 <yitz> that's it!
00:24:21 <vertue> I need some help with a Haskell error...
00:24:31 <dmwit> vertue: You're in the right place!
00:24:32 <dmwit> ?hpaste
00:24:32 <lambdabot> Haskell pastebin: http://hpaste.org/
00:24:39 <edwardk> i know mentally that G is there. I just never use it ;)
00:25:00 <yitz> edwardk: perhaps because you're using a dvorak keyboard?
00:25:06 <vertue> how do I use that ?
00:25:07 <greymalkin> edwardk: If it helps, G works in less as well..
00:25:20 <edwardk> yitz: not any more
00:25:36 <dmwit> vertue: Copy and paste the code that isn't working (and the error message) into the text box, fill in the stuff above, hit submit.
00:25:41 <greymalkin> So... getting to the 'EXAMPLES' section of any man page.
00:25:50 <edwardk> go to hpaste.org, paste your problem, and then it'll pop up a message here so folks can read it
00:26:05 <hpaste> rr pasted “Hakell error” at http://hpaste.org/69325
00:26:21 <edwardk> greymalkin: so does :100000 ;)
00:26:28 <vertue> ok just pasted it as rr
00:26:32 <greymalkin> Yeah, but it has a different meaning in less.
00:26:49 <edwardk> gets you there ;)
00:26:54 <vertue> M is  Math.Statistics
00:26:58 <greymalkin> But I'm still trying to grok why on earth you'd use both vim and emacs.
00:27:01 <greymalkin> at the same time.
00:27:09 <yitz> that's the other thing. i flipflop between view and less, mixing up those keystrokes as well.
00:27:11 <edwardk> greymalkin: one word 'agda'
00:27:23 <dmwit> vertue: At a guess: you can only take the mean of lists, and filteredData is a list of lists.
00:27:24 <greymalkin> I would have to take a good 10-20 minutes to think of a way to more thoroughly confuse my own brain.
00:27:28 <dmwit> vertue: Use map or concat.
00:27:57 <vertue> sorry you are right...
00:28:06 <vertue> I mistyped
00:28:08 <dmwit> vertue: The error message *nearly* says this: it says it got a slightly deeper-ly-nested list than it was expecting.
00:28:18 <vertue> aPlot = map M.mean (transpose filteredData)
00:28:26 <vertue> still give same error
00:28:31 <yitz> greymalkin: basically, i'm trying to gradually get better at vim, but there are still a lot of things i can only do in emacs.
00:28:38 <vertue> filteredData is [[Float]]
00:28:40 <vertue> oops
00:28:46 <vertue> I mean [[[Float]]]
00:28:55 <greymalkin> Hehe. So you're travelling the opposite direction from me
00:29:12 <dmwit> vertue: Alright, then add one to every number in my sentences above.
00:29:13 <greymalkin> I finished my vim -> emacs transition just a few months ago.
00:29:30 <yitz> greymalkin: one of these days i'll give up and just go back to teco
00:29:39 <dmwit> vertue: map M.mean works on lists of lists of numbers, but filteredData is a list of lists of lists of numbers.
00:29:47 <dmwit> vertue: Use map or concat.
00:30:08 <vertue> thanks will try that...
00:30:30 <vertue> what confused me though is that maximum worked.
00:31:18 <yitz> > maximum [1,3,5,7,9]
00:31:19 <lambdabot>   9
00:31:35 <yitz> > maximum [[1,3],[5,7],[9,11]]
00:31:36 <lambdabot>   [9,11]
00:31:48 <dmwit> yitz: only in \bot, though =)
00:32:00 <dmwit> oh wait
00:32:03 <dmwit> Not only in \bot.
00:32:05 <dmwit> :t maximum
00:32:06 <lambdabot> forall a. (Ord a) => [a] -> a
00:32:09 <dmwit> aaaa
00:32:13 <dmwit> lol
00:32:41 <dmwit> > maximum [[10000,0],[0,1000],[0,2000]]
00:32:41 <yitz> dmwit: it works with tuples, too. :)
00:32:41 <vertue> what does that mean for the noob in the corner?
00:32:42 <lambdabot>   [10000,0]
00:33:03 <dmwit> vertue: Lists are ordered (lexicographically).
00:33:09 <dmwit> vertue: ...but lists are not numbers.
00:33:14 <dmwit> compare:
00:33:16 <dmwit> :t maximum
00:33:17 <lambdabot> forall a. (Ord a) => [a] -> a
00:33:24 <greymalkin> vertue: maximum doesn't just work on [Float], but also [[Float]] and [[[Float]]]
00:33:24 <dmwit> :t \xs -> sum xs / fromIntegral (length xs)
00:33:25 <lambdabot> forall a. (Fractional a) => [a] -> a
00:33:34 <greymalkin> and all derrivations thereof
00:34:08 <dmwit> :t maximum . map (map id)
00:34:09 <lambdabot> forall a. (Ord a) => [[a]] -> [a]
00:34:22 <dmwit> :t (\xs -> sum xs / fromIntegral (length xs)) . map (map id)
00:34:23 <lambdabot> forall a. (Fractional [a]) => [[a]] -> [a]
00:34:35 <dmwit> ...yes, techically correct.
00:34:48 <dmwit> But even more confusing for new Haskellers. =P
00:36:53 <vertue> yep...
00:36:53 <vertue> and they are hanging on by their fingernails as is :-)
00:36:53 <vertue> thanks a lot for the help
00:36:53 <dmwit> Yeah, you should ignore my last two experiments. But the previous ones and greymalkin's explanations are good.
00:36:54 <dmwit> You should ask questions if any part of those was unclear.
00:36:54 <vertue> now I need to figure out how to get mean to behave like maximum...
00:36:54 <vertue> cause if I map . map it it does not give me the answer i need
00:36:55 <yitz> vertue: what do you want the mean of [[1,3],[9,10]] to be?
00:37:15 <dmwit> We can help you, but not unless you tell us what the function you're trying to write should do. =)
00:37:19 * dmwit -> bed
00:37:46 <vertue> [5, 75]
00:37:57 <vertue> oops I mean[5,6.5]
00:37:59 <yitz> now *i'm* confused
00:38:32 <alang> vertue: what about the mean of [[1],[]]?
00:38:36 <yitz> ah. ok. so then what about [[1,3],[9,10,15]]?
00:38:56 <yitz> right, even better what alang asked
00:38:57 <vertue> alang: error
00:39:19 <vertue> yitz: error
00:39:43 <greymalkin> vertue: Can you use a tuple instead of a list?
00:39:59 <vertue> I'd rather not...
00:40:06 <greymalkin> [ (1, 3) (9, 10) ]
00:40:16 <greymalkin> Because then you can easily do something like this:
00:40:18 <yitz> vertue: well, without the error, you can do map mean . transpose
00:40:36 <greymalkin> > unzip [(1,3), (9,10)]
00:40:37 <yitz> vertue: if you really need the error, check separately that the lists are all the same length
00:40:37 <lambdabot>   ([1,9],[3,10])
00:40:42 <vertue> Ah - an inner transpose
00:41:00 <vertue> that might just work
00:41:23 <vertue> SQL takes care of the input
00:41:32 <vertue> so I know it will always be square
00:41:33 <yitz> > let mean xs = sum xs / fromIntegral (length xs) in map mean . transpose $  [[1,3],[9,10,15]]
00:41:37 <lambdabot>   mueval-core: Time limit exceeded
00:41:38 <greymalkin> Then it's just a matter of allMeans (x,y) = (mean x, mean y)
00:41:52 <yitz> ?
00:41:54 <yitz> > let mean xs = sum xs / fromIntegral (length xs) in map mean . transpose $  [[1,3],[9,10,15]]
00:41:56 <lambdabot>   [5.0,6.5,15.0]
00:42:08 <vertue> perfect
00:43:08 <vertue> thanks a lot
00:46:50 <teneen> Since [x,y,z,w] is just syntactic sugar for (x:y:z:w:[]). Why was the (:) operator not just a "smart constructor" for the List datatype (for which it's constructors are not exported) so that the list data type includes the length within it?
00:47:11 <c_wraith> teneen: because not all lists have a length
00:47:22 <c_wraith> > let x = 1 : x in x
00:47:23 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
00:48:09 <edwardk> teneen: what is the length of fix (1:)
00:48:14 <edwardk> > fix (1:)
00:48:15 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
00:48:24 <shachaf> Even for lists that *do* have a length, you don't always know it, or want to know it.
00:48:36 <shachaf> Knowing it involves doing a bunch of work you might not need to do.
00:48:49 <roconnor> edwardk: the lenght is fix S
00:48:54 <teneen> So if the language was strict, what I just said will be meaningful?
00:48:57 <edwardk> you can make a strict list with a memoized length, thats fine
00:49:01 <edwardk> teneen: yes
00:49:11 <edwardk> teneen: then you have other problems of course ;)
00:49:18 <edwardk> because you need mutability just to tie the knot
00:49:34 * hackagebot hspec 1.1.1 - Behavior Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.1.1 (SimonHengel)
00:49:43 <edwardk> and so the representations of data structures becomes much more visible
00:49:52 <roconnor> ocaml lets you tie static knots without mutability
00:50:03 <shachaf> A strict language could -- yes, what roconnor said (I think).
00:50:26 <roconnor> but static knots are less fun than dynamic knots
00:51:09 <teneen> Laziness is much more fun
00:51:12 <yitz> edwardk: it could be a lazy type too. just be careful not to examine the length parameter when the list might be infinite. just like for regular lists.
00:51:25 <teneen> not only in programming languages :P
00:51:28 <edwardk> roconnor: ocaml lets you do lots of things, most of the time, it lets you do basically anything if you do it through a record ;)
00:52:18 <edwardk> yitz: even so you change space performance
00:52:24 <yitz> yes
00:52:24 <roconnor> edwardk: ocaml 3.12 now lets you do things without using records.
00:52:36 <edwardk> woot
00:52:49 <edwardk> my recollection was to try something and if it didn't work, jam a record in the middle
00:52:57 <roconnor> edwardk: yes, it was
00:53:06 <edwardk> so i'm glad to hear they've worked on improving the degeneracy of the rest of the type system ;)
00:57:10 <roconnor> http://stackoverflow.com/a/5811281/727983
00:58:37 <edwardk> yeah i've done the cheesy ocaml knot tying. every time i do i feel guilty and look around to see if anybody noticed
00:59:27 <shachaf> Common Lisp also lets you do it without mutation.
01:00:33 <flux> bonus points for them not using Obj.magic (ie. unsafe casting)
01:00:36 <womb> hi guys
01:00:54 <edwardk> i just love how scheme's letrec tries so hard to keep you from seeing the initializing #f's, before failing miserably..
01:02:29 <shachaf> For that matter, C has struct Node n = {.val=5,.next=&n};
01:20:44 <fmap> Is there any way to convert `A' to `Q Exp' where `data A = A (a → b)'?
01:21:20 <fmap> Tutorials I
01:22:02 <fmap> 've found so far suggests converting a → b to something for what Data.Typeable and Data.Data could be derived.
01:22:13 <fmap> suggest*
01:41:56 <adamt> https://github.com/olegkat/haskell-memcached seems to be the newest memcached-library, but it's marked as alpha and no updates in two years.
01:42:10 <adamt> Am i missing something?
01:44:51 <c_wraith> mostly that most people have stopped using memcached
01:44:57 <womb> you will store cache in memcached ?
01:45:10 <path[l]> what do they use now? redis?
01:45:13 <womb> nowadays redis is popular and fancy
01:45:28 <c_wraith> redis is the most popular option these days, at least
01:45:30 <t7> c_wraith: try hitting your database a gazillion times a second look google
01:45:49 <c_wraith> t7: I didn't say people have stopped using caches.
01:45:53 <womb> well hitting google is not hitting one db first of all :)
01:47:07 <womb> first you hit loadbalancer who will give you one of the servers from pool then you will get either cache or you will hit db with cached tags
01:47:15 <womb> next you will get your results
01:47:58 <adamt> and before that you get served random dns entries. irrelevant discussion though. :P
01:49:04 <womb> but its a good topic to dig in! thanks mate.
01:49:05 <adamt> c_wraith: http://redis.io/clients lists 3 haskell clients, do you know whether one is better than the others, or is it just a matter of taste?
01:49:17 <t7> if your database doesnt fit in ram you need to refactor your project
01:49:19 <c_wraith> adamt: we've been using hedis.
01:49:38 <womb> t7: :D
01:51:09 <hvr> c_wraith: I wonder if something like redis could be implemented with GHC Haskell w/o suffering from signfikant GC  overhead
01:51:53 <t7> could allways handle memeory yourself with malloc et al
01:54:13 <hvr> t7: well, but then you'd have to implement a C-represention of all basic types supported by the redis data-model...?
02:01:57 <t7> i need a datatype that generates a unique identifier everytime i add something to a Set
02:02:03 <t7> does that exist allready?
02:05:28 <burbul> Couple of days ago I was floating around here and got told not to use Show for pretty printing...
02:05:43 <burbul> Is there a type class that is meant for pretty printing, or should I just roll my own?
02:06:29 <burbul> t7: can you not use the size of the set?
02:06:48 <t7> burbul: what if i remove an element?
02:06:50 <burbul> ah
02:06:57 <burbul> sorry, thought it was only growing
02:07:03 <mm|swarm> burbul: as far as I know there is no class for this
02:07:11 <mm|swarm> but I may be wrong
02:07:13 <burbul> mm|swarm, thanks
02:07:39 <mm|swarm> usually i use a Show instance to show as many fields as possible from a data structure
02:07:41 <burbul> Is not hard to roll my own, just seemed best to use a standard one if it was there. (Little surprised it isn't.)
02:07:56 <burbul> Well, I'm displaying all the information in the current Show, but
02:07:59 <greymalkin> t7, there's a section in learn a haskell on monads which talks about making a log as you go -- you could then hash the log.
02:08:01 <burbul> Not necessarily which constructor
02:08:09 <mm|swarm> while I create PPrint instances for dusplaying only what I need to display
02:08:19 <burbul> hashing a log seems relatively slow
02:08:24 <mm|swarm> PPrint being rolled on its own
02:08:29 <burbul> You could hold an int (via StateT Int ...)
02:08:31 <mm|swarm> i use the show for debugging via ghci
02:08:39 <burbul> and then increment the int every time you perform an operation
02:08:51 <burbul> Then wrap the whole thing in a datatype
02:08:58 <t7> yeah but it might get huge
02:09:03 <burbul> why?
02:09:11 <burbul> an int is four bytes
02:09:18 <burbul> And you only have to hold onto one of them
02:09:19 <t7> after a gazillion operations
02:09:24 <burbul> You will still have one int
02:09:34 <t7> yeah but element 0 might still be in use
02:09:35 <mm|swarm> add strictness :)
02:09:40 <t7> after wrapping around
02:09:44 <burbul> ah, sorry...
02:09:45 <t7> i mean overflow
02:10:17 <t7> i will just use State, its easier
02:10:19 <t7> :)
02:10:24 <t7> and Integer
02:10:31 <burbul> yes
02:10:31 <t7> webscale!
02:10:46 <burbul> I was just trying to look up the name of the bignum
02:10:50 <fmap> @hackage monad-supply
02:10:50 <lambdabot> http://hackage.haskell.org/package/monad-supply
02:11:05 <fmap> t7: maybe this can be useful?
02:12:01 <burbul> What does showsPrec do? Clearly something to do with precedence...
02:12:27 <burbul> nm, found it
02:12:53 <t7> @hoogle Char -> Bool
02:12:54 <lambdabot> Data.Char isAlpha :: Char -> Bool
02:12:54 <lambdabot> Data.Char isAlphaNum :: Char -> Bool
02:12:54 <lambdabot> Data.Char isAscii :: Char -> Bool
02:13:21 <mm|swarm> @hoogle a -> String
02:13:22 <lambdabot> Network.BufferType buf_toStr :: BufferOp a -> a -> String
02:13:22 <lambdabot> Prelude show :: Show a => a -> String
02:13:22 <lambdabot> Text.Show show :: Show a => a -> String
02:13:46 <mm|swarm> yup, there doesn't seem to be anything usable for pretty printing :P
02:15:30 <burbul> I've made my own
02:15:36 <burbul> but thanks!
02:16:44 <burbul> Thank God for the type system of Haskell -- if it weren't for that it would be such a nightmare figuring out which 'show's I needed to change.
02:23:24 <t7> whats the standard name for the person you are talking to or person receiving an order
02:30:28 <fnsoxt> haskell's plugins for vim ?
02:30:39 <MasseR> Yep
02:30:41 <MasseR> ghc-mode
02:30:44 <MasseR> ghc-mod even
02:31:01 <MasseR> And IIRC haskellmode
02:31:06 <MasseR> (Not in my pathogen)
02:31:22 <MasseR> (I'm using it instead of ghc-mod so I should remember, but alas)
02:31:22 <fnsoxt> thx
02:31:43 * mekeor didn't like ghc-mod much.
02:31:51 <MasseR> There is a wiki page for it (or at least used to be), and both of those can be found from github
02:31:57 <MasseR> mekeor: How come?
02:32:00 <gienah> fnsoxt: haskellmode: http://projects.haskell.org/haskellmode-vim
02:32:06 <mekeor> oh, sry. i was talking about emacs… sorry.
02:32:29 <MasseR> mekeor: Same thing basically. ghc-mod is editor agnostic
02:32:35 <MasseR> Or was something wrong with the wrapper
02:33:07 <mekeor> i don't know and i don't mind.
02:33:25 <gienah> ghc-mod supports emacs and vim: http://www.mew.org/~kazu/proj/ghc-mod/
02:35:57 <t7> anyone do NLP in haskell?
02:36:34 <mekeor> NLP?
02:36:53 <potix2> ghc-mod wrapper for vim is here. https://github.com/eagletmt/ghcmod-vim
02:37:47 <fnsoxt> thx,i like it.
02:38:06 <mikkihiiri> natural language processing, probably
02:38:22 <mm|swarm> t7: I'm interested in this
02:38:30 <mm|swarm> in fact, I'm interested in AI in Haskell
02:38:39 <mikkihiiri> http://www.grammaticalframework.org/ I've used this a few times..
02:38:48 <mekeor> is mm|swarm == mm_freak ?
02:39:00 <burbul> :t runIdentity
02:39:01 <lambdabot> forall a. Identity a -> a
02:39:09 <t7> mm|swarm: does a package exist that can strip the verb, subject etc from a text command in english?
02:39:47 <d-snp> mm|swarm: isn't lisp or python/ruby more suitable for AI programming?
02:41:45 <t7> i need part of speech tagging
02:42:24 <mm|swarm> mekeor: nop, we're different persons
02:42:38 <mm|swarm> he answered some of my questions in the past
02:42:51 <mm|swarm> t7: I don't know, I just started :)
02:43:27 <mm|swarm> I'm teaching haskell (as TA) thus I switch easily from one interest to another
02:43:35 <mm|swarm> depending on what the students and the teacher asks
02:43:54 <mm|swarm> d-snp: maybe but the same can be achieved with Haskell
02:44:18 <mm|swarm> at least this is my belief
02:47:04 <mekeor> d-snp: why?
02:47:59 <mekeor> i only know of prolog as a prog-lang suitable for AI.
02:48:00 <d-snp> mekeor: I think they allow for more metaprogramming
02:48:20 <d-snp> maybe I just haven't discovered haskell's metaprogramming features yet
02:48:22 <mekeor> d-snp: ah, hm..
02:48:27 <d-snp> but I think metaprogramming is very important to ai
02:48:33 <mekeor> why?
02:49:06 <kstt> please could someone explain data-lens package numbering policy at http://hackage.haskell.org/package/data-lens ? 2.0.4.1 is mastered by E. Kmett, uploaded on May, 8. However, 2.10.0 is mastered by R. OConnor, uploaded on April, 10 .
02:49:14 <mekeor> d-snp: haskell itself doesn't really have ways for meta-programming. but the extension TemplateHaskell is exactly this.
02:49:32 <d-snp> because in AI you often require your code to change at runtime, which is easier to achieve when your language has metaprogramming features
02:49:40 <d-snp> lisp was designed for AI programming
02:49:57 <mekeor> ah, i see.
02:51:33 <d-snp> but I haven't read into TemplateHaskell yet, so perhaps haskell is very well suited
02:52:39 <d-snp> ah talking about AI makes me want to continue my AI project, which I have pushed all the way to the bottom of my priorities :(
02:54:47 * hackagebot dzen-utils 0.1.1 - Utilities for creating inputs for dzen.  http://hackage.haskell.org/package/dzen-utils-0.1.1 (FelipeLessa)
03:05:06 <depy> guys, how hard to learn is haskell comparing to lisp ?
03:05:36 <depy> assuming I already know basics
03:06:40 <d-snp> how hard to learn is lisp? :P
03:06:58 <adamt> Haskell is a constant learning experience.
03:06:59 <depy> not that hard, but I only know basics :)
03:07:04 <adamt> Lisp is just matching lots of ()'s.
03:08:08 <blackh> depy: I don't know lisp, so I don't know! Anyway, if you want to learn, we'll help you.
03:08:16 <depy> btw, what's main domain for haskell nowadays?
03:08:17 <hvr> adamt: that's like saying that english is just matching a lot of [a-z .?!]
03:08:54 <adamt> hvr: it isn't? :(
03:08:55 <blackh> depy: That's difficult to say, because it's useful in so many areas.
03:09:22 <depy> I thought so
03:10:16 <hvr> adamt: well, don't tell that to people who have wasted years of education getting their English degree =)
03:10:21 <blackh> depy: What particular areas are you interested in?
03:10:56 <adamt> hvr: Reminds me of the episode where Sheldon Cooper trashtalks a french person for getting a ph.d in french litterature.
03:11:11 <hvr> rotfl
03:11:44 <depy> blackh, nothing particular in mind, I just want to learn it to "broaden my horizon" -> to become better programmer and to get a good grasp on functional programming
03:12:28 <blackh> depy: Haskell is quite good for that, because it's always pushing you away from imperative ways of doing things.
03:12:47 <blackh> It doesn't let you "cheat".
03:13:10 <depy> Yes I heard that it's pure and does side effects torugh monads
03:14:14 <blackh> Yeah - exactly so. So I suppose you could say it's the quickest route to learning functional programming.
03:14:24 <depy> it "Learn you a haskell for greater good" a good book to start with?
03:14:35 <blackh> Yes, that's what I would recommend.
03:14:50 <depy> cool :)
03:15:25 <depy> do you guys use any other programming languages ? or do you all write haskell at your job?
03:15:29 <blackh> That book gets you into it quickly, but doesn't get into big examples.
03:15:32 <Boney> I like "real world haskell", but I havn't read learn you a hskell.
03:15:40 <osfameron> LYAH++ # cutesy but not *too* cutesy, and goes along at a good pace
03:15:57 * osfameron froths at the mouth remembering _why's self-indulgent annoying guide to cartoon foxes
03:15:57 <blackh> RWH is more for big meaty examples and detail. LYAH is more about getting your feet wet.
03:16:15 <depy> guess I'll go with LYAH then :)
03:16:26 <Boney> blackh: ah.
03:16:27 <blackh> depy: Haskell is my favourite language by far. I use C++ in my day job, but I am pushing my company into a more functional style.
03:16:48 <depy> blackh, good for you, I can't push anything anywhere here :)
03:17:02 <frerich> blackh: Same here
03:17:17 <Boney> depy: I use Mercury for my day job (it's similar in a number of ways to Haskell), but I also work at a University in programming languages so I'm not exactly representative.
03:17:20 <blackh> I could evangelize functional programming for New Zealand.
03:17:31 <d-snp> osfameron: guide to cartoon foxes? :P
03:17:39 <blackh> I'm one of those people who took up functional programming out of frustration with standard methods.
03:17:45 <Boney> blackh: Hey, I think we might have met,  Steven Blackheath?
03:17:54 <blackh> Boney: Yeah - that's me.
03:17:59 <bas_> we are a small shop, and I write whatever utils/internal apps we need in Haskell
03:18:01 <Boney> <- Paul Bone
03:18:06 <osfameron> d-snp: allegedly it was about Ruby, but it was page after page of cartoon bloody foxes, GRAAARGH
03:18:08 <blackh> Oh, hi there!
03:18:14 <Boney> blackh: we met at LCA a few years ago.
03:18:21 <d-snp> haha, I thought it was awesome
03:18:21 <Boney> I've been worndering how you're doing.
03:18:24 <depy> blackdog, I guess I'm becoming one of those people :)
03:18:26 <blackh> Indeed! That was fun. My first ever public speaking. :)
03:18:26 <d-snp> but then again, I wasn't trying to learn ruby :P
03:19:02 <blackh> depy: I sympathize.
03:19:24 <blackh> Still, I think things are really shifting now. Functional programming is becoming acceptable in polite company.
03:19:31 <Boney> blackh: Yeah, one if my first too,  I've done a lot more public speaking since.
03:19:45 <Boney> blackh: I'm nearly finished my PhD.
03:20:11 <depy> blackdog, I agree yes. Altough I have no idea why right now. It existed for so long... :)
03:20:16 <blackh> That's great! Do you think you got the problem largely solved? It's quite tricky.
03:20:36 <osfameron> d-snp: hah, I guess yeah.  Anyway, that's what I mean about LYAH not being *too* cutesy.  You can kinda skip over a couple of silly sentences, smile at the drawings, and actually learn some Haskell.
03:20:58 <Boney> blackh: In general 'mostly'.  But there's a lot of fine tuning that can be done.
03:21:10 <Boney> there's probably at least another 10 man-years of work in it.
03:21:19 <d-snp> oh depy: I use Ruby at my work, C# at my startup and Haskell for my Bsc thesis, but I guess I'm not very representative ;)
03:21:29 <adamt> Boney: Now you have to admit what you're working on. :)
03:21:40 <Boney> and then some more time until auto parallelisation becomes mainstream.
03:21:45 <Boney> adamt: yeah, just realized that.
03:21:58 <Boney> adamt: feedback directed automatic parallelisation.
03:22:00 <blackh> depy: Multi-core is one reason, but I also think it's basically just your standard paradigm shift life-cycle thing going on.
03:22:29 <blackh> The 1% influence the 5% who then influence the 94%
03:22:39 <d-snp> feedback directed? as in runtime profiling?
03:23:01 <blackh> Boney: I am not surprised. It's a worthy goal, though.
03:23:14 <Boney> d-snp: so far driven by data from the profiler.
03:23:20 <depy> blackdog,  yea, I guess I haven't been even paying attention to functional programming before, maybe that's why it feels so big now all the sudden
03:23:31 <d-snp> didn't microsoft release something like that a short while ago?
03:23:33 <Boney> but you could use dynamic recompilation (like Java) if you wanted quicker turn-arounds.
03:23:54 <blackh> depy: I can bang on about why functional programming is a good idea if you want. :) I'm good at that.
03:24:25 <blackh> In fact, I don't even need a subject!
03:24:30 <Boney> d-snp: not that I'm aware of.
03:24:33 <depy> blackh, I'm already our "your" side, no need to convert me. I was long before I came to this channel. :)
03:24:56 <depy> blackdog, I just haven't had much time to really get to it and master it :)
03:25:00 <d-snp> here this Boney http://msdn.microsoft.com/en-us/library/hh265136(v=vs.110).aspx
03:25:21 <d-snp> I heard of it yesterday, it apparently autoparalellizes (?) c++
03:25:27 <Boney> ta.
03:25:40 <blackh> depy: Jolly good. Well, why don't I save you lots of time and tell you what *isn't* good about Haskell...
03:25:44 <Boney> Yes that's a real word (at least I tell people that it is)
03:25:52 <kstt> does anybody knows if it is supposed to be possible to generate lenses with "makeLenses" for a data type defined in an other module ? I keep having "Illegal binding of built-in syntax" error messages".
03:26:02 <kstt> (package data-lens)
03:26:03 <depy> blackh, that would be nice for a change:)
03:26:12 <d-snp> though, I heard it by word of mouth, now I read it it might be something else
03:26:20 <frerich> blackh: Do you have some thoughts of how to bring functional thinking into an existing team of experienced C++ people? We're a smallish shop with plenty of clever C++ folks (some of which also played with Haskell or Erlang or Lisp). I'm trying to find a way to get *some* benefits of functional programming into our daily routine; unfortunately it's quite a pain in C++.
03:27:37 <frerich> blackh: Many (not quite "most"...) people here agree that functional thinking has its advantages; the problem is not so much the goal, but how to get there. :-}
03:28:03 <blackh> depy: Well, Haskell has a slightly annoying namespace clutter/module naming, but it isn't actually bad. Records are a bit clunky for related reasons. Laziness can take a bit of mastering, and ultimately has to be understood if you want to write big programs. It's still a win but with a cost in terms of extra learning curve. Err... I think that most of it.
03:28:35 <blackh> frerich: I think about this subject a lot, and I think the answer is... FRP a.k.a. Reactive programming.
03:28:37 <Boney> d-snp: ok, that's implicit data parallelism, not explicit parallelism.
03:28:46 <Boney> err, not automatic parallelism.
03:28:59 <hpaste> osa1 pasted “peggy error” at http://hpaste.org/69327
03:29:05 <d-snp> yeah I see now, the person who explained it to me exaggerated slightly ;)
03:29:20 <Boney> d-snp: in my work the programmer doesn't have to change the program.
03:29:24 <osa1> can anyone experienced in peggy help me? I'm getting an "not in scope: v4" error in this peggy parser code http://hpaste.org/69327
03:29:28 <d-snp> I once saw a talk at a university about someone who was researching autoparalellization in haskell, could that have been you?
03:29:53 <Boney> d-snp: DpH is similar and worth looking into.
03:29:59 <depy> blackh, if that's it then I'm sold :)
03:30:18 <Boney> d-snp: that's not to say that this work isn't good or valuable, I only mean that it's different (and has different objectives to my work)
03:30:35 <blackh> depy: Oh, yes, and the lack of decent stack traces is a bit problematic sometimes, but that's being worked on.
03:31:43 <Boney> frerich: I think that your language has to make pure functional programming easy before you'll get people using it naturally.
03:32:04 <Boney> otherwise they're going against the grain of the language and it's more effort.
03:32:32 <frerich> Boney: Hm.
03:33:13 <blackh> depy: There are a lot of good things about Haskell. Once you know it it doesn't feel restricting in any way (in my opinion). The rate of technical innovation in Haskell is breathtaking. A guy I know called Ryan Trinkle described Haskell as "a powderkeg of innovation" and I agree.
03:33:35 <Boney> blackh: I think that monad stacks can be a problem.
03:33:35 <blackh> depy: Purity is HUGE. That can't be overstated, and Haskell is by far the most popular pure language.
03:33:55 <Boney> there are easier non-monadic ways to handle effects.
03:33:56 <depy> are there any other mainstream pure functional languages?
03:34:11 <adimit> there can only be one.
03:34:25 <blackh> depy: No, there aren't. Only Clean and that's not very widely used.
03:34:27 <Boney> depy: Haskell is one of the 2 I'm aware of, and it's by far the most popular.
03:34:53 <blackh> People grumble about "monad creep" in Haskell but I don't find it a problem.
03:35:23 <blackh> frerich: My brother and I are working on FRP implementations in Haskell, C++ and Rust called Sodium.
03:35:27 <Boney> blackh: I think it depends on how well the software was designed, how you're trying to modify it from it's original design.
03:35:31 <d-snp> hmm nvm, the video I saw was also about data parallel things, by spj
03:35:38 * frerich goes to google Sodium
03:35:45 <Boney> blackh: since I've used state variables in Mercury I find monads annoying.
03:35:56 <Boney> (although they're better in some select cases)
03:36:29 <depy> btw, guys, do any of the hyped testing approaches like tdd and bdd apply to functional programming since functions don't have (mostly) side-effects in functional languages?
03:36:41 <d-snp> Boney: the link to the mercury programming language on your website is dead :)
03:36:57 <d-snp> where your website is: http://ww2.cs.mu.oz.au/~pbone/
03:37:00 <kstt> note to roconnor  : I must stick to data-lens 2.0.4.1 because its dependencies accept container 0.5, which is not the case for data-lens 2.9.*
03:37:21 <Boney> d-snp: hrm, we've moved servers around.  Try http://www.mercury.cis.unimelb.edu.au
03:37:30 <blackh> frerich: http://hackage.haskell.org/package/sodium and https://github.com/kentuckyfriedtakahe/sodium (C++)
03:37:41 <blackh> The C++ one is nowhere near completion.
03:37:43 <Boney> d-snp: I'll fix the link, ta.
03:38:07 <frerich> depy: They definately apply to any programming paradigm, including functional programming. However, the stronger the type system, the more the interpreter/compiler can detect at build-time; which in turn lets you write less tests for runtime things. As it happens, Haskell's type system is quite strong. Not so much with, say, Lisp.
03:38:09 <blackh> frerich: I have a working C++ implementation here and agreement from my boss to release it.
03:38:55 <blackh> depy: My personal opinion is that TDD is largely compensation for deficiencies in imperative langauges.
03:39:10 <blackh> Possibly controversial. :)
03:39:57 <frerich> depy: In Haskell programs, I like to think of 'TDD' as 'Type-Driven Development' in which I'm sketching a lot of things just using type signatures and 'undefined'.
03:40:06 <blackh> frerich: Tell me what sort of project your day job is, so I can see if FRP might be useful.
03:40:23 <ptek> blakh, in my opinion, tdd makes one understand the rules much better when writing something
03:41:06 <Boney> depy: IMHO, TDD isn't as useful because a strict type system (especially a H-M type system) saves you from many of the mistakes you might have due to types.
03:41:18 <Boney> In practice I use regression tests only.
03:41:20 <ptek> blackh: we use it extensively in haskell as well - and its a joy to deepen the knowledge of functionality every time a quicktest fails :)
03:41:36 <frerich> blackh: I'm a software engineer working on an automated GUI testing tool; depending on the operating system/GUI toolkit used by the application under test we use different languages. However, the vast majority of the code is C++. Some parts of the code do a lot of work on graphs (say, looking up an object in an object hierarchy or so).
03:42:28 <d-snp> Boney: why would you assume most bugs are solved by a strict type system? (i.e, the most compelling reason for TDD is fixing types?)
03:42:31 <frerich> blackh: There's also plenty of networking code, based on event loops, done. I'm thinking that for this FRP might be good.
03:42:31 <blackh> frerich: Well, basically FRP is essentially a replacement for the observer pattern, or - to put it another way - the observer pattern, but without sucking
03:43:01 <d-snp> oh wait
03:43:01 <blackh> frerich: The problem is that FRP in C++ has seriously ugly syntax.
03:43:20 <d-snp> I'm confused, you were talking about test-driven-development right?
03:43:22 <frerich> blackh: Well that's actually often what it boils down to: the syntax in C++.
03:43:46 <blackh> frerich: But C++11 is actually excellent for functional programming, in spite of the ugly syntax.
03:43:49 <adamt> FRP?
03:44:04 <d-snp> functional reactive programming?
03:44:11 <blackh> adamt: Functional Reactive Programming, which is changing its namely slowly to just Reactive Programming
03:44:13 <Boney> d-snp: yeah, test-driven development.  Because a strong & static type system can catch many bugs, there's less for your test suite to do, makeing it less useful.
03:44:25 <adamt> Aha, thanks.
03:44:46 <frerich> blackh: I had other attempts to introduce functional paradigms into a C++ code base fail because of that. Indeed, C++11 is nice but alas - we have to support gcc 3.0 and upwards as well as MSVC6-11 and more crazy things. The range of compilers to support is so large that most sophisticated C++ tricks aren't acceptable :-}
03:44:56 <blackh> frerich: The problem with event-based programming, as you will be aware from experience, is what I call "state-machine-itis".
03:45:09 <d-snp> Boney: I would not agree at all, I think most bugs are in confused/obfuscated/misunderstood logic
03:45:10 <frerich> blackh: Sure
03:45:25 <blackh> frerich: That is a damn shame, because C++11 is a massive improvement.
03:45:30 <d-snp> which is solved by proper conventions, intuitive language and expressiveness
03:45:36 <d-snp> not strict types..
03:46:05 <frerich> blackh: Not onlymaintaining the state but also people who'd like to make some asynchronous piece of code look synchronous by starting nested event loops (which in turn means that at that point, anything can happen because triggering the event loop does not tell you what the event handlers might do).
03:46:06 <d-snp> and very well checked by good tests
03:46:22 <blackh> frerich: I sympathize.
03:46:49 <Boney> d-snp: I'm not sure,  I agree that logic can't be checked by types and can be checked by tests.
03:47:04 <blackh> frerich: Yes, FRP would help a LOT with that. It _is_ possible to shift your code piece-by-piece to the new paradigm. It works very well.
03:47:17 <Boney> but I'm not sure how often different classes of bugs occur.
03:47:28 <ptek> d-snp: its when you have the type system to support you in reasoning about what data you are dealing with. I remember we had huge troubles with that in ruby - where we'd write tests for types as well
03:47:48 <blackh> frerich: Are people at all frustrated with the bugginess of the code base? You really need that frustration to be present if you want to change the way people do things.
03:48:21 <blackh> frerich: You should also talk to my brother. We both have experience in pushing FRP in different sized teams. His is 50+ people, mine is 2 people.
03:48:30 <blackh> Well, 3 actually - one team leader.
03:48:31 <Boney> One of the things I've noticed is that some people don't use the typesystem effectivly.
03:48:33 <ptek> Boney: in my experience things get messy, when you have to maintain 3 years old codebase, change some logic and don't know what parts of the system are broken afterwards
03:48:41 <frerich> blackh: I guessed so. A year or two ago I tried to port some event-based code (a GUI) using FRP, just as an exercise. Never got around to finishing it, but if there's one thing I got out of it, it's that there's probably often a better solution to event loops. :-}
03:48:46 <d-snp> I think Liskov proved that a strict type system can really be a big problem when designing modular/complex systems
03:48:55 <Boney> I often create an enum type that looks exactly like a boolean, except that the names of true and false will actually describe the situation.
03:49:34 <Boney> I'm then less likly to pass arguments in the wrong orders (since I'd get type errors) and I'm less likly to get "does true mean X or !X" logic errors.
03:49:34 <d-snp> ptek: I haven't encountered such a situation yet, but I can imagine it might happen
03:49:41 <Boney> this is only the simpliest example.
03:50:04 <blackh> frerich: The style of programming you describe can be improved enormously, but it's much, much easier when you have closures.
03:50:20 <frerich> blackh: They certainly are frustrated with the code base (hard to extend, hard to understand, etc. etc.); however, discussing approaches to resolve the situation (for instance, by suggesting to consider using more functional paradigms when refactoring the code base) are always uphill battles. It's *unclear* how big the benefit is, but it's very clear what the cost of porting iwll be.
03:50:37 <blackh> frerich: If you don't want to go the whole hog, even continuation-passing style can improve things greatly.
03:51:03 <frerich> blackh: Yes we actually do use CPS in a few caes already.
03:51:08 <blackh> frerich: It doesn't have to be a huge cost - it definitely can be done in degrees.
03:51:15 <blackh> ...in mean, bit-by-bit.
03:52:13 <frerich> blackh: I believe writing a book about 'migrating' a code base (and a team, at the same time...) to a more functional approach using CPS and FRP and whatnot would be a useful thing to do. :)
03:52:17 <blackh> frerich: Commercial projects generally hit a complexity wall and go one of three ways: 1. mothballed, 2. company staffs up and project gets hugely inefficient and costly (often after the company is acquired), 3. major refactoring.
03:52:26 <d-snp> Boney: the enum type idea is good, I'll remember that too :)
03:52:27 <frerich> I think if somebody had some experience with doing that a few times, some useful insights could be learned from that.
03:52:53 <blackh> frerich: Obviously 3 is the only sane answer!
03:53:27 <frerich> blackh: Yes, maybe not from an economical perspective, but certainly from the angle of any engineer with a bit of self-respect :)
03:55:24 <blackh> frerich: That's a good idea (book)! Well, the thing is, refactoring is cheaper because bad code has enormous costs associated with it. But they're all "hidden" (like an elephant in the room).
03:55:52 <irene-knapp1> yes, well said
03:56:03 <irene-knapp1> bad code has enormous costs but we don't notice because they're so big that we take them for granted
03:56:09 <blackh> frerich: All good software projects are re-written three times or so.
03:56:18 <irene-knapp1> but that said, refactoring is better than rewriting
03:56:28 <irene-knapp1> rewriting, at the risk of generalizing, usually fails
03:56:39 <blackh> Yes - refactoring is definitely better than re-writing, though it's not without its pain.
03:56:41 <irene-knapp1> yes
03:57:11 <Boney> d-snp: thanks.
03:57:24 <blackh> It's a perfectly valid way for a project to go: start simple, get complex, complexity out of control, major refactoring, repeat, nice code.
03:57:36 <blackh> My brother estimated that they went from 1 week to add a feature down to 1 hour.
03:57:42 * hpc considers "comment-copy-paste" to be a form of rewriting
03:57:47 <bitonic> blackh: what do you mean with rewriting? throwing the old code away and restarting or incremental replacement of code?
03:57:57 <irene-knapp1> the former
03:57:59 <hpc> comment out all your code, then rebuild the functionality, copy-pasting from the existing code as you need to
03:58:12 <irene-knapp1> yeah, what hpc says
03:58:16 <irene-knapp1> is the balance I often strike
03:58:28 <hpc> it goes really quick, and gets almost all the shit out
03:58:31 <irene-knapp1> yeah
03:58:36 <bitonic> irene-knapp1: well then "all good software is rewritten 2/3 times" is falre
03:58:41 <bitonic> *false
03:58:42 <irene-knapp1> that's fine.
03:58:47 <irene-knapp1> I wasn't the one asserting that :D
03:59:03 <bitonic> irene-knapp1: right, blackh
03:59:10 <frerich> hpc: Sometimes it can be quite hard to tell whether you rebuilt the functionality indeed, because the behaviour of the old code is hard to test (if at all). So you end up having to refactor code so that it becomes testable in the first place - and this refactoring itself can't be verified.
03:59:13 <blackh> bitonic: I meant re-writing through refactoring
03:59:29 <bitonic> blackh: ok, so incremental rewrite
03:59:54 <irene-knapp1> of course, if one were using Agda, then the old code and the new code both work
03:59:56 <blackh> Yeah - that's what I mean. The XP guys have it right, in my opinion - don't design, but refactor often
03:59:57 <hpc> frerich: yeah... that's where strong static types come in :D
04:00:14 <blackh> Bad code comes about through resistance to refactoring.
04:00:16 <irene-knapp1> I do think some advance design is okay, I think XP is a little *hem* extreme in its dislike for it
04:00:28 <hpc> icwydt
04:00:36 <irene-knapp1> haha
04:00:53 <irene-knapp1> but yes, I'm a static-typing afficianado
04:01:00 <blackh> irene-knapp1: Well, you're right. But older methodologies were extreme in the other direction.
04:01:04 <irene-knapp1> I program far faster in Haskell than I ever did in Lisp, even after five years of using Lisp
04:01:10 <irene-knapp1> yeah, true enough
04:01:31 <hpc> i "rewrote" my IRC bot a couple of times this way, and every time, once it typechecked there were no runtime problems
04:01:35 <irene-knapp1> nice
04:01:47 <irene-knapp1> is lambdabot the bot in question?
04:01:56 <hpc> no, but my bot is close
04:01:57 <irene-knapp1> @botsnack
04:01:58 <lambdabot> :)
04:02:00 <irene-knapp1> that's cool
04:02:04 <hpc> on another network i am Spock, and the bot is Data
04:02:08 <blackh> frerich: Investigate and see whether it might be possible to move to C++11. You might have to wait a year or whatever.
04:02:10 <irene-knapp1> cute, haha
04:02:14 <hpc> it does hoogle, mueval, and :t
04:02:23 <irene-knapp1> niftyo
04:02:35 <hpc> and something i wish lambdabot had, when you join a channel it tells you the last few lines people said before you joined
04:02:43 <irene-knapp1> ah, yeah.  in Jabber that's built-in.
04:03:11 <hpc> and it does duckduckgo searches
04:03:29 <irene-knapp1> not familiar
04:03:33 <hpc> and does a rather tremendous amount of post-processing on the API results to get it down to something i can display in a few lines
04:03:34 <irene-knapp1> oh I see
04:03:36 <irene-knapp1> a search engine
04:03:41 <hpc> https://duckduckgo.com/?q=pi
04:03:49 <hpc> my bot does the red box at the top
04:04:04 <irene-knapp1> I see
04:14:22 <t7> how can i tell which version of Parsec ghci has imported?
04:15:27 <hpc> t7: use something from parsec and look for something like
04:15:28 <hpc> Loading package numbers-3000.0.0.0 ... linking ... done.
04:16:25 <t7> hmm
04:16:46 <t7> Parsec has kind * -> * -> * in the docs but arity of 4 in my ghci
04:18:19 <t7> why does life have to be so hard? why do you hate me, god?
04:18:33 <taylorgb> I think in Parsec3 Parsec is just a type synonym for ParsecT with the Identity Monad from Data.Functor
04:18:48 <taylorgb> ParsecT should be Stream, User State, Monad, Result Type
04:19:43 <taylorgb> But I think there are seperate parsec and parsec3 packages, make sure you have the one you're intending to use
04:20:03 <t7> which is better?
04:21:04 <taylorgb> I seem to remember the interfaces are slightly better, I think that parsec3 has more functionality in that is has the transformers implemented, and instances for both Monad and Applicative. Which I'm not sure the old one had.
04:21:13 <taylorgb> slightly different rather
04:24:25 <hpc> what's the point of the user state?
04:24:38 <hpc> if you wanted it, wouldn't you use StateT as your monad?
04:24:47 <hpc> (as the inner monad, i should say)
04:27:34 <taylorgb> It's certainly not clear to me, I haven't had cause to use it.
04:28:45 <taylorgb> Unless it is intended to be used to store a value related to the parser, and not to the result.
04:33:47 <teneen> is there an abstraction which is like a Monoid but does not have a suitable definition for mappend?
04:35:31 <teneen> and similarly for MonadPlus?
04:36:05 <hpc> teneen: don't think so
04:36:13 <hpc> there'd be no laws for it
04:36:14 <Philippa_> hpc: honestly? Parsec's old enough that monad transformers weren't a stable thing originally
04:36:24 <hpc> ah, hysterical raisins
04:36:49 <Philippa_> I think parser branching undoes state alterations, but I'd have to RTFSource
04:37:40 <hpc> that could be their way of doing context-sensitive grammars, then
04:37:45 <hpc> applicative style + hidden state
04:42:20 <jamil_1_> hi all
04:42:27 <adamt> Hello jamil_1_
04:42:37 <jamil_1_> what is the difference between type constructor and data constructor ?
04:42:47 <hpc> a type constructor is like Bool
04:42:52 <hpc> a data constructor is like False
04:43:40 <jamil_1_> what about this: data Tree a = Tip | Node a (Tree a) (Tree a)
04:43:53 <hpc> type constructor is Tree, data constructors are Tip, Node
04:44:57 <hpc> you can read it as
04:45:21 <hpc> data TypeConstructor typeParam typeParam ... = DataConstructor dataParam dataParam ... | ...
04:46:21 <jamil_1_> right
04:47:04 <jamil_1_> so data keyword lets you construct new types which may or may not be type constructors themselves, right ?
04:47:35 <hpc> it defines the type constructor
04:48:15 <hpc> like say when you define a function
04:48:23 <hpc> function param param param = ...
04:48:42 <hpc> that defines the function, not "new values"
04:48:52 <jamil_1_> ok
04:49:02 <hpc> data TypeConstructor param param param = ... -- this is similar
04:49:15 <jamil_1_> got it
04:49:33 <jamil_1_> how should I read this: Left :: forall b a. a -> Either a b
04:49:52 <sipa> is that a GADT definition?
04:50:00 <jamil_1_> so each data constructor it self is a function  ?
04:50:06 <jamil_1_> this is from http://www.haskell.org/haskellwiki/Constructor
04:50:09 <hpc> indeed
04:50:24 <hpc> well, many are
04:50:32 <hpc> in that tree type, Tip :: forall a. Tree a
04:50:44 <sipa> False and True are technically not functions
04:50:50 <sipa> or Nothing
04:50:51 <hpc> it's just a value, because there's no (->) in the type
04:51:52 <jamil_1_> what does forall denote ?
04:52:06 <hpc> it just says "these are type variables"
04:52:26 <hpc> (it means more than that, but none of the subtlety comes into play here)
04:52:29 <sipa> jamil_1_: you'd probably write that yourself as "a -> Either a b", which means the same
04:54:44 <jamil_1_> are there other things like forall e.g forsome ?
04:55:03 <sipa> there is "exists", but forget about that for now
04:55:16 <hpc> exists isn't actually a haskell keyword though
04:55:25 <hpc> the complication of forall comes from putting it in strange places
04:59:47 <t7> @pl (\x -> not (isVerb x) && not (isCondition x))
04:59:48 <lambdabot> ap ((&&) . not . isVerb) (not . isCondition)
05:02:01 <mauke> :t not . liftM2 (||) ?isVerb ?isCondition
05:02:02 <lambdabot> forall (f :: * -> *). (?isVerb::f Bool, ?isCondition::f Bool, Monad f, Functor f) => f Bool
05:02:36 <mauke> :t not P.. liftM2 (||) ?isVerb ?isCondition
05:02:37 <lambdabot> Couldn't find qualified module.
05:02:49 <mauke> :t not Prelude.. liftM2 (||) ?isVerb ?isCondition
05:02:50 <lambdabot> forall a. (?isVerb::a -> Bool, ?isCondition::a -> Bool) => a -> Bool
05:03:57 <adimit> … which extension allows for the question marks in front of function names?
05:04:13 <adimit> and why do you need them at all?
05:04:29 <depy> can anyone explain me this syntax:  let square x = x * x in square 10
05:04:58 <depy> let is just lexical scopping right?
05:05:05 <adimit> depy: correct.
05:05:09 <irene-knapp1> yes, but it can be used to bind functions as well as variables
05:05:12 <nand`> depy: let <X> in <Y>  <- all the definitions in <X> are in scope in <Y>; in this example “square” is being defined only for the body of the in ..., here “square 10”
05:05:14 <irene-knapp1> it means the same thing as
05:05:18 <depy> and first x is function parameter?
05:05:20 <irene-knapp1> let square = \x -> x * x in square 10
05:05:22 <adamt> depy: yes
05:05:28 <adimit> depy: just like with top-level functions.
05:05:53 <nand`> adimit: The ?foo is just like undefined; but lambdabot tells you the type of it as well
05:05:57 <depy> oh
05:06:03 <nand`> contrast
05:06:12 <depy> you have no curly braces to mark the scope
05:06:14 <nand`> :t \isVerb isCondition -> not Prelude.. liftM2 (||) isVerb isCondition
05:06:15 <lambdabot> forall a. (a -> Bool) -> (a -> Bool) -> a -> Bool
05:06:17 <depy> so you define it with "in"
05:06:25 <irene-knapp1> the "in" is required anyway, actually
05:06:36 <irene-knapp1> the only case where there's no "in" is when you're using do-notation, which has special syntax for let
05:06:43 <adimit> nand`: ok, so it's lambda-bot specific?
05:06:51 <nand`> depy: yeah; it's whitespace-sensitive instead of using curly braces; but I think you can use curly braces as well actually
05:06:56 <nand`> adimit: I'm not sure
05:07:03 <nand`> adimit: I've never used it or seen it outside lambdabot though
05:07:04 <irene-knapp1> > let { square x = x * x } in square 10
05:07:06 <lambdabot>   100
05:07:07 <hpc> it's the ImplicitParameters extension
05:07:13 <irene-knapp1> you still need the "in"
05:07:17 <hpc> (which by the way is horrible and you should never use it)
05:07:29 <irene-knapp1> > do { let square x = x * x ; return $ square 10 }
05:07:30 <lambdabot>   <no location info>: parse error on input `}'
05:08:12 <hpc> let only works in layout do-blocks
05:08:16 <irene-knapp1> made some mistake there, not sure what exactly, but you get the idea.  I can omit the "in" (and indeed, must) when I'm putting the let as a statement a do-block.
05:08:18 <irene-knapp1> +in
05:08:31 <irene-knapp1> oh, not in explicit-braces ones?
05:08:34 <hpc> it needs to know if the next line is a definition or a continuation of the do-block
05:08:39 <depy> hm, ok then I'm still not sure what "in" means
05:08:39 <hpc> and it can't know that without indentation
05:08:40 <irene-knapp1> logical
05:08:43 <nand`> > let { square x = x * x } in { square 10 }
05:08:44 <lambdabot>   <no location info>: parse error on input `{'
05:08:50 <irene-knapp1> "in" just separates the defined items from the result value
05:09:03 <hpc> depy: "let DEFINITIONS in EXPRESSION" -- it's just syntax
05:09:09 <parcs`> 'in' delimits bindings from the expression
05:09:12 <depy> I see
05:09:14 <adamt> depy: let <something be something else while inside the> in <block>
05:09:19 <adimit> depy: it's like with a mathematical exercise. You define what you *have* in the let block, and the in block actually uses that stuff.
05:09:27 <nand`> depy: “in” is just a keyword; eg. “if <X> then <Y> else <Z>” <- X,Y,Z are here separated by keywords; except here it's “let <X> in <Y>”
05:10:02 <depy> so the thing after "in" gets evaluated
05:10:07 <nand`> yes
05:10:25 <adimit> depy: but the stuff in the let block also gets evaluated, then bound to the names defined there.
05:10:26 <nand`> let <X> in <Y> is basically equivalent to <Y>, except free variables in <Y> get matched against the definitions in <X> as well
05:10:48 <adimit> The tricky thing is that values in let-definitions can depend on each other.
05:11:16 <depy> so basically, this sample is anonymous function since it only exists inside that lexical scope?
05:11:17 <adimit> > let { x = 1 ; y = x+1 } in y
05:11:18 <lambdabot>   2
05:11:32 <depy> hm interesting
05:11:39 <irene-knapp1> it's not anonymous, in that it has a name; but yes, that name is only bound inside that scope
05:11:44 <nand`> right; that's what sets let..in apart from, say; (\foo bar -> <Y>) (fooBody) (barBody)   vs  let foo = fooBody; bar = barBody in <Y>
05:11:46 <adimit> depy: basically, yes, but not really anonymous, since it actually does have a name :-)
05:11:53 <depy> oh, right :)
05:12:41 <depy> > let { a = 1; b = 2; sum  = a + b } in sum
05:12:42 <lambdabot>   3
05:13:01 <depy> > let { a = 1; b = 2; sum x y = x + y } in sum a b
05:13:02 <lambdabot>   3
05:13:05 <depy> great :)
05:13:09 <nand`> another difference between top-level definitions is that the definitions in a ‘let’ can depend on variables in the scope surrounding it; eg. foo x = let y = x+1; z = y*2 in z
05:13:31 <adimit> another interesting one:
05:13:38 <adimit> > let x + y = 6 in 2 + 2
05:13:39 <lambdabot>   6
05:13:41 <t7> @hoogle (a -> Bool) -> m a -> m [a]
05:13:42 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
05:13:42 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
05:13:42 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
05:13:51 <nand`> > let 2+2=5 in 2+2
05:13:52 <lambdabot>   5
05:13:53 <t7> is there a monadic takeWhile?
05:13:55 <sipa> > let 6 = 3 in 3+3
05:13:56 <lambdabot>   6
05:14:05 <t7> or repluicateWhile
05:14:06 <sipa> > let 6 = 3 in 6+6
05:14:07 <lambdabot>   12
05:14:10 <sipa> :(
05:14:16 <adimit> lol
05:14:40 <depy> so this let does nothing I guess
05:14:41 <nand`> the sugar for numeric literals sort of destroys that one :(
05:14:50 <unnali> > runIdentity $ do { let { square x = x * x }; return $ square 10; }
05:14:52 <lambdabot>   100
05:14:53 <unnali> finally.
05:15:09 <adimit> this kind of stuff would work in Coq though.
05:15:14 <mm_freak> t7: 'fix' =)
05:15:39 <nand`> > let three=3; six=6 in let six=three in six+six
05:15:40 <lambdabot>   6
05:15:45 <depy> so what exactly does this do: "let x + y = 6 in 2 + 2" ?
05:15:47 <irene-knapp1> limit of x goes to infinity as 1 approaches 2
05:15:54 <nand`> depy: redefines (+)
05:16:01 <nand`> > let (+) x y = 6 in 2+2
05:16:02 <lambdabot>   6
05:16:03 <nand`> observe
05:16:10 <nand`> > let (+) _ _ = 6 in (+) 2 2
05:16:11 <lambdabot>   6
05:16:18 <adimit> and:
05:16:21 <adamt> nice trick.
05:16:27 <adimit> > let (+) _ = 2 in 2 + 2
05:16:28 <lambdabot>   2
05:16:31 <adamt> I guess it's right; hell is reading other people's haskell code. :)
05:16:36 <sipa> > let { a + b = a * b; a * b = a - b } in 4 + 5
05:16:37 <lambdabot>   -1
05:16:49 <nand`> > let 2+2 = 3 in 2+2 -- works similarly, this one is actually pattern matching on the numerics
05:16:50 <lambdabot>   3
05:17:02 <nand`> > let 2+2 = 3 in 2+4 -- observe
05:17:03 <lambdabot>   *Exception: <interactive>:3:4-10: Non-exhaustive patterns in function +
05:17:08 <unnali> hah!
05:17:10 <t7> @hoogle a -> m [a] -> m [a]
05:17:10 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
05:17:10 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
05:17:10 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
05:17:24 <nand`> adamt: don't worry; if you do that in production code you deserve to be shot
05:17:25 <sipa> t7: give an example of what you wany?
05:17:50 <depy> so: let x + y = 6 tells that "something + somethign" will always return 6 ?
05:17:51 <t7> keep parsing x until its not a number
05:17:54 <t7> or something
05:18:05 <nand`> depy: correct
05:18:19 <nand`> contrast
05:18:23 <unnali> t7: http://stackoverflow.com/questions/1133800/haskell-monadic-takewhile seems to be a similar kinda question; don't know if that has exactly what you want.
05:18:26 <nand`> > let x+y = x*y in 5+5
05:18:27 <lambdabot>   25
05:18:49 <adamt> nand`: Many people have a boss that hands out riot shields to his employees to protect them for getting shot. Sadly.
05:18:51 <depy> so this redefines + function to be *
05:18:56 <sipa> > let _+x = x in 6+7
05:18:57 <lambdabot>   7
05:19:01 <nand`> depy: yes pretty much
05:19:15 <nand`> > let (+) = (*) in 5+5 -- works as well because of eta reduction
05:19:16 <lambdabot>   25
05:19:22 <unnali> t7: you need some way of signalling that you want the execution to stop, though, so i think the type sig you gave isn't quite complete
05:19:26 <mm_freak> :t \p c -> fix (\again -> do x <- c; if p c then fmap (c :) again else return [])
05:19:27 <lambdabot> forall (m :: * -> *) t. (Monad m, Functor m) => (m t -> Bool) -> m t -> m [m t]
05:19:32 <sipa> :t forever
05:19:33 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
05:19:37 <mm_freak> :t \p c -> fix (\again -> do x <- c; if p x then fmap (x :) again else return [])
05:19:38 <lambdabot> forall (m :: * -> *) t. (Monad m, Functor m) => (t -> Bool) -> m t -> m [t]
05:19:40 <depy> how come + and other similar functions can be called like "x + x" not "+ x x" ?
05:19:44 <mm_freak> @ t7
05:19:56 <mm_freak> also for many things foldM is a nice generic combinator (that doesn't apply in this case)
05:20:02 <sipa> depy: + is an operator that must be written infix, the corresponding function is (+)
05:20:03 <unnali> mm_freak: wow.
05:20:05 <nand`> depy: because they're operators
05:20:08 <sipa> > (+) 5 3
05:20:09 <lambdabot>   8
05:20:13 <nand`> depy: it depends on the exact symbols involved
05:20:24 <mm_freak> :t \p c -> fix (\again -> do x <- c; if p x then liftM (x :) again else return [])
05:20:25 <nand`> eg. ‘f’ is not an operator, but ‘+’ is
05:20:25 <lambdabot> forall (m :: * -> *) t. (Monad m) => (t -> Bool) -> m t -> m [t]
05:20:32 <depy> ok :) tnx
05:20:33 <sipa> depy: you can do the opposite as well, by the way:
05:20:36 <mm_freak> also yeah, if you use liftM, the type will be simpler =)
05:20:45 <sipa> > let plus = (+) in 5 `plus` 3
05:20:45 <nand`> depy: a `f` b = f a b; contrast a + b = (+) a b
05:20:46 <lambdabot>   8
05:21:16 <depy> that's pretty cool :)
05:21:30 <adamt> depy: functions only containing special chars in the name is turned into an infix functions, and surround it with (..) and it'll be back to prefix notation
05:21:33 <nand`> unfortunately it's not as cool as I'd like; I want my `flip F`
05:21:37 <nand`> `flip f` *
05:21:45 <sipa> depy: even cooler:
05:21:45 <hpaste> t7 pasted “replicateWhile” at http://hpaste.org/69329
05:21:48 <sipa> > (+3) 5
05:21:49 <lambdabot>   8
05:21:53 <sipa> > (3-) 5
05:21:54 <adamt> depy: the opposite is turning a prefix function into infix, which is done with `..`
05:21:54 <lambdabot>   -2
05:21:57 <nand`> > (-3) 5
05:21:57 <sipa> > (-3) 5
05:21:58 <lambdabot>   -3
05:21:58 <lambdabot>   can't find file: L.hs
05:21:59 <nand`> :P
05:22:07 <nand`> yeah, ignore that last one
05:22:20 <sipa> > (- 3) 5
05:22:21 <lambdabot>   -3
05:22:24 <sipa> :(
05:22:26 <nand`> > (+(-3)) 5
05:22:27 <lambdabot>   2
05:22:30 <nand`> ugly, but works
05:22:31 <sipa> > (subtract 3) 5
05:22:32 <lambdabot>   2
05:22:37 <nand`> sipa++
05:22:49 <nand`> > (+ negate 3) 5
05:22:50 <lambdabot>   2
05:23:01 <sipa> :t (subtract 3)
05:23:02 <lambdabot> forall t. (Num t) => t -> t
05:23:06 <mm_freak> unnali: ?
05:23:11 <depy> > (subtract 3) 5
05:23:12 <lambdabot>   2
05:23:24 <depy> > subtract 3 5
05:23:25 <lambdabot>   2
05:23:42 <depy> > 3 `subtract` 5
05:23:43 <lambdabot>   can't find file: L.hs
05:23:52 <nand`> poor lambdabot and race conditions
05:24:04 <depy> > 3 `(subtract)` 5
05:24:05 <lambdabot>   <no location info>: parse error on input `('
05:24:09 <depy> lol :
05:24:13 <nand`> depy: it was correct without the ( )
05:24:19 <nand`> the contents of ` ` can't be an expression; has to be a name
05:24:23 <depy> oh
05:24:31 <nand`> lambdabot just died in exactly that moment
05:24:47 <nand`> > 3 `subtract` 5
05:24:48 <lambdabot>   2
05:25:07 <nand`> note that subtract = flip (-)
05:25:12 <depy> > 3 `subtract` 5
05:25:13 <lambdabot>   2
05:25:16 * hackagebot elm-yesod 0.1.2 - The Elm language Yesod compatibility module.  http://hackage.haskell.org/package/elm-yesod-0.1.2 (VincentAmbo)
05:25:18 <depy> oh cool
05:35:15 <adamt> i (think) i need something like  (a -> b) -> Maybe a -> Maybe b, any suggestions?
05:35:32 <barrucadu> @djinn  (a -> b) -> Maybe a -> Maybe b
05:35:32 <lambdabot> f a b =
05:35:32 <lambdabot>     case b of
05:35:32 <lambdabot>     Nothing -> Nothing
05:35:32 <lambdabot>     Just c -> Just (a c)
05:35:44 <parcs`> fmap
05:36:15 <unnali> :t fmap
05:36:16 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:36:38 <unnali> :i Maybe
05:36:43 <unnali> aw. :(
05:37:12 <nand`> @src Maybe fmap
05:37:12 <lambdabot> fmap _ Nothing       = Nothing
05:37:12 <lambdabot> fmap f (Just a)      = Just (f a)
05:37:17 <nand`> :)
05:38:10 <jtza8> How would I iterate through two lists checking for equality all the way through?
05:38:13 <adamt> oh, i think i'm kinda slowly-ish getting your points.
05:38:16 <unnali> nand`: nice!
05:38:22 <Botje> jtza8: list1 == list2
05:38:23 <nand`> :t all -- jtza8
05:38:24 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
05:38:30 <nand`> oh wait
05:38:56 <fmap> > zipWith (==) [1..5] [5,4..1]
05:38:57 <lambdabot>   [False,False,True,False,False]
05:39:08 <nand`> what Botje said works; but if you want to do it manually: and .: zipWith (==) works
05:39:16 <mekeor> > all . zipWith (==) [1..5] [1,4,3,2,4,5]
05:39:17 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
05:39:17 <lambdabot>         against inferred ...
05:39:21 <mekeor> > all . zipWith (==) $ [1..5] [1,4,3,2,4,5]
05:39:22 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
05:39:23 <lambdabot>         against inferred type ...
05:39:26 <nand`> mekeor: s/all/and/
05:39:31 <mekeor> erm, you know what i mean…
05:39:45 <mekeor> nand`: oh, true.
05:39:53 <jtza8> > and zipWith (==) [1..5] [1..6]
05:39:54 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
05:39:54 <lambdabot>         against inferred typ...
05:40:03 <nand`> > and . zipWith (==) [1..5] $ 1:[2..5]
05:40:05 <lambdabot>   True
05:40:10 <jtza8> > and (zipWith (==) [1..5] [1..6])
05:40:11 <lambdabot>   True
05:40:22 <jtza8> That's fine
05:40:38 <adamt> nand`: is that Maybe fmap thing something that exists, or just some vuhdo generated on the fly?
05:40:48 <nand`> adamt: it exists
05:40:56 <nand`> > fmap (+1) (Just 5)
05:40:56 <lambdabot>   Just 6
05:41:07 <unnali> @src [] fmap
05:41:07 <lambdabot> fmap = map
05:41:07 <nand`> jtza8: keep in mind l1 == l2 works as well since (==) for lists is defined this way
05:41:22 <nand`> > [1..5] == [1..6]
05:41:23 <lambdabot>   False
05:41:25 <nand`> > [1..5] == [1..5]
05:41:26 <lambdabot>   True
05:41:27 <jtza8> nand`: That's it
05:41:47 <jtza8> Not the same with zip, and that's my problem
05:42:10 <nand`> oh right; zip ignores the remaining elements
05:42:10 <jtza8> it's the 6 that should make the statement false.
05:42:19 <nand`> ignore what I said then :(
05:42:46 <jtza8> That's exactly what I thought at first as well.
05:43:06 <nand`> > let f l1 l2 = and (zipWith (==) l1 l2) && (length l1 == length l2) in f [1..5] [1..6]
05:43:07 <lambdabot>   False
05:43:20 <nand`> or just use the recursive definition
05:43:21 <adamt> :t fmap
05:43:22 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:43:24 <nand`> @src [] (==)
05:43:24 <lambdabot> []     == []     = True
05:43:24 <lambdabot> (x:xs) == (y:ys) = x == y && xs == ys
05:43:24 <lambdabot> _      == _        = False
05:43:48 <adamt> oh wait, and `fmap` == <$> right?
05:43:55 <nand`> adamt: yes
05:44:02 <sipa> :t <$>
05:44:03 <lambdabot> parse error on input `<$>'
05:44:06 <nand`> :t (<$>)
05:44:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:44:08 <sipa> :t (<$>)
05:44:08 <adamt> brilliant, thanks everybody.
05:44:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:44:12 <sipa> :t fmap
05:44:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:45:06 <jtza8> Thanks
05:54:04 <adamt> i have some logic that i want to apply to either (Maybe a) or a and return Bool, how would i go about that?
05:54:34 <nand`> adamt: start by writing the type of the function you want to implement
05:55:18 <adamt> i already have this function: Maybe (Entity User) -> Bool
05:55:52 <adamt> so i'm curious whether Entity User -> Bool can work at the same time :>
05:56:32 <adamt> (i could just make two different functions, but what's the fun in that?)
05:56:40 <unnali> you can't have it applied to two different types at once
05:56:47 <unnali> but can't you just wrap the first arg in Just if you know it?
05:57:03 <unnali> if it's a longer-ish chain, just compose Just
05:57:11 <adamt> You're right, i could.
05:57:19 <adamt> It's only a single place anyways.
05:57:36 <unnali> I think it's probably the nicer way.
05:57:52 <unnali> and you're right, two different functions is no fun at all
05:57:58 <adamt> or i would end up with isAdmin and isAdmin' or something.
05:58:05 <adamt> one could use the other though.
05:58:30 <adamt> (the reason is the difference between requireAuth and maybeAuth in Yesod, if anybody cares)
05:58:42 <nand`> I would implement Entity User -> Bool and then compose the other one with that and maybe
05:59:01 <nand`> I'm guessing your isAdmin Nothing = False ?
05:59:06 <adamt> nand`: yes
05:59:25 <unnali> nand`: nice
05:59:31 <aristid>  :t maybe False
05:59:34 <aristid> :t maybe False
05:59:35 <lambdabot> forall a. (a -> Bool) -> Maybe a -> Bool
05:59:43 <nand`> :t let isAdmin = (undefined :: Maybe a -> bool) in maybe False isAdmin
05:59:44 <lambdabot> forall a. Maybe (Maybe a) -> Bool
05:59:51 <nand`> err
05:59:55 <nand`> :t let isAdmin = (undefined :: a -> bool) in maybe False isAdmin
05:59:56 <lambdabot> forall a. Maybe a -> Bool
06:00:15 <aristid> nand`: huh, is bool case-insensitive? oO
06:00:21 <nand`> aristid: nope :P
06:00:31 <aristid> aaah lol
06:00:36 <aristid> evil bastard you!
06:00:45 <nand`> aristid: but in this case the type is equal to :: a -> b; so the “False” in maybe forced the b to be Bool
06:00:52 <aristid> yeah:)
06:00:54 <nand`> my bad :)
06:05:20 * hackagebot SyntaxMacros 1.0.3 - Syntax Macros in the form of an EDSL  http://hackage.haskell.org/package/SyntaxMacros-1.0.3 (MarcosViera)
06:20:56 <importantshock> Is it possible to bind implicit parameters without using a let/where statement? I'm looking to bind an explicit parameter in do-notation, i.e. `?foo <- something`
06:22:16 * BMeph wonders if importantshock gets what "implicit" means...
06:26:08 <Taneb> How do I un-import Prelude in GHCI?
06:26:27 <parcs`> importantshock: don't think so. you can do foo <- something; let ?foo = foo;
06:26:29 <Ke> at least you can use hiding
06:26:35 <fmap> :m -Prelude
06:26:48 <Taneb> Doesn't work?
06:27:05 <Ke> oh wait ghci
06:27:14 <Taneb> (this is with GHC 7.4.1
06:27:15 <Taneb> )
06:28:11 <hayashi> Is there any way to make an instance of some class on a data type that just returns the application of a function on the constructor name in the default case?
06:28:12 <ClaudiusMaximus> Taneb: you can   import Prelude()  -- but that still gives you instances...
06:28:21 <Taneb> ClaudiusMaximus, that works, thanks
06:30:54 <hayashi> wonder if there's some way of mutilating Typeable to do that
06:31:30 <unnali> is there some nice way to 'zip' up monadic actions? I'm looking for (Monad m) => m a -> m b -> m (a, b). Control.Monad.Zip.mzip appears to be a thing, but only on MonadZip instances.
06:31:52 <nand`> :t liftM2 (,)
06:31:53 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
06:32:30 <nand`> unnali: ^
06:32:56 <merijn> importantshock: You can pattern match with <-, but maybe I misunderstand your question?
06:33:06 <merijn> importantshock: Oh wait, ignore me
06:33:49 <unnali> nand`: genius!
06:34:30 <importantshock> parcs`: yeah, that's what i've been doing
06:39:33 <hpaste> untitled pasted “program structure” at http://hpaste.org/69330
06:41:35 <merijn> untitled: What do you mean by "This structure I use is very dumb and unuseful, since upper functions in the chain must alway take same parameters and this is impossible."?
06:41:50 <merijn> Why is that impossible?
06:42:36 <Peaker> untitled, are 1+2 in a loop?
06:43:05 <untitled> Peaker: only 2 uses loop
06:43:05 <Peaker> untitled, sounds like you might want a forever in the state monad?
06:43:21 <Peaker> untitled, why is 2 in a loop?
06:43:25 <Peaker> there's no user input involved?
06:43:41 <untitled> merijn: since I have to call printObj from parser, it returns 1 string, what if I call printAll?
06:43:57 <Rhamphoryncus> Peaker: question is, whom is stalking whom ;)
06:44:00 <untitled> printAll would return an array of strings
06:44:09 <Peaker> Rhamphoryncus, :)
06:44:27 <Peaker> Rhamphoryncus, glad you're #haskell'ing :)
06:44:30 <nand`> untitled: you could have printObj return a singleton list
06:44:37 <merijn> untitled: Why not call printobj at the top level?
06:44:43 <merijn> Also, what nand` said
06:45:02 <nand`> or use IO () as the common denominator :P
06:45:09 <Rhamphoryncus> Peaker: I decided that C++ was crappy enough that even with my biases against functional languages they'd still be better than it
06:45:16 <untitled> well, printObj doesn't print anything, it just constructs a string to be printed
06:45:26 <untitled> and first, I need to parse input
06:45:30 <Peaker> Rhamphoryncus, cool, Haskell as the less shitty language also works :)
06:45:58 <merijn> untitled: Yes, but why don't you call printObj in ioLoop? Then you don't have to pass it through all the other functions?
06:46:05 <nand`> the only language Haskell isn't less shittier than is Haskell
06:46:13 <Rhamphoryncus> Peaker: it's a surprisingly productive mindset.  I'm actually enjoying learning about it
06:46:22 <untitled> merijn: and first, I need to parse input
06:46:29 <untitled> => have to call parser
06:46:34 <Peaker> Rhamphoryncus, awesome
06:46:50 <merijn> untitled: So you parse the input, return the object and then (in ioLoop) call printObject on the returned object?
06:47:28 <merijn> I suspect you have some side-condition/assumption you're not mentioning as I don't really see a problem right now?
06:48:08 <nand`> what I'd do is probably something like data Action = PrintAll | PrintOne Integer | AddOne ...; parse :: String -> Maybe Action; run :: Action -> StateT [Object] IO () -- or whatever
06:48:09 <untitled> that would be "a haskell rookie"
06:48:18 <Rhamphoryncus> Peaker: I just have to avoid thinking about aspects like monads until later, when I can examine them in context rather than out of context
06:48:53 <merijn> Rhamphoryncus: There's not much to examine, tbh
06:49:10 <Rhamphoryncus> merijn: sssh, you'll only make me think of them out of context
06:50:37 <Peaker> Rhamphoryncus, yeah, monads are always introduced too early.. they're meant to generalize some relatively advanced stuff, so it's much better to learn the specifics first
06:51:01 <Rhamphoryncus> Peaker: yeah
06:52:02 <nand`> LYAH has good pacing re: monads imo
06:52:40 <Rhamphoryncus> See, I was afraid of even mentioning monads because I knew people would jump on it
06:54:33 <Peaker> Rhamphoryncus, are you working from LYAH?
06:54:52 <Rhamphoryncus> http://book.realworldhaskell.org/
06:55:31 <Peaker> ah, do you find it good? I think it's more of a book to go from intermediate->advanced.. starting with Haskell with it may be difficult?
06:55:52 <Rhamphoryncus> So far it's been fine, but I'm only on the second chapter
06:55:54 <merijn> Peaker: Well, the first few chapters are nice to start with
06:56:12 <merijn> But during later chapters I personally ran into issues with details that had been glossed over
06:56:36 <merijn> (At which point LYAH was just finished, so I just read that instead :p)
06:57:03 <Rhamphoryncus> I'll keep that in mind if I hit trouble :)
07:02:25 <Peaker> hopefully the structural editor I'm working on will make starting with Haskell much easier (type inference as you edit, underlining the types under sub-expressions, no syntax errors, etc)
07:05:01 <Nafai> Peaker: made much progress on that?  definitely a cool idea
07:05:13 <merijn> Nafai: Lots of people working on similar stuff
07:05:49 <merijn> A colleague of mine is working on an editor that will undeline type errors (after you hit compile) in the source and offer auto-suggestions based on the expected type
07:06:12 <merijn> Structural editing integrated with structural version control would be sweet
07:06:29 <merijn> Peaker: It better be a modal editor!
07:06:30 <Peaker> Nafai, yeah... github.com/Peaker/bottle  some type inference already going on as you edit
07:06:43 <Peaker> merijn, it is integrated with structural version control, but it's all very preliminary
07:06:47 <Peaker> (there's no merge yet)
07:06:51 <nand`> another idea: GHC already picks out suggestions for similar names to names that don't exist; it would be cool if the editor can pick out the ones that would type check
07:07:14 <nand`> eg. to auto-fix typos
07:07:43 <Peaker> nand`, it will, we're about to add that soon
07:07:50 <merijn> Peaker: What do you use for the UI atm?
07:07:57 <Peaker> nand`, ours will be more useful than GHC because there's no "import"
07:07:57 <nand`> sounds neat
07:08:05 <Peaker> merijn, OpenGL + graphics-drawingcombinators
07:08:16 <Peaker> With our own animation framework + GUI toolkit
07:08:22 <nand`> personally I would be more appreciative of an elaborate plugin for vim than a new editor outright
07:08:28 <Rhamphoryncus> safe haskell looks like it could be useful to me later on.  Does it allow limiting memory and CPU consumption?
07:08:29 <Peaker> nand`, the idea is to get rid of text
07:08:34 <nand`> oh
07:08:37 <Peaker> Rhamphoryncus, I don't think so...
07:08:58 <nand`> Peaker: have you ever considered cross-overs with mathematical notation, then? eg. auto-implementing some concepts
07:09:05 * merijn just wanted to know whether it'd run on the commandline or (if not) whether he'd be stuck using X11
07:09:06 <Peaker> nand`, everything is structural, including the revision control... there's no silly "save" button, undo buffer is persistent (and unified with the rev. control)
07:09:08 <Rhamphoryncus> Peaker: that's not as useful then :/
07:09:21 <Peaker> Rhamphoryncus, true.. it's a good step forward though
07:09:27 <Rhamphoryncus> yup
07:09:41 <Peaker> nand`, Yeah, the idea is to present it in the best way possible.. potentially math notation. Even for types we might do that
07:09:52 <nand`> Peaker: is this revision control an entirely new system or based on git/darcs/something else?
07:10:03 <Peaker> nand`, entirely new system, because it needs to track structures, not text lines
07:10:08 <nand`> heh, drag and drop type editor
07:10:10 <nand`> I can see it coming
07:10:11 <unnali> Peaker: looks neat! though the comments about revision control are concerning for integration.
07:10:18 <Peaker> nand`, it's not drag&drop... there's no mouse support yet even :)
07:10:31 <Peaker> unnali, it's just preliminary.. it'll be quite a while before it's ready for real use
07:10:38 <Peaker> but it's making steady progress
07:10:49 <unnali> Peaker: of course. Installing the deps now so I can see how it's right now, anyway. :)
07:11:13 <Peaker> unnali, awesome :)  feedback would be great.. lots of rough edges in the UI yet, we're not currently focusing on those
07:11:26 <nand`> Peaker: if you're tracking structural changes; would it be capable of recognizing changes that “go together” ie. one won't type check without the other and packing them together?:
07:12:19 <Peaker> nand`, you mean high-level dependencies between changes? Probably.. rev control is a tough problem and we've only spent a little while attacking it
07:12:33 <nand`> yeah that sounds like what I was thinking
07:12:40 <Peaker> nand`, when we get a good UI that's practical for editing and rev control becomes the next bottleneck for progress, we'll focus on that
07:12:42 <nand`> would be interesting if you can pull it off
07:13:21 <ClaudiusMaximus> i have some approximate measurements of f(n) for various n, what's a good way to extrapolate from that to asymptotic behaviour?   specifically, http://img832.imageshack.us/img832/8420/graphc.png is a plot of the data that i have so far...
07:13:35 <zezikaro> Hi, Does anyone here have a programming blog/portfolio website?
07:14:01 <Peaker> Rhamphoryncus, you could of course implement your own interpreter for some language and restrict that however you like, Haskell makes interpreter-writing real easy (can write a little "usable" language in 30 lines :-) )
07:14:13 <Peaker> unnali, there are so many annoyances w.r.t installing all the dependencies
07:14:17 <nand`> Peaker: so I guess you're storing haskell code in some form of generalized structure; and writing a function that will convert this to haskell source code?
07:14:45 <Peaker> nand`, temporarily, to use GHC. Later we'll have the compiler within the framework, doing incremental compilation as you edit
07:15:06 <Peaker> nand`, the code is serialized into a key/value store
07:15:16 <Rhamphoryncus> Peaker: heh.  There are a few existing languages I can use for that, such as lua.  I'll also be evaluating them later.  I guess I can add "roll my own in haskell" to that list, hehe
07:15:30 <nand`> ClaudiusMaximus: red ones look quadratic
07:15:54 <Peaker> unnali, do the deps install cleanly? What GHC are you using?
07:17:10 <ClaudiusMaximus> nand`: yeah, that's what i thought too, and the blue ones look linear, but that would make the green ones linear, which would really surprise me
07:18:05 <nand`> maybe you need to sample a larger scale for the green ones
07:18:39 <Rhamphoryncus> ClaudiusMaximus: a logarithmic scale might make it clearer
07:19:27 <unnali> Peaker: not quite. :| I need to install FTGL, hold on.
07:19:57 <unnali> Peaker: I'm on platform 2011.11, so 7.0.4
07:20:13 <unnali> and by 2011.11 I mean 2011.4, it seems.
07:20:31 <Peaker> hopefully GLFW-b won't cause the usual trouble it does with 7.0.X
07:20:47 <unnali> hmm. we'll see.
07:21:18 <ClaudiusMaximus> Rhamphoryncus: http://img856.imageshack.us/img856/2993/graphloglog.png  so, looks clearer, but not sure what it means :)
07:21:38 <unnali> Peaker: I got something odd. it may be because I'm on OS X, though.
07:21:43 <unnali> lots of clang output ..
07:24:08 <Peaker> unnali, installing these libs is quite annoying, causes various troubles on various people's machines
07:24:15 <unnali> I can understand why.
07:25:44 <Peaker> why?
07:26:35 <Rhamphoryncus> ClaudiusMaximus: yeah.  Next thing I'd try is just with the new time, non-logarithmic, in line mode
07:28:56 <ClaudiusMaximus> Rhamphoryncus: http://img24.imageshack.us/img24/9290/graphline.png
07:29:57 <ClaudiusMaximus> Rhamphoryncus: but i'd rather have some numerical algorithms thatd' magically work it out for me than plotting graphs and guessing (found this: http://www.dgp.utoronto.ca/people/JamesStewart/378notes/05logLog/ )
07:30:48 <Rhamphoryncus> ClaudiusMaximus: ahh, I was going for more of an ad-hoc judgement
07:31:19 <Peaker> unnali, did you manage?
07:31:22 <Peaker> unnali, which library install failed?
07:31:27 <unnali> Peaker: GLFW-b
07:31:54 <Peaker> unnali, do you have some example errors?
07:31:56 <unnali> Peaker: 7 build errors in same, mostly knee-deep in OS X frameworks.
07:32:00 <unnali> I'll post them, hang on.
07:32:10 <Paprikachu> > foldl (+) 0 [0..9]
07:32:11 <lambdabot>   45
07:33:04 <hpaste> unnali pasted “bottle deps failure” at http://hpaste.org/69331
07:33:29 <unnali> (I realise BerkeleyDB failed too, but I'm ignoring that while I work on the 'hard' one.)
07:33:45 <hpaste> untitled pasted “returning list of printables” at http://hpaste.org/69332
07:35:01 <Peaker> /usr/bin/../lib/clang/3.1/include/mmintrin.h:28:2: error: #error "MMX instruction set not enabled"
07:35:05 <Paprikachu> > let map' f xs = foldr (\x : acc -> f x : acc) [] xs in map' (+3) [0..9]
07:35:06 <lambdabot>   <no location info>: parse error on input `:'
07:35:13 <Paprikachu> > let map' f xs = foldr (\x acc -> f x : acc) [] xs in map' (+3) [0..9]
07:35:14 <Peaker> unnali, interesting that clang and not gcc is used by cabal install of glfw
07:35:14 <lambdabot>   [3,4,5,6,7,8,9,10,11,12]
07:35:48 <unnali> Peaker: OS X is weird like that. it seems to prefer clang everywhere, causes a headache with just about every possible build.
07:35:50 <Peaker> > let map' f = foldr ((:) . f) [] in map' (+3) [0..9]
07:35:52 <lambdabot>   [3,4,5,6,7,8,9,10,11,12]
07:36:09 <adamt> unnali: can't you just install gcc, fix some paths, and be done with it? :)
07:36:11 <unnali> !
07:36:15 <unnali> no no, gcc's installed
07:36:24 <unnali> success with CC=gcc CXX=g++ cabal install
07:36:30 <unnali> okay, I'll fix up BerkeleyDB and then we should be on our way.
07:36:43 <Peaker> wow, clang doesn't know about gcc's __attribute__? How does anything at all work
07:36:48 <unnali> :D
07:36:53 <Peaker> unnali, \O/
07:38:44 <hpaste> “Ben Gamari” pasted “Stack overflow” at http://hpaste.org/69333
07:39:13 <bgamari> Does anyone see why the above stack overflows?
07:39:24 <bgamari> It's short enough that it should be pretty easy for qualified eyes to see
07:39:36 <bgamari> sadly my eyes apparently don't fit that description
07:41:01 <ClaudiusMaximus> bgamari: try Data.Vector.Unboxed.Mutable  - you're getting (+1) thunks building up in the boxed vector
07:41:15 <ClaudiusMaximus> bgamari: probably - i didn't try it to be sure
07:41:21 <bgamari> ClaudiusMaximus: Alright, fair enough. that does make sense
07:41:39 <Peaker> @hoogle .!
07:41:40 <lambdabot> No results found
07:41:43 <Peaker> @src ($!)
07:41:44 <lambdabot> f $! x = x `seq` f x
07:41:58 <bgamari> ClaudiusMaximus: I was thinking of using newtypes and other richer data structures, hence the use of boxed vectors
07:42:18 <bgamari> and the recent post to libraries@haskell
07:42:31 <Peaker> maybe it could be useful to have     (f .! g) x = f (g $! x)
07:42:33 <bgamari> I do wish that Unboxed wasn't such a pain to work with
07:42:37 <unnali> Peaker: now I'm failing to install BerkeleyDB :|
07:42:43 <Peaker> then bgamari could use .! (+1)
07:42:46 <bgamari> Peaker: True
07:42:54 <Peaker> unnali, what is the error?
07:43:03 <ClaudiusMaximus> bgamari: right - then you could have    modify v i f = do{ x <- read v i ; write v i $! f x }
07:43:29 <hpaste> unnali pasted “bottle deps failure (BerkeleyDB)” at http://hpaste.org/69335
07:43:47 <Peaker> unnali, probably the wrong version of db
07:43:50 <unnali> Peaker: trying an alternate version of db, I just picked "berkeley-db" from homebrew.
07:43:52 <ClaudiusMaximus> Peaker: ah nice, that could be handy
07:43:53 <unnali> trying berkeley-db4
07:44:02 <Paprikachu> > let reverse' = foldl (flip (:)) [] in reverse' [1,2,3,4]
07:44:04 <lambdabot>   [4,3,2,1]
07:44:41 <ClaudiusMaximus> Peaker: what about (f !. g) x = f $! g x   -- would that also be useful?
07:45:05 <Peaker> unnali, the package says  "This is a work in progress: The coverage of the Berkeley DB API is not yet complete. Tested with Berkeley DB versions 4.7 and 4.8, but should work with earlier versions."
07:45:20 <Peaker> ClaudiusMaximus, yeah, and !.! too? :)
07:45:33 <unnali> hah, so it does! Thanks, Peaker. Here goes ...
07:45:48 <unnali> ugh
07:46:01 <Peaker> ClaudiusMaximus, to make a function strict on its arg, you just need to write it in a section (f $!),  so you could just (f $!) .! g
07:46:06 <unnali> looks like using a different compiler for FTGL cf. GHC is causing issues.
07:46:14 <unnali> Peaker: I'll try again tomorrow, right now I need to sleep.
07:46:44 <ski> `f .! g = f . strict g', `f !. g = strict f . g' where `strict f !a = f a'
07:47:05 <hpaste> unnali pasted “bottle deps failure (wrong arch? clang/gcc clash?)” at http://hpaste.org/69336
07:47:08 <Peaker> strict f = (f $!)
07:47:09 <bgamari> ClaudiusMaximus: That did it, thanks!
07:47:11 <ski> yes
07:47:12 <b_jonas> these language extensions (and I mean the type system ones, not the syntacitcal ones) haskellers invent! they're quite crazy
07:47:27 <b_jonas> every time you read one you think they can't top it
07:47:31 <Peaker> b_jonas, they all map to System F, that's how they know they aren't crazy :)
07:47:34 <b_jonas> but they always come up with something even less understandible
07:47:42 <Peaker> b_jonas, example?
07:48:01 <b_jonas> ghc 7.4.1 has constraints as types
07:48:44 <ski> because constraints are represented as types in the System F translation
07:48:59 <Peaker> b_jonas, that's very understandable?
07:49:07 <ClaudiusMaximus> @ask mgsloan how about strict 'plumbers'?  15:42 < Peaker> maybe it could be useful to have     (f .! g) x = f (g $! x)  15:44 < ClaudiusMaximus> Peaker: what about (f !. g) x = f $! g x   -- would that also be useful?
07:49:07 <lambdabot> Consider it noted.
07:49:10 <ski> might as well have them as types in Haskell as well
07:49:24 <ski> it's a (conceptially) simplifying generalization/merging
07:49:34 <b_jonas> wouldn't that cause all kinds of loops in type checking?
07:49:40 <Peaker> ClaudiusMaximus, I guess you could just do:   (f$!) . g      or   f . (g$!)   to make either side strict
07:49:50 <ski> b_jonas : i don't think so ?
07:49:55 <Peaker> maybe   f !. g = (f$!) . (g$!) makes sense
07:50:15 <b_jonas> I mean, even with not treating constraints as types, there's all kinds of complicated rules about multi-parameter typeclasses just so they can't loop.
07:50:48 <b_jonas> With type familes and type synonym families and dependent types and identity constraints all that stuff, this becomes worse.
07:51:14 <hpaste> untitled pasted “returning list of printables” at http://hpaste.org/69338
07:51:30 <untitled> guys, I'm trying to create a list of objects by calling a function, that returns those objects
07:51:41 <untitled> something goes wrong
07:51:44 <b_jonas> anyway, the docs does say that:
07:51:56 <b_jonas> "Presently, only standard constraints, tuples and type synonyms for those two sorts of constraint are permitted in instance contexts and superclasses (without extra flags). The reason is that permitting more general constraints can cause type checking to loop, ..."
07:52:13 <b_jonas> untitled: go on
07:52:59 <untitled> b_jonas: http://hpaste.org/69338
07:53:25 <Peaker> pArr=([printObj1 input) <-- seems like a parse error to me
07:54:25 <untitled> Peaker: emm, yes, but that's not the point, I just wrote it by hand in there
07:55:09 <untitled> the point is Couldn't match expected type `Printable' with actual type `[t0]'
07:55:25 <Peaker> untitled, need a full example..
07:56:51 <Peaker> untitled, I don't really understand your problem from half code :)
07:57:59 <untitled> the problem is that pArr doesn't get instances of Printable, it gets [t0]
07:58:14 <untitled> the way I'm trying to make this list is somehow wrong
07:58:36 <Paprikachu> isn't $ and . almost the same thing?
07:58:51 <mm|swarm> :t ($)
07:58:52 <lambdabot> forall a b. (a -> b) -> a -> b
07:58:56 <mm|swarm> :t (.)
07:58:57 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:59:05 <Paprikachu> if i have to function a and b and i want to call this function with x
07:59:07 <mm|swarm> almost
07:59:12 <Paprikachu> then these 2 are equivalent
07:59:21 <Paprikachu> a . b x
07:59:21 <mm|swarm> you ca do f . g $ x or f $ g $ x
07:59:27 <Paprikachu> a $ b x
07:59:33 <mm|swarm> or (f . g) x
07:59:36 <Paprikachu> err, yes
07:59:39 <Paprikachu> f $ g $ x
07:59:46 <t7> @hoogle (a -> b) -> (b -> c) -> (a -> c)
07:59:47 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
07:59:47 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
07:59:47 <lambdabot> Control.Parallel.Strategies (-|) :: (a -> b) -> Strategy b -> (b -> c) -> (a -> c)
07:59:55 <mm|swarm> > let f = (+1)
07:59:56 <lambdabot>   not an expression: `let f = (+1)'
08:00:07 <mm|swarm> > f x = x + 1
08:00:08 <lambdabot>   <no location info>: parse error on input `='
08:00:28 <Peaker> Paprikachu, ($) and (.) are related, but not nearly the same
08:00:47 <moonwi> @pl (\x y -> x:[y])
08:00:47 <lambdabot> (. return) . (:)
08:00:54 <nand`> > map ((+1) $ (*2)) [1..3]
08:00:55 <lambdabot>   [3,5,7]
08:00:56 <nand`> > map ((+1) . (*2)) [1..3]
08:00:58 <lambdabot>   [3,5,7]
08:01:15 <Paprikachu> o_O
08:01:22 <Paprikachu> the first doesn't make sense to me
08:01:41 <moonwi> concat $ zipWith ((. return) . (:)) "hlowrd" "el ol."
08:01:47 <Peaker> it may be a result of the fact you can replace:   f $ g $ x   with f . g $ x      but that's because changing ($) to (.) actually changes the parse-tree and the operator at the same time.  f $ (g $ x)  vs. (f . g) $ x
08:01:49 <nand`> Paprikachu: that's okay; it relies on lambdabot trickery
08:02:02 <S11001001> > ((+1) . (*2)) . [1..3]
08:02:04 <lambdabot>   [3,5,7]
08:02:08 <nand`> Paprikachu: specifically, Data.NumInstances
08:02:28 <nand`> S11001001: nice one
08:02:45 <nand`> > ((+1) $ (*2)) . [1..3]  -- maximum evil
08:02:47 <lambdabot>   [3,5,7]
08:02:54 <Paprikachu> what does this even mean
08:03:06 <nand`> Paprikachu: in lambdabot-land, (.) = fmap and functions are numbers
08:03:16 <S11001001> :t (.) :: (b -> c) -> (a -> b) -> a -> c
08:03:17 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
08:04:12 <nand`> (+1) $ (*2) = (*2) + 1; the Num instance for functions defines f + g = \x -> f x + g x; and 1 = const 1
08:04:40 <b_jonas> yeah, that's one of the more evil lambdabot addittions indeed
08:05:08 <b_jonas> it works even if stuff like f or x aren't even involved
08:06:13 <b_jonas> btw, in lambdabot what's the function that makes a symbolic function from a string the way var makes a symbolic variable from a string?
08:06:49 <nand`> :t fun "f"
08:06:50 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
08:07:33 <nand`> > let square = fun "square" in map square [1..3]
08:07:34 <lambdabot>   Ambiguous type variable `b' in the constraints:
08:07:34 <lambdabot>    `SimpleReflect.FromExpr ...
08:07:37 <nand`> :(
08:08:05 <nand`> > let square = fun "square" in map square [1..3] :: [Expr]
08:08:06 <lambdabot>   [square 1,square 2,square 3]
08:08:15 <moonwi> :t fun
08:08:16 <lambdabot> forall a. (SimpleReflect.FromExpr a) => String -> a
08:08:35 <untitled> Peaker: in fact I just want to know how to extract an inner type out of outer type in this line: SA PrintableArr {pArr=[printObj1 input obj1Arr i | i <- [0..(length obj1Arr)]] :: Printable}, I get Types, and want to get Printable
08:08:53 <untitled> data Types = S (Printable) | SA (PrintableArr) | N
08:09:41 <untitled> minus ":: Printable" :)
08:10:18 <Paprikachu> > nub [1,2,3,4,1,2,3,4]
08:10:19 <lambdabot>   [1,2,3,4]
08:10:53 <alpounet> @src fun
08:10:53 <lambdabot> Source not found. There are some things that I just don't know.
08:11:03 <nand`> alpounet: http://hackage.haskell.org/packages/archive/show/0.4.1.2/doc/html/src/SimpleReflect.html
08:11:11 <alpounet> hah thanks
08:11:14 <moonwi> > nubBy (==) [1,2,3,4,1,2,3,4]
08:11:15 <lambdabot>   [1,2,3,4]
08:12:14 <nand`> > nubBy (/=) [1,2,3,4,1,2,3,4,4]
08:12:15 <lambdabot>   [1,1]
08:15:07 <moonwi> > concat $ zipWith ((. return) . (:)) "hlowrd" "el ol."
08:15:09 <lambdabot>   "hello world."
08:19:11 <nand`> > concat .: zipWith (++) `on` map pure $ "hlowrd" "el ol."
08:19:12 <lambdabot>   Precedence parsing error
08:19:12 <lambdabot>      cannot mix `Data.Function.on' [infixl 0] and ...
08:19:20 <nand`> > (concat .: zipWith (++) `on` map pure) "hlowrd" "el ol."
08:19:22 <lambdabot>   "hello world."
08:19:25 <fmap>  concat $ transpose ["hlowrd", "el ol."]
08:19:28 <fmap> > concat $ transpose ["hlowrd", "el ol."]
08:19:29 <lambdabot>   "hello world."
08:19:55 <xplat> @remembery mauke < mauke> Paprikachu: Ableitung < Paprikachu> :O < Paprikachu> how do you know i speak german < mauke> Paprikachu: you once typo'd '?' as 'ß' < mauke> hmm, I should've said I'm Sherlock Holmes
08:19:55 <lambdabot> I will never forget.
08:20:18 <nand`> that was quite some latency
08:22:07 <danr> > foldl (.) id (zipWith ((.: (:)) . (:)) "hlowrd" "el ol.") ""
08:22:09 <lambdabot>   "hello world."
08:22:44 <moonwi> :t (.:)
08:22:45 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
08:23:06 <moonwi> hmm
08:26:06 <Jaak> @src (.:)
08:26:06 <lambdabot> Source not found. Do you think like you type?
08:26:21 <Jaak> :t (.)
08:26:22 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:26:27 <Jaak> aha, nice
08:26:49 <fmap> (.:) is fmap fmap fmap
08:27:09 <Jaak> or (.).(.) with is visually more... pleasing
08:27:13 <Jaak> whihc*
08:27:16 <Jaak> bah!
08:27:25 <fmap> no
08:27:37 <Paprikachu> > lines "foo\nbar"
08:27:38 <lambdabot>   ["foo","bar"]
08:27:42 <Jaak> :)
08:27:42 <Paprikachu> > lines "foo\nbar\n"
08:27:43 <lambdabot>   ["foo","bar"]
08:27:54 <Paprikachu> > lines "foo\nbar\n\n"
08:27:55 <lambdabot>   ["foo","bar",""]
08:28:42 <Paprikachu> > words "foo, bar"
08:28:43 <lambdabot>   ["foo,","bar"]
08:29:10 <moonwi> :t mempty :: Maybe a
08:29:12 <lambdabot>     Could not deduce (Monoid a) from the context ()
08:29:12 <lambdabot>       arising from a use of `mempty' at <interactive>:1:0-5
08:29:12 <lambdabot>     Possible fix:
08:29:33 <moonwi> :t mempty :: Maybe String
08:29:34 <lambdabot> Maybe String
08:29:35 <ezyang> Does anyone happen to know off hand whether or not it is better to write a traditional mutable data structure with lots of TVars for the pointers, or a persistent data structure with one TVar, when you don't need persistence?
08:30:05 <ezyang> Certainly in the Haskell ecosystem, the latter is easier, since most mutable data structures are not polymorphic in the reference type.
08:30:33 <adamt> Oh god, type sigs is almost impossible to figure out with Yesod.
08:32:47 <aristid> adamt: use ghci?
08:33:22 <adamt> aristid: Well, GHC 7.4.1 already proposes type sigs
08:33:45 <aristid> adamt: ok, so everything's cool?
08:33:59 <adamt> But when the type-sig is 10-lines long, and can't just post be copied over, then it's not easy. :P
08:36:03 <hpaste> adamt pasted “type-sigs” at http://hpaste.org/69339
08:36:43 <aristid> adamt: make some type synonyms, i think ghc will try to use them :)
08:37:26 <aristid> adamt: oh, your problem is just that you can't copy it over verbatim?
08:37:33 <aristid> adamt: just remove the forall foo bar. part
08:37:35 <adamt> aristid: Yes.
08:37:55 <adamt> :o
08:37:57 <adamt> oh nice.
08:38:24 <adamt> The Yesod scaffold already defined type synonyms for most things, it's just not that easy to deal with. Hehe.
08:38:30 <adamt> aristid: Thanks a lot.
08:38:54 <aristid> adamt: or you could enable -XExplicitForAll
08:39:02 <aristid> or -XRankNTypes as ghc suggests itself
08:39:26 <adamt> aristid: Considering i have no clue about what they do, i think it's better to leave them out. (for now) ;)
08:39:59 <aristid> -XExplicitForAll just enables that syntax
08:49:44 <adamt> oh, nub and nubBy are neat-o.
08:51:00 <paolino> hello , when I try to compile runST  . mapArray f ghc says it can't make m0 in forall s. ST s. Even with runSTArray . mapArray f . thaw I have the same problem. How is it supposed to be used mapArray in ST s ?
08:52:48 <Botje> what array are you mapping over?
08:52:55 <aristid> adamt: just be aware they are not necessarily fast:)
08:53:39 <paolino> Botje: STArray s  Int a
08:54:19 <paolino> in the second case an Array Int a
08:55:01 <fmap> paolino: what if you replace (.) with ($)
08:55:03 <fmap> ?
08:56:06 <paolino> fmap no more error
08:56:48 <fmap> i have no idea what it fixes but it helped me in similar issue with runSTArray
08:59:23 <c_wraith> it has to do with the compiler inferring a polymorphic type for a type parameter of a function.
08:59:30 <c_wraith> GHC never does that by default
08:59:57 <c_wraith> But it has some rules hacked in to make it sometimes do that in the case of $ and runST
09:06:40 <neptunewi> > 1
09:06:41 <lambdabot>   1
09:07:40 <paolino> It seems there is no MArray instance for my datatype as element. Is ite related to my datatype being a GADT ?
09:09:47 <mrothe> from ghci: *** Exception: user error (https not supported) <- how do I know which package/where this exception is created?
09:10:33 <paolino> From the docs there is a MArray (STArray s) e (ST s),  which seems ok for every 'e'
09:10:40 <dEPy> anyone know if leksah includes haskell or should I download and isntall it seperately
09:11:36 <matthiasgorgens> I am getting "warning: too many hs_exit()s" from running one of my haskell programs that also binds to libcurl.  Is that a warning coming from haskell (ghc to be precise) or libcurl?
09:11:40 <c_wraith> paolino: if it's a GADT, doesn't that imply different values tend to be different types? e can only be one concrete type
09:13:20 <c_wraith> paolino: furthermore, e has to be monomorphic, not polymorphic
09:13:39 <paolino> c_wraith: ok, which is the solution then ? deriving instance for each 'e' in the GADT ?
09:14:51 <fmap> dEPy: download and install it separately
09:15:13 <c_wraith> paolino: No, this is a case of the type of MArray just not even working. elements must all have the same monomorphic type.
09:15:57 <paolino> c_wraith: , from a functional pov, the implementation for any concrete 'e' should be ok for my values
09:16:27 <c_wraith> paolino: that doesn't matter. The problem is that you can't put multiple different types in the array. (STArray is boxed anyway, it doesn't care what your type is)
09:16:29 <paolino> c_wraith: and yes they have
09:16:56 <paolino> the same monomorphic type
09:17:10 <c_wraith> then...  STArray doesn't care.
09:17:34 <paolino> actually I'm mapping from one to another
09:17:42 <paolino> of the same GADT
09:18:08 <c_wraith> Well, I really have no clue what you're talking about.
09:18:27 <paolino> ok, I clean the code for a paste
09:21:06 <teneen> Are there higher-order types?
09:21:20 <ski> yes
09:21:22 <ski> @kind Mu
09:21:23 <lambdabot> (* -> *) -> *
09:21:27 <ski> @kind StateT
09:21:28 <lambdabot> * -> (* -> *) -> * -> *
09:22:06 <ski> @kind Either Int
09:22:07 <lambdabot> * -> *
09:22:20 <paolino> c_wraith: http://hpaste.org/69340
09:22:25 <ski> `Either' is a type function, it can accept two arguments (here given only one, so it expects one more)
09:22:38 <ski> @kind StateT String (Either Int)
09:22:39 <lambdabot> * -> *
09:22:46 <`Jake`> @kind Either
09:22:47 <lambdabot> * -> * -> *
09:23:09 <ski> `StateT' is a higher-order type function, it can accept three arguments, the first and the last being ordinary (non-function-)types
09:23:52 <ski> the middle one however being an argument type function (which `StateT' expects will accept one ordinary/concrete type argument, and "return" an ordinary/concrete type)
09:23:54 <teneen> so  a higher-order type is a type which can quantify over types which their kind contains (->) ?
09:24:11 <ski> "quantify" isn't the right word here
09:24:28 <ski> a higher-order type is a type which takes some type-functions as arguments
09:24:52 <ski> just like a higher-order value is a value (a function) which takes some (value-)functions as arguments
09:25:04 <teneen> isn't there an implicit quantifier in each type?
09:25:15 <ski> @let perLine f = unlines . map f . lines
09:25:17 <lambdabot>  Defined.
09:25:20 <ski> @type perLine
09:25:21 <lambdabot> (String -> String) -> String -> String
09:25:41 <ski> `perLine' is a higher-order (value-)function, because it accepts a (value-)function as argument
09:25:59 <ski> teneen : no quantifier, the relevant part here is the `->'
09:26:36 <ski> strictly speaking `A -> B -> C' is also higher-order, since it means `A -> (B -> C)' (so a function *returning* a function)
09:26:39 <teneen> (forall m a. m a) isn't this a higher-order type because m has kind (* -> *)?
09:27:04 <ski> however, `A -> B -> C' is more or less the same as `(A,B) -> C', so we usually don't count curried functions when we're talking about higher-order functions
09:27:15 <ski> teneen : no
09:27:23 <ski> @kind forall m a. m a
09:27:24 <lambdabot> *
09:27:41 <ski> the kind is `*', so it isn't even a type-function, much less a higher-order type-function
09:28:03 <c_wraith> paolino: I don't have a GHC that supports DataKinds at the moment..
09:28:11 <ski> maybe you're confusing the concept "higher-order type(-function)" with the concept "higher-ranked type" ?
09:28:18 <teneen> no
09:28:26 <ski> ok
09:28:33 <teneen> I think I'm talking about the language itself
09:28:37 <paolino> c_wraith: I rewrite that with empty data declarations
09:28:50 <ski> `forall m a. m a' isn't any more higher-order than `Mayba Int' is
09:28:51 <teneen> In first order logic you cannot quantify over predicates
09:29:01 <c_wraith> paolino: actually, I'm doing that already.
09:29:04 <ski> in the first, `m :: * -> *'; in the second `Maybe :: * -> *'
09:29:27 <ski> `map' is a higher-order function, but `map ord "abc"' isn't
09:29:55 <ski> and `\xs -> map ord (reverse xs)' isn't either a higher-order function (though it *is* a function)
09:30:13 <teneen> In logic to quantify over predicates you need a higher-order logic. What's the counter-part in types?
09:31:17 <ski> ok, i can see how you might be confused by "higher-order" here, if you compare it with "first-order logic","second-order logic",...,"higher-order logic"
09:32:23 <ski> i suppose if you know `forall x. exists_unique y. R(x,y)' in *first*-order logic
09:32:33 <ski> then this is comparable to having a function from `x' to `y'
09:32:54 <ski> e.g. with `x,y :: Int' so the function having type `Int -> Int'
09:33:57 <ski> but if we're in *second*-order logic, then `x' and/or `y' may be functions (over non-functions), and so we may get types like `Bool -> (Int -> Bool)', `(Int -> Bool) -> Int', `(Int -> Int) -> (Bool -> Bool)'
09:34:11 <ski> i.e. then we can (implicitly) express second-order functions
09:34:34 <ski> teneen : i'm not sure, but i suspect the connection between the terms (if any) is something like the above
09:35:03 <c_wraith> paolino: I think the problem is your use of ST is invalid.
09:35:51 <ski> teneen : however, if you want to compare formulae in logic with types in programming, then that's a different comparision (involving the BHK-interpretation or the Curry-Howard-correspondence or something similar
09:36:09 <teneen> ski: I guess your initial explanation that a higher-order type is a type that contains a type function (* -> *) is quite correct. And the language itself is higher-order since you can quantify over these types
09:36:41 <paolino> c_wraith: because of GADTs ?
09:36:59 <ski> teneen : under this comparision, a second-order formula in logic corresponds to a type in which you can quantify not only over concrete types (types in `*'), but also over ('first-order*) type-functions (in `* -> *', then)
09:37:00 <c_wraith> paolino: no.  completely irrelevant.  You're trying to do exactly what ST is designed to prevent
09:37:27 <c_wraith> paolino: Which is return a mutable cell from an ST computation
09:37:49 <ski> teneen : so this means that already the types in plain Haskell98 correspond to formulae in higher-order logic
09:38:24 <ski> (or more precisely, to prenex formulae, in the fragment not containing an existential quantifier)
09:38:52 <teneen> ski: yes
09:39:53 <teneen> ski: thanks :)
09:40:39 <paolino> c_wraith: even with data Carrello l  = Carrello Rank (Array Int (Prodotto Rational l) ) and runSTArray ..... (thaw xs) I have an error, different actually, more strange
09:41:38 <paolino> inaccessible code in a pattern
09:41:54 <c_wraith> huh.  I've never seen that before.
09:44:50 <ski> @type Data.Array.MArray.thaw
09:44:51 <lambdabot> forall (a :: * -> * -> *) i e (m :: * -> *) (b :: * -> * -> *). (Ix i, Data.Array.Base.IArray a e, Data.Array.Base.MArray b e m) => a i e -> m (b i e)
09:45:23 <ski> @type Data.Array.MArray.freeze
09:45:25 <lambdabot> forall (a :: * -> * -> *) i e (m :: * -> *) (b :: * -> * -> *). (Ix i, Data.Array.Base.MArray a e m, Data.Array.Base.IArray b e) => a i e -> m (b i e)
09:46:02 <ski> paolino : did you use something like `runST (freeze =<< mapArray (...) =<< thaw xs)' ?
09:46:21 <c_wraith> Honestly, if your code is using Array, there's no reason to go through ST and use mapArray at that point.
09:46:28 <c_wraith> You can just use toList and fromList
09:46:39 <c_wraith> mapArray doesn't mutate anyway
09:47:24 <ski> @type Data.Array.MArray.mapArray
09:47:26 <lambdabot> forall e' e (a :: * -> * -> *) i (m :: * -> *). (Data.Array.Base.MArray a e' m, Data.Array.Base.MArray a e m, Ix i) => (e' -> e) -> a i e' -> m (a i e)
09:48:15 <c_wraith> well.  toList, map, and fromList
09:55:07 <paolino> c_wraith: that is one function, not the reason for introducing ST. There is another function, not relevant to this error
09:55:43 <mparodi_> hello guys
09:56:12 <paolino> ski, I see now thaw is monadic ....
09:57:09 <moebius_eye> > 245 / 60
09:57:10 <lambdabot>   4.083333333333333
09:57:15 <mparodi_> is there any syntax to apply a function to two identical values? foo f x | bar x = f (yada x) (yada x) | otherwise = f (zaz x) (zaz x)
09:58:08 <mparodi_> I guess I can use the laziness in that way: foo f x | bar x = f h h | otherwise = f t t where h = yada x; t= zaz x
09:58:11 <parcs`> > join (+) 1
09:58:12 <lambdabot>   2
09:58:26 <mparodi_> is there any better way without "where"?
09:58:34 <jfischoff> :t join
09:58:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
09:59:04 <mparodi_> was it to me?
09:59:14 <mparodi_> @src join
09:59:14 <lambdabot> join x =  x >>= id
09:59:53 <parcs`> yes, join takes a function accepting two identical arguments and returns a function accepting one
10:00:02 <paolino> ski, that resolves the issues with Array, thanks. I'm left with understanding the ones with STArray
10:00:06 <mparodi_> alright, thank you
10:00:24 <mparodi_> I still don't know what the monads are
10:00:32 <parcs`> magic
10:00:35 <mparodi_> but I guess I can use it anyway
10:02:54 <parcs`> :t undefined :: Proxy a
10:02:54 <lambdabot> Not in scope: type constructor or class `Proxy'
10:05:08 <mparodi_> @instances Num
10:05:09 <lambdabot> Double, Float, Int, Integer
10:06:16 <paolino> c_wraith: thanks, you are right MArray (STArray s) (Prodotto Rational Convergente) (ST s1)), s /= s1, that is why there is no instance. Moral, I can't have the s type parameter in my data types, out of runST
10:06:22 <sp3ctum> @src Num
10:06:22 <lambdabot> class  (Eq a, Show a) => Num a  where
10:06:22 <lambdabot>     (+), (-), (*)           :: a -> a -> a
10:06:22 <lambdabot>     negate, abs, signum     :: a -> a
10:06:22 <lambdabot>     fromInteger             :: Integer -> a
10:06:53 <c_wraith> paolino: yeah..  That leak of s was the real issue.
10:07:07 <mparodi_> @index join
10:07:07 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
10:07:41 <paolino> c_wraith: I must read the docs and errors slower
10:14:51 <ski> paolino : you can't return an `STArray s i a' out from a `runST' (assuming they use the same `s' type, i.e. they run in the same "state thread")
10:15:54 <ski> mparodi_ : that uses `instance Monad (rho ->) where return a = \rho -> a; rho_a >>= a_rho_b = \rho -> a_rho_b (a_rho rho) rho'
10:16:31 <ski> mparodi_ : then `join f  =  f >>= id  =  \rho -> id (f rho) rho  =  \rho -> f rho rho'
10:16:55 <mparodi_> actually I added a join function so I don't have to deal with monads, ie: foo ... = ... join ... where join f x = f x x
10:17:07 <ski> works as well
10:20:02 <ski> mparodi_ : your `join' is also known as `warbler' (see figure 13 in "To Dissect a Mockingbird: A Graphical Notation for the Lambda Calculus with Animated Reduction" by David C. Keenan in 1996-08-27 - 2009-11-20 at <http://dkeenan.com/Lambda/>)
10:24:52 <applicative> what does an ocamler mean by the ampersands in this,  w l @ (if v = w then [u] else []) @ f w r   I'm trying to translate something
10:25:34 <ski> applicative : `@' corresponds to `++' in Haskell
10:25:43 <applicative> ski thanks
10:25:53 <applicative> I have known that
10:26:00 <byorgey> also, & is ampersand, @ is 'at'
10:26:03 <ski> and `^' is concatentation for strings
10:26:42 <applicative> i freaked thinking it was syntax, as @ is for us
10:29:37 <ski> applicative : `<var> @ <pat>' in Haskell corresponds to `<var> as <pat>' in SML, and to `<pat> as <var>' in O'Caml
10:31:08 <applicative> yes I wasn't inclined to read it as our @ but had momentary difficulty seeing it as expressing a function because of my dubious haskelly background
10:32:50 <shevy> hmm first time I see http://hackage.haskell.org/platform/ how old is that?
10:33:27 <ski>   "Current stable release: 2011.4.0.0 (December 2011)"
10:33:38 <ski>   "Next release: May 2012"
10:33:50 <applicative> shevy: theres another one coming out any day
10:33:59 <applicative> what operating system are you using shevy
10:34:02 <tertl3> i refuse to update
10:34:11 <shevy> applicative linux... hmm but I read that I need ghc anyway ...
10:34:24 <shevy> 3 years ago I think I just downloaded ghc
10:34:42 <tertl3> what is applicative linux?
10:34:52 <ski> (you need an executable GHC to build GHC from source, yes)
10:34:59 <applicative> tertl3: excellent distro
10:35:14 <tertl3> link me up plz
10:35:24 <ski> like linux, but using applicative functors for most effects, instead of monads
10:35:26 <applicative> shevy, you need ghc and cabal from your package manager for sure
10:35:40 <applicative> lax monoidal linux
10:36:28 <mzero> shevy - platform includes GHC in both Mac and Windows distributions - and some linux distros
10:37:05 <applicative> shevy, it might be that you want some leading libraries from your package manager as well, I'm not sure.
10:37:29 <mparodi_> @instances Num
10:37:30 <lambdabot> Double, Float, Int, Integer
10:38:19 * tertl3 parsing error
10:38:23 <applicative> shevy, in principal I think a haskell-platform or ghc-haskell-platform from your package manager is a good idea.  After that you can install libraries locally with cabal install
10:38:44 <shevy> hmm
10:39:11 <applicative> shevy: then it is easy to chuck the local ones and start over for one thing, leaving the fundamental machinery intact
10:39:50 <applicative> mzero can say when 'new haskell platform' will be announced, but it is another question when a given distribution will carry it
10:39:59 <jonaskoelker> in ghci, can I set it's module search path (i.e. -i arguments)?
10:43:15 <applicative> shevy if you haven't used haskell before, its obvious thing.
10:44:15 <shevy> applicative I've dabbled a little bit in haskell some years ago
10:44:23 <applicative> ah i see
10:44:43 <shevy> applicative I am struggling more with my system than anything else right now though ;) rpmdrake wants to download 394MB for haskell... that boggles my mind a bit too much right now
10:45:14 <applicative> hm, but just ghc and cabal wouldn't be so bad? or are they what you mean :)
10:45:40 <geekosaur> jonaskoelker, ":set -iwhatever" works
10:45:58 <shevy> I am not sure... there is not that much information available through rpmdrake. just that it needs that much space...
10:46:22 <adamt> shevy: get the binary GHC from the website, and cabal-install. it's like 6 commands in total to get a system running. ^^
10:46:49 <adamt> wait, more like 8, when counting the tar -x's
10:46:57 <Peaker> shevy, everything's cartesian-compiled against threading enabled/disabled and profiling enabled/disabled
10:47:10 <Peaker> so every compiled thing is 4 times larger than it could be
10:49:39 <jjl_> sounds like a great deal of fun on osx with universal binaries ;)
10:49:58 <applicative> hm, it does look like the rpms are trying to get you to get the whole platform.  as Peaker says it includes profiling versions alongside everything
10:51:45 <adamt> sorry, i should read more carefully.
10:53:05 <applicative> shevy I notice the rpm is much more up  to date than what youd see on the website, "update to ghc-7.4.1 and latest libraries" "update to cabal-0.14 "
10:53:24 <shevy> hehe
10:53:32 <shevy> the rpmdrake one says ghc 7.0.4
10:53:50 <applicative> to judge from this  http://arm.koji.fedoraproject.org/koji/buildinfo?buildID=69490  Is that the relevant one
10:54:37 <applicative> hm, is see, maybe I hit on the wrong page
10:54:41 <applicative> ?
10:55:07 <shevy> no idea right now hmm
10:55:35 <shevy> I am going to punch my computer in the stomach for a while though
10:55:43 * applicative is rpm ignorant
10:56:11 <tertl3> knock 'em for a good one shevy
10:57:27 <applicative> shevy, have you done something to update I notice there are revisions from the last three weeks
10:58:13 <applicative> shevy: anyway there's probably no way around it that its big, see the deluxe ingredients http://arm.koji.fedoraproject.org/koji/rpminfo?rpmID=279725
10:58:17 <shevy> applicative, to my knowledge I havent done anything. I do however sometimes manage to break things after a while
10:58:29 <armlesshobo> which lib would you all recommend I use for mysql?
10:58:40 <armlesshobo> i see a bunch of options doing a cabal list
11:01:32 <applicative> armlesshobo: I know jack about mysql, but I notice http://hackage.haskell.org/package/mysql and http://hackage.haskell.org/package/mysql-simple are written by b o'sullivan
11:01:45 <applicative> which gives me some ground for confidence :)
11:02:38 <mparodi_> to debug a code, how can I execute something and print "foo" after/before that?
11:02:58 <applicative> import Debug.Trace (trace) ?
11:03:24 <applicative> then write mynumber = 3 + 7 * (trace "eight" 8)
11:03:40 <mparodi_> for example, foo x = putStr "foo" >> x+1
11:03:41 <applicative> and it will say: eight when it evaluates 8
11:03:50 <armlesshobo> applicative: lol that's good to know
11:04:32 <applicative> mparodi_: if its just for testing, Debug.Trace does that for you, by shamelessly using unsafeperformio
11:04:48 <applicative> mparodi_: you get rid of it after you figure out what was wrong
11:05:23 <applicative> or do like the jhc source and toggle between import Debug.Trace (trace) and trace str x = x :)
11:05:52 <mparodi_> is there a trace :: String -> IO() ?
11:05:58 <mparodi_> I don't want to put a condition
11:06:41 <applicative> the trouble with your example foo x = putStr "foo" >> x+1 is that x+1 is presumably something like an Int
11:07:15 <mekeor> how do i best write a function that extracts the definition of a function from a (haskell) source code? i mean, how do i have to design such a function best?
11:07:33 <applicative> i think the intended effect of foo x = putStr "foo" >> x+1 is exactly that of foo x = trace "foo" (x+1)
11:08:00 <mparodi_> applicative, actually yes, thanks
11:08:43 <xplat> 03:26 < greymalkin> But I'm still trying to grok why on earth you'd use both vim and emacs. <-- because you're a unitarian?
11:08:47 <applicative> @quote Debug
11:08:47 <lambdabot> Knuth says: The conventional wisdom shared by many of today's software engineers call for ignoring efficiency in the small; but I believe this is simply an overreaction to the abuses they see being
11:08:47 <lambdabot> practiced by pennywise-and-pound-foolish programmers, who can't debug or maintain their "optimized" programs.
11:08:52 <applicative> no
11:08:56 <Eduard_Munteanu> mekeor: haskell-src(-exts)?
11:08:59 <applicative> @quote chromatic
11:08:59 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
11:09:07 <applicative> ^^^ sublime !!!
11:09:42 <mekeor> Eduard_Munteanu: more preciseyl, i want to parse Idris-sourceCode which has a very similar syntax.
11:09:57 <xplat> personally i use them both in different situations, depending on things like workflow and the qualities of their respective editing modes
11:10:40 * applicative uses nano and textmate
11:10:48 <Eduard_Munteanu> mekeor: how similar is it, syntactically?
11:10:53 * applicative uses emacs for agda, what torture
11:11:03 <Eduard_Munteanu> mekeor: I mean, could it pass as valid Haskell?
11:11:58 <applicative> it's awfully similar
11:12:15 <Eduard_Munteanu> applicative: I don't believe you, why aren't you in #agda? :P
11:12:38 <applicative> not sure, I think theyre a little surly arent they?
11:12:57 <mparodi_> wow! I love exponentiation by squaring... I wrote a script to calculate fibonacci numbers. it takes a couple of seconds to calculate fibonacci 50000000 (10449382 digits!)
11:13:45 <applicative> wait i'm not following, what don't you believe Eduard_Munteanu ?
11:13:45 <Eduard_Munteanu> applicative: pretty much the same people from #haskell, actually
11:13:56 <Eduard_Munteanu> Using Agda :P
11:13:57 <applicative> Yeah, I know, just surlier
11:14:00 <lazyfinn> Hello, how do I update one field of each record in a list of records? map (+1) (name Persons), something similar?
11:14:14 <applicative> Oh I'm an agda user, not particularly skilled
11:14:27 <yywi> > putStrLn "hello"
11:14:28 <lambdabot>   <IO ()>
11:14:37 <applicative> i did a lot in the winter when i was trapped in Jerusalem.
11:14:58 <applicative> I mean, that was the most recent spell of it
11:15:23 * applicative considers that agda is almost as beautiful as jerusalem
11:16:03 <lazyfinn> anyone?
11:16:30 <shachaf> lazyfinn: map (\p -> p { name = name p + 1 })
11:16:52 <shachaf> Alternatively, look at lenses.
11:17:16 <shachaf> Then you'd be able to say something like map (modify name (+1))
11:17:41 <lazyfinn> ok, greets
11:17:51 <yywi> let y f = f $ y f
11:19:14 <hpaste> applicative pasted “bbauer” at http://hpaste.org/69343
11:19:42 <applicative> Eduard_Munteanu: check out ludicrous syntax from on of my equality crazes ^^^
11:19:47 <mekeor> Eduard_Munteanu: it couldn't pass as valid haskell. e.g. it uses : instead of ::.
11:19:48 <applicative> one of
11:20:31 <applicative> Eduard_Munteanu: attempting to port of a bit of coq of a. bauer
11:23:46 <hpaste> applicative annotated “bbauer” with “bbauer (annotation)” at http://hpaste.org/69343#a69344
11:23:51 <applicative> Eduard_Munteanu: haha, i just found a tiny bit of the same in idris so you can see what it looks like
11:23:56 <applicative> ^^^
11:39:02 <jfischoff> is there utility that will convert "open" imports to explicit item list imports?
11:40:00 <shachaf> jfischoff: I think Evan Laforge had a utlity that had to do with import lists.
11:40:10 <shachaf> Hmm, but I think he just uses qualified imports for everything.
11:40:21 <applicative> ghc -ddump-minimal-imports
11:40:44 <jfischoff> applicative: cool thanks I'll give that a shot
11:41:21 <gdoteof> is there existing magic that turns tuples into csv files?
11:41:37 <gdoteof> and/or xls
11:42:22 <hayashi> @pl \a b -> a ++ c ++ b
11:42:22 <lambdabot> (. (c ++)) . (++)
11:42:45 <tazjin> gdoteof: There's a csv module, http://hackage.haskell.org/packages/archive/csv/0.1.2/doc/html/Text-CSV.html
11:43:36 <mparodi_> @src logBase
11:43:37 <lambdabot> Source not found. It can only be attributed to human error.
11:43:55 <armlesshobo> @src LogBase
11:43:55 <lambdabot> Source not found. Wrong!  You cheating scum!
11:44:01 <armlesshobo> lol
11:45:31 <hayashi> @src maybe
11:45:31 <lambdabot> maybe n _ Nothing  = n
11:45:32 <lambdabot> maybe _ f (Just x) = f x
11:47:03 <hpaste> lazyfinn pasted “somecode” at http://hpaste.org/69345
11:47:11 <lazyfinn> what's wrong with this code?
11:49:33 <JoeyA> ref <- newIORef undefined
11:50:01 <JoeyA> Here, ref is of type IORef a, for any a, but it only gets to be one a.
11:50:11 <jfischoff> ++applicative
11:51:15 <JoeyA> Likewise, when the monomorphism restriction is on and you have len = genericLength without a type signature, len has type Num i => [b] -> i, but can only have one type of 'i'.
11:51:35 <JoeyA> ref and len are both "monomorphic" in the same sense, I would argue.
11:51:35 <cg_morton> lazyfinn: are you trying to modify the Persons in the array?  because haskell is immutable so that won't work, you need to return the modified array
11:52:30 <lpsmith> Why isn't there an addUTCTime :: DiffTime -> UTCTime -> UTCTIme?   Instead there is only a nominalDiffTime
11:52:34 <cg_morton> updateName persons = map (\r -> r { name = name r ++ "ton" }) persons
11:52:48 <cg_morton> would be much simpler
11:53:41 <lazyfinn> cg_morton: uh, ok
11:53:59 <cg_morton> though I'm not at all familiar with how you're using record syntax there either, so that might also be a problem
11:55:36 <lazyfinn> cg_morton: well, just passing it function, no more
11:55:42 <lazyfinn> to*
12:01:17 <byorgey> lpsmith: because such a function would also have to take a table of leapseconds as an argument
12:02:17 <ski> JoeyA : yes
12:02:51 <lpsmith> byorgey, right, but lets say you want to time something to happen every other second or whatever,  to do that (without drift) would seem to require this exact function.
12:03:06 <JoeyA> ski: Continuing that train of thought: Int -> Int is monomorphic in a different sense.
12:03:20 <ski> not really
12:03:22 <JoeyA> Is there a word for types that are monomorphic in the first sense?
12:03:30 <JoeyA> Or is "monomorphic" the right word?
12:03:34 <ski> yes
12:03:43 <JoeyA> If so, then http://www.haskell.org/haskellwiki/Monomorphism needs to be updated.
12:03:57 <ski> in your `ref' case you have `ref :: IORef a', not `ref :: forall a. IORef a'
12:03:59 <JoeyA> It calls foo :: (Int -> Int) -> [Int] -> [Int] monomorphic
12:04:06 <ski> the `forall a.' would have made it polymorphic
12:04:07 <lpsmith> hmm
12:04:10 <mparodi_> can I becnchmark the execution of a function? I want to know how many seconds it takes
12:04:26 <ski> (but the fact that you can be implicit about `forall's confuses the picture a little)
12:04:43 <geekosaur> mparodi_, try the criterion package?
12:04:46 <ski> in your len case, you get `len :: forall b. Num i => [b] -> i'
12:04:54 <mparodi_> criterion?
12:04:56 <ski> so it's polymorphic in `b', but not in `i'
12:05:01 <byorgey> lpsmith: if you really care about that, then you can use the stuff in Data.Time.Clock.TAI, in conjunction with http://hackage.haskell.org/package/leapseconds-announced
12:05:03 <mparodi_> @hoogle criterion
12:05:04 <lambdabot> package criterion
12:05:04 <lambdabot> package criterion-to-html
12:05:10 <JoeyA> Here's very simple usage of criterion: http://hpaste.org/65318
12:05:15 <ski> JoeyA : yes, that is also monomorphic
12:05:28 <JoeyA> (though that benchmarks an action, not a pure function)
12:05:42 <lpsmith> I do see your point;   such a function is almost morally correct,  but not really.   If GHC were to magically have a table of leap seconds,  and used a function  addUTCTime :: DiffTime -> UTCTime -> UTCTime,   then results could vary depening on whether you did the computation before or after the leapsecond was announced
12:05:48 <ski> JoeyA : it's monomorphic if there's no `forall' (not even an implicit one) at the "toplevel" of the type
12:05:53 <lpsmith> byorgey, I'm not sure I do,  but thanks for the pointers!
12:06:12 <JoeyA> ski: What's a good way to say that something has monomorphic type variables?  What I just said?
12:06:39 <mparodi_> Could not find module `Criterion.Main':
12:06:43 <JoeyA> e.g. ref :: IORef a, where a is bound elsewhere
12:06:53 <JoeyA> mparodi_: cabal install criterion
12:06:59 <ski> JoeyA : if it's not completely monomorphic (like in `len'), you can say it's "monomorphic *in*" some type variable(s)
12:07:27 <mparodi_> ok, thanks
12:07:44 <ski> JoeyA : consider `map :: (a -> b) -> ([a] -> [b])'
12:07:45 <JoeyA> ski: len is monomorphic in a type variable: Num i => [a] -> i
12:07:49 <JoeyA> Right?
12:08:04 <ski> JoeyA : this really means `map :: forall a b. (a -> b) -> ([a] -> [b])', when we're explicit about the `forall's
12:08:15 <JoeyA> Right
12:08:25 <ski> JoeyA : well -- for `len' it depends e.g. on the DMR
12:08:51 <JoeyA> ski: Assume it's on.
12:09:03 <ski> surely e.g. `genericLength' is polymorphic
12:09:35 <ski> the DMR, in certain circumstances, forces type variables in the signature of an operation to become monomorphic
12:10:10 <ski> namely, those (free) type-variables which are constrained by `cxt' in a `cxt => ' context
12:10:33 <ski> and the DMR strikes if two thinks happen at the same time
12:10:52 <lpsmith> hmm, I'm not sure how I missed the TAI module for so long.  Probably because I don't know enough about time.
12:11:01 <ski>   (a) the operation is defined with no arguments to the left of the `='
12:11:10 <ski>   (b) there is no explicitly given type signature
12:11:35 <ski> so, you can always disable the DMR in a specific case by writing an explicit type signature
12:11:42 <ski> if you write
12:11:46 <ski>   f x = ..x..
12:11:46 <JoeyA> ski: I was about to respond to http://www.reddit.com/r/haskell/comments/udnx2/understanding_haskells_monomorphism_restriction/
12:12:05 <ski> (or similar, but with pattern-matching, and possibly several defining equations)
12:12:09 <ski> then it's not strike
12:12:13 <ski> but if you write
12:12:17 <ski>   f = \x -> ..x..
12:12:18 <ski> e.g.
12:12:27 <ski> or if you're not defining a function
12:12:31 <ski>   myParser = do
12:12:33 <ski>     ...
12:12:38 <ski> then it'll also strike
12:13:22 <JoeyA> I understand the monomorphism restriction.  Here's my intuition of it: things that are polymorphic without the help of a type class (e.g. id, map) are truly polymorphic.  map does not have to change its behavior depending on whether the argument is [Int] or [String]
12:13:46 <ski> JoeyA : however, whether something is monomorphic or not (and "how much") is a general concept, and the DMR is just one use of it
12:13:55 <statusfailed> Is there a good way to systematically measure and test performance?
12:14:03 <ski> so, consider again
12:14:04 <ski>   map :: forall a b. (a -> b) -> ([a] -> [b])
12:14:13 <statusfailed> like QuickCheck for performance, maybe? :)
12:14:30 <tgeeky> is it possible to enter something like:  @let unhom g f p q = k where k v | p v = []; | q v = [f v]; | (l,r) g v = k l ++ k r   -- in lambdabot?
12:14:43 <ski> JoeyA : yes
12:15:14 <ski> (though i would say it's "truly polymorphic" even if there's constraints -- but perhaps not "fully polymorphic")
12:15:25 <mparodi_> JoeyA, http://paste.kde.org/490940
12:15:27 <JoeyA> When a type class is brought into the picture, the value has to "do" something different depending on its type.
12:15:45 <JoeyA> Since Haskell is purely functional, doing something different does not affect the semantics of the language.
12:15:46 <ski> JoeyA : when we define `map f ... = ..f..', then i claim that `f :: a -> b' here is *monomorphic*
12:15:47 <ClaudiusMaximus> tgeeky: if it doesn't work, maybe   s/; |/ |/g
12:15:58 <JoeyA> err, that wasn't very clear
12:16:08 <tgeeky> ClaudiusMaximus: that didn't work either, but I got a type error
12:16:11 <ski> (no it wasn't)
12:16:15 <tgeeky> @let unhom g f p q = k where k v | p v = [] | q v = [f v] | (l,r) g v = k l ++ k r
12:16:15 <lambdabot>  <local>:7:55:
12:16:16 <lambdabot>      Couldn't match expected type `t -> t1 -> Bool'
12:16:16 <lambdabot>           ...
12:16:22 <mparodi_> any suggestion? http://paste.kde.org/490940
12:16:34 <JoeyA> Since Haskell is purely functional, something being evaluated twice does not affect semantics (bottoms aside)
12:16:55 <ClaudiusMaximus> tgeeky: (l,v) g v ?
12:16:57 <mparodi_> (I'm trying to install criterion to benchmark a code)
12:17:02 <mparodi_> s/code/function/
12:17:07 <tgeeky> ClaudiusMaximus: oops!
12:17:08 <ClaudiusMaximus> tgeeky: (l,r) is not a function
12:17:20 <tgeeky> ClaudiusMaximus: yep. missing a <-
12:17:27 <JoeyA> mparodi_: What version of GHC?
12:17:28 <tgeeky> ClaudiusMaximus: but now I got "pattern guards not enabled" which pretty much ends it
12:17:33 <tgeeky> @let unhom g f p q = k where k v | p v = [] | q v = [f v] | (l,r) <- g v = k l ++ k r
12:17:33 <lambdabot>   PatternGuards is not enabled
12:17:36 <tgeeky> ;(
12:17:42 <mparodi_> Glasgow Haskell Compiler, Version 7.0.4, for Haskell 98, stage 2 booted by GHC version 7.0.4
12:17:45 <applicative> mparodi_: grr
12:17:45 <mparodi_> JoeyA, ^
12:17:54 <mparodi_> applicative, ?
12:18:07 <applicative> mparodi_: what version of ghc are you using, on what platform?
12:18:18 <mparodi_> I already said that
12:18:24 <mparodi_> 7.0.4 on Debian
12:18:33 <applicative> oh i didn't see, just the link
12:18:38 <applicative> hmm
12:18:46 <ClaudiusMaximus> :t unhom g f p q = k where k v | p v = [] | q v = [f v] | otherwise = case g v of (l,r) -> k l ++ k r   -- tgeeky, is this equivalent?
12:18:47 <lambdabot> parse error on input `='
12:18:56 <mparodi_> isn't there any other way to benchmark? :P
12:19:06 <ClaudiusMaximus> :t let unhom g f p q = k where k v | p v = [] | q v = [f v] | otherwise = case g v of (l,r) -> k l ++ k r in unhom   -- tgeeky, is this equivalent?
12:19:07 <lambdabot> forall t a. (t -> (t, t)) -> (t -> a) -> (t -> Bool) -> (t -> Bool) -> t -> [a]
12:19:20 <JoeyA> ski: I mean, what I said wasn't very clear.  What you said makes sense ;-)
12:19:21 <tgeeky> ClaudiusMaximus: yep, looks exactly right
12:19:31 <t7> so is the new platform out tonight, or did SPJ LIE!?
12:19:31 <ski> JoeyA : yeah, i know ..
12:19:36 <ski> JoeyA : anyway, to make my point about `map' here, i want to pass types explicitly in the code. e.g. instead of saying `length "foo"', i'll say `length_Char "foo"' to emphasize that `length' conceptually first takes a type argument
12:20:01 <applicative> mparodi_: have you done 'cabal update' lately, not that i am advising it at the moment
12:20:07 <mparodi_> yep, a minute ago
12:20:08 <JoeyA> Well, length_Int [...]
12:20:14 <JoeyA> length doesn't care about the items themselves.
12:20:21 <ski> yes
12:21:38 <ski> JoeyA : so the code for `map' would then become
12:21:42 <ski>   map :: forall a b. (a -> b) -> [a] -> [b]
12:21:46 <ski>   map_a_b = loop
12:21:48 <ski>     where
12:21:52 <ski>     loop :: (a -> b) -> [a] -> [b]
12:21:57 <ski>     loop f [    ] = [             ]
12:21:59 <ski>     loop f (x:xs) = f x : loop f xs
12:22:35 <ski> note that as we reach `loop', we have two *specific* types `a' and `b' (it's just that we don't know *which* types they are, but they're still specific)
12:22:48 <ski> so, `loop' in here is *not* polymorphic, it's monomorphic
12:22:52 <ski> and so is `f'
12:23:09 <ski> so, `map' is the polymorphic function here, since it's the one that takes the type arguments
12:23:38 <tgeeky> ClaudiusMaximus: thanks. Here's what I made:
12:23:42 <tgeeky> > map fiblist [0..6]
12:23:44 <lambdabot>   [[1],[1],[1,1],[1,1,1],[1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1...
12:23:46 <ski> then, having fixed them, it (conceptually) makes a `loop' which works for these two specific types
12:23:48 <tgeeky> > map (length . fiblist) [0..10]
12:23:50 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89]
12:24:05 <ski> and then `loop' is just an ordinary non-polymorphic function which loops around
12:24:05 <mparodi_> ok, I guess I won't be able to benchmark it >_>
12:24:35 <ski> JoeyA : this is known as "monomorphic recursion"
12:24:37 <ski> @src map
12:24:37 <lambdabot> map _ []     = []
12:24:37 <lambdabot> map f (x:xs) = f x : map f xs
12:24:43 <applicative> mparodi_: it's a mystery why parallel was requiring deepseq=1.1 exactly
12:24:47 <ski> is using monomorphic recursion
12:25:07 <tgeeky> ClaudiusMaximus: btw, can one always convert pattern guard usage to case analysis?
12:25:12 <applicative> the more recent parallel says > 1.1 and < 1.4
12:25:24 <ski> JoeyA : there's also a concept of "polymorphic recursion" which is allowed in Haskell, but where it can't infer the types (you *have* to provide a type signature in this case)
12:25:37 <cg_morton> so it's monomorphic because it behaves exactly the same for all types?
12:25:38 <ClaudiusMaximus> tgeeky: i don't know pattern guards - but (,) has only one constructor
12:25:39 <JoeyA> ski: mmhmm
12:25:41 <mparodi_> can't I do something like "time() >> foo >> time()"?
12:26:03 <ski> JoeyA : and this is simply that the function which takes the types as arguments is calling *itself*, and because it does that, it can call itself with *different* types than the "current call" got
12:26:09 <JoeyA> ski: Polymorphic recursion is more fun in C++: http://codegolf.stackexchange.com/questions/1956/generate-the-longest-error-message-in-c/1957#1957
12:26:15 <ski> JoeyA : in some cases, this is essential to be able to code up an algorithm
12:26:24 <zezikaro> > print . reverse . reverse [1..10]
12:26:25 <lambdabot>   No instance for (GHC.Num.Num [a])
12:26:25 <lambdabot>    arising from the literal `1' at <inter...
12:26:28 <mparodi_> I mean, in this case it would be like "time >> foo >> time", where time prints a timestamp in ms
12:26:44 <tgeeky> ClaudiusMaximus: conveniently, I write a test version of unhom that makes a 3 tuple, so I'll find out eventually.
12:26:48 <ski> JoeyA : hehe, i can imagine
12:26:52 <JoeyA> > let f :: (Show a) => a -> String; f x = show x ++ " " ++ f [x] in f 0
12:26:54 <lambdabot>   "0 [0] [[0]] [[[0]]] [[[[0]]]] [[[[[0]]]]] [[[[[[0]]]]]] [[[[[[[0]]]]]]] [[...
12:27:10 <applicative> mparodi_: what happens if you do  cabal install parallel-3.2.0.3 --dry-ru
12:27:15 <ski> JoeyA : in any case, typical Haskell implicatations "do nothing" at run-time, corresponding to the type-passing i talked about
12:27:20 <applicative> cabal install parallel-3.2.0.3 --dry-run rather
12:27:36 <mparodi_> In order, the following would be installed (use -v for more details): parallel-3.2.0.3
12:27:49 <hpaste> ClaudiusMaximus pasted “timing IO actions” at http://hpaste.org/69346
12:28:06 * tgeeky is convinced that the behavior of --dry-run should *always* be used unless cabal install discovers that there are no prereqs other than the package being installed
12:28:18 <mparodi_> In order, the following would be installed (use -v for more details): parallel-3.2.0.3 <-- with: <applicative> cabal install parallel-3.2.0.3 --dry-run rather
12:28:20 <ski> JoeyA : however, it would be possible to pass around sizes of types at run-time (as surrogates of the types), and use this to make polymorphic functions like `map' operate on lists where the elements could occupy different size in the cons cells, depending on the type of them
12:28:23 <ClaudiusMaximus> mparodi_: ^^   but criterion does much more accurate things
12:28:48 <mparodi_> ClaudiusMaximus, I don't need precision, I just want to know if it's 100s or 110 seconds
12:29:07 <ski> JoeyA : have you seen the `data BinTree a = Elements a | Double (BinTree (a,a))' example ?
12:29:07 <ClaudiusMaximus> mparodi_: also note that lazy evaluation can play havoc with benchmarks
12:29:10 <mparodi_> actually in ms would be better :P
12:29:10 <tgeeky> mparodi_: that's a precision of +/- 5 seconds :O
12:29:27 <JoeyA> ski: I don't think I have
12:29:34 <mparodi_> ok ok, 100ms or 110ms
12:29:37 <mparodi_> :)
12:29:50 <tgeeky> should be pretty easy
12:30:01 <mparodi_> tgeeky, how?
12:30:05 <ClaudiusMaximus> or you can hSetBuffering stdout NoBuffering and pipe into 'ts'
12:30:10 <mparodi_> in other languages it would
12:30:13 <tgeeky> mparodi_: I'm just saying that timers in a computer can quite easily resolve +/- 5 ms
12:30:21 <applicative> mparodi_: what happens if you ask  cabal install parallel statistics deepseq monad-par-extras criterion --dry-run
12:30:35 <tgeeky> mparodi_: +/- 5 ns will be a challenge
12:30:44 <mparodi_> http://paste.kde.org/490958
12:30:46 <mparodi_> applicative, ^
12:31:06 <mparodi_> tgeeky, yeah, it's easy if you have a way to ask for the current time
12:31:07 <JoeyA> 100ms is an eternity for a computer.  That's long enough to ask the OS what time it is 100,000 times.
12:31:25 <applicative> mparodi_: looks like it might take a little while :)
12:31:43 <tgeeky> JoeyA: lol. I know it's just true, but that frankly sounds hillarious
12:32:08 <JoeyA> Hmm, replicateM_ 1000000 (getCurrentTime >>= evaluate) only takes a second in ghci
12:32:21 <applicative> mparodi_: It was resisting this, which is what it needs to do, I'd say
12:32:26 <JoeyA> (as does replicateM_ 1000000 getCurrentTime by itself)
12:32:34 <applicative> mparodi_: it isn't predicting any breakage
12:32:54 <mparodi_> applicative, it's the first time I use cabal so I'm not quite sure what you asked me to do. is there any solution?
12:33:44 <JoeyA> (oh wait, was mixing up 100ms and 1s)
12:33:55 <mparodi_> I remove the --dry-run and it's installing.. something... now
12:33:56 <mparodi_> :)
12:34:01 <applicative> I think you should do cabal install parallel statistics deepseq monad-par-extras criterion  but I would prefer a more expert opinion
12:34:17 <mparodi_> applicative, it's late, I'm already doing so :3
12:34:39 <geekosaur> looks saneish to me.  at least I don't think it's about to blow its own brains out by replacing bootlibs...
12:34:42 <ski> JoeyA : ok, consider the following elements of that type :
12:34:50 <ski>   0 :: Integer
12:34:58 <ski>   Elements 0 :: BinTree Integer
12:35:07 <ski>   (0,1) :: (Integer,Integer)
12:35:20 <applicative> ah geekosaur , thanks
12:35:28 <ski>   Elements (0,1) :: BinTree (Integer,Integer)
12:35:37 <ski>   Double (Elements (0,1)) :: BinTree Integer
12:35:57 <ski>   ((0,1),(2,3)) :: ((Integer,Integer),(Integer,Integer))
12:36:04 <ski>   Elements ((0,1),(2,3)) :: BinTree ((Integer,Integer),(Integer,Integer))
12:36:13 <ski>   Double (Elements ((0,1),(2,3))) :: BinTree (Integer,Integer)
12:36:21 <ski>   Double (Double (Elements ((0,1),(2,3)))) :: BinTree Integer
12:36:22 <applicative> mparodi_: the other alternative was to specify an older version of criterion, though i think its sexier features require more recent one
12:36:26 * hackagebot PortFusion 1.1.1 - high-performance distributed reverse / forward proxy & tunneling for TCP  http://hackage.haskell.org/package/PortFusion-1.1.1 (CetinSert)
12:36:41 <Lemon> so how do RankNTypes work again?
12:36:50 <Lemon> like, what do I annotate to get it to kick in?
12:36:56 <ski>   (((0,1),(2,3)),((4,5),(6,7))) :: (((Integer,Integer),(Integer,Integer)),((Integer,Integer),(Integer,Integer)))
12:37:01 <JoeyA> forall a. a -> a -- rank 1
12:37:07 <ski>   Elements (((0,1),(2,3)),((4,5),(6,7))) :: BinTree (((Integer,Integer),(Integer,Integer)),((Integer,Integer),(Integer,Integer)))
12:37:12 <JoeyA> (forall a. ...) -> Int -- rank 2
12:37:18 <ski>   Double (Elements (((0,1),(2,3)),((4,5),(6,7)))) :: BinTree ((Integer,Integer),(Integer,Integer))
12:37:25 <JoeyA> A rank 3 function is one that has a rank 2 argument, etc.
12:37:28 <ski>   Double (Double (Elements (((0,1),(2,3)),((4,5),(6,7))))) :: BinTree (Integer,Integer)
12:37:37 <JoeyA> (very brief explanation of what rank-N types are)
12:37:37 <ski>   Double (Double (Double (Elements (((0,1),(2,3)),((4,5),(6,7)))))) :: BinTree Integer
12:37:41 <JoeyA> :t mask
12:37:42 <lambdabot> Not in scope: `mask'
12:37:45 <ski> JoeyA : i think you see the picture, now
12:37:46 <JoeyA> @hoogle mask
12:37:46 <lambdabot> Control.Exception.Base mask :: ((forall a. IO a -> IO a) -> IO b) -> IO b
12:37:47 <lambdabot> Control.Exception mask :: ((forall a. IO a -> IO a) -> IO b) -> IO b
12:37:47 <lambdabot> Control.Exception.Base mask_ :: IO a -> IO a
12:37:59 <JoeyA> ((forall a. IO a -> IO a) -> IO b) -> IO b -- rank-3 type!
12:38:19 <JoeyA> Lemon: Are you asking how to turn on the extension?  Namely, {-# LANGUAGE RankNTypes #-}
12:38:31 <ski> a value of type `BinTree a' is an equally-nested pair of some depth, so it *always* contain `2^n' elements of type `a', where `n' is the depth (the number of `Double' constructors)
12:39:00 <ski> JoeyA : now, try to write `sumBinTree :: Num a => BinTree a -> a' or `toList :: BinTree a -> [a]' :)
12:39:25 <mparodi_> alright, done
12:39:45 <mparodi_> Could not find module `Criterion.Main': ¬¬
12:40:06 <ski> JoeyA : if you try this, you'll notice that when `sumBinTree' is called on an argument of type `BinTree a', it needs to call itself on an argument of type `BinTree (a,a)', which is not the *same* type -- hence polymorphic recursion
12:40:07 <JoeyA> ski: Interesting
12:40:09 <mparodi_> ah, I had to restart ghci
12:40:54 <ski> JoeyA : if you write the types explicit, in the pseudo-Haskell i did above, you'll write something like `sumBinTree_a (Double t) = ..(sumBinTree_(a,a) t)..'
12:41:23 <ski> JoeyA : note that the recursive call isnt' `sumBinTree_a ...', it's `sumBinTree_(a,a) ...' -- this is polymorphic recursion
12:41:47 <applicative> mparodi_: wait, is this something keeping criterion from completing installation, or something else
12:42:22 <mparodi_> applicative, the installation was successful as I can see
12:42:30 <mparodi_> I'm trying now to add the benchmark code
12:42:40 <mparodi_> like that: http://hpaste.org/65318
12:42:40 <ski> JoeyA : btw, you can represent a collection of any size by a list with elements of type `Maybe (BinTree a)', where each element is (or rather, possibly contains a) a tree with depth one more than the preceeding
12:42:45 <mparodi_> but I don't have a main >_>
12:42:46 <Lemon> okay I am
12:42:56 <Lemon> kinda stuck here, since these types are WAY too confusing for me
12:42:58 <applicative> ah, you need to do like me and use someone else's example :)
12:42:59 <Lemon> @hpaste
12:42:59 <lambdabot> Haskell pastebin: http://hpaste.org/
12:43:33 <jonaskoelker> stray thought (watch out!): if instead of 'fix f = let x = f x in x' I defined 'fix f = let x = f undefined in x' (or just 'fix f = f undefined'), what exactly would be the difference?
12:43:37 <JoeyA> ski: You can also represent a collection of any size by a list of type [a] ;-)
12:43:47 <startling> Hi, I have a typedef enum in C. how do I use that in haskell with the FFI?
12:43:50 <jonaskoelker> my reasoning: I'll get crashes (err, errors) instead of hangs
12:43:50 <ski> JoeyA : doing this is related to representing a number like `29' in binary as `1 * 2^0 + 0 * 2^1 + 1 * 2^2 + 1 * 2^3' -- the `1 *'/`0 *' corresponds to `Maybe' here and `BinTree' is the powers of two
12:44:10 <startling> specifically, I have a struct where one of members is a typedef enum.
12:44:11 <ski> JoeyA : yes, but using this can get you more efficient operations
12:44:18 <JoeyA> Ah
12:44:23 <mparodi_> <applicative> ah, you need to do like me and use someone else's example :) <-- why? do you have one? :)
12:44:35 <hpaste> Lemon pasted “RankNTypes?” at http://hpaste.org/69347
12:44:39 <JoeyA> startling: Are you building your library or program with cabal?
12:44:42 <ski> JoeyA : see Chris Okasaki's great book "Purely Functional Data Structures" for more on (e.g.) this (and also other cool stuff)
12:44:54 <Lemon> somebody help me work out the type of fixConvert, there
12:44:59 <ski> JoeyA : (he also has a thesis of that name, which contains much of what's in the book, but not all)
12:45:02 <JoeyA> You can use hsc2hs and say #{const FOO_CONST}
12:45:04 <startling> JoeyA: not at the moment. basically I have a C thing and it'd be really cool if I could use quickcheck to test it
12:45:17 <mparodi_> ah, yeah! done
12:45:24 <JoeyA> startling: ah
12:45:34 <mparodi_> wait, it can't be true
12:45:46 <startling> all the C unit testing things are pretty rubbish
12:45:59 <JoeyA> Unit testing, or performance testing?
12:46:05 <JoeyA> oh, performance, I guess
12:46:23 <mparodi_> mean: 54.02139 ns, lb 53.97936 ns, ub 54.08030 ns, ci 0.950
12:46:29 <JoeyA> What's wrong with tap ("test anything protocol")?
12:46:30 <JoeyA> http://ccodearchive.net/info/tap.html
12:46:31 <mparodi_> it can't be just 54ns >_>
12:46:44 <dcoutts_> startling: I think enums can be treated as ints as far as Haskell FFI is concerned
12:47:08 <mparodi_> maybe it's lazy evaluating something so actually it's benchmarking <nothing>
12:47:09 <JoeyA> err, you said quickcheck
12:47:22 <startling> dcoutts_, yeah. but I'm not sure how to make that a haskell type
12:47:45 <startling> I don't *need* to, but it'd be pretty cool
12:47:58 <dcoutts_> startling: you can do it manually by define an equivalent enumeration type and making it an instance of Storable
12:48:13 <singpolyma> or just newtype int, depending on what you need
12:48:30 <dcoutts_> startling: or you can do it automatically using the c2hs FFI preprocessor, but expect to spend a little time learning the tool.
12:48:37 <startling> dcoutts_, so data MyEnum = One | Two | Three etc?
12:48:43 <startling> and make it an instance of enum?
12:48:46 <startling> and storable
12:48:49 <dcoutts_> startling: right
12:49:00 <startling> dcoutts_: sounds good. thanks!
12:49:20 <mparodi_> JoeyA, are you sure the way to do that is for example: main = defaultMain [bench "foo 50000000" getCurrentTime] ? it's returning 54ms when actually it takes like 5 seconds
12:49:37 <mparodi_> actually 54ns, no ms
12:50:10 <mparodi_> I suppose it's not doing anything since it doesn't have to print the result
12:50:20 <JoeyA> mparodi_: What OS are you on?
12:50:22 <dmwit> Did you read the fine manual?
12:50:24 <mparodi_> Debian
12:50:28 <JoeyA> Oh
12:50:57 <mparodi_> why? it works anywhere but no on Debian? xD
12:51:17 <dmwit> nfIO
12:51:19 <applicative> mparodi_: it's about the same here
12:51:20 <JoeyA> So the example I pasted gives you something different?  http://hpaste.org/65318
12:51:27 <JoeyA> mean: 1.051929 us
12:51:48 <mparodi_> mean: 54.21888 ns, lb 54.15641 ns, ub 54.28455 ns, ci 0.950
12:52:02 <applicative> mparodi_: if you compile my.hs then ./my --help will exhibit the options
12:52:20 <dmwit> benchmarking getCurrentTime: mean 83ns
12:52:29 <dmwit> benchmarking nfIO getCurrentTime: mean 4.24 us
12:52:50 <dmwit> (not copy/pasted, obviously)
12:53:23 <startling> hmmm, what type should my void * in C be?
12:53:23 <applicative> mparodi_: one could probably do with a more realistic example in any case
12:53:39 <startling> Ptr ()?
12:54:05 <dmwit> startling: That very much depends on the context the void * is used in.
12:54:09 <JoeyA> dmwit: Hmm, so later versions of getCurrentTime don't make the system call immediately?
12:54:34 <startling> dmwit, i don't need to use it in haskell, I just need it for completeness for the type representing my struct
12:54:35 <mparodi_> applicative, the point is that it's wrong by.. 5 seconds, not just a few ms :P
12:54:39 <JoeyA> If you have to force the value to get it to make a system call, that would be a bug...
12:54:58 <JoeyA> (it would return the time when the value is forced, rather than when getCurrentTime was called)
12:55:05 * applicative has never used criterion for an IO operation, usually its some fold
12:55:22 <dmwit> JoeyA: getCurrentTime does a lot of computation after it gets back from the syscall.
12:55:58 <JoeyA> dmwit: Perhaps, but I thought the system call was the most expensive part.
12:56:11 <JoeyA> I benchmarked this in C a long time ago with plain gettimeofday, and it took 1us.
12:56:13 <ClaudiusMaximus> startling: i sometimes distinguish different void* by something like    {-# LANGUAGE EmptyDataDecls #-}   data ThingA    data ThingB    foo :: Ptr ThingA -> Ptr ThingB -> IO ()
12:56:18 <JoeyA> Well, a couple years ago.
12:56:34 <ClaudiusMaximus> startling: dunno if that's a recommended way or not
12:56:36 <startling> ClaudiusMaximus, oh, cool
12:57:14 <JoeyA> Okay, on my system, getCurrentTime on GHC 7.4.1 still takes 1us after installing the latest version of time.
12:58:03 <dmwit> startling: See also, e.g. http://stackoverflow.com/questions/9283528/ffi-haskell-callback-with-state
12:58:03 <mparodi_> benchmarking [1..]!!100000000
12:58:03 <mparodi_> mean: 54.23316 ns, lb 54.16814 ns, ub 54.31181 ns, ci 0.950
12:58:03 <mparodi_> std dev: 364.7821 ps, lb 310.3378 ps, ub 446.1314 ps, ci 0.950
12:58:15 <JoeyA> dmwit: How long does replicateM_ 1000000 Data.Time.Clock.getCurrentTime take on your system?
12:58:17 <mparodi_> [1..]!!100000000 <-- takes more than 54.23316ns >_>
12:58:24 <JoeyA> (no criterion, just run it in ghci)
12:58:48 <dmwit> JoeyA: 0.12 s
12:58:59 <dmwit> mparodi_: Did you read the fine manual? (again?)
12:58:59 <JoeyA> Maybe I just have an ancient computer.
12:59:03 <dmwit> mparodi_: Did you use "nf"?
12:59:06 <mparodi_> I will
12:59:07 <JoeyA> That takes a full second for me
12:59:08 <mparodi_> no
12:59:13 <mparodi_> nf?
12:59:17 <dmwit> mparodi_: Congratulations, I found your bug.
12:59:22 <mparodi_> yay!
12:59:24 <mparodi_> :)
13:00:05 <JoeyA> dmwit: Try this in GHCi:
13:00:06 <JoeyA> x <- getCurrentTime
13:00:08 <JoeyA> y <- getCurrentTime
13:00:13 <JoeyA> wait a few seconds
13:00:33 <JoeyA> err, getCurrentTime; y <- getCurrentTime; -- wait -- y
13:00:45 <mparodi_> @hoogle nf
13:00:45 <lambdabot> Control.Parallel.Strategies class NFData a
13:00:45 <lambdabot> Control.DeepSeq class NFData a
13:00:45 <lambdabot> Prelude isInfinite :: RealFloat a => a -> Bool
13:00:48 <JoeyA> See if getCurrentTime actually get the time at the call site, or if you have to force the argument.
13:01:02 <dmwit> x and y are very different
13:01:21 <dmwit> mparodi_: It's part of the criterion package.
13:01:33 * mparodi_ wonders where the manual is
13:01:42 <dmwit> http://hackage.haskell.org/package/criterion
13:01:47 <JoeyA> (import Data.Time.LocalTime to pretty-print times)
13:10:42 <applicative> is mean: 98.44835 ns more reasonable mparodi_ ?
13:11:04 <mparodi_> I still couldn't benchmark it u.u
13:11:05 <applicative> no i guess not.
13:11:09 <mparodi_> main = defaultMain [bench "fib" (nf fib 50000000)]
13:11:18 <mparodi_> it should be working, right?
13:11:27 <mparodi_> (of course not, it's wrong)
13:11:39 <dmwit> Post a complete file.
13:11:49 <dmwit> So we can reproduce the wrong.
13:11:55 <mparodi_> http://paste.kde.org/491000
13:12:53 <dmwit> That doesn't even compile.
13:12:59 <mparodi_> sure not
13:13:10 <mparodi_> Ambiguous type variable `b0' in the constraints: ...
13:13:28 <dmwit> Monomorph fibonacci, or give 5000... a type signature.
13:14:04 <mekeor> now i undestand what monomorphism means… thanks, dmwit
13:14:12 <mparodi_> I don't
13:14:29 <mparodi_> I mean, I don't know how can I monomorph a function
13:14:34 <mparodi_> I can*
13:14:37 <dmwit> mparodi_: The compiler couldn't decide which Integral a to choose for the type of fibonacci.
13:15:05 <dmwit> mparodi_: Either give fibonacci a type signature without a type variable (like Integer -> Integer) or specify the type of its arguments at its call site (like (5000 :: Integer)).
13:15:37 <mparodi_> oh, I got it now
13:16:05 <mparodi_> yep, that was the problem. thank you a lot guys!
13:16:13 <applicative> mparodi_: fib should return Integer, i guess Int -> Integer is okay
13:16:21 <Luke> is there a way to run multiple threads from GHCi? similar to compiling with -threaded?
13:16:27 <applicative> like dmwit said :)
13:16:50 <mparodi_> is it evaluating the time that it takes to print the number?
13:17:01 <mparodi_> it takes like 5 seconds to find it and like a minute to print it :P
13:17:12 <dmwit> ...no
13:17:19 <dmwit> (You're not asking it to print the number anywhere.)
13:17:27 <geekosaur> Luke, ghci is threaded.  there are some limits on it I think because of the way the REPL works, but threads should work subject to them
13:17:43 <mparodi_> I guess it's done with nfIO
13:18:02 <ClaudiusMaximus> Luke:   ghci +RTS -N -RTS   might be needed, as with any other -threaded program to get it to actually use more cores
13:18:09 <Luke> thanks
13:19:02 <Luke> yeah that worked
13:19:06 <Luke> thanks a lot
13:19:18 <Luke> is there any way I can default it with those runtime settings?
13:19:55 <startling> hmmm, is there anything nice for generating C code with haskell?
13:20:01 <ClaudiusMaximus> Luke: RTS options may also be specified using the GHCRTS environment variable.  (from ghci +RTS -? )
13:20:12 <startling> specifically I want to automate testing/valgrind, possibly with a dsl
13:20:33 <Luke> ClaudiusMaximus: like GHCRTS=-N ?
13:20:42 <ClaudiusMaximus> Luke: i imagine so
13:20:45 <Luke> thanks
13:20:47 <mparodi_> mean 2.656515s :)
13:21:34 <applicative> mparodi_: I get mean: 3.004732 s,  I want a new laptop!
13:21:42 <mparodi_> haha
13:22:09 <mparodi_> length $ show $ fibonacci 50000000
13:22:10 <mparodi_> 10449382
13:22:12 <mparodi_> o.o
13:22:18 <startling> something like hatex for C would be lovely.
13:23:48 <applicative> Luke are you sure you want to be forkIO ing in ghci?
13:24:00 * applicative just tried forM [10..20] ( forkIO . print . fibonacci ) >>= sequence_ . map print for the heck of it
13:26:08 <applicative> > text "143926482614T7857\n93151h7786\n3098r\n45\n71e\nadId 163"
13:26:09 <lambdabot>   143926482614T7857
13:26:09 <lambdabot>  93151h7786
13:26:09 <lambdabot>  3098r
13:26:09 <lambdabot>  45
13:26:09 <lambdabot>  71e
13:26:11 <lambdabot>  adId 163
13:26:29 <applicative> I think that was ThreadID 163 in there
13:27:05 <startling> well I can just hack something up with parsec I gues
13:27:56 <applicative> what does hatex do
13:28:57 <applicative> ah writing is hard enough, why would I want a typechecker over my shoulder
13:29:14 <h44l> is there a chatroom where i can ask a question about buying a device that connects to a TV? im trying to decide on a device that switches between DVD palyers and other things connected to a TV
13:29:51 <cg_morton> have you tried google search?
13:29:53 <luite> k-lined for that?
13:30:47 <marienz> luite: he's asking that question in *all* the channels
13:31:07 <marienz> (which triggers an automated anti-spam kline without it mattering much what the message is)
13:31:53 <luite> he must have been really interested in hdmi switches then...
13:32:37 <marienz> normally those get unset quickly, but when I did that with him he proceeded to ask the same question in a slightly different set of channels, so I've given up for now
13:38:20 <Phlogistique> Heya
13:38:49 <Phlogistique> I'm reading "Functional programming with bananas, lenses, enveloppes and barbed wire" as downloaded here http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.125
13:39:23 <Phlogistique> There are quite a few things wich look like errors in the text; is it a draft version? Is there a corrected version anywhere?
13:39:35 <byorgey> Phlogistique: can you give an example?
13:39:55 <geekosaur> some thing that look like errors are simply that the syntax changed between the paper and the actual implementation, IIRC
13:40:26 <byorgey> that's the only version I know of
13:41:00 <byorgey> geekosaur: what actual implementation?
13:41:33 * geekosaur thoguht there was at least one lenses package based (perhaps loosely) on that paer?
13:41:46 <geekosaur> also reactive-banana exists
13:42:22 <byorgey> reactive-banana has nothing to do with the bananas in that paper, I think
13:42:37 <Phlogistique> byorgey: hum, yes
13:42:48 <Phlogistique> for exemple, at the bottom of page 17
13:42:51 <dmwit> And lenses have nothing to do with the lenses in that paper, either. =)
13:42:52 <byorgey> also, the notion of 'lenses' (i.e. bidirectional computation, fields, etc.) has nothing to do with the 'lenses' in that paper
13:42:55 <Phlogistique> um, page 11 I mean
13:43:22 <Phlogistique> there is a relation with a variable named 'h' on the right side but not on the left side
13:44:34 <byorgey> I think it is referring to the 'h' from (16)
13:44:48 <byorgey> I'm not sure though
13:44:48 <Phlogistique> I think there was one place where I thought the types didn't match up too; but I'm strugling to understand things so I'm probably mistake
13:44:51 <Phlogistique> n
13:45:22 <byorgey> there certainly may be a few errors.  But I've read that paper and I certainly don't remember there being 'quite a few'
13:45:38 <Phlogistique> OK; that was prolly me misundersting things then
13:46:36 * hackagebot timeplot 1.0.10 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-1.0.10 (EugeneKirpichov)
13:47:10 <Phlogistique> also: I don't understand the phrase "which are each others inverse and even..." page 10 of the papers. What does it mean?
13:47:25 <dmwit> My reading is that the h is existentially quantified: if there's an h that makes the things to the right of the "<=" true, then the thing to the left of the "<=" is true, too.
13:47:43 <hpaste> ClaudiusMaximus pasted “fib with monad-par - bug?” at http://hpaste.org/69354
13:47:59 <ClaudiusMaximus> sometimes crashes, sometimes works - what's up?
13:48:02 <Phlogistique> dmwit: oh, thanks
13:49:20 <Phlogistique> byorgey++
13:49:22 <dmwit> Phlogistique: Where is the <-F notation defined?
13:49:23 <Phlogistique> dmwit++
13:49:27 <dmwit> Seems like that would be relevant.
13:49:43 <prabuinet> anybody using xmonad on macbookpro/ubuntu with external monitor,whenever i exit i'm getting only a black screen, it takes to gdm only after i unplug my monitor cable
13:49:46 <Phlogistique> dmwit: which one?
13:50:04 <dmwit> ...and even id = mu(in <-F out).
13:50:15 <Phlogistique> you mean F above an arrow
13:50:17 <dmwit> yes
13:50:22 <coppro> prabuinet: play with xrandr a bit
13:50:34 <prabuinet> coppro, 'll try
13:50:38 <Phlogistique> dmwit: bottom of page 7
13:50:52 <Phlogistique> dmwit: the µ is "fix"
13:51:08 <Phlogistique> F is a monofunctor
13:51:25 <byorgey> dmwit: (f <-F- g) h = f . fmap_F h . g
13:52:18 <byorgey> Phlogistique: I think it means that inF and outF are inverses, and moreover, something even stronger is true, namely, that id = mu(in <-F- out)
13:52:38 <Phlogistique> byorgey: OK, thanks
13:52:38 <byorgey> although it is awkwardly phrased.
13:52:48 <dmwit> Right, this is quite a strong claim: if we unwrap a thing, then everywhere (unwrap and wrap), then wrap it back up, nothing happened.
13:55:20 <hayashi> darned containers.  there's a map over keys and a map over values and corresponding maps-over-one-with-the-other-as-an-input, but no "map over every mapping changing both key and value" as far as I can see without either converting to associative list and back or composing two maps
13:56:14 <hayashi> This is probably my cue to eliminate the value transformation~
13:56:19 <dmwit> hayashi: I suspect that's because the provided ones can be done efficiently, and the one you're asking for can't.
13:56:21 <hayashi> indeed that's what I'll do
13:57:05 <ClaudiusMaximus> @hoogle mapKey
13:57:06 <lambdabot> Data.Map mapKeys :: Ord k2 => (k1 -> k2) -> Map k1 a -> Map k2 a
13:57:06 <lambdabot> Data.Map mapKeysMonotonic :: (k1 -> k2) -> Map k1 a -> Map k2 a
13:57:06 <lambdabot> Data.Map mapKeysWith :: Ord k2 => (a -> a -> a) -> (k1 -> k2) -> Map k1 a -> Map k2 a
13:57:41 <hayashi> and then, yeah, I'll just use mapKeys
13:57:43 <ClaudiusMaximus> i imagine mapKeysMonotonic is the efficient one
13:57:55 <dmwit> Oh, weird, it does provide even the inefficient ones.
13:58:15 <byorgey> I suspect it's because no one has ever wanted it before.
13:58:39 <hpc> hayashi: make a new empty map and fold over the old one inserting into the new
13:59:33 <ClaudiusMaximus> @hoogle fromDistinct
13:59:33 <lambdabot> Data.IntMap fromDistinctAscList :: [(Key, a)] -> IntMap a
13:59:33 <lambdabot> Data.Map fromDistinctAscList :: [(k, a)] -> Map k a
13:59:34 <lambdabot> Data.IntSet fromDistinctAscList :: [Int] -> IntSet
13:59:47 <hayashi> actually, come to think of it, I could probably use mapKeysMonotonic
14:00:13 <hpc> hayashi: make sure it's actually monotonic ;)
14:00:22 <hayashi> given that the transformation is applying the same prefix to each (string) key, which if strings are ordered lexicographically should preserve ordering
14:01:37 <ClaudiusMaximus> > M.mapKeysMonotonic (const False) (M.fromList [(False, "er"), (True, "hm")])
14:01:38 <lambdabot>   fromList [(False,"er"),(False,"hm")]
14:02:20 <ClaudiusMaximus> > (M.size $ M.mapKeysMonotonic (const False) (M.fromList [(False, "er"), (True, "hm")]), M.size $ fromList [(False,"er"),(False,"hm")])
14:02:21 <lambdabot>   Couldn't match expected type `GHC.Real.Ratio
14:02:21 <lambdabot>                               ...
14:02:41 <ClaudiusMaximus> > (M.size $ M.mapKeysMonotonic (const False) (M.fromList [(False, "er"), (True, "hm")]), M.size $ M.fromList [(False,"er"),(False,"hm")])
14:02:42 <lambdabot>   (2,1)
14:04:18 <jfischoff_> ClaudiusMaximus: do you know if there is a simple pedagogical language that supports incremental computing out of the box?
14:05:10 <jfischoff_> ClaudiusMaximus: or perhaps a better term would be implicitly…
14:05:49 <dmwit> > let foldbPass op = go where { go (x:y:rest) = op x y : go rest; go short = short }; foldb op def = head . (++[def]) . dropWhile (not . null . drop 1) . iterate (foldbPass op) in foldb (*) 1 [1..1000000]
14:05:49 <lambdabot>   No instance for (GHC.Num.Num [a])
14:05:50 <lambdabot>    arising from a use of `e_11111000000' ...
14:06:00 <dmwit> :t let foldbPass op = go where { go (x:y:rest) = op x y : go rest; go short = short }; foldb op def = head . (++[def]) . dropWhile (not . null . drop 1) . iterate (foldbPass op) in foldb
14:06:01 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a] -> [a]
14:06:31 <ClaudiusMaximus> jfischoff_: i'm not sure what implicitly incremental computing is
14:06:51 <jfischoff_> ClaudiusMaximus: its a term I made up :)
14:07:38 <jfischoff_> ClaudiusMaximus: Oh wait I confused you with someone else, my bad
14:07:43 <ClaudiusMaximus> jfischoff_: hehe - ok
14:07:45 <dmwit> oh
14:07:57 <dmwit> :t let foldbPass op = go where { go (x:y:rest) = op x y : go rest; go short = short }; foldb op def = (++[def]) . head . dropWhile (not . null . drop 1) . iterate (foldbPass op) in foldb
14:07:58 <lambdabot> forall a. (a -> a -> a) -> a -> [a] -> [a]
14:08:15 <dmwit> > let foldbPass op = go where { go (x:y:rest) = op x y : go rest; go short = short }; foldb op def = (++[def]) . head . dropWhile (not . null . drop 1) . iterate (foldbPass op) in foldb (*) 1 [1..1000000]
14:08:19 <lambdabot>   mueval-core: Time limit exceeded
14:09:59 <dmwit> Okay, now I can ask by question: will foldb union empty . map (uncurry singleton) be more efficient (non-asymptotically) than foldl' (uncurry insert) empty?
14:10:11 <dmwit> I guess I could just time it.
14:10:32 <ClaudiusMaximus> jfischoff_: if it's what i think you might mean, i'd like it if this thing wasn't so awkward/manual: https://gitorious.org/ruff/ruff/blobs/master/Fractal/Mandelbrot/Numeric/RayTraceForward.hs (lines 15-20 are the relevant parts)
14:15:29 <jfischoff_> ClaudiusMaximus: Hard for me to say. The basic idea with incremental computing is  you build a dependency graph of thunks similar to STG, but different in that the thunks can become "dirty" or unevaluated after being evaluated if there inputs are change.
14:16:16 <magicman> What's the cabal flag again for forcing the use of a specific package?
14:16:36 <magicman> My google-fu and userguide-fu is failing me :-/
14:18:34 <c_wraith> magicman: --constraint ?
14:19:40 <xplat> jfischoff_: this kind of automatic incrementalization is usually called 'adaptive programming' i think
14:20:19 <jfischoff_> xplat: thanks that help my search. Our you aware of anything analogous to STG but for adaptive programming?
14:21:10 <xplat> nothing much like STG, there are some imperative ones done as preprocessors and functional ones that are monadic
14:21:41 <xplat> also imperative libraries but those are awkward to use
14:22:10 <magicman> Righto, thanks c_wraith.
14:23:00 <jfischoff_> xplat: yeah. I haven't seen anything. I don't know if it is just a bad idea, or no one has tried to make the simplest thing that will work … from scratch yet.
14:23:08 <xplat> jfischoff_: also edwardk is working on a library for automatic parallelization that should be able to grow adaptive programming features as well
14:24:07 <xplat> (might be in the process of growing them by now -- it's based on previous work from microsoft research)
14:24:33 <jfischoff_> xplat: cool I'll pester him next time he shows up.
14:24:36 <jfischoff_> :)
14:27:33 <xplat> (i suppose it's more 'semiautomatic parallelization' -- does its own scheduling and stuff, but you have to mark semantic fork and join points)
14:28:32 <jfischoff_> xplat: is this his revision control stuff?
14:29:43 <mekeor> so, how can i import a module which is in a directory which is in the current directory?
14:29:43 <xplat> yeah
14:30:14 <mekeor> i mean like '#include "Foo/Bar.hs"' or so in C or so…
14:32:57 <hpc> import Foo.Bar?
14:33:28 <mekeor> when i do $ head Foo/Bar.hs # in the bash, what should i get?
14:33:33 <mekeor> moduel Foo.Bar ?
14:33:36 <mekeor> or module Bar?
14:33:44 <hpc> module Foo.Bar
14:33:59 <mekeor> that's stupid. but okay. fine, thanks.
14:34:08 <hpc> or maybe {-# LANGUAGE ... #-}
14:34:10 <hpc> :D
14:34:14 <mekeor> :D hehehe :D
14:34:24 <mekeor> hpc: which ext?
14:34:32 <mekeor> i'd really use it.
14:34:46 <hpc> mekeor: http://hpc.dyndns-web.com:8000/blog/view.cgi?id=15 -- ALL the extensions!
14:35:00 <mekeor> coool!
14:35:19 <xplat> hpc: until they make a new one
14:35:23 <mcstar> does ... enable future extensions too?
14:35:33 <mekeor> BAH! NPlusKPatterns are ugly.
14:35:53 <hpc> xplat: yeah...
14:36:23 <mekeor> ah! hpc means headprogrammingczar
14:38:17 <mekeor> hpc: so, is there really such an ext? and if yes, which one?
14:40:46 <hpc> mekeor: there's no "..." extension, that was just me being lazy
14:41:31 <mekeor> oh, i thought you didn't remember the name of the extension :D okay, alright.
14:42:20 <mekeor> hpc: how does Foo/Baz.hs include Foo/Bar.hs then?
14:44:13 <mcstar> mekeor: afaik, haskell modules form a directory structure
14:44:28 <mcstar> the last file name must be the module's name also
14:45:10 <mekeor> you mean, the last part of the modules name has to be the filename? that way?
14:45:38 <mcstar> the module's name must be the same as the file's name it lives in
14:48:51 <mcstar> mekeor: http://www.haskell.org/tutorial/modules.html
14:49:14 <mcstar> this is not what i said, though, i believe implementations behave differently from that
14:49:30 <mcstar> it would be great to hear this form someone knowledgeable
14:51:24 <mekeor> mcstar: there was no Foo.Bar syntax in Haskell98, afaik.
14:54:00 <mcstar> i somehow doubt that, that would mean no module hierarchy
14:54:50 <mauke> correct
14:55:13 <mauke> we still don't have a real hierarchy
14:55:37 <mekeor> mauke: what's correct?
14:55:46 <mauke> "that would mean no module hierarchy"
14:55:53 <mekeor> ah.
14:56:00 <geekosaur> mcstar, hierarchical modules were an extension, which is why until recently there were modules like IO and Char (and now you need to force haskell98 mode to get them)
14:56:06 <mekeor> mauke: is "there was no Foo.Bar syntax in Haskell98" also true?
14:56:10 <mauke> yes
14:56:12 <mekeor> ok
14:56:45 <mcstar> i see, im a bit surprised
14:56:55 <mauke> but functionality-wise Foo.Bar doesn't buy you anything over Foo_Bar
14:57:22 <hpc> except that you can 'ls' without tearing your hair out
14:57:34 <EvanR> haha, comonads are like nightclubs
14:57:38 <mcstar> or learn your glob patterns
14:57:40 <EvanR> http://gelisam.blogspot.com/2007/04/of-comonads-and-nightclubs.html
14:57:51 <hpc> EvanR: i love it
14:57:56 <hpc> so long, burrito jokes!
14:58:50 <mcstar> mekeor: http://learnyouahaskell.com/modules cf. 'make your own modules'
15:00:28 <mcstar> i think it answers your question
15:00:34 <mekeor> ok. thanks.
15:03:26 <mcstar> so, what is under the wintercoat?
15:06:56 <osa1> why I can't create a String instance for a custom typeclass? I'm getting "use -XTypeSynonymInstances" error
15:07:07 <EvanR> mcstar: nightclub gear
15:07:34 <shachaf> osa1: Because String isn't a class.
15:08:10 <otters> String is a type synonym for [Char]
15:08:12 <otters> hence the name
15:08:21 <osa1> shachaf: right, thanks.
15:08:43 <shachaf> osa1: (The class is IsString.)a
15:12:20 <whittle> You know, when I was initially learning monads, I took it on faith that they would be valuable. Now I see type a -> m b everywhere.
15:13:00 <hpc> whittle: just wait until you learn to multithread
15:13:19 <hpc> or learn how Cont works
15:14:10 <shachaf> Understanding Monad and understanding Cont are pretty closely related.
15:14:20 <whittle> hpc: I was going to try to grok arrows next, as I’ve run into them when reading libraries.
15:14:45 <hpc> arrows are kind of a crap abstraction
15:15:13 <jfischoff_> hpc: I sort of agree with you, but I'm interested in your reasons
15:15:50 <hpc> jfischoff_: any nontrivial use of arrows is going to bring in Arrow, but also ArrowApply, ArrowPlus, ...
15:16:06 <hpc> it kinda generalizes everything, piece by piece
15:16:15 <whittle> hpc: Noted. If I’m going to skip arrows for now, do you have a go-to resource you can suggest regarding multithreading or Cont?
15:17:11 <hpc> whittle: for multithreading, try writing something server-client, and go through Control.Concurrent in the docs
15:17:37 <hpc> Cont is kinda tricky; i have a post that explains part of it, but assumes prior knowledge of other things
15:18:09 <hpc> you might also try just going through libraries that do neat IO stuff on hackage
15:18:23 <hpc> those tend to make waaaaaay more sense when you aren't wtf-ing at Monad
15:18:28 <hpc> also Parsec
15:19:02 <whittle> Good to know. I’m dipping my toes into Parsec and Conduits right now.
15:20:05 <EvanR> attoparsec is my favorite
15:20:06 <whittle> Mostly, I’ve been picking things up from reading the source on hackage.
15:28:41 <crdueck> @src (!!)
15:28:42 <lambdabot> xs     !! n | n < 0 = undefined
15:28:42 <lambdabot> []     !! _         = undefined
15:28:42 <lambdabot> (x:_)  !! 0         = x
15:28:42 <lambdabot> (_:xs) !! n         = xs !! (n-1)
15:37:49 <EvanR> "Since continuations are functions which represent the future of a computation, manipulation of the continuation functions can achieve complex manipulations of the future of the computation"
15:38:05 <EvanR> easy reading xD
15:38:53 <acowley> Translation: They don't think it be like it is, but it do.
15:39:07 <EvanR> lol
15:41:03 <hpc> EvanR: continuations are like wearing roller skates in a maple syrup factory!
15:41:42 * hpc likes "a continuation is what happens next"
15:42:01 <EvanR> so what happened was...
15:45:41 <hpaste> whittle pasted “FuzzyDate” at http://hpaste.org/69357
15:46:57 <whittle> As a Haskell newbie trying to improve, I would appreciate comments on that code, up to and including, “There’s an easier way to do all of that.”
15:47:03 <whittle> Please.
15:49:20 <ClaudiusMaximus> @pl Just . f =<< m
15:49:20 <lambdabot> Just . f =<< m
15:49:26 <ClaudiusMaximus> @pl return . f =<< m
15:49:27 <lambdabot> f `fmap` m
15:49:29 <hpc> whittle: type FuzzyDate - (Maybe Day, Maybe Month, Maybe Year)
15:49:34 <hpc> er, '='
15:50:05 <hpc> can handle any combination of day, month, year known/not-known
15:50:43 <hpc> oh i see how it's ordered
15:51:16 <hpc> how about
15:51:45 <hpc> data Fuzzy a = Fuzz a a a -- estimate, lower bound, upper bound
15:51:52 <acowley> As a high order bit, it's fine.
15:51:58 * hackagebot graph-rewriting-gl 0.7 - OpenGL interface for interactive port graph rewriting  http://hackage.haskell.org/package/graph-rewriting-gl-0.7 (JanRochel)
15:52:19 <hpc> yeah, you would write more general operations, then make date-specific functions in terms of those
15:53:09 <whittle> hpc: So FuzzyDate would be something like
15:53:14 <ifnspifn> if I were looking for an english dictionary library, where might I look?
15:53:49 <whittle> type FuzzyDate = (Fuzzy Integer) (Fuzzy Int) (Fuzzy Int)
15:53:50 <whittle> ?
15:54:01 <hpc> type FuzzyDate = Fuzzy Day
15:54:15 <whittle> hpc: Ah!
15:54:16 <hpc> and then you can just give it larger and larger error ranges
15:55:00 <hpc> actually, you can probably do without the estimate, and with some niceness for record access......
15:55:12 <hpc> data Fuzzy a = Fuzz {lowerBound :: a, upperBound :: a}
15:56:25 <hpc> ifnspifn: doesn't look like something exists, but you can probably make some simple stuff that uses /usr/dict or whatever the file
15:57:13 <whittle> hpc: I see. That goes well outside the problem I was trying to solve, but you’re right that it’s a much more general solution.
15:57:30 <ifnspifn> hpc: alas, thanks anyhow :]
15:57:48 <hpc> whittle: you can write nice general functions to operate on fuzzy ranges, then use those to build more specific date stuff
15:58:12 <hpc> with some luck, you might find that the code writes itself
16:01:25 <whittle> hpc: How would you define fuzzy comparison?
16:02:35 <whittle> I feel like there’s got to be a maths whitepaper somewhere that solves comparison of ranges.
16:05:13 <whittle> And why isn’t there a #math channel?
16:05:28 <Axman6> i thought there was. maybe ##math?
16:05:37 <mkscrg> so where's a good place to start with generics in haskell?
16:05:37 <arbn> whittle: ##math isn't good enough?
16:05:53 <mkscrg> is there something better than http://www.haskell.org/haskellwiki/GHC.Generics?
16:06:18 <whittle> arbn: Wasn’t expecting the double-hash.
16:06:25 <adamt> whittle: ## means "about"-channel
16:06:33 <adamt> so ##math => channel about math
16:07:02 <adamt> #haskell is the official channel for haskell, thus only one # (in general :P)
16:07:27 <arbn> I think #math redirects to ##math, though. It does for me, but maybe that's client-specific.
16:08:09 <adamt> it's freenode doing the redirect
16:08:27 <adamt> staff probably closed #math but made it forward to ##math.
16:08:38 <arbn> That's what I thought, so even if whittle tried #math, he would still get to ##math.
16:08:43 <adamt> or rather, asked the chanops to do it.
16:09:44 <parcs`> what if there was an official channel about math
16:10:31 <adamt> parcs`: how could there?
16:16:43 <acowley> adamt: time machine + Leonhard Euler
16:17:17 <adamt> acowley: Even then, he would probably have to join up with a bunch of other old guys to form an official math institute. ;)
16:18:21 <acowley> Maybe a society…. maybe even a king or queen among societies!
16:18:25 <parcs`> why euler?
16:18:58 <adamt> Maybe they could call themself the illuminati.
16:19:01 <acowley> He's awesome, and if he claimed the right to found #math nobody could really argue.
16:19:17 <companion_cube> why not Gauss?
16:19:24 <acowley> I mean, Pythagoras founded #numerology and nobody balked.
16:20:19 <acowley> This is turning into mathematician Pokemon. I choose you, Euler!
16:20:36 <adamt> they would also have to apply for a cloak, like math/something
16:21:04 <irene-knapp1> I choose the axiom of choice?
16:22:12 <nand`> if you ask me; the founder of #math is the empty set; I believe mathematics are the only thing in this world that are derived from nothing
16:22:40 <acowley> irene-knapp1: that's a classic
16:23:02 <parcs`> i choose the babylonians
16:23:07 <nand`> there's actually a band called the Axiom of Choice
16:23:11 <nand`> quite a good one too in my opinion
16:23:25 <nand`> they have an album fittingly called “Unfolding”
16:23:38 <acowley> So maybe there is a #math, but only elements of the empty set may join it.
16:24:47 <nand`> alternatively; members of #math enjoy relativity - from each users perspective, they themselves are the founders
16:24:56 <parcs`> wow the babylonians were using the quadratic formula in 2000bc
16:25:55 <whittle> parcs`: What were they using it for?
16:26:30 <adamt> nn
16:26:47 <parcs`> whittle: dunno
16:26:48 <startling> I'm on a 64-bit system but I want ghci to build 32-bit. is it possible?
16:26:49 <nand`> probably evenly distributing crops or something
16:27:05 <startling> it's os x, so it's a weird combination of 64 and 32 bit
16:27:19 <startling> and I want to link against some i386 object files
16:29:52 <ifnspifn> hey, I'm having some difficulty understanding the IO docs.. I'm trying to read in a file as a [String]. Any ideas about where to start?
16:30:05 <parcs`> @oeis 2 6 12 60
16:30:06 <lambdabot>  a(0) = 1; for n >= 1, a(n) = least common multiple (or lcm) of {1, 2, ..., n}.
16:30:06 <lambdabot>  [1,1,2,6,12,60,60,420,840,2520,2520,27720,27720,360360,360360,360360,720720,...
16:30:08 <acowley> startling: I think it is possible to build a 32bit GHC (and GHCi) on OS X, but I don't recall how off the top of my head.
16:30:15 <parcs`> @oeis 2 6 12 60 120
16:30:16 <lambdabot>  Colossally abundant numbers: n for which there is a positive exponent epsilo...
16:30:16 <lambdabot>  [2,6,12,60,120,360,2520,5040,55440,720720,1441440,4324320,21621600,367567200...
16:31:39 <startling> acowley, err, i was unclear i think
16:31:52 <startling> what I want is a 32-bit binary from haskell source
16:32:00 <startling> that is, I want ghc to produce 32-bit binaries
16:32:13 <acowley> startling: You need a 32bit GHC to do so.
16:32:18 <startling> acowley: ah
16:32:19 <startling> darn
16:32:47 <acowley> startling: If you go back a couple versions the binary on haskell.org/ghc for OS X will be 32 bit
16:33:31 <Bytter> @oeis 1 2 4 8 16 32
16:33:33 <lambdabot>  Powers of 2: a(n) = 2^n.
16:33:33 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
16:33:51 <HugoDaniel> ghc 64bits for windows would a be a nice thing to have
16:33:59 <Bytter> @oeis 1 1 2 3 5 8
16:34:05 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1.
16:34:05 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
16:34:16 <HugoDaniel> then i could code in haskell in windows using the 64bit database drivers
16:34:33 <Bytter> HugoDaniel: português?
16:34:40 <HugoDaniel> Bytter: yes
16:34:47 <Bytter> HugoDaniel: boa
16:34:56 <HugoDaniel> :)
16:35:25 <sipa> @oeis 2 6 20 70 252 924
16:35:25 <lambdabot>  Central binomial coefficients: C(2*n,n) = (2*n)!/(n!)^2.
16:35:26 <lambdabot>  [1,2,6,20,70,252,924,3432,12870,48620,184756,705432,2704156,10400600,4011660...
16:36:05 <HugoDaniel> oeis is smart
16:36:31 <HugoDaniel> @oeis 2 3 5 7 11 13 17 19
16:36:33 <lambdabot>  The prime numbers.
16:36:33 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
16:37:14 <irene-knapp1> @oeis 2 3 5 11 13 17 19
16:37:15 <lambdabot>  Let p and q be consecutive primes. If pq+p+q is a prime, adjoin p to the seq...
16:37:15 <lambdabot>  [2,3,5,11,13,17,19,23,41,43,47,59,79,83,89,101,109,113,137,163,167,173,223,2...
16:37:16 <HugoDaniel> @oeis 1 48 6 992 384 29 0
16:37:17 <lambdabot>  Sequence not found.
16:37:19 * irene-knapp1 blinks
16:37:39 <HugoDaniel> oeis should output "random sequence" :D
16:38:05 <HugoDaniel> @oeis 0 0 0 0 0 -1
16:38:05 <strager> @oeis 3 1 4 1 5 9 2 6 5
16:38:07 <shachaf> @oeis 1 2 3 1000000000
16:38:16 <lambdabot>  Expansion of f(q) = f(q, -q^2) in powers of q where f(a, b) is the Ramanujan...
16:38:16 <lambdabot>  [1,1,1,0,0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0...
16:38:20 <lambdabot>  Decimal expansion of Pi.
16:38:20 <lambdabot>  [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,6,4,3,3,8,3,2,7,9,5,0,2,8,8,4,1...
16:38:20 <lambdabot>  Sequence not found.
16:38:24 <HugoDaniel> ish!
16:38:26 <HugoDaniel> omg!
16:38:32 <irene-knapp1> haha nice
16:38:42 <HugoDaniel> kill oeis with fire!! its going to rule us all!
16:46:17 <HugoDaniel> is there a hackage package for oeis ?
16:46:27 <HugoDaniel> i want it do that i can rule the world :)
16:46:38 <ClaudiusMaximus> @tell Rhamphoryncus i ended up using R's least squares minimisation assuming log-log should be straight line: old x = 0.03285206 * x ** 2.2181903 ; new x = 0.01106556 * x ** 1.33944402 ; old_over_new x = 2.968857   * x ** 0.8787463 ; rubbish graph: http://img801.imageshack.us/img801/1976/regression.png
16:46:38 <lambdabot> Consider it noted.
16:46:51 <twanvl_> HugoDaniel: http://hackage.haskell.org/package/oeis
16:46:59 <HugoDaniel> yay \o/
16:47:10 <HugoDaniel> is there an online version of it ?
16:47:30 <HugoDaniel> im going to do it!
16:47:50 <twanvl_> the package calls an online service
16:47:59 <twanvl_> ?google oeis
16:48:01 <lambdabot> http://oeis.org/
16:48:01 <lambdabot> Title: The On-Line Encyclopedia of Integer Sequences™ (OEIS™)
16:48:17 <HugoDaniel> oh
17:22:38 <parcs`> @oeis 0 3 1 5
17:22:48 <lambdabot>  a(n) = A118534(n)/A117078(n) unless A117078(n) = 0 in which case a(n) = 0.
17:22:49 <lambdabot>  [0,0,1,0,3,1,5,3,1,9,1,3,13,3,1,1,19,5,9,23,1,15,11,9,3,33,11,35,21,3,3,5,45...
17:25:12 <startling> does anyone know of a hsc2hs example? i can only find two rather opaque pages
17:28:57 <startling> ah well, c2hs seems like more what i want anyway
17:34:10 <strager> hsc2hs is automatic when using cabal
17:34:29 <startling> strager, i'm writing bindings, not using them
17:34:52 <startling> well I'll use them too, but i have to write them first. ;)
17:35:31 <parcs`> startling: i suggest hsc2hs + bindings-DSL
17:36:20 <Clint> i concur
17:38:40 <startling> hmm, are these painful to use outside of cabal?
17:39:02 <startling> I'm not using cabal because the whole idea is to use quickcheck to write tests for a C thing
17:39:30 * Clint squints.
17:39:36 <startling> heh
17:40:38 <Clint> startling: why would you not use cabal for that?
17:40:50 <parcs`> startling: kinda. you have to rerun hsc2hs on the source file to update the outputted haskell file
17:41:06 <parcs`> ghci doesn't do that automatically or anything
17:41:11 <parcs`> but that would be a cool feature
17:41:26 <startling> well, i have a makefile for this thing so I can use that
18:03:03 <chare> Does haskell have native support for opengl or is there an overhead incurred in calling opengl functions?
18:04:22 <whittle> In order to make one of my types an instance of an existing class, I need to implement formatCharacter :: Char -> Maybe (TimeLocale -> Maybe NumericPadOption -> t -> String). However, my implementation depends on which data constructor was used for t. Is there any way to square this?
18:05:10 <strager> Can I not use <?> with aeson?
18:05:43 <mauke> whittle: I don't get it
18:06:22 <strager> whittle: Well, you're returning a function, so you have full control over what the final String is
18:06:36 <whittle> I’d like to create a function with type Char -> t -> Maybe (???) and somehow translate that.
18:07:31 <dstcruz> what a day. rm -fr ~/.cabal ~/.ghc && cabal update && cabal install cabal-dev   ---- no can do :(
18:07:42 <strager> f c t -> Just (\tl mnpo t' -> str)
18:07:49 <dstcruz> anyone else having trouble with that?
18:07:50 <parcs`> chare: what languages _don't_ have the overhead you're asking aboun+
18:07:51 <mauke> strager: you can't
18:07:53 <parcs`> about?*
18:07:54 <mauke> er
18:08:04 <mauke> not you
18:08:50 <dstcruz> something about: To fix this warning, don't compile with -mdynamic-no-pic or link with -Wl,-no_pie
18:09:19 * dstcruz thinks that I need a virtual box with linux to avoid some of this mess
18:09:33 <whittle> strager: I’m sorry to be obtuse. I’m new to Haskell and having trouble figuring out how to “invert control” (where invert control is almost certainly the wrong way to say what I mean).
18:09:40 <mauke> whittle: you can't
18:10:21 <geekosaur> dstcruz, that part clearly identifies as a warning.  if you are having an error, pastebin the whole thing and not just the non-detail-bearing part of a warning
18:10:52 <strager> whittle: Code sample would be nice
18:11:11 <hpaste> dstcruz pasted “cabal-dev issue” at http://hpaste.org/69361
18:11:42 <shachaf> dstcruz: That looks like just a warning.
18:11:51 <shachaf> Does the cabal-dev it installs not work?
18:12:11 <shachaf> chare: There's an overhead incurred in calling functions in any language.
18:12:39 <dstcruz> I should really go to be. That install actually *did* work, those are just warnings, as you pointed out. Yikes. What a day.
18:12:45 <chare> if you go through something like swig then you get overhead thats avoidable
18:13:24 <hpaste> whittle pasted “FuzzyDate” at http://hpaste.org/69362
18:16:57 <whittle> mauke: Do I need to switch from using one type and multiple data constructors to using one class and multiple types?
18:17:06 <geekosaur> the opengl bindings add no significant overhead (at least now that they aren't doing silly things like pointlessly doing slow conversions to/from Rational...)
18:17:30 <parcs`> chare: then yes haskell opengl avoids that kind of overhead. calling C functions in haskell is fast. however the way the opengl functions are defined in haskell is not optimal: every call will first call glGetProcAddress, check if the function pointer is not null, then call the function pointer
18:18:45 <parcs`> while this is worse for performance (not significantly worse), it increases the portability of the package by being able to unconditionally marshal GL functions that your system does not have
18:19:53 <parcs`> geekosaur: yeah that is horribly slow. i'm surprised it took so long for anyone to notice
18:21:53 <chare> parcs: what is the difference between Haskell's ABI and C's ABI
18:22:57 <rtsguru> l
18:23:47 <rtsguru> if Haskell and C have different ABI then how can Haskell call opengl without overhead?
18:23:47 <mauke> 1) what do they have in common?  2) since when does haskell have an ABI?  3) since when does C have an ABI?
18:24:05 <geekosaur> types, mostly.  (OpenGL uses C types to minimize this; if it used Haskell's Integers it would have to marshal between C's fixed size integers and Haskell's arbitrary precision ones)
18:24:29 <rtsguru> Isn'te there something about different calling convention that makes some languages incur an overhead when making calls to C libraries
18:25:13 <mauke> how do you define "calling convention"?
18:25:31 <rtsguru> http://en.wikipedia.org/wiki/Application_binary_interface
18:26:15 <whittle> strager: Did you get a chance to look at the code I posted at http://hpaste.org/69362 ?
18:39:43 <tgeeky> is there an easy way to generate the "topmatter" haddock documentation that goes in comments before "module ..."?
19:03:10 <tgeeky> answer: steal it from someone else's package
19:24:36 <sayuke> what does the !! mean in Chunk !!ByteString ByteString. I know one ! is weak head normal form.
19:25:00 <tgeeky> @src (!!)
19:25:01 <lambdabot> xs     !! n | n < 0 = undefined
19:25:01 <lambdabot> []     !! _         = undefined
19:25:01 <lambdabot> (x:_)  !! 0         = x
19:25:01 <lambdabot> (_:xs) !! n         = xs !! (n-1)
19:25:18 <tgeeky> not that?
19:25:23 <tgeeky> no, that's a function :O
19:27:43 <JoeyA> ghc gives an error if I pass it -hide-package monads-tf (I currently don't have that package installed).
19:27:54 <sayuke> tgeeky: isnt that just list lookup?
19:28:10 <tgeeky> sayuke: yep. it's "at"
19:28:14 <JoeyA> Is there an option to hide a package without requiring the package I'm hiding to be installed?
19:28:35 <sayuke> tgeeky: this is used in a data declaration context
19:28:47 <tgeeky> sayuke: yes, that's why I said "no, that's a function"
19:29:06 <sayuke> tgeeky: well ill be damned
19:29:28 <sayuke> tgeeky: o sorry, I'm back up to date now. the world is sane
19:29:35 <JoeyA> Perhaps I should be using cabal, but it's so much slower than just compiling a few .hs files with a simple makefile.
19:29:50 <tgeeky> JoeyA: I doubt GHC will hide a package it doesn't know about
19:30:15 <JoeyA> Perhaps I'll just do -hide-all-packages and -package the ones I need.
19:30:22 <JoeyA> Nuclear launch detected.
19:30:59 <tgeeky> sayuke: I'm guessing maybe they mean the same thing as "!"
19:31:33 <tgeeky> sayuke: evidently not.
19:33:51 <tgeeky> sayuke: by all accounts I think that should be invalid?
19:44:22 <Ralith> JoeyA: try tup!
19:47:02 <JoeyA> Ralith: tup?
19:47:14 <Ralith> JoeyA: tup!
19:47:23 <Ralith> (it is like make)
19:47:27 <Ralith> (only magic)
19:47:42 <JoeyA> Whereabouts?
19:47:52 <Ralith> http://gittup.org/tup/
19:48:11 <Ralith> simpler and more concise syntax, scales better
19:48:33 <Ralith> also never requires cleaning
19:53:08 <byorgey> sayuke: did you see this in the Haddock documentation for Data.ByteString.Lazy.Internal?
19:53:16 <byorgey> I think that's a Haddock bug
19:53:43 <byorgey> if you look at the actual source code it says data ByteString = Empty | Chunk {-# UNPACK #-} !S.ByteString ByteString
19:57:27 * geekosaur was wondering if that was what was going on...
20:36:31 <mysticc> what does filterM do ..
20:36:40 <mysticc> @t filterM
20:36:40 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
20:36:49 <mysticc> :t filterM
20:36:50 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
20:38:02 <qtplatypus> mysticc: Do you know filter ?
20:38:06 <qtplatypus> :t filter
20:38:07 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
20:38:14 <mysticc> qtplatypus, Yes
20:38:24 <mysticc> I am not able to understand this
20:38:43 <mysticc> > filterM (const [True,False]) [1,2,3,4,5]
20:38:44 <lambdabot>   [[1,2,3,4,5],[1,2,3,4],[1,2,3,5],[1,2,3],[1,2,4,5],[1,2,4],[1,2,5],[1,2],[1...
20:39:11 <mysticc> > filterM (const [True,False]) [1,2,3]
20:39:12 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
20:39:55 <dmwit> mysticc: It looks at each element of the list [1,2,3] in turn, and nondeterministically chooses both to keep it and not to keep it.
20:40:30 <dmwit> The "const [True, False]" means ignore the actual value and always choose the exact two choices "yes, keep it" and "no, don't keep it".
20:40:43 <dmwit> compare
20:40:50 <zachk> @src const
20:40:50 <lambdabot> const x _ = x
20:41:02 <dmwit> > filterM (\v -> if even v then [True, False] else [False]) [1,2,3]
20:41:03 <lambdabot>   [[2],[]]
20:41:21 <aristid> > filterM (const [True,True]) [1,2,3,4,5]
20:41:22 <lambdabot>   [[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1...
20:41:32 <mysticc> dmwit,: Yeah ... thats really cool ...
20:41:46 <dmwit> Yes! So cool.
20:42:08 <mysticc> @src filterM
20:42:08 <lambdabot> Source not found. It can only be attributed to human error.
20:46:50 <dmwit> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Control-Monad.html#filterM
20:52:29 * hackagebot yesod-platform 1.0.4.2 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.0.4.2 (MichaelSnoyman)
21:16:21 <Xpl01t> e
21:24:09 <unnali> > e
21:24:10 <lambdabot>   e
21:27:32 <JoeyA> > [read -> view_id :: Int] <- getArgs
21:27:33 <lambdabot>   not an expression: `[read -> view_id :: Int] <- getArgs'
21:29:14 <geekosaur> not going to work anyway, getArgs is in IO and will be stubbed
21:29:43 <geekosaur> that's a view pattern used inside a do
21:29:51 <geekosaur> I think
21:31:04 <JoeyA> > do {(+1) -> x <- [1]; [x/2]}
21:31:05 <lambdabot>   <no location info>: parse error on input `->'
21:31:30 <JoeyA> > do {((+1) -> x) <- [1]; [x/2]}
21:31:31 <lambdabot>   [1.0]
21:32:02 <JoeyA> Surely there's a way to write ... -> ... <- ... in Haskell without parens
21:32:40 <copumpkin> lol
21:32:43 <JoeyA> case ... of x -> do this <- x
21:42:45 * BMeph wonders if newsham will keep mzero from being a liar...
21:43:27 * BMeph is, of course, referring to HP 2012.2.0.0 coming out in "May 2012"
21:46:04 <unnali> BMeph: too late for that where I live!
21:49:39 <BMeph> unnali: Right; last I heard, newsham was still in Hawai'i, which has about four hours left... :)
21:53:01 <unnali> hah! :)
21:56:37 <applicative> > do {(+1) -> x <- [1]; [x/2]}
21:56:38 <lambdabot>   <no location info>: parse error on input `->'
21:57:29 <applicative> got the wrong one
21:59:55 <applicative> > [ x | ((+1) -> x) <- [1,3] , even x]
21:59:56 <lambdabot>   [2,4]
22:00:17 <applicative> that could produce total confusion  with a bit of golfing
22:01:10 <ion> hehe
22:04:33 <applicative> > [  y | (show -> x) <- [1,3] , (ord -> y ) <- x ]
22:04:34 <lambdabot>   [49,51]
22:05:15 <applicative> somehow i'm getting used to this after the shock of JoeyA s example
22:06:30 <JoeyA> > (x,y)
22:06:31 <lambdabot>   (x,y)
22:06:40 <applicative> > [  y | (show -> (length -> (show -> x))) <- [1,3] , (ord -> (chr -> y) ) <- x ]
22:06:41 <lambdabot>   "11"
22:06:51 <applicative> my god what debauchery
22:06:53 <JoeyA> Very obfusce.  I like it.
22:07:04 <JoeyA> @google uncyclopedia Haskell
22:07:06 <lambdabot> http://uncyclopedia.wikia.com/wiki/Haskell
22:07:06 <lambdabot> Title: Haskell - Uncyclopedia, the content-free encyclopedia
22:08:00 <applicative> “Haskell is compiled from .hs-files which means HOMO SEXUAL”~ Oscar Wilde on Haskell
22:08:16 <JoeyA> View patterns are actually pretty nice for trivial command line parsing: case args of [reads -> [(n :: Int, "")]] -> do
22:08:35 <JoeyA> Expects a single integer argument, and the pattern fails if that's not what's there.
22:09:00 <JoeyA> (doesn't ignore trailing whitespace, though)
22:13:28 <applicative> > take 5 $ fix$(<$>)<$>(:)<*>((<$>((:[{- thor's mother -}])<$>))(=<<)<$>(*)<$>(*2))$1
22:13:29 <lambdabot>   [1,2,4,8,16]
22:13:34 <applicative> not too bad
22:17:14 <unnali> O_O
22:21:00 <applicative> we should have short names for each member of the power set of 'supported languages' maybe I'd be more likely to use ViewPatterns
22:21:19 <applicative> {-#LANGUAGE Amber#-}
22:21:44 <zzo38> What would -XAmber mean?
22:21:44 <lambdabot> zzo38: You have 2 new messages. '/msg lambdabot @messages' to read them.
22:21:46 <applicative> i.e GADTs, NoMono.., ViewPatterns, KindSignatures
22:22:20 <applicative> zzo38: I expected you to ask, what would -XNoAmber mean
22:22:29 <zzo38> O, you mean, it means more than one thing
22:22:41 <zzo38> But, yes, that too
22:22:57 <zzo38> I already read the messages on lambdabot isn't it?
22:23:37 <applicative> no like everyone I find it a little exhausting; i demand -fglasgow-exts, -fparis-exts, -fparis-texas-exts
22:25:14 <mikeplus64> applicative: what is the -> in [  y | (show -> (length -> (show -> x))) <- [1,3] , (ord -> (chr -> y) ) <- x ]
22:25:15 <mikeplus64> ?
22:26:02 <applicative> JoeyA was bringing up pleasing examples, its 'view patterns'
22:26:12 <mikeplus64> ah
22:27:09 <applicative> with foo (show -> str) = reverse str I get the secret backward name function
22:27:36 <zzo38> Which properties of functions can we enforce by type signatures?
22:28:04 <applicative> but to my horror also with  foo (show -> (reverse -> str)) = str
22:28:17 <applicative> i guess
22:28:36 * BMeph prefers 'foo (reverse . show -> xs) = xs'... ;þ
22:29:01 <zzo38> I don't particularly like that extension (there are even features of standard Haskell I don't like much); but you can use if you want to, and they are optional
22:29:09 <applicative> > let let foo (show -> (reverse -> str)) = str in foo 1.2
22:29:10 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
22:29:19 <applicative> >  let foo (show -> (reverse -> str)) = str in foo 1.2
22:29:20 <lambdabot>   "2.1"
22:32:40 <zzo38> As far as I can tell, it is possible to use the Category class for the Kleisli categories of monads which cannot use the Monad class
22:34:57 <zzo38> Do you know that?
22:36:53 <mikeplus64> >let foo = (show -> reverse -> s) = s in foo 123
22:36:56 <mikeplus64> > let foo = (show -> reverse -> s) = s in foo 123
22:36:57 <lambdabot>   <no location info>: parse error on input `->'
22:37:19 <unnali> > let foo (show -> reverse -> s) = s in foo 123
22:37:20 <lambdabot>   <no location info>: parse error on input `->'
22:38:18 <mikeplus64> > let foo ((show >>> reverse >>> show) -> s) = s in foo 1.234
22:38:19 <lambdabot>   "\"432.1\""
22:38:20 <applicative> another parens
22:38:25 <mikeplus64> heh
22:38:39 <mikeplus64> excellent obfuscation tool :|
22:39:23 <dmwit> > let f --> g = g . f; foo (show --> reverse -> s) = s in foo 123
22:39:25 <lambdabot>   "321"
22:39:35 <mikeplus64> > let foo (show >>> reverse >>> show -> s) = s in foo 1.234
22:39:36 <lambdabot>   "\"432.1\""
22:40:57 <zzo38> Are names in any version of Haskell permitted to include ASCII backspace characters?
22:42:33 <dmwit> No, thank goodness.
22:44:07 <zzo38> Why? They allow Unicode, so they should also allow ASCII.
22:44:56 <applicative> you are allowed to refer to them, always in scare quotes ' '
22:45:19 <tgeeky> applicative: hehe, I always think of them as saying "so called"
22:45:35 <tgeeky> '\4144' is a "so called 4144"
22:45:59 <applicative> > '\4144'
22:46:00 <lambdabot>   '\4144'
22:46:07 <applicative> > \4144
22:46:08 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
22:46:13 <applicative> hmm
22:46:30 <applicative> the soi-disant '
22:46:42 <applicative> the soi-disant '\4144'
22:47:10 <dmwit> zzo38: Many ASCII characters are allowed in names. For example, a-z, A-Z, and many more.
22:47:19 <dmwit> zzo38: Also, many Unicode characters are not allowed in names.
22:47:52 <shachaf> @hoogle Either a b -> Maybe b
22:47:53 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
22:47:53 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
22:47:53 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
22:47:59 <shachaf> This seems like it ought to be a thing.
22:48:01 <dmwit> So your argument becomes "some Unicode characters are allowed in names, therefore all ASCII characters should be allowed in names", which seems nonsensical to me.
22:48:25 <zzo38> I didn't say all ASCII characters should be allowed.
22:48:52 <dmwit> :t either mzero return -- shachaf?
22:48:53 <lambdabot> forall a b (m :: * -> *). (MonadPlus ((->) a), Monad m) => Either a b -> m b
22:48:57 <dmwit> eh
22:48:59 <applicative> all unicode brackets are forbidden except the familiar ones
22:49:04 <applicative> such a loss!
22:49:04 <dmwit> :t either (const mzero) return
22:49:05 <lambdabot> forall (m :: * -> *) a a1. (MonadPlus m) => Either a1 a -> m a
22:49:34 <shachaf> dmwit: OK, but it still seems like it ought to be a thing. :-)
22:49:43 <shachaf> @hoogle Either a b -> m b
22:49:43 <lambdabot> Data.Either rights :: [Either a b] -> [b]
22:49:44 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
22:49:44 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
22:49:54 <dmwit> zzo38: Okay. More precisely, your argument becomes "some Unicode characters are allowed in names, therefore ASCII backspace should be allowed in names", which seems even more nonsensical to me.
22:50:03 <zzo38> :t either (const empty) pure
22:50:04 <lambdabot>     Ambiguous occurrence `empty'
22:50:04 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
22:50:04 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:55:0-22
22:50:14 <geekosaur> makes perfect sense if you're an APL programmer }:>
22:50:19 <zzo38> :t either (const Control.Applicative.empty) pure
22:50:20 <lambdabot> forall (f :: * -> *) a a1. (Alternative f) => Either a1 a -> f a
22:50:37 <dmwit> geekosaur: With different premises, the conclusion might make sense, yes.
22:52:14 <applicative> > either (const Control.Applicative.empty) pure $ Left "Wing"  :: [String]
22:52:15 <lambdabot>   []
22:52:22 <applicative> > either (const Control.Applicative.empty) pure $ Right "Wing"  :: [String]
22:52:23 <lambdabot>   ["Wing"]
22:52:52 <applicative> > either (const Control.Applicative.empty) pure $ Left "Wing"  :: Maybe String
22:52:53 <lambdabot>   Nothing
22:53:02 <applicative> > either (const Control.Applicative.empty) pure $Right "Wing"  :: Maybe String
22:53:03 <lambdabot>   Just "Wing"
22:53:07 <tgeeky> > either (const |-|) pure $ Left "Wing" :: [String]
22:53:08 <lambdabot>   No instance for (Control.Applicative.Alternative
22:53:08 <lambdabot>                     ((->) ...
22:53:13 <zzo38> shachaf: If Either would be Foldable then, Prelude.Generalize.convList will also do the same thing
22:53:30 <tgeeky> > either (const (|-|)) pure $ Left "Wing" :: [String]
22:53:32 <lambdabot>   []
22:53:43 <tgeeky> > either (const (|-|)) pure $ Right "Wing" :: [String]
22:53:45 <lambdabot>   ["Wing"]
22:54:04 <applicative> @type  (|-|)
22:54:05 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a
22:54:19 <tgeeky> applicative: it's just empty
22:54:27 <zzo38> Why do they call it that?
22:54:35 <dmwit> ?hoogle traverse
22:54:35 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
22:54:36 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
22:54:36 <lambdabot> Control.Parallel.Strategies parTraverse :: Traversable t => Strategy a -> Strategy (t a)
22:54:36 <tgeeky> they don't, I added it in lambdabot
22:54:42 <tgeeky> @src (|-|)
22:54:43 <lambdabot> Source not found.
22:54:51 <tgeeky> @lets
22:54:52 <lambdabot>  Defined.
22:54:55 <tgeeky> err?
22:55:46 <shachaf> > either (pure empty) pure
22:55:47 <lambdabot>   Ambiguous occurrence `empty'
22:55:47 <lambdabot>  It could refer to either `Control.Applicative...
22:55:55 <shachaf> @ty either (pure Control.Applicative.empty) pure
22:55:56 <lambdabot> forall (f :: * -> *) a a1. (Alternative f) => Either a1 a -> f a
22:56:34 <dmwit> What is the other empty that is confusing lambdabot?
22:56:48 <dmwit> :t A.empty
22:56:49 <lambdabot> Couldn't find qualified module.
22:56:54 <dmwit> too bad
22:57:50 <dmwit> ugh, some empty regex
22:57:52 <dmwit> useless
22:58:33 <zzo38> They probably could make Either to be Foldable and Traversable.   sequenceA (Left x) = pure (Left x); sequenceA (Right x) = Right <$> x;
23:00:12 <dmwit> :t Data.Traversable.sequenceA
23:00:13 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
23:07:50 <applicative> its an outrage theres a regex empty in scope but not Text.PrettyPrint.empty
23:11:45 <Catnaroek> Hello. I have written the following Haskell program: http://ideone.com/vt3NW , whose semantics and runtime behavior I am using as benchmark to test the amount of arcane hacks one needs to fake multiparameter type classes in other languages. My main problem is that "fuck" and "orgy" are not very nice function names. What other function names could I use?
23:12:47 <Rotaerk> ..
23:13:00 <unnali> "md2 = MD "Alan Kay" -- not dead, but I wish he were"
23:13:10 <zzo38> Thinking of some kind of program I was thinking about, a type such as this might be what is wanted ((forall x. f x -> Free (CoYoneda f) x) -> Free (CoYoneda f) y -> Free (CoYoneda f) y)
23:13:19 <Catnaroek> I thought about "dance" and "party", but AFAIK only humans can dance, which would make the definition of the type class superfluous.
23:13:24 <Catnaroek> (It would only be instanced once.)
23:13:53 <applicative> > foldl1 ($$) [text x | (show -> x) <- [0..3]]
23:13:54 <lambdabot>   0
23:13:54 <lambdabot>  1
23:13:55 <lambdabot>  2
23:13:55 <lambdabot>  3
23:15:48 <applicative> > foldl1 ($$) [text x <> text y | (show -> x) <- [0..3] | (show -> x) <- [3,2..0] ]
23:15:49 <lambdabot>   Duplicate binding in parallel list comprehension for: `x'
23:15:57 <applicative> > foldl1 ($$) [text x <> text y | (show -> x) <- [0..3] | (show -> y) <- [3,2..0] ]
23:15:58 <lambdabot>   03
23:15:58 <lambdabot>  12
23:15:58 <lambdabot>  21
23:15:58 <lambdabot>  30
23:19:27 <dmwit> If I were an op, I think I'd kick you. probably an abuse of power
23:28:47 <zzo38> zz f (Free (CoYoneda x y)) = f y >>= zz f . x; -- The name "zz" here is not really what you would call it; I just gave it a name so that it can reference itself
23:29:17 <zzo38> zz :: (forall x. f x -> Free (CoYoneda f) x) -> Free (CoYoneda f) y -> Free (CoYoneda f) y;
23:29:33 <zzo38> Do you think it is?
23:30:57 <dmwit> Hm, cool. What's it do?
23:32:09 <zzo38> One possible use is if you used (Free (CoYoneda f)) to represent a monad that can perform actions where the f is the GADT of actions which can be performed, and then you are allowed to manipulate the actions it performs too
23:33:40 <zzo38> Free is the free monad from a functor, and CoYoneda is the left Yoneda which always makes a functor regardless of f
23:35:14 <zzo38> Do you know of other use?
23:37:29 <dmwit> I fear it's too late at night for me to understand it well enough to guess if I know of other uses. =P
23:47:16 <zzo38> Do you think what I mentioned is a possible use?
23:56:20 <whittle> @pl R (B d) (A d)
23:56:20 <lambdabot> R (B d) (A d)
23:56:49 <dmwit> ?pl \d -> R (B d) (A d)
23:56:49 <lambdabot> liftM2 R B A
23:57:31 <ClaudiusMaximus> zzo38: is it related to http://hackage.haskell.org/package/MonadPrompt ?  not really sure what your zz's type means, and it's a bit early here to think hard
23:57:54 <zzo38> I have not checked yet
23:59:44 <whittle> ?pl \d -> R (B d) (A $ p d)
23:59:45 <lambdabot> liftM2 R B (A . p)
