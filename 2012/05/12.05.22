00:02:15 <tmiw> speaking of IDEs--any recommendations? i'm currently using textmate on mac and vim everywhere else.
00:02:52 <mgsloan> I like sublime text quite a bit.  I think emacs via ghc-mod has much better haskell integration, though
00:03:30 <shachaf> Perhaps Emacs with ghc-mode will get even better with GHC 7.6!
00:04:11 <newsham> lighttable?
00:04:13 <newsham> :)
00:05:05 <mgsloan> shachaf: Ohhhh yeah, I can't wait for those 7.6 features
00:05:21 <mgsloan> I actually had my own version of holes
00:05:33 <kallisti> > fix (foldr (:) []) [1,2,3]
00:05:34 <lambdabot>   Couldn't match expected type `[t1] -> t'
00:05:34 <lambdabot>         against inferred type `[a]'
00:05:58 <mgsloan> but it invoked ghci a ton in order to figure things out
00:06:09 <mgsloan> (type slicing)
00:06:30 <mgsloan> (err, "type error slicing")
00:06:45 <mgsloan> looking forward to having GHC do the heavy lifting for me :)
00:29:42 <flebron> So I was previously using the Maybe monad to communicate possible parsing failure. I'm now using Either for more precise errors. However, Data.Map still returns a Maybe. Did I do the composition correctly on line 24? Is there a better way, in general, to compose this sort of behavior? http://hpaste.org/68822
00:30:03 <flebron> I also ask because it would seem interesting to use the State monad instead of my ad-hoc passing of a stack everywhere.
00:31:35 <fmap> @type M.lookup
00:31:36 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
00:42:01 <ClaudiusMaximus> :t maybe (Left "msg") Right
00:42:02 <lambdabot> forall b. Maybe b -> Either [Char] b
00:43:05 <ClaudiusMaximus> :t \x -> if x > 10 then fail "msg" else Right x
00:43:06 <lambdabot> forall a a1. (Num a, Ord a) => a -> Either a1 a
00:44:01 <flebron> I tried fail before, but I think Either doesn't implement fail as Left, it just throws an exception.
00:44:10 <ClaudiusMaximus> :t fail
00:44:11 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
00:44:26 <flebron> Indeed.
00:44:28 <ClaudiusMaximus> ah, yes
00:46:55 <ClaudiusMaximus> :t fail :: String -> Either String a  -- this could be possible, though
00:46:55 <lambdabot> forall a. String -> Either String a
00:48:44 <ClaudiusMaximus> but seems it isn't implemented like that - not sure why; maybe because fail is not loved
00:53:39 <fmap> you can use throwError instead of fail
00:53:47 <fmap> > throwError "m" :: Either String a
00:53:48 <lambdabot>   Left "m"
00:56:12 <flebron> Is that the way to compose Maybe and Either, though? Perhaps there's a better way, one which doesn't exploit that I explicitly know Maybe's ctors.
01:01:34 <mm_freak> :t maybe (Left mempty) Right
01:01:35 <lambdabot> forall a b. (Monoid a) => Maybe b -> Either a b
01:02:02 <mm_freak> flebron: in other words, eliminate Maybe
01:02:46 <flebron> mm_freak, can I? Data.Map returns a Maybe...
01:03:19 <mm_freak> flebron: with the function i have just given you…  if you want to mix Either and Maybe computations, try to turn Maybes into Eithers using the formula
01:03:45 <mm_freak> Either makes a nice Alternative, when 'e' is a monoid
01:04:01 <flebron> So I'd have to say f = maybe (Left "myerror") Right, then f $ lookup …
01:04:17 <mm_freak> well, yes, that's the dirty way to do it
01:04:23 <flebron> What's the pretty way?
01:04:30 <mm_freak> mempty instead of "myerror"
01:04:42 <flebron> Well how can I tell it what error to spit out?
01:05:06 <mm_freak> use the dirty way =)
01:05:09 <flebron> :p
01:05:24 <mm_freak> the interpretation:  Maybe is a failable computation with an unspecified error
01:05:49 <mm_freak> in the Monoid model you leave it unspecified…  whenever you can specify it you start with an Either in the first place
01:06:10 <mm_freak> in other words:  if you have a library function that returns a Maybe, where the possible error is clear, use a "dirty" wrapper
01:07:18 <mm_freak> i'm calling it "dirty" because it's in some sense ad-hoc…  doesn't mean it's bad, it's just outside the model
01:07:56 <flebron> Right.
01:08:13 <flebron> I think I'll try using the State monad as well, since it seems hackish to pass around the parser's stack every time.
01:08:22 <kallisti> I would be interested to see the performance differences between pointfree and non-pointfree code.
01:08:29 <kallisti> but I think that's difficult to do in a scientific way
01:08:48 <osfameron> *is* there a performance difference?
01:09:20 <newsham> arent the points free? :)
01:09:26 <mm_freak> the point-free variant is slower in theory, but in practice it gets optimized to the same version
01:09:56 <mm_freak> at least for usages of (.)
01:18:28 <Ralith> newsham: so yes, the points are free.
01:18:28 <Ralith> :D
01:20:12 <womb> \o
01:24:04 <mm_freak> how efficient is Rational for integral values?
01:24:40 <roconnor> mm_freak: I suspect it isn't specialized at all.
01:24:58 <roconnor> *suspect*
01:25:29 <mm_freak> that's not what i mean…  i mean:  if the denominator is always 1, does it still simplify using gcd all the time?
01:25:46 <roconnor> mm_freak: I imagine so.
01:25:51 <mm_freak> hmm, ok
01:26:16 <roconnor> but it has been a number of years since I looked into this
01:26:51 <dmwit> gcd returns PDQ when one of its arguments is 1.
01:27:19 <mm_freak> it seems to be as fast as Integer for integers
01:27:44 <mm_freak> (3 :: Integer)^10000000 is as fast as (3 :: Rational)^10000000
01:28:13 <mm_freak> not so for sums, but the difference isn't large
01:28:48 <dmwit> I wonder if Rational has a rewrite rule that specializes (^).
01:29:05 <dmwit> Since you know you don't have to call gcd for the multiplications in a (^).
01:30:00 <dmwit> Yes it does.
01:30:12 <dmwit> So that's why you're seeing such good performance for ^).
01:31:27 <mm_freak> indeed…  it's much slower if i do this:  foldl' (*) 1 (replicate 100000 (3 :: Rational))
01:31:42 <dmwit> Oh, well.
01:31:50 <mm_freak> compared to ":: Integer" that is
01:31:51 <dmwit> (^) at least uses repeated squaring even in the non-specialized form.
01:31:55 <shachaf> mm_freak: Well, even if it didn't specialize that, you can expect it to do repeated squaring.
01:31:57 <dmwit> Oh, okay.
01:32:08 <mm_freak> shachaf: i'm comparing raw multiplication time
01:32:19 * shachaf is one step behind dmwit, clearly.
01:32:25 <mm_freak> "foldl' (*) 1 (replicate 100000 (3 :: Integer))" takes 0.21 secs
01:32:30 <mm_freak> the Rational version takes 1.9 secs
01:32:45 <dmwit> Actually, I'm a bit confused.
01:33:59 <dmwit> Since it seems I was misreading GHC.Real, and it doesn't have a specialized version for Ratio.
01:34:02 <mm_freak> is there a better way to represent probabilities?  i need to be able to divide and want results to be as exact as possible
01:34:47 <dmwit> If Rational works, it'll be faster than the alternatives.
01:35:14 <mm_freak> the point is:  i'm saving the total number of possibilities separately…  then i just save the number of occurences for each outcome…  so far i would need only integers
01:35:22 <womb> mm_freak: rational is storing numbers as <before dot> and <after dot> forgot english names :D
01:35:35 <dmwit> Aaaaah, here we go, {-# RULES "(^)/Rational" (^) = (^%^) #-}
01:35:44 <mm_freak> now i want to be able to adjust one probability without having to update all individual numbers…  by a simple formula i get to update only the total number of occurences
01:36:14 <mm_freak> but that formula involves division and results in fractionals, so i can't use integers anymore
01:36:36 <mm_freak> however, Double suffers from its inability to represent something like 1/3
01:41:25 <dmwit> So, is SPECIALISE GHC's version of C++'s templating?
01:41:37 <bitonic> dmwit: lol.
01:42:02 <bitonic> SPECIALISE simply tells GHC to create non-polymorphic versions of functions
01:42:17 <shachaf> dmwit: In that it generates code, but not semantically.
01:43:22 <shachaf> (I mean that it's just an optimization.)
02:01:25 <kallisti> > do { x <- [1..10]; let x' = x + 1; return x'}
02:01:26 <lambdabot>   <no location info>: parse error on input `}'
02:01:29 <kallisti> can someone explain this to me?
02:01:53 <kallisti> I was pretty sure this was a thing I could do. is it not possible with semicolon syntax?
02:01:58 <mauke> > do { x <- [1..10]; let {x' = x + 1}; return x'}
02:01:58 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
02:02:11 <kallisti> ah it's ambiguous
02:02:41 <ozgura> > do x <- [1..10]; let x = x + 1; return x'
02:02:42 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
02:03:02 <ozgura> oops
02:07:19 <edsko> @pl \msg -> sendMany sock msg `onException` N.sClose sock
02:07:19 <lambdabot> (`onException` N.sClose sock) . sendMany sock
02:21:58 <hpaste> RM pasted “Concurrent Channels” at http://hpaste.org/68833
02:25:29 <hhb_> In the recent Parallel Haskell Digest an example was posted on concurrent channels. http://www.well-typed.com/blog/66 I've tried to created the simplest example I can, but it will not compile. Can you help me? http://hpaste.org/68833
02:26:53 <fmap> and the error is?
02:26:57 <alpounet> hhb_, could you paste the error?
02:28:28 <hhb_> alpounet: yes, thanks http://hpaste.org/68834
02:28:45 <hhb_> fmap: thanks, http://hpaste.org/68834
02:29:27 <alpounet> hhb_, use newTChanIO
02:29:35 <alpounet> newTChan returns a TChan in the STM mona
02:29:35 <alpounet> d
02:29:52 <mauke> or atomically
02:30:42 <hhb_> alpounet: perfect, thanks. Compiles and runs :)
02:31:27 <alpounet> it's that or indeed: atomically newTChan, as mauke suggests. atomically just lets you run STM transactions, and newTChan is one.
02:38:44 <kylaline> Is it normal to end up with an "else" that doesn't do anything because the statement the "if" checks would rather throw an error than return False, or does it mean I'm doing something wrong?
02:40:11 <Botje> kylaline: can you give an example?
02:41:19 <kylaline> Botje: https://gist.github.com/2767888
02:42:39 <mauke> kylaline: why does eeldusedTaidetud return Bool?
02:43:07 <kylaline> what else would it return?
02:43:40 <mauke> kylaline: Int
02:43:45 <mauke> kylaline: [Double]
02:43:51 <mauke> kylaline: Map String Bool
02:44:19 <kylaline> what would I do with that?
02:44:31 <mauke> what would you do with a Bool?
02:44:41 <mauke> they're equally nonsensical
02:44:42 <kylaline> well nothing but it would be similarly ugly
02:44:53 <mauke> so. why did you use Bool?
02:46:09 <kylaline> because the eeldusedTaidetud checks preconditions, and if then seemed to fit with the spirit of it
02:46:21 <mauke> it doesn't
02:47:34 <hhb_> So, I've tried a simple Datagram server as many ways as I can find to try. I thought concurrent channels would help, but in a simple test, I drop 25% of packets. If I compile with -threaded then I drop 90%. Any ideas what I am doing wrong? http://hpaste.org/68836
02:48:37 <hpaste> mauke pasted “tukelda” at http://hpaste.org/68837
02:49:24 <kylaline> mauke: so you're saying they just shouldn't be put in a separate function?
02:50:54 <hpaste> mauke annotated “tukelda” with “tukelda (annotation)” at http://hpaste.org/68837#a68838
02:54:20 <arcatan> does anyone know if there's a new Haskell Platform release coming this month?
02:58:53 <aristid> arcatan: "Next release: May 2012"
02:59:09 <aristid> arcatan: so at least it's _planned_. no idea on whether they will be able to do it
02:59:19 <arcatan> looking at the mailing list, they're working on it
03:07:39 <hhb_> One observation about this http://hpaste.org/68836 is that it using 100% cpu when no traffic is being sent. Does anyone know how to fix that?
03:10:02 <arcatan> hhb_: I'm guessing forever $ return () is the problem
03:11:46 <arcatan> hhb_: a simple solution would be that instead of forking the consumer, just run it in the main thread
03:12:23 <hhb_> arcatan: it will block if I put it in the main thread. It is suppose to be concurrent
03:14:30 <arcatan> oh, hmm.
03:14:50 <hhb_> I think that if I can get the cpu down, this might actually perform.
03:14:52 <womb> can type name start with : ?
03:15:12 <womb> data Lol = :One | :Two
03:15:13 <womb> ?
03:15:30 <womb> > data Lol = :One | :Two
03:15:31 <lambdabot>   <no location info>: parse error on input `data'
03:15:43 <womb> > let :One = 1
03:15:44 <lambdabot>   <no location info>: parse error on input `:'
03:15:46 <womb> ;/
03:16:23 <mauke> womb: that's not a type name
03:17:05 <womb> yes you are right
03:18:44 <arcatan> hhb_: compile it with -threaded and put the consumer in the main thread
03:22:33 <hhb_> arcatan: that performs the best yet, but it still looses 3% of packets
03:36:51 <manish411> hi haskellers
03:37:06 <manish411> how is commenting done in haskell??
03:37:11 <manish411> I am a newbie
03:37:37 <mauke> -- one line
03:37:42 <mauke> {- a
03:37:44 <mauke> block -}
03:38:01 <manish411> ok
03:54:59 <zark4711> hi
03:55:17 <hpaste> RM pasted “Concurrent Channels” at http://hpaste.org/68840
03:56:02 <zark4711> i am a noob and dont recall do notation correctly
03:56:10 <zark4711> what other ways are there to write
03:56:11 <zark4711>     filePaths <- traversePath sitesDir
03:56:11 <zark4711>     print filePaths
03:56:21 <hhb_> arcatan: FYI, this works best so far http://hpaste.org/68840
03:56:32 <zark4711> i know of traversePath sitesDir >>= print
03:56:37 <hpaste> RM pasted “Concurrent Channels” at http://hpaste.org/68841
03:57:27 <zark4711> but is there something similar to this (which i wrongly guessed would just pass the parameter invisibly):
03:57:37 <zark4711> traversePath sitesDir
03:57:37 <zark4711> print filePaths
03:57:41 <zark4711> sorry
03:57:44 <zark4711> traversePath sitesDir
03:57:45 <zark4711> print
03:57:48 <zark4711> i meant
03:58:03 <zark4711> ... within a do-block
03:58:10 <hpc> not really
03:58:32 <hpc> that first bit of code is as nice as you are going to get that, unless there's more to go on
03:59:02 <hpc> if sitesDir is a parameter, you can do something like
03:59:22 <hpc> {- as opposed to foo sitesDir = traversePath sitesDir >>= print -} foo = traversePath >=> print
04:00:05 <hpc> or to make it look more like function composition, foo = print <=< traversePath
04:00:38 <zark4711> hmm.
04:00:40 <arcatan> hhb_: btw, here's something about making the main thread to wait for the children threads. http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent.html#g:12
04:01:00 <hpc> zark4711: that's mostly different for the sake of differentness though :P
04:03:06 <manish411> hi!! neone into parsec library??
04:04:04 <manish411> I m trying to make a parser for left - recursive grammer by converting it into non-left recursive grammer
04:04:30 <manish411> however I am a bit confused as to how to deal with the epsilon in productions
04:04:56 <manish411> can I use try ove a complete do block ??
04:05:12 <manish411> mean outside a do {   }  block
04:06:08 <Cale> manish411: You can apply try to any parser, including one which is constructed with a do-expression
04:06:48 <Cale> manish411: You can also use  return v  to successfully match the empty string, returning some value v.
04:06:53 <manish411> so is this syntax correct     try ( do {    } )
04:07:05 <manish411> yes I want to match empty string
04:10:31 <womb> guys :)
04:10:39 <manish411> ok so return '  ' solved my problem
04:10:40 <Botje> manish411: uh .. there's no point in that.
04:10:43 <womb> is there ant / rake / make like tool for Haskell ?
04:10:49 <Botje> womb: ghc has --make
04:11:02 <Botje> womb: and there's cabal for more involved stuff
04:11:05 <womb> Botje: thanks can i wrote scripts for it ?
04:11:15 <Botje> womb: no, that's only for building.
04:11:18 <womb> i need something like rebar so i will be able to add templates etc.
04:11:20 <donri> @hackage shake
04:11:21 <lambdabot> http://hackage.haskell.org/package/shake
04:11:34 <manish411> made my first parser using parsec
04:11:36 <manish411> :D
04:11:48 <womb> thanks for shake
04:19:03 <donri> what is rebar?
04:19:21 <boku> Guys, Haskell doesn't support raw string syntax like C# (@) or Python. Can this feature be added with Template Haskell?
04:19:35 <donri> oh erlang
04:20:08 <sipa> what is raw string syntax?
04:20:16 <donri> womb: cabal for building most haskell projects, shake for a generic haskell-based build system / task runner
04:20:31 <donri> boku: sure
04:20:46 <donri> basically s = QuasiQuoter { quoteExp = stringE } or something like that
04:20:54 <donri> sipa: no escape codes
04:21:31 <donri> boku: but depending on what you're trying to do there might be a better quoter than mere strings (like regexen, parsed at compile time, see package "rex")
04:21:33 <finnrobi> I don't think I've ever used raw strings for anything but regular expressions
04:22:30 <boku> donri: Thanks. So you think that rex will be better than TH?
04:22:49 <donri> rex uses quasiquoting (which is a TH feature)
04:23:09 <donri> the regex syntax is checked at compile time so you get less runtime errors
04:23:39 <boku> donri: Oh, I'll try, thanks again.
04:23:41 <donri> @hackage rex
04:23:42 <lambdabot> http://hackage.haskell.org/package/rex
04:24:29 <donri> if you use vim you can even get some syntax highlighting for rex quotes ;) https://github.com/dag/vim2hs
04:25:21 <boku> donri: No, I'm emacs user.
04:26:10 <donri> aye :)
04:30:32 <bxc> is it possible to make cabal install use another repo in addition to the hackage one? I have a bunch of my own code that I use cabal for (in various packages) but I don't want to push to hackage but do want to cabal dependency management on.
04:30:55 <mgsloan> Author of rex here :D  glad to see people know about it!!  I had no idea that there was highlighting for it!
04:31:42 <donri> yea the regex-side of it is rather crude, mainly the point is to highlight the inline haskell i guess
04:33:31 <mgsloan> donri: yup.  One other static benefit is knowing how many patterns are matched
04:33:43 <donri> ah yea
04:33:45 <hhb_> Heskallers, have you noticed how the term "real time" is being used to mean something like streaming + automatic? Just give in or fight it? If fight it, what is a better term?
04:33:59 <mgsloan> more recently I've been doing fancier things with inline haskell in QQ
04:34:00 <mgsloan> https://github.com/mgsloan/quasi-extras/blob/master/examples/Example2.hs
04:35:27 <mgsloan> this uses ast-literal-patterns to implement reduction of arithmetic that happens to be in terms of constants
04:36:18 <mgsloan> unfortunately, school has caught up to me, and I need to work on finishing up the next couple weeks before going much further with it
04:58:11 <opqdonut> the canonical example of using par is: a `par` b `pseq` f a b
04:58:22 <opqdonut> why not: a `par` b `par` f a b
04:58:38 <opqdonut> the latter will create one more spark, but otherwise the behaviour should be the same, right?
04:58:46 <hpc> no
04:58:54 <hpc> pseq specifies order of evaluation
04:58:58 <opqdonut> I know
04:59:09 <hpc> in a `par` b `par` f a b, you can get recomputation
04:59:36 <opqdonut> blackholing should prevent that in most cases, right?
05:01:26 <hpc> http://hackage.haskell.org/packages/archive/parallel/latest/doc/html/Control-Parallel.html#v:pseq
05:02:47 <hpc> hmm
05:02:57 <hpc> opqdonut: might want to wait for someone who knows this better :P
05:07:56 <emias> n
05:51:48 <edsko> @pf (\err -> caseInvalid err >>= \st -> return (st, ()))
05:51:48 <lambdabot> Maybe you meant: bf pl
05:51:51 <edsko> @pl (\err -> caseInvalid err >>= \st -> return (st, ()))
05:51:51 <lambdabot> (flip (,) () `fmap`) . caseInvalid
05:52:42 <boku> I asked about raw strings in Haskell about an hour ago. You advised to use package rex. But there is redundant functionality in it. I don't need regexs, I just wanna write "\begin\end" instead of "\\begin\\end"? Do other solutions exist?
05:54:01 <edsko> @pf p >>= \a -> return (a, ())
05:54:01 <lambdabot> Maybe you meant: bf pl
05:54:02 <edsko> @pl p >>= \a -> return (a, ())
05:54:02 <lambdabot> flip (,) () `fmap` p
06:04:35 <tazjin> Urgh, 21st centuries and I'm having encoding issues with the LDAP package :|
06:09:37 <edsko> @pf \a -> return (RemoteEndPointInvalid err, a)
06:09:37 <lambdabot> Maybe you meant: bf pl
06:09:38 <edsko> @pl \a -> return (RemoteEndPointInvalid err, a)
06:09:38 <lambdabot> return . (,) (RemoteEndPointInvalid err)
06:11:03 <edsko> @pl \err -> (,) (RemoteEndPointInvalid err) <$> caseInvalid err
06:11:03 <lambdabot> ap ((<$>) . (,) . RemoteEndPointInvalid) caseInvalid
06:12:11 <edsko> @pl \err -> liftM ((,) (RemoteEndPointInvalid err)) $ caseInvalid err
06:12:11 <lambdabot> ap (fmap . (,) . RemoteEndPointInvalid) caseInvalid
06:15:18 <byorgey> heh, funny that @pl knows "liftM = fmap" but not (<$>) = fmap
06:16:34 <edsko> yeah, I generally prefer <$> actually. not so impressed by ap (fmap . (,) . RemoteEndPointInvalid) caseInvalid though :)
06:18:00 <byorgey> what's unimpressive about it?
06:18:19 <edsko> unreadable
06:18:30 <byorgey> edsko: well what do you expect when calling @pl?
06:18:44 <edsko> heh :) fair enough. sometimes a good suggestions, usually, not :)
06:19:10 <byorgey> if you call @pl on  a function  \x -> ...   where x occurs more than once in ..., you are pretty much guaranteed to get something unreadable.
06:19:23 <edsko> yeah
06:19:29 <byorgey> because it has to use 'ap' to duplicate the argument.
06:19:33 <edsko> sure
06:20:01 * byorgey actually finds  ap (fmap . (,) . RemoteEndPointInvalid) caseInvalid  quite readable as far as @pl output goes ;)
06:20:08 <edsko> :-)
06:20:18 <edsko> maybe so, but I think (\err -> (,) (RemoteEndPointInvalid err) <$> caseInvalid err)
06:20:18 <edsko>  is better :)
06:20:56 <frerich> As a Haskell beginner, I find the equality between liftM and fmap and  and... I thought there was something else. Anyway, I find it a bit confusing that there are so many names for the same thing. One of those was first, no? Maybe fmap? I wonder why somebody thought it was useful to introduce other names for the same function.
06:21:01 <byorgey> edsko: I completely agree =)
06:21:33 <Eduard_Munteanu> frerich: nah, they're not the same thing, they make sense in different contexts.
06:21:37 <Eduard_Munteanu> :t fmap
06:21:37 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:21:38 <Botje> frerich: because they apply to different things.
06:21:40 <Eduard_Munteanu> :t liftM
06:21:40 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
06:21:51 <Botje> frerich: liftM works on monads, whereas fmap works on functors
06:21:58 <byorgey> frerich: the problem is that the Monad class does not require Functor, even though all (mathematical) monads are (mathematical) functors
06:22:07 <Botje> it just so happens that monads are *also* functors, so fmap also works on monads.
06:22:28 <byorgey> frerich: so liftM can be defined in terms of the Monad methods, and fmap is a Functor method, and mathematically they ought to be the same but Haskell does not require it.
06:22:44 <byorgey> I should say, the Haskell standard libraries do not require it.
06:22:47 <frerich> Aaaah, I see, I knew that monads are functors but I didn't realize that in Haskell, being a monad does not imply being a functor (as in, the type class).
06:22:55 <byorgey> frerich: right, exactly.
06:23:01 <edsko> yeah, a bug imho :)
06:23:32 <byorgey> frerich: then further complicating things is the fact that Applicative was invented long after Functor and Monad, but lies exactly in between them
06:23:49 <byorgey> which introduced yet more mathematically-equal-yet-not-equal-in-Haskell stuff
06:23:53 <byorgey> such as liftA2 = liftM2
06:24:39 <arcatan> there has been talks of making Functor/Applicative a superclass of Monad but obviously it would break lots of code etc.
06:25:37 <Philippa> I think we should start using transitional LANGUAGE pragmas more, on that front
06:26:01 <Philippa> especially as you can automate testing which one's needed
06:26:30 <arcatan> LANGUAGE BetterPrelude :)
06:26:57 <arcatan> (let's revamp Num hierarchy while we're at it)
06:32:35 <Philippa> arcatan: I'd split it up smaller at first, but yes
06:32:41 <Philippa> and Applicative should be in Prelude!
06:32:57 <danr> that would be nice... and the (->) r instance
06:38:30 <S11001001> and presumably semigroup over monoid, bind over monad, apply over applicative, invariant over functor, etc?
06:40:20 <Gurrag> What is the name of that other Haskell wiki besides the "Haskell Wiki" at haskell.org?
06:40:27 <Gurrag> I think it's got "git" somewhere in the URL
06:41:03 <bitonic> Gurrag: if you're talking about gitit, that's a wiki software
06:43:02 * hackagebot xkcd 0.1 - Downloads the most recent xkcd comic.  http://hackage.haskell.org/package/xkcd-0.1 (RobertSelvek)
06:43:25 <b52> im curious, does many of you guys use haskell at work?
06:44:55 <Eduard_Munteanu> Gurrag: this sort of stuff? http://hackage.haskell.org/trac/haskell-prime/
06:45:00 <S11001001> not quite as useful as prelude-php, but nice
06:45:58 <Gurrag> I actually don't need the link I was asking for; I didn't know that the official Haskell Wiki had the same information as the alternate hosted one I was looking for; thank you for the help
06:46:50 <byorgey> the alternate one was just set up by someone as a proof of concept
06:48:51 <Eduard_Munteanu> b52: some do, I hear. Certain companies use it for internal stuff, or certain programmers use it for prototyping / designing software.
06:49:51 <mm_freak> b52: i do
06:50:02 <b52> mm_freak: what do you use it for?
06:53:23 <mm_freak> b52: networking mainly, but also small tools
06:55:00 <womb> Guys i have an idea, i'm building a scraping platform and i think about creating a small language in haskell just for purpose on scraping so it would have a very limited capabilities. do you think it is a good idea
06:55:08 <womb> i could go with a route of DSL
06:55:20 <womb> but i fear i will have security obsticle
06:55:34 <womb> i want to give users ability to write this scripts
06:56:33 <Eduard_Munteanu> womb: you could write an interpreter instead
06:57:03 <womb> Eduard_Munteanu: yes i thought i can base my project on Scheme48h interpreter tutorial
06:57:06 <womb> i liked it
06:57:18 <shirt> @google Safe Haskell
06:57:20 <lambdabot> http://www.haskell.org/ghc/docs/7.2.2/html/users_guide/safe-haskell.html
06:57:20 <lambdabot> Title: 7.20.�Safe Haskell
06:57:42 <womb> it needs to be human usable :D
06:58:28 <womb> shirt: i need to read about it, thanks!
06:58:40 <Eduard_Munteanu> Alternatively, you could use SELinux or maybe seccomp to restrict the code.
06:59:12 <womb> i need to do research on it, thanks guys for ideas.
06:59:32 <Eduard_Munteanu> IIRC, luite did something based on SELinux and cgroups to restrict arbitrary code.
06:59:36 <Eduard_Munteanu> Maybe you should ask him.
07:00:35 <dcoutts_> bxc: in case you didn't get an answer to your earlier Q, the answer is yes
07:23:05 * hackagebot cpuid 0.2.2.2 - Binding for the cpuid machine instruction on x86 compatible processors  http://hackage.haskell.org/package/cpuid-0.2.2.2 (HenningThielemann)
07:28:06 * hackagebot cpuid 0.2.3 - Binding for the cpuid machine instruction on x86 compatible processors  http://hackage.haskell.org/package/cpuid-0.2.3 (HenningThielemann)
07:43:40 <solidus-river> is haskell really memory intensive? trying to find a flaw in building a web server with it
07:44:09 <solidus-river> i'm thinking maybe compared to imperative interprative languages it will take up much more memory due to the thunks
07:44:34 <Entroacceptor> it doesn't have to
07:45:08 <solidus-river> Entroacceptor: only if your really carefull about design though, correct? and that would be somewhat limiting?
07:47:15 <solidus-river> i guess you could specify at compile time an upper limit, but what does that do with the interpretor, if you need it does it crash or does it garbage collect some older thunks and then re generate them (seems like it would slow to a crawl)
07:47:40 <mauke> uh. what
07:48:06 * hackagebot timeplot 1.0.9 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-1.0.9 (EugeneKirpichov)
07:48:39 <Entroacceptor> mauke knows more than me ;) But there are web servers written in Haskell
07:48:48 <Entroacceptor> quite a lot, actually, and they are in use
07:49:02 <solidus-river> mauke: this is a bad time for me to go into a discussion about it so i should bring it up later but i'm trying to start a debate about whether or not haskell would be a bad/good base for a webserver due to memory usage
07:49:15 <S11001001> start a debate?
07:49:22 <mauke> why do you think haskell is memory intensive?
07:49:24 <solidus-river> start a debate / dig for information
07:49:31 <solidus-river> i'm figuring this is not a question that is going to have a definite answer
07:49:50 <solidus-river> muake: i was under the impression that thunks can become memory intensive
07:49:53 <absence> mm_freak: after considering what you told me about events coming from e.g. a reader monad instead of from the wire input wrapped in Maybe, i've come to wonder, what is the input for such a wire network? just dummy values?
07:50:14 <Taneb> I thought it was memory intensive because it's difficult to modify objects, but copying happens all the time
07:50:49 <S11001001> shall I compare thy memory usage to a summer's day?
07:51:08 <solidus-river> S11001001: can you write a poem about it please?
07:52:13 <mauke> Taneb: if you never modify an object, you never have to copy old stuff
07:53:20 <solidus-river> i guess in a web server you wouldn't be significantly modifying objects except when serving up a page or rendering a template, but then that would probably be done in IO
07:53:20 <Taneb> I'm not really sure what I'm talking about, I'll be honest
07:54:00 <solidus-river> i'm still working my way through learn you a haskell (chapter 10) so i've got a ways to go as well
08:07:25 <parcs`> solidus-river: memory intensive compared to what? c?
08:07:44 <mauke> ruby
08:07:55 <parcs`> i hope not
08:14:41 <mm_freak> absence: generally my application has a fully polymorphic input type
08:14:51 <mm_freak> app :: MyWire a Something
08:15:31 <mm_freak> in some cases the output type is (), namely when the wire already causes the app-specific side effects
08:15:41 <mm_freak> this can be useful or evil, depending on what the wire does
08:16:09 <sordina2> What are some interesting monads that don't default the behavior of (>>)?
08:17:48 <absence> mm_freak: do you often use the polymorphic input for anything
08:17:49 <parcs`> sordina2: do you mean monads that provide an optimized implementation of (>>)?
08:17:49 <absence> ?
08:18:06 <parcs`> because the default behavior is the only behavior
08:18:16 <Taneb> @src (>>)
08:18:17 <lambdabot> m >> k      = m >>= \_ -> k
08:18:29 <fmap> @src [] (>>)
08:18:29 <mm_freak> sordina2: (>>) is a special case of (>>=), so the default implementation is always correct…  any semantically different implementation is wrong
08:18:29 <lambdabot> xs >> ys      = concatMap (const ys) xs
08:18:55 <mm_freak> absence: yes…  you can interpret a wire with fully polymorphic input as a so-called "behavior" from classical FRP
08:19:18 <mm_freak> you only use input, if a wire's behavior actually depends on other wires' output
08:22:44 <sordina2> parcs` mm_freak, Yes, but there still must be some that do something interesting with it.
08:23:00 <sordina2> Even if it has the same behavior.
08:23:31 <mm_freak> sordina2: yes, they optimize
08:23:32 <Gurrag> does (x:xs) in the @src for take imply that the list passed into it will be separated into a (car, cdr)-esque tuple for processing?
08:23:47 <sordina2> mm_freak: Any in particular?
08:23:50 <mm_freak> Gurrag: that's one way to interpret it
08:24:06 <mm_freak> sordina2: i'm having difficulty to come up with a monad for which i wouldn't write (>>)
08:24:21 <Gurrag> so you could say that a non-empty list will match (a:b) ?
08:24:33 <ski> yes
08:24:35 <armlesshobo> yes
08:24:38 <ski> Gurrag : in fact even `a:b'
08:25:01 <sordina2> mm_freak: I'm looking to find some interesting examples to show a friend.
08:25:36 <armlesshobo> > let a:b = []
08:25:36 <lambdabot>   not an expression: `let a:b = []'
08:25:46 <armlesshobo> ?
08:25:56 <armlesshobo> i did it on ghci :(
08:26:01 <rwbarton> that's not an expression
08:26:11 <ski> > let a:b = [] in ()
08:26:12 <lambdabot>   ()
08:26:13 <ski> > let a:b = [] in a
08:26:14 <lambdabot>   *Exception: <interactive>:3:4-11: Irrefutable pattern failed for pattern a ...
08:26:19 <ski> > let a:b = [0,1,2] in a
08:26:20 <lambdabot>   0
08:26:21 <armlesshobo> ahh
08:26:31 <mm_freak> sordina2: pick any monad you like
08:26:37 <armlesshobo> how come I got away with it in ghci?
08:27:07 <absence> mm_freak: understood :) and just to make sure i've not misunderstood more fundamental stuff - the output is e.g. a GameState type with the result of the wire network taking care of key presses and so on, which can be used for drawing etc?
08:27:16 <armlesshobo> does it assume "...in ()"?
08:27:17 <rwbarton> ghci accepts more than just expressions
08:27:21 <rwbarton> no
08:27:24 <armlesshobo> ok
08:27:55 <sordina2> mm_freak: I know I can go looking for examples. I was wondering if anyone here had any they thought were interesting.
08:28:47 <rwbarton> "let pat = expr" in ghci is a let statement that binds whatever variables are in pat for the rest of your ghci session
08:28:47 <mm_freak> absence: well, the result should be a game state instant independent of whatever happened /inside/ the wire…  events can cause the game's "trajectory" to bump
08:28:53 <mm_freak> sordina2: dunno, pick Maybe
08:29:08 <mm_freak> Just _ >> x = x;  Nothing >> _ = Nothing
08:29:45 <mm_freak> or equivalently:  x >> y = maybe Nothing (const y) x
08:30:12 <mm_freak> while:  x >>= f = maybe Nothing f x
08:30:24 <mm_freak> :t \x f -> maybe Nothing f x
08:30:25 <lambdabot> forall a a1. Maybe a1 -> (a1 -> Maybe a) -> Maybe a
08:31:48 <rwbarton> that seems like a good demonstration of why you would not bother implementing (>>) specially for Maybe
08:32:42 <Gurrag> is do-notation considered cheating?
08:32:53 <Botje> it's there to be used
08:32:54 <parcs`> cheating at what?
08:32:58 <hughfdjackson> life
08:33:02 <hughfdjackson> :p presumably
08:33:02 <sordina2> mm_freak: Thanks, but Maybe's (>>) doesn't seem very interesting.
08:33:10 <parcs`> is haskell considered cheating? because look, no memory management!
08:34:04 <hughfdjackson> If do notation is guilty of anything, it's just confusing me ;)
08:34:23 <Taneb> > Nothing >> Just 1
08:34:24 <lambdabot>   Nothing
08:35:14 <navaati> (>>) is useful for precondition check
08:35:58 <ment> is there a system(3)?
08:36:41 <armlesshobo> so, is the result of the last expression in a do-block what gets returned?
08:36:48 <armlesshobo> in a function
08:37:35 <ment> armlesshobo: yeah
08:38:11 <armlesshobo> ment: even if the d-block is inside an if-then-else statement, right?
08:38:11 * hackagebot git-annex 3.20120522 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20120522 (JoeyHess)
08:38:13 <rwbarton> the result of the do-block is the result of the last expression in the do-block... provided that makes sense
08:38:17 <armlesshobo> do-block*
08:38:27 <armlesshobo> ok
08:38:43 <rwbarton> it sounds like you might be getting the wrong idea...
08:38:50 <armlesshobo> most likely
08:40:11 <rwbarton> there is no magic relation between a do-block and the "function" it is "in"
08:40:49 <rwbarton> if your function returns a do-block, then when the return value of the function is executed, the result will be the result of the last line of the do block
08:41:03 <rwbarton> but your function might do something else with the do-block besides return it directly
08:41:04 <armlesshobo> rwbarton: right
08:43:21 <ski> @hoogle system
08:43:22 <lambdabot> System.Process system :: String -> IO ExitCode
08:43:22 <lambdabot> System.Cmd system :: String -> IO ExitCode
08:43:22 <lambdabot> package system-argv0
08:43:25 <ski> ment : ^ ?
08:47:15 <mm_freak> armlesshobo: note that a monadic action has nothing to do with functions
08:47:28 <mm_freak> the result of a monadic action has nothing to do with the result of a function
08:47:51 <mm_freak> if you have something like:  A -> m B, where m is a monad, then the function's result is an m B, not a B
08:48:01 <mm_freak> and if you have m B, then you don't have a function at all
08:49:11 * armlesshobo thinks he's gonna have read up on what a Monad is
08:49:55 <edwardk> Monads are overrated. Clearly we should use right kan extension transformers
08:49:55 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:50:08 <sipa> armlesshobo: in short, it's a spacesuit, a burrito and a few other things at once
08:50:29 <mm_freak> armlesshobo: don't, you'll just harm yourself
08:51:04 <armlesshobo> lmao
08:51:26 <mm_freak> learn Maybe, Either e and [], then learn Reader e, State s and Writer l
08:51:30 <mcstar> is it possible, to read an IORef with a view pattern? i.e. a function receives an IORef, and i extract the value  right from the function argument definition?
08:51:33 <Gurrag> Maybe/Just/Nothing are monads, right?
08:51:42 <mm_freak> mcstar: no
08:51:49 <mcstar> o.O
08:51:55 <mm_freak> mcstar: but you can do:  (f -> x) <- readIORef ref
08:52:14 <mcstar> hm
08:52:21 <mm_freak> but that's really just:  x <- fmap f (readIORef ref)
08:52:47 <mcstar> the point would be to not pollute the functin body with the read
08:53:20 <mm_freak> mcstar: reading an IORef is an IO effect…  you can't cause it in a pure context
08:53:25 <rwbarton> you can't avoid it though, the read is an IO action, it might matter when you execute it w.r.t. other IO actions
08:53:45 <mcstar> yeah i get it
08:53:57 <mm_freak> mcstar: if you want to get rid of it, get rid of the IORef in the first place
08:54:03 <mcstar> haha
08:54:12 <mcstar> you mean stick with c++?
08:54:14 <mcstar> XD
08:54:23 <rwbarton> presumably this function does more with the IORef than just reading it
08:54:31 <mm_freak> if for some reason you need it, consider a function like this:  IORef s -> (State s a) -> IO a
08:54:38 <ski> Gurrag : `Maybe' is a monad. `Just' and `Nothing' are values, not types, so can't be monads
08:55:20 <mm_freak> mcstar: just a note, i write large scale applications without ever using a single IORef =)
08:56:03 <mcstar> mm_freak: im your exact opposite
08:56:32 <mcstar> my prefix trie has 3 IORef fields
08:56:49 <mcstar> 1 stores a vector, the other 2 stores integers
08:56:50 <ski> @type flip Data.IORef.atomicModifyIORef . ((snd &&& fst) .) . runState
08:56:51 <lambdabot> forall a b. State b a -> GHC.IORef.IORef b -> IO a
08:57:02 <absence> mm_freak: for cases like glut where i have to gather events first and then stepwire through them, is it "okay" to use Maybe inside the reader monad (as opposed to a Maybe input), or is there a better way to design it?
08:57:03 <mcstar> (two index values, to keep track of things)
08:57:19 <mm_freak> mcstar: why?
08:57:35 <mcstar> mm_freak: i dont see how else could it work
08:57:47 <mm_freak> absence: depends, what does the Maybe wrapper represent?
08:57:52 <mcstar> i have to replace that vector periodically with a bigger one
08:58:26 <mm_freak> mcstar: for a prefix trie i would consider a Seq instead
08:58:58 <mcstar> where is that?
08:59:23 <mm_freak> Data.Sequence
08:59:44 <mm_freak> not even that actually
08:59:49 <mcstar> dont appreviate if you talk to newbies :)
08:59:54 <mcstar> bb
09:00:26 <mm_freak> perhaps something like this:  data Trie k a = Leaf a | Branch (Map k (Trie k a))
09:00:27 <mcstar> i dont see how that would solve anything
09:00:39 <mcstar> mm_freak: nono i want it mutable
09:00:48 <mm_freak> why?
09:00:51 <mcstar> i dont want a pure one, that i have done long ago
09:00:58 <mcstar> im exploring mutability in haskell
09:01:12 <mm_freak> tries are the wrong data structure to explore that
09:01:21 <mm_freak> it makes no sense to have a mutable trie
09:01:56 <mcstar> well, this prefix kind of trie afaik is usually implemented with mutable arrays in thenodes
09:02:15 <mm_freak> quotation needed
09:02:25 <mm_freak> in fact i'm having difficulty finding a good example of where you actually want mutability
09:02:34 <ski> maybe splay trees ?
09:02:40 <mm_freak> the only good example i can come up with is the sieve of eratosthenes
09:02:59 <mcstar> i dont really care now about these academic points, its a learning experience, i just picked this
09:03:11 <mm_freak> i don't think you want mutability for a splay tree
09:03:23 <mm_freak> mcstar: nothing academic about that
09:03:58 <mm_freak> mcstar: one interesting way to explore mutability is to explore the concurrency features of haskell
09:04:04 <mm_freak> STM et al
09:04:07 <nyingen> Does pattern matching on a Text object incur a big performance hit compared to using == ?
09:04:11 <absence> mm_freak: the input event that all the wires that either inhibit or are identity (like quitKey in your earlier example) will check against
09:04:32 <mm_freak> nyingen: you mean like when using OverloadedStrings?
09:04:39 <nyingen> yes
09:05:07 <mm_freak> nyingen: there will be a performance difference compared to CAFs with preconstructed Texts and (==)
09:05:13 <mm_freak> but i doubt it will be large
09:05:30 <nyingen> ok
09:05:52 <mcstar> mm_freak: in usual languages, it is an academic question, to whether or not implement a trie in a mutable or immutable way, i think
09:05:54 <Luke> I want to make a conduit wrapper around my database IO. I think it was recommended not to build a conduit source from "sourceIO" - what's the recommended way to build it?
09:05:58 <nyingen> I assume with actual String, the behavior for matching and == are identical, no?
09:05:59 <mm_freak> absence: i usually create an Event type against which the various event wires pattern-match…  depending on the application there can be a NoEvent constructor
09:06:44 <mm_freak> mcstar: in haskell it has practical implications…  a mutable tree structure is harder to implement and use for no immediate gain
09:06:55 <rwbarton> how do you pattern match on Text
09:07:12 <mm_freak> rwbarton: -XOverloadedStrings
09:07:16 <rwbarton> if you do it using OverloadedStrings it just means using ==
09:07:45 <mm_freak> nyingen: if you don't use OverloadedStrings and pattern-match against a string, it is actually a constructor match
09:07:45 <mcstar> mm_freak: a naive immutable version probably wont be as fast, the guys who did Data.Trie must have done a great job
09:07:59 <mm_freak> nyingen: there is no difference between "abc" and 'a':'b':'c':[]
09:09:10 <mm_freak> mcstar: tree performance is about its sharing properties, not about its mutability
09:09:24 <mm_freak> i wouldn't be surprised to see a mutable implementation perform /worse/
09:10:18 <mm_freak> you need to essentially program C in haskell to get reasonable performance there, including the client interface…  and it would be extremely awkward to have:  lookup :: Tree k a -> Seq k -> IO (Maybe a)
09:10:42 <absence> mm_freak: ahh yes, i thought of that, but considered it "pretty much the same" as wrapping it in Maybe. is a NoEvent better?
09:11:06 <mm_freak> absence: if you have a single event type, using a Maybe is sufficient
09:11:18 <mm_freak> absence: otherwise i would go with NoEvent
09:11:37 <mcstar> mm_freak: would you enlighten me, whats the purpose of the seq there?
09:11:39 <mm_freak> absence: data Event = NoEvent | Events Event Event | QuitEvent | ThisEvent | ThatEvent
09:11:46 <mm_freak> absence: that allows you to write a Monoid instance for Event
09:12:12 <mm_freak> mcstar: it's a prefix tree…  k is the type of "characters", the alphabet
09:12:24 <mm_freak> and a key is a sequence of characters
09:12:33 <mcstar> oh
09:12:37 <absence> mm_freak: that makes sense. thanks for your patience, i'll go tinker now :)
09:12:43 <mm_freak> absence: have fun =)
09:13:12 <mcstar> mm_freak: you mean insteaf of [Char] i should use Seq Char?
09:13:43 <navaati> bah. after a week trying to find why netwire and it's inhibition stuff is better than yampa style… i still can't get why. I have the strong impression that netwire is not designed to model continuous behaviours, only "do something when there is an event" stuff
09:13:47 <mm_freak> mcstar: Seq gives better performance for finite all-in-memory sequences
09:14:35 <mcstar> mm_freak: even if those sequnces are short? i.e. words for example
09:14:52 <rwbarton> it depends on the operations and yes, the size
09:15:38 <T_X> hi, I'm currently reading about and playing with cabal. for GPL licensing, what's the best way to add the "or later" terms?
09:15:44 <adz_> What's wrong with this guy http://scrollingtext.org/apache-log-ip-counting ? Posted code with stack overflow, and does not correct it, although there is a solution in the comments!
09:15:53 <mm_freak> mcstar: my observation is that Seq is much faster as long as the sequences are constructed in such a way that they fully live in memory…  if you do something lazier you may want to use lists instead
09:16:16 <mm_freak> navaati: this is difficult to explain in a single IRC line
09:16:18 <T_X> just adding the according header to the .hs file and/or changing "GPL3" to "GPL3+"?
09:16:56 <mm_freak> navaati: it replaces events and switching by inhibition, giving you a monoid-like FRP arrow
09:17:18 <mcstar> mm_freak: contains (PFTrie (readIORef -> ar) _ _) string = ar >>= go string 0
09:17:18 <mm_freak> navaati: you can then combine application components in a similar fashion as happstack does it for server parts
09:17:28 <mcstar> seems i can use viewpatterns to read IORef's
09:17:32 <mm_freak> navaati: this gives you much better composability than yampa
09:18:27 <mm_freak> mcstar: you can't…  "ar" has the type IO X
09:18:43 <navaati> hum… actually i feel like netwire is meant to be used with Applicative, not with Arrow
09:19:01 <mcstar> mm_freak: thats ok, but i could apply the transformation
09:19:05 <mcstar> and thats what i wanted
09:19:13 <mm_freak> mcstar: you still need "x <- ar"
09:19:24 <rwbarton> did you read the whole line
09:19:49 <mm_freak> navaati: it supports either style…  sometimes you want arrow style, but usually you want applicative style
09:19:54 <mcstar> rwbarton: who?
09:19:55 <mm_freak> you can mix them freely
09:19:57 <rwbarton> mm_freak
09:20:19 <mm_freak> ah, true
09:20:23 <rwbarton> though i agree sort of, you are not really reading the IORef in the view pattern, just construction the action of (later) reading it
09:20:27 <rwbarton> *constructing
09:20:28 <mm_freak> but i don't see the big advantage
09:20:38 <rwbarton> nor do i
09:20:39 <mm_freak> it makes your code harder to understand, too
09:20:56 <navaati> mm_freak: yeah, because doing something like "keyEvent -< ()" is *really really* ugly…
09:22:18 <mm_freak> navaati: well, that's one of the cases where you want neither Arrow nor Applicative, but really just Category =)
09:22:32 <navaati> but i still can't find a way to make my code less ugly, or more idiomatic, using this inhibition paradigm…
09:22:50 <mm_freak> quittingWorld . quitKeyEvent <|> regularWorld
09:23:37 <mcstar> i agree, that there are better use cases for view patterns
09:23:52 <mcstar> but im the only one reading that code
09:24:30 <mm_freak> mcstar: view patterns for single-pattern matches are just a way to get rid of let-bindings…  i abandoned them for that case…  they are less to type, but make the code harder to understand when you have to come back to it later
09:24:53 <mcstar> yeah, i dont branch on the result
09:25:53 <navaati> mm_freak: yeah, but the overall arrow will only be quittingWorld _at the instant of_ quitKeyEvent, and come back to normal world immediately after, which is not really usefull : i need to have it be quittingWorld _from the moment of_ quitKeyEvent
09:26:15 <mm_freak> navaati: you can hold the event
09:26:27 <mm_freak> quittingWorld . swallow quitKeyEvent <|> regularWorld
09:28:23 <mm_freak> you can also use "hold quitKeyEvent", but as the actual value is not interesting, swallow saves some memory
09:28:36 <mm_freak> swallow switches to the constant wire upon first production
09:28:48 <mm_freak> while hold switches to holdWith
09:30:46 <mcstar> mm_freak: i have some memory of reading about syntactic sugar for dealing with IORefs, you know something about this?
09:31:02 <mm_freak> mcstar: there is no syntactic sugar specifically for IORefs
09:31:04 <absence> mm_freak: if you want to switch between two worlds, do you use something like oneWorld . (worldFlag id) <|> otherWorld . (worldFlag not) ?
09:31:33 <absence> mm_freak: on second thought, "worldFlag not" isn't needed
09:31:56 <mm_freak> absence: the question is still interesting…  an often overlooked wire is the 'edge' wire
09:32:52 <mm_freak> there are also specialized variants like 'asSoonAs' and 'while'
09:33:23 <navaati> hum, ok… and atm i have something like :
09:33:23 <navaati> currEvent ∷ GlossWire a Event -- with type GlossWire = WireM () (ReaderT (Time Float) (Reader (Maybe Event)))
09:33:23 <navaati> currEvent = constant (lift ask) >>> arrM >>> injectEvent
09:33:23 <navaati> as my event producer, is it the right way ?
09:33:35 <mm_freak> loadingScreen . while . arr isLoading <|> world
09:34:40 <mm_freak> navaati: generally you'll want to avoid injectEvent
09:34:57 <navaati> how i am supposed to create my event producer, then ?
09:35:14 <navaati> i don't see any other way…
09:35:41 <mm_freak> navaati: the proper way is to write a small DSL for your low level library (gloss in this case) by directly accessing the monad (see mkGenM and mkPure)
09:35:55 <mm_freak> then build your application on top of that DSL
09:36:14 <mm_freak> in an ideal world there is a library netwire-gloss that implements the DSL on top of netwire
09:36:18 <navaati> well, that's why i was trying to do with currEvent
09:36:32 <navaati> i tried to store directly a "GlossWire a Event" in the Reader, but then i don't know how to get it back
09:36:33 <mm_freak> you don't want currEvent
09:36:38 <mm_freak> you want wires that react to certain events
09:36:58 <mm_freak> of course you can define them in terms of a currEvent, if you wish
09:37:01 <navaati> (currEvent is only a step to later have a keyEvent, etc.)
09:37:30 <navaati> yeah yeah of course, but i still need injectEvent
09:37:43 <mm_freak> injectEvent is fine if you don't want to interface with the monad directly
09:38:02 <mm_freak> just view injectEvent as reserved for use by the DSL
09:38:21 <navaati> yeah, that's the case
09:38:51 <navaati> this currEvent is not part of my app wire
09:39:38 <mm_freak> i'd say you got it =)
09:39:53 <navaati> i still don't see the interest of inhibition, though…
09:41:06 <Gracenotes> Does anyone know much about random graph generation for an arbitrary number of nodes and edges? As in, more sophisticated things to do than, say, m < n(n-1) edges have the same probability of appearing between n nodes?
09:41:49 <mm_freak> navaati: in yampa you have to use switching for everything, which is very inconvenient, especially if you have to switch back and forth
09:42:14 <mm_freak> of course you can only appreciate this if you have tried to use yampa/animas productively =)
09:43:42 <navaati> i must admit that it's not been easy to wrap my head around switching, but… i find it more powerful in the end
09:44:06 <navaati> (and it's neither been easy to wrap my head around inhibition
09:44:13 <mm_freak> navaati: switching is supported by netwire…  it's a superset of yampa
09:44:45 <navaati> ah ? interesting, how do you do that ?
09:44:58 <mm_freak> it has some very powerful switches in fact, see the Control.Wire.Trans.Combine module for example
09:45:14 <mm_freak> in fact "wire transformers" are all kinds of fancy switches
09:47:00 <mm_freak> in fact, netwire up to 1.2.7 included most switching combinators found in yampa, but removed them in later releases
09:47:06 <mm_freak> http://hackage.haskell.org/packages/archive/netwire/1.2.7/doc/html/FRP-NetWire-Switch.html
09:47:28 <navaati> (because i'm starting to think that my example problem does actually fit well the switching paradigm)
09:47:58 <mm_freak> what is your example problem?
09:48:42 <osa1> what is `s` parameter of data "STUArray s i e" for?
09:49:22 <mm_freak> osa1: it's the phantom type used in ST s
09:49:32 <ski> for identifying the "state thread" in which the array is allocated
09:49:38 <mm_freak> osa1: it makes sure that the array can't escape the ST context
09:49:49 <navaati> i've got a dot on the screen, when i press left key it heads to left, when i press right it heads to the right, when i press down it stops, when i press up it sticks to the mouse
09:49:59 <ski> it also makes sure that access to the array is sequentialized
09:50:45 <mm_freak> navaati: that sounds to me like a holding event
09:51:33 <mm_freak> navaati: you would write wires for the specific directions and a wire that represents a dot with the given direction
09:52:00 <mm_freak> then you would select one of them based on the current holded event and pass the rsult to the dot wire
09:52:19 <mm_freak> no explicit switching involved…  'hold' is an implicit switcher
09:52:59 <mm_freak> in fact you would start with holdWith here
09:53:19 * hackagebot statistics-dirichlet 0.6.1 - Functions for working with Dirichlet densities and mixtures on vectors.  http://hackage.haskell.org/package/statistics-dirichlet-0.6.1 (FelipeLessa)
09:53:46 <navaati> hum… i don't really understand, what would be the types ?
09:55:30 <mm_freak> navaati: a straightforward way is this:  holdWith StandStill (MoveLeft <$ leftKey <|> MoveRight <$ rightKey <|> …)
09:56:03 <mm_freak> then you have a wire:  dot :: MyWire Direction Dot
09:56:14 <mm_freak> this is just an integral
09:56:21 <mm_freak> see the .Calculus module
09:57:31 <mm_freak> then you just compose the two:  dot . direction
09:57:40 <shapr> mmm, code
09:57:59 <navaati> hum, that's pretty close from what i do atm, except the "<$" and "<|>" trick (with arrows it looks very ugly)
09:58:33 <mm_freak> i use arrows only for ArrowChoice and ArrowLoop
09:58:44 <mm_freak> otherwise Category/Applicative is usually much nicer to work with
09:59:58 <navaati> it's actually a bit more complicated than an integral because when the mouse is used to set the position of the wire, and i go back in Left mode, i want the dot to go left from the mouse position, not from (0,0)
10:00:11 <Luke> I'm trying to construct a conduit source from a lazy DB read -> list. it looks like Conduit.List.sourceList might be a nice helper but I'm not sure if I can use it with Database.HDBC.fetchAllRows etc. anyone have any suggestions?
10:00:27 <mm_freak> navaati: still an integral to me
10:00:51 <navaati> yes, but the "integral" wire doesn't work
10:01:04 <mm_freak> navaati: unless you need an instantaneous following of the mouse
10:01:10 <navaati> yeah
10:01:14 <navaati> i do
10:01:52 <navaati> the problem is that when i switch back to the integral, because of inhibition it start from before the FollowMouse mode
10:02:07 <mm_freak> navaati: you can still make this work using ArrowLoop
10:02:08 <navaati> (but writing a custom version of integral has worked)
10:02:11 <navaati> yep
10:02:45 <mm_freak> but yes, the integral wire doesn't allow instantaneous jumps
10:03:16 <mm_freak> you can emulate them with a data loop, but it can get messy…  i have planned to add a more powerful integral wire anyway
10:03:55 <navaati> oh, another thing : how do i decide the granularity of primitive events ? or rather : what is the way to make an eventKeyLeft from an eventKey
10:05:03 <mm_freak> navaati: that's up to you…  you could have a keyEvent wire that outputs the key pressed and then use that with 'require'
10:05:21 <mm_freak> in general you will want to have a fully polymorphic input type, as far as that's possible
10:05:29 <mm_freak> that makes it easy to combine with (<|>)
10:05:55 <mm_freak> but in this particular case i would go with leftKeyEvent
10:06:32 <navaati> it's a bit cumbersome to do this for every letter of the alphabet
10:07:04 <mm_freak> of course
10:07:09 <mm_freak> that's really only for this particular case
10:07:37 <mm_freak> but it is useful to have a keyEvent wire like this:  keyEvent :: Key -> MyWire a a
10:07:51 <navaati> so an user of netwire-gloss would do something like "fmap (isLetter 'A') keyEvent >>> require", right ?
10:07:59 <navaati> aaaah, ok
10:08:28 <navaati> got it
10:08:32 <navaati> well, let's code then
10:08:59 <mm_freak> if you plan to release, place an upper bound on the netwire major version =)
10:09:07 <navaati> 'k
10:09:08 <mm_freak> i tend to change the API between major versions
10:09:20 <navaati> that's what major versions are for
10:09:35 <mm_freak> yeah
10:26:00 <hpaste> armlesshobo pasted “"why come this won't compile?"” at http://hpaste.org/68848
10:27:35 <navaati> armlesshobo: you need "return"
10:27:50 <armlesshobo> really?
10:28:04 <Nimatek> "rejecting: bin-package-db-0.0.0.0/installed-eb0... (package is broken)" oh, cabal..
10:28:06 <armlesshobo> i thought the result of the last expression is the returned value
10:28:33 <dschoepe> armlesshobo: return is different from the return you know from imperative programming
10:28:53 <Taneb> A lot of those FilePath -> Bool look like they should be FilePath -> IO Bool
10:28:54 <geekosaur> lots of redundant "do"s in there (it is not a magic talisman) and one redundant use of $
10:29:07 <dschoepe> armlesshobo: Also, validDIr needs to return an IO Bool, which is why you need return to transform a Bool (`True') into an IO Bool (`return True')
10:29:07 <geekosaur> egregiously redundant,that is
10:30:28 <armlesshobo> dschoepe: why does it need to return an IO Bool?
10:31:06 <navaati> do notation should be a language extension, so that beginners have to get their hands dirty with bind…
10:31:06 <dschoepe> armlesshobo: Because validDir uses IO functions such as doesDirectoryExist, hence it cannot return a pure value (e.g. one of type Bool)
10:31:33 <dschoepe> armlesshobo: I.e. validDir has the wrong type signature.
10:31:49 <navaati> dschoepe: beware : it *does* return a pure value :-p
10:32:19 <armlesshobo> dschoepe: I though that it didn't matter as long as the type of the result of the last expression matched the signature
10:32:21 <geekosaur> let's be confusing, shall we
10:32:32 <navaati> huhuhu
10:32:46 <dschoepe> navaati: An ill-defined function doesn't return values of any kind!
10:33:01 <navaati> haha, true
10:33:02 <mm_freak> navaati: i disagree…  beginners just need a guiding hand into do-notation
10:33:25 <geekosaur> armlesshobo, but the last expression's type is determined by the previous expression's type.  they're not as independent as you might think
10:33:34 <armlesshobo> oh no...
10:33:35 <armlesshobo> lol
10:33:38 <mm_freak> i found that especially people coming from imperative languages feel home with do-notation and just need to be introduced to recursion instead of looping
10:33:41 <navaati> do notation hides the fact that you construct an "IO a" value
10:33:49 <mm_freak> yes, it does
10:34:01 <navaati> well it's bad
10:34:16 <navaati> (or rather : i think it's bad)
10:34:16 <mm_freak> depends on how IO has been introduced to you
10:34:27 <shapr> Anyone know where I can find Network.Wai.Middleware.RequestLogger ?
10:34:35 <ski> armlesshobo : if you have `do x <- blah; bleh x; y <- bloh x; bluh', then the type of `bluh' must have the form `m a' for some type `m' (which should be a monad) and some type `a' -- and `m a' is then also the type of the whole `do'-expression
10:35:41 <armlesshobo> so, the result of do is 'm a' where a is the type of the last expression?
10:35:53 <Nimatek> I think introducing people to monadic IO and then showing how do-notation is sugaring away all the >> and >>= works better.
10:36:46 <hughfdjackson> ditto on what Nimatek said
10:36:50 <navaati> with this approach the whole "IO actions are first class values" is eluded, which is a bit sad
10:37:44 <hughfdjackson> i've been struggling with monads and io on and off, and it wasn't until i read this today http://stackoverflow.com/a/194207 that it started making sense
10:37:52 <hughfdjackson> or.. rather, more sense
10:38:03 <ski> armlesshobo : no, the type of the `do'-expression is `m a', where the type of the last command is *also* `m a' (not `a')
10:38:19 <hughfdjackson> (for me, this helped too: http://igstan.ro/posts/2011-05-02-understanding-monads-with-javascript.html)
10:39:00 <ski> armlesshobo : e.g. in `do putStrLn "What's your name ?"; getLine', the type of `getLine' is `IO String', which also is the type of the whole `do'-expression
10:39:30 <ski> armlesshobo : note that this expression is equivalent to `do putStrLn "What's your name ?"; name <- getLine; return name'
10:39:48 <ski> here, `getLine' still has type `IO String', and `name' has type `String'
10:39:56 <ski> so `return name' has type `IO String' again
10:40:11 <hpaste> mcstar pasted “prefix trie reloaded for the last time” at http://hpaste.org/68849
10:40:48 <mcstar> mm_freak: now that code runs in 2x the time of Data.Trie
10:41:00 <armlesshobo> hmm
10:41:11 <armlesshobo> I totally had the wrong idea of a do-block
10:41:11 <armlesshobo> :|
10:41:27 <mm_freak> mcstar: compared to?
10:41:45 <mcstar> yes
10:42:00 <mm_freak> mcstar: i mean what was the previous factor?
10:42:22 <mcstar> well, a naive functional one did like 3x worse than this
10:43:09 <jaxtr> ahh it's a wonderful day
10:43:23 <ski> armlesshobo : .. how so ?
10:43:37 <mm_freak> mcstar: i find that unlikely…  perhaps your implementation was unfortunate
10:44:18 <armlesshobo> ski: i didn't know realize that it was type 'm a'
10:44:37 * shapr grumbles at code
10:44:41 <armlesshobo> i thought it just allowed you to evaluate a block of expressions
10:45:13 <mcstar> mm_freak: i wrote mine, http://hpaste.org/68330, then found this blog http://alexandersgreen.wordpress.com/2010/09/13/prefix-trees-in-haskell/, these run in the same time
10:45:35 <mcstar> roughly 20 secs, comapred to Data.Trie's 2.5 secs
10:45:55 <mcstar> now my last version of mutable is around 5 secs
10:46:20 <mm_freak> mcstar: i find the representation very unfortunate…  let me write my own variant
10:46:25 <barrucadu> armlesshobo: do notation is just syntactic sugar around monadic binding, the >> and >>= operators
10:46:28 <ski> armlesshobo : the `do'-notation desugars to calls to `(>>=)' (and `(>>)')
10:46:33 <mcstar> the test consists of loading 220K words(2.4MB) into the trie, and checking very word again
10:46:37 <ski> @undo do x <- foo; bar x
10:46:38 <lambdabot> foo >>= \ x -> bar x
10:46:52 <ski>   (>>=) :: Monad m => m a -> (a -> m b) -> m b
10:46:57 <mcstar> very->every
10:47:02 <armlesshobo> ski: right, like you explained to me yesterday... :P
10:47:07 <ski>                                    ^^^     ^^^
10:47:12 <armlesshobo> ski: it made sense, but I didn't understand the implications lol
10:47:40 <ski> note how the type the argument function returns, `m b', matches the type of what `(>>=)' returns
10:47:45 <mcstar> mm_freak: but i think the solution from that blog is at least elegant
10:48:22 <armlesshobo> ski: yes
10:50:06 <newsham> > do { unto others }
10:50:08 <lambdabot>   Just as you would have them do unto you
10:50:18 <geekosaur> *snrk*
10:50:25 <mcstar> mm_freak: i translated my mutable one to ocaml too, it really sucked
10:50:25 * shapr sets phasers to stun with Scotty
10:50:38 <mcstar> mm_freak: i even get segmentation fault on too many words
10:51:29 <hpaste> mcstar pasted “similar thing in ocaml” at http://hpaste.org/68850
10:54:47 <shapr> Huh, the scotty web server is really straightforward and fun!
11:02:33 <dskippy> I am experiencing an oddity with my modules. I installed Numeric.LinearAlgebra.Algorithms from the tarball just now. If I run ghci and import it, it's fine. If I make a file with just the import line and run that file with ghci, it fails to fine the module.
11:02:44 <dskippy> Why is the search path different for the two?
11:03:05 <ion> Is it?
11:03:26 <dskippy> Well, I would assume. But perhaps not. But for one it finds the module and the other it does not.
11:03:53 <dskippy> I mean, after all, I am the confused one here. I'm willing to accept I'm wrong on most aspects of this question :)
11:04:19 <ion> Embrace the ultimate power of error messages.
11:04:51 <dskippy> Yeah I have -v on and it's told me that it's looking in a relative path, but not absolutely where it is.
11:05:44 <armlesshobo> so is a monad just an abstract structure?
11:06:06 <mcstar> dskippy: maybe you start ghci in the module directory? (just a guess)
11:06:10 <armlesshobo> abstract type structure*?
11:06:35 <dskippy> mcstar: Yeah I move out of that directory to test. I'm not in my home dir. No the module is not installed there ;)
11:06:57 <tromp_> a monad is a type that is an instance oftypeclass  Monad
11:07:27 <armlesshobo> ok
11:07:28 <tromp_> Monad is the abstract one
11:08:06 <tromp_> e.g. Maybe is a monad, and Just 42 is a monadic value
11:08:30 <armlesshobo> yes
11:08:49 <hpaste> “Ertugrul Söylemez” pasted “Immutable trie implementation” at http://hpaste.org/68852
11:08:55 <mm_freak> mcstar: see the paste
11:09:15 <mcstar> mm_freak: turkish name?
11:09:17 <mm_freak> its performance can be improved by implementing a specialized 'insert' function, but i prefer to work with unions
11:09:20 <mm_freak> yes
11:09:54 <shapr> hoi tromp_ ! How's code?
11:10:12 <mcstar> mm_freak: ok thanks, ill study that, whats felxible instances?
11:10:16 <shapr> tromp_: You once proved to me that homomorphic encryption wouldn't work, but I've forgotten the links. Do you remember them?
11:10:46 <armlesshobo> tromp_: and so the types that are instances of typeclass Monad can be bound (>>=) and returned
11:10:50 <armlesshobo> (>>), right?
11:10:59 <mm_freak> mcstar: it's because of the IsString instance for Seq Char
11:11:19 <mm_freak> without FlexibleInstances the type arguments must be polymorphic
11:11:25 <mm_freak> like Seq a
11:11:42 <mm_freak> the IsString instance is really just for testing
11:11:43 <dskippy> armlesshobo: Well, you can't return any type of object. Return is wait raises a value into your monadic type.
11:12:15 <armlesshobo> dskippy: i meant to imply that the actions can happen to those types
11:12:33 <dskippy> So if you have a Integer, 4, you can get an IO Integer with "return 4"
11:12:46 <armlesshobo> right
11:12:49 <dskippy> Yeah basically.
11:13:24 <mm_freak> armlesshobo: when you interpret "IO A" as an action that produces an A on execution, then 'return' takes any value and turns it into an action that results in that value
11:13:35 <tromp_> hi Shae!
11:13:38 <dskippy> Monad is a type class that for which the type have >> and return implemented and there are a few monad laws that any reasonable implementation of the Monad class obey.
11:13:44 <mm_freak> armlesshobo: it is noteworthy that in haskell IO actions never get executed in the scope of haskell
11:13:56 <tromp_> i dont recall talking about homomorphic encryption:(
11:14:09 <shapr> tromp_: It was several years ago, before you moved to the USA.
11:14:34 <tromp_> armlesshobo: monadic values can be bound and returned...
11:14:46 <shapr> I guess I could download all the #haskell logs and grep them.
11:14:51 <tromp_> oh, my memory is not that good:(
11:15:26 <armlesshobo> so, what does it mean to 'bind'?
11:15:33 <jfischoff> what category of testing does QuickCheck fall under?
11:15:44 <armlesshobo> off the top of my head I think it means to bind something to the scope of something subsequent
11:15:49 <shapr> jfischoff: generative?
11:16:13 <jfischoff> sounds right ;)
11:16:31 <mm_freak> armlesshobo: you have an action that depends on a value (A -> IO B)…  when you apply that parametric action to an A, the result is an IO B
11:16:38 <mm_freak> like:  putStrLn :: String -> IO ()
11:16:47 <shapr> jfischoff: fuzzing is random and generative, but QuickCheck is just generative, because you can reproduce failures, and you can use things like SmallCheck to tune your testing approach.
11:16:47 <mm_freak> you apply putStrLn to "xyz", the result being an IO ()
11:17:00 <mm_freak> armlesshobo: now suppose that the value is produced by another action
11:17:15 <mm_freak> i.e. you don't have an A, but an IO A
11:17:27 <mm_freak> you need some way to connect the two…  this is what binding means
11:17:49 <jfischoff> shapr: do you set the seed of something repro? I've never tried to reproduce a QuickCheck failure
11:17:50 <mm_freak> you need a function that combines IO A and A -> IO B into an IO B
11:18:07 <mm_freak> the (>>=) function does that for you
11:18:17 <mm_freak> (>>=) :: IO a -> (a -> IO b) -> IO b
11:18:22 <mm_freak> getLine >>= putStrLn
11:18:51 <shapr> jfischoff: Yah, there's a seed and size. Heffalump challenged me to do test-driven-development with Haskell, so I hacked up QuickCheck 1 to explicitly consume a seed and size.
11:18:58 <shapr> And happily, Koen added that ability to QC2
11:19:04 * shapr digs around
11:19:15 <jfischoff> nice
11:19:20 <armlesshobo> mm_freak: so whatever get input by getLine is then bound to putStrLn
11:19:26 <armlesshobo> and that's the value that putStrLn "puts"
11:19:35 <mm_freak> armlesshobo: basically yes…  just look at the types
11:19:42 <mm_freak> getLine :: IO String
11:19:48 <mm_freak> putStrLn :: String -> IO ()
11:20:03 <mm_freak> in this case:  (>>=) :: IO String -> (String -> IO ()) -> IO ()
11:20:06 <armlesshobo> IO is a type of monad with type String
11:20:22 <armlesshobo> ok
11:20:46 <navaati> :t fmap putStrLn getLine
11:20:47 <lambdabot> IO (IO ())
11:20:53 <navaati> :t join $ fmap putStrLn getLine
11:20:54 <lambdabot> IO ()
11:20:58 <shapr> jfischoff: It starts here: http://hackage.haskell.org/packages/archive/QuickCheck/2.4.2/doc/html/Test-QuickCheck.html#v:quickCheckWith
11:21:02 <ion> > myquickcheck True
11:21:03 <lambdabot>   "OK, passed 500 tests."
11:21:09 <mm_freak> armlesshobo: the "<-" syntax from do-notation is really just syntactic sugar for (>>=)
11:21:22 <shapr> I thought one of the testing packages on hackage handled replaying failing tests, but I forget which one.
11:21:23 <mm_freak> do x <- getLine; putStrLn x = getLine >>= putStrLn
11:21:27 * shapr digs around more
11:21:28 <armlesshobo> mm_freak: i got that, just don't fully grasp (>>=) yet, it's new to me :)
11:21:52 <armlesshobo> it will click
11:21:58 <armlesshobo> and you'll know when it clicks ;P
11:22:32 <jfischoff> shapr: oh that's great. Printing out the test case every time is useful (now if it could just make HUnit tests automatically when it fails ….)
11:22:49 <mcstar> armlesshobo: did you read the 'you could have invented monads yourself(maybe you already did it)" blog?
11:22:58 <armlesshobo> mcstar: no, never heard of it
11:23:12 <navaati> haha, clicks with haskell are always great clicks :D i remember the great one for me wasn't understanding monads but understanding how the State monad works…
11:23:14 <jfischoff> shapr: also, I have used the Args one… just didn't see the seed ;)
11:23:20 <mcstar> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
11:23:38 <armlesshobo> navaati: my first one was finally fathoming partial functions :P
11:23:54 <shapr> jfischoff: Why make HUnit tests?
11:24:11 <mm_freak> armlesshobo: you can understand (>>=) just by looking at its type
11:24:14 <shapr> Ohh, I see! You want HUnit tests because that way you can explicitly see which input failed?
11:24:23 <armlesshobo> navaati: I was like "WHAT!? How is that even...what is this madness!?" lol
11:24:35 <mm_freak> armlesshobo: think of /composing/ actions
11:24:52 <shapr> jfischoff: You don't need a HUnit test as long as the generator doesn't change. You can regenerate the test case with the seed.
11:24:57 * shapr thinks
11:25:05 <navaati> it was like "omg enlightenment"
11:25:07 <shapr> Though that would mean you couldn't improve your generators
11:25:13 <jfischoff> shapr: exactly
11:25:14 <shapr> jfischoff: ok, I see how that would be a good idea.
11:25:35 <shapr> jfischoff: write it!
11:25:47 <mcstar> navaati: i dont know whats wrong with me, i didnt feel enlightened when i learned common lisp, nor when haskell
11:25:50 <navaati> personally i find the typeclassopedia explaination of monads to be the best one
11:26:12 <mcstar> stupid elusive aha moments
11:26:26 <jfischoff> shapr: hmm, okay I will. But maybe I will make it harder first. I have a crazy QuickCheck idea
11:26:42 <shapr> jfischoff: Start with simple so I can use it for my GSoC project ;-)
11:27:03 <jfischoff> shapr: hehe, okay, but you should hear the idea first
11:27:06 <shapr> ok!
11:28:04 <shapr> If you can convert between QC and HUnit tests, you could extend HUnit with shrink. That would be nifty.
11:30:12 <jfischoff> shapr: Alright so assuming you have a good way to diff all your types (like using something like the gdiff package). After QuickCheck finds a fault, it tries to tell what about the input is the problem, by comparing the bad input to all the good inputs (assuming you have some). Assuming your type is a complicated tree, any unique or statistically rare subtree is highlighted.
11:30:13 * shapr donates $10 to edwardk's category theory research fund
11:30:30 * edwardk puts it to good use
11:30:40 <shapr> edwardk: pizza?
11:30:44 <edwardk> yeah
11:30:46 <shapr> jfischoff: That's an excellent idea.
11:30:55 <jfischoff> :0
11:30:58 <jfischoff> :0
11:31:00 <jfischoff> :)
11:31:02 <jfischoff> hehe
11:31:17 <shapr> I think edwardk once told me about some testing that works vaguely like that.
11:31:17 <edwardk> jfischoff is just sitting there with his mouth open hoping i'll hand him pizza
11:31:20 <shapr> hah
11:31:27 <jfischoff> ;)
11:31:32 <jfischoff> I got it one try!
11:31:39 <shapr> I know it was some white-box testing paper from MSR that edwardk sent me...
11:31:44 <edwardk> oh yeah
11:31:53 <gdoteof> The only thing I have really been using haskell for is yesod.  how would i go about using a patched version https://github.com/yesodweb/yesod/tree/master/yesod-form within my existing project?
11:32:00 <gdoteof> i have been using cabal-dev to build executables
11:32:19 <gdoteof> i don't know enough about cabal to understand what is going on
11:32:19 <shapr> If I remember correctly, they did something like shrink where they tried to discover one or more boundaries where a small change meant the tests went from passing to not passing.
11:32:31 <shapr> edwardk: Do you remember anything about that paper?
11:32:43 <jfischoff> shrink is super helpful
11:32:47 <edwardk> http://research.microsoft.com/en-us/projects/atg/ndss2008.pdf
11:33:08 <edwardk> Automated whitebox fuzz testing
11:33:18 <gdoteof> alternatively i would be fine with just using https://github.com/yesodweb/yesod the whole repo
11:33:35 <alpounet> gdoteof, you can just get that project
11:33:48 <edwardk> basically run the compiled program, then look for provable conditions that would case you to take another direction down any of the branches as you went, and try to compute new inputs that would force the other branch
11:33:49 <jfischoff> edwardk: thanks!
11:33:53 <alpounet> and cabal-install it
11:34:00 <alpounet> well, cabal-dev install it i meant
11:34:16 <edwardk> i really enjoyed that paper
11:34:34 <gdoteof> alpounet: is it possible to do it with just the sup project?
11:34:36 <gdoteof> *sub
11:34:45 <gdoteof> as it takes forever to compile on my machine
11:34:47 <edwardk> the nice thing is it can fuzz complex file formats without any knowledge of the format
11:34:48 <alpounet> gdoteof, if it has its own cabal file
11:34:51 <alpounet> i think so
11:34:58 <jfischoff> shapr: I wonder if you could use a code coverage tool to highlight a unusual path of a bad test case?
11:35:03 <gdoteof> alpounet: ok.  it does
11:35:03 <gdoteof> thanks
11:35:15 <shapr> jfischoff: That would be extremely cool... mix together profiling and QuickCheck?
11:35:17 <edwardk> in exchange of course for a HUGE slowdown
11:35:37 <shapr> edwardk: I can live with that :-)
11:36:05 <armlesshobo> mcstar: oooooohhhhhhhh
11:36:07 <shapr> jfischoff: That's several different projects you've come up with :-)
11:36:08 <edwardk> ISTR the tests they ran took minutes/hours instead of seconds
11:36:10 <armlesshobo> mm_freak: ^
11:36:22 <shapr> jfischoff: All of which sound awesome.
11:36:29 <jfischoff> :)
11:36:29 <armlesshobo> mm_freak: is that it?
11:36:30 <mcstar> armlesshobo: hoooohohohoho
11:36:39 <armlesshobo> mcstar: XD
11:36:57 <jfischoff> shapr: yeah but I think you are right, the low hanging fruit is the QuickCheck HUnit Generator.
11:37:09 <armlesshobo> mm_freak: ... i think it just clicked....
11:37:10 <shapr> Though I'm not sure how to do it...
11:37:26 <shapr> edwardk: Thanks for finding that reference :-)
11:37:30 * shapr saves the paper
11:37:34 <edwardk> NP
11:37:47 <edwardk> there are a couple of related papers on pex as well, but i don't have them handy
11:38:11 <jfischoff> shapr: I think you would just have the output of a failed test case be haskell code of some sort. And you could append it to a file or copy and paste it.
11:38:36 <jfischoff> shapr: you would add want the correct expected is
11:39:02 <shapr> Yah, that sounds good.
11:39:05 <edwardk> clearly we need a haskell whitebox unit testing framework
11:39:17 <shapr> edwardk: I agree, and I nominate jfischoff as the author ;-)
11:39:22 <shapr> It's so easy to volunteer someone else!
11:39:24 <edwardk> sounds good
11:39:27 <jfischoff> haha
11:39:35 <mm_freak> armlesshobo: monads aren't complicated…  just don't try to understand monads in general, but particular monads =)
11:40:13 <jfischoff> np problem, I will have a half working undocumented project up in no time. It is my forte ;)
11:40:21 <armlesshobo> ok, and for clarification, IO String is an IO monad with String as the underlying type?
11:40:39 <edwardk> we'd usually say its an IO action that yields a string
11:40:53 <armlesshobo> ok
11:40:59 <shapr> jfischoff: If you put your HUnit test generator on github, there's some possibility I will contribute :-)
11:41:08 <edwardk> and reserve the phrase 'IO monad' for the way we compose IO actions
11:41:27 <jfischoff> shapr: Then its a deal :)
11:41:38 * shapr goes back to coding on prototypes for his GSoC project
11:42:46 <luite> shapr: have fun :)
11:43:00 <gdoteof> armlesshobo: as a haskell noob that had monads click for me (at least enough so that i could use ones others have made); is that when you are "in" a monad; your code is running within a certain context that is sort of like a higher dimensional reality than the code that called the monad
11:43:39 <mcstar> i have a way better analog
11:44:01 <mcstar> i feel compelled to tell it, but i wanted to write about it in a blog
11:44:14 <mcstar> no, i cant tell it yet
11:44:15 <armlesshobo> mcstar: well get writing
11:44:15 <gdoteof> so inside of your main, when you do an IO and have an IO String; there is a whole other reality in that IO String that your code in main cannot see.  in this case, the going out to the keybaord and getting the input, or putting the bits on the screen.
11:44:24 <armlesshobo> mcstar: i ain't got all day... :P
11:44:26 <armlesshobo> lol
11:45:02 <mcstar> a little hint: it has to do with star trek
11:45:17 <jfischoff> edkwardk: what sort of things would you see in a full fledged whitebox testing framework?
11:45:29 <armlesshobo> coffee
11:45:32 <armlesshobo> jfischoff: ^
11:45:39 <gdoteof> sort of like a blackbox.  you press a button and it gives you an answer.  but the reality is that there is something inside tha tblackbox going on that you can't see from the perspective outside the monad
11:45:58 <jfischoff> I meant more like features
11:46:07 <jfischoff> what features would be good
11:46:14 <jfischoff> to have
11:48:02 <andares> hey, is there a way to look up the way Prelude defines tuples?
11:48:12 <andares> I'm confused about the type declaration (a,b).
11:48:31 <andares> namely how that works -- is it syntax sugar?
11:48:35 <c_wraith> yes
11:48:46 <mcstar> > :t (,)
11:48:47 <lambdabot>   <no location info>: parse error on input `:'
11:48:57 <c_wraith> The syntax is special - the semantics are not
11:49:24 <mcstar> i just realized today , is not special
11:49:33 <c_wraith> data Pair a b = Pair a b -- exactly isomorphic to (a, b), just no special syntax
11:50:11 <andares> and the value constructor (,) is defined similarly to the way that (:) is for lists?
11:50:11 <mcstar> :t (,)
11:50:12 <lambdabot> forall a b. a -> b -> (a, b)
11:51:24 <c_wraith> andares: pretty much.  If it was syntactically valid, you could say:  data (,) a b = (,) a b
11:52:02 <ron2> hello to all, I am searchin for example of Unboxed array of tuples
11:52:12 <c_wraith> It's just that commas are special syntactically, so that isn't really going to work
11:52:13 <ron2> can't find any
11:52:23 <mcstar> c_wraith: however i cant make longer tuples with (,) than 2
11:52:40 <c_wraith> mcstar: different type.  data (,,) a b c = (,,) a b c
11:52:46 <c_wraith> :t (,,)
11:52:47 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
11:52:52 <mcstar> haha,k
11:54:11 <c_wraith> :t (,,,,,,,,,)
11:54:13 <lambdabot> forall a b c d e f g h i j. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> (a, b, c, d, e, f, g, h, i, j)
11:54:27 <c_wraith> ...  somewhere, GHC stops supporting those.  It's higher than that, though.
11:55:20 <ron2> so how could I make unboxed array of tuples?
11:55:53 <mcstar> ron2: data.vector.unboxed supports that
11:56:08 <ron2> and simple Data.Array.Unboxed?
11:56:10 <edwardk> ron2: you can use a storable array http://www.haskell.org/ghc/docs/6.12.2/html/libraries/array-0.3.0.0/Data-Array-Storable.html
11:56:16 <mcstar> (if the elements of the tuple support unbxing)
11:56:35 <edwardk> and you can use the unboxed vector type mcstar recommended
11:57:52 <ron2> Is there a way to  use Data.Array.Unboxed instead of data.vector?
11:58:02 <tac> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
11:58:03 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53. a -> b -> c -> d -> e -> f -> g ->
11:58:03 <lambdabot> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 ->
11:58:03 <lambdabot>  t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35,
11:58:03 <lambdabot> t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53)
11:58:08 <tac> eep :<
11:58:45 <mcstar> this technique is good, when i forget the abc
11:58:51 <mcstar> i just have to type commas
12:00:28 <c_wraith> z, t28?
12:00:32 <c_wraith> what happened to 27?
12:01:19 <mcstar> hm
12:01:31 <mcstar> bugreport?
12:03:35 <armlesshobo> f . g x = f( g x)
12:03:48 <ron2> but storable array is slower than IOUArray (I need mutable one)
12:04:02 <armlesshobo> whereas f >>= g is like g( f x )
12:04:05 <armlesshobo> right?
12:04:57 <mcstar> i wouldnt do that
12:06:03 <armlesshobo> no
12:06:12 <mcstar> do x <- f; g x
12:06:30 <armlesshobo> the result of f is put passed to g
12:06:57 <mcstar> and a function is not an action
12:09:51 <ron2> mcstar, do IOUArray supports having elements as tupes (of unbox elements)?
12:10:51 <mcstar> ron2: i dont think so
12:11:00 <mcstar> i went with vector, and suggest you do the same
12:11:53 <untitled> hi, what is the best way to tokenize a string, comma used as delimiter and there can be spaces before/after delimiter + tokens can occur in any order
12:12:07 <ron2> mcstar, whats the complexity of mulable vector of unboxed for element update, and read?
12:12:38 <mcstar> the trivial ones
12:12:45 <mcstar> O(1)
12:14:14 <ron2> mcstar, do you have an example of unboxed vector of tuples?
12:14:16 <armlesshobo> mcstar: so do x <- getLine; putStrLn x is the same as getLine >>= (\x -> putStrLn x)?
12:14:31 <b52> armlesshobo: yop
12:14:45 <mcstar> ron2: http://hpaste.org/68849
12:14:45 <b52> do is just sugar
12:15:24 <mcstar> armlesshobo: you can loose the lambda
12:17:36 <ron2> mcstar, can I use record instead og tuple?
12:22:23 <mcstar> oops
12:22:25 <mcstar> lose
12:22:44 <mcstar> ron2: no
12:25:06 <ron2> so the only way is to convert record to tuple
12:25:08 <ron2> ?
12:25:26 <mcstar> what are you trying to store?
12:26:53 <k-zed_> (sorry for potential derail-) is there a way to have an immutable vector type with size encoded in the type?
12:27:12 <k-zed_> e.g. if i need a 32-long array of integers.
12:28:11 <mauke> I don't know if there's a convenient way
12:28:56 <mcstar> data SizedArray = SizedArray Int Array ?
12:29:08 <Eduard_Munteanu> IIRC there were some packages that did that. Maybe some newer stuff too given TypeNaturals (is that in already or not?).
12:29:45 <mcstar> ah, i see
12:30:20 <k-zed_> if there's no idiomatic way, what's a common workaround?
12:30:30 <ron2> mcstar, some values which will be loaded and updated quite frequently
12:30:35 <k-zed_> (if i want to avoid using lists)
12:31:00 <mcstar> sata SA a = SA a Array?
12:31:00 <k-zed_> also, we can say that the array is too big to just handle as a big tuple/record...
12:31:06 <mcstar> s->d
12:31:31 <mcstar> ron2: no i mean, whats the type of the values?
12:31:39 <dmwit> k-zed_: If the sizes are known statically and come from a smallish set, it's fairly easy to write some smart constructors. Otherwise, you'll need to do some type-level natural work.
12:31:51 <dmwit> I think this is maybe one of the most re-implemented features of all time.
12:32:17 <Eduard_Munteanu> mcstar: I guess he wants typesafe indexing
12:32:27 <dmwit> There are several type-level natural packages on Hackage; I'm not sure (but there probably are) some packages for natural-indexed vectors as well.
12:32:49 <mcstar> Eduard_Munteanu: and by parameterizng the type with an int, can that be done?\
12:32:58 <dmwit> You might look into REPA a bit.
12:33:12 <Eduard_Munteanu> mcstar: not an Int, more like Peanos
12:33:53 <ron2> mcstar, Data.Word
12:34:00 <serialhex> hi all, i have a painful problem that i hope someone might be able to help me with a bit: i need to interface with some MS COM stuff & i've checked out the com package but it's old and dosn't want to compile... any (good) suggestions?
12:34:02 <tac> Eduard_Munteanu: drop 1 [piano, piano, piano]
12:34:44 <mcstar> ron2: i guess then a tuple is not really an inconvenience?
12:35:56 <mcstar> are you worried about not being able to use 'record{a=2}' style updating?
12:36:08 <Eduard_Munteanu> Hm, I guess that might've been REPA.
12:37:05 <ron2> mcstar, record is better with its named params, easer to extend stuff
12:38:01 <mcstar> ron2: how many fields do you have?
12:38:19 <ron2> mcstar, 5 for now
12:38:20 <mcstar> it cant be more than 6
12:38:54 <ron2> mcstar, why is that?
12:39:07 <mcstar> file:///home/mcstar/.cabal/share/doc/vector-0.9.1/html/Data-Vector-Unboxed-Mutable.html
12:39:14 <mcstar> :)
12:39:26 <dmwit> ron2: What's the question we're trying to answer here?
12:39:29 <mcstar> anyway, its not defined for more
12:39:40 <mcstar> you should use boxed arrays
12:39:44 <mcstar> i mean vectors
12:39:46 <dmwit> mcstar: I don't think a file:/// URL is going to work.
12:39:55 <mcstar> dmwit: thats why the smiley
12:39:59 <dmwit> heh
12:40:21 <mcstar> dmwit: btw, i could with a bit ingenuity
12:40:49 <dmwit> mcstar: What's the question?
12:41:12 <ron2> dmwit, I nees some unboxed mutable array of tuples or recors(better)
12:41:40 <mcstar> i just dont understand why you want them unboxed
12:41:56 <dmwit> ron2: So write a Storable instance and be done with it...?
12:42:34 <ron2> mcstar, performance and the memory ussage
12:42:51 <mcstar> but you already have a lot of fields, it doesnt add much
12:44:35 <ron2> dmwit, so I need to implement sizeOf, alignment, one of peek and one of poke? yes? do you have an example?
12:44:48 <dmwit> yes, yes, and no
12:45:03 <dmwit> Any package with an FFI binding ought to have some instances, though.
12:45:08 <ron2> mcstar, so you think that the boxed speed will be the same as unboxed?
12:45:35 <mcstar> ron2: http://hpaste.org/68745#a68749
12:45:38 <ron2> dmwit, the last answer was not so good :D
12:46:03 <mcstar> ron2: you can easily check it yourself
12:46:56 <dmwit> ron2: https://github.com/haskell-pkg-janitors/X11/blob/master/Graphics/X11/Xinerama.hsc#L76 for example; you could build this and then look in dist/ to see what Haskell the .hsc file got transformed into
12:47:26 <dmwit> oh, mcstar++
12:48:10 <ron2> mcstar, I am new to haskell, sorry that I bother you. So I should search in hpaste?
12:48:32 <dmwit> ron2: No, the link he gave starts right off with a Storable instance as a sample.
12:48:44 <mcstar> ron2: the annotated version of that paste(the lower one) contais a full example of how to make something storeable
12:48:48 <dmwit> So there's no need to search.
12:49:03 <mcstar> ron2: but first, just make a test case, and compare your some boxed/unboxed vectors
12:49:27 <mcstar> btw, it was written by claudius
12:50:09 <RylandAlmanza> parse error on input `)'
12:50:18 <RylandAlmanza> What is likely the problem when I get that error?
12:50:19 <ron2> dmwit, thank you. One more question: where should I search for examples? if I need ones
12:50:32 <RylandAlmanza> I've checked all the parentheses, and they all seem ok
12:51:02 <mcstar> parse error on input `)'
12:51:20 <mcstar> obviusly you need a (
12:51:25 <dmwit> ron2: I suppose another option is to declare an MArray instance directly for your data type. There's lots of examples of that here: http://hackage.haskell.org/packages/archive/array/latest/doc/html/src/Data-Array-IO-Internals.html#IOUArray
12:51:51 <andares>   banana f g = (\r -> f (g r) r) hey, is this the most concise way to write this?
12:51:56 <RylandAlmanza_> Sorry, my connection messed up or something
12:51:57 <dmwit> Other than that, I can't help much. I just gave you the first hit for "ack Storable" in my personal collection of Hackage packages. =P
12:52:06 <RylandAlmanza_> Did anyone answer my question?
12:52:08 <andares> banana has type (a -> t -> b) -> (t -> a) -> t -> b
12:52:09 <dmwit> andares: That's pretty good, yup!
12:52:15 <andares> woot!
12:52:24 <dmwit> ?djinn (a -> t -> b) -> (t -> a) -> (t -> b)
12:52:24 <lambdabot> f a b c = a (b c) c
12:52:33 <dmwit> ?src (->) (>>=)
12:52:34 <andares> djinn?
12:52:34 <lambdabot> f >>= k = \ r -> k (f r) r
12:52:51 <mauke> @pl banana f g = (\r -> f (g r) r)
12:52:51 <lambdabot> banana = flip flip id . liftM2
12:53:08 <mauke> andares: djinn generates code for a given type
12:53:10 <dmwit> andares: djinn takes a type and tries to implement it =)
12:53:12 <Cale> RylandAlmanza_: Could you perhaps paste your code on hpaste.org? It might be a layout issue.
12:53:12 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
12:53:45 <andares> whoa. how?!
12:53:58 <mauke> magic, of course
12:54:00 <andares> that is seriously space-age.
12:54:01 <dmwit> proof search
12:54:11 <andares> any link to papers or anything?
12:54:14 <hpaste> RylandAlmanza pasted “parse error on input `)'” at http://hpaste.org/68854
12:54:18 <mauke> inb4 curry-howard
12:54:48 <RylandAlmanza_> Cale: tilemapTiles returns a [[Bool]]
12:55:08 <andares> my mind is too blown. I think I need to sit down.
12:55:18 <dmwit> andares: http://scholar.google.com/scholar?q=djinn+haskell =)
12:55:27 <mcstar> no else
12:55:39 <mauke> http://en.wikibooks.org/wiki/Haskell/The_Curry-Howard_isomorphism
12:55:51 <Cale> right, your if is missing its else.
12:56:15 <dmwit> Hm, those hits aren't actually as helpful as I thought.
12:56:58 <RylandAlmanza> Fixed! Thanks guys! Didn't know else was mandatory
12:57:38 <dmwit> "For the curious, Djinn uses a decision procedure for intuitionistic
12:57:39 <dmwit> propositional calculus due to Roy Dyckhoff."
12:58:43 <mcstar> i'd cut Roy's Dyckhoff
12:58:57 <mcstar> oh, is it dike?
12:59:17 <andares> "intuitionistic"?
13:00:05 <Philippa> andares: "truth" is "has been proven" / "we have a way to construct it" - no "it must exist" proofs
13:00:09 <dmwit> Intuitionistic logic rejects the assumption that one of P or not P is definitely true.
13:00:10 <Cale> andares: as in, without the law of excluded middle
13:00:31 <schlicht> does anyone know a workaround for this bug http://hackage.haskell.org/trac/gtk2hs/ticket/1262 ? the patches i found, dont work for me
13:01:02 <andares> dmwit: like in the case of paradoxes or something?
13:01:11 <dmwit> andares: Not necessarily.
13:01:12 <mcstar> dmwit: that actually sounds non-intuitive
13:01:41 <dmwit> andares: For example, you might believe that there is some number with property P, but not be able to exhibit such a number.
13:01:53 <fmapE> Is it possible in any way in haskell to apply the function arrow (->) to just the right side argument to get a * -> * type constructor?
13:01:55 <dmwit> In intuitionistic logic, we would say that the proposition "exists n. P n" is neither true nor false.
13:02:00 <Cale> In particular, a suitable axiomatisation of it in terms of implication is provided by K: a -> (b -> a), and S: (e -> (a -> b)) -> (e -> a) -> (e -> b)
13:02:09 <dmwit> (Since you can't prove that no number has the property, and you can't exhibit a number with that property.)
13:02:38 <dmwit> fmapE: No, but you can make a newtype that swaps the order of arguments to (->) and use that instead.
13:02:48 <dmwit> In fact, I think there's a Flip newtype in some library somewhere.
13:03:43 <Cale> actually, statements P can be neither true nor false in classical logic as well, but P or not P will still hold of them.
13:04:02 <fmapE> dmwit: Yes I'd rather not do that, but you seem certain that I can't do it the other way...
13:04:05 <mcstar> dmwit: are you pretending to understand that, or you really do?
13:04:05 <andares> dmwit: ah, so you could have some function that decides whether or not a given number has the property, but you couldn't prove it false for all n without enumerating an infinite number of them.
13:04:11 <andares> (for example)
13:04:16 <dmwit> andares: right
13:04:35 <dmwit> mcstar: Intuitionistic logic systems are my job. =)
13:04:40 <dmwit> (sort of)
13:04:49 <fmapE> dmwit: I'm almost certain I've seen it used in documentation somewhere, though it might just be a notational nicety in writing
13:05:17 <dmwit> fmapE: Haskell doesn't have type-level lambdas; the result is that all type constructors must be applied to their first argument first, and their second argument second, etc.
13:05:37 <dmwit> e.g. (-> r) is a fine type constructor, but (r ->) doesn't exist
13:05:54 <andares> is there a way to prove that my function is defined for all values of a data type?
13:05:57 <ezyang> well, spell it ((->) r)...
13:05:57 <lambdabot> ezyang: You have 1 new message. '/msg lambdabot @messages' to read it.
13:06:00 <ezyang> @messages
13:06:01 <lambdabot> shapr said 2h 37m 57s ago: I want your homecooked bunch of scripts for extra Ubuntu awesomeness on your X61t!
13:06:09 <andares> I'm trying to implement something for newtype EitherLeft b a = EitherLeft (Either a b), but I don't know whether I'm hitting all the bases.
13:06:14 <sclv> fmapE its in conal's type something library.
13:06:22 <fmapE> dmwit odd...I was trying to do (-> (m ())) and it was complaining about a parse error
13:06:24 <dmwit> andares: ghc can warn you if you missed some cases.
13:06:32 <dmwit> andares: -fwarn-incomplete-patterns or something like that
13:06:42 <sclv> fmapE: typecompose! http://hackage.haskell.org/package/TypeCompose
13:06:45 <ezyang> @tell shapr Sure. Let me scrounge around and put them in somewhat presentable form.
13:06:46 <lambdabot> Consider it noted.
13:06:55 <rwbarton> dmwit has it backwards, or meant something else entirely, or something
13:07:03 <dmwit> fmapE: You're right, I got it backwards.
13:07:20 <dmwit> fmapE: (r ->) is fine, and (-> r) is wrong. Also, even for (r ->) you have to spell it ((->) r).
13:07:52 <dmwit> (which makes it more obvious why you would need a lambda for the latter: the spelling would have to be something like \v -> (->) v r)
13:08:01 <fmapE> dmwit: ...bummer ok. Thanks everybody
13:08:13 <sclv> fmapE: it was also in category-extras, but i don't know where it ended up in the ce diaspora
13:09:49 <dmwit> contravariant-Data.Functor.Contravariant.Op
13:10:04 <dmwit> But it's specialized to (->)
13:10:36 <dmwit> ack++
13:11:03 <dmwit> Ah, semigroupoids-Data.Semigroup.Dual.Dual is the non-specialized version
13:14:48 <ron2> dmwit, so after defining MArray instance I can use IOUArray as array of my type?
13:15:01 <fmapE> but if I don't want to drag in another package, I could just do newtype Flip a b c = F (a c b)
13:15:04 <fmapE> ?
13:15:18 <dmwit> ron2: That's the idea, yeah.
13:15:23 <dmwit> fmapE: yes
13:15:35 <fmapE> coolio
13:15:40 <dmwit> ...but code duplication =(
13:16:59 <otters> ugh
13:17:01 <dmwit> edwardk: Do you know of a package somewhere with Newtype instances for stuff in your various category packages? (not necessarily written by you?)
13:17:07 <fmapE> dmwit: This is code for a master's thesis, so I'm trying to make it as self-contained as possible
13:17:07 <otters> I have never seen a Parsec example that worked when I tried it
13:17:14 <otters> and by "work" I mean "doesn't throw a type error"
13:17:29 <edwardk> dmwit: as in the 'newtype' package?
13:17:29 <dmwit> Parsec has changed a lot since most of the examples and tutorials were written, yeah.
13:17:31 <edwardk> i don't have one
13:17:37 <edwardk> but you're welcome to bang one out
13:17:45 <otters> how the hell do people learn Parsec
13:17:46 <dmwit> Yep, just wanted to make sure I wasn't duplicating effort.
13:17:50 <edwardk> the problem with newtype is its not haskell 98, so i can't make instances right in the packages
13:18:09 <dmwit> semigroups-orphans here I come ;-)
13:18:37 <otters> dmwit: how do people learn Parsec?
13:18:51 <dmwit> I don't know. I learned it back when the tutorials and code were still in synch.
13:18:59 <Clint> trial and error
13:19:01 <dmwit> Read the documentation?
13:19:05 <shapr> yay!
13:19:05 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
13:19:09 <otters> Lucky
13:19:12 <otters> okay then
13:19:20 <Clint> same way we learn haskelldb
13:19:27 <otters> never heard of haskelldb
13:19:33 <dmwit> I would say a fair amount of my Haskell coding is blindly connecting things that happen to have the right types.
13:20:05 <fmapE> dmwit: One for this weeks HWN
13:20:17 <saep> that's how i got my A in functional programming :D
13:20:21 <dmwit> edwardk: Thought you might like this cute thing: http://hpaste.org/68796
13:20:25 <otters> okay then
13:21:13 <danr> dmwit: ala?
13:21:17 <dmwit> edwardk: Somebody asked how to write the Haskell-idiomatic version of \x y -> head . sort . filter (>0) $ [x, y]
13:21:20 <dmwit> =P
13:21:25 <edwardk> dmwit: cute
13:21:32 <dmwit> ?hackage newtype <- danr
13:21:32 <lambdabot> http://hackage.haskell.org/package/newtype <- danr
13:21:42 <danr> thank you!
13:22:11 <dmwit> This is Enterprise Haskell. =P
13:24:12 <otters> Parsec's types are scary
13:24:19 <danr> dmwit: did you see the comment about under2 in the documentation of ala? :)
13:24:28 <otters> ParsecT s u m a -> ParsecT s u m a
13:25:54 <dmwit> danr: What, that it's not provided because ala is provided?
13:26:23 <dmwit> If so, then what's your point? If they don't provide under2, and we need under2, what are we supposed to do other than use ala?
13:26:31 <ron2> dmwit, tanks again :)
13:27:21 <dmwit> otters: Yep. "s" is the type of the stream; "u" is the type of user (i.e. you, the programmer) state; "m" is a monad you want to transform (often Identity); "a" is the type of the thing you want to return when the parse succeeds.
13:27:32 <danr> dmwit: No... I meant it was a bit sad they did not export it now that there was a use of it.
13:27:40 <dmwit> oh =)
13:28:00 <dmwit> I agree, I wish they had exported a few under's even though ala is quite general. =)
13:35:37 <armlesshobo> ugh...haskell has become my crack addiction ...
13:35:38 <armlesshobo> :(
13:41:02 <mm_freak> yeah, haskell and similar languages can be very addictive =)
13:43:05 <serialhex> +1 haskell addict...  haskellers anon anyone?
13:43:08 <mcstar> Simon Peyton Jones, one of the greatest junkies
13:43:20 <mcstar> or PSJ?
13:43:25 <mcstar> no
13:43:27 <mcstar> SPJ
13:43:45 <hiptobecubic> ESP
13:45:36 <frigga> How are the default Enum instances implemented?
13:46:09 <frigga> Are they a naive list implementation, or some kind of more efficient map?
13:46:24 <Botje> of what?
13:46:25 <jonaskoelker> Hello, I'm Jonas and I'm a haskaholic
13:46:41 <mcstar> hello, Jonas!
13:46:43 <jonaskoelker> :)
13:47:21 <serialhex> hi Jonas!
13:47:32 <jonaskoelker> haa-eee :)
13:47:40 <tac_> I just come here for the free Pizza every Tuesday.
13:47:47 <byorgey> frigga: can you give a concrete example of a type about whose Enum instance you would like to know?
13:47:59 <byorgey> I don't know what "the default Enum instances" means
13:48:03 <jonaskoelker> tac_, haskell knowledge is just a side effect? ;-)
13:48:16 <mcstar> controlled side effect
13:48:18 <tac_> jonaskoelker: Nope. Haskell doesn't have side effects
13:48:25 <frigga> byorgey: Any type I might define like...data Foo = Bar | Baz | ... deriving (Enum)
13:48:32 <mm_freak> #haskell has side effects
13:48:37 <gdoteof> anyone know something about yesod?  its really a general haskell question i have and #yesod is pretty quiet at the moment.  i ran into a bug with yesod; and there was a lightning fast fix put into the git repo
13:48:48 <gdoteof> i wanted to test that out but i have been having a hard time
13:48:51 <gdoteof> i cloned the yesod repo
13:48:55 * shapr grumbles at code
13:49:03 <gdoteof> i cabal-dev installed the updated module
13:49:06 * jonaskoelker grumbles in code
13:49:08 <byorgey> frigga: oh, a derived Enum instance, I see.   I don't actually know how those work.
13:49:10 <mcstar> anyway, whats with these hebrew sounding names?
13:49:18 <gdoteof> but in my webapp directory; that code isn't being brought in
13:49:20 <gdoteof> and i am not sure how to
13:49:28 <frigga> byorgey: Ahh, bumme. :(
13:49:31 <gdoteof> i have been running with `yesod --dev devel`
13:49:31 <frigga> bummer
13:49:34 <shapr> gdoteof: I thought cabal-dev was for isolated experiments?
13:49:48 <shapr> gdoteof: Have you tried using "cabal install" in an updated source repo?
13:49:56 <jonaskoelker> frigga: a daring soul might venture into the deep caverns of ghc :)
13:49:57 <shapr> jonaskoelker: What code are you grumbling?
13:50:04 <gdoteof> and building executables with `cabal-dev configure && cabal-dev build`
13:50:16 <kb_oe> an interesting online comic book http://kh43.com
13:50:17 <gdoteof> shapr: i haven't tried.  i think you are right that it is for isolated environments
13:50:22 <jonaskoelker> dice rolling
13:50:29 <gdoteof> i guess what i want to do is bring that module into the isolated environment
13:50:30 <jonaskoelker> finite probability distribution sampling and calculation
13:50:37 <jonaskoelker> expression parsing and tree walking
13:50:37 <shapr> I'm glad kb_oe got killed for spamming.
13:51:04 <shapr> Sounds like fun.
13:51:06 <gdoteof> shapr: but, there are no .hs files in my cabal-dev directory in my yesod app
13:51:15 <jonaskoelker> it is.  Doesn't pay any, tho' ;-)
13:51:17 <shapr> gdoteof: I just started using cabal-dev, I don't know.
13:51:29 <shapr> jonaskoelker: I'm having fun and getting paid too!
13:51:41 <jonaskoelker> lucky bastard!  Paid for writing haskell?
13:51:53 <shapr> Yah, I'm doing a GSoC project!
13:51:59 <jonaskoelker> w00t w00t
13:52:02 <frigga> jonaskoelker: Yeah, I thought I'd check in here first, before venturing into the caverns.
13:52:28 <jonaskoelker> frigga: good call :)  Maybe the less cavernous hs98 or other std docs specify The One Correct Answer
13:52:28 <Jaxan> someone succesfully built lambdabot with ghc 7.4? I get an error: http://hpaste.org/68855
13:52:32 <andares> hey, if I have f :: m (a -> b), \a -> f a should be type a -> m b right?
13:52:49 <Botje> no
13:52:57 <jonaskoelker> snd'ed
13:53:06 <gdoteof> ah.  cabal-dev /path/to/the/module
13:53:08 <gdoteof> within my yesod app
13:53:12 <monochrom> "f a" is ill-typed
13:53:20 <andares> ill-typed?
13:53:30 <jonaskoelker> doesn't type check
13:53:34 <monochrom> a nice way to say "type error"
13:53:35 <Botje> andares: the only way to produce something that contains b is f >>= \g -> return g a
13:53:41 <Botje> return (g a) even
13:54:23 <andares> but if f is a functor, there should be an isomorphism between a -> b and m a -> m b, right?
13:54:42 <jonaskoelker> @pl (\a -> ?f >>= \g -> return $ g a)
13:54:43 <lambdabot> (line 1, column 8):
13:54:43 <lambdabot> unexpected "?"
13:54:43 <lambdabot> expecting lambda abstraction or expression
13:54:47 <jonaskoelker> @pl (\a -> f >>= \g -> return $ g a)
13:54:48 <lambdabot> (`fmap` f) . flip id
13:55:16 <shapr>  frigga: Have you already ventured into the depths of #ghc and asked there?
13:56:01 <frigga> shapr: Not yet
13:56:20 <jonaskoelker> what would you guys estimate the market shares of the various haskell compilers(/systems) are?
13:56:37 <shapr> Probably more than $38 a share.
13:56:45 <Botje> shapr: $33 by now.
13:56:52 <shapr> Oh right...
13:57:04 <Botje> make that 31 :)
13:57:09 <frigga> jonaskoelker: 100 - ghc_market_share = epsilon
13:57:12 <xemdetia> Is there any good documentation or examples on the newer try syntax? I can't seem to figure out how to make the exceptions not ambigious.
13:57:13 <jonaskoelker> > init "shares"
13:57:14 <lambdabot>   "share"
13:57:17 <shapr> jonaskoelker: Most people use ghc, a few people use others for particular purposes.
13:57:38 <hpaste> “Jonathan Fischoff” pasted “berekley db error” at http://hpaste.org/68857
13:57:39 <jonaskoelker> frigga: my sense as well
13:57:59 <jonaskoelker> whadda ya know, a sepelling error :P
13:58:12 <shapr> jonaskoelker: UHC and YHC can do neat tricks, and hugs can run on a cellphone. Those are the special purpose usages I've seen.
13:58:45 <jonaskoelker> yeah... I've been thinking about running my .hs stuff on my smartphwn
13:59:06 <shapr> Isn't GHC registerized for ARM now?
13:59:14 <jonaskoelker> dunno
13:59:33 <jonaskoelker> is ghc up for building windows apps?
14:00:23 <shapr> I don't know.
14:00:37 <dmwit> andares: Definitely not.
14:01:00 <dmwit> andares: There's an embedding (a -> b) -> (f a -> f b), but not necessarily a projection (f a -> f b) -> (a -> b).
14:01:02 <rwbarton> not even if m is a functor
14:01:23 <dmwit> andares: And none of those types are even the one you have, namely f (a -> b).
14:01:27 <andares> huh.
14:01:59 <jonaskoelker> oh, hi dmwit.  Remember suggesting that I monadified my dice-rolling code?  That cut 140 lines down to 99 simpler lines
14:02:04 <solidus-river> if i call a pure function from an IO block is it still restricted to being performed before the next request in the IO block is executed?
14:02:09 <dmwit> jonaskoelker: \o/
14:02:22 <monochrom> not restricted
14:02:44 <hpaste> gdoteof pasted “cabal-dev is teasing me” at http://hpaste.org/68858
14:02:49 <jonaskoelker> apparently no ghc or hugs for Maemo :|
14:02:52 <monochrom> do { return (head []); putStrLn "hi" }  is not an error
14:03:11 <solidus-river> cool so it defers the execution like normal pure code
14:03:46 <Peaker> solidus-river, IO actions being executed will force evaluation of the pure code that they need to execute
14:03:48 <c_wraith> it is normal pure code
14:03:50 <monochrom> putStrLn (head []) bombs but that's because putStrLn wants the answer immediately
14:04:21 * shapr boings cheerfully
14:04:24 <shapr> yay code is working!
14:04:35 <jonaskoelker> congratulations! :)
14:05:21 <solidus-river> cool, also, haskell is a great tool for making programmers think more mathmatically about their programs. Taking a theory of computation course this quarter and my midterm before i started learn you a haskell vs my midterm today were drastically different experiences
14:05:32 <dmwit> jonaskoelker: So what does your code look like now?
14:07:33 <shapr> solidus-river: I wish my uni taught Haskell!
14:07:46 <jonaskoelker> is there a command-line interface for hpaste.org?
14:07:52 <tac_> shapr: Then you couldn't be all Hipster about it.
14:08:08 <edwardk> wget ? =)
14:08:16 <shapr> tac_: You have a point.
14:08:23 <edwardk> shapr is the original #haskell hipster. he was in #haskell before there was #haskell
14:08:30 * shapr laughs
14:08:53 <shapr> I'd still like to get paid lots of money to write Haskell... other people certainly got to that part before I did !
14:09:06 <hiptobecubic> shapr, that would be a neat trick, yea
14:09:07 <shachaf> shapr certainly shapd #haskell
14:09:14 <edwardk> well, i seem to recall you not having the best time last time you were a paid haskeller =P
14:09:21 <luite> shapr: at least you get some now :)
14:09:32 <jonaskoelker> edwardk: ^_^
14:09:32 <xemdetia> Is using ScopedTypeVariables something that is considered sane, or should I be working to get around using this.
14:09:33 <luite> better than me :p
14:09:36 <shapr> edwardk: That's true, I am certainly attempting to improve.
14:09:38 <solidus-river> shapr things the the next haskell conference was alright but really sold out compared to the last haskell con
14:09:45 <solidus-river> s/things/thinks
14:10:00 <shapr> solidus-river: I wasn't able to go to the most recent one! :-(
14:10:09 <shapr> solidus-river: Have you been to one of the ICFPs?
14:10:25 <Saizan> xemdetia: fairly sane
14:10:40 <hpaste> jonaskoelker pasted “sample.hs (dice rolling)” at http://hpaste.org/68860
14:11:31 <hiptobecubic> edwardk, oh. I settled on a thesis topic. It isn't as fun as I'd hoped, but I might still be able to pull something interesting out of it programming wise.
14:11:58 <solidus-river> shapr: nope, just learning it, still going through learn you a haskell, plan is to do that then read up on functional reactive programming then go build something
14:12:01 <dmwit> xemdetia: ScopedTypeVariables is fairly benign.
14:12:01 <jonaskoelker> dmwit: I still do a little bit of manual lifting, but now the names are longer :)
14:12:19 <edwardk> so what topic will we be turning to you to dispense wisdom about in the future?
14:12:22 <shapr> solidus-river: Good plan! I want to know how FRP works too!
14:12:28 <dmwit> jonaskoelker: =D
14:12:50 <xemdetia> Thanks guys
14:12:57 <shapr> hiptobecubic: I like reading thesi(?) What will yours be about?
14:13:02 <c_wraith> ScopedTypeVariables doesn't let you do anything new..  It just makes it easier to express it.
14:13:07 <hiptobecubic> pricing exotic FX derivatives using pde discretizations / finite differencing on gpus.
14:13:19 <dmwit> jonaskoelker: Well, eval got worse, but dang, sample got so much better!
14:13:22 <edwardk> sounds like fun
14:13:34 <jonaskoelker> eval?
14:13:38 <edwardk> you should use automatic differentiation instead ;)
14:13:39 <jonaskoelker> oh
14:13:41 <jonaskoelker> :)
14:13:57 <sipa> shapr: theses?
14:14:03 <dmwit> jonaskoelker: Though I'm a bit surprised that sample isn't obviously recursive...
14:14:07 <Peaker> ScopedTypeVariables should probably have been the default, and maybe even without requiring "forall"
14:14:27 <hiptobecubic> edwardk, it's a pretty open topic. The bank has set the constraint that it it 'must be fast' and that's largely it.
14:14:28 <Peaker> 2 newbies I've helped already were very surprised that was not the default behavior
14:14:33 <dmwit> jonaskoelker: e.g. I'm surprised that you don't have something like sample (Add x y) = liftScalars (+) (sample x) (sample y)
14:14:46 <jonaskoelker> did I mention this to you, dmwit---I was thinking about definition a generic monadic semantic-exppression-tree-traversal, then expressing my two modules (Sample, Statistics) as basically a short and simple monad
14:14:54 <edwardk> hiptobecubic: i was just meaning with regards to bypassing finite differencing wherever possible
14:15:15 <schlicht> when i'm trying to build gtk i get "Only <glib.h> can be included directly.", does anyone know how to fix this?
14:15:25 <dmwit> jonaskoelker: sounds fun
14:15:35 <jonaskoelker> dmwit: see liftList2List and liftLists
14:15:36 <dmwit> schlicht: Pull from darcs. I'll be making a release in the next few days, hopefully, to fix this.
14:15:41 <jonaskoelker> they're basically that
14:15:56 <dmwit> jonaskoelker: aaaah
14:16:12 <dmwit> Yep, "scalars" was the function I hadn't read.
14:16:16 <schlicht> dmwit, nice :) thanks. gtk or glib or both?
14:16:25 <shapr> sipa: Oh, that is a better word.
14:16:35 <hiptobecubic> edwardk, i'm wondering if Accelerate will be competitive enough to justify building something in haskell for show and tell
14:16:36 <dmwit> schlicht: The gtk2hs repository includes gtk, glib, cairo, pango, and something else.
14:16:51 <schlicht> alright :)
14:16:56 <jonaskoelker> squishy types are fun =)
14:16:59 * jonaskoelker sighs
14:17:01 <hpc> dmwit: -buildtools, i think
14:17:08 <dmwit> that sounds right
14:17:09 <edwardk> hiptobecubic: probably not. lots of fiddly operations, probably makes more sense to generate the kernel yourself
14:17:16 <hpaste> xemdetia pasted “seek exception handling” at http://hpaste.org/68861
14:17:30 <dmwit> gio was what I was thinking of, though.
14:17:39 <xemdetia> Is there any way to do what I just pasted nicer?
14:18:08 <dmwit> xemdetia: That looks like buggy code to me.
14:18:40 <c_wraith> that has several problems.
14:18:42 <dmwit> Perhaps you meant something like ... `E.catch` (\e -> if isIllegalOperationError e then putStrLn "cannot seek" else ???)
14:19:06 <dmwit> Perhaps rethrowing the exception in the else clause.
14:19:09 <Peaker> xemdetia, that doesn't build, does it?
14:19:16 <xemdetia> Peaker: it does
14:19:20 <dmwit> It builds, probably, but doesn't do what he probably thinks it does. =)
14:19:27 <hiptobecubic> edwardk, do you have to work with gpu programming in what you do? I'd imagine so, no?
14:19:27 <Peaker> oh, right, you've just pattern-matched it against _
14:19:46 <edwardk> hiptobecubic: not here, but i do some gpu coding off and on
14:19:59 <xemdetia> I was having a hard time trying to figure out how to handle the exception at all, let alone properly which is why I am asking for opinions
14:20:03 <Peaker> xemdetia, "case" pattern-matches against data constructors or a wild-card. Lower-case is a wild-card
14:20:03 <dmwit> xemdetia: Try adding -fwarn-name-shadowing when you compile to see what I mean by "doesn't do what you think it does".
14:20:31 <Peaker> I'd recommend  -Wall -Werror
14:20:37 <dmwit> ?hoogle isIllegalOperationError
14:20:38 <lambdabot> System.IO.Error isIllegalOperationErrorType :: IOErrorType -> Bool
14:20:59 <dmwit> ?hoogle catch
14:20:59 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
14:21:00 <lambdabot> System.IO.Error catch :: IO a -> (IOError -> IO a) -> IO a
14:21:00 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
14:21:06 <xemdetia> I don't actually get any feedback from -Wall and -Werror
14:21:22 <rwbarton> probably because you didn't import System.IO.Error
14:21:24 <dmwit> xemdetia: import System.IO.Error
14:21:43 <monochrom> "case x of Just x -> ... x ..." the 2nd and 3rd x's are the same. different from the 1st x
14:22:12 <xemdetia> dmwit: that makes a redundant import when I add that import
14:22:16 <dmwit> more to the point, "foo = bar; case x of foo -> baz", the first and second foo's are different
14:23:08 <dmwit> Oh, man, you didn't even name the thing properly.
14:23:35 <dmwit> The real one is isIllegalOperationErrorType, no?
14:23:45 <dmwit> Anyway, this is all beside the point.
14:23:50 <dmwit> Have you seen the point or should we say it again?
14:24:01 <dmwit> (presumably in different words =)
14:24:17 <Peaker> xemdetia, case x of lowerCaseHere ->  ...   is equivalent to:   let lowerCaseHere = x in ...
14:24:29 * monochrom volunteers to use Chinese
14:24:33 <xemdetia> I understand the point Peaker made about it being accidently a wildcard.
14:24:39 <jonaskoelker> f = do { putStrLn "the first explanation"; f } --  :-)
14:24:41 <dmwit> okay =)
14:24:46 <Peaker> I think maybe a "case-of-wildcard" should also warn with -Wall
14:25:06 <Peaker> there are no legitimate uses of that that I can think of, except for generated code, which can take the extra effort to avoid it too
14:25:10 <c_wraith> well, it will warn that it's an unused name, at least.
14:25:22 <c_wraith> (in this case)
14:27:41 <DMcGill> will it not warn about shadowing?
14:28:13 <c_wraith> it will warn about that too, yeah
14:28:22 <serialhex> does anyone in here know about interfacing with MS COM stuff???
14:28:56 <xemdetia> I was having such difficulty trying to figure out how to give some type information to the exception handler stuff I guess I wasn't focused as much on the logic.
14:29:04 * hackagebot wsedit 0.1.0.0 - A small tool to list, add and remove webseeds from a torrent file  http://hackage.haskell.org/package/wsedit-0.1.0.0 (LinusLuessing)
14:29:51 <c_wraith> xemdetia: just using the function isIllegalOperationType gives it information about the error type
14:31:04 <xemdetia> c_wraith: I didn't find information about that function until just now by looking at the documentation. All it mentioned was the errors.
14:35:58 <navaati> the Num type class is (pretty much) equivalent to a ring in mathematics, right ?
14:36:54 <c_wraith> not completely
14:36:57 <c_wraith> :t signum
14:36:59 <lambdabot> forall a. (Num a) => a -> a
14:37:05 <c_wraith> :t fromInteger
14:37:06 <lambdabot> forall a. (Num a) => Integer -> a
14:37:14 <c_wraith> Those aren't things in a ring. :)
14:37:27 <shachaf> navaati: Nope.
14:37:43 <shachaf> Num is (pretty much) equivalent to nonsense.
14:38:22 <monochrom> it's close to ring. some kind of valuation ring actually because of abs
14:38:30 <navaati> c_wraith: yeah, by "pretty much" i was thinking about "without fromInteger" (i forgot about signum, tho)
14:39:09 <navaati> of course i'm talking about Num in GHC 7.4.1, that is without Eq and Show :)
14:39:30 <shachaf> They took out Eq *and* Show?
14:39:53 <dmwit> yes
14:39:56 <dmwit> Thank goodness.
14:39:56 <monochrom> fromInteger actually helps ringness. homomorphism Z -> YourRing
14:41:03 <monochrom> it was controversial for a while on glaswgow-haskell-users. some people cried "treason! this is not standard!"
14:41:03 <shachaf> I don't think Num has any laws.
14:41:12 <shachaf> If it does, Double probably doesn't obey them.
14:41:36 <monochrom> SPJ replies that from what he heard in the libraries mailing list, this is the new standard
14:41:52 <c_wraith> well, it is now.
14:42:18 <navaati> shachaf: because of floating point arithmetic funkyness ?
14:42:31 <ggs1729> Can someone tell me what <+> does?
14:42:40 <sipa> : (<+>)
14:42:43 <shachaf> @ty (<+>)
14:42:44 <lambdabot>     Ambiguous occurrence `<+>'
14:42:44 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at State/L.hs:5:0-19
14:42:44 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<+>', imported from Text.PrettyPrint.HughesPJ at State/L.hs:53:0-46
14:42:45 <sipa> :t (<+>)
14:42:46 <lambdabot>     Ambiguous occurrence `<+>'
14:42:46 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at State/L.hs:5:0-19
14:42:46 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<+>', imported from Text.PrettyPrint.HughesPJ at State/L.hs:53:0-46
14:42:55 <sipa> :t (Control.Arrow.<+>)
14:42:56 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowPlus a) => a b c -> a b c -> a b c
14:43:02 <monochrom> that depends on whose <+>
14:43:13 <shachaf> navaati: I don't know what sort of algebraic structure floating-point numbers are an example of, but I want nothing to do with it.
14:43:37 <monochrom> floating-point is better left as its own algebraic structure :)
14:43:46 <ggs1729> ok, thanks
14:44:07 <shachaf> @src Floating
14:44:07 <lambdabot> class  (Fractional a) => Floating a  where
14:44:08 <lambdabot>     pi                                                      :: a
14:44:10 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
14:44:12 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
14:44:14 <lambdabot>     (**), logBase                                           :: a -> a -> a
14:44:18 <shachaf> Laws: None
14:44:21 * shachaf shudders.
14:44:23 <navaati> oh, btw, Int, Word and friends are actually modular arithmetics, right ?
14:44:29 <shachaf> navaati: No, they're undefined.
14:44:34 <shachaf> Overflow is, that is.
14:44:36 <shachaf> At least for Int.
14:44:39 <c_wraith> well, the fixed-size ones are modular
14:44:40 <ggs1729> what's the best way to answer thase sorts of questions myself? e.g. how do I get info about Control.Arrow.<+>?
14:44:51 <shachaf> ggs1729: :i in ghci
14:45:04 <shachaf> (Or :t in ghci to get the type of an expression.)
14:45:30 <ggs1729> thx shachaf
14:45:43 <navaati> (ah, yeah, Int is not fixed size… *sigh* why, haskell people, have you done the same horrible thing that C people, WHY ?)
14:45:57 <shachaf> What *is* Int?
14:46:00 <shachaf> We just don't know.
14:46:18 <sipa> Int is a signed integer of at least 32 bits, no?
14:46:32 <dmwit> sipa: no
14:46:41 <dmwit> I think you're guaranteed 28 or 29 bits.
14:46:45 <shachaf> Sinteger.
14:47:50 <sipa> The finite-precision integer type Int covers at least the range [ - 229, 229 - 1]
14:48:14 <sipa> So you're guaranteed a 30-bit signed integer
14:48:16 <dmwit> oh, bleh
14:48:29 <dmwit> Is there a version of replicateM_ that won't stack overflow on replicateM_ 40000?
14:48:37 * monochrom giggles at 229
14:49:05 <Peaker> dmwit, for strict monads, you need to implement your own "sequence" and "sequence_" with the reverse trick
14:49:31 <monochrom> eh? replicateM_ is not supposed to be a cause of stack-overflow
14:49:33 <hiptobecubic> dmwit, can you do it lazily? I needed to replicateM_ to make an infinite list of random variates a few weeks ago
14:49:56 <dmwit> Perhaps it's not replicateM_'s fault, then.
14:50:17 <dmwit> Yes, it was my fault.
14:50:19 <monochrom> ok, "random" is a typical cause of overflow
14:50:25 <dmwit> I didn't rebuild after adding my strictness annotation.
14:50:44 <Peaker> oh wait, sequence_ is not a problem, only sequence, oops
14:52:15 <armlesshobo> is it really possible to have a list of actions?
14:52:23 <Peaker> armlesshobo, sure
14:52:27 <armlesshobo> :O
14:52:34 <Peaker> armlesshobo, [putStrLn "Hello", print "Hi!"]
14:52:36 <armlesshobo> that's incredible lol
14:53:01 <navaati> no, that's haskell FTW
14:53:06 <armlesshobo> lol
14:53:14 <fmap> > sequence [Just 1, Just 2, Just 3]
14:53:15 <lambdabot>   Just [1,2,3]
14:53:41 <armlesshobo> and a list of partial functions! lol
14:53:56 <DMcGill> note that simply having a list of actions doesn't execute, you use sequence for that
14:57:57 <armlesshobo> DMcGill: right, or you could do "do head(as)" or things of that sort
14:57:58 <schlicht> are there more than a rare few jobs where one uses hakell out there?
15:00:49 <hiptobecubic> sure
15:01:51 <navaati> unrelated math question : does exist an injection from R² to R ?
15:02:12 <shachaf> Yes.
15:02:19 <tac_> navaati: not a continuous one, but yeah, sure
15:02:23 <c_wraith> Is it computable?
15:02:42 <DMcGill> R isn't computable
15:02:44 <c_wraith> I guess not, by definition
15:03:06 <shachaf> "computable, adj.: not an injection form R² to R"
15:03:21 <c_wraith> By definition of R, not the whole thing. :P
15:03:25 <tac_> shachaf: That requires functional extensionality to prove.
15:04:21 <mgsloan> hey, maybe now that we have type-level naturals, maybe we can get n-bit primitives or specify integers with compile-time modulus
15:04:25 <DMcGill> it may well be possible to get a good approx to the function with floating point numbers however
15:04:36 <markus3> hi guys, is it possible to get a type operator to compose monads? I have "type (a :: (* -> *) -> *) :> (b :: * -> *) = a b" and "infixr :>", but it doesn't work... "zzz :: StateT Int :> IO" gives me "Expecting one more argument to `StateT Int'" ...
15:04:38 <DMcGill> Z to Z is easy for example
15:04:53 <navaati> that means that R² is isomorphic to R ? duh…
15:05:58 <ski> navaati : you could ask in #constructive-math ..
15:06:09 <tac_> R and R^2 have the same cardinality. There's a bijection somewhere between them
15:06:24 <markus3> I know that type aliases must be applied fully, but I think I have done that
15:06:26 <tac_> oh, are we talkking constructive?
15:06:32 <mgsloan> > showCReal 20 $ log pi
15:06:33 <lambdabot>   "1.14472988584940017414"
15:10:46 <navaati> markus3: zzz is a value ? it can't be, because "StateT Int :> IO" is of kind * → *, which is the kind of a type constructor, not of a type, and values belong to types
15:14:05 <markus3> navaati: I need to digest that for awhile :-)
15:14:06 <ski> markus3 : `StateT Int' has kind `(* -> *) -> (* -> *)', not kind `(* -> *) -> *'
15:14:08 * hackagebot cryptocipher 0.3.4 - Symmetrical Block, Stream and PubKey Ciphers  http://hackage.haskell.org/package/cryptocipher-0.3.4 (VincentHanquez)
15:14:12 <markus3> yes
15:14:21 <markus3> I found out just now
15:14:46 <navaati> ah, i was wrong then…
15:14:52 <ski> @kind StateT Int
15:14:52 <markus3> anyway, this kind of operator seems to be possible?
15:14:52 <lambdabot> (* -> *) -> * -> *
15:15:08 <markus3> the type is now "type (a :: (* -> *) -> * -> *) :> (b :: * -> *) = a b"
15:15:21 <markus3> this should be correct?
15:15:37 <hpaste> xemdetia pasted “seek exception handling revisions” at http://hpaste.org/68863
15:15:45 <ski> depends on what you want to do
15:16:04 <xemdetia> Going back to my earlier drivel, did I accomplish what I set out to do correctly this time (based on the new paste)?
15:16:05 <markus3> so I can have "type Stack s r w = StateT s :> ReaderT r :> WriterT w :> IO"
15:16:16 <markus3> .. and others like that
15:16:29 <gurrag> "The following packages are likely to be broken by the reinstalls:" <list of a good deal of cabal's packages including ghc>  How do I mitigate this?  I'm trying to install the `nehe-tuts' package for learning the Haskell OpenGL bindings
15:16:43 <markus3> I just wanted to have a nicer operator for composing monad-types
15:16:44 <ski> markus3 : should work, i think
15:17:03 <geekosaur> gurrag, that suggests to me that nehe-tuts doesn't work with your compiler version.
15:17:09 <ski> @hoogle RWS
15:17:09 <lambdabot> Control.Monad.RWS module Control.Monad.RWS
15:17:09 <lambdabot> Control.Monad.Trans.RWS module Control.Monad.Trans.RWS
15:17:10 <lambdabot> Control.Monad.Trans.RWS.Lazy type RWS r w s = RWST r w s Identity
15:17:51 <DMcGill> gurrag: it doesn't succesfully answer your question but I used the beautiful code examples to learn the syntax: http://www.renci.org/wp-content/pub/tutorials/BeautifulCode.pdf
15:18:09 <markus3> yup, I know of that, but say I want to compose any kind of stacks, not just RWS
15:18:30 <DMcGill> and then basically did the tutorials from http://www.videotutorialsrock.com/, translating them from C into Haskell
15:18:42 <DMcGill> (and that's the story of how I learn hopengl)
15:18:47 <DMcGill> learnt*
15:19:08 <markus3> ski: I wonder if somethink like this operator exists somewhere. this keeps me clear of many parenthesis
15:19:10 * ski would just write `StateT s (ReaderT r (WriterT w IO))' .. ymmv
15:23:14 <lpvb> hey, what JVM functional language would be most similar to haskell?
15:23:36 <lpvb> Is Scala more like haskell than clojure?
15:23:46 <tac_> Neither are like haskell
15:23:56 <tac_> Both are side-effectful and strictly evaluated
15:23:57 <hiptobecubic> lpvb, if you force yourself not to use the imperative features, maybe scala? I'm not sure though
15:24:20 <tac_> the JVM isn't well-suited for a Haskell-like language
15:24:26 <tac_> Not to say it can't be done.
15:24:30 <c_wraith> Scala's a bit closer, due to having a static typing system.
15:24:39 <c_wraith> But..  It's pretty different.
15:25:21 <lpvb> okay ty
15:25:28 <geekosaur> there's Frege
15:25:47 <hiptobecubic> isn't there jhc or something like that?
15:25:47 <geekosaur> closer in terms of synax, but IIRC it's strict instead of lazy
15:26:02 <tac_> geekosaur: ah yeah. It says it's non-strict though
15:26:08 <tac_> http://code.google.com/p/frege/
15:28:55 <lpvb> interesting...
15:32:19 <lpvb> tac_, are there any downsides to frege?
15:32:26 <tac_> I've never used it.
15:32:38 <tac_> My guess would be the downsides are similar to any other small-ish project
15:32:55 <tac_> It's not used by the 10,000 people GHC is used by, so it's more likely to have bugs and has a much smaller community for support
15:33:50 <Gurrag> I'm still getting package installation failure from cabal with "<pkg name> depends on deepseq-1.3.0.0 which failed to install."
15:35:26 <tgeeky> Gurrag: ghc-pkg list | grep deepseq
15:35:29 <tgeeky> Gurrag: results?
15:36:10 <Gurrag> tgeeky: 2 identical entries of "deepseq-1.3.0.0"
15:36:55 <lpvb> tough decisions.. I guess I'll use clojure
15:38:01 <tac_> lpvb: what kind of an application are you writing?
15:38:18 <tgeeky> Gurrag: you must have a --global and a --user installation
15:38:31 <tgeeky> Gurrag: check out the results of ghc-pkg list
15:38:54 <tgeeky> if that is the case (you have a user and global install) someone else here might be able to tell you what to do
15:39:04 <Gurrag> I'd rather just nuke the whole thing and start over if possible
15:39:13 <tgeeky> Gurrag: do ghc-pkg check
15:39:16 <Gurrag> I'm guessing I made an error somewhere along the line in installing haskell
15:39:18 <tgeeky> Gurrag: does it report errros?
15:39:26 <Gurrag> yes, a ton
15:39:34 <tgeeky> Gurrag: yep. nuke and retry
15:39:35 <Gurrag> all regarding haddock
15:39:40 <tgeeky> oh that's fine
15:39:49 <tgeeky> that's just saying that you're not installing documentation
15:40:04 <Gurrag> I'll still nuke and retry
15:40:19 <Gurrag> I don't have any projects or anything set up so it won't hurt
15:40:23 <tgeeky> Gurrag: edit your uhh .cabal file or whatever it is
15:40:30 <tgeeky> and turn documentation on
15:40:37 <irene-knapp> ~/.cabal/config
15:40:41 <tgeeky> so those ghc-pkg check errors will go away (and you'll have docs!)
15:42:04 <lpvb> tac_, nothing specific; I mainly want to target a VM so my code can be called by Java or C# programmers and vice-versa. I wish frege had as much traction as Clojure, F#, or Scala...
15:42:42 <Gurrag> I am getting a certain error still regarding deepseq: "Data.Array can't be safely imported!"
15:44:19 <Gurrag> what's the best way to nuke cabal / haskell-platform and start from square one?
15:45:08 <Peaker> Gurrag, typically the haskell-platform is installed globally and your local .cabal is the one you want to nuke only?
15:45:30 <Gurrag> it's a personal computer so I'm the only user
15:45:40 <Peaker> Gurrag, yes, but there's still this separation
15:45:47 <Peaker> Gurrag, what does ghc-pkg list say? can you paste that?
15:45:50 <Gurrag> okay
15:46:52 <xemdetia> I am probably not the one you should be listening too Gurrag but what I did is compile ghc using the --user setup to a local folder and then install cabal from scratch based on that operation.
15:47:08 <hpaste> gurrag pasted “ghcpkg list gurrag” at http://hpaste.org/68864
15:47:14 <xemdetia> It wasn't that terrible in the end of things, but it did destroy my ~/.cabal by default because I was lazy
15:54:37 <d-snp> hey
15:55:13 <d-snp> would you say state machines are difficult/unhandy to implement in haskell? know any good paper/article on this?
15:55:37 <tac_> d-snp: state machines should be easy enough, I think
15:55:53 <tac_> d-snp: They would be something similar to state monads
15:57:51 <favonia> d-snp: no. states are just explicit in Haskell. :)
16:00:37 <d-snp> hmm as in you would pass them as function parameters right?
16:01:46 <Peaker> d-snp, a state machine would be a:  handleEvent :: Event -> State -> State  function  and applying it would be easy:  foldr (.) id $ map handleEvent events
16:11:54 <favonia> Peaker: hmm I thought it will begin with 'foldl'? I feel the head of events comes earlier.
16:17:59 <Peaker> favonia, foldl/foldr differ in how the () group, it wouldn't make a difference here
16:18:14 <Peaker> (except foldr is better when the binop given is lazy)
16:18:37 <Peaker> > foldl (.) id [('x':), ('y':), ('z':)] "Hi"
16:18:39 <lambdabot>   "xyzHi"
16:18:41 <Peaker> > foldr (.) id [('x':), ('y':), ('z':)] "Hi"
16:18:43 <lambdabot>   "xyzHi"
16:19:19 <Peaker> foldl (*) z   makes for:   (((((z * a) * b) * c) * d) ...)
16:19:34 <favonia> Peaker: oh yes, I was confused
16:19:50 <Peaker> foldr (*) z   makes for:   (a * (b * (c * (d * ... * z)))))
16:20:31 <favonia> Peaker: oh I guess I just missed the associativity of (.) :P
16:23:30 <favonia> Peaker: thanks. :)
16:23:40 <Peaker> no problem :)
16:25:45 <favonia> Peaker: ah, no, sorry, I need to take my words back. Yes (.) has associativity, but my point is that perhaps "('x':)" should happen first
16:26:20 <favonia> Peaker: so it would be foldl (flip handleEvent) ...
16:26:31 <Peaker> but note that the order of applications in foldr and foldl does not change in my above lambdabot example
16:29:58 <favonia> Peaker: you are right that it doesn't change the order... but I want the other order so that the head of events comes first. well I guess it's just a different taste.
16:30:27 <Peaker> favonia, ah, I see, so you want foldr (flip (.)) id then, or reverse the list
16:30:51 <DMcGill> could always use foldr (flip handleEvent) (nothing) (reverse events)
16:31:51 <favonia> Peaker: yes, something like that. anyway, Haskell is expressive enough to express all variations concisely
16:31:55 <Peaker> flip handleEvent is not useful here
16:32:12 <Peaker> it's (.) which is useful to flip
16:33:13 <favonia> Peaker: hmm I can just skip the composition. i.e. you don't need to use pointless style
16:34:01 <favonia> foldl (flip handleEvent) startingState events
16:34:28 <Peaker> ah, ok
16:36:38 <favonia> Peaker: perhaps I was thinking of monadic version so that you can jump to 'foldM (blah blah blah) startingState events' right away
16:37:17 <Peaker> favonia, you could   foldr (>=>) return    just as easily
16:37:45 <favonia> Peaker: hmm ok :P
16:38:15 <Peaker> @type foldr (>=>) id
16:38:16 <lambdabot> forall (m :: * -> *) c. (Monad m) => [m c -> m (m c)] -> m c -> m c
16:38:23 <Peaker> oops
16:38:56 <Peaker> @type foldr (>=>) return
16:38:57 <lambdabot> forall (m :: * -> *) c. (Monad m) => [c -> m c] -> c -> m c
16:40:46 <favonia> Peaker: I think I am just trying to avoid 'reverse'...
16:41:11 <Peaker> @type foldr (<=<) return
16:41:12 <lambdabot> forall (m :: * -> *) c. (Monad m) => [c -> m c] -> c -> m c
16:41:47 <Peaker> favonia, given (<=<) and (>=>) both are possible, you can avoid reverse like this too..  though your approach is great.. It makes a "scanl" easily possible, and that's nice
16:47:48 <favonia> Peaker: I see your point. oh I haven't thought of 'scanl'... yes 'foldl' and 'scanl' are like brothers and sisters. :P thanks.
17:00:00 <tgeeky> scannung us the traced version of folding
17:00:03 <tgeeky> scanning*
17:07:07 <xemdetia> What is the Haskell best practice for dealing with something like an IO Bool? I know unsafePerformIO exists, but the operation I am examining (hIsSeekable) definitely doesn't have any side effects. So is the 100% correct way to use a binding of some type or am I missing something.
17:08:02 <ezyang> hIsSeekable is not referentially transparent.
17:08:30 <ezyang> its value can change dependingo n time
17:08:32 <ezyang> *on time
17:09:20 <xemdetia> Well I am not talking about it in such an abstract sense as just trying to slot it in something like an if statment or some other control flow
17:09:31 <xemdetia> *statement
17:09:34 <Nimatek> xemdetia: Use it inside IO.
17:10:41 <ski>   do my_Bool <- my_IO_Bool
17:10:46 <gurrag> How can I reset `cabal' to its initial setup under Xubuntu?
17:10:46 <ski>      if my_Bool
17:10:51 <ski>        then do
17:10:56 <ski>          ...
17:10:59 <ski>        else do
17:11:02 * gurrag trying to nuke a broken Cabal installation
17:11:02 <ski>          ...
17:11:26 <xemdetia> ski: so that is the best way to do it? Again I know this as an option but I was wondering if there was a better way of going about it
17:11:28 <ski> or use `when' or `unless', if one of the branches is just a `return ()'
17:11:36 <geekosaur> gurrag, rm -r ~/.ghc
17:12:02 <gurrag> can someone corroborate that? it sounds risky
17:12:06 <gurrag> "rm -r"
17:13:13 <gurrag> doing it anyway
17:13:48 <geekosaur> don't typo, of coutse.  or "mv" if you want to be safe
17:14:01 <gurrag> thanks, it seems to have helped so far
17:14:10 <geekosaur> but ~/.ghc is safe to blow away, aside from having to reinstall local cabal-installed libraries
17:14:26 <gurrag> i'm trying to get the OpenGL package to install through cabal, hopefully it won't keep hanging up on deepseq having issues
17:15:20 <ski> @type \h -> (System.IO.hIsSeekable h >>=) . flip when $ do putStrLn "yes"
17:15:21 <lambdabot> GHC.IO.Handle.Types.Handle -> IO ()
17:15:37 <ski> xemdetia : not sure how ugly that ^ is
17:17:59 <favonia> gurrag: next time if you know the offending packages and there are only a few, perhaps you can try ghc-pkg unregister
17:18:17 <gurrag> thanks for the tip
17:18:42 <xemdetia> ski: It definitely is interesting! I am not sure how much better that leaves me though. Either way thanks.
17:18:58 <favonia> gurrag: however if there are a lot I will just delete ~/.ghc lol
17:24:48 <jfischoff> are there alternatives to cabal-dev, or is it the way to go?
17:27:50 <gurrag> geekosaur and favonia, thanks for the help, after deleting ~/.ghc , the OpenGL package was successfully installed
17:28:53 <byorgey> jfischoff: there is virthualenv
17:29:05 <jfischoff> any difference?
17:29:09 <byorgey> yes
17:29:19 <byorgey> (don't ask me what the differences are)
17:29:28 <jfischoff> :)
17:29:32 <byorgey> http://hackage.haskell.org/package/virthualenv
17:29:42 <jfischoff> thanks
17:30:34 <jfischoff> has anyone used both cabal-dev and virtualenv and can compare them?
17:49:26 * hackagebot happstack-yui 7351.3.0 - Utilities for using YUI3 with Happstack.  http://hackage.haskell.org/package/happstack-yui-7351.3.0 (DagOdenhall)
18:26:01 <JoeyA> Whoops.
18:26:10 <irene-knapp> it's all your fault
18:28:20 <Ralith> you had better make up for it
18:29:06 <JoeyA> I'll contribute tests to postgresql-simple.  Would that be fine?
18:29:37 <irene-knapp> yes!
18:29:38 <irene-knapp> yes it would
18:30:10 <irene-knapp> also, if you would add an exported function that lets you provide a fromRow implementation without using a typeclass, that would be swell
18:30:28 <irene-knapp> it's necessary if you want to represent multiple different things in the same type, see
18:32:55 <JoeyA> irene-knapp: I'm not following.  I haven't used postgresql-simple yet, but I plan to move my code base to it at some point in the future.
18:33:08 <JoeyA> What's wrong with the Applicative interface?
18:33:16 <irene-knapp> oh, okay
18:33:40 <irene-knapp> nothing is wrong with it except that I wanted to define something along the lines of data Row = Row [Dynamic], right
18:34:09 <irene-knapp> and then use that to represent a row from several different tables
18:34:10 <irene-knapp> and I can't do that because I need to either pass in extra information to fromRow, or alternatively provide separate implementations of it
18:34:20 <irene-knapp> if Haskell had dependent types I'd be willing to go the other direction, but it doesn't, so.
18:35:05 <irene-knapp> since this was for work - last week in fact :) - and I was on a strict time budget, I wound up doing my own quick remake of postgresql-simple instead, which isn't as featureful
18:35:15 <irene-knapp> but having that functionality in the real thing would be great
18:36:14 <JoeyA> "I need to either pass in extra information to fromRow" What information, in particular?
18:36:39 <JoeyA> hmm
18:37:01 <JoeyA> You mean you want to query a table with a custom RowParser, rather than having to spin up an ad-hoc type for it?
18:37:15 <irene-knapp> yes
18:37:19 <JoeyA> And more crucially, the row parser uses data from run-time?
18:37:20 <irene-knapp> exactly
18:37:38 <irene-knapp> well, the data from run-time that it uses is just what type I'm using
18:37:51 <irene-knapp> but because the row parser is provided by the typeclass and there's no interface to pass  your own
18:37:55 <irene-knapp> (that I saw, at least)
18:38:18 <JoeyA> query :: (ToRow q, FromRow r) => Connection -> Query -> q -> IO [r]
18:39:00 <JoeyA> So what you want is something like this?  queryWith :: (q -> [Action]) -> RowParser r -> Connection -> Query -> q -> IO [r]
18:39:06 <irene-knapp> precisely so
18:44:47 <JoeyA> irene-knapp: Looks pretty easy to implement.  Just wondering, why didn't you?  Were there other issues that made postgresql-simple too hard to use?
18:45:08 <irene-knapp> no, that was actually the sole thing I didn't like about it
18:45:21 <irene-knapp> I did implement it, but because I was in a hurry I did my own thing instead of digging into someone else's codebase :)
18:45:36 <JoeyA> ah
18:45:45 <irene-knapp> I used postgres-pq or whatever it's called, the same backend library that postgresql-simple uses
18:46:06 <irene-knapp> and my own implementations of FromField, FromRow, and the RowHandler monad
18:46:37 <irene-knapp> the RowHandler monad was the only finicky bit because I insisted on making the instance MonadControlBase IO RowHandler, haha
18:47:15 <irene-knapp> I had in mind that eventually I could migrate to postgres-simple if my code lives long enough and it grows that feature
18:48:22 <JoeyA> I also implemented a row reader, but with one crucial difference: columns are referenced by name, rather than in sequence.
18:48:51 <irene-knapp> ah, cool!
18:49:20 <JoeyA> This provides a safety net of sorts when the query and reader aren't forced to be lock-step, like postgresql-simple does (I think).
18:49:24 <JoeyA> But it breaks composability
18:49:24 <irene-knapp> right, I see
18:49:34 <JoeyA> Namely, you can't take two readers and stick 'em together.
18:49:52 <irene-knapp> how does that interact with columns that are the results of computations?
18:49:58 <irene-knapp> do you have to AS them to some known name?
18:50:07 <JoeyA> Yes
18:50:13 <irene-knapp> hm, may be fine
18:50:16 <JoeyA> I don't have any query conversion stuff, though.
18:50:25 * irene-knapp nods
18:50:26 <JoeyA> Again, my system is generally inferior.
18:50:31 <irene-knapp> right, okay
18:50:50 <JoeyA> But it was fun to write.  It has an Applicative interface, so it can look up all the column names once :-)
18:50:53 <irene-knapp> right :)
18:51:00 <JoeyA> newtype ReadResult a = ReadResult {runReadResult :: PQ.Result -> IO (PQ.Row -> IO a)}
18:51:51 * irene-knapp nods
18:53:16 <JoeyA> I wish PostgreSQL supported temporary triggers.
18:53:27 <JoeyA> Then we could implement a higher-level async notification facility.
18:53:46 <JoeyA> Namely, have it automatically install a trigger that calls NOTIFY whenever a row is modified.
18:54:26 <JoeyA> The API could provide a copy of the table in its current state (on request).
18:54:43 <JoeyA> But the key feature would be automatic dispatch based on when things change.
18:55:26 <JoeyA> Keep copies of old records, and when a record is updated, call a user-supplied computation with both the old and new records.
18:56:37 <JoeyA> By applying a filter function to both sides, you can test if a relevant part of the record changed, and dispatch this to listeners.
18:57:59 <JoeyA> I had to do this in an application.  It was really time consuming to arrive at this solution (maybe I'm just slow and stupid).  I almost implemented this logic in SQL.
18:58:02 <otters> how would you make a lazy socket?
18:58:08 <otters> never mind
18:59:55 <crdueck> is there any/enough of an advantage to tail recursion in haskell as to make it worthwhile?
19:00:23 <JoeyA> crdueck: Are you asking this from the perspective of an implementor?
19:00:47 <crdueck> JoeyA: as in someone writing haskell programs? yes
19:00:55 <JoeyA> Oh
19:02:18 <crdueck> i'm just used to scheme where tail recursive optimization is guaranteed and so it's in your best interest to make all functions tail recursive.
19:02:49 <JoeyA> Oh, you're asking if making your functions tail-recursive is worthwhile.
19:03:02 <crdueck> but i've read things that point out that haskell's lazyness can avoid making the recursive calls untill they're needed so its not usually worth doing
19:03:06 <JoeyA> Well, in Haskell, a lot of functions *look* tail-recursive but actually aren't.
19:03:15 <JoeyA> @src foldr
19:03:15 <lambdabot> foldr f z []     = z
19:03:16 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
19:03:31 <JoeyA> This is not tail recursive per se.
19:03:44 <Saizan> crdueck: if you're using the result of the recursive call strictly then you'd better make it tail-recursive instead
19:04:00 <Saizan> crdueck: but if you can exploit laziness it's better not to
19:04:56 <JoeyA> @src mapM
19:04:56 <lambdabot> mapM f as = sequence (map f as)
19:05:01 <JoeyA> @src sequence
19:05:01 <lambdabot> sequence []     = return []
19:05:01 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
19:05:01 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
19:05:39 <JoeyA> Beware of this pattern, when used in a strict monad.  It is *not* tail-recursive, and it will stack overflow given a long enough list.
19:06:47 <JoeyA> I'd say that in a strict monad (e.g. IO), tail recursion is quite important.
19:08:27 <JoeyA> sequence' = go id where go dl [] = return $! dl []; go !dl (x:xs) = do v <- x; go (dl . (v:)) xs
19:09:05 <JoeyA> There's a version of sequence that returns a list of values that is safer to use in a strict monad (i.e. doesn't leak memory)
19:09:28 <JoeyA> Err, leak stack.  It uses memory for each of the items, though.
19:09:52 <JoeyA> dl here stands for "difference list"
19:19:36 * hackagebot chell 0.2.4 - A simple and intuitive library for automated testing.  http://hackage.haskell.org/package/chell-0.2.4 (JohnMillikin)
19:23:03 <JEntrep> has anyone in here used hnn, a neural network library in haskell?
19:30:42 <JoeyA> Ooh, neat, chell uses Template Haskell, presumably to keep you from having to label assertions, repeating yourself.
19:39:40 * hackagebot format 0.1.0.0 - Rendering from and scanning to format strings  http://hackage.haskell.org/package/format-0.1.0.0 (ScottLawrence)
19:49:18 <crdueck> @src unfoldr
19:49:19 <lambdabot> unfoldr f b  = case f b of
19:49:19 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
19:49:19 <lambdabot>    Nothing        -> []
19:52:09 <JoeyA> I'm using Haskell type signatures to work out how I'm going to do something in JavaScript.  Has anyone else done that?
19:53:19 <JoeyA> I wonder if a more powerful, dependently-typed language like Agda would be a better "thinking language" for this sort of purpose.  I don't know Agda yet.
19:53:47 <ezyang> I think Haskell types are plenty powerful for something like JavaScript.
19:55:23 <JoeyA> For example, this sketches out a function that generates form fields from data, and returns a corresponding function to read them back: data -> DOM a -> IO (Maybe (data -> IO data))
19:55:44 <JoeyA> Where a -> b -> IO c corresponds to function(a, b) {... return c;}
19:56:09 <JoeyA> and Maybe just means the thing can be nullable.
20:05:40 <RylandAlmanza> Anyone have experience with the haskell sdl bindings? I'm having trouble with waitEventBlocking.
20:05:44 <hpaste> RylandAlmanza pasted “SDL waitEventBlocking” at http://hpaste.org/68869
20:11:52 <dmwit> Anybody have a solution for sharing ~/.cabal across architectures?
20:13:32 <geekosaur> no :(
20:13:37 <dmwit> (I've got a dual boot of 32-bit and 64-bit Linuxes that share /home. Only sticking point is ~/.cabal/bin.)
20:13:40 <dmwit> ah
20:13:44 <dmwit> bummer
20:14:42 <dmwit> I suppose I'll probably hack up something horrible that links ~/.cabal/bin to something appropriate in my shell's rc file.
20:24:45 * hackagebot Elm 0.1.1 - The Elm compiler and server.  http://hackage.haskell.org/package/Elm-0.1.1 (EvanCzaplicki)
20:27:00 <xil> hello?
20:27:33 <zachk> hi
20:27:48 <xil> oh good. Thought IRC wasn't working
20:27:57 <zachk> xil try using /ping
20:28:06 <xil> awesome, thanks
20:28:30 <jmillikin> quick question -- it looks like GHC 7.4 is parsing the DEPRECATED pragma incorrectly. http://hpaste.org/68870 . Was this behavior change intentional?
20:28:45 <xil> so, how do I use lambdabot to get the src for a particular instance of a typeclass?
20:28:57 <xil> the src for a function of that typeclass
20:29:59 <xil> like the src for the [] instance of <*>
20:30:51 <aristid> xil: in general, you should probably try the online hoogle
20:31:40 <aristid> @src Applicative []
20:31:41 <lambdabot> Source not found. Maybe you made a typo?
20:34:02 <xil> okay, well the src isn't what I was expecting, not surprisingly. So here's the question: is <*> == map for []?
20:34:21 * gurrag just learned that lists are monads
20:34:46 * hackagebot Elm 0.1.1.1 - The Elm compiler and server.  http://hackage.haskell.org/package/Elm-0.1.1.1 (EvanCzaplicki)
20:39:39 <xil> wait a sec....
20:40:33 <xil> f a = do { b <- a; return b }
20:40:50 <Ralith> isn't that id?
20:40:57 <xil> if I do <f [1..3]> then what is b?
20:42:37 <Ralith> xil: 1, 2, or 3
20:42:46 <Ralith> refer to the Monad instance for List.
20:42:53 <Ralith>   xs >>= f = concatMap f xs
20:43:06 <xil> aha, List. I was searching for [] and getting nothing
20:43:25 <Ralith> do notation makes it look like imperative code, but it very much isn't
20:44:12 <xil> that is really awesome. I need to familiarize myself more with monads and Monad instances
20:44:19 <Ralith> isn't it? :D
20:44:28 <Ralith> and List, is only the beginning.
20:44:33 <zachk> > (flip concatMap) [1,2,3] (enumFromTo 1)
20:44:34 <lambdabot>  Terminated
20:44:40 <zachk> ??
20:45:43 <xil> Ralith: I've taken advantage some of the Maybe monad's bind instance to make some things easier. Also Either. But otherwise not much....
20:45:48 <xil> ...yet
20:46:10 * Ralith is presently in love with monadic futures
20:47:02 <zachk> Ralith: what are those?
20:48:12 <Ralith> zachk: what I have in mind, at least, is something that'll let you write I/O-bound code in synchronous style, which can be executed (and multiplexed) asynchronously.
20:48:37 <dmwit> ?src [] (>>=)
20:48:37 <lambdabot> xs >>= f     = concatMap f xs
20:48:43 <dmwit> ?src [] (<*>)
20:48:43 <lambdabot> (<*>) = ap
20:48:55 <Ralith> it needs more work atm, but it's an exciting idea
20:48:57 <xil> how is (<-) defined? You say that for lists (x >>= f) = (concatMap f xs), but how does that translate onto (<-) giving the elements of the list?
20:48:59 <dmwit> xil: Does that help?
20:49:15 <xil> dmwit: yeah I found the src on hoogle, but it's good knowing how to do it with lambdabot
20:49:20 <dmwit> xil: do { x <- m; e } translates to (m >>= \x -> e).
20:49:34 <xil> I often like to msg lambdabot directly for some of th istuff. Does it more easily than hoogling for some things
20:49:47 * hackagebot Elm 0.1.1.2 - The Elm compiler and server.  http://hackage.haskell.org/package/Elm-0.1.1.2 (EvanCzaplicki)
20:49:49 * hackagebot chell 0.2.5 - A simple and intuitive library for automated testing.  http://hackage.haskell.org/package/chell-0.2.5 (JohnMillikin)
20:50:05 <xil> dmwit: ah, okay awesome
20:51:15 <xil> ?src [] ap
20:51:15 <lambdabot> Source not found. Sorry.
20:52:07 <xil> wow that is clever
20:52:19 <xil> ap = liftM2 id
20:52:42 <xil> oh wait, I misunderstood
20:53:50 <tgeeky_> @src ap
20:53:50 <lambdabot> ap = liftM2 id
20:54:01 <tgeeky_> xil: looks right to me
20:54:06 <xil> no I know it's right
20:54:11 <xil> I just thought it was clever for the wrong reason
20:54:17 <xil> I don't see why it isn't just liftM
20:54:25 <tgeeky_> @type ap
20:54:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
20:54:27 <tgeeky_> @type liftM
20:54:28 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
20:55:05 <xil> ah
20:55:15 <xil> subtle difference
20:55:17 <tgeeky_> xil: liftM2 starts in an m context
20:55:21 <xil> yeah
20:55:56 <xil> @type id
20:55:57 <lambdabot> forall a. a -> a
20:56:18 <tgeeky_> @pl liftM2 id
20:56:19 <lambdabot> ap
20:56:33 <xil> bah, it's too complicated for me. I don't yet understand forall
20:56:41 <tgeeky_> xil: you don't need to understand forall
20:56:50 <xil> I mean, I understand it logically, but not for type declarations
20:57:06 <xil> why is liftM2 id a valid function application?
20:57:28 <xil> the type of liftM2 starts with ( a -> b -> c ), but id is a -> a
20:57:39 <tgeeky_> @type liftA2
20:57:40 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
20:57:52 <tgeeky_> @type liftA2 id
20:57:53 <lambdabot> forall b c (f :: * -> *). (Applicative f) => f (b -> c) -> f b -> f c
20:58:03 <tgeeky_> @type liftA2 id id
20:58:04 <lambdabot> forall b c. ((b -> c) -> b) -> (b -> c) -> c
20:58:06 <dmwit> because if you write "a -> b -> c = d -> d", there's a solution where "d = c = a -> b".
20:58:27 <dmwit> sorry, where "a = d = b -> c"
20:59:01 <dmwit> that is, "a -> b -> c" can become "(b -> c) -> (b -> c)" by specializing "a", and "d -> d" can also become "(b -> c) -> (b -> c)" by specializing "d".
20:59:43 <xil> ah I see
21:00:15 <tgeeky_> > uncurry (ap)
21:00:16 <lambdabot>   Overlapping instances for GHC.Show.Show ((m (a -> b), m a) -> m b)
21:00:16 <lambdabot>    arisi...
21:00:16 <xil> that is pretty cool
21:00:21 <tgeeky_> @type uncurry (ap)
21:00:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (m (a -> b), m a) -> m b
21:06:58 <xil> okay so if I get this right....ap and <*> are not the same as map, for lists
21:07:09 <dabblego> right
21:07:39 <xil> ap and <*> would take a list of functions and apply each one to each of the elements of the given list
21:07:49 <dmwit> right
21:07:58 <xil> sweet, I'm starting to understand this stuff
21:08:04 <dmwit> > [(+1), (*5)] <*> [10, 20]
21:08:05 <lambdabot>   [11,21,50,100]
21:08:08 <tgeeky_> the connor mcbride paper is the best for this stuff
21:08:56 <xil> The View from the Left?
21:09:06 <xil> oh wait there are a lot of paperly
21:09:26 <xil> tgeeky_: remember the name?
21:09:34 <tgeeky_> http://www.soi.city.ac.uk/~ross/papers/Applicative.html
21:09:50 * hackagebot Elm 0.1.1.3 - The Elm compiler and server.  http://hackage.haskell.org/package/Elm-0.1.1.3 (EvanCzaplicki)
21:10:10 <xil> sweet, thanks =D
21:13:13 <Guest29853> cool
21:14:09 <tgeeky_> Guest29853: IRC?
21:14:53 * hackagebot Elm 0.1.1.4 - The Elm compiler and server.  http://hackage.haskell.org/package/Elm-0.1.1.4 (EvanCzaplicki)
21:26:09 <NemesisD> hey guys, im thinking about writing a library for parsing cron intervals. want to figure out what my datatype should be like
21:26:43 <NemesisD> it will have a duration component, NominalDiffTime, i guess, and then a time component (month and day of year, hour, min, second)
21:27:52 <NemesisD> but i don't know if its better practice to return something like (Time, NominalDiffTime) or Cron Time NominalDiff Time or maybe newtype Cron = Cron (Time, NominalDiffTime)
21:28:22 <hpaste> dmwit pasted “arch-specific .cabal” at http://hpaste.org/68871
21:28:26 <dmwit> geekosaur: =)
21:29:08 <geekosaur> spose that works
21:29:27 * geekosaur kinda wishes @sys weren't openafs-specific though
21:31:14 <NemesisD> the downside to returning something generic like (Time, NominalDiffTime) is that it could be accidentally used interchangeably with a similar value that has nothing to do with Cron
21:45:38 <utkarsh__> hi
21:45:44 <utkarsh__> haskellers
21:45:49 <utkarsh__> neone there??
21:46:07 <dalt> yo
21:48:16 <utkarsh__> have you worked on parsing through parsec??
21:48:20 <utkarsh__> dalt
21:48:47 <dalt> not yet, i'm totally new to haskell as of 15 minutes ago
21:49:00 <utkarsh__> ok
21:51:41 <NemesisD> i've parsed with attoparsec
21:51:43 <NemesisD> once
21:52:15 <tgeeky_> *once*
22:01:26 <xil> @type ( id >>= return )
22:01:27 <lambdabot> forall a. a -> a
22:01:47 <xil> whoops, not what I meant
22:02:49 <xil> @type ( fromIntegral >>= putStrLn.show )
22:02:50 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `IO ()'
22:02:50 <lambdabot>     In the first argument of `(.)', namely `putStrLn'
22:02:50 <lambdabot>     In the second argument of `(>>=)', namely `putStrLn . show'
22:10:52 <xil> okay, I think I give up on figuring out how to write this. I have: "ls <- mapM ( readArray arr ) someIndexes; return $ map aToB arr". I'm looking for a way to condense that into a single application of mapM. aToB: a -> b
22:12:17 <dmwit> xil: Well, read literally, since you're not using ls, you could just use "return $ map aToB arr".
22:12:31 <dmwit> (?)
22:12:31 <xil> oh whoops
22:12:36 <xil> that should be map aToB ls
22:12:42 <dmwit> aha
22:12:57 <xil> =P
22:13:17 <dmwit> How about mapM (fmap aToB . readArray arr) someIndexes?
22:13:49 <dmwit> also possible: mapM (\i -> aToB <$> readArray arr i) someIndexes
22:13:52 <xil> ah fmap. Lemme go look at that a bit
22:14:05 <dmwit> (<$>) = fmap -- =)
22:15:02 <xil> fmap is just a more general map?
22:15:07 <dmwit> yes
22:15:51 <xil> ah I see how that works. Awesome
22:16:16 <xil> fmap essentially injects aToB inside the IO (.) returned by readArray arr
22:16:17 <xil> well
22:16:23 <xil> it's not IO in my case, but it still works
22:16:40 <xil> it's ST s in this case, but that's a functor it seems
22:16:57 <dmwit> All monads are functors. And almost all Monads are Functors.
22:17:17 <xil> haha, did you make a mistake?
22:17:33 <xil> or do I misunderstand the difference with the capitalizations?
22:17:43 <dmwit> I didn't make a mistake.
22:17:54 <xil> in theory all monads are functors, but in Haskell not all Monads have been made Functors
22:17:57 <dmwit> It's an unfortunate accident that it's possible to define a Monad instance without defining a Functor instance in Haskell.
22:18:03 <dmwit> correct
22:18:17 <dmwit> However, I don't know of any counterexamples. Only that counterexamples are possible. =)
22:18:41 <xil> ah okay, my apologies. I just thought it was funny how both statements are almost contradictory
22:18:51 <o-_-o> Hello
22:18:52 <dmwit> I know. =)
22:19:00 <dmwit> Hiya, o-_-o.
22:19:09 <o-_-o> So I am learning monads
22:19:32 <xil> o-_-o: I can't tell whether the 'o's or '-'s are the eyes
22:19:50 <o-_-o> Monad is anything that defines the 3 functions and is useful for ordering computations.
22:19:51 <dmwit> For me, the o's are headphones.
22:20:04 <dmwit> o-_-o: Anything that defines the functions and obeys the laws.
22:20:06 <xil> dmwit: ah now I see it
22:20:09 <manjunaths> sorry
22:20:11 <dmwit> useful for ordering computations is not a requirement.
22:20:48 <manjunaths> ok, Monads need not even be in a do, as in list monad and maybe monad
22:21:09 <manjunaths> and IO can be done without monads
22:21:41 <xil> I think the do-notation is a convenience. You don't need to use it with any monads. You can use it for list and maybe if you want
22:21:55 <xil> I just learned today that it does some really cool things when used with the list monad
22:21:58 <manjunaths> So the only reason for the existence of monad is that if there is a disconnect in my compositional pipeline, then I can use a monad to glue them together ?
22:22:01 <dmwit> Monadic code can be written without do-notation, yes. However, the second part of that sentence makes me wary: lists and maybe can use do-notation.
22:22:12 <dmwit> IO can be done without using the monad structure of the IO type, for sure.
22:22:30 <rwbarton> main = print "Hello world"
22:22:50 <dmwit> I'm not sure I understand what the final question means.
22:23:06 <xil> > wastedFunc = print "Hello World!"
22:23:06 <lambdabot>   <no location info>: parse error on input `='
22:23:07 <dmwit> Do monads really need to justify their own existence?
22:23:22 <manjunaths> If everything can be done without monads then why do they exist ?
22:23:29 <manjunaths> dmwit: good point
22:23:43 <dmwit> Monads are a handy interface that many things happen to fit into.
22:23:53 <xil> manjunaths: if everything can be done with Tuning machines, then why do computers exist?
22:23:56 <manjunaths> dmwit: Ok.
22:24:01 <dmwit> We can write a bunch of code that only uses that interface, and then becomes instantly useful and meaningful at many different types.
22:24:11 <manjunaths> dmwit: ah...ok
22:24:24 <tgeeky_> someone should tell snoyman his yesod book is on usenet! he's really made it!
22:24:34 <dmwit> As for whether everything can be done without monads, I think you need to be careful there.
22:24:53 <rwbarton> (->) a is a monad, does that mean if i use a function i use monads
22:24:58 <dmwit> Everything can be done without actually implementing the Monad interface, but you'll be using functions that would be valid implementations of that interface with other names.
22:25:01 <dmwit> Which seems a bit silly.
22:25:24 <dmwit> (Or what did you mean exactly by "everything can be done without monads"?)
22:25:35 <manjunaths> dmwit: I am just wondering why there are so many monad tutorials
22:25:36 <rwbarton> class WarmFuzzyThing
22:25:57 <dmwit> manjunaths: Because the community went through a phase in its adolescence. =)
22:26:06 <manjunaths> dmwit: Heh...ok
22:26:30 <tgeeky_> just know, that there was a time when we didn't have monads, and it was good. But then we got monads, and it was good-er.
22:26:32 <xil> dmwit: oh I forgot to thank you for the help. Thanks =D
22:26:46 <dmwit> You're welcome, of course. =)
22:27:46 <tgeeky_> dmwit: you make a good teacher.
22:28:28 <dmwit> That made me unreasonably happy, tgeeky.
22:28:38 <manjunaths> dmwit: Thanks.
22:28:44 <xil> here's just a funny little thing. Is there an easier way to write: f (_, _, _, x) = x
22:28:53 <dmwit> xil: There's a package for that.
22:28:55 <dmwit> ?hackage tuple
22:28:55 <lambdabot> http://hackage.haskell.org/package/tuple
22:29:38 <xil> ....wow
22:29:49 <xil> just brute force everything
22:29:58 <dmwit> yes =(
22:30:05 <xil> but it only goes up to 9. Is that by design or is that an actual limit?
22:30:07 <dmwit> But don't worry, the code is generated, not hand-written. =)
22:30:17 <xil> wait sorry 15
22:30:18 <tgeeky_> xil: just practicality
22:30:30 <tgeeky_> xil: most actual places tupling apperas, the highest arity is 7
22:30:40 <tgeeky_> but it works up to hundreds
22:30:45 <dmwit> Yeah, I think the author probably figured that tuples above size 15 really ought to be migrated to a more realistic data structure...
22:30:47 <jtobin> anyone know how to 'lift' a mwc-random generator into a forM_ loop that's running in ST?
22:30:59 <mm_freak> in GHC tuples are unlimited, as far as i see
22:31:00 <dmwit> tgeeky_: Actually, GHC itself has an upper limit of 63-tuples. =P
22:31:06 <xil> haha, I can't even begin to imagine someone writing a 100-tuple
22:31:10 <mm_freak> jtobin: can't be done
22:31:32 <jtobin> mm_freak: i was afraid of that
22:31:36 <mm_freak> jtobin: oh wait
22:31:36 <tgeeky_> dmwit: 63? hmm
22:31:41 <mm_freak> the interface has been changed
22:31:44 <mm_freak> it can be done =)
22:31:49 <jtobin> oh joy
22:31:50 <jtobin> haha
22:31:54 <jtobin> how so though?
22:32:13 <mm_freak> jtobin: you can't lift as far as i see, because the generator is tied to the monad
22:32:19 <tgeeky_> dmwit: i hope you didn't find this out by exhaustion
22:32:23 <mm_freak> so you need to actually create the generator in ST
22:32:35 <dmwit> tgeeky_: No, somebody else told me. =)
22:32:44 <dmwit> it's like... an oral tradition now
22:32:52 <mm_freak> jtobin: you can do this:  withSystemRandom mySTFunction
22:33:14 <mm_freak> or use 'initialize' if you want to pass a seed yourself
22:33:14 <dmwit> jtobin: There's nothing to do; ST is already an instance of PrimMonad.
22:33:16 <jtobin> yeah, presently i've got (in ST): gen <- initialize blah ; forM_ things *stuff involving uniformR*
22:33:18 <dmwit> mm_freak: what are you on about?
22:33:37 <dmwit> Or am I the confused one somehow?
22:33:49 <mm_freak> dmwit: the way i understand the question is that jtobin wants to carry an IO generator to ST
22:33:54 <mm_freak> and that's not possible as far as i see
22:33:58 <jtobin> not from IO to ST
22:34:12 <jtobin> from ST to.. further ST :)
22:34:32 <dmwit> Can you paste some code that doesn't work for us to look at?
22:34:33 <jtobin> jk, i don't think 'further ST' is really accurate there
22:34:44 <dmwit> ?hpaste
22:34:44 <lambdabot> Haskell pastebin: http://hpaste.org/
22:34:57 <mm_freak> jtobin: may i ask why you use mwc-random?
22:35:20 <jtobin> dmwit: yup, give me a sec
22:35:32 <jtobin> mm_freak: i know, you recommended mersenne yesterday
22:35:42 <jtobin> mm_freak: still executing in ST, and afaik mersenne doesn't support that?
22:35:43 <mm_freak> that's not why i'm asking
22:35:47 <jtobin> mm_freak: only IO?
22:35:58 <mm_freak> i'm asking because mwc-random, while slower, has a nicer interface =)
22:36:03 <tgeeky_> dmwit: https://github.com/ghc/packages-ghc-prim/commit/7fcfc880853fa399c9468049aeb14e6eadb9eae5
22:36:06 <tgeeky_> lol
22:36:45 <jtobin> mm_freak: mwc-random also has good support for various distributions, and this is a statistical application
22:36:53 <jtobin> mm_freak: so, while i do intend to try mersenne
22:37:06 <jtobin> mm_freak: i've been sticking with mwc for the time being
22:37:12 <mm_freak> "It causes GHC to use vast amounts of space compiling GHC/Tuple.hs."
22:37:13 <mm_freak> hehe
22:37:49 <mm_freak> jtobin: understood
22:37:55 <mm_freak> well, just keep mwc-random
22:38:04 <mm_freak> mersenne-random is only faster, but a lot less convenient
22:38:15 <dmwit> tgeeky_: aww
22:38:19 <dmwit> tgeeky_: No Generic for you!
22:38:39 <dmwit> tgeeky_: And yeah, the "Manuel says:" at the bottom is pretty hilarious.
22:38:59 <xil> hmm....I'm confused by this error, "25:10 parse error on input '::'," in this code http://hpaste.org/68872
22:39:49 <dmwit> xil: check out line 15
22:40:02 <xil> whoops *blush*
22:40:35 <dmwit> Just out of curiosity, what happens if you put another closing brace on line 17?
22:40:47 <tgeeky_> dmwit: but I was about to solve world peace using my fancy algorithim, but I need 64-tuples! Alas, the world will have to wait.
22:41:00 <dmwit> nooooo
22:41:07 <jtobin> whoops, forgot to select #haskell in the hpaste
22:41:15 <xil> dmwit: it parses but can't find the functions in that data type
22:41:15 <jtobin> dmwit mm_freak: http://hpaste.org/68873
22:41:18 <dmwit> Use a 4-tuple of 16-tuples and solve world peaaaaace!
22:41:32 <dmwit> xil: huh
22:41:37 <dmwit> xil: I wonder if that's a bug. =)
22:41:38 <tgeeky_> dmwit: I'm not smart enough to do that. Noooooo
22:41:58 <jtobin> the problem is that the generator doesn't update in the forM_ loop.  if i initialize a new generator in there, all is well
22:42:09 <dmwit> jtobin: You may like "replicateM_".
22:42:12 <jtobin> presently the code works but (i'm guessing) generates the same random numbers every time
22:42:16 <tgeeky_> there's a guy in the NBA who renamed himself "Metta World Peace"
22:42:20 <dmwit> Won't fix whatever problem you're having, but it's nicer than that hack. =)
22:42:32 <xil> dmwit: actually, maybe it's better if you just look at the output http://hpaste.org/68874
22:43:40 <cads> tgeeky, doesn't metta mean 'loving kindness'?
22:43:49 <dmwit> jtobin: uh... can you strip out just a tad less, so there's something we could actually observe breaking all by ourselves?
22:43:53 <tgeeky_> cads: I don't know.
22:44:08 <tgeeky_> But he is one of the most violent NBA players, and is one of the most ejected from games
22:44:24 <tgeeky_> he was "Ron Artest"
22:44:47 <mm_freak> jtobin: it would be really helpful if you write type signatures
22:44:51 <jtobin> dmwit: i know, i still tend to pick randomly from {replicateM_, forM_, mapM_} without rhyme/reason ;)
22:45:00 <mm_freak> jtobin: they will help others right now and yourself later =)
22:45:13 <xil> when importing the ST module, do I import Control.Monad.ST, or Control.Monad.ST.Safe. The latter is what's linked from Data.Array.ST, which is what I'm using the ST monad for.
22:45:18 <jtobin> mm_freak: sorry, a lot has been stripped out from the code
22:45:31 <mm_freak> jtobin: strip out everything, but not the type signatures ;)
22:45:34 <jtobin> mm_freak: rest assured that type sigs are always included on top-level bindings in finished products :)
22:45:57 <tgeeky_> cads: yes, it means "loving kindness and frendliness to all"
22:45:59 <mm_freak> jtobin: i also see a lot of unnecessary mutation there
22:46:02 <andares> argh the 20 haskell problems are getting hard.
22:46:06 <mm_freak> your code can be simplified a lot
22:46:38 <jtobin> dmwit: give me a sec and i'll whip up a simplified working example
22:46:52 <mm_freak> probably to the point where i would say that you don't actually need ST at all
22:47:05 <dmwit> xil: "go with your heart"
22:47:21 <jtobin> mm_freak: that would be lovely, haha
22:47:28 <jtobin> mm_freak: initially i did write this up using State
22:47:34 <xil> dmwit: haha, okay
22:47:50 <mm_freak> jtobin: do you understand that the fact that you are using mwc-random is the only reason your whole program is imperative?
22:48:10 <jtobin> mm_freak: started playing with ST today as it seemed like it could potentially be a better fit
22:48:37 <dmwit> mm_freak: It's really hard to say if that's true or not without seeing what the configuration data type looks like.
22:48:43 <dmwit> There could be real pointers/arrays in there.
22:49:22 <jtobin> mm_freak, dimwit: here is a paste of code from a couple of days ago: http://hpaste.org/68771
22:49:31 <dmwit> It seems a bit unlikely given the skeleton here where there's an STRef around the config, but that could just be a mistake in understanding.
22:49:35 <jtobin> mm_freak, dimwit: i'm in the process of retooling that to ST
22:49:57 <jtobin> dmwit: still working on that example i promised, nother minute or two
22:50:01 <dmwit> okay =)
22:50:26 <mm_freak> dmwit: pointers and arrays don't require IO/ST
22:50:43 <dmwit> what
22:52:09 <mm_freak> you can actually do quite a lot with pointers and arrays before you need IO/ST
22:52:26 <mm_freak> and of course talking about mutable arrays here
22:58:01 <jtobin> hmm, maybe i've got a different problem going on than i thought
22:58:20 <jtobin> in writing up a little working example for dmwit i don't observe the same effects o_O
23:01:54 <andares> I've been trying to think this through. is there a way to convert m (n b) to n (m b), where n and m are types?
23:02:07 <andares> that are applicative functors.
23:07:21 <jtobin> hmm yep i must have a different problem.. the numbers seem to be generating ok
23:07:32 <xil> thanks for the help again everyone =] -- especially dmwit =D. Have a good night!
23:07:33 <dmwit> andares: Sometimes.
23:07:34 <jtobin> let me check the code again.. might be something silly going on
23:07:42 <dmwit> andares: Not all functors commute.
23:07:55 <dmwit> However, those ones that do probably have an instance of that one thing. Traversable, maybe?
23:07:58 <dmwit> :t traverse
23:07:59 <lambdabot> Not in scope: `traverse'
23:08:06 <dmwit> :t Data.Traversable.traverse
23:08:07 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
23:08:13 <andares> I'm trying to solve moppy :: (Misty m) => [a] -> (a -> m b) -> m [b] from the 20 intermediate haskell problems.
23:08:29 <andares> where I have the methods of applicable functors.
23:08:44 <andares> and I've kind of been hitting my head against a wall, because it seems I can only do it if functors commute.
23:08:51 <dmwit> So, yup, you're trying to write traverse. =)
23:09:03 <dmwit> You can do it.
23:09:12 <dmwit> Keep banging that head. =)
23:09:16 <andares> using only fmap, <$> and <*>?
23:09:29 <dmwit> Oh, is Misty not Monad?
23:09:44 <andares> Misty is functor, I think.. or am I wrong? let me look.
23:10:22 <andares> oh waw, it is monad.
23:13:19 <dmwit> Applicative is enough, I think. But yeah, Monad makes it easy.
23:13:37 <andares> you're on a different plane of "easy" than I am. :p
23:13:45 <dabblego> the GHC docs spell infered incorrectly
23:13:46 <dmwit> sorry, easier
23:14:26 <dabblego> Safe Haskell	Safe-Infered
23:14:39 <dmwit> Yes, that's really annoying.
23:15:54 <andares> the problem I've run into is that I can't figure out a way of getting a out of [a] in such a way that I can return m b instead. d'oh
23:16:01 <dmwit> dabblego: File a ticket. =)
23:16:06 <dabblego> is there a Data.Text trie?
23:16:26 <dabblego> dmwit: I have a very spelling-anal colleague; I'll just show him in a minute and a ticket will be made for me :)
23:18:43 <dmwit> I wonder: is a Text trie really going to win over a boring old [Char] trie?
23:19:12 <dmwit> I suppose if you expect to have a sparse trie with long keys, it might.
23:19:19 <dabblego> is there a [Char] trie?
23:19:21 <dmwit> sure
23:19:28 <dabblego> I only see ByteString
23:19:30 <dmwit> http://hackage.haskell.org/package/list-tries e.g.
23:19:48 <dabblego> thanks
23:23:04 <andares> argh this is too hard. I'm going to give up for the night.
23:25:52 <jtobin> dimwit, mm_freak: crisis averted.  mwc was working as expected
23:26:06 <jtobin> had a typo that was causing grief
23:50:13 * hackagebot mega-sdist 0.1 - Handles uploading to Hackage from mega repos  http://hackage.haskell.org/package/mega-sdist-0.1 (MichaelSnoyman)
23:52:40 <absence> mm_freak: hi! i'm having trouble with my fully polymorphic input type. i get errors like "couldn't match type 'a' with '()' - 'a' is a rigid type variable bound by the type signature for functionThatCallsStepwire"
23:56:01 <guest__> is there a way to specify a particular version of ghc being needed in the cabal file; something like requires ghc >= 7.0.2
23:57:13 <megajosh2> I believe so
23:57:26 <megajosh2> hold on a sec
23:57:41 <dmwit> Not really. You can require particular extensions, though, which is the recommended way for most things.
23:57:49 <dmwit> What was added in 7.0 that you need to rely on?
23:58:04 <megajosh2> No? I thought I saw that once
23:58:07 <guest__> dmwit: default signatures
23:58:18 <megajosh2> Then again I'm not the world's most active haskell developer so...
23:58:22 <dmwit> What are default signatures?
23:58:38 <guest__> there's 'impl(ghc >= 7.0.2)' stuff; but that's for conditionals; I want a global constraint
23:58:54 <dmwit> Ah, the DefaultSignatures extension?
23:58:57 <dmwit> So depend on that.
23:59:14 <dmwit> That way, other implementations that offer DefaultSignatures won't be spuriously excluded.
23:59:45 <guest__> dmwit: ah, I didn't realize you can depend on explicit features in the cabal file. how do you do that?
