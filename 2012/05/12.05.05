00:14:57 <Saizan> TC?
00:19:53 <Franciman> Saizan, typeclass
00:19:59 <Franciman> I'm a bit lazy :)
00:20:44 <dmwit> (->), Kleisli m, Lens spring to mind
00:22:13 <Franciman> dmwit, and in what do they differ from Monads?
00:22:33 <dmwit> They have different kinds, for one thing.
00:22:36 <Franciman> they = Category
00:22:43 <Franciman> *Categories
00:23:22 <dmwit> I can't think of a very many things that are similar between them, really.
00:24:28 <Franciman> they can be both combined
00:26:36 <lysgaard> I have a datatype: data Foo a b = Bar a (Set b), how do I constrain it so that 'a' has to be an instance of a typeclass?
00:27:45 <dmwit> You don't.
00:27:53 <dmwit> You constraint functions that consume and produce Foo's, instead.
00:30:11 <lysgaard> dmwit: Ah, true. But my datatype only makes sense for an 'a' that's instance of a specific typeclass.
00:30:46 <dmwit> Why is that?
00:31:51 <lysgaard> I want to create an n-dimensional Vector. To do that, i want to combine an index of the Ix typeclass with a Vector.
00:32:35 <dmwit> Is your example more compelling than, say, Data.Map's Ord "requirement"?
00:34:18 <lysgaard> dmwit: Maybe not. I'll try it out and see if it works. Thanks for the help =)
00:42:44 <Saizan> with GHC you do it like data Foo a b = C a => Bar a (Set b) with GADTs enabled i think
00:43:41 <Saizan> but most of the time there are going to be some operations that don't care about the C a constraint and those would be unnecessarily constrained
00:44:55 <dmwit> Isn't that the one that doesn't do what you want it to do?
00:45:04 <Saizan> no, that's the one that does
00:45:36 <Saizan> data C a => Foo a b = .. is the other, but that's not more standard
00:45:42 <Saizan> *no
00:46:12 <dmwit> wow
00:46:24 <dmwit> That... is a really similar syntax.
00:47:36 <Saizan> they are fairly similar things :)
00:49:19 <efie> http://www.haskell.org/ghc/docs/7.0.1/html/libraries/containers-0.4.0.0/Data-Tree.html#1 - why is drawTree not of type drawTree :: (Show a) => Tree a -> String wouldn't this be better?
00:50:00 <dmwit> efie: drawTree . fmap show already does that
00:50:29 <dmwit> efie: The given type for drawTree is more flexible; for example, if I want to pretty-print my elements rather than showing them, I can do that.
00:52:02 <Franciman> if monads are arrows, and arrows aren't monads, what can arrows do that monads can't?
00:52:45 <dmwit> The canonical example is that parsing arrows can do static analysis of lookahead symbols.
00:52:51 <dmwit> See the Duponcheel paper for more details.
00:54:03 <Cale> Franciman: If you ask me, it's less about arrows being a generalisation of monads (in fact, I think that really arrows should be required to satisfy an additional law which would exclude the Kleisli instance), and more about what the arrow primitives reveal about the structure of your computation.
00:54:45 <Cale> But to get a sense for it, look at how in a monadic setting, you're putting together lots of things of type a -> m b (which is the type of the right hand parameter to >>=)
00:54:55 <Franciman> yes
00:55:10 <Cale> and because those are functions, they're completely opaque -- >>= can't inspect them at all in deciding how to carry out the computation
00:55:41 <Cale> It can only apply the function to a value of type a, which due to polymorphism, it can only get from doing something with its lefthand parameter
00:56:22 <Cale> With arrows, you have (>>>) :: (a ~> b) -> (b ~> c) -> (a ~> c), where now (~>) is a type which you have control over.
00:56:46 <Cale> and so (>>>) can conceivably do things to inspect these "function-like" arguments in many cases
00:57:09 <Franciman> yes
00:57:48 <Cale> (due to the presence of arr, it won't always be able to do something useful, and because there are no primitives for manipulating pairs, the arrow syntax will get in the way a lot by invoking arr constantly, but it's possible to work around these problems with enough trouble)
00:58:37 <Cale> At iPwn, we have a custom version of Control.Arrow, along with a new preprocessor for desugaring arrow syntax
00:58:48 <Franciman> cool
00:58:51 <Cale> in order to avoid arr as much as possible
00:59:15 <Cale> We also need an additional law, that (f >>> g) *** (h >>> k) = (f *** h) >>> (g *** k)
00:59:30 <Cale> which means that most monads aren't arrows to us
00:59:54 <Cale> But all the really useful instances of Arrow satisfy that law anyway
00:59:54 <Franciman> and for example what you use arrows for?
01:00:03 <Cale> functional reactive programming
01:00:28 <Cale> Are you familiar with FRP at all?
01:00:32 <Franciman> no
01:02:18 <Cale> Basically, FRP is the idea that there are two kinds of things which a stateful program needs to manipulate: there are things which always have a value whenever you look at them, and that value might be different at various points -- things like the position of the mouse, or the number of HP that a monster has, or what should be drawn on the screen
01:02:26 <Cale> those are called behaviours
01:02:43 <Cale> and then there are things which happen at discrete times and only when they occur do they have a value
01:02:56 <Franciman> events?
01:03:00 <Cale> yes
01:03:05 <Franciman> just read on wikipedia
01:03:16 <Cale> things like mouse clicks, keystrokes, attacks, sounds to be played perhaps
01:03:30 <Franciman> yes
01:04:05 <Cale> and so the goal of an FRP library is to provide a way to discuss behaviours and events and how they get constructed in terms of one another
01:04:45 <Franciman> oh ok
01:04:52 <Cale> The idea is that by defining the relationships between these things in a declarative way, we can avoid all sorts of bugs related to updating things in the wrong order, or forgetting to update them under certain conditions, etc.
01:06:07 <Franciman> of course
01:07:04 <Cale> In our arrowy library for FRP, our arrows transform behaviours into other behaviours, and events are represented by a parametric datatype. So we have things like  hold :: (ArrowEvent (~>)) => a -> (Event (~>) a ~> a)
01:07:18 <efie> dmwit: you mean like when I want to print my elements in a nicer way I can do this for example with "drawTree . fmap (\x -> show x ++ "NICE!")", which I could not do if I used "Show a => ..."?
01:07:37 <Cale> which takes an initial value and produces an arrow which consumes occurrences of an event, and switches its output behaviour's value just after each occurrence
01:07:56 <dmwit> efie: correct
01:09:39 <efie> dmwit: ok, that makes sense. I though the more general the type of functions are, the better, but there are probably more things to think about..  :)
01:09:43 <efie> thought*
01:09:44 <Franciman> Cale, so arrows are about analyising the input?
01:10:51 <dmwit> efie: Well, see, the thing you have to understand is that (forall a. Show a => a) is not more general than String. =)
01:11:02 <Cale> Franciman: Or being able to analyse the computation you're going to do before you do it
01:11:17 <Cale> Franciman: Monads don't let you do that so much
01:11:49 <Franciman> good, and why don't they?
01:12:52 <Cale> If you have x >>= f in some monad, then this means to "run" x (whatever that means), and then if its result is v, you then "run" (f v)
01:13:07 <Cale> But that means you can't know what the rest of the computation is until you've already started to run it.
01:13:47 <Cale> and so if there was some opportunity to not have to perform x at all for some reason, then it's too late by the time you could know this
01:14:35 <Cale> (or even just a way to simplify what needs to be done by combining x with some part of what f v is going to do)
01:14:53 <Cale> There's no way to tell that sort of thing at runtime, because f is completely opaque
01:16:13 <Franciman> Cale, ok, so if I have understood arrows let you do analysis on input, that is what monads can't do
01:16:14 <Franciman> right?
01:18:03 <Saizan> they let you do analysis on the computation itself, rather than on input
01:18:21 <Saizan> unless by input you meant that
01:18:39 <Franciman> by input I mean the first parameter of an arrow type
01:19:02 <Saizan> then no
01:19:18 <Saizan> i.e. that's not the point
01:19:59 <Franciman> and what is it :)?
01:20:25 <Saizan> you can have arrows that analyze the computation to be done before any input is given to them
01:21:09 <Franciman> can you give me an example?
01:24:10 <Saizan> http://en.wikibooks.org/wiki/Haskell/Understanding_arrows#Static_and_dynamic_parsers
01:24:27 <Saizan> even if since then they found other ways to structure their parsers
01:25:45 <bxc> Saizan: what other ways?
01:27:10 <Saizan> uu-parsinglib
01:28:40 <Franciman> oh great, thanks very much
01:34:06 <augur> Saizan! :D
01:37:17 <Saizan> augur?
01:37:23 <augur> hey
01:49:15 <navaati> hi
01:51:16 <Peaker> does the uu-parsinglib take advantage of Applicative/Non-monadic parser combinators? i.e: Can it build fast parsers which use the static-ness?
02:01:49 <lamefun2> http://code.haskell.org/frag/src/Object.hs
02:01:52 <lamefun2> ...
02:02:05 <lamefun2> Frag has all objects crammed in one place too
02:03:37 <Cale> lamefun2: hm?
02:05:02 <Cale> lamefun2: Are you referring to the ObsObjState type?
02:05:05 <lamefun2> how to make an entity system without cramming data of all entities into one data structure? ideally so entities can be loaded as modules on fly
02:05:08 <lamefun2> yes
02:05:20 <Cale> Ah, well, decide what operations you need on entities
02:05:30 <Cale> and then make entities records of those operations
02:06:20 <Cale> and then instead of data constructors, you have ordinary functions construct those records
02:06:43 <Cale> If you want to look at it in terms of OOP
02:06:52 <lamefun2> this? http://www.haskell.org/haskellwiki/FAQ#I.27m_making_an_RPG._Should_I_define_a_type_for_each_kind_of_monster.2C_and_a_type_class_for_them.3F
02:07:26 <Cale> sure, something like that
02:08:08 <lamefun2> so actual monster is a pair of Monster and MonsterOps?
02:08:08 <Cale> Basically, your private member variables become function parameters.
02:08:55 <Cale> Your constructor method becomes a normal function (of all the private state), and your other methods are fields of your record. Operations which would produce a new structure will just call the constructor(s) recursively.
02:09:09 <Cale> oh, actually, that's not quite what I was recommending
02:09:18 <Cale> I was recommending only MonsterOps :)
02:10:01 <Cale> but, yeah, you could move the position and hitpoints into MonsterOps if you want those to be transparent and all monsters have them
02:10:06 <Cale> (all entities, rather)
02:10:37 <Cale> Otherwise, they become parameters to the function which constructs a monster entity
02:11:30 <lamefun2> how do I create new entity with this?
02:11:34 <Cale> also, new probably doesn't make much sense in my way of thinking
02:11:54 <Cale> (though you could include it if you really wanted it)
02:12:15 <Cale> okay, so suppose we have something like:
02:13:35 <Cale> data Entity = Ent { draw :: IO (), step :: DeltaTime -> Entity, ... other operations ... }
02:14:04 <Cale> rocket pos vel acc = Ent { .. }
02:14:24 <Cale>   where draw = drawRocket pos -- forgot about angle, whatever
02:15:51 <Cale>         step dt = rocket (pos ^+^ dt *^ vel ^+^ (1/2 * dt^2) *^ acc) (vel ^+^ acc) acc
02:15:58 <Cale> something like that
02:15:59 <lamefun2> I undesrstand
02:16:02 <lamefun2> but
02:16:06 <lamefun2> wait
02:16:10 <lamefun2> i'll try myself
02:16:21 <Cale> In order to make the entities interact, you'll definitely need more than that
02:16:50 <Cale> and rather than simply producing an Entity, you may want to have the step produce a list of them (so that you can kill entities by giving an empty list, or spawn more)
02:17:01 <Cale> also, the step might have more inputs
02:17:16 <Cale> But that's the basic idea anyway
02:19:22 <teneen> The fact that you cannot define something like "inits [] = [[]]; inits = (:) <$> id <*> (inits . init)" is very annoying!
02:20:22 <Cale> It's basically to help with the case that you add a new parameter to some case of the function definition, but miss one of them.
02:20:37 <Cale> (though that'd *usually* be a type error for another reason)
02:21:02 <lamefun2> Cale: http://pastebin.com/cDgfM4uM - like this?
02:21:04 <mauke> The paste cDgfM4uM has been copied to http://hpaste.org/68113
02:21:20 <lamefun2> ...
02:21:35 <lamefun2> why does every channel copy pastes?
02:21:54 <Cale> lamefun2: Entity there is the opposite of what I meant
02:22:04 <Cale> But EntityClass is basically the idea
02:22:14 <Cale> (though, the name is kinda confusing)
02:22:39 <Cale> I guess if you're thinking of it as an OO abstract class, then yes. :)
02:23:50 <Cale> oh wait
02:23:53 <Cale> There's another problem
02:24:00 <Cale> nextState takes an Entity
02:24:02 <Cale> it shouldn't
02:24:14 <Cale> nextState :: TimeInterval -> EntityClass
02:24:25 <Cale> Yeah, it also shouldn't produce an Entity
02:24:28 <lamefun2> ...
02:24:30 <Cale> That stuff should be private :)
02:25:00 <Cale> Unless you really want it to be public, in which case, you should unify all this...
02:25:28 <lamefun2> eh
02:25:32 <lamefun2> you say
02:25:47 <lamefun2> that I should cram all data from my entities into one signle data structure?
02:27:31 <lamefun2> for example
02:27:54 <lamefun2> entity "Explosion" doesn't need to have xSpeed and ySpeed since it'll be just a static sprite animation
02:27:56 <hpaste> Cale annotated “pastebin.com/cDgfM4uM” with “pastebin.com/cDgfM4uM (annotation)” at http://hpaste.org/68113#a68114
02:28:18 <Cale> ^^ look there :)
02:28:34 <Cale> okay, so if the speeds should be private... then...
02:28:47 <lamefun2> Cale: that's exactly what I *don't* want to do
02:29:03 <hpaste> Cale annotated “pastebin.com/cDgfM4uM” with “pastebin.com/cDgfM4uM (annotation) (annotation)” at http://hpaste.org/68113#a68115
02:29:16 <Cale> ^^
02:29:32 <Cale> Just delete them from the structure, if you don't want to expose them :)
02:29:52 <Cale> You only expose the general interface of operations on entities for the rest of the program to see
02:30:07 <Cale> i.e. the things which would be 'public' in OOP
02:30:32 <Cale> the things which would be 'private' are still parameters to the constructor function though
02:30:48 <Cale> Does that make sense?
02:31:27 <Cale> oops
02:31:44 <Cale> bullet :: Double -> Double -> Double -> Double -> Entity
02:31:46 <Cale> in this case
02:31:54 <lamefun2> eh
02:32:00 <lamefun2> currying?
02:32:10 <Cale> yes
02:32:15 <Cale> I just got the type signature wrong
02:32:18 <Cale> in my paste
02:33:01 <Cale> There's no particular reason it needs to be curried, that's just how you do multiple parameters in Haskell
02:33:55 <lamefun2> looks nice
02:33:59 <lamefun2> thanks a lot
02:36:27 <YellowOnion1> how do I get cabal to install C/C++ packages?
02:36:32 <YellowOnion1> on windows
02:38:17 <dmwit> You have to install the C bits yourself.
02:38:33 <dmwit> What package are you trying to get installed?
02:38:48 <YellowOnion1> http://projects.haskell.org/diagrams/
02:39:21 <dmwit> That's not a C/C++ package.
02:39:28 <dmwit> I guess you are stuck on gtk2hs?
02:39:43 <dmwit> If so, there's install instructions on the gtk2hs website, including Windows-specific instructions.
02:39:45 <YellowOnion1> needs glibc
02:39:55 <dmwit> glibc?
02:40:04 <YellowOnion1> or glib
02:40:11 <dmwit> glib is very different from glibc.
02:40:14 <dmwit> glib is part of gtk2hs.
02:40:23 <YellowOnion1> yeah got them mixed up
02:40:34 <dmwit> http://code.haskell.org/gtk2hs/INSTALL
02:41:50 <YellowOnion1> so cabal install gtk2has-buildtools diagram doesn't work, but if I remove diagram from the command it installed
02:43:31 <YellowOnion1> yeah it says it didn't install, I'll check those docs
02:44:14 <Zedrikov> Does ghc throw an error if definitions mismatch in a hs and a hs-boot file? For instance, if in the hs-bootfile, I declare "test = True" and in the hs-bootfile "test = False", what will happen?
02:45:50 <Saizan> why do you put definitions in the hs-boot at all?
02:45:59 <Saizan> though i don't know
02:47:48 <Zedrikov> YellowOnion1: so cabal install gtk2has-buildtools diagram doesn't work, but if I remove diagram from the command it installed ← Did you mispelled it? The package is gtk2hs-buildtools, not gtk2has-buildtools, so it is normal if an error occured.
02:48:31 <YellowOnion1> na, cmd.exe copy past is'nt worth the effort
02:50:11 * hackagebot abstract-par-accelerate 0.3.1 - Provides the class ParAccelerate, nothing more.  http://hackage.haskell.org/package/abstract-par-accelerate-0.3.1 (RyanNewton)
02:50:26 <Zedrikov> Saizan: In fact I didn't put definitions in hs-boot, it was a wild question, you are right, I see no reason to put such a thing, excepted inadvertantly (for instance a copy/paste followed by a removal of some functions, but accidently not all)
02:51:34 <YellowOnion1> ok added .cabal/bin to path
02:52:33 <YellowOnion1> I wish I could play games on Linux, because then I would have no reason to be on this PITA OS
02:53:26 <hiptobecubic> YellowOnion1, what's wrong with it?
02:54:40 <YellowOnion1> I know a few people who dev a crossplatform app, and the actually use a linux build box compile the app for windows because they can't figure out how to do it on Windows
02:54:51 <YellowOnion1> to compile*
02:55:13 * hackagebot meta-par-accelerate 0.3.1 - Support for integrated Accelerate computations within Meta-par.  http://hackage.haskell.org/package/meta-par-accelerate-0.3.1 (RyanNewton)
02:55:13 <YellowOnion1> like even if it's a windows only feature, they still send it to the build box
02:56:52 <YellowOnion1> and Visual Studio is like a 3GB install and will not install to any other drive apart from C
02:57:12 <YellowOnion1> so I can't use that because I have 1GB of free space on my C
02:59:42 <YellowOnion1> *** Do not install the binaries into a directory with embedded spaces. ***
02:59:56 <YellowOnion1> On a windows system that's like suicide
03:00:14 <dmwit> Yes, you might as well give up right then.
03:02:17 <YellowOnion1> I'm pretty much stuck with python then :/
03:04:23 <dmwit> Why?
03:04:36 <dmwit> It's not like it's hard to avoid spaces in the path you pick for installation.
03:05:12 * hackagebot hbayes 0.2 - Inference with Discrete Bayesian Networks  http://hackage.haskell.org/package/hbayes-0.2 (alpheccar)
03:05:15 <YellowOnion1> just annoying :-|
03:05:29 <dmwit> ...
03:05:33 <YellowOnion1> I like everything organised
03:05:45 <dmwit> Nothing is stopping you from being organized.
03:05:50 <dmwit> Just be organized with no spaces.
03:06:17 <YellowOnion1> and reinstall everything in directories with no spaces?
03:06:23 <dmwit> eh?
03:06:33 <dmwit> What are you reinstalling?
03:06:54 <dmwit> Only the path to the Gtk+ package matters.
03:07:17 <YellowOnion1> yes, but it's not organised if it's in it's own path
03:08:32 <YellowOnion1> but I think trying to be organised an an OS that has a mind of it's own is stupid anyway
03:08:59 <YellowOnion1> there's a bout 12 files in H:\  that keep appearing, even deleting them doesn't nothing
03:10:10 <YellowOnion1> all my friends have the same problem, something from .NET crap
03:11:35 <YellowOnion1> there's a 6KB .bmp here which is solid white
03:20:42 <YellowOnion1> dmwit: it just annoying, everytime I tried to do some programming I end up not event touching the code because some package wont install, this one still doesn't and that the error messages are no help
03:22:19 <dmwit> I'm sorry you're frustrated.
03:22:32 <dmwit> If you post the command you tried and the error it gave you, there's a chance somebody here can help you.
03:25:27 <YellowOnion1> cabal install gtk2hs-buildtools diagrams > error.log
03:26:06 <YellowOnion1> https://gist.github.com/2601394
03:27:03 <dmwit> You need to install gtk2hs-buildtools first, then diagrams.
03:27:16 <dmwit> Also, you should double-check that your %PATH% includes the directory that containts gtk2hsC2hs.
03:27:33 <dmwit> e.g. %UserData%/.cabal/bin or whatever
03:27:35 <YellowOnion1> yeah I've checked all those
03:27:38 <dmwit> You may have to poke around a bit.
03:27:55 <dmwit> Okay, so does "gtk2hsC2hs --version" print something useful or an error?
03:30:11 <YellowOnion1> hmm, maybe %PATH% doesn't allow varibles in them
03:35:50 <YellowOnion1> dmwit: my %PATH% is so big I would have to pastebin it :/
03:36:01 <dmwit> heh
03:40:17 * hackagebot abstract-par-accelerate 0.3.2 - Provides the class ParAccelerate, nothing more.  http://hackage.haskell.org/package/abstract-par-accelerate-0.3.2 (RyanNewton)
03:42:00 <hpaste> mekeor pasted “could someone calculate 'g 4' please?” at http://hpaste.org/68116
03:42:25 <YellowOnion1> dmwit: seems I needed the PKG_CONFIG_PATH set as well
03:42:59 <dmwit> Ah, interesting.
03:43:36 <mekeor> does anybody have a powerful computer? could you calculate 'g 4' of the above paste, please, if so? that'd be awesome.
03:43:55 <dmwit> YellowOnion1: Did you add the gtk directory to your normal PATH?
03:44:04 <dmwit> the directory you installed Gtk+ to, I mean
03:44:08 <dmwit> (per the installation instructions)
03:44:16 <YellowOnion1> dmwit: yeah
03:44:21 <dmwit> hmph
03:44:41 <YellowOnion1> pkg-config was executing so it worked, but it was reporting errors about that varible
03:45:18 * hackagebot meta-par-accelerate 0.3.2 - Support for integrated Accelerate computations within Meta-par.  http://hackage.haskell.org/package/meta-par-accelerate-0.3.2 (RyanNewton)
03:52:54 <YellowOnion1> dmwit: oh yay it finally installed
03:53:04 <dmwit> \o/
03:53:21 <YellowOnion1>  /o/
03:54:14 <YellowOnion1> dmwit: http://imgur.com/gallery/rRacC
03:54:32 <YellowOnion1> planted dog
04:08:34 <YellowOnion1> and now errors about dlls :/
04:23:52 <roha> i have some problems with intendation, could somebody tell me what the problem is here? compiler error message included.
04:23:54 <hpaste> roha pasted “do block” at http://hpaste.org/68117
04:26:40 <Taneb> Try moving the "where" block left a bit?
04:26:43 <dmwit> roha: Your _ is indented too much.
04:26:46 <dmwit> By one space.
04:26:59 <dmwit> where block placement is fine
04:27:47 <roha> dmwit, yeah youre right. now it compiles, thanks!
04:28:34 <dmwit> roha: By the way, my clue was in the error message; it said "'/' -> init path' (...)", and the weird-looking extra "(...)" was what caught my eye.
04:29:37 <roha> ah because the extra space meant that "_ -> ..." was one the same line as "'/' -> init path'..."?
04:30:02 <dmwit> right
04:53:21 <navaati> ARGH, this bug in leksah with space triggering autocompletion (while it should only be <ctrl>space) is still there !
04:53:26 <navaati> wtf
04:53:37 <adnauseam> guys, what's wrong with my syntax here
04:53:38 <adnauseam> http://pastebin.com/YicT9tBm
04:53:41 <mauke> The paste YicT9tBm has been copied to http://hpaste.org/68118
04:56:09 <Cale> adnauseam: you have guards inside your let
04:56:18 <Cale> adnauseam: you probably want to use where instead
04:56:25 <Cale> where scopes over multiple guards
04:56:52 <sordina1> Still having issue swith indent parsing... Why would this be failing?
04:56:54 <Cale> the guards have to either be inside a case expression, or on the left side of an =
04:56:55 <hpaste> sordina1 pasted “Indent Parser” at http://hpaste.org/68119
04:57:04 <adnauseam> Cale: roger
04:57:57 <Cale> sordina1: what behaviour are you seeing?
04:58:34 <sordina1> Error(line 2, column 1):  unexpected "H"
04:59:00 <sordina1> Cale: I'm trying to create a nested source tree based only on indentation
05:20:54 <lamefun2> "Also, Haskell is not generally taught to whiny undergrads that throw a fit when faced with something this new and different."
05:21:01 <lamefun2> undergraduates are whiny O_o?
05:21:32 <Cale> Haskell isn't taught to undergrads?
05:22:01 <hpc> new and different? how dare they!
05:22:09 <sipa> what does undergrad mean exactly?
05:22:17 <sipa> like, how many years are you an undergraduate
05:22:21 <lamefun2> Cale: btw, is it possible to make a type detection system in haskell? so when passed an entity, I can know its type?
05:22:30 * barrucadu is disappointed that the Haskell module was discontinued at his uni a couple of years ago
05:22:33 <Cale> sipa: Means university before your first degree
05:22:40 <Cale> sipa: So 4 years usually
05:22:56 <ion> @type [Just 42]
05:22:57 <lambdabot> forall t. (Num t) => [Maybe t]
05:23:01 <ion> lamefun2: ↑
05:23:03 <sipa> ok, i learnt haskell in my 4th year at the university
05:23:18 <Cale> lamefun2: You can give your entities a field which is a string describing them
05:23:25 <hpc> this uni doesn't teach haskell at all, but it soon will
05:23:29 <Cale> lamefun2: Or an enumeration datatype
05:23:38 <hpc> only one class teaches FP right now, and that's the AI class
05:23:43 <hpc> which uses CL, of all things
05:23:51 * t7 never went to uni :(
05:24:22 <lamefun2> Are there any person-orientated languages? That just do what one wants them to do?
05:24:36 <t7> yeah, english
05:24:47 <t7> with the man servant framework
05:24:55 <t7> on rails
05:25:11 <Cale> lamefun2: What you're asking for there is a way to transform your current Entity system back to the sort of one which you didn't like originally :)
05:25:24 <Cale> (sort of) :)
05:25:29 <hpc> lamefun2: there's an esolang where the operations are inquiries on an IRC channel
05:28:21 <Franciman> Cale after some hours : arrows are like functions, the only difference is that with arrows you can analyse what they do, with functions you can't since they're opaque
05:28:27 <Franciman> is this right?
05:28:52 <Cale> yes, well, you might be able to anyway :)
05:29:09 <Cale> Arrow is just a typeclass which specifies an interface
05:29:22 <Franciman> in fact functions are arrows as well :)
05:29:24 <Cale> nt libraries might implement that interface just
05:29:25 <Franciman> yes
05:29:27 <Cale> oops
05:29:41 <hpc> the arr function messes with that line of reasoning a bit
05:29:41 <wli> "Observable type" is probably the word you're looking for.
05:29:49 <Cale> Different libraries might implement that interface just to get the notation
05:29:56 <Cale> hpc: only a bit
05:30:08 <Cale> hpc: You can still inspect everything not in the image of arr
05:30:14 <Cale> (potentially)
05:30:18 <hpc> yeah
05:30:22 <hpc> or give a broken instance
05:30:47 <Franciman> Cale, is this a good picture of arrows?
05:31:46 <Cale> Franciman: yeah, pretty much
05:32:02 <Franciman> what else can be said?
05:32:06 <Cale> Franciman: Monad and Arrow just describe general shapes that APIs of various libraries might fit into
05:32:18 <Franciman> yes
05:32:22 <Cale> (also, Applicative, and that whole hierarchy of classes)
05:33:05 <lamefun2> Cale: Is that that with Haskell I can either have a way not to cram everything in one structure or being able to retrieve class-specific data and functions from an entity?
05:33:19 <Franciman> of course, I meant just the concept they refer to
05:33:50 <Franciman> well, now I can go stright on and not use arrows lol
05:34:13 <ion> Nobody uses arrows laughing out loud. They’re serious business.
05:34:57 <Franciman> oh sorry dude
05:34:58 <Franciman> :)
05:36:29 <adnauseam> is there a way to calculate the binomial coefficient and get an Integer at the end, rather than a Float ? my current function has the signature binom :: (Enum a, Fractional a, Ord a) => a -> a -> a
05:36:48 <hpc> hmm
05:36:49 <hpc>     Warning: newtype `CUInt' is used in an FFI declaration,
05:36:49 <hpc>              but its constructor is not in scope.
05:36:49 <hpc>              This will become an error in GHC 7.6.1.
05:37:03 <wli> adnauseam: Use div not /
05:37:12 <hpc> aren't CUInt etc, specifically for FFI calls?
05:37:21 <adnauseam> wli: i will, thanks man !
05:38:02 <adnauseam> wli:  <3 <3 <3
05:39:35 <Igloo> hpc: You need to import it non-abstractly
05:40:05 <hpc> ah
05:40:13 <hpc> i thought they didn't export constructors
05:59:24 <donri> is there anything more than stm that makes concurrency "feel easier" in haskell compared to other [imperative] languages? or is it a mirage?
06:00:16 <donri> or perhaps just overall avoidance of global mutable state?
06:00:24 <bitonic> donri: lightweight threads? MVars?
06:00:32 <hpc> donri: immutability and "functions have superpowers" stuff
06:00:39 <bitonic> still, there are languages in which concurrency is easier than in haskell
06:00:42 <bitonic> well, there is A language
06:00:44 <bitonic> erlang
06:00:53 <bitonic> or feels easier and more natural anyways
06:01:02 <donri> cloud haskell? :P
06:01:03 <t7> pi calculus
06:01:09 <hpc> https://www.youtube.com/watch?v=1yH_j8-VVLo
06:01:34 <bitonic> donri: yeah I'm waiting for that to be ready, but I think it's more than that
06:02:11 <ion> hpc: hah
06:02:17 <bitonic> hpc: rofl
06:02:21 <mekeor> hpc: omg -.-
06:02:22 <donri> xD
06:03:47 <thalll> if i imported a module that contains a ADT with the same name, how can i refer to the one in the current module? if there is something like this. or self. ?
06:04:01 <hpc> thalll: make the import qualified
06:04:19 <donri> bitonic: but lightweight threads just make threading more "feasible" or "scalable" or something, not necessarily "easier"? and are mvars that different from the corresponding construct in other languages?
06:04:30 <hpc> import Foo hiding (Bar(..))
06:04:42 <merijn> donri: Lightweight threads don't make threading easier, but lack of mutable state does
06:04:44 <hpc> import qualified Foo (Bar(..)) as F
06:04:54 <bitonic> donri: it's easier because you feel like you can spawn threads without worrying about performance/spawning too many
06:04:59 <thalll> but then i need to prefix everything with "M.*" ?
06:05:00 <donri> true
06:05:12 <hpc> thalll: just the data structure stuff, if you do what i just typed
06:05:14 <hpc> but yeah
06:05:14 <bitonic> merijn: you can write immutable functions in other languages, but yeah
06:05:28 <merijn> bitonic: Sure
06:05:39 <thalll> hpc: hm okej, thx
06:06:33 <bitonic> the cool thing about erlang that it's really just simple functions, all the state is passed in as an argument and everything is clear
06:06:38 <bitonic> no monads, no arrows, no anything
06:06:38 <merijn> donri: I'm not really aware of constructs similar to mvar's in other languages, they're sort of a mix between mutex guarded variables combined with a condition signal
06:06:59 <bitonic> so the code is usually really clear and more composable
06:07:20 <merijn> bitonic: Yeah, Erlang seems neat. To bad the syntax is ugly :\
06:07:35 <bitonic> merijn: I don't mind it
06:07:51 <bitonic> haskell is still cooler.
06:08:16 <donri> canhas cloud agda?
06:08:44 <donri> http://tvtropes.org/pmwiki/pmwiki.php/Main/NinjaPirateZombieRobot
06:09:01 <hpc> donri: agda wouldn't be so presumptuous as to call it "cloud"
06:09:11 <hpc> "suspended condensate agda" -- more like :D
06:09:39 <donri> i always thought it was kind of a silly naming for haskell as well... though "the remote package" is comparably uninteresting
06:09:40 <thalll> hpc: was possible to write pathtothismodule.ADT , would be nice with a macro self.ADT that did just that
06:11:20 <hpc> they should just call it "distributed haskell"
06:11:24 <hpc> because that's what it is
06:15:30 * hackagebot data-lens-fd 2.0.2 - Lenses  http://hackage.haskell.org/package/data-lens-fd-2.0.2 (RussellOConnor)
06:16:18 <hpaste> stj pasted “finally full blown ray tracer :)” at http://hpaste.org/68122
06:16:23 <stj> and here's a screenshot: http://i.imgur.com/aR1eZ.png
06:18:19 <parcs`> stj: nice!
06:22:07 <tsousa> Real World Haskell is good book to someone who did read some chapters from LYAH but left without doing some real project in Haskell just some exercises?
06:23:13 <Franciman> yeah, that's what I did, and found it good
06:23:26 <merijn> tsousa: Yes
06:23:49 <merijn> tsousa: I think RWH is a good second book, it's a bit to terse as a first book IMO
06:24:06 <tsousa> should i skip the first chapters?
06:24:15 <Franciman> nah read it all
06:24:41 <Franciman> no wait
06:25:30 * hackagebot data-lens-template 2.1.4 - Utilities for Data.Lens  http://hackage.haskell.org/package/data-lens-template-2.1.4 (RussellOConnor)
06:25:54 <Franciman> tsousa, well actually you can also skip them
06:38:02 <nand`> What's a good way to write a hashing function of type [Integer] -> Double (on the scale 0-1) in a way that will produce reasonably spread-out results? ie. given an ample amount of purely random inputs, the output should be evenly spread throughout the codomain
06:39:09 <scopedTV> For [Int], you could do the XORd value, and then converting that to Double via its binary representation?
06:39:25 <scopedTV> Not sure how good of a choice that is, obviously.
06:40:01 <scopedTV> "purely random" [Integer] doesn't exist, you'd need to fix a distribution by the way.
06:40:41 <nand`> ah, it's actually [Int], not [Integer]
06:40:57 <nand`> (Bits Integer exists as well though)
06:41:27 <byorgey> interpreting a bitstring as a Double is unlikely to produce something in the range [0,1].
06:41:57 <nand`> byorgey: I was thinking of taking the result modulo something and dividing by that
06:42:24 <nand`> (note that the upper end is exclusive, that is the result should be >= 0 and < 1; but this doesn't really matter)
06:42:34 <scopedTV> Oh, missed that part.
06:42:35 <byorgey> that should certainly produce something with the right distribution
06:43:00 * scopedTV should learn to read.
06:43:01 <byorgey> whether it is a good hashing function is quite a different matter (which I don't know enough to answer)
06:43:15 <nand`> byorgey: doesn't matter; the only goal I stated is the only goal I'm aiming for
06:43:33 <nand`> collisions, reversal etc. is completely irrelevant
06:44:27 <byorgey> ok.  Then given a list of uniformly distributed Int values, their sum should be (approximately) uniformly distributed mod k (where k is anything you like)
06:45:19 <byorgey> then dividing by k gives you a value in the range 0-1.
06:45:25 <adnauseam> i'm trying to write a function that removes the last occurance of a character from a list. my method is the following: count the elment within the list - then iterate through the list again, this time counting and delete at the last iteration. is this a good way of doing it ?
06:45:36 <byorgey> although note it will be 'quantized' i.e. you can only get things of the form x/k
06:46:08 <byorgey> adnauseam: probably not
06:46:31 <byorgey> adnauseam: I would do it by first reversing the list, deleting the *first* occurrence of the character, then reversing again
06:46:54 <adnauseam> byorgey: that's genuis.
06:47:06 <adnauseam> thanks man
06:50:21 <hiptobecubic> byorgey, is it actually faster that way though? Reversing the list means walking to the end of it doesn't it?  Or does it keep a pointer to the tail lying around?
06:50:34 <nand`> hiptobecubic: it does
06:50:45 <nand`> and going through the list twice (once to count, the second to remove) is just as inefficient
06:51:08 <nand`> hiptobecubic: there's no other way to do it either; since you have to know the list ends to know a character was the last occurence
06:51:15 <nand`> so you ultimately have to traverse to the end one way or the other
06:51:45 <hiptobecubic> nand`, right. So I was curious as to whether or not   reverse . dropit . reverse was *better* than just doing it the 'naive' way
06:51:48 <fmap> i guess what will be faster depends on where the last occurence is
06:52:13 <hiptobecubic> well if it knows where the end of the list is, then it will be at least as fast to reverse
06:52:21 <nand`> hiptobecubic: while I don't know if it's *better*, it's certainly cleaner and easier to understand
06:52:43 <hiptobecubic> faster if the last occurrence is near the end (and thus near the beginning of the reversed)
06:55:40 <nand`> fmap: I'm not sure if that has any effect
06:57:09 <nand`> fmap: even if the last character is right at the beginning, you have to traverse it at least once to know that; and the “removal” function doesn't just magically stop evaluating when the last character is found
06:57:35 <nand`> if you evaluate the result completely, then the “removal” function traverses to the end as well
06:59:34 <Skola> pointfree often suggests a use of listM2, but when I try to use it, ghc gives "No instance for (Monad ((->) [Int])) arising from a use of `liftM2'
06:59:39 <Skola> or something similar
06:59:54 <Skola> liftM2*
06:59:54 <nand`> Skola: import Control.Monad.Instances
07:00:12 <Skola> thanks!
07:02:46 <fmap> nand`: if the last occurence is the head of initial list then the latter algorithm does 3 traversals, doesn't it?
07:03:25 <fmap> where the former does at most 2
07:07:32 <nand`> I believe (reverse . init . reverse) would still only require two traversals to start outputting lazily
07:08:28 <nand`> since “init” is lazy, it doesn't force a traversal to the end; it's the reverse that comes after it that makes it evaluate completely; but on top of the output of reverse (which requires one traversal to start outputting)
07:10:43 <nand`> (note that removeFirstOccurenceOf c should also be lazy)
07:16:11 <merijn> I'm using data-lens to automatically generate lenses for my record syntax ADT, is there a "nice" way of creating a new value of that type or do I just use normal record syntax plus the ugly underscore names?
07:41:04 <scooty-puff> is there a way to ensure that a data constructor use is not optimized away?
07:41:10 <scooty-puff> for when using weak pointers
07:45:01 <navaati> does someone use netwire here ?
07:45:13 <merijn> What's a good library for scraping HTML pages?
07:47:39 <navaati> merijn: you want to parse the page or you want to download every link in it ?
07:47:50 <navaati> if 1/, libtagsoup, if 2/, libcurl
07:49:11 <merijn> navaati: Parse, for given values of parse :p
07:49:46 <navaati> then tagsoup is the right lib, it can parse even shitty html. not sure that there is a haskell binding, tho
07:49:58 <merijn> Apparently there is :)
07:50:12 <navaati> yep
07:50:15 <navaati> lucky boy
08:00:07 <hiptobecubic> merijn, forkIO a perl script and do it with regex and special variables  :D
08:00:35 <hiptobecubic> what could go wrong
08:15:36 * hackagebot paragon 0.1.11 - Paragon  http://hackage.haskell.org/package/paragon-0.1.11 (NiklasBroberg)
08:15:37 <_flow_> I need to compute a lot of stuff on big ASCII Data, on the one hand ByteString looks ideal, on the other a lot of functions are only defined for String, Char and not Word8. Should I got with String or with ByteString?
08:16:19 <fmap> what functions?
08:16:28 <_flow_> isSpace etc.
08:16:56 <eisbaw> hey
08:17:08 <donri> merijn: there's been some blog posts with hxt
08:17:19 <eisbaw> I know (+1) is a partial function
08:17:24 <navaati> @hoogle v -> Wire e (>~) (Maybe v) v
08:17:25 <lambdabot> Warning: Unknown type Wire
08:17:25 <lambdabot> No results found
08:17:27 <eisbaw> and I can also do (/8)
08:17:35 <fmap> _flow_: http://hackage.haskell.org/packages/archive/bytestring/0.9.2.1/doc/html/Data-ByteString-Lazy-Char8.html
08:17:35 <donri> eisbaw: no, it's a partially applied function
08:17:43 <eisbaw> but why can't I do, fx (-10)    ?
08:17:51 <donri> eisbaw: (which in haskell is just a function)
08:18:00 <eisbaw> @donri: ok :)
08:18:01 <lambdabot> Unknown command, try @list
08:18:05 <eisbaw> donri: ok :)
08:18:28 <_flow_> fmap: Lazy.Char8 perfect :) ty
08:18:38 <donri> eisbaw: when haskell programmers speak of "partial" functions they're usually talking about functions that can fail at runtime
08:18:41 <lamefun2> this is strange language... are there people who were taught Haskell as the first language?
08:19:13 <mzero> eisbaw: the reason (-10) doesn't work, as it parses as a negative number
08:19:14 <eisbaw> donri: okay, I will look more into that. I am a beginner.
08:19:17 <donri> eisbaw: probably a parse problem with negative numbers...
08:19:24 <mzero> you use     (subtract 10)   or the hack   (-10+)
08:19:30 <eisbaw> donri: aha
08:19:37 <donri> > (- 10) 20
08:19:38 <lambdabot>   -10
08:19:46 <donri> > ((-) 10) 20
08:19:47 <lambdabot>   -10
08:20:07 <eisbaw> donri: got it
08:20:10 <donri> ^_^
08:20:14 <eisbaw> :)
08:20:16 <donri> ignore lambdabot's crazy num instances
08:20:48 <eisbaw> btw, I made a reverse $ operator, so its similar to unix pipes
08:21:01 <eisbaw> I know its been done before, but I think its wicked cool :)
08:21:53 <mzero> you'll get used to $, trust me... after all,  I bet you don't find      doneLast (doneMiddle (doneFirst thing)
08:22:14 <donri> eisbaw: or use (>>>) from Control.Category
08:22:32 <mzero> when we think of computation as functions, it has been natural to have the last applied function on the left.... $ just let's you do it without parenthesis
08:23:01 <mzero> when we think of computation as sequencing (like pipes, or Haskell's >>=) we tend to think of the last operation on the right
08:23:30 <mzero> er.. I meant   I bet you don't find      doneLast (doneMiddle (doneFirst thing))) strange
08:23:48 <donri> > (take 10 >>> length) [1..]
08:23:49 <lambdabot>   10
08:24:06 <eisbaw> mzero: exactly, but this time I just needed standard-deviation, so datapoints ||| map (\x -> x - mean) ||| map square ||| sum ||| sqrt   seems intuitive
08:24:40 <eisbaw> donri: cool
08:25:48 <donri> but note that it's the flipped (.) (though generalized beyond functions), not ($)
08:26:54 <donri> which is why we can't do (take 10 [1..] >>> length)
08:27:05 <incog> man i love cock
08:27:08 <incog> feed me dicks
08:27:10 <incog> gay for cock
08:27:13 <eisbaw> wtf
08:27:22 <incog> what
08:27:33 <donri> @where ops
08:27:33 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
08:27:34 <incog> JIMMY CRACK CORN BUT I SUCK DICK
08:27:38 <incog> JIMMY CRACK CORN BUT I SUCK DICK
08:27:48 <incog> CAN YOU GET PREGNANT FROM ANAL SEX
08:27:52 --- mode: ChanServ set +o mauke
08:27:52 --- mode: mauke set +b *!*@95.141.28.51
08:28:00 --- kick: incog was kicked by mauke (incog)
08:28:09 <donri> mauke: y u no on @where ops
08:28:15 <mzero> eisbaw: whcih ever way works for you....  but If I were saying that forumla out loud I'd say   "it's the sqrt of sum of the square of the difference between each point and the mean
08:28:26 <mauke> donri: why do I have to be?
08:28:36 <mzero> which translates directly into       sqrt . sum . map (square . subtract mean)
08:28:38 <eisbaw> mzero: true ;)
08:28:39 <donri> seems not ;)
08:28:52 <Mathnerd314> mauke: so you get highlighted when you're distracted?
08:29:23 <mauke> I do get highlighted
08:29:49 <donri> you highlight on "@where ops" itself?
08:29:59 <mauke> yep
08:30:00 --- mode: mauke set -o mauke
08:30:01 <donri> cute :)
08:30:17 <mauke> seems simpler
08:32:32 <Mathnerd314> hmm, like @get-shapr
08:37:39 <adnauseam> is there a better way to check if ObjectA is a permutation of ObjectB, than to sort both objects and see if they're equal ?
08:38:47 <cheater__> good luck with infinite lists
08:39:56 <adnauseam> cheater__: mhm, i didn't think about checking two infinite lists - not sure if that's possible o_0
08:39:59 <Kaide> actually it doesn't really make sense to talk about one infinite thing as a permutation of anothe rinfinite thing does it?
08:40:15 <merijn> Is there an example of how to implement an instance of Read?
08:40:44 <Taneb> I think in terms of Dwarf Fortress I'm a competent haskell programmer
08:40:47 <Kaide> so there is the build in assumption that it should be finite
08:41:25 <cheater__> Kaide: it does, infinite things can be permutations of eachother
08:41:49 <cheater__> for example, 0, 1, 0, 0, 0, 0, ...       and 1, 0, 0, 0, 0, 0, ...
08:41:57 <adnauseam> cheater__: is there an implementation out there that actually compares infinite lists to eachother ?
08:42:00 <Kaide> cheater__: how do you generate a all permutations of an infinite list?
08:42:01 <adnauseam> do i really want it ? o_0
08:42:50 <Kaide> adnauseam: Yes, and depends what you want to do, and it only works on lists of bits
08:43:00 <cg_morton> well an infinite list has to have some generative function right?  So if a prefix of A is a permutation of B and the remainders have the same generative function, you have a match
08:43:15 <Kaide> oh that's true
08:44:25 <cheater__> adnauseam: no.
08:44:38 <cheater__> Kaide: i don't care how you generate all permutations
08:45:18 <cheater__> cg_morton: unless my generative function is rnd
08:45:50 <cg_morton> ah, but that's not a pure function
08:46:05 <cg_morton> if they're both rnd with the same seed
08:46:09 <cg_morton> then it still works
08:46:23 <cheater__> gray area here
08:46:27 <cg_morton> hehe
08:46:29 <cheater__> memoized rnd is a pure function
08:50:11 <byorgey> Kaide: you can't generate all permutations of an infinite list, there are too many.
08:51:11 <bitonic> what's the fastest "encode" with Text? I guess is one of the Utf16, but which?
08:51:28 <bitonic> in other words, if I have to hash a Text, what to do?
08:52:56 <adnauseam> well that more or less confused me a bit, but i get it, i'll also rephrase, given two non-infinite lists, is there a better way to check if one is a permutation of the other without sorting both first?
08:53:13 <adnauseam> and i don't have the generative functions of either
08:53:37 <adnauseam> the signature is simple [a] -> [b] -> Bool
08:53:41 <adnauseam> simply*
08:56:49 <adnauseam> i'll just sort and compare :p
08:58:42 <byorgey> adnauseam: that type signature doesn't make sense.  You can't do anything with two lists if you don't even know that they have the same type.
08:59:07 <otters> If I have a list of Strings, what's the best/fastest way to check which ones are contained in /usr/share/dict/words?
08:59:51 <byorgey> adnauseam: if you have an Ord constraint on the list elements, then sorting is probably the best way to check.  I don't think you can do it any faster than that anyway.
09:00:07 <Svarg> byorgey: you could check if their lengths are the same!
09:00:20 <byorgey> Svarg: you're right, I misspoke!
09:00:45 <byorgey> If they have different lengths then one is definitely not a permutation of the other =)
09:01:13 <byorgey> so, correction: you can't do *much* with two lists if you don't even know that they have the same type. =)
09:01:39 <otters> should I use a different String type for this
09:02:01 <adnauseam> byorgey: yeah, just implementing a sorting algo atm, and i've a (Ord a) => [a] -> [a] -> Bool in the sig
09:02:33 <byorgey> adnauseam: you're implementing a sorting algoithm? What's wrong with Data.List.sort?
09:03:41 <byorgey> otters: it totally depends on your requirements, how many Strings you have, etc. etc.  There is unlikely to be one absolute best way.
09:03:50 <otters> byorgey: 10,096
09:04:22 <byorgey> otters: just implement it in the simplest way possible to start, and see if it is fast enough for you.  e.g. read /use/share/dict/words into a Set and then use membership tests.
09:04:31 <otters> oh okay
09:05:38 <otters> so I'm going to have to read it into a list and then make a set out of that, right
09:12:48 <oddraisent> parse ((Elda <$> (many1 (noneOf "=") <* string "=") <*> (many1 (noneOf "\\"))) `Text.Parsec.sepBy` (string "\n")) "" "1=2\n3=4"
09:12:51 <oddraisent> Right [Elda "1" "2\n3=4"]
09:13:10 <oddraisent> How can I get Right [Elda "1" "2", Elda "2" "4"]?
09:13:54 <Svarg> where would i be able to find out who currently maintains concurrency libs in base? i have a new implemenation of concurrent channels that fixes issues http://hackage.haskell.org/trac/ghc/ticket/4154 and http://hackage.haskell.org/trac/ghc/ticket/3527 - it also exposes 3 new apis along with the old one - 2 lower-level concurrent queues (one blocking and one non-blocking), and a new implementation of concurrent channels with an applica
09:13:55 <otters> what's the time complexity of elem?
09:13:55 <Svarg> functor instance
09:15:52 <byorgey> oddraisent: do you mean  (many1 (noneOf "\n")) ?
09:15:59 <byorgey> instead of "\\"
09:16:34 <xraycat> otters: Data.List.elem? shouldn't it be O(n)?
09:16:47 <byorgey> \n is a single character, the \ is just an escape used when representing it, there is not actually a literal backslash in the string
09:16:49 <otters> I guess
09:16:52 <byorgey> yes, O(n)
09:17:28 <otters> hmm
09:17:51 <otters> turns out in a real-world context, it'll be less like 10,000 strings and more like 720,000
09:17:57 <neophyte> Maybe someone will be able to help me, I amtrying to devise a reasonable way to assign code numbers to recursive functions. (The hint is: Every recursive function has a standard description). Let d(x) be the function that yields a 1 if the xth recursive function is defined and has value 0 for argument x; else d(x)=0. Show d is not recursive. Any ideas how to do this?
09:18:03 <byorgey> otters: fine.
09:18:09 <oddraisent> byorgey: but "\n" is list of characters. Or \n is a single special character?
09:18:20 <byorgey> oddraisent: yes, \n is a single special character.
09:18:25 <byorgey> a newline character.
09:18:25 <oddraisent> byorgey: ok
09:18:48 <byorgey> otters: I still think what I suggested should work fine
09:18:53 <otters> right
09:18:58 <otters> it takes about 15 seconds with runhaskell
09:19:02 <otters> but compiled it's 3.22 seconds
09:19:05 <otters> which is not so bad
09:19:14 <byorgey> cool
09:19:29 <otters> oh, no, 7 seconds
09:19:40 <byorgey> you could probably speed it up by using a trie instead of just a Set of words. But that makes things more complicated
09:19:56 <otters> indeed
09:19:56 <byorgey> not sure if there is a trie package on Hackage you could use
09:19:59 <byorgey> there probably is though
09:20:07 <otters> data.trie
09:20:22 <otters> not really sure what a trie is though
09:21:30 <byorgey> looks like there are quite a lot of trie packages on Hackage.  the problem is choosing the best one for your purposes.
09:22:03 <byorgey> imagine a tree where each node can have many children in a list, and the edges are labeled by characters
09:22:21 <byorgey> so each word in the set is represented by a path from the root of the trie to a leaf
09:23:04 <otters> I see
09:23:04 <oddraisent> byorgey: why it fails for "1=2\n3=4\n"?
09:23:32 <byorgey> oddraisent: what do you mean "fails"?
09:23:41 <mzero> otters - have tried using Data.HashSet from the unordered containers package?
09:23:48 <otters> not yet
09:24:01 <mzero> has about the same interface as Data.Set, but faster
09:24:10 <otters> I see
09:24:14 <oddraisent> byorgey: returns Left with error message "unexpected end of input"
09:24:20 <mzero> (as it seems you don't need to enumerate the set in order, which Data.Set gives you)
09:24:54 <oddraisent> Seems like last element of strings list is empty
09:25:10 <byorgey> oddraisent: hmm, not sure
09:25:11 <otters> saved 0.02s
09:25:15 <otters> using hashset
09:25:31 <mzero> hmmm... not much, would have expected much more
09:25:53 <mzero> you are loading all of /usr/share/dict/words into it, then probing a list of 10k words, right?
09:27:45 <otters> well, my list is 720,000 members, and /usr/share/dict/words is 286,000
09:27:52 --- mode: ChanServ set +o mauke
09:27:53 --- mode: mauke set -b *!*@95.141.28.51
09:29:05 <otters> building the hashset itself only takes 0.000287 seconds
09:29:53 --- mode: mauke set -o mauke
09:30:26 <mzero> beware of timing Haskell
09:30:44 <otters> okay
09:31:30 <mzero> that would be a nanosecond per word - I doubt it!  that is probably time to create the thunk
09:31:42 <mzero> how are you reading the files? hGetContents ?
09:31:43 <otters> well, if you say so
09:31:44 <otters> yeah
09:32:24 <mzero> If the time is too slow, you will probably gain speed by switching from String ot Test
09:32:34 <mzero> and use the hGetContents functions from there
09:32:40 <otters> Test?
09:32:48 <mzero> er Text
09:32:50 <mzero> Data.Text
09:32:53 <otters> oh okay
09:33:01 <mzero> Strings are very inefficient
09:33:10 <otters> as I've heard
09:34:34 <mzero> you will probably want Data.Text.Lazy.IO
09:34:42 <otters> foundi t
09:34:47 <mzero> which has an hGetContents which will do what you want
09:34:57 <mzero> the non-lazy version will need to read the whole file into memory first
09:34:58 <otters> right
09:35:02 <mzero> which may be okay
09:35:11 <otters> well, I kinda need it in memory anyway to compute the intersection of the two lists
09:35:16 <mzero> 720k words isn't THAT big
09:35:18 <otters> I mean, as far as I know...
09:35:20 <merijn> Hmm, I want a custom read instance, are there any examples I can pilfer?
09:35:32 <mzero> well ... try both
09:35:34 <mzero> same API!
09:35:59 <hpc> merijn: google readsPrec
09:37:49 <otters> so I have the dictionary as Text
09:39:57 <otters> but I'm using Data.List.Split.endBy to split the dictionary
09:39:58 <otters> into words
09:41:05 <otters> how should I split the dictionary into words?
09:44:29 <adnauseam> is my syntax wrong here http://pastebin.com/znB87c7D
09:44:34 <mauke> The paste znB87c7D has been copied to http://hpaste.org/68126
09:44:36 <adnauseam> "?
09:45:14 <mzero> otters - how about   Data.Text's splitOn  or    lines?
09:45:16 <mzero> or words?
09:45:18 <otters> oh
09:45:20 <otters> oh lines
09:45:21 <otters> duh
09:45:27 <adnauseam> because i'm getting a non exhaustive exception
09:46:04 <merijn> hpc: Yeah, I got that much, but I'm unclear how to do implement it :p
09:46:08 <mauke> adnauseam: sort' []
09:46:09 <otters> oh god
09:46:17 <otters> an inexplicable error
09:46:38 <sepp2k> adnauseam: You're not covering the case where the argument to sort' is the empty list.
09:47:10 <adnauseam> oh, hrm
09:47:26 <adnauseam> then instead ns == [], rather have (n:ns) == [] ?
09:47:28 <sepp2k> adnauseam: Also sort' [1] would be [] according to your code.
09:47:28 <merijn> hpc: Oh, looks like I want Text.Read
09:47:39 <otters> "Couldn't match expected type `T.Text' with actual type `Data.Text.Lazy.Internal.Text'"
09:47:40 <adnauseam> sepp2k: yeah, i just noticed :|
09:47:41 <mauke> adnauseam: that makes no sense
09:47:47 <sepp2k> adnauseam: (n:ns) can't ever be equal to []
09:47:49 <otters> where I imported Data.Text as T
09:47:55 <sepp2k> You want sort' [] = []
09:48:04 <adnauseam> oh, that simple
09:48:32 <Ptival> is there a delete version that removes all occurences?
09:48:43 <mauke> filter
09:48:44 <jonkri> what format do you recommend for a haskell library manual?
09:48:50 <Ptival> mauke: thanks :)
09:48:53 <jonkri> being able to convert it to html is a plus :)
09:49:06 <mauke> jonkri: haddock
09:49:33 <jonkri> mauke, i'll have that, but i meant something more like a book
09:50:07 <barrucadu> jonkri: Literate Haskell?
09:50:43 <mzero> otters - you can't mix the Lazy and non-Lazy versions of Text
09:50:47 <otters> okay
09:50:49 <mzero> there are duplicate modules for each
09:50:50 <otters> yeah I just realized that
09:50:56 <jonkri> barrucadu, lhs files? can you have text formatting and images with that?
09:50:57 <mzero> so Data.Text.IO if you want the non Lazy version
09:51:08 <otters> I don't
09:51:37 <barrucadu> jonkri: Yes. You can use whatever markup format you want outside of the code blocks - so you could use something like Markdown (or LaTeX) and have Pandoc generate HTML for you
09:52:03 <eisbaw> normally where is used to elaborate variables, but I can't get it to work with a function
09:52:06 <adnauseam> mauke, sepp2k: thank alot =]
09:52:40 <sepp2k> np
09:52:46 <jonkri> barrucadu, thank you, i'll look into it!
09:52:55 <adnauseam> i was over applying guards =p
09:52:56 <adnauseam> heh
09:53:50 <otters> okay so I saved 0.24 seconds switching to Text
09:54:05 <sepp2k> adnauseam: As a rule you can't use guards to cover cases that the pattern you're guarding already excluded
09:54:58 <adnauseam> sepp2k: learned that today. this took 30 minutes to actually figure out. i figured n would be the last element while ns would be empty, imagining a:[]
09:55:00 <merijn> The docs say that with GHC I need only define readPrec (instead of readsPrec) to implement Read, but when I don't define readsPrec the compiler complains...
09:55:06 <adnauseam> but aye no i see what really happens
09:57:37 <mzero> otters - but total time is still 7 sec?
09:57:47 <otters> 6.7s
09:57:52 <otters> yeah basically
09:58:04 <mzero> are we optomizing for fun now, or is this still too long for some other use --- and we have reason to believe it shoudl be faster
09:58:44 <otters> well, it's not a world-ender, but I'd like to get it down to around 3 seconds
09:59:31 <mzero> you're at 9µs per word there
09:59:42 <otters> no
09:59:44 <otters> *oh
10:00:02 <mzero> > 6.7 / 720000 * 1000000
10:00:03 <lambdabot>   9.305555555555555
10:04:38 <otters> @where forever
10:04:39 <lambdabot> I know nothing about forever.
10:05:00 <otters> is it weird that lambdabot doesn't know the standard library or is it just me
10:05:42 <Enigmagic> :t forever
10:05:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
10:05:44 <mauke> @index forever
10:05:45 <lambdabot> bzzt
10:05:49 <mauke> @hoogle forever
10:05:49 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
10:06:04 <mauke> otters: it's you
10:06:13 <otters> figured
10:06:58 <Taneb> How long should I wait for the hackage guy before I get worried?
10:07:07 <mauke> '@where' is an arbitrary factoid db
10:07:56 <mzero> Is the Hackage guy coming to install your packages?
10:08:36 <Taneb> The hackage guy is coming to send me an email saying I can have a hackage account
10:08:38 <mzero> otters: some back of the env. calc. with a CPU guy here points out that this is not unreasonable speed
10:08:43 <Taneb> You're thinking of the cabal guy
10:08:49 <otters> mzero: okay, good then
10:08:56 <mzero> since every prob. is essentailly a series of cache misses, since you have such a large dict.
10:09:03 <mzero> and cache misses are SLOW
10:10:49 <mzero> I think, otters, if you want further improvement, you'd need to alter the problem: Like require both lists to be sorted before you start
10:20:56 <adnauseam> if - is binary function, is a negative integer than a half-applied function ?
10:21:01 <roconnor_> >1978 + 35
10:21:02 <adnauseam> than\then
10:21:04 <roconnor_> > 1978 + 35
10:21:05 <lambdabot>   2013
10:21:16 <Taneb> adnauseam, - is special
10:21:21 <Taneb> Which annoys many people
10:21:39 <adnauseam> hrm
10:22:31 <adnauseam> graaah
10:22:37 <Taneb> > (- 3) 2
10:22:38 <lambdabot>   -3
10:22:45 <Taneb> > (subtract 3) 2
10:22:46 <lambdabot>   -1
10:25:59 <adnauseam> > ( + 3) 2
10:26:00 <lambdabot>   5
10:26:09 <adnauseam> *pulls at hair*
10:26:48 <Taneb> - is special, + isn't
10:26:53 <nyingen> how is (- 3) 2 being parsed?
10:27:10 <adnauseam> > (- (-3) 2)
10:27:11 <lambdabot>   3
10:27:28 <Taneb> The negative number "-3", applied to the number "2"
10:27:36 <nyingen> you can apply numbers to numbers?
10:27:44 <Taneb> Only in lambdabot it seems
10:27:50 <mauke> everywhere
10:27:56 <adnauseam> > + 3 3
10:27:57 <lambdabot>   <no location info>: parse error on input `+'
10:27:58 <c_wraith> :t 3
10:28:00 <lambdabot> forall t. (Num t) => t
10:28:09 <adnauseam> > (+ 3) 3
10:28:10 <lambdabot>   6
10:28:11 <c_wraith> If there's an instance of Num for functions....
10:28:12 <bitonic> > 3 3
10:28:13 <lambdabot>   3
10:28:19 <bitonic> mauke: ^^^ that's caleskell only
10:28:20 <adnauseam> it gets applied only if it gets bound to a function
10:28:27 <mauke> bitonic: no
10:28:37 <adnauseam> so numbers, then, can not be applied to numbers
10:28:39 <bitonic> mauke: that instance is in the HP?
10:28:42 <mauke> bitonic: no
10:28:44 <lamefun2> is there any game engine in Haskell?
10:28:44 <Taneb> > map 3 "hello"
10:28:45 <lambdabot>   [3,3,3,3,3]
10:29:06 <adnauseam> mapping 3 to 3 wouldn't do anything i'm guessing
10:29:11 <Taneb> lamefun2, http://www.haskell.org/haskellwiki/Applications_and_libraries/Games#Game_Engines_and_Libraries
10:29:15 <adnauseam> > map 3 3
10:29:16 <lambdabot>   No instance for (GHC.Num.Num [a])
10:29:16 <lambdabot>    arising from the literal `3' at <inter...
10:29:18 <bitonic> mauke: that's what I mean "caleskell only"
10:29:40 <mauke> bitonic: if something isn't in the Prelude, that doesn't automatically make it "Caleskell"
10:30:10 <adnauseam> well, that was a dumb test, but if i mapped 3 to a list of threes, i wouldn't be exactly applying a number to a number. it'd just be getting 3 items for each item in that list. it could be anything. in that sense, map is not a numeric operation
10:30:16 <Taneb> > map 'a' "hello"
10:30:17 <bitonic> mauke: it's not even in the HP. it's defined in lambdabot not in some external package
10:30:17 <lambdabot>   Couldn't match expected type `a -> b'
10:30:17 <lambdabot>         against inferred type `GHC.Ty...
10:30:31 <Taneb> > map [] "hello"
10:30:32 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
10:30:54 <bitonic> mauke: that makes it caleskell to me
10:30:56 <mauke> bitonic: ok, now I'm not sure what you mean by "HP"
10:31:12 <bitonic> mauke: haskell platform
10:31:19 <mauke> oh
10:35:11 <mauke> bitonic: no, that instance is from vector-space
10:35:45 <bitonic> mauke: oh well, ok.
10:57:11 <kallisti> edwardk: do you have any packages relevant to boolean algebras?
10:58:17 <edwardk> kallisti: not really. i used to have a boolean ring lying around in http://hackage.haskell.org/packages/archive/monoids/0.1.36/doc/html/Data-Ring-Boolean.html but nothing for algebras per se
11:00:25 <Taneb> > 22.53 + 2.8
11:00:26 <lambdabot>   25.330000000000002
11:00:29 <Taneb> Weird, huh?
11:00:53 <kallisti> > 22.53 + 2.8 :: CReal
11:00:54 <lambdabot>   25.33
11:01:37 <strager> Yay, floating point arithmetic =]
11:03:52 <navaati> :i CReal
11:04:14 <navaati> 1/3 :: CReal
11:04:17 <navaati> > 1/3 :: CReal
11:04:19 <lambdabot>   0.3333333333333333333333333333333333333333
11:04:33 <navaati> what is this CReal stuff ?
11:04:44 <kallisti> awesomeness
11:04:50 <kallisti> :t showCReal
11:04:51 <lambdabot> Int -> CReal -> String
11:05:02 <kallisti> > last $ showCReal 1000 pi
11:05:03 <lambdabot>   '9'
11:05:03 <navaati> ah, interesting !
11:05:15 <kallisti> > showCReal 1000 pi
11:05:16 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
11:05:35 <navaati> like Integer for reals ?
11:05:41 <kallisti> not quite.
11:05:45 <kallisti> that would be something like Decimal
11:06:15 <kallisti> I honestly don't know much about it. I've only browsered the source code once, and I don't know how real numbers are constructed.
11:06:51 <fmap> Isn't there a "how many times ~/.cabal and ~/.ghc were wiped"-counter in cabal?
11:07:07 <kallisti> there should be.
11:07:28 <navaati> in which package it is ?
11:07:37 <kallisti> numbers I think.
11:07:41 <kallisti> Data.CReal
11:07:44 <kallisti> @hoogle Data.CReal
11:07:45 <lambdabot> No results found
11:07:55 <kallisti> @hoogle Data.Number.CReal
11:07:55 <lambdabot> No results found
11:07:59 <kallisti> that's where it's at
11:08:00 <c_wraith> CReal is a function
11:15:41 * hackagebot cond 0.0.2 - Basic conditional and boolean operators with monadic variants.  http://hackage.haskell.org/package/cond-0.0.2 (AdamCurtis)
11:25:25 <lispy> fmap: cabal-dev makes that counter stay at zero, FWIW
11:26:39 <fmap> lispy: that's cheating
11:27:15 <jonkri> what data constructor do you use for Error instances when no specific constructor makes sense? :)
11:27:20 <kallisti> edwinb: I'm looking on inspiration for what to add to https://github.com/kallisti-dev/cond/blob/master/src/Control/Cond.hs
11:27:33 <bitonic> is there a way to use ghc-mod with the packages listed in the .cabal file?
11:27:49 <kallisti> I'm thinking about having a seperate module with a Boolean typeclass (similar to AC-Boolean), with all of the same functions but overloaded on Boolean.
11:28:10 <kallisti> *separate   also considering adding some of the Monoid, Arrow, and Category conditionals from bool-extra
11:39:16 <danr> kallisti: I think it could help to call the branches t and f rather than a and b? And also, this operator: http://hpaste.org/66356
11:40:04 <kallisti> ah yeah, that would be good.
11:40:27 <kallisti> maybe call it $?
11:40:43 <kallisti> since there's already ?? and having ? as well might be a little confusing.
11:41:04 <danr> maybe :)
11:41:09 <kallisti> that would be a very useful combinator for chains of composition.
11:41:22 <danr> some people like a curried if' as well
11:41:33 <danr> Bool -> (a,a) -> a
11:41:44 <danr> i'm not really a fan of it thoguh
11:42:47 <kallisti> ? is good I guess.
11:42:59 <kallisti> you're programming in Haskell; you're not allowed to get confused by operators.
11:43:20 <kallisti> well, actually.
11:43:35 <kallisti> I am still trying to figure out a viable syntax/representation for a ternary conditional operator
11:43:44 <kallisti> and ? is a potential candidate, for obvious reasons.
11:45:34 <kallisti> maybe something like ?.
11:45:36 <kallisti> ????
11:46:36 <strager> foo ?? bar ?: baz  C-style
11:46:55 <kallisti> right
11:47:03 <kallisti> but which part of the operator should be reified?
11:47:20 <kallisti> my intuition leads me to say that it should be like:  data ThenElse a = ThenElse a a
11:47:25 <kallisti> then (?:) = ThenElse
11:47:38 <kallisti> unless I'm missing some other way to do it.
11:47:53 <kallisti> I guess with functions.
11:48:03 <strager> Well think about nesting.
11:48:12 <strager> foo ?? bar ?: baz ?? qix ?: confusing
11:48:20 <strager> => foo ?? bar ?: (baz ?? qix ?: confusing)
11:48:26 <byorgey> that's confusing in C too.
11:48:33 <strager> Not if it's indented properly
11:48:39 * byorgey disagrees
11:49:13 <monochrom> I just add more parentheses
11:49:17 <kallisti> also for completeness I can go ahead and use Category instead of Prelude..
11:49:29 <kallisti> regarding ?. (which I guess is what I'll call it because it makes the most sense)
11:49:33 <strager> So I think that definition says ?? and ?: must be at the same level of precedence and be infixr
11:49:43 <monochrom> but really it should be shown as a tree not a line of text
11:49:59 <strager> monochrom: Right
11:50:58 <kallisti> hm, I could redefine select to be for Categories as well.
11:51:07 <kallisti> but then it's just a special if'
11:51:09 <kallisti> so that's silly.
11:51:43 <kallisti> oh wait, nevermind.
11:51:51 <monochrom> Tony Hoare likes to use this notation: "x ⊲ b ⊳ y" for "if b then x else y"
11:51:52 <kallisti> it's not if' because the condition is also part of the category.
12:00:51 <mojo> hi all anyone have ever try to add new protocol to scapy tool ??
12:11:31 <kallisti> so I've got ?. for conditional category composition
12:11:49 <kallisti> and ?<> for conditional mappend.
12:12:08 <kallisti> (that's kind of a bad way to describe them; neither make use of composition or mappend)
12:20:43 * hackagebot geniplate 0.6.0.1 - Use template Haskell to generate Uniplate-like functions.  http://hackage.haskell.org/package/geniplate-0.6.0.1 (LennartAugustsson)
12:23:54 <byorgey> man, I really wish there was a way to have GHC show the intermediate steps in its constraint solving algorithm
12:24:18 <byorgey> I have an error saying "no instance for Foo blah" and I haven't the faintest idea where the Foo constraint is coming from
12:25:29 <kallisti> sounds like something from the Example.Typeclasses module.
12:25:31 <kallisti> >_>
12:25:42 <kniu> so right now Haskell has open type-level functions, open functions from types to values, and closed value-level functions
12:25:56 <kniu> and it kind of has closed functions from types to values in the form of GADTs
12:26:19 <kniu> what would a closed type-level function be useful for?
12:26:35 <kniu> also, what's an open value-level function good for?
12:27:06 <kallisti> aren't typeclass methods open value-level functions?
12:27:41 <byorgey> no, the typeclass methods themselves are not open.
12:28:04 <byorgey> kniu: open value-level functions would be weird, since the set of values of a given type is always closed.
12:28:23 <byorgey> open type-level functions make sense because the set of types is open.
12:28:38 <byorgey> i.e. you can always define new types.  But you can't add new values of a given type.
12:29:05 <kniu> yes but what if that weren't the case, is what I'm asking
12:29:14 <kniu> what would open types be used for?
12:29:30 <byorgey> well, you could, say, extend an existing algebraic data type with new constructors
12:29:44 <byorgey> the problem is that any existing functions on that type would now crash if you gave them the new constructors
12:30:17 <byorgey> whereas at the type level, if you give a new type to an existing type-level function it just gets stuck.
12:30:21 <byorgey> which is not a big deal.
12:30:27 <kniu> Haskell allows non-exhaustive pattern matching anyway
12:30:33 <kniu> treat that case the same
12:30:37 <byorgey> yes, it's true.
12:31:16 <byorgey> I mean, it's not hard to imagine how such an extension could work.  I'm just saying I think the costs would outweigh the benefits.
12:32:00 <byorgey> kniu: closed type-level functions could be quite useful though.
12:32:45 <kniu> byorgey, for what?
12:32:48 <byorgey> for example, if you declared a type-level function closed it might allow the compiler to prove that it is injective
12:33:06 <byorgey> and then you could decompose equalities of the form  f a ~ f b  into   a ~ b
12:33:09 <nihtml> @type Data.List.genericLength
12:33:10 <lambdabot> forall b i. (Num i) => [b] -> i
12:33:24 <kniu> huh
12:33:24 <kniu> that's interesting
12:33:27 <DanBurton> Random question: does anyone know where I can find that parameterized version of "And then there's Haskell"?
12:33:30 <byorgey> right now if you want an injective type function you have to use a data family, which is annoying
12:36:46 <Mathnerd314> Haskell also has a closed function from values to types
13:18:23 <kallisti> are there any typeclasses for Categories with a notion of "application"?
13:23:28 <Mathnerd314> Applicative (C a) ?
13:24:52 <kallisti> not quite what I had in mind.
13:26:10 <Mathnerd314> (.) on C () a ?
13:34:09 <nus> @src (<<<)
13:34:09 <lambdabot> f <<< g = g >>> f
13:35:23 <hayashi> In trying to write a function to return table names in both databases in a database pair, I accidentally ran intersect inside the list applicative context.  The resulting table names included: rec_laelueue re_abeee re_labelee r_labluu auu rebeee eaeee eeee eeee  rec_laelee _auu ec_eee re_lelee eaeee _ rec_beee rec_eee rec_ocatonoo _oaioooup rec_ocatiooou re_loationloop rccat e_latilp looloo re_ap _latinlp _oaooop elotionloo
13:36:00 <hayashi> I wish my databases included tables named looloo and elotionloo.
13:36:03 <otters> @src (>>>)
13:36:04 <lambdabot> Source not found. You type like i drive.
13:36:12 <byorgey> hayashi: hahahaha =)
13:36:16 <monochrom> hehe
13:47:00 <Kaide> is there something out there that gives a local implementation of hoogle?
13:47:15 <luite> yes, hoogle
13:47:58 <Kaide> ah I see
13:48:01 <Kaide> cabal install hoogle?
13:48:07 <luite> (seriously, if you cabal install it, you get a hoogle executable that can be run as a web server)
13:48:26 <luite> yes
13:48:41 <luite> only tricky thing is that you need to build the hoogle database for your packages
13:49:30 <luite> i use some bash script to build the index for all packages in the ghc-pkg db
14:06:18 <kallisti> but really...
14:06:45 <kallisti> why is there no generalization of filterM to either traversable or foldable (I'm not sure which one would fit best)
14:07:43 <kallisti> maybe it's not possible with more information?
14:07:48 <kallisti> *without
14:07:56 <Jed_84> hi all
14:08:13 <kallisti> hey
14:08:32 <Jed_84> I'm using the Hugs interpreter to do some school work (please don't tell me to use GHCI instead :-)) and I can't find a way to declare variables in Hugs' prompt
14:08:40 <Jed_84> for instance, let x = 1 produces an error
14:08:55 <shachaf> Jed_84: I don't think you can do that in Hugs?
14:09:03 <shachaf> Maybe you should use ghci instead.
14:09:11 <Jed_84> thanks and i wish i could
14:09:12 <Jed_84> :)
14:09:48 <Botje> Jed_84: then you can't.
14:09:54 <Botje> put your declarations in a .hs file and load that
14:09:58 <Jed_84> that's what I thought
14:10:01 <Jed_84> yeah, i'll probably do that
14:10:02 <Jed_84> thanks Botje
14:13:08 <Kaid> No instance for (Functor (IOSLA (XIOState s0) b0))
14:13:09 <Kaid> =/
14:14:04 <Kaid> how did HXT manage to make it so that readDocument [] "foo.xml" does not give you a functor
14:15:53 <byorgey> Kaid: well, you're supposed to use the Arrow interface
14:16:08 <byorgey> though it could be made an instance of Functor, I suspect the omission is just an oversight
14:17:25 <Kaid> okay so so I'll just use >>^ then?
14:17:38 <Kaid> that'll achieve the same end?
14:18:27 <byorgey> yes, I think so
14:20:48 * hackagebot paragon 0.1.12 - Paragon  http://hackage.haskell.org/package/paragon-0.1.12 (NiklasBroberg)
14:21:39 <lamefun2> class Monad m where  (>>=)  :: m a -> (a -> m b) -> m b     --- so it has an operator that takes some mystical "m a" and a function that turns something of type a to "m b" and returns "m b". what are those "m a" and "m b"?
14:22:06 <shachaf> lamefun2: They're values.
14:22:18 <shachaf> m is the Monad instance, a is its argument.
14:23:04 <shachaf> Maybe you should read some more about type classes etc. before going to this definition -- it can be a bit confusing. :-)
14:23:07 <shachaf> See the FAQ:
14:23:08 <shachaf> @where faq
14:23:08 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
14:23:44 <lamefun2> like in data Vector r = Vector r r where r is some type?
14:23:56 <ezyang> Can anyone tell me how modern FRP deals with updates to purely functional data structures?
14:24:22 <Kaid> @instances XIOState
14:24:22 <lambdabot> Couldn't find class `XIOState'. Try @instances-importing
14:24:29 <Kaid> @instances-importing XIOState
14:24:30 <lambdabot> Couldn't find class `XIOState'. Try @instances-importing
14:24:38 <ezyang> That is to say, say I have a source which contains a purely functional data structure. I want to update one leaf w/ path copying. Does everything get recalculated?
14:24:48 <ezyang> If I don't want to do it, then what?
14:29:10 <kallisti> > app ((+1), 2)
14:29:11 <lambdabot>   3
14:29:47 <Zedrikov> I have some problem with compiling gtk with cabal ("Only  <glib.h> can be included directly"). Is there a simple workaround not involving patching?
14:30:13 <kallisti> do you have gtk headers on your system?
14:31:26 <Zedrikov> It seems; at least /usr/include/gtk-{1.2,2.0,3.0} are populated.
14:33:16 <Zedrikov> and /usr/include/gtk-{1.2,2.0,3.0}/gtk/gtk.h exist
14:34:32 <kallisti> :>
14:34:42 <geekosaur> the "Only <glib.h>" error seems to be a thing with older code and the latest glib
14:42:19 <Zedrikov> So nobody has a simple workaround to run successfuly "cabal install gtk" with a recent glib?
14:49:38 <hpaste> scooty-puff pasted “Way to make this WeakIntMap less fragile?” at http://hpaste.org/68134
14:53:11 <scooty-puff> the "insert" requires the NOINLINE, otherwise the k is unboxed
14:53:41 <scooty-puff> and Tip cannot {-# UNPACK #-} !Key, otherwise it won't be heap allocated for updateWithKey
14:59:09 <LambdaDusk> are there any Parsec experts here? I have made a Jade parser: https://gist.github.com/2605850 but I can't figure out why it doesn't parse double lines properly (the testing parsings are in the second file)
15:11:39 <tertl5> types and programming languages is what im reading
15:11:48 <tertl5> got it on my kindle
15:15:41 <merijn> I'm trying to implement a custom read for lists of my datatype, I have an implementation of readListPrec, but I'm unsure how to make readList use it
15:16:24 <hpc> @hoogle readListPrec
15:16:25 <lambdabot> Text.Read readListPrec :: Read a => ReadPrec [a]
15:16:25 <lambdabot> Text.Read readListPrecDefault :: Read a => ReadPrec [a]
15:16:44 <dmwit> Generally speaking, I think it's considered best practice to leave the Read and Show instances as derived and write a pretty-printer/parser if you have other formats you want to read and write.
15:17:06 <kosmikus> dmwit: you've been looking for me? something about the zipper package?
15:17:18 <hpc> is the cabal-install repo still darcs, or did it really move to github?
15:17:19 <merijn> dmwit: Maybe, but I already implemented the things now so I want to know how to use them :p
15:17:27 <hpc> hackage says darcs, and darcs says github
15:17:34 <dmwit> kosmikus: Oh, I think kallisti was bamboozled by your package, and I was just checking if you happened to be around at the moment.
15:17:39 <dmwit> But if you want to tell me about it I'm all ears.
15:18:12 <dmwit> hpc: File a documentation bug. =)
15:18:17 <kosmikus> hpc: it's on github
15:18:26 <dmwit> kosmikus: (...I was also bamboozled, in case that wasn't clear. =P)
15:18:43 <kosmikus> dmwit: heh. do you have concrete questions?
15:18:55 <merijn> hpc, dmwit: No suggestions? :(
15:19:32 <kosmikus> hpc: is there any official reference claiming it's still a darcs repo?
15:19:34 <hpc> merijn: have you tested it by showing a list of your things?
15:19:47 <dmwit> merijn: I'm reading the documentation, give me a moment. =)
15:19:48 <hpc> kosmikus: hackage still says darcs
15:19:53 <merijn> hpc: Yes, my show implementation works
15:20:11 <kosmikus> hpc: hmm, let me check
15:20:31 <kosmikus> hpc: oh right, that's because the release was *before* I moved it to git
15:20:51 <kosmikus> it feels a bit strange to make a re-release just to fix the repository location
15:20:56 <dmwit> merijn: There's readPrec_to_S in Text.ParserCombinators.ReadPrec
15:21:31 <hpc> kosmikus: in theory, they could edit the .cabal file in-place
15:21:38 <hpc> but mostly, i was just confused
15:21:41 <kosmikus> hpc: it's evil, though :)
15:21:48 <dmwit> merijn: So, something like readList = readPrec_to_S readListPrec 0 -- ?
15:21:58 <kosmikus> hpc: I'm planning a cabal-install-0.14.2 in the not too distant future
15:22:16 <kosmikus> hpc: and the repository itself should tell you it has moved
15:22:47 <kallisti> there was a post on reddit for a library wishlist. Someone mentioned a backup library, and I think that's a project I could probably tackle.
15:22:50 <kosmikus> dmwit: the main problem in understanding "zipper" is, I think, to understand how the underlying multirec library works
15:23:10 <kallisti> I was wondering if anyone has any good resources, suggestions, or in general information on ways to go about such a thing.
15:23:18 <barq> Is there any miranda channel?
15:23:43 <merijn> dmwit: Hmm, compiles, but getting "no parse", so maybe I screwed up my parser
15:23:45 <kosmikus> dmwit: there's a small example in the zipper library, and there are examples as well as a paper referenced in multirec
15:24:00 <dmwit> Wonderful.
15:24:37 <hpc> kallisti: start with "cabal init", and get a username on hackage
15:24:48 <kosmikus> dmwit: I'm happy to make documentation improvements, but I'm afraid I have no time right now to just go and write an extensive tutorial. some advice on what's difficult (or, even better, pull requests), would be welcome.
15:24:57 <hpc> (i am still waiting on my username though, so be patient...)
15:25:02 <barq> Can I ask Miranda questions here?
15:25:28 <hpc> barq: perhaps in -blah
15:25:41 <dmwit> kosmikus: Well, even just a mention in the haddocks somewhere that there's an example to look at would help a lot. =P
15:25:42 <hpc> /join #haskell-blah
15:26:45 <kosmikus> dmwit: right. I'll try to fix this for the next release.
15:26:51 <dmwit> This example is quite enlightening, actually.
15:33:41 <jfischoff> kosmikus: dimwit: what package?
15:33:45 <jfischoff> dmwit:
15:33:55 <dmwit> ?hackage zipper
15:33:55 <lambdabot> http://hackage.haskell.org/package/zipper
15:34:35 <ion> What does | do?
15:34:42 <ion> Whoops, wrong channel.
15:34:45 <jfischoff> kosmikus: how does it compare to syz?
15:36:42 <kosmikus> jfischoff: syz is all based on Typeable
15:37:22 <jfischoff> kosmikus: yes, its not very type safe
15:37:58 <strager> @pl \(a, b) -> (a, f b)
15:37:59 <lambdabot> second f
15:38:05 <jfischoff> kosmikus:so zipper is better?
15:38:42 <hpaste> merijn pasted “readListPrec” at http://hpaste.org/68136
15:38:51 <kosmikus> jfischoff: I'm biased, of course :)
15:38:59 <merijn> Anyone that can help me debug that parser?
15:39:24 <kosmikus> jfischoff: a biased comparison from the other side can be found in Section 6.2.2 of the syz paper
15:39:35 <jpeeters> hi everyone
15:40:03 <jfischoff> kosmikus: doesn't mean your wrong :)
15:40:07 <kosmikus> jfischoff: I don't have a full comparison ready, I'm afraid, because syz came later.
15:40:13 <merijn> Somehow readPrec properly parses the datatype properly, but when I try to write readListPrec I apparently screw up
15:40:55 <jpeeters> did someone experienced llvm bindings here?
16:00:09 <kallisti> hpc: I have one of those.
16:00:11 <BMeph> wat
16:10:21 <applicative> barq: this is probably  as good as it gets for #miranda  I noticed a few questions showing up on StackOverflow
16:11:37 <Enigmagic> jpeeters: i use the llvm bindings, what's up?
16:13:28 <jpeeters> Enigmagic: I used LLVM with C++ a lot recently and I would like to try Haskell bindings but I cannot figure out how to make a simple example working… could you help?
16:13:37 <jpeeters> I have Haskell Platform installed on Mac
16:14:03 <Enigmagic> jpeeters: did you look at the examples here: https://github.com/bos/llvm/tree/master/examples ?
16:14:30 <jpeeters> no
16:22:53 <kallisti> I don't remember who linked me to that article on Tony Hoare's conditional choice operator
16:22:56 <kallisti> but thanks!
16:22:57 <jpeeters> Enigmagic: What are you using Haskell and LLVM for?
16:25:31 <tgeeky_> dmwit: hacking tonight?
16:27:35 <dmwit> tgeeky_: We'll see! I always make big promises to myself about weekends, but rarely deliver. =P
16:27:48 <tgeeky_> dmwit: plus, you know... dragons.
16:28:01 <tgeeky_> They pretty much sell themselves.
16:28:19 <dmwit> =)
16:29:34 <jpeeters> Enigmagic: do the bindings work with llvm-3.0?
16:29:56 <jpeeters> because I have a compilation error saying that a LLVM library is missing
16:30:18 <dmwit> Seems to use unification-fd we'll have to un-recursively-define Values.
16:30:21 <dmwit> That's mildly annoying.
16:31:50 <tgeeky_> dmwit: did you survey unification packages on hackage?
16:32:18 <tgeeky_> hehe, or is the population 1
16:32:51 <dmwit> Well, there's only one package in the Unification category.
16:33:20 <dmwit> Seems there's agum and cmu; let's see what they're about.
16:34:39 <dmwit> These don't really look applicable. So the population does indeed seem to be 1.
16:35:12 <tgeeky_> well, we do have an abelian group after the fact, but I don't see how that helps us :O
16:35:29 <dmwit> Wait, we do?
16:35:46 <dmwit> An abelian group on `Value`s?
16:40:12 <tgeeky_> dmwit: took me a sec to load it. heck no, not on Values. Am I confusing something again? The overall result of the language is "akin to" working in a field, then you can have an abelian group over a field. But this doesn't help us finish the project :O
16:42:33 <tgeeky_> dmwit: maybe it's time I read about what unification is/does
16:42:51 <dmwit> We need to do unification on Values. cmu and agum are for unification of things which happen to form a communitative monoid (resp. group). Values do not form a monoid (resp. group), so cmu and agum aren't helpful.
16:43:20 <dmwit> I think.
16:43:22 <dmwit> =P
16:44:33 <dmwit> I'm pretty confident of claims 1 and 3; claim 2 I'm not as sure.
16:46:08 <dmwit> So, in git, branches are refs. Are the refs to the first commit where things are being done differently, the last commit in a chain of differences, or the commit right before you start doing things differently?
16:46:37 <ezyang> The last commit in a chain
16:46:41 <ezyang> They're like pointers.
16:47:05 <dmwit> Okay; so I should think of branches as being somewhat mutable? If I continue my efforts on a branch, I should update the branch ref to point to my latest work?
16:47:14 <ezyang> They are very mutable
16:47:20 <dmwit> wonderful
16:47:28 <tgeeky_> they are the main mutable thing (other than tags)
16:47:31 <ezyang> To compensate, Git has a 'reflog', which stores all of the pointers
16:47:45 <ezyang> so if you accidentally nuke one, you can probably get it back
16:48:24 <dmwit> So, I have some changes to the current working copy not yet added to the index or committed. I want to throw them away, sort of, but in a principled, version-control way. So my plan is:
16:48:28 <dmwit> 1. create a new branch
16:48:32 <dmwit> 2. add to the index + commit
16:48:35 <dmwit> 3. update the branch
16:48:45 <tgeeky_> no
16:48:47 <dmwit> 4. check out a commit from before the change
16:48:54 <ezyang> 1. git checkout -b new-branch
16:48:54 <dmwit> Okay, so what's the right plan?
16:49:04 <tgeeky_> 1. create. 2. check out the branch., 3. add + commit. 4. checkout master again
16:49:06 <ezyang> 2. git commit -asm "some commit"
16:49:11 <ezyang> 3. git checkout master
16:49:12 <ezyang> done
16:49:16 <ezyang> Alternatively, you can just stash it.
16:49:35 <dmwit> Ah, I guess I didn't understand what checkout did. Interesting.
16:49:44 <ezyang> it doesn't do that, unless you pass it -b
16:49:48 <ezyang> "Git UI doesn't make sense"
16:50:04 <tgeeky_> that quote seems out of left field
16:50:19 <tgeeky_> dmwit: that' why i listed it in 4 steps, not three, because i didn't know about checkout -b
16:50:21 <shachaf> You can always "git branch new-branch" and then "git checkout new-branch".
16:50:28 <tgeeky_> ^^
16:50:48 <Mathnerd314> git dwiw ... - does what you want
16:50:49 <aristid> shachaf: why would you do that?
16:51:10 <shachaf> aristid: To understand what's going on.
16:51:22 <shachaf> Once you understand what's going on feel free to use shortcuts. :-)
16:51:25 <dmwit> This argument about one step vs. two isn't related to how wrong I was about checkout, by the way.
16:51:28 <aristid> shachaf: why not read the manpage for git-checkout for that purpose :P
16:51:52 <tgeeky_> dmwit: well we don't know what is in your head :O
16:52:07 <dmwit> Not until I tell you, no.
16:52:14 <dmwit> So I told you. =)
16:52:19 <tgeeky_> ;)
16:52:31 <aristid> dmwit: i don't think you actually know what is going on in your head, for the most part :)
16:52:42 <tgeeky_> dmwit: evidently this can be done with one command:
16:52:51 <tgeeky_> git stash branch this-is-a-new-branch
16:53:05 <dmwit> aristid: very likely
16:53:20 * dmwit git help stash
16:53:39 <dmwit> Thanks to all for the git help, by the way.
16:53:53 <shachaf> ezyang: Are you going to be in CA in the summer?
16:55:08 <ezyang> No, I'll be in Boston until end of summer.
16:55:34 <shachaf> Ah, OK.
16:57:04 <tgeeky_> dmwit: http://www-cs-students.stanford.edu/~blynn/gitmagic/  http://ftp.newartisans.com/pub/git.from.bottom.up.pdf  and http://git-scm.com/book <-- this used to be much better, I don't know where the community book is anymore.
16:57:32 <tgeeky_> dmwit: but this might be the best of all: http://ndpsoftware.com/git-cheatsheet.html#loc=stash;
16:57:44 <Mathnerd314> dmwit: perhaps you could extend unification-fd to use Generic?
16:58:06 <kallisti> monochrom: that's not the actual symbols used in Communicating Sequential Processes.
16:58:32 <dmwit> Mathnerd314: There's nothing quite like shaving a yak, is there?
16:58:48 <dmwit> I think I will choose not to use git stash.
16:58:58 <dmwit> It looks like it's best for things that you want to temporarily abandon.
16:59:04 <shachaf> git stash is great*.
16:59:06 <shachaf> * until it's not
16:59:07 <dmwit> I'm pretty confident that I want to permanently abandon my current changes.
16:59:16 <dmwit> So I will use the verbose version.
16:59:31 <shachaf> If you're just permanently abandoning them, you don't need to make a branch at all. :-)
16:59:49 <dmwit> note the "pretty" in "pretty confident"
17:00:02 <shachaf> Oh.
17:00:26 <shachaf> Anyway I think tgeeky_ was talking about "git stash branch".
17:00:27 <kallisti> confidence is a beautiful thing.
17:00:29 <tgeeky_> http://ndpsoftware.com/git-cheatsheet.html#loc=stash; <-- this is pretty awesome.
17:00:31 <shachaf> Which makes a new branch out of your stash.
17:00:51 <tgeeky_> kallisti: I was going to say that, too. One needs to feel the freedom to be fluid and stupid with tools like git... I guess it takes time.
17:01:45 <kallisti> man I really want to find a Unicode version of these symbols used in communicating sequential processes.
17:02:25 <kallisti> they're angle brackets with a vertical bar through the middle.
17:03:23 <parcs`> @hoogle <|>
17:03:23 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
17:03:23 <lambdabot> Text.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
17:03:23 <lambdabot> Text.ParserCombinators.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
17:03:41 <tgeeky_> parcs`: surely that's not what he meant?
17:03:46 <kallisti> heh
17:04:03 <parcs`> tgeeky_: what do you think i thought he meant
17:04:14 <tgeeky_> kallisti: http://shapecatcher.com/
17:04:32 <tgeeky_> i'm guessing 0x2222, 0x15c9,
17:04:33 <tgeeky_> maybe
17:04:37 <kallisti> but this relies on my ability to draw well...
17:04:54 <hpc> http://hpc.dyndns-web.com:8000/thirdparty/unicode.html
17:05:02 <parcs`> 0x2119 is nice
17:05:09 <parcs`> ⇹
17:05:52 * hackagebot usb 1.1.0.2 - Communicate with USB devices  http://hackage.haskell.org/package/usb-1.1.0.2 (BasVanDijk)
17:06:10 <kallisti> there's no arc to it.
17:06:22 <tgeeky_> kallisti: is it a sideways A?
17:06:30 <tgeeky_> kallisti: link to the original? :o
17:06:32 <kallisti> the bar continues above and below the angle bracket
17:06:38 <kallisti> there may be no symbol for it.
17:07:30 <tgeeky_> kallisti: yeah, that's what I drew (pretty well). and i didn't see any direct matches
17:07:32 <parcs`> ∢ ?
17:07:41 <parcs`> oh wait that's 0x2222
17:07:51 <kallisti> that's what monochrom used earlier
17:07:54 <kallisti> so maybe that's... it?
17:08:04 <adnauseam> i've an unrelated haskell q about lambda calc. in (λx.(λy. ∗ x z) y) y, is the x in (λy. ∗ x z) free? i think it is free. am  i wrong?
17:08:09 <tgeeky_> kallisti: *cough*
17:08:30 <kallisti> adnauseam: x is bound by a lambda
17:08:32 <ezyang> No.
17:08:35 <kallisti> so it's not free
17:08:38 <kallisti> z is free
17:08:44 <ezyang> but if you just had the latter, it would be free.
17:08:54 <adnauseam> all the x's are ?
17:09:06 <kallisti> any x within a lambda that binds the variable x is bound
17:09:14 <kallisti> if it's outside of a lambda that binds x, it's free.
17:09:16 <shachaf> adnauseam: In "(λy. * x z)", x and z are free. In the whole expression that you gave, the x isn't free (but the z is).
17:09:30 <Mathnerd314> kallisti: ⦉ ?
17:09:34 <parcs`> ᗆ
17:09:37 <adnauseam> perfect, that explain the confusion within this text then
17:09:46 <adnauseam> they're talking about different segments of the expression
17:10:07 <tgeeky_> parcs`: thats the first one I've seen on screen
17:10:13 <tgeeky_> I have UTF-8 enabled, too
17:10:16 <parcs`> ᐶ ᗌ
17:10:19 <adnauseam> thanks shachaf, Khisanth, ezyang
17:10:39 <kallisti> pictures speak a thousand words http://dl.dropbox.com/u/16495819/2012-05-05_20-07-45_1366x768.png
17:13:19 <parcs`> your battery is at 0%
17:13:36 <tgeeky_> parcs++
17:13:40 <kallisti> yes
17:13:58 <kallisti> it evaluates thunks for energy.
17:14:03 * kallisti seems legit.
17:14:42 <tgeeky_> kallisti: I guess that it is not unicode, or is a < with some sort of vertical strikethrough
17:14:58 <kallisti> ah well
17:15:06 <kallisti> I guess I can't please the Unicode enthusiasts then.
17:15:14 <kallisti> unless I settle with something else.
17:16:04 * kallisti is god-tier bike shedder.
17:17:50 <kallisti> parcs`: that's probably the cloest equivalent.
17:18:38 <kallisti> but it's a letter.
17:19:04 <parcs`> a _canadian_ letter
17:19:23 <kallisti> apparently.
17:21:17 <dmwit> ?ask jfischoff What editor do you use? You have large comment boxes with words inside denoting sections; does your editor have support for hiding/showing sections, or are you doing that yourself in wetware?
17:21:18 <lambdabot> Consider it noted.
17:21:41 <tomekk_> Hi, I was wondering how to print a tuple (hopefully, n-tuple) of strings just like ghci does it.
17:21:54 <kallisti> use show
17:22:02 <kallisti> ghci calls show on whatever it displays.
17:22:15 <kallisti> > show ("hello", "world")
17:22:16 <lambdabot>   "(\"hello\",\"world\")"
17:22:23 <tomekk_> kallisti: that prints out the quotes, which I don't want.
17:22:38 <kallisti> then you don't want to display it as ghci does.
17:22:41 <tomekk_> kallisti: Ideally, I'd like f ("hi", "world") = "(hi, world)"
17:23:12 <tomekk_> kallisti: Oh, you're right. Is it possible to do it the way I'd like?
17:23:22 <kallisti> sure.
17:23:29 <dmwit> f (a,b) = "(" ++ a ++ ", " ++ b ++ ")"
17:23:47 <dmwit> f (a,b) = printf "(%s, %s)" a b
17:23:49 <kallisti> or if you want to be super fancy you can use showChar and friends.
17:23:55 <tomekk_> dmwit: Unfortunately I'm dealing with pretty long tuples, so that would be a pain
17:24:19 <kallisti> why are you dealing with long tuples?
17:24:24 <kallisti> long tuples are usually bad.
17:24:48 <tomekk_> I'm using it in Debug.trace. I guess I could use lists; it probably doesn't matter
17:25:04 <kallisti> oh
17:25:50 <tomekk_> I really just want to annotate each of the values that I'm printing in trace. Right now that involves trace $ show ("x", x, "y", y, ...)
17:26:09 <kallisti> @hoogle text
17:26:09 <lambdabot> System.IO data TextEncoding
17:26:09 <lambdabot> GHC.IO.Encoding.Types data TextEncoding
17:26:09 <lambdabot> GHC.IO.Encoding data TextEncoding
17:26:13 <kallisti> :t text
17:26:14 <lambdabot> String -> Doc
17:26:16 <kallisti> @hoogle String -> Doc
17:26:17 <lambdabot> Language.Haskell.TH.Ppr pprString :: String -> Doc
17:26:17 <lambdabot> Language.Haskell.TH.PprLib ptext :: String -> Doc
17:26:17 <lambdabot> Text.PrettyPrint.HughesPJ ptext :: String -> Doc
17:26:24 <kallisti> > text "hello"
17:26:25 <lambdabot>   hello
17:26:32 <kallisti> > map text ["hello", "world"]
17:26:33 <lambdabot>   [hello,world]
17:26:43 <tomekk_> wow
17:26:52 <kallisti> from Text.PrettyPrint.HughesPJ
17:27:17 <tomekk_> Cool! Thanks so much
17:28:12 <hpc> @hoogle [String] -> String -> String
17:28:13 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
17:28:13 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
17:28:13 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
17:32:45 <parcs`> dmwit: that sounds like vim folds
17:32:58 <dmwit> Yes, I use vim folds extensively.
17:33:18 <dmwit> I was just wondering whether replacing his huge blocks with vim folds would reduce his editor's coping mechanism.
17:33:22 <dmwit> If so, I don't want to do that.
17:33:44 <adnauseam> vim folds? :o
17:34:03 <adnauseam> oh za
17:34:20 <dmwit> adnauseam: :help fold.txt
17:34:48 <kallisti> I feel like I should probably wait longer than a day before releasing another version of cond. :P
17:35:05 <dmwit> Release often!
17:35:41 <kallisti> I can't deny your logic.
17:38:08 <dmwit> hm
17:40:55 <blackdog> kallisti: i tend to feel that until you have a heap of users who'll be annoyed by constant updates, you might as well release as often as you have useful changes.
17:42:34 <shachaf> If you have a heap of users then at least it's easy to tell which ones are the most important.
17:44:39 <kallisti> blackdog: yeah there doesn't seem to be any harm.
17:45:15 <kallisti> I update lots of packages with zero userbase and no one writes angry emails. :P
17:45:24 <blackdog> kallisti: maybe don't gratuitously break the PVP :)
17:45:48 <blackdog> what were the general thoughts on scott kilpatrick's proposal for semantic packages, btw?
17:47:39 <blackdog> i really like the idea of type-driven packages - we have a type checker, we might as well use it.
17:57:41 <Chris_> hi
18:04:26 <monochrom> @tell kallisti no, not CSP of course. just plain conditionals in imperative programming. see the book Unifying Theories of Programming
18:04:26 <lambdabot> Consider it noted.
18:04:37 <kallisti> monochrom: hi
18:04:37 <lambdabot> kallisti: You have 4 new messages. '/msg lambdabot @messages' to read them.
18:05:27 <kallisti> monochrom: I meant the notation
18:05:29 <kallisti> not the semantics.
18:05:41 <kallisti> I'll look at that then
18:08:54 <monochrom> yes, I mean the notation too.
18:25:55 * hackagebot cond 0.1 - Basic conditional and boolean operators with monadic variants.  http://hackage.haskell.org/package/cond-0.1 (AdamCurtis)
18:26:52 <augur> what should i read for a good introduction to (simple) subtyping?
18:27:06 <augur> probably TTFP or that other one
18:43:50 <Ralith> TAPL
18:59:40 <kallisti> the join/part spam is intense.
19:01:10 <Plex-> what is the purpose of Functor? to create a uniform interface for mapping?
19:02:46 <Mathnerd314> kallisti: conference mode?
19:03:21 <ion> kallisti: You can configure your client to hide it.
19:05:19 <parcs`> what join/part? :)
19:07:42 <rasfar> yeah, lispy pointed out that you can hide it (can in xchat at least), and it's quite a relief
19:10:09 <rasfar> sometimes when really bored i turn it back on though
19:10:46 <ion> In WeeChat you can toggle their visibility with meta-=
19:10:56 <ion> retroactively, too
19:13:27 <Axman6> Plex-: you can think of it as that yes. that's pretty much essentially what it is
19:14:15 <Plex-> ah ok, thanks. I was wondering what could possibly be the point of it, since just any old function could do that for other types
19:15:31 <Axman6> @instances Functor
19:15:32 <lambdabot> ((,) a), ((->) r), ContT r m, Either a, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
19:16:15 <kallisti> ion: I know I know
19:17:28 <Axman6> Plex-: all type classes are is just a bunch of normal functions
19:33:29 <ezyang> Does anyone know of research into automatically deriving imperative versions of purely functional data structures?
19:41:22 <mgsloan> ezyang: I haven't read very many papers about this stuff (in general) - an undergrad myself - but, it seems like that would almost fall under strictness analysis / region inference.  In other words, going imperative / manual memory management is equivalent to optimization
19:42:27 <mgsloan> unless you mean fully imperativizing data structures, like turning list zippers into gap buffers, or something like that
19:42:41 <ezyang> Fully imperativizing.
19:42:57 <mgsloan> Seems like a very ambiguous problem
19:43:19 <mgsloan> you'd always end up losing the sharing properties
19:43:40 <ezyang> OK, let's restrict it.
19:44:01 <ezyang> We only care about operations of the form T -> T, and you're only allowed to compose these together.
19:44:09 <ezyang> so no referring to the past.
19:45:01 <kallisti> just put everything in an IORef. problem solved. :P
19:45:11 <ezyang> kallisti: That doesn't buy very much :-)
19:45:27 <ezyang> For example, there is an obvious and efficient transformation for fmap.
19:46:12 <ezyang> For BST like structures insert and delete translate reasonably well between mutable and immutable realms.
19:46:20 <kniu> statically infer that the 'previous' T isn't used anymore and would be garbage collected anyway, then compile it so that the 'new' T is written into there, assuming all Ts have the same size
19:46:33 <mgsloan> yeah, region inference!
19:46:52 <ezyang> kniu: But that's not true, there may be sharing going on.
19:47:04 <kniu> what sharing?
19:47:06 <ezyang> i.e. path copying
19:47:18 <kniu> if it's shared, it can't be GCd
19:47:19 <mgsloan> computing (T -> T) may involve sharing
19:47:28 <rwbarton> you mean sharing between the old and new values?
19:47:34 <ezyang> yeah
19:47:35 <kniu> oh that?
19:47:37 <ezyang> mgsloan: Right.
19:47:53 <kniu> would still fall under the notion of "isn't used anymore"
19:47:53 <ezyang> mgsloan: So add the further constraint: all values are used *linearly* within the function.
19:48:03 <ezyang> I don't know if linearity inference is decidable
19:48:56 <kniu> why not just treat all functions as linear, and see where linearity is being violated?
19:49:39 <ezyang> OK, if I do the GC approach I still end up paying log n.
19:49:39 <kniu> basically, run a linear type checker first, annotate non-linear terms, then run the normal type checker, and then compile using the annotations
19:49:44 <mgsloan> ezyang: it might not be.. but certainly a conservative linearity is decidable
19:49:52 <ezyang> in the case of, say, insert on a BBST
19:50:33 <ezyang> Now, what I'd /really/ like to do is observe that that I can use the memory from the old allocated Node for the new allocated node.
19:50:44 <kniu> ezyang, by 'GC approach' what do you mean?
19:51:12 <ezyang> As in, imperativize the structure by giving it it's own memorybox and GC.
19:51:30 <kniu> instead of deleting unused memory, see whether any functions want to return anything of the same type and size as the GC'd value, and recycle that memory?
19:51:51 <mgsloan> it would be /really/ cool to be able to generate an "imperativized" strict version of a data structure and its ops, and convert between the two as desired / decided by the RTS / profiled
19:52:26 <mgsloan> (of course the issue with this not being in the Type would be that you'd use typeclass dispatch for everything..)
19:52:38 <mgsloan> errr not typeclass dispatch
20:03:15 <quuxman> does anybody have a working example that takes midi signals and sends them to SuperCollider to generate sound?
20:03:29 <quuxman> I remember writing a basic version of this, but I can't find it
20:06:13 <quuxman> ahah, the supercollider-midi looks like it. I love the fact that there are example programs in hackage
20:07:06 <andrus> Has anyone gotten the CloudHaskell examples to work when running nodes on different hosts?
20:08:12 <dmwit> Are there any monad transformer transformers?
20:08:33 <drdo> andrus: I didn't try the examples provided, but i did play around with it and it worked
20:09:44 <andrus> drdo: you tested on multiple machines?
20:10:09 <drdo> andrus: Yes
20:10:24 <drdo> Both on the same lan and across the ocean :P
20:10:31 <drdo> andrus: What trouble are you having?
20:10:55 <andrus> It looks like getPeers never returns
20:11:30 <andrus> drdo: I'm using a config file listing all known hosts and specifying role and hostname for each node
20:11:56 <drdo> andrus: Sorry i can't be of more assistance, i've never experienced such thing
20:13:02 <andrus> drdo: hmmm, well you give me hope...
20:13:09 <dmwit> ?unmtl StateT t m a
20:13:10 <lambdabot> t -> m (a, t)
20:14:22 <andrus> I'm getting a ConfigException after a long timeout, "Can't talk to local node registry". I'll try to dig back into this
20:14:47 <drdo> andrus: I never looked into how that worked
20:15:00 <drdo> But there's some mechanism for peer discovery
20:15:38 <quuxman> what exactly does this error mean? cabal: The pkg-config package alsa version >=1.0.14 is required but it could
20:15:42 <quuxman> not be found.
20:15:42 <drdo> That's not it though i guess, local node registry sounds like the analog of erlang's epmd i guess
20:16:07 <quuxman> I figure I need some sort of -dev package installed, but I don't really have any clue which one. I can't actually find any alsa*-dev or libalsa*-dev package
20:17:38 <dmwit> Well, for what it's worth, the package is called alsa-lib here.
20:18:30 <dmwit> (One of the consequences of decentralization is that all conventions will eventually be ignored by somebody.)
20:20:36 <quuxman> ah, the package is libasound2-dev here
20:34:43 <ezyang> Does anyone happen to know how much sharing in between updates red black trees tend to get?
20:35:51 <andrus> drdro: so i should have made sure the listen port for each host was accessible to the other hosts, d'oh!
20:36:56 <dmwit> ezyang: Quite a lot, I expect; the O(log n) operations ought to share O(n - log n) = O(n) nodes, no?
20:37:28 <dmwit> (Or is that not your question?)
20:38:06 <ezyang> What about rotations?
20:38:17 <dmwit> What about them?
20:38:21 <ezyang> Maybe rotations are sufficiently local that you do OK.
20:38:27 <dmwit> You're still only affecting O(log n) of the nodes.
20:38:30 <ezyang> What about if I prune off a large range?
20:38:44 <ezyang> e.g. subtree deletion
20:38:54 <dmwit> Dunno about that one.
20:39:04 <kallisti> ezyang: speaking of which, what's the best way to go about that?
20:39:16 <kallisti> (subtree deletion)
20:39:23 <kallisti> using Data.Tree
20:39:34 <ezyang> Well, it's a bit of an abstraction violation so I'm not surprised if Haskell's implementations don't have 'em
20:39:41 <rwbarton> it's still true that if the operation takes O(log n) time, then the resulting tree must share all but O(log n) nodes with the input (as otherwise where did they come from?)
20:39:44 <tgeeky_> ezyang: http://stackoverflow.com/questions/5665212/deleting-a-whole-subtree-of-a-red-black-tree-would-keep-its-properties
20:39:48 <ezyang> What I'd expect is if I delete a range, I'll need to do a lot of rebalancing
20:40:17 <ezyang> Heh, the accepted answer is "iterate or rebuild"
20:40:32 <dmwit> rwbarton: What I meant was I didn't know if there was an O(log n) algorithm for pruning a large range. =)
20:40:38 <ezyang> I like the split/join answer better :-)
20:40:52 <ezyang> That's pretty fancy.
20:44:01 <kallisti> the monad instance for Data.Tree is kind of weird.
20:44:59 * kallisti would expect more operations to be exported.
20:51:31 <kallisti> in fact I don't see any way to do general subtree deletion with Data.Tree
20:51:36 <kallisti> you can only do it with Forests
20:51:47 <kallisti> otherwise you have to return a Maybe (Tree a)
20:51:51 <kallisti> in the case that the root is deleted.
20:52:12 <tgeeky_> kallisti: just make sure you change the root before you delee things/
20:52:14 <tgeeky_> delete*
20:52:33 <kallisti> what do you mean?
20:53:05 <tgeeky_> can't you rotate the whole tree in some way, such that the old root isn't the new root?
20:53:48 <kallisti> no, because then it's not the same tree. :P
20:54:01 * kallisti is talking about something unrelated to the prior topic.
20:54:02 <tgeeky_> well, nor is the result of deleting half of it? :O
20:54:07 <tgeeky_> oh
20:54:17 <kallisti> my trees represent directories in a filesystem
20:54:23 <kallisti> so.. rotating is no. :P
20:54:43 <tgeeky_> kallisti: ah, ok. I remember you discussing that last night. I was the person who mentioned 'forest'
20:54:56 <kallisti> right.
20:55:25 <tgeeky_> kallisti: i happen to think that an interface to files/directories using forests will really be helpful, instead of direct file access liek we always do now
20:55:28 <kallisti> so I could either  a) make my subtree filter operate on forests  b) have it return Maybe (Tree FilePath)
20:56:20 <kallisti> I'll go with Forest, because it's not too bad to work around in the common case where you only have one tree, the code is cleaner, and it does more.
20:56:32 <tgeeky_> kallisti: yeah. I think so.
20:57:01 <tgeeky_> kallisti: even in the case of a single directory as the root (say, $HOME)
20:57:17 <tgeeky_> kallisti: can't you always consider that to be the root of a tree, or that directory is a list of trees?
20:57:31 <kallisti> yeah
20:57:34 <tgeeky_> that is, .gnome, and .cabal, and .blah
20:57:39 <tgeeky_> yeah
20:57:40 <kallisti> currently my getDirectory functions return a Tree
20:57:49 <kallisti> where the root is the original FilePath argument
20:57:55 <tgeeky_> then you are sort of obliged to use forests anyway, because otherwise you're making decisions for your users that you shouldn't make
20:59:03 <ezyang> :-( West Point appears to have GC'ed Chris Okasaki's research website.
21:00:37 <hpaste> kallisti pasted “why is this not already in the Data.Tree module?” at http://hpaste.org/68142
21:00:56 <kallisti> oh crap I didn't actually typecheck that. :
21:00:57 <kallisti> P
21:02:37 <hpaste> kallisti annotated “why is this not already in the Data.Tree module?” with “why is this not already in the Data.Tree module? (annotation)” at http://hpaste.org/68142#a68143
21:02:45 <kallisti> I'm just wondering why Data.Tree is so scant..
21:04:18 <kallisti> heh. Trees in computer science are fun; remove the root, and you get a forest.
21:05:16 <dmwit> Is there an extension that implies all of DeriveGeneric, DeriveDataTypeable, DeriveFunctor, DeriveTraversable, DeriveFoldable, etc.?
21:05:44 <kallisti> does StandaloneDeriving perform all of this magic?
21:05:59 <kallisti> otherwise: I dunno
21:06:45 <dmwit> Unfortunately, no.
21:07:35 <kallisti> what exactly is "right" and "left" in terms of trees?
21:07:39 <kallisti> regarding folds
21:09:42 <dmwit> kallisti: I would imagine you'd want pre-order and post-order folds rather than left- and right- folds.
21:10:15 <kallisti> yes
21:10:37 <drdo> kallisti: The cool thing about using left and right is that there's almost always two points of view :P
21:10:59 <dmwit> fold :: (a -> [b] -> b) -> Tree a -> b -- ?
21:12:28 <dmwit> I don't think associativity makes as much sense for tree folds.
21:12:32 <dmwit> Because they're not linear.
21:32:17 <kallisti> so I've generalized filterPaths
21:33:12 <kallisti> now there's extractPaths, which takes a predicate and a forest, and returns a tuple of 2 forests The first forest contains the tree with all of the false subtrees removed
21:33:17 <kallisti> the second forest is a list of all the removed subtrees
21:33:49 <kallisti> then filterPaths is just the same thing but with the first element returned.
21:33:54 <ezyang> Hmm, I wonder how you would define a tree data type which would also support subtree information
21:35:12 <dmwit> kallisti: Shouldn't the second thing be more than just the removed subtrees?
21:35:19 <dmwit> Like, a path and a subtree or some such thing?
21:35:26 <dmwit> FSV of "should"
21:35:48 <kallisti> why a path?
21:36:12 <dmwit> Because not all removed subtrees occur at the root node(s).
21:36:22 <kallisti> well, yes.
21:36:39 <kallisti> but each node has the parent paths prepended to it
21:36:43 <kallisti> so all the information is still present.
21:37:35 <kallisti> this might be useful if you want to exclude some directories from an operation
21:37:40 <kallisti> but still doing something with them as a special case.
21:37:58 <dmwit> Oh, this is explicitly for FilePath-labeled trees.
21:38:38 <kallisti> yes.
21:38:49 <kallisti> much of it could be generalized.
21:38:54 <kallisti> but I'm writing with one purpose in mind.
21:39:09 <kallisti> (to make Haskell's currently filesystem operations suck a little less)
21:39:13 <kallisti> -ly
21:43:29 <kallisti> how similar is DList to constructing a binary tree of concatenations and then traversing it?
21:50:37 <kallisti> actually
21:50:40 <kallisti> a binary tree of cons operations
21:56:56 <lispy> hello
21:57:17 <Taneb> Hello
22:00:47 <kallisti> I wonder if it would be possible to have a filesystem in which you can "freeze" subtrees
22:01:13 <kallisti> so that you have a consistent snapshot of the directory and its children upon being frozen.
22:01:17 <kallisti> and to do that efficiently.
22:01:29 <geekosaur> snapshot capability is fairly common
22:02:04 <kallisti> oh. how is it done typically?
22:02:08 <blackdog> geekosaur: any journalled filesystem gives you that, doesn't it?
22:02:33 <Ralith> blackdog: pretty sure you need COW.
22:02:39 <geekosaur> depends.  most snapshotting is copy on write
22:02:39 <ion> In btrfs you can snapshot an entire subvolume, but AFAIU not an arbitrary subdirectory.
22:03:05 <geekosaur> which, in terms of unix filesystems, is a tweak to hard links
22:03:29 <kallisti> how do you typically access these operations?
22:03:44 <ion> With btrfs, the btrfs tool.
22:03:56 <Clint> (f.ex.) btrfs subvolume snapshot blah blah-snapshot
22:03:57 <geekosaur> I don'[t recall if BSD UFS2 does snapshots at tree level.  or for that matter ZFS
22:04:30 <Clint> zfs no
22:05:11 <ion> If it doesn’t need to be an atomic snapshot, you can run cp -a --reflink=always directory directory-snapshot-ish
22:07:15 <dmwit> ?hoogle (Foldable t, Alternative f) => (a -> f b) -> t a -> f b
22:07:16 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
22:07:16 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
22:07:16 <lambdabot> Data.Foldable mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
22:08:00 <dmwit> :t Data.Foldable.traverse
22:08:01 <lambdabot> Not in scope: `Data.Foldable.traverse'
22:08:34 * kallisti imagines ZFSFS
22:08:44 <kallisti> Zermelo-Fraenkel Set File System.
22:09:51 <dmwit> kallisti: Dunno about other file systems, but here at UPenn snapshotting is done with a kernel patch. =P
22:10:48 <kallisti> with snapshotting my lazy IO approach to directory trees would be slightly less dangerous.
22:11:06 <kallisti> but then, without snapshotting, basically any approach to recursive directory traversal is slightly dangerous.
22:11:18 <dmwit> ?hoogle Alternative f => [a] -> f a
22:11:19 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
22:11:19 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
22:11:19 <lambdabot> Test.QuickCheck.Gen elements :: [a] -> Gen a
22:17:09 <kallisti> isSymLink :: FilePath -> IO Bool
22:17:10 <kallisti> isSymLink p = isSymbolicLink <$> getSymbolicLinkStatus p
22:17:14 <kallisti> is there an easier way to do this?
22:17:32 <kallisti> I'm using System.Posix.Files
22:22:57 <mikeplus64> is there an operator equivalent to \f x -> f `ap` return x ?
22:23:19 <dmwit> :t \f x -> f `ap` return x
22:23:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> a -> m b
22:23:35 <dmwit> :t \f -> fmap (f$)
22:23:36 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:23:55 <dmwit> :t \f x -> fmap ($x) f
22:23:57 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
22:24:17 <mikeplus64> alright, thanks
22:24:33 <dmwit> :t ($x) <$> f
22:24:34 <lambdabot>     Ambiguous occurrence `f'
22:24:35 <lambdabot>     It could refer to either `L.f', defined at <local>:8:0
22:24:35 <lambdabot>                           or `SimpleReflect.f', imported from SimpleReflect at State/L.hs:73:0-32
22:24:56 <dmwit> :t flip (<$>) . flip ($)
22:24:57 <lambdabot> forall a b a1. a1 -> (a -> b) -> (a1 -> a) -> b
22:25:50 <dmwit> Probably not, but there's lots of ways to spell it. =)
22:26:14 <mikeplus64> > let f = return $ \x y z -> (x, y, z, x + y + z) in ($ 1) <$> ($ 2) <$> ($ 3) <$> f
22:26:16 <lambdabot>   No instance for (GHC.Show.Show (f (a, a, a, a)))
22:26:16 <lambdabot>    arising from a use of `...
22:26:32 <mikeplus64> > let f = return $ \x y z -> (x, y, z, x + y + z) :: Maybe a in ($ 1) <$> ($ 2) <$> ($ 3) <$> f
22:26:33 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a'
22:26:33 <lambdabot>         against inferred ...
22:26:34 <geekosaur> kallisti, that's a direct reflection of the standard API; it doesn't get simpler
22:26:50 <mikeplus64> > let f = return $ \x y z -> (x, y, z, x + y + z) :: Maybe (Int, Int, Int, Int) in ($ 1) <$> ($ 2) <$> ($ 3) <$> f
22:26:51 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe
22:26:51 <lambdabot>                             ...
22:26:57 <mikeplus64> lerp
22:27:55 <geekosaur> (lstat(path, &statbuf); S_ISLNK(statbuf.st_mode))
22:28:07 <kallisti> geekosaur: okay then
22:28:08 <mikeplus64> > let f = return $ \x y z -> (x, y, z, x + y + z) :: Maybe (Int -> Int -> Int -> (Int, Int, Int, Int)) in ($ 1) <$> ($ 2) <$> ($ 3) <$> f
22:28:09 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe
22:28:09 <lambdabot>                             ...
22:31:01 <mikeplus64> > let f = return (\x y z -> (x, y, z, x + y + z)) :: Maybe (Int -> Int -> Int -> (Int, Int, Int, Int)) in ($ 1) <$> ($ 2) <$> ($ 3) <$> f
22:31:02 <lambdabot>   Just (3,2,1,6)
22:34:30 <tgeeky_> let f = return (\x y z -> (x, y, z, x + y + z)) :: Maybe (Int -> Int -> Int -> (Int, Int, Int, Int)) in ($ 1) <$> ($ 2) <$> ($
22:36:16 <kallisti> @hoogle ($))
22:36:16 <lambdabot> Parse error:
22:36:16 <lambdabot>   ($))
22:36:16 <lambdabot>      ^
22:36:18 <kallisti> @hoogle ($$)
22:36:18 <lambdabot> Text.PrettyPrint.HughesPJ ($$) :: Doc -> Doc -> Doc
22:36:18 <lambdabot> Text.PrettyPrint ($$) :: Doc -> Doc -> Doc
22:36:18 <lambdabot> Language.Haskell.TH.PprLib ($$) :: Doc -> Doc -> Doc
22:38:49 <dmwit> Wow, how did cabal init know that?
22:39:25 <mikeplus64> cabal init is magical these days
22:40:33 <ion> dmwit: Know what?
22:41:03 <dmwit> It noticed modules in the src/ directory.
22:41:52 <tgeeky_> dmwit: you have to remember to expressly push your branches to your public github when ready
22:42:17 <tgeeky_> i often forget to do that :(
22:42:21 <dmwit> yes, just preparing a .cabal file before my push
22:42:32 <tgeeky_> dmwit: kk
22:45:29 <dmwit> Anyway, got unification-fd plugged in.
22:45:35 <dmwit> It cleaned up a bunch of stuff, which makes me very happy.
22:45:51 <dmwit> (And it forced me to finally learn how to use the Logic monad properly, which makes me happy, too. =)
22:46:07 * hackagebot hotswap 0.1.9.12 - Simple code hotswapping.  http://hackage.haskell.org/package/hotswap-0.1.9.12 (MikeLedger)
22:46:20 <tgeeky_> :r
22:46:30 <tgeeky_> dmwit: these are all good things. :O
22:46:57 <dmwit> bleh, github seems down from here
22:47:20 <tgeeky_> dmwit: same here :(
22:47:26 <tgeeky_> dmwit: nevermind
22:47:28 <tgeeky_> works ok
22:48:49 <Kaide> @hoogle (Monoid t) => a b t -> b -> t
22:48:49 <lambdabot> Control.Monad.Trans.Reader runReader :: Reader r a -> r -> a
22:48:50 <lambdabot> Control.Monad.Reader runReader :: Reader r a -> r -> a
22:48:50 <lambdabot> Control.Monad.Trans.State.Lazy evalState :: State s a -> s -> a
22:49:10 <Kaide> @hoogle (Monoid t) => Maybe t -> t
22:49:11 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
22:49:11 <lambdabot> Data.Foldable fold :: (Foldable t, Monoid m) => t m -> m
22:49:11 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
22:49:49 <Taneb> :t fromJust mzero
22:49:50 <lambdabot> forall a. a
22:49:50 <Kaide> ahah
22:50:09 <Taneb> No, that's wrong
22:50:20 <dmwit> Kaide: fold has the type you asked for
22:50:26 <Kaide> yes it does
22:50:42 <dmwit> :t mzero
22:50:43 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
22:50:54 <Taneb> fromMaybe mzero was what I meant
22:51:01 <dmwit> :t fromMaybe mempty
22:51:02 <lambdabot> forall a. (Monoid a) => Maybe a -> a
22:51:06 <Taneb> That's the one
22:51:07 * hackagebot hotswap 0.1.9.13 - Simple code hotswapping.  http://hackage.haskell.org/package/hotswap-0.1.9.13 (MikeLedger)
22:51:15 <mikeplus64> sorry hackage
22:51:17 <mikeplus64> lol
22:51:42 <dmwit> Hm, something is wrong with my wired connection but not with my wife's wireless connection!
22:51:49 <dmwit> We're both gooing through the same router, how can this be?
22:52:07 <Taneb> Problem with your adaptor?
22:52:16 <Taneb> My wifi adaptor thingy is awful
22:52:37 <dmwit> The wireless is fine. It's my desktop's wired connection that's not working properly.
22:52:53 <Taneb> Problem with the cable?
22:53:08 <dmwit> I can visit the router's diagnostic pages just fine.
22:54:53 <tgeeky_> dmwit: router has been running for a long time and some queue is overloaded, reboot router?
22:55:01 <tgeeky_> or even switch, if it's a cheap one :o
22:55:36 <dmwit> stranger and stranger: I can wget https://github.com, but can't visit it in my browser or git push to it.
22:56:13 <dmwit> tgeeky_: It's hard to blame the router when my wife's computer is doing everything just fine through the same router.
22:56:38 <Veinor> is there a module for 'fuzzy' date parsing?
22:56:53 <tgeeky_> dmwit: no it's not. the queues for the switch are distinct from the overall queues for the entire WAN traffic
22:57:20 <oelewapperke> does haskell require something special to support arrays ? I am following the docs at http://www.haskell.org/tutorial/arrays.html, but haskell keeps reminding me that it doesn't know about the "array" function
22:57:25 <Veinor> in other words, something that can take "June 8, 2012 5:17:22 AM" and turn it into a time value, without me specifying the formatstring in advance
22:57:44 <Veinor> oelewapperke: you need to import Data.Array
22:57:47 <dmwit> (Also, I rebooted the router a day or two ago. This behavior has been happening for a little while and I was hoping that would fix it without me understanding the problem.)
22:57:49 <Veinor> in ghci, :m +Data.Array
22:58:08 <oelewapperke> Veinor: thanks
22:58:09 <dmwit> "import Data.Array" Just Works in ghci these days... with a modern GHC, of course
22:58:11 <tgeeky_> dmwit: heheheh. I wish there were a command to make that a candidate for quote of the week
22:58:25 <Veinor> dmwit: oh true
22:58:53 <dmwit> Veinor: Don't know of one.
22:59:49 <blackdog> Veinor: heya - get a chance to look at killerswan's pull request for askitter?
23:00:06 * blackdog really does want a haskell twitter channel
23:00:11 <Veinor> oh, i'd completely forgotten about that. mostly because i don't maintain askitter any more
23:00:19 <Veinor> well, not actively
23:00:58 <Veinor> merged :)
23:01:03 <blackdog> fantastic:)
23:01:33 <Veinor> one of these days i do want to build something that uses twitter so i have incentive to maintain it
23:01:43 <blackdog> hackage push too? </greedy>
23:01:59 <Veinor> haha
23:02:07 <Veinor> remind me tomorrow? i wanna take a look over it
23:02:11 <blackdog> yep, no dramas
23:02:41 <nejucomo> How can I uninstall packages with ghc or tell ghci which module to import when two packages provide the same module?
23:02:50 <nejucomo> s/with ghc/with cabal/
23:03:40 <dmwit> ghc-pkg hide
23:03:45 <dmwit> or use package-qualified imports
23:04:05 * nejucomo scans :help output for package-qualified
23:04:53 <dmwit> You won't find it there.
23:04:59 <blackdog> Veinor: you have a particular thing in mind for twitter, btw?
23:05:13 <dmwit> Look in the GHC manual instead.
23:05:25 <dmwit> I would Google it for you, but I'm currently debugging some network connectivity problems.
23:05:43 <strager> nejucomo: ghci -hide-package conflicting-package-name
23:05:46 <tgeeky_> dmwit: here's all of the machinations of stepEval, laid out in justified alignment: http://i.imgur.com/ywi6X.png
23:05:54 <abdulsattar> @pl (\a -> a /= "c" && a /= "d")
23:05:55 <lambdabot> liftM2 (&&) ("c" /=) ("d" /=)
23:07:58 <nejucomo> Thanks lazyweb^H^H^H^H^H^H^H strager!  ;-)
23:08:41 <strager> dmwit's suggestions are better long-term though.
23:09:01 <dmwit> tgeeky_: Sisyphean
23:09:16 <dmwit> tgeeky_: The next push (when it happens) is going to basically completely overwrite stepEval. =P
23:09:58 <tgeeky_> dmwit: that's fine. I know I won't be able to merge this easily enough to make it worth my while.
23:10:19 <tgeeky_> dmwit: These aren't wasted, they are examples for an editor that understands haskell files modulo respacing :o
23:10:42 <tgeeky_> (and reordering, where reordering doesn't affect the outcome)
23:10:45 <dmwit> Yes, an editor with *real* elastic tabstops would be wonderful.
23:11:23 <tgeeky_> dmwit: hehe. it's even better than that :)
23:11:30 <tgeeky_> dmwit: that's the project that mgsloan and I share
23:12:30 <tgeeky_> dmwit: fantastic word, though. Sisyphean.
23:13:48 <tgeeky_> dmwit: and it's only true in the sense that I'll ultimately have to work with your pushes. If doing this nonsense helped me understand (visually see) what's going on with the stepper, then it's entirely worth it
23:13:54 <tgeeky_> dmwit: too early to tell on that front, though.
23:16:19 <mgsloan> I'm all for having full control over code layout.
23:16:19 <mgsloan> At once, I think it would be really cool to have an editor that displayed code in some manner specified by a "style", which changes the display layout conventions of other code, according to your preference (while remembering the old layout).
23:17:35 <mgsloan> and a very interesting style to automate, is lining up parts of code that have related structure (unfortunately, it's impossible to determine automatically if they actually _are_ related)
23:17:59 <tgeeky_> mgsloan: you can in the case of records, at least.
23:18:17 <dmwit> I think "automatically" is certainly too much to hope for.
23:18:32 <tgeeky_> but yeah, that's correct. What you can do is identify points in documents which you can use as centered anchors
23:18:59 <tgeeky_> mgsloan: but the key realization I think is that in order to do a good job of this, you don't leave the programmer with *full* control
23:19:07 <mgsloan> dmwit: hmm, I don't see why doing it automatically is very farfetched
23:19:29 <dmwit> Because, aesthetically, I don't always want every possible alignment point aligned.
23:19:57 <dmwit> Sometimes, I want two lines with equations whose equals signs aren't aligned, and sometimes I want two lines with equals signs that are aligned.
23:20:24 <mgsloan> dmwit: Fair point!  That's why you'd have the ability to specify a preference, customizing the heuristics used to weight the optimization of layouts
23:20:42 <mgsloan> bit of a hand-wavy answer, but there really area  whole slew of things people might look for
23:20:56 <tgeeky_> you don't have to do them all, you just have to have an editor who understands (or can prove) that differences in alignment aren't cause for recompilation... then you could automatically or even randomly align things
23:21:33 <mgsloan> tgeeky_: While unpractical as it forces an editor, I think it'd be cleaner to do this display-side
23:22:01 <tgeeky_> mgsloan: I don't think I know where that line is drawn yet, either
23:22:33 <tgeeky_> dmwit: imagine it as a *really* fancy version of the "scramble letters" button on an computer scrabble game (or words with frends or whatever)
23:22:58 <mgsloan> dmwit: Attempting to line up similar ASTs, not just related symbols, could make some sense.  Better yet, apply machine learning to the problem, and have users of the tool supply specific feedback regarding alignment choices.
23:23:56 <mgsloan> that last bit sounds very much like it wouldn't work, due to varying layout preferences among people, but this would hopefully be feedback of the form "these two things aren't related", rather than "I like 2 extra spaces here"
23:26:00 <mgsloan> tgeeky_: I like doing it display side, because it leaves things open to further display-side extensions (pretty lambdas, symbols, 2D layouts, richer literals, etc)
23:26:17 <tgeeky_> mgsloan: I think that's that leads to the most convincing example of what we're saying -- which is the minification of js code. Minificaton of haskell isn't necessary (or particularly helpful) but the entire point of the process is that you could do almost any transformation of (whitespace -> whitespace) and it's hard to say which is better or best (other than, for loading in a browser, minimization of this is best)
23:27:02 <tgeeky_> ok gotta sleep now
23:27:06 <tgeeky_> ttybothtomorrow
23:27:17 <mgsloan> 'night!
23:34:30 <frontendloader> I'm not familiar with haskell's layout, what would be a way to patch this into my 7.4.1 install? http://hackage.haskell.org/trac/ghc/ticket/5872
23:36:18 <xil> hi everyone. I'm about to paste some code to hpaste. I'm wondering if anyone here could help me test it. It's OpenGL and I want to know the FPS you get, which is displayed in the upper left corner when you run it. You can use WASD to move and the '\' key to toggle mouse control of the camera. Holding spacebar also let's you move up and down rather than limiting you to 2D movement, which is default.
23:36:24 <hpaste> xil pasted “fps test” at http://hpaste.org/68146
23:42:04 <frontendloader> maybe it isn't that simple
23:42:08 <dmwit_> tgeeky_: pushed
23:42:17 <frontendloader> would it be hard to recompile /usr/lib/ghc/base-4.5.0.0/Data/Bits.hi and use it?
23:44:57 <mmcdermo> xil: I get a constant 63 fps
23:45:28 <mmcdermo> Pretty hexagons btw
23:45:46 <dmwit_> I pushed the unification-nih branch, too, just for the heck of it.
23:46:58 <xil> mmcdermo: awesome, thanks =]. Yeah it's a test of a hex grid thing I'm working on for something
23:47:39 <mmcdermo> xil: I figured you were working on it for something ;) What are you visualizing / representing btw?
23:47:42 <xil> mmcdermo: I'm just getting about 30 and was wondering if it's my comp or what because the code should be capping it at 60, which it looks like it's doing for you
23:48:13 <xil> mmcdermo: it's something navigation related. I'm testing out some A* stuff in 3D and thought a hex grid makes movement easier
23:49:47 <mmcdermo> xil: anytime anyone mentions A* All I can think of is Dwarf Fortress lol. Is it CPU bound or GPU bound most likely?
23:50:07 <mmcdermo> I mean for your example, not A* :P
23:51:55 <xil> mmcdermo: does DF use A*? That would make a lot of sense. I'm going to say mine is CPU bound because I don't yet really know how to use the GPU for math and assume Haskell doesn't automatically for any reason. But the OpenGL part of it should be I'd think. I try to use as many OpenGL functions as possible to minimize CPU usage regarding the display
23:52:37 <ion> Drawf Fortress laughs?
23:54:55 <mmcdermo> Yep DF does (Im pretty sure); and I agree with it being CPU bound most likely. Have you played with the accelerate gpu lib at all? I never completely figured it out but it promises to make GPU work from haskell pretty nice
23:55:40 <hpaste> armence pasted “trying typeclasses” at http://hpaste.org/68147
23:55:59 <m3ga> anyone had any success or trouble with the happy parser and utf8? on linux if it makes a difference.
23:56:00 <xil> mmcdermo: I only know that it is possible to use the GPU for non-graphics things, but haven't looked at all yet into how to accomplish that
23:56:32 <armence> Hey all, I'm trying to figure out typeclasses and so I tried to code a little toy example (http://hpaste.org/68147) but I keep getting an error message. Can somebody help me out here?
23:57:56 <xil> armence: try "yesno (23::Int)"?
23:58:31 <armence> xil: Not in scope: data constructor `Int'
