00:33:12 <levi-g> hi all, its so quiet.
00:35:03 <jfischoff> @google it's oh so quiet
00:35:05 <lambdabot> http://en.wikipedia.org/wiki/It's_Oh_So_Quiet
00:35:05 <lambdabot> Title: It's Oh So Quiet - Wikipedia, the free encyclopedia
00:55:55 <efie> there is probably a math library in which the cartesian product function is defiend; how can I find it, if it exists?
00:58:21 <jfischoff> what are your types?
00:59:17 <efie> [a] -> [b] -> [(a,b)]
00:59:49 <jfischoff> > [(x, y) | x <- [1,2,3]., y<- [4,5,6] ]
00:59:50 <lambdabot>   <no location info>: parse error on input `,'
01:00:08 <jfischoff>  [(x, y) | x <- [1,2,3], y<- [4,5,6] ]
01:00:21 <jfischoff> >  [(x, y) | x <- [1,2,3], y<- [4,5,6] ]
01:00:22 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
01:00:34 <nus> @type zip
01:00:35 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
01:00:40 <jfischoff> yes
01:01:27 <nus> @hoogle [a] -> [b] -> [(a,b)]
01:01:28 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
01:01:28 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
01:01:28 <lambdabot> Test.QuickCheck.Modifiers shrinkState :: ShrinkState s a => a -> s -> [(a, s)]
01:06:14 <Jed_84> hi all
01:16:21 <Jed_84> Is it possible to somehow make constructors of abstract types visible from my unit tests?
01:16:52 <Jed_84> I have defined an algebraic data type in a module, and i'm exporting functions to create and manipulate instances of this type, but the constructors are not being exported
01:17:30 <Jed_84> I'd like to write some tests for the exported functions and it would be great if I could use the constructors to create test instances
01:23:38 <jfischoff> export Blah (Type (..)) where are you doing this (..)?
01:37:16 <Jed_84> jfischoff, yes, but that's the thing. I only want the constructors visible from my unit tests
01:37:35 <Jed_84> doing export Foo (Type(...) would make the constructors visible across the entire application
01:37:52 <Jed_84> and I don't want that
01:38:30 <adamt> I'm trying to manipulate a UTCTime (adding days/hours/seconds), but i can only find ways of manipulating ClockTime's via. CalendarTime from System.Time. Am i overlooking something?
01:40:43 <adamt> (closest i get is making a DiffTime as per http://hackage.haskell.org/packages/archive/time/1.1.4/doc/html/Data-Time-Clock.html , but addUTCTime demands a NominalDiffTime. =/
01:41:13 <coldpizza72i> Does this look like a legitimate function.  isMember2 x set = if null set then False else if x == head set then True else isMember2 x tail set
01:43:26 <fmap> coldpizza72i: in what sense "legitimate"?
01:44:19 <fmap> definitely not idiomatic
01:44:39 <Cale> Also missing some parens
01:44:53 <Cale> around (tail set)
01:47:03 <coldpizza72i> fmap: what do you mean?
01:48:04 <kallisti> coldpizza72i: you could write that much easier via pattern matching
01:48:12 <coldpizza72i> oh
01:48:21 <kallisti> > let (x:xs) = [1,2,3,4,5] in x
01:48:22 <lambdabot>   1
01:48:23 <kallisti> > let (x:xs) = [1,2,3,4,5] in xs
01:48:24 <lambdabot>   [2,3,4,5]
01:48:40 <adamt> i suppose my real itch is how to create NomialDiffTimes from scratch, if anybody knows about that.
01:48:51 <kallisti> adamt: should have a Num instance
01:48:53 <kallisti> just use fromIntegral
01:49:21 <adamt> oh
01:49:38 <adamt> Now i feel stupid. Thanks kallisti :)
01:49:47 <kallisti> no worries. I was confused too when I first looked at the library
01:49:52 <coldpizza72i> kallisti: i don't get what you just wrote
01:49:54 <kallisti> there's no documentation on the typical use cases.
01:50:17 <pharaun> coldpizza72i: that's an example of pattern matching
01:50:22 <kallisti> coldpizza72i: so anywhere you can bind a variable you can also bind a pattern. a variable name is actually just a special kind of pattern.
01:50:23 <luite> hehe that seems to configure everyone
01:50:25 <luite> confuse
01:50:29 <luite> hmm, odd typo...
01:50:48 * pharaun configures luite 
01:51:03 <coldpizza72i> kallisti: [1,2,3,4,5] looks like hard codeing
01:51:08 <kallisti> it is
01:51:13 <kallisti> the pattern is on the left-hand side
01:51:14 <pharaun> yes it is, its just an example
01:51:24 <kallisti> you can supply any list on the right-hand side.
01:51:28 <oddraisent> It there a way to suppress all output of IO() function?
01:51:59 <kallisti> coldpizza72i: a pattern can contain constructors and variables. the pattern matches if all of the constructors match, and when it succeeds, it extracts the fields of the constructor and binds them to the  variables
01:52:11 <kallisti> you can have multiple patterns
01:52:18 <kallisti> f [] = "this list is empty"
01:52:35 <kallisti> f (x:xs) = "this list is not empty: it has" ++ show x ++ "as its head and " ++ show xs ++ " as its tail"
01:53:14 <kallisti> coldpizza72i: are you familiar with : already?
01:53:16 <fmap> @hoogle runProcess
01:53:17 <lambdabot> System.Process runProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> Maybe Handle -> Maybe Handle -> Maybe Handle -> IO ProcessHandle
01:53:19 <coldpizza72i> yes
01:53:27 <kallisti> coldpizza72i: : is the constructor for lists.
01:53:32 <kallisti> so you can pattern match with it.
01:53:57 <kallisti> oddraisent: not that I know of.
01:54:11 <kallisti> not strictly "all output", because that covers a wide variety of things.
01:54:41 <kallisti> coldpizza72i: [] is also a constructor for lists. You can build any list from : and []
01:54:58 <oddraisent> kallisti: only putStr(Ln) and print outputs
01:55:09 <kallisti> oddraisent: redirect stdout to /dev/null? :P
01:56:01 <oddraisent> kallisti: yes
01:56:15 <kallisti> thanks for answering my question! :D
01:57:07 <kallisti> coldpizza72i: do you see what I'm saying?
01:57:15 <coldpizza72i> yeah
01:57:15 <kallisti> instead of explicitly checking for null, and calling head and tail
01:57:20 <kallisti> you can use pattern matching.l
01:58:08 <coldpizza72i> I have done a little bit of prolog
01:58:11 <donri> haha +RTS -B
01:58:24 <coldpizza72i> tiny bit rather
01:58:25 <kallisti> is that the system bell option?
01:59:02 <kallisti> coldpizza72i: yep; it's similar to that, but a bit more restricted.
01:59:05 <donri> yep
01:59:12 <coldpizza72i> kallisti: how so
01:59:53 <kallisti> Haskell's pattern matching only works on the constructors of data structures.
01:59:59 <kallisti> and some special syntax.
02:00:32 <kallisti> like string literals, an list literals can be used, even though they're not strictly constructors.
02:00:43 <kallisti> and numbers are handled specially, since they're overloaded.
02:00:54 <kallisti> (actually with OverloadedStrings the same applies to string literals)
02:00:58 <coldpizza72i> kallisti: thats cool because i don't like prolog very much and think its pretty confusing
02:01:52 <coldpizza72i> How does Ocaml compare to Haskell
02:02:10 <kallisti> they come from the same roots so there's a lot of overlap.
02:02:21 <ion> > compare "Ocaml" "Haskell"
02:02:22 <lambdabot>   GT
02:02:28 <coldpizza72i> whats the difference
02:02:32 <ion> GT
02:02:34 <coldpizza72i> GT?
02:02:38 <kallisti> but Haskell is lazy and purely function, which makes it quite a bit different from anything else in the ML family. That's about all I know; I'm not an ML or Ocaml expert.
02:02:50 <kallisti> coldpizza72i: data Ordering = LT | EQ | GT
02:02:54 <kallisti> :t compare
02:02:55 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
02:03:18 <kallisti> GT is a constructor of the Ordering type.
02:03:20 <kallisti> it has no arguments.
02:03:39 <kallisti> another example of nullary constructors:  data Bool = False | True
02:04:56 <kallisti> pattern matching on nullary constructors is nice and easy:  not True = False; not False = True
02:05:26 <kallisti> flipOrder LT = GT; flipOrder GT = LT; flipOrder EQ = EQ
02:05:36 <kallisti> (I don't think that function actually exists anywhere)
02:09:05 <coldpizza72i> i have to go
02:13:58 <Botje> > map (compare EQ) [LT..GT]
02:13:59 <lambdabot>   A section must be enclosed in parentheses thus: (`LT..` GT)Not in scope: `L...
02:14:16 <Botje> > map (compare EQ) [LT,EQ,GT]
02:14:17 <lambdabot>   [GT,EQ,LT]
02:14:22 <Botje> kallisti: ^^
02:18:15 <adamt> I like how you scared the pizza guy away :)
02:21:38 <kallisti> Botje: ah yes
02:22:00 <illissius> if I have data Nat = Zero | Succ Nat; infinity = Succ infinity, is it bad manners to provide instance Bounded Nat where minBound = Zero; maxBound = infinity?
02:22:36 <kallisti> heh
02:23:10 <kallisti> well there's not really a clear definition of how Bounded is supposed to work.
02:23:34 <kallisti> but, particularly when you combine it with an Enum instance, you generally expect certain things out of it, even though they're not really written anywhere.
02:23:52 <kallisti> -shrug- I don't really know the answer, actually.
02:24:14 <illissius> it's not like maxBound = error "not supported" because infinity is actually useful
02:24:19 <kallisti> I would only define that instances if you get something nice out of it.
02:24:23 <kallisti> illissius: yes
02:24:24 <wli> I thought Bounded merely required Ord so the invariants minBound <= x, maxBound >= x holds for any x :: Bounded t => t
02:24:26 <illissius> it's just not very.. bounded
02:25:12 <kallisti> there is no Ord superclass on Bounded
02:25:24 <wli> There should be.
02:25:28 <kallisti> why?
02:25:37 <wli> So such invariants can hold.
02:25:54 <wli> But really it should be broken up into lower bound and upper bound properties.
02:25:56 <illissius> documentation sez, "Ord is not a superclass of Bounded since types that are not totally ordered may also have upper and lower bounds."
02:26:23 <wli> Well, really it's that Ord is not sufficiently finely-grained.
02:26:41 <illissius> a lot of things in the Prelude aren't :)
02:27:03 <wli> Antichains can still exist in a poset with a maximal element.
02:27:12 <kallisti> well, in its defense, at the time of its writing I don't think "define a typeclass for each overloaded function" was in style
02:27:34 <kallisti> and it certainly becomes bewildering for anyone trying to learn the language.
02:27:39 <kallisti> I'm glad the Prelude was simple to understand.
02:27:48 <wli> It doesn't have to be for every overloaded function.
02:28:07 <wli> It merely shakes out that way in numerous cases.
02:29:25 <wli> The "make it easy for newbies" arguments haven't held up well with time.
02:30:04 <illissius> the laws-ish stated for Enum/Bounded don't seem to rule out maxBound = infinity.. http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Enum
02:30:36 <illissius> so I guess the question is still "I wonder if it's polite"
02:44:37 <rexamophone> hi guys
02:44:43 <Taneb> Hello
02:44:45 <rexamophone> Haskell beginner here.
02:45:08 <rexamophone> pointfree tells me that the following expression reduces down to just const (1 +)
02:45:11 <rexamophone> foldRight (\x acc-> (1 +) acc) 0
02:45:23 <Taneb> @hoogle foldRight
02:45:24 <lambdabot> No results found
02:45:33 <rexamophone> ie foldRight (const (1 +)) 0
02:45:51 <rexamophone> im not sure i understand how const works in this instance?
02:46:15 <luite> > const x y
02:46:16 <lambdabot>   x
02:46:20 <rexamophone> why is const required to reduce x out of the expression?
02:47:32 <Taneb> > \x -> y
02:47:33 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> SimpleReflect.Expr)
02:47:33 <lambdabot>    arisin...
02:47:33 <luite> rexamophone: you need some function that ignores an argument, since you don't use x
02:48:12 <rexamophone> oh i get it
02:48:29 <rexamophone> the lambda has to be an expression which takes two arguments
02:48:50 <rexamophone> and i return a partial (const) which fits that
02:48:53 <luite> yeah
02:49:03 <rexamophone> great!
02:49:04 <rexamophone> thanks :)
02:53:10 <kallisti> hm, I wonder why no one has made a postgreSQL language extension for Haskell.
02:53:15 <kallisti> stored Haskell procedures? sounds awesome.
02:54:06 <kallisti> it's probably just completely impossible to implement
02:55:00 <luite> it's possible to export haskell functions and write some wrapper lib that calls them
02:55:22 <luite> so probably not completely impossible :)
02:57:30 <kallisti> I'm aware
03:03:12 <Franciman> hey, how can I add autocompletion to emacs?
03:03:26 <Franciman> does haskell-mode already provide this?
03:05:47 <Franciman> or is ghc-mod better?
03:09:49 <sopvop> So, I have a list of possible updates to records. fold over it is ok, but writing the damp update functions in a list is ugly. like [\x -> maybe x (\newval -> p {foo = newval}) maybeNew]  And that maybeNew is another lambda. Ugly and ureadable.
03:10:01 <sopvop> damn
03:10:21 <roha> where can i find the implementation of (>>) for the State Monad?
03:10:22 <donri> sopvop: data-lens
03:10:37 <sopvop> I don't get the lens :(
03:10:59 <donri> sopvop: http://www.happstack.com/docs/crashcourse/AcidState.html#ixset_lens
03:12:23 <roha> under Monad on hackage i can only find the implementation for the list monad
03:13:05 <donri> roha: http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/src/Control-Monad-Trans-State-Lazy.html#StateT
03:13:27 <donri> scroll down to the Monad instance and look at >>=
03:14:11 <donri> the ~ is a lazy pattern
03:14:44 <donri> http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/src/Control-Monad-Trans-State-Strict.html#StateT for the strict version, might be easier to read in this case
03:14:57 <roha> donri, thanks!
03:16:33 <gienah> sopvop: a tutorial on lens: http://www.scs.stanford.edu/11au-cs240h/notes/zipper.html
03:16:42 <donri> (you'll usually want the mtl package though, but it's defined in transformers and the exported in mtl)
03:24:29 <Taneb> Proxy is a MonadPlus
03:27:58 <kallisti> it would be great if we could decide on a lens API and simply automatically incorporate it into records
03:28:06 <kallisti> so that instead of accessor functions you get lenses.
03:29:16 <roconnor__> kallisti: I think the big "problem" is the the current record mechanism supports "polymorphic" updates i.e. updates that change the type parameters of the record
03:29:40 <roconnor__> this is something that lenses as they stand do not allow.
03:29:44 <kallisti> oh. I hadn't even considered that a possibility.
03:29:52 <sopvop> Yeah, data-lens look nice, thanks for tutorial link
03:30:20 <gienah> sopvop: no worries
03:38:10 <dixie_> I'm curious... is there something like an oracle summer of code? :)
03:40:32 <adamt> dixie_: Honestly, Oracle doesn't (at least to me) sound like a company that would be into stuff like that. They seem more like a proper evil corporation(tm).
04:00:11 <oelewapperke> what is wrong with "head getArgs" ?
04:00:29 <oelewapperke>     Couldn't match expected type `[a]'
04:00:29 <oelewapperke>            against inferred type `IO [String]'
04:00:45 <barrucadu> oelewapperke: `getArgs` returns an IO [String], not a String
04:00:51 <cheater_> head is [a] -> a
04:00:55 <cheater_> you are feeding it IO [a]
04:01:10 <barrucadu> *not a [String]
04:01:32 <oelewapperke> why does that matter ?
04:01:44 <cheater_> you want do { args <- getArgs; let y = head args }
04:01:51 <cheater_> because haskell is strongly typed
04:02:04 <cheater_> and you aren't allowed to shove the square piece in the round hole
04:02:37 <oelewapperke> but the IO monad is only to mark this thing as impure, isn't it ?
04:02:52 <oelewapperke> why can't a pure function operate on data that came from an impure function like this ?
04:05:09 <barrucadu> The data is inside the IO monad, you have to 'lift' the head function into IO to use it
04:06:18 <opqdonut> oelewapperke: liftM :: (a -> b) -> IO a -> IO b
04:06:23 <opqdonut> does exactly that
04:06:50 <opqdonut> (actually the type is more general than that: Monad m => (a -> b) -> m a -> m b)
04:10:46 <navaati> :t fmap
04:10:47 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:11:02 <navaati> so no need to import Control.Monad
04:13:57 <fmap> oelewapperke: IO monad is not only to mark things.
04:14:25 <oelewapperke> why is "let" necessary ?
04:14:46 <oelewapperke> I tried x <- getArgs; y <- head x;
04:14:48 <oelewapperke> doesn't work
04:15:14 <donri> is the args list empty?
04:15:38 <donri> uh actually, you'll need a "return" for that there to work, but better use let
04:15:47 <oelewapperke> donri: it's not eve getting to that point, it just doesn't typecheck at all
04:15:51 <ceii__> you use <- to get the 'a' out of an 'IO a'
04:16:01 <donri> oelewapperke: yea. you need IO values for <- inside the IO monad
04:16:05 <ceii__> head x doesn't have an IO type, and you just want to give it a name
04:16:15 <ceii__> fir that, you use let
04:16:18 <ceii__> for*
04:16:29 <cheater_> @type (liftM head) $ getArgs
04:16:31 <lambdabot> Not in scope: `getArgs'
04:16:33 <cheater_> hmm
04:16:34 <donri> you can create IO values using "return", but it's sort of redundant when used with <-
04:16:41 <cheater_> @type (liftM head)
04:16:42 <lambdabot> forall a (m :: * -> *). (Monad m) => m [a] -> m a
04:17:05 <cheater_> you can just do (liftM head) $ getArgs
04:17:22 <fmap> @type head `liftM` System.Environment.getArgs
04:17:24 <lambdabot> IO String
04:17:38 <donri> :t head <$> System.Environment.getArgs
04:17:40 <lambdabot> IO String
04:17:56 <donri> or you can pattern match
04:18:09 <oelewapperke> can't I get IO off of that string ?
04:18:10 <donri> y:_ <- getArgs
04:18:27 <donri> this has the benefit of saner error messages
04:19:45 <donri> oelewapperke: there is a way to sidestep the type system but you're not supposed to leave IO once you enter it
04:20:17 <donri> some people think it's OK in the case of getArgs though
04:20:28 <donri> args = unsafePerformIO getArgs
04:20:28 <oelewapperke> so how would I get the first commandline argument into a string ?
04:21:19 <donri> oelewapperke: the recommended way is to do it inside IO, then you can do like i said, first:rest <- getArgs
04:21:22 <oelewapperke> donri: but then why is IO String so different from String
04:21:42 <donri> @where io
04:21:42 <lambdabot> Raphael L. Levien's language with continuations as fundamental structure, described in his paper "Io: a new programming notation" (1989-09-10) at <http://dl.acm.org/citation.cfm?id=70931.70934> and
04:21:42 <lambdabot> in chapter 2 of Raphael A. Finkel's book `APLD', implementations `Amalthea',`Ganymede'
04:21:51 <donri> o_O
04:22:14 <fmap> oelewapperke: http://www.haskell.org/haskellwiki/IO_inside
04:22:21 <donri> http://www.haskell.org/haskellwiki/Introduction_to_IO
04:31:06 <nand`> @hoogle (a -> b) -> (b -> a)
04:31:06 <lambdabot> Data.Generics.Schemes everywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
04:31:07 <lambdabot> Data.Generics.Schemes everywhere' :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
04:31:07 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
04:31:27 <nand`> Is there any type class for functions that have an inverse such that “inverse f . f” = id ?
04:33:34 <platzhirsch> In Haskell you can describe the same computation in many ways, often it seems reasonable to make these computations especially short. What do you think would be a good word to descrive the shortness of such a computation? As in awesomeness
04:35:31 <hiptobecubic> platzhirsch, it depends on the quality of the code. If it's short because it's terse and unreadable then 'shitty' is a good word.
04:36:12 <platzhirsch> hiptobecubic: right, I didn't mean shortening come hell or high water
04:36:37 <ClaudiusMaximus> http://en.wiktionary.org/wiki/concise#Adjective is probably what i'd use
04:37:08 <platzhirsch> ClaudiusMaximus: nice
04:37:41 <platzhirsch> I really like that one
04:39:14 <ClaudiusMaximus> http://en.wiktionary.org/wiki/succinct#Adjective might be better as it also has a notion of clarity
04:39:56 <ClaudiusMaximus> (better for marketing purposes)
04:42:12 <platzhirsch> ClaudiusMaximus: true, clarity is important in that matter
04:45:12 <iFire> platzhirsch: the standard phrase is succinct
04:45:26 <iFire> bit late
04:46:17 <ClaudiusMaximus> nand`: not sure if this is what you want, but there's http://hackage.haskell.org/packages/archive/groupoids/0.2.1.2/doc/html/Data-Isomorphism.html and http://hackage.haskell.org/packages/archive/fclabels/latest/doc/html/Data-Label.html#g:4 and probably more things (i searched hayoo for isomorphism)
04:49:48 <nand`> looks like I can use Iso (->)
04:51:37 <ClaudiusMaximus> nand`: cool;  i think it'd be hard to make a "typeclass for invertible functions", because "invertible" is a property of values, not types
04:53:10 <nand`> yeah, true
04:53:15 <nand`> I should be making a type, not a typeclass
04:53:59 <platzhirsch> iFire: good to hear that from you, too :)
04:57:42 <iFire> platzhirsch: google sinccinct data structures
05:03:19 <cheater_> oelewapperke: IO String and String are different types. In Haskell, your types need to match. Don't ask why they are different, they just are.
05:03:49 <cheater_> you obviously want to process this string somehow
05:04:12 <cheater_> let's say you want to make another string out of it, so you make a function process :: String -> String
05:05:14 <cheater_> then you use this code: main = do { args <- getArgs; let arg1 = head args; putStrLn (process arg1) }
05:05:23 <cheater_> and it prints out the processed string
05:05:32 <cheater_> that's probably close enough for you to figure out what to do next
05:05:43 <cheater_> have fun
05:11:18 <hiptobecubic> With an llvm target for ghc, and NVidia having announced an llvm backend for their cuda platform, do we expect to see easier integration or are they just tooting their horns about relatively little?
05:12:59 <adamt> Stupid Haskell, I'm not sure i can go back to a language without pattern matching.
05:13:07 <adamt> I better not have to then.
05:17:26 <sipa> adamt: switch (...) { case X: ... } ought to be enough for everyone!
05:18:23 <parcs`> pattern matching is theoretically awesome but it's not really a game changer
05:20:15 <zachk> adamt: you don't have to use pattern matching all the time
05:20:25 <zachk> you could write accesors and use them if that is more comfortable for you
05:21:35 <hpc> for me, the thing that makes switching languages unbearable is first-class IO
05:23:33 <hpc> (and more recently, ContT r IO)
05:30:48 <plumenator> Anybody know someone that uses Haskell in re-eingineering projects?
05:37:56 <plumenator> Does anyone use Haskell for reengineering?
05:40:42 <Clint> what?
05:41:47 <zachk> plumenator: what is re-engineering?
05:42:20 <hamid> do you mean reverse engineering?
05:42:22 <plumenator> Reverse Engeneering + Reimplementation
05:42:23 <plumenator> http://en.wikipedia.org/wiki/Reengineering
05:43:32 <plumenator> The context I'm looking at is legacy systems written in old languages like COBOL.
05:43:47 <plumenator> Usually only code is available
05:43:58 <plumenator> No documentation
05:46:26 <dsx7> Hi guys, is there a canonical way of mapping a Bool to Either apart from if-then-else? something like :: Bool -> a -> b -> Either a b ?
05:47:17 <hpc> @djinn Bool -> a -> b -> Either a b
05:47:18 <lambdabot> f a b c =
05:47:18 <lambdabot>     case a of
05:47:18 <lambdabot>     False -> Left b
05:47:18 <lambdabot>     True -> Right c
05:47:26 <sopvop> I just figured out I need type class to update records from serialization, on top of aeson. Maybe someone already did this?
05:49:06 <hpc> dsx7: are you asking in a "can you write this function" way, or an "in theory, are these the same" way?
05:51:38 <dsx7> I'm asking more "is there a canonical/semantic abstraction for this problem". Surely it's trivial to write one but maybe there's something already out there I'm missing. I want a ArrowChoice that takes a bool and I thought if-then-else would be kind of ugly in this point-free setting
05:52:25 <hpc> ah
05:52:59 <dsx7> I thought maybe there's something "standard"
05:53:08 <hpc> don't think so
05:53:17 <dsx7> thanks a lot anyway
05:53:20 <ClaudiusMaximus> @pl \a b c -> if a then Left b else Right c
05:53:21 <lambdabot> flip flip Right . ((.) .) . (. Left) . if'
05:53:30 <hpc> technically, if-then-else is the only eliminator you need
05:53:33 <jonaskoelker> yummy
05:53:39 <ClaudiusMaximus> @pl \b c a -> if a then Left b else Right c
05:53:39 <lambdabot> (. Right) . flip . flip if' . Left
05:53:52 <dsx7> :))
05:54:25 <hpc> iirc, the "eliminator" for a data type is the function f such that (f Constructor1 Constructor2 ...) = id
05:54:25 <ClaudiusMaximus> @pl \c b a -> if a then Left b else Right c
05:54:26 <lambdabot> flip (flip . flip if' . Left) . Right
05:54:43 <hpc> @let (f ?? t) p = if p then t else f
05:54:45 <lambdabot>  Defined.
05:54:48 <hpc> :t (False ?? True)
05:54:49 <lambdabot> Bool -> Bool
05:54:56 <hpc> :t foldr (:) []
05:54:57 <lambdabot> forall a. [a] -> [a]
05:55:17 <hpc> -- both are "eliminators" in that context, and you can do pretty much whatever, with them
05:55:57 <jonaskoelker> interesting concept; got a (semi)practical example?
05:56:14 <dsx7> which theory are eliminators coming from?
05:56:20 <hpc> dunno :P
05:56:27 <hpc> it's just stuff i have picked up from #agda
05:56:31 <dsx7> just wondered where I can read more about them
05:56:32 <jonaskoelker> computer science :P
05:56:40 <dsx7> aha
05:56:44 <jonaskoelker> or math
05:56:50 * jonaskoelker is being silly
05:57:22 <hpc> just pointing out that those kind of functions should be all you need to go from one type to another
05:57:30 <hpc> probably
05:57:51 <jonaskoelker> :t (Left a ?? Right b)
05:57:52 <lambdabot> Bool -> Either Expr Expr
05:58:00 <jonaskoelker> :t ((Left a) ?? (Right b))
05:58:01 <lambdabot> Bool -> Either Expr Expr
05:58:05 <jonaskoelker> o_O
05:58:18 <ClaudiusMaximus> :t (a, b)
05:58:19 <lambdabot> (Expr, Expr)
05:58:21 <jonaskoelker> oh yeah, silly me, makes sense
05:58:45 <jonaskoelker> :t (Left 1 ?? Right [2]) True -- I'm guessing [Int] or somesuch
05:58:46 <lambdabot> forall t t1. (Num t, Num t1) => Either t [t1]
05:59:00 <jonaskoelker> wth
05:59:18 <jonaskoelker> :t ((Left 1 ?? Right [2]) True)
05:59:19 <hpc> > (Left 1 ?? Right [2]) True
05:59:19 <lambdabot> forall t t1. (Num t, Num t1) => Either t [t1]
05:59:19 <dsx7> thanks hpc
05:59:21 <lambdabot>   Right [2]
05:59:41 <jonaskoelker> ah
05:59:42 <hpc> > (Left 1 ?? Right [2]) False
05:59:43 <lambdabot>   Left 1
05:59:47 <dsx7> I also didn't know you can do "(t ?? f) p" syntax
05:59:47 <jonaskoelker> me silly
05:59:56 <dsx7> (even though it actually makes sense)
06:00:22 <jonaskoelker> that's just an extension of (x infixoperator y), right?
06:01:40 <jonaskoelker> do you guys have any experience with clojure?  If so, what do you make of it?
06:02:11 <ion> (a `f` b) ≡ (f a b), therefore (a `f` b) c ≡ (f a b) c
06:02:39 <jonaskoelker> = f a b c
06:04:32 <byorgey> dsx7: the general idea of an "eliminator" comes out of formal logic
06:05:15 <byorgey> where for each new syntactic form you have some introduction rules which give you that form in the conclusion, and some elimination rules which let you do something with that form as a premise
06:06:06 <byorgey> for example, the introduction rule for logical and (conjunction) says that if you can prove A and B, then you can prove (A /\ B).  That corresponds to the (,) constructor in Haskell.
06:06:44 <byorgey> the elimination rules for logical and are  (A /\ B) ==> A   and  (A /\ B) ==> B, which correspond to fst and snd in Haskell.
06:09:07 <hpc> byorgey: oh, cool
06:09:12 <hpc> i should have noticed that myself
06:14:09 <Taneb> I think the next stage for my family tree library will be to add GEDCOM compatibility and support
06:15:16 <Taneb> Or should I?
06:18:17 <jonaskoelker> gedcom?
06:21:23 <Taneb> De-facto standard format for genealogy files
06:22:01 <jonaskoelker> i see
06:25:56 <Taneb> Thinking about it, the library's written in such a way that I'd have to almost start it from scratch
06:29:19 <jtza8> If I'm a Lisp kinda person, and infix notation never really seems needed, would not using it be bad style?
06:29:39 <Taneb> If it affects the readability of the code
06:29:44 <Taneb> Negatively, that is
06:29:55 <jtza8> True, and false.
06:30:02 <jtza8> For example...
06:30:04 <parcs`> of course infix notation is not "needed"
06:30:12 <parcs`> but it's almost always nicer
06:30:24 <jtza8> elem 3 [1, 2, 4]
06:30:26 <parcs`> so yes it would be bad style
06:30:31 <jtza8> is as clear as
06:30:40 <jtza8> 3 `elem` [1, 2, 4]
06:30:41 <parcs`> oh, i thought you were talking about operators
06:30:44 <Taneb> Same
06:30:51 <jtza8> sorry for that.
06:31:03 <Taneb> Go for infix if it's more readable, try not to use it otherwise?
06:31:36 <hpc> yeah, nobody in their right mind is going to write (>>=) foo (\x -> (>>) bar ((>>=) ...
06:31:38 <parcs`> jtza8: sometimes it's nicer, sometimes it's not. i don't know if one can really quantify when and when not to use it
06:31:45 <ClaudiusMaximus> there's also http://www.liskell.org/ (but it seems bitrotted/unmaintained since ~2007)
06:32:13 <jtza8> Well, I guess these things come with experience.
06:32:14 <hpc> backtick notation isn't very common anyway
06:32:23 <hpc> mostly just for elem, div, mod, and such
06:32:36 <hpc> where they are expected to be infix anyway
06:32:42 <parcs`> jtza8: i don't think it would be considered bad style to completely avoid it though
06:32:54 <hpc> @let (∈) = elem
06:32:55 <lambdabot>  Defined.
06:33:06 <hpc> 1 ∈ [1..15]
06:33:10 <hpc> > 1 ∈ [1..15]
06:33:12 <lambdabot>   True
06:33:16 <hpc> :D :D :D
06:33:33 <jtza8> Thanks for clearing that up.
06:33:39 <mekeor> @let π = pi
06:33:40 <lambdabot>  Defined.
06:33:57 <hpc> @let τ = 2*π
06:33:58 <lambdabot>  Defined.
06:34:09 <hpc> (for the math hipsters)
06:34:15 <mekeor> @let φ = (1 + sqrt 5) / 2
06:34:16 <lambdabot>  Defined.
06:34:43 <byorgey> @package tau
06:34:43 <lambdabot> http://hackage.haskell.org/package/tau
06:34:45 <byorgey> =)
06:35:19 <mekeor> lol
06:35:28 <byorgey> hmm, isn't there also a package that defines infix symbols for a lot of Prelude functions such as elem?
06:35:46 <t7> theres a unicode something package
06:35:54 <ClaudiusMaximus> http://hackage.haskell.org/package/base-unicode-symbols
06:36:05 <byorgey> ah, that's it =)
06:36:43 <byorgey> haha, I like how they use Greek letters in all the types =D
06:36:53 <byorgey> (∈) :: Eq α => α -> [α] -> Bool
06:37:47 * mekeor watches http://www.youtube.com/watch?v=3174T-3-59Q – hmm, actually that's off-topic…
06:39:34 <FrostyX> Much please. I cant figure it out. How I can add withUrgencyHook NoUrgencyHook into this my line main = xmonad =<< statusBar myStatusBar myPP toggleStrutsKey defaults
06:41:21 <FrostyX> oh, wrong channel. I want write to xmonad ..
06:44:51 <hpaste> expez pasted “testing runProcess” at http://hpaste.org/68426
06:45:19 <Expez> I get 'parse error on input putStrLn' on that last line. What did I mess up?
06:45:37 <ClaudiusMaximus> the where binds to the =, so the putStrLn is in the where clause
06:45:42 <ClaudiusMaximus> or something like that
06:46:32 <rwbarton> yeah you can't use where like that
06:46:32 <ClaudiusMaximus> either put the where clause after the whole do block, or use 'let'
06:47:07 <Expez> ok, thanks
06:50:39 <statusfailed> With Data.Binary.Get, is there a way to run a "Get" until the end of input and return a list?
06:50:49 <statusfailed> like a repeat combinator or something
06:57:36 <ClaudiusMaximus> statusfailed: i guess you could make one with runGetState, but it seems there is no such combinator prebuilt - possibly down to strictness in relation to >>= ? (perhaps the Get monad can't return a list until it's reached the end of the input, which could be rather huge with lazy bytestrings - but i'm speculating..)
07:00:04 <statusfailed> ClaudiusMaximus: So the normal way to do it would be to just use runGetState incrementally?
07:00:35 <ClaudiusMaximus> statusfailed: i don't know, i've never used the binary package, but that is likely the route i'd take if i needed to
07:00:45 <statusfailed> okay, looks good to me. Thanks!
07:01:56 <ClaudiusMaximus> perhaps some combo of runGetState, isEmpty and Data.List.unfoldr
07:05:13 <statusfailed> ClaudiusMaximus: I just found an example here: http://www.haskell.org/haskellwiki/DealingWithBinaryData#The_Get_monad
07:05:33 <statusfailed> ClaudiusMaximus: it just uses recursion and isEmpty
07:05:37 <statusfailed> so thanks :D
07:07:10 <ClaudiusMaximus> cool
07:13:02 <Taneb> Is it possible to include instances for a type in a library, but not require the package containing the type?
07:14:33 <geekosaur> uh
07:14:58 <geekosaur> that makes no sense to me.  you need to have the type to make an instance for it
07:15:11 <Taneb> As in, "Hello p
07:15:58 <Taneb> * "Hello person installing this package, type Foo has a Bar instance, but you don't have the package where Foo is defined, but that's alright! You still get all the other instances!"
07:16:05 <deech> Hi all, just saw this (http://www.reddit.com/r/programming/comments/tjeg3/haskell_was_a_statically_typed_language_now_you/) on the front page of proggit. Does this mean that it will be easier to create plugins in the future?
07:16:25 <geekosaur> Taneb, I kno what you think you mean
07:16:33 <geekosaur> my point was that it makes no sense
07:16:54 <geekosaur> (I know, it makes sense to you... btu it makes no sense in the context of Haskell)
07:17:31 <rwbarton> you can perhaps use package cabal flags or extra instance packages to provide these instances... I don't know which is considered less evil
07:17:43 <Taneb> It's just annoyed me in the past how, etc, there's no Aeson instance for HashMap
07:17:53 <geekosaur> the instance can't be made to exist at all without knowledge of the type.  no, you can't have it just be dangling there without the type it's based on, the type needs to be there to define it in the first place therefore it *will* be there in the interface
07:18:03 <Taneb> (Well, there's no Aeson class, but the Aeson associated classes)
07:18:18 <Taneb> Ok, I guess that makes sense
07:18:19 <BrianHV> I don't think he's proposing dangling classes... I've wondered about this myself, actually
07:18:47 <ClaudiusMaximus> Taneb:  http://www.haskell.org/haskellwiki/Orphan_instance might have some advice on a linked reference - personally i think cabal flags that change API are more evil than extra packages with orphan instances...
07:18:56 <BrianHV> it's the sort of thing that in C might be done with a preprocessor check like #if AESON  instance HashMap Aeson where ... #endif
07:19:05 <BrianHV> maybe that would work in haskell as well
07:25:08 <seven> hi
07:26:27 <seven> when i read sth from file i wanna use some function on that and it doesn't work if i hardcode it then it works :/
07:27:05 <Taneb> Gedcom is scary
07:27:34 <seven> someone help please
07:28:07 <Taneb> Sounds like you're stuck in the IO
07:28:31 <seven> ok..
07:28:32 <rwbarton> paste some code at http://hpaste.org, we cannot possibly help you based on what you've said so far
07:28:39 <Taneb> ^^^
07:28:50 <rwbarton> also the error message or whatever indication you have that "it doesn't work"
07:30:27 <hpaste> 7sedam7 pasted “preblem” at http://hpaste.org/68427
07:31:23 <Taneb> Does rules.txt exist?
07:31:34 <rwbarton> okay, and what is the issue?
07:31:40 <seven> yep
07:31:49 <seven> it exists
07:31:54 <rwbarton> what is the issue
07:31:59 <fmap> @hoogle getLines
07:31:59 <lambdabot> No results found
07:32:00 <seven> sec ill paste error
07:32:04 <rwbarton> thanks
07:32:39 <seven> Couldn't match expected type `IO b0' with actual type `[Char]' Expected type: IO b0 Actual type: String
07:32:56 <rwbarton> so getLines is not any function I know about
07:33:01 <rwbarton> where is it from?
07:33:24 <seven> sry sec
07:33:34 <seven> getLines = liftM lines . readFile
07:33:53 <rwbarton> :t liftM lines . readFile
07:33:54 <lambdabot> FilePath -> IO [String]
07:35:00 <seven> how can I get [String]
07:35:07 <rwbarton> what you wrote looks fine to me
07:35:15 <rwbarton> what lines is that error you pasted reported for?
07:35:17 <rwbarton> *what line
07:36:29 <geekosaur> seven, if you think you want to "get [String]", you haven't quite figured out Haskell yet.  (In short:  you can't.  work *within* the IO, do not try to "get rid of" it.)
07:36:36 <rwbarton> his code looks fine
07:36:45 <Taneb> What's the type of parse?
07:36:45 <seven> i didn't thing that
07:36:55 <geekosaur> [12 10:34] <seven> how can I get [String]
07:37:00 <geekosaur> "you can't"
07:37:03 <seven> ok
07:37:28 <seven> i expresed my self wrong
07:37:42 <roha> quick question: if you pattern match against a Maybe value, does that force the evaluation the value?
07:38:34 <roha> or: does pattern matching always force evaluation?
07:38:44 <seven> i made a typeing mistake it works now
07:38:51 <seven> thanks anyway
07:39:25 <geekosaur> roha, pattern matching always forces just far enough to match
07:39:42 <fmap> > (\(Just n) -> show 7) (Just undefined)
07:39:43 <lambdabot>   "7"
07:39:56 <geekosaur> so if your pattern is (Maybe x) then it evaluates far enough to get the Maybe,but x remains unevaluated
07:41:08 <roha> ok great! monads start to make sense :D
07:42:15 <siracusa> > (\(Just !n) -> show 7) (Just undefined)
07:42:16 <lambdabot>   "*Exception: Prelude.undefined
07:44:24 <navaati> nom nom nom, holes in ghc 7.6 !
07:44:52 <Taneb> > (\(Just !n) -> show 7) (Just (Just undefined))
07:44:53 <lambdabot>   "7"
07:45:10 <navaati> when will it be released, anyone knows ?
07:49:39 <siracusa> navaati: Do you mean types with holes?
07:50:05 <navaati> i mean holes like goals in agda
07:50:37 <siracusa> Hhm, I don't know Agda
07:57:31 <c_wraith> ghc 7.6? probably late this year. GHC major versions are on approximately one-year cycles
08:05:14 <White_Rabbit> Is there BONUS, author of Lern you a haskell?
08:05:34 <c_wraith> preflex: seen BONUS
08:05:35 <preflex>  BONUS was last seen on #haskell 1 year, 12 days, 19 hours, 37 minutes and 35 seconds ago, saying: yeah i think that's better as well
08:05:46 <Taneb> Probably not
08:05:52 <White_Rabbit> argh
08:05:59 <Taneb> Probably not/
08:06:05 <syao> hello to all, I have a question. Can I user Data.Sequence like a mutable Queue?
08:06:06 <Taneb> What's the problem? was what I meant to say
08:06:31 <c_wraith> syao: well, you can use it as a queue easily enough - but it's certainly not mutable
08:06:43 <White_Rabbit> Taneb: I want ask him "Can I translate your ebook?"
08:06:55 <Taneb> Okay, I can't help you with that
08:06:58 <syao> is there a mutable version? or somethin similar?
08:07:01 <Taneb> Send him an email, perhaps?
08:07:22 <byorgey> syao: why do you need it to be mutable?
08:07:34 <syao> performance reason
08:07:46 <Taneb> Mutable in what?
08:07:49 <syao> and memory usage
08:07:55 <c_wraith> so, you're saying you have no clue, you think it's just better, somehow
08:08:14 <White_Rabbit> bb
08:08:31 <c_wraith> have you actually benchmarked?
08:08:51 <syao> I'll use a lot of queues, and they should be updated in realtime system
08:09:06 <c_wraith> so, no, you haven't benchmarked
08:09:11 <c_wraith> You're just making random assumptions
08:09:16 <byorgey> is there an existing package on Hackage defining the construction that takes a semigroup under min and turns it into a monoid by adjoining an element at positive infinity?
08:09:20 <syao> so a lot of copying wont help
08:10:00 <rwbarton> who said anything about copying
08:10:22 <Taneb> syao, Haskell may not work as you think it works on the inside
08:10:25 <c_wraith> Data.Seq has amortized O(1) insert/remove from both ends. That means it's not doing a lot of copying
08:10:43 <byorgey> syao: because of purity, immutable data structures do not have to be copied in order to create a modified version.
08:11:34 <syao> yes, but i need to know how much real time the Data.Seq O(1) will be
08:11:47 <syao> yes, but i need to know how much real time the Data.Seq O(1) will take
08:12:18 <syao> ok, sorry for the bother, I'll try to benchmark it :)
08:12:20 <byorgey> well, honestly, I don't think Haskell is a very good choice for programming real-time systems
08:12:40 <c_wraith> it's not, due to pause-the-world GC
08:12:54 <c_wraith> But I have a sneaking suspicion this isn't a hard real-time problem
08:12:56 <syao> i have 2 ways. erlang or haskell
08:13:08 <byorgey> if you want functional, maybe try OCaml instead.  Jane St. has apparently had good success creating real-time software using it.
08:14:40 <syao> the problem is that software is kind of real time in some part and distributed in other. so in real I dont know what to use.. :/
08:16:55 <bitonic> byorgey: why would OCaml have advantages over Haskell?
08:17:11 <bitonic> I think they're (Jane St.) successful because they spent a lot of time creating good libraries
08:17:25 <syao> the message passing could be done in erlang and other in haskell. that's what I think.
08:17:28 <t7> easier to reason about memory usage?
08:17:34 <t7> and space leaks
08:18:00 <t7> is that the same thing? i dont know
08:26:39 <mm_freak> byorgey: you can write real time systems in haskell…  you just have to obey some rules
08:26:48 <mm_freak> as little sharing as possible, etc.
08:33:22 <Taneb> The Gedcom spec is so dense...
08:34:05 <statusfailed> Why do many functions like "take" have Int parameters instead of specifying Num ?
08:34:15 <statusfailed> Is there a performance reason or something?
08:34:37 <mm_freak> statusfailed: yes
08:34:46 <Taneb> Take the first 4.2 elements of [1..]
08:34:52 <statusfailed> Oh, do I mean Integral then? :P
08:35:13 <mm_freak> statusfailed: you probably mean Num and Enum
08:35:16 <rwbarton> @type genericTake
08:35:17 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
08:35:22 <mm_freak> but you, Num would suffice
08:35:33 <mm_freak> anyway, Int is used consistently enough that you should never have to convert
08:35:46 <mm_freak> and it does make a performance difference
08:35:48 <statusfailed> well, I just used a Word32, but it's not really bothering me, I was just curious
08:35:59 <statusfailed> what is the performance issue with type classes?
08:36:48 <mm_freak> statusfailed: can't be optimized easily across modules
08:37:13 <statusfailed> Oh right, because the details of the specific Num/Enum aren't known?
08:37:15 <adamt> zachk: well, right now i like pattern matching a lot.
08:37:43 <statusfailed> interesting. Thanks guys :)
08:37:43 <jmcarthur> not a huge performance problem if INLINABLE is used liberally
08:37:48 <statusfailed> INLINABLE you say
08:37:55 <adamt> parcs`: of course it's not a gamechanger, but the convenience of pattern matching isn't to be devalued either. :)
08:38:02 <jmcarthur> can still be a problem sometimes, but it helps
08:38:46 <mm_freak> statusfailed: well, you can certainly have genericTake be as fast as take…  but we would have to go through some trouble to get there
08:38:56 <jmcarthur> SPECIALIZE can help too
08:39:01 <mm_freak> since there is really little reason not to use Int, 'take' uses Int
08:39:24 <statusfailed> sure, makes sense
08:39:26 <parcs`> adamt: yep :)
08:39:40 <mm_freak> one problem of every beginning haskell programmer is in the first few months the desire for overgeneralization =)
08:39:49 <statusfailed> jmcarthur: those are some great tips, I didn't know those existed :D
08:40:01 <statusfailed> mm_freak: I think any language :D
08:40:11 <mm_freak> statusfailed: especially haskell
08:40:16 <jmcarthur> i like generalization
08:40:19 <statusfailed> I think LYAH advises against making your own typeclasses actually
08:40:25 <statusfailed> perhaps for that reason?
08:40:30 <mm_freak> when i started getting comfortable almost all of my functions and types used a lot of type variables
08:40:38 <mm_freak> nowadays most of my functions are monomorphic
08:40:52 <jmcarthur> interesting. i've gone the opposite direction
08:41:23 <zachk> monomorphic? well defined, specific type signatures? I know it greatly decreases compile time
08:41:31 <mm_freak> two reasons:  1. i stay in the problem domain and get better performance, 2. i have a simple specification that is harder to break
08:41:46 <jmcarthur> i've gradually shifted more and more from monomorphic+lazy to polymorphic+strict
08:42:01 <jmcarthur> i see monomorphism as being a more *complex* specification
08:42:03 <mm_freak> oh, my code utilizies laziness where it can =)
08:42:23 <jmcarthur> since you are carrying around the baggage of specific types instead of just a few laws from type classes
08:42:40 <mm_freak> jmcarthur: for example if you know that Vector is the optimal data structure you should probably just use Vector
08:42:55 <mm_freak> instead of "Vectorlike a v => v a" or whatever you call it
08:43:01 <jmcarthur> but i can just make that choice in one place instead of everywhere
08:43:33 <mm_freak> well, i have observed that i never really changed my choices
08:43:44 <jmcarthur> Vector is not, in my opinion, an awesome example for this. there aren't many alternatives to it
08:43:53 <mm_freak> and if i did i would just change some type aliases and an auxilliary module
08:43:57 <jmcarthur> at least not with similar interfaces
08:44:11 <mm_freak> type Ctx = Map Index Name
08:44:42 <zachk> jmcarthur: how do you go about enforcing the strictness?
08:45:14 <jmcarthur> zachk: i just use it where i think it will be useful. usually in the form of strict fields, occasionally in the form of strict parameters, rarely using seq explicitly
08:45:22 <zachk> ahh
08:45:41 <jmcarthur> i use laziness a lot too, mind you
08:45:46 <mm_freak> what kind of applications do you write?  i found myself never to find strict fields useful
08:46:05 <jmcarthur> but the more experience i've gained the more i've developed an intuition for it
08:46:53 <jmcarthur> mm_freak: i think the strictness serves the purposes of being semantically meaningful (usually this is when i use strict fields) and also beneficial for performance
08:47:18 <mm_freak> strict fields usually /degrade/ performance
08:47:20 <jmcarthur> mm_freak: i've been working on a lot of game dev type things, and graphics and stuff, but i also code this way for less real-time things
08:47:29 <mm_freak> they can improve memory usage, but performance usually goes down
08:48:02 <jmcarthur> strict fields, not unboxed fields
08:48:04 <mm_freak> unless, of course, you also unbox the fields
08:48:09 <mm_freak> yes
08:48:10 <jmcarthur> i unbox sometimes
08:48:14 <jmcarthur> but rarely
08:48:20 <mm_freak> strict fields have a performance hit
08:48:43 <mm_freak> because it's still a thunk…  now the compiler, whenever pattern-matching against the constructor, must make sure the field is evaluated, even if it already is
08:48:50 <jmcarthur> it depends on whether the fields are going to be put under different constructors over and over
08:49:26 <jmcarthur> normally these are one-shot things, like vectors of small dimension, configs, etc.
08:49:34 <mm_freak> i see
08:49:45 <mm_freak> i'd go with regular nonstrict fields and enforce explicitly
08:50:01 <mm_freak> that gives better performance than strict fields
08:50:05 <jmcarthur> to me it's a kind of distinction between data and codata
08:50:38 <zachk> codata?
08:50:48 <jmcarthur> unboxed fields have a performance impact too, even over plain strict fields
08:50:56 <jmcarthur> if you end up boxing and unboxing over and over
08:51:00 <mm_freak> right
08:51:08 <mm_freak> i just go with the usual nonstrict fields
08:51:34 <mm_freak> they have the best performance, but occasionally need some strictness annotations in pattern matches
08:52:34 <jmcarthur> if you usually use strictness annotations on them then you have the same overhead as if they were just strict fields, no?
08:52:43 <mm_freak> yes
08:52:47 <jmcarthur> ah you said occasionally
08:52:53 <jmcarthur> misread as usually
08:53:50 <zachk> is codata a 'promise' to generate data?
08:54:00 <jmcarthur> zachk: haskell blurs the distinction between data and codata. codata is essentially data that's allowed to be infinite. when you are reasoning about recursing over and generating data/codata, the way you reason about them differs depending on which one it is
08:54:03 <mm_freak> zachk: see recursion vs. corecursion
08:54:26 <zachk> ahh
08:54:45 <amiddelk> why would strict fields have any other performance penalty than causing a potentially unused value to be computed for which otherwise only a closeure would have to be created?
08:55:03 <jmcarthur> zachk: that's roughly it. you can think of it as the difference between strictly folding a data structure and lazily unfolding a data structure (although strictness and laziness are not important parts of what these mean)
08:55:03 <mm_freak> amiddelk: the run-time must make sure the field is computed
08:55:16 <mm_freak> amiddelk: every time that is, even if the field is certainly already computed
08:55:23 <jmcarthur> amiddelk: each time you seq something there is a runtime cost even if it's already evaluated
08:55:44 <jmcarthur> it's not a huge cost, but it is there
08:55:59 <mm_freak> zachk: the idea is:  recursion consumes data, corecursion generates data
08:56:08 <mm_freak> recursion must be destructive, corecursion must be constructive
08:56:39 <amiddelk> mm_freak: I'd actually say that you would *not* have to check that, because when you use the constructor, it will have forced the computation of the fields already ...
08:56:42 <mm_freak> if you follow those rules, then all of your programs either terminate or are productive
08:56:53 <mm_freak> so you don't have unproductive infinite loops
08:57:29 <mm_freak> amiddelk: that's the difference between strictness and eager evaluation
08:57:38 <amiddelk> jmcarthur: agreed. Unless of course you incorporate the results of strictness analysis.
08:57:57 <jmcarthur> right. strictness analysis is one of the optimizations i find difficult to predict, though
08:58:34 <jmcarthur> although i do lean on it a lot
08:58:50 <jmcarthur> well... i guess i dont' really
08:58:59 <amiddelk> if I write let x = ... in seq x (...) then I'd hope that it does not first create a closure for x and then start seq'ing that one
08:59:32 <jmcarthur> there is only one way to find out :)
09:04:08 <ClaudiusMaximus> amiddelk: unfortunately that can happen (it bit me once, got a <<loop>> or the equivalent in the threaded runtime, which i think is just sitting there doing nothing consuming no cpu? - anyway turned out i had made a typo somewhere too, and got it fixed...)
09:04:52 <ClaudiusMaximus> > let x = seq x "hmm" in x
09:04:57 <lambdabot>   mueval-core: Time limit exceeded
09:05:41 <ClaudiusMaximus> was pretty much what i did, not sure if that's actually the same as what you meant, now..
09:06:19 <ClaudiusMaximus> > let x@(~(_:_)) = seq x "hmm" in x
09:06:23 <lambdabot>   mueval-core: Time limit exceeded
09:07:05 <amiddelk> ClaudiusMaximus: actually, a strictness analyzer should give an error in this case ;-)
09:07:10 <parcs`> > let !x = seq x "hmm" in x
09:07:11 <lambdabot>   Recursive bang-pattern bindings aren't allowed:
09:07:11 <lambdabot>      { !x = GHC.Prim.seq x ...
09:08:44 * hackagebot patterns 0.0.3 - Common patterns in message-oriented applications  http://hackage.haskell.org/package/patterns-0.0.3 (TobiasSchoofs)
09:09:26 <ClaudiusMaximus> parcs`: nice! think i saw that once, with a mutually recursive binding in a do block, that made me split it into 2 separate 'let's, or something, possibly typos were involved there too :)
09:11:06 <jmcarthur> ClaudiusMaximus: <<loop>> is when you have a value whose evaluation strictly depends on its own evaluation
09:12:38 <jmcarthur> ClaudiusMaximus: for example:   main = print (let x = x in x :: ())
09:13:29 <ClaudiusMaximus> jmcarthur: yep, that's what i thought, but i seem to recall the threaded runtime behaving differently w.r.t. printing <<loop>> and aborting
09:13:30 <jmcarthur> ClaudiusMaximus: when the runtime starts evaluating a thunk, it tags it until it's done. if it runs across a thunk that's already tagged, it knows it's caught in a loop
09:13:46 <jmcarthur> ClaudiusMaximus: yeah i think the threaded runtime does treat this a bit differently
09:15:41 <ClaudiusMaximus> jmcarthur: right.  ghci uses threaded runtime (ghci +RTS --info  reports rts_thr) , and just sits there consuming no cpu until you interrupt it with "let x = x in x :: ()"
09:18:20 <jmcarthur> right
09:19:17 <parcs`> ClaudiusMaximus: i think that's different. a blackhole exception does get raised, but ghci ignores it
09:19:46 <jonaskoelker> I have "type Number = Integer"---why doesn't Number implement Enum?
09:20:06 <jonaskoelker> gah, nvm
09:25:11 <ismail> someone there?
09:25:41 <mekeor> of course!
09:26:14 <ismail> my ghci tells me that it could not find module System.Random. How can i solve that?
09:26:53 <statusfailed> Is there like an embeddable script library for haskell? Like a GHCI for adding haskell scripting to my program?
09:27:05 <donri> ismail: do you have the random package installed?
09:27:53 <ismail> donri: it seems not.
09:28:09 <Cale> statusfailed: hint
09:28:14 <donri> ismail: also, what do you need randomness for? that package has a few issues
09:28:21 <Cale> statusfailed: and/or using the GHC API directly
09:28:32 <mekeor> donri: is System.Random not in base?
09:28:35 <ismail> i am working with a book with examples in it
09:28:36 <statusfailed> Cale: awesome, you are the man :)
09:28:49 <ismail> Computational Semantics ...
09:28:53 <donri> mekeor: nope
09:29:00 <Cale> mekeor: Not any more, it seems...
09:29:30 <mekeor> ok
09:29:55 <ismail> and one example File tries to load the module System.Random
09:30:16 <donri> ismail: ah, in that case: cabal install random
09:30:34 <ismail> i don't understand. How does it work?
09:31:32 <donri> ismail: actually, it might be best to grab a platform install, http://hackage.haskell.org/platform/
09:32:43 <ismail> Isn't it possible to just download a .hs file with the module in it?
09:33:28 <donri> maybe, maybe not. better install it properly.
09:35:29 <geekosaur> ismail, you can download it from hackage, but possibly not in a drop-into-your-program form, that's not how things are generally done
09:37:46 <ismail> geekosaur: i am downloading archive.tar now. into which folder do i have to extract it?
09:37:59 <geekosaur> ...what?
09:38:15 <donri> you still need to install it even if you do it manually like that
09:38:39 <geekosaur> isn't archive.tar *all* of hackage?  seems a bit excessive
09:38:48 <donri> oh, right. heh.
09:38:59 <ismail> oh
09:39:02 <ismail> :-)
09:39:15 <donri> ismail: do you have a "cabal" command in your terminal?
09:39:33 <mekeor> ismail: which OS?
09:40:51 <ismail> donri: cabal not in scope
09:40:54 <EEVIAC> hey how do i get overloaded strings to work in ghci
09:40:56 <ismail> mekeor: OpenSuse 12.1
09:41:00 <donri> ismail: normal terminal, not ghci
09:41:12 <byorgey> EEVIAC: :set -XOverloadedStrings
09:41:15 <Kuba> Hello!
09:41:15 <EEVIAC> thanks!
09:41:25 <xterm5443> Hi, I have problem with class types.
09:41:26 <xterm5443> Example:
09:41:26 <xterm5443> simpleHTTP :: HStream ty => Request ty -> IO (Result (Response ty))
09:41:26 <xterm5443> mkRequest :: BufferType ty => RequestMethod -> URI -> Request ty
09:41:26 <xterm5443> simpleHTTP (mkRequest ...)
09:41:26 <xterm5443> Error:
09:41:26 <xterm5443> Ambiguous type variable ´ty0´ in the coinstraints:
09:41:27 <geekosaur> that said... System.Random I thought was a bootlib, so should already be installed
09:41:27 <xterm5443> (HStream ty) arising from a use of ...
09:41:27 <xterm5443> How I can solve it?
09:41:27 <byorgey> hi Kuba!
09:41:35 <byorgey> xterm5443: please don't paste in the channel, use hpaste.org
09:42:03 <Kuba> could you please explain me that behaviour? http://wklej.org/hash/42a31dfa7c/txt/ and the error: http://wklej.org/hash/59a3923ac7/txt/ ?
09:42:18 <ismail> donri: i am about to install cabal right now
09:42:40 <ismail> now i have cabal. what next?
09:42:41 <xterm5443> byorgey: sorry.
09:42:51 <donri> ismail: cabal update; cabal install random
09:43:09 <Franciman> is there a way to emulate forall without using the extension?
09:43:22 <Franciman> ( just want to know, I don't want to do silly things )
09:43:31 <byorgey> Kuba: does it work if you remove the type signatures from build xs  and  build qs?
09:43:32 <Kuba> oh, sorry, hope you don't mind I used my own pastie service, not hpaste...
09:43:54 <byorgey> Kuba: by default, the 'a' in those type signatures has no connection to the 'a' from the instance head
09:44:01 <byorgey> Kuba: no, that's fine
09:44:34 <Kuba> byorgey: urm, you just solved my problem...
09:44:42 <Kuba> byorgey: but lemme check
09:44:54 <Kuba> (it compiles)
09:44:58 <byorgey> great =)
09:45:18 <Kuba> omomom, okay, it works as expected even!
09:45:48 <byorgey> if you ever DO need to refer to an existing type variable in a local type signature, you have to add 'forall a. ...'  to the top-level type signature, and turn on the ScopedTypeVariables extension
09:45:57 <byorgey> but you usually don't need that unless you're doing something fancy
09:46:17 <ismail> donri: done. what now?
09:46:17 <Kuba> byorgey: I have to go now, but I'll look into the code once again and try to bother you later on
09:46:27 <byorgey> Kuba: ok
09:46:28 <donri> ismail: try running the example again
09:46:38 <Kuba> byorgey: as currently I find this behaviour strange
09:46:52 <Kuba> byorgey: thanks and see you later
09:47:04 <byorgey> Kuba: it is a little strange.  I can explain it in more detail later.  I'm sure there are others who can as well.
09:47:41 <bitonic> uhm. is there a closs-platform sleep?
09:47:44 <ismail> the installation process failed a i recognized now
09:48:01 * mybuddymichael
09:48:46 * hackagebot PortFusion 1.0.3 - CORSIS PortFusion : High-performance Distributed Proxy  http://hackage.haskell.org/package/PortFusion-1.0.3 (CetinSert)
09:49:12 <byorgey> bitonic: threadDelay?
09:52:21 <ismail> after typing install random it says: user error (The package requires Cabal library verion -any && >=1.6 bot no suitable version is installed.)
09:53:33 <donri> ismail: what does "ghc-pkg latest Cabal" say?
09:53:58 <bitonic> byorgey: I'll check it out, thanks
09:54:04 <ismail> ghc-pkg: cannot find package Cabal
09:54:15 <byorgey> ismail: how did you install GHC?
09:54:19 <bitonic> byorgey: yeah looks good. thanks.
09:54:19 <byorgey> and what version is it?
09:54:23 <donri> you managed to install cabal-install without Cabal?
09:54:31 <mysticc> @hoogle permutation
09:54:32 <lambdabot> Data.List permutations :: [a] -> [[a]]
09:54:32 <lambdabot> package permutation
09:54:32 <lambdabot> package action-permutations
09:54:40 <noam> is there any package similar to ArrayRef that compiles on ghc 7.4?
09:54:50 <ismail> i installed ghc oneclick with software.opensuse.org
09:55:04 <ismail> i installed cable with zypper
09:55:47 <byorgey> noam: maybe try vector, or Repa?  I'm not familiar with ArrayRef so not sure which features you're looking for
09:56:14 <noam> i really just want a better syntax for using the ST monad
09:56:29 <noam> it's so clunky
09:56:57 <jmcarthur> clunky in what way?
09:57:39 <ismail> i now typed: cabal install cabal-install
09:58:40 <noam> jmcarthur: readSTRef, writeSTRef, modifySTRef everywhere. when in imperative languages your code will be much nicer to look at
09:59:26 <byorgey> ismail: you shouldn't really need to upgrade cabal-install (though it may tell you there is a more recent version available)
09:59:49 <ismail> it didn't work anyways.
09:59:54 <byorgey> ismail: can you run "ghc-pkg list" and paste the output somewhere?
09:59:58 <jmcarthur> noam: are you certain you even need ST arrays? are immutable vectors insufficient for what you're doing?
10:00:56 <ismail> could you just tell me the syntax for redirecting output into file?
10:01:11 <noam> jmcarthur: i want to write a Go program (the game), so that board needs O(1) updates that are important individually.
10:01:35 <amiddelk> ClaudiusMaximus: in the example that you gave a couple of screens back, perhaps the GHC option for eager blackholing would have given an error immediately: http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/using-smp.html#parallel-compile-options
10:01:55 <noam> jmcarthur: for a program without an AI a Map will probably good enough. but that is not what i want.
10:01:57 <byorgey> ismail: ghc-pkg list > somefile.txt
10:01:58 <jmcarthur> noam: would O(log n) really be too slow?
10:02:18 <c_wraith> noam: you'd rather severely complicate backtracking code?
10:02:27 <jmcarthur> noam: especially for AI, the easy backtracking you get with purely functional data structures is awesome
10:02:33 <ismail> byorgey: where can i put it?
10:02:48 <byorgey> ismail: hpaste.org
10:03:16 <ClaudiusMaximus> amiddelk: cool, i'll check it out
10:03:52 <hpaste> ismail pasted “ismails random problem” at http://hpaste.org/68428
10:04:27 <ClaudiusMaximus> amiddelk: ah, nice! i do have some parallel things where i really don't want re-evaluation to happen because it's expensive to compute...
10:05:31 <noam> jmcarthur, c_wraith: Map would be easier but less efficient. I'd rather do it the complicated way. haskell has such good ways of separating state from the rest of the program, i wonder why people seem to avoid it at all cost ;)
10:05:58 <lamefun2> Does Haskell force FRP? Is traditional State -> TimeInterval -> State approach still valid?
10:06:21 <byorgey> ismail: ok, as I suspected, the ghc package that you installed seems to come only with the absolute bare minimum.  OpenSUSE must have broken stuff out into other separate packages that you need to install as well.  But I don't know what they are.
10:06:29 <jmcarthur> lamefun2: not only does it not force frp, but frp is not common at all
10:06:58 <amiddelk> ClaudiusMaximus: in that case I'd rather ensure that the value is computed before the computations that depend on it
10:07:20 <ClaudiusMaximus> amiddelk: sure, of course i'll benchmark and profile and so on to check that it helps
10:07:22 <jmcarthur> noam: Map is not the only purely functional map we have, you know
10:07:28 <jmcarthur> noam: Map is one of the slowest
10:07:49 <parcs`> noam: you can make infix aliases of ST methods, eg $= is writeSTRef, %= is modifySTRef, etc
10:08:20 <noam> jmcarthur: i don't know about all the data structures but i really want O(1) access and not O(log n)
10:08:44 <jmcarthur> noam: from some points of view there isn't much of a difference between O(1) and O(log n)
10:08:55 <jmcarthur> noam: IntMap is widely considered to be O(1) for example
10:09:13 <noam> parcs`: thats about what i want. is there a library that defines those for me?
10:09:53 <parcs`> noam: i think so, but i forgot its name
10:10:05 <c_wraith> hell.  Hash table access is necessarily O(log n). People don't know that because a) they suck at math, and b) the constant factors are really good.
10:10:28 <jmcarthur> c_wraith: exactly
10:10:34 <ClaudiusMaximus> there is StateVar package for IORefs and similar, not sure if supports use with ST
10:10:40 <noam> jmcarthur: you can say that, but there will be still a constant overhead of going through about 10 pointers, for an AI that's unacceptable
10:10:47 <jmcarthur> c_wraith: even array access is O(log n). it's just that n is constant on most machines
10:11:06 <iFire> jmcarthur: you mean dependent on word size
10:11:10 <noam> ClaudiusMaximus: right. i'm not comparing to a hashtable, but rather to a flat array.
10:11:20 <jmcarthur> iFire: the word size and the size of the address space are related
10:11:34 <jmcarthur> iFire: it's linear in the word size and logarithmic in the address space size
10:11:50 <roha> is there a parallel version of map for vectors? (like parMap)
10:12:47 <jmcarthur> roha: such a thing could exist for boxed vectors. for unboxed vectors you might want to check out something like repa
10:13:35 <ismail> Anywas. Thank you all for your kind help. I just deleted the unnecessary random parts out of my code and just skip it :-)
10:13:55 <roha> jmcarthur, ok thanks, ill check it out
10:17:19 <mrkronecker> Hello! I wonder if anyone knows of an effective method for planning out projects in Haskell/the functional paradigm?
10:18:01 <mrkronecker> As far as planning goes, I'm mostly accustomed to OO projects
10:18:15 <mrkronecker> which I don't think translates!
10:18:30 <jmcarthur> mrkronecker: i don't really plan them out any differently
10:18:35 <mrkronecker> Oh no?
10:18:40 <jmcarthur> mrkronecker: but i never really plan out far in advance anyway
10:18:53 <jmcarthur> mrkronecker: i usually go for a pretty straightforward, bottom-up approach
10:19:15 <mrkronecker> I am quite an assiduous planner, I guess.
10:19:16 <jmcarthur> mrkronecker: at each level of abstraction, i think about what interface i want and then just implement it...
10:19:57 <mrkronecker> I am planning on designing a sort of text-based adventure game
10:20:07 <mysticc> @src permutations
10:20:07 <lambdabot> Source not found. Sorry.
10:20:18 <ClaudiusMaximus> same here, i just jump in and start coding, haskell makes it quite easy to refactor parts that turn out to be inconvenient
10:20:29 <mrkronecker> I see!
10:20:34 <jmcarthur> ClaudiusMaximus: well... usually, at least :)
10:20:40 <mrkronecker> I should try that
10:20:48 <mrkronecker> Thank you all for your advice
10:20:57 <lpsmith> hmm,  it would be very convenient to have a hackage package that would make it easy to create a Windows Service in Haskell
10:21:36 <ClaudiusMaximus> jmcarthur: sure, of course i end up in mutable state IO hell sometimes, easier to add another field to the state than to clean it up... and it's quite hard to escape from that without starting over
10:24:13 <hpaste> xterm5443 pasted “Class type problem” at http://hpaste.org/68429
10:27:19 <jmcarthur> xterm5443: ghc can't tell that the ty type parameter in your rq binding is the same as the ty type parameter in your q binding. try something like this:   q :: forall ty. HStream ty => IO (Result (Response ty))    and   rq :: Request ty
10:27:50 <jmcarthur> xterm5443: the forall brings ty into the scope of rq's type signature so you can reuse it instead of declaring it anew, which is what your current code does
10:28:29 <jmcarthur> xterm5443: i hope i got q's type signature right. correct it if necessary, of course
10:29:50 <Taneb> I'm annoyed at GEDCOM
10:31:04 <xterm5443> jmcarthur: I modified source by your idea ... but still the same problem.
10:31:55 <jmcarthur> xterm5443: ah, sorry, i guess i don't really have the context to fix it then
10:32:00 <jmcarthur> ninly!
10:32:09 <ninly> jmcarthur!
10:35:19 <twanvl> xterm5443: this looks like the monomorphism restriction
10:35:34 <twanvl> add a type signature for q, or add {-# LANGUAGE NoMonomorphismRestriction #-}
10:39:21 <xterm5443> twanvl, jmcarthur: I have defined {-# LANGUAGE NoMonomorphismRestriction #-}. ( q type is - q :: forall ty. HStream ty => IO (Result (Response ty)) )... not working :(.
10:40:44 <twanvl> shouldn't "rq :: forall tq. (HStream ty) => Request ty" be "rq :: forall ty. (HStream ty) => Request ty" ?
10:40:57 <twanvl> i.e. with the type variable named ty, not tq
10:42:30 <xterm5443> twanvl: In the source file I have ¨ty¨, not ¨tq¨. (typing error with copy)
10:43:47 * hackagebot htiled 0.0.2 - Import from the Tiled map editor.  http://hackage.haskell.org/package/htiled-0.0.2 (ChristianRoedliAmble)
10:45:39 <twanvl> xterm5443: the first version (without the type signature on rq) works for me if I set NoMonomorphismRestriction
10:45:57 <twanvl> note that if you set that in a source file it might not apply to definitions made inside ghci
10:53:08 <BillyJoe> Using FP (in general or Haskell in particular), how do you participate in transactions with an external system? In an imperative language I would simply call Begin()/Rollback()/Commit()
10:54:27 <statusfailed> Hmm, is there a function to print a number as hexadecimal with a minimum number of digits?
10:55:00 <mysticc> BillyJoe: What does that have to do with FP ..
10:55:16 <twanvl> > showHex 1234 ""
10:55:16 <lambdabot>   "4d2"
10:55:30 <jmcarthur> BillyJoe: i guess i'd probably do that as a monad where the run function attempts to run the transaction and failure causes it to rollback
10:55:34 <statusfailed> twanvl: If I want a 4-digit string, though?
10:55:37 <mysticc> @hoogle hexadecimal
10:55:38 <lambdabot> Text.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
10:55:38 <lambdabot> Text.ParserCombinators.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
10:55:38 <lambdabot> Data.Text.Lazy.Read hexadecimal :: Integral a => Reader a
10:55:57 <twanvl> you want at least 4 digits?
10:56:00 <jmcarthur> BillyJoe: similar to STM, i guess
10:56:01 <statusfailed> at least n digits
10:56:11 <jmcarthur> BillyJoe: most such system don't have orElse like STM does though, sadly
10:56:14 <jmcarthur> *systems
10:56:18 <twanvl> > printf "%04x" 1234
10:56:18 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:56:19 <lambdabot>    `Text.Printf.PrintfType ...
10:56:23 <twanvl> > printf "%04x" 1234 :: String
10:56:24 <lambdabot>   "04d2"
10:56:31 <statusfailed> oh, awesome
10:56:32 <jmcarthur> orElse/retry
10:56:35 <statusfailed> twanvl: thanks very much!
10:57:00 <jmcarthur> BillyJoe: also, you could just use begin, rollback, commit just like in C or something
10:57:07 <jmcarthur> it's just lower level
10:57:44 <adamt> Is there something like filter that returns two lists (one with the matches and one with the rest)?
10:57:55 <mysticc> jmcarthur: What are "most such system" here ?
10:57:58 <jmcarthur> adamt: i think it's called partition or something
10:57:59 <t7> filter (not . f)
10:58:10 <jmcarthur> mysticc: the case i have in mind is something like postgresql
10:58:10 <t7> hehe
10:58:12 <twanvl> > partition even [1..5]
10:58:12 <lambdabot>   ([2,4],[1,3,5])
10:58:21 <adamt> t7: rather not, i want it to happen in one runthrough ;)
10:58:35 <adamt> jmcarthur + twanvl: of course, thank you very much.
10:58:48 <Alan> I'm writing an instruction encoder/decoder for a toy instruction set, and i'm having an annoying problem where I have to write the opcode values in two places... is there some kind of way that I could associate some values with constructors in a bijective way?
10:58:50 <BillyJoe> mysticc, I don't understand, doesn't it?
10:58:53 <jmcarthur> @src partition
10:58:54 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
10:58:54 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
10:58:54 <lambdabot>                               | otherwise = (ts, x:fs)
10:58:59 <BillyJoe> jmcarthur, monads, I see, thanks!
10:59:17 <Alan> it's especially problematic because the constructors don't all take the same numbers or types of parameters
10:59:29 <mysticc> BillyJoe: I meant are you trying to implement transactions or using some ..
10:59:44 <noam> jmcarthur: i had a change of heart. what would be the best `Data.Map`-like immutable data structure for a small 2d array (19x19)
10:59:54 <xterm5443> twanvl: Not working for me :(. Should I upload complete source file to hpaste?
11:00:07 <twanvl> xterm5443: yes
11:01:25 <jmcarthur> noam: i've used http://hackage.haskell.org/package/unordered-containers for this before. i've also used EnumMap, but this looks newer (maybe better? dunno) http://hackage.haskell.org/package/enummapset
11:01:57 <BillyJoe> mysticc, Actually, I just asked that questions because I try to learn how FP handles things that seem to be impossible by "just" defining functions in FP style. That "transaction with external system" both covered state and external system communication.
11:02:03 <jmcarthur> noam: i've also made a wrapper around IntMap before just for using 2d coordinates
11:02:08 <adamt> actually, thanks for doing the src-thing jmcarthur, since i might as well implement a specific partition method for this case.
11:02:18 <jmcarthur> adamt: why?
11:02:38 <noam> jmcarthur: alright. i'll check those up. thanks
11:02:56 <adamt> jmcarthur: i need to partition on a criteria but also use the result of the calculation behind the criterion.
11:03:07 <BillyJoe> mysticc, I was curious to know if that actually could be expressed using FP functions or if it would be solved using a non-FP paradigm.
11:03:11 <noam> jmcarthur: is your wrapper on github or somewhere public?
11:03:13 <mysticc> BillyJoe: Then it is monad you are looking for ..
11:03:20 <jmcarthur> adamt: ah! i would compose partition with map, then
11:03:29 <plumenator> Are there good examples of Haskell used for source code transformation?
11:03:34 <jmcarthur> noam: i don't think so. it was throwaway code for an AI contest i was participating in
11:03:40 <plumenator> Say, if the input language is COBOL?
11:03:48 * hackagebot graph-serialize 0.1.5 - Serialization of data structures with references.  http://hackage.haskell.org/package/graph-serialize-0.1.5 (ThomasSchilling)
11:04:10 <adamt> jmcarthur: i need to split into two stacks based on something being overdue or not, and then transform the data into something else containing information about how overdue it is. if that makes sense.
11:04:18 <hpaste> xterm5443 pasted “Class type problem (2)” at http://hpaste.org/68430
11:04:41 <adamt> jmcarthur: i'll try to figure something about with partition and map, thanks.
11:04:44 <mysticc> @google alternate stm implementation gist
11:04:47 <lambdabot> https://gist.github.com/1454995
11:04:59 <jmcarthur> adamt: do it the other way around then. map over the list so that the new list's elements are the original values and how far overdue they are, then partition base on whether they are actually overdue
11:05:26 <jmcarthur> adamt: where the filter uses the results from the map
11:05:27 <adamt> jmcarthur: Oh. I suppose that makes sense.
11:05:41 <adamt> Certainly seems simpler.
11:06:32 <BillyJoe> mysticc, I've read about monads, and it seems to be parts of rules composed into a whole (a monad) with state. Is it somewhat correct to say that a monad is imperative code wrapped in an optionally stateful box that make the imperative code fit into an FP system?
11:06:45 <jmcarthur> BillyJoe: no, i would not say that is correct
11:07:04 <BillyJoe> jmcarthur, then I have to read some more :)
11:07:12 <jmcarthur> BillyJoe: as far as most programmers are normally concerned, a monad is just a common pattern in many interfaces
11:07:30 <jmcarthur> BillyJoe: common enough to get some syntax sugar
11:07:54 <jmcarthur> it's otherwise not special at all, has nothing to do with implementation (apart from some laws that must be satisfied)
11:08:08 <twanvl> xterm5443: so the module will be loadable in ghci, but you can't call q, because you need to specify the return type.
11:08:09 <BillyJoe> jmcarthur, I see.
11:08:12 <jmcarthur> BillyJoe: the benefit is that once you've internalized the laws and various consequences of them then you can write some very generic code with them
11:08:13 <twanvl> for example > q :: IO (Result (Response String))
11:08:30 <Franciman_> you can syntax sugar-ize anything you want, the only thing you need is a preprocessor
11:08:43 <BillyJoe> Franciman, true
11:09:17 <twanvl> xterm5443: or you could just specialize the type of q in web.hs to only return String, or ByteString or whatever you want
11:09:30 <jmcarthur> BillyJoe: but i would like to discourage you from attempting to tie it to any notion of state or sequencing or imperative programming. the only kind of sequencing that's fundamental to monads is data dependencies, which doesn't even imply an evaluation order due to laziness and often doesn't even imply any particular ordering of effects (some monads are commutative in terms of their effects)
11:10:11 <jmcarthur> BillyJoe: and the data dependencies thing isn't particular to monads either. most programming has such things, of course :)
11:11:48 <Franciman_> why the heck can't I get used to any haskell editor-IDE?
11:12:05 <xterm5443> twanvl: Are you sure? simpleHTTP (getRequest ¨http://haskell.org¨) working ... and return value is the same as q.
11:12:16 <iFire> Franciman_: look into the y-combinator and see that you only need paper
11:12:46 <byorgey> Franciman_: what is the maximum amount of time you have spent using any single IDE?
11:13:26 * byorgey likes his A4-size Integrated Drawing Environment
11:13:29 <Franciman_> iFIre lol
11:13:48 <BillyJoe> jmcarthur, so what you are saying is that while imperative code often is implemented using monads, monads themselves (the pattern) isn't in any way related to imperative code (or state)? Just like "citynames are often put in strings, but strings aren't in any way related to citynames"
11:13:49 * hackagebot git-date 0.2 - Bindings to the date parsing from Git.  http://hackage.haskell.org/package/git-date-0.2 (StephenWeber)
11:14:06 <jmcarthur> BillyJoe: yes!
11:14:15 <BillyJoe> then I got your point :)
11:14:24 <Franciman_> byorgey quite a bit of time, especially with Eclipse that was slower than a tortoise with only two feet
11:14:52 <byorgey> I think you mean a 500-pound tortoise with only two feet
11:15:01 <Franciman_> yeah definetely
11:15:32 <Franciman_> *definitely
11:16:33 <Franciman_> eclipse has the power to get me angry more than anything else in the world
11:17:50 <xterm5443> twanvl: Sorry, simpleHTTP (getRequest ¨http://haskell.org¨) have ... String in returend value.
11:19:10 <xterm5443> twanvl: Thank you very much! Its working now (added String ...).
11:22:00 <EEVIAC> yes i have a question about Data.Enumerator. why are enumerators defined as type Enumerator a m b = Step a m b -> Iteratee a m b
11:22:06 <EEVIAC> why does it return an iteratee
11:22:28 <EEVIAC> i thought an enumerator takes an iteratee and feeds it input and then returns what the iteratee returned
11:25:34 <HugoDaniel> hi
11:32:46 <parcs`> EEVIAC: an enumerator modifies an iteratee by feeding it data
11:34:40 <EEVIAC> ah, so if the iteratee that we're feeding finishes doing its stuff, the returned iteratee will be a Yield?
11:37:33 <Kuba> byorgey: hey, fancy explaining me how on earth the compiler properly infers types in my case? ;d
11:38:38 <byorgey> Kuba: sure
11:38:53 <byorgey> Kuba: can you link me to your code again?
11:39:05 <Kuba> byorgey: http://wklej.org/hash/42a31dfa7c/txt/
11:39:33 <Kuba> byorgey: is it value:values that crucial there?
11:40:47 <byorgey> Kuba: well, let's see, what's the type of 'build' supposed to be?
11:41:10 <Kuba> Serial a => build :: [Bit] -> (a, [Bit])
11:41:58 <byorgey> ok, and in this case we are defining a Serial instance for [a]
11:42:08 <byorgey> so the type of build should be   [Bit] -> ([a], [Bit])
11:42:14 <Kuba> yep
11:42:24 <Kuba> therefore value is a, and values is [a]?
11:42:31 <byorgey> right
11:42:43 <Kuba> mhm
11:42:57 <Kuba> makes sense
11:43:01 <byorgey> and that's how it knows which version of 'build' to call in each of the definitions in the 'where' clause
11:43:52 <byorgey> the reason it *doesn't* work if you add type annotations to those calls to 'build' is a little obscure, I don't know if my explanation from before made sense
11:44:20 <Kuba> well, it doesn't seem natural that "a" there is not "the a"
11:44:28 <Kuba> and rather it's some a1
11:44:31 <parcs`> EEVIAC: yes, but that can only be found out by running the iteratee with 'run'. the iteratee may want more input, or it may not like the input and fail, too
11:45:21 <byorgey> Kuba: the way to understand it is that a type like  (a, [Bit])  is just shorthand for  forall a. (a, [Bit])
11:45:49 <byorgey> Kuba: so the 'forall a.' in the local type annotations ends up shadowing the 'a' from the top-level type signature
11:46:01 <Kuba> mhm
11:46:25 <Kuba> byorgey: so, can you bypass it?
11:47:18 <byorgey> Kuba: yes, you can, by enabling the ScopedTypeVariables extension (by putting {-# LANGUAGE ScopedTypeVariables #-} at the top of the file)
11:48:55 <Kuba> byorgey: I inserted this line as the first line of the file... and I get the same error
11:49:18 <byorgey> Kuba: hmm, just a second
11:49:22 <Kuba> aah, no sorry
11:49:33 <Kuba> stupid, I accidentally put it as a comment
11:49:48 <Kuba> byorgey: you were, indeed, right
11:50:19 <adamt> if i implement a function like foo (Bar x y z) = ... can i then, somehow, access the entire "Bar" somehow?
11:50:21 <Kuba> byorgey: well, thank you for all advice
11:50:26 <byorgey> Kuba: ah, ok, good =)
11:50:30 <byorgey> Kuba: you're welcome
11:51:23 <Kuba> adamt: I've seen something along these lines: foo bar@(Bar x y z) = you can use "bar' here . But i'm no expert
11:51:41 <adamt> Kuba: Thanks, i'll try that!
11:59:23 <Kuba> byorgey: is there a general name for "{-# LANGUAGE" constructs?
11:59:43 <ClaudiusMaximus> pragma
11:59:44 <byorgey> well, the whole thing is called a LANGUAGE pragma
11:59:52 <byorgey> the things that go inside it are just called extensions
12:00:45 <Kuba> thanks, I'll read more about that
12:01:00 <ClaudiusMaximus> http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/pragmas.html
12:05:32 <otters> fuq
12:05:42 <otters> "No match in record selector char"
12:05:48 <otters> no line number
12:06:53 <ClaudiusMaximus> otters: +RTS -xc   might help
12:09:14 <edro4838> Does Haskell Regex.Posix character classes sample : [:alpha:], if so is there a good tutorial for using Haskell Regex ?
12:10:18 <geekosaur> Tex.Regex.Posix supports what the platform's POSIX regex library supports.  that *should* include charclasses, but the bindings don't test that
12:11:52 <ClaudiusMaximus> there is this which mentions an "invalid character class" return code: http://hackage.haskell.org/packages/archive/regex-posix/0.95.1/doc/html/Text-Regex-Posix-Wrap.html#t:ReturnCode
12:12:40 <edro4838> I've been trying 'isAlpha = makeRegex "[[:alpha:]]" ::   Regex' and variants and cin't get it to compile.
12:13:33 <Kuba> gonna be going, once again thanks for help!
12:17:34 <donri> edro4838: i suggest you use the rex package so you get compile-time syntax checking of the regexen
12:20:36 <rwbarton> edro4838: can't get it to *compile*?
12:20:58 <stbuehler> hi! i get a warning "Top-level binding with no type signature" for stuff like "constValue = 55 :: Word8"
12:21:34 <stbuehler> two questions: can i disable the warning in the file itself? and is there a good reason why this "misc" mode still results in a warning?
12:21:50 <rwbarton> constValue :: Word8 [newline] constValue = 55
12:21:59 <stbuehler> (i know how to fix it, but... well, there are a lot of constants, and it seems wrong to double the line count)
12:22:20 <rwbarton> constValue :: Word8; constValue = 55   -- :P
12:22:24 <rwbarton> uh
12:22:24 <byorgey> stbuehler: (1) yes, with {-# OPTIONS_GHC -fno-warn-missing-signatures #-}, and (2) not really
12:22:35 <monochrom> did you know: you can merge many type signatures as e.g. "a, b, c, d, e :: Word8"
12:22:53 <stbuehler> byorgey: thx!
12:28:08 <rasfar> monochrom, I had no idea; is that in H98?
12:28:52 <donri> should be; i've seen it used in the data-lens packages which claim to be h98
12:28:58 <donri> unless i'm misremembering
12:29:02 <nh2> how do I make a simple socket server? http://www.haskell.org/haskellwiki/Simple_Servers seems outdated, where can I find a recent example?
12:29:18 <donri> nh2: maybe conduit?
12:29:46 <monochrom> it is haskell 98
12:30:05 <nh2> donri: I don't mind which way as long as it's simple and has an example
12:30:13 <rasfar> hmph!
12:30:32 <sp3ctum> hi. can someone enlighten me on what the difference between class constraints (e.g.) ((Show a) => a -> a) and forall a is?
12:30:44 <monochrom> in fact I learned it from haskell 98's Prelude sample code!
12:30:57 <sp3ctum> I read this https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types but i cannot find a difference. maybe i'm just tired.
12:31:49 <adamt_> does anybody know about something like [a] -> b -> [(a, b)]?
12:31:50 <hpc> sp3ctum: "forall VARS. TYPE" basically just means "VARS are type variables"
12:31:59 <monochrom> "forall a. a -> a" can only be id or non-termination. "Show a => a -> a" can be more interesting
12:32:03 <hpc> :t map
12:32:04 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
12:32:25 <adamt_> (except for combining zip with something like a -> [a])
12:32:28 <hpc> forall gets trickier when you put it inside parens
12:32:31 <hpc> :t runST
12:32:32 <lambdabot> forall a. (forall s. ST s a) -> a
12:32:43 <hpc> but that's not particularly important
12:33:14 <hpc> type classes say "whatever this type is, it needs to be kinda like this"
12:33:19 <hpc> :t lookup
12:33:20 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
12:33:45 <Alan> is it possible to have a parameter type that is a function of any arity?
12:33:50 <hpc> sp3ctum: so that type there says, "a and b can be any type, but a had better be something we can compare for equality"
12:34:18 <monochrom> another example. "forall a. a -> Int" can only give the same number regardless of parameter, or non-termination. "Enum a => a -> Int" can give a variety of numbers
12:34:18 <sp3ctum> hpc, ok. but why have forall at all? is it just the same without it?
12:34:21 <hpc> Alan: yes, but it's eeeeeevil
12:34:38 <hpc> sp3ctum: it's the same without it, most of the time
12:34:38 <Alan> hpc: :(
12:34:51 <Alan> tell you what, this might be easier if i just show you my code
12:34:52 <sp3ctum> "most" of the time? :)
12:34:55 <hpc> you can safely ignore foralls until they appear inside parenthesis
12:34:56 <Alan> although i'll be embarassed...
12:35:00 <Alan> and then tell you what i'm trying to do
12:35:11 <hpc> but that's higher-rank types, and you'll definitely know when you're bumping into those
12:35:26 <sp3ctum> hpc, okay. maybe i'll go with that for the time being
12:35:38 <sp3ctum> thanks for explaining
12:35:42 <Alan> https://github.com/alanbriolat/foostack/blob/master/src/FooStack/Asm.lhs
12:35:55 <hpc> Alan: basically, you need a type class to express the type of a variadic function
12:36:00 <hpc> :t printf -- for instance
12:36:01 <lambdabot> forall r. (PrintfType r) => String -> r
12:36:12 <monochrom> "Show a => a -> a" is shorthand for "forall a. Show a => a -> a"
12:36:54 <Alan> my specific problem is that encodeInstruction and decodeInstruction basically duplicate the mapping between an Instruction constructor and a Chunk
12:37:09 <monochrom> so it seems strange to "compare" constraints and forall. they are not even mutually exclusive.
12:37:14 <Alan> is there actually a sensible way to implement that bijective mapping?
12:37:55 <Alan> so that the Chunk for each Instruction constructor is only defined once?
12:38:44 <adamt_> is there a built in function that does something like: f (a, b) -> f a b        ?
12:39:04 <hpc> Alan: hmm
12:39:06 <monochrom> curry and uncurry. not built in. library.
12:39:06 <hpc> adamt_: uncurry
12:39:28 <adamt_> thanks a lot to both of you.
12:39:56 <hpc> Alan: i can think of a couple of ways to do it, but they're all horrible
12:40:12 <seven> hi
12:40:26 <rasfar> that looks ill-typed to me; unless (a,b) ~ a
12:40:29 <Alan> hpc: all as horrible as the inevitable errors caused by trying to keep 2 halves of a bijective mapping in sync?
12:40:45 <donri> rasfar: yea i think it wasn't meant as a type signature
12:41:08 <rasfar> yeah, i'm still trying to decide what was meant :p
12:41:18 <Alan> hpc: my ideas so far center on treating the constructors like an enum
12:41:19 <hpc> Alan: oh, how about, instead of
12:41:20 <hpc> > decode8 (Chunk 8 0xF0) = decodeArity2 4 LD
12:41:21 <hpc> > decode8 (Chunk 8 0xF1) = decodeArity2 4 LDB
12:41:21 <hpc> > decode8 (Chunk 8 0xF2) = decodeArity2 4 ADD
12:41:21 <lambdabot>   <no location info>: parse error on input `='
12:41:22 <lambdabot>   can't find file: L.hs
12:41:22 <lambdabot>   <no location info>: parse error on input `='
12:41:23 <hpc> -- etc
12:41:27 <hpc> whoops
12:41:32 <hpc> instead of that, have
12:41:37 <rasfar> likely the curry/uncurry answer was appropriate since adamt_ seemed satisfied by that
12:41:38 <jmcarthur> Alan: you can make a little dsl for describing formats of instructions that generates serializers and deserializers for you
12:41:38 <hpc> binaryMapping :: whatever
12:41:41 <Alan> haha, lambdabot doesn't like LHS pastes...
12:41:45 <hpc> binaryMapping 0xF0 = LD
12:41:55 <hpc> binaryMapping 0xF2 = LDB
12:41:55 <hpc> etc
12:41:56 <jmcarthur> Alan: but this is thought about a lot without much progress, generally
12:42:16 <Alan> hpc: but what is the type of binaryMapping? this is why i was asking about variadics
12:42:24 <adamt_> rasfar: well i have a tuple with two elements that i need unpacked into two arguments.
12:42:36 <Alan> hpc: my constructors all have different signatures
12:42:45 <adamt_> rasfar: so uncurry sounded reasonable.
12:43:01 <hpc> Alan: oh, crap
12:43:07 <rasfar> adamt_: okay, I guess it wouldn't be the same "f" on both sides though?
12:43:11 <Alan> hpc: :)
12:43:15 <donri> adamt_: yea you probably want uncurry. it's just that what you sampled looks like a type signature that doesn't type check. :)
12:43:37 * ski is wondering what constructors Alan is talking about ..
12:43:42 <rasfar> (even as a re-write at the expression level it baffles me)
12:44:04 <adamt_> rasfar: same f on both sides. i just need something like *(a b) in python.
12:44:07 <donri> like, Functor f => f (a,b) -> f a b -- here the "f" type constructor takes different number of parameters
12:44:13 <hpc> Alan: i could probably figure out a nice way given about half an hour, but my brain is tapped out from figuring out how to get svnserve to use a relative root over ssh
12:44:16 <hpc> :(
12:44:18 <Alan> ski: the constructors for Instruction in https://github.com/alanbriolat/foostack/blob/master/src/FooStack/Asm.lhs
12:44:30 <donri> rasfar: the -> wasn't meant as a function arrow
12:44:31 <Alan> hpc: i don't envy you
12:44:54 <hpc> heh, the trick was to move svnserve to svnserve.bin, and turn svnserve into a shell script that passed the right -r
12:45:16 <hpaste> seven pasted “Interact” at http://hpaste.org/68433
12:45:17 <monochrom> a clear wording is "is there a converter that does converter f (a,b) = f a b" or "is there a converter that does converter f a b = f (a,b)"
12:45:25 <rasfar> i sense that i'm even slower than usual today so i'll let it go now...
12:45:31 <seven> can some1 please look
12:45:36 <ski> Alan : hm, i'm not sure what you want to do with them ..
12:45:42 <Alan> hpc: well thanks for the interest, i'll have to take another look once i've finished getting owned by civ5 AIs...
12:45:52 <hpc> Alan: :D
12:45:57 <adamt_> but, uncurry is (a -> b -> c) -> (a, b) -> c, i'm not sure how that helps me
12:46:02 <ski> Alan : actually, i realize i have to leave now :/ -- maybe i can take a look at it later
12:46:16 <hpc> Alan: my first guess would be something to do with GADTs, actually
12:46:20 <Alan> ski: it's fine, i'm about to context switch too
12:46:37 <adamt_> oh. uncurry f (a, b), apparently i'm just too stupid.
12:46:39 <seven> and allso when i type "da" it says "no no!" for interact but "ne" when I call tit "da" from prelude
12:47:04 <byorgey> seven: getContents means to read the *entire* contents of stdin, i.e. all the contents forever.  You probably want to use getLine if you want to just read a single line at a time.
12:47:26 <byorgey> seven: that's because  "da" is not the same as "da\n"
12:47:28 <seven> ah ty ill try that
12:47:31 <monochrom> yeah, getContents captures the complete future
12:47:34 <byorgey> seven: I think that problem will also go away if you use getLine
12:47:44 <byorgey> because getLine does not return the terminating \n character
12:47:45 <seven> ok ty :)
12:48:30 <seven> it works ty :)
12:48:49 <lamefun2> how to case-switch a pair?
12:48:53 <lamefun2> for example
12:49:13 <lamefun2> case shape1, shape2 of  Circle, Circle -> ... Triangle, Circle -> ...
12:49:15 <donri> > case (1,2) of (a,b) -> (b,a)
12:49:16 <lambdabot>   (2,1)
12:50:28 <monochrom> case (shape1, shape2) of (Circle, Circle) ->
12:51:41 <Twey> lamefun2: You always need the brackets
12:55:16 <zachk> welcome, welcome all
13:33:53 * hackagebot htiled 0.0.3 - Import from the Tiled map editor.  http://hackage.haskell.org/package/htiled-0.0.3 (ChristianRoedliAmble)
13:35:19 <parcs`> su
13:35:22 <parcs`> oops ;)
13:36:07 <byorgey> #
13:39:33 <jonaskoelker> parcs`: sudo switch window :-P
13:41:38 <adamt_> Mandatory related xkcd comic: http://xkcd.com/149/
13:45:05 <timthelion> > (reverse $ drop 13 $ reverse "/home/user/foo.grid-haskell")++".hs"
13:45:06 <lambdabot>   "/home/user/foo.hs"
13:46:06 <timthelion> I'm trying to change "/home/user/foo.grid-haskell" to "/home/user/foo.hs", that doesn't seem very smart, since I then have to check if the list is actually that long, and if what I'm dropping is indeed "lleksah-dirg."
13:46:26 <timthelion> What is the proper way?
13:47:00 <zachk> nice adamt_
13:47:12 <byorgey> timthelion: replaceExtension foo "hs"
13:47:21 <byorgey> timthelion: from System.FilePath
13:47:23 <timthelion> byorgey: :)
13:47:25 <timthelion> thanks
13:48:12 <timthelion> everything that's not a one liner already can be written more robustly as one :)
13:48:16 <statusfailed> I want to make functions to make human-readable strings for some data types. I understand that the Show typeclass is not the way to go- is there a reasonably standard pretty printing module?
13:48:22 <timthelion> @src replaceExtension
13:48:22 <lambdabot> Source not found. It can only be attributed to human error.
13:49:25 <byorgey> statusfailed: there are some standard pretty printing modules, e.g. http://hackage.haskell.org/package/pretty .  I do not know of any standard pretty-printing type class.
13:51:07 <statusfailed> byorgey: Hmm, so nothing like "Show" for nicely-formatted stuff?
13:52:34 <statusfailed> I was looking at Text.Printf but that seems to be for a limited set of types only
13:53:40 <gseitz> statusfailed: iirc, edward kmett has something for pretty printing
13:53:59 <gseitz> can't remember if it's in a separate package or part of trifecta
13:54:08 <timthelion> byorgey: Do you know how it works?  I looked at the source and it is: dropExtensions :: FilePath -> FilePath
13:54:11 <timthelion> dropExtensions p = p { pathExtensions = [] }
13:54:15 <zzo38> Does GHC have any command to tell it to import all the instances in all modules in a given directory?
13:54:25 <timthelion> But FilePath is type FilePath = String ! :O :/ :P
13:54:45 <timthelion> well, the source is drop then add
13:54:47 <statusfailed> gseitz: thanks, i'll check it out
13:54:55 <timthelion> but you get my concern
13:55:04 <donri> timthelion: are you sure it's the same FilePath type?
13:55:18 <byorgey> timthelion: do you have a link to the source?
13:55:18 <geekosaur> doesn't sound ike it
13:55:19 <timthelion> donri: that's almost as bad as Haskell not being type safe :D
13:55:29 <timthelion> http://hackage.haskell.org/packages/archive/system-filepath/latest/doc/html/src/Filesystem-Path.html#dropExtensions
13:55:34 <adamt_> what if i want to uncurry a tuple with 3 elements? :o
13:55:40 <adamt_> uncurry twice?
13:55:47 <geekosaur> oh, right, that's a proposed replacement for FilePath
13:55:52 <parcs`> zzo38: you mean like an import declaration?
13:55:55 <geekosaur> adamt_, pattern matching
13:56:17 <geekosaur> tuples are not like lists; a 2-tuple is not compatible type-wise with a 3-tuple
13:56:18 <donri> timthelion: http://hackage.haskell.org/packages/archive/system-filepath/0.4.6/doc/html/Filesystem-Path.html#t:FilePath it defines its own version
13:56:23 <byorgey> timthelion: that is from the system-filepath package, which is different
13:56:33 <byorgey> timthelion: I was talking about the 'filepath' package
13:56:44 <timthelion> byorgey: and the replaceExtension function still works in the "normal" haskell?
13:56:52 <timthelion> OK
13:56:54 <adamt_> geekosaur: I know, but that doesn't make uncurry any different in theory.
13:57:23 <donri> timthelion: are you saying types should never have the same name as any other type in any package on hackage?
13:57:24 <adamt_> i already have too many layers of pattern matching, so i might as well hack my uncurry-3 then.
13:57:56 <geekosaur> adamt_, the function named uncurry is typed for a 2-tuple
13:58:12 <geekosaur> it's not an intrinsic that pulls a chunk off any tuple type
13:58:21 <timthelion> donri: I am merely human, and I happen to have an extremely bad organization skills yet a good associative memory.  I have no hope of keeping things strait of my keywords stop being keys.
13:58:26 <donri> they're already qualified by their module, and package in the worst case
13:58:37 <adamt_> geekosaur: Yes, i realise that. Which was why i was asking whether (or tried to) there was an uncurry that took a 3-tuple :)
13:58:49 <donri> timthelion: good thing haddock links the type to its definition, then! :)
13:59:03 <donri> timthelion: you can click FilePath in the type in the docs for dropExtensions
13:59:09 <timthelion> OK
14:00:49 <donri> @hoogle uncurry3
14:00:49 <lambdabot> No results found
14:00:52 <geekosaur> and hence my original response, "use a pattern match".
14:01:08 <geekosaur> (which got lost to yet another network outage, sigh)
14:01:30 <adamt_> geekosaur: no no, i got that first message.
14:01:48 <geekosaur> yeh, I meant the first time I sent "and hence..." got lost
14:02:20 <geekosaur> (ambiguous language, sigh.)
14:02:21 <donri> in theory uncurry could belong to a type class, but doesn't AFAIK
14:02:57 <geekosaur> I think tuples used to be expensive
14:03:32 <geekosaur> ghc added a bunch of tuple instances for things several years back that hugs still lacks
14:03:47 <geekosaur> ()up from 6-tuples to 15-tuple, I think)
14:04:14 <adamt_> I could also go an entirely different route, but i have no clue how to use map with a function of higher arity than 1.
14:05:17 <zzo38> parcs`: Yes, like import declarations. However instead of specifying each one, I want to automatically import all modules which are in a specified directory, and then a Template Haskell code can find the instances defined there, and so on
14:05:33 <timthelion> geekosaur: it has a lot... http://blogs.gnome.org/wjjt/2012/03/29/if-you-like-a-tool-never-look-at-its-headers/
14:05:44 <mybuddymichael>  /quit
14:05:45 <rasfar> :t zipWith
14:05:46 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
14:05:55 <rasfar> :t List.map3
14:05:56 <lambdabot> Not in scope: `List.map3'
14:06:01 <rasfar> :(
14:06:21 <donri> :t Data.List.map3
14:06:22 <lambdabot> Not in scope: `Data.List.map3'
14:06:33 <rasfar> oh yeah, ... oh no.
14:06:40 <donri> :)
14:06:53 <timthelion> geekosaur: but really, the maximum you ever need is the 2 tuple, since you can package an arbitrary number of types onion style (a,(b,(c,d)))
14:07:04 <adamt_> actually i only need two arguments, not three, in the other case. Hehe.
14:07:43 <geekosaur> timthelion, you can but it's expensive; lots of boxing going on there
14:07:54 <timthelion> geekosaur: expesive preformance wise?
14:08:40 <zzo38> Do you know of any such things about imported instances in GHC?
14:10:19 <geekosaur> zzo38, no, there is no magic auto-import-everything in a directory much less auto-import-every-<some specific thing>
14:12:06 <donri> zzo38: you can export modules so you can reduce lots of imports to one single import everywhere except in that single module
14:13:16 <donri> module Imports (module Export) where import Foo as Export; import Bar as Export...
14:18:27 <zzo38> donri: I know about I could do that; in this case I only need instances though, so that a TH code can produce a list of them. If there is no better way, I suppose I can just make a script which automatically produces the module which only exports all instances in a directory; is there a way to tell cabal to use such scripts?
14:18:55 * hackagebot language-guess 0.1 - Guess at which human language a text is written in.  http://hackage.haskell.org/package/language-guess-0.1 (ChristianRoedliAmble)
14:21:54 <timthelion> it's amazing how much of the Haskell type system's magical ability to prevent bugs consists of typing case m of {Just t -> doSomethingWith t ; Nothing -> return ()}
14:23:30 <zzo38> timthelion: There is also the "maybe" function
14:25:15 <timthelion> zzo38: a little weird though maybe :: b -> (a->b) -> Maybe a -> b means I'll be typing maybe () doSomething m...
14:25:40 <timthelion> or would that be maybe (return ()) doSomething m, either way, it's not any nicer.
14:25:57 <rwbarton> Data.Foldable.forM_ doSomethingWith m
14:26:19 <zzo38> timthelion: To me I prefer that way
14:26:36 <zzo38> rwbarton: O, that, too. OK
14:26:43 <timthelion> zzo38: Freedom is a wonderful thing :)
14:27:27 <zzo38> Will they add the Alternative and MonadPlus instances for Either, and/or the Applicative instance for Q in Template Haskell?
14:28:54 <zzo38> O, they added the Applicative for Template Haskell already, now.
14:35:47 <haziz> Are there man pages for each individual function in Haskell? In other words can I type man fst somewhere and get a man or help page about the function? I am finding the profusion of functions overwhelming!
14:37:56 <sipa> @hoogle fst
14:37:56 <lambdabot> Prelude fst :: (a, b) -> a
14:37:57 <lambdabot> Data.Tuple fst :: (a, b) -> a
14:37:57 <lambdabot> package fst
14:38:05 <sipa> @hackage fst
14:38:06 <lambdabot> http://hackage.haskell.org/package/fst
14:38:11 <sipa> hmm
14:39:03 <donri> haziz: cabal install hoogle; hoogle data; hoogle -i fst
14:43:27 <pingveno> Is there a stdlib function to repeat a given item a certain number of times?
14:43:49 <pingveno> Not infinite, just a finite number of times.
14:43:51 <parcs`> :t replicate
14:43:51 <donri> > replicate 3 a
14:43:52 <lambdabot> forall a. Int -> a -> [a]
14:43:52 <lambdabot>   [a,a,a]
14:44:08 <pingveno> parcs`++
14:44:28 <pingveno> (increment, not concatenate)
14:44:28 <zzo38> haziz: I would like such a things too, better than using HTML, I would think
14:44:46 <roha> hey, id like to try to implement a monad instance of my own (bind, return) of an (existing) monad. do you have any suggestions? (besides list, maybe, state)
14:44:47 <donri> zzo38: see my answer to haziz
14:45:03 <donri> it doesn't give you a full man page but does show you the doc on the terminal
14:45:09 <roha> s/of/on
14:45:32 <zzo38> You can get the type with the :i command of GHCi, but GHCi has no command to display documentation
14:45:47 <donri> roha: read up on monad transformers
14:49:20 <roha> donri, ok thanks. reading the wiki article now :)
14:50:12 <donri> roha: oh i misunderstood...
14:50:16 <donri> @where typeclassopedia
14:50:17 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
14:50:19 <donri> read that. :)
14:50:40 <donri> well, it will show you the code rather than have you guess it. a good read though.
14:50:57 <structuralist> is mueval the preferred way to evaluate haskell in haskell?
14:51:12 <zzo38> The ListT transformer is not so good and doesn't work properly, but there is LogicT which does work.
14:51:15 <donri> structuralist: depends. do you trust the code to evaluate?
14:51:55 <structuralist> donri: not necessarily
14:52:03 <donri> structuralist: if you do, "hint" should suffice. if not, mueval or maybe look at the new "safe haskell" feature (ghc 7.2+)
14:52:25 <structuralist> cool, thanks
14:53:58 <jmcarthur> roha: try this. take any functor f and try making a monad of the form:     data MyMonad a = Foo a | Bar (f (MyMonad a))
14:54:16 <jmcarthur> roha: you should always be able to do it
14:54:31 <jmcarthur> so long as f is a functor
14:55:44 * shapr hugs rtharper 
14:55:52 <lamefun2> hello
14:56:16 <zzo38> jmcarthur: However, it isn't a monad transformer
14:56:33 <rtharper> hihi shapr
14:56:37 <jmcarthur> zzo38: but roha only asked about monads, not transformers
14:56:44 <zzo38> OK
14:59:10 <jmcarthur> zzo38: here's a transformer version:    newtype MyMonadTransformer m a = M (m (Either a (f (MyMonadTransformer m a))))
14:59:47 <zzo38> jmcarthur: Ues I know about that already
15:00:04 <zzo38> Except you made a slight mistake
15:00:19 <jmcarthur> ?
15:00:46 <zzo38> jmcarthur: Can you find the mistake?
15:01:09 <roha> jmcarthur, thanks!
15:01:30 <jmcarthur> i don't think i made a mistake. note that i'm assuming that you plug in some f instead of using it as a variable. you could bind it on the rhs if you really wanted
15:01:38 <jmcarthur> *the lhs
15:01:57 <timthelion> I have two modules, Cell and Grid(which imports Cell), and all of a sudden, I needed a function in Cell to contain the type Grid.  And so I have to move all of my functions out of Cell into a new module to prevent recursive imports.  I feel like Haskell is in the dark ages on this point :(
15:02:03 <zzo38> jmcarthur: My idea of the similar thing as you wrote, does put f as a parameter
15:02:23 <jmcarthur> yeah, you could make a generic free monad transformer that way
15:02:43 <jmcarthur> i was just going to have roha inline the f so he has a chance to see what's going on with a concrete type
15:03:04 <jmcarthur> i also left out the whole transformer thing for the same reason
15:03:54 <zzo38> timthelion: Do you know about -XFlexibleContexts and -XTypeFamilies and {-# SOURCE #-}? These are some ways to solve such a problem too
15:04:30 <timthelion> zzo38: No, I didn't, last time I asked about it it wasn't suggested.
15:04:47 <jmcarthur> zzo38: how do those extensions help with recursive imports?
15:05:17 <jonaskoelker> when I ask happy to parse "1 +" (a valid prefix) in my pretty vanilla expression grammar, it dies with "Internal Happy error" rather than calling the user error handler.  Have anyone seen the same thing?  How to handle?
15:05:23 <zzo38> (You can use -XFlexibleContexts to call a function before it is defined; with a class C and then use the context (C ()) on functions that require to call functions that cannot be imported yet)
15:05:48 <zzo38> (Zero-parameter type classes would help better, but Haskell does not support any such things)
15:05:52 <timthelion> 0_o
15:05:58 <jmcarthur> that sounds terrible
15:05:59 <jmcarthur> :)
15:06:03 <hpc> jonaskoelker: can you reproduce the error in as few lines as you can?
15:06:25 <rwbarton> hpc: yes, he can :P
15:06:26 <jonaskoelker> hpc, is that either a tautology or a non-tautology? ;-)
15:06:27 <timthelion> zzo38: I think I'll just move back to coding in Python with inline C thanks.
15:06:49 <jonaskoelker> gimme' two secs
15:07:25 <zzo38> timthelion: OK, if that is what you prefer. Would you consider Ibtlfmm codes (my own idea of a programming language related to Haskell)?
15:07:35 <timthelion> zzo38: Or perhaps in C with a macro'd in partial python implementation :)
15:08:24 <zzo38> timthelion: Enhanced CWEB allows C codes to be executed in the preprocessor as well as using C codes for the program code itself
15:08:34 * timthelion didn't find anything on google for Ibtlfmm
15:08:56 * hackagebot cmu 1.8 - Unification in a Commutative Monoid  http://hackage.haskell.org/package/cmu-1.8 (JohnRamsdell)
15:09:05 <zzo38> timthelion: There is nothing on Google for it. I have no documents yet, and even when I do, they won't be on Google.
15:09:07 <timthelion> zzo38: I was joking.
15:09:23 <timthelion> zzo38: why wouldn't they be on google?
15:10:30 <zzo38> timthelion: I don't put stuff on Google. But it might be found on my gopherspace, or on HTTP if you know the exact URL
15:10:31 <strager> @pl m >>= \n -> return $ \t -> C (n t)
15:10:32 <lambdabot> (C .) `fmap` m
15:11:15 <jonaskoelker> it went away when I shaved down my grammar to ~nothing
15:11:44 <timthelion> zzo38: So you aren't soo closed source corporate as to want your code to die with you, but rather such a hippy paranoid opensource person that you want your code to die with you :)
15:12:07 <barrucadu> People still use Gopher?
15:12:14 <zzo38> I do not wish my code to die with me; backups are permitted and encouraged
15:12:27 <zzo38> barrucadu: Yes, it is still in use.
15:12:54 <roha>  jmcarthur, do you mean something like this: data MEither a = Error a | Success (Either (MEither a))  ?
15:13:14 <timthelion> zzo38: but only by those obscure few who know you exist.
15:13:29 <emias> [A[A
15:13:31 <zzo38> roha: That is a kind mismatch
15:13:52 <jonaskoelker> hpc: I think I got it.  Thanks for prodding me :-)
15:14:14 <hpc> :D
15:15:00 <zzo38> timthelion: No, I would put them on a Hypernet service (something of my own invention) therefore the files can be kept even if you have no internet connection, even if you have no telephone, mail, whatever, even if you do not know what the files are
15:15:45 <barrucadu> Why are you distributing your code through such obscure channels?
15:17:36 <zzo38> barrucadu: Well, I think gopher is better protocol for many purposes. Hypernet is also better in that the government cannot get rid of it or use it to spy on anyone
15:18:08 <timthelion> zzo38: why not use an already widespread darknet?
15:18:11 <barrucadu> Other than you, how many people use Hypernet?
15:18:14 <mauke> the government doesn't have to get rid of it if it doesn't exist in the first place
15:18:38 <zzo38> barrucadu: Even I don't use it; it doesn't exist.
15:18:42 <jonaskoelker> hpc: what was happening was that I was evaluating the `remainingTokens' parameter when looking at end-of-stream; I suspect Happy puts a bottom (error ...) there
15:18:55 <jonaskoelker> that's what a sketchy read of autogen'd code tells me, at least
15:19:11 <zzo38> timthelion: Well, the other ones might require PDF, HTML, internet, etc, but Hypernet is medialess.
15:20:02 <barrucadu> Why not use torrents? With DHT, someone would have to take out every node in the swarm to kill it
15:20:05 <zzo38> So that you could even add Hypernet onto printed books, handwriting, satellite, "sneakernet" transfers, etc
15:20:11 <timthelion> zzo38: so is https://en.wikipedia.org/wiki/Freenet
15:20:50 <zzo38> And in addition makes Hypernet completely decentralized (no DNS authority, etc)
15:21:02 <zzo38> (You have to use keys instead)
15:21:30 <timthelion> zzo38: it's easier to simply send a signal towards a supernova and use gravitational mirroring,  that will give you a nice uninteruptable backup which is perfectly restorable 10 million years in the future :)
15:22:04 <roha> zzo38, data MEither a = Error a | Success (Either (MEither a)) seems to be OK now, but it doesn't make any sense whatsoever :)
15:22:05 <timthelion> no government will ever catch it, for it will flee at the speed of light
15:22:19 <zzo38> timthelion: That is not the point.....
15:22:38 <monochrom> @quote monochrom faster
15:22:39 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
15:23:05 <timthelion> :)
15:25:09 <lamefun2> trainingText = sepBy (many1 (letter <|> digit)) spaces
15:25:21 <lamefun2> and unexpected end of input at non-existent line 2
15:25:29 <lamefun2> Parsec
15:25:44 <timthelion> zzo38: did you fail to interpret the obvoious intent of humor in my statement?
15:26:19 <zzo38> The problem with Freenet is that it still requires a web browser and internet
15:26:32 <timthelion> zzo38: nope, you can sneekernet it
15:28:00 <zzo38> While Hypernet is designed not to use HTML or that stuff (although you can, of course, use any file you want), because plain text is highly recommended
15:34:15 <otters> hmm
15:52:10 <zzo38> For example Hypernet could have command-line options, -r to receive packets from stdin, -s to send packets to stdout, -a to set addresses, -f to post a file, -k to set keys, -G to act as a plugin to a prefix-based gopher service, other options to set what packets to send/receive, etc. And then, you might use "hyn -s | datatoaudio > /dev/radio" to broadcast Hypernet packets over radio signals, or "zbarscan | hyn -r" to receive packets from QR codes and so on.
15:52:46 <zzo38> And then -d to download a file, -u to upload, -l to list files in a group, ...
15:53:08 <zzo38> And -I for interactive mode
15:53:37 <krey_> o/, what's the best way of understanding callCC & the usage of the Cont r monad? should I read about delimited continuations, or would that just confuse me even more?
15:55:20 <parcs`> @src callCC
15:55:20 <lambdabot> Source not found. My brain just exploded
15:55:24 <zzo38> krey_: I have also read about continuations and know some things about it but I also do not know what the Cont monad has to do with these things; I just know that (Cont r) is like (Codensity (Const r)), and that if r is a monoid then you get a MonadPlus, etc
15:55:57 <Saizan> Cont is not really the monad for delimited ones
15:56:21 <parcs`> krey_: what i did was intermittently stare at the definition of callCC for a couple of months
15:56:30 <adamt_> 'night people.
15:57:46 <krey_> zzo38: what is this interesting Codensity thing of which you speak? i must google
15:58:07 <krey_> parcs`: not sure that's an option for me right now :D
15:58:40 <Eduard_Munteanu> There should be some examples of callCC around.
15:59:47 <parcs`> i don't know of an easy way of understanding it other than thinking about it a lot *shrug*
16:00:03 <krey_> Eduard_Munteanu: I couldn't really find anything useful, the most it seems to do is 'escape'
16:00:57 <Eduard_Munteanu> krey_: yep, it can be used to implement certain control flow structures, like goto and breaking from loops
16:01:31 <parcs`> krey_: callCC captures the current continuation and passes it to the given function argument
16:01:53 <krey_> Eduard_Munteanu: but surely there is more to this mysterious beast. I swear people do crazy things cont + state
16:02:41 <Eduard_Munteanu> Well, yeah, it's pretty powerful as a monad.
16:03:22 <krey_> Eduard_Munteanu: so how can I learn the way of the cont+state?
16:03:27 <krey_> and callcc
16:03:43 <parcs`> read about it? there's lots of documentation
16:04:00 <zzo38> krey_: newtype Codensity f x = Codensity (forall z. (x -> f z) -> f z)  It makes a monad regardless of what f is
16:04:01 <parcs`> play with it, stare at the definitions of >>= and callCC, try to make sense of it
16:04:07 <BMeph> krey_: First learn about continuations in general.
16:04:40 <BMeph> To me, anyway, the Cont Monad doesn't really make sense without knowing how continuations work in genral already.
16:05:21 <krey_> zzo38: yeah, apparently you can make that into a monad over functorz :S
16:05:34 <zzo38> My own Plus class which does not require Functor, like Alternative and MonadPlus but with no superclasses, means Endo is Plus, and (Codensity Endo) is MonadPlus and in fact is a list monad (you get list concatenation for free)!
16:06:45 <Eduard_Munteanu> krey_: more like a free monad for a functor
16:06:47 <zzo38> I understand continuations but not how they are used in Haskell. I understand monads too, I prefer to understand them defined in terms of fmap, return, and join, and have >>= as a combination of fmap with join, instead of the other way around
16:07:41 <Eduard_Munteanu> Yeah, the typeclass should really let you define it in terms of return+join too.
16:07:43 <zzo38> There is a free monad of a functor too, called Free, where (Free (Const x)) is like (Either x)
16:08:44 <Eduard_Munteanu> Kinda helps if you have an adjunction in mind.
16:09:51 <zzo38> Regardless of adjunctions and that stuff, I find return+join+fmap is more sensible to me, while >>= and various other operations are useful shortcut functions
16:10:26 <krey_> zzo38: some of us find >=> more sensible than anything else :P
16:11:02 <zzo38> krey_: Well, >=> is useful, and, return and <=< define the Kleisli category, too
16:11:34 <Eduard_Munteanu> I even wonder if some monads can be more efficiently implemented in terms of either of (>>=) or join.
16:11:45 <krey_> zzo38: I meant to say <=<
16:11:59 <zzo38> krey_: OK
16:12:24 <zzo38> Eduward_Munteanu: They could make it accept both ways, like the Extend class can be defined in terms of extend or duplicate
16:12:47 <Eduard_Munteanu> zzo38: yeah, that's what I mean.
16:13:19 <statusfailed> I have the same problem as this guy: http://hpaste.org/report/55626
16:13:31 <statusfailed> How do I set a default Boolean value with CmdArgs ?
16:13:37 <zzo38> But Haskell programs are difficult to change in this way due to incompatibility and so on. It is one of the thing I intended to fix in Ibtlfmm, so we should invent Ibtlfmm working group to do so.
16:14:38 <Eduard_Munteanu> > map pred "Ibtlfmm"
16:14:39 <lambdabot>   "Haskell"
16:14:41 <parcs`> @src maximum
16:14:41 <lambdabot> maximum [] = undefined
16:14:41 <lambdabot> maximum xs = foldl1 max xs
16:14:51 <Eduard_Munteanu> Sounded too odd to be an acronym :)
16:18:35 <t7> what do you think the next evolution of FP languages will be? (if its not purely function im calling that a devolution)
16:18:58 <Eduard_Munteanu> t7: dependently-typed, maybe?
16:19:27 <t7> they dont seem to be catching on very quickly... but i hear haskell didnt for years
16:20:47 <Eduard_Munteanu> Well, yeah, even languages designed to be popular don't catch on until there are enough libs etc.
16:21:28 <parcs`> i saw a presentation on "liquid types" where properties of function could be automatically inferred
16:21:45 <Eduard_Munteanu> And given lots of DT languages are research-y and mostly geared towards proving stuff rather than programming, that makes it more difficult. Nevertheless, they have been put to some use.
16:21:58 <parcs`> perhaps that's the part of the future of FP
16:22:10 <zzo38> Wha about features of Ibtlfmm, would any of those do?
16:22:39 <Eduard_Munteanu> zzo38: like...?
16:23:15 * Ralith wants dependent typing
16:24:18 <BMeph> zzo38: Really, with all of the blathering on that you do of "Ibtlfmm", it would be handy if you collected it all in one place somewhere... :)
16:24:29 <zzo38> Eduard_Munteanu: Type classes are really just type synonyms of some kind where the final result of kind & is one thing. Another is types {x} where x is a value, has a kind {t} where t is the type of x. One more thing involve, many things are defined in terms of macros, so there is no built-in do-notation/if-then-else/etc
16:24:49 <zzo38> BMeph: Yes I would agree, I will try to write something
16:25:21 <Eduard_Munteanu> zzo38: I'm not so sure about those macros, have you seen Agda's syntax construct?
16:25:37 <Eduard_Munteanu> Pretty powerful in conjunction with mixfix notation.
16:25:51 <zzo38> Eduard_Munteanu: I have seen some things in Agda; but I dislike their use of unicode a lot
16:26:02 <Eduard_Munteanu> Well, apart from that.
16:26:28 <Eduard_Munteanu> You can define do-notation yourself, more or less.
16:26:41 <BMeph> zzo38: When you do, 1) Don't forget to comb through the TUNES logs to make sure you get everything; 2) tell folks about it - maybe some of what you want overlaps with the Haskell'/Haskell2 (are those different?) efforts.
16:27:19 <zzo38> BMeph: I don't know if Haskell'/Haskell2 are different, but yes a few of the things are overlapping a bit, but some are opposite to what they want.
16:27:27 <zzo38> I have the file open right now I am writing some things
16:27:42 * BMeph goes \o/
16:27:50 <parcs`> has anyone here seen the liquid types presentation
16:28:49 <Eduard_Munteanu> parcs`: I just googled that, haven't read it though
16:31:59 <parcs`> it's really awesome. basically it showcases a type inference engine that automatically proves properties of functions -- whether a sorting algorithm actually outputs a sorted list, whether n^2 is >= 0 for all n, etc
16:32:43 <t7> is there a video?
16:32:45 <parcs`> yep
16:32:57 <t7> url plox
16:33:17 <parcs`> http://research.microsoft.com/apps/video/dl.aspx?id=103638 i think that's id
16:33:19 <parcs`> i
16:33:21 <parcs`> it*
16:34:00 <parcs`> yep, it is, because the download link i clicked on that page is still purple :)
16:34:17 <t7> awesome thanks
16:34:44 <t7> is this the thing they added to ghc?
16:35:09 <parcs`> t7: nope this has very little to do with ghc i think
16:36:19 <parcs`> i just mentioned it because the topic of the future of fp came up :) this is like agda, except that the proofs are automatically inferred for you
16:47:14 <crdueck> @src fold1'
16:47:15 <lambdabot> Source not found. My brain just exploded
16:47:23 <crdueck> @src foldl1'
16:47:23 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
17:13:27 <zzo38> Nevertheless if you have idea for features of Ibtlfmm, comment, etc, please tell me anyways. I am currently writing what some of my ideas are, already.
17:15:53 <kmels> zzo38, what is Ibtlfmm?
17:16:09 <zzo38> kmels: A programming language
17:16:25 <kmels> zzo38, do you have the link to it?
17:16:45 <zzo38> kmels: Not yet.
17:16:56 <kmels> paper?
17:16:58 <shachaf> > map succ "Haskell"
17:16:59 <lambdabot>   "Ibtlfmm"
17:17:06 <kmels> oh.
17:17:09 <zzo38> kmels: Not yet.
17:29:23 <lsv> can someone answer this beginner question?  Why does ghci returns True for [3,2,1] > [2,10,100]
17:29:50 <zzo38> lsv: I think it is because 3 > 2
17:30:14 <lsv> but shouldn't it continue checking 2 > 10?
17:30:24 <kallisti> how does it determine ordering?
17:30:26 <kallisti> at that point?
17:30:45 <rwbarton> same reason "cab" > "bat"
17:30:51 <zzo38> lsv: No! Say you have "Apple" and "Banana", surely 'A' < 'B' so it should come first in a sorting, you should not check 'p' > 'a' to make it more...
17:30:58 <kallisti> 3 > 2, 3 < 10, 1 < 100.  now what?
17:31:49 <zzo38> lsv: Perhaps try:   zipWith compare [3,2,1] [2,10,100]    if that is what you want
17:33:23 <kallisti> lsv: the ORd instance for list allows lexicographical string sorting, as well as efficient sorting in general. If you traverse the entire list for each comparison then your sorting is much much slower.
17:33:36 <kallisti> this becomes important when you start storing lists in binary search trees, for example.
17:33:41 <kallisti> to implement sets and maps.
17:33:59 <Ralith> except it isn't remotely about speed
17:34:07 <Ralith> lexicographical sorting is just the standard way to sort things.
17:35:11 <mietek> What is the state-of-the-art high-performance serveer in Haskell?  Snap?  Warp?  Mighttpd2?
17:35:46 <hpc> mietek: the big 3 at the moment are snap, yesod, happstack
17:35:47 <hpc> iirc
17:36:05 <mietek> hpc: you mean web frameworks.
17:36:36 <kallisti> Ralith: it's not "about" speed but that's an advantage it has over a full traversal.
17:36:41 <hpc> they're all servers in the same way xmonad is a WM
17:36:50 <hpc> they are libraries that compile into servers
17:37:01 <Ralith> kallisti: a full traversal isn't a candidate, because it isn't a sane way to sort things.
17:37:10 <kallisti> yes
17:37:19 <kallisti> (?)
17:37:31 <Ralith> it's a strange thing to compare lexicographical ordering with, is all.
17:37:40 <Ralith> as to do so suggests that they are comparable.
17:38:34 <Jed_84> hi all
17:38:39 <lsv> so it is enough to know that 3 > 2, I think I got it.  Thanks.
17:38:44 <Jed_84> is there a function in the haskell library to check if a list is a permutation of another list?
17:39:33 <hpc> (all . elem), perhaps
17:39:47 <Ralith> you'd have to do that both ways
17:39:54 <rwbarton> sort xs == sort ys
17:40:06 <zzo38> Jed_84:  on (==) sort
17:40:16 <hpc> ah right, i forget which one is permutation and which is combination
17:40:30 <Jed_84> i was thinking of using isInflixOf and checking bothways
17:40:38 <lsv> thanks, bye.
17:40:48 <Jed_84> but all/elem is better
17:42:19 <zzo38> Here is Ibtlfmm document right now:    echo 'phlog*c_prog.ibtlfmm-part-i' | nc zzo38computer.cjb.net 70   should download a copy to your computer.
17:42:37 <zzo38> It is not a complete document, I only wrote what some of my ideas are.
17:43:24 <sipa> how does one pronounce its name?
17:43:54 <zzo38> sipa: The same way it is written. "Ib" is one syllable and them "tlfmm" is second one.
17:45:20 <Jed_84> is there an "implies" operator in haskell
17:45:26 <Jed_84> A implies B
17:45:33 <Jed_84> A `implies` B
17:48:05 <Ralith> zzo38: HTTP not good enough for you? :P
17:51:03 <kallisti> what's the significance of a total function?
17:52:00 <hpc> kallisti: ever wondered if your program terminated?
17:52:17 <hpc> ever wondered if it had any conditions that made it crash?
17:52:28 <geekosaur> total functions are defined for all inputs.  head is an example of a non-total function; it throws an exception for an empty list
17:52:39 <kallisti> hpc: a function doesn't have to be well-defined to be total does it?
17:52:42 <hpc> yes
17:52:44 <jmcarthur> > let p .-> q = not p || q in True .-> False
17:52:45 <lambdabot>   False
17:52:52 <hpc> kallisti: that is in fact the definition
17:52:59 <kallisti> you could have inputs that relate to outputs that aren't inputs themselves.
17:53:29 <kallisti> or is "total function" something different from a "total relation"?
17:53:35 <hpc> it's different
17:53:39 <hpc> i think you are confused :P
17:53:40 <kmels> jmcarthur, how do you call this syntax that doesn't use ifs? I'm refering to ||
17:53:48 <kmels> oh that's an OR
17:53:53 <kallisti> silly math terminology
17:53:57 <kmels> but, there is something instead of ifs
17:54:28 <hpc> "f :: A -> B is a total function" => "for all a :: A, (f a) returns a (defined) value of type B in finite time"
17:54:29 <kallisti> so total = well-defined
17:54:43 <hpc> yeah
17:54:50 <hpc> that means no bottoms, no non-termination
17:55:04 <hpc> you can still make infinite lists though, if you are productive about it
17:55:06 <hpc> > [1..]
17:55:07 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:55:11 <kallisti> ah, so in this context, bottom is not a legitimate output
17:55:16 <hpc> (and other data structures)
17:55:17 <zzo38> kmels: Instead of if in Haskell I prefer bool, but I don't know if that is what you meant
17:56:00 <kallisti> zzo38: do you like the functions in Control.Conditional? there's a bool function and other similar things.
17:56:06 <zzo38> Ralith: Gopher protocol better. This way with nc you need not load the web browser program
17:56:19 <zzo38> kallisti: I have not seen it; I defined my own bool in Prelude.Generalize
17:56:31 <kallisti> @hackage cond
17:56:31 <lambdabot> http://hackage.haskell.org/package/cond
17:57:01 <hpc> kallisti: the fun comes when you also take the curry-howard isomorphism
17:57:09 <kallisti> (shameless endorsement of my own code above)
17:57:15 <hpc> @djinn a -> (a -> b) -> b -- proof of modus poens, or whatever
17:57:15 <lambdabot> Cannot parse command
17:57:20 <hpc> @djinn a -> (a -> b) -> b
17:57:21 <lambdabot> f a b = b a
17:57:40 <zzo38> Is  flip id  isn't it?
17:57:50 <hpc> in a language where all values are total, you can't "prove false"
17:57:52 <hpc> as it were
17:58:00 <hpc> @djinn (a -> a) -> a
17:58:00 <lambdabot> -- f cannot be realized.
17:58:10 <zzo38> kallisti: I can try to look later, perhaps
17:58:14 <hpc> "if (a implies a), a is true"
17:58:24 <hpc> is obviously false, because false implies false
17:58:59 <hpc> and in a total language, you can't write a value of that type because the computation of the final result can't be shown to always terminate
17:59:22 <zzo38> hpc: The other thing is, if they had a type for only bijective functions, you may be able to do arithmetic too using Maybe for successors?
17:59:49 <kallisti> hpc: how does bottom technically not count as an element of the codomain for a function?
18:00:14 <kallisti> such that the corresponding element of the domain is defined for that function?
18:00:49 <hpc> can you rephrase that?
18:01:01 <kallisti> I don't know?
18:01:12 <kallisti> f x = bottom
18:01:18 <kallisti> why is f not well-defined now?
18:01:21 <rwbarton> "(defined)" means "not bottom"
18:01:24 <rwbarton> or so
18:01:28 <hpc> yeah, that
18:01:39 <rwbarton> you might also like it to be totally defined, i.e. not contain any bottom subexpressions
18:01:44 <hpc> or more technically, "bottom" = "not defined"
18:01:46 <kallisti> then I learned a different definition of what well-defined means.
18:02:14 <rwbarton> any function that isn't "well-defined" in your sense isn't really a function
18:02:21 <sipa> kallisti: undefined in a language like C means "anything can happen now"
18:02:50 <hpc> bottom includes non-termination, dividing by zero, calling error, calling exitWith, or firing ze missiles and blowing up your laptop
18:02:57 <kallisti> I know what bottom represents.
18:03:00 <kallisti> in that sense.
18:03:07 <rwbarton> like i can try to define a function f :: Bool -> Int by the equations "f False = 4, f False = 7"
18:03:17 <rwbarton> that's a different kind of "not well defined"
18:03:27 <zzo38> I suppose if there are no values of some type, such as:  data Initialize x; instance Comonad Initialize where { extract _ = undefined; };   is valid (although you also need Extend and Functor)
18:03:29 <kallisti> I simply learned that "well-defined" for a function means that there exists an element in the codomain that relates to every element of the domain  (aka it's a function)
18:03:39 <rwbarton> we usually just call those "functions"
18:03:50 <kallisti> but I guess well-defined also means "no element of the domain relates to bottom"
18:04:09 <hpc> kallisti: the two definitions are kinda the same
18:04:24 <hpc> if you say "bottom is not an element of any type"
18:04:25 <kallisti> right
18:04:29 <kallisti> this is the information I'm interested in
18:04:33 <hpc> which is what total languages do
18:04:35 <kallisti> when I ask all these questions.
18:05:08 <kallisti> I see
18:05:20 <zzo38> sipa: And then, what about undefined in a language like LLVM? It is similar to C's undefined, I suppose
18:05:23 <kallisti> but then these functions aren't partial functions?
18:05:29 <kallisti> unless you can redefine partial functions
18:05:34 <kallisti> they're just.. not functions of any description.
18:05:47 <kallisti> if an element of the domain relates to bottom
18:05:50 <hpc> yeah, a partial function would be one where the codomain includes bottom
18:05:58 <hpc> like f(x)=1/x
18:06:35 <zzo38> But there is the category for partial functions too  (Kleisli Maybe)  but still it has to be computable to run it on the computer
18:06:46 <sm> oh nifty, GHC 7.6 will be able to compile with type errors
18:07:09 <kallisti> hpc: erm. if it includes bottom in the codomain wouldn't it be total as well?
18:07:15 <zzo38> sm: What does that mean, specifically?
18:07:52 <rwbarton> usually people do not both include bottom in the codomain and speak of functions which do not have output values associated to some input values
18:07:53 <hpc> ah, right
18:07:57 * kallisti is apparently confused easily by math terminology.
18:08:37 <hpc> kallisti: yeah, let's say the definition of total function is "function whose range contains bottom"
18:08:42 <hpc> er
18:08:48 <hpc> kallisti: yeah, let's say the definition of total function is "function whose range DOES NOT CONTAIN bottom"
18:09:16 <hpc> add bottom somewhere in the function, and it becomes partial
18:09:53 <kallisti> bottom is just a way to make the undefinedness an actual element in the domain/codomain
18:10:06 <hpc> yeah
18:10:06 <kallisti> and you change your definitions of total and partial accordingly?
18:10:20 <rwbarton> right
18:10:24 <rwbarton> the concept is the same
18:10:34 <rwbarton> or, similar enough
18:10:38 <kallisti> blah. things like that in math always confuse me.
18:10:55 <kallisti> where the definitions change minutely but the terminology remains the same.
18:11:07 <hpc> kallisti: once you realize that bottom is magic/special, it gets easier
18:11:14 <sm> zzo38: check out the GHC entry in http://www.haskell.org/communities/05-2012/html/report.html
18:11:25 <hpc> it doesn't help that haskell doesn't keep it special
18:11:29 <rwbarton> the concept is more important than the exact definition anyways
18:11:33 <zzo38> sm: OK
18:11:39 <kallisti> yeah I understood the concept all along..
18:11:45 <kallisti> just not how the terminology changed.
18:11:49 <hpc> it's like the guy who reads LOTR and decides that elves exist
18:12:14 <kallisti> I guess in some sense it becomes easier to talk about undefinedness if you give it a name and stuff it in your sets?
18:12:24 <hpc> yeah
18:12:37 <rwbarton> also now you can more easily compose partial functions, talk about equational reasoning etc.
18:13:27 <rwbarton> composition is just composition, it's not "f(g(x)) if g(x) is defined and otherwise undefined"
18:14:07 <rwbarton> plus, since haskell is lazy we might have f(g(x)) defined even if g(x) is not defined
18:14:22 <zzo38> I do not know about compose partial functions except (Kleisli Maybe) category, in which either one result Nothing is still Nothing, so that is different than that too
18:14:54 <zzo38> But, yes it is possible with lazy programming to make f(g(x)) defined anyways, and so on
18:15:08 <zzo38> (That is, without the (Kleisli Maybe) category, I mean)
18:16:56 <rwbarton> I guess I wandered off-topic somewhat there
18:19:44 <zzo38> In case you want Mozilla search plugin for Hackage:    http://sprunge.us/jNSg
18:20:17 <zzo38> (URLs on sprunge are for direct download; no web browser required)
18:20:52 <hpc> zzo38: hoogle already indexes most of hackage
18:21:05 <Eduard_Munteanu> You could add smart bookmarks, too.
18:21:30 <Eduard_Munteanu> I usually prefer that to getting random search plugins :)
18:21:32 <zzo38> hpc: Well, this one is just a shortcut for direct entry
18:21:42 <zzo38> Eduard_Munteanu: What is smart bookmarks?
18:22:00 <zzo38> I do not think I have that feature on my computer
18:22:24 <Eduard_Munteanu> zzo38: you add a special kind of bookmark with a keyword, so you can say e.g.    wp math    to search Wikipedia for 'math'
18:22:42 <hpc> zzo38: bookmark a url with a "%s" in it somewhere
18:23:07 <hpc> then give it a keyword (need to open the show-all-bookmarks thing)
18:23:22 <hpc> then type the keyword, followed stuff
18:23:24 <hpc> and it interpolates
18:23:29 <zzo38> Eduard_Munteanu: Well, in my computer, the search plugins act like that, if I configure the shortcut "h" for "hackage.xml" search plugin then typing C-l :h base will access the base package
18:23:50 <zzo38> hpc: I don't have that on my computer
18:24:07 <hpc> zzo38: you don't have firefox? :P
18:24:24 <zzo38> hpc: Correct
18:24:40 <Eduard_Munteanu> Ah.
18:25:03 <Eduard_Munteanu> You can just go to http://hackage.haskell.org/packages/archive/pkg-list.html, right-click the search box and choose "add a keyword for this search"
18:25:57 <zzo38> Eduard_Munteanu: Right-clicking the search box does nothing on my computer
18:26:15 <crdueck> @src Right
18:26:15 <lambdabot> Source not found. My mind is going. I can feel it.
18:26:15 <Eduard_Munteanu> zzo38: yeah, I mean in Firefox.
18:26:39 <zzo38> Eduard_Munteanu: O, it works in Firefox.
18:26:59 <Eduard_Munteanu> @src Either   -- crdueck
18:26:59 <lambdabot> Source not found. :(
18:27:01 <hpc> i think the root of all this confusion is you linking us to a firefox search plugin when you don't have firefox
18:27:06 <Eduard_Munteanu> Bah.
18:27:07 <hpc> :P
18:27:17 <Eduard_Munteanu> data Either a b = Left a | Right b    -- :)
18:27:23 <zzo38> hpc: It is not a Firefox search plugin, it is a Mozilla search plugin file.
18:27:43 <zzo38> The program I have supports some of the commands in Mozilla search plugin but not all of them, for example, it does not support icons
18:28:07 <t7> parcs`: this liquid types stuff is awesome
18:28:08 <zzo38> But you can use Mozilla search plugin file in Firefox too.
18:32:12 <parcs`> t7: :)
18:38:21 <zzo38> Is there ephemeris program for use with Haskell?
18:41:51 <geekosaur> zzo38, I couldn't find one last time I went looking
18:44:54 <zzo38> geekosaur: I did not find it either. Do you know how to make such thing?
18:49:52 <sm> something else I learned from HCAR: http://www.cs.kent.ac.uk/projects/heat/ is a nice simple IDE for haskell
18:58:19 <geekosaur> zzo38, all I can suggest is port one from somewhere.  I did the part I needed from a web page, but I needed particular calculations that aren't necessarily astronomically precise
19:14:05 * hackagebot carettah 0.1.0 - A presentation tool writtten with Haskell.  http://hackage.haskell.org/package/carettah-0.1.0 (KiwamuOkabe)
19:14:07 * hackagebot fast-tags 0.0.5 - Fast incremental vi tags.  http://hackage.haskell.org/package/fast-tags-0.0.5 (EvanLaforge)
19:26:34 <zzo38> geekosaur: I have a program which can calculate the distance from here to the moon and so on, called Astrolog, and it is very good with many features, but there are also many things missing, so I wanted to try to make something in Haskell using ephemeris stuff, including not only planets but also ISS, dwarf planets, rotation of planets, etc
19:44:06 * hackagebot carettah 0.1.1 - A presentation tool writtten with Haskell.  http://hackage.haskell.org/package/carettah-0.1.1 (KiwamuOkabe)
19:58:58 <slack1256> somebody here dominates the internals of Control.Parallel.Strategies
19:59:15 <slack1256> i have trouble seeing the need for the "Lift" datatype
20:12:12 <gwern> > 38806 + 45030 + 879 + 4088 + 6244 + 86
20:12:13 <lambdabot>   95133
20:14:07 * hackagebot pandoc 1.9.3 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.9.3 (JohnMacFarlane)
20:15:12 <gwern> > 38806 + 4088
20:15:13 <lambdabot>   42894
20:15:30 <ClaudiusMaximus> slack1256: i don't know.   but the source code comments seem to indicate that it might be used to distinguish Eval (newtype) from Lift (data) to get appropriate strictness behaviour?  http://hackage.haskell.org/packages/archive/parallel/3.2.0.2/doc/html/src/Control-Parallel-Strategies.html
20:15:45 <ClaudiusMaximus> slack1256: maybe the papers referenced in the documentation would explain
20:18:10 <gwern> > 4088 - 38806
20:18:11 <lambdabot>   -34718
20:19:04 <slack1256> ClaudiuMaximus: i don't see any source code comments on the "Lift" datatype
20:19:20 <slack1256> but you are right i should check the papers (or see when was introduced)
20:19:33 <ClaudiusMaximus> slack1256: i just glanced through the most recent paper, and that was before ghc 7.2 was released, so it doesn't have the Lift thing
20:20:22 <tsanhwa> @pl \f d -> isJust (look f d)
20:20:22 <lambdabot> (isJust .) . look
20:21:27 <slack1256> ClaudiusMaximus: you are right!, also GHC 7.2(.1) was a big change because it introduced the primitives spark# y seq#
20:21:38 <slack1256> i will dig through that
20:23:04 <ClaudiusMaximus> i think the data Lift is to put things in a box so that r0 works? (ie, does no evaluation)   not sure..
20:28:08 <slack1256> but was spark# a indicator of possible benefit of parallel evaluation but did nothing of evaluation? (where a lot's of problems with threads that did no work)
20:28:20 <slack1256> well spark# is new so i will check GHC.Conc
20:48:39 <zzo38> I have     type Expander = StateT [Declaration] [];    but now I think that might be wrong because, it may read only some declarations while expanding macros, and then the macros are capable to add new declarations, but we need to keep track of which declaration added on, which the compiler then may need to call the expander again to expand macros in new blocks, etc can you please tell me how to do so?
20:50:49 <zzo38> Do you have any idea?
20:50:58 <zzo38> What do you think would be best way?
21:01:15 <zzo38> Do I need RWST?
21:02:31 <geekosaur> RWST is a fossil
21:02:55 <geekosaur> (superseded by monad transformers)
21:03:15 <shachaf> geekosaur: RWST *is* a monad transformer.
21:03:36 <zzo38> geekosaur: Well, but do you know about what it would do according of what I have written above about the Expander type?
21:03:40 <geekosaur> I think it was intended to be a proof of concept, though; RWS is ReaderT WriterT State
21:05:00 <geekosaur> zzo38, I do not see what Writer (or the Writer component in RWS/RWST) would have to do with what you described
21:07:07 <zzo38> geekosaur: I don't know that is why I asked. But what I was think of is that the monoid is [Declaration] therefore you can add more Declaration on, and ten you read also [Declaration] meaning the declaration already there, or make that using the states, I don't really know it is why I asked, please.
21:07:57 <geekosaur> I am not in a position to figure it out for you
21:08:47 <zzo38> It is confusing me a bit
21:13:17 <frontendloader> Is there a reason take 1 [a] returns type [a] rather than a
21:13:34 <zzo38> frontendloader: Yes, because the number of item to take could be anything
21:13:53 <frontendloader> it clicked in my head right as I was hitting enter
21:14:11 <zzo38> You can use head if you just want the first element (it will be an error if it doesn't have one)
21:20:37 <zzo38> Does Haskell do stable sort?
21:21:00 <shachaf> It is possible to write a stable sort in Haskell.
21:22:17 <zzo38> But does the normal sorting do stable sort?
21:24:32 <slack1256> yes
21:24:37 <slack1256> there is sort which is stable
21:24:46 <slack1256> and unstableSort which doesn't in Data.List
21:25:19 <slack1256> if iirc Data.Sequence also has this two functions
23:04:13 * hackagebot wai-websockets 1.2.0.3 - Provide a bridge betweeen WAI and the websockets package.  http://hackage.haskell.org/package/wai-websockets-1.2.0.3 (MichaelSnoyman)
23:33:46 <liupei> help
23:34:44 <liupei> ?
23:36:08 <coldpizza72i> how do i define a function that has a param of a list of only 1 element
23:36:25 <coldpizza72i> funct (x:_) = ...?
23:38:11 <ClaudiusMaximus> coldpizza72i: (x:_) would match lists of at least one element - you can use [x] as sugar for (x:[]) in patterns too
23:38:11 <jtobin> coldpizza72i: try func (x:[])
23:38:34 <coldpizza72i> thx
23:39:08 <CarlosBoBLopez> hey guys
23:39:14 <CarlosBoBLopez> how come when I type
23:39:22 <CarlosBoBLopez> 91.2 /10
23:39:35 <CarlosBoBLopez> i get
23:39:36 <CarlosBoBLopez> 9.120000000000001
23:39:49 <CarlosBoBLopez> in WinGHCI
23:39:56 <ClaudiusMaximus> welcome to binary floating point
23:39:58 <shachaf> Because that's the value of 91.2/10
23:40:24 <CarlosBoBLopez> hmm
23:40:51 <CarlosBoBLopez> if I type that expression anywhere else I don't get that 1 at the end
23:41:02 <jtobin> you'll get 9.12 if you use float
23:41:06 <CarlosBoBLopez> Claudius could you explain just a wee bit more or give me a link?
23:41:19 <jtobin> > 91.2 / 10 :: Float
23:41:20 <lambdabot>   9.12
23:41:34 <ClaudiusMaximus> > showFFloat Nothing (91.2/10 :: Rational) ""
23:41:35 <lambdabot>   No instance for (GHC.Float.RealFloat GHC.Real.Rational)
23:41:35 <lambdabot>    arising from a u...
23:42:08 <Cale> > 91.2 / 10 :: Rational
23:42:09 <lambdabot>   228 % 25
23:42:31 <Cale> > realToFrac (91.2 / 10 :: Rational) :: Double
23:42:32 <lambdabot>   9.12
23:42:45 <Cale> 91.2 / 10
23:42:46 <Cale> > 91.2 / 10
23:42:48 <lambdabot>   9.120000000000001
23:42:50 <ninegrid> its a beautiful thing
23:43:20 <CarlosBoBLopez> @_@
23:43:33 <Cale> CarlosBoBLopez: It's basically rounding error.
23:43:43 <shachaf> How come when I divide 1 by 3 I get 0.3333333333, but 0.3333333333 * 3 is 0.9999999999?
23:44:03 <coldpizza72i> Im trying to create a function to find the max elem in a list but I'm getting non exhaustion patterns http://pastebin.com/WW7KpaBT
23:44:13 <mauke> The paste WW7KpaBT has been copied to http://hpaste.org/68456
23:44:49 <Cale> coldpizza72i: how are you running that?
23:45:09 <CarlosBoBLopez> Cale: you mean something wrong with the way haskell divides in that case?
23:45:10 <coldpizza72i> maxE [9,8]
23:45:27 <coldpizza72i> is that what you mean
23:45:32 <ninegrid> CarlosBoBLopez: every language has this issue
23:45:43 <shachaf> coldpizza72i: Your patterns aren't non-exhastive.
23:45:52 <shachaf> In fact they're *too* exhaustive; one of them is wrong.
23:46:01 <Cale> maxE [9,8] = maxx 9 (maxE [8]) = maxx 9 8 = if 9 > 8 then 9 else 8 = if True then 9 else 8 = 9
23:46:08 <shachaf> But the issue is probably just that you're not loading your modified code.
23:46:12 <Cale> coldpizza72i: should be no problem
23:46:17 <ninegrid> CarlosBoBLopez: it is the way real numbers are represented by the machine (with finite precision)
23:46:36 <Cale> coldpizza72i: Are you sure you have the right file loaded?
23:46:47 <coldpizza72i> i was defining in interactive mode
23:47:01 <shachaf> coldpizza72i: Do it all on one line.
23:47:06 <Cale> coldpizza72i: In that case, were you redefining maxE over and over?
23:47:19 <ninegrid> CarlosBoBLopez: have a look at this http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
23:47:31 <coldpizza72i> let me just load my file, i need to comment out some stuff first
23:47:51 <CarlosBoBLopez> Thank you everybody.
23:48:46 <CarlosBoBLopez> ninegrid: I'll look at that link. I found it rather weird that this only happened in WinGHCI.
23:49:04 <coldpizza72i> So i know haskell supports a lot of approaches, would you guys recommend the pattern matching for finding the max element like i did?
23:50:03 <Cale> coldpizza72i: Well, there's already a maximum function in the Prelude
23:50:10 <Cale> Also, there's foldl
23:50:32 <ninegrid> CarlosBoBLopez: it happens in ghci on archlinux on my end as well
23:50:44 <coldpizza72i> Cale: its a school assignment to redefine some functions
23:50:45 <Cale> > foldl1 max (words "here is a list of words to find the alphabetical maximum of")
23:50:46 <lambdabot>   "words"
23:51:31 <ninegrid> CarlosBoBLopez: It isn't "weird", consider the information loss in a fixed precision number... you can't think of floating point numbers as "real" numbers
23:51:58 <coldpizza72i> I don't quite understand the folds
23:52:06 <ninegrid> CarlosBoBLopez: the trailing 1 is a pretty insignificant quantity
23:52:26 <Cale> Actually, the way you wrote it is more equivalent to foldr
23:52:38 <Cale> coldpizza72i: Let's take a look at some programs
23:52:43 <Cale> sum [] = 0
23:52:49 <Cale> sum (x:xs) = x + sum xs
23:52:53 <Cale> product [] = 1
23:52:59 <Cale> product (x:xs) = x * product xs
23:53:07 <Cale> concat [] = []
23:53:17 <Cale> concat (x:xs) = x ++ concat xs
23:53:55 <ninegrid> CarlosBoBLopez: just remember that it isn't a shortcoming of haskell, it is a shortcoming (if at all) of computer hardware
23:54:00 <Cale> You should start to see a pattern here, yeah? Everything is like the definition of sum, but with 0 and (+) being replaced by different values.
23:54:48 <Cale> So, rather than write the same program over and over with small changes, we can factor this pattern out
23:55:18 <ninegrid> CarlosBoBLopez: this might be a better introduction to the issue http://en.wikipedia.org/wiki/Floating_point#Accuracy_problems
23:55:24 <Cale> foldr f z will be the function which uses f in the place of (+) and z in the place of 0
23:55:27 <Cale> So
23:55:32 <Cale> foldr f z [] = z
23:55:41 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
23:56:08 <coldpizza72i> I see :)
23:56:11 <Cale> and then we can write  sum = foldr (+) 0;  product = foldr (*) 1;  concat = foldr (++) []
23:56:20 <Cale> and so on, for any other program which looks like that
23:56:42 <CarlosBoBLopez> Ninegrid: Thank you very much.
23:56:55 <coldpizza72i> Cale: what about foldr1?
23:57:05 <Cale> Note also that foldr (:) [] is the identity function
23:57:11 <CarlosBoBLopez> Ninegrid: I get the gist of what you're saying, but I can process it all right now. haha
23:57:20 <CarlosBoBLopez> *can't
23:57:28 <Cale> so you can think of foldr f z as replacing each (:) in the construction of the list with f and the [] at the end (if any) with z
23:57:40 <CarlosBoBLopez> Ninegrid: I'll be sure to study those links.
23:58:08 <Cale> foldr1 is similar, except that it 1) requires a nonempty list, 2) only takes a function parameter, and 3) uses the last element of the list in place of z
23:58:13 <Cale> So
23:58:15 <ninegrid> CarlosBoBLopez: on second thought, just read the second link.  keep in mind that your concept of real numbers isnt represented by the bits in the machine, there are strange gaps on the machine
23:58:22 <Cale> foldr1 f [z] = z
23:58:40 <Cale> foldr1 f (x:xs) = f x (foldr1 f xs)
23:58:57 <CarlosBoBLopez> Ninegrid: Interesting. I'm reading that right now.
23:59:34 <Cale> (note that in the second equation, xs has to be nonempty, or else the first would have matched)
23:59:58 <Cale> So in your case,  maxE = foldr1 maxx
