00:01:48 <ClaudiusMaximus> > let pars = "" : pars >>= \p -> pars >>= \q -> [ p ++ "(" ++ q ++ ")" ] in pars
00:01:52 <lambdabot>   mueval-core: Time limit exceeded
00:05:05 <Veinor> greymalkin: think of it like this: $ is like an open paren that adds a close paren at the end of the line
00:05:21 <Veinor> so f $ x y $ z is f ( x y ( z))
00:07:24 <shachaf> > length $ [1,2,3] :: [Int]
00:07:25 <lambdabot>   Couldn't match expected type `[GHC.Types.Int]'
00:07:26 <lambdabot>         against inferred typ...
00:07:29 <greymalkin> Veinor: I understand how it works. It just doesn't have the kind of clarity that actually opening and closing the parens does.
00:07:38 <otters> > length $ [1,2,3] :: Int
00:07:39 <lambdabot>   3
00:07:56 <ClaudiusMaximus> > let ok = ok' 0 ; ok' _ [] = True ; ok' 0 (')':_) = False ; ok' n (_:ps) = ok' (n+1) ps in filter ok [ replicateM n "()" | n <- [0 ..] ]
00:07:57 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
00:07:57 <lambdabot>         against inferred type...
00:07:57 <Veinor> shachaf: :P
00:08:02 <shachaf> Veinor: Don't convince people to use ($)! It's overused as it is.
00:08:17 <otters> It is not
00:08:34 <greymalkin> otters: And... what was the point of that one?
00:08:40 <greymalkin> length [1,2,3] :: Int
00:08:48 <greymalkin> Worked just fine for me
00:08:52 <Veinor> i generally find f . g h . x y $ z a far more readable than f (g h (x y (z a)))
00:08:52 <solrize> :t flip ($)
00:08:54 <lambdabot> forall a b. a -> (a -> b) -> b
00:08:55 <otters> Yeah
00:09:04 <otters> that's because :: takes the whole statement
00:09:33 <ClaudiusMaximus> > let ok = ok' 0 ; ok' _ [] = True ; ok' 0 (')':_) = False ; ok' n (_:ps) = ok' (n+1) ps in filter ok (concat[ replicateM n "()" | n <- [0 ..] ])
00:09:34 <lambdabot>   ["","(","((","()","(((","(()","()(","())","((((","((()","(()(","(())","()((...
00:09:52 <Veinor> > (2 :: Int) + 3
00:09:53 <lambdabot>   5
00:10:08 <ClaudiusMaximus> any elegant way to generate those without generating everything then filtering?
00:10:55 <shachaf> What's the pattern there?
00:11:04 <ClaudiusMaximus> wait, i messed it up :(
00:11:38 <ski> (s/statement/expression/)
00:11:48 <ClaudiusMaximus> > let ok = ok' 0 ; ok' _ [] = True ; ok' 0 (')':_) = False ; ok' n ('(':ps) = ok' (n+1) ps ; ok' n (')':ps) = ok' (n-1) ps in filter ok (concat[ replicateM n "()" | n <- [0 ..] ])
00:11:49 <lambdabot>   ["","(","((","()","(((","(()","()(","((((","((()","(()(","(())","()((","()(...
00:12:18 <ski> Veinor : i often prefer `(f . g h . x y) (z a)'
00:12:34 <shachaf> > let ok = ok' 0 ; ok' n [] = n == 0 ; ok' 0 (')':_) = False ; ok' n ('(':ps) = ok' (n+1) ps ; ok' n (')':ps) = ok' (n-1) ps in filter ok (concat[ replicateM n "()" | n <- [0 ..] ])
00:12:35 <lambdabot>   ["","()","(())","()()","((()))","(()())","(())()","()(())","()()()","(((())...
00:12:39 <shachaf> Is it that?
00:13:18 <ClaudiusMaximus> shachaf: not quite, i don't require matches, just more lefts than rights
00:13:31 <ClaudiusMaximus> in every prefix
00:14:54 <noor_> hey the haskell platform installer is saying I need Xcode developer tools but I have already installed Xcode, what am I missing?
00:15:59 <shachaf> > let ok ps = all (\s -> length (filter (=='(') s) >= length (filter (==')') s)) (inits ps) in filter ok (concat[ replicateM n "()" | n <- [0 ..] ])
00:16:03 <lambdabot>   ["","(","((","()","(((","(()","()(","((((","((()","(()(","(())","()((","()(...
00:16:04 <shachaf> That?
00:16:14 <Veinor> @type each
00:16:15 <lambdabot> Not in scope: `each'
00:16:21 <Veinor> aw, there's no Omega
00:17:29 <ClaudiusMaximus> shachaf: looks ok to me
00:17:39 <Veinor> let pars = ("":) $ runOmega $ liftM2 (\p q -> p ++ "(" ++ q ++ ")") (each pars) (each pars) in take 20 pars
00:17:42 <Veinor> ["","()","(())","()()","((()))","()(())","(())()","(()())","()((()))","(())(())","()()()","(((())))","()(()())","(())((()))","()()(())","((()))()","(()(()))","()(((())))","(())(()())","()()((()))"]
00:18:12 <shachaf> Veinor: That's not the pattern ClaudiusMaximus is after, though. :-)
00:18:19 <Veinor> well, yeah
00:18:29 <Veinor> but i was curious
00:18:37 <shachaf> But that pattern should be pretty easy to generate.
00:18:52 <noor_> anyone know about my issue?
00:19:39 <shachaf> No one in here. :-(
00:19:40 <shachaf> @google hey the haskell platform installer is saying I need Xcode developer tools but I have already installed Xcode
00:19:44 <lambdabot> http://www.haskell.org/haskellwiki/Mac_OS_X
00:19:46 <lambdabot> Title: Mac OS X - HaskellWiki
00:19:50 <shachaf> Maybe one of the things in that page will be useful?
00:20:21 <geekosaur> noor_, until the new haskell platform is released you need a symlink, I think from /Applications/Xcode.app/Contents/Developer to /Developer
00:20:58 <noor_> great make me learn the terminal why don't you :angry:
00:21:03 <zzo38> Although (Codensity Endo) is a list monad, (Density Endo) is entirely different; it seems to be like ((->) (Product Natural))
00:21:46 <Veinor> zzo38: i understood some of those words!
00:22:08 <ClaudiusMaximus> Veinor: ah, thought something like that woudd be nice, just need to take prefixes
00:22:10 <zzo38> Veinor: Some of them? Is there some you do not understand?
00:22:23 <Veinor> well pretty much anything in parentheses
00:23:04 <shachaf> Well, fortuantely for you the things in the parentheses are the things that you can just look up. :-)
00:23:08 <ClaudiusMaximus> shachaf: thanks, that looks like it might lead to some kind of equational reasoning solution, but unfortunatley my brain isn't up to it at this time of the morning...
00:23:23 <shachaf> ClaudiusMaximus: I am presently barely able to think.
00:23:33 <zzo38> shachaf: Yes
00:23:45 <ski> noor_ : does `ln -s /Developer /Applications/Xcode.app/Contents/Developer' work ?
00:26:08 <noor_> I am scared that link will always be there then I will forget about it and then when I need to fix something I will have no idea what the problem is and also it said something about needing to install a previous version of Xcode to work properly.......
00:26:35 <noor_> @ski
00:26:35 <lambdabot> Maybe you meant: ask src wiki
00:27:11 * ski knows nothing about `Xcode', sorry
00:27:20 <geekosaur> ski:  you got the parameters backwards
00:27:48 <geekosaur> /Developer is the target, not the source (it's where older Xcode used to install)
00:27:52 <ski> geekosaur : dang .. and i even checked the man page to make sure :/
00:28:36 * ski can never remember the parameter order for `ln -s', it seems it's always the other way around
00:28:39 <geekosaur> I'm not sure why but people do seem to get ln's parameters backwards a lot.  it's always source first then destination, just as with cp and mv
00:30:42 <ski> (i tried `touch apa' then `ln -s apa bepa' which made `bepa' a symbolic link to `apa' -- maybe my `ln -s' works differently ?)
00:31:30 <ski> (since surely `apa' here is the destination, and `bepa' the source)
00:31:49 <mm_freak_> can i somehow use SPECIALIZE for types such that all functions are specialized automatically?
00:31:59 <mm_freak_> or for constructors
00:32:27 <zzo38> mm_freak_: I don't know of any way
00:33:52 <geekosaur> ski, you may have explained something... do you think the same way about cp?
00:34:37 <shachaf> @let merge [] ys = ys; merge xs [] = xs; merge (x:xs) (y:ys) = x : y : merge xs ys
00:34:38 <lambdabot>  Defined.
00:34:45 <shachaf> @let gen :: Int -> String -> [String]; gen n x = x : merge (guard (n > 0) >> (gen (n-1) (x++"]"))) (gen (n+1) (x++"["))
00:34:47 <lambdabot>  Defined.
00:34:48 <shachaf> > gen 0 ""
00:34:50 <lambdabot>   ["","[","[]","[[","[][","[[]","[][]","[[[","[][[","[[]]","[][][","[[[]","[]...
00:34:53 <shachaf> ClaudiusMaximus: Something like that?
00:35:09 <geekosaur> because surely the destination is where it is going, not where it is now
00:35:15 <ski> geekosaur : i don't think i've ever thought it similar to `cp'
00:35:22 <ClaudiusMaximus> shachaf: nice!
00:35:42 <shachaf> That doesn't generate them in sorted-by-length order, for one.
00:35:47 <shachaf> But that's the basic idea.
00:35:51 <shachaf> s/the/a/
00:36:04 <geekosaur> it is.  it used to *be* cp.  (on many systems, although not linux, ln / cp / mv are hardlinked or symlinked together)
00:36:34 <shachaf> geekosaur: On Linux they are cp-ed together!
00:36:34 <ski> geekosaur : hm, to make sure, when you said "from /Applications/Xcode.app/Contents/Developer to /Developer", did you maybe mean `/Developer' to be the symlink ?
00:36:39 <shachaf> But since they're the same thing, it works.
00:36:50 <zzo38> And then does it decide what to do from the name they are invoked by?
00:37:15 <geekosaur> ski, yes, /Developer will be the created symlink
00:37:28 <ski> geekosaur : ok, so i think that's where i misinterpreted you then
00:37:41 <ski> in my mind, the symlink is pointing in the other direction
00:37:51 <geekosaur> zzo38, exactly.  (in C the invocation name is passed in argv[0].  this is not available in Haskell for various reasons though...)
00:38:03 <shachaf> @ty getProgName
00:38:04 <lambdabot> Not in scope: `getProgName'
00:38:07 <zzo38> Yes I know it is argv[0], I know about C programming
00:38:10 <shachaf> @hoogle getProgName
00:38:10 <lambdabot> System.Environment getProgName :: IO String
00:39:51 <geekosaur> (actually, why am I still awake?  feh)
00:40:08 <Peaker> argv[0] is only progName by convention, so it would have been better to expose argv[] as is
00:40:08 <Peaker> (Can execute programs with any argv[0] you want)
00:41:11 <geekosaur> indeed, and the polymorphic program via argv[0] is considered deprecated these days, although it is stil used
00:41:45 * ski . o O ( `busybox' )
00:41:46 <zzo38> return (*argv)[strlen(*argv)-2]=='s';
00:42:15 <geekosaur> it's just a bit evil, if convenient (not just ln/mv/cp, but also things like shells being told they're login shells by argv[0][0] being '-')
00:44:00 <geekosaur> and yes, busybox
00:44:23 <zzo38> And does the example I gave work too?
00:45:36 <geekosaur> "work" for what?  (although I could break it trivially by passing a 0- or 1-length argv[0] :)
00:46:15 <geekosaur> (except on those versions of linux which use argv[0][0] == 0 to trigger ldd behavior, although that may have died with a.out)
00:46:57 <zzo38> Well, yes, you could, but doing so will not cause any damage (you might get a segfault but no damage)
00:47:08 <noor_> How long do I have to wait until The Haskell Platform and Xcode (latest) will just "work"
00:47:13 <geekosaur> but at 0345 I am clearly rambling pointlessly.  try that sleep thing again...
00:47:40 <geekosaur> noor_, the last I heard, the next haskell platform was supposed to be out by the end of May; so with luck, under a week.
00:47:44 <noor_> because I cannot find a place to download the previous Xcode and instillation instructions are gauge at best
00:48:00 <noor_> wow that would be nice :) :) :)
00:48:11 <noor_> *vauge
00:48:25 <geekosaur> there is certainly active work on it, and I am under the impression the development code does work (at least as far as xcode is concerned)
00:48:34 <burbul> I have a Parsec parser that's going into an infinite loop (or at least trying something extremely slow) ... can anyone tell me a good way to debug it?
00:48:39 <geekosaur> also, you can find and download older versions, at https://connect.apple.com
00:48:54 <burbul> (In an imperative language I would just step through, figuring out what it was doing.)
00:49:02 <geekosaur> (apple does not make it very easy to track that down... and one cannot link directly to stuff on it)
00:49:37 <zzo38> You could do the same even without the standard libraries:  s=*argv; while(*++s); return s[-2]=='s';
00:49:50 <zzo38> burbul: There is Debug.Trace which could be used
00:50:23 <burbul> so, put a trace statement at the start of each parser?
00:50:41 <burbul> I guess I could, although I have about 30-40 of them, so it would take a while...
00:51:01 <burbul> There isn't a more direct way of seeing e.g. the stages of the beta reduction of a particular expression ?
00:51:03 <zzo38> Just put on one and see if that one is the problem
00:51:10 <burbul> Fair enough -- thanks
00:51:47 <ski> zzo38 : anyway, i see the proofs of the monad laws for `Free f' looks more or less like proofs that lists form a monoid ..
00:52:17 <ski> zzo38 : i still wonder if there's a formulation of it that appeals more to `(>>=)' than to `join', though ..
00:52:31 <ski> (s/it/`Free f'/)
00:52:56 <zzo38> ski: I don't know, but I prefer to have monads defined in terms of join
00:53:19 <ski> i think it depends
00:54:23 <zzo38> Also, (Free ((,) x)) is like (Writer [x]) (although the other value will be at the end of the list, so if it is infinite it has no end)
00:55:34 <zzo38> Proof for monad laws for Free f is like proof of list form a monoid? Well, Free is a backward but not forward monad transformer, and [] is a backward but not forward monoid transformer. Does this meaningful?
00:56:11 <ski> > execWriter (mapM_ (tell . (: [])) [0 ..])
00:56:13 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
00:56:40 <burbul> It's probably my fault, but the laziness of the trace means that I'm not getting anything back...
00:56:50 <ski> i'm not sure what you mean by "backward" and "forward" here
00:57:05 <burbul> None of my parsers are returning anything, so wrapping trace around them doesn't really help
00:57:20 <burbul> I tried wrapping it around a primitive parser that should definitely have been called
00:57:25 <burbul>     trace "x" (string "{")
00:57:39 <burbul> Still didn't get anything back...
00:58:15 <ski> .. sounds strange
00:58:15 <zzo38> ski: What I mean is: Some transfomer makes a new __ for any __ and a forward transformer is a __ homomorphism from the old to the new, while a backward transformer is a __ homomorphism the other way around. (Replace "__" with "monad" and so on)
00:59:02 <zzo38> Is this understandable?
01:00:28 <ski>   incl :: Functor f => f a -> Free f a
01:00:34 <ski>   incl fa = JoinIncl (fmap Return fa)
01:00:39 <ski> are you talking about this one ?
01:02:06 <zzo38> ski: Yes. It is a forward functor transformer but is not a forward monad transformer.
01:02:28 <zzo38> Since, for example,   lift . return = return    does not hold.
01:02:36 <ski>   proj :: Monad m => Free m a -> m a
01:02:39 <ski>   proj (Return      a) = return a
01:02:40 <ski>    proj (JoinIncl mFma) = join (fmap proj mFma)
01:02:43 <ski> or this one ?
01:03:12 <zzo38> ski: Yes, that is the backward monad transformer.
01:04:06 <ski> when you say "backward monad transformer", to me it sounds like you claiming that if `Free m' is a monad, then `m' is a monad
01:04:19 <zzo38> That is not what I mean.
01:04:33 * ski nods
01:04:57 <burbul> wait... I'm getting back something from the trace if I run the code through ghci, but not from the prompt
01:05:00 <burbul> Is that normal?
01:07:33 <ski> zzo38 : hm .. i wonder how to make one with `lift . return = return' ..
01:08:05 <zzo38> ski: It is not possible since Free simply is not a forward monad transformer.
01:09:56 <sipa> burbul: strictness analysis may cause runtime execution order to be different?
01:10:51 <burbul> hmm
01:11:21 <burbul> Surely there is some way to watch the equivalent of the call stack over time?
01:11:30 <burbul> Maybe the order in which things are beta-reduced?
01:11:32 * ski . o O ( `class MonadMonad t where {treturn :: Monad m => m a -> t m a; tjoin :: Monad m => t (t m) a -> t m a; tbind :: (Monad m,Monad n) => (forall a. m a -> t n a) -> (forall a. t m a -> t n a)}; instance MonadMonad CoYoneda where {...}' )
01:13:55 <burbul> ah, wait... do I need to use seq or something like that?
01:14:19 <burbul> And writing things like
01:14:20 <burbul> lambda_var_exp = trace "in " $ liftM LambdaVarExp lambda_var
01:14:24 <burbul> Rather than just
01:14:29 <burbul> lambda_var_exp = liftM LambdaVarExp lambda_var
01:14:34 <burbul> *am writing
01:14:43 <sipa> how do you trace now?
01:14:49 <burbul> but I think the problem is that if none of the functions ever return, none of the traces are being executed
01:15:16 <burbul> I traced by just wrapping 'trace' around the body of each parser
01:15:33 <burbul> But that's only helpful if some of them are returning something
01:15:53 <burbul> I've never used seq before, but I imagine it might help?
01:21:34 * hackagebot Tournament 0.0.1 - Tournament related algorithms  http://hackage.haskell.org/package/Tournament-0.0.1 (EirikAlbrigtsen)
01:24:05 <Peaker> ski: what's that? An alternative to monad transformers?
01:29:00 <ski> Peaker : rather a strengthening
01:29:24 <ski> (`treturn' corresponds to `lift', of course)
01:29:54 <zzo38> It look like a monad of monads (as opposed to a monad of values)
01:33:10 <killy9999> what is the use of "forall" keyword?
01:33:15 <killy9999> http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/other-type-extensions.html
01:33:28 <killy9999> I'm readin this and i don't see what forall is usefull for
01:36:14 <zzo38> killy9999: Do you know what forall (the upside-down "A" shape) does in mathematics?
01:36:19 <killy9999> yes
01:36:50 <zzo38> Well, that is what it is useful for, but in Haskell it is refer to types, specifically.
01:37:03 <ski> consider e.g.
01:37:04 <killy9999> my current understanding is that forall is implicitly added to all the type declarations
01:37:13 <killy9999> so my question is why add it explicitly
01:37:18 <ski>   take :: Int -> [a] -> [a]
01:37:46 <ski> what we mean when we write this is to say that for every type `a', this is a valid type signature for `take'
01:37:53 <ski> so, valid instances are e.g.
01:37:56 <zzo38> Maybe when scoped type variables are used, the forall is used to declare the type variable
01:38:09 <ski>   take :: Int -> [Double] -> [Double]
01:38:20 <ski>   take :: Int -> [[String]] -> [[String]]
01:38:23 <ski> but not
01:38:29 <ski>   take :: Int -> [[String]] -> [Double]
01:39:18 <ski> so, we really mean something like
01:39:21 <ski>   forall a.
01:39:24 <killy9999> ski: yes, but that works without using forall keyword
01:39:25 <ski>     take :: Int -> [a] -> [a]
01:39:33 <ski> or, as it's written
01:39:38 <ski>   take :: forall a. Int -> [a] -> [a]
01:40:10 <mikkihiiri> quick question: if I have a function that has like then lines of where -expressions when they will be evaluated?
01:40:42 <mikkihiiri> only when needed or everytime the function is called?
01:40:43 <ski> this means that `take' itself is polymorphic, that it can be used as having several of the possible specific types above
01:40:48 <ski> consider
01:40:50 <sipa> killy9999: it becomes useful when you need rank-2 types
01:40:59 <ehamberg> mikkihiiri: whenever the result of the expression is needed.
01:41:14 <mikkihiiri> cool! thanks :)
01:41:16 <sipa> killy9999: for example, (forall a. a -> a) -> Int -> Int
01:41:26 <killy9999> GHC manual gives an example: f2 :: (forall a. a->a) -> Int -> Int
01:41:32 <mikkihiiri> really a complex function so where expressions save a lot of readibility
01:41:36 <killy9999> yes, the same :)
01:42:03 <ski> > (take 2 [2.0,2.5,3.3],take 3 [[],["a"],["bc","def"],["ghij","klmno","pqrstu"]])
01:42:04 <lambdabot>   ([2.0,2.5],[[],["a"],["bc","def"]])
01:42:21 <ski> note that *in the same expression*, the two `take's here have *different* types
01:42:31 <killy9999> sipa: the way I understand this signature is that the function takes a->a function and an Int and returns an INt
01:42:42 <killy9999> why is there a need for forall in the declaration?
01:42:54 <ski> killy9999 : now, suppose you want to write a function
01:42:55 <killy9999> Why can't it be (a -> a) -> Int -> Int ?
01:43:03 <ski>   foo take = (take 2 [2.0,2.5,3.3],take 3 [[],["a"],["bc","def"],["ghij","klmno","pqrstu"]])
01:43:13 <ski> killy9999 : what should the type signature of `foo' be ?
01:43:14 <sipa> killy9999: because then you could supply a function Float -> Float
01:43:29 <sipa> killy9999: and it cannot give you an int for an int
01:43:54 <sipa> written explicitly, that would be: forall a. (a -> a) -> Int -> Int
01:44:16 <sipa> which means that the function will receive a function of type (a -> a), with a chosen by the caller
01:44:19 <Taneb> Hello
01:44:30 <ski> `forall a. (a -> a) -> Int -> Int' and `(forall a. a -> a) -> Int -> Int' are *very* different types
01:44:31 <sipa> but it still has to turn an int into an into, no matter what it receives
01:44:40 <ski> the first is the type of a polymorphic function
01:44:48 <killy9999> ski: yes, I understand that they are different
01:44:54 <ski> the second is the type of a function which takes a polymorphic function as an *argument*
01:45:00 <sipa> (forall a. a -> a) -> Int -> Int, means a function that takes an argument of type a -> a for EVERY type a
01:45:16 <sipa> and it is allowed to choose how to instanciate a itself
01:45:37 <sipa> you could only call it with id as argument, or something undefined
01:46:00 <sipa> so it hides from the caller which type a is going to be used
01:46:07 <ski> > let foo :: (forall a. Int -> [a] -> [a]) -> ([Double],[[String]]); foo take = (take 2 [2.0,2.5,3.3],take 3 [[],["a"],["bc","def"],["ghij","klmno","pqrstu"]])  in  foo drop
01:46:08 <lambdabot>   ([3.3],[["ghij","klmno","pqrstu"]])
01:46:10 <ski> > let foo :: forall a. (Int -> [a] -> [a]) -> ([Double],[[String]]); foo take = (take 2 [2.0,2.5,3.3],take 3 [[],["a"],["bc","def"],["ghij","klmno","pqrstu"]])  in  foo drop
01:46:11 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
01:46:11 <lambdabot>         against inferred ty...
01:46:18 <ski> killy9999 : consider those two examples
01:46:29 * killy9999 thinks about them
01:46:50 <ski> (note that the argument `take' actually becomes the function `drop' here :)
01:47:11 <Taneb> Could someone explain to me how forall works?
01:47:49 <killy9999> Taneb: ski and sipe are currently explaining to me how it works :)
01:47:56 <killy9999> s/sipe/sipa
01:47:56 <Taneb> Ooh, I'll logread
01:48:00 <Taneb> :)
01:48:22 <ski> Taneb : maybe start by looking at the end of <http://tunes.org/~nef/logs/haskell/12.05.26>
01:48:34 <Taneb> There already
01:50:45 <Taneb> Well, I've learnt something today
01:50:52 <Taneb> And it's not just that I can't draw
01:51:00 <zzo38> And (forall a. a -> a -> a) is like Bool
01:54:36 <zzo38> And I think (forall a. [a] -> Maybe a) is somewhat like (Natural -> Natural) where the type ensures that the output must be less than or equal to the input
01:54:44 <killy9999> OK, I don't see why the second case doesn't work...
01:55:24 <killy9999> Oh wait, I think I get it
01:55:48 <killy9999> In the first case the function passed as a parameter is inferred two have different type every time it is used
01:56:03 <ski> in the second case, `take' has type `Int -> [a] -> [a]' for one *specific* (but undetermined at the time of type-checking) `a'
01:56:23 <killy9999> And in thes second it is first inferred  that a is Double and when it comes to use String as a there is an error, right?
01:56:32 <ski> yes, in the first case, the parameter `take' is *polymorphic* (because it has a type looking like `forall ...')
01:56:38 <ski> yes
01:56:38 <killy9999> I see
01:56:42 <killy9999> now it makes sense
01:56:44 <ski> in the second case, `take' is monomorphic
01:56:45 <killy9999> thanks!
01:56:55 <ski> it's just that `a' isn't know yet, but it's still monomorphic
01:57:11 <killy9999> so this was 2-nd rank type?
01:57:14 <ski> yes
01:57:48 <killy9999> and higher ranks are when the polymorphism is nested deeper in the type declaration?
01:58:24 <ski> yes, when it's nested to the left of an `->' arrow
01:58:56 <ski> killy9999 : <http://hpaste.org/10060> is a simple example of using a rank-2 type (of `traceFix') to hide implementation details
01:59:53 <ski> if i hadn't used a rank-2 type in
01:59:55 <ski>   traceFix :: (forall m. Monad m => (a ->  m b) -> (a -> m b)) -> (a -> (Trace a b,b))
02:00:03 <ski> i would have had to say
02:00:09 <killy9999> ski: thanks
02:00:51 <ski>   traceFix :: ((a -> Writer (Trace a b) b) -> (a -> Writer (Trace a b) b)) -> (a -> (Trace a b,b))
02:00:56 <zzo38> Am I correct about (forall a. [a] -> Maybe a) and (forall a. a -> a -> a)?
02:01:17 <ski> and then the caller of `traceFix' could access my private tracing state in the callback argument -- which i wanted to avoid
02:02:07 <ski> zzo38 : `forall a. a -> a -> a' is basically `Bool', yes (iirc, this is related to yoneda, and CPS)
02:03:01 <killy9999> ski: honestly I don't understand much of that, probably because I don't understand monads yet, but I'll save that on my private wii for later
02:03:10 <zzo38> And (forall a. (a -> a) -> a -> a) is like natural numbers
02:03:50 <zzo38> ski: I didn't know it is related to Yoneda and CPS, but, OK. But what about (forall a. [a] -> Maybe a)? Do you know that one?
02:05:32 <ski> no, i haven't seen that before
02:06:22 <zzo38> Neither have I because I just made it up
02:06:41 <ski> some days ago, someone here suggested trying to write a program that computes the number of (total) elements of a (potentially) higher-rank type, assuming it's finite
02:07:47 <zzo38> The number of elements of things like (forall x. x -> x -> x -> x -> x -> x -> x -> x -> x) is the number of -> in it, I think
02:11:21 <zzo38> I think (forall a. [a] -> a) is uninhabited but (forall a. [a] -> Maybe a) is like what I have described; do you think it is?
02:12:27 <Peaker> if you had indexed the list length then:   List n a -> Maybe a       is probably like:   List n a -> Fin (Succ n)
02:12:47 <ski> hm, let's ponder some elements
02:13:29 <ski>   f0 _ = Nothing
02:13:43 <ski>   f1 [] = Nothing
02:13:50 <ski>   f1 (a:_) = Just a
02:14:06 <zzo38> Peaker: Using my idea of natural number types, the type of array of the specified fixed number of elements is (->)
02:14:14 <ski>   f2 [] = Nothing
02:14:31 <ski>   f2 (a:[]) = Just a
02:14:38 <ski>   f2 (_:_:_) = Nothing
02:15:42 <ski>   f3 [] = Nothing
02:15:52 <ski>   f3 (_:[]) = Nothing
02:16:02 <ski>   f3 (a:_:_) = Just a
02:16:13 <ski>   f4 [] = Nothing
02:16:20 <ski>   f4 (_:[]) = Nothing
02:16:29 <ski>   f4 (_:a:_) = Just a
02:16:36 <ski>   f5 [] = Nothing
02:16:44 <ski>   f5 (a:[]) = Just a
02:16:48 <ski>   f5 (_:a:_) = Just a
02:17:40 <ski> hm, i think at this point we need to consider matching on the next tail
02:19:26 <ski> hm, i suspect it grows exponentially
02:20:39 <zzo38> f :: (forall a. [a] -> Maybe a) -> Integer -> Integer; f g x = maybe 0 succ $ g (genericTake x [0..]);
02:22:43 <zzo38> ski: You suspect what grows exponentially?
02:23:18 <ski> the number of functions, given the length of the prefix we allow them to pattern-match on
02:24:57 <zzo38> Is that relevant?
02:25:10 <ski> i'm not sure
02:26:35 <zzo38> The answer can be Nothing, or it can be Just one of the elements of the list; the only way to select them is by index and the only other information you have is the length
02:27:09 <ski> first i was thinking you were missing some functions -- but now i'm not so sure
02:28:29 <zzo38> If the input has 2 elements then the function cannot check what they are, they only know there are two of them, and can have 3 possible outputs
02:30:31 <nand`> tgeeky__: pong
02:30:37 <zzo38> The input list with 2 elements represents the natural number 3 here
02:31:01 <ski> hm, why not `2' ?
02:31:58 <zzo38> O, wait, yes, you are correct
02:32:37 <ski> Peaker : *nod*
02:32:59 <zzo38> Yes it does mean 2
02:34:04 <zzo38> I may have made a typing mistake
02:34:34 <Peaker> In #haskell that's ambiguous
02:34:57 <zzo38> Yes it is, but here I mean I pushed the wrong key
02:38:12 * ski is still trying to understand zzo38 conception of the functions
02:38:52 <ski> do you want `1 + 2 + 3 + 4 + ...' number of functions ?
02:39:19 <ski> (i'm not completely sure my question makes any sense)
02:41:27 <killy9999> another quick question: is Core language used by GHC and the Core language developed in this tutorial: http://research.microsoft.com/en-us/um/people/simonpj/papers/pj-lester-book/ the same language?
02:42:07 <ski> (this all reminds me of bar induction or the fan principle, or something like that ..)
02:48:56 <Guest98390> wc
02:53:08 <ski> oh, of course -- naturally the class i had in mind is smaller than the one zzo38 had in mind
02:54:49 <ski> (since zzo38 is only considered finite lists, while i apparently was also considering infinite streams)
03:13:51 <DaDaDOSPrompt> Is there a generally-preferred Haskell IDE?
03:15:17 <burbul> I really like Leksah
03:15:25 <killy9999> DaDaDOSPrompt: http://ics.p.lodz.pl/~stolarek/blog/
03:15:41 <DaDaDOSPrompt> intriguing
03:15:42 <killy9999> here's a review of Emacs, EclipseFP and Leksah, although very subjective
03:16:04 <gienah> DaDaDOSPrompt: like yeah, there is only leksah, its the only IDE written in totally in Haskell (as far as I know)
03:16:07 <DaDaDOSPrompt> EclipseFP, eh? Intriguing. I can't imagine that being useful unless it seriously alters the very core of Eclipse itself.
03:16:29 <killy9999> why?
03:16:41 <killy9999> I find EclipseFP very useful
03:16:47 <merijn> DaDaDOSPrompt: Many people here (including me) seem to prefer vim/emacs for haskell, though
03:16:47 <DaDaDOSPrompt> Eclipse, at least in all instances I've seen it, has struck me as very Java-centric
03:16:57 <DaDaDOSPrompt> any good vim plugins?
03:17:07 <nand`> there's a haskell-mode for vim but I don't use it
03:17:09 <merijn> (Actually, I prefer vim for almost everything :p)
03:17:26 <mgsloan> http://www.reddit.com/r/haskell/comments/ts8fi/haskell_ides_emacs_vim_and_sublime_oh_my_opinions/
03:17:48 <gienah> DaDaDOSPrompt: there is also ghc-mod, which works with vim (I don't use it, I just build it)
03:17:48 <nand`> (I find the plugin too confusing and/or broken to use in my setup; I may have installed it incorrectly)
03:17:59 <absence> mm_freak_: thanks for the clarifications :) in some of the wires i've ended up ignoring the input and producine (). is it better to produce the input value (like identity) to avoid breaking signal flow?
03:18:02 <merijn> Googling haskell-mode should turn up some stuff, but I mostly just use syntax highlight and autoindent, while having ghci running in a separate tmux pane for interaction
03:18:14 <DaDaDOSPrompt> ah
03:18:17 <nand`> yes, syntax highlight and autoindent work fine for my purposes
03:18:21 <burbul> If you are relatively new to Haskell (like me), Leksah is great because it puts squiggly red underlines under all of your type errors
03:18:31 <burbul> And once you have fixed those there's a very good chance your program will just work
03:18:39 <DaDaDOSPrompt> yes
03:18:41 <DaDaDOSPrompt> hmm
03:18:43 <DaDaDOSPrompt> intriguing
03:18:51 <DaDaDOSPrompt> I wonder if I can get that on a package manager
03:19:02 <nand`> on my secondary monitor I have constantly open a web browser with a good dozen or so hackage docs open as well as an easy method to search hoogle and hayoo
03:19:02 <burbul> -- if you are new to Haskell you will also make a lot of type errors as you are learning so
03:19:07 <killy9999> Eclipse is written in Java and is primarily an IDE for Java, so in that sense it's Java centric
03:19:07 <burbul> It's really useful to have quick feedback
03:19:08 <nand`> that's the main tool I use for haskell development
03:19:19 <killy9999> but there are plugins for other languages
03:19:32 <nand`> DaDaDOSPrompt: I don't know about your distro but a leksah package exists for me
03:19:34 <merijn> burbul: I mostly use ghci for that, I just hit ':r' and you're off
03:19:53 <DaDaDOSPrompt> I mean, let's put it this way killy9999: if I'm writing in Eclipse-FP, and I'm writing Haskell, will I still have a menu button to "Generate Getters/Setter Pairs?"
03:20:01 <killy9999> no
03:20:08 <DaDaDOSPrompt> ah, ok
03:20:10 <nand`> I personally just have a terminal open where I hit up and enter to rebuild; uncovering any type errors
03:20:27 <DaDaDOSPrompt> so the available options become semantically apt for the purpose of writing Haskell then?
03:20:31 <merijn> Eclisp-FP "Generate lenses?" :p
03:20:33 <killy9999> My suggestion is that if you ever worked with eclipse and enjoyed it to try EclipseFP
03:20:37 <nand`> (I also automatically run HLint on every build and enable most GHC warnings, which I recommend)
03:20:43 <DaDaDOSPrompt> Alright
03:20:56 <killy9999> yes
03:20:56 <DaDaDOSPrompt> I've semi-enjoyed it. I suspect it's more capable than I am.
03:21:21 <killy9999> well, if you don't like eclipse then eclipsefp might not be the best choice
03:21:29 <merijn> nand`: Is there some way to globally specify default flags for GHC?
03:21:36 <nand`> merijn: I don't know
03:21:37 <DaDaDOSPrompt> I'd say that I've gotten to roughly the same level of skill in Eclipse as in vim, which is to say that I've not yet left the realms of extreme tedium performing slightly more complex tasks moving text
03:21:41 <merijn> bummer
03:21:48 <killy9999> emacs is also a good choice, but if you don't know it then steep learning curve mught be a problem
03:21:52 <nand`> merijn: you could alias them in your shell of choice
03:22:04 <nand`> eg. in bash alias ghc='ghc -Wall' or whatever
03:22:09 <DaDaDOSPrompt> yeah, my prevalent vim background, alas, keeps me tied to it in some capacity
03:22:25 <DaDaDOSPrompt> and I have not spent the time getting better in it lately
03:22:28 <alpounet> merijn, i tend to just specify them in the cabal file of my project but well, you still have to do it for every project
03:22:30 <merijn> DaDaDOSPrompt: I would use vim in that scenario, mostly because I think that overall my time spend learning vim was some of the best time investment I made
03:22:31 <burbul> merijn: how does ghci help with type errors ? don't you  have to read through all  error messages?
03:22:38 <DaDaDOSPrompt> yeah
03:22:51 <killy9999> and as for leksah
03:22:53 <merijn> burbul: Yeah, but if you just scan for line numbers that's 90% of the error usually :p
03:22:58 <DaDaDOSPrompt> I mean, I guess at this point my big difficulty is that I have ideas I want to express in vim, but I don't know what medium I'd do that with inside the IDE alone
03:23:01 <nand`> I personally don't use cabal, so I just add them to whatever build script I'm currently using; which works fine for me
03:23:11 <killy9999> honestly speaking I fond Leksah to be a real nightmare
03:23:13 <merijn> If that + some reflection is not enough I try to actually read the error
03:23:17 <burbul> merijn: yup, I don't read the content, but Leksah actually underlines the actual token that is causing the error
03:23:22 <burbul> Which I find much more useful than just having the line number
03:23:24 <DaDaDOSPrompt> I can crank out shell scripts to do the job, but ugh, I sort of hate having those things around after a while.
03:23:27 <barrucadu> nand`: For showing most GHC warnings, is -Wall enough?
03:23:46 <nand`> -Wall enables “almost all warnings”
03:23:58 <merijn> burbul: I have a colleague working on an editor that does the same but will actually auto-suggest valid values of the needed type from the current scope
03:24:07 <nand`> for what for details of what that means, I have no clue
03:24:18 <burbul> That sounds even nicer
03:24:35 <killy9999> EclipseFP also underlines errors
03:24:37 <hpc> you might find that -Wall is too many warnings
03:24:40 <merijn> burbul: Which reminds me, he was supposed to e-mail me a paper on it. I'm going to bug him right now :)
03:24:46 <hpc> haskell is generally very good about "if it compiles, it works"
03:24:47 <killy9999> and also has integration with HLint
03:24:50 <burbul> Can anyone tell me the right way of using Debug.Trace.trace with Parsec?
03:25:15 <nand`> I use -Wall together with a handful of -fno-warn- flags, eg. “unused-do-bind”, “type-defaults” and “orphans”
03:25:15 <killy9999> so it can apply HLint's suggestions automatically (and solve some other errors)
03:25:22 <merijn> burbul: Same way you use it anywhere, just put 'trace "my message" $' in front of a line?
03:25:35 <burbul> hpc: that is very true, although I find that the flipside is that in the very small number of cases where it compiles and things aren't working, it can be a nightmare to track things down.
03:25:48 <DaDaDOSPrompt> There's an HLint?
03:25:48 <burbul> merijn: when I do that, I only get the error message printed once (ever)
03:25:54 <merijn> DaDaDOSPrompt: Yup
03:26:03 <burbul> And my code is going into some sort of recursive loop
03:26:04 <nand`> @where hlint
03:26:05 <lambdabot> http://community.haskell.org/~ndm/hlint/
03:26:08 <merijn> DaDaDOSPrompt: hpaste.org uses it to auto-suggest improvements to your paste there
03:26:11 <DaDaDOSPrompt> What's the preferred profiling method for Haskell? Can I profile and/or debug both Haskell and FFI-linked C somehow?
03:26:18 <merijn> burbul: Are you running from GHCI?
03:26:32 <burbul> no
03:26:48 <burbul> well, actually, I was using winghci earlier
03:26:51 <burbul> But it kept crashing
03:26:55 <DaDaDOSPrompt> ?:[]
03:26:55 <lambdabot> Unknown command, try @list
03:26:58 <merijn> Hmm, I had similar problems once. It's because the thunk is only evaluated once, I think\
03:27:19 <DaDaDOSPrompt> the thunk?
03:27:21 <burbul> yes, I'm pretty sure that's it
03:27:24 <merijn> Someone suggested changing it into a function that takes an extra () argument to force reevaluation
03:27:33 <burbul> The problem is that the whole parser is evaluated the first time it's called
03:27:37 <burbul> So I can see which parsers are being used
03:27:39 <burbul> But that doesn't really help
03:27:42 <burbul> http://www.haskell.org/haskellwiki/Debugging#Infinite_loops
03:27:49 <burbul> Has a neat trick, but I only got it to work once
03:27:55 <burbul> The rest of the time ghci crashes
03:28:10 <merijn> DaDaDOSPrompt: Since haskell is lazy not everything (even almost nothing) is evaluated immediately. A thunk is the name for a computation that can be (but is not yet) evaluated
03:28:21 <DaDaDOSPrompt> ah, ok
03:28:21 <burbul> (This is what I mean by it being a bit of a nightmare to track things down... I really love Haskell, but I have no idea how one debugs things!)
03:28:40 <DaDaDOSPrompt> I had an impression, for some reason, that a thunk referred to some specific variation of that concept implemented in C
03:28:49 <burbul> Force revaluation... hmmm.
03:29:03 <DaDaDOSPrompt> an awkward construct of programming language classes long gone
03:29:09 <merijn> DaDaDOSPrompt: "head [1,2,3,4]" does not return 1, it returns a thunk that (when inspected/evaluated) will return 1
03:29:38 <merijn> This is a relevant distinction in some scenarios
03:29:39 <DaDaDOSPrompt> yes. that's sensible enough.
03:29:47 <merijn> > head []
03:29:48 <lambdabot>   *Exception: Prelude.head: empty list
03:29:51 <burbul> Problem is the thing I want to call is referenced in about 30 different places.
03:29:58 <nand`> > let f = head [] in 5
03:29:58 <lambdabot>   5
03:30:00 <merijn> > (\x -> 1) (head [])
03:30:01 <lambdabot>   1
03:30:13 <DaDaDOSPrompt> >head [ 1, 2, 3, 4 ]
03:30:16 <DaDaDOSPrompt> > head [ 1, 2, 3, 4 ]
03:30:17 <lambdabot>   1
03:30:22 <DaDaDOSPrompt> oh my
03:30:27 <merijn> The head thunk is never inspected in my second example, and so the exception never occurs
03:30:28 <DaDaDOSPrompt> how amusing
03:30:51 <merijn> This can be very useful sometimes
03:31:47 <burbul> Is there a way to make ghci display more than 20 lines of history?
03:32:24 <burbul> nm, founded
03:32:27 <burbul> *found it
03:33:18 <merijn> DaDaDOSPrompt: lambdabot can do much cooler things than just evaluate some simple expressions. It can also eliminate superfluous variables from code, generate automatic code corresponding to a type and query Hoogle for type signatures :)
03:33:26 <killy9999> DaDaDOSPrompt: http://en.wikibooks.org/wiki/Haskell/Laziness#Thunks_and_Weak_head_normal_form
03:34:07 <DaDaDOSPrompt> wow, automatic simplification? that's fantastic
03:34:56 <nand`> it can also make code illegible
03:35:00 <nand`> @help pl
03:35:00 <lambdabot> pointless <expr>. Play with pointfree code.
03:35:09 <hpc> @pl \a b c d -> d e a c d
03:35:09 <lambdabot> const . flip flip id . (ap .) . flip . flip ($ e)
03:35:32 <nand`> @unpl const . flip flip id . (ap .) . flip . flip ($ e)
03:35:32 <lambdabot> (\ t _ h -> (\ m -> m e t h) >>= \ ab -> (\ i -> i) >>= \ aa -> return (ab aa))
03:35:39 <hpc> lol
03:35:43 <hpc> "m e t h"
03:35:50 <nand`> Haskell is clearly on drugs
03:35:50 <DaDaDOSPrompt> amazing
03:35:54 <merijn> DaDaDOSPrompt: Eliminating variable names is unfortunately not always simplifcation :p
03:35:58 <DaDaDOSPrompt> lambdabot is high as a kite
03:36:06 <DaDaDOSPrompt> indeed
03:36:10 <DaDaDOSPrompt> well, that's no problem
03:36:19 <DaDaDOSPrompt> variable names can easily be translated back
03:36:26 <DaDaDOSPrompt> doesn't take much to accomplish that
03:36:38 <merijn> @pl \x -> do {foo <- x; bar foo }
03:36:39 <lambdabot> (line 1, column 10):
03:36:39 <lambdabot> unexpected "{"
03:36:39 <lambdabot> expecting variable, "(", operator or end of input
03:36:53 <merijn> Oh, bollocks. I can never get do blocks right for @pl
03:37:10 <DaDaDOSPrompt> In certain respects Haskell puts me in mind of Prolog
03:37:37 <DaDaDOSPrompt> granted, far better in most respects
03:37:39 <merijn> DaDaDOSPrompt: The haskell type system is rather similar to Prolog. Some perverse individuals enjoy programming prolog in the type system :p
03:37:43 <shachaf> @@ @pl @undo \x -> do {foo <- x; bar foo }
03:37:43 <lambdabot>  (bar =<<)
03:37:54 <DaDaDOSPrompt> Prolog was a bit byzantine
03:38:22 <nand`> @help @
03:38:22 <lambdabot>  @ [args].
03:38:22 <lambdabot>  @ executes plugin invocations in its arguments, parentheses can be used.
03:38:22 <lambdabot>  The commands are right associative.
03:38:22 <lambdabot>  For example:    @ @pl @undo code
03:38:22 <lambdabot>  is the same as: @ (@pl (@undo code))
03:38:30 <merijn> @pl \x -> (x >>= \foo -> bar foo)
03:38:30 <lambdabot> (bar =<<)
03:38:38 <DaDaDOSPrompt> It struck me a bit like being bought by the local mill-grinder and made to push a wooden wheel, ala Conan the Barbarian, except in this case the wheel was cast ivory and a bit more refined somehow.
03:39:02 <burbul> Trying to use history with parsec is an exercise in pain... http://hpaste.org/69048
03:39:19 <DaDaDOSPrompt> I mean, I guess the thing I enjoy about prolog, although it irks me when I consider the matter of sorting, is the way iterating over the database is essentially automatic, but at the same time it seems not quite right
03:54:40 <MagneticDuck> I have a silly little question: is there any faster way to write (\x _ -> f x)? Just wondering. ^^
03:55:02 <Botje> @pl \x _ -> f x
03:55:03 <lambdabot> const . f
03:55:20 <MagneticDuck> ah yes that little function
03:55:22 <MagneticDuck> @type const
03:55:23 <lambdabot> forall a b. a -> b -> a
03:55:28 <MagneticDuck> ty
03:56:09 <MagneticDuck> (const . inc) 1 2
03:56:16 <MagneticDuck> > (const . inc) 1 2
03:56:16 <lambdabot>   Not in scope: `inc'
03:56:31 <MagneticDuck> > (const . (+ 1)) 1 2
03:56:33 <lambdabot>   2
03:57:45 <xvilka> hello! I'm writing some raw data analysis program. It consist from two modules - main executable(contain ui, etc) and shared libraries - core, which provide all features. Also this library provide api/bindings to other languages. Need add haskell support too. So, i need to add some C library interface, which will be haskell module, and can be used in external haskell programs. But how i can embed haskell support in main executable (and load that module
03:58:28 <xvilka> i ve found howto write C lib/module for haskell, but can't found how-to embed haskell into program
04:01:15 <Ralith> xvilka: I don't think that's a well supported use case.
04:02:42 <xvilka> Ralith: may be you have tips/hints how-to improve that architecture? or I need just patch/embed ghci in my program?
04:02:42 <mauke> http://www.haskell.org/ghc/docs/latest/html/users_guide/ffi-ghc.html#ffi-library
04:03:10 <Ralith> it's a fine architecture, it's just that afaik haskell doesn't embed very well presently.
04:05:14 <MagneticDuck> hey I'm feeling a bit silly... but I don't quite understand why it's (const . inc) and not (inc . const)...
04:05:54 <mauke> run it in your head
04:06:07 <mauke> (inc . const) x = inc (const x)
04:06:10 <xvilka> Ralith: ok, thx. i'll see what i  can do with it
04:06:26 <MagneticDuck> which is what I would think
04:06:31 <MagneticDuck> inc $ const x
04:06:37 <xvilka> mauke: thx too
04:06:48 <MagneticDuck> const returns a single value that's passed to inc
04:06:56 <MagneticDuck> why (const . inc)?
04:07:07 <MagneticDuck> > (inc . const) 4 5
04:07:08 <lambdabot>   Not in scope: `inc'
04:07:18 <MagneticDuck> > ((+1) . const) 4 5
04:07:20 <lambdabot>   5
04:07:27 <MagneticDuck> ...
04:07:31 <mauke> your examples suck
04:07:41 <mauke> > ((+1) . const) 1 100
04:07:43 <lambdabot>   2
04:07:52 <MagneticDuck> yeah true
04:07:52 <mauke> > ((+1) . const) (1 :: Int) 100
04:07:54 <lambdabot>   2
04:08:09 <mauke> oh, the other one
04:08:19 <MagneticDuck> wait
04:08:27 <mauke> > ((+ (1 :: Int)) . const) 1 100
04:08:28 <lambdabot>   Couldn't match expected type `t1 -> t'
04:08:28 <lambdabot>         against inferred type `GHC.T...
04:08:33 <MagneticDuck> ((+1) . const) doesn't work in ghc
04:08:47 <mauke> yes, because numbers are usually not functions
04:08:50 <mauke> they are in lambdabot
04:08:52 <nand`> :t const
04:08:52 <lambdabot> forall a b. a -> b -> a
04:08:56 <mauke> > 1 "hello"
04:08:57 <lambdabot>   1
04:09:03 <nand`> (b -> a) is not a number thus can't be passed into (+1)
04:09:06 <nand`> normally
04:09:25 <MagneticDuck> oh yes I see
04:09:29 <nand`> > ((+1) .: const) 1 100
04:09:31 <lambdabot>   2
04:09:48 <nand`> > ((+(1 :: Int)) .: const) 1 100
04:09:49 <lambdabot>   2
04:10:05 <nand`> maybe this is more in line with what you wanted (whatever it is you wanted, I wasn't following)
04:10:27 <mauke> > (show . const) 'a' ()
04:10:28 <lambdabot>   Couldn't match expected type `t1 -> t'
04:10:28 <lambdabot>         against inferred type `GHC.B...
04:10:34 <mauke> > (const . show) 'a' ()
04:10:36 <lambdabot>   "'a'"
04:10:53 <MagneticDuck> (const . (+1)) x y = const ((+1) x y) = ...const (x+1) y
04:10:59 <MagneticDuck> what...
04:11:07 <mauke> MagneticDuck: no
04:11:23 <mauke> MagneticDuck: (const . (+1)) x y = (const ((+1) x)) y
04:11:49 <mauke> = (const (x + 1)) y = (x + 1)
04:13:11 <MagneticDuck> we're basically overapplying (+1) here and the left over parameter spills over to const which ignores it...
04:13:11 <nand`> MagneticDuck: your third step is incorrect as well. const ((+1) x y) = const ((x+1) y) which would only work if x+1 is a function
04:13:32 <MagneticDuck> yeah I didn't understand how that could be
04:13:36 <nand`> oh okay
04:13:37 <MagneticDuck> hence the ...
04:13:46 <mauke> MagneticDuck: we're not overapplying (+1)
04:13:57 <MagneticDuck> we're not applying it at all, yes
04:14:11 <MagneticDuck> any other examples along these lines?
04:17:13 <MagneticDuck> oh okay I got it
04:17:24 <MagneticDuck> I'm getting back into haskell as I took a little break.. so I'm a tad rusty
04:18:18 <MagneticDuck> ((const . (+ 1)) x) y = (const $ x + 1) y = x + 1
04:18:22 <MagneticDuck> :P
04:18:29 <MagneticDuck> ty all
04:20:26 <MagneticDuck> and if we wanted to ignore two values that would be (const . const . (+1)) right?
04:20:40 <nand`> :t const . const . (+1)
04:20:41 <lambdabot> forall b b1 a. (Num a) => a -> b -> b1 -> a
04:21:14 <nand`> seems like it
04:21:15 <MagneticDuck> and to ignore the second value we would just use flip
04:21:18 <MagneticDuck> @type flip
04:21:19 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
04:21:33 <MagneticDuck> um...
04:21:38 <nand`> note that (\x _ _ -> x+1) may be shorter and more readable
04:21:44 <MagneticDuck> well yeah true
04:22:04 <nand`> @type Prelude.flip
04:22:05 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
04:22:07 <MagneticDuck> ah
04:22:08 <nand`> in case you're wondering ^
04:22:15 <MagneticDuck> okay
04:22:24 <MagneticDuck> the other one is Data.Functor?
04:22:25 <mauke> > flip const a b
04:22:26 <lambdabot>   b
04:22:35 <MagneticDuck> so...
04:22:35 <nand`> no, the other one is in Cale's sick mind
04:22:46 <mauke> nand`: no
04:22:49 <MagneticDuck> where is it declared
04:22:53 <nand`> @src flip
04:22:53 <lambdabot> flip f x y = f y x
04:22:55 <mauke> @hoogle flip
04:22:55 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
04:22:56 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
04:22:56 <lambdabot> package Flippi
04:23:07 <MagneticDuck> function? not functor?
04:23:11 <MagneticDuck> ah
04:23:13 <MagneticDuck> never mind
04:23:16 <mauke> wrong one
04:23:43 <MagneticDuck> @type flip
04:23:44 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
04:23:48 <MagneticDuck> where is THAT one?
04:24:30 <nand`> :t \f a -> fmap ($ a) f
04:24:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
04:24:36 <mauke> directly in lambdabot
04:24:37 <nand`> hooray for first try
04:24:54 <mauke> that is, State/L.hs
04:25:07 <MagneticDuck> lambdabot .... you confuse me ._.
04:25:14 <mauke> > length cake
04:25:16 <lambdabot>   42
04:25:21 <mauke> > cake !! 0
04:25:21 <nand`> > cake
04:25:22 <lambdabot>   can't find file: L.hs
04:25:23 <lambdabot>   "One 18.25 ounce package chocolate cake mix."
04:25:36 <MagneticDuck> LOL
04:25:37 <mauke> > cake !! 1
04:25:39 <lambdabot>   "One can prepared coconut pecan frosting."
04:25:54 <MagneticDuck> you made me almost choke on a cherry
04:26:02 <MagneticDuck> lesson learned: never use lambdabot while eating
04:26:17 <mauke> > cake
04:26:18 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
04:26:27 <MagneticDuck> cake !! 2
04:26:53 <MagneticDuck> > cake !! 2
04:26:55 <lambdabot>   "Three slash four cup vegetable oil."
04:27:33 <nand`> > find (isInfixOf "cherry") cake
04:27:34 <lambdabot>   Nothing
04:27:45 <MagneticDuck> NOTHING
04:27:57 <MagneticDuck> > find (isInfixOf "putrid") cake
04:27:59 <lambdabot>   Just "That will deodorize and preserve putrid tissue."
04:28:03 <MagneticDuck> O.o
04:28:27 <mauke> > drop 27 $ map head cake
04:28:28 <lambdabot>   "TOOTOOTASCIICAT"
04:28:43 <sipa> > cake
04:28:45 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
04:29:02 <nand`> > take 27 $ map head cake
04:29:03 <lambdabot>   "OOTFOTOTDFFFFFPFCOAUFANTOAT"
04:29:04 <MagneticDuck> find (isInfixOf "cake") cake
04:29:27 <MagneticDuck> > find (isInfixOf "cake") cake
04:29:28 <lambdabot>   Just "One 18.25 ounce package chocolate cake mix."
04:29:32 <nand`> > foldl1 f [0..5]
04:29:33 <lambdabot>   Ambiguous type variable `a' in the constraints:
04:29:33 <lambdabot>    `GHC.Enum.Enum a'
04:29:33 <lambdabot>      a...
04:29:38 <sipa> > map tail cake
04:29:40 <lambdabot>   ["ne 18.25 ounce package chocolate cake mix.","ne can prepared coconut peca...
04:29:49 <sipa> eh
04:29:52 <sipa> > map last cake
04:29:54 <lambdabot>   "........:................'................"
04:30:01 <MagneticDuck> ooh
04:30:44 <MagneticDuck> filter (\x -> last x == ''') cake
04:30:52 <MagneticDuck> > filter (\x -> last x == ''') cake
04:30:53 <lambdabot>   <no location info>:
04:30:53 <lambdabot>      lexical error in string/character literal at chara...
04:30:57 <MagneticDuck> rr
04:31:06 <MagneticDuck> how do you write the ' character?
04:31:08 <nand`> > '\''
04:31:09 <lambdabot>   '\''
04:31:19 <MagneticDuck> > filter (\x -> last x == '\'') cake
04:31:21 <lambdabot>   ["An entry called 'how to kill someone with your bare hands.'"]
04:32:02 <MagneticDuck> > filter (\(x, _) -> last x == '\'') $ zip cake [0..41]
04:32:04 <lambdabot>   [("An entry called 'how to kill someone with your bare hands.'",25)]
04:32:12 <MagneticDuck> > cake !! 24
04:32:14 <lambdabot>   "One cup granulated sugar."
04:32:15 <nand`> > intercalate " " $ map (last . words) cake
04:32:16 <lambdabot>   "mix. frosting. oil. eggs. chips. margarine. sugar. flour. as: crackers. ca...
04:32:22 <nand`> > intercalate " " $ map (head . words) cake
04:32:23 <lambdabot>   "One One Three Four One Three One Two Don't Fish Fish Fish Fish Fish Pull F...
04:32:54 <MagneticDuck> Fish?
04:33:04 <MagneticDuck> > cake !! 9
04:33:06 <lambdabot>   "Fish shaped crackers."
04:33:10 <MagneticDuck> O.o
04:33:14 <MagneticDuck> > cake !! 10
04:33:15 <nand`> > filter ((=="Fish") . head . words) cake
04:33:15 <lambdabot>   "Fish shaped candies."
04:33:16 <lambdabot>   ["Fish shaped crackers.","Fish shaped candies.","Fish shaped solid waste.",...
04:33:29 <MagneticDuck> ...
04:33:31 <nand`> > drop 3 $ filter ((=="Fish") . head . words) cake
04:33:32 <lambdabot>   ["Fish shaped dirt.","Fish shaped ethylbenzene.","Fish shaped organic compo...
04:33:43 <MagneticDuck> okay that's it. what kind of people wrote lambdabot. xD
04:33:55 <nand`> silly people
04:34:14 <MagneticDuck> you don't say
04:34:24 <jonaskoelker> fish shaped ethylbenzene?! :D
04:34:31 <MagneticDuck> like really
04:34:39 <MagneticDuck> fish shaped solid waste gets my O.o though
04:34:42 <Ralith> aren't those portal quotes?
04:34:45 <nand`> > cake !! 14
04:34:47 <lambdabot>   "Pull and peel licorice."
04:34:49 <jonaskoelker> any alex/happy buffs around?
04:35:00 <MagneticDuck> if they were there would be something about combustible lemons
04:35:11 <MagneticDuck> > find (isInfixOf "lemon") cake
04:35:13 <lambdabot>   Just "One cup lemon juice."
04:35:21 <MagneticDuck> > filter (isInfixOf "lemon") cake
04:35:22 <Ralith> no, a specific set of quotes
04:35:22 <lambdabot>   ["One cup lemon juice."]
04:35:27 <MagneticDuck> ah
04:35:34 <Ralith> not ones randomly selected to be annoying.
04:35:43 <Ralith> specifically, I should say
04:36:29 <MagneticDuck> hey just a shoutout... in the world of haskell hackers who uses vim and who uses emacs?
04:36:31 <jonaskoelker> I'm trying to thread an alex lexer through a happy parser, but I just can't make any sense of the docs nor the type errors :|
04:37:24 <nand`> > sum $ concatMap (map ord) cake
04:37:25 <lambdabot>   132221
04:37:38 <t7> MagneticDuck: everyone uses vim
04:37:39 <nand`> MagneticDuck: emacs seems to be on the majority but a lot of Haskellers I know use vim, myself included
04:37:46 <MagneticDuck> xD
04:37:49 <nand`> and by “seems to be” I really have no clue
04:37:57 <MagneticDuck> well two opinions right there
04:38:01 <MagneticDuck> I learned vim
04:38:05 <MagneticDuck> but I use "sublime text"
04:38:15 <MagneticDuck> because it's pretty and has support for most of the vim commands
04:38:16 <nand`> I used to use sublime text before I switched to vim
04:38:27 <nand`> (Sublime Text 2, to be specific)
04:38:30 <MagneticDuck> ever tried vintage mode?
04:38:31 <hpaste> jonaskoelker pasted “The parse is a lie” at http://hpaste.org/69049
04:39:04 <nand`> only problems with ST2 are the fact that it's non-free as well as being too annoying to configure/extend. It also has no support for terminals. I only used it in windows where I had no real terminal to speak of
04:39:07 <augur> what is inversion of control?
04:39:11 <nand`> MagneticDuck: yes, but I feel it's not as powerful/complete as vim
04:39:40 <MagneticDuck> nand: well yes. For instance, it doesn't havce block selection, a feature that's really helpful to make multiline inserts. :/
04:39:52 <jonaskoelker> augur: it's basically providing a set of function to some other function f that runs a main loop or such, and calls back your functions
04:39:53 <nand`> I've never used that in vim either
04:40:24 <MagneticDuck> i'm pretty addicted to vim0~A
04:40:35 <boccato> Since the conversation is on editors... Does any of you use Leksah?
04:40:46 <nand`> we've had this discussion not too long ago
04:40:50 <nand`> a few links were mentioned
04:40:55 <MagneticDuck> yeah I saw that but never got around to trying it out.
04:41:01 <MagneticDuck> looks cool
04:41:18 <nand`> here's one of them http://www.reddit.com/r/haskell/comments/ts8fi/haskell_ides_emacs_vim_and_sublime_oh_my_opinions/
04:41:34 <nand`> I tried leksah for a few minutes but did not enjoy using it off the bat
04:42:39 <jonaskoelker> no help with parsing?
04:43:02 <mrarch> trying the powerful parsec library,  my doubt is  I have to parse integers and I am trying it using Text.Parsec.Token . There is a parser integer which can parse integers , But going through the documentation I cannot find how to run this parser over a string to parse integers. For example there is  [ parse char "d"] for parsing characters
04:47:42 <hpaste> untitled pasted “data structure” at http://hpaste.org/69050
04:48:03 <untitled> how can I create empty list of my data type?
04:48:20 <fmap> []
04:48:21 <fmap> ?
04:48:23 <untitled> here, in the code, line 18 I create a dummy record
04:48:30 <untitled> but want it to be empty
04:48:41 <nand`> let records = []
04:48:48 <nand`> note that “getRecNo” and “getRecNums” are redundant
04:48:56 <nand`> equal to “no” and “nums”, respectively
04:49:29 <untitled> fmap: it complains like: *** Exception: a.hs:14:1-40: Non-exhaustive patterns in function addLine
04:49:40 <untitled> if i do: let records = []
04:49:42 <applicative> the defaultRecord is presumable Rec 0 []
04:49:47 <untitled> addRec*
04:50:32 <applicative> dont use [records] thats a one member list
04:50:42 <nand`> doesn't line 19 through a parser error? wouldn't it be (Rec {no=1, nums=[1,2,3]}) instead?
04:50:48 <fmap> untitled: that's because [records] matches a list with exactly one element
04:51:09 <nand`> or does record syntax bind more tightly than function application
04:51:11 <fmap> not a []
04:52:00 <applicative> addRec = (:) is the definition you want
04:52:11 <nand`> applicative: unless he wants to append, not prepend
04:52:22 <applicative> oops
04:52:28 <nand`> addRec = flip (++()
04:52:30 <nand`> -(
04:52:43 <nand`> oh, still not quite correct
04:52:52 <nand`> flip (++) . return
04:53:08 <nand`> but at that point it's probably best just to define it as addRec r rs = rs ++ [r]
04:53:43 <applicative> addRec rec recs = recs ++ [rec]
04:53:55 <untitled> yep, thanks, that did it
04:54:22 * MagneticDuck is away: I'm away, but back in like 0 seconds or so, + or - an hour
04:54:25 <untitled> nand`: it compiles fine
04:55:39 * MagneticDuck is away: I'm away, but back in like 0 seconds or so, + or - an hour
04:55:55 <nand`> untitled: seems like it
04:55:56 <applicative> untitled: the problem was the brackets around [records], which seem naturalbecause you are thinking of a list, but the bare 'records' can vary over lists
04:55:56 <younder> lol
04:56:06 * MagneticDuck is back (gone 00:00:27)
04:56:14 <untitled> applicative: yep, got it
04:56:31 <younder> not even gone in 60 seconds:)
04:56:31 <untitled> fmap: was pointing it to ;)
04:56:48 <applicative> its a case where the list sugar gets in the way
04:57:41 <nand`> note that depending on the circumstances you may be better prepending while building and then reversing the final result
04:58:29 <younder> Sugar is overrated, I prefer the tersity if Mathematica or Lisp
04:59:04 <mauke> yes, clearly lisp is terse
04:59:10 <untitled> nand`: ok, noted
05:00:30 <younder> mauke, Ok so common Lisp isn't so terse, but Scheme is.
05:01:06 * applicative passes the sugar to mauke
05:03:09 <younder> The newer Scheemes have WAY more batteries included and seem almost like usable languages
05:04:23 <mauke> (define (map f list) (if (null list) list (cons (f (car list)) (map f (cdr list)))))
05:04:32 <younder> Whatever Haskell is cool to, excepts it has too much sugar
05:04:50 <mauke> map _ [] = []; map f (x : xs) = f x : map f xs
05:05:27 <younder> Ok, good point
05:06:46 <hughfdjackson> haskell 1: scheme 0
05:06:55 <hughfdjackson> :p the last of the great rivalries?
05:07:07 <mauke> sugar is what makes terse code possible
05:08:12 <hughfdjackson> too much sugar makes the medicine difficult to understand
05:08:23 <hughfdjackson> as i think i had a small rant about a couple of times here :D
05:08:31 <hughfdjackson> once understood, though, it's generally rather awesome
05:10:30 <younder> the complexity in syntax makes macro's rather difficult though. This is why  Lisp has survived trough all these years.
05:10:58 <younder> Take it or leave it, It has it's fans
05:11:14 <merijn> younder: You're thinking of Racket and friends?
05:11:31 <merijn> (w.r.t. usable Schemes I mean)
05:11:51 <younder> merijn, I am.. I rather like Racket
05:12:05 <merijn> It's still on my to learn list
05:12:25 <burbul> Is anyone here familiar with Parsec?
05:14:42 <applicative> Parsec is the bread and butter of #haskell second only to the Prelude and Data.List
05:15:24 <younder> applicative, You forgot Cabal
05:15:25 <merijn> applicative: Don't forget Data.Functor and arrows :p
05:15:42 * applicative is parser-challenged though, by the incapacity to distinguish right and left
05:15:46 <younder> applicative, and also Darcs
05:16:01 <applicative> but burbul what is your question?
05:16:22 <applicative> if there's  a problematic module you can paste it on hpaste.org  by the  way
05:16:51 <burbul> I wanted something that is like many, but which backtracks over the final separator if it cant find a valid argument after it.
05:16:58 <burbul> So some mixture of many and try
05:17:02 <cozachk> what is hpaste coded in, and if it is haskell what libraries?
05:17:34 <burbul> sorry, not many,
05:17:36 <merijn> cozachk: I forget, but the code is on github I though
05:17:37 <burbul> sepBy
05:17:37 <applicative> cozachk: study https://github.com/chrisdone/hpaste
05:18:02 <burbul> It's not that important though, as I just figured out that I can get away with using sepEndBy
05:18:04 <merijn> cozachk: Haskell it seems
05:18:33 <younder> burbul, I don't think there is anything like that, but it should be..
05:18:57 <applicative> does sepEndBy keep the last separator?
05:19:02 <burbul> yes
05:19:10 <burbul> It's a workaround in my case
05:19:40 <burbul> The problem was that I had some space separated things, possibly followed by a space
05:19:57 <burbul> and when I just used sepBy it saw the final space and thought "aha! I'm expecting another element..."
05:20:21 <applicative> right like optional ; at the end
05:20:32 <burbul> Replacing 'sepBy x whites >> whites' with 'sepEndBy x whites' dealt with the issue.
05:20:35 <burbul> yup
05:20:38 <burbul> Anyway, thanks!
05:22:18 <merijn> I want something like "Map String a" but supporting lookups for partial keys, levenshtein distance, that sorta thing
05:22:22 <applicative> I see I was imagining the last separator might take on a different meaning
05:22:24 <merijn> Any suggestions?
05:23:23 <younder> http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance
05:26:00 <merijn> younder: That seems to be implementations of Levenshtein distance, I was looking for data structures that would simplify doing lookups based on that (if something like that exists)
05:26:50 <burbul> Actually, more generally, is there a sensible policy for dealing with whitespace in Parsec? I'm getting a lot of different whitespace-related bugs. (I suspect most of them are because something is grabbing it in a greedy fashion.)
05:26:58 * hackagebot hjsmin 0.1.2 - Haskell implementation of a javascript minifier  http://hackage.haskell.org/package/hjsmin-0.1.2 (AlanZimmerman)
05:27:30 <jonaskoelker> what's the name for (>>=)?  "Into"?
05:27:40 <ion> bind
05:27:40 <applicative> hm merijn http://hackage.haskell.org/packages/archive/bktrees/0.2.2/doc/html/Data-Set-BKTree.html is set-like not maplike but maybe there is an idea in it
05:27:48 <jonaskoelker> right, thanks :)
05:28:18 <chris2> is =<< then dnib?
05:28:49 <younder> ??
05:29:24 <ion> chris: Sure :-)
05:29:27 <chris2> :)
05:29:38 <chris2> like \in and \ni in tex :D
05:29:55 <hpaste> untitled pasted “return value” at http://hpaste.org/69051
05:29:56 <untitled> and how do you call 2 functions, that return values, and return only the second function's value?
05:30:26 <merijn> applicative: That looks interesting, thanks
05:30:27 <ion> chris: And 1/ohm being called “mho”
05:30:36 <merijn> untitled: Why would you do that?
05:30:44 <chris2> ion: no, thats siemens :P
05:30:54 <ion> chris: It’s *officially* Siemens. :-P
05:30:56 <mauke> untitled: and what do you do with the first value?
05:31:03 <merijn> const would work, but whether that's what you want depends on why you're asking
05:31:13 <untitled> merijn: first I need to create a record, second I want to print message that a record was created
05:31:16 <chris2> people really call that mho, wow :P
05:31:17 <ion> chris: I don’t thinkg (=<<) is *officially* dnib either.
05:31:30 <chris2> is zh then seconds? :P
05:31:32 <merijn> untitled: For IO you just want >>
05:32:17 <merijn> Note that print isn't a function...
05:32:23 <mauke> :t print
05:32:24 <lambdabot> forall a. (Show a) => a -> IO ()
05:32:26 <mauke> it is
05:32:30 <ion> Verily.
05:32:34 <merijn> Well yeah
05:33:39 <merijn> mauke: I meant in the sense that the output behaviour of "print foo" is not a function so the "call 2 functions that return values and return only the second" is a nonsensical question for what he wants
05:34:23 <mauke> you're using a weird definition of "is not a function"
05:34:48 <applicative> untitled: you want this function to print that it has created the record?
05:34:50 <merijn> I didn't actually mean print in the prelude sense, the Prelude is shadowing normal English :(
05:35:00 <younder> No He seams 'pure' function I think
05:35:13 <merijn> I guess I should have said printing to remove the ambiguity
05:35:22 <younder> No He seams he means 'pure' function I think
05:35:23 <untitled> merijn: applicative I just made 1 function for IO and wanted to return ("Created record " ++ getNo) to it
05:35:33 <untitled> and actually create the record too
05:35:50 <merijn> untitled: Do you need the output or is it just for debugging?
05:35:57 <untitled> I need it
05:36:31 <applicative> I have a sense that you will want to refactor this in the end but it's intelligible
05:36:47 <merijn> So want something like "foo :: IO Record" which prints and than returns the record?
05:37:01 <merijn> (or "foo :: a -> IO Record", I guess
05:37:09 <nand`> the “Created record” thing sounds like he wants to log what happens, maybe a writer is more appropriate?
05:37:28 <merijn> Possibly?
05:37:32 <applicative> or i guess String -> [Record] -> IO [Record]
05:38:18 <younder> Yes, that sort of makes sense
05:38:22 <untitled> what's IO [Record]? :)
05:38:44 <mauke> untitled: what is addRec?
05:38:48 <untitled> I print the message in the caller function
05:38:49 <applicative> "do something, launch missles, whatever, and return a list of Records"
05:39:21 <applicative> mauke: addRec was a pure function appending a Record a minute ago
05:39:22 <merijn> untitled: oh, you returning (String, Record) and printing the String in the outer function?
05:39:34 <untitled> mauke: addRecord :: Line -> [Line] -> [Line]
05:39:46 <applicative> whats a Line?
05:39:48 <mauke> untitled: then your code makes no sense
05:39:51 <untitled> mauke: addRecord :: Rec -> [Rec] -> [Rec]
05:39:53 <untitled> sorry
05:40:02 <mauke> untitled: worse, what you're asking for makes no sense
05:40:02 <applicative> mauke, the typechecker already told him that
05:40:22 <mauke> applicative: where?
05:40:32 <untitled> merijn: right
05:41:12 <applicative> http://hpaste.org/69050 mauke I was thinking of this?
05:41:58 <mauke> applicative: that doesn't contain createRec
05:42:23 <applicative> right, we're doing createRec now, as I thought
05:42:51 <mauke> so what was that about the type checker?
05:42:58 <mauke> because createRec is a syntax error
05:43:10 <applicative> the code for createRec wont typecheck
05:43:18 <mauke> no, it won't parse
05:43:38 <applicative> right
05:44:20 <applicative> it will be the same thought if we put do in the natural places
05:44:24 <applicative> thought
05:44:26 <applicative> though
05:44:29 <applicative> grr
05:45:43 <applicative> It seems there is an existing list of records, and here, we accept a string, and expand the record list, while saying we did this
05:46:07 <applicative> thats why I thought createRec :: String -> [Record] -> IO [Record]
05:47:06 <mauke> but createRec has no effects
05:47:16 <mauke> just two return values
05:47:40 <applicative> I think he wants to print "Created record 100" if thats what happened
05:47:49 <mauke> no
05:48:01 <mauke> <untitled> I print the message in the caller function
05:48:32 <untitled> yes
05:48:53 <untitled> I mean I don't even care which way it happens anymore
05:49:14 <untitled> confused =\
05:49:19 <applicative> wait, I guess the 'input'  isnt a String,it's a Record
05:49:26 <untitled> input is a string
05:49:31 <untitled> I parse it
05:49:35 <untitled> it's a command from user
05:49:39 <untitled> to add a record
05:50:51 <untitled> I wish there were void functions in haskell
05:51:05 <mauke> why?
05:51:12 <mauke> haskell is lazy
05:51:15 <applicative> maybe you should write the one with a record as input first, then you can write the one that takes a string, complains if it's no good, but does the former if it is good
05:51:17 <untitled> so I won't have to care about return values
05:51:23 <mauke> untitled: if you don't use the result of a function, it never runs
05:51:32 <mauke> LAZY
05:51:37 <untitled> ok, ok
05:53:02 <applicative> suppose you have a function parseRec ::  String -> Maybe Record , or maybe String -> Either String Record
05:54:37 <applicative> then it's  something like createRec input  records = case parseRec input of Nothing -> putStrLn "bad input, fool"; Just record -> do putStrLn "Created record " ++ show (getNum record)
05:54:41 <applicative> return record
05:55:18 <applicative> return $ addRec record records, rather
05:55:18 <mroman> not caring about return values considered harmful ;)
05:56:45 <younder> mroman, I wasn't aware you had any choice+
05:56:54 <untitled> applicative: thanks, I'll try
05:57:36 <younder> But it really hot here, I am burning up and my brain could feel better.
05:58:09 <merijn> Is there any good place IRC/web/whatever to ask around for algorithms/data structures when Google and friends aren't returning anything useful?
05:58:24 <hpaste> applicative annotated “return value” with “return value (annotation)” at http://hpaste.org/69051#a69053
05:58:37 <mroman> younder: do { _ <- someIO; return (); }
05:58:56 <applicative> untitled: I should have added a line, parseRec = undefined
05:59:18 <mroman> and there is a void in Haskell
05:59:22 <mroman> @type void
05:59:23 <lambdabot> Not in scope: `void'
05:59:29 <barrucadu> Control.Monad (void) iirc
05:59:35 <untitled> applicative: thanks man
05:59:54 <mroman> yes @barrucadu
05:59:58 <applicative> something is wrong with the spacing, remember, no tabs in haskell
06:00:04 <mroman> Functor f => f a -> f ()
06:00:15 <untitled> merijn: there is a chan #algorithms but it's dead 99% of time
06:00:22 <barrucadu> Ooh, someone has updated the Arch Xen package and it now compiles. Time to play with HaLVM…
06:05:49 <burbul> merijn: ehat are you looking for?
06:06:20 <applicative> untitled: http://hpaste.org/69056 is what I intended.  The way the browser shows the input field on hpaste was messing me up
06:06:56 <untitled> ok
06:07:10 <burbul> (I meant, what specific algs/data structures)
06:07:20 <younder>  My mind is rater fried, It is a very hot day here, so have some forbearance for me if I seem stupid..
06:11:52 <applicative> untitled, I forgot to return 'records' in case of error http://hpaste.org/69060  writing in the text field of hpaste is totally hopeless by the way
06:13:07 <burbul> Not on the web, but Cormen Leiserson & rivest is a pretty comprehensive algorithms book. Or sedgwick has written one that is much shorter but still covers most of the standard things.
06:13:38 <burbul> There's a book on functional data structures by okasaki that is apparently very good, though I haven't read it.
06:17:40 <burbul> @pl liftM (\arg f -> Apply f arg) space_then_bracketed_exp
06:17:41 <lambdabot> fmap (flip Apply) space_then_bracketed_exp
06:17:50 <younder> burbul, Yes I have it and recommend it..
06:20:12 <younder> Purely functional data structures osakai might provide some background
06:22:16 <younder> Computational category theory hasn't seen a update since the 80's
06:23:09 <younder> So I find this alot, not to worry just work with it
06:24:18 <younder> You might be the first in the field to add something interesting:)
06:34:31 <mrkronecker> Hello! I'm making a text adventure game. I'd like for it to be possible to save the game's state, but the data object which contains the game state contains lists of first order functions. Is there SOME way in Haskell to serialize first order functions?
06:37:17 <mrkronecker> err
06:37:33 <MagneticDuck> hey there, I have a question... how hard is it to make a little IRC bot?
06:37:45 <mrkronecker> well, s/first order//
06:37:48 <hughfdjackson> easier than it is to magnetise a duck :D
06:37:54 <hughfdjackson> *ahem* sorry
06:37:58 <MagneticDuck> how do I take an IO program and hook it up to IRC
06:38:00 <MagneticDuck> and lol
06:38:10 <MagneticDuck> well actually getting addicted to zen magnets isn't that hard
06:38:29 <MagneticDuck> for a duck of course there are a few technical problems
06:38:54 <hughfdjackson> ahaha
06:39:02 <hughfdjackson> ducks just dont tessellate the same way
06:39:32 <fmap> MagneticDuck: http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
06:39:35 <MagneticDuck> and more importantly our feet don't really have opposable thumbs.
06:39:37 <MagneticDuck> ._.
06:39:56 <hughfdjackson> haha
06:39:59 <hughfdjackson> awwh :( now i feel bad
06:40:05 <hughfdjackson> i also don't have an answer to your question
06:40:08 <hughfdjackson> i just found your name amusing
06:41:03 <MagneticDuck> heh
06:41:09 <MagneticDuck> you know what zen magnets are right?
06:41:11 <MagneticDuck> #magnets
06:42:30 <younder> And how do they relate to Haskell?
06:42:37 <MagneticDuck> math
06:42:38 <applicative> MagneticDuck: here's onebased on the wiki tutorial http://hpaste.org/51064
06:42:48 <MagneticDuck> yeah it looks cool
06:42:50 <MagneticDuck> I'm starting now
06:44:04 <younder> I like Pizza too, but not in my code :)
06:44:23 <merijn> burbul: I was looking for a map like data structure with efficient approximate lookup. I have Cormen, et al. on the shelf here, but those are mostly to basic for what I want now
06:44:30 <dmwit> mrkronecker: You'll need to find a way to represent your data as data if you want to serialize it, sorry.
06:44:44 <mrkronecker> Drat! OK thanks
06:44:51 <merijn> burbul: So far the suggestion of Burkhard-Keller trees from here seems most promising, but I'm hoping there is something a bit more efficient
06:44:56 <MagneticDuck> the duck puts in the last link: "yeah I might be able to make some pizza out of zen magnets". I should probably shut up now and get working.
06:45:18 <dmwit> mrkronecker: Just how infinite are your functions?
06:45:36 <dmwit> Do you have a finite domain?
06:45:48 <younder> merijn, You don't have Donald Knuth's 'The art of programming' That's close to a cardinal sin. Get it at once!
06:46:26 <younder> 'the art of computer programming' sorry
06:46:53 <cozachk> younder: have you read surreal numbers?
06:47:26 <younder> cozachk, I have in Connawys book
06:47:31 <cozachk> ahhh
06:48:14 <cozachk> whats the name of the Conway anthology?
06:49:00 <younder> On Numbers and Games by John H. Conway
06:49:49 <younder> Thats the bit on surreal numbers, but an anthology.
06:49:58 <mrkronecker> dmwit : There are no constraints on the domain, sadly. Like... it is represented as (String -> StateOperation String), but this could be derived from any number of other variables which appear during the course of the game
06:50:08 <younder> But it's not a anthology
06:50:14 <cozachk> the novel by knuth is an entertaining read
06:50:32 <mrkronecker> StateOperation just wrapping some (State -> (a, State))
06:51:04 <dmwit> mrkronecker: You'll have to think a bit, then. =)
06:51:51 <mrkronecker> Thank you. I'll reflect on my options!
06:53:20 <younder> cozachk, It is no novel by Knuth. It is 4 books
06:53:34 * cozachk goes to get the novel 
06:53:58 <younder> # I could accept. But novel shows ignorance
06:55:16 <cozachk> you are correct it is not a novel..
06:55:22 <cozachk> SURREAL NUMBERS
06:55:33 <cozachk> how two ex-students turned on to pure mathematics and found total happiness
06:55:45 <cozachk> a mathematical novelette by D.E. Knuth
06:56:27 <cozachk> ISBN-13 978-0-201-03812-5
06:56:29 <Hayro> #cvv2 #cvv2 #cvv2 #cvv2 #cvv2 #cvv2 #cvv2 #cvv2 #cvv2 #cvv2 #cvv2 #cvv2 #cvv2 #cvv2 #cvv2 #cvv2 #cvv2 #cvv2 #cvv2 #cvv2 #cvv2 #cvv2 #cvv2 #cvv2 #cvv2 #cvv2 #cvv2 #cvv2 #cvv2 #cvv2 #cvv2
06:57:58 <younder> John Conway is not a student he is a professor at Princeton University.
06:58:49 <cozachk> from "SURREAL..." to " "-5" I was typing data out of the novelette titled: Surreal Numbers
06:59:18 <merijn> younder: I actually do have TAoCP :)
06:59:56 * cozachk doesn't but has looked at it before in bookstores 
07:00:13 <younder> I believe you merijn , you were just testing me
07:00:42 <cozachk> surreal numbers were the first mathematical discovery to first be published in literature in a work of fiction
07:02:04 <younder> cozachk, It was not a work of fiction It was was a work of mathe. Surreal numbers are as real as complex numbers.
07:04:50 <mm_freak_> absence: in general yes
07:05:11 <mm_freak_> absence: you will have an easier time using (.)
07:09:37 <merijn> Is there a comparison/conversion function that converts composite unicode characters to their ASCII form (e.g., ë becomes e)
07:10:24 <applicative> I dont think the unicode character is properly called composite
07:10:42 <younder> they most definattly don't
07:10:59 <younder> obviously
07:11:43 <younder> Is that in fact what you mean
07:12:13 <merijn> applicative: I'm pretty sure they're not called that, but I can't be arsed to lookup terminology
07:12:35 <younder> arsed :)
07:14:44 <younder> The point is Unicode is 24 bit and ASCII is 7 bit. So a full conversion is is totally impossible.
07:15:07 <merijn> Yeah, but I don't care about unicode except the bit that is ASCII + modifiers
07:16:17 <merijn> As my input is English, but I want to compare strings ignoring things like diaeresis
07:17:15 <younder> merijn, Oh in hthat case just stribe off the 8 bits. That gives you  Iso-latin-11 the West  European code
07:17:53 <younder> 16
07:18:05 <merijn> That depends on the encoding, doesn't it?
07:18:32 <younder> merijn, No, That is standard in Unicode
07:21:00 <younder> The 8 lower bits in unicode are islo-lation
07:21:06 <younder> latin
07:22:08 <younder> http://unicode.org/
07:22:55 <younder> so you can just strip the lower byte
07:24:11 <younder> And that will work in America and in Western Europe
07:25:54 <younder> Except for the Euro symbol
07:28:25 <dmwit> Um, the lower byte of 'ë' is not 'e'. Not even the lower seven bits of 'ë' is 'e'.
07:28:54 <younder> no and..
07:29:07 <younder> They aree two symbols
07:29:10 <dmwit> ...and the original question was about converting '	`fmap` (eventWindow >>= liftIO . drawableGetSize)
07:29:13 <dmwit> 	`ap`   return now
07:29:16 <dmwit> 	`ap`   liftIO (readIORef posRef)
07:29:18 <dmwit> eh
07:29:24 <dmwit> converting ë to e
07:31:46 <younder> That doesn't even make any sense. It is 2 8 bit characters
07:33:10 <dmwit> Why doesn't it make sense? It looks like a perfectly cromulent question to me.
07:33:20 <dmwit> Just because the answer you proposed doesn't work doesn't mean the question is wrong.
07:33:59 <dmwit> As far as I know, there's no pre-built function to do it, and I think the Unicode committee would like to have a word with anybody who *wants* to do it.
07:34:23 <dmwit> But the question is certainly well-formed, meaningful English.
07:34:57 <younder> dmwit, striping the 8 bit off works. But it leads to weak code..
07:35:09 <dmwit> No, stripping the eighth bit off does not work.
07:35:25 <dmwit> > chr (ord 'ë' .&. 0x7f)
07:35:27 <lambdabot>   'k'
07:35:27 <younder> Yes ,it does!
07:35:39 <dmwit> No, it doesn't. As I just demonstrated.
07:36:12 <younder> I have only tried it in C, C++ and Common Lisp.
07:36:32 <dmwit> ...
07:36:38 <dmwit> younder--
07:36:45 <younder> But I see no reason It shouldn't work in Haskell
07:37:23 <younder> You are really pissing me off dmwit
07:37:34 <barrucadu> So you're saying that, in C, 'ë' & 0x7f == 'e'?
07:38:58 <younder> barrucadu,  I used 0xFF to include isolation. And I said some characters required to bytes for french.
07:39:37 <dmwit> 'ë' & 0xff still isn't 'e'
07:39:56 <Taneb> Is there any monad that uses a different definition for (>>)?
07:40:53 <fmap> different?
07:41:01 <Taneb> not-default
07:41:19 <dmwit> I vaguely remember the WASH CGIT monad having something non-standard...
07:41:27 <dmwit> Though maybe that was forever, and not (>>).
07:41:43 <Taneb> You can't... redefine forever?
07:41:54 <dmwit> No, but you can define *another* forever. =)
07:41:59 <Taneb> =) indeed
07:42:18 <fmap> [] has non-default >> iirc
07:42:20 <barrucadu> @src forever
07:42:20 <lambdabot> Source not found. Take a stress pill and think things over.
07:42:32 <dmwit> ?src [] >>
07:42:33 <lambdabot> Source not found. Just what do you think you're doing Dave?
07:42:35 <dmwit> ?src [] (>>)
07:42:36 <lambdabot> xs >> ys      = concatMap (const ys) xs
07:42:45 <dmwit> ?src Monad
07:42:46 <lambdabot> class  Monad m  where
07:42:46 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
07:42:46 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
07:42:46 <lambdabot>     return      :: a -> m a
07:42:46 <lambdabot>     fail        :: String -> m a
07:42:53 <Taneb> ?src [] (>>=)
07:42:53 <lambdabot> xs >>= f     = concatMap f xs
07:43:04 * barrucadu looks up the definition of forever
07:43:10 <dmwit> Although it's spelled differently, that's still the default (>>).
07:43:10 <barrucadu> How does that have the type m a -> m b?
07:43:23 <Taneb> :t concatMap
07:43:25 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
07:43:27 <dmwit> barrucadu: Things that never return can have any type.
07:43:35 <barrucadu> Ok
07:43:45 <barrucadu> That also explains how void is a -> Void
07:44:00 <barrucadu> *Data.Void void
07:44:00 <dmwit> Did you mean Void -> a?
07:44:15 <barrucadu> Yes!
07:44:18 <barrucadu> And it's called absurd
07:44:19 <dmwit> okay =)
07:44:21 * barrucadu fails at memory today
07:45:04 <Taneb> Is forever useful for non-side-effecty monads?
07:45:27 <hpc> Taneb: sometimes
07:46:13 <hpc> you can write "looping" functions as (forever $ step) :: Either result intermediate
07:46:29 <Taneb> I wouldn't have thought of that
07:46:37 <Taneb> That would be quite useful, I think
07:46:54 <hpc> there's better ways to do the same thing though
07:47:16 <hpc> usually you need more power than that gives you, and so you end up folding over an infinite list
07:47:31 <hpc> but it's something!
07:55:26 <jmcarthur> that's still an effecty monad
07:55:43 <zezikaro> what's a monad?
07:55:49 <dmwit> I was just about to ask how you define side-effect-y.
07:56:16 <dmwit> zezikaro: It's a structure that has a unit and join.
07:56:36 <dmwit> zezikaro: There are plenty of good resources online for learning about them.
07:56:39 <dmwit> My favorite is
07:56:40 <hpc> zezikaro: and some laws
07:56:47 <dmwit> ?where you could have invented monads
07:56:48 <lambdabot> I'm right here, silly.
07:56:51 <dmwit> um
07:56:56 <hpc> LYAH has a good chapter on monads
07:56:59 <dmwit> ?google you could have invented monads and maybe you already have
07:57:01 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
07:57:07 <dmwit> ?where typeclassopedia is good, too
07:57:08 <hpc> that one's good too
07:57:08 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
07:57:25 <dmwit> ?where aam
07:57:25 <lambdabot> http://www.haskell.org/haskellwiki/All_About_Monads
08:00:22 <dmwit> I feel dirty doing "git clone darcs.haskell.org/..."
08:02:38 <applicative> zezikaro: they are things  like  lists, maybes, trees, io actions, ... subject to certain standard operations.
08:03:07 <dmwit> pfftt, yeah, like a guy with a name like applicative would know
08:03:12 <dmwit> ;-)
08:03:50 * dmwit suddenly realizes slinging mud about names isn't too bright
08:04:15 <applicative> zezikaro: in the case of lists, the standard operations are singleton x = [x] and concatMap , to put it crudely.
08:06:20 <applicative> zezikaro: the prior concept is Functor, which as LYAH puts it, is 'things you can map over'
08:06:29 <zezikaro> >.<
08:06:32 <zezikaro> thanks
08:06:33 <applicative> > fmap (+1) [1,2,3]
08:06:34 <lambdabot>   [2,3,4]
08:06:40 <zezikaro> i'm only on chapter 2 atm
08:06:41 <applicative> > fmap (+1) (Just 1)
08:06:42 <lambdabot>   Just 2
08:06:49 <applicative> > fmap (+1) Nothing
08:06:50 <lambdabot>   Nothing
08:07:00 <applicative> > fmap (+1) (Left 'a')
08:07:00 <lambdabot>   Left 'a'
08:07:06 <applicative> > fmap (+1) (Right 1)
08:07:07 <lambdabot>   Right 2
08:07:11 <applicative> etc etc
08:07:18 <applicative> monads are a further wrinkle
08:07:39 <applicative> > return 1 :: [Int]
08:07:39 <lambdabot>   [1]
08:07:45 <applicative> > return 1 :: Maybe Int
08:07:46 <lambdabot>   Just 1
08:07:52 <applicative> > return 1 :: Either String Int
08:07:53 <lambdabot>   Right 1
08:08:11 <applicative> theres one more step but thats about it
08:09:01 <zezikaro> it's chapter 12
08:09:05 <zezikaro> >.~<
08:09:16 <zezikaro> why does it take 8 chapters to actually do "hello world"
08:09:29 <applicative> it's just how he organized it
08:09:39 <applicative> we can tell you how to do helloworld
08:10:35 <applicative> his plan is good, he knows what he's doing
08:10:36 <dmwit> zezikaro: Open ghci and type "Hello, world!". Done!
08:11:02 <dmwit> I don't believe it took eight chapters to get there -- I bet he does something very like that in chapter one. =)
08:11:34 <Philippa> dmwit: 'scheating. You're not saying hello to the World unless you're doing IO. Yourself.
08:11:45 <Philippa> but yes, it's the right approach
08:11:47 <ChristianS> he intentionally avoids I/O for the first chapters
08:11:53 <dmwit> Philippa: I don't agree at all.
08:11:55 <Philippa> just one of the ways FPLs are/can be different
08:12:40 <Philippa> dmwit: *shrug* I just find the alternative interpretations make the choice of "Hello, world!" a little less meaningful
08:12:51 <applicative> zezikaro: if you make it to the end all the  IO  stuff will come together incrediby quickly. Facility with it is getting used the type system and general features like list, maybe, ioaction
08:12:57 <dmwit> (Also, I checked: he doesn't do it in chapter one -- there's no code at all in chapter one -- but he does do it in chapter two. =))
08:13:45 <dmwit> Philippa: Just because C doesn't have a REPL doesn't mean we can't abuse it in Haskell. =)
08:14:01 <zezikaro> does he?
08:14:06 <zezikaro> the only hello world i've seen in the first few chapters is
08:14:11 <zezikaro> "hello world" == "hello world"
08:14:20 <hpc> dmwit: in python, hello world isn't "$ python; 'hello world';"
08:14:22 <dmwit> ghci> "hello" ++ " " ++ "world"
08:14:24 <dmwit> "hello world"
08:14:33 <dmwit> zezikaro: Right here in chapter two. =)
08:14:35 <hpc> it's "print 'hello world'"
08:14:42 <Philippa> dmwit: sure. It's just an abuse, is all :p
08:14:46 <dmwit> hpc: Again, I don't agree.
08:15:05 <dmwit> hpc: I think opening the python shell and putting 'hello world' is a perfectly good hello-world for Python, too.
08:15:13 <zezikaro> 'h' : 'e' : 'l' : 'l' : 'o' : [] ++ " world"
08:15:16 <zezikaro> I'm a genius!
08:16:30 <zezikaro> How do i write multiple lines in haskell?
08:16:36 <zezikaro> when i press enter it just executes it
08:16:37 <tgeeky__> hm
08:16:41 <applicative> zezikaro: if you are anxious to compile executables write a module "main = interact zezikaro; zezikaro :: String -> String ; zezikaro str = undefined " and replace undefined by increasingly complicated definitions as you go along in lyah
08:17:05 <dmwit> zezikaro: In ghci, you can use :{ and :}, or explicit {;} all on one line.
08:17:13 <applicative> the compiled executable will take a string from stdin and emit the transformed string from stdout, so you can pipe through it
08:18:34 <dmwit> ?src show
08:18:34 <lambdabot> show x = shows x ""
08:18:52 <dmwit> Oh, right, and shows calls showList in the [] instance.
08:19:10 <merijn> Any xml-conduit users here? I'm trying to select the followingSibling of a node whose content matches some predicate P. I was using "cursor $// checkNode P >=> followingSibling", but that doesn't work, since checkNode strips all nodes not matching P and the sibling I want does not match P. Any suggestions?
08:19:12 <zezikaro> dmwit what's that sorry?
08:19:34 <zezikaro> applicative I'm a noob sorry
08:19:45 <hpc> merijn: parens?
08:19:47 <tgeeky__> zezikaro: stop apologizing
08:19:51 <dmwit> zezikaro: :{ starts a multiline command in ghci. :} ends it. You may also convert your whitespace-sensitive multiline command into a whitespace-insensitive single line command using explicit brackets and semicolons.
08:20:16 * hpc doesn't conduit, and doesn't know if you can give a different association for ($//), (>=>)
08:20:48 * applicative considers that ($//) is an unusually ugly operator
08:21:02 <merijn> hpc: Different association is a type error
08:21:44 <merijn> applicative: Actually, it's pretty okay in the context ($/ applies to all children of a node, $// applies recursively to all descendants)
08:37:20 * hackagebot liblastfm 0.0.3.0 - Wrapper to Lastfm API  http://hackage.haskell.org/package/liblastfm-0.0.3.0 (MatveyAksenov)
08:39:26 <zezikaro> Is there an easy way to write haskell programs?
08:39:33 <zezikaro> like what you can do in eclipse
08:40:24 <hpc> zezikaro: eclipse does a lot of stuff, and most of it isn't actually relevant to haskell
08:40:30 <hpc> like code generation
08:40:37 <zezikaro> I'm just after the easy
08:40:40 <hpc> my preferred way to write haskell is two terminals
08:40:41 <zezikaro> write/press play button
08:40:50 <hpc> one is vim editing the file, the other is ghci with the file loaded
08:40:58 <hpc> edit file, ":r" in ghci to reload
08:41:12 <hpc> play around a bit or just get the type errors, and back to editing
08:48:30 <kqr_> is there any specific reason the record syntax for creating data types pollutes the namespace so badly? couldn't that have been done in any other way? (i don't expect you to tell me, if you happen to know an article or something about it i'd be happy to read. i couldn't find anything by a quick googling other than "some people like it that way while some people don't." i can't imagine a single reason why anyone would like it that way)
08:49:16 <mauke> what do you propose instead?
08:49:21 <hpc> kqr_: there's a lot of debate on what can be done to improve record syntax
08:49:25 <ezyang> It is widely acknowledged that the record system is suboptimal, but getting something better is quite complex.
08:50:10 <kqr_> mauke, my gut instinct would be to define the functions named `type_field' with an underscore in between
08:50:22 <kqr_> mauke, it's not like the underscore is used to denote anything else in names anyway
08:50:48 <hpc> :t forM_
08:50:49 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
08:50:55 <kqr_> oh
08:50:57 <hpc> :t sequence_
08:50:58 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
08:50:59 <hpc> ;)
08:51:02 <kqr_> right
08:51:08 <kqr_> anyway, some sort of delimiter
08:51:19 <Philippa> kqr_: they did the simplest thing that worked in 1990, in the knowledge that record systems were a research area. It stuck.
08:51:50 <kqr_> i guess including type information in the function name could be considered ugly in the same way as hungarian notation does, but it somehow conveys what in object oriented languages would be an instance method
08:52:05 <kqr_> Philippa, are records that old, and have people not succeeded in making them better since?
08:52:35 <hpc> agda's records are quite powerful, at the price of a really complicated module system
08:52:50 <hpc> or i suppose, they went with the complicated module system and got a lot out of it, including records
08:53:17 <hpc> but that design would be rather a huge change for haskell
08:54:06 <Saizan> actually, if you just created a module for each datatype definition like agda does you'd get most of the namespacing benefits
08:54:20 <kqr_> what is the common way of using records to avoid name space pollution? do you put them in their own module or avoid record syntax entirely?
08:55:19 <Philippa> kqr_: there are many better record systems, that's the problem
08:55:26 <Philippa> picking one leads to infinite bikeshedding
08:55:33 <Philippa> and the module approach works, yes
08:55:35 <kqr_> right
08:55:56 <Philippa> the module approach makes it easy to (module-)locally rename namespaces, too
08:57:14 <kqr_> good point
08:59:24 <Saizan> that's why if you had data R = R { ... }; define the accessors in an implicitly declared module R you'd get a significant improvement at basically no cost
08:59:51 <Saizan> it'd break old code though, because you'd have to "import R" to use the accessors unqualified
09:00:57 <Philippa> you get module namespace problems then, but yes
09:01:14 <Philippa> (make the two namespaces distinct somehow and you're fine)
09:04:03 <Saizan> true
09:04:31 <Saizan> maybe you need a full story for local modules to make this work nicely
09:05:12 <Saizan> s/local/sub/
09:09:39 <merijn> Is there a way to get a list of packages using a package? (i.e., I'm looking for some code samples of a library)
09:10:54 <applicative> there doesn't seem to be a reverse dependencies revealing hackage up at http://hackage.factisresearch.com/ anymore
09:11:38 <applicative> is one up somewhere else?
09:14:58 <Saizan> there's some reverse hackage somewhere
09:18:11 <applicative> #hackage is saying "[Live test server http://hackage.factisresearch.com/ | ...For all your hackage and cabal questions and needs | The latest hackage source code needs your help! http://hackage.haskell.org/trac/hackage/wiki/HackageDB/2.0]
09:18:23 <applicative> ah well
09:20:17 <mroman> How does ghc inline "forever"?
09:24:51 <mzero> only  -ddump-simpl knows for sure, mroman !
09:28:09 <c_wraith> ..  forever can't be inlined, it's recursive
09:40:00 <Saizan> you could worker-wrap transform it
09:40:16 <Saizan> forever m = go where go = m >> go
09:41:07 <Saizan> then if it decides to inline forever it'll create a specialized go and call that
09:43:47 <taylanub> https://en.wikipedia.org/wiki/Untyped_lambda_calculus#Reduction_strategies under these definitions, haskell would be a combination of call-by-name and call-by-need, right ?
09:47:39 <taylanub> (i wonder how useful those definitions are at all)
09:48:38 <Philippa> haskell's allowed to use any non-strict strategy
09:48:44 <Philippa> GHC haskell is largely call-by-need
09:50:42 <Tomsik> Isn't non-strict equivalent to lazy evaluation (as to which terms normalize)?
09:50:47 <c_wraith> no.
09:51:00 <c_wraith> non-strict is denotational semantics, lazy is operation semantics
09:51:04 <c_wraith> operational
09:51:26 <Tomsik> Okay, but do they give the same result?
09:51:29 <c_wraith> oh, as for which terms normalize? yeah, that's probably the same.
09:51:29 <Philippa> lazy evaluation is a non-strict strategy, yes
09:51:41 <Philippa> non-strictness admits other strategies though
09:51:46 <Philippa> (including call-by-name)
09:52:04 <jfischoff> is there a list of strategies somewhere?
09:52:10 <Tomsik> They'll be undistinguishable though, right? (besides resource consumption)
09:53:24 <merijn> Tomsik: lazy evaluation guarantees an expresion is only evaluated once, GHC's semantics don't, afaik
09:53:43 <merijn> Tomsik: So they can also differ in computation time (which you might consider a resource, I guess)
09:54:13 <Tomsik> So the problem is side effects?
09:54:50 <merijn> Well no, as that's a matter of the IO monad.
09:54:53 <Taneb> type Graph = IntMap (IntMap Int)
09:55:06 <Tomsik> What I'm thinking about is that cal-by-name is an okay model for thinking what a Haskell value will evaluate to?
09:55:19 <merijn> It's just that if I have "veryLongComputation 1 + veryLongComputation 1" GHC will computate "veryLongComputation 1" twice
09:55:25 <Taneb> Seems better than Data.Graph
09:55:35 <taylanub> jfischoff: the link i gave above. but it seems rather vague; perhaps the strategies would be more correctly represented by a relation(!) and not a list
09:55:58 <taylanub> (am i doing it right in keeping it mathematical?)
09:56:07 <merijn> @where hayoo
09:56:07 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
09:56:17 <jfischoff> taylanub: cool thanks
09:56:34 <taylanub> what i'm saying is, call-by-name/need are both types of lazy, and it seems like you could have features of both and it would be a third kind of lazy ...
10:02:21 <hpaste> dmwit pasted “GHC is fixed!” at http://hpaste.org/69064
10:02:29 <dmwit> aavogt: Do you like this error message better? =)
10:03:37 <aavogt> yep looks good
10:04:25 <luite>  what's the recommended way to install a larger library with a cabal package (2000 files)?
10:04:39 <dmwit> Wow, 2000 files!
10:04:53 <hpc> luite: one at a time for the rest of your life ;)
10:04:53 <dmwit> Wait, 2000 Haskell files?
10:05:05 <luite> dmwit: no javascript files
10:05:29 <luite> it's the closure library, some of which is required for the ghcjs runtime
10:05:48 <luite> not all, but i think it's better to just install the whole thing
10:06:31 <dmwit> I suppose one of data-files or other-files.
10:06:37 <dmwit> I agree that listing 2000 things there is a bit annoying.
10:06:50 <luite> yeah quite.. since the files can change with every update...
10:06:51 <donri> luite: for happstack-yui i use data-files and a generated cabal file via cpp and make, see https://github.com/dag/happstack-yui
10:07:05 <dmwit> luite: Oh, data-files and other-source-files accept wildcards.
10:07:08 <dmwit> e.g. data/*
10:07:17 <dmwit> data/*.js I mean
10:07:26 <donri> that's not recursive though
10:07:37 <luite> dmwit: yeah but the js files are in lots of directories
10:08:03 <dmwit> Still, listing all the directories is better than listing all the files individually. =P
10:08:10 <hpc> can you do
10:08:22 <hpc> data/*.js, data/*/*.js, data/...
10:08:30 <donri> nope
10:08:31 <luite> hpc: no
10:08:39 <donri> wildcard is only allowed in the filename and before the extension
10:08:49 <gurrag> is Happstack considered a DSL?
10:09:05 <tgeeky> someone should invent data/**.js
10:09:06 <luite> gurrag: not really i'd say
10:09:10 <donri> define DSL?
10:09:19 <stepcut> gurrag: no.. though it does contain some DSLs
10:09:20 <xemdetia> Is there a good way to just unregister everything from a haskell install cleanly so I can start to rebuild it?
10:09:38 <donri> xemdetia: cabal-dev
10:09:54 <tgeeky> donri: that's good advice for next time
10:09:58 <hpc> xemdetia: or rm -r ~/.ghc ~/.cabal
10:10:00 <merijn> xemdetia: Nuke ~/.cabal or ~/.ghc, but I forget which of the two
10:10:03 <hpc> or something like that
10:10:05 <luite> ~/.ghc
10:10:08 <luite> is the one
10:10:09 <hpc> it's safe to nuke both
10:10:19 <xemdetia> Okay
10:10:22 <hpc> if you nuke .cabal you might lose configuration and executables
10:10:23 <luite> you can nuke ~/.cabal if you haven't installed binaries that you still need
10:10:51 <xemdetia> No I am trying to get ghc7 working on debian old and I ended up with a cyclical dependency and can't seem to get out of it
10:10:56 <xemdetia> I will just nuke both for now
10:11:52 <luite> hm, does ghc install tar or sometihng, on windows? i guess it does, right?
10:12:02 <monochrom> no
10:12:21 <luite> hm, but it must be able to untar stuff with cabal-install
10:12:24 <monochrom> err, I don't know, don't trust me
10:12:33 * hackagebot GTALib 0.0.2 - A library for GTA programming  http://hackage.haskell.org/package/GTALib-0.0.2 (KentoEmoto)
10:12:36 <tgeeky> it installs mingw, which I think might have tar in it
10:12:55 <luite> a post-install hook that untars the closure library would be ok, i guess
10:14:03 <donri> or bundle, and you don't have to worry about where to put it etc because cabal handles it
10:14:14 <hpc> if you're feeling silly, you can depend on tar
10:14:32 <luite> hpc: hm, but it's the Setup script that must use it, not the package
10:14:41 <tgeeky> hm. I don't actually see tar in the mingw that's installed by ghc
10:15:00 <hpc> luite: put it in configure, maybe
10:15:13 * hpc knows there is some way to handle Setup.hs depends
10:15:45 <c_wraith> It's just occurred to me that unless you're really careful, Lazy ST could be a nightmare to think about..
10:16:10 <hpc> c_wraith: you mean like, unsafeInterleaveST?
10:16:17 <hpc> because if so, oh god
10:16:19 <c_wraith> well, Control.ST.Lazy
10:16:23 <hpc> ah
10:16:27 <c_wraith> but I think it's basically the same thing
10:16:28 <monochrom> yeah, it is very subtle what it is lazy about
10:17:04 <tgeeky> luite: it appears that no, ghc does not install tar
10:18:17 <luite> tgeeky: ah looks like cabal-install itself depends on zlib and tar
10:18:21 <monochrom> my http://hpaste.org/63925 may help see some aspect of Control.ST.Lazy
10:18:33 <tgeeky> luite: ok. GHC doesn't install cabal-install, so that makes sense
10:19:29 <tgeeky> luite: for what it's worth, a normal install of mingw (not the pruned one that GHC comes with) includes tar.exe
10:19:44 <monochrom> cabal-install depends on zlib, and seems to write its own tar code
10:20:30 <monochrom> "Other-Modules: ... Distribution.Client.Tar ..."
10:20:49 <c_wraith> wow, I really have no clue what lazy ST does.  It's not the same as unsafeInterleaveST
10:21:18 <luite> monochrom: oh right, i stupidly searched for tar in the page but the hit was the cabal-install-0.14.0.tar.gz filename, not a dependency :)
10:21:28 <monochrom> hahaha
10:22:34 <hpaste> c_wraith annotated “lazy ST example” with “another lazy ST example” at http://hpaste.org/63925#a69065
10:22:35 <luite> hmm, well i think i could include a tar, non gz file
10:22:41 <luite> since the archive gets gzipped anywy
10:22:49 <c_wraith> I have *no* clue what's going on there
10:22:58 <luite> and Cabal should be on any propr GHC install
10:23:16 <tgeeky> luite: all of this is included in haskell platform (on windows)
10:23:41 <luite> tgeeky: yeah i know, but i'd like it to work on plain ghc installs as well
10:24:49 <monochrom> the important thing to note is "return (x:xs)". what values of x and xs do you get?
10:25:02 <c_wraith> x is obvious
10:25:07 <c_wraith> I was trying to figure out xs
10:25:52 <monochrom> unroll "loop" a few times to see that xs's value does not depend on "writeSTRef r (x+2)"
10:25:52 <c_wraith> it can't be actually running the loop action again before it gives a value to xs, because that would cause non-termination
10:26:01 <mzero> luite: can't you just build your installer with cabal, and then ship the Setup.hs file?
10:26:17 <mzero> I think that is the expected way to present something that can be installed in a place without cabal-install
10:26:33 <mzero> (remember, the Cabal library, which does all the install work, is shipped with GHC)
10:26:58 <c_wraith> monochrom: I can't unroll loop. That's the thing. I have no clue what it's doing...  I was previously operating under the assumption it's like unsafeInterleaveST, but clearly it isn't
10:27:30 <luite> mzero: i was planning to use the Cabal lib's untar code to run a post-install hook in Setup.hs, is that what you mean?
10:27:42 <mzero> sure
10:28:06 <monochrom> unroll means inline. inlining does not change semantics. you may know nothing about what it does, but inlined and not-inlined do the same unknown thing.
10:28:16 <mzero> everything that needs should be shipped with GHC
10:29:17 <luite> the only other thing this needs is a jvm, how should i bundle that with a cabal package? ;p
10:29:28 <dmwit> =(
10:29:50 <c_wraith> luite: just have it dump some error messages about out of memory.  Everyone will assume it's a jvm
10:29:59 <luite> hehe, it can do without a jvm, but then it won't be able to optimize javascript properly
10:30:14 <luite> unless someone volunteers to rewrite closure compiler in haskell
10:31:53 <c_wraith> monochrom: I see what you're saying, but it doesn't tell me anything unless I know how the actions are executed. I'm looking at order of effects, which is what I don't understand here.  How is lazy ST implemented such that the order of effects is sane, but also allowing productive non-terminition?
10:32:02 <hpc> what's the extension that makes ghci print foralls in :t?
10:32:13 <hpc> it's not RankNTypes or ExplicitForAll
10:35:31 <mzero> luite: you can't possible hope to properly bundle a jvm with your system ---
10:35:41 <c_wraith> Huh.  more experimenting tells me I haven't got the foggiest idea of what's going on.  But I have to run.  Maybe I'll figure this out tomorrow.
10:37:12 <otters> what's the closest Haskell approximation to Ruby's String#scan?
10:41:46 <hpc> does anyone know how to force ghci to print foralls in type queries?
10:42:40 <hpc> i tried reading lambdabot's source and can't find what's doing it
10:43:17 <mzero> otters - what does that do
10:44:54 <otters> well, it takes a string and a regex and makes a list of every substring the regex matches
10:46:40 <danr> hpc: maybe they are from -ddump-tc
10:46:44 <danr> it writes them with foralls
10:47:23 <hpc> $ ghci -ddump-tc
10:47:24 <danr> I never gotten ghci to write them
10:47:30 <danr> hpc: ghc -ddump-tc
10:47:36 <hpc> oh
10:47:43 <danr> I guess it works with ghci too...
10:48:06 <danr> but only at compilation (type checking)
10:48:22 <hpc> not working
10:48:28 <danr> -fforce-recomp
10:49:15 <hpc> eh, i found a better way
10:49:27 <hpc> trying to reproduce lambdabot's behavior
10:49:31 <hpc> <hpc> ?type undefined
10:49:36 <hpc> <bot> :: a
10:49:50 <hpc> now i am not turning on extensions and flags and shit
10:50:46 <hpaste> monochrom annotated “lazy ST example” with “another lazy ST example (annotation)” at http://hpaste.org/63925#a69066
10:58:09 <ion> hpc: -fprint-explicit-foralls
10:58:58 <hpc> ion: yaaaaay!
11:03:40 <luite> mzero: sorry was away
11:03:47 <mzero> np
11:04:13 <luite> mzero: nah it just looks for java in the path, and in the future will probably print a warning when there is none
11:04:32 <luite> and maybe with an override through an environment var
11:04:40 <mzero> I'm also building a project with a ton of .js files
11:04:51 <luite> what kind of project?
11:04:56 <mzero> currently all listed in the .cabal file - I like the tar ball idea....
11:05:04 <mzero> only... I think we're going to use file-embed instead
11:05:22 <mzero> well - I suppose we could do both
11:05:26 <luite> ah that works if you use them only in haskell
11:05:37 <mzero> well, we serve them from haskell, but yes
11:05:37 <shawng> Bonjours les gars... I mean top of the morning to you boys and ladies (of course)
11:05:38 <mzero> we do
11:05:47 <luite> but in this case we need the .js files on disk because they are used with closure compiler to build javascript bundles
11:06:25 <luite> where a bundle = a bunch of haskell functions
11:06:30 <mzero> ah -
11:06:47 <mzero> I'm thinking we should, before embedding, as a build step, closure up our files....
11:06:48 <shawng> Is anyone from 2600, the hacker group in NY in this chat? Paul Gramm affiliates perhaps?
11:07:05 <luite> every exported function depends on a few bundles,a page that calls some haskell function loads the bundles first
11:08:02 <mzero> shawng: in #haskell? seems like a long shot!
11:08:16 <luite> some stuff that all functions depend on wil end up in one bundle (usually this contains some rts functions, part of the base and integer-gmp package)
11:08:29 <shawng> mzero: so you know about 2600?
11:08:38 <mzero> yes
11:09:33 <shawng> mzero: i'm wondering where VT is going to meet up for his google summer of code project. I'm just learning Haskell at Bryant Park at the moment
11:10:02 <shawng> mzero: you know VT?
11:10:12 <mzero> no, nor where Bryant Park is
11:10:35 <shawng> mzero: NYC. Beyind the New York Public Library
11:11:01 <shawng> mzero: nice place to code, aesthetic and cool. Because it's hot this summer
11:11:35 <mzero> whereas I'm in California, wearing a long sleeve shirt, and getting cold.... :-)
11:12:13 <xemdetia> I am bad at life, how do I submit patches for the cabal-install-ghc74 package
11:12:19 <shawng> mzero: i've heard about you Cali boys. San Fran is having an economic boom apparently
11:13:51 <shawng> mzero: you remember how to change the username?
11:14:38 <ski> /nick my_new_nickname
11:14:56 <ski> shawng : like that ^ ?
11:17:35 <hpaste> monochrom annotated “lazy ST example” with “sprinkle sprinkle little stars, how I wonder when you are” at http://hpaste.org/63925#a69067
11:17:44 <monochrom> hehe
11:19:25 <jonaskoelker> Hi all.  When I readFile "/etc/passwd-" I get an isPermissionError but when I readFile "/dev/fuse" I get "dice: /dev/fuse: hGetContents: permission denied (Operation not permitted)", not handled by my error handler.  What gives?
11:20:21 <dmwit> hGetContents succeeds immediately and passes out of your handler.
11:20:28 <hpc> jonaskoelker: stat them both and see what's different?
11:20:38 <dmwit> Uses of the returned value from hGetContents later will trigger the exception (later).
11:20:41 <monochrom> @tell c_wraith "sprinkle sprinkle little stars, how I wonder when you are" http://hpaste.org/63925#a69067
11:20:41 <lambdabot> Consider it noted.
11:20:48 <hpc> also what dmwit said
11:20:52 <hpc> :t readFile
11:20:53 <lambdabot> FilePath -> IO String
11:20:55 <ski> `evaluate =<< hGetContents filePath' ?
11:21:12 <ski> (er, s/filePath/handle/, perhaps)
11:21:13 <hpc> (evaluate . length) to read more than the first block
11:21:13 <mauke> dmwit: no, it doesn't
11:21:19 <dmwit> ...Actually, yeah, I'm confused.
11:21:28 <dmwit> That exception should be thrown by whatever is opening the handle you're passing to hGetContents.
11:21:37 <jonaskoelker> handle (myhandler) (readFile path) >>= goDoStuff
11:22:34 <ski> monochrom : makes perfect sense :)
11:22:34 <mauke> dmwit: readFile
11:22:55 <monochrom> I hope you like the title! :)
11:22:59 <dmwit> I need to learn to read.
11:23:06 <ski> i do :)
11:23:45 <ski> > read "dmwit"
11:23:46 <lambdabot>   *Exception: Prelude.read: no parse
11:24:09 <monochrom> instance Read dmwit where {}
11:24:39 <dmwit> Okay, I'm stumped.
11:24:45 <dmwit> Maybe paste some code?
11:25:01 <mauke> dmwit: code was pasted
11:25:03 <dmwit> Unless somebody else answered and I didn't understand the answer because I was thinking about the wrong problem.
11:25:07 <mauke> dmwit: readFile "/dev/fuse"
11:25:37 <dmwit> Well, if that's the whole code, then the answer is clear: it's not being handled by an exception handler because there's no exception handler.
11:26:01 <jonaskoelker> handle (myhandler) (readFile path) >>= goDoStuff
11:26:13 <mauke> jonaskoelker: myhandler is undefined
11:26:15 <mauke> jonaskoelker: path is undefined
11:26:19 <mauke> jonaskoelker: goDoStuff is undefined
11:26:25 <mauke> jonaskoelker: the parens around myhandler are redundant
11:26:56 <jonaskoelker> also interesting, reading /dev/adsp: "dice: /dev/adsp: hGetContents: resource exhausted (Cannot allocate memory)"
11:27:03 <dmwit> Anyway, it seems that /dev/fuse is special.
11:27:04 <jonaskoelker> hpasting in a jiffy
11:27:12 <monochrom> the only exceptions that could happen from readFile are the like of "file not found", "can't open, permission problems", etc., i.e., just those concerned with opening the file.
11:27:17 <dmwit> Just running 'readFile "/dev/fuse"' and 'readFile "/etc/passwd-"' will give different outputs in ghci.
11:27:29 <dmwit> (More different than one saying /dev/fuse and one saying /etc/passwd-, even.)
11:27:34 <jonaskoelker> some other special files are handled normally (e.g. /dev/zero, /dev/full)
11:27:45 <monochrom> subsequent reading problems are deliberately not told to you. they just cause the string to end early.
11:28:02 <jonaskoelker> huh?
11:28:07 <mauke> I wish I knew what read(2) failing with EPERM means
11:28:22 <jonaskoelker> right
11:28:31 * jonaskoelker facepalms -- why didn't I think of that
11:28:43 <hpc> try just opening the files
11:29:13 <hpaste> jonaskoelker pasted “the code in question” at http://hpaste.org/69069
11:29:26 <haskell_chap> hello everyone
11:30:07 <monochrom> "catch x y" catches only exceptions that happen immediately
11:30:15 <byorgey> hello haskell_chap
11:30:38 <haskell_chap> hey there
11:30:47 <Jeanne-Kamikaze> sup
11:30:53 <jonaskoelker> monochrom: what does non-immediately mean with reference to readFile?
11:30:55 <ChristianS> Prelude> readFile "/etc/shadow" -- *** Exception: /etc/shadow: openFile: permission denied (Permission denied)
11:30:55 <ChristianS> Prelude> readFile "/dev/fuse -- "*** Exception: /dev/fuse: hGetContents: permission denied (Operation not permitted)
11:31:07 <ChristianS> hm, maybe /dev/fuse can be opened but not read?
11:31:16 <jonaskoelker> apparently?!
11:31:18 <hpc> jonaskoelker: it means readFile opens the file, but doesn't try to read stuff from it until it needs to
11:31:54 <jonaskoelker> hpc: and so the exception gets thrown... when I put the "already read" string into WHNF?
11:31:59 <mauke> ChristianS: duh
11:32:27 <monochrom> as another example, "x <- catch (return (div 1 0)) etc" there is no exception to be caught here, yes if you use x later there will be a divide-by-zero exception, but that's later, not now.
11:33:04 <haskell_chap> So what is the best platform to work on for a mac? I'm having trouble with macports and the more conventional method of installation
11:33:18 <monochrom> readFile does lazy I/O via hGetContents, so a lot of problems will not pop up "now"
11:33:46 <hpc> jonaskoelker: yeah; which is outside the catch
11:34:06 <applicative> haskell chap, just download the haskell  platform installer.  if you are using Lion there are a few subtleties
11:34:06 <merijn> haskell_chap: Really? I just download Haskell Platform and install, works great out of the box
11:34:13 <applicative> scrap the macports one for sure
11:34:22 <merijn> applicative: Which? I installed on Lion no problem
11:34:23 <jonaskoelker> hpc: ah... so I need to to wrap the use in an exception handling block...
11:34:44 <dmwit> jonaskoelker: yes, or use
11:34:46 <dmwit> ?hackage strict
11:34:46 <lambdabot> http://hackage.haskell.org/package/strict
11:34:47 <hpc> jonaskoelker: or read the file at the same time you open it
11:34:52 <applicative> merijn: oh, there had been diffficulty with the script looking for gcc in the wrong place, maybe its been updated?
11:35:04 <merijn> applicative: Oh, yeah. You're right
11:35:09 <jonaskoelker> hpc: how do I do that?  Pass it through seq or something?
11:35:10 <applicative> i mean the script that 'ghc' is
11:35:14 <merijn> applicative: That was a matter of editing one file, though
11:35:45 <applicative> merijn, yeah, i was just warning haskell_chap that there is at least on potential hiccup
11:36:24 <haskell_chap> Only v. 6.10.4 for ghci
11:36:24 <haskell_chap> Hugs 98 version is from Sept. 2006
11:36:35 <applicative> http://hackage.haskell.org/platform/mac.html -- haskell chap
11:36:41 <jonaskoelker> anyways, changing "handle _ (readFile name) >>= go" into "handle _ (readFile name >>= go)" does the trick for me :-)
11:36:43 <merijn> haskell_chap: On Lion you need to edit /usr/bin/ghc and change the gcc path in there to /usr/bin/gcc and you're good to go, but that's the only thing, on the others you don't even need to do that
11:36:46 <applicative> yeah macports maybe have been abandoned.
11:36:50 <jonaskoelker> thanks for your help everybody
11:36:54 <hpc> jonaskoelker: the hacky way is "do contents <- readFile foo; evaluate (length contents); return contents"
11:36:55 <merijn> @where platform
11:36:55 <lambdabot> http://hackage.haskell.org/platform/
11:37:21 <haskell_chap> applicative: thank you but I get an error downloading that
11:37:24 <applicative> nb haskell_chap the platform presupposes that you have installed a bunch of xcode.  that's where it gets it gcc and maybe a bit more
11:37:35 <hpc> which basically says "force the string from start to finish"
11:37:41 <applicative> i just downloaded and installed this morning
11:37:48 <haskell_chap> applicative: the binary does not work
11:37:57 <applicative> which one
11:38:07 <applicative> do you have XCOde?
11:38:12 <haskell_chap> applicative: 64 bit
11:38:25 <applicative> e.g. do you get anything from 'which gcc' or whatever
11:38:25 <jonaskoelker> hpc, right, because length needs the to cdr down the [Char] until it hits []
11:38:30 <applicative> hmmm
11:38:36 <danr> @pointfree \(a,b) -> flip (,) b <$> f a
11:38:37 <lambdabot> Unknown command, try @list
11:38:42 <jonaskoelker> hpc: what'd be the non-hacky way? ;-)
11:38:42 <danr> @pf \(a,b) -> flip (,) b <$> f a
11:38:43 <lambdabot> Maybe you meant: bf pl
11:38:59 <hpc> jonaskoelker: read lines until you hit the end of the file
11:39:00 <haskell_chap> applicative: why is there anything that could run out of Xcode? I was expecting to work out the interpretor. You know I think i'll just use emacs
11:39:08 <hpc> or refactor the program so you pass the handle around and read progressively
11:39:20 <applicative> xcode here doesnt mean the obnoxious editor
11:39:29 <hpc> see also:
11:39:31 <hpc> :t withFile
11:39:31 <lambdabot> Not in scope: `withFile'
11:39:38 <applicative> its the 'unix  tools' that are included or whatever theyre called
11:39:44 <merijn> applicative: Well, it does. But you don't have to use it :p
11:40:01 <merijn> haskell_chap: XCode is a dependency for installing gcc on OSX
11:40:08 <applicative> yeah, i'm sayig what you need, good luck disaggregating
11:40:25 <merijn> haskell_chap: gcc is not installed by default and installing XCode will install all the dev tools you need
11:40:33 <haskell_chap> applicative: i'm following the material outlined in this Standford course: http://www.scs.stanford.edu/11au-cs240h/
11:41:01 <applicative> yes excellent, it moves at a fast pace ")
11:41:04 <applicative> :)
11:42:20 <applicative> yeah here, haskell_chap you need to install some version of xcode, in particular the chunk labelled "Unix Development Support"
11:42:22 <haskell_chap> merijn: I don't understand but i'll muse on what you just said
11:43:18 <applicative> I notice somewhere that apple had condescended to notice homebrew and that the right gcc rightly installed might be available via homebrew sometime
11:43:26 <haskell_chap> applicative: ok i'll look for that version
11:43:28 <applicative> which would simplify things
11:43:53 <merijn> haskell_chap: It's simple, OSX does not have gcc (or make or any dev-tools) installed. Installing XCode is the canonical way to install dev-tools on OSX
11:44:00 <applicative> the "Unix Development Support" will be in any xcode, though mine is a bit out of date
11:44:11 <applicative> they cant sell machines with gcc
11:44:24 <haskell_chap> applicative: i'll be on the lookout for that via homebrew
11:44:30 <merijn> haskell_chap: 1) Instal XCode from App Store 2) Start XCode 3) Go to Preferences > Downloads and click "Install command line tools"
11:44:51 <applicative> the simple path im mentioning is for the future
11:45:08 <merijn> 4) Install Haskell Platform 5) (Lion only) Edit /usr/bin/ghc to point to the correct gcc path
11:45:25 <merijn> haskell_chap: Doing it without installing XCode is a path full of pain and madness
11:45:30 <applicative> when mzero is done, the last  bit will be unnecessary
11:45:36 <haskell_chap> merijn: I already have Xcode so ill skip to STEP 3
11:45:55 * applicative reaffirms all of merijns  points
11:45:57 <mzero> if you are installing Xcode 4.3 - you should install the "command line tools" which you do from within Xcode once it is isntalled
11:46:41 <applicative> haskell_chap: now we have a real authority intevening.... :)
11:46:49 <haskell_chap> merijn: well thanks for saving me all the pain and madness. What would I do without you guys?
11:46:58 <merijn> haskell_chap: np :)
11:47:26 <xemdetia> hooray I finally have 7.4.1 installed and HDBC + snap
11:49:04 <pooya72> Hi I'm a programming novice, just learning haskell throuh "Real World Haskell." I love it so far. Static typing is really interesting. Any tips for learning Haskell?
11:49:52 <merijn> pooya72: If you feel like RWH is going to fast for you I can recommend Learn You a Haskell, it is a bit slower paced and easier to follow (imo) than RWH
11:50:30 <merijn> Other than that, playing around with ghci (and/or tryhaskell.com) is a good start
11:50:38 <xemdetia> be aware too that some RWH examples use stuff that's deprecated
11:50:46 <byorgey> hanging out in here and asking questions is also a good idea.
11:51:19 <pooya72> merijn: Actually I started with LYAH and I thought that was going too fast. To many commands not enough concepts. So went with RWH. I like how it explains why Haskell does things the way it does.
11:51:47 <pooya72> xemdetia: what is deprecated? commands or packages?
11:52:02 <pooya72> byorgey: will do ;)
11:52:09 <xemdetia> pooya72: some examples in the exception handling stuff section use the old version
11:52:28 <pooya72> xmedetia: ok, will keep that in mind
11:52:56 <xemdetia> I fussed with that myself a few days ago actually and was trying to use it as an example but ended up finding my own bloody path through it. It actually comes up with a lot of packages so I don't know what's going on there.
11:53:04 <zezikaro> How can I count all of the elements in a list of integer?
11:53:06 <zezikaro> I have this atm http://ideone.com/gBlX6
11:53:13 <zezikaro> and it works, but what's the better way of doing it?
11:53:41 <dmwit> :t sum
11:53:42 <lambdabot> forall a. (Num a) => [a] -> a
11:53:55 <dmwit> ?src print
11:53:55 <lambdabot> print x = putStrLn (show x)
11:54:12 <dmwit> zezikaro: Both of those are aimed at you. =)
11:55:18 <zezikaro> sorry i'm new
11:55:22 <zezikaro> i just started today >.<
11:55:58 <byorgey> zezikaro: no apologies necessary, welcome =)
11:56:04 <zezikaro> I get the second bit; print (sum' [1..100])
11:56:14 <zezikaro> since i was doing what print already has
11:56:17 <zezikaro> thanks :P
11:56:29 <haskell_chap> So I have a big question, saw it on reddit, so here goes: who in the Haskell community is in charge of innovating Haskell libraries for the mac platform?
11:56:42 <dmwit> ?src sum
11:56:42 <byorgey> zezikaro: first, note that instead of using tail and head, you should pattern-match on the list
11:56:42 <lambdabot> sum = foldl (+) 0
11:56:52 <solrize> zezikaro, do you know about tail recursion?
11:56:53 <haskell_chap> im in NY so i'd preferably like to work with someone here
11:56:54 <byorgey> zezikaro: like  sum' (a:as) = ...
11:57:02 <dmwit> haskell_chap: "in charge"?
11:57:04 <mzero> haskell_chap: what do you mean "in charge"
11:57:09 <zezikaro> solarus I thought this was! =[
11:57:18 <dmwit> haskell_chap: People who want Mac OS features are in charge of implementing those features.
11:57:23 <haskell_chap> by 'in charge' I mean taking the greatest stand
11:57:29 <zezikaro> Isn't it tail recursive if the recursion happens first, then the additional stuff happens last
11:57:32 <byorgey> don't worry about tail recursion for now.  it's not even really important in haskell anyway.
11:57:37 <mzero> "stand"? Is there an argument here?
11:57:44 <byorgey> zezikaro: no.  but it's not important for now. =)
11:57:48 <solrize> zezikaro, tail recursion means the recursive call gives the final result.  in your example you're making a recursive call, then adding the result to something
11:58:03 <zezikaro> I did it that way, because i thought THAT was tail recursive :P
11:58:06 <mzero> do you mean, who is "doing the most"? not many --- I don't think I know of many Mac OS specific Haskell libraries
11:58:08 <haskell_chap> who is authentically pursuing this not in their self interest, but in the interest of the great good?
11:58:13 <zezikaro> I was told a + recursiveCall
11:58:14 <zezikaro> was bad
11:58:23 <zezikaro> because then it's generating a huge list of functions
11:58:30 <Nimatek> > let sum' [] = 0; sum' (x:xs) = x + sum' xs in sum' [1..10] -- zezikaro
11:58:30 <lambdabot>   55
11:58:31 <haskell_chap> damn it's going to rain here in Bryant park so be quick about it
11:58:40 <solrize> well as byorgey says, don't worry about it for now, but your version uses linear stack space
11:59:04 <byorgey> zezikaro: note that the order of arguments to + makes no difference.
11:59:12 <mzero> I don't know what you mean by "this" - there is a Mac Object-C bridge effort, and there has been some Mac Cocoa integration effort - and there is a Mac iOS effort ----
11:59:23 <mzero> these are led by various people for various reasons
11:59:41 <zezikaro> I've got a lot more of this haskell book to read i see... :P
11:59:56 <byorgey> zezikaro: did you understand my comment above about pattern-matching?
12:00:03 <mzero> personally, I'm "in charge" of building the Mac OS X installer for Haskell Platform
12:00:09 <byorgey> that is much more important at this point than efficiency.
12:00:17 * mzero which is what I'm actually trying to do at this very instant
12:00:20 <haskell_chap> what do you mean don't worry about it? A project like this would give some personal meaning to my life and help my growth in the community. Please dont tell me not to worry about it
12:00:59 <mzero> "don't worry about it" wasn't directed at you, haskell_chap
12:01:00 <gurrag> What's the best Linux GUI library for Haskell?
12:01:17 <merijn> haskell_chap: All open source is people pursuing things out of self interest :p
12:01:21 <dmwit> gurrag: The bindings to the library you already know will be best.
12:01:34 <haskell_chap> mzero: then it is quite serindipidous that I began speaking with you from the very beginning. I would like to help you, but I have to cultivate myself with the langauge before I can begin a project
12:01:39 <gurrag> are there bindings to Xlib?
12:01:52 <mzero> true dat
12:01:55 <luite> gurrag: there's gtk2hs and wxhaskell
12:01:55 <dmwit> gurrag: If you know Gtk, use gtk2hs; if you know wx, use wxhaskell; if you know Qt, use the Qt bindings; if you know SDL, use sdl-whatever-it's-called, etc.
12:02:05 <dmwit> gurrag: There are bindings to Xlib in the X11 library.
12:02:07 <dmwit> ?hackage X11
12:02:08 <lambdabot> http://hackage.haskell.org/package/X11
12:02:16 <gurrag> ok thanks
12:02:24 <gurrag> also nice to know that SDL's in there
12:02:31 <luite> i'm not sure how well-maintained the Qt bindings are
12:02:38 <dmwit> Me neither, actually.
12:02:41 <merijn> I heard the Qt bindings are rather...experimental
12:02:44 <gurrag> I don't use Qt anyway, I have a pretty low-resource machine
12:02:44 <dmwit> But the others are pretty popular.
12:03:39 <haskell_chap> merijn: false. open source is about the greater good. Any of us would die without society's help so rational self interest is in the pursuit of helping the 'weak' in an economically darwinistic sense
12:04:17 <haskell_chap> merijn: look at what DARPA is doing to help the handicaped. Point proven.
12:04:34 <gurrag> are you secretly rms
12:04:55 <haskell_chap> merijn: have you seen the robotic arm?
12:05:15 <merijn> haskell_chap: I've never in my life contributed something to open source out of ethical incentive. I have done quite a bit of stuff because I wanted something to work that didn't
12:05:35 <dmwit> "Somebody is doing something, and it isn't obvious to me how that thing could be in their self-interest; therefore, nobody does anything in their own self-interest."
12:05:38 <dmwit> ...wut
12:05:47 <mzero> I think you want #haskell-blah for that discussion (really!)
12:06:09 <merijn> Yeah, probably
12:06:39 <haskell_chap> merijn: well im sure you are missing out on all the pork barrel our government sloshes about for open source projects! DARPA, NASA these projects cost billions and billions
12:07:07 <haskell_chap> merijn: why go to the petty capitalist in late capitalism?
12:07:40 <danr> is there a safe (!!) (i.e returning Maybe) in some reasonable library?
12:07:44 <merijn> haskell_chap: Many scientists do science just because it's neat, not because it is necessarily good for society. Anyhoo, this iff off-topic for here and should move to #haskell-blah
12:08:06 <byorgey> danr: yes, the 'safe' library
12:08:08 <byorgey> @package safe
12:08:09 <lambdabot> http://hackage.haskell.org/package/safe
12:08:15 <haskell_chap> merijn: ok ill reserve my chit-chat for there
12:08:32 <danr> byorgey: Alright, I'll depend on it. Thanks :)
12:08:39 <merijn> danr: '\n -> listToMaybe . drop n'?
12:09:48 <danr> merijn: I was considering that too ;)
12:14:32 <strager> Can I record the stream items (tokens, chars, etc.) consumed by a parser in Parsec?
12:14:39 <strager> Something like ParsecT s u m a -> ParsecT s u m (a, [s])
12:18:47 <pooya72> So do other statically typed programming languages allow you to declare new data types like haskell? like: data Book = Book Int String [String] ?
12:19:01 <pooya72> I just find this really amazing
12:19:41 <mzero> uhm- don't almost ALL programming languages allow you to declare new data types?
12:19:49 <Eduard_Munteanu> pooya72: it's called a disjoint union, basically
12:20:12 <Eduard_Munteanu> (assuming you have other constructors too)
12:20:21 <otters> mzero: not really
12:20:32 <otters> actually, a lot do
12:20:33 <Eduard_Munteanu> But yeah, for this one in particular, it seems valid for a lot of languages out there.
12:20:35 <Nimatek> Not all languages have algebraic data types though.
12:20:39 <merijn> pooya72: You can do it in other functional languages to, Ocaml/SML (really ML's in general) and things like F# for example
12:20:53 <mzero> I'm not sure what aspect you're finding amazing, pooya72
12:21:15 <mzero> the example you gave is pretty vanilla --- and exists in a similar form in most languages
12:21:15 <adamt> *couch* c structs *cough*
12:21:15 <merijn> mzero: That's because you've been jaded by years of haskell :)
12:21:16 <Eduard_Munteanu> The brevity?
12:21:51 <Eduard_Munteanu> Take a couch suppressant :P
12:21:58 <byorgey> Java, C, C++, Perl, Ruby, Python -- just a few languages that DON'T have anything similar.
12:22:40 <dmwit> Java has something like open ADTs.
12:22:41 <strager> struct Book { int a; char *b; char **c; };  // C
12:22:55 * byorgey is not sure what aspect mzero doesn't find amazing
12:23:03 <dmwit> You make an abstract base class for your type, and one class inherits from it for each constructor you would have in Haskell.
12:23:03 <byorgey> algebraic data types are super fantastic
12:23:12 <pooya72> so give me an example similar to data Book = Book Int String [String] in either clojure ruby or python. So I can relate to it. If it's possible.
12:23:29 <pooya72> maybe I'm not understanding the concept properly
12:23:31 <strager> I know none of those, but I gave an example in C above.
12:23:40 <adamt> pooya72: in clojure you would just use a tuple for it, probably.
12:23:51 <pooya72> strager: thanks, but I don't know C :)
12:23:53 <dmwit> pooya72: class Book { int field1; string field2; list<string> field3 }
12:23:59 <dmwit> Forgive my syntax.
12:24:14 <dmwit> I've been long in the Haskell world.
12:24:27 <ion> class Book < Struct.new(:foo, :bar, :baz); end
12:24:50 <Eduard_Munteanu> ion: what is that?
12:24:55 <otters> ruby
12:24:58 <ion> Ruby
12:24:58 <Eduard_Munteanu> Ah.
12:24:59 <merijn> Eduard_Munteanu: Looks like Ruby to me
12:25:09 <byorgey> the crux of the issue, however, is that the Book example only involves product, not sum.  Many languages give you something like that.
12:25:19 <byorgey> it's when you add in sums that you have to go to contortions.
12:25:25 <ion> yeah
12:25:37 <zezikaro> ] <byorgey> zezikaro: did you understand my comment above about pattern-matching?
12:25:40 <zezikaro> No :(
12:25:44 <zezikaro> I haven't reached that yet in the book
12:25:46 <zezikaro> (if it's there)
12:25:56 <dmwit> It's certainly there.
12:25:59 <pooya72> ok, so in other languages you would rely on class, then have have functions use that. Ok I understand it better now...
12:26:00 <byorgey> zezikaro: which book are you reading?
12:26:25 <byorgey> if it introduces the 'head' and 'tail' functions before it talks about pattern-matching, that book should be taken out back and shot.
12:26:26 <adamt> pooya72: If you don't understand it at first, you won't understand it by comparing it to inferior models from other languages. ;)
12:26:52 <pooya72> maybe that's cause I would just go from SQL query to function without classes
12:26:53 <Nimatek> zezikaro: in your "sum' a" instead of accessing parts of the list a through heads and tail, you can pattern match as sum' (x:xs) where x is the head and xs the tail.
12:26:56 <zezikaro> byorgey learn you a haskell
12:26:58 <Nimatek> head*
12:27:01 <zezikaro> for great good
12:27:02 <byorgey> zezikaro: well, you are already doing it a little bit. Your function has two clauses.  the first clause says  sum [] = 0
12:27:07 <pooya72> adamt: yeah maybe ;{
12:27:09 <pooya72> ;)
12:27:30 <zezikaro> I only know of something like sum' _ = 1
12:27:32 <zezikaro> i think
12:27:35 <merijn> @hoogle [a] -> [(a,a)]
12:27:35 <zezikaro> where you don't care what it is
12:27:35 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
12:27:36 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
12:27:36 <lambdabot> Data.Graph.Inductive.Query.Monad apply :: GT m g a -> m g -> m (a, g)
12:27:52 <zezikaro> I think I think I think.
12:27:57 <byorgey> zezikaro: the [] is called a pattern, you are seeing whether the argument matches that pattern, in this case, whether it is the empty list
12:28:07 <merijn> Is there a convenient way to turn a list into a list of pairs of items?
12:28:07 <byorgey> zezikaro: right, _ is a pattern meaning you don't care
12:28:08 <zezikaro> ah, I thought it was overloads
12:28:29 <applicative> zezikaro: no, its just that you dont use it on the rhs
12:28:39 <byorgey> zezikaro: something like  (a:as)  would be a pattern that tests whether the list has at least one element, and it calls the first element a and the rest of the list as
12:28:57 <zezikaro> cna you do it the other way?
12:29:00 <zezikaro> ie, you want the last
12:29:03 <byorgey> zezikaro: so you could say   sum' (a:as) = ... a ... as ...
12:29:15 <byorgey> zezikaro: good question. No, you can't.
12:29:22 <applicative> with list zezikaro no way
12:29:31 <zezikaro> thanks
12:29:42 <byorgey> zezikaro: because lists are constructed using [] (empty list) and (:)  (cons) which adds an element to the *front* of a list
12:29:49 <byorgey> so you have to take them apart the same way.
12:30:00 <applicative> zezikaro: its frequently  irritating but follows from the essence of the matter
12:30:37 <byorgey> if you really need that, it just means you ought to be using a different data structure.
12:31:25 <byorgey> > let f [] = 0; f (x:_) = x  in  f []
12:31:27 <lambdabot>   0
12:31:30 <byorgey> > let f [] = 0; f (x:_) = x  in  f [1,2,3]
12:31:31 <lambdabot>   1
12:31:58 <danr> @hoogle (a -> m (Maybe b)) -> [a] -> m [b]
12:31:59 <byorgey> note  [1,2,3] is really an abbreviation for  1 : (2 : (3 : [])), so it matches  (x:_) with x = 1
12:31:59 <lambdabot> No results found
12:32:26 <byorgey> (and with [2,3] matching the _ part, but that gets thrown away of course)
12:32:31 <byorgey> zezikaro: is this making any sense?
12:34:03 <zezikaro> yes thank you
12:34:39 <zezikaro> is 'as', 'a set' ?
12:34:44 <zezikaro> element a, and a set of a
12:34:51 <ion> % ghc -XSafe -e 'import Unsafe.Coerce' -e 'unsafeCoerce [] :: Bool'
12:34:53 <strager> :t \f xs -> liftM catMaybes $ mapM f xs
12:34:54 <ion> False
12:34:54 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> m (Maybe a)) -> [a1] -> m [a]
12:34:56 <ion> :-(
12:35:05 <strager> ^ danr
12:36:01 <strager> zezikaro: No; people usually put 's' at the end to pluralize something
12:36:20 <strager> xs => many x; just like cows => many cow
12:36:30 <merijn> One ball, multiple balls. One a, multiple as
12:37:01 <strager> And usually it means a "list of 0 or more elements"
12:37:07 <strager> Not necessarily two or more
12:37:47 <zezikaro> haha okay
12:37:56 <zezikaro> thanks
12:38:35 * monochrom has a list of wives!
12:38:43 <strager> wifes*
12:40:45 <ion> tail [] is a list of −1 elements.
12:41:02 <zezikaro> > 1
12:41:03 <lambdabot>   1
12:41:07 <zezikaro> > tail []
12:41:08 <lambdabot>   *Exception: Prelude.tail: empty list
12:41:26 <zezikaro> >init []
12:41:34 <zezikaro> > init []
12:41:35 <lambdabot>   *Exception: Prelude.init: empty list
12:41:50 <zezikaro> i thought it would've returned an empty list
12:41:53 <byorgey> zezikaro: and this is exactly why you should not use such functions.
12:42:03 <byorgey> zezikaro: yes, that would be much more sensible.
12:42:05 <pooya72> so does Haskell's strict typing produce better designed programs because it forces you to design the input to your functions? From that class / data type thing above, I realized how wrong my ruby code was :) (but I'm a noob hobbyist)
12:42:09 <byorgey> or returning a Maybe
12:42:15 <strager> pooya72: I'd say no.
12:42:24 <pooya72> strager: why?
12:42:30 <hpaste> d-snp pasted “pattern match order” at http://hpaste.org/69072
12:42:42 <d-snp> hey, in what order are patterns matched, will this work?
12:42:46 <strager> Okay, 'better designed' than what?  a Java program?
12:42:49 <monochrom> I think yes
12:42:50 <strager> Or a Ruby one?
12:43:06 <pooya72> well Ruby, cause it's dynamically typed
12:43:31 <byorgey> d-snp: patterns are matched from top to bottom.
12:43:35 <strager> In that case, yes, because in Haskell and other statically-typed languages, you often think in terms of contracts and encapsulation.
12:43:49 <pooya72> monochrome: why yes?
12:43:54 <byorgey> d-snp: that will not work because it is a type error.
12:44:05 <d-snp> ohh so I need to put it all the way at the bottom, that's a pity, is there no inequality error?
12:44:11 <d-snp> type error?
12:44:14 <pooya72> strager: but not much of an advantage over java or others?
12:44:39 <newsham> pooya72: I wouldnt say it makes "better programs".  what it does is perform some kind of check on your program at compile time.  and performing any kind of check at all is boudn to find some bugs in your program.
12:45:01 <byorgey> d-snp: yeah, you need to put it at the bottom.  Note that you can write  handleInit MkSocket{} _ _ _  = ...  if you don't care about the arguments to the MkSocket constructor
12:45:09 <newsham> so you get some bugs pointed out at compile time very early so youc an fix them early.  finding and fixing bugs isone of the hardest parts of programming, so its a big win.
12:45:12 <byorgey> d-snp: but just writing 'MkSocket' by itself is an error because it expects arguments
12:45:23 <strager> pooya72: I don't think inheritently so, no.
12:45:27 <d-snp> ohhh sorry I forgot to remove the MkSocket
12:45:29 <d-snp> thanks
12:45:51 <pooya72> pooya72: but doesn't relive you of cognitive load? Like you don't have to keep your data model in your head cause you have a system that keeps checking it?
12:45:54 <strager> newsham: I think pooya72 is discussing more on the design of a program than the debugging aspect.  But that's a valid point.
12:46:02 <byorgey> d-snp: ah, ok. but yes, it needs to go at the bottom.
12:46:08 <pooya72> strager: yes
12:46:26 <pooya72> newsham: but doesn't relive you of cognitive load? Like you don't have to keep your data model in your head cause you have a system that keeps checking it?
12:46:28 <newsham> strager: I think you design programs the same way in dynamic and statically typed programs.  if you're not thinking about the types you're probably just making mistakes
12:46:44 <zezikaro> Do all haskell functions have to return something?
12:46:49 <zezikaro> there's no, "void" ?
12:46:49 <byorgey> d-snp: you could do something like handleInit MkSocket{socketState=s} _ _ | s /= LISTENING = ...   but that's kind of ugly
12:46:51 <newsham> pooya72: i think about the types all the time when programming in dynamically typed languages
12:46:55 <byorgey> zezikaro: correct
12:47:21 <newsham> zezikaro: yes, but you can return data with no meaningful informational content.
12:47:23 <byorgey> zezikaro: there is, however, the type ()  (pronounced "unit") which has only one value, also called ()
12:47:25 <newsham> ie "()"  the empty tuple
12:47:25 <strager> newsham: I think it's about encouragement.  In static languages you're encouraged to create data types which have a clear meaning.  In dynamic languages you often cheat and use arrays or hashmaps for a lot of things, if you're lazy.  =]
12:47:32 <byorgey> zezikaro: so a value of type  ()  doesn't tell you anything
12:47:35 <monochrom> the type system encourages some software structures and discourages some others. for example if it gives you parametric polymorphism, you just write one foldr and it is already good for [Int], [Double], [Double->Int]... without it, you will write 3 foldr's.
12:47:49 <merijn> pooya72: One example, I recently refactored a reasonably complex program I'm working on. In some scenario's I refactored without even really understanding the simplification (because HLint recommended it, or just by playing in ghci) and afterwards everything still worked without error :)
12:47:49 <byorgey> zezikaro: so if you "don't want to return anything" you can just return ()
12:47:56 <zezikaro> thank you
12:48:02 <newsham> strager: strongly typed languages dont discourage the use of arrays and hashmaps
12:48:03 <merijn> pooya72: Pretty sure I wouldn't have been able to do that in python or something similar
12:48:04 <pooya72> newsham: yeah, but can't you kind of relive the you're brain of a lot of that load cause of the type system? just wondering...
12:48:09 <zezikaro> i'm not sure what sort of program to write for this yet xD
12:48:15 <zezikaro> i can do some cool stuff
12:48:21 <newsham> pooya72: I dont agree.
12:48:22 <zezikaro> but i'm not sure how i'd ever get an application running on it
12:48:32 <pooya72> strager: that's how I used to program. hashmap all the things!
12:48:37 <strager> newsham: Yes they do, because if you do that you have lots of casting/coercion/typechecking in your code.
12:48:43 <pooya72> newsham: ok thanks
12:48:48 <strager> That's friction which dynamic languages generally don't have in this case.
12:49:03 <newsham> strager: you're talking about something else which is implicit vs. explicit coercion
12:49:14 <newsham> you can have a strongly typed language with implicit coercion
12:49:43 <Eduard_Munteanu> You can?
12:49:47 <strager> Array myArray = new Array(); myArray[0] = new Car(); myArray[0].drive();
12:50:04 <strager> The third statement would need an explicit cast in most OOP static languages.
12:50:13 <Ralith> newsham: are you sure you don't have 'strong' and 'static' confused?
12:50:56 <Eduard_Munteanu> Arguably all/most languages are like that then, since they do keep track of types strictly.
12:51:05 <merijn> Is there a "[a] -> [(a,a)]" function somewhere that Hoogle isn't finding?
12:51:10 <strager> (I know you can have templates, generics, polymorphic types, whatever, but it's a short example =])
12:51:19 <newsham> strager: true.  but is that discouraging its use?  i guess thats a matter of opinion.
12:51:20 <merijn> newsham: No implicit coercion is the definition of strongly typed...
12:51:33 <newsham> ok i think i was talkign about static typing, sorry.
12:51:57 <Tomsik> @djinn [a] -> [(a,a)]
12:51:58 <lambdabot> Error: Undefined type []
12:52:00 <merijn> Python is strongly typed, but not static. C is statically type,d but not strong
12:52:24 <Tomsik> @djinn Functor f => f a -> f (a,a)
12:52:25 <lambdabot> Error: Class not found: Functor
12:52:52 <strager> newsham: More typing => more discouragement => less likely to structure a program which relies on it
12:53:17 <Tomsik> strager, runtime bugs are more discouraging
12:53:27 <ski> @djinn Functor f => f a -> f (a,a)
12:53:28 <lambdabot> -- f cannot be realized.
12:53:50 <ski> (`djinn' doesn't understand polymorphic methods)
12:53:57 <strager> by typing I meant human typing, on a keyboard
12:54:27 <strager> merijn: Well there's map (\x -> (x,x))
12:54:42 <zezikaro> Can you define a function foo a, b such that you can have a different action called out if both a b are reals
12:54:43 <Tomsik> there's also const []
12:54:44 <Tomsik> ;)
12:54:44 <newsham> ?type fmap (\x -> (x,x))
12:54:45 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f (a, a)
12:54:45 <zezikaro> or a and b are integer etc
12:54:49 <ski> @type zip`ap`tail
12:54:51 <lambdabot> forall b. [b] -> [(b, b)]
12:54:57 <ski> @quote aztec
12:54:58 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
12:55:04 <zezikaro> ?type sum
12:55:05 <lambdabot> forall a. (Num a) => [a] -> a
12:55:36 <Tomsik> strager, in a dynamically typed language you have to type more
12:55:40 <merijn> strager: I was looking for "pair (x1:x2:xs) = (x1, x2) : pair xs
12:55:43 <strager> zezikaro: Not unless you make a type class
12:55:48 <Tomsik> because you don't have implicit type information passed by compiler around
12:55:56 <strager> merijn: Oh, I see
12:55:57 <merijn> err, that and "pair _ = []"
12:55:58 <zezikaro> thank you
12:56:05 <fmap> @type fmap (join (,))
12:56:06 <zezikaro> i think i saw that in the book
12:56:06 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f (a, a)
12:56:34 <strager> zezikaro: It's like addition; it's defined differently for different types.
12:56:34 <Tomsik> join instance for (->) is pretty useful
12:56:38 * ski wonders how to write merijn's `pair' with `foldr'
12:56:49 <newsham> they should give it a name, tomsik.
12:56:54 <newsham> "they" = stdlib authors
12:57:06 <ski> give what a name ?
12:57:06 <Tomsik> probably, it took me a good while to find that
12:57:21 <Tomsik> ski, join :: (a -> a -> a) -> (a -> a)
12:57:39 <ski> i think it's called `W' or something like that
12:57:40 <otters> join f x = f x x
12:57:42 <ski> ("Warbler" ?)
12:58:05 <Tomsik> ski, but it's not anywhere in the standard library
12:58:12 <fmap> (t → t → a) → (t → a) *
12:58:28 <Tomsik> besides using join that can make someone scratch his head if he doesn't know what it does
12:58:56 <ski> yeah, it's warbler
12:59:15 <ski> see "To Dissect a Mockingbird: A Graphical Notation for the Lambda Calculus with Animated Reduction" <http://dkeenan.com/Lambda/>
12:59:24 <ski> also
12:59:25 <ski> @where smullyan
12:59:26 <lambdabot> Raymond Merril Smullyan, "To mock a mockingbird : and other logic puzzles including an amazing adventure in combinatory logic","The riddle of Scheherazade and other amazing puzzles, ancient & modern"
12:59:26 <lambdabot> ,"What is the name of this book : The riddle of dracula and other logical puzzles"
12:59:36 <newsham> ?let warbler f x = f x x
12:59:37 <lambdabot>  Defined.
12:59:52 <aristid> :t warbler
12:59:52 <lambdabot> forall t t1. (t -> t -> t1) -> t -> t1
13:00:08 <monochrom> what?! the riddle of dracula?!
13:00:13 <aristid> @pl \f x -> f x x
13:00:13 <lambdabot> join
13:00:32 <monochrom> is that along the line of "pride and prejudice and zombies"? :)
13:00:55 <merijn> monochrom: That one is suprisingly readable, btw
13:01:12 <merijn> Although I haven't read pride and prejudice so I can't really compare :p
13:01:41 <newsham> merijn: pdf? :)
13:01:52 * ski thought merijn was talking about the smullyan book ..
13:02:48 <monochrom> "pride and prejudice and perfectly logical angel or demon guarding the crossroad to heaven and hell"
13:03:53 <strager> Oh no; I wrote a semicolon at the end of a 'return' expression.  =[
13:04:00 <monochrom> @quote monochrom angel
13:04:00 <lambdabot> monochrom says: at a crossroad you meet an angel (always tells the truth) or demon (always lies). the crossroad gives you two choices of roads, one to heaven, one to hell, and only the angel or
13:04:00 <lambdabot> demon knows which is which. if you ask "how would you answer if I asked 'what is a monad?'", what will happen?
13:06:17 <newsham> which road would the other dude tell me to follow?
13:06:36 <monochrom> unfortunately there is only one dude
13:07:12 <monochrom> well, you could say, you mean "the opposite of you", but that's kind of awkward
13:07:42 <Tomsik> I think the answer should be beating with a stick
13:07:44 <newsham> "what would the devil say is the right road to take?"
13:07:48 <monochrom> the truth is you need neither "the other dude" nor "the opposite of you"
13:08:00 <jonaskoelker> you just need squaring of either 1 or -1
13:08:10 <newsham> tomsik: thats "if you see the buddha on the road"
13:08:18 <jonaskoelker> or self-xor of either 0 or 1
13:08:38 <newsham> mono: the answer is "burrito", duh.
13:08:49 <monochrom> yeah!
13:10:06 <d-snp> jay for ruby! \o/
13:10:12 <Tomsik> There's a band named burrito, by the way
13:13:08 <d-snp> Ok, modules loaded!
13:13:19 <d-snp> making ze progresses
13:14:14 <merijn> Argh
13:14:34 <merijn> There is no format string for month numbers without a leading zero in Data.Time.Format?
13:14:34 <d-snp> what'sup merijn? :)
13:14:46 <d-snp> ew
13:14:54 <d-snp> that can't be right
13:15:23 <merijn> I can't find one in the docs anyway
13:15:54 <d-snp> you mean a default string?
13:15:58 <ski> monochrom : .. made me think of <http://web.archive.org/web/20100214103957/http://www.cs.chalmers.se/~augustss/AFP/problems/devils-n-angels/>
13:16:02 <jonaskoelker> @hoogle (a, b) -> (a -> IO aa) -> (b -> IO bb) -> IO c
13:16:03 <lambdabot> No results found
13:16:22 <merijn> d-snp: No, I mean the characters combinations you use to parse/format time values
13:16:26 * ski . o O ( Singleton variables : `c' )
13:16:27 <jonaskoelker> is there something which applies two IO actions to the two elements of a tuple?
13:17:07 <merijn> > readTime defaultTimeLocale "%m/%d/%Y" "05/01/2008" -- This
13:17:07 <lambdabot>   Not in scope: `readTime'Not in scope: `defaultTimeLocale'
13:17:19 <mzero> :t (&&&)
13:17:20 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
13:17:20 <ski> @type \f g -> runKleisli (Kleisli f *** Kleisli g)
13:17:21 <merijn> > readTime System.Locale.defaultTimeLocale "%m/%d/%Y" "05/01/2008" -- This
13:17:21 <lambdabot>   Not in scope: `readTime'Not in scope: `System.Locale.defaultTimeLocale'
13:17:21 <d-snp> merijn: does %m-z not work?
13:17:22 <lambdabot> forall b (m :: * -> *) c b' c'. (Monad m) => (b -> m c) -> (b' -> m c') -> (b, b') -> m (c, c')
13:18:00 <d-snp> eh I' mean %-m
13:18:11 <ski> jonaskoelker : like that ?
13:18:31 <mzero> ah, jonaskoelker   (***) from Arrow
13:18:37 <jonaskoelker> :t (***)
13:18:38 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
13:19:13 <jonaskoelker> let me try
13:19:20 <merijn> d-snp: For reading it doesn't, at least
13:19:44 <merijn> d-snp: This throws an exception for me: readTime defaultTimeLocale "%-m/%e/%Y" "5/1/2008" :: Day
13:20:22 <ski> @type let (.) = (Prelude..) in \f g -> uncurry (liftM2 (,)) . (f *** g)  -- alternative
13:20:22 <mzero> > let twoThings = putStrLn *** (putStrLn . show . (*10)) in twoThings ("hiho", 42)
13:20:23 <lambdabot> forall a1 a2 (m :: * -> *) b b'. (Monad m) => (b -> m a1) -> (b' -> m a2) -> (b, b') -> m (a1, a2)
13:20:24 <lambdabot>   (<IO ()>,<IO ()>)
13:22:02 <merijn> d-snp: And of course I can't blindly pad with zero, since that will crash for months with two digits
13:22:31 <ski> @type let swap = snd &&& fst in fmap (fmap swap . strength . swap) . strength
13:22:32 <timthelion> What is the Ordering version of (<) Such that (<Ordering) :: Ord a => a -> a -> Ordering
13:22:32 <lambdabot> forall a c (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (f c, f1 a) -> f1 (f (c, a))
13:24:25 <timthelion> Such that I can sortBy (\a b -> (pointOf a) < (pointOf b)) myListOfThingsWithPoints
13:24:35 <fmap> compare?
13:24:42 <opqdonut> compare
13:24:44 <opqdonut> :t compare
13:24:45 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
13:25:02 <timthelion> and compare relates to < or >?
13:25:08 <otters> compare is both
13:25:13 <jonaskoelker> timthelion: you make like `on`
13:25:14 <jonaskoelker> :t on
13:25:15 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
13:25:16 <Eduard_Munteanu> @src Ordering
13:25:17 <lambdabot> data Ordering = LT | EQ | GT
13:25:32 <jonaskoelker> :t sortBy (compare `on` fst)
13:25:33 <lambdabot> forall a b. (Ord a) => [(a, b)] -> [(a, b)]
13:25:41 <ski> @type let swap = snd &&& fst in uncurry (fmap . swap .: (,)) . swap <=< strength
13:25:43 <lambdabot> forall (f :: * -> *) a c. (Functor f, Monad f) => (f c, f a) -> f (c, a)
13:25:53 <timthelion> interesting
13:26:00 <timthelion> jonaskoelker: thanks :)
13:26:06 <jonaskoelker> sure :-)
13:26:10 <jonaskoelker> also, hoogle is your friend
13:26:22 <fmap> :t sortBy (comparing fst)
13:26:23 <lambdabot> forall a b. (Ord a) => [(a, b)] -> [(a, b)]
13:26:24 <jonaskoelker> most of the time, you can hoogle the type of the function you want and it's there
13:26:29 <zezikaro> is it possible to create a 'project' function?
13:26:31 <jonaskoelker> :t comparing
13:26:32 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
13:26:35 <ski> timthelion,jonaskoelker : also `sortBy (comparing pointOf) myListOfThingsWithPoints'
13:26:52 <Eduard_Munteanu> zezikaro: what do you mean?
13:27:08 <jonaskoelker> ski: comparing = on compare?
13:27:11 <jonaskoelker> @src comparing
13:27:11 <lambdabot> Source not found. It can only be attributed to human error.
13:27:25 <Paprikachu> wtf, haskell is sick shit
13:27:31 <ski>   comparing f = compare `on` f  -- yes
13:27:33 <zezikaro> Given arguments
13:27:36 <zezikaro> select the ith argument
13:27:38 <Paprikachu> i mean
13:27:40 <Paprikachu> [22:23:11]	<lambdabot>	forall (f :: * -> *) a c. (Functor f, Monad f) => (f c, f a) -> f (c, a)
13:27:43 <Paprikachu> dude wtf
13:27:53 <merijn> d-snp: Aparently strptime is the package I want, bindings for the C function strptime and that actually behaves sanely :)
13:27:59 * ski beams
13:28:31 <zezikaro> Eduard_Munteanu http://en.wikipedia.org/wiki/Projection_%28set_theory%29
13:28:36 <strager> zezikaro: Yes, with boilerplate.  There is 'const' which is used very often.
13:28:38 <merijn> Paprikachu: You get used to it :p
13:28:38 <strager> @src const
13:28:39 <lambdabot> const x _ = x
13:28:43 <solarus> Paprikachu: your clock is off by 5 minutes!
13:28:55 <timthelion> solarus: OCD!
13:29:05 <Paprikachu> well, i'm not doing haskell because i have no idea what to do with it
13:29:14 <Paprikachu> but it looks just crazy
13:29:15 <Eduard_Munteanu> zezikaro: you need a different 'proj' for different number of arguments.
13:29:22 <adamt> solarus: your's is off by 3 then.
13:29:26 <strager> Paprikachu: Everything before the . there is unnecessary
13:29:33 <strager> (Functor f, Monad f) => (f c, f a) -> f (c, a)
13:29:36 <zezikaro> Eduard_Munteanu Is there not a cool way of doing it?
13:29:37 <timthelion> Paprikachu: I don't understand all that monad functor stuff either, and I do haskell like no one's buisness
13:29:41 <solarus> adamt: 26 May 22:27:56 ntpdate[26191]: adjust time server 130.237.211.2 offset 0.001078 se
13:29:48 <mzero> > let apTuple f g = uncurry (>>) . (f *** g)   in    (putStrLn `apTuple` (putStrLn . show . (*10)) ("hi ho", 42)
13:29:49 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:29:57 <Paprikachu> can you explain to a c++ programmer what a monad is?
13:30:06 <d-snp> :P
13:30:07 <Eduard_Munteanu> zezikaro: do you need different types for the different arguments?
13:30:14 <solarus> adamt: had to check if at was my clock or his :)
13:30:21 <zezikaro> Eduard_Munteanu it'll all be integer
13:30:32 <strager> Paprikachu: There was a good series of blog articles on monads wrt C++
13:30:38 <Eduard_Munteanu> zezikaro: oh, certainly then
13:30:39 <adamt> solarus: my laptop and cell sync individually of each other, but agree on the time. but not with yours. :(
13:30:41 <Eduard_Munteanu> :t (!!)
13:30:42 <lambdabot> forall a. [a] -> Int -> a
13:30:46 <strager> http://bartoszmilewski.com/2011/01/09/monads-for-the-curious-programmer-part-1/
13:30:52 <Eduard_Munteanu> zezikaro: ^^   maybe you can use that
13:30:52 <zezikaro> =[
13:31:07 <Paprikachu> ty
13:31:08 <zezikaro> i'd have to call it as a list
13:31:10 <zezikaro> then
13:31:15 <zezikaro> func [arg1, .. argn]
13:31:16 <ski> Paprikachu : generally speaking, a monad is a abstract interface, comparable to the interface of a priority queue
13:31:16 <zezikaro> but i want
13:31:22 <zezikaro> func arg1, ..., argn
13:31:33 <merijn> Paprikachu: The biggest problem is that they're so simple people thing they missed something in the explanation and look for all this complexity that isn't there
13:31:38 <zezikaro> oh, and an index
13:31:39 <Eduard_Munteanu> You might be able to apply some of that printf magic.
13:31:43 <ski> Paprikachu : .. mind, that doesn't tell you what a monad *is*, only what *kind* of thing it is
13:31:49 <zezikaro> func n arg1, ..., argn => argn
13:32:02 <Paprikachu> sounds strange anyway.
13:32:04 <strager> zezikaro: You don't use commas in such a way
13:32:12 <strager> zezikaro: Why not use a list though?
13:32:27 <d-snp> a monad is just a linked list of function pointers, isn't it? :P
13:32:32 <zezikaro> sorry it was an example
13:32:36 <merijn> Paprikachu: Do you have any experience with jQuery in javascript?
13:32:39 <rhapsodh1> how can i get the milliseconds since epoch in integer or string?
13:32:42 <Eduard_Munteanu> http://stackoverflow.com/questions/7828072/how-does-haskell-printf-work
13:32:50 <ski> d-snp : nope :)
13:33:00 <rhapsodh1> i've been googling for half an hour, and cat get the hang of it
13:33:08 <rhapsodh1> cant
13:33:09 <merijn> Paprikachu: Otherwise, I think the easiest thing to do is examine the Monad instance of Maybe, list and Either
13:33:09 <timthelion> Perhaps we should all just read GHC's source code.  That should provide a description of Monads so simple even a computer can understand.
13:33:32 <Paprikachu> [22:30:05]	<merijn>	Paprikachu: Do you have any experience with jQuery in javascript?
13:33:34 <Paprikachu> nope
13:33:35 <jonaskoelker> > (snd &&& fst) (print 1, print 2)
13:33:36 <lambdabot>   (<IO ()>,<IO ()>)
13:33:49 <jonaskoelker> how do I run those two?
13:33:53 <Paprikachu> i don't do web stuff, that's too boring :x
13:33:54 <hpaste> newsham pasted “epoch time” at http://hpaste.org/69074
13:34:53 <newsham> oops forgot:  epoch = read "1970-01-01 00:00:00.0 UTC" :: UTCTime
13:35:09 <newsham> rhaps: work for you?
13:36:21 <adamt> Paprikachu: Looking at the danish job market, computer science equals web stuff, including making CS ph.d's write html.
13:37:01 <Paprikachu> lol
13:37:06 <merijn> Paprikachu: This is also a nice intro (if you're moderately familiar with basic haskell): You Could Have Invented Monads! (And Maybe You Already Have.) (http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html)
13:37:07 <Paprikachu> web stuff is for idiots
13:37:23 <strager> Yes; I am idiot.
13:37:37 <adamt> Paprikachu: Also, you'll be hard pressed to even get a webdev-job without a masters degree. It's total failure.
13:37:49 <Paprikachu> i don't want to
13:37:52 <merijn> I've reached the point where I don't know which is more painful, native GUI development or developing a HTML5 web interface
13:37:57 <strager> adamt: =[
13:38:01 <adamt> Paprikachu: Good thing you're not in Denmark then. Lol.
13:38:03 <Paprikachu> and yes, guis suck
13:38:16 <Paprikachu> console applications <3
13:38:16 <strager> GUI's don't suck.
13:38:19 <d-snp> oO
13:38:21 <newsham> merijn: html5.
13:38:25 <Nimatek> "Also, you'll be hard pressed to even get a webdev-job without a masters degree." That's sarcasm, I hope.
13:38:39 <adamt> Apparently the result of free education is stupidly high requirements for applicants to jobs.
13:38:43 <d-snp> I love html5
13:38:46 <timthelion> strager: just non keyboard accessable GUIs suck :D
13:38:57 <d-snp> how can you say it's as painful as native gui development?
13:39:18 <newsham> dsnp: because it requires you to go through .js
13:39:41 <adamt> Nimatek: It's quite common in Denmark to demand a masters degree for working with crappy java combined with a crappy web framework.
13:39:47 <timthelion> adamt: the result of free education in the Czech Republic is that every idiot thinks he's entitled to a degree whether he studies and goes to school or not :D
13:39:57 <d-snp> aside from javascript not being all bad, I use coffeescript to make it pretty
13:40:09 <adamt> Sorry, i'm ranting. Just annoyed. :[
13:40:12 <d-snp> :P
13:40:37 <Nimatek> I agree about that being an annoying situation.
13:41:04 <jonaskoelker> adamt: I share your pain ^_^
13:41:06 <d-snp> people with masters degrees tend to make terrible webdevelopers
13:41:13 <timthelion> adamt: Do you guys get a masters in 5 years or 6?
13:41:14 <jonaskoelker> (and country of residence, presumably nationality)
13:41:16 <newsham> dsnp: i didnt say its all bad, just more annoying that going native
13:41:50 <adamt> timthelion: 5 in theory, although it's rare to do it on time.
13:41:56 <d-snp> same here
13:42:32 <adamt> d-snp: Yes, it makes no sense, we even have purely practical education that is aimed at stuff like webdev. But if a company can get a masters instead, well, yeah, it looks nice. :P
13:44:28 <d-snp> company I work for only cares if you have a github account :P
13:44:48 <timthelion> d-snp: can you get them to send me money too?
13:45:01 <d-snp> depends what is on your github account timthelion ;)
13:45:09 <adamt> That's equally stupid (eliminating people not doing open source dev. as possible candidates for a job)
13:45:13 <timthelion> d-snp: some crapy python, and some haskell
13:45:27 <timthelion> d-snp: and a driver and some firmware written in C
13:45:36 <d-snp> adamt: nah, people without opensource work are asked to supply source code from private projects, or assigned a small assignment
13:46:06 <d-snp> timthelion: sounds good :) though we're not hiring atm :P
13:46:22 <Eduard_Munteanu> Open source dev is a pretty good indication of various things.
13:46:55 <adamt> Eduard_Munteanu: That the person is hacking in their spare time, or was lucky enough to get a job for a company paying to do open source dev.
13:47:09 <timthelion> I agree with Eduard_Munteanu anyone with an understanding of information and a passion for computer science has to have done SOME hobby stuff open source.
13:47:30 <d-snp> passion for software development is a key characteristic in my opinion
13:47:37 <timthelion> adamt: hacking in your spare time is a huge indicator in interest in the feild
13:47:50 <d-snp> and it's told by either a nice github account, or a large private collection of projects
13:48:05 <Eduard_Munteanu> adamt: I mean it does show one can deal with an established codebase, sometimes strict rules and deal with people.
13:48:09 <adamt> timthelion: The ideal job should be able to satisfy ones hunger for the field, imo.
13:48:15 <merijn> d-snp: What qualifies as a "nice github account"?
13:48:18 <timthelion> d-snp: Yeah, passion all the way, don't want people taking leave for children or any of that crap!
13:48:18 <d-snp> the github account shows you have a bit of guts/social confidence too
13:48:22 <hpc> d-snp: or open-source projects that don't go through github ;)
13:48:24 <merijn> How many projects/how many SLOC?
13:49:12 <d-snp> merijn: the more the better, when you're hiring you're always looking for the best person who applied / you can hunt
13:49:23 <MagneticDuck> hey there everyone. I'm working on a bit of a self-assigned deadline... I have a problem that I could solve on my own but I was wondering if anybody knew a real fast clean way to solve it:
13:49:40 <strager> merijn: I'd say dabbling in a few problem domains.  i.e. not four CRUD RoR projects.
13:49:49 <timthelion> MagneticDuck: now there's a pickup line :D
13:49:59 <strager> I wonder: how does 'i.e.' interact with negatives?  I'd normally use 'e.g.' there but it was a negative so 'i.e.' felt right.
13:50:09 <MagneticDuck> how do I get the string like "{hello}{bye}{lala}{HELLOAGAIN}" into the list ["hello", "bye", "lala", "HELLOAGAIN"]
13:50:27 <hpc> @src words
13:50:28 <lambdabot> words s = case dropWhile isSpace s of
13:50:28 <lambdabot>     "" -> []
13:50:28 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
13:50:29 <MagneticDuck> I could solve it with a custom recursive function
13:50:42 <Eduard_Munteanu> strager: 'e.g.' normally means for example
13:50:44 <hpc> MagneticDuck: generalize that by parameterizing over isSpace
13:50:53 <MagneticDuck> ?
13:50:54 <merijn> strager: It's quite simple "i.e." means "that is" and is used for an exhaustive alternative definition
13:50:59 <Eduard_Munteanu> While 'i.e.' is more like "in other words".
13:51:00 <hpc> or use parsec, if you don't want "{hello{bacon" to parse
13:51:10 <merijn> strager: "e.g." means "for example" and is used for non-exhaustive lists of examples
13:51:13 <strager> merijn: Yes, but does the negation make it exhaustive?
13:51:18 <hpc> MagneticDuck: words s p = case dropWhile p s of ...
13:51:30 <hpc> er, split s p = ...
13:51:31 <Eduard_Munteanu> strager: not necessarily
13:51:38 <MagneticDuck> split eh
13:51:39 <MagneticDuck> okay
13:51:42 <hpc> then split string (`elem` "{}")
13:51:47 <MagneticDuck> well I'm making a very simple problem
13:51:57 <MagneticDuck> so I might even get away with splitting on |
13:52:04 <adamt> Hopefully you're solving a problem, not creating one. :)
13:52:06 <merijn> @hoogle ((a,b) -> (Maybe c, b)) -> (a, b) -> Maybe (c, b)
13:52:07 <lambdabot> No results found
13:52:25 <Eduard_Munteanu> E.g. "I like my languages pure (e.g. not C)" :D
13:52:39 <strager> merijn: Oh god, I encounter that problem so many times (with Maybe).  I resort to 'do' notation, and I think that's clear enough.
13:52:59 <strager> I consider C pure
13:53:03 <timthelion> >filter (not ""==) $ spit (\a->a== '{' or a=='}') "{hello}{bye}{lala}{HELLOAGAIN}"
13:53:08 <merijn> strager: That would work badly in this case :\
13:53:08 <MagneticDuck> timthelion: heh. I hate all deadlines except my own ones. Those I follow with all my power, whether or not it is necessary to work into the night. xD
13:53:10 <timthelion> > filter (not ""==) $ spit (\a->a== '{' or a=='}') "{hello}{bye}{lala}{HELLOAGAIN}"
13:53:10 <lambdabot>   Not in scope: `spit'Precedence parsing error
13:53:11 <lambdabot>      cannot mix `GHC.Classes.=...
13:53:11 <strager> Not in the 'futrely functional' sense
13:53:35 <MagneticDuck> wait what?
13:53:37 <merijn> strager: As I have a one line helper functions (that currently uses fromJust), changing it to do notation would balloon its size
13:53:48 <timthelion> What is that error?
13:53:53 <MagneticDuck> spit
13:53:53 <MagneticDuck> xD
13:54:03 <Eduard_Munteanu> In the "purists use C" sense? :P
13:54:04 <timthelion> :t split
13:54:05 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
13:54:12 <MagneticDuck> rrr
13:54:14 <timthelion> ah, wrong split
13:54:19 <d-snp> timthelion: how would you prove to a company that you are a good software developer, if you have no opensource work because of your prior job + children?
13:54:24 <MagneticDuck> :t Data.List.split
13:54:25 <lambdabot> Not in scope: `Data.List.split'
13:54:27 <timthelion> I wanted split :: (Char -> Bool) -> Text -> [Text]
13:54:41 <merijn> @pl \(x, y) -> if isJust x then Just (fromJust x, y) else Nothing
13:54:41 <lambdabot> uncurry (flip flip Nothing . ap ((.) . if' . isJust) ((Just .) . (,) . fromJust))
13:54:41 <strager> merijn: It occurs to me more often with data structures without destructing functions, however, not with tuples.
13:54:44 <hpc> d-snp: turn off the termination checker, then prove false
13:54:51 <hpc> oh wait, in reality :P
13:54:54 <d-snp> :P
13:55:12 <strager> Eduard_Munteanu: No, in the 'simple yet powerful' sense (with pointers and its structs and unions).
13:55:20 <strager> 'tis just memory.
13:55:32 <MagneticDuck> rrr where is split??
13:55:40 <hpc> @hoogle split
13:55:41 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
13:55:41 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
13:55:41 <lambdabot> Data.Typeable splitTyConApp :: TypeRep -> (TyCon, [TypeRep])
13:55:42 <strager> And I see what you mean Eduard_Munteanu; thanks (re e.g./i.e.)
13:55:45 <timthelion> d-snp: joke.  When my dad worked for M$, they didn't have leave for newborn children.  The leave was only implimented after(directly after) Bill Gates had his first child.
13:55:55 <d-snp> lol
13:56:03 <ski> @type let (.) = (Prelude..) in (fmap swap . strength . swap .)
13:56:03 <strager> merijn: You'd define it yourself, basing the implmentation off of that of 'words'.
13:56:04 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (a1 -> (f b, a)) -> a1 -> f (b, a)
13:56:28 <zomg> I wonder if I should put my haskell irc bot thingy on github now that you guys were talking about that so much
13:56:32 <MagneticDuck> what should I use to split a list on some element?
13:56:36 <merijn> strager: Yeah, I'll just use the one I just used with @pl
13:56:40 <zomg> Although I think I should first check if it even compiles...
13:56:42 <MagneticDuck> split ' ' = words
13:56:50 <timthelion> MagneticDuck: Data.Text's split
13:56:50 <strager> merijn: err beeped wrong person ;P
13:56:57 <strager> Meant to beep MagneticDuck
13:57:10 <timthelion> MagneticDuck: I gave you the answer, just lambda bot thinks I was refering to a different split
13:57:11 <burbul> Anyone know of a nice line-of-code counting utility for Haskell? (On Windows.)
13:57:29 <ski> merijn : `isJust',`fromJust' :/
13:57:32 <strager> wc -l =]
13:57:33 <MagneticDuck> okay thanks. I'm usually not one to cheat but ME HAZ A DEADLINE
13:57:58 <d-snp> burbul: copy & paste into word? :P
13:58:04 <MagneticDuck> wait a minute... I don't know what Text is...
13:58:05 <burbul> strager: I meant something that only current source code, ignoring comments and whitespace
13:58:12 <d-snp> oh
13:58:13 <strager> I have a loc shell script for Haskell code.  Here's the core:
13:58:14 <strager>   echo "$(cat "$@" | grep -v -E '^[[:space:]]*($|--( |$)|//)' | wc -l) non-blank non-comment lines of code"
13:58:16 <burbul> *only counts source code  [gah dictation software]
13:58:20 <burbul> thanks!
13:58:50 * timthelion just looks at githubs graphs
13:58:55 <strager> so: cat myfile.hs | grep -v -E '^[[:space:]]*($|--( |$)|//)' | wc -l
13:59:05 <d-snp> why don't you count comments to your loc? what do you use the loc for?
13:59:38 <burbul> d-snp: at the moment I'm just counting lines of code for fun, and I believe it's conventional not to include comments (often one counts them separately)
13:59:50 <timthelion> d-snp: it's a kind of, you know, "bigger dick contests" the irony, being that some devs thing bigger is better, and others think smaller is better.
14:00:00 <d-snp> :P
14:00:05 <strager> d-snp: I used it a few times to estimate how "well documented" my code is ;P  Haddock tells you the same thing though (but as % of functions documented)
14:00:40 <merijn> ski: You have a better soluton?
14:00:40 <d-snp> I have to go back to coding.. but haskell is annoying me so I feel like chatting :P
14:00:40 <burbul> timthelion: mainly I'm curious to see how large my Haskell programs are getting compared to those in languages I'm fluent in. In some sense that doesn't tell you anything very rigourous, but I'm still curious.
14:00:43 * timthelion started using literary haskell so he would be forced to comment.  It didn't help.
14:00:52 <strager> I also use it to compare the size of my test suite with the implementation.
14:01:21 <merijn> ski: I've been trying to figuring something out using fmap/whatever, but I can't construct anything sensible
14:01:28 <merijn> s/figuring/figure
14:01:54 <d-snp> ok, so here's a question about haskell, do you guys ever feel that haskell makes you think too much about implementation detail when you're setting up a project?
14:02:13 <burbul> I've never found that.
14:02:21 <hpc> d-snp: never
14:02:25 <burbul> But then I always plan things out in advance before coding.
14:02:26 <ski> @type let (.) = (Prelude..) in (uncurry (flip (fmap . flip (,))) .)  -- slighty better, i think
14:02:27 <lambdabot> forall a (f :: * -> *) b a1. (Functor f) => (a1 -> (f a, b)) -> a1 -> f (a, b)
14:02:29 <strager> merijn: I think you should make it clear =]  Unless you're code golfing
14:02:38 <timthelion> burbul: I just rewrite constantly :D
14:02:43 <merijn> ski: >.>
14:02:48 <d-snp> burbul: do you plan on a whiteboard?
14:03:02 <d-snp> or on paper?
14:03:05 <burbul> paper
14:03:07 <ski> merijn : you basically want `(strength .)', except with the other order around the pairs
14:03:08 <strager> d-snp: I think the opposite.  I think in terms of types, not values or implementation, and not often in terms of flow control.
14:03:26 <ski> @type let (.) = (Prelude..) in (fmap swap . strength . swap .)
14:03:27 <burbul> (Or in a Google document)
14:03:27 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (a1 -> (f b, a)) -> a1 -> f (b, a)
14:04:12 <strager> If I'm designing a new API, or have to figure out all the edge cases of a function, I usually write down patterns or type signatures on paper.
14:04:21 <strager> (Even when writing imperative code nowadays)
14:04:52 <strager> I hate 'planning' by typing.
14:05:02 <strager> Can't draw arbitrary arrows easily xD
14:05:15 * timthelion loves planning, gives him something to think about while mastrubating.
14:05:16 <burbul> I was about to ask what the difference between planning with type signatures and planning by typing was!
14:05:35 <strager> Oh, heh
14:05:37 <burbul> Then I realised you meant on a keyboard.
14:05:39 <strager> Overloaded term =]
14:05:41 <strager> yes
14:05:51 <d-snp> hmm
14:06:03 <strager> Oh, and pens, never pencils
14:07:17 <merijn> @pl \x -> (\y -> (y, snd x)) <$> fst x
14:07:17 <lambdabot> ap ((<$>) . flip (,) . snd) fst
14:07:29 <ski> "Making Java easier to type and easier to type" <http://homepages.inf.ed.ac.uk/wadler/gj/gj-back-full.jpg> (Wadler,Odersky,Bracha,Stoutamire)
14:07:49 <strager> hehe
14:08:02 <merijn> hmm, @pl is useful as always >.>
14:08:24 <hpc> @. djinn type \x -> (\y -> (y, snd x)) <$> fst x
14:08:25 <lambdabot> Cannot parse command
14:08:26 <strager> Love how it used (<$>) instead of fmap
14:08:26 <burbul> I can't tell if you're being sarcastic or not.
14:08:31 <hpc> @. @djinn @type \x -> (\y -> (y, snd x)) <$> fst x
14:08:31 <lambdabot> Plugin `compose' failed with: Unknown command: "@djinn"
14:08:43 <hpc> @type \x -> (\y -> (y, snd x)) <$> fst x
14:08:44 <lambdabot> forall a b (f :: * -> *). (Functor f) => (f a, b) -> f (a, b)
14:08:51 <burbul> [ I can't read that thing, but then I'm still at the monad stage rather than the functor/Applicative one]
14:08:54 <hpc> oh well
14:08:56 <merijn> @pl \x -> fmap (\y -> (y, snd x)) (fst x)
14:08:57 <lambdabot> ap (fmap . flip (,) . snd) fst
14:09:13 <merijn> burbul: That's because it's horribly unreadable :p
14:09:17 <burbul> :)
14:09:21 <burbul> What's <$>?
14:09:24 <merijn> The type should be plenty easy to understand, though
14:09:27 <zomg> I'm getting Loading package ghc-7.0.3 ... ghc: /usr/lib/ghc-7.0.3/ghc-7.0.3/libHSghc-7.0.3.a: no string tables, or too many
14:09:29 <hpc> @. djinn type \x -> (\y -> (y, snd x)) . fst x
14:09:30 <lambdabot> Cannot parse command
14:09:31 <merijn> :t \x -> fmap (\y -> (y, snd x)) (fst x)
14:09:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => (f a, b) -> f (a, b)
14:09:33 <strager> I think what you have is readable already.  Why do you need to make it point-free?
14:09:33 <zomg> When trying to use -package ghc with ghci
14:09:36 <zomg> Any ideas?
14:09:37 <hpc> @. djinn type \x -> (\y -> (y, snd x)) Prelude.. fst x
14:09:37 <strager> @src (<$>)
14:09:38 <lambdabot> f (a, b) c = (a c, b)
14:09:38 <lambdabot> f <$> a = fmap f a
14:09:41 <hpc> AHA!
14:09:49 <merijn> burbul: <$> is just infix fmap
14:09:50 <hpc> :t
14:09:50 <strager> @ burbul ^
14:09:52 <burbul> thanks (was trying to remember what @src was called)
14:10:03 <hpc> :t \p x -> first ($ x) p
14:10:04 <lambdabot> forall a b d. (a -> b, d) -> a -> (b, d)
14:10:27 <hpc> @pl \p x -> first ($ x) p
14:10:27 <strager> zomg: Wild guess: was it compiled with the same compiler?
14:10:28 <lambdabot> flip (first . flip id)
14:10:32 <hpc> try that
14:10:39 <merijn> strager: I don't want it pointfree, I think it's just unreadable
14:11:05 <burbul> @type \x -> (\y -> (y, snd x)) Prelude.. fst x
14:11:06 <lambdabot> forall b b1 a. (a -> b, b1) -> a -> (b, b1)
14:11:23 <zomg> strager: no idea, ubuntu package
14:11:31 <merijn> hpc: That type doesn't look right, it has (a -> b) as first element of the tuple
14:11:47 <zomg> strager: it seems there were some bugs regarding that error which were fixed for 7.0.4 but I can't find a package for ubuntu 10.4 with that version... bah
14:12:06 <strager> zomg: I think your only choice is to upgrade, like I did.
14:12:10 <burbul> @type \x -> (\y -> (y, snd x)) (Prelude.. fst x)
14:12:11 <lambdabot> forall b b1 c a. (a -> b1, b) -> ((b1 -> c) -> a -> c, b)
14:12:13 <strager> Latest two versions have 7.4.x.
14:12:31 <strager> Or set up an Arch VM or something.  =]
14:12:38 * adamt mumbles something about installing ghc and cabal manually
14:12:39 <zomg> hah :P
14:12:40 <burbul> What was the original...
14:12:48 <burbul> @type \x -> (\y -> (y, snd x)) <$> fst x
14:12:48 <zomg> Prob just gonna compile from source then
14:12:49 <lambdabot> forall a b (f :: * -> *). (Functor f) => (f a, b) -> f (a, b)
14:12:54 <hpc> merijn: the types are the same
14:13:34 <merijn> hpc: Mine was "Functor f => (f t, b) -> f (t, b)"
14:13:43 <merijn> So they are certainly not the same
14:13:46 <timthelion> zomg: it's easier to download the binary from haskell.org than to compile from source.
14:13:59 <burbul> Isn't it just specialising f to (a->) ?
14:14:03 <hpc> yeah
14:14:11 <burbul> not (a->), say (c->)
14:14:42 <burbul> It looks much easier to write in pointful notation to me
14:14:50 <zomg> timthelion: okay, will give that a shot then. thanks for the tip
14:15:15 <merijn> hpc: Well, it produces a type error in GHCi with "(Just 5, 'a')" as input
14:15:59 <burbul> Possibly because hpc used $,
14:16:02 <merijn> So there's something different
14:16:13 <burbul> Which forces you to use function application rather than a general functor?
14:16:16 <burbul> (That's a guess)
14:16:20 <hpc> yeah, i was using arrows and ($), which was wrong
14:16:51 <burbul> You actually want this for Maybe, or in general?
14:16:54 <hpc> in my defense, what you wanted looked a lot like flip
14:16:55 <hpc> :t flip
14:16:56 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
14:18:09 <ion> zomg: Install libgmp-dev libgmp3c2 or equivalent. ‘export PATH="$HOME/.ghc/bin:$HOME/.cabal/bin:$PATH"’. Get the binary tarball from http://www.haskell.org/ghc/download_ghc_7_4_1#x86linux and extract it. ‘./configure --prefix="$HOME/.ghc" && make install’. Download the source tarball from http://hackage.haskell.org/package/cabal-install and extract it. ‘EXTRA_CONFIGURE_OPTS=-p sh bootstrap.sh’.
14:18:11 <ion> ‘cabal update’. ‘vi ~/.cabal/config’. Add ‘library-profiling: True’, ‘documentation: True’. Add the export PATH… line to your .<shell>rc.
14:18:42 <burbul> Like I said, I don't know about factors, but it looks like it might be easier to write in Maybe then in general.
14:18:49 <otters> :t flip
14:18:50 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
14:18:53 <burbul> (At least to write readable)
14:18:55 <otters> pretty sure that's not actually the type of flip
14:18:57 <otters> @src flip
14:18:58 <lambdabot> flip f x y = f y x
14:19:28 <merijn> burbul: I want it for maybe, I have some code that's doing "map (first f)" and "f :: a -> Maybe b" so I end up with [(Maybe b, c)], and I only care about the tuples were b is valid
14:20:09 <merijn> There's catMaybes ([Maybe a] -> [a]), but that won't work if the maybe is inside the tuple
14:20:21 <hpc> merijn: (>>= guard (isJust . fst))
14:20:22 <burbul> You could take the maybe value and then make it wrapped round the whole tuple by using liftM
14:20:24 <burbul> I think
14:20:25 <hpc> :t guard
14:20:26 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
14:20:41 <hpc> yay list monad
14:20:57 <hpc> oh, er, pretend i used guard right
14:21:06 <burbul> If you liftM (,c) onto your Maybe b, I think you will get a Maybe (b,c)
14:21:11 <burbul> And then you can use catMaybes
14:21:25 <burbul> But hpcs solution is probably nicer -- I'm a newbie
14:22:09 <hpc> :t \xs -> do {x <- xs; guard (isJust . fst $ x); [x]}
14:22:09 <lambdabot> forall a b. [(Maybe a, b)] -> [(Maybe a, b)]
14:22:16 <hpc> er
14:22:40 <hpc> :t \xs -> do {p@(Just x, y) <- xs; ]p\}
14:22:41 <lambdabot> parse error on input `]'
14:22:48 <hpc> :t \xs -> do {p@(Just x, y) <- xs; [p]} -- i can type!
14:22:48 <lambdabot> forall t t1. [(Maybe t1, t)] -> [(Maybe t1, t)]
14:22:59 * hpc stops spamming
14:23:06 <d-snp> module imports can't form a cycle? :(
14:23:15 <burbul> merijn: where does c come from? Is it a function of a as well?
14:23:36 <timthelion> d-snp: yes, it's the worst part of haskell :D
14:23:41 <hpc> @ty \xs -> do {p@(Just x, y) <- xs; [(x,y)]} -- this has the type you want, i think
14:23:42 <lambdabot> forall t t1. [(Maybe t1, t)] -> [(t1, t)]
14:23:57 <hpc> timthelion: the best part!
14:24:10 <timthelion> d-snp: trust me, it's the biggest anoyance you'll ever face in haskell(except for hackage packages not installing)
14:24:11 <hpc> if you have five modules, and you can't compile a single one without all the others, it's not five modules
14:24:39 <hpc> circular imports make that not only possible, not only easy, but hard to avoid
14:24:46 <timthelion> hpc: but you still would like to put them in 5 files, because too long text files are difficult to navigate :D
14:24:54 <burbul> Oh, i see, you start with a [(a,c)] and you want to turn it into a [(Maybe b, c)] ?
14:24:59 <hpc> timthelion: i would factor it differently
14:25:26 <burbul> Why not convert f into something of type (a,c) -> (Maybe b,c) ?
14:25:30 <merijn> hpc: Hmm, that might work but still needs a fromJust then
14:25:36 <burbul> sorry,
14:25:51 <hpc> merijn: not the last one
14:25:56 <hpc> \xs -> do {p@(Just x, y) <- xs; [(x,y)]}
14:26:03 <burbul> (a,c) -> Maybe (b,c)
14:26:14 <hpc> :: [(Maybe t1, t)] -> [(t1, t)]
14:26:27 <ion> burbul: const Nothing?
14:26:36 <timthelion> hpc: there are times when you CANNOT :D  like in the case of data A = B | C ; data B = A | C ; data C = A | B
14:26:38 <hpc> technically it uses [] fail
14:26:40 <merijn> hpc: Isn't the p@ redundant there?
14:26:45 <hpc> oh, yeah
14:26:48 <hpc> forgot to take that off
14:26:50 <burbul> ion: Sorry, didn't follow that -- probably I'm confused.
14:27:24 <hpc> timthelion: and if the types are that inter-dependent, why would you want them separated?
14:27:25 <burbul> What's the thing that gives you a function of a given type? @djinn?
14:27:28 <ion> burbul: I probably missed something since i haven’t been paying attention to the question, but isn’t const Nothing the only valid implementation of (a,c) -> Maybe (b,c)?
14:27:28 <timthelion> ion: there's a const function in Haskell?  Isn't that kind of redundant?
14:27:32 <hpc> burbul: yes
14:27:35 <burbul> sorry
14:27:43 <timthelion> hpc: because they take up 500 lines each?
14:27:46 <burbul> (a->c) -> (a,c) -> Maybe (b,c)
14:27:59 <burbul> It should be some sort of lift
14:28:10 <burbul> @djinn (a->c) -> (a,c) -> Maybe (b,c)
14:28:10 <lambdabot> f _ _ = Nothing
14:28:24 <burbul> @djinn (a->b) -> (a,c) -> Maybe (b,c)
14:28:24 <lambdabot> f a (b, c) = Just (a b, c)
14:28:35 <burbul> @djinn (a->Maybe b) -> (a,c) -> Maybe (b,c)
14:28:36 <lambdabot> f a (b, c) =
14:28:36 <lambdabot>     case a b of
14:28:36 <lambdabot>     Nothing -> Nothing
14:28:36 <lambdabot>     Just d -> Just (d, c)
14:28:53 <burbul> ion: that last type signature is the right one
14:29:22 <strager> @src
14:29:22 <lambdabot> src <id>. Display the implementation of a standard function
14:29:25 <strager> @src const
14:29:25 <lambdabot> const x _ = x
14:29:26 <d-snp> timthelion: I do'nt think it is the biggest annoyance
14:29:35 <strager> timthelion: const is pretty useful in many cases
14:29:36 <burbul> @djinn (a->b) -> (a,c) -> (b,c)
14:29:36 <lambdabot> f a (b, c) = (a b, c)
14:29:38 <d-snp> no data polymorphism must be the biggest
14:29:44 <d-snp> (the lack of it)
14:29:45 <burbul> That function must have a name...
14:29:46 <hpc> d-snp: data polymorphism?
14:29:52 <timthelion> hpc: What if pattern needed to expand out another 50 lines here? https://github.com/timthelion/gridhaskell-haskarrow/blob/97644f0ecda55a5f9ff8514e10a6ffaed3624cb7/Cell.lhs
14:29:55 <ion> burbul: “first”
14:29:56 <d-snp> as in record types that inherit from eachother
14:30:03 <burbul> :t first
14:30:04 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
14:30:07 <burbul> [thanks!]
14:30:11 <hdev_> how do i link my project to a cabal library in path/git repository? only thing i see is version numbers
14:30:18 <timthelion> strager: what can const even mean in a non mutably typed purely funcitonal programming language?
14:30:42 <d-snp> oh, and record methods being global functions instead of methods is also pretty bad
14:30:50 <d-snp> in the annoyances department :D
14:30:53 <strager> timthelion: "ignore the second argument"; see its source
14:31:16 <hpc> timthelion: you can factor out Action
14:31:26 <hpc> nothing else in that file depends on it
14:31:37 <burbul> anyway, hpcs solution is more readable.
14:31:47 <timthelion> hpc: how does one factor out such a thing?
14:32:05 <burbul> @src const
14:32:05 <lambdabot> const x _ = x
14:32:05 <timthelion> hpc: and that would be far more unatural than putting pattern in it's own file
14:32:07 <merijn> hpc: Right, this seems to work like I want, yes :)
14:32:08 <strager> timthelion: Eventually I end up refactoring the code so 'const' isn't necessary, but it does come up on occasion.  Just like 'id'.
14:32:09 <burbul> it means that
14:32:42 <hpc> timthelion: new module, have it import Cell
14:32:53 <hpc> oh wait, nvm
14:32:56 <hpc> thought action was a type
14:32:59 <hpc> it's a constructor
14:33:11 <timthelion> yes, that is 100LOC of constructors :D
14:33:36 <hpc> in any event, the data dependencies go
14:33:55 <hpc> CellCommon -> Rectangle, String
14:34:14 <hpc> Cell -> CellCommon, kitchen sink, NOT Pattern
14:34:26 <hpc> Pattern -> Cell, Rectangle, String
14:34:40 <hpc> so that's Pattern -> Cell -> CellCommon
14:34:41 <timthelion> hpc: Cell depends on Pattern
14:34:57 <hpc> ah
14:35:24 <hpc> well, ick
14:35:39 <timthelion> hpc: this is the command set for a "programming language", and pattern belongs to the command Which.
14:36:01 <burbul> If they really have to be interdependent, you could put all the type declarations in one file and move absolutely everything else (including IO) into a separate file?
14:36:11 <hpc> if i had those data types, i would run away screaming ;)
14:36:18 <timthelion> programming language is in quotes since I'm just taking an editable visual graph and compiling it to haskell.
14:36:36 <timthelion> hpc: other than the large file size so far it works well.
14:36:52 <hpc> also what burbul said
14:36:59 * hpc has a few Foo.Types modules hanging around
14:37:22 <hpc> and not because of interdependencies either, just because it's a good place to put them
14:37:26 <timthelion> burbul: already did that, the ONLY thing in that file is the type declarations
14:37:50 <ski> (timthelion : no instance declarations or `deriving' clauses ?)
14:37:58 <burbul> Just looking at it -- looks like there's a lot of blank lines in there.
14:38:11 <burbul> Even in the middle of type declarations
14:38:18 <timthelion> burbul: you get that with literary haskell
14:38:41 <burbul> ah
14:39:12 <burbul> That sounds like a pain -- without the blank lines I don't think it would look too bad.
14:39:46 <otters> how do you find the index of a substring in a string?
14:40:31 <hpc> otters: rethink the underlying problem ;)
14:40:31 <fmap> > length . takeWhile not . map ("sub" `isPrefixOf`) $ tails "abcsubdef"
14:40:33 <lambdabot>   3
14:40:56 <otters> hpc: this really is the fastest way to do it
14:41:23 <burbul> What is the underlying problem ?
14:42:42 <otters> I just need to do some hacky extraction of a string from a page
14:43:08 <burbul> @src Data.List.findIndex
14:43:08 <lambdabot> Source not found. Do you think like you type?
14:43:14 <otters> of course, I'm a moron
14:43:18 <burbul> @src findIndex
14:43:18 <lambdabot> findIndex p     = listToMaybe . findIndices p
14:43:22 <otters> because Data.ByteString actually has a helper that will do it for me
14:43:27 <d-snp> wait.. data MyData = This { length :: Int } | That { length :: Int } actually works?
14:43:32 <d-snp> that's.. great..
14:43:51 <burbul> how come length doesn't become overloaded?
14:44:02 <d-snp> I don't know
14:44:09 <d-snp> but it throws no compile time error
14:44:14 <burbul> wow
14:44:30 <timthelion> burbul: It only works as long as length continues to be an Int. And yes length becomes overloaded :(
14:44:31 <burbul> Presumably if you change the second Int to a string it won't compile
14:44:31 <hpc> d-snp: length :: MyData -> Int
14:44:36 <burbul> snap
14:44:43 <hpc> length (This l) = l
14:44:47 <hpc> length (That l) = ;
14:44:49 <hpc> length (That l) = l
14:45:24 <d-snp> ;?
14:45:31 <hpc> that record stops making sense at exactly the same time the desugaring stops making sense :D
14:45:44 <hpc> (which is to say, "not yet, but you're close")
14:46:30 <hpaste> d-snp pasted “Is this going to work?” at http://hpaste.org/69076
14:46:53 <d-snp> that's the type that I compiled
14:47:03 <d-snp> but I'm nowhere near testing it, so I'm very curious :P
14:47:41 <d-snp> they both have a stack and an eventhandler
14:47:56 <timthelion> d-snp: no reason why not.
14:48:06 <d-snp> ok cool
14:48:43 <d-snp> I get it now too hpc thanks :D
14:50:03 <timthelion> d-snp: actually it's not cool. It's a rather buggy implementation.  Hopefully they will fix the more obvious bugs in the future, but the design is flawed :/
14:51:57 <timthelion> Most obvious bug is that THIS compiles without even giving you a warning: data MyData = A{a::X,b::X}|B{c::X};foo a@A{} = c a
14:52:38 <d-snp> ohh that's not so nice :D
14:53:15 <d-snp> that gives the same error as non-covering pattern matches right?
14:53:21 <timthelion> But it's a hard bug to fix due to the bad design.  We're using a pattern match there, when we should be somehow constraining the type of a.
14:53:32 <timthelion> d-snp: it gives an error on run time yes
14:53:59 <d-snp> I think the whole idea of pattern matching has a fundamental flaw there
14:54:12 <d-snp> the non-covering pattern match error is also awkward
14:54:27 <timthelion> d-snp: that can be prevented with -Wall
14:54:31 <timthelion> but this one cannot
14:55:26 <timthelion> The problem is that there's no way to constrain a type and say that foo only takes MyData's that are A's and not B's.
14:56:54 <d-snp> in your example did you mean foo a@MyData{} = c a?
14:57:21 <timthelion> d-snp: NO!
14:57:35 <ski> GADTy records types would be nice to have ..
14:57:38 <d-snp> awrgh
14:58:17 <timthelion> The probable solution is to prevent the messup by using different typing mechanisms.  For example, data MyData = A A' | B B' ; data A' = A'{a::X,b::X} ; data B' = B'{c::X} ; foo :: MyData ; foo A a = c a <- doesn't compile anymore.
14:58:18 <ski> d-snp : `MyData' is not a data constructor
14:58:27 <hpc> ski: records can combine with GADTs
14:58:36 <hpc> the syntax is odd though
14:58:43 <ski> hpc : i don't mean that
14:58:47 <ski> i mean something like
14:58:47 <timthelion> hey! that's how we should do it, we should make a nice sugar for what I just wrote there.
14:58:50 <timthelion> !!!
14:58:54 <d-snp> alright time for bed, good night guys!
14:59:00 <ski>   data Foo :: * -> *
14:59:02 <zzo38> (Codensity Endo) is a list monad, but what does (Codensity (\x -> (x -> x -> x))) mean?
14:59:02 <ski>     where
14:59:11 <ski>     commonField :: Foo a -> String
14:59:19 <ski>   aField :: Foo A -> Double
14:59:34 <ski>     bField :: Foo B -> Map Int Bool
14:59:45 <hpc> zzo38: you're mixing levels there
14:59:50 <hpc> i think
15:00:08 <hpc> (Codensity (\x -> (x -> x -> x))) is not valid haskell
15:00:12 <ski> d-snp : so that `commonField' exists in all `Foo a's, but `aField' only exists when `a' is `A', and `bField' only when `a' is `B'
15:00:17 <zzo38> Of course I do not mean you would actually write (\x -> (x -> x -> x)); I mean a newtype with that definition.
15:00:21 <d-snp> tomorrow I will figure out how to make timers
15:00:29 <hpc> zzo38: ah, that would be the same as Endo
15:00:29 <d-snp> so my protocol can time out and such things
15:00:35 <hpc> er wait
15:00:39 <hpc> zzo38: ignore that last
15:01:04 * hpc would guess that it looks something like a tree
15:01:25 <hpc> but i have only a superficial understanding of Codensity
15:01:41 <ski>   Codensity (\x -> (x -> x -> x)) a = forall b. (a -> b -> b -> b) -> b -> b -> b  -- hm
15:02:38 <ski> it seems like `data Tree a = T0 | T1 | T2 a (Tree a) (Tree a)', yes
15:03:41 <hpc> is there a good link to understanding Codensity?
15:04:06 <dino-> I'm using a library that is using bytestrings and is issuing fail in the Data.Binary.Get monad. This is killing my own software built on this. Is there a way I can catch this failure?
15:04:11 <zzo38> hpc: I don't know
15:04:15 <hpc> preferably one that doesn't compare it to smoked salmon, or call it a natural transformation from functors to bifunctors in a monoidal category
15:04:17 <ski> timthelion : i don't understand your example -- you have `foo :: MyData', but `foo A a = ...' suggests `foo' is a function
15:06:06 <ski> hpc : you know how writing `(foo ++ bar) ++ baz' is bad, yes ?
15:06:24 <hpc> ski: yeah
15:06:38 <ski> and similarly, defining `f x = f y ++ ...'
15:07:03 <hpc> indeed
15:07:10 <ski> well, `Codensity' is meant to avoid the similarly awkward `(foo >>= bar) >>= baz'
15:07:35 <ski> in some cases, having the pass through all these `(>>=)'s is wasteful, for no gain
15:07:39 <hpc> oh, COOL
15:07:55 <hpc> so like for Maybe
15:08:09 <ski> (consider e.g. the `Maybe' monad and the `Either e' monad -- when you throw an exception, you'd like to *not* stop and check whether it's an except at *every* pending `(>>=)' call)
15:08:11 <dino-> Oh, Control.Exception may help here. I do have somewhere in IO that surrounds this that I can try it.
15:08:15 <hpc> it would turn (Nothing >>= stuff) >>= nonterminating tower of stuff
15:08:22 <hpc> into Nothing >>= (tower)
15:08:29 <ski> more or less, yes
15:08:29 <hpc> and then it would terminate
15:08:34 <hpc> i love it
15:09:06 <ski> (though i'm not sure about the non-terminating stuff here -- iiuc all these `(>>=)' already need to be active, so there can't be an infinite amount of them)
15:09:29 <zzo38> (Codensity m) is a monad regardless of what m is
15:09:51 <ski> you know one cure for `(foo ++ bar) ++ baz' is to replace it with `((foo ++) . (bar ++)) . (baz ++)'
15:10:10 <hpc> yeah
15:10:17 <ski> `Codensity' basically does something similar, for the `(>>=)' of any monad
15:10:21 <zzo38> And (Codensity Endo) is a list in terms of its fold function
15:10:49 <ski>   instance Monad (Codensity f)  -- note that `Monad f' is *not* required here
15:11:13 <ski> you only need to know `Monad f' when you unwrap from `Codensity f a' to `f a'
15:11:22 <ski> e.g. when you insert your exception handlers
15:11:35 <hpc> ski: what's the relationship between Codensity and Cont?
15:11:46 <hpaste> timthelion pasted “Should I post this feature request to wiki or to haskell-cafe? I'm not a member of either...” at http://hpaste.org/69080
15:11:46 <hpc> they're identical modulo the position of "forall b"
15:11:57 <timthelion> ^^^^
15:13:23 <ski>   data Codensity f a = JorpDnib (forall b. (a -> f b) -> f b)
15:13:43 <ski> @unmtl ContT b f a
15:13:43 <lambdabot> (a -> f b) -> f b
15:13:53 <zzo38> Cont r = Codensity (Const r)
15:14:04 <ski> hpc : the `forall b.' guarantees there's no continuation effects
15:14:18 * monochrom would bring the Maybe sledgehammer to the record selector problem
15:14:49 <zzo38> hpc: The relation between Codensity and Cont would be    Cont r = Codensity (Const r)
15:15:28 <ski> zzo38 is of course right :)
15:15:41 <timthelion> monochrom: what is that?
15:15:42 <hpc> @unmtl Cont r a
15:15:42 <lambdabot> (a -> r) -> r
15:15:57 <hpc> ski: so it keeps the 'r' polymorphic, groovy
15:16:08 <ski> yes
15:16:09 <monochrom> it means c :: MyData -> Maybe Int
15:16:14 <ski> @let forAll :: [a] -> Cont Bool a; forAll = cont . flip all
15:16:15 <lambdabot>  Defined.
15:16:21 <ski> @let forAny :: [a] -> Cont Bool a; forAny = cont . flip any
15:16:22 <lambdabot>  Defined.
15:16:31 * hpc probably should have been able to figure that out; he just read through higher-ranked types in the ghc docs...
15:16:40 <timthelion> monochrom: That would also work. but my system would be cleaner if we had a good sugar.
15:17:07 <hpc> ski: is there a CodensityT?
15:17:23 <zzo38> hpc: Codensity is already a monad transformer (both forward and backward)
15:17:30 <timthelion> monochrom: wait, are you serious?
15:17:39 <hpc> oh
15:17:44 <hpc> oh i see
15:17:45 <ski> > evalCont $ do x <- forAll [0,1,2,3]; y <- forSome [2,4,6]; return (y > x)
15:17:47 <lambdabot>   Not in scope: `forSome'
15:17:51 <ski> > evalCont $ do x <- forAll [0,1,2,3]; y <- forAny [2,4,6]; return (y > x)
15:17:53 <lambdabot>   True
15:18:02 <hpc> Codensity IO ~~ ContT () IO -- ?
15:18:10 <ski> > evalCont $ do y <- forAny [2,4,6]; x <- forAll [0,1,2,3]; return (y > x)
15:18:12 <lambdabot>   True
15:18:39 <hpc> ski: ooh
15:18:55 <ski> hpc : note that `Cont Bool a' is *not* isomorphic to `a'
15:19:13 <ski> however, `forall b. Cont b a' *is* isomorphic to `a'
15:19:14 <hpc> ski: yeah, but forall r. Cont r a is
15:19:21 <hpc> yaaaaay!
15:19:41 <ski> since we know the "answer type" `Bool' above (it's not abstract), we can do "funny things" with it (i.e. control effects)
15:19:56 <zzo38> There is also Density, which always makes a comonad. (In addition, (Density f) is applicative if f is applicative)
15:20:26 <hpc> one thing at a time :P
15:20:36 <hpc> my brain has room for only so much useless abstraction ;)
15:20:48 <ski> maybe some CPS would be in order ?
15:21:19 <hpc> nah
15:21:19 <zzo38> My variant of Plus which is like Alternative and MonadPlus but with no superclasses, makes Endo an instance of Plus and therefore (Codensity Endo) also an instance of MonadPlus and Alternative, giving list concatenation for free.
15:21:34 <hpc> i need to keep my head in (ContT () IO) mode for this project i want to finish over the summer
15:21:46 <ski> zzo38 : where do you keep the interaction laws ?
15:22:02 <zzo38> ski: I do not understand you.
15:22:26 <zzo38> Notice also that Plus and Comonad are mutually exclusive (nothing can ever follow the laws of both).
15:22:58 <ski> zzo38 : laws like `empty <*> _ = empty' and `mzero >>= _ = mzero'
15:23:25 <ski> currently, the former resides in the `Alternative' class, and the latter in the `MonadPlus' class
15:23:32 <zzo38> ski: The law `mzero >>= _ = mzero' is implied by the monad laws. It is not always the case for applicatives which are not monads.
15:23:49 <zzo38> I have seen no such law `empty <*> _ = empty'
15:24:03 <ski> maybe you have a class which has both `Plus' and `Alternative' as superclasses, containing the first one, and one subclassing `Plus' and `Monad' containing the latter
15:24:30 <ski> zzo38 : hm, are you sure it's implies ?
15:24:37 <zzo38> ski: Yes, you could have classes like that containing only superclasses and methods, but no laws.
15:24:41 <zzo38> ski: Yes.
15:24:48 <zzo38> ski: Yes, you could have classes like that containing only superclasses and laws, but no methods.
15:24:56 <ski> (well, i meant .. yes, that :)
15:25:17 <ski> could you explain how it's implied ?
15:26:33 <ski> (i'm not sure i've seen `empty <*> _ = empty' explicitly mentioned somewhere -- but it seems pretty reasonable, no ?)
15:26:47 <zzo38> ski: mzero >>= x = join (x <$> mzero) = join (id <$> mzero) = join mzero  and  (>>= return) = join . fmap return = id  and parametricity
15:27:45 <ski> is the step from `x <$> mzero' to `id <$> mzero' using a free theorem ?
15:27:55 <zzo38> ski: Yes, it is using parametricity.
15:28:59 <ski> oh, right, it's a different instance of `mzero
15:29:00 <ski> '
15:29:31 <ski> @free foo :: F a
15:29:31 <lambdabot> $map_F f foo = foo
15:29:35 <ski> basically
15:29:48 <zzo38> ski: Yes, it is that.
15:29:54 <ski> (so, i'd omit the `id <$>' part completely)
15:30:25 <zzo38> Well, I was using   fmap id = id   but I suppose you could do it your way too
15:30:33 <ski> (at first it looked like you replaced `x' with `id', but they didn't have the same type -- then i realized `mzero' was also replaced)
15:30:52 <ski> (:
15:31:45 <ski> (i'm not sure why you also gave a proof of one of the identity laws for `Monad', though)
15:32:25 <zzo38> ski: So that you can prove   join mzero = mzero
15:33:47 <ski> i don't follow
15:34:17 <zzo38> Maybe my proof is not sufficiently formal
15:34:24 <ski> (`join' is not `(>>= return)')
15:34:31 <JoeyA> http://elm-lang.org/ currently has the best error message I've ever seen.
15:34:32 <zzo38> ski: I know.
15:34:35 <JoeyA> "An Error Occured: Better Messages to come."
15:34:46 <zzo38> And it isn't what I meant.
15:34:58 <ski> zzo38 : ok, then i don't know what you mean
15:34:59 <ski> t
15:35:14 <ski> how did you mean to go from `join mzero' to `mzero' ?
15:35:37 <zzo38> Well, some other people have said that although my proof is a bit faulty, they have agreed that due to parametricity, my conclusion is correct.
15:36:00 <zzo38> ski: I am probably just not being clear and formal and that
15:36:12 <ski> zzo38 : it's possible :)  i'm just trying to understand what your idea was here
15:36:52 <zzo38> Well, I am not very good at writing it very clearly.
15:37:10 <ski> i suspect that you actually need `join mzero = mzero' as a law as well -- but i'm not sure
15:38:15 <zzo38> I will try again:   join (x <$> mzero) = join (anything <$> mzero) = join (return <$> mzero) = (join . fmap return) mzero = mzero
15:38:19 <zzo38> Is that better?
15:38:24 <zzo38> I think now it is better
15:38:31 <hpaste> beefcube pasted “heaps1” at http://hpaste.org/69081
15:39:10 <beefcube> more newbie problems, why is that producing a compiler error (which doesn't make sense to me)
15:39:33 <zzo38> ski: Now I did it better, isn't it?
15:39:44 <otters> I don't see why that would be an error
15:39:45 <JoeyA> beefcube: Are you talking about "5:1: Error: Eta reduce" ?
15:39:57 <monochrom> "head"?
15:40:06 <otters> beefcube: change it to "takeHighest = head"
15:40:26 <JoeyA> That's not really an error, that's a message from hlint.  "Error" is rather misleading.
15:40:32 <zzo38> "5:1: Error: Eta reduce" is not really an error, it should say warning
15:40:45 <monochrom> "head" is for lists, not heaps.
15:41:13 <monochrom> did you, like, actually read http://hackage.haskell.org/packages/archive/heap/1.0.0/doc/html/Data-Heap.html ?
15:41:55 <rhapsodh1> i thinks i'm a little lost about monads
15:42:07 <beefcube> i'm trying to use Data.Heap.head
15:42:25 <zzo38> rhapsodhi: What part did you fail at?
15:42:27 <monochrom> there is no Data.Heap.head
15:42:48 <rhapsodh1> zzo38: i've got getPOSIXTime returning IO POSIXTime
15:42:58 <beefcube> head :: (HeapPolicy p a) => Heap p a -> a
15:42:59 <beefcube> head = fst . extractHead
15:43:00 <beefcube> ?
15:43:05 <rhapsodh1> how do i transform it into just POSIXTime?
15:43:13 <zzo38> rhapsodhi: You don't.
15:44:02 <monochrom> you just wrote that yourself? well why was it not in the paste? and also, if you want to do that, you need "import Prelude hiding (takeWhile, head)"
15:44:05 <rhapsodh1> zzo38: so how can i 'show' it somehow?
15:44:12 <beefcube> monochrom, that was pasted from the file you cited
15:44:18 <zzo38> rhapsodh1: What you do is, something like   (f <$> getPOSIXTime) makes a function   (f :: POSIXTime -> x) to make a (IO x) from it, and if you want to show it:  getPOSIXTime >>= print
15:44:45 <ski> zzo38 : ah, ty -- that's fine, yes :)
15:45:02 <zzo38> ((getPOSIXTime >>= print) is equivalent to (join (print <$> getPOSIXTime)), although you need not use join)
15:45:21 <zzo38> rhapsodh1: Am I understandable now? This question a lot of people ask
15:45:34 <monochrom> no, web browser string search does not find "head =" in http://hackage.haskell.org/packages/archive/heap/1.0.0/doc/html/Data-Heap.html
15:45:39 <ski> @wiki MonadPlus reform proposal
15:45:39 <lambdabot> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
15:45:49 <rhapsodh1> zzo38: i don't want to print it onto the screen
15:45:49 <ski> zzo38 : did you see that ^ one yet ?
15:45:56 <rhapsodh1> i want a string representation
15:46:00 <zzo38> ski: Yes I have seen
15:46:18 <ski> zzo38 : it could be interesting to consider what would be appropriate laws for `Alternative', apart from the monoid laws
15:46:24 <monochrom> I think I should just walk away from this. this is delusional.
15:47:04 <zzo38> rhapsodh1: (show <$> getPOSIXTime) makes it into (IO String) which can then be used with other (String -> x) functions by (fmap f) if f is of type (String -> x) to make (IO x) and so on
15:48:04 <beefcube> monochrom: i've been looking at 0.5.0, my apologies
15:48:35 <zzo38> rhapsodh1: And then if f is also something resulting in some (IO x) stuff meaning some I/O action, join makes (IO (IO x)) into (IO x) which means the resulting action is performed after the action resulting in it to result in that action's result, but you use >>= as a convenient shortcut, so (getPOSIXTime >>= print) instead of (join (print <$> getPOSIXTime)) and so on.
15:48:53 <zzo38> ski: I think there is none.
15:49:27 <ski> why not ?
15:49:36 <rhapsodh1> zzo38: thanks, i guess i'll be able to do it :)
15:49:43 <rhapsodh1> from now on
15:49:48 <mietek> Anyone following the latest installment of the iteratees saga, pipes-2.0.0?
15:49:49 <monochrom> then you still need "import Prelude hiding (takeWhile, head)"
15:50:02 <zzo38> ski: Just because there isn't any, as far as I know.
15:50:13 <ski> to me, `empty <*> _ = empty' sounds reasonable
15:50:25 <ski> i'm not sure about `_ <*> empty = empty'
15:50:42 <zzo38> Same with MonadPlus, there needs no additional laws (they should be separate classes for the additional laws such as right zero law and so on)
15:51:39 <zzo38> ski: Actually those two laws you give could be specified as additional classes having Applicative and Plus as superclasses, and then the first one is automatically applied when it is also Monad
15:51:57 <ski> hm .. i wonder when you'd want to add such laws-only classes into constraints
15:52:21 <zzo38> ski: Such as when making an instance of a new class, is one thing
15:52:40 <ski> <ski> maybe you have a class which has both `Plus' and `Alternative' as superclasses, containing the first one, and one subclassing `Plus' and `Monad' containing the latter
15:53:26 <ski> zzo38 : do you have any (perhaps trivial) example in mind ?
15:54:13 <zzo38> ski:  instance Idempotent x => IdempotentA ((,) x);   This example is just for laws-only class and is not for the specific classes you were discussing, though.
15:54:54 <ski> hm, yea
15:55:44 <ski> i suppose some algorithms could want to rely on laws on the types, to reformulate the obvious solution into a non-obvious but more efficient one
15:56:07 <ski> (and then the algorithm only gives correct results if you don't lie about the laws)
15:56:56 <zzo38> Is (\x y -> (f x -> f y)) a Arrow if and only if f is an idempotent applicative? I am unsure but I guessed
15:58:29 <ski>   join (liftA2 (,)) = liftA (join (,))  -- being this law ?
15:59:05 <ski> (the "only if" would probably be hard to show, if correct)
15:59:13 <zzo38> ski: By idempotent applicative I mean   x *> x = x   and I think what you say is the same
16:00:28 <tgeeky> @type join (liftA2 (,))
16:00:29 <lambdabot> forall b (f :: * -> *). (Applicative f) => f b -> f (b, b)
16:00:31 <tgeeky> @type (liftA (,))
16:00:31 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f (b -> (a, b))
16:00:54 <ski> @type liftA (join (,))
16:00:55 <lambdabot> forall a (f :: * -> *). (Applicative f) => f a -> f (a, a)
16:01:06 <tgeeky> oh, I forgot the join
16:01:23 <ski> (one runs the action twice, pairs the results; the other runs it once, copies the result)
16:03:44 <ski> `ado a0 <- ia; a1 <- ia; (a0,a1)' vs. `ado a <- ia; (a,a)' in Philippa's notation
16:04:13 <zzo38> ski: In terms of actions, yes I guess that would be it but they are not necessarily going to be actions
16:05:02 <monochrom> "without further ado" :)
16:17:05 <applicative> mietek, trying to follow this saga, just now
16:18:34 <mietek> applicative: ack
16:18:48 <applicative> indeed.
16:18:55 <mietek> applicative: I hoped pipes would be understandable. I think with the latest release, they have ceased to be.
16:19:21 <mietek> Perhaps I need a PhD
16:19:44 <applicative> well that's the state i'm in.  though I have to say the first pipes library cast such a flood of light, I'm still grateful....
16:20:01 <ski> @hackage pipes
16:20:02 <lambdabot> http://hackage.haskell.org/package/pipes
16:20:31 <mietek> http://hackage.haskell.org/packages/archive/pipes/2.0.0/doc/html/Control-Pipe.html
16:20:40 <mietek> This is the new "tutorial"
16:21:20 <mietek> The author stresses how pipes satisfy category laws, but I don't really see the benefit
16:21:28 <JEntrep> Does anyone here know any good resources for directed graph theory?
16:21:47 <ski> hm, this reminds me of fudgets
16:21:51 <applicative> i was trying to see if i could write something isomorphic to his 'frames' that was more naive and direct
16:22:11 <applicative> fudgets?
16:22:26 <ski> @where Fudgets
16:22:26 <lambdabot> GUI using X, by Thomas Hallgren and Magnus Carlsson, at <http://www.altocumulus.org/Fudgets/>,<http://www.carlssonia.org/ogi/ProdArrows/>. Also see `Alfa'
16:24:24 <ski> hm, i wonder whether `Pipe' yield an indexed monad
16:25:04 <mietek> ski: the author mentions that in http://www.haskellforall.com/2012/05/pipes-20-pipe-finalization.html
16:25:56 <mietek> I wish there was an example of, say, a TCP server built on pipes
16:26:21 <mietek> Maybe a comparison of the different ways of building TCP servers in Haskell
16:28:14 <Peaker> at the API level conduits and pipes seem similar
16:28:31 <Peaker> (await/yield monad horizontally composable)
16:33:00 * hackagebot graphics-drawingcombinators 1.4.2 - A functional interface to 2D drawing in OpenGL  http://hackage.haskell.org/package/graphics-drawingcombinators-1.4.2 (EyalLotem)
16:38:48 <ski> hm, why not `type Producer b m r = Pipe Void b m r' instead ? :/
16:40:56 <mauke> what would the advantages be?
16:41:44 <aristid> ski: didn't pipes _use_ to do that?
16:44:46 <applicative> ski what is it now?
16:45:39 <applicative> ah Produce b is Pipe () b
16:47:43 <applicative> the urpipes had a unit type Zero at both ends.
16:48:30 <ski> conceptually `Void' seems more right, if you don't want to go the polymorphic route
16:49:37 <ski> (since a pipe that awaits `()'-values could be separately useful, i imagine)
16:49:44 <ghorn> i'd appreciate help concisely writing type signatures for heterogenous lists http://stackoverflow.com/questions/10770618/concise-notation-for-heterogenous-lists-using-type-operators
16:50:16 <applicative> ghorn, what makes a man want heterogeneous lists?
16:51:02 * applicative thinks, well repa uses them
16:51:19 <ghorn> i'm doing [Tensor] -> [Tensor] functions, but I want Vector and Matrix to have different types for safety
16:53:47 * ski . o O ( `data RelList r :: * -> * -> * where Nil :: r i i; Cons :: r i j -> RelList r j k -> RelList r i k' )
16:53:59 <ghorn> i got most of the way there doing what repa did but I'm trying to simplify the signatures
16:56:27 <BMeph> ghorn: And using type classes instead won't help, because...? :)
16:56:55 <ski> i'm not sure what kind of elements you'd like to have in your lists
16:57:04 <ski> how is `Tensor' defined ?
16:57:32 <ghorn> data Expr sh a where . . . .
16:57:42 <ski> (maybe you need something not as general as "heterogenous lists")
16:58:10 <ski> is `twoExprs :: ExprT (D0 :* D1) Double' supposed to be a two-dimensional vector ?
16:58:56 <ghorn> it's supposed to be a (Scalar, Vector)
16:59:28 <ski> i don't follow
16:59:44 <ski> which part of `twoExprs = Expr D0 7 :* Expr D1 8' is the scalar, and which is the vector ?
17:00:08 <ghorn> right now I have to write types as (Expr D0 Double :* Expr D1 Double) and i'm trying to write it as ExprT (D0 :* D1) Double instead
17:00:22 <ghorn> Expr D0 7 is the scalar, Expr D1 7 is the vector
17:00:29 <ski> hm .. strange
17:00:33 <ghorn> sorry Expr D1 8 is the vector
17:00:42 <ski> how is the latter a vector ?
17:00:52 <ski> a vector in which vector space (which dimension) ?
17:00:54 <ghorn> oh sorry, i used 8 instead of [8,9, . . .] like an idiot
17:01:05 <ghorn> it's just for the stack overflow post
17:01:12 <ghorn> https://github.com/ghorn/dvda/blob/master/Dvda/Expr.hs
17:01:38 <ghorn> it would use different constructors for real vectors
17:02:14 <ski> oh, so `D0',`D1',`D2' was meant to denote different vector spaces (or dimensions thereof)
17:02:25 <mietek> ski: that Void/() question is one I have as well.
17:02:34 <ghorn> yes
17:02:47 <ghorn> i'm using repp's DIM0 DIM1 DIM2 etc
17:02:48 <gbacon> when I try to cabal install xmonad xmonad-contrib, cabal complains about much dependency-bumbuzzlery
17:02:54 <gbacon> how can I unwedge it?
17:02:55 <ghorn> repa's*
17:03:11 <gbacon> bumfuzzlery, that is
17:03:28 * ski has no idea about `repp'
17:03:46 <gbacon> I'm using xmonad now, but somewhere along the way, some libraries must have gotten hosed
17:03:51 <gbacon> dratted mutable state
17:03:52 <ski> hm, should `EDimensionless :: a -> Expr sh a' be `EDimensionless :: a -> Expr DIM0 a' ?
17:04:27 <ghorn> no, I only use EDimensionless in fromIntegral to help with numeric literals
17:04:55 <ghorn> i figure out the type later and convert to ESingleton
17:05:42 <ski> i think `EDeriv :: sh ~ DIM0 => Expr DIM0 a -> Expr DIM0 a -> Expr sh a' can probably be simplified to `EDeriv :: Expr DIM0 a -> Expr DIM0 a -> Expr DIM0 a'
17:06:02 <BMeph> ghorn: From your instance example, it looks as if you're trying to claim (a :* a) ~ a, although it may just be that I know too little about type families to understand what it really says. :)
17:06:38 <ghorn> ski: i think you're right, i've just been learning about GADTs
17:07:28 <ghorn> ski: yes that doesn't cause any problems
17:09:39 <applicative> gbacon did you have xmonad installed from your distribution before?
17:09:45 <ski> i'm still wondering what kind of mixed lists you want to be able to write
17:09:58 <ghorn> ski: the reason for EDimensionless is so I can write things like  "4*x" where x is a matrix
17:10:30 * ski would not use `(*)' for scaling
17:10:50 <adu> perhaps .*.
17:11:00 <adu> or .* or *.
17:11:14 <ski> (:
17:11:39 <ghorn> yeah . . . it causes problems
17:11:45 <applicative> gbacon, do you know the usual measures to check for broken packages and so on?
17:12:00 <ghorn> in this: https://github.com/ghorn/dvda/blob/master/CompileTest.hs
17:12:19 <ghorn> I want to write the type of function fun' more concicely
17:15:36 <ski> hm, i suspect you could make a type family with `type instance E (sh0 :* sh1) a = E sh0 a :* E sh1 a' and `type instance E DIM0 a = Expr DIM0 a', &c.
17:16:38 <ski> oh, i suppose that's what your `ExprT' is, apart from not writing the `DIM0',&c cases manually
17:17:20 <ski> the problem in the instance resolution there is that it doesn't take the context into account, when deciding which instance is appropriate, only the instance head
17:17:48 <ski> (istr rumors that this maybe could be lifted ..)
17:17:57 <ghorn> on yeah that works, i can just write instances for E DIM0 a, E DIM1 a, E DIM2 a, etc
17:18:36 <ski> is `DIM0',`DIM1',&c. type synonyms (or type families) ?
17:18:56 <ghorn> the problem is that someone could instance Shape (sh0 :* sh1)
17:19:05 <ghorn> synonyms
17:19:14 <ski> synonyms for what ?
17:19:50 <ghorn> from repp's shape library (Z :: DIM0), ((Z :. 5) :: DIM1) ((Z :. 5 :. 3) :: DIM2) etc
17:19:52 <ski> `Z',`S :. Z',`S :. S :. Z', &c. ?
17:20:08 <ski> hm
17:20:11 <ghorn> spell check is s/repa/reps/
17:20:17 <ghorn> or repp
17:20:41 <ski> well, what's the type of the data constructor `(:.)' ?
17:21:26 <ghorn> http://hackage.haskell.org/packages/archive/repa/3.1.4.2/doc/html/Data-Array-Repa-Index.html#t::.
17:22:14 <ski> ok, i see
17:23:39 <ghorn> well you have given me a solution in making separate instances for DIM0, DIM1, etc, just too bad i can't write one for Shape sh =>
17:24:01 <ghorn> i'm only really gonna ever up to DIM2, maaaaaybe DIM3
17:24:18 <ghorn> *use up to DIM2
17:24:51 <ski> i think one should be able to manually match on `Z' and `(:.)'
17:25:28 <ski> hm .. well, actually no recursion should be needed either, i think
17:25:45 <ski>   instance ExprList Z a
17:25:47 <ski>     where
17:25:56 <ski>     type ExprT Z a = Expr Z a
17:26:09 <ski>   instance ExprList (sh :. Int) a
17:26:11 <ski>     where
17:26:26 <ski>     type ExprT (sh :. Int) a = Expr (sh :. Int) a
17:26:37 <ghorn> i see
17:26:39 <ghorn> let me try that
17:26:40 <ski> i suppose you can probably generalize `Int' to `head' here
17:26:58 <ski> also .. i'm not sure why you have `a' as a parameter to the type class
17:27:04 <ski> can't you say
17:27:11 <ski>   class ExprList sh
17:27:12 <ski>     where
17:27:20 <ski>     type ExprT sh :: * -> *
17:27:22 <ski> instead ?
17:29:28 <ghorn> your solution matching on (sh :. Int) works
17:30:08 <ghorn> i'm not sure how type ExprT sh :: * -> * works
17:33:00 <ski> see <http://www.haskell.org/ghc/docs/latest/html/users_guide/type-families.html#type-family-declarations>
17:34:27 <ghorn> i see
17:34:57 <ghorn> i think
17:35:28 <ghorn> is this sort of like writing (f = g) instead of (f x = g x)
17:35:29 <ghorn> ?
17:35:41 <ski> yeah
17:36:10 <ski> except that with what you had, you were allowed to pattnern-match on the `a' argument (but didn't in the given instances)
17:36:46 <ski> but with `type ExprT sh :: * -> *' only the first argument of `ExprT' may be a non-variable in instances
17:37:24 <ghorn> i see
17:38:37 <ghorn> thanks very much
17:38:37 * peropaal ..
18:09:09 <zezikaro> Hi, does anyone know a good haskell compiler
18:09:19 <zezikaro> or easy way to edit + run haskell code
18:09:47 <zezikaro> i was suggested to use 2 separate terminals earlier, but I'd like syntax highlighting/speed
18:10:03 <zachk> ghc is nice, ghci is a nice interpreter, hugs used to be recommended for beginners
18:10:10 <zachk> use vim or emacs
18:10:15 <zachk> and install the haskell platform
18:10:17 <ski> haskell-mode in emacs has highlighting
18:10:21 <shachaf> If you don't already use vim or emacs, don't start using it for this.
18:10:28 <zachk> ?google haskell platform
18:10:30 <lambdabot> http://hackage.haskell.org/platform/
18:10:30 <lambdabot> Title: Download Haskell
18:10:31 <shachaf> Learning Haskell is enough of a hassle.
18:10:48 * zachk agrees 100% with shachaf 
18:10:49 <strager> leksah is a popular IDE
18:10:59 <strager> I've heard Eclipse FP is good too
18:11:04 <strager> I have no experience with either.
18:11:15 <strager> I use Vim with no extra plugins for Haskell.
18:11:30 <strager> Hoogle, GHCi, and GNU make are in my toolbelt.
18:11:31 <shachaf> I also use vim. But you should use whichever text editor you're already familiar with.
18:11:40 <zezikaro> Couldn't get eclipse fp to work
18:11:44 <zezikaro> downloading leksah now thnaks
18:11:58 <zachk> hoogle integration into ghci using the .ghci in your home folder is quite nice
18:12:08 <zezikaro> It took me hours to work out how to quit vim...
18:12:14 <strager> GoogleIt
18:12:19 <zachk> zz or ZZ for starters
18:12:25 <strager> zz is for noobs
18:12:30 <ion> @google how to quit vim
18:12:32 <strager> Oh, wait...
18:12:32 <lambdabot> http://www.tuxfiles.org/linuxhelp/vimcheat.html
18:12:33 <lambdabot> Title: The Vim commands cheat sheet
18:12:33 <zezikaro> :q
18:12:37 <zachk> well it took him hours to quit vim, so zz would work good
18:12:54 <zezikaro> oh woah
18:12:56 <zachk> for vim: Esc :wq! works nicely for starters for getting out with a save first
18:12:58 <ion> Imagining that i didn’t know it already, it just took me about five seconds.
18:13:01 <zezikaro> leksah has a crazy skin
18:13:23 <strager> Just hit ^C and it tells you ;P
18:14:46 <zezikaro> "Leksah is the Haskell IDE of choice. It is written in Haskell"
18:14:47 <zezikaro> oh woah
18:16:18 <rwbarton> I would guess it is used by a quite small minority of Haskell users though
18:16:44 <rwbarton> I think maybe s/ of choice// :P
18:17:13 <rwbarton> as in, it is the only one, but many (most?) people just use a regular editor + ghci
18:18:13 <zezikaro> it's cool from what I can see
18:18:17 <zezikaro> but i can't get it to work
18:18:18 <zezikaro> :D
18:18:42 <strager> Don't worry; you can make production software with just a REPL.
18:18:48 <strager> ed style.
18:19:11 <zezikaro> ed?
18:19:17 <strager> @man ed
18:19:18 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
18:19:22 <strager> guh.
18:19:24 <strager> @google man ed
18:19:27 <lambdabot> http://www.gnu.org/fun/jokes/ed.msg.html
18:22:25 <zezikaro> I can't actually get it to run
18:22:33 <zezikaro> [1 of 1] Compiling Main             ( src\Main.hs, interpreted )
18:22:33 <zezikaro> Ok, modules loaded: Main.
18:22:38 <zezikaro> but it doens't do anything..
18:27:43 <geekosaur> zezikaro, use :main to run it; the point of ghci is to let you load a set of definitions and then exercise individual functions
18:27:56 <geekosaur> or use runghc to just load up and run something
18:28:33 <zezikaro> Where do I type :main
18:28:34 <zezikaro> ?
18:29:11 <geekosaur> at the ghci prompt (should be "Main>" or similar)
18:29:57 <zezikaro> ugh found it on leksah
18:29:59 <zezikaro> was an odd icon
18:30:04 <zezikaro> i would've expected a ... play button
18:30:17 <zezikaro> instead it's a picture of 3 odd cogs
18:30:18 <zezikaro> thanks
18:30:37 <geekosaur> oh, leksah.  have not played much with that
18:39:19 <hpaste> dmwit pasted “python transliteration” at http://hpaste.org/69084
18:41:00 <dmwit> sorry
18:43:05 <Nimatek> One thing I can't get used to with Haskell is that the libraries come with many small useful functions, and because I'm too lazy to read I keep reimplementing them, oblivious of their existence.
18:45:53 <dmwit> What, no genericFindIndices?
18:46:15 <dmwit> ?hoogle Integral b => (a -> Bool) -> [a] -> [b]
18:46:16 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
18:46:16 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
18:46:16 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
18:48:36 <strager> Nimatek: Typically I look at things which look reusable I've written, and I Hoogle their type signatures.
18:48:41 <strager> Usually something comes up.
18:49:18 <Nimatek> strager: Yes, but by that point you've already written them!
18:49:38 <strager> But now you'll have a better name and less code in your codebase!
18:49:39 <strager> =]
18:51:23 <Nimatek> True, but ideally I'd want to recognize it before I spend the time on them.
18:54:19 <mparodi> Hello guys
18:54:43 <mparodi> how do you explain the type of "curry id" and "uncurry id"?
18:55:03 <ski> long or short explanation ?
18:55:22 <mparodi> the one that I will understand the most
18:55:23 <mparodi> :P
18:55:59 <ski> heh, and which one is that (surely you can't expect *us* to know !) ?
18:56:02 <ski> ;)
18:56:12 <ski> we have
18:56:17 <mparodi> I bet it's the short one
18:56:19 <dmwit> :t curry
18:56:20 <dmwit> :t id
18:56:20 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
18:56:21 <lambdabot> forall a. a -> a
18:56:23 <ski>   curry :: ((a,b) -> c) -> (a -> b -> c)
18:56:34 <dmwit> ((a,b) -> c) = (d -> d)
18:56:43 <dmwit> therefore (a,b) = d and c = d
18:56:59 * ski . o O ( "but where did `d' come from ?" )
18:57:08 <haskell_chap> hello all
18:57:13 <dmwit> Yes, that needs to be explained.
18:57:26 <dmwit> I picked "id :: d -> d" to avoid confusion from having different "a"s in each type.
18:57:27 <haskell_chap> no luck with the package after installing Xcode
18:57:45 <dmwit> Rewriting c out of the type of curry using c = (a,b), we get
18:57:58 <dmwit> curry :: ((a,b) -> (a,b)) -> (a -> b -> (a,b))
18:58:08 <dmwit> and hence curry id :: a -> b -> (a,b)
18:58:12 <ski> re shawng
18:58:34 <dmwit> Exercise: do the same trick for uncurry id.
18:58:54 <dmwit> (Write down the equations between type variables that you get, and then rewrite the types to eliminate as many variables as possible.)
18:59:03 <ski> mparodi : to type `curry id', we start by the signatures for the variables in here
18:59:05 <haskell_chap> Xcode version is 4.3.2
18:59:10 <ski>   curry :: ((a,b) -> c) -> (a -> b -> c)
18:59:13 <ski>   id :: a -> a
18:59:18 <ski> and those *really* mean
18:59:25 <ski>   curry :: forall a b c. ((a,b) -> c) -> (a -> b -> c)
18:59:29 <ski>   id :: forall a. a -> a
18:59:38 <haskell_chap> ski: what are you talking about ski?
18:59:51 <ski> haskell_chap : talking about type inferece with mparodi
19:00:01 <ski> the first step now is to *specialize* these *polymorphic* functions
19:00:05 <ski> in the sense that
19:00:11 <ski>   length :: [String] -> Int
19:00:15 <ski> is a specialization of
19:00:20 <ski>   length :: forall a. [a] -> Int
19:00:22 <dmwit> haskell_chap: This is cargo-cult advice, but did you install the command line tools from within Xcode?
19:00:28 <haskell_chap> ski: hm ic but I want to join the fun not just fiddle with Xcode
19:00:33 <dmwit> (<- does not have a Mac, and has never used Haskell on a Mac)
19:00:43 <ski> however, so far, we don't know what actual types we want instead of `a',`b',`c',`a' above
19:01:03 <ski> so we invent *placeholders*, e.g. calling them `_a',`_b',`_c',`_d'
19:01:05 <ski> so we get
19:01:20 <ski>   curry :: ((_a,_b) -> _c) -> (_a -> _b -> _c)
19:01:24 <ski>   id :: _d -> _d
19:01:37 <ski> now, since we have an application `curry id'
19:01:38 <haskell_chap> dmwit: please don't stereotype me
19:01:45 <dmwit> ?
19:01:58 <haskell_chap> dmwit: cargo cult
19:02:09 <ski> the formal parameter type of `curry' has to be the same as the type of `id' (the actual parameter)
19:02:12 <dmwit> I am cargo-culting, not you.
19:02:14 <ski> meaning
19:02:25 <ski>   (_a,_b) -> _c  =  _d -> _d
19:02:44 <dmwit> I saw somebody give this advice earlier; however, I don't understand it, so I don't actually know if it will help you.
19:02:51 <ski> and the type of the whole application `curry id' is the result type `_a -> _b -> _c'
19:02:55 <ski> so, now we know
19:02:56 <dmwit> Saying that it was cargo-cult advice was meant to be a succinct way of giving you this warning, nothing more.
19:03:06 <ski>   curry id :: _a -> _b -> _c
19:03:08 <ski>     where
19:03:10 <ski>   (_a,_b) -> _c  =  _d -> _d
19:03:22 <ski> however, we can simplify the type equation into
19:03:29 <ski>   (_a,_b) = _d
19:03:34 <ski>   _c = _d
19:04:06 <ski> and now we can replace `_c' and `_d' with `(_a,_b)', eliminating the placeholders `_c' and `_d'
19:04:08 <mparodi> oh, what on Earth!?
19:04:10 <ski> so we get just
19:04:11 <mparodi> lol
19:04:21 <ski>   curry id :: _a -> _b -> (_a,_b)
19:04:37 <ski> now, there's no more type equations to simplify
19:04:39 <mparodi> I definitely prefer the short version :P
19:04:47 <haskell_chap> dmwit: ah I understand
19:04:51 <ski> so we know that this typing actually works for *every* type `_a' and `_b'
19:05:09 <ski> so we can now *generalize* this typing into
19:05:18 <ski>   curry id :: forall a b. a -> b -> (a,b)
19:05:19 <ski> or
19:05:24 <ski>   curry id :: a -> b -> (a,b)
19:05:26 <ski> for short
19:05:47 <ski> mparodi : that's the long version :)
19:06:17 <ski> with more tricky things (e.g. if you get a strange type error) it can sometimes be helpful to spell out the type-inference steps as above
19:06:22 <dmwit> mparodi: The very short explanation is that since "c" can be anything in "curry :: ((a,b) -> c) -> (a -> b -> c)", it can in particular be "(a,b)", which means we can also give curry the type "curry :: ((a,b) -> (a,b)) -> (a -> b -> (a,b))". Done.
19:07:20 <ski> but usually it suffices to say that "the `a' in `id :: a -> a' unifies with the `(a,b)' as well as with the `c' in `curry :: ((a,b) -> c) -> (a -> b -> c)'"
19:07:24 * mzero poking his head up
19:07:39 <mzero> haskell_chap: did you get it working on your mac
19:08:34 <haskell_chap> mzero: yes i'm dwlding the command line tools now
19:08:46 <mzero> excellent -
19:08:46 <haskell_chap> mzero: no luck with the package however
19:08:54 <mzero> Haskell Platform will install after you do that
19:09:01 <haskell_chap> mzero: xcode 4.3.2 installed
19:09:11 <mzero> but you will need to hand fiddle /usr/bin/ghc
19:09:24 <haskell_chap> mzero: finally!
19:09:32 <mzero> or - I'm going to put up a release candidate of the next Haskell Platform tonigth (in about 4 hours)
19:09:41 <mparodi> ski, dmwit: thank you guys. I understood why but more important, I think I learned how to do it myself with any other function/composition
19:09:41 <mzero> and that will work out of the box with Xcode 4.3
19:09:43 <haskell_chap> mzero: thought i'd never see the light
19:09:55 <mzero> have to go put my kids to bed
19:09:56 <mzero> laters
19:10:06 <haskell_chap> mzero: take care and good luck
19:10:17 <haskell_chap> mzero: your project is worthy
19:10:45 <ski> mparodi : great :)
19:11:37 <strager> dmwit: Your explaination of 'curry id' was how I thought about the problem.
19:11:54 <dmwit> strager: The short explanation, or the very short one? =)
19:12:15 <strager> Your latest.
19:12:22 * dmwit nods
19:12:28 <rwbarton> i thought the very short explanation would be "because that is the type you get when you apply the HM type inference algorithm"
19:12:55 <dmwit> Yes, the very short explanation leaves a lot out (like how to magically choose "(a,b)" as the type that "c" can become).
19:13:11 <dmwit> The short explanation left less out.
19:13:17 <dmwit> But still a lot. =)
19:13:17 <shachaf> The very short explanation is "because GHC says so".
19:13:28 <strager> "Magic."
19:13:28 <shachaf> The very short explanation is "because".
19:13:38 <ion> The very short explanation is "".
19:13:42 <ski> @ghc
19:13:42 <lambdabot> ghc says: Try -fglasgow-exts for GHC's newtype-deriving extension
19:13:59 <strager> @quote
19:13:59 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
19:14:05 <strager> @quote
19:14:06 <lambdabot> Saizan_ says: it's not really that memorable.
19:14:11 <strager> Silly mutable state.
19:14:53 <dmwit> ?quote mutable
19:14:54 <lambdabot> elliott says: <Cale> Array is immutable boxed  <Cale> UArray is immutable unboxed  <Cale> IOArray is mutable boxed  <elliott> IOUArray is an array of debts.
19:15:15 <dmwit> =)
19:15:18 <haskell_chap> so just a quick ? cout << "How relevant is C++ to Haskell programming?" << endl;
19:15:34 <dmwit> ?where ffi
19:15:34 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/haskellch8.html
19:15:43 <dmwit> enjoy
19:16:11 <strager> haskell_chap: You can use existing knowledge of C++ in Haskell (templates in paticular)
19:16:25 <strager> But I don't think C++ is "relevant" to Haskell programming
19:16:57 <haskell_chap> lambdabot: thank you lambdabot
19:17:23 <shachaf> lambdabot++ # so helpful
19:18:00 <Gurrag> what's the current state of Windows native UI bindings in Haskell?
19:19:44 <haskell_chap> strager: would you care to say why?
19:20:38 <dmwit> Gurrag: The Win32 library exists, which includes bindings to GDI... (?)
19:20:47 <hpaste> ghorn pasted “type functions not injective or something” at http://hpaste.org/69085
19:20:52 <strager> Why about what specifically?
19:20:53 <Gurrag> dmwit: ok thank you !
19:21:16 <haskell_chap> y a des français dans ce forum?
19:21:29 <strager> non
19:21:33 <strager> desole =[
19:21:45 <haskell_chap> strager: haha vous parlez français?
19:21:48 <ghorn> this one is over my head
19:21:49 <strager> </all-my-french-willpower>
19:22:02 <strager> haskell_chap: I choose not to.
19:22:04 <haskell_chap> très bien
19:22:04 <ghorn> this was not helpful http://stackoverflow.com/a/8887088/717881
19:22:07 <rwbarton> ceci n'est pas un forum
19:22:52 <rwbarton> well okay, i don't know the use of the french word "forum" :)
19:23:16 <haskell_chap> rwbarton: oui je sais, c'est très sérieux ce qui est en train de developper là
19:23:55 <strager> I got most of that; let's see if Google Translate can help top it off.
19:24:19 <strager> d'oh; how could I forgot 'en train de'
19:24:29 <ski> ghorn : could you annotate your paste with the error message ?
19:24:32 <dmwit> ghorn: We are, as Haskell programmers, so used to assuming that if we know the type "Tree a", then we know what "a" is. But for type families, this isn't true.
19:25:03 <dmwit> ghorn: We may very well know that "F a = Int" and still not know what "a" is, because there may be two declarations like "F Double = Int" and "F [String] = Int".
19:25:33 <hpaste> ghorn annotated “type functions not injective or something” with “type functions not injective or something (annotation)” at http://hpaste.org/69085#a69086
19:25:41 <dmwit> (explanation of the term injective: if "f a" uniquely determines "a", then "f" is said to be injective)
19:26:51 <haskell_chap> are there French resources for Haskell? I'd like to do research in French
19:27:19 <ghorn> i see
19:27:27 <shachaf> haskell_chap: I think programming language resources tend to be in English.
19:27:45 <shachaf> You might have better luck with OCaml if you're just looking for things vaguely similar to Haskell. :-)
19:27:50 <haskell_chap> shachaf: true, but they did come up with Ocamel
19:27:58 <dmwit> ghorn: In particular, we may know that "foo :: Expr sh0 a", but that doesn't tell us necessarily that we should use the "sh0" instance of ExprList. There may be many types "sh'" that have an identical "Expr sh' a" type.
19:28:10 <dmwit> Sorry, s/foo/x/
19:28:20 <rwbarton> ML is a good gateway language to Haskell anyways
19:29:01 <haskell_chap> shachaf: it came out of Polytéchnique, since they are a technocratic society they have good resources. Although all education is public so it's state owned
19:29:05 <dmwit> ghorn: Modern GHC's will reject the class you wrote there outright, I think, because "foo" can never be successfully called.
19:29:36 <dmwit> Hm, apparently not.
19:29:48 <dmwit> I thought I saw something in one of the release notes about this, but it must be something subtly different.
19:29:59 <strager> haskell_chap: http://haskell.fr/wiki/index.php?title=Apprendre_Haskell
19:30:18 <strager> ça marche?
19:30:49 <dmwit> strager, haskell_chap: Maybe #haskell-fr ...?
19:30:59 <haskell_chap> strager: merci bien, je peux cultiver mon français au même temps, c'est merveilleux
19:32:00 <dmwit> Ah, only types with inferred impossible types are rejected.
19:32:16 <dmwit> If you explicitly ask for a type that's impossible to call, GHC lets you get away with it.
19:32:16 <ski> haskell_chap : maybe "Développement d'applications avec Objective Caml." Emmanuel Chailloux,Pascal Manoury,Bruno Pagano <http://caml.inria.fr/about/books.en.html#id219230>
19:32:17 <lexande> can anyone explain what "forall" means in terms of category theory?
19:33:17 <Saizan> lexande: a special case is to think of forall a. F a -> G a as a natural transformation between F and G
19:33:32 <ski> lexande : there's probably several answers, but i think it has to do with ends and coends -- edwardk could probably explain it
19:33:45 <rwbarton> forall a. ... is an end yes
19:34:10 <ski> or possibly Cale could explain it :)
19:34:11 <rwbarton> but i don't know where this is written down, i only realized it recently
19:34:24 <Cale> explain what?
19:34:37 <ski> how `forall' and `exists' are related to ends and coends
19:34:58 <ski> i've been trying to read "Categories for the working Mathematician" on this, but i haven't managed to decipher it yet
19:35:05 <Cale> Nope, can't explain. I just barely know what ends and coends are.
19:35:41 <rwbarton> I guess the "theorems for free" paper is about this?
19:36:00 <ski> lexande : in any case, a function of type `forall a. F a -> G a' corresponds to a natural transformation from the functor `F' to the functor `G'
19:36:28 <ski> @type maybeToList
19:36:29 <lambdabot> forall a. Maybe a -> [a]
19:36:42 <ski> is therefore a natural transformation from `Maybe' to `[]'
19:37:02 <dmwit> rwbarton: Bidirectionalization for Free, too, I guess.
19:37:26 <rwbarton> I hadn't heard of that paper
19:37:31 <dmwit> They even use subcategories of Hask like Eq and Ord.
19:37:36 <haskell_chap> Is there a french Haskell chat?
19:37:38 <ski> (natural transformations has to satisfy a law -- but it happens that since polymorphism in Haskell is truly *parametric* (technical word), every such polymorphic function in Haskell is a natural transformation)
19:37:43 <lexande> ski, thank you
19:37:44 <dmwit> haskell_chap: As I said before, #haskell-fr
19:37:53 <otters> wow
19:37:54 <haskell_chap> dmwit: thanks
19:37:56 <otters> there's a french haskell chat
19:38:00 <ski> lexande : did you want to know anything more specific ?
19:38:33 <lexande> not really
19:38:35 <ski> (there's a swedish one too, #haskell.se, and in various other languages as well)
19:39:13 <ski> lexande : let's say we have a polymorphic function `eta :: forall a. F a -> G a'
19:39:43 <ski> lexande : we could think of this as a family of (monomorphic) functions, one for each choice of the type `a'
19:39:51 <ski>   eta_a :: F a -> G a
19:40:06 <ski> (though in Haskell we'd still write `eta', not `eta_a')
19:40:07 <lexande> yeah i can see why it would be a natural transformation
19:40:22 <ski> now, say we have two types `a',`b', and a function
19:40:25 <ski>   f :: a -> b
19:40:35 <ski> the law now says that
19:40:56 <ski>   eta_b . fmap_F f = fmap_G . eta_a
19:41:02 <ski> er
19:41:05 <ski>   eta_b . fmap_F f = fmap_G f . eta_a
19:41:24 <ski> the left side is a function that goes from `F a', via `F b', to `G b'
19:41:38 <ski> the right side is a function that goes from `F a', via `G a', to `G b'
19:41:44 <lexande> that is just the criterion for something to be a natural transformation, no?
19:41:47 <jfischoff> I'm trying to debug a package conflict issue, and when I run ghc-pkg -V I get: shell-init: error retrieving current directory: getcwd: cannot access parent directories: No such file or directory
19:41:54 <ski> and the law just says that it shouldn't matter which way we compose here
19:41:54 <jfischoff> is that something to worry about?
19:42:06 <ski> lexande : yes
19:42:17 <rwbarton> lexande: yes. but it is also the criterion to be in the end of the bifunctor F a -> G b
19:42:33 <ski> lexande : and it so happens that every polymorphic function in Haskell automatically satisfy such a law
19:42:47 <geekosaur> jfischoff, something deleted your current directory out from under you (that message is from bash)
19:43:24 <ski> lexande : however, if it was possibly in Haskell to *check* what type `a' actually had, inside the function `eta' (and then possibly do different things depending on what type `a' was), *then* the law wouldn't hold automatically
19:43:24 <dmwit> geekosaur: If you don't consider it rude, I'd love to know about how old you are.
19:44:10 <lexande> ski, but the law might hold anyway
19:44:15 <ski> yes
19:44:20 <shachaf> Hey, it's lexande.
19:44:22 <dmwit> (You are very expert, and I wonder how long it takes to achieve that.)
19:44:25 <ski> but we can't rely on it, by type-checking
19:44:27 <geekosaur> and is printed at the start of a script, and ghc-pkg is a script which wraps the real ghc-pkg (so it can be moved)
19:44:36 <geekosaur> dmwit: 47
19:44:53 <dmwit> cheers
19:44:56 <geekosaur> and have been working with Unix since 1982
19:45:18 <jfischoff> geekosaur: thanks
19:45:27 <lexande> ski, so forall a. F a -> G a does not contain all the natural transformations between F and G?
19:45:29 <lexande> just some of them?
19:46:13 <ski> lexande : are you talking about Haskell now, or about a language where parametricity doesn't automatically hold ?
19:46:34 <ski> in any case, you'd have to specify what you mean by "all"
19:47:29 <ski> (e.g. one can't define uncomputable natural transformations in Haskell)
19:47:31 <lexande> oh i guess it's just a property of Hask that all the morphisms satisfy whatever criteria you need for that to work
19:48:22 <lexande> sometimes the stuff after forall a. does not look much like a bifunctor though
19:48:27 <ski> yes
19:48:45 <ski> i think that's where ends would probably come in
19:50:09 <ski> if you have `forall a. F a', where `F' is a functor, then you could rewrite this into basically the same `forall a. Const () a -> F a'
19:50:10 <lexande> but an end is also a thing that a bifunctor has
19:50:18 <ghorn> so is there a quick fix for my issue, or do i have to figure out a different way of doing it?
19:50:34 <lexande> what if i have forall a. a -> a -> a
19:50:41 <dmwit> ghorn: You have to figure out a different way of doing it.
19:50:50 <dmwit> ghorn: Usually it's not hard: just make the type function go "the other way".
19:50:58 <dmwit> Instead of "f x = y" write "f y = x".
19:50:58 <ski> (actually i think rwbarton probably meant difunctor)
19:51:08 <lexande> hmm, i guess that's natural transformations from Const to Hom
19:51:37 <dmwit> But it's much too late for me to carefully understand your problem domain and give more targeted advice, sorry.
19:51:48 <ski> well, `\a -> (a -> a)' is not a functor
19:52:17 <dmwit> Natural transformations are just ends of difunctors, what's the problem?
19:52:45 <lexande> dmwit, that's not the problem, i was just trying to work out which difunctor in particular
19:52:56 <dmwit> It was a joke.
19:53:01 <dmwit> ?quote wadler endofunctor
19:53:01 <lambdabot> wadler says: A monad is a monoid in the category of endofunctors, what's the problem?
19:53:02 <lexande> i know
19:53:34 <lexande> but i don't see a problem with that either, though i'd like it if somebody could tell me what the eilenberg-moore category of the IO monad looks like
19:55:05 <lexande> ski, i don't know how to parse `\a -> (a -> a)' at all, assuming a is a type
19:55:21 <lexande> hmm, i suppose i can guess
19:55:35 <dmwit> Uh, I didn't read carefully, but surely not all monads are the result of some adjunction.
19:55:42 <lexande> dmwit, yes they are
19:56:10 <lexande> not just one adjunction either
19:58:34 <dmwit> Wow. This is neat.
19:58:48 <lexande> there's an adjunction between Hask and the kleisli category of the IO monad that gives rise to the IO monad, but that doesn't seem very interesting.  having though about it for other monads (e.g. the eilenberg-moore category of list is monoid) it seems like the eilenberg-moore category of IO would be more interesting
19:58:57 <ski> two adjunction situations (which may coincide)
19:59:27 <lexande> but i can't get my head around what it should look like
19:59:43 <copumpkin> dmwit: the kleisli/EM categories were supposedly originally "designed" to find an adjunction that gives rise to a given monad
19:59:50 <copumpkin> dmwit: they might not be the only ones though
20:00:57 <ski> hm, right .. i thought dinatural transformations were involved ..
20:01:25 <lexande> ski, also why isn't \a -> (a->a) a functor?  it seems like you can define the action on morphisms suitably
20:01:46 <lexande> hmm, no i suppose you can't
20:01:55 <dmwit> The action would need an isomorphism rather than just an arrow.
20:02:16 <ski> lexande : `a' occurs both positively/covariantly, and negatively/contravariantly
20:02:30 <lexande> so what difunctor is \forall a. a -> (a -> a) an end of?
20:02:33 <dmwit> ...possibly just a forward and backward arrow with some properties, not sure which ones.
20:03:05 <ski> .. however, istr there was something fun there with species
20:03:46 <ski> where you take the category of finite sets and *iso*morphisms between them as morphisms, and considers endofunctors on that category
20:04:14 <lexande> for what?
20:04:49 <ski> for expressing species
20:05:41 <lexande> i am not sure what that means or what it has to do with difunctors on Hask
20:07:50 <ski> hm, i suppose an example where you may assume that every morphism is an iso
20:08:06 <haskell_chap> installation failed again... maybe I need something else besides the command line tools?
20:08:57 <haskell_chap> ah within xcode
20:11:17 <lexande> ski, but clearly you can't assume that in Hask
20:12:53 <gbacon> how can I unwedge my local cabal library? attempts at cabal install xmonad xmonad-contrib fail with dependency errors
20:13:48 <haskell_chap> ? about monad >> Is a monad thought of conceptually as an abstract tool?
20:18:43 <ski> lexande : *nod*, naturally not
20:19:05 * ski was browsing around <http://byorgey.wordpress.com/tag/combinatorial-species/>
20:19:17 <haskell_chap> oh man irc is connected to the coding environment! Super cool
20:20:22 <ski> lexande : <http://byorgey.wordpress.com/2009/07/24/introducing-math-combinatorics-species/> might be interesting
20:20:28 <lexande> rwbarton, what is forall a. a -> a -> a an end of?
20:21:44 <ski> of the difunctor `\(a0,a1). a0 -> a0 -> a1', i think
20:22:19 <lexande> i guess that is a difunctor
20:22:23 <fortran> hm
20:25:53 <rwbarton> yes
20:26:20 <rwbarton> you split all the occurrences of the type a (in "forall a.") into two variables according to whether they appear in positive or negative position
20:27:02 <rwbarton> and take the end of the resulting bifunctor
20:27:11 <ski> you probably also need to split all "invariant" functors used in the body like that, too
20:27:31 <rwbarton> yes, do this after expanding all the type constructors that appear
20:28:00 * ski isn't sure if this would sensibly be called "invariant functor"
20:28:28 <rwbarton> not sure, but i know what you mean
20:29:00 <ski> (i suspect that term might be in use for some other purpose)
20:29:40 <rwbarton> you could say it is a functor on the subcategory of isomorphisms
20:29:55 <rwbarton> but i think it is more productive here to think about the "split" bifunctor instead
20:30:26 <ski> yea
20:31:14 <mparodi_> ok, I did some examples and all of them were correct!
20:31:15 <mparodi_> but I still have a question
20:31:38 <mparodi_> suppose you have two functions with types:      ((a, b) -> c) -> d -> e       and         f -> g -> h
20:31:46 <mparodi_> there're many options there
20:32:17 <mparodi_> f = ((a, b) -> c)
20:32:18 <mparodi_> g -> h = d
20:32:19 <mparodi_> for example
20:32:50 <dmwit> mparodi_: Are you applying the former to the latter, or equating the former type and the latter?
20:32:58 <mparodi_> or
20:32:59 <mparodi_> f = (a, b)
20:32:59 <mparodi_> g -> h = c
20:33:21 <mparodi_> if the functions are called foo and bar, then I'm doing "foo bar"
20:33:26 <dmwit> mparodi_: Also, note that ((a,b) -> c) -> d -> e is ((a,b) -> c) -> (d -> e) and no other parenthesization is correct.
20:33:38 <dmwit> mparodi_: Okay, so you're equating ((a,b) -> c) and (f -> g -> h)?
20:33:52 <dmwit> That is, trying to equate ((a,b) -> c) and (f -> (g -> h))?
20:33:55 <mparodi_> ah, yes! that remove the ambiguity
20:33:58 <mparodi_> removes*
20:34:04 <dmwit> The first arguments to (->) must be equal, and the second arguments must be equal, so we must have
20:34:12 <dmwit> (a,b) = f and c = g -> h
20:34:25 <mzero> haskell_chap: you are still stuck
20:34:34 <mzero> in what way did the install fail?
20:36:24 <mparodi_> you're right. there's no problem if you consider the implicit parenthesis at the end (I didn't!)
20:36:26 <mparodi_> thank you dmwit
20:38:12 <mparodi_> foo :: ((a,b) -> c) -> d -> e
20:38:13 <mparodi_> bar :: f -> g
20:38:16 <mparodi_> what about this one?
20:38:28 <mparodi_> f = (a,b) and g = c
20:38:37 <mparodi_> or f = ((a,b) -> c) and g = d
20:38:38 <mparodi_> ?
20:39:23 <dmwit> If we are trying to typecheck the expression "foo bar", then we must equate the argument type of foo with the entire type of bar.
20:39:24 <mparodi_> (I guess the first one is the correct one)
20:39:36 <dmwit> So (a,b) -> c = f -> g
20:39:50 <mparodi_> right, I got it :)
20:40:26 <dmwit> The type ((a,b) -> c) -> d is not a subterm of the type ((a,b) -> c) -> d -> e
20:40:48 <dmwit> The direct subterms are (a,b) -> c and d -> e; that is, the only correct parenthesization is ((a,b) -> c) -> (d -> e).
20:40:59 <dmwit> (((a,b) -> c) -> d) -> e is a different type.
20:41:17 <dmwit> (All three of those sentences are saying the same thing in different ways.)
20:41:28 <tgeeky> whoa! learning!
20:41:48 <dmwit> tgeeky: mparodi_ is learning to do unification by hand =)
20:42:00 <mparodi_> yeah u.u
20:42:13 <tgeeky> cool. maybe I should read this stuff.
20:42:20 <tgeeky> s/maybe//
20:42:48 <shachaf> Is the opposite of unification "ification"?
20:45:35 <mparodi_> ok, I'm not trying to see why curry uncurry is not correct, I have:
20:45:40 <mparodi_> curry :: ((a, b) -> c) -> (a -> b -> c)
20:45:41 <mparodi_> uncurry :: (d -> e -> f) -> (d, e) -> f
20:45:41 <mparodi_> (a, b) -> c = (d -> e -> f) -> ((d, e) -> f)
20:45:41 <mparodi_> =>
20:45:41 <mparodi_> (a, b) = d -> e -> f
20:45:41 <mparodi_> c = (d, e) -> f
20:45:47 <mparodi_> so
20:45:51 <mparodi_> curry uncurry :: a -> b -> (d, e) -> f
20:46:06 <mparodi_> but you can put a and b in using just d, e and f
20:46:19 <mparodi_> so I guess it's enough to say "curry uncurry" is wrong
20:46:34 <dmwit> Well, the reason it's wrong is because in the equation
20:46:37 <mparodi_> I meat, you can't but... *
20:46:39 <dmwit> (a,b) = d -> e -> f
20:46:50 <dmwit> The top constructor on the left is (,), but the top constructor on the right is (->).
20:46:50 <mzero> mparodi_: did you mean    curry . uncurry   ?
20:46:56 <dmwit> Since those aren't equal, you're hosed.
20:47:00 <dmwit> There's no solutions to that equation.
20:47:25 <dmwit> (Nothing we could every hope to write for "a", "b", "d", "e", and "f" would make a tuple type be equal to a function type!)
20:47:32 <mparodi_> <mparodi_> but you CAN'T put a and b in using just d, e and f <-- that's what I tried to say
20:47:48 <tgeeky> @type uncurry  curry
20:47:49 <lambdabot> forall b b1 c. ((b, b1) -> c, b) -> b1 -> c
20:47:50 <tgeeky> @type uncurry . curry
20:47:50 <lambdabot> forall a b c. ((a, b) -> c) -> (a, b) -> c
20:47:58 <dmwit> :t curry uncurry
20:48:00 <lambdabot>     Couldn't match expected type `(a, b)'
20:48:00 <lambdabot>            against inferred type `a1 -> b1 -> c'
20:48:00 <lambdabot>     In the first argument of `curry', namely `uncurry'
20:48:12 <tgeeky> (,) a b = ((->) d e) -> f
20:48:17 <tgeeky> that can't be true! :o
20:48:21 <dmwit> mparodi_: Not only did you correctly observe that it's unsolvable, you even reached the same unsolvable equation GHC did: (a,b) = a1 -> b1 -> c
20:48:24 <dmwit> =)
20:48:34 <mparodi_> good
20:48:42 <dmwit> (Though you used different letters.)
20:48:47 <dmwit> tgeeky: correct, it can't be true =)
20:48:51 <shachaf> @let type (,) = (->)
20:48:52 <lambdabot>   Illegal test declaration
20:49:25 <mparodi_> yes, I prefer not to use numbers :P
20:49:36 <mparodi_> (like in a1, b1, etc)
20:51:56 <tgeeky> dmwit: have you made progress (coding OR thinking) about pee?
20:52:08 <tgeeky> or is it on the backburner?
20:52:18 <dmwit> What's left to do? =)
20:52:22 <tgeeky> haha
20:52:28 <tgeeky> all the things :O
20:53:17 * hackagebot GTALib 0.0.3 - A library for GTA programming  http://hackage.haskell.org/package/GTALib-0.0.3 (KentoEmoto)
21:21:03 <amdavidson> Hola, I'm on step11 of tryhaskell.org, it seems to be sensitive to the difference between " and '
21:21:08 <amdavidson> is that true of haskell?
21:21:14 <shachaf> Yes.
21:21:20 <shachaf> "" is for strings, '' is for characters.
21:21:24 <shachaf> Like C*.
21:21:32 <shachaf> * In C '' is actually for integers, but close enough.
21:21:48 <amdavidson> thanks. what should 'a' : [] return?
21:21:58 <shachaf> 'a' : [] is the same as "a"
21:22:03 <shachaf> Also the same as ['a']
21:22:16 <amdavidson> "a" == ['a
21:22:17 <amdavidson> ']
21:22:20 <amdavidson> ?
21:22:27 <shachaf> Why don't you type that into the tryhaskell prompt? :-)
21:22:44 <amdavidson> I did. It says it should return ['a'] and it does return "a"
21:22:50 <amdavidson> it doesn't say that they're the same thing.
21:24:10 <shachaf> I mean, type «"a" == ['a']» into tryhaskell
21:24:14 <shachaf> It should say "True".
21:24:17 <mzero> think of double-quoted characters as just a pretty way to print a ist of Char
21:24:38 <ski> > ['a','b','c']
21:24:39 <lambdabot>   "abc"
21:24:57 <amdavidson> ok, thanks.
21:25:16 <pooya72> hi, how would i use fromSql on [SqlByteString "Title"] to convert it to a string?
21:25:36 <shachaf> amdavidson: By the way, if you're in the bay area, you should come to bahaskell next month!
21:29:56 <pooya72> nevermind I got it :)
21:53:21 * hackagebot dvda 0.1 - Efficient automatic differentiation  http://hackage.haskell.org/package/dvda-0.1 (GregHorn)
22:08:21 * hackagebot dvda 0.1.1 - Efficient automatic differentiation  http://hackage.haskell.org/package/dvda-0.1.1 (GregHorn)
22:13:18 <chimeracoder> I'm getting build errors (Could not deduce type) on /HMAC.hsc for nano-hmac with ghc 7.4 - what's the best way to fix this?
22:14:25 <mzero> that package hasn't been updated since 2008, and hasn't compiled since GHC 7.0
22:14:37 <mzero> I think if you want it to work, you'll have to do some serious hacking
22:14:39 <chimeracoder> damn
22:14:58 <chimeracoder> what's the package I should use to get hmac-sha1, then?
22:15:57 <mzero> Crypto
22:16:02 <mzero> @package Crypto
22:16:02 <lambdabot> http://hackage.haskell.org/package/Crypto
22:16:18 <mzero> or
22:16:20 <mzero> @package SHA
22:16:21 <lambdabot> http://hackage.haskell.org/package/SHA
22:16:53 <tommd> Just use the cryptohash package instead, if you have the choice.
22:17:15 <tommd> It has high performance SHA C bindings.
22:17:39 <mzero> @package cryptohash
22:17:39 <lambdabot> http://hackage.haskell.org/package/cryptohash
22:17:44 <mzero> it is also up-to-date
22:18:05 <shachaf> Is that package really a reimplementation of cryptographic primitives in Haskell?
22:18:11 <tommd> No.
22:18:16 <tommd> It is bindings to C implementations.
22:18:35 <tommd> Vincent has a lot of good work in the Haskell/Crypto space (cryptohash, cryptocipher, tls, some others)
22:18:35 <shachaf> Which one?
22:18:40 <mzero> the later
22:18:52 <shachaf> Ah. I meant Crypto.
22:19:06 <chimeracoder> I think I tried using that one but it wasn't working for some reason - let me try again
22:19:07 <tommd> Crypto is a reimplementation of SHA in Haskell, yes.
22:19:58 <mzero> as is the SHA package (that is, also pure Haskell)
22:20:09 <tommd> If "that one" is cryptohash that isn't working then that is a bug (or error on your part) and should be reported.
22:20:51 <chimeracoder> tommd: I meant cryptohash, yes, but it was probably my error (the function call itself didn't work, not the compilation/build, so let me see)
22:23:44 <tommd> If you run into issues feel free to e-mail or open a S.O. question.
22:23:47 * tommd goes to bed
22:24:51 <chimeracoder> tommd: thanks
22:26:24 <chimeracoder> woohoo, it works! thanks!
23:05:02 <sid_> amazing
23:05:39 <mzero> why yes, Haskell is amazing!
23:11:47 <Eduard_Munteanu> I think that was an amazingly short stay. :D
23:38:20 <jonaskoelker> is there a word for approximating a probability distribution by repeated sampling?
23:42:31 <b_jonas> jonaskoelker: empirical distribution?
23:43:28 <b_jonas> not quite what you want
23:45:32 <shawng> hello everyone
23:46:37 <shawng> zeroz: top of the morning to you
23:47:30 <shawng> anyone awake even?
23:50:39 <shawng> just curious what the relevance of scheme is to Haskell
23:51:07 <shawng> guess i'm just asking ? to myself then
23:51:26 <jonaskoelker> b_jonas: yeah... and now the trick: in verb form :-)
23:51:28 <shawng> hey there
23:51:30 <jonaskoelker> empiricize?
23:51:40 <jonaskoelker> oh well, I'll go with "approximate"
23:52:37 <shawng> jonaskoelker: so do you create your own operators much? You know, top up design?
23:52:42 <solrize> jonaskoelker, there are some specific fancy algorithms like gibbs sampling
23:52:52 <solrize> but nothing comes to mind generically
