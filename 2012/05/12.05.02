00:00:17 <ymasory> ion: since we're going [IO ()] -> IO () isn't that using IO as a monoid?
00:02:23 <sabrehagen> shachaf: The reason I'm asking is the support at my university is appalling, we don't have tutorial classes, just a lecture. I've been going to ex students to ask questions, and try to gain an understanding. When they're not available, I come here for assistance in understanding what is a very complex language for me.
00:03:35 <shachaf> sabrehagen: It's considered polite to mention that something is homework in the question as you ask it. :-)
00:03:50 <shachaf> Anyway, what's the point of having Val there at all?
00:04:13 <sabrehagen> shachaf: sorry, i understand that. i've been asking so many questions of so many people you forget to keep mentioning it all the time! :)
00:04:47 <sabrehagen> shachaf: well it's part of the spec, i have no choice in in being there. The GADT is expecting either an Int or a Bool, I don't know why we have to make our own datatypes for it.
00:05:46 <shachaf> Are you sure this makes sense?
00:05:57 <sabrehagen> shachaf: Should I just write Con     :: Val -> Term Valo and modify my spec to "data Term Val where"? Does this look like what the top part (the spec) is asking? I'm actually really confused what it's asking!
00:06:15 <shachaf> You don't *want* a Term Val, do you?
00:06:39 <shachaf> I think that defeats the whole purpose, unless I'm misunderstanding.
00:06:48 <sabrehagen> shachaf: well, technically i believe it should be able to take anything, but I'm trying to write an expression evaluator, so it only expects integers or booleans, nothing else.
00:07:10 <sabrehagen> shachaf: if it gets given something else, it won't be able to interface with the other parts of the GADT
00:07:13 <shachaf> The whole point of the "type safe" thing is that you're *not* dealing in Vals. No?
00:08:53 <sabrehagen> shachaf: I *guess* so. That makes sense to me. The spec has it included though, where it says "together with the following definition of the possible values that can arise from evaluating such terms". Do you take this to mean the GADT should return types of Vals rather than basic Integers or Bools?
00:13:13 <yitz> sabrehagen: are you sure you need to include Val in your solution? it looks to me like Val was just invented to be able to create the "untyped" version of Term. perhaps the instructor means that once you have "completed" that to be "typed", you don't need Val anymore.
00:14:03 <shachaf> Maybe they're after evaluateTerm :: Term t -> Val, or something like that.
00:14:35 <sabrehagen> yitz: hmmm, yes, i can see what you mean there. i'll opt to go with that for now. i think the spec could just be worded badly...great, that was a waste of about an hour trying to chase that down!
00:16:48 <shachaf> sabrehagen: "that can arise from evaluating" seems pretty clearly not to be about intermediate representations.
01:11:29 <womb> Hi guys
01:14:31 <yitz> hi womb
01:15:24 <sabrehagen> hi guys, back for more questions :) as requested before, i should mention this is for a university task. i have to "implement a statically type-safe eval function". The file I just pasted has the rest of the question and supporting code. I really have *no idea* how to make a statically typed evaluator. Could somebody tell me if i'm on the right track, or how i should get on it?
01:15:29 <hpaste_> sabrehagen pasted “Eval Module” at http://hpaste.org/67956
01:18:43 <ziman> sabrehagen, the index "t" in your Term datatype tells you what type the Term would evaluate to
01:19:08 <ziman> so the eval function should have probably the type eval :: Term t -> t
01:20:08 <ziman> then you get nice correct-by construction representation of terms because, for example, you can apply And only to terms that represent a boolean value
01:20:33 <ziman> and, in turn, when you evaluate a term representing a boolean value, you want to get a Bool, naturally
01:21:11 <yitz> sabrehagen: what ziman is saying goes according the assumption we made earlier about what your instructor means. if you think it's reasonable to use the type ziman says for eval, then go for it.
01:21:43 <sabrehagen> ziman: oops, that makes sense. so things like "eval (And Term p Term q)" should be "eval (And p q)" because the data type of p and q are restricted by "eval :: Term t -> t" to Term?
01:22:15 <yitz> sabrehagen: restricted to Term t for some t
01:22:40 <sabrehagen> yitz: I subsequently found the line "Consider them a specification for the type-safe version of Term that you need to implement. ", so I believe the data Val... type can be discarded.
01:22:51 <yitz> yay!
01:23:17 <yitz> sabrehagen: then follow ziman
01:23:57 <sabrehagen> yitz: haha :) okay, restricted to Term t for some t. Coming from a C background, is it true to say that t is of type Term?
01:24:07 <sabrehagen> (i'm still having trouble with these basic things)
01:24:31 <yitz> no
01:24:57 * hackagebot ghc-heap-view 0.2 - Extract the heap representation of Haskell values and thunks  http://hackage.haskell.org/package/ghc-heap-view-0.2 (JoachimBreitner)
01:25:21 <sabrehagen> yitz: how should it be said then? I know you said "restricted to Term t for some t", but I'm having trouble seeing the difference between that and what I said. (not trying to sound smart!)
01:25:25 <yitz> t is Bool or Integer or something concrete. "Term t" is a term that evaluates to a t, where t can be Bool, Integer...
01:25:26 <Botje> sabrehagen: Term t is a value that contains a term that is guaranteed to evaluate to a value of type t
01:26:21 <Botje> mentally replace "term" by "program" if that helps :)
01:26:34 <sabrehagen> Botje: hmmm, okay, that makes sense. i wouldn't have worked it out myself though!
01:27:02 <yitz> sabrehagen: you're not supposed to work that out by yourself. your instructor is supposed to tell you that.
01:27:21 <Botje> well, you need to provide the right eval function that actually *produces* that t
01:27:32 <ziman> t is any type and I'd say Term is "tagged" by this type; the usual interpretation is that "Term Bool" is a term representing "Bool" (that will evaluate to Bool), "Term Int" represents an "Int" and, in general, for any t, "Term t" represents the type t
01:27:47 <ziman> er, represents a value of the type t
01:27:53 <sabrehagen> yitz: yes, it's rather lacking in that department. he's *good*, but when it's done in a lecture, you really need the tutorial followup, which is what we're lacking!
01:28:06 <yitz> sabrehagen: ok hang out here more
01:28:54 <sabrehagen> ziman: thanks, that's helping to clear it up :)
01:29:07 <sabrehagen> yitz: hehe, my hours on here over the past few weeks have skyrocketed! i feel bad asking so many questions, but everybody seems very willing to help
01:29:08 <ziman> and compiler keeps track of the tags and only allows you to combine terms so that their tags match the rules you defined in the data declaration
01:30:14 <yitz> sabrehagen: well, haskell is fun to discuss, so we can't resist
01:54:31 <bartavelle> hello, my do blocks look like that : http://hpaste.org/67959 . Is there some syntactic sugar or some way to avoid all the indentation ?
01:54:38 <merijn> Is there something like @pl for brace removal? :p
01:54:44 <rodayo> Just curious, is it possible to defined getLine recursively using getChar?
01:54:52 <rodayo> if so, how?
01:54:59 <shachaf> merijn: @undo, perhaps.
01:55:13 <shachaf> bartavelle: Maybe you want something like EitherT?
01:55:19 <shachaf> Or ErrorT or however it's called.
01:55:24 <merijn> rodayo: I think so
01:55:32 <bartavelle> shachaf, perhaps, I will look that up
01:55:34 <shachaf> rodayo: Yes.
01:55:51 <shachaf> bartavelle: This deep-indentation pattern is exactly what you'd use a monad to solve, at any rate.
01:56:03 <rodayo> shachaf, can you explain how it's done?
01:56:14 <shachaf> rodayo: Do you know how IO works in Haskell?
01:56:15 <merijn> rodayo: Would actually be a nice "do I understand the IO monad" exercise :p
01:56:43 <rodayo> i actually just started the IO chapter in Learn you a Haskell
01:57:05 <merijn> rodayo: Just call getChar until you hit EOL and then return all characters until then. It'll be very inefficient, but it would work
01:57:11 <rodayo> i sorta toy around with everything inside the tutorial so I was wondering if this was possible
01:57:21 <shachaf> rodayo: It's pretty easy so it'll probably make a good exercise. :-)
01:57:40 <merijn> rodayo: Yeah, I would recommend trying and asking for help when you get stuck :p
01:57:47 <bartavelle> shachaf, the second example in http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-Error.html seems to also lead to deep indentation
01:57:49 <rodayo> merijn, shachaf, alright i'll give it a go and come back if i get stuck
01:57:59 <merijn> (I think can actually think of 3 different implementations without to much effort :p)
01:58:10 <bartavelle> i thought about something like "monadplus", but I am not sure I understood what it did, or if that was actually appropriate
01:58:13 <shachaf> merijn: Three different implementations?
01:58:33 <shachaf> bartavelle: I don't think you need MonadPlus for this.
01:59:30 <rodayo> would the edge case be defined as "getLine' EOL = ..."?
01:59:44 <shachaf> rodayo: getLine doesn't take any arguments.
01:59:45 <rodayo> i haven't seen EOL before so i'm not sure
01:59:53 <shachaf> EOL means '\n'
01:59:57 <shachaf> Newline.
02:00:03 <shachaf> (End-of-line, really.)
02:00:08 <rodayo> alright...tricky =P
02:00:39 <shachaf> rodayo: Which introduction to IO did you read?
02:00:46 <shachaf> A lot of them are misleading and/or wrong.
02:00:49 <rodayo> http://learnyouahaskell.com/input-and-output#hello-world
02:00:58 <shachaf> Hrm. I don't know much about it.
02:01:02 <shachaf> The FAQ might help:
02:01:04 <shachaf> @where faq
02:01:04 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
02:01:26 <hpaste_> dmwit annotated “ugly blocks” with “what ugly blocks looks like using ErrorT” at http://hpaste.org/67959#a67960
02:01:38 <dmwit> bartavelle:
02:02:08 <bartavelle> ahhh !
02:02:10 <bartavelle> nice
02:02:14 <shachaf> dmwit++ # taking the trouble
02:02:18 <rodayo> shachaf, cool thx
02:02:27 <bartavelle> thanks a lot dmwit
02:06:38 <rodayo> I did it but I'm not sure why it worked: http://pastie.org/3847718
02:07:00 <rodayo> I was expecting it to read only the last character
02:07:54 <shachaf> rodayo: Are you sure that works?
02:08:18 <rodayo> shachaf, yep =P i was surprised too
02:08:27 <shachaf> Doesn't work for me.
02:08:58 <merijn> It works here (for returning the last char)
02:09:10 <merijn> So, next step is how to return all the others too :p
02:09:13 <rodayo> shachaf, oh damn! i forgot the ' in the main
02:09:19 <shachaf> I thought so.
02:09:38 <rodayo> lol so it did whta i expected it to...just prints the \n from the end of the line
02:09:53 <shachaf> Right.
02:09:58 <shachaf> You should call it antiGetLine!
02:10:06 <dmwit> I'll help you write the next version.
02:10:08 <shachaf> (Because getLine gives you everything *but* the '\n'.)
02:10:15 <dmwit> getLine' = go "" where ...
02:10:26 <shachaf> Is there a takeWhileM :: (a -> Bool) -> [IO a] -> IO [a]?
02:10:29 <shachaf> dmwit: Huh? You don't need go.
02:10:41 <shachaf> You just need a small modification of rodayo's existing function.
02:10:50 <shachaf> One-line change, or three lines the long way.
02:11:17 <dmwit> Sure, there are other ways.
02:11:21 <merijn> rodayo: You can turn it into a working implementation by adding 7 characters (9 if you include spaces), although that's probably cheating by using an operator you don't know :p
02:11:30 <rodayo> I haven't learned "go" and "where" yet
02:11:37 <dmwit> go is not a keyword
02:11:40 <dmwit> > let go = 3 in go
02:11:42 <lambdabot>   3
02:11:45 <shachaf> rodayo: "go" is a function you define.
02:11:52 <dmwit> let go x = x + 5 in go 3
02:11:52 <merijn> go isn't a keyword, it's a common name for helper functions
02:11:59 <shachaf> "where" is just like let except backwards (note: the previous statement is false)
02:12:07 <rodayo> oic
02:12:10 <merijn> It's just short for "I can't be arsed to name this"
02:12:28 <shachaf> dmwit: I'm not sure what your plan with "go" is exactly -- appending at the end each time?
02:13:01 <merijn> rodayo: Btw, in the else clause the "do" is redundant. If you have a single IO value you can just write that directly
02:13:27 <dmwit> shachaf: Or reverse at the end.
02:13:37 <shachaf> I guess.
02:13:45 <rodayo> merijn, oh yeah you're right! thx
02:14:21 <merijn> btw
02:14:47 <merijn> Anyone else annoyed that hpaste's input box doesn't have a fixed with font or is that just my browser selecting a wrong default?
02:15:10 <dmwit> hpaste is monospace here
02:15:15 <merijn> No, it's hpaste related as other input fields use courier for me
02:16:01 <dmwit> It has textarea { font-family: monospace; } in its CSS file.
02:16:15 <dmwit> Oh, I lied, that's in my user agent stylesheet.
02:16:33 <dmwit> Seems your browser just chooses a non-monospace font for textareas.
02:17:06 <quicksilver> I agree with merijn, it is annoying
02:17:15 <quicksilver> but mostly I compose hpastes in $EDITOR and just copy/paste
02:17:30 <quicksilver> seems like a simple CSS change that would be sensible to suggest to the maintainer, though
02:17:35 <quicksilver> chrisdone is it?
02:18:10 <quicksilver> no CSS files in hpaste's CSS dir :-/ https://github.com/chrisdone/hpaste/tree/master/wwwroot/css
02:18:56 <rodayo> It's getting late for me...thanks for the help. =) I'll tackle this again tmrw
02:20:05 <dmwit> quicksilver: grep for amelie
02:20:52 <dmwit> um
02:23:05 <merijn> Hmm, is there a nice way to do "fmap $ fmap foo"
02:23:16 <dmwit> that looks nice to me
02:23:41 <shachaf> @ty fmap (fmap ?foo)
02:23:42 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (?foo::a -> b, Functor f, Functor f1) => f1 (f a) -> f1 (f b)
02:23:44 <shachaf> @ty (?foo .:)
02:23:44 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (?foo::a -> b, Functor f, Functor g) => f (g a) -> f (g b)
02:24:34 <shachaf> merijn: Do you consider "fmap fmap fmap foo" to be nicer than "fmap (fmap foo)"?
02:25:22 <merijn> Actually, I think I want this:
02:25:24 <merijn> (<$$>) :: (Functor f1, Functor f2) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
02:25:24 <merijn> (<$$>) = fmap . fmap
02:25:39 <shachaf> merijn: That's (.:)
02:25:51 <merijn> Where's that defined?
02:26:04 <quicksilver> dmwit: there is an amelie.css but I don't see it in the repo
02:26:12 <Catnaroek> How can you even read that stuff?
02:26:20 <shachaf> merijn: Lambdabot's L.hs
02:26:31 <quicksilver> dmwit: mind you I can't see how to make github search the repo
02:26:47 <merijn> Catnaroek: With some practice :)
02:27:03 <dmwit> quicksilver: Yeah, sorry for the red herring. Amelie seems to be the name of the project.
02:27:21 <merijn> Catnaroek: tbh, once you get used to syntax conventions it's not that hard. Unless you try and read code written by edwardk :p
02:27:45 <quicksilver> dmwit: yes, indeed. I think he forgot to commit the CSS file.
02:27:53 <Catnaroek> Code like that is the reason why I never explicitly declare the types of things.
02:27:53 <quicksilver> preflex: seen chrisdone
02:27:53 <preflex>  chrisdone was last seen on #haskell 9 days, 20 hours, 23 minutes and 54 seconds ago, saying: or if you're using the split library you can split and use intercalate
02:28:46 <yitz> merijn: i often write (fmap . fmap) foo, but it depends on the context
02:29:36 <quicksilver> @tell chrisdone Does hpaste use an amelie.css which isn't in the github repo? I can't see it, maybe I'm being blind or maybe it's magically generated somehow? Anyhow the feature request is actually, a monospace font for textarea.
02:29:36 <lambdabot> Consider it noted.
02:29:45 <yitz> @hoogle <$$>
02:29:45 <lambdabot> Text.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
02:29:45 <lambdabot> Text.ParserCombinators.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
02:29:57 <merijn> Catnaroek: I *always* declare explicit types on the top level to figure out what I'm doing before I write the code
02:30:45 <yitz> Catnaroek: it often gives you simpler error messages from GHC, too.
02:31:17 <merijn> Catnaroek: And the type is not that complex, you normally use "fmap :: Functor f => (a -> b) -> f a -> f b" to deal with values inside a functor (i.e. a list, Maybe, IO, whatever)
02:32:01 <merijn> Catnaroek: In this case I had the problem that the value I had was a Maybe inside a State monad. So I need one fmap to get inside the State and a second to access the value inside the Maybe
02:32:20 <Skola_> what are IntSets used for?
02:32:47 <Catnaroek> merijn: Oh.
02:32:48 <merijn> Catnaroek: If you remove the functor 's and write it out you end up with "(<$$>) :: (a -> b) -> State s (Maybe a) -> State s (Maybe b)"
02:33:12 <Catnaroek> Yes, I see.
02:33:32 <Catnaroek> I'm still a newbie.
02:34:20 <merijn> Catnaroek: You get used to it after a while, and then you get lazy and think "why would I implement this function for one datatype if I can get it for free for all possible datatypes"
02:35:00 <Catnaroek> I have no trouble thinking in terms of making things as generic as possible.
02:35:08 <Catnaroek> I understand typeclasses.
02:35:55 <Catnaroek> And I (think I) understand monads. I just have never used the State monad.
02:35:55 <Skola_> Is IntSet faster than a list of ints for certain computations?
02:36:57 <merijn> Catnaroek: Then sign that you understand monads is the moment you realise there's just not that much to get. :p
02:38:08 <merijn> Skola_: Yes, the complexity of checking for membership of a list is O(n), set O(log n), IntSet O(min(n, W)) (where W is the width in bits of a machine word)
02:38:56 <shachaf> merijn: In other words, O(1)
02:39:00 <shachaf> because W is 1.
02:39:06 <shachaf> ∎
02:39:41 <Skola_> how about insertion?
02:39:49 <merijn> shachaf: That's what I thought, yes. But the docs specifically write "O(min(n, W))", so I figured I'd not change it :p
02:40:01 <merijn> Skola_: The Documentation lists complexity for all operations
02:40:19 <Skola_> okay, thanks : }
02:41:10 <Peaker> merijn, if you're going to include the cost of comparing a single item in there as O(W) instead of O(1), then membership in a list is O(n*W),  IntSet cannot be O(n) if there's one long item
02:41:36 <merijn> Catnaroek: The state monad just carries additional state, it's kinda similar to rewriting all your functions from "a -> b" to "(a, s1) -> (b, s2)" to pass state in and out of multiple functions without having to write a lot of boilerplate
02:42:05 <shachaf> merijn: Where a,b,s1,s2 are values, not types. :-)
02:42:17 <shachaf> Typewise it would be "a -> b" -> "(a,s) -> (b,s)"
02:42:46 <Catnaroek> merijn: So it's almost like syntactic sugar?
02:42:54 <Catnaroek> Well, not syntactic.
02:42:58 <Catnaroek> Library sugar.
02:43:30 <shachaf> Uh-oh.
02:43:36 * shachaf just read more context.
02:43:45 <shachaf> Catnaroek: "understanding monads" is the wrong goal.
02:43:50 <shachaf> Did you read the FAQ?
02:43:52 <shachaf> @where faq
02:43:52 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
02:44:23 <merijn> Catnaroek: Well, yes
02:45:08 <merijn> Catnaroek: It's functional sugar for passing "global" (well, more like "local for multiple functions") state around
02:45:25 <Catnaroek> shachaf: What's so difficult to understand about sequential computations that can be "chained", and each of whose "steps" yields a value?
02:45:38 <merijn> Catnaroek: You'd be amazed :)
02:45:55 <shachaf> Catnaroek: Monads aren't about sequential computations.
02:45:59 <merijn> Catnaroek: It's not mutable, thus pure. It just stops you from having to write a lot of boilerplate to access and update the information
02:47:06 <merijn> Catnaroek: The wikibook shows how to implement State from scratch, it's fairly easy to follow: https://en.wikibooks.org/wiki/Haskell/Understanding_monads/State
02:48:41 <Catnaroek> shachaf: So it's just an interface that, *for some concrete types* can be interpreted as I said, but for other types could mean something entirely different?
02:49:14 <shachaf> More or less.
02:50:42 <Catnaroek> Is there any other monad type (other than Maybe) for which (>>=) means something that cannot be interpreted as "chaining" two sequences into a longer one?
02:51:25 <quicksilver> if you interpret 'chaining' and 'sequences' as sufficiently general abstract notions you will be able to shoe-horn anything into that model
02:51:31 <blackdog> Catnaroek: what stops you interpreting Maybe as chaining?
02:51:35 <shachaf> You can always use that interpretation but sometimes it doesn't help very much.
02:51:49 <quicksilver> but the list monad is another good example in which the intuitive sense is not much about sequentiality.
02:51:51 <shachaf> What quicksilver said.
03:00:22 <teneen> Can ghci run parallel code?
03:01:08 <dmwit> yes
03:01:39 <teneen> using par and pseq? Does it detect the number of cores automatically?
03:02:12 <dmwit> You may use +RTS -N to detect the number of cores automatically or +RTS -Nn to use exactly n cores.
03:02:49 <teneen> I didn't know that there as +RTS option for ghci
03:05:39 <dmwit> Well, it's written in Haskell, so...
03:12:38 <kuribas> Is there a function to extract part of an array?
03:14:42 <dmwit> kuribas: Like, slices? Depends which array library you're talking about.
03:14:43 <Jaak> maybe ixmap?
03:14:44 <QinGW> hi
03:14:47 <Catnaroek> Is (>>=) somewhat like applying a (IO / list / Maybe / etc.) homomorphism?
03:15:10 <kuribas> dmwit: Data.Array
03:15:12 <Jaak> @type ixmap
03:15:14 <lambdabot> forall i j e. (Ix i, Ix j) => (i, i) -> (i -> j) -> Array j e -> Array i e
03:15:32 <dmwit> Then, yes, probably ixmap is the closest you can get.
03:15:42 <kuribas> Is it efficient?
03:15:51 <dmwit> Catnaroek: What's an (IO / list / Maybe / etc.) homomorphism?
03:16:03 <dmwit> Catnaroek: Do you mean an arrow in the Kleisli category, or...?
03:16:26 <Catnaroek> No, wait, no. It doesn't have to be an homomorphism, because it doesn't not necessarily map the identity onto the identity.
03:16:44 <dmwit> I think you've got your terminology a bit confused.
03:16:49 <meric> I wrote a averaged perceptron implementation but it is so slow………… Can anyone see any obvious problems with it? http://hpaste.org/67964
03:16:51 <Jaak> you might be thinking of a functor then`?
03:17:03 <t7> has anyone here ever messed about with compiling a lambda calc down to c?
03:17:20 <dmwit> meric: Perhaps you should do some profiling. Do you know how?
03:17:34 <Jaak> you might look at the spj paper on implementing STG
03:17:36 <dmwit> t7: GHC used to do this.
03:17:43 <dmwit> Jaak++
03:17:52 <meric> dmwit: I've heard of Criterion… but I haven't used it before. Can it show like how much time was spent in what function?
03:18:06 <_flow_> xmonad
03:18:12 <dmwit> Criterion is for benchmarking, which is not the same as profiling.
03:18:13 <Jaak> http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/
03:18:24 <meric> Oh, then I don't know how...
03:18:27 <dmwit> meric: see http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/profiling.html
03:18:37 <meric> Thanks!
03:19:14 <t7> bitonic: where did you read how to compose substitutions in HM? is it just a common sense thing?
03:20:01 <bitonic> t7: my lecture notes worked more or less like that, I think I got the actual combinators from "Typing Haskell in Haskell"
03:20:29 <t7> the wikipedia article has no mention of it
03:20:38 <t7> :|
03:20:59 <bitonic> t7: what wikipedia article?
03:21:01 <t7> there should be a programmerpedia
03:21:11 <t7> http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner#Algorithm_W
03:21:11 <bitonic> there should.
03:21:50 <bitonic> t7: I think it's because they're not using substitutions but references
03:22:38 <bitonic> t7: which is the more efficient way, you can check the two-level recursive types paper for a unification algorithm for types in the ST monad
03:22:45 <bitonic> but substitutions are nicer
03:23:01 <t7> unification in place?
03:24:53 <bitonic> t7: i'm not sure what you mean by "in place"
03:26:06 <t7> like destructive updating... i duno
03:26:13 <bitonic> t7: yes
03:26:17 <t7> im gonna read the original paper :)
03:26:52 <meric> Where can I find profiling libraries for a given package? I'm getting this message: "Perhaps you haven't installed the profiling libraries for package `vector-0.9'?"
03:27:27 <dmwit> cabal install --enable-profiling
03:27:28 <scopedTV> meric: cabal install -p bla
03:27:39 <meric> awesome
03:27:39 <dmwit> or set it permanently in ~/.cabal/config
03:27:42 <scopedTV> meric: enable library-profiling in ~/.cabal/config and never experience this problem again.
03:27:51 <meric> thanks~
03:27:57 <meric> (!)
03:28:39 <fmap> Does enabled profiling still require world reinstall?
03:28:53 <scopedTV> Yes.
03:31:47 <jostepson> Hello. I have a simple library that passes around some state. Should I use the state monad, or should i write my own monad to do the same thing? I ask because I think if I use the state monad, do I provide for a leaky abstraction where the user could call put and get themselves and modify the internal state
03:31:49 <bitonic> t7: what original paper? Milner's?
03:32:11 <t7> yeah
03:32:14 <t7> milner damas
03:32:36 <Saizan> jostepson: you can newtype-wrap the State monad if you want to hide that
03:32:39 <bitonic> jostepson: you should use transfomers' State monad if you need one, if you want to hide stuff wrap it in a newtype or do not expose functions
03:33:00 <t7> bitonic: i wanna make a staticly typed scripting language for embedding in applications and games
03:33:07 <t7> safer than python / lua etc
03:33:19 <bitonic> t7: I'm not sure that's the best thing, there are tons of good treatments of HM
03:34:43 <t7> yeah i have read a few but i still have some questions
03:35:25 <jostepson> Saizan: thanks
03:35:28 <jostepson> bitonic: thanks
03:39:03 <galia> hello
03:39:07 <t7> they gave me an ethernet cable with only 4 contacts...
03:39:41 <galia> why d'u use haskell?
03:40:14 <scopedTV> Because of the strong and static type system, functions are first-class values, it's quite efficient, and it is pleasant to use.
03:40:36 <galia> why is it functional?
03:41:49 <t7> because functions
03:42:02 <t7> first class values
03:42:05 <scopedTV> "functional" means that it's based on functions instead of mutating state
03:42:15 <galia> hmmm
03:42:36 <scopedTV> in C you would write unsigned n = 1; for (i = 1; i <= n; i++) n *= i;
03:42:51 <scopedTV> you are constantly changing the state as to obtain some result
03:42:59 <galia> yep
03:43:01 <scopedTV> in Haskell you write fact 0 = 1; fact n = n * fact (n-1)
03:43:08 <galia> and what d'u do?
03:43:24 <galia> oops
03:43:37 <galia> it must be fun
03:43:48 <galia> where is it used?
03:43:57 <scopedTV> we write equations/definitions, basically.
03:44:07 <scopedTV> instead of commands
03:44:22 <scopedTV> I use it to do some stuff in computational geometry.
03:44:32 <galia> wow
03:44:33 <scopedTV> darcs is a revision control system.
03:44:40 <kuribas> Has anyone used haskell DSP?
03:44:41 <scopedTV> xmonad is a windows manager that I use.
03:44:49 <scopedTV> window*
03:45:01 <scopedTV> GHC is a Haskell compiler written in Haskell.
03:45:19 <scopedTV> there are three web frameworks, all with a different focus, that allow you to write web applications in Haskell.
03:45:21 <galia> how is haskell\ compiled?
03:45:34 <scopedTV> most people use GHC, the Glasgow Haskell Compiler.
03:45:52 <scopedTV> but there's also an interpreter and a REPL (like in Python, Ruby, lisps)
03:45:59 <galia> is haskell a reall alternative to C, i wonder.....
03:46:19 <scopedTV> haskell is very different from C, but it can link to C libraries quite easily.
03:46:26 <alpounet> kuribas, just tried it, i may need it at some point
03:46:49 <kuribas> alpounet: What was your idea about the efficiency?
03:46:55 <scopedTV> it's quite fast but not as fast as C (check out the "language shootout" for some benchmarks)
03:47:48 <scopedTV> C is quite low-level, Haskell is very high-level.
03:48:19 <galia> <scopedTV> I can see it...
03:48:30 <alpounet> kuribas, correct, but it probably would benefit a bit from using vector and/or hmatrix i think
03:48:50 <scopedTV> I use both Haskell and C, but prefer Haskell if possible.
03:49:03 <galia> would be nice to know the area it is best applied to...like y've said geometry... may be
03:49:09 <scopedTV> C only if I really need the best performance possible.
03:50:04 <galia> <scopedTV> are u a student or d'u work with haskell?
03:50:11 <scopedTV> both, at the moment.
03:51:17 <galia> hmmm... I wouldn't mind to implement it at work too... i work with gui at C#
03:51:19 <scopedTV> Haskell is not a good choice if there are certain .NET, Java or C++ libraries you need to link to.
03:51:32 <scopedTV> C libraries are no problem at all, C++ are quite a pain
03:53:16 <galia> <scopedTV>, thank you .... I was here to get a quick glance at lessons :)
03:53:33 <scopedTV> The best resource for beginners is LYAH I think.
03:53:34 <scopedTV> @where lyah
03:53:34 <lambdabot> http://www.learnyouahaskell.com/
03:55:19 <galia> how about write our own haskell
03:55:21 <galia> ))
03:55:28 <galia> must be fun
03:55:51 <galia> Aho will help me
03:56:11 <ment> or Ullman
03:56:20 <galia> yep
03:56:41 <galia> will u join?
03:57:42 <ment> galia: sure
04:07:47 <merijn> @pl \f g x -> f x &&& g x
04:07:48 <lambdabot> liftM2 (&&&)
04:09:19 <navaati> hi
04:09:23 <scopedTV> hi navaati
04:13:55 <yitz> merijn: or liftA2
04:17:40 <hiptobecubic> this monadic repa thing is pretty annoying
04:18:04 <hiptobecubic> If you decide, for example, that you want to use sumS instead of sumP, suddenly it's no longer monadic and now you have to change everything
04:19:40 <ment> hiptobecubic: repa?
04:19:49 <hiptobecubic> the parallel array library
04:19:54 <hiptobecubic> Data.Array.Repa
04:20:30 <ment> oh
04:26:32 <t7> i wish there was a decent haskell to javascript compiler that worked on windows
04:28:43 <Dtgr> that would be awesome :p
04:34:57 <merijn> I'm shadowing a Prelude function in my module, so I have "import Prelude hiding (lookup)" at the top. Is it still possible to somehow get acces to it using Prelude.lookup? If so, how? Do I just put an "import qualified Prelude (lookup)" above it>
04:35:06 <scopedTV> yes
04:35:14 <scopedTV> or without the (lookup)
04:35:33 <scopedTV> or below.
04:38:02 <vezyr> Can someone please explain to me what (->) really is?
04:38:13 <vezyr> Is it a type constructor?
04:38:18 <scopedTV> yes
04:38:18 <merijn> Yes
04:38:33 <ion> I tend to use something like import Prelude hiding (blah); import qualified Prelude as P; so i get to refer to it as P.blah
04:39:07 <vezyr> So type constructors behave like operators if they are composed of special characters ?
04:39:16 <scopedTV> no -> is quite special
04:39:34 <merijn> You can have infix type constructors/type operators by prefixing with :
04:39:42 <merijn> Although that might need an extension?
04:39:46 <scopedTV> No, it doesn't.
04:40:25 <merijn> Or wait, was that infix constructors instead of type operators? I confused myself
04:40:45 <scopedTV> definitely constructors, dunno about type oeprators
04:41:08 <vezyr> So actually when I have function signatures like :: a - > b it is equivalent to :: ((->) a b), is that correct?
04:41:13 <scopedTV> Yes.
04:41:22 <vezyr> merijn: I think what you say is true for value constructors
04:41:45 <merijn> vezyr: Yeah, I think I was confused for a bit there
04:42:26 <vezyr> I am sorry for all those stupid questions but somehow (->) really confuses me and shutters my very existance :)
05:07:20 <t7> if i have the subs     a :-> b       and       b :-> c     what is there composition?    a :-> c  and  b :-> c  ?
05:07:26 <t7> bitonic: ^
05:08:55 <hpaste_> hiptobecubic pasted “<<loop>>” at http://hpaste.org/67965
05:09:19 <hiptobecubic> Can anyone tell me why this program outputs  "<<loop>>" instead of printing the result?
05:12:19 <hpaste_> hiptobecubic annotated “<<loop>>” with “<<loop>> (annotation)” at http://hpaste.org/67965#a67966
05:13:44 <hiptobecubic> I can't search for it because has decided that no one ever wants to search for queries with punctuation
05:13:50 <hiptobecubic> because google*
05:14:31 <Botje> hiptobecubic: it means your program has an infinite loop somewhere
05:14:37 <Botje> like f = f somewhere
05:14:57 <hiptobecubic> how would it know?
05:15:12 <Botje> let m = m / fromIntegral n
05:15:15 <hiptobecubic> and if it does, why doesn't it say so at compile time instead of building a worthless program as if that's what i wanted?
05:15:16 <Botje> you can't do that, dave.
05:15:31 <Botje> because it's not usually that simple :)
05:15:37 <Botje> change that to let m' = m / ...
05:15:40 <Botje> and the same for the v
05:15:58 <hiptobecubic> Botje, ugh, yes. They had ' on the end at one point and i deleted them somehow apparently
05:16:00 <hiptobecubic> thanks
05:16:08 <Botje> it knows because it's reducing the graph for m and suddenly it encounters m again.
05:16:25 <hiptobecubic> It can't see that at compile time?
05:16:47 <Botje> no, because let m = 1 : m is perfectly valid
05:17:20 <hiptobecubic> ah ok
05:17:31 <Botje> another nasty case is f 0 n = f 0 (n+1)
05:17:44 <Botje> that will never stop, but ghc can't know that
05:20:17 <hiptobecubic> hm
05:20:30 <hiptobecubic> I seemed to have ruined all of my loop fusion by switching to repa
05:22:25 <aib> so what happens if I write a Haskell program to loop when a program terminates but to terminate if it sees "<<loop>>" and feed that program to itself?
05:22:49 <scopedTV> singularity!
05:23:36 <merijn> aib: You invalidate most of our current CS knowledge and become famous for eternity
05:24:25 <aib> do I get a Turing award or a lawsuit from Oracle?
05:24:54 <nand`> first the second; then the first (and the second is thus hastily withdrawn)
05:31:16 <merijn> Given "data Foo = forall b . b" there's no way to do something with the data inside Foo, right?
05:31:59 <hpc> merijn: no
05:32:15 <merijn> Ok, that's the answer I was hoping for :p
05:32:49 <merijn> Actually, that depends on whether you meant "no, you can't do anything with it" or "no, that's not right"
05:32:51 <hpc> well, maybe
05:33:04 <hpc> if you were a horrible person, you could unsafeCoerce it to get the data out
05:34:12 <merijn> Okay, let's be more concrete "data Dict = forall a b . (Eq a) => [(a,b)]" (or Map a b, whatever)
05:34:30 <merijn> I will always have to have both a b in my type signatures, right?
05:35:37 <hpaste_> hpc pasted “your data type” at http://hpaste.org/67967
05:36:49 <hpc> in your Dict example, the list HAS TO BE of type (forall a b. (Eq a) => [(a, b)])
05:36:51 <merijn> hpc: My main problem is defining generic functions over Map's/whatever becomes very ugly as all resulting functions also parametrise over both Map arguments
05:38:00 <merijn> I was just wondering if I could hide that verbosity/complexity from the types
05:39:04 <hpc> dunno
05:39:12 <hpc> my brain doesn't do higher rank types
05:39:51 <womb> @quote hpc
05:39:51 <lambdabot> hpc says: Cale: where is your internet, and how is it more interesting than mine
05:39:52 <hpc> not intuitively, at least
05:43:34 <aleator> Hello! Can anyone point me to an example where definition of fmap satisfies the first functor law, but not the second?
05:45:49 <hpc> aleator: i can't think of one
05:46:39 <aleator> hpc: Neither can I without some means of identifying id, which isn't possible.
05:47:01 <aleator> Thus I'm bit lost on why it exists.
05:47:12 <hpc> it's from the theoretical definition
05:47:34 <hpc> and "i can't think of one" isn't really a proof that one law subsumes the other ;)
05:47:44 <hpc> it could still matter in categories that aren't (->)
05:47:58 <hpc> though that's not relevant for the standard Functor class...
05:48:23 <aleator> Well, I can easily think of some examples in Set, but in just haskell?
05:48:57 <hpc> in plain haskell, i don't think so
05:49:10 <hpc> you can actually trick Set into being a Functor with ConstraintKinds
05:49:19 <hpc> which does make that second law importan
05:49:20 <hpc> t
05:49:56 <hpc> class Functor c f where fmap :: c a, c b => the usual type
05:50:02 <hpc> (or something like that)
05:50:29 <aleator> Wait.. I meant set as in 'category of'
05:50:49 <hpc> ah
05:50:54 <aleator> If there is a constraint on Functor class, then it might actually matter
05:51:46 <aleator> Ie. Eq constraint and fmap f (Just x) | f x == x = Just x | otherwise = bonkers
05:51:54 <romildo> How do I write the following do expression in applicative style?
05:51:55 <hpc> indeed
05:51:56 <romildo> do l <- pArit; pToken "="; r <- pArit; return E l r
05:52:03 <aleator> hpc: Thanks!
05:52:09 <aleator> Didn't think of this.
05:52:15 <hpc> romildo: E <$> pArit "=" <*> pArit
05:52:25 <hpc> @src liftA2
05:52:25 <lambdabot> liftA2 f a b = f <$> a <*> b
05:52:31 <hpc> (liftA2 == liftM2)
05:52:35 <hpc> @src liftM2
05:52:36 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
05:52:41 <t7> @pf (\ a b -> f a ++ b)
05:52:42 <lambdabot> Maybe you meant: bf pl
05:52:47 <t7> @pl (\ a b -> f a ++ b)
05:52:47 <lambdabot> (++) . f
05:54:00 <romildo> hpc, there is separate action pToken "=" which was not take into account.
05:54:45 <romildo> Would it be: E <$> pArit <* pToken "=" *> pArit
05:54:48 <aleator> pToken "=" *>  pArit
05:54:54 <aleator> Bah :) Too slow :)
05:56:13 <hpc> romildo: oh
05:56:22 <hpc> yeah, something like that
05:57:06 <hpc> @hoogle (<.>)
05:57:07 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
05:57:07 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
05:57:13 <hpc> hmm
05:57:31 <sgronblo> how do I use guards with a function defined in a where?
05:57:45 <sgronblo> I'm getting parse error in pattern
05:57:55 <hpc> foo = bar
05:57:59 <hpc>  where
05:58:04 <mauke> sgronblo: show code
05:58:16 <hpc>   bar | quux == schnoz = zipple zopple
05:58:29 <hpc>       | otherwise = zazzle frazzle ropple stopple
05:58:50 <mauke> http://cosbybebop.ytmnd.com/
05:59:12 <sgronblo> all right, gimme a second
05:59:12 <hpc> oh my
06:00:26 * hackagebot vault 0.2.0.0 - a persistent store for values of arbitrary types  http://hackage.haskell.org/package/vault-0.2.0.0 (HeinrichApfelmus)
06:00:27 * hackagebot reactive-banana 0.5.0.3 - Practical library for functional reactive programming (FRP).  http://hackage.haskell.org/package/reactive-banana-0.5.0.3 (HeinrichApfelmus)
06:00:52 <mauke> > banana  > apfelmus
06:00:53 <lambdabot>   Not in scope: `banana'Not in scope: `apfelmus'
06:02:01 <aleator> hpc: fmap f (Foo x) = f `seq` Foo (f x) breaks law #2 and not #1.
06:02:03 <t7> @hoogle StateT
06:02:04 <lambdabot> Control.Monad.State.Lazy StateT :: (s -> m (a, s)) -> StateT s a
06:02:04 <lambdabot> Control.Monad.State.Strict StateT :: (s -> m (a, s)) -> StateT s a
06:02:04 <lambdabot> Control.Monad.Trans.State.Lazy StateT :: (s -> m (a, s)) -> StateT s m a
06:02:20 <hpc> aleator: oh, totally forgot about seq! excellent
06:02:39 <sgronblo> http://pastebin.com/GpUEW9zQ
06:02:41 <mauke> The paste GpUEW9zQ has been copied to http://hpaste.org/67968
06:03:01 <mauke> sgronblo: indentation
06:03:10 <aleator> hpc: I cheated. Thats from Stack (hammar).
06:03:16 <sgronblo> What's wrong with it?
06:03:19 <mauke> sgronblo: the base indentation of the 'where' block is determined by the token after 'where': '_format'
06:03:47 <sgronblo> mauke: oh
06:03:56 <hpc> sgronblo: generally what people will do with where blocks is indent the "where" halfway, then on a new line indent everything else the rest of the way
06:04:04 <mauke> basically, start a new line after 'where' and you're set
06:04:15 <hpc> or that
06:04:54 <ment> are there any examples of algorithms implemented using Data.Graph?
06:05:24 <sgronblo> Btw, when did you need parentheses around the x:xs? Always?
06:05:44 <mauke> when precedence demands it
06:05:59 <mauke> that's like asking "when do you need parentheses around x+y?"
06:06:14 <sgronblo> Ah ok.
06:06:22 <hpc> that, plus "always, in pattern matches"
06:06:25 <hpc> for mostly the same reason
06:06:33 <mauke> not always in pattern matches
06:06:42 <hpc> usually, in pattern matches
06:06:50 <mauke> case ... of ([], x : xs) ->
06:07:04 <hpc> that's a wonky edge case
06:07:17 <hpc> tuples are the darkest parsing evil i have ever seen
06:07:19 <mauke> case ... of Flerp{ twinkies = x : xs } ->
06:07:30 <hpc> that i will accept ;)
06:07:37 <mauke> case ... of [x : xs] ->
06:08:08 <ion> case ... of "x : xs" ->
06:08:16 <hpc> lol
06:08:56 <mauke> don't make me pull out {- -}
06:09:17 <ion> hpc: I take it you haven’t seen the articles about some insane stuff the language that shall not be named does when parsing e.g. numbers? :-)
06:09:35 <ion> Re: darkest parsing evil
06:09:41 <hpc> oh, i have seen that
06:09:45 <hpc> but it's par for the course in php
06:09:52 <hpc> haskell should KNOW BETTER
06:12:41 <jophish> yo yo yo
06:12:54 <mauke> coyoyo
06:13:02 <jophish> exactly
06:13:12 <jophish> I was wondering what (*) means in a function declaration
06:13:21 <jophish> f (*) a b c = something
06:13:38 <mauke> it means the first parameter is called *
06:13:45 <jophish> oh blimey
06:13:48 <jophish> thanks
06:14:24 <hpc> @src on
06:14:25 <lambdabot> (*) `on` f = \x y -> f x * f y
06:15:03 <hpc> > let modTwo = (==) `on` div in modTwo 4 5
06:15:04 <lambdabot>   *Exception: (==): No overloading for function
06:15:16 <hpc> > let modTwo = (==) `on` (`div` 2) in modTwo 4 5
06:15:17 <lambdabot>   True
06:15:20 <hpc> ha!
06:15:50 <int-e> evil.
06:16:41 <int-e> > let modTwo = (==) `on` (`mod` 2) in modTwo 4 5
06:16:42 <lambdabot>   False
06:16:51 <t7> bloody american english
06:18:20 <yitz> t7: what did we do this time?
06:18:33 <t7> 'generalize'
06:18:59 <yitz> newtype deriving?
06:20:19 <hpc> "jineruleyes"
06:20:21 <t7> @hoogle zipM
06:20:22 <lambdabot> Control.Monad mapAndUnzipM :: Monad m => (a -> m (b, c)) -> [a] -> m ([b], [c])
06:21:01 <t7> whats the infix for fmap?
06:21:08 <hpc> (<$>)
06:21:08 <yitz> <$>
06:21:09 <ion> <$> or `fmap`
06:21:21 <saml> what's type Foo a    mean?
06:21:57 <saml> or   type Foo a = a -> Bar
06:22:10 <ion> That creates a type alias.
06:22:27 <ion> Foo a and a -> Bar can be used interchangeably.
06:23:34 <saml> oh i dindn't know type can have type variable
06:25:49 <aleator> Gah. I'm trying to revise my lecture on Functors&co and I can't think of any great examples of them.
06:26:00 <mm_freak_> t7: are you still working on your language?
06:26:19 <bitonic> aleator: I hope you included the canonical burrito example
06:26:32 <aleator> bitonic: I thought that was about monads :)
06:26:46 <t7> mm_freak_: im working on Hindley milner inferred typed language now
06:27:14 <bitonic> aleator: every monad is a functor
06:27:29 <mm_freak_> t7: so no dependent types?
06:27:56 <t7> nah, i want joe average to be able to use it
06:28:49 <mm_freak_> t7: i see, ok
06:29:02 <mm_freak_> well, regardless…  locally nameless is great…  if you haven't, you should try it
06:29:19 <t7> is that the mix of identifiers and de bruijn ?
06:29:34 <saml> is functor same as ocaml functor?
06:29:36 <mm_freak_> that's basically a strong separation of bound (index) and free (name)
06:29:50 <mm_freak_> here is the identity function:  lambda (return Typ) $ \ta -> lambda (return ta) $ \x -> return x
06:30:09 <mm_freak_> without types it would be:  lambda $ \x -> return x
06:30:49 <mm_freak_> it uses indices internally, but allows you to write all of your code without them
06:30:53 <bitonic> saml: no
06:31:14 <t7> wtf
06:31:17 <t7> how
06:31:37 <t7> oh god you use functions in your data types?
06:31:46 <mm_freak_> no =)
06:31:56 <mm_freak_> http://namebinding.wordpress.com/2009/10/14/i-am-not-a-number-im-a-free-variable/
06:32:06 <hpc> haha
06:32:35 <mm_freak_> t7: the expression type doesn't change at all, except that you add another constructor 'Free' that takes a name instead of a number
06:32:55 <t7> and helper functions for constructors?
06:33:02 <aleator> Ok. I offer one tip of the hat to anyone who can give me a 'wow' example on why Functors are cool.
06:33:10 <mm_freak_> yeah, smart constructors…  you don't /need/ them, but it's nice to have them
06:33:12 <mauke> inb4 loeb
06:33:52 <bitonic> aleator: Functors are not the kind of thing you can do youtube pitches on :P
06:33:59 <bitonic> they're just a useful abstraction
06:34:06 <mm_freak_> t7: the idea is that you have an "open" expression like "x" and you have a "close" function that turns the free variable into a bound one:  \0
06:34:33 <aleator> bitonic: I know. I just need to get them through to people who historically are a bit critical on anything new :)
06:34:46 <mauke> new?
06:34:58 <aleator> (new to them)
06:35:10 <bitonic> aleator: there are plenty of introduction to Functors. the best I've seen is the one in LYAH
06:36:45 <aleator> bitonic: Yeah. I liked it quite much as well. However, the students did complain (after hopefully reading lyah) that they found out what a functor is but not why it is useful. You can probably see why I'm bit lost here :)
06:36:53 <xplat> cabal: dependencies conflict: ghc-7.0.3 requires pretty ==1.1.1.0 however pretty-1.1.1.0 was excluded because ghc-7.0.3 requires pretty ==1.0.1.2
06:36:56 <xplat> wat
06:37:09 <bitonic> aleator: what kind of students?
06:37:30 <aleator> bitonic: university, ranging from early bachelor to late masters.
06:38:23 <bitonic> aleator: uhm. http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Functor.html there are 15+ instances of Functor here
06:39:02 <xplat> does anyone know what could be causing cabal to do that?
06:39:18 <bitonic> aleator: I would even say that most ADT of kind "* -> *" are functors.
06:39:50 <aleator> bitonic: True. Perhaps my problem is not at explaining functors but explaining why it is nice to have abstractions..
06:39:53 <xplat> bitonic: it might be less 'what things are functors' and more 'why do i care' though
06:40:08 <bitonic> xplat: that is a broader discsussion
06:40:10 <bitonic> aleator: yeah.
06:40:17 <bitonic> which is what xplat is saying in other words
06:40:54 <xplat> well i was more aiming at 'why is something as simple as functor a nice abstraction, it doesn't seem to capture much'
06:41:23 <ocharles> aleator: the why is that 15+ instances out of the box
06:41:41 <ocharles> the ability to already have a ton of things you can do merely by being an instance of Functor is quite a wow to me
06:41:54 <ocharles> "oh, so all those patterns I already learnt just work with this? that's cool!"
06:42:01 <Eduard_Munteanu> aleator: it might help if you explain it as a generalization of 'map'
06:42:12 <Eduard_Munteanu> (among other things)
06:47:13 <aleator> ocharles: Hey. That was smartly said. Thanks!
06:47:42 <aleator> ie. "You know map. It works for lists. There is fmap. It works for pretty much everything"
06:49:33 <alpounet> aleator, you can also make them implement a few functions that would just be a dumb fmap, but without the fmap, and then make them realize it's always the same pattern, may it be with IO, Maybe, [], ... and that they all are just fmap something val
06:50:54 <aleator> alpounet: Yeah. That'd be good also. Main problem is finding enough smart examples.
06:50:58 <mm_freak_> byorgey: the stacked name approach is indeed better, because you don't need a state monad
06:51:03 <aleator> But I'll try to have something like that
06:54:35 <mm_freak_> aleator: there are different flavors of functors…  there are containers, functions, abstract actions, etc.
06:54:41 <mm_freak_> pick one from each flavor
06:55:34 <mm_freak_> from the context i inferred that you are teaching functors
06:56:00 <aleator> mm_freak_: Yeah. Or planning to next fall. Just trying to address the biggest criticisms of the previous course.
06:56:17 <aleator> mm_freak_: abstract action? IO?
06:56:49 <Eduard_Munteanu> That's not really a great functor.
06:57:14 <merijn> hmm
06:57:26 <sgronblo> Having trouble figuring out how to run my quickcheck property by using runhaskell somehow
06:57:30 <t7> @hoogle m a -> m b -> m (a, b)
06:57:31 <lambdabot> Data.Sequence zip :: Seq a -> Seq b -> Seq (a, b)
06:57:31 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
06:57:31 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
06:57:50 <Eduard_Munteanu> :t zipWithM
06:57:50 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
06:57:52 <sgronblo> Apparently you can load your property file and Test.QuickCheck in prelude and do quickCheck property
06:58:08 <merijn> If I'm using a mapLens the result is Maybe, is there a way to further focus inside the Maybe? (i.e. the value inside the Maybe has field that I want to access using lenses)
06:58:08 <sgronblo> But can't I use some function in a main = do or something?
06:58:16 <Philonous> :t liftA2 (,)
06:58:18 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
07:02:07 <merijn> I guess I'm essentially looking for a way to abstract this pattern: "(someMap ^. mapLens "a") >>= (^. someLens)"
07:03:00 <t7> is it possible to lazy create a list of Monadic values?
07:03:41 <mauke> > repeat getLine
07:03:42 <lambdabot>   [<IO [Char]>,<IO [Char]>,<IO [Char]>,<IO [Char]>,<IO [Char]>,<IO [Char]>,<I...
07:04:07 <mm_freak_> aleator: yes, IO is an abstract action with no ADT representation (although you can certainly make one)
07:04:34 <mm_freak_> aleator: my approach to this was to explain folds for ADTs and derive functors from folds
07:05:10 <mm_freak_> fmap f = fold (A . fmap f) (B . fmap f) (C . f)
07:05:21 <ocharles> t7: I assume you want something that is IO [a], but "take 5" would only do enough work to take 5 elements?
07:05:29 <ocharles> or words to that effect
07:05:40 <t7> yes#
07:05:46 <t7> instead of replicateM
07:05:55 <ocharles> look into conduits, pipes, enumerator, and other stuff
07:06:08 <aleator> mm_freak_: Hmm. That is interesting. How did it pan out?
07:06:33 <mm_freak_> aleator: a good treatment of folding did the trick…  and you get the laziest possible fmap for free
07:06:56 <mm_freak_> aleator: define lists and a few operations for them
07:07:19 <mm_freak_> show how the operations are structurally similar and ask how one could capture the /structure/ of the operation (introducing "combinators")
07:07:59 <aleator> mm_freak_: I was so focused on the thought that functors are simplest so they should go first, that I didn't really consider doing it that way before.
07:08:21 <mm_freak_> aleator: well, functional programming is about combinators and compositions
07:09:17 <aleator> mm_freak_: Sure, I tried to lure people to combinators with <$>, . , and <*>
07:09:41 <aleator> mm_freak_: Silly question. Did you cover (ordinary) folds before map?
07:10:11 <mm_freak_> aleator: no, mapping was one of the operations whose structure i analyzed for right-folding of lists
07:10:16 <merijn> Is there a way I can beat cabal into using newer packages?
07:10:34 <tgeeky> merijn: cabal install package-1.2.3.4
07:10:39 <mm_freak_> aleator: i also established the notion of a "natural" fold, for which you can establish an identity fold
07:10:50 <mm_freak_> for lists the natural fold is foldr
07:11:10 <mm_freak_> and the identity fold is:  foldr (:) []
07:11:18 <merijn> tgeeky: Oh wait, I missed something obvious
07:11:39 <mm_freak_> merijn: forgot to cabal update? =)
07:11:42 <aleator> mm_freak_: And after you had fold for list, you made some for custom data and then moved to functors?
07:11:43 <merijn> No
07:11:51 <merijn> mm_freak_: I misread supported versions
07:11:59 <mm_freak_> aleator: yeah…  trees, streams, etc.
07:12:12 <mm_freak_> after having something to work with i introduced the notion of functors
07:12:12 <merijn> roconnor__: Is there any reason why data-lens-template doesn't/wouldn't work with the newest data-lens version?
07:12:57 <aleator> mm_freak_: Sounds nice approach. Did the students like it?
07:13:06 <mm_freak_> aleator: yeah
07:13:54 <mm_freak_> aleator: btw, it helps not to talk about haskell too much ("lazy", "non-strict", etc.)…  let the intuition develop by itself
07:14:04 <aleator> mm_freak_: Nice! I'm really struggling to keep the dropout below 20%, which means some balancing between boring and too scary :)
07:14:27 <t7> im being stupid, type a = StateT FreshVar (Either TypeCheckError) a      <- does that look right?
07:14:28 <mm_freak_> aleator: watch mzero's video =)
07:14:29 <roconnor__> merijn: not to my knowledge
07:14:45 <mm_freak_> aleator: http://www.youtube.com/watch?v=b9FagOVqxmI
07:14:49 <aleator> mm_freak_: True. There is plenty that you actually don't really need to teach. Syntax is one that people will just get after a while.
07:14:54 <merijn> roconnor__: Any clue how I'd go about forcing cabal into trying to link with newer data-lens versions?
07:15:22 <mm_freak_> aleator: exactly
07:15:46 <mm_freak_> aleator: by explaining those things you risk focussing on Unimportant Details
07:15:52 <mm_freak_> it's better to focus on them later
07:15:54 <aleator> mm_freak_: Sadly, I'm not as fun as mzero, I guess :)
07:16:07 <aleator> mm_freak_: However, I've already stolen that idea: https://github.com/aleator/haskell-amuse-bouche
07:16:19 <mm_freak_> aleator: be fun…  throw some jokes in…  i always start with "haskell is stupid" and show this example:
07:16:24 <mm_freak_> > let 2 + 2 = 5 in 2 + 2
07:16:25 <lambdabot>   5
07:16:28 <mm_freak_> =)
07:16:33 <t7> ignore me
07:16:40 <EvanR> bah humbug
07:17:00 <aleator> mm_freak_: Yeah. One of my TA's did this, by accident, live on the exercises :)
07:17:05 <tgeeky> mm_freak_: just carefully explain that Haskell is smart enough to know about large values of 2 (and even small values of 5!), and it just does the right thing behind the scenes
07:17:34 <mm_freak_> tgeeky: nice one =)
07:17:37 <mm_freak_> i might build on that
07:18:07 <aleator> But anyhow, I'm having a basically minimal lectures and as much exercises as you can physically cram in a single course -approach
07:18:53 <mm_freak_> aleator: don't exaggerate with exercises…  in particular don't make your students feel stupid
07:19:37 <mm_freak_> at the same time you also shouldn't give the feeling that "you're not stupid, it is indeed complicated"
07:19:47 <mm_freak_> because everything you teach is "really simple, just unfamiliar"
07:19:53 <mm_freak_> this is often a difficult tradeoff
07:20:11 <mm_freak_> even the most complicated things are "really simple and you'll see why"
07:20:45 <aleator> mm_freak_: I think we managed quite well on that aspect last year. Making people work in groups with similar level of skill helped much on that account.
07:21:24 <mm_freak_> aleator: i designed my courses like workshops, so we did everything together, but my groups were small…  5-10 people mostly
07:21:51 <aleator> Biggest problems were the lack of synthesis or the formation of the 'bigger picture', not having enough precise examples (which I'm trying to fix right now), plus a really nasty exercise about intersecting rectangles.
07:22:28 <merijn> roconnor__: Well, everything seems to compile and link just fine, so I think I'll just have to kick edwardk to bump the dependency on the packages
07:22:58 <mm_freak_> aleator: yeah, that's why i always teach the idea of combinators and compositions as early as possible…  i always start with basic function application and how the types must fit, then move on to basic I/O to be able to write actual programs (fun factor)
07:23:06 <mm_freak_> after that i go to data structures and algorithms
07:23:42 <merijn> @tell edwardk data-lens-template and data-lens-fd default to an old version of data-lens because of a dependency restriction, but seem to work fine with data-lens-2.10, might be time to bump up the max version?
07:23:42 <lambdabot> Consider it noted.
07:23:59 <aleator> mm_freak_: 5-10? You're lucky! I had this: http://www.dropbox.com/gallery/3575208/1/haskell?h=f6ee4c
07:24:49 <aleator> mm_freak_: I guess I should ask for a bigger classroom next time..
07:26:31 <_mpu> where can I get the list of typeclasses that have an instance for List?
07:27:07 <t7> @hoogle lift
07:27:07 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
07:27:07 <lambdabot> Control.Applicative liftA :: Applicative f => (a -> b) -> f a -> f b
07:27:07 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
07:28:36 <mm_freak_> aleator: my last workshop of that size was about RSA, not haskell
07:29:19 <mm_freak_> but it's still not university lecture-size, so you can still do this on a very personal level
07:29:21 <alpounet> _mpu, in ghci, :info [] gives you a few. i wonder if bringing the appropriate modules (with other instances for [a]) in ghci will add them to that list
07:29:30 <sgronblo> I don't really get how to specify quickcheck properties yet.
07:29:36 <hpc> it will
07:29:39 <t7> @hoogle m a -> StateT s m a
07:29:39 <lambdabot> Control.Monad.Trans.State.Lazy put :: Monad m => s -> StateT s m ()
07:29:40 <lambdabot> Control.Monad.Trans.State.Strict put :: Monad m => s -> StateT s m ()
07:30:24 <t7> do i have to lift here
07:30:29 <t7> i did this before somehow...
07:30:53 <t7> oh
07:30:55 <t7> :|
07:31:14 <sgronblo> Some pages say to use quickCheck and specify the type as like :: Int -> Bool, while other show to use like where _ = s :: Int
07:31:42 <Botje> sgronblo: both work to constrain the types.
07:31:48 <Botje> although the second is nicer.
07:31:56 <Botje> where types = (a,b,c) :: (Int, String, Bool)
07:32:57 <sgronblo> Does quickcheck come with instances of Arbitrary for common datat types too btw?
07:33:39 <scooty-puff> STRef is an instance of Eq, would it be possible to make it an instance of Hashable?
07:34:18 <scooty-puff> i see: casMutVar#, but i have no clue what it does
07:35:22 <Botje> sgronblo: yes
07:35:41 <Botje> scooty-puff: the cas is probably compare and swap
07:36:30 <scooty-puff> ok
07:38:27 <scooty-puff> heh: reallyUnsafePtrEquality#
07:38:49 <Botje> "can you make it .. more unsafe?"
07:39:13 <hpc> phpPtrEquality
07:39:23 <EvanR> damn
07:39:33 <Botje> which either compares pointers or randomly nukes the memory they're pointing at?
07:39:42 <hpc> or both
07:39:42 <sgronblo> Botje: So what if I want to restrict input of ints to be greater than 0?
07:39:55 <Botje> sgronblo: that's where the ==> thing comes in
07:40:04 <sgronblo> Do I need to reimplement Arbitrary Int or do I create a new PositiveInt or something?
07:40:05 <hpc> Botje: for extra fun, add some hard-coded parsing to GHC with subtle bugs relating to that function
07:40:06 <Botje> :t (==>)
07:40:07 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
07:40:22 <Botje> sgronblo: which means you only want inputs that pass the predicate.
07:40:35 <Botje> sgronblo: foo x = x > 0 ==> ...
07:40:47 <Peaker> that can be problematic...
07:41:13 <Botje> or you make a custom Arbitrary instance. or you use Word and fromIntegral it to an Int :)
07:41:13 <Peaker> sgronblo, you can use the ==> approach (which may waste lots of computation), or the newtype/instance approach, or you can use a Gen computation with "forAll"
07:41:18 <Peaker> @hoogle forAll
07:41:19 <lambdabot> Test.QuickCheck.Property forAll :: (Show a, Testable prop) => Gen a -> (a -> prop) -> Property
07:41:19 <lambdabot> Test.QuickCheck forAll :: (Show a, Testable prop) => Gen a -> (a -> prop) -> Property
07:41:19 <lambdabot> keyword forall
07:41:33 <sgronblo> Too many suggestions now :)
07:41:49 <Peaker> sgronblo, the quickest/most flexible is probably the "forAll" function
07:42:41 <sgronblo> Anyway I'm used to Rails tests wasting much more resources than I assume computation does. As in expensive database calls etc.
07:45:35 <sgronblo> So I would use forAll instead of quickCheck?
07:46:15 <Botje> no, forAll constructs a property you can test.
07:47:51 <Peaker> sgronblo, Example: quickCheck (forAll arbitrary (<9))
07:48:07 <Philonous> Are ThreadIds guaranteed to be unique during program runs?
07:48:44 <sgronblo> what's the arbitrary?
07:51:23 <sgronblo> Is that where I put my "truth function"
08:14:25 <t7> whats the default infix mode?
08:15:33 * hackagebot sequor 0.2.3 - A sequence labeler based on Collins's sequence perceptron.  http://hackage.haskell.org/package/sequor-0.2.3 (GrzegorzChrupala)
08:15:43 <merijn> infixl 9
08:16:45 <c_wraith> @info (.)
08:16:45 <lambdabot> (.)
08:16:49 <c_wraith> ...
08:16:58 <c_wraith> I was expecting a bit more than that.
08:17:01 <c_wraith> silly me!
08:21:07 <Botje> huh, so @info doesn't do caleskell? :P
08:21:29 <tgeeky> @src (.)
08:21:30 <lambdabot> (f . g) x = f (g x)
08:21:30 <lambdabot> NB: In lambdabot,  (.) = fmap
08:21:36 <tgeeky> Botje: ^^
08:21:39 <ion> I don’t think i’ve ever seen @info do anything more than repeat the query.
08:22:15 <Botje> tgeeky: that's @src.
08:22:50 <tgeeky> Botje: I was just pointing out the caleskell note is seen in @src
08:23:22 <Botje> ah, definitely.
08:29:48 <t7> hmm
08:30:09 <t7> i think a staticly typed language needs some form of subtyping
08:30:22 <t7> so we can have infix +-*/ for all numbers
08:31:28 <parcs`> recently in ghc: https://github.com/ghc/ghc/commit/ac230c5ef652e27f61d954281ae6a3195e1f9970
08:33:11 <ppseafield> When running Setup.hs build, it says it can't find module `Prelude' and suggests base, haskell98/2010 for my build-depends , but base is in my build-depends. How can I get cabal to see it? If I just use ghc --make, it compiles fine.
08:34:55 <geekosaur> only one of those is present?  (in recent ghc, base, haskell98, and haskell2010 are mutually incompatible and will lead to can't find Prelude because it can't decide which one to use)
08:35:19 <ppseafield> geekosaur: Yeah, I just have base in build-depends
08:36:15 <mun> if a logic is undecidable, does that mean unification is undecidable?
08:42:53 <tgeeky> mun: If I understand you correctly, then [Yes, No] -> [Yes]
08:43:33 <t7> bitonic: have you ever played with constraint based inference?
08:43:43 <t7> rather than substitution
08:45:10 <bitonic> t7: no
08:45:24 <t7> solving the constraints at the end looks hard
08:46:07 <t7> i just did HM again nice and clean in 150 loc. Its sinking in now
08:47:45 <bitonic> good job
08:48:45 <Botje> t7: "gradual typing with unification-based inference" has a very nice algorithm you can steal.
08:50:09 <t7> ah cheers
08:51:17 <Botje> they probably reference a simpler algorithm as well, but I happened to have that one open :)
08:54:09 <t7> i will goto the pub on the way home and read that
08:54:15 <t7> with a nice cold pint
08:54:16 <ment> t7: LOC as in line of c?
08:54:23 <t7> lines of code
08:54:55 <ment> what language though?
08:55:05 <t7> ... haskell
08:59:14 <tromp_> > 1374*0.22
08:59:15 <lambdabot>   302.28000000000003
09:01:20 <Catnaroek> @src fold
09:01:21 <lambdabot> Source not found. Where did you learn to type?
09:01:30 <Catnaroek> @src foldl'
09:01:31 <lambdabot> foldl' f a []     = a
09:01:31 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
09:03:05 <_mpu> @src foldl
09:03:05 <lambdabot> foldl f z []     = z
09:03:05 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:04:03 <plumenator> @src State
09:04:04 <lambdabot> Source not found. That's something I cannot allow to happen.
09:16:32 <xplat> has anyone managed to install ghc-mod lately with ghc 7.0.3?
09:19:10 <suerubic> Can I automatically derive an instance of NFData - seems odd that I can't find one for the very important class that's widely used
09:22:09 <copumpkin> suerubic: most people don't actually use NFData all that much
09:22:22 <copumpkin> there are a couple of packages out there that will derive it for you using template haskell
09:22:26 <copumpkin> but otherwise, not really
09:22:53 <suerubic> copumpkin: i was under the impression it was a crucial part of all the parallelism models
09:23:18 <copumpkin> being able to control what sort of evaluation you want is important
09:23:22 <copumpkin> it isn't always necessarily NF
09:23:33 <copumpkin> and NFData instances are typically fairly easy to hack together
09:24:02 <c_wraith> NFData tends to be the easy-but-inefficient hammer that people use to debug problems, but not to solve them when the bug is found.
09:24:10 <suerubic> copumpkin: ok thanks. is it still best thing to use when i'm sending data structures down a channel and want them fully evaluated?
09:30:02 <augur> paul pietroski's view on natural language semantics makes so much sense now
09:30:05 <augur> <3<3<3
09:30:11 <augur> description logic under the reader monad
09:34:13 <alpounet> xplat, i have it working with 7.4.1, haven't tried with 7.0.3
09:34:56 <hpaste_> nonefool_ pasted “Rewrite rules/data families” at http://hpaste.org/67970
09:35:42 <nonefool_> can somebody explain to me why the rewrite rule in the above past doesn't fire?
09:37:42 <xplat> alpounet: :I
09:38:06 <alpounet> xplat, what issue do you have when installing it?
09:38:25 <xplat> cabal: dependencies conflict: ghc-7.0.3 requires pretty ==1.1.1.0 however pretty-1.1.1.0 was excluded because ghc-7.0.3 requires pretty ==1.0.1.2
09:44:14 <spanner> perl lets us add underscores to numbers for readability, like 100_000_000, which the parser ignores. does haskell have anything like this?
09:44:35 <dmwit> no
09:44:44 <dmwit> but you can write 1e8 =)
09:44:58 <jfischoff> spanner: you could write a quasiquoter to do it
09:45:02 <dmwit> > 1e8 :: Int -- suddenly wondering if that's true
09:45:03 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
09:45:04 <lambdabot>    arising from the lit...
09:45:24 <dmwit> Hah, yes!
09:45:39 <dmwit> [num|100,000,000|]
09:45:45 <dmwit> actually, that is pretty readable looking
09:46:00 <dmwit> jfischoff++
09:46:05 <jfischoff> :)
09:47:04 <jfischoff> There should be way to automatically turn a parsec parser into a quasiquoter (assuming you don't need antiquotes)
09:47:11 <jfischoff> maybe there is ...
09:49:09 <dmwit> jfischoff: You should write a quasiquoter that turns Parsec parsers into quasiquoters...
09:49:15 <dmwit> and use it to bootstrap itself.
09:49:25 <alpounet> xplat, uh, this one's weird... good luck
09:51:02 <jfischoff> dmwit: have you ever played with this? http://hackage.haskell.org/package/BNFC-meta
09:51:43 <jfischoff> dmwit: I wrote a few little expression parsers/quasiquoters with it. Its pretty cool.
09:52:10 <dmwit> neat
09:56:07 <Ngevd> How /does/ one get a Hackage account?
09:56:31 <dmwit> Click "User accounts" and read.
09:56:51 <Ngevd> I sent an email yesterday, haven't got a reply yet
09:56:59 <dmwit> Just wait.
09:57:06 <Ngevd> I'm impatient.
09:57:17 <Ngevd> Aaargh.
09:57:19 <Ngevd> This is annoying
09:57:22 <Ngevd> But I WILL WAIT
09:57:30 <dmwit> =)
09:57:36 * dmwit hands Ngevd a sugar lambda
09:57:51 <hayashi> That reminds me
09:58:20 <hayashi> I should ask for a Hackage account at some point.  Are you supposed to provide evidence of having a ready-made package to upload in the request email?
09:58:21 <hpc> i sent an email last week and didn't get a response
09:58:40 <dmwit> hayashi: You needn't.
09:58:49 <dmwit> hpc: Hm... that's starting to get to the worrying point.
10:00:47 <byorgey> sounds about average.
10:01:30 <byorgey> right now the Hackage Accounts Committee consists of: Ross Paterson.
10:02:02 <jfischoff> what
10:02:14 <jfischoff> s the status of hack age 2
10:02:22 <byorgey> once Hackage 2 goes live the situation should improve a lot, since it has support for account privileges, i.e. there can be multiple people who can administrate accounts.
10:03:37 <byorgey> jfischoff: the status is that there is a live mirror at http://hackage.factisresearch.com/, and (as I understand it) it just needs a bit more work to test everything and do the final migration
10:04:05 <jfischoff> byorgey: super cool
10:08:10 <saml> hey i want to write a static site generator.. how can I track dependencies?
10:08:10 <mcstar> hi! what is this called? "class ShowPred a flag | a->flag where {}" when the | character(guard?) is after the class name?
10:08:20 <hpc> functional dependency
10:08:23 <hiptobecubic> My code using repa is twice as slow as the code using Data.Vector.Unboxed :(
10:08:23 <byorgey> saml: use hakyll.
10:08:32 <hpc> (or fundep)
10:08:34 <saml> if page1 gets updated,  all pages that references page1 will have to be regenerated, too
10:08:46 <mcstar> hpc: read a couple of your posts, bit over my head :)
10:08:46 <saml> i thought hakyll regenerates entire site
10:08:48 <byorgey> saml: yep. hakyll handles all that for you.
10:08:51 <c_wraith> hiptobecubic: are you running on multiple cores? repa is only particularly good when it can actually go parallel
10:08:52 <byorgey> saml: no, it doesn't.
10:08:54 <saml> oh thanks
10:09:16 <saml> i was gonna have each page  a haskell module and ghc handle dependencies
10:09:33 <byorgey> saml: that sounds like a nightmare to maintain.
10:09:40 <hiptobecubic> c_wraith, i have two cores. When I run it on both i get speed close to (but not quite as good as) Vector.Unboxed. When i run Repa on one core it is twice as slow
10:09:43 <saml> :P  EDSL for web pages!
10:09:52 <Ngevd> Can anyone reccommend a graphics library with boxes, lines, and text?
10:09:58 <byorgey> saml: and doesn't work very well when you also have static resources that aren't haskell files.
10:10:04 <hpc> Ngevd: SDL?
10:10:07 <saml> ah i see thanks byorgey
10:10:11 <c_wraith> hiptobecubic: honestly, that doesn't surprise me that much. The people getting good results with repa have been running on 4+ cores
10:10:12 <byorgey> Ngevd: what do you want to do with it?
10:10:25 <mcstar> hpc: so it means, that ShowPred must have a "a->flag" signature?
10:10:35 <mcstar> no it cant be that
10:10:46 <Ngevd> byorgey, I'm planning on making a Data.FamilyTree.Report, which should give you a clue
10:10:48 <hpc> mcstar: it means the type a determines the type flag
10:10:55 <byorgey> saml: more generally, if you want a nice way to track dependencies/do automatic rebuilding in general, use shake
10:11:03 <c_wraith> hiptobecubic: I think it's just a matter of not being nearly as optimized as vector.
10:11:07 <hpc> mcstar: a better example would be MonadReader, perhaps
10:11:13 <byorgey> Ngevd: ah, ok.  Try diagrams.
10:11:16 <byorgey> @where diagrams
10:11:17 <lambdabot> http://projects.haskell.org/diagrams/
10:11:20 <hpc> mcstar: you are writing a website or something, and you have your custom CGI monad
10:11:25 <hpc> you can read GET/POST information
10:11:29 <hpc> and stuff like the IP address
10:11:34 <hpc> @hoogle monadstae
10:11:34 <lambdabot> No results found
10:11:36 <hpc> @hoogle monadstate
10:11:37 <Ngevd> Thanks
10:11:37 <lambdabot> Control.Monad.State.Class class Monad m => MonadState s m | m -> s
10:11:37 <lambdabot> Control.Monad.State.Lazy class Monad m => MonadState s m | m -> s
10:11:37 <lambdabot> Control.Monad.State.Strict class Monad m => MonadState s m | m -> s
10:11:38 <byorgey> Ngevd: and feel free to come ask in #diagrams if you have questions.
10:11:50 <hpc> mcstar: so, data CGI a where ...
10:11:59 <hpc> data CGIState = ...
10:12:03 <hpc> (or something like that)
10:12:12 <hpc> and to get the ask function
10:12:15 <mcstar> hpc: is this really for me? im not website oriented
10:12:17 <byorgey> Ngevd: there is even a tree-drawing module in the diagrams-contrib package
10:12:19 <byorgey> Ngevd: http://hackage.haskell.org/packages/archive/diagrams-contrib/0.1.1.0/doc/html/Diagrams-TwoD-Layout-Tree.html
10:12:20 <hpc> instance MonadState CGIState CGI where ...
10:12:24 <hpc> mcstar: im getting to the good part
10:12:36 <Ngevd> byorgey, unfortunatly, family trees aren't trees?
10:12:42 <hpc> mcstar: now, if that functional dependency wasn't there, someone could go and write another instance of MonadState for CGI
10:12:50 <byorgey> Ngevd: heh, good point =)
10:13:00 <hpc> or worse, the typechecker could decide that there's an ambiguous type variable
10:13:00 <hiptobecubic> c_wraith, ah. That's a shame. Throwing OpenMP on a loop does well even for two cores usually.
10:13:06 <hpc> what the "m -> s" means is
10:13:26 <mcstar> s is a type that is parameterized by m
10:13:32 <hpc> whenever you use ask in your CGI type
10:13:38 <hpc> you ALWAYS get back a CGIState
10:13:42 <hpc> because that's what that instance says
10:13:49 <hpc> and there can't ever be another one that conflicts with it
10:13:58 <hpc> :t ask
10:13:59 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
10:14:19 <hpc> so if m = CGI, r = CGIState
10:14:27 <c_wraith> hiptobecubic: I think repa can do better with more work. Remember that it's not nearly as mature as vector, at this point
10:14:27 <mcstar> hpc: ok, thanks very much, is it a haskell 98 feature?
10:14:30 <hpc> no
10:14:37 <hpc> you need to turn on the extension for it
10:14:43 <hpc> nowadays people seem to prefer type families
10:14:57 <hpc> which solve the same problem in a somewhat nicer way
10:15:04 <c_wraith> Type families can be cleaner. Aren't always.
10:15:04 <mcstar> hpc: imreading this http://www.haskell.org/haskellwiki/GHC/AdvancedOverlap
10:15:42 <hiptobecubic> c_wraith, more work as in larger loops or as in more parallelization
10:16:02 <c_wraith> hiptobecubic: neither, actually. I'm thinking constant-factor improvements
10:16:30 <hiptobecubic> c_wraith, oh you mean Repa can do better after more people work on the library
10:16:34 <c_wraith> yes
10:16:47 <hiptobecubic> c_wraith, ah. Well yeah I hope. Unboxed does pretty well
10:16:56 <c_wraith> It's still relatively young, as far as libraries go.
10:17:38 <hpc> mcstar: that's a freaky trick
10:19:19 <mcstar> hpc: you mean haskell? yes it is a freaky trick XD
10:19:43 <hpc> mcstar: the overlapping thing you linked
10:19:48 <mcstar> im kidding
10:19:51 <hpc> oh :P
10:20:28 <augur> http://www.reddit.com/r/haskell/comments/t2yy2/scrap_your_type_classes/
10:20:34 <augur> why does this cause GHC to choke?
10:20:53 <augur> if its dictionaries under the hood, why on earth would explicit dictionaries work nicely, but implicit ones work badly?
10:21:55 <rwbarton> why does what cause GHC to choke
10:22:31 <augur> rwbarton: see the link?
10:22:32 <rwbarton> or are you referring to the article in general
10:22:45 <Eduard_Munteanu> Mm, that freaky thing kinda lets one "pattern-match" on *.
10:22:46 <rwbarton> "choke" sounds like compiler hangs or something
10:23:39 <augur> rwbarton: according to the article, it does
10:24:01 <rwbarton> the article is 20 screens long
10:24:29 <augur> rwbarton: class Iso a b where fw :: a -> b ; bw :: b -> a
10:25:02 <augur> rwbarton: instance Iso ((), a) a where fw = snd ; bw = (,) ()
10:25:16 <augur> thats the kind of example he deals with
10:25:18 <augur> and then he says
10:25:20 <augur> this wont work:
10:25:34 <rwbarton> (why didn't you just say this in the first place when I asked "why does what cause GHC to choke" :P)
10:25:44 <augur> instance (Iso a b, Iso b c) => Iso a c where fw = fw . fw ; bw = bw . bw
10:26:06 <augur> this will supposedly cause the compiler to hang
10:26:09 <augur> this last one
10:26:34 <Eduard_Munteanu> Um, I suppose it can't know you want to go "through 'b'"?
10:26:38 <hpc> . o O (what type class feature would desugar to GADT dictionaries?)
10:26:43 <rwbarton> it has no way to know what to pick for b, yeah
10:26:49 <augur> Eduard_Munteanu: he turns on undecidable instances and such tho
10:26:55 <augur> so it doesnt simply fail to type change
10:26:55 <roconnor__> @tell merijn edward kicked me to update data-lens-template et. al. and someone else here said they would update them for me.  I guess it didn't happen.  If you have a hackage account, feel free to update them :)
10:26:56 <lambdabot> Consider it noted.
10:26:57 <augur> .. type check
10:26:57 <rwbarton> I'm surprised it doesn't just reject the whole mess as overlapping though
10:26:59 <augur> it _hangs_
10:27:17 <augur> well, read his post and see the details
10:28:01 <rwbarton> well it's hardly surprising that it could loop
10:28:03 <Eduard_Munteanu> Hm. I'm not sure how those work exactly.
10:28:08 <rwbarton> I mean imagine you had an instance Iso a a
10:28:27 <augur> hmm
10:28:34 <rwbarton> hmm, sure enough
10:29:03 <rwbarton> anyways you can't do this for obvious reasons
10:29:14 <rwbarton> the specific failure mode is just a matter of curiosity :)
10:29:18 <augur> which are the obvious reasons tho
10:29:24 <augur> because i dont see them
10:29:29 <rwbarton> well, for one, that instance will overlap with any other instance?
10:29:45 <jfischoff> roconnor__: are lenses moving towards arrows?
10:29:51 <augur> rwbarton: will it?
10:29:54 <rwbarton> secondly if it was somehow allowed, how would you know that your instances were coherent, i.e. that the isomorphism you get doesn't depend on the choice(s) of b?
10:29:58 <Eduard_Munteanu> augur: you're expecting GHC to pick the right fws, even though the type of the whole expression tells nothing
10:30:03 <rwbarton> yes of course since it matches any variables a and c
10:30:06 <Eduard_Munteanu> fw . fw goes from a to a.
10:30:34 <augur> Eduard_Munteanu: im expecting it to pick some b' so that one fw goes from a to b' and the other from b' to c
10:30:37 <Eduard_Munteanu> It could look into the scope and see if anything matches, but there isn't a straightforward choice.
10:30:38 <rwbarton> thirdly it has no way to go about searching for the b to choose
10:30:47 <rwbarton> that's just not how type classes work
10:30:50 <augur> i suppose it's not reasonable to expect it to choose a b' that it knows can satisfy that
10:31:14 <augur> rwbarton, Eduard_Munteanu: you should write a reply entitled
10:31:19 <augur> Don't Scrap your Classes
10:31:20 <byorgey> this is one case where passing dictionaries manually can help, since basically you are forced to give an explicit proof term rather than having the compiler discover it for you
10:31:40 <rwbarton> or imagine you wanted to compose three isomorphisms a to b, b to c, c to d, it has no way to know the two ways to compose them are the same so what is it supposed to do
10:31:41 <byorgey> your explicit proof term will explicitly specify when to use transitivity (and what type goes in the middle)
10:31:58 <rwbarton> haha
10:31:59 <augur> byorgey: or maybe we could have the option to go between the two views easily
10:32:03 <rwbarton> "Scrap your Records" :P
10:32:14 <rwbarton> in the vein of other recent /r/haskell submissions
10:32:21 <augur> byorgey: we might be able to annotate it using {{ ... }}
10:32:27 <rwbarton> @hackage reflection
10:32:27 <lambdabot> http://hackage.haskell.org/package/reflection
10:32:29 <rwbarton> have fun
10:32:33 <augur> and we can call the resulting version of Haskell "Agda"
10:32:33 <augur> :)
10:32:38 <byorgey> augur: yes, that is an interesting direction for research, but it is very non-obvious how to make it work without introducing problems with coherence.
10:35:18 <Eduard_Munteanu> augur: I think you can annotate one of the fws with a type
10:35:41 <Eduard_Munteanu> Though I guess you need ScopedTypeVariables
10:39:13 <hiptobecubic> I think random number generation might be slowing me down :/
10:40:27 <ymasory> is there any shortcut for nesting maps over and over? like a function that would let me do this more pleasantly: M a b c d e -> M a b c d f?
10:45:06 <Eduard_Munteanu> ymasory: that looks strange, do you mean stuff like M (A (B (C (D e))))?
10:45:34 <augur> Eduard_Munteanu: hmm
10:49:24 <ymasory> Eduard_Munteanu: maybe something like [[[Int]]] -> [[[String]]]
10:50:08 <illissius> is there any easy way to tell which language extensions were introduced in which versions of GHC?
10:50:15 <parcs`> :t (fmap . fmap . fmap) :: (Int -> String) -> [[[Int]]]
10:50:16 <lambdabot>     Couldn't match expected type `[[[Int]]]'
10:50:16 <lambdabot>            against inferred type `f a -> f b'
10:50:16 <lambdabot>     In the first argument of `(.)', namely `fmap'
10:50:46 <hpc> illissius: look for a GHC changelog
10:51:01 <byorgey> ymasory: if you want, you can define operators like  oo = fmap . fmap;  ooo = fmap . fmap . fmap  etc.
10:51:03 <Eduard_Munteanu> :t (fmap . fmap . fmap) :: (Int -> String) -> [[[Int]]] -> [[[String]]]
10:51:03 <lambdabot> (Int -> String) -> [[[Int]]] -> [[[String]]]
10:51:13 <strager> illissius: Why don't you build a table and share it with us?  =]
10:51:32 <Eduard_Munteanu> Or you can use the triple boobies directly...
10:51:38 <byorgey> ymasory: and then write  f `ooo` x
10:51:42 <Eduard_Munteanu> :t (.).(.).(.) --- just in lambdabot though
10:51:43 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
10:52:12 <ymasory> byorgey: thanks
10:52:36 <strager> Why did Functor get roped into that?
10:52:49 <illissius> strager: Yeah, maybe. eventually... ;)
10:53:03 <byorgey> strager: because in lambdabot (.) has a generalized type
10:53:10 <byorgey> strager: in particular (.) = fmap
10:53:14 <strager> I see
10:53:19 <hpc> another fun one is flip
10:53:20 <hpc> :t flip
10:53:21 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
10:53:31 <hpc> flip fs x = fmap ($ x) fs
10:53:47 <hpc> for the (c ->) Functor, flip = Prelude.flip
10:54:01 <hpc> but it has nice properties for other things too
10:55:15 * strager 's brain!
10:58:34 <illissius> hpc: searching for text in the release notes at http://www.haskell.org/ghc/docs/ in the user's guide for each version is the best I could find. it's pretty cumbersome and hit-and-miss unfortunately.
10:58:47 <illissius> in this particular case I'm wondering when Rank2Types might've been introduced...
11:02:34 <hpaste_> Luke pasted “fmap?” at http://hpaste.org/67971
11:02:49 <Luke> ^^ can I use fmap or something here?
11:02:55 <Luke> to get rid of the return ()?
11:03:12 <byorgey> Luke: use 'when'
11:03:16 <byorgey> @type when
11:03:17 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
11:03:21 <Luke> nice
11:03:22 <Luke> thanks
11:03:27 <byorgey> when exists $ removeDirectoryRecursive dir
11:10:50 <Luke> I'm getting an exception from removeDirectoryRecursive of that
11:11:23 <Luke> "-- If f is not a directory, re-throw the error"
11:11:27 <Luke> from the remove source
11:20:40 <Luke> looks like file permissions or something. deleting the dir and starting over it's fine now
11:25:36 <hiptobecubic> :t (.).(.)
11:25:38 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
11:25:58 <hiptobecubic> :t (.).(.) id
11:25:59 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a -> a1) -> f a -> f a1
11:26:26 <hiptobecubic> :t (.)
11:26:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:26:46 <hiptobecubic> :t (.) .
11:26:47 <lambdabot> parse error (possibly incorrect indentation)
11:26:50 <hiptobecubic> :t (.) (.)
11:26:51 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
11:27:25 <hiptobecubic> :t (.) (.) (.)
11:27:26 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
11:34:17 <scooty-puff> does a package exist that implements a weak intmap (or any sort of weak map)?
11:34:32 <scooty-puff> i would assume it would operator in IO, and thats fine with me
11:34:46 <scooty-puff> *operate
11:35:37 <scooty-puff> but it would be nice if it was not modified in place via ioref's, etc.
11:35:49 <scooty-puff> (can't think of the right term..)
11:36:30 <danr> @type takeWhile (not . null) .: liftM2 (.) (map . take) (iterate . drop)
11:36:30 <lambdabot> forall a. Int -> [a] -> [[a]]
11:36:54 <rata_> hi
11:38:26 <byorgey> hi rata_
11:38:35 <mekeor> hi!
11:39:20 <rata_> is there a better way to do tail . reverse . dropWhile (== '.') . reverse?
11:39:35 <rata_> sorry, I mean (/= '.')
11:40:36 <danr> @hoogle dropExtension
11:40:36 <lambdabot> System.FilePath.Windows dropExtension :: FilePath -> FilePath
11:40:36 <lambdabot> System.FilePath.Posix dropExtension :: FilePath -> FilePath
11:40:36 <lambdabot> System.FilePath.Windows dropExtensions :: FilePath -> FilePath
11:40:39 <danr> rata_: ^
11:44:30 <magicman> > tail . reverse . dropWhile (== '.') . reverse $ "Hello.there"
11:44:31 <lambdabot>   "ello.there"
11:44:43 <magicman> > tail . reverse . dropWhile (/= '.') . reverse $ "Hello.there"
11:44:45 <lambdabot>   "ello."
11:45:03 <mekeor> > reverse . tail . dropWhile (/= '.') . reverse $ "Hello.there"
11:45:05 <lambdabot>   "Hello"
11:45:20 <magicman> That's probably what was meant, yeah :p
11:45:25 <mekeor> :)
11:47:43 <rata_> yes
11:49:03 <fmap> @hoogle interact
11:49:04 <lambdabot> Prelude interact :: (String -> String) -> IO ()
11:49:04 <lambdabot> System.IO interact :: (String -> String) -> IO ()
11:49:04 <lambdabot> Data.ByteString interact :: (ByteString -> ByteString) -> IO ()
11:51:04 <ttt--> hi, if i want to make a simple minesweeper-like game, what graphic library could i use?
11:51:35 <Eduard_Munteanu> ttt--: gtk2hs should be fine, I think
11:52:40 <bitonic> Eduard_Munteanu: I think he's referring to the actual game
11:52:54 <bitonic> ttt--: if you want 3D the only was is OpenGL I'm afraid
11:53:22 <Eduard_Munteanu> Um, he said minesweeper, not minecraft :)
11:53:31 <Eduard_Munteanu> That's pretty much not 3D.
11:53:34 <mekeor> lol
11:53:41 <Ngevd> 3D minesweeper
11:53:50 <sclv> it has 3d effects!
11:53:56 <sclv> the little buttons go down when you click them.
11:53:57 <Ngevd> "OK, this cell is next to 28 mines"
11:54:00 <Eduard_Munteanu> Yeah, button shading :P
11:54:01 <Ngevd> "Oh dear"
11:55:14 <hpc> 3D minesweeper is really fun
11:55:46 * magicman only knows http://jayisgames.com/games/minesweeper-3d-universe/ . Which isn't *completely* 3D, but still quite tricky.
11:55:55 <bitonic> Eduard_Munteanu: I actually read minecraft! ehehe
11:55:57 * bitonic is tired
11:56:05 <sclv> I like 1d minesweeper.
11:56:08 <Eduard_Munteanu> Heh.
11:56:11 <sclv> I always win!
11:57:07 <gentleben> ttt--: you can also use a software renderer
11:57:38 <ttt--> im looking for something really simple.. use boxes with numbers and clicking on them
11:57:55 <rata_> is there a way to ask for a newline in parsec?
11:58:02 <sclv> somebody should write minesweeper on the 120 cell: http://math.ucr.edu/home/baez/dodecahedron/Stereographic_polytope_120cell_faces.png
11:58:25 <rata_> nevermind
11:58:30 <Eduard_Munteanu> sclv: there is a 4d maze game somewhere
11:58:52 <Eduard_Munteanu> @google 4d maze
11:58:54 <lambdabot> http://www.urticator.net/maze/
11:58:54 <lambdabot> Title: urticator.net - 4D Maze Game
11:58:57 <Ngevd> There's a 5D rubik's cube somewhere
11:59:07 <sclv> or this: http://plus.maths.org/content/sites/plus.maths.org/files/articles/2010/yau/Calabi_yau2.jpg
11:59:09 <Eduard_Munteanu> Ouch, that sounds insane :)
11:59:39 <hpc> sclv: that's just a projection of a 10-D surface, i think
11:59:50 <Eduard_Munteanu> ttt--: you could use GTK buttons I guess.
11:59:50 <ttt--> gtk2hs looks good for this, thanks
12:00:13 <mm_freak_> is there a difference between uniqueness types and affine types?
12:00:23 <danr> about the 4d maze: I hope you enjoy the game, it is one of the best things I have ever made.
12:00:27 <danr> nice
12:00:40 <adamt> i don't really see the point of a 5d rubiks cube, when most people struggle with the 3x3x3 one, and almost nobody cares about learning the stupid cases where to adjacent edges are flipped on a even sided cube.
12:00:46 <sclv> hpc: https://en.wikipedia.org/wiki/Calabi-Yau_manifold
12:01:11 <hpc> ah, 6 dimensions :P
12:01:27 <hpc> oh, n dimensions
12:01:30 * hpc lrns2read
12:01:56 <sclv> this particular one i think is 5 dimensional, but i dunno. it looks pretty.
12:02:20 <sclv> (also not a projection but a section)
12:02:25 <Eduard_Munteanu> danr: oh, you're the author?
12:02:33 <danr> Eduard_Munteanu: oh no! :)
12:02:37 <danr> I just found it a nice quote
12:02:40 <Eduard_Munteanu> Ah.
12:02:46 <danr> It was on the webpage linked above
12:03:20 <Catnaroek> Is there a typeclass of containers that can be sequentially iterated?
12:03:28 <hpc> @hoogle iteratee
12:03:29 <lambdabot> package iteratee
12:03:29 <lambdabot> package iteratee-compress
12:03:29 <lambdabot> package iteratee-mtl
12:03:36 <Catnaroek> Oh, nice.
12:03:43 <Catnaroek> Thanks, hpc.
12:03:53 <hpc> also conduit
12:04:27 <c_wraith> err.
12:04:29 <c_wraith> Wait?
12:04:37 <c_wraith> Do you really want Foldable?
12:05:33 <byorgey> Catnaroek: can you give a bit more context about what you are trying to achieve?
12:06:05 <Catnaroek> I'm trying to push my metaprogramming skills to the limit, both in Haskell with typeclasses and in C++ with templates.
12:06:35 <Catnaroek> So I am trying to implement a map that works with any sequentially iterable container.
12:06:36 <bitonic> is there a way to make ghc-mod use the packages specified in a cabal file?
12:07:20 <hiptobecubic> like fmap?
12:07:23 <c_wraith> Catnaroek: how does that differ from fmap?
12:07:45 <byorgey> Catnaroek: well, it sounds like you want Traversable.
12:07:54 <byorgey> implementing Functor in terms of Traversable is a good exercise.
12:08:36 <Catnaroek> Oh.
12:12:12 <hiptobecubic> I didn't realize that random number generation was so expensive
12:12:48 <luite> hiptobecubic: is it?
12:12:52 <hpc> hiptobecubic: yeah, it takes 10 pseudo-random numbers to get one random number
12:13:01 <hpc> and then using a RNG to pick one of those 10 numbers at random
12:14:59 <hdev> hi, what do you guys generally use for haskell development? emacs/vim/anything else?
12:15:19 <Ngevd> Eclipse
12:15:27 <Ngevd> But sometimes it doesn't work
12:15:29 <Ngevd> :/
12:15:40 <Ngevd> And I've only got it actually doing Haskell on Windows
12:15:53 <hdev> Ngevd: ewww, full blown ide, is it worth it feature wise?
12:16:15 <hpc> hdev: one terminal vim, another terminal ghci
12:16:26 <hpc> edit in vim, ":r" in ghci to reload
12:16:32 <hpc> rinse, repeat
12:16:45 <Ngevd> hdev, built in cabal, ghci, hlint...
12:16:50 <Ngevd> But still, not really
12:18:13 <c_wraith> @hoogle whenJust
12:18:13 <lambdabot> No results found
12:18:16 <c_wraith> boo!
12:18:20 <c_wraith> I demand a recount!
12:18:43 <Ngevd> fmap?
12:19:37 <c_wraith> according to hayoo, 4 different packages define exactly that function
12:19:43 <c_wraith> xmonad is one of them
12:20:20 <hdev> what about leksah, yi, are they worth trying? essentially i would like to have some kind of completion + goto source, because i am pretty new to haskell, but i guess ghci can do that for me, can it?
12:20:35 <c_wraith> whenJust :: Monad m => Maybe a -> (a -> m ()) -> m ()
12:20:42 <hpc> afaik, yi is abandoned
12:21:20 <hpc> leksah is broken, but the reason for the breakage alternates between "leksah is out of date" and "one of leksah's depends is out of date"
12:21:42 <hpc> except according to hackage, it compiles
12:21:45 <hpc> so perhaps it's fixed
12:21:50 <roha> quick question: how can i combine partition with doesDirectory exist on a list of filepaths: partition doesDirectoryExist contents
12:21:59 <hdev> hpc: i already tried it and it doesn't on linux
12:22:10 <hpc> hmm
12:22:24 <hdev> hpc: it's about that gtk library i think
12:22:26 <roha> doesDirectory is of type  FilePath -> IO Bool
12:22:33 <c_wraith> roha: unfortunately, you'd need a different function for that. something like partitionM
12:22:34 <hpc> hdev: yeah, something like that
12:22:46 <hpc> hdev: it and one of its depends keep getting built on different versions of gtk
12:23:21 <c_wraith> @hoogle Monad m => [a] -> (a -> m Bool) -> m ([a], [a])
12:23:21 <lambdabot> No results found
12:23:39 <jfischoff> is there a workaround for when you need template haskell and mutually recursive types?
12:23:46 <roha> c_wraith, ok thanks!
12:24:02 <worldsayshi> To anyone: I have a peculiar haskell-mode (emacs) issue: When quitting ghci (':q') inside emacs without closing the buffer, when I do C-c C-l ghci will end up with the working directory being one directory up from before, so the imports will fail...
12:24:04 <c_wraith> roha: doesn't seem to be a function that exists already
12:25:08 <hdev> i'll have a look into eclipsefp, let's see if it is usable
12:25:56 <quintessence> roha: you can liftM (map fst . partition snd . zip xs) (mapM doesDirectoryExist xs)
12:26:18 <quintessence> actually, is there a combinator for decorate/foo/undecorate?
12:26:53 <quintessence> (where by "map" I mean "bimap", but you get the idea)
12:26:53 <Elemir> @hoogle :: Ord a => [(a, b)] -> Map a [b]
12:26:53 <lambdabot> No results found
12:27:09 <Elemir> @hoogle :: Eq a => [(a, b)] -> [(a, [b])]
12:27:10 <lambdabot> Data.Graph.Inductive.Query.Dominators dom :: Graph gr => gr a b -> Node -> [(Node, [Node])]
12:27:14 <Elemir> Hem
12:38:33 <fmap> Is there someone who managed how to ignore "Use camelCase" warning from HLint?
12:40:49 <copumpkin> you gotta use camelCase
12:40:55 <vodik> fmap: hlint --ignore "Use camelCase"
12:40:55 <copumpkin> then it'll stop bothering you :)
12:41:01 <vodik> fmap: if you must
12:42:33 <fmap> I see, hlint --help says `--ignore=hint'
12:42:34 <fmap> thanks
12:44:27 <EvanR> how does it know when you dont use camelcase
12:44:35 <EvanR> underscores
12:49:05 <vodik> magic
12:49:27 <vodik> EvanR: its just looks for underscores in identifies
12:49:53 <EvanR> ok
12:49:56 <vodik> EvanR: Found: test_func = ... Why not: testFunc = ...
12:50:47 <EvanR> we should be able to just put spaces in identifiers
12:50:52 <EvanR> would solve everything
12:51:37 <Eduard_Munteanu> Perhaps some Unicode space-like character :)
12:51:55 <vodik> EvanR: how would you tell the difference between an identifier with spaces in it or an identifier with parameters?
12:52:19 <EvanR> magic
12:52:27 <EvanR> when that fails, more magic
12:52:42 <vodik> heh, s/magic/mind reading/
12:52:53 <EvanR> mind reading would help
12:59:39 <hpaste_> scooty-puff pasted “How horrible is this?” at http://hpaste.org/67977
13:07:39 <hjulle> Is there any way to get exclusive instance contexts? For example: x :: Num a, (not Integral a) => a
13:09:05 <hjulle> I want this for giving both generic and specific instatiation to a class that would otherwise clash.
13:09:30 <quintessence> scooty-puff: if you use that to hash an STRef that's a thunk, you may get a different hash value after it gets evaluated
13:09:53 <hjulle> s/instatiation/instantiation
13:10:12 <geekosaur> no, and it wouldn't be meaningful.  (an instance context mneans "pass the dictionary for how to <x>"; what's the dictionary for "not Integral"?  what does  "not Integral" even *do*?)
13:11:23 <hjulle> geekosaur: I only want it for matching, not ever setting something to that type
13:11:48 <scooty-puff> quintessence: thats why i used $! - wasn't sure if needed to do more to make sure it was strict - and if that would make sure the value in the ref is evaluated (or needs to?)
13:12:08 <geekosaur> hjulle... what?
13:12:27 <geekosaur> I hope that doesn't translate to "I think typeclasses are OO" --- they are not
13:12:58 <hjulle> geekosaur: Not as far as I know
13:13:47 <quintessence> scooty-puff: Oh, I missed that.  That should work fine in practice, though I think there's no official guarantee that evaluating a thunk is the only way for the "same" value to have a different StableName
13:14:23 <hjulle> geekosaur: What I really want is some way to disambiguate different instantiations of a class
13:14:52 <scooty-puff> k, will prob use a wrapper that produces integers instead - a lot easier to figure out
13:15:21 <scooty-puff> i.e. StateT Integer (ST s)
13:15:25 <scooty-puff> or whatever
13:20:57 <quintessence> geekosaur: there is a semantics (and implementation) of negative instance constraints (http://lambda-the-ultimate.org/node/4173), but not in Haskell
13:23:47 <hjulle> quintessence: Yes, that was exactly what I was looking for
13:29:21 <reinoud> Hi
13:29:49 <reinoud> is there some kind of profiler available for ghc? one that tells me what takes the most memory or needs the most rewrites?
13:30:32 <shachaf> @where profiling
13:30:33 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
13:32:53 <whittle> Is there an example set-up I can use for rebuilding a library using plugins-auto during development?
13:33:54 <hpaste_> thief- pasted “TicTacToe Question (Past Exam Question)” at http://hpaste.org/67978
13:34:19 <thief-> If someone could have a quick look at that for me it'd be a real help
13:35:10 <thief-> I've got about half of it done, but I think I'm going about it the wrong way
13:35:23 <thief-> Feels like I'm making it harder than it needs be
13:35:49 <reinoud> tnx
13:35:56 <Botje> any time you're typing that much, you're doing it wrong.
13:36:43 <thief-> Botje: yea it felt wrong, out of practice though - haven't done any haskell since before xmas
13:36:58 <Botje> thief-: try writing a function that enumerates all places that can provoke a win.
13:37:23 <Botje> so places :: Board -> [[Maybe Piece]]
13:37:33 <Botje> which returns the three rows, the three columns, and the two diagonals
13:38:19 <Botje> and I'd implement Board as [[Maybe Piece]] (3x3 list of lists)
13:39:04 <thief-> Our lecturer recommended a sparse map instead of "Maybe Piece"s, but I didn't have time to look into that
13:39:31 <Botje> also an option. though not really worth it for a 3x3 board
13:41:18 <thief-> so then check the result of places to see if any of them contain the same 3 pieces - is that what you meant?
13:41:35 <Botje> yes.
13:41:41 <thief-> cool cheers
13:42:13 <thief-> the area I'm having more problems with though is the moves function - the left b = Board… bit
13:42:26 <thief-> sorry *let b = Board
13:43:14 <Botje> yes, your notation is screwing you over.
13:43:59 <thief-> so you reckon things would be easier here if I go with the 3 lists then
13:43:59 <Botje> let next take a Board.
13:44:21 <Botje> also, your let b = Board (next ... b ...) is cause for trouble.
13:45:11 <sclv> the instance chains formulation, as i recall, lets you prove false.
13:45:36 <sclv> so i mean you can use it, but as i recall, "don't do that then"
13:46:23 <quintessence> sclv: what does prove false mean in this context?
13:46:44 <sclv> a type system encodes a logic.
13:46:45 <Botje> thief-: you can work with a list of Maybe Piece and convert back to your Board afterwards.
13:47:06 <mm_freak_> is there a difference between uniqueness types and affine types?
13:47:18 <sclv> multiparam type classes extend that logic
13:47:30 <sclv> to make it less trivial
13:47:39 <sclv> prove false means that the logic encoded is inconsistent.
13:47:45 <quintessence> sclv: general recursion (in values) already lets you prove false in that sense, doesn't it?
13:47:51 <sclv> yes.
13:47:56 <sclv> you can do forall a. a.
13:48:28 <sclv> but that's terms proving types.
13:48:32 <sclv> this is slightly different.
13:48:46 <sclv> it's that the types themselves are inconsistent.
13:49:08 <angstrom> @pl \(Just a, b) -> (a, b)
13:49:09 <lambdabot> (line 1, column 8):
13:49:09 <lambdabot> unexpected "a"
13:49:09 <lambdabot> expecting operator or ")"
13:49:31 <angstrom> what am I doing wrong?
13:50:09 <thief-> Botje: thanks for your help, I'm going to try again without the record syntax
13:50:54 <Botje> that's not record syntax
13:51:23 <quintessence> sclv: can you deduce both "C a" and "C a fails"? That would be pretty questionable.
13:52:09 <sclv> i don't remember all the details.
13:52:32 <fmap> angstrom: first fromJust
13:53:02 <sclv> but its essentially this: http://okmij.org/ftp/Prolog/index.html#impure
13:53:42 <Catnaroek> Suppose I implement a "data BinaryTree a = ...", with "instance Functor BinaryTree where ...". Do I have to implement "fmap :: (a -> b) -> BinaryTree a -> BinaryTree b" in such a way that the resulting "BinaryTree b" 's internal structure is exactly the same as the original "BinaryTree a" 's structure?
13:53:57 <sclv> you get negation as failure
13:54:00 <angstrom> fmap: thanks
13:54:28 <shachaf> Catnaroek: Usually it's considered sufficient to make it indistinguishable-using-your-exported-primitives.
13:55:00 <shachaf> So if you don't export the BinaryTree constructor but just export views and (==) and so on, that *might* be sufficient?
13:55:03 <c_wraith> In particular, if you want to implement it with toList and fromList, usually no one will care
13:55:34 <shachaf> This would be more helpful if fmap could have constraints -- then you could have fmap for Set, for instance (which would obviously result in a different internal structure).
13:55:57 <shachaf> However, it has to be completely indistinguishable for this argument to work. :-)
13:56:44 <Catnaroek> Km
13:56:47 <quintessence> sclv: interesting, thanks.
13:56:47 <Catnaroek> Okay.
13:57:22 <twanvl> you could probably also let Ghc derive the Functor instance for you
13:57:32 <copumpkin> the only rules fmap needs to satisfy, really, is that fmap id = id
13:57:53 <copumpkin> so if your equality doesn't care too much about internal structure, you're fine
13:58:05 <copumpkin> chances are, the function wouldn't be able to affect internal structure at all, though
13:58:14 <c_wraith> yes.  So long as you use extensional equality.
13:58:21 <copumpkin> but you might envision "optimizing" the structure as you walk along
13:58:23 <thoughtpolice> shachaf: you can get real close to Functor for Set nowadays, with ATs and constraint kinds. there's a bug in 7.4.1 that makes this uglier than it needs to be though
13:58:32 <copumpkin> you might find two smaller nodes that could be coalesced into a larger node, or something
13:58:33 <thoughtpolice> s/real close to/
13:58:35 <thoughtpolice> s/real close to//
13:58:46 <shachaf> thoughtpolice: Sure, you can define your own class, but not Functor. :-)
13:58:47 <copumpkin> thoughtpolice: the problem with that is that you double all your constraints
13:59:08 <thoughtpolice> shachaf: ah, right. :(
13:59:09 <Catnaroek> Thank you all!
14:01:28 <EvanR> is IO a functor
14:01:42 <Botje> if you feed and water it properly, yes.
14:01:46 <copumpkin> EvanR: sure
14:02:28 <c_wraith> :t read <$> getLine
14:02:28 <lambdabot> forall a. (Read a) => IO a
14:02:38 <c_wraith> looks like a functor to me
14:02:50 <copumpkin> quacks like one, too
14:03:12 <EvanR> is it just composition
14:03:33 <c_wraith> it's the same thing as any other monad
14:03:37 <c_wraith> @src liftM
14:03:37 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
14:03:42 <copumpkin> nope, because IO isn't a function (unless you look at shitty non-essential implementation details)
14:03:47 <EvanR> oh
14:03:52 <EvanR> right
14:03:54 <EvanR> liftM
14:06:14 <t7> its a type level function... :)
14:06:23 <EvanR> i meant to say application
14:06:32 <EvanR> which is basically what all fmap is supposed to do
14:06:57 <c_wraith> yep.
14:07:07 <c_wraith> It's really the only thing it *can* do, with its type
14:07:41 <EvanR> then why is 'applicative' functor something greater
14:07:58 <copumpkin> it's a functor with an extra couple of operations
14:08:07 <copumpkin> with more required properties, there are fewer possible instances
14:08:10 <jfischoff> is there a good way to specify that you would like all types defined in a module to derive some list of type classes?
14:08:37 <copumpkin> so properties(Functor) < properties(Applicative) and instances(Applicative) < instances (Functor)
14:08:40 <copumpkin> (zomg
14:08:43 <copumpkin> )
14:08:50 <sclv> what functors are not applicative, by the way?
14:08:52 <sclv> i forget
14:09:09 <copumpkin> hmm
14:09:15 <c_wraith> sclv: mostly ones that can't support pure
14:09:22 <copumpkin> there's Map k
14:09:29 <c_wraith> (,) a
14:09:49 <sclv> but there's a whole discussion about how every functor effectively supports pure!
14:09:58 <sclv> or rather you don't need pointed
14:09:59 <copumpkin> is there?
14:10:05 <copumpkin> well, it's not that they all support it
14:10:06 <sclv> but just "gimmeOne"
14:10:09 <copumpkin> it's that all the laws come for free
14:10:12 <sclv> which gives you *something*
14:10:22 <rodayo> Does anyone see something immediately wrong with this: "join (x:xs) c = x ++ [c] ++ join xs" with joined defined like so: "join :: [String] -> Char -> String"
14:10:22 <copumpkin> well, the only laws you can say about pointed are implied by parametricity
14:10:26 <sclv> and then you can fmap const into it
14:10:27 <copumpkin> so you might as well not recognize it as its own thing
14:10:32 <sclv> so any functor where there exists at least one
14:10:38 <sclv> you can make a typeclass that gives you that one
14:10:41 <sclv> and then that gives you pure.
14:10:47 <sclv> so you have to squint a bit.
14:10:50 <copumpkin> not really, cause you need a base thing to fmap onto
14:10:54 <sclv> right.
14:10:57 <vodik> rodayo: = x : c : join xs
14:11:03 <sclv> that's the squinting bit.
14:11:07 <copumpkin> :)
14:11:14 <vodik> rodayo: = [x] ++ [c] ++ join xs (first suggestion is better)
14:11:16 <copumpkin> the usual objection to pointed is what I was saying about the parametricity, though
14:11:20 <sclv> but if you give me a nonempty type, i promise i can write a base thing to fmap onto and hence pure.
14:11:58 <sclv> so let's reformulate -- are there any pointed functors which are not applicative :-)
14:12:01 <sclv> and what are they?
14:12:20 <rodayo> vodik, second suggestion ([x] ++ [c] ...) doesn't work, i'll try the other
14:12:37 <vodik> rodayo: whats the type of c/
14:13:05 <rodayo> vodik, Char...isn't that how the it's defined?
14:13:23 <vodik> rodayo: and (x:xs)?
14:13:33 <rodayo> String
14:13:40 <rodayo> sorry [String]
14:13:48 <vodik> oh
14:13:58 <vodik> i assumed String -> Char -> String
14:14:02 <Botje> rodayo: the first type you had was correct.
14:14:12 <Botje> could you put the entire function on hpaste.org?
14:14:28 <Botje> .oO(also, you're reinventing intercalate)
14:14:40 <Botje> :t intercalate
14:14:41 <lambdabot> forall a. [a] -> [[a]] -> [a]
14:15:20 <rodayo> http://pastie.org/3850682
14:16:22 <Botje> rodayo: oh.
14:16:23 <rodayo> my edge condition might be wrong but i'm getting a compilation error at the last line
14:16:33 <Botje> rodayo: you're not passing enough parameters to join in the recursive call.
14:16:56 <vodik> rodayo: join xs c
14:17:10 <vodik> Botje: good spot
14:17:14 <rodayo> oooo
14:17:22 <rodayo> :p my bad
14:18:22 <Botje> rodayo: it helps to give the error as well :)
14:19:03 <rodayo> Botje, yep i just figured there was probably something immediately wrong with it that i didn't see. i'll include the error next time
14:20:17 <e98> does hackage/cabal not have support for delta package index? or does it and I believe it's doing a full download on 'cabal update'?
14:21:14 <byorgey> e98: it doesn't.
14:22:19 <byorgey> e98: I'm pretty sure it's on the list of "features someone should add"
14:30:31 <e98> byorgey: I see. just had to be sure I'm not making this up
14:31:10 * hackagebot cmu 1.7 - Unification in a Commutative Monoid  http://hackage.haskell.org/package/cmu-1.7 (JohnRamsdell)
14:38:34 <xplat> i tried installing every version of ghc-mod back to 1.0.0, none of them will install
14:39:30 <vodik> xplat: whats the error?
14:39:58 <xplat> vodik: cabal: dependencies conflict: ghc-7.0.3 requires pretty ==1.1.1.0 however pretty-1.1.1.0 was excluded because ghc-7.0.3 requires pretty ==1.0.1.2
14:41:41 <dmwit> xplat: Did you reinstall ghc-7.0.3? What does ghc-pkg check say?
14:42:10 <dmwit> Reinstalling any of the libraries that ship with GHC is highly discouraged. Easy way to break your system.
14:42:22 <xplat> ghc-7.0.3 is not installable
14:42:51 <Clint> tell yourself you don't want 7.0.3 anyway
14:42:52 <xplat> i.e. there's no installation candidate, so no danger i'd do that
14:43:22 <dmwit> Yes, that's true. But reinstalling ghc-7.0.3 is not the only way to hose yourself, so the advice (and the request for ghc-pkg check) stand.
14:43:56 <xplat> there's a bunch of things ghc-pkg check says are broken because of missing dependencies.  pretty and ghc are not among them
14:44:39 <dmwit> ?hpaste perhaps?
14:44:40 <lambdabot> Haskell pastebin: http://hpaste.org/
14:44:58 <dmwit> I suppose you might also try adding -v's to your cabal install line to ask cabal about what it's thinking.
14:45:51 <xplat> i put like 10 -vs in there and no help
14:46:19 <xplat> still prints like 3 lines, of which only the one i already pasted mentions any specific packages
14:46:47 <dmwit> what
14:47:21 <dmwit> How old is your cabal-install? =P
14:47:33 <xplat> the other two lines are 'Reading available packages...' and 'Resolving dependencies...'
14:47:56 <xplat> 0.10.2 using lib version 1.10.1.0
14:48:36 <dmwit> That should be new enough to be able to spit out more information.
14:48:43 <dmwit> strange
14:50:13 <dmwit> Well, "cabal install ghc-mod --with-ghc =ghc-7.0.3" seems to be working just fine here...
14:51:52 <dmwit> By which I mean it claims to have created an install plan. I didn't actually try building everything
14:51:55 <dmwit> .
14:52:46 <xplat> mine doesn't even get as far with that option as without
14:52:54 <xplat> cabal: Cannot find the program 'ghc' at '=ghc-7.0.3' or on the path
14:53:07 <dmwit> Get a better shell. =)
14:53:16 <dmwit> Try `which ghc-7.0.3` instead of =ghc-7.0.3
14:53:24 <xplat> oic
14:53:33 <xplat> yeah, same error then
14:53:47 <dmwit> I wouldn't expect that to change the error.
14:54:06 <dmwit> I only included it so you knew I was using the same compiler version.
14:54:13 <xplat> oh
14:54:15 <rwbarton> is that =foo syntax used by some weird shell?
14:54:20 <dmwit> rwbarton: zsh
14:54:44 <dmwit> It's very handy, because it's enough of a clue for the tab-completion to work well.
14:55:02 <Botje> very hard to live without, yes
14:55:29 <hpaste_> xplat pasted “ghc-pkg check” at http://hpaste.org/67979
14:56:53 <bitonic> rwbarton: and if you can't be bothered to configure zsh, just get this: http://grml.org/zsh/
14:56:54 <dmwit> youch
14:58:46 <rwbarton> i can't even be bothered to install it and it would be a single command :P
14:59:26 <dmwit> xplat: What version of pretty is in the dependencies section of "cabal info haskell-src-exts"?
14:59:59 <dmwit> xplat: How does that compare to the dependencies section for "cabal info Cabal"?
15:01:03 <bitonic> rwbarton: getting that is a single command as well
15:01:30 <dmwit> xplat: (You might try something like "cabal install ghc-mod --constraint pretty=1.0.1.2", which is the version that ships with ghc, and see what error it tells you.)
15:01:45 <dmwit> might have to be pretty==1.0.1.2, I don't remember
15:02:22 <dmwit> bitonic: Getting somebody else's zsh config seems a bit pointless if you can't even be assed to install zsh, let alone run it...
15:02:29 <Steve|Office> What's the best way to create an array where each element can depend on previously computed elements?
15:02:44 <dmwit> Steve|Office: just create it
15:03:02 <byorgey> Steve|Office: a regular array can do that.  Just define it recursively.
15:03:07 <Steve|Office> Right now, I've got something like listArray theBounds $ map f (range theBounds)
15:03:18 <Steve|Office> And f refers to elements of the array.
15:03:26 <Steve|Office> Is there a better way?
15:03:33 <dmwit> myCrazyRecursiveArray = array (0,30) [(i, myCrazyRecursiveArray ! i + 1) | i <- [0..30]]
15:03:38 <dmwit> :t array
15:03:39 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
15:03:43 <bitonic> dmwit: true, but it's a great config.
15:03:45 <dmwit> Steve|Office: Yes, that's the right way.
15:03:46 <byorgey> Steve|Office: what about that method do you think needs improving?
15:03:52 <xplat> dmwit: same error except it's excluded by the top-level dependency too
15:03:57 <Steve|Office> I'm not sure anything does. That's why I'm asking.
15:03:59 <hayashi> Hmm, hsql or hdbc.  Such choices
15:04:03 <byorgey> Steve|Office: ok =)
15:04:14 <byorgey> Steve|Office: nope, that is an excellent method
15:04:34 <t7> well they blocked pirate bay... whats next? porn i guess
15:04:34 <xplat> cabal info haskell-src-exts has pretty >= 1.0
15:04:36 <byorgey> Steve|Office: it's a great way to do lightweight dynamic programming
15:04:39 <Steve|Office> Will Haskell ever decide to throw values that have been computed away because it can recompute them?
15:04:44 <Steve|Office> In fact, DP is exactly what I'm doing here.
15:05:01 <byorgey> Steve|Office: no
15:05:13 <t7> whats the gc for?
15:05:15 <Steve|Office> byorgey: Okay, great!
15:05:20 <xplat> and Cabal is pretty >=1 && <1.2
15:05:26 <byorgey> Steve|Office: well, to be precise, the Haskell standard does not prohibit that.  But no implementation that I know of would do that.
15:05:36 <dmwit> Steve|Office: GHC will never memoize except when you ask it to by creating a data structure, and will never throw away data except when you ask it to by not referring to it any more.
15:05:43 <dmwit> Steve|Office: Other implementations may vary.
15:05:51 <hayashi> For something that involves operations on arbitrary tables whose names are specified from an interactive loop and nothing is known about the structure thereof until runtime, does one haskell database solution pull ahead of the other?
15:05:57 <Steve|Office> byorgey: Yeah, referential transparency would seem to allow it, but I wasn't sure if that's what was happening or not.
15:06:02 <hayashi> I've already ruled out haskelldb based on that, I think
15:06:33 <Steve|Office> I was watching memory usage of my program in top and it would grow to a little over 4 GB and then drop down to about 1.5 and then grow again. I wasn't sure what was going on.
15:06:57 <dmwit> Functional languages tend to produce rather a lot of garbage.
15:07:12 <dmwit> I wouldn't be surprised if you had some largish thunks in there, too.
15:07:17 <byorgey> Steve|Office: maybe the garbage collector ran?  Who knows.  Explaining memory usage patterns can be really tricky.
15:07:19 <dmwit> Which can collapse quite a lot.
15:07:27 <EvanR> easily solved with no gc and infinite ram
15:07:34 <EvanR> am i crazy? i think not
15:07:55 <xplat> when your ram fills up, just buy more?
15:08:05 <Steve|Office> Heh. I'm going to give this program a shot on a computer that has 48 GB of ram. Hopefully that'll help.
15:08:19 <EvanR> xplat: to the cloud
15:08:29 <sig> wow so many online
15:09:12 <Botje> avoiding success is hard.
15:09:38 <bitonic> expecially now that spj is buzzwords-compliant. "Haskell in the Cloud" :(
15:09:49 <EvanR> it is, and im so good at it
15:09:56 <EvanR> im a master
15:09:58 <xplat> 'to succeed, aim low, and miss'
15:10:20 * hayashi goes with hsql.
15:10:32 <companion_cube> "Agile Haskell in the Webscale Cloud"
15:10:38 <EvanR> lol
15:11:28 <bitonic> companion_cube: "Enterprise Ready, Agile Haskell REST Service in the Webscale Cloud"
15:12:37 <luite> i'm a bit disappoint that cloud haskell can't do more
15:12:46 <Cale> Typeclouds and Cloud Constraints
15:12:56 <luite> i could spend the summer improving it, but i'd have no money and no eat
15:13:13 <companion_cube> Polymorphic Clouds in the Agile Monadiic Typeclass
15:13:14 <jfischoff> luite: kickstarter?
15:13:16 <bitonic> I'd have no eat!
15:13:57 <bitonic> jfischoff: kickstarter only works for silly gadgets and videogames :(
15:13:59 <luite> jfischoff: i think you need to be us based for that
15:14:09 <luite> and you probably need to sell it as a point and click adventure game
15:14:57 <byorgey> are you guys making these up or is there a Cloud Haskell Buzzphrase Generator that I don't know about?
15:14:58 <Cale> Agile braided webscale n-categories
15:15:07 <Cale> Making them up, I think
15:15:12 <byorgey> =)
15:15:49 <byorgey> ooh ooh let me try
15:16:16 <xplat> the monoidal cloudagory of highly-available RESTful service interfaces
15:16:44 <companion_cube> byorgey: it's pure Buzzphrase handcrafting
15:16:58 <dmwit> type-directed synergy homomorphism development kit
15:17:30 <companion_cube> Purely Functional Applicative Type-safe Monoid-compatible Cloud-based Curryfied Language 2.0
15:17:39 <byorgey> hmm, I'm no good at this
15:18:13 <companion_cube> byorgey: come one, buzzwords just form a monoid for the concatenation
15:18:18 <byorgey> hehehe
15:18:36 <byorgey> companion_cube: I think it's only a semigroup.  The empty string is definitely not a buzzword.
15:19:07 <companion_cube> byorgey: I think that "Agile" is pretty much a neutral element
15:19:13 <companion_cube> you can add it everywhere
15:19:23 <companion_cube> and it still does not in interfere
15:19:39 <dmwit> Given the set B of buzzwords and T of technical terms, form the free monoid over B \cup T subject to the laws bb' = b (whenever b,b' \in B) and tt' = t (whenever t,t' \in T).
15:20:25 <xplat> Agile agile cloud-based agile webscale agile agile agile service-oriented agile architectures agile.  Agile.
15:20:37 <dmwit> companion_cube seems to be proposing a third law, "agile" = \epsilon, which seems plausible enough, though a further examination of the solution space is warranted in future work.
15:20:59 <Botje> xplat: now I want to see the chicken chicken chicken video done that way.
15:21:19 <sig> haskell vs c++?
15:21:26 <companion_cube> High-performance Clustered Cloud Haskell for Dynamic Entreprise web-3.0 Business Applications
15:21:30 <xplat> "do you have anything without agile in it?"
15:21:47 <companion_cube> agile chicken chicken agile agile chicken
15:21:49 <dobblego> how do I traverse a haskell source AST keeping state?
15:21:50 <dmwit> sig: embed Haskell in your C++ and call it a day
15:21:59 <companion_cube> chicken are naturally agile, anyway
15:22:42 <xplat> hence chicken scheme
15:22:48 <sig> nice
15:23:22 <mizu_no_oto> Are there any good texts on Category Theory from a fp perspective?  Say, something that deals mostly with Monoids and their properties, or particularly interesting properties of groups from a fp perspective?
15:24:08 <companion_cube> I'd suggest "Learn You a Cloud Haskell for Great Distributed Good"
15:24:36 <mizu_no_oto> Geh.  Abstract Algebra, not Category Theory
15:27:14 <luite> hmm i wonder how many pages one could write about the properties of monoids in functional programming
15:27:28 <dmwit> Actually, the monoid laws are basic enough that you don't really get any interesting properties out of them.
15:27:37 <dmwit> You need more than just a monoid structure to get interesting things to happen.
15:27:53 <mizu_no_oto> So it's only groups where interesting things start to happen?
15:27:53 <luite> i guess you can give a few examples, but can't think of much more :)
15:27:58 <c_wraith> There are *some* interesting things.
15:28:15 <dmwit> mizu_no_oto: There are intermediate structures -- more than monoids, not yet groups -- that have interesting properties.
15:28:18 <Cale> The theory of monoids is basically the theory of formal languages
15:28:20 <c_wraith> For instance, associativity means that careful construction (tree-shapes, in particular) allow parallel processing much more efficiently
15:28:23 <dmwit> Dunno of a good reference exploring these, though.
15:28:24 <Cale> which is very interesting
15:28:32 <Cale> but also very hard
15:29:08 <luite> hmm, i remember some monoid structure being exploited for incremental (re)parsing
15:29:25 <Cale> Regular languages are preimages of subsets of a finite monoid under a homomorphism from a free monoid :)
15:29:29 <madjestic> hey guys, how do I specify a default ghc version?  I've got 6.10.4 used by default, but I have installed 7.4.1, however ghc --version still gives me 6.10.4, I would like to swtich to 7.4.1
15:29:46 <dmwit> madjestic: Just update the symlinks.
15:30:07 <dmwit> ghc, ghc-pkg, haddock, etc. are just symlinks to ghc-6.10.4, ghc-pkg-6.10.4, haddock-ghc-6.10.4, etc.
15:30:38 <dmwit> Use "which ghc" to see where those links live.
15:30:46 <mizu_no_oto> I have to do a "project" for a Abstract Algebra course I'm currently taking, and was thinking of doing it on something more applicable to CS than most of the stuff in the course
15:30:49 <madjestic> thanks
15:31:16 <dmwit> That sounds like fun!
15:32:22 <tgeeky> mizu_no_oto: Write some haskell code to check presentations and generators from http://brauer.maths.qmul.ac.uk/Atlas/v3/
15:33:00 <QinGW> dunno if eselect can work for it
15:33:23 <mizu_no_oto> It's something like extending the results of a paper, filling in some blanks, or doing something that we haven't really covered - Sylow Theorems were one suggestion.  Can anyone point me to something that might be interesting for it?
15:33:55 <mizu_no_oto> c_wraith:  You mentioned "some interesting things" about monoids.  Could you expand on that?
15:34:10 <c_wraith> mizu_no_oto: see the "for instance" right afterwards
15:34:33 <mizu_no_oto> >_<
15:40:00 <tgeeky> mizu_no_oto: that have interesting properties.
15:40:00 <tgeeky> 18:27 < Cale> The theory of monoids is basically the theory of formal languages
15:40:02 <tgeeky> argh
15:40:07 <tgeeky> mizu_no_oto: http://www.mscs.dal.ca/~selinger/papers/graphical.pdf
15:43:24 <dmwit> Monoidal categories typically go significantly beyond having only the structure of a monoid.
15:43:47 <dmwit> I'm really jealous that you thought to link that and I didn't, though.
15:44:04 <dmwit> tgeeky++
15:44:55 <tgeeky> dmwit: I haven't read it yet, but just from skimming it looks wonderful.
15:45:20 <tgeeky> I just referenced it from the negative and fractional paper.
15:49:42 <hayashi> @pl \x y -> f x y a >>= g x y b >>= h x y c
15:49:42 <lambdabot> ap (ap . ((>>=) .) . ap (ap . ((>>=) .) . flip flip a . f) (flip flip b . g)) (flip flip c . h)
15:50:01 <hayashi> Well, ain't that a glorious mess.
15:50:15 <Botje> so pretty
15:50:20 <hayashi> Thinking about it
15:50:35 <hayashi> @pl \x y -> f x y >>= g x y >>= h x y
15:50:36 <lambdabot> ap (ap . ((>>=) .) . ap (ap . ((>>=) .) . f) g) h
15:50:36 <jfischoff> tgeeky: what did you think of the fractional type paper?
15:50:48 <hayashi> Nope.  Not even close.
15:51:28 <tgeeky> dmwit: it would seem to me like an admirable goal to somehow leverage some sort of invertible (parsing/printing?) system for mapping the definitions used in (negative/fractional) and this paper, with the corresponding diagrams (using diagrams!) for *at least* documentary (if not interactive) use
15:52:22 <tgeeky> jfischoff: very good. I think it's more interesting tham it seems at first sight.
15:54:10 <tgeeky> dmwit: it might be the kind of thing that could be done as a group at hac/phi, if there is enough framework to do it before it starts. August is pretty far off.
15:54:53 <jfischoff> tgeeky: Yeah, I don't think they set out to make a more expressive type system, but it solved a need. I can dig up the link to the Pi language code if you are interested
15:55:48 <jfischoff> tgeeky: its an earlier version in haskell
15:56:20 * hackagebot shelly 0.7 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.7 (GregWeber)
15:56:28 <tgeeky> jfischoff: and as a physicist at heart, the possibilities of how their analogies might be refined to be more modern, intruigue me
15:56:55 <tgeeky> jfischoff: sure. that might help. I intended to actually work on implementing this paper tonight.
15:58:10 <jfischoff> tgeeky: http://www.cs.indiana.edu/~sabry/papers/Pi.hs
15:58:57 <jfischoff> tgeeky: if you make a parser I'll make a quasiquoter :)
15:59:12 <tgeeky> hehe.
16:00:03 <adimit> A question about haddock: say I want a highlight to link to 'Data.Text.Text' but I'm not actually importing 'Data.Text' is there a way to do that?
16:01:08 <dmwit> tgeeky: It's a bit tricky, because the graphical language is designed to hide a lot of the details required to construct terms in the sequential language.
16:01:37 <dmwit> tgeeky: (Especially when there are wires whose types are not 1.)
16:01:52 <dmwit> ...or 0 I suppose
16:02:17 <tgeeky> dmwit: hehe. draw text, make it small, and color it white :O
16:02:23 <tgeeky> or color=bkgcolor
16:03:22 <tgeeky> dmwit: in all seriousness, yeah, I think it will be hard.
16:05:32 <dmwit> tgeeky: Let's put something on github. I started an evaluator, we shouldn't duplicate work. =)
16:05:51 <tgeeky> dmwit: yay! and github yay!
16:09:17 <dmwit> tgeeky: https://github.com/dmwit/pi-eta-epsilon
16:09:22 <tgeeky> dmwit: already found it :)
16:09:32 <tgeeky> dmwit: this code is *screaming* to be written in a multiplate
16:10:42 <tgeeky> dmwit: very nice.
16:10:47 <dmwit> okay, multiplate away
16:10:59 <jfischoff> dmwit++
16:15:19 <dmwit> Okay, gotta run for the night.
16:15:21 <dmwit> See you around.
16:17:00 <mm_freak_> edwardk: would you recommend trifecta for productive applications?
16:17:10 <edwardk> yes
16:17:10 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
16:17:42 <shachaf> Hey, it's edwardk.
16:18:00 <alpounet> "would you use trifecta in a critical program for a space shuttle?"
16:18:00 <edwardk> preflex: xseen roconnor
16:18:00 <preflex>  roconnor was last seen on freenode/#haskell 3 days, 11 hours, 9 minutes and 26 seconds ago, saying: It seems like in practice every dioid will be a kleene algebra. ... I can't really think of any dioid that isn't.
16:18:21 <edwardk> alpounet: sure. just because it'd be cool to say i wrote something that was used on the space shuttle
16:18:51 <edwardk> @tell roconnor could you bump the dependency bounds on data-lens-fd and data-lens-template to allow the current data-lens versions?
16:18:52 <lambdabot> Consider it noted.
16:18:55 <mm_freak_> edwardk: is there an obvious advantage over parsec?  and does it support incremental parsing?
16:19:27 <mm_freak_> i was going for attoparsec, but that one doesn't support source code positions
16:20:10 <mm_freak_> ok, the second question is answered i think
16:24:20 <mm_freak_> the problem i have with trifecta is that the parser type is really scary
16:24:33 <edwardk> mm_freak_: yeah i'm hoping to simplify that
16:24:52 <edwardk> its a little too parameterized right now, and most users don't care about the flexibility
16:25:07 <copumpkin> newtype wrappers ftw!
16:25:43 <mm_freak_> edwardk: what's the rationale for trifecta?  think of someone parsing a programming language
16:25:54 <mm_freak_> i.e. why would i choose it over parsec?
16:25:55 <c_wraith> the problem I have with trifecta is looking at the giant list of type signatures, and going "I have no clue what these do" :)
16:26:17 <tgeeky> edwardk: plus you can rest easy knowing that it will never need to fly again. *sad panda bear*
16:26:54 <mm_freak_> edwardk: don't get me wrong…  i love your libraries, just /because/ they use new ideas in elegant ways =)
16:27:01 <Philippa> mm_freak_: trifecta is a pretty major step in parsing tech from where I'm standing, FWIW. The way it supports incremental parsing is almost hilarious
16:27:16 <nonefool_> http://hpaste.org/67970 <-- can anybody help me find out why the rewrite rule doesn't fire?
16:27:36 <edwardk> mm_freak_: the main advantages of trifecta are that it never lies about where the parse error occurred (unlike parsec), it provides much nicer error reporting functionality including clang-style fixits, you can apply monad transformers to parsers and still get a parser, you can easily mixin additional parser transformers to get support for things like layout, or literate programming
16:28:06 <mm_freak_> i see
16:28:15 <mm_freak_> is there some documentation or a tutorial somewhere?
16:28:18 <edwardk> mm_freak_: and you get a lot of support making it easier to build all the crap you build after the parser, such as syntax highlighting, etc.
16:28:42 <edwardk> mm_freak_: the closest you'll find to a good worked example is probably dylukes: winchester STG
16:29:12 <edwardk> mm_freak_: i'd been planning on finishing the refactoring i want to do to the diagnostics subsystem before i wrote a tutorial
16:29:19 <eviltwin_b> doesn't that rewrite rule need a type?  not enough to just say addFoo = addFooDouble, needs the type context in which to do it (remember, typeclasses are open)
16:29:27 <edwardk> mainly i want to lobotomize the diagnostics types, because they are overly confusing right now
16:29:42 <edwardk> and nobody uses the extra functionality that the extra type arguments for them provide
16:30:55 <edwardk> woot. i now have order statistics working in multipass
16:31:35 <mm_freak_> edwardk: my big problem is that i can't really use the token functionality of parsec…  my language is going to be a bit more complicated than that
16:32:20 <mm_freak_> think of agda on steroids =)
16:32:23 <edwardk> mm_freak_: yeah. i can see how that is a bit of a problem, but a user token type causes all sorts of problems with the diagnostic reporting
16:32:37 <mm_freak_> hmm
16:32:45 <mm_freak_> perhaps i should write a custom special purpose parser
16:32:47 <sm> would any of you know a windows app that makes viewing markdown, with table of contents, easy ?
16:33:06 <mm_freak_> sm: pandoc it into HTML
16:33:27 <sm> I just tried pandoc for windows, but I think these folks will need a gui
16:34:00 <mm_freak_> sm: pandoc --toc -o blah.html blah.txt
16:35:39 <nonefool_> eviltwin_b: my rewrite rule syntax knowledge is a bit fuzzy. What would a rule with the necessary annotations look like?
16:37:31 <edwardk> mm_freak_: for what it is worth you can parse mixfix pretty readily with trifecta. and i've got a branch of it lying around with support for leaf level packrat to memoize parsing combinators like agda does
16:38:18 <edwardk> mm_freak_: i want to get the revision control monad working better and see if i can drive that functionality off of a revision controlled symbol table rather than my current approach though
16:39:14 <acowley> So I'm tripping over something stupid. I have these mutually recursive types: newtype F c a = F ([T c a]) and data T c a = L c a | N c (F c a)
16:39:55 <mm_freak_> edwardk: i wanted to experiment with an automaton-based approach to parsing anyway, so this is the opportunity to do it =)
16:40:04 <acowley> and I'm also grappling with some of Conal's things on zippers and derivatives and whatnot, but I don't know how to treat these guys using the usual Fix machinery for functors.
16:40:32 <edwardk> fair nuff. you may want to read my old trifecta slides, which were on a technique that was much more suited to parallel parsing
16:40:41 <geekosaur> grh, sorry, I misunderstood what was going on.  I am not sure that will work though (any more than I am that this will; notwork here sucks)
16:40:52 <acowley> My life is made harder by the extra "c" parameter, but I think I need it :(
16:41:05 <mm_freak_> edwardk: well, my idea had similar goals:  vertical composability of parsing
16:41:35 <mm_freak_> write a simple grammar, then add layout and spacing transparently
16:41:49 <acowley> Actually I can use type F c = [] :. T c (with (:.) as functor composition)
16:42:06 <acowley> but I'm still wrapped around myself and pointing in an unknown direction
16:42:55 <edwardk> mm_freak_: http://comonad.com/reader/wp-content/uploads/2009/08/A-Parsing-Trifecta.pdf talks a bit at the end about how you can use a dyck language skeleton (or visibly pushdown language skeleton to borrow philippa's preferred terminology) to eke out more parallelism from parsing. i've had some success using a mixture of that and my speculation combinators
16:44:51 <mm_freak_> edwardk: let me write a small test…  i think with my technique you get parallelism for free
16:45:18 <edwardk> feel free. we can talk later. i need to run
16:45:32 <mm_freak_> ok, thanks for the pointer
16:45:35 <mm_freak_> have fun =)
16:45:41 <edwardk> i have had a few parallel parsers over the years, each one of them has disappointed me for different reasons
17:04:41 <acowley> I now have several hundred lines of code that type check but I have absolutely no idea how to use
17:04:51 <acowley> achievement…. unocked?
17:09:39 <hpc> @quote understand
17:09:39 <lambdabot> AlanPerlis says: It is easier to write an incorrect program than understand a correct one.
17:09:44 <hpc> hmm
17:10:08 <hpc> TuringTest says: They got it work in Haskell without understanding Haskell.  It is quite an achievement, of some description.
17:10:39 <acowley> So incomprehensibly correct is something to aim for?
17:10:50 <hpc> that's what oleg does
17:10:54 <hpc> it's what edwardk does
17:11:00 <hpc> so it must work pretty well
17:11:03 <hpc> ;)
17:11:22 <acowley> I always assumed that they could comprehend what they say! You have opened my eyes.
17:11:54 <acowley> So the trick is to keep adding correctness until you have no idea what the code does, then dump it undocumented somewhere?
17:12:05 <hpc> yep
17:19:56 <acowley> has anyone here defined a regularization into sums and products for a composition of regular functors?
17:24:05 <Steve|Office> If my haskell program segfaults, can I assume it is running out of memory?
17:24:32 <hpc> no
17:24:34 <acowley> Steve|Office: not in general
17:24:37 <hpc> OOM is different from segfaulting
17:24:44 <randomclown> So I have this GADT which represents Java objects on the jvm stack. Is it ok to pass undefined into to the constructor when I just want to represent the type of the expression?
17:24:45 <randomclown> http://hpaste.org/67983
17:25:24 <Steve|Office> Well, if it uses malloc() and fails to check for NULL return values, then it would segfault.
17:26:58 <alpounet> randomclown, as long as it doesn't get evaluated, it's fine
17:27:10 <alpounet> even if there are stuffs like the tagged package
17:27:36 <randomclown> alpounet is that standard procedure>
17:27:45 <randomclown> or do people normally do it differently?
17:28:04 <alpounet> i believe tagged is the "standard" solution
17:28:20 <alpounet> or at least, people implement the Proxy type of that package, if they don't use the package
17:28:56 <alpounet> it's never a good idea to have a "undefined" value hanging around in a library or app... just imagine someday you change a function, and a side effect would be that this undefined would somehow get evaluated
17:30:39 <acowley> The more code I add the deeper this hole gets. The types aren't speaking to me!
17:31:05 <copumpkin> hmm
17:31:12 <copumpkin> acowley: listen harder
17:31:16 <hpc> acowley: quick, add more code!
17:31:20 <acowley> randomclown: I agree with alpounet. There are times when tagged or undefined are appropriate, but there may be a better way to approach your problem
17:31:35 <hpc> you should waterboard your types
17:31:38 <hpc> they'll talk in no time
17:31:48 <acowley> Well, what I'm doing is trying to write down some values of the types that are trying to strangle me
17:31:51 <acowley> and now I have some values
17:31:57 <acowley> but they don't make any sense to me
17:32:09 <hpc> acowley: can you paste the types, perhaps?
17:32:13 <acowley> which also tends to hurt my ability to give good names to things
17:38:09 <acowley> hpc: I'm trying to work with zippers of something like a nested rose tree
17:38:21 <hpc> eeeew
17:38:24 <acowley> hpc: So I'm using Conal's Regular class with its PF type family
17:38:35 <acowley> and I have types like, PF (Forest (Sum Int) (Int,Int)) (Zipper' (Forest (Sum Int) (Int,Int)))
17:39:47 <hpc> acowley: if (Forest (Sum Int) (Int,Int)) is a prominent thing in your program, give it a name
17:39:59 <hpc> that's the one thing that stands out to me from just that line
17:40:09 <hpc> acowley: if (Forest (Sum Int) (Int,Int)) is a prominent thing in your program, give it a name -- if you didn't get that
17:40:45 <acowley_> well
17:40:59 <acowley_> that's just an annotation I wrote out so I could begin to have to a clue what my example value was
17:41:24 <acowley_> I'm getting messed up because I don't have a Regular instance for compositions of regular functors
17:42:25 <acowley_> I can write out specific instances, but haven't quite cracked the general case, in part because I don't really get what PF is doing actually
17:57:04 <acowley> Well, my incomprehensibly correct code diverges. I should have seen that coming.
18:06:30 <Steve|Office> okay, it's probably not running out of memory. It never got above 12 GB that I saw in top. Does this mean it's a bug in the compiler?
18:13:10 <aristid> is it possible to add a class constraint to an associated type right in the class where the associated type is defined? specifically, i'd like to from any instances that there be a Monoid instance for the type
18:14:56 <aristid> *to demand
18:15:09 <tgeeky> hehe I kept re-reading "to from to from to from.. to from what!?"
18:15:17 <aristid> sorry:)
18:15:35 <aristid> sometimes i forget to actually type one of those words oO
18:16:28 <dmwit> class Monoid (T m) => Foo m where type T m
18:16:58 <aristid> dmwit: thanks, will try that
18:17:05 <dmwit> If the question was "can you do that", the answer is yes; if the question was "how do you do that", then the answer is what I wrote above.
18:17:08 <dmwit> =)
18:20:46 <aristid> dmwit: thanks, it works just fine. i'm not particularly fond of having to write the constraint before the associated type is even introduced, but i guess that's just the way it is
18:27:48 <acowley> Given two equations PF x = PF y, and PF y = t, I still need a constraint PF x ~ PF y hanging about in critical places.
18:47:24 <acowley> I write the most complicated bottoms
18:48:11 <zzo38> I made Prelude.Generalize but please tell me in case you have suggestion and/or complains too.
18:49:35 <zzo38> class Peanoid x where { zeroP :: x; succP :: x -> x; }; class Copeanoid x where { predP :: x -> Maybe x; }; class Function f i o | f -> i, f -> o where { ($) :: f -> i -> o; infixl 0 $; }; class Swap f where { swap :: f x y -> f y x; }; bool :: x -> x -> Bool -> x; (<>>=) :: (Functor m, Monad m) => m a -> (a -> m b) -> m a; tail :: MonadLogic m => m x -> m x; (!!) :: (Copeanoid i, Foldable t) => t x -> i -> x;    and so on.
18:51:44 <dstcruz> @remember acowley I write the most complicated bottoms
18:51:44 <lambdabot> Good to know.
18:52:48 <otters> copeanoid
18:55:10 <parcs`> zzo38: fyi you can condense | f -> i, f -> o to | f -> i o
19:05:39 <zzo38> parcs`: OK.
19:06:20 <zzo38> Here is the entire file so far:   http://sprunge.us/WZOd
19:09:02 <xil> hey everyone. So I have a binary tree in the form of an Array Int (Int,Int) and I have a function http://hpaste.org/67990 that returns the shortest path to a leaf; it's just for example. If you notice, I pass a list down recursively adding to it at each node. My question is: does each recursive level receive a deep copy of the list, or are all levels referencing the same tails in memory (when they have the same tails)? That is, does each 
19:12:18 <aristid> @quote bottom
19:12:19 <lambdabot> xerox says: I am really interested specifically in bottoms in this very moment.
19:12:44 <xvilka_> hello! i'm try to choose second scripting language for my binary data analisys framework (already have lua (for simple scripts) and python (for more complex)). Need to choose language for _really_ comple logic. Do you think haskell good for that?
19:13:58 <tromp_> how is python failing you there?
19:14:06 <xvilka_> this framework == some kind of wireshark + ida pro, but for static binary data (some files)
19:14:56 <xvilka_> tromp_: it is ok, wonder may be haskell is better, if you have any arguments
19:16:55 <tromp_> if you're new to haskell, you may want to work on simpler problems first
19:18:20 <xvilka_> yes. it is long-state goal, anyway.
19:18:58 <tromp_> haskell is a most worthwhile learning experience anyway
19:19:47 <tromp_> once you become more familiar, you'll know how well it fits you and your analysis programs
19:34:26 <copumpkin> preflex: seen ddarius
19:34:26 <preflex>  ddarius was last seen on #haskell 55 days, 26 minutes and 53 seconds ago, saying: BMeph: No.
19:42:16 <parcs`> what happened to ddarius
19:42:29 <copumpkin> busy I guess :)
19:42:38 <otters> @pl \a b
19:42:39 <lambdabot> (line 1, column 5):
19:42:39 <lambdabot> unexpected end of input
19:42:39 <lambdabot> expecting pattern or "->"
19:42:45 <otters> @pl \a b -> (f a) ++ (f b)
19:42:45 <lambdabot> (. f) . (++) . f
20:07:06 <zzo38> catMaybes becomes concat, listToMaybe becomes convList, maybeToList also becomes convList, isNothing becomes null, findIndices becomes findIndex, etc
20:08:21 <JoeyA> What happens when you go from the Maybe monad to the List monad?  (I'm playing Jeopardy)
20:09:16 <JoeyA> Type classes, for 500 please.
20:10:09 <zzo38> You can go from Maybe to any Alternative:  maybe empty pure   but this program converts from any Foldable to any Alternative, and Maybe is Foldable as well as Alternative.
20:11:25 <zzo38> Foldable allows you to read the order of the elements and Alternative allows you to write the order of the elements
20:12:16 <zzo38> Many functions can be generalized to different classes:   tail :: MonadLogic m => m x -> m x;
20:13:09 <zzo38> Many functions can be generalized to different classes:   tail :: MonadLogic m => m x -> m x;   (!!) :: (Copeanoid i, Foldable t) => t x -> i -> x;   length :: (Peanoid i, Foldable t) => t x -> i;   filter :: MonadPlus m => (x -> Bool) -> m x -> m x;   iterate :: Alternative f => (x -> x) -> x -> f x;   head :: Foldable t => t x -> x;   drop :: (Copeanoid i, MonadLogic m) => i -> m x -> m x;
20:14:08 <zzo38> take :: (Copeanoid i, MonadLogic m) => i -> m x -> m x;   find :: (Alternative f, Foldable t) => (a -> Bool) -> t a -> f a;   tails :: MonadLogic m => m x -> m (m x);   findIndex :: (Peanoid i, Alternative f, Foldable t) => (a -> Bool) -> t a -> f i;   repeat :: Alternative f => x -> f x;   null :: Foldable t => t x -> Bool;   concat :: (MonadPlus m, Foldable f) => m (f x) -> m x;
20:15:12 <Cale> copeanoid :)
20:15:23 <zzo38> Cale: What about copeanoid?
20:15:30 <Cale> interesting name
20:15:39 <Cale> I think I understand what it means without having heard it before
20:16:03 <zzo38> Cale: Yes, probably the type signatures can also give you a hint what it means
20:16:52 <Cale> Peanoid would be things which have Peano-arithmetic zero and successor, Copeanoid would be things which can be decomposed like that.
20:17:04 <zzo38> Cale: Yes.
20:23:26 <parcs`> zzo38: for maximum abstraction you should unify all type classes into one: http://okmij.org/ftp/Haskell/TypeClass.html#Haskell1
20:23:26 <zzo38> But I also want to know what kind of optimization you can suggest too
20:23:43 <zzo38> parcs`: I have seen that already
20:24:28 <parcs`> what do you think of it
20:25:20 <zzo38> parcs`: I think it is good for describing how it is possible to do so; in most cases there is not really a reason to make it done.
20:26:25 <zzo38> But I do like these kind of things, even if they would not ordinarily be used.
20:27:33 <zzo38> The reason I am not changing existing typeclasses is because of compatibility reasons.
20:29:45 <zzo38> (But I would like the classes changed; but Haskell does not offer a good way to change them while leaving them as they are. Ibtlfmm has this feature and I can then invent the classes differently; but Ibtlfmm is not invented yet.)
20:37:34 <zzo38> But I do suppose you can use that unify of all type classes, in some cases can be used as substitute for constraint kinds.
20:38:47 <zzo38> (Since I do want to be able to have categories where the types for the objects are restricted to specified class)
20:54:45 <zzo38> Why do I get an error message when I try to use a INLINABLE pragma? It says that the next line after the pragma is wrong.
20:57:38 <zzo38> bool :: x -> x -> Bool -> x; bool x _ False = x; bool _ x True = x; {-# INLINABLE bool #-} (<>>=) :: (Functor m, Monad m) => m a -> (a -> m b) -> m a;   But they are on separate lines. It says the ( in (<>>=) is wrong
20:59:21 <shachaf> zzo38: Works for me.
20:59:46 <shachaf> As the old saying goes, "maybe you should @paste your exact code, zzo38".
20:59:49 <zzo38> shachaf: Then why doesn't it work for me?
21:00:18 <zzo38> The code is this one   http://sprunge.us/WZOd   but I have added a pragma after the definition of bool
21:01:01 <zzo38> I also try to add RULES pragma to tail (!!) length but get similar error
21:01:25 <shachaf> Maybe you should make a smaller test case and @paste that. :-)
21:03:44 <zzo38> I found the mistake
21:04:00 <shachaf> No ; after the #-}?
21:04:08 <zzo38> I fixed it. The mistake is that I needed a semicolon after the pragma
21:04:20 <shachaf> Right. Makes sense.
21:04:31 <zzo38> But I thought a pragma is supposed to be like a comment syntax?
21:05:35 <zzo38> And you do not need a semicolon after a comment.
21:06:26 <shachaf> I guess not.
21:07:15 <jfischoff> are there any haskell/cabal project wizards?
21:08:00 <gienah> jfischoff: cabal init
21:08:35 <jfischoff> gienah: which is great, but there still is a lot repetitive work.
21:09:11 <jfischoff> all the folder making. creating a .ghci file, I test exe , etc..
21:09:43 <gienah> yeah haskell porgrammers are lazy
21:09:50 <shachaf> Oh, I thought jfischoff was looking for a person.
21:10:17 <jfischoff> I am. I'm look dimwit.
21:10:21 <jfischoff> dmwit
21:10:50 <jfischoff> shachaf: but I am also making a project
21:11:56 <jfischoff> shachaf: https://github.com/dmwit/pi-eta-epsilon/blob/master/dualities.hs
21:22:25 <nyingen> @quote
21:22:26 <lambdabot> newsham says: haskell's like chess.  easy to learn. hard to master.
21:24:08 <Dread> @quote
21:24:09 <lambdabot> ivanm says: Axman6: the premature optimisation quote is misquothed
21:26:10 <xil> hey everyone. So I have a binary tree in the form of an Array Int (Int,Int) and I have a function http://hpaste.org/67990 that returns the shortest path to a leaf; it's just for example. If you notice, I pass a list down recursively adding to it at each node. My question is: does each recursive level receive a deep copy of the list, or are all levels referencing the same tails in memory (when they have the same tails)? That is, does each 
21:27:13 <gienah> xil: you were cut off after "That is, does each"
21:27:23 <xil> That is, does each node in the tree basically only add 1 element in memory, since lists are linked lists right?
21:33:56 <sgronblo> Ok, I was still too stupid to figure out how to use quickchecks forAll
21:35:17 <dmwit> jfischoff: pong
21:35:27 <dmwit> No structure yet, feel free to make one.
21:35:35 <dmwit> (Didn't really think it needed one yet... =P)
21:36:48 <dmwit> re: the lack of polymorphism
21:36:52 <jfischoff> dmwit: great
21:37:01 <dmwit> I would imagine there's a separate phase that takes an untyped term and infers a typed term from it.
21:37:05 <dmwit> Shouldn't be hard, just haven't done it.
21:37:19 <jfischoff> jfischoff: I think it is something that can be added later
21:37:21 <dmwit> re: both associates (R/L)... I'm not sure what this one means.
21:38:35 <dmwit> (Also, did you intend for those comments to be haddock comments? They don't seem like the kind of thing you'd want to appear in documentation...)
21:38:56 <jfischoff> dmwit: no no it was a note to you.
21:39:27 <jfischoff> dmwit: I will have lots of questions, some dumb along the way
21:39:58 <dmwit> Me, too, I'm sure. =P
21:40:36 <tgeeky> dmwit: I'm going to try to propose a regex-like renaming of types to make the code look prettier when aligned. hopefully I can demonstrate soon :o
21:40:58 <dmwit> Can you explain what the "both associates" question is about?
21:41:33 <jfischoff> dmwit: http://www.cs.indiana.edu/~sabry/papers/Pi.hs
21:41:37 <jfischoff> have you seen that?
21:41:51 <dmwit> tgeeky: ...oh, alignment.
21:42:12 <dmwit> Now I'm working with other people, I may not get to use tabs for indentation and spaces for alignment. =/
21:42:13 <jfischoff> dmwit: they use the associative identity as an operation
21:42:42 <jfischoff> and have both left and right version for the sum and product types
21:42:59 <dmwit> Oh, as for that, we have Introduce (AssociativeS blah) and Eliminate (AssociativeS blah).
21:43:08 <dmwit> likewise for AssociativeP
21:43:16 <jfischoff> dmwit: nice
21:43:42 <dmwit> likewise for all base isomorphisms, actually, I didn't like their naming scheme where they had to invent two names for every isomorphism
21:43:50 <tgeeky> dmwit: My gut tells me that's not enough? Unless you have two Introduce types and two Eliminate types
21:43:50 <jfischoff> dmwit:okay back to the parser. I will send you a pull I guess with the project structure
21:43:54 <dmwit> It seems wasteful.
21:44:04 <jfischoff> dmwit: agreed
21:44:14 <dmwit> tgeeky: Why isn't it enough?
21:44:19 <jfischoff> brb
21:44:33 <tgeeky> dmwit: because you want to truly keep track of left-moving things and right-moving things seperately
21:44:54 <dmwit> tgeeky: We do, in the MachineState.
21:44:55 <tgeeky> they use chiral versions of everything for some reason (I presume it's to do just this)
21:45:01 <dmwit> tgeeky: It's just a renaming.
21:45:17 <dmwit> tgeeky: What they call AssocPlusL and AssocPlusR we call Introduce (AssocPlus) and Eliminate (AssocPlus).
21:45:22 <dmwit> There's nothing deeper than that.
21:45:41 <dmwit> Likewise what they call, e.g., Distribute and Factor we call Introduce (Distributive) and Eliminate (Distributive).
21:45:52 <dmwit> It's exactly the same, just with fewer names to remember.
21:46:12 <dmwit> name the law, not the operation
21:46:46 <tgeeky> dmwit: hehe. I think this is why I am differing. I want to name the operation, so I can see how this works when we relax (or break) the law
21:47:03 <tgeeky> but conceptually for now I like yours much better
21:58:29 <jfischoff> dmwit: do you have a newer version than the one on github?
22:02:09 <dmwit> No.
22:03:00 <jfischoff> great
22:16:55 <thelastnode> hey all, if I wanted to learn how to use quickcheck, what's a good source?
22:17:02 <thelastnode> and which version should I use?
22:17:56 <xil> hey everyone. So I have a binary tree in the form of an Array Int (Int,Int) and I have a function http://hpaste.org/67990 that returns the shortest path to a leaf; it's just for example. If you notice, I pass a list down recursively adding to it at each node.
22:18:00 <xil> My question is: does each recursive level receive a deep copy of the list, or are all levels referencing the same tails in memory (when they have the same tails)? That is, does each node in the tree basically only add 1 element in memory, since lists are linked lists right?
22:20:04 <monochrom> same tails in memory
22:20:15 <dmwit> Dunno what you mean by tails, but "tree" will be a pointer to the same array throughout all the recursive calls.
22:20:32 <dmwit> Oh, you were talking about the returned values?
22:20:36 <dmwit> Yes, same tails.
22:20:39 <dmwit> thelastnode: The latest version.
22:20:46 <dmwit> Dunno what the best intro guide is.
22:21:17 <monochrom> the question can be rephrased as: does path' share with path
22:21:56 <monochrom> my http://www.vex.net/~trebla/haskell/lazy.xhtml shows sharing
22:22:50 <monochrom> it is the best guide because there is no other guide at all. (apart from a few dead-tree books)
22:23:48 <monochrom> yes, please be appalled at the sorry state of lazy evaluation tutorials because everyone tries so hard to be politically correct and sticks with the totally uninformative "non-strict"
22:24:13 <dmwit> Hey, that's not true!
22:24:21 <dmwit> ezyang's guide to GHC memory management was pretty good.
22:29:55 <jfischoff> hmm not really a shortcut. I have a parser for the Types but it doesn't work with spaces…because I used buildExpressionParser
22:30:26 <xil> oh sorry, missed all of that. Let me catch up
22:31:32 <jfischoff> wait fixed it
22:32:18 <monochrom> if you use buildExpressionParser in conjunction with TokenParser, you can get it to work with spaces. my http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements has a complete example
22:33:02 <zzo38> I have now added the bind2 and bind3 functions, which are like liftM2 and liftM3 with join
22:33:34 <jfischoff> monochrome++ I might need that later but my tests passed
22:33:54 <jfischoff> onto the quasiquoter
22:36:53 <xil> monochrom: thanks, I'll read that guide
22:39:01 <jfischoff> hmm an I don't think I can use buildExpressionParser and do antiquoting
22:46:14 <frontendloader> https://gist.github.com/1cf6ba4af0a598df0501 is this doable in a single list comprehension? Input: [1,2,3] Ouput [(1,2),(1,3),(2,3)] i.e. unique combinations of 2.
22:48:20 <c_wraith> frontendloader: absolutely
22:48:40 <frontendloader> coddle me a little, but don't spoil it?
22:48:56 <c_wraith> start with generating all pairs of two values from the input
22:49:04 <frontendloader> and filter?
22:49:08 <c_wraith> Once you can do that, figure out how to restrict the output
22:53:55 <dmwit> frontendloader: You might like the function tails.
22:53:56 <dmwit> :t tails
22:53:57 <lambdabot> forall a. [a] -> [[a]]
22:54:16 <frontendloader> haven't run in to forall yet
22:54:28 <dmwit> You can ignore it.
22:54:40 <shachaf> It just means "∀".
22:54:53 <shachaf> (You can ignore it.)
22:54:53 <monochrom> haha
22:57:02 <zzo38> tails = duplicate  for lists as well
22:57:34 <frontendloader> I do not have a tails function
22:57:40 <shachaf> It's hidden.
22:57:46 <shachaf> @hoogle tails
22:57:47 <lambdabot> Data.List tails :: [a] -> [[a]]
22:57:47 <lambdabot> Data.ByteString tails :: ByteString -> [ByteString]
22:57:47 <lambdabot> Data.ByteString.Char8 tails :: ByteString -> [ByteString]
22:57:47 <frontendloader> though writing it wouldn't be hard
22:57:48 <zzo38> frontendloader: You will need to import it
22:57:54 <shachaf> You should write it!
22:58:09 * shachaf looks for context.
22:58:26 <shachaf> Oh.
23:00:11 <shachaf> frontendloader: List comprehensions are just a cute corner case of Haskell syntax.
23:00:20 <shachaf> They aren't something to aspire to when writing list-based code.
23:00:43 <zzo38> One way is like this:   (init . tails >=> \(h : t) -> (,) h <$> t)   But there may be other ways too.
23:02:06 <zzo38> You can try using list comprehensions too if you want to; I do not find list comprehensions useful.
23:02:34 <frontendloader> do they usually come down to "generate everything and filter"?
23:02:47 <frontendloader> because I'm not a fan of that style of comprehension
23:03:41 <monochrom> I am not either, but it's a popular beginner tactic for project euler problems.
23:03:46 <dmwit> No, there is a much more efficient way to do what you want to do.
23:03:59 <dmwit> You needn't generate any but exactly the tuples you want.
23:04:11 <monochrom> find the sum of all even primes. "oh, I know, I'll use list comprehension"
23:04:26 <frontendloader> ha that was my first thought
23:04:40 <zzo38> monochrom: What a dumb we can answer it easily without using much of anything
23:04:50 <frontendloader> I wrote a sieve in C++ back when I was learning that and thought "Wow I'll bet I can do that in one list comp in haskell" the first time I looked at it.
23:05:04 <frontendloader> was still in the "haskell is magic" phase
23:05:11 <monochrom> makes project euler the most popular way to write brutally brute-force algorithms
23:06:17 <jfischoff> dmwit: https://github.com/jfischoff/pi-eta-epsilon
23:06:26 <shachaf> monochrom: *All* the even primes? Is that even, like, *possible* to do in finite time?
23:06:38 <shachaf> Better to say "under a million" just to be on the safe side.
23:06:57 <monochrom> under a googoplex
23:07:02 <zzo38> Why do you use list comprehensions a lot in Haskell? I have written some Haskell programs and never needed it or find it useful
23:07:23 <frontendloader> I'm used to using them from python.
23:07:25 <monochrom> "because it looks like I'm doing math"
23:07:38 <frontendloader> the syntax is somewhat familiar
23:08:36 <zzo38> frontendloader: O, it is because you program in Python. I have only done very few things in Python and haven't use (or even known about) list comprehension
23:08:48 <dmwit> jfischoff: wow, cool
23:09:37 <dmwit> jfischoff: Oh, you should just go ahead and delete dualities.hs if it's been copied into Language.PiEtaEpsilon.Syntax
23:10:10 <jfischoff> dmwit: will do.
23:10:58 <jfischoff> its missing a pattern quasiquoter
23:11:09 <zzo38> Would you do the making pairs of the list in the way I have specified or would you do it in a different way?
23:11:17 <jfischoff> and antiquates and all the other expression :)
23:11:42 <jfischoff> antiquotes
23:13:30 <Cale> > [(x,y) | (x:xs) <- tails [1,2,3], y <- xs]
23:13:31 <lambdabot>   [(1,2),(1,3),(2,3)]
23:13:45 <mm_freak_> wow, parsing dependently typed lambda calculus is a nightmare
23:14:02 <Cale> zzo38: ^^ that's the usual list comprehensiony way :)
23:14:49 <Cale> mm_freak_: why is that?
23:15:04 <Cale> I would expect it to be not so much harder than parsing normal lambda calculus...
23:15:13 <zzo38> Cale: OK, so that is a way too and it works; but I don't like it much
23:15:56 <Cale> It makes good use of the semantics of pattern match failure in a list comprehension
23:16:22 <zzo38> Cale: Yes I can see that
23:16:33 <frontendloader> I can't get the empty case to work
23:16:45 <mm_freak_> Cale: you need very smart backtracking, because the feature that determines the result can come very late
23:17:00 <Cale> > [(x,y) | (x:xs) <- tails [], y <- xs]
23:17:01 <lambdabot>   []
23:17:22 <mm_freak_> Cale: for example (Set) -> Set vs. (A : Set) -> Set
23:19:18 <zzo38> > (init . tails >=> \(h : t) -> (,) h <$> t) [1,2,3]
23:19:19 <lambdabot>   [(1,2),(1,3),(2,3)]
23:19:30 <zzo38> > (init . tails >=> \(h : t) -> (,) h <$> t) []
23:19:32 <lambdabot>   []
23:20:32 <zzo38> It is the way that came to my mind.
23:21:40 <zzo38> The list comprehension way still is not a function as it stands (but can easily be made so)
23:23:26 <zzo38> How manyy people think of it in different ways?
23:24:22 <frontendloader> tails x = [x] ++ (tails . tail $ x) is this formatted right?
23:29:00 <dmwit> frontendloader: Just import Data.List.
23:29:05 <dmwit> It's already defined there.
23:29:19 <dmwit> And yes, that's formatted fine,  but the code is wrong. =P
23:30:25 <dmwit> > let f xs = [(x,y) | x:y:_ <- tails xs] in f [1..3] -- zzo38, this is the way that came to mind for me
23:30:26 <lambdabot>   [(1,2),(2,3)]
23:30:29 <dmwit> whoops
23:30:45 <dmwit> > let f xs = [(x,y) | x:rest <- tails xs, y <- rest] in f [1..3] -- zzo38, this is the way that came to mind for me
23:30:46 <lambdabot>   [(1,2),(1,3),(2,3)]
23:33:17 <frontendloader> whats wrong with that implementation of tails outside of me not including the edge case
23:34:33 <dmwit> Nothing else is wrong.
23:35:23 <dmwit> Might as well write x : foo instead of [x] ++ foo, but that's a style thing, not a bug. And you may prefer [x] ++ foo in many cases... depends what you want to emphasize.
23:56:01 <rodayo> Is there such a thing as an EOF character in haskell? I wanna check if getChar returns an EOF or not...
23:56:47 <shachaf> It'll probably throw an exception.
23:57:33 <rodayo> shachaf, having worked with exceptions yet...
23:58:14 <rodayo> I'm writing a brainfuck interpreter just to practise the basics. right now i'm reading a char then deciding what it is...
23:58:29 <shachaf> You could probably just use getContents or something...
23:58:34 <rodayo> if EOF is encountered i want the loop to stop
23:59:06 <rodayo> i was gonna get the input from stdin...not a file so...
23:59:39 <shachaf> So?
23:59:49 <shachaf> That ellipsis habit of yours seems habit-forming.
