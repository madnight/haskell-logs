00:39:41 <frontendloader> is there an apt repo for GHC >7.4.1
01:39:12 <Taneb> Hello
01:39:20 <Taneb> How can I get a keypress from input?
01:40:59 <donri> getChar
01:41:14 <Taneb> Does that work for arrow keys?
01:41:54 <ion> yes
01:42:44 <ion> You’ll probably have to use terminfo to know which escape sequences mean which keys.
01:45:36 <Taneb> Also, how long until I can start worrying about the Hackage guy?
01:45:39 <geekosaur> unpacking that:  an arrow key sends something like <ESC> [ C (ANSI/VTxxx right arrow), libraries such as hscurses know how to read them as single entities *and* give you access to a database of key definitions if you need to deal with them youself
02:11:32 <LambdaDusk> I know I have solved it once, but I can't remember how the hell I solved it. I am getting this error: "cabal: Couldn't read cabal file "ixset/1.0.3/ixset.cabal"", because the cabal file of ixset is somehow malformed. Now I can't compile any project using ixset, not even ixset < 1.0.3
02:11:36 <LambdaDusk> anyone can help me?
02:17:45 <Saizan> LambdaDusk: try cabal update
02:18:31 <LambdaDusk> Saizan: I just re-installed my entire haskell stack, with the ghc and such. Deleted .ghc and .cabal entirely and then made a cabal update
02:19:55 <Saizan> no idea then
02:20:04 <LambdaDusk> Saizan: Afaik it's a bug in cabal-install, but I can't install a new version of it, because something with base versions
02:20:52 <LambdaDusk> like this: http://pastie.org/3872462
02:21:49 <merijn> To get something to work with overloadedstrings I can get away with just "instance IsString foo where fromString = read", no?
02:22:20 <Saizan> LambdaDusk: try cabal install cabal-install-0.14.0
02:22:44 <Saizan> merijn: yes
02:23:21 <merijn> Saizan: Excellent :)
02:23:22 <Saizan> merijn: some will chase you with pitchforks for using a partial function in something used to desugar literals though
02:23:48 <merijn> Saizan: I say bollocks to them! :)
02:24:41 <merijn> I'm a firm believer of "Halt and Catch Fire" error handling for invariants :p
02:25:01 <LambdaDusk> Saizan: Thanks, that seems to install
02:25:30 <merijn> On semi-related note, is there a way to do "instance Something [Foo] where" without FlexibleInstances? I don't understand why the compiler complains at me...
02:25:36 <Saizan> they are firm believers of "a literal shouldn't crash"
02:25:54 <Saizan> merijn: no there isn't
02:26:25 <merijn> Saizan: Can you at least explain what it does and why thats necessary?
02:26:47 <Saizan> merijn: it lifts the restriction not allowing you to make such an instance
02:27:02 <Saizan> merijn: it's necessary because haskell2010 has that restriction
02:28:10 <merijn> (as for the "literals shouldn't crash thing", right now I just have 'read "blah"' instead of literals, which doesn't make the code any more robust, but makes it exceedingly tedious to write)
02:28:27 <merijn> Right, but why does it have that restriction? And which restriction is that?
02:28:43 <Saizan> the error message tells you
02:29:04 <Saizan> and it was there because they liked to be conservative about typeclasses
02:29:19 <bitonic> specifically, "All instance types must be of the form (T a1 ... an) where a1 ... an are *distinct type variables*"
02:29:33 <bitonic> merijn: I don't think there's a specific "why"
02:29:54 <merijn> bitonic: Yeah, I read that. But I don't understand why it wouldn't allow specific types instead of type variables...
02:30:00 <merijn> That makes no sense to me
02:30:19 <LambdaDusk> Saizan: Thanks, it compiles now!
02:30:53 <Saizan> LambdaDusk: cheers :)
02:31:13 <Saizan> merijn: think of how you do instance resolution, and you'll see why it makes implementation much easier
02:31:38 <bitonic> yeah, you just have to match the constructor
02:31:45 <merijn> right
02:35:04 <LambdaDusk> merjin:  The thing with those full types in the classes stems from haskell98, and I've read many people regard the class-system in haskell98 as not flexible enough
02:35:39 <bitonic> in practice, every used haskell implementation has Flexible* + MPTC + FunDeps
02:36:09 <merijn> In practice not many people care about things outside GHC ;p
02:36:15 <bitonic> that too...
02:41:05 <bitonic> merijn: btw, the fact that ScopedTypeVariable is not in the standard is much weirder
02:41:29 <bitonic> I'd expect that to be default behaviour
02:42:24 <opqdonut> yeah it is
02:42:30 <merijn> bitonic: heh, I never thought about that one before
02:46:50 <ski> bitonic : i'd prefer `PatternSignatures' ..
02:47:39 <bitonic> ski: was that STV before?
02:47:56 <ski> huh ?
02:48:20 <bitonic> ski: wasn't ScopedTypeVariable called PatternSignatures before?
02:48:29 <Eidel> I get Not in scope: type constructor or class `Empty' when I try to use a datatype with the constructor Empty (in another file). I have imported the correct module.. anyone?
02:48:39 <ski> they are related, but don't do exactly the same thing
02:48:51 <bitonic> ski: does PatternSignatures still exist?
02:49:08 <ski> (though i think `PatternSignatures' has now been eaten by `ScopedTypeVariables')
02:49:12 <geekosaur> Eidel, you're using it in the wrong context then
02:49:30 <ski> Eidel : paste ?
02:49:33 <geekosaur> key is, you say it's a *data* constructor but it's lookig for a *type* constructor
02:50:32 * ski thinks this is good reason not to usually name data constructors the same as type constructors
02:50:37 <hpaste> Eidel pasted “Constructor error” at http://hpaste.org/68168
02:51:28 <geekosaur> you only exported the type constructor
02:51:37 <geekosaur> export RBTree(..)
02:51:46 <Eidel> Aha
02:53:11 <ski>   foo,bar :: forall a. Guaggle a -> Nodos a
02:53:23 <ski> is `a' in scope in the clauses of `foo' and `bar' ?
02:54:11 <Eidel> geekosaur: seems to work now :) Thanks
02:54:42 <ski> Eidel : you could also enumerate the data constructors inside the brackets
02:55:06 <Eidel> Nice
02:57:02 <rexamophone> @pl sum (h :| t) = h + sum t
02:57:02 <lambdabot> (line 1, column 14):
02:57:02 <lambdabot> unexpected "="
02:57:02 <lambdabot> expecting variable, "(", operator or end of input
02:59:18 <ski> rexamophone> :t (:|)
02:59:50 <yitz> ski: (:|) :: a -> [a] -> NonEmpty a
03:02:34 <yitz> rexamophone: besides the fact that @pl doesn't know about NonEmpty, your expression is not well typed: sum on the left takes a NonEmpty, whereas on the right takes a regular list.
03:04:21 <yitz> @pl sum' (h, t) = h + sum t
03:04:21 <lambdabot> sum' = uncurry ((. sum) . (+))
03:05:07 <fmap> @pl sum (x:xs) = x + sum xs
03:05:07 <lambdabot> sum = fix ((`ap` tail) . (. head) . flip ((.) . (+)))
03:05:09 <yitz> rexamophone: so sumNE = sum' . NE.uncons = uncurry ((. sum) . (+)) . NE.uncons
03:10:09 <hpaste> ski annotated “Constructor error” with “alternate style” at http://hpaste.org/68168#a68169
03:10:16 <ski> Eidel : fwiw ^
03:11:06 <ski> rexamophone : so you need some combinator for accessing the parts of a `NonEmpty a'
03:31:11 <QinGW> hi
03:32:22 <hpaste> “while-loop in haskell” pasted “Eidel” at http://hpaste.org/68171
03:32:38 <Eidel> does anyone know how to do a while loop like I posted in hpaste?
03:32:40 <srhb> QinGW: Hi
03:32:42 <liyang> <insert Soviet Russia joke>
03:33:11 <Eidel> (in a more functional programming style)
03:33:16 <srhb> Eidel: Well, why do you want one? You generally don't mutate in Haskell, and while loops typically encode a mutation scheme.
03:33:28 <frontendloader> what's @pl do?
03:33:39 <ski> @help pointless
03:33:40 <lambdabot> pointless <expr>. Play with pointfree code.
03:33:54 <Eidel> srhb: I have a recursive data type (a Tree) that i want to reuse in a function
03:34:06 <srhb> Eidel: But then you'd generally recurse through it.
03:34:10 <geekosaur> mostly it makes readable expressions unreadable :)
03:34:26 <ski> Eidel : looks like a `foldl'
03:34:31 <mauke> Eidel: foldl' function obj [0 .. n-1]
03:34:59 <ski> Eidel : where does `n' come from ?
03:35:17 <Eidel> ooh, looks nice
03:35:29 <Eidel> ski: nowhere :P JUst wanted to show a for loop
03:35:52 <ski> Eidel : mauke's version assume you define `function oldObj i = ...'
03:36:18 <mauke> true
03:36:23 <mauke> make that (flip function)
03:36:24 <ski> Eidel : often you can avoid talking about counts and indices at all
03:36:40 <merijn> Also, doesn't iterate do this?
03:36:42 <merijn> :t iterate
03:36:43 <lambdabot> forall a. (a -> a) -> a -> [a]
03:36:47 <merijn> ah, no
03:36:51 <ski> frontendloader : it makes code more pointless
03:37:09 <srhb> ski: And obviously, more is less.
03:38:05 <ski> <insert nineteen-eightyfour quote>
03:38:29 <merijn> frontendloader: @pl tries to use some basic rules to eliminate variables/names from code, although often it just makes the code unreadable :p
03:38:34 <ski> QinGW : do you have any haskell question yet ?
03:38:53 <merijn> frontendloader: But it can be helpful if you feel there is a nice combinator you're forgetting
03:39:21 <frontendloader> I haven't gotten to combinators yet
03:39:38 <merijn> frontendloader: A combinator is just "something that combines things"
03:39:45 <merijn> i.e. map/fold are combinators
03:40:10 <merijn> Eidel: Anyway, your while loop looks like you can implement it in two lines of Haskell
03:40:51 <ski> merijn : also function composition
03:40:55 <liyang> If you just want a straight for-loop without updating obj (as in obj = … obj …), there's for (and for_) in Data.Traversable.
03:41:14 <ski> @type Data.Traversable.for
03:41:15 <lambdabot> forall (t :: * -> *) a (f :: * -> *) b. (Data.Traversable.Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
03:41:16 <ski> @type Data.Traversable.for_
03:41:17 <lambdabot> Not in scope: `Data.Traversable.for_'
03:41:27 <ski> @type Data.Foldable.for_
03:41:28 <lambdabot> forall (t :: * -> *) a (f :: * -> *) b. (Data.Foldable.Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
03:42:14 <hpaste> merijn annotated “Eidel” with “Eidel (annotation)” at http://hpaste.org/68171#a68173
03:43:54 <liyang> > for [0 .. n-1] print
03:43:55 <lambdabot>   Not in scope: `for'
03:44:04 <mauke> M
03:44:11 <liyang> or traverse is for with the arguments swapped.
03:44:26 <liyang> forM only works on lists...
03:44:49 <liyang> Data.Traversable.for works nicely on Maybe too, for example.
03:48:51 <frontendloader> foldl/foldr basically what I'd recognize as reduce?
03:49:12 <merijn> frontendloader: Yes, reduce is a common name for foldl/foldr
03:49:19 <mauke> reduce = foldl
03:57:56 <timthelion> If a tutorial with example code is copyright, does that mean I cannot use the example code in my GPL program without permision?  I have http://muitovar.com/gtk2hs/index.html in mind.
03:58:36 <merijn> timthelion: All code (even if not specified) is copyrighted. Whether you can use it in your GPL program depends on the license of said code
03:59:12 <timthelion> Well that makes the tutorial really useless :(
03:59:37 <Ralith> tutorials are generally meant for uses other than copy-pasting into final products.
03:59:57 <flux> you could always ask the authors if they would release the code under a permissive license
03:59:59 <merijn> Looks like (with the current wording) you can only use code samples when the end result is licensed the same as the tutorial
04:00:16 <flux> I suppose it's one way to get started if you get to copy parts from the code and modify them
04:00:17 <merijn> flux: It is currently copyleft, just GPL incompatible copyleft :p
04:00:27 <flux> and not worry if you release the code later on or not
04:01:03 <merijn> timthelion: Might want to e-mail them requesting them to provide an additional license for copying any code in the tutorial (and to tell them to update their copyright notice)
04:01:21 <merijn> Although it seems unlikely they'll sue you for copying their code samples in a GPL program :p
04:01:27 <timthelion> merijn: I'm looking into that.  Have to find their email adress first.
04:01:53 <timthelion> merijn: I'm really rather paranoid these days, after all the weird lawsuits that we hear about in the news.
04:02:16 <merijn> timthelion: Maintainer e-mail is here (and listed with other gtk2hs packages) http://hackage.haskell.org/package/Gtk2hsGenerics
04:02:21 <timthelion> Sometimes I consider saying to hell with opensource and just going blatantly illegal in my coding practices :(
04:02:32 <timthelion> merijn: thanks
04:02:34 <merijn> timthelion: The odds of them suing you is about zero, the odds of them winning are probably lower :p
04:03:00 <frontendloader> Sometimes you are more concerned with respecting the creator than getting sued.
04:03:53 <merijn> frontendloader: Yes, but it's a tutorial for a GPL framework. It seems unlikely the creator will feel disrespected if you use it in a GPL program (provided you credit him)
04:04:02 <merijn> A copyleft tutorial, even
04:12:34 <hpaste> srhb pasted “20 intermediate...” at http://hpaste.org/68174
04:12:45 <srhb> I don't understand what that error is telling me, or why it occurs. Halp?
04:13:33 <mauke> foo has the wrong type
04:14:18 <mauke> > let zomg (x : xs) = [ord x]; zomg foo = foo in zomg "hi"
04:14:19 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
04:14:19 <lambdabot>         against inferred type ...
04:14:28 <mauke> > let zomg (x : xs) = [ord x]; zomg [] = [] in zomg "hi"
04:14:29 <lambdabot>   [104]
04:15:39 <srhb> But what other possible type is there for foo? It must be EitherLeft (Right v)... There are no other options, are there?
04:15:47 <aib> > let zomg (x:xs) = ord x : zomg xs; zomg [] = [] in zomg "hi"
04:15:48 <lambdabot>   [104,105]
04:16:13 <srhb> Oh shoot, forgot to give data declarations
04:16:13 <mauke> srhb: EitherLeft (Right v) is not a type
04:16:20 <srhb> No, that's a value of course.
04:16:42 <mauke> foo :: EitherLeft t a
04:16:46 <mauke> required: EitherLeft t b
04:17:22 <srhb> Yes, the error tells me as much. Hm. I don't understand why foo is not EitherLeft t b though.
04:18:40 <srhb> Or rather, how can there be a difference between t b and t a when v is of type a == b
04:19:17 <mauke> v is not of type a == b
04:20:12 <srhb> How can it not be? furry must be (a -> b) -> f a -> f b, so if my working version takes EitherLeft (Right v) as second argument and returns EitherLeft (Right v), must a not be equal to b?
04:20:58 <fmap> srhb: Does (Nothing :: Char) equal (Nothing :: Int)?
04:21:21 <srhb> No..
04:21:43 <mauke> srhb: no
04:22:03 <mauke> srhb: v :: t, not a
04:23:58 <srhb> Meh, I don't get it.
04:24:11 <cads> is it difficult to determine what code gcc generates for a given snippet of haskell?
04:25:01 <mauke> cads: none
04:25:13 <cads> http://pastie.org/3872921
04:25:15 <mauke> gcc isn't a haskell compiler
04:25:19 <cads> I meant ghc :D
04:25:37 <mauke> ghc -S
04:25:55 <Botje> cads: start with the core output
04:26:16 <cads> the code listing I pasted is a simple code that turns a list which represents the coefficients of a polynomial into a list the represents the coefficients of the polynomial's derivative
04:26:26 <mauke> srhb: v :: t;  Right v :: Either a t;  EitherLeft (Right v) :: EitherLeft t a
04:26:44 <fmap> srhb: Then why (EitherLeft (Right v) :: EitherLeft t a) and (EitherLeft (Right v) :: EitherLeft t b) should equal?
04:28:59 <srhb> mauke, fmap: Thanks, I think I got it. Half-way at least. :)
04:29:24 <Botje> cads: hackage has a corelist package
04:29:41 <mauke> > (Nothing :: Maybe Int) :: Maybe ()
04:29:42 <lambdabot>   Couldn't match expected type `()'
04:29:43 <lambdabot>         against inferred type `GHC.Types....
04:29:44 <mauke> nutshell
04:31:45 <cads> wow, the .s file looks like assembly
04:31:55 <mauke> ...
04:32:11 <geekosaur> .s is the standard unix extension for assembly, yes
04:32:20 <cads> ;)
04:33:22 <geekosaur> and ghc has used a native code generator instead of ugly C and an uglier Perl postprocessor for a while now
04:36:07 <Botje> and shiny llvm since 7.0!
04:36:23 <lysgaard> I want to create a Ndimensional version of Data.Vector. If i bundle a Vector together with in instance of the Data.Ix class this is possible. But I can't get my head around how to declare a datatype that only takes arguments that are instance of certain classes.
04:36:42 <hpaste> merijn pasted “lens simplification” at http://hpaste.org/68175
04:36:55 <merijn> Is there a way to simplify this lens?
04:37:51 <merijn> I look up some data based on a lens "bar", then use the result of that to actually get the data I want using "lens2"
04:38:16 <merijn> But the code duplication for the initial lookup annoys me and in general is just ugly
04:38:26 <cads> in an article I read on the new llvm backend, the author  compiles a simple line of code into something that still looks somewhat like haskell, except for a strange case syntax and some strange use of the hash symbol
04:38:31 <cads> The article is https://donsbot.wordpress.com/2010/02/21/smoking-fast-haskell-code-using-ghcs-new-llvm-codegen/
04:38:46 <cads> and the listing I'm talking about is in the "Simple Loops" section
04:39:00 <alpounet> i guess it's Core
04:39:15 <alpounet> yeah, that's GHC Core
04:39:15 <merijn> cads: It's Core, the intermediate representation for haskell
04:39:38 <merijn> cads: GHC compiles haskell to Core, then Core to ASM
04:39:46 <danr> cads: run your ghc with -ddump-simpl to get the final optimised core
04:40:02 <Ngevd> Hello
04:40:34 <Ngevd> GHC seems to be unable to find a couple of modules I have
04:40:53 <Ngevd> Any advice?
04:41:15 <danr> Ngevd: well, what modules? :)
04:41:19 <mauke> yeah, what actually happens?
04:41:55 <Ngevd> A bunch of happstack modules, and data-lens (which I could reinstall without network, and now it works?)
04:42:13 <Ngevd> Oh, damn, it works now
04:42:28 <Ngevd> That was odd
04:43:19 <cads> is this core code?
04:43:19 <cads> oh, that's not strange case syntax, I think that's just a 'less than or equal to' comparison
04:43:51 <danr> cads: I think dons have simplified the code slightly on his blog
04:44:01 <danr> well simplified the output from the dump
04:44:26 <danr> or actually, this looks like something -ddump-simpl could spit out :)
04:44:39 <Saizan> ghc-core is also nice
04:49:42 <cads> Botje, I have not found corelist, but I found ghc-core. Did you mean another package?
04:50:03 <saxobob> hello, can anyone help an ultra-Haskell-noob.  I'm working through "Try Haskell" interactive tut and at lesson 5 am aiming to pattern match out a substring from element 2 of a tuple...
04:50:21 <saxobob> (10, "abc") - trying to get "a"
04:50:40 <saxobob> I tried this... let (_:([a:_]))=(10,"abc") in a
04:50:52 <saxobob> and this let (_:(a:_))=(10,"abc") in a
04:51:03 <sipa> the second should work
04:51:04 <srhb> saxobob: Strings are lists of characters.. So the pattern is something like 'a':_
04:51:08 <mauke> sipa: no
04:51:18 <sipa> oh
04:51:21 <xraycat> isnt there a ',' missing?
04:51:24 <mauke> saxobob: (_, a : _)
04:51:27 <sipa> (_,a:_)
04:51:32 <sipa> misread the comma
04:51:41 <srhb> ah, me too.
04:51:54 <srhb> Convoluted. :-)
04:52:02 <saxobob> so the list in the pattern match doens't need to be inside a []?
04:52:25 <mauke> that would add another layer of listiness
04:52:26 <saxobob> because a list could be 'a':'b':'c' etc... ?
04:52:33 <sipa> saxobob: [a] i syntactic sugar for a:[]
04:52:38 <mauke> [a,b,c] is syntactic sugar for a : b : c : []
04:52:44 <srhb> saxobob: with an :[] at the end, yes
04:52:58 <saxobob> what function does the final [] serve?
04:53:08 <mauke> terminating the list
04:53:17 <mauke> @src []
04:53:17 <lambdabot> data [] a = [] | a : [a]
04:53:36 <sipa> saxobob: a list is either [], or element : (other list)
04:54:05 <saxobob> OK, thanks lambdadot, sipa etc.  Thanks everyone.  Back to learning.  Bye
04:54:06 <sipa> leaving the final [] would be a type error, as the second argument of : cannot be an element
04:54:18 <hpc> :t (5:)
04:54:19 <lambdabot> forall t. (Num t) => [t] -> [t]
04:54:28 <hpc> > (5:) [1, 2, 3]
04:54:29 <srhb> hpc: That's a section though..
04:54:29 <lambdabot>   [5,1,2,3]
04:55:20 <Nemo_> hi #haskell. another new person here: why do these two versions of max have such different runtimes? http://pastebin.com/z2ar758D
04:55:22 <mauke> The paste z2ar758D has been copied to http://hpaste.org/68176
04:55:24 <solarus> nice of him to thank lambdabot :)
04:55:55 <danr> solarus: :)
04:56:08 <danr> I'm surprised lambdabot did not reply
04:56:21 <hpc> Nemo_: recomputation of max' xs, vs only computing max'' xs once
04:57:24 <mauke> O(n^2)? am I reading this right?
04:57:37 <mauke> I mean 2^n
04:59:21 <luite> not 2^n
04:59:33 <Nemo_> hpc: ah, okay. so in max' both guards get evaluated, while in max'' it defers evaluating maxTail until it knows which guard was successful?
05:00:09 <hpc> Nemo_: no
05:00:20 <luite> hm, wait
05:00:28 <hpc> lemme paste, sec
05:00:32 <solarus> Nemo_: in the first one you first fully evaluate max' xs in each call of max' which takes O(n)
05:00:32 <mauke> 1, 3, 7, 15
05:02:18 <solarus> so first you check if 1 is larger than any of [2..100] then you do it for 2 and [3..100] and so on
05:03:50 <hpc> http://hpaste.org/68177 -- added comments
05:03:59 <hpc> the two (max' xs) thunks are different
05:04:25 <Nemo_> oh, brilliant, thank you
05:04:28 <Nemo_> that makes sense
05:05:18 <hpc> it's roughly the same reason an imperative algorithm with temporary variables will be faster than a naive algorithm
05:06:57 <Nemo_> nifty, thanks very much
05:16:00 <schlicht> how good is the mac support  with gtk2hs these days?
05:17:06 <hpc> schlicht: doesn't matter; gtk still looks terrible on macs anyway :P
05:20:36 <schlicht> hpc, does matter for me :) my boss uses mostly mac, so the gui should work on mac :)
05:20:38 <aristid> mac software must be hand-crafted with objective-c to be accepted
05:22:27 <hpc> heh
05:24:05 <hpc> http://projects.haskell.org/gtk2hs/ -- apparently it works
05:24:18 <hpc> "- Gtk+ on Aqua working on Mac"
05:30:00 <schlicht> hpc, yeah, but what i read its kind of "use that version, with that patch and dance aorund the table singing..."
05:32:51 * hackagebot hierarchical-clustering 0.4.2 - Fast algorithms for single, average/UPGMA and complete linkage clustering.  http://hackage.haskell.org/package/hierarchical-clustering-0.4.2 (FelipeLessa)
05:33:23 <Taneb> Now it's lost Text.CSV
05:39:58 <frontendloader> @pl tails x = x : (tails . tail $ x)
05:39:59 <lambdabot> tails = fix (ap (:) . (. tail))
05:53:02 <schlicht> im trying to install wxc on arch linux, but get compiler erros. http://pastebin.com/hc8rST29 . does someone have an idea?
05:53:05 <mauke> The paste hc8rST29 has been copied to http://hpaste.org/68178
05:57:25 <Botje> schlicht: maybe they changed that in a recent version of wx?
05:58:05 <schlicht> Botje, what do you mean? :)
05:59:25 <Botje> the first hit for that wxstring::wxstring error says the code using it is wrong
05:59:29 <Botje> but that was for wx-2.8
05:59:32 <Botje> so i guess wxc is broken :(
05:59:46 <Botje> you could open it up and see why it's calling wxstring::wxstring(int)
06:00:55 <schlicht> hmm maybe my wxgtk is broken, i will have a look at that
06:10:40 <Botje> I'd say it's wx, but you never konw
06:13:42 <schlicht> why does  wx-0.13.2.1 need wxc 0.90? hakage doesnt list it as dependencies
06:18:24 <int-e> schlicht: it's a dependency of wxcore
06:19:50 <Taneb> It seems I can't have both happstack-server and csv installed simultaneously
06:21:57 <schlicht> int-e, ah, okay, thanks
06:22:29 <schlicht> okay, i give up. no wxhaskell for me :(
06:26:06 <mm_freak_> wadler's original paper on linear types introduces a "let! X in Y" statement that fully evaluates X before it evaluates Y
06:26:12 <mm_freak_> doesn't seq/deepseq suffice?
06:26:47 <byorgey> mm_freak_: I expect deepseq and let! are equivalent.
06:27:29 <mm_freak_> ok…  i was afraid i had to add this really ugly language feature
06:30:53 <mekeor> schlicht: i think your paste http://pastebin.com/hc8rST29 means that you're missing the C-develeopment files/libraries for wx or so. did you try to install the -dev-packages for wx with your ditro's package-manager?
06:30:53 <mauke> The paste hc8rST29 has been copied to http://hpaste.org/68178
06:31:30 * mekeor thinks mauke seriously hates pastebin.com.
06:32:05 <tgeeky_> mekeor: hehe. just wait till he adds "And 20 minutes of DDOSing pastebin has commenced!"
06:32:08 <schlicht> mekeor, i will have a look at it, one sec :)
06:32:16 <mekeor> tgeeky_: :D
06:32:32 <mekeor> schlicht: sure :)
06:32:56 <Botje> mekeor: who doesn't.
06:33:19 <Botje> it's full of ads and doesn't  do nice syntax highlighting
06:33:23 <Botje> at least hpaste can annotate
06:33:57 <mekeor> Botje: i agree. hpaste's syntax-highlighting is worth nothing though.
06:34:50 <opqdonut> annotations are the killer feature
06:34:53 <opqdonut> gist is pretty nice too
06:35:05 <schlicht> mekeor, could that be lib32-wxgtk 2.8.12-1 ?
06:35:13 * mekeor thinks the main-benefit of hpaste is that it's free software.
06:35:17 <byorgey> we also have the hpaste bot which is nice
06:35:31 <mekeor> schlicht: bah. dunno :/
06:35:39 <byorgey> another benefit is that the author of hpaste hangs out in here so sometimes you can get him to add features =)
06:35:42 <schlicht> okay :) i will give it a try
06:35:57 <mekeor> byorgey: which nick does he use?
06:35:58 <tgeeky_> kidnap his family, and then s/sometimes/always/!
06:36:02 <byorgey> chrisdone
06:36:09 <mekeor> ok
06:36:18 <tgeeky_> hey guys, check it it -- i found the origin of the Earth: http://i.imgur.com/dIc3N.png
06:36:19 <byorgey> (I think)
06:36:30 <luite> yeah
06:36:35 <nand`> pastebin.com has ads?
06:36:47 <luite> the code is also on github
06:37:02 <luite> it used to be called amelie, but i think it's just pastebin or something like that now
06:37:46 <byorgey> I thought amelie was some sort of more general framework underlying hpaste
06:38:05 <tgeeky_> byorgey: https://github.com/lilac/amelie
06:38:14 <mekeor> tgeeky_: : https://github.com/chrisdone/hpaste
06:38:32 <byorgey> ah, I was wrong
06:39:12 <joe9> i am missing something with cabal versions. please help: http://codepad.org/3MolOa0A is cabal install cabal --reinstall. it install 1.14 version of cabal. but, cabal --version still says 1.12
06:39:24 <joe9> http://codepad.org/aqOgt7Yl
06:39:46 <luite> joe9: hackage has some list of preferred versions
06:40:00 <byorgey> joe9: the Cabal library is not the same thing as the cabal executable
06:40:11 <luite> oh right, that too
06:40:21 <mekeor> byorgey: "using version 1.12.0 of the Cabal library"
06:40:25 <byorgey> you now have the 1.14 version of the Cabal library (though you should have already had it in the first place, it comes with GHC 7.4)
06:40:39 <byorgey> yes, reinstalling the Cabal library does not recompile the cabal executable
06:40:42 <luite> you need to rebuild cabal-install to make it use the newe library
06:40:48 <joe9> ok, thanks.
06:40:56 <dcoutts> cabal install cabal-install-0.14.0
06:41:44 <joe9> dcoutts: that helped, thanks.
06:45:23 <joe9>  http://codepad.org/ITxwPopc more a linux question.
06:45:40 <joe9> what am I doing wrong here? why does which use /usr/bin/cabal instead of .cabal/bin/
06:46:04 <mauke> hash -r
06:46:06 <mauke> type -a cabal
06:46:28 <Botje> one of the two is not executable, perhaps?
06:47:11 <joe9> mauke: thanks that helped. hash -r
06:47:42 <joe9> mauke: if you do not mind me asking, what does "type -a cabal" do.
06:47:47 <joe9> man type is not that useful
06:47:51 <mauke> help type
06:48:39 <Jaak> does anyone know where the term Hutton's Razor was first coined?
06:49:26 <Jaak> google does not yield anythign concrete to refer to
06:51:07 <bitonic> Jaak: what's Hutton's Razor?
06:51:31 <Jaak> a simple expression language with just literals and addition operator
06:55:01 <merijn> Any code golfers feel up to helping me write this more elegantly? "(\m -> let tmp = m ^. f in m ^. g tmp)"
06:56:19 <mauke> \m -> m ^. g (m ^. f)
06:56:21 <bitonic> (\m -> m ^. g (m ^. f))?
06:56:26 <bitonic> ehe.
06:56:42 <Cale> ditto
06:56:44 <merijn> hmm, now I don't even remember why I had the initial let...
06:57:18 <mauke> ap (^.) (g . (^. f))
06:57:43 <bitonic> (^.) <$> (g . (^. f))!
06:57:57 <mauke> is that legal?
06:58:20 <Jaak> illegally unreadable maybe
06:58:20 <bitonic> mauke: why not?
06:58:25 <bitonic> actually sorry, <*>
06:58:27 <bitonic> not <$>
06:58:56 <bitonic> (assuming that what mauke posted works)
06:59:07 <mauke> @pl (\m -> let tmp = m ^. f in m ^. g tmp)
06:59:08 <lambdabot> liftM2 (. g) (^.) (^. f)
06:59:19 <mauke> @pl \m -> m ^. g (m ^. f)
06:59:20 <lambdabot> ap (^.) (g . (^. f))
06:59:23 <merijn> Hmm, actually then I can probably get it even smaller
06:59:26 <bitonic> oh, ok.
06:59:37 <merijn> @pl (\m -> getL (g (getL f m)) m)
06:59:38 <lambdabot> getL =<< g . getL f
07:00:08 <mauke> nice =<<, @pl
07:00:15 <merijn> hmm, not sure if that's readable, though :p
07:01:45 <bitonic> Jaak: ok
07:01:54 <merijn> @pl (\s m -> setL (g (getL f m)) s m)
07:01:55 <lambdabot> join . flip (setL . g . getL f)
07:08:15 <merijn> Only in Haskell can I refactor my code without understanding the refactoring >.>
07:08:24 <saml> what?
07:08:39 <Botje> isn't it refuctoring then? :P
07:08:46 <saml> you mean there is genetic algorithm that refactors your haskell code?
07:08:59 <saml> until it compiles
07:09:07 <mauke> it's mechanical
07:09:16 <mauke> you can refactor without understanding
07:09:23 <Botje> ask on #haskell, paste back into editor.
07:09:37 <saml> hence genetic algorithm is a good choice
07:09:52 <merijn> On related note
07:09:52 <saml> and be amazed at the resulting refactored code
07:09:57 <mauke> how do you judge fitness?
07:10:12 <saml> number of lines!
07:10:25 <merijn> I refactored to the following number of incredibly readable *cough* code
07:10:32 <hpaste> bitonic pasted “type families” at http://hpaste.org/68180
07:10:34 <merijn> s/number/line
07:10:35 <merijn> foo f g = lens (g . getL f >>= getL) (\s -> g . getL f >>= flip setL s)
07:10:42 <bitonic> why doesn't this work: http://hpaste.org/68180 ?
07:11:00 <saml> type Family Foo a
07:11:17 <bitonic> saml: ?
07:11:18 <merijn> roconnor: I got a new stock lens I'd like to see in Data.Lens, there's probably a prettier implementation and better name for it, but I can't think of one atm
07:11:24 <saml> what's Foo bitonic ?
07:11:33 <mauke> a type family, apparently
07:11:35 <bitonic> saml: a type family
07:11:37 <roconnor> merijn: go ahead
07:11:45 <hpaste> bitonic annotated “type families” with “type families (error)” at http://hpaste.org/68180#a68181
07:11:50 <saml> i don't knowo about it.. i thought type should start with upper case
07:11:51 <bitonic> I annotated with the error
07:11:59 <bitonic> saml: family is a keyword
07:12:05 <merijn> roconnor: It's basically the code I just pasted, but the type is perhaps clearer "foo :: Lens a b -> (b -> Lens a c) -> Lens a c"
07:13:04 <merijn> Because my current code finds me often needing to access a lens parametrised over the result of another lens on the same data type
07:13:16 <merijn> And it seems sufficiently generic to be useful as a stock lens
07:13:39 <bitonic> Saizan: any ideas about what I posted? I don't see why the fact that type families are not injective matters in this case
07:14:28 <mauke> bitonic: it's possible that quux :: Foo a doesn't nail down the type
07:15:11 <mauke> because (quux :: Foo A) :: Foo B is potentially valid
07:15:17 <roconnor> foo :: (a  ->  b) -> (b -> Lens a c) -> Lens a c
07:15:23 <roconnor> foo :: (a -> Lens a c) -> Lens a c
07:16:21 <roconnor> foo :: (a -> a -> Store c a) -> a  -> Store c a
07:16:27 <roconnor> foo = join
07:17:13 <roconnor> merijn: it seems a bit strange
07:17:28 <Saizan> bitonic: from Foo x ~ Foo y you can't deduce x ~ y
07:17:31 <jeff_s_> For base < 4.5, is there a better way for me to create a value of Foreign.C.Types.CTime than unsafeCoerce?
07:17:53 <jeff_s_> Oh hm, fromInteger probably.
07:23:12 <bitonic> Saizan: so wait if I've got two instances of `Foo a' GHC can't deduce `Foo a ~ Foo a'?
07:23:36 <bitonic> also, the error says "Couldn't match type `Foo a' with `Foo a0'". where does that `a0' come from?
07:23:50 <mauke> bitonic: probably from :t quux
07:24:21 <bitonic> mauke: but `quux :: Foo a'
07:24:43 <mauke> bitonic: that doesn't say much
07:25:03 <bitonic> mauke: ah, right.
07:25:10 <jeff_s_> (correction to my self-answer, it's fromIntegral)
07:25:59 <merijn> roconnor: Example from my code, I writing a simulation for a distributed system. I have id's, which are owned by a location. I have a lens to get the data for a location+id combination and a lens to get the owner of an id. To get information from the owner of an id I first need to use the owner lens to find its location, then I use the found location + id to create a new lens to actually access the data.
07:25:59 <jeff_s_> (correction to my self-answer, it's fromIntegral)
07:26:01 <jeff_s_> oops
07:26:45 <hpaste> bitonic annotated “type families” with “type families (annotation)” at http://hpaste.org/68180#a68182
07:26:57 <bitonic> mauke: ^^^ I'm puzzled on why this simpler instance doesn't work as well
07:26:58 <Saizan> bitonic: everytime you use quux it gets passed a fresh type variable
07:27:20 <Saizan> bitonic: (that's just plain HM polymorphism)
07:27:39 <mauke> maybe I should have a look at type families
07:27:46 <bitonic> Saizan: yeah right, I got confused, but in my new examples (which is simpler) why doesn't it work?
07:27:46 <mauke> this seems like fun :-)
07:28:01 * hackagebot hspec 1.1.0 - Behavior Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.1.0 (SimonHengel)
07:28:05 <jeff_s_> Heh, great, CTime isn't an instance of Integral.
07:28:07 <merijn> roconnor: I don't know if that's very common, but as I said, it seems sufficiently generic to be useful. Especially when you want to manipulate state based on other state
07:28:21 <mauke> bitonic: looks like the same problem
07:28:22 <jeff_s_> unsafeCoerce, here I come...
07:28:28 <Saizan> bitonic: http://hpaste.org/68183
07:28:38 <mauke> bitonic: it's trying to solve Foo a = Int for a
07:28:44 <merijn> roconnor: And I'm not really sure how else you'd do it
07:29:07 <bitonic> Saizan: right. but in this case it seems like it's simple to solve the yellow
07:29:12 <Saizan> bitonic: any definition where a type variable appears only as an argument for a type family index is useless
07:29:28 <saml> bitonic, what are you trying to accomplish? are you learning about type families or do you need type families?
07:29:34 <bitonic> saml: that's really sad. ok.
07:29:38 <bitonic> sorry, Saizan
07:29:49 <roconnor> merijn: I think I got a little lost in your description
07:30:00 <bitonic> saml: type families would be really useful if I could do this
07:30:08 <merijn> roconnor: Hmm, I'll write a small example
07:30:25 <saml> probably type families are't for the things you are trying to do then
07:30:46 <bitonic> Saizan: it still seems like something obvious to do when resolving this. but I'm probably missing some subleties
07:30:52 <Saizan> bitonic: type families are open, so you could have Foo Char = Int too somewhere else
07:31:09 <hpaste> saml annotated “type families” with “type families (annotation) (annotation)” at http://hpaste.org/68180#a68184
07:31:21 <saml> that compiles
07:31:24 <bitonic> Saizan: how would that be a problem in this case?
07:31:37 <bitonic> saml: do you know what type families are :P?
07:31:50 <mauke> <mauke> bitonic: it's trying to solve Foo a = Int for a
07:32:13 <mauke> a = Int && a = Char?
07:32:24 <Saizan> bitonic: there's the usual design principle of not committing to ad-hoc solutions but using only most general ones, IOW you'd break monotonicity
07:32:35 <bitonic> mauke: why?
07:32:41 <bitonic> newtype Bar a = Bar (Foo a)
07:32:49 <bitonic> so why would you have to have Foo a = Int?
07:32:56 <mauke> florb :: Bar Int
07:33:15 <mauke> florb = Bar {- ... -}
07:33:18 <bitonic> Saizan: ok. well this is sad I had this grand design in mind :(
07:33:35 <bitonic> mauke: yeah but the type in there would simply be `Foo Int'. Not Int
07:33:43 <mauke> Foo Int is Int
07:33:45 <bitonic> Saizan: thanks anyways.
07:33:55 <mauke> says so in line 4
07:33:56 <bitonic> mauke: oh right in this case, but it doesn't matter
07:34:00 <bitonic> it could be anything no?
07:34:08 <mauke> huh?
07:34:21 <mauke> if it could be anything, that just makes it more ambiguous
07:34:36 <bitonic> mauke: the problem is that GHC does not replace the `a' in quux with Int
07:34:46 <bitonic> if you had a way to tell it to do that it'd be fine
07:35:03 <mauke> I'm not sure there is an 'a' in quux
07:35:12 <bitonic> quux :: forall a. Foo a
07:35:24 <mauke> Foo is a type function
07:35:24 <Saizan> there's an 'a' type argument for quux
07:35:44 <bitonic> mauke: if GHC substituted that `a' with `Int' it'd work, which is what I expected it to do automatically
07:35:56 <bitonic> sadly you can't do it manually
07:36:14 <mauke> it works in the other direction
07:36:14 <Saizan> anyhow, you can use data Proxy a = Proxy; quux :: Proxy a -> Foo a; quux (Proxy :: Proxy Int), but i guess you know that
07:36:32 <hpaste> merijn pasted “Lens example” at http://hpaste.org/68185
07:36:44 <merijn> roconnor: Does that pseudo implementation make sense?
07:36:51 <bitonic> Saizan: oh right, yes. thanks.
07:37:10 <bitonic> I'd probably have hacked that without realizing I needed proxy
07:37:51 <hpaste> merijn annotated “Lens example” with “Lens example (fixed)” at http://hpaste.org/68185#a68186
07:38:05 <merijn> roconnor: Whoops, small mistake, second one should work :p
07:38:27 <bitonic> mauke: what other direction?
07:39:38 <bitonic> Saizan: works like a charm :)
07:40:14 <mauke> direction 1: "I know quux :: Foo a and a = Int, so quux :: Foo Int, which is Int, so quux :: Int"
07:40:47 <mauke> wait, that doesn't work
07:40:47 <bitonic> mauke: it really doesn't matter what `Foo Int' is. the problem is that it's not substituting the tyvar `a' in quux.
07:40:52 <bitonic> once it does that, it works.
07:40:58 <bitonic> using Proxy is a way to force that substitution.
07:41:12 <mauke> yes, I need to think more
07:41:44 <hpaste> bitonic annotated “type families” with “this works” at http://hpaste.org/68180#a68187
07:41:46 <bitonic> mauke: ^^^
07:41:52 <bitonic> that works
07:42:19 <bitonic> (not that there is not one instance of `Foo')
07:42:34 <Saizan> florb :: Bar Int; florb = Bar undefined -- also works btw :)
07:42:42 <bitonic> Saizan: yeah! ehe
07:43:00 <bitonic> (this is a reduced version of a problem in a program that actually does something :))
07:43:27 <mauke> my current intuition is that with Proxy a -> Foo a the two 'a's are linked
07:43:47 <mauke> i.e. the 'Proxy a ->' part is like a handle you can grab
07:44:00 <bitonic> mauke: yeah, since the quantification is at the left
07:44:08 <bitonic> `quux :: forall a. Proxy a -> Foo a'
07:44:10 <mauke> whereas before the 'a' was completely unconstrained
07:44:17 <bitonic> so passing the `Proxy' you can force the substitution
07:44:32 <Saizan> Proxy a ~ Proxy Int implies a ~ Int, that's the whole trick
07:44:36 <bitonic> mauke: "unconstrained" doesn't make much sense here. there just wasn't an explicit way to substitute that type variable
07:45:25 <mauke> it makes sense to me :-)
07:45:37 <bitonic> mauke: ok, terminology :)
07:45:46 <bitonic> for me "constraint" in Haskell means "type-class constraint"
07:45:58 <mauke> I see it as more general
07:46:15 <Saizan> i think unconstrained makes sense, because in HM it's all a game of implying constrains on type variables by constraining the types of the arguments and results
07:46:31 <mauke> e.g. with 'foo bar' I have the constraint that foo :: (->) x y for some x,y
07:46:40 <Saizan> the problem is that in the original quux the information flow was interrupted by the presence of Foo
07:46:46 <byorgey> bitonic: even if we are being specific to haskell, there are other kinds of constraints as well, such as type equality constraints (and also implicit parameter constraints)
07:47:20 <mm_freak_> where "un" means "unique":  doesn't "un Int -> un Int" allow that the function drops the old reference and returns a new integer?  i see how linear types wouldn't allow that
07:47:28 <bitonic> byorgey: true
07:48:17 <byorgey> mm_freak_: I could imagine a meaning of "un" which allows that. In which case you have an affine type system, not linear
07:48:38 <byorgey> but I think affine is normally what you would want for uniqueness typing anyway.  It really doesn't matter whether you use something or not.  You just can't duplicate it.
07:49:17 <mm_freak_> ok
07:49:29 <mm_freak_> well, i want a linear type at least for World
07:49:49 <mm_freak_> in my core language i want to design IO the way Clean does it
07:50:26 <byorgey> sure.  I don't actually know many details about how Clean's type system works.
07:50:46 <mm_freak_> well, Clean uses a unique type…  i guess this is safe because there is no constructor for World
07:51:10 <mm_freak_> but it's not conceptually safe IMO
08:01:48 <lamefun2> is there a vector space typeclass?
08:03:03 * hackagebot abstract-par 0.3.1 - Type classes generalizing the functionality of the 'monad-par' library.  http://hackage.haskell.org/package/abstract-par-0.3.1 (RyanNewton)
08:05:38 <byorgey> lamefun2: yes, see the vector-space package
08:05:43 <byorgey> @package vector-space
08:05:44 <lambdabot> http://hackage.haskell.org/package/vector-space
08:11:43 <Svarg> hi conal
08:14:54 <conal> Svarg: howdy
08:15:11 <mm_freak_> is it sensible to indicate the linearity of a type through the kind system?
08:15:48 <mm_freak_> f : (Int : Lin) -> (Int -> Lin)
08:15:52 <mm_freak_> uhm
08:15:56 <mm_freak_> f : (Int : Lin) -> (Int : Lin)
08:17:05 <ski> mm_freak_ : the most straight-forward way to do things is to have a `! :: * -> *' type constructor for "non-linearity"
08:18:15 <mm_freak_> huh?
08:18:20 <lamefun2> Is there a Haskell compiler in to official programming language of earth person-orientated language for people JavaScript?
08:18:23 <mm_freak_> for /non/-linearity?
08:18:42 <ski> yep
08:18:49 <mm_freak_> lamefun2: sorry, that question did not make any sense to me
08:18:50 <merijn> lamefun2: Error: no parse
08:18:55 <ski> everything is linear, unless explicitly not linear
08:19:12 <ski> mm_freak_ : it's more or less the same as saying "everything is pure, except as marked by a monad"
08:19:31 <mm_freak_> ski: i understand that, but isn't that going to be really inconvenient?
08:19:33 <lamefun2> Is there a compiler that can translate Haskell programs into the official programming language of Earth person-orientated language for people JavaScript?
08:19:34 * Axman6 senses a troll with horrible english skills
08:19:45 <barrucadu> lamefun2: That still makes no sense.
08:19:46 <mm_freak_> lamefun2: still no parse
08:19:49 <geekosaur> that did sound somewhat protontorpedo-ish
08:19:51 <ski> (of course everything, including monadic computations, are pure -- in the same way everything is linear in the above system -- but `!' is used to *encode* nonlinearity in the linear system -- this was Girard's discovery)
08:19:56 <merijn> lamefun2: There is a haskell to javascript compiler, yes. If that's what you're asking
08:20:03 <merijn> Multiple even, I think
08:20:29 <merijn> lamefun2: University of Utrecht is working on that
08:20:37 <geekosaur> it probably doesn't produce code you can read though, since compilers to other languages rarely do
08:21:11 <Axman6> i wonder if lamefun2 believes that javascript is actually a nice language
08:21:25 <barrucadu> Does anyone believe that?
08:21:37 <jamiltron> Douglas Crawford.. maybe.
08:21:39 <Axman6> i think some people actually do, amazingly
08:21:39 <geekosaur> it's what they understand, therefore is superior to everything else?  typical unthink
08:21:41 <mm_freak_> i believe that javascript is a low level language and you would want to compile a high level language to it
08:21:42 <barrucadu> then again, I came across someone who said PHP was nice, yesterday
08:22:06 <RenJuan> barrucadu, I gar-aun-tee there are people that do.
08:22:10 <mm_freak_> javascript has the same basic problems and design errors as (a misinterpretation of) assembly language
08:22:10 <ski> mm_freak_ : anyway, to get it more convenient, you start by adding a non-linear environment of variables, and possibly also linearity annotations on the types, instead of `!' (or maybe in addition)
08:22:57 <mm_freak_> ski: i don't know…  i'd like to have a "nonlinear by default" type system that allows linearity (or affinity, i'm yet unsure about which one i'll go with)
08:23:08 <merijn> barrucadu: What? You read hacker News too? :p
08:23:18 <Franciman> lol
08:23:22 <lamefun2> But sadly JavaScript is the future and all the traditional compiled programming languages will be reduced into tools of writing JavaScript interpreters. That's Microsoft Web 3.0.
08:23:24 <ski> mm_freak_ : yeah, so you probably want some kind of linearity annotations, then
08:23:42 <merijn> lamefun2: Yeah, anyone who believes that is an idiot
08:23:43 <ski> mm_freak_ : i'm just saying that the explicit version with `!' is easier to understand, at first
08:23:49 <Axman6> lamefun2: please try harder. your trolling isn't even remotely annoying or funny
08:23:57 <Axman6> it;s like you're trolling yourself more than us
08:23:58 <mm_freak_> ski: it seems sensible to use kinds for that…  as my language is dependently typed i already have "kind polymorphism"
08:24:28 <mm_freak_> Set Linear 0, Set NonLinear 0
08:24:35 <barrucadu> merijn: No, I was talking about programming languages with someone and he said PHP was his favourite because "It's like C but with a nice standard library"
08:24:51 <merijn> barrucadu: I feel stupider for reading the sentence
08:24:54 <Axman6> barrucadu: wut
08:25:03 <Axman6> jesus
08:25:07 <merijn> s/the/that
08:25:07 <ski> mm_freak_ : it's possible one could use kinds here, i'm not sure
08:25:20 <lamefun2> merjin: Why an idiot? Everything is sadly approaching that.
08:25:30 <mm_freak_> ski: there is even a language that does it…  "alms"
08:25:35 <mm_freak_> i guess i'll just read their paper
08:25:43 <ski> mm_freak_ : i suspect one'd want to have (coherent) overloading of the type functions, though
08:26:03 <roconnor> merijn: looking now
08:26:14 <mm_freak_> ski: i'll have implicit arguments, agda style, and value inference
08:26:39 <ski> mm_freak_ : i don't follow your `Set Linear 0' examples, though
08:27:11 <mm_freak_> ski: if A : Set Linear 0, then it corresponds to a linear version of what you would write X : Set 0 in agda
08:28:26 <roconnor> merijn: I guess I don't understand why info is a map from id * location to info when the location is determined from the id
08:28:52 <geekosaur> btw I'm calling (badly misaimed) troll, Mr. "Microsoft Web 3.0"; go look at who supports ghc development again, then come back with a real question
08:29:20 <Veinor> hmm
08:29:30 <ski> mm_freak_ : and `Set NonLinear 0' is a subkind of `Set Linear 0' ?
08:29:38 <Veinor> do i want to bother with shell scripting, or do i want to write this shell-script-like thing in haskell
08:29:58 <mm_freak_> ski: not sure about that…  i'll read tov's and pucella's paper about Alms first
08:29:58 <zaltekk> PHP is C-like if you use C-like to mean brace-formatted
08:29:58 <navaati> Veinor: there is a haskell shell iirc
08:30:15 <mm_freak_> (i've never read so many papers in such a short time period)
08:30:23 <geekosaur> there is also ghc -e and runhaskell. for that matter
08:30:23 <navaati> zaltekk: haha, then haskell is python-like ? funny
08:30:33 <ski> mm_freak_ : also (again), i suspect that you really are mostly interested in uniqueness rather than linearity
08:30:34 <geekosaur> it's ML-like
08:30:39 <zaltekk> navaati: hmm. sure? lol
08:30:49 <merijn> roconnor: Separate locations have separate state about an id. Mostly I just deal with "the state on this node" in my simulation (in which case I can directly access info), but sometimes I need to update the state on the owner (i.e. "message" the owner), in which case I first need to find who the owner is, then look up its state
08:30:59 <geekosaur> PHP is (somewhat distantly) Algol family
08:31:36 <mm_freak_> ski: as i pointed out earlier, uniqueness is safe for IO only because there is no world constructor…  so it's not conceptually safe
08:31:56 <bitonic> jaspervdj: is there any way to easily use websockets with warp (0.4)? the fact that websockets has its own http request type (RequestHttpPart) is kinda annoying when interoperating with it
08:32:00 <ski> mm_freak_ : hm, i must have missed you saying that
08:32:14 <mm_freak_> ski: you didn't appear to be active then
08:32:32 * ski nods
08:33:11 <ski> mm_freak_ : i'm not sure why it's not conceptually safe, though
08:33:15 <mm_freak_> ski: the point was that uniqueness only guarantees, well, uniqueness…  the type system doesn't know that it's /the same/ object, just that it's another unique object
08:33:35 <ski> well, it's not the same value
08:33:50 <merijn> roconnor: Anyhoo, it's not a huge issue. I just figured the notion of a derived or composite (not sure what would be a good name) lens was nice and generic :)
08:34:17 <jaspervdj> Hi bitonic: did you try this package? http://hackage.haskell.org/package/wai-websockets
08:34:27 <roconnor> merijn: for now I think I'll leave it out; but if I'll be on the look out for it in other contexts.
08:34:49 <mm_freak_> ski: imagine you had emptyWorld : World…  then 'print' could ignore the argument and print into the empty world instead
08:35:11 <mm_freak_> linear types don't allow that
08:35:16 <merijn> roconnor: I'll let you know if I run into more use cases :)
08:35:54 <mm_freak_> ski: i'm raising this issue because i want to make it as easy as possible to optimize the core language
08:36:06 <bitonic> jaspervdj: I had no idea that existed. Thanks :)
08:36:23 <ski> mm_freak_ : i don't think i follow
08:36:36 <navaati> if i import Control.{Applicative,Monad,Arrow} and i only use a few combinators, only the code for these combinators will be linked into my build, not all the modules, right ?
08:36:41 <mm_freak_> ski: the more the compiler knows about the code the better you can optimize
08:36:42 <dolio> Imagine I added 'forgetWorld : World -> ()' and 'duplicateWorld : World -> (World, World)' to something with linear types. Then it's not safe.
08:36:57 <ski> mm_freak_ : afaics, the essential thing here is "update-in-place" -- which can be made safely by uniqueness, but not by linearity
08:37:30 <mm_freak_> ski: huh?  could you elaborate?  i thought linear types are a special case of uniqueness types
08:37:43 <ski> mm_freak_ : if you have a linear `Blah', then you can't use update-in-place on it (in general)
08:38:04 * hackagebot file-location 0.4.4 - common functions that show file location information  http://hackage.haskell.org/package/file-location-0.4.4 (GregWeber)
08:38:27 <ski> mm_freak_ : because a valid way to get a linear `Blah' is to start with a non-linear `Blah', and then *forget* that it was non-linear, thereby promising not to duplicate or discard this reference in the future
08:38:49 <ski> mm_freak_ : but that doesn't prohibit you duplicating the reference *before* going from non-linear to linear
08:38:53 <mm_freak_> ski: doesn't that cast involve copying?
08:39:42 <ski> i suppose one could make that conversion involve copying -- but then i don't think it can be fully polymorphic, in a general system
08:39:55 <ski> (e.g. there is no way you can duplicate `A & B' in general)
08:39:58 <mm_freak_> i see what you mean
08:40:17 <mm_freak_> so i'd have linearity as an additional feature to uniqueness?
08:40:26 <ski> maybe
08:40:32 <mm_freak_> hmm
08:41:13 <mm_freak_> what if i don't have that conversion at all?  withArray : (Lin Array -> Lin Array) -> Array -> Array
08:41:39 <ski> where that copies ?
08:41:45 <mm_freak_> yeah
08:42:10 <mm_freak_> i could also think of a type class for that kind of thing
08:43:02 <frontendloader> @pl zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys
08:43:04 <lambdabot> zipWith' = fix (flip flip tail . (ap .) . flip flip head . ((.) .) . flip flip tail . ((flip . ((flip . (ap .)) .)) .) . flip flip head . ((flip . ((flip . ((.) .)) .)) .) . liftM2 flip (((.) . flip
08:43:04 <lambdabot> . (((.) . (:)) .)) .))
08:43:05 <ski> (hm, or i suppose `! (A & B)' could possibly be copied .. but i'm not sure about lolli or par)
08:43:17 <whittle> Just read http://www.haskell.org/haskellwiki/Abstract_data_type which lists three kinds of abstraction: parameterization, module implementation hiding, and type classes. Are there guidelines regarding when to use each?
08:43:19 <frontendloader> flip.
08:43:47 <Axman6> flip flip tail, flip flip head. the @pl zipWith Haskell dance!
08:43:55 <whittle> ^ That was meant to be read “I just read,” not “You should read.”
08:44:34 <frontendloader> pl seems to not be a wise thing to do if you're using functions that take multiple parameters
08:44:52 <geekosaur> pretty much
08:44:53 <ski> frontendloader : or, if you have non-trivial patterns
08:45:39 <frontendloader> it looks pretty trivial in it's readable form
08:46:14 <ski> frontendloader : exercise (hard) : implement `zipWith', using a call to `foldr' for each list, for traversing it
08:46:38 <Axman6> @pl \xss -> f y (head xss) : zipWith ys (tail xss)
08:46:38 <lambdabot> ap ((:) . f y . head) (zipWith ys . tail)
08:48:16 <byorgey> whittle: use parameterization when you want something that works uniformly over all types.  Use type classes when you want something that works in different ways for different types.  Module implementation hiding is orthogonal; use it if you want to encapsulate some sort of "unsafe" internals behind a "safe" external API
08:48:23 <ski> mm_freak_ : hm, i suppose you can make promotion an O(0)-op, but not dereliction
08:48:52 <byorgey> whittle: that's a very, very rough guideline.  But also, note that those three things are not mutually exclusive.  You can use all of them at once.
08:48:55 <yan_> so if i'm performing a lot of authenticated tasks, that i first use (getAuth :: Creds -> IO Auth) to get it, i am currently doing this in a MaybeT IO ().. but this makes me lift everything twice.. would doing this in bare IO (), but calling fail if anything goes wrong a better idea?
08:49:02 <bitonic> jaspervdj: weird. I had to disable the example to make it work.
08:49:08 <bitonic> (it didn't install otherwise)
08:49:15 <ski> whittle : typical uses of abstract types (module implementation hiding) is when you want to get a quotient type or a subtype (or both) of the representation type
08:49:28 <byorgey> yan_: no.  Calling fail is never a good idea.
08:49:35 <mm_freak_> ski: could you elaborate (or link)?
08:49:50 <Veinor> yan_: what do you mean, lift everything twice?
08:49:59 * byorgey was just going to ask that
08:50:04 <ski> whittle : quotient type meaning that two different representations can represent the same ideal value -- subtype meaning that some potential represesentations are to not be allowed
08:50:06 <yan_> Veinor: i need to lift a do-block to get it into MaybeT IO
08:50:14 <Veinor> right
08:50:39 <byorgey> yan_: I don't understand why you need to lift it twice though.  just a single 'liftIO' should suffice.
08:51:01 <Veinor> doesn't plain old lift work too?
08:51:02 <jaspervdj> bitonic: Hmm, that's weird indeed, perhaps create an issue in the yesodweb/wai repo with the exact error? https://github.com/yesodweb/wai
08:51:20 <byorgey> yes, plain old lift works too, but liftIO would continue to work even if you added another transformer to the stack
08:51:27 <Veinor> true
08:51:28 <bitonic> jaspervdj: I will
08:51:28 <mm_freak_> yan_: x <- lift $ do …
08:51:46 <ski> mm_freak_ : dereliction is the rule that takes you from `Gamma , A |- Delta' to `Gamma , ! A |- Delta' -- it allows you to treat a variable of type `! A' as if it had type `A', removing the non-linearity
08:51:54 <whittle> byorgey: Noted. Thank you.
08:52:06 <bitonic> jaspervdj: I think it has something to do with loading the static files
08:52:55 <ski> mm_freak_ : promotion is the rule that takes you from `! Gamma |- A' to `! Gamma |- ! A' -- it allows you to promote an expression of type `A', to the non-linear type `! A', *provided* that all the free variables have types of shape `! B', for various `B's
08:52:57 <frontendloader> ski: zipWith'' f (x:xs) (y:ys) = foldr f 0 x y : zipWith'' f xs ys
08:53:05 * hackagebot scotty 0.4.1 - Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp  http://hackage.haskell.org/package/scotty-0.4.1 (AndrewFarmer)
08:53:18 <yan_> Veinor: what if i want to add a StateT monad to this? Then i'm wrapping MaybeT StateT IO () and it doesn't feel like a clean way to do things
08:53:23 <ski> mm_freak_ : dereliction is aka the left-introduction rule for `!', while promotion is the right-introduction rule for `!'
08:53:23 <frontendloader> with two edge cases ofc
08:53:34 <yan_> i can also just use StateT and pass a 'fail' value
08:54:00 <mm_freak_> ski: it was really rather the left part of your statement that confused me
08:54:24 <Veinor> yan_: if you want to add a StateT then liftIO will lift an IO action either into StateT IO or MaybeT (StateT IO), depending on which typechecks
08:54:38 <whittle> ski: A balance vector where all the elements have to sum to zero would be a subtype? And a type that includes encoded data and the encoding used would be a quotient type?
08:54:39 <ski> whittle : an example of a subtype is when implementing binary search trees : because only trees with elements in a sorted order are allowed, so we want to disallow the creation of other trees
08:54:56 <whittle> ski: Okay.
08:55:10 <frontendloader> I'm not sure what to whip up for the type sig for that even after looking at :t
08:55:39 <ski> whittle : an example of a quotient type is when implementing sets or bags or finite maps with trees : because the same set/bag/map can be represented with several different trees, so we want to disallow anyone from noticing the difference between conceptually equal sets/bags/maps
08:55:46 <byorgey> yan_: using StateT + MaybeT  sounds fine to me.  Much cleaner than any alternative.  The alternatives basically amount to simulating StateT + MaybeT manually.
08:55:49 <Veinor> on an unrelated note i wonder if it's possible to use runghc in such a way that if the source doesn't change then it keeps the executable around
08:56:12 <ski> frontendloader : oh, i forgot to say : no recursion, and no pattern-matching on `[]' not `x:xs'
08:56:30 <ski> (frontendloader : also that code doesn't type-check)
08:56:40 <byorgey> Veinor: does runghc even make an executable?
08:56:52 <Veinor> well no
08:56:57 <Veinor> you'd have to build something on top of it
08:57:05 <frontendloader> oh I called the wrong zipwith heh
08:57:13 <ski> mm_freak_ : "i suppose you can make promotion an O(0)-op" ?
08:57:20 <mm_freak_> yeah
08:57:26 <mm_freak_> oh
08:57:27 <byorgey> Veinor: just make 'runghc' into a symlink that calls 'ghc --make' and then calls the resulting executable =P
08:57:30 <mm_freak_> i just failed to parse it =)
08:57:37 <Veinor> yeah exactly :P
08:57:40 <byorgey> (s/symlink/alias)
08:57:45 <frontendloader> foldr f 0 [x,y]
08:57:47 <mm_freak_> ski: an O(0) operation you mean =)
08:57:48 <Veinor> anyway
08:57:50 <frontendloader> was what I meant to write
08:58:02 <mm_freak_> i thought that was some fancy logic notation that i didn't know ;)
08:58:05 <ski> whittle : "A balance vector where all the elements have to sum to zero would be a subtype?" -- yes
08:58:06 <byorgey> > foldr f 0 [x,y]
08:58:07 <lambdabot>   Ambiguous occurrence `f'
08:58:08 <lambdabot>  It could refer to either `L.f', defined at <local...
08:58:18 <frontendloader> recursion and x:xs are all I know at the moment
08:58:20 <Veinor> i'm going to make a shell script that automatically sets the sandbox on every invocation of cabal-dev so you can do like
08:58:33 <ski> whittle : "And a type that includes encoded data and the encoding used would be a quotient type?" -- could be, i'm not sure on exactly what you mean here
08:58:41 <Veinor> sandboxer foo and it replaces cabal-dev with cabal-dev.real $* --sandbox=~/.sandboxes/foo
08:59:04 <frontendloader> how can you define/call a recursive function on lambdabot?
08:59:11 <geekosaur> Veinor, maybe you're thinking of virthualenv at this point...
08:59:15 <Veinor> i probably am
08:59:22 <Veinor> but virthualenv is unmaintained :(
08:59:26 <ski> mm_freak_ : aye
08:59:29 <frontendloader> nevermind
08:59:42 <bitonic> jaspervdj: yeah, file-embed is broken here.
08:59:52 <joelr> moin
08:59:54 <ski> frontendloader : ok, then don't mind my exercise yet then :)
08:59:56 <whittle> ski: What I was thinking of was something like an encrypted bytestring paired with the (symmetric) key it was encrypted with.
09:00:26 <frontendloader> What's the "key" I'd need to know to be able to do it?
09:00:42 <frontendloader> liftM2 or some other monad-related thing?
09:00:44 <joelr> what is the best way to convert a list of String to a list of CString for use with Foreign.Marshal.Array.newArray? i have a C function that needs envp
09:00:50 <ski> frontendloader : to do what ?
09:00:55 <frontendloader> your exercise
09:00:57 <Veinor> the reason i want cabal-dev to automatically pick the sandbox is because i keep running into stuff that doesn't know about custom sandbox locations
09:01:17 <ski> frontendloader : you need to first have a good grasp of how to use `foldr'
09:01:30 <ski> frontendloader : "how can you define/call a recursive function on lambdabot?" -- use `let'
09:01:41 <Veinor> joelr: cStrings <- mapM newCString strings
09:01:56 <ski> > let fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2) in map fib [0 ..]
09:01:59 <joelr> Veinor: thanks!
09:02:00 <lambdabot>   mueval-core: Time limit exceeded
09:02:11 <ski> > let fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2) in map fib [0 .. 9]
09:02:12 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
09:02:28 <ski> frontendloader : like that, e.g. ^
09:02:30 <Veinor> this is why i like the virthualenv solution more, because it appears to just create a fake ghc, fake cabal, etc that does the right thing
09:03:00 <Veinor> maybe i should take over virthualenv!
09:03:08 <ski> whittle : the key point with quotient types is that you can represent the same conceptual value in several different ways
09:03:24 <dcoutts> Veinor: btw, I recently broke virthualenv by making cabal more picky about the GHC_PACKAGE_PATH stuff
09:03:35 <Veinor> aw
09:03:46 <Veinor> it seems like cabal-dev is the more popular choice right now anyway
09:03:46 <ski> whittle : the most familiar example here is probably that of the rational numbers, each rational number can be represented as a fraction in many ways, e.g. `3/7 = 6/14'
09:04:05 <whittle> ski: Got it. Once again, thank you for your lucid explanations.
09:04:19 <Veinor> no clue why
09:04:30 <uniquenick> is there a simple way to update all the dependencies of a project recursively?  and ideally to remove the old versions after?
09:04:40 <ski> whittle : if you decide to always represent a rational number as a fraction where the numerator and denominator has no non-trivial divisors (and the denominator is positive), then you get a subtype
09:05:19 <dcoutts> Veinor: it's not irretrievably broken, just letting you know if you wanted to maintain it
09:05:19 <whittle> ski: Oh! They’re related!
09:05:20 <ski> whittle : in any case, Haskell doesn't have any explicit way of expressing subtypes nor quotient types -- but i think it's good to have words for what we're commonly after when doing an abstract data type
09:05:24 <whittle> Veinor: Have you tried Vagrant. Much heavier than either cabal-dev or virthualenv, but it works great.
09:06:05 <Veinor> vagrant seems way too heavy
09:06:17 <dcoutts> Veinor: the problem is you should not tell ghc a different package database from the ones you tell cabal
09:06:23 <bitonic> jaspervdj: https://github.com/snoyberg/file-embed/issues/2
09:06:25 <ski> whittle : but in some cases there's no "canonical form" which you could reduce the representation to -- or the canonical form is not computable -- or computing it would be inefficient -- then using a quotient type may be preferred
09:06:41 <Veinor> dcoutts: right
09:07:21 <ski> whittle : though often you still disallow some representations, perhaps doing a "partial canonicalization" (like keeping a tree partially balanced, even if not perfectly balanced) -- so it's often a combination of both
09:08:10 <ski> (like AVL trees and red-black trees, e.g.)
09:10:01 <Veinor> newtype MyMonad a = MyMonad (StateT MyState (ReaderT Options (ErrorT MyException (WriterT [String] IO))) a)
09:10:03 <Veinor> ...
09:10:10 <frontendloader> I don't understand how foldr could be abused (too harsh?) in such a manner
09:10:11 <Veinor> i am now much less enthusiastic about virthualenv
09:10:35 <ski> whittle : btw, Mercury allows you to explicitly specify that a type is to be a quotient type of another type .. (unlike Haskell)
09:10:59 <ski> frontendloader : well, you can use `foldr' to traverse a single list
09:11:20 <ski> frontendloader : and you can use it to traverse a list, and for each element of that list, use `foldr' again to traverse another list
09:11:52 <ski> frontendloader : however, traversing both at the same time, in "lock-step"/"parallel" is harder to do with `foldr'
09:12:52 <ski> my solution of it hinged on thinking about each `foldr' traversal as a coroutine, managing to tell them to "pass the buck" forward and back between each other
09:13:45 <whittle> ski: I felt like I was right with you until you said that a type could be a quotient type of another type. With literal quotients, would rationals be quotient types of integers?
09:13:51 <ski> (and maybe the possibility of doing this means that one could use e.g. `buildr'-`foldr' fusion to optimize away intermediate data structures in a nice way, here)
09:14:11 <frontendloader> zw f xs ys = [f x y | x <- xs | y <- ys]
09:14:16 <frontendloader> thats about as advanced as I get :/
09:14:46 <ski> whittle : rationals would be a quotient of the type of *pairs* of integers and non-zero integers
09:14:48 <frontendloader> fails in a bunch of situations too I'd bet
09:15:13 <ski> whittle : mathematically, a quotient type of `|Z * {n : |Z | n /= 0}'
09:15:26 <whittle> Veinor: Vagrant is very heavy by comparison. On the other hand, it allows complete separation of build environments in a way that the others are only pretending to.
09:16:06 <ski> frontendloader : that's an ok implementation of `zipWith' -- but it's cheating of course, since parallel list comprehensions basically desugar to a call to `Prelude.zipWith' :)
09:17:00 <whittle> ski: Ah! So you wouldn’t say that a type is the quotient type of several other types, but the quotient type of a tuple of types?
09:17:24 <ski> not "tuple of types" but a "tuple type"
09:17:35 <ski> a tuple type is a type of tuples
09:18:06 <ski> (conceptually, a tuple type, and a tuple *of* types, are very different beasts)
09:18:31 <ski> (unfortunately here, the Haskell syntax muddies this distinction)
09:19:02 <whittle> ski: A tuple type isn’t just the number of elements in the tuple (the ordinal?) but also what types are in the tuple?
09:19:46 <rwbarton> a tuple type is *determined* by not just the number of elements in the tuple but also what types are in the tuple
09:19:54 <ski> s/what types are in the tuple/what types the values in the tuples have/
09:20:00 <rwbarton> however, what it is is a new type
09:20:26 <rwbarton> also, what ski said
09:20:29 <ski> informally, we say that `[Int]',`[[(Bool,Char)]]',`[Int -> [Int]]' are all "list types"
09:20:48 <whittle> ski: Of course, because an actual tuple can contain only values, not types themselves.
09:20:56 <ski> similarly, we say that the types `(Int,Bool)',`(Char,[IO ()],Int -> Bool)' are tuple types
09:21:32 <ski> whittle : well, a "tuple of types"/"type tuple" could contain types -- but this doesn't exist in Haskell
09:22:28 <augur> copumpkin: whats a faaaaaaa
09:22:39 <copumpkin> augur: http://www.math.mcgill.ca/rags/difftl/faa-tac.pdf
09:23:00 <whittle> ski: I see. A type tuple would be on a different Principia Mathematica-type level of abstraction.
09:23:13 <augur> copumpkin: hmm
09:23:19 <augur> its got nice pictures, so that's a plus!
09:23:22 <ski> type tuples could be useful when you're doing IndirectComposite on a bunch of mutually-recursive types
09:23:31 <ski> (though type records would be even more useful, here)
09:23:55 <ski> whittle : yeah, a value tuple is a value, having as type a tuple type
09:24:14 <ski> whittle : while a type tuple is a type, having as kind a tuple kind
09:25:58 <whittle> ski: Okay. `(1, True)' is a value tuple of type `(Int,Bool)' of abstract type `(,)' of kind `* -> * -> *'?
09:26:26 <whittle> s/value tuple of type/value tuple of concrete type/
09:26:48 <ski> whittle : let's imagine for a while
09:27:05 <whittle> ski: Okay.
09:27:08 <ski> first, let's imagine the kind `*' was spelled `ConcreteType'
09:27:35 <ski> then, let's imagine the tuple type `(Int,Bool)' was written like `Int * Bool' (ML-style)
09:27:37 <quintessence> whittle: you'd call (Int, Bool) an application of the type constructor (,) (of kind * -> * -> *) to Int :: * and Bool :: *
09:27:59 <ski> then the type of `(1,True)' is `Int * Bool', and the kind of that type is `ConcreteType'
09:28:08 * hackagebot file-embed 0.0.4.3 - Use Template Haskell to embed file contents directly.  http://hackage.haskell.org/package/file-embed-0.0.4.3 (MichaelSnoyman)
09:28:22 <ski> now, `(*)' here is a type constructor, of kind `ConcreteType -> ConcreteType -> ConcreteType'
09:28:44 <ski> or maybe `ConcreteType * ConcreteType -> ConcreteType', if you desugar an infix type to a tupled thing, instead of to a curried thing
09:28:44 <whittle> The same way you used in in the mathematical definition.
09:29:14 <whittle> s/in in/* in/
09:29:55 <ski> so then `(*)' would be a type function which converts a two-tuple of types to the tuple type which has values which are two-tuples (with "element" types being the respective types inside the type tuple)
09:30:06 <ski> whittle : are we sufficiently confused, yet ?
09:30:32 <whittle> ski: I’m repeating that last line aloud a couple of times.
09:31:30 <whittle> ski: A type function is a function that operates at the type echelon instead of the value echelon?
09:31:32 <ski> mm_freak_ : did you want to ask edwardk about uniqueness and linearity ?
09:31:39 <edwardk> ?
09:32:10 <ski> edwardk : mm_freak_ is thinking about linearity and uniqueness, wants to implement some kind of language with update-in-place, at least
09:32:26 <edwardk> ah
09:32:48 <edwardk> i should dig up the nuel source code and send it to him. ;)
09:32:51 <ski> edwardk : i remember you awhile ago figured out some nice way to fit both into a system
09:32:55 <edwardk> yeah
09:33:15 <ski> whittle : yeah, e.g. `Maybe' and `Either Int' are type functions
09:33:31 <whittle> ski: I hope it’s all right that I’m logging this conversation? I’m going to sit with it for a while and then come back and read it over again.
09:33:39 <ski> whittle : basically, a type function is a type which has a kind which looks like `k0 -> k1', for some kinds `k0' and `k1'
09:33:55 <navaati> whittle: it's already logged, see the topic
09:34:01 <ski> whittle : sure, log away to your heart's content
09:34:55 <mm_freak_> ski: right now i don't have questions…  i want to implement the basic type checker and value inference first
09:35:17 <bitonic> whittle: #haskell is already logged
09:35:29 <ski> mm_freak_ : ok
09:35:44 <whittle> navaati, bitonic: Thanks for the heads-up. I totally missed that.
09:36:06 <ski> mm_freak_ : i'm not sure if you've thought about this, but it might be a good idea to write down the typing rules in a nice declarative way, and not just code them up algorithmically
09:37:39 <mm_freak_> ski: that's not my way of thinking…  i always need to see how things perform before i can lift them to a more abstract level
09:37:59 <mm_freak_> in other words:  i could do that now, but it wouldn't help me at this point
09:38:18 <whittle> ski: Thanks for all the help. You are an extraordinarily lucid instructor.
09:38:30 <whittle> Thanks also to byorgey, rwbarton and quintessence for your assistance.
09:39:02 <whittle> I’m going to go write some Haskell code and attempt to incorporate all this.
09:39:10 <nominolo> edwardk: how does you uniqueness+linearity compare with http://www.holdermans.nl/pubs/assets/hage07generic-slides.pdf ?
09:39:26 <nominolo> s/you/your approach to/
09:39:49 <ski> mm_freak_ : ok, sure
09:41:39 <nominolo> there're actually quite a few publications on this from Dutch/Belgian universities.  probably due to Clean
09:42:57 <edwardk> nominolo: pretty different. the main thing i was doing was maintaining a lattice of subtructural type properties, which is really a lattice product of two different lattices, one representing the relevance and the other the 'affinity' of the type involved. the main trick is that linearity and uniqueness are actually quite different. in one sense you can convert a uniqueness type into an unrestricted type
09:43:32 <edwardk> and you can convert an unrestricted type into a linear type, so if you look at it the right way linearity and uniqueness are on the opposite ends of the substructural modality type lattice
09:44:05 <edwardk> my main problem was that when i first stabbed at this i didn't realize how much relevance sucks ;)
09:44:37 <edwardk> in practice we don't care that every contraction of a term is not-weakened, merely that one contraction of it isn't. we want strictness, not relevance
09:45:06 <edwardk> if i had it to do all over again, i'd try to replace the relevance axis with a strictness analysis
09:45:09 <frontendloader> foldr (:) [] [1,2,3] so /thats/ how you traverse with foldr
09:45:45 <ski> > foldr f z [0,1,2]
09:45:46 <lambdabot>   f 0 (f 1 (f 2 z))
09:45:47 <edwardk> the other problem i ran into was that so many compiler optimizations become nigh impossible once you constrain the types that way
09:46:07 <edwardk> you get the power to be very explicit, but you also have the burden of having to be very explicit
09:46:24 <edwardk> that may be surmountable, but it was daunting to me
09:46:43 <hy[er]> Does anybody know if there is a way of listing all of the libraries that use the state monad? I'm interested in what cases it's applicable.
09:47:04 <nominolo> edwardk: yes, that's how I see things
09:47:13 <mm_freak_> just asking for opinions here, and a yes/no would suffice:  would anyone prefer uniqueness/linear typing for IO over a monad?  it seems to have advantages, but also disadvantages, and i find myself wondering how to make this convenient…  i'd probably end up with a state monad anyway
09:47:47 <nominolo> in order to appease such complicated type systems you also have to write your program in a certain way
09:48:06 <edwardk> mm_freak_: i would be okay with making a monad that internally _used_ a linear type. i don't want to replace monads though. 90% of what i write with monads never touches IO
09:48:31 <mm_freak_> edwardk: of course…  this question is really about the specific case of IO
09:48:37 <edwardk> my major problem with Clean is that because they have linear types, they leave all these unnecessary world variables cluttering up their code
09:48:45 <mm_freak_> i will have monads anyway, and i also will have uniqueness/linear types anyway
09:48:50 <edwardk> er uniqueness types
09:49:02 <ski> mm_freak_ : advantages can be to not over-sequentialize things
09:49:24 <edwardk> if you just want it for in-place update purposes strictness and uniqueness (plus affine) will serve you better than pure linear types
09:49:43 <mm_freak_> ski: i don't see how…  i mean you write the same code, but with more functional notation, but with the same explicit flow
09:49:55 <edwardk> better knowledge of values than continuations, makes an otherwise symmetric model asymmetric
09:49:58 <ski> edwardk : yeah, though i saw `sequence' for the state monad in a std lib for Clean :)
09:50:22 <mm_freak_> edwardk: everybody seems to say that, but linear types appear to be cleaner to me
09:50:37 <edwardk> ski: i actually had a nice little monad i wanted to write up that needed uniqueness types, and i went to implement it in clean and … stopped. ;)
09:51:05 <ski> mm_freak_ : in clean, you can divide up the world into the filesystem, the graphics system, and more, and then operations in different subsystems aren't logically ordered wrt each other
09:51:22 <nominolo> mm_freak_: linear types get messy for more complicated types, though (e.g., container types)
09:51:26 <mm_freak_> ski: yeah, that's the main appeal =)
09:51:29 <edwardk> uniqueness is just the property that you have contracted it yet, this means you can create a value imperatively and then share it. this is a really nice principled way to deal with the ST s problem without rank 2 types and an annoying phantom type and a stack discipline of how you use it getting in the way
09:51:52 <ski> mm_freak_ : probably you can do this for different pieces of mutable states, maybe requiring effect typing, though
09:52:24 <mm_freak_> i guess i'll just have to try everything…  i'm used to that anyway now =)
09:53:40 <zaltekk> has anyone from Jane Street ever mentioned why they didn't choose haskell?
09:54:23 <zaltekk> was it simply that the guy that started them down the path to ocmal had used ocaml before and hadn't used haskell?
09:54:30 <nominolo> zaltekk: don't they have some famous O'Caml people there?  Not sure which is the chicken and which is the egg, though
09:55:26 * ski . o O ( "Container Types" <http://sneezy.cs.nott.ac.uk/containers/blog/> )
09:56:24 <nominolo> zaltekk: http://www.quora.com/Programming-Languages/Why-does-Jane-Street-use-OCaml
09:57:23 <zaltekk> nominolo: hmm. yeah, that seems to be all i can find
09:57:25 <nominolo> zaltekk: the second answer suggests that Yaron introduced it and he know OCaml well
09:57:33 <zaltekk> Minksy just happened to have had used ocaml in grad school
09:57:36 <nominolo> s/know/knew/
09:57:40 <copumpkin> I'd imagine it was also due to the fact that back in the day the OCaml compiler was a lot faster than GHC or other Haskell ones
09:57:42 <zaltekk> and their java rewrite of their code was failing
09:57:54 <zaltekk> i just haven't seen him mention whether or not haskell was even thought of
09:58:31 <zaltekk> and that their first iteration was VBA in Excel...
09:58:44 <nominolo> a better question is why Credit Suisse dropped Haskell and switched to F#
09:58:55 <zaltekk> hmm
09:59:12 <zaltekk> i've never considered F# since it's .NET
09:59:29 <nominolo> also Standard Chartered isn't using GHC Haskell, it's using a language similar to Haskell (with a compiler written by Lennart)
09:59:33 <copumpkin> nominolo: I had a chance to ask on of the guys involved but didn't
10:00:01 <nominolo> copumpkin: I think it was for .net interoperability
10:00:07 <copumpkin> probably
10:00:21 <nominolo> and because F# allows you to drop into imperative style, I assume
10:00:41 <copumpkin> now, did they switch before or after a bunch of haskell people left?
10:00:56 <zaltekk> i'm sure visual studio has some nice fancy tools for f#
10:00:58 <copumpkin> was it the cause, the effect, or just unrelated?
10:01:22 <nominolo> copumpkin: yeah, not sure
10:01:57 <nominolo> zaltekk: yes, it has LINQ integration and other nice things, too
10:02:25 <nominolo> a big issue is that they dropped the module system, though
10:02:44 <zaltekk> F# did?
10:03:18 <nominolo> one of the guys in my office is learning OCaml and the lack of type classes is somewhat mitigated via modules/functors.  I wonder how F# deals with having neither
10:03:38 <nominolo> zaltekk: yeah, it's basically like Haskell's module system
10:03:45 <nominolo> or Java/.net.  Nothing fancy.
10:04:09 <ski> (.. the module system of SML,OCaml is one of the best parts of them)
10:04:27 <quintessence> nominolo: it uses .net's object system, so presumably it has class-based dispatch. I wonder how it does type inference though
10:05:01 <nominolo> ski: I don't know.  it's very powerful, but all that ModuleName.t stuff is ugly
10:06:01 <nominolo> ski: and "Map String a" becomes "module StringMap = Map.Make (String)"
10:06:44 <ski> you could do the former in some cases as well
10:06:50 <joelr> is there a package to read configuration files of the format the cabal uses?
10:07:10 <ski> (but there's no higher-order types ..)
10:07:14 <bgamari> How does one turn a Data.Colour.RGBSpace.RGB into a Colour?
10:07:26 <navaati> joelr: the cabal package ?
10:07:32 <joelr> hmm
10:07:46 <joelr> navaati: thanks, i'll take a look
10:07:52 <nominolo> joelr: laksah has a package for that I thingk
10:08:00 <joelr> nominolo: thanks
10:08:15 <rwbarton> bgamari, most likely you want to use sRGB
10:08:25 <joelr> my ghc-7.4.0 seems to lack the ffi package
10:08:27 <joelr> weird
10:08:43 <joelr> cabal list doesn't find it either
10:08:58 <navaati> there is a ffi package ? i thought the ffi stuff were in base
10:09:21 <ClaudiusMaximus> bgamari: possibly combined with uncurryRGB
10:09:25 <bgamari> rwbarton: Yes, but sadly all of the functions in Data.Colour.SRGB appear to take individual components
10:09:30 <Veinor> it is
10:09:33 <Veinor> Foreign is in base
10:09:36 <joelr> navaati: that's a clue!
10:09:42 <bgamari> ClaudiusMaximus: Yes, this is what confuses me. Why does nothing seem to take an RGB?
10:09:59 <zaltekk> anyway, the reason i ask is because i've taken an interest in both software engineering/design and functional programming
10:10:01 <ClaudiusMaximus> bgamari: because RGB is a horrible perceptual hack akin to mp3, probably
10:10:04 <rwbarton> bgamari, and uncurryRGB
10:10:13 <zaltekk> and there isn't much material on the convergence of the two
10:10:22 <rwbarton> the api is a little weird I agree
10:10:56 <bgamari> Alright, as long as it's not just me
10:10:58 <bgamari> Thanks!
10:11:12 <geekosaur> joelr. what exactly are you looking for?  FFI's in the base and has been for a very. very long time
10:11:25 <joelr> geekosaur: sorry, been out of haskell for a few years
10:12:30 <rwbarton> in 7.0.4 there is some package named ffi-1.0
10:13:41 <geekosaur> really?  not base?
10:14:03 <geekosaur> I have 7.0.4 docs up and Foreign is in base
10:14:39 <geekosaur> looks like a backward compatibility stub?
10:19:50 <mm_freak_> nominolo: there is a company behind F#
10:20:05 <mm_freak_> companies don't like open source projects without a dedicated team working on it
10:20:34 <mm_freak_> when i tried to advocate a piece of software the question raised was always like:  "what if the guy stops working on it?"
10:21:32 <navaati> mm_freak_: even for the linux kernel the question is raisen
10:22:09 <mm_freak_> navaati: it's not as bad for linux as it is for, say, haskell
10:22:38 * ski . o O ( "What if the company goes bankrupt ?" )
10:23:22 <lamefun2> what is the map-like function that is (a -> [b]) -> [a] -> [b]? that makes one list of those generated [b] lists?
10:23:32 <cg_morton`> that can never happen, ski.  That's the whole point of managed economies
10:23:37 <nominolo> lamefun2: concatMap?
10:23:40 <nominolo> :t concatMap
10:23:40 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
10:23:46 <mm_freak_> lambdabot: looks like foldM
10:23:49 <benmachine> so I wrote something on a haskellwiki talk page
10:23:55 <benmachine> then I remembered that no-one reads those
10:24:00 <benmachine> so comment please: http://www.haskell.org/haskellwiki/Talk:Typing
10:24:07 <lamefun2> :t map
10:24:07 <mm_freak_> but yeah, concatMap has exactly that signature
10:24:08 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
10:24:39 <benmachine> (I'm making an effort to improve the most visible wiki pages, I think the one on typing is wrong, would appreciate someone agreeing with me, especially if they provide references)
10:24:49 <nominolo> > concatMap show [11..15]
10:24:49 <lambdabot>   "1112131415"
10:24:52 <navaati> lamefun2: that is also (=<<) for the list monad
10:25:31 <ski> benmachine : you appear to have forgotten to leave a signature of some kind
10:25:33 <lamefun2> :t =<<
10:25:34 <lambdabot> parse error on input `=<<'
10:25:36 <benmachine> ski: true, whoops
10:26:04 <navaati> :t  (=<<)
10:26:05 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
10:26:21 <benmachine> ski: I put one at the bottom
10:26:23 <ski> > do x <- [11 .. 15]; show x
10:26:24 <lambdabot>   "1112131415"
10:27:07 <navaati> is it possible to do this using list comprehension ?
10:27:33 <nominolo> > [ show x | x <- [11..15] ]
10:27:33 <lambdabot>   ["11","12","13","14","15"]
10:27:48 <nominolo> > [ c | x <- [11..15], c <- show x ]
10:27:48 <lambdabot>   "1112131415"
10:28:00 <scooty-puff> can anyone thing of a type class method mapST whose base instance would have type Monad m => (forall s . ST s a) -> m a?
10:28:30 <scooty-puff> and general type similar to, but not: t m a -> m' a
10:28:31 <benmachine> scooty-puff: liftST?
10:28:35 <navaati> nominolo: ah, gg
10:28:41 <benmachine> or something?
10:29:02 <copumpkin> scooty-puff: why is that different from return . runST ?
10:29:17 <benmachine> scooty-puff: http://hackage.haskell.org/package/monad-st is this what you wanted
10:29:24 <scooty-puff> well, that instance would be
10:29:34 <scooty-puff> minus the (.) part - prob have to do return (runST m)
10:29:59 <scooty-puff> would like to take a monad transformer (possibly unknown, other than thats its an instance of this class) that has ST at its core
10:30:08 <scooty-puff> and map it to some equivalent type that doesn't
10:30:15 <scooty-puff> and could have .. whatever at its core
10:30:22 <copumpkin> ah, I see
10:30:24 <scooty-puff> benmachine: k
10:30:33 <benmachine> scooty-puff: oh, it might not be what you wanted
10:30:45 <rwbarton> how about a nontrivial example
10:30:46 <benmachine> that is to say, it isn't
10:31:18 <copumpkin> so if you have a: MonadTrans t => t ST a t Identity a
10:31:23 <copumpkin> so if you have a: MonadTrans t => t ST a -> t Identity a
10:31:23 <scooty-puff> well, easier probably to describe that real code (not yet available, though i could link what it is now)
10:31:31 <nominolo> mm_freak_: it's usually more about the possibilty to pay someone to get issues fixed, I suppose
10:31:39 <ski> s/ST/(ST s)/
10:31:47 <copumpkin> yeah
10:31:50 <nominolo> mm_freak_: and MS is putting a lot of weight behind F#
10:31:53 <ski> well, with a `forall s.' in there too
10:32:01 <tromp_> > (36000-3226)/2.7/365
10:32:02 <lambdabot>   33.25621511922882
10:32:06 <mm_freak_> nominolo: that's also a valid reason, yes
10:32:15 <scooty-puff> yep, thats pretty much it, but would be like:
10:32:42 <tromp_> > (36000-3226)/27/365
10:32:43 <lambdabot>   3.3256215119228822
10:33:02 <scooty-puff> (forall m . MonadError MyError (t m), forall m . MonadReader MyConfig (t m)) => Stuff -> m Result - i know not valid syntax
10:33:24 <copumpkin> okay, now I'm confused :P
10:33:39 <scooty-puff> well, actuall Stuff -> t m Result
10:33:43 <copumpkin> zomg :: MonadTrans t => (forall s. t (ST s) a) -> t Identity a
10:33:45 <tromp_> hmm, some crazy ppl bidding on an auction that will last over 3 more years:(
10:33:48 <copumpkin> that isn't what you want?
10:33:56 <scooty-puff> it is
10:34:14 <scooty-puff> i think..
10:34:27 <copumpkin> is there a way to throw a natural transformation into a monad transformer?
10:34:34 <copumpkin> to switch the transformed thing
10:34:45 <ski> should be a monad morphism, no ?
10:34:51 <mm_freak_> copumpkin: like t m a -> t n a?
10:34:54 <bitonic> copumpkin: it's usually mapWhatever
10:35:02 <scooty-puff> mm_freak_: yes, but that would work with ST
10:35:04 <bitonic> @hoogle mapStateT
10:35:05 <lambdabot> Control.Monad.Trans.State.Lazy mapStateT :: (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
10:35:05 <lambdabot> Control.Monad.Trans.State.Strict mapStateT :: (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
10:35:05 <lambdabot> Control.Monad.State.Lazy mapStateT :: (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
10:35:10 <scooty-puff> and the forall s . ST s a thing
10:35:16 <ski> presumably like `(Monad m,Monad n) => (forall a. m a -> n a) -> (forall a. t m a -> t n a)'
10:35:26 <copumpkin> ski: yeah
10:35:41 <copumpkin> but I guess there isn't a generic way to apply that to all monad transformers?
10:35:48 <copumpkin> perhaps a class supporting that is the class you need
10:35:49 <ski> bitonic : those are all too concrete
10:36:13 <ski> yes, obv this would need a class
10:36:20 <ski> `MonadFunctor' or something
10:36:26 <bitonic> ski: what types are we talking about here?
10:36:27 <copumpkin> although getting the higher-rank ST type into the class with all the others would probably be ugly
10:36:39 <ski> bitonic : hm ?
10:36:55 <ski> copumpkin : yeah, i'm not sure how to fit the `forall s.' into stuff
10:37:01 <rwbarton> i recall we were talking about a possible kind-polymorphic Functor class here a while back
10:37:02 <copumpkin> it generally does not fit :/
10:37:32 <ski> i suppose one might be able to do `newtype PolyST a = PST (forall s. ST s a)'
10:37:59 <ski> but then there's still the issue about distributing the `forall s.' to the right place
10:38:34 <Franciman> but why hasn't haskell standardised forall?
10:38:49 <navaati> what are the requirement to upload a package on hackage ?
10:39:04 <bitonic> navaati: have an account
10:39:09 <parcs`> 1) have a hackage account 2) have an internet connection
10:39:09 <roha> if i have to apply a filter function for each point in a 1000x1000 grid. the whole thing has to be applied 50 times. which data structure should on choose for this task? a mutable array? at the moment i use lists but i suppose that's not really efficient
10:39:11 <scooty-puff> hmm... maybe i should just know the ErrorT, ReaderT, WriterT, etc., deconstruct and runST, the rethrow, tell, etc.
10:39:22 <scooty-puff> *then rethrow ...
10:39:35 <scooty-puff> blah
10:40:12 <navaati> roha: check the repa package. very powerfull parallelized stuff
10:40:12 <scooty-puff> i will mess aroudn with PolyST, maybe can some up with something..
10:40:57 <navaati> but what do you mean by "a filter function" ? does it mean that after applying it, you don't anymore have a 1000² grid ?
10:41:14 <schlicht> are there any tools/libs that i can use to render/display latex with haskell?
10:41:24 <navaati> or do you simply mean "mapping a function on every cell" ?
10:41:43 <roha> navaati, yes, but the function depends on the values around this cell
10:41:52 <roha> so there is much indexing going on
10:42:23 <navaati> roha: not really a problem i think
10:42:27 <rwbarton> sounds like you want some sort of immutable array
10:43:21 <navaati> indexing is O(1) with repa
10:43:22 <rwbarton> (such as repa)
10:43:51 <roha> and what would be the advantage of an immutable array over a mutable array in this case?
10:43:57 <quintessence> roha: repa has a stencil convolution module that might be what you're looking for
10:44:03 <navaati> roha: it stays pure
10:44:06 <lamefun2> why Double -> Double -> Double for a 2-arg fn and not Double, Double -> Double?
10:44:20 <allbery_b> currying
10:44:27 <roha> ok so immutable arrays are not that much slower than mutable arrays?
10:44:38 <rwbarton> why would they be slower
10:44:51 <navaati> lamefun2: this is called currying, and it enables one to partially apply functions.
10:44:55 <rwbarton> if immutable arrays support the operations you need, they will not be slower
10:45:01 <rwbarton> the downside is... you can't mutate them
10:45:10 <c_wraith> well. Updating a mutable array means copying the whole thing. that is slower
10:45:17 <c_wraith> But just doing reads is not slower.
10:45:35 <roha> i thought the whole copying of the immutable array slows it down. if i have to modify the array 100x100x50 times
10:45:40 <navaati> c_wraith: no ? you only copy parts that you modify, don't you ?
10:45:50 <rwbarton> aren't you producing new arrays anyways?
10:45:59 <lamefun2> navaati: ? what does it have to do with currying?
10:46:01 <c_wraith> navaati: no, with an immutable array, you copy the whole thing
10:46:16 <lamefun2> many language separate args with , and still has currying
10:46:16 <c_wraith> navaati: unlike with trees or other structures that can take advantage of sharing
10:46:18 <rwbarton> if you are going to modify every element of a 1000x1000 array there is no need to use a mutable data structure...
10:46:23 <roha> c_wraith, so GHC doesn't to any magic to prevent the whole copying?
10:46:29 <navaati> c_wraith: ah, crap
10:46:39 <rwbarton> if you are going to modify *one* element then there is a large copying cost, yes
10:46:51 <c_wraith> roha: what magic would be possible? Either you preserve the previous structure or you don't.
10:47:25 <navaati> c_wraith: wait, the *structure* is copied, but not the elements, right ?
10:47:40 <roha> sorry kind of confused right now. if i have to modify the array 100x100x50 times, doesn't this result in just as much copying of the whole array?
10:47:52 <c_wraith> navaati: yes. however, if the structure is a 2-million entry array, that's not a cheap operation
10:47:53 <roha> if i use an immutable array
10:48:56 <rwbarton> roha: okay let's take a simple example
10:49:06 <rwbarton> imagine you have a big array and for some reason you want to double every element
10:49:09 <navaati> roha: anyway, if you want to stencil-convolute on your array, you can't modify it inplace, so there is no point in having a mutable array : you'll have to copy it anyway
10:49:35 <navaati> s/you'll/you'd/
10:49:45 <rwbarton> if you think of this algorithm as "modify in turn each element so that it becomes double the old value" then you better use a mutable array or you will copy the array every time...
10:49:50 <rwbarton> but that is silly
10:50:14 <rwbarton> you can just say that you are producing a new big array, where each element is twice the corresponding old value
10:50:28 <rwbarton> that will have the same cost as if you were to use a mutable array and double each element
10:50:34 <rwbarton> but it doesn't require mutability in any way
10:50:39 <rwbarton> then, you throw away the old array
10:50:55 <rwbarton> does that make sense?
10:51:13 <roha> so if i map (*2) over an array the array is only copied 1 time?
10:51:15 <navaati> rwbarton: time cost is the same, but mem cost is double, no ?
10:51:23 <navaati> roha: of course
10:51:23 <rwbarton> sure
10:51:40 <copumpkin> ski: can you write a functor instance for PolyST without running the computation?
10:52:04 <rwbarton> also as navaati says, it's probable that you can't do your transformation in place anyways...
10:52:17 <copumpkin> oh, I guess
10:52:42 <roha> ok thanks, i think ill get it now :)
10:52:43 <rwbarton> or at least, you would need special tricks to do so
10:53:00 <rwbarton> if the new value depends not only on the old value in that cell, but in neighboring cells as well
10:54:01 <navaati> so, short answer : use repa, and enjoy automatically threaded code :)
10:54:47 <scooty-puff> so when dealing with weak pointers (i've kind of been going on about this lately), need to make sure stuff isn't unboxed to primitives too early (so that i make a weak pointer to a just-boxed-and-thrown-away, etc.)
10:55:19 <roha> thanks, im going to use repa then. :)
10:55:35 <scooty-puff> so had been using NOINLINE to hide some stuff, and some combinators of the form Key -> a -> (Key -> Weak a -> IO b) -> IO b
10:55:39 <scooty-puff> (marked noinline)
10:55:44 <scooty-puff> is there a more robust way?
10:55:59 <scooty-puff> maybe disable that optimization (unboxing) and manually handle it?
10:56:11 <scooty-puff> (if thats possible?)
10:57:09 <navaati> scooty-puff: there is something like a NOUNBOX pragma, see ghc's doc
10:57:13 <scooty-puff> k
10:57:31 <gwern> @remember StevenKaas Haskell's Wager: what if infinite lists can suffer infinitely even when lazily evaluated?
10:57:32 <lambdabot> Okay.
10:57:34 <gwern> @flush
10:57:40 <gwern> @quote Wager
10:57:40 <lambdabot> StevenKaas says: Haskell's Wager: what if infinite lists can suffer infinitely even when lazily evaluated?
11:16:13 <proq> does anyone know if anything like rubymotion is coming out or already possible for iphone dev?
11:16:47 <zaltekk> proq: haskell for ios?
11:16:57 <proq> zaltekk: yeah
11:17:01 <zaltekk> http://www.haskell.org/haskellwiki/IPhone
11:27:10 <yan_> so i'm inside an IO monad and i have a few funcs that are of type (foo -> IO foo), func1, func2, etc and i have a [foo] which i need to operate on.. doing 'mapM (func1 >>= func2) foos' gives a type error.. what am i misunderstanding?
11:27:43 <shachaf> yan_: Maybe you want (>=>)?
11:27:46 <shachaf> @ty (>>=)
11:27:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
11:27:49 <shachaf> @ty (>=>)
11:27:49 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
11:27:56 <alpounet> you definitely want >=>
11:28:11 <alpounet> >>= takes a monadic value/action and a function
11:28:21 <alpounet> whereas >=> is "monadic composition"
11:29:01 <yan_> shachaf, alpounet: yup looks to be exactly what i need, and trying to think of why i forgot of its existence earlier
11:29:14 <shachaf> Because no one ever uses it. :-)
11:29:36 <yan_> shachaf: hm, this makes me think i'm not writing idiomatic haskell
11:29:50 <colah> Since I was rambeling about this here yesterday: https://github.com/colah/HaskSymb
11:29:53 <shachaf> No, if it works for you then it's fine.
11:30:04 <shachaf> Just in practice I rarely see it used.
11:30:18 <Eelis> edwardk: any chance pointed and comonad-transformers (and the things they depend on) can be made to compile with containers 5.0 ?
11:30:27 <edwardk> sure
11:30:33 <Eelis> sorry, i meant 0.5 :)
11:31:31 <edwardk> i have about 38 packages i need to push with that update
11:31:32 <navaati> shachaf: when you like point-free, you use it all the time :)
11:31:38 <Eelis> edwardk: wow
11:32:01 <edwardk> i just searched my haskell folder for cabal files for projects i own which have an upper bound on containers. =/
11:32:03 <Eelis> in general, are upper bounds on versions really worth it? so far i've seen them cause more headache than they probably prevent
11:32:22 <Eelis> i'm thinking of removing all upper bounds from the packages i maintain
11:32:26 <edwardk> yes, in this case the major version change hides serious api changes
11:32:30 <edwardk> please don't
11:32:53 <edwardk> if you do, then i'll be hard pressed to bring myself to transitively depend on them, since then my code will just randomly break some day
11:33:07 <Eelis> random breakage is exactly what i'm seeing as a result of the upper bounds :)
11:33:35 <edwardk> well, the main thing I try to ensure is that my code works with both the current platform and with the bleeding edge
11:33:37 <navaati> why is an instance Monad m => Category (a -> m b) impossible ?
11:33:54 <shachaf> Eelis: Configure-time breakage is better than compile-time/run-time breakage.
11:34:04 <chrisdone> dcoutts: hey, how do you recommend specifying a custom compiler with Cabal package descriptions? in the manual i only see --with-compiler, which seems for specific ghc versions, though i imagine i can use that to specify my custom compiler, it would be suave to specify inside my cabal file if possible. build-type of custom probably could be a nice approach. i see in the API i can use OtherCompiler
11:34:04 <edwardk> navaati: because a.) the kinds don't make sense, and b, it would overlap with just about everything
11:34:05 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
11:34:27 <edwardk> navaati: how would you know whether you wanted to do kleisli composition or if you meant (.) for function composition for instance?
11:34:34 <luite> hey chrisdone :)
11:34:34 <shachaf> navaati: Category instances have kind * -> * -> *
11:34:40 <Eelis> shachaf: sure, but unnecessary breakage is worse than no breakage ;)
11:34:40 <luite> chrisdone: i'm working on ghcjs atm
11:34:42 * chrisdone waves
11:34:49 <edwardk> navaati: its easy to construct impossible to typecheck examples
11:34:55 <chrisdone> luite: having fun? ;-)
11:35:22 <navaati> edwardk: about the kind not making sense, yeah, i was wondering if it's only possible to express that. One would need lambdas at the type level : "Monad m => Category (\a b -> (a -> m b))" x)
11:35:25 <Eelis> shachaf: and more often than not, the breakages caused by upper bounds turn out unnecessary
11:35:32 <luite> chrisdone: i have the codegenerator working with ghc 7.4 now, and switched the module loader from its own lazy thing to requirejs (which can run closure to combine everything for you)
11:36:14 <shachaf> Eelis: Yes. It would be nice if version numbers had more information so it would be easier to guarantee correctness.
11:36:30 <navaati> about the second point, well… "ah shit"
11:36:30 <edwardk> Eelis: given my druthers, i'd rather have the dependencies managed more like the gnu versioning scheme, where you explicitly state the oldest api that you are compatible with, and the library provider makes the claims of backwards compatibility to older versions of their api, i realize the pvp is intended to model this but i find the gnu versioning scheme nicer
11:36:36 <shachaf> navaati: Generally you use a newtype for that sort of thing.
11:36:43 <shachaf> Since there aren't actual type lambdas.
11:36:45 <Eelis> edwardk: sounds cool
11:36:46 <chrisdone> quicksilver: fwiw hpaste's stylesheet is here: https://github.com/chrisdone/hpaste/blob/master/src/Amelie/View/Style.hs
11:36:46 <chrisdone> quicksilver: i'll add the monospace font to the textareas
11:36:50 <shachaf> Kleisli is the newtype you want here. :-)
11:37:11 <edwardk> navaati: if you allow arbitrary type lambdas it becomes impossible to infer
11:37:33 <navaati> shachaf: i know, but it make the kleisli category horrible to use : you need to wrap and unwrap all the time…
11:37:37 <edwardk> navaati: there are papers on the topic of how to push that a little, but its easy to see
11:37:51 <edwardk> navaati: or you just use >=> and <=<
11:37:57 <chrisdone> luite: excellent. what are you writing?
11:38:01 <luite> chrisdone: problem is still that the code size is quite horrible
11:38:09 <shachaf> And return.
11:38:28 <luite> chrisdone: eventually i hope to move most haskell evaluation of wolfgang to the client
11:38:37 <mm_freak_> wow, parsec uses a really bad representation for errors
11:38:50 <navaati> edwardk: indeed. you can't use arrows stuff, though
11:38:56 <edwardk> mm_freak_: yep, that was part of why i wrote trifecta. i _couldn't_ build it on parsec =(
11:39:32 <Eelis> i guess upper bounds are okay if the maintainer has enough time and energy to constantly keep track of new versions of the package's dependencies and bump the package's bound. i really, really don't have that time and energy though :D
11:39:34 <luite> chrisdone: but hopefully it will be more generally useful
11:39:35 <chrisdone> luite: nod. how big is it? about 1.8mb?
11:39:38 <edwardk> navaati: there isn't much there i want to use. anyways, kleisli is a little newtype noisy, but there isn't a good alternative
11:39:57 <mm_freak_> at least my parser works now, and i have a much better understanding of how to parse programming languages
11:40:00 <luite> chrisdone: uh, the base library, ghc-prim and integer-simple are 10MB uncompressed, around 1MB gzipped (without minification)
11:40:09 <edwardk> Eelis: then don't bother. update as the platform comes out and tell everyone tough luck until then ;)
11:40:12 <aristid> edwardk: did you look at uu-parsinglib? :P
11:40:29 <mm_freak_> edwardk: luckily i designed my library such that i can switch to other parser libraries easily =)
11:40:30 <edwardk> aristid: yes. i even cleaned up the code for it when it first came out so i could read it
11:40:40 <Eelis> edwardk: i've actually been doing that, but my users keep complaining
11:40:42 <mm_freak_> so i might find myself switching to trifecta sooner or later
11:40:57 <chrisdone> luite: right… heavy stuff. alright for a non-busy application probably
11:41:01 <luite> chrisdone: but i think the code generator can be optimized a whole lot, and probably some parts of base should be swapped out for "native" javascript implementations
11:41:14 <edwardk> Eelis: i'd rather have the 'hey i can't build this' false positives than the 'hey your code does wrong things' false positives
11:41:29 <edwardk> Eelis: its a matter of choosing between type 1 and type 2 error ;)
11:41:29 <Eelis> i'm not too worried about the latter
11:41:33 <ybit> http://www.haskell.org/haskellwiki/The_JavaScript_Problem :: what's this "finicky equality/automatic conversion", is it referencing ==, ===  and NaN == NaN returning False?
11:41:40 <aristid> edwardk: but it also didn't fit your needs?
11:41:59 <edwardk> aristid: uu-parsinglib is more of a proof of concept than a usable library
11:42:27 <Eelis> i don't mind shipping software with a general disclaimer of "this program will be broken if the libraries it uses broke backward compatibility at some point"
11:42:28 <luite> chrisdone: and ghcjs outputs lots of intermediate variables that it uses just for one assignment, i think that closure can remove a lot of code bloat
11:42:49 <luite> chrisdone: dunno about dead code elimination yet, i want to optimize the output for that
11:42:57 <chrisdone> luite: yeah, closure removes some dead code
11:43:05 <aristid> edwardk: oh, seems like trifecta has some API docs now
11:43:49 <luite> chrisdone: anyway my short term goal is to get diagrams to build on this, and then generate an interactive svg :)
11:44:13 <edwardk> it also made me downright sad to find 'instance Applicative f => Functor f' in the uu-parsinglib code.
11:44:42 <edwardk> they have since fixed that rather egregious misunderstanding of how instances work, but wow.
11:45:07 <chrisdone> luite: it's unable to optimize things like foo.bar where it's unknown whether .bar will be abilable at runtime. some other things i learned: it doesn't optimize if(X){ x } if (X) { y } into if (X) { x ; y }, and it doesn't remove “var foo = (function(){ … foo })” self-referencing var calls
11:45:19 <luite> chrisdone: btw do you have any preference for dealing with lots of js files? i have a fairly simple require.js scheme atm, don'tknow if that's an acceptable requirement
11:46:43 <chrisdone> luite: i personally and my more experienced colleague (author of uglifyjs) prefer one big JS file, less overhead that way. (also more chance for output optimization when considered as a whole)
11:47:05 --- mode: ChanServ set +o mauke
11:47:05 --- mode: mauke set -b *!*@gateway/web/freenode/ip.81.210.14.160
11:47:40 <luite> chrisdone: right, my idea was to use require.js for development, just loading a .js for every module, and for deployment running through the r.js tool that combines a module with all its dependencies
11:47:52 <edwardk> i'm somewhere in the middle. if i have a lot of common js for a site, i tend to package it all up, but if the page has one-off javascript that builds on the common core i package that separately. that way i can take advantage of the caching browser side for the core
11:48:56 <edwardk> i do tend to write it all as separate javascript files though, even use c preprocessing to link it all together before minimizing, etc.
11:49:05 --- mode: mauke set -o mauke
11:49:16 <edwardk> or at least i used to. haven't written any javascript in a couple years
11:49:21 <luite> do you use separate js files in development?
11:49:25 <chrisdone> sure. i also write everything as separate js files, better for development
11:49:37 <luite> where use = send to browser
11:49:40 <chrisdone> (but obv. make on distribution for production)
11:50:11 --- mode: ChanServ set +o copumpkin
11:50:15 <edwardk> luite: nah, basically i let the make process i use for the site bundle and minimize or not (in development i may avoid minimization/atomization)
11:50:27 <edwardk> but in development they tend to look like http://comonad.com/js/cps/Thread.js
11:50:30 --- mode: copumpkin set +b *!null@ugh.thatss.smelly.cc:##fix_your_connection
11:50:33 <copumpkin> is that the secret?
11:50:36 <luite> edwardk: oh that would give you very long files in the js debugger
11:50:45 <copumpkin> I guess not
11:50:50 --- mode: copumpkin set -b *!null@ugh.thatss.smelly.cc:##fix_your_connection
11:50:50 <edwardk> yeah
11:50:56 <copumpkin> I can never remember how to do redirect bans
11:51:03 --- mode: copumpkin set +b *!null@ugh.thatss.smelly.cc$##fix_your_connection
11:51:08 <copumpkin> let's try that
11:51:11 <edwardk> i still have the line directives bundled in comments to figure out where i am in an absolute sense though
11:51:43 <luite> chrisdone: ok, i'll ask about more input later. i really wanted to change the loading method, because the old ghcjs method made it impossible to view the code in the debugger
11:52:05 <luite> it loaded modules with XHR, and then just eval'd them to inject some properties in a global $hs object
11:52:11 <chrisdone> yeah, not great
11:52:30 --- mode: copumpkin set -o copumpkin
11:53:14 <chrisdone> luite: this hs->js example works: http://hpaste.org/68137
11:53:39 <chrisdone> luite: the first annotation includes the runtime/libs, second annotation is just the program-specific code
11:54:02 <chrisdone> (if it didn't require jQuery you could paste the second example into the js console)
11:56:10 <luite> chrisdone: ah cool, I don't have a proper prelude or foreign library yet, although it's easy to make foreign imports
11:56:30 <chrisdone> luite: if anything i'm catering to the 'lightweight code' use-case, and also learning lessons that will come in handy to optimise ghcjs later on
11:56:34 <luite> where's your rts?
11:56:40 <tgeeky_> luite: I wish you guys whould get together and spell out the differences/similarities in your approaches (also versus ghcjs and existing techniques)
11:57:26 <hpaste> chrisdone pasted “(preliminary) runtime” at http://hpaste.org/68190
11:57:41 <luite> chrisdone: yeah i definitely want to use your experience for that :p
11:57:51 <chrisdone> tgeeky_: http://www.haskell.org/haskellwiki/The_JavaScript_Problem -- does this help somewhat?
11:58:54 <tgeeky_> chrisdone: only somewhat
11:59:24 <luite> ghcjs is obviously much lower level code
11:59:44 <chrisdone> luite: it's drastically simple — its main advantage is simplicity. the advantages to ghcjs are clear
11:59:45 <luite> but i'm not sure if it would be best to keep generating code from the stg phase, or to move back to core
12:00:03 <chrisdone> luite: why exactly does it generate from stg and not core?
12:00:18 <luite> uh dunno, i didn't make the choice :)
12:01:31 <luite> it already bit me once, because stg has optimized int literals, which are optimized for integer-gmp if ghcjs is built with a ghc that uses integer-gmp
12:01:36 <Franciman> do you know of any netbeans plugin for haskell?
12:01:57 <tgeeky_> Franciman: if it exists, it's probably not very good.
12:02:04 <luite> so i have to deoptimize int literals first, before coreprepping and translating to stg
12:02:24 <Franciman> so I have found my mission
12:02:27 <luite> optimized literals use the S# constructor directly for small ints
12:02:29 <chrisdone> tgeeky_: uhc and ghcjs are two sides of the same coin, a bunch of the UU guys are developing UHC and trying to use it to make apps. ghcjs has a couple guys working on it, but the main author is MIA. they're both nice because they fully support the features of both compilers, but they output huge gobs of code (megabytes of it) just to get started. i wrote a little compiler to javascript for a strict subset of haskell as demo'd above,
12:02:29 <chrisdone> with the aim of being simple and outputting tiny (and performant) code, as demo'd above, it does that. that's about it afaik
12:02:29 <tgeeky_> Franciman: there is cutting edge support for eclipse, vim and emacs
12:02:32 <luite> which integer-simple doesn't have
12:02:52 <tgeeky_> Franciman: FWIW, there are a few "editor-support" libraries that will make the process of supporting haskell in any editor much smoother
12:02:57 <chrisdone> luite: hm, i see
12:03:10 <Franciman> yeah thanks
12:03:15 <Franciman> btw that's just an addition
12:03:33 <Franciman> to let netbeans-ers use their favorite ide with their favorite language
12:03:56 <luite> tgeeky_: i think the approaches work towards the same goal, chrisdones compiler by adding more features and typechecking, uhc/ghcjs by (hopefully) improving the code generator to reduce code bloat and improve performance
12:04:23 <luite> but i dunnno if that goal is reachable
12:04:24 <chrisdone> indeed
12:04:57 <tgeeky_> ghcjs's hello world is megabytes? :(
12:05:02 <chrisdone> yeah
12:05:18 <luite> tgeeky_: 10MB
12:05:34 <luite> tgeeky_: although the browser doesn't load all that
12:07:43 <hpaste> “hj hello world” pasted “chrisdone” at http://hpaste.org/68191
12:07:47 <luite> tgeeky_: a fresh request transfers 5.89MB
12:08:01 <hpaste> chrisdone annotated “chrisdone” with “complete optimized output” at http://hpaste.org/68191#a68192
12:08:17 <chrisdone> now you can copy-paste that output into the console and run it :-)
12:08:21 <luite>  hehe
12:08:37 <tgeeky_> chrisdone: so you're making an honest-to-goodness FFI for javascript?
12:08:39 <luite> tgeeky_: but that's completely unoptimized
12:09:27 <luite> tgeeky_: i think that some code overhead should be acceptable for wolfgang, but for busy sites, chrisdones compiler is probably a better idea in the short term
12:10:42 <chrisdone> in the short term, indeed
12:10:47 <luite> long term: we get google to host the ghc base libs in their cdn so that everyone has most things already cached!
12:10:54 <chrisdone> ;)
12:11:10 <chrisdone> tgeeky_: honest-to-goodness ffi?
12:11:47 <luite> anyway, back to scripting: dump ghc-pkg list, extract dependencies of some package (diagrams!), compile everything with ghcjs
12:12:10 <luite> next step: compile simple diagram, wait 5 minutes for svg to render
12:12:42 <chrisdone> i had two bugs in production today due to javascript type errors
12:12:48 <luite> :(
12:13:08 <sclv> silly chris, javascript doesn't have types :-)
12:13:09 <chrisdone> so i'm more motivated to start swapping code for haskell ;)
12:13:21 <luite> i got lots of TypeErrors yesterday
12:13:26 <sclv> no types = no type errors!
12:13:33 <sclv> qed.
12:13:34 <luite> because of the wrong closure type for int literals
12:14:00 <chrisdone> i rarely get errors producing features but refactoring/changing produces the most subtle bugs and edge cases
12:14:15 <chrisdone> luite: wrong closure type?
12:15:15 <luite> chrisdone: yeah it generated code for integer-gmp, so it made a Data thunk with constructor tag for S# and an integer data parameter, but it expected some function thunk to build an Integer
12:15:19 <luite> for integer-simple
12:15:28 <chrisdone> yeah… that kind of stuff scares me
12:15:46 <chrisdone> i don't like not knowing whether the code the compiler accepted will actually run
12:15:46 <luite> that's a bit icky about ghcjs: everything is usually built against the native ghc installation
12:16:25 <luite> so if you have differences, #ifdef or anything, that will result in type differences, you will likely end up with wrong javascript
12:16:39 <chrisdone> :/
12:17:18 <luite> i think that most of this can be fixed by properly hiding packages, but there are some edge cases with the base package and the integer one
12:17:36 <luite> the coreprep step processes ineger literals based on the host ghc, and it's not configurable
12:22:21 <navaati> the Category class says "id and (.) must form a monoid". Is it enough to describe the rules an instance must follow ?
12:22:42 <chrisdone> luite: just discovered this: https://github.com/valderman/haste-compiler
12:23:21 <luite> lol another one...
12:23:29 <chrisdone> seems similar to ghcjs
12:23:48 <luite> yeah similar approach
12:23:58 <luite> i don't like the GPL-3 though
12:24:59 <chrisdone> can always bother the author about licensing
12:25:02 <luite> yeah
12:25:18 <luite> it uses the ghc api to compile to stg
12:25:26 <chrisdone> its precedessor was lambdascript https://github.com/valderman/lambdascript/
12:28:09 <ski> navaati : huh ?
12:28:33 * hackagebot histogram-fill-cereal 0.6.2.0 - Library for histograms creation.  http://hackage.haskell.org/package/histogram-fill-cereal-0.6.2.0 (AlexeyKhudyakov)
12:28:36 <chrisdone> luite: which was this kind of nice and small not-really-haskell. then there's that Elm project. after seeing these two and noticing that people (including myself) would be happy even with a kind of dumb but type-safe language compiling to JS--anything but js--happy to forgo all the libraries and features provided by haskell for at least *something*… i might as well spend a weekend making something to compile a subset of haskell
12:28:38 <navaati> i suppose there are "category rules" like there are "monad rules", right ?
12:28:41 <luite> chrisdone: so he basically started with your approach and then ended up with taking ghcjs' instead :)
12:28:55 <chrisdone> luite: yep ;-)
12:29:17 <luite> bah not good, 10 different not-quite-ready haskell->js thingies
12:29:38 <chrisdone> this is how the web frameworks started :p
12:29:46 <navaati> (if it's unclear : s/the Category class says/the haddock comment of the Category class says/)
12:30:10 <ski> navaati : by "rules" do you mean the associated laws ?
12:30:16 <navaati> ski: yes
12:30:28 <ski> navaati : also, i'm not clear on what you're really asking about
12:30:41 <rwbarton> well it would be better to say that id and (.) must form ... a category
12:31:02 <luite> chrisdone: but i still think that having a real language on the client is much better than some server-side dsl for generating javascript
12:31:08 <ski> navaati : in the case of `Category', you should imo state the expected laws formally, and possibly also add a comment or two explaining them
12:31:12 <rwbarton> which looks the same in equation form, id . f = f = f . id and (f . g) . h = f . (g . h)
12:31:51 <ski> yeah, like in rwbarton's, though i would add explicit `forall f.' and `forall f g h.' in there
12:31:53 <chrisdone> luite: yeah even with the DSL you're still writing JS semantics
12:32:10 <rwbarton> I think navaati is referring to http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Category.html#t:Category
12:32:24 <navaati> rwbarton: yup
12:33:53 <ski> navaati : so are you asking about whether that should state the laws explicitly, or about a class of your own which you're documenting ?
12:34:55 <navaati> ski i'm wondering if "id and (.) must form a monoid" describes the category laws
12:34:57 <luite> chrisdone: i'll install this thing and see what kind of code it makes :)
12:35:55 <navaati> s/describes/is mathematically equivalent to/
12:36:04 <chrisdone> luite: tbh mine is already ready to be used in production after a few days of work. it's so small i can just replace or write some small features with it to start with, and it's so simple i have little to worry about regarding the output, it's quite readable. and fast. also helps that i wrote it.
12:36:04 <chrisdone> luite: i'm a kinda get-the-simplest-possible-solution-working-well-and-expand-later kinda guy :-)
12:36:18 <rwbarton> navaati: a monoid is a category with just one object
12:36:24 <chrisdone> luite: yeah, let me know if its output is small as advertised
12:36:28 <rwbarton> so in that regard the laws are the same
12:36:50 <navaati> rwbarton: aaaah. interesting, thanks
12:36:51 <rwbarton> however the often-omitted "for all f g h such that ..." carries a different meaning
12:36:53 <chrisdone> luite: (i meant after a few days of work from starting the project, not 'it will be ready in a few days')
12:38:16 <luite> chrisdone: yeah my primary application is a site where you can evaluate haskell, it wouldn't make much sense to not support proper haskell :)
12:38:33 * hackagebot leveldb-haskell 0.1.0 - Haskell bindings to LevelDB  http://hackage.haskell.org/package/leveldb-haskell-0.1.0 (KimAltintop)
12:38:35 <navaati> rwbarton: you mean that if the type A is a category, it's a category with the only object being A and (.) being mappend
12:39:50 <chrisdone> luite: indeed
12:40:09 <chrisdone> luite: which is why i presume the licensing is an issue for you, in case you want to distribute
12:40:27 * chrisdone . o O ( LevelDB? )
12:40:51 <chrisdone> ah, another key-value store
12:41:11 <luite> yeah
12:41:20 <rwbarton> if a type A is a monoid then we can think of it as a category C with a single object x and set of morphisms A from x to x
12:41:28 <luite> and i want to modify the rts so that readFile cn open files from the wiki
12:41:37 <rwbarton> what the object "is" is immaterial
12:42:15 <luite> ok building haste libraries
12:42:33 <chrisdone> right, that would be sweet
12:42:46 <luite> it crashes...
12:42:48 <luite> buh
12:42:51 <chrisdone> lol
12:42:51 <luite> but it still generates some files
12:43:10 <chrisdone> the good old crashed-but-still-did-some-stuff result
12:43:37 <ski> navaati : however, the typings for the laws are more general
12:43:44 <luite> so far it has generated 11MB code
12:43:53 <jfischoff> chrisdone: I call that programming ;)
12:44:07 <bitonic> chrisdone: btw, answering to you original question, I'm pretty sure you can specify whatever you want with --with-compiler
12:44:15 <bitonic> chrisdone: afaik you just give the executable name
12:44:19 <chrisdone> jfischoff: dijkstra would not have liked this :p
12:44:28 <ski> navaati : so, saying "`1' and `(*)' in a monoid must form a category" is more correct than saying "`id' and `(.)' in a category must form a monoid"
12:44:41 <jfischoff> @quote dijkstra
12:44:41 <lambdabot> Dijkstra says: I mean, if 10 years from now, when you are doing something quick and dirty, you suddenly visualize that I am looking over your shoulders and say to yourself "Dijkstra would not have
12:44:41 <lambdabot> liked this", well, that would be enough immortality for me.
12:45:05 <bitonic> shit, which is exactly what happened.
12:45:10 <chrisdone> i actually have a poster of dijkstra next to my desk at work, looking down on me
12:45:14 <bitonic> good job, Dijkstra
12:45:25 <akosch> chrisdone: me too
12:45:37 <chrisdone> bitonic: sure -- but preferably i could specify in the cabal file
12:46:04 <akosch> chrisdone: I have this one: http://lemonodor.com/images/dijkstra-quick-n-dirty-s.jpg
12:46:11 <bitonic> chrisdone: I don't think it's the cabal file responsibility to decide what to compile with...
12:46:29 <luite> chrisdone: hmm, it uses some binary format
12:46:32 <chrisdone> akosch: me too :-)
12:46:39 <bitonic> akosch, chrisdone: can I buy those somewhere?
12:46:54 <chrisdone> bitonic: dunno, i got it printed off
12:47:03 <akosch> bitonic: I just printed it, it's small but effective :)
12:47:05 <dcoutts> chrisdone: right, the package builder not package author should decide the compiler
12:47:07 * bitonic can't be bothered :P
12:47:21 <navaati> hum… i think i'm confused about what a category and a monoid are, and i'm confused because of the haskell typeclass formulation
12:47:26 <chrisdone> bitonic: well, in cabal you can specifcy the compiler, ghc/nhc/uhc/etc.
12:47:34 <bitonic> chrisdone: no, just what you tested with
12:47:41 <bitonic> (in the cabal file)
12:47:52 <dcoutts> chrisdone: you can only select that on the cabal command line atm
12:48:27 <bitonic> but I think that's a feature, I can't see why you would want to specify what to compile with in the cabal file
12:48:30 <dcoutts> we will likely eventually provide a way to specify these builder flags in a file, but it will not be the .cabal file
12:48:54 <dcoutts> as bitonic says, it's a feature: allowing separating the roles of package author and package builder
12:49:37 <chrisdone> (ah, right, the manual only mentions compiler as a field *type*, not a field)
12:50:46 <luite> chrisdone: it looks like its main gain is that it uses arrays to return most things instead of objects
12:52:14 <ski> akosch,chrisdone : <http://johnhdoe.com/me/images/doing-it-wrong.jpg>
12:52:51 <younder>  /#vim
12:52:58 <younder>  /#vim
12:53:18 <chrisdone> dcoutts: given that cabal allows me to specify build tools i wouldn't mind also being able to specify the compiler that is capable of building my program, but i see the rationale
12:53:21 <bitonic> younder: nope.
12:53:24 <Botje> younder: try /j #vim
12:53:39 <luite> chrisdone: ah found how to output stuff to js
12:53:47 <chrisdone> possibly i can make a post-build hook or otherwise use Shake
12:54:22 <chrisdone> luite: right… arrays aren't a big win in any sense
12:54:33 <luite> chrisdone: gzipped code size (unminified) for integer-simple GHC.Integer.Type, ghcjs: 13278, haste: 13551
12:54:42 <chrisdone> ski: seen it… i might print it off too :p
12:54:44 <dcoutts> chrisdone: the idea is that by default we should allow portable code, so we can specify constraints on the compiler (like language extensions, and library versions) but we don't need to specify which compiler(s) are compatible
12:55:01 <otters> http://hackage.haskell.org/packages/archive/unordered-containers/0.1.3.0/doc/html/Data-HashSet.html#v:member
12:55:07 <dcoutts> chrisdone: other build tools are more implementation defined
12:55:11 <otters> what is W in O(min(n,W))?
12:55:19 <luite> chrisdone: i think property access for objects is probably really optimized in modern javascript interpreters
12:55:21 <chrisdone> dcoutts: sure
12:55:28 <bitonic> otters: it says at the top of the page
12:55:40 <otters> oh
12:55:45 <dcoutts> chrisdone: otoh, there is a missing spot for explicitly non-portable packages of various sorts.
12:56:00 <otters> silly me
12:56:24 <chrisdone> luite: in v8 a declared object is compiled to a proper struct with pointers (that's why i use them for Cons and Thunk, it's demonstrably faster0. otherwise it has to use a dictionary with the associated lookup overhead
12:57:15 <bitonic> otters: you can read it as O(1)
12:57:21 <otters> sweet
12:57:38 <rribeiro> Hi folks... Is there some that's familiarized with Jone's Theory of Qualified Types to answer some questions?
12:58:41 <chrisdone> dcoutts: right… large applications due tend to make non-portable assumptions due to expedience (and assurance). though in this case i'm just experimenting with using my haskell→js compiler in a convenient way
12:59:23 <luite> chrisdone: haste does generate a little smarter code, if(x==1) .. else, instead of case 1:, case 2:
12:59:31 <dcoutts> chrisdone: right, it'd be more for use cases where you're not distributing the source or making a reusable component and building something in the context of a bigger system
12:59:54 <luite> and minified variables
13:00:00 <luite> but other than that it looks quite similar
13:00:00 <dcoutts> chrisdone: though that may also be better served by being able to give a builder config file
13:00:06 <luite> both use the same stg as source of course
13:00:30 <dcoutts> chrisdone: that is, specify which ghc in the builder config file not the .cabal file
13:00:35 <rribeiro> My question is, I believe, simple; but I'm unable to provide a good answer to it
13:01:27 <rribeiro> how to prove, using the entailment relation that Eq [a] is entailed by P = {forall a . Eq a => Eq [a]}
13:02:23 <chrisdone> dcoutts: right. so the package description remains generic but i can instantiate it with some specific stuff. how would that look? cabal configure --config foo.cabal-conf or something?
13:02:46 <dcoutts> chrisdone: in my imagination it'd look a lot like the existing ~/.cabal/config file
13:02:53 <luite> chrisdone: hm, i think there's some optimization for ghcjs: if there are only two constructors, the second case can always be default, closure compiler can probably take it from there
13:02:54 <chrisdone> luite: yeah that's alright. does the outputted code work?
13:03:20 <chrisdone> dcoutts: ahhh
13:03:20 <dcoutts> chrisdone: perhaps with some ui to help make a default config or something
13:03:22 <luite> chrisdone: dunno, that's more work to test :p
13:03:34 <luite> chrisdone: looks like the main thing he has going for it is a bigger standard lib
13:03:53 <luite> maybe deployment is easier
13:03:57 <dcoutts> chrisdone: and it'd let you specify everything you can specify with "cabal configure"
13:05:17 <luite> chrisdone: nope doesn't work, you need ghc 7.2 for it, 7.0 and 7.4 don't work
13:05:28 <luite> it's missing modules from the base lib
13:06:32 <chrisdone> dcoutts: btw the cabal init has always been such a nice thing for me. every little project i make in cabal i go straight to my ~/Projects/me dir mkdir project; cabal init *tap tap tap* and start hacking :-)
13:06:48 <chrisdone> s/in cabal/in haskell/
13:06:52 <dcoutts> great
13:07:06 <dcoutts> chrisdone: we streamlined cabal init a bit in the latest release
13:07:45 <chrisdone> dcoutts: in what sense?
13:08:03 <Mathnerd314> does eclipsefp have indentation support?
13:08:16 <chrisdone> luite: ah… so another not-quite-complete codegen :-)
13:08:44 <dcoutts> chrisdone: reduced the number of questions without a default 'y' answer
13:09:23 <dcoutts> chrisdone: and you don't need to do --no-comments anymore
13:09:27 * chrisdone cabal install cabal-installs
13:09:38 <dcoutts> cabal install cabal-install-0.14.0
13:09:44 <luite> chrisdone: admittedly i haven't tried to make ghcjs work with 7.0 and 7.2, only with 7.4 :)
13:10:01 <chrisdone> dcoutts: ah, hackage is smart-pointing to an older version?
13:10:22 <dcoutts> chrisdone: yes, 'til we're happy we're not going to break everything
13:10:24 * chrisdone . o O ( can't think of another word for that thing that hackage does for special packages )
13:10:35 <chrisdone> dcoutts: hehe :-)
13:11:06 <chrisdone> dcoutts: btw, are you still on ghc-6.12.3 on your own machine?
13:11:21 <dcoutts> chrisdone: I've got lots of versions
13:11:37 <chrisdone> dcoutts: true, me too, in /opt/ghc. but you have a default, i presume?
13:11:50 <dcoutts> my default is 7.0.4
13:11:55 <chrisdone> ah, ok
13:11:56 <dcoutts> oldest is 6.4.2 :-)
13:12:20 <bitonic> I only go back to 6.12.3
13:12:23 <luite> i still can't use 7.4 on os x :(
13:12:28 <luite> since it segfaults all the time
13:13:28 <jfischoff> luite: i have np with 7.4 on osx
13:13:33 <bitonic> luite: really? that's surprising
13:13:46 <chrisdone> dcoutts: i'm still on 6.12.3 (our old redhat servers are limiting me to this, and i'm negotiating an upgrade with the sysadmins…) but it's nice that cabal still works. i don't know how much pain you have to go through to back-support so far to 6.4.2
13:13:53 <luite> actually it's runhaskell with a large ghc project that segfaults
13:13:56 <luite> err
13:14:02 <luite> large haskell project (yesod)
13:14:05 <dcoutts> chrisdone: oh I think I only test back to 6.10
13:14:25 <luite> yesod devel builds your website as a library, then runghc's that to start the server
13:14:35 <luite> but it segfaults with ghc 7.4, runs fine with 7.0
13:15:05 <luite> i was hoping to find out what the problem is before 7.4.2/platform are released, but i have no idea how to debug this
13:17:22 <chrisdone> dcoutts: ah, neat (latest cabal init). i see it now (since my last version) lowercases the prop names too. seeing as i can put my hackage user/pass in my cabal/.config, would it be ok to put our authorname/maintainer email in there as well?
13:17:41 * chrisdone currently perusing for the .cabal/config docs
13:18:05 <dcoutts> chrisdone: mm, in principle that'd be reasonable
13:18:25 <dcoutts> chrisdone: to have an "init" section of the ~/.cabal/config
13:18:57 <dcoutts> chrisdone: hmm, though it'd not have the intended effect, it would not even ask you the question.
13:19:26 <chrisdone> dcoutts: preferably it would have a default. is that not possible in the current procedure?
13:19:51 <dcoutts> chrisdone: no, if you use cabal init --author=blah, then it doesn't ask you interactively
13:20:09 <chrisdone> ah
13:20:14 <dcoutts> and the config file would just reflect the command line
13:20:25 <chrisdone> though i suppose nine times out of ten, i don't want to enter anything, personally
13:20:26 <dcoutts> that's what the infrastructure supports generically
13:20:31 <chrisdone> sure
13:21:12 <dmwit_> I suppose you could add a --default-author command line switch.
13:21:42 <chrisdone> is it optimizing a use-case only I have? does anyone care about this?
13:23:19 <chrisdone> possibly ;)
13:24:48 <chrisdone> dcoutts: er, did you disable issue creation on the Cabal github project or has github been re-arranged while i wasn't looking?
13:25:16 <dcoutts> chrisdone: we currently still use trac for tickets, bos is working on trac->github migration
13:25:31 <chrisdone> ah, cool!
13:25:41 <dcoutts> it appears to be a bit difficult
13:25:47 <dcoutts> but bos reports progress
13:27:52 <t7> hackage is like the apple store
13:30:13 <rudyl313> When I write haskell I aim to have every function be pure (limiting the required side-effected actions to be done in the IO monad)... but when a bug occurs deep in a stack of pure functions I wish I could print out a value to try to figure out the problem... how do ppl generally get around this problem?
13:31:07 <copumpkin> Debug.Trace
13:32:13 <rudyl313> copumpkin: thats exactly what i was looking for...thanks!
13:32:15 <hpc> @quote oasis
13:32:16 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
13:32:17 <copumpkin> :)
13:32:50 <rudyl313> hpc: nice :)
13:35:09 <ybit> i'm confused about object literals
13:35:22 <ybit> "In computer science, a literal is a notation for representing a fixed value in source code."
13:35:30 <ybit> "In contrast to literals, variables or constants are symbols that can take on one of a class of fixed values"
13:35:34 <byorgey> ybit: for example,  'c' is a literal
13:35:35 <ybit> from https://en.wikipedia.org/wiki/Literal_%28computer_programming%29
13:35:36 <byorgey> so is  23
13:35:49 <sipa> or "hello world!\n"
13:35:54 <byorgey> but x is not a literal, it is a variable
13:36:03 <scooty-puff> can type constructors be composed?
13:36:36 <dmwit_> Some type constructors are functions. These type constructors can be composed (as can any function).
13:36:42 <byorgey> scooty-puff: yes, though not directly; see http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Data-Functor-Compose.html
13:36:45 <ybit> in the ecma/js example, newobj is the literal?
13:36:59 <dmwit_> bleh, I misunderstood
13:37:26 <donri> ybit: no, {}  is the literal
13:37:39 <ybit> donri: the contents of {} ?
13:37:40 <scooty-puff> k, thanks - too bad the wrapper is required..
13:37:48 <donri> ybit: the members of the object
13:37:48 <dmwit_> ybit: yes
13:37:49 <rasfar> strings are literals even though they are composite, constructed values?
13:38:02 <rasfar> so it's a question of compile-time vs. run-time?
13:38:05 <hpaste> “Ertugrul Söylemez” pasted “Locally nameless in action” at http://hpaste.org/68201
13:38:14 <donri> > 'H':'i':[]
13:38:15 <mm_freak_> i love it =)
13:38:15 <lambdabot>   "Hi"
13:38:29 <byorgey> rasfar: it doesn't make sense to say "strings are literals".  However, "xyz" is a string literal.
13:38:48 <dmwit_> rasfar: A literal is a fully-saturated (value) constructor, all of whose arguments are literals.
13:38:56 <rasfar> well, obviously, but i think i clarified my meaning in the second line...
13:38:58 <mm_freak_> working parser, type checker and interpreter…  now i'll add a compiler and then release everything =)
13:39:04 <ybit> donri: but the property value and method functions can be changed, so i'm confused about the definition "notation for representing a fixed value in source code"
13:39:04 <byorgey> rasfar: it's just a question of what the language syntax provides.
13:39:20 <dmwit_> rasfar: Since "abcd" is 'a':'b':'c':'d':[], and every (:) is fully saturated on the left by a character literal and on the right by a string literal, the whole thing is a literal, too.
13:39:31 <rasfar> thanks, i understand
13:39:32 <dmwit_> rasfar: Depending on definitions, you might consider a lambda to be a literal, too.
13:39:34 <byorgey> dmwit_: really?  That's not the definition of 'literal' I was thinking of.
13:39:42 <donri> ybit: it's "literal" in the source but may be mutated at runtime
13:39:44 <cg_morton`> it's interesting a function definition is technically a literal
13:39:48 <byorgey> I would have said  "abcd" is a literal but 'a':'b':'c':'d':[]  is not.
13:39:53 <dmwit_> um
13:40:07 <dmwit_> Well, I guess there's a few different definitions you could choose.
13:40:14 <ybit> hmm..
13:40:17 <rasfar> then it's about syntax? since "abcd" is (probably) internally represented as ... the longer one there
13:40:18 <dmwit_> I think a definition that distinguishes "abcd" and 'a':... is a bit suspect, though. =P
13:40:24 <byorgey> indeed.  I was thinking of the definition that corresponds to a case in your language's grammar.
13:40:27 <ybit> it can also be mutated in the  source...
13:40:30 <donri> yes, literals are all about syntax
13:40:32 <Combatjuan> I would say that 'a':'b':'c':'d':[] is 5 literals.
13:40:38 <byorgey> dmwit_: not if the definition is at the level of syntax.
13:40:42 <dmwit_> okay
13:40:45 <donri> ybit: but then you changed the source code? :)
13:40:48 * dmwit_ shrugs
13:41:03 <mm_freak_> lambdas as literals?
13:41:11 <cg_morton`> a literal statement in a piece of code is one that will always be the same value when it's compiled/interpreted
13:41:11 <ybit> a = 1; a = 2; <- that's not changing source is it?
13:41:13 <mm_freak_> feels incorrect
13:41:22 <ybit> it doesn't feel right, but that's valid js
13:41:36 <mm_freak_> ybit: you have two variables with the same name there
13:41:37 <sipa> ybit: 1 and 2 are literals in that piece of js code
13:41:51 <mm_freak_> oh, js
13:41:52 <cg_morton`> ybit:  1 will always be 1 in that code, but a will be a different thing at different times
13:41:54 <donri> ybit: basically, {foo:"bar"} is sugar in js for (function(){var $ = new Object(); $.foo = "bar; return $; })()
13:41:56 <mm_freak_> ok, forget it =)
13:42:02 <donri> (sort off.)
13:42:04 <rasfar> I suppose Template Haskell could complicate this even more...
13:42:28 <mun> hi
13:42:32 <mun> i have a rather simple logic question
13:42:34 <mun> \forall t \in T. \exists s \in S. (s/2) mod 2 = 0 <--> s/2 = t?
13:42:53 <mun> given i have a set S = {5,6,8,10} and a set T = {3,4,5}
13:43:21 <mun> sorry, it should read s mod 2 = 0 <--> s/2 = t
13:43:41 <byorgey> s mod 2 = 0 has nothing to do with t.
13:44:01 <mun> byorgey, well, 5 is in S, but 5/2 = 2.5 but 2.5 isn't in T
13:45:02 <byorgey> what's the scope of the quanitifiers?  is it (\forall ... \exists ...) <--> ...   or  (\forall ... \exists ... ( ... <--> ... ) )  ?
13:45:22 <cg_morton`> it's a strange use of <-->, because once you've chosen an s and t, s mod 2 =  0
13:45:23 <dmwit_> It has to be the latter, or you have free variables.
13:45:25 <mun> byorgey, sorry, it'd be the latter.
13:45:34 <cg_morton`> and s/2 = t are not propositions any more
13:45:45 <bgamari> conal: It would be nice if there was a class in vector-space which had an accessor to get an (integral) dimension
13:46:03 <byorgey> mun: so what's your question?
13:46:06 <bgamari> e.g. dimensionOf (1,2) = 2
13:46:27 <dmwit_> I would say the S and T you exhibited validify (is that the right term?) that proposition.
13:46:30 <ybit> i've been looking at languages which are trying to incorporate some ideas haskell has, coffeescript is one, and i came across someone saying "Anyway, use what you want. I'll stick with my object literals, dynamic typing, and prototypal OO, thanks."
13:46:45 <byorgey> validate =)
13:46:46 <ybit> from what i can gather, it seems every language has object literals
13:46:59 <mun> byorgey, my question is whether \forall t \in T. \exists s \in S. (s mod 2 = 0 <--> s / 2 = t) is true
13:47:01 <cg_morton`> ybit: no, that's a javascript feature
13:47:17 <ybit> cg_morton`: haskell has a ="1"
13:47:38 <mm_freak_> ybit, cg_morton`: object literals are a feature of ECMA
13:47:45 <mm_freak_> javascript, actionscript and haxe have them
13:47:54 <byorgey> mun: yes, it is true, given those sets S and T
13:48:05 <mm_freak_> also most languages with extensible records have something similar
13:48:08 <conal> bgamari: hm. maybe related to HasBasis
13:48:24 <byorgey> for each t you can either pick the s which is 2*t or you can pick 5.
13:48:27 <mun> but is the right to left case true though? for some s \in S, s/2 = t, for all t \in T?
13:48:34 <mun> that's what the right to left case says, right?
13:48:36 <byorgey> since  X <--> Y  is true when both X and Y are false.
13:48:59 <ybit> it sounds like object literals are just a reference to a specific location in memory for that piece of code, very vague sounding
13:49:07 <dmwit_> mun: I don't think that's what the right-to-left case says, no.
13:49:10 <conal> bgamari: i've been wanting to redesign the decompose method anyway
13:49:17 <bgamari> conal: Yes, but calling length on the returned basis for something that we often know at compile time is kind of yucky
13:49:19 <byorgey> mun: you can't consider it independently of the --> direction.
13:49:33 <mm_freak_> ybit: not at all…  those anonymous "objects" are really just records…  they are like extensible haskell records
13:49:46 <conal> bgamari: exactly. that's part of what i want to redesign -- separate static from dynamic
13:50:07 <ybit> what's the difference between string literals and object literals?
13:50:16 <mm_freak_> ybit: string literal: "abc"
13:50:21 <bgamari> conal: Yep, sounds like we agree
13:50:24 <cg_morton`> ybit: in ...ECMA an object is essentially a dictionary with string indices, and the object literal is a convenient syntax for creating them
13:50:26 <mm_freak_> object literal:  { x: "abc", y: 3 }
13:51:14 <mm_freak_> ybit: haxe has extensible records and is statically, strongly typed, so you may want to have a look into it to understand them best
13:52:13 <lamefun2> :t mapM_
13:52:14 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
13:52:22 <lamefun2> what is mapM_?
13:52:23 <cg_morton`> ybit: you could instead construct an object like: a = {}; a.x = "abc"; a.y = 3;    but the literal syntax is easier and cleaner
13:52:49 <mm_freak_> note that the type of 'a' changes along the way
13:55:52 <cg_morton`> ybit: similarly, the list-style construction of a string might be something like:  s = ['a','b','c'];    but the string literal form  s = "abc"   is much simpler, though it means the same thing
13:55:58 <ybit> cg_morton`: so a = {}; a.x = "abc"; a.y = 3; wouldn't be considered an object literal?
13:56:24 <cg_morton`> ybit: Nope.  Not the way that term is used in ECMA
13:56:26 * ybit needs to read into what haskell records are 
13:56:55 <ybit> and i guess the ECMA spec wouldn't hurt
14:00:05 <mm_freak_> ybit: the ECMA spec does hurt ;)
14:00:13 <bgamari> Any Repa folks around?
14:00:43 <cg_morton`> I think 'literal' most generally means that if you see it written in two places in the code it is guaranteed to mean the same thing both times
14:01:43 <bgamari> It would be nice if Data.Array.Repa.Algorithms.Matrix had a determinant implementation
14:05:13 <lispy> hello
14:06:21 <sipa> cg_morton: you mean any (pure) expression?
14:07:10 <mm_freak_> cg_morton: by that definition almost everything is literal in haskell
14:07:55 <mm_freak_> "literal" usually means that you construct a value of a specific primitive/base type directly in source code
14:08:00 <Polarina> Is there a function that repeats a monadic action until a certain condition is met?
14:08:14 <mm_freak_> Polarina: not predefined
14:09:03 <Polarina> I'll make my own then, thanks.
14:09:10 <mm_freak_> Polarina: why?
14:09:26 <mm_freak_> if you need a "while" combinator you almost certainly are doing something wrong
14:09:58 <Polarina> mm_freak_, I am deserializing data with Data.Binary and need to stop collecting results until a certain byte is seen.
14:10:26 <Polarina> s/until/when/+
14:11:30 <mm_freak_> Polarina: i recommend explicit recursion there
14:12:49 <Polarina> mm_freak_, I was going for that. Was just wondering if there was a function of some sort that would help me there.
14:13:23 <mm_freak_> Polarina: the "while" loop you know from imperative programming is too general to be captured in a useful way as a combinator
14:14:18 * Polarina needs to stop use those mind-corrupting languages.
14:14:45 <mm_freak_> Polarina: not only the languages, but also the constructs…  there is something very wrong with loops
14:15:07 <mm_freak_> loops, especially with destructive update, are a common source for bugs
14:15:12 <tac-tics> Loops are cool man
14:15:29 <tac-tics> You just have to have a system to reason about them
14:16:15 <vraid> bad code is a common source of bugs
14:16:39 <tac-tics> (good code, too, but that's besides the point)
14:26:56 <mun> dmwit, sorry someone was at the door. so what does the right-to-left case say?
14:27:08 <mun> byorgey, hmm but it's an iff so both directions need to be considered, right
14:38:45 <koala_bot> I am looking at some code that uses n+k pattern matching, and read that {-# LANGUAGE NPlusKPatterns #-} can be used to enable it so that I do not get compilation errors. However, having added that line to the file, I am still seeing problems when I try to load. Can someone walk me through this?
14:39:18 <geekosaur> koala_bot, pastebin it
14:39:21 <geekosaur> @hpaste
14:39:22 <lambdabot> Haskell pastebin: http://hpaste.org/
14:40:06 <hpaste> “koala_bot's prof” pasted “LK.hs” at http://hpaste.org/68202
14:40:19 <koala_bot> ^
14:40:41 <koala_bot> Line 49*
14:41:22 <Eduard_Munteanu> koala_bot: what's the error?
14:41:31 <geekosaur> pragmas have to go at the *very* top
14:41:31 <koala_bot> LK.hs:49:13: Parse error in pattern: n + 1
14:41:48 <geekosaur> line 1, not after the "module" declaration
14:42:02 <koala_bot> geekosaur: that is how it was when i first tried, and i got the same error.
14:42:05 <koala_bot> tried again just now to the same effect.
14:42:22 <geekosaur> also, which ghc version is this?
14:42:39 <koala_bot> how do I check that?
14:42:46 <hpc> ghc --version
14:42:51 <geekosaur> ghc --version
14:43:04 <geekosaur> (I assume this is ghc, if it's not then all bets are off)
14:43:08 <koala_bot> 7.0.4
14:43:39 <hpc> might be parens
14:43:45 <hpc> oh, there's a paste
14:43:47 <lamefun2> how to do matrices in haskell? (up to 4x4)?
14:44:10 <bgamari> lamefun2: There are many ways
14:44:18 <koala_bot> hpc: this code at one point was functional - it was made by my professor for a class a while back and I am revisiting it during an indepednent study but it just does not seem to work with the updated GHC
14:44:24 <lamefun2> type Vector3 = (Double, Double, Double) deriving (Eq)
14:44:29 <lamefun2> type Matrix3x3 = (Vector3, Vector3, Vector3) deriving (Eq)
14:44:33 <lamefun2> or just 9 doubles
14:44:36 <lamefun2> is this a good way?
14:44:40 <bgamari> lamefun2: If you just want something to work, use hmatrix
14:44:41 <tac-tics> lamefun2: Same way you might in other languages. Nested lists, nested arrays, or a fixed array of 16 values, or however you want to represent it
14:44:45 <bgamari> lamefun2: That's one way
14:44:59 <bgamari> lamefun2: you may want to look at the vector-space package
14:45:01 <tac-tics> lamefun2: There are always tradeoffs to the way you do it
14:45:15 <bgamari> lamefun2: if that is the rough approach you want to take
14:45:20 <scooty-puff> is there any overlap between constraint kinds and rank-n types (i don't mean in functionality or expressiveness, but if constraint kinds can be used to represent rank-n types)
14:46:37 <hpc> scooty-puff: don't think so
14:46:47 <scooty-puff> so like class Test a where type B a; test :: (forall (B a) . ....) -> ...
14:46:48 <scooty-puff> k
14:47:03 <scooty-puff> seems like would need a special implicitly converted type variable kind
14:47:05 <lamefun2> I just want to store linear transformations
14:47:11 <hpc> but don't take me as the authority on the matter
14:48:15 <koala_bot> Anybody have any other thoughts on my n+k issue?
14:48:55 <monochrom> no
14:50:00 <sclv> there is no issue!
14:50:25 <bgamari> lamefun2: Nothing wrong with storing the matrix as you did above
14:50:54 <bgamari> lamefun2: If you needed dynamically-sized/large matricies I would probably recommend Repa
14:50:55 <koala_bot> sclv: was that directed at me?
14:52:32 <Enigmagic> koala_bot: try moving the NPlusKPatterns pragma to the top of the file
14:52:42 <koala_bot> I have. No improvement :(
14:53:13 <Enigmagic> okay, well remove the offending code instead. it's a small change.
14:53:53 <koala_bot> It's not really my code to edit unfortunately. Thanks for everyone's input - I'll just have to bring up the problem with my prof.
14:58:23 <t7> i thought n+k was removed in '2010 ?
14:58:54 <geekosaur> t7, still there with the right pragma, which is being used
15:07:03 <[mth]_> I have a cabal build on OSX, basic Setup.hs using Distribution.Simple, but it intermittently fails (with exit code 11), no other output. It fails on clean configure and build at different times. Anyone else seen this, or know what might be causing it.
15:07:46 <[mth]_> Note that it builds consistenly on Linux. And this is using 7.4.1
15:09:16 <t7> whats error 11?
15:09:53 <rwbarton> well signal 11 is SIGSEGV
15:10:15 <rwbarton> possibly the linker is running out of memory? that's a fairly common condition
15:11:08 <haziz> Is "Write Yourself a Scheme in 48 Hours" OK as a first Haskell book? I would consider myself intermediate in C but have no experience with either Scheme or Haskell or other functional languages?
15:11:22 <[mth]_> Ok, fair enough. That should be enough to track it down.
15:12:09 <t7> haziz
15:12:12 <t7> @lyah
15:12:13 <lambdabot> Unknown command, try @list
15:12:22 <t7> meh try lern you a haskell
15:16:09 <haziz> I have started LYAH. I just thought that the idea of building a Scheme interpreter using Haskell sounded interesting. Will tackle it as my second book. I also have but have not read Real World Haskell.
15:16:55 <Peaker> I'm really missing (anonymous) structural records and anonymous sums in Haskell
15:17:16 <Peaker> by anonymous sums I really mean polymorphic variants
15:18:07 <mm_freak_> haziz: i've often seen the scheme book being criticized not to be beginner-friendly
15:18:58 <mm_freak_> LYAH on the other hand is very beginner-friendly
15:23:22 <kallisti> so a QSem is essentially a kind of counter variable?
15:23:42 <kallisti> where you set a maximum value
15:23:58 <kallisti> and then threads can wait for a slot to become available, or free a slot.
15:25:03 <c_wraith> yeah.
15:25:21 <kallisti> is there a QSem where the maximum quantity can be changed arbitrarily?
15:26:08 <kallisti> I see some difficulties implementing that
15:26:18 <kallisti> but I'm wondering if someone else has already thought it through.
15:30:00 <c_wraith> well, the standard use is that the hard bound is at zero, not at the top
15:30:15 <c_wraith> If you create a QSem with capacity 50, then add 1 to it, the capacity is now 51
15:30:34 <c_wraith> It doesn't care if you add more to it than it started with
15:30:42 <c_wraith> It only cares if you get below 0
15:31:05 <Peaker> I don't really get the usefulness of semaphores (except the uninteresting use case as a mutex)
15:31:38 <c_wraith> Peaker: I think it's that you can be notified on them, as opposed to mutexes, which you just fail to acquire
15:31:41 <Peaker> I don't think I've ever seen semaphores used except as mutexes (count ignored)
15:31:56 <c_wraith> if I remember the classical description of those structures correctly
15:32:04 <Peaker> mutexes generally have a potentially-waiting "lock" primitive (and sometimes a "tryLock")
15:32:27 <c_wraith> hmm.
15:32:56 <c_wraith> Then I don't know.  I never felt like the traditional primitives were well-designed anyway :)
15:42:18 <kallisti> right now I have a manager thread that sends actions to a queue that many worker threads pick up and perform; pretty standard concurrency idiom I think.
15:42:42 <kallisti> and I have a variable in my database to adjust the number of workers alive at any given time.
15:43:12 <kallisti> if the variable changes then the manager will send a number of kill actions on the queue to balance out the number of workers with the variable change.
15:43:28 <kallisti> but maybe there's a simpler approach?
15:43:48 <kallisti> (the manager will also spawn new threads in the event that the variable increases, of course)
16:04:38 <vhd> how can I use bang patterns with ghci? (I am using winghci)
16:05:16 <hpc> vhd: ghci -XBangPatterns
16:05:24 <hpc> or :set something or other
16:06:03 <vhd> thank you
16:06:30 <byorgey> :set -XBangPatterns, in fact
16:07:08 <hpc> heh
16:15:08 <yan_> is there a way to make the IO monad 'stop' executing? (i.e. like Nothing in Maybe)
16:15:18 <mauke> throw an exception
16:15:20 <yan_> (without using a MaybeT that is)
16:15:44 <hpc> throw an exception or call exitWith
16:15:50 <hpc> (an uncaught exception)
16:16:01 <hpc> once you halt an IO action, you're out of your program
16:18:48 * hackagebot virthualenv 0.2.1 - Virtual Haskell Environment builder  http://hackage.haskell.org/package/virthualenv-0.2.1 (BartoszCwiklowski)
16:21:12 <byorgey> yan_: I'm not sure why you're so keen to avoid using MaybeT.  IO actions which "fail"/stop early is precisely what  MaybeT IO  is intended to model.
16:27:14 <lamefun2> how complete are existing Haskell -> JavaScript compilers?
16:31:32 <lamefun2> I want to be ready for Web 3.0
16:32:18 <geekosaur> still trolling, are we?
16:32:39 <t7> lamefun2: they are rubbish
16:32:44 <t7> not even ready for the windows 7
16:34:38 <mefisto> are there haskell -> javascript compilers? :O
16:35:08 <lamefun2> so, no downcasting ever in haskell?
16:35:16 <aristid> mefisto: yes, at the proof of concept level.
16:36:05 <lamefun2> nevermind
16:36:24 <t7> what do you mean by downcasting
16:36:30 <t7> haskell doesnt have subtypes
16:36:41 <byorgey> there is no casting in Haskell, period.  up or down.
16:37:45 <blackdog> > :t unsafeCoerce
16:37:45 <lambdabot>   <no location info>: parse error on input `:'
16:38:03 <blackdog> hm. suppose i deserve that for trolling anyway.
16:38:13 <t7> > unsafeCoerce "Helolol" :: Int
16:38:14 <lambdabot>   Not in scope: `unsafeCoerce'
16:38:18 <mefisto> aristid: interesting... maybe obviate the need for crappy node.js someday :D
16:38:47 <mauke> mefisto: if you're on the server, why bother going through javascript at all?
16:39:00 <t7> i think he means code sharing
16:39:25 <mefisto> what t7 said
16:41:36 <t7> agda can compile to js :)
16:42:14 <djahandarie> You can run Agda?!
16:42:44 <t7> no just translate it to js
16:42:50 <bitonic> and then you can run it lol
16:43:14 <ozataman_> anyone know a good lib to do number formatting with thousands separator, etc?
16:43:17 <djahandarie> But all that happens when you run it is it translates itself back into Agda.
16:43:48 <t7> just spits out more type errors
16:44:51 <hpaste> mk12 pasted “Map fromList build list” at http://hpaste.org/68206
16:44:58 <mefisto> such a useful, productive language... shocking I've never heard of it before
16:45:51 <t7> haskell should have a pragma or something to test an expression is total
16:46:01 <mk12> How can I create a Map from a list, where the key values are lists combining the values of duplicate keys? http://hpaste.org/68206
16:46:04 <mauke> heh
16:46:11 <mauke> willTerminate :: a -> Bool
16:46:35 <mk12> I know it's because I'm never consign with [] but I'm not sure how I'd do what I want…
16:46:39 <mk12> *consing
16:47:06 <vhd> anyone who used gtk2hs, how do you refresh the screen? I have a long computation and it would be handy to redraw the screen prior to it.
16:48:27 <mk12> actually seeing the type signature of fromListWith makes me think this is impossible..
16:48:55 <mauke> :t M.fromListWith
16:48:56 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [(k, a)] -> M.Map k a
16:49:41 <mauke> > (M.fromListWith (++) . map (fmap return)) [("a", 1), ("a", 5), ("b", 6), ("c", 7)]
16:49:42 <lambdabot>   No instance for (Data.Monoid.Monoid (m a))
16:49:43 <lambdabot>    arising from a use of `e_1156...
16:50:15 <mauke> > (M.fromListWith (P.++) . map (fmap return)) [("a", 1), ("a", 5), ("b", 6), ("c", 7)]
16:50:17 <lambdabot>   fromList [("a",[5,1]),("b",[6]),("c",[7])]
16:51:00 <mk12> mauke: ah, thank you. what is the significance of "P" in P.++ ?
16:51:09 <mauke> :t (++)
16:51:10 <lambdabot> forall m. (Monoid m) => m -> m -> m
16:51:17 <mauke> P.++ is the prelude version
16:51:23 <mauke> (this is lambdabot specific)
16:51:37 <yan_> i'm trying to use Network.Curl.Download.Lazy, and a method returns a lazy ByteString. I'm trying to treat it as Data.ByteString.ByteString, but GHC is complaining that it's actually Data.ByteString.Lazy.Internal.. do i just change the type i'm expecting or is there something about lib usage that i'm missing?
16:51:39 <mk12> ohh ok, ya I'm using data.map qualified
16:51:45 <mk12> but thanks!
16:52:09 <ben> vhd: Maybe with mainIteration from http://hackage.haskell.org/packages/archive/gtk/0.12.3/doc/html/Graphics-UI-Gtk-General-General.html#g:3 ?
16:52:34 <mauke> yan_: there are two bytestring types, lazy and strict
16:52:44 <mauke> yan_: you're trying to treat it as strict but it's lazy
16:53:12 <yan_> mauke: sure, but what i'm asking is how are Data.ByteString.Lazy and Data.ByteString.Lazy.Internal different?
16:53:16 <yan_> (the curl lib uses .Internal)
16:53:20 <int80_h> does the following action exist already in a library somewhere?
16:53:24 <int80_h> ifM p t f  = p >>= (\p' -> if p' then t else f)
16:53:32 <int80_h> monadic if
16:53:55 <t7> @pl \p t f = p >>= (\p' -> if p' then t else f)
16:53:56 <hpc> you can also define it as
16:53:56 <lambdabot> (line 1, column 8):
16:53:56 <lambdabot> unexpected "="
16:53:56 <lambdabot> expecting pattern or "->"
16:54:05 <hpc> (t ?? f) p = if p then t else f
16:54:07 <t7> @pl \p t f -> p >>= (\p' -> if p' then t else f)
16:54:08 <lambdabot> (. (flip . flip if')) . (.) . (>>=)
16:54:14 <hpc> ifM p t f = p >>= (t ?? f)
16:54:30 <mauke> yan_: they aren't, and I doubt that curl uses .Internal
16:54:48 <mk12> mauke: with your code I'm getting "No instance for (Functor ((,) [Char])) arising from use of 'fmap'", is there something I need to import?
16:54:53 <int80_h> hpc: I'm wondering if this has been defined already in some library?
16:54:55 <mauke> yan_: it's just that the type is originally defined in Data.ByteString.Lazy.Internal and reexported from Data.ByteString.Lazy
16:55:08 <Peaker> I like the one which gives     false <? predicate ?> true     so that compositions of multiple predicates look sort of like a tree, visually
16:55:16 <mauke> huh, where's the functor instance for tuples?
16:55:35 <hpc> mauke: try importing things into ghci and :info Functor
16:55:48 <hpc> (or :info (,))
16:55:52 <Peaker> Control.Monad.Instances has one
16:56:21 <mauke> mk12: ^
16:56:44 <vhd> ben surely you mean mainLevel?
16:56:48 <mk12> thanks :)
16:57:18 <vhd> no wait im reading it wrong
17:33:25 <augur> is there a nice relationship between CPS transformations and already-continuized functions?
17:38:21 <luite> hmm, for dependencyClosure (Cabal library), Left is a succesful result, Right is error... interesting
17:42:32 <Clint> anyone know what "gtk2hsC2hs: UName: root name supply used after saving
17:42:34 <Clint> " means?
17:42:44 <Eduard_Munteanu> gienah: any idea why the Gentoo agda package doesn't get me the 'agda-mode' utility?
17:43:21 <Eduard_Munteanu> Actually, I'm not sure who to ask, but I remember you being involved with the ebuilds in some way.
17:43:31 <Eduard_Munteanu> (the Haskell-related ebuilds, that is)
17:44:02 <Eduard_Munteanu> sci-mathematics/agda-2.3.0.1 that is
17:47:56 <QinGW> hi morning
17:48:16 <Eduard_Munteanu> QinGW: hi
17:50:12 <hamishmack> luite: Have you tried this… https://github.com/hamishmack/ghcjs ?
17:50:14 <QinGW> does haskell has a restful http server application?
17:50:49 <blackdog> QinGW: it's got quite a few. snap, yesod... i've been using scotty for little restful apps
17:51:17 <tgeeky> hamishmack: he is well aware of ghcjs, he's going a different route for specific reasons
17:51:21 <luite> hamishmack: uh yes, i've been hacking on its source code for the past 3 days
17:51:39 <tgeeky> luite: damn it. you're going th ghcjs, cd is going his own way
17:51:46 <luite> right :p
17:51:47 <tgeeky> s/$/?/
17:51:56 <tgeeky> luite: I thought you had rejected ghcjs too :O
17:52:10 <luite> tgeeky: na there's the haste compiler
17:52:15 <luite> but it's not really that much different
17:52:21 <luite> the project is more active
17:52:30 <luite> and it has some client-side libs
17:52:38 <luite> but i can't really use them for wolfgang
17:52:56 <luite> so i'll stick with ghcjs+hacks for now, since i can build diagrams with it now :)
17:52:59 <tgeeky> luite: so the process is to compile lots of haskell to javascript, so that you can load diagrams, so that you can make diagrams in svg, but this process will take minutes?
17:54:10 <hamishmack> luite: I just added integer-gmp support over the weekend
17:54:29 <luite> hamishmack: oh cool
17:54:31 <hamishmack> luite: Using goog.math.Intege
17:55:01 <luite> i was planning to do that later, it would probably be a requirement for getting diagrams to run with acceptable speed
17:55:09 <luite> but this is great news :)
17:55:30 <QinGW2> blackdog, they will support restful primitive?
17:55:45 <tgeeky> luite: just stumbled on this: http://babbage.cs.qc.cuny.edu/IEEE-754/
17:56:05 <hamishmack> luite: I am going to put a hello world up as some people seam to think it is big
17:56:10 <luite> hamishmack: I've reworked the module loading things to make it use require.js instead of XHR
17:56:23 <luite> hamishmack: i've compiled diagrams with it, 65MB javascript code
17:56:32 <Eduard_Munteanu> BTW, are there any Yesod templates I could snatch?
17:56:45 <hamishmack> luite: I have done something similar, but I have also added function level linker
17:57:06 <luite> ugh
17:57:07 <hamishmack> that strips out unused code before closure even sees it
17:57:16 <luite> so why didn't you tell me a few days ago :p
17:57:30 <hamishmack> I posted to reddit months ago
17:57:37 <luite> really?
17:57:47 <luite> why did i miss this...
17:57:51 <luite> url?
17:57:54 <tgeeky> hamishmack: are you ghcjs owner?
17:58:25 <hamishmack> tgeeky: No but I seem to be the most active dev right now
17:58:53 <luite> hamishmack: what do you think of haste?
17:59:36 <hamishmack> luite: Looks good.  I thought it had different aims though
17:59:41 <hamishmack> Not sure
18:00:02 <augur> copumpkin!
18:00:05 <augur> Saizan!
18:00:09 <augur> other smart people!
18:00:10 <tgeeky> augur!
18:00:20 * tgeeky looks over his sholder, for smart people
18:00:34 <Polarina> o.O
18:00:59 <Polarina> Aren't we all smart?
18:01:07 <Eduard_Munteanu> preflex: seen ddarius
18:01:07 <preflex>  ddarius was last seen on #haskell 59 days, 22 hours, 53 minutes and 33 seconds ago, saying: BMeph: No.
18:01:30 <hamishmack> luite: http://www.haskell.org/pipermail/haskell-cafe/2011-May/091897.html
18:01:43 <Eduard_Munteanu> Hm, I had a feeling I haven't seen him in here lately.
18:01:55 <hamishmack> luite: Wow it has been a year
18:02:05 <tgeeky> hamishmack: if only that had line breaks :o
18:02:22 <hamishmack> doh
18:02:23 <luite> hamishmack: oh i have seem that message somewhere... and that is probably why i ignored your branch
18:02:56 <tgeeky> luite: back then you were using snap, not yesod :o
18:03:06 <luite> yes, that too, but
18:03:16 <luite> the message mentions a patched ghc
18:03:21 <luite> instead of something that uses the ghc api
18:03:38 <hamishmack> I am just trying out a new way of building the fat compiler
18:04:04 <luite> i can now do cabal install diagrams
18:04:04 <hamishmack> Instead of merging the code I am making just 3 smallish changes to GHC
18:04:25 <luite> and then run a script that generates js code for diagrams and all its dependencies
18:04:39 <hamishmack> luite: Cool
18:04:48 <hamishmack> how did you get cabal to work?
18:05:00 <hamishmack> where does it store .js files?
18:05:01 <luite> --with-compiler=ghcjs
18:05:22 <luite> and made ghcjs fall back to ghc for things like --numeric-version
18:05:25 <tgeeky> luite: it seems pretty clear that we've entered a time where the type of compilation isn't Haskell -> ... -> C or Asm backend, but Haskell -> ... -> [llvm, c, javascript1, javascript2, etc]
18:05:30 <bitonic> is there a package with function from Pipes to Iteratees? With Pipe I mean conduit's Pipe
18:05:58 <tgeeky> luite: that's good progress, though.
18:06:08 <luite> well javascript isn't an ideal backend
18:06:37 <hamishmack> luite: Have you pushed it to github yet?
18:06:40 <luite> hamishmack: is it possible to use ghc with integer-gmp to build ghcjs that uses integer-simple?
18:06:43 <luite> no
18:07:08 <augur> copumpkin: cps transform <=> cont monad?
18:07:28 <tgeeky> hamishmack: luite (correctly, in my opinion) is being careful to polish his product before releasing
18:07:32 <rexamophone> @lp map f a = foldRight (\acc x -> f x :| acc) Nil a
18:07:33 <lambdabot> Maybe you meant: . ? @ bf do ft help id let map pl rc slap v wn
18:07:46 <luite> tgeeky: hehe, nah i'm just slow with releasing
18:08:02 <luite> for these hacky kind of things, it's more important to share stuff
18:08:03 <tgeeky> luite: bah, lies. I've seen your todo lists... and you .. to .. doing them
18:08:26 <hamishmack> tgeeky: Pushing to a github branch != releasing.  It is just sharing what you are working on
18:08:27 <luite> but i think i should probably rebase my stuf on hamishmacks branch
18:08:45 <hamishmack> tgeeky: cabal upload would be releasing
18:09:15 <hamishmack> luite: Let me know if you need a hand with any of it
18:09:30 <luite> hamishmack: i spent half the weekend debugging an integer literal problem with ghcjs, for 7.4 :(
18:10:04 <luite> hamishmack: what are you using ghcjs for?
18:11:04 <hamishmack> luite: I want to port leksah to it in the long term
18:11:40 <tgeeky> hamishmack: I mean the context in which he's operating is a pretty large ongoing project. Even those of us who have been following...
18:11:53 <tgeeky> jeez. that's almost equally ambitious and long-term
18:12:50 <luite> hamishmack: whoah nice
18:12:56 <hamishmack> luite: I would like to try to run the GHC testsuite to check the integer stuff is right
18:13:18 <Eduard_Munteanu> augur: pretty much I guess
18:13:37 <augur> Eduard_Munteanu: ?
18:14:00 <Eduard_Munteanu> augur: on the CPS transformation being equivalent to Cont
18:14:24 <augur> Eduard_Munteanu: it was a question, not a statement :P
18:14:34 <Eduard_Munteanu> Yeah.
18:15:26 <hamishmack> luite: If you do a cabal install --enable-tests and cabal test on that ghcjs branch it will build and link some example code
18:16:10 <augur> how do i import some packages in ghci?
18:16:12 <hamishmack> luite: but you might need to fix up the paths to closure
18:16:18 <augur> actually nevermind
18:16:38 <luite> hamishmack: oh i don't have closure installed
18:17:18 <hamishmack> luite: https://developers.google.com/closure/library/
18:17:52 <hamishmack> luite: It uses the compiler too
18:18:12 <luite> hamishmack: i get a panic
18:18:12 <tgeeky> nstead of compiling from a source language to machine code, it compiles from JavaScript to better JavaScript.
18:18:25 <luite> hamishmack: GHC.Debug is a package module
18:19:08 <hamishmack> luite: What version of GHC are you using?
18:19:19 <Eduard_Munteanu> augur: you kinda get the transformation by mapping f to return . f
18:19:20 <luite> 7.4,1
18:22:25 <luite> hamishmack: do i still need to build base/prim/integer manually?
18:23:59 <hamishmack> luite: F (for the stand alone ghcjs the instructions are basically the same as the old ghcjs branch
18:25:40 <hamishmack> luite: (oops failed to capitalise F in for without looking like I was swearing)
18:26:18 <hamishmack> Do you have a copy of the ghc 7.4.1 source in ../ghc ?
18:28:47 <luite> uh no
18:29:43 <hamishmack> luite: It BuildTests.hs looks in there IIRC for the ghc-prim and base
18:31:20 <hamishmack> luite: whats more it needs some of the header files to build them so you need to run a bit of the GHC build process to get it up and running
18:31:35 <luite> right, i have that
18:31:40 <luite> 	attempting to use module `base:Control.Monad' (../ghc/libraries/base/Control/Monad.hs) which is not loaded
18:32:58 <kallisti> concurrent actions are interesting.
18:33:10 <kallisti> the type IO a -> IO a crops up a lot
18:33:36 <mauke> :t evaluate
18:33:37 <lambdabot> Not in scope: `evaluate'
18:33:39 <kallisti> that are not like id at all.
18:34:06 <parcs`> not just concurrent actions
18:34:11 <luite> hamishmack: any ideas?
18:34:14 * kallisti isn't sure what he's even talking about right now. :P
18:34:43 <hamishmack> luite: Might be the missing header file thing.  Try running the steps in https://github.com/hamishmack/ghcjs readme under "Building Prelude" on the GHC source
18:34:52 <luite> hamishmack: i see some generated code now, it's basically the same, but with everything moved from $hs.modules to top level, and shortened names/identifiers, is thet correct?
18:35:30 <hamishmack> luite: Yes also it use CPS for every call (not just tail calls)
18:35:59 <hamishmack> that way I have been able to add light weight Threads
18:36:14 <luite> ah, cool
18:36:17 <hamishmack> because the JavaScript stack is not needed
18:36:47 <hamishmack> it has MVars but no TVars yet
18:37:03 <hamishmack> Also no async exceptions
18:37:20 <hamishmack> I have done weak pointers and finalisers though
18:37:55 <luite> ah that's much better than i expected :)
18:38:42 <hamishmack> luite: Once I update the instructions and push the new GHC branch it would be cool if you could try that out too
18:39:01 <luite> why can you push it? :)
18:39:04 <luite> err
18:39:06 <luite> when
18:40:20 <hamishmack> luite: I can push the branch now if you like.  It builds, but I have not tried compiling anything with it yet.
18:40:41 <parcs`> kallisti: for example i have a function 'withDeltaTime :: (IO NominalDiffTime -> IO a) -> IO a' -- the 'IO NominalDiffTime' is an action that computes the delta between the last time the action was executed and the current time. internally it uses IORefs to store the previous time, but the user doesn't have to know or care about that, which is pretty mindblowing i think
18:40:54 <luite> hamishmack: the instructions say that i should configure ghc for integer-simple, is that still correct?
18:41:05 <hamishmack> luite: No
18:41:19 <hamishmack> luite: You can use integer-gmp now
18:41:37 <hamishmack> luite: It will probably be faster
18:42:20 <hamishmack> but be warned that integer ops will block all running threads
18:43:00 <luite> should be ok
18:43:20 <luite> i was planning to run computations in an iframe anyway :)
18:43:53 <luite> rebuilding ghc now in that subdir
18:45:27 <hamishmack> luite: What OS are you on?
18:46:27 <luite> hamishmack: ubuntu
18:46:54 <luite> hamishmack: quickest should be enough, right?
18:46:55 <hamishmack> luite: I have been using OS X so some of the RTS calls I have implemented might be OS X specific
18:47:14 <hamishmack> luite: Yes
18:47:28 <luite> oh...
18:47:41 <luite> well i do have OS X, but i keep running into GHC problems on that
18:47:48 <luite> so i run linux in a vm
18:48:04 <hamishmack> luite: No i just mean stuff like IO calls
18:49:20 <luite> ok ghc rebuilt
18:50:02 <luite> hamishmack: same problem again
18:51:06 <luite> http://hpaste.org/68208
18:51:07 <tgeeky> luite: ghc.debug? that might be something new?
18:51:36 <hamishmack> luite: Can you put the log in hpaste?
18:52:05 <hamishmack> luite: oops :-)
18:56:05 <hamishmack> luite: Just checked my copy of GHC
18:56:46 <hamishmack> I have modified that file to include "import Prelude" even if __HUGS__ is not defined
18:57:11 <hamishmack> luite: (ghc/libraries/base/System/Mem/Weak.hs)
18:58:42 <hamishmack> luite: you don't need to rebuild GHC
18:58:53 <luite> whoah..
18:59:04 <hamishmack> just changing the #ifdef in ghc/libraries/base/System/Mem/Weak.hs should do it
19:01:55 <hamishmack> luite: That is a pain because that file is in packages-base.git not ghc.git
19:02:42 <kallisti> Could not deduce (Functor m) arising from a use of `getConn' from the context (MonadIO m)
19:02:45 <kallisti> huh. really?
19:02:51 <kallisti> I thought it went:  MonadIO -> Monad -> Functor
19:03:52 <kallisti> oh well I'll just liftM instead of fmap.
19:04:28 <hamishmack> luite: Any luck?
19:04:29 <monochrom> "Monad -> Functor" did not happen
19:04:53 <luite> hamishmack: getting a little further
19:05:18 <luite> ERROR - Cannot read: examples/rts-options.js
19:05:34 <hamishmack> luite: Oh that is new file
19:05:38 <hamishmack> I'll push it now
19:05:39 <kallisti> monochrom: oh that's right the standard library is silly isn't it.
19:07:03 <hamishmack> luite: PUshed
19:08:26 <luite> Couldn't get a file descriptor referring to the console
19:09:29 <luite> do i need some console javascript thing?
19:09:50 <kallisti> StandaloneDeriving should magically derive all instances always.
19:09:59 <kallisti> MonadBaseControl would be nice, at least.
19:10:19 <kallisti> (aka do newtype deriving even with type families involved)
19:11:17 <hamishmack> luite: Where are you  getting that error?
19:12:06 <hamishmack> luite: Did it make hs1.js, hs2.js etc?
19:12:14 <luite> yeah
19:12:28 <luite> i think it's the system open thingie
19:12:43 <hamishmack> did you open test_raw.html ?
19:13:02 <luite> yeah in the browser now
19:13:06 <luite> had to start a webserver
19:13:12 <luite> since i don't have a local browser
19:13:16 <luite> it's a text-only vm
19:13:26 <luite> fortunately it's easy to do with warp-static :)
19:14:28 <luite> hamishmack: i do get a maximum call stack size exceeded error
19:14:54 <hamishmack> hamishmack: That might be the GC for weak pointers
19:15:23 <hamishmack> luite: It uses recursion to visit all the objects
19:15:49 <hamishmack> luite: I need to change it to iterate instead
19:16:55 <hamishmack> luite: If you leave out the weak pointer test (I think it is test12) it should go away
19:17:37 <luite> it does seem to work in firefox
19:18:18 <hamishmack> luite: Or change 10000 to 2000 in test12
19:23:01 <luite> hamishmack: oh you're still loading modules with xmlhttprequest?
19:23:34 <hamishmack> luite: Yes because you might not want to load all the code at once
19:24:18 <hamishmack> so what you do is you "export" some functions that you want as entry points
19:24:36 <hamishmack> (in this case each test)
19:25:16 <hamishmack> the linker then tries to organise the functions need for each one into separate files
19:25:29 <blackdog> are there any test frameworks in haskell that can do test discovery? ie, i have a bunch of files, they contain tests, and i have some command i can run that will execute all the tests?
19:25:33 <hamishmack> without duplicating them
19:26:03 <hamishmack> It outputs code to load each in hsloader.js
19:28:14 <hamishmack> In the fat compiler I am setting it up so that if there is a JS module in your project it will "export" the functions in that, otherwise it will "export" the ones in Main.
19:29:20 <hamishmack> That way you can avoid exporting Main by including a JS module instead
19:29:28 <luite> hm, wait
19:30:12 <Sam___> Sorry, I am a newbie in Haskell. I have started to read Learn You A Haskell. Interesting. I should like to know: Is there anyone here who uses Haskell for web development? What are the advantages of selecting Haskell over PHP for website development?
19:30:34 <luite> hamishmack: it tries to generate a separate page for all exported functions?
19:30:59 <Axman6> safety and performance. there's quite a few people using haskell for webdev. you might try the #yesod channel or #happstack
19:31:18 <mauke> preflex: quote wlangstroth
19:31:18 <preflex>  <wlangstroth> one of the great things about haskell is that it's not php
19:31:35 <blackdog> Sam___: getting started, you may want to try "scotty"
19:31:47 <hamishmack> luite: Just the "JS exported" functions
19:31:48 <blackdog> yesod is great, but it's an all-encompassing solution, like rails
19:32:00 <Sam___> OK. I shall have a look. So, what are the advantages concretely?
19:32:26 <luite> hamishmack: ah k
19:32:29 <stepcut> Sam___: I use Happstack for web development.. here is a little information, http://www.happstack.com/C/ViewPage/5, but in only scratches the surface
19:32:42 <Sam___> I thought Yesod was a server whereas Rails is a framework?
19:32:43 <blackdog> Sam___: it's very fast, can handle high load, and it's easier to get correct code, because the compiler helps you out when you're talking gibberish.
19:32:45 <hamishmack> luite: https://github.com/hamishmack/ghcjs/blob/master/src/Generator/Link.hs
19:32:56 <luite> yeah I have that file open in my editor atm :)
19:33:20 <blackdog> Sam___: no, not really. Warp is the server you usually run Yesod under.
19:33:21 <monochrom> not why-haskell, but rather why-not-php: http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/
19:33:25 <luite> hamishmack: want to join another channel for some more discussion without distractions?
19:33:36 <hamishmack> I called them "pages" because that was the use case I was thinking of.
19:34:27 <Sam___> Is PHP not cheaper to host than Yesod?
19:34:39 <Axman6> what makes you say that?
19:34:43 <blackdog> Sam___: it's probably easier to find random webhosts that support PHP
19:34:50 <luite> Sam___: you can host yesod for free on heroku, but yeah, many cheap virtual hosters don't support haskell
19:34:53 <blackdog> but you can run Yesod on heroku
19:35:12 <Axman6> seems to me if you're using any sort of service where you have to pay for CPU usage, a compiled language that's fast would be a much better choice than PHP
19:35:13 <blackdog> it's a definite drawback - you'll spend more time on deployment with pretty much any haskell framework.
19:35:27 <blackdog> Axman6: no-one charges by cpu usage.
19:35:29 <stepcut> Sam___: if you are looking for very cheap.. PHP is hard to beat. Most haskell frameworks require a VPS.. but those start at $8/month.. so it can be cheap.. but not very cheap
19:35:30 <Axman6> Sam___: PHP is honestly a truly awful language
19:35:42 <Axman6> blackdog: not even Amazon? i thought they did
19:35:43 <luite> hamishmack: wanna join #ghcjs ?
19:35:54 <blackdog> Axman6: don't talk aesthetics, talk advantages :)
19:35:56 <hamishmack> luite: Yes
19:36:11 <blackdog> Axman6: you get charged per minute the machine's up
19:36:17 <Axman6> ah
19:36:54 <Sam___> Why do you prefer Haskell with Yesod or Happstack over Ocaml with Oxigen?
19:37:03 <blackdog> and really, the cost of running your server is hardly the point. it's the deployment costs that count.
19:37:19 <blackdog> Sam___: because I know haskell better and it has a bigger community :)
19:37:46 <stepcut> Sam___: yes.
19:38:40 <Sam___> Is there a real difference in terms of speed (performance) with a Website built in an imperative language?
19:39:15 <blackdog> Sam___: you can write bad slow haskell, you can write fast PHP, but in general, the same thing written the same way should be faster in haskell.
19:39:30 <blackdog> but that's more to do with PHP being an interpreter
19:39:30 <stepcut> Sam___: or sorry.. missed the 'why do' part
19:40:08 <blackdog> Sam___: http://www.yesodweb.com/blog/2011/03/preliminary-warp-cross-language-benchmarks
19:40:22 <blackdog> (completely ignoring database costs)
19:41:12 <Sam___> Why are they not more CMSs written in Haskell and hosted on Servers in Haskell, then?
19:41:20 <Sam___> Or any other web applications?
19:41:33 <monochrom> it is harder to write correct php than correct haskell. then again, no one cares about correctness, people actually want vulnerabilities.
19:44:08 <stepcut> Sam___: just a matter of timing, I think you will see a few haskell based CMSes appearing soon. Haskell people have spent a while trying to get the really low level web primitives built right first.. so that a CMS can be built on a solid foundation
19:46:35 <Sam___> Can you really do everything you like using Haskell or do you happen to use any other language for some specific tasks?
19:46:58 <Blazemore> Hello, you guys are pretty smart, you'll probably get this one
19:47:22 <Blazemore> How many possible ways are there of making 1 from adding 1/16, 1/8, 1/4 and 1/2?
19:47:31 <stepcut> Sam___: it is not a question of the technical capabilities of the language, but rather the other social and economic issues surrounding it. Interest in using Haskell has a web platform has only really blossomed in the last 2 years, so there has been a lot of catchup work to do, and there are also fewer Haskell developers and fewer companies trying to use Haskell for web development, so the amount of man hours dedicated to the task is s
19:47:31 <stepcut>  small.. but there are now several startups investing time and money in the area, as well as more open source developers working on interesting web related technologies
19:47:33 <Blazemore> For example, 1/2 + 1/2 or 1/2 + 1/4 + 1/4
19:47:43 <mauke> Blazemore: does order matter?
19:47:51 <stepcut> Blazemore: you should write a program to figure that out..
19:47:52 <Blazemore> mauke: yes
19:48:28 <monochrom> I use C when I learn and experiment with Haskell FFI
19:48:28 <Blazemore> stepcut: I don't think you could do that in Haskell
19:48:33 <stepcut> Sam___: I have been using Haskell full-time for 10 years.. the only area where using Haskell has proven tricky is real-time work, because the garbage collector likes to pause the world
19:48:53 <stepcut> Blazemore: you only care about 1/16, 1/8, 1/4, and 1/2 ?
19:49:04 <Blazemore> yes
19:49:30 <stepcut> and you known that the most number of terms you will need to combine is 16 right (16 * 1/16)
19:49:37 <Blazemore> Yep
19:49:47 <monochrom> "I don't think you could do that in Haskell" is a possible provocative tactic to get answers
19:49:47 <stepcut> so.. you can brute force the solution pretty quickly
19:50:06 <Axman6> Sam___: the only time we tend to use other languages is when there's some other great library (usually a C library) which we want to use. like CURL. and then we just make a simple wrapper using the FFI
19:50:13 <CoconutCrab> 16 * 1/16 is one solution
19:50:28 <Blazemore> monochrom: well yes it is ;) But I know there's an answer which doesn't require a program to solve. It's something to do with combinations/permutations
19:50:36 <Blazemore> But I don't remember enough from A-level maths
19:50:38 <CoconutCrab> replace 2 1/6 with 1/8, then we have 1C15
19:50:44 <Sam___> For example
19:51:09 <Sam___> Another basic question: when you want to design a GUI, which library do you use?
19:51:27 * Axman6 hates designing GUIs in any language
19:51:32 <siracusa> Blazemore: When you want a pure mathematical answer, why do you ask here?
19:51:42 <CoconutCrab> nevermind, I forget all the math
19:51:53 <Blazemore> siracusa: First place I thought of that is active, and has people who might know how to work out the answer
19:51:54 <stepcut> siracusa: because it is the friendliest channel on freenode ;)
19:52:18 <stepcut> Blazemore: people on  #math could give you a math solution.. but they might not want to..
19:53:14 <siracusa> Should be on the topic "#haskell -- The friendliest channel on freenode"
19:53:23 <Blazemore> stepcut: Asking on there now, I assumed it wasn't active
19:53:25 <stepcut> Blazemore: instead of doing a pure brute force, you could start with 1/2 + 1/2, and then build a tree where you sub dived each term.. that should allow you to iterate through all the possible valid combinations
19:53:33 <Blazemore> That's what I was thinking stepcut
19:53:40 <rwbarton> what about 1/4 + 1/2 + 1/4
19:53:57 <stepcut> Blazemore: nah.. it is active and they know a lot of stuff.. but they can be elitist sometimes
19:54:00 <Blazemore> rwbarton: That's permitted, yes, that would be one solution
19:54:13 <Blazemore> I might ask on a stack exchange
19:54:31 <stepcut> rwbarton: right.. the tree method does not give you every possible ordering.. you still need to do some additional post processing
19:54:56 <stepcut> rwbarton: the tree would give you, 1/2 + (1/4 + 1/4)
19:55:12 <stepcut> and probably, (1/4 + 1/4) + 1/2
19:56:46 <mauke> does 5271 sound plausible?
19:57:04 <Blazemore> It sounds a little high mauke
19:57:17 <Blazemore> But I'm not sure
19:58:26 <Blazemore> mauke someone in ##math just got that
19:58:27 <tgeeky>  Blazemore: hm. You can answer a different question with egyptian fractions
20:00:04 <tgeeky> Blazemore: 1/2 + 1/4 + 1/8 + 1/16 + 1/32 + (10/320) = 1
20:00:28 <tgeeky> totally helpful I'm sure
20:00:34 <siracusa> mauke: How did you find this number?
20:00:49 <Blazemore> So here's what I'd do
20:00:51 <Blazemore> Build a tree
20:00:54 <Blazemore> So you'd have
20:00:57 <Blazemore> 1/2, 1/2
20:01:06 <Blazemore> There are two ways of arranging that
20:01:11 <Blazemore> Then you have 1/2, 1/4, 1/4
20:01:14 <mauke> siracusa: http://hpaste.org/68209
20:01:36 <rwbarton> yep
20:02:20 <Blazemore> Looks good
20:06:27 <rodayo> In a type signature, when you're stating "what" kind of arguments are accepted...can you only use a typeclass to describe them? I'm doing: "hailstone :: Integer a => a -> a" which won't compile but "hailstone :: Integral a => ..." does
20:06:46 <Veinor> rodayo: the first one would be written hailstone :: Integer -> Integer
20:07:17 <rwbarton> a is a type variable, if you want a fixed type just specify it :)
20:07:24 <rodayo> Veinor, I see...so before the "=>" it's typeclasses, after that it's the types
20:07:34 <Veinor> well, typeclasses and other constraints, but yeah
20:07:44 <shachaf> hailstone :: (a ~ Integer) => a -> a
20:08:08 <rodayo> Hmm, never seen that one before...
20:08:11 <shachaf> (The above will work with GHC. But don't actually do it.)
20:08:25 <Veinor> rodayo: it means 'a must be the same type as Integer'
20:08:32 <rodayo> Hmm, never seen that one before?
20:08:35 <rwbarton> ignore it
20:08:46 <Veinor> but yeah don't do that until you're dealing with more advanced things
20:08:47 <rodayo> Is that like non-standard or something?
20:08:54 <rwbarton> yes
20:09:02 <rwbarton> it is useful in conjunction with other type system extensions
20:09:53 <rodayo> Ah I see...I had the "type -> type" before but I figure that may get repetitive with lots of arguments
20:10:23 <rodayo> The single letter definitions are easier to read
20:10:48 <shachaf> "Haskell programmers don't use enough single-letter identifiers", reports area man
20:12:31 <Veinor> haha
20:13:11 <shachaf> Anyway, you can use ~ to make locally-scoped type synonyms.
20:13:14 <shachaf> But that's an abuse.
20:13:50 <Veinor> i've done it once or twice, i think
20:14:32 <shachaf> Type synonyms are the devil anyway.
20:16:20 <Cale> rodayo: yeah, when something could be literally anything at all, it doesn't hurt to use a single letter identifier for it :)
20:16:49 <shachaf> Cale: Sometimes multiletter identifiers are justified.
20:18:13 <Cale> Identifier name length should be an increasing function of scope, and a decreasing function of frequency of occurrence.
20:19:01 <Cale> Things which are completely polymorphic usually also have tiny scopes. (Apart from undefined)
20:19:46 <Cale> Type variables usually don't have a much larger scope than the type declaration they're in, so they can be one letter each without causing confusion.
20:21:01 <rodayo> good way of putting it
20:33:13 <monochrom> interesting, ghc 7.4.1 does not work with the gold linker this particular way: when building a package, ghc calls ld directly, and ghc 7.4.1 adds a few flags to the ld command not recognized by the gold linker. the extra flags tell ld to use less memory, haha
20:33:42 <monochrom> building an executable is not affected. (calls gcc to link)
20:34:16 <parcs`> monochrom: that depends on whether the linker ghc was built with supported those flags http://hackage.haskell.org/trac/ghc/ticket/6063
20:35:17 <monochrom> yeah, that
20:39:56 * monochrom is building the new cabal-install with ghc 7.4.1. now chugging along by temporarily disabling the gold linker
20:45:36 <newsham> why does "cast" defn here use "fix"?  http://www.scs.stanford.edu/11au-cs240h/notes/generic.html
20:47:07 <sm> are there some good tools that make debugging parsec parsers easier ? Like, say, a runParserDebug that logs input consumed and backtracks by each parser ?
20:47:47 <rwbarton> newsham, it's a trick to give the function access to the type of its own result
20:48:37 <rwbarton> note that typeOf b doesn't actually use b, and ~(Just b) doesn't actually pattern match
20:49:10 <shachaf> That's not the usual definition of cast, is it?
20:49:52 <newsham> what would happen without the fix?
20:49:55 <rwbarton> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-Typeable.html#cast
20:50:05 <shachaf> Oh, usually it's just an expanded version.
20:50:11 <rwbarton> equivalent non-fix version
20:50:20 <shachaf> I assume ScopedTypeVariables would let this be written out more straightlyforward?
20:51:12 <strager> How would I go about building `base` for profiling?  Or do I even need to do that to use -fprof-auto?  (I'm getting Could not find module `Prelude'.)
20:52:05 <rwbarton> yes, then you could write typeOf (undefined :: b)
20:52:28 <parcs`> strager: install your distro's profiling ghc libs
20:52:42 <shachaf> If you foralled the b.
20:52:51 <shachaf> I wonder whether automatic scoping is actually a good thing.
20:53:00 <rwbarton> right
20:53:53 <strager> parcs`: Didn't think of that; thanks =]
20:56:17 <dsj36> I was implementing the MonadFix instance for [], and I was trying to come up with a nontrivial usage of it
20:56:56 <dsj36> things like 'mfix (\x -> [1:x, 2:x])' just give something like [ [1,1,1...], [2,2,2,...] ]
20:57:30 <dsj36> all of this as an exercise, of course :)
20:58:32 <dsj36> any ideas for a nontrivial fixed point in this sense?
21:09:04 <davesque> is snake-casing frowned upon in Haskell?  i don't like camel casing :P.
21:09:37 <Catnaroek> davesque: I guess it is like an "use the language of the land" thing.
21:10:18 <davesque> so camel casing is definitely the norm.
21:11:14 <strager> is_this_snake_casting?
21:11:16 <strager> *casing
21:11:21 <davesque> yep
21:11:41 <shachaf> how'about'monochrom'casing
21:11:45 <shachaf> (Is that what monochrom does?)
21:11:53 <strager> hah.
21:11:57 <mjrosenb> f x y = (x + y) :: Snake -- this is snake casting
21:12:06 <strager> () redundant
21:12:09 <davesque> snake _casing_, not casting
21:12:10 <strager> Shame on you!
21:12:12 <shachaf> cast (x + y) :: Maybe Snake
21:12:24 <shachaf> strager: Huh?
21:12:35 <shachaf> strager: What's wrong with parentheses-that-aren't-strictly-necessary?
21:12:53 <strager> I can't be playful?
21:13:18 <shachaf> Your attitude is a Problem.
21:13:30 <davesque> Catnaroek: so camel casing is definitely the accepted norm?
21:13:31 <nyingen> Snake? Snake?? Snaaaaaaaaaaaaaaake???
21:13:43 <nyingen> sorry, s_n_a_a_a_a_a_a_k_e
21:13:46 <blackdog> davesque: i don't like camelcase much, but i use it to fit in.
21:13:50 <shachaf> davesque: It's pretty normy, going by the Report and standard library.
21:13:53 <strager> is_it_now?
21:14:06 <davesque> cool, guess i gotta swallow it :)
21:14:06 <blackdog> whatever you do: no Snakey_Camel_Case
21:14:09 <shachaf> davesque: Consider that types have to start with an uppercase letter.
21:14:14 <nyingen> Java people like camel case
21:14:18 <davesque> don't worry, that's not gonna happen
21:14:18 <shachaf> blackdog: I think Snakey_Camel_Case is perfectly justified.
21:14:24 <shachaf> In the right context.
21:14:24 <blackdog> shachaf: :/ really?
21:14:28 <blackdog> it's ugly as sin
21:14:49 <davesque> shachaf: true, although python and ruby happily mix snake-casing with class-casing
21:14:50 <shachaf> blackdog: If you're doing snakey_lower_case, what do you propose using for types? Snakey_first_letter_upper_case?
21:14:55 <Catnaroek> davesque: I really hate camelCase, but I will always use it when I am using Haskell. Because if there is something that I hate more than any specific naming convention, it is having to deal with codebases with multiple naming conventions.
21:15:08 <shachaf> davesque: Right, that's true. But it has its own ugliness.
21:15:13 <monochrom> monochrom'casing is oleg'casing
21:15:22 <blackdog> shachaf: FirstLetterUpperCase
21:15:22 <davesque> Catnaroek: agreed.  consistency is more important than personal taste.
21:15:29 <shachaf> Anyway this discussion is probably a waste of channel time. Most casing discussions are.
21:15:38 <blackdog> shachaf: Bike_ShedL
21:15:51 <shachaf> monochrom: monochrom = oleg, right?
21:15:58 <shachaf> monoleg
21:16:00 <monochrom> ha, casing is not injective!
21:16:17 <monochrom> anyway, programmers look for pastimes to kill time
21:16:32 <davesque> please, i'd like a good first impression of this channel :P
21:16:36 <shachaf> Thankfully casing is also not surjective.
21:17:05 <monochrom> sorry, what is snaking-casing again?
21:17:20 <shachaf> underscore_separated_words
21:17:30 <monochrom> thanks
21:17:36 <shachaf> I've never heard it before.
21:17:50 <davesque> well thanks for the clarification anyway
21:17:51 <shachaf> Did you know IRC considers { to be upper-case [?
21:18:05 <monochrom> I didn't
21:18:06 <applicative> davesque I don't think can reasonably object to unexported things being developed with snake casing. and thus e.g. locally bound things after where etc.
21:18:42 <davesque> applicative: true, although I don't want to be made fun of by people :)
21:18:43 <mgsloan> yeah, snake casing is sometimes good for locals, particularly if they share a common prefix or something like that
21:19:01 <applicative> in fact I really hate camel casing local variables:  append firstList secondList = case firstList of ...
21:19:24 <mgsloan> yeah, snake casing locals might be a good thing to canonicalize, actually
21:20:14 <mgsloan> (when you have tons of things in a where clause)
21:20:17 <applicative> mgsloan: I have often thought that, just because it would enhance readability.
21:20:33 <applicative> the only trouble is usually  they're x and y
21:20:57 <monochrom> I would welcome camel case if not for Haskell's restriction that forces the inconsistency in getChar, hGetChar, null, notNull...
21:21:15 <shachaf> Which inconsistency?
21:21:24 <monochrom> you can't just add/delete a prefix, you have to fix up one more character
21:21:34 <monochrom> g vs G for example
21:21:35 <applicative> that is a little taxing isn't it
21:21:36 <shachaf> Ah, yes.
21:21:45 <shachaf> Case is such a ridiculous thing.
21:21:48 <shachaf> English oughtn't have it.
21:21:58 <mgsloan> yeah, you only end up with large local names when you like to create lots of complicated functions in your where declarations (I know I do)
21:23:11 <applicative> can't haskell be written in alphabets that dont make the distinction.  (I assume there are such things)
21:23:37 <applicative> Is there upper case Japanese??
21:24:11 <monochrom> well, if a letter has no distinction, haskell will allow it for only one use, not two uses
21:24:21 <drbean> There are katakana and hiragana alternatives for the same sound.
21:25:13 <blackdog> applicative: https://gist.github.com/2632556 not working makes me sad.
21:25:24 <applicative> the programmer decides whether its 'upper' or 'lower'
21:25:29 <applicative> ?
21:25:46 <blackdog> i wonder if i accidentally used an uppercase snowman.
21:26:42 <applicative> I was wondering, maybe data  ☃
21:27:40 <monochrom> の is allowed for variable beginning, but not type beginning
21:28:22 <monochrom> so, the compiler, not the human, decides what to make of の etc
21:29:50 <davesque> 日本語できる？クール。
21:30:17 <monochrom> same story with エ, can be a variable, not a type. there goes both hiragana and katakana
21:32:01 <monochrom> well, I only tested GHC, I don't know what other compilers do
21:32:22 <applicative> blackdog: https://gist.github.com/2632582
21:32:31 <applicative> snowman is an operator
21:32:33 <blackdog> applicative: oh, duh.
21:32:37 <blackdog> of course. thanks!
21:33:46 <applicative> maybe we can use ☃ to solve the neverending `mappend` disputes
21:34:08 <Cale> davesque: 私のこと？
21:34:10 <blackdog> applicative: frooooostee the snowman, used to love connecting strings
21:34:34 <monochrom> no, ☃ is for yesod and snoyman!
21:34:43 <Cale> lol
21:35:16 <applicative> > let x ☃ y = x `mappend` y in "hello" ☃ " " ☃ "snowman"
21:35:17 <lambdabot>   "hello snowman"
21:36:56 <strager> I'm "creating" my own monad by wrapping the State monad.  My monad's >>= is appearing at the hot spot of a profile.  Am I deriving Monad right?  http://slexy.org/view/s20jmjKDHQ
21:36:57 <blackdog> urk. anyone else get a slightly sick feeling when they read their own haskell from a few years ago?
21:37:27 <strager> Not Haskell (haven't been doing Haskell that long), but code in general, yes =]
21:38:06 <Cale> strager: You could just use newtype deriving and put  deriving (Monad)
21:38:29 <strager> I could do that.  Would that fix the performance problem?
21:38:36 <Cale> No idea.
21:38:41 <strager> I'm just wondering if that looks right.
21:38:43 <davesque> Cale: ハスカルでひらがなとかたかなできる。しらなかた。
21:38:51 <applicative> data Doubles  = {-#UNPACK#-} !Double : ☃: {-#UNPACK#-} !Double is a parse error
21:39:01 <strager> Japanese looks so weird without kanji.
21:39:42 <davesque> こもん。私の日本語は。。。：P
21:39:43 <Cale> It looks correct. Replacing it with newtype deriving should improve performance at least marginally. It might not fix your issue.
21:40:09 <applicative> wait, I got the space wrong thanks to my editor, its okay data Doubles  = {-#UNPACK#-} !Double :☃: {-#UNPACK#-} !Double
21:41:40 <monochrom> no no, you don't say "こもん。私の日本語は。。。：P". you say: こもん。私の日本語は。。。^_^
21:42:05 <davesque> hmm
21:42:13 <davesque> it's been a while ^_^
21:42:32 <Cale> ごもんとはどう言う意味？
21:42:35 <strager> Yup, still up there
21:43:09 <davesque> Cale: i was apologizing for my bad japanese
21:43:14 <Cale> 「ごめん」
21:43:21 <davesque> ahh, right hehe
21:43:36 <strager> Any good tools to slice 'n' dice GHC's .prof output?
21:44:32 <Cale> strager: All I know is that it would certainly be nice with the new profiler to have something which could filter it all
21:45:23 <Cale> The new profiler produces much more detailed reports, but they're kinda ridiculous sometimes.
21:46:00 <Cale> Like, I have .prof files which are 40 MB
21:46:21 <abdulsattar> How can we convert Data.ByteString.ByteString -> String ?
21:46:32 <strager> The one I'm looking at is 26MB
21:46:40 <strager> I just trimmed everything with a self time of 0.0
21:46:41 <Cale> abdulsattar: there's Data.ByteString.Char8.unpack
21:46:48 <strager> Which helps a lot =]
21:46:50 <Cale> abdulsattar: Which will ignore unicode etc.
21:47:02 <Cale> abdulsattar: otherwise, you'll want to use something like a UTF-8 decoder
21:47:17 <abdulsattar> Cale: I'll try that. Thanx
21:54:40 <applicative> abdulsattar: http://hackage.haskell.org/packages/archive/text/0.11.2.0/doc/html/Data-Text-Encoding.html  Data.Text.unpack is Text -> String
21:56:08 <solrize> heyall, i got question about smart constructors.  I want to have   data Foo = A Int | B String   in module X, where the data constructors aren't exported because I want to enforce certain constraints on the values, but I want other modules to be able to inspect the values by pattern matching (just not make new ones).  is there a way to do that?  thanks
21:57:25 <Veinor> i don't believe so
21:57:59 <solrize> related: sort of the same thing for type classes.  I want Foo, Bar, etc. to belong to some unexported type class (because all members of the class need a certain property enforced by the module) but that means other modules don't seem to be able to have type signatures on functions that use those types
21:58:06 <solrize> it's able to infer the typeclass constraints
21:58:14 <solrize> but there's no way to write them down explicitly
21:58:18 <solrize> veinor thanks, hmm.
21:58:46 <Veinor> this is also correct, if you don't export a typeclass then you can't write the type signature because you can't name the class
21:59:17 <hpaste> applicative pasted “BS->Text->String” at http://hpaste.org/68211
21:59:32 <applicative> abdulsattar: like this for exxample ^^^
21:59:39 <solrize> this seems sort of lame.  maybe there is a way to use gadt's instead of classes somehow
21:59:52 <Veinor> possibly, I don't know much about GADTs
22:00:15 <solrize> thanks
22:00:33 <solrize> it's sort of bogus that i can write type-inferrable functions that i can't write explicit types for
22:06:26 <kallisti> what makes something code?
22:07:05 <dmwit> coffee
22:07:09 <kallisti> for instance
22:07:12 <kallisti> is a config file code?
22:07:42 <kallisti> how about the options that you pass to find?
22:10:37 <kallisti> if you say no: isn't it basically doing the same thing as a Python program; it's some data that, when interpreted, produces some computation that was decided by the data itself.
22:11:04 <strager> I consider config files code
22:11:12 <kallisti> all of this should be pretty obvious, but then..
22:11:20 <kallisti> if you say yes: then what is a defintion of what code is?
22:11:41 <dmwit> I get funny looks when I say HTML is a programming language that doesn't have conditionals.
22:12:01 <strager> It has conditionals
22:12:02 <strager> <noscript>!
22:12:03 <strager> =D
22:12:23 <dmwit> For some reason, I don't think that's the source of the funny looks. =P
22:12:54 <kallisti> yeah "HTML isn't a programming language!" is practically ingrained into programmer DNA.
22:13:48 <kallisti> it's like our knee jerk reaction to some 14 year old kid who calls himself a leet HTML hacker.
22:14:00 <chazor> code = characters that mean something.
22:14:17 <chazor> I know that's vague, but it feels correct.
22:14:19 <kallisti> so, data? shocking.
22:14:39 <dmwit> Is there a point to all of this philosophy?
22:14:53 <chazor> well, you can extrapolate to call any language code
22:14:54 <kallisti> no, just musing.
22:17:17 <kallisti> I'm just seeing if I really understand the lack of distinction between data and code.
22:17:51 <solrize> data is code, code data; that is all ye know on earth, and all ye need to know.
22:17:56 <chazor> maybe a better definition would be "an intermediary medium for the purpose of communication"
22:18:47 <chazor> data = abstract concept of information, code = how you express that information.
22:20:09 <bd_> code is one way of interpreting data :)
22:22:33 --- mode: hitchcock.freenode.net set +o ChanServ
22:34:15 <blackdog>  @pl (\x -> foo . x)
22:34:41 <blackdog> no? oh well. perhaps it's silly, but i've never partially applied (.) before
22:34:46 <solrize> @pl (\x -> foo . x)
22:34:46 <lambdabot> (foo .)
22:34:47 <lambdabot> (foo .)
22:34:50 <blackdog> was a "pow! and got illuminated" moment
22:35:07 <shachaf> blackdog: Hopefully you keep up that habit. :-)
22:35:15 <shachaf> Partially applying (.) is only rarely justified.
22:35:25 <shachaf> By which I mean sectioning it.
22:35:37 <blackdog> it's nicer than (\x -> foo .x) though
22:35:48 <shachaf> What's the context?
22:36:23 <blackdog> bumming some code for fun, mostly
22:36:43 <blackdog> wanted to see how terse i could get it without going completely unintelligble
22:38:03 <blackdog> shachaf: i'm not going to put the boobs operator into production code :)
22:39:03 <shachaf> ?
22:39:25 <kallisti> the tersest way to write code is:  f
22:39:30 <kallisti> where f is the function that does the thing you want.
22:39:35 <blackdog> @type ((.) (.))
22:39:35 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
22:40:05 <blackdog> kallisti: it's that second step that's a killer
22:40:33 <kallisti> that's basically what pointfree style is all about
22:40:35 <kallisti> clever code re-use.
22:42:50 <newsham> why is 'exists' spelled 'forall'?  isnt that rather confusing?
22:43:01 <kallisti> it's not.
22:43:11 <dmwit> It is confusing. It is spelled that way to use fewer keywords.
22:44:11 <solrize> it's also confusing because exists could go on the other side of the = i think
22:44:12 <newsham> but surely we could overload other keywords that we don't overload.
22:44:17 <newsham> is keyword minimization that strong a goal?
22:44:32 <kallisti> there's not really anything confusing about existential quantifiers.
22:44:55 <blackdog> kallisti: and that old dictum about debugging being twice as hard as coding suggests that clever code is to be assiduously avoided:)
22:44:55 <kallisti> the forall binds a polymorphic type variable
22:44:59 <kallisti> which is then the field of a constructor.
22:46:44 <solrize> suppose control.exception.evaluate is defined as a black box primitive instead of in terms of !$.  now suppose !$ and seq don't exist.  is it possible to synthesize them with evaluate and unsafecoerce?
22:47:52 <newsham> so it really is 'forall' even though its used to express 'exists'?
22:48:08 <kallisti> possibly with unsafePerformIO, but not in any standard way.
22:48:18 <liyang_> newsham: it really is forall.
22:48:24 <solrize> yeah unsafeperformio is what i meant
22:48:33 <kallisti> you'd essentially be relying on implementation details to achieve the same semantics, I think.
22:48:40 <kallisti> but I don't really know.
22:48:54 <solrize> i guess it's ugly either way
22:58:08 <quicksilver> @tell chrisdone Ah, nice! Thanks.
22:58:08 <lambdabot> Consider it noted.
23:00:11 <Veinor> https://github.com/veinor/sandboxer i wrote a shell script for managing cabal-dev sandboxes
23:00:45 <Veinor> you can do something like sandboxer init my-awesome-sandbox; sandboxer activate my-awesome-sandbox and every cabal-dev you invoke will automatically use ~/.sandboxer/my-awesome-sandbox
23:02:36 <solrize> https://github.com/veinor/milagos hey veinor is that you?  i was just looking at it a little while ago and it looks cool
23:02:44 <Veinor> yeah, that's me
23:02:59 <Veinor> http://blog.amateurtopologist.com/ this is what it looks like, if you didn't see
23:03:14 <solrize> yeah it looks good
23:03:35 <solrize> are you going to support comments?  what is the persistence layer?
23:04:42 <Veinor> the persistence layer is a sqlite database, but it gets regenerated constantly any time you edit a post in /posts
23:04:51 <Veinor> so the actual persistence layer is the filesystem
23:05:04 <Veinor> if i do comments, it'll probably just be disqus.
23:05:11 <solrize> ic
23:06:01 <Veinor> i have on that site these directories: cabal-dev-and-yesod  i-wrote-this-in-emacs  nested-inotify
23:06:05 <solrize> anyway it's nice, hosted comments would be cool but that can happen later :)
23:06:13 <solrize> yeah i saw the nested inotify post on reddit
23:06:23 <solrize> it's correct, inotify doesn't recursively scan directories
23:06:25 <solrize> according to the doc
23:06:28 <Veinor> yeah
23:06:51 <Veinor> i was thinking of going full out and writing up a fully recursive inotify watcher for that post, but... eh
23:07:22 <solrize> yeah
23:07:31 <mgsloan> WIP implementation of TH AST quoters as a quasi-quoter: https://github.com/mgsloan/overload-app/blob/master/src/Language/Haskell/TH/Builders.hs
23:07:39 <solrize> how hard was it to figure out yesod and conduit etc.?
23:07:44 <Veinor> i have a post about sandboxer scheduled for the 14th, figure i want to try to get in the habit of posting once a week
23:07:50 <Veinor> hmm
23:08:33 <Veinor> it took me about four weeks to build milagos, on top of schoolwork and a critical failure at my motivation check as well as a rewrite to move away from a web interface and towards using the filesystem
23:08:52 <Veinor> i don't think it directly uses conduits anywhere
23:09:16 <solrize> it scans a posts directory and puts stuff in sqlite as it finds it?
23:09:20 <Veinor> yeah
23:09:37 <solrize> ic
23:10:19 <Veinor> yesod kind of has a steep learning curve, imo
23:10:22 <solrize> have you done any load tests, or is that even an issue?
23:10:32 <Veinor> but i think once you get to know it it's a lot easier
23:10:42 <solrize> and how big (memory) is the running process?
23:11:16 <solrize> i've been playing with little vps's
23:11:52 <Veinor> it gets about 200 requests/second, I could probably get more if i really optimized it
23:12:08 <solrize> not bad... i wonder where the bottlenecks are
23:13:13 <Veinor> it starts to slow down around 6 concurrent requests, but even at 20 it still gets 160/sec
23:13:56 <Veinor> memory usage is small, around 18MB or so
23:14:17 <solrize> cool
23:14:27 <solrize> maybe mysql could handle more concurrency
23:14:37 <Veinor> it's possible, i mean sqlite isn't exactly known for speed
23:14:46 <solrize> or for a personal blog, just read all the stuff into ram
23:14:56 <Veinor> yeah
23:15:05 <solrize> like happstack-state i guess
23:15:17 <Veinor> i think i'm going to eventually move it to postgresql
23:15:31 <Veinor> or maybe even have an option
23:15:59 <Veinor> (unfortunately i don't think you can switch database types at runtime with yesod)
23:16:12 <solrize> i like fossil (fossil-scm.org), written by same guy who did sqlite
23:17:11 <solrize> why do you use inotify instead of manually pinging the server to push a file?
23:17:48 <solrize> i mean, it's a UI thing, fine either way, so just wondering
23:19:28 <Veinor> because this way i can edit stuff in emacs using tramp (emacs's thing for editing over ssh)
23:19:40 <Veinor> then i can just save and refresh the post
23:20:51 <Veinor> milagos is pretty heavily inspired by octopress
23:23:01 <solrize> yeah, i saw that characteristic of octopress mentioned on hacker news... i got interested in it til i saw it was written in ruby, :/
23:23:52 <Veinor> that's partly why i wrote milagos! so i could have all that neat stuff but written in haskell
23:24:12 <solrize> yay :)
23:29:12 <solrize> you have a lot of small source files rather than a few big ones
23:29:25 <mefisto> Veinor: do you find that yesod presents any particular obstacles?
23:30:29 <free_beard> hi, i'm trying to install the euterpea library from the 2012 hsom book, but the installation fails because of some missing CCA library which should contain a ccap preprocessor. does someone know what that is and where I can get it from?
23:32:27 <free_beard> hsom is the haskell school of music book for the yale course on music and computers
23:32:43 <free_beard> http://haskell.cs.yale.edu/?page_id=269 this is the library i'm trying to install
23:33:04 <Veinor> mefisto: doing runtime theming is hard
23:33:26 <Veinor> yesod compiles the templates into the executable. while you can load templates at runtime, you lose some of the features
23:34:15 <Veinor> it's not insurmountably hard, mind, just nontrivial. compare this to snap, where heist means that all your templates are loaded at runtime anyway
23:35:19 <Veinor> also, it is possible to use heist with yesod so if i really wanted to i could go with that approach
23:36:53 <Veinor> recompilation times can be kind of annoying but usually are on the order of 10 seconds, i think improving this is a gsoc project
23:38:42 <mefisto> what would you use if you wanted to serve templates from a database
23:39:08 <Veinor> what do you mean?
23:42:30 <mefisto> if you have some templates that are stored in your database rather than filesystem... would heist be a good solution for this? just curious if you've  approached this problem]
23:44:12 <Veinor> ah
23:44:40 <Veinor> possibly, yeah. i haven't really thought much about it
23:46:50 <hpaste> justlooks pasted “pacman problem” at http://hpaste.org/68213
23:53:18 <hpaste> justlooks pasted “my prb” at http://hpaste.org/68214
23:53:21 <blackdog> having a bit of trouble with forall quantification at https://gist.github.com/2633129
23:53:50 <blackdog> "res" works fine, "go" fails horribly. is what i'm aiming for possible?
23:54:51 <Veinor> blackdog: what's the error you're getting?
23:55:31 <blackdog> Veinor: pasted as a comment under the gist
23:56:28 <kallisti> I think you want an existential
23:56:39 <blackdog> kallisti: i thought i had an existential
23:56:47 <blackdog> isn't that what Foo is?
23:56:54 <kallisti> no it's just a type synonym
23:56:58 <kallisti> with a rank-n type
23:57:01 <hpaste> justlooks pasted “my prb” at http://hpaste.org/68215
23:57:29 <blackdog> kallisti: hm. ok. so i need a data decl rather than the type synonym?
23:57:33 <kallisti> yes
23:58:34 <kallisti> you want
23:58:54 <kallisti> data AnyJSON = forall a. FromJSON a => AnyJSON a
23:59:00 <kallisti> type Foo = AnyJSON -> String
23:59:05 <blackdog> hah, you little beauty
23:59:13 <blackdog> works a treat, cheers.
23:59:16 <hpaste> justlooks pasted “my prb” at http://hpaste.org/68216
