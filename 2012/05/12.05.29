00:00:54 <ski> dmwit : ok -- i was actually suspecting you were thinking about group actions above
00:01:36 * ski feeds catery a spoon of category theory, spiced with some Earl Grey tea
00:02:25 <ski> "you'd better swallow your medicine, child"
00:03:49 <ski> dmwit : the idea with group actions is that we have a mapping from a group to the automorphism group of some object in some category
00:04:28 <ski> this is known as representation theory
00:05:29 <ski> if the only group element that is mapped to the identity automorphism is the identity element in the group, then the group representation/action is said to be faithful/effective
00:05:36 <ski> so, basically we're looking at
00:05:54 <ski>   f : G >---> Aut A
00:06:09 <ski> usually, this is rephrased as
00:06:38 <ski>   (*) : |G| * |A| >---> |A|
00:06:45 <ski> satisfying
00:06:49 <ski>   1 * a = a
00:07:00 <ski>   (g0 * g0) * a = g0 * (g1 * a)
00:07:46 <dmwit> right
00:07:57 <ski> e.g. we can have a group whose elements are the complex numbers with norm `1', under multiplication (the "unit circle")
00:07:57 <dmwit> I've played with this correspondence or something like it before.
00:08:18 <dmwit> When trying to figure out the right generalization of monoid homomorphisms to stateful homomorphisms.
00:08:23 <ski> and then we can have a group action that maps this group into rotations of the plane around a given point in the plane
00:08:32 <ski> this action is faithful
00:09:11 <ski> if we instead take the group of real numbers (with addition), and map that into rotation around the point by that angle, the action isn't faithful
00:10:13 <dmwit> remind me: faithful means injective on arrows?
00:10:16 <ski> an interesting question is, given some category of objects, which groups can be faithfully represented by actions on this category
00:10:57 <frerich> ski, dmwit: The good thing about such discussions like yours is that it makes me think "Hm, some pretty smart people are using Haskell so it can't be that bad.". The bad thing is that I think "Hm, some pretty smart people are using Haskell, I wonder whether I need a PhD first to really grok this." :-)
00:11:37 <dmwit> frerich: =)
00:12:27 <flebron> the best thing is when you notice that, as the years go by, you understand more and more about this magic
00:12:37 <flebron> and now suddenly monoidal category isn't an insult in klingon
00:12:53 <ski> frerich : hehe
00:13:33 <ski> you learn stuff by learning a trickle here, a trickle there, one step at a time
00:14:00 <ski> dmwit : i think so, but i'm not sure
00:14:22 <ski> the definition given at <http://en.wikipedia.org/wiki/Representation_theory> says that `(*)' should be injective
00:14:56 <ski> my definition was `forall g : G. act g = id => g = 1'
00:15:13 <dmwit> oh, right
00:15:17 <ski> i'm not sure if you meant that `act' or `(*)' should be injective
00:15:36 <ski> (i renamed my `f' above to `act')
00:16:18 <ski> we could first try to prove the equivalence of my definition with `act' being injective
00:16:38 <ski> so, we know that `act g0 = act g1', and want to prove `g0 = g1'
00:16:56 <dmwit> easy, use g0^-1
00:17:41 <ski> we deduce from the premise that `act g0 . (act g1)^-1 = act g1 . (act g1)^-1 = id'
00:18:07 <ski> and i think we can prove that `(act g1)^-1 = act (g1^-1)'
00:18:10 <dmwit> act g0^-1 . act g0 = act g0^-1 . act g1; therefore 1 = act (g0^-1 . g1); therefore g0^-1 . g1 = id and g0 = g1
00:18:32 <ski> then we know that `act g0 . act (g1^-1) = act (g0 * g1^-1)'
00:18:40 <dmwit> oh, my . is backwards compared to yours
00:19:10 <ski> and because we know that this is `id', `g0 * g1^-1' must be `1', by my definition above, and so `g0 = g1'
00:19:38 <ski> dmwit : yeah, your way is basically the same
00:19:51 <ski> then, the other direction
00:20:06 <ski> we assume `act g = id' and want to prove `g = 1'
00:20:17 <ski> well, `id = act 1', so done
00:22:11 <ski> so, is `(*)' injective ?
00:22:41 <ski> let's assume `g0 * a0 = g1 * a1', and try to prove `g0 = g1 /\ a0 = a1'
00:22:45 <dmwit> (*) is always bijective in each argument
00:23:03 <dmwit> proof: use the inverse to get back where you started
00:23:22 <ski> well, i was talking about "jointly injective"
00:23:33 <ski> (i.e. injective over the single pair argument)
00:23:46 <dmwit> surely not
00:23:49 * ski can't recall which direction implies the other, here
00:24:02 <dmwit> since e.g. (g0,a0) and (1,g0*a0) will both go there
00:24:25 <ski> *nod*
00:24:30 <ski> so, what do they mean by
00:24:31 <ski>   An effective or faithful representation is a representation (V,φ) for which the homomorphism φ is injective.
00:24:34 <ski> then ?
00:24:52 <dmwit> Sorry, who is they?
00:24:59 <dmwit> And is this a real question, or a pedagogical test?
00:25:04 <ski> whoever wrote that snippet on the WP page
00:25:16 <ski> real question :)
00:27:18 <dmwit> I would suppose it means if phi(g)=phi(g') then g=g', no?
00:27:24 <ski> i suppose they probably mean the group homomorphism `\g -> \a -> phi(g,a)'
00:27:30 <ski> (aka `curry phi')
00:27:56 <ski> well, they have defined `phi' as taking a pair of a group element and an element of the space `A'
00:27:56 <dmwit> yes
00:28:12 <dmwit> Oh, yeah, well... mathematicians don't worry about that difference, really, do they? =)
00:28:25 <ski> yeah, but it matters :)
00:28:30 <ski> (as evidenced here)
00:29:16 <ski> if we take  if phi(g)=phi(g') then g=g'  at face value,  g  and  g'  must be pairs of group elements and points in the space
00:29:42 <dmwit> If you take phi as being a tuple-argument'd function, it's not a homomorphism.
00:29:53 <kenjin2201> Hello, I'm new to Haskell and trying to install gtk2hs on Windows7 but keep failing. Can anyone help me?
00:29:55 <dmwit> So I think they've been exactly as precise as they need to be.
00:29:56 <Gurrag> how suitable is FreeBSD for serving Yesod or Happstack backends?
00:30:02 <ski> dmwit : it can be a homomorphism in `Set', at least
00:30:05 <dmwit> kenjin2201: Have you read the Windows installation instructions?
00:30:30 <dmwit> kenjin2201: http://code.haskell.org/gtk2hs/INSTALL
00:30:33 <ski> dmwit : if you can embed the points in the group in a(nother) space, then it might also be a homomorphism in the category of spaces considered
00:31:09 <ski> (e.g. often one lets group act over their underlying set/space/object)
00:31:11 <kenjin2201> dmwit: yes. Actually I thought I've succeeded installing but no windows showing
00:31:38 <dmwit> kenjin2201: Well, the formula for success when asking questions is "I do X, expecting Y to happen, but Z happens instead.".
00:32:07 <shachaf> I think about the problem, expecting an answer to occur to me, but nothing occurs to me instead.
00:33:02 <dmwit> Resolution: tell your problem to #haskell.
00:33:10 <kenjin2201> dmwit: Sorry. Ok. I've followed all the instructions. What I want to know is whether GTk+ works as well in Windows 7
00:33:15 <kenjin2201> 64 bit
00:33:25 <dmwit> There are no 64-bit releases of GHC for Windows.
00:33:25 <shachaf> dmwit: Problem: I don't know how to ask questions. :-(
00:33:47 <dmwit> shachaf: ESR has this great web page describing how to ask good questions...
00:33:59 <dmwit> http://www.catb.org/~esr/faqs/smart-questions.html
00:34:01 <dmwit> a bit longish
00:34:14 <flebron> xP wrote some quick test code for an LL(1) parser in haskell, and now it's the 4th and 5th result on google for "ll1 haskell" :s
00:34:23 <dmwit> kenjin2201: You'll need to install 32-bit Gtk libraries and start over if you tried with 64-bit libraries.
00:34:31 * ski . o O ( "tell us EXACTLY 1) what you typed; 2) what you saw; and 3) what you expected to see." )
00:34:43 <kenjin2201> dmwit: Thank you. I'll try it again.
00:35:25 <dmwit> kenjin2201: Also, I've tested only Windows XP. Donations of a Windows 7 DVD will get you support.
00:36:10 <dmwit> flebron: filling a niche, mate!
00:36:12 <dmwit> 'grats
00:38:26 <flebron> :)
00:40:55 <rata_> dmwit: I'll try the formula: I wrote some code to parse, infer and construct some data structures, I expected it to be blazing fast, but it stack overflows instead
00:41:24 <rata_> when I optimise, then it doesn't stack overflows, but it's super slow anyway
00:41:29 <dmwit> solution: get it on the Language Shootout and email dons
00:41:50 <rata_> and then when I compile with profiling, it stack overflows again
00:41:55 <dmwit> haha
00:41:56 <dmwit> awesome
00:42:06 <dmwit> Anyway, the short answer is "use more strictness".
00:42:57 <rata_> well, that was useful before to avoid the stack overflow in optimised code
00:43:59 <rata_> dmwit: do you know if there's any way to tell where to put more strictness?
00:44:38 <dmwit> The usual answer is "do profiling" and "stare at it really hard".
00:45:05 <dmwit> If profiling causes it to stack overflow, you might want to try to find an easier input to run your program on.
00:45:27 <timthelion> Anyone know what mp3 player is to be seen in the corner of this picture? http://xmonad.org/images/screen-dons-tall-status.png
00:45:30 <dmwit> In the worst case, you can try putting some code on hpaste and asking in here for advice.
00:45:49 <ClaudiusMaximus> if you heap profile and see lots of growing THUNK bands then you need to add more strictness, but it doesn't tell you where - other bands growing at the same time might be related though
00:45:53 <ski> dmwit : more strictness isn't always good ..
00:46:03 <ClaudiusMaximus> *probably need
00:46:29 <dmwit> ski: No, but it's how you eliminate stack overflows.
00:46:54 <dmwit> Stack overflows are the direct result of having too many thunks deeply nested.
00:46:55 <rata_> dmwit: then the question becomes, do you know how to make ghc print the whole function name in heap profiles?
00:47:14 <dmwit> No I don't. Have you tried reading the fine manual?
00:48:41 <ClaudiusMaximus> rata_: +RTS -L9999 -RTS should do it (compile with -prof -auto-all -caf-all -rtsopts ; check runtime system options with  +RTS -? )
00:49:27 <rata_> ClaudiusMaximus: thanks =)
00:49:55 <timthelion> rata_: and if you are getting stack overflow, you may want to run it twice to see if it doesn't overflow differently.  Since GHC will do more than one thing at once, sometimes it crashes somewhere else than it overflows.
00:50:38 <timthelion> that is with the profiling
00:51:04 <rata_> timthelion: well, I have isolated the problem to a couple of serial running functions, so I know roughly were the issue is
00:51:34 * timthelion once "isolated" a problem like that too :D
00:52:13 <rata_> I think it overflows now in the second function, but that doesn't mean the first one is perfect, because it allocates too much memory anyway
00:52:24 <Gurrag> Do Haskell web backends perform reliably under 256MB RAM, or is that too little for such use?
00:52:27 <rata_> Alloc rate    3,953,314,290 bytes per MUT second
00:53:20 <kallisti> Gurrag: I would imagine it depends on the application.
00:53:26 <timthelion> I was writting a compiler.  And so I had a whole bunch of (++).  And I had <thing that overflows> ++ <the rest of the really long list of things to do> and of course it always crashed somewhere way down the line, since when it saw that the item was taking a while it just continued...
00:55:41 <rata_> the function that's taking most of the time is called (...)
00:55:44 <rata_> what's that?
00:59:11 <Gurrag> > :t map
00:59:18 <Gurrag> no bot
00:59:49 <timthelion> :t map
00:59:59 <timthelion> nope :(
01:00:00 <ClaudiusMaximus> preflex: seen lambdabot
01:00:00 <preflex>  lambdabot was last seen on #haskell 1 hour, 54 minutes and 10 seconds ago, saying: Data.ByteString.Char8 break :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
01:01:11 <rata_> I find haskell so nice to write but so painful to debug
01:01:52 <frerich> rata_: I think reasoning about performance characteristics is tricky. Like, spotting code which will eat a lot of CPU or memory.
01:02:02 <timthelion> rata_: agreed
01:02:15 <rata_> yes, it's way too hard some times
01:02:17 <frerich> rata_: The lazy semantics make this hard for me, but maybe that's because I'm so strict wired in my brain because of C++.
01:03:11 <rata_> I think there's a missing insight that makes lazy semantics accessible to the intuitive reasoning
01:03:34 <sheepz> hello, is this valid syntax? fold (+) [1,2,3,4]?
01:03:34 <timthelion> frerich: I used to think that you could reason about the opperations like, how difficult a transformation like sort is, and how big a data structure.
01:03:41 <rata_> sheepz: no
01:04:16 <Ralith> sheepz: it's valid syntax, but no function named fold is defined by default.
01:04:18 <frerich> sheepz: The syntax is fine, assuming you do have a function called 'fold'.
01:04:22 <rata_> sheepz: well, actually it is, but probably not what you intend
01:05:05 <sheepz> ok, i thought haskell had like a fold function similarly to map
01:05:07 <ski>   map :: (a -> b) -> ([a] -> [b])
01:05:15 <Ralith> haskell has several.
01:05:19 <Twisol> in your case you'd want foldl1 I assume
01:05:22 <Ralith> and you can define more!
01:06:08 <sheepz> wow foldl1 worked!:D
01:06:09 * ski idly wonders what dan64- tried to paste
01:06:22 <Twisol> foldl1 is a left fold that starts with the first item in the list
01:06:30 <Twisol> foldl requires that you give it an initial value
01:06:36 <ski> > foldl (+) [a,b,c,d]
01:06:46 <ski>   ((a + b) + c) + d
01:06:55 <Twisol> ski: needs an initial accumulator, no?
01:07:03 <ski> er, s//1/, yes
01:07:13 <Twisol> > foldl (+) 0 [1, 2, 3, 4]
01:07:28 <ski>   (((0 + 1) + 2) + 3) + 4
01:07:35 <timthelion> ski: doesn't s//1/ create an infinite list of 1's?
01:07:40 <Twisol> :D
01:08:08 <ski> timthelion : well, depends on whether you want to replace one occurance of the empty string, or every occurance
01:08:34 <ski> and arguably, in a list of `n' elements, there's `n+1' occurances of the empty sub-list
01:08:34 * timthelion is not sure that s//anthing/ is valid regex.
01:08:38 <Twisol> in that case, which occurance?
01:08:48 <ski> any ?
01:09:04 <timthelion> s/ant/anyt/
01:09:05 <ski> (using nondeterminism, anglic or demonic as you please)
01:09:47 * timthelion always prefered the lesser gods of more questionable motives.
01:10:12 <ski> (in this case, the nondeterminism was angelic from my POV, meaning that it replaced the occurance that i wanted to replace -- in the worst case, it's demonic for you, in case you can't predict which occurance i wanted to replace)
01:10:27 <Twisol> pfft.
01:10:28 <Twisol> :)
01:11:06 <Gurrag> > take 4 loop 'a'
01:11:07 <timthelion> ski: I presume you make a little alter and say you're prayers every time you restart the computer after a kernel upgrade?
01:11:31 <ski> timthelion : hm ?
01:11:43 <ski> Gurrag : type error
01:11:47 <timthelion> ski: well, you beleive in angelic nondetermanism
01:11:55 <ski> Gurrag : probably you wanted  take 4 (loop 'a')
01:11:56 <Twisol> s/alter/altar
01:12:26 <path[l]> whats angelic vs demonic non determinism
01:12:30 <barrucadu> timthelion: I think the only way to keep the regex gods happy is with sacrifice.
01:12:45 <Gurrag> brb network hiccup from installing vbox
01:12:46 <Twisol> easy ways to handwave away what nondeterministic stuff will do, I presume
01:12:55 <Twisol> resolution mechanisms
01:13:03 <path[l]> heh I see
01:13:10 <Twisol> angelic: resolves in your favor
01:13:23 <Twisol> demonic: resolves totally against your favor
01:13:50 <timthelion> Twisol: not if you're me.  The angels are trying to defend the world against my evil influence :D
01:14:05 <Twisol> Hah.
01:16:36 <jonaskoelker> why is the notation `>>=' used for, well, >>=?  Historical reasons?
01:17:17 <timthelion> jonaskoelker: it looks pretty and is semantically transparent?
01:17:28 <jonaskoelker> (e.g. why not '==>=<><!!:@'?)
01:17:51 <timthelion> that would be rather awkward to write, no?
01:17:52 <jonaskoelker> semantic transparency `orthogonalTo` notation ?
01:18:08 <jonaskoelker> sure, but how about '==>'?  I think that says "into" more clearly
01:18:19 <jonaskoelker> or some other arrow-looking combination
01:18:25 <burbul> What's the difference between EitherT and ErrorT?
01:18:46 <Twisol> Might have something to do with how Haskell ranks infix functions by default? I don't remember how it works but I read something somewhere. :S
01:18:52 <Zedrikov> jonaskoelker: I guess you can still use '==>=<><!!:@' as an alias for '>>='; you just have to define it if you want.
01:19:06 <jonaskoelker> burbul: my guess: Either is the only "instance" of either, but there can be more than one instance of Error
01:19:19 <jonaskoelker> (oops, s/either/Either/, and it's not an instance)
01:19:41 <jonaskoelker> Twisol: but that is a design choice, which can be coordinated with the design choice of what notation to use?
01:19:46 <jonaskoelker> :i >>=
01:19:56 <jonaskoelker> > :i >>=
01:20:01 <jonaskoelker> -.-
01:20:03 <Twisol> :i (>>=)
01:20:13 <Twisol> you -could- just run ghci :D
01:20:21 <burbul> :t runErrorT
01:20:36 <bitonic> jonaskoelker: you can probably find the reason digging in the mailing list archives
01:20:37 <burbul> huh?
01:20:43 <jonaskoelker> lambdabot is not here
01:20:44 <burbul> Anyway, it's runErrorT :: m (Either e a)
01:20:55 <burbul> So it's hardwired to Either
01:21:17 <burbul> no! Come back, Lambda bot! What are we going to do without you?
01:21:44 <yitz> preflex: tell Cale hi could you please restart lambdabot? thanks!
01:21:45 <preflex>  Consider it noted.
01:22:22 <yitz> preflex: xseen Cale
01:22:22 <preflex>  Cale was last seen on freenode/#haskell 9 hours, 38 minutes and 3 seconds ago, saying: d-snp: It looks like your code should be possible to factor somewhat without any duplication... You might just pull out newHeader and initAck and those cookies as functions of the various things they depend on.
01:22:34 <bitonic> burbul: the result type is, but that does not enforce anything about the actual implementation
01:23:40 <tango73> ciao
01:23:43 <tango73> !list
01:24:26 <yitz> jonaskoelker: once i needed an infix operator version of the constructor for the Last monoid. i used this: !@$+
01:25:33 <rata_> wow! Alloc rate    18,446,744,038,946,294,463 bytes per MUT second
01:25:44 <rata_> Productivity  -2.2% of total user, -2.2% of total elapsed
01:25:51 <greymalkin> Is there any reason that Monoid's 'return' doesn't just use a default implementation of 'pure'? If almost all Monoids are also applicative functors...
01:26:08 <burbul> ah, oh -- thanks
01:27:33 <quicksilver> greymalkin: you meant Monad, right? The answer is that when Monad was defined, Applicative didn't exist.
01:28:03 <quicksilver> if we wre defining Monad now we'd probably remove return entirely and just use pure from applicative.
01:28:12 <greymalkin> Yeah... sorry .. my fingers not getting it.
01:28:16 <greymalkin> monad.
01:28:17 <greymalkin> monad.
01:28:22 <greymalkin> monad.
01:28:24 <Twisol> can hardly blame you.
01:29:06 <greymalkin> Ah... that would allow for imperative-kin to stop confusing themselves with it.
01:29:23 <Twisol> Is it too late to modify Monad in future versions of Haskell?
01:29:33 <quicksilver> no
01:29:47 <quicksilver> it's never too late, it's the 21st century when everything changes
01:30:13 <quicksilver> but there are backward compatibility problems and people are cautious about breaking stuff.
01:30:33 <Ralith> I can see it now
01:30:34 <Twisol> Can anyone recommend a good primer on monad transformers?
01:30:39 <Ralith> Haskell 2012 transitional
01:30:48 <greymalkin> quicksilver: For that reason I think the default implementation (default to pure) would be about perfect; no breakage, less code in the future.
01:31:31 <quicksilver> can you do that? can you use a method from another class in a default without making it a superclass?
01:31:34 <greymalkin> But... I'm less than 5 days into studying haskell, so I reserve the right of my future self to call my present self an egomaniacle idiot.
01:32:11 * Twisol waves to lambdabot
01:32:30 <ski> @botsmack
01:32:37 <lambdabot> :)
01:33:00 <ski> @vixon why did you leave us before, have you no heart ?
01:33:07 <lambdabot> You have to face the fact that whole problem is really the blacks. The key is to divise a system that reconizes this while not appearing to...
01:33:09 <myme> Twisol: I'd like that too, if you find any.
01:33:27 <ski>   "The term \"flexibility\" is usually used to denote the existence of a range of choices available to a programmer or implementor -- the more choice, the better the flexibility. Flexibility is sometimes referred to as \"generality\". Because it is frequently presented in the desirable terms, \"delaying the binding of virtual objects to their realisations\", increased flexibility has generally been considered a fatted calf of great succulence,
01:33:38 <ski>   "In recent years, the wisdom of this quest has been called into question, for flexibility without discipline appears contrary to the plans of the god of reliability. (An automobile with independent steering mechanisms for both front wheels is more flexible but less disciplined than an ordinary one. It is mainly of metaphysical interest, offensive to the god of safe highways.)"
01:33:38 <Twisol> Lol, what did you do to lambdabot?
01:33:43 <Eduard_Munteanu> Phew, good thing it's not the offensive vixen we knew :P
01:33:44 <ski>    (-- quoted in Zoltan Somogyi's Ph.D. thesis "A parallel logic programming system based on strong and precise modes" in 1989-01 at <http://ww2.cs.mu.oz.au/~zs/papers/thesis.ps.gz>)
01:33:48 <ski>   -- "Sacrificing the calf of flexibility on the altar of reliability" by Peter J. Denning in 1976
01:33:59 <quicksilver> greymalkin: answer, No. viz. Could not deduce (MyApplicative m) from the context (MyMonad m) arising from a use of `pure'at /Users/jules/personal/test.hs:9:11-14
01:34:01 <ciaranm> "pure" is just as silly a name as "return". clearly we should use greek letters. also monads should be defined by eta and mu, not bind
01:34:13 <ski> timthelion ^
01:34:22 <greymalkin> :(
01:34:46 <quicksilver> greymalkin: I'm pretty sure one of the many class hierarchy improvement suggestions makes what you're suggesting permissible.
01:34:54 <quicksilver> greymalkin: (for pretty much exactly the reason you want it)
01:34:55 <burbul> <greymalkin>: sounds like you've gone a long way in five days. What are you using to learn from?
01:35:25 <burbul> I don't think I encountered any tutorials that mentioned Applicative
01:35:29 <Twisol> I've been learning for about that amount of time too.
01:35:38 <Twisol> burbul: Learn You A Haskell talks about Applicative.
01:35:56 <ski> path[l],Twisol : angelic nondeterminism means that the system will try alternate options until it generates one which works for you. demonic means that the system will arbitrarily choose one of the possibly alternatives, and you have to be prepared for any one of them
01:36:11 <quicksilver> greymalkin: see http://hackage.haskell.org/trac/ghc/wiki/DefaultSuperclassInstances and, in particular see ALL FOUR links in the first paragraph of that page.
01:36:14 <ciaranm> i thought demonic meant it always chose the one you didn't want
01:36:26 <Twisol> that sounds more like chaotic than demonic
01:36:28 <quicksilver> ciaranm: "always" is subjective.
01:36:28 <greymalkin> burbul: Just "Learn you a haskell..." -- I come from Erlang and scheme (in addition to a rash of imperatives) so I have some mental skids already greased.
01:36:47 <quicksilver> ciaranm: if you want determinism you have to assume it might always choose that one
01:36:55 <quicksilver> which doesn't mean than in an operational model it will.
01:37:21 <quicksilver> lots of the work on nondeterminism is about how you can use non-deterministic constructs to product a deterministic result
01:37:30 <quicksilver> (or at least, a result with tightly bounded non-determinism)
01:37:41 <ski> path[l],Twisol : e.g. the list monad, as well as backtracking Prolog, is angelic nondeterminism; while the nondeterminacy generated by the scheduler interleaving threads/processes in concurrenty if of the demonic kind, as is random generators and partially specified library functions (like what happens if you don't pass an equivalence relation to `nubBy')
01:37:41 <path[l]> ski:  ah, got it. thanks
01:38:13 <Twisol> I see, interesting. Thanks.
01:38:37 <path[l]> oh
01:38:44 <path[l]> that's very cool
01:38:51 <ski> path[l],Twisol : angelic is also known as "all-solutions" nondeterminism, and demonic is also known as "committed-choice" nondeterminism
01:39:15 <Twisol> I guess it's easy to discount them when they have cutesy names.
01:39:28 <ski> path[l],Twisol : angelic is related to the Hoare powerdomain preorder, while demonic is related to the Smyth powerdomain preorder
01:40:00 <path[l]> going over my head now
01:40:04 <Twisol> ^
01:40:23 <ski> well, consider a type with a preorder (e.g. a partial order)
01:40:36 <ski> e.g. consider the type `Maybe Bool'
01:41:00 <ski> this has elements `_|_',`Nothing',`Just _|_',`Just False',`Just True'
01:41:08 <ski> with the ordering generated by
01:41:16 <ski>   _|_  =[  Nothing
01:41:20 <ski>   _|_  =[  Just _|_
01:41:28 <ski>   Just _|_  =[  Just False
01:41:30 <ski>   Just _|_  =[  Just True
01:41:42 <ski> here `x =[ y' means that `y' is more defined than `x'
01:41:57 <Twisol> following so far...
01:42:00 <path[l]> ok
01:42:26 <ski> now, the question is, what is an appropriate ordering for the type `{Maybe Bool}' (with elements being sets containing the elements above)
01:42:58 <ski> in any case we want to have the property that if
01:43:20 <ski>   forall i. a_i =[ b_i
01:43:22 <ski> then
01:43:45 <ski>   {a_i | i \in I} =[ {b_i | i \in I}
01:43:51 <ski> this e.g. means that
01:44:07 <Twisol> is _i meant to be a subscript?
01:44:10 <ski> yes
01:44:18 <ski>   {_|_ , Just _|_}  =[  {Nothing , Just False}
01:44:20 <ski> as well as
01:44:28 <ski>   {_|_ , Just _|_}  =[  {Just True , Just True}
01:44:44 <ski> i.e. we can make a set of elements more defined, by making the elements more defined
01:45:07 <Twisol> seems to make sense.
01:45:11 <path[l]> actually I think I'm stuck at something more basic
01:45:23 <path[l]> why is the bottom type an element of Maybe Bool?
01:45:32 <Twisol> not that I really grok the preorder thing too much, but that last statement, sure
01:45:39 <Eduard_Munteanu> It's an element of any type.
01:45:42 <greymalkin> So... angelic will prefer the most specific set, demonic will prefer the least specific set.  ?
01:45:45 <ski> now, with angelic/Hoare preorder we also say that if `A' is a subset of `B', then `A =[ B'
01:45:54 <path[l]> oh ok
01:46:02 <ciaranm> > let x = x in x :: Maybe Bool
01:46:05 <lambdabot>   mueval-core: Time limit exceeded
01:46:07 <ski> and, with demonic/Smyth preorder we also say that if `A' is a *superset* of `B', then `A =[ B'
01:46:35 <sopvop> How to lift applicative into another applicative? Or how to use monad transformers-like stuff but with applicative interface?
01:46:47 <Twisol> so in angelic, supersets are more well defined, and in demonic, subsets are more well defined?
01:47:10 <ski> so, this mean that in the angelic/Hoare ordering, if you see an element in the set, then it'll still be there, when the computation progresses (and more elements may be found)
01:47:28 <ski> so, angelic never removes any element from the set
01:47:30 <greymalkin> Brilliant.
01:47:52 <ski> if you're looking for an even element in the set, and find `2', then you can stop, safe in the knowledge that `2' won't be retracted later
01:48:09 <path[l]> why would demonic remove elements from the set
01:48:09 <ski> however, with the demonic/Smyth preorder, as the computation progresses, elements can be removed
01:48:34 <ski> so, in demonic, the elements so far in the set represents the *possible* outcomes of the computation
01:48:48 <Twisol> ahhh.
01:49:01 * frerich notes all this heaven/hell talk has a different touch if you're addicted to Diablo 3.
01:49:03 <ski> so, if you want to check that the outcome is an even number, then you have to check that *all* current elements are even
01:49:08 <Twisol> almost like a whitelist vs. a blacklist?
01:49:21 <ski> this corresponds to you having to consider every possible interleaving of threads, with concurrency
01:49:35 <Twisol> in that they go different directions, I mean, but come to the same result
01:50:02 <path[l]> Im not following this at all. I was with you till you said you can order from supersets to subsets or vice versa. But I didnt follow how elements are removed from a set
01:50:13 <greymalkin> Twisol: the whitelist/blacklist is a bit more static.
01:50:22 <Twisol> I'm grasping for handholds :P
01:50:39 <ski> path[l] : in the angelic/Hoare preorder, we have e.g.
01:50:46 <ciaranm> if you've seen branch and bound algorithms, you can think of angelic as being like the possible results you build up as you branch, and demonic as being the values left after a bound heuristic
01:50:52 <Eduard_Munteanu> path[l]: more defined elements correspond to either subsets or supersets, as defined above
01:51:10 <path[l]> oh ok
01:51:29 <ski>   {}  =[ {_|_ , Just True} =[ {Nothing , _|_ , Just True} =[ {Nothing , Just _|_ , Just True} =[ {Nothing , Just True}
01:51:34 <Eduard_Munteanu> So progress in the computation means you either add or remove elements.
01:51:41 <Twisol> so if I have this right, angelic builds up from a set of no results, and demonic eliminates from a set of everything?
01:51:41 <ski> in the demonic/Smyth, we have otoh
01:52:03 <greymalkin> Twisol: They both build...
01:52:32 <ski>   {Nothing , Just _|_} =[ {Nothing , Just True , Just _|_} =[ {Just True , Just False} =[ {Just False}
01:52:41 <greymalkin> But as you're building a list (say, l-r tree traversal, for argument's sake) of the elements in a tree, you have two scenarios:
01:53:02 <greymalkin> Angelic: After you've gone over the left side, you can be sure it will still be there.
01:53:23 <greymalkin> Demonic: The tree may be pruned, even while you're building your list.
01:53:36 <greymalkin> ski: About right? (although likely naive)
01:53:52 <ski> (btw, i should say that i may be mixing up which of angelic and demonic corresponds to the names "Hoare" and "Smyth" here -- the book "Logic Via Topology" by Steven Vickers discusses these two powerdomains a bit, but i haven't that book here now)
01:54:25 <greymalkin> being that Hoare is "upper" and Smyth is "lower" in wikipedia, I'd say you've got it right.
01:54:39 <ciaranm> that sounds like one of those books that would get you lynched by an angry mob of stuffy old logicians
01:54:58 <Twisol> mm, I'm definitely having trouble visualizing this. It's okay, it's not something I absolutely need to understand right now.
01:55:12 <path[l]> yeah
01:55:14 <path[l]> same here
01:55:44 <greymalkin> I *think* I have it... the part about thread interleaving made it seem clear to me.
01:55:47 <ski> greymalkin : if by "gone over to the left side" corresponds to crossing from the left side of `=[' to the right side, then it sounds right
01:55:47 <path[l]> I'm also not sure why every element in the set remaining is the same as "the system tries everything until something works"
01:56:08 <Twisol> well, I get how that corresponds, anyway
01:56:08 <path[l]> whereas "some elements may vanish" is the same as "it just locks into one random choice"
01:56:48 <greymalkin> path[l]: the "lockes into one random choice" is just the most extreme version of "some elements may vanish"
01:57:02 <ski> greymalkin : the random value source, and the "implementation-defined behaviour" examples are also common
01:57:25 <greymalkin> Ak...
01:57:26 <greymalkin> No
01:57:31 <path[l]> huh … ok I have to think about this correlation
01:57:45 <greymalkin> Hoare is lower... Smyth is upper... you still have it right, I typed it wrong.
01:58:08 <Twisol> so what, demonic is like a reader thread concurrent with a writer thread?
01:58:21 <ski> e.g. in Scheme, the behaviour of `(list (read) (read))' is (demonically) nondeterministic, because order of evaluation of the operator and operands in a combination (/application) form isn't defined (except to say that it must correspond to *some* sequential order)
01:58:24 * Twisol is trying one last time.
01:59:01 <ski> but in PLT Scheme^W^WRacket, they always to left-to-right evaluation here -- but if you want to write portable Scheme code, you can't rely on this
01:59:02 <Twisol> ..Ahh.
01:59:03 <greymalkin> ski: But by "gone over" I mean that in creating a fictional list of all elements in a binary tree, you have completed traversal of a left tree that, in the demonic case, may be pruned while you are traversing the right hand side.
01:59:28 <Twisol> Do you have a similar example for angelic nondeterminism?
01:59:51 <ski> Twisol : demonic means that there's multiple possibilities, and you don't know which of them will actually happen
02:00:56 <greymalkin> hate to run.. still interesting, but need sleep.
02:02:15 <ski> Twisol : e.g. `catch (foo (error "a") (error "b")) (\e -> print e >> return 0)' where you know that `foo' will evaluate both arguments, but you don't know in which order
02:03:10 <ski> haskell conceptually specifies a (non-empty) *set* of exceptions here, and `catch' demonically chooses one member from that set
02:03:31 <ski> Twisol : list monad is an example or angelic
02:04:51 <Twisol> so far, demonic seems most familiar - it seems directly related to why I never, ever, ever use i++ or i-- multiple times in a statement in imperative languages.
02:05:07 <ski> > do x <- [0 .. 9]; y <- [0 .. 9]; guard (y > 5); guard (x == y*y); return (x,y)
02:05:08 <lambdabot>   []
02:05:18 <ski> > do x <- [0 .. 9]; y <- [0 .. 9]; guard (x > 5); guard (x == y*y); return (x,y)
02:05:19 <lambdabot>   [(9,3)]
02:05:21 <path[l]> yeah, I've only seen demonic
02:05:36 <merijn> Twisol: Man, nested ++ and -- operators are the best :)
02:05:41 <Twisol> ;_;
02:05:47 <ski> here, it "magically" choose the right values for `x' and `y', which satisfied the constraints i later placed on them
02:06:05 <merijn> Twisol: This is a nice one to piss of colleagues: "return i++;"
02:06:14 <Twisol> Stop it, no more! :(
02:06:25 <HugoDaniel> hi
02:06:27 <path[l]> ski: isnt that because we ASKED it to try all options?
02:06:29 <ciaranm> return i++; is well defined, incidentally
02:06:29 <Twisol> ski: So it sort of picked all of them?
02:06:30 <Gurrag> `i` gets returned and the value subsequently increased, and then freed?
02:06:34 <ski> is `i ++ --' determined ?
02:06:38 <adamt> I don't want to work with people who don't know the difference between ++i and i++. ;)
02:06:46 <merijn> ciaranm: Sure, I know it is well defined. But it still confuses plenty of people :)
02:06:52 <Twisol> ski: not to my knowledge, the return value is just a value, not a variable itself
02:06:53 <ski> path[l] : of course, that's the *implementation* of the angelic non-determinism
02:07:09 <ciaranm> also, return i++; is very common in c++ with iterators, so it's only c programmers who won't get it
02:07:15 <ski> path[l] : btw, note that the complexity class NP is defined in terms of angelic nondeterminism
02:07:25 <sheepz> why cannot I do this? foldl + 0 (map(\x -> x*x) [1,2,3,4])
02:07:35 <Twisol> sheepz: parenthesize +
02:07:37 <Eduard_Munteanu> (i++)-- shouldn't be, IIRC
02:07:49 <Twisol> > foldl (+) 0 (map (\x -> x*x) [1, 2, 3, 4])
02:07:49 <lambdabot>   30
02:07:55 <ski> we assume that we can guess a solution, and we want to know that the complexity of checking that it's a proper solution is polynomial-time
02:07:58 <sheepz> Twisol: thank you
02:08:12 <Twisol> sheepz; welcome. As a general rule, throw parentheses around an infix operator you're not invoking.
02:08:13 <path[l]> oh ok
02:08:14 <mroman> > foldl (+) 0 (map (*) [1,2,3,4])
02:08:15 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
02:08:15 <lambdabot>    arising from a use of `...
02:08:19 <merijn> sheepz: In general, surround operators with parentheses to use them a functions
02:08:24 <mroman> hm.
02:08:42 <merijn> mroman: That map returns a list of functions
02:08:51 <merijn> Which you then attempt to fold
02:08:53 <Twisol> ski: so in summary, demonic is like multiple ++'s in a line, and angelic is like investigating all possibilities?
02:08:53 <Eduard_Munteanu> Otherwise that parses as (+) foldl (0 (map ...))
02:08:54 <mroman> oh yeah
02:08:58 <mroman> I misread x*x :)
02:09:13 <ski> Twisol : those are good examples, yes
02:09:13 <sheepz> how would I go about writing it as a function?
02:09:18 <sheepz> like sum_of_squares
02:09:21 <merijn> > foldl (+) 0 (map (join (*)) [1,2,3,4])
02:09:22 <lambdabot>   30
02:09:31 <Twisol> ski: excellent!
02:09:35 <mroman> Exactly.
02:09:50 <ski> Twisol : of course, iirc, multiple `++' in C with no sequence-point in between causes UB, and not just indeterminacy
02:10:08 <ski> (which isn't quite the same thing)
02:10:24 <Twisol> ski: well, from the observer's point of view… all I care about is that I have no idea what i will be at either point.
02:10:26 <Eduard_Munteanu> ski: I think it's invalid as an expression
02:10:36 <Twisol> ski: given foo(i++, i++) anyway
02:10:46 <merijn> > let square = map (join (*) in sum . square $ [1,2,3,4]
02:10:47 <lambdabot>   <no location info>: parse error on input `in'
02:10:50 <ski> UB here means that *before* it executes the code with the `++', it may do unexpected stuff
02:10:55 <ciaranm> x++ gives you an rvalue, not an lvalue
02:10:58 <merijn> > let square = map (join (*)) in sum . square $ [1,2,3,4]
02:11:00 <lambdabot>   30
02:11:02 <Eduard_Munteanu> i++ returns an rvalue
02:11:40 <ski> sheepz : there's also `(^ 2)'
02:11:52 <merijn> sheepz: I would either define a square function and then define it as "sum . map (^2)" or something like that
02:11:58 <mroman> What imports does lambdabot use?
02:12:05 <merijn> eh, ignore the first half of that sentence
02:12:13 <merijn> I changed my mind on the square function :p
02:12:18 <mroman> Because without instance declaration join does not work that way.
02:12:29 <merijn> :t join
02:12:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
02:12:33 <ciaranm> mroman: lambdabot uses a programming language called calekell, not haskell
02:12:48 <merijn> mroman: Sure it does, "(->) e" is an instance of Monad
02:12:49 <ski> Twisol : no, not only don't you know what `i' is after that piece of code has executed. you *also* don't know that the program is going to do *before* it reaches that point
02:13:06 <merijn> ciaranm: Pretty sure join works like that in haskell too :p
02:13:10 <Twisol> ski: Why's that?
02:13:28 <mroman> let square = map (join (*)) in sum . square $ [1,2,3,4] <- does not work in ghci
02:13:40 <sheepz> merijn, ski, i was trying to find a way to implement in with foldl
02:13:42 <ciaranm> mroman: Control.Monad.Instances probably
02:13:42 <merijn> mroman: You might need to import Control.Monad
02:13:55 <mroman> join is in Control.Monad
02:14:01 <mroman> so it's obviously imported ;)
02:14:03 <merijn> Or Data.Functor, something like that
02:14:07 <quicksilver> I don't think simply having some modules imported is an example of caleskell.
02:14:11 <Taneb> Control.Monad.Instances
02:14:13 <ski> Twisol : see "A Guide to Undefined Behavior in C and C++, Part 1" by John Regehr in 2010-07-09 at <http://blog.regehr.org/archives/213>
02:14:26 <ciaranm> mroman: e-> isn't
02:14:38 <quicksilver> caleskell is stuff like the generalised (.)
02:14:53 <merijn> Caleskell is limited to those module imports that are different form haskell/controversial. Not simply "an imported instance"
02:15:00 <Eduard_Munteanu> @index
02:15:00 <lambdabot> bzzt
02:15:08 <Eduard_Munteanu> @instances-import
02:15:08 <lambdabot> Plugin `instances' failed with: Prelude.last: empty list
02:15:09 <merijn> quicksilver: Don't forget Functor instance for numbers :p
02:15:14 <ski> Twisol : because UB means that the compiler may *assume* that you don't break the rules. and it may use that information to optimize code running before the `++' code -- and if you break the rules, that may cause unexpected things to happen *before* it reaches the `++'s
02:15:17 <Eduard_Munteanu> Bah, what was it...
02:15:22 <Twisol> ah, gotcha
02:15:24 <Eduard_Munteanu> @imports
02:15:25 <lambdabot> Unknown command, try @list
02:15:30 <Eduard_Munteanu> Nevermind.
02:15:41 <Twisol> ski: ignoring the details of sequence points and undefined behavior, is the idea of multiple i++'s in the same expression an acceptable proxy for demonic nondeterminism>
02:15:42 <Twisol> *?
02:16:05 <ski> sheepz : using `foldl' should be almost the same as using `foldr'
02:16:28 <sheepz> i don't know how to pass it a list
02:17:14 <quicksilver> Twisol: if the C standard said "the ++s will be evaluated sequentially but the order of evaluation is not specified" then yes.
02:17:56 <ski> Twisol : yes .. though `(list (begin (set! x (+ 1 x)) x) (begin (set! x (+ 1 x)) x))' is a better example (since this isn't UB, only implementation-defined)
02:17:57 <quicksilver> Twisol: but where the C standard simply says "behaviour is undefined" then a compliant compiler may choose to print a picture of a sleeping kitten and then go play pool for the rest of the day.
02:18:30 <Twisol> ski: is that Haskell?
02:18:46 <Eduard_Munteanu> More like Lisp something.
02:18:55 <ski> quicksilver : or it may deviously do what you expected it to, except when you've been lulled into a false sense of safety ;)
02:18:57 <Eduard_Munteanu> The parens give it away :P
02:19:00 <ski> Twisol : it's Scheme
02:19:06 <Eduard_Munteanu> See? :D
02:19:35 <Twisol> so in general, having two things accessible the same resource in such a way that the resource is modified, but with no idea which one will go first.
02:19:38 <Twisol> yes?
02:19:48 <Twisol> *accessing
02:20:03 <ski> Twisol : Scheme doesn't define the order of evaluating `e',`e0',`e1',... in `(e e0 e1 ...)', it only specifies that it must be consistent with *some* sequential ordering of these (so an interleaving is not allowed, e.g.)
02:20:28 <Ralith> that seems like a weird thing to specify
02:20:29 <ski> Twisol : yes, that's a common case
02:20:48 <Twisol> ski: it's just the simplest case for a typically-imperative programmer like me to grok, really
02:21:06 <ski> Twisol : of course, usually the idea is that the *end* result will be the same, regardless of which intermediate states are actually used
02:21:25 <Twisol> ah, that's a new wrinkle. :(
02:21:52 <Twisol> so the start and end states are well defined, but the middle is foggy?
02:22:24 <ski> Twisol : e.g. handling a large piece of work by chunking it into parts, handing them off to threads (hopefully executing on different cores/machines), then telling them to post the result to a join channel (in some nondeterministic order), and then you piece them together in the right order
02:22:33 <ski> e.g. torrent :)
02:22:39 <Twisol> Gotcha...
02:23:02 <sheepz> hmm, how do I get a list of partial sums for a list of numbers?
02:23:30 <Twisol> deriving a series from a sequence? :o
02:23:31 <quicksilver> > scanl (+) [1,2,3,4,5]
02:23:32 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [[t]])
02:23:32 <lambdabot>    arising from a ...
02:23:36 <ski> of course, the problem is in convincing / proving to yourself (or someone else) that in the *end*, the internal nondeterminacy doesn't really matter
02:23:39 <quicksilver> > scanl1 (+) [1,2,3,4,5]
02:23:40 <lambdabot>   [1,3,6,10,15]
02:24:12 <quicksilver> sheepz: possibly whaty ou meant? ^^
02:24:39 <ski> Ralith : yeah, i'm not sure of the rationale for not allowing interleavings there
02:25:11 <ski> maybe they'd have to specify which operations has to be atomic, then
02:25:38 <Ralith> interleaving wouldn't make atomicity an issue, would it?
02:25:43 <Ralith> that would only come up with concurrency
02:26:01 <sheepz> quicksilver, for [1,4,8] get [0, 1, 5, 13]
02:26:15 <quicksilver> > scanl (+) 0 [1,4,8]
02:26:15 <lambdabot>   [0,1,5,13]
02:26:44 <sheepz> quicksilver: thank you
02:27:04 <ski> Ralith : depends -- can `(set! x (+ 1 x))' be interleaved with `(set! x (* 2 x))' e.g. ?
02:27:49 <Ralith> oh, wait
02:28:03 <Ralith> for some reason I thought 'sequential' meant 'lexical'
02:28:11 <Ralith> I get you now
02:28:16 <Ralith> yeah, atomicity would be an issue
02:28:57 <ski> Ralith : and yes, one possibly way to implement the interleaving would be to have concurrency everywhere
02:29:10 <Ralith> would be a bit silly
02:29:15 <ski> Oz1 did this
02:29:21 <Ralith> Oz1?
02:29:48 <ski> (it turned out to be inefficient, because it was too fine-grained, and the implementation didn't know to not do it for small enough computations)
02:30:00 <ski> the first implementation of the language Oz used in CTM
02:30:29 <ski> another way to get interleaving would be to add some kind of coroutines, i think
02:32:20 <ski> like `(make-channel c (foo (begin (send c 2) 3) (receive c) (begin (send c 4) 5) (receive c)))' or something
02:33:13 <Twisol> quick question… I have this definition: type TelnetWriter = WriterT [Word8] (State WriterState) . How do I go about getting a value that's an instance of this type?
02:33:17 <ski> executing a `(receive c)' would freeze this sub-computation, until another sub-computation does a `send' on `c'
02:33:33 <ski> actually, reverse the order of the four forms inside the `foo' call above
02:33:34 <Twisol> with a plain Writer I'd just pass a tuple to 'writer'.
02:33:42 <Baughn> I'm reading the haskellwiki on catamorphisms, and.. in haskell terms, what exactly is an f-algebra?
02:33:58 <ski> Baughn : consider
02:34:19 <ski>   data List a = Nil
02:34:19 <ski>               | Cons a (List a)
02:34:54 <ciaranm> Baughn: do you know what an endofunctor is?
02:34:59 <ski> this type `List a' is the intitial `ListF a'-algebra, where that type is defined like
02:35:12 <ski>   data ListF a r = NilF
02:35:18 <ski>                  | Cons a r
02:35:24 <Baughn> ciaranm: Nope!
02:35:25 <ski> (s/Cons/ConsF/)
02:35:38 <ski> (you may rename `r' to `self' or `this', if you prefer)
02:35:39 <ciaranm> Baughn: do you know what a functor is?
02:35:46 <Baughn> ciaranm: Well, in haskell terms yes..
02:36:41 <Baughn> ski: So that's a.. type-level list?
02:36:55 <Baughn> Well, no. Heterogenous list..
02:37:02 <ski> an `F'-algebra consists of two things :
02:37:03 <Baughn> I would normally use a tuple?
02:37:17 <ski>   (a) a type/object/set `X'
02:37:27 <ski>   (b) a function of type `F X -> X'
02:37:47 <ski> so, an `List a'-algebra then consists of a type `X', and a function `List a X -> X'
02:38:30 <ski> er, `ListF a'-algebra, and `ListF a X -> X', that should be
02:39:03 <ski> you can check that a function of type `ListF a X -> X' more or less is the same as `(X,a -> X -> X)'
02:39:16 <ski> now, consider the function `foldr'
02:39:29 <ski>   foldr :: (a -> r -> r) -> r -> [a] -> r
02:39:38 <ski> we imagine this is our
02:39:44 <ski>   foldr :: (a -> r -> r) -> r -> List a -> r
02:40:02 <ski> then, we take liberties with the arguments. making it
02:40:08 <ski>   foldr :: (r,a -> r -> r) -> List a -> r
02:40:13 <ski> finally making it
02:40:24 <ski>   foldr :: (ListF a r -> r) -> (List a -> r)
02:40:29 <Twisol> ski: Out of curiosity, do you have  a degree in mathematics? You seem to have a really good grasp on this stuff.
02:40:50 <quicksilver> ask not if ski has a degree; ask how many degrees ski has.
02:41:01 <hughfdjackson> how many degrees does ski have? :p
02:41:04 <Twisol> well I suppose that answers my question! :P
02:41:09 <hughfdjackson> not mine ;)
02:41:19 <hughfdjackson> :D don't worry, i ain't really prying
02:41:23 <ski> so, `foldr' is a function, that given *any* `ListF a'-algebra (with carrier `r'), gives a function from `List a' (which is the *initial* `ListF a'-algebra) to `r'
02:42:25 <ski> that `List a' is the initial `ListF a'-algebra *means* that given an `ListF a'-algebra, there's a *unique* homomorphism from the initial algebra to it
02:43:32 <ski> and a morphism from one `ListF a'-algebra (say with carrier `r0', and function `con0 :: ListF a r0 -> r0') to another `ListF a'-algebra (say with carrier `r1', and function `con1 :: ListF a r1 -> r1')
02:43:56 <ski> such a morphism/homomorphism is the same as a function `f :: r0 -> r1' from the carrier of the first one to the carrier of the second ond
02:44:04 <ski> such that
02:44:44 * frerich watches this monologue.
02:44:46 <Baughn> Not sure I'm getting this.. but basically "F-algebra" means "There is a fold-like function over F"
02:45:04 <Baughn> That seems too specific for such a generic term
02:45:10 <ciaranm> for some very vague value of "fold-like"...
02:45:12 <ski>   f . con0  =  con1 . fmap f
02:45:19 <Baughn> Still.
02:45:44 <Eduard_Munteanu> Baughn: http://en.wikipedia.org/wiki/F-algebra
02:46:06 <Baughn> Eduard_Munteanu: I can't read that, because I don't know what they mean by endofunctors
02:46:08 <ski> in the specific case where the first algebra is the initial algebra, we get
02:46:21 <Baughn> Eduard_Munteanu: And I can't read the endofunctor page, because etc.
02:46:30 <Eduard_Munteanu> Baughn: functors from a category to itself
02:46:31 <Eduard_Munteanu> Ah.
02:46:37 <Baughn> Eduard_Munteanu: Though I bet they'd be quite readable if put in terms of haskell types
02:46:55 <ciaranm> if you only put it in terms of haskell types you miss the point of it
02:47:01 <ski>   f . (\NilF -> Nil | (ConsF a as) -> Cons a as)  =  con1 . fmap f
02:47:08 <ski> which is the same as
02:47:34 <Baughn> ciaranm: I'm capable of generalizing later, but I can't /learn/ from the general case.
02:47:38 <ski>   f ((\NilF -> Nil | (ConsF a as) -> Cons a as) listf0)  =  con1 (fmap f listf0)
02:47:40 <Baughn> ..okay, I probably can, but I'd lack motivation.
02:47:58 <ski> `listf0' can be either of shape `NilF' or `ConsF a as', so this is the same as
02:48:09 <Baughn> ski: By the way, you lost me about a page back
02:48:11 <ski>   f ((\NilF -> Nil | (ConsF a as) -> Cons a as) NilF)  =  con1 (fmap f NilF)
02:48:14 <ciaranm> Baughn: that's a dangerous approach to take with category theory. if you think the general concept is anything like a few specific examples, you can go wildly wrong
02:48:22 <Twisol> Baughn: I'm with you on the general vs. specific issue
02:48:24 <ski>   f ((\NilF -> Nil | (ConsF a as) -> Cons a as) (ConsF a as))  =  con1 (fmap f (ConsF a as))
02:48:31 <ski> simplifies to
02:48:40 <Baughn> ciaranm: I didn't say I'd believe that, but having a specific case as scaffolding is useful.
02:48:41 <ski>   f Nil  =  con1 (fmap f NilF)
02:48:50 <ski>   f (Cons a as)  =  con1 (fmap f (ConsF a as))
02:48:52 <ski> simplifies to
02:49:00 <ski>   f Nil  =  con1 NilF
02:49:04 <Baughn> ciaranm: As it is, I don't see how to map that wikipedia page to haskell at all, and it's not obvious that that's possible, or useful.
02:49:09 <ski>   f (Cons a as)  =  con1 (ConsF (f a) as)
02:49:46 <ciaranm> Baughn: learn enough category theory (abstractly) that you can work out what a natural transformation is in haskell without anyone telling you. then you should be good to go.
02:49:56 <ski> and if we split `con1 :: ListF a r1 -> r1' into `(nil1,cons1) :: (r1,a -> r1 -> r1)' we get
02:50:02 <ski>   f Nil  =  nil1
02:50:05 <Baughn> ciaranm: And that would somehow help me?
02:50:13 <ski>   f (Cons a as)  =  cons1 (f a) as
02:50:15 <ciaranm> Baughn: it's the first step to enlightenment
02:50:25 <Baughn> ciaranm: Can't be bothered with enlightenment. :P
02:50:30 <Twisol> What's a good way to start learning category theory?
02:50:36 <ciaranm> Twisol: Awodey
02:50:37 <ski> um, actually the `f' is in the wrong place
02:50:39 <ski> it should be
02:50:40 <ski>   f Nil  =  nil1
02:50:45 <ski>   f (Cons a as)  =  cons1 a (f as)
02:50:48 <frerich> ciaranm: I hear writing jump'n'run games is actually another way to enlightement.
02:50:49 <ski> @src foldr
02:50:49 <lambdabot> foldr f z []     = z
02:50:50 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:50:59 <ski> my `f' is `foldr f z' above
02:51:01 <ciaranm> also "An introduction to (co)algebra and (co)induction"
02:51:06 <ski> my `nil1' is `z', and my `cons1' is `f'
02:51:14 <Twisol> ciaranm: what level of mathematical knowledge is required?
02:51:24 <Baughn> ciaranm: I've acquired some useful terms from general abstract nonsense, but category theory seems a step beyond that
02:51:28 <ski> Baughn : ok, sorry -- i'm a little bit tired atm :/
02:51:32 <ciaranm> Twisol:
02:51:34 <ciaranm> gah
02:51:38 <Twisol> :)
02:51:49 <ciaranm> Twisol: it helps if you know some algebra and some topology
02:51:56 <Baughn> ski: Don't worry about it.
02:51:57 <ciaranm> you definitely need set theory
02:52:07 <Twisol> ciaranm: going to assume you don't mean elementary algebra
02:52:09 <ciaranm> of the easy kind, not the lolinfinity kind
02:52:12 <Baughn> ski: Though FWIW, I think you may have written that upside-down. Start with specifics, don't end with them.
02:52:29 <ciaranm> Twisol: i mean you should know what a group homomorphism is
02:52:34 <ski> Baughn : if you remind me later, i could try going over it slower, and in more detail (and maybe when there's not so much other traffic, or in #haskell-overflow, or something)
02:53:13 <ski> Baughn : yeah, that's probably a consequence of me being tired, unable to think clearly
02:53:30 <Twisol> ciaranm: lets come at this from another angle. I have just completed my second semester of calculus. How difficult would it be to work through category theory from this level?
02:53:36 <Baughn> ski: If I remember.
02:53:42 <Baughn> Hm~
02:53:44 <burbul> I'm getting unwanted behaviour in a ErrorT String (WriterT [DerivationEntry] ... monad:
02:54:03 <burbul> Sometimes I want to write out some DerivationEntrys and then
02:54:10 <Twisol> ski: 'fore I forget, thanks for explaining the nondeterminism things earlier.
02:54:14 <burbul> fail to indicate that I'm not going to
02:54:20 <burbul> Actually return a meaningful value.
02:54:21 <Baughn> "Categories are composed of objects and arrows between objects; arrows can be composed associatively; all objects have a self-arrow" "In some specific categories, arrows are functions"
02:54:26 <ciaranm> Twisol: you should do some abstract algebra first. there's a book "Conceptual Mathematics" that does it without it, but it's a) annoyingly written and b) misleadingly Set-ish
02:54:31 <ski> Twisol : no degree in math (though i've taken a few math courses) -- i'm just generally interested in some math things, and have absorbed some knowledge
02:54:36 <Baughn> ..I take it that categories in which arrows are /not/ functions are not interesting for programming
02:54:39 <burbul> but calling fail *seems* to stop the WriterT tells from taking effect
02:54:41 <Twisol> ski: Ah, cool.
02:54:44 <burbul> Is this a laziness thing?
02:54:46 <ciaranm> Baughn: completely untrue
02:55:14 <Baughn> ciaranm: I mean, for describing programs
02:55:20 <ciaranm> Baughn: still completely untrue
02:55:21 <Baughn> As opposed to programs describing categories
02:55:36 <Baughn> ciaranm: ..okay, so what kind of program structure would be not-a-function?
02:55:40 <Twisol> would a monad transformer be an arrow that isn't a function?
02:55:49 <ski> Twisol : there's a nice paper by Bart Jacobs and someone more named something like "a tutorial to (co)induction and something" -- i think you can find a link to it on the WP page for coinduction -- this explains `F'-algebras and `F'-coalgebras, taking some CS examples
02:56:01 <Baughn> Twisol: No, those are functions from monads to monads
02:56:10 <ciaranm> Baughn: most of the good stuff comes from either categories from ordered sets, or categories with a small number of elements where the arrows are just arrows
02:56:14 <Twisol> hmm, k.
02:56:57 <ciaranm> Baughn: thinking of arrows as functions is one of those really bad "why you shouldn't learn from examples" things i mentioned before
02:57:33 <Baughn> ciaranm: Arrows are relations, not functions. I know that.
02:57:38 <ski> Baughn : you can have arrows from a specification of a module to a refined one which includes operations to be used for internal implementation details, e.g.
02:57:42 <ciaranm> Baughn: no. arrows are arrows.
02:58:41 <Twisol> *sigh* stuff like this defies definition, except in terms of their structure. At least as they seem to me.
02:58:43 <ski> "Documents as Categories" by William C. Wake in 1996-03-26 at <http://xp123.com/wwake/dissertation/model.shtml>
02:58:52 <Baughn> ciaranm: ..yes? That doesn't make them not relations between category objects.
02:58:52 <ski> "Categories for Software Engineering" by Jose Luiz Fiadero in 2004-10-18 at <http://homepage.mac.com/fiadeiroj/jose/CATBook/>
02:58:52 <ciaranm> Baughn: the category usually known as 2 is a good one to bear in mind. it has two objects and a one non-identitiy arrow, . -> .
02:58:55 <ski> "An Introduction to Category Theory for Software Engineers" by Steve Easterbrook in 1999 at <http://www.cs.toronto.edu/~sme/presentations/cat101.pdf>
02:58:56 <Twisol> probably one of the reasons monads are so flipping hard to understand
02:59:25 <Baughn> Twisol: Monads are simple enough. You don't need any of this, trust me.
02:59:27 <ski> s/Twisol/Baughn/
02:59:28 <ciaranm> monads are so flipping hard to understand because people insist upon talking about bind instead of join
02:59:30 <Gurrag> is there a list of those PDF links?
02:59:30 <t7> i wanna do something with opencyc :)
03:00:00 <ski> Baughn : the last two links above talks about using CT in software engineering, e.g. to talk about module specifications and implementations
03:00:12 <ciaranm> Baughn: 2 is a perfectly good, and extremely useful, example of a category. it's not some degenerate perverse case, either. it's absolutely critical to all the interesting stuff.
03:00:17 <Baughn> Twisol: Model monads as applicative functors plus join. :)
03:00:24 <Twisol> ciaranm: wasn't the flatten function a 'join' on lists?
03:00:31 <Baughn> Yep
03:00:34 <ciaranm> Twisol: yup
03:01:15 <Twisol> Baughn: About the only thing I feel like I have solidly is monoids. :P
03:01:17 <ciaranm> Twisol: from a category theory perspective, monads are usually defined in terms of what haskell would call fmap, pure and join, not bind
03:01:29 <ski> Baughn : arrows need not be relations.. however `Arrow' is (`Set'-valued, not truth-valued) relation between objects of the category, yes
03:01:40 <Twisol> ciaranm: Is that because Applicative came after Monad was originally in the language?
03:01:41 <ciaranm> and join is way easier to understand than bind
03:01:44 <ski> Baughn : where `Arrow' in `Hask' is the type constructor `(->)'
03:02:02 <ciaranm> Twisol: no, it's because when you *use* monads, bind is the operation you most often want
03:02:14 <Baughn> ski: Then you're using a different definition of "relation" than I am
03:02:47 <ski> Baughn : "sibling" e.g. is a relation
03:02:50 <Eduard_Munteanu> Baughn: they're not relations as in functions are relations. They're just "things" with a source and target.
03:02:57 <Twisol> currently, the extent of my understanding of applicatives is "oh hey, I can compose the result of this IO action with this function and have it still be an IO action in the end"
03:03:11 <Twisol> B.unpack <$> getContents being the exact example.
03:03:20 <Baughn> ski: I am pretty obviously not talking about genealogy?
03:03:32 <Eduard_Munteanu> Just like objects in a category aren't necessarily sets.
03:03:44 <ski> Baughn : consider the category where objects are natural numbers, and the unique (if any) morphism from `m' to `n' is the natural number `n - m'
03:04:00 <ski> Baughn : here the morphisms are natural numbers
03:04:18 <rtharper_> so 0 = id?
03:04:48 <Baughn> ski: Morphism? So what happened to the arrows?
03:04:55 <Eduard_Munteanu> Same thing.
03:05:09 <Eduard_Munteanu> But a more general notion than morphisms for e.g. rings.
03:05:18 <ski> Baughn : now take instead as morphisms from `m' to `n' any natural number `k' such that `n + k =< m' -- so now there's three (instead one one) arrow from `5' to `7' -- but the arrows are still natural numbers, not function, not relations
03:05:46 <ski> Baughn : in the first case, the composition `k . l' is simply `k + l'
03:05:56 <ski> i think that works in the second case as well
03:05:58 <Baughn> It was not obvious from the wikipedia page that arrows can also be objects in the same category
03:05:59 <Eduard_Munteanu> ski: technically you get equivalence classes on natural numbers, no?
03:06:08 <ski> the identity arrow is always `0' here
03:06:18 <Eduard_Munteanu> (since you can't say id_A = id_B = 0)
03:06:29 <t7> how do i build a game tree if the number of branches are super high
03:06:37 <ski> Eduard_Munteanu : why not ?
03:06:53 <t7> i need some kinda strong AI
03:06:53 <t7> maybe thats on hackage
03:07:05 <Eduard_Munteanu> ski: arrow equality should only be defined for compatible arrows, I think
03:07:08 <ski> Baughn : sorry, "morphism" is a synonym for "arrow"
03:07:29 <Baughn> t7: Oh dear, I hope not.
03:07:37 <ski> Eduard_Munteanu : it needs to be defined for compatible arrows -- whether it is defined for incompatible arrows is irrelevant
03:08:03 <ciaranm> an arrow "has" a domain and a codomain
03:08:08 <ciaranm> 0 doesn't
03:08:28 <ski> to talk about an arrow, you must already have decided on the domain and codomain of it
03:08:51 <ski> so you already have the domain and codomain specified
03:09:02 <ski> then you can say the arrow you're thinking of is `0'
03:09:19 <ciaranm> this is like saying that the function "x |-> x^2" is an arrow in Set, which it isn't
03:09:31 <ski> (imnsho, an arrow is not a triple of a domain, a codomain, and "the real arrow")
03:09:38 <Eduard_Munteanu> Mm, I'm a bit uncomfortable saying id_A = 0, id_B = 0 and concluding identity arrows for two different objects are equal. :/
03:10:14 <ski> ciaranm : "arrow in Set" is an undefined term, you have to say "is an arrow in Set from ... to ..."
03:10:22 <Eduard_Munteanu> So that's why I suggested talking about equivalence classes 0 = {0_A, 0_B, ...}
03:10:28 <ciaranm> ski: which is the point!
03:10:47 <ski> ciaranm : ok :)
03:11:06 <ciaranm> ski: so in your example, 0 isn't an arrow, and an identity arrow isn't 0
03:11:15 <Eduard_Munteanu> Actually there's a whole lot to define for a given category, not just arrows and objects, but arrow composition and equality too.
03:11:35 <ski> Eduard_Munteanu : now you're still thinking of these `0_A',`0_B',&c. as *inherently* having a domain and codomain -- they do not
03:12:11 <ski> ciaranm : yes, for every natural number `m', `0' is an arrow from `m' to `m'
03:12:37 <ski> and in the latter example above, for every pair of natural numbers `m' and `n', `0' is an arrow from `m' to `n'
03:12:50 <Eduard_Munteanu> ski: I'm not. I just have classes Ob(C) and Arr(C) (0 \in Arr(C)), but I don't want to be able to conclude incompatible arrows are equal somehow.
03:12:52 <ciaranm> ski: i object to your use of the word "is"
03:13:17 <ciaranm> ski: for every naturam number `m', there is an arrow from `m' to `m' given by `0'
03:13:30 <ski> Eduard_Munteanu : yes, your `Arr(C)' class is a clas of triples of domain,codomain and "the real arrow from the domain to the codomain"
03:13:45 <ski> Eduard_Munteanu : i want to talk about "the real arrows" only, not about the triples
03:15:01 <ski> Eduard_Munteanu : instead of saying "we have classes `Ob(C)' and `Arr(C)'", we should (imnsho) say "we have a class `Ob(C)', and for ever pair of elements `A' and `B' in `Ob(C)', a class `Arr(C,A,B)'"
03:15:11 <Eduard_Munteanu> ski: nope, 0 is exactly the natural 0. Then I say id_A corresponds to 0 and id_B to 0 too.
03:15:17 <ciaranm> you don't have "real arrows" in a category
03:15:24 <ciaranm> maybe you want an enriched category
03:15:57 <Eduard_Munteanu> Actually, Hom(A, A) is { 0 the natural }.
03:16:19 <ski> Eduard_Munteanu : i'm defining `Arr(C,m,n)' here as the set `{k : |N | m + k =< n}'
03:17:18 <ski> and so the natural number `0' is an element of every arrow class `Arr(C,m,n)'
03:17:37 <ciaranm> you can't do that!
03:17:43 <Eduard_Munteanu> ski: so you can't conclude every identity arrow is equal from that?
03:17:47 <ski> ciaranm : why not ?
03:18:07 <ski> Eduard_Munteanu : i don't understand the question
03:18:28 <ciaranm> ski: because there's no such thing as the "underlying blah" for an arrow
03:18:39 <ski> ciaranm : i agree
03:18:43 <Eduard_Munteanu> That is forall m n, Arr(C, m, m) = Arr(C, n, n) = { 0 }
03:19:16 <ski> Eduard_Munteanu : yes
03:19:34 <Eduard_Munteanu> So forall m n, id_m = id_n (since those always exist, I have to pick the identities as 0).
03:20:05 <ski> yes (i'm not sure what the parenthetical remark means)
03:20:23 <t7> o god i hate JS
03:20:35 <t7> i wish there was a decent haskell -> JS on windows
03:21:31 <ski> Eduard_Munteanu : anyway, yes `forall m n. id_m = id_n = 0' is true -- so what ?
03:21:45 <Eduard_Munteanu> ski: so I get at least two arrows with different sources and targets as equal. Can I also compose those incompatible arrows?
03:21:55 <ski> categorically, we only care about equality between parallel arrows anyway
03:22:18 <Eduard_Munteanu> e.g. id_A . id_B
03:22:39 <ski> (i.e. arrows that are *given* to us as being parallel, as opposed to ones which *happen* to be parallel "in the implementation")
03:22:39 <Eduard_Munteanu> I mean, it is a bit strange.
03:23:22 <ski> Eduard_Munteanu : the category structure only defined composition when the (given) domain of one arrow is equal to the (given) domain of the other
03:23:31 <Eduard_Munteanu> ski: also, surely one can talk about Dom(0) and Cod(0).
03:23:34 <ciaranm> i think the issue here is that ski thinks he's talking about a category where the objects and arrows "are" something, whereas me and Eduard_Munteanu are talking about a category where the objects and arrows "are defined by" something
03:23:36 <ski> we don't care if composition is / could be defined for other pairs of arrows
03:24:07 <ski> s/defined/defines/
03:24:32 <ski> Eduard_Munteanu : `Dom(f)' and `Cod(f)' is precisely what i want to ban :)
03:24:50 <Eduard_Munteanu> Oh, I'm okay with arrows "being" something. Just not something that lets me identify incompatible arrows (hence why I suggested arrows correspond to equivalence classes for n - m, rather than that exactly)
03:24:54 * hackagebot hscolour 1.20 - Colourise Haskell code.  http://hackage.haskell.org/package/hscolour-1.20 (MalcolmWallace)
03:25:17 <ski> (if you really want to talk about those, e.g. in internal categories, then you construct your triples of type `exists A : Ob(C). exists B : Ob(C). Arr(C,A,B)')
03:26:05 <ski> ciaranm : i'm not sure i understand the distinction you're after
03:26:56 <ski> Eduard_Munteanu : consider in Haskell `Nothing' vs. `False' -- it may happen that the implementation represents these two values in the same way -- but coding *in* Haskell, we shouldn't care about this
03:27:33 <Eduard_Munteanu> Yeah, but in Hask you can still distinguish those.
03:27:40 <ski> Eduard_Munteanu : similarly, it might be that `id_m' and `id_n' are represented as the same value (in the explicit construction of the category), but we shouldn't care, when we're working *in* the category
03:27:47 <ski> no you can't
03:27:53 <ski> > False == Nothing
03:27:54 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
03:27:54 <lambdabot>         against inferred type ...
03:28:07 <ski> the answer is not `False' or `True' (or `_|_')
03:28:14 <ski> it's simply an illformed expression
03:29:15 <Eduard_Munteanu> ski: there is an internal equality to Hask which lets you do that, not computably, but still.
03:29:45 <ski> that is irrelevant to working in `Hask', or writing and reasoning about programs in Haskell
03:29:47 <Eduard_Munteanu> I don't think a category is fully defined without some notion of telling which arrows are equal (including f . g = h stuff)
03:30:09 <ski> of course you have to define what it means for `f' and `g' to be equal
03:30:38 <ski> but you only have to be able to do this when you know that `f' and `g' has both been *given* to us as morphisms from a common domain `A' to a common codomain `B'
03:32:14 <ski> (so, when working *in* the category, we have to already decide on which `A' and `B' to use, before we can even talk about whether `f' and `g' might be equal)
03:32:26 <Eduard_Munteanu> Hm, so I guess the arrow equality over Hask could be totally different from propositional equality over Arr(C)?
03:32:44 <ski> of course, you *could* require one to be able to form the proposition `f = g' even for non-parallel arrows
03:32:48 <Eduard_Munteanu> Maybe trying to formalize that in Agda messed me up :)
03:32:49 <ski> but i see no use for this
03:33:43 <ski> Eduard_Munteanu : in my world, `Arr(C)' doesn't exist. `(A,B) |-> Arr(C,A,B)' exists :)
03:34:50 <ski> (btw, i'm open to arguments that the "allow considering whether non-parallel arrows are equal" position is useful -- but i haven't seen any convincing such arguments, yet)
03:37:09 <burbul> If I write 'tell ... >> fail "" ' in ErrorT String (WriterT ...), will the tell actually happen ?
03:37:43 <burbul> AFAICS it should...
03:37:47 <ski> @unmtl ErrorT String (WriterT Foo) a
03:37:48 <lambdabot> Plugin `unmtl' failed with: `WriterT Foo (Either String a)' is not applied to enough arguments, giving `/\A. Either String a (A, Foo)'
03:37:56 <ski> @unmtl ErrorT String (WriterT Foo m) a
03:37:57 <lambdabot> m (Either String a, Foo)
03:38:45 <hpc> you'll see (return ("", thatThingYouTold))
03:39:03 <burbul> ok -- thanks
03:39:12 <burbul> bug Must be somewhere else then
03:39:18 <hpc> er, Left ""
03:39:19 <ski> burbul : yes, even if the `Either String a' is `Left errMsg', you still get the element of type `foo'
03:39:36 <Eduard_Munteanu> ski: hm, right, I guess arrow equality could be defined on Hom(A, B) rather than Arr(C), and you could totally ignore propositional equality.
03:39:38 <ski> @unmtl WriterT Foo (ErrorT String m) a
03:39:38 <lambdabot> m (Either String (a, Foo))
03:39:41 <ski> is different
03:39:54 <ski> (here an exception throws away the log)
03:40:05 <Eduard_Munteanu> In fact, looking at my agda stuff, that's what I did :)
03:40:05 <burbul> yes -- I tried quite hard to pick the right one, but I just want to double check, because a lot of the tells aren't coming through for some reason.
03:40:10 <burbul> *wanted
03:40:20 <burbul> Thank you
03:40:30 <sheepz> scan func list = reverse $ foldl (\l e -> (func e (head l)) : l) [head list] (tail list) I found that this is how scan could be implemented using fold, can someone explain this?
03:40:31 <ski> Eduard_Munteanu : i'm not sure what you mean by "ignore propositional equality" ?
03:40:43 <ski> (Eduard_Munteanu : not surprising :)
03:41:08 <ski> burbul : `unmtl' does the trick :)
03:42:05 <ski> sheepz : itym `scanl1'
03:42:10 <Eduard_Munteanu> ski: the intensional equality on Arr(C), the "normal" equality.
03:42:33 <ski> sheepz : also, that doesn't work for infinite lists (while the usual `scanl1' does)
03:42:59 <Eduard_Munteanu> e.g. 0 = 0
03:43:04 <ski> Eduard_Munteanu : i don't see why one would be "propositional" (whatever you mean by that), but not the other
03:43:22 <Eduard_Munteanu> Propositional in the type-theoretic sense.
03:43:33 <ski> sheepz : consider :
03:43:54 <ski>      scan func (0:1:2:[])
03:44:43 <ski>   =  reverse (foldl (\l e -> func e (head l) : l) func [0] (1:2:[]))
03:44:47 <pooya72> is anyone else getting an error from pcre-light-0.4 when they are trying to install yesod? the error is:
03:44:47 <pooya72> Preprocessing library pcre-light-0.4...
03:44:47 <pooya72> Base.hsc:103:18: error: pcre.h: No such file or directory
03:44:47 <pooya72> Base.hsc: In function ‘main’:
03:44:56 <Eduard_Munteanu> ski: stuff you can prove equal by refl (or whatever you got in your theorem prover :D)
03:45:19 <ski>   =  reverse (foldl (\l e -> func e (head l) : l) func (func 1 0:[0]) (2:[]))
03:45:36 <ski>   =  reverse (foldl (\l e -> func e (head l) : l) func (func 2 (func 1 0);func 1 0:[0]) [])
03:45:53 <ski>   =  reverse (func 2 (func 1 0):func 1 0:[0])
03:46:07 <ski>   =  0 : func 1 0 : func 2 (func 1 0) : []
03:46:24 <ski> sheepz : does that explain how it works ?
03:46:45 <sheepz> ski: it think it should
03:46:47 <sheepz> thank you
03:47:23 <ski> Eduard_Munteanu : ok, you mean "identity/identicality", `data Identical {A : Set} (a : A) : A -> Set where Refl : Identical a a'
03:47:37 <ski> sheepz : now, consider what happens if you pass an infinite list
03:48:20 <ski> > scanl1 (+) [0 ..] :: [Expr]
03:48:21 <lambdabot>   [0,0 + 1,0 + 1 + 2,0 + 1 + 2 + 3,0 + 1 + 2 + 3 + 4,0 + 1 + 2 + 3 + 4 + 5,0 ...
03:48:39 <ski> sheepz : this is the standard `scanl1', but consider what your `scan' will do here
03:49:33 <ski> Eduard_Munteanu : so, by "non-propositional equality", do you mean any given equivalence relation ?
03:50:10 <Eduard_Munteanu> ski: yeah
03:50:24 <ski> (or maybe the "propositional" refers to that it's `A -> A -> Set' (or `A -> A -> Prop'), rather than `A -> A -> Bool' (or `A -> A -> Sierpinski') ?)
03:50:50 <Eduard_Munteanu> Identical is alright.
03:51:51 <pooya72> nevermind, I fixed it. I had to install pcre first. Good thing irc chats are logged :) : http://heavymetalab.appspot.com/browse/haskell/2012/5/9
03:51:59 <Eduard_Munteanu> While arrow equality would be : Hom a b -> Hom a b -> Set, or something like that.
03:53:14 <ski> (there's also `data LeibnizEquality {A : Set} (a0 : A) (a1 : A) : Set1 where Subst : ((F : A -> Set) -> (F a0 -> F a1)) -> LeibnizEquality a0 a1')
03:53:47 <ski> Eduard_Munteanu : yeah, or possibly s/Set/Prop/, if we don't care about *how* arrows are equal
03:54:07 <hpaste> “Eduard - Gabriel Munteanu” pasted “Categories” at http://hpaste.org/69186
03:54:41 <Eduard_Munteanu> ski: hm, actually, I think I can't really assign the same representative for an arrow
03:58:56 <burbul> In my ErrorT String (WriterT [DerivationEntry] ...) monad, I am getting different DerivationEntrys written when I replace a "fail" with a "return"
03:59:11 <burbul> Which makes me suspect that the fail is failing in something other than ErrorT.
03:59:15 <burbul> Is that possible?
03:59:43 <burbul> (I wouldn't have thought so, because I haven't lifted it, but I can't see any reason why changing fail<->return should affect what's written...)
04:01:54 <ClaudiusMaximus> :t throwError  -- wouldn't this be better than 'fail' ?
04:01:54 <ski> Eduard_Munteanu : hm, i don't see why you couldn't
04:01:55 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
04:02:25 <burbul> :t fail
04:02:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
04:02:28 <ski> ClaudiusMaximus : if you want to programatically catch the error, then usually yes
04:03:24 <burbul> I'm just trying that...
04:03:55 <burbul> no, throwError behaves like fail -- changing it to a return alters what's written
04:04:28 <burbul> I just don't get this.
04:04:49 <ClaudiusMaximus> so you have something like  do tell "a" ; fail "e" ; tell "b"  and s/fail/return/ makes the log say "ab" instead of "a" ?
04:05:15 <ski> hm, i suppose one could have a `data Error e a = Err (ErrMsg e) | Ok a' with `errMsg :: e -> ErrMsg e' and `getErrMsg :: ErrMsg e -> IO e'
04:05:24 <Eduard_Munteanu> ski: if Hom a a /= Hom b b, then I can't have an inhabitant of both. If Hom a a = Hom b b, then the arrow equivalence let's me compare them too
04:05:40 <ski> or maybe `forErrMsg :: ErrMsg e -> (e -> IO ()) -> IO ()' would be better, then we could allow `mergeErrMsg :: ErrMsg a -> ErrMsg a -> ErrMsg a'
04:06:03 <Eduard_Munteanu> *lets
04:06:14 <ski> burbul : what `throwError' does depends on which monad you use, yes
04:06:56 <ski> burbul : in some monads, it'll just behave like `fail'
04:07:02 <burbul> the complete monad is
04:07:30 <ski> Eduard_Munteanu : yes, but only if you know `Hom a a = Hom b b'
04:07:36 <burbul> ErrorT String (WriterT [DerivationEntry] (State NameCount a))
04:08:00 <opqdonut> am I somehow misusing iteratees here? http://hpaste.org/69188
04:08:20 <Eduard_Munteanu> ski: you would know that straight away if you define a category with Hom _ _ = |N
04:08:23 <burbul> I can't see how switching throwError <-> return can affect what happens in the WriterT
04:08:24 <ski> Eduard_Munteanu : if you declare `Hom' abstractly (or only expost the implementation in an "internal" submodule, e.g.), then you can't do this (without opening the "internal" one)
04:08:38 <Eduard_Munteanu> Hm.
04:08:40 <ski> (s/expost/expose/)
04:08:51 <womb> Hi guys!
04:08:52 <burbul> Could anyone have a look? http://hpaste.org/69187
04:08:55 <ski> hello womb
04:08:57 <Eduard_Munteanu> womb: hi
04:09:15 <ClaudiusMaximus> > runWriter $ do { tell "a" ; return "oops" ; tell "b" }
04:09:16 <lambdabot>   ((),"ab")
04:09:21 <ClaudiusMaximus> > runWriter $ do { tell "a" ; fail "oops" ; tell "b" }
04:09:22 <lambdabot>   ((),"a*Exception: oops
04:10:35 <ski> is that lazy or strict writer ?
04:10:53 <Eduard_Munteanu> Yeah, I guess that'd work.
04:11:21 <burbul> ahhhh.....
04:11:32 <burbul> So I need to switch to a strict writer?
04:11:55 <Eduard_Munteanu> Still, I'd probably just tag along an object (so you get different e.g. zeros), if I were to do that in Agda :)
04:12:19 <Eduard_Munteanu> (and you can get back a natural from that, if you want to)
04:12:54 <ski> > runIdentity . runErrorT . runWriterT $ do { tell "a" ; fail "oops" ; tell "b" } :: Either String ((),String)
04:12:56 <lambdabot>   Left "oops"
04:12:57 <ski> > runIdentity . runWriterT . runErrorT $ do { tell "a" ; fail "oops" ; tell "b" } :: (Either String (),String)
04:12:59 <lambdabot>   (Left "oops","a")
04:13:13 <ski> ClaudiusMaximus,burbul ^
04:13:57 <burbul> Is that a strict writer or a lazy writer? or does it not make any difference?
04:14:03 <burbul> *strict WriterT
04:14:08 <ski> the first is using `WriterT String (ErrorT String Identity)', the second `ErrorT String (WriterT String Identity)'
04:14:18 <ski> burbul : i'm not sure
04:14:22 <burbul> yes, I'm using ErrorT _  (WriterT _  Identity)'
04:14:33 <burbul> And still finding that the tell is not doing anything
04:17:23 <ski> burbul : well, for what `e' are you using `ErrorT e' ?
04:17:42 <ski> and how does the `instance Error e' look like, for that `e' ?
04:18:01 <ski> ok, `String' i see in your paste
04:19:12 * ski tries to recall where to see the source of `WriterT' and `ErrorT'
04:20:13 <ski> Eduard_Munteanu : i think it is needless to carry around that bulk -- it's a bit like every value in a dynamically checked language carrying around a tag that identifies what kind of value it is
04:21:04 <ski> it is conceptual baggage that is of no use (at least in most cases), and which just complicates your internal model
04:22:13 <Eduard_Munteanu> Yeah, though it's hard to tell what's the easiest approach with Agda :)
04:22:15 <gbqw435> Get ENDLESS gadgets on www.nycdental.us Come visit!
04:22:30 <Eduard_Munteanu> @where ops
04:22:31 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
04:22:46 <gbqw435> Get ENDLESS gadgets on www.nycdental.us Come visit!
04:22:47 <gbqw435> Get ENDLESS gadgets on www.nycdental.us Come visit!
04:22:47 <gbqw435> Get ENDLESS gadgets on www.nycdental.us Come visit!
04:22:47 <gbqw435> Get ENDLESS gadgets on www.nycdental.us Come visit!
04:22:48 --- mode: ChanServ set +o mauke
04:23:00 * ski . o O ( `anacron -ndq anachron' )
04:23:13 <Eduard_Munteanu> Actually, I might take this with Freenode staff.
04:23:55 <Eduard_Munteanu> Ah, good.
04:24:22 <quicksilver> surely repeating the post doesn't make you more likely to get clicked
04:24:31 <quicksilver> but makes you *much* more likely to be picked up by automatic spam monitors.
04:24:37 <quicksilver> breaking news: spammers are stupid.
04:24:48 --- mode: mauke set -o mauke
04:24:59 <mm_freak> IRC spammers tend to be stupid
04:25:13 * ski idly wonders whether this is a nice new dentist, *click*
04:25:39 <pooya72> hi, so how do you fix ghc errors such as "package HDBC-2.3.1.1-ba50fe98e02142c4c03f268cdb6df66b is unusable due to missing or recursive dependencies:
04:25:39 <pooya72>   convertible-1.0.11.1-dac7ee73b3a9a06449dae70b4586f9c5 text-0.11.1.5-cfeb4462e4827329a7664f98c088eaf8
04:25:39 <pooya72> package HDBC-postgresql-2.3.2.1-7f5f48270056faeceffa0ee7b2a5cf98 is unusable due to missing or recursive dependencies:
04:25:40 <pooya72>   HDBC-2.3.1.1-ba50fe98e02142c4c03f268cdb6df66b convertible-1.0.11.1-dac7ee73b3a9a06449dae70b4586f9c5"
04:26:13 <pooya72> HDBC-postrgesql was working fine, but i installed yesod, don't know if that broke anyting
04:30:34 <Raydiation> are there any resources that compare OOP and functional programming? like side by side examples that show how one would solve it in haskell`
04:30:34 <Raydiation> compared to examples in oop
04:30:42 <Raydiation> its kinda hard to get the concepts into my head
04:31:51 <koala_man> there are probably some sites that compare procedural vs functional, but OOP usually doesn't come into play until your app is longer than a snippet
04:32:00 <adamt> Raydiation: You could also try asking for clarifications here. :)
04:32:49 <merijn> Raydiation: I mostly just played around and asked for suggestions here :p
04:33:38 <merijn> Cale had this nice OO haskell example which I thought was interesting, but I can't find it right now
04:33:48 <irene-knapp1> well, but you can reduce a real case to a snippet; it's just that doing so removes the motivation for how it was implemented and you have to trust that the author actually had a good one
04:33:56 <quicksilver> Raydiation: the hard thing about that comparison is that "Everything is an object" is used as an unconditional mantra
04:34:01 <quicksilver> (in OOP circles)
04:34:11 <quicksilver> so objects are used as a universal abstraction for any layer of complexity
04:34:23 <irene-knapp1> yeah.  whereas there are at least a few things that GHC doesn't consider to be functions.  (the number 5, for example…. hahaha)
04:34:35 <quicksilver> so in idiomatic functional programming, you don't replace all objects the same way
04:34:40 <quicksilver> it depends what they were for.
04:34:46 <merijn> I like the description "value oriented programming"/"data structure oriented programming" rather than functional programming
04:35:01 <quicksilver> you might replace some classes by types, but other classes by modules
04:35:11 <quicksilver> (which are just groups of related functions of course0
04:35:11 <merijn> Because that's what it usually feels like when I write haskell/functional stuff
04:35:17 <irene-knapp1> that's an interesting one
04:35:39 <irene-knapp1> well, data structures plus algorithms equals programs, as we know, hahaha
04:35:58 <irene-knapp1> (I think that was Wirth?)
04:36:25 <merijn> I usually first design my data structures, then figure out the types of operations I want to perform and only *then* I figure out how to write functions belonging to the types I came up with
04:36:26 <Raydiation> adamt: im planning to learn it, i dont have the time (this month) so ill start next month ;) i just felt like asking for good resources
04:36:40 <irene-knapp1> I actually sometimes figure out types first
04:36:55 <irene-knapp1> since that can inform the choice of an appropriate structure
04:36:55 <merijn> Raydiation: I would say the best resource is to not think about comparing it to OO, as down that road lies confusion
04:36:59 <burbul> @src traceShow
04:37:00 <lambdabot> Source not found. :(
04:37:49 <merijn> Raydiation: Just starting "from scratch" rather than assuming you already know how to program is the easiest approach
04:38:05 <ski> <http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue3/Functional_Programming_vs_Object_Oriented_Programming>
04:38:08 <ski> <http://www.haskell.org/haskellwiki/OOP_vs_type_classes>
04:38:09 <merijn> As for resources, Learn You a Haskell and Real World Haskell are excellent and free (I would recommend starting with the former)
04:38:18 <ski> those aren't Cale's one, but might be interesting, still
04:39:18 <ski> merijn : "expressive programming" ?
04:39:30 <merijn> ski: Sounds a bit vague
04:40:27 <irene-knapp1> code-oriented programming :D
04:40:38 <ski> @where LYAH
04:40:38 <lambdabot> http://www.learnyouahaskell.com/
04:40:39 <merijn> programming-oriented programming!
04:40:40 <ski> @where RWH
04:40:40 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
04:40:48 <Raydiation> merijn: yeah i got the learn you a haskell book at home :) and its hard to switch those burnt in ways how you solve stuff, i guess i know too much oop languages
04:41:02 <merijn> (Or "Programming, motherfucker!")
04:41:05 <ski> (merijn : "expressive" of course coming from "expression" :)
04:41:17 <quicksilver> Raydiation: ski's second link (OOP_vs_type_classes) looks like what you wanted
04:41:19 <quicksilver> in part, at least
04:41:36 <ciaranm> oop and functional aren't mutually exclusive
04:41:49 <chridi> hmh.. i just did a few lines of happstack-lite...
04:41:52 <ciaranm> it's unlearning the procedural stuff that's the issue usually
04:41:59 <chridi> now i want to store some informations.. should I use STM or something else?
04:42:05 <quicksilver> hmm it gets less good around 3.1
04:42:14 <quicksilver> "Type classes are like interfaces/abstract classes, not classes itself"
04:42:14 <merijn> STM is completely unrelated to storing information
04:42:18 <Raydiation> ski: quicksilver: ty
04:42:23 <quicksilver> no they're not. Please wash your mouth out, wiki author.
04:42:23 <ski> yw
04:42:43 <chridi> well.. its memory
04:42:43 <ski> quicksilver : they're *more* like the former than the latter, though
04:42:43 <chridi> ;)
04:42:59 <hpc> quicksilver: type classes are like quesadillas...
04:43:01 * ski . o O ( "more tea, anyone ?" )
04:43:04 <merijn> chridi: Doesn't happstack use acid-state for storing data?
04:43:38 <merijn> quicksilver: I always thought people complaining about that comparison were overthinking the analogy
04:43:51 <quicksilver> ski: yes, it is. broken glass is more like cornflakes than like oranges
04:44:05 * ski nods solemnly
04:44:07 <merijn> I've always found it a perfectly fine analogy when I started learning and I still think so
04:44:24 <quicksilver> ski: but nonetheless you should not consider broken glass a good substitute for cornflakes in most circumstances.
04:44:40 <quicksilver> merijn: I complaing about it because I fear it will cause other people to over think the analogy.
04:44:45 <ski> (saying they're "like" foo isn't the same as saying they're exactly like foo)
04:44:51 <merijn> quicksilver: "are like" doesn't mean "substitute for" in my world
04:45:09 <pooya72> so do hackage packages break each other often?
04:45:20 <quicksilver> merijn: no, it doesn't, but if that approach causes people to consider using typeclasses in haskell when they would have used an interface in java, then it is a very poor teaching tool.
04:45:35 <quicksilver> merijn: because that is very rarely what you want to do.
04:45:57 * merijn was never really a java programmer so doesn't even know what a Java interface entails
04:45:58 <ski> quicksilver : i think your fear it probably well-founded in several cases, but i still think it's a useful starting analogy, when learning
04:46:03 <ski> s/it/is/
04:46:04 <earthy> I think it goes better the other way around
04:46:11 <quicksilver> so my criticism of it is that I believe it is a bad scaffolding on which to base learning.
04:46:22 <earthy> when you think about using in Interface in java where you would have used a typeclass in haskell
04:46:39 <ciaranm> analogies are bad for learning. start with the most abstract definition.
04:46:52 <quicksilver> "bad for learning" is subjective.
04:47:04 <quicksilver> good analogies are an excellent way for many people to learn
04:47:23 <quicksilver> and category theory is the branch of mathmetics concerned with formalising the notion of "good analogy"
04:47:30 <earthy> ciaranm: abstractions are useless if you don't understand what the abstractions abstract from
04:47:44 <quicksilver> earthy: that is also subjective.
04:47:54 <quicksilver> some people learn well abstractly.
04:48:08 <quicksilver> (personally, I'm one of those who does not learn well abstractly, though)
04:48:37 <earthy> I've yet to meet someone who is not helped by showing a concrete exmaple of an abstraction
04:49:02 <sopvop> #haskell, I'm in dire need of your help. I have a applicative functor, and want to supply it values from another applicative functor, IO. How one does it?
04:49:49 <ciaranm> sopvop: one doesn't
04:49:55 <ski> (i read Grothendieck is good at doing it abstractly from the start)
04:49:57 <sopvop> :(
04:50:46 <ciaranm> earthy: the objection is not to showing concrete examples to illustrate a definition. it's to using an analogy.
04:50:57 <ski> sopvop : you can combine `Foo (a -> b)' with `Foo a' to get `Foo b', but you can't combine `a -> Foo b' with `Foo a' to get `Foo b', if `Foo' is only an applicative functor (but not a monad)
04:51:02 <quicksilver> ciaranm: they are quite closely related though.
04:51:07 <Raydiation> oh, real world haskell is awesome http://book.realworldhaskell.org/read/writing-a-library-working-with-json-data.html
04:51:25 <ski> sopvop : if the applicative functor is also a monad, like `()', you can use `(=<<)' or `(>>=)', e.g.
04:51:46 <earthy> ciaranm: ah
04:51:54 <earthy> yes, analogies are dangerous
04:52:03 <earthy> they're the fabled leaky abstractions
04:52:15 <quicksilver> ciaranm: linear maps between vector spaces are like homomorphisms between groups" is an analogy
04:52:17 <ski> allegories are better
04:52:35 <quicksilver> and it contains useful content for people familar with one of those but not the other.
04:52:40 * ski . o O ( "Categories, Allegories", Freyd, et al. )
04:52:55 <ski> (hm , `Scedrov', iirc)
04:53:01 <quicksilver> "python generators are like haskell list comprehensions" is another
04:53:14 <quicksilver> (which I can't judge the quality of, because I'm python-illiterate)
04:53:18 <ciaranm> except that python generators aren't like haskell list comprehensions
04:53:26 <quicksilver> but such comparison are, I think, very helpful when they're correct.
04:53:29 <quicksilver> and very unhelpful when they're wrong.
04:53:41 <quicksilver> so "good analogies" are helpful and bad ones, obviously, are not.
04:54:05 <quicksilver> "haskell typeclasses are like Java interfaces", in my opinion, is of the latter sort.
04:54:29 <sopvop> ski: I've spend half a day trying to figure it out. Should have asked it here first. Thanks.
04:54:35 <mm_freak> haskell type classes are like implicit arguments
04:54:46 <ski> sopvop : got it working ?
04:55:01 <sopvop> Nope, my functor is not a monad
04:55:03 <Philonous> quicksilver:  I think python generators are coprocedures, not codata.
04:55:08 <ski> ok
04:55:31 <quicksilver> Philonous: I have no reason to doubt you, as I say, I'm python illiterate.
04:55:55 <quicksilver> if my second analogy turned out to be way off-base then, I think, that made my point anyway :)
04:56:08 <ski> sopvop : maybe there's a way you can restructure your code to do what you want -- and/or maybe you could modify your type to be a monad
05:00:52 <Philonous> quicksilver:  I find it striking how many of those "helpful", "intuitive" analogies turn out to be harmful. Even if the similarities are real (but not total) they still seem to hinder understanding because the learner thinks he understands something when he doesn't.
05:01:17 <sopvop> Well, it should be simple. return = pure and >>= = fmap. But I've heard not all applicatives are monads
05:01:24 <quicksilver> you might be right, Philonous.
05:01:32 <ciaranm> >>= and fmap are two different things
05:01:51 <quicksilver> Philonous: ideally they come with an example of how far the analogy stretces and a counterexample of where it fails, I guess.
05:01:58 <ciaranm> also, if you're trying to work out whether or not something is a monad, join is probably easier to work with than nomd
05:02:01 <ciaranm> nomd? bind
05:03:05 <ski>   fmap  :: Functor     f =>   (a ->   b) -> (f a -> f b)
05:03:06 <hpaste> sopvop pasted “is this a monad?” at http://hpaste.org/69191
05:03:08 <ciaranm> analogies are what people use when they don't want to admit that they're just too dumb to be able to do CS, which is just maths
05:03:09 <ski>   (<*>) :: Applicative i => i (a ->   b) -> (i a -> i b)  (=<<) :: Monad
05:03:18 <ski>   (<*>) :: Applicative i => i (a ->   b) -> (i a -> i b)
05:03:18 <ski>   (=<<) :: Monad       m =>   (a -> m b) -> (m a -> m b)
05:03:39 <ski> (s/  (=<<) :: Monad$//)
05:03:44 <merijn> ciaranm: I disagree
05:03:52 <ski> sopvop : compate the three operations above, all different
05:03:56 <merijn> It is helpful to have analogies to generalise from
05:04:12 <ciaranm> the definition is the generality
05:04:48 <ciaranm> sopvop: looks a lot like that's a monad in the same way that Maybe and Either are
05:04:53 <ski> ciaranm : ah, you just coined the warm and fuzzy replacement name for "bind" :)
05:05:08 <ciaranm> heh
05:05:09 <sopvop> It's pretty much either with monoid in Left.
05:05:28 <merijn> ciaranm: No one learns thing by definition, not even mathematicians
05:05:35 <merijn> I'm reminded of this quote: http://hpaste.org/69192
05:05:45 <ciaranm> merijn: no, you learn by definition, example, example, example
05:06:18 <burbul> > runIdentity . runWriterT . runErrorT $ do { tell "a" ; fail "oops" ; tell "b" } :: (Either String (),String)
05:06:19 <lambdabot>   (Left "oops","a")
05:06:23 <merijn> Example, example, example, definition works just as well
05:06:33 <ciaranm> merijn: also, that quote is a prime example of reasoning by faulty analogy
05:06:49 <burbul> I think I know why I'm hitting a bug... I want something that is like the above but where the "tell b" works even after a fail.
05:06:55 <burbul> Is that a coherent concept?
05:07:01 <ciaranm> merijn: it's falsely suggesting that mathematical definitions are like definitions of animals
05:07:41 <ski> burbul : hm, sounds strange
05:07:47 <merijn> ciaranm: I disagree with you statement that they're different. You're gonna need a better argument than "they're not similar" to convince me
05:07:59 <ciaranm> merijn: mathematical definitions are not fuzzy
05:08:07 <burbul> I know it sounds strange, but it's what I need...
05:08:08 <merijn> Ha
05:08:13 <sopvop> So, If I make it into a monad. To use it with IO, do I need to make it an instance of monad transformer?
05:08:20 <burbul> Problem was that I'm computing a value from a bunch of children (themselves recursively computed)
05:08:26 <ciaranm> merijn: a mathematical definition is simply a short-hand way of expressing a statement built up from some axioms
05:08:30 <ski> burbul : the point of `ErrorT' here is to *abort* the rest of the computation, so that any `WriterT'-effects in it won't happen
05:08:45 <merijn> The axioms can still be fuzzy
05:09:00 <ciaranm> then they're bad axioms
05:09:05 <burbul> and I wanted to record certain info for any children that *might* be accessed, even if short-circuiting means that they aren't accessed
05:09:10 <merijn> But anyhoo, that's not a discussion I have time for now, so back to work
05:09:16 <merijn> ciaranm: There are no unfuzzy axioms
05:09:37 <merijn> But as I said, maybe another time :)
05:09:38 <arnsholt> I think most people doing research on didactics and mathematics agree that the abstract understanding only comes after some time
05:09:57 <Philonous> merijn:  Good analogies are hard to come by and bad ones hurt a lot. "A cat is like a dog that goes 'purr'" contains negative information.
05:10:49 <ciaranm> arnsholt: there's no such thing as "abstract understanding" of inherently abstract concepts. there is simply "understanding" or "not understanding".
05:12:02 <ski> burbul : we basically have `ErrorT mea >>= aEmb = ErrorT (do ea <- mea; case ea of Left errMsg -> return (Left errMsg); Right a -> runErrorT (aEmb a))', meaning that when we reach something that throws an exception, the rest of the computation `aEmb' is discarded
05:12:32 <burbul> I know
05:12:37 <ski> burbul : if you don't want to discard it in the `Left' case, then you must pass it a fake `a' argument, and hope it doesn't look at it (too soon)
05:12:37 <burbul> Problem is I need something with a different behaviour
05:13:01 <burbul> At the moment the best thing I can think of doing is using
05:13:10 <ski> burbul : you could attempt defining a monad which worked like this .. i'm not sure whether it would satisfy the monad laws, though
05:13:34 <burbul> (WriterT [DerivationEntry] NumberingM) (Either String a)
05:13:36 <burbul> Instead of
05:13:45 <burbul> ErrorT String (WriterT [DerivationEntry] NumberingM) a
05:14:28 <burbul> But then I have to manually combine all of the (Either String a)s...
05:15:52 <arnsholt> ciaranm: I don't think that's true. Metaphor and analogy are pretty much fundamentals of human reasoning. Abstract reasoning doesn't come naturally (without the famed 10000 hours at least)
05:16:28 <ciaranm> arnsholt: maths doesn't come naturally either
05:17:37 <arnsholt> Yeah, which is why we usually start with a fuzzy understanding of the concepts
05:18:16 <ski>   LazyErrorT mea >>= aEmb = LazyErrorT (do ea <- mea; case ea of LazyLeft errMsg -> do {aEmb (error "non-lazy !"); return (Left errMsg)}; Right a -> runLazyErrorT (aEmb a))
05:18:24 <ski> burbul : something like that, i think
05:18:43 <burbul> I had to take some time to absorb that. Thank you!
05:18:47 <burbul> *I'll have to
05:18:53 <ski> (i'm not completely sure whether `LazyErrorT' is a good name for this)
05:18:56 <ciaranm> arnsholt: but we're not doing fuzzy. we're doing maths.
05:19:15 <ski> burbul : also, since we're in unknown territory here, we really should check the monad laws
05:21:03 <ski> burbul : if the computation tries to look at the `a' when there isn't any (because the previous computation raised an exception), you'll get an `error' call aborting the program
05:21:11 <burbul> I think I need to take some time to think hard about this!
05:21:21 <burbul> But thank you very much for constructing it for me.
05:21:23 <ski> well, let's define return
05:21:38 <ski>   return a = LazyErrorT (return (Right a))
05:22:09 <ski> ok, `return a >>= amb = amb' holds
05:22:49 <ski> and `ma >>= return = ma' also holds
05:23:21 <ski> so, how about `(ma >>= amb) >>= bmc = ma >>= \a -> amb a >>= bmc' ?
05:25:06 <burbul> Are we going to have to work through the left/right cases?
05:25:17 <ski> yes
05:25:29 <ciaranm> *cough*definejoinandcheckthelawsthatway*cough*
05:25:40 <ski> i think the associative law holds as well
05:25:53 <ski> but it would be best to do it explicitly, writing it down
05:25:57 * ski is a bit tired atm
05:26:02 <burbul> don't worry
05:26:21 <burbul> I'll wade through it myself and come back if I have problems
05:26:25 <ion> ski: That’s understandable, you’ve been handing out cash all day.
05:26:30 <burbul> I'm very grateful for the help!
05:26:33 <ski> if there's any exception-monad related laws which you want / rely on, you should check those as well
05:26:46 <burbul> Where would I find a list of such laws?
05:26:57 <ski> e.g. something like `throwError e >>_ = throwError e' is probably not going to hold, here
05:27:17 <ski> but if you don't implement `MonadError', that possibly wouldn't be a problem
05:27:26 <ski> er, s/>>/>>=/
05:28:12 <ski> burbul : hm, i'm not sure -- maybe in the packages describing the monads ?
05:28:24 <ski> @wiki Monadplus reform proposal
05:28:24 <lambdabot> http://www.haskell.org/haskellwiki/Monadplus_reform_proposal
05:28:26 <ski> @wiki Monadplus
05:28:27 <lambdabot> http://www.haskell.org/haskellwiki/Monadplus
05:28:43 <ski> lists some `MonadPlus' related laws
05:28:50 <burbul> thanks!
05:29:01 <ski> for `MonadError', `throwError foo' should be mostly similar to `mzero'
05:29:50 <ski> hm .. and i suppose since this is a monad, not an applicative functor, we can't really expect exception concatenation here
05:30:22 <ski> (burbul : maybe s/Monadplus/MonadPlus/ above, i don't recall)
05:30:50 <ski> then, you'd want some laws for `catchError'
05:30:55 <ski> @hoogle catchError
05:30:55 <lambdabot> Control.Monad.Trans.Error catchError :: (Monad m, Error e) => ErrorT e m a -> (e -> ErrorT e m a) -> ErrorT e m a
05:30:55 <lambdabot> Control.Monad.Error.Class catchError :: MonadError e m => m a -> (e -> m a) -> m a
05:30:55 <lambdabot> Control.Monad.Error catchError :: MonadError e m => m a -> (e -> m a) -> m a
05:31:00 <ski> e.g.
05:31:21 <ski>   catchError (throwError err) err_mb = err_mb err
05:31:32 <burbul> After thinking for a minute, I think I can get away with just the monad laws
05:31:39 <ski> but you'd also want some kind of distributivity law with `(>>=)'
05:32:53 <quicksilver> ciaranm: I use analogies and I respectfully submit that I'm not too dumb to do CS.
05:32:59 <quicksilver> I concede I am biased and may be wrong.
05:35:33 <ski>   catchError (ma >>= amb) err_mb = catchError (liftM Right ma) (liftM Left . err_mb) >>= \eb -> case eb of Left b -> return b; Right a -> catchError (amb a) err_mb
05:35:37 <ski> a bit ugly ..
05:35:52 <ski> i think it'd probably look nicer, using
05:36:01 <jjl_> 1
05:36:41 <ski>   catchBindError :: MonadError e m => m a -> (e -> m b) -> (a -> m b) -> m b
05:38:20 <ski>   catchBindError ma err_mb a_mb = catchError (liftM Right ma) (liftM Left . err_mb) >>= \ba -> case ba of Left b -> return b; Right a -> a_mb a
05:38:23 <ski> alternatively
05:38:48 <ski>   catchBindError ma err_mb a_mb = catchError (liftM Right ma) (liftM Left) >>= either err_mb a_mb
05:38:55 <ski> so, we get, hm
05:40:22 <ski>   catchBindError (ma >>= a_mb) err_mc b_mc = catchBindError ma err_mc (\a -> catchBindError (a_mb a) err_mc b_mc)
05:40:26 <ski> much nicer :)
05:41:15 <ski> burbul : ok
05:42:00 <t7> how do i purely functional perlin noise?
05:42:00 <ski> burbul : considering this second law above (relating `catchError'/`catchBindError' with `(>>=)'), i think you *don't* want this law holding here
05:42:58 <ski> burbul : and, afaics, this is a reasonable law for `MonadError', which would then mean that you oughtn't instantiate that class
05:43:43 <burbul> ski: sorry, I was walking around the room thinking. I was a bit scared by the 'Bottom' floating around.
05:43:49 <burbul> It occurred to me that I could do the following:
05:43:52 <ski> (hm, s/catchBindError/catchErrorBind/ seems like a better name)
05:43:58 <burbul> Inside the do block in the
05:44:02 <ski> burbul : `Bottom' ?
05:44:26 <burbul> um -- undefined
05:44:28 <ski> (oh, the `error "non-lazy !" ?)
05:44:29 <burbul> error s
05:44:30 <ski> ok
05:45:04 <burbul> I was trying to figure out whether inside the do block in the original ErrorT String (WriterT [DerivationEntry] NumberingM) monad I could
05:45:35 <burbul> use runErrorT to get back all the bits and pieces I needed as (Either err, vals)
05:45:39 <ski> > mfix (`seq` Nothing)
05:45:40 <ski> > mfix (`seq` [])
05:45:43 <lambdabot>   mueval-core: Time limit exceeded
05:45:44 <lambdabot>   mueval-core: Time limit exceeded
05:46:03 <ski> (hm, i was thinking those would give an error, or pattern-match failure, but apparently they don't)
05:46:10 <burbul> And then work with that.
05:46:30 <burbul> Eventually producing another Either which was the return value
05:46:38 <burbul> and going back into the ErrorT String (WriterT [DerivationEntry] NumberingM) monad
05:46:43 <ski> mhm
05:46:53 <burbul> This is really my first experiment with monad Transformers, so I think I'm going to have to take a lot of time to think --
05:47:02 <ski> sure, take your time
05:47:06 <burbul> Please don't spend a lot of effort on it!  You've done more than enough already.
05:47:34 <burbul> right -- thanks again.
05:47:56 <ski> yw
05:51:19 <ski>   catchErrorBind (catchErrorBind ma err_mb a_mb) err_mc b_mc  =  catchErrorBind ma (\err -> catchErrorBind (err_mb err) err_mc b_mc) (\a -> catchErrorBind (a_mb a) err_mc b_mc)
05:51:37 <ski> is yet another sensible-looking law for `MonadError'
05:54:32 <ski> @hoogle MonadError e m => m a -> (e -> m b) -> (a -> m b) -> m b
05:54:32 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
05:54:33 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
05:54:33 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
05:54:37 <ski> @hoogle+
05:54:37 <lambdabot> Control.Exception.Base bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
05:54:37 <lambdabot> Control.Exception bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
05:54:37 <lambdabot> Control.OldException bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
05:54:49 <mm_freak> > mfix (const Nothing)
05:54:50 <lambdabot>   Nothing
05:55:14 <t7> how is there no instance of Random for Word8 :(
05:55:50 <ski> > map (take 10) (mfix $ \ns -> do n <- [0,1]; return (n:ns))
05:55:51 <lambdabot>   [[0,0,0,0,0,0,0,0,0,0],[1,1,1,1,1,1,1,1,1,1]]
05:56:30 <ski> > fmap (take 10) (mfix $ \ns -> do n <- Nothing; return (n:ns))
05:56:31 <lambdabot>   Nothing
05:56:31 <tgeeky> t7: there is an instance of Arbitrary: http://hackage.haskell.org/packages/archive/QuickCheck/2.4.2/doc/html/Test-QuickCheck-Arbitrary.html
05:56:38 <tgeeky> t7: which may be "just as good"
05:56:48 <mm_freak> > mfix (`seq` Nothing)
05:56:51 <mm_freak> this one is weird
05:56:52 <lambdabot>   mueval-core: Time limit exceeded
05:57:03 <ski> @src Maybe mfix
05:57:03 <lambdabot> mfix f = let a = f (unJust a) in a where unJust (Just x) = x
05:57:03 <mm_freak> i'd also expect it to pattern-match-fail
05:57:17 <ski> i suppose it cycles instead
05:57:29 <mm_freak> oh yes, of course
05:57:39 <mm_freak> in order to pattern match it wants the result of 'f'
05:57:43 <aristid> @src [] mfix
05:57:43 <lambdabot> mfix f = case fix (f . head) of
05:57:44 <lambdabot>            []    -> []
05:57:44 <lambdabot>            (x:_) -> x : mfix (tail . f)
05:57:50 <mm_freak> that one does the same
05:57:51 <mm_freak> over and over
05:58:07 <mm_freak> so it actually makes sense
05:58:10 <ski> and for `[]', we have `head' there, serving the same purpose
05:58:46 <mm_freak> i don't understand the instance for lists
05:58:57 <mm_freak> > mfix (\x -> [x, x])
05:59:01 <lambdabot>   mueval-core: Time limit exceeded
05:59:01 <aristid> mm_freak: phew, so i'm not alone
05:59:32 <ski> > map (take 4) (mfix (\ns -> [0:ns,1:ns]))
05:59:34 <lambdabot>   [[0,0,0,0],[1,1,1,1]]
05:59:57 <ski> > map (take 4) (mfix (\ns -> do n <- [2,3]; [n:0:ns,n:1:ns]))
05:59:58 <lambdabot>   [[2,0,2,0],[2,1,2,1],[3,0,3,0],[3,1,3,1]]
06:00:16 <aristid> > mfix $ const Nothing
06:00:16 <lambdabot>   Nothing
06:00:38 <mekeor> > mfix $ flip const Nothing
06:00:39 <lambdabot>   Occurs check: cannot construct the infinite type: a = m a
06:01:16 <Axman> :t mfix\
06:01:18 <lambdabot> parse error on input `\'
06:01:18 <Axman> :t mfix
06:01:20 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
06:02:55 <mm_freak> i don't really get the semantics of mfix for lists
06:03:15 <mm_freak> it feeds the head of the result back?
06:03:33 <t7> @hoogle (a -> a) -> a -> [a]
06:03:34 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
06:03:34 <lambdabot> Data.List iterate :: (a -> a) -> a -> [a]
06:03:34 <lambdabot> Data.Generics.Schemes everywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
06:03:51 <t7> > take 5 $ iterate (/ 2) 100
06:03:52 <lambdabot>   [100.0,50.0,25.0,12.5,6.25]
06:04:39 <mm_freak> > map (take 3) . iterate (drop 3) $ [1..]
06:04:41 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23...
06:05:05 <t7> @hoogle iterateWhile
06:05:05 <lambdabot> No results found
06:05:20 <mm_freak> > map (take 10) . transpose . map (take 3) . iterate (drop 3) $ [1..]
06:05:24 <lambdabot>   mueval-core: Time limit exceeded
06:05:28 <mm_freak> huh?
06:05:39 <mm_freak> > transpose . map (take 3) . iterate (drop 3) $ [1..]
06:05:41 <lambdabot>   [[1,4,7,10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,55,58,61,64,67,70,73,7...
06:05:49 <mm_freak> > map (take 10) . transpose . map (take 3) . iterate (drop 3) $ [1..]
06:05:53 <lambdabot>   mueval-core: Time limit exceeded
06:06:03 <mm_freak> why does that loop on lambdabot?
06:06:18 <mm_freak> ah
06:06:20 <mm_freak> got it
06:09:30 <int-e> mm_freak: let me guess: prepend a 'take 3' and everything works as expected?
06:09:30 <hughfdjackson> mm_freak: where's transpose from?
06:09:51 <hughfdjackson> :/ i think i'm being ultimately daft
06:10:17 <hughfdjackson> aha, Data.List..
06:10:50 <t7> whats the best package for simple image manipulation? (i need to scale)
06:24:49 <sopvop> ski: I've reworked my type into proper monad, and also made monatT for it. It works now, and code looks nice. Thanks for help
06:31:03 <Luke> is there a way to replace (map . map show) over an [[a]] with (fmap show) or something
06:31:21 <Luke> i want to show each element, not each "row"
06:31:35 <srhb> Luke: Nope, that's what map . map is for on lists of lists.
06:31:42 <Luke> k ty
06:31:44 <srhb> (It makes sense and is readable, too!)
06:31:51 <Luke> true
06:31:59 <Luke> but if I could make [[]] the functor, then it'd work =)
06:32:39 <Botje> deepmap?
06:33:40 <fmap_> > show .: [[1],[2],[3]]
06:33:42 <lambdabot>   [["1"],["2"],["3"]]
06:34:54 <mekeor> > map (map show) [[1],[2],[3]]
06:34:54 <Botje> what an appropriate nickname :)
06:34:55 <lambdabot>   [["1"],["2"],["3"]]
06:36:43 <byorgey> Luke: [[]] is a functor, but you can't make an instance for it since it overlaps with the instance for []
06:37:02 <Luke> gotcha - thanks
06:37:20 <byorgey> Luke: however, using Data.Functor.Compose from transformers, you could write  getCompose . fmap show . Compose
06:37:22 <mm_freak> map . map show?  feels like a type error
06:37:24 <byorgey> not that that's much better ;)
06:37:27 <mm_freak> :t map . map show
06:37:29 <lambdabot>     Couldn't match expected type `a -> b'
06:37:29 <lambdabot>            against inferred type `[String]'
06:37:29 <lambdabot>     Probable cause: `map' is applied to too many arguments
06:37:38 <byorgey> I assume Luke meant  (map . map) show
06:37:43 <Luke> yeah
06:37:49 <mm_freak> ah
06:37:57 <Luke> typed it wrong
06:38:22 <mm_freak> deepmap is possible, but you would need some advanced type system features for it
06:38:42 <S11001001> syb?
06:39:11 <mm_freak> you can do it with existentials for example, but Luke, just forget that =)
06:39:14 <mm_freak> use map . map
06:42:17 <ski> sopvop : nice :)
07:07:24 <ski> > let select (_,     [       ],_  ) = mzero; select (x,xxs0@(x0:xxs1),xs) = return (x0,xxs0,xxs1) `mplus` do {(x,xxs1,xs) <- select (x,xxs1,xs); return (x,xxs1,x0:xs)}; setXXs xxs ~(x,_xxs,xs) = (x,xxs,xs) in mfix (select . setXXs "abc") :: [(Char,String,String)]
07:07:26 <lambdabot>   [('a',"abc","bc"),('b',"bc","ac"),('c',"c","ab")]
07:07:28 <ski> > let append (~[     ],~[],[        ]) = return ([],[],[]); append (~(_x:xs), ys,xsys0@(x:xsys)) = return ([],xsys0,xsys0) `mplus` do {(xs,ys,xsys) <- append (xs,ys,xsys); return (x:xs,ys,x:xsys)}; setXsYs xsys ~(xs,ys,_xsys) = (xs,ys,xsys) in mfix (append . setXsYs "abc") :: [(String,String,String)]
07:07:30 <lambdabot>   [("","abc","abc"),("a","bc","abc"),("ab","c","abc"),("abc","","abc")]
07:08:19 <ski> mm_freak,aristid ^
07:08:34 <ski> see those examples of `mfix' for the `[]' monad :)
07:12:17 <ch0kee> hello
07:12:24 <Axman> o/
07:12:37 <ch0kee> is there any way to visually debug code for example in geany ?
07:15:59 <byorgey> ch0kee: the EclipseFP plugin for Eclipse has some graphical debugging features I think.
07:16:16 <byorgey> ch0kee: I'm not exactly sure what you're looking for though, I'm not familiar with geany
07:16:33 <byorgey> http://eclipsefp.github.com/
07:17:31 <ch0kee> thanks for the answer, i dont want to use geany at all costs, its just a very plain, easy to use editor, with built-in make support for haskell
07:17:35 <ch0kee> I give it a try
07:20:26 <arnsholt> What's the idiomatic way to express that my Parsec parser should consume the entirety of the input string?
07:20:52 <bitonic> ch0kee: you can also get that in emacs/vim with ghc-mod
07:20:53 <ion> something <* eof
07:20:57 <byorgey> arnsholt: myParser = parseStuff <* eof
07:21:04 <arnsholt> Cheers!
07:21:06 <joelr> moin
07:21:40 <joelr> how do i declare a haskell "thing" that i need to pass to a c function that will later call a haskell callback?
07:22:33 <byorgey> anyone else with an account on code.haskell.org having trouble ssh'ing into it?
07:22:57 <Igloo> WFM
07:23:05 <Saizan> me too
07:23:11 <joelr> StablePtr it is, i think
07:23:51 <byorgey> ok.  ping and HTTP both work for me, it's just SSH that hangs
07:24:06 <byorgey> but maybe it's something on the Penn network end, I'll check
07:24:21 <homie> is there a repl for gch ?
07:24:26 <homie> i know ghci but.....
07:24:47 <byorgey> oh, there, it's actually working, just very slow
07:24:54 <jfischoff> homie: but what?
07:24:56 <byorgey> homie: what's wrong with ghci?
07:25:23 <tgeeky_> byorgey: it's a popular thing in other languages to make alternative REPLs
07:25:35 <ch0kee> byorgey: it doesnt run on my android :) thats a problem
07:26:04 <byorgey> fair enough, I am certainly not claiming ghci is perfect =)
07:26:22 <homie> well yes it could be better....
07:26:29 <byorgey> just want to know specifically what it is that homie is looking for which ghci does not provide
07:27:12 <homie> hmmm if you ask me so.....
07:27:28 <homie> i can't tell yet what exactly
07:27:58 <homie> i used it once and strange things were happening, especially with the debugger or so.....
07:28:58 <tgeeky_> byorgey: i searched for 'coapplicative' and only found an edwardk note about haskell not having (and can't possibly have) coexponentials.
07:29:03 <tgeeky_> byorgey: why is this so obvious?
07:29:57 <sipa> what is a coexponential?
07:30:12 <byorgey> tgeeky_: like everything CT, presumably it is obvious once you have sufficiently grokked the definitions.
07:30:16 <byorgey> but before that, it isn't.
07:30:28 <byorgey> since I don't know off the top of my head what a coexponential is, it is not obvious to me.
07:30:46 <tgeeky_> oh. I thought it was a Haskell limitation of some sort
07:30:55 <tgeeky_> the way edwardk worded it
07:31:25 <byorgey> maybe it is.  I don't know.
07:31:44 <tgeeky_> ok
07:32:22 <byorgey> ah, ok, a coexponential object is just an exponential in the dual category.
07:33:31 * sipa needs to learn CT one day
07:34:24 <byorgey> so I suppose a coexponential (Y <-- X)  would be one that comes with a 'coapply' of type   X -> (Y <-- X) x Y
07:35:23 <yrlnry> I looked into coexponentials a few months back.  Categories with coexpoentials also have a law that says that a+(bc) = (a+b)(a+c) for objects a,b,c, so that's why you don't see them much.
07:35:44 <gdoteof> I have a [(Foo,Bar)] and I need a [Foo,[Bar]]  .  Bar is essentially the data indexed by Foo; in my case it's really [(Player,Session)]  where each player has multiple sessions; and I need to get a clean list of sessions indexed by player so i can take a sum of it all
07:35:45 <yrlnry> And categories with both exponentials and coexponentials turn out to be trivial in some way I can't quite recall.
07:36:31 <barrucadu> gdoteof: Every element of a list must be the same type.
07:36:58 <tgeeky_> yrlnry: you don't see them much becaus they have a distributive law?
07:37:14 <yrlnry> A distributive law of coproducts over products, yes.
07:37:18 <byorgey> gdoteof: do you mean  [(Foo,[Bar])] ?
07:37:37 <tgeeky_> yrlnry: well, I mean, why is that something which is a hinderance?
07:37:46 <yrlnry> Well, can you think of an example?
07:37:53 <mauke> gdoteof: group . sort
07:38:13 <tgeeky_> yrlnry: no a categorical one, but there are plenty of mathematical ones?
07:38:18 <yrlnry> name one.
07:38:44 <tgeeky_> distribution of addition over multiplication in the field of rationals?
07:39:02 <yrlnry> 1+(2*3) = (1+2)*(1+3)?
07:39:06 <yrlnry> That's news to me.
07:39:58 <tgeeky_> oh, I didn't read that carefully enough.
07:40:25 <tgeeky_> yrlnry: do you know of any?
07:40:39 <byorgey> || distributes over &&.  That's the only example I know of.
07:40:56 <yrlnry> That's what I was about to say.  Some sort of lattice poset.
07:41:25 <byorgey> that's kind of cheating though because it's self-dual.
07:41:31 <yrlnry> Yeah.
07:42:17 <tgeeky_> what about distribution of <*> over <|> or some other weird thing with applicative/alternative
07:42:26 <tgeeky_> can't be those two
07:45:07 <tgeeky_> ugh. google is no help searching for this. It doesn't seem to believe 'coexponential' is a word.
07:45:26 <yrlnry> You can tell it "no, I really meant coexponential"
07:45:29 <homie> waahahahaha
07:45:35 <byorgey> tgeeky_: I just did a google search and get lots of results.
07:45:49 <yrlnry> It assumes you made a mistake because it finds a zilliion documents discussing exponenetials and hardly any discussing coexponentials.
07:46:00 <homie> someone forgot to teach googlebot cat theory!
07:46:03 <homie> lol
07:46:14 <byorgey> @go coexponential
07:46:14 <lambdabot> Maybe you meant: google googleit do
07:46:18 <byorgey> @google coexponential
07:46:20 <lambdabot> http://ncatlab.org/nlab/show/coexponential+map
07:46:20 <lambdabot> Title: coexponential map in nLab
07:46:24 <byorgey> see?
07:46:55 <tgeeky_> byorgey: yep. I thought I clicked that link, but the first time I spelled it wrong
07:47:26 <gdoteof> byorgey: sorry yes that is what i meant [(Foo,[Bar])]
07:47:50 <gdoteof> mauke: checking out group . sort
07:48:25 <tgeeky_> yrlnry: oddly enough, these do come up in physics?
07:48:43 <tgeeky_> yrlnry: or at least in a few places in physics
07:49:05 <mauke> gdoteof: well, you probably need groupBy
07:49:10 <yrlnry> My understanding of physics is less than zero.
07:49:15 <tgeeky_> yrlnry: hehe ;)
07:49:20 <homie> mine too
07:49:29 <mauke> fucking magnets, etc
07:49:46 <tgeeky_> yrlnry: "I'd say something insightful about physics, but there is a probability > 100% that it's wrong."
07:50:05 <tgeeky_> hehe. Watch the physicists slowly back out of the room.
07:50:08 <gdoteof> is there anyway to 'pretty print' from putStrLn ?
07:50:22 <gdoteof> i am trying to inspect what i have; but it is so dense
07:50:45 <yrlnry> I found out that if you ask a question on se.physics that involves SR, they all start to back slowly out of the room because they assume you're a crackpot.
07:50:46 <byorgey> @package groom
07:50:46 <lambdabot> http://hackage.haskell.org/package/groom
07:50:49 <byorgey> gdoteof: ^^^
07:51:46 <yrlnry> Like mathematicians and trisection.  You could have the most reasonable question in the world about trisection, but as soon as you asked all the mathematicians would start to give you the hairy eyeball.
07:51:48 <gdoteof> byorgey: tyvm!
07:52:11 <tgeeky_> yrlnry: lol. the hairy eyeball. That's a new one.
07:52:17 <byorgey> what's SR?
07:52:18 <yrlnry> No, that's old.
07:52:19 * hackagebot hbayes 0.4.1 - Inference with Discrete Bayesian Networks  http://hackage.haskell.org/package/hbayes-0.4.1 (alpheccar)
07:52:23 <tgeeky_> byorgey: special relativity
07:52:28 <byorgey> oh, ok
07:52:31 <tgeeky_> yrlnry: I meant, new to me
07:52:51 <tgeeky_> byorgey: I am supposed to be working on relations (and not coexponentials)
07:52:57 <tgeeky_> byorgey: I found these slides interesting: http://www3.di.uminho.pt/~jno/ps/wg21-67b-sl.pdf
07:53:57 <tgeeky_> yrlnry: I am a (quantum) physicist and will be happy to answer any questions you have about SR, in #haskell-blah, to the best of my abilities.
07:54:06 <yrlnry> "hairy eyeball" seems to date to the late 1960s.
07:54:28 <tgeeky_> yrlnry: it sounds like something you'd get from a rough night drinking
07:55:09 <byorgey> ah, if a category has both exponentials and coexponentials, then  A = A + 0 = A + (0x0) = (A+0) x (A+0) = AxA.  If A = AxA, then apparently all morphisms into A with the same domain are equal (that's the step I don't quite see yet).
07:55:34 <byorgey> so it collapses to a poset.
07:55:48 <yrlnry> That explains why we couldn't think of any good examples except for posets.
07:55:58 <byorgey> indeed.
07:58:26 <tgeeky_> byorgey: that's a pretty cool property
07:58:53 <tgeeky_> I presume that you could substitute (0x0) with (0x0x0) or (0x0x0x0) or whatever?
07:59:00 <byorgey> sure
08:00:26 <fmap> Can I somehow see the inferred types of nested definitions?
08:00:45 <gdoteof> oh man groom is great
08:07:30 <parcs`> what is a nested definition
08:07:47 <burbul> :t runStateT
08:07:48 <monochrom> inside "where" or "let"
08:07:49 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
08:08:08 <ion> Has anyone implemented the getting and putting of null-terminated ByteStrings of unknown size with cereal?
08:08:09 <byorgey> fmap: the only way I know is to use the debugger to step to a point where the definition is in scope, and then ask for its type
08:08:22 <moebius_eye> I was wondering if there was a way to start threads in Haskell...
08:08:36 <byorgey> moebius_eye: yes, forkIO
08:08:55 <moebius_eye> byorgey: Isn't that for making forks?
08:09:09 <nand`> I'm not sure what the distinction is
08:09:18 <monochrom> "forking threads" just to confuse you!
08:09:24 <byorgey> moebius_eye: it creates a new lightweight thread, it does not fork off a new process, if that's what you're asking
08:10:06 <moebius_eye> OK. That's what I was looking for. :)
08:10:09 <byorgey> moebius_eye: but see a reference like "Real World Haskell" for lots more info on multithreaded programming in Haskell
08:10:44 <moebius_eye> thanks
08:12:21 <jaxtr> ahh it's a wonderful day
08:12:38 <pooya72> does any one know of any good tutorials on how to use cabal-dev?
08:14:45 <gdoteof> @hoogle group
08:14:46 <lambdabot> Data.List group :: Eq a => [a] -> [[a]]
08:14:46 <lambdabot> Data.List groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
08:14:46 <lambdabot> System.Posix.Types type GroupID = CGid
08:15:09 <gdoteof> weird. hayoo doesn't list the Data.List group
08:17:29 <tgeeky_> hayoo is missing a lot of stuff
08:19:17 <gdoteof> noted.     i am trying to do $ groupBy (\(x,y) -> ???) myListOfTuples
08:19:35 <gdoteof> originally i did (\(x,y) -> y==y) but that is obviously wrong
08:20:00 <gdoteof> i have [(Session,Player)] and I need them grouped by player
08:20:58 <S11001001> :t \c -> groupBy c (undefined :: [(String, Int)])
08:21:00 <lambdabot> ((String, Int) -> (String, Int) -> Bool) -> [[(String, Int)]]
08:21:19 <S11001001> gdoteof: fill in the arg :)
08:22:14 <`Jake`> does anyone here has syntastic for vim installed?
08:22:57 <gdoteof> S11001001: i have my list of tuples as `report`.  so report looks like [(Session1,Player1),(Session2,Player1),(Session3,Player2),(Session4,Player2)]
08:23:48 <gdoteof> and what I want is [([Session1,Session2], Player1), ([Session3,Session4],Player2)]
08:24:31 <Axman> gdoteof, don't forget that the function you pass to groupBy takes two arguments, not one
08:24:45 <gdoteof> so i tried to fill in the arg, but am missing something.  my attempt, groupBy (\(x,y) -> y==y) report
08:24:48 <gdoteof> ohhh
08:24:59 <gdoteof> that is the missing piece
08:25:29 <quicksilver> gdoteof: why do you think that hayoo doesn't list Data.Llist group?
08:25:38 <quicksilver> it is the first hit if you search for group
08:25:47 <quicksilver> (under the old name List.group)
08:25:55 <nand`> gdoteof: groupBy (comparing fst) works too
08:26:39 <gdoteof> quicksilver: for me it is haskell98 List.group
08:26:42 <gdoteof> okay yeah.
08:27:22 <angstrom> nand`: isn't it `groupBy ((==) `on` fst)'?
08:28:11 <nand`> oh, yes
08:28:14 <nand`> comparing is for Ord
08:28:50 <quicksilver> > map (\l -> (map fst l, snd (head l))) . groupBy (\(_,y0) (_,y1) -> y0 == y1) $ [(1,"p1"),(2,"p1"),(3,"p2"),(4,"p2")]
08:28:52 <lambdabot>   [([1,2],"p1"),([3,4],"p2")]
08:28:56 <quicksilver> gdoteof: ^^
08:29:14 <quicksilver> for extra pointfree credit, that first lambda can be replaced by &&&
08:29:17 <nand`> (or (==) `on` snd in your case, not fst)
08:29:44 <quicksilver> gdoteof: however bear in mind that group only works like that if the data is presorted.
08:30:45 <Paprikachu> hello world :o
08:31:05 <gdoteof> quicksilver: great.  i don't yunderstand &&& though
08:31:11 <quicksilver> then don't use it :)
08:31:13 <gdoteof> nand`: yep that was it for me; that works
08:31:15 <quicksilver> thats' why I didn't use it.
08:31:32 <quicksilver> it's not really relevant or interesting to your original question
08:31:39 <quicksilver> just a note on a way to make the answer shorter
08:31:52 <Paprikachu> > 1&2
08:31:53 <lambdabot>   Not in scope: `&'
08:31:54 <nand`> > ((+1) &&& (*2)) (50, 60)
08:31:55 <lambdabot>   ((51,61),(100,120))
08:31:56 <Paprikachu> :<
08:32:04 <mauke> Paprikachu: .&.
08:32:11 <nand`> oh, I was thinking of ***
08:32:14 <Paprikachu> > 1.&.2
08:32:15 <lambdabot>   Ambiguous type variable `a' in the constraint:
08:32:15 <lambdabot>    `Data.Bits.Bits a'
08:32:15 <lambdabot>      a...
08:32:33 <Paprikachu> > 1.&.2 :: Int
08:32:35 <lambdabot>   0
08:32:49 <Paprikachu> this is wrong
08:32:59 <Paprikachu> oh wait, no
08:33:01 <Paprikachu> lol
08:33:09 <hpaste> notyy pasted “confused about monad transformer” at http://hpaste.org/69200
08:33:24 <Paprikachu> why do i have to say :: Int
08:33:33 <Paprikachu> and how do i know if i have to?
08:33:45 <mauke> Paprikachu: the compiler will complain if it can't figure it out
08:33:59 <Paprikachu> nice rule :P
08:34:09 <Paprikachu> "if the compiler complains, it's wrong"
08:34:12 <Paprikachu> lolol
08:34:29 <mauke> numbers get special treatment
08:34:30 <quicksilver> Paprikachu: you need it when you're using overloading and there isn't enough type information to complete inference.
08:34:31 <mauke> > 1 + 2
08:34:32 <lambdabot>   3
08:34:45 <mauke> in this case the type is defaulted to Integer
08:34:47 <quicksilver> Paprikachu: unless the requirements for the defaulting rule kick in.
08:34:59 <mauke> but defaulting only works in a fairly limited number of cases
08:35:06 <Paprikachu> and why isn't it clear that the result should be Int?
08:35:06 <quicksilver> mauke: not so much numbers get special treatment, as a short list of predefined classes get special treatment.
08:35:07 <womb> How long are on average your modules when you code in haskell ?
08:35:10 <womb> in lines
08:35:25 <notyy> read some tutorial about monad transformer,can't understand... any one can suggest some simpler tutorial?
08:35:26 <mauke> Paprikachu: because it's Integer
08:35:30 <quicksilver> (but in the end it is alwyas numbers which get defaulted)
08:35:31 <womb> more like 200 or 2000 ?
08:35:38 <barrucadu> Paprikachu: 1 is not an Int.
08:35:38 <Paprikachu> but 1 is an Int, isnt it?
08:35:41 <barrucadu> :t 1
08:35:42 <lambdabot> forall t. (Num t) => t
08:35:49 <Paprikachu> lol
08:35:59 <Paprikachu> hmmmm
08:36:03 <womb> 1 is a Num
08:36:07 <Paprikachu> > 1 :: Int .&. 2
08:36:08 <lambdabot>   Only unit numeric type pattern is valid
08:36:14 <Paprikachu> > 1 :: Int .&. 2 :: Int
08:36:15 <lambdabot>   <no location info>: parse error on input `::'
08:36:26 <Axman> > (1 :: Int) .&. 2
08:36:26 <Paprikachu> > (1 :: Int) .&. (2 :: Int)
08:36:27 <lambdabot>   0
08:36:28 <lambdabot>   can't find file: L.hs
08:36:34 <Axman> o.O
08:36:37 <Paprikachu> :D
08:37:31 <Paprikachu> so.. how can i write an irc bot in haskell
08:38:05 <dylukes> A quick questin,
08:38:07 <Paprikachu> > "\r\nPRIVMSG #haskell :hohoho\r\n"
08:38:08 <lambdabot>   "\r\nPRIVMSG #haskell :hohoho\r\n"
08:38:16 <Paprikachu> :(
08:38:25 <dylukes> hm, nevermind I think I can answer this myself.
08:39:05 <Paprikachu> > show "\n"
08:39:07 <lambdabot>   "\"\\n\""
08:39:19 <Paprikachu> > show '\n'
08:39:20 <lambdabot>   "'\\n'"
08:39:29 <Paprikachu> :t '\n'
08:39:30 <lambdabot> Char
08:39:41 <Paprikachu> > print '\n'
08:39:42 <lambdabot>   <IO ()>
08:39:55 <barrucadu> Are you trying to break lambdabot? >.>
08:40:05 <Paprikachu> no. ^^
08:40:56 <zenzike> Paprikachu: presumably you've seen this?: http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
08:40:58 <dylukes> Paprikachu: There are a lot of ways.
08:41:01 <Paprikachu> > let f = f; f;
08:41:02 <lambdabot>   <no location info>: parse error on input `;'
08:41:05 <Paprikachu> :(
08:41:15 <dylukes> That tutorial is pretty simple for a basic IRC bot. I find the level of abstraction is too low for my taste.
08:41:19 <dylukes> But I'm a perfectionist.
08:41:27 <Paprikachu> me too :P
08:41:41 <dylukes> Well, just do it.
08:42:03 <Paprikachu> why does it disable buffering?
08:42:06 <monochrom> you can certainly add your own abstractions
08:42:10 <Paprikachu> that makes no sense to me.
08:42:32 <dylukes> It's so when you do write it writes immediately.
08:42:40 <monochrom> and enable bufferring as you see fit
08:42:41 <Paprikachu> i'm sure there is a flush function or something.
08:42:47 <dylukes> Indeed.
08:42:48 <otters> I want to split a ByteString by "\n\n"
08:42:52 <otters> can I do that?
08:42:52 <Paprikachu> hFlush?
08:43:02 <Paprikachu> (just a guess)
08:43:09 <dylukes> otters: yes
08:43:10 <monochrom> I think the "split" package can do that split
08:43:14 <dylukes> @hoogle splitWith
08:43:14 <lambdabot> Data.ByteString.Char8 splitWith :: (Char -> Bool) -> ByteString -> [ByteString]
08:43:14 <lambdabot> Data.ByteString.Lazy.Char8 splitWith :: (Char -> Bool) -> ByteString -> [ByteString]
08:43:14 <lambdabot> Data.ByteString splitWith :: (Word8 -> Bool) -> ByteString -> [ByteString]
08:43:17 <Paprikachu> @index hFlush
08:43:18 <lambdabot> System.IO
08:43:22 <Paprikachu> hah!
08:43:28 <Paprikachu> it _does_ exist.
08:43:32 <otters> yeah, those take individual characters
08:43:35 <otters> I need to split by a string
08:43:44 <dylukes> otters: You can take advantage of lazyness and be lazy.
08:43:51 <hayashi> @pl \key -> ( ( pretty key <> text ":" ) <+> ) . pretty
08:43:52 <lambdabot> (. pretty) . (<+>) . (<> text ":") . pretty
08:43:54 <otters> what
08:43:58 <dylukes> and zip the bytestring with itself offset.
08:44:05 <dylukes> but that's kinda a silly way to do things.
08:44:19 <tgeeky__> @hoogle (String -> Bool) -> ByteString ->  [ByteString]
08:44:19 <lambdabot> No results found
08:44:25 <tgeeky__> @hoogle (ByteString -> Bool) -> ByteString ->  [ByteString]
08:44:25 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
08:44:25 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
08:44:25 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
08:44:26 <dylukes> the overhead would be very big.
08:44:37 <otters> yes, and I like small overhead
08:44:46 <dylukes> Write a split routine then, it's not more than a line or tw.
08:45:02 <otters> that's what I've been trying to do for the past few minutes
08:45:13 <otters> the best I can think of is to iterate breakSubstring
08:45:18 <tgeeky__> otters: you want the splitOn function from split
08:45:38 <tgeeky__> otters: http://hackage.haskell.org/packages/archive/split/0.1.4.2/doc/html/Data-List-Split.html
08:45:46 <otters> doesn't splitOn operate on lists
08:45:48 <dylukes> tgeeky__: It's not for bytestrings though.
08:45:55 <dylukes> He's working with bytestring.
08:46:09 <tgeeky__> so write exactly the same function for bytestrings?
08:46:18 <dylukes> You could use a small attoparsec.
08:46:23 <dylukes> :P
08:46:31 <dylukes> Again, I have lazy inefficient solutions.
08:46:40 <otters> okay, I'll just use breakSubstring
08:46:43 <otters> thanks
08:47:05 <Paprikachu> > connectTo "irc.freenode.net" (PortNumber $ fromIntegral 6667)
08:47:07 <lambdabot>   Not in scope: `connectTo'Not in scope: data constructor `PortNumber'
08:47:20 <monochrom> import Network
08:47:27 <mauke> Paprikachu: that fromIntegral is redundant
08:47:32 <Paprikachu> > import Network; connectTo "irc.freenode.net" (PortNumber $ fromIntegral 6667)
08:47:33 <lambdabot>   <no location info>: parse error on input `import'
08:47:41 <Paprikachu> how can i import that?
08:47:47 <mauke> you can't
08:47:52 <monochrom> oh, nevermind, do it in your own ghc
08:47:53 <Paprikachu> mauke: i've taken it from the tutorial
08:48:06 <mauke> Paprikachu: then the tutorial is wrong
08:48:10 <mauke> well, or sloppy
08:48:17 <Paprikachu> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
08:48:28 <Paprikachu> what should i use instead?
08:48:36 <tgeeky__> Paprikachu: it would be somewhat silly if you were allowed to make someone else's lambdabot connect to a server (over IRC)
08:48:37 <dylukes> otters: I'll try to thin abotu this
08:48:42 <dylukes> I'd like to write such a routine as well.
08:48:47 <otters> me too
08:48:53 <mauke> Paprikachu: nothing
08:49:00 <Paprikachu> what.
08:49:07 <monochrom> PortNumber 6667
08:49:24 <armlesshobo> I think I may have found a bug using GTK
08:49:32 <Paprikachu> what does this do?
08:49:33 <gdoteof> quicksilver: thanks.  it took me a minute of playing with the parts tos ee what was going on.
08:49:42 <quicksilver> gdoteof: good :)
08:49:44 <gdoteof> i look forward to someday understanding what &&& is and how it is the same thing
08:49:51 <dylukes> otters: oh duh, why didn't I think of this
08:49:58 <Paprikachu> also, any ideads which haskell IDE i could use?
08:50:02 <Paprikachu> ideas
08:50:09 <k-zed> @type (&&&)
08:50:10 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
08:50:16 * k-zed slowly backs away
08:50:19 <armlesshobo> Paprikachu: leksah is cool
08:50:24 <Paprikachu> nope.
08:50:25 <quicksilver> gdoteof: (f &&& g) is (\l -> (f l, g l))
08:50:31 <armlesshobo> Paprikachu: i personally use vim
08:50:35 <hpaste> applicative annotated “confused about monad transformer” with “confused about monad transformer (annotation)” at http://hpaste.org/69200#a69201
08:50:38 <Paprikachu> no thanks
08:50:39 <parcs`> Paprikachu: there is eclipsefp and emacs haskell-mode
08:50:40 <Paprikachu> :D
08:50:45 <quicksilver> gdoteof: so in this case you'd use (map fst &&& snd.head)
08:50:47 <applicative> notyy: ^^^ maybe?
08:51:15 <Paprikachu> no command-line editor, and eclipsefp doesn't really help me in any useful way
08:51:27 <Paprikachu> leksah is just crap as a whole
08:51:32 <armlesshobo> Paprikachu: notepad
08:51:42 <parcs`> then you're out of luck because that's pretty much all there is
08:51:47 <Paprikachu> that's windows stuff
08:51:54 <Paprikachu> not availlable for os x
08:51:56 <Paprikachu> :P
08:52:06 <otters> dylukes: think of what
08:52:13 <mauke> wait, since when is emacs a "command-line editor"?
08:52:14 <dylukes> A simple solution.
08:52:24 <Paprikachu> isn't it?
08:52:26 <k-zed> > (((+) 1) &&& ((+) 2)) 3
08:52:26 <lambdabot>   (4,5)
08:52:30 <k-zed> woah.
08:52:53 <dylukes> oh uh
08:53:13 <dylukes> wait, isn't breakSubstring almost exactly what you want?
08:53:22 <otters> yeah
08:53:27 <otters> I'm just trying to figure out how to repeatedly apply it
08:53:28 <dylukes> Then why not just use that.
08:53:39 <dylukes> oh, just recurse.
08:53:52 <otters> oh, recursion
08:54:23 <dylukes> I basically just implemented breakSubstring
08:54:27 <k-zed> @hoogle iterate
08:54:27 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
08:54:27 <lambdabot> Data.List iterate :: (a -> a) -> a -> [a]
08:54:27 <lambdabot> Data.ByteString.Lazy.Char8 iterate :: (Char -> Char) -> Char -> ByteString
08:54:45 <k-zed> there might be this for "repeated application"?
08:54:46 <dylukes> do { i <- findSubstring ss bs); return (Char8.splitAt i bs); }
08:55:00 <Paprikachu> so how do i compile a haskell program with ghc
08:55:19 <dylukes> ghc --make Main.hs
08:55:20 <navaati> $ ghc MyHaskellProgram.hs
08:55:44 <Paprikachu>     Could not find module `Network':
08:55:46 <Paprikachu> whaaaaaaaaaaaat
08:55:48 <dylukes> Use --make.
08:55:49 <notyy> applicative,that's exactly what I am looking for, I am trying to understand it, thank you very much
08:55:57 <Paprikachu> i did
08:56:02 <dylukes> *shrug*
08:56:43 <Paprikachu> QQ
08:56:49 <Paprikachu> hi ski
08:57:14 <mauke> dylukes: --make is the default
08:57:46 <gdoteof> quicksilver: great.  that makes sense.  thanks a lot.  really much appreciated
08:57:55 <Paprikachu> i'll reinstall haskell
08:58:13 <mauke> Paprikachu: ghc-pkg list network
08:58:36 <Paprikachu> says /Library/Frameworks/GHC.framework/Versions/7.0.3-x86_64/usr/lib/ghc-7.0.3/package.conf.d
08:58:42 <dylukes> mauke: oh it is now?
08:58:44 <dylukes> that's good.
08:58:48 <mauke> Paprikachu: and nothing else?
08:58:51 <Paprikachu> nope
08:58:58 <mauke> Paprikachu: then you simply don't have the network package
08:59:09 <Paprikachu> why not o_O
08:59:14 <mauke> because you didn't install it
08:59:17 <dylukes> Are you on Windows btw?
08:59:24 <quicksilver> gdoteof: you're most welcome.
08:59:29 <Paprikachu> gladly i'm not
08:59:31 <mauke> dylukes: /Library/Frameworks? unlikely
08:59:39 <dylukes> Network is no longer bundled with GHC.
08:59:48 <dylukes> Did you install the Haskell Platform, or just GHC alone?
08:59:56 <`Jake`> does anyone have ghc-mod for vim installed?
09:00:11 <Paprikachu> [17:57:15]	<dylukes>	Did you install the Haskell Platform, or just GHC alone?
09:00:14 <Paprikachu> i don't remember
09:00:20 <Paprikachu> i installed it months ago
09:00:23 <k-zed> `Jake`: i have a haskell mode installed
09:00:57 <dylukes> `Jake`: I used it in emacs, haven't gotten enough vim practice yet to use vim comfortably, but it's on my list of things to install.
09:02:24 <`Jake`> ok... well, I don't think you can help me then, because I mainly wanted to install it for syntastic to work, but I can't install it correctly, for some reason, and I don;t think that sntastic works with haskellmode...
09:02:47 <`Jake`> ahhh too many typos
09:03:29 <Paprikachu> gawd
09:03:31 <Paprikachu> do
09:03:33 <Paprikachu> want
09:03:35 <Paprikachu> irc bot
09:05:08 <Paprikachu> nao
09:05:10 <Paprikachu> ._.
09:06:33 <parcs`> please don't type like hat
09:06:56 <yitz> preflex: seen Cale
09:06:56 <preflex>  Cale was last seen on #haskell 17 hours, 22 minutes and 37 seconds ago, saying: d-snp: It looks like your code should be possible to factor somewhat without any duplication... You might just pull out newHeader and initAck and those cookies as functions of the various things they depend on.
09:06:59 <Paprikachu> whyyyy
09:07:18 <mauke> Paprikachu: it's annoying
09:07:19 <yitz> preflex: tell Cale never mind, lambdabot's back. thanks!
09:07:19 <preflex>  Consider it noted.
09:07:26 * hackagebot hscolour 1.20.1 - Colourise Haskell code.  http://hackage.haskell.org/package/hscolour-1.20.1 (MalcolmWallace)
09:07:36 <Paprikachu> preflex: tell mauke: hi
09:07:36 <preflex>  no
09:07:42 <Paprikachu> preflex: tell mauke hi
09:07:43 <preflex>  Consider it noted.
09:08:02 <Paprikachu> preflex: tell Paprikachu hi
09:08:02 <preflex>  what
09:08:03 <tgeeky__> lol @ "no"
09:08:14 <tgeeky__> and @ "what"
09:08:19 <tgeeky__> preflex, the no frills lamdabot
09:08:38 <Paprikachu> preflex: tell lambdabot > 42
09:08:38 <preflex>  Consider it noted.
09:08:57 <yitz> @botsnack
09:08:58 <lambdabot> :)
09:08:58 <preflex>  lambdabot: you have 1 new message. '/msg preflex messages' to read it.
09:08:58 <tgeeky__> > 2 + 2
09:08:59 <lambdabot>   4
09:09:00 <`Jake`> Did you ever think about the possibilty that preflex might actually be a human?
09:09:15 <tgeeky__> `Jake`: I did, but then I put down the crack pipe.
09:09:16 <mauke> Paprikachu: don't do that
09:09:22 <Paprikachu> don't do what?
09:09:32 <hpc> preflex: tell lambdabot @tell hpc wat
09:09:32 <preflex>  Consider it noted.
09:09:38 <hpc> > "echo"
09:09:39 <lambdabot>   "echo"
09:09:45 <hpc> and did it work?
09:09:50 <mauke> hpc: don't do that
09:09:53 <hpc> no :(
09:10:09 <tgeeky__> Paprikachu: don't try to setup botsex
09:10:15 <mauke> Paprikachu: store messages for bots that can never be retrieved
09:10:15 <yitz> mauke: lambdabot should probably be rejected as a special case.
09:10:35 <mauke> yitz: why?
09:10:39 <Paprikachu> memory leaks!
09:10:59 <yitz> mauke: so people won't clog it up with stupid messages like that
09:11:10 <Paprikachu> preflex: tell Q hi
09:11:10 <preflex>  Consider it noted.
09:11:18 <Paprikachu> xd
09:11:42 <Paprikachu> does the user have to be in the channel?
09:11:45 <mauke> Paprikachu: there is no nick q
09:12:09 <Paprikachu> preflex: help
09:12:09 <preflex>  try 'help help' or see 'list' for available commands
09:12:15 <Paprikachu> preflex: help help
09:12:15 <preflex>  help COMMAND - show help for a command
09:12:22 <Paprikachu> preflex: list
09:12:22 <preflex>  Botsnack: [botsnack]; Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; PlokiRE: [re]; Seen: [seen]; Sixst: [6st]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; XSeen: [xseen];
09:12:23 <preflex>  ZCode: [zdec, zenc]
09:12:24 <tgeeky__> don't you dare
09:12:34 <Axman> Paprikachu, if you keep that up, you're probably heading for a ban
09:12:44 <zomg> I wrote my own haskell irc bot
09:12:49 <zomg> it's much more awesome than lambdabot
09:12:55 <zomg> if it compiles of course
09:12:56 <HugoDaniel> :)
09:12:56 <zomg> ;>
09:13:17 <zomg> I broke it by updating haskell into 7.0.3 which apparently in turn broke the hidden ghc module somehow and my bot depends on that to load code dynamically
09:13:18 <Paprikachu> preflex: cdecl foo
09:13:18 <preflex>  foo
09:13:22 <tgeeky__> I compiled my own lambdabot, and then broke it the very next day by updating.
09:13:36 <quicksilver> Paprikachu: play with preflex in private messages, if you wish
09:14:07 <Axman> preflex: cdecl int (*fp)(int *foo,double *bar);
09:14:07 <preflex>  fp: pointer to function(foo: pointer to int, bar: pointer to double) returning int
09:14:20 <mauke> or in #haskell-blah
09:14:51 <Paprikachu> prefelx: cdecl int foo::*
09:15:01 <Paprikachu> preflex: cdecl int foo::*
09:15:01 <preflex>  trailing garbage
09:15:09 <Paprikachu> you are garbage :o
09:15:14 <tommd> I don't think Paprikacu likes to listen to humans.
09:15:14 <Axman> yes, C++ is garbage
09:15:36 <Paprikachu> actually, C is garbage and C++ the only true religion
09:15:45 <Axman> we have ways of making him listen. or, doing what we really want, not talking nonsense ;)
09:16:23 <Yarou> i hope you don't make him an offer he can't refuse
09:17:11 <Axman> i was thinking more a kicking, but that might also work
09:18:16 <tgeeky__> it's like the electromechanical-spider thing they used in the Matrix, only over the internet
09:18:58 <Axman> what, C++? :P
09:19:10 <hpaste> ktosiek pasted “NeuronTest.hs” at http://hpaste.org/69203
09:19:11 <ktosiek> Hi! I'm having problems with OpenCL - I'm getting "OpenCL Exception: InvalidValue occurred in call to: clEnqueueReadBuffer" when trying to peekListArray
09:19:36 <ktosiek> hpaste bot just sent the code
09:20:22 <ktosiek> how can I get to the results?
09:21:30 <Paprikachu> ircbot.hs:7:1:
09:21:32 <Paprikachu>     The last statement in a 'do' construct must be an expression
09:21:38 <Paprikachu> main = do
09:21:40 <Paprikachu> 	socket <- (connectTo server (PortNumber port))
09:21:41 <Paprikachu> what.
09:21:54 <quicksilver> Paprikachu: you can't end a do block with a "a <- b"
09:22:04 <quicksilver> you have to end with a normal expression
09:22:16 <aristid> like return ()
09:22:16 <Axman> what you've written there is equivalent to main = connectTo server (PortNumber port) >>= \socket ->
09:22:28 <quicksilver> you could use "return ()" if you don't particularly want to do antyhing
09:22:30 * tgeeky__ waits for Axman
09:22:31 <Paprikachu> i don't know what >>= means
09:22:34 <Paprikachu> but okay
09:22:35 <aristid> Axman: where's your 6 gone? oO
09:22:40 <Axman> D:
09:22:54 <Paprikachu> what does return mean in haskell?
09:23:01 <Paprikachu> wasn't there something special about it?
09:23:04 <Axman> bloody IRC client. my server died so I'm on Xchat Azure, and it does;t like remembering my preferences
09:23:12 <tgeeky__> Paprikachu: read the documentation.
09:23:17 <Paprikachu> no thx
09:23:27 <Ralith> then have fun not knowing!
09:23:28 <Yarou> @type (>>=)
09:23:29 <mauke> Paprikachu: there's something non-special about it
09:23:30 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:23:37 <Paprikachu> i don't care if i don't know
09:23:37 <Yarou> Paprikachu: ^
09:23:38 <tgeeky__> oh, well you just signed your death warrant w.r.t. getting help here :O
09:23:45 <Yarou> that is what >>= is
09:24:15 <Yarou> and Paprikachu when asking for help, it's generally a good idea not to be an asshole
09:24:19 <Paprikachu> i don't really know what monads are, allthough ski tried to explain them to me, so that doesn't help me
09:24:28 <alpounet> Paprikachu, so your goal is basically to write an ircbot in haskell without actually learning the necessary haskell to do so?
09:24:55 * tgeeky__ steals alpounet's troll food and hides it
09:24:55 <Paprikachu> ghc: could not execute: /usr/bin/gcc-4.2
09:24:59 <Paprikachu> dude what
09:25:11 * Axman is going to go and learn C, but fuck that pointer shit
09:25:24 <Paprikachu> pointers are simple
09:25:29 <alpounet> tgeeky__, hey, this wasn't an actual troll, my question was kind of legitimate :P
09:25:38 <Eduard_Munteanu> Yeah, kinda like monads :P
09:25:39 <Paprikachu> but why the heck does ghc want to use gcc
09:25:42 <Paprikachu> and why 4.2
09:25:47 <tgeeky__> alpounet: no, you'r feeding the troll :O
09:25:48 <Axman6> so are monads.
09:25:53 <tgeeky__> alpounet: and presumably they eat troll food.
09:25:53 <Paprikachu> hell, i got 4.8
09:26:21 <thoughtpolice> Paprikachu: GHC emits assembler files. it uses GCC to turn the assembler files into object files
09:26:25 <mauke> Axman6: wanna talk about C in #haskell-blah?
09:26:29 <Axman6> does GHC even use gcc for anything other than linking these days?
09:26:40 <alpounet> tgeeky__, oh, well, i guess i'd be better off listening to Susskind.
09:26:45 <Paprikachu> but why doesn't it use /usr/bin/gcc
09:26:46 <thoughtpolice> technically GCC could just call 'as' directly
09:26:51 <Paprikachu> which is 4.8
09:26:59 <Axman6> mauke, not particularly, why do you ask? (actually, if it's interesting, maybe)
09:27:26 <Paprikachu> also, i'm not sure if /usr/bin/gcc-4.2 exists. seems like it doesn't.
09:27:28 <mauke> Axman6: oh, just in case this was going to turn into a longer discussion about pointers
09:27:28 <tgeeky__> Axman6: I think he took your "learning C, but fuck that pointer shit" as a serious assertion
09:27:38 <mauke> argh
09:27:41 <mauke> tgeeky__: got it
09:28:21 <ion> Le sigh. It seems i can’t implement “get” for null-terminated ByteStrings with cereal. They don’t seem to export the necessary things to do that.
09:28:41 <quicksilver> might be by design
09:28:43 <ion> (PEBKAC is also possible, of course.)
09:28:48 <Paprikachu> so whats wrong with my ghc
09:28:53 <quicksilver> they're not really good binary protocol design
09:29:06 <quicksilver> good binary protocols are designed so you know how much to read up front
09:29:20 <quicksilver> or it might just be an ommission, who knows ;)
09:29:45 <ion> quicksilver: Yes, the protocol (<https://developer.valvesoftware.com/wiki/Source_RCON_Protocol>) is abhorrent overall.
09:29:57 <parcs`> i have a somewhat-c-related question: how does plusPtr work without knowing the size of the underlying data type? ie how does plusPtr work without a Storable constraint on the a in Ptr a?
09:30:07 <ion> Multiple replies can be sent to queries, but it won’t tell you how many or which one is the last one.
09:30:40 <mauke> :t plusPtr
09:30:41 <lambdabot> Not in scope: `plusPtr'
09:30:42 <Axman6> parcs`: isn't it just an increment of n to the value of the pointer?
09:30:58 <thoughtpolice> parcs`: it just increments by 'n', so you have to specify the size yourself, which can be based on the underlying data type
09:31:13 <parcs`> oh okay, so it's not like pointer addition in c
09:31:17 <thoughtpolice> yeah
09:31:28 <mauke> parcs`: "Advances the given address by the given offset in bytes."
09:31:32 <Axman6> @hoogle Ptr
09:31:33 <lambdabot> Foreign.Ptr module Foreign.Ptr
09:31:33 <lambdabot> Foreign.Ptr data Ptr a
09:31:33 <lambdabot> GHC.Exts data Ptr a
09:31:38 <ion> I already wrote getByteString0 only to have it not compile because they don’t export Data.Serialize.Get.put.
09:31:46 <Paprikachu> so noone willing to help me
09:32:05 <Axman6> Paprikachu: we've helped you heaps and you've been nothing but annoying and a pain
09:32:56 <Paprikachu> telling me to read a documentation has nothing to do with helping
09:33:30 <Clint> Paprikachu: git clone git://github.com/dom96/ElysiaBot.git
09:33:34 <Clint> build, and then pretend you wrote it
09:33:35 <Axman6> it really does, when your questions are so simple
09:33:46 <Paprikachu> no Clint
09:33:47 <tgeeky__> Paprikachu: nothing is wrong with your ghc, you're probably running a shell script or something that is calling an old version of gcc
09:33:52 <quicksilver> Paprikachu: telling you to read documentation is one way of helping you.
09:33:52 <Axman6> Paprikachu: we're happy yo help people, but they have to be willing to help themselves too
09:34:03 <Paprikachu> i just run ghc from the command line, nothing more
09:34:13 <quicksilver> Paprikachu: if you reject some of the help you are offered, you reduce your chance of getting more help.
09:34:13 <Paprikachu> ghc <filename>
09:34:22 <bitonic> is there an STM-based hashtable?
09:34:34 <tgeeky__> Paprikachu: then your installation of GHC is borked. try again.
09:34:44 <Paprikachu> i used macports to install it
09:35:04 <tgeeky__> ah, there's your problem
09:35:09 <parcs`> i believe the ghc in macports is crusty
09:35:11 <bitonic> to insert/delete/modify entries atomically
09:35:33 <monochrom> helping has nothing to do with telling
09:36:25 <coppro> dumb question time!
09:36:27 <Axman6> bitonic: you could use the unordered-containers package in a TVar and get all that without much effort
09:36:39 <coppro> I have (a -> b -> c) and (c -> d). How do I compose them to get (a -> b -> d)?
09:36:46 <tgeeky__> coppro: there are no dumb questions, only dumb people asking them!
09:36:51 <tgeeky__> though maybe I have that backwards
09:37:00 * Axman6 goes to bed
09:37:03 <thoughtpolice> the GHC inside macports probabaly hasn't been updated to deal with the recent changes in Xcode, the removal of gcc-4.2 being one of those changes
09:37:04 <mauke> @djiinn (a -> b -> c) -> (c -> d) -> (a -> b -> d)
09:37:05 <lambdabot> f a b c d = b (a c d)
09:37:08 <tgeeky__> @djinn (a -> b -> c) -> (c -> d) -> (a -> b -> d)
09:37:09 <lambdabot> f a b c d = b (a c d)
09:37:11 <parcs`> :t \f g -> (f .) . g
09:37:12 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
09:37:14 <`Jake`> Clint: does it work if you replace git:// with http:// ?
09:37:19 <tgeeky__> mauke: !! great minds!
09:37:29 <tgeeky__> @pl f a b c d = b (a c d)
09:37:29 <thoughtpolice> you should probably just remove the macports install, and use the binary installer from haskell.org/ghc IMO
09:37:29 <lambdabot> f = flip ((.) . (.))
09:37:30 <bitonic> Axman6: sure, but that doesn't exploit the fact that you have mutability
09:37:33 <thoughtpolice> or update the macports formula
09:37:40 <Eduard_Munteanu> @. pl djinn (a -> b -> c) -> (c -> d) -> (a -> b -> d)
09:37:40 <lambdabot> f = flip ((.) . (.))
09:37:41 <tgeeky__> coppro: like that^^
09:37:50 <Paprikachu> maybe it's because i installed ghc-devel instead of ghc
09:37:54 <tgeeky__> Eduard_Munteanu: You gave me a knol! thanks!
09:37:55 <Axman6> bitonic: no, but that may also be a premature optimisation =)
09:37:56 <Paprikachu> i'm now trying ghc
09:38:09 <untitled> can I create a type, which contains (Maybe Line) and (Maybe Circle), Line and Circle are records made by me, and make a function, that returns either Maybe Line or Maybe Circle, i.e. this type?
09:38:16 <coppro> tgeeky__: ah, this is obviously superior to me writing the lambda out myself :P
09:38:28 <bitonic> Axman6: yes but asking doesn't hurt, maybe it existed already
09:38:29 <Clint> `Jake`: if only there were some way to find out
09:38:34 <Axman6> untitled: you could make it return Maybe (Either Line Circle)
09:38:40 * Eduard_Munteanu accepts Visa and Mastercard :P
09:39:01 * tgeeky__ only emits debt, not credit :O
09:39:08 * Axman6 -> sleep for realz
09:39:41 <coppro> is there no library which has functions composing multiple arguments like that?
09:39:45 <Paprikachu> is there something like Either for 3 types?
09:39:53 <`Jake`> Clint: It does the same think, doesn't it?
09:39:59 <tgeeky__> Paprikachu: now that's a good question
09:40:02 <`Jake`> thing*
09:40:10 <parcs`> coppro: functors
09:40:12 <Eduard_Munteanu> @. pl djinn (c -> d) -> (a -> b -> c) -> (a -> b -> d)
09:40:12 <lambdabot> f = (.) . (.)
09:40:18 <Paprikachu> thank you :P
09:40:24 <Clint> `Jake`: well, no, the git:// uses smart transport, the http:// does a redirect to https and then uses dumb transport
09:40:26 <Eduard_Munteanu> That might be more sensible wrt composition.
09:40:31 <coppro> how about Data.Composition?
09:40:46 <`Jake`> Clint: ok...
09:40:55 <`Jake`> Clint: thanks
09:41:42 <Paprikachu> so there isn't?
09:41:55 <parcs`> Either (Either a b) c
09:42:28 <applicative> data Paprikachu a b c = Pap a | Rika b | Chu c
09:42:37 <untitled> Axman6: Couldn't match expected type `Either Line Circle' with actual type `Line'
09:43:04 <Paprikachu> and i can use this the same way as Left/Right x?
09:43:16 <applicative> instance Monad (Paprikachu a b) where return = Chu ...
09:43:48 <untitled> Axman6: this function returns Maybe Line, I put the return type as you said
09:44:07 <Paprikachu> always these monads QQ
09:44:08 <applicative> with Either (Either ..) your values are Left (Right  a) (Left (Left b)  and Right c
09:44:23 <Paprikachu> yeah, that's not that easy to use
09:44:49 <applicative> with the custom  data Paprikachu a b c , they are Pap a  Rika b and Chu c
09:45:29 <Paprikachu> okay
09:46:05 <applicative> paprikachu f g h p :: (a -> d) -> (b -> d) -> (c -> d) -> (Paprikachu a b c -> d); ...
09:46:19 <applicative> @type either
09:46:20 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
09:47:10 <applicative> @src  either
09:47:10 <lambdabot> either f _ (Left x)     =  f x
09:47:10 <lambdabot> either _ g (Right y)    =  g y
09:47:41 <Paprikachu> okay, the normal non-devel version of ghc also wants to use gcc-4.2
09:47:45 * untitled didn't understand a thing
09:47:45 <Paprikachu> this sucks.
09:49:11 <thoughtpolice> Paprikachu: you probabaly have a new version of xcode which has gcc-4.2 removed, and the version of GHC in macports is too old to have this issue fixed. you should probabaly just use the haskell.org mac installers or something
09:49:25 <thoughtpolice> which AFAIK do work with xcode 4.2+ and beyond
09:49:35 <Paprikachu> no, xcode is not that new afaik
09:49:41 <Paprikachu> it's 3.x
09:50:02 <Paprikachu> ill try the haskell.org installer then
09:50:03 * applicative is using the deLuxe new haskell platform ghc 7.4
09:50:13 <thoughtpolice> oh. in that case, i don't even know if the new installers work with that old of an xcode
09:50:17 <thoughtpolice> just check the page
09:50:23 <thoughtpolice> it mentions xcode compatibility
09:50:25 <applicative> my xcode is ancient
09:50:35 <thoughtpolice> well, there you go
09:50:45 <joelr> @pl do { size <- peek tickerLen; buf <- peek tickerPtr; ticker <- packCStringLen (buf, size) }
09:50:46 <lambdabot> (line 1, column 4):
09:50:46 <lambdabot> unexpected "{"
09:50:46 <lambdabot> expecting variable, "(", operator or end of input
09:50:49 <applicative> wait, Paprikachu what gcc do you have?
09:50:54 <Paprikachu> 4.8
09:50:57 <joelr> hmm
09:51:23 <applicative> i'd think the new installer should know about all that.  but it's still being tested
09:51:52 <applicative> its here if you dare :)  http://www.ozonehouse.com/mark/platform/
09:52:11 <strager> @undo do { size <- peek tickerLen; buf <- peek tickerPtr; ticker <- packCStringLen (buf, size) }
09:52:12 <lambdabot>  Parse error at "}" (column 90)
09:52:16 <mauke> gcc 4.8? does that exist?
09:52:21 <strager> @undo do { size <- peek tickerLen; buf <- peek tickerPtr; ticker <- packCStringLen (buf, size) ; return ticker }
09:52:21 <lambdabot> peek tickerLen >>= \ size -> peek tickerPtr >>= \ buf -> packCStringLen (buf, size) >>= \ ticker -> return ticker
09:52:34 <joelr> strager: not quite
09:52:37 <Paprikachu> [18:49:45]	<mauke>	gcc 4.8? does that exist?
09:52:43 <thoughtpolice> probably some development snapshot
09:52:44 <strager> I don't know what you're trying to do =]
09:52:44 <Paprikachu> it's the developement-version
09:53:11 <joelr> strager: i'm just trying to shorten the sequence, maybe with fmap from Control.Applicative?
09:53:17 <Paprikachu> so i shouldn't download http://www.haskell.org/ghc/download_ghc_7_4_1#macosx_x86_64
09:53:25 <strager> @pl peek tickerLen >>= \ size -> peek tickerPtr >>= \ buf -> packCStringLen (buf, size) >>= \ ticker -> return ticker
09:53:25 <lambdabot> (peek tickerPtr >>=) . flip flip return . (((>>=) . packCStringLen) .) . flip (,) =<< peek tickerLen
09:53:31 <strager> There you go!  =D
09:53:35 <Paprikachu> and use http://www.ozonehouse.com/mark/platform/ instead?
09:53:58 <applicative> gcc 4.8 makes partial redundancy elimination more aggressive!
09:54:08 <untitled> yesterday someone suggested me to use pattern matching in case clause to accept different types, so how do I make function accept different types to use pattern matching inside it? :)
09:54:12 <strager> @pl peek tickerLen >>= \ size -> peek tickerPtr >>= \ buf -> packCStringLen (buf, size)
09:54:13 <lambdabot> (peek tickerPtr >>=) . (packCStringLen .) . flip (,) =<< peek tickerLen
09:54:14 <joelr> strager: e.g. ByteString.packCString <$> peek tickerPtr <*> peek tickerLen
09:54:37 <Paprikachu> # gcc --version
09:54:39 <Paprikachu> gcc (GCC) 4.8.0 20120325 (experimental)
09:54:40 <Paprikachu> there you have it
09:54:43 <mauke> untitled: you can't
09:54:47 <joelr> strager: except ByteString.packCString takes a tuple
09:54:58 <strager> uncyrry packCSringLen <$> peek tickerPtr <*> peek tickerLen
09:55:03 <strager> uncurry*
09:55:08 <applicative> Paprikachu: the latter will come with the rest of the haskell platform, so e.g. you wont have to figure out how to get the right iconv and so on for major libraries
09:55:09 <strager> I suck at typing today
09:55:22 <Paprikachu> alright, thx
09:55:22 <joelr> strager: @uncurry ?
09:55:39 <strager> :t uncyrry packCStringLen
09:55:40 <lambdabot> Not in scope: `uncyrry'
09:55:41 <lambdabot> Not in scope: `packCStringLen'
09:55:41 <strager> ...
09:55:50 <joelr> :D
09:55:56 <applicative> Paprikachu: for me its working better than the old patform but i am on 'Snow Leopard'
09:55:59 <strager> :t uncurry BS.packCStringLen
09:56:01 <lambdabot>     Couldn't match expected type `b -> c'
09:56:01 <lambdabot>            against inferred type `IO BSC.ByteString'
09:56:02 <lambdabot>     In the first argument of `uncurry', namely `BSC.packCStringLen'
09:56:06 <untitled> mauke: can I at least put different records in one type and make a function, that accepts this type and then use 'case' to determine which record is it?
09:56:06 <Paprikachu> me too
09:56:13 <Paprikachu> lion is crap :D
09:56:13 <mauke> untitled: yes
09:56:26 <strager> OH, you want curry; my bad
09:56:34 <strager> :t curry BS.packCStringLen
09:56:36 <lambdabot> GHC.Ptr.Ptr Foreign.C.Types.CChar -> Int -> IO BSC.ByteString
09:56:38 <joelr> strager: i do?
09:56:44 <strager> There you go
09:57:11 <applicative> in principle you want the haskell platform on osx for sure, and via the installers
09:57:14 <untitled> mauke: the syntax would be: type Mytype = (Rec1, Rec2) ?
09:57:29 <mauke> untitled: no, 'type' doesn't create types. 'data' does
09:57:29 <applicative> i was able to install wxhaskell for the first time in ages
09:57:35 <joelr> strager: hmm… thanks
09:58:00 <untitled> mauke: so, this will be a record containing records?
09:58:04 <mauke> untitled: no
09:58:09 <mauke> untitled: what do you mean by "record"?
09:58:23 <untitled> mauke: the one you create with data keyword
09:58:36 <mauke> data creates types
09:58:42 <strager> untitled: 'type' simply aliases one type to a different name, so you can use that different name and it is substituted.
09:58:45 <mauke> so you mean ... type, I guess?
09:59:19 <untitled> mauke: http://learnyouahaskell.com/making-our-own-types-and-typeclasses search for Record syntax
09:59:35 <mauke> untitled: record syntax is something different
10:00:00 <applicative> untitled: with type Mytype = (Rec1,Rec1) you would 'access' the fields with fst and snd
10:00:14 <gtmanfred> in case someone wasn't aware of it, I found this the other day to use with kindle gen https://github.com/igstan/learn-you-a-haskell-kindle
10:00:25 <Paprikachu> why is haskell 1,1 GB in size? xD
10:00:33 <mauke> Paprikachu: because it's not haskell
10:01:13 <applicative> Paprikachu: Not big enough!
10:02:33 <Yarou> i suppose it's equally as arbitrary as certain people using , instead of . for decimal point notation
10:03:02 <applicative> what are you going to use all that space on your harddrive for?  movies, family photos ... or the ghc?
10:03:20 <Paprikachu> porn
10:03:50 <Paprikachu> [1 of 1] Compiling Main             ( ircbot.hs, ircbot.o )
10:03:52 <Paprikachu> Linking ircbot ...
10:03:53 <Paprikachu> HELL YEAH
10:03:57 <applicative> see that's just what I meant.  The haskell platform will crowd out the nonsense, replacing it with Sense
10:04:20 <untitled> mauke: any hint how to make a type, containing types created with data? :)
10:04:54 <mauke> untitled: uh. the same you made the other types?
10:04:55 <Paprikachu> it works (:
10:04:57 <strager> Getting your code to compile after hours of wrestling with the compiler; such a good feeling.
10:05:02 <mauke> untitled: er, same way*
10:05:12 <Paprikachu> thanks appicative for the link <3
10:05:22 <untitled> mauke: parser complains about data keyword inside another data
10:05:32 <mauke> wtf
10:05:35 <strager> untitled: All types are "created with data".
10:05:58 <strager> untitled: You can't declare a data type while declaring a data type.
10:06:25 <applicative> Paprikachu: it does something a little different  ~/Library/Haskell... vs ~/.cabal I don't quite get yet
10:06:40 <untitled> if I first create 2 datatypes, then when creating a type containing those, parser complains about multiple declarations
10:06:54 <strager> untitled: Paste please
10:06:58 <Paprikachu> i don't care as long as it works :3
10:07:01 <strager> See /topic
10:07:06 <applicative> leave the word 'data' out?
10:08:16 <Paprikachu> does the write function append "\r\n" itself?
10:08:33 <hpaste> untitled pasted “types” at http://hpaste.org/69207
10:08:46 <strager> Paprikachu: No
10:09:01 <strager> When doing IRC, specify the line ending manually
10:09:07 <Paprikachu> ok
10:09:11 <applicative> untitled: you need to wrap Lines and Circles in the last line
10:09:23 <monochrom> you have to write "data Types = C1 Line | C2 Circle". you can choose some other names than C1 and C2
10:09:34 <hpaste> applicative annotated “types” with “types (annotation)” at http://hpaste.org/69207#a69208
10:09:42 <strager> untitled: That doesn't do what you want.  That creates two data constructors on the last line which conflict with the first two data constructors.
10:09:48 <applicative> untitled: ^^^ like that
10:09:55 <untitled> oh, ok
10:09:57 <untitled> thanks
10:10:08 <strager> Now L and C don't conflict
10:10:13 <monochrom> but I would just merge all 3 types. "data Types = Line { param1 ... } | Circle { p1 ... }"
10:10:18 <applicative> in a different system it could make sense
10:10:50 <Paprikachu> is it possible to create a function that takes a variable number of arguments?
10:10:58 <strager> Paprikachu: Yes, but don't do that
10:11:01 <strager> Send an array
10:11:03 <strager> *list
10:11:08 <Paprikachu> like hPrintf
10:11:10 <applicative> id take a variable number of arguments
10:11:14 <applicative> takwa
10:11:17 <applicative> aaaaaaah
10:11:20 <strager> > id id id id id 4
10:11:22 <lambdabot>   4
10:11:29 <strager> So practical!
10:11:33 <applicative> see, like strager did
10:11:33 <strager> > const const const const 4
10:11:34 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b -> a)
10:11:34 <lambdabot>    arising from a use...
10:11:38 <strager> > const const const const const 4
10:11:39 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> a)
10:11:39 <lambdabot>    arising from a use of `...
10:11:43 <strager> > const const const const const 4 4
10:11:44 <lambdabot>   4
10:11:44 <Siod> in the following code, what's the type of notOk: http://ideone.com/GMGqp
10:11:52 <Siod> is it wrapped in Cont?
10:12:11 <strager> Why would a paste site have Facebook integration?
10:12:13 <applicative> yipe callcc run everyone!
10:12:17 <strager> I don't understand the internet anymore.
10:12:30 <monochrom> because people want to "like" some pastes
10:12:37 <mauke> :t callCC
10:12:38 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
10:12:49 <Siod> yeah, that's confusing
10:12:54 <Siod> what's the type of notOk
10:13:14 <mauke> String -> Cont r Int?
10:13:22 <adamt> I'm more interested in why the facebook integration nonsense is speaking east-european.
10:13:28 <mauke> no, that can't be
10:13:55 <applicative> adamt: I have the same I noticed the Polish the other day
10:14:13 <Siod> notOk is the id function when called with runCont (divExcpt 10 0 error) id
10:14:31 <Siod> but i'm not getting how it's skipping the division when y ==0
10:14:43 <mauke> Siod: how is notOk id?
10:14:46 * applicative prefers codepad for simple Haskell examples
10:15:02 <Siod> mauke: i know it's not just id, but it's id
10:15:05 * applicative dimly remembers that codepad is written in haskell
10:15:08 <mauke> Siod: what
10:15:30 <tac-tics> Siod: The "do" notation isn't (necessarily) run sequentially
10:15:36 <Siod> mauke: because id "Denominator 0" goes into err
10:15:42 <Siod> mauke: handler err returns "Deminoator 0"
10:15:42 <mauke> Siod: WHAT
10:15:53 <pooya72> hi everyone. How can I install cabal-install 0.14.0? When I run cabal list cabal-install it only gives 0.10.4
10:16:08 <luite> cabal install cabal-install-0.14.0
10:16:14 <mauke> Siod: explain your reasoning
10:16:17 <applicative> cabal update?
10:16:41 <pooya72> luite: ha! the great luite! So we weet again!
10:16:48 <Siod> mauke: do you know i'm wrong and want to understand where i went wrong, or are you confused?
10:16:57 <applicative> pooya72: i see
10:17:08 <mauke> Siod: I'm confused by what you're saying
10:17:13 <mauke> Siod: and I think you're confused about your code
10:17:21 <pooya72> applicative: so I tried cabal update didn't work for some reason
10:17:22 <luite> pooya72: the older version still is the default one since 0.14.0 is still kind of experimental
10:17:38 <Siod> mauke: ok, divExcpt divided two ints, assume we're using 10 0
10:17:42 <luite> so you have to explicitly specify the version
10:17:50 <Siod> mauke: divExcpt also takes an error handler
10:18:04 <Siod> mauke: we input 10 0, then the \ok lambda runs
10:18:12 <applicative> pooya72: yes give the version  it probably breaks on older ghcs
10:18:16 <mauke> Siod: no, it doesn't
10:18:18 <Siod> then the \notOk lambda runs
10:18:30 <pooya72> luite: so I shouldn't have installed it? :)
10:18:44 <Siod> mauke: how so?
10:18:53 <luite> pooya72: no it's ok, it should work with 7.4.1, but hasn't been properly tested with older versions yet
10:19:01 <mauke> Siod: divExcpt 10 0 is still waiting for handler. nothing runs yet
10:19:06 <luite> if you find problems with it you should probably report them
10:19:09 <tac-tics> Someone should make a step-evaluator for the Cont monad
10:19:20 <tac-tics> I bet seeing the evaluation visually would help people understand it
10:19:20 <Siod> mauke: it's run with `runCont (divExcpt 10 0 error) id`
10:19:40 <mauke> ok
10:19:52 * applicative defines hangUpOnCC
10:20:05 <Siod> mauke: alright, so \notOk runs and then it hits the when
10:20:09 <mauke> yes
10:20:28 <Siod> mauke: now it sees y == 0, so it runs id on "Deminoator 0"
10:20:32 <mauke> Siod: no
10:20:34 <Siod> mauke: which is saved in err
10:20:36 <mauke> no
10:20:57 <Siod> mauke: go on then
10:21:06 <hpaste> Paprikachu pasted “irc bot” at http://hpaste.org/69209
10:21:07 <mauke> Siod: I don't understand where you get 'id' from
10:21:14 <mauke> Siod: it runs 'notOk' on "Denominator 0"
10:21:15 <Siod> mauke: the function is run with runCont (divExcpt 10 0 error) id
10:21:16 <Paprikachu> http://ideone.com/L4LCS
10:21:19 <Paprikachu> what's wrong here?
10:21:25 <Siod> mauke: notOk is id
10:21:30 <mauke> Siod: no, it isn't
10:21:32 <Siod> mauke: but it probably has some cont magic with it
10:21:36 <mauke> no
10:21:46 <Siod> mauke: you're not very convincing
10:22:00 <mauke> Siod: you're not very convincing
10:22:03 <Siod> mauke: and you're kind of annoying
10:22:09 <applicative> write socket ("NICK " ++ nick)
10:22:15 <mauke> <mauke> Siod: how is notOk id?
10:22:17 <Siod> mauke: i'm trying to understand the code
10:22:22 <Paprikachu> oh, lol
10:22:23 <mauke> Siod: you're kind of not answering my first question
10:22:25 <Paprikachu> thanks
10:22:26 <Siod> mauke: do you not see handler err
10:22:34 <Siod> mauke: forget it, i don't want to talk with you
10:22:37 <mauke> Siod: I do, but why does that matter?
10:22:41 <mauke> we haven't reached that part yet
10:22:46 <applicative> write socket "NICK " ++ nick is the attempt to append nick to an action
10:23:04 <Siod> ski
10:23:07 <applicative> you can do it in php
10:23:39 <Siod> applicative: can you help me out with this?
10:23:54 <applicative> callCC, no way!
10:23:57 <Siod> applicative: i just want to know the type of notOk http://ideone.com/GMGqp
10:24:04 <Siod> damn it
10:24:11 <mauke> ...
10:24:35 <Paprikachu> how can i print a string?
10:24:41 <Paprikachu> print doesn't do what i want
10:24:44 <mauke> putStr
10:24:46 <pooya72> luite: still no luck with the cabal-dev ghci ;(
10:26:06 <byorgey> pooya72: what's wrong with cabal-dev ghci?
10:26:21 <pooya72> byorgey: doesn't run
10:26:37 <byorgey> I think there is a known bug where you have to get it to successfully build once before cabal-dev ghci will work, or something like that
10:26:45 <byorgey> maybe that's your issue?
10:26:52 <pooya72> byorgey: cabal-dev install works cabal-dev configure works but cabal-dev ghci doesn't
10:26:58 <byorgey> oh, I see
10:27:05 <byorgey> what error do you get?
10:27:13 <applicative> Siod: are you ready for my announcement
10:27:24 <Siod> applicative: sure
10:27:30 <applicative> Siod: the type of notOk is  String -> m()
10:27:36 <applicative> where m is a monad
10:27:44 <luite> pooya72: but you said that it gave you a peremission denied error writing to /cabal-dev ?
10:27:54 <applicative> here I guess String -> Identity ()
10:28:14 <mauke> applicative: how did you derive that?
10:28:31 <Siod> that is confusing
10:28:44 <Siod> :t id
10:28:45 <lambdabot> forall a. a -> a
10:28:50 <pooya72> luite: if tried running /cabal-dev/cabal.config manually
10:29:04 <pooya72> luite: not through cabal-dev ghci
10:29:09 <Siod> where did the identity monad come from applicative?
10:30:49 <applicative> @src Cont
10:30:50 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
10:30:56 <applicative> is that right
10:30:57 <Paprikachu> why is this not valid? pong line = "PONG: " ++ $ drop 6 line
10:31:08 <Siod> callCC f = Cont $ \k -> runCont (f (\a -> Cont $ \_ -> k a)) k
10:31:09 <mauke> Paprikachu: because ++ $ is a syntax error
10:31:09 <luite> pooya72: ah, hmmm
10:31:11 <applicative> forget it, here's the type see the last arg of foo  http://ideone.com/g7mIF
10:31:22 <Paprikachu> why, it'S 2 operators
10:31:27 <Paprikachu> it's
10:31:31 <mauke> Paprikachu: exactly
10:31:43 <Paprikachu> a $ b means the same as a (b)
10:31:49 <Paprikachu> and that's what i want
10:31:53 <byorgey> no, it doesn't
10:31:56 <mauke> Paprikachu: no, it isn't
10:31:58 <byorgey> a $ b means the same as  a b
10:32:07 <Siod> christ
10:32:16 <pooya72> luite: this is the error http://hpaste.org/69210 I hate to drag you back into this. I was hoping cabal-install 0.14.0 would help. but it didn't :(
10:32:17 <byorgey> $ is not syntax, it is a function
10:32:21 <byorgey> just like any other function
10:32:23 <applicative> Siod: I was using Control.Monad.Trans.Cont
10:32:29 <Paprikachu> then why is it wrong?
10:32:41 <byorgey> Paprikachu: should this work:  3 + * 6
10:32:50 <Paprikachu> no, but this is different
10:32:54 <mauke> Paprikachu: it's the same
10:32:55 <byorgey> no, it isn't =)
10:33:05 <byorgey> $ is not special.
10:33:08 <Paprikachu> a ++ $ b should mean a ++ b
10:33:13 <mauke> Paprikachu: no, it shouldn't
10:33:30 <luite> pooya72: yeah that either means that fake-ghc-cabal-dev couldn't be run, or that its output was invalid
10:33:36 <byorgey> whether it should or not is irrelevant.  the fact is, it doesn't.
10:34:00 <Paprikachu> also, how can i do an if without an else?
10:34:05 <pooya72> luite: yeah but fake-ghc-cabal-dev runs fine manually...
10:34:07 <mauke> applicative: your type for notOk is unnecessarily restrictive
10:34:33 <Jeanne-Kamikaze> what's an if without an else supposed to mean
10:34:34 <meiji11> if I have a built-in type that's an applicative functor, is there a way to get ghci to pull up its implementation of <*>?
10:34:38 <luite> pooya72: yeah that makes it strange, i don't really know how to debug it other than by recompiling cabal-dev and addming more print stuff to see what it's dowing
10:34:40 <byorgey> Paprikachu: since if is an *expression*, not a statement, the else is required.  Otherwise the expression would have no value when the test is false, which doesn't make sense
10:34:41 <luite> doing
10:35:02 <mauke> Paprikachu: 'when'
10:35:04 <byorgey> Paprikachu: however, if you are in a do-block, you can sometimes use 'when'
10:35:06 <Paprikachu> but i want to do something only if something is true and nothing otherwise
10:35:16 <byorgey> which is the same as  if test then doSomething else return ()
10:35:18 <parcs`> :t flip (<$) :: Bool -> a -> Maybe a
10:35:19 <lambdabot>     Couldn't match expected type `Bool' against inferred type `f b'
10:35:19 <lambdabot>     In the first argument of `flip', namely `(<$)'
10:35:19 <lambdabot>     In the expression: flip (<$) :: Bool -> a -> Maybe a
10:35:19 <luite> pooya72: perhaps cabal-dev -v helps a bit? don't know if it has that flag
10:35:40 <parcs`> :t flip (<$) . guard :: Bool -> a -> Maybe a
10:35:41 <lambdabot> forall a. Bool -> a -> Maybe a
10:35:46 <Paprikachu> > do when True (print 5)
10:35:48 <lambdabot>   <IO ()>
10:35:49 <pooya72> yeah, I ran it on -v3 didn't help much
10:35:53 <parcs`> there's your if without else
10:35:56 <byorgey> Paprikachu: yup, that works
10:36:17 <Paprikachu> > do when True $ putStr "foobar"
10:36:18 <lambdabot>   <IO ()>
10:36:25 <Paprikachu> what.
10:36:29 <byorgey> Paprikachu: (note that lambdabot does not evaluate IO actions)
10:36:34 <Paprikachu> ok
10:36:37 <mauke> byorgey: yes, it does
10:36:40 <byorgey> does not *execute, I should say
10:36:41 <byorgey> yes, sorry
10:36:48 * mauke high-fives byorgey
10:36:50 <hpaste> applicative pasted “ContT whatever” at http://hpaste.org/69211
10:36:59 <applicative> Siod, the identity bit was wrong here is a more determinate type  ^^^
10:37:03 <hpaste> Luke pasted “Pipes DB reader” at http://hpaste.org/69212
10:37:09 <Paprikachu> @index when
10:37:10 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
10:37:16 <Paprikachu> QQ
10:37:18 <Luke> can anyone  help me with the type error in this paste? http://hpaste.org/69212
10:37:21 <Paprikachu> what do i have to import?
10:37:23 <Siod> that makes more sense
10:37:24 <mauke> applicative: still not quite it
10:37:26 <Luke> I'm messing with Pipes
10:37:30 <byorgey> Paprikachu: Control.Monad
10:37:48 <Paprikachu> @index isPrefixOf
10:37:48 <lambdabot> Data.List
10:37:52 <applicative> darn it, mauke! I said I was going to run when callcc came up
10:38:09 <armlesshobo> when I try to do a build with the -dynamic flag, do I need the *.so or do I need to install a separate package?
10:38:10 <mauke> Luke: try rows <- liftIO ioRows
10:38:19 <applicative> check out those type errors with the new even-more-categorical pipes
10:38:23 <Luke> oh thanks - wrong monad =)
10:39:23 <Luke> mauke: it's saying there's no instance for (MonadIO (Control.Monad.Trans.Free.FreeT (PipeF () Row) IO))
10:39:28 <hangUpOnCallCC> Siod: mauke will take all your callCC queries :)
10:39:58 <mauke> Luke: oh, fun. does 'lift' work?
10:40:02 <Siod> not in a helpful way hangUpOnCallCC
10:41:11 <hangUpOnCallCC> Luke: should you lift $ iorows  ?
10:41:19 <Luke> where's lift defined?
10:41:34 <Luke> oh nm
10:41:37 <Luke> foudn it
10:41:54 <Luke> yeah that was it - thanks
10:42:03 <hangUpOnCallCC> it will take you from an IO [Row] to the Pipe thing, whatever it is now
10:42:54 <hangUpOnCallCC> Luke, so then all the lines in the block are inthe pipe monad, not in IO, which is where iorows is
10:43:40 <Luke> right - thanks
10:44:13 <hangUpOnCC> you changed monads midstream
10:44:22 <Paprikachu> is there a function to drop the last character of a string?
10:44:41 <Clint> yes
10:44:42 <hangUpOnCC> init
10:44:49 <hangUpOnCC> dont use it
10:44:55 <Paprikachu> ...
10:45:03 <hangUpOnCC> > init "hello"
10:45:04 <lambdabot>   "hell"
10:45:09 <hangUpOnCC> see bad luck
10:45:15 <Paprikachu> why not?
10:45:36 <untitled> mauke: one more about types: how do I make 'Nothing' a part of my new type? same as before, but Types = L (Maybe Line) | C (Maybe Circle) | N Nothing; something like that
10:45:58 <hangUpOnCC> > map init $ unlines "hello\n\n\nworld"
10:45:59 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
10:45:59 <lambdabot>         against inferred ty...
10:46:05 <joelr> folks, any suggestion on what i'm doing wrong here? https://gist.github.com/da573ad39bbd5f04051c
10:46:09 <hangUpOnCC> grrr
10:46:09 <sipa> untitled: just ¦ N
10:46:13 <hangUpOnCC> > map init $ lines "hello\n\n\nworld"
10:46:14 <lambdabot>   ["hell","*Exception: Prelude.init: empty list
10:46:29 <Luke> is there an easy rule of thumb to tell what monad you'll be in in a block in a case like this?
10:46:29 <Luke> how did you know?
10:46:32 <Paprikachu> 		line <- init line
10:46:33 <hangUpOnCC> ^^^ here's why init is not in the Prelude for Haskell'''''''
10:46:37 <Paprikachu> why doesn't this work?
10:46:47 <ktosiek> untitled: you can make a constructor with no parameters
10:47:00 <Botje> Paprikachu: unless you're in the list monad, that's an error.
10:47:11 <Paprikachu> ?
10:47:22 <untitled> sipa: what does that mean? :)
10:47:25 <ktosiek> just: data Types = L (Maybe Line) | C (Maybe Circle) | N
10:47:31 <Paprikachu> 		line <- hGetLine socket
10:47:32 <Paprikachu> 		line <- init line
10:47:36 <sipa> untitled: what ktosiek said
10:47:37 <Paprikachu> this is basically what i want
10:47:40 <untitled> ktosiek: oh, ok
10:47:42 <Botje> Paprikachu: let line' = init line
10:47:45 <strager> Paprikachu: You want a 'let' expression:  let line' = init line
10:48:02 <Paprikachu> why is it called line'?
10:48:04 <sipa> Paprikachu: "init" is not a monadic action
10:48:06 <Paprikachu> and why llet
10:48:14 <Botje> Paprikachu: because types.
10:48:20 <sipa> so you can't use it on the right.of <-
10:48:26 <Botje> line <- hGetLine socket is an indication that you're in the IO monad
10:48:26 <strager> Paprikachu: Because you're not providing a monadic operation
10:48:29 <Paprikachu> QQ
10:48:35 <Paprikachu> haskell is so complicated ;_;
10:48:35 <strager> Paprikachu: You *could* do line' <- return (init line)
10:48:36 <Jeanne-Kamikaze> or fmap init onto the io val
10:48:40 <Botje> so all things to the right of a <- *must* be an IO action.
10:48:49 <Botje> init :: [a] -> [a] , so not an IO action, so type error.
10:49:12 <strager> Paprikachu: You'll figure it out; don't worry.  =]
10:49:31 <Paprikachu> 		line <- hGetLine socket
10:49:33 <Paprikachu> 		line <- return(init line)
10:49:37 <Paprikachu> can i write this in one statement?
10:50:03 <sipa> Paprikachu: notice that <- is line <- fmap init $ hGetLine socket
10:50:07 <sipa> ow
10:50:13 <cg_morton> line <- fmap init ( hGetLine socket )
10:50:22 <cg_morton> right?
10:50:22 <sipa> that
10:50:32 <Paprikachu> holy shit, more stuff i don't know
10:50:37 <Paprikachu> what is fmap?
10:50:45 <ktosiek> :t fmap
10:50:47 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:51:14 <untitled> sipa: ktosiek that doesn't seem to work, Couldn't match expected type `Types' with actual type `Maybe a0' In the expression: Nothing
10:51:22 <cg_morton> fmap is the same as <+>, maybe you know that one
10:51:27 <sipa> untitled: paste code please
10:51:35 <Paprikachu> nope, i don't
10:51:37 <joelr> any ffi experts around?
10:51:45 <sipa> joelr: just ask
10:51:46 <pooya72> member:luite: so i got ghci to work without any dependencies
10:51:51 <ktosiek> untitled: you would just use "N" for your "Nothin Type"
10:51:52 <sipa> @quote sipa
10:51:53 <lambdabot> sipa says: asking for experts before asking your questions prevents non-experts who know the answer as well from answering
10:51:57 <joelr> sipa: https://gist.github.com/da573ad39bbd5f04051c
10:52:20 <joelr> why the error? any way of doing what i'm doing but better?
10:52:24 <cg_morton> Paprikachu: you should probably read a haskell book or something
10:52:28 <Paprikachu> ./whois PaprikachuBot
10:52:30 <Paprikachu> :D
10:52:34 <Botje> Paprikachu: x <- fmap f m === y <- m; x <- (f y)
10:52:43 <Botje> uh
10:52:45 <Botje> Paprikachu: x <- fmap f m === y <- m; x <- return (f y)
10:53:02 <untitled> ktosiek: it's not my Nothing type, it's the one used in Maybe
10:53:13 <Paprikachu> [19:49:51]	<cg_morton>	Paprikachu: you should probably read a haskell book or something
10:53:18 <Paprikachu> yeah, probably
10:53:28 <sipa> @where lyah
10:53:28 <lambdabot> http://www.learnyouahaskell.com/
10:53:36 <sipa> ^- read that
10:53:41 <ktosiek> untitled: then you would need "L Nothing" or "C Nothing"
10:54:05 <joelr> sipa: are you talking to me?
10:54:07 * ktosiek wonders if you wanted to have "not really there, but a circle" in your type
10:54:13 <sipa> joelr: no
10:54:32 <jfischoff> anyone every used Shellac for building repl's?
10:54:38 <joelr> soo … any ffi knowledge around? :D
10:55:38 <untitled> ktosiek: emm, could you write a new type, which contains Maybe Line, Maybe Circle and Nothing from Maybe?
10:55:51 <Jeanne-Kamikaze> joelr, didn't you miss an argument ?
10:55:59 <Jeanne-Kamikaze> where's the handle
10:56:04 <joelr> Jeanne-Kamikaze: where, where? oh, darn!!!
10:56:05 <ktosiek> untitled: no, because "Nothing" already has a type - "Maybe"
10:56:08 <joelr> Jeanne-Kamikaze: thanks!!!
10:56:08 <Jeanne-Kamikaze> or am I stupid
10:56:09 <strager> untitled: What do you really want to do?
10:56:20 <Jeanne-Kamikaze> there's no AlertHandle :)
10:56:53 <ktosiek> untitled: is your type something like "Line or Circle or nothing"?
10:56:55 <joelr> Jeanne-Kamikaze: indeed. right you are!
10:57:04 <untitled> ktosiek: yes
10:57:15 <untitled> ktosiek: no, Maybe Line, Maybe Circle or Nothing
10:57:26 <ktosiek> untitled: why "Maybe"?
10:57:41 <strager> untitled: You want: data LineOrCircle = L Line | C Circle ; type MaybeLineOrCircle = Maybe LineOrCircle
10:57:47 <strager> Just wrap it in Maybe
10:57:51 * hackagebot hackport 0.2.18 - Hackage and Portage integration tool  http://hackage.haskell.org/package/hackport-0.2.18 (SergeiTrofimovich)
10:57:59 <strager> Unless you have a really good reason to embed it in the data type
10:58:14 <strager> Just (L (Line ...))
10:58:49 <cg_morton> if you have:  type = L (Maybe Line)   you can already do   L (Nothing)
10:59:42 <timthelion> It's ironic.  I write an application in haskell, and the only preformance problems I have are related to GTK+ which was written in C :D
10:59:46 <Jeanne-Kamikaze> or Maybe (Either Line Circle)
10:59:50 <cg_morton> and there's no reason to make that different from C (Nothing)
11:00:33 <sm> what does hpc mean by "hpc: can not find Main in ["./.hpc"]" ?
11:00:56 <cg_morton> or, type T = L Line | C Circle, and then use 'Maybe T' as your type
11:01:16 <timthelion> sm: hpc is an application as well as a person?
11:01:38 <sm> yes
11:01:39 <cg_morton> ah, but with 'data' instead of 'type'
11:02:16 <timthelion> sm: and .hpc is a dynamically compiled haskell config file.
11:02:21 <timthelion> ?
11:02:36 <sm> http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/hpc.html
11:02:52 <sm> also why does that doc talk about .mix and .tix files.. typo or are they different ?
11:03:37 <sm> timthelion: could be
11:04:07 <sm> ah, more detail at http://www.haskell.org/haskellwiki/Haskell_program_coverage
11:04:08 <timthelion> sm: does my question answer your question?
11:04:17 <sm> timthelion: not yet, but I'm digging..
11:05:14 <untitled> strager: actually I just want a function to accept any of two hand-made types, which come in Maybe, or Nothing
11:05:19 <pooya72> luite: GOT IT TO WORK!!!
11:05:30 <pooya72> luite: don't know what i did, but it worked!
11:05:46 <armlesshobo> pooya72: hpaste your code so we can critique it into the ground
11:06:19 <pooya72> armlesshobo: haha, it wasn't code, just getting cabal-dev ghci runnig
11:06:25 <armlesshobo> ah
11:06:51 <pooya72> armlesshobo: now all I have to do is learn how to code!
11:07:35 <luite> pooya72: yay \o/
11:07:52 <pooya72> luite: thanks for your help. It's been hours....
11:08:11 <luite> i know how frustrating these problems cna be :p
11:08:20 <sm> http://darcs.haskell.org/packages/hpc.git/ ? that's just not right :)
11:08:21 <armlesshobo> so, do not all haskell libraries have shared objects?
11:08:34 <armlesshobo> because I can't build sometimes with the -dynamic flag
11:09:16 <armlesshobo> ghc even talks down to me, like "did you install the 'dyn' libraries for 'gtk-xxxxx', IDIOT?"
11:09:19 <armlesshobo> and then quits on me
11:10:14 <manish411> I just installed apache server on arch. Where can i find the directory www ?
11:10:25 <armlesshobo> in /var
11:10:27 <armlesshobo> manish411: ^
11:10:45 <armlesshobo> like it says in the configuration files
11:10:57 <timthelion> armlesshobo: objects? you mean like .hi files? or what kind of object?
11:11:05 <armlesshobo> timthelion: like *.so files
11:11:18 <manish411> it have the apache server running, but there is no sign of www in /var
11:11:21 <timthelion> armlesshobo: no, they do not.
11:11:32 <armlesshobo> manish411: check the config files
11:11:38 <manish411> ok
11:23:26 <barrucadu> manish411: If you haven't found it yet, /srv/http
11:23:46 <manish411> yes there this folder
11:23:53 <manish411> I thought so
11:25:03 <manish411> so in archlinux is /srv/http equivalent to  /var/www ?
11:25:31 <armlesshobo> not sure, archlinux isn't really 'linux'
11:25:32 <armlesshobo> :P
11:26:44 <gtmanfred> armlesshobo: sure it is
11:27:01 <armlesshobo> gtmanfred: right... :P
11:27:12 <gtmanfred> you have been hanging out with Psi-Jack and ##linux too much
11:27:26 <Siod> armlesshobo: http://en.wikipedia.org/wiki/Hypercorrection
11:27:36 <untitled> ktosiek: and how do I strip the actual type from this outter type, when I need to 'case' it? now I got "case reply of \n L (Just (Line _ _)) -> do \n blabla fromJust reply"
11:27:52 <parcs`> manish411: this is #haskell
11:28:34 <armlesshobo> wow, didn't expect people to get so butthurt :P
11:28:38 <ktosiek> untitled: replace _ with some names, they will be bound to the matched parts on the right side of "->"
11:28:40 <armlesshobo> i mean, "butthurt"
11:29:19 <gtmanfred> why do you consider it not linux
11:29:38 <monochrom> now I get butthurt, too :)
11:30:02 <untitled> ktosiek: I don't actually need them
11:30:14 <untitled> they are just params for Line constructor
11:30:30 <ktosiek> well, so now I'm confused
11:30:36 <dmwit> untitled: use L (Just foo@(Line _ _)) -> ...
11:31:01 <dmwit> > let foo@(x:y:rest) = [1..5] in (foo, x, y, rest)
11:31:02 <lambdabot>   ([1,2,3,4,5],1,2,[3,4,5])
11:31:24 <Siod> dmwit: are you good would callcc?
11:31:34 <untitled> I need to get the Line out of it :)
11:31:57 <monochrom> yeah, then it's dmwit's code
11:32:13 <dmwit> Siod: ENOPARSE
11:32:20 <Siod> wah?
11:32:45 <monochrom> but you must also be aware that you can further get the params of Line by a suitable pattern
11:32:46 * geekosaur assumes s/would/with/
11:33:23 <newsham> endoparse
11:33:26 <Siod> error no parse
11:34:00 <untitled> dmwit: thanks
11:34:01 <Siod> i guess dmwit hasn't heard of callcc
11:34:58 <monochrom> I think it's EACCES for "error, no access", so it's EPARSE for "error, no parse"
11:35:30 <newsham> mono: there are some inconsistent names.
11:35:38 <alshain> hey, I'd like to create a function which returns a tuple of a value, and another function, that function is supposed to return a value and a function, that function... etc, the problem that I have that the definition of the type is recursive
11:36:12 <monochrom> yeah heh
11:36:16 <alshain> that I have *is*, that...
11:36:21 <mekeor> let f = (5,f) -- ?
11:36:40 <newsham> EPERM v. ENOMEM for example
11:36:51 <alshain> mekeor: what if I wanted to add a type annotation?
11:36:58 <sipa> type MyType a r = \a -> (r, MyType a r)
11:37:15 <copumpkin> not allowed :)
11:37:32 <S11001001> alshain: that's a cofree (->)
11:37:38 <sipa> ok, use data and a constructor instead
11:37:43 <monochrom> you have to use a newtype wrapper, and keep wrapping and unwrapping. you're thinking an infinite type.
11:37:51 <S11001001> @hoogle Cofree
11:37:52 <mekeor> alshain: oh. oO dunno
11:37:52 <lambdabot> No results found
11:37:56 <alshain> sipa: what is "a"? Wouldn't that be a type ?
11:37:58 <S11001001> liar
11:38:00 <copumpkin> Siod: I think the issue was with your sentence, not callCC
11:38:06 <sipa> alshain: yes?
11:38:12 <monochrom> haskell doesn't take infinite types unless you throw in newtype
11:38:12 <mekeor> > let f = (5,f) in f
11:38:14 <lambdabot>   Occurs check: cannot construct the infinite type: t = (t1, t)
11:38:24 <Siod> ah s/would/with
11:38:28 <copumpkin> :)
11:38:32 <S11001001> http://hackage.haskell.org/packages/archive/free/2.1.1.1/doc/html/Control-Comonad-Cofree.html
11:38:35 <alshain> sipa: but.. I would not want the function to need a parameter I think, i.e. no a
11:39:02 <Siod> copumpkin: how about you, are you good with callcc?
11:39:09 <sipa> alshain: a function always takes a parameter...
11:39:34 <copumpkin> Siod: won't know until you ask your question :) ask the channel, and presumably someone who knows will answer :P asking specific people doesn't work as well
11:39:59 <Siod> copumpkin: it makes more difficult for the person i asked to ignore me
11:40:04 <Siod> :)
11:40:08 <copumpkin> Siod: yes, that isn't something you want
11:40:13 <alshain> hmm okay.. I just started today with LYAHGG
11:40:18 <copumpkin> because they recognize being put on the spot and will resent you for it
11:40:28 <copumpkin> which will not get you what you want
11:40:33 <Siod> copumpkin: if they can't help, that's fine with me
11:40:40 <copumpkin> anyway, ask the channel
11:40:43 <Siod> or even if they don't want to
11:41:04 <copumpkin> that's pretty standard IRC etiquette :)
11:41:15 <Siod> copumpkin: this is my secondary strategy after your recommendation failed
11:41:23 <copumpkin> ah, I missed the original question
11:42:14 <mekeor> alshain: notify me if you found a solution to your problem, please. it's exciting.
11:43:12 * hackagebot hledger-lib 0.18 - Core data types, parsers and utilities for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-lib-0.18 (SimonMichael)
11:43:14 * hackagebot hledger 0.18 - The main command-line interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-0.18 (SimonMichael)
11:43:16 * hackagebot hledger-web 0.18 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.18 (SimonMichael)
11:44:08 <mauke> Siod: it didn't fail, but if you call people who are trying to help you "annoying" and don't want to talk to them, that makes it a bit hard
11:44:26 <Siod> mauke: what you did wasn't help
11:44:38 <mauke> why not?
11:44:52 <monochrom> I don't think Siod has called anyone annoying. or did I miss an instance?
11:44:57 <dmwit> You did.
11:45:02 <dmwit> I was just reviewing that conversation. =P
11:45:19 <mauke> monochrom: 23 minutes ago
11:45:27 <Siod> mauke: let's see, i think my original question was what the type of notOk was; I asked if my assumptions was correct, and was trying to walk through the code
11:45:31 <monochrom> alright, don't call answerers annoying.
11:45:36 <mauke> monochrom: uh, and an hour
11:45:46 <Siod> mauke: and i think you basically just said 'no' to everything i had questions about with no further explanation
11:45:49 <S11001001> alshain: if you don't need an argument, you can just use Cofree Identity a, which has the value shape a <: Cofree Identity a.  But it works with any functor you like
11:45:59 <mauke> Siod: no, I first said 'ok' and 'yes' a few times
11:46:09 <mauke> Siod: then we got to the part were your assumptions were wrong and I said 'no'
11:46:17 <mauke> Siod: then I told you why and you said I was annoying
11:46:22 <Siod> mauke: you didn't say why
11:46:35 <monochrom> there is an unwritten social contract here that says "you don't call askers annoying, you don't call answerers annoying". I would think it's only fair and logical.
11:46:39 <mauke> <mauke> <mauke> Siod: how is notOk id?
11:46:41 <newsham> we try to be helpful and polite here.  but please keep in mind that people are offering help in their free time and please be greatful for the help you do get.
11:47:28 <byorgey> Siod only asked why once.  mauke explained.  Then Siod said something else wrong, mauke said 'no', and instead of asking why again Siod got annoyed.  <--- what it looked like to byorgey
11:48:26 <Saizan> Siod: anyhow, can you restate any question you still have?
11:48:43 <Saizan> Siod: i'm not finding it in my scrollback
11:48:48 <mauke> Siod: hah, not only did I explain to you what's wrong, you then started arguing with me about it. then: <Siod> mauke: you're not very convincing
11:49:14 <mauke> Siod: if you're already convinced your assumptions can't possibly be wrong, why ask for help at all?
11:50:16 <Saizan> well, sometimes one can be not very convincing just because he didn't offer enough of an explanation
11:50:53 <mauke> Saizan: <Siod> mauke: notOk is id  <mauke> Siod: no, it isn't  <Siod> mauke: you're not very convincing
11:51:19 <Saizan> right, "no, it isn't" wouldn't be very convincing to me
11:51:19 <dmwit> Okay, I think the metaconversation has gone far enough.
11:51:38 <monochrom> I would think the party who claims "notOk is id" is one who needs to give justifications
11:51:53 <mauke> monochrom: that's what the whole conversation before that was about!
11:52:04 <Saizan> i think it's better if anyone with a firmer grasp of the matter gives justification
11:52:09 <mauke> because I didn't understand the code or how notOk could possibly be id
11:52:22 <Siod> http://ideone.com/dLMBQ
11:52:27 <mauke> meanwhile I've understood what's going on and I can say with certainty that it isn't id
11:52:52 <newsham> is there an easy way to ask ghci what the type of some internal variable in an expr is?
11:53:13 <dmwit> newsham: Not really. You can use the ImplicitParams trick.
11:53:19 <dylukes> Put something of the wrong type there instead?
11:53:22 <dylukes> :)
11:53:28 <dylukes> And look at the type error.
11:53:36 <dmwit> :t map ?f [1..5]
11:53:37 <lambdabot> forall a b. (?f::a -> b, Num a, Enum a) => [b]
11:53:53 <dylukes> Lambdabot has holes?
11:53:58 <monochrom> it seems impossible to compare who has a firmer grasp
11:54:00 <dylukes> :t flip ?f
11:54:01 <lambdabot> forall (f :: * -> *) a b. (?f::f (a -> b), Functor f) => a -> f b
11:54:08 <mauke> Siod: String -> Cont r b
11:54:28 <newsham> dylukes: what if it is a variable binding you want the type of (ie. in siod's question, "what is the type of notok?")
11:54:40 <dylukes> *shrug* dunno :\
11:54:56 <Saizan> Siod: (notOk :: String -> Cont r b) there
11:55:05 <Siod> 12:12 <mauke> String -> Cont r Int?
11:55:06 <Siod> 12:13 <mauke> no, that can't be
11:55:25 <Twisol> dmwit: incoming question about the monad transformer from my Telnet writer before
11:55:36 <Siod> Saizan: thanks, is id called? i replaced it with test t a = t (show a ++ " tested") and the result was appended with tested
11:55:51 <newsham> i always thought it would be nice having an editor that you could click on any part of a haskell programa and get the type of the thing you selected
11:55:55 <dylukes> Out of curiosity, how is Netwire?
11:56:07 <Saizan> Siod: you mean in the commented out examples at the top?
11:56:16 <Twisol> dmwit: how do I "initialize" a new value of a monad transformer? Particularly this one: WriterT [Word8] (State WriterState)
11:56:35 <Siod> i called  runCont (divExcpt 10 2 error) (test print) and got "5 tested"
11:56:38 <dylukes> Twisol: You're thinking about it slightly wrong.
11:56:42 <dmwit> :t runState -- Twisol
11:56:43 <lambdabot> forall s a. State s a -> s -> (a, s)
11:56:47 <Siod> instead of  runCont (divExcpt 10 2 error) id
11:56:50 <dylukes> You just write the code in the transformer,
11:56:57 <dmwit> One of the arguments to the runFoo is the inital value.
11:57:03 <dylukes> and you have to unpeel it back to IO or a pure function.
11:57:21 <dylukes> with the run____ or un____ functions associated with it. These are also where the initial state is provided.
11:57:31 <Twisol> dylukes: right, I guess it's more of a "how do I get the initial value into the computation chain"
11:57:39 <dylukes> yeah, for that it'd be...
11:57:42 <dylukes> :t runWriterT
11:57:43 <lambdabot> forall w (m :: * -> *) a. WriterT w m a -> m (a, w)
11:57:47 <dylukes> :t runState
11:57:48 <lambdabot> forall s a. State s a -> s -> (a, s)
11:58:16 <hpaste> phil pasted “hint ghci crash” at http://hpaste.org/69213
11:58:24 <newsham> does ghci have the same "holes" feature that lambdabot does?
11:58:27 <dylukes> runWriterT . (`runState` initState)
11:58:34 <dylukes> :t runWriterT . (`runState` undefined)
11:58:35 <lambdabot>     Couldn't match expected type `WriterT w m a'
11:58:35 <lambdabot>            against inferred type `(a1, s)'
11:58:35 <lambdabot>     In the second argument of `(.)', namely `(`runState` undefined)'
11:58:38 <dmwit> newsham: -XImplicitParams, as I said before.
11:58:49 <newsham> dmwit: thank you, sorry, missed it
11:59:15 <byorgey> it's not really a "holes" feature.
11:59:18 <dylukes> well that should be WriterT w State s a -> ((a, s), w)
11:59:19 <mekeor> -XMultiParamTypeClasses (or how ever it's called) should be standard. -.-
11:59:20 <dylukes> I believe.
11:59:27 <byorgey> however, an honest-to-goodness holes feature is being worked on.
11:59:34 <Saizan> Siod: yeah, the second argument of runCont there is surely called if you call ok
11:59:55 <Siod> basically, notOk returns the string to the callCC at err <- and then id is run on the result of notOk
11:59:55 <dmwit> mekeor: Make a Haskell' proposal; maybe H2022 will have it standard. =)
12:00:04 <mekeor> ^^
12:00:16 <byorgey> mekeor: MPTCs is fairly uncontroversial. The problem is that to be useful, they often require FunctionalDependencies, which is controversial.
12:00:27 <Siod> now i don't understand how notOk returns to that callCC; how it breaks the execution
12:00:47 <Siod> so notOk is wrapped in some cont magic that i don't get
12:01:01 <mauke> not quite
12:01:05 <mauke> >>= is where the magic happens
12:01:07 <Saizan> Siod: you've to look at the implementation of callCC
12:01:13 <mauke> well, and that
12:01:21 <Twisol> dmwit, dylukes - thanks!
12:01:26 <dylukes> np
12:01:43 <monochrom> maybe you like to see my Cont examples (actually ContT examples) at http://www.vex.net/~trebla/haskell/cont-monad.xhtml
12:01:51 <dylukes> I still don't get why runState takes the monadic action before the initial state...
12:02:00 <dylukes> Same for ContT.
12:02:18 <Saizan> dylukes: because it's defined as a record accessor
12:02:24 <monochrom> becasue runStateT is the field name of the StateT "record"
12:02:31 <dylukes> Saizan: oh right.
12:02:42 <Twisol> ((runState . runWriterT) action initial) ended up working for me.
12:02:42 <Siod> do i need to understand n-rank polymorphism to get callcc?
12:02:44 <dylukes> but still, we could name that runStateT__ or something then to
12:02:51 <dylukes> runState = flip runStateTRecord
12:02:52 <Saizan> Siod: no
12:02:53 <dylukes> and export that.
12:02:57 <monochrom> I agree
12:03:10 * monochrom is not a fan of that field name anyway
12:03:12 <dylukes> Twisol: that works ,but I usually write the action afterwards
12:03:13 <dylukes> like...
12:03:16 <Saizan> Siod: at least, the callCC in mtl isn't defined with it, iirc
12:03:31 <dylukes> (`runState` init) . runWriterT $ do ...
12:03:46 <Saizan> Siod: arguably it should, but that's not so important wrt the runtime semantics
12:03:59 <Siod> k
12:04:11 * Siod reading monochrom's tut
12:04:17 <Twisol> dylukes: so you used runState as a section?
12:04:35 <dylukes> Yeah, it's really just identical to saying flipping it.
12:04:55 <dylukes> (flip runState init) == (`runState` init)
12:04:58 <Twisol> Seems a little opaque, but makes sense.
12:05:33 <dylukes> I doubt there's any performance benefit. The optimizer is smart.
12:06:56 <Twisol> What would be a good name for a function that returns the accumulated monoid from a Writer and replaces it with mempty?
12:07:13 <dylukes> const mempty :)
12:07:17 <mauke> flush
12:07:28 <dmwit> :t listen
12:07:30 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m a -> m (a, w)
12:07:43 <dmwit> not precisely the same
12:07:53 <dmwit> but may be useful anyway
12:07:56 <Paprikachu> when i run ghci, i get a segfault.
12:07:58 <Twisol> definitely, thanks
12:07:59 <sipa> const $ return mempty ?
12:07:59 <dylukes> const (return mempty) perhaps.
12:08:03 <Paprikachu> probably not what should happen.
12:08:09 <dylukes> sipa: beat you to it :p
12:08:14 <yrlnry> "spit".  And the corresponding function that returns unit and also replaces the current value with mempty could be "swallow".
12:08:20 <Paprikachu> $ ghci
12:08:21 <Paprikachu> GHCi, version 7.4.1: http://www.haskell.org/ghc/  :? for help
12:08:23 <Paprikachu> Loading package ghc-prim ... linking ... done.
12:08:24 <Twisol> yrlnry: Hahah.
12:08:25 <Paprikachu> Loading package integer-gmp ... linking ... done.
12:08:27 <Paprikachu> Loading package base ... linking ... done.
12:08:28 <Paprikachu> Segmentation fault
12:08:32 <dylukes> yrlnry: And you use "gargle" for exceptional cases when things are going strangely.
12:08:43 <Twisol> Wouldn't that be choke?
12:08:51 <yrlnry> Now that's not nice.
12:08:52 <sipa> dylukes: from my point of view, i was first - IRC is not synchronous
12:08:53 <dylukes> gargle is for non-fatal errors.
12:09:01 <dylukes> sipa: true.
12:09:12 <dylukes> I see both as at 15:07:37
12:09:23 <Twisol> What is const?
12:09:28 <byorgey> there's no way to replace the accumulated log in a Writer.  If you want to do that, then you need State.
12:09:29 <dylukes> :t const
12:09:30 <lambdabot> forall a b. a -> b -> a
12:09:34 <dylukes> :t const 0
12:09:35 <lambdabot> forall t b. (Num t) => b -> t
12:09:37 <sipa> dylukes: i see both as 21:07:37
12:09:38 <dylukes> > const 0 undefined
12:09:39 <lambdabot>   0
12:09:42 <monochrom> IRC enjoys most consequences of relativity, e.g., "who said it first" depends on observer
12:09:46 <dylukes> > const 0 whoevencares where whoevencares = undefined
12:09:47 <lambdabot>   <no location info>: parse error on input `where'
12:10:07 <Twisol> > const 0 whoevencares ; where whoevencares = undefined
12:10:07 <lambdabot>   <no location info>: parse error on input `;'
12:10:11 <Twisol> aw.
12:10:28 <dylukes> @src const
12:10:28 <lambdabot> const x _ = x
12:10:29 <byorgey> 'where' may only be attached to declarations
12:10:31 <dylukes> simple enough.
12:10:39 <Twisol> ah, okay.
12:10:39 <yrlnry> monochrom:  there's a famous Leslie Lamport paper about the concept of simultaneity in distributed computer systems.
12:11:10 <monochrom> yeah, that too. I took two grad-level distributed computing courses (theoretical)
12:11:25 <dmwit> byorgey: It can't be done from within Writer, but it can be done from outside Writer.
12:12:16 <dmwit> e.g. flush (WriterT (Id (w,a))) = WriterT (Id (mempty, w))
12:12:34 <Twisol> so is Writer a poor fit for accumulating a buffer of data that needs to be sent?
12:12:49 <dmwit> I think it's a wonderful fit.
12:13:02 <Twisol> that's good then :P
12:13:35 <nand`> you can “reset” the log of a writer action by not binding the two writer actions; but by invoking them separately
12:13:39 <mauke> I have reconsidered your question and the answer is runWriter
12:13:54 <byorgey> when you're ready to send the data, use runWriter to extract the buffer contents and send it.  Then start a new Writer computation for accumulating the next buffer-full of data.
12:14:09 <dmwit> yes
12:14:24 <dylukes> So, a quick question...
12:14:34 <markus3> hi #haskell! is there a way to disable Template Haskell messages when running code that has TH in it?
12:14:38 <dmwit> These suggestions smell much less than "flush" does. =)
12:14:39 <dylukes> could one say Writers are related to anamorphisms in the same way Readers are related to catamorphisms?
12:14:41 <Twisol> I'll also have to juggle the inner State monad that should persist, though.
12:15:20 <markus3> I have a cgi script to run, and the TH stuff printed at the front doesn't work well with apache..
12:15:58 <markus3> I'm running the script as runhaskell [script name]
12:16:01 <monochrom> I am not even convinced how Readers are related to catamorphisms
12:16:04 <dmwit> markus3: compile it
12:16:16 <byorgey> dylukes: how are Readers related to catamorphisms? Just because the type of a Reader compuation is   r -> a, which could be implemented by a catamorphism on r?
12:16:30 <dylukes> Fair yeah.
12:16:43 <byorgey> dylukes: then the answer is no.  an anamorphism is  a -> r.
12:17:00 <navaati> hey, no haskell platform this month ?
12:17:04 <c_wraith> I still have no clue how the heck Control.Monad.ST.Lazy actually works. I've come as far as figuring out it has the same order of effect execution as non-lazy ST. But the implementation of it baffles me.
12:17:23 <byorgey> dylukes: the cata/ana duality is switching direction of arrows.  the reader/writer duality is adjunction.
12:17:31 <byorgey> two common sorts of duality but not the same.
12:17:37 <dylukes> Elaborate? (perhaps in blah)
12:17:44 <dylukes> I'm not quite clear on what adjunction is here.
12:18:01 <byorgey> dylukes: how about #haskell-in-depth, it's off-topic for -blah =)
12:18:22 <navaati> isn't there a #category-theory ?
12:18:53 <markus3> dmwit: compiling is a bit slow..
12:19:09 <markus3> that's why I thougth to have it be runhaskell
12:19:18 <dmwit> wut
12:19:28 <dmwit> Compile it once. Run it many times.
12:19:43 <markus3> yes :) but I am changing it
12:19:55 <markus3> very often atm
12:19:59 <markus3> linking is slow
12:20:58 <markus3> compiling is as fast as a "runhaskell"-go
12:22:04 <monochrom> we could argue for years which way is faster, but... I would think, under the circumstance, if you want stdout to not have some stuff, you have no choice anyway
12:22:30 <monochrom> "if it doesn't have to be correct, I can make it 100x faster"
12:23:02 <monochrom> there is really no two speeds to choose from if correctness gives you only one choice
12:23:51 <dmwit> Well, it at least motivates the original question.
12:23:58 <dmwit> ...to which I don't know the answer.
12:24:02 <markus3> well as I'm changing the script, then runhaskell-ing it is below a second, compiling and linking it is something like 10
12:24:21 <Twisol> If I have a monad like WriterT [Word8] (State WriterState), is it correct to say that the State has been augmented by Writer, rather than the Writer being augmented by State?
12:24:26 <c_wraith> markus3: that's the difference between interpreting and compiling.
12:24:26 <markus3> it's the linking phase which is unbearably slow
12:24:49 <markus3> yep, I will compile it, when the code doesn't change anymore
12:25:21 <monochrom> are you using yesod? so that you need TH?
12:25:24 <Paprikachu> > cycle "nag "
12:25:25 <lambdabot>   "nag nag nag nag nag nag nag nag nag nag nag nag nag nag nag nag nag nag na...
12:26:05 <markus3> I'm using web-routes and boomerang to derive printer-parsers
12:26:36 <markus3> it says "Introducing router rXxx" for every data constructor
12:26:48 <byorgey> Twisol: For Writer and State in particular, it doesn't matter, since they commute
12:27:03 <byorgey> Twisol: that is,  WriterT w (State s)  is isomorphic to  StateT s (Writer w)
12:27:04 <monochrom> is that really stdout? or stderr?
12:27:33 <byorgey> Twisol: but for some transformers the order does matter.  In that case you can use lambdabot's handy @unmtl command to figure out what they do
12:27:45 <byorgey> @unmtl WriterT [Word8] (State WriterState) a
12:27:45 <lambdabot> WriterState -> (a, [Word8], WriterState)
12:27:55 <Twisol> byorgey: The result of this surprised me: (runState . execWriterT) (writeTelnetCommand 200) Plaintext
12:27:57 <c_wraith> ... except it does that.
12:27:59 <Twisol> ended up being: ([255,200],Plaintext)
12:28:09 <Twisol> which is my writer's accumulator and the state's… state.
12:28:10 <c_wraith> for whatever reason, @unmtl flattens nested tuples
12:28:30 <luite> markus3: that's exactly why yesod devel uses runhaskell instead of producing an executable every time
12:29:41 <byorgey> Twisol: I would have to see the definition of writeTelnetCommand to explain that.
12:30:02 <Twisol> byorgey: It's less the contents and more the structure
12:30:05 <byorgey> Twisol: oh, wait, no I don't.  Why does that surprise you?
12:30:22 <Twisol> It seems as though WriterT bundled the accumulator up inside the State's data.
12:30:38 <Twisol> Which is why I was asking who augments who.
12:30:42 <byorgey> @type execWriterT
12:30:43 <lambdabot> forall w (m :: * -> *) a. (Monad m) => WriterT w m a -> m w
12:31:07 <byorgey> execWriterT  results in a State computation which returns the accumulator as its result.
12:31:29 <byorgey> @type runState
12:31:30 <lambdabot> forall s a. State s a -> s -> (a, s)
12:31:47 <byorgey> runState will then return the result (which in this case will be the Writer's accumulator) paired with the state.
12:31:58 <favonia> hi all, I am using TH to generate a top-level datatype declaration (through newName) happily in GHC 7.4. Unfortunately I need/want to support older GHCs, which are suffering from bug #5037; this bug which makes newName absolutely uncapturable. Is there any workaround for older GHCs?
12:32:00 <Twisol> Right. It's not that kind of "surprised".
12:32:15 <Twisol> It's a "this type isn't what I thought it was" surprised.
12:32:32 <byorgey> Twisol: I don't understand.
12:32:53 <Twisol> because you do understand, and I'm a novice. S'okay, it's not a big deal. :D
12:32:57 <byorgey> are you still confused, or you're just saying that you *were* surprised but now you understand?
12:33:15 <angstrom> is use of recursive modules frowned upon?
12:33:18 <Twisol> I was surprised by the outcome, yes. I don't know what I -was- expecting.
12:33:25 <byorgey> Twisol: ok =)
12:33:30 <Twisol> Thanks!
12:33:36 <favonia> (I meant the ticket #5037 http://hackage.haskell.org/trac/ghc/ticket/5037 )
12:34:52 <byorgey> Twisol: however, in general given  FooT Bar   I would say that Bar is augmented with Foo.
12:34:52 <markus3> monochrom: now that I look at it, it's not stdout, and not stderr (I think). Piping the script dosen't show it, nor does redirecting the stderr into a file
12:35:31 <monochrom> that's very strange. breaks the law of the excluded middle!
12:36:35 <monochrom> recursive modules is just more work for you in ghc. not frowned upon.
12:36:36 <Twisol> "if it's not this, it's that"?
12:36:42 <monochrom> yeah!
12:39:00 <markus3> not an expert on this, but don't some programs write their text somehow to the controlling terminal (or something). I.e you can't pipe some programs help output into less
12:39:39 <favonia> monochrom: well, LEMs are just donuts, and everyone can break it into halfs
12:39:53 <angstrom> monochrom: was just wondering, since it, indeed, seems kindof tedious
12:40:05 <gdoteof> i have [Foo]  and foo2Int :: Foo -> Int   how can i fold a [Foo] summing with foo2Int ?
12:40:11 <markus3> I don't remember what progams, but they were some common unix tools I think..
12:40:28 <tromp_> sum . map foo2Int
12:41:11 <gdoteof> sum . map foo2Int listOfFoos ?
12:41:31 <tromp_> sum . map foo2Int $ listOfFoos
12:41:55 <Twisol> Cool, I have a Telnet writer monad. >:D
12:42:05 <geekosaur> markus3, you may be thinking of standard error, which can be redirected (just not in a friendly way, except in some shells and even then only along with standard output)
12:42:55 <c_wraith> markus3: programs can also detect whether stdout is a tty or not, then alter their behavior based on that.
12:43:27 <geekosaur> foo 2>&1 | less # stdout and stderr to pipe, Bourne-compatible shells
12:43:39 <geekosaur> foo |& less # same in csh, tcsh, and zsh
12:45:03 <geekosaur> (there are programs which open the tty directly, but this is used primarily for passwords and such)
12:45:12 <favonia> gdoteof: he was using pointless style
12:45:23 <favonia> @pl sum (map f l)
12:45:24 <lambdabot> sum (map f l)
12:45:33 <favonia> @pl \l -> sum (map f l)
12:45:34 <lambdabot> sum . map f
12:45:34 <markus3> yep, I think "man --help" sends its help into stderr -- piping stdout to less dosn't show anything
12:45:43 <sipa> @pl \f l -> sum (map f l)
12:45:43 <lambdabot> (sum .) . map
12:46:07 <geekosaur> it's quite common for help output to go to stderr, yes.
12:47:00 <redscare> is there a 64-bit version of ghc for windows?
12:47:41 <dmwit> redscare: not yet
12:47:47 <dmwit> Real Soon Now =)
12:48:14 <redscare> thank you
12:53:23 <Twisol> In general, should I prefer long names that are more likely to be unique, or short names and assume the module will be imported qualified?
12:54:36 <monochrom> toss a coin
12:54:43 <aristid> Twisol: if you want people to import qualified, make sure to have as many name clashes as possible :D
12:54:53 <S11001001> don't name operations
12:55:34 <Twisol> S11001001: What do you mean?
12:56:31 <S11001001> explain everything in terms of instantiating existing typeclasses, and you don't have to name anything but your types :)
12:57:04 <Twisol> that sounds slightly too advanced for me :/
12:57:19 <dmwit> Twisol: Do: use descriptive names. Don't: prefix all your names with something you think will be unique.
12:57:23 <monochrom> don't name types either. just say how you compose ground types, sum types, product types, function types
12:57:39 <dmwit> Also, don't: listen to these other guys, they're having a laugh.
12:57:46 <copumpkin> don't forget dependent sum and product
12:57:51 <RylandAlmanza> How do I export a typeclass in a module?
12:57:53 <Twisol> I had a feeling, but wasn't sure :P
12:58:07 <monochrom> module Mine(MyClass(..)
12:58:25 <Twisol> dmwit: So far, everything is writeTelnet*, because that's what they do but for different types of data. And one clearCR.
12:58:30 <favonia> and universe polymorphism
12:58:30 <RylandAlmanza> thanks, monochrom. So it's just like exporting a datatype, then?
12:58:34 <monochrom> I am serious about "toss a coin".
12:58:40 <monochrom> yes
12:59:28 * dmwit savors http://stackoverflow.com/questions/10800341/need-comments-for-haskell-win32-createwindow-and-events-code#comment14060231_10800341 a bit
13:00:53 <dmwit> Twisol: "go with your heart"
13:01:04 <Twisol> haha. Fair enough.
13:01:09 <monochrom> I coined that, too
13:01:09 <dmwit> Personally, I'd drop it. But there's some question of aesthetics that somehow not all programmers agree on.
13:01:17 <dmwit> monochrom: I know, I love it so much.
13:01:30 <monochrom> it really depends on the actual library
13:01:47 <Twisol> for most purposes, this particular module will be internal anyways
13:01:47 <dmwit> monochrom: You need to license it. CC-BY-SA or something
13:02:18 <jfischoff> dmwit:there should be a best of stack overflow like the best of craigslist
13:02:52 <dmwit> I'd subscribe. =D
13:03:03 <jfischoff> I'd add that one :D
13:03:12 <newsham> ?remember aristid if you want people to import qualified, make sure to have as many name clashes as possible :D
13:03:13 <lambdabot> Good to know.
13:03:47 <leino> I am using trifecta to parse some stuff. I have been using the function parseFromFile. why can I not find a parseFromString? is not supported to parse directly from a string in trifecta?
13:03:51 <newsham> head = undefined; (:) = undefined -- import qualified!
13:04:20 <favonia> undefined = ()
13:04:23 <Twisol> So, uh. Is it okay to be using a Writer as part of a type called TelnetReader? :P
13:04:29 <newsham> heh
13:04:38 <newsham> ?let undefined = () in undefined
13:04:38 <lambdabot>   Parse error: in
13:04:50 <newsham> >let undefined = () in undefined
13:04:53 <newsham> > let undefined = () in undefined
13:04:54 <lambdabot>   ()
13:06:38 <monochrom> it is not an irony to use LossyDatagram as part of an implementation of LosslessStream. if you know what I mean
13:07:21 <edwardk> leino: its more of an omission by apathy than by design
13:07:39 <leino> edwardk: ah ok
13:08:13 <leino> I gess I can do System.Process.shell $ "echo " ++ myString   :)
13:08:33 <leino> *guess
13:09:08 <startling> so what do I use for applying data to templates? like, i want a user to supply some html with spots for data and I want to put my data in there.
13:09:18 <startling> "template haskell" clogs up google
13:09:21 <hpc> leino: why not putStrLn?
13:09:36 <monochrom> "template haskell" means something else
13:10:05 <startling> monochrom: i know, but it makes it hard to find what i'm looking for
13:10:12 <Twisol> startling: are you using a framework of some kind?
13:10:38 <startling> Twisol, nope, generating static html
13:10:54 <leino> hpc: I meant, in order to get a file from my string
13:11:03 <dmwit> writeFile?
13:12:00 <leino> dmwit: yeah, that would also work
13:12:02 <hpc> @hoogle replace
13:12:03 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Environments Replace :: TextureFunction
13:12:03 <lambdabot> Data.Text replace :: Text -> Text -> Text -> Text
13:12:03 <lambdabot> Data.Text.Lazy replace :: Text -> Text -> Text -> Text
13:12:29 <leino> but that gives me an actual physical file, right?
13:13:15 <hpc> startling: use replace perhaps
13:13:54 <`Jake`> At http://www.haskell.org/haskellwiki/Data_Parallel_Haskell#Where_to_get_it they say hat Data-Parallel Haskell is available as an addon for GHC 7.4. They don't mean that it's available _since_ 7.4, do they?
13:13:58 <Siod> fucking hell, trying to understand how callcc is implemented is doing my head in
13:15:50 <monochrom> I understood it by implementing it myself instead of reading an existing implementation. YMMV
13:16:20 <`Jake`> I just noticed that they don't by looking at the history. I should have done that earlier.
13:17:34 <Siod> callCC f = Cont $ \k -> runCont (f (\a -> Cont $ \_ -> k a)) k <-- what is (\a -> Cont $ \_ -> k a)?
13:22:55 <hpc> Siod: it's a Cont action that when called, ignores the current continuation and terminates
13:23:23 <hpc> with the value (k a)
13:31:02 <leino> Siod: I read about someone making the case once that callCC is pointless in pure computations. can't remember who and didn't understand the argument, but if that person is was then maybe you should do look at some Scheme code if you want to understand call/cc?
13:31:42 <leino> is was -> was right   :)
13:31:52 <parcs`> Siod: it helps to remove the newtype noise: callCC f = \k -> f (\a _ -> k a) k
13:34:40 <Siod> http://stackoverflow.com/questions/9050725/call-cc-implementation
13:37:47 <RylandAlmanza> monochrom: Still here? When I export a typeclass, does that export all instances as well, or do I export instances seperately?
13:38:59 <acowley> instances are always exported without you doing anything
13:39:14 <RylandAlmanza> alright, thanks, acowley. :)
13:39:23 <tgeeky_> in fact, you can't stop them from being exported
13:39:49 <tgeeky_> so the "without you doing anything" is unnecessary, being pedantic. Is this right acowley?
13:40:18 <acowley> tgeeky_: Yes, I wanted to clarify that RylandAlmanza shouldn't try to explicitly export his instances
13:40:32 <acowley> explicit is the norm in Haskell; instances are exception
13:40:43 <acowley> are *the* exception
13:41:39 <coppro> see also Control.Monad.Instances ;)
13:43:26 <kstt> hi
13:43:35 * hackagebot hledger-interest 1.4.1 - computes interest for a given account  http://hackage.haskell.org/package/hledger-interest-1.4.1 (PeterSimons)
13:45:06 <coppro> What is [::] ?
13:45:50 <acowley> coppro: where did you encounter that?
13:46:02 <coppro> acowley: Control.Monad.Instances has an instance for Monad [::]
13:46:46 <coppro> at least, the docs say it do
13:46:51 <acowley> I don't see that in the docs?
13:46:59 <acowley> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.5.0.0/Control-Monad-Instances.html
13:47:19 <coppro> Blah, I was using an older version
13:47:39 <Clint> link?
13:47:57 <coppro> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Monad-Instances.html
13:49:19 <acowley> My guess is it's a haddock bug/typo
13:50:07 <kstt> I need an advice for my next haskell-powered website. It will respond to requests concurrently, of course. In the process of building a response, the handler needs to read a data structure that is quiet expensive to build (retreive data from database and build a complex map). This data structure is cachable so it should be shared across concurrent handlers.
13:50:43 <acowley> kstt: one option is to put the data structure in an MVar that is in scope for all handlers
13:51:00 <kstt> Yes, but I want cheap reading and automatic pausing of readers if a thread decides to update it
13:51:50 <kstt> IOW, takeMVar it not ideal because I would need to put the data back right after reading it.
13:52:09 <kstt> and readMVar has the same problem of course
13:52:24 <acowley> How about using TMVar then? You might not get client pausing, but affected readers would restart
13:52:55 <kstt> why not, but certainly a bit overkill
13:53:17 <acowley> I think it's worth trying as it would keep your code super simple
13:53:34 <acowley> everyone is so wary of STM performance (me included) :/
13:54:44 <kstt> actually, a simple IORef + atomicModifyIORef would be almost perfect
13:55:20 <bas_> how do I write this without do notation:
13:55:25 <hpaste> bas pasted “How do I write this without” at http://hpaste.org/69219
13:55:45 <kstt> the only drawback is that there is no way for a thread to say "hey, I'm going to update this data, please hang on a moment and wait till I finish"
13:56:15 <joelr> where is the source code for System.Environment (base libs)?
13:56:51 <acowley> bas: maybe something like, ((,) <$> (length <$> try indents) <*> try selector) <* newline
13:57:17 <bas_> ah I didn't know about the <*
13:57:19 <bas_> thanks
13:58:38 * hackagebot hscolour 1.20.2 - Colourise Haskell code.  http://hackage.haskell.org/package/hscolour-1.20.2 (MalcolmWallace)
14:01:26 <fmap> joelr: http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/src/System-Environment.html
14:01:35 <joelr> fmap: thanks
14:02:47 <bas_> yes acowley that works just fine, I should look into Applicative. So far I've most used liftM and the like
14:03:45 <acowley> bas_: Applicative is great for plumbing functions through effects.
14:09:38 <bas_> feels very natural to write as well
14:11:00 <acowley> Yes, I think of applicative operators as fancy whitespace: you write a sentence f a b c d, and then tart up the whitespace without moving any pieces around.
14:11:30 <S11001001> I would like up to liftA50 please in base
14:12:08 <`Jake`> does anyone know how to fix the error "* Missing C library: GL"? I get it when I try to instal OpenGLRaw
14:12:30 <adamt> is it possible to import stuff a bit like this: `import Foo.Bar (quux as q)'?
14:13:04 <bas_> import qualified Foo.Bar.quux as q ?
14:13:44 <fmap> `Jake`: what OS are you using?
14:13:55 <`Jake`> fmap: Ubuntu 12.04
14:15:02 <adamt> bas_: oh, wasn't aware you could just nest deeper. Thanks :)
14:15:48 <dschoepe> `Jake`: You need to install the ubuntu package containing the C header files for opengl.
14:16:07 <monochrom> no, the right syntax is import Foo.Bar as q (quux)
14:16:23 <monochrom> sorry, that's also wrong
14:16:29 <geekosaur> monochrom, I think they want to rename individual functions, not the whole module
14:16:41 <monochrom> import Foo.Bar as Q (quux) . and the result is you have Q.quux
14:16:59 <`Jake`> dschoepe: ok, thanks, I'll try that
14:17:40 <monochrom> unfortunately, renaming individual things is not allowed
14:19:03 <adamt> monochrom: So no importing a single function and renamed it? Aww.
14:19:04 <acowley> But you can always define q = Q.quux in the module where you want to use that alias.
14:19:10 <hpaste> phil pasted “hiernotify not working” at http://hpaste.org/69222
14:19:19 <adamt> acowley: Oh. Good point. Thanks all.
14:20:57 <mcstar> hey!
14:21:23 <mcstar> did somebody call my name?
14:25:15 <mcstar> > Data.IORef.newIORef [] >>= \r -> Data.IORef.writeIORef r [1] >> Data.IORef.readIORef r
14:25:16 <lambdabot>   Not in scope: `Data.IORef.newIORef'Not in scope: `Data.IORef.writeIORef'Not...
14:25:21 <mcstar> bleh
14:25:59 <mcstar> i would like to ask, why does this not work, when i do this in ghci, and break up the expressions?
14:26:15 <hpc> monomorphism restriction?
14:26:35 <mcstar> hpc: No instance for (Num (GHC.Prim.Any *)) this is what i get
14:26:52 <mcstar> the inferred type of r is IORef [GHC.Prim.Any *]
14:27:03 <mcstar> and i cant do anything with that IORef after that
14:27:14 <hpc> wat
14:27:34 <acowley> mcstar: are you entering the parts on separate lines?
14:27:38 <monochrom> ghci aggressive type-defaulting. add more type annotations
14:27:54 <acowley> what monochrom said
14:28:06 <mcstar> hm
14:28:20 <mcstar> ok, so this should work in a real program
14:29:10 <monochrom> and ghci has to be that aggressive because when you enter "newIORef []" alone, ghci has to make a typing decision immediately, and based on no knowledge of the future
14:29:36 <mcstar> im discussing monomorphism in #ocaml, if someone knows the differences of the 2 languges wrt this, id like to hear it
14:30:09 <mcstar> monochrom: yeah, that is solved in ocaml with an existential type if im correct
14:30:42 <mcstar> IORef ('a list) => IORef ('_a list)
14:30:48 <mcstar> in pseudocode
14:31:51 <otters> @pl \x -> x - 1
14:31:51 <lambdabot> subtract 1
14:32:54 <dmwit> otters: You might wish it was (- 1), right?
14:33:00 <dmwit> unfortunately no =)
14:33:19 <hpc> > (- 1)
14:33:19 <lambdabot>   -1
14:33:39 <joelr> does anyone know how to mark arguments as required with CmdArgs?
14:33:42 <monochrom> > (- 1) 0
14:33:42 <lambdabot>   -1
14:33:46 <`Jake`> what does @pl do?
14:33:54 <mcstar> short for poland
14:33:55 <acowley> > flip (-) 1 $ 5
14:33:57 <lambdabot>   4
14:33:58 <DrSyzygy> jamiltron: It's pointless.
14:33:58 <otters> dmwit: god damned unary minus
14:34:03 <`Jake`> mcstar: ah, that makes sense
14:34:17 <otters> `Jake`: removes function points
14:34:19 <jamiltron> DrSyzygy: What?
14:34:21 <otters> @pl \x -> f x
14:34:22 <lambdabot> f
14:34:28 <`Jake`> otters: alright, thanks
14:34:35 <otters> @pl \(x,y) -> f (x,x) (y,y)
14:34:36 <lambdabot> uncurry ((. join (,)) . f . join (,))
14:35:13 <dmwit> It also does optimization.
14:35:19 <dmwit> ?pl id id id ap id ap ap ap id id
14:35:23 <lambdabot> (ap `ap` id) (ap id) id
14:35:23 <lambdabot> optimization suspended, use @pl-resume to continue.
14:35:46 <`Jake`> ok
14:35:52 <monochrom> @pl-resume
14:35:58 <lambdabot> (ap `ap` id) (ap id) id
14:35:58 <lambdabot> optimization suspended, use @pl-resume to continue.
14:36:13 <dmwit> Lucky me, an infinite loop on my first try.
14:36:20 <otters> ?pl id id id id
14:36:21 <lambdabot> id
14:36:25 <otters> no way
14:36:26 <mcstar> dmwit: how do you know it wont halt?
14:36:46 <hpc> :t (ap `ap` id) (ap id) id
14:36:46 <monochrom> dmwit used this package:
14:36:47 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
14:36:47 <lambdabot>     Probable cause: `id' is applied to too few arguments
14:36:47 <lambdabot>     In the second argument of `ap', namely `id'
14:36:47 <dmwit> mcstar: My semi-decision procedure returned and said "won't halt".
14:36:52 <monochrom> @hackage HaltingSolver
14:36:53 <lambdabot> http://hackage.haskell.org/package/HaltingSolver
14:37:06 <hpc> :t id id id ap id ap ap ap id id
14:37:07 <lambdabot>     Occurs check: cannot construct the infinite type:
14:37:07 <lambdabot>       a = (a -> a1) -> a -> b
14:37:07 <lambdabot>     Probable cause: `id' is applied to too many arguments
14:37:24 <mcstar> dmwit: it must have a powerful orcale
14:37:42 <monochrom> it's why oracle bought sun :)
14:37:48 <dmwit> There's no oracle, or else it wouldn't need to be a *semi*-decision procedure. =)
14:38:03 <tgeeky_> it's an oracle with a bottle of jack
14:38:47 <otters> I have two threads created by forkIO that occasionally print to stdout at the same time so the characters get interspersed
14:38:51 <otters> Can I somehow prevent this
14:38:58 <mcstar> yes
14:39:01 <dmwit> take a lock
14:39:14 <dmwit> write your lines to a chan and have a third thread print from the chan
14:39:44 <otters> oh
14:39:51 <mcstar> or you could have multiple output channels
14:40:03 <mcstar> and print to different partsof the screen
14:40:08 <strager> I'd keep to each handle being manipulated by only one thread.
14:40:10 <otters> that would be awesome
14:40:19 <otters> I don't know how to do that though
14:40:44 <dmwit> The simplest way to do that still involves three threads.
14:40:53 <strager> Use chans as dmwit suggested.
14:40:57 <otters> okay chans
14:40:57 <dmwit> Unless ncurses is threadsafe, which I kind of doubt.
14:41:01 <strager> (channels; a form of message passing)
14:41:11 <otters> I really don't think I want to put ncurses into this project for that sole purpose
14:41:21 <otters> so chans it will be
14:41:22 <dmwit> Definitely not.
14:42:10 <dmwit> Threads are wonderful, use lots of them.
14:42:17 <monochrom> you can use locking too. MVar is suitable for this
14:42:22 <mcstar> im sure it could be done with 2 open terminals
14:42:37 <dmwit> Yes, I meant my first two lines to be separate suggestions.
14:42:44 <otters> can I make a top-level Chan with unsafePerformIO as long as I write/read from it in the IO monad?
14:42:45 <dmwit> But I think using a Chan is cleaner.
14:42:53 <dmwit> otters: ew, no
14:43:00 <otters> fiiiine
14:43:03 <dmwit> Make it before you fork your threads and pass it along.
14:43:22 <otters> Okay
14:45:24 <geekosaur> ncurses is really not threadsafe; there was no point in making its internals threadsafe because it uses a serial protocol to update the terminal so there is by necessity only a single cursor position where updates happen
14:45:26 <angstrom> is there a way to use deriving with recursive modules?
14:46:23 <hpc> geekosaur: you can make it threadsafe by smushing parallel input into a single Chan
14:46:26 <hpc> in theory
14:46:55 <dmwit> angstrom: Why don't you describe the problem you're having instead of making us try to guess it?
14:47:08 <dmwit> ?hpaste is preferable
14:47:09 <lambdabot> Haskell pastebin: http://hpaste.org/
14:47:44 <geekosaur> hpc, you cannot make the terminal its writing to have multiple write positions, or safely interrupt one output sequence to do another
14:48:15 <hpc> ah
14:50:10 <geekosaur> curses is quite primitive, there's not a lot of point in trying to make it threadsafe
14:51:08 <hpc> it could make a decent threading exercise
14:51:24 <kkyqqp> is there a good way to iterate over a pair of infinite values such that the second value is incremented as the first increases, instead of the first going to infinity? what I mean is iterating (0,0), (1,0),(1,1),(2,0),(2,1),(2,2), instead of (0,0),(1,0),(2,0),(3,0)?
14:52:11 <dmwit> > [(x,y) | x <- [0..], y <- [0..x]]
14:52:12 <lambdabot>   [(0,0),(1,0),(1,1),(2,0),(2,1),(2,2),(3,0),(3,1),(3,2),(3,3),(4,0),(4,1),(4...
14:52:32 <mdmkolbe> When I do ":m +Char" in GHCi, it says it can't find module Char.  I thought "Char" was a standard module.  Is there some flag I'm missing?  (I know about Data.Char, but I'm trying to compile code generated with "happy" that uses "import Char".)
14:52:44 <kkyqqp> thanks dmwit!
14:52:55 <dmwit> mdmkolbe: -XHaskell98
14:53:06 <hpc> mdmkolbe: or update happy, or something
14:53:12 <dmwit> or -package haskell98
14:53:18 <hpc> if you're at the latest version, report a bug
14:53:38 <hpc> (happy might be one of those "don't update this" ghc things)
14:53:58 <monochrom> fortunately, no, you're free to update happy
14:54:00 <dmwit> Upgrading happy is safe and productive.
14:54:15 <monochrom> and happy
14:54:16 <armlesshobo> and it gives you a feel-good feeling
14:54:22 <armlesshobo> that feels good
14:54:31 <dmwit> =)
14:54:59 <mdmkolbe> this is a darcs version from a few weeks ago
14:55:24 <armlesshobo> download and do everything by hand.
14:55:28 <armlesshobo> it'll make you feel good
14:57:25 <mdmkolbe> dmwit: "-package haskell98" gives me an error about Prelude being in both "base" and "haskell98".  Do I need to hide something?
14:58:16 <rwbarton> hide base I suppose?
14:58:22 <hpc> mdmkolbe: use the -X flag
14:58:35 <hpc> it should Just Work(TM)
14:59:22 <mdmkolbe> hpc: -XHaskell98 reports package "Char" not found.
15:00:22 <dmwit> That can't be the real error.
15:00:27 <dmwit> Char isn't a package.
15:03:21 <zezikaro> Is it possible to load a haskell map from a txt file?
15:03:33 <strager> zezikaro: read
15:03:36 <mdmkolbe> dmwit: d'oh.  The "import Char" was comming from the header of the example I was running through happy, and not happy itself.  (Someone needs to update happy/examples/Calc.ly to use Data.Char instead of Char.)
15:04:02 <strager> > show $ M.fromList [(1,2), (3,4)]
15:04:03 <lambdabot>   "fromList [(1,2),(3,4)]"
15:04:11 <strager> > read "fromList [(1,2),(3,4)]" :: M.Map
15:04:12 <lambdabot>   Expecting an ordinary type, but found a type of kind * -> * -> *
15:04:18 <strager> > read "fromList [(1,2),(3,4)]" :: M.Map Int Int
15:04:20 <lambdabot>   fromList [(1,2),(3,4)]
15:04:32 <dmwit> zezikaro: How important is speed?
15:04:55 <strager> Or you can use JSON or something if you want to talk to other programs.
15:05:57 <dmwit> (If speed matters, you can get an order of magnitude better performance by writing a real parser instead of using read(s). Otherwise, read is very simple and works.)
15:06:40 <hpc> and if speed still really matters, maybe try acid-state or something
15:07:07 <hpc> (acid-state is useful for different reasons than speed though...)
15:08:10 <hpaste> angstrom pasted “deriving with recursive modules” at http://hpaste.org/69226
15:08:47 <zezikaro> dmwit Thanks
15:08:54 <zezikaro> is it better to use let ... in
15:08:54 <zezikaro> or
15:08:58 <zezikaro> where?
15:09:01 <zezikaro> 'where' that is
15:09:01 <strager> Stylistic.
15:09:14 <strager> I prefer 'where' but sometimes I find 'let..in' useful.
15:09:25 <strager> Other people are the opposite.
15:09:55 <hpc> 'where' doesn't apply to as many places in the code
15:10:01 <hpc> let-in can be used in any expression
15:10:03 <zezikaro> is htere a notable difference that can be taken advantage of?
15:10:11 <strager> What hpc just said.
15:10:24 <strager> You can write let..in in a guard, for example.
15:10:28 <strager> Not that it's a good idea...  =]
15:10:35 <hpc> 'where' emphasizes equational reasoning more though
15:10:37 <zezikaro> I might've misunderstood the learn you a haskell book on what it does
15:10:42 <hpc> "foo = bar where ..."
15:10:47 <hpc> vs "foo = let ... in bar"
15:10:56 <mdmkolbe> zezikaro: as far as the compiler is concerned, they are identical in behaviour (though "where" can't be used as many places).
15:11:01 <angstrom> it seems, that if it where possible to put deriving in .hs-boot files, this could be resolved.
15:11:30 <zezikaro> thanks
15:12:16 <dmwit> angstrom: Have you tried just putting something like "instance Show B" in your .hs-boot file?
15:12:22 <mdmkolbe> zezikaro: "let x = foo in bar" presents the "foo" to the human reader first, but "bar where x = foo" presents the "bar" to the human reader first.  It changes the emphasis that you give to different parts of the code (but only from a human perspective).
15:12:54 <`Jake`> I guess if cabal gives me the warning that my llvm version couldn't figure out my llvm version doing a quick apt-get install llvm isn't enough?
15:13:13 <tgeeky__> @index (>>-)
15:13:13 <lambdabot> bzzt
15:13:14 <`Jake`> oops, should've read that sentence again
15:13:17 <angstrom> dmwit: that should fix it too, yes. but I'd prefer not to write the instances myself
15:13:58 <`Jake`> *...if cabal gives me the warning that _it_ couldn't figure out my...
15:14:24 <dmwit> angstrom: No, you shouldn't write the instance yourself.
15:14:30 <dmwit> angstrom: I meant literally what I said.
15:14:50 <dmwit> angstrom: Have you tried putting the literal text "instance Show A" in A.hs-boot?
15:15:01 <dmwit> (and changing nothing else)
15:15:19 <angstrom> dmwit: nice!
15:16:00 <angstrom> dmwit: I misread you the first time, but that did the trick. thanks :-)
15:16:19 <dmwit> You might want to do something similar with B in B.hs-boot.
15:16:30 <angstrom> already did
15:16:32 <solidus-river> how would i determine the best math library for useing angles, points, and matricies and relevant operators on them?
15:16:35 <dmwit> Okay. =)
15:17:04 <hpc> solidus-river: for matrices, check out hmatrix
15:17:22 <dmwit> solidus-river: Try vector-space
15:17:48 <hpc> oh, forgot about vector-space
15:18:25 <solidus-river> this is going to be interesting
15:18:58 <`Jake`> if cabal tells me "ghc: could not execute: opt-3.0", then that is related to llvm, right?
15:18:58 <otters> I've defined datatype Kevin in module Kevin.Base, which has a Chan member which is where all the logging messages get sent to
15:19:03 <otters> and Kevin.Util.Logger defines the logger
15:19:22 <solidus-river> trying to do an iterative IK solver in haskell but i have no clue how to handle the maybe values when i come across a divide by zero in the algorythm (happens anytime the bone is aligned with an axes or perpindicular to destination of armature)
15:19:26 <otters> Except that the logger needs to run in StateT (TVar Kevin) IO to access the Kevin object whose chan it's trying to write to
15:19:57 <otters> And in Kevin.Base I've also defined a method readClient which takes a Kevin and returns an IO ByteString, and in that method, the logger is used to log the string that was read from the Handle
15:20:09 <otters> so Kevin.Base depends on the logger and vice versa
15:20:37 <otters> so the question is, how can I resolve the circular dependency
15:20:49 <dmwit> ?google ghc manual hs-boot
15:20:53 <dmwit> otters: ^^
15:20:54 <lambdabot> http://hackage.haskell.org/trac/ghc/ticket/1409
15:20:54 <lambdabot> Title: #1409 (Allow recursively dependent modules transparently (without .hs-boot or an ...
15:20:58 <dmwit> eh... no
15:22:16 <dmwit> otters: http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/separate-compilation.html#id3059813
15:22:22 <otters> hm
15:22:30 <hpaste> ifnspifn pasted “Amateur hour” at http://hpaste.org/69228
15:22:35 <otters> is this a better solution than refactoring
15:23:33 <dmwit> Often refactoring is preferable.
15:23:53 <SinPatrones> hi everybody
15:23:54 <SinPatrones> :D ..
15:24:54 <ifnspifn> Oh, I guess the bot lets you guys know. Well, I'm learning haskell at the moment, and http://hpaste.org/69228 is a list of functions from the 99 Haskell Problems (http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems). In the provided solutions, I've not seen many that share the patterns I've been using to solve these so far... so I was curious as to whether someone could point out if I'm doing any super nasty bad 
15:25:11 <dmwit> You are doing some super nasty bad.
15:25:19 <ifnspifn> haha, excellent
15:25:34 * otters is trying to figure out how to refactor
15:25:40 <ifnspifn> I was advised to avoid using "length", so these are my attempts at working around that
15:25:52 <otters> if I move the Kevin definition to a separate file and require that
15:26:05 <dmwit> comp is fine
15:26:10 <dmwit> pack is terrifying
15:26:43 <zezikaro> i'm disliking "foo " ++ var ++ " bar " ++ var2
15:26:49 <zezikaro> is there a sprintf or whatever
15:27:03 <zezikaro> I guess that goes against the spirit of haskell, but I wonder?
15:27:13 <dmwit> > printf "foo %s bar %s" "bleh" "zezikaro"
15:27:14 <lambdabot>   Ambiguous type variable `a' in the constraints:
15:27:14 <lambdabot>    `GHC.Show.Show a'
15:27:15 <lambdabot>      a...
15:27:16 <zezikaro> " foo {0} bar {1}" var var 2
15:27:17 <dmwit> > printf "foo %s bar %s" "bleh" "zezikaro" :: String
15:27:19 <lambdabot>   "foo bleh bar zezikaro"
15:27:20 <SinPatrones> hhi
15:27:20 <otters> Text.Printf uses some type-fu
15:27:22 <SinPatrones> hi
15:27:22 <otters> unfortunately
15:27:43 <zezikaro> dmwit Can't reuse them?
15:27:47 <zezikaro> %s0 ?
15:28:01 <SinPatrones> who can help me??
15:28:14 <dmwit> ifnspifn: Generally speaking, init and last are a bad sign.
15:28:19 <solidus-river> does hmatrix not have a concept of points?
15:28:19 <dmwit> SinPatrones: Nobody.
15:28:24 <armlesshobo> Nothing
15:28:36 <zezikaro> dmwit Oh wait, it can't be printf
15:28:43 <zezikaro> because i'm returning it as a string
15:28:49 * hackagebot cabal-install-bundle 0.10.2 - The (bundled) command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-bundle-0.10.2 (BartoszCwiklowski)
15:28:51 * hackagebot cabal-install-bundle 0.10.2.1 - The (bundled) command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-bundle-0.10.2.1 (BartoszCwiklowski)
15:28:53 * hackagebot cabal-install-bundle 0.14.0 - The (bundled) command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-bundle-0.14.0 (BartoszCwiklowski)
15:28:54 <zezikaro> foo :: a -> b -> c -> String
15:29:09 <zezikaro> so printf wouldn't make sense =[
15:29:12 <dmwit> ifnspifn: You might want to look into filter and map for dropEv, or perhaps learn how list comprehensions can combine the two.
15:29:17 <zezikaro> > :t printf
15:29:18 <lambdabot>   <no location info>: parse error on input `:'
15:29:22 <zezikaro> i suck
15:29:25 <otters> yeah, haskell variadic arguments
15:29:26 <Botje> zezikaro: print can return a string too.
15:29:26 <otters> :t printf
15:29:28 <lambdabot> forall r. (PrintfType r) => String -> r
15:29:29 <dmwit> zezikaro: printf returns strings.
15:29:38 <armlesshobo> SinPatrones: ask your question
15:29:59 <zezikaro> really? o.O
15:30:01 <zezikaro> seems confusing
15:30:28 <Botje> zezikaro: the magic is in that PrintfType thing.
15:30:35 <Botje> note the lack of quotes around magic.
15:30:54 <ifnspifn> dmwit: list comprehension seems like an obvious choice in retrospect for dropEv, but I couldn't wrap my mind around implementing pack without some kind of fold
15:30:58 <acowley> I'm having trouble providing a comonadic interface for some zipper stuff. Does anyone have any favorite references for such things?
15:31:20 <SinPatrones> how can I find the size of my screen, with Haskell?
15:31:21 <SinPatrones> ,...........
15:31:44 <SinPatrones> or one line of my screen??
15:32:14 <zezikaro> >_<
15:32:21 <zezikaro> i don't get it yet
15:32:23 <zezikaro> but thank you
15:33:03 <zezikaro> does hoogle take a type header then return a matching function ?
15:33:16 <Botje> when it feels like it
15:33:21 <Peaker> zezikaro, Yeah, it can do that, most of the time
15:33:25 <armlesshobo> SinPatrones: why do you need to do this?
15:33:30 <zezikaro> i want something like... [a] -> ([a], Boolean)
15:33:34 <zezikaro> remove
15:33:43 <zezikaro> so, removes an element from the list, and gives a boolean if it was succesful
15:33:45 <zezikaro> otherwise false
15:34:03 <zezikaro> or is that something I have to make myself
15:34:05 <armlesshobo> zezikaro: so something like [a] -> Bool
15:34:18 <zezikaro> I need it to manipulate the existing list i pass in
15:34:19 <dmwit> ifnspifn: lern2recursion =)
15:34:26 <dmwit> (re: can't do pack without a fold)
15:34:41 <sm> SinPatrones: http://hackage.haskell.org/packages/archive/vty/4.7.0.14/doc/html/Graphics-Vty-Terminal.html#v:display_bounds perhaps
15:34:44 <strager> Easy: \x xs -> (delete x xs, elem x xs)
15:34:46 <armlesshobo> zezikaro: understand that the list you pass in is immutable
15:34:47 <zezikaro> and if i'm right in saying, things are immutable in haskell?
15:34:50 <SinPatrones> is my homework....
15:34:51 <strager> Hard: fold yourself
15:34:52 <otters> :where liftIO
15:34:56 <otters> @where liftIO
15:34:56 <lambdabot> I know nothing about liftio.
15:35:00 <otters> really.
15:35:00 <zezikaro> armlesshobo I may have this backwards..
15:35:07 <zezikaro> immutable means modifications create a new object
15:35:09 <zezikaro> right?
15:35:15 <dmwit> ifnspifn: For split' and removeAt, this style of annotating all elements and then unannotating seems like a bit of extra work compared to the straightforward way.
15:35:16 <armlesshobo> zezikaro: you can't change what's passed in
15:35:19 <armlesshobo> zezikaro: at all
15:35:22 <dmwit> ifnspifn: Which is to recurse on the number you're handed.
15:35:30 <Botje> immutable means there's no such thing as modification
15:35:39 <zezikaro> yeah, so, i need a tuple then
15:35:45 <zezikaro> for the new modified list and the result
15:35:53 <Peaker> no such thing as destructive modification, but a new value computed from the old is commonly referred to as "modification"
15:36:00 <strager> :t  \x xs -> (delete x xs, elem x xs)
15:36:01 <lambdabot> forall a. (Eq a) => a -> [a] -> ([a], Bool)
15:36:01 <Botje> or you can do the check up front
15:36:05 <otters> pretty sure I don't import Control.Monad.IO.Class in this file
15:36:08 <otters> and I still have access to liftIO
15:36:11 <otters> what the hell
15:36:41 <otters> where is it
15:36:43 <armlesshobo> zezikaro: the list you passed in can be used to return a new list, but the list itself can't be changed
15:36:57 <zezikaro> that's what the tuple was for
15:37:06 <zezikaro> strager's seems like how i need it to be i believe
15:37:09 <zezikaro> but that seems inefficient?
15:37:15 <dmwit> otters: It's common to re-export things from another module.
15:37:15 <armlesshobo> zezikaro: but why do you need a tuple?
15:37:21 <ifnspifn> dmwit: funny enough, I was trying to avoid a recursive solution, mostly because I've been seduced by these terse one-liners I've been seeing in the solutions :P I'll give those few another go. Thanks a ton for taking some time to grok my nastiness :D
15:37:40 <strager> zezikaro: It'll iterate twice, yes.  You can write it as a fold.
15:37:58 <armlesshobo> zezikaro: (I missed the first part of the issue)
15:38:11 <dmwit> ifnspifn: If you get a chance, you should take a glance at the source for these functions in GHC's libraries once you've had another go.
15:38:20 <dmwit> ifnspifn: Ask in here about any choices you don't understand.
15:38:24 <zezikaro> so i can do tuple = removeStuff list; newList = fst tuple; if snd tuple then .. else ..
15:38:33 <dmwit> You can learn a lot about how to write fast code by reading GHC's source. =)
15:38:59 <zezikaro> strager I wasn't able to get fold in learn you a haskell :(
15:39:20 <strager> zezikaro: let (list', removed) = removeStuff list in ...
15:40:09 <zezikaro> i have got so much to learn o.o
15:40:22 <strager> Just ask for code reviews from time to time.
15:40:32 <ifnspifn> dmwit: will do, thanks again!
15:40:36 <zezikaro> i don't know what to code after I finish this turing machine
15:40:38 <zezikaro> =[
15:40:47 <strager> zezikaro: Have someone code review your turing machine when you're done.
15:41:07 <dmwit> zezikaro: Have you seen the diagrams here? http://www.haskell.org/haskellwiki/Fold#List_folds_as_structural_transformations
15:41:12 <armlesshobo> zezikaro: your function should just return the list after it's worked on
15:41:23 <zezikaro> Oh! I got a different book; I'm stuck between gloss (recommended by application (who seems to be gone)) and the thing recommended in this book...
15:41:40 <zezikaro> "the haskell school of expression"
15:41:46 <zezikaro> dmwit Nope! Checking it out now, thanks
15:42:10 <zezikaro> SOEGraphics ?
15:42:10 <armlesshobo> The Haskell School of Monads
15:42:22 <zezikaro> is that okay to use?
15:42:30 <strager> armlesshobo: He wants to know if the element was removed or not.
15:42:33 <zezikaro> I think the entire book is based around it
15:42:40 <strager> In addition to removing the element(s?) from the list.
15:42:41 <armlesshobo> strager: check the size of the resultant list
15:42:45 <armlesshobo> zezikaro: ^
15:42:54 <strager> armlesshobo: He wants it in one iteration it seems.
15:43:00 <zezikaro> armlesshobo length requires an iteration of the entire list
15:43:08 <dmwit> zezikaro: There's a Gtk implementation of the SOE, I think.
15:43:10 <dmwit> ?hackage soegtk
15:43:11 <lambdabot> http://hackage.haskell.org/package/soegtk
15:43:11 <zezikaro> and it's potentially an infinite list
15:43:14 <zezikaro> i think
15:43:23 <zezikaro> > length [0..]
15:43:27 <lambdabot>   mueval-core: Time limit exceeded
15:43:29 <dmwit> Though I'm technically the maintainer, I have no idea whether it's bitrotted or not. It builds, anyway.
15:43:42 <zezikaro> strager> armlesshobo: He wants it in one iteration it seems.
15:43:44 <zezikaro> Isn't it best to do that?
15:43:59 <strager> zezikaro: Yes, efficiency-wise (likely).
15:44:17 <zezikaro> I was going to do recursion because I don't understand fold (yet?)
15:44:39 <strager> Write it recursively and try refactoring it into a fold.
15:44:47 <zezikaro> is that easy to do?
15:45:03 <strager> Depends on how you write your recursive function
15:45:07 <strager> but probably, yes.
15:45:31 <zezikaro> The pictures on that link make it look easy
15:45:37 <zezikaro> okay thank you
15:46:51 <dmwit> Anyway, nothing wrong with a bit of explicit recursion here and there.
15:47:38 <tommd> Or a lot if you are translating C code that isn't a map, fold, filter, zip, or any other trivial operation.
15:48:27 * tommd has been translating C code to Haskell for too long.
15:49:39 <ifnspifn> Quick question about type declaration for functions... is it more than good practice? or will type inference allow me to be lazy in most/all cases?
15:50:28 <SinPatrones_> hi
15:50:35 <SinPatrones_> everybody
15:50:52 <strager> ifnspifn: I explicitly type all top-level functions.  There's a GHC option to warn if you don't, if you want to use that style.
15:50:56 <zezikaro> hi
15:51:04 <strager> I sometimes annotate local declarations if it may be unclear.
15:51:28 <irene-knapp1> I annotate local declarations if there's more than about 20 lines of them
15:51:39 <strager> O_o
15:51:53 <strager> 20 lines in one declaration?
15:51:54 <irene-knapp1> well, "Programs should be written primarily for humans to read and only secondarily for machines to execute."
15:52:01 <irene-knapp1> no, in multiple declarations within the same let
15:52:06 <strager> Oh, okay
15:52:33 <irene-knapp1> (I have one piece of code in bad need of refactoring - it's like 300 lines in a single let :( )
15:52:51 <irene-knapp1> (but I can't think how else to do it.  it's the CPU core of an 8-bit Nintendo emulator.)
15:54:18 <strager> ;_;
15:56:45 <zezikaro> <SinPatrones_> I need to put a word in right of my screen in haskell
15:56:51 <zezikaro> Could anyone help him please :)
15:58:28 <strager> > replicate ' ' 69 ++ "hello world"
15:58:29 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
15:58:29 <lambdabot>         against inferred type ...
15:58:38 <strager> > replicate 69 ' ' ++ "hello world"
15:58:41 <lambdabot>   "                                                                     hello...
15:58:56 <SinPatrones_> who can speak Spanish? please :D
15:59:13 <zezikaro> strager No way to get the console width at all?
15:59:39 <strager> Maybe with ncurses
15:59:39 <tommd> SinPatrones_: See the #haskell-????? channels - there might be one for spanish.
15:59:45 <zezikaro> or possible char width
15:59:55 <nand`> zezikaro: there are definitely some functions for this
16:00:11 <nand`> both char width and console width; but I believe I used ncurses for the latter
16:00:26 <strager> UI.NCurses.screenSize in package ncurses
16:00:37 <strager> You'll need an ncurses context though
16:00:42 <nand`> Data.Char.WCWidth
16:02:16 <zezikaro> well he's gone now, but i learnt something at least
16:02:17 <zezikaro> thanks
16:03:24 <acowley> I had to unpack my comonad instances to specific zipper types due to type parameters not lining up in a nice way :(
16:03:44 <acowley> but at least it works!
16:04:17 <acowley> 'til the morrow, fair #haskell
16:12:43 <zezikaro> uhh, just because i'm curious
16:12:51 <zezikaro> what sort of age range are the people in this channel?
16:13:21 <DrSyzygy> zezikaro: Most are inducted as they start grade school
16:13:32 <DrSyzygy> but some of the really senior ones in here have already gone through puberty
16:13:33 <coppro> eleventy-minus-4
16:13:52 <zezikaro> i'm 20, i was just wondering
16:14:47 <hughfdjackson> i'm 24
16:14:51 <hughfdjackson> i don't know anything worth knowing
16:14:54 <hughfdjackson> :P
16:15:48 <sipa> 27
16:17:56 <mcstar> 26
16:18:19 <mcstar> and ive seen all the good scifi series
16:19:04 <alex-hu> If I were to use mmap (system.io.mmap), how could I access numerical array (of doubles) if it is preceded by a header (specifying some meta-data)?  I don't see what types should be used here, and how to do this without unnecessary copying.
16:19:19 <zezikaro> thanks
16:19:27 <zezikaro> i was just interested in what age people would be
16:19:55 <hughfdjackson> i imagine that people in their 20s are more likely to answer
16:20:02 <zezikaro> i watched the developers of haskell in an interview, and i wondered if everyone was the same age
16:20:02 <mcstar> alex-hu: whats wrong with ocaml?
16:20:40 <zezikaro> does ocaml bare any resembalance to occam
16:20:50 <zezikaro> hoare's CSP one
16:20:51 <zezikaro> language
16:21:04 * byorgey is 30
16:21:26 <byorgey> zezikaro: I don't think so
16:22:53 <Rotaerk> zezikaro, variant of ML
16:24:24 <byorgey> Caml stands for "Categorical Abstract Machine Language"
16:24:32 <byorgey> OCaml = Objective Caml
16:24:49 <byorgey> Occam is presumably named for the guy with the razor.
16:24:50 <nand`> Heh, @dice <number> should be changed from defaulting to <number>d1 to 1d<number>; eg @dice 10 should roll a 10-sided die, not 10 dice with one side..
16:24:56 <byorgey> so the similarity of names is accidental.
16:24:58 * `Jake` is younger than all of you
16:25:25 <ptrf> zezikaro: think of ML. now think about ML if the french where to do it
16:25:30 <`Jake`> Well, I'm 16
16:25:48 <ptrf> they dont have ml style fun declarations unless they're recursive. then it's rec
16:26:22 <zezikaro> hah
16:26:26 <ptrf> and they use ; as list seperators and , to split decimal parts from the integer part of a float
16:26:35 <zezikaro> `Jake` Nice; What other programming langauges do you know?
16:26:58 <ptrf> and ocamls module system, although strict, is really a pain to work with
16:27:09 <sipa> @dice 20
16:27:09 <lambdabot> 20 => 20
16:27:20 <`Jake`> zezikaro: Java, I used to know a bit of pascal (Well, I had an examn about it), some C++
16:28:10 <`Jake`> *exam
16:28:34 <ptrf> as long as you stay away from their objective features, it's a pretty decent language. oh yeah, after type inference and checking, they throw all less than absolutely essential information away
16:28:42 <mcstar> alex-hu: it seems to me, you can 'seek' in the file, and get back a pointer to your data, after that you can do whatever you want with it
16:28:44 <ptrf> which also makes debugging suck from time to time
16:29:14 <zezikaro> `Jake` An exam in pascal, at 16 ? o.O
16:29:16 <zezikaro> Where do you study?
16:29:22 <zezikaro> If you don't mind me asking
16:29:44 <sipa> @dice 20d2
16:29:44 <zezikaro> Do most people here have a degree in computer science?
16:29:44 <lambdabot> 20d2 => 30
16:29:50 <zezikaro> or is everyone hobbyists?
16:30:07 <parcs`> does a RULE get fired if you bind an intermediate value to another name and use that name instead?
16:30:17 <mcstar> zezikaro: science, but not computer
16:30:42 <alex-hu> mcstar, so, first parse, then get a pointer and somehow tell that it is a pointer to array?
16:30:54 <zezikaro> mcstar Physics related?
16:31:07 <`Jake`> zezikaro: I'm studying Computer Science in Hagen, germany. It's a distance study, and apparently, I'm doing a version specifically for pupils. Not nearly as much work as if I was a real student there.
16:31:23 <parcs`> eg if you have a RULE '0 * x = 0' and 'let y = 0 in y * x' would the RULE still get fired?
16:32:49 <mcstar> zezikaro: yes
16:33:14 <`Jake`> zezikaro: but I can just go on and finish it when I'm done with school, it'll save me some time
16:33:40 <byorgey> zezikaro: I think you will find a wide range of backgrounds here.
16:34:32 <zezikaro> It's interesting
16:34:41 <zezikaro> I think the internet/irc is cool, how we're able to talk
16:34:42 <byorgey> Though my impression is that there is a higher proportion of academics/people with a CS degree here than you would find in many other language-specific channels.
16:35:00 <zezikaro> at completely different age groups, locations, interests, education etc
16:35:04 <byorgey> it's very cool.
16:35:06 <sipa> #agda may be an exception? :p
16:35:20 <byorgey> I said 'many' not 'all' =)
16:35:22 <edwardk> sipa: perhaps =)
16:36:51 <edwardk> i joined the #haskell community because it was the easiest way to surround myself with people who knew stuff I didn't.
16:37:07 <mparodi_> Hello
16:37:38 <edwardk> I figured osmosis would kick in eventually. ;)
16:37:48 <mparodi_> what's the standard approach to do something like:      sum list / length list, where list :: Num a => [a]     ?
16:37:55 <mcstar> alex-hu: i think it could work with Data.Binary
16:38:10 <edwardk> mparodi: / fromIntegral (length list)
16:38:23 <mparodi_> ah, fromIntegral? I tried with fromInteger
16:38:25 <sipa> or genericLength
16:38:37 <edwardk> sipa: i generally don't recommend using genericLength for anything
16:38:52 <`Jake`> why?
16:39:02 <edwardk> :t fromIntegral
16:39:03 <lambdabot> forall a b. (Integral a, Num b) => a -> b
16:39:13 <edwardk> Jake: because its a _lot_ slower
16:39:35 <mparodi_> > let mean list = sum list / fromIntegral $ length list in mean [1..5]
16:39:36 <lambdabot>   No instance for (GHC.Enum.Enum (GHC.Types.Int -> b))
16:39:36 <lambdabot>    arising from a use ...
16:39:48 <`Jake`> ok
16:39:50 <edwardk> the $ has the wrong precedent for that
16:39:56 <mparodi_> oh, really!?
16:40:02 <edwardk> let mean list = sum list / fromIntegral (length list) in mean [1..5]
16:40:12 <edwardk> > let mean list = sum list / fromIntegral (length list) in mean [1..5]
16:40:12 <lambdabot>   3.0
16:40:18 <mparodi_> you're right, how is it interpreted with $ ?
16:40:25 <byorgey> mparodi_: that parses as (sum list / fromIntegral) $ length list, because $ has lower precedence than /
16:40:31 <c_wraith> $ has the lowest precedence possible for an infix operator
16:40:34 <edwardk> (sum list / fromIntegral) $ (length list)
16:40:41 <mparodi_> I see
16:40:43 <mparodi_> thank you!
16:41:21 <edwardk> in general $ 'inside' an operand to an infix operator just doesn't work
16:42:32 <zezikaro>  <edwardk> I figured osmosis would kick in eventually. ;)
16:42:33 <zezikaro> haha
16:42:54 <zezikaro> Could someone help me with my removeElem function I was trying to create earlier please
16:42:54 <zezikaro> http://ideone.com/E9xlw
16:43:14 <zezikaro> returns a modified list and a result of true/false if an element from the list is succesfully removed
16:43:20 <zezikaro> using the function pased into it
16:43:33 <c_wraith> zezikaro: well, for one, I think you want to return a pair, not a function
16:43:42 <zezikaro> fuck
16:43:45 <edwardk> removeElem :: (a -> Bool) -> [a] -> ([a], Bool)  not removeElem :: (a -> Bool) -> [a] -> ([a] -> Bool)
16:43:45 <zezikaro> good catch
16:44:16 <zezikaro> two tweaks and it's fixed
16:44:18 <zezikaro> thank you
16:44:20 <edwardk> :t splitAt
16:44:21 <lambdabot> forall a. Int -> [a] -> ([a], [a])
16:44:53 <edwardk> :t break
16:44:54 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
16:45:35 <edwardk> zezikaro: you can build it up with break using your predicate, then just look at the second list to figure out what to do next
16:45:57 <zezikaro> "break" ?
16:46:04 <mcstar> (True, xs)
16:46:05 <zezikaro> ah
16:46:08 <edwardk> > break (< 3) [1..10]
16:46:09 <lambdabot>   ([],[1,2,3,4,5,6,7,8,9,10])
16:46:15 <edwardk> > break (> 3) [1..10]
16:46:16 <lambdabot>   ([1,2,3],[4,5,6,7,8,9,10])
16:46:32 <zezikaro> mcstar You're saying that doesn't match the heading type (is that the right word?)
16:46:35 <c_wraith> :t partition
16:46:36 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
16:46:40 <zezikaro> i fixed that in my second fix
16:46:56 <c_wraith> > partition (<5) [1..10]
16:46:57 <lambdabot>   ([1,2,3,4],[5,6,7,8,9,10])
16:47:00 <mcstar> i think it wont typecheck
16:47:09 <zezikaro> How do you distinguish between
16:47:10 <edwardk> foo f xs = case break xs of (ys,[]) -> (ys,False); (ys,z:zs) -> (ys ++ zs, True)
16:47:13 <zezikaro> passing a function as an argument
16:47:17 <mcstar> ([a], Bool) vs (Bool, [a])
16:47:24 <zezikaro> and passing the reuslt of a function applied to the next parameter
16:47:32 <zezikaro> (resultXS, resultB) = removeElem compareFunc xs
16:47:38 <zezikaro> could be intepreted as
16:47:41 <zezikaro> (resultXS, resultB) = removeElem (compareFunc xs)
16:47:46 <zezikaro> which clearly isn't what i meant
16:47:47 <mparodi_> > (map (**2) [1..5]) / (fromIntegral (length [1..5]))
16:47:48 <lambdabot>   No instance for (GHC.Real.Fractional [a])
16:47:48 <lambdabot>    arising from a use of `e_12151...
16:47:53 <edwardk> > let foo f xs = case break xs of (ys,[]) -> (ys,False); (ys,z:zs) -> (ys ++ zs, True) in foo (> 3) [1..10]
16:47:54 <mparodi_> what's the problem now?
16:47:54 <lambdabot>   Couldn't match expected type `[a] -> ([a], [a])'
16:47:54 <lambdabot>         against inferred t...
16:48:00 <mcstar> zezikaro: function application has the highest precedence
16:48:02 <edwardk> > let foo f xs = case break f xs of (ys,[]) -> (ys,False); (ys,z:zs) -> (ys ++ zs, True) in foo (> 3) [1..10]
16:48:03 <lambdabot>   ([1,2,3,5,6,7,8,9,10],True)
16:48:07 <edwardk> > let foo f xs = case break f xs of (ys,[]) -> (ys,False); (ys,z:zs) -> (ys ++ zs, True) in foo (< 3) [1..10]
16:48:09 <lambdabot>   ([2,3,4,5,6,7,8,9,10],True)
16:48:16 <edwardk> hrmm i screwed up somewhere =)
16:48:24 <zezikaro> mcstar So why didn't it apply to xs?
16:48:28 <zezikaro> it works without the brackets
16:48:37 <zezikaro> before i did (resultXS, resultB) = removeElem (compareFunc) xs
16:48:40 <zezikaro> to make sure it didn't apply
16:48:45 <zezikaro> but without brackets works, too
16:48:52 <mcstar>  removeElem compareFunc xs ===  (removeElem compareFunc) xs
16:49:07 <mparodi_> > map (**2) [1..5] / fromIntegral (length [1..5])
16:49:08 <lambdabot>   No instance for (GHC.Real.Fractional [a])
16:49:08 <lambdabot>    arising from a use of `e_12151...
16:49:11 <mparodi_> :|
16:49:27 <alex-hu> mcstar, I'll check this out, and see what solution would work best for me.  Thx.
16:49:36 <zezikaro> edwardk I don't mind re-inventing the wheel at this stag
16:49:38 <zezikaro> stage*
16:49:43 <zezikaro> since i've only been at this a few days now
16:49:58 <edwardk> zezikaro: sure, just figured i'd try it as an exercise
16:50:28 <zezikaro> Is it possible to change my function into a fold, like previous suggested
16:50:30 <zezikaro> :o
16:50:58 <mcstar> zezikaro: putting a binding into parentheses is completely redundant
16:51:15 <mparodi_> @type map (**2) [1..5] / fromIntegral (length [1..5])
16:51:16 <lambdabot> forall a. (Floating a, Enum a, Fractional [a]) => [a]
16:51:23 <mparodi_> the type is correct!
16:51:40 <edwardk> > let foo f xs = case break f xs of (ys,[]) -> (ys, False); (ys,_:zs) -> (ys ++ zs, True) in foo (> 12) [1..10]
16:51:41 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10],False)
16:51:53 <edwardk> zezikaro: yes
16:52:34 <zezikaro> i don't get that >.<
16:53:01 <zezikaro> i don't understand let ... in still, so i'm just using where constantly
16:53:11 <zezikaro> i suck
16:54:10 <mparodi_> guyss, do you see why it doesn't work? because I don't
16:54:11 <jfischoff> zezikaro: I like where better anyway :)
16:54:32 <edwardk> @type \f -> foldr (\x (xs,done) -> if done then (x:xs,done) else if f x then (xs,True) else (x:xs,False)) ([],False)
16:54:33 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], Bool)
16:54:52 <edwardk> the function is ugly enough i probably wouldn't write it inline like that though
16:55:38 <mcstar> let .. in is important cause it can capture bindings
16:55:41 <mcstar> where cant afaik
16:56:29 <mcstar> (ofc it can, but usually it only means function parameters)
16:57:42 <edwardk> @hpaste
16:57:42 <lambdabot> Haskell pastebin: http://hpaste.org/
16:57:43 <mparodi_> @hoogle (Fractional a, Float b) => a -> b
16:57:43 <lambdabot> Warning: Unknown class Float
16:57:43 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
16:57:43 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
16:57:56 <mparodi_> @hoogle (Fractional a, Num b) => a -> b
16:57:57 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
16:57:57 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
16:57:57 <lambdabot> Data.List genericLength :: Num i => [b] -> i
16:57:59 <hpaste> edwardk pasted “for zezikaro” at http://hpaste.org/69230
16:58:31 <mparodi_> argh
16:59:14 <c_wraith> :t fromRational
16:59:16 <lambdabot> forall a. (Fractional a) => Rational -> a
16:59:34 <c_wraith> heh.  that's not what you need
16:59:35 <mparodi_> is it that hard to work with *float*? u.u
16:59:48 <c_wraith> mparodi_: Float is a type.  Floating is a class.  don't mix them up
16:59:54 <mparodi_> I don't know why it's forcing me to deal with Fractional
17:00:05 <c_wraith> @instances Fractional
17:00:09 <lambdabot> Double, Float
17:00:29 <mparodi_> then I didn't get why it doesn't work :P
17:00:38 <zezikaro> edwardk thanks
17:00:44 <zezikaro> I understand that
17:00:54 <zezikaro> i've also decided to give funcs just 'f'
17:00:58 <zezikaro> what happens if you pass in two funcs
17:00:59 <zezikaro> is it
17:01:01 <zezikaro> f1 f2 ?
17:01:12 <edwardk> i usually to f g h and then resort to more complicated naming
17:01:16 <edwardk> er go
17:02:12 <nand`> :t toRational
17:02:13 <lambdabot> forall a. (Real a) => a -> Rational
17:02:16 <nand`> oh
17:03:16 <mcstar> edwardk: why would you use foldr?
17:03:35 <zezikaro> if i do 'where', is it something can be recalculated per mapM_ 'call'
17:03:36 <mcstar> you can stop once you the predicate became true
17:03:52 <mcstar> -you
17:04:33 <edwardk> mcstar: i wouldn't. he asked if you could though
17:04:45 <mcstar> k
17:06:43 <mcstar> zezikaro: i cant make head or tails of your last sentence
17:07:10 <mparodi_> oh, silly me. I found the problem
17:07:11 <mcstar> but 'where' is just like a toplevel definition, except, lives in a nested scope
17:07:25 <zezikaro> mcstar Sorry, i'm just thinking... I might need to give it a few goes then ask for help
17:09:30 <mparodi_> @type map (**2) [1..5] / genericLength [1..5]
17:09:31 <lambdabot> forall a. (Floating a, Enum a, Fractional [a]) => [a]
17:09:38 <mparodi_> why does it say [a]?
17:09:43 <mparodi_> it's wrong, it can't have that type
17:09:54 <mparodi_> the first argument of (/) is a list!
17:10:03 <mparodi_> @type sum (map (**2) [1..5]) / genericLength [1..5]
17:10:04 <lambdabot> forall a. (Floating a, Enum a) => a
17:10:08 <mparodi_> this is correct ^
17:10:08 <parcs`> why can't it have that type?
17:10:27 <mparodi_> parcs`, what's the type of [1..5]/3 ?
17:10:29 <dmwit> I think he meant he doesn't *want* it to have that type. =)
17:10:31 <mparodi_> does it make sense?
17:10:35 <mparodi_> @type (/)
17:10:36 <lambdabot> forall a. (Fractional a) => a -> a -> a
17:10:40 <parcs`> mparodi_: (Floating a, Enum a, Fractional [a]) => [a]
17:10:41 <dmwit> Yes, it does, but you need an instance of Fractional for lists.
17:10:51 <dmwit> (does make sense, that is)
17:11:33 <mparodi_> ahm, interesting.. what's the meaning of [1..5]/3? I mean, what's the result?
17:11:48 <mparodi_> I guess you have to define (/) for Fractional a => [a]
17:11:51 <parcs`> mparodi_: the result depends on what type you constrain that expression to
17:11:59 <dmwit> Depends. How did you define (/) for your [a] instance of Fractional?
17:12:20 <mparodi_> instance Fractional a where (/) list number ... ?
17:12:31 <mparodi_> s/.../= .../
17:12:38 <dmwit> oh no
17:12:46 <dmwit> instance Fractional a where list1 / list2 = ...
17:12:56 <edwardk> i'm guessing with formal power series division
17:12:58 <dmwit> It would be a very weird instance to write.
17:13:19 <dmwit> But you *could* write one.
17:13:26 <mparodi_> the second argument should be of type Num a
17:13:27 <dmwit> So it's not lying to you when it says there's a chance.
17:13:35 <mparodi_> @type genericLength
17:13:35 <dmwit> :t (/)
17:13:35 <lambdabot> forall b i. (Num i) => [b] -> i
17:13:36 <lambdabot> forall a. (Fractional a) => a -> a -> a
17:13:43 <dmwit> mparodi_: The second argument has the same type as the first argument.
17:14:00 <parcs`> mparodi_: Fractional implies Num
17:14:00 <mparodi_> then it couldn't work
17:14:06 <mparodi_> ah, ok
17:14:30 <mparodi_> even if the second argument is NOT a list you have to define (/) for two lists?
17:14:39 <dmwit> The second argument *is* a list.
17:15:01 <dmwit> So get this "even if blah" stuff out of your head.
17:15:01 <mparodi_> uh? it's genericLength [1..5], ie: number, not list
17:15:07 <dmwit> genericLength is polymorphic.
17:15:11 <dmwit> It could return a list.
17:15:12 <parcs`> it's not a number, it's a Num a => a
17:15:21 <dmwit> (again, assuming you had appropriate instances)
17:15:24 <mparodi_> @type genericLength
17:15:25 <lambdabot> forall b i. (Num i) => [b] -> i
17:15:39 <dmwit> Here, the instance you'd need is instance Num [i]
17:16:01 <mparodi_> I'm missing some part, I thought "Num a" was "a number" (Float, Int, whatever)
17:16:08 <mparodi_> I need to continue reading that book :P
17:16:11 <dmwit> lists fall into "whatever"
17:16:13 <dmwit> if you want them to
17:16:42 <mparodi_> Num a => a          ==        Num a => [a]
17:16:43 <mparodi_> ?
17:16:47 <mparodi_> I'm confused now
17:16:47 <dmwit> Just because the standard libraries don't have a list instance for numbers doesn't mean you can't write one. =)
17:18:15 <dmwit> It's like this: currently, there are instances of Num for things like Int, Double, Float, Complex Double, CReal, Rational, etc.
17:18:32 <dmwit> There isn't an instance of Num for lists.
17:18:35 <dmwit> But you could write one.
17:18:51 <dmwit> And then any value which happens to be polymorphic enough to handle Num can handle lists.
17:19:03 <dmwit> The situation is similar for Floating, or Fractional, or any other class.
17:19:04 <mparodi_> I see
17:19:17 <mparodi_> it's weird and dark >_>
17:19:30 <dmwit> Now, (/) is a function which is polymorphic enough to handle any Fractional type.
17:19:49 <dmwit> So if you've declared an instance of Fractional for lists, then [1..5] / [3,7] makes sense.
17:20:07 <mcstar> try implementing matrix operations out of lists with the usual operators, and it wont be so dark after that
17:20:28 <dmwit> And genericLength is polymorphic enough to return any instance of Num, so if you have an instance of Num for lists, then [1..5] / genericLength [3..7] makes sense, *because genericLength returns a list*.
17:21:00 <dmwit> Now, just because there are no such instances now doesn't mean there couldn't be any such instances ever.
17:21:26 <dmwit> So GHC must let you write [1..5] / genericLength [3..7] now, and hope that by the time we're ready to execute that we've worked out how to add instances of the appropriate type classes.
17:21:33 <dmwit> If not, well, *then* we can complain about an error.
17:21:36 <Peaker> for error diagnostic purposes, it might be nice to have an instance ban:   ban instance Fractional [a] "Attempt to use list is a fractional number!"
17:21:47 <zezikaro> is there a
17:21:50 <zezikaro> 'while true' in haskell?
17:21:57 <Peaker> zezikaro, Control.Monad.forever
17:22:01 <Peaker> @src forever
17:22:01 <lambdabot> Source not found. I've seen penguins that can type better than that.
17:22:06 <Peaker> forever x = x >> forever x
17:22:19 <zezikaro> :P
17:22:19 <zezikaro> thanks
17:23:34 <Peaker> example use:  10 thread workers executing an infinite loop in Haskell:  replicateM_ 10 . forkIO . forever $ do ...
17:24:22 * monochrom swaps "forkIO" and "forever"!
17:24:32 <Peaker> hehe
17:25:07 <mparodi_> @module forkIO
17:25:07 <lambdabot> Unknown command, try @list
17:25:15 <mparodi_> where is forkIO?
17:25:20 <hpc> @hoogle forkIO
17:25:20 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
17:25:21 <lambdabot> GHC.Conc.Sync forkIO :: IO () -> IO ThreadId
17:25:21 <lambdabot> GHC.Conc forkIO :: IO () -> IO ThreadId
17:25:21 <Peaker> @index forkIO
17:25:21 <lambdabot> Control.Concurrent
17:26:19 <Peaker> @type bracket
17:26:20 <lambdabot> Not in scope: `bracket'
17:26:25 <Peaker> @type Control.Exception.bracket
17:26:26 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
17:26:59 <Peaker> newtype Bracket r a = Bracket { unBracket :: ContT r IO a } deriving (Monad, MonadTrans) ; with  bracket returning Bracket c a   instead of (a -> IO c) -> IO c is really nice
17:27:14 <Peaker> runBracket = unBracket . (`runContT` return)
17:27:22 <Peaker> @type (`runContT` return)
17:27:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => ContT a m a -> m a
17:27:40 <Peaker> my forkIO loop above would actually leak the threads -- no way for them to ever die
17:27:44 <Peaker> (except if they fail)
17:28:00 <zezikaro> How do you know if it's
17:28:02 <Peaker> but if instead, someone wraps forkIO in a bracket that kills the thread when exiting, and uses Bracket, then you can use:
17:28:04 <zezikaro> "maybe" or "Maybe"
17:28:06 <zezikaro> "just" or "Just"
17:28:14 <zezikaro> is there a logical reason for knowing the naming
17:28:15 <mparodi_> maybe is a function, Maybe is a type
17:28:19 <mparodi_> isn't it?
17:28:27 <zezikaro> removeElem :: (a -> Bool) -> [a] -> ([a], maybe a)
17:28:30 <zezikaro> so then it's Maybe a
17:28:56 <Peaker> zezikaro, upper-case followed by dot syntax is always qualified name.  upper-case in values means Data Constructor. upper-case in types means Type name or Type Class name
17:29:08 <Peaker> lower-case in values means non-data-constructor (any other value)
17:29:12 <Peaker> lower-case in types means type-variable
17:29:30 <zezikaro> So this is Maybe a
17:29:33 <zezikaro> right? >_<
17:29:43 <vodik> yes
17:29:53 <zezikaro> thanks
17:30:02 <Peaker> zezikaro, yes, otherwise the "maybe" is a type-variable and can mean any type at all
17:30:14 <zezikaro> and that's why you do 'just elem ->'
17:30:18 <zezikaro> because that's a function in that case
17:30:25 <zezikaro> but it's actual type is Just a
17:30:27 <zezikaro> I hope
17:30:59 <Peaker> zezikaro, what? no
17:31:03 <zezikaro> fml
17:31:06 <Peaker> zezikaro, "just" doesn't exist
17:31:12 <Peaker> zezikaro, data Maybe a = Nothing | Just a
17:31:20 <vodik> Just isn't a type
17:31:35 <zezikaro> is there not a function just that returns true if it's of a type
17:31:35 <vodik> (i don't know what the proper term is so i'll be quiet now)
17:31:39 <Peaker> zezikaro, "Maybe" is a type. "a" is a type-variable (both in the type namespace).   "Nothing" and "Just" are data constructors (both in the value namespace)
17:31:54 <Peaker> zezikaro, the GHC compiler :)
17:32:03 <vodik> ah
17:32:06 <zezikaro> ah so when you do a case
17:32:10 <zezikaro> i'm actually doing pattern matching
17:32:14 <vodik> yes
17:32:47 <zezikaro> thanks
17:32:49 <vodik> you can even have guards
17:34:11 <jmillikin> I'm hitting what looks like a GHC bug, when combining mvar with weak pointers. Anyone around with strong GHC-runtime-fu who can figure this out? I'm stumped. http://stackoverflow.com/questions/10802322/why-is-a-weak-pointer-to-an-mvar-finalized-even-though-the-mvar-is-still-access
17:34:32 <vodik> let f x = case x of x | x > 5 -> True | otherwise -> False in f 7
17:34:36 <vodik> > let f x = case x of x | x > 5 -> True | otherwise -> False in f 7
17:34:37 <lambdabot>   True
17:34:39 <vodik> > let f x = case x of x | x > 5 -> True | otherwise -> False in f 3
17:34:40 <lambdabot>   False
17:35:53 <zezikaro> thanks
17:38:33 <zezikaro> vodik Can you mix between guards and patterns?
17:38:54 <Peaker> zezikaro, each pattern can have guards inside it.. though it is a pretty rarely useful feature
17:38:59 <vodik> zezikaro: sure, just like with functions. that's just a contrived example ^
17:39:12 <Peaker> better to use patterns > than guards > than if-statements
17:39:16 <zezikaro> thank you Peaker and vodik
17:39:57 <vodik> zezikaro: note i first had to pattern match with case x of x (note the extra x at the end)
17:40:09 <vodik> zezikaro: its kinda hard to read when its all on one line
17:40:21 <zezikaro> I didn't actually notice that
17:40:22 <Peaker> vodik, not sure why you're showing this to a beginner... it's not a common pattern to use and probably better to just call a different function for that
17:40:22 <zezikaro> thanks
17:40:41 <zezikaro> Peaker It's always nice to know new thigns
17:40:42 <geekosaur> you can also use _ there since you can use the original binding
17:40:42 <zezikaro> things*
17:40:43 <vodik> Peaker: in hindsight may not have been productive
17:40:52 <vodik> Peaker: you are right
17:40:54 <Peaker> > let f x | x > 5 = True | otherwise = False in f 3
17:40:55 <lambdabot>   False
17:41:01 <geekosaur> or that
17:41:01 <vodik> yeah
17:41:06 <zezikaro> It's never a waste of time to teach someone something new
17:41:13 <zezikaro> particularly since i'm wanting to learn the language :P
17:41:18 <Peaker> ^^ this is much better style.  "case x of x" is going to give shadow warnings and is not really a good way to use case
17:41:22 <vodik> zezikaro: no, but its not exactly a good practice is the point
17:41:37 <vodik> zezikaro: for completions sake ;)
17:42:16 <hpaste> Peaker pasted “Indentation of guards” at http://hpaste.org/69231
17:42:27 <Peaker> zezikaro, this is how you typically indent it ^^
17:42:54 <zezikaro> ah
17:42:56 <zezikaro> thank you
17:48:59 <zezikaro> Damn, I just can't work out what's wrong with this
17:49:08 <zezikaro> and it's a parse error of all things
17:49:08 <zezikaro> http://ideone.com/nFM0o
17:49:27 <zezikaro> i'm trying to output the states in my turing machine
17:49:35 <hpaste> “`Jake`” annotated “Indentation of guards” with “Indentation of guards (annotation)” at http://hpaste.org/69231#a69232
17:49:53 <`Jake`> isn't _that_ how you typically indent it?
17:50:07 <Peaker> `Jake`, not me, I'm usually not a masochist :)
17:50:20 <Peaker> if you've got good IDE support for it, go for it
17:50:23 <zezikaro> foo bar
17:50:24 <Peaker> (I don't)
17:50:41 <zezikaro> In my link i remove a wild card state
17:50:43 <`Jake`> Peaker: I use pretty much standard vim atm, so no, I haven't ^^
17:50:53 <zezikaro> and modify the key state from q0 to q0 (wildCardDirection)
17:51:01 <`Jake`> Peaker: but it looks nicer
17:51:01 <zezikaro> but i get a parse error on 'where'
17:51:13 <Peaker> zezikaro, "where" is something that definitions (aka a=b) have, not any expression
17:51:21 <Peaker> zezikaro, you might want to use "let" inside an expression
17:51:28 <monochrom> yeah, you can't use "where" there. change it to let
17:51:31 <Peaker> `Jake`, well, maintaining it is annoying
17:51:41 <Peaker> zezikaro, also, your code is too far to the right
17:51:45 <monochrom> \(k,v) -> let ... in do mapM_ ...
17:51:51 <Peaker> make your indent smaller and/or split to more definitions
17:52:01 <`Jake`> Peaker: I guess should write a vim plugin for it
17:52:02 <monochrom> in general "\x -> ... where ..." doesn't fly
17:53:04 <Peaker> `Jake`, I hate textual editors.. It's going to be trivial in the structural editor I'm working on :)
17:53:26 <`Jake`> Peaker: what are you using?
17:53:36 <Peaker> `Jake`, for now, emacs, but it is painfjul
17:53:42 <Peaker> until the structural editor is self-hosting
17:53:43 <zezikaro> parse error, possibly incorrect indentation
17:53:46 <zezikaro> ='[
17:53:50 <Peaker> zezikaro, your indent style is insane :)
17:54:21 <zezikaro> insane...ly good?
17:54:23 <zezikaro> =[
17:54:23 <Peaker> zezikaro, instead of forM bla $ \n .... tons of indent .... do \n ... even more indent ...         just do:   forM bla $ \x -> do \n ... a bit more indent
17:54:35 <`Jake`> zezikaro: are you sure you want to use 8 spaces for indentation?
17:54:39 <Peaker> (put the do in the same line as forM and indent just a bit)
17:54:42 <monochrom> yeah I don't go out of my way to align ='s either. so fragile.
17:54:45 <zezikaro> `Jake` It's the default in notepad++
17:54:55 <`Jake`> zezikaro: you can change that ;-)
17:55:01 <Peaker> monochrom, the structural editor I'm working on already shows the = aligned in a where clause :)
17:55:32 <monochrom> yeah, visual alignment is a computer's job, not a human's job
17:55:34 <Peaker> (it's currently insanely showing all sub-expression types temporarily)
17:55:48 <Peaker> (we're adding type-inference, so it's useful)
17:56:02 <Peaker> but it's still already pretty impressive, IMO :)
17:56:05 <luite> for haskell?
17:56:16 <Peaker> Yeah, sort of Haskell/SystemF freak child
17:56:31 <Peaker> Some parts we use SystemF and not Haskell because it is simpler (e.g: "forall" is more like Agda)
17:56:35 <`Jake`> zezikaro: indentation is preference, but personally, I think it's kind of confusing to use too many spaces
17:56:43 <bscarlet> Any cabal experts out there? I can get C code to work through FFI using C-Sources in my Library section, but while the library seems to come out right (I can build an executable in a dependent package that calls the c-code), test sections in the same cabal package don't seem to get linked to the objects from the C-Sources.
17:57:41 <monochrom> structural editor also eliminates the tension between two programmers wanting two different amounts of spacing in indentations
17:57:52 <Peaker> monochrom, yeah -- we don't even allow different sugarings
17:58:26 <Peaker> instead of de-sugaring, it only does sugaring (pre-presentation), and it always just does it, so there's no silly choice on whether to use: >>= \x -> ...   or "do" notation
17:58:48 <Peaker> maybe later, such a silly choice can be added as an end-user GUI option (not actually stored in code)
18:01:35 <zezikaro> Sorry for asking really stupid questions all the time
18:01:43 <zezikaro> I can't seem to make my function removeElem work with a
18:01:43 <zezikaro> http://ideone.com/lZs07
18:02:03 <zezikaro> I tried | f x = (xs, Maybe x)
18:02:07 <zezikaro> and it didn't work either
18:02:15 <Peaker> zezikaro, "Maybe" is a type
18:02:22 <Peaker> zezikaro, a type constructor, specifically
18:02:38 <Peaker> zezikaro, (xs, Maybe x) is invalid because all these names in there are in the value-namespace, not the type-namespace
18:02:53 <Peaker> zezikaro, So upper-case value name looks for a *data constructor* by the name of "Maybe" and doesn't find any
18:03:14 <Peaker> zezikaro, what you probably want is: (xs, Just x).  Just is the data constructor that wraps a value in a Maybe:   Just :: a -> Maybe a
18:03:26 <Peaker> Just and Nothing are the data constructors in the Maybe type
18:03:35 <zezikaro> nom nom nom
18:03:37 <zezikaro> thank you
18:04:59 <zezikaro> is it possible to have two types that are actually the same thing
18:05:07 <zezikaro> data Foo = L | R | (C | H)
18:05:14 <zezikaro> so C and H are actually the same thing
18:05:19 <zezikaro> and can be be used interchangably
18:05:23 <monochrom> no
18:05:29 <zezikaro> No fun
18:05:32 <zezikaro> thanks :P
18:07:00 <`Jake`> Well, couldn't you do something like data Baz = Baz | Bar and data Foo = L | R | Baz?
18:07:25 <monochrom> also, terminology: in "data Foo = L | R | C | H", L, R, C, H are not types. they are values, data constructors. Foo is the type.
18:08:01 <`Jake`> Probably not. I guess It's not realy the same
18:08:05 <nand`> “two types that are actually the same thing” <- I can't imagine what this would be useful for
18:08:39 <zezikaro> in a turing machine a halt state can be defined as 'C' or 'H'
18:09:04 <zezikaro> I guess I'll pick one
18:09:06 <zezikaro> thanks
18:10:01 <monochrom> sure, but I doubt there is any need to classify states into halting and non-halting at the type level. you only need the classification at run time --- value level
18:10:16 <applicative> zezikaro is removeElem supposed the be this http://hpaste.codepad.org/g0jWLazX
18:10:28 <monochrom> is'halt C = True; is'halt H = True; is'halt _ = False
18:10:40 <nand`> class Turing t where isHalt :: t -> Bool
18:10:52 <monochrom> KISS
18:11:20 <nand`> I was under the impression that he wants to model different turing machines
18:11:31 <nand`> (or why else the C/H alternative thing?)
18:13:30 <monochrom> two halting states: the accept state, the reject state
18:13:43 <zezikaro> applicative I can't spot the difference sorry
18:13:47 <zezikaro> what's different?
18:14:13 <applicative> I put a Just in line 5
18:14:17 <zezikaro> ah
18:14:17 <applicative> line 4
18:14:21 <zezikaro> applicative I got help with that already
18:14:24 <zezikaro> I was trying Maybe x
18:14:29 <zezikaro> :P
18:14:37 <zezikaro> thanks
18:15:31 <zezikaro> I need to make a turing machine to test this properly I guess
18:15:57 <applicative> you can make an Eq instance data Foo = L | R | C | H that identifies C and H, for what its worth
18:16:07 <monochrom> wait, you mean you're writing 100 lines of code straight and you have tested nothing?
18:16:28 <zezikaro> monochrom I've tested it with a turing machine that I had written down on a piece of paper
18:16:33 <zezikaro> i can't remember what the hell it does
18:16:45 <zezikaro> i think it checks balanced 1s or something
18:17:11 <monochrom> I mean you should do more unit testing. specify what each function should do, test against that.
18:17:23 <zezikaro> blargh
18:17:28 <zezikaro> i'm wanting fun, not unit tests =D
18:17:52 <zezikaro> Although I believe i'm at the end of this soon
18:18:04 <monochrom> not your current "I'll complete the whole space shuttle system first, and then I'll give it a complete mission as test..."
18:18:05 <zezikaro> Get rid of '_' to mean wild card and i think i'm done
18:18:42 <monochrom> otoh if you say you've proved your program correct, that's different
18:19:13 <monochrom> (but I would do unit-proving if I were to prove 100 lines of code correct. clearly.)
18:19:37 <zezikaro> monochrom Prove my program correct?
18:19:43 <zezikaro> with hoare logic?
18:21:47 <Axman6> are you talking about haskell or not?
18:22:09 <Axman6> because proving things in haskell is quite a lot easier than using hoard logic
18:22:55 <monochrom> great insight typo. many real-world programs are analysed by hoard logic indeed :)
18:23:29 <Axman6> "many"?
18:23:35 <Axman6> oh, heh
18:24:00 <monochrom> getting a hoard of programmers to figure out a segfault, for example... :)
18:24:15 <zezikaro> monochrom That's the only program proving I know of sorry :/
18:25:03 <Axman6> haskell programs are a form of proof in themselves (though with holes a lot of the time)
18:26:41 <zezikaro> is it best to have...
18:27:05 <zezikaro> a tuple for the map key, of, (stateName, Left | Right)
18:27:10 <zezikaro> where Left/Right are wild cards
18:27:17 <zezikaro> or a state which is used for wild cards
18:27:35 <zezikaro> Because I just realised I might've made things a bit too complex
18:27:43 * Axman6 doesn't understand
18:28:06 <zezikaro> (StateTuple '_' "q0" Leave Left)
18:28:13 <zezikaro> '_' is my "wild character"
18:28:23 <zezikaro> In turing machines its useful to define state "q0 (L)"
18:28:38 <zezikaro> which continues left ignoring chars it reads if it doesn't have a state that matches the read sybol
18:28:51 <zezikaro> that's why one of my states was '_' as the read symbol
18:29:09 <zezikaro> '_' is very brittle
18:29:21 <zezikaro> so i'm not sure if i should create a state for dealign with that
18:29:26 <zezikaro> or a tuple for the key
18:29:39 <zezikaro> because atm i map stateName -> [tuples]
18:30:00 <zezikaro> so i'm not sure if i should chang ethat to (stateName, ignoreLeft) -> [tuples]
18:30:02 <zezikaro> for instance
18:30:09 <zezikaro> or keep with the ignore state inside it
18:32:14 <zezikaro> Axman6 Does that make sense ? :P
18:35:54 <zezikaro> storing it as a tuple means I delete all of the code I just worked on today xD
18:39:15 <sinelaw> yo!
18:39:51 <sinelaw> is there a launchpad ppa for haskell-platform?
18:40:05 <monochrom> I am not sure why (state, left|right) is a map key to begin with. presumably the transition function maps (state, symbol read) to (state, symbol written, left|right). so the map key ought to be (state, symbol read)
18:42:05 <Axman6> launchpad app?
18:42:11 <zezikaro> monochrom My old code was http://ideone.com/vbtdi
18:42:21 <zezikaro> it maps state name to quintuples
18:42:38 <sinelaw> Axman6, nope, ppa
18:43:06 <Axman6> ok, i'll restate my question; launchpad ppa?
18:43:08 <geekosaur> Axman6, they're asking if there is a private ackage archive/repo
18:43:39 <sinelaw> the answer being.....
18:43:41 <geekosaur> launchpad is sort of a github and package repository for debian/ubuntu packages
18:43:54 <geekosaur> I am only aware of PPAs for older ubuntu releases
18:44:05 <sinelaw> :(
18:44:16 <sinelaw> then it's upgrade or downgrade
18:45:02 <geekosaur> the new haskell platform drops later this wek; someone will probably do a ppa soon thereafter
18:45:09 <geekosaur> week, even
18:45:16 <sinelaw> wek is good
18:46:48 <sinelaw> so here's an idea for FRP i've been considering for quite a while
18:47:00 <sinelaw> it's more about math fun than about code
18:47:42 <sinelaw> everybody knows how to define derivative, integral, etc.
18:48:09 <sinelaw> but is there a *constructive* definition of those? meaning, using some common building blocks
18:48:45 <sinelaw> with the desired properties for physical system: causality, non-infinite memory, whatever else
18:48:57 <Ralith> symbolic or numeric?
18:49:00 <sinelaw> symbolic
18:49:11 <dolio> Bishop did quite a bit of analysis constructively.
18:49:31 <sinelaw> dolio: example?
18:49:46 <dolio> What do you mean?
18:49:57 <dolio> He probably wrote a book on it.
18:50:06 <dolio> But I don't know where to get it.
18:50:12 <sinelaw> well, i'm not likely to read it :)
18:50:32 <sinelaw> but what sort of things did he do?
18:50:38 <dolio> http://en.wikipedia.org/wiki/Errett_Bishop
18:51:29 <sinelaw> thanks
18:51:48 <Eduard_Munteanu> If this is about FRP, perhaps you can find a reasonable analogue of derivatives and such.
18:52:18 <Eduard_Munteanu> I'm thinking stuff that forwards only changes in its state.
18:52:27 <sinelaw> exactly
18:53:00 <zezikaro> How do you get a specific key from a map?
18:53:09 <sinelaw> what i was thinking is an operator that combines the  Lebesgue and Reimann approaches to integration
18:53:11 <zezikaro> Map.getKey "foo" map
18:53:18 <zezikaro> is what i'm after
18:53:20 <sinelaw> but instead of doing integration, it could do a lot more
18:53:20 <Eduard_Munteanu> :t Map.lookup
18:53:21 <lambdabot> Couldn't find qualified module.
18:53:29 <Eduard_Munteanu> @hoogle lookup
18:53:30 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
18:53:30 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
18:53:30 <lambdabot> Data.HashTable lookup :: HashTable key val -> key -> IO (Maybe val)
18:53:38 <zezikaro> !
18:53:38 <Eduard_Munteanu> @more
18:53:39 <zezikaro> is that right?
18:53:52 <zezikaro> map ! "foo"
18:54:22 <Eduard_Munteanu> lookup :: Ord k => k -> Map k a -> Maybe a
18:54:45 <Axman6> @hoogle Ord k => k -> Map k a -> Maybe a
18:54:46 <strager> You should import Map qualified, probably
18:54:46 <lambdabot> Data.Map lookup :: Ord k => k -> Map k a -> Maybe a
18:54:46 <lambdabot> Data.Map lookupIndex :: Ord k => k -> Map k a -> Maybe Int
18:54:46 <lambdabot> Data.Map (!) :: Ord k => Map k a -> k -> a
18:54:50 <Eduard_Munteanu> zezikaro: that would do too, but perhaps you want to see if it's in the map to begin with
18:54:58 <strager> So you'd do: mymap M.! key
18:55:07 <strager> Or use lookup, which is safer
18:55:12 <zezikaro> that returns a boolean?
18:55:17 <zezikaro> how does mymap M.! key
18:55:18 <zezikaro> work sorry
18:55:31 <byorgey> it doesn't
18:55:31 <strager> Do you know how !! works for lists?
18:55:35 <byorgey> > fromList [("a", 3)] ! "b"
18:55:36 <lambdabot>   No instance for (Control.Monad.Random.Class.MonadRandom
18:55:36 <lambdabot>                    ...
18:55:36 <zezikaro> yeah
18:55:50 <byorgey> > M.fromList [("a", 3)] M.! "b"
18:55:51 <lambdabot>   *Exception: Map.find: element not in the map
18:55:59 <Eduard_Munteanu> :t Data.Map.empty
18:56:00 <lambdabot> forall k a. M.Map k a
18:56:05 <strager> Oh, you want elem?
18:56:21 <zezikaro> oh you're doing import qualified Data.Map as M
18:56:25 <strager> @hoogle Map.member
18:56:25 <zezikaro> that's what you meant by M.!
18:56:26 <lambdabot> Data.Map member :: Ord k => k -> Map k a -> Bool
18:56:26 <lambdabot> Data.Map notMember :: Ord k => k -> Map k a -> Bool
18:56:27 <zezikaro> right?
18:56:32 <strager> Yes
18:56:39 <zezikaro> I r lurning
18:56:43 <byorgey> zezikaro: yeah, importing Data.Map as M is common
18:56:43 <zezikaro> thanks
18:56:56 <Eduard_Munteanu> sinelaw: actually, I wonder if this has to have something to do with numeric integration
18:56:59 <strager> > "a" `M.member` M.fromList [("a", undefined)]
18:57:01 <lambdabot>   True
18:57:06 <sinelaw> Eduard_Munteanu, nope it doesn't
18:57:06 <strager> > "b" `M.member` M.fromList [("a", undefined)]
18:57:07 <lambdabot>   False
18:57:08 <byorgey> zezikaro: you say you want a Bool.  What are you going to do with this Bool?
18:57:21 <zezikaro> oh i just got confused with the "M.!" notation
18:57:28 <zezikaro> and jumped to odd conclusions
18:57:29 <zezikaro> :P
18:57:30 <Eduard_Munteanu> sinelaw: perhaps there's a formulation that's oblivious of all that? Maybe like zippers are derivatives in some context.
18:57:33 <strager> Yeah, looks odd without syntax highlighting ;P
18:57:35 <byorgey> oh, ok =)
18:58:12 <sinelaw> Eduard_Munteanu, you can define an operator that takes a function and applies it on delta-t's
18:58:40 <sinelaw> Eduard_Munteanu, and the next logical step is to make it more lebesgue-like by working with sigma-algebras instead of just numbers
18:59:08 <sinelaw> Eduard_Munteanu, and then, it can work on any haskell type
18:59:41 <sinelaw> Eduard_Munteanu, if one is into showing application of that to programming, or to whatever sets of stuff you happen to like
19:00:11 <strager> What's the aeson equivalent for XML in modern Haskell?
19:00:38 <strager> (I'm writing XML)
19:01:35 <dobblego> I use HXT
19:02:13 <strager> Looks pretty large judging from the number of modules =]
19:03:12 <strager> I don't see XML writing in HXT
19:03:26 <sinelaw> Eduard_Munteanu, here's something i wrote back in the day: http://www.ee.bgu.ac.il/~noamle/_downloads/gaccum.pdf
19:03:33 <sinelaw> you may have seen it
19:04:13 <sinelaw> It includes examples of how to define the derivative and integral
19:04:18 <Eduard_Munteanu> Hm, not yet, but I'll read it :)
19:04:29 <sinelaw> but it's only part of what I wanted to do
19:04:49 <sinelaw> it's missing the generalization to sigma-algebras and using Lebesgue-style definitions
19:05:03 <zezikaro> what is HXT?
19:05:06 <byorgey> strager: 'aeson equivalent' is underspecified.  What features do you want?
19:05:09 <strager> zezikaro: An XML package
19:05:09 <zezikaro> haskell extensible...
19:05:14 <zezikaro> oh okay
19:05:16 <strager> byorgey: Very easy way to write XML
19:05:19 <mparodi_> is there any function to remove duplicates in a list?
19:05:26 <strager> mparodi_: nub
19:05:32 <strager> :t nub
19:05:33 <lambdabot> forall a. (Eq a) => [a] -> [a]
19:05:35 <hhb_> Does anyone have datagram socket experience? My server gets 0% packet loss as long as I produce and consume from the start over a TChanIO. If I threadDelay the consumer until all packets are sent, I get over 50% packet loss. Both producer and consumer are in forkIO
19:05:39 <mparodi_> thank you strager
19:05:39 <zezikaro> I thought you were calling him a noob...
19:05:44 <strager> lol
19:05:56 <mparodi_> @index nub
19:05:57 <lambdabot> Data.List
19:06:23 <Eduard_Munteanu> sinelaw: hm, that's pretty much analysis-oriented. I was thinking of something a lot simpler, though I guess it's not FRP-ish in the modern sense.
19:06:24 <mparodi_> zenzike, it's implicit :P
19:06:26 <strager> byorgey: Preferably using type classes
19:06:47 <dmwit> hhb_: I don't know the answer, but the question was well asked.
19:06:50 <zezikaro> Can you use pattern matching on map lookups?
19:06:55 <strager> zezikaro: No
19:06:56 <sinelaw> Eduard_Munteanu, what's FRP-ish in the modern sense?
19:07:00 <strager> zezikaro: You can maybe use guards
19:07:06 <zezikaro> boo
19:07:07 <zezikaro> thanks
19:07:11 <dmwit> hhb_: If you don't get an answer here, you might try one of the mailing lists, or StackOverflow.
19:08:27 <byorgey> strager: maybe try blaze-markup
19:08:41 <Eduard_Munteanu> sinelaw: more like if you had a group with elements from a given type, you could have an integral element get those and add them up. Similarly, a derivative element would take differences.
19:08:50 <strager> byorgey: I don't see it on Hackage
19:09:01 <byorgey> http://hackage.haskell.org/package/blaze%2Dmarkup
19:09:11 <strager> Odd; Hoogle didn't find it
19:09:15 <sinelaw> Eduard_Munteanu, question is how to define something like that generally enough
19:09:22 <byorgey> hoogle doesn't search everything on Hackage
19:09:27 <sinelaw> so that it isn't just adding and differetiating
19:10:00 <bscarlet> hhb_: You're delaying all receiving until all sending is done? How much are you pushing out into the ether before you start reading?
19:10:06 <strager> byorgey: looks cool
19:10:11 <hhb_> dmwit: thanks and I'll try asking there. I can't figure out why I get more loss when I have less happening (higher memory usage, yes, but half the IO).
19:10:12 <strager> I like how it's monadic
19:10:19 <strager> I'll try it; thanks
19:10:26 <hhb_> bscarlet: about 600MB
19:10:49 <Eduard_Munteanu> sinelaw: for integrals, I guess you'd end up with something much like Writer, building up a trace of the values it got.
19:11:17 <Eduard_Munteanu> Mind, my knowledge on FRP is rather basic :)
19:11:40 <sinelaw> Eduard_Munteanu, OK :) I'm also interested in just the math
19:11:56 <Eduard_Munteanu> Heh, fair.
19:12:00 <sinelaw> Mind, I'm not a mathematician of any sort
19:12:03 <sinelaw> :)
19:12:18 <bscarlet> hhb_: By "datagram", do you mean the constructor of Network.Socket.SocketType, which looks to mean UDP, or are you using something else? (I don't have much context to go on here).
19:12:54 <hhb_> bscarlet: the log source itself is 90MB and the highest I have seen the GHC compiled binary use for resident memory is 600MB. Even a little delay in starting the consumer results in data loss.
19:13:14 <hhb_> bscarlet: UDP, yes. No upper bound on the TChanIO
19:15:39 <bscarlet> hhb_: So you write a bunch in your producer, then start consuming. Where do you think the data should be in between? I'd imagine it's passing down through some libraries, down through the OS, over the wire, and back a similar path. Where in that stack do you expect buffering?
19:16:03 <hhb_> bscarlet: "(msg) <- recv sock" is in forever. I follow that by an atomically write to the TChanIO. 0% loss if the consumer starts at the same time as aforementioned producer.
19:16:52 <hhb_> bscarlet: the buffering is good. I don't want the loss. This server is the end of the line, so I am just writing to file, putStrLn, whatever I can test. ByteString all the way.
19:17:51 <bscarlet> hhb_: But where are you expecting the buffering to happen? In a Haskell library? In the c-library underneath? In the kernel?
19:19:16 <Eduard_Munteanu> I don't think there's going to be any buffering if noone is listening.
19:19:30 <bscarlet> hhb_: Naively, I wouldn't have expected it anywhere. UDP doesn't guarantee delivery, so even without Haskell one outcome that wouldn't have surprised me if I sent a bunch of packets and didn't start receiving would be that the OS would drop them on the floor if they weren't being read fast enough.
19:20:30 <bscarlet> hhb_: i.e. my crude mental model would be there'd be receive buffer of some small fixed size in the kernel and after it filled up the kernel wouldn't have anywhere to put more packets so it'd let them drop.
19:20:42 <hhb_> bscarlet: In Haskell. TChanIO is just a Haskell linked list so I'm not even going for compactness. I just want to simulate a slow consumer and the loss is mystifying to me. I would expect it to buffer and capture just as much data as when I was buffering and consuming.
19:21:42 <hhb_> bscarlet: http://hpaste.org/68836
19:21:51 <Eduard_Munteanu> Can't you at least make the producer wait until the consumer is up?
19:22:39 <hhb_> that paste actually needs a threadDelay in main instead of return or it uses 100% cpu, FYI.
19:23:29 <Eduard_Munteanu> Oh, everything goes through the TChan?
19:24:53 <hhb_> Eduard_Munteanu: I'm trying to use a chan as a buffer. I should be able to wait to consume. Yes. And when both start at same time 0% loss. If I threadDelay the consumer for 10 seconds until all 700,000 packets arrive, I get at least 50% losss.
19:25:01 <Eduard_Munteanu> Depends how large the buffer is then.
19:25:12 <dmwit> TChan is an unbounded buffer.
19:25:23 <Eduard_Munteanu> Not that, the OS buffer.
19:25:27 <hhb_> dmwit: right
19:25:31 <hhb_> Eduard_Munteanu: oh
19:25:47 <Eduard_Munteanu> You could pretty much wait indefinitely on writeTChan there no?
19:26:22 <Eduard_Munteanu> Or does it buffer even if noone is listening?
19:26:36 <hhb_> Eduard_Munteanu: how so? If I don't writeTChan, I can't recv the next msg.
19:27:07 <hhb_> Eduard_Munteanu: recv is descirbed as blocking until a message arrives.
19:27:25 <Eduard_Munteanu> Does writeTChan block too?
19:27:36 <Eduard_Munteanu> s/Does/Can/
19:27:52 <dmwit> writeTChan doesn't block unless another thread is also trying to write.
19:27:53 <bscarlet> Eduard_Munteanu: it could, but as this code is written it shouldn't much.
19:28:32 <Eduard_Munteanu> I see.
19:28:37 <bscarlet> hhb_: do you know how the drops are distributed? All at the beginning? Randomly spaced out?
19:28:58 <hhb_> bscarlet: I don't know. I should look at that.
19:29:01 <Eduard_Munteanu> hhb_: where are you getting your data from and how fast?
19:29:24 <dmwit> hhb_: aha, I have an idea!
19:29:41 <dmwit> hhb_: Here's a question for you: are you running -threaded and with +RTS -Nsomething bigger than 1?
19:29:44 <Eduard_Munteanu> Loopback stuff could easily outrun "slower" stuff.
19:30:02 <dmwit> hhb_: If not, perhaps the main loop is pegging the CPU with the "forever (return ())" and the reader is never getting to run.
19:30:07 <hhb_> Eduard_Munteanu: From a Java app as fast as it can send. If I slow it down then it is much better, but I am trying to decouple the buffering, socket read, etc.
19:30:20 <otters> why would you forever (return ()) ?
19:30:27 <dmwit> hhb_: The correct way would be to grab the thread ids returned by the two forks and wait on them instead of using forever (return ()).
19:30:32 <hhb_> dmwit: I have been running with and without -threaded.
19:30:47 <liberty_g> I'm new to haskell and am up to the Learn You A Haskell chapter about custom type classes. I think monads are coming up soon. Once I've learned that, what's a good next step? I'd like exercises since LYAH is lacking there.
19:30:59 <Eduard_Munteanu> hhb_: you should really try to get an idea of how fast it's sending
19:31:06 <dmwit> otters: It's a pretty bad idea, yeah. At the very least forever (threadDelay ...). =)
19:31:07 <zezikaro> Could someone help me with this please http://ideone.com/2Z6oB
19:31:12 <hhb_> dmwit: I actually updated it to forever $ threadDelay(1000000 * 60)
19:31:20 <dmwit> hhb_: much better =)
19:31:20 <zezikaro> I changed my map to store the information of what to do when it finds an unknown symbol
19:31:27 <zezikaro> and now i'm getting indentation problems =[
19:31:49 <zezikaro> it's crazily indented, it's not that big when in notepad++
19:32:27 <dmwit> zezikaro: At a guess: you (and notepad++) aren't being careful about the difference between tabs and spaces.
19:33:09 <hhb_> Eduard_Munteanu: Yes, but I can't come up with a theory of why I have no loss when producer and consumer are contending over that TChan and 50% loss when the producer has the TChan all to itself.
19:33:42 <Eduard_Munteanu> hhb_: did you set the number of threads like dmwit pointed out?
19:33:45 <liberty_g> Would Real World Haskell be a good bet? I've heard it's good but don't know if it has exercises.
19:34:00 <dmwit> zezikaro: My second guess is that line 102 needs to be indented more.
19:34:07 <zezikaro> dmwit a tab isn't a space
19:34:11 <dmwit> zezikaro: (The lone } after tm = TuringMachine { ...)
19:34:11 <zezikaro> there's a setting for that though
19:34:29 <zezikaro> the error is at 48
19:34:32 <zezikaro> 58*
19:34:34 <zezikaro> 102 is fine
19:34:41 <hhb_> Eduard_Munteanu: I didn't know about that so I will try it. I had only tried it with and without -threaded alone.
19:34:57 <zezikaro> The } matches with the opening {
19:35:09 <bscarlet> hhb_: Are you waiting to send from the Java process until you know the receiver/producer is actually running?
19:35:20 <zezikaro> Or do i misunderstand you dmwit
19:36:20 <zezikaro> prog.hs:58:3: parse error (possibly incorrect indentation)
19:36:24 <hhb_> bscarlet: yes, every time.
19:37:02 <dmwit> zezikaro: Please paste your code to somewhere that doesn't convert tabs to spaces.
19:37:06 <dmwit> Perhaps hpaste.
19:37:17 <zezikaro> does hpaste execute?
19:37:24 <dmwit> No.
19:37:48 <zezikaro> !hpaste
19:37:53 <dmwit> ?where hpaste
19:37:54 <lambdabot> http://hpaste.org/
19:38:09 <zezikaro> Why hpaste over ideone?
19:38:33 <schroedinbug> liberty_g: book.realworldhaskell.org and learnyouahaskell.com.
19:39:20 <dmwit> zezikaro: I thought I just said why.
19:39:28 * hackagebot postgresql-simple 0.1.3 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.1.3 (LeonSmith)
19:39:31 <zezikaro> oh sorry
19:39:37 <zezikaro> i managed to miss that
19:39:46 <zezikaro> dmwit It was a missing bracket
19:39:49 <dmwit> zezikaro: Anyway, you're missing a closing parenthesis on line 56.
19:39:54 <liberty_g> schroedinbug:  Does real world haskell have many exercises? Learn you a haskell sure doesn't.
19:39:56 <zezikaro> :D
19:40:11 <liberty_g> Thanks for answering, btw.
19:40:27 <otters> I don't understand how the IO monad makes Haskell retain purity
19:40:59 <boccato> liberty_g: How long are you learning Haskell?
19:41:02 <ion> IO actions are pure values that only represent actions that may or may not be executed depending on whether you assign them to main or not.
19:41:04 <dmwit> otters: What things are you afraid are impure?
19:41:09 <schroedinbug> liberty_g: IIRC Real World Haskell does have exercises, but I so far think I prefer Learn You A Haskell for content.  I'm a newb to Haskell myself.
19:41:25 <dmwit> liberty_g: You might like the Typeclassopedia.
19:41:29 <zezikaro> dmwit Do you know the best way to get rid of that ugly code?
19:41:39 <zezikaro> case maybeTuple of
19:41:50 <otters> dmwit: I don't really know
19:42:10 <otters> but evaluating getChar will not give you the same result every time
19:42:11 <liberty_g> I am up to custom type classes, no monads. Glancing at haskell for about a year, learning for a few weeks.
19:42:20 <dmwit> otters: Surprise!
19:42:22 <otters> Hmmm
19:42:28 <otters> Actually, yeah it will
19:42:28 <dmwit> otters: Evaluating getChar will give you the same result every time.
19:42:33 <otters> Yep
19:42:36 <otters> okay, problem solved
19:42:43 <dmwit> Okay, congratulations, now you understand everything. =)
19:42:44 <boccato> I ask because I am learning myself, started a few weeks ago.
19:42:56 <otters> That was easier than most times I don't understand something in haskell
19:43:09 <dmwit> zezikaro: You might want to look into the Maybe monad. Dunno for sure, though, I don't really want to read that code. >_<
19:43:10 <otters> I remember when I was trying to understand join
19:43:12 <otters> it was kind of sad
19:43:25 <zezikaro> dmwit That's how bad it is..
19:43:27 <zezikaro> :'/
19:43:29 <boccato> This post might help you finding problems: http://stackoverflow.com/questions/1012573/how-to-learn-haskell
19:43:32 <otters> zezikaro: it's just long
19:43:33 <strager> Is there something like atexit in Haskell?
19:43:44 <strager> (doing something before exitFailure kills the program)
19:43:45 <dmwit> strager: exitWith
19:44:05 <liberty_g> Thanks for the tips!
19:44:10 <strager> dmwit: No; http://man.cx/atexit
19:44:24 <boccato> schroedinbug: how newb are you?
19:44:31 <dmwit> Yes, I thought atexit was something else. Sorry.
19:44:46 <dmwit> strager: You can register finalizers on foreign pointers. That's about the best thing I can think of.
19:44:56 <dmwit> Otherwise, catch your exceptions and drink your milk.
19:44:58 <strager> Maybe exitSuccess throws an exception?
19:45:05 <boccato> schroedinbug: Are you working on something? I am looking for something to get my hands dirty to help me learn :)
19:45:35 <schroedinbug> boccato: Looked at RWH a while back, then quit. Recently started reading Learn You a Haskell.
19:45:51 <boccato> It is a good book.
19:45:55 <schroedinbug> boccato: My plan was to look at the xmonad source and start hacking on it.
19:46:09 <boccato> schroedinbug: I am at chapter 10.
19:46:13 <schroedinbug> or at least understand my config...
19:46:30 <boccato> Interesting.
19:46:32 <zezikaro> in java you might do, while ((input = scanner.nextInt()) != -1) { switch(input) case 1 : ..; default : Syso("Error"); }
19:46:36 <zezikaro> How does that equate t ohaskell?
19:46:53 <zezikaro> case 1 : ...; break;*
19:47:04 <strager> zezikaro: Pattern matching?  =]
19:47:06 <boccato> I think I'll try to grasp the basics of Yesod after I finish this book.
19:47:18 <zezikaro> strager And a while loop? o.O
19:47:21 <strager> case input of 1 -> ...
19:47:41 <boccato> Are you having trouble understanding things? Cause there are some videos I found that might be helpful for you.
19:47:46 <dmwit> zezikaro: Parsing (is that what you're trying to do?) generally happens with parsec, alex/happy, or a similar library.
19:48:03 <zezikaro> No, just a simple command line tool
19:48:08 <strager> forM_ (getLine >>= read) $ \input -> case input of 1 -> ...
19:48:09 <zezikaro> that will read a 1, execute stuff
19:48:11 <zezikaro> ask for the next thing to do
19:48:21 <zezikaro> until -1
19:48:26 <dmwit> getContents >>= mapM_ foo . lines
19:48:30 <dmwit> foo :: String -> IO ()
19:48:44 <zezikaro> and it's a sequential sort of thing
19:48:58 <dmwit> or just use interact
19:49:13 <boccato> schroedinbug: Actually ppl here pointed me to them, its been very helpfull.
19:49:15 <dmwit> You might like reads :: String -> [(Int, String)]
19:49:42 <schroedinbug> boccato: The main issue I'm having a hard time with so far is finding free time.
19:49:56 <dmwit> > reads "123 the rest of the input lol" :: [(Int, String)]
19:49:57 <lambdabot>   [(123," the rest of the input lol")]
19:50:06 <boccato> yeah, that is complicated
19:50:14 <otters> > reads "123 rest" :: [(Int,a)]
19:50:16 <lambdabot>   Couldn't match expected type `a'
19:50:16 <lambdabot>         against inferred type `[GHC.Types....
19:51:42 <zezikaro> o.O
19:52:46 <otters> :t reads
19:52:47 <lambdabot> forall a. (Read a) => String -> [(a, String)]
19:53:04 <otters> :t "foo"#
19:53:05 <lambdabot> GHC.Prim.Addr#
19:57:04 <dmwit> ...Addr#?
19:57:29 <rwbarton> it's a C string I think?
19:57:43 <dmwit> wow
19:57:48 <rwbarton> so basically a char * or an Addr$
19:57:51 <rwbarton> Addr#
19:59:30 <otters> what's good for encoding/decoding htmlentities in haskell+
19:59:32 <otters> ?
20:01:38 <Ralith> otters: the list monad
20:01:38 <Ralith> :D
20:01:47 <otters> what
20:01:55 <dmwit> yeah, what
20:02:38 <Eduard_Munteanu> HXT works for HTML too.
20:02:57 <otters> actually, I think I'm already going to need to pull in a regex lib for this
20:03:08 <Eduard_Munteanu> Or tagsoup.
20:03:27 <Eduard_Munteanu> (but they're different beasts)
20:03:33 <Ralith> otters: define a function which takes a character and returns an entity-encoded versionof it [if necessary]
20:03:38 <Ralith> then yourstring >>= thatfunction
20:03:44 <otters> Ralith: but what about decoding :4
20:03:53 <Ralith> good question
20:03:54 <mparodi_> @src iterate
20:03:54 <lambdabot> iterate f x =  x : iterate f (f x)
20:04:11 <zezikaro> How do you get an infinite list of string?
20:04:21 <zezikaro> char*
20:04:25 <otters> > repeat 'c'
20:04:27 <lambdabot>   "cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc...
20:04:30 <mparodi_> @hoggle Int b -> [a] -> b -> [a]
20:04:30 <lambdabot> Did you mean: Int -> [a] -> b -> [a]
20:04:31 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
20:04:31 <lambdabot> Text.Html HtmlNode :: Html -> [HtmlTree] -> Html -> HtmlTree
20:04:40 <mparodi_> @hoggle [a] -> Int -> [a]
20:04:40 <lambdabot> Prelude drop :: Int -> [a] -> [a]
20:04:40 <lambdabot> Data.List drop :: Int -> [a] -> [a]
20:04:40 <lambdabot> Prelude take :: Int -> [a] -> [a]
20:04:47 <zezikaro> > "abc" + (repeat '...')
20:04:48 <lambdabot>   <no location info>:
20:04:48 <lambdabot>      lexical error in string/character literal at chara...
20:04:52 <zezikaro> > "abc" ++ (repeat '...')
20:04:53 <lambdabot>   <no location info>:
20:04:53 <lambdabot>      lexical error in string/character literal at chara...
20:04:55 <mparodi_> > take 10 [1..]
20:04:56 <Ralith> zezikaro clearly asked for an infinite list of string
20:04:56 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
20:04:59 <mparodi_> :)
20:05:00 <Ralith> > repeat "c"
20:05:04 <lambdabot>   ["c","c","c","c","c","c","c","c","c","c","c","c","c","c","c","c","c","c","c...
20:05:05 <otters> zezikaro: "..." not '...'
20:05:06 <zezikaro> > "abc" ++ (repeat '.')
20:05:10 <lambdabot>   "abc..........................................................................
20:05:16 <geekosaur> > cycle "ha"
20:05:17 <lambdabot>   "hahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahaha...
20:05:37 <zezikaro> thank you :)
20:05:44 <Ralith> otters: anyway, don't use regexps
20:05:48 <mparodi_> > concat $ repeat 'c'
20:05:49 <lambdabot>   Couldn't match expected type `[a]'
20:05:50 <lambdabot>         against inferred type `GHC.Types...
20:05:52 <otters> Ralith: I'm going to need them for something else
20:05:53 <Ralith> they don't perform very well and they're extremely bug prone
20:05:54 <mparodi_> > concat $ repeat "ha"
20:05:55 <lambdabot>   "hahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahaha...
20:05:56 <Ralith> doesn't matter
20:05:58 <otters> but okay
20:06:06 <mparodi_> @src cycle
20:06:06 <lambdabot> cycle [] = undefined
20:06:06 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
20:06:08 <Ralith> use a real parser whenever possible
20:06:16 <Ralith> haskell is full of nice parsing libraries
20:06:19 <Ralith> some of them are even invertible!
20:06:24 <otters> well Text.HTML.TagSoup.Entity has lookupEntity
20:06:32 <zezikaro> i don't know what that word means
20:06:35 <zezikaro> 'invertible'
20:06:40 <otters> can be inverted
20:06:43 <Ralith> that's okay, I was talking to otters
20:06:45 <Ralith> >_>
20:06:57 <otters> so, recursion
20:07:05 <otters> it's going to be dirty
20:07:08 <otters> but whatevs
20:07:19 <Ralith> ?
20:07:26 <Ralith> by "use a real parser" I don't mean "write a parser by hand"
20:07:29 <Ralith> I mean parsec or something
20:07:41 <Ralith> hand-written parsers are generally almost as bad as regexps, if not worse.
20:07:45 <otters> oh, you think I should use a parser for decoding?
20:08:02 <Ralith> that's what I'd do if I had to implement it from scratch, anyway.
20:08:06 <otters> huh
20:08:08 <otters> okay
20:08:37 <Ralith> it's a painfully simple grammar; just gotta get the escapes right.
20:08:51 <mparodi_> @src scanl1
20:08:51 <lambdabot> scanl1 f (x:xs) =  scanl f x xs
20:08:51 <lambdabot> scanl1 _ []     =  []
20:08:56 <otters> right
20:08:56 <mparodi_> @src scanl
20:08:56 <lambdabot> scanl f q ls = q : case ls of
20:08:56 <lambdabot>     []   -> []
20:08:57 <lambdabot>     x:xs -> scanl f (f q x) xs
20:09:28 <Ralith> (which is one of the reasons to avoid regexps; they don't handle things like escapes very well)
20:10:08 <otters> I see
20:11:02 <mparodi_> lambdabot, http://en.wikipedia.org/wiki/Naming_convention_%28programming%29#JavaScript
20:11:03 <mparodi_> be happy :)
20:11:23 <mauke> Ralith: what
20:11:30 <mauke> how do regexes not handle escapes?
20:12:21 <Ralith> mauke: match \n but not \\n while still matching \\\n
20:12:32 <Ralith> I don't recall if it's strictly possible, but it's certainly not easy.
20:12:34 <mauke> er. trivial?
20:12:38 <Ralith> oh?
20:12:46 <mauke> \\.
20:12:56 <Ralith> um
20:12:58 <mauke> match backslash followed by any character
20:12:59 <mparodi_> is there a "sublist list start end" function?
20:13:06 <Ralith> that doesn't work.
20:13:10 <mauke> why not?
20:13:13 <mparodi_> @hoggle [a] -> Int -> Int -> [a]
20:13:13 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
20:13:14 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
20:13:14 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
20:13:22 <Ralith> \\n contains a backslash followed by a character.
20:13:27 <mparodi_> @hoggle+
20:13:27 <lambdabot> Data.IntMap findWithDefault :: a -> Key -> IntMap a -> a
20:13:27 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
20:13:28 <lambdabot> Data.List zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
20:13:37 <Ralith> but it's an escaped backslash, so it shouldn't be matched.
20:13:38 <mauke> Ralith: ok, then I need a better problem description
20:13:52 <mparodi_> @hoggle+
20:13:52 <lambdabot> Test.QuickCheck.Gen unGen :: Gen a -> StdGen -> Int -> a
20:13:52 <lambdabot> Network.BufferType buf_snoc :: BufferOp a -> a -> Word8 -> a
20:13:52 <lambdabot> Data.List zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
20:14:04 <mparodi_> hmn, it seems the answer is no
20:14:06 <Ralith> I think otters understood me. I'm not sure why you didn't
20:14:12 <Ralith> can you hilight what was unclear?
20:14:22 <zezikaro> if (modifyOperation state) returns a type of 'data modify = Set Char | Leave deriving (Show)'
20:14:26 <zezikaro> How do you get the char?
20:14:42 <Ralith> zezikaro: pattern-match
20:14:47 <mauke> Ralith: what you're trying to do
20:14:50 <Clint> you want to match either a newline or a backslash followed by n?
20:14:54 <Ralith> mauke: I'm not trying to do anything.
20:15:02 <zezikaro> Ralith stateToString = "[ label = \"<" ++ show (readSymbol state) ++ ", " ++ show (modifyOperation state) ++ ", " ++ (transferState state) ++ ">\"]"
20:15:09 <zezikaro> How can i pattern match in those circumstances
20:15:10 <mauke> Ralith: then what's an escape?
20:15:15 <rwbarton> case modifyOperation state of { Set ch -> {- ... use ch ... -} ; Leave -> {- something else -} }
20:15:41 <Ralith> zezikaro: by moving the modifyOperation call elsewhere.
20:16:21 <Ralith> mauke: most commonly, "escape" refers to a symbol which inverts the specialness of another symbol.
20:16:26 <mauke> yes
20:16:44 <mauke> "specialness" refers to some interpretation of the symbol
20:16:57 <zezikaro> thank you
20:17:03 <mauke> if you're not processing symbols and interpreting them in some way, "escape" is meaningless
20:17:15 <Ralith> indeed.
20:17:29 <mauke> hence why I asked what you're trying to do
20:17:34 <mauke> i.e. what the overall operation is
20:17:40 <Ralith> perhaps you should be speaking to otters?
20:17:57 <mauke> otters didn't make a claim about regexes AFAICS
20:18:04 <Ralith> that's correct.
20:18:11 <Ralith> he's also the one trying to do a thing.
20:19:16 <mauke> ok?
20:19:37 <Ralith> glad we got that cleared up!
20:19:47 <mauke> so basically I think you're wrong
20:20:24 <Clint> and it's settled
20:21:36 <Twisol> Wow, just read about iteratees. Seems like a really useful technique
20:24:23 <mauke> .oO( (\\.)*\n )
20:26:19 <otters> so why is Data.ByteString.Char8.pack '\4660' == "4"
20:26:24 <Ralith> mauke: I'm not even sure what that's supposed to do.
20:26:40 <Ralith> \\{2}*\n might work, though, come to think of it
20:26:43 <Ralith> er
20:26:44 <Ralith> \\n
20:27:06 <mauke> Ralith: it's the solution to the following task:
20:27:43 <mauke> you're given a string in which \ is an escape character. use a regex search to find all unescaped newlines
20:27:47 <tgeeky__> has anyone else here played with shplit?
20:27:50 <tgeeky__> @hackage shplit
20:27:50 <lambdabot> http://hackage.haskell.org/package/shplit
20:27:52 <Ralith> I don't think so.
20:28:59 <Ralith> yep, testing confirms
20:29:04 <mauke> hmm?
20:29:49 <otters> > "\4660"
20:29:51 <lambdabot>   "\4660"
20:30:00 <otters> :t pack
20:30:01 <lambdabot> forall o n. (Newtype n o) => o -> n
20:30:01 <kallisti> tgeeky__: looks cool, but not something I would use as a productivity tool.
20:30:07 <otters> :t Data.ByteString.Char8.pack
20:30:08 <lambdabot> String -> BSC.ByteString
20:30:18 <otters> > Data.ByteString.Char8.pack "\4660"
20:30:19 <lambdabot>   Not in scope: `Data.ByteString.Char8.pack'
20:30:22 <otters> oh
20:30:29 <otters> no but seriously, that gives me "4"
20:30:33 <otters> which is really not what I wanted to happen
20:30:36 <mauke> > 4660 `mod` 256
20:30:38 <lambdabot>   52
20:30:39 <tgeeky__> kallisti: not productivity, but if you want to not think about the mechanical definitions when dealing with non-empty lists (using lists)
20:30:42 <kallisti> ByteStrings aren't strings
20:30:42 <mauke> > chr (4660 `mod` 256)
20:30:44 <lambdabot>   '4'
20:30:47 <tgeeky__> kallisti: I think it might work well for that
20:30:49 <mauke> otters: what did you want to happen?
20:31:13 <tgeeky__> kallisti: it occurs to me, however, that it's kind of weird how "special syntax-y" the definition for list is.
20:31:16 <otters> mauke: I would love for it to be Ethiopic Syllable See
20:31:19 <otters> which is what the unicode standard sas
20:31:21 <otters> *says
20:31:23 <mauke> otters: there is no such byte
20:31:25 <kallisti> tgeeky__: it's completely special.
20:31:25 <otters> randomly chosen character
20:31:27 <Twisol> chr 4660 ?
20:31:30 <otters> huh
20:31:37 <otters> okay
20:31:48 <kallisti> otters: ByteStrings are sequences of bytes
20:31:53 <otters> I'm aware there's no such byte
20:31:59 <otters> so I have to convert that into several bytes
20:32:07 <mauke> which bytes?
20:32:14 <kallisti> in order to translate a sequence of charactres to a sequence of bytes you need to use a specific encoding.
20:32:22 <otters> mauke: \xe1\x88\xb4
20:32:26 <kallisti> as it stands a Unicode codepoint isn't any particular sequence of bytes.
20:32:27 <tgeeky__> kallisti: I know. The point is, playing with this (and reading the source) it occurs to me, that we could just as well have a *second* list-kind where you have, say, <> as your left-and right-right bracket (and as empty).
20:32:27 <otters> oh, UTF-8
20:32:36 <otters> soo uh
20:32:52 <otters> anybody know of a library that will encode that for me
20:32:53 <tgeeky__> kallisti: that is, you just have two ways to pattern match a list, with no other distinction that they won't pattern match the other
20:33:22 <kallisti> tgeeky__: I really think list syntax should be overloaded.
20:33:33 <tgeeky__> kallisti: well, I mean to actually have two seperate ones
20:33:56 <tgeeky__> kallisti: so you can have, say, a bijection from [] to <>
20:33:58 <kallisti> yes I understood. I don't really know if <> would be worth all the things it breaks.
20:34:10 <tgeeky__> kallisti: well, we can use whatever symbols we want
20:34:15 <tgeeky__> as long as we have a 2nd kind of them
20:34:23 <tgeeky__> kallisti: ie: data {-xs-}[] x = [] | {-x-}x : {-xs-}[x]
20:34:23 <kallisti> sure
20:34:25 <tgeeky__> instead of that
20:34:39 <kallisti> Perl 6 has circumfix operators that work like that for any kind of Unicode "brackets".
20:34:41 * hackagebot postgresql-libpq 0.8.2 - low-level binding to libpq  http://hackage.haskell.org/package/postgresql-libpq-0.8.2 (LeonSmith)
20:35:08 <mzero> perl 6 has operators for almost anything
20:35:13 <Ralith> oh man encodings
20:35:34 <mzero> http://www.ozonehouse.com/mark/periodic/
20:35:44 <tgeeky__> well, I was going to invent some fancy scheme, but it's easier to go ahead with what I said (ignoring totally the existing usage of (<), (>), and (<>)):
20:36:09 <tgeeky__> data {-xs-}<> x = <> | {-x-}x : {-xs-}<x>
20:36:16 <tgeeky__> and then you can write functions like:
20:36:36 <Twisol> otters: I don't know, but try Hoogle or Hayoo.
20:36:47 <tgeeky__> dom2ran :: <a> -> [a]   ;  ran2dom :: [a] -> <a>
20:36:57 <otters> I did it!
20:37:45 <tgeeky__> but you could also do: dd2rr :: <a> -> <a> -> [a] -> [a]
20:37:55 * kallisti wonders why Haddock doesn't bother to document fixity declarations
20:38:18 <tgeeky__> isn't there some more general way to do fixity stuff? it involved reverse polish notation or something?
20:38:46 * tgeeky vaugely remembers a reddit link
20:42:42 <mauke> true, you need something like (\\.)*([^\\]|$) - which is pointless
20:43:12 <tgeeky> as in, not worth doing, or point-free?
20:43:13 <mauke> the "correct" approach is to tokenize everything with \\.|[^\\]
20:43:22 <Twisol> looks like a regex, not a function
20:43:30 <Twisol> would assume the former
20:50:06 <otters> well, this is definitely a problem
20:50:25 <otters> because attoparsec doesn't have a "char" function that recognizes a UTF-8 character
20:51:07 <Ralith> is parsec specific to characters?
20:51:15 <dmwit> no
20:51:17 <otters> I have no idea
20:51:21 <Ralith> so just use a sequence of codepoints.
20:51:33 <Ralith> there's no such thing as a "UTF-8 character" anyway
20:51:42 <dmwit> attoparsec is really for binary data, not text
20:51:45 <otters> good, technicalities help me
20:51:56 <Ralith> there're UTF-8 code units, but those don't correspond to characters.
20:51:56 <otters> what should I use for the encoder?
20:52:02 <dmwit> ?hackage encoding
20:52:03 <lambdabot> http://hackage.haskell.org/package/encoding
20:52:09 <dmwit> is my favorite
20:52:12 <dmwit> It's quite complete.
20:52:38 <otters> doesn't have HTML entities, but hey
20:52:51 <dmwit> Oh, there's Data.Attoparsec.Text.
20:52:52 * Ralith advises against trying to process actual characters, as pinning them down is incredibly hard.
20:53:05 <dmwit> So after you've decoded the UTF8, you can still use attoparsec if that's your cup of tea.
20:53:11 <otters> Ralith: I need to process actual characters so that I can convert them into HTML entities
20:53:18 <mzero> Parsec can be based over anything you want
20:53:23 <Ralith> otters: I think you can make do with codepoints for that.
20:53:32 <otters> I don't know ho
20:53:32 <mzero> it parses a sequence of a -- you pick a
20:53:33 <otters> w
20:53:48 * Ralith digs around for the unicode glossary
20:54:08 <Ralith> http://www.unicode.org/glossary/
20:54:11 <Ralith> may be illustrative.
20:54:24 <mzero> are you parsing textual input, or a binary protocol?
20:54:36 <otters> textual input
20:54:51 <zezikaro> Hi, I got a new book today about haskell, and it says "import SEOGraphics"
20:54:52 <mzero> if it is text, almost certainly what you want to do then is read the text via Data.Text or Prelude
20:55:00 <zezikaro> but when i run the program it says "module SEOGraphics not found"
20:55:05 <mzero> and use Parsec over Char -- which are Unicode Characters
20:55:07 <otters> but IIRC
20:55:08 <Ralith> otters: A character is encoded by one or more codepoints. A codepoint is encoded by one or more code units.
20:55:19 <zezikaro> or rather, "could not find module 'SEOGraphoics"
20:55:23 <Ralith> all lower ASCII is single-codepoint.
20:55:28 <zezikaro> Does anyone know if that's deprecated or something and was removed?
20:55:38 <Ralith> things outside of lower ASCII should probably be escaped regardless.
20:55:38 <mauke> Ralith: also, s/codepoint/scalar value/g IIRC
20:55:39 <dmwit> zezikaro: You will need to install a library that provides it.
20:55:55 <mzero> what? Ralith that seems like odd advice
20:55:59 <Ralith> mauke: not as I understand it--can you cite?
20:56:00 <dmwit> zezikaro: As I suggested when you mentioned this before, you could install soegtk and import Graphics.SOE.Gtk, for example.
20:56:08 <Ralith> mzero: for safe HTML transport, I mean.
20:56:10 <mauke> zezikaro: you misspelled SEOGraphics
20:56:18 <mzero> no - that is silly
20:56:31 <Ralith> to tell the truth I was thinking of URL encoding
20:56:33 <mzero> as long as you properly state the encoding
20:56:36 <Ralith> yeah
20:56:37 <mauke> Ralith: IIRC UTF-16 surrogates are "codepoints"
20:56:44 <mzero> HTML works with UTF-8 everywhere
20:57:02 <Ralith> mauke: yes, they are
20:57:07 <mzero> mauke: they are not
20:57:11 <Clint> well, except for the things you need to escape
20:57:12 <Ralith> wat
20:57:25 <Ralith> mzero: they are.
20:57:33 <Ralith> I just verified on the spec.
20:57:42 <mzero> Chapter 3?
20:57:49 <zezikaro> dmwit Sorry, how do you install soegtk?
20:57:53 <mauke> usually when people talk about codepoints they mean "scalar values"
20:58:08 <dmwit> zezikaro: cabal install alex happy && cabal install gtk2hs-buildtools && cabal install soegtk
20:58:22 <mzero> unicode scalar values are all values 0 - 10ffff save d800 -dfff
20:58:23 <dmwit> zezikaro: You will also need the -dev versions of the gtk libraries.
20:58:27 <dmwit> zezikaro: Windows or Linux?
20:58:32 <zezikaro> windows
20:58:35 <zezikaro> this seems complicated o.o
20:58:35 <dmwit> zezikaro: ...or, God help you, Mac?
20:58:36 <dmwit> okay
20:58:39 <mzero> they correspond to exactly that set of values that can be encoded in every Unicode encoding form
20:58:43 <Ralith> mzero: refer to D10a
20:58:53 <Ralith> mauke: I see, good to know.
20:58:59 <dmwit> zezikaro: Installation instructions are available here: http://code.haskell.org/gtk2hs/INSTALL
20:59:14 * mauke shakes fist at UTF-16
20:59:17 <dmwit> zezikaro: Or, if your book has another suggestion about how to install a library that provides that module, by all means follow those instead.
20:59:20 <Ralith> mzero: better still, D15
20:59:26 <Ralith> Surrogate code points and noncharacters are considered assigned code points,
20:59:26 <Ralith> but not assigned characters
20:59:45 * hackagebot highlighting-kate 0.5.1 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.1 (JohnMacFarlane)
20:59:52 <zezikaro> nope it just said used SOEGraphics instead of Graphics
20:59:55 <zezikaro> because Graphics might change
21:00:11 <mzero> Ralith: my bad - but still - never define strings in terms of those
21:00:15 <mzero> always unicode scalar avalues
21:00:29 <Ralith> why's that?
21:00:57 <Ralith> the rationale isn't obvious, other than "avoid accidentally encoding a surrogate"
21:01:15 <mzero> D76
21:01:31 <mzero> because surrogates cannot exist as arbitrary entities in any encoding
21:01:34 <Ralith> oh
21:01:34 <zezikaro> well that didn't work
21:01:35 <zezikaro> -.-
21:01:38 <Ralith> so that is literally the rationale
21:01:39 <zezikaro> thanks
21:01:42 <Ralith> that works I guess!
21:02:18 <mzero> anyhow - I don't know what you and otters are parsing - but parsing Char is pretty reasonable
21:02:29 <mzero> just decode your input first - then parse over that
21:02:52 * Ralith doesn't actually remember what Char actually corresponds to
21:03:00 <mzero> as for output - if it is to be HTTP or HTML compatible, encoding at UTF-8 is generally universally interoperable
21:03:07 <mzero> so long as you mark it as such
21:03:22 <mzero> Char corresponds to Unicode Scalar Value I think
21:03:37 <mauke> codepoint
21:03:41 <Ralith> welp
21:03:49 <mauke> > '\xd800'
21:03:50 <lambdabot>   '\55296'
21:04:11 <mzero> ew
21:04:41 <mauke> hey, in Perl a character is simply a 32-bit value
21:05:10 <Ralith> does ICU handle processing actual characters?
21:05:14 <mzero> I believe that has been discussed on various haskell forums as an "infelicity"
21:05:45 <mzero> Ralith: as ICU is developed in part by core Unicode team members... yes
21:06:00 <Ralith> that's why I imagined it, if anything, would.
21:06:01 <Ralith> cool.
21:06:17 <Axman6> > text "\xd800"
21:06:19 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
21:06:51 <poseidon> Any reading on what the '$' does in haskell?
21:06:59 <mzero> to quote the Haskell 2010 report: "The character type Char is an enumeration whose values represent Unicode (or equivalently ISO/IEC 10646) characters"
21:07:11 <Ralith> oh dear.
21:07:40 <mauke> @src ($)
21:07:40 <lambdabot> f $ x = f x
21:08:11 <Ralith> poseidon: it's a syntax hack.
21:08:15 <mzero> I believe I have argued that that is a terrible definition
21:10:24 <hhb_> Hi, can anyone tell me what the (MkSocket s _ _ _ _) part of http://hackage.haskell.org/packages/archive/network/2.3.0.13/doc/html/src/Network-Socket-ByteString.html#recv is doing?
21:10:57 <zezikaro> it's pattern matching
21:11:03 <zezikaro> its first argument is of type MKSocket
21:11:19 <mzero> yikes - I had argued and got Dart's defintion to be based on "unicode scalar value" - but the current draft seems to have back-slid (though you can see evidence that it had been "unicode scalar value" in the text still)
21:11:22 <zezikaro> and it's taking the value s from one of the values from its constructor
21:11:33 <zezikaro> so that it can make use of s inside of the function
21:11:51 <Ralith> zezikaro: MkSocket is a data constructor, not a type.
21:11:56 <hhb_> OK, so it is returning a fd to s it seems
21:12:08 <zezikaro> sorry
21:12:11 <zezikaro> i knew what i meant
21:12:24 <zezikaro> but didn't put it nt othe right words
21:12:29 <Ralith> kk
21:12:30 <hhb_> Thanks!
21:12:49 <zezikaro> hhb_ pattern matching is covered in learn you a haskell
21:13:14 <zezikaro> and holy shit, that's the first question i've actually understood
21:13:20 <zezikaro> *fuck yeah*
21:13:31 <hhb_> zezikaro: :)
21:15:22 <zezikaro> what is the natural progression of learning for a beginner to haskell?
21:15:45 <parcs`> http://www.willamette.edu/~fruehr/haskell/evolution.html
21:17:50 <Twisol> I'm not sure I even want to understand what most of that does
21:18:47 <dmwit> I'm always terrified of clicking that link.
21:18:50 <tgeeky> Twisol: if that's the article I think it is, the point is, they all "do" the same thing :o
21:19:05 <Twisol> It's the many ways of writing factorial
21:19:06 <tgeeky> well, probably "are"
21:19:10 <dmwit> Because every time I do I find out I've made it a little lower on the page, and still think all the ones below it are a terrible idea...
21:19:28 <Twisol> :D
21:20:14 <Ralith> haha
21:20:32 <Twisol> Does anyone know of any real-world usage of iteratees? I want to investigate the concept a little.
21:20:39 <tgeeky> dmwit: ah, you should have started at the end, and move the last element to the first
21:20:50 <tgeeky> Twisol: they are used *all over* the place
21:21:17 <tgeeky> dmwit: and then, they would get better and better :O
21:23:31 <Twisol> It looks like I'll be writing some kind of iteratee for my Telnet reader.
21:24:42 <tgeeky> perhaps you can be tempted to investigate the grandchildren of the iteratee problem with conduit and pipes
21:28:30 <Twisol> tgeeky: interestingly, I'm reading a Reddit comment thread about pipes/conduits right now
21:28:49 <Twisol> tgeeky: How do iteratees and conduits/pipes differ exactly?
21:29:30 <khayyim> Are foldl and foldr both tail recursive?
21:29:46 <Axman6> have a look and tell us
21:29:49 <Axman6> @src foldl
21:29:50 <lambdabot> foldl f z []     = z
21:29:50 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:29:51 <Axman6> @src foldr
21:29:51 <lambdabot> foldr f z []     = z
21:29:52 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
21:30:03 <Axman6> what's the last thing that's called in each?
21:30:42 <shachaf> khayyim: Tail recursion is pretty different in Haskell from other languages.
21:30:45 <khayyim> ah, so just foldl?
21:30:56 <shachaf> khayyim: You should pretty much never use foldl.
21:31:05 <shachaf> foldr and foldl' are the functions you want.
21:31:08 <Twisol> News to me. Why?
21:31:19 <khayyim> I'm asking so that I understand tail recursion, btw.
21:31:25 <shachaf> @google foldr foldl foldl'
21:31:28 <lambdabot> http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'
21:31:28 <lambdabot> Title: Foldr Foldl Foldl' - HaskellWiki
21:31:41 <shachaf> khayyim: foldr is much more "fundamental" than foldl.
21:31:49 <tgeeky> Twisol: sorry, can't answer that.
21:31:56 <shachaf> You can build foldl out of foldr but not vice versa.
21:31:56 <Axman6> khayyim: tail recursion is when the recursive function calls itself as the last 'action' i guess
21:32:07 <shachaf> khayyim: Anyway, why do you care about tail recursion?
21:32:10 <tgeeky> Twisol: the guy who made conduits has written at length about the problems he saw (and solved)
21:32:21 <tgeeky> Twisol: as has the pipes guy
21:32:26 <shachaf> (There are good reasons for caring about it but there are also popular reasons that aren't good in Haskell.)
21:32:29 <Twisol> khayyim: tail recursion - in imperative languages, at least - just means that the current "frame" of execution is done, so instead of creating a new one on top and continuing with the next call, it can reuse the space immediately and return in the end straight to the initial caller
21:32:32 <khayyim> shachaf: Why care about what anything means?
21:32:46 <Twisol> tgeeky: Okay, I'll do a little field research then. Thanks
21:32:55 <khayyim> The term comes up often in my reading, and I want to make sure I know what it means.
21:32:58 <shachaf> khayyim: Because you use it to communicate with other people.
21:33:08 <shachaf> khayyim: Words don't matter nearly as much as concepts, though.
21:33:30 <shachaf> @google haskell tail recursion
21:33:32 <lambdabot> http://www.haskell.org/haskellwiki/Tail_recursion
21:33:33 <lambdabot> Title: Tail recursion - HaskellWiki
21:33:38 <shachaf> Maybe that wiki page is good.
21:33:44 <khayyim> shachaf: I don't know the difference ;)
21:34:16 <shachaf> khayyim: Part of the reason that people care about "tail recursion" is something that some people call "tail call elimination"
21:34:42 <khayyim> shachaf: I have no idea what that is; never heard of it. I shall look it up.
21:34:50 <shachaf> However, the idea of "tail call elimination" is completely at odds with the evaluation model used by every Haskell evaluator.
21:35:11 <shachaf> Therefore, caring about tail calls makes less sense in Haskell than in, say, Scheme.
21:35:39 <Axman6> except when it actually does turn tail recursive functions into loops...
21:36:00 <shachaf> Axman6: Talking about "tail call elimination" still doesn't make a whole lot of sense.
21:36:08 <khayyim> Thankfully I am far too ignorant at this point to care about tail recursion for the "wrong reasons".
21:37:19 <khayyim> Axman6: yes, I was just reading about that. Tail recursive functions  compile to loops, yes? And there is a potential problem of making an infinite loop?
21:40:10 <khayyim> Twisol: looking back at what you said about tail recursion, that sounds a lot like a loop.
21:40:28 <Axman6> well, there's less problem than if they were being called using the stack, since they will never blow the stack (that's why we want tail call elimination)
21:41:49 <Twisol> khayyim: Yep. Recursion and loops are closely related in the first place.
21:42:41 <otters> ugh
21:42:54 <otters> Data.Text doesn't have a simple "hGet" function to get one byte, which makes sense since it's not byte-based
21:43:03 <otters> but I need to read from a socket until I get a null byte
21:43:05 <otters> any suggestions?
21:43:14 <shachaf> otters: Read a ByteString from the socket, convert?
21:43:44 <shachaf> s/a ByteString/bytes/
21:43:48 <kallisti> otters: Text is for Unicode text. ByteString is for strings of bytes.
21:44:06 <Eduard_Munteanu> I'd think a null byte should result in some misparse/exception, if there's no valid interpretation as a character, no?
21:44:20 <shachaf> Eduard_Munteanu: Sure there's a valid interpretation as a character.
21:44:51 <shachaf> The octet 0 is perfectly valid ASCII and UTF-8, and the codepoint 0 is perfectly valid Unicode.
21:45:23 <Eduard_Munteanu> Does half of a newline count as such?
21:45:39 <Eduard_Munteanu> e.g. \n when nl = \r\n
21:45:40 <kallisti> otters: are you waiting for a null /byte/ or a null /character/
21:45:51 <otters> how are they different
21:46:00 <kallisti> well, for one, characters are not bytes.
21:46:01 <zzo38> Is there something like readProcess but for network instead?
21:46:01 <lambdabot> zzo38: You have 2 new messages. '/msg lambdabot @messages' to read them.
21:46:08 <zzo38> ?messages
21:46:08 <lambdabot> nortti said 1m 8d 12h 23m 56s ago: Myhell script gopher client: http://dl.dropbox.com/u/28915864/shgopher
21:46:09 <lambdabot> Taneb said 10d 13h 52m 18s ago: Thoughts on Prelude.Generalize: Data.Semigroups rather than Data.Monoid, perhaps? (maybe)
21:46:13 <otters> I'm waiting for a null character
21:46:19 <zzo38> You already told me that!!!!!
21:46:20 <lambdabot> zzo38: You have 1 new message. '/msg lambdabot @messages' to read it.
21:46:23 <shachaf> otters: Are you sure about that?
21:46:24 <kallisti> okay then that's fine. just check for '\0'
21:46:48 <otters> What if I'm waiting for a null byte?
21:47:01 <otters> it's fine anyway, I'm just returning a String and using T.pack
21:47:04 <kallisti> then use bytestrings because Text has no direct byte-based interface
21:47:46 <kallisti> but if your data is, say, Unicode text as UTF-8, then plenty of valid characters will contain null bytes.
21:47:55 <shachaf> kallisti: That's not true.
21:48:12 <kallisti> well, I guess only one then, right?
21:48:50 <shachaf> The only thing the byte 0x00 could mean in UTF-8 is the Unicode codepoint U+0000.
21:49:03 <kallisti> right.
21:49:25 <shachaf> Keep in mind that otters hasn't even stated their encoding yet.
21:49:31 <shachaf> This is kind of important.
21:49:40 <kallisti> I should have used a different example. UTF-16 perhaps.
21:49:46 <shachaf> The only person who can know whether it's a 0 byte or a 0 character is otters.
21:50:06 <kallisti> and he seems confused about the difference between codepoints, encodings, character sets, and characters.
21:50:14 <shachaf> "I need to read from a socket until I get a null byte"
21:50:15 <otters> utf-8
21:50:27 <shachaf> otters: Are you parsing a binary format?
21:50:40 <otters> No, I'm reading packets sent by a server that terminates them with \0
21:50:53 <shachaf> That sounds vaguely like a binary format...
21:51:00 <otters> Okay, fine.
21:51:02 <otters> Yes
21:51:24 <shachaf> In that case, the format specification will specify how they're terminated. :-)
21:51:33 <mzero> are the packets intended to be UTF-8? The packages are sent on a TCP stream?
21:51:44 <otters> shachaf: There is no format specification
21:51:50 <otters> mzero: yes, yes
21:51:52 <kallisti> sounds like a job for ByteString.
21:52:01 <mzero> aha- now there's your problem - no format spec!
21:52:08 <otters> Well, I didn't inven the format
21:52:10 <otters> so I can't provide the spec
21:52:11 * kallisti uses ByteString for IRC parsing because there's no standardized encoding.
21:52:13 <shachaf> otters: OK, so it's a 0 byte.
21:52:21 <shachaf> (Even though in UTF-8 they're the same.)
21:52:29 <shachaf> I decree that it's a 0 byte, so you should parse it as such.
21:54:10 <kallisti> education by force.
21:59:16 <dmwit> I demand that the format used by the server I have never contacted and for which I don't even know the name may or may not be sending a zero byte!
22:00:15 <Ralith> you demand that it may or may not?
22:00:30 <dmwit> I demand that you may or may not be twisting my words!
22:00:50 <dmwit> Sincerely, Douglas Adams (from beyond the grave).
22:01:53 <kallisti> hm, with type-level naturals and typeclass magic you could actually overload charater literals in a fairly typesafe way.
22:02:59 <kallisti> so that character literals can refer to single bytes (preferably as a family of newtyped character types) or Unicode codepoints or whatever other character set.
22:06:04 <kallisti> you could have a "generic character" type with a natural as a type parameter. the natural encodes the minimum bit width needed to represent the character.
22:06:24 <Ralith> that wouldn't work
22:06:30 <kallisti> not fully.
22:06:57 <Ralith> there are different sets of codepoints which represent different characters in the same encoding
22:07:12 <Ralith> and different encodings of the same codespace that have different bit width costs
22:07:43 <kallisti> key word here would be "minimum"
22:07:56 <kallisti> assuming that your encoding is sane.
22:08:00 <shachaf> kallisti: Please don't mix characters up with encodings. :-(
22:08:07 <kallisti> I'm not.
22:08:16 <zzo38> I think the Char should simply be 24 bits, where codes 0-127 are ASCII and everything else depends on the program.
22:08:27 <Ralith> kallisti: but your suggestion doesn't make much sense otherwise...
22:09:00 <kallisti> it relies on the fact that encodings exist.
22:09:03 <kallisti> for character sets.
22:09:27 <shachaf> I don't get it.
22:09:36 <shachaf> What should the parameter be for the character 'A'?
22:10:37 <kallisti> you'd have to assume unicode codepoints.
22:10:39 <kallisti> so
22:11:21 <Ralith> kallisti: codepoints aren't characters...
22:11:25 <kallisti> 65. it takes exactly one byte to represent (up to) the 65th Unicode codepoint.
22:11:30 <kallisti> minimum
22:12:55 <kallisti> Ralith: you would have to use Unicode codepoints as your standard medium of conversion
22:13:15 <kallisti> which is what Char represents last I checked.
22:14:08 <kallisti> I'm sure there's something I'm missing. it was just a brainstorm.
22:14:08 <shachaf> kallisti: Huh? It does?
22:14:31 <shachaf> You're being racist.
22:14:38 <shachaf> That's what you're missing!
22:15:17 <kallisti> The character type Char is an enumeration whose values represent Unicode (or equivalently ISO/IEC 10646) characters (see http://www.unicode.org/ for details).
22:16:00 <shachaf> Why should the character U+0041 get preferential treatment over the character U+5B50?
22:16:33 <kallisti> it doesn't. it simply takes more bytes to represent that number.
22:16:52 <shachaf> No it doesn't?
22:16:55 <zzo38> I dislike that feature of Haskell, so Ibtlfmm it has to be, Char is 24 bits where 0-127 are ASCII and anything else depends on the program which deals with it. So, it could be Unicode, but it might also be CP437 or some other encoding, as long as it is one which is compatible with ASCII.
22:17:01 <mzero> shachaf: purely historical artifact - but so what
22:17:19 <kallisti> oh wait
22:17:26 <mzero> zzo38: that is a wholly unworkable, error prone approach to characters which no piece of major software uses
22:17:27 <shachaf> What if I make an encoding that encodes Cyrillic characters compactly and English characters using more bytes?
22:17:29 <kallisti> shachaf: er, then I don't understand your question.
22:17:45 <shachaf> zzo38: CP437 isn't compatible with ASCII.
22:18:51 <kallisti> shachaf: ah
22:18:57 <mzero> This is all moot - the bike sheds have been fought and won - Unicode is it - and the Unicode encodings won
22:19:13 <shachaf> mzero: I'm not disagreeing with that!
22:19:17 <shachaf> And I think UTF-8 is a gret encoding.
22:19:27 <shachaf> s/et/eat/
22:19:40 <mzero> I believe you-
22:19:42 <mzero> :-)
22:19:53 <zzo38> shachaf: When control codes are used as control codes, both CP437 and ASCII can do that but CP437 also has graphical representations for the control codes; that is not my problem.
22:19:59 <shachaf> I just don't want "the minimum bit width needed to represent the character" to be considered a property of the *character*.
22:20:05 <shachaf> Because it's not, it's a property of the encoding.
22:20:14 <mzero> true dat
22:20:21 <shachaf> Nowadays-Haskell uses multiple different encodings internally.
22:20:27 <shachaf> s/ internally//
22:20:35 <kallisti> admittedly I was thinking of the encodings that currently exist, and not "whatever new encoding someone thought of that breaks this system"
22:20:42 <mzero> zzo38: that is a very silly way of looking at it
22:20:44 <zzo38> mzero: Maybe you dislike it but I think it is reasonable to use the approach I mention. I dislike many things about Unicode anyways
22:21:06 <kallisti> but I guess chinese encodings are already exist, don't they?
22:21:10 <kallisti> -are
22:21:39 <shachaf> kallisti: It's still not a property of the character.
22:21:50 <kallisti> shachaf: I didn't disagree
22:21:52 <shachaf> And anyway there are a *lot* of encodings that exist.
22:22:14 <shachaf> $ iconv -l | wc -l
22:22:15 <shachaf> 1168
22:22:42 <shachaf> (Admittedly some of those are the same encoding by different names.)
22:23:21 <kallisti> shachaf: a minimum bit width is a proprety of codepoints, but you can't use it as a standard of completely general typesafe conversion.
22:23:42 <shachaf> kallisti: It's not a property of codepoints?
22:23:52 <kallisti> assuming, you know, codepoints are integers that have bit representations
22:23:56 <kallisti> and aren't like... apples or something.
22:24:02 <shachaf> They have many different bit representations.
22:24:20 <shachaf> That's what "encoding" means.
22:24:21 <kallisti> how so?
22:24:24 <kallisti> no...
22:24:26 <kallisti> I'm not talking about encodings.
22:24:43 * mzero wonders what the minimum bit width of 0 is...
22:24:53 <kallisti> I'm talking about codepoints. they're represented by integers (typically natural numbers, right?)
22:25:00 <mzero> wonders what the minimum bit width of U+0000 is...
22:25:15 <shachaf> kallisti: And why should lower integers get encoded with fewer bits?
22:25:26 <shachaf> It should be the most common integers.
22:25:28 <kallisti> when did I mention them getting encoded to anything?
22:25:30 <kallisti> other than integers
22:25:39 <kallisti> er...
22:25:47 <shachaf> OK -- then "bits" is not a property of an integer.
22:25:52 <kallisti> I've never known of an encoding for integers
22:25:54 <kallisti> that doesn't work like that.
22:26:09 <mzero> then you haven't studied history of computer science!
22:26:12 <shachaf> That doesn't work like what?
22:26:17 <shachaf> kallisti: Huffman encoding?
22:26:27 <mzero> there have been many odd encodings of integers into bits!
22:26:52 <kallisti> somehow I feel like I'm being misinterpreted.
22:26:59 <kallisti> or perhaps I'm saying the wrong things.
22:27:12 <shachaf> Huffman encoding isn't odd at all -- it's a perfectly reasonable encoding of integers into bits (given a certain distribution) that might represent a big integer with a small number of bits.
22:27:27 <shachaf> Somehow I feel like you're being, like, racist and stuff.
22:27:42 <kallisti> racist towards larger numbers.
22:27:51 <mzero> I know a commercially successful machine, with a variable length encoding of integers, where 9 required 7 bits, and 10 required 14!  (8 and 16 if you counted parity)
22:27:53 <shachaf> Racist toward people who don't speak English.
22:28:32 <kallisti> I'm admittedly not very familiar with many encodings of things.
22:28:37 <shachaf> Because who even cares about them, right? Codepoints 0-127 4 lyfe!
22:28:40 <mzero> dudes- I think "racist" is a bit harsh of a term here --- Latin-centric, perhaps, but not "racist"
22:28:46 <kallisti> just the general idea of how they work.
22:28:56 <shachaf> mzero: It's a #haskell tradition.
22:28:57 <kallisti> and a few examples.
22:29:03 <shachaf> I may be carrying it too far. :-)
22:29:17 <earthy> mzero: what machine was that?
22:29:23 <mzero> not one I think that we should aspire to keep going
22:29:27 <mzero> IBM 1401
22:29:37 * earthy should have guessed. :)
22:29:50 <mzero> BCD variable length encoding of integers
22:30:26 <kallisti> shachaf: okay, so... when you make an assumption about how codepoints are represented as bits, then minimum bit width becomes a property of codepoints in your little closed bubble. there. :P
22:30:29 <mzero> each byte had 4 bcd bits, A and B bits (both 0 for numbers), and a Word Mark bit, the indicated the end of the variable length value.
22:33:59 <adnap> @pf \x y -> a ++ "\n" ++ b
22:34:07 <lambdabot> Maybe you meant: bf pl
22:34:18 <adnap> @pf \x y -> x ++ "\n" ++ y
22:34:18 <lambdabot> Maybe you meant: bf pl
22:34:27 <kallisti> shachaf: you could, at the very least, have typesafe overloading of character literals between Char and a newtype of Word8
22:34:28 <mzero> I think this semantic argument between k. and s. has kinda run its course - you should both shake hands and have a beer over the Unicode spec, and just accept that we are where we are: There are 1112063 unicode scalar values, numbered with the integers 0 through 0x10ffff. They've been assigned to human characters in a way that is latin-centric, euro-centric, and asian almost last (though not without everyone's input) -- and they are encoded into octets
22:34:29 <mzero> a variety of ways, whcih also mostly are latin-centric. Ah well.
22:34:36 <otters> holy mother of god
22:34:38 <otters> how many encodings are there
22:34:57 <shachaf> mzero: I didn't object to any of that!
22:35:02 <mzero> I know
22:35:07 <mzero> nor did K, really
22:35:20 <shachaf> mzero: I was objecting to kallisti's proposed latin-centric modification to Haskell.
22:35:22 <kallisti> UTF-8, UTF-16, UTF-32. all hail the Unicode!
22:35:23 <Ralith> mzero felt like there weren't enough objections going around.
22:35:28 <mzero> otters - in practice only a few dozen
22:35:34 <adnap> @pl \x y -> x ++ "\n" ++ y
22:35:55 <lambdabot> (. ('\n' :)) . (++)
22:36:07 <otters> mzero: right
22:36:08 <adnap> gross
22:36:10 <zzo38> I am making the computer system including BIOS, it doesn't use Unicode.
22:36:11 <otters> big numbers are more fun though
22:36:21 <otters> Data.Text.ICU has 229 standard converters
22:36:36 <zzo38> shachaf: I am also objecting to such modification to Haskell which is why I want to use Ibtlfmm instead
22:37:01 <adnap> > putStrLn $ (. ('\n' :)) . (++) "boop" "beep"
22:37:02 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
22:37:02 <lambdabot>         against inferred type...
22:37:32 <adnap> > (. ('\n' :)) . (++) "boop" "beep"
22:37:33 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> b'
22:37:33 <mzero> what is Ibtlfmm?
22:37:33 <lambdabot>         against inferr...
22:37:41 <kallisti> shachaf: s/latin-centric modification/poorly thought out brainstorm that was fully considered for possibly 1 minute before being carelessly uttered on IRC/
22:38:00 <shachaf> > succ."Haskell"
22:38:02 <lambdabot>   "Ibtlfmm"
22:38:15 <mzero> snort
22:38:21 <otters> > succ . "Haskell"
22:38:23 <lambdabot>   "Ibtlfmm"
22:38:30 <otters> oh, because (.) is fmap
22:38:31 <shachaf> kallisti: I ain't h8in' or anything, by the way.
22:38:35 <otters> I wondered wtf was going on
22:38:39 <mzero> only here, otters, only here
22:38:41 <adnap> > "bla"
22:38:42 <lambdabot>   "bla"
22:38:46 <otters> I know i know
22:38:53 <kallisti> > pred."Haskell"
22:38:54 <lambdabot>   "G`rjdkk"
22:38:59 <geekosaur> > (. ('\n' :)) . (++) $  "boop" "beep"
22:39:00 <lambdabot>   Couldn't match expected type `t -> [GHC.Types.Char]'
22:39:00 <lambdabot>         against inferr...
22:39:02 <kallisti> I shall design G`rjdkk then.
22:39:18 <geekosaur> oh right
22:39:22 <otters> > (succ . succ) . "Haskell"
22:39:24 <lambdabot>   "Jcumgnn"
22:39:26 <geekosaur> > ( (. ('\n' :)) . (++) ) "boop" "beep"
22:39:28 <lambdabot>   "boop\nbeep"
22:39:31 <otters> wins, because it has the word "cum"
22:39:35 <adnap> geekosaur: ty
22:39:40 <otters> Jcumgnn -- Haskell++
22:39:42 <geekosaur> extra parentheses
22:39:44 <andares> oh, that makes sense. list monad and all.
22:39:48 <mzero> Hah - the Klingon Empire create G`rjdkk ten thousand years before your father was born!  G`rjdkk!!!!
22:39:58 <kallisti> > unlines ["boop", "beep"] -- adnap
22:39:59 <lambdabot>   "boop\nbeep\n"
22:40:02 <kallisti> oh not quite
22:41:06 <adnap> foldr1 (\x y -> x ++ y) ["boop", "beep", "bop"]
22:41:09 <adnap> > foldr1 (\x y -> x ++ y) ["boop", "beep", "bop"]
22:41:10 <lambdabot>   "boopbeepbop"
22:41:19 <adnap> > foldr1 (\x y -> x ++ "\n" ++ y) ["boop", "beep", "bop"]
22:41:20 <lambdabot>   "boop\nbeep\nbop"
22:41:40 <kallisti> > intercalate "\n" ["boop", "beep", "bop"]
22:41:40 <lambdabot>   "boop\nbeep\nbop"
22:41:41 <andares> why the \n+
22:41:51 <adnap> kallisti: ty
22:42:27 <kallisti> Haskell is too fancy to use join for that
22:42:31 <kallisti> it needs that for something else.
22:43:03 <shachaf> kallisti: Maybe I just misunderstood and was being mean for no reason.
22:43:18 <adnap> kallisti: what module is intercalate in?
22:43:20 <kallisti> shachaf: no all of your points were valid.
22:43:23 <kallisti> adnap: Data.List
22:43:41 <mzero> > unlines . map ('b':) . (++["oo"]) . map (:"ppity") . map toLower $ "IO"
22:43:42 <lambdabot>   "bippity\nboppity\nboo\n"
22:44:02 <kallisti> shachaf: I hadn't fully thouht the idea through, I was considering only a small number of candidate character sets, and their common encodings.
22:44:17 <mzero> I win cause I got IO in there!
22:44:49 <andares> fmap (++) ["hello","cool","world"]
22:45:09 <andares> > fmap (++) ["hello","cool","world"]
22:45:10 <lambdabot>   Overlapping instances for GHC.Show.Show
22:45:10 <lambdabot>                              ([GHC....
22:45:22 <andares> hm.
22:45:39 <mzero> > foldl1 (++)  ["hello","cool","world"]
22:45:41 <lambdabot>   "hellocoolworld"
22:46:19 <mzero> your expression simply created a list of three functions (each ready to append something)
22:46:31 <kallisti> > fmap ($ "") . foldr (.) id . fmap (++) $ ["hello", "cool", "world"]
22:46:32 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> b'
22:46:32 <lambdabot>         against inferr...
22:46:56 <kallisti> > ($ "") . foldr (.) id . fmap (++) $ ["hello", "cool", "world"]
22:46:57 <lambdabot>   "hellocoolworld"
22:47:01 <andares> ahhh, I see.
22:47:46 <otters> the best part is I actually know what is going on in there
22:47:52 <kallisti> hm
22:48:02 <kallisti> > foldr (.) ($ "") . fmap (++) $ ["hello", "cool", "world"]
22:48:02 <lambdabot>   Overlapping instances for GHC.Show.Show
22:48:02 <lambdabot>                              (([GHC...
22:48:04 <kallisti> aw
22:48:22 <kallisti> yeah that wouldn't make sense.
22:48:23 <andares> :t traverse
22:48:24 <lambdabot> Not in scope: `traverse'
22:48:38 <andares> there's a function that looks like [a] -> (a -> m b) -> m [b], right?
22:48:45 <kallisti> :t concatMap
22:48:45 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
22:49:01 <andares> is there anything that takes m n a -> n m a?
22:49:22 <kallisti> not that I know of.
22:49:31 <mzero> @hoogle (a -> m b) -> [a] -> m [b]
22:49:31 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
22:49:31 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
22:49:31 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
22:49:44 <kallisti> oh I misread.
22:49:48 <mzero> :t swap mapM
22:49:49 <lambdabot> Not in scope: `swap'
22:49:54 <mzero> :t flip mapM
22:49:55 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
22:50:13 <mzero> :t forM
22:50:14 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
22:50:31 <mzero> hoogle is your friend!
22:50:36 <kallisti> delicious cat skins.
22:51:40 <kallisti> oh wait
22:51:47 <kallisti> :t (sequence .) . map
22:51:47 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m [a]
22:52:12 <dobblego> andares: I think you mean m (n a) -> n (m a)
22:52:19 <dobblego> in which case sequence/distribute
22:52:22 <andares> ah, quite right.
22:52:28 <andares> :t sequence
22:52:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
22:52:33 <andares> :t distribute
22:52:34 <lambdabot> Not in scope: `distribute'
22:52:48 <dobblego> http://hackage.haskell.org/packages/archive/distributive/0.2.0.1/doc/html/Data-Distributive.html#t:Distributive
22:53:19 <andares> but then I'd also need m (n a) -> m a, which I could easily write using fmap but ehhh.
22:53:51 <kallisti> fmap (foldr something something)  ???
22:53:59 <mzero> did you mean    m (n a) ->  n (m a)   ?
22:54:21 <dobblego> @type fold
22:54:22 <lambdabot> Not in scope: `fold'
22:54:24 <dobblego> @type Data.Foldable.fold
22:54:25 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
22:55:11 <nilg> could someone help me decipher an expression on this page http://blog.sigfpe.com/2008/02/purely-functional-recursive-types-in.html ?
22:55:26 <mzero> sure - which one
22:55:51 <nilg> in the definition of tailHelper is the x new or the old one in tail?
22:55:56 <nilg> tail x?
22:56:16 <mzero> new
22:56:22 <mzero> because it appears on the left of the =
22:56:47 <mzero> GHC would give a warning that the x in tailHelper's two clauses are shadowing the x in tail's clause
22:57:24 <zzo38> Can you please tell me if there is anything like readProcess but for network connections instead of execute programs locally?
22:57:27 <nilg> mzero: so you not cannot a variable for pattern matching?
22:57:29 <kallisti> a helpful warning, but annoying when you're trying to remove all warnings from your code. :P
22:57:46 <mzero> nilg: correct, not in the pattern match -- variables there are always new ones
22:57:53 <nilg> thanks
22:58:02 <mzero> if you need to compare for equality against a value you have in some variable
22:58:04 <mzero> you need a guard
22:58:13 <kallisti> it would be interesting if you could somehow drop old variables into a pattern..
22:58:55 <mzero> don't go there, kallisti, it makes a mess of scoping
22:59:01 <kallisti> essentially it would just be a structural equality
22:59:31 <kallisti> yes, you would need some syntax to distinguish between variable substition and pattern variables, of course.
23:01:34 <kallisti> what do you guys think about overloaded sequence syntax
23:01:57 <kallisti> overloaded [], (:), and [a,b,c].
23:02:19 <kallisti> it would greatly simplify pattern matching on sequence-like types.
23:02:20 <Eduard_Munteanu> kallisti: for Seq? You could just use view patterns to get pattern-matching-like looks
23:02:26 <kallisti> right.
23:02:30 <kallisti> view patterns are a nice work around.
23:03:07 <kallisti> another problem would be that if you overload range syntax as well, then you pretty much force all sequence-like types to be infinite
23:03:14 <kallisti> or potentially infinite
23:03:27 <kallisti> or produce a nasty runtime error...
23:24:48 <strager> @quote
23:24:49 <lambdabot> DanPascu says: For God's sake, have mercy on us. I'm no mathematician, yet I find 'patch commutation' to sound reliable and trustworthy. 'Patch Flipping' sounds like a drunken monkey doing rollovers
23:30:00 <tmiw> @quote
23:30:00 <lambdabot> winxordie says: HTML is the Hyper Typed Milner Language, an early predecessor to ML
23:32:36 <kallisti> can relations have more than 2 terms?
23:33:17 <kallisti> oh, it would appear so.
23:33:39 <kallisti> so commutativity would be a property of ternary relations
23:33:46 <kallisti> whereas symmetric is for binary relations.
23:48:48 <Twisol> This might be a stupid question, but how agile is Haskell development? I don't mean like the Agile methodology, just in the general sense.
23:50:10 * geekosaur thinks "agile" is largely orthogonal to the language
23:50:57 <Twisol> A counterexample might be good… but too obvious and it's just stupid. :S
23:51:44 <Twisol> none are coming to mind immediately, except VBscript, which is the stupid one.
23:52:59 <Twisol> Well, I'm used to languages like Lua and Ruby and Javascript, where I can typically experiment and rewrite with abandon, and not really have to deal with much ceremony.
23:53:35 <osfameron> Haskell is surprisingly nice, from a dynamic language background
23:53:37 <shachaf> Haskell requires you to sacrifice a lamb every time you want to change a data-type declaration.
23:53:59 <osfameron> it has a REPL too, and you can start off not having to annotate your function types, until it becomes useful to
23:54:25 <c_wraith> haskell actually supports deep rewrites better than Ruby (I don't have experience with huge rewrites in the other two languages you list)
23:55:03 <Twisol> Mm. So far I've been able to modify a file, :l it in ghci, and toy with it easily enough, so it's feeling good at the moment.
23:55:12 <osfameron> c_wraith: because it won't compile until you've done the rewrite correctly?
23:55:19 <Twisol> roughly the same approach I took with Ruby, anyway
23:55:46 <c_wraith> osfameron: give or take.  The compiler tells you what you haven't fixed yet.
23:56:17 <osfameron> c_wraith: yeah, that's nice.  of course it's sometimes nice in a dynamic language to do a partial rewrite, test it, fix the next bit, and test that.
23:56:31 <c_wraith> osfameron: ghc 7.6 supports that!
23:56:41 <osfameron> which I haven't worked out how to do as easily in haskell (comment out unused functions you haven't changed...?)
23:56:45 <osfameron> c_wraith: oh?
23:56:51 <osfameron> how does that work?
23:56:57 <zzo38> I do like GHCi and use it a lot
23:57:17 <c_wraith> there's a flag to defer type errors - the code compiles, but it replaces any expression with a type error with a call to error with the description of the type error
23:57:45 <osfameron> c_wraith: that sounds very sensible!
23:57:54 <c_wraith> it also reports it as a warning
23:58:00 <osfameron> (as long as you don't get in the habit of using that all the time ;-)
23:58:01 <Twisol> Ooh, nice.
23:58:34 <c_wraith> there was some mention of hackage rejecting any package that used it :)
