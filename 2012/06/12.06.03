00:10:33 <bmktuwien> sudokode, do you also familiar with urxvt scrolling problem? unless the mouse-pointer is inside the window, i can't scroll in urxvt using keyboard's pageUp and pageDown
00:10:45 <bmktuwien> upps srry
00:10:56 <bmktuwien> wrong window... noob :)
00:11:27 <mdmkolbe> Probably no one awake to handle this, but my upload to hackage seems to have hung.  I'm not sure whether to retry or wait for the upload to complete.
00:12:26 <unnali> p
00:12:28 <unnali> oops.
00:16:38 * hackagebot TYB 0.2.0 - Template Your Boilerplate - a Template Haskell version of SYB  http://hackage.haskell.org/package/TYB-0.2.0 (MichaelAdams)
00:17:00 <mdmkolbe> Ah, there it went through
00:21:54 <Lemmih> @tell geekosaur Send patches.
00:21:54 <lambdabot> Consider it noted.
00:22:01 <Lemmih> @messages
00:22:02 <lambdabot> applicative said 1h 57m 54s ago: sorry to trouble you; it seems there is something wrong with the configure script for SDL-image, geekosaur identifies it 01:09 and following June 3.
00:22:02 <lambdabot> geekosaur said 1h 49m 44s ago: quick summary: -lSDL_image is added to compile command even before the compiler has been tested, so its absence leads to "C compiler cannot create executables". it
00:22:02 <lambdabot> also would be better to use pkg-config, and Cabal's knowledge of same, to test for the dev packages being installed even before then
00:23:35 <geekosaur> I.... might, but I was ony the one who diagnosed it, not who ran headlong into it.  didn't even have SDL installed before that and might not leave it installed, at least int he VM --- although I may end up revisiting it when I try to update the macports haskell platform and dependents
00:23:35 <lambdabot> geekosaur: You have 1 new message. '/msg lambdabot @messages' to read it.
00:26:39 * hackagebot TYB 0.2.1 - Template Your Boilerplate - a Template Haskell version of SYB  http://hackage.haskell.org/package/TYB-0.2.1 (MichaelAdams)
01:41:09 <alex-hu> I wonder, how could one use fftw with repa arrays?
01:42:23 <pooya72> chapter 5 in real world haskell is crazy
01:48:18 <mcstar> alex-hu: why repa specifically?
02:03:27 <rekado> Hi
02:03:57 <rekado> I'm having troubles understanding the run...T functions of monad transformers
02:04:23 <rekado> I have a monad transformer stack, wrapped in a newtype:
02:05:16 <rekado> in my main I need to peel the transformers off to get to the base monad IO.
02:06:26 <rekado> after many attempts to get the execMyMonad function to work I'm not even sure my newtype looks right.
02:07:00 <rekado> I'm basically just wrapping ErrorT, StateT, and ReaderT around IO.
02:07:22 <rekado> here's the type
02:07:25 <rekado> newtype Conn a = Conn (ReaderT ConnConf (StateT ConnState (ErrorT ConnError IO)) a)
02:07:37 <rekado> does this order make any sense?
02:09:01 <rekado> how do I unwrap this?
02:10:24 <rekado> or do I have this the wrong way?
02:11:17 <snhmib> rekado: from inside out... (runerrort $ runstateT ... $ runReaderT .. $ connMonadActionsGoHere)... i think :P
02:12:07 <fmap> rekado: newtype Conn a = Conn { runConnT ‚à∑ ReaderT ConnConf (StateT ConnState (ErrorT ConnError IO)) a }
02:12:22 <snhmib> o_O
02:13:04 <snhmib> what does "runConnT ? .." do?
02:13:05 <rekado> fmap: I'm looking for a function that allows me to pass ConnConf and ConnStaet
02:13:48 <rekado> execConn :: ConnConf -> ConnState -> Conn a -> IO a
02:14:22 <fmap> rekado: then runErrorT . evalState . runReaderT . runConnT to get inside
02:14:38 <fmap> evalStateT*
02:15:10 <rekado> fmap, this looks very familiar. I think I just left off runConnT.
02:15:16 <rekado> I'll try that.
02:15:32 <rekado> Still, I'm no longer sure that this stack does what I want it to do.
02:15:47 <rekado> It should model a connection over a socket.
02:15:50 <fmap> snhmib: unwraps newtype
02:17:40 <rekado> the Reader wrapper contains read-only configs, State is for mutable state, Error is for handling invalid inputs.
02:18:36 <rekado> fmap: I suppose the "?" should really be "::"?
02:19:12 <fmap> rekado: oh well that was unicode symbol for ::
02:19:26 <snhmib> heh ok :)
02:19:42 <fmap> rekado: your stack looks good for what you want
02:22:05 <rekado> fmap: thank you. That is reassuring.
02:22:11 <rekado> I think I got it now.
02:22:25 <rekado> Should have used that newtype unwrapper thingy.
02:54:12 <rekado> I'm afraid I still don't get
02:54:14 <rekado> it
02:57:01 <rekado> hmpf, misread the type signature. It's all fine.
02:59:34 <roconnor_> I like nice code:
02:59:37 <roconnor_> traversableLens :: (Traversable f) => MultiLens (f a) a
02:59:38 <roconnor_> traversableLens = MLens $ traverse (runMLens id)
03:15:16 <roconnor_> I'm starting to understand why Conor uses backwards lists so much
03:15:58 <roconnor_> f x y z = (((f x) y) z) meaning the z is the outer most accessible expression.
03:16:35 <ani_> quit
03:16:56 <roconnor_> Though honestly I think it is the function application that is backwards, not lists.
03:17:39 <sipa> all becuase of those mathematicians that defined the . operator as "after" instead of "before"
03:18:08 <Saizan> roconnor_: typing context are typically backwards
03:23:53 <dzhus> is ¬´Simplifier ticks exhausted.¬ª message from GHC a reason to worry?
03:27:12 <c_wraith> well, in the sense that it means it could have optimized the code further and didn't...  sort of.
03:27:45 <bitonic> c_wraith: yeah but it panics when it happens
03:28:11 <bitonic> dzhus: so I guess the solution is to increase the ticks, see http://hackage.haskell.org/trac/ghc/ticket/5539
03:28:20 <c_wraith> I thought that was fixed before 7.4 was released
03:29:03 <bitonic> oh, ok. so it just stops optimizing and rolls back?
03:29:15 <c_wraith> doesn't even roll back.  Just stops optimizing
03:29:37 <c_wraith> the simplifier is an incremental optimization
03:30:07 <bitonic> well if it's in the middle of optimizing something, or can it just occur between two steps?
03:30:39 <c_wraith> I'm not certain, but I believe the latter
03:31:21 <c_wraith> but yeah, in any case, it will continue with correct code that isn't as optimized as it could be if you let the simplifier run longer
03:32:29 <c_wraith> I'm pretty sure simplifier ticks were added to catch bugs in the simplifier that led to it running forever, especially with the HOOPL optimization stuff being added.
03:33:00 <c_wraith> And they were left in because it's not a bad idea to put an upper bound on things that can run a very long time.
03:33:27 <c_wraith> But the GHC devs were surprised there are packages that the simplifier *does* run that long on, successfully.
03:34:03 <bitonic> I wonder if people have similar problems with the inference recursion depth
03:38:25 <burbul> @djinn (b -> m b) -> (a,b) -> m (a,b)
03:38:25 <lambdabot> -- f cannot be realized.
03:38:37 <burbul> @djinn Monad m => (b -> m b) -> (a,b) -> m (a,b)
03:38:37 <lambdabot> -- f cannot be realized.
03:39:00 <c_wraith> djinn doesn't really know about Monad
03:39:10 <c_wraith> despite claiming to
03:39:39 <burbul> ah
03:40:25 <c_wraith> :t let f g (a, b) = liftM ((,) a) $ g b
03:40:26 <lambdabot> <no location info>:
03:40:26 <lambdabot>     not an expression: `let f g (a, b) = liftM ((,) a) $ g b'
03:40:28 <c_wraith> :t let f g (a, b) = liftM ((,) a) $ g b in f
03:40:29 <lambdabot> forall t (m :: * -> *) a1 t1. (Monad m) => (t -> m a1) -> (t1, t) -> m (t1, a1)
03:40:42 <c_wraith> heh.  slight accidental generalization
03:41:11 <c_wraith> but that generalization actually constrains its behavior quite a bit
03:41:50 <burbul> I came up with
03:41:51 <burbul> x f (n, r) = do {p <- f r; return (n, p)}
03:42:03 <c_wraith> that's the exact same thing
03:42:11 <burbul> oh
03:42:33 <c_wraith> @src liftM
03:42:33 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
03:42:58 <burbul> I thought I was doing something with (? (,)) rather than ((,) a)
03:43:04 <burbul> @pl do {p <- f r; return (n, p)}
03:43:04 <lambdabot> (line 1, column 4):
03:43:05 <lambdabot> unexpected "{"
03:43:05 <lambdabot> expecting variable, "(", operator or end of input
03:43:09 <burbul> @pl @undop do {p <- f r; return (n, p)}
03:43:09 <lambdabot> (line 1, column 1):
03:43:09 <lambdabot> unexpected "@"
03:43:10 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
03:43:13 <burbul> @pl @undo do {p <- f r; return (n, p)}
03:43:13 <lambdabot> (line 1, column 1):
03:43:13 <lambdabot> unexpected "@"
03:43:13 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
03:43:18 <burbul> @undo do {p <- f r; return (n, p)}
03:43:18 <lambdabot> f r >>= \ p -> return (n, p)
03:43:31 <c_wraith> you need @@ or @. to compose the plugins
03:43:39 <burbul> ah - thanks
03:43:59 <burbul> Anyway, I think it's fine for now. Thanks!
03:46:12 <luca> (This is Parsec, but shouldn't be specific to it).  There is function 'many' which applies a parser 0 or more times greedily returning list of results. I want to create a 'many_3' which applies 3 parsers 0 or more times in any order, returning 3 seperate lists. I can write this, but wondering if someone can see some trick to do it concisely
03:47:30 <burbul> fold them with <|> and then use many?
03:47:44 <c_wraith> that only works if all 3 have the same type
03:47:45 <burbul> (Being careful about whether or not you want to wrap them in 'try' before using <|>)
03:47:47 <luca> that would give me one list with all results; i want 3 seperate lists for output of each parser
03:47:47 <burbul> ah
03:48:07 <burbul> But if they don't have the same type, what's the return type of the final thing?
03:48:15 <c_wraith> 3 different lists
03:48:17 <luca> ([a],[b],[c])
03:48:18 <burbul> i see
03:48:36 <burbul> Sorry, I wasn't reading carefully enough
03:48:38 <c_wraith> I'm not seeing any clever idea for this.
03:49:00 <c_wraith> if it was 2, I'd try to do something with partitionEithers
03:49:15 <c_wraith> but with 3?  Nothing jumps to mind
03:49:16 <luca> i've never used monad within a monad, could we use state to start with ([],[],[]) and at each parser success accumulate to one of the lists?
03:50:14 <c_wraith> you certainly can do that, yes.
03:50:26 <c_wraith> though be careful about accidentally building the lists backwards
03:50:43 <luca> in this instance it wouldn't actually matter
03:52:24 <adamt> God i love that people actually still think about what they're going to write, and not just hammer the head into the keyboard until it compiles.
03:53:03 <burbul> I'm not sure whether it's cleaner, but you could layer three WriterTs
03:53:39 <burbul> Instead of the state
04:20:08 <tsousa> i want to make a script to check my email which modules do i need to use?
04:23:42 * roconnor_ ponders if twanvl lenses would be suitable for some sort of lens-fusion library.
04:24:13 <twanvl> what would lens-fusion do?
04:24:31 <roconnor_> whatever list-fusion does except for lenses?
04:25:27 <twanvl> get rid of intermediary lenses?
04:25:40 <roconnor_> yes
04:27:06 <twanvl> but what is an intermediary lens? For lists if you have f (g x), then (g x) is an intermediary list. For lenses you would f and g to be functions from lenses to lenses. Does that ever happen in practice?
04:27:43 <roconnor_> hmm I see what you are saying
04:28:26 <roconnor_> heh, I most mostly basing my speculation on the fact that list-fusion relies on an isomorphic type of rank-2.
04:28:34 <hpc> it does happen
04:28:41 <hpc> one such function from lenses to lenses is (.)
04:32:48 <twanvl> but it's like saying you want function-fusion. The compiler is already pretty good at that, in the form of inlining
04:33:34 <twanvl> the difference is, I think, that one list can have many cons cells, so it is worthwhile to eliminate those
04:36:21 <roconnor_> twanvl: hmm ... perhaps I should point out I'm thinking at the moment of multi-lens list fusion, which also has "cons" cells
04:36:25 <roconnor_> er
04:36:28 <roconnor_> multi-lens-fusion
04:36:34 <roconnor_> (multi-lens)-fusion
04:42:36 <hayashi> @pl \f g a b -> (f a) . (g b)
04:42:36 <lambdabot> flip . (((.) . (.)) .)
04:44:35 <hayashi> ok, that's quite nasty, how about
04:44:40 <hayashi> @pl \a b -> (f a) . (g b)
04:44:40 <lambdabot> (. g) . (.) . f
04:45:30 <hayashi> actually, 'the hell am I doing, one of these is a point anyway
04:45:42 <hayashi> ProTip: do not haskell minutes after waking up
04:45:52 <hpc> @@pl src on
04:46:00 <hpc> @@ pl src on
04:46:00 <lambdabot>  pl src on
04:46:05 <hpc> @@ @pl @src on
04:46:05 <lambdabot>  (line 1, column 1):
04:46:05 <lambdabot> unexpected end of input
04:46:05 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
04:46:19 <hpc> pah
05:03:42 <hughfdjackson> is filter and different from takeWhile?
05:03:55 <hughfdjackson> they seem to be performing the same role..
05:04:25 <hughfdjackson> :# oh, mea culpa
05:04:37 <hughfdjackson> takeWhile seems to only return the first result for which the predicate is true
05:05:16 <zomg> I think takeWhile will work with infinite lists vs filter will never finish
05:05:19 <hughfdjackson> *ahem* even that much is not true
05:05:42 <hughfdjackson> apparently takeWhile will stop taking if the predicate returns false, and takes until then
05:05:47 <zomg> Yeah was just about to say
05:05:56 <zomg> filter will go through the entire list
05:06:13 <hughfdjackson> :D it's all starting to make a vague sort of sense
05:06:29 <zomg> Hehe
05:11:47 <tsousa> i want to make a script to check my email in Haskell which module do i need to learn? does anybody have a script for me to see how you did it?
05:17:26 <zomg> tsousa: probably either a module for reading IMAP or POP3 mailboxes
05:17:28 <stat_vi> lisp
05:18:29 <tsousa> zomg, is it easy to learn? i dont know any about monads and stuff like that i have read LYAH until the functors chapter
05:19:28 <zomg> I have no idea tbh :)
05:19:54 <zomg> I can't imagine it being particularily hard to do but it could be challenging for a beginner I guess
05:25:57 <pooya72> tsousa: when you figure it out let me know. :) I'm learning too
05:47:23 * hackagebot yesod-auth-fb 1.0.2 - Authentication backend for Yesod using Facebook.  http://hackage.haskell.org/package/yesod-auth-fb-1.0.2 (FelipeLessa)
05:56:53 <vosovich> Hey. Could anyone check http://pastebin.com/tD57QY2V and see what I'm doing wrong?
05:56:58 <mauke> The paste tD57QY2V has been copied to http://hpaste.org/69458
05:58:47 <vosovich> thank you. I'll paste to hpaste from now on.
06:00:00 <fmap> vosovich: compress y:xs is (compress y):xs and not (compress (y:xs))
06:01:05 <fmap> and btw it could be helpful to include error you've got to paste next time
06:02:14 <vosovich> fmap: I'll repaste with the error. Just one sec
06:02:56 <fmap> vosovich: you can just annotate existing paste
06:04:34 <fmap> vosovich: anyway, the solution is to use `compress (y:xs)' or `compress $ y:xs'
06:05:08 <hpaste> vosovich annotated ‚Äúcompress‚Äù with ‚Äúcompress (annotation)‚Äù at http://hpaste.org/69458#a69459
06:06:19 <vosovich> fmap: could you explain what the quotes do?
06:07:27 <fmap> vosovich: you don't need quotes, i've used them to separate code from text
06:08:20 <vosovich> oh, right. So compress takes precedence over :?
06:09:05 <vosovich> fmap: Yup, that did it. Thank you.
06:09:43 <fmap> yes, function application takes precedence over any infix operator
06:12:13 <anicake> :quit
06:27:30 * hackagebot shelly 0.9.5.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.9.5.1 (GregWeber)
06:32:29 <nand`> https://upload.wikimedia.org/wikibooks/en/8/88/List-graph.png <- two questions: 1. why does ():[] appear twice? 2. why is ():[] below ():_|_? I thought ‚Äúbeing below‚Äù represented ‚Äúbeing less defined than‚Äù
06:33:34 <danr> nand`: there's a typo, the ():[] to the left should be a ():_|_
06:34:14 <nand`> okay. and the ():_|_ directly above it? Should that be ():[] then; ie. the same element as the one marked in red to the right?
06:34:30 <danr> no
06:34:37 <danr> but above ():_|_ we have ():[]
06:34:50 <danr> and ():_|_:_|_
06:35:15 <jghickman> I'm trying to install GHC on OS X (10.7.3) with Xcode 4.3.2, but the installer says "developer tools missing, please install Xcode first."  Does anybody know why the installer can't find Xcode?
06:35:24 <danr> oh yes, you're right, ignore the little "no" :)
06:35:46 <nand`> danr: okay, thanks
06:35:47 <danr> yes, it's a DAG rather than a tree
06:35:51 <mzero> jghickman: You need the command line tools
06:36:05 <jghickman> Command-line Xcode tools?
06:36:10 <mzero> Go to Xcode prefs, download pane
06:36:13 <nand`> danr: DAG?
06:36:20 <danr> nand`: directed acyclic graph
06:36:20 <jghickman> Ah, I'll look.
06:36:28 <mzero> You can select ot there from the components tab
06:36:41 <danr> nand`: with _|_ as root
06:37:07 <mzero> Also - HP 2012.2.0.0 is ready if you want it
06:37:22 <mzero> For Mac, that is
06:37:25 <danr> mzero: really, since when?
06:37:26 <unnali> mzero: woo!!
06:37:27 <danr> mzero: link?
06:37:28 <jghickman> Sweet, download in progress.
06:37:51 <k-zed> mzero: when does it become the official/stable release?
06:38:01 <jghickman> Um, what's HP 2012.2.2.0.0 ??
06:38:01 <k-zed> aha, "    Expected week of June 4th, 2012 "
06:38:11 <k-zed> haskell platform (i guess)
06:38:24 <mzero> I'm just waiting for the web site to go live, but the installers are staged and ready
06:38:25 <jghickman> Where do you find that?
06:39:01 <mzero> Hold on ...
06:40:04 <mzero> http://lambda.haskell.org/platform/download/2012.2.0.0/
06:40:38 <danr> mzero: cool. are .pkg files mac version?
06:40:42 <jghickman> Thanks!
06:40:59 <Axman6> mzero: what GHC does the next release have?
06:41:01 <arnsholt> Is there a built-in name for `\(a, b) -> (b, a)'?
06:41:02 <mzero> Yes 32bit and 64bit
06:41:02 <k-zed> mzero: cool
06:41:11 <mzero> Ghc 7.4.1
06:41:17 <k-zed> @hoogle (a, b) -> (b, a)
06:41:17 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
06:41:17 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
06:41:18 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
06:41:19 <Axman6> :D
06:41:28 <danr> @type uncurry (flip (,))
06:41:29 <lambdabot> forall b a. (a, b) -> (b, a)
06:41:41 <arnsholt> Spiffy. Cheers!
06:42:29 <mroman> @type uncurry . uncurry
06:42:30 <lambdabot> forall b c a b1. (a -> b1 -> b -> c) -> ((a, b1), b) -> c
06:45:16 <mzero> Btwwith os x 10.7 and HP 2012.2.0.0 -- you no longer need Xcode, just the "Command Line Tools for Xcode" which can be downloaded from Apple separately and installed without Xcode (despite the name!)
06:46:23 <mzero> Also if your getting Mac HP chose 32bit unless you have huge data needs
06:47:34 <kmels> hello, why should `LargeKey` not be in scope after I import Data.LargeWord? I'm doing > ghci, >  import Data.LargeWord, > :i LargeKey
06:48:43 <xraycat> import in ghci?
06:48:47 <luite> fergusnoble: yeah i am
06:49:04 <kmels> yes
06:49:31 <k-zed> mzero: why is 32bit better than 64 for osx?
06:49:50 <luite> fergusnoble: if you have the non-threaded runtime, you're not supposed to call haskell things from other threads
06:50:10 <xraycat> kmels: to load a module you'd probably do: :m + Data.LargeWord
06:50:16 <mzero> Slightly faster mostly due (we think) to better memory utilization and cache use:
06:50:45 <k-zed> and it doesn't happen for linux 64bit?
06:50:47 <k-zed> or it's the same there?
06:51:13 <luite> fergusnoble: it would've been easier with the threaded runtime, but i had some problems with that and the ghc api on os x, and this library is to be used in an app that also uses the ghc api
06:51:56 <mzero> Basically, on a modern CPU the instruction sets are about as fast- but 64bit pointers and into just take twice the memory bandwidth and cache space
06:52:05 <kmels> xraycat, i see, why import Data.List works though? I get this input with :m Data.LargeWord, Ambiguous module name `Data.LargeWord': it was found in multiple packages: largeword-1.0.1 Crypto-4.2.5
06:52:20 <mzero> Probably true on Linux - I didn't measure it there
06:52:26 <k-zed> OK
06:52:57 <navaati> well on linux now there is the x32 ABI
06:53:22 <mzero> On Mac, though, you have 32bit and 64bit Libs for everything- not usually so on Linux
06:54:09 <mzero> Is x32 the newer ISA but with 32 but ints and pointers? That'd be best of both worlds
06:55:46 <navaati> mzero: yep
06:56:17 <mzero> Now we'd just need GHC to support that architecture....
06:56:39 <navaati> you run it on a 64 bits kernel so that the global address space is still >4GB
06:56:51 <olsner> ghc should be mostly able to do that for 64-bit code, without needing x32 ABI at all
06:57:05 <navaati> (of course the apps are limited to <4GB since their pointers are 32 bits wide
06:57:30 <olsner> i.e. limit the haskell heap to the low 4GB, generate code that loads smaller pointers
06:58:29 <mzero> I think it would just be a matter of getting configure to understand that arch
06:58:51 <hpc> can't GHC figure that out already?
06:58:53 <byorgey> mzero: by the way, http://pnyf.inf.elte.hu/fp/Diagrams_en.xml is unrelated to http://projects.haskell.org/diagrams/
06:59:15 <byorgey> it is somewhat confusing.
06:59:19 <mzero> Hpc: no , not really
06:59:39 <mzero> byorgey: K - so what is that page using???
07:00:06 <xraycat> kmels: http://stackoverflow.com/questions/3918774/specifying-package-name-for-module-related-commands-in-ghci
07:00:17 <mzero> ( have you been waiting all night to tell me that? :-)
07:01:26 <byorgey> mzero: hehe, no, I have a highlight set on 'diagrams' and only just saw what you said now
07:01:44 <byorgey> mzero: it uses http://hackage.haskell.org/package/dia-base and http://hackage.haskell.org/package/dia-functions
07:03:50 <kaf3ii> removeEach :: [a] -> [(a,[a])]
07:03:50 <kaf3ii> removeEach (x:xs) = (x,xs) : map (second (x:)) (removeEach xs)
07:03:50 <kaf3ii> is there a way of makeing this function list-monadishly state-monadishly composable
07:05:17 <kaf3ii> or is there already such a type defined somewhere ?
07:08:13 <byorgey> "makeing this function list-monadishly state-monadishly composable" -- not sure what you mean
07:08:21 <mzero> kaf3ii: I'm not sure what you mean by that - removeEach returns a list , what more do you want?
07:08:27 <byorgey> that's how I would implement it.  though it needs a case for the empty list too.
07:10:07 <kaf3ii> byorgey: thats what im realizing now also :/
07:11:07 <kaf3ii> i think a have an idea of what i should do, may have asked prematurely
07:12:24 <parcs`> do you mean writing it with the type StateT [a] [] a ?
07:13:01 <kaf3ii> parcs`: that may be it
07:15:10 <kaf3ii> the monad should be run with a list of values, and in the monad you can get values with do { a <- request; ... }
07:16:02 <nand`> :t let removeEach [] = []; removeEach (x:xs) = (x,xs) : map (second (x:)) (removeEach xs) in StateT removeEach
07:16:03 <lambdabot> forall a. StateT [a] [] a
07:16:08 <kaf3ii> request then gives you  "all" values from the inputlist and  removes those values from the list
07:16:32 <nand`> no need to make it more complicated than it is :P
07:18:34 <mzero> Do you mean a<-request would get each pair in turn?
07:19:05 <kaf3ii> mzero: yes
07:19:21 <mzero> Done! It is already a list
07:20:13 <mzero> do { (a,as) <- removeEach foo; ... }
07:20:15 <luca> I'm having an issue with Parsec buildExpressionParser in that things like &&! will be treat as a single operator, rather than 2 operators etc
07:20:51 <kaf3ii> mzero: or runBla [1,2,3] { a <- request; b <- request; return (a,b) }   ==> [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
07:22:17 <kaf3ii> mzero: (a,as) <- removeEach :D
07:23:26 <mzero> do { (a,as) <- removeEach [1,2,3]; (b,bs) <- removeEach as; return (a,b); }
07:24:13 <parcs`> > (`runStateT` [1,2,3]) (let request = let removeEach [] = []; removeEach (x:xs) = (x,xs) : map (second (x:)) (removeEach xs) in StateT removeEach in do liftM2 (,) request request)
07:24:14 <lambdabot>   [((1,2),[3]),((1,3),[2]),((2,1),[3]),((2,3),[1]),((3,1),[2]),((3,2),[1])]
07:24:25 <parcs`> > (`evalStateT` [1,2,3]) (let request = let removeEach [] = []; removeEach (x:xs) = (x,xs) : map (second (x:)) (removeEach xs) in StateT removeEach in do liftM2 (,) request request)
07:24:26 <lambdabot>   [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
07:24:38 <kaf3ii> nice thanks :)
07:27:41 <pooya72> does haskell have something like C's printf ("hello %s", var); ? where it will convert the type to string?
07:27:53 <dschoepe> pooya72: There's Text.Printf
07:28:07 <pooya72> dschoepe: thanks!
07:28:09 <arnsholt> For a type Foo a b, is there a syntax to extract the a or b in an expression?
07:28:22 <Clint> pattern matching
07:28:34 <dschoepe> pooya72: But that function is not type-safe and it's a quite tricky to do printf-like things in a type-safe way.
07:28:39 <parcs`> check out the printf-mauke package it has a type-safe printf
07:29:04 <dschoepe> Here's a mind-boggling way to implement it: http://okmij.org/ftp/typed-formatting/index.html
07:29:40 <parcs`> arnsholt: data Proxy a = Proxy; extract :: Foo a b -> Proxy a; extract _ = Proxy
07:30:30 <arnsholt> parcs`: Right. Easier to just make an intermediate named var then
07:31:17 <nand`> it seems to me that the most obvious way to implement printf is as :: String -> [String] -> String
07:31:39 <pooya72> thanks guys
07:31:47 <mzero> > let removeEach [] = []; removeEach (a:as) = (a,as):map (second(a:)) (removeEach as) in do { (a,as) <- removeEach [1,2,3]; b <- as; return (a,b) }
07:31:48 <lambdabot>   [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
07:32:04 <mzero> no need for the second "request" to be a call to removeEach
07:32:57 <mzero> (finally had to switch from IRC on my iPhone to a real computer - typeing the last expression almost killed me!)
07:33:13 <parcs`> mzero: yes but the other way is cooler :P
07:33:34 <pooya72> what's the haskell idiomatic way to get a int into  string? for example "Hello my id is" ++ (show id)? but writing ++ gets tedious...
07:33:59 <Clint> you're missing a space
07:34:03 <Axman6> there's also printf, but some people don't like that
07:34:22 <nand`> there's also concat ["Hello my id is ", show id, "!"]
07:35:37 <Blkt> good day everyone
07:40:58 <hughfdjackson> i see you said that in two rooms
07:41:14 <hughfdjackson> can we assume that was a *stifles laughter* a blanket statement?
07:41:20 <hughfdjackson> *ahem*
07:41:54 * Axman6 senses there was supposed to be a joke there...
07:42:25 <hughfdjackson> :p if I had a kid, that'd be expected behaviour
07:42:34 <hughfdjackson> :/ pre-fatherhood dad jokes are probably not on
07:42:48 <Twey> Heheh
07:45:21 <pooya72> Blkt: G'day!
07:56:07 <kaf3ii> mzero: ok, is now trying to make the function [1,2,3,..] ==> all possible orderings of [1,2,3,...]
07:56:35 <Axman6> permutations?
07:56:43 <Axman6> > permutations [1,2,3,4]
07:56:44 <lambdabot>   [[1,2,3,4],[2,1,3,4],[3,2,1,4],[2,3,1,4],[3,1,2,4],[1,3,2,4],[4,3,2,1],[3,4...
07:56:51 <kaf3ii> that it..
07:57:06 <kaf3ii> already defined.. i see..
07:57:18 <Axman6> but frun to figure out also =)
08:00:20 <kaf3ii> soo while im at it, is there a function [1,2] -> [[],[1],[2],[1,2],[2,1]]
08:01:12 <hpc> > permutations [1,2]
08:01:13 <lambdabot>   [[1,2],[2,1]]
08:01:15 <hpc> hmm
08:01:30 <kaf3ii> permutations . tails ?
08:01:38 <hpc> :t permutations . filterM (const [True,False])
08:01:39 <lambdabot> forall a. [a] -> [[[a]]]
08:01:45 <hpc> :t permutations =<< filterM (const [True,False])
08:01:46 <lambdabot>     Couldn't match expected type `[[a]]'
08:01:46 <lambdabot>            against inferred type `[a1] -> [[a1]]'
08:01:46 <lambdabot>     In the second argument of `(=<<)', namely
08:01:54 <hpc> :t permutations <=< filterM (const [True,False])
08:01:55 <lambdabot> forall a. [a] -> [[a]]
08:02:05 <hpc> > permutations <=< filterM (const [True,False]) $ [1,2]
08:02:06 <lambdabot>   [[1,2],[2,1],[1],[2],[]]
08:02:17 <kaf3ii> :D nice
08:02:24 <hpc> > permutations <=< filterM (const [False, True]) $ [1,2] -- to get it in the right order
08:02:25 <lambdabot>   [[],[2],[1],[1,2],[2,1]]
08:02:55 <hpc> > permutations <=< filterM (const [True,False]) $ [1..] -- this should work, i think
08:02:57 <lambdabot>   *Exception: stack overflow
08:03:04 <hpc> oh well
08:04:02 <hpc> filterM (const [True, False]) can be read as "all combinations of (original list with elements 1, 2, 3, 4, 5, ... removed)"
08:04:25 <hpc> and then you get the permutations of each sublist
08:04:39 <mharvan> I'm learning haskell and I applied hlint.. I have something like (fst x * fst y, snd x * snd y) and it's suggesting to us Control.Arrow.*** instead, why is it better?
08:05:21 <Botje> :t (*) *** (*)
08:05:22 <lambdabot> forall b b'. (Num b, Num b') => (b, b') -> (b -> b, b' -> b')
08:05:23 <kaf3ii> hpc: thanks
08:05:35 <Botje> hmm, maybe not.
08:05:44 <hpc> mharvan: it lets you write operations on tuples, instead of operations on tuple elements
08:06:12 <hpc> @let m1 = (*) *** (*) -- only to save typing
08:06:13 <lambdabot>  Defined.
08:06:21 <k0ral> @hoogle [a] -> [b] -> [(a,b)]
08:06:21 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
08:06:21 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
08:06:21 <lambdabot> Test.QuickCheck.Modifiers shrinkState :: ShrinkState s a => a -> s -> [(a, s)]
08:06:28 <k0ral> no cartesian product ?
08:06:58 <hpc> :t \x y -> m1 *** x *** ($ y)
08:06:59 <lambdabot> forall b b' b1 c a b2. (Num b, Num b') => (b1 -> c) -> a -> ((b, b'), (b1, a -> b2)) -> ((b -> b, b' -> b'), (c, b2))
08:07:06 <hpc> er
08:07:09 <hpc> :t \x y -> m1 *** x
08:07:10 <lambdabot> forall t b b' b'1 c'. (Num b, Num b') => (b'1 -> c') -> t -> ((b, b'), b'1) -> ((b -> b, b' -> b'), c')
08:07:28 <hpc> :t \x y -> m1 x
08:07:29 <lambdabot> forall t b b'. (Num b, Num b') => (b, b') -> t -> (b -> b, b' -> b')
08:08:17 <hpc> i think there's more you can do with that, but it's too early in the morning here...
08:09:30 <mharvan> I guess I'll have to learn a bit more :)
08:10:40 <parcs`> @localtime hpc
08:10:42 <lambdabot> Local time for hpc is Sun Jun  3 11:10:20 2012
08:10:57 <hpc> yes, 11 is early
08:11:36 <parcs`> :)
08:12:00 <k0ral> @localtime k0ral
08:12:02 <lambdabot> Local time for k0ral is Sun Jun  3 17:11:41 2012
08:12:14 <k0ral> impressive
08:12:41 <byorgey> it computes it by testing how long messages take to reach you, and dividing by the speed of light
08:13:32 <hpc> the test message is a CTCP TIME command
08:13:55 <k0ral> I don't buy it
08:14:42 <hpc> there's a bug where lambdabot hasn't been properly calibrated to this universe's speed of light
08:14:48 <hpc> so sometimes it can be off by a few seconds
08:15:31 <k0ral> maybe it should simply round to the nearest hour instead of taking care of seconds xD
08:16:04 <hpc> or just change the speed of light
08:16:12 <saep> yeah, it's too fast
08:16:51 <k0ral> hmmm, I wouldn't darep laying with light speed, too many implications
08:16:53 <hpc> https://www.youtube.com/watch?v=2s_Fk8Ys8cI
08:17:34 <kuribas> I have been thinking on hacking on xmonad to create a windowmanager for a tablet pc.  Can I compile to arm?
08:18:01 <daniel_-> hi, im doing the learnyouahaskell.com tutorial (currently on random numbers) and it seems like it does not work correctly for me and i wonder why. it doesn't putStr "Which number in the range from 1 to 10 am I thinking of? " until i actually have supplied the numberString <- getLine which comes after
08:18:49 <hpc> daniel_-: buffering
08:19:13 <hpc> it doesn't actually print it right away, but waits until either the end of a line, or 4096 characters
08:19:19 <hpc> i forget which it defaults to
08:19:23 <bas_> if I want to store Haskell data in a file and later read it back in again, what are my options?
08:19:26 <hpc> hSetBuffering stdin LineBuffering
08:19:30 <hpc> or hFlush stdin
08:19:35 <hpc> er, s/in/out
08:20:30 <daniel_-> thanks :)
08:21:50 <navaati> mm_freak: how do you manage collections of elements in netwire ? (like parallel switch in yampa)
08:21:50 <navaati> the distribute wire transformer does not allow the list to be dynamic (one can't add and remove elements during execution)
08:23:47 <kuribas> How good is ghc support for embedded architectures, like arm?
08:23:54 <saep> kuribas: Xmonad should work on any system that uses X. The debian package is also available on most architectures (http://packages.debian.org/sid/xmonad).
08:25:55 <kuribas> I want to put linux on a tablet pc (the archos 5 internet tablet), but I didn't find a good windowmanager, so I could hack something together from xmonad...
08:26:24 <jonaskoelker> kuribas: AFAIK ghc can compile to (a subset of) C
08:26:51 <kuribas> I can compile on the device, so I wouldn't need a cross compiler...
08:27:06 <jonaskoelker> going down that path would be my first step, though my knowledge pretty much ends there ^_^
08:27:42 <kuribas> I don't know Xmonad, but I know haskell and some X programming.
08:30:12 <navaati> ghc can't really output to C anymore. to do this you need the unregisterised build of ghc, which is packaged version is not, and it's only for devs anyway. however ghc can now output to llvm, which gives it almost instant arm support
08:31:07 <navaati> so answer is : support for arm is pretty good in last versions of ghc
08:31:18 <navaati> and cross-compiling should even be possible
08:32:20 <Philippa> so what does the todo list for arm ghci look like now, anyway?
08:36:23 <Cheery> I'm trying to make a tree editor, which functions similarly to text editors.. and I try think up an approach of how to get it.
08:36:58 <Cheery> thinking about a scheme where you'd edit a list, but that list would encode a tree.
08:37:02 <Cheery> http://www.pasteall.org/pic/show.php?id=32638
08:37:05 <Cheery> like this
08:38:44 <navaati> Cheery: a tree editor, right, but which kind of trees ? rose trees, binary trees ?
08:40:25 <Cheery> navaati: the final application is a programming environment
08:41:02 <Cheery> navaati: so the tree should be probably something like nested lists.
08:41:15 <Cheery> tagged, nested lists.
08:42:20 <mzero> well - I couldn't infer what type of tree was meant by that graphical representation
08:42:28 <navaati> data Tree a = [(a,Tree a)] ?
08:42:28 <mzero> so - perhaps it isn't, er, clear
08:42:47 <navaati> (i don't understand the graphical representation either)
08:43:17 <mzero> newtype Tree a = Tree [(a,Tree a)]
08:43:18 <Cheery> navaati: that looks like ok.
08:44:22 <navaati> well, this representation is perfectly represented by gtk treeview, i think
08:44:23 <Cheery> the image's supposed to represent a list. there's handles and symbols in the list.
08:44:57 <mzero> BTW - if anyone wants an early shot at Haskell Platform 2012.2.0.0 -- I've put a copy of the website (it hasn't gone live yet) on my server: http://www.ozonehouse.com/mark/platform/site/   --- the downloads it points to are the live, official ones
08:45:03 <Cheery> those handles should encode a tree. the matching handles are connected by line
08:45:32 <mzero> are the handles like the open/close pair of brackets?
08:45:36 <Cheery> yes
08:45:59 <burbul> Is there a 'safe' equivalent of (!!)? (E.g. returning a Maybe.)
08:46:00 <mzero> is the label _after_ the opening bracket/handle the label of the tree, or the label of the first thing in the tree?
08:46:40 <mzero> @hoogle [a] -> Int -> Maybe a
08:46:41 <lambdabot> Prelude (!!) :: [a] -> Int -> a
08:46:41 <lambdabot> Data.List (!!) :: [a] -> Int -> a
08:46:41 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
08:46:43 <Cheery> label represents a symbol, character, in the tree.
08:46:51 <mzero> guess not!
08:47:01 <burbul> thanks
08:47:10 <mzero> @hoogle Int -> [a] -> Maybe a
08:47:11 <lambdabot> Prelude (!!) :: [a] -> Int -> a
08:47:11 <lambdabot> Data.List (!!) :: [a] -> Int -> a
08:47:11 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
08:47:24 <mzero> there should be!
08:47:36 <companion_cube> pattern match against (drop n)
08:47:41 <navaati> :t \l n -> fmap (!!n) (guard (n<= length l) >> l)
08:47:42 <lambdabot> forall a. [[a]] -> Int -> [a]
08:48:11 <navaati> :t guard
08:48:12 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
08:48:31 <navaati> :t \l n -> fmap (!!n) (l <$ guard (n<= length l))
08:48:32 <lambdabot> forall a (f :: * -> *). (MonadPlus f, Functor f) => [a] -> Int -> f a
08:49:00 <navaati> > (\l n -> fmap (!!n) (l <$ guard (n<= length l))) 2 "abc" :: Maybe Char
08:49:01 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
08:49:01 <lambdabot>         against inferred type ...
08:49:13 <navaati> > (\l n -> fmap (!!n) (l <$ guard (n<= length l))) "abc" 2 :: Maybe Char
08:49:14 <lambdabot>   Just 'c'
08:49:19 <navaati> > (\l n -> fmap (!!n) (l <$ guard (n<= length l))) "abc" 5 :: Maybe Char
08:49:20 <lambdabot>   Nothing
08:49:25 <navaati> yeah !
08:50:00 <Cheery> mzero: all I'd want is an easy, simple way to edit trees that have text in them, such that it's easy to implement
08:50:48 <burbul> I really just want to be able to replace the !! error message with something more informative... maybe I should rol my own op.
08:50:52 * mzero grances at JSON, XML, HTML, S-Expressions, ....
08:51:05 <mm_freak> navaati: yes, see the .Trans subtree
08:51:07 <burbul> using yr scheme, navaati
08:51:09 <mzero> burbul - you should roll your own - it will take two lines of code
08:51:13 <burbul> yup
08:51:13 <mzero> maybe three
08:51:26 <parcs`> burbul: in the 'safe' package there is a function like that
08:51:37 <burbul> thanks!
08:52:00 <parcs`> you can also do 'xs !! n = listToMaybe (drop n xs)'
08:52:50 <Cheery> mzero: yeah.. I were thinking about something like XML when doing the late draft I had.
08:53:04 <navaati> mm_freak: which module ? i examinated every one of them and couldn't find a way
08:53:12 <Cheery> the problem is editor should continuously show the changes to the user.
08:53:23 <Cheery> but if the user breaks the syntax, how could the editor show it properly?
08:53:24 <mzero> I guess what I'm saying is: there are very few examples of tree editing via graphic manipulation --- and there are no lack of trees in applications
08:53:50 <mm_freak> navaati: examples are in the .Trans.Combine module
08:53:57 <mzero> editing text is surprisingly effective for humans
08:54:08 <mzero> but I like the idea of showing the tree
08:54:14 <mzero> continuously as you edit
08:54:27 <mm_freak> navaati: i had a more generic combinator in an earlier version of netwire, but removed it, because the more general, the less convenient‚Ä¶  the proper way is to write application-specific wire transformers
08:54:30 <mzero> but as for which graphical representation, that will really depend on your problem domain
08:54:43 <Cheery> oh that I have solved. :)
08:54:49 <Cheery> (I guess)
08:55:14 <navaati> mm_freak: i absolutely don't understand what does this context stuff does‚Ä¶
08:55:15 <mzero> well, though neither of us knew your problem domain, at least two of us couldn't make heads or tails of that diagram
08:55:51 <navaati> and also : wtf, managing collections is NOT an application specific feature oO
08:56:00 <mzero> but in the end - if you build the structure so that you can edit text, but display representation as you type - then you can fiddle with graphic representations quickly (and with real users) and find the best way
08:57:11 <Siod> why does yesod use .cg files
08:57:55 <Cheery> mzero: yeah.
08:59:11 <Cheery> I thought about having sequence of symbols, which encode the tree structure.. and implement revised text editing commands, which recognise that structure.
08:59:56 <Cheery> but those rules should be simple.. as I want it'd be easy to implement similar to how text editors have been easy to come up with.
09:01:45 <yitz> Siod: yesod uses .cg for "codegen". it's only part of the internals of the yesod executable itself.
09:02:10 <Cheery> a simple text editor is just a cursor into sequence of text.. and you can remove or add from before/after the cursor
09:02:16 <Siod> yitz: i don't understand your second sentence
09:02:28 <yitz> Siod: (i actually don't exactly know what that means. i'm no yesod expert. i just asked snoyberg, and that's what he said.)
09:02:46 <Siod> ah
09:03:05 <Cheery> mzero: I'd like to keep it pretty much like that, but have the additional rules for how the encoded tree behaves.
09:03:18 <yitz> Siod: i think he's trying to say don't worry about it. but i'll ask again if you want. (i'm in the middle of a conversation with him about something totally unrelated.)
09:03:29 <shintaku> probably a common question in here, but can someone recommend a haskell book?  I'm familiar with scala, for what that's worth.
09:04:03 <Siod> real world haskell
09:04:13 <shintaku> thanks
09:04:40 <shintaku> do any of the books cover applicative functors, arrows, etc?
09:04:57 <parcs`> LYAH covers lots of stuff but not arrows
09:04:58 <navaati> Cheery: hum‚Ä¶ you mean that a text editor is basically a Zipper on String ? so what you want is an interface for a Zipper on Tree <Char ? String ? Anyway, something you can edit with a keyboard>, right ?
09:05:00 <Siod> learn you a haskell covers applicative functors decently
09:05:09 <shintaku> cool.  thanks
09:05:12 <Siod> wikibooks has a haskell book that covers arrows
09:05:26 <Siod> and applicative functors, and just about everything
09:05:38 <Cheery> navaati: hum.. hey that's cool thinking!
09:05:39 <shintaku> so, i should probably just get real world haskell and then read the wiki
09:05:42 <Siod> http://en.wikibooks.org/wiki/Haskell
09:05:51 <Siod> shintaku: that's what i did
09:05:58 <Cheery> navaati: zipper, indeed
09:06:03 <shintaku> cool, thanks
09:06:16 <Cheery> yeah
09:06:30 <Cheery> there were zipper on trees and strings I remember
09:06:56 <Siod> the advanced topics on haskell's wikibook still need work
09:07:08 <monochrom> @seen ezyang
09:07:08 <lambdabot> Unknown command, try @list
09:07:12 <Siod> maybe an expert here could donate some time
09:07:13 <navaati> Cheery: i don't know zippers very well. But i think that by studying their basic operations you could infer the operations in your editor
09:07:17 <monochrom> preflex: seen ezyang
09:07:18 <preflex>  ezyang was last seen on #haskell 3 days, 37 minutes and 13 seconds ago, saying: Certainly in the Haskell ecosystem, the latter is easier, since most mutable data structures are not polymorphic in the reference type.
09:07:36 <Cheery> navaati: I could try that direction anyway.
09:08:02 <Cheery> navaati: there's another aspect on this, which is the collaborative editors.
09:08:16 <Cheery> they need to treat changes as changesets
09:08:34 <navaati> also, maybe you could talk to the Yi guys, they may have thought about this editor as a zipper approach
09:08:35 <Cheery> but I guess they can operate very well on splices and such.
09:09:10 <shintaku> ok, i have an honest question.  haskell looks extremely popular.  and this channel has more people in it than most programming languages.  why are there very few popular websites written in haskell?  there aren't many using scala, but i've heard of a few high traffic sites using scala.  then again, my exposure differs, so, let me know if i'm incorrect.
09:09:36 <mcstar> because of the butterfly effect
09:09:59 <shintaku> going back in time and sitting on a bug can kill my mom?
09:10:05 <mcstar> butterflies are beautiful, so ppl are drawn towards them
09:10:10 <Siod> my guess: scala is basically a facelift for java, and java has the industry's trust
09:10:32 <shintaku> and i didn't really think of the application server aspect
09:10:39 <shintaku> that's a good point, Siod
09:11:38 <Siod> i'm not sure about this, but i think haskell at the scale is still in the early stages, too
09:12:20 <bas_> I think I know the major reason for Haskell not taking off as a web language yet
09:12:30 <Siod> s/at the scale/at that scale
09:12:32 <bas_> you see, I am a frontender
09:12:46 <dcoutts_> bas_: do we not have enough rock stars? :-)
09:12:56 <shintaku> why?
09:12:57 <Eliel> shintaku: also, haskell is actually pretty difficult language to get used to.
09:13:01 <bas_> and most of my colleagues have their brain explode when they read any of it
09:13:26 <bas_> and actually that's the case for my _back-end_ colleagues as well
09:13:38 <bas_> dcoutts_ has it
09:13:50 <Eliel> I think bas_ put it quite well :)
09:14:04 <Siod> is learning haskell really so much harder than scala?
09:14:12 <bas_> rockstars are pretty useful for adoption among web folks
09:14:24 <bas_> but problem is, not many are actually smart
09:14:28 <dcoutts_> Siod: no, it's almost certainly easier than Scala
09:14:36 <Eliel> Siod: not having tried scala, I can't say :)
09:14:49 <bas_> the clichÈ that Haskell is hard and beautiful is actually true
09:14:51 <Siod> dcoutts_: how is that possible?
09:14:52 <parcs`> we need more haskell rockstars, ninjas and gangstas
09:14:59 <Eliel> Siod: but it's different enough that you have to study to be able understand the code. I expect that puts people off.
09:15:11 <dcoutts_> Siod: with Haskell you only have to learn the functional paradigm rather than a mixed functional and imperative paradigm
09:15:28 <bas_> Haskell is for people who like elegance above ease-of-use
09:15:34 <bas_> although once you learn it, nothing is easier
09:15:36 <navaati> yeah, right, haskell is difficult : learning the basis of Yet Another Imperative Language takes from one day to two weeks, and back in the days it took me something like 6 month to understand haskell enough
09:15:39 <Siod> dcoutts_: oh, so assuming you come from an imperative background, then scala is easier?
09:15:48 <dcoutts_> Siod: scala is actually a quite complex language since it mixes both styles, e.g. has both parametric and subtyping polymorphism
09:16:17 <dcoutts_> Siod: then you'll get Scala's imperative bits but that will not help with the FP or the mixed FP/imperative
09:16:24 <Eliel> the difficulty with haskell for most people is, I expect, that they'd have to learn to think functional.
09:16:26 <bas_> but this talk about "why isn't Haskell more popular" makes no sense to me
09:16:39 <Siod> dcoutts_: let me put it this way, which language has the largest set of function programming features and abilities
09:16:52 <Eliel> also, to write haskell code, you really need to understand what you're doing. With imperative languages, you can get by with trial and error.
09:16:54 <Siod> s/function/functional
09:17:10 <Siod> are they roughly equal?
09:17:24 <bas_> as long as Peyton Jones and similarly talented folks are working on Haskell, I don't need or want hords of jQuery ninja's involved
09:17:34 <parcs`> haskell is much more that a functional programming language. it's a pure, lazy functional programming language
09:17:43 <Siod> Eliel: the more i learn of haskell, the more it looks like writing in a restricted imperative style that enforced quality code
09:18:07 <Siod> ive seen C++ projects structured similarly to haskell projects
09:18:12 <dcoutts_> Siod: I'm not quite sure what comparison you're making exactly
09:18:37 <Eliel> Siod: haskell required reasonably explicit data flow to be specified in the code. Most other languages don't.
09:18:47 <Eliel> s/required/requires/
09:19:06 <Siod> Eliel: the keyword is requires; good developers in other languages want explicit data flow
09:19:18 <Eliel> yep
09:19:19 <Siod> i.e., you'll see C++ projects structured similarly to haskell projects
09:19:38 <bas_> at what level?
09:19:50 <Eliel> that requirement is, I think, the reason people have a problem with haskell.
09:19:59 <Eliel> and others love it
09:20:14 <dcoutts_> we don't need to convert everyone
09:20:16 <Siod> bas_: the architectural level
09:20:29 <dcoutts_> just the top 10% best programmers, the ones who understand the value of abstraction
09:20:31 <Siod> bas_: project leaders will forbide singletons and coupling for example
09:20:47 <Siod> bas_: which basically makes the project structured like you're using the state monad
09:21:08 <bas_> dcoutts_, personally my choice of Haskell is largely one of aesthetics
09:21:17 <bas_> it best matches my thinking
09:21:23 <Siod> more recently, though. developers are adopting a more granular functional approach in imperative programming
09:21:29 <Siod> carmac had an article with suggestions on that approach
09:21:33 <dcoutts_> bas_: with the consequence that you're more productive (and happier)
09:21:44 <Siod> eg. using vec3f normalized() instead of void normalize() for a vector class
09:21:53 <bas_> fitter, happier, more productive, yes, if you catch the reference
09:22:03 <dcoutts_> heh
09:22:18 <dcoutts_> but the practical benefit (e.g. business benefit) is the higher productivity
09:22:40 <bas_> in a broad sense of the word productivity yes
09:22:42 <bas_> more reliable
09:22:46 <dcoutts_> and increased productivity is most important for the best programmers who are most productive to start with
09:23:01 <bas_> less maintenance, easier to share
09:23:17 <bas_> and less time between prototype and final
09:23:20 <dcoutts_> bas_: sure, in the broadest sense, producing the desired quality of results quicker, or higher quality in the same time
09:23:25 <bas_> yeah
09:23:34 <dcoutts_> and the ongoing benefits, maintenance, flexibility etc etc
09:25:49 <Siod> what still annoys me about haskell code is that when browsing a new code base, i never have an idea where an unfamiliar function comes from; other languages are more qualified by default
09:27:58 <roconnor_> Siod: you mean other languages are more object oriented?
09:28:32 <Siod> roconnor_: haskell has the same ability by forcing an import to be qualified, but you have to force it--it's not default
09:28:43 <bas_> well perhaps "the problem" is that functions are not methods
09:28:56 <Siod> what i'm referring to is closer to namespaces than objects
09:29:01 <bas_> hm
09:29:01 <roconnor_> Siod: I don't disagree with you.  I think all hackage packages should (automatically) be rewritten with fully specified imports
09:29:18 <Siod> yeah
09:29:36 <yitz> it'd be nice to have a refactoring tool that does that automatically
09:29:44 <roconnor_> Siod: Java has a similar import mechanism to Haskell AFAIU.  The main difference is that java programs often use method calls
09:30:00 <yitz> i spend a lot of time fiddling with import busywork in haskell. reminds me of java.
09:30:32 <Siod> i like c++ namespaces
09:31:04 <mcstar> nothings better than a cold c++ namespace
09:31:23 <mcstar> why would you like it?
09:31:45 <Siod> it's a good way of encapsulating an implementation into a label
09:31:57 <roconnor_> I'd like modules *not* to be units of comilation in GHC :/
09:32:03 <Siod> and you can use it for documentation even, by creating namespaces inside namespaces
09:32:03 <roconnor_> *compilation
09:32:19 <Siod> so you have your chatbot namespace, and inside that you have your internals namespace
09:32:19 <c_wraith> roconnor_: just mark all your functions as INLINEABLE.  problem solved!
09:32:33 <mcstar> Siod: why would it be better in any way than haskell's modules?
09:32:40 <mzero> Haskell Platform 2012.2.0.0 is official: http://hackage.haskell.org/platform/
09:32:42 <Cheery> hmm
09:32:48 <yitz> yay!
09:32:54 <Siod> mcstar: it's qualified by default, and you can shorten the namespace tree of several imports
09:32:58 <mzero> any channel ops here: time to change the topic!
09:33:09 <yitz> @where ops
09:33:09 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
09:33:19 <Siod> mcstar: so you have data.list and data.map and so on; with c++ can remove the data. part with one declaration
09:33:24 <Cheery> navaati: so with zipper I'll get a current node + way to reconstruct the tree aka. context
09:33:41 <Siod> so now you get to simply say list. and map. and so on
09:33:51 <Siod> for *everything* in the data namespace
09:33:55 <dcoutts_> mzero: if I change nick I can set the topic I think
09:34:02 <dcoutts_> mzero: what do you want exactly?
09:34:12 --- mode: ChanServ set +o mauke
09:34:12 --- topic: set to '["Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.1: http://is.gd/vkWMMa ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","admin/spam issues: #haskell-ops "]' by mauke
09:34:25 <mzero> done!
09:34:27 <mzero> thank mauke
09:34:28 <mauke> dcoutts_: you don't need to change nick
09:34:35 <parcs`> 2012.2? why not 2012.5? :)
09:34:43 <mzero> ;-)
09:34:57 <parcs`> actually it's 6 now
09:35:21 <mzero> shhhhhhh parcs` , we only missed May by three days
09:35:27 <dcoutts_> mauke: doesn't seem to like it, though I think I did link my nicks
09:35:47 <mauke> dcoutts_: what command did you use?
09:35:55 <dcoutts_> mauke: /op dcoutts_
09:36:12 --- mode: mauke set -o mauke
09:36:12 <mauke> you need ops to +o someone
09:37:10 <mauke> I'm assuming that /op is an alias for /mode +o in your client (as usual)
09:37:21 <dcoutts_> mauke: honestly I've no idea
09:37:28 <mcstar> siod
09:37:34 <mauke> dcoutts_: /msg chanserv op #haskell
09:37:44 <bokuk1> i have a question. laziness operate on list only ?
09:37:44 --- mode: ChanServ set +o dcoutts_
09:37:52 <mauke> bokuk1: no
09:37:56 <hughfdjackson> laziness is in all the places
09:37:59 <hughfdjackson> by default
09:38:02 <mcstar> laziness is a property of the language
09:38:05 <Adeon> they operate on everything not explictly marked strict
09:38:13 <mauke> dcoutts_: now you can /deop yourself (because you're +o) :-)
09:38:13 <dcoutts_> bokuk1: it's totally pervasive, it's the Haskell evaluation strategy
09:38:28 --- mode: dcoutts_ set -o dcoutts_
09:38:58 <bokuk1> hmm...
09:39:02 <bokuk1> data MyList = MyListEmpty | MyList Int (MyList) deriving Show
09:39:37 <Twey> Brackets are redundant
09:39:39 <bokuk1> can i make a function that manage the MyList type value using laziness ?
09:39:50 <Twey> bokuk1: Any function you like
09:40:07 <dcoutts_> @faq can i make a function that manage the MyList type value using laziness ?
09:40:07 <lambdabot> The answer is: Yes! Haskell can do that.
09:40:15 <mcstar> > let f x y = x in f 1 undefined
09:40:15 <lambdabot>   1
09:40:20 <mcstar> thats laziness ^^
09:40:44 <Twey> repeatMyList :: Int -> MyList; repeatMyList n = MyList n $ repeatMyList n
09:41:03 <mcstar> > [1..] !! 10000
09:41:04 <lambdabot>   10001
09:41:34 <Twey> bokuk1: There's nothing magic about the list types (except the [] syntactic sugar)
09:42:06 <Adeon> the 'if'-like function is a good example of lazyness in use that doesn't involve lists, IMO
09:42:37 <Adeon> that is, you can define an 'if' function the naive way that would break in strictly evaluated context
09:42:41 <bokuk1> hmm...
09:43:33 <monochrom> oh yikes, new haskell platform
09:44:31 <bokuk1> thanks a lot ~
09:44:55 <bokuk1> but. It is difficult to me~. haskell too difficult~
09:46:05 <mzero> :-)
09:46:40 <monochrom> somehow I don't think haskell is difficult per se. it's difficult under previous imperative programming education, sure.
09:46:57 <hughfdjackson> bokuk1: i'm not very far in my haskell education
09:47:11 <hughfdjackson> but it seems (at the moment) that it seemed more daunting than it appears at first
09:47:22 <Ke> resource management in haskell may be non-trivial
09:47:38 * hughfdjackson is just ignoring that aspect for the moment
09:47:38 <monochrom> I just opened a virtual machine inside my mind to learn haskell (or anything). it was pretty easy.
09:47:57 <Cheery> "bears activated"
09:48:12 <bokuk1> :-)
09:48:20 <Ke> I would say lazy is the most difficult aspect of haskell
09:48:53 <bokuk1> I thinks so~
09:49:00 <mcstar> monochrom: what?
09:49:12 <monochrom> a virtual machine in my mind. yes I can do that.
09:49:18 <LeNsTR> monochrom: :)
09:49:46 <alanz>  /msg NickServ identify  7ni8yunmqh46ccjd
09:49:58 <luca> ....lol
09:49:58 <navaati> alanz: oops :D
09:50:04 <Enigmagic> heh
09:50:10 <LeNsTR> funny joke
09:50:12 <monochrom> I think it's also a pretty important skill if you sometimes talk to intuitionists and some other times talk to classicists, no? :)
09:50:16 <alanz> oh well
09:50:18 <mcstar> it shows ****************** for me, whats funny?
09:50:31 <alanz> bloody spaces
09:50:34 <bokuk1> can you address me about web page well documented about lazy ?
09:50:52 <monochrom> yes, see my http://www.vex.net/~trebla/haskell/lazy.xhtml
09:51:16 <navaati> mcstar: it shows **** because there is a filter directly in your client (weechat ?), but the pass have been leaked
09:51:27 <mcstar> navaati: J/K
09:51:46 <bokuk1> thanks monochrom ~ :-)
09:52:09 <mcstar> monochrom: do you want to explain this VM concept of yours?
09:52:29 <parcs`> alanz: you should be identifying through the server password field
09:52:43 <alanz> ok, im new to this
09:52:46 <monochrom> like virtualbox and vmware
09:52:54 <mcstar> in your mind???
09:52:59 <monochrom> yes
09:53:18 <mcstar> monochrom: >not so nice words<
09:53:46 <parcs`> alanz: http://freenode.net/faq.shtml#nicksetup
09:54:05 <parcs`> #7
09:54:37 <mcstar> alanz: btw, congrats on your password, seems to be strong
09:55:15 <alanz> autogened in keepass. Simplest habit to get into
09:55:24 <Cheery> navaati: but with zipper, isn't there quite bit of problems if I'd like to change the thing from two cursors at once?
09:55:32 <mcstar> i just remember a long sentence
09:55:53 <navaati> two cursors ? wtf ?
09:56:07 <Cheery> well say I want to describe a selection
09:57:03 <navaati> oh‚Ä¶ hem, didn't think about selection‚Ä¶
09:58:40 <luca> hahaha; ouch. Modified my parser to permit things like (a&&!b) instead of just (a&& !b) but made parsing RIDICULOUSLY slow in comparison due to all the added backtracking
09:59:25 <luca> like 1 minute for a fairly large file, versus 0.01 seconds
10:00:16 <monochrom> haha yeah that's awesome or awful :)
10:00:28 <arnsholt> Sounds like you might need lookaheads in strategic places
10:00:47 <luca> i've decided to just not allow things like a&&!b instead :P
10:01:21 <ziman> I use `try' for tokenization and avoid it at the grammar level
10:01:23 <Cheery> navaati: well if you flatten a tree into a list with tree markers.. I think it's bit like that zipper thing.
10:01:38 <luca> ziman: I would, but the grammar is not tokenizable
10:01:39 <Cheery> so I might still get the idea how to handle the markers from there
10:01:55 <ziman> luca, ah, too bad. :)
10:02:05 <mzero> luca - I don't know what language you are parsing - but if you can tell that &&! can never be an operator on its own - that is, that it is always two tokens - then there is no reason for any backtracking - your parser should be just as fast
10:02:22 <luca> specifically the language has things like a<b<c>>, but also >> as an operator etc
10:02:34 <mzero> the trick will be in defining your operator token parser to NOT be like the free built in one - that accepts any sequence of operator characters
10:02:45 <mzero> is the set of operators fixed?
10:02:48 <luca> yeh
10:02:58 <mzero> then there is no reason for it to be slow
10:03:17 <luca> well to get around it, i stopped using buildExpressionParser and did it more manually
10:03:19 <mzero> how do you resolve   a<b<c>>  vs   a<b<c> >   (note extra space)
10:03:57 <luca> with lots of trys inserted to avoid it parsing a&&b and failing due to trying to parse lhs as a& then finding it can't do a rhs for the & operator etc
10:04:17 <luca> mzero: things like a<b<c>> can only appear in specific parts of the grammar
10:04:20 <luca> so it's unambiguous
10:04:43 <luca> in one place it would be parsed as a type name, in another part as an expression with no overlap
10:04:44 <mzero> it would be common, like C++ for example, to insist on a "maximal operator" rule -- so >> with no space is always a single operator -- and > > has to have a space to be two
10:06:58 <luca> I already had to add a fair bit of backtracking (which thankfully didn't slow it down too much) as i'm trying to parse a subset of this particular langage, and keep preprocessor stuff where possible
10:07:12 <luca> instead of running through preprocessor, then parsing
10:07:47 <luca> (I'm writing a translator for a subset of this language, and want to keep things like preprocessor statements)
10:09:50 <bitonic> yeee new platform.
10:12:37 <mcstar> hm, just because a data structure is cyclic, it doesnt need to be immutable right?
10:12:49 <mcstar> -im
10:12:56 <Cheery> mcstar: no
10:13:13 <mcstar> why?
10:13:21 <Cheery> or wait
10:13:31 <mauke> enjoy your ambiguous question
10:13:32 <mcstar> immutability with laziness works, wouldnt it?
10:14:09 <monochrom> you can have {cyclic, acyclic} {mutable, immutable} data structures
10:14:21 <mcstar> i heard a claim that you need mutability for cyclic structures, thats the claim
10:14:36 <mauke> ah, so when you said "immutable", you meant "mutable"
10:14:42 <mcstar> mauke: -im
10:14:43 <Cheery> "an immutable object is an object whose state cannot be modified after it is created."
10:14:53 <monochrom> "x = () : x" is beginner's cyclic immutable data structure
10:15:09 <Cheery> lol
10:15:30 <mauke> mcstar: const struct node x = { 0, &x };  // immutable cyclic strict
10:15:35 <mcstar> yeah, but that works only because of laziness
10:15:38 <mcstar> right?
10:16:10 <monochrom> I would say yes
10:16:18 <Cheery> that doesn't need laziness
10:16:35 <Cheery> just a pointer pervert who likes to hook immutable objects to themselves.
10:17:19 <mauke> ocaml> let rec a = 0 :: b and b = 0 :: a in a = b;;  (* infinite loop *)
10:17:30 <mauke> immutable cyclic strict
10:17:34 <mm_freak> navaati: if you look at the type of the parallel switching combinators of yampa, you will see what i mean‚Ä¶  if you absolutely want them back, you can just copy the code from netwire 1.2.7
10:17:50 <mm_freak> it had the switching combinators yampa has
10:18:14 <quazimodo> hey mahogny
10:18:32 <Cheery> you can create cyclic immutable structures by defining labels and defining links between them. :)
10:18:48 * quazimodo started learning lambda calculus
10:19:14 <navaati> hum‚Ä¶ i think i'll develop on animas atm, finding a way to combinate events as elegantly as in netwire, and i'll check the next version of netwire when it'll come
10:20:12 <tuxit> evening all
10:20:16 <Cheery> I guess I'll get off the computer, go design the fancy data structure on the paper, perhaps walk outside and fart some more
10:21:03 <mcstar> cherry odour farts?
10:21:19 <Cheery> my intestines have decided that a global warming isn't so bad thing after all.
10:21:47 <Cheery> or local warming
10:22:15 <mcstar> anyway, im reading here, 'a doubly linked list is a cyclic data structure, and it necessarily have to be imperative'
10:23:03 <monochrom> if it is on some wiki, you can correct it
10:23:26 <mcstar> a doubly linked list is not a trivial recursive cyclic structure
10:23:40 <monochrom> a counterexample in haskell is left as an exercise for the reader
10:23:50 <mcstar> yay
10:23:54 <monochrom> a counterexample in C is left as an exercise for mauke
10:23:57 <mcstar> i think im the reader
10:24:47 <Cheery> feeling I figured it out
10:24:58 <monochrom> doubly-linked list is trivial in comparison with triply-linked tree
10:25:02 <mcstar> btw, it is in jason hickey's ocaml book
10:25:30 <Cheery> I guess I can implement the flat representation of tree with symbols in it.
10:25:31 <monochrom> ok, add "in ocaml" to every sentence in the book
10:25:45 <mauke> preparing a counterexample in ocaml ...
10:25:57 <Cheery> then implement a splice on that, with link/unlink -behavior to trickster with the tree
10:25:59 <monochrom> oh haha, that will rock :)
10:26:22 <Cheery> I guess the definition should span about a page.
10:26:33 <Cheery> so it's simple enough .)
10:26:34 <Cheery> :)
10:29:13 <ion> > let a = (d, 0, b); b = (a, 1, c); c = (b, 2, d); d = (c, 3, a) in map (\(_,x,_) -> x) . iterate (\(l,_,r) -> l) $ c
10:29:14 <lambdabot>   Occurs check: cannot construct the infinite type:
10:29:14 <lambdabot>    t = ((t1, t2, t), t3, ...
10:29:40 <dzhus> does GHC inline constants?
10:29:40 <ion> duh. A new datatype is needed. :-P
10:30:04 <monochrom> sometimes
10:30:17 <mm_freak> apparently you can only select between threaded and non-threaded RTS‚Ä¶  isn't it possible to specify a custom RTS somehow?
10:30:21 <mauke> blarh, ocaml syntax
10:30:28 <aristid> :t In
10:30:29 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
10:30:35 <mauke> mcstar, monochrom: http://codepad.org/2hFv7XTw is what I came up with
10:30:37 <aristid> ion: like this?
10:31:12 <monochrom> yeah, that works, thanks mauke
10:32:01 <ion> aristid: Hmm. Is that enough for doubly-linked (,,)s?
10:32:42 <monochrom> well, In plus its inverse is enough for everything
10:33:00 <aristid> ion: doubly-linked? not sure:)
10:33:06 <aristid> monochrom: which is its inverse?
10:33:32 <mcstar> mauke: hm, i dont get it
10:33:42 <mcstar> how can you extend the dlist?
10:33:45 <monochrom> @src In
10:33:46 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
10:33:50 <mauke> mcstar: you can't, it's immutable
10:33:50 <aristid> ah
10:33:52 <monochrom> out is In's inverse
10:34:00 <aristid> monochrom: i thought you meant some kind of dual type to Mu :)
10:34:05 <luca> :t has
10:34:06 <lambdabot> Not in scope: `has'
10:34:15 <mcstar> that doesnt matter, you should still be able to make a bigger dlist from it
10:34:16 <luca> :D
10:34:18 <mcstar> this is useless
10:34:27 <mauke> mcstar: why should I be able to?
10:35:02 <mcstar> its like saying, you have a cons list, which is of length N, but you cant cons another element to the front
10:35:09 <mauke> yes
10:35:12 <mauke> what's wrong with that?
10:35:17 <mcstar> 42
10:35:18 <monochrom> an "immutable doubly-linked list" was specified. since it's immutable, you can't add stuff afterwards
10:35:52 <monochrom> "cons list" is singly-linked. there lies the difference
10:36:56 <geekosaur> mm_freak, some years back I think there was an attempt to make runtimes pluggable; this mostly demonstrated that the runtime and ghc are a bit too tightly entwined for it to work in any reasonable fashion
10:37:15 <monochrom> you can, of course, create one more node to point to the existing doubly-linked list. but do not expect the latter to point back to the former
10:37:44 <mm_freak> hmm
10:39:46 <mcstar> mr obvious
10:40:00 <monochrom> yes?
10:40:13 <mcstar> nothing
10:40:33 <aristid> just
10:42:30 <mauke> is it possible to write a function 'a list -> 'a dlist in ocaml?
10:43:56 <mzero> anyone have opinions on continuous integration services for Haskell?
10:44:03 <aristid> mauke: is dlist a difference list or a doubly-linked list? *not helping just curious*
10:44:06 <mcstar> mauke: i dont see how could that dlist be efficiently created
10:44:21 <mauke> aristid: oh, doubly linked list
10:44:22 <mcstar> aristid: 2nd
10:44:48 <mauke> mcstar: ignore efficiency for now
10:45:15 <mcstar> yes it is possibl
10:45:17 <mcstar> e
10:45:19 <mcstar> why wouldnt it be?
10:45:43 <mcstar> put your code in a function, that takes 2 elements from the list, and returns a dlist
10:46:17 <mcstar> returns x for example
10:46:57 <mcstar> now converting a list to a dlist, idk
10:47:08 <mcstar> i would say no
10:47:13 <aristid> why wouldn't it be possible?
10:47:20 <mauke> ok, yes, const Nil is a possible implementation
10:49:21 <Igloo> Does anyone know how I am supposed to free a gtk2hs Pixbuf?
10:50:18 <hpc> Igloo: it gets GC'd
10:50:23 <mcstar> oops, i once run into a problem with pixbufs, they showed up as resource memory for X, ate all my ram
10:50:31 <hpc> in theory
10:50:56 <Igloo> Hmm, well, the memory usage implies it isn't  :-)
10:51:12 <mcstar> in my case, they certainly weren gc'd
10:51:12 <Igloo> GCed by gtk+, rather than by GHC's RTS?
10:51:41 <hpc> i mean, the haskell Pixbuf values should have a finalizer that does the C-side free
10:51:57 <hpc> and that runs on GHC GC
10:52:35 <mcstar> hpc: once you display it, X caches it or something
10:52:50 <mcstar> i dont want to say totally bullshit things, but they really showed up for X
10:53:27 <hpc> yeah, i don't know what does happen, but that's what should happen
10:53:38 <mcstar> maybe they were gc'd but still..
10:53:39 <hpc> (should, because it's how everything else gtk works, and so it's expected)
10:54:35 <ion> I give up. I can‚Äôt figure out how to do the equivalent of data L a = L a (L a) (L a) with Mu and standard types (or at least the ones available in lambdabot).
10:55:36 <aristid> :t In (In undefined, In undefined)
10:55:37 <lambdabot> forall (f :: * -> *). Mu ((,) (Mu f))
10:55:57 <hpc> newtype F b a = F b a a -- uh, maybe something like this?
10:56:03 <ezyang> Commutative monads: still hard to reasona bout?
10:56:07 <aristid> hpc: using just Mu is the goal
10:56:09 <dolio> I'm not sure there's anything predefined that does F a = (a, a).
10:56:19 <dolio> Which you need.
10:56:33 <hpc> aristid: er, s/newtype/data
10:56:39 <hpc> aristid: and then Mu (F a) ~~ L a
10:57:08 <aristid> hpc: dolio seems to imply that the b in your type is not necessary
10:58:00 <hpc> i think it has to be there
10:58:07 <dolio> I don't think I implied that.
10:58:09 <hpc> because once you apply Mu to (F b), a = (F b a)
10:58:18 <dolio> But F a = (a, a) is a building block that's lacking.
10:58:24 <hanDerPeder> hey, dont know if this makes sense or not but is there a convenience function for the REPL that lets me write something like "foo x >>= bar" instead of "foo x >>= (\y -> return $ bar y)"?
10:58:52 <ion> handerpeder: bar <$> foo x
10:59:00 <hpc> if you don't have the 'b', you can't actually place a value at the leaves
10:59:12 <hanDerPeder> ion: thats applicative, right?
10:59:18 <ion> (<$>) = fmap
10:59:28 <hpc> or put another way, if you want (Mu `O` F) ~~ L, (Mu `O` F) :: * -> *
10:59:30 <hanDerPeder> ion: aha, thanks!
10:59:40 <ion> You do get it by importing Control.Applicative, but it lives in Data.Functor.
10:59:50 <hpc> which means Mu (F x), for some x
11:00:12 <hpc> or something like that
11:00:22 * hpc isn't very good at explaining
11:01:51 <ion> hpc: I get it, i was just wondering if there‚Äôs some way to do a doubly-linked list in lambdabot since we can‚Äôt define new types. :-)
11:02:16 <hpc> ah
11:02:21 <hpc> ([a], a, [a])
11:02:24 <hpc> manual zipper
11:02:37 <copumpkin> automatic zippers sound dangerous
11:02:43 <copumpkin> just think of the things that could get caught in them
11:02:47 <mauke> zippers don't count
11:03:21 <copumpkin> someone should implement those 1.5ly-linked lists in haskell! ;)
11:03:22 <hpc> oh, then STRef, or terrifying knot-tying
11:03:38 <mcstar> real men use buttons instead of zippers
11:04:40 <otters> 1.5 light years? :O
11:04:54 <pooya72> applicative: hello!
11:04:54 <copumpkin> nah, between singly and doubly :P
11:05:10 <applicative> oh pooya72 hi
11:05:49 <pooya72> applicative: man haskell does have a high learning curve :) - at least compared to ruby/python
11:06:10 <aristid> catholipumpkin: the pope approves
11:06:34 <otters> pooya72: that's how you know it's a good language
11:06:36 <ion> pooya72: Did you do any programming before Ruby/Python?
11:06:46 <pooya72> ion: a little yeah
11:06:51 <pooya72> otters: :)
11:06:57 <mcstar> i wonder about languages' forgetting curves
11:07:13 <mcstar> haskell's could be pretty steep there too
11:07:19 <ion> Was your first programming language considerably easier to learn than Haskell?
11:07:19 <applicative> or unlearning curve yes
11:07:24 <pooya72> ion: oh sorry no. ruby - python were my first
11:07:43 <otters> ruby is great
11:07:47 <luca> till last night havn't touched haskell since learning basics over 2 years ago, got back into it straight away
11:07:58 <applicative> haskell is easier to learn than python and ruby, if we can generalize from my case...
11:08:06 <otters> we can't
11:08:15 <mcstar> we tried to, we failed XD
11:08:19 <otters> it took me a long time to learn haskell
11:08:26 <otters> but I like it a lot better than any imperative language
11:08:29 <applicative> of course Haskell sort of keeps going
11:08:36 <pooya72> but I can't say the way i was programming ruby as actually programming
11:08:43 <applicative> but then so does entymology
11:08:45 <pooya72> I now notice how bad I was at it
11:08:52 <pooya72> thanks to haskell :)
11:08:59 <hpc> applicative: you don't actually learn python
11:09:06 <hpc> you just get a list of things you are allowed to do from guido
11:09:09 <mcstar> on a side note, star trek: enterprise feels a bit lame
11:09:11 <applicative> hpc what do you do?
11:09:15 <applicative> ah
11:09:19 <hpc> :P
11:09:29 <applicative> python is not imperative; guido is.
11:09:42 <applicative> python is an obediential programming language
11:09:55 <arnsholt> I'm gonna have to try to remember some of applicative's quotes the next time I have to teach Python ^_^
11:10:06 <hpc> :D
11:10:11 <applicative> obediences dont compose though
11:10:28 <otters> tries to think of a composition joke
11:10:42 <arnsholt> I had some quips along those lines, but the one about the list of allowed things is definitely the best one I've heard in a while
11:10:42 <aristid> @quote applicative
11:10:42 <lambdabot> applicative says: {-# MORALS loose #-}
11:10:55 <applicative> ha
11:11:03 <otters> @quote applicative
11:11:03 <lambdabot> applicative says: if you are only beginning to learn Haskell, don't let them talk to you about monads. ask them about fmap
11:11:15 <applicative> theres wisdom
11:11:20 <hpc> that's a damn good bit of advice
11:11:27 <aristid> man, Functors are so hard to understand
11:11:29 <djahandarie> @quote djahandarie
11:11:30 <lambdabot> djahandarie says: I wonder if De Bruijn was any good at remembering names.
11:11:31 <applicative> @quote applicative
11:11:31 <lambdabot> applicative says: if you are only beginning to learn Haskell, don't let them talk to you about monads. ask them about fmap
11:11:36 <djahandarie> Hah
11:11:39 <applicative> ah well
11:11:42 <otters> surprisingly it took me a very long time to understand that a Functor isn't "a box"
11:11:45 <monochrom> example of obediences do not compose: "I want it fast, cheap, good"
11:11:52 <aristid> djahandarie, applicative: tsk tsk, love listening to yourselves? :P
11:11:53 <hpc> Functor is really the gateway to type classes in general
11:11:55 <otters> and to try and disengage from concrete concepts
11:12:04 <hpc> it's the first higher-kinded ANYTHING you come across
11:12:09 <monochrom> Functor is the gateway drug? :)
11:12:12 <Twey> A Functor *is* a box, or something that wants to look like a box
11:12:12 <applicative> no i was hoping for one some made last week, aristid
11:12:13 <otters> just like monoid is "something with a binary operation"
11:12:29 <barrucadu> Functor is the typeclass gateway drug
11:12:42 <otters> I was reading the Monoid docs awhile ago
11:12:45 <applicative> that God's truth barrucadu
11:12:57 <otters> "mappend is 'an associative operation'? what is it supposed to do??"
11:12:57 <bitonic> when using conduit, is there an easy way, given a Sink, to feed the sink data and return the result only if the sink has completed (if it has reached Done), or another Sink otherwise, to resume when more data is present? I feel like I'm missing something easy
11:13:02 <mzero> well, it's a "box" for a very mind-alterting defintion of "box"
11:13:13 <mauke> mzero: I fully support that definition :-)
11:13:14 <monochrom> I used Num as the typeclass gateway drug
11:13:19 <otters> and finally realized "oh, it's just 'an associative operation'"
11:13:27 <aristid> otters: it's supposed to be associative, and mempty is supposed to be the identity element! that's what it do
11:13:36 <otters> right
11:13:48 <otters> but I was thinking, "an associative operation that does what?!"
11:13:51 <otters> silly old me
11:14:06 <dmwit> "an associative operation that does what?" "depends"
11:14:08 <monochrom> yeah, the biggest hurdle with type classes is allowing yourself to ask "but what does it do?"
11:14:30 <otters> it does anything that fulfills the type signature
11:14:32 <monochrom> or "what is it?"
11:14:36 <aristid> otters: www.zombo.com answers that question
11:14:40 <monochrom> hahaha
11:15:11 <barrucadu> I think an equally valid question is "But will it blend?"
11:15:25 <aristid> @hoogle blend
11:15:25 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Environments Blend :: TextureFunction
11:15:25 <lambdabot> Graphics.Rendering.OpenGL.GL.PerFragment blend :: StateVar Capability
11:15:25 <lambdabot> Graphics.Rendering.OpenGL.GL.PerFragment blendColor :: StateVar (Color4 GLclampf)
11:15:41 <mcstar> lol
11:16:02 <mcstar> DONT look for it on youtube
11:16:04 <applicative> bitonic, shouldn't this all be one complex sink, though?
11:16:45 <aristid> bitonic: maybe ask in this new mailing list? :D https://groups.google.com/forum/#!forum/streaming-haskell
11:17:12 <applicative> bitonic: and perhaps a more complicated source
11:17:32 <hayashi> "will it beat Monad as the typeclass abstraction du jour?"
11:17:53 <applicative> what is the 'streaming haskell' list defined as being about
11:18:23 <aristid> applicative: iteratees, enumerators, conduits and pipes!
11:18:39 <aristid> no lazy I/O allowed
11:18:46 * hayashi notes that he hasn't written a monad tutorial yet, and resolves to write one (if one doesn't exist) stating "Monads are monads.  (This is a lazily evaluated monad tutorial.)"
11:18:49 <applicative> I would much rather read about the iteratee - enumerator -conduit -pipes smackdown on a list than on reddit, which has proven to make me an idiot again and again
11:19:03 <fragamus> can someone translate this line of code into english‚Ä¶ I was surprised by the braces‚Ä¶ newtype MySupply e a = MySupply { runMySupply :: Reader e a } deriving (Monad)
11:19:10 * applicative demands minority rights for lazy io!
11:19:19 <ion> data Pipe ‚Ä¶ = Pipe { smoke :: ‚Ä¶ }
11:19:19 <mauke> fragamus: that's record syntax
11:19:27 <fragamus> oh right
11:19:34 <mauke> I can translate it to Haskell!
11:19:39 <applicative> aristid: not much activity yet
11:19:48 <bitonic> applicative: well the situation I've got is a Sink to "execute" incrementally, but I want to make sure to execute as much of the Sink as possible each time data arrive, and stop when the Sink is Done
11:19:52 <mauke> newtype MySupply e a = MySupply (Reader e a) deriving (Monad)
11:19:59 <mauke> runMySupply (MySupply x) = x
11:20:04 <aristid> applicative: no, i just got invited like half an hour ago, so i guess michael created it then :)
11:20:06 <bitonic> I'm not sure about the terminology here
11:20:17 <aristid> actually 2 hours ago
11:20:19 <applicative> oh its by invitation, aristid....
11:20:25 <ben> but then you can't do someMySupply { runMySupply = ... okay you probably don't want to do that anyway
11:20:29 <aristid> applicative: oh it's not public?
11:20:33 <bitonic> btw, is the pipes-conduit civil war over yet?
11:20:43 <applicative> no it is, as far as i can see
11:20:43 <aristid> bitonic: i don't think so
11:20:55 <mauke> there's a war?
11:21:00 <applicative> aristid: oh wait, i apply to join
11:21:12 <bitonic> mauke: well theres a looong ongoing debate
11:21:20 <HugoDaniel> there's no war, just use conduits but tell your friends about pipes :P
11:21:39 <ben> enlist today
11:21:41 <mauke> what's good about conduits?
11:21:47 <applicative> mauke: can you please tell Judge Fouquier-Tinville what streaming IO library you use?
11:21:49 <ben> they're in yesod
11:21:56 <mauke> applicative: none
11:22:28 <Fouquier-Tinvill> Off with maukes head!
11:23:08 <aristid> mauke: do you at least use Strict IO?
11:23:17 <applicative> 10 years hard labor, you used lazy  io
11:23:24 <mauke> aristid: sometimes, yes
11:23:33 <applicative> mauke thats so ... so ... *unprofessional*
11:23:37 <mauke> e.g. preflex is all strict bytestrings
11:24:07 <aristid> So you are not Committed to the Revolution
11:24:43 <mauke> right
11:24:47 <mauke> but I've read about pipes
11:25:02 <applicative> mauke THIS IS THE TIME OF DECISION; DONT LET YOUR MODULES BE CONSIGNED TO THE DUSTBIN OF HISTORY; USE ITERIO
11:25:18 <mcstar> http://www.yesodweb.com/book/conduit
11:25:20 <mauke> how about I just use perl instead
11:25:24 <mcstar> very imformative
11:25:36 <aristid> mauke: well, that way you at least avoid the civil war
11:25:47 <mauke> mcstar: looks heavily out of date
11:26:01 <mcstar> mauke: it just lacks some details
11:26:47 <mauke> wow, the code formatting is terrible
11:27:26 <aristid> that's a good reason to use pipes indeed :D
11:28:27 <dmwit> mcstar: 404'd...?
11:28:54 <mauke> dmwit: http://www.yesodweb.com/book/conduits
11:29:33 <aristid> mauke: that's heavily out of date it seems
11:29:58 <mcstar> dmwit: no, just 'not found', yesod is smart enought to omit 404
11:30:05 <applicative> mauke: you mean the way snoyman writes code?  or something about the website
11:30:45 <mcstar> hah
11:31:19 <RenJuan> eye no con du it
11:31:20 <mcstar> http://www.haskell.org/haskellwiki/Conduit first link to yesodweb, it needs an 's'
11:32:17 <aristid> what's a comonoid? :)
11:32:40 * applicative found the Conduit Style loathesome at first but there is in fact a characteristic genius to it. 
11:32:56 <aristid> applicative: explain
11:33:10 <aristid> explain what you just said _and_ explain what a comonoid is, that is.
11:33:16 <RenJuan> loathing at first sight, that's an achievement right thar
11:33:18 <mauke> applicative: http://mauke.hopto.org/tmp/screenshot.png
11:33:43 <aristid> mauke: that's a rendering bug
11:33:47 <mcstar> terrible fonts if i may say so
11:33:48 <applicative> mauke i see, thats rendering
11:34:02 <mauke> that's not a rendering bug, that's bad web design
11:34:29 <applicative> aristid he systematically lays things out and inclines you to lay things out so that you keep track of things, eg what 'layer' in the transformer 'stack' youre operating on
11:34:40 <mcstar> anyway, if someone can fix haskellwiki, pls put an 's' at the end of the link
11:35:32 <RenJuan> ur bitchin about the conduit page at haskell.org?
11:35:43 <dmwit> mcstar: It's a wiki. You can fix it.
11:35:51 <mauke> the text column is very narrow (less than a third of my screen width), and the lines are long enough that most comment lines spill over by one word
11:35:54 <mauke> which is super annoying to read
11:36:19 <aristid> mauke: if you have 1920 pixels wide, why do you show the browser fullscreen anyways?
11:36:39 <RenJuan> my web design would make you dig out your brain with a spoon
11:36:59 <mcstar> RenJuan: why is that 'bitchin'?
11:37:43 <RenJuan> another expression would be "princess on a pea"
11:37:43 <mauke> aristid: to emphasize the silliness of the formatting
11:38:30 <dmwit> Why do web pages like to waste so much space like that anyway?
11:38:47 <RenJuan> mcstar: because to me and probably most people here it's entirely adequate. Haskell is a community of programmers not web designers.
11:38:48 <mauke> RenJuan: wait, are you saying people who complain about broken links are oversensitive?
11:38:49 <dmwit> It's kind of like spitting on window managers.
11:39:09 <mcstar> ah
11:39:20 <RenJuan> no I'm reacting to the complaint about the haskell.org web design
11:39:29 <mauke> RenJuan: what complaint was that?
11:39:31 <RenJuan> broken is broken
11:40:32 <RenJuan> mauke, yours apparently
11:40:37 <tromp_> > fix fix
11:40:38 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
11:40:52 <hpc> > fix Mu fix
11:40:53 <lambdabot>   Not in scope: data constructor `Mu'
11:40:55 <mauke> RenJuan: I never mentioned haskell.org
11:40:57 <hpc> > fix In fix
11:40:58 <lambdabot>   Couldn't match kind `(* -> *) -> *' against `* -> *'
11:41:01 <hpc> :(
11:41:04 <RenJuan> ah, then my bad
11:41:09 <mcstar> i think he switched our nicks
11:41:09 <mauke> yes
11:41:19 <newsham> when all else fails, fix it
11:41:25 <newsham> > 1 + fix it
11:41:28 <lambdabot>   mueval-core: Time limit exceeded
11:41:47 <newsham> > fst (1, length (fix it))
11:41:49 <lambdabot>   1
11:42:25 <otters> > fst (1, undefined)
11:42:26 <lambdabot>   1
11:42:36 <newsham> > snd (readFile "/etc/passwd" >>= fixIt, "done")
11:42:37 <lambdabot>   Not in scope: `fixIt'
11:42:43 <newsham> > snd (readFile "/etc/passwd" >>= fix it, "done")
11:42:45 <lambdabot>   "done"
11:42:47 <twanvl> woah, enabling GADTs causes my program to no longer type check
11:42:50 <aristid> :t fix In
11:42:51 <lambdabot>     Couldn't match kind `(* -> *) -> *' against `* -> *'
11:42:51 <lambdabot>     When matching the kinds of `Mu :: (* -> *) -> *' and `f :: * -> *'
11:42:51 <lambdabot>       Expected type: f (Mu f)
11:42:52 <twanvl> maybe I need a new ghc
11:43:15 <aristid> :t fix (In .)
11:43:16 <lambdabot>     Couldn't match kind `(* -> *) -> *' against `* -> *'
11:43:16 <lambdabot>     When matching the kinds of `Mu :: (* -> *) -> *' and `f :: * -> *'
11:43:16 <lambdabot>       Expected type: f1 (f (Mu f))
11:43:37 <mzero> twanvl: I doubt that a new GHC would fix that
11:43:52 <twanvl> it really sounds like a bug to me
11:43:59 <twanvl> I have a program that works
11:44:11 <twanvl> and if I add {-# LANGUAGE GADTs #-}, it doesn't typecheck
11:48:16 <dmwit> twanvl: Doesn't GADTs change how let binding type inference works?
11:48:23 <dmwit> -XGADTs, that is
11:48:35 <twanvl> that could definately be the problem
11:49:01 <hpc> pattern matching adds type equality constraints
11:49:05 <hpc> with GADTs
11:49:41 <dmwit> twanvl: "the -XGADTs flag also sets -XRelaxedPolyRec"
11:49:47 <dmwit> from the GHC manual
11:50:42 <twanvl> that's not it, it works with RelaxedPolyRec
11:51:46 <twanvl> I have a program with Rank2Types (or actually, with PolymorphicComponents), the typechecker complains about escaping type variables when calling a local function. It will probably work if I add a type signature, but I don't want to have to.
11:52:18 <Saizan>  NoLocalMonoBinds or something like that
11:52:34 <hpc> Saizan: i think that's on by default
11:52:46 <hpc> and MonoLocalBinds is what you set to change it
11:52:50 <Saizan> hpc: GADTs reverses the default
11:52:56 <hpc> ah
11:58:06 <twanvl> it might just be my old ghc (7.0.4), I just installed the new haskell platform, let's see how that goes
11:58:21 <twanvl> okay, now it complains even before typechecking :)
12:00:38 <Saizan> it's NoMonoLocalBinds btw
12:01:25 <twanvl> Saizan: thanks, that does the trick
12:01:31 <twanvl> but what does it have to do with GADTs?
12:02:27 <arnsholt> twanvl: Completely unrelated to what you're actually talking about: You the same twan as wrote a blogpost about OCR in Haskell that ended up on HN a while (half a year, year?) back?
12:02:43 <Saizan> twanvl: with the new typechecker they figured that typing problems in the presence of gadts pattern matching would get easier if local definitions would be monomorphic
12:02:59 * hackagebot cabal2nix 1.33 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.33 (PeterSimons)
12:03:01 * hackagebot pandoc 1.9.4 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.9.4 (JohnMacFarlane)
12:03:27 <twanvl> Saizan: but why can you then still disable MonoLocalBinds? And does doing that mess with the type checker?
12:03:54 <twanvl> arnsholt: I did write something about finding rectangles for the purpose of OCR, yes
12:05:47 <arnsholt> Yeah, that's the one. Could I possibly pick your brains about OCR a bit?
12:06:29 <Saizan> twanvl: it can cope with it, apparently
12:06:31 <pooya72> Does the HDBC-postgres package support returns? As in " "INSERT INTO todos (item, priority) VALUES (?, ?) RETURNING item;"
12:06:39 <twanvl> arnsholt: sure
12:06:54 <Saizan> twanvl: i guess in some cases you get type errors you wouldn't get otherwise
12:07:53 <arnsholt> I've got a bit of an interest in some things that touch on what you did in your thesis (NLP and classical languages, specifically), but I know essentially nothing about OCR and such
12:08:58 <arnsholt> What I'm wondering is, on a scale from complete insanity to mere madness, how feasible do you think it would be to try to OCR manuscripts of medieval or classical texts?
12:09:55 <twanvl> arnsholt: depends on whether it is hand written or printed, the former is very difficult, the latter is doable but tricky
12:10:06 <JoeyA> pooya72: I don't see why it wouldn't.  It acts just like a SELECT query as far as reading the return value.
12:10:10 <arnsholt> From what I gathered from skimming your thesis, the text you worked on was a printed text, so going to handwriting would change things a lot
12:10:19 <ezyang> thanks faze
12:10:24 <ezyang> Torment will probably suck.
12:10:31 <pooya72> JoeyA: that's what I thought. But all it gives back is the number of rows that have been updated
12:10:54 <JoeyA> pooya72: Hmm...
12:11:06 <pooya72> JoeyA: I'm just using the standard methods on RWH http://book.realworldhaskell.org/read/using-databases.html
12:11:10 <JoeyA> pooya72: Not really an answer to your question as asked, but why not use postgresql-simple instead?
12:11:18 <JoeyA> It's newer and shinier, at least.
12:11:22 <arnsholt> twanvl: Yeah, I'd be thinking about handwritten texts. Any good literature to get an overview of the field?
12:11:36 <pooya72> JoeyA: is that better? lol, I just used HDBC-postgres cause of RWH
12:12:59 <arnsholt> I'm in NLP, sp I'm reasonably conversant in the statistical shenanigans involved I think, but I've never actually worked with the image part of things
12:13:00 <JoeyA> pooya72: I'd say so.  It has better type support (automatically converts values to/from SQL representation), and more closely fits PostgreSQL's idea of a result set.
12:13:55 <pooya72> JoeyA: i c, any good documentation? the hackage and github sites don't have any info http://hackage.haskell.org/package/postgresql-simple
12:14:18 <JoeyA> http://hackage.haskell.org/packages/archive/postgresql-simple/0.1.3/doc/html/Database-PostgreSQL-Simple.html doesn't look very scant to me.
12:15:43 <JoeyA> pooya72: But to answer your question: for HDBC, I think you need to call fetchRow to get the returned value, like you would for a select query.  Did you try that?
12:15:51 <twanvl> arnsholt: as far as I know, the state of the art for some forms of handwriting, especially cursive, is to recognize whole words instead of attempting to segment out individual letters. But it has been a while since I worked on this topic
12:16:07 <pooya72> JoeyA: haha, how did find that documentation! very nice.
12:16:10 <JoeyA> execute :: Statement -> [SqlValue] -> IO Integer returns the number of rows modified.
12:16:16 <JoeyA> pooya72: I clicked the link ;-)
12:16:33 <pooya72> JoeyA: yeah I can't find docs on hackage
12:16:35 <pooya72> lol!
12:16:37 <JoeyA> Under Modules
12:16:44 <strager> Is there a JSON parser (like aeson) which is a monad transformer?
12:16:58 <JoeyA> Yes, many Haskell modules are surprisingly well-documented ;-)
12:17:32 <pooya72> JoeyA: so seriously, from here: http://hackage.haskell.org/package/postgresql-simple were did you click?
12:17:43 <pooya72> can't believe I'm asking this...
12:17:43 <JoeyA> strager: What part of parsing are you interested in?  Converting text to JSON values, or converting raw JSON values (objects/arrays/numbers/strings/bool/null) to values?
12:17:51 <arnsholt> twanvl: Interesting. Makes sense, I suppose (and closer to how people usually read, interestingly), although it does make the machine learning part of things more complicated
12:17:57 <JoeyA> pooya72: Under modules, Database.PostgreSQL.Simple
12:18:08 <pooya72> ahh....
12:18:17 <arnsholt> But AFAIK, most medieval manuscripts aren't cursive though (thankfully), although they're hard enough to read without being cursive
12:18:36 <pooya72> JoeyA: so you recommend postgres-simple or persistent from yesod?
12:18:50 <pooya72> JoeyA: plan on using yesod in the long run...
12:18:52 <JoeyA> pooya72: persistent uses postgresql-simple
12:19:13 <pooya72> JoeyA: ok.. cool
12:19:22 <JoeyA> So I'd recommend trying persistent first.
12:19:45 <JoeyA> pooya72: Have you created your database schema yet?
12:19:53 <pooya72> JoeyA: yeah
12:20:03 <pooya72> JoeyA: but it's nothing big, just a todo list
12:20:04 <strager> JoeyA: The latter; FromJSON typeclass in aeson.
12:20:07 <JoeyA> I've never used persistent, but I'd like to know how well it deals with existing databases.
12:20:26 <pooya72> JoeyA: ok, I'll let you know how bad I f*ed everything up
12:20:59 <JoeyA> strager: Ah.  At least that's the easy part, no?  ;-)
12:21:11 <pooya72> gotta run...
12:21:13 <JoeyA> (if you already have support code from Aeson)
12:23:20 <bokuk> can i have a question ?
12:23:20 <strager> I have my parser, and I have a postprocessor which runs after the parser.
12:23:25 <strager> bokuk: Yes.
12:23:35 <bokuk> haskell is difficult to optimization ?
12:23:51 <strager> The parser inserts undefines in a bunch of places, and the postprocessor fills in the gaps.  (The postprocessor is monadic.)
12:23:57 <strager> *undefineds
12:24:11 <strager> bokuk: Yes and no.  Some optimizations are easy; some are hard.
12:24:43 <bokuk> thanks ~
12:24:51 <strager> Haskell poses problems optimizing away memory management, but it's great at allowing things like stream fusion.
12:25:43 <bokuk> hmm..
12:26:01 <bokuk> it is difficult to write a game than ocaml ?
12:26:11 <JoeyA> strager: So I guess the crux of your problem is that the parseJSON method can't be contextualized all by itself, making parsing of child types less convenient?
12:26:26 <hpc> bokuk: yes, tautologically; it's difficult to write games :D
12:27:20 <JoeyA> Well, it's easy to write simple games, no?  ;-)
12:27:23 <roconnor_> bokuk: http://shinytoys.org/blog/today-i-created-death
12:27:25 <strager> JoeyA: No, that isn't the problem.  I'd like to get access to my (stateful) monad within the parser, but I can't.
12:27:46 <strager> (I understand there are complications with backtracking, but I'm fine with that; it doesn't pose a problem in my case.)
12:29:08 <JoeyA> roconnor_: How is that running in the browser?
12:29:55 <strager> <img>'s everywhere
12:30:03 <strager> All game logic on the server
12:30:20 <strager> (Just looked at the dev tools for a few seconds; I may be wrong)
12:30:28 <JoeyA> oh
12:31:06 <bokuk> hpc : is it easy to write a game in ocaml than haskell?
12:31:51 <hpc> no clue
12:32:26 <Adeon> that might depend on what technologies you'd base the game on and how easy it would be to bind/use them in ocaml and haskell
12:32:31 <bjorkintosh> bokuk, games span numerous genres.
12:32:32 <bokuk> i don't understand that word "no clue"  : i am not good to speak english.
12:32:36 <bjorkintosh> what are you interested in writing?
12:32:44 <bjorkintosh> bokuk, what do you speak? it means "no idea".
12:33:01 * hackagebot cereal-conduit 0.5 - Turn Data.Serialize Gets and Puts into Sources, Sinks, and Conduits  http://hackage.haskell.org/package/cereal-conduit-0.5 (MylesMaxfield)
12:33:15 <bokuk> i am sorry my poor englsih. i want to write a shooting game.
12:33:24 <bjorkintosh> bokuk, do it in c++!
12:33:31 <bokuk> no.
12:33:36 <bjorkintosh> why not?
12:33:39 <Adeon> 3D shooting game?
12:33:41 <bokuk> i am good to write in c++
12:33:41 <strager> Write it in C#!  JavaScript!  Python!  Java!
12:33:53 <bokuk> but, i don't like c++
12:34:00 <strager> Unity3D!  LOVE2D!  Something better suited for games.
12:34:11 <mietek> http://hackage.haskell.org/packages/archive/pipes-zlib/0.0.1/doc/html/src/Control-Pipe-Zlib.html#decompress
12:34:19 <strager> If you want to learn Haskell, you should probably write something Haskell's relatively good at.
12:34:20 <bokuk> no. i want to write a game in ocaml or haskell!!
12:34:25 <mietek> Why (lift . liftIO) ?
12:34:28 <bokuk> :-)
12:34:36 <bjorkintosh> bokuk, good luck :)
12:34:46 <pcapriotti> mietek: no reason, I'll fix it :) thanks for noticing
12:34:57 <mietek> pcapriotti: oh cool, you're here.
12:35:07 <Adeon> nothing prevents you from writing games in haskell, it just lacks mature infrastructure and libraries for that kind of applications, (as far as I understand?)
12:35:49 <pcapriotti> mietek: actually, it's already fixed in master
12:35:57 <mietek> pcapriotti: I greatly appreciate your simple and practical examples in pipes-extra
12:36:20 <mietek> pcapriotti: I'm currently comparing zlib-enum, zlib-conduit and pipes-zlib
12:36:21 <Adeon> isn't there at least one first person shooter written in haskell
12:36:24 <dzhus> my program stops with ¬´pgm-name: <<loop>>¬ª message on stdout, can wrong unbox instances (for vector package) cause this?
12:36:38 <shysoft> How do you convert a 'IO [Float]' to a '[Float]'? I.e., how do you remove the 'IO'?
12:36:52 <luca> you don't
12:37:10 <c_wraith> shysoft: you don't. an IO type means "this does IO".  you can't take that away.
12:37:10 <mietek> pcapriotti: do you know if there's a practical example of pipes-2.0 usage yet?  I don't fully understand what are the benefits of pipes-2.0 vs pipes-core
12:37:17 <shysoft> How do I use a 'IO [Float]' In a method expecting a 'Float'?
12:37:43 <c_wraith> depends on the types.
12:37:51 <shysoft> *'Expecting a [Float]'
12:37:51 <pcapriotti> mietek: I don't know... I haven't actually spent much time with pipes 2.0 yet, to be honest
12:37:59 <c_wraith> shysoft: but (>>=) is the basic building block
12:38:02 * hackagebot digestive-functors-snap 0.3.2.1 - Snap backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-snap-0.3.2.1 (JasperVanDerJeugt)
12:38:45 <c_wraith> shysoft: (>>=) has the type IO a -> (a -> IO b) -> IO b
12:39:06 <c_wraith> shysoft: which lets you use an IO a as if it was an a, so long as the resulting action is also an IO value
12:39:21 <strager> shysoft: Use >>= or 'do' notation.  If you show the context of your problem in code, we can help you squeeze it in where you need it.
12:39:21 <mietek> shysoft: [Float] is a list of floats; Float is a single float
12:39:27 <c_wraith> shysoft: do-notation desugars to use of (>>=), also
12:39:35 <Nimatek> shysoft: http://learnyouahaskell.com/input-and-output
12:41:04 <JoeyA> > let f (all . isSpace -> True) = "It's white"; f (all . isAlpha -> True) = "It's letters"; f _ = "It's neither" in ["  \t", "abc", "123"]
12:41:05 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
12:41:06 <lambdabot>         against inferred ...
12:41:22 <JoeyA> > let f (all isSpace -> True) = "It's white"; f (all isAlpha -> True) = "It's letters"; f _ = "It's neither" in ["  \t", "abc", "123"]
12:41:23 <lambdabot>   ["  \t","abc","123"]
12:41:49 <JoeyA> Note to self: don't run untested expressions in IRC.
12:42:21 <strager> I like how you just ignore 'f'.  =]
12:42:34 <JoeyA> > let f (all isSpace -> True) = "It's white"; f (all isAlpha -> True) = "It's letters"; f _ = "It's neither" in map f ["  \t", "abc", "123"]
12:42:35 <lambdabot>   ["It's white","It's letters","It's neither"]
12:42:48 <strager> Are those view patterns?
12:42:51 <JoeyA> My point is, I <3 view patterns.
12:42:56 <strager> Why not use guards?
12:42:57 <mauke> JoeyA: f ""
12:43:35 <JoeyA> strager: Well, in my particular usage, I'm using view patterns to match results of something else, too.
12:44:07 <strager> Guards + case?  =D
12:44:23 <JoeyA> Something like: f (all isSpace -> True) = Blank; f (parseExpression -> Left err) = SyntaxError err; f (parseExpression -> Right (Literal v)) = ...
12:44:45 <mauke> the first one is better written as f s | all isSpace s = Blank; IMHO
12:44:47 <strager> mm, will that call parseExpression twice?
12:45:01 <JoeyA> strager: I don't think so.
12:45:06 <mauke> I think so
12:45:22 <JoeyA> I tried it in GHCi with an unsafePerformIO computation.
12:46:10 <mauke> f s | all isSpace s = Blank | otherwise = case parseExpression s of Left err -> ...
12:46:13 <mauke> looks better to me
12:46:29 <strager> Same here.
12:46:33 <tuxit> any emacs users here, I can't import any package
12:46:43 <tuxit> or module
12:46:50 <tuxit> import IO does not work for me
12:47:06 <geekosaur> you have ghc 7.4.1, right?
12:47:11 <JoeyA> let f (seq (unsafePerformIO launchMissiles) -> 3) = "three"; f (seq (unsafePerformIO launchMissiles) -> 4) = "four"; f (seq (unsafePerformIO launchMissiles) -> _) = "something else"
12:47:22 <tuxit> yes
12:47:26 <JoeyA> Here, it launches the missiles only once when I pass f 3, 4, or 5.
12:47:30 <geekosaur> either set haskell98 mode or learn to use module names that aren't from 1998
12:47:52 <tuxit> oooh so my tutorial is old then ;-)
12:47:57 <strager> Indeed.
12:47:59 <geekosaur> (IO has been System.IO for years)
12:48:00 <strager> System.IO
12:48:34 <geekosaur> and if there are tutorials out there stull using the old names, let us know what they are so we can get them updated or something
12:49:02 <tuxit> this works
12:49:04 <tuxit> awesome
12:49:13 <shysoft> I'm trying to write a method called 'pointify' and I'm getting a compilation error on the base case: http://pastebin.com/PqiZNXwF    What's wrong?
12:49:18 <tuxit> geekosaur, I don't know where to begin, most of them
12:49:19 <mauke> The paste PqiZNXwF has been copied to http://hpaste.org/69468
12:49:20 <tuxit> sorry
12:49:31 <mauke> tuxit: most of what?
12:49:39 <tuxit> tutorials
12:49:41 <mauke> shysoft: IO
12:49:46 <mauke> tuxit: what tutorials?
12:50:00 <geekosaur> still, would be nice to know which one you are using so it can be updated to either set haskell98 mode or use modern names...
12:50:08 <tuxit> yet another haskell tutorial
12:50:20 <strager> shysoft: You want 'return'
12:50:22 <tuxit> I have a book from o'reilly
12:50:24 <mekeor> shysoft: pointify x = do list <- x; case x of [] -> [];
12:50:28 <strager> You want to lift [] into the IO monad
12:50:33 <tuxit> might be wrong too
12:50:47 <mekeor> oh, also, you can't do a function with IO a -> a
12:50:57 <strager> Wait no, I'm wrong shysoft
12:51:00 <strager> Mistread that type signature
12:51:02 <Nimatek> Except for the function that must not be named.
12:51:02 <strager> Misread*
12:51:17 <roconnor_> shysoft: having parameters of type IO Foo is usually wrong; just use Foo instead.
12:51:20 <strager> shysoft: mekeor is right.  You need IO a -> IO b.
12:51:29 <strager> or what roconnor_ said.
12:51:35 * strager isn't helping the discussion.
12:52:00 <roconnor_> shysoft: parameters of type IO Foo are used for callbacks
12:52:04 <hpaste> mekeor annotated ‚Äúpastebin.com/PqiZNXwF‚Äù with ‚Äúpastebin.com/PqiZNXwF (annotation)‚Äù at http://hpaste.org/69468#a69469
12:52:13 <mekeor> shysoft: ‚Üë
12:52:29 <mauke> mekeor: why all the IO?
12:52:30 <tuxit> ooh well this helped a lot
12:52:35 <tuxit> thx
12:53:04 <hpaste> mekeor annotated ‚Äúpastebin.com/PqiZNXwF‚Äù with ‚Äúpastebin.com/PqiZNXwF (annotation) (annotation)‚Äù at http://hpaste.org/69468#a69470
12:53:22 <mekeor> mauke: i'm not sure what he wants‚Ä¶
12:53:28 <mauke> so why IO?
12:53:47 <barrucadu> I think the best type would be [Float] -> [(GLfloat, GLfloat, GLfloat)]
12:54:08 <mekeor> mauke: i assume the type is :: IO x -> IO y
12:54:30 <mekeor> barrucadu: maybe, yes.
12:54:34 <mauke> mekeor: why?
12:54:44 <barrucadu> And then, in the function which does the IO, fmap pointify
12:54:51 <mekeor> mauke: because he wrote IO x -> y in his original post.
12:54:59 <mauke> yes, which makes no sense
12:55:03 <mekeor> yes.
12:55:06 <mauke> and doesn't match the actual code they wrote
12:55:17 <mekeor> idk what he wants‚Ä¶ so‚Ä¶
12:55:30 <strager> He wants unsafePerformIO, of course!
12:55:38 <mekeor> =)
12:57:45 <hpaste> Nimatek pasted ‚Äúfor shysoft‚Äù at http://hpaste.org/69471
12:59:31 <shysoft> How do you convert a 'Float' to a 'GLfloat'?
12:59:52 <mekeor> unsafeCoerce
13:00:18 <twanvl> realToFrac
13:01:09 <hpc> id?
13:01:13 <hpc> i think it's a type alias
13:01:16 <ion> instance Extend IO where { duplicate a = do a; return a }; instance Comonad IO where { extract = unsafePerformIO }
13:02:55 <bitonic> ion: nice.
13:03:24 <parcs`> :t join (<$)
13:03:25 <lambdabot> forall (f :: * -> *) b. (Functor f) => f b -> f (f b)
13:03:29 <hpc> i think any monad can be an extend?
13:03:57 <parcs`> more like any functor :D
13:04:10 <bitonic> hpc: each Functor
13:04:16 <bitonic> damn
13:04:18 <shysoft> I'm attempting to invoke 'pointify :: [Float] -> [(GLfloat, GLfloat, GLfloat)]' with an argument of type 'IO [Float]' and I'm getting a compilation error. How do I fix this?
13:04:20 <parcs`> hah!
13:04:30 <parcs`> shysoft: LYAH
13:04:41 <barrucadu> @where LYAH
13:04:41 <lambdabot> http://www.learnyouahaskell.com/
13:04:47 <Nimatek> shysoft: 21:57 <hpaste> Nimatek pasted ‚Äúfor shysoft‚Äù at http://hpaste.org/69471
13:04:54 <stickyboot_irssi> What are some well known dekstop applications written in haskell?
13:05:04 <parcs`> there aren't many
13:05:06 <ion> Xmonad
13:05:10 <bitonic> stickyboot_irssi: XMonad, the ledger thing
13:05:12 <parcs`> threadscope
13:05:15 <hpc> darcs?
13:05:22 <mauke> hpc: not very desktop
13:05:43 <stickyboot_irssi> things more along the line of a traditional gui
13:05:55 <mauke> where's the manatee stuff?
13:05:59 <stickyboot_irssi> i know xmonad is a gui, but rather unconventional
13:06:07 <mauke> @where manatee
13:06:07 <lambdabot> I know nothing about manatee.
13:06:18 <barrucadu> Unconventional? There are lots of tiling window managers.
13:06:55 <mauke> http://www.flickr.com/photos/48809572@N02/
13:07:16 <bitonic> barrucadu: each of them unconventional
13:07:33 <stickyboot_irssi> by conventional i mean like gnome, windows, os x
13:07:44 <stickyboot_irssi> dektop apps that use that kind of interface
13:08:13 <stickyboot_irssi> something you would see your mom using
13:08:40 <taylorgb> I'm not sure mom could figure out gnome3
13:08:44 <taylorgb> Not sure I can
13:09:16 <Nimatek> Yeah, I put mom on Mint's Cinnamon, that seems to work.
13:09:34 <bitonic> stickyboot_irssi: windows, OS X? do you realize there are like 10 applications of that kind on the market? the answer would be "no" for each programming language except C and C++
13:10:03 <mietek> pcapriotti: I think using forP' in latest pipes-zlib makes things less readable.
13:10:16 <stickyboot_irssi> im sorru i wasnt clear, i meant that use that style of interface
13:11:59 <bitonic> stickyboot_irssi: GUI programming isn't that big in the Haskell community, but there are good bindings to gtk and wx
13:12:54 <mietek> Getting gtk bindings to build can be a challenge.
13:13:06 <stickyboot_irssi> Any well known examples of programs that use those with haskell?
13:13:10 <hpc> you have to install the buildtools first
13:13:24 <arnsholt> @hoogle (a -> [b]) -> [a] -> [b]
13:13:25 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
13:13:25 <lambdabot> Data.List concatMap :: (a -> [b]) -> [a] -> [b]
13:13:25 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
13:13:34 <mietek> hpc: https://gist.github.com/2420144
13:13:39 <bitonic> stickyboot_irssi: I think manatee might be a good example, but I've never used it
13:13:45 <stickyboot_irssi> ill check it out
13:13:46 <stickyboot_irssi> thanks
13:14:15 <mietek> hpc: and this actually didn't work until I checked out specific versions of the library dependencies with brew
13:14:27 <mietek> hpc: *and* I bet this is all wrong now with new Haskell Platform
13:14:28 <hpc> i have a gtk install with 7.4.1...
13:14:35 <hpc> pre-platform
13:14:41 <mietek> On OS X?
13:14:50 <hpc> oh, debian
13:14:51 <bitonic> me too, and it wasn't difficult to install it
13:15:02 <arnsholt> I could really get used to this searching by parameter signature thing
13:15:04 <mietek> It's difficult on OS X.
13:15:23 <adamt> arnsholt: Yeah it's pretty cool.
13:16:08 <strager> If I change module Foo and Bar depends on Foo, GHC seems to recompile Bar (90% of the time).  Can I make GHC do that less?  I remember reading something about this, but I can't remember what options affected this behaviour.
13:16:14 <strager> (I just want faster build/iteration times)
13:16:25 <pcapriotti> mietek: yeah, I think you're right, I should probably inline it
13:17:13 <mietek> pcapriotti: I'm trying to rewrite it, so that I feel I understand every little bit
13:17:58 <arnsholt> adamt: Another thing I'm starting to like is whenever I get to the "now, what was it I -actually- wanted this function to do" (as opposed to whatever I wrote down as a first attempt), writing down the signature solves it in a lot of cases
13:18:02 <pcapriotti> mietek: cool! feel free to send in a pull request when you're done :)
13:18:17 <arnsholt> Programming with the type system instead of against it has its advantages, apparently
13:19:06 <limitlimit> hey guys, is there a way to alias a specific form of a type?
13:19:12 <limitlimit> if that makes sense
13:19:16 <adamt> arnsholt: It sure does. I'm still getting used to it all as well, and pretty often feel stupid for not figuring out what the types are going to be first. :)
13:19:30 <mietek> pcapriotti: I think you mentioned on reddit that you want to get rid of explicit discard calls... is that right?
13:19:31 <hpaste> limitlimit pasted ‚Äútype alias question‚Äù at http://hpaste.org/69473
13:19:47 <bitonic> I guess my question about conduit is: can I feed a Sink incrementally until it produces a result? it seems that all the functions are simply to connect Source to Sink and produce a result immediately, using the second argument of NeedInput when the Source doesn't have input anymore
13:20:23 <pcapriotti> mietek: well, yeah, I moved them there so that they won't appear in user code
13:20:42 <bitonic> I want to feed the Sink data as soon as I get it, without forcing a result
13:20:43 <mietek> pcapriotti: sorry, 'there'?
13:20:53 <pcapriotti> the problem there is that those pipes should be polymorphic in the return type, but unfortunately the types don't work out automatically unless you add a manual discard
13:20:58 <pcapriotti> there = in pipes-zlib
13:22:02 <pcapriotti> I *think* this is something that would be made cleaner by Chris' 5-th type parameter
13:23:01 <parcs`> strager: 90% of the time?
13:23:11 <parcs`> strager: it should recompile Bar 100% of the time
13:23:13 <strager> parcs`: Some changes don't cause that recompilation of Bar, I think
13:23:43 <strager> I haven't done scientific experiments, but that's what it feels like anyway.
13:25:22 <parcs`> strager: hmm, yeah. perhaps if the interface file doesn't change between recompilation of Foo then Bar won't get recompiled
13:25:36 <parcs`> recompilations*
13:28:50 <parcs`> actually the behavior seems more intricate than hat
13:28:51 <parcs`> that
13:29:01 <parcs`> cool, never noticed :)
13:30:37 <limitlimit> can anyone help with a basic type aliasing question?  http://hpaste.org/69473
13:32:05 <parcs`> limitlimit: Node is data constructor, not a type constructor
13:32:40 <strager> You can't do that limitlimit.  Capitals are reserved for type and value constructors.
13:32:44 <strager> s/value/data/
13:32:51 <limitlimit> parcs`: so is there some other construct analogous to "type" that I could use?
13:32:59 <strager> If you want consistency, make node = Node
13:33:07 <strager> limitlimit: You're using it.
13:33:21 <parcs`> limitlimit: what is wrong with 'leaf'?
13:33:53 <parcs`> and to answer your question no you can't have data constructor aliases
13:34:02 <limitlimit> parcs`: nothing in particular, I guess I was just wondering more generally
13:34:19 <limitlimit> ok, thanks all
13:35:50 <arnsholt> @pl \i -> psiAtPos crf (input !! i) i
13:35:50 <lambdabot> psiAtPos crf =<< (input !!)
13:36:51 <arnsholt> Doesn't look too bad. Yet I have no idea how that does what I think it should
13:37:05 <arnsholt> Time to read some more
13:37:58 <parcs`> f =<< g = \a -> f (g a) a
13:38:23 <parcs`> so psiAtPost crf =<< (input !!) = \a -> psiAtPos crf (input !! a) a
13:39:03 <arnsholt> Ah, right. It does exactly what I wanted, just couldn't make that out from the docs. Excellent
13:39:12 <arnsholt> Thanks for the explanation =)
13:39:33 * cizra dances around. I just wrote my first FFI hello-worldish thing.
13:40:27 <strager> I remove one 'traceShow' and a fifth of my project recompiles =[
13:41:51 <parcs`> strager: that doesn't happen for me
13:43:07 <strager> [master 2362667] Merge branch 'type-anal-1'
13:43:09 <strager> aww yeah!
13:43:28 <strager> Go go, CI monkeys!  Tell me my code sucks!
13:43:46 <parcs`> strager: are you compiling with optimizations?
13:43:59 <strager> lemme make sure I'm not
13:44:16 <monochrom> hrm, "traceShow" shouldn't give you compiler errors if you use it properly...
13:45:04 <strager> Why is -O in there...
13:45:19 <parcs`> if you compile with optimizations then definitions may want to get inlined and so more things would have to get recompiled
13:45:31 <monochrom> oh, you mean recompilation detection. yeah, that happens. optimizations implies inlining implies that modules aren't all that independent anymore
13:46:10 <strager> That was probably it parcs`.  I thought I had a debug build set (--disable-optimizations to cabal); apparently not.
13:46:53 <monochrom> in fact it escalates to the package level too. suppose package X depends on package Y depends on package Z. you think you just change Z. the result can be needing recompilation of both Y and X
13:47:15 <strager> That makes sense monochrom.  I can understand /why/ it does it.
13:47:30 <strager> I remember reading about an option to GHC which reduces the chance of recompilation, though.
13:47:39 <monochrom> (it is exactly why cabal-install decides to reinstall a whole lot of existing packages every so often)
13:47:40 <parcs`> is it possible to specifically disable inlining? compiling without any optimiztions would result in a really slow program
13:47:41 <strager> By 'chance' I mean 'the set of features' or whatever.
13:48:13 <monochrom> well, the thing is disabling inlining leads to practically disabling many optimizations
13:48:27 <mietek> pcapriotti: I'm annoyed with zlib-bindings. feedInflate, feedDeflate, finishDeflate return a Popper, but finishInflate doesn't.
13:48:28 <parcs`> yeah true.
13:48:53 <strager> Well, it'd be nice to disable inlining across module boundaries, but not package boundaries.
13:49:12 <strager> (so things like Prelude.map are inlined, but my own code isn't)
13:49:18 <monochrom> especially since typical haskell code uses so many abstractions and passing-functions-around. you don't notice this with C because you barely abstract anything
13:49:23 <Kooothor> hello
13:49:27 <mekeor> hi, Kooothor
13:49:47 <parcs`> strager: maybe -split-objs helps?
13:50:09 <Kooothor> I noticed the archlinux link on http://hackage.haskell.org/platform//linux.html is 404. Can someone replace it with this link please ? https://wiki.archlinux.org/index.php/Haskell_Package_Guidelines
13:50:32 <Kooothor> I couldn't find any contact on the webpage
13:50:44 <daniel_-> may i ask how long compile times you get with your LOC? (just curious)
13:51:01 <Kooothor> I'm hoping someone here nows who is in charge of web :)
13:51:05 <Kooothor> +k
13:51:11 <strager> parcs`: Maybe.  I'll try that for my next round of development.
13:51:24 <strager> daniel_-: I think compilation times are more affected by what features you use than the LOC
13:53:14 <strager> And if you have 30k LOC of generated typeclasses, compiling that one module may take a minute or two =]
13:53:26 <statusfailed> Is there an algorithm to assign "identity" (e.g., IP addresses), in which it's impossible to impersonate?
13:53:33 <statusfailed> impersonate an actor*
13:53:41 <strager> statusfailed: Identity as in human?
13:53:47 <statusfailed> strager: as in computers
13:53:50 <petrus_> Kooothor: funny you asked, I have just noticed that too while researching the state of haskell-platform on Arch
13:54:02 <strager> MAC address is good but you can MAC spoof
13:54:05 <parcs`> haskell-platform on arch doesn't exist
13:54:19 <statusfailed> strager: I mean something truly secure, where even a malicious user is unable to impersonate someone
13:54:29 <strager> You may take a hash of all the machine hardware.  Microsoft used to do this to check for licence piracy.
13:54:46 <petrus_> parcs, yes not anymore, I know as much
13:54:46 <Kooothor> I sent an email to allIcouldFind@haskell,org...
13:55:06 <statusfailed> This is part of a broader question really, which is essentially: Is it possible to build a distributed system which can tolerate byzantine failure in which identities can be spoofed
13:55:08 <parcs`> due to the nature of arch, many preferred to have an up-to-date ghc than a stable haskell platform
13:55:12 <statusfailed> Or is identity not an issue
13:55:42 <strager> statusfailed: From just that description, it doesn't seem like identity would be an issue.  Resources need to be secured; it doesn't matter who has a copy of that resource.
13:55:49 <strager> resource, workload, etc.
13:56:25 <statusfailed> strager: Hmm, that's a good point
13:56:33 <petrus_> parcs`: I know the history of this (more or less) however I have just asked on #arch-haskell
13:56:50 <petrus_> what is the situation (and/or future plan) with the haskell-platform on arch in the view of haskell-platform recent release?
13:57:17 <monochrom> IIRC you can fight byzantine-ness by assuming cryptographic hashing
13:57:56 <monochrom> unless your spoofing includes promising even that (by social engineering for example)
13:58:09 <bitonic> petrus_: the situation is that the only reliable way to keep up to date is to install the HP yourself, and that's what you should do imo.
13:58:10 <statusfailed> monochrom: do you mean like with public key cryptography?
13:58:12 <monochrom> err, s/promising/comprimisng/
13:58:22 <monochrom> yeah like that, or MD5 etc
13:58:34 <mikeplus64> petrus_: arch doesn't follow the HP
13:58:38 <monochrom> actually make it public-key digital signature
13:58:39 <bitonic> petrus_: the HP and the compiler
13:58:51 <cizra> Is it easily possible to return a return value out of a Haskell program?
13:58:52 <mikeplus64> petrus_: arch already has ghc 7.4.1 and cabal 0.14 though
13:58:57 <statusfailed> monochrom: Yeah, I was thinking on those lines with the identity issue, but I couldn't see how it would work
13:59:00 <mikeplus64> so you just use cabal to install what you want
13:59:20 <petrus_> bitonic: :-(, it looks like it
13:59:24 <bitonic> @google haskell exit value
13:59:26 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Exit.html
13:59:26 <lambdabot> Title: System.Exit
13:59:28 <bitonic> cizra: ^^^
13:59:39 <cizra> bitonic: Oh, EXIT value. I was googling for return value. Thanks!
14:00:08 <strager> C has ruined us all!
14:00:19 <tgeeky> anyone know what this is: 16:57 <tgeeky> @type uncurry3 (flip ((.) . (.) . (.)) . flip ((.) . (.)) . flip (.))
14:00:22 <tgeeky> 16:57 <lambdabot> forall b b1 a b2 (f :: * -> *). (Functor f) => (f a, b1 -> b, b2 -> b1) -> (a -> b2) -> f b
14:00:31 <bitonic> petrus_: but that's true for most programming environments. most package managers are simply not flexible enough
14:01:01 <bitonic> petrus_: and for non-rolling releases distro is true for all software!
14:01:11 <monochrom> oh, here is an extra point: if some majority of the participants are not compromised (like 3/4, depends on actual problem), then you can fight byzantine-ness. otherwise you are hacked.
14:01:56 <monochrom> so to sum up, you use cryptographic checks plus hoping that a suitable fraction is trustworthy
14:02:35 <petrus_> bitonic: but Arch should be different! ... OK a bit at least. the main reason (I guess) for abandoning HP on Arch was the lagging of ghc
14:03:07 <petrus_> but now ghc is in sync on HP
14:03:26 <mikeplus64> other way around
14:03:28 <bitonic> petrus_: arch can't keep up with hackage, you're going to have to make compromises.
14:03:29 <mikeplus64> the lagging of the HP
14:03:30 <Clint> petrus_: you should make a page like this for arch: http://people.debian.org/~nomeata/platform.html
14:03:34 <strager> monochrom: If you have at least one trusted authority, I think it can survive
14:03:46 <mikeplus64> petrus_: just use cabal to install what you want
14:03:50 <petrus_> mikeplus64: yes that what I meant
14:04:17 <bitonic> petrus_: I personally always advise to get the GHC binaries, HP and cabal; which is by far the most flexible solution
14:04:44 <monochrom> yes. the algorithms I learned replaced authority by majority
14:04:57 <bitonic> since you can easily have multiple GHC versions - I have everything from 6.12
14:05:17 <mikeplus64> petrus_: ghc obviously comes with the base libraries, if you want basically the HP you can do cabal install mtl-2.1.1 transformers-0.3.0.0 alex-3.0.1 and there are a few others that i forget
14:05:18 <strager> monochrom: Cool; where'd you learn?
14:05:47 <bitonic> mikeplus64: quite a few others
14:05:48 <monochrom> U of Toronto grad course. theoretical course on distributed computing
14:06:06 <mikeplus64> happy, hsc2hs too
14:06:12 <monochrom> was mind-opening and exciting, yeah :)
14:06:18 <mikeplus64> and haddock!
14:06:22 <Clint> alex
14:06:29 <Clint> oh
14:06:31 * Clint is illiterate
14:06:33 <monochrom> the proofs are tricky and torturous, mind you :)
14:06:42 <mikeplus64> petrus_: here you go: http://hackage.haskell.org/platform/changelog.html
14:08:41 <petrus_> guys, I can get HP and whatever haskell stuff I need on Arch in one way or in another
14:09:04 <petrus_> that was not my point or question
14:11:50 <petrus_> it seems unfortunate that arch abandoned HP, additionally the arch wiki pages do not reflect the current haskell situation correctly
14:12:20 <bitonic> petrus_: it was a deliberate choice, they want the "bleeding edge". It's the wrong decision imo.
14:12:51 <mikeplus64> it abandoned it after months of an old ghc not compiling the packages they wanted to use
14:13:35 <petrus_> bitonic: yes I tracked down how it happened. I am not sure that the "sulotion" is good.
14:13:52 <petrus_> in that we agree
14:14:13 <statusfailed> monochrom: Sorry, just got back: that sounds really interesting, I don't suppose you could point me to any papers to get started?
14:14:14 <bitonic> petrus_: I personally think it's silly. the current version of haskell should be the HP, not the last GHC
14:14:35 <bitonic> I mean that was the idea when the HP was created
14:14:43 <statusfailed> monochrom: I'm more interested in majority consensus rather than trusted authority
14:14:45 <mikeplus64> bitonic: unfortunately many packages on hackage do not at all reflect that
14:14:47 <geekosaur> or the latest ubuntu, which cobbled together its own 7.4.1-based HP (is it anything close to the real one, or did they just forward-port the old one?)
14:14:47 <bitonic> and the packages that don't compile with
14:15:15 <bitonic> mikeplus64: not many. it's mainly experimental packages (i'm thinking of REPA now)
14:15:33 <petrus_> regardless, the wiki should give a correct view what is the correct situation and it does not do that.
14:15:40 <mikeplus64> yeah
14:16:03 <petrus_> there are discrepancies
14:16:23 <bitonic> but I really don't get the philosophy "last version at all costs". I mean a distro shouldn't do that imho.
14:16:34 <tuxit> I am four to five days studying haskell now, and so far the experience is humbling me
14:17:03 <tuxit> this language is so alien to anything I am used to
14:17:05 <bitonic> tuxit: yes.
14:17:08 <statusfailed> tuxit: haha, I know that feeling :D
14:17:25 <tuxit> not meant as a criticism
14:17:30 <mauke> "I know that feel, bro"
14:17:39 <tuxit> I have my very reasons to pick up haskell
14:17:52 <parcs`> petrus_: i feel that the decision arch made wrt to haskell is well-aligned with the philosophy of arch
14:17:56 <mikeplus64> bitonic: why not, really, in hindsight for me at least it has been very convenient
14:18:11 <parcs`> if you do not agree with the choice arch made then you do not agree with arch
14:18:37 <bitonic> mikeplus64: for me it wasn't, when I tried arch/gentoo. most of the time you want the bleeding edge only in a few cases
14:18:42 <parcs`> "the arch way"*
14:18:48 <bitonic> but I don't like it as a default
14:19:01 <mikeplus64> bitonic: it's not "bleeding edge" as such, it's just the latest stable upstream
14:19:28 <bitonic> mikeplus64: the latest stable for haskell is the HP, and GHC's website warns you
14:19:38 <parcs`> petrus_: were you using arch around the time ghc 7 was released?
14:19:51 <petrus_> parcs`:  yes and no, things change, see my initial humble question
14:20:09 <parcs`> during that time arch was still packaging the haskell platform, and it took 6 months for the HP to ship ghc 7
14:20:16 <parcs`> meaning it took 6 months for arch to get ghc
14:20:24 <parcs`> 7. many people did not like that
14:20:28 <petrus_> parcs`:  yes, I know, was there
14:20:43 <mikeplus64> bitonic: well, the version of ghc that /would/ be included in the HP
14:20:56 <bitonic> mikeplus64: yeah but that's not what arch is doing
14:20:57 <mikeplus64> ie. right now arch does pretty much have a minimalistic HP
14:21:07 <parcs`> petrus_: what is your initial question again?
14:21:21 <bitonic> mikeplus64: they always have the last GHC, they had 7.4 before it made in the HP (today)
14:21:43 <mikeplus64> bitonic: exactly, and 7.4 was the version to be included in the HP
14:22:05 <bitonic> mikeplus64: "to be"
14:22:17 <bitonic> mikeplus64: it wasn't out yet (the HP)
14:22:22 <petrus_> parcs`:  I was wondering what the archaskell group (may) plan with HP now that ghc HP in sync
14:22:54 <parcs`> petrus_: how long will that sync last?
14:22:58 <petrus_> parcs`: and asked it here since I got no answer from tem
14:23:13 <parcs`> i assume they are ignoring the HP
14:23:22 <petrus_> parcs`: good point
14:24:06 <petrus_> parcs`:  here is another thing to (re)consider
14:24:14 <parcs`> in a couple of days ghc 7.4.2 will be released, and the HP will be out of date again.
14:24:36 <bitonic> parcs`: nooo... the HP is *the* stable Haskell environment :(
14:24:54 <petrus_> parcs`: arch is known to have "very good" haskell environment, community etc
14:25:03 <bitonic> I mean that's why they did the HP in the first place
14:25:04 <parcs`> if you're looking for stability arch is the wrong choirce
14:26:02 <bitonic> parcs`: agreed. but the last HP is not out of date. it's the last GHC that's ahead :P
14:26:13 <parcs`> petrus_: i disagree that "arch is known to have a very good haskell environment." it is merely average
14:26:30 <petrus_> parcs`: the larger haskell community advises newcomers and in some way old timers too to goo with HP
14:28:21 <d-snp> > :t String
14:28:22 <lambdabot>   <no location info>: parse error on input `:'
14:28:28 <parcs`> petrus_: sure but this is not specific to ghc. _every_ programming language bundled in arch is the latest version, newcomer-friendly or not
14:28:30 <d-snp> :t String
14:28:31 <lambdabot> Not in scope: data constructor `String'
14:28:39 <d-snp> why is this? can't I get the type of types?
14:29:05 <geekosaur> String is a type synonym; and :t takes an expression, not a type
14:29:12 <luite> does arch also include lots of hackage packages?
14:29:16 <parcs`> no
14:29:20 <geekosaur> and lambdabot doesn't implement :info, more's the pity
14:29:33 <d-snp> geekosaur: and there are no expressions that return types?
14:29:42 <bitonic> parcs`: but what I'm arguing is that the last version of Haskell should be the HP
14:29:49 <parcs`> luite: in includes the HP and the packages that xmonad needs to recompile itself, i think
14:29:51 <geekosaur> d-snp, not /per se/
14:30:05 <bitonic> not the last version of GHC, which should be seen as a dev preview imo.
14:30:20 <luite> parcs`: hmm, that sounds sensible, although i gues it would make sense to hide the xmonad dependencies somehow
14:30:31 <geekosaur> there are some packages that let you produce TypeReps, but those are not types and can't be used as types
14:30:34 <bitonic> (and I think that's close to the intentions to the people that release the GHC/HP)
14:30:43 <petrus_> parcs`:  I won't argue about this (and that), it is beside my point
14:31:17 <barrucadu> bitonic: The latest version of Haskell is the Haskell Platform. However, the latest version of GHC isn't necessarily the version in the HP.
14:31:21 <geekosaur> generally if you want to do that kind of thing, you're either looking at ghc-lib or at template haskell
14:31:22 <barrucadu> Arch packages GHC, not the HP
14:31:44 <luite> yeah i agree, if you installed 7.4.1 just after release as a beginner, you were going to have a bad time
14:31:45 <shysoft> I'm getting an error saying 'could not find module Timer'
14:31:50 <barrucadu> And so, Arch's GHC package is often newer than the version of GHC in the HP
14:32:02 <bitonic> barrucadu: well, in other words I think it should package the HP, not GHC
14:32:19 <bitonic> (not necessarely in one package)
14:32:33 <parcs`> anyway i don't want to discuss this anymore because i don't use arch anymore :)
14:32:45 <parcs`> debian has a much sensible package system
14:32:47 <petrus_> parcs`:  so people come to arch for haskell and find HP is not here, the wiki is full of inconsistencies regarding haskell
14:32:51 <barrucadu> Fine, it could do that - but then its GHC package would be outdated
14:32:54 <Eduard_Munteanu> Eww :)
14:33:12 <bitonic> parcs`: I think it's relevant to the others because that philosophy hurts the Haskell environment
14:33:31 <petrus_> parcs`:  and that I think not good policy for arch
14:33:35 <Eduard_Munteanu> Well, I guess it's ok, but I can't stand it when Debian autostarts services and all that crap :)
14:33:37 <luite> barrucadu: i think more advanced users could install their ghc manually (if the package manager doesn't support multiple versions already)
14:33:46 <parcs`> petrus_: maybe arch is not as haskell-friendly as you say. also, the wiki is publicy-edited, so feel free to udpate it
14:34:18 <petrus_> parcs`:  not I am saying that is what the arch haskellers projecting
14:34:37 <barrucadu> luite: Yes, but if the HP was packages and not GHC, Arch would have an outdated version of GHC, which is not the Arch Way.
14:34:49 * barrucadu is undecided whether Arch should package GHC or the HP
14:34:51 <Nimatek> It's not especially haskell friendly, nor is it unfriendly.
14:34:52 <d-snp> can I write a function that returns a value of a certain class instead of a type?
14:35:11 <d-snp> like: (Int -> Show)
14:35:19 <d-snp> which returns anything that instances show?
14:35:24 <luite> barrucadu: is the arch way to package the latest version, even if it breaks everything for users?
14:35:28 <bitonic> d-snp: Show a => Int -> a
14:35:29 <Eduard_Munteanu> d-snp: Show a => Int -> a
14:35:33 <Eduard_Munteanu> Heh.
14:35:36 <bitonic> Eduard_Munteanu: zzzing
14:35:38 <Ralith> or he could use an existential type
14:35:42 <barrucadu> luite: The Arch Way is to package the latest stable version
14:35:57 <luite> barrucadu: even if that breaks everything for users?
14:36:00 <bitonic> Ralith: that's like using a flamethrower to light a cig
14:36:02 <Eduard_Munteanu> d-snp: since Show isn't a type
14:36:15 <Ralith> bitonic: assuming that the trivial example is what he actually wanted to do.
14:36:21 <Nimatek> I didn't notice the update breaking 'everything'. Don't remember if I had to tweak some stuff or not.
14:36:26 <parcs`> luite: there is more caution taken with the core packages, but pretty much yes
14:36:29 <Ralith> it is helpful to know that flamethrowers are available, at any rate
14:36:30 <luite> barrucadu: since that's more or less what happens for few months when a new "stable" ghc appears
14:36:37 <bitonic> Ralith: it's dangerous, too.
14:36:45 <luite> parcs`: that sounds like a bad idea to me...
14:36:50 <petrus_> parcs`:  I cannot edit the wiki on this, since I am not in the arch haskell circle enough. that why I asked them about it
14:37:00 <Ralith> bitonic: all the better :D
14:37:14 <barrucadu> luite: To give you an idea of Arch's packaging - /usr/bin/oython refers to python 3
14:37:20 <barrucadu> * /usr/bin/python
14:37:26 <luite> oython!
14:37:29 <bitonic> Ralith: expecially if you don't know how to use it :)
14:37:45 <Ralith> hard to learn how to use something without knowing it exists.
14:37:56 <luite> barrucadu: hehe guess i'll keep ubuntu then
14:38:04 <barrucadu> And so everything using Python 2 has to be patched to use /usr/bin/python2, despite very few things actually using Python 3 yet
14:38:21 <parcs`> petrus_: there is an arch-haskell mailing list where you can forward your concerns to the people in charge
14:38:40 <bitonic> Ralith: yeah but I wouldn't teach about existential types (which are often misunderstood and overused) to Haskell newcomers
14:38:53 <petrus_> parcs`:  I know that too - thanks
14:39:03 <Ralith> that is your decision!
14:39:23 <bitonic> Ralith: and, of course, the best one :)
14:39:28 <Ralith> of course.
14:39:36 <hpaste> d-snp pasted ‚Äúshow‚Äù at http://hpaste.org/69474
14:39:53 <d-snp> Eduard_Munteanu: this didn't work :P
14:39:54 <parcs`> Eduard_Munteanu: i don't like the service autostart thing either, but usually it saves me a step that i would have done anyway
14:39:56 <bitonic> Ralith: tbh, d-snp probably wants existential types
14:40:24 <bitonic> d-snp: yep, you want existential types.
14:40:43 <d-snp> I've always been the existential type
14:41:20 <Ralith> bitonic: that is why I brought them up :P
14:41:59 <bitonic> d-snp: you basically want `Int -> exists a. Show a => a', which means "I'm giving you an `a' which is showable, but you don't get to decide which `a' - I do"
14:42:39 <bitonic> d-snp: but in haskell you can't write it like that, you need to wrap the `a' in a datatype. chances are that you actually don't need an existential
14:43:41 <Eduard_Munteanu> parcs`: seems like a security risk to me, e.g. installing openssh when some accounts have weak passwords.
14:43:45 <d-snp> hm
14:44:01 <bitonic> d-snp: http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#existential-quantification the `forall' there should read as `exists'
14:44:07 <mietek> pcapriotti: are you still here?
14:44:23 <hpc> Eduard_Munteanu: you can get ssh to use a username whitelist, i think
14:44:34 <adamt> hpc: indeed you can
14:44:43 <adamt> it can also whitelist based on groups
14:44:46 <mietek> Is anyone familiar with zlib-bindings?
14:44:47 <Eduard_Munteanu> hpc: yeah, but Debian insists on starting services as soon as you install them :)
14:44:54 <bitonic> d-snp: but they didn't want to add another keyword :P. anyway, you're better off explaining what you want to do, because as I said you probably don't need an existential
14:45:31 <Eduard_Munteanu> Which is quite insane as a default.
14:46:06 <adamt> Eduard_Munteanu: Didn't debian (as a direct cause of that) have a period where you couldn't install two different webservers, since they would both listen on port 80 by default?
14:46:11 <bitonic> d-snp: in short, if you're a newcomer, you can happily leave they'll only confuse you :)
14:46:16 * bitonic has to go
14:46:30 <Eduard_Munteanu> adamt: heh, really?
14:46:48 <d-snp> bitonic: I have a function fromChunk, that is implemented by instances of Chunk, and it returns a specific Chunk instance
14:47:01 <d-snp> I know that all instances of chunk also derive show
14:47:09 <adamt> Eduard_Munteanu: I'm not sure on the details, but i remember having some issues getting both apache and lighttpd installed with apt-get. Ages ago. I still like debian, though. :)
14:47:19 <Peaker> frerich, hey, you there?
14:47:31 <Peaker> frerich, I'm curious about what kind of presentation you were making that you wanted to show Bottle in
14:47:31 <Eduard_Munteanu> Yeah, I'm using debian for some servers, dunno if there's anything better.
14:47:32 <d-snp> hmm
14:47:39 <bitonic> d-snp: I don't know what Chunk is. I have to run now anyway, I'm sure somebody else will help you
14:47:40 <luite> Eduard_Munteanu: ubuntu! :p
14:47:41 <d-snp> I'm not making sense
14:47:42 <parcs`> Eduard_Munteanu: true, but openssh-server is bundled separately.
14:47:43 <d-snp> ok cya :D
14:47:46 <bitonic> later!
14:47:58 <Eduard_Munteanu> parcs`: yeah, but you still get no chance to configure it :D
14:48:23 <adamt> Eduard_Munteanu: Gentoo :>
14:48:32 <Eduard_Munteanu> luite: the server flavor? Really, how ok is it? In my mind, Ubuntu doesn't have much of a reputation there.
14:48:49 <adamt> Eduard_Munteanu: Wikipedia is running on Ubuntu.
14:49:02 <adamt> So it is used on some *cough* smaller *cough* websites. :-)
14:49:06 <Eduard_Munteanu> adamt: don't tempt me, I kinda thought about it. After all, I run Gentoo on this machine.
14:49:18 <d-snp> isn't ubuntu just debian with some more edge?
14:49:36 <d-snp> doesn't sound very crazy to run ubuntu as a server os
14:49:38 <Eduard_Munteanu> But frankly, I do want effortless updates.
14:49:41 <parcs`> yeah. ubuntu tracks debian unstable
14:49:53 <luite> Eduard_Munteanu: for me it has worked fine so far, i started with ubuntu when debian stable was too old for what i needed on a server, so then installed ubuntu (latest), and then upgraded to ubuntu lts and kept it there
14:49:54 <Eduard_Munteanu> Stuff that won't break / require attention, that is.
14:50:14 <Eduard_Munteanu> (and Gentoo doesn't quite cut it there)
14:50:21 <adamt> Eduard_Munteanu: Yeah, Gentoo is def. too much maintenance for most people. So i run sabayon instead.
14:50:22 <luite> Eduard_Munteanu: worked fine so i've been using this approach for most of my servers now :)
14:50:47 <Eduard_Munteanu> luite: hm, plain Ubuntu LTS, or some server flavor?
14:50:47 <luite> but i don't really need very exotic things
14:51:05 <luite> Eduard_Munteanu: server flavour, but i think the only difference is the installer now
14:51:07 <luite> maybe kernel
14:51:17 <Eduard_Munteanu> I kinda need reasonably uptodate stuff.
14:51:26 <Luke1>  "No instance for (Read UTCTime)" ... how am I getting this error? I can clearly see Read UTCTime defined in Data.Time.Clock
14:51:30 <luite> i update to the regular ubuntu when i need something newere
14:52:00 <pcapriotti> mietek: yes
14:52:15 <Eduard_Munteanu> Anyway, I kinda settled with a CentOS machine for a central server somewhere.
14:52:35 <Eduard_Munteanu> Installing additional software kinda sucked.
14:52:52 * Eduard_Munteanu should probably update from 5 to 6
14:52:56 <mietek> pcapriotti: I don't get Poppers.  It seems from pipes-zlib that Poppers are multiple-use, as yieldPopper is recursive.  But it seems from zlib-bindings that Poppers are single-use.
14:52:56 <luite> centos might be a bit more secure by default
14:53:01 <mietek> pcapriotti: what am I missing?
14:53:02 <luite> with its selinux stuff
14:53:27 <Eduard_Munteanu> Yeah, Fedora et al. usually have the best SELinux support out there.
14:53:37 * adamt would like to mention scientific linux, as yet another RHEL fork, which didn't fall a year behind last year, unlike centos.
14:54:05 <Clint> minimalist selinux configs are kind of a joke
14:54:30 <pcapriotti> mietek: where do you see that it's single use?
14:54:43 <adamt> Doesn't most people get annoyed by selinux, and slack too much on the configuration to make things run?
14:54:53 <Eduard_Munteanu> Clint: like a minimal targeted policy? Yeah. Looking at Gentoo's stuff, it kinda breaks a lot.
14:55:03 <Clint> Eduard_Munteanu: doesn't protect you very much, and confuses people
14:55:28 <Eduard_Munteanu> I just want sandbox-X, though.
14:55:34 <mietek> pcapriotti: I'm looking at how a Popper is constructed, and it looks like it's done in zlib-bindings/Codec/Zlib.hs:205, :218, :219 -- the drain function
14:55:39 <Eduard_Munteanu> For my Gentoo desktop, but it's not ready :)
14:55:50 <Peaker> @tell frerich I'm curious about what kind of presentation you were making that you wanted to show Bottle in
14:55:50 <lambdabot> Consider it noted.
14:56:06 <mietek> pcapriotti: I don't see anything suggesting it's continuation-based
14:56:42 <mietek> But I may be missing something, as the code is a bit hairy
14:56:59 <pcapriotti> mietek: uhm, I haven't looked at the source, but I wouldn't see the point in returning a "Popper" if you can only pop once...
14:57:33 <mietek> pcapriotti: http://abstrusegoose.com/432
14:57:54 <mietek> ;)
14:57:55 <tgeeky_> @djinn ((a,b) -> b) -> ((a,a,a,a,a,a),b) -> b
14:57:55 <lambdabot> f a ((b, _, _, _, _, _), c) = a (b, c)
14:57:56 <pcapriotti> mietek: I don't think it's continuation based, I believe it uses mutable state
14:57:57 <tgeeky_> @djinn ((a,b) -> b) -> ((a,a,a,a,a,a,a),b) -> b
14:57:57 <lambdabot> f _ (_, a) = a
14:58:09 <tgeeky_> anyone know why djinn collapses the list of a's?
14:58:18 <tgeeky_> is it because of the 7-product standard?
14:58:28 <tgeeky_> err, standard practice of stopping at 7-tuples or whatever
14:58:41 <tgeeky_> @djinn ((a,b) -> b) -> ((a),b) -> b
14:58:42 <lambdabot> f a = a
14:58:44 <pcapriotti> mietek: is that while reading my code or Michael's? :)
14:59:19 <hpaste> d-snp pasted ‚Äúexistential type?‚Äù at http://hpaste.org/69476
14:59:31 <d-snp> so help, what's wrong with that code?
14:59:33 <hpc> tgeeky_: in this case i think you need to use the source, luke
14:59:46 <tgeeky_> hpc: ok
14:59:46 <mietek> pcapriotti: I think it might make sense to return a Popper that can only pop one or zero times.
14:59:55 <tgeeky_> hpc: lambdabot part of the djinn part, you guess?
14:59:58 <mietek> pcapriotti: either zlib is ready to give us another chunk, or not.
15:00:11 <hpc> djinn part
15:00:12 <mietek> pcapriotti: of course, the interface could make that more clear.
15:00:13 <Peaker> d-snp, what's the "ChunkType" class?
15:00:22 <pcapriotti> there can be multiple chunks
15:00:27 <Peaker> And what's Init?
15:00:33 <tgeeky_> hpc: shall I report back?
15:00:55 <hpc> if you feel like it ;)
15:01:10 <hpaste> d-snp annotated ‚Äúexistential type?‚Äù with ‚Äúchunktype class‚Äù at http://hpaste.org/69476#a69477
15:01:18 <d-snp> Peaker: :)
15:01:28 <Peaker> d-snp, what's Init?
15:01:51 <pcapriotti> mietek: I'm looking at the drain function, I still think that my original interpretation is correct
15:01:59 <Peaker> d-snp, fromTypedChunk (initChunkType) c <-- both of these params are wild-card patterns
15:02:06 <Peaker> d-snp, so only your first definition line matters
15:02:17 <hpaste> d-snp annotated ‚Äúexistential type?‚Äù with ‚ÄúInit‚Äù at http://hpaste.org/69476#a69478
15:02:20 <d-snp> Peaker: :)
15:02:25 <Peaker> d-snp, Init must be some concrete type, and that contradicts the type you implied: which is polymorphic to any "t" instance
15:02:36 <mietek> pcapriotti: ah, so the mutable state is kept on the C side...
15:02:45 <pcapriotti> mietek: yes, I think so
15:02:58 <d-snp> but Init is a ChunkType, so it's polymorphic to t right?
15:03:08 <Peaker> d-snp, Init is a single type, it's not polymorphic
15:03:26 <d-snp> :S
15:03:36 <Peaker> "fromTypedChunk :: ChunkType t => Word8 -> Chunk -> t" says: "fromTypedChunk returns whatever 't' type the caller wants".. but it actually returns Init specifically
15:03:51 <d-snp> oh
15:04:51 <Peaker> d-snp, maybe you mean to say (in pseudo-code):  fromTypedChunk :: exists t. ChunkType t => ...   which means "fromTypedChunk returns a value of some type 't', which is an instance of ChunkType, but you otherwise don't know anything about it" ?
15:04:57 <d-snp> could I have it return a ChunkType, or even a Show? regardless of what the caller wants? or is that impossible?
15:05:06 <d-snp> yes
15:05:09 <d-snp> that would be awesome
15:05:13 <Peaker> d-snp, you could -- but it's mostly an anti-pattern
15:05:23 <Peaker> d-snp, I can help you with that, and then explain a better way to do it :)
15:05:26 <d-snp> well it's just for showing, which is debugging
15:05:31 <Peaker> even then
15:05:45 <Peaker> ok, so Haskell doesn't really have "exists", only "forall"
15:05:53 <Peaker> but you can get the "exists" semantic with a little workaround
15:06:03 <d-snp> :D
15:06:30 <Peaker> basically you can do:   "data AnyChunkType = forall t. ChunkType t => AnyChunkType t"
15:07:03 <Peaker> d-snp, semantically, this means that the ChunkType constructor can take any "t" and build an AnyChunkType value. Whoever *extracts* from that constructor cannot depend on the type because anything could have been put in there.
15:07:12 <Peaker> d-snp, so the "forall" outside the constructor becomes an "exists" inside the constructor
15:07:35 <d-snp>     Perhaps you intended to use -XExistentialQuantification ?
15:07:43 <Peaker> yeah, you need that for this
15:07:45 <d-snp> :D
15:07:56 <Peaker> operationally, it just means that "AnyChunkType" contains the value alongside a dictionary (ChunkType) which is the only way to operate on it
15:08:08 <d-snp> is that something cabal packages are allowed to do?
15:08:31 <Peaker> d-snp, sure.. but as I said above, it's very rarely a good idea :)
15:08:38 <Peaker> (especially for cases such as this)
15:08:50 <Peaker> what you can do is stick a LANGUAGE pragma at the top of your file:
15:08:57 <Peaker> {-# LANGUAGE ExistentialQuantification #-}
15:09:40 <d-snp> that looks very professional :P
15:09:43 <Peaker> d-snp, anyway, when you find yourself using existential wrapper with type-class constriant, typically it means you should have used an explicit record of methods in place of the type-class in the first place
15:09:47 <absence> is anyone else having trouble building vec with the new haskell platform?
15:10:02 <d-snp> so, the way around it is a big case statement, inside the show definition I think
15:10:11 <Peaker> d-snp, read this: http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
15:11:27 <d-snp> haha, ofcourse I'm not there yet, because AnyChunkType doesn't derive show..
15:12:03 <Peaker> d-snp, why not have a (String, ) around your value for the debug show?
15:13:30 <d-snp> a (String, ) ? how would I populate that?
15:18:16 <Siod> what's the most complete functional reactive library?
15:18:31 <tgeeky_> hpc: can't find anything obvious, and it's not important enough :o
15:18:37 <Peaker> d-snp, just do the "show" preemptively
15:18:52 <Peaker> d-snp, instead of all these type-class constraints that let you do x,y,z,  just do x,y,z and store the results there instead
15:19:51 <nexion> is it possible to do something like: type MessageHandlerFunction a = MessageType b => b -> ByteString -> ClientSendChan -> a -> IO ()? I'd like to indicate that b is of class MessageType
15:19:58 <mietek> pcapriotti: thanks for helping me understand that.
15:20:07 <mietek> pcapriotti: a silly question: why do pipes need a return type?
15:20:23 <d-snp> Peaker: but I don't know the results in advance, I'll just give up on this for now
15:20:28 <d-snp> it's taking too much effort
15:20:30 <Peaker> d-snp, you do
15:20:33 <mietek> pcapriotti: I mean, a return value, separate from the output stream?
15:20:36 <Peaker> d-snp, otherwise, you wouldn't be able to write the instances
15:20:39 <pcapriotti> mietek: short answer: because they form a monad
15:20:52 <Peaker> d-snp, you don't need advanced type hackery for this.. you just need simple records
15:21:00 <pcapriotti> the return value allows all sorts of nice combinators to be written
15:21:10 <Peaker> nexion, type-class constraint inside a synonym like that may not work as you expect (I'm not sure)
15:21:15 <pcapriotti> mietek: take a look at Control.Pipe.Combinators, there are some interesting examples there
15:21:21 <Peaker> nexion, in any case, you're going to need to pass "b" as a param to that type synonym
15:21:43 <nexion> Peaker: ah, so put the constraint on the function and pass that in?
15:22:09 <mietek> pcapriotti: OK.  I started to wonder, because the discard (forever await) at the end of both decompress/compress seems like unreachable code.
15:22:20 <Peaker> nexion, Yeah
15:22:43 <nexion> Peaker: thanks :)
15:23:16 <pcapriotti> mietek: it's not unreachable, the first `await` will be reached, then it will be stuck there
15:23:35 <pcapriotti> mietek: it's basically equivalent to `await >> undefined`, but using discard is nicer
15:24:56 <mietek> pcapriotti: my reasoning was: if I'm writing a pipe like de/compress, and I have handled all the input using forP, why do I need to await any more input?
15:25:26 <mietek> I recognize the need to fix the types
15:25:31 <mietek> But it doesn't seem natural
15:27:03 <pcapriotti> mietek: that discard tells the type system that after compress has finished, there's nothing more to be done at that stage of the pipeline
15:27:54 <pcapriotti> you can add stuff after a forP (like, in fact, compress does) when you need to perform finalization
15:28:04 <pcapriotti> that discard specifies that there's no more finalization to be done
15:28:27 <mietek> pcapriotti: yes.  I think it would be nice if that was implied by the end of the do-block
15:28:48 <pcapriotti> mietek: no, that wouldn't be composable
15:28:58 <pcapriotti> iow, the monad laws would fail
15:29:43 <mietek> pcapriotti: is compress composable?
15:29:49 <mau> hello!
15:30:08 <pcapriotti> mietek: compress is a complete pipe that handles all its input
15:30:17 <pcapriotti> so you can't add anything after it
15:30:55 <pcapriotti> discard ensures that anything added after compose is ignored, and makes the pipe polymorphic as it should be
15:31:04 <mau> I have a question, I hope someone can help: I installed yi, but I cannot exit :-/
15:31:30 <mau> I tried to find some documentation, but I had no success
15:31:38 <pcapriotti> mietek: anyway, as I said, this can be made prettier using a fifth type parameter representing the upstream return value
15:32:26 <pcapriotti> mietek: see the discussion about it here: https://groups.google.com/forum/#!topic/streaming-haskell/FU6mUgaO5WM
15:33:07 <mietek> Thanks
15:40:37 <mekeor> how can i test whether a process is running? (which package/library/module can i use for that purpose?) (platform: linux.)
15:40:59 <sipa> ps ax ?
15:42:23 <mekeor> mekeor: google, hoogle and hayoo are your friends: System.Posix.Process.getProcessID
15:42:27 <mekeor> sipa: no
15:43:10 <sipa> you want the pid of the current process?
15:43:30 <RenJuan> mekeor every linux desktop has some equivalent of the Windows task manager
15:43:37 <RenJuan> or the Mac Activity monitor
15:43:38 <mekeor> no, i just noticed that function is not what i am looking for‚Ä¶
15:43:51 <mekeor> sipa: erm. ps ax is not what i want because it's for the shell, isn't it?
15:44:02 <mekeor> RenJuan: i want to do it within haskell.
15:44:06 <sipa> ah
15:44:11 <mekeor> yea =)
15:44:16 <mekeor> sorry, i was vague‚Ä¶
15:44:53 <RenJuan> thread level detail normally requires a debugger
15:45:18 <sipa> mekeor: i'm not sure what exactly you want either
15:45:31 <sipa> a list of running processes?
15:45:37 <RenJuan> like for ghci to show threading apparently
15:45:46 <sipa> (though i'll certainly not know how to do it within haskell)
15:45:54 <Clint> he wants to know if there's a process named _x_ in the process table
15:46:12 <RenJuan> but "within haskell"
15:47:28 <sipa> processes afaik do not have a name :)
15:47:57 <sipa> they have a command line, and they have an associated executable
15:48:16 <RenJuan> pid
15:49:11 <RenJuan> OSes don't care what you call a process generally
15:49:18 <mekeor> i want to test whether a process called "foo" is running at the moment. so sth like "f :: String -> IO Bool"
15:49:40 <sipa> define "named"
15:49:46 <mekeor> i defined it
15:50:04 <sipa> ok, define "called"
15:50:05 <mekeor> also, i didn't use that word :P
15:50:08 <mekeor> hehe
15:50:09 <mekeor> ok
15:50:16 <e98> how does uploading code to hackage work? is there any kind of authorization?
15:50:27 <mekeor> e98: nop
15:50:29 <RenJuan> very little apparently
15:50:44 <mekeor> e98: <RenJuan> very little apparently
15:50:49 <mekeor> =)
15:50:59 <mekeor> sipa: all processes have names, don't they?
15:51:12 <sipa> they have a command line, and they have an associated executable
15:51:17 <adamt> dejavu
15:51:18 <mau> hello to all, does anyone use yi editor?
15:51:37 <mekeor> mau ke
15:51:42 <Ke> yi seems to have a bit performance issues
15:51:51 <e98> mekeor: very little is? just some name, but no enforced permission?
15:51:53 <mekeor> mau ++ ke == mauke
15:52:08 <RenJuan> mekeor: no linux does not associate names with processes
15:52:15 <mau> the question is very stupid: I opened it and I do not know how to close it
15:52:21 <mekeor> e98: yes
15:52:25 <mau> discarding changes
15:52:43 <mekeor> mau: which mode? vi or emacs or ‚Ä¶?
15:52:49 <Ke> mau: it all depends on what keybindings you use
15:52:52 <mekeor> try :q and C-x C-c
15:52:58 <mau> first time I opened it, so the default
15:53:11 <Ke> it is possible to start yi so that you can't close it at all
15:53:30 <mekeor> mau: try typing ESACPE, then : then q then RETURN
15:53:39 <Ke> or :q!
15:53:45 <mau> no, vim commands do not work
15:53:57 <mekeor> mau: try Ctrl-x then Ctrl-c
15:53:58 <mau> it seems emacs mode, but
15:54:15 <mekeor> mau: type Ctrl-g first before that above
15:54:18 <mau> C-g do not work
15:54:24 <mekeor> mau: else, killall yi
15:54:47 <mekeor> RenJuan: how does htop/top/killall know the process-name then??
15:54:53 <mau> ll kill it... but is a fail :/
15:55:07 <sipa> mekeor: they match on the command-lline, i believe
15:55:07 <mau> *I'll
15:55:15 <RenJuan> mekeor, it doesn't it just shows the command line associated with the process
15:55:26 <sipa> mekeor: but a process can change its own command line
15:55:31 <RenJuan> which is not "the name" of the process
15:55:31 <mekeor> sipa: lline?
15:55:32 <Peaker> mau, yi has a config of whether to emulate emacs, vi, etc
15:55:35 <Peaker> mau, which is it?
15:56:00 <mau> It seems emacs to me
15:56:16 <mau> because C-x seems to work
15:56:18 <mekeor> sipa: okay, so i define "called" as "has the command-line"
15:56:36 <mau> but C-g no!
15:56:42 <mekeor> mau: C-x C-c -- where's the problem?
15:56:54 <mauke> mau: what did you expect C-g to do?
15:56:58 <mau> that it saves
15:57:03 <mauke> wat
15:57:19 <sipa> mekeor: one way is iterating through all /proc/<number/cmd file, matching those to what you want (the arguments are 0-byte separated), and return the <number> which had the matching file
15:57:20 <mekeor> mau: C-g aborts a command
15:57:26 <mekeor> mau: C-x C-s for saving
15:57:40 <mau> is it possible to exit disarding changes?
15:57:49 <mau> the fact is that I pressed keys at random
15:58:08 <mau> and I opened (do not ask me how :D) yi.hs
15:58:18 <mau> so now I am editing that file
15:58:25 <mau> so I do not want to save!
15:59:11 <mau> and afaik C-x C-s save
16:00:54 <mekeor> sipa: another way is‚Ä¶ ?
16:01:04 <RenJuan> commnd line/system load (some loads are created by system processes)
16:01:41 <mekeor> RenJuan: huh? please write complete sentences
16:02:21 <e98> mekeor: so anyone can upload files to hackage? no registration required?
16:02:53 <mau> ok, I had success! thank you!
16:03:13 <mekeor> mauke: can you please tell e98 how to upload to hackage?
16:03:20 <mau> let's go to learn haskell now
16:03:21 <mekeor> that sequence of commands, please
16:03:26 <mauke> why me?
16:03:32 <mekeor> you said it me, too.
16:03:37 <mauke> when?
16:03:41 <sipa> 3
16:03:41 <mekeor> yesterday, i think
16:03:42 <sipa> 2
16:03:43 <sipa> 1
16:03:47 <sipa> NOW
16:03:56 <mekeor> BOOM
16:04:29 <mauke> mekeor: I don't see it
16:04:39 <sipa> mekeor: another way is running ps ax in a child process and piping its output into your program (though ps does the same thing internally)
16:04:45 <mekeor> maybe the day earlier then.
16:04:51 <mauke> I don't think so
16:04:54 <sipa> mekeor: or finding some haskell package to do it
16:04:56 <sipa> :)
16:05:03 <mekeor> mauke: do it anyway.
16:05:17 <mekeor> sipa: yea, i asked you, #haskell, for that purpose.
16:05:26 <mekeor> =) :P :)
16:05:29 <mauke> mekeor: ... do you want me to copy/paste the instructions from hackage.haskell.org?
16:05:45 <mekeor> if necessary, yes.
16:06:04 <mauke> e98: is it necessary?
16:06:15 <mekeor> e98: oh foo.
16:06:22 <mekeor> e98: http://hackage.haskell.org/packages/hackage.html
16:06:31 <mekeor> e98: "You can check and upload your package using the Upload link above, though to upload packages you'll need a HackageDB username and password (see User accounts). "
16:06:41 <geekosaur> mekeor, the kernel's process userblock holds both a short name and a full command line; the short name is the thing that actually got run (which for a script will be the name of the interpreter, i.e. sh / python / perl) and a full command line (which can be changed on most Unixlikes by assignment), so neither is a sure match.  Linux utilities such as pidof try a bunch of things to try to identify a program, not always successfully (as, again, w
16:06:41 <geekosaur> ith scripts)
16:06:44 <mekeor> e98: please, please, please please: excuse me!
16:06:49 <mekeor> i'm very sorry.
16:08:01 <mekeor> e98: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program#Upload_your_package_to_Hackage
16:08:21 <mauke> mekeor: I grepped my logs for 'mauke.*hackage'. nothing.
16:08:56 <mekeor> hm
16:10:10 <mekeor> mauke: okay‚Ä¶ it was dmwit. sorry
16:10:42 <mekeor> on 12th june 2012: 16:37:56 <dmwit> rm dist/*.tar.gz && cabal sdist && cabal upload dist/*.tar.gz
16:10:54 <mekeor> no, on 1st hehehe
16:11:02 <mauke> this assumes you've told cabal your username and password
16:11:23 <mekeor> mauke: ah, ah. that's why i got confused‚Ä¶ ok
16:11:23 <mauke> which I haven't because I've always used the web interface
16:14:46 <e98> yeah
16:14:47 <Clint> it'll just prompt you for them
16:14:54 <e98> user/pass
16:15:04 <e98> used on web form or cabal upload
16:15:08 <e98> but that's all
16:15:14 <mekeor> e98: can you excuse my fault?
16:15:18 <e98> no ownership of?
16:15:46 <e98> e98: nohting to excuse, I'm sorry you feel you have to excuse. I give you permission to feel good :)
16:16:01 <mekeor> yay
16:16:17 <mekeor> e98: did you willingly address yourself?
16:16:21 <mekeor> that'd be awkward
16:16:43 <mekeor> s/willingly/deliberately/
16:17:26 <e98> mekeor: no
16:17:33 <mekeor> heh :)
16:18:23 * hackagebot semigroupoids 1.3.2.1 - Haskell 98 semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-1.3.2.1 (EdwardKmett)
16:46:57 <jfischoff> hell
16:46:58 <jfischoff> o
16:47:04 <mekeor> hell, oh!
16:47:20 <jfischoff> hell, no!
16:48:16 <mekeor> hell, yo!
16:50:44 <mgsloan> 'lo!
16:52:10 <Peaker> I love GHC's "did you mean"
16:52:21 <mekeor> Peaker: example?
16:52:24 <mgsloan> me too
16:52:45 <mekeor> mgsloan: example? i mean, when can i see this?
16:52:48 <mgsloan> I think it'd be cool to have a project to write something, perhaps as a GHC plugin, that extends the amount of help it gives you
16:52:50 <Peaker> mekeor, I write "filterChars . ..." and it says: "Not in scope: `filterChars' Perhaps you meant `E.filterChars' (imported from Graphics.UI.Bottle.EventMap)"
16:52:59 <mekeor> ah, cool
16:53:22 <mekeor> yea, saves lots of time.
16:54:31 <mgsloan> it would be great to extend "did you mean" with type information
16:54:52 <mgsloan> automatically place a hole at all of the things that're out of scope
16:56:57 <mgsloan> (then rank the "did you mean" possibilities by a combination of their name and type similarity)
16:57:19 <mgsloan> (perhaps even including "did you mean" possibilities that have no relevance to the name)
16:58:06 <RenJuan> sounds like a herculean labor done well
16:58:07 <Peaker> mgsloan, did you look at bottle?
16:58:27 <Peaker> We're aiming to make a good Haskell IDE and all the types inferred are available to you as you edit
16:58:31 <mgsloan> I looked at the code.  Looks very awesome!
16:58:46 <Peaker> mgsloan, how can you tell just from the code? :) Or you mean the code style or parts you reviewed?
16:58:57 <Peaker> Thanks, by the way :)
16:59:06 <mgsloan> I was working on a project to do that as well (been backburner'd for a while though), I'd love to pitch in
16:59:54 <Peaker> collaboration is kind of difficult, unfortunately, because it is so research-y, we don't really have large chunks of work to dispatch, and we usually work physically together, and spend most of our time discussing how stuff should be done and little of it implementing
17:00:03 <Peaker> run-on sentence, oops.
17:00:22 <RenJuan> "good" unlike leksah?
17:00:23 <Peaker> 80% talking about how to do stuff, 20% doing stuff
17:00:35 <mgsloan> Yeah, good code style!  I mostly was looking at codeedit, because that's the interesting part of it
17:00:40 <Peaker> mgsloan, btw, why didn't you run it?
17:01:02 <mgsloan> I wasn't sure if it would work :)  I post projects on github that don't yet work all the time
17:01:35 <Peaker> mgsloan, how did you hear about it?
17:01:52 <Peaker> (and it "works", that is, can be demo'd. It isn't usable for real projects yet)
17:02:02 <mgsloan> jfischoff mentioned it yesterday
17:02:11 <hpc> ooh, can you give your IDE support for agda-style holes?
17:02:22 <hpc> that'd be awesome in combination with GADTs / constraint kinds
17:02:32 <Peaker> hpc, what are agda-style holes?
17:02:38 <Peaker> hpc, I think our holes are probably agda-style holes
17:02:48 <Peaker> (But I'm not sure since I don't know what they are :) )
17:03:01 <hpc> foo :: [a] -> a
17:03:09 <hpc> foo (x:xs) = ?
17:03:25 <hpc> -- using the IDE, you can see that the hole :: a, and what you can fill it with
17:03:40 <hpc> and press a button, and it's occupied with x
17:04:02 <hpc> boring example, but it gets more interesting when the types start to reduce the number of things you can fill a hole with
17:04:18 <hpc> in agda, you can almost write a function definition from just types
17:04:59 <mgsloan> In a reddit comment yesterday I saw that we can already /kinda/ do holes.  If the top-level sig is inferrable, then we can comment it out, and introduce an implicit variable.  Then, ask for the type, and you get the type of your hole!
17:05:27 <hpc> hah
17:05:48 <mgsloan> Peaker: I want to make "type diagrams" which look like this http://www.mgsloan.com/mockup5.png  http://www.mgsloan.com/mockup6.png
17:07:06 <Peaker> hpc, yeah -- we have that :)
17:07:17 <Peaker> hpc, our hole knows its type (except our type inference/propagation/checking is very incomplete yet)
17:07:27 <Peaker> hpc, and we also don't use it yet to filter the possible results
17:07:29 <mgsloan> you're doing your own type inference?!
17:07:30 <Peaker> hpc, but will soon
17:07:38 <Peaker> mgsloan, yeah, we don't call ghc at all
17:07:49 <Peaker> mgsloan, we need the inference to work incrementally as you edit
17:07:50 <hpc> very cool
17:08:30 <hpc> in theory, you could compile with the GHC API and use that
17:08:41 <mgsloan> Well, that's totally opposite of the design philosophy of my project.  I absolutely pounded ghci with requests (turns out somewhat unnecessarily - full type error slicing is unnecessary - though potentially valuable)
17:08:43 <hpc> dunno if there's any way to persuade it into working incrementally
17:08:58 <mgsloan> I think that we can make it roughly incremental
17:09:27 <mgsloan> by loading additional modules that can reference top level identifiers that correspond to the unchanged parts of the code
17:09:58 <mgsloan> this would have the strength that ghc type system upgrades require much less work on the IDE side
17:10:10 <mgsloan> and you don't have to worry about making the two consistent in their behaviour
17:10:23 <Peaker> hpc, maybe, ghc integration will probably come later.. but we want to write our own inference/interpreter first to see where it leads us
17:10:45 <Peaker> hpc, we might not want to do Haskell particularly (we currently do part of SystemF), there are some annoying mis-features in Haskell (in our opinion)
17:11:31 <mgsloan> I'm just afraid that when you know type theory / etc, it can be very tempting to put that knowledge to put that knowledge to use, and succumb to NIN syndrome, chasing optimizations that aren't necessary for the tool to start being useful
17:11:45 <Peaker> mgsloan, I think the IDE needs to be smart about types anyway.. if the ghc api is completely structural maybe we could use that, but it's probably not incremental
17:11:59 <Peaker> mgsloan, it's not really an optimization, it's a simplification
17:12:09 <Peaker> the type inference we do have is <350 lines of code
17:12:19 <Peaker> ghcapi/ghci interaction would easily be more than that
17:12:37 <copumpkin> but you don't support all of the GHC type system features, right?
17:12:42 <Peaker> and there'd be quite a penalty to going to ghc and back, losing our metadata in the process
17:12:43 <mgsloan> hmm, perhaps!  many fewer places for problems to hide, though
17:12:45 <Peaker> copumpkin, right
17:12:54 <copumpkin> still cool
17:12:59 <copumpkin> is this project public anywhere?
17:13:08 <Peaker> mgsloan, we might not want to be Haskell at all eventually, and go full Agda
17:13:08 <mgsloan> Yeah, it's way cooler to do your stuff properly incrementally
17:13:18 <Peaker> It seems like Agda might actually be simpler to implement than Haskell in some ways
17:13:29 <mgsloan> Peaker: why?  I think a tool of this nature would be very useful
17:13:32 <copumpkin> you mean reimplementing its type system?
17:13:34 <mgsloan> is it a research project?
17:13:36 <copumpkin> or to integrate with it?
17:13:43 <copumpkin> it's designed to have interactive integration
17:13:45 <Peaker> copumpkin, the former, but we might be completely off :)
17:13:50 <copumpkin> oh, I wouldn't say that :)
17:14:11 <Peaker> copumpkin, what about Agda minus universes?
17:14:33 <copumpkin> there's a lot of complex behavior in agda
17:14:36 <Peaker> copumpkin, also we probably don't want the module system
17:15:03 <copumpkin> tracking positivity in data declarations and all the termination conditions and so on
17:15:06 <Peaker> copumpkin, or the overloaded constructor names (no need for name overloads, mostly)
17:15:15 <copumpkin> besides, agda has an actual API designed with interactive editors in mind
17:15:26 <Peaker> copumpkin, the termination conditions don't sound very complicated (structural recursion, guarded recursion?)
17:15:41 <copumpkin> they're pretty complicated :)
17:16:11 <Peaker> well, we'll have much to learn then :)  we're very NIH fellows
17:16:18 <copumpkin> fair enough
17:17:00 <Peaker> Is the Agda API a library with structural code input, or does it use text?
17:17:23 <mgsloan> I'm all for doing things correctly and interestingly., but... I just feel like there is such value in making this happen for Haskell.  I wouldn't have spent months and months of my freetime on it (atop undergrad) if I didn't feel like that
17:17:34 <Peaker> btw, NIH is almost always used in a negative context, but IME, I've regretted re-using existing solutions far more than I regretted NIH
17:17:39 <mgsloan> So, I guess I'd encourage you to go that direction, but if not, well, I think we're on it!
17:17:45 <copumpkin> Peaker: not sure, haven't played with it much
17:17:54 <Peaker> mgsloan, well, we intend to invest quite a bit of time in it (and we already have)
17:18:34 <mgsloan> Right, it'd be best to have that time investment yield some real significant results / quantity of users!
17:18:43 <Peaker> copumpkin, if I need to spawn child processes or convert to/from text it's probably not what we'd want to use..  in any case, we're also after learning about type systems here, and later we can re-use existing code after learning
17:19:06 <copumpkin> Peaker: you don't need child processes. Agda is a library and emacs just happens to fire up ghci since it isn't a haskell program
17:19:14 <Peaker> mgsloan, well, re-using something like ghci is a huge compromise.. I don't think big compromises would yield that.   We NIH'd Gtk/etc out too
17:19:14 <copumpkin> but you could easily just load the library in your own program
17:19:14 <JoeyA> "<Peaker> ... IME, I've regretted re-using existing solutions far more than I regretted NIH"  Really?  I'd like to know more about it.  My experience has mostly been the opposite.
17:19:30 <mgsloan> While an awesome IDE for proof assistants would be fantastic, and is direly needed, I feel that a good Haskell IDE could get more use
17:19:39 <JoeyA> It might just be that I'm a crummy programmer :P
17:20:02 <mgsloan> Peaker: I agree with NIH-ing gtk - I just use GTK to provide a cairo context
17:20:30 <Peaker> JoeyA, When I tried to adapt existing solutions to my needs I'd always hit various flexibility walls.. and I end up spending far more time on the "adaptation" part than I would implementing the whole thing on my own. And I end up with a very sub-optimal result
17:21:33 <JoeyA> Peaker: Did you contact the maintainers of said projects?
17:21:39 <Peaker> mgsloan, talking text with ghci is not a workable solution IMO
17:21:44 <mgsloan> Peaker: While it is a compromise, and less fun to write, using GHCI can allow the implementation of the other aspects of the project to happen first
17:22:15 <Peaker> JoeyA, yeah, they didn't budge, afraid of big changes, etc.  Usually the fear is due to a hard-to-reason-about implementation or they're already committed to horrible API's/etc
17:22:28 <Peaker> mgsloan, like what aspects?
17:22:33 <JoeyA> Ah
17:22:51 <mgsloan> Peaker: right.  I have an idea for a horrifying solution to that
17:23:03 <Peaker> mgsloan, btw, note that we also NIH'd the way the code is stored.. we store it in a key/value store, not in text files
17:23:17 <Peaker> mgsloan, and we NIH'd revision control, because we need structural revision control
17:23:31 <mgsloan> Peaker: the structural editing, the IDE UI, the depiction of info (I haven't run it quite yet, btw)
17:23:47 <Peaker> mgsloan, we're already working on all of those
17:23:50 <mgsloan> Peaker: Oh man.. Are you going for collaborative editing too?
17:23:56 <Peaker> mgsloan, not yet
17:24:04 <Peaker> mgsloan, and we got far enough in those aspects that we started working on type inference
17:24:23 <mgsloan> Peaker: Yeah, sure, I'm just saying that you could devote more resources to those if there wasn't work to do type system side.  (too late now, so perhaps I should just ignore this :P )
17:24:31 <mgsloan> I see!
17:24:43 <mgsloan> very cool!
17:27:23 <mgsloan> Peaker: So, here's the horrifying way to send code to GHCI without serializing + re-parsing.  You store your code as TH ASTs (btw, TH typecheck is coming this summer - maybe we should request support for incrementalness?), and output binary-serialized versions of them as ByteString literals, which are passed to a TH function
17:27:34 <mgsloan> this TH function just de-serializes the ByteString
17:28:11 <ClaudiusMaximus> @tell mcstar http://archive.org/details/ClaudiusMaximus_-_Fractal_Juggling i ported the rendering part to GLSL, then combined it with some juggling algorithms (will upload the code to hackage in the next few days..)
17:28:11 <lambdabot> Consider it noted.
17:28:15 <mgsloan> The question is how much overhead is involved in serialize --> Bytes -> String
17:28:18 <Peaker> mgsloan, well consider that we want to get rid of modules and "import"
17:28:30 <Peaker> mgsloan, it raises so much legacy challenges when using ghci
17:28:42 <mgsloan> hmmm
17:28:53 <mgsloan> Ah, I see, fair 'nough
17:29:01 <Peaker> all code entities just get GUIDs and connect to each other's guid
17:29:05 <mgsloan> yup
17:29:30 <Peaker> an interface can be implemented as a record that's passed around. With agda-style typing, that record can contain other types, to be sort-of a "module"
17:29:34 <mgsloan> classical structural editor ideas.  Can you support text that's not not a comment, and doesn't parse?
17:29:50 <Peaker> mgsloan, we'll add those, and call them "annotations", probably
17:29:59 <Peaker> basically any document you want associated with sub-expressions
17:30:05 <Peaker> throw images in there, too
17:30:11 <mgsloan> seems reasonable!  very cool!
17:30:13 <Peaker> maybe auto-generated graphs on example inputs
17:30:53 <davesq> Can someone explain why this instance decl is illegal? https://gist.github.com/2865610 I've been reading everything I can find on it but just don't get it. #n00b
17:31:02 <mgsloan> how about supporting splices in comments, with expressions that yield "Doc" or something like that?
17:31:31 <mgsloan> I guess one issue is if there's an image file, you need "IO Doc"
17:31:40 <mgsloan> and then you have to decide when it needs to be re-evaled
17:33:36 <Peaker> davean, you need FlexibleInstances to allow instances that aren't a simple concrete type. You used "a" as one of the instance types, which isn't that
17:33:40 * hackagebot network 2.3.0.14 - Low-level networking interface  http://hackage.haskell.org/package/network-2.3.0.14 (JohanTibell)
17:33:51 <Peaker> davean, just add a {-# LANGUAGE FlexibleInstances #-} pragma to allow that
17:33:53 <mgsloan> GHCI seems to allow you to reference unambiguous names.  I suppose you probably cannot include the package ID in there too, hmmm (package imports)
17:34:23 <Peaker> mgsloan, "IO" probably won't be involved in anything interactive
17:34:28 <Peaker> mgsloan, or that is interpreted as you edit
17:34:41 <mgsloan> ah, so the image goes in the DB?
17:34:43 <Peaker> already the editor has "IO" only on a very outer shell
17:34:56 <Peaker> mgsloan, if you import it raw, probably. but it can be generated purely
17:35:19 <davesq> Peaker: is flexibleinstances commonly used? Or a sign that my design is wrong?
17:35:21 <mgsloan> So, GHCI will let you use "Data.Char.isSpace" without importing Data.Char
17:35:26 <Peaker> davean, it's very commonly used
17:35:40 <Peaker> oops, davesq
17:35:57 <Peaker> davesq, Though TypeFamilies are growing in popularity instead of MultiParamTypeClasses
17:35:57 <davesq> Peaker: good to know, thanks.
17:38:41 * hackagebot gnome-keyring 0.3 - Bindings for libgnome-keyring  http://hackage.haskell.org/package/gnome-keyring-0.3 (JohnMillikin)
17:39:09 <Peaker> davesq, https://gist.github.com/2865635
17:41:45 <Peaker> mgsloan, fully-qualified names may cause package trouble, yeah
17:42:07 <Peaker> mgsloan, we might want to have our own walled garden with explicit import of stuff
17:42:10 <Peaker> into the DB
17:42:17 <Peaker> to guard against eco-system horrors
17:42:36 <Peaker> (given we'll probably want a completely different mode of package management)
17:42:58 <mgsloan> Peaker:  Actually, I'm starting to change my mind - I kinda like that the type inference is built-in!  For mostly selfish reasons: it might make creating my type diagrams easier!
17:43:27 <mgsloan> Still a bit worried about keeping up with GHC (if you're going with Haskell).  Is the avoidance of eco-system horros the source of the name "bottle"?
17:43:42 <Cheery> I discovered how I can get the text-like editing of the trees.
17:43:57 <Cheery> going to implement it in few next hours.
17:44:20 <davesq> Peaker: so the nested "type Element" is a type family, not the type synonym that I'm used to?
17:44:46 <Peaker> mgsloan, heh, the source of the name "bottle" is that it was the main object on the table when we selected a (temp) name.. it'll probably get a nicer name later
17:45:18 <shachaf> Good source of names.
17:45:38 <Peaker> davesq, it's an "associated type" of the class instance, which is also a type family or a partial type function (only on the domain of the instances)
17:46:00 <Peaker> I guess we could have called it "table" but then everyone would think "light table" stole our name or vice versa :)
17:46:08 <Peaker> also it may be more confusing in programmatic places
17:46:16 <Cheery> Peaker: what are you creating?
17:46:25 <Peaker> Cheery, An IDE for functional programming
17:46:31 <Peaker> Cheery, structural rather than textual
17:46:52 <Cheery> Peaker: ah. how's it coming up?
17:47:01 <Peaker> very nicely :-) I think it's already pretty impressive
17:47:06 <davesq> Peaker: i think i have more reading to do. thanks for the example.
17:47:25 <Peaker> it has many cool features, eliminates many of my pet peeves (e.g: "save button", or heuristic source control diffs)
17:47:28 <Cheery> Peaker: I have similar plans, except for generic programming
17:47:57 <Cheery> went back to the design stage with it while ago.
17:47:58 <Peaker> davesq, you can also have "type family F a" outside of a class, and then: "type instance F Int = Char".. if you don't want the class baggage
17:48:09 <Peaker> Cheery, what do you mean by "generic programming"
17:48:11 <Peaker> ?
17:48:19 <mgsloan> Peaker: My project name for something along that is "Panopti", hah!  But bottle is nice.  It reminds me of name that "Why?" would pick
17:48:43 <Cheery> Peaker: it's not language dependent, it can be used to program similar languages that we used to have.
17:48:52 <shachaf> mgsloan: Like "potion", the name of _why's programming language?
17:49:08 <mgsloan> shachaf: yeah, or like "shoe" :)
17:49:24 <shachaf> I confused "bottle" with "potion" before.
17:49:25 <Peaker> Cheery, ah, but all good IDEs are language-dependent.. otherwise you can only offer pretty dumb features
17:49:43 <Peaker> there are of course many re-usable components
17:49:48 <Peaker> for the different languages
17:50:06 <Cheery> Peaker: yeah, but are the editors like that?
17:50:28 <Peaker> Cheery, you mean non-IDEs? No, but that's why they are less powerful
17:50:42 <Cheery> I've used vim this far.
17:50:43 <Peaker> without language-dependence you don't even get syntax-highlighting
17:50:55 <tazjin> Peaker: I can't really imagine what a "structural rather than textual" IDE would be like, is there anything up on it already?
17:51:04 <mgsloan> I think that an interesting market to target would be a "code assistant" tool - you've got your favorite code editing / etc environment, but then you open a different, more semantically aware tool for resolving type errors / performing refactoring / de-linting
17:51:06 <Peaker> tazjin, http://github.com/Peaker/bottle
17:51:16 <tazjin> ty
17:51:20 <Peaker> tazjin, basically you edit a structured AST, rather than text character strings
17:51:29 <Peaker> tazjin, all keyboard inputs map to valid structural transformations
17:51:29 <Cheery> lol. :)
17:51:38 <mgsloan> tazjin: People have been kicking around "structure editors" for a long time, but it's hard to point at one that succeeded
17:51:49 <tazjin> Hrmm
17:51:51 <Peaker> mgsloan, switching tools all the time would be a chore... IMO
17:51:51 <mgsloan> It's an idea that's long overdue, in otherwords :D
17:51:56 <tazjin> Peaker: Does it require GTK or anything like that?
17:52:08 <Peaker> tazjin, no, it requires GLFW, drawingcombinators, OpenGL, BerkeleyDB
17:52:18 <mgsloan> Peaker: perhaps.  The issue is that it takes a long time to get all of the editor features together
17:52:20 <Cheery> mgsloan: yeah. I think it lacks thinking, not coding.
17:52:21 <tazjin> I'll check it out
17:52:30 <Peaker> Cheery, code is not text, why edit it as text?
17:52:36 <Cheery> Peaker: exactly so
17:52:40 <Cheery> Peaker: but..
17:52:50 <Cheery> what is code if not text?
17:52:57 <mgsloan> So, if you emphasize refactoring / information / visualization, then it gives a way for the tool to be useful before it has all of those features
17:53:02 <Peaker> Cheery, An AST is much closer to what code is than text
17:53:12 <Cheery> Peaker: okay, so what an AST is?
17:53:24 <Peaker> Cheery, a rich data structure :)  As opposed to [Char]
17:53:35 <Cheery> like XML?
17:53:39 <Peaker> Like an ADT
17:53:46 <geekosaur> haven't people been trying and mostly failing to do AST-based editors for over 20 years?
17:53:51 <Peaker> Cheery, e.g: TH's AST
17:53:51 <mgsloan> yes
17:54:10 <Peaker> geekosaur, people have been trying to make touch interfaces for a long time before Apple made the iPhone
17:54:29 <Cheery> geekosaur: seems the activity is damn high right now.
17:54:32 <mgsloan> yeah, I agree that it can be done
17:54:46 <Cheery> more than one person is pursuing AST-based editors right now
17:54:56 <jfischoff> mgsloan: hey did you see I got gtk-toy-diagrams to work?
17:55:14 <mgsloan> the problem is that not enough people buy into a particular implementation, and so they usually remain toys
17:55:28 <Cheery> Peaker: if my current design works, I'll have a working version of mine within 12 hours.
17:55:40 <mgsloan> which is why I'm so focused on figuring out a way for these ideas to be manifested in a project that is useful sooner rather than later.
17:55:53 <mgsloan> jfischoff: Awesome!!
17:55:58 <Peaker> Cheery, well, surely it isn't as ambitious a project then :)
17:56:13 <mgsloan> jfischoff: hope it wasn't too problematic?
17:56:14 <Cheery> Peaker: I do think this is fundamental project. :)
17:56:20 <Cheery> of course there's direction from there outwards.
17:56:25 <Peaker> Cheery, I'm not sure I understand what you want to do
17:56:59 <Peaker> mgsloan, I think the problem with structural editing is that you have to reinvent a whole set of tools, and people usually fail bigtime on at least some of them
17:57:06 <jfischoff> mgsloan: no it wasn't. I didn't realize how busted gtk on OSX can be though ‚Ä¶ seems to work ok now.
17:57:21 <Peaker> mgsloan, also, another problem is that people realize text is not what you want to edit, but they fail to realize it IS usually what you want to present.
17:57:24 <Cheery> Peaker: I try think up an editing scheme that's very similar to editing text.
17:57:37 <Peaker> mgsloan, also, they associate text with keyboard, and structure with mouse, so they make their editor all pointy-clicky
17:57:45 <Peaker> mgsloan, various mistakes of previous endeavors
17:58:02 <Cheery> Peaker: I've got figured the layouting mechanism for that. so I should get it happen soon.
17:58:03 <mgsloan> Peaker: right, I agree wholeheartedly on those points
17:58:05 <Peaker> Cheery, and what is it you are editing?
17:58:15 <mgsloan> keyboard based editing is essential, and screw pretty graphics
17:58:25 <mgsloan> this is what I call "rich editing"
17:58:37 <Cheery> Peaker: it's hard to explain, but if you make a tree out of it, it's pretty much like XML
17:58:39 <Peaker> pretty graphics is nice for some things, but textual presentation of structured code is great
17:59:04 <Peaker> Cheery, our very old/previous incarnations of "bottle" edited a dumb tree.. then it evolved to edit a code tree
17:59:35 <mgsloan> it can have more structural representations like a "math notation" projection, or even optionally the typical "block notation" we're eschewing
17:59:48 <mgsloan> but a text notation, like the normal haskell syntax, at the base
18:00:04 <Peaker> yeah, and generate example outputs and draw graphs/charts
18:00:30 <mgsloan> yup yup.  We're practically going point-for-point the ideas I'd written down
18:00:43 <Cheery> Peaker: what I'm trying to do is something like notepad, but for tree representations
18:01:00 <Cheery> Peaker: as I think it should be possible to write, if the format is good
18:01:01 <Peaker> Cheery, I understand, and we kind of did that earlier
18:01:15 <Peaker> but our tree was serialized on a db (with a little side-program to convert to/from xml)
18:01:46 <Cheery> I think I'll encode it in a file, in bytecode.
18:01:53 <Cheery> had some code for that already
18:02:09 <mgsloan> (not that that's anything special - clearly from the recent IDE news / that one presentation - these ideas aren't exactly new)
18:02:22 <mgsloan> it does boggle me that no professionally used IDE really does this stuff, though
18:02:43 <Cheery> don't mess up professional and world-changing.
18:02:53 <Cheery> they aren't same things. :)
18:02:59 <mgsloan> oh of course
18:03:22 <mgsloan> I think most haskellers are all too well aware of the mismatch between practicality and industrial implementation
18:04:28 <mgsloan> it's just bizarre - there've been tons of academic projects for doing structure editing and concrete value feedback - but nothing that seems to actually get used
18:04:47 <Cheery> I think it's that breaking ground and innovating doesn't translate to making money
18:05:11 <Cheery> mostly it means that you're pioneering ground and someone else comes after you and makes the actual money by monetizing the schemes you created.
18:05:24 <mgsloan> I think it's just that the value of solving this well isn't understood, and the difficulty of solving it well is underestimated
18:05:39 <mgsloan> so, people try to implement it, it falls on its face, and people say "well that sucked, what a bad idea!"
18:05:42 <geekosaur> until the save format isn't one that can be edited quickly in a simple text editor (usually breaking any attempt to save additional information from the AST with it), and compilers accept the same input format, it's going to be problematic
18:06:03 <mgsloan> geekosaur: I agree.  The tool will need a transitional mode
18:06:18 <Cheery> geekosaur: or an accepted format everyone will use
18:06:20 <mgsloan> which is why I emphasize the "coding assistant" utility target as a more realistic goal
18:06:37 <mgsloan> the more people you get using this coding assistant, the more people potentially are hacking on it
18:07:03 <mgsloan> marketing it this way means that you won't wait 2 years for all the necessary IDE features to get worked out
18:07:12 <Cheery> I feel enough talk has been done. This doesn't progress.
18:07:26 <Cheery> Peaker: if you are awake when I get to sleep, I can show this to you.
18:07:42 <mgsloan> Cheery: Perhaps not, but I think my ideas have merit
18:08:39 <mgsloan> I usually try to think about software from a time-evolution perspective rather than an abstract / constructivist perspective of the ideal architecture
18:08:43 * hackagebot xmobar 0.15 - A Minimalistic Text Based Status Bar  http://hackage.haskell.org/package/xmobar-0.15 (JoseAntonioOrtegaRuiz)
18:09:05 <Peaker> Cheery, Sure, if it's cool :)
18:09:44 <tazjin> Peaker: Meh, BerkeleyDB is throwing C build errors at me. I'll have to sort this out before I can try it :P
18:09:45 <Cheery> mgsloan: I do think there's some merit in your idea. But also thinking one of the best things you can get is freedom from parsing things up.
18:10:28 <Cheery> parsing is complicated and expensive process.
18:11:16 <Peaker> tazjin, you've probably installed the wrong version
18:11:23 <Peaker> tazjin, it only supports relatively old versions of the clib
18:11:25 <djanatyn> does anyone know the best way to install GHC on Debian wheezy?
18:11:26 <djanatyn> (testing)
18:11:27 <Peaker> (the Haskell binding package)
18:11:31 <tgeeky> wow. what a mess:
18:11:34 <tgeeky> @. pl djinn ((c,d),(a,b)) -> ((c,a),(d,b))
18:11:35 <lambdabot> f = uncurry (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (,)) . flip . (((.) . (,)) .) . (,)))
18:11:37 <Peaker> tazjin, you need to point it at an older version
18:11:52 <Cale> djanatyn: Probably the same way as everywhere else, just grab the generic linux binary
18:11:57 <tazjin> Peaker: brew gave me berkeley-db 5.3.15
18:11:57 <djanatyn> the package provided is 7.0.4-8; how old is that?
18:12:07 <Peaker> tazjin, that's too new...
18:12:11 <tazjin> Peaker: okay
18:12:13 <Cale> 7.0.4 is kinda old
18:12:25 <Peaker> http://hackage.haskell.org/package/BerkeleyDB-0.8.5  says 4.8
18:12:37 <Cale> There was 7.2.x and now 7.4.1
18:12:38 <Cheery> Peaker: does your editor have concept of broken tree?
18:12:47 <Peaker> Cheery, no
18:13:00 <Peaker> Cheery, the structure is always valid
18:13:02 <nejucomo> cabal list regex shows a bunch of stuff, but I can't tell what's the "standard" or "basic" package.  regex-base says it replaces Text.Regex.  Which do I want?
18:13:09 <otters> @pl \(x,y) -> (y,x)
18:13:10 <lambdabot> uncurry (flip (,))
18:13:33 <Cheery> Peaker: my plan is to make a flat representation of the tree.
18:13:39 <aristid> @hoogle swap
18:13:40 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
18:13:40 <lambdabot> Control.Concurrent.MVar swapMVar :: MVar a -> a -> IO a
18:13:40 <lambdabot> Graphics.UI.GLUT.Window swapBuffers :: IO ()
18:13:41 <Peaker> Cheery, in-memory?
18:13:47 <Peaker> Cheery, we wanted to scale up, that's why we used a key/value store
18:13:55 <aristid> otters: sufficiently recent versions of ghc ship with a swap function :)
18:13:59 <Cheery> Peaker: yeah, well the tree edges look up like parentheses in that view.
18:14:08 <otters> @type swap
18:14:09 <lambdabot> Not in scope: `swap'
18:14:23 <aristid> otters:  lambdabot | Data.Tuple swap :: (a, b) -> (b, a)
18:14:30 <Cheery> Peaker: if you remove one edge, the tree becomes broken.
18:14:41 <Peaker> Cheery, why represent it that way?
18:14:52 <Peaker> why not in a cohesive way that doesn't have "Broken" as an option?
18:14:57 <otters> oh, I see
18:14:58 <otters> Data.Tuple
18:15:06 <Cheery> Peaker: you can do text splice on it if it's represented like that
18:15:06 <djanatyn> Cale: when you said the generic linux binary, did you mean the haskell platform?
18:15:16 <Cale> no
18:15:21 <Cheery> Peaker: well. text splice with link/unlink of tree edges
18:15:23 <Peaker> Cheery, why is that useful? Why not a sub-tree splice?
18:15:29 <Cale> I tend not to bother with that, though it might be good
18:15:43 <Cheery> Peaker: this should be simple.. simple enough that it can be coded in a day
18:15:43 <Cale> A new version of it was just released
18:15:56 <Cale> I'll tend to just install the generic linux binary from the ghc website
18:15:58 <Peaker> Cheery, so it's still a text editor, then, apparently
18:16:02 <Cale> and then get cabal install
18:16:20 <Cale> and run the bootstrap.sh script from its package
18:16:21 <Cheery> Peaker: yes and no. Have you seen a text editor that understands structure?
18:16:30 <Cale> and then just use cabal to install whatever libraries I need
18:17:05 <Peaker> Cheery, yes.. Eclipse
18:17:19 <Peaker> it feels very half-assed
18:17:29 <Peaker> because it's still committed to allowing breakage everywhere
18:18:33 <Cheery> well.. maybe it's better I get this done first. :) It's easiest to show that way how it works and why.
18:18:51 <Peaker> yeah in between IRC I work on improving my type inference :)
18:23:17 <Peaker> any good simple uniqueness/random monad on hackage?
18:23:40 <Peaker> (Basically a StateT UniqueId or StateT StdGen or such, with the associated operations)
18:29:33 <parcs`> edwardk has one
18:30:01 <parcs`> http://hackage.haskell.org/package/concurrent-supply
18:31:37 <Peaker> its in IO though...
18:32:02 <Peaker> (the only way to make one)
18:32:09 <Peaker> also, it is not a monad
18:32:18 <Peaker> but nm, I just wrote a StateT wrapper
18:32:37 <shachaf> Peaker: His is globally unique (in the program), not just locally.
18:32:53 <shachaf> And he has all sorts of unsafe tricks to make it fast, or something like that.
18:32:59 <Peaker> yeah, it sounds useful
18:33:01 <Peaker> but I need something else
18:33:07 <Peaker> (just local uniqueness, no IO)
18:33:11 <shachaf> Yep.
18:33:17 <shachaf> @google monadsupply
18:33:19 <lambdabot> http://www.haskell.org/haskellwiki/New_monads/MonadSupply
18:33:19 <lambdabot> Title: New monads/MonadSupply - HaskellWiki
18:33:52 <shachaf> Not sure if that's in a library.
18:33:58 <shachaf> Easy enough to write yourself, I guess.
18:35:36 <Cheery> Peaker: http://bpaste.net/show/4oIQbqrtbChTHLfz90ZE/
18:35:51 <Peaker> Python? :P
18:36:14 <Peaker> so much boilerplate just to capture lexical scope
18:37:14 <Cheery> http://bpaste.net/show/b5KyH4LwSuasPATqg62K/
18:37:19 <Cheery> commented in what they mean.
18:37:44 <nejucomo> I want to read a file, modify the contents, the write the file back out.  Is it error prone due to laziness to do this: readFile f >>= writeFile . modifyContents
18:38:02 <rwbarton> nejucomo, yes
18:38:10 <Cheery> Peaker: python is quite natural for me, but it's just a stepping stone.
18:38:17 <nejucomo> How do I strictly read the file?
18:38:19 <Peaker> stepping stone to where?
18:38:56 <Cheery> Peaker: what do you expect me to do once I have the first interpreter which reads the trees?
18:39:59 <nejucomo> Can I do something like: readFile p >>= (\ !s -> writeFile p (modify s))
18:40:02 <rwbarton> nejucomo: there isn't a prebuilt strict readFile in the standard Haskell library. you can import one from the strict-io package, or use a hack like { contents <- readFile f; evaluate (length contents); writeFile (modifyContents contents) }
18:40:30 <rwbarton> no, because that bang pattern will only force the first cell of the list (i.e. whether the list is of the form [] or _:_)
18:40:51 <Peaker> Cheery, move to Haskell? :D
18:40:53 <nejucomo> Does deepseq help?  (I'm not very familiar with strictness issues in haskell yet...)
18:41:03 <rwbarton> yes,
18:41:09 * nejucomo tfms.
18:41:17 <nejucomo> s/tfms/rtfms/
18:41:19 <rwbarton> readFile p >>= \s -> s `deepseq` writeFile p (modify s)
18:41:31 <Cheery> Peaker: why haskell? it's still parsed language.
18:41:42 <Cheery> :P
18:41:43 <joeyh> or, often better, write to a temp file and rename into place, which avoids laziness, space leaks, and updates the file atomically
18:41:50 <nejucomo> Cheery: Are you hoping for an unparsed language?
18:41:57 <rwbarton> then you have to import deepseq from the deepseq package or use rdeepseq from parallel
18:42:27 <Cheery> nejucomo: well you have to parse the serialization of tree to unserialize it.. but yes.
18:42:34 <nejucomo> joeyh: Yes, that does sound much better.  I was just curious about laziness and deepseq.
18:42:42 <nejucomo> I'm especially curious about the implementation of deepseq.
18:43:20 <Peaker> Cheery, I ported your code to Haskell
18:43:21 <Peaker> http://bpaste.net/show/GGUv0XuVpjLuk6jZeQwf/
18:43:29 <Peaker> Cheery, So much less boilerplate, so much more information, so much more concise
18:43:29 <parcs`> it's essentially foldr seq () i think
18:43:43 <nejucomo> In the interest of getting it done right instead of learning, I'm going to take joeyh's approach.
18:43:47 <Peaker> parcs`, it's not specific to lists
18:44:00 <Peaker> deepseq uses the NFData instance
18:44:04 <parcs`> Peaker: yeah
18:44:13 <parcs`> but that's the list implementation
18:44:25 <Cheery> Peaker: okay. I hope the next pick is as easy.. because next I'll write the thing that makes this live. :)
18:44:28 <parcs`> :t foldr seq ()
18:44:29 <lambdabot> forall a. [a] -> ()
18:44:35 <nejucomo> Damn, my curiosity keeps getting piqued.  /me wonders how NFData and generics are related...
18:44:40 <Peaker> Cheery, why Python? Spend more lines of code to get less reliability? :P
18:45:04 <Cheery> Peaker: less speed too..
18:45:11 <Cheery> I find it easy to type. I enjoy typing it.
18:45:51 <strager> __init__
18:45:55 <strager> Do you really love that?  =]
18:46:02 <parcs`> nejucomo: hmm, you can probably make a generic nfdata instance
18:46:07 <Peaker> Cheery, heh, masochist :)
18:46:16 <nejucomo> Ah the personal preferences of implementation language/tool: The endless freenode noise-floor.
18:47:08 <nejucomo> Peaker: Also, when you write it in haskell, you should of course use Emacs with viper vim emulation.  That's the best way to solve your problem.
18:47:17 <nejucomo> :-p
18:50:02 <Cheery> Peaker: the idea is that every catenated set of operations do a zipthrough the document.
18:50:47 <Cheery> so the changeset walks through a zipper and uses it to build a next version of document.
18:51:24 <Cheery> link turns two 'edges' to a new node.
18:52:04 <Cheery> splice destroys a part and replaces it with new content.
18:53:05 <Cheery> link in fact is a data to context change.
18:53:15 <Cheery> splice is a data to data change
18:53:50 <Cheery> and data changes are recognised before context changes.
18:54:11 <Cheery> so you can add edges and link them in single changeset.
18:54:56 <Cheery> [link(offset, 2, tag), splice(0, 0, [edge(), edge()])]
19:05:41 <Lemon> so apparently
19:05:50 <Lemon> type T = (,) Foo
19:05:54 <Lemon> is not the same as
19:06:01 <Lemon> type T a = (Foo, a)
19:06:13 <Lemon> what gives?
19:06:48 <mauke> 'type' is shallow
19:07:05 <mauke> if you declare a type alias with arguments, every use must supply all arguments
19:07:28 <mauke> you can't use it to create type lambdas
19:07:57 <Lemon> is there a good reason for that?
19:08:57 <mauke> probably
19:11:20 <gwern> @quote
19:11:20 <lambdabot> co_dh says: I don't like it, but I don't know why.
19:13:41 * geekosaur has seen it discussed on -cafe but does not recall particulars
19:28:37 <Cheery> I guess I change the order of appearances of link() and splice() -commands.. to make it easier to compute.
19:32:27 <Gurrag> should I uninstall the previous version of haskell platform before installing the new one? [Windows]
19:42:52 <JoeyA> Hurray, Haskell Platform 2012.2.0.0 is finally out (with GHC 7.4.1) !
19:43:58 <Gurrag> JoeyA: do you know if you have to uninstall the previous haskell platform before installing the new one?
19:44:28 <JoeyA> I don't know.  I suppose it's OS-specific.
19:44:39 <otters> oh, should we be updating haskell platform now?
19:44:58 <JoeyA> If you want pure awesomeness, sure.
19:45:02 <otters> I guess I do
19:45:29 <JoeyA> On Windows, I plan to run the installer, then check which GHC binary my PATH takes me to, and fix it if necessary.
19:46:14 <strager> It'll be fun reinstalling every package you installed with cabal-install
19:46:29 <otters> I can't wait for that part
19:48:23 <JoeyA> Just cd .ghc (or Application Data/ghc or whatever) and move the index over to do a fresh build.
19:48:52 <unlink> What is the idiomatic, high-level way of connecting subprocesses with pipes?
19:52:33 <unlink> I would like an interface like:  runPipeline_ $ cmd ["cat", "foo", "bar"] >>> cmd ["sort"] >>> cmd ["uniq", "-c"]
19:53:48 <nand`> unlink: you might be interested in something like http://hackage.haskell.org/packages/archive/HSH/2.0.4/doc/html/HSH.html
19:54:37 <JoeyA> What's a good way to install pcre-light (in particular, the pcre C library it needs) on Windows?
19:54:41 <unlink> nand`: Yes, I was evaluating that. I would prefer to bring in a simpler / more generic library, or something standard, if it exists.
19:57:35 <nand`> unlink: well; if you're using something like System.Process to create the processes you might be able to link the handles together with lazy IO
19:57:44 <nand`> other than that I don't really know
19:57:49 <otters> I'm installing the new haskell platform
19:58:05 <unlink> nand`: Yeah, I didn't really see any documentation related to that.
19:58:12 <unlink> nand`: But that would be nice.
19:59:41 <otters> oh boy I get to reinstall all my cabal packages
19:59:55 <nand`> hGetContents out >>= hPut in -- preferably with the ByteString interface or something similar
20:00:18 <JoeyA> :q
20:00:39 <JoeyA> whoops
20:00:50 <unlink> nand`: Ah, yes, I could thread them together in userspace, but I'd prefer to use a real pipe.
20:01:15 <Cheery> hmm
20:01:19 <nand`> unlink: oh; I see where you're coming from. I don't know what ‚Äúreal pipe‚Äù means here, is this some POSIX stuff?
20:01:57 * geekosaur thinks this sounds like one of the shell programming packages on hackage
20:02:17 <mauke> nand`: man 7 pipe
20:02:24 <Cheery> I can't help the feeling that I did not encode the changeset to tree the best way I could.
20:02:33 <aristid> nand`: yes, it's posix stuff.
20:02:41 <unlink> nand`: Well, whatever high-level abstraction Haskell exposes that causes the stdin of one to be fed from the stdout of another.
20:02:59 <unlink> (at a file-descriptor level. and yes, it would use pipe(2) on POSIX.)
20:03:21 <geekosaur> http://hackage.haskell.org/packages/archive/shelly/0.9.5.1/doc/html/Shelly.html
20:04:38 <aristid> unlink: http://hackage.haskell.org/packages/archive/unix/latest/doc/html/System-Posix-IO.html#g:8
20:04:51 <aristid> unlink: that's not very high-level but doesn't require additional packages
20:05:08 <nand`> I looked through HSH for what it's worth, seems like it's using userspace lazy IO
20:06:12 <aristid> :t fdToHandle
20:06:13 <lambdabot> Not in scope: `fdToHandle'
20:06:17 <aristid> oh well
20:06:28 <unlink> aristid: Yeah, I saw that too. But it would be nice if I didn't have to use System.Posix.IO.
20:06:39 <geekosaur> unlink:  see the one I sent earlier
20:06:43 <unlink> But it is currently my top contender.
20:06:49 <aristid> unlink: want it to be portable? i think windows doesn't have unnamed pipes
20:07:27 <unlink> aristid: ah. I don't particularly care.
20:07:36 <aristid> unlink: i mean i guess you could use pipes where possible and fallback to lazy i/o
20:07:37 <geekosaur> it's a higher level implementation and even includes a pipe operator to combine ShIO commands
20:09:16 <unlink> geekosaur: That's the Yesod one, right?
20:09:32 <unlink> Where does the pipes library fit in to all this?
20:09:41 <geekosaur> split off from yesod, doesn't seem to require it
20:09:54 <unlink> geekosaur: (yeah, Yesod is highly modular)
20:09:55 <aristid> i was about to say Shelly doesn't look like it's snoyman code, but it's from greg weber :D
20:10:25 <geekosaur> also doesn't appear to use the pipes library (which is not related to POSIX pipes, it's a distant relative of left-fold enumerator I/O)
20:11:31 <unlink> yeah
20:11:48 <geekosaur> oh, look, it's even windows compatible
20:11:49 <unlink> well Yesod libraries tend to depend on conduit instead...
20:12:01 <geekosaur> yeh, but that's not involved either
20:13:16 <geekosaur> this makes sense since it's not so much about the Haskell I/O side of things (looks like you use the one of your choice), it's about hooking external commands together conveniently
20:14:43 <aristid> unlink: wait look at this: http://hackage.haskell.org/packages/archive/process/1.1.0.1/doc/html/System-Process.html#t:StdStream
20:14:54 <aristid> unlink: it allows you to create a pipe right there
20:21:41 <unlink> aristid: Aha.
20:22:10 <aristid> unlink: so what are you going to go with? :)
20:24:49 <unlink> aristid: I think I'm going to implement a simple monad on top of that last one.
20:50:58 <Cheery> Peaker: I stumbled upon a probelm
20:51:00 <Cheery> *problem
20:54:03 <Cheery> Peaker: the tree editing scheme I try get becomes very complex very fast.
21:11:31 <Cheery> maybe treating tree as if it was a text is poor approach.
21:14:29 <Cheery> splice inside, wrap/unwrap  might do it.
21:14:42 <Cheery> build/collapse :)
21:14:57 <Cheery> they are opposites and splice inside is opposite to itself.
21:15:03 <guidj0s> How can I import a module stored in a parent directory? This does not seem to be specified.
21:15:25 <Cheery> it unfortunately also means no walk-in unless programmed.. but maybe that's good
21:21:00 <mzero> guidj0s: you must add the parent directory to the list of search paths for ghc
21:22:04 <guidj0s> mzero: Thank you.
21:22:15 <mzero> ghc -i.. should work
21:42:01 <augur> @ask conal am i correct in assuming your bottom-up trees always have 2^n leaves?
21:42:01 <lambdabot> Consider it noted.
21:45:23 <strager> @quote
21:45:23 <lambdabot> ski_ says: unique among types, 'Void -> X' has its own charm. tourists should definitly pay a visit.
21:46:25 <mzero> yay - plush builds on Jenkins
21:46:55 <mzero> don't have any automated tests set up - but it builds in both 7.0.3 and 7.4.1
21:54:12 <mzero> who down-votes a reddit release announcement?
21:54:18 <mzero> absurd!
21:55:02 <Ralith> the automated vote fuzzing system, perhaps?
21:55:14 <mzero> is there one?
21:57:35 <monochrom> the Invisible Hand did it :)
21:57:47 <JoeyA> lpsmith: Would you mind if I developed a patch to rid postgresql-simple of its pcre dependency?  Maybe I'm just not good at this, but I can't install the pcre C library on Windows.
21:58:04 <monochrom> preflex: seen ezyang
21:58:04 <preflex>  ezyang was last seen on #haskell 9 hours, 47 minutes and 40 seconds ago, saying: Torment will probably suck.
21:58:19 <monochrom> yikes, I just missed him
21:59:10 <JoeyA> An alternative approach would be to bundle C files in the pcre-light package as is done in the zlib package.  I don't know if dons would want to maintain that or not.
22:09:13 <aekition> hi
22:09:38 <aekition> i have installed leksah and when i start it the cmd stays open ... is that supposed to be?
22:10:54 <hamishmack> aekition: Yes
22:11:09 <aekition> can i prevent it?
22:12:22 <hamishmack> aekition: on windows?
22:12:42 <aekition> yes
22:14:30 <hamishmack> I gues you might be able to edit the leksah.bat file.  I do not have my windows VM set up right now, so I can't check
22:16:01 <aekition> u mean to edit bat file to end the prompt window?
22:16:45 <aekition> also the cmd shows package  not found....5 times! is it normal?
22:17:56 <AlienPilgrim> hi, I just upgraded to the latest Haskell Platform, and my "import Random" now reports that it's a member of a hidden package - is there another random number library I should be using instead?
22:18:09 <mzero> System.Random
22:18:44 <mzero> Random was the old module name from Haskell 98
22:19:12 <mzero> GHC 7.4.1 switched to Haskell 2010 by default, and that uses the newer hierarchial names for such modules: System.Random
22:19:27 <AlienPilgrim> okay, so it's the same code underneath
22:19:33 <mzero> if you want the old names, unhide the haskell98 package
22:20:16 <mzero> yup - I think there might be some tiny minor differences in a few of those packages, but nothing major
22:20:22 <AlienPilgrim> thanks
22:20:25 <AlienPilgrim> btw, what's the status of split's statistical robustness nowadays?
22:20:46 <mzero> ? not sure what you are referring to
22:21:28 <AlienPilgrim> in the Random library, there's a split function to "split" one random source into two
22:21:31 <Cheery> http://bpaste.net/show/wOeIaKDgjXiaKgEmMinz/
22:21:49 <mzero> oh - that - I've no clue
22:21:50 <AlienPilgrim> useful in functional code where you don't really want to thread the random generator through everything
22:22:10 <AlienPilgrim> thanks anyway :)
22:22:28 <Cheery> it's funny how long it takes to drop away bad ideas.
22:22:36 <mzero> what, using Python?
22:22:38 <mzero> :-)
22:22:49 <Cheery> lol
22:23:02 <Cheery> mzero: I meant the tree as text -metaphor
22:23:07 <hamishmack> aekition: I mean edit it so it launchs leksah with "start" http://www.computerhope.com/starthlp.htm
22:23:21 <Cheery> that's just simply so complex that you stagger in the beginning of trying to make it real.
22:23:53 <Cheery> treating trees as trees seems to be most reasonable.
22:24:42 <Cheery> now there's some things I can't do then.. like splicing through trees
22:24:49 <Cheery> but I don't know whether it's really necessary feature
22:25:00 <Cheery> if you want to splice through, collapse the structure first.
22:26:30 <Cheery> it's important for every editing command to have a clear opposite
22:26:54 <Cheery> seems like it helps were it anything you were making.
22:27:22 <Cheery> enough rambling. :)
22:28:04 <Cheery> should next put this into essence/, then throw away that oldy document format
22:28:35 <Cheery> and provide layouter for this new format.
22:28:40 <Cheery> shouldn't take longer than hour or two.
22:29:23 <Cheery> first I think I'd like to refill my beverage stock.
22:30:28 <Cheery> +coffee +carbon_dioxide_tanks.
22:31:49 <Cheery> sort of sad thing with structural editing concept.
22:32:04 <Cheery> I've spent now.. year.. two? with it?
22:32:23 <Cheery> yet if it's sane to implement, it should be possible to build in a day.
22:33:35 <mgsloan> I've spent > 5 years thinking about it, and > 1 year working on-and-off at real attempts towards things of this sort
22:33:59 <mgsloan> and don't really have much to show for it, but lots of inspiration accumulated!
22:35:10 <Cheery> well it's interesting if this works.. and if it doesn't I see why.
22:35:59 <mgsloan> I'm pretty pumped about bottle.  Hopefully Peaker won't mind some external contribution :D
22:36:04 <Cheery> guessing this time I'll just serialize the tree into something like json.
22:36:24 <Cheery> could write that in before I start with the layouter
22:43:10 <mgsloan> Peaker: Dunno if you're there, but just ran bottle, and this is absolutely amazing!!
22:43:25 <Cheery> mgsloan: it looks cool but very complex to use
22:43:29 <mgsloan> I love the visual consistency / persistence
22:43:43 <mgsloan> Cheery: Sure, but once the hard part is done it can be made easy to use
22:43:45 <Cheery> I'd say it's bit of too messy too. :)
22:44:11 <mgsloan> Cheery: oh yeah, throwing a graphics designer at it would be a good idea
22:44:23 <mgsloan> (a good graphics designer, anyway, not these gradient-istas)
22:44:26 <Cheery> if you can
22:45:28 <Cheery> I think we should get our factions joined.. but I don't think the editor should be written in python or haskell.
22:45:35 <Cheery> it should be written in itself.
22:46:17 <mgsloan> yeah, getting less fracturing of efforts would definitely be best
22:46:32 <mgsloan> a few days ago we started #haskell-visual-programming for this purpose
22:46:54 <Cheery> and didn't tell me? how nasty of you :P
22:47:13 <mgsloan> hah!  Yeah, gotta tell Peaker too!
22:48:12 <mikeplus64> holy things i didn't know batman
22:48:15 <mikeplus64> you can pattern match in guards
22:48:58 <Cheery> I go catch my breakfast
22:54:29 <aekition> newbie: i downloaded a game in haskell...how do i run it?
22:54:56 <zzo38> aekition: Compile it using ghc and then it will run
22:55:10 <aekition> what is it with cabal install?
22:55:37 <zzo38> Cabal probably would automatically do that, if it is configured
22:56:21 <aekition> oh so cabal comes with ghc which is in haskel right? or not
22:56:39 <zzo38> Haskell Platform includes both GHC and Cabal.
22:57:20 <aekition> zzoo38 i have compiled setup.hs to exe now?
22:57:35 <zzo38> aekition: You don't need to compile setup.hs!
22:57:49 <aekition> dont tell me its main.hs
22:57:58 <mzero> is there a foo.cabal file in the directory?
22:58:01 <zzo38> aekition: main.hs is the file you need to compile to exe
22:58:05 <mzero> (for some foo)
22:58:21 <aekition> there is cabal
22:58:24 <zzo38> setup.hs is the file used for Cabal to install the program
22:58:35 <aekition> boomslang.cabal in main folder
22:58:55 <mzero> there is a .cabal file?   then just    cabal install    in the shell --- will build and install it
22:59:08 <zzo38> It should be Main.hs (with that exact capitalization), but it doesn't have to be
22:59:22 <mzero> if you want to build locally:     cabal install --only-dependencies && cabal configure && cabal build
23:00:30 <aekition> whatever i type it says not in scope... im goin crazy
23:00:51 <mzero> aekition: what game? link?
23:01:44 <aekition> http://hackage.haskell.org/package/boomslang
23:02:28 <mzero> okay - there is a .cabal file there
23:02:40 <aekition> so how do i open it?
23:02:45 <aekition> i mean run the game
23:02:55 <mzero> you need to compile and built it
23:02:59 <mzero> and all the packages it depends on
23:03:05 <mzero> cabal install --only-dependencies
23:03:14 <mzero> type that in a shell
23:03:19 <mzero> when in that directory
23:03:39 <mzero> then     cabal configure && cabal build
23:05:02 <aekition> omg god it need cabal update
23:05:15 <aekition> how annoying is that... i jus downloaded haskell yesterday
23:06:18 <aekition> ok now update complete and its doin compiling
23:06:24 <mzero> sadness - we just release a new haskell platform today
23:06:38 <kallisti> aekition: there's nothing called "Haskell" that you can download
23:06:48 <aekition> the platform
23:06:49 <kallisti> moreover, cabal-install not part of this "Haskell", and you need to update it the first time you use it
23:06:54 <kallisti> so that it's aware of what packages are available.
23:07:06 <aekition> what list of packages are there
23:07:13 <mzero> @where hackage
23:07:13 <lambdabot> <http://hackage.haskell.org/package/>, also see `revdeps'
23:07:23 <mzero> behold!
23:07:45 <yitz> kallisti: the title of the haskell platform page is "download haskell"
23:08:22 <kallisti> wow. amazing.
23:08:36 * kallisti can download concepts from the internet.
23:08:42 <aekition> im on a long learning curve here
23:08:58 <yitz> mzero: some guy spammed all kinds of haskell.org admin adresses saying that the link to archlinux on the hp linux page is 404
23:09:21 <kallisti> aekition: if you're familiar with other package managers it's pretty common to need a manual update every so often
23:09:58 <mzero> yitz: we know - it will be moved as soon as I can get access to the site
23:10:15 <yitz> mzero: annoying, but true we should fix that. the person suggested the archlinux wiki page about haskell, since there is no longer a single haskell platform package on archlinux
23:10:18 <yitz> ah ok
23:10:27 <aekition> sorry for being a newbie but could i ask wether its possible to use haskell to make a website like tryhaskell...?
23:10:30 <yitz> mzero: do you have the alternate url?
23:10:44 <mzero> not handy - do you?
23:10:52 <yitz> mzero: sure one sec
23:11:04 <mzero> aekition: why yes, yes it can
23:11:21 <aekition> ok now cabals done...some errors... why?
23:11:28 <yitz> mzero:  https://wiki.archlinux.org/index.php/Haskell_Package_Guidelines
23:11:39 <mzero> put them in hpaste, aekition
23:11:45 <mzero> @where hpaste
23:11:45 <lambdabot> http://hpaste.org/
23:11:51 <yitz> mzero: at least that's what that spam email suggested :)
23:13:09 <hpaste> Lazar pasted ‚ÄúBoomslang‚Äù at http://hpaste.org/69482
23:13:25 <mzero> thanks yitz, though I have to say, that page would be less than helpful to someone just trying to get the platform
23:14:17 <yitz> right
23:14:50 <mikeplus64> aekition: you might want to bump the OpenGL dependency to a higher version (2.5.0.0)
23:14:54 <mikeplus64> in that boomslang package
23:15:01 <mzero> aekition: you'll need to post more scroll back -- OpenGL failed to install on your system for some reason
23:15:02 <aekition> how can i do that?
23:15:21 <blackdog> doing some recreational optimisation, and got it to the point where the slowest part of my app is showing integers. Any ideas?
23:15:52 <cizra> Advance to solving the halting problem? :-)
23:15:53 <blackdog> tried Text.ByteString.Show, but it didn't help.
23:16:02 <mikeplus64> aekition: cabal unpack boomslang; cd boomslang-0.0.3; <edit boomslang.cabal to have the dependency on OpenGL bumped to 2.5.0.0>; cabal install
23:16:25 <yitz> mzero: i wonder why there *isn't* a haskell platform package on arch, just as a virtual package, since all of the platform is in fact on arch. probably because limiting the versions to the exact ones specified by the platform doesn't fit in well with arch.
23:16:35 <mzero> well - it would seem like we should know why OpenGL failed to build before we try newer versions....
23:16:52 <mikeplus64> aekition: nevermind,. doesn't seem to work when i try
23:17:07 <yitz> mzero: in which case maybe there just shouldn't be a link to arch at all from the hp page
23:17:08 <aekition> so the game doesnt work even on ur pc
23:17:10 <aekition> ?
23:17:34 <mikeplus64> yeah, i think you need to also change the font-opengl4x6 package
23:17:40 <mzero> yitz - there was already some discussion on h-p mailing list to that exact effect
23:17:41 <mikeplus64> to also depend on OpenGL 2.5
23:17:45 <mikeplus64> 2.5.*
23:17:47 * yitz nods
23:17:48 <mikeplus64> instead of 2.4.*
23:18:09 <mzero> mikeplus64: I think that is getting into voodoo land for someone trying to get a game to run
23:18:11 <aekition> leave it
23:18:20 <mzero> we have no idea if OpenGL 2.5 will install on his system
23:18:23 <aekition> im a newbie and dont want to go there... i will jus download another game
23:18:31 <mzero> you should
23:18:36 <mikeplus64> you could install Level0 (my game) :)
23:18:38 <mikeplus64> kik
23:18:40 <mikeplus64> lol*
23:18:47 <mzero> Boomshine hasn't been developed in over 2 years - unlikely to work on a modern Haskell system
23:19:34 <mikeplus64> aekition: yeah, it works if i edit the .cabal file for font-opengl-basic4x6
23:19:40 <mikeplus64> and the .cabal for boomslang
23:19:51 <mikeplus64> neat game
23:20:42 <aekition> ok i opened cabal for editing ... what do i change
23:20:54 <mikeplus64> on the lines saying OpenGL == 2.4.*
23:20:59 <aekition> i see it yes..
23:20:59 <mikeplus64> change the 2.4.* to 2.5.*
23:21:09 <aekition> ok but why ?
23:21:20 <mikeplus64> because OpenGL 2.4.* is old; 2.5.* is newer
23:21:37 <aekition> where tho.... both if and else?
23:21:40 <aekition> or jus else
23:21:45 <mikeplus64> all
23:22:15 <aekition> done
23:24:22 <mikeplus64> then do cabal install
23:24:33 <mikeplus64> in first the opengl-font-thingo dir
23:24:39 <mikeplus64> and then in the boomslang one
23:25:18 <aekition> rejecting....
23:25:32 <mikeplus64> did you edit both .cabals
23:25:41 <aekition> oh sorry wait
23:26:28 <aekition> what two cabals? i just have one cabal file
23:26:41 <mikeplus64> ok, so you edited the boomslang one?
23:26:59 <aekition> yes
23:27:39 <mikeplus64> then what you need to do is (probably best not in the boomslang dir) cabal unpack font-opengl-basic4x6
23:27:50 <mikeplus64> and then cd font-opengl-basic4x6-someversionnumber
23:28:08 <mikeplus64> then edit that folder's cabal file, changing the opengl version from 2.4.* to 2.5.* like before
23:28:16 <mikeplus64> then cabal install
23:28:25 <mikeplus64> then you can try do cabal install in the boomslang directory again
23:31:06 <aekition> doin it..
23:31:44 <aekition> so while wait.... y dont i jus use opengl 2.4 and download it?
23:31:54 <mikeplus64> that's what cabal tried to do
23:32:01 <mikeplus64> but it failed to build it
23:32:46 <aekition> for what reason?
23:33:27 <mikeplus64> if i try cabal install OpenGL-2.4.0.0 it errors saying that there isn't a Eq a context on some line
23:34:27 <aekition> i think this is associated with my graphics car
23:34:30 <aekition> card
23:34:45 <mikeplus64> what is?
23:35:00 <aekition> i often get this error with aticfx32.dll and for 2 years since i  bought this laptop i cant fix it
23:35:14 <aekition> lenovo y560 ati radeon
23:35:31 <mikeplus64> oh, then i can't really help you with a hardware specific bug
23:36:06 <aekition> who can? if lenovo hasnt so far who made the hardware with ati...
23:37:18 <aekition> finally it works!
23:37:26 <mikeplus64> yay
23:37:30 <aekition> and i dont even understand what the purpose of this game is but anw..
23:37:37 <mikeplus64> lol, neither
23:37:41 <mikeplus64> i just click and circles pop up
23:37:59 <mzero> anyone here ever built cabal-dev?
23:38:10 <mikeplus64> if you try cabal install Level0 you'll be playing my game :)
23:38:14 <aekition> yes but if u noticed u have to succeed a moment that other circles come by and touch them to make bigger circles..
23:38:15 <mikeplus64> mzero: yeah
23:38:27 <aekition> some guy who had plenty of free time made it probably
23:38:31 <mzero> when I configure and build it --- it doesn't build the cabal-dev executable
23:38:42 <mzero> can't figure out why - it builds fake-ghc-cabal-dev
23:38:51 <mzero> and ghc-pkg-6_8-compat
23:38:59 <mikeplus64> old ghc?
23:39:35 <mzero> 7.4.1
23:39:42 <mzero> right out of the platform
23:40:35 <aekition> could someone point out a good tutorial for making a website like tryhaskel ?
23:40:54 <mikeplus64> weird, i get the same error
23:41:01 <mikeplus64> not error, but uh, derp
23:41:05 <mzero> what aspect are you looking for? bulding web sites that execute user entered Haskell back at their server?
23:41:15 <mzero> that isn't a starter project! or likely something with a tutorial
23:41:33 <mzero> okay, mikeplus64, so it's not just me
23:41:37 <mzero> almost looks like a cabal error
23:41:51 <mikeplus64> mzero: i think the last time i built cabal-dev, i had to delete the fake-ghc-cabal-dev and ghc-pkg-6_8-compat
23:41:53 <mikeplus64> sections
23:42:02 <aekition> just anything that is also linked to a database
23:42:16 <mikeplus64> i'd look at the yesod book
23:43:51 <aekition> im thinking of building a website like tryhaskel where password protected users can use it at my company to insert records of cost analysis of specific items.... then with instant search one can filter out the results and easily find out how the costing had been made
23:44:07 <aekition> just simple but fancy graphics
23:44:39 <mikeplus64> very ambitious first project, but you should definitely look at happstack, snap and yesod's respective documentation, aekition
23:44:48 <mikeplus64> (each are good haskell web frameworks)
23:44:54 <aekition> is all of that on harskell org
23:44:56 <aekition> ?
23:45:09 <mikeplus64> no
23:45:11 <mikeplus64> just google it
23:45:38 <unnali> @google happstack
23:45:41 <lambdabot> http://happstack.com/
23:45:41 <lambdabot> Title: Home
23:45:45 <aekition> so these 3 are the best atm?
23:45:46 <unnali> @google snap framework haskell
23:45:48 <lambdabot> http://snapframework.com/
23:45:48 <lambdabot> Title: Snap: A Haskell Web Framework: Home
23:45:53 <unnali> @google yesod haskell
23:45:55 <lambdabot> http://www.yesodweb.com/
23:45:56 <lambdabot> Title: Yesod Web Framework for Haskell
23:46:20 <Cheery> I should unlazy myself today. :)
23:46:29 <Cheery> kicked my peak 6 hours already
23:46:32 <Cheery> but would want more
23:47:18 <aekition> thanks!
23:48:14 <mzero> aekition: what kind of web development are you familiar with? (just trying to perhaps give you some guidance between the three frameworks)
23:48:17 <aekition> guys tell me the truth... wordpress drupal joomla and all that.... are they really worth it? i think the make the easy stuff hard....plus u dont get to understand what u are doin... am i wrong?
23:48:32 <Cheery> aekition: they are worth it if you're without clue
23:48:47 <Cheery> they help you get up something quickly
23:48:50 <mzero> sure they are worth it --- for some things, and not for others
23:48:51 <aekition> i mosty know html and css some javascript thats it
23:49:06 <mzero> without knowing what you want to do, one can't really say
23:49:11 <Cheery> also they help you if you don't have time
23:49:26 <aekition> i mean this cms solutions in the end of the day might take u longer for a simple project than building it your self
23:49:30 <mzero> I have a blog - I use wordpress - makes it easy
23:49:32 <Cheery> web deving is annoying can of worms
23:49:46 <mzero> aekition: do you know any server side frameworks?
23:49:59 <Cheery> and no language can help that, unless it replaces huge chunk of web
23:50:09 <aekition> not really no server side
23:51:01 <mzero> well then - perhaps you want to tackle some smaller projects first - building an interactive web site is a large undertaking
23:51:09 <mzero> (of the sort you outlined)
23:51:24 <aekition> and i thought it was a matter of days to do :(
23:52:24 <mzero> if all you have is some javascript? no... you've got tons of stuff to learn to get to a working web site --- I don't mean to discourage you - you should start right away - but set your sights very small to start
23:53:05 <aekition> thanks for the advice and dont worry im stubborn... especially lately at programming lol
23:53:14 <mzero> Both Yesod and Snap have "just build me an empty site" starter systems
23:53:23 <mzero> and Yesod has a shiny new book
23:54:10 * hackagebot peggy 0.3.1.1 - The Parser Generator for Haskell  http://hackage.haskell.org/package/peggy-0.3.1.1 (HideyukiTanaka)
23:55:37 <aekition> hehe thanks
