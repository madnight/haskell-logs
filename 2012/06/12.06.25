00:00:09 <kaos> Hi, is there any way to re-formulate '(f g - h g) x' into something like '(f - g) `magicOperator` x` ?
00:01:05 <MostAwesomeDude> kaos: Not for all f, g, and h, AFAIK.
00:01:15 <MostAwesomeDude> But I'm pretty weak at combinators, so who knows?
00:02:12 <lebedev> kaos: Maybe Conal's VectorSpace? instance VectorSpace v => VectorSpace (a -> v)
00:02:41 <mauke> :t ((*) - div)
00:02:42 <lambdabot> forall a. (Integral a) => a -> a -> a
00:02:56 <mauke> > ((*) - div) 9 4
00:02:56 <lambdabot>   34
00:03:56 <MostAwesomeDude> What.
00:05:08 <mauke> > ((*) - div) x y
00:05:09 <lambdabot>   x * y + negate (x `div` y)
00:06:21 <MostAwesomeDude> How. But. What?
00:06:28 <mauke> hmm?
00:06:58 <mauke> articulate your confusion so I can vanquish it most efficiently
00:07:09 <srhb> I think it's the distribution of arguments that appears magic
00:07:20 <azaq23> MostAwesomeDude: Functions from some set A -> V where V is vector space form themselves a vector space regarding componentwise addition and scalar multiplication, the package implements this
00:07:51 <MostAwesomeDude> mauke: I'm highly confused by what happends in ((*) - div)
00:08:03 <mauke> MostAwesomeDude: it calls (-) with two arguments
00:09:08 <MostAwesomeDude> mauke: Well, over here, my ghci tells me that the type is ((*) - div) :: (Num (a -> a -> a), Integral a) => a -> a -> a
00:09:16 <mauke> yes
00:09:32 <MostAwesomeDude> And, sure enough, I can't get an instance of Num (a -> a -> a).
00:09:38 <mauke> oh, you can
00:09:39 <lebedev> Let's f x y = 2*x*y and g x g = 3*x*y. You might write (f ^+^ g) 3 4
00:09:43 <mauke> it's somewhere on hackage
00:09:43 <MostAwesomeDude> Maybe lambdabot's slightly magical?
00:09:50 <mauke> no, just an import
00:10:06 <dncr> is there a library with a Z/nZ type so that modular arithmetic happens automagically?
00:11:18 <MostAwesomeDude> Hm. Quirky.
00:11:46 <dncr> let a = toMod n aInt in print (fromMod $ 4 * a + 7)
00:11:52 <mauke> MostAwesomeDude: http://hackage.haskell.org/packages/archive/NumInstances/1.0/doc/html/src/Data-NumInstances.html
00:12:49 <ion> > (sin^2 + cos^2) 42 :: CReal
00:12:50 <lambdabot>   1.0
00:15:04 <MostAwesomeDude> mauke: Wow. Nifty.
00:17:28 <roconnor_> > deriv (sin^2 - cos^2) x
00:17:29 <lambdabot>   1 * cos x * sin x + sin x * (1 * cos x) + negate (1 * negate (sin x) * cos ...
00:18:22 <MostAwesomeDude> > deriv ((sin x) / x)
00:18:23 <lambdabot>   Couldn't match expected type `Data.Number.Dif.Dif a
00:18:23 <lambdabot>                        ...
00:18:39 <roconnor_> > deriv (sin / id) x
00:18:40 <lambdabot>   1 * cos x * recip x + sin x * negate (1 * recip x * recip x)
00:18:53 <MostAwesomeDude> Oh, I see. It's not symbolic at all.
00:18:59 <roconnor_> nope
00:19:15 <MostAwesomeDude> Or, rather, the expression's not symbolic, but lambdabot is symbolic in its solution somehow.
00:19:19 <roconnor_> > deriv (\x -> sin x / x) x
00:19:20 <lambdabot>   1 * cos x * recip x + sin x * negate (1 * recip x * recip x)
00:19:26 <roconnor_> > sin x
00:19:28 <lambdabot>   sin x
00:19:33 <roconnor_> @type x
00:19:35 <lambdabot> Expr
00:19:42 <lebedev> Wow!
00:20:22 <lebedev> > deriv (\x -> x^x) x
00:20:25 <lambdabot>   No instance for (GHC.Real.Integral
00:20:25 <lambdabot>                     (Data.Number.Dif.Dif...
00:20:35 <lebedev> > deriv (\x -> x**x) x
00:20:36 <lambdabot>   (1 * recip x * x + log x * 1) * exp (log x * x)
00:20:52 <mauke> > deriv (\x -> x**x) 2
00:20:53 <lambdabot>   6.772588722239782
00:21:00 <alang> :t deriv
00:21:01 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
00:21:11 <alang> @src Dif
00:21:12 <lambdabot> Source not found. My mind is going. I can feel it.
00:21:33 <roconnor_> alang: Dif is dual real numbers
00:21:51 <roconnor_> alang: http://en.wikipedia.org/wiki/Dual_numbers
00:23:19 <alang> deriv is from numbers?
00:23:33 <edwardk> MostAwesomeDude: you can use Debug.Traced and 'ad' to get the same result
00:24:00 <MostAwesomeDude> edwardk: ...There are things in Debug besides traceShow?!
00:24:07 <MostAwesomeDude> Man, today I *learned* things.
00:24:16 <edwardk> http://hackage.haskell.org/packages/archive/traced/2008.7.4/doc/html/Debug-Traced.html
00:24:28 <edwardk> combines very well with ad
00:24:53 <edwardk> you can even see the different answers from reverse and forward mode
00:24:59 <edwardk> because of the different order of operations
00:25:52 <MostAwesomeDude> Crazy.
00:26:42 <edwardk> i've actually used a variant of it to do compile time AD
00:27:00 <srhb> "AD"?
00:27:05 <edwardk> so you feed it the algorithm and then template haskell spits out the code for the algorithm and the derivative
00:27:08 <edwardk> automatic differentiation
00:27:12 <srhb> Ah.
00:27:42 <edwardk> http://hackage.haskell.org/package/ad
00:28:31 <srhb> Funky.
00:28:39 <edwardk> lets you do things like compute: grad (\[x,y,z] -> x * y + z) [1,2,3]
00:29:05 <srhb> Oh, really. That's quite handy.
00:30:14 <edwardk> gradients, jacobians, hessians, the entire derivatives tower as a cofree comonad or jet minimizing shared work, etc.
00:30:47 * srhb wonders what a cofree comonad is, ditto for jet
00:30:49 <srhb> So many terms. :-)
00:31:01 <edwardk> ghci> diffs cos 1      => [0.5403023058681398,-0.8414709848078965,-0.5403023058681398,0.8414709848078965,0.5403023058681398...
00:31:05 <edwardk> gives you all the derivatives
00:31:37 <edwardk> now, when you have a function from multiple inputs, the derivatives 'fan out' as you go deeper
00:32:04 <edwardk> if you have 5 inputs, you have 1 answer, 5 first derivatives, 25 second (though they are related) 125 3rd (with more relations), etc.
00:32:16 <edwardk> the tower of all of these derivatives is the jet
00:32:39 <srhb> Ah.
00:32:59 <edwardk> a cofree comonad is a way to make that shape maximize sharing, but its also just a simple data type
00:33:10 <edwardk> data Cofree f a = a :< f (Cofree f a)
00:33:17 <edwardk> if f = Identity thats just
00:33:30 <edwardk> a :< Identity (b :< Identity (c :< .. ))
00:33:39 <edwardk> if f = [] then you get a rose tree
00:33:45 <srhb> @type (:<)
00:33:46 <lambdabot> Not in scope: data constructor `:<'
00:33:46 <edwardk> where you can have n children of each node
00:33:53 <srhb> Oh, it'sa type constructor
00:33:55 <edwardk> thats just the constructor name i gave it
00:34:00 <srhb> Right
00:34:04 <srhb> I recognize the rose tree
00:34:06 <edwardk> if f = Maybe you get a 'non-empty list'
00:34:21 <edwardk> since you have a :< Nothing or a :< Just (b :< Nothing) ...
00:34:22 <srhb> Aha
00:34:25 <srhb> Yes
00:34:26 <srhb> I see it
00:34:30 <srhb> That is a clever structure
00:34:47 <srhb> I never thought it was so general
00:34:56 <edwardk> now, when you have a function that takes an 'f' of inputs, then the gradient will have an 'f' of derivatives
00:35:16 <edwardk> grad :: (Traversable f, Num a) => (forall s. Mode s => f (AD s a) -> AD s a) -> f a -> f aSource
00:35:21 <edwardk> er sans (Source)
00:35:52 <edwardk> but we can compute an entire tower chaining all the layers of derivatives
00:35:54 <edwardk> grads :: (Traversable f, Num a) => (forall s. Mode s => f (AD s a) -> AD s a) -> f a -> Cofree f a
00:36:22 <edwardk> so you get (the answer) :< f (the first derivatives :< f ( the second derivatives :< ...
00:36:35 <srhb> That's quite brilliant. :)
00:36:45 <edwardk> thank you =)
00:36:58 <edwardk> this maximizes the 'zipping' of the structure
00:37:09 <edwardk> since the end user can easily peel the derivatives apart
00:37:23 <edwardk> but tis not generally safe for him to zip up arbitrary 'f a's he has lying around
00:37:29 <edwardk> its safe for me in the derivative code though
00:37:39 <edwardk> because i only have onething with that shape the original input set he gave me
00:37:51 <edwardk> now, a Jet is something i can translate a cofree comonad into
00:37:59 <edwardk> data Jet f a = a :- Jet f (f a)
00:38:10 <edwardk> here :- is just another constructor
00:38:13 <srhb> Similar
00:38:19 <edwardk> but we're now recursing polymorphically
00:38:20 <mauke> not recursive
00:38:25 <mauke> er, wait
00:38:36 <mauke> it recurses the other way around
00:38:38 <edwardk> a :- f a :- f (f a) :- f (f (f a) :- ...
00:38:48 <srhb> Why polymorphically
00:38:54 <edwardk> before we had one f being introduced at each level
00:38:55 <srhb> Isn't that 'a' the same 'a' all the way down?
00:39:01 <mauke> no
00:39:05 <edwardk> here we're unpacking all the fs at a layer
00:39:11 <mauke> a = f a
00:39:14 <edwardk> i've maximally _un_ zipped
00:39:15 <mauke> or rather, a' = f a
00:39:18 <srhb> aaah
00:39:47 <edwardk> so you can jet :: Functor f => Cofree f a -> Jet f a  to convert to the unzipped representation
00:39:55 <edwardk> and then use headJet and tailJet to step down the list
00:39:59 <edwardk> getting just the nth derivatives
00:40:01 <edwardk> without all the garbage
00:40:08 <srhb> Right. :)
00:40:45 <edwardk> headJet . tailJet . tailJet . tailJet . jet . grads (\[x,y,z] -> x*y*cos z)      -- will give you 3rd derivatives
00:41:23 <edwardk> [[[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,1.9799849932008908]],[[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.9899924966004454]],[[0.0,0.0,1.9799849932008908],[0.0,0.0,0.9899924966004454],[1.9799849932008908,0.9899924966004454,0.2822400161197344]]]
00:41:48 <edwardk> (when applied to [1,2,3])
00:42:23 <edwardk> which is a 3 dimensional tensor of derivatives
00:43:32 <srhb> I'm playing around with it now. Makes me feel a little bit small. :D But thank you for enlightening me!
00:43:42 <edwardk> and it went out of its way to compute them optimally
00:43:56 <edwardk> since at the nth level there are k^n derivatives
00:44:05 <edwardk> but only (n + k - 1) choose k  distinct such derivatives
00:44:18 <edwardk> that latter number grows a LOT slower
00:44:30 <edwardk> so when you need 24 derivatives of a 5ary function...
00:44:47 <edwardk> er 24th derivatives
00:45:34 <edwardk> thats 98,280 distinct calculations rather than 5.9 × 10^16
00:45:39 <ion> Debug.Traced, huh? Seems like it might be useful.
00:45:51 <srhb> I have a hope of doing scientific computing with Haskell once I get further in my education - this package looks like it fits the bill nicely, while being quite cool in how it does its magic. :P
00:45:54 <edwardk> which means i can use it for taylor models
00:46:06 <srhb> How so?
00:46:27 <kallisti> @hoogle Handle -> IO FilePath
00:46:27 <srhb> Grab n derivs from the jet?
00:46:27 <lambdabot> System.IO hGetContents :: Handle -> IO String
00:46:27 <lambdabot> GHC.IO.Handle hGetContents :: Handle -> IO String
00:46:27 <lambdabot> System.IO hGetLine :: Handle -> IO String
00:46:43 <edwardk> well, you want to truncate a taylor series for a taylor model, and when you have multiple inputs, the naive form blows up in the number of derivatives involved
00:47:00 <edwardk> here i can get the minimal work to compute the distinct ones
00:47:15 <edwardk> and they actually get shared results in the cofree comonad/jet
00:47:39 <edwardk> so you can program with it easily, but not waste universe lifetimes computing ;)
00:47:51 <edwardk> but yeah
00:47:59 <srhb> Which is quite a benefit. I'm not sure I understand how you know about the sharing in this case. I find it hard to reason about
00:48:04 <edwardk> the jet holds my derivatives, so its easy to get the taylor series
00:48:06 <srhb> (But I'm also quite new to Haskell)
00:48:08 <srhb> Yeah
00:49:11 <edwardk> i added the optimal sharing part after a talk with the guy who wrote cosy infinity where i discovered there was no way for me to get access to his code since i'm not a proper academic any more
00:49:31 <edwardk> so i said screw it, i'll just make a nicer tool in haskell ;)
00:49:51 <edwardk> and he laughed and talked about how hard sharing was to get right
00:50:13 <edwardk> he was right. it took a whole afternoon ;)
00:50:27 <srhb> Dear lord. :P I would share his sentiment, I'm afraid.
00:51:10 <edwardk> i never did package up a toolkit for taylor models though, so i guess his monopoly still stands
00:51:46 <srhb> Well, isn't it almost there as it is with ad?
00:52:17 <edwardk> yes
00:52:34 <kallisti> wow cabal is taking ages to resolve dependencies.
00:52:36 <edwardk> though the thing with taylor models is i need properly rounded floating point arithmetic
00:52:47 <edwardk> so i've been working to get mpfr to work with haskell
00:53:04 <edwardk> and that has problems with the way mpfr uses gmp and how gmp interacts with haskell's garbage collector
00:53:18 <srhb> Okay. Sounds icky.
00:53:24 <kallisti> isn't it gmp that uses mpfr?
00:53:37 <edwardk> i have those problems largely licked, but they have a few issues remaining with the garbage collector in ghci
00:53:39 <edwardk> nope
00:53:41 <edwardk> other way
00:53:57 <kallisti> I recall that I needed to build mpfr to build gmp.
00:54:00 <edwardk> gmp gives you integers, mpfr uses those to make multi-precision floating points with arbitrary rounding
00:54:09 <srhb> It might be simpler to use gmp directly
00:54:13 <srhb> Well "simpler"
00:54:15 <srhb> :P
00:54:15 <edwardk> not really
00:54:16 <ion> edwardk: Thanks for the explanation about the cofree comonad and jet, it was enlightening.
00:54:20 <edwardk> mpfr does a lot of work
00:54:25 <srhb> Yes, it really was, I echo that
00:54:26 <edwardk> ion: happy to help
00:54:51 <edwardk> its a shame you can't make a general purpose comonad out of jet itself though
00:54:51 <shachaf> Did I miss a fancy explanation?
00:54:55 <Goatflakes> is gmp bcd? or is it like bcd but with the decimals replaced by platform integers?
00:54:56 <edwardk> shachaf: yes
00:55:07 <shachaf> How far up the scrollback should I look?
00:55:11 <srhb> Not far
00:55:29 <srhb> Go to 9:26 CEST :P
00:55:30 <edwardk> 31 minutes
00:56:03 <edwardk> i'm at that strung out awake, overly long winded explanation phase of the night ;)
00:56:52 <edwardk> Goatflakes: more or less
00:57:00 <srhb> Hehe, now I know when to trawl #haskell :-)
00:57:58 <Goatflakes> so it's like base n integer, where n=maxint-1?
00:58:15 <Goatflakes> wait maxint+1
00:58:18 <Goatflakes> or something :p
00:58:34 <edwardk> Goatflakes: i say more or less because the limb size varies a bit
00:58:34 <shachaf> Ah, neat.
00:58:40 <Axman6> oh wow, F# is now winning in the thread ring benchmark on the language shootout, but a long way
00:58:40 <srhb> I often wonder what would be necessary for Haskell to start pushing into scientific computing. It seems there are some really good matrix manipulation libraries now, which should put it in a good spot to replace all the horrible Fortran in, say, astrophysics.. But I suppose things like proper mpfr support is necessary too
00:58:47 <Axman6> by a long way*
00:58:47 <shachaf> (n + k - 1) choose k -- why does this come up a lot?
00:58:52 <frerich> I'm sorry for being offtopic, but since there are plenty of Comp.Sci. people in here and I'm having a hard time googling for this: what was the name for grammars which generate words in which no word is the prefix of another? Prefix-free? Prefix-safe? I can't seem to find this again...
00:58:59 <edwardk> shachaf: no idea. took me a while to calculate that
00:59:06 <Goatflakes> god. fortran
00:59:17 <shachaf> edwardk: It's the number of elements in an unordered n-tuple of a type with k inhabitants.
00:59:19 <srhb> Yes..
00:59:20 <Goatflakes> die alread :/
00:59:25 <edwardk> shachaf: yep
00:59:39 <srhb> It won't. And then you go see the language shootout, and you kinda see why, but still no. :P
00:59:42 <edwardk> shachaf: which is exactly what a partial derivative is if you think about it ;)
01:00:08 <shachaf> frerich: "prefix-free"
01:00:16 <edwardk> we don't care about the order we take the partials, just the set of what we've derive w.r.t. and how many times
01:00:26 <edwardk> er what we've derived
01:00:41 <Goatflakes> when someone makes it so you can do multiplication as easily on a vector as float as on a tensor as on an a
01:00:55 <frerich> shachaf: Thanks, I guess I must've overlooked something in the Google results, I'll scoot back into my dark corner now.
01:01:19 <edwardk> Goatflakes: its actually pretty easy to do multiplication in the covector monad on anything
01:01:45 * Goatflakes runs when he hears the m word
01:02:01 <edwardk> Goatflakes: this one is a particularly evil one of mine ;)
01:02:01 <Goatflakes> lol i know i have some reading to do
01:02:09 <Goatflakes> lol
01:02:12 <edwardk> or particularly nice as the case may be
01:03:16 <Goatflakes> god i have gone and given myself an msg headache again :< off topic ik but makes monads seem hard when u have a headache
01:06:49 * ion looks at http://www.grc.nasa.gov/WWW/k-12/Numbers/Math/documents/Tensors_TM2002211716.pdf
01:07:01 <Goatflakes> omfg
01:07:03 <ion> This might be a bit more approachable explanation of tensors than the Wikipedia article.
01:07:04 <Goatflakes> thanks!
01:07:37 <Goatflakes> i have given up on wikipedia for learning maths. i just close my eyes and buy a book of amazon :<
01:08:17 <Goatflakes> lol tensors=k-12
01:09:11 <Goatflakes> i am 2 subjects from graduation in computer science and literally did as many math subjects as i could and not one of my textbooks or lecturers had the foggiest what a tensor was
01:09:58 <Goatflakes> so i'm guessing postgrad unless you major in materials science or fluid dynamics or something like that where it's useful
01:10:40 <srhb> Or just straigt up physics.
01:11:08 <Goatflakes> possibly we don't have any hard science at the shitpot uni i go to :<
01:11:19 <srhb> Oh :P
01:11:24 <Goatflakes> ikr
01:11:43 <hiptobecubic> Goatflakes, I think not mastering tensors is pretty standard for undergraduate education
01:11:53 <Goatflakes> lol
01:12:01 <hiptobecubic> Unless you are in a field that uses them heavily like you mentioned
01:12:32 <Goatflakes> o i read that as "I think not! Mastering tensors is pretty standard for undergraduate education"
01:12:41 <Goatflakes> :p
01:12:49 <hiptobecubic> :D
01:12:59 <hiptobecubic> Well I certainly haven't, anyway.
01:13:20 <hiptobecubic> Although perhaps I'm not a great model. I studied biology in undergrad
01:13:44 <Goatflakes> it's shocking how much math is missing from my course
01:14:41 <Goatflakes> u can litterally graduate with a BS(CompSc) with only taking discrete math OR statistics and linear algebra
01:15:12 <hiptobecubic> You'll find that carries through to MSc as well, unless maybe you're at a really top school? I wouldn't know. Univ. Amsterdam isn't particularly prestigious.
01:15:45 <hiptobecubic> Goatflakes, i think you'd be shocked to find out how many people don't know ass about statistics.
01:17:01 <Goatflakes> lecturers are horrified of course to be teaching such drivel but kids won't enrol if there is too much maths and by too much i mean any. we had literally the best highschool mathematics teach program in the country (australia) but the had to pull it from lack of student. now there is a chronic shortage of secondary maths teachers country wide. but i digress :p
01:17:27 <hiptobecubic> I think that's world wide
01:17:45 <Goatflakes> yeah i bet it is
01:18:06 <srhb> actually that F# solution to threadring is kind of cheating, isn't it.. They're not really linked?
01:18:15 <srhb> (Or I'm having problems reading F# ._.)
01:18:37 <hiptobecubic> srhb, are you working in F#? Do you like it?
01:18:51 <hiptobecubic> It might finally get me to boot windows and learn to work with .NET
01:19:50 <srhb> hiptobecubic: No, sorry, I don't know it much. It's fairly readable though.
01:21:09 <Goatflakes> last 30 year? maybe more, been a misguide push to make mathematics "practical" instead of what they should be doing which is making it "interesting"
01:21:27 <bartavelle> is there a way to search for packages that depend on a known package ?
01:22:19 <bartavelle> Or if anyone knows of a package that uses hinotify to watch recusively over a directory, I am interested.
01:22:40 <bartavelle> I believe I read somewhere there was a GSoC on the subject
01:22:44 <bartavelle> can't find it anymore
01:22:58 <srhb> Isn't that like a oneliner?
01:23:08 <Goatflakes> GSoC? also i just cringed at the engrish i have been pumping out :p
01:23:21 <srhb> Google Summer of Code
01:23:28 <Goatflakes> right
01:23:39 <bartavelle> putting a watch on the files is a one liner
01:23:49 <srhb> but..
01:23:51 <bartavelle> adding newly creating files to the watchlist and removing the deleted ones properly isn't
01:24:09 <srhb> Are you sure? :P
01:24:19 <bartavelle> depends on the size of your lines I suppose :)
01:24:32 <srhb> Well, almost a oneliner then. Wish I had Linux. :P
01:24:36 <mauke> bartavelle: http://packdeps.haskellers.com/reverse/hinotify
01:24:39 <bartavelle> but it looks like the kind of things I would mess up
01:24:56 <bartavelle> mauke, exactly what I was looking for !
01:24:56 <Goatflakes> srhb: you know it's free right? ;)
01:25:20 <ciaranm> i run linux 19
01:25:25 <srhb> Goatflakes: Yes, and unfortunately runs like crap on my Macbook.
01:25:45 <Goatflakes> lol
01:25:47 <Goatflakes> y?
01:25:56 <Goatflakes> no hardware accelerated video card?
01:26:22 <srhb> Goatflakes: Bad support for a number of things.. troublesome BIOS/EFI booting.. Backlight troubles.. No integrated video card..
01:26:31 <srhb> And I really cba to fix all those things.
01:27:28 <Goatflakes> sounds horrid. i can't even be f'd to install linux on my acer cause wubi didn't install nvidia drivers
01:28:17 <Goatflakes> will stay that way until i get the shits with windows to much :D
01:30:22 <ion> > fix (\ ~(c:cs) -> ("Give me a '" ++) . (++ "'! ") . pure =<< (c:cs))
01:30:25 <lambdabot>   "Give me a 'G'! Give me a 'i'! Give me a 'v'! Give me a 'e'! Give me a ' '!...
01:32:33 <solrize> lol
01:36:18 <torox> hello
01:36:26 <Goatflakes> hai2u
01:37:31 <Ralith_> ion: why destructure at all?
01:38:26 <ion> ralith: It needs to assume there’s a first element, otherwise it won’t get around to evaluating "Give…" before it tries to use the first 'G'.
01:39:09 <Catnaroek> @src mapM_
01:39:09 <lambdabot> mapM_ f as = sequence_ (map f as)
01:39:51 <Ralith> srhb: that's why I got a thinkpad instead of a macbook!
01:40:09 <Ralith> only thing that isn't perfect ootb is the wifi, and that's being actively resolved by intel themselves
01:40:16 <Ralith> (and that's on a cutting edge model...)
01:41:00 <srhb> Ralith: Yeah, I fixed that issue on a friends Thinkpad with some parameters from that bugtracker on INtel
01:41:20 <Ralith> srhb: oh? Care to link?
01:41:20 <srhb> Ralith: I am getting a Thinkpad next for sure, I just hope their screens manage to become on par with Macbook screens before I can afford it. :-)
01:41:27 <Ralith> yeah, that would be nice
01:41:30 <srhb> Ralith: Uh, it's been a while..
01:41:32 <srhb> Let me check
01:41:46 <Ralith> I ran into some suggestions to disable 11n, but that just broke it even more
01:42:05 <srhb> Oh, I think that's what fixed it for him. Wireless centrino something?
01:42:09 <srhb> Anyway, I think we're OT :P
01:42:50 <timthelion> srhb: I wouldn't worry too much about the screens.  Since in linux, there are still a number of programs that use bitmap fonts,and those don't play nice with high dpi...
01:44:01 <Ralith> timthelion: those're usually perfectly configurable.
01:44:30 <srhb> I wasn't talking about the new fancy high-dpi screens though. It's mostly a color issue.
01:45:14 * Ralith doesn't particularly care about the color of his code, IRC client, or casual web browsing
01:45:29 <srhb> :)
01:46:06 * timthelion never noticed any color issues
01:48:07 <timthelion> Honestly, except for purple, this screen can do anything.  And I don't think anyone can do purple right, period.
01:51:23 <Catnaroek> @pl f (Just x) = x
01:51:23 <lambdabot> (line 1, column 12):
01:51:24 <lambdabot> unexpected "="
01:51:24 <lambdabot> expecting variable, "(", operator or end of input
01:56:01 <srhb> @pl (\(Just x) -> x)
01:56:01 <lambdabot> (line 1, column 9):
01:56:01 <lambdabot> unexpected "x"
01:56:02 <lambdabot> expecting operator or ")"
01:56:09 <srhb> What!
01:56:19 <srhb> @pl \ (Just x) -> x
01:56:20 <lambdabot> (line 1, column 9):
01:56:20 <lambdabot> unexpected "x"
01:56:20 <lambdabot> expecting operator or ")"
01:56:22 <srhb> <<
01:56:29 <srhb> Though I can't see how.
01:57:04 <mauke> pl doesn't do patterns
01:57:08 <MostAwesomeDude> srhb: You want fromJust, BTW.
01:57:11 <MostAwesomeDude> :t fromJust
01:57:12 <lambdabot> forall a. Maybe a -> a
01:57:19 <shachaf> No, you don't want fromJust.
01:57:23 <shachaf> Please don't use fromJust. :-(
01:57:39 <MostAwesomeDude> Yes, I was about to explain how it's a bad idea. :3
01:58:05 <shachaf> "Press this big red button to make exciting things happen!"
01:58:17 <shachaf> "...No, I was about to tell you never to press that button! Why did you do it?!"
01:58:26 <MostAwesomeDude> Fair enough.
01:59:02 <shachaf> srhb: @pl can't do pattern-matching, in general, because in general you can't write that point-free.
01:59:12 * hackagebot webdriver 0.4 - a Haskell client for the Selenium WebDriver protocol  http://hackage.haskell.org/package/webdriver-0.4 (AdamCurtis)
01:59:20 <mauke> it has special support for pairs. that's it
01:59:32 <srhb> No, as much, but the error message is not very clear. :-) Either way, it wasn't me that needed it
02:04:58 <ion> Cheerleadception http://codepad.org/fo7UPWvL
02:08:00 <liyang> but but, the idea of a thing inside another thing inside yet another thing is totally not what Inception is about!
02:08:35 <mauke> the xzibit meme wasn't about that either
02:08:46 <mauke> enjoy your corruption
02:10:36 <mellum> Is there a library that does minimum cut in unweighted graphs?
02:13:56 <bitonic> mellum: you mean with flow networks?
02:14:32 <mellum> bitonic: well, that's a method that would work, although it wouldn't be the fastest, probably
02:14:46 <mellum> I don't care so much about the method, I just want the cut :-)
02:15:01 <bitonic> mellum: fgl has something iirc
02:15:23 <bitonic> mellum: http://hackage.haskell.org/packages/archive/fgl/5.4.2.4/doc/html/Data-Graph-Inductive-Query-MaxFlow.html
02:16:58 <hpaste> Azel pasted “Socket listen failure” at http://hpaste.org/70419
02:18:27 <mellum> bitonic: thanks
02:19:01 <Azel> I am trying to listen to a socket bound on my own address bu when I run the code I just pasted, I receive this error message: "test: listen: unsupported operation (Operation not supported)". I'm sure I made a stupid error, but I don't see where...
02:21:30 <merijn> Azel: I'm not entirely sure, but can you even listen on UDP sockets?
02:21:41 <merijn> I think you can just call receive on them
02:22:21 <merijn> If you meant to use a TCP socket then you probably don't want "Datagram" as an argument to socket
02:22:57 <merijn> Azel: Just checked, C man page says listen only applies to SOCK_STREAM and SOCK_SEQPACKET
02:23:14 <merijn> So calling listen on a UDP (SOCK_DATAGRAM) socket is an error
02:23:47 <Azel> Nah, I tried to do a listen on a UDP socket, which is an error (and, in retrospect, not my brightest idea...)
02:24:19 <merijn> You live, you learn :)
02:24:49 <yogsototh> I all, it is stated in typeclassopedia that valid functor instances are unique, and this can be proved using the free-theorem. Here is some proof. http://article.gmane.org/gmane.comp.lang.haskell.libraries/15384 But, if we simply declare (fmap f = id), It appears to me it continue to be a valid instance of Functor while different from the default one (take Maybe for instance). Where am I wrong?
02:28:01 <quicksilver> yogsototh: that does not have the right type.
02:28:13 <quicksilver> yogsototh: id is always F a -> F a
02:28:20 <quicksilver> yogsototh: but fmap f must be F a -> F b
02:28:24 <quicksilver> for arbitrary a/b
02:29:14 <yogsototh> quicksilver: Thank you! I knew it was simple, I feel dumb. :)
02:29:31 <quicksilver> however I think that the claim is not true.
02:30:04 <quicksilver> oh what does "valid" mean? obeying the laws?
02:30:19 <quicksilver> yes, if they obey the laws they are unique.
02:31:25 <yogsototh> id obey the laws but not the type. There was my confusion.
02:32:46 <yogsototh> I should have tried it in ghci.
02:33:16 <quicksilver> :)
02:45:39 <bitonic> mellum: yw
03:10:51 <srhb> I feel like a great newbie resource would treat some general cases in more detail. Like, if you're making a game, how do you keep track of state, should you pass it around or make an IORef and what considerations weight for and against each approach..
03:11:31 <quicksilver> You should first pass it around, and learn the issues with that
03:11:40 <quicksilver> then you should refactor to use an IORef, and learn the issues with that appraoch
03:12:04 <ksf> then you should use StateT, and learn the issues with that approach
03:12:05 <quicksilver> then you should rewrite your core code into a state monad and have a wrapper which loads/restores the value from IORef
03:12:13 <quicksilver> and then finally you should learn about lenses
03:12:15 <ksf> ...or rather, not, because you already made everything monadic.
03:12:30 <quicksilver> and write each part of the app accessing only the *part* of the state it actually needs (via a lense)
03:12:37 <shachaf> quicksilver: No, lenses should come before IORef!
03:12:39 <ksf> the first thing to realise is that there's no need for state.
03:12:51 <srhb> :-) Excellent, now for the tutorial that takes me through all those.
03:12:53 <shachaf> They're so simple and they go nicely with the idea of passing state around.
03:12:54 <ksf> or, at least, passing it around.
03:13:01 <quicksilver> shachaf: well you need the IORef really if there are callbacks involved
03:13:08 <shachaf> srhb: I think quicksilver wants you to take yourself through all of those.
03:13:12 <quicksilver> which is there is with many IOrefs.
03:13:15 <quicksilver> erm
03:13:15 <srhb> Yes :P
03:13:18 <quicksilver> many UI librs.
03:13:20 <shachaf> quicksilver: Well, OK, if you're doing an IOy thing.
03:13:27 <ksf> srhb, two functions: update :: GameWorld -> GameWorld, draw :: GameWord -> IO ()
03:13:30 <srhb> A game with no IO may be boring.
03:13:52 <ksf> oh. make that Input -> GameWorld -> GameWorld.
03:13:56 <Dtgr> how come there's no need for state in a game :p
03:14:03 <srhb> wouldn;t update have to be GameWorld -> IO Input -> IO GameWorld
03:14:09 <ksf> even games written in imperative languages follow that pattern.
03:14:11 <shachaf> IO Input?
03:14:19 <srhb> How do you get input otherwise?
03:14:23 <ksf> you first collect input, then pass it.
03:14:23 <srhb> I mean, it's IO.
03:14:27 <srhb> Ah, yes
03:14:29 <srhb> Of course.
03:14:48 <srhb> input >>= update world
03:14:52 <srhb> But wait, that needs a return anyway.
03:15:14 <ksf> and collecting input should be decoupled from update and draw.
03:15:37 <ksf> you don't want to miss keypresses shorter than a frame etc.
03:16:52 <srhb> Hm.
03:20:30 <quicksilver> ksf: and when you do this stuff properly you do discover interesting issues like "what state is my application in when it's animating between two states? and what should I do with keypresses recived at that time?"
03:20:54 * quicksilver learnt that one because, the first time, the answer was "crash with an inexhaustive patterns error".
03:21:04 <ksf> there's no animating between two states
03:21:09 <shachaf> quicksilver: To be fair, -Wall would've caught that.
03:21:24 <srhb> So, I guess the "main loop" is the interesting bit here, since it's probably quite different from an imperative version?
03:21:27 <srhb> Well, may or may not be.
03:21:34 <ksf> the GameWorld is the current world, and it's always valid to draw. a single one, not two.
03:21:44 <ksf> you don't interpolate game reality.
03:21:48 <quicksilver> ksf: that is certainly one way of describing the issue discovered, yes.
03:22:07 <quicksilver> ksf: but those aren't quite the words I would have used myself
03:22:25 <quicksilver> I distinguish between "game world" and "ui state"
03:22:32 <quicksilver> game world is what I save to disk and load.
03:22:36 <quicksilver> UI state is what has animations.
03:23:10 <quicksilver> anyhow I'm not suggesting this is a problem; I'm just remarking that as part of the process of thinking this carefully you come across important questions like "how should the UI respond to events while it is animating"
03:23:15 <ksf> srhb, not really. update, in imperative languages, usually updates the state in-place instead of generating a new one, but that's rather inconsequental
03:23:36 <srhb> And either method could be used here, anyway.
03:24:28 <ksf> regarding updates, there's always two possibilities: do them as soon as possible, in the event handler, or collect events.
03:24:39 <ksf> with a simple UI you might get away with the former.
03:24:46 <ksf> usually, you want to collect events.
03:24:54 <ksf> and update in exactly one place.
03:24:55 * quicksilver agrees
03:25:15 <srhb> Collect events in yet another state? Or is that GameWorld as well.. pendingEvents?
03:25:33 <ksf> if it's a simple, no-animation "menu up/down" then just bloody set the new index and let the drawing catch up.
03:25:39 <srhb> Right.
03:25:57 <ksf> but as you're doing proper event aggregating for the game world, anyway, you can as well reuse it.
03:26:04 <quicksilver> I think there are some cases in which "ignore this input event because the natural of the current UI state transition is such that these events will not be relevant when the transition is complete" is the right answer; but in the majority of cases the right answer is "let the smart user type faster than the animation - he knows what he wants to do"
03:26:07 <ksf> also: DON'T START WITH THE MENU
03:26:25 <ksf> and your game is just another widget.
03:27:30 <ksf> srhb, in another state.
03:27:51 <ksf> Input -> Input, each time an event fires.
03:27:53 <srhb> Because the events decide how to update the GameWorld
03:28:17 <ksf> well, you snapshot them, then keep on updating.
03:28:30 <ksf> while keeping updating, you update the gameworld and draw.
03:28:36 <ksf> then snapshot again.
03:28:39 <ksf> think forkIO
03:29:13 <srhb> Yes, I was considering if forkIO was the way to go here. It seems easier to have an event handler do just that. But then I seem to need that mutable variable
03:29:26 <srhb> mutable shared variable, too.
03:29:45 <ksf> I'd use a standard actor pattern.
03:29:59 <ksf> that is, communicate via messages over TChans
03:30:11 <srhb> Oh, I haven't tried that yet.
03:30:37 <srhb> I was thinking event handler modifies an mvar to append the next action while there's a consumer reducing that same list of events
03:32:28 <srhb> But I guess that is basically a TChan(?)
03:32:36 <ksf> well, what way is the most elegant depends on whether you're more focussed on individual keypress events or "is the key still pressed" or even "for how many frames is the key now pressed"
03:32:43 <srhb> Right.
03:33:10 <ksf> I recommend not caring about it right now and using the simplest working version.
03:33:33 <srhb> OK, thanks for the sparring, and yes, I think I need to get something running now to fully understand the model. :)
04:03:59 <Tinned_Tuna> Morning Funners
04:04:09 <unnali> Tinned_Tuna: evening.
04:17:39 <mellum> Is there a way to get a version of IntMap.adjust that returns an error if the key wasn't in the map? Without having to do a costly extra lookup?
04:17:46 <mekeor> Tinned_Tuna: midday.
04:29:46 <t7> i thought lookup returned a maybe
04:30:07 <mauke> :t M.adjust
04:30:08 <lambdabot> forall a k. (Ord k) => (a -> a) -> k -> M.Map k a -> M.Map k a
04:40:10 <hpc> lookups are costly?
04:41:08 <unnali> hpc: should they not be?
04:41:34 <hpc> not in a map structure...
04:41:56 <unnali> not costly, but not free either.
04:42:03 <unnali> it might be O(log n)
04:42:51 <hpc> logn is nothing compared to the cost of making a map large enough for it to matter in the first place
04:43:02 <unnali> i concur :)
04:43:34 <fmap> lookups in IntMap are O(min(n,W))
04:43:51 <hpc> what's W?
04:44:06 <mellum> whatever the cost is, having this extra lookup will make the function about twice as slow, which I want to avoid
04:44:06 <hpc> word size?
04:44:08 <fmap> length of Int in bits
04:44:22 <fmap> 32/64 basically
04:44:37 <hpc> heh, fun
04:51:45 <srhb> does readTChan block if the channel is empty?
04:54:10 <shachaf> srhb: Yep.
04:54:16 <shachaf> Easy enough to try it out. :-)
04:55:47 <srhb> shachaf: Yes, that was the behaviour I was experiencing, I hyst wanted to be sure since the docs don't say as much.
04:55:57 <srhb> just*
04:56:31 <shachaf> They don't?
04:56:47 <srhb> "Read the next value from the TChan"
04:57:11 <shachaf> I guess they don't say anything.
04:57:15 <srhb> I suppose it is implicit, but it would have been nice to just add "blocks if empty" :P
04:58:00 <shachaf> srhb: Send a patch-or-something!
04:58:11 <srhb> shachaf: :o
04:58:49 <shachaf> You could probably get it in there with an email to libraries@ or something like that.
04:59:13 <srhb> I'll do that.
05:02:31 <srhb> Oh, not allowed. *pout*
05:03:08 <srhb> Why on earth list that as a maintainer address if we're not allowed to send to it.
05:05:21 <Saizan> yeah, you have to register to the mailing list
05:05:46 <hpc> that's a great way to make sure you never get bug reports
05:06:06 <srhb> :-)
05:06:35 <astry> hi
05:06:54 <silver> some opensource project promises you a tshirt for bug reports!
05:06:59 <astry> is there a curses-style lib which can receive mouse clicks?
05:07:30 <hpc> astry: i think so, because htop does it
05:07:40 <hpc> no idea what it's called though
05:07:56 <hpc> and it might be term-specific
05:08:36 <mauke> astry: ncurses
05:10:40 <srhb> hscurses has mouse things.
05:16:34 <astry> hpc: is htop written in haskell?
05:16:52 <astry> mauke: thank you. i have tried using vty in the meantime. do you know if it does that as well?
05:17:22 <mauke> no idea
05:18:01 <ehamberg> htop is written in C. don't know where the ‘h’ comes from.
05:18:34 <ehamberg> ah. the authors name is Hisham :)
05:18:40 <Goatflakes> wait
05:18:50 <Goatflakes> backwards fish =<<
05:18:57 <unnali> Goatflakes: waiting.
05:19:09 <srhb> syntax error..
05:19:15 <mm_freak> i have defined a Comonad instance for "data Bottom a"…  this doesn't feel too wrong, because disregarding bottom you can't construct a value of that type
05:19:18 <unnali> Goatflakes: what about (<><) ?
05:19:49 <Goatflakes> lol
05:19:57 <Goatflakes> fillo fish
05:20:02 <unnali> fillo?
05:20:02 <mauke> ehamberg: Hisham
05:20:11 <Goatflakes> fillet
05:20:14 <Goatflakes> o
05:20:15 <Goatflakes> fish
05:20:15 <unnali> fillet
05:20:16 <unnali> fillo
05:20:21 <unnali> those are very different words
05:20:26 <Goatflakes> macdonald's fish burger
05:20:37 <Goatflakes> not in australia
05:20:37 <unnali> aha, that's how you pronounce it over there
05:20:38 <unnali> right
05:20:53 <unnali> well, it exists here, but we pronounce "fillet" as … uhh, "fillet".
05:20:59 <Goatflakes> where the fillofish is no longer served >.<
05:21:11 <unnali> oh, really!? well, shows how long it's been since i stopped going there!
05:21:20 <unnali> (<><) = undefined
05:21:24 <Goatflakes> lol it's only been a year tops
05:21:26 <mauke> unnali: but "fillet of" takes so long to pronounce
05:21:47 <Goatflakes> :t ((<><))
05:21:48 <lambdabot> Not in scope: `<><'
05:21:52 <Goatflakes> exactly
05:21:53 <unnali> mauke: we make up for it by dropping `r's in everything
05:22:11 <mauke> "but there are no 'r's in fillet of fish!"  "see?"
05:22:18 <unnali> grcuo.hrcuentdrdck
05:22:18 <Goatflakes> also do you pronounce fillet as fill-ay or fill-it?
05:22:30 <Goatflakes> exactly
05:22:34 <unnali> rofl
05:22:35 <unnali> shush
05:22:38 <unnali> it's not something i say!
05:22:51 <xarch> hi
05:22:55 <Goatflakes> hello
05:23:06 <unnali> not being a meat eater, it's not something i have a lot of experience in pronouncing >:
05:23:13 <Goatflakes> ./topic fillofish
05:23:16 <xarch> I'm trying to convert an expression to ANF, does this seem correct : http://paste.awesom.eu/xarch/llg&ln ?
05:23:34 <mauke> unnali, Goatflakes: this would be more on topic in #haskell-blah :-)
05:23:39 <Goatflakes> :p
05:23:51 <unnali> mauke: concur
05:25:48 <Goatflakes> also
05:25:53 <Goatflakes> fish is not a meat
05:25:57 <Goatflakes> :3*
05:29:00 <mekeor> xarch: nice pastebin! :D
05:29:29 <xarch> :)
05:40:38 <Goatflakes> so i'm kind of stuck. i was watching meijer's intro haskell lectures, then i bought the hutton book and all went well till parsers. should i shelve meijer/hutton and try LYAH then come back to it? or should i just read/watch it again and idk try to nut it out?
05:41:22 <srhb> Read LYAH
05:41:27 <srhb> Always read LYAH.
05:41:28 <srhb> :P
05:41:52 <Goatflakes> cool hutton is good but it is a bit brief in parts
05:42:10 * Goatflakes goes and reads LYAH and leaves the nice haskell people alone
05:42:12 <srhb> So is LYAH, but it gives you the tools to get started, and then you will know better where to search for knowledge and what to ask.
05:42:24 <Goatflakes> ah cool
05:42:51 <Goatflakes> i have these meta tutorials too they've been useful
05:44:06 <Goatflakes> sorry trying to find the links for you too many tabs o.O
05:44:46 <Goatflakes> http://acm.wustl.edu/functional/haskell.php
05:46:03 <jaxtr> ahh it's a wonderful day
05:51:04 <unnali> jaxtr: it is!
05:51:10 <unnali> I gave a presentation on Haskell at work today, was pretty fun
05:51:27 <unnali> had people naming functions when given types at the end of it
05:52:27 <srhb> unnali: Fast learners. :)
05:52:52 <Goatflakes> good teacher?
05:53:43 <Goatflakes> srhb: i have used emacs lisp before but hated it. would write yourself a scheme be a waste of time for me at this point?
05:53:49 * Goatflakes is procrastinating
05:54:02 <Goatflakes> ^hated it but made it work
05:54:12 <unnali> Goatflakes: definitely not! scheme and emacs lisp are different in many important ways.
05:54:31 <unnali> Goatflakes: you won't know until you try it. plus, making a lisp is a hugely different thing to using one.
05:54:39 <srhb> Goatflakes: It's a fine project. I'm not sure how much Haskell you know already? Write you a scheme was a bit much on my first week
05:54:39 <Goatflakes> true
05:54:47 <srhb> Basically all I could do was copy and paste and not understand what was happening.
05:54:52 <unnali> srhb: definitely! we use Erlang at work, and I make a habit of being pretty strict with type specs we use in that respect, so I think that helped a little.
05:55:02 <srhb> unnali: Ah, that definitely helps! :P
05:55:15 <srhb> But still, good achievement. You should obviously have filmed your presentation. :-)
05:55:45 <unnali> hah, I think it was a little too low-key for that :D
05:55:51 <unnali> but first of hopefully many
05:56:12 <Goatflakes> wait
05:56:33 <Goatflakes> maybe it's a good fit cause i only don't understand parsing and monads so far everything else was natural
05:56:34 <srhb> I was watching one of SPJs talk on concurrency and Haskell from.. Last year! And found the comparisons with Erlang, if low-key, very useful.
05:57:24 <unnali> srhb: definitely. it's a lot more grokkable than Haskell at first pass, so it's neat being able to say something like "data Maybe a = Just a | Nothing" on the lhs of the whiteboard and "-type maybe(A) :: {just, A} | nothing." on the rhs :)
05:57:36 <srhb> unnali: Yeah :)
05:57:54 <srhb> Goatflakes: How about some simple IO project to get a hang of using monads?
05:57:56 <unnali> srhb: well, more grokkable to people who've used Erlang before and not Haskell …… who'd have idiot!
05:58:02 <unnali> who'd have thought** <- idiot.
05:58:17 <srhb> unnali: That was the weirdest typo. O_o
05:58:35 <unnali> srhb: I was going to call myself an idiot in the first line, and then somehow decided not to, then jumped the shark. :|
05:58:40 <Goatflakes> lol
05:58:56 <unnali> Goatflakes: when you say 'parsing', do you mean in general, or using Parsec, or …?
06:03:03 <Goatflakes> well i want to get into more general parsing but for the moment i just need to understand the chapter on parsing in hutton's "programming in haskell" so i can move on to the IO chapter
06:03:38 <Goatflakes> so i was asking about parsec, etc. before but now i'm talking about just the usually stuff you do with >>= and do
06:04:16 <unnali> ah, okay. that in itself is quite separate to parsing.
06:04:32 <unnali> do you know about how do-syntax desugars to (>>=) and vice versa?
06:04:42 <Goatflakes> yes
06:04:51 <unnali> okay, that's half the battle won :)
06:04:52 <Catnaroek> Hello. Is there any function similar to Text.Printf.printf, except it only expects a regular string? (no %s %d and the like)
06:05:03 <ben_m> putStrLn
06:05:10 <unnali> Catnaroek: when you say Text.Printf.printf, what do you mean? ben_m probably has what you want.
06:05:16 <Catnaroek> ben_m: That can only print to the standard output.
06:05:20 <Catnaroek> Sorry, I meant
06:05:24 <Catnaroek> hPrintf
06:05:31 <unnali> Catnaroek: hPutStrLn? :)
06:05:41 <Catnaroek> Oh, I did not know that existed! :D Thanks!
06:06:01 <unnali> @hoogle hPutStrLn
06:06:02 <lambdabot> System.IO hPutStrLn :: Handle -> String -> IO ()
06:06:02 <lambdabot> Data.ByteString hPutStrLn :: Handle -> ByteString -> IO ()
06:06:02 <lambdabot> Data.ByteString.Char8 hPutStrLn :: Handle -> ByteString -> IO ()
06:06:05 <unnali> np!
06:06:06 <fmap> actually putStrLn is `hPutStrLn stdout'
06:06:17 <unnali> Goatflakes: so what about monads is currently getting you?
06:06:39 <Catnaroek> Grrr, I swear if I ever see Data.ByteString again, I will kill someone.
06:06:44 <srhb> Catnaroek: Here's how you could have discovered this. Either checked the source of putStrLn (logic: How does it know to print to stdout?) or you could have searched Hoogle for the signature you needed (Handle -> String -> IO ())
06:06:59 <srhb> Catnaroek: Both would have yielded your function. :-)
06:07:07 <Catnaroek> srhb: Oh, I did not know you could hoogle type signatures.
06:07:18 <srhb> Catnaroek: Heh, that's one of the most awesome things. Try it out :)
06:07:28 <srhb> @hoogle Handle -> String -> IO ()
06:07:28 <lambdabot> System.IO hPutStr :: Handle -> String -> IO ()
06:07:28 <lambdabot> GHC.IO.Handle hPutStr :: Handle -> String -> IO ()
06:07:28 <lambdabot> System.IO hPutStrLn :: Handle -> String -> IO ()
06:07:29 <Catnaroek> :D I will!
06:07:38 <Goatflakes> nice
06:07:42 <Catnaroek> Thank you all!
06:08:19 <Catnaroek> I just cannot stand Text.Printf... I really dislike C.
06:08:27 <Goatflakes> :p
06:08:35 <srhb> I don't know how you even stumbled upon it. :-)
06:08:51 <Goatflakes> so what did you use before you came to haskell?
06:08:59 <srhb> Goatflakes: Tears and blood.
06:09:04 <Goatflakes> lol
06:09:33 <Goatflakes> i mean what languages did Catnaroek use before haskell
06:09:37 <unnali> Catnaroek: printf is a pretty nice example of an EDSL going back to early times.
06:09:49 <unnali> Catnaroek: and it's a lot better than what C++ tried to introduce instead :3
06:10:30 <Goatflakes> yeah appart from the fact it isn't type safe. but i hate doing that formated io with c++ streams it's aweful
06:10:57 <sopvop> how to safely convert Int -> Word32?
06:11:18 <quicksilver> fromIntegral
06:11:24 <quicksilver> (what does 'safely' mean?)
06:11:33 <sopvop> Means checking bounds
06:11:36 <unnali> Goatflakes: yes, but not much in C is type-safe, so you tend to take what you can get. that said, the compiler often will do special checking on format strings.
06:11:46 <quicksilver> sopvop: check the bounds yourself :-/
06:11:50 <unnali> sopvop: what should happen if the Int was out of bounds? :|
06:12:33 <sopvop> Int -> Either String Word32 would be nice. :)
06:12:36 <Goatflakes> so width of Int is 64 or undefined?
06:12:45 <srhb> sopvop: Maybe Word32 probably better ^^
06:13:06 <unnali> Goatflakes: at least [-2^29, 2^29-1]
06:13:10 <unnali> but maybe larger, depends on implementatino.
06:13:13 <unnali> ion**
06:13:20 <Goatflakes> weird number
06:13:23 <unnali> it's the "fast" integer, so on a 32-bit system it'll be above.
06:13:30 <unnali> not so, it's just signed 32-bit :)
06:13:42 <unnali> but on a 64-bit system you'll probably get -2^61 .. 2^61-1
06:13:53 <Goatflakes> yeah that's what i was worried about
06:14:01 <Goatflakes> so it can overflow on 64 bit
06:14:22 <Goatflakes> i like to give implementation defineds a very wide berth if at all possible
06:14:42 <quicksilver> unnali: no.
06:14:47 <Goatflakes> i treat them as the cancerous undefineds they are
06:14:49 <unnali> quicksilver: you're right
06:15:02 <quicksilver> in practice, it's -2^63 .. 2^63-1
06:15:08 <quicksilver> on GHC
06:15:12 <bitonic> Int is going to be Int64 on GHC
06:15:14 <bitonic> yeah
06:15:23 <unnali> quicksilver: so I've just discovered :3
06:15:25 <quicksilver> but as you correctly point out the standard only guarantees 2^29 each way
06:15:35 <quicksilver> if you need to care, you can check.
06:15:45 <Goatflakes> one of the things that i like about java is how it insists on number formats that are sensible
06:15:57 <quicksilver> Goatflakes: it might be implementation defined but the implementation is obliged to tell you via maxbound/minbound
06:16:01 <unnali> relevant section of the report: http://www.haskell.org/onlinereport/basic.html#numbers
06:16:06 <sopvop> So, for general case: int > fromIntegral (minBound :: Something) && int < fromIntegral (maxBound :: Something) right?
06:16:13 <Goatflakes> ugh
06:16:19 <bitonic> sopvop: isInBounds i x = i >= minBound x && i <= maxBound
06:16:21 <Goatflakes> defensive programing ahead
06:16:30 <bitonic> well. no :P
06:16:32 <unnali> Goatflakes: just use the correct size for the operation.
06:16:34 <Goatflakes> Integral
06:16:42 <Goatflakes> is the right size :p
06:16:44 <bitonic> sopvop: but those two functions should help
06:16:45 <unnali> could be.
06:16:51 <srhb> You mean Integer
06:17:09 <Goatflakes> i mean
06:17:10 <unnali> Goatflakes: Integral is the class of integer-like (whole?) numbers.
06:17:13 <quicksilver> "isInbounds i = i >= minBound && i <= maxBound" does not check anything.
06:17:15 <Goatflakes> yes i know
06:17:17 <bitonic> sopvop: the safest bet is to convert to Integer first and then compare
06:17:21 <bitonic> quicksilver: yeah, I know
06:17:43 <sopvop> Monday is way to fast :(
06:17:49 <unnali> sometimes I get the impression many of us are here telling the others things we already know. :)
06:17:52 <Goatflakes> i figure if i put integral in all my type signatures when i mean Int it will work
06:18:04 <Goatflakes> but
06:18:07 <srhb> foo n = if n == (fromIntegral w) then (Just w) else Nothing where w = fromIntegral n ?
06:18:07 <srhb>  
06:18:12 <unnali> sopvop: monday's only 33 minutes left here.
06:18:20 <Goatflakes> doesn't work when u have to do io and all that icky stuff
06:18:21 <srhb> With type annotation of course.
06:18:37 <Goatflakes> ^binary io
06:18:42 <Goatflakes> which is also the cancer
06:18:47 <unnali> Goatflakes: well, if you're doing binary io, you've already lost!
06:18:49 <srhb> Is there something bad about that solution?
06:19:03 <unnali> your width is constrained by a format somewhere
06:19:35 <srhb> I think my foo encodes the actual rules to be enforced nicely, but not sure..
06:19:47 <Goatflakes> lol reminds me of that book learn (can't remember what) in fixnum days
06:20:05 <Goatflakes> scheme?
06:20:24 <Goatflakes> anyway i'm going to stop being bad and off topic and go read bye
06:20:35 <unnali> enjoy!
06:20:45 <Goatflakes> :)
06:20:49 <unnali> srhb: so long as it works as we all expect, i think so!
06:20:57 <srhb> sopvop: Check the foo I wrote above :)
06:22:14 <srhb> You could even do foo :: Integral w => Integer -> Maybe w -- I think.
06:23:10 <srhb> (or maybe not...)
06:23:20 <srhb> Ah, yes you can
06:23:42 <quicksilver> you'll need a bounded constraint I think srhb
06:23:50 <srhb> quicksilver: Why?
06:24:01 <quicksilver> oh I see your approach
06:24:08 <quicksilver> you're right, equality suffices
06:24:12 <srhb> Neato.
06:24:16 <schlicht> how do i export explicit a data constructor, if the type has the same name?
06:24:19 * srhb is finally slightly clever.
06:24:38 <quicksilver> schlicht: the same way you do if they have different names
06:24:42 <quicksilver> TypeName(ConName)
06:24:53 <schlicht> quicksilver, ahh, didnt know that :)
06:24:59 <bitonic> TypeName(..) to export all of them
06:25:02 <schlicht> quicksilver, thank you!
06:25:23 <schlicht> bitonic, thanks =)
06:25:31 <DMcGill> what's considered best form for record punning?
06:25:48 <DMcGill> i.e. record{..} vs record{one, two, three}
06:26:05 <srhb> You could even make the n Integral too, but if you've already given something out of bound for that, I guess it would be bad.
06:28:23 <mm_freak> my types grow and grow…  i have a type with eight type variables…
06:28:46 <quicksilver> DMcGill: record punning is bad :)
06:32:10 <bitonic> which roughly translates to "name shadowing is bad"
06:32:14 <bitonic> mmmkay?
06:33:03 <Goatflakes_away> @hoogle map
06:33:03 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
06:33:03 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
06:33:03 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
06:33:28 <quicksilver> bitonic: especially at different types.
06:33:33 <quicksilver> bitonic: that's what really bothers me.
06:34:15 <Goatflakes_away> @hoogle (a->b)->(a,a)->(b,b)
06:34:15 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
06:34:16 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
06:34:16 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
06:34:28 <Goatflakes_away> erm no
06:34:36 <Goatflakes_away> how do i do a map on a pair plz?
06:34:45 <bitonic> quicksilver: well, at least that's safer than when shadowing with the same type. that is a great way to introduce subtle bugs.
06:35:29 <DMcGill> goatflakes_away: use a lambda
06:35:40 <quicksilver> bitonic: that is a fair point. But I feel shadowing at a different type induces wetware bugs :)
06:36:00 <DMcGill> > (\f (a,b) -> (f a, f b)) (1,2) (+1)
06:36:02 <lambdabot>   Couldn't match expected type `t -> t1'
06:36:02 <lambdabot>         against inferred type `(t2, ...
06:36:11 <DMcGill> > (\f (a,b) -> (f a, f b)) (+1) (1,2) -- oops
06:36:13 <lambdabot>   (2,3)
06:36:25 <Goatflakes_away> or if it's pair of all the same types, should i be using a list instead, even if i only ever want a fixed number of elements in the per pair/list
06:36:43 <bitonic> :t let pairMap f g = map (\(x, y) -> (f x, f y)) in pairMap
06:36:44 <lambdabot> forall t t1 t2. (t -> t1) -> t2 -> [(t, t)] -> [(t1, t1)]
06:37:02 <fmap> > join (***) (*2) (1,5)
06:37:04 <lambdabot>   (2,10)
06:37:16 <Goatflakes_away> lol yeah i'm a bit slow atm
06:37:19 <Goatflakes_away> thanks
06:37:23 <unnali> fmap: that was the one i was searching for!
06:37:35 <DMcGill> that reminds me, time to read typeclassopedia!
06:38:00 <barrucadu> @pl \f (a,b) -> (f a, f b)
06:38:01 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
06:38:09 <bitonic> yeah!
06:38:12 <barrucadu> Woo!
06:38:13 <unnali> woooooo
06:38:16 * bitonic does the pl dance
06:38:32 <Goatflakes_away> what is a typeclassopedia?
06:38:40 <srhb> Goatflakes_away: It's an article on the wiki.
06:38:42 <barrucadu> @where typeclassopedia
06:38:42 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
06:38:49 <Goatflakes_away> thanks
06:39:07 <unnali> :t map . join (***)
06:39:08 <lambdabot> forall b c. (b -> c) -> [(b, b)] -> [(c, c)]
06:39:10 <fmap> > (1,5) * 2
06:39:12 <lambdabot>   (2,10)
06:39:20 <unnali> fmap: :o
06:39:40 <unnali> fmap: what treachary
06:39:40 * hackagebot hsfacter 0.1.0.0 - A small and ugly library that emulates the output of the puppet facter program. Mainly used in conjunction with language-puppet.  http://hackage.haskell.org/package/hsfacter-0.1.0.0 (SimonMarechal)
06:40:07 <frerich> Goatflakes_away: I think that you could do something like 'data Pair a = Pair a a' and then make 'Pair' an instance of Functor
06:40:09 <srhb> Someone made tuples an instance of Num? <_<
06:40:18 <bitonic> srhb: yeah, Cale did!
06:40:28 <fmap> > fromIntegral 2 :: (Int, Int)
06:40:29 <lambdabot>   (2,2)
06:40:30 <fmap> > (1,5) * (2,2)
06:40:31 <lambdabot>   (2,10)
06:40:33 <fmap> unnali: ^
06:40:35 <srhb> Magic.
06:40:36 <unnali> @pl \f -> bimap f f
06:40:37 <lambdabot> join bimap
06:40:43 <unnali> lambdabot: right.
06:40:47 <unnali> fmap: I see!
06:41:05 <barrucadu> Num instances, in *my* tuples?
06:41:10 <DMcGill> and it's not really a haskell question but my cygwin shell is acting a little wierd - when in bash it works as expected but when in ghci the up and down arrow keys move the cursor to other lines instead of scrolling through previous commands
06:41:13 <unnali> > (join bimap) succ (1,2)
06:41:15 <lambdabot>   Not in scope: `bimap'
06:41:21 <rekado> Hi, I'm looking for a library that gives me authenticated encryption. I haven't found anything. Should I use the AES package and then MAC the resulting ciphertext manually?
06:41:23 <unnali> how on earth do I bring something in scope with dear lambdabot?
06:41:33 <DMcGill> and using the arrow keys or what have you produces invalid chars too
06:41:40 <unnali> DMcGill: cygwin is incorrigible :|
06:41:54 <bitonic> unnali: what do you mean? @let?
06:41:59 <mekeor> unnali: there's @let… not sure if that's what you want…
06:42:15 <unnali> bitonic, mekeor: sorry; I mean, I want Category.Bifunctor -- but it may well not even be in a package lambdabot has, so my query may not make sense :)
06:42:23 <rwbarton> you can't import things in lambdabot (aside from asking the lambdabot admin "hey can you add this to the list of imports please")
06:42:29 <unnali> right!
06:42:39 <unnali> ta :)
06:42:49 <DMcGill> surely you can qualify some things that lambdabot doesn't have in scope automatically?
06:42:51 <unnali> Control.Bifunctor** it's too late.
06:43:06 <rwbarton> well some modules are imported qualified
06:43:39 <rwbarton> here's a paste I found googling "lamdbabot imports", which may or not reflect reality: http://hpaste.org/67747
06:44:02 <unnali> rwbarton: handy, thanks!
06:45:09 <unnali> oh well, I'm off to bed.
06:45:12 <unnali> night!
06:45:32 <DMcGill> what does the string (e.g. "mtl") mean? It's not defined in the Haskell 98 report anyway
06:45:45 <mauke> it's the package name
06:46:38 <DMcGill> to disambiguate between modules in the same name from different packages?
06:46:46 <DMcGill> with the same name*
06:46:47 <mauke> http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal-1.14.0/Language-Haskell-Extension.html#v:PackageImports
06:47:00 <DMcGill> I see, thanks
06:47:43 <quicksilver> with caution though
06:47:52 <quicksilver> that feature is not really supposed to be used for that IIRC
06:48:25 * quicksilver can't remember why.
06:49:40 * hackagebot hsfacter 0.1.0.1 - A small and ugly library that emulates the output of the puppet facter program. Mainly used in conjunction with language-puppet.  http://hackage.haskell.org/package/hsfacter-0.1.0.1 (SimonMarechal)
06:52:17 <mekeor> is there a way to make (\s -> putStr s >> print s) pointless?
06:52:48 <quicksilver> yes.
06:53:00 <mekeor> how?
06:53:09 <quicksilver> @pl \s -> putStr s >> print s
06:53:10 <lambdabot> liftM2 (>>) putStr print
06:53:36 <rwbarton> @faq Is there a way to make (\s -> putStr s >> print s) pointless?
06:53:36 <lambdabot> The answer is: Yes! Haskell can do that.
06:53:40 <mekeor> but that doesn't work…
06:53:42 <Botje> that's an excellent exam question
06:53:45 <mekeor> rwbarton: -.-
06:53:48 <Botje> mekeor: why not?
06:53:58 <bitonic> @faq is there a way to make any lambda expression pointless?
06:53:58 <lambdabot> The answer is: Yes! Haskell can do that.
06:53:59 <quicksilver> mekeor: import Control.Monad.Instances.
06:54:01 <bitonic> yeah!
06:54:10 <mekeor> quicksilver: ah
06:54:12 <srhb> > liftM2 (>>) putStr print $ "blah"
06:54:13 <lambdabot>   <IO ()>
06:54:17 <quicksilver> mekeor: and, "that doesn't work" is one of the most annoying things anyone can say.
06:54:19 <mekeor> worx
06:54:24 <quicksilver> mekeor: please avoid it.
06:54:28 <mekeor> quicksilver: how?
06:54:37 <quicksilver> instead tell us what actually happens
06:54:42 * hackagebot xlsx-templater 0.0.1 - Simple and incomplete Excel file templater  http://hackage.haskell.org/package/xlsx-templater-0.0.1 (KirillZaborsky)
06:54:44 <mekeor> okay, sorry.
06:54:44 * hackagebot language-puppet 0.1.3 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.1.3 (SimonMarechal)
06:54:50 <quicksilver> compile error? type error? program runs but crashes? error message?
06:54:58 <quicksilver> (as it happens, I guessed this one)
06:55:01 <mekeor> okay, sorry.
06:55:09 <quicksilver> but in general, people are not going to be able to help you from 'doesn't work' :)
06:55:13 <quicksilver> no apology required.
06:55:15 <mekeor> okay, sorry.
06:55:23 <mekeor> thank you, by the way :)
06:58:18 <mekeor> can all recursive algorithms be written iteratively and the other way around?
06:58:34 <mauke> yes, assuming you get access to data structures
06:58:45 <Goatflakes_away> > map (map (["Red","Green","Blue"] !!)) [[x,y] | x <- [0..2], y <- [x..2], x /= y]
06:58:46 <lambdabot>   [["Red","Green"],["Red","Blue"],["Green","Blue"]]
06:58:54 <mauke> to write recursive algorithms iteratively, you implement a call stack
06:59:17 <mauke> to write iterative algorithms recursively, you turn each loop into a recursive function
06:59:21 <bitonic> mauke: a tail recursive tail stack, which is the main point
06:59:31 <mauke> huh?
06:59:41 * hackagebot hsfacter 0.1.0.2 - A small and ugly library that emulates the output of the puppet facter program.  http://hackage.haskell.org/package/hsfacter-0.1.0.2 (SimonMarechal)
07:00:17 <bitonic> mauke: when you hear people say "and now lets make the faster, iterative version", what they're doing is removing the stack
07:00:41 <mekeor> mauke: what if you assume you only have access to non-recursive data structures?
07:00:43 <Goatflakes_away> but
07:01:30 <rwbarton> the version with an explicit stack is still iterative... it's just not faster
07:01:36 <Goatflakes_away> most functional languages do tail recursion elimination so that can be a bit pointless if the recursive algorithm is tail recursive
07:02:41 <Goatflakes_away> means that u call the function recursively but don't do anything after you return from the recursive call, so u might as well return all the way back up from the top
07:02:51 <Goatflakes_away> ^up to the top
07:04:41 * hackagebot cabal-meta 0.2.2 - build multiple packages at once  http://hackage.haskell.org/package/cabal-meta-0.2.2 (GregWeber)
07:06:30 <dino-> I'm trying to install darcs using cabal-install. I'm not seeing darcs in the cabal list after (apparently successful) update. But I see it fine on Hackage.
07:09:21 <dino-> But it works when I just forge ahead and do 'cabal install darcs'
07:09:23 <dino-> bleh
07:11:08 <srhb> When Typeclassopedia says that [] is a Functor, isn't that wrong terminology? Shouldn't it say that [] and map form a Functor? Or have I misunderstood something?
07:11:20 <srhb> [] as in the list constructor.
07:12:36 <srhb> Actually it says functor with a small 'f', which makes it worse, I think.
07:13:28 <sipa> why would it be an uppercase f? it is not the name of a person or a place
07:13:48 <srhb> Because of how types and type classes are capitalized in Haskell.
07:13:52 <mikeplus64> is there a way to splice in normally formatted haskell code from a string (like "1 + 1") at compile time without having to go through a big TH syntax thing?
07:14:03 <rwbarton> technically, yes, though in practice it is common to refer to a functor by just the object part, just as it is common to say "the group of integers" or whatever
07:14:20 <srhb> Okay, thanks.
07:14:29 <rwbarton> rather than "the group (Z,+,0)"
07:14:55 <ciaranm> upi mean "the group (Z, +, 0, -)"!
07:15:01 <ciaranm> upi? you
07:15:11 <rwbarton> sure, whatever :)
07:15:20 <rwbarton> everything is determined by Z and + anyways
07:15:43 <Goatflakes_away> @hoogle [a]->[b]->([a],[b])
07:15:44 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
07:15:44 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
07:15:44 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
07:15:57 <rwbarton> but logically if i am going to include 0 i might as well include - too
07:15:58 <Botje> Goatflakes_away: that's just the (,) constructor :P
07:16:01 <srhb> And (,)
07:16:04 <Goatflakes_away> @hoogle [a]->[b]->[(a,b)]
07:16:05 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
07:16:05 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
07:16:05 <lambdabot> Test.QuickCheck.Modifiers shrinkState :: ShrinkState s a => a -> s -> [(a, s)]
07:16:11 <Goatflakes_away> so
07:16:20 <Goatflakes_away> no cartesian product function?
07:16:21 <ciaranm> i like how most algebra textbooks get the definition of group wrong
07:16:53 <srhb> > [(x,y) | x <- [1,2,3], y<-[4,5,5]]
07:16:54 <lambdabot>   [(1,4),(1,5),(1,5),(2,4),(2,5),(2,5),(3,4),(3,5),(3,5)]
07:17:06 <rwbarton> > liftA2 (,) [1,2,3] [4,5,5]
07:17:07 <lambdabot>   [(1,4),(1,5),(1,5),(2,4),(2,5),(2,5),(3,4),(3,5),(3,5)]
07:17:11 <srhb> Oh, clever, yes.
07:17:21 <Goatflakes_away> yeah i just did one myself :3
07:17:25 <srhb> damn, I wish I would notice those liftMs before I wrote something. I'm almost there. :-)
07:17:37 <rwbarton> ciaranm, how so?
07:18:10 <bitonic> srhb: the list comprehension is much more clearer anyway
07:18:31 <ciaranm> rwbarton: an awful lot of them assume uniqueness of the identity in later parts of the definition, but don't prove that until later, and don't require uniqueness
07:18:40 <srhb> In this particular case, probably, but for other monads.. :)
07:19:11 <rwbarton> oh hmm
07:19:25 <srhb> What would Haskell need in order to generalize liftM n f a b c d e f ... ?
07:19:54 <Goatflakes_away> > let cart_prod_goatflakes xs ys [(x,y) | x<-xs, y<-ys]
07:19:55 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:20:01 <Goatflakes_away> boo
07:20:26 <Goatflakes_away> > cart_prod_goatflakes xs ys [(x,y) | x<-xs, y<-ys]
07:20:26 <srhb> Goatflakes_away: let foo = ... in (expr involving foo)
07:20:27 <lambdabot>   Not in scope: `cart_prod_goatflakes'Not in scope: `xs'Not in scope: `ys'Not...
07:20:33 <Goatflakes_away> >.<
07:20:34 <osfameron> srhb: `ap` maybe?
07:21:21 <Goatflakes_away> i hate doing things inside an io monad i'm confused enough already :p
07:21:38 <srhb> Goatflakes_away: Use a source file and runhaskell then :)
07:21:46 <Goatflakes_away> yeah
07:22:05 <mekeor> @let cart_prod_goatflakes xs ys [(x,y) | x<-xs, y<-ys]
07:22:05 <lambdabot>   TemplateHaskell is not enabled
07:22:10 <Goatflakes_away> mah function is good though isn't it?
07:22:11 <mekeor> @let cart_prod_goatflakes xs ys = [(x,y) | x<-xs, y<-ys]
07:22:13 <lambdabot>  Defined.
07:22:29 <Goatflakes_away> :D
07:22:50 <Goatflakes_away> cart_prod_goatflakes [1..3] [4..6]
07:22:56 <Goatflakes_away> > cart_prod_goatflakes [1..3] [4..6]
07:22:58 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
07:23:07 <mekeor> yay :D
07:23:10 <Goatflakes_away> eheheh
07:23:14 <Goatflakes_away> ta
07:23:19 <srhb> Goatflakes_away: You can also query lambdabot privately, if you didn't know. :)
07:23:25 <Goatflakes_away> orly?
07:23:30 <mekeor> ya rly
07:23:36 <Goatflakes_away> someone said it didnt' work when they tried it last night
07:23:58 <srhb> Works fine.
07:24:02 <mekeor> ":t" doesn't work. you have to use @type instead.
07:24:03 <Goatflakes_away> cool
07:24:06 <Goatflakes_away> o
07:24:12 <Goatflakes_away> tank
07:24:14 <Goatflakes_away> s
07:25:44 <mekeor> adnauseam is going to ask a question!
07:25:53 <mekeor> not anymore…
07:26:32 <adnauseam> :P
07:26:39 <adnauseam> i've got a bag full of questions
07:26:45 <adnauseam> but today's is math's day
07:26:52 <adnauseam> -is
07:27:08 <adnauseam> shot myself in the foot there with the apostrophes
07:27:45 <Botje> .oO(beware of people bearing bags)
07:29:09 <mekeor> douche bags especially.
07:29:14 <Goatflakes_away> :p
07:29:28 <Goatflakes_away> was about to say big bags but i refrained nobly
07:29:45 <srhb> Can I hide an instance from Prelude?
07:30:29 <adnauseam> fear not
07:30:53 <fmap> srhb: no
07:31:03 <adnauseam> my bag is full of awesome, and confusion =[
07:31:10 <Goatflakes_away> lol
07:36:15 <mellum> is there something like "()" (unit) of Ocaml in Haskell
07:36:23 <srhb> > ()
07:36:24 <lambdabot>   ()
07:36:27 <mellum> oh
07:36:32 <mellum> :-)
07:36:54 <srhb> mellum: Why, though? You may or may not be on the way to doing something wrong now. :P
07:38:00 <mellum> srhb: I want to get the intersection of an IntMap with an integer set. But IntMap.intersection takes only maps. So I thought I'd use an IntMap that maps to unit to store the integer set.
07:38:39 <Botje> mellum: you could also grab the keyset from the IntMap and intersect that.
07:39:06 <Botje> keysSet returns an IntSet
07:39:47 <Goatflakes_away> also love it how functional programming is supposed to be about composition but then we write huge hairy list comprehensions :p
07:40:01 <mellum> Botje: but I want the intersection to be a map, keeping the bindings of the map
07:41:57 <Botje> mellum: okay, so use filter + intset.member
07:42:22 <Botje> or try to lookup all numbers in the intset and discard the Nothing results
07:42:56 <srhb> filter (member map) set -- does seem very idiomatic.
07:43:02 <srhb> Oh, other way around
07:43:19 <srhb> filter (member set) map :-)
07:43:29 <mellum> that would work. I'm just trying to make it as efficient as possible...
07:43:41 <Botje> catMaybe . map (flip M.lookup intMap)
07:43:43 <srhb> Thought actually member does not work on keys, but on values
07:43:53 <srhb> filterWithKey
07:44:11 <Botje> mellum: which one to use depends on which is bigger :)
07:46:05 <Goatflakes_away> is Integer really so slow? wouldn't it just use an platform int and catch overflows, so it would be nearly as fast as a platform int for numbers that would fit into an Int?
07:47:21 <Botje> sure
07:47:25 <Botje> but you still need the checks
07:48:14 <keseldude> Integer never seemed slow to me. Where did you read that it was slow?
07:48:43 <Goatflakes_away> checks are done in hardware and raise exceptions i'm guessing and appart from maybe messing with superscalar scheduling probably aren't slower than overflows that aren't checked
07:49:04 <quicksilver> keseldude: it's certainly much slower than Int.
07:49:05 <Goatflakes_away> well i didn't but always you hear "Integer can hold unlimited precision, but is slower"
07:49:15 <quicksilver> whether that matters or not depends on what you're doing, of course.
07:50:09 <Goatflakes_away> or in most processors do you have to check processor status words after each op to check for overflow?
07:50:26 <solrize> Goatflakes_away, since when is there a hardware overflow check?  i've been wishing for a while that there was one
07:50:48 <quicksilver> there is a hardware overflow register/flag, solrize
07:50:59 <quicksilver> it's not exposed by any widely used programming language
07:51:00 <mellum> solrize: Alpha has one :-)
07:51:07 <quicksilver> which I've often thought was odd.
07:51:10 <Goatflakes> hmm
07:51:15 <solrize> quicksilver, yeah but then you have to burn an instruction checking the flag
07:51:20 <quicksilver> yes.
07:51:22 <Goatflakes> so
07:51:35 <solrize> i meant i've been wishing there was an overflow trap like there usually is for floating point
07:51:39 <Goatflakes> overflow exceptions are only for floating point? bummer
07:51:45 <Goatflakes> what u said
07:51:51 <quicksilver> Goatflakes: anyhow, to answer your question, no, Integer doesnt' ust use a platform int and catch overflows.
07:52:07 <quicksilver> Integer uses a data structure which stores either a platform int or a GMP number
07:52:11 <Goatflakes> so it uses platform ints and checks after each operation
07:52:21 <quicksilver> and there is substantial overhead in checking it all
07:52:24 <solrize> and haskell doesn't generate checking code for Int
07:52:26 <solrize> like SML does
07:52:50 <ksf> cabal: cannot configure hint-0.3.3.4. It requires ghc >6.6
07:52:50 <ksf> There is no available version of ghc that satisfies >6.6
07:53:01 <ksf> ...I happen to have 7.4.2
07:53:04 <Goatflakes> yeah i noticed that i managed to overflow an int
07:53:11 <Saizan> ksf: do you have the ghc package installed?
07:53:15 <ksf> yep.
07:53:17 <Saizan> i.e. ghc-pkg list ghc
07:53:26 <ksf> system-wide, even.
07:53:55 <Saizan> it can only be in the global package db
07:54:14 <Saizan> anyhow, that's the "ghc" it's referring to there, not the compiler
07:54:21 <ksf> yep, I know.
07:54:35 <srhb> So how do I hide (,) ? :P
07:54:59 <ksf> behind a couple of if impl()s there's ghc-mtl....
07:55:26 <ksf> which complains about a lacking ghc >=6.10
07:56:19 <ksf> and yi can't be compiled without hint.
07:56:51 <ksf> in general, the whole thing seems outdated.
07:57:08 <EvanR> is there a standard function to append to a list
07:57:15 <Botje> ++
07:57:20 <Goatflakes> you can't do "foo::Integral->Integral" can you? you have do "foo::Integral a=>a->a"?
07:57:21 <EvanR> wrong type
07:57:36 <Botje> EvanR: yes, you can only append lists.
07:57:47 <Botje> if you want to append an element ... ++ [x]
07:57:59 <Botje> EvanR: also, you probably want to avoid that for non-trivial lists.
07:58:01 <EvanR> nothing with the same type as : ?
07:58:04 <EvanR> Botje: yes
07:58:13 <rwbarton> Goatflakes, right
07:58:19 <Goatflakes> :p
07:58:23 <mroman> Goatflakes: It's a typeclass, not a type.
07:58:26 <Goatflakes> silly maybe
07:58:32 <Botje> EvanR: some libraries have a function called snoc
07:58:36 <Botje> @hoogle snoc
07:58:36 <lambdabot> Data.ByteString.Char8 snoc :: ByteString -> Char -> ByteString
07:58:36 <lambdabot> Data.ByteString.Lazy.Char8 snoc :: ByteString -> Char -> ByteString
07:58:36 <lambdabot> Data.ByteString snoc :: ByteString -> Word8 -> ByteString
07:58:38 <rwbarton> @quote rwbarton type.class
07:58:38 <lambdabot> rwbarton says: A type class is not a type just like a dog house is not a dog.
07:58:45 <Botje> but probably not for lists
07:58:46 <Goatflakes> snot
07:59:03 <mroman> Integral -> Integral means that you wan't something with type Integral
07:59:23 <mroman> Integral a => a -> a means, that you want an a that somehow *is* an Integral
07:59:35 <mroman> but not of type Integral.
07:59:37 <Goatflakes> seems arbitrary but maybe it makes the parser easier
07:59:43 * hackagebot ekg 0.3.1.1 - Remote monitoring of processes  http://hackage.haskell.org/package/ekg-0.3.1.1 (JohanTibell)
07:59:57 <EvanR> Goatflakes: Integral is not a type
07:59:57 <rwbarton> it's not arbitrary at all
08:00:05 <mroman> yeah
08:00:08 <mroman> e.g
08:00:11 <fmap> EvanR: you may want a Sequence if you do (++ [x]) a lot.
08:00:12 <mroman> Num -> Num -> Num
08:00:13 <mroman> vs
08:00:20 <mroman> (Num a, Num b) => a -> a -> b
08:00:20 <rwbarton> for example these are different: Integral a => a -> a vs. (Integral a, Integral b) => a -> b
08:00:23 <EvanR> fmap: yes
08:00:26 <Goatflakes> i know it's not a type but why not pretend it is
08:00:35 <rwbarton> um
08:00:41 <Goatflakes> yeah that would be bad
08:00:43 <rwbarton> this isn't PHP?
08:00:55 <EvanR> fmap: someone asked me how to append to a list because they were used to other systems, i realized theres no library function for it
08:01:06 <mroman> Goatflakes: Perhaps you *could* make a special case for
08:01:12 <EvanR> of course i told him ++ [x], reverse . blah . reverse, and dont do that
08:01:12 <mroman> Num a => a -> a -> a
08:01:16 <Botje> otherwise people would start using it!
08:01:20 <mroman> so that you can write Num -> Num -> Num
08:01:27 <EvanR> Botje: well theres !!
08:01:42 <mroman> but it wont work for (Num a, Num b) => a -> b -> a -> b
08:01:55 <Botje> that's just for fancy fibonacci tricks ;)
08:02:14 <EvanR> also, you can append to lists efficiently ;)
08:02:22 <EvanR> by writing it as an unfold
08:02:27 <EvanR> haha
08:02:43 <solrize> EvanR, Writer (Endo String)  or so?
08:02:48 <EvanR> yeah
08:02:53 <Goatflakes> is !! O(1) or O(n)?
08:02:56 <EvanR> n
08:03:01 <Goatflakes> damn
08:03:09 <EvanR> 'dont try this at home' (tm)
08:03:16 <Goatflakes> so it really is a list :<
08:03:17 <keseldude> use arrays if you want O(1)
08:03:20 <EvanR> Goatflakes: yes
08:03:28 <Goatflakes> how to use an array in haskell?
08:03:31 <EvanR> Data.Sequence has O(log n)
08:03:35 <keseldude> there's an IOArray
08:03:35 <Goatflakes> nerver herd of it
08:03:40 <Goatflakes> o
08:03:51 <EvanR> arrays are not as easy to use and are usually not necessary
08:03:58 <keseldude> if you're just using the array internally, you can use STArray
08:04:03 <solrize> Goatflakes, what are you trying to do?
08:04:06 <edwardk> Goatflakes: if you want cheaper indexing you can use other structures like an array to get O(1) in exchange for O(n) update or a skew binary random access list to get O(log n)  (!!) in exchange for not dealing with infinite lists
08:04:27 <Goatflakes> thinking in horror of all the data structures that use array
08:04:34 <EvanR> not in haskell
08:04:38 <solrize> Goatflakes, the simplest and most "functional" approach is often data.intmap which is O(log n)
08:04:41 <mroman> hm.
08:04:46 <mroman> I'm actually surprised
08:04:46 <edwardk> Data.Sequence is a good general purpose data structure for random access in haskell
08:05:00 <Goatflakes> skip lists ftw
08:05:05 <EvanR> IntMap
08:05:07 <Goatflakes> ok
08:05:08 <xarch> a trie would give something like constant time access, wouldn't it?
08:05:13 <EvanR> no
08:05:15 <solrize> i thought data.sequence was rather slow
08:05:22 <xarch> well, given you don't use arbitrary length ints
08:05:25 <EvanR> better than a linked list
08:05:31 <edwardk> it gives you O(1) access to either end, O(log n) random access and its _persistent_, so you can access older versions without copying the whole thing. try that with an array ;)
08:05:42 <mroman> http://codepad.org/sz2qGIPQ <- is actually legal.
08:05:50 <mroman> probably because 5 gets promoted to float.
08:05:56 <mroman> or double, whatever 5.0 is.
08:06:19 <Botje> mroman: 5 is really (fromInteger 5)
08:06:20 <Goatflakes> :t 5.0
08:06:21 <lambdabot> forall t. (Fractional t) => t
08:06:26 <Goatflakes> hehe
08:06:30 <Goatflakes> i knew it would say that
08:06:36 <mroman> Botje: Ah yeah.
08:06:40 <solrize> mroman 5 is polymorphic
08:06:42 <solrize> :t 5
08:06:43 <lambdabot> forall t. (Num t) => t
08:07:19 <mroman> http://codepad.org/vdqMMOCn vs http://codepad.org/Z9VSIoMS @Goatflakes
08:07:36 <mroman> I forgot how ghc treats num literals.
08:07:50 <mroman> or Haskell 98.
08:07:54 <Goatflakes> anyway it's 1:06am, got work at 8:30am and haven't dried or ironed my clothes yet so night ;)
08:07:57 <mroman> Not sure where this actually is defined.
08:08:47 <Goatflakes> right i get it mroman
08:08:50 <mekeor> Goatflakes: you're an underground haskell-hacker? nice!
08:09:17 <Goatflakes> lol
08:09:36 <Goatflakes> gn
08:09:44 <mekeor> gn
08:10:33 <bartavelle> I suppose hackage isn't the right place to release a sample application of a library I just published there ?
08:11:05 <srhb> I've seen libraries with demos on Hackage. NOt sure if it's frowned upon.
08:11:56 <jfischoff> I add it. Hackage is just an easy way to install haskell code.
08:22:30 <bartavelle> humm
08:23:54 <bartavelle> OTOH this is not exactly supposed to be used with "cabal install", although it produces a usable binary
08:23:59 <bartavelle> this is meant to be used in GHCI
08:24:11 <bartavelle> so I guess this is a bad idea to put it on hackage as nobody will realize that
08:25:01 <xwl> is there a way to change the stack size in ghci ?
08:26:11 <bartavelle> I guess +RTS works with ghci
08:26:48 <xwl> bartavelle: you mean recompile GHCI using +RTS option?
08:27:00 <bartavelle> mine seems to accept it out of the box
08:28:00 <xwl> how do you know that?
08:28:19 <bartavelle> ghci +RTS -K64m -RTS probably
08:28:33 <bartavelle> I did not check the docs so this might be entirely wrong
08:28:57 <edwardk> shachaf: give comonad.com a try from where it was broken before
08:29:01 <edwardk> shachaf: whenever you get a chance
08:37:45 <xwl> bartavelle: seems work for me.  but actually i want to decrease it.. to understand stack overflow problem.
08:38:59 <xwl> look like 35K is the smallest one i can get.
08:40:36 <xwl> enough for me. now i don't have to wait for ghc to run for a long time to consume all the memory.
08:40:43 <xwl> bartavelle: thanks.
08:42:59 <srhb> SHE seems extremely nifty. When does it get merged in? :-)
08:47:58 <solrize> srhb, http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/kind-polymorphism-and-promotion.html#promotion
08:48:05 <solrize> it's a start :)
08:48:36 <mekeor> http://en.wikipedia.org/wiki/Fold_%28higher-order_function%29#Universality explains when a function can be written as a foldr. could you please tell me when a function is writable as a foldl?
08:48:55 <srhb> Oh :) Neat.
08:49:24 <solrize> > foldl (*) [1..10]
08:49:24 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [t])
08:49:25 <lambdabot>    arising from a us...
08:49:36 <EvanR> :t map map map
08:49:37 <lambdabot>     Couldn't match expected type `[a -> b]'
08:49:37 <lambdabot>            against inferred type `(a1 -> b1) -> [a1] -> [b1]'
08:49:37 <lambdabot>     In the second argument of `map', namely `map'
08:49:39 <solrize> > foldl (+) [1..10]
08:49:40 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [t])
08:49:40 <lambdabot>    arising from a us...
08:49:45 <solrize> > foldl (+) [1..10]  :: Integer
08:49:46 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
08:49:46 <lambdabot>         against inf...
08:49:51 <srhb> Starting value
08:49:54 <EvanR> :t map (map map)
08:49:55 <lambdabot> forall a b. [[a -> b]] -> [[[a] -> [b]]]
08:49:55 <solrize> > foldl (+) 0 [1..10]  :: Integer
08:49:56 <lambdabot>   55
08:50:04 <solrize> > foldl (*) 1 [1..10]  :: Integer
08:50:05 <lambdabot>   3628800
08:50:13 <mekeor> so… what?
08:50:29 <srhb> foldl can be defined in terms of foldr
08:50:32 <EvanR> :t fmap (fmap fmap)
08:50:33 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => f2 (f1 (a -> b)) -> f2 (f1 (f a -> f b))
08:50:35 <srhb> (ignoring things like memory and such)
08:50:39 <solrize> mekeor i don't understand your question, that's how to write factorial as a foldl
08:50:41 <mekeor> srhb: so what?
08:50:55 <mekeor> solirc: did you click on that link?
08:51:03 <EvanR> fmap (fmap (fmap (fmap (...
08:51:25 <srhb> mekeor: If a function can be written with foldr, and foldl can be writted as a function of foldr, then foldl can describe at least as many functions as foldr.
08:51:58 <solrize> mekeor, yeah i see the stuff at the link but i still don't understand your question
08:52:25 <mekeor> "g [] = v;  g (x:xs) = f x (g xs)" is the same as "g = foldr f v". what about foldl?
08:52:33 <srhb> As sad
08:52:39 <srhb> As said, foldl can be written with foldr
08:52:42 <srhb> How does this not answer your question?
08:53:09 <solrize> oh i see you want to know what can be written as a foldr but not as a foldl
08:53:17 <solrize> foldl has to consume the entire list
08:53:29 <solrize> so e.g. you can't foldl over an infinite list
08:53:41 <srhb> Also, my logic is flawed.
08:53:43 <srhb> :-)
08:53:47 * srhb needs coffee
08:54:41 <mekeor> anyway. gotta go.
08:54:44 <leondy> hello
08:54:46 <mekeor> thanks, and bye!
08:54:48 <srhb> If the converse were true, which it is, my logic would hold, so it does
08:54:48 <mekeor> leondy: hi :D
08:54:50 <srhb> (ignoring laziness)
08:55:03 <solrize> > let m f a xs = foldr (\x y -> f x : y) a xs in m (* 2) [1..5]
08:55:04 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
08:55:04 <lambdabot>    arising from a use ...
08:55:49 <mellum> Incidentally, if I want to write a fold-like function, say one that goes over the connected components of a graph, should I make it foldl-like or foldr-like? Is there any reason to prefer one?
08:56:05 <solrize> > let m f  xs = foldr (\x y -> f x : y) [] xs in m (* 2)  [1..5]
08:56:06 <lambdabot>   [2,4,6,8,10]
08:57:10 <solrize> mellum usually you want foldr if it generates output a little bit at a time
08:58:34 <DexterLB> is there a way to pattern-match a list with a single item?
08:58:43 <mellum> solrize: why?
08:58:49 <DexterLB> I thought about (x:[]), but it doesn't work
08:59:14 <srhb> DexterLB: Both [x] and x:[] work
08:59:16 <solrize> mellum, because with foldl you'd have to generate all the output at once
08:59:43 <solrize> > let (x:[]) = [3] in x*2
08:59:44 <lambdabot>   6
09:00:04 <srhb> > let foo (x:[]) = "One!" in [1,2]
09:00:05 <lambdabot>   [1,2]
09:00:12 <srhb> Oh, it doesn't?
09:00:13 <srhb> err
09:00:18 <srhb> > let foo (x:[]) = "One!" in foo [1,2]
09:00:19 <lambdabot>   "*Exception: <interactive>:3:4-22: Non-exhaustive patterns in function foo
09:00:20 <srhb> there we go
09:00:22 <srhb> > let foo (x:[]) = "One!" in foo [1]
09:00:24 <lambdabot>   "One!"
09:00:32 <srhb> > let foo ([x]) = "One!" in foo [1]
09:00:33 <lambdabot>   "One!"
09:00:34 <srhb> > let foo ([x]) = "One!" in foo [1,2]
09:00:35 <lambdabot>   "*Exception: <interactive>:3:4-21: Non-exhaustive patterns in function foo
09:00:40 <srhb> Works like a charm.
09:02:37 <DexterLB> srhb: hmm :)
09:02:48 <srhb> DexterLB: So what are you doing wrong? ;)
09:03:08 <DexterLB> srhb: I think my problem is totally not in the pattern matching bit :D
09:03:18 <srhb> DexterLB: Sounds right. :-)
09:08:40 <Greg-UBC> hi guys is there any lib simmilar to htdp2/image in racket?
09:08:55 <Greg-UBC> as in extremely beginner friendly
09:10:15 <edsko> is there a theory of an Arrow-like construct that does not assume pure?
09:10:33 <jamiltron> Are there solutions to the exercises in the typeclassopedia anywhere? I'd like to check my answers as I go along.
09:10:44 <srhb> jamiltron: Google! :)
09:10:50 <srhb> They're there, in various places
09:10:59 <srhb> Or: Check the Haskell source
09:14:46 * hackagebot urldecode 1.0.0.1 - Decode percent-encoded strings.  http://hackage.haskell.org/package/urldecode-1.0.0.1 (BenedictEastaugh)
09:19:19 <Taneb> Hello
09:19:24 <srhb> Taneb: Hi
09:19:41 <jedai> Greg-UBC: And what does this library does ?
09:20:53 <DexterLB> srhb: the problem was in my type constrains :D
09:21:07 <srhb> DexterLB: :)
09:21:16 <DexterLB> srhb: is there a typeclass that has ALL types?
09:21:31 <DexterLB> -srhb:
09:21:33 <drewr> "the problem was in my type constraints" --every haskell programmer ever
09:21:38 <srhb> DexterLB: Uhm.. What are you doing? It sounds wrong. :P
09:22:24 <srhb> DexterLB: If you are writing a completely polymorphic type, why would you add constraints?
09:22:31 <srhb> polymorphic function?
09:22:34 <srhb> Rather.
09:22:46 <DexterLB> well my function takes several parameters (is that the word?) and several of them have to have the same type
09:23:33 <DexterLB> for example f :: (Num a, Num b) => a -> a -> b
09:23:49 <DexterLB> but instead of Num I want them to be any types
09:24:03 <tac-tics> DexterLB: Parameters is the right word for what a and b are there
09:24:12 <srhb> DexterLB: But how can you do that? Unless if your function just throws those parameters away
09:24:43 <fmap> @djinn a -> a -> b
09:24:44 <lambdabot> -- f cannot be realized.
09:25:09 <srhb> DexterLB: Express what you want your function to do first, then think of a type.
09:25:13 <tac-tics> @type \x y -> fix id
09:25:14 <lambdabot> forall t t1 a. t -> t1 -> a
09:25:16 <srhb> (In this case, at least)
09:25:20 <tac-tics> :)
09:25:29 <Taneb> @djinn ((a -> b) -> a) -> a
09:25:30 <lambdabot> -- f cannot be realized.
09:25:42 <DexterLB> ooooh
09:26:23 <DexterLB> I just remove the constrains :D I thought that lowercase "types" weren't "defined" without defining them in the constrain section
09:26:41 <srhb> DexterLB: Ah.
09:26:57 <DexterLB> my full type signature is: f :: (a -> a -> b) -> [a] -> [b]
09:27:01 <DexterLB> and now works :)
09:27:13 <DexterLB> takes a function as a parameter
09:27:36 <srhb> DexterLB: When in doubt, try not to specify the type annotation at all and then just ask ghci for the type
09:27:50 <jedai> DexterLB: There's an implicit forall : forall a b . a -> a -> b
09:28:08 <DexterLB> jedai: oooh that's what I was looking for
09:28:27 <DMcGill> what does djinn do? (Other than granting wishes of course)
09:28:30 <tac-tics> Yeah. Unquantified types in Haskell are always universally quantified.
09:28:40 <jedai> DMcGill: Try to realize a type
09:28:42 <tac-tics> DMcGill: It tries to find a program that has that type.
09:28:48 <tac-tics> @djinn a -> b -> a
09:28:48 <lambdabot> f a _ = a
09:28:52 <tac-tics> @type const
09:28:53 <lambdabot> forall a b. a -> b -> a
09:28:54 <tac-tics> @src const
09:28:55 <lambdabot> const x _ = x
09:28:57 <tac-tics> see?
09:28:59 <Greg-UBC> jedai: it's a graphics library that allows for the easy creation of super simple interactive programs
09:29:20 <Greg-UBC> jedai:  the closest thing i can find atm is diagrams but its not quite there yet
09:29:42 <jedai> Greg-UBC: Well I'm not sure what you call interactive programs, did you look at Gloss ?
09:29:45 <srhb> @dinn (a -> a -> b) -> [a] -> [b]
09:29:45 <lambdabot> Error: Undefined type []
09:29:48 <srhb> Oh
09:30:08 <MostAwesomeDude> @djinn (a -> a -> b) -> m a -> m b
09:30:08 <lambdabot> -- f cannot be realized.
09:30:09 <geekosaur> djinn doesn't understand recursive types
09:30:16 <srhb> I see.
09:30:22 <jedai> Greg-UBC: It's not as good as diagrams for description of graphism but more interactive
09:30:52 <Greg-UBC> jedai:  yeah, i tried gloss but it's a little confusing
09:31:10 <jedai> Greg-UBC: what was confusing ?
09:31:15 <b_> :pl (\x -> isTagOpen x && "//" `isPrefixOf` fromAttrib "href" x)
09:31:17 <Greg-UBC> jedai: cant find any documentation whatsoever other than the examples package
09:31:26 <b_> what's the command for pointfree?
09:31:37 <srhb> @pl
09:31:37 <lambdabot> (line 1, column 1):
09:31:37 <lambdabot> unexpected end of input
09:31:37 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
09:31:39 <srhb> oops
09:31:40 <Greg-UBC> jedai:  and it dosnt seem quite *there* yet
09:31:40 <srhb> :)
09:31:47 <b_> @pl (\x -> isTagOpen x && "//" `isPrefixOf` fromAttrib "href" x)
09:31:48 <lambdabot> liftM2 (&&) isTagOpen (("//" `isPrefixOf`) . fromAttrib "href")
09:31:50 <b_> hehe thanks
09:31:51 <srhb> Greg-UBC: I made a snake game with Gloss, it's awesome :P
09:31:58 <armlesshobo> welp, java 8 supports lambda functions. i think it's time to abandon ship, all. :P
09:32:14 <srhb> Greg-UBC: And the docs on hackage are fairly clear?
09:32:28 <spobat> wzm
09:32:38 <jedai> Greg-UBC: I'm not sure what you mean by that ? Sure it's not super robust super complete awesome library but that seems a bit contradictory with your objective ?
09:32:58 <DexterLB> so, what I'm trying to do is traverse a list, for example [1, 2, 3, 4, 5, 6, 7, 8] by pairs like this: (1, 2), (2, 3), (3, 4) etc. I made a function to do it and it works, but is there an easier way?
09:33:00 <hpaste> DexterLB pasted “pairMap” at http://hpaste.org/70425
09:33:08 <srhb> DexterLB: zip?
09:33:47 <srhb> map (\(x,y) -> x*y) . zip $ [1,2,3,4,5,6]
09:33:51 <srhb> > map (\(x,y) -> x*y) . zip $ [1,2,3,4,5,6]
09:33:52 <lambdabot>   Couldn't match expected type `[(t, t)]'
09:33:52 <lambdabot>         against inferred type `[b] ...
09:33:55 <srhb> arf arf
09:34:02 <glguy> :t zipWith
09:34:03 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
09:34:33 <MostAwesomeDude> :t \f xs -> zipWith f xs (tail xs)
09:34:34 <lambdabot> forall a c. (a -> a -> c) -> [a] -> [c]
09:34:37 <MostAwesomeDude> ^^
09:34:44 <srhb> that's what I meant!
09:34:45 <srhb> :P
09:34:46 <MostAwesomeDude> Although you'd better make sure that xs isn't empty!
09:35:03 <jedai> DexterLB: zip with the tail of the list
09:35:16 <DexterLB> jedai: interesting thought
09:35:38 <armlesshobo> > 1:[]:2:[]:[]:3
09:35:39 <lambdabot>   No instances for (GHC.Num.Num [a], GHC.Num.Num [[a]])
09:35:39 <lambdabot>    arising from a use...
09:35:49 <armlesshobo> ... oops
09:36:02 <jedai> > let pairMap f xs= map f (zip xs $ tail xs) in pairMap id [1..5]
09:36:03 <lambdabot>   [(1,2),(2,3),(3,4),(4,5)]
09:36:57 <DexterLB> and I suppose this is way faster than recursion?
09:37:13 <jedai> You'll want uncurry to have exactly the same semantics
09:37:18 <MostAwesomeDude> Well, map and zipWith are both recursive, but you don't have to worry about that.
09:37:20 <jedai> DexterLB: Maybe not
09:37:44 <jedai> DexterLB: though it may fuse better (so much faster in a pipeline of functions)
09:39:17 <Greg-UBC> shrb: that's cool! any chance i could see the code?
09:39:41 <srhb> Greg-UBC: Hmmm! I'm a bit scared about showing it since it's probably kind of nooby. :D
09:39:50 <mun> hi
09:39:51 <mun> higher-order unification is undecidable, but what does that actually mean?
09:39:59 <Greg-UBC> srhb: haha dont worry, i just started haskell a week ago myself
09:40:25 <jedai> DexterLB: Basically, using combinator is not faster per se than using direct recursion since the combinators use recursion but since the combinators are more "principled" they're more appropriate to optimization rules
09:40:26 <tac-tics> mun: it probably means you can't use Hindley Milner with higher rank types.
09:40:55 <srhb> Greg-UBC: PM me your e-mail then :)
09:41:05 <EvanR> and combinators are easier to use
09:41:22 <John_14350761640> What do you mean principled? Does that mean the compiler has more guarantees about the code?
09:41:30 <tac-tics> mun: For example, System F. System F doesn't allow you to figure out the types from the definition of a funciton.
09:41:44 <mun> right
09:42:21 <tac-tics> mun: Haskell isn't as powerful as system F, because you can only do rank 1 polymorphism (by default).
09:42:24 <mun> tac-tics, but in technical terms, what does that actually mean? there's no algorithm that can discover the unifiers to a unification problem?
09:43:19 <jedai> John_14350761640: Yes, direct recursion is "too powerful" so it could do too many things with the data, the combinators usually have pretty simple algebraic rules on them (like map f . map g == map (f.g))
09:43:29 <tac-tics> mun: I'm not sure about the details :)
09:44:28 <tac-tics> mun: But my educated guess would be that unification performs evaluation at the type level.
09:44:59 <tac-tics> mun: And since you're evaluating something *while* you type check it, there's the possibility that the thing you're evaluating will get stuck in a loop.
09:45:09 <mun> tac-tics, right. but then it's also said that higher-order unification is semidecidable by Huet's algorithm.
09:45:17 <mun> so is it undecidable or semidecidable...
09:45:48 <tac-tics> Obviously, it will typecheck some things right :) I'm not sure of what semidecidable means.
09:47:08 <tac-tics> In any case, from a pragmatic standpoint, having your typechecker loop on a bad program isn't too useful.
09:48:12 <mun> hmm
09:48:31 <ptrf> ok, i'm reading through the typeclassopedia (http://www.haskell.org/haskellwiki/Typeclassopedia) and trying to do the first exercises, defining Functor instancens for Either e and ((->) e)
09:49:29 <ptrf> for Either, I just had instance Functor (Either e) where fmap _ (Left e) = Left e; fmap g (Right a) = Right (g a)
09:49:34 <ptrf> so, that was kind of easy
09:50:11 <jamiltron> ptrf: I'm doing the same thing!
09:50:27 <ptrf> but I'm completely stumbling when doing ((->) e)
09:50:43 <srhb> ptrf: Have you thought about the type for fmap?
09:50:54 <ptrf> hej srhb :)
09:51:03 <srhb> ptrf: Hej :D
09:51:12 <ptrf> yes, i have, but i mean
09:51:18 <EvanR> (a -> b) -> f a -> f b
09:51:25 <ptrf> i know :)
09:51:40 <ptrf> the thing is, instance Functor ((->) e) where ...
09:51:41 <EvanR> all i see is 'composition' screaming out at me ;)
09:51:47 <EvanR> if f were like a function
09:51:59 <EvanR> and not a type function
09:52:31 <ptrf> for the maybe functor you have just a or nothing
09:52:33 <tac-tics> @type (.)
09:52:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:52:52 <ptrf> for the either, you have left and right
09:52:57 <Saizan> mun: btw, something can be both undecidable and semidecidable, the two contradict each other
09:53:11 <Saizan> mun: *the two don't contradict, sorry
09:53:12 <srhb> ptrf: But there's no other function constructor, so you don't need to worry about that.
09:53:55 <ptrf> hmmm
09:54:03 <ptrf> i'm chewing on it for a bit
09:54:08 <srhb> ptrf: Ok :)
09:54:20 <EvanR> stick that in your pipe and smoke it
09:54:24 <jamiltron> While we're on the subject of the typeclassopedia, can I get some help regarding ((,) e)?
09:54:32 <srhb> ptrf: What I meant about the type, by the way, is inserting the type of the given functor into the actual type signature of fmap instead of 'f'
09:54:47 <jamiltron> Defining a Functor instance for ((,) e), that is.
09:54:50 <srhb> jamiltron: Same afvice for you
09:54:53 <srhb> advice, too
09:55:28 <jamiltron> Hmm
09:55:48 <srhb> jamiltron: Once you've written that type signature, you're basically done.
09:56:00 <mun> Saizan, hmm why's that? my understanding that semidecidability means there's an algorithm that halts at a particular set of recursively enumerable of things. undecidability doesn't guarantee such an algorithm to exist, right?
09:56:06 <jamiltron> the type signature for fmap?
09:56:27 <srhb> jamiltron: Yes, but with the specific instance in mind. So replace f with your ((,) e) in a way that makes sense for you
09:56:28 <Saizan> mun: right, but doesn't claim it doesn't either
09:57:33 <mun> Saizan, right. so is HO unification undecidable or semidecidable? http://en.wikipedia.org/wiki/Unification_(computer_science) says that it is undecidable, but Huet has a semi-decidable algorithm.
09:57:42 <jamiltron> So ((,) e) is just a -> (e, a)
09:57:46 <Saizan> mun: it can be both!
09:57:59 <srhb> jamiltron: Right.
09:58:00 <EvanR> :t (,) e
09:58:02 <lambdabot> forall b. b -> (Expr, b)
09:58:02 <Saizan> mun: but i don't know the details
09:58:12 <ptrf> so, fmap g h = h . g
09:58:21 <srhb> ptrf: RIght :)
09:58:25 <mun> Saizan, right
09:58:33 <EvanR> :t flip fmap
09:58:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
09:58:36 <srhb> er.. Backwards. isn't it
09:59:29 <Saizan> mun: it seems like Huet has a way of enumerating unifiers (not guaranteeing them to be most general though)
10:00:29 <ptrf> :t (,)
10:00:30 <lambdabot> forall a b. a -> b -> (a, b)
10:00:45 <ptrf> :t (->)
10:00:46 <lambdabot> parse error on input `->'
10:01:28 <srhb> ptrf: That's a bit strange, I think it only exists on the type level
10:01:39 <ptrf> yes
10:01:43 <jamiltron> Yeah, I'm still chewing on (,). My initial reaction is to do something like (\x -> let (y,z) = h x in (g y, g z)) but that's not the right answer.
10:02:21 <ptrf> :t ((,) e)
10:02:22 <lambdabot> forall b. b -> (Expr, b)
10:02:47 <srhb> fmap :: (a -> b) -> (e,a) -> (e,b) -- right jamiltron?
10:03:00 <jamiltron> srhb: Right.
10:03:11 <srhb> jamiltron: Still nothing? :-)
10:03:33 <jamiltron> srhb: Honestly I think its right under my nose but I just haven't realized it yet.
10:03:44 <srhb> jamiltron: Yeah, I think so too.
10:04:21 <DexterLB> can't I have two data types that have a "member" with the same name?
10:04:36 <mun> is a second-order expression an expression with no function variable taking functions as arguments? but isn't a function taking functions as arugments a second-order term?
10:05:48 <fmap> DexterLB: if you are talking about records then no
10:05:54 <mun> or is something like f(\lambda x. x) make f a third-order term?
10:06:08 <roconnor_> edwardk: but you spent so much time on recursion schemes :(
10:06:28 <DexterLB> fmap: so there can't be different functions with different type signatures but identical names
10:06:50 <fmap> in the same namespace
10:06:56 <ptrf> srhb: /55
10:07:03 <ptrf> oopw
10:07:43 <ptrf> :t (.)
10:07:44 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:09:03 <fmap> DexterLB: or rather there can be but you can't use any of them without qualification because of ambiguity
10:09:20 <DexterLB> fmap: that's sad
10:09:50 <Dtgr> why isn't there a Show instance for UTCTime?
10:10:17 <fmap> Dtgr: there is
10:10:24 <DexterLB> Dtgr: there is, used it 5min ago :D
10:10:45 <Dtgr> where is it? i've imported Data.Time with no luck
10:14:17 <fmap> Dtgr: well, it's defined in Data.Time.LocalTime.LocalTime, but Data.Time should re-export it.
10:15:18 <Dtgr> hm
10:17:09 <Dtgr> ah, upgrading haskell-platform helped :)
10:19:06 <tgeeky> so, if there's a general pattern here (regarding properties that division algebras have) we have that:    [ commutative subRing <- (q,q) , associative SubAlg <- (o,o) , (power) associative SubAlg <- (s,s) ]  where q = quaternions, o = octonions, s = sednions.  But what's at the head of this list? [ distributive Alg < - (c,c) ]?
10:20:28 <tgeeky> yeah. I guess it's that you get a real and imaginary function part?
10:25:26 <teneen> when will the ConstraintKinds (or any other) trick be used in the standard typeclasses such as Monad, to allow restricted instances?
10:25:55 <tgeeky> if ever, after they work correctly and have done so for a few public releases?
10:25:56 <rwbarton> don't hold your breath
10:26:12 <tgeeky> 7.8 would be the earliest possible, so probably 8.x :O
10:26:31 <teneen> tgeeky: I don't find any problems with the ConstraintKinds solution
10:26:33 <rwbarton> my guess would be "never"
10:26:33 <srhb> Actually, that would be Haskell standard tied, not GHC tied, wouldn't it
10:26:50 <tgeeky> yes. We're talking about a redefinition of the Prelude
10:27:53 <teneen> Can I import the Prelude without importing the Monad Class?
10:28:20 <tgeeky> yes, with judicious use of hiding (..); but you will break every single monad out there, I think?
10:29:52 <keseldude> import Prelude hiding (Monad(..)) seems to work
10:30:20 <tgeeky> keseldude: now import a monad from anywhere
10:30:31 <rwbarton> if you want to use do notation with a custom Monad class you will need to use -XImplicitPrelude
10:30:45 <tgeeky> +No
10:30:48 <rwbarton> and of course write all your own Monad functions and classes
10:30:51 <rwbarton> *instances
10:31:25 <teneen> rwbarton: hiding Monad will not suffice?
10:31:40 <rwbarton> suffice for what
10:31:43 <lispy> For those of you looking for a job, Galois is hiring again: http://www.haskell.org/pipermail/haskell-cafe/2012-June/101978.html
10:32:23 <keseldude> all you get from hiding Monad(..) is that (>>=), (>>), etc. are out of scope
10:32:29 <teneen> rwbarton: Using do notation for a custom monad?
10:32:38 <rwbarton> correct, then you need to do what I said
10:32:49 <hpaste> stj pasted “ridiculous! how is this function not tail recursive?” at http://hpaste.org/70429
10:33:13 <mauke> stj: it is tail recursive
10:33:19 <teneen> rwbarton: I need the functions in the Prelude, so I want to "import Prelude hiding (Monad(..))"
10:33:21 <stj> it completely fills my memory
10:33:24 <mauke> stj: yes
10:33:30 <rwbarton> non-Monad related functions?
10:33:32 <mauke> that has nothing to do with whether it's tail recursive
10:33:44 <stj> mauke: oh, I see... lazyness, right?
10:33:45 <teneen> rwbarto: I'll define my on monad class, and the instances.
10:33:48 <mauke> stj: yes
10:33:55 <mauke> stj: the function isn't strict in g and s
10:34:03 <mauke> so it very efficiently builds a huge thunk
10:34:03 <rwbarton> you can use -XNoImplicitPrelude and import the functions from Prelude you want explicitly
10:34:39 <rwbarton> oh yeah that's what tgeeky meant by "No", sorry I got the language flag name wrong the first time
10:35:28 <rwbarton> like import Prelude (length, (.), ...) -- whatever
10:35:51 <stj> mauke: nice! banging the arguments helped a lot... do I have any nice alternatives to using bang patterns?
10:36:00 <mauke> seq
10:36:02 <stj> since they are not, well, standard haskell
10:36:13 <mauke> $!
10:36:36 <teneen> keseldude: Can I then define my own monad class with the same method names and use do-notation?
10:37:27 <keseldude> you'd have to redefine every monad
10:37:48 <keseldude> I don't know if do notation would work
10:37:53 <rwbarton> with -XNoImplicitPrelude do notation will just use whatever (>>=)/(>>)/fail are in scope. doesn't have to be in a "Monad" class, or even a class at all
10:37:55 <tac-tics> teneen: No, you can't do that.
10:38:02 <keseldude> oh ok
10:38:14 <timthelion> Is there something lighter than ncurses for haskell terminal interfaces?
10:38:19 <tac-tics> teneen: Is there something in particular you're trying to do? Or are you just curious?
10:39:30 <timthelion> ncurses won't build : dist/build/UI/NCurses.chs.h:5:29: fatal error: ncursesw/curses.h: No such file or directory
10:39:31 <teneen> tac-tics: I do not want to use -XNoImplicitPrelude since I don't want to mention each function I want from the Prelude explicitly. I just want to mention the functions which I do not want!
10:39:35 <stj> just curious, have you guys rewritten a good part of standard library (Data.List, monads, functors) for better understanding/practice?
10:39:45 <teneen> tac-tics: Which is the Monad typeclass
10:40:30 <fmap> timthelion: vty/vty-ui
10:41:04 <tac-tics> teneen: Just a guess, but have you tried no implicit prelude, then importing *just* the Monad typeclass from the Prelude?
10:41:12 <timthelion> fmap: thanks
10:41:26 <rwbarton> you can also use -XNoImplicitPrelude and then use import Prelude hiding (...) I guess
10:41:35 <rwbarton> but you *must* use -XNoImplicitPrelude to do what you want
10:41:55 <roSievers> hi, could someone tell me what is wrong with my pattern matching? http://www.pasteall.org/33241/haskell
10:42:13 <rwbarton> as otherwise do notation refers to Prelude.(>>=), etc. regardless of whether they have been hidden by an "import Prelude" declaration
10:42:25 <stj> roSievers: inv _:0:f must be inv (_:0:f)
10:42:26 <tac-tics> roSievers: Parens
10:42:27 <teneen> tac-tics: the Monad class is what I **do not** want
10:42:44 <teneen> rwbarton: I'll consider this, thanks!
10:42:45 <roSievers> ah ok, thank you :-)
10:42:56 <roSievers> haven't done this in a while
10:44:20 <Taneb> Can someone suggest something interesting for me to play around with?
10:44:49 * hackagebot wai 1.2.0.3 - Web Application Interface.  http://hackage.haskell.org/package/wai-1.2.0.3 (MichaelSnoyman)
10:44:51 * hackagebot wai-app-static 1.2.0.4 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-1.2.0.4 (MichaelSnoyman)
10:44:53 * hackagebot wai-eventsource 1.2.0.3 - WAI support for server-sent events  http://hackage.haskell.org/package/wai-eventsource-1.2.0.3 (MichaelSnoyman)
10:44:55 * hackagebot warp 1.2.2 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.2.2 (MichaelSnoyman)
10:45:02 <heatsink> Taneb, have you tried the Euler project?
10:45:19 <Taneb> Yeah, I get stuck about 25
10:45:39 <DMcGill> Taneb: Typeclassopedia has exercises going through
10:45:50 <Taneb> I've done 30 problems from the Euler project
10:46:02 <mm_freak> Taneb: write a real application
10:46:14 <Taneb> mm_freak, aww, but real things are boring
10:46:15 <DMcGill> where are you at? LYAH's later chapters also have exercises and might contain new things
10:46:30 <DMcGill> or there's always HOpenGL
10:46:33 <mm_freak> that's not only a challenge, but it actually helps you learn how to actually write software with haskell =)
10:46:36 <mm_freak> Taneb: no, real things are boring in C++
10:46:59 <Taneb> DMcGill, I've finished LYAH
10:47:05 <Taneb> Haven't seen HOpenGL
10:47:18 <DMcGill> @where BeautifulCode
10:47:19 <lambdabot> I know nothing about beautifulcode.
10:47:24 <mm_freak> Taneb: few of my projects use less than 5 interesting haskell-only technologies (FRP, lenses, concurrency, acid-state, etc.)
10:47:27 <jfischoff> ?where simply easier
10:47:27 <lambdabot> I know nothing about simply.
10:47:49 <Taneb> brb
10:47:50 <jfischoff> Taneb: maybe http://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html
10:47:53 <DMcGill> http://www.renci.org/wp-content/pub/tutorials/BeautifulCode.pdf
10:47:59 <DMcGill> is where I learnt hopengl from
10:48:06 <DMcGill> how do you add a 'where' to lambdabot?
10:48:25 <mm_freak> jfischoff: that's a dangerous post =)
10:48:27 <jfischoff> DMcGill: yeah thanks for the reminder
10:48:51 <jfischoff> oh, how so?
10:49:13 <mm_freak> it made me read lots of papers and write lots of (essentially equivalent) implementations of a dependently typed lambda calculus…  and i'm still working on my compiler, now side by side to reading the STG paper
10:49:34 <jfischoff> hehe
10:49:47 <jfischoff> yeah, I know what you mean
10:49:57 * hackagebot warp-tls 1.2.1 - SSL support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-1.2.1 (MichaelSnoyman)
10:52:25 <jfischoff> mm_freak: I've been thinking about the STG a little, and wondering if there is a way to make something similar but gives adaptive computing implicitly. Maybe you can speak to that one way or another...
10:52:47 <mm_freak> jfischoff: adaptive?
10:53:04 <solrize> With version 0.8.0:
10:53:04 <solrize>     Node got a lot faster.
10:53:07 <solrize> hmm
10:53:55 <Taneb> Hmm
10:54:32 <jfischoff> mm_freak: Adaptive computing or incremental computing is a way to things where if your inputs change you only recalculate the parts of the program that depend on those inputs
10:55:04 <mm_freak> jfischoff: oh, i'm doing this at framework level…  netwire 4.0 will do that
10:55:14 <mm_freak> it actually already does, but it's not released yet
10:55:32 * jfischoff is looking up netwire
10:56:48 <DMcGill> @pl f x = g (h x)
10:56:49 <lambdabot> f = g . h
10:57:17 <DMcGill> @pl f x y = g (h x) y
10:57:18 <lambdabot> f = g . h
10:57:37 <kevinquinnyo> very new to computer science in general, vague question not sure how to ask so here goes:
10:58:04 <kevinquinnyo> haskell compiles to machine code, but you can also `runhaskell` before compiling
10:58:12 <kevinquinnyo> is this unique, or are there other languages that do this?
10:58:16 <jfischoff> mm_freak: net wire its more low level then I would want. I would like to write code that is more like normal haskell code, and have a translation step later handle efficient evaluation
10:58:24 <kevinquinnyo> and if ther's a FAQ that answers this somewhere link me please
10:58:24 <Botje> kevinquinnyo: lisp did it before
10:58:41 <jfischoff> mm_freak: which is why I was thinking of making a different STG
10:58:45 <kevinquinnyo> Botje: thanks did not know that
10:58:57 <mm_freak> jfischoff: huh?  as i understand it netwire is then higher level
10:58:58 <Botje> kevinquinnyo: then again, that's a safe answer for every language feature ;)
10:59:21 <mm_freak> jfischoff: also i don't see how you could do that sensibly at the STG level without building FRP right into the compiler
10:59:38 <S11001001> kevinquinnyo: ocaml as well, there are native and nonnative schemes (among other lisp)
10:59:39 <jfischoff> mm_freak: yes I want FRP built in.
10:59:47 <Botje> kevinquinnyo: there is no reason you can't write an interpreter for java or C/C++
10:59:51 <S11001001> even java :)
11:00:00 <mm_freak> jfischoff: a few people have done that, but it's not pretty…  i think that FRP doesn't belong to that level
11:00:00 <Botje> people have, i think
11:00:10 <S11001001> csharp repl for c# from mono probably does it
11:00:40 <kevinquinnyo> didn't know that either, and whenever i've played with C, i find testing/debugging to be very time consuming because of having to compile
11:00:51 <kevinquinnyo> so i'm having fun with haskell
11:01:12 <kevinquinnyo> thanks for answers
11:01:15 <kevinquinnyo> back to it
11:01:42 <mm_freak> kevinquinnyo: haskell is very different in that regard…  i often write pages of code for hours never testing it once, and then testing hours later
11:02:01 <jfischoff> mm_freak: I can't say one or another. But most of the FRP libraries that I have seen require a lot of noise to allow for efficient implementations and I think that should something the runtime should handle.
11:02:17 <jfischoff> mm_freak: in the sense that I don't want to think about it
11:02:46 <mm_freak> jfischoff: i can't speak for other FRP libraries, but netwire easily reaches 100-200 million FPS
11:03:03 <mm_freak> that's netwire 3…  netwire 4 even outperforms that
11:03:05 <carter_> mm_freak looks pretty cool, whats the use case  and whats "FPS" and acronymm for here
11:04:00 <mm_freak> carter: frames per second, and netwire is a generic FRP library that i use mainly for networking
11:04:06 <carter> ok
11:04:12 <carter> wheres 4 live?
11:04:38 <carter> mm_freak: also, for some of my own projects i'm trying to get a handle on the phase space of current state of the art FRP designs
11:05:03 <mm_freak> carter: 4.0 is not online yet…  it's still under active development
11:05:18 <carter> mm_freak : cool, whats the high level difference?
11:05:28 <mm_freak> the current phase space contains mainly reactive-banana and also to a smaller extent netwire
11:05:39 <carter> mm_freak: i've a few projects that are in that state myself :)
11:05:43 <carter> ok
11:06:01 <carter> whats the distinctions between them abstraction / internals wise?
11:06:08 <carter> (as a domain expert)
11:06:12 <srhb> Is it possible to do the typeclassopedia exercises without getting all sorts of errors about duplicate definitions?
11:06:13 <carter> in your mind
11:06:24 <srhb> I think I remember doing that once, but now I can't recall.
11:06:38 <Saizan> srhb: import Prelude () ?
11:06:44 <mm_freak> carter: well, they are completely different…  reactive-banana follows the classic FRP paradigm, while netwire has a novel concept based on AFRP
11:07:03 <carter> afrp = "asynchronous" frp ?
11:07:19 <carter> arrowized
11:07:19 <mm_freak> in reactive-banana you have behavious and events, while in netwire you have producing/inhibiting signal functions (and as of netwire 4 also suspending and forking)
11:07:20 <carter> gotcha
11:07:40 <mm_freak> the A stands for Arrowized, yes, but i tend to prefer to call it Applicative nowadays =)
11:08:06 <solrize> bah i typed "frp tutorial" into firefox search bar and it popped up a bunch of ftp tutorials (instead of frp)
11:08:18 <carter> mm_freak: anything more recent than http://haskell.cs.yale.edu/wp-content/uploads/2011/02/workshop-02.pdf ?
11:09:05 <mm_freak> carter: about AFRP?  doubt it…  there is little documentation
11:09:14 <mm_freak> enough to get started, though
11:09:25 <mm_freak> i have mainly learned it by reinventing it =)
11:09:34 <srhb> Saizan: Then I have to duplicate the type classes and types needed though. Hmm
11:10:11 <EvanR> re frp tutorial, is the reactive banana documentation not enough?
11:10:23 <mm_freak> EvanR: reactive-banana is not AFRP
11:10:28 <EvanR> right
11:10:53 <carter> mm_freak : ok, cool! I've been trying to sort out whether certain ideas i've been playing with that relate to that space are new or not
11:10:58 <EvanR> re 'googling for frp tutorial'
11:11:06 <carter> so i've beent trying to collect background work etc
11:11:10 <carter> to evalute it
11:11:22 <carter> though it looks like the answer thus far is "yes, it'll be new"
11:11:26 <Saizan> srhb: import Prelude (..only what you need..) ?
11:11:30 <carter> (once I get around tow working on it)
11:11:31 <mm_freak> carter: care to share your ideas?
11:11:53 <Saizan> srhb: you might need to do both the () and the ( .... ) imports
11:12:24 <srhb> Saizan: Seems the instances are always imported, even with (). Ah well.
11:12:36 <Saizan> ah, yeah
11:12:40 <geekosaur> instances are always imported, yeh
11:13:49 <edwardk> roconnor_: i learned a lot
11:15:30 <timthelion> How do I get the current user's home directory???  I thought perhaps "homeDirectory" would help me, but it requires a UserEntry, and I thought perhaps one of the get functions would help, but they all require an ID or username... Simplest command possible and it's impossible, or takes at least 3 lines of code?!
11:16:05 <geekosaur> getEnv "HOME"
11:16:11 <timthelion> :)
11:16:13 <timthelion> thanks
11:16:22 <heatsink> Does that work in Windows?
11:16:26 <geekosaur> if you want portable, you will quickly learn why there's no simple way to do it
11:16:37 <mauke> I bet there's a simple way
11:16:37 <timthelion> What's Windows?
11:16:39 <timthelion> :)
11:16:46 <geekosaur> because the concept is at best weak
11:17:06 <srhb> System.Directory.getHomeDirectory
11:17:20 <srhb> Depending on need, getAppUserDataDirectory
11:17:25 <timthelion> geekosaur: one wouldn't know if they wanted "My Documents" or the user's documents and settings directory..
11:17:27 <geekosaur> (on Windows you are supposed to use a different path for different kinds of things... like that)
11:17:49 <mauke> http://hackage.haskell.org/packages/archive/directory/latest/doc/html/System-Directory.html#v:getHomeDirectory
11:18:03 <geekosaur> and of course if you're being strict about XDG compliance then there's some similar dances needed
11:18:12 <mauke> getAppUserDataDirectory
11:18:13 <geekosaur> (on unixlikes)
11:18:24 <srhb> mauke: Hah, beat you
11:18:39 <geekosaur> so, you shoot down your own "simplest command possible"
11:19:07 <mauke> srhb: you win this round
11:19:13 * srhb cowers
11:20:07 <timthelion> geekosaur: I was annoid, since apparently neither "~/.xinitrc" nor "$HOME/.xinitrc" are valid paths according to System.Directory.  Which is technically a bug in the first case...  Though not one I'm going to waste my time reporting.
11:20:30 <rwbarton> ...
11:20:37 <geekosaur> wrong
11:20:43 <srhb> How is that a bug?
11:20:49 <geekosaur> ~ and $HOME are meaningful to the shell
11:20:53 <rwbarton> those are expanded by your shell
11:21:07 <geekosaur> they can NOT be meaningful to the kernel, not without opening up a massive pile of security holes
11:21:19 <rwbarton> try echo ~/.xinitrc, echo $HOME/.xinitrc
11:21:30 <geekosaur> and, this is not Haskell specific
11:21:44 <srhb> To put it differently: That's not a bug. :P
11:23:13 <armlesshobo> right
11:23:35 <timthelion> What security hole would be opened by that?
11:23:36 <armlesshobo> if that was a bug, then a lot of applications are buggy :P
11:23:44 <armlesshobo> timthelion: nothing
11:23:58 <mm_freak> edwardk: i have defined a Comonad instance for 'data Bottom a' with 'extract _ = error "Stop proving bottom!"'…  do you think that's sensitive?
11:24:23 <geekosaur> timthelion:  what, allowing paths to include arbitrary *user-specified* paths?
11:24:33 <armlesshobo> geekosaur: it's irrelevant to the kernel
11:24:36 <geekosaur> (and yes, ~ is user specified, it is $HOME)
11:25:00 <Eduard_Munteanu> mm_freak: what's Bottom?
11:25:01 <geekosaur> armlesshobo, what are you on about now?
11:25:13 <mm_freak> Eduard_Munteanu: i've written its whole definition there in quotes
11:25:29 <Eduard_Munteanu> Ah.
11:25:59 <Eduard_Munteanu> mm_freak: I think that's only valid for Bottom Void
11:26:25 <Eduard_Munteanu> Or...
11:26:26 <Eduard_Munteanu> Hm.
11:26:34 <mm_freak> Eduard_Munteanu: you can't construct a Bottom value anyway
11:26:43 <mm_freak> but i need the Comonad instance
11:26:51 <Eduard_Munteanu> What for? :)
11:27:20 <mm_freak> instance (Comonad f) => ArrowLoop (Wire e s f)
11:27:31 <mm_freak> 'extract' is necessary for the suspension functor 'f' for feedback
11:27:44 <mm_freak> otherwise the feedback loop is broken by suspension
11:27:54 <mm_freak> "suspension" as in monad-coroutine, but a custom implementation of that
11:31:44 <Taneb> Niave recursion has got the better of me once again
11:34:54 <Taneb> class SortOfComonad w where sortOfExtract :: w a -> Maybe a
11:35:08 <DMcGill> @pl f<$> x <*> y
11:35:09 <lambdabot> f <$> x <*> y
11:35:30 <DMcGill> @pl g x y = f <$> x <*> y
11:35:31 <lambdabot> g = ((f <$>) .) . (<*>)
11:35:54 <mm_freak> Taneb: s/SortOfComonad/WithNaturalTransformationToMaybe/
11:36:06 <timthelion> is there any example program or tutorial for vty?  I found benchmarks, but nothing that shows anything usefull.
11:36:10 <Taneb> SortOfComonad is shorter
11:36:20 <mm_freak> and that's not what i want anyway…  i really need 'extract' the way it's defined =)
11:36:25 <Kakadu> hi! Can you give me a tip how to execute program in leksah? Menu item package->Run writes '========== 127 ==========================' to log and nothing more...
11:36:35 <Taneb> Nah, I'm just thinking outload
11:36:37 <Taneb> *loud
11:36:52 <Taneb> Completely irrelevant to your needs
11:37:17 <mm_freak> i see
11:37:29 <Eduard_Munteanu> timthelion: if I'm not mistaken, cheater_ might've blogged an example on that
11:37:36 * Eduard_Munteanu looks
11:38:16 <Eduard_Munteanu> timthelion: http://cheater.posterous.com/haskell-curses
11:38:25 <timthelion> thankyou
11:39:46 <identity> Is there anything good out there for reflection in haskell? I'm thinking stuff like, say, presenting a list of modules to the user to load, and then being able to call functions from them. I'm googling it right now, but I thought I would ask here anyway.
11:40:18 <mm_freak> identity: reflection or dynamic loading?
11:40:46 <identity> mm_freak: Well, I'm using reflection because I was able to do what I'm describing in C# using what they called reflection.
11:40:47 <mm_freak> for reflection in the haskell sense there is the 'reflection' library
11:41:00 <identity> It may be a misnomer
11:41:08 <identity> Dynamic loading would work as well, I guess
11:41:13 <Taneb> This is the first time I've ever tried to use zipWith7
11:41:19 <Taneb> And I thought it was useless...
11:41:36 <mm_freak> Taneb: you may be interested in the ZipList functor
11:42:11 <Taneb> mm_freak, let me try to get this working and I'll look at that when I give up
11:42:25 <aristid> :t ala
11:42:26 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
11:42:27 <mm_freak> for ZipList "f <$> xs <*> ys <*> zs" corresponds to "zipWith f xs ys zs"
11:42:31 <fmap> timthelion: vty-ui has awesome manual
11:42:33 <aristid> :t ala ZipList
11:42:33 <Taneb> Right, I'm giving up
11:42:34 <lambdabot> forall a b n' o'. (Newtype n' o') => (([a] -> ZipList a) -> b -> n') -> b -> o'
11:43:04 <fmap> timthelion: http://jtdaugherty.github.com/vty-ui/manuals/vty-ui-users-manual-1.5.pdf
11:43:15 <Taneb> Unless there's a function that's (a -> a) -> a -> a -> a -> a -> a -> a -> a
11:43:31 <Taneb> -> a
11:43:39 <mm_freak> you can also define S and K combinators for ordinary lists
11:44:42 <timthelion> fmap: thanks
11:46:04 <mm_freak> > let (f:fs) ~*~ (x:xs) = f x : (fs ~*~ xs); _ ~*~ _ = []; k x = [x] in k (\x y z -> (x,y,z)) ~*~ [10..19] ~*~ [20..29] ~*~ [30..39]
11:46:05 <lambdabot>   [(10,20,30)]
11:46:19 <mm_freak> > let (f:fs) ~*~ (x:xs) = f x : (fs ~*~ xs); _ ~*~ _ = []; k x = repeat x in k (\x y z -> (x,y,z)) ~*~ [10..19] ~*~ [20..29] ~*~ [30..39]
11:46:20 <lambdabot>   [(10,20,30),(11,21,31),(12,22,32),(13,23,33),(14,24,34),(15,25,35),(16,26,3...
11:46:58 <Taneb> Oh god, I'm the person who wrote the most controversial Haskell program on Uncyclopedia
11:46:58 <mm_freak> > let (f:fs) ~*~ (x:xs) = f x : (fs ~*~ xs); _ ~*~ _ = []; k x = repeat x in k (\x y z -> (x + y + z, x, y, z)) ~*~ [10..19] ~*~ [20..29] ~*~ [30..39]
11:47:00 <lambdabot>   [(60,10,20,30),(63,11,21,31),(66,12,22,32),(69,13,23,33),(72,14,24,34),(75,...
11:47:01 <srhb> what is a "skolem" type variable?
11:49:17 <otters> :t let a = a in a
11:49:19 <lambdabot> forall t. t
11:49:43 <otters> > let a = a in a
11:49:47 <lambdabot>   mueval-core: Time limit exceeded
11:50:26 <DMcGill> wow, I did not know that the Reader monad is just ((->) e)
11:50:29 <DMcGill> mind, blown, etc
11:50:29 <codolio> A skolem is a type of variable that only unifies with itself (or, unground unification variables).
11:52:01 <codolio> So, if a and b are distinct skolems, then a will not unify with b, and neither will unify with, say, Integer.
11:52:57 <rwbarton> you can think of a skolem variable as representing some constant but unknown type
11:53:43 <srhb> I wonder if it's a good thing that I keep typing return instead of unicorn in these exercises. Something must be settling, finally.. :-)
11:54:51 <Baughn> DMcGill: Reader is not exactly (e ->), it's a newtype around that
11:54:56 <Baughn> Otherwise, yeah. :)
11:58:54 <DMcGill> @pl h e = f e (g e)
11:58:55 <lambdabot> h = ap f g
11:59:14 <Baughn> @type ap
11:59:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
11:59:21 <EvanR> so is arrowized frp 'more powerful' than applicative frp?
12:00:21 <mm_freak> EvanR: not per se
12:00:51 <heatsink> So a rigid type variable is a skolem variable?
12:01:13 <Baughn> heatsink: skolem is just a metasyntactic variable. It has no more meaning than foo.
12:01:17 <EvanR> mm_freak: is it a style thing?
12:01:45 <Baughn> heatsink: It's not a class, or anything.. just "Some type"
12:02:08 <heatsink> So is a unifiable type variable
12:02:39 <heatsink> In GHC terminology, there are rigid and flexible type variables.  codolio's description sounded like rigid type variables
12:03:23 <codolio> I don't think GHC uses that terminology anymore.
12:03:32 <codolio> Or at least, it mentions skolems somtimes now.
12:03:37 <mm_freak> EvanR: paradigm…  mainly about the achilles' heel of FRP:  events
12:03:55 <heatsink> ok
12:04:15 <Saizan> actually the meta-variables are the non-skolem ones
12:12:39 <srhb> @hoogle (a -> m b) -> [a] -> m [b]
12:12:40 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
12:12:40 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
12:12:40 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
12:12:46 <srhb> Ah..
12:13:36 <EvanR> for loops yay
12:13:38 <EvanR> :)
12:13:47 <srhb> ^^
12:14:04 <applicative> Am I right that it's bad news if someone ends with a new locally installed Cabal library in addition to a globally installed one that came with their ghc or the Haskell platform
12:14:06 <EvanR> 'you can write C code in any language'
12:14:22 <applicative> if someone ends up with one, rather
12:14:54 <geekosaur> applicative, usually it's a bad sign, yes
12:15:21 <geekosaur> sometimes it's necessary (tracking yesod, for example...) but then you need to use great care with other stuff
12:15:45 <bartavelle> I suppose there are operators defined for running a "either" function, extracting the value if the result is Right, and running a backup function if it is left, right ?
12:15:58 <EvanR> :t either
12:15:59 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
12:16:12 <EvanR> :t either id
12:16:13 <lambdabot> forall a b. (b -> a) -> Either a b -> a
12:16:14 <fetter_oml> can one of you imagine creating a (endlest) list of fibonacci numbers with list comprehension?
12:16:16 <bartavelle> ah perfect
12:16:19 <applicative> I'm trying to figure out a pandoc user's problem.  He has ghc-6.12 on ubuntu, and the globally installed libraries look as they should; but cabal install to him he needed a new cabal-install
12:16:39 <fetter_oml> without the direct formula, that would be cheating :)
12:17:17 <fetter_oml> (the one with lots of sqrt(5) and nasty stuff like that)
12:17:39 <applicative> geekosaur: this introduced a new Cabal lib, and now there is a rather mute failure building some things.
12:18:51 <mroman> > take 10 $ [fst x|x <- iterate (\(a,b) -> (b,a+b)) (0,1)]
12:18:52 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
12:19:03 <mroman> or is that cheating :D
12:20:03 <DMcGill> so I've got newtype Reader e a = Reader (e -> a)
12:20:10 <byorgey> there's nothing really all that special about list comprehensions.  they are basically just syntax sugar for 'map', 'filter', and 'guard'.
12:20:12 <DMcGill> and have Functor and Applicative for it
12:20:19 <DMcGill> but I'm stuck on (>>=)
12:20:43 <byorgey> DMcGill: what should be the type of (>>=)?
12:21:08 <DMcGill> Reader e a -> (a -> Reader e b) -> Reader e b
12:21:11 <fetter_oml> mroman: thats a nice one, except that it is almost unreadable.
12:21:13 <DMcGill> which without the newtypes is
12:21:28 <DMcGill> (e -> a) -> (a -> e -> b) -> (e -> b)
12:21:38 <DMcGill> which \e -> g (f e) e satisfies
12:21:52 <DMcGill> but I'm having trouble putting that back into the newtype
12:22:04 <fetter_oml> we have to create a endless list of fibonacci numbers, but our function has no input parameter, so no rekursion.
12:22:39 <DMcGill> f >>= g = \e -> g (f e) e
12:22:44 <byorgey> DMcGill: right.
12:22:48 <fetter_oml> mroman: ah, now ive understood yours. nice.
12:22:51 <applicative> geekosaur: why was cabal install instructing him to install a new one of itself?  I dimly remember this.  I wonder if the cabal that came with his ghc-6.12 shouldn't be able to do it
12:23:09 <EvanR> you dont need a parameter to use recursive definitions internally
12:23:25 <sipa> @pl \(a,b) -> (b,a+b)
12:23:26 <lambdabot> uncurry (ap (,) . (+))
12:23:27 <EvanR> xs = 1 : xs
12:23:27 <byorgey> DMcGill: every place you have a   Reader, pattern-match on it to get a function; every place you need to make a Reader just use the Reader constructor
12:23:34 <byorgey> (Reader f) >>= g = ...
12:23:39 <byorgey> for a start
12:23:56 <byorgey> (Reader f) >>= g = Reader $ ...   in fact
12:24:28 <byorgey> it might also help to have a function   runReader :: Reader e a -> e -> a
12:25:42 <DMcGill> ah, that did it thanks
12:26:23 <srhb> > take 10 . map fst . iterate (uncurry (ap (,) . (+))) $ (0,1)
12:26:26 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
12:26:29 <srhb> mroman: :-)
12:37:48 <gwern> @quote
12:37:48 <lambdabot> solrize says: The last good thing written in C was Schubert's Ninth Symphony.
12:38:14 <angstrom> is there something like a Modulo class, such that I can perform modulo-n arithmetic on its instances? (if that makes sense)
12:40:58 <DMcGill> is Integral what you're looking for?
12:41:16 <DMcGill> that defined mod
12:41:40 <DMcGill> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Integral
12:42:59 <angstrom> no. I want the modulo to happen automagically, with `n' being encoded into the type
12:43:57 <sipa> that's require a type-level int to define the modulus
12:44:07 <DMcGill> Hmm, you could define an num instance for Mod n Int
12:44:34 <sipa> though predefined instances for some set of moduluses wouldn't be hard
12:45:01 <angstrom> but that would require me to bring the type-level natural into the value-level, no?
12:45:08 <DMcGill> (Mod n x) >>= f = Mod n (f x `mod n)
12:45:09 <DMcGill> ?
12:45:23 <sipa> right
12:45:24 <DMcGill> s/`mod/`mod`
12:46:46 <taylorgb_> Is there some definition of `f :: ( a -> Bool ) -> a -> Maybe a' that would fit better than `mfilter f . Just' ?
12:50:44 <angstrom> DMcGill: that was my first thought, too. but then I thought it would be "nice" to be able to do something like `5 + (6 :: Modulo 7)' yielding `4 :: Module 7'
12:51:06 <angstrom> s/Module/Modulo/
12:52:14 <sipa> (6 `Mod` 7) + (5 `Mod` 7) wouldn't be hard
12:53:49 <cheater_> Eduard_Munteanu: :)
12:54:54 <donri> is there a way to get a Socket from a file descriptor?
12:55:09 <angstrom> sipa: fair enough :-)
12:55:15 <donri> or is that what MkSocket is for
12:58:54 <avh> I was wondering, when using cabal2arch, does the package have to be on hackage?
12:59:17 <avh> because when i run it on my own package, it seems to try and download the sources from the internet
12:59:21 <avh> and then fails
13:03:19 <fragamus> is there a safe version of last
13:05:54 <fmap> > let maybeLast [] = Nothing; maybeLast xs = Just $ last xs in map maybeLast [[], [1,2,3]]
13:05:55 <lambdabot>   [Nothing,Just 3]
13:06:41 <fragamus> is that in some API or do I have to copy the code
13:07:04 <taylorgb_> I don't think there is a definition in any of the well known modules, you'd have to write it yourself
13:07:12 <fmap> fragamus: there is safe package
13:07:18 <fmap> @package safe
13:07:18 <lambdabot> http://hackage.haskell.org/package/safe
13:07:18 <taylorgb_> Or maybe there is
13:07:45 <taylorgb_> Hm, wonder why hoogle didn't find anything :)
13:09:56 <fmap> fragamus: but if you only need safe last it's ok to define it yourself
13:10:29 <fmap> taylorgb_: iirc hoogle doesn't search entire hackage
13:10:46 <srhb> Hayoo does, though
13:10:56 <srhb> (Ironically)
13:12:49 <srhb> Hm, I am lost in exercise 19 of the 20 intermediate Haskell exercises.
13:13:26 <srhb> I'm asked to implement fluffy (functor) for State s, can anyone lend a hand?
13:13:37 <edwardk> mm_freak: =) i have a similar comonad around that just spins
13:14:09 <edwardk> mm_freak: data Initial a = Initial (Initial a); instance Comonad Initial where extract (Initial a) = extract a ;)
13:14:21 <edwardk> er newtype Initial a = Initial (Initial a)
13:15:57 <dmwit> taylorgb_, fmap: Try hoogling "tailDef +safe".
13:16:07 <dmwit> (Yes, it's annoying.)
13:16:15 <shapr> So I'm trying to write a display :: a -> HTML class. Is there any 'best practice' on this sort of typeclass I can read about in a research paper or blog post?
13:17:14 <dmwit> shapr: There are some papers on writing pretty printers, but they're mostly about how to do layout in ASCII and precedence stuff.
13:17:17 <dmwit> What are you looking for?
13:17:45 <dmwit> (It's a bit of a weird question: what are you worried about with the obvious code like "class Display a where display :: a -> HTML"?)
13:17:55 <shapr> Probably some example implementations. I want to be able to display SVG, text and other values in the browser.
13:20:34 <mm_freak> edwardk: well, apart from extract looping that's not the same comonad =)
13:20:50 <mm_freak> the newtype variant is actually
13:21:04 <mm_freak> but since EmptyDataDecls is now standard i just go with "data Bottom a"
13:21:16 <taylorgb_> srhb: What seems to be the trouble?
13:21:40 <edwardk> i usually write the newtype version because its friendlier to old compilers
13:21:45 <srhb> I just think my brain melted down.. But I'm defining another FUrry instance of ((,) t) now, that should help, I think.
13:22:21 <edwardk> of course another good one is to just carry around the (forall a. a)
13:22:47 <edwardk> newtype Derp a = Derp (forall b. b); instance Comonad Derp where extract a = a
13:23:50 <edwardk> extend _ (Derp a) = Derp a
13:24:06 <mm_freak> hmm…  Derp is quite nice actually, but it requires RankNTypes
13:24:11 <edwardk> yeah
13:24:17 <edwardk> thats why i don't use it for Void
13:24:34 <tac-tics> mm_freak: full rank N? Doesn't rank2 work?
13:24:39 <edwardk> just rank 2
13:24:49 <mm_freak> tac-tics: sure, but i don't really differentiate between the two =)
13:24:54 <edwardk> but if you're going to implement higher rank types, you might as well go all the way
13:25:11 <edwardk> you need rank 3 for callCC
13:25:24 <tac-tics> mm_freak: It's easy to differentiate. One has undecidable type inference. The other, you just *wish* type inference was undecidable...
13:25:25 <edwardk> unless you want to break it up into two combinators
13:25:37 <edwardk> tac-tics: =)
13:26:01 <mm_freak> i just don't assume to have any type inference when using either of them =)
13:26:25 * tac-tics goes on his usual tyraid about how Hindley-Milner is the devil.
13:26:53 <edwardk> having now implemented a type checker for them, i'm pretty comfortable with rank n types
13:27:03 <mm_freak> it's funny that for my projects there is a sharp line between ExistentialQuantification and RankNTypes…  i use either one or the other, but almost always one of them and never both =)
13:27:21 * applicative piously affirms the divinity of indley-Milner
13:27:25 <tac-tics> edwardk: What did you base your type checker on? I'd love to learn the basics of how that stuff works.
13:27:27 <applicative> Hindley rather
13:27:34 <edwardk> tac-tics: HMF
13:27:35 <mm_freak> unless you view the sole enabling of GADTs as using ExistentialQuantification as well
13:28:10 <Eduard_Munteanu> I thought rank-n types were a fairly straightforward extension.
13:28:10 <mm_freak> well, i have written a type checker, too…  but that's unfair, because my language is dependently typed =)
13:28:21 <mm_freak> Eduard_Munteanu: it is
13:28:35 <tac-tics> mm_freak: what language did you write? :)
13:28:53 <mm_freak> tac-tics: i'm writing a dependently typed core langauge for an experimental low level project
13:29:05 <tac-tics> neat
13:29:35 <kevinquinnyo> hey guys, i'm learning haskell for fun and am playing with: http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot on a localhost IRC server
13:29:41 <mm_freak> and my experience so far makes me question the decision to have a dependent type system
13:30:02 <mm_freak> easy to implement, hard to make convenient
13:30:14 <kevinquinnyo> and i'm wondering, if i want to execute a shell command, say !do_ls
13:30:17 <tac-tics> mm_freak: Yes. Dependent Types make the theory pretty flat
13:30:37 <tac-tics> But the problem is the users can go all Power Overwhelming on themselves.
13:30:54 <mm_freak> yeah, DTs feel like a secret weapon
13:30:59 <tac-tics> Plus, having a discrete namespace for types vs functions is convenient.
13:31:19 <kevinquinnyo> can someone point me in the right direction to doing that, based on the IRC bot example?  I know i need something like System.Process, but so far, getting a bit confused
13:31:21 <Eduard_Munteanu> Well, true, you're less likely to end up implementing various extensions that don't fit well coherently.
13:31:36 <Eduard_Munteanu> *well and
13:31:46 <mm_freak> generally making "types equal?" and "NF of expressions equal?" the same question makes implementation very easy, but type checking undecidable (unless you forbid general recursion, which i don't intend to do (yet))
13:32:09 <mm_freak> kevinquinnyo: System.Process is all you need =)
13:32:27 <mm_freak> kevinquinnyo: in fact there are many convenient functions in that module that should make executing shell commands one-liners
13:32:33 <Eduard_Munteanu> mm_freak: maybe you don't need decidable typechecking
13:32:52 <Eduard_Munteanu> I wonder if that's a valid option, e.g. timeout during typechecking and reject potentially well-typed programs.
13:32:58 <tac-tics> mm_freak: I've wondered: what if you have a dependently-typed language with general recursion..... but only provably total functions can be used at the type level
13:33:09 <mm_freak> Eduard_Munteanu: that's a bad option…  well-typed programs should always type-check
13:33:15 <applicative> kevinquinnyo: system "rm foo.txt"  removes foo.txt
13:33:15 <mm_freak> one option is to let the user abort instead
13:33:41 <mm_freak> tac-tics: then i could just as well implement the termination checker for the whole language =)
13:33:57 <kevinquinnyo> sorry, got disconnected, i asked a very vague question a second ago, not sure if anyone responded.
13:33:57 <mm_freak> guarded corecursion makes that convenient enough for the programmer
13:34:01 <applicative> kevinquinnyo: it is a little more complicated if you want to get stuff back as from e.g. ls
13:34:07 <mm_freak> kevinquinnyo: System.Process is all you need =)
13:34:08 <Eduard_Munteanu> mm_freak: or that. But we're already working on the premise the typesystem will reject some well-behaved programs.
13:34:12 <mm_freak> kevinquinnyo: in fact there are many convenient functions in that module that should make executing shell commands one-liners
13:34:17 <Eduard_Munteanu> FSVO well-behaved.
13:34:27 <mdhopkins> has someone made the heroku of haskell yet for yesod?
13:34:35 <applicative> kevinquinnyo: system "rm foo.txt"  removes foo.txt  (system is in System.Cmd
13:34:40 <mm_freak> Eduard_Munteanu: it can reject well-behaved programs, but i don't want it to reject well-typed programs
13:34:44 <kevinquinnyo> mm_freak if that's the case, i probably need to dig into it further
13:34:58 <applicative> to get information back you need to piece things together from System.Process
13:34:59 <mm_freak> kevinquinnyo: see applicative's example
13:35:21 <kevinquinnyo> mm_freak applicative thanks about to try it
13:35:32 <tac-tics> mm_freak: Just out of curiosity, what kind of "low level project" are you working on?
13:35:40 <mm_freak> kevinquinnyo: see readProcess for example
13:35:57 <kevinquinnyo> realizing arbitrary commands from an irc bot to the shell it's running from could be quite dangerous as well
13:36:23 <mm_freak> tac-tics: kernel development
13:36:36 <tac-tics> cool
13:36:52 <tac-tics> yeah, I think the promise of dependent types is really big in that kind of arena
13:37:03 <applicative> kevinquinnyo: of course you can do the equivalent of "ls" with some variant of getDirectoryContents "."
13:37:05 <tac-tics> Bounds-checking-free array code is almost enough to justify them alone :)
13:37:11 <Eduard_Munteanu> mm_freak: btw, did you look at BitC?
13:37:21 <mm_freak> i figured that security holes in the kernel are the most severe ones around, and also that kernel development is so inherently difficult the way it's done today that kernel devs get things wrong that would be easy in a better language
13:37:27 <mm_freak> Eduard_Munteanu: yes i did
13:37:31 <Eduard_Munteanu> I wonder if that's more amenable to analysis and proving in a theorem prover.
13:37:33 <mm_freak> i also looked at idris
13:37:56 <tac-tics> mm_freak: How did you feel about Idris?
13:38:00 <kevinquinnyo> applicative: interesting, yes i'm ultimately planning to try some more complex commands, and i'll have to decide whether to use haskell or the shell, when and where
13:38:34 <mm_freak> tac-tics: idris is great, but its design felt somewhat ad-hoc…  i'd like to have a language that's more like agda
13:38:35 <Eduard_Munteanu> mm_freak: yeah, though Idris doesn't sound like a good language for a kernel, a bit too far removed from barebones C.
13:39:13 <mm_freak> Eduard_Munteanu: that's not really true…  idris would be fine, but i wanted to go into compiler design for functional languages anyway =)
13:39:24 <mm_freak> idris would work with some modifications
13:39:28 <tac-tics> mm_freak: What parts feel ad-hoc to you?
13:39:35 <Eduard_Munteanu> You can always come up with your own DSL and prove stuff about it, but the question still remains, what language makes sense for a kernel.
13:39:46 <Taneb> Alternative's kinda sideways from Monad
13:39:52 <applicative> kevinquinnyo: I remember helping someone with a variant of that tutorial, which might be of use as a comparison. let me find it
13:40:04 <mm_freak> tac-tics: well, edwinb summarizes this quite well:  idris is not a dependently typed language, but a language with dependent types =)
13:40:05 <Taneb> They're both inbetween Applicative and MonadPlus
13:40:13 <mm_freak> and that's what it feels like
13:40:22 <tac-tics> ah
13:40:23 <mm_freak> it feels like haskell with dependent types
13:40:24 <tac-tics> I gotcha
13:40:49 <mm_freak> Eduard_Munteanu: a language that is compiled to small, memory-efficient code
13:41:00 <tac-tics> mm_freak: So it sounds like you want something like Agda, only an Agda you can actually run :P
13:41:08 <mm_freak> exactly =)
13:41:17 <applicative> kevinquinnyo: here it is, maybe its basically the same in all interesting respects http://hpaste.org/51068
13:41:30 <Eduard_Munteanu> mm_freak: that's not usually the case with functional languages, though.
13:41:38 <Eduard_Munteanu> At least not higher-level stuff.
13:41:39 <tac-tics> mm_freak: I would really love such a language as well.
13:41:42 <mm_freak> Taneb: except that the laws are different MonadPlus and Alternative are equivalent
13:41:56 <Eduard_Munteanu> I think even ATS is a bit too much for a kernel.
13:41:59 <Taneb> mm_freak, Alternatives don't have to be Monads
13:42:10 <mm_freak> and Alternative is also equivalent to ArrowZero and ArrowPlus…  nowadays i just say:  instance ArrowZero X where zeroArrow = empty
13:42:14 <mm_freak> same for ArrowPlus
13:42:28 <mm_freak> Taneb: conceptually it's wrong that MonadPluses have to be monads =)
13:42:47 <mm_freak> tac-tics: then hold your breath…  i'm working on it =)
13:42:55 <mm_freak> but currently my focus is on netwire
13:43:12 <Eduard_Munteanu> The hard question seems to be how to preserve the level of control languages like C give you and prove stuff about it reasonably at the same time.
13:43:23 <mm_freak> Eduard_Munteanu: there are some tradeoffs
13:43:36 <mm_freak> i don't go for absolute minimal code size
13:43:48 <Taneb> mm_freak, I view it as MonadPluses are things that are both Monads and Alternatives, but I'm not sure how right that is
13:43:54 <tac-tics> mm_freak: Have you looked at separation logic at all?
13:43:58 <mm_freak> since nowadays we measure RAM in gigabytes i don't feel that the smallest possible code is really necessary =)
13:44:03 <mm_freak> speed is more important
13:44:13 <Eduard_Munteanu> Code size isn't the issue per se, though.
13:44:38 <luite> code size still is an issue sometimes... the text package is a problem if you compile it to javascript for example
13:44:47 <mm_freak> Taneb: yes, that's a reasonable way to put it…  but really, whenever you implement MonadPlus, you should implement it in terms of Alternative
13:44:48 <Eduard_Munteanu> I mean, for a kernel.
13:44:50 <Peaker> mm_freak, I thought the whole point of MonadPlus is relating the Monoid laws with the Monad laws
13:45:04 <luite> didn't you know that kernels will be written in javascript in a few years? ;p
13:45:16 <donri> luite: using ghcjs?
13:45:18 <Eduard_Munteanu> Looking at how hotpaths are heavily optimized in Linux, there's absolutely no way you can get that in higher-level languages.
13:45:20 <Taneb> mm_freak, I've never managed to come up with any new MonadPluses...
13:45:37 <luite> donri: yeah
13:45:37 <mm_freak> Peaker: MonadPlus is a bit weaker…  i think the documentation doesn't expect you to have an associative mplus
13:46:25 <edwardk> in general when i find myself reaching for an Arrow, I stop and ask myself if it should just be Applicative
13:46:35 <mm_freak> Eduard_Munteanu: if the kernel core takes 500 KiB that's fine…  my first goal is to get it to run and actually do something =)
13:46:51 <mm_freak> edwardk: i always give both
13:46:57 <edwardk> Peaker: MonadPlus has two unfortunate choices of semantics
13:47:11 <edwardk> mm_freak: i usually see if i can remove that first argument and just work in a monad/applicative ;)
13:47:15 <fuchsto> How do i construct a CArray? There is listArray, but it's defined for IArray.
13:47:18 <donri> seems like frp is transitioning from arrows to applicative?
13:47:20 <tac-tics> (In a dependnetly-typed language, we wouldn't have this discussion about what external laws a class satisfies :)
13:47:21 <mm_freak> Taneb: that's probably fine…  only few people come up with /new/ MonadPluses (or Monads for that matter)
13:47:26 <Peaker> edwardk, zero's right-identity, and what else?
13:47:29 <hpc> ideally, it would just be MonadZero
13:47:35 <Eduard_Munteanu> mm_freak: ah. I was thinking more along the lines of "how can we do stuff like seL4 more easily and get a less fragile result?".
13:47:40 * mgsloan thinks that arrows likely impeded the adoption of FRP
13:47:44 <hpc> with the rule that mzero >> m = m >> mzero = mzero
13:47:50 <mm_freak> Eduard_Munteanu: seL4?
13:47:52 <Peaker> donri, hopefully everything transitions. Arrow is IMO a superfluous class (at least the one that has "arr" in it)
13:48:02 <edwardk> mm_freak: for instance newtype LinearMap r b a = LinearMap { ($*) :: (a -> r) -> b -> r } is a usable Arrow, but
13:48:09 <donri> i see
13:48:21 <Eduard_Munteanu> mm_freak: a formally verified L4 kernel
13:48:28 <edwardk> newtype Covector r a = Covector { ($*) :: (a -> r) -> r) }  is a nicer monad ;)
13:48:42 <edwardk> then linear maps are just kleisli arrows in the covector r monad
13:48:58 <mm_freak> edwardk: sometimes Arrow is useful, especially if you have ArrowLoop
13:48:58 <edwardk> and all monadic actions represent tensoring, etc.
13:49:13 <Eduard_Munteanu> mm_freak: they have an executable Haskell specification, and a C model they've proven equivalent to the spec. But the proof is *huge* and fragile.
13:49:29 <mm_freak> edwardk: of course if you have a monad, you really don't want Arrow =)
13:49:39 <edwardk> mm_freak: yeah, i've occasionally found the sugar handy, though, i tend to just rip out the arrows and build a nice dsl with observable sharing
13:49:44 <Eduard_Munteanu> Like 10k LOC C code, 60k LOC proofs :D
13:49:52 * Eduard_Munteanu doesn't remember the actual figures though
13:50:06 <edwardk> i find that its much easier on the eyes than the sewer of foo <- bar -< baz   noise
13:50:25 <mm_freak> Eduard_Munteanu: i don't want that separation, and i'm sure you can write kernels in functional languages
13:50:25 <geekosaur> fuchsto, looks like http://hackage.haskell.org/packages/archive/carray/latest/doc/html/Data-Array-CArray.html#v:createCArray ?
13:50:59 <mm_freak> edwardk: most of my code is written in applicative style…  i mostly use arrow style when i use ArrowLoop
13:51:07 <Eduard_Munteanu> mm_freak: if you're ok with taking a sometimes large performance hit, yeah
13:51:46 <edwardk> i usually just make a dsl that i can reify the graph out of, and observe the sharing rather than use arrow loop. gives me things like
13:51:53 <mm_freak> Eduard_Munteanu: i don't expect serious performance problems, particularly because the type system helps you to avoid most of them =)
13:52:12 <edwardk> half_adder a b = (xor a b, a && b)
13:52:14 <Eduard_Munteanu> I think at least some kernel core needs to be written in a lower-level language to get reasonable performance, e.g. IPC
13:52:19 <Eduard_Munteanu> Heh.
13:52:21 <mm_freak> edwardk: could you elaborate?
13:52:35 <edwardk> full_adder a b cin = (s2, c1 || c2) where (s1, c1) = half_adder a b; (s2, c2) = half_adder s1 cin
13:52:58 <Eduard_Munteanu> mm_freak: come up with asymptotic types, say Foo O(n) :P
13:53:01 <mm_freak> Eduard_Munteanu: yes, that core will be the (S)TG machine =)
13:53:20 <applicative> fuchsto: are you using the carray library from hackage?
13:53:35 <edwardk> then i can just use data-reify to get the graph out in a manipulable form
13:53:37 <mm_freak> Eduard_Munteanu: the idea is that the STG machinery is built into the kernel
13:53:39 <kevinquinnyo> applicative: sorry i was away, got your pastebin, thank you
13:53:56 <edwardk> mm_freak: for instance i could make an arrow based ad library, but it'd be awful =)
13:54:01 <mm_freak> edwardk: i'll have to look into that
13:54:14 <Eduard_Munteanu> mm_freak: what kind of kernel are you considering, btw? Monolithic/microkernel?
13:54:24 <mm_freak> i really don't know how i would translate, for example, my Wire type to something like that =)
13:54:32 <mm_freak> Eduard_Munteanu: micro
13:54:38 <edwardk> mm_freak: another trick is that you can actually make it so you can observe the function applications
13:54:47 <edwardk> mm_freak: thats almost exactly the original use case ;)
13:55:07 <edwardk> mm_freak: http://www.ittc.ku.edu/~andygill/talks/20090603-tdos.pdf
13:55:13 <Eduard_Munteanu> mm_freak: I think a monolithic kernel also makes sense if you're going to prove stuff about it
13:55:37 <edwardk> er http://www.ittc.ku.edu/csdl/fpg/sites/default/files/Gill-09-TypeSafeReification.pdf
13:55:49 <srhb> The (>>=) for State is dark magic. I understand approximately none of it.
13:55:56 <mm_freak> edwardk: thanks, i'll look into that
13:56:07 <mm_freak> srhb: try to write it yourself
13:56:10 <Eduard_Munteanu> srhb: then don't look at it and implement your own :)
13:56:12 <Eduard_Munteanu> ^^
13:56:28 <edwardk> mm_freak: in 'ad' i reify a tape of what you've done with numbers from a tree to get a graph with the sharing information in it
13:56:48 <srhb> <_<
13:56:58 <edwardk> https://github.com/ekmett/ad/blob/master/src/Numeric/AD/Internal/Reverse.hs#L62 through MuRef
13:57:01 <mm_freak> srhb: think of it this way:  (>>=) :: (s -> (a, s)) -> (a -> s -> (b, s)) -> (s -> (b, s))
13:57:24 <mm_freak> because 'State s a' and 's -> (a, s)' are essentially the same thing =)
13:57:38 <edwardk> replace data Tape a t with data Circuit t = Zero | One | And t t | Or t t | Xor t t | Not t
13:57:45 <edwardk> and then make your Wire a newtype fixed point of that
13:57:53 <edwardk> newtype Wire = Wire (Tape Wire)
13:57:54 <fuchsto> applicative, geekosaur : I found createCArray, but i'm somewhat lost ... how do i create a Storable?
13:58:07 <srhb> mm_freak: Ah.. hm. I maybe kinda get that.
13:58:13 <edwardk> then when you use data-reify you get a ([(Int, Tape Int)], Int)
13:58:16 <mm_freak> edwardk: that starts to make sense, but will that work?  Wire is now a coroutine arrow
13:58:46 <fuchsto> applicative: Yes, the carray package. I'm just looking for a way to transform a list of floats to a CArray ... i have to convert the floats to Storables first, and i don't get how, yet
13:58:55 <mm_freak> Eduard_Munteanu: that won't really be necessary…  the kernel will actually have a type system builtin =)
13:58:59 <edwardk> not sure what Wire is in your situation, i was assuming it was a functional representation of a wire in a circuit
13:59:19 <applicative> Float is already of a storable type, no?
13:59:38 <srhb> Yes
13:59:51 <mm_freak> edwardk: ah, not at all…  Wire is my FRP signal function type
13:59:57 <edwardk> with the above you can stitch together wires using arbitrary functions, make cycles in them, etc. but in the end they are made out of actual values
13:59:58 <edwardk> ah
14:00:01 <Eduard_Munteanu> mm_freak: yeah, but I mean, since the code is written in a functional language, it's also less susceptible to buffer overflows and other such errors.
14:00:02 <applicative> fuchsto: the instances of Storable in base are here http://hackage.haskell.org/packages/archive/base/4.4.1.0/doc/html/Foreign-Storable.html#t:Storable
14:00:06 <edwardk> i haven't done an observable FRP yet
14:00:19 <mm_freak> its current definition is:  newtype Wire e s f a b = Wire (a -> Output e s f a b)
14:00:34 <mm_freak> where Output is either Inhibit, Produce or Suspend with suitable arguments
14:00:37 <mm_freak> and f is a functor
14:00:41 <edwardk> messy
14:00:43 <edwardk> ok
14:00:48 <edwardk> stick to crappy arrow syntax ;)
14:00:53 <geekosaur> fuchsto, Storable isn;t something you create, it identifies types that can be marshaled.  see http://hackage.haskell.org/packages/archive/base/4.4.1.0/doc/html/Foreign-Storable.html#t:Storable
14:00:56 <fuchsto> applicative: That's what i found ... but createCArray seems to expect a GHC.Ptr.Ptr
14:00:58 <ptrf> :t <$>
14:00:58 <mm_freak> i'm not using arrow syntax
14:00:59 <lambdabot> parse error on input `<$>'
14:01:07 <pcavs> :t (<$>)
14:01:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:01:16 <ptrf> thanks, forgot em :)
14:01:18 <hpc> edwardk: yeah, i can't use FRP either
14:01:18 <mm_freak> edwardk: i don't really know how to make it less messy…  if you have an idea i'd be happy to know about it =)
14:01:37 <edwardk> mm_freak: that was an acknowledgement of defeat, not a bash on your design =)
14:01:38 <fuchsto> geekosaur: Yes, thanks, i got that part from the article 'Numeric Haskell' on the haskell wiki
14:01:53 <geekosaur> there is a sizeable list of standard types that are Storable, and various packages define their own instances
14:02:20 <fuchsto> geekosaur: but assuming i have a list  fs  containing Floats. I can't pass it to createCArray like in     createCArray (0,9) fs
14:02:22 <edwardk> i do want to take a whack at using observable sharing in an FRP design though
14:02:32 <mm_freak> edwardk: the user interface is really convenient actually…  better than yampa and gets along without the arrow interface…  internally it has some beauty to it, but it takes lots of type arguments, which i'd love to improve somehow
14:02:48 <fuchsto> geekosaur: As it's expecting a GHC.Ptr.Ptr e. Sorry, it's my first steps in impure Haskell.
14:03:07 <rwbarton> @type withArray
14:03:08 <lambdabot> Not in scope: `withArray'
14:03:10 <edwardk> mm_freak: i've tried to love FRP. i decided i had better things to waste my life on ;)
14:03:13 <rwbarton> @hoogle withArray
14:03:13 <lambdabot> Foreign.Marshal.Array withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
14:03:13 <lambdabot> Foreign.Marshal.Array withArray0 :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b
14:03:13 <lambdabot> Foreign.Marshal.Array withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b
14:03:20 <rwbarton> @hoogle createCArray
14:03:21 <lambdabot> No results found
14:03:24 <applicative> fuchsto: why aren't you using the vector package if you are startiing out from http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial or is that the wikipage you  meant
14:03:41 <hpc> mm_freak: a first probably-cheating step would be to arbitrarily decide that one of those types is constrained to (), and see how much expressive power the result has
14:03:46 <fuchsto> applicative: I want to use Math.FFT. They again are expecting CArrays.
14:03:49 <hpaste> “Ertugrul Söylemez” pasted “New Netwire internals” at http://hpaste.org/70433
14:03:56 <geekosaur> yes, you're tryingt o work something that's quite complex
14:04:06 <mm_freak> edwardk: see the paste…  and no, i use FRP productively…  it's fine =)
14:04:09 <hpc> or arbitrarily decide that two types are the same
14:04:17 <mm_freak> edwardk: the paste contains the actual code for the Wire type
14:04:19 <fuchsto> applicative: CArray i r -> CArray i (Complex r)
14:04:30 <mm_freak> hpc: i can't constrain any of them
14:04:54 <geekosaur> you don't pass it a list of things, you pass it a function which is given an allocated chunk of memory (a Ptr) and you have to fill that memory.  see http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.5.1.0/Foreign-Marshal-Array.html for the functions you can use to write your list into the Ptr
14:05:37 <donri> would frp be suitable for writing irc bots?
14:05:41 <fuchsto> geekosaur: That finally makes sense. So i should use withCArray in the first place
14:06:06 <hpaste> “Ertugrul Söylemez” annotated “New Netwire internals” with “New Netwire internals (annotation)” at http://hpaste.org/70433#a70434
14:06:07 <edwardk> donri: i'm sure you can make an irc bot run over a tin can and string if you put your mind to it ;)
14:06:13 <geekosaur> createCArray (0,9) (\p -> pokeArray p fs) -- if fs has exactly 10 elements [I think...])
14:06:29 <mm_freak> edwardk: just added the stepping function so you can see how it actually works…  the type is really scary, but the concept is actually very simple
14:06:35 <geekosaur> not that familiar with the Ix stuff in general, although I have a basic understanding of Ptrs
14:06:43 <donri> :) well, i mean, most frp examples seem to be about having an UI updated based on value dependencies
14:06:43 <mm_freak> and there you also see why ArrowLoop has a Comonad constraint of 'f' =)
14:06:49 <donri> that's not very relevant to irc bots
14:06:51 <edwardk> yeah, i've built similar constructions for working with iteratees
14:07:03 <donri> but it "feels" like it makes sense to use frp for irc bots?
14:07:15 <mm_freak> donri: it does make sense
14:07:27 <edwardk> donri: you can do fine with irc, its more or less 'call and response', and frp is good at that
14:07:27 <mm_freak> fastirc is actually already partly rewritten based on the new netwire =)
14:07:46 <fuchsto> geekosaur: Strange, 'my' createCArray does not expect a function
14:08:01 <mm_freak> there is also a proof-of-concept web framework called webwire on hackage…  it's based on a rather old netwire version though
14:08:07 <geekosaur> createCArray :: (Ix i, Storable e) => (i, i) -> (Ptr e -> IO ()) -> IO (CArray i e)
14:08:11 <donri> mm_freak: is fastirc yours?
14:08:12 <edwardk> the main reason i tend to get sad about frp is its just rather hopelessly naive about time
14:08:19 <mm_freak> donri: yes
14:08:22 <russel-athletic> hiho
14:08:24 <fuchsto> geekosaur:  -.-  Sorry, looked up the wrong function
14:08:34 <mm_freak> edwardk: time is an addon
14:08:39 <mm_freak> in AFRP at least
14:08:43 <russel-athletic> i know common lisp and sml, is there a specific guide to learn haskell or should i just use a standard tutorial
14:08:45 <kevinquinnyo> applicative: i hate to be a nuisance, but would it be too much trouble for you to pastebin a modified http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot with a !ls  (or any system command) ?  i feel like if i see that i will understand the structure
14:08:48 <edwardk> mm_freak: depends on how you go about it, but yes
14:08:49 <donri> mm_freak: got a release soon? :)
14:09:05 <mm_freak> donri: this or next week for netwire…  probably longer for fastirc
14:09:29 <mm_freak> edwardk: since netwire 3 i maintain time as an addon, because events are essentially decoupled from time in AFRP
14:09:40 <mm_freak> not so for classic FRP (and that's why i don't like it)
14:10:09 <mm_freak> heinrich apfelmus is spending a lot of time to get the concept of time right in classic FRP
14:10:32 <edwardk> mm_freak: yeah i spent a month or so beating on a usable form of 'functional reactive relativity' before i just moved on with my life
14:10:39 <mm_freak> i shouldn't say AFRP…  it's WFRP if you will
14:11:12 <tgeeky> edwardk: you did whaaaa </Professor>
14:11:43 <edwardk> tgeeky: you can get pretty far if you parameterize your notion of FRP with a causal domain ;)
14:13:44 <mm_freak> edwardk: when netwire 4 is out, you should give it a shot =)
14:13:53 <mm_freak> i think you'll like it…  FRP done right IMO
14:14:18 <mm_freak> i have a lot of experience now using FRP in productive code
14:15:20 <Eduard_Munteanu> Production code?
14:16:16 <mm_freak> uhm…  i'm not a native english speaker…  is there a difference?
14:16:27 <Clint> yes
14:16:53 <tac-tics> mm_freak: Productive code sounds like something that passes a productivity check in Agda :)
14:17:04 <mm_freak> hehe i see
14:17:09 <mm_freak> i'm on #haskell =)
14:17:14 <tac-tics> Production code is a standard term for code that is "live" and being used by the actual users.
14:17:23 <donri> productive means getting stuff done, production means "running professionally" sort of?
14:17:25 <mm_freak> ok, production code then
14:17:44 <mm_freak> live at least, and partly "professional" in the business sense
14:17:55 <donri> well yea, "live" is better
14:18:07 <donri> doesn't have to be business
14:18:48 <fuchsto> geekosaur: I imported Foreign.Marshall.Array and pokeArray is not in scope?
14:19:15 <srhb> Marshal, right?
14:19:22 <mm_freak> edwardk: your fixed point approach you talked about…  is it related to free monads?
14:19:25 <fuchsto> geekosaur: I tried to convert a list of integers to a CArray Integer using    let carr = createCArray (0,(length xs)-1) (\ptr -> pokeArray ptr xs)
14:19:53 <edwardk> mm_freak: good observation, though you don't need an actual Pure constructor, so its just Mu, not Free
14:19:55 <mm_freak> edwardk: because i have implement some small imperative DSLs based on free monads, and that sounds very related
14:20:01 <mm_freak> i see
14:20:18 <edwardk> i do a lot of DSLs with free and ideal monads
14:20:26 <fuchsto> geekosaur: srhb: Ah, okay, thank you >_<
14:20:44 <mm_freak> ok, let me just try it out before reading a lengthy paper =)
14:20:46 <edwardk> https://github.com/ekmett/bound makes them only ideal not free
14:21:05 <edwardk> so i tend to lose the ability to claim my DSLs are free now =)
14:21:39 <mm_freak> what's an ideal monad?
14:21:39 <fuchsto> Hrm, okay, that doesn't work as pokeArray returns IO()
14:22:12 <edwardk> monads have coproducts, but not products in general. ideal monads are a family of monads where you have a 'separate' return constructor and everything else
14:22:32 <edwardk> data Ideal f a = Pure a | Ideal (f a)
14:22:42 <edwardk> now, free monads are ideal
14:23:02 <mm_freak> ok, i see the difference
14:23:56 <edwardk> what you need is a way to idealize :: f (Ideal f a) -> f a
14:24:05 <mm_freak> code always helps as i still don't know a lot about CT =)
14:24:23 <mm_freak> so type definitions make more sense to me =)
14:24:28 <edwardk> thats okay, the term comes from tarmo uustalu, and isn't in general usage =)
14:24:36 <fuchsto> Hm, but actually that should be okay. What's wrong with    let carr = createCArray (0, (length xs) -1) ( \ptr -> do { pokeArray ptr xs } )
14:24:40 <fuchsto> ?
14:25:03 <edwardk> whats nice about ideal monads is that can define the product of any two ideal monads
14:25:07 <Eduard_Munteanu> edwardk: hm, are they related to ideals as in ring theory?
14:25:13 <rwbarton> nothing per se, but probably you want carr <- createCArray (0, (length xs) -1) ( \ptr -> do { pokeArray ptr xs } )  no?
14:25:24 <edwardk> Eduard_Munteanu: same idea with regards to products =)
14:26:06 <fuchsto> rwbarton: Sure, but it throws 'No instance of Storable Integer arising from the use of createCArray' :/
14:26:23 <rwbarton> well yeah, you can't Store an Integer
14:26:30 <rwbarton> (I mean Integer isn't Storable)
14:26:40 <Eduard_Munteanu> Hm, what exactly is a coproduct of monads?
14:27:01 <edwardk> Eduard_Munteanu: thats the trick, you want the 'effects' from both monads to make sense together
14:27:04 <hpc> is (Storable a, Storable b) => Either a b storable?
14:27:06 <Eduard_Munteanu> Like a coproduct in End(C)?
14:27:18 <hpc> because you could be hilarious and match on the Integer
14:27:25 <edwardk> what you get out of the ideal monad is a way to make a layering of N(M(N(M(…(A))))))
14:27:29 <edwardk> out of the ideal portions
14:27:35 <rwbarton> you can store fixed-size integral types like Int or Int32 or Int64
14:27:40 <rwbarton> but not Integer, it is arbitrary size
14:27:43 <geekosaur> Integer is difficult because it's an implementation dependent representation of a BigInt
14:27:44 <fuchsto> rwbarton: But Float is? O?o
14:27:48 <rwbarton> sure
14:27:55 <hpc> @src Integer
14:27:56 <lambdabot> data Integer = S# Int#
14:27:56 <lambdabot>              | J# Int# ByteArray#
14:27:57 <hpc> rwbarton: ^
14:28:07 <geekosaur> Float is defined by a standard
14:28:14 <fuchsto> Like Int, get it
14:28:15 <geekosaur> (IEEE754 floating point)
14:28:18 <edwardk> so it is A + N (A + M (A + N(…)) )  + M (…)
14:28:19 <rwbarton> Float is the IEEE 32-bit format
14:28:36 <rwbarton> (in GHC anyways)
14:28:58 <edwardk> basically the outer layer chooses which monad goes first and you mutually recurse, using the idealize operation to smash N (N A) into N A whenever you need to ensure they alternate
14:29:03 <geekosaur> the relevant point is, is it a type that something outside of Haskell will understand?  for Int and Float the answer is yes; for Integer, not so much
14:29:06 <mm_freak> @src Mu
14:29:06 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
14:29:12 <geekosaur> (this is what Storable means)
14:29:17 <hpc> doesn't the haskell report define semantics that are almost but not quite IEEE-compliant?
14:29:20 <edwardk> it is rather interesting to derive the monad
14:30:32 <mm_freak> data List a r = Cons a r | Nil
14:30:33 <edwardk> did that make sense?
14:30:37 <mm_freak> is that the basic idea?
14:30:42 <mm_freak> for fixed-point based data
14:30:45 <edwardk> mm_freak: of Mu? yeah
14:31:22 <mm_freak> ok, that's rather simple…  let's see if i can write a lambda calculus expression language in terms of that
14:31:24 <edwardk> when you use data-reify it replaces the fixed point recursions with just identifiers, and gives you a map from identifiers to levels
14:31:42 <mm_freak> let me get the basic idea before trying data-reify =)
14:32:16 <Eduard_Munteanu> edwardk: somewhat, I kinda have to read about it somewhere first
14:32:30 <mm_freak> but i'm afraid i can't apply this to Wire, because i can't really prevent opaque functions
14:33:06 <edwardk> data E a = a :@ a | Lam Var a   -- is one way to implement a base functor for a lambda calculus, because when you take its free monad, you get Pure a | (Free E a :@ Free E a) | Lam Var (Free E a)
14:33:22 <edwardk> but i find that in general using free or mu to tie the not on a lambda calculus is an awkward approach
14:33:32 <edwardk> a nicer way is to get locally-nameless binding by
14:34:25 <edwardk> data Exp a = Var a | Exp a :@ Exp a | Lam (Exp (Maybe a)) -- using ADT based debruijn levels
14:34:33 <edwardk> or use something like bound to make something nicer
14:34:39 <mm_freak> locally nameless is what i'm using
14:34:49 <edwardk> with Bound you'd use
14:35:02 <edwardk> data Exp a = Var a | Exp a :@ Exp a | Lam (Scoped () Exp a)
14:35:15 <edwardk> deriving (Functor, Foldable, Traversable)  -- and then just make the Monad
14:36:09 <edwardk> instance Monad Exp where Var a >>= f a; (a :@ b) >>= f = (a >>= f) :@ (b >>= f); Lam b >>= f = Lam (b >>>= f)  -- where m >>>= f is just a fancy way to write m >>= lift . f
14:36:17 <edwardk> that takes care of name capture
14:36:26 <mm_freak> data-reify is intriguing for some projects…  but i'll have to look into that later…  gotta get some stuff done now
14:36:32 <matthiasgorgens> Is there a library function to run lots of monadic actions in parallel threads, and collect the results?  Typed like [m a] -> m [a].
14:37:11 <mm_freak> matthiasgorgens: not in the base library, but it's really easy to define
14:37:12 <edwardk> matthiasgorgens: for what monads? IO? or just any random monad?
14:38:06 <edwardk> there should be a nice way to abuse the 'initial algebra semantics are enough' approach to make the Exp using Scoped above into a free monad of some sort
14:38:13 <edwardk> but i haven't figured it out yet
14:39:27 <hayashi> trite question I know, but what are people's favourite aliases for ((.).(.))?  I remember .: or maybe :. being a fan favourite
14:39:34 <edwardk> mm_freak: right now i use the reification of observable sharing for ad, sat solving, compilation of a dsl to cuda, some half finished blas bindings, etc. its pretty flexible
14:39:55 <edwardk> i tend not to alias it because it makes someone stop to look up the alias
14:40:53 <hpaste> “Ertugrul Söylemez” pasted “Fork and collect” at http://hpaste.org/70436
14:41:04 <mm_freak> matthiasgorgens: see the paste
14:41:30 <mm_freak> edwardk: i think you are assuming an AST
14:41:47 <edwardk> yes, i confess =)
14:42:07 <mm_freak> well, as said, there are opaque functions that i can't avoid =)
14:42:32 <mm_freak> at least not in a straightforward way
14:43:52 <joewhite> Hi guys , what does it mean != Haskell ?
14:44:13 <geekosaur> it doesn't normally.  where did you find it?
14:44:21 <hpc> @hoogle (!=)
14:44:21 <lambdabot> No results found
14:44:23 <mm_freak> joewhite: are you looking for the (/=) operator?
14:44:43 <joewhite> mm_freak: !=
14:45:05 <mm_freak> that's some library function then…  the base library doesn't define a function with that name
14:45:28 <mm_freak> > let x != y = x*y + x + y in 5 != 7
14:45:30 <lambdabot>   47
14:45:33 <applicative> > let (!=) = (!!) in [1,2,3] != 2
14:45:34 <lambdabot>   3
14:46:09 <mm_freak> joewhite: if you could give a type signature for that function we could probably tell you more =)
14:46:22 <applicative> > let (!=) = (/=) in 1 != 2
14:46:23 <lambdabot>   True
14:48:40 <joewhite> mm_freak: one of my friend just asked
14:48:47 <joewhite> thank you guys
14:50:24 <fragamus> plugh
14:50:45 <hpaste> fragamus pasted “I think I need some "Maybe"” at http://hpaste.org/70438
14:51:12 <hayashi> * "Maybe I need some "Maybe""
14:51:14 <hayashi> FTFY
14:52:10 <fragamus> anyways I'm a newb and I need to figure this out
14:56:04 <hpaste> fragamus annotated “I think I need some "Maybe"” with “Maybe I need some "Maybe" (annotation)” at http://hpaste.org/70438#a70439
14:56:59 <hpc> don't see anything in there meriting Maybe
14:57:02 <dmwit> You know you don't need to say let so many times, right?
14:57:23 <dmwit> let introduces a block, so just use indentation in the way you normally do for multiple definitions.
14:57:58 <dmwit> As for Maybe, why not add a line like "when (not (null left)) (throwError "blah")"?
14:58:01 <hpc> if you're using vim, visual block all the lets but the first, and r<space>
14:58:06 <dmwit> And demand that this action be run in a MonadError instance.
14:59:17 <twanvl> since all the manipulation is done only on 'c', you should consider putting it into a separate function, and write  do { (a,b,c) <- get; put (a,b,doSomeStuffWith c) }
15:02:53 <fragamus> I actually figured out a lot of stuff while I was trying to form a question
15:05:43 <dmwit> Oh, crap, you missed all our awesome suggestions while your computer was asleep.
15:06:12 <dmwit> 17:57 < dmwit> As for Maybe, why not add a line like "when (not (null left)) (throwError "blah")"?
15:06:30 <dmwit> 17:58 < twanvl> since all the manipulation is done only on 'c', you should consider putting it into a separate function, and write  do { (a,b,c) <- get; put (a,b,doSomeStuffWith c) }
15:06:53 <dmwit> Oh, yes, and the former was followed by
15:06:59 <dmwit> 17:57 < dmwit> And demand that this action be run in a MonadError instance.
15:07:14 <zybreak> I've got a noob question for you guys, would appreciate any help
15:07:53 <dmwit> fragamus: ^
15:08:04 <geekosaur> just ask...
15:08:24 <fragamus> Ok
15:08:34 <fragamus> Thanks man
15:08:45 <hpc> zybreak: newbies only get one free question; most of them waste it asking if they can ask a question ;)
15:08:48 <zybreak> alright: I'm solving a math problem in haskell, and im getting stack overflow (i'm guessing from too much recursion)
15:09:05 <zybreak> hpc: i knew it... damn :P
15:09:31 <hpc> can you hpaste the code?
15:09:33 <dmwit> zybreak: Stack overflows in Haskell are usually the result of too much laziness, not too much recursion.
15:09:40 <dmwit> You can never have too much recursion. =)
15:09:44 <hpc> or not enough laziness
15:09:45 <realitygrill> guess: foldl?
15:10:01 <zybreak> check it out: http://pastebin.com/tAM7tVRd
15:10:02 <mauke> The paste tAM7tVRd has been copied to http://hpaste.org/70440
15:10:25 <dmwit> s/divisable == True/divisable/
15:10:51 <dmwit> But that won't fix the problem. =)
15:11:01 <Peaker> zybreak, "check n+1" == "(check n)+1"
15:11:10 <dmwit> yes
15:11:28 <realitygrill> i don't understand this code
15:11:44 <hpc> your stack overflow ends up being from the build-up of (((((((...) +1) +1) +1) ...
15:11:49 <Peaker> zybreak, can you fix the hlint warnings on the hpaste copy of your paste?
15:12:09 <zybreak> Peaker will do
15:13:49 <realitygrill> looking for a number divisible by 1-20?
15:13:51 <zybreak> Peaker: done
15:14:12 <zybreak> realitygrill thats right
15:14:18 <realitygrill> yay
15:14:24 <zybreak> ;)
15:14:57 <zybreak> I'm playing around with project euler as well as learning haskell
15:15:21 <Peaker> zybreak, so your "check n+1" call is actually calling "check n" again, which is bad :)
15:15:47 <zybreak> Peaker oh, yeah. thats no good :)
15:15:54 <Peaker> zybreak, if you're interested, I can suggest some nicer ways to do this exercise..
15:16:58 <zybreak> Peaker I would love some tips, like i said before. total haskell newbie
15:17:31 <nobdraisentone> How can I rewrite \(x:xs) -> (x, xs)? Instead of pl-advice `liftM2 (,) head tail'
15:17:41 <Peaker> zybreak, sum (map (n `rem`) [1..20]) == 0     is going to have to sum everything, when in fact you can stop on the first one which is non-zero
15:17:54 <Peaker> zybreak, so a nice function is "all"
15:17:56 <Peaker> @type all
15:17:57 <copumpkin> nobdraisentone: take a step back and avoid needing the list or the pair
15:17:58 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
15:18:16 <Peaker> > all (== 0) (map (5 `rem`) [1..20])
15:18:17 <lambdabot>   False
15:18:38 <Peaker> > all (== 0) (map (product[1..20] `rem`) [1..20])
15:18:40 <lambdabot>   True
15:18:44 <zybreak> Peaker oh, thanks
15:18:57 <Peaker> zybreak, next -- you could have check n do a single check, without a recursion
15:19:24 <Peaker> zybreak, check n = all (== 0) (map (n `rem`) [1..20])
15:20:02 * hackagebot scotty 0.4.4 - Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp  http://hackage.haskell.org/package/scotty-0.4.4 (AndrewFarmer)
15:20:08 <Peaker> zybreak, and then, you can use a:   head (filter check [1..])         or you can use the "find" function which does the "head after filter" part
15:20:10 <Peaker> @type find
15:20:11 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
15:20:50 <Peaker> hmm.. let's ignore find for now, you want to loop infinitely until you find one rather than ever return a failure.. so the "head" after "filter" solution is better
15:22:01 <hpaste> Peaker annotated “pastebin.com/tAM7tVRd” with “Simpler” at http://hpaste.org/70440#a70445
15:22:37 <Peaker> zybreak, recursion is like the "goto" of the functional world, it's low-level so we prefer to use higher-level stuff (that's built from recursion underneath)
15:24:01 <zybreak> Peaker I see, this solution was indeed alot simpler
15:25:28 <unnali> join = (>>= id)
15:25:35 <unnali> x >>= f = join $ fmap f m
15:25:39 <unnali> are these the canonical derivations?
15:25:41 <Azel> Peaker: couldn't check be implemented with a fold ? Like that: foldr1 lcm [1..20] (or foldr lcm 1 [1..20]) ?
15:25:50 <zybreak> haskell is amazing, i'm new in the functional world. but its a real nice change from my imperative past
15:25:53 <unnali> i was up all last night in bed trying to work out how to express (>>=) and join in terms of each other, and these do seem to type cehck
15:26:04 <dmwit> unnali: yes
15:26:09 <unnali> (and by type check i mean they produce the correct types, so I guess they must be!)
15:26:13 <unnali> dmwit: wooooo
15:26:35 <unnali> dmwit: i've never spent so long `programming' while lying down in bed without a computer or notepad :)
15:26:43 <dmwit> unnali: Though I guess you meant either "m >>= f" or "join $ fmap f x". ;-)
15:26:47 <hpc> unnali: for extra credit, implement join as a primitive for as many monads as you can
15:26:52 <unnali> dmwit: whups. yes.
15:26:59 <hpc> and decide which of join/(>>=) is prettier for each
15:27:11 <unnali> hpc: sounds fun! will do. :)
15:27:37 <matthiasgorgens> mm_freak: thanks for the paste.  (and please pardon my late reply.)  the technique of the paste is what I'm doing manually at the moment, I'd just hoped there'd be some code already on hackage.  by the way, wouldn't an ivar be better than an mvar here?
15:28:02 <matthiasgorgens> mm_freak: actually, I am doing something more generic with the lifted-base package.
15:28:36 <mm_freak> matthiasgorgens: in terms of efficiency the MVar is probably the best you can get…  also i don't see why you would put that in a library…  it's not something you would do a lot
15:28:52 <mm_freak> make sure you're not abusing concurrency for parallelity
15:29:23 <matthiasgorgens> mm_freak: I'm not completely sure what the code is doing. :o) I am just happily replacing all IO's with MonadBaseControl IO m at the moment.
15:29:37 <mm_freak> matthiasgorgens: why?
15:29:38 <matthiasgorgens> "the code" means the code of the daemon I am working on at the moment.
15:30:07 <Peaker> Azel, I didn't want to think :) Just mechanical refactorings :)
15:30:19 <matthiasgorgens> mm_freak: because we had needed MonadBaseControl badly enough that one of our co-workers even come up with an in-house implementation, until we found lifted-base.
15:30:38 <mm_freak> i see
15:30:40 <matthiasgorgens> mm_freak: we have a monad-transformer stack that we have to run up and down.
15:30:50 <mm_freak> i try to avoid monad-control as much as possible =)
15:31:06 <matthiasgorgens> was actually quite a nice exercise to prove that my co-workers type class was essentially equivalent to monadbasecontrol.
15:31:14 <matthiasgorgens> (only I felt stupd afterwards for taking so long.)
15:31:19 <matthiasgorgens> mm_freak: why?
15:31:28 <mm_freak> it feels dirty
15:31:44 <matthiasgorgens> the lifted-base stuff is pretty useful.
15:31:48 <matthiasgorgens> avoids lots of headeches.
15:31:51 <matthiasgorgens> headaches.
15:31:58 <matthiasgorgens> especially liftBaseOp.
15:31:58 <hpc> there's an ezyang post that shows it is simultaneously more powerful than IO and not powerful enough
15:32:48 <hpc> just be aware that you might get broken semantics from blithely lifting everything
15:33:26 <matthiasgorgens> hpc, it's probably fine, we don't really need the call-back effects coming back into the top monad.
15:33:31 <matthiasgorgens> we don't use state at the top.
15:33:36 <matthiasgorgens> (though we do use error.
15:33:55 <matthiasgorgens> which could get broken like ezyang describes, I guess.)
15:35:51 <matthiasgorgens> anyway, thanks for the link to ezyang.
15:36:00 <matthiasgorgens> or the reference, rather.
15:37:57 <Azel> Peaker: Fair enough. I thought about that method because I don't have (yet) Haskell on my Windows box and tryhaskell.com terminates your solution without giving the result
15:44:01 <Peaker> Azel, yeah that algorithm is too slow
15:44:09 <Peaker> Azel, I didn't actually try to run it before
15:52:02 <lolcathost> Hello. Does System.IO.hGetLine return a string containing a newline?
15:53:42 <applicative_> It shouldnt contain the newline
15:58:59 <dmwit> lolcathost: In the future, this kind of question is best answered by trying it.
15:59:16 <dmwit> Just type "hGetLine stdin" into ghci and see what happens.
15:59:21 <lcfrs> Can anyone comment on when to use FRP and when to use state machine abstractions?
15:59:36 <hayashi> ghci is amazingly useful for trying things out
16:00:49 <hayashi> I love using ghci to check to see if bits of code I'm about to use in a compiled bit of Haskell are of the correct type, because in Haskell once something's the right type it becomes surprisingly likely to be the right function
16:01:30 <lolcathost> dmwit: I did not know stdin was actually an identifier.
16:01:31 <lolcathost> Sorry.
16:02:03 <hayashi> especially combinator runs like strings of Control.(Applicative|Monad|Arrow) glue
16:15:47 <tchon> ~~/clear
16:15:50 <tchon> oops
16:16:04 <HugoDaniel> :)
16:17:19 <lcfrs> From what I understand, there are certain problems where FRP is a better tool than a typical state machine library. But, what makes FRP better for these problems? Does it give certain compile-time guarantees about erroneous state transitions?
16:22:51 <stephenjudkins> lcfrs: i've only read papers about frp and have never implemented anything in it
16:22:55 <stephenjudkins> *using it
16:23:22 <stephenjudkins> but to my understanding, FRP offers some static guarantees that certain classes of failures cannot occur
16:24:07 <stephenjudkins> http://lampwww.epfl.ch/~imaier/pub/DeprecatingObserversTR2010.pdf offers examples of these failures
16:24:40 <lcfrs> There's a really interesting blog post about it with an implementation of Pong: https://github.com/leonidas/codeblog/blob/master/2012/2012-01-17-declarative-game-logic-afrp.md
16:27:40 <lcfrs> Ah, yes I've read this paper before. Thanks for remind me about it.
16:27:50 <ksf> dyre compeletly breaks profiling the custom executable, dosen't it?
16:30:25 <jmcarthur> the focus of frp is not really on such static guarantees. it's on being a simple way to express time-dependent systems
16:31:00 <jmcarthur> some guarantees tend to come just by being implemented in haskell, though, of course :)
16:38:20 <hpaste> fragamus annotated “I think I need some "Maybe"” with “Maybe I need some "Maybe" (annotation) (annotation)” at http://hpaste.org/70438#a70447
16:40:08 <hpaste> fragamus annotated “I think I need some "Maybe"” with “Maybe I need some "Maybe" (annotation) (annotation) (annotation)” at http://hpaste.org/70438#a70448
16:40:24 <brianbi> Does lambdabot interpret ++ and -- as @karma+ and @karma-
16:40:32 <mauke> yes
16:40:34 <fragamus_> I need help cramming a use of RandT into foo
16:41:04 <ksf> fragamus_, easy.
16:41:13 <brianbi> mauke: was that a response to me or someone else
16:41:17 <ksf> when (not left) (put (a, b, newc)
16:41:31 <lpsmith> It'd be nice if GHC warned that a constructor/variable isn't ever used in a meaningful way... such as a data constructor that is not exported from a module and only appears in a pattern,  and never as a constructor.
16:41:39 <ksf> oh. when (not . null $ left)
16:42:02 <ksf> there's no need to factor the lets into the else branch.
16:42:16 <ksf> haskell is lazy. they won't get evaluated if they aren't needed.
16:42:49 <ksf> pattern matching is meaningful.
16:43:20 <lpsmith> If you never use a constructor on the right hand side,  it's not.
16:43:32 <ksf> of course it is.
16:43:46 <fmap> data Void = Void Void
16:43:49 <ksf> there could be an unsafeCoerce, somewhere.
16:44:10 <lpsmith> ksf, that doesn't count
16:44:32 <lpsmith> besides,  you could selectively disable the warning for that.
16:45:03 <ksf> I'm still waiting for pragmas that let you enable and disable options line-wise.
16:45:14 <dmwit> brianbi: ++ and -- are not identical to ?karma+ and ?karma-: there are some special cases for the inline version (like C++ doesn't do anything but ?karma+ C does).
16:45:35 <lpsmith> I mean,  there isn't much you can do to reason about Haskell code if you assume if you allow unsafeCoerce and unsafePerformIO and FFI to be used in arbitrary ways.
16:45:37 <dmwit> fmap: newtype Void = Void Void is better; your version is inhabited by infinitely many non-bottom "values".
16:45:39 <lpsmith> ksf, that would be nice
16:45:40 <ksf> probably would need an epic rewrite of ghc's internal state tracking, which'd be a Good Thing(tm) :)
16:45:52 <lcfrs> jmcarthur: yes, I guess that's true.
16:46:20 <harrison> i am not the walrus
16:46:28 <Raynes> But I am.
16:46:51 <ClaudiusMaximus> lpsmith: what about   module Foo(Foo(Used), foo, unFoo) where data Foo = Used | Unused deriving (Enum) ; foo = succ ; unFoo = pred   -- this warning stuff could get complicated fast
16:48:03 <dmwit> ClaudiusMaximus: deriving (Enum) uses both Used and Unused on a RHS.
16:48:04 <dmwit> easy
16:49:02 <ksf> dmwit, now figure out whether some TH code uses it.
16:49:04 <ClaudiusMaximus> lpsmith: it sure would be nice in some circumstances, but in others it could get tedious (eg: bad habit of mine is using Show/Read for serialization with record syntax... i should switch to parsers/prettyprinters but i lazy..)
16:49:24 <dmwit> ksf: GHC has access to the splices.
16:49:38 <ksf> yeah but it may not even splice them, but still use.
16:49:53 <dmwit> what?
16:50:07 <ksf> reductio ad turingam.
16:50:09 * hayashi :: Maybe Walrus
16:50:27 <dmwit> ksf: You may have a valid point, but I can't even parse your English.
16:50:51 <dmwit> Let alone resolve the pointers in your sentence. =P
16:50:53 <ksf> the TH code could look at the constructor to decide something, but not splice it.
16:51:06 <dmwit> Ah, yes.
16:51:09 <dmwit> That's harder.
16:51:16 <ksf> which means that to figure it out, you'd need to solve the halting problem.
16:51:56 <dmwit> I think GHC could be excused for printing a warning if none of the code (including splices) mentioned a particular constructor, and left it to the human to decide whether actually taking the constructor out would change what the TH did.
16:52:17 <dmwit> TH is sort of an "all bets are off" extension, anyway.
17:07:17 <fragamus> ksf: Thank you for pointing out that the let equations are evaluated lazily
17:07:35 <brianbi> dmwit: thanks, found it
17:45:23 <tbelaire> how do I tell ghc that my gcc has moved?
17:45:53 <hpc> is gcc still on your path?
17:46:44 <tbelaire> yes
17:46:54 <ksf> tbelaire, "ghc", "ghci" etc. are mere wrapper scripts, you can configure virtually everything there.
17:47:10 <tbelaire> ok, thanks
17:47:13 <ksf> and ghc should find the new gcc automatically, I think.
17:47:23 <tbelaire> it's not
17:48:14 <jfischoff> tbelaire: are you on osx lion?
17:48:19 <tbelaire> yes
17:48:42 <tbelaire> Should I just use brew?  Lets see what version that has
17:48:43 <jfischoff> hpaste the error
17:48:53 <jfischoff> @hpaste
17:48:53 <lambdabot> Haskell pastebin: http://hpaste.org/
17:49:02 <tbelaire> It's a one line error
17:49:06 <jfischoff> ok
17:49:13 <tbelaire> ghc: could not execute: /Developer/usr/bin/gcc
17:49:20 <tbelaire> and that's because that doesn't exist
17:49:45 <tbelaire> gcc lives at /usr/bin/gcc now
17:49:51 <jfischoff> oh I thought it might be something else. Did you just move it? hash -r might fix it
17:50:17 <tbelaire> I didn't just move it, but I haven't used ghc fora  while.  hash -r?
17:51:00 <aristid> tbelaire: hash -r makes the shell forget all memorized binary locations
17:51:35 <tbelaire> nope, but ghci works ok
17:51:51 <tbelaire> I think I might get the newest Haskell Platform
17:51:56 <tbelaire> see if that fixes everything
17:53:40 <tbelaire> oh, I just sudo vi $(which ghc)
17:53:47 <tbelaire> and fixed the location there
17:53:57 <tbelaire> Thanks you for the help
18:04:00 <kaitocracy> hi is there any way to generate a core dump in haskell?
18:04:17 <kaitocracy> or rather after a core dump has been generated is there any way to analyze it?
18:04:37 <shachaf> gdb?
18:04:42 <shachaf> There probably aren't really nice tools for it.
18:04:56 <shachaf> I think Enigmagic worked on some tools to make gdb work more nicely with GHC?
18:05:51 <kaitocracy> so if I gdb'd a haskell core dump I'd probably get all kinds of weird output right?
18:05:57 <kaitocracy> would any of the function names even be recognizable?
18:06:14 <Enigmagic> kaitocracy: yes, there are symbols for top level functions
18:06:21 <mauke> you're assuming there will be a call stack
18:06:31 <kaitocracy> oh would I not even get a call stack?
18:06:44 <mauke> where from?
18:06:48 <Enigmagic> there is an evaluation stack
18:07:00 <Enigmagic> depending on the crash it can be useful
18:07:09 <kaitocracy> I see I see
18:07:22 <kaitocracy> so one other question; is there any way to handle stuff like out of memory in a haskell program?
18:07:40 <kaitocracy> in C if I malloc and it doesn't work because of OOM I can actually theoretically handle that
18:07:49 <kaitocracy> if my application were really robust I might be able to free some stuff
18:07:55 <kaitocracy> is there any way to do something similar in Haskell?
18:08:26 <Cale> kaitocracy: Largely, no. You could possibly handle such a thing using FFI primitives
18:08:51 <Cale> But since you're not managing your memory by hand, there's generally nothing you can do to deallocate things.
18:10:29 <teneen> How come this function "(a -> Bool) -> a -> Maybe a" is not available in the standard libraries?
18:10:54 <Cale> No particular reason
18:10:58 <teneen> it's handy when dealing with the Maybe monad
18:11:15 <Cale> It's also expressible nicely in terms of the Maybe monad.
18:11:25 <Cale> (and guard)
18:13:10 <teneen> Cale: true
18:16:24 <stephenjudkins> kaitocracy: i have no idea if Haskell supports this, but on the JVM there are {Weak, Soft}References that work decently for that kind of thing. don't try to get too clever with them, though.
18:17:41 <stephenjudkins> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Mem-Weak.html
18:43:05 <dmwit> Yes, I also like ensure p x = guard (p x) >> return x
18:43:14 <dmwit> But I don't know where it would fit in the standard libraries. =P
18:43:27 <rhencke> is it normal that my head exploded while trying to learn haskell?
18:43:34 <dmwit> Pretty normal. =)
18:43:39 <rhencke> ok, whew.
18:43:46 <dmwit> Heck, even GHC's mind explodes from time to time.
18:44:21 <dmwit> http://stackoverflow.com/a/213441/791604
18:44:34 <rhencke> wow.
18:44:40 <rhencke> it really does.
18:44:49 <rhencke> somehow that makes me feel better.  thanks. :)
18:47:37 <rhencke> when it does work though, it's kinda spine-tingly.
18:54:16 <otters> > let 5 = 6 in 5
18:54:18 <lambdabot>   5
18:55:54 <rwbarton> > let (x, 5) = ((), 6) in x
18:55:55 <lambdabot>   *Exception: <interactive>:3:4-19: Irrefutable pattern failed for pattern (x...
18:56:26 <rwbarton> > let (x, ~5) = ((), 6) in x
18:56:27 <lambdabot>   ()
18:56:55 <shachaf> > let () = undefined in 5
18:56:57 <lambdabot>   5
18:57:09 <parcs`> > let ~(x, 5) = ((), 6) in x
18:57:10 <lambdabot>   *Exception: <interactive>:3:4-20: Irrefutable pattern failed for pattern (x...
18:57:23 <parcs`> > let ~(~(x,5)) = ((), 6) in x
18:57:24 <lambdabot>   *Exception: <interactive>:3:4-22: Irrefutable pattern failed for pattern (x...
18:57:32 <rwbarton> let bindings effectively have an implicit ~
18:58:34 <shachaf> letь 5 = 6 in 5
18:58:53 <rhencke> > let bygones = bygones
18:58:54 <lambdabot>   not an expression: `let bygones = bygones'
18:59:00 <parcs`> why does 6 get forced when forcing x?
19:00:26 <rwbarton> i guess it translates to something like let x = case ((), 6) of (x, 5) -> x
19:00:48 <geekosaur> that's my understanding
19:01:07 <rwbarton> (... ; _ -> error "Irrefutable pattern failed for ...")
19:08:33 <SrPx> I'm learning about Haskell. I don't understand a thing. What is the purpose of this: data Person = Person { firstName :: String , lastName :: String , age :: Int  } deriving (Eq, Show, Read)
19:09:05 <SrPx> Why do you have to bind firstname, lastName and so on to the concept of Person? What if you decide to change it later? What if you have persons with different name conventions later on?
19:09:16 <SrPx> And why the deriving (Eq, Show, Read)?
19:09:19 <rwbarton> it's like a struct in C
19:09:19 <shachaf> Then you have a different data type.
19:09:31 <rwbarton> if you want to change it later, you change the definition of Person
19:09:31 <SrPx> rwbarton: those are bad
19:09:35 <rwbarton> I see
19:09:38 <SrPx> :/
19:09:47 <SrPx> can I have some duck typing on haskell
19:09:57 <shachaf> No.
19:10:01 <SrPx> sigh
19:10:03 <blackdog> SrPx: you can have a typeclass
19:10:05 <shachaf> (Well, yes, but no.)
19:10:13 <blackdog> more like defining interfaces and then implementations.
19:10:18 <shachaf> You can use a typeclass but it'll lead to bad code the way you're approaching this.
19:10:18 <irene-knapp> not for you.  come back - one year.
19:10:26 <irene-knapp> don't feed him, he's trolling
19:10:31 <SrPx> irene-knapp: ?
19:10:46 <copumpkin> SrPx: you're basically taking a language that is known for its strong types and saying "I don't want types"
19:10:46 <SrPx> irene-knapp: I didn't offend you in any point man.
19:10:57 <copumpkin> SrPx: either you're missing the point
19:11:05 <irene-knapp> I didn't take offense.  I was just pointing out the nature of the communication happening here for those who might have missed it.
19:11:21 <SrPx> copumpkin: you're considering that I already knew that information for some reason
19:11:31 <Axman6> SrPx: it's time you learnt about why static typing is important
19:11:46 <SrPx> Axman6: Why it is important?
19:12:01 * shachaf sighs.
19:12:38 <SrPx> I have a good idea, what if instead of "sighing" and attacking me, you just educate me ?
19:13:32 <Axman6> SrPx: because it gives you a much higher level of assurance that your programs are correct. the compiler can find a whole universe of bugs that can't be found in dynamically typed languages, and they allow the compiler to make much better decisions about optimisations because it already knows the types of everything at compile time
19:13:35 <shachaf> SrPx: You should read the FAQ!
19:13:36 <shachaf> @where faq
19:13:37 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
19:13:39 <shachaf> It explains everything.
19:14:37 <shergill> isn't the next version of ghc supposed to include a kind of delayed type checking? basically issuing warnings for certain type errors and deferring to runtime exceptions when code is executed. would aid in prototyping
19:15:07 <SrPx> Axman6: it makes the process of developing the program more lengthly, thought, don't it? I'm just searching for a language that allows fast prototyping. I like how haskell treats functions, lambda, partial application and such.
19:15:22 <Axman6> SrPx: also it's not our job to teach you haskell, so please don't treat us like it is. you came in asking questions that are pretty silly if you know anything at all about haskell. people often get annoyed when people don't put in any effort learn and just ask for answers. this is why you've not received the warm welcome this channel is renowned for
19:16:10 <shergill> SrPx: http://hackage.haskell.org/trac/ghc/wiki/DeferErrorsToRuntime
19:16:12 <Axman6> SrPx: not once you get used to it. you think about everything in terms of their types
19:16:54 <Eduard_Munteanu> SrPx: depends if you take debugging time into account :D
19:17:43 <Axman6> you'll often write your programs by thinking of their types first, then writing the implementations of the functions, and if it compiles, you know that you have a very good chance that your program is correct. all that's left is logic errors usually (which almost no language can help you with)
19:17:43 <blackdog> There is some value in getting a crappy, half-debugged version up to get feedback quickly, and it's not really haskell's strong suit
19:18:10 <Axman6> blackdog: but hopefully will be soon with the deferred type errors =)
19:18:24 <SrPx> Axman6: I'm not saying you have to teach me, just that instead of attacking me you could just have used that effort to say something constructive... I didn't attack anyone just placed a question...
19:18:53 <shachaf> SrPx: There is a long history in this channel -- and in IRC -- that you're missing.
19:19:28 <blackdog> SrPx: the question wasn't really answerable. "What is this thing i don't even" ... how do you answer that?
19:19:30 <shachaf> In general this channel is probably one of the friendlier ones on Freenode. But it's still polite to ask questions in some ways, and not in other ways.
19:19:30 <SrPx> shachaf: what?
19:20:04 * Axman6 joins #java: "how do I write all my programs without using objects at all, and how do I make lambdas in java?"
19:20:27 <shachaf> Axman6: Just switch to Java 8!
19:20:38 <SrPx> shachaf: I just ask the question the first way I manage to phrase it correctly enough, writting in english is already hard enough for me
19:20:38 <rhencke> SrPx: i can understand your pain - trying to learn Haskell, too.  it's hard to re-think the basics you're used to building programs with.
19:20:39 <Axman6> that only solves half my problems!
19:20:55 <SrPx> so...
19:21:15 <SrPx> blackdog: yes, I'm searching for a language that allows just this. Haskell's syntax for functions is the best one I've seen
19:21:19 <blackdog> SrPx: let's try again. do you have a question?
19:21:42 <SrPx> blackdog: no, nevermind =/
19:21:47 <Eduard_Munteanu> IDK, after all, it's still the old weak vs strong typing debate.
19:21:47 <SrPx> it's okay
19:22:00 <rhencke> i prefer firm typing, like tofu
19:22:05 <Eduard_Munteanu> It's not like you can open your eyes to Haskell if you dislike strong typing.
19:22:46 <heatsink> You can tell a lot about a man by the way he types.
19:22:48 <SrPx> I don't get how strong typing is bound to functional programming, though.
19:22:53 <rhencke> it's not
19:23:09 <rhencke> it's just bound to haskell :)
19:23:14 <SrPx> I see
19:23:38 <heatsink> First-class functions are much harder to reason about without types
19:23:47 <parcs`> shergill: yeah
19:24:13 <blackdog> Eduard_Munteanu: while i hate to rekindle this one - do you mean static vs dynamic? Python and Ruby are strongly typed, after all
19:24:13 <heatsink> Or, to say it another way, first-order programs are easier to reason about without types
19:24:37 <Eduard_Munteanu> blackdog: dynamic isn't the issue here, SrPx complained Haskell doesn't do duck typing
19:24:42 <rwbarton> blackdog: in some ways, but not when it comes to, say, records
19:25:21 <Eduard_Munteanu> Also, as I recently learned from Erlang, yeah, strong typing doesn't mean much if you don't have a type system to begin with ;)
19:25:23 <SrPx> I was not aware "duck typing" was seen with a bad conotation here.
19:25:39 <rhencke> it's not bad or good in and of itself
19:25:42 <rhencke> it's just a way to get something done
19:26:07 <parcs`> duck typing is the source of many subtle errors
19:26:10 <Eduard_Munteanu> (or much of a type system, I give you that :D)
19:26:37 <Eduard_Munteanu> Truth is, people in here generally prefer strong type systems, I think.
19:26:47 <shergill> ifonly we could marry erlang's fault tolerance/robustness with haskell's expressive type system and cleaner syntax, we'd have a winner
19:26:50 <Eduard_Munteanu> (and rich types)
19:26:58 <SrPx> heatsink: you said first order functions are easier to reason about without types ?
19:27:03 <SrPx> what does that mean?
19:27:13 <Eduard_Munteanu> He said "with".
19:27:15 <heatsink> First-order programs
19:27:28 <rhencke> he said without, but i think he meant with
19:27:37 <rwbarton> without as compared to higher-order functions
19:27:39 <Eduard_Munteanu> Erm, sorry.
19:27:49 <heatsink> I was comparing first-order programs to higher-order programs
19:27:54 <Eduard_Munteanu> Yeah, that was confusing :D
19:28:05 <solrize> srpx, haskell is so fast it can construct an INFINITE list in almost no time.
19:28:11 <solrize> > take 5 $ [1..]
19:28:12 <lambdabot>   [1,2,3,4,5]
19:28:42 <Eduard_Munteanu> I was thinking first-class functions.
19:28:47 <rhencke> and watch how fast it finds the last element of an infinite list!
19:28:47 <SrPx> solrize: I think this is really good.
19:28:49 <rhencke> > last [1..]
19:28:53 <lambdabot>   mueval-core: Time limit exceeded
19:28:55 <rhencke> ...
19:28:57 <otters> > let a = a in a
19:29:01 <lambdabot>   mueval-core: Time limit exceeded
19:29:25 <solrize> >let t = map (2*) (1:t) in t
19:29:31 <solrize> > let t = map (2*) (1:t) in t
19:29:32 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
19:30:58 <rhencke> it's really hard to take learning haskell slowly
19:35:54 <heatsink> > take 3 $ let f g x = g x x in iterate (f (^)) 12
19:36:00 <lambdabot>  Terminated
19:37:32 <applicative> > take 3 $ iterate (join (^)) 2
19:37:33 <lambdabot>   [2,4,256]
19:37:50 <heatsink> join?
19:37:57 <heatsink> What monadery is this?
19:38:12 <applicative> @type join
19:38:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
19:38:15 <dmwit> join f = \x -> f x x
19:38:39 <dmwit> in the (e ->) monad
19:38:56 <dmwit> join :: (e -> (e -> a)) -> (e -> a)
19:39:02 <applicative> for the (a -> _) monad it makes an (a  -> (a -> x)) into an (a -> x)
19:39:06 <shachaf> @ty join .: join
19:39:06 <Eduard_Munteanu> Or an unwrapped variant of Reader.
19:39:07 <lambdabot> forall (m :: * -> *) a (g :: * -> *). (Monad m, Monad g, Functor g) => g (g (m (m a))) -> g (m a)
19:39:21 <heatsink> Oh
19:40:19 <coppro> shachaf: you're a terrible person
19:41:34 <applicative> > join .: join $ (Just $ Just ["hello", "world"])
19:41:36 <lambdabot>   Just "helloworld"
19:42:48 <coppro> !give applicative useless parens award
19:43:02 <rwbarton> @ty (join .: join) . fmap Data.Traversable.sequence
19:43:03 <lambdabot> forall (m :: * -> *) a (g :: * -> *). (Monad m, Monad g, Functor g, Data.Traversable.Traversable m) => g (m (g (m a))) -> g (m a)
19:43:10 <applicative> yeah, i started another way '
19:43:36 * applicative secretly cant tell his left from his right
19:44:05 <dmwit> quick, somebody get their inferred type to spell something cool
19:52:20 <solrize> the haskell faq is awesome; i don't think i'd read thru it before (unless it's expanded a lot recently)
19:53:58 <fragamus> hey guys google search is giving me fits    I'm trying to learn about "when"
19:54:19 <fragamus> any links would be appreciated
19:54:37 <geekosaur> @index when
19:54:37 <Eduard_Munteanu> :t when
19:54:37 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
19:54:39 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
19:55:07 <Eduard_Munteanu> when condIsTrue doThis
19:55:22 <dmwit> ?src when
19:55:22 <lambdabot> when p s = if p then s else return ()
19:55:28 <dmwit> nothing more to learn =)
19:56:00 <dmwit> 's' is a weird choice of variable name
19:56:11 <dmwit> ?src unless
19:56:12 <lambdabot> unless p s = if p then return () else s
19:56:33 <fragamus> thanx
19:56:42 <fragamus> i never saw it before today
19:57:08 <dmwit> But yes, for this kind of question you should use hoogle or hayoo instead of google or yahoo. =)
19:57:10 <fragamus> I have done a fair bit of reading but I must've skipped it
20:08:57 <zachk> > fmap (*2) (5,10)
20:08:58 <lambdabot>   (5,20)
20:11:04 <zachk> how do I get my haskell to do that (fmap f (a,b)) ?
20:11:36 <otters> zachk: what are you wanting to happen
20:11:59 <zachk> I actually want to fmap an IO action over a tuple
20:12:01 <rwbarton> the instance might be in Control.Monad.Instances
20:12:40 <shachaf> "fmap an IO action over a tuple" is a type error
20:13:03 <otters> is not
20:13:08 <otters> :t fmap print (1, "hello")
20:13:09 <lambdabot> forall t. (Num t) => (t, IO ())
20:13:17 <zachk> ok, so what is the \proper\ way to do it ?
20:13:33 <zachk> or should I roll my own?
20:13:57 <rwbarton> (print isn't an IO action)
20:14:06 <zachk> ??
20:14:08 <rwbarton> what do you actually want to do
20:14:10 <otters> what is it, then?
20:14:22 <zachk> oh yea
20:14:32 <rwbarton> a function that returns an IO action
20:14:38 <otters> I assume zachk meant a function that returns an IO action
20:14:58 <zachk> (a->IO b) -> (a,a) -> IO (b,b)
20:15:02 <rwbarton> so far it's not entirely clear zachk means anything at all :P
20:15:14 <otters> oh
20:15:18 <otters> so you just want fmap to operate on both sides
20:15:19 <zachk> oh I mean something, I just haven't completely defined what I mean until the last line
20:15:24 <rwbarton> okay
20:15:34 <otters> @let fmap2 f (a,b) = (f a, f b)
20:15:36 <lambdabot>  Defined.
20:15:36 <rwbarton> this isn't very fmap-like
20:15:40 <otters> yeah
20:16:16 <zachk> what is it more like then?
20:16:26 * zachk contemplates arrows which he has no idea on how to use.... 
20:16:30 <parcs`> :t join (***)
20:16:31 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
20:16:39 <shachaf> @@ @pl @undo \f (x,y) -> do { x' <- f x; y' <- f y; return (x',y') }
20:16:40 <lambdabot>  (`ap` snd) . (. fst) . liftM2 flip (((.) . (>>=)) .) (flip flip ((return .) . (,)) . (((.) . (>>=)) .))
20:16:42 <otters> that's the one
20:16:44 <shachaf> ...You can probably do better than that.
20:19:24 <zachk> well thank you
20:19:42 * zachk goes to make his own thingy 
20:20:14 <shachaf> uncurry (liftM2 (,)) .: join (***)
20:20:16 <shachaf> Something like that.
20:20:24 <shachaf> (...But just write it out explicitly.)
20:28:14 <dibblego> join bimap
21:02:11 <kkyqqp> why does this hang when it works for 4 or less?              foldr (^) 1 [1..5]
21:02:13 <kkyqqp> > foldr (^) 1 [1..5]
21:02:18 <lambdabot>   mueval: ExitFailure 1
21:02:18 <lambdabot>  mueval: Prelude.undefined
21:02:30 <kkyqqp> > foldr (^) 1 [1..4]
21:02:31 <lambdabot>   1
21:03:25 <Eduard_Munteanu> Are you sure you want foldr?
21:03:48 <kkyqqp> I'm not actually using the function, it was a typo and I'm just curious why it doesn't work
21:03:56 <avpx> it's because of the associativity
21:04:18 <rwbarton> because 2^3^4^5 is a big number
21:04:33 <avpx> 1^(2^(3^(...))) is much different (in terms of how this is computed) than ((1^2)^3)^...
21:04:38 <rwbarton> > 3^4^5
21:04:40 <lambdabot>   373391848741020043532959754184866588225409776783734007750636931722079040617...
21:04:52 <rwbarton> it has that many bits, however long that number is
21:04:54 <kkyqqp> ah right, that's very clear thanks
21:05:07 <avpx> :)
21:06:27 <Saimass0ud> Am I the only one who thinks foldr looks like folder.
21:06:32 <Saimass0ud> As in, directory.
21:40:24 <solrize> 3^4^5 = 3^2^10 = 3^1024 = a sort of manageable number
21:41:36 <dmwit> 3^1024 is a manageable number, but it's rather a lot if the unit is "bits"
21:41:44 <solrize> yes :)
21:41:56 <solrize> .w graham's number
21:42:12 <solrize> @w graham's number
21:42:12 <lambdabot> Maybe you meant: web1913 what where where+ wiki wn world02 . ? @ v
21:43:11 <dmwit> > 1024 * logBase 1024 3 - logBase 1024 8
21:43:12 <lambdabot>   162.0001600738464
21:43:32 <dmwit> kilo, mega, giga, tera, peta, exa ... that's six
21:43:39 <dmwit> I don't think we have 162 different prefixes. =)
22:05:03 <T_X> hm, for haskell coding style, do you usually put the most abstract function at the top or at the bottom in your source code?
22:05:52 <T_X> from c coding and languages alike, I usually tend to put the most atomic ones at the top as without function preceding function declarations, compiling would fail
22:06:17 <T_X> but as in haskell I could do it the other way round too, I'm wondering whether I should do it the other way round
22:07:56 <strager> I think most of my top-level functions are equally 'atomic'
22:07:59 <strager> per module
22:08:30 <kallisti> same here. However at some point I deviate and begin doing a top-down organization.
22:08:30 <strager> Lemme check what actually happens in my code though =]
22:08:45 <T_X> :D
22:08:55 <kallisti> so by the end you're reading the lower-level / intermediate-level functions.
22:09:42 <strager> Well, I have an export list at the top of my cleanly-coded modules.  The definitions match the order of the export list.  So whatever makes sense for the export list.
22:10:11 <strager> So usually: data types, primitive functions, helper functions
22:13:14 <T_X> strager: hm, okay. so if I have a simple algorithm which I can seperate like f (g (h x)), you'd have function f at the top of your source code file and function h at the bottom?
22:15:03 <strager> That's a pretty broad question, but perhaps, yes
22:15:20 <strager> as that's how I'd write it using composition or bind or a let chain
22:15:53 <T_X> hm, okay. thanks!
22:44:50 <kallisti> > 101*100/2
22:44:51 <lambdabot>   5050.0
22:44:52 <kallisti> > sum [1..100]
22:44:53 <lambdabot>   5050
22:44:58 <kallisti> this would be a useful rewrite rule I think.
22:45:05 <kallisti> with `div` instead of /
22:45:13 <monochrom> haha
22:48:28 <avpx> kallisti: That sum notation is also bad because it eats up memory on the stack
22:49:21 <copumpkin> it doesn't if you actually compile the code
22:49:59 <avpx> copumpkin: Oh really? That's great.
22:50:07 <copumpkin> it's kind of a spec bug there
22:50:13 <copumpkin> but the optimizer is smart enough to see through it
22:50:28 <avpx> That's neat, I wonder how that works.
22:50:56 <avpx> Unfortunately GHC is pretty completely opaque to me.
22:55:16 * hackagebot yackage 0.5.0.1 - Personal Hackage replacement for testing new packages.  http://hackage.haskell.org/package/yackage-0.5.0.1 (MichaelSnoyman)
