00:00:43 <T_X> does something like a 'replicate :: Integer -> a -> [a]' exist?
00:01:01 <T_X> or is a list always limited to a number of elements fitting an Int?
00:02:09 <T_X> ah, wait, just found genericReplicate
00:21:29 <ark11> i am a newbie in haskell ... started reading LYAH now
00:21:37 <kfish> hi ark11
00:50:18 * hackagebot github 0.4.0 - Access to the Github API, v3.  http://hackage.haskell.org/package/github-0.4.0 (MikeBurns)
00:59:48 <solrize> https://gitorious.org/~simons   holy crap i didn't know about this
01:01:49 <srhb> Ok, is there a definitive guide on this goddamn Internal ByteString error when you have another ByteString imported? <_< I think it is _the_ most confusing thing.
01:02:50 <srhb> And all the docs just say "ByteString", but it's definitely not just any ByteString.
01:03:13 <shachaf> srhb: There are two ByteStrings.
01:03:30 <shachaf> The module Data.ByteString has one and the module Data.ByteString.Lazy has another one.
01:03:49 <shachaf> The types themselves are defined in Data.ByteString.Internal and Data.ByteString.Lazy.Internal.
01:04:48 <srhb> I don't understand how I manage to get these error then, no matter if I use Data.ByteString.Lazy or Data.ByteString.
01:05:05 <srhb>     Couldn't match expected type `Data.ByteString.Internal.ByteString' with actual type `B.ByteString' -- all the friggin' time.
01:05:05 <srhb>  
01:05:22 <shachaf> Is B Data.ByteString.Lazy?
01:05:27 <srhb> Either
01:05:31 <srhb> Both give that error
01:05:36 <shachaf> That doesn't sound right.
01:05:43 <shachaf> If B is Data.ByteString, it should work.
01:05:48 <shachaf> Are you sure it's not a subtly different error?
01:06:00 <srhb>     Couldn't match expected type `B.ByteString' with actual type `Data.ByteString.Lazy.Internal.ByteString' -- strict
01:06:00 <srhb>  
01:06:19 <srhb> But I will diff the entire errors now :P
01:06:39 <shachaf> Is that error coming from a different line?
01:06:52 <shachaf> I suspect you have code that uses both strict and lazy.
01:08:05 <srhb> Might be.. Guh.
01:09:35 <srhb> I still think it would be clearer if these were not both called ByteString
01:09:42 <srhb> Entire libraries work on either one or the other, but not both.
01:10:38 <shachaf> srhb: They're easy to convert back and forth.
01:10:47 <srhb> Yeah..
01:14:10 <srhb> On a different note, is it possible Data.Compression.GZip.decompress is screwing with UTF8? It shouldn't, right>
01:14:55 <shachaf> If it's a thing that operates on ByteStrings, nope.
01:15:14 <Botje> unless it screws with high bits
01:15:18 <Botje> but that'd be evil
01:15:46 <srhb> Yes, it operates on ByteStrings..
01:16:23 <shachaf> gzip ought to be a function :: ByteString -> ByteString
01:16:57 <srhb> It is.
01:17:14 <shachaf> It oughtn't know about UTF-8.
01:17:28 <srhb> OK, new error.
01:17:38 <srhb>     Couldn't match expected type `GHC.Word.Word8' with actual type `Char'
01:17:38 <srhb>  
01:17:57 <shachaf> Sounds like you're confusing Chars and bytes.
01:18:09 * srhb rages
01:18:10 <srhb> :P
01:18:50 <shachaf> Do you know the difference between the two?
01:18:57 <srhb> I guess I don't!
01:19:03 <shachaf> You're liable to be called racist by a fellow who's no longer in this channel if you don't.
01:19:23 <srhb> Well, we don't want that.. :P
01:19:26 <Botje> a char is a unicode codepoint, a byte is a byte
01:21:04 <srhb> (L.unpack . decompress . L.pack)
01:21:07 <srhb> Doesn't that look right?
01:21:12 <srhb> (used on a String)
01:21:21 <srhb> Where L is Lazy ByteString
01:21:41 <srhb> Ah.. pack is the sinner.
01:22:21 <shachaf> srhb: Yes, don't use "pack".
01:22:35 <srhb> What's the right way to convert then?
01:22:45 <shachaf> If you want to encode some characters into a ByteString, pick your encoding and then use a function that encodes with it.
01:22:50 <shachaf> For example encodeUtf8
01:23:20 <srhb> But it's gzipped. How do I know what encoding that needs?
01:23:33 <shachaf> Wait, what?
01:23:38 <shachaf> You're doing L.pack of something.
01:23:44 <shachaf> What's that something?
01:24:03 <srhb> An originally base64 encoded String of gzipped data that I've just un-base64'ed
01:24:33 <quicksilver> you can't base64 encode a string
01:24:36 <quicksilver> that doesn't make sense
01:24:47 <srhb> I can base64 decode it though?
01:24:52 <quicksilver> no
01:24:56 <srhb> Why not?
01:24:58 <quicksilver> base64 is a byte encoding
01:25:01 <quicksilver> not a char encoding
01:25:05 <quicksilver> so it doesn't apply to strings
01:25:16 <srhb> Ok, well, the code was basically working before, but ate unicode characters
01:25:19 <srhb> So it's apparently doable.
01:25:56 <shachaf> It's doable but you have to keep the types straight.
01:26:13 <srhb> Yeah, and I guess I didn't
01:26:17 <srhb> Here's the original, working version
01:26:22 <srhb> B.unpack . decompress . B.pack . decode . zippedsub $ downloadedString
01:26:28 <shachaf> What's B?
01:26:31 <srhb> er, forget the zippedsub
01:26:35 <shachaf> I hope the answer isn't Data.ByteString.Char8. :-(
01:26:41 <srhb> Um.. <_<
01:26:48 <srhb> OK, let's say that it isn't.... <_<
01:27:02 * srhb hides
01:27:15 <shachaf> srhb: I recommend forgetting about the existence of Data.ByteString.Char8
01:27:27 <srhb> Duly noted. :-)
01:27:45 <quicksilver> it's possible to use Chars to store Word8s, clearly
01:27:47 <quicksilver> since they fit
01:27:56 <quicksilver> however doing so leads to confusion and all else being equal, you should avoid doing so
01:28:14 <srhb> So what I need is to handle the base64 decoding better
01:28:23 <shachaf> srhb: So replace B.pack with encodeUtf8 and B.unpack with decodeUtf8
01:28:23 <quicksilver> use Word8 when you mean Word8 and Char when you mean Char
01:28:31 <quicksilver> and hopefully it becomes clearer.
01:28:40 <shachaf> And figure out the difference between Word8 and Char.
01:29:03 <srhb> shachaf: Are you sure about that. I mean, I B.pack so that I can pass the resulting ByteString to gzip.. Why would I encodeUTF8 it?
01:29:10 <srhb> quicksilver: I'll try.. Thanks
01:29:18 <srhb> ungzip rather
01:30:05 <shachaf> srhb: Oh, no, that shouldn't be a String in the first place.
01:30:11 <srhb> Ack!
01:31:57 <srhb> I am receiving the String over XmlRpc
01:32:51 <shachaf> If you're getting a String and you can't help yourself, then you'll probably want to "parse" it into bytes or whatever it's meant to be wherever you can.
01:33:03 <shachaf> At any rate base64decode should be a function that returns bytes.
01:33:30 <srhb> I guess I'm using a wrong decode function then. Gonna try and hoogle for a better one, thanks
01:34:15 <shachaf> If your decode function is just broken and returns a bunch of Chars between 0 and 255, you can convert *those* Chars into Word8s.
01:34:30 <shachaf> I recommend making a wrapping decode function for it if that's what you have to do.
01:34:43 <srhb> The weird thing is that gzip hasn't been choking on the data yet
01:34:51 <srhb> Which really made me think the problem was with the gzip -> string bath
01:34:53 <srhb> path*
01:35:09 <srhb> I mean, if decode was broken, wouldn't it choke on decompressing the data?
01:35:11 <shachaf> Yes, that's probably the actual only part you need to change.
01:35:29 <shachaf> Replace B.unpack with decodeUtf8 and it should work fine.
01:35:34 <shachaf> But you should still figure out the other changes. :-)
01:35:42 <srhb> Yeah. :) I can't find the proper decode function though
01:35:51 <srhb> There's String -> String or ByteString -> ByteString
01:36:34 <shachaf> @hoogle decodeUtf8
01:36:38 <lambdabot> Data.Text.Encoding decodeUtf8 :: ByteString -> Text
01:36:40 <lambdabot> Data.Text.Lazy.Encoding decodeUtf8 :: ByteString -> Text
01:36:42 <lambdabot> Data.Text.Encoding decodeUtf8' :: ByteString -> Either UnicodeException Text
01:36:43 <shachaf> Maybe you need to go through Text? I don't know.
01:37:06 <srhb> Me neither.
01:47:01 <solrize> wha?  i just installed haskell-platform from debian repo, ran ghci, typed "let x=3 in x" and got error message
01:47:10 <solrize> <interactive>:1:6:
01:47:10 <solrize>     Warning: Defaulting the following constraint(s) to type `Integer'
01:47:10 <solrize>              `Num t' arising from the literal `3' at <interactive>:1:6
01:47:20 <solrize> some weird issue?  i've never had that happen before.
01:47:26 <shachaf> That's not an error message.
01:47:46 <solrize> well warning message
01:47:49 <solrize> still pretty annoying
01:48:08 <shachaf> Yes. You can turn off specific warnings if you want to.
01:48:17 <shachaf> I don't think that one's on by default.
01:48:27 <solrize> well i think something is wrong with the install since it did that immediately
01:48:37 <solrize> and other times i've installed the same package it's not done that
01:48:51 <shachaf> Something is probably giving -Wall to your ghci
01:48:54 <shachaf> I have no idea.
01:49:00 <shachaf> As I said, you can turn warnings off.
01:49:18 <solrize> do you happen to know how to turn that off?
01:49:36 <shachaf> I didn't until a few seconds ago!
01:49:51 <shachaf> man ghc | grep default
01:50:36 <solrize> well i don't want to turn off too many
01:50:44 <solrize> i can't stay up too much later i'll mess with this more tomorrow i guess
01:52:31 <solrize> oh found it
01:52:37 <solrize> there was a .ghci in the directory i was in
01:52:39 <solrize> setting -Wall
01:52:44 <solrize> you pegged it ;)
01:53:03 <shachaf> Just be glad it didn't have :!rm -rf $HOME
01:53:12 <solrize> heh yeah
01:53:18 <solrize> .ghci is kind of a scary feature that way
01:53:33 <solrize> i downloaded postmaster source and am looking at it but it doesn't seem to do much
01:53:46 <b_> when I do: \x -> createProcess (proc "links" x), links is executed correctly, but the terminal is fucked up, probably because the haskell program has not terminated
01:53:56 <solrize> and the author seems to have started rewriting it in c++ :-P
01:54:04 <b_> what is the common way to hand over control to an external process?
01:54:32 <solrize> links, the text web browser?
01:54:39 <solrize> it goes and messes with the tty modes
01:54:44 <b_> yes
01:54:53 <solrize> you kind of have to save and restore them if you want them restored
01:55:00 <b_> is this avoidable?
01:55:05 <b_> hm
01:55:15 <solrize> it would be nice if some library did it
01:55:23 <solrize> but i dunno if that's so common
01:55:36 <b_> in python I use subprocess.call("links", x), and it just works
01:55:45 <int-e> b_: did you compile your program? if you do that from ghci then haskeline and links will probably interact very badly.
01:55:56 <b_> int-e: will try
01:56:50 <b_> no that does not make a difference
01:57:38 <frerich> Sorry for being offtopic, but since this is a rather large channel chances are that some op is here: there is a guy spamming in ##FreeBSD but I can't seem to find any FreeNode staff members to consider a ban or something. Is somebody around here?
01:57:56 <b_> when I press any key, it is sent to the shell
01:58:22 <koala_man> frerich: did you try #freenode already?
01:59:02 <frerich> koala_man: Ah! Thanks, I wasn't aware of that.
02:00:35 <int-e> b_: ok, you should wait for the process to finish: createProcess (proc "links" []) >>= \(_,_,_,p) -> waitForProcess p  works for me.
02:01:21 <b_> high five, awesome, thanks
02:01:22 <int-e> even from ghci :)
02:09:46 <int-e> b_: there's also "rawSystem", rawSystem "links" ["http://webspace.webring.com/people/cu/um_3734/indexanimals.htm"]
02:11:22 <b_> int-e: very nice, that's what I was looking for I guess :]
02:11:24 <b_> thanks
02:16:30 <xarch> hi
02:17:58 <Botje> hai
02:29:50 <xarch> how can I use a language pragma with literate Haskell?
02:30:11 <xarch> > {-# LANGUAGE Foo #-} doesn't seem to work
02:30:12 <lambdabot>   Not in scope: `doesn't'Not in scope: `seem'Not in scope: `to'Not in scope: ...
02:30:45 <shachaf> xarch: Is it right at the top of the file?
02:30:51 <xarch> yes
02:31:26 <shachaf> Hmm.
02:33:13 <shachaf> Looks like unlit strips it out.
02:34:45 <shachaf> xarch: Looks like \begin{code}{-# LANGUAGE ... #-}\end{code} works.
02:36:19 <ksf> do I really need a typeclass for every sum kind that I want to accept in different functions?
02:36:20 <xarch> doesn't work on my computer
02:36:40 <shachaf> xarch: On three lines.
02:36:43 <ksf> type-level lists that look like "class FooOrBarOrBaz" look quite silly.
02:36:48 <xarch> doesn't work either
02:36:55 <shachaf> Works for me.
02:36:57 <shachaf> \begin{code}
02:37:01 <shachaf> {-# LANGUAGE GADTs #-}
02:37:02 <shachaf> \end{code}
02:37:09 <shachaf> Right at the top of the file.
02:37:10 <ksf> (and, no, I don't have proper names for them)
02:37:25 <xarch> that's what I've done
02:37:30 <xarch> but it doesn't work
02:38:29 <shachaf> xarch: What version of GHC?
02:38:42 <xarch> 7.4.1
02:39:44 <shachaf> Hmm, for that matter, it works for me with > {-# LANGUAGE GADTs #-} too.
02:40:35 <xarch> hm
02:40:39 <xarch> now it works
02:40:56 <xarch> that's weird
02:41:11 <xarch> well, thanks anyway!
02:43:26 <shachaf> Is this some kind of conspiracy?
02:46:51 <dmwit> ksf: I don't think I understand the question yet.
02:49:09 <ksf> dmwit, I have an object hierarchy, to take the real example, I've got Windows and Pixmaps and both are Drawables.
02:49:16 <ksf> so far so easy to write instances for.
02:49:58 <ksf> but some but not all functions that take windows alternatively take other types, too.
02:50:39 <ksf> so if I do the usual one-instance-per-class thing, I end up with a gazillion classes, all with ugly names, most being used only once.
02:51:08 <quicksilver> have you seen the encoding where subclasses are parameters?
02:51:15 <quicksilver> so it would be Drawable a
02:51:25 <quicksilver> Drawable Window and Drawable Pixmap
02:51:43 <quicksilver> can't remember which one, but one of the GUI bindings used that encoding
02:52:10 <ksf> Ive read about it in a paper, but they discarded it because using instances is strictly more expressive.
02:52:20 <ksf> I might not need that expressivity, thoug.h
02:52:51 <dmwit> one-instance-per-class?
02:53:05 <ksf> the way gtk does it
02:53:25 <ksf> instance IsDrawable Window
02:53:40 <ksf> oh, and it's one class per class, one instance per instance.
02:53:49 <ksf> (that was too easy to get right)
02:54:53 <dmwit> I see. I think you're using a very strange meaning of "type level lists".
02:55:19 <ksf> quicksilver, the first problem I see with that approach is that one has to manually annotate windows and pixmaps with the Drawable newtype if one wants to pass it to a function.
02:55:43 <ksf> well, I don't need type-level lists as such.
02:55:44 <dmwit> But yes, if two different functions can accept a different subset of all types, then they must have different contexts.
02:55:46 <ksf> but unions.
02:56:08 <dmwit> That's not to say that you can't do something clever by using the fact that contexts can be concatenated to perform intersection...
02:56:08 <ksf> which HList can do, by applying records of functions to single values.
02:57:08 <ksf> that fact -- that products and sums are duals of each other in a way -- is annoying, btw. because I understand it must be true, but don't grok it.
02:57:59 <ksf> "records of fnuctions" that come with type-directed dispatch, otoh, are exactly typeclasses.
03:00:50 <quicksilver> exactly typeclasses are records of values, not necessarily functions ;)
03:01:02 <ksf> well, yes.
03:01:16 <ksf> but if they couldn't be functions you couldn't make them into sum selectors.
03:05:16 <Lemon> at some point
03:05:33 <Lemon> I believe I'm relying too much on types
03:05:39 <Lemon> whatever happened to
03:06:05 <Lemon> "it's better to have a hundred functions on a single datatype than ten functions each on ten datatypes."?
03:06:25 <Lemon> s/each//
03:06:32 <Lemon> forgot who said that
03:07:16 <ksf> it's not better.
03:07:42 <ksf> if you have a hundred functions on a single AST the functions are very likely partial.
03:08:04 <sipa> in haskell there is often only a single meaningful implementation for a given type!
03:09:20 * ksf is just adding another type parameter to his AST so he can change its type.
03:09:22 <ksf> shape, even.
03:09:30 <ksf> it's going to be a proper graph when I'm done.
03:09:49 <Lemon> well then
03:09:57 <Lemon> ksf, I am also dealing with an AST type
03:10:08 <Lemon> let me describe this problem I'm having
03:10:43 <Lemon> It started out as a desire to give each subtree of the expression a possible type annotation
03:10:55 <ksf> I'd rather ask fgl once whether the bugger is circular than walk along name lookups blindly.
03:11:35 <Lemon> so basically data Exp f = Id String | App (f (Exp f)) (f (Exp f)) | Lam String (f (Exp f))
03:12:20 <Lemon> but then I moved on to writing an evaluator, so I thought I'd just create another type
03:12:24 <ksf> variables in function position are always nice.
03:12:49 <Lemon> data Val = Lit String [Val] | Fun Env String Val
03:12:54 <Lemon> you know, basic stuff
03:13:48 <ksf> ...no, I don't need another parameter. it'd be identical to the other one.
03:14:21 <Lemon> oh god this is hard to explain
03:15:00 <TheLemonMan> i have a doubt in this damn one-liner foldr (shiftL 1 $ flip setBit) 0 $ map (digitToInt) "1001" how do i tell that i'm interested to the result of the flipped function and not the function itself ?
03:15:28 <shachaf> Get rid of the $, insert parentheses.
03:15:35 <shachaf> Then add a lambda for the argument.
03:16:11 <TheLemonMan> no way to keep it point-free ?
03:16:26 <shachaf> There certainly is a way.
03:16:39 <shachaf> But first you have to know what you want.
03:17:34 <TheLemonMan> i just realized that setBit doesn't do what i want
03:17:35 <Lemon> alright, I think I figured it out
03:18:38 <Lemon> the problem lies with the type of definitions: data Def f = Let (f (Pat f)) (f (Exp f)) | Def String (Up f (Exp (Up f)))
03:18:50 <Lemon> that (Up f) is the thing giving me trouble
03:19:36 <Lemon> it's a type family that returns the annotation type constructor one level up
03:19:58 <Lemon> but what should it return for the top level?
03:20:38 <dmwit> :t runMaybeT
03:20:40 <lambdabot> Not in scope: `runMaybeT'
03:20:55 <Lemon> how do I make my data types actually "terminate"?
03:35:19 <Lemon> sometimes I wish that if I write "type Foo a = Bar" the type system would just let me write "Foo" by itself and infer the kind "* -> *"
03:35:41 <Lemon> that would solve so many of my problems right now
03:37:25 <bitonic> Lemon: that would lead to "bad things" (tm)
03:38:36 <Lemon> yeah well
03:38:58 <Lemon> some men just want to watch the type checker loop
03:40:04 <bitonic> Lemon: well I wasn't even implying recursive type functions
03:50:08 <Catnaroek> Is there any library like Network.IRC, but with a proper union type to handle different IRC commands?
03:58:42 <ksf> Lemon, http://hpaste.org/70465
03:59:00 <ksf> no guarantees given, especially on the pragmas being the minimum set.
03:59:19 <ksf> and you will have to annotate functions.
03:59:27 <ksf> and ignore that :? thing.
04:00:44 <ksf> but as you see, it's perfectly possible to derive your instances even with that highly abstract type parameter.
04:06:30 <Lemon> ksf, what is that
04:06:33 <Lemon> can you explain
04:08:03 <hpc> Catnaroek: don't think so
04:09:31 <Catnaroek> Oh.
04:09:37 <ksf> Lemon, a way to reduce the number of type variables you have to pass around, by making it into a parameter for type families.
04:09:48 <ksf> then a lot of standalone deriving
04:10:18 <ksf> ...because you have to hint ghc at the needed contexts, deriving clauses won't work.
04:12:53 <Lemon> that's... not exactly what I was asking for but okay
04:12:56 <Lemon> thanks
04:15:30 * hackagebot google-html5-slide 0.1.0.0 - Google HTML5 Slide generator  http://hackage.haskell.org/package/google-html5-slide-0.1.0.0 (HideyukiTanaka)
04:29:32 <hpaste> Peaker pasted “Straightforward lens?” at http://hpaste.org/70466
04:29:48 <Peaker> Hey, instead of all the new fancy shmancy lens constructs, why not use this simple representation instead?
04:30:11 <Botje> needs a lensFactoryAbstractionSingletonPatternFactory
04:30:31 * hackagebot egison 1.2.2 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-1.2.2 (SatoshiEgi)
04:30:54 <quicksilver> Peaker: it's fine. Some implementation use it.
04:31:12 <quicksilver> Peaker: it's marginally more efficient to write "modify" if you have a combined representation.
04:31:59 <Peaker> quicksilver, what if you replace "setter" with "modify"?
04:32:11 <quicksilver> I don't know.
04:32:13 <quicksilver> :)
04:32:24 <Peaker> the question is why edwardk and others went to the very interesting approach of using these Mirrored Lens's if this approach works?
04:32:59 <Peaker> I see his approach is nicely composable with (.) -- but is the non-straightforward-ness worth it?
04:33:09 <quicksilver> efficiency I imagine
04:36:33 <MagneticDuck> yo, I just have a great idea... wouldn't it be possible to compile lambdabot and a little gui for android?
04:36:58 <MagneticDuck> with a nice keyboard that has autocorrect for haskell functions and syntax...
04:37:28 <tomboy64> is someone here involved with the haskell-overlay in gentoo?
04:37:39 <tomboy64> does it make sense to post dependency-problems?
04:37:40 <hpc> MagneticDuck: i would just do it over mueval
04:37:51 <hpc> lambdabot compilation is a ridiculous endeavor
04:38:16 <MagneticDuck> ah
04:38:43 <MagneticDuck> well lambdabot is an irc bot
04:38:58 <MagneticDuck> so it has lots of bells and whistles in the oi world
04:38:59 <mauke> tomboy64: there's a channel for that
04:39:04 <mauke> was it #gentoo-haskell?
04:39:25 <gienah> yes
04:40:11 <tomboy64> thank you very much folks :)
04:42:04 <tomboy64> is it worth installing/using leksah? or only for bigger projects?
04:43:08 <gienah> tomboy64: you could try emerge app-editors/leksah (reminds me I should bump the version)
04:44:24 <tomboy64> gienah: i am doing that and it gives me quite a few warnings bout deprecated stuff
04:44:36 <tomboy64> hmm seems like it's only about exceptions
04:51:00 <merijn> tomboy64: I (and it seems most other people?) prefer to just use plain vim/emacs for haskell projects (or really any project of any size) :p
04:51:25 <tomboy64> ^^ ok
04:52:08 <jaxtr> ahh it's a wonderful day
04:53:07 <merijn> I haven't really worked on extremely big projects, but so far the vim approach seems to scale up to (at least) several thousand files and 200k SLOC :p
04:53:20 <syntaxfree> so I need to write k-neighbour search. I was thinking of doing it with lists first and move on to arrays later.
04:54:44 <syntaxfree> basically, there's a matrix/list of lists M, and I want to compare according to some distance function each line of the matrix with the other lines, and pick up the index for the k lowest distances.
04:55:08 <kallisti> let's say you have a piece of data whose contents are completely persistent/immutable with regard to pure code, but whose interaction with pure code causes side-effects that can be felt in IO.
04:55:14 <syntaxfree> I wrote this in Matlab already, but subscripting matrices in Matlab is very easy. Also, it's untenably slow at the sizes we're working now.
04:55:32 <kallisti> does this break referential transparency? What kind of structure might have these properties?
04:55:55 <kallisti> syntaxfree: are you familiar with the vector library?
04:56:19 <kallisti> it's an efficient 1-dimensional array library. It can easily be used to emulate N dimensional matrices.
04:56:26 <syntaxfree> I was aware it existed.
04:57:07 <syntaxfree> anyway, I can kind of conceive of a explicit recursive solution, but can't match it to a primitive recursion combinator.
04:57:24 <syntaxfree> (can't install the vector library on Windows for the life of me, incidentally)
04:58:31 <kallisti> syntaxfree: so every index is compared with all the others (including itself)?
04:59:05 <syntaxfree> I'm trying to find the Haskell-y way to do this, more generally. My matrix-based solution is terribly inefficient, particularly because the input is a sparse matrix representation. Granted, this because Matlab implements SVD for sparse matrices to begin with.
04:59:17 <kallisti> ah I see.
04:59:26 <syntaxfree> (I need SVD earlier on for dimensionality reduction)
04:59:39 <nand`> tomboy64: if you want to give yi (an editor written in and ultimately for haskell) a try, I can share the -9999 ebuilds I made for it + yi-contrib
05:00:23 <kallisti> syntaxfree: say you represent your sparse matrix as a Map (see http://hackage.haskell.org/packages/archive/sized-types/0.1/doc/html/Data-Sized-Sparse-Matrix.html for an example of this implementation)
05:00:37 <kallisti> then you can produce a cartesian product of all the keys via applicative functors
05:00:45 <tomboy64> nand`: is the yi in the haskell-overlay reasonably recent?
05:00:50 <syntaxfree> .. which would be lazy, so ok.
05:00:50 <kallisti> > (,) <$> [1..10] <*> [1..10]
05:00:51 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,1),(2,2),(...
05:01:06 <kallisti> replace the lists with "keys m" where m is your sparse mapping
05:02:07 <syntaxfree> I kind of feel over my head with applicative functors, but moving on -- can the numerical libraries handle this as a matrix/2-dimensional vector?
05:02:51 <syntaxfree> hoogling right now.
05:02:56 <kallisti> you could use vector for that purpose. instead of a Map you could use a Vector of Maybes
05:03:10 <kallisti> to emulate multiple dimensions you'd have to write your own functions to handle indexing.
05:03:14 <kallisti> since vector is 1-dimensional
05:03:25 <kallisti> you could also use this sparse matrix implementation I linked, which is just a map.
05:03:34 <kallisti> syntaxfree: are you familiar with liftM2 ?
05:03:45 <kallisti> liftM2 f a b   is equivalent to f <$> a <*> b
05:03:50 <kallisti> for monads.
05:04:07 <nand`> tomboy64: I'm not entirely sure
05:04:16 <syntaxfree> well, monads yes. applicative functors just confuse me.
05:04:23 <syntaxfree> anyway, valuable tips.
05:04:29 <kallisti> (such as list, which is the monad I used to generate that cartesian product)
05:04:33 <syntaxfree> thanks. gotta run.
05:04:33 <DMcGill> what sort of thing is the Free monad used for?
05:04:40 <kallisti> later
05:05:05 <kallisti> syntaxfree: the only application I've seen for it is in the pipes library.
05:05:18 <kallisti> it could probably be rewritten without it.
05:06:32 <kallisti> DMcGill: I don't know if you've seen this but here's an article on a potential application for Free http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
05:07:06 <kallisti> s/syntaxfree/DMcGill/
05:07:12 <DMcGill> kallisti: thanks, I hadn't. As part of typeclassopedia I just wrote a Monad instance for it and was curious
05:07:46 <DMcGill> Functor I mean, I'm doing Applicative and Monad now
05:08:42 <kallisti> monad is pretty straightforward.
05:09:27 <kallisti> I've never tried the Applicative instance.
05:11:14 <nand`> “How dare they! Exceptions are only for exceptional situations and not for ordinary flow control. What a bunch of morons!”
05:11:16 <nand`> heh
05:11:22 <sgronblo> how do you get this "abcdefghijkl" -> ["abc", "def", "ghi", "jkl"]
05:11:40 <kallisti> @hoogle splitEvery
05:11:40 <lambdabot> No results found
05:12:01 <kallisti> http://hackage.haskell.org/packages/archive/split/0.1.2/doc/html/Data-List-Split.html#v:splitEvery
05:12:08 <kallisti> aka the most requested function of all time.
05:12:32 <sgronblo> kallisti: thanks
05:12:37 <kallisti> sgronblo: if you don't want that library as a dependency you could also define it recursively from splitAt from Data.List
05:12:49 <sgronblo> hehe
05:12:49 <sgronblo> im a noob
05:12:50 <sgronblo> ruby is my day job
05:13:05 <kallisti> honestly Data.List.Split should probably be incorporated into base.
05:13:24 <kallisti> every other high-level language has these things as part of its standard lib.
05:13:40 <sgronblo> kallisti: sure but i am trying to learn functionst that are available
05:13:40 <sgronblo> oh wait is this a dependency i need to install?
05:13:48 <quicksilver> kallisti: s/base/the platform/;
05:13:53 <DMcGill> is my type signature "Functor f => Applicative (Free f)" or "Applicative f => Applicative (Free f)"?
05:13:53 <kallisti> yeah it's part of the split package
05:14:01 <kallisti> quicksilver: well, sure.
05:14:01 <quicksilver> the high level goal is to make base smaller, not larger.
05:14:19 <kallisti> I don't see a practical benefit of doing that.
05:14:29 <hpc> i would like to see a larger base
05:14:33 <nand`> DMcGill: I would guess Functor; since that's the point - you can construct a monad (and hence an applicative) from just a functor
05:14:47 <hpc> incorporating parts that everything depends on anyway
05:14:49 <hpc> like mtl
05:14:56 <alpounet> well you always link against base
05:15:52 <quicksilver> kallisti: the practical benefit of making base smaller?
05:16:08 <quicksilver> kallisti: it's because base is tied to a GHC version, which means that fixes and changes can't be made between GHC releases.
05:16:35 <quicksilver> a larger base means more work for the GHC team, less GHC releases getting done, and more code which "can't be fixed" between releases.
05:17:37 <quicksilver> at least that's my understanding.
05:18:14 <kallisti> that's a weird problem to have.
05:18:18 <kallisti> base could easily be seperately maintained.
05:18:51 <fmap> > map (take 3) . takeWhile (not . null) . iterate (drop 3) $ "abcdefghikjl"
05:18:53 <lambdabot>   ["abc","def","ghi","kjl"]
05:20:40 <hpc> kallisti: base also has GHC.* modules
05:20:45 <hpc> i assume that's the tricky part?
05:21:27 <kallisti> I guess. I mean, you could still develop base independently and then link each GHC with a version.
05:21:39 <bitonic> well in theory "base" should just contain the haskell report data types and functions.
05:21:54 <bitonic> or better, the subset that can't be defined in haskell itself
05:22:02 <bitonic> which is still something.
05:22:19 <kallisti> packages everwhere...
05:22:46 <bitonic> howewer, a large `base' has its advantages. you have a much more useful toolbox as soon as you install the compiler
05:22:47 <kallisti> cabal already takes long enough resolving dependencies..
05:23:22 <Saizan> the toolbox is supposed to be the platform
05:23:34 <bitonic> Saizan: that's true as well
05:25:28 * kallisti should petition to include cond in the platform. :D
05:25:37 * hackagebot approx-rand-test 0.0.4 - Approximate randomization test  http://hackage.haskell.org/package/approx-rand-test-0.0.4 (DanielDeKok)
05:25:39 * hackagebot cabal2nix 1.35 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.35 (PeterSimons)
05:31:05 <S11001001> :t Data.Set.map
05:31:06 <lambdabot> forall a b. (Ord a, Ord b) => (a -> b) -> S.Set a -> S.Set b
05:31:15 <S11001001> why the Ord a constraint?
05:31:58 <flux> s11001001, sets are built using binary trees, which are built based on that property
05:32:15 <S11001001> :t \f -> S.fromList . map f . S.toList -- flux
05:32:17 <lambdabot> forall a a1. (Ord a) => (a1 -> a) -> S.Set a1 -> S.Set a
05:32:33 <S11001001> flux: I get the Ord b constraint
05:32:54 <flux> s11001001, but Data.Set.map takes a set, not a list
05:33:07 <S11001001> so does my function I just put there
05:33:09 <sipa> S11001001: if you cannot compare elements, you cannot put them in a set
05:33:11 <flux> hmm, right
05:33:38 <flux> so why does that not have Ord a1?
05:33:41 <S11001001> but that function, which is incidentally exactly how S.map seems to be defined, doesn't have an inferred constraint on the input set element type
05:34:09 <flux> @source Data.Set.map
05:34:09 <S11001001> you don't need ord to walk an already-built tree
05:34:10 <lambdabot> Data.Set.map not available
05:34:16 <S11001001> flux: the source is the function I wrote :)
05:34:20 <sipa> S11001001: good point
05:34:21 <kallisti> flux: it's not strictly required that the input set have an Ord constraint in order to traverse it
05:34:30 <kallisti> however to put the elements back in order you need the constraint.
05:34:34 <kallisti> er yeah what that guy said.
05:34:44 <flux> maybe it's just an over-specified function
05:35:01 <kallisti> if anything it's perfectly specified.
05:35:17 * kallisti isn't sure what over-specified means here.
05:35:51 <flux> kallisti, it's less polymorphic than it could be?
05:36:03 <flux> over-constrained then perhaps
05:36:30 <sipa> over-specified is like defining id as Int -> Int
05:36:35 <kallisti> oh nevermind I misread
05:36:37 <sipa> right
05:36:56 <kallisti> I thought Data.Set.map didn't have the Ord constraint on the input
05:37:47 <kallisti> in fact it has the exact same definition
05:38:03 <kallisti> http://hackage.haskell.org/packages/archive/containers/0.4.1.0/doc/html/src/Data-Set.html#map
05:41:00 * kallisti sent an email to libraries@haskell.org
05:41:04 <kallisti> maybe it will get changed. :D
05:41:08 <S11001001> thanks kallisti
05:41:57 <kallisti> "You are not allowed to post to this mailing list, and your message has
05:41:59 <kallisti> been automatically rejected."
05:42:01 <kallisti> oh neverind. :P
05:43:13 <S11001001> right
05:43:20 * kallisti didn't know that was a thing.
05:43:41 <kallisti> the hackage maintainer email probably shouldn't point to an address that rejects emails by default.
05:44:08 <bitonic> S11001001: of course it needs Ord, what if mapping the element changes the ordering?
05:44:21 <kallisti> then, everything is fine.
05:44:27 <bitonic> e.g. you've got a tree with [1, 2] in it and you do `Set.map negate'
05:44:31 <kallisti> because the output type has an Ord constraint.
05:44:52 <kallisti> so for a -> a functions, the input type didn't have an Ord, so neither does the output.
05:44:56 <bitonic> kallisti: oh, ok then.
05:46:41 <ksf> > let ?x = 1 in let ?x = (?x+1) in ?x
05:46:42 <lambdabot>   2
05:46:46 <ksf> \o/
05:46:56 <sipa> wut?
05:47:11 <ksf> -XImplicitParams
05:47:16 <ksf> ...overriding works.
05:47:53 <kallisti> yep
05:48:27 * ksf is sick and tired of reader monads
05:48:36 <kallisti> ha
05:48:40 <kallisti> yeah me too, sometimes.
05:49:49 <kallisti> ksf: write a package to automatically generate accessor functions for a reader environment
05:50:03 <kallisti> get<x> = <x> <$> ask
05:50:18 <kallisti> where <x> is some record field
05:50:35 <ksf> nah, that's not the problem, the problem is the curse of the propagating do
05:51:23 <kallisti> oh, I typically end up using ReaderT Env IO  or whatever so that's not a big deal.
05:51:48 <quicksilver> implicit parameters are a cure far worse than the disease, ksf, but I suspect you will not believe that until you feel the pain yourself.
05:51:51 <DMcGill> @src gets
05:51:51 <quicksilver> good luck :)
05:51:52 <lambdabot> Source not found. Just what do you think you're doing Dave?
05:51:57 <DMcGill> :t gets
05:51:59 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
05:52:09 <ksf> I won't introduce IO into AST mangling code
05:52:27 <ksf> quicksilver, ddc uses them quite extensively.
05:52:29 <ksf> and it works.
05:52:31 <sgronblo> how do I map read :: Integer to a list of strings?
05:52:40 <kallisti> map reader listOfStrings
05:52:43 <kallisti> *read
05:52:46 <ksf> though benl's code style is highly idiosyncratic in general.
05:53:19 <sgronblo> kallisti: but don't I have to like type it by putting the :: Integer at the end somehow?
05:53:23 <kallisti> sgronblo: I assume you meant read :: String -> Integer
05:53:24 <quicksilver> ksf: many things work.
05:53:26 <kallisti> sgronblo: not if it's inferred
05:53:28 <DMcGill> kallisti: isn't asks what you want? asks f = liftM f ask
05:53:33 <kallisti> > read "2" + read "2"
05:53:34 <lambdabot>   4
05:53:37 <kallisti> DMcGill: yes
05:53:40 <ksf> the only argument against them is "wahg they're dynamic binding" which is a) false and b) besides the point as there's still lexical scope.
05:53:42 <quicksilver> ksf: I can show you quite successful applications written in PHP, even.
05:54:20 <ksf> you could perfectly well emulate them with typeclasses and a phantom type for every redefinition.
05:54:41 <ksf> as such, they're only syntactic sugar.
05:54:50 <kallisti> the main drawback for me is the type signature cruft.
05:55:08 <bitonic> ksf: that is not an argument for using them
05:55:16 <ksf> I don't write type signatures.
05:55:17 <kallisti> but I agree that they're not bad otherwise. They look like an acceptable substitute for reader (though I've never used it as such)
05:55:47 <ksf> and nowadays there's context synonyms, btw.
05:56:12 <mauke> http://hackage.haskell.org/package/reflection
05:56:39 <ksf> that doesn't relieve you from passing a type around.
05:57:34 <ksf> implicit parameters are perfect for "oh, dang, I need some semi-global information". not global enough to be on the top level, but global enough to be in main, usually.
05:57:51 <ksf> you then write two ?'s and a couple other characters and your code works.
05:58:30 <d-snp> hey, anyone know per chance any papers about quantifying code quality? (and perhaps haskell code quality in particular?)
05:58:31 <ksf> ...if not, you delete some type sigs.
05:58:52 <ksf> I bet there's dozens of papers about machine proofing haskell.
05:59:11 <ksf> ...which should be the only quantifiable sort of quality.
05:59:28 <bitonic> d-snp: most studies of that type focus on how much branches/loops the code has. There is a term for that kind of quantification, but I forgot.
05:59:56 <quicksilver> ksf: well, my experience was that hiding parameterisation in this way ultimately proved to obfuscate my code
06:00:09 <quicksilver> ksf: but your experience may differ and so may your opinion ;)
06:00:13 <ksf> use *long* identifiers for implicit params
06:00:27 <quicksilver> (I would also not use typeclasses in the way you sketched, personally)
06:01:05 <ksf> well, I'm accustomed to people being afraid of my code =)
06:01:16 <sgronblo> you can have multiple wheres that refer to earlier wheres right?
06:01:23 <ksf> nope.
06:01:36 <schlicht> i'm using gtk2hs and trying to get the fileChooserDialog associated with a fileChooserButton via get. But i can't realy use it, because the type is unknown
06:01:41 <ksf> that is, if they are nested, yes.
06:01:50 <ksf> but one binding can only have one where.
06:02:34 <sgronblo> like somethingsomething where a = blah\nindentation b = something with a
06:03:27 <ksf> one where is a mutually recursive binding group.
06:03:33 <ksf> just like a let
06:04:35 <quicksilver> so if that's all you meant, sgronblo, the answer is that individual definitions in one where group can refer to both earlier *and later*
06:04:45 <xarch> hello
06:04:46 <quicksilver> as in all other definition groups (lets / modules)
06:04:59 <quicksilver> order in a group is not important but nesting is.
06:05:06 <xarch> isn't HashMap from unordered-containers faster than the regular Data.Map?
06:05:28 <quicksilver> it is intended to be for some/most use cases, yes.
06:05:31 <bitonic> xarch: it depends what you need. For lookups and insert, it generally should
06:05:49 <xarch> yes, I only use lookup and insert
06:05:56 <bitonic> xarch: then it should yes.
06:06:03 <xarch> ok, thanks
06:06:38 <xarch> I have the feeling Data.Map is used more often, when HashMap would be better
06:06:56 <d-snp> ksf: I don't think machine proofing should be the only kind of quality, it's not an end all solution to software problems
06:07:06 <d-snp> bitonic: I think that's the kind of analysis I'm looking for
06:07:17 <bitonic> xarch: I have a feeling that 98% of the times that difference in performance is not an issue.
06:07:39 <bitonic> d-snp: it was something like "cyclic analysis" or "cyclicity" :P
06:07:44 <bitonic> can't remember
06:07:47 <xarch> I'm not sure "I have the feeling" was the expression I was looking for actually
06:07:59 <xarch> maybe "I have the impression"
06:08:08 <xarch> sorry for my English.
06:08:33 <bitonic> xarch: no you might be right, but what I was trying to say is that for most applications it does not matter anyway.
06:08:45 <xarch> ok
06:08:57 <bitonic> and `containers' is more readily available than `unordered-containers'
06:09:34 <ksf> and to top it off, I'm now going to use unsafePerformIO.
06:09:46 <ksf> (to generate unique ids)
06:10:10 <bitonic> ksf: uhu? you're writing a non ref. transparent function, willingly?
06:10:18 <HairyDude> @djinn (a -> b) -> (a -> c) -> (b -> c -> d) -> a -> d
06:10:19 <lambdabot> f a b c d = c (a d) (b d)
06:10:20 <bitonic> (that's what I get from the uids comment)
06:10:45 <ksf> nono it's referentially transparent.
06:10:53 <ksf> it's monotonically increasing.
06:11:03 <ksf> which isn't even important.
06:11:12 <ksf> the only important thing is that it's unique.
06:11:12 <bitonic> ksf: uhm? how does mononotonicity have to do with that?
06:11:15 <bitonic> oh. ok.
06:11:18 <xarch> generating ids is often annoying
06:11:34 <ksf> unsafePerformIO doesn't get inlined.
06:11:50 <bitonic> NO_INLINE
06:11:55 <HairyDude> @hoogle Form a -> Form b -> (a -> b -> c) -> Form c
06:11:56 <lambdabot> Did you mean: Form -> Form -> (a -> b -> c) -> Form
06:11:56 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
06:11:56 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
06:12:05 <ksf> so when you say let id = unsafeUnique in (id, id) you are guaranteed that fst == snd
06:12:13 <bitonic> I always mentally read pragmas shouting.
06:12:54 <xkb> hi
06:13:22 <xkb> Does anyone here know any working example code on using Mongo and a JSON server like Snap/Scotty/WAI/..?
06:13:42 <ksf> hmmm I wonder why there's no Acme.Unique
06:14:32 <xarch> for storing the environment when using De Bruijn indices, should I use a IntMap or a list?
06:15:05 <ksf> I think my brief excursion with disciple has spoiled me a bit.
06:15:28 <ksf> bitonic, that should be implied.
06:15:40 <ksf> for inlinable unsafeperformio there's separate functions.
06:16:19 <ksf> oh, no, that's about threads.
06:17:35 <quicksilver> ksf: well, there is http://www.haskell.org/ghc/docs/7.4.2/html/libraries/base-4.5.1.0/Data-Unique.html
06:22:21 <ksf> meh it doesn't work.
06:22:37 <ksf> that's io, even worse than State
06:23:19 <quicksilver> surely you can unsafeperform it for your purposes?
06:23:29 <ksf> {-# NOINLINE newUnique #-}
06:23:30 <ksf> newUnique :: Integer
06:23:30 <ksf> newUnique = unsafePerformIO $ atomicModifyIORef globalCounter (\x -> (x+1,x))
06:24:35 <d-snp> bitonic: "statement count, cyclomatic number, effort measure, and data flow complexity measures"
06:24:40 <d-snp> cyclomatic number perhaps? :)
06:25:23 <kallisti> cabal: There is no package named 'haskell-platform'.
06:25:25 <kallisti> why not? :(
06:25:30 <quicksilver> ksf: I mean, you've already demonstrated you don't know what referential transparency means, so another unsafePerform around a library function won't make it worse :)
06:25:34 <bitonic> d-snp: yes, that.
06:25:38 <ksf> ...adding a parameter doesn't help. that would've been the disciple way.
06:25:45 <bitonic> d-snp: and the data flow one.
06:26:03 <ksf> quicksilver, it *is* referentially transparent. and that's the problem.
06:26:08 <ksf> it returns constantly 0.
06:26:32 <quicksilver> haha :)
06:27:33 <nand`> http://hackage.haskell.org/packages/archive/free/2.1.1.1/doc/html/Control-Comonad-Cofree.html <- what a sad comonad
06:27:47 <nand`> all of those :< :< :< must get depressing
06:28:05 <int-e> ksf: you must have some odd abstract datatype in mind where all integers are equal.
06:28:15 <xarch> :>
06:28:24 <int-e> may I suggest newUnique = () instead? :-)
06:28:31 <nand`> :> should totally be the constructor for Free
06:28:41 <xarch> well
06:28:48 <xarch> the constructor for free is unary, so…
06:29:19 <nand`> :> (1, :> (2, :> (3, Pure ())))
06:35:09 <teneen> Why do fixity declarations not work correctly in ghci?
06:37:53 <rwbarton> well a fixity declaration is supposed to go alongside a binding, and you can't write those at top-level in ghci either
06:38:05 <rwbarton> but this works: let infixl 3 &; x & y = ...
06:40:55 <JuanDaugherty> what's the most stable ghc ATM?
06:42:19 <hepek> JuanDaugherty: 7.4.2 (?)
06:49:23 <schlicht> how to i get a signal with gtk2hs, where i only now the name from glade?
06:51:28 <xkb> I'm running into some problems with the following code: https://gist.github.com/2995876 line 73 fails, as expected, on the fact that M.Action IO a is not ActionM. I don't really have a clue how I should fix this. I'm aiming to return the JSON of the returned feeding.
06:54:56 <hpd> Hi, is there a package that defines a typeclass that abstracts away common associative array implementations (eg. Data.Map)
06:57:14 <teneen> rwbarto: it is accepted in ghci, but it does not have the desired effect.
06:57:33 <teneen> rwbarton:
06:59:04 <kallisti> hpd: defining a common interface has always been a challenge.
07:02:59 <hpd> ok, i see. Would be nice, if you want to be able to switch implementations later
07:03:58 <eikke> would anyone have some demo code on how to tackle this: writing a server app (using enumerator/pipe/conduit/whatever) which should accept client connections, and handle multiple request/replies on these connections
07:05:11 <applicative> can a noob install a fairly recent Haskell Platform, or anyway ghc+cabal on Ubuntu?
07:05:49 <applicative> or is ghc-6.12 the going version on ubuntu
07:06:46 <linduxed> lets say that i've got one line with "foobar = someReallyExpensiveRecursiveFunctionThatReturnsAPair someArgument"
07:07:19 <linduxed> and the second line says "baz = snd $ foobar"
07:07:49 <fmap> applicative: latest Ubuntu should have 2012.2 haskell platform in repos
07:08:11 <linduxed> assuming that foobar and baz are used on the same line later on (or before a 'where'), will the recursive funciton need to be run two times, or only once
07:08:13 <linduxed> ?
07:08:54 <S11001001> linduxed: depends on what the type of foobar is
07:09:14 <S11001001> usually only once, though
07:09:19 <linduxed> ok
07:09:31 <frerich> linduxed: Assuming that your expensive function is pure, I would say that the result can be reused, since the function will yield the same value for the same input and it has no side effects.
07:09:55 <DexterLB> is there book on category theory you would you recommend
07:09:56 <linduxed> frerich: ok, that sounds good
07:09:57 <DexterLB> =?
07:10:01 <S11001001> frerich: purity is not sufficient in face of typeclass constraints
07:10:24 <linduxed> oh and i probably don't need the $
07:10:31 <applicative> fmap so if he (a pandoc-user)  just does something like apt-get install haskell-platform or whatever he should get it?
07:10:59 <frerich> linduxed: Maybe you don't need the "snd" either, because you can write "(blah, baz) = someReallyExpensiveFunction someArgument"
07:11:27 <linduxed> frerich: good idea, don't know if it will work in this case though
07:11:29 <linduxed> will see
07:11:32 <linduxed> but good tip
07:11:32 <nand`> is there an unicode symbol for the natural transformation arrows (→ with a dot above it)?
07:12:02 <frerich> linduxed: I think 'fst', 'snd' and 'head' are often code smells that there is some pattern matching possible somewhere.
07:12:22 <linduxed> frerich: ...
07:12:35 <linduxed> frerich: let's not talk about code smells in this code that i'm writing
07:13:01 <frerich> linduxed: Ok, let's say it's baby code, and it's fine if babies are smelly every now and then (as long as somebody's around to take care of the diapers).
07:13:21 <hayashi> that's now my favourite code metaphor of all time
07:13:24 <linduxed> frerich: https://gist.github.com/2948280
07:13:24 <DexterLB> lol
07:13:34 <DexterLB> that goes to bash.org
07:14:17 <nand`> frerich: ‘fst’ and ‘snd’ are invaluable tools in writing point-free code
07:14:18 <fmap> applicative: yes, there is haskell-platform package since natty
07:14:41 <fmap> HP version depends on Ubuntu release though
07:14:51 <frerich> nand`: That's true.
07:14:55 <applicative> grrr, I see that haskell-platfrom is not packaged for ubuntu 'Lucid'/10.4
07:15:16 <donri> head is an invaluable tool in writing code that crashes with obscure hard-to-track-down errors at runtime
07:17:09 <applicative> fmap, so it is hopeless to use the usual install methods i guess. he would have to build ghc with ghc6
07:17:33 <applicative> hm, monochrom has some instruction somewhere
07:19:02 <applicative> fmap or can it be that this one line blog-post is right http://speely.wordpress.com/2011/12/30/how-to-install-haskell-platform-in-ubuntu-10-04-lucid-lynx/
07:20:51 <applicative> forget that it would just give you  the accursed ghc6
07:31:04 <amos1> I have a problem with type-class inheritance
07:31:32 <sipa> do we have to guess? ;)
07:31:48 <amos1> I tried to create a class, which has two instances
07:32:02 <amos1> One which is an inheritance,
07:32:20 <mauke> what
07:32:31 <amos1> and the other of a specific data-type which does not implement the first class
07:32:32 <lifeng> hi all, I'm planning to port GHCi to mipsel, is there any guidelines? I searched the web and found nothing helpful
07:32:54 <sipa> amos1: can you paste your code please? (hpaste.org)
07:34:02 <amos1> sipa: doing that
07:35:05 <fmap> applicative: or he could upgrade to next LTS
07:35:27 <applicative> LTS?
07:35:47 <applicative> i see
07:37:35 <hpaste> amos1 pasted “type-class inheritance” at http://hpaste.org/70469
07:37:59 <mauke> amos1: your first instance is for all types
07:38:31 <amos1> I know, of course it asked me for FlexibleInstances and then for Undecidable instances
07:38:57 <amos1> but after I did that, it still wouldn't work, because indeed the first one matches for all types.
07:39:10 <amos1> Now, the intenet said that what I wanted was
07:39:15 <nand`> oh yay, 7.4.2 updated. “Searching for packages installed with a different version of GHC. <screen full of packages>”
07:39:27 <amos1> instance (Num a) => Powerable (N a) where ...
07:39:41 <amos1> with a newtype N.
07:40:26 <amos1> This indeed works, but is ugly, because now the functions that use the class Powerable can't works with numbers,
07:41:09 <amos1> only with N a0 for a number a0,
07:41:54 <amos1> and of course writing a new version for the functions which unwraps N (which is what I'm currently doing for testing)
07:42:39 <amos1> somewhat undermines the purpose of having the type-class (although it still keeps from code copying)
07:42:55 <amos1> is there anything smart to do?
07:45:08 <Cale> amos1: There's no such thing as typeclass inheritance.
07:45:39 <Cale> There are just superclass constraints, which only have the effect of forcing you to write certain instances.
07:46:14 <Cale> Are you sure you actually want a new typeclass in this case?
07:46:51 <Cale> The code you pasted is obviously not compileable, because it has sections cut out of it, so it's hard to be sure of what you're actually trying to do here.
07:48:23 <amos1> Cale: i'll paste the full version
07:48:30 <Cale> amos1: It's worth noting also that constraints on instances are *ignored* for the purposes of instance selection.
07:48:43 <Cale> So if you write   instance (Num a) => Powerable a
07:49:02 <Cale> It's the same, for the purposes of deciding which instance to use, as  instance Powerable a
07:49:17 <Cale> which will always be selected (or overlap)
07:50:15 <quicksilver> I think I can see what amos1 wants
07:50:19 <Cale> The reason for this design is that while the compiler is compiling a module, it can never be certain that an instance of any particular class won't exist.
07:50:32 <quicksilver> he wants his class Powerable to have an instance for Matrix, and on top of that an instance for all Num types.
07:50:45 <Cale> That is, for any given type t, it's impossible to know that there won't be an instance of Num for t in some future module.
07:50:47 <quicksilver> however, that doesn't work for the reasons Cale is explaining.
07:50:57 <hpaste> amos1 pasted “raising matrices by power” at http://hpaste.org/70471
07:51:49 <Cale> In particular, in your case, there might be an instance  Num (Matrix a)
07:51:58 <rwbarton> why not just in fact make an instance Num (Matrix a)
07:52:03 <Cale> indeed
07:52:09 <amos1> I tried that first,
07:52:21 <amos1> but the problem was with implementing fromInteger
07:52:28 <rwbarton> oh
07:52:39 <amos1> I need that for the "1" in quickPow _ 0 = 1
07:52:49 <rwbarton> but then what's the Diag constructor for?
07:52:50 <Cale> fromInteger should send an integer n to n times the identity matrix
07:53:00 <amos1> but fromInteger doesn't know what size matrix I'm working with
07:53:22 <Cale> oh
07:53:35 <amos1> I thought about some black wizardry
07:53:38 <amos1> of a sum type,
07:53:39 <Cale> Yeah, if you don't have a fixed size, then that's a problem :P
07:53:49 <amos1> with a special Diag x,
07:54:05 <amos1> which is a diagonal matrix of arbitrary size, which
07:54:18 <amos1> is converted to a real one when I perform addition or multiplication
07:54:30 <amos1> but I thought this would be easier
07:55:16 <amos1> The ideal solution would be to use numbered types, but I'mnot ready to go down that path
07:55:29 <Cale> I guess you could also just assume that these matrices represent linear operators on an infinite dimensional space which only act nontrivially on some finite-dimensional subspace...
07:55:33 <quicksilver> the other approach, for some operation "Fooable" which  you care about is just to write an instance for Matrix, and then an instance for every number type you actually care about.
07:55:43 <quicksilver> e.g., an instance for Matrix, and one for Double.
07:56:04 <Cale> So to multiply two matrices of different sizes, you extend one of them by 1's on the diagonal and 0's elsewhere
07:56:06 <Cale> heh
07:56:09 <quicksilver> the instance may even be a one-liner if you have a generic Num a => implementation you can plug in of course.
07:56:24 <Cale> though that's again not going to be great for fromInteger
07:57:12 <Cale> Do you actually need this polymorphism?
07:57:14 <amos1> quicksilver: that is probably better than what I already have, but seems... incomplete
07:57:18 <rwbarton> act as a scalar except on some finite-dimensional subspace
07:57:27 <Cale> rwbarton: yeah, good idea
07:57:34 <morel> may i start another parallel discussion?
07:57:35 <hpaste> mekeor pasted “can i write this as a fold?” at http://hpaste.org/70472
07:57:38 <Cale> morel: sure
07:57:42 <morel> mekeor == morel.
07:58:07 <amos1> No, I could work with quicksilver's idea, but it disturbes me that I haven't found something better
07:58:29 <Cale> morel: What is this actually computing, in English?
07:58:53 <morel> Cale: i'm just solving a system of linear equatations…
07:58:57 <morel> just for fun.
07:59:45 <morel> Cale: i suppose i can write this as a fold(r), can i?
07:59:47 <hpaste> savask pasted “Number conversion” at http://hpaste.org/70473
08:00:38 <savask> Hello. I'm making a base 256 to base 94 converter, here it is: http://hpaste.org/70473 How can I make it better and smaller? I feel like I can combine to10 and to94 somehow.
08:01:02 <amos1> rwbarton: what exactly do you mean?
08:01:31 <Cale> morel: Looks like a foldl
08:01:33 <xkb> Any help on: https://gist.github.com/2995876 ?
08:02:04 <frerich> savask: I don't want to spoil the fun, but I believe you could just use the 'digits' and 'unDigits' functions from Data.Digits
08:02:20 <morel> Cale: okay, thanks. i'll try that. thanks :)
08:02:26 <savask> frigga: Ah, yes. The "task" is not to use those easy ways.
08:02:47 <morel> savask: you meant frerich, not frigga.
08:02:54 <savask> Ups
08:02:59 <morel> :)
08:03:02 <savask> frerich, of course.
08:03:03 <Cale> amos1: Is there somewhere in your program where you actually take advantage of the fact that you have a Powerable typeclass in a meaningful way?
08:03:37 <amos1> Cale: only in the implementation of quickPow (and slowPow, which is for testing)
08:03:41 <Cale> okay
08:03:56 <Cale> btw, Powerable is the same thing as Monoid
08:04:23 <Cale> except that getMultId takes a value of type a (which I guess it's meant to ignore)
08:04:36 <Cale> class Monoid a where
08:04:49 <Cale>   mempty :: a
08:04:54 <Cale>   mconcat :: a -> a -> a
08:05:40 <Cale> ah, of course
08:05:58 <amos1> the reason getMultId takes a value is the same reason I couldn't implement fromInteger
08:06:00 <Cale> you're using the parameter to getMultId in your case to determine the size of identity to produce
08:06:02 <Cale> yeah
08:06:53 <Cale> To be perfectly honest, this is an awkward sort of thing to try to be polymorphic about if you can't get a Num instance.
08:07:21 <amos1> how do you mean?
08:08:03 <Cale> Most libraries which have vector and matrix operations which might apply to numbers don't attempt to unify the names of those operations with the ones for numbers.
08:08:48 <ksf> is there a non-bytestring trie somewhere on hackage?
08:08:53 <ksf> like [Integer] or something?
08:09:04 <ksf> I don't really need performance, but semantics.
08:09:20 <bitonic> ksf: there is a ternarytrees package on hackage, by Axman6 iirc
08:09:50 <Cale> For example, it's common to give different names to scalar multiplication, matrix-matrix multiplication, and matrix-vector multiplication.
08:10:25 <ksf> no submap function, there.
08:11:36 <amos1> yes, but specifically I'm trying to improve the implementation of power, which is generic.
08:11:37 <Cale> I can see why you might want this to be polymorphic, but the implementation of (^) in the Prelude does (more or less) what your quickPow does in any case.
08:11:45 <ksf> there's a prefix tree in holumbus
08:11:55 <Botje> isn't IntMap a trie?
08:12:08 <Botje> uh, nope
08:12:09 <Botje> nevermind :)
08:12:13 <ksf> yep but it doesnt' have an [a] interface
08:12:21 <tac-tics> In a typeclass, what does the "type" keyword do? Rather, what extension allows it?
08:12:37 <amos1> I assumed it would, but I won't work for my matrices, unless I implement them as Nums.
08:12:48 <amos1> I also wanted to do this as an exercise
08:12:53 <morel> Cale: works! thanks once more =D
08:13:29 <ksf> ...so solving the algorithm with a data structure won't work, I have to resort to writing a data structure with an algorithm.
08:13:37 <ksf> s/writing/solving
08:13:42 <tac-tics> For example, in MonadRef
08:13:54 <tac-tics> What is the "type Ref" line and what extension does it require?
08:14:28 <quicksilver> tac-tics: associated types / type families
08:14:47 <tac-tics> quicksilver: thanks
08:15:22 <quicksilver> tac-tics: {-# LANGUAGE TypeFamilies #-}
08:15:28 <tac-tics> danke
08:15:32 <amos1> Cale: well, anyway, thanks for the help! I'll think which solution to use.
08:16:56 <Cale> amos1: Another option is just to use good old functional programming
08:17:12 <Cale> amos1: and just take the identity and multiplication as parameters explicitly
08:17:54 <Cale> amos1: Then you don't end up with ambiguity problems :)
08:20:34 <arkw> where is bonus?
08:20:47 <zachk> @seen bonus
08:20:48 <lambdabot> Unknown command, try @list
08:20:51 <zachk> bah
08:20:55 <arkw> wanna say thanks to him
08:20:57 <amos1> Cale: yeah, I still think I'll with some typeclass :)
08:21:01 <morel> preflex: seen bonus
08:21:02 <preflex>  bonus was last seen on #haskell 1 year, 57 days, 19 hours, 53 minutes and 4 seconds ago, saying: yeah i think that's better as well
08:21:08 <arkw> for the terrific book he made
08:21:17 <zachk> arkw: link?
08:21:47 <arkw> zachk: http://learnyouahaskell.com/
08:22:00 <arkw> ppl refer to this book as "LYAH"
08:22:19 <arkw> by the way i am new so you might find this one as pretty basic
08:23:57 <Cale> amos1: tbh, I think I like that one the best, if the point is to implement the algorithms in a flexible and reusable way. A related option would bundle the identity and multiplication into a record.
08:24:38 <zachk> arkw: I still don't grok (understand) all of lyah
08:25:07 <DMcGill> is my only hope of getting the unix package working (and hence filemanip) on my windows box to install a unix (probably ubuntu) partition?
08:25:39 <amos1> Cale: that sounds interesting
08:25:46 <Cale> data Mon a = Mon { identity :: a, multiply :: a -> a -> a }
08:25:55 <zachk> cygwin, mingw, msys DMcGill could work
08:26:28 <amos1> of course I still need the baggage of identity :: a -> a for my matrices, but that's not so bad...
08:26:36 <Cale> You wouldn't actually
08:26:46 <DMcGill> from the haskell wiki: If a package depends (either directly or indirectly) on the unix package, you cannot compile it on Windows
08:26:48 <Cale> You'd just have different values of type Mon (Matrix a)
08:26:58 <Cale> for differently sized matrices
08:27:45 <Cale> ironically, none of which actually gives a monoid on the whole Matrix type :P
08:27:51 <DMcGill> and that page has talked about cygwin/mingw/msys previously
08:27:55 <amos1> So I'll use another function, which takes my matrix, and returns a Mon according to its size?
08:27:59 <Cale> yeah
08:28:09 <Cale> Or which takes a size and produces a Mon
08:28:32 <EvanR> Mon stands for monoid here?
08:28:35 <Cale> yeah
08:28:59 <amos1> btw, what are the advantages of implementing Monoid for this Mon?
08:29:18 <Cale> How would you implement Monoid for this?
08:29:45 <EvanR> you cant
08:29:49 <maloi> Cale: any news on bloodknight? :)
08:29:54 <Cale> (I guess there's sort of a way to do it, but it doesn't make a whole lot of sense)
08:30:15 <EvanR> values of type Mon a arent elements of the monoid
08:30:34 <EvanR> that its representing
08:31:34 <Cale> This Mon is essentially the dictionary type which would be constructed when the Monoid typeclass is compiled.
08:31:55 <amos1> yeah, I thought about it, and that returns us to inheritance
08:31:57 <JuanDaugherty> looks like 7.4.1 was the answer to my earlier query
08:32:12 <Cale> inheritance?
08:32:33 <Cale> (there's no inheritance anywhere)
08:33:57 <amos1> I mean, if I wanted to implement a monoid using this Mod. Nevermind.
08:33:58 <EvanR> oop inheritance in practice is always used for crazy stuff
08:34:06 <EvanR> that is better done another way
08:35:18 <Cale> But by hand-compiling the Monoid typeclass into good old functional programming, what happens is that we can do things which would require dependent types (or at least richer type-level values) if we wanted to do them while keeping typeclasses around.
08:35:32 <Cale> For example, making the Mon value to use depend on a number.
08:35:55 <EvanR> is this how youd do it in ocaml
08:36:03 <EvanR> or ML
08:36:08 <Cale> (that would require type-level numbers if we wanted to stick with the Monoid typeclass)
08:36:22 <Cale> Probably something closer to this...
08:36:36 <Cale> You'd probably use modules actually.
08:37:06 <roconnor> > experiment (:[])
08:37:08 <lambdabot>   Not in scope: `experiment'
08:38:23 <quicksilver> Cale: conversely, classes like 'Functor' smuggled higher rank types into the language in the sense that to implement them as dictionaries you need a nested forall.
08:38:44 <Cale> yeah
08:39:03 <quicksilver> and I wonder if that's part of what made them seem expressive.
08:39:25 <quicksilver> it's interesting that the restrictions on the way they are used means it is an inferrable fragement of higher-rank types.
08:39:43 <quicksilver> (ignoring the ambiguity issues from classes like show/read)
08:39:49 <Cale> It's probably part of why people made a distinction between ordinary typeclasses and constructor classes for a while.
08:40:06 <roconnor> what are constructor classes?
08:40:23 <Cale> Typeclasses whose parameter has a kind other than *, basically.
08:40:34 <morel> is there a common, more general fold which is not defined like "foldl f z (x:xs) = foldl f (f z x) xs" but rather like "foldl f z x@(_:xs) = foldl f (f z x) xs" or so (such that the function f can use the whole remaining list, i mean)?
08:41:22 <roconnor> morel: foldl . tails
08:41:24 <Cale> morel: the composition of foldl with tails
08:41:44 <morel> roconnor: oh, cool. nice idea, great. thanks! :D
08:42:07 <Cale> Also nice in conjunction with map :)
08:42:16 * roconnor patents the idea before Cale does
08:42:17 <morel> Cale: how?
08:42:22 <Cale> map f . tails
08:42:23 <morel> roconnor: hehe
08:42:37 <Cale> is like map, except that the function is allowed to look at the remainder of the list
08:42:53 <morel> Cale: ah
08:42:55 <morel> nice
08:43:19 <morel> (didn't really get it though… oO)
08:43:23 <roconnor> people who liked map f . tails, also liked: comonads
08:43:24 <Cale> hmm?
08:43:29 <morel> :D
08:43:50 <morel> i think i'm lagging…
08:43:54 <EvanR> whats an example of a constructor class
08:43:59 <Cale> EvanR: Functor
08:44:11 <EvanR> o
08:44:18 <EvanR> and Ord is a regular class
08:44:20 <Cale> yaeh
08:44:23 <Cale> yeah*
08:44:29 <morel> @kind Maybe
08:44:30 <lambdabot> * -> *
08:44:43 <morel> @info Maybe
08:44:43 <lambdabot> Maybe
08:44:50 <Cale> heh
08:44:55 <morel> is there something like @instances?
08:45:01 <Cale> @instances Maybe
08:45:03 <lambdabot> Couldn't find class `Maybe'. Try @instances-importing
08:45:05 <EvanR> @instances Functor
08:45:06 <lambdabot> ((,) a), ((->) r), ContT r m, Either a, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
08:45:07 <Cale> @instances Functor
08:45:08 <lambdabot> ((,) a), ((->) r), ContT r m, Either a, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
08:45:09 <Cale> oop
08:45:10 <Cale> heh
08:45:14 <morel> :)
08:45:35 <EvanR> StateT s m is a Functor but
08:45:40 <EvanR> State s ?
08:45:46 <keseldude> > map (\(x:_) -> x+1) . init . tails $ [1..3]
08:45:48 <lambdabot>   [2,3,4]
08:45:56 <Cale> EvanR: Obviously also a Functor
08:45:59 <ciaranm> all monads are functors
08:46:00 <EvanR> ok cool
08:46:26 <EvanR> are there functors in common usage with no monad instance
08:46:42 <ciaranm> yes
08:46:46 <morel> o/
08:46:47 <ciaranm> ZipList comes to mind
08:47:04 <Cale> Though I'm not sure that counts as being in common usage
08:47:11 <roconnor> Const
08:47:30 <morel> why isn't ziplist ∈ Functor?
08:47:31 <roconnor> Store
08:47:36 <Cale> morel: it is
08:47:37 <roconnor> Traced
08:47:42 <Cale> morel: It's not a monad
08:47:46 * roconnor wonders if anyone has ever used Traced
08:47:48 <rwbarton> actually it is
08:47:54 <morel> Cale: ah
08:47:57 <Cale> (but it is an Applicative)
08:48:10 <morel> Cale: ah
08:48:18 <Cale> I guess you could make it an instance of Monad in a way which was incompatible with its Applicative instance.
08:48:33 <roconnor> (a,) ... when a isn't a monoid
08:48:33 <rwbarton> well of course, since it is []
08:48:43 <rwbarton> but in fact you can also make it an instance of Monad in a way which is compatible with Applicative
08:48:46 <morel> Cale: could it be possible to make it an instance of Functor?
08:48:54 <Cale> rwbarton: oh?
08:49:04 <Cale> rwbarton: Not if the lists are finite, surely.
08:49:14 <rwbarton> you just have to be a little smarter about how you form the diagonal
08:49:16 <morel> wtf. anyway. have to go now. bye guys!
08:50:30 <rwbarton> join xss should only return a list of length n if the first n lists of xss all have length at least n
08:51:08 <rwbarton> (as opposed to: join xss returns a list of length n if the ith list of xss has length at least i+1 for 0 <= i < n)
08:51:57 <quicksilver> rwbarton: to satisfy all the laws don't you need to restrict to types of length n?
08:52:07 <quicksilver> where n is either a natural number, or infinity.
08:52:09 <rwbarton> (i.e. the naive diagonal join xss = zipWith (!!) xss [0..])
08:52:14 <rwbarton> nope, try them and see
08:52:18 <quicksilver> interesting.
08:52:40 <rwbarton> associativity is the only potentially problematic one
08:53:00 <quicksilver> so it should return a list of length n where n is the largest such that the first n lists all have length n?
08:53:12 <quicksilver> so join [[1,2,3],[4,5],[6]] = [1,5] ?
08:53:41 <quicksilver> s/length n?/length at least n?/ the
08:53:53 <rwbarton> correct
08:54:28 <rwbarton> but also join [[1],[2,3]] = [1]
08:54:33 * quicksilver nods
08:55:24 <hpaste> xkb pasted “Problems getting values from Action IO a” at http://hpaste.org/70475
08:55:28 <rwbarton> the only possible problem with associativity is that if you do the joins in the two different ways, the resulting lists have different lengths
08:56:14 <quicksilver> xkb: I'm not fmailiar with Mongo but there must be a runMongo or something
08:56:19 <quicksilver> to execute M.Actions
08:56:40 <xkb> quicksilver: I'll go over the docs again
08:57:49 <quicksilver> xkb: the word Action doesn't appear in "http://hackage.haskell.org/packages/archive/mongoDB/0.4/doc/html/Database-MongoDB.html"
08:57:55 <quicksilver> am I looking at the wrong module?
08:58:08 <Cale> rwbarton: Right, so associativity fails, no?
08:58:56 <EvanR> quicksilver: Database.MongoDb.Query has data Action m a
08:59:10 <quicksilver> yeah I was looking at very old docs
08:59:14 <quicksilver> silly google
08:59:20 <quicksilver> xkb: looks like the run method is called "access"
09:00:57 <xkb> quicksilver: this is the one I'm using
09:00:57 <xkb> http://hackage.haskell.org/packages/archive/mongoDB/1.3.0/doc/html/Database-MongoDB-Query.html
09:01:24 <xkb> ah access returns an m (Either..)
09:01:45 <xkb> I'm not really familiar with MonadIO though
09:01:46 * quicksilver nods
09:01:48 <quicksilver> ignore it
09:01:55 <quicksilver> in your case the MonadIO instance is IO
09:02:16 <quicksilver> because, allBreastFeedings :: M.Action IO [Document]
09:02:21 <quicksilver> 'IO' is the monad.
09:02:39 <quicksilver> so the problem you'll have is that your 'amain' doesn't have access to the pipe
09:03:11 <quicksilver> you'll need to thread that through somehow
09:04:37 <rwbarton> Cale, no
09:04:52 <rwbarton> not for the one that requires the first n lists all to have length at least n
09:05:02 <xkb> quicksilver: ah that helps
09:05:06 <xkb> off tinkering again :P
09:05:09 <quicksilver> :)
09:05:14 <rwbarton> if I have xsss :: [[[a]]], let me write it x_{ijk}
09:05:21 <rwbarton> where x_{ijk} :: Maybe a
09:05:21 <quicksilver> OMG!
09:05:27 <quicksilver> proof by einstein notation!
09:05:34 <quicksilver> first time I've seen that as an answer to a haskell question :)
09:06:12 <rwbarton> then for both ways of applying join twice, the result has length >= n iff x_{ijk} exists (non-Nothing) for 0 <= i,j,k < n
09:06:13 <EvanR> lol
09:06:38 <kkyqqp> can I use case/guards in a where clause?
09:06:45 <tac-tics> "I got tired of writing down equations that made any sense, so I started dropping the Σ
09:06:49 <EvanR> yes
09:07:02 <rwbarton> if you try the naive diagonal, you find out that one way, the result has length >= iff x_{ijk} exists for 0 <= i <= j <= k < n, and the other way iff x_{ijk} exists for 0 <= i < n, 0 <= j <= k < n
09:07:08 <rwbarton> so that one fails
09:07:27 <EvanR> whats funny is that all einstein notation formulas begin with a disclaimer 'the following uses einstein notation'
09:07:32 <EvanR> defeating the purpose of standard notation xD
09:08:25 <tac-tics> Honestly, I don't think I would have understood a lot of it, even with explicit sigmas.
09:08:34 <Cale> quicksilver: It's only Einstein notation if you automatically sum over it
09:08:36 <rwbarton> are people talking about me?
09:08:53 <rwbarton> I am not summing anything
09:08:59 <kkyqqp> I'm not sure how to set up the guard/case clause in the where expression then, can anybody point out my error?  http://hpaste.org/70477
09:09:25 <rwbarton> just talking about the elements of a nested list
09:10:51 * hackagebot urldecode 1.0.0.2 - Decode percent-encoded strings.  http://hackage.haskell.org/package/urldecode-1.0.0.2 (BenedictEastaugh)
09:11:16 <quicksilver> you are right of course rwbarton, Cale, it was just an instinctive fear of indices.
09:11:29 <parcs`> > compare Nothing (Just 3)
09:11:31 <lambdabot>   LT
09:12:09 <xplat> so why is nub called nub?
09:12:13 <rwbarton> just trying to save electrons :)
09:12:19 <xplat> shouldn't it be called n00b?
09:12:22 <quicksilver> kkyqqp: in the guard case, you have too little indentation.
09:12:30 <quicksilver> kkyqqp: oh, both cases.
09:12:34 <quicksilver> where foo x =
09:12:47 <quicksilver> ^^^^^^<--- next line must start further in than this
09:13:01 <quicksilver> otherwise you are starting a new definition
09:13:10 <EvanR> > sort [Just 6, Just 1, Nothing, Just 3, Nothing]
09:13:11 <lambdabot>   [Nothing,Nothing,Just 1,Just 3,Just 6]
09:13:26 <Nimatek> > n00b "xplat"
09:13:28 <lambdabot>   True
09:13:34 <kkyqqp> that worked, thanks quicksilver
09:13:43 <xplat> > nub "xplat"
09:13:45 <lambdabot>   "xplat"
09:14:08 <avpx> :t nub
09:14:09 <lambdabot> forall a. (Eq a) => [a] -> [a]
09:14:16 <xplat> > (nub &&& n00b) "Nimatek"
09:14:19 <lambdabot>   ("Nimatek",True)
09:14:35 <bitonic> @src n00b
09:14:35 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
09:14:43 <EvanR> :t n00b
09:14:44 <lambdabot> Not in scope: `n00b'
09:14:52 <xplat> > n00b lambdabot
09:14:53 <lambdabot>   Not in scope: `lambdabot'
09:14:53 <bitonic> @check n00b
09:14:56 <lambdabot>   "OK, passed 500 tests."
09:15:01 <bitonic> suspicious.
09:15:02 <EvanR> wtf is n00b
09:15:04 <armlesshobo> @check sort
09:15:05 <lambdabot>   No instance for (Test.QuickCheck.Testable [a])
09:15:05 <lambdabot>    arising from a use of `Sh...
09:15:05 <tac-tics> > n00b
09:15:06 <lambdabot>   Overlapping instances for GHC.Show.Show
09:15:06 <lambdabot>                              ([GHC....
09:15:11 <bitonic> EvanR: I bet on `const True'
09:15:19 <armlesshobo> n00b
09:15:24 <xplat> nimatek secretly created it and secretly destroyed it
09:15:24 <EvanR> > n00b fix
09:15:25 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
09:15:25 <lambdabot>         against inferred ty...
09:15:28 <armlesshobo> > n00b self
09:15:29 <lambdabot>   Not in scope: `self'
09:15:39 <xplat> > n00b "lambdabot"
09:15:40 <avpx> > let n00b = nub
09:15:41 <lambdabot>   not an expression: `let n00b = nub'
09:15:41 <lambdabot>   True
09:15:44 <EvanR> its String -> Bool
09:15:55 <xplat> yeah, looks like 'const True'
09:16:04 <EvanR> thats  a -> Bool
09:16:08 <EvanR> > n00b 0
09:16:09 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
09:16:10 <lambdabot>    arising from the literal ...
09:16:24 <bitonic> EvanR: fine `const True :: String -> Bool'.
09:16:26 <xplat> my other guess was actually "n00b x = nub x == x"
09:16:29 <Nimatek> How to keep #haskell busy.
09:16:29 <EvanR> haha
09:16:43 <rwbarton> seemingly impossible functional programs to the rescue!
09:17:20 <bitonic> rwbarton: would it work in this case?
09:17:31 <EvanR> class MonadStrange
09:17:36 <rwbarton> well, as long as n00b is total
09:17:53 <rwbarton> > n00b undefined
09:17:55 <lambdabot>   *Exception: Prelude.undefined
09:17:57 <xplat> > n00b $ cycle "hi"
09:17:58 <rwbarton> aha
09:18:00 <lambdabot>   True
09:18:05 <bitonic> rwbarton: it does exhaustive search on all total functions?
09:18:09 <xplat> seems like IFP would work
09:18:45 <rwbarton> have you read the blog post of that name? ("seemingly impossible functional programs")
09:19:04 <kkyqqp> > cycle "look around you! "
09:19:05 <lambdabot>   "look around you! look around you! look around you! look around you! look a...
09:19:16 <rwbarton> http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
09:19:17 <bitonic> rwbarton: yes, but I can't recall the details
09:19:42 <rwbarton> tl/dr: magic
09:20:00 <nand`> > n00b undefined
09:20:02 <lambdabot>   *Exception: Prelude.undefined
09:20:09 <nand`> oh
09:20:11 <rwbarton> > n00b ('a':undefined)
09:20:12 <nand`> rwbarton already did that
09:20:13 <lambdabot>   True
09:20:29 <rwbarton> > n00b ('N':undefined)
09:20:31 <lambdabot>   *Exception: Prelude.undefined
09:20:35 <rwbarton> mhm
09:20:40 <EvanR> haha
09:20:45 <EvanR> the story unfolds
09:20:48 <nand`> heh.
09:21:13 <rwbarton> of course when you can observe an undefined result you can just poke the function like this
09:21:49 <xplat> > filter (not true) . map n00b $ (enumFrom (chr 0))
09:21:51 <lambdabot>   Not in scope: `true'
09:22:00 <xplat> > filter not . map n00b $ (enumFrom (chr 0))
09:22:02 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
09:22:02 <lambdabot>         against inferred ty...
09:22:18 <xplat> > filter not . map (n00b . (:undefined)) $ (enumFrom (chr 0))
09:22:21 <lambdabot>   *Exception: Prelude.undefined
09:22:35 <xplat> > filter not . map (n00b . (:undefined)) $ (enumFrom (chr 256))
09:22:39 <lambdabot>   []
09:22:51 <xplat> > filter not . map (n00b . (:undefined)) $ (enumFromTo (chr 128) (chr 256))
09:22:51 <hpaste> xkb pasted “Almost there.. Action vs IO” at http://hpaste.org/70478
09:22:53 <lambdabot>   []
09:23:14 <xplat> > filter not . map (n00b . (:undefined)) $ (enumFromTo (chr 64) (chr 128))
09:23:17 <lambdabot>   *Exception: Prelude.undefined
09:23:30 <xplat> > filter not . map (n00b . (:undefined)) $ (enumFromTo (chr 0) (chr 64))
09:23:32 <lambdabot>   []
09:23:34 <xkb> I think I'm wrongly nesting do blocks..
09:23:48 <xplat> this would be easier with spoon
09:24:42 <xplat> > filter not . map (n00b . (:undefined)) $ (enumFromTo (chr 64) (chr 95))
09:24:45 <lambdabot>   *Exception: Prelude.undefined
09:24:57 <xplat> > filter not . map (n00b . (:undefined)) $ (enumFromTo (chr 96) (chr 128))
09:24:59 <lambdabot>   []
09:25:24 <xplat> > filter not . map (n00b . (:undefined)) $ (enumFromTo (chr 64) (chr 79))
09:25:27 <lambdabot>   *Exception: Prelude.undefined
09:25:35 <xplat> > filter not . map (n00b . (:undefined)) $ (enumFromTo (chr 80) (chr 95))
09:25:37 <lambdabot>   []
09:25:47 <xplat> > filter not . map (n00b . (:undefined)) $ (enumFromTo (chr 64) (chr 71))
09:25:49 <lambdabot>   []
09:26:07 <xplat> > filter not . map (n00b . (:undefined)) $ (enumFromTo (chr 72) (chr 75))
09:26:10 <lambdabot>   []
09:26:21 <xplat> > filter not . map (n00b . (:undefined)) $ (enumFromTo (chr 76) (chr 77))
09:26:24 <lambdabot>   []
09:26:44 <xplat> > filter not . map (n00b . (:undefined)) $ [chr 78]
09:26:46 <lambdabot>   *Exception: Prelude.undefined
09:26:50 <xplat> > filter not . map (n00b . (:undefined)) $ [chr 79]
09:26:53 <lambdabot>   []
09:27:49 <nand`> xplat: you can do this in a /query with lambdabot too
09:28:04 <xplat> yeah, i guess i've demonstrated the process enough :)
09:29:16 <EvanR> is n00b really an undocumented function in lambdabot to confuse noobs
09:29:36 <sipa> :t n00b
09:29:37 <lambdabot> [Char] -> Bool
09:29:43 <EvanR> i tried that >_<
09:30:07 <EvanR> > n00b ""
09:30:08 <lambdabot>   True
09:30:31 <EvanR> > n00b "pro"
09:30:33 <lambdabot>   True
09:30:44 * sipa thinks  n00b == const True
09:31:00 <xplat> oh, one more demo:
09:31:03 <xplat> > map snd . filter fst . map (n00b . ('N':) . (:undefined) &&& id) $ enumFrom (chr 0)
09:31:04 <lambdabot>   Not in scope: `n00b'
09:31:12 <xplat> WHAT.
09:31:17 <rwbarton> n00b!
09:31:20 <xplat> Nimatek: cheating
09:31:47 <nand`> sipa: it isn't, we've established that
09:32:02 <EvanR> > the (\y -> n00b y == False)
09:32:03 <lambdabot>   Not in scope: `the'Not in scope: `n00b'
09:32:04 <Nimatek> Someone else undefined it :|
09:32:33 <EvanR> lol
09:32:33 <bitonic> we'll never know
09:32:37 <EvanR> just as i was about to solve it
09:33:00 <xplat> i came up with a much fewer-queried way to solve it too ...
09:33:45 <xplat> EvanR: not as few as yours, though :)
09:34:27 <EvanR> very powerful technique use it wisely ;)
09:35:01 <nand`> is there a way to simplify this? \x -> concatMap (sequence . flip replicate x) [0..] -- preferably without @pl's garbage
09:35:08 <EvanR> funny that n00b being undefined was the first problem
09:36:26 <rwbarton> i would probably just use a list comprehension, and replicateM
09:36:35 <nand`> > concatMap (sequence . flip replicate "ABC") [0..] -- to see it in action
09:36:37 <lambdabot>   ["","A","B","C","AA","AB","AC","BA","BB","BC","CA","CB","CC","AAA","AAB","A...
09:37:00 <rwbarton> > concatMap (flip replicateM "ABC") [0..]
09:37:02 <lambdabot>   ["","A","B","C","AA","AB","AC","BA","BB","BC","CA","CB","CC","AAA","AAB","A...
09:38:05 <EvanR> seems like sequence is usually never needed directly
09:38:06 <nand`> :t ([0..] >>=) . flip replicateM
09:38:07 <rwbarton> > [ s | n <- [0..], s <- replicateM n "ABC" ]
09:38:07 <lambdabot> forall a. [a] -> [[a]]
09:38:08 <lambdabot>   ["","A","B","C","AA","AB","AC","BA","BB","BC","CA","CB","CC","AAA","AAB","A...
09:38:10 <EvanR> mapM, replicateM, etc
09:39:52 <nand`> > [1..3] >>= flip replicateM "AB"
09:39:54 <lambdabot>   ["A","B","AA","AB","BA","BB","AAA","AAB","ABA","ABB","BAA","BAB","BBA","BBB"]
09:40:14 <nand`> I'm surprised this isn't some Data.List function
09:40:35 <nand`> “list of all finite strings from alphabet x”
09:41:08 <EvanR> > [0..9]
09:41:09 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
09:41:12 <EvanR> > [0..]
09:41:13 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
09:41:15 <EvanR> > [..]
09:41:16 <lambdabot>   <no location info>: parse error on input `..'
09:41:35 <EvanR> should exist ;)
09:41:41 <nand`> EvanR: what would it be defined as?
09:42:12 <EvanR> ...,-4,-3,-2,-1,0,1,2,3,4,...
09:42:18 <EvanR> ;)
09:42:41 <nand`> let [..] = [..] in ... -- same effect!
09:43:02 <nand`> hmm, technically it would be interesting to have that for Bounded, Enum
09:43:10 <nand`> > [minBound .. maxBound] :: [Int]
09:43:11 <lambdabot>   [-9223372036854775808,-9223372036854775807,-9223372036854775806,-9223372036...
09:43:16 <EvanR> would solve a few remaining problems in computer science!
09:43:30 <nand`> I just don't see it becoming useful very often
09:43:49 <EvanR> solution looking for a problem
09:45:03 <EvanR> @src cycle
09:45:03 <lambdabot> cycle [] = undefined
09:45:03 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
09:45:18 <EvanR> oh cycle isnt total..
09:45:45 <xarch> well
09:46:29 <pcavs> @src ap
09:46:29 <lambdabot> ap = liftM2 id
09:46:36 <pcavs> @src liftM2
09:46:36 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
09:47:19 <xplat> zip`ap`tail $ [0..]
09:47:22 <xplat> > zip`ap`tail $ [0..]
09:47:24 <lambdabot>   [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,1...
09:47:25 <c_wraith> that would be a little easier to understand if it said liftM2 ($)
09:47:55 <c_wraith> But ($) is just a type-specialized version of id, so liftM2 id is identical
09:48:34 <xplat> > zip`ap`filter odd $ [0..]
09:48:35 <lambdabot>   [(0,1),(1,3),(2,5),(3,7),(4,9),(5,11),(6,13),(7,15),(8,17),(9,19),(10,21),(...
09:50:48 <xplat> > zip`ap`(filter (odd.fst) . zip`ap`filter odd) $ [0..]
09:50:50 <lambdabot>   Precedence parsing error
09:50:50 <lambdabot>      cannot mix `L..' [infixr 9] and `Control.Mona...
09:51:02 <xplat> > zip`ap`(filter (odd.fst) . (zip`ap`filter odd)) $ [0..]
09:51:04 <lambdabot>   [(0,(1,3)),(1,(3,7)),(2,(5,11)),(3,(7,15)),(4,(9,19)),(5,(11,23)),(6,(13,27...
09:52:23 <snyp_> Why am I getting this? I am beginning learning Haskell. http://pastebin.com/ksaYiVM2
09:52:25 <mauke> The paste ksaYiVM2 has been copied to http://hpaste.org/70482
09:53:01 <EvanR> snyp_: are you use tabs or spaces?
09:53:05 <EvanR> using
09:53:09 <snyp_> tabs.
09:53:13 <EvanR> use spaces
09:53:15 <snyp_> 3 of them
09:53:31 <nand`> what is line 5 doing there?
09:53:33 <nand`> in your paste
09:53:42 <EvanR> ah
09:53:49 <nand`> “deriving” is only valid after a data or newtype declaration
09:53:52 <snyp_> ok.. using spaces .. wait.
09:53:56 <nand`> and only applies to it
09:54:05 <EvanR> no, nand` caught it
09:54:50 <nand`> “data Foo = Bar deriving Show” <- means a Show instance is automatically created for the type Foo. “myFoo = Bar deriving Show” <- makes no sense, values don't have instances - types do
09:55:00 <nand`> but if you're just starting this may or may not be getting ahead
09:55:07 <snyp_> using spaces doesn't solve the problem.
09:55:31 <snyp_> RWH says use deriving(show) for now and will expl;ain it later.
09:55:37 <EvanR> snyp_: delete line 5
09:56:22 <EvanR> (and use spaces, anyway ;)
09:56:54 <snyp_> oh.. i was adding deriving after a value of Bookinfo. overlooked it. my bad.
09:57:03 <snyp_> mhm. ok
09:57:41 <snyp_> ok working. thx
10:05:29 <jaredc> i have a question about type synonym families
10:06:17 <jaredc> as i understand it so far they are a way to define a type that is different depending on each instance of a class, is that correct?
10:08:10 <jaredc> and that is useful because you are moving the type out of the class declaration and into the instance declaration?
10:08:16 <monochrom> they can do other things. but yes they can do that.
10:09:55 <Cale> jaredc: You can think of the class associated type as a type-level function.
10:10:47 <kwmiebach> Hi. Can you recommend an http server? I don't know which of the projects I found is alive.
10:11:03 <MostAwesomeDude> kwmiebach: Warp.
10:11:14 <srhb`> kwmiebach: Warp is very much alive and _very_ fast
10:11:47 <Cale> There's also the Snap server, which is also alive
10:11:53 <kwmiebach> MostAwesomeDude: srhb` thank you, I will try that one : )
10:12:25 <kwmiebach> and also consider Snap, thank you Cale
10:12:47 <MostAwesomeDude> kwmiebach: It depends on what you want to do.
10:12:53 <MostAwesomeDude> But IIRC both of them support WAI.
10:13:11 <srhb> Huh, Snap supports WAI? I did not know that.
10:13:44 <stepkut> snap does not support WAI
10:14:17 <Cale> There's also happstack
10:14:35 <Cale> I think it's still alive?
10:14:40 <srhb> Very much.
10:14:52 <srhb> They all are, really.
10:14:57 <parcs`> > maximum [] :: Maybe Int
10:14:59 <lambdabot>   *Exception: Prelude.maximum: empty list
10:15:01 <jaredc> cale: and by type level function you mean a function from types to types, right? if so, then i think i understand. i'm going through okasaki's functional data structures and trying to make a class Queue a with instances of the various queues
10:15:01 <parcs`> boo
10:15:08 <Cale> jaredc: yes
10:15:24 <jaredc> thanks
10:15:40 <srhb> > maximumMay []
10:15:41 <lambdabot>   Not in scope: `maximumMay'
10:15:43 <srhb> Aw..
10:15:48 <Cale> jaredc: one where, unlike the type constructors you can define with data declarations, you get to define piecewise according to each instance of your class.
10:16:24 * stepkut notes that he should add some dates on the happstack website
10:16:36 <srhb>  stepkut: Please :-)
10:16:37 <stepkut> or bring back the twitter feed
10:16:40 <stepkut> or both!
10:16:44 <srhb> Both!
10:17:34 <mightybyte> snap-core : snap-server :: wai : warp
10:17:50 <kallisti> has there been any work toward allowing Haskell to compile standalone executables?
10:17:59 <kallisti> standalone as in, no operating system.
10:18:19 <stepkut> srhb: I logged a bug :)
10:18:28 <stepkut> kallisti: yes
10:18:30 <btubbs> kallisti: http://www.haskell.org/pipermail/glasgow-haskell-users/2010-November/019635.html
10:18:36 <EvanR> kallisti: meaning, the code includes its own operating system ;)
10:18:42 <kallisti> correct.
10:19:01 <EvanR> heh, that would make it hard to write an operating system with it
10:19:11 <EvanR> because if it ran, youd already be done!
10:19:12 <stepkut> kallisti: http://www.readwriteweb.com/cloud/2010/11/haskell-virtual-machine.php
10:19:24 * kallisti is interested in using Haskell to design an operating system.
10:19:32 <kallisti> ah it runs on Xen.
10:19:34 <stepkut> kallisti: see House / hOp
10:19:40 <kallisti> that makes sense. you basically no longer have to deal with drivers.
10:19:46 <Cale> The happstack.com website is really pretty except for two things: 1) grey-on-white text is always worse than black-on-white text  2) a splash of colour probably wouldn't hurt :)
10:19:51 <stepkut> kallisti: http://lambda-the-ultimate.org/node/299
10:20:14 <stepkut> kallisti: ancient and unsupported now, but it has been done
10:20:18 <srhb> Cale: But it runs on their own CMS system now, so it's easy for them to change! :o
10:20:19 <EvanR> can i haz hardware to directly run haskell source code ;)
10:20:37 <srhb> s/system//
10:20:39 <jaredc> cale: oooooooh, ok. so just to be sure, Just :: a -> Maybe a. so the input type always the output type. But with type families you get to decide the mapping for yourself on a per instance basis?
10:20:51 <stepkut> Cale: yeah, the theme needs a bunch of improvements.
10:20:54 <jaredc> cale: always determines*
10:21:02 <Cale> jaredc: Just is a value-level function
10:21:10 <Cale> jaredc: it's a data constructor, not a type constructor
10:21:19 <Cale> jaredc: Maybe :: * -> *  is the type level function here :)
10:21:25 <stepkut> Cale: the paragraph width is too wide, and not really grid aligned
10:21:28 <parcs`> > ((<*) . maximum <*> guard . not . null) [] :: Maybe Int
10:21:31 <lambdabot>   *Exception: Prelude.maximum: empty list
10:21:31 <kallisti> I have an hunch that immutability and orthogonal persistence eliminates many of the problems you would encounter with traditional OS design. The trick is making it efficient.
10:21:35 <Cale> jaredc: and it always sends a type t to the type Maybe t
10:21:52 <Cale> jaredc: you can't really define it separately for different specific types t
10:22:03 <EvanR> kallisti: garbage collected OS
10:22:09 <ocharles> :t guard
10:22:09 <kallisti> yep.
10:22:11 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
10:22:28 <kallisti> EvanR: one problem is:  how do you efficiently garbage collect a hard drive or SSD?
10:22:40 <EvanR> same way you gc anything else
10:22:44 <parcs`> > maximum [] <* guard (not (null [])) :: Maybe Int
10:22:46 <lambdabot>   *Exception: Prelude.maximum: empty list
10:22:49 <ocharles> > fmap maximum . (guard . not . null) $ []
10:22:50 <lambdabot>   Couldn't match expected type `[a]' against inferred type `()'
10:22:58 <jaredc> cale: ok! i get it now. thanks again
10:23:14 <kallisti> EvanR: seems like the best approach would be to make slower storage media lower priority for garbage collection.
10:23:21 <EvanR> kallisti: file systems already gc their physical space
10:23:27 <parcs`> oh
10:23:42 <parcs`> > (flip (*>) . maximum <*> guard . not . null) [] :: Maybe Int
10:23:44 <lambdabot>   Nothing
10:24:57 <Cale> stepkut: I'm always surprised how popular grey-on-white and grey-on-grey text is. I think the reason is that people don't actually try to read the text, but are just blurring their eyes and looking at the overall page or something. Lower contrast looks better, but only if you're not trying to read.
10:25:32 <parcs`> > (fmap maximum . (*>) =<< guard . not . null) [] :: Maybe Int
10:25:35 <lambdabot>   *Exception: Prelude.maximum: empty list
10:25:59 <kallisti> Cale: I think there's a happy medium where the text looks nice and is easy to read (and looking nice makes it pleasant to read)
10:26:32 <kallisti> black-on-gray is nice.
10:26:37 <Cale> I think more contrast is always better when it comes to text that is actually meant to be read.
10:26:38 <kallisti> er... gray-on-black
10:27:03 <Cale> Paragraph text should always be maximum contrast. You can do whatever you want with your headers.
10:27:24 <kallisti> orange-on-red headers.
10:27:51 <kallisti> cyan text.
10:28:03 * kallisti best web designer.
10:28:05 <shapr> Sounds so pleasent.
10:28:47 <srhb> OK. With the hope that no one will kill me for bringing up that absurd UTF8 problem from earlier and my horrible understanding of UTF8, chars, bytes, encodings, base64, binary and what have you... how about this: (show . decodeUtf8 . decodeLenient . read)
10:29:10 <srhb> Ah crap, I forgot the gzipping. Nevermind. I'll be back.
10:29:39 <kallisti> srhb: decodeLenient is from base64-bytestring?
10:29:49 <srhb> Yes. (I will change it to decode later)
10:29:49 <kallisti> @hoogle decodeLenient
10:29:49 <lambdabot> No results found
10:29:58 <rtharper> just coming into the convo, why not use Text?
10:30:02 <kallisti> srhb: first problem: read doesn't return a ByteString
10:30:16 <srhb> Actually, it types as it is.
10:30:28 <srhb> So I suppose it does?
10:30:35 <kallisti> not the Prelude one.
10:31:40 <srhb> Who needs unicode in their subtitles anyway -_-
10:31:51 <rtharper> Arabs?
10:31:52 <rtharper> Russians?
10:31:54 <rtharper> Swedes?
10:31:55 <rtharper> Danes?
10:32:01 <rtharper> Germans?
10:32:01 <srhb> Screw them! Especially the Danes!
10:32:02 <srhb> :-)
10:32:12 * shapr censors himself.
10:32:13 <rtharper> Poles?
10:32:16 <rtharper> Slavs?
10:32:29 <srhb> I get it, I get it. It's just frustrating :P
10:32:31 <rtharper> I suppose Slav is a bit unhelpful
10:32:32 <rtharper> heheh
10:32:49 <rtharper> lol you were saying, shapr?
10:33:03 <kwmiebach> I am 'cabal update'ing for the first time - when it takes so lang is it normal?
10:33:09 <rtharper> ye
10:33:11 <rtharper> yep
10:33:15 <shapr> rtharper: Everything I was thinking is off-topic for #haskell
10:33:36 <kallisti> rtharper: I believe he needs to use libraries that treat the data as binary (gzip and base64 decoding)
10:34:00 <kallisti> thus why he's not using text exclusively
10:34:19 <srhb> Yes, I get a string, then I need to base64 decode it, then I need to ungzip it, then I need it to become a String
10:34:45 <kallisti> why does it need to become a String?
10:34:58 <srhb> Um, actually that is less important, as long as I can write it to a file we're good
10:35:04 <srhb> But the problem is up until that point anyway
10:35:15 <kallisti> well if all you need is file IO
10:35:22 <kallisti> there's no need to convert to anything other than ByteString
10:35:27 <kallisti> just write the binary data to file, no problem.
10:35:27 <rtharper> kallisti: aha
10:35:34 <srhb> Yeah, that part is no problem.
10:35:51 <prkc> hi all, any idea how can I transform a string like this: "\226\136\171" to the corresponding utf-8 character? (integral character in my example)
10:35:52 <kallisti> so... what's the problem? :P
10:35:58 <srhb> Everything!
10:35:59 <srhb> :P
10:36:08 <rtharper> Data.Text?
10:36:09 <rtharper> =p
10:36:14 <kallisti> srhb: just use the zlib library and base64-bytestring
10:36:23 <kallisti> and fromString to convert String to ByteString
10:36:23 <Cale> http://hackage.haskell.org/package/base64-bytestring-0.1.2.0
10:36:35 <srhb> fromString, seriously.. That must be the last thing I haven't tried
10:36:38 <srhb> *tries*
10:36:49 <kallisti> srhb: oh, also
10:36:51 <kallisti> you want
10:36:56 <Cale> http://hackage.haskell.org/packages/archive/zlib/0.5.3.3/doc/html/Codec-Compression-GZip.html
10:36:56 <kallisti> Data.ByteString.Char8
10:37:05 <kallisti> which imports the IsString instance
10:37:09 <kallisti> (which is fundamentally broken)
10:37:10 <srhb> Everyone earlier said: Pretend Char8 does not exist <_<
10:37:29 <kallisti> srhb: what are you reading into a String
10:37:42 <srhb> the base64 encoded thingamabobs.
10:37:43 <rtharper> I'm unclear, you want to decode utf-8, but not all the time?
10:37:48 <kallisti> srhb: so, ASCII text
10:37:53 <rtharper> are you treating it as binaries or as characters?
10:37:54 <kallisti> so converting from String to ByteString here is fine.
10:37:59 <srhb> OK, so Char8 was right
10:38:04 <Cale> For ASCII text, Data.ByteString.Char8.pack is fine
10:38:08 <kallisti> rtharper: binary. he needs to use zlib and base64-bytestring
10:38:11 <kallisti> both of which are bytestring libraries
10:38:14 <kallisti> and then file IO
10:38:14 <srhb> she*, and yes ^^
10:38:26 <rtharper> but then, she just asked how to decode a UTF-8 character
10:38:55 * kallisti shrugs.
10:39:16 <kallisti> confusion, perhaps?
10:39:51 <kallisti> srhb: er wait why are you using read to grab base64 data
10:39:54 <srhb> Most likely!
10:40:07 <kallisti> :t read
10:40:08 <lambdabot> forall a. (Read a) => String -> a
10:40:09 <srhb> My last experiment can probabably be ignored. Let me try to get it right again
10:40:11 <kallisti> I'm thinking of this read.
10:40:37 <kallisti> oh... duh, that's why that worked.
10:41:02 <kallisti> srhb: yeah I think you want fromString instead of read.
10:41:06 <kallisti> > read "test" :: ByteString
10:41:08 <lambdabot>   Not in scope: type constructor or class `ByteString'
10:41:13 <geekosaur> prkc, how are you getting that string?  if reading from a file with standard Strings, see http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.5.1.0/System-IO.html#g:23; with ByteString you need decodeUtf8; with Text I think it should handle it automatically.  if generating it some other way, consider that String supports unicode codepoints and manual utf8 encoding is unnecessary
10:41:14 <kallisti> > read "test" :: BS.ByteString
10:41:15 <lambdabot>   "*Exception: Prelude.read: no parse
10:41:17 <kallisti> yeah
10:41:22 <kallisti> > read "\"test\"" :: BS.ByteString
10:41:23 <lambdabot>   "test"
10:41:28 <srhb> OK, so fromString from the.. Lazy ByteString?
10:41:32 <kallisti> no strict
10:41:44 <kallisti> base64-bytestring is for strict bytestrings  (trust me I've been through all of this...)
10:41:53 <kallisti> I actually want to implement a lazy version and patch it in
10:41:54 <kallisti> one day.
10:42:03 <srhb> OK, trying, and thank you I really appreicate this. I've been struggling with this program for so long.
10:42:31 <kallisti> glad I could help. :)
10:42:51 <kwmiebach> How do I get "base"? I wanted to "cabal install warp"  http://pastebin.com/ZtHgXKxR
10:42:52 <srhb> Are you sure that fromString exists though?
10:42:53 <mauke> The paste ZtHgXKxR has been copied to http://hpaste.org/70485
10:43:01 <srhb> Is it not 'pack'?
10:43:04 <kwmiebach> sorry mauke
10:43:16 <kallisti> srhb: fromString is in Data.String, and to use it with ByteString you need to import the Char8 module because that's where the IsString instance lives.
10:43:22 <kallisti> srhb: I think pack would work as well
10:43:31 <kallisti> I don't recall if they're equivalent, but they're very similar anyway.
10:44:01 <kallisti> I want to say there's a subtle difference. let me see.
10:44:07 <jfischoff> how do I pass the extra source directory -i flag to runhaskell?
10:44:34 <srhb> kallisti: OK, fromString works. Next problem: zlib wants a different type ByteString
10:44:39 <kallisti> jfischoff: straightforwardly.  runhaskell -i ...
10:44:40 <srhb> Er, I meant decompress
10:44:59 <kallisti> srhb: oh. yeah. welcome to strict/lazy bytestring hell
10:45:10 <srhb> Yes, thans, I knew _that_ existed. :D
10:45:37 <fragamus> Writing Haskell code is hard but when it's done it's so beautiful
10:45:38 <kallisti> many libraries use lazy bytestrings, actually
10:45:44 <kwmiebach> How can I find out if I have already base library installed and working?
10:45:45 <kallisti> base64-bytestring just happens to use strict.
10:46:15 <kallisti> kwmiebach: since GHC comes with base I would hope that you do. but you can see it with:  cabal info base
10:46:17 <geekosaur> kwmiebach, base library comes with the compiler
10:46:17 <jfischoff> kallisti: thanks the issue was with -package-conf but its was good to know it is supposed to work
10:47:32 <kallisti> srhb: okay so you'll want to import both strict and lazy (I use SBS and LBS as aliases), pass a lazy bytestring to zlib, then convert that to strict for base64-bytestring.
10:47:33 <kwmiebach> ok, good to know
10:47:34 <srhb> kallisti: So... L.fromChunks . return ?
10:47:43 <jfischoff> is there anyway to tell what the path is of the currently executing file, like the __FILE__ parameter in ruby?
10:47:49 <kallisti> srhb: SBS.concat . LBS.toChunks
10:48:12 <srhb> kallisti: What! Isn't that the wrong way? I have Strict, I need Lazy
10:48:23 <kallisti> srhb: oh are you base64 decoding before you compress?
10:48:26 <srhb> Yes
10:48:26 <kallisti> *decompress
10:48:36 <kallisti> oh
10:48:38 <kallisti> then yeah
10:48:38 <geekosaur> jfischoff, http://hackage.haskell.org/package/executable-path
10:48:44 <kallisti> yours is correct.
10:48:48 <srhb> OK, phew, I'm not all lost :-)
10:49:03 <kallisti> srhb: luckily that's also the more efficient route
10:49:12 <srhb> And then I simply need to find a different writeFile and test. Wow!
10:49:23 <kallisti> srhb: LBS.writeFile
10:49:36 <jfischoff> geekosaur: killer thanks!
10:49:57 <geekosaur> note that it is not 100% reliable because ther is no 100% reliable way to get such
10:50:07 <kallisti> srhb: turns out the bytestring authors have already considered the possibility that you might want to do useful things with it.
10:50:07 <srhb> kallisti: My goodness, it types. Thanks so much!
10:50:31 <srhb> Now to test if I have automatic subtitle unicode goodness :-)
10:50:51 <geekosaur> also note that there is no way to get the *source* file, it's not made available (well, maybe some evil TH or CPP)
10:51:59 <kallisti> srhb: feel free to help me patch in a lazy version of encode/decode and friends
10:52:16 <kallisti> I could greatly use it for my own code (which takes the more inefficient lazy -> strict  route)
10:52:40 <srhb> kallisti: Hmm, I'm not sure how much help I can be, you've already seen how inept I am on that topic :-)
10:53:13 <shachaf> srhb: Still at it with the ByteStrings?
10:53:24 <kallisti> srhb: out of curiosity what's the application here?
10:53:29 <srhb> shachaf: I was, kallisti has finally beaten sense into my head
10:53:45 <kallisti> weird, I don't normally do that here.
10:53:48 <shachaf> Uh oh.
10:53:58 <kallisti> shachaf knows that's never a good thing.
10:54:13 <srhb> kallisti: I've written a program that given a movie file hashes it to OpenSubtitles specs, downloads the highest rated sub and launched vlc with that subtitle :-) It has worked flawless so far, except for unicode characters
10:54:36 <srhb> It's a nice wrapper for a process that I usually spend time on to get my daily TV series fix
10:56:16 <kallisti> srhb: cool. if you host it somewhere I might hack on it.
10:56:32 <kallisti> though I'm not sure what that would entail.
10:57:02 <srhb> kallisti: Maybe! Once I clean it up a bit. :-) Also I still get unicode issues, so I'm a bit stumped.
10:58:46 <kallisti> srhb: do you make use of Text at any point?
10:59:12 <srhb> Ah, no, I just figured I should do decodeUtf8 on the ByteString
10:59:37 <kallisti> if the ByteString is carrying Unicode data that it's just passing along, there's no need to do anything explicit.
11:00:12 <srhb> Well, I am now suspecting OpenSubtitles from holding a grudge on me then.
11:02:04 <kallisti> srhb: I wouldn't take it too personally
11:02:15 <hpaste> kwmiebach pasted “compile warp - dependencies” at http://hpaste.org/70486
11:02:34 <kwmiebach> i wonder how to get the dependencies right
11:03:06 <kallisti> srhb: I'm guessing it's not an issue with VLC?
11:03:19 <kallisti> perhaps one program accepts a different encoding from the other?
11:03:54 <kwmiebach> bzw i am not compling warp, but the warp example server
11:03:56 <kwmiebach> btw
11:04:03 <srhb> kallisti: I'm not sure how to debug it really. A different subtitle downloader for Mac gets the same file (I think!) and the utf8 characters are displayed correctly in VLC with that.
11:04:22 <srhb> Though it might actually be downloading the files differently. Hmm.
11:05:31 <kallisti> srhb: assuming you're not doing any grievous re-encoding, it sounds like API/format incompatibillities
11:05:49 <srhb> Yeah.. I'm starting to suspect as much
11:06:05 <srhb> Well.. No.
11:06:13 <srhb> On their side it's gzipped and base64-encoded.
11:06:28 <srhb> *boggles*
11:06:36 <kallisti> right but what encoding is it?
11:06:52 <kallisti> compared to what VLC is expecting?
11:07:54 <kallisti> srhb: btw if you try to convert a String into a ByteString it will completely botch the encoding. so if you're using String for HTTP stuff and then converting to ByteString that would be an issue.
11:08:38 <srhb> kallisti: But wouldn't the decompress function complain massively then?
11:09:10 <mel-> hi
11:09:34 <kallisti> Prelude Data.ByteString.Char8 Data.String> fromString "\11111" :: ByteString
11:09:34 <kallisti> "g"
11:09:36 <kallisti> srhb: no
11:09:41 <srhb> Hmm.
11:10:44 <kallisti> srhb: the most commonly used HTTP libraries that I know of are perfectly capable of working with ByteStrings though. I just thought I would throw that out there as it might be a possible source of misunderstanding.
11:11:03 <srhb> kallisti: Yeah, perhaps. It's an XMLRPC protocol..
11:11:15 <kallisti> but if it's base64 encoded then that's all ASCII anyway
11:11:19 <srhb> It is.
11:12:59 <srhb> Well. I think I'm doing everything right (now) and it must be on OpenSubtitles' end.
11:14:01 <kallisti> it's not beyond likelihood that someone on the internet has managed to mess up Unicode.
11:14:06 <srhb> :-)
11:15:15 <monochrom> use human inspection to determine the encoding
11:15:48 <srhb> monochrom: How so?
11:16:19 <monochrom> confront a human with a hex editor displaying the data
11:16:28 <Cale> OT: this page is much more amusing in Chrome than in Firefox http://www.uoguelph.ca/geography/research/geog4480_w2007/Group10/
11:16:52 <srhb> Cale: Why does the text grow? <_<
11:17:11 <prkc> geekosaur: thanks for the help, i managed to partly solve the problem with decodeUtf8. (I have a bytestring which comes from an IRC logging bot)
11:17:37 <Cale> nested <big> tags
11:17:40 <srhb> Aahh
11:18:19 <prkc> geekosaur: but i noticed that this solution does not work for all input. I got the following error (using decodeUtf8 on the bytestring): "Cannot decode byte '\x64': Data.Text.Encoding.decodeUtf8: Invalid UTF-8 stream"
11:19:37 <SegFaultAX|work2> I don't really understand "lifting". I've read over the haskell wiki on the subject, but I'm still not fully groking it. So, what is lifting and why is it useful?
11:19:49 <Cale> SegFaultAX|work2: In what context?
11:19:55 <Cale> 'lifting' can mean a lot of things
11:19:56 <c_wraith> depends on what you mean.  it has at least 3 different meanings
11:20:16 <SegFaultAX|work2> Cale: Oh really. Hmm, liftA and liftA2 I guess for starters.
11:20:32 <SegFaultAX|work2> Or generally, lifting with respect to applicative functors.
11:20:38 <geekosaur> that (\x64 => 'd') is presumably an interior byte and there's no way to determine what the real problem is without more information/  one problem you may run into is an unfortunate amount of IRC related stuff that tries utf8 and falls back to latin1 if that fails
11:20:41 <c_wraith> > (+) 2 3
11:20:42 <lambdabot>   5
11:20:54 <Cale> liftA is the same thing as fmap
11:20:56 <kwmiebach> I am currently trying to compile my first warp demo. I installed haskell-platform on debian squeeze and then insstalled "warp" and "wai" with cabal. But the example does not compile. Can you give me a hint?
11:20:57 <c_wraith> > liftA2 (+) (Just 2) (Just 3)
11:20:58 <lambdabot>   Just 5
11:21:17 <kwmiebach> THis is what I paste some minutes ago http://hpaste.org/70486
11:21:56 <kwmiebach> "Failed to load interface for `Network.Wai' " - how can I reslove this?
11:22:24 <Cale> kwmiebach: Your GHC is too old.
11:22:31 <SegFaultAX|work2> So here's a terminology question first: in `Just 5 :: Maybe Int` Maybe Int is the type, but is there a name to distinguish the data constructor `Just` from the value `5`? Or is it just that, data constructor and value?
11:22:42 <Cale> kwmiebach: do   ghc-pkg list base
11:22:51 <Cale> kwmiebach: and tell me what version it says
11:23:00 <c_wraith> SegFaultAX|work2: data constructors are just special functions - being functions means they are values, too
11:23:28 <SegFaultAX|work2> c_wraith: So is lifting just separating the "Just part" from the "5 part"?
11:23:30 <kwmiebach> Cale: base-3.0.3.2    base-4.2.0.0
11:23:35 <Cale> kwmiebach: I believe 6.12.x came with base 4.2, yeah
11:23:58 <Cale> Right, so you need at least base-4.3 for conduit-0.4.2 to build
11:24:00 <c_wraith> SegFaultAX|work2: sort of...  But it's best looked at from the perspective of *types*, not values.
11:24:02 <geekosaur> wait, you have two veersions of base installed?
11:24:07 <Cale> and that means you need a newer GHC
11:24:07 <c_wraith> > liftA2 (+) (Just 2) Nothing
11:24:08 <lambdabot>   Nothing
11:24:13 <Cale> yes, that's standard
11:24:19 <SegFaultAX|work2> ?t liftA2
11:24:20 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
11:24:20 <kwmiebach> I think I uninstall all the debian squeeze haskell-platform ? And how to get a recent one?
11:24:25 <geekosaur> hm, yeh, older ghc did that
11:24:26 <Cale> GHC 6.12.x came with two versions of base
11:24:31 <prkc> geekosaur: I can see the logged channel with my IRC client. the problem is with the following message: "Üdv". If I type this to the channel it works. I assume that the original sender of the message doesn't use UTF8 and that causes the error
11:24:46 <Cale> kwmiebach: I generally install the generic linux binary from the GHC website
11:25:01 <c_wraith> SegFaultAX|work2: you can think of liftA2/3/etc as lifting a function into a type context.  it goes from (a -> b) to (Maybe a -> Maybe b), for instance
11:25:08 <geekosaur> prkc, yes, that's why stuff tries utf8 and falls back to latin1; many IRC users use latin1, and the IRC protocol doesn't know character encodings at all
11:25:11 <kwmiebach> Cale, I will do that, thanks a lot
11:25:11 <Cale> and then just install cabal-install by getting the package from hackage and running the bootstrap.sh script inside there
11:25:24 <SegFaultAX|work2> c_wraith: Is that similar to uncurrying?
11:25:36 <c_wraith> SegFaultAX|work2: nothing like it at all.
11:25:39 <MostAwesomeDude> SegFaultAX|work2: Nope.
11:25:40 <kwmiebach> ok
11:25:42 <geekosaur> you may well have try decodeUtf8, catch the exception, and retry
11:25:50 <MostAwesomeDude> SegFaultAX|work2: Do you understand how a *value* could be lifte.
11:25:55 <MostAwesomeDude> *erg, lifted?
11:26:05 <SegFaultAX|work2> MostAwesomeDude: I'm struggling with the entire concept of lifting.
11:26:15 <SegFaultAX|work2> MostAwesomeDude: In all of its applications. :)
11:26:26 <ciaranm> first, learn category theory
11:26:29 <MostAwesomeDude> SegFaultAX|work2: Okay, so first think about lifting a number into Maybe. You end up with Just your number, right?
11:26:37 <SegFaultAX|work2> MostAwesomeDude: Sure.
11:26:38 <c_wraith> SegFaultAX|work2: let's look at the exact example I gave, then.  (+) :: Int -> Int -> Int
11:26:52 <SegFaultAX|work2> c_wraith: Ok, easy enough.
11:26:59 <c_wraith> SegFaultAX|work2: liftA2 (+) :: Maybe Int -> Maybe Int -> Maybe Int
11:27:39 <monochrom> Ü may be 0xdc (iso-latin-1) or 0xc3 0x9c (utf-8) or...  this is why you must use a hex editor. for all other software, what you see is a lie.
11:27:41 <MostAwesomeDude> SegFaultAX|work2: Okay. So when you're lifting a function, the function is wrapped in another function, just like your value was wrapped in a constructor for another value.
11:28:07 <c_wraith> SegFaultAX|work2: it just changes the types of all the arguments (and the result) to be in a context.  Maybe, in this case.  You can see it as lifting the function into the Maybe context.
11:28:16 <MostAwesomeDude> > fmap (-1) (Just 5)
11:28:17 <lambdabot>   Just (-1)
11:28:25 <srhb> monochrom: Does it help if I see the garbage characters I get and _know_ what it should be?
11:28:25 <MostAwesomeDude> Oh, derp.
11:28:31 <MostAwesomeDude> > fmap (+1) (Just 5)
11:28:32 <lambdabot>   Just 6
11:28:48 <monochrom> if you know how software lies, sure
11:29:07 <Cale> (remember that lambdabot has an instance of Num for functions wherein numbers are constant functions)
11:29:20 <Cale> > map 5 [1..10]
11:29:21 <lambdabot>   [5,5,5,5,5,5,5,5,5,5]
11:29:24 <monochrom> but that means you used the equivalent of a hex editor a long time ago when you were learning
11:29:37 <MostAwesomeDude> Cale: Yes, Caleskell always confuses me. :3
11:29:38 <srhb> monochrom: Hehe. Okay, maybe not then :-)
11:30:06 <Cale> That's imported from the vector-space package. I didn't write it.
11:30:08 <shachaf> monochrom: What if I used an oct editor?
11:30:18 <MostAwesomeDude> Cale: Fair enough. :3
11:30:41 <monochrom> oct editor is just as good
11:31:16 <shachaf> monochrom: Actually for understanding UTF-8 a bin editor might be best.
11:31:31 <prkc> geekosaur: it seems that Codec.Text.IConv is what I need for converting latin1 bytestring to utf8 (if decodeUtf8 fails). now it's time to code it :)
11:33:07 <geekosaur> there's also GHC.IO.Encoding but I think it's painful to use directly (it's intended for internal use by GHC's I/O system, hence GHC module prefix)
11:34:39 <SegFaultAX|work2> MostAwesomeDude, c_wraith: Sorry, got pulled away for some SQL stuff. I'm reading through my scrollback now.
11:35:45 <SegFaultAX|work2> c_wraith: Why does liftA2 lift the types into Maybe specifically?
11:35:50 <prkc> geekosaur: ok, thanks for the help again, you saved me from wasting a lot of time with this :)
11:36:08 <c_wraith> SegFaultAX|work2: it needn't be Maybe - it works for any instance of Applicative.  Maybe is just an easy example
11:36:23 <Eduard_Munteanu> :t liftA2
11:36:23 <lambdabot> Eduard_Munteanu: You have 1 new message. '/msg lambdabot @messages' to read it.
11:36:24 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
11:37:03 <fragamus> Why does function composition with the.com reader work from right to left but function composition within the monad with the bind operator works from left to right
11:37:18 <SegFaultAX|work2> Ohhhh, I see!
11:37:24 <fragamus> I'm using speech to text to type here so
11:37:29 <SegFaultAX|work2> So what are the other lift contexts?
11:37:49 <c_wraith> SegFaultAX|work2: it's an open set.  Anything you can make an instance of Applicative
11:38:23 <c_wraith> SegFaultAX|work2: The important part is that the functions in the Applicative class are sufficient to implement the liftA* family of functions
11:39:05 <EvanR> :t liftA2
11:39:06 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
11:39:17 <Eduard_Munteanu> fragamus: bind isn't exactly composition, but you can use (<<<) or (<=<) for monads too
11:39:45 <fragamus> Oh
11:39:52 <SegFaultAX|work2> c_wraith: In your example you said liftA2 (+) :: Maybe Int -> Maybe Int -> Maybe Int, why was it lifted to Maybe there? How do you specify the type to lift the function into?
11:39:53 <Eduard_Munteanu> (>>=) is more like function application. There's a (=<<) too, btw.
11:39:56 <fragamus> I did not know that
11:40:28 <c_wraith> SegFaultAX|work2: Because the types of the argument I was passing were Maybe Int (well, Maybe Integer actually, but whatever)
11:40:38 <c_wraith> :t liftA2 (+)
11:40:39 <lambdabot> forall a (f :: * -> *). (Num a, Applicative f) => f a -> f a -> f a
11:40:42 <EvanR> >>= >>> <<= >== <== <=> >=< >>< <<> *gets confused*
11:40:44 <c_wraith> :t liftA2 (+) (Just 5)
11:40:45 <lambdabot> forall a. (Num a) => Maybe a -> Maybe a
11:41:00 <SegFaultAX|work2> Ah!
11:41:04 <Eduard_Munteanu> :t (<=<)
11:41:04 <c_wraith> SegFaultAX|work2: it's just type inference.  Use the evidence available to narrow down the type
11:41:05 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
11:41:09 <Eduard_Munteanu> :t (<<<)
11:41:10 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
11:41:38 <fragamus>  I'm curious about Como now. I don't know much about them I don't hear them discussed
11:41:44 <timthelion> > show "foo" -- is there something like show, which won't add quotes to the string?
11:41:46 <lambdabot>   "\"foo\""
11:41:46 <Eduard_Munteanu> (<<<) is (.) for arbitrary categories. (<=<) is a specialized (<<<) for Kleisli arrows.
11:41:48 <fragamus> Commands
11:41:52 <fragamus> Ugh
11:41:57 <fragamus> iPhone
11:42:03 <Eduard_Munteanu> Comonads?
11:42:09 <realitygrill> "The function return provides a bridge from the setting of pure expressions without side effects to that of impure actions with side effects." <- why is 'return' the bridge? it looks to me like any IO action would cross this... divide... also
11:42:11 <fragamus> Co-monads
11:42:19 <avpx> timthelion: Err, isn't that what "foo" is?
11:42:40 <SegFaultAX|work2> c_wraith: Are those kind constraints part of the signature or is that just extra fluff from lambdabot?
11:42:50 <timthelion> avpx: well I want to be able to convert arbitrary values in the Show class to a string, but I don't want to change strings at all.
11:43:20 <c_wraith> SegFaultAX|work2: they're something extra lambdabot has turned on.  Still kinda handy to know about, if not see every time.
11:43:38 <SegFaultAX|work2> c_wraith: Can you use kind constraints in actual type class definitions?
11:43:40 <c_wraith> SegFaultAX|work2: It's important that types that are instances of Applicative are *required* to have the kind * -> *
11:43:43 <timthelion> avpx: and I don't understand your point at all :)
11:43:48 <ksf> bloody bitwise and isn't invertible, is it?
11:43:56 <c_wraith> SegFaultAX|work2: it's not as important to see that in every type signature
11:44:13 <avpx> timthelion: I see what you're getting at, at least.
11:44:14 <ksf> not enough information in the result to reconstruct one unknown with that result and another known.
11:44:17 <c_wraith> SegFaultAX|work2: GHC allows it, with an extension (-XKindSignatures, I believe)
11:44:17 <ksf> no matter what direction.
11:44:37 <fragamus> Comonads
11:44:40 <timthelion> Is there an isString function???
11:44:42 <SegFaultAX|work2> c_wraith: But if I wanted to make my type class (Applicative, say) enforce kind * -> *, can I rely on the type system or is it just part of the documentation for my type class?
11:44:44 <Eduard_Munteanu> fragamus: http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html is a nice example if you're starting out
11:45:03 <EvanR> timthelion: maybe youre thinking of Typeable
11:45:08 <c_wraith> SegFaultAX|work2: most of the time, that will be inferred correctly automatically.  You only need an explicit signature when it's ambiguous
11:45:14 <c_wraith> @src Applicative
11:45:14 <lambdabot> class Functor f => Applicative f where
11:45:14 <lambdabot>     pure  :: a -> f a
11:45:15 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
11:45:17 <ocharles> Eduard_Munteanu: thanks, I also trouble to find practical applications of comonads
11:45:20 <fragamus> Yeah I saw that ed
11:45:23 <EvanR> :t typeOf
11:45:25 <lambdabot> forall a. (Typeable a) => a -> TypeRep
11:45:36 <hpaste> semigroup pasted “Brainhurt” at http://hpaste.org/70487
11:45:41 <c_wraith> SegFaultAX|work2: see how the type variable "f" is used in the signatures?
11:45:48 <EvanR> > typeOf "barf"
11:45:49 <lambdabot>   [Char]
11:46:00 <SegFaultAX|work2> c_wraith: Yea
11:46:11 <fragamus> I want to learn the ways of comonads too
11:46:13 <c_wraith> SegFaultAX|work2: the compiler can see from the type of pure that "f" must have the kind * -> *
11:46:14 <timthelion> EvanR: I'm looking it up now...
11:46:26 <EvanR> timthelion: but you almost certainly dont want to use that for whatever youre working on ;)
11:46:33 <semigroup> I'm having a hard time writing a typeclass that I want to work kind of cleverly.
11:46:43 <c_wraith> SegFaultAX|work2: since a is an argument to a function, it must have kind *.  and since f a is the result of a function, it must also have kind *.  Therefore, f must be * -> *
11:47:00 <EvanR> timthelion: your type signatures probably ensure that you are dealing with a string
11:47:04 <fragamus> In the cellular automaton example the Como Nadler used to describe the field in which the consultations are being done I wonder if that is consistently so
11:47:06 <Eduard_Munteanu> ocharles: you might also want to check sigfpe's other stuff, or edwardk's blog
11:47:07 <semigroup> I just posted it from hpaste, could someone help me puzzle out how I can possibly make it work like I want?
11:47:21 <fragamus> Comonad ugh
11:47:22 <SegFaultAX|work2> c_wraith: How could we make those types ambiguous?
11:47:23 <ocharles> Eduard_Munteanu: edwardk's blog goes over my head too often
11:47:27 <ocharles> though i am subscribed
11:47:36 <SegFaultAX|work2> c_wraith: So that we'd need to explicitly have a kind constraint?
11:47:42 <timthelion> EvanR: I'm trying to do the simplest thing in the world :)  I have a list Show a => [a], which I print out on the screen, and when that list is a [String] it looks dumb when everything is in quotes.
11:47:59 <c_wraith> SegFaultAX|work2: something like class Foo f a where bar :: f a
11:48:04 <timthelion> EvanR: if the list is [Int] or something, it's just fine...
11:48:15 <Eduard_Munteanu> fragamus: consultations?
11:48:22 <c_wraith> SegFaultAX|work2: you know that "f a" has kind *, but that doesn't tell you what the exact kinds of f and a are
11:48:34 <fragamus> Comonads dammit
11:48:35 <EvanR> timthelion: Show a => [a] does not do what you think it does
11:48:43 <fragamus> Computation
11:48:58 <c_wraith> SegFaultAX|work2: ghc will make them as simple as possible, though, and assume a :: *
11:49:03 <ocharles> timthelion: you probably need a newtype StringList = StringList [String]
11:49:06 <ocharles> and a show instance on that
11:49:08 <fragamus> I'm driving
11:49:17 <fragamus> I'm using voice recognition
11:49:22 <EvanR> ah nvm
11:49:23 <Eduard_Munteanu> Ah, heh.
11:49:23 <timthelion> ocharles: O_o???
11:49:23 <SegFaultAX|work2> c_wraith: Even if we maybe meant * -> * -> *?
11:49:25 <c_wraith> SegFaultAX|work2: if you want other behavior, you need to use a kind signature to make it explicit
11:49:41 <c_wraith> SegFaultAX|work2: yep
11:49:50 <ocharles> timthelion: Show [a] and Show [String] overlap, I believe, which might be your problem?
11:50:14 <SegFaultAX|work2> c_wraith: So for example Either a b might cause ambiguous instance definitions?
11:50:26 <timthelion> ocharles: but I don't want to take [String] as the argument, I want to take Show a => [a] as my argument!
11:50:52 <timthelion> ocharles: can I just define a new show instance for String?
11:51:04 <fragamus> So do you think that the domain of computation is what Comonads are for
11:51:08 <ocharles> i don't think so, because Prelude defines an instance and you can't hide instances
11:51:13 <ocharles> but i am probably wrong
11:51:19 <EvanR> timthelion: no, you have to use a new type
11:51:22 <c_wraith> SegFaultAX|work2: well, no..  Either is a concrete type with a known kind.  It's when you have a type *variable* whose kind is ambiguous
11:51:39 <EvanR> timthelion: newtype StringTheShowsWithoutQuotes
11:51:44 <ocharles> timthelion: or not use Show
11:51:52 <EvanR> timthelion: you can also define a function which renders the string without quotes
11:51:58 <SegFaultAX|work2> c_wraith: Either is concrete? I thought it was a type constructor with 2 arguments?
11:52:17 <ocharles> EvanR: that would have to be String -> String, or [String] -> String, and timthelion wants to take [a]
11:52:24 <ocharles> so i don't think just that new function is enough
11:52:44 <EvanR> well its always going to show String like that
11:52:47 <c_wraith> SegFaultAX|work2: Either is concrete.  Either a is polymorphic, but limited.  Because Either is concrete, you know what its kind is.
11:52:55 <ocharles> EvanR: not if he uses MyShow a => [a] -> ...
11:53:06 <EvanR> then it wont show anything but string
11:53:09 <timthelion> EvanR: So I have displayMenu :: Show a => [a] -> IO a.. And then inside that I somehow cast to StringThatShowsWithoutQuotes?  Somehow you aren't making sense to me...
11:53:16 <Eduard_Munteanu> fragamus: in many cases comonads are about values in a context
11:53:17 <EvanR> unless he defines a million instances identical to Show
11:53:17 <ocharles> EvanR: anything that has a MyShow instance, yes
11:53:33 <ocharles> well just explaining all timthelion's options
11:53:45 <timthelion> EvanR: I want to be able to have a menu of Ints as well or any Show-able type...
11:54:12 <timthelion> Something this simple can't be impossble to do reasonably can it?
11:54:42 <ocharles> timthelion: another option is data Menu = [MenuItem] and data MenuItem = StringItem String | IntItem Int
11:54:53 <ocharles> and then Show Menu, and Show MenuItem instances
11:55:01 <semigroup> or GADTs
11:55:04 <ocharles> i mean we don't *really* know what you're trying to achieve
11:55:13 <EvanR> exactly
11:55:15 <ocharles> Show is not really designed for human consumption
11:55:20 <EvanR> it doesnt sound very simple at this point what you want to do
11:55:48 <EvanR> timthelion: you sure can test if its a string by also including Typeable constraint
11:55:53 <EvanR> but i mean, really
11:56:21 <EvanR> why dont you just accept a list of strings for your menu
11:56:31 <timthelion> EvanR: I guess I will
11:56:34 <SegFaultAX|work2> c_wraith: Now I'm confused about the definition of concreteness.
11:56:53 <timthelion> and let the library user cast to string as he likes.  I guess that IS the most reasonable...
11:57:01 <timthelion> thankyou for your time
11:57:06 <EvanR> yes, and he wont have to be limited to show instances
11:57:18 <c_wraith> SegFaultAX|work2: Either is a concrete type with kind * -> * -> *.  Either a b is a polymorphic type with kind *
11:57:29 <c_wraith> SegFaultAX|work2: it comes down to whether the expression has any type variables in it
11:57:36 <rupert> hi, it is the first time i am here in this channel and i am a haskell newbie who has some questions about a concrete code snippet
11:57:41 <rupert> how does this work here?
11:57:45 <EvanR> hpaste it
11:57:53 <rupert> i see, i will try
11:57:54 <SegFaultAX|work2> c_wraith: Ohhh, so a value doesn't have to have kind * to be concrete?
11:58:02 <Eduard_Munteanu> @where hpaste
11:58:03 <lambdabot> http://hpaste.org/
11:58:22 <stephenjudkins> rupert: don't ask to ask, just ask. people won't bite too hard :)
11:58:38 <SegFaultAX|work2> c_wraith: Or rather, a type can be concrete without kind *.
11:58:39 <rupert> i see :-)
11:58:39 <Eduard_Munteanu> SegFaultAX|work2: a type
11:58:46 <c_wraith> SegFaultAX|work2: yes, that latter.
11:58:46 <SegFaultAX|work2> Eduard_Munteanu: Yea, that. :)
11:59:05 <Eduard_Munteanu> Secondly, only types of kind * are inhabited.
11:59:18 <Eduard_Munteanu> Maybe that's what you were thinking.
11:59:28 <SegFaultAX|work2> Eduard_Munteanu: Is there such thing as "partially inhabited"?
11:59:29 <hpaste> rupert pasted “foo1 vs non-working foo2” at http://hpaste.org/70488
11:59:41 <SegFaultAX|work2> Like Either Int a?
11:59:48 <Eduard_Munteanu> Um, I don't think so.
11:59:55 <Eduard_Munteanu> Either Int a :: *
12:00:05 <rupert> so why does foo2 work in ghci and foo1 does not?
12:00:17 <Eduard_Munteanu> And that's always inhabited, say Left 0
12:00:23 <SegFaultAX|work2> Eduard_Munteanu: Isn't Either Int a :: * -> *?
12:00:36 <mauke> rupert: because (:) prepends an element to a list
12:00:49 <mauke> rupert: (foo2 xs) is not an element and x is not a list
12:01:19 <rupert> ah, : just prepends but does not append?
12:01:23 <mauke> right
12:01:33 <rupert> so how can i append then to a list?
12:01:49 <EvanR> :t (:)
12:01:50 <lambdabot> forall a. a -> [a] -> [a]
12:01:59 <SegFaultAX|work2> :t (++)
12:02:00 <lambdabot> forall m. (Monoid m) => m -> m -> m
12:02:07 <EvanR> > [1,2,3] ++ [4]
12:02:09 <lambdabot>   [1,2,3,4]
12:02:16 <SegFaultAX|work2> :t (++) []
12:02:17 <lambdabot> forall a. [a] -> [a]
12:02:51 <EvanR> rupert: for efficient append, dont use a list
12:03:48 <SegFaultAX|work2> So what's the benefit of the applicative style? Is it used often?
12:03:57 <EvanR> yeah it is
12:04:18 <rupert> so how could i make foo1 work in principle?
12:04:26 <mauke> with ++
12:04:35 <EvanR> SegFaultAX|work2: it makes certain patterns take up a lot less code
12:04:45 <SegFaultAX|work2> EvanR: Like what? Combinators?
12:04:59 <EvanR> look for examples of libraries that use applicative
12:05:15 <SegFaultAX|work2> EvanR: I don't really know how I'd start searching for that.
12:05:42 <EvanR> @instances Applicative
12:05:43 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
12:06:21 <rupert> i tried to change the recursive call into [x] ++ (foo1 xs) but this does not work
12:06:44 <SegFaultAX|work2> Can lambdabot tell you all the type classes of which a type is an instance of?
12:06:46 <rupert> instead of x : (foo1 xs)
12:07:10 <SegFaultAX|work2> Like if I wanted to know all the type classes Int is an instance of (including derived classes)
12:07:13 <EvanR> SegFaultAX|work2: its listed in the documentation for that type
12:07:25 <EvanR> well not Int
12:08:12 <EvanR> @instances-importing Int
12:08:13 <lambdabot> Couldn't find class `Int'. Try @instances-importing
12:08:45 <EvanR> SegFaultAX|work2: you mean standard classes? new instances pop up all the time in each module
12:09:41 <EvanR> SegFaultAX|work2: http://www.haskell.org/onlinereport/classes.gif
12:10:05 <rupert> ok, it does work, sorry
12:10:07 <rupert> thx for help
12:10:46 <Eduard_Munteanu> SegFaultAX|work2: no, Either Int :: * -> *
12:10:58 <Eduard_Munteanu> But Either Int a :: *
12:11:15 <rupert> another question, is there a way to append to a list in constant time, i.e. O(1)?
12:11:28 <Eduard_Munteanu> rupert: no, not at the other end.
12:11:32 <EvanR> rupert: no
12:11:34 <kwmiebach> I am compiling new ghc from source with the old ghc from the debian packages? So It is better to remove the debian packages after the make and before the sudo make install?
12:11:42 <rupert> only at the beginning with (:)?
12:11:56 <Eduard_Munteanu> rupert: Seqs are better at that, you log-ish time appending to either end
12:12:18 <rupert> i see
12:12:26 <EvanR> Eduard_Munteanu: actually its O(1) at both ends
12:12:37 <EvanR> log in the middle
12:12:39 <Eduard_Munteanu> Hm, really?
12:12:41 <Eduard_Munteanu> Ah.
12:12:58 <Eduard_Munteanu> Indeed.
12:13:05 <EvanR> rupert: so use Data.Sequence if you need to insert on both ends
12:13:12 <rupert> thanks
12:14:34 <hpaste> hanDerPeder pasted “Loops” at http://hpaste.org/70489
12:14:45 <EvanR> actually i dont see any insert in the middle function..
12:14:53 <hanDerPeder> whats an efficient way to translate that c program into haskell?
12:16:08 <Eduard_Munteanu> hanDerPeder: the outer loop seems useless
12:16:45 <hanDerPeder> Eduard_Munteanu: yes, well it's pretty much a toy example
12:16:46 <Eduard_Munteanu> The inner loop is just a zipWith (*)
12:17:14 <hanDerPeder> gcc is able to optimise the loop away, which I find kinda neat
12:17:54 <Eduard_Munteanu> Yeah, that's a pretty straightforward loop transformation / strength reduction.
12:18:04 <EvanR> log n indexing
12:18:19 * illissius wonders how it is that Data.Vector.Mutable.length :: MVector s a -> Int is not monadic, and yet functions like 'grow' are available which change its size.
12:18:27 <illissius> doesn't that break referential transparency?
12:18:45 <semigroup> Not really
12:19:44 <semigroup> grow is monadic
12:19:47 <semigroup> length isn't
12:20:08 <semigroup> length is just a field in the record afaik
12:20:12 <illissius> semigroup: yeah, and so the result of length depends on whether it is evaluated before or after grow is executed. no?
12:20:20 <hanDerPeder> Eduard_Munteanu: I made a version using zipWith for the inner loop, but I'm not sure how to add the outer loop
12:20:45 <illissius> oh, hmm.
12:20:55 <illissius> yeah, you're right
12:21:16 <semigroup> illissius, grow makes a copy of the vector internally I think, so you're actually looking at different vectors at that point
12:21:16 <Eduard_Munteanu> hanDerPeder: a map might do
12:21:20 <illissius> grow presumably returns a new MVector with a different size field, pointing to the same array, which is what has actually chanegd
12:21:27 <fragamus> Can anyone tell me about the garbage collector
12:21:27 <kallisti> srhb: any progress?
12:21:31 <illissius> or something like that
12:21:43 <fragamus> Is it any good
12:21:49 <Eduard_Munteanu> grow returns a different vector anyway
12:22:00 <illissius> ok then, my concerns are assuaged. :)
12:22:08 <Eduard_Munteanu> Just like map returns a different list.
12:22:10 <xarch> what would you recommend for command-line options parsing?
12:22:25 <hpaste> nand` pasted “Lambda calculus with trivial types” at http://hpaste.org/70490
12:22:27 <Eduard_Munteanu> @hoogle getopt
12:22:27 <lambdabot> System.Console.GetOpt getOpt :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])
12:22:27 <lambdabot> System.Console.GetOpt getOpt' :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String])
12:22:27 <lambdabot> System.Console.GetOpt module System.Console.GetOpt
12:22:29 <srhb> kallisti: I think it's an error on their part. Nothing I can do. :-)
12:22:43 <Eduard_Munteanu> xarch: getopt? ^^
12:22:48 <xarch> hm
12:22:52 <kallisti> fragamus: it's fine-tuned for immutable structures. it's a generational copy collector.
12:22:54 <srhb> kallisti: So the program actually works quite well right now, even if there's no error handling. Then again, if something does go wrong there's really not much to do but to crash out.
12:22:55 <xarch> ok!
12:23:07 <kallisti> fragamus: I believe for the oldest generations it switched to a mark-and-sweep collector
12:23:12 <illissius> Eduard_Munteanu: that's not so obvious, these are *mutable* vectors, but I'll take your word that it's true in this case.
12:23:13 <xarch> I was wondering whether there was any more idiomatic library but well
12:23:25 <nand`> In general, how would one go about adding rank-1 polymorphism to a type checker like the one I hpasted?
12:23:25 <kallisti> srhb: wasn't there another program for Mac that worked?
12:23:33 <kallisti> did it not talk to the OpenSubtitles site?
12:23:36 <Eduard_Munteanu> illissius: the data itself is a mutable structure, but the length is just a field in a datatype
12:23:47 <srhb> kallisti: No, I just tested it, and it actually has the same encoding errors on that same subtitle file, so yay! :P
12:23:52 <Eduard_Munteanu> data MVector s a = MVector !Int !Int !(MutableArray s a)
12:24:19 <fragamus> What you mean oldest generation
12:24:26 <ksf> fragamus, usually, the majority of objects that are created get collected just a moment after. ghc's GC excels at that.
12:24:59 <illissius> Eduard_Munteanu: right! that's uncontroversial. I thought you were saying it copied the array itself (which is actually what semigroup was saying). my bad.
12:25:44 <rupert> how can i pattern match against the first element, the last element, and all elements between?  is it (x:xs:y)?
12:25:46 <kallisti> fragamus: http://hackage.haskell.org/trac/ghc/wiki/GarbageCollectorNotes
12:25:54 <rupert> in a list of course
12:25:59 <Eduard_Munteanu> rupert: you can't
12:26:18 <illissius> (which it may or may not do, but it's not immediately obvious without looking at the source, and on top of that doesn't matter.)
12:26:23 <fragamus> I read in some guys blog edit the garbage collector was not good but I want to think that he wasn't using Haskell properly
12:26:24 <Eduard_Munteanu> rupert: pattern-matching merely follows the datatype's structure
12:26:34 <rupert> i see
12:26:39 <kallisti> fragamus: considering the amount of junk that a typical Haskell program produces, it's quite good.
12:26:41 <Eduard_Munteanu> rupert: for lists, it's a head consed to another list, or an empty list
12:27:09 <rupert> so no explicit tail in the data structure and therefore not possible, right?
12:27:26 <EvanR> fragamus: theres a preponderance of blog content not necessarily favorable to haskell
12:27:32 <EvanR> but thats the blagosphere for you
12:27:34 <Eduard_Munteanu> rupert: it isn't possible to pattern-match, but you can get to the last element of a non-empty list
12:28:13 <Eduard_Munteanu> e.g. head . reverse
12:28:20 <rupert> or last?
12:28:21 <EvanR> > last [1,2,3,4]
12:28:22 <lambdabot>   4
12:28:26 <Eduard_Munteanu> Yup.
12:28:27 <kallisti> fragamus: you can utilize immutability to efficiently do generational copying. you fill up a nursery the size of a page, and when it's time to garbage collect, you yoink all the referenced data and clear the page. it's impossible for older generations to refer to new generations.
12:28:30 <EvanR> @src last
12:28:30 <lambdabot> last [x]    = x
12:28:30 <lambdabot> last (_:xs) = last xs
12:28:31 <lambdabot> last []     = undefined
12:28:39 <EvanR> walking the list
12:28:51 <rupert> i see
12:29:01 <Eduard_Munteanu> (mind [x] is just sugar for x:[])
12:29:53 <Eduard_Munteanu> rupert: you can't do that for Seq's either, FWIW, though view-patterns let you write something in a style similar to pattern-matching
12:29:58 <kallisti> fragamus: because the vast majority of values are temporary, you only end up copying a small amount of data, and quickly flushing the rest all at once.
12:31:07 <Eduard_Munteanu> However, that's just pre-applying a function to an argument and letting you pattern match on the result.
12:31:22 <Eduard_Munteanu> So you can e.g. apply reverse to the list and check its head.
12:32:17 <nand`> rupert: If you use a Data.Sequence you can inspect the left and right ends: case (viewl xs, viewr xs) of (left :< _, _ :> right) -> ...
12:32:32 <rupert> thanks
12:32:43 <nand`> not sure how you would match the middle though
12:32:58 <EvanR> youd need to search probably
12:33:20 <kallisti> fragamus: I'm curious what complaints were levied against the GHC GC. There may be some valid points.
12:33:43 <Eduard_Munteanu> You could write your own view into a list / seq, e.g. data HeadMiddleEnd a = HME a [a] a; toHME :: [a] -> HeadMiddleEnd a
12:33:45 <timthelion> Is there any reason why lines cannot start with # in literate haskell?
12:34:06 <Eduard_Munteanu> (nevermind it being partial for now)
12:34:17 <nand`> case (Seq.viewl xs, Seq.viewr xs) of (left :< _, init :> right) -> -- Seq.drop 1 init is now the middle
12:34:46 <Eduard_Munteanu> Then you can write stuff like    foo (toHME -> HME h xs e) = ...
12:34:52 <Eduard_Munteanu> (with view patterns)
12:36:29 <roconnor> Are view patterns that direction?
12:36:37 <roconnor> I thought they were <-
12:36:44 <tommd> nope
12:36:48 <roconnor> dang
12:38:22 <mauke> > let vmap _ [] = []; vmap f ((f -> y) : (vmap f -> ys)) = y : ys in vmap show [1 .. 3]
12:38:23 <lambdabot>   ["1","2","3"]
12:40:09 <EvanR> > map show [1..3]
12:40:10 <lambdabot>   ["1","2","3"]
12:46:16 <EvanR> mauke: whats vmap?
12:46:39 <EvanR> map defined with view patterns?
12:46:43 <mauke> yes
12:48:19 <codolio> > let vipWith f ((f -> g) : (vipWith f -> h)) ((g -> y) : (h -> ys)) = y : ys ; vipWith _ _ _ = [] in vipWith (+) [1,2,3] [4,5,6]
12:48:20 <lambdabot>   [5,7,9]
12:48:52 <mauke> haha
12:49:04 <EvanR> vip it
12:49:08 <EvanR> vip it good
12:51:31 <EvanR> does ghc share the one necessary instance of the value (), [], empty sequence, empty set, data.map, etc?
12:51:49 <codolio> Yes.
12:57:00 <dmwit> In fact, it even shares [] across different types (and similarly for the others).
12:57:10 <EvanR> yeah
12:58:22 <rupert> how can i import Data.List so that ghci knows the sortBy function?
12:58:36 <dmwit> "import Data.List"
12:58:53 <dmwit> If you are using a very old GHC, then ":m + Data.List" instead.
12:59:33 <rupert> thx, i tried to use load instead of import, import is obvious
12:59:36 <semigroup> The old way still works though
12:59:58 <dmwit> EvanR: For a beautiful picture, try cabal-installing vacuum-cairo, importing System.Vacuum.Cairo in ghci, and running
13:00:03 <dmwit> view ("a",[1])
13:00:38 <dmwit> The result really is quite nice.
13:00:58 <kallisti> rupert: for my Haskell projects I'll often set up a .ghci file in the working directory, which ghci will automatically run
13:01:09 <kallisti> setting up common imports and language extensions (OverloadedStrings in particular)
13:02:16 <rupert> ah, this sounds interesting
13:03:50 <EvanR> vacuum cairo...
13:04:13 <EvanR> wow
13:08:50 <EvanR> heh so all lists in the haskell environment end at the same place ;0
13:09:08 <EvanR> if they end
13:10:16 <markus3> B
13:10:31 <tac-tics> EvanR: In *ghc* haskell maybe
13:10:43 <tac-tics> You are forgetting about the other great compilers no one uses :P
13:11:15 <kallisti> EvanR: imagine if some malicious code got access to that pointer and decided to put a nasty thunk there.
13:11:24 * illissius wonders whether it's considered a bug for GHC to say things like "match_co baling out"
13:12:12 <tac-tics> kallisti: like if evaluating nil launched missiles?
13:12:34 <EvanR> yes
13:12:36 <EvanR> in ghc
13:12:50 <EvanR> :t nil
13:12:51 <lambdabot> Not in scope: `nil'
13:21:27 <timthelion> System.Posix.Process.executeFile kills the haskell thread it's launched from?(that is the behavior that I'm observing...) So how do I launch a program(in this case ln) and wait till it's done before continuing?
13:21:47 <srhb> waitForProcess
13:21:49 <kallisti> one of the functions in System.Process is a good start.
13:21:58 <kallisti> there are many variations
13:22:15 <c_wraith> timthelion: it's a wrapper around POSIX exec.  exec *replaces* the current process with the new one.
13:23:04 <timthelion> c_wraith: I seem to understand that.  I only used it, since I found it in the xmonad sources...
13:23:26 <EvanR> maybe you want to write a shell script instead ;)
13:24:27 <timthelion> EvanR: Um no, I'm writting in Haskell, to see if I cannot write a utility in Haskell.
13:24:45 * timthelion hates the idea that everything should be thrown together from half assed shell scripts...
13:25:49 <stepcut> haskell is awesome for shell scripting
13:26:04 <stepcut> 3 line shell scripts have a horrible tendency to become 1000 line monsters
13:28:06 <srhb> I saw the deep innards of a rather large telecoms company once
13:28:13 <srhb> *shiver*
13:28:21 <timthelion> srhb: :D :D
13:28:48 <timthelion> reminds me of http://xkcd.com/224/
13:28:50 <srhb> It was a many many kloc savage beast of perl, awk and sh sown together to vaguely resemble something living.
13:29:23 <srhb> And yes :P
13:30:32 <EvanR> timthelion: use the right tool for the job, combine right tools when its easy and theres more than one right tool ;)
13:31:16 <timthelion> EvanR: you realise, that your name is an anagram for my responce to that statement, right?
13:31:36 <EvanR> no, i dont
13:31:45 <timthelion> nEvar :D :D :D
13:31:47 <srhb> Raven!!
13:31:49 <srhb> I mean.. NEVAR!
13:32:30 <timthelion> :D
13:33:44 <shachaf> srhb: I thought telecoms all used Erlang!
13:34:14 <stepcut> shachaf: :)
13:36:24 <edwardk> shachaf: not so many
13:36:55 <shachaf> edwardk: Next you'll tell me it's only Ericsson. :-(
13:37:09 <jfischoff> anyone have a strong opinion on what command line arg parsing library I should use?
13:37:13 <edwardk> =P
13:37:24 <edwardk> jfischoff: the optparse-applicative stuff looked neat
13:37:35 <EvanR> rawr strong opinions
13:37:42 <edwardk> jfischoff: i used to kind of like cmdargs, but the inability to extend it was rough
13:37:52 <shachaf> FFI bindings to getopt!
13:38:31 <jfischoff> edwardk: in what way is it difficult to extend? I know pretty much nothing about it.
13:38:58 <edwardk> i wanted to customize the way it displayed the options to the end user (i had a bunch of localization support elsewhere in my app)
13:39:17 <edwardk> and i wanted to get access to what the options were so i could do bash shell completion
13:39:25 <edwardk> neither one were really possible without rewriting it
13:39:30 <EvanR> getArgs
13:39:44 <shachaf> Doesn't bash completion have a magical mode where it parses --help to extract the options?
13:40:00 <EvanR> getOpt
13:40:23 <startling> I keep running into situations where I want to map all of a given type to other things in opaque, composable, comparable ways. I keep making sure the type derives Ix and using arrays, but that just seems clumsy since i need to repeatedly specify that it maps *all* of the type. Any ideas?
13:40:24 <edwardk> shachaf: no, but you can make custom shell scripts to do the completion, and then have them invoke your program with an option to get the completions back, which is what i wound up doing
13:40:59 <startling> And it seems silly to mess with the tables/maps/whatever since that means dealing with a superfluous Maybe
13:41:01 <jfischoff> edwardk: cool I'll look at the two and see which one is a better fit
13:41:47 <edwardk> jfischoff cmdargs is the least code of any option parsing lib, but its an imperative mess of horrible meaning-providing bottoms
13:42:07 <jfischoff> ugh
13:42:11 <edwardk> optparse-applicative is more code to use, but easier to understand what you're doing
13:42:16 <EvanR> startling: fromJust
13:42:23 <startling> EvanR: :/
13:42:30 <EvanR> you said its never Nothing
13:42:39 <startling> yeah.
13:43:09 <edwardk> if you know it maps all the type, just pass a function, not a map, etc. ;)
13:43:10 <startling> meh, I guess that works, it's just surprising that there's nothing built-in like this
13:43:33 <startling> edwardk: yeah, but I can't check functions for equality
13:43:51 <edwardk> sure you can, just iterate over the domain
13:43:52 <startling> I guess I could write a wrapper that derives Eq and checks all the possibilities
13:43:55 <startling> yeah
13:43:57 <startling> hmm
13:44:13 <pooya72> in ghci as the prompt > keeps getting bigger as you import modules, how do you clear it?
13:44:14 <roconnor> and do that crazy thing if your domain is compact but not finite.
13:44:14 <EvanR> or use a combinator that crashes the program if theres Nothing
13:44:22 <nobdraisentone> Data.Array.MArray.mapArray > Constructs a new array derived from the original array by applying a function to each of the elements.
13:44:25 <nobdraisentone> What is a point of that function if it produced new copy of old array? I thought it should be kinda superposition of writeArray and readArray, neh?
13:44:26 <edwardk> or that =)
13:44:51 <startling> nobdraisentone, the point is that it creates a new array
13:45:02 <edwardk> clearly you should use my contravariant j implementation ;)
13:45:12 <EvanR> DiffArray!
13:45:15 <edwardk> http://hpaste.org/69758
13:45:21 <startling> nobdraisentone: map creates a new list, yeah?
13:45:25 <edwardk> because that is the most obvious way to search a space
13:45:32 <nobdraisentone> startling: > MArray
13:45:39 * roconnor doesn't click on edward's link
13:45:52 <edwardk> roconnor: =P
13:46:08 * hackagebot JuicyPixels 1.3 - Picture loading/serialization (in png, jpeg and bitmap)  http://hackage.haskell.org/package/JuicyPixels-1.3 (VincentBerthoux)
13:46:20 <edwardk> roconnor: basically the monad for J generalizes to any contravariant functor
13:46:47 <jfischoff> pooya72: :set prompt >
13:47:15 <pooya72> jfischoff: you're a gentleman and a scholar
13:48:09 <startling> nobdraisentone: kay?
13:48:11 <hiptobecubic> Is there a working tool to paste to hpaste?
13:48:20 <roconnor> (-->) :: Bool -> Bool -> Bool
13:48:25 <roconnor> why not (<=)
13:48:38 <startling> nobdraisentone: you're asking "why isn't this function exactly what I want?". the solution is "write your own function that does exactly what you want"
13:48:40 <EvanR> > True < False
13:48:41 <lambdabot>   False
13:48:54 <roconnor> EvanR: <=
13:49:05 <EvanR> > True <= False
13:49:06 <lambdabot>   False
13:49:18 <EvanR> > True <= True
13:49:19 <lambdabot>   True
13:49:35 <EvanR> esoteric! ;)
13:49:49 <roconnor> my favourite kind of teric
13:50:17 <S11001001> > succ False -- bottomful not
13:50:18 <lambdabot>   True
13:50:22 <S11001001> more general
13:50:42 <EvanR> > succ True
13:50:43 <lambdabot>   *Exception: Prelude.Enum.Bool.succ: bad argument
13:50:46 <EvanR> waw
13:51:01 <tac-tics> > [False..]
13:51:03 <lambdabot>   <no location info>: parse error on input `]'
13:51:09 <nobdraisentone> startling: I'm just curious what for is there a function that not modified an array in mutable arrays module
13:51:34 <S11001001> must use prec for True, so to implement not look at boolean, use succ if false, prec if true
13:51:37 <illissius> @check \a b -> (a <= b) == (not a || b)
13:51:38 <lambdabot>   "OK, passed 500 tests."
13:51:47 <EvanR> nobdraisentone: you want there to be no function to map a mutable array?
13:51:51 <roconnor> @scheck \a b -> (a <= b) == (not a || b)
13:51:52 <lambdabot>   "OK, passed 500 tests."
13:51:55 <roconnor> :/
13:52:02 <startling> nobdraisentone, hmmm, is MArray a functor? fmap might do it
13:52:37 <tac-tics> > False < True
13:52:38 <lambdabot>   True
13:52:42 <tac-tics> Noooo
13:52:46 <tac-tics> @type (<)
13:52:47 <lambdabot> forall a. (Ord a) => a -> a -> Bool
13:53:20 <illissius> the unfortunate thing is that <= looks like an arrow, and it's pointing the wrong way.
13:53:39 <EvanR> vanity syntax! ;)
13:53:39 <dmwit> looks fine if you read it as "subset or equal", no?
13:54:08 <illissius> yeah, I guess that's true.
13:54:09 <nobdraisentone> startling: a monad
13:54:28 <EvanR> nobdraisentone: so yeah, then it has fmap
13:54:38 <nobdraisentone> Or no
13:55:02 <joewhite> {parent(X, alice), parent(pam; alice)}      Guys , i have question with prolog unification , how does it goes actually ?
13:56:53 <Catnaroek> Hello. Please excuse me if I am saying something stupid. Is there any function equivalent to "f n s = (take n s, drop n s)" ?
13:57:00 <nobdraisentone> Another question: is there a way to remove element from MArray?
13:57:02 <sclv> joewhite: try ##prolog?
13:57:04 <EvanR> Catnaroek: splitAt
13:57:15 <Catnaroek> EvanR: Nice, thanks.
13:57:47 <joewhite> sclv:yes
13:58:10 <startling> nobdraisentone: what does "remove" mean?
13:58:27 <EvanR> nobdraisentone: arrays have a fixed size
13:58:42 <startling> nobdraisentone: put an empty value at that location? then make it an MArray of Maybe
13:59:13 <hiptobecubic> I didn't realize you could pattern match an operator like this.....  "zipWith (*) (x:xs) (y:ys) = x * y : zipWith (*) xs ys"
13:59:34 <nobdraisentone> startling: remove means smth like `fromList [(1,"a"), (2,"b")] → fromList [(1,"a")]'
13:59:48 <startling> nobdraisentone, don't think so
13:59:59 <EvanR> nobdraisentone: youll have to do just that
14:00:08 <EvanR> create a new array with a different size
14:00:12 <startling> nobdraisentone, maybe you dont want an array?
14:00:15 <EvanR> sounds like you dont want to use arrays
14:01:22 <hpaste> timthelion pasted “cabal” at http://hpaste.org/70492
14:01:45 <timthelion> So I'm writting my very first cabal file ever, and I get that error when I go to configure my package...
14:01:58 <timthelion> I know for sure that vty is most deffinitely installed
14:02:06 <nobdraisentone> joewhite: `pam' and `alice' are not variables, so second predicate return True or False only. So, it return all possible X's, that match first predicate, only in case, that second predicate is true
14:02:11 <applicative> if someone is trying to build something with cabal and gets "ghc: out of memory (requested 1048576 bytes)" can he pass a flag to increase it?
14:02:30 <timthelion> applicative: isn't that a bit like downloading more ram ;)
14:02:59 <applicative> you think  ghc would take what it could get.  i guess so
14:03:15 <nobdraisentone> startling: maybe. I'm looking for some mutable structure with availability to remove elements.
14:03:23 <applicative> grrrr
14:03:27 <timthelion> applicative: what do you have free?
14:03:28 <nobdraisentone> Something like mutable map will be great
14:03:31 <timthelion> aka free -h?
14:03:38 <joewhite> nobdraisentone: thx so much
14:03:47 <applicative> timthelion: it's not me, i'm trying to help someone in spain install something
14:03:59 <EvanR> nobdraisentone: just use a Data.Map
14:04:17 <EvanR> or IntMap
14:04:27 <startling> nobdraisentone, sure you need mutability?
14:04:41 <timthelion> applicative: sorry, just tryin to help :) :)
14:05:04 <EvanR> IORef (IntMap Whatever)
14:05:05 <startling> nobdraisentone: if you *really* need mutability, http://hackage.haskell.org/package/judy might be useful
14:05:05 <nobdraisentone> startling: yes I do
14:05:18 <EvanR> or MVar (IntMap Whatever)
14:05:23 <applicative> timthelion: but if free -h tells him he has more can he request it, or is it obvious he's lost?
14:05:44 <applicative> or whatever
14:05:44 <nobdraisentone> EvanR: what is the difference between IORef and MVar?
14:05:52 <EvanR> MVar is concurrent
14:06:01 <timthelion> applicative: I don't know. he might be able to free some memory.
14:06:14 <EvanR> IORef will work if you only have one thread
14:06:18 <applicative> timthelion: hmm
14:06:40 * applicative is of course ignorant of so-called operating systems
14:06:55 <EvanR> barely operating systems ;)
14:07:06 <nobdraisentone> startling: built only on ghc-7.0 :[
14:07:38 <fmap> one IORef can be used safely with multithreading
14:07:56 <applicative> oh wait, ghc takes +RTS -K100000000m
14:08:08 * applicative studies
14:08:08 <kallisti> nobdraisentone: IORef can be used in a somewhat threadsafe way as well, with atomicModifyIORef. The difference is that MVar has a locking mechanism whereas IORef does not.
14:08:12 <tac-tics> What does -k1000000m do?
14:08:13 <joewhite> nobdraisentone: {p(f(X),c),p(Y,f(Z))} for this can i may be say *ail, because both f(Z) and c are not variables (case 1/2   not fulfilled * ?
14:08:22 <EvanR> just use MVar
14:08:26 <joewhite> nobdraisentone: *fail*
14:09:10 <MagneticDuck> yo, I'm a little confused about how IO is a monad
14:09:36 <EvanR> are you confused about IO, or about Monads in general, or both?
14:09:42 <MagneticDuck> just IO
14:09:57 <MagneticDuck> general question
14:09:59 <MagneticDuck> heh
14:10:10 <EvanR> main is an IO action and gets executed when you run the program, you can combine IO actions in various ways to get sequential effects
14:11:03 <MagneticDuck> how does "return () >>= putStrLn "hello"" work?
14:11:19 <MagneticDuck> putStrLn :: String -> IO ()
14:11:29 <MagneticDuck> return () doesn't have type IO String
14:11:51 <c_wraith> it doesn't work.
14:11:54 <c_wraith> it's a type error
14:12:05 <c_wraith> :t return () >>= putStrLn "hello"
14:12:06 <lambdabot>     Couldn't match expected type `() -> m b'
14:12:06 <lambdabot>            against inferred type `IO ()'
14:12:06 <lambdabot>     In the second argument of `(>>=)', namely `putStrLn "hello"'
14:12:12 <MagneticDuck> okay
14:12:16 <applicative> tac-tics: -Kx is a runtime flag http://www.haskell.org/ghc/docs/7.2.2/html/users_guide/runtime-control.html  I  was hoping  ghc itself could take it
14:12:43 <kallisti> MagneticDuck: the right-hand side of >>= is a function
14:12:49 <kallisti> not an IO computation
14:12:55 <MagneticDuck> so how does "do {return (), putStrLn "hello"}" work
14:13:01 <kallisti> it uses >>
14:13:08 <kallisti> do{m; n}  is m >> n
14:13:08 <nand`> @unmtl MaybeT (Writer [a]) ()
14:13:08 <lambdabot> (Maybe (), [a])
14:13:12 <MagneticDuck> oh
14:13:16 <kallisti> m >> n = m >>= const n
14:13:21 <nand`> @unmtl WriterT [a] Maybe ()
14:13:22 <lambdabot> Maybe ((), [a])
14:13:58 <kallisti> MagneticDuck: sounds like you're actually confused about monads in general and not specifically IO.
14:13:58 <timthelion> anyone on why http://hpaste.org/70492 doesn't work ??? :( :( :(
14:14:25 <monochrom> build-depends: vty
14:14:26 <startling> MagneticDuck: think of it like "return () >>= (\_ -> putStrLn "hello")"
14:14:33 <MagneticDuck> yeah
14:14:35 <MagneticDuck> I know that
14:14:46 <startling> MagneticDuck, cool! so it just throws out the ()
14:14:56 <MagneticDuck> lol I'm having a newbie moment. If I have enough of them I'll eventually get good. :D
14:14:58 <startling> MagneticDuck: like any other function that does nothing with its input
14:15:01 <monochrom> oh, you have that line, but you have it at a wrong place. move it after "Executable: hdm"
14:15:23 <startling> MagneticDuck: yeah, it's tricky to wrap your head around at first. it's easier than you think, though@!
14:15:35 <monochrom> build-depends is a per executable/library local clause, not a header global clause
14:16:01 <startling> MagneticDuck: just remember that anything in do notation can be represented as >>=s, and >> is a special case of >>=
14:16:08 <hpaste> timthelion annotated “cabal” with “cabal (annotation)” at http://hpaste.org/70492#a70494
14:16:16 <timthelion> monochrom: changed it, stil doesn't work though :(
14:16:38 <monochrom> works here. cannot reproduce.
14:16:45 <timthelion> monochrom: oh, thaks
14:16:47 <timthelion> thanks
14:17:00 <timthelion> sorry, you're typing faster than I can think :)
14:17:01 <monochrom> maybe add indentation
14:17:05 <tzxn3> yeah, "m >> f" is the same as "m >>= \_ -> f"
14:17:26 <tzxn3> as far as I know
14:17:39 <shachaf> @src (>>)
14:17:39 <lambdabot> m >> k      = m >>= \_ -> k
14:17:59 <kallisti> and do {m; n}  and do {_ <- m; n}
14:18:04 * kallisti wants to beat the horse into the ground.
14:19:30 <EvanR> reductionists ;)
14:19:52 <EvanR> just let expressions of the form a >> b, be ;)
14:19:59 <tzxn3> it's really just that >> looks neater and takes fewer key presses
14:20:09 * monochrom is a reductionist
14:20:22 <byorgey> tzxn3: m >> f is the same as  m >>= \_ -> f  by default, and even if the definition of >> is overridden, it still ought to be semantically equivalent
14:20:33 <startling> can >> even be overridden?
14:20:40 <byorgey> yes
14:20:45 <EvanR> its in the class
14:20:45 <byorgey> because it is a member of the Monad type class
14:20:46 <kallisti> I prefer do let in do {do m; do n}
14:20:53 <startling> oh, i thought it was separately defined
14:21:03 <rwbarton> a member with a default definition
14:21:06 <EvanR> pleaseDo
14:21:10 * monochrom acknowledges that reductions aren't always possible or practical
14:21:17 <EvanR> intercal ftw
14:21:46 <kallisti> EvanR: you know...
14:21:54 <kallisti> we could make an intercal monad
14:22:01 <EvanR> its funny when reductions leave you with something more complex than what you started with xD
14:22:04 <kallisti> basically IO that keeps count of how polite you are
14:22:16 <EvanR> lol
14:22:20 <EvanR> comeFrom
14:22:28 <kallisti> oh right.
14:22:55 <kallisti> please $ do ...    is easy enough though
14:27:23 <kallisti> I think to make a come from that looked syntactically correct you would need some sort of TH magic?
14:28:09 <monochrom> hrm, like IO but detects how polite you are? :)
14:28:24 <EvanR> kallisti: Acme.Dont
14:28:30 <donri> @hackage acme-dont
14:28:30 <lambdabot> http://hackage.haskell.org/package/acme-dont
14:29:31 <monochrom> so, like, m >>= \x -> please (f x) will work but m >>= f may not work? :)
14:29:55 <donri> i imagine "don't" can actually be useful as an alternative to commenting out code ;)
14:30:10 <EvanR> ya
14:30:56 <applicative> so the guy with the error "ghc: out of memory (requested 1048576 bytes)" in fact only has about 1048576 bytes? hm
14:30:59 <kallisti> don't = const (return ())
14:30:59 <EvanR> yeah, please increments a politeness counter randomly
14:31:11 <EvanR> and decrements for each >>=
14:31:17 <EvanR> until stuff doesnt work anymore
14:31:18 <timthelion> EvanR: randomly, or deterministically?
14:31:23 <EvanR> both
14:31:24 <monochrom> hahaha base < 1000000
14:31:39 <timthelion> cheater__: Hello?
14:32:22 <kallisti> EvanR: I suppose pseudo-randomly is both deterministic and random in some sense.
14:32:25 <kallisti> unless you meant something else.
14:34:57 <EvanR> i object to so called pseudo random being referred to as pseudo
14:35:09 <EvanR> its still random, thanks
14:35:38 <monochrom> that dives into different people defining "random" differently due to different philosophies
14:35:39 <zmv> it's still pseudo :P
14:35:40 <EvanR> pseudo is pejorative ;)
14:35:57 <EvanR> im just reading 'pseudo' as 'not'
14:36:07 <kallisti> EvanR: from a theoretical standpoint pseudorandom is not random at all.
14:36:13 <kallisti> so, yes.
14:36:20 <monochrom> I certainly understand the stance that "fairly unpredictable => random"
14:36:31 <EvanR> hide a sufficiently good RNGs state and show a theoretical difference xD
14:36:56 <monochrom> ah, but some very bad generators are really psuedo, even in your sense :)
14:37:05 <kallisti> to my knowledge all PRNGs are periodic
14:37:07 <EvanR> yeah
14:37:08 <kallisti> so, that's easy enough
14:37:11 <zmv> 4 is the standard random number. Enough said.
14:37:37 <monochrom> Knuth certainly admits that his first attempt at a generator failed miserably :)
14:37:51 <EvanR> kallisti: finite memory, yeah
14:38:05 <EvanR> but i wouldnt say thats implied by 'pseudo random generator'
14:38:24 <EvanR> especially since one meg of memory would be a ridiculously big state, and we have 16 gigs of memory now
14:38:41 <EvanR> and it keeps increasing
14:38:48 <semigroup> I've got a lot of threads running concurrently and I'm looking for a simple way to wait to exit until they're all finished. What's the easiest way to wait for arbitrarily many threads?
14:39:03 <kallisti> pseudo random generator implies a deterministic process to producing values. Which is inherently non-random. I'm not sure what we're discussing here that isn't already obvious.
14:39:08 <monochrom> haha obXKCD: http://xkcd.com/221/ (probably zmv is referring to this :) )
14:39:18 <kallisti> @hackage threads
14:39:18 <lambdabot> http://hackage.haskell.org/package/threads
14:39:21 <kallisti> semigroup: ^
14:39:23 <EvanR> kallisti: forM take from a list of MVar ()
14:39:28 <EvanR> semigroup: ^
14:40:10 <EvanR> kallisti: deterministic doesnt have to mean finite memory
14:40:37 <kallisti> but what does finite memory have to do with pseudorandom generators being truly random
14:40:43 <semigroup> EvanR, nice and simple, I like it.
14:40:50 <EvanR> there are many examples of chaotic systems that no one knows if they are periodic
14:41:02 <EvanR> chaotic, deterministic systems
14:41:08 <kallisti> semigroup: I like the ThreadGroup approach. very easy.
14:41:18 <EvanR> kallisti: finite memory is the reason you objected on the basis of periodic
14:41:26 <EvanR> which is an orthogonal issue
14:44:20 <applicative> how do I negate a flag with cabal  -fno-<flag> ?
14:44:39 <monochrom> that probably depends on which flag, and some are impossible
14:44:44 <applicative> wait yes
14:45:48 <applicative> hm.  If i change the default to False in the cabal file it believes me, why cant I do it from the command line?
14:46:44 <timthelion> Can I leave someone a message using a bot in this channel?
14:47:00 <hiptobecubic> timthelion, there is one for all of freenode
14:47:11 <mauke> @help tell
14:47:12 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
14:47:17 <applicative> i got it cabal install json --flags -parsec
14:47:30 <timthelion> mauke: thanks
14:47:43 <hiptobecubic> \how
14:47:47 <hiptobecubic> msg MEMOSERV SEND hiptobecubic "msg"
14:47:51 <hiptobecubic> there it is
14:47:56 <timthelion> and cheater__ is http://cheater.posterous.com ?
14:48:00 <timthelion> does anyone know?
14:50:04 <timthelion> @tell cheater__  "I've stolen your code and put it https://github.com/timthelion/hdm/blob/master/Menu.hs and would like your permission to use it.  You can reply to me at timothyhobbs@seznam.cz"
14:50:04 <lambdabot> Consider it noted.
14:50:17 <EvanR> haha
14:50:18 * timthelion feeds lambdabot some botsnack
14:50:22 <EvanR> timthelion: copying is not theft
14:51:06 <timthelion> EvanR: I tend to agree, which is why I release everything under the GPL...  But his code had no licence info.
14:51:20 <EvanR> its still not theft xD
14:51:46 <hiptobecubic> timthelion, no license means free for everyone to do anything
14:52:01 <timthelion> hiptobecubic: in my wet dreams it does
14:52:01 <EvanR> hiptobecubic: not legally true
14:52:13 <EvanR> theres an implied copyright
14:52:21 <tzxn3> all my functions seem to be in the IO monad
14:52:34 <EvanR> tzxn3: sounds like C code ;)
14:53:30 <tzxn3> though what I'm writing isn't really suited to a purely functional language
14:53:48 <tzxn3> it's more a shell script/python type thing
14:53:51 <EvanR> do you have a lot of actual IO ?
14:53:55 <tzxn3> yes
14:54:17 <EvanR> good thing haskell is one of the best imperative languages ;)
14:54:40 <pooya72> programming noob here, but would you guys consider haskell good for prototyping?
14:54:47 <copumpkin> pooya72: absolutely
14:55:01 <hiptobecubic> pooya72, that is one of the things it is considered "good at"
14:55:05 <EvanR> what i like about that is the data structure definition language in haskell
14:55:11 <mauke> one time I prototyped a Haskell library in C :-(
14:55:25 <bitonic> mauke: that sounds like a brilliant idea
14:55:32 <applicative> timthelion: if anything the gpl is an unusually emphatic assertion of private ownership.
14:55:39 <mauke> I had to, I couldn't get the TVars right
14:55:45 <timthelion> I only like haskell, because it actually has types.  I find types to be soo intuitive!
14:55:46 <EvanR> people tend to not think out their data very well in js, python, ruby etc
14:55:49 <mauke> so I wrote it in C with pointers
14:56:02 <shachaf> mauke: Why not write it in Haskell with IORefs?
14:56:08 <pooya72> hiptobecubic: I just read a remark from paul graham and he didn't think it was good for prototyping. that's what got me thinking
14:56:32 <copumpkin> pooya72: he doesn't give good reasons for that opinion, so I doubt it's particularly well reasoned :)
14:56:36 <mauke> shachaf: because IORefs are TVars for my purposes
14:56:43 <mauke> it wouldn't change the code
14:57:01 <timthelion> applicative: the GPL is only a reaction on a broken system.
14:57:06 <shachaf> Ah.
14:57:21 * applicative concedes that point
14:57:31 <mauke> C can do pp = &(*pp)->next; and other fun stuff
14:57:31 <pooya72> copumpkin: lol
14:58:34 <tzxn3> man, everything seems to be coming together
14:58:47 <tzxn3> I now understand the usefulness of monadic IO P:
14:58:47 <EvanR> the neutrons are forming
14:59:45 <applicative> pooya72: mr paul graham was dissing haskell? now we're ruined
15:00:01 <bitonic> let's ta
15:00:03 <bitonic> oops.
15:00:07 <donri> paul graham, the mother of all the lisp snobs
15:00:10 <bitonic> sorry. you can continue.
15:00:15 <pooya72> applicative: lol
15:00:18 <mauke> lisp is blub
15:00:30 <bitonic> lisp is fun
15:01:22 <timthelion> who the hell is this paul graham dood? What has he written in Haskell?
15:01:23 <pooya72> but it did get me thinking if a dynamic language would be better for prototyping. but then you change things so often, a good type system can let you know where things have been broken.
15:01:31 <donri> lisp is ruined by obnoxious fanboys
15:01:38 <tzxn3> Lisp has macros!!!!11!1
15:01:39 <roconnor> I'm a bottom-up programmer.  I start by making data structures and building operations on them.  I'm not sure how I'd do this without types.
15:01:41 <bitonic> pg said something along the lines "yeah static types are static, programs change => static types are bad!". who cares.
15:01:48 <tac-tics> Lisp is the joke. And Paul Graham is the punchline.
15:01:58 <donri> pooya72: -fdefer-type-errors ;)
15:02:04 <mauke> -fignore-errors
15:02:16 <monochrom> both dynamic languages and haskell are great for prototyping and script. yes this is a paradox for many people.
15:02:32 <semigroup> -fruby-mode
15:02:37 <pooya72> roconnor: I think I'm the same way.
15:02:39 <bitonic> roconnor: that's curious because pg is probably one of the foremost advocate for bottom-up, and one of his main tools is dynamic typing
15:02:47 <roconnor> bitonic: interesting
15:02:56 <bitonic> roconnor: see "On Lisp"
15:03:10 <EvanR> at some point someone may realize that macros are functions
15:03:16 <pooya72> I wish I could find that comment he left on lambda the ultimate
15:03:17 <EvanR> maybe not
15:03:36 <roconnor> I was a little frusterated with the recent live-coding haskell video on reddit since he starts with a very procedural approach to the problem.
15:03:45 <roconnor> but I don't mean to complain
15:04:12 <roconnor> I actually feel a bit guilty for feeling frusterated.
15:04:30 <bitonic> I like lisp a lot in the end, it can be as if not more fun than Haskell. but Haskell is something else.
15:04:37 <monochrom> pooya72: http://donsbot.wordpress.com/2010/08/17/practical-haskell/
15:05:30 <hiptobecubic> I like this "triangle of disagreement"
15:05:30 <applicative> live coding haskell yipe
15:05:36 <pooya72> I found it. It's his comment from 2004: http://lambda-the-ultimate.org/node/186#comment-1351
15:05:44 <hiptobecubic> Seems like something that would have been on the wall in high-school english class
15:06:18 <EvanR> hiptobecubic: triangle of disagreement?
15:06:20 <hiptobecubic> https://en.wikipedia.org/wiki/Paul_Graham_(computer_programmer)#Graham.27s_Hierarchy_of_Disagreement
15:07:24 <applicative> pooya72: god, what a jerk the graham character is.  it was almost 10 yrs ago
15:07:38 <startling> macros are just dynamically-scoped functions that implicitly quote their arguments
15:07:41 <startling> duh
15:07:48 <hiptobecubic> "You are an ass hat." is my preferred way to disagree
15:08:00 <tac-tics> "I don't consider myself to be doing research on programming languages. I'm just designing one, in the same way that someone might design a building or a chair or a new typeface." - Paul Graham, on Arc
15:08:07 <tac-tics> I would never want to sit in a chair built by Paul Graham
15:08:59 <mgsloan> Hmm, I actually kind-of agree with the sentiment that a good deal of language design is aesthetic design
15:09:11 <phao> are monads somewhat like list comprehentions?
15:09:19 <EvanR> this blub stuff and hierarchy of disagreement annoys me, because its hierarchical
15:09:23 <roconnor> mgsloan: as it, what syntax shall we use for comments :D
15:09:25 <tac-tics> phao: They are related, yes.
15:09:26 <roconnor> *as in
15:09:28 <phao> sions*
15:09:52 <mgsloan> roconnor: Yeah, it matters!  A little bit :)
15:10:00 <tac-tics> > [(x, y) | x <- [1,2,3], y <- "abc"]
15:10:01 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
15:10:13 <tac-tics> > do x <- [1,2,3]; y <- "abc"; return (x, y)
15:10:14 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
15:10:32 <codolio> roconnor no doubt agrees.
15:10:36 <codolio> Syntax is all there is, after all.
15:10:45 <roconnor> :)
15:10:46 <applicative> pooya72:  ah the 'designed by committee' meme appears there too. fortunately someone points out that Miranda was designed by a single master
15:11:01 <phao> hmm
15:11:08 <roconnor> I wish Turner was a millionare
15:11:25 <phao> tac-tics, list comprehensions (and this) makes me remember SQL
15:11:28 <applicative> me too
15:11:30 <phao> and that Linq stuff
15:11:32 <bitonic> pooya72: aha. nice digging. that proves that pg had no idea about Haskell.
15:11:32 <bitonic> also, loving the attack "I get the impression that using it would feel like reading a novel written by a literary critic."
15:11:32 <bitonic> well maybe he's better off lending money
15:11:47 <parcs`> well that was 8 years ago
15:11:48 <phao> tac-tics, do you know how all these things are related?
15:12:12 <EvanR> 'power spectrum of programming languages'
15:12:17 <EvanR> :(
15:12:20 <roconnor> did SPJ get his award for Haskell or for GHC?
15:12:38 <tac-tics> phao: I'm not sure what you mean "how" they are related. But you can translate from any of them to any other.
15:12:47 <kwmiebach> How can i find out which package to install for example to fulfil "import qualified Data.ByteString.UTF8"
15:13:02 <bitonic> kwmiebach: google? anyway, it's `bytestring'
15:13:03 <phao> hmm
15:13:07 <pooya72> but haskell really is so different than other languages that its hard to judge it.
15:13:17 <startling> kwmiebach: you can't know for sure
15:13:25 <phao> tac-tics, it's just that a sql query looks a lot like a list comprehension expression
15:13:30 <startling> kwmiebach: some other package can provide Data.ByteString.UTF8
15:13:52 <tac-tics> phao: Yeah. That's because they're all trying to express the same essential thing.
15:13:55 <kwmiebach> ok thank you. to know there is no way is better than know nothing : )
15:14:26 <phao> tac-tics, do you know what thing that is?
15:14:27 <EvanR> to know there is no way better is to know nothing
15:14:35 <startling> kwmiebach: yep. but the standard Data.ByteString.UTF8 is provided by 'bytestring', as bitonic says
15:14:54 <parcs`> 8 years ago did haskell even have ghci, or cabal?
15:15:02 <parcs`> er, ghc
15:15:12 <dmwit> GHC is like 20 years old.
15:15:14 <codolio> GHC was around.
15:15:20 <codolio> GHCi I think not.
15:15:22 <parcs`> s/haskell/ghc
15:15:23 <codolio> But Hugs was around.
15:15:47 <parcs`> oh right, hugs
15:16:00 <jfischoff> Paul Graham identity from high school was based on being smarter then the jocks. When he got a phd he changed it to being a better programmer then the people that were smarter then him.
15:16:03 <tac-tics> phao: I don't know the name for it. "do" notation works for monads, comprehension notation works for lists (and also for monads in Haskell)
15:16:13 <jfischoff> it just ego preservation
15:16:16 <tac-tics> phao: Maybe you'd call it "nondeterministic computation" to be fancy
15:16:30 <fmap> actually Data.ByteString.UTF8 is from utf8-string
15:16:41 <phao> =)
15:16:41 <tac-tics> phao: SQL is based on more concrete notions, like cartesean products and filters
15:16:50 <bitonic> oh, fmap is right, sorry kwmiebach.
15:16:57 <bitonic> @google Data.ByteString.UTF8
15:17:00 <lambdabot> http://hackage.haskell.org/packages/archive/utf8-string/0.3/doc/html/Data-ByteString-UTF8.html
15:17:00 <lambdabot> Title: Data.ByteString.UTF8
15:17:06 <codolio> GHCi is bordering on 8 years old, though, I think.
15:17:07 <bitonic> good job google.
15:17:13 <tac-tics> phao: If you want to have the equivalent of a "where" clause in Haskell, you need more than a monad, you need a MonadPlus
15:17:16 <tac-tics> @type guard
15:17:17 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
15:17:23 <codolio> Because I probably started using Haskell about that long ago, and ghci wasn't too far after that.
15:17:48 <tac-tics> > do x <- [1,2,3]; y <- [1,2,3,4,5]; guard (x == y); return (x, y)
15:17:49 <lambdabot>   [(1,1),(2,2),(3,3)]
15:18:02 <tac-tics> ^ the "guard" call acts like a where clause in sql
15:18:14 <phao> hmm
15:18:15 <dmwit> ghci was added in 5.00, apparently, which was released June 2001.
15:18:21 <dmwit> So ghci existed 8 years ago, yes.
15:18:35 <monochrom> pooya72: http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html
15:19:06 <phao> thx tac-tics
15:19:16 <pooya72> monochrom: thanks
15:20:27 <monochrom> recent GHC has a monad comprehension syntax that supports the whole shebang of "where", "group by"
15:20:27 <kwmiebach> fmap, thank you. now i can compile. and it works: http://37.188.114.200:3000/
15:20:31 <pooya72> i actually don't find haskell that much different than ruby for prototyping. but just learning haskell is much more difficult.
15:21:00 <codolio> Oh, it's older than I thought.
15:21:08 <EvanR> ruby has no real type system
15:21:15 <jfischoff> pooya72: learning to write correct ruby code is harder for me the correct haskell code
15:21:22 <codolio> I guess it's that it was actually getting good enough to use instead of Hugs back when I started.
15:21:26 <EvanR> jfischoff: sam
15:21:27 <EvanR> e
15:21:33 <hpaste> nand` annotated “Lambda calculus with trivial types” with “Lambda calculus with polymorphic types” at http://hpaste.org/70490#a70496
15:21:38 <EvanR> for various reasons
15:21:54 <blackdog> jfischoff: jeez, who cares about correct code? That won't get you onto hacker news.
15:22:10 <mel-> I am new to haskell and i'm kind of confused... I'm writing a function for parsing a configuration file. now, i'm not sure what the correct approach in the haskell world is for handling cases like syntax errors in the file to parse. in other languages i would have aborted with an error message immediately or i would have thrown an exception. what's appropriate for haskell?
15:22:28 <jfischoff> blackdog: thank god :)
15:22:30 <pooya72> jfischoff: lol, I actually don't know what "correct" ruby code is. I think that was one of my fears. I'm a solo hobbyist, so none tells me when I'm off track :(
15:22:45 <EvanR> mel-: if youre using Parsec, theres a combinator to issue a parse error message
15:22:48 <jfischoff> pooya72: bug free
15:22:57 <zachk> mel-: you can use: error string, but that is generally considered inappropriate
15:23:01 <t7> who is shae erricson?
15:23:10 <mel-> zachk: that's what i thought.
15:23:11 <byorgey> mel-: your parsing function should return not a Config (say) but a  Maybe Config, or an  Either String Config
15:23:11 <pooya72> jfischoff: but to find bugs you need users :)
15:23:16 <byorgey> to indicate the possible failure.
15:23:40 <jfischoff> pooya72: no you just need to cover all your cases
15:23:54 <mel-> EvanR: primarily for teaching myself haskell i want to write the function (it's simply syntax btw) myself, without any fancy packages.
15:23:56 <pooya72> that's true
15:23:58 <monochrom> correct code means you have a formal (symbolic) specification and you have a formal (symbolic) program and you can prove (you may skip it) that the latter satisfies the former.
15:24:05 <EvanR> Either String Config or something analogous is used in many reader libs
15:24:11 <mel-> Ah!
15:24:16 <mel-> Either String Config
15:24:24 <mel-> and String is the error message describing the syntax error
15:24:26 <startling> mel-: or Maybe Config
15:24:29 <EvanR> yeah
15:24:31 <shoerain> You know/buffer 21
15:24:33 <shoerain> er
15:24:37 <mel-> thank you
15:24:41 <monochrom> as a special case, if the specification says "any behaviour is acceptable", then your program is already correct
15:24:47 <EvanR> mel-: the Left value for Either is conventionally used for the error case
15:25:05 <mel-> alright
15:25:27 <mel-> anyway, i'll visit the world of dreams now. good night !
15:26:16 <byorgey> t7: no idea who Shae Erricson is.  Shae Erisson is a super-cool dude who you can read about here http://www.scannedinavian.com/about/ and hangs out in #haskell as shapr
15:27:54 <monochrom> shae ericsson is shae erisson's evil twin who prefers erlang to haskell :)
15:29:06 <t7> i have him on my google+
15:29:07 <byorgey> hahaha
15:29:13 <jfischoff> @remember monochrome: shaw ericsson is shaw erisson's evil twin who prefers erlang to haskell :)
15:29:13 <t7> but i didnt know his IRC name
15:29:13 <lambdabot> Done.
15:29:25 <jfischoff> crap
15:29:41 <jfischoff> @forget monochrome: shaw ericsson is shaw erisson's evil twin who prefers erlang to haskell :)
15:29:41 <lambdabot> Done.
15:29:52 <codolio> monochrom, You know, I'd always mentally inserted the c, and never noticed.
15:30:06 <jfischoff> @remember monochrom: shae ericsson is shae erisson's evil twin who prefers erlang to haskell :)
15:30:06 <lambdabot> I will remember.
15:30:14 <blackdog> codolio: it's from eris, the goddess of chaos :)
15:30:25 <mauke> @quote monochrom:
15:30:26 <lambdabot> monochrom: says:  Turbo Pascal is the best thing since GHC.
15:30:51 <parcs`> :t id <*> (:[])
15:30:52 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a -> b]
15:30:52 <lambdabot>       Expected type: a
15:30:52 <lambdabot>       Inferred type: [a -> b]
15:31:37 <parcs`> :t let f = head in f [f]
15:31:38 <lambdabot> forall a. [a] -> a
15:31:42 <otters> :t (id <*>)
15:31:43 <lambdabot> forall a b. ((a -> b) -> a) -> (a -> b) -> b
15:32:10 <parcs`> :t ?f [?f]
15:32:12 <lambdabot> Top level:
15:32:12 <lambdabot>     Occurs check: cannot construct the infinite type: t = [t] -> t1
15:32:12 <lambdabot>       Expected type: [t] -> t1
15:35:20 <parcs`> isn't the x in \x -> x x just a rank 2 type?
15:35:56 <EvanR> :t \x -> x x
15:35:57 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
15:35:57 <lambdabot>     Probable cause: `x' is applied to too many arguments
15:35:57 <lambdabot>     In the expression: x x
15:36:26 <EvanR> i still dont get that
15:36:33 <monochrom> I don't think rank-2 or rank-any helps
15:36:52 <EvanR> > (\x -> x x) id
15:36:54 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
15:36:55 <parcs`>  :t \(x :: forall a. a -> a) -> x x
15:37:03 <parcs`> :t \(x :: forall a. a -> a) -> x x
15:37:04 <lambdabot> forall a. (forall a1. a1 -> a1) -> a -> a
15:37:13 <monochrom> oh, it does
15:38:11 <parcs`> is rank 2 type inference undecidable?
15:38:58 <EvanR> > (\x -> x x) (\x -> x x)
15:38:59 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
15:39:18 <EvanR> <lambdabot> (\x -> x x) (\x -> x x)
15:39:18 <EvanR>  ;)
15:39:37 <parcs`> @where fix
15:39:38 <lambdabot> I know nothing about fix.
15:39:41 <EvanR> haskell is broken, it cant construct infinite types
15:39:46 <parcs`> @where y
15:39:46 <lambdabot> \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x)))
15:40:09 <parcs`> @src Rec
15:40:10 <lambdabot> newtype Rec a = InR { outR :: Rec a -> a }
15:40:16 <parcs`> EvanR: lies!
15:40:22 <mauke> parcs`: no
15:40:30 <parcs`> mauke: no what?
15:40:41 <mauke> rank 2 type inference is not undecidable
15:40:56 <tac-tics> @type fix InR
15:40:57 <lambdabot>     Couldn't match expected type `Rec a -> a'
15:40:58 <lambdabot>            against inferred type `Rec a'
15:40:58 <lambdabot>     In the first argument of `fix', namely `InR'
15:41:08 <parcs`> then why doesn't ghc do it
15:41:22 <mauke> because it's hard
15:41:57 <illissius> my RULES, my RULES, my RULES do not fire :(
15:42:16 <jfischoff> can you make optional arguments that aren't flags in optparse-applicative?
15:44:34 <jfischoff> ah value
15:46:44 <ArchBlob> hello
15:47:33 <jrw> hi ArchBlob
15:47:50 <ArchBlob> i am looking for something like this Either a b -> ( b -> c) -> Either a c
15:48:01 <ArchBlob> it is trivial using pattern mathcing
15:48:05 <DMcGill> fmap
15:48:16 <ArchBlob> but i am wondering if there is a clever way
15:48:18 <DMcGill> :t fmap
15:48:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:48:21 <ArchBlob> fmap won;t do
15:48:37 <ArchBlob> because i need not change if it is Left
15:48:40 <DMcGill> > fmap show (Right 123)
15:48:42 <lambdabot>   Right "123"
15:48:48 <DMcGill> > fmap show (Left 123)
15:48:49 <lambdabot>   Left 123
15:49:00 <DMcGill> fmap is exactly what you want
15:49:23 <ArchBlob> is it...
15:49:29 <jfischoff> @djinn Either a b -> ( b -> c) -> Either a c
15:49:29 <lambdabot> f a b =
15:49:30 <lambdabot>     case a of
15:49:30 <lambdabot>     Left c -> Left c
15:49:30 <lambdabot>     Right d -> Right (b d)
15:49:40 <DMcGill> well it applies the function to the Right and doesn't apply it to the Left
15:49:51 <ArchBlob> myEither e@(Right _) f = fmap f e
15:49:52 <ArchBlob> myEither (Left  x) _   = Left x
15:49:55 <ArchBlob> this is what i did
15:50:05 <jrw> that's fmap
15:50:14 <DMcGill> fmap f (Left x) === Left x
15:50:26 <alpounet> that's fmap for the 'Either a' Functor instance
15:51:02 <jrw> ArchBlob, what else could fmap do when given a Left? it needs to come up with a value of type a... it better use the one it was given
15:51:11 <fmap> another option is `right' from Control.Arrow
15:51:16 <Levine_> http://pastebin.com/dJiniMMC     Hi Guys i have some codes for you, ahm when i try implemnt this , get an parse error on input '='   here : sumrecip [] = Just 0
15:51:18 <mauke> The paste dJiniMMC has been copied to http://hpaste.org/70499
15:51:35 <dmwit> jrw: Not necessarily. It could come up with a value of type c. ;-)
15:51:36 <ArchBlob> i have looked into control.Arrow
15:51:41 <dmwit> (This is even harder, though. =)
15:52:07 <ArchBlob> and found something about postcomposition with a pure function
15:52:08 <jrw> dmwit, fair enough :)
15:52:14 <DMcGill> Levine: there's a capital 'R' on line 21
15:52:22 <ArchBlob> that looked like this
15:52:25 <DMcGill> Haskell is case sensitive
15:52:27 <dmwit> ArchBlob: Arrow provides it, as "left" and "right".
15:52:30 <jrw> I am curious what you thought fmap was doing on Left's though?
15:52:37 <dmwit> > right (*3) (Right 3)
15:52:38 <lambdabot>   Right 9
15:52:42 <dmwit> > right (*3) (Left 3)
15:52:43 <lambdabot>   Left 3
15:52:54 <mauke> Levine_: lines 13 .. 15 need to be indented
15:53:02 <ArchBlob> i thought it would apply f to left
15:53:15 <ArchBlob> and i don't whant it do do that
15:53:18 <dmwit> ArchBlob: f doesn't have the right type to be applied to the Left's.
15:53:21 <jrw> ArchBlob, the types don't match
15:53:34 <dmwit> ArchBlob: Just look at the type: fmap :: (a -> b) -> Either notA a -> Either notA b
15:53:56 <dmwit> ArchBlob: I have chosen some type variable names that I hope are suggestive. =)
15:54:20 <ArchBlob> well, i think i get it now
15:54:32 <ArchBlob> i'll try it and come right back, thank you
15:54:52 <dmwit> But yes, I suggest using "left" and "right" rather than "fmap".
15:55:02 <dmwit> Since "right" has a counterpart "left", but "fmap" doesn't have any such counterpart.
15:55:10 <ArchBlob> i'll try that too dmwit
15:55:39 <dmwit> I guess it depends on what you're trying to emphasize.
15:55:50 <dmwit> Choose based on what makes the code most suggestive to the reader.
15:56:11 <DMcGill> note too that using "left" and "right" will lead to more complex error messages
15:56:20 <Levine_> mauke: yeah i fixed, but it STILL doesnt work
15:56:21 <DMcGill> although probably not by much tbh
15:56:27 <Levine_> tha
15:56:29 <dmwit> If you're using Either to be a real sum type, where neither side of the sum is "more important", then use left and right; if you are using it for an error type, where Right's represent success and Left's represent failure, then use "fmap".
15:57:22 <ArchBlob> i'm using it as an error type dmwit
15:57:48 <DMcGill> Levine_: repaste it
15:58:16 <dmwit> fmap, then
15:58:23 <dmwit> or one of its aliases
15:58:34 <DMcGill> (<$>) tends to be nice
15:58:36 <dmwit> liftM, liftA, (<$>), etc.
15:58:58 <Peaker> too many names..
15:59:19 <dmwit> You sound like Guido.
15:59:21 <Levine_> DMcGill: http://pastebin.com/tyr1ATTW
15:59:24 <mauke> The paste tyr1ATTW has been copied to http://hpaste.org/70500
15:59:29 <DMcGill> System.FilePath includes infix functions with aliases like "</>" and "<.>" along with the note "also some infix functions for those that like that sort of thing"
15:59:42 <dmwit> Levine_: You still haven't indented lines 14-16.
16:00:13 <Peaker> I like that about Python..  having multiple ways to say same concept is a bad thing on its own
16:00:26 <DMcGill> Levine_: note that lines 6 and 7 need to be indented the same amount
16:00:37 <dmwit> DMcGill: No, they do not.
16:00:43 <DMcGill> oh, my mistake
16:00:49 <DMcGill> sorry
16:00:49 <dmwit> Those lines are fine (though aesthetically displeasing).
16:01:16 * hackagebot parsers 0.2 - Simple parsing combinators  http://hackage.haskell.org/package/parsers-0.2 (EdwardKmett)
16:01:31 <Levine_> dmwit: Well , how ?
16:01:51 <dmwit> Levine_: Choose a string of spaces and tabs, and put that string in front of each line.
16:01:55 <dmwit> The exact same string, mind.
16:02:04 <dmwit> Many people like to choose four spaces.
16:02:06 <Peaker> class Lift0 f where lift0 :: a -> f a ; class Lift1 f where lift1 :: (a -> b) -> f a -> f b ; class Lift2 f where lift2 :: (a -> b -> c) -> f a -> f b -> f c ; class Join j where join :: j (j a) -> j a ;    type Functor f = (Lift1 f) ; type Applicative f = (Lift0 f, Lift1 f, Lift2 f) ; type Monad f = (Lift0 f, Lift1 f, Lift2 f, Join f)
16:02:06 <ArchBlob> how the hell did i missed that about fmap, and i even used it...
16:02:07 <dmwit> I like to choose one tab.
16:02:15 <bitonic> edwardk: more parsers?
16:02:15 <ArchBlob> *miss
16:02:23 <edwardk> quite literally
16:02:44 <dmwit> edwardk: Man, I think everybody should just strike the words "simple", "smart", and similar from all package descriptions. =P
16:02:50 <edwardk> bitonic: dmwit : =P
16:02:59 <ArchBlob> thank you very much guys
16:03:31 <blackdog> bitonic: there's a real difference between yesod and scotty that i'd find it difficult to describe without using some cognate of "simple" :)
16:03:45 <blackdog> gah. dmwit. sorry.
16:03:47 <edwardk> dmwit: i've patched the repo so it just says 'Parsing combinators' ;)
16:03:59 <dmwit> =D
16:04:24 <Peaker> edwardk, how does it differ from the others?
16:04:26 <dmwit> blackdog: "featureless" ;-)
16:04:36 <edwardk> bitonic: this is the bulk of the combinator set from trifecta without all the trifecta diagnostics baggage
16:04:36 <Levine_> dmwit: thx man it worked
16:04:50 <Levine_> DMcGill: thank you also)
16:05:10 <edwardk> and the classes are set up so you could make instances for attoparsec or parsec, etc. to write code independent of the parsing combinator library
16:05:13 <Peaker> edwardk, also, http://www.reddit.com/r/haskell/comments/vk7fy/mirrored_lenses/c55znmr?context=3
16:05:22 <edwardk> the classes also lift over monad transformers
16:05:25 <blackdog> dmwit: ha. no, i've found scotty quite useful
16:05:37 <blackdog> would you be ok with "spare"?
16:05:58 <edwardk> (.) composability lets you make getters and setters in the way i described in the post
16:06:02 <dmwit> eh
16:06:06 <dmwit> I'm not really religious about it.
16:06:45 <Peaker> edwardk, is that the main thing?  It's a nice advantage, but there are also downsides
16:06:52 <edwardk> if you use the separate getter, setter or the (indexed) store comonad coalgebra approach you get something where you can't make get-only or set-only operations
16:06:56 <edwardk> yes
16:07:02 <edwardk> but it was enough to convert me for that post
16:07:11 <edwardk> i gave the indexed store comonad version in the post as well
16:07:30 <Peaker> I don't know the Store comonad, so I skimmed over that part..
16:07:45 <edwardk> take youd definition and fuse the two functions
16:07:54 <Peaker> oh
16:07:59 <edwardk> oldrec -> (oldfield, newfield -> newrec)
16:08:06 <edwardk> tada
16:08:11 <edwardk> you now understand the store comonad lenses
16:08:21 <Peaker> which is the last type variable the CoMonad is open on?
16:08:29 <edwardk> newrec
16:08:37 <edwardk> usually oldfield and newfield are the same
16:08:44 <edwardk> then you get a comonad
16:08:49 <edwardk> here you only get an 'indexed comonad
16:08:55 <edwardk> and its a weird indexed algebra
16:08:57 <Peaker> ah, thanks
16:09:08 <mauke> there must be a joke about tubular bells somewhere in there
16:09:41 <edwardk> anyways the laws to be a store comonad coalgebra are the same as the lens laws, just less ad hoc
16:10:22 <edwardk> now, the benefit of going with the store comonad is that you can 'share the work you used to split the structure apart to get the field out' with the work done putting it back together
16:10:42 <edwardk> the separate getter/setter can have to do twice as much work for repeated setting
16:10:58 <edwardk> this happens to be the same performance win that you get from the van laarhoven lenses
16:11:02 <stepcut> nice
16:11:13 <edwardk> i just never spotted it in the van laarhoven lenses before
16:11:30 <edwardk> this removed my last major objection of them
16:11:50 <edwardk> now, you can get some nice performance wins out of the vL lenses that are harder with the store comonad lenses
16:11:58 <edwardk> when you inline them into ^., etc.
16:12:02 <edwardk> they can often vanish
16:12:13 <edwardk> where with the store comonad that requires a lot more work on behalf of the compiler
16:12:19 <edwardk> and i haven't seen it happening in practiec
16:13:45 <donri> what is the remaining benefits of the data-lens lenses? being haskell 98?
16:14:33 <edwardk> donri: haskell 98
16:14:45 <edwardk> thats about it
16:14:57 <edwardk> you can make a polymorphic data lens lens, but then you can't make it a category
16:15:06 <edwardk> at least not without crazy extensions
16:15:16 <edwardk> since you can make it a category with index's of kind (*,*)
16:15:44 <edwardk> so you have to use something other than (.)  and id, or add crazy extensions to compose them if you want them polymorphic
16:15:46 <dmwit> oooo
16:16:01 <donri> so if i don't care about h98, vL lenses are the future? :)
16:16:01 <dmwit> I had never even thought about the possibility of Category being kind-polymorphic.
16:16:04 <dmwit> Is that a thing that GHC does?
16:16:09 <dmwit> kind-polymorphic classes?
16:16:12 <edwardk> dmwit: yes
16:16:19 <dmwit> really cool
16:16:33 <edwardk> dmwit: with 7.4.1 you can make kind polymorphic classes, which opens up kind polymorphic categories
16:16:47 * dmwit swoons
16:16:51 <jfischoff> is there an example some where?
16:16:59 <edwardk> when Control.Category goes polymorphic then my constraints package can make a Category out of (:-) for constraint entailment
16:18:24 <edwardk> {-# LANGUAGE PolyKinds #-} import Data.Constraint; class Category a where id :: k a a; (.) :: k b c -> k a b -> k a c; instance Category (:-) where id = refl; (.) = trans
16:18:28 <edwardk> jfischoff: done ;)
16:18:46 <edwardk> you probably want to hide the Prelude (.) and id as well
16:19:20 <edwardk> jfischoff: to do good product and sum categories is harder with the current platform you really want the syntax for polymorphic kind signatures, and that didn't get in until 7.4.2 or later
16:20:22 <edwardk> jfischoff: but being able to say instance (Category i, Category j) => Category (Prod i j) where id = Prod id id; … is pretty sweet
16:20:50 <edwardk> with semigroupoids i can do (.) for product categories but without the kind (*,*) index i coudn't make id
16:21:26 <edwardk> http://hackage.haskell.org/packages/archive/semigroupoid-extras/0.2.7.2/doc/html/src/Data-Semigroupoid-Product.html#Product was what i could do before
16:21:40 <jfischoff> yeah that is really cool, but I'm still trying to get my head around what is happening
16:22:31 <edwardk> now, data Product (j :: x -> x -> *) (k :: y -> y -> *) (a :: (x,y)) (b :: (x,y)) where Pair :: j a b -> k a' b' -> Product j k '(a,a') '(b,b')
16:22:34 <edwardk> can be a Category
16:22:49 <edwardk> notice the kind variables x and y in that
16:23:18 <edwardk> andthe fact that the types there aren't products, but lifted products which inhabit the product kind
16:23:48 <edwardk> i have the benefit that we've had all this stuff working for a few months in our compiler here
16:24:02 <edwardk> so i've had some chances to play with it =)
16:24:23 <edwardk> jfischoff: another example that is easier
16:24:26 <edwardk> data Proxy a = Proxy
16:24:34 <edwardk> before ghc would kind default the argument a to kind *
16:24:36 <edwardk> but why?
16:24:40 <edwardk> now it can be any kind
16:24:45 <edwardk> so you can have Proxy Maybe
16:24:47 <edwardk> or Proxy Int
16:24:51 <edwardk> or Proxy (Eq Int)
16:24:54 <jfischoff> ah
16:25:19 <jfischoff> right, it seems like in the  Category (Prod i j) ghc should be able to see that this has the right kind after the application right?
16:25:26 <edwardk> you _had_ to use monomorphization on kinds at awkward times in the compiler before
16:25:41 <jfischoff> after apply the i and j to Prod that is
16:26:32 <edwardk> now it can. you have some fun problems when you go to make constraint categories though
16:26:54 <edwardk> i've had to come up with a mountain of plumbing for dealing with sums and products of constraints, etc.
16:27:51 <edwardk> ghc can figure out the polymorphic kind for class Category just fine from the methods and almost figures out the right kind for Prod i j on its own
16:28:06 <edwardk> there are some kind polymorphic GADTs that need signatures
16:28:09 <thoughtpolice> well, with 7.4 you can have Proxy Maybe etc - you can also do similar and use polykinds for a typeable replacement. but you couldn't say data Proxy (a :: k) = Proxy where 'k' is a kind variable, and that's what was really missing
16:28:16 <thoughtpolice> (edwardk will correct me if i'm wrong :P)
16:28:17 <edwardk> thoughtpolice: yep
16:28:31 <thoughtpolice> the full story hit HEAD last week though, i think simon said in the commit it was the last remaining piece
16:28:37 <edwardk> thoughtpolice: that was what crippled my first foray into using these
16:28:57 <thoughtpolice> yeah i remember you mentioning it in boston. have you been playing with HEAD yet?
16:28:57 <edwardk> i'll have to pull, because i have a whole library that has been waiting to be able to compile ;)
16:29:03 <edwardk> not lately
16:29:09 <edwardk> too hard to keep up on the bleeding edge
16:29:13 <thoughtpolice> i haven't really gotten a chance to play with 7.4 features lately :(
16:29:14 <edwardk> i have packages to maintain
16:29:24 <thoughtpolice> edwardk: with hsenv i build copies of HEAD and try them all the time
16:29:35 <edwardk> i might give that a shot
16:29:48 <edwardk> https://github.com/Paczesiowa/hsenv ?
16:29:52 <thoughtpolice> yep
16:30:17 <thoughtpolice> it's a fantastic tool honestly, it's like cabal-dev but instead it just kind of injects itself into your running shell to set configuration/package paths
16:30:35 <thoughtpolice> so it isolates everything to a directory, but everything 'just works' so you can activate the environment and just say 'ghci', 'cabal install foo', etc
16:30:49 <edwardk> bookmarked. i'll give it a shot tomorrow
16:31:04 <sznurek> Hey, I have a little question: both Network.accept and Network.Socket.accept does reverse DNS lookup, can I disable it somehow?
16:31:21 <blackdog> thoughtpolice: it doesn't interact terribly well with ghc-mod unfortunately (or ghc-mod doesn't interact well with it)
16:31:38 <thoughtpolice> blackdog: i've noticed this. i've managed to get hsenv+ghc-mod working in emacs with all the bells like ghci etc
16:31:42 <thoughtpolice> but it's kind of tricky
16:31:49 <blackdog> oh, really?
16:32:13 <thoughtpolice> yeah, i could spawn GHCi terminals for HEAD, and things like autocomplete of LANGUAGE pragmas etc took HEAD features into account
16:32:15 <blackdog> i've been tempted to work out why, but i have a terrible habit of spending more time on my environment than on working code.
16:32:35 <thoughtpolice> i think the trick is that you have to activate hsenv, install ghc-mod inside the environment, then open up emacs *by itself* and activate the hsenv emacs mode
16:32:39 <thoughtpolice> then you can navigate to a haskell file
16:32:44 <thoughtpolice> and i think the ghc-mod features will work
16:33:01 <thoughtpolice> this does mean you have to have GHC-mod working for HEAD though, i've given kazu a few patches for that before
16:33:19 <blackdog> thoughtpolice: huh. what do you mean by "open up emacs by itself"?
16:33:30 <blackdog> start it from the terminal where you've activated hsenv?
16:33:31 <thoughtpolice> blackdog: i mean don't open a haskell buffer and activate haskell-mode first
16:33:52 <thoughtpolice> just start emacs, do M-x hsenv and point it to the directory, then open a haskell file, and haskell-mod + ghc-mod will kick in
16:33:56 <blackdog> oh, there's an hsenv mode?
16:33:59 <blackdog> i didn't know that
16:34:02 <thoughtpolice> yeah, it's in the source tree
16:34:16 <thoughtpolice> i think it updates all the basic variables inside haskell-mode to point to the localized environment
16:34:22 <blackdog> right. ghc-mod's got some special purpose code for cabal-dev, i think
16:34:34 <blackdog> ok, that could be good
16:34:44 <blackdog> so much duplication :(
16:34:57 <thoughtpolice> blackdog: it doesn't really scale very well though, because when you have say, 5 different hsenv environments, you have to install ghc-mod into each one, and make sure you do the dance in order
16:35:17 <thoughtpolice> i make and destroy HEAD environments pretty regularly to test things, and it's a huge pain
16:36:34 <blackdog> oy
16:37:50 <blackdog> thoughtpolice: it's a bit of a staging mixup, really. if the point of hsenv is to isolate what's needed for your code to be deployed, you don't really want ghc-mod deps mixed up in there too.
16:39:06 <thoughtpolice> blackdog: yeah :/ that's the only way i've ever gotten it to work though
16:39:19 <thoughtpolice> and even then it's really fragile
16:39:38 <thoughtpolice> i just set up ghc-mod for my 'production' system-wide compiler these days, and forgo it for hsenv environments
16:41:17 <adnauseam> is there a way to quickly and easilly transphorm recursive functions into end-recursive functions ?
16:41:21 <thoughtpolice> blackdog: also, IIRC, you're working on the GHC iOS cross compiler correct? i'm keen on trying it here soon, so i may let you know how it goes (i just got a new iDevice i want to play with)
16:41:28 <blackdog> thoughtpolice: nah, that's stephen
16:41:48 <blackdog> i've been trying to get ghc going in a heroku environment
16:42:03 <zachk> heroku?
16:42:22 <blackdog> zachk: hosting system. usually for ruby, but has generic buildpacks now.
16:42:29 <zachk> ah ty
16:42:44 <stephenjudkins> adnauseam: does end-recursive == tail-recursive?
16:42:45 <blackdog> the basic idea is that you should be able to push to a git repo endpoint, and the system builds your binaries and deploys them.
17:29:13 <mae> has anyone successfully got ghc 7.4.2 building with the haskell platform src tar ball 2012.2, i am doing it right now, but was wondering if anyone else has had success here yet
17:38:32 <monochrom> I haven't tried, but apart from needing --enable-unsupported-ghc-version it should be fine
17:47:20 <flazz> i'm reading the Zipper chapter of learnyousomehaskell, the author says that Focus would be a better than than Zipper, does Cursor share the same sentiment?
17:47:54 <SrPx> Allright people, you were right, Haskell is still not for me. I'll come back here in an year as suggested...
17:49:10 <Mortchek> SrPx, seems like an awfully limiting conclusion to come to.
17:50:44 <zachk> SrPx: stay and play around with haskell
17:51:08 <mm_freak> SrPx: i doubt that anyone here actually suggested that haskell is not for you
17:58:58 <SrPx> they said this yesterday...
17:59:06 <SrPx> when I asked about duck typing
17:59:46 <SrPx> but this is true I can't deal with haskell... I'm trying but I can't solve trivial tasks on it
18:00:13 <SrPx> maybe when I have more experience in general I can try again ..
18:00:27 <ion> Duck typing isn’t needed actually.
18:01:55 <Mortchek> Don't type classes solve some of the same problems that duck typing does?
18:02:57 <Mortchek> SrPx, you don't get experience by not doing. If you want to be good at a language, you have to start off doing poorly with it.
18:03:18 <dmwit> Experience is what you have by the time you don't need it any more.
18:03:21 <Mortchek> SrPx, if you have trouble understanding the concepts, *make* yourself understand.
18:04:16 <Mortchek> Rather than say "I can't deal with Haskell", say "I don't know yet how to deal with Haskell".
18:04:23 <Mortchek> The former closes you off, the latter opens you up.
18:05:21 <shachaf> dmwit: I'm pretty sure you *do* need the experience.
18:05:41 <SrPx> Mortchek: no, I'm fine with all the functional concepts. I don't get the typing thing. Or lack of mutability. Or something, I'm not sure what.
18:05:44 <shachaf> Well, FSVO "experience"
18:06:00 <SrPx> Mortchek: perhaps I'm just trying to solve a problem Haskell was not designed for.
18:06:18 <SrPx> Mortchek: I absolutelly fall in love with the way haskell treats functions
18:06:22 <shachaf> Haskell was not designed for: Being like every other programming language you've ever used.
18:06:37 <SrPx> I know. well.
18:06:41 <blackdog> SrPx: what concrete problem were you trying to solve?
18:06:55 <shachaf> SrPx: Do you mean anything other than "the syntax for lambdas"?
18:07:23 <dmwit> shachaf: Well, first-class functions is more than just syntax.
18:07:35 <SrPx> blackdog: some, actually, like creating a particles simulation with attracting particles, and a small game with players that have attributes like HP, mana, exp, inventory (that is a list of items of different types) and so on
18:07:41 <shachaf> dmwit: Yes, but SrPx was talking about the syntax a lot yesterday.
18:07:53 <dmwit> The idea isn't unique to Haskell, but Haskell may be many people's first introduction to the idea.
18:08:07 <Cale> SrPx: Back when I learned Haskell it took me about 2 months before I felt like I could really do real things with it, and about a year to be comfortable. Granted, I had a full courseload at the time, and there weren't as many good tutorials and books back then.
18:08:10 <SrPx> shachaf: well anything? First order functions, list comprehension, currying, and so on
18:08:15 <dmwit> SrPx: That doesn't smell like a list to me.
18:08:29 <Cale> But you should expect quite a bit of discomfort for a while if you're already used to programming in other languages.
18:08:38 <SrPx> dmwit: list, group, array, many languages call it by different names
18:08:42 <dmwit> SrPx: Eh, what language doesn't have first order functions?
18:08:54 <dmwit> SrPx: That doesn't smell like a list, group, or array.
18:08:54 <Mortchek> SrPx, you're probably talking about a tuple. Lists are homogenous.
18:09:53 <SrPx> Mortchek: is not a tuple fixed? (Like, type a, then type b, then type c, then type b... but once you define this is it)
18:09:54 <blackdog> SrPx: for the particles simulation, it may be interesting to look at Manuel Chakravarty's Barnes-Hut n-body simulation
18:10:03 <blackdog> http://drops.dagstuhl.de/volltexte/2008/1769/pdf/08004.PeytonJonesSimon.1769.pdf
18:10:21 <Mortchek> SrPx, a tuple is of fixed length.
18:10:23 <dmwit> SrPx: Yes, that's the idea.
18:10:27 <blackdog> (well, i don't know if it was manuel's work directly, but you know what i mean)
18:10:46 <Mortchek> SrPx, what languages are you used to, by the way? Your nick is familiar and I think I might have seen you in ##javascript.
18:13:36 <SrPx> blackdog: (reading)
18:14:06 <SrPx> Mortchek: dmwit how does haskell represent a collection of different types without pre-defining order or length?
18:14:15 <dmwit> SrPx: It doesn't.
18:14:24 <SrPx> oh sorry
18:14:27 <dmwit> SrPx: And you should feel bad for wanting it.
18:14:29 <SrPx> just asked
18:14:45 <Mortchek> SrPx, can you give an example of when you might want that?
18:14:47 <SrPx> dmwit: but how would I define a "inventory" that keeps track of the player's items? ;s
18:15:00 <SrPx> items can be of different types
18:15:02 <dmwit> SrPx: You would have a single type for items, and keep it as a list.
18:15:02 <Mortchek> SrPx, a list of values of some type Item you define.
18:15:11 <SrPx> hmm
18:15:13 <dmwit> Don't worry, sums are cheap in Haskell.
18:15:18 <SrPx> makes sense
18:15:39 <SrPx> but there is no single example where a collection of different types would be desirable?
18:15:56 <Mortchek> SrPx, well, why don't you give a situation where you might want it?
18:16:06 <dmwit> It happens. But it's very, very uncommon.
18:16:15 <SrPx> dmwit: can you think in an example?
18:16:22 <blackdog> SrPx: sometimes, you might want to loosen it so you could define new stuff at runtime. in the approach dmwit is advocating, your sum type contains all the items you're ever going to be able to have, and adding new item types would require a recompile.
18:16:31 <dmwit> I can think of just one example where it really matters.
18:16:50 <dmwit> xmonad uses existentials to allow a user-extensible sum type for layouts.
18:17:03 <SrPx> Mortchek: I don't know. but I imagine what would happen if later on development I decided that my inventary can hold Players too (maybe a spell will trap a player on a backpack, dunno).
18:17:23 <SrPx> Mortchek: player is very different from item... so I would have to rewrite the whole code?
18:17:29 <blackdog> SrPx: you'd add an arm to the Sum type, and call it TrappedPlayer Player
18:17:39 <dmwit> yes, exactly
18:18:00 <dmwit> And then the compiler tells you all the places you fucked up because you forgot to deal with the new ability to trap players in backpacks.
18:18:41 <SrPx> hmm
18:19:42 <SrPx> I'm not sure... I had really bad experiences on C++ because of things like that... I'm afraid of anything that restricts what I can do.
18:19:47 <SrPx> not haskell's fault
18:20:07 <blackdog> SrPx: you haven't really shown an example where you are restricted yet
18:20:35 <Mortchek> SrPx, the compiler managing that for you is excellent. Would you rather it go uncaught and forget you have to add trapped player handling to your behavior?
18:20:40 <SrPx> I don't know any, like when I coded in C++, I just programmed the whole thing and then realized it would take an enourmous effort to change it.
18:20:56 <SrPx> which is bad for my games because I used to have weekly updates
18:21:00 <SrPx> I just don't know
18:21:04 <SrPx> perhaps there's not this problem at all
18:21:39 <SrPx> Mortchek: which kind of different behavior that would need? :s
18:21:40 <ion> Can you give a concrete example of the kind of thing C++ didn’t allow you to do?
18:21:48 <SrPx> ion: hm yes!
18:22:24 <SrPx> ion: it all happened at least 5 years ago but I'll try to remember some
18:22:36 <ion> srpx: A function that takes an item in the backpack, paints it blue and puts it back into the backpack. Whoops, you didn’t remember to make it handle trapped players. Fortunately the compiler reminded you.
18:23:49 <SrPx> ion: for example I remember I needed to add a game feature which my players could search other players based on certain attributes (like players with exp = 1000, lv = 20, vocation = sorcerer).
18:24:18 <SrPx> ion: on Javascript I could write something like function search(player,key,value), as every player is a hash table
18:24:52 <SrPx> ion: on C++, I was forced to hard-code each possible query, because hp, level, etc, were defined the standard way, class player { int hp; int level } something like that
18:25:12 <SrPx> ion: so whenever I updated the game with a new thign (like, a new skilltype) I would have to modify that definition
18:25:24 <Mortchek> filter (\p -> hp p == 100) players
18:26:00 <ion> stringToLens "hp" = Just hp
18:26:41 <ion> Also, nothing prevents you from using hash maps (but it might not be the best idea in this case).
18:27:07 <Mortchek> Hash maps are also homogenous, no?
18:27:11 <blackdog> SrPx: do you want to allow your players to specify the key and the value, then? if they typo, they expect to just get a null list?
18:27:25 <ion> They can use sum types, too.
18:27:38 <SrPx> again without knowing I can't say for sure. maybe haskell will not torture me like C++ did in so many ways... but I'm traumatized from this. any language feature that puts a limitation scares me, thats it I guess
18:27:50 <SrPx> blackdog: I can check that on javascript
18:27:52 <ion> Haskell certainly doesn’t torture me like C++ does.
18:28:10 <SrPx> blackdog: if (player[key]) { } ...
18:28:34 <blackdog> SrPx: sure, i just mean it's not a case you're trying to guard against - you're happy that they just get no results
18:28:41 <Mortchek> Haskell's "limitations" are a blessing. I love how Haskell tells me immediately that I used a function wrong because I'm using it with the wrong types.
18:28:52 <SrPx> blackdog: no problems ?
18:28:58 <SrPx> blackdog: they would get no results the other way
18:29:02 <SrPx> (hard coding)
18:29:18 <ion> I’m using the Closure compiler and type annotations with JavaScript to get some static checking in it.
18:29:29 <SrPx> Mortchek: this is something I don't quite get too. I never had any kind of problem with that on javascript and python.
18:29:46 <Cale> SrPx: I'm not completely sure I understand what you mean there, but there are plenty of limitations with respect to types in javascript, you just don't get any help from the compiler/interpreter in terms of enforcing them. You have to keep them in your head.
18:29:56 <Mortchek> SrPx, I'm still in the beginner stage so I make lots of mistakes applying functions. :P
18:30:17 <Cale> (and check that your code meets them manually)
18:30:31 <SrPx> Cale: this is okay, I just like freedom. On javascript I programmed a function that game me the oop features I wanted. Because it just don't forces me on any pattern
18:30:44 <Mortchek> Yeah, I usually don't even bother type checking in JS because it would be a pain to check everything. I avoid using type coercion though.
18:30:44 <SrPx> Mortchek: hm
18:31:30 <Mortchek> JS gives you lots of freedom but it also sits back and lets you shoot yourself in the foot.
18:31:48 <Mortchek> Haskell will go "Hey buddy, that Int doesn't fit in there."
18:31:59 <SrPx> Mortchek: but I never really had any problem on it
18:32:23 <Cale> SrPx: It's not so much a problem as a small tax that you constantly pay.
18:32:31 <SrPx> Mortchek: at all, I never had a programming experience as good as the last game I did in js
18:32:38 <SrPx> Mortchek: I just coded, coded, coded... and it worked
18:32:54 <SrPx> Cale: what
18:33:09 <Cale> I find it tiring to program in dynamically typed languages because I *have* to think about the types constantly or else I do stupid things and my programs don't work.
18:33:27 <SrPx> Mortchek: I've done many, maany things that a programmer would shot me for. But it worked. My players liked. So what? :/
18:33:42 <SrPx> Cale: for example?
18:33:59 <Eduard_Munteanu> Yeah, it seems easier when the program "works", but in the end you spend a lot of time debugging various issues.
18:34:00 <SrPx> Cale: what kind of programs are you doing atm
18:34:50 <SrPx> Eduard_Munteanu: maybe it was a lucky first try but the time I spent debugging was negligible. Weird things happened but they were easy to catch just following the code in action
18:34:58 <Cale> For example, putting something of the wrong type into a list by forgetting to apply some conversion function to it, and only having the program choke on it much later in some other part of the program when that value is retrieved.
18:35:23 <ion> srpx: That’s exactly the kind of stuff a statically checking compiler will find for you.
18:35:25 <Cale> and then having nothing but a debugger to trace through the code and hope to find where my mistake is
18:35:48 <Cale> That's a lot worse than just having the compiler tell me the line number on which I made the error before my program even runs.
18:36:06 <Eduard_Munteanu> Not to mention the horribly complicated semantics of dynamic typing, in some cases.
18:36:17 <SrPx> it tells the line it crashed when you are running it, though
18:36:18 <Eduard_Munteanu> Erm, weak typing.
18:36:25 <SrPx> 99% of the times it is pretty obvious where the error is
18:36:34 <Cale> SrPx: That is frequently very far from where the actual bug is
18:36:34 <SrPx> Eduard_Munteanu: for example?
18:36:50 <Ralith> SrPx: as the programs you work on grow, the ease of finding those errors will drop exponentially.
18:36:50 <YayMe> No way, everyone knows dynamic languages are the best thing ever because they increase production like 300%, that is to say, they let people write bad bug riddled software 3 times as quickly as a static language..
18:37:05 <SrPx> Ralith: maybe this is true
18:37:06 <Cale> SrPx: because data structures are often produced and consumed in different parts of the program
18:37:15 <Eduard_Munteanu> SrPx: the implicit conversions and guesswork you get are rules you still have to know
18:37:26 <SrPx> Ralith: this is why I like keep the program as small as possible
18:37:41 <SrPx> Ralith: small sectors everywhere
18:37:44 <Ralith> SrPx: that works nicely if you only ever need to do small things.
18:37:57 <Ralith> some of us aspire to more!
18:38:01 <Mortchek> Ideally a program would be made out of modular parts that are as small as possible. If each part works correctly, you theoretically know that so does the program.
18:38:06 <fayden> well, no, you always want to keep things as small as possible
18:38:13 <SrPx> Ralith: almost every thing you can do I believe can be done in based in the combination of small things. Youre made of atoms ( :
18:38:25 <Ralith> SrPx: combinations of small things are large things.
18:38:29 <SrPx> Mortchek: yes
18:38:33 <fayden> which are still as small as possible
18:38:46 <SrPx> Ralith: but then it will become easy again to find where the error is
18:38:55 <mgsloan> SrPx: and our chips are made of many transistors.  The question is, how was that particular arrangement determined :)
18:39:06 <YayMe> I know javascript has become all the rage, but for some reason people have come to equate that with dynamic languages are better than static ones
18:39:23 <Ralith> SrPx: until you work on a large thing.
18:39:24 <YayMe> which is silly.. not that dynamic languages are inherently bad, they just have a time and a place
18:39:32 <SrPx> if your character started walking backwards and the entire code that affects the walking behavior of your character is well separed from everything else, well, you just found the problem
18:39:49 <Mortchek> I like JavaScript, but its type coercion is extremely silly.
18:40:10 <SrPx> YayMe: while I loved my experience with javascript it has many horrible things . I don't want to make it my #1 language
18:40:11 <YayMe> Mortchek: as do I
18:40:13 <SrPx> I still need that language
18:40:20 <YayMe> right
18:40:27 <YayMe> like I said, dynamic languages have a time and a place
18:40:35 <YayMe> in my opinion, that place is scripting
18:40:44 <SrPx> YayMe: why?
18:40:51 <Mortchek> SrPx, I'm in the process of making Haskell my #1 language whereas JS has been for maybe a year now.
18:40:53 * Ralith suggests that the time is '1970' and the place is 'somewhere far away'
18:41:32 <YayMe> Ralith: yeah, something MANY people these days don't realize is dynamic languages aren't the newer way to do things
18:41:32 <SrPx> YayMe: for example, one could write a dynamic language with a option to warn you of any problem it can find using the most advanced AI, if you just annotate the code properly
18:42:10 <SrPx> YayMe: so that's pretty much it, "forcing" you to something is not better than giving you freedom
18:42:15 <Boney> You know what's a good code annotation!?!
18:42:20 <Boney> A type signature!!
18:42:26 <Ralith> YayMe: hey, at least people are making progress.
18:42:37 <Boney> It's also good, because both the programmer and the compiler can use it.
18:42:40 <SrPx> Boney: yes, then make type signatures a superfitial thing over the language and make an option for them to be ignored on compile time.
18:42:46 <blackdog> SrPx: one thing to keep in mind is that dynamic typing is a subset of static
18:42:53 <SrPx> "forcing" is not better than "not forcing" , right ?
18:42:59 <blackdog> if you want to model everything dynamically, you can do it
18:43:00 <YayMe> anything larger than a script is going to become a brainfuck when it becomes large enough. As someone whose been writing enterprise C# software for years now, and if it didn't have type checking I would have been slamming my dick in a door jam countless times where I hit compile and it tells me I missed a change somewhere up the chain
18:43:03 <SrPx> blackdog: I see it as the opposite
18:43:11 <Cale> SrPx: I'd rather have the types in libraries that I use actually mean something.
18:43:14 <Boney> SrPx: Why should it ignore them?  the point of not writing your types ina comment is so that the compiler can also use them.
18:43:17 <blackdog> but haskell offers you the ability to restrict yourself when you want to do so.
18:43:19 <SrPx> blackdog: static typing is the same as dynamic typing, with some restrictions added
18:43:38 <Boney> firstly, the compiler will use types to catch bugs in your code.  Secondly, they can be used to generate faster code.
18:43:53 <SrPx> Boney: because then if you just wanted to make a small piece of buggy software that just solved a small task your needed for your clients, you could do it in some hours
18:43:56 <Cale> SrPx: Actually, there's more differences than that
18:43:58 <Eduard_Munteanu> Sounds a bit like Erlang's success typing.
18:44:03 <SrPx> Boney: instead of having to write a piece of art software you would only use once
18:44:04 <Cale> SrPx: Do you know about typeclasses?
18:44:14 <blackdog> SrPx: no, that's demonstrably false. you can map any dynamic program directly to a haskell program with the same semantics.
18:44:17 <Ralith> YayMe: I question the assumption that statically typed scripts are inherently inviable
18:44:26 <blackdog> it's ja
18:44:29 <Eduard_Munteanu> (or generally, types as an optional afterthought)
18:44:31 <blackdog> SrPx: it's just not common practice.
18:44:35 <SrPx> blackdog: how?
18:44:42 <Ralith> blackdog: Can you show that?
18:44:42 <Boney> SrPx: I never want to do that. Not ever.  There's Never an escuse for shitty work.  My clients get the best code I can produce (and they can afford)
18:44:46 <SrPx> blackdog: the opposite is true too
18:44:50 <YayMe> Ralith: Me too, I love static typing but I am saying dynamic languages are also viable for scripts
18:44:56 <Ralith> YayMe: fair enough.
18:45:09 <SrPx> Boney: so you just want to write a code that will convert 50 images to black-and-white.
18:45:14 <blackdog> SrPx: no, it isn't. I can't put the same restrictions on a ruby program so that i catch errors at compile time without writing my own type inference engine.
18:45:18 <Boney> SrPx: code is often re-used more thanthe orginal author realizes.
18:45:36 <YayMe> Ralith: My statement is that anything larger than a script in a dynamic language is going to be regretted if you know what it's like to write large static typed software
18:45:36 <SrPx> Boney: you're saying that writting a buggy software that will do it , in 30 minutes, is worse than writting your own photoshop in 30 days before delivering?
18:45:49 <Ralith> YayMe: yeah, I follow you now.
18:45:50 <Boney> SrPx: then I'd write a script using imagemagic,
18:45:50 <YayMe> Mortchek: I actually love javascript for a lot of things and think it's great, but after trying to play with nodeJS I just really couldn't see how I would want to write system software in it
18:45:55 <Boney> SrPx: why would my script be buggy?
18:46:09 <Boney> if it where buggy it wouldn't work.
18:46:12 <SrPx> Boney: buggy I mean just simple
18:46:12 <Mortchek> YayMe, really? Node made JS more exciting for me. What about it drove you away?
18:46:19 <SrPx> Boney: you understand what im talking about
18:46:22 <Boney> SrPx: that's not what you're saying.
18:46:31 <Boney> No I thought you ment that it had bugs in it.
18:46:32 <SrPx> Boney: you don't need to write a piece of art in this case
18:46:36 <SrPx> no no
18:46:39 <SrPx> sorry
18:46:40 <blackdog> SrPx: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Dynamic.html
18:46:41 <Boney> that's what buggy means.
18:46:44 <SrPx> just "lazy"
18:46:48 <Boney> Or a small car.
18:46:49 <SrPx> (not in the haskells meaning of lazy|)
18:46:51 <Boney> :-P
18:46:56 <Iceland_jack> this conversation..
18:47:01 <SrPx> my english vocabulary is VERY limited please be easy with me : s
18:47:03 <shachaf> This discussion is very much not Haskell. :-( Maybe it should be in #not-haskell
18:47:21 <SrPx> this is true...
18:47:23 <Boney> SrPx: ah sorry, The rest of your language seems prefect, so I didn't know.
18:47:26 <SrPx> I have some work to do, too...
18:47:30 <SrPx> but you guys have great points
18:47:36 <SrPx> Boney: o.o
18:47:40 <SrPx> Boney: this is the first time someone says that
18:47:42 <Mortchek> YayMe, maybe we can take it to ##javascript if it's bothering people here. I'm a regular there.
18:48:18 <Cale> SrPx: Typeclasses allow the inferred types in your program determine its behaviour
18:48:32 <Cale> which is something that is not at all easy to do in a dynamically typed setting
18:48:46 <sinelaw> Peaker, you there?
18:48:49 <YayMe> Mortchek: I was just giving my 2 cents :)
18:49:01 <SrPx> inferred types?
18:49:08 <YayMe> Mortchek: Node is exciting for JavaScript, I completely agree!
18:49:14 <SrPx> i know the word infrared
18:49:29 <Cale> SrPx: Well, just the types, but you can allow them to be inferred without having to say to the compiler what the types are
18:49:49 <YayMe> Mortchek: But- as I said, I've been writing enterprise software in C# for years now and I just can't see the serious value of writing system level software in JavaScript
18:49:50 <SrPx> im clueless what you are talking about
18:49:56 <Cale> SrPx: check this out, for example:
18:50:03 <Cale> > read "[1,2,3,4]" :: [Integer]
18:50:04 <lambdabot>   [1,2,3,4]
18:50:12 <Cale> > read "5" :: Double
18:50:13 <lambdabot>   5.0
18:50:16 <Cale> > read "5" :: Integer
18:50:18 <lambdabot>   5
18:50:36 <YayMe> Mortchek: I understand the reason JavaScript was chosen for node was the lack of system level APIs so they could force people to use an asynchronous model, which is great! I completely agree with the value of asynchronous IO, which is one of the big reasons I'm learning Haskell
18:50:37 <Cale> Which parser to use is being determined by which type we're asking for
18:51:07 <SrPx> oh sure
18:51:07 <blackdog> YayMe: well, let's disambiguate that a bit - Haskell IO is synchronous
18:51:11 <SrPx> but...
18:51:25 <Cale> SrPx: and we don't even have to specify what that type is, if it can be determined by context
18:51:32 <blackdog> it's just that threads are super-cheap (at least with GHC), and the runtime manager converts to a polling loop beneath the covers.
18:51:37 <SrPx> can you hack haskells parser?
18:51:42 <YayMe> blackdog: Is it? I had read somewhere under the covers it'll do asynchronous IO, but either way I know you *can* do asynchronous IO with it from what I have read
18:51:53 <blackdog> you really wouldn't want to try that kind of code transformation without a strong type-based guarantee.
18:52:00 <shachaf> YayMe: Under the covers your C programs do asynchronous I/O too.
18:52:18 <blackdog> YayMe: the crucial point is that you can write it synchronously, which is better for understanding than a maze of twisty callbacks.
18:52:18 <YayMe> shachaf: C or C#? and how so?
18:52:34 <shachaf> YayMe: Calls like fread() and fwrite()
18:52:49 <Cale> SrPx: you can add parsers of your own, for your own types
18:52:52 <Ralith> or calls like read and write.
18:52:56 <YayMe> shachaf: I don't write C heh, though I have debated diving into it many times
18:53:03 <shachaf> Ralith: That's not C, that's POSIX. :-)
18:53:08 <Ralith> :P
18:53:10 <Cale> SrPx: (by adding instances of the Read class)
18:53:17 <SrPx> Cale: hmm o.o
18:53:22 <shachaf> YayMe: Fine, your Python or Ruby or whatever programs. Any program on a modern computer.
18:53:26 <SrPx> Cale: really , with any syntax?
18:53:40 <Cale> SrPx: sure, why not? They're just functions String -> a, for various types a
18:53:43 <Ralith> SrPx: Read isn't exactly haskell's parser.
18:53:58 <SrPx> hm
18:54:03 <Cale> Yeah, I assumed he was talking about read, because that's what I was talking about
18:54:15 <blackdog> SrPx: are you talking about loading new code at runtime?
18:54:15 <Ralith> he's also in #lisp, so it pays to be sure.
18:54:45 <Ralith> (for the uninitiated, in lisp you can modify the syntax that the compiler processes)
18:55:16 <YayMe> blackdog: You can do non-blocking IO in haskell, no?
18:55:33 <Cale> YayMe: Just use threads :)
18:55:42 <dmwit> You can, but why bother when GHC's threads are so cheap?
18:55:45 <SrPx> again I think I already asked about that, sorry... how would one make this in haskell? http://pastebin.com/DKQ72fKX (any absolutely remote chance one of you guys would be super awesome and translate it?)
18:55:47 <mauke> The paste DKQ72fKX has been copied to http://hpaste.org/70501
18:55:48 <Ralith> YayMe: haskell has a FFI, so you can do whatever you like.
18:56:00 <SrPx> blackdog: nono
18:56:03 <Cale> YayMe: In GHC, the IO primitives are pretty much all defined in terms of non-blocking stuff.
18:56:09 <YayMe> Cale: I do plenty of that in C#, but the other bonus in haskell is the code purity means I don't have to worry about locking mechanisms
18:56:15 <shachaf> Cale: But the interface is blocking.
18:56:20 <Cale> right
18:56:22 * hackagebot google-html5-slide 0.1.1.0 - Google HTML5 Slide generator  http://hackage.haskell.org/package/google-html5-slide-0.1.1.0 (HideyukiTanaka)
18:56:27 <dmwit> data Player = Player { hp :: Int, pos :: [Int], items :: [String] }
18:56:43 <dmwit> damage p dmg = p { hp = hp p - dmg }
18:56:49 <SrPx> blackdog: i was talking about what cale said about modifying the parser for your own types
18:56:50 <dmwit> etc.
18:57:11 <Cale> SrPx: you add parsers for your own types by writing instances of Read
18:57:18 <YayMe> Cale: But what does that mean that the interface is blocking and the GHC is non-blocking ? Does that just mean that the call to IO is made and under the covers the runtime does whatever other work is available in that space and comes back to it like a continuation?
18:57:21 <Cale> In the Prelude, we have:
18:57:28 <Cale> (something like)
18:57:29 <blackdog> YayMe: no. that thread blocks.
18:57:33 <Cale> class Read a where
18:57:36 <SrPx> dmwit: p { hp = hp p - dmg }
18:57:39 <SrPx> dmwit: what
18:57:40 <Cale>   ... other stuff ...
18:57:48 <blackdog> whenever you have more work to do that you think you might like to parallelise, forkIO off another thread
18:57:48 <Cale>    read :: String -> a
18:57:59 <blackdog> they are cheap as chips, so it's fine.
18:58:00 <Ralith> SrPx: haskell record syntax.
18:58:18 <monochrom> my multi-thread programs use very few locks, and they're really MVars (1-place message queues), easy to reason with
18:58:32 <blackdog> YayMe: .. actually, maybe that's what you meant and i misread you.
18:58:43 <YayMe> blackdog: right, well either way- like I said I am choosing to learn ahskell because of it's ability for concurrency. Even if the threads weren't free, the purity makes concurrent code way easier to write
18:58:47 <Cale> SrPx: That means the record which is the same as p except with the hp field set to  hp p - dmg
18:58:53 <SrPx> damage p dmg <--- declaring a function... p { hp = hp p - dmg } <--- set player's hp to player's hp - dmg
18:59:03 <Ralith> YayMe: you could just write pure code in your home lang :P
18:59:25 <SrPx> no wait
18:59:26 <dmwit> SrPx: correct
18:59:34 <YayMe> Ralith: Try writing stateless code in C# and then trying to tell the people around you that the immutability is a good thing
18:59:35 <Ralith> SrPx: not set; create a player with the modified value.
18:59:38 <dmwit> (pedantically: return a new player with less hp)
18:59:47 <Ralith> YayMe: well, you could do it in *theory* :D
18:59:49 <SrPx> Ralith: but then it'll not copy the original players pos etc
18:59:50 <monochrom> could, but without a library full of immutable data structures, it is difficult
19:00:04 <Ralith> SrPx: it does, that's what the record syntax is for.
19:00:11 <Cale> SrPx: yes it will, that's what that means
19:00:12 <blackdog> Ralith: and you pay the price without getting all the benefits
19:00:19 <SrPx> oh got it
19:00:36 <Ralith> blackdog: I'm not sure I'd call it a price.
19:00:37 <Cale> SrPx: If p is some record, then  p { foo = bar }  is the same as p except with the foo field set to the value bar
19:00:38 <SrPx> p { a = b } ... new player with a = b and everything else the same as 'p'
19:00:40 <SrPx> right?
19:00:44 <Cale> yaeh
19:00:46 <SrPx> Cale: ( =
19:00:49 <SrPx> this is nice
19:01:06 <SrPx> really nice
19:01:10 <SrPx> hmm
19:01:13 <YayMe> Ralith: Of course heh, but even still it would be super easy for me to make a mistake and miss immutability somewhere, moreover the garbage collector in C# is absolutely not tuned to have every object being immutable
19:01:14 <blackdog> Ralith: oh, come on. let's be real: it is occasionally annoying to have to recast things in immutable form.
19:01:19 <monochrom> with multi-thread, you really want to "create a new record" rather than "mutate a bunch of shared variables"
19:01:30 <Ralith> blackdog: yes--occasionally!
19:01:37 <Ralith> not generally.
19:01:58 <SrPx> but guys can you program big systems with haskell? do all of you make haskell your first language? also... can haskell access libraries from other languages?
19:01:59 <Ralith> YayMe: that's a good point.
19:02:08 <blackdog> Ralith: so that's the price. it's usually worth paying, especially when you get all the benefits
19:02:09 <Ralith> SrPx: haskell has a FFI.
19:02:22 <SrPx> lmgt
19:02:29 <monochrom> I was born decades before haskell. it cannot be my first language.
19:02:30 <blackdog> SrPx: the haskell FFI is the nicest one I've used, I think. Ruby's is a pain in the arse.
19:02:40 <ion> Yes, Haskell’s FFI is excellent.
19:02:41 <shachaf> blackdog: The C++ one is pretty good.
19:02:45 <Ralith> hah
19:02:51 <Ralith> it's true
19:02:52 <ion> bindings-DSL make it even nicer.
19:03:10 <blackdog> shachaf: ha. that's just C with an accent...
19:03:15 <monochrom> that is against my will, of course :)
19:03:21 <shachaf> blackdog: Not really...
19:03:25 <YayMe> Ralith: Can you speak to me of the FFI a touch? Precisely- it is interoperability where haskell exports? or is it imports? is it both? which binding types does it export? Does it export in-line code?
19:03:29 <monochrom> Ć <-- C with an accent
19:03:32 <YayMe> err import in-line code rather
19:03:43 <shachaf> YayMe: Yes.
19:04:02 <Ralith> YayMe: afaik, haskell's FFI extends to allowing you to call out to C libs.
19:04:02 * monochrom should create a programming language and call it Ć to annoy the hell out of ascii zealots!
19:04:03 <SrPx> I didn't know it existed, interesting, I'll take a read on that (no idea of how to phrase this last sentence sorry for the lazyness)
19:04:21 <dmwit> The FFI provides both exports and imports.
19:04:27 <blackdog> YayMe: if you want to call macros, you have to wrap them in a function first
19:04:30 <blackdog> which is annoying sometimes
19:04:33 <dmwit> It supports about a dozen basic C types (including pointers).
19:04:39 <dmwit> ?where ffi
19:04:39 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/haskellch8.html
19:04:40 <SrPx> what are some haskell downsides?
19:04:42 <YayMe> blackdog: But you can do it with FFI? That's interesting
19:04:46 <Ralith> dmwit: you can write a haskell lib that can be compiled to a library that can be used by a C program?
19:04:52 <dmwit> Ralith: yes
19:04:55 <Ralith> awesome!
19:05:09 <Ralith> where can I find docs for that?
19:05:16 <dmwit> In fact, it's basically required to do that when using any serious C library (though you might not think it!).
19:05:21 <shachaf> SrPx: Joining a channel and sayng "justify your existence for me please" is not considered very polite.
19:05:27 <YayMe> dmwit: Can you use FFI to import .net code through an interop lib? I don't know precisely what type of binding .net interops can export- I know they can import a variety..
19:05:30 * Ralith indeed does not think that
19:05:36 <dmwit> For example, any C library that uses callbacks: you must export your Haskell code into a C function pointer.
19:05:36 * Ralith would be interested to be proven wrong
19:05:38 <SrPx> dotnet 	Calling convention of the .net platform jvm 	Calling convention of the Java Virtual Machine  õo
19:05:46 <Ralith> dmwit: um, that isn't the same thing.
19:05:48 <SrPx> shachaf: what man?
19:05:55 <dmwit> YayMe: If you can access it from C, you can access it from Haskell.
19:06:00 <dmwit> Ralith: I know it's not.
19:06:08 <dmwit> Ralith: But the answers I gave you are correct nonetheless.
19:06:13 <Ralith> :P
19:06:28 <blackdog> SrPx: at the risk of self-promotion, I did a set of slides on some downsides of haskell in prod at http://mwotton.github.com/hs_gbu/
19:06:37 <Ralith> dmwit: to be certain--I can compile some haskell code into a .so which exports symbols conforming to the C ABI?
19:06:46 <blackdog> they're not insoluble, mostly it's just engineering time that's needed
19:06:57 <SrPx> shachaf: I'm really not acostumed with that culture where everything could be taken in offense. things are not like that where I live. please sorry if I sound umpolite sometimes. it is by no means my intention
19:07:04 <dmwit> Ralith: Read the FFI doc. It tells exactly what you must do to use Haskell code from C.
19:07:22 <blackdog> Ralith: you have to call an init function to set up haskell first, but otherwise you're home and hosed.
19:07:30 <Ralith> sweet.
19:07:33 <Ralith> thanks!
19:07:50 <monochrom> hosed? that sounds bad :)
19:08:41 <monochrom> ok, that kills the conversation
19:09:04 <YayMe> Reads like the only export for .net assemblies is com
19:09:41 <YayMe> they can import C bindings so they could import haskell, but they can't export to it unless the FFI can import COM which I would think to be odd unless I misunderstand COM
19:10:13 <dmwit> I think there are three or four bitrotted attempts at .NET binding.s
19:10:49 <SrPx> blackdog: wow
19:11:16 <SrPx> blackdog: eh how do I read it?
19:11:34 <blackdog> SrPx: hit right
19:11:43 <SrPx> =]
19:11:46 <blackdog> a surprising number of people got caught on that... :)
19:12:14 <SrPx> http://i.imgur.com/2nYnd.png lol
19:12:42 <blackdog> *grin* it was deliberately a bit provocative.
19:14:57 <SrPx> but you pointed that eng. time is just what's needed
19:15:11 <SrPx> this is the most important thing for me sadly ) =
19:15:20 <blackdog> SrPx: I mean engineering time on the core platform
19:15:23 <blackdog> not for the dev
19:15:31 <SrPx> oh I see
19:15:57 <blackdog> it's sort of an untapped niche for haskell. there are a few people doing web stuff on it, but nowhere near the torrents of rails guys.
19:16:08 <blackdog> so some of the patterns aren't as well established yet.
19:16:22 * hackagebot HOpenCV 0.1.2.3 - A binding for the OpenCV computer vision library  http://hackage.haskell.org/package/HOpenCV-0.1.2.3 (NoamLewis)
19:17:51 <YayMe> blackdog: Dig the slides.
19:18:19 <YayMe> blackdog: And speaks precisely to what I'm seeing as I'm learning it, so I'm not nuts
19:18:33 <YayMe> Well, I'm probably nuts but that's a separate problem
19:23:14 <SrPx> Alas, this may lull you into a false sense of security ("it compiles, so it must work correctly"), especially after you spend hours trying to satisfy the compiler (think of higher order functions taking higher order functions as arguments - see below for a simple example).
19:23:16 <YayMe> Would learning all the different formal combinators (S K I, whatever others I see people mention) make me a better haskell developer?
19:23:28 <SrPx> (this is not about haskell /\ but ocaml)
19:23:42 <koninkje> YayMe: not in the short run, IMO
19:23:56 <SrPx> haskell is not like that, right?
19:24:09 <koninkje> maybe in the long run, but only because it's another way of understanding how all the logic/calculi fit together
19:24:18 <copumpkin> SrPx: neither is ocaml
19:24:22 <dmwit> SrPx: Bugs happen.
19:24:30 <dmwit> Anybody who tries to tell you otherwise is lying.
19:24:32 <dibblego> YayMe: learning S, K and I (or SKI combinator calculus) is useful mostly because it is interesting in terms of its implications -- making you a better programmer in general
19:24:40 <dmwit> Types help a lot.
19:24:42 <koninkje> yeah
19:24:46 <SrPx> everyone says a different thing for me ) ;
19:24:49 <YayMe> SrPx: and a dynamic language will give you no sense of security or security, and again- writing C# for years now I can say the "spend hours trying to satisfy the compiler" would only be something someone who doesn't know the language does
19:24:49 <dmwit> Anybody who tells you otherwise from that is also lying.
19:25:01 <copumpkin> SrPx: perhaps you should try being less opinionated when first learning something, and approach it with an open minded :)
19:25:04 <copumpkin> -ed
19:25:10 <SrPx> YayMe: after years you don't get that anymore?
19:25:18 <YayMe> Fuck no.
19:25:39 <SrPx> copumpkin: I do, just not sure what learn
19:25:48 <dibblego> that lying (types help a lot) may be unintentional, but the extent to which it is wrong, makes it a lie and a dangerous one
19:26:02 <SrPx> know im being a bit unconf but this will be my 8th language or so and I still didnt find one that i could use for the rest of my life
19:26:20 <SrPx> for everything
19:26:45 <blackdog> dibblego: what do you mean?
19:26:47 <YayMe> It maybe takes a month to learn to satisfy the C# compiler- C# and similar imperative languages are so effing simple in their syntax and the possibilities they give to you, if you can't easily write compilable code you might need to rethink something.
19:26:58 * koninkje still uses Perl and Bash for whack-a-mole scripting
19:27:28 <YayMe> dibblego: Yeah, I was reading through some of it earlier and got that sense, but thought I'd ask in here if anyone can say that is true or if it actually won't give much benefit, because it looks really bloody hard to try and practice working with the combinators
19:27:30 <dibblego> blackdog: "<dmwit> Types help a lot. <dmwit> Anybody who tells you otherwise from that is also lying." Some people seem to think lying requires intention to deceive -- this is not even false
19:27:49 <blackdog> SrPx: one of the habits you start falling into is programming into the type system - you think about your system, and structure types so that you can't even represent broken situations
19:27:49 * liyang wrote a sed script the other day to de-literatise some .lhs files.
19:28:10 <dibblego> people who say "negate(Types help a lot)" may have no intent to deceive, but they are still lying
19:28:24 <koninkje> YayMe: I wouldn't worry about combinator calculi until you're comfortable with normal Haskell
19:29:28 <SrPx> hmm
19:29:43 <edwardk> dibblego: oh, you mentioned the jquery is a monad idiot replied, but i forgot what you said he said
19:30:18 <dibblego> edwardk: tl;dr "oh I'm not going to write that book anyway" -- my private thought is "then why can I buy it right now?"
19:30:22 <YayMe> Am I wrong to feel that Haskell as a language gives a great deal more syntactic pieces to the developer than the C/C++/C#/Java style languages?
19:30:29 <edwardk> dibblego: hah
19:30:32 <YayMe> I agree completely to Haskell's conciseness absolutely
19:30:53 <koninkje> YayMe: not really. Haskell's *syntax* is extremely minimal
19:30:55 <YayMe> I just feel the language has so many more inherent pieces it gives for you to have to learn and know
19:30:56 <dibblego> YayMe: haskell has far less syntax than all of those if that's what you mean
19:31:11 <koninkje> There are a good deal of infix operators, but those can be defined in libraries
19:31:17 <YayMe> dibblego: Exactly what I mean. Must just be that I learned the C syntax 15 years ago
19:31:18 <dibblego> YayMe: the concepts used to write haskell are quite different though -- maybe you mean that
19:31:56 <YayMe> dibblego: No- I mean the syntax, I was curious if others felt the same about the syntax or it's merely my perception because of how foreign it is
19:32:01 <blackdog> koninkje: well, there's let vs where, and indentation vs {, }, ;
19:32:28 <dibblego> I'd say that it is foreign is leading you to think it has "more syntax", but actually, it's the concepts that are foreign and it has less syntax
19:32:35 <koninkje> blackdog: yeah, and?
19:33:11 <blackdog> koninkje: saying there's some syntactic redundancy. not a lot.
19:33:24 <koninkje> I didn't say anything about redundancy
19:33:39 <YayMe> in C you have basically... if/else/for/while/switch/case/{}/[]
19:33:42 <koninkje> Also, let vs where isn't redundancy per se; they have different scoping behavior
19:33:44 <blackdog> koninkje: if something is minimal, then it has no redundancy, no?
19:34:00 <YayMe> It just feels like haskell has all of thos and many more pieces
19:34:15 <koninkje> blackdog: I wouldn't say that
19:34:37 <YayMe> but I'm sure it's just my perception
19:34:49 <blackdog> koninkje: minimal = nothing can be taken away, no?
19:35:14 <koninkje> blackdog: nothing can be taken away /= nothing is duplicated
19:35:16 * blackdog just noticed his habit of appending ", no?" and wonders if other people find it as annoying as he does
19:35:30 <koninkje> blackdog: also, you're confusing mathematical terminology with the everyday meaning
19:35:47 <YayMe> blackdog: you're talking semantics, what he meant was less than other languages
19:36:00 <YayMe> :P
19:36:17 <blackdog> sure, but it's on a continuum. minimal might be scheme, or forth
19:36:25 <shachaf> You can't talk about semantics in here! This is #haskell!
19:36:26 <YayMe> Anyway, I'm going to play minecraft and hope not to have any horrible haskell dreams tonight like i did the whole first week I was learning it
19:36:39 <blackdog> shachaf: quotebait!
19:37:02 <YayMe> dreaming in code is annoying normally, but dreaming in code when you don't even understand the language... that first week blew
19:37:27 <dmwit> YayMe: I dunno. In C, ++, --, +, *, /, etc. are all syntax. In Haskell they're just functions.
19:37:30 <dmwit> function names
19:37:31 <YayMe> at least now when I'm dreaming in haskell my dreams are able to create accurate comprehensible constructs
19:38:12 <shachaf> dmwit: Let's see you implement postfix ++ in Haskell!
19:38:56 <dmwit> :t ("what's so hard about that?"++) -- ;-)
19:38:57 <lambdabot> [Char] -> [Char]
19:39:07 <dmwit> :t (Sum 1++)
19:39:08 <lambdabot>     Ambiguous occurrence `Sum'
19:39:09 <lambdabot>     It could refer to either `Control.Monad.RWS.Sum', imported from Control.Monad.RWS
19:39:09 <lambdabot>                           or `Data.VectorSpace.Sum', imported from Data.VectorSpace
19:39:17 <dmwit> booo
19:39:30 <shachaf> dmwit: I mean the behavior of C postfix ++
19:39:32 <shachaf> Not the syntax.
19:43:43 <parcs`> > let (++) = (+1) in let a = 5 in (a++)
19:43:45 <lambdabot>   6
19:44:35 <dmwit> let (++) = modifyIORef (1+)
19:45:05 <dmwit> let (++) x = do { vx <- readIORef x; writeIORef (vx+1); return vx }
19:46:10 <parcs`> let (++) = (`atomicModifyIORef` (join (,) . (+1)))
19:47:07 <ion> Is ++ in C specified to be atomic, btw?
19:48:20 <dmwit> I'm pretty sure that no.
20:05:31 <LevineamStart> http://pastebin.com/cRfaRT88   Hi guys , i am trying to change second part of the code(namely b and c )...can you maybe help me ?
20:05:33 <mauke> The paste cRfaRT88 has been copied to http://hpaste.org/70502
20:06:19 <dmwit> What goes wrong when you try to change it?
20:06:52 <hpaste> irene-knapp pasted “Presented for the approval of the Midnight Society” at http://hpaste.org/70503
20:06:58 <irene-knapp> just so you can share my horror
20:07:12 <irene-knapp> first one to tell me what's horrifying about it wins a karma point
20:07:30 <irene-knapp> (besides that it's not done yet)
20:08:13 <LevineamStart> dmwit: well thats the problem dude, i cant change very well....
20:10:33 <gwern> irene-knapp: are you afraid of the list?
20:10:53 <irene-knapp> I'm afraid of something about the list, yes
20:10:58 <irene-knapp> what it represents, you might say :)
20:11:11 * gwern is struck by how many entries map to the same ''
20:11:24 <irene-knapp> oh, those are the ones I haven't finished
20:11:37 <gwern> so that wasn't the horrifying part? darn
20:11:46 <irene-knapp> time's up
20:11:48 * gwern relinquishes the flashlight
20:11:56 <irene-knapp> haha!  at least you got the reference
20:12:15 <irene-knapp> it's horrifying because it's an attempt to make rules for using Unicode quotation marks to delimit string literals
20:12:20 <dmwit> LevineamStart: Well, you'll have to ask a better question than that if you want help.
20:13:13 <gwern> irene-knapp: that doesn't seem to horrifying. more nesting ability seems nice
20:13:23 <irene-knapp> an inherently impossible task for a number of reasons, but anyway the key is the left-quote codepoint and the value is the list of the right-quote codepoints that can balance it
20:13:31 <irene-knapp> yeah, it seems worth doing imo
20:13:37 <irene-knapp> given the larger goals of the language it's for
20:13:58 <LevineamStart> dmwit: thx anyway
20:14:01 <irene-knapp> but it's annoying because for example guillemets (angle brackets) point outward in some languages and inward in others :)
20:14:10 <gwern> more flexibility!
20:14:10 <irene-knapp> and there's German and Swedish which use low-then-high
20:14:12 <irene-knapp> and so on
20:14:13 <irene-knapp> but yes
20:15:59 <gwern> ah, I remember _Are You Afraid of the Dark_. one of the vampire episodes was why I slept for years with my favorite blanket wrapped around my neck. you can guess why.
20:16:14 <irene-knapp> haha, yes
20:17:03 <gwern> a little tempted to torrent it but... childhood shows are best not rewatched
20:17:18 <irene-knapp> yeah, indeed
20:28:40 <gurrag> how does the compiler know the difference between a datatype and a function?
20:29:00 <startling> gurrag, it finds the definition
20:29:32 <startling> gurrag, well, it'd help if you clarify what you mean by "datatype"
20:29:52 <ion> Types are to the right from ::, values (like functions) are to the left. ;-)
20:29:59 <rwbarton> sounds like the setup to a joke
20:30:08 <gurrag> I'm watching the Haskell Amuse-Bouche, wherein is mentioned a line DropOne (Link first rest) = rest
20:30:14 <dibblego> 7
20:30:32 <startling> gurrag: mhm. and?
20:30:59 <gurrag> so you have to know the rest of the code to see that List in that case is a datatype and not a function that takes 2 arguments?
20:31:00 <Cale> gurrag: If you're referring to data constructors (the things which are pattern matched against), then capitalisation distinguishes them from other values syntactically
20:31:12 <gurrag> Ah, thanks
20:31:21 <rwbarton> right, in fact it should probably be dropOne (Link first rest) = rest
20:31:22 <Cale> (they're not types though, they're values)
20:31:36 <dibblego> note also that "a function that takes 2 arguments" is an approximation -- actually, all haskell functions take 1 argument
20:31:46 <gurrag> oops, it was dropOne rwbarton
20:32:12 <rwbarton> > let Just x = x in x
20:32:13 <lambdabot>   Occurs check: cannot construct the infinite type:
20:32:13 <lambdabot>    t = Data.Maybe.Maybe t
20:32:27 <rwbarton> > let (_:x) = x in x
20:32:31 <lambdabot>   mueval-core: Time limit exceeded
20:32:34 <ion> gurrag: I take it you're referring to "Link"? It's not a type.
20:32:42 <gurrag> Data class, sory
20:32:50 <gurrag> sorry*
20:33:03 <rwbarton> It's actually called a data constructor
20:33:07 <startling> gurrag: it's not a "Data class" either
20:33:15 <dibblego> Data.Maybe.Maybe is a data type in the module name Data.Maybe
20:33:15 <startling> gurrag: its a function that makes a thing of a certain type
20:33:24 <startling> (kind of)
20:33:45 <startling> sometimes the type has the same name as the function, but they're separate entities to the compiler
20:34:31 <ion> data Foo = Bar  -- Foo is a type, Bar is a value and can also be used in patterns. A.k.a. a data constructore. Foo and Bar are in completely different namespaces.
20:34:41 <ion> constructor
21:19:09 <djahandarie> Hmmm... I want something like a Data.Map with two seperate keys -- I want O(log n) on both split and lookup for both keys. I.e., split1, lookup1, split2, lookup2, or whatever. One could imagine other interfaces to it as well
21:19:25 <djahandarie> Does that exist? Or is there an easy way to make Data.Map do that?
21:20:29 <djahandarie> (Use case: just a normal map, but I want to be able to efficiently "expire" old entiries)
21:22:36 <Boney> djahandarie: first thing I think of is an artificial key, create some new type Key Int
21:22:46 <Boney> use that to index a map that is Map Key MyData
21:22:54 <Boney> then use two maps to lookup that map.
21:23:08 <Boney> Map FirstKey Key
21:23:13 <Boney> and Map SecondKey Key
21:23:32 <Boney> so it's 2* O(log N)
21:23:45 <djahandarie> You'd need O(n) to split, wouldn't you?
21:23:46 <Boney> but it's easy.
21:23:56 <Boney> oh sorry, I wasn't paying attention to split.
21:24:27 * Boney goes back to not being distracted by IRC.
21:24:34 <djahandarie> I really just need lookup on one key, and split on the other, for this specific use case.
21:24:54 <djahandarie> I have an idea of how to build a structure from scratch that would do this, but seems like a pain in the ass
21:25:32 <Boney> Hrm, Map SplitKey Data  and Map IndexKey SplitKey ?
21:26:19 <Boney> provided that when you want to insert you can generate a new split key. (which if this is for expring things, a monotonic counter would be fine.
21:26:51 <Boney> hrm, I guess you want to clean up the Index map.
21:26:53 <Boney> yeah I dono.
21:30:50 <djahandarie> Oh, I think I might be able to build a fancy Key which does what I want it to.
21:37:50 <djahandarie> Well, it's hardly a general solution, but I can maintain keys of  int_time*2^32+ip_hash  , and since I'm only going to have around 10 seconds worth of backlog, given an IP, I can do only 10 lookups to see if its in the map or not. Naturally, split will work since it's ordered by time.
21:38:37 <djahandarie> (Using time as the expiry method, and IPs are my real keys.)
21:39:57 <djahandarie> (This solution is naturally exploiting that my real key domain is finite, and that my backlog isn't that big.)
21:44:15 <djahandarie> Can fit it into a 64 bit int too, if I use a custom representation of time. Yeay. Should be reasonably fast.
21:46:18 <copumpkin> djahandarie: can't you just have a map + a queue?
21:58:13 <djahandarie> copumpkin, the immediate way I think of using a map+queue results in an O(n*log n) split for the map. What are you thinking of?
21:58:27 <copumpkin> oh, you need to split it?
21:58:38 <copumpkin> nevermind then :)
21:58:44 <djahandarie> Well, I need to expire old entries in the map. It's essentially a split, isn't it?
21:59:09 <djahandarie> Guess I shouldn't be calling it a split anymore.
21:59:22 <djahandarie> So no, I don't need to split it.
22:00:12 <djahandarie> But I do need to remove a bunch of entries from the Map somehow, and just finding all the entries to remove via the queue, then removing them from the Map would be O(n*log n)
22:00:32 <djahandarie> In the end, I need to somehow order the data in the Map itself such that I can get rid of a lot of it quickly
22:02:48 <djahandarie> I don't think it's possible to add any sort of structure onto a stock Map in order to solve this problem. Need to mess with the data structure itself to get the solution to the general problem I asked earlier, probably
22:40:22 <enko> this is the only language i know where learning it drunk is easier
