00:01:08 <aleator_> Well, that is the actual question. I can't find a way to use ghc-api to check if a value has a show instance, so, I try to typecheck the above. If it fails, then, it doesn't.
00:01:34 <shachaf> Oh, so it is the actual question. :-) OK.
00:01:58 <aleator_> Also, doing "show ("++x++")" doesn't work for "1+"
00:02:52 <shachaf> aleator_: That sounds like a dangerous way of type-checking user-input code.
00:03:16 <aleator_> shachaf: Yep.
00:03:48 <shachaf> If this is definitely how you're going to do it, something like "let it = ... in show it" might work a bit better.
00:04:23 <aleator_> I just can't navigate the maze of ghc-api to get a global `InstEnv` which would possibly contain the right info
00:04:49 <aleator_> shachaf: Ah. I'm silly. Of course that is way better.
00:06:34 <aleator_> I'm pretty sure that all the information is in TcGblEnv since the typechecker obviously can decide these..
00:13:19 <cheater> is there a function that catches any exception and returns True or False based on whether the exception happened or not?
00:15:41 <aleator_> cheater: e2b op = catch (op >> return True) $ \ (_ :: SomeException)) -> return False ?
00:16:40 <cheater> interesting, thanks
00:18:21 <Cale> http://www.twitch.tv/cronikeys -- glitching Super Mario World for fun and profit(?)
00:19:14 <Cale> (the glitch she's doing works on console, but often crashes her emulator)
00:20:12 <shachaf> Cale: You should be in #-blah!
00:20:25 <shachaf> They're having an oh-so-exciting discussion about Unicode vs. ASCII in there right now.
00:20:37 <Cale> lol
00:20:54 <Peaker> heh, I only mind the Unicode because it excludes me from reading interesting code :(
00:21:42 <aleator_> I'm piqued. Where does the ghc typechecker stash information about global instances?
00:22:13 <fabjan> Peaker: excludes? Are you missing fonts?
00:22:30 <shachaf> fabjan: This discussion is restricted to #-blah.
00:22:36 <fabjan> right
00:23:06 * hackagebot digestive-functors 0.4.1.1 - A practical formlet library  http://hackage.haskell.org/package/digestive-functors-0.4.1.1 (JasperVanDerJeugt)
00:36:02 <yitz> aleator_: all instances are global. what do you mean by "stash"?
00:36:16 <yitz> ah didn't see your comments above
00:39:36 <Gx4> hello :)
00:41:33 <yitz> aleator_: so your question is, given a type and a class, what function do you call in the GHC API to check whether that type has an instance of that class?
00:42:13 <yitz> hi Gx4
00:42:18 <cheater> has anyone read this? http://haskell.cs.yale.edu/?page_id=276
00:42:25 <shachaf> yitz: Well, a value and a class. But I assume the value->type part is taken care of here?
00:42:28 <cheater> "Haskell school of music"
00:44:04 <yitz> shachaf: oh a value? i assumed aleator_ meant an expression. so you type-check it first to get its type.
00:44:23 <shachaf> yitz: Oh, true, expression.
00:44:41 <yitz> shachaf: a value - in the runtime? then no, it might be very hard to find out anything about types and classes.
00:44:52 <yitz> oh ok an expression.
00:48:57 <Kashyap_> Folks .... I have a question ... why is this ambiguity allowed - main = do      x <- readLn :: IO Int      x <- readLn :: IO Int      putStrLn (show x)      return ()
00:49:13 <Peaker> Kashyap_, what ambiguity?
00:49:21 <Peaker> Kashyap_, you mean the same program without the type signatures?
00:49:34 <augur> Kashyap_: main is always IO () afaik
00:49:35 <Kashyap_> I mean ... use of x twice
00:49:44 <augur> er
00:49:47 <shachaf> Kashyap_: It's shadowed.
00:49:54 <augur> oic
00:50:05 <shachaf> Kashyap_: After the second line there's no reference left to the first x.
00:50:11 <Kashyap_> yeah .. but is it not misguiding?
00:50:14 <Peaker> Kashyap_, \x -> \x -> ... x ...        always uses the inner 'x'
00:50:16 <shachaf> They're two different variables which happen to share the same name.
00:50:22 <Peaker> Kashyap_, GHC will give you a warning about it being misguiding
00:50:24 <shachaf> Kashyap_: Sometimes! Which is why ghc -Wall will warn about it.
00:50:30 <Peaker> Kashyap_, "Warning 'x' is shadowed .."
00:50:33 <Kashyap_> oh cool ... let me try
00:50:58 <Kashyap_> oh cool ... that is what I was looking for
00:51:21 <Kashyap_> I mean ... as long as there is a way for automatically detecting a possible unintended activity
00:51:33 <shachaf> "Warning: unintended activity detected"
00:51:51 <Kashyap_> Is there a way to make -Wall mentioned in the Haskell file itself
00:51:56 <Peaker> -Wunintended-activities is needed too for that
00:52:07 <Peaker> Kashyap_, Without -Wall, some really hazardous situations are ignored by ghc
00:52:08 <shachaf> Kashyap_: {-# OPTIONS_GHC -Wall #-} might do it.
00:52:21 <shachaf> Kashyap_: But it should probably be part of your build system?
00:52:21 <Peaker> I think "OPTIONS" works too, not sure what is better, I use OPTIONS
00:52:22 <yitz> put it in the cabal file
00:52:23 <shachaf> I don't know.
00:52:33 <shachaf> Peaker: I think OPTIONS is considered deprecated or somethin'.
00:53:04 <yitz> but then that forces other people to use it who may not want it
00:53:17 <Kashyap_> It seems to work in the latest platform - 7.4.1
00:54:01 <Kashyap_> well ... I ran into this when I was attempting to do an EDSL for generating webapps ... I want to claim that the EDSL will catch most of the bugs for you :)
00:54:08 <Kashyap_> at compilation that is
00:54:20 <shachaf> Kashyap_: -Wall will be necessary in the file that generates the warnings, not in the libraries that it uses.
00:55:02 <Kashyap_> shachaf - oh!! .. that would not cut it then ... I mean, I'd just have to put it in the documentation then
00:55:54 <Peaker> Kashyap_, that's the goal of multiple web frameworks in Haskell already, too, have you checked them out?
00:56:19 <Kashyap_> Indeed ... yesod is on top of my list for that
00:56:38 <Kashyap_> What I am attempting to do is just illustrate how easily once can develop an EDSL
00:57:22 <Kashyap_> I am planning to take a very simple case of modelling a webapp as a series of screen navigations and a Screen as a list of controls - with actions
00:57:28 <Gx4> I was wondering if you could tell me if there's a website with a list of tasks for haskel learning ?
00:58:18 <yitz> @where lyah
00:58:18 <lambdabot> http://www.learnyouahaskell.com/
00:58:28 <yitz> it's a book
00:58:34 <Kashyap_> Gx4 - you should ofcourse check out www.haskell.org and http://learnyouahaskell.com/
01:00:55 <Gx4> thank you :)
01:05:24 <aleator_> yitz: Yep, I'm looking for a function that would tell me if a given Type is in Show class.
01:15:22 <hs_nab> hello guys
01:15:28 <hs_nab> where can i find the haskell stdlib?
01:15:56 <Lemon> hs_nab, hold on
01:16:54 <kniu> hs_nab, http://hackage.haskell.org/package/base-4.5.0.0
01:17:05 <hs_nab> kniu: thank you.
01:17:40 <hs_nab> kniu: i am looking for something close to ( Node.js || Go )'s http package
01:18:51 <kniu> hs_nab, http://hackage.haskell.org/package/HTTP
01:18:56 <kniu> this comes with Haskell Platform
01:19:05 <hs_nab> kniu: very neat.
01:20:04 <kniu> In unrelated news, I finally found a non-contrived use for type families
01:20:16 <hs_nab> uh-oh. 'client-side web programming in Haskell.' I need to write http servers
01:20:56 <kniu> hs_nab, browse this list: http://hackage.haskell.org/packages/archive/pkg-list.html
01:21:06 <hs_nab> tytyty
01:21:33 <hs_nab> this is one helluva funcking long list of pacakges o.O
01:21:49 <hs_nab> didn't know there is so much stuff written in haskell
01:21:56 <kniu> hs_nab, http://hackage.haskell.org/package/http-server
01:22:02 <kniu> ctrl-f is your friend
01:23:05 <hs_nab> ;)
01:31:02 <womb> Hi!
01:31:09 <shachaf> womb: Hoy!
01:31:10 <srhb> womb: Hello.
01:31:49 <Gx4> womb> hello
01:50:03 <srhb> When I get: "ld: symbol(s) not found for architecture i386" <- Does it mean I'm trying to link but my libraries are i386, or that I'm trying to link and my libraries are NOT i386?
01:51:06 <shachaf> Are you using an x86-32 version of GHC on x86-64 or something?
01:51:49 <srhb> Yes, I believe so. So it must be that way around, libraries are 64 bit while GHC is not.
01:52:03 <srhb> The error could be slightly less ambiguous. :/
01:52:18 <startling> srhb: are you on os x?
01:52:22 <srhb> startling: Yes
01:52:40 <startling> yeah. ghc is 32-bit iirc and gcc and clang make 64-bit object files
01:52:57 <srhb> Awesome. I'll just get the 64 bit Haskell Platform then.
01:53:52 <startling> srhb: you could also compile your object files for both architectures or just i386
01:55:40 <srhb> startling: Yes, I suppose either way will work. Except I think installing 64 bit Haskell Platform is simpler than getting all the libraries to play nice with anything but the default options. Perhaps I'm wrong though. I'll try this way around first. :-)
02:09:27 <startling> srhb: I dont remember for sure, but i recall there being a problem with 64-bit on os x
02:09:35 <startling> not sure though. best of luck, regardless!
02:11:42 <srhb> startling: Thanks. There seems to be a problem with every Haskell thing on OS X that requires an external library. :P
02:12:27 <startling> srhb: i know. :(
02:12:44 <startling> 7.4.2 seems to be a step in the right direction, though
02:12:55 <srhb> Oh, I didn't know that was going to fix anything.
02:13:15 <startling> srhb, well, it fixed a handful of libraries that I was holding out hope for
02:13:22 <startling> and 7.4.1 was completely broken for me
02:13:22 <srhb> startling: Ah, okay. That's nice to know.
02:13:35 <bxc_> 7.4.1 segfaults a lot on my os x box.
02:13:40 <bxc_> i haven't tried 7.4.2
02:13:46 <startling> bxc_: sigsegv, you mean?
02:13:54 <startling> yeah, I get that every once in a while
02:14:06 <bxc_> if I'd got round to capturing the errors in that much detail i would have sent them in ;)
02:14:23 <bxc_> ghci and profile -hb seem fairly reliable breakers though
02:14:28 <startling> yup
02:14:43 <bxc_> i'm not so hardcore that I need much post 7.0 stuff though
02:14:51 <startling> 7.4.2, fortunately, fixed the silently-fail-on-import bug
02:15:09 <srhb> I'm also considering downgrading. At least I had GTK and WX sorta kinda working on the previous Haskell platform.
02:15:23 <bxc_> i have both
02:15:27 <bxc_> and switch back and forth
02:16:40 <srhb> This is probably just a clever plan to make us all switch to Linux. :-)
02:17:44 <startling> srhb, my new hard drive should be here in a few days !
02:18:46 <bxc_> srhb: well thats my plan with next laptop
02:18:59 <t7> mm_freak: does your thing have sum and/or product types yet?
02:19:17 <srhb> bxc_: Same here, not so nice to get it all to work on a Macbook.. I'm going to miss the display and the touchpad though. Ah well!
02:19:49 <startling> I really started to appreciate the linux ecosystem after using os x
02:20:22 <srhb> Yeah. Especially with Haskell. I was so very jealous when I set up gtk2hs + wxhaskell on a friend's Debian for comparison. So painless.
02:20:22 <bxc_> mostly i appreciate teh fact that 32 bit linux software runs much more reliably than eveyrthing else
02:20:32 <startling> it's not bad (it's leaps and bounds ahead of windows, just by being a *nix) but there's tons of little gotchas and workarounds
02:20:33 <bxc_> incl 64bit linux softare.
02:20:39 <bxc_> it just seems that much less tested and bugfixed
02:21:40 <startling> 7.4.x did get rid of the annoying linking error, though
02:22:03 <srhb> Was just terminal spam though, wasn't it?
02:28:12 <srhb> "ld: symbol(s) not found for architecture x86_64" <- brilliant! :P
02:29:52 <shachaf> Are you sure you have all the dependencies listed installed?
02:29:59 <shachaf> Xcode command line tools something something.
02:30:04 <srhb> Pretty sure, yes.
02:30:39 <shachaf> Are you able to compile C programs?
02:31:25 <srhb> shachaf: Yes.
03:12:46 <Franciman> hi all
03:12:51 <Taneb> Hello
03:13:42 <Franciman> hey people I am writing a lexer, and wondered what's the most elegant way to do it : lexer :: String -> [Token] or lexer :: Lex [Token]
03:14:16 <Franciman> with the first one, the parser shouldn't call the lexer a lot of times
03:14:39 <Taneb> Where's Lex defined?
03:14:40 <Franciman> *and was wondering
03:14:52 <Franciman> Taneb, that's just a State monad
03:15:03 <Franciman> to keep the input string
03:15:08 <Taneb> Why not the reader monad?
03:15:16 <Franciman> yeah sorry I meant reader
03:15:51 <Taneb> Reader String [Token]
03:15:53 <Taneb> Hmm
03:16:00 <Taneb> I think they're equivalent
03:16:14 <Taneb> Using the Monad allows you to use do notation
03:16:30 <Taneb> More convieniently than the other
03:17:03 <Franciman> yeah that would make combining lexers nicer
03:17:32 <Franciman> but that would mean to add a call to the lexer from the parser anytime
03:17:37 <Franciman> i want a new token
03:18:42 <Taneb> I'm afraid I've never written a lexer, I don't really know the problems
03:18:53 <Taneb> But maybe ParserT Lex String [Token] ?
03:18:59 <Taneb> Or something
03:19:55 <Franciman> that's very elegant, thanks very much
03:25:40 <benmachine> must you guys stack monads on everything?
03:26:40 <benmachine> Franciman: Reader r a and r -> a are interchangeable
03:27:24 <Franciman> benmachine, yeah actually ...
03:31:56 <hilhil> -- is a comment inside a cabal file, right?
03:32:05 <dcoutts> yep
03:32:05 <benmachine> yes
03:32:09 <hilhil> thanks
03:32:18 <dcoutts> hilhil: though only on lines on it's own
03:33:00 <hilhil> like this?
03:33:02 <hilhil> --    ghc-options: -rtsopts -prof -threaded -auto-all -caf-all
03:35:24 <hilhil> nm, its working now
03:36:36 <TheLemonMan> Does sinkState expect a function as a state ?
03:37:05 <Taneb> @hoogle sinkState
03:37:05 <lambdabot> No results found
03:37:12 <Taneb> @hayoo sinkState
03:37:12 <lambdabot> Unknown command, try @list
03:37:36 <Taneb> Conduit
03:37:37 <TheLemonMan> hackage doc page has no info about the type
03:38:42 <hilhil> I'm finding it hard to make sense of the profiling data due to the laziness of Haskell
03:38:51 <hilhil> Is there any trick to it?
03:38:54 <hilhil> Or anywhere I can read about it?
03:43:24 <alpounet> shapr, so, how's it going? :)
03:44:01 <Taneb> Can anyone give me somewhere to start to learn GUI programming?
03:46:22 <Eduard_Munteanu> Taneb: check a gtk2hs tutorial
03:46:33 <Eduard_Munteanu> @google gtk2hs tutorial
03:46:34 <lambdabot> http://www.muitovar.com/gtk2hs/index.html
03:46:35 <lambdabot> Title: Gtk2Hs Tutorial
03:47:02 <Taneb> Thanks
03:47:13 <Eduard_Munteanu> hilhil: I agree, it can be misleading at times. Perhaps you might want to post your code and the profile?
03:48:55 <hilhil> Eduard_Munteanu: there's about 4k lines of code...
03:49:01 <hilhil> Also, I think it's the basics I'm having trouble with
03:49:14 <hilhil> For example, I don't really understand what happens if I put a cost centre inside a function call
03:49:23 <hilhil> Will it just stack up every time I call that function?
03:49:33 <hilhil> (Thanks for the kind offer, though!)
03:54:17 <kuribas> Is there a functional language that is suited for embedded (arm) programming?
03:54:41 <kuribas> With reasonable speed and memory consumption?
03:55:58 <aristid> kuribas: what is reasonable memory consumption? how much RAM do you have?
03:56:13 <quicksilver> I believe lisp has been popular on embedded systems. Of course there are many different lisps.
03:56:30 <Taneb> I know a couple of people with lisps
03:56:49 <Taneb> This is, of course, completely irrelevant
03:56:49 <kuribas> aristid: 32M
03:57:14 <hilhil> actually, setting cost centres seems to modify the behaviour of my program...
03:57:17 <hilhil> apply_filters fs = {-# SCC "apply_filters" #-} mapForest apply_all
03:57:24 <kuribas> Taneb: scheme would be fine to.  I tried chibi-scheme, which gives about 2.5M using the interpreter.
03:57:25 <hilhil> Stops that function from working
03:57:33 <hilhil> I must be doing something stupid ... ?
03:57:49 <Taneb> kuribas, I think you meant quicksilver.
03:58:09 <kuribas> Taneb: eh, right :)
03:58:49 <Taneb> I'm afraid Haskell is the only programming language I'm at all competent at
03:59:15 <Eduard_Munteanu> hilhil: I'd rather say every time the subexpression is evaluated
03:59:46 <hilhil> I don't understand why the cost centre is changing the program behaviour...
04:00:16 <Eduard_Munteanu> hilhil: how do you mean?
04:00:31 <Eduard_Munteanu> hilhil: I think it might preclude certain optimizations
04:01:03 <hilhil> no, I mean that if I put in the cost centre, I don't seem to get any output
04:02:16 <Eduard_Munteanu> hilhil: give it more time. It might also mean it's not doing certain optimizations and it might be on its way to blowing the stack, or stuff like that.
04:03:02 <hilhil> It's not timing out -- I just run the program in the usual way (via a shell script), and nothing is printed.
04:03:15 <hilhil> Blowing the stack: how would I tell?
04:08:58 <Eduard_Munteanu> hilhil: does it terminate, or spin indefinitely?
04:09:28 <hilhil> terminate
04:10:56 <benmachine> hilhil: sounds nasty. conduct sanity checks :P
04:12:03 <hilhil> meaning?
04:12:16 <Eduard_Munteanu> Are you using any unsafe stuff?
04:12:44 <benmachine> meaning, it would be kind of surprising if the problem was actually as you described it, so maybe make sure you are recompiling everything correctly, and that it is *just* this change that makes it stop working
04:12:44 <hilhil> I'm using a memoize library which my collaborator wrote, and I suspect it has some unsafe stuff in it
04:12:52 <benmachine> hmm
04:13:22 <hilhil> benmachine: I'm obsessively 'clean'ing after switching profiling on/off
04:13:31 <hilhil> And it's definitely just that change
04:13:47 <benmachine> hilhil: switching profiling on/off does the change, or just the SCC?
04:14:22 <hilhil> Good question... let me check. Do you want rtsopts on or off?
04:15:13 <benmachine> hilhil: I want the change that breaks your code to be as small as possible, that's all
04:15:35 <benmachine> also I want to go have a shower, so someone else can take over for a bit :P
04:15:51 <hilhil> Putting in the SCC without switching on -prof or -rtsopts is fine. I'm going to check em one by one
04:16:10 <benmachine> I imagine an SCC has no effect without profiling
04:17:22 <hilhil> [compiling is really slow]
04:17:27 <adamt> does anybody have a clue about how to construct the Ascii-types http://hackage.haskell.org/packages/archive/http-types/0.6.11/doc/html/Network-HTTP-Types.html uses?
04:17:55 <unnali> adamt: looks like it's just a ByteString! http://hackage.haskell.org/packages/archive/http-types/0.6.11/doc/html/Network-HTTP-Types.html#t:Ascii
04:18:05 <unnali> i.e. construct a ByteString, get an Ascii for free.
04:18:35 <adamt> unnali: Oh. Of course, i see now. Thank you for taking your time!
04:19:03 <unnali> adamt: not at all! Are you familiar with constructing ByteStrings?
04:19:39 <adamt> unnali: Nah, but i'll figure it out. I just ended up going nowhere looking in the cabal-file for dependencies providing an Ascii-type :-)
04:20:05 <unnali> Right! ;)
04:20:18 <Eduard_Munteanu> adamt: you just needed to click its definition in haddock there ;)
04:22:00 <hilhil> ahhh... it only appears to crash if -threaded is used together with the SCC
04:22:36 <hilhil> And I don't really need that (it was just there because of http://stackoverflow.com/questions/6704873/haskell-profiling-says-total-time-0-00-secs-but-its-not-true )
04:22:39 <adamt> Eduard_Munteanu: I just didn't realize (hey, i'm forgetful) that it constructed a type alias
04:23:13 <hilhil> thanks!
04:25:55 <t7> theres a bug in ghci with windows
04:26:19 <t7> when editing the middle of a multiline expression
04:26:19 <Taneb> t7, elaborate?
04:26:28 <t7> it goes full retard
04:27:26 <hilhil> If I have a pointless function and I want to measure the total cost of evaluating it on every argument to which it is applied, do I need to make it pointful?
04:27:55 <t7> have the readline lib changed in the new platform or something?
04:31:00 <t7> hmm i cant reproduce it now
04:31:07 <t7> it has happend a couple of times
04:31:33 <t7> aha
04:31:39 <t7> needs to be 3 lines i think
04:32:40 <t7> nope
04:32:42 <t7> hmm
04:35:10 <t7> aha ok
04:35:15 <t7> type this in ghci
04:35:17 <t7> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 5657 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100
04:35:20 <t7> press home
04:35:27 <t7> type anything until it forces a new line
04:35:34 <t7> enjoy the cool pattern for a while
04:35:37 <t7> press enter
04:35:41 <t7> enjoy the crash
04:36:06 <t7> i should get my name in the credits for that
04:37:08 <t7> etConsoleCursorPosition: invalid argument (The parameter is incorrect.)
04:43:28 <adimit> Question: is there an algorithm for finding the narrowest possible overlap between two lists? Say I have [a,b,c] and [d,d,a,d,a,d,b,a,d,c,d,c]. The result would be (4,9), assuming 0-indexing.
04:44:24 <adimit> I mean, I'm writing my own right now, but I can't shake the feeling that this has to have been done by somebody smarter than me in the past
04:44:43 <hpc> adimit: you mean smallest sublist of the latter that contains the former in-order?
04:44:49 <hpc> or contains the elements, or what?
04:45:12 <adimit> hpc: smallest sublist of the latter that contains the former in-order would be spiffy!
04:45:27 <frerich> adimit: I'm not aware of anything existing; my own guess would be that you look for the last occurrence of the first character in the needle ([a,b,c] in your case) and then the first occurrence of the last character of the needle from the back
04:45:51 <hpc> yeah, what frerich said
04:46:11 <frerich> Hm, otoh, that's not quite it.
04:46:15 <hilhil> frerich: what happens if there isn't a 'b' in that range?
04:46:27 <t7> Nothing?
04:46:28 <frerich> think of [a,b,c] on [x,x,a,b,c,c]
04:46:35 <frerich> That shouldn't yield 'abcc'...
04:46:55 <hpc> start with indexing all positions of a, b, c
04:46:58 <hpc> in a [[Int]
04:47:09 <hpc> then think about filtering the list
04:47:58 <hilhil> Looks like a dynamic programming problem to me.
04:48:31 <hilhil> for each pair of integers (k,n)
04:48:40 <adimit> frerich: that's true. My current approach is to scan from the left, then keep track of what we've already matched, match the leftmost element of the first list to the rightmost fitting element of the second, and so on, and if that doesn't pan out, backtrack.
04:48:55 <adimit> hilhil: exactly, dynamic programming 101.
04:49:11 <hilhil> where k <= the length of the shorter array ([a,b,c])
04:49:25 <hilhil> and n <= the length of the longer array ([d,d,a,d,a,d,b,a,d,c,d,c])
04:49:54 <hpc> ah, that works
04:50:02 <hpc> it should be O(n^3) too
04:51:03 <hilhil> Consider the first n elements of the longer array
04:51:24 <hilhil> aah, I feel like I'm not explaining this very well
04:52:04 <hilhil> The idea is that you fill in a table giving you the *start positions* for the different sub problems
04:52:12 <hilhil> So for example one entry of the table corresponds to
04:52:15 <hilhil> [a,b] and
04:52:22 <adimit> hilhil: like CYK parsing, really, no?
04:52:27 <hilhil> [d,d,a,d,a,d,b,a,]
04:52:34 <hilhil> Absolutely: CYK parsing is another dynamic program in problem
04:52:37 <hilhil> *programming
04:52:45 <hilhil> so for a two things I mentioned, you store
04:52:53 <hilhil> 4
04:52:58 <hilhil> because [a,d,b]
04:53:06 <hilhil> Starts at position t
04:53:13 <hilhil> *Starts a position 4
04:53:28 <hilhil> And it's the shortest substring of [d,d,a,d,a,d,b,a,] containing  [a,b]
04:54:12 <hilhil> (And actually it will need to be a table of Maybe Ints rather than a table of Ints, because sometimes the longer thing will not contain the shorter thing )
04:54:40 <adimit> yup, that sounds reasonable :-)
04:54:55 <hilhil> Then to compute the cell entry for e.g. [a,b] x [d,d,a,d,a,d,b,a,d,c]
04:55:09 <hilhil> No, make that
04:55:17 <hilhil>  [a,b,c] x [d,d,a,d,a,d,b,a,d,c]
04:55:22 <hilhil> You look at the entries for
04:55:30 <hilhil> a) [a,b] x [d,d,a,d,a,d,b,a,d]
04:55:36 <hilhil> and b)
04:55:45 <hilhil> [a,b,c] x [d,d,a,d,a,d,b,a,d]
04:56:09 <hilhil> Hmmm... actually, b) doesn't seem to be necessary in this case.
04:56:28 <hilhil> So you might find its a O(n^2) algorithm rather than an O(n^3) one
04:56:36 <hilhil> Anyway, I'll stop talking!
04:57:13 <t7> >flip flip (return . liftM2 (,) maximum minimum) . (((>>=) . sequence) .) . flip (map . flip elemIndex) "abc" "jklashasjdacaklsjdaslbkadj"
04:57:16 <t7> > flip flip (return . liftM2 (,) maximum minimum) . (((>>=) . sequence) .) . flip (map . flip elemIndex) "abc" "jklashasjdacaklsjdaslbkadj"
04:57:17 <lambdabot>   Couldn't match expected type `[m a]'
04:57:18 <lambdabot>         against inferred type `GHC.Typ...
04:57:24 <t7> poo
04:57:40 <hilhil> :t flip flip
04:57:41 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
04:58:33 <t7> > (flip flip (return . liftM2 (,) minimum maximum) . (((>>=) . sequence) .) . flip (map . flip elemIndex)) "abc" "jklashasjdacaklsjdaslbkadj"
04:58:35 <lambdabot>   Just (3,21)
04:58:42 <t7> beautiful code
04:59:02 <t7> do the items have to be in order?
04:59:32 <arnsholt> I think you'd need CKY parsing with dotted items to do this particular problem, but the idea is a good one IMO
05:02:33 <TheLemonMan> is a Conduit a one item per time transformer or gets the whole data at once when the source ends ?
05:03:14 <adimit> hilhil: thanks for your explanations though :-) I'm pretty bad at calculating alg. complexities, but I might just make this into a package, seeing as it seems to have some general use case.
05:03:31 <adamt> SIlly server.
05:03:37 <hilhil> It's going to be O(n^2)
05:04:50 <adimit> t7: lol, that's a neat one.
05:05:03 <adimit> yeah, they'd have to be in order.
05:07:14 <adimit> TheLemonMan: the idea behind conduits is to be able to do constant-space processing, so yeah, it can work on the stream, while the data is trickling in, and doesn't have to slurp in the entire handle at once.
05:07:25 <hilhil> adimit: look at http://hpaste.org/69801
05:08:06 <hilhil> In that fragment  I've got three lists (one for each of [a], [a,b], [a,b,c])
05:08:21 <hilhil> And the length of each list is the same as the length of [d,d,a,d,a,d,b,a,d,c,d,c]
05:09:12 <hilhil> Each element of each list can be computed in O(1) time
05:09:25 <hilhil> so it's O(n^2) time. [And O(n) space]
05:11:49 <adimit> hilhil: indeed, that looks quite like what I want to do, though I didn't think of representing it as lists like that. Nice!
05:13:20 <hilhil> You could also do it with 12 lists of length 3 (rather than 3 of length 12), which will save you some space if the short list is much shorter than the long one
05:13:31 <hilhil> (I just didn't write it out like that because it would be much harder to read)
05:15:39 <hilhil> what I *don't* know is how to make haskell memoise the lists properly...
05:15:53 <LambdaDusk> I wanted to ask if there's a compilable version of reactive planned... anyone knows?
05:16:05 <adimit> But I wonder, can't it be done in just a 2-pass over the longer list?
05:16:47 <wereHamster> Not in scope: `openSerialPort'. Perhaps you meant `openSerial' (imported from System.Hardware.Serialport)
05:16:58 <wereHamster> does hs use some kind of fuzzy search for these suggestions?
05:17:17 <adimit> so ou have [d,b,a,b,a,d,b,a,d,c,d,d,c], and you pass over it once: [(1,1),(2,0),(3,1),(4,0)…]
05:18:20 <kniu> sometimes, I want to write something like
05:18:44 <adimit> Then you take that second list, and keep track of only two things: the highest level you've reached (Maybe Int), and where the match for that started.
05:18:51 <pooya72> what's the haskell way to find and replace a string? I know there is Data.Text.replace, just wondering what the *way* was...
05:19:05 <kniu> data T a = Foo t where t = Bar a
05:19:24 <kniu> I want locally defined types in a data type definition
05:21:39 <adimit> ah, no, I'd need some more info, namely new start points, just like in the lists you showed me. I think the memoization i'll do in STArray or somesuch. Thanks!
05:27:43 <LambdaDusk> or some other question: Is there an FRP library based on GLUT and OpenGL that is currently developed?
05:31:45 <nonefool> is there a good reason why instance declarations aren't/can't be named (and thus be hidden from the export list), besides 'no one has implemented it yet'? what's the difficulty?
05:32:37 <Axman6> what's the point of hiding that a type is an instance of something?
05:33:29 <jaxtr> ahh it's a wonderful day
05:37:28 <fmap> nonefool: you can break invariants
05:38:19 <fmap> nonefool: http://stackoverflow.com/questions/8728596/explicitly-import-instances
05:39:06 <TheLemonMan> adimit: so it's correct to assume that push pushes the data directly into the sink every time is called ?
05:41:43 <nonefool> fmap: ah I see, thanks, so much for wanting that feature :)
05:43:43 <vijaykiran> Is there a reason why the function :type shows all the args separated with -> ?
05:49:41 <TheLemonMan> vijaykiran: because (->) is a function ?
05:49:50 <frerich> vijaykiran: Opposed to say, separating the arguments from the return value
05:49:54 <frerich> ?
05:50:00 <vijaykiran> frerich: yes
05:50:18 * vijaykiran is a noob-haskell - just started reading realworld haskell book
05:51:05 <frerich> vijaykiran: In Haskell, every function takes exactly one argument and returns one value. Multiple arguments are done by a process called 'currying'. In principle, a function taking 'n' arguments (for n > 1) returns another function taking 'n-1' arguments.
05:51:34 <frerich> vijaykiran: So in the simplest case, a function taking an Int and returning an Int is of type 'Int -> Int'. A function taking *two* ints actually is 'Int -> (Int -> Int)'
05:51:51 <sipa> now you run into trouble with that definition, with polymorphic functions like 'id'
05:51:57 <sipa> > id 5
05:51:58 <lambdabot>   5
05:52:33 <sipa> > id (+) 5 2
05:52:34 <lambdabot>   7
05:52:41 <sipa> see, it took 3 arguments!
05:53:00 <favonia> > id id id id id 1
05:53:01 <lambdabot>   1
05:53:26 * favonia flees
05:53:41 <vijaykiran> frerich: ok, understood. I read that "Haskell’s type system makes it an interesting challenge to write functions that take variable numbers of arguments."
05:53:48 * hackagebot leveldb-haskell 0.1.1 - Haskell bindings to LevelDB  http://hackage.haskell.org/package/leveldb-haskell-0.1.1 (KimAltintop)
05:53:59 <frerich> sipa: Only if you ignore that function application has the highest precedence, so what you wrote is actually ((id (+)) 5) 2 - in which case each invocation clearly takes just one argument.
05:54:00 <morel> isn't actually (id id id id 1) == (((id id) id) id) 1 ?
05:54:14 <sipa> frerich: absolutely
05:54:50 <morel> if sipa is right that frerich is right, i am right, too.
05:55:01 <sipa> morel is right
05:55:07 <frerich> :-))
05:55:31 <morel> Anyway, so that now vijaykiran's questions is solved, i've got one, too:
05:55:33 <morel> Can I use Haskell to program an Atmel AVR microcontroller? (E.g. Atmega8.)
05:55:44 <sipa> i'm just argument that such functions make it impossible to see from their defintion "how many arguments they take"
05:55:48 <sipa> +ing
05:56:17 <favonia> vijaykiran: hmm I'm not sure if the challenge is interesting, but variable numbers of args is certainly doable
05:56:38 <sipa> it requires quite some hackery
05:57:03 <morel> using a lists instead of a variable number of args is probably the easiest.
05:57:05 <sipa> haskell's type system is designed to make every requirement of the function explicit in its type
05:57:15 <sipa> :t printf
05:57:16 <lambdabot> forall r. (PrintfType r) => String -> r
05:57:34 <sipa> > printf "%s %i" "test" 666
05:57:35 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:57:35 <lambdabot>    `Text.Printf.PrintfType ...
05:57:43 <sipa> > (printf "%s %i" "test" 666) :: String
05:57:44 <lambdabot>   "test 666"
05:58:01 <vijaykiran> favonia: :) I'm fine with leaving that for later
05:58:05 <morel> …like this:  printf "foo: %d, %f, %c" [12, 123.123, 'a']
05:58:08 <Phlogistique> :i PrintfType
05:58:21 <morel> @src PrintfType
05:58:21 <lambdabot> Source not found.
05:58:31 <morel> @info PrintfType
05:58:31 <lambdabot> PrintfType
05:58:32 <sipa> morel: won't work, as that list now contains values of different types
05:58:47 <morel> sipa: PrintfStuff a => [a]
05:59:05 <sipa> morel: that still requires it to be a list of type a
05:59:19 <sipa> morel: that type can be many things, but in one single list, all elements have to be of type a
05:59:19 <morel> yup
05:59:29 <favonia> vijaykiran: in many cases, you can just put arguments of the same type in a list, and optional arguments in Maybe
05:59:39 <morel> sipa: yes. just create a type-class then.
05:59:39 <sipa> morel: unless you'd use existential types
05:59:46 <sipa> morel: no, that will not work; try it
05:59:52 <morel> sipa: why not?!
06:00:00 <sipa> morel: what is the type of [5,"bla"]
06:00:01 <sipa> ?
06:00:15 <morel> PrintfStuff t => [t]
06:00:26 <sipa> that's not a type, that's a set of types
06:00:35 <sipa> and it's wrong
06:00:37 <morel> class PrintfStuff t where foo :: t -> String -- or something
06:00:48 <sipa> [t] means a list of type t
06:00:59 <morel> sipa: why do you want it to be monomorphic? that's not necessary.
06:01:10 <sipa> that's not the problem
06:01:20 <sipa> Bla t => [t] means of list of type t where t belongs to Bla
06:01:31 <Eduard_Munteanu> Um, are you looking for a heterogenous list?
06:01:33 <sipa> it does not mean a list of various types t, where each belongs to Bla
06:01:39 <sipa> yes
06:01:40 <Eduard_Munteanu> You kinda need existentials or stuff like that.
06:01:45 <sipa> indeed
06:01:50 <morel> sipa: erm… OH shit!!
06:01:58 <morel> sipa: got it :D
06:02:19 <sipa> anyway, yes there are solutions, but those require some language extensions
06:02:39 <morel> yea, i know existentials.
06:03:05 <srhb> I keep wanting to be able to qualify record fields by their data type name. Do other people run into this as well? personName, dogName, catName...
06:04:45 <favonia> srhb: DisambiguateRecordFields ?
06:05:27 <morel> srhb: i don't get it, sorry… what do you want to do? let's consider this: data Foo = Bar { baz :: Type } -- what do you want to do with this?
06:05:37 <srhb> favonia: What does that do exactly?
06:06:35 <srhb> morel: data Cat = Cat { name :: String }; data Person = Person { name :: String }
06:06:55 <favonia> srhb: oh i'm sorry. it is a language extension that could possibly allow the program you want
06:07:08 <favonia> DisambiguateRecordFields is the name of the extension
06:07:11 <srhb> favonia: Thanks I'm trying to find that online.
06:08:09 <favonia> srhb: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#disambiguate-fields
06:08:22 <srhb> favonia: Thanks :-)
06:19:55 <kniu> I also want
06:20:04 <kniu> operator sections for type operators
06:34:39 <Moiman> @list todo
06:34:39 <lambdabot> todo provides: todo todo-add
06:39:45 <jimbo9> need music
06:40:31 * HairyDude sings: wave a chicken in the air, stick a deckchair up your nose
06:43:56 * hackagebot graph-rewriting 0.7.1 - Monadic graph rewriting of hypergraphs with ports and multiedges  http://hackage.haskell.org/package/graph-rewriting-0.7.1 (JanRochel)
06:45:41 <nand`> sipa: Nonsense, all you need is a num instance for [Char] :P
06:45:51 * nand` is probably way way too slow
06:46:01 <nand`> forget I said anything
06:46:16 <HairyDude> Num [Char]? eugh
06:47:23 <sipa> nand`: haha, true
06:47:41 <merijn> Now I just need DisambiguateLenses :p
06:48:57 * hackagebot graph-rewriting-gl 0.7.1 - OpenGL interface for interactive port graph rewriting  http://hackage.haskell.org/package/graph-rewriting-gl-0.7.1 (JanRochel)
06:57:28 <nand`> instance Num [Char] where a + b = show (read a + read b)
06:57:38 <nand`> JavaScript-style
06:58:23 <HairyDude> ick
06:58:38 <mhwombat> ?hoogle (a -> b) -> [a] -> [b]
06:58:38 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
06:58:38 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
06:58:38 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
06:58:44 <HairyDude> "not a number" + "definitely not a number"
06:59:23 <HairyDude> > show (read "foo" + read "bar" :: Int)
06:59:24 <lambdabot>   "*Exception: Prelude.read: no parse
06:59:47 <Taneb> > digitToInt 'a'
06:59:48 <lambdabot>   10
06:59:50 <Taneb> > digitToInt 'q'
06:59:51 <lambdabot>   *Exception: Char.digitToInt: not a digit 'q'
07:00:14 <HairyDude> > read "0xFF" :: Int
07:00:15 <lambdabot>   255
07:04:54 <sclv> preflex: seen davean
07:04:54 <preflex>  davean was last seen on #haskell 1 day, 16 hours, 19 minutes and 40 seconds ago, saying: Peaker: Who is "we"?
07:06:50 <Taneb> preflex: seen Ngevd
07:06:51 <preflex>  Ngevd was last seen on #haskell 32 days, 5 hours, 54 minutes and 3 seconds ago, saying: Hello
07:07:24 <Taneb> Wow, I haven't used that nick in a while
07:09:04 <hilhil> My program runs a  list of things through a long filter chain
07:09:08 <hilhil> So e.g. I compute
07:09:14 <hilhil> f(g(h(x_1)))
07:09:17 <benmachine> nand`: cf. http://hackage.haskell.org/package/acme-php
07:09:19 <hilhil> f(g(h(x_2)))
07:09:21 <hilhil> and so on
07:09:32 <hilhil> [ exactly what functions are used is controlled by a commandline argument.]
07:09:51 <hilhil> Is there an easy way to profile how much time is spent in f, how much in g, and so on ? (Without going through every function and manually adding SCCs)
07:10:26 <DrSyzygy> IIRC there are default profiling cost center additions if you just put the right flags in
07:10:47 <hilhil> -auto-all didn't do anything, and -caf-all produced an enormous amount of output
07:11:23 <parcs`> hilhil: what ghc version?
07:11:38 <hilhil> 7.0.3
07:12:41 <hilhil> The filter-chain constructing  code is here: http://hpaste.org/69805
07:16:23 <parcs`> hilhil: ghc 7.4 has a better profiler that will likely profile those functions with just -auto-all
07:16:41 <hilhil> I'm usign the Haskell platform (under Windows)
07:17:04 <hilhil> Can I get away with just trying to install a later ghc on top of the one that is already there?
07:17:47 <hilhil> ah, wait -- looks like there's a new Haskell platform
07:17:49 <hilhil> Thanks!
07:17:52 <benmachine> hilhil: if it helps, I have like eight GHCs installed
07:18:02 <benmachine> each just on top of the previous
07:18:04 <hilhil> benmachine: under Windows or Linux?
07:18:09 <benmachine> linux
07:18:09 <favonia> hilhil: you probably want to just install the new platform
07:18:23 <favonia> hilhil: oops I am too slow
07:18:23 <hilhil> yup. thanks!
07:19:30 <hilhil> When I'm installing it, do I have to do anything special in order to build the profiling versions of libraries?
07:21:38 <hilhil> http://lambdor.net/?p=258 <--- not sure whether the advice given here is up-to-date
07:22:58 <parcs`> i just enable profiling in ~/.cabal/config so that every package will get built with profiling libs
07:23:19 <parcs`> the HP should provide profiling versions of the libs it comes wit
07:24:04 <hilhil> parcs: the problem is that I'm not sure whether ~/.cabal/config will exist before I install the Haskell platform
07:24:22 <srhb> Does anyone use HaXR? Can I dump the output of remote somehow?
07:24:25 <marcot> Hi.  I'm installing MissingH using ./Setup build; ./Setup haddock; ./Setup install.  How can I make it register the documentation to show on index.html, like if I had installed using cabal install?
07:24:25 <hilhil> (I'm going to uninstall the previous version first. Things can be pernickety under Windows.)
07:24:42 <EvanR> cabal install missingh
07:27:28 <parcs`> hilhil: i think the HP installs the profiling libs regardless of whether you want them or not
07:29:48 <Axman6> isn't missing ancient?
07:30:07 <EvanR> some of the stuff i wanted from missingH has since showed up in other libs
07:30:51 <hilhil> thanks!
07:36:11 <HairyDude> the idea of MissingH is kind of horrible anyway, it's a kitchen sink / melting pot full of unrelated miscellaneous *stuff* that should be in its own library
07:44:11 <hpaste_> pooya72 pasted “multiple substitutes?” at http://hpaste.org/69807
07:44:51 <pooya72> is it possible to do multiple subRegex substitutions in one run? http://hpaste.org/69807
07:46:28 <mroman> How can I build a Monad on top of another Monad?
07:47:22 <opqdonut> read up on monad transformers
07:47:23 <Adeon> you may want to look up on monad transformers
07:47:29 <opqdonut> they are exactly that
07:48:11 <opqdonut> http://www.haskell.org/haskellwiki/Monad_Transformers is probably a good place to start
07:48:12 <mhwombat> mroman: monad transformers can do that, but chances are what you need to do is already implemented for you. What monads do you want to use?
07:49:04 * hackagebot QuickAnnotate 0.5 - Annotation Framework  http://hackage.haskell.org/package/QuickAnnotate-0.5 (ShayanNajd)
07:49:14 <mroman> I want to 'hook' the state monad.
07:49:18 <mroman> and extend it.
07:49:21 <hpaste_> pooya72 pasted “multiple substitutes a better way?” at http://hpaste.org/69808
07:49:40 <mhwombat> mroman: look at the StateT monad
07:50:00 <pooya72> so this is how I'v implemented multiple subRegexs. is there a better way? http://hpaste.org/69808
07:51:33 <mroman> Transformers don't create new monads?
07:51:51 <mhwombat> mroman: This might help http://www.haskell.org/haskellwiki/Simple_StateT_use
07:52:19 <benmachine> transformers create monads by combining the features of several other monads
07:52:27 <ifnspifn> I've got a tree data type that looks like this (https://gist.github.com/2910432), but I'd like to generate each SNode's list of children [STree] lazily. How would this kind of thing be done? I figured that I couldn't just create instances of this type with an empty list and then fill that in later
07:53:24 <benmachine> ifnspifn: what makes you think that the 'children' record accessor isn't already lazy?
07:53:31 <merijn> ifnspifn: What do you mean? It's already lazy...
07:53:35 <marcot> Well, my question was simply: how do I install a package using ./Setup (instead of cabal install) registering the haddock documentation?
07:53:56 <HairyDude> pooya72: I don't see how you could perform both substitutions other than by doing first one and then the other
07:54:11 <benmachine> marcot: I'm not really sure because I haven't used Setup in a while, but you might want the "haddock" subcommand
07:54:22 <benmachine> maybe just running haddock after build and before install would be enough
07:54:28 <ifnspifn> benmachine/merijn: well, I'm still quite new to Haskell, so I wasn't sure. My only experience with laziness is a toy language, Oz, in which functions had to be explicitly declared as being lazy
07:54:35 <marcot> benmachine: That's what I thought too, but it wasn'.t
07:54:40 <benmachine> ifnspifn: Haskell is lazy-by-default
07:55:03 <pooya72> HairyDude: yeah, i thought there might be a better way, cause I'll be doing roughly 12 substitutions on large text.
07:55:10 <mroman> If I use StateT I expose everything from StateT, right?
07:55:11 <favonia> ifnspifn: in Haskell you have to worry about eagerness instead
07:55:29 <mroman> And I can't reimplement get?
07:55:59 <benmachine> mroman: you can use a newtype over StateT
07:56:03 <pooya72> HairyDude: I was thinking there should be a way to do it in one cycle, if the pattern matches one of the cases, then it does the appropriate substitution
07:56:22 <benmachine> mroman: although at that point you might as well just write your own custom monad, it's not much harder
07:56:30 <ifnspifn> alright, well that's quite neat then! Thanks
07:56:41 <merijn> ifnspifn: If you just define a function "f :: a -> [STree]" you can just hand "f a" as the value for children and it'll be computed lazily as you expect
07:56:53 <asdf_> tes
07:57:51 <HairyDude> pooya72: think of the composition findBar . findFoo as like a unix pipeline findFoo | findBar
07:58:08 <HairyDude> pooya72: once findFoo produces some output, findBar can start working on it
07:58:33 <favonia> mroman: 'get' is bound to the typeclass MonadState. define a newtype for (StateT blah blah blah) and implement 'get' in whatever way you want :)
07:59:04 * hackagebot git-annex 3.20120611 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20120611 (JoeyHess)
07:59:05 <HairyDude> pooya72: actually... it occurs to me that the regex backend might not be written in haskell...
07:59:07 <favonia> @type get
07:59:08 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
07:59:10 <pooya72> HairyDude: oohhh, okay, so it doesn't wait for findFoo to finish, then have findBar start? It just passes the strings along?
08:00:13 <pooya72> HairyDude: i c.
08:01:28 <HairyDude> pooya72: ah, yes, the regex engine is C, so you don't get those benefits of laziness... my mistake
08:02:24 <pooya72> HairyDude: no prob. You're lucky that I'm also a hairy dude.
08:02:29 <HairyDude> :)
08:02:54 <favonia> mroman: or perhaps you only need State? seems that you're not combining two existing monads. what you're doing is more like writing a new monad transformer (if that hasn't been done yet)
08:04:37 <cheater_> hi
08:04:56 <mroman> favonia: I only need state, yes.
08:05:18 <mroman> Actually I want an other "interface" to the State monad.
08:05:26 <cheater_> i have updated my blog tutorial on NCurses / HSCurses / Vty. The section on Vty is completely rewritten, and Vty is currently the best choice for curses-style user interfaces. http://cheater.posterous.com/haskell-curses
08:07:20 <mroman> favonia: Like a StackMonad.
08:07:29 <mhwombat> cheater_: fantastic timing, I was just about to dip my toes in the ncurses water
08:07:32 <mroman> it supports only pop and push without exposing anything else.
08:07:49 <mroman> and pop and push use get/upt from the state monad.
08:07:52 <mroman> *put
08:07:56 <mhwombat> or hscurses, or vty, or whatever
08:08:38 <cheater_> mhwombat: you want vty.
08:08:55 <favonia> mroman: I see. then you can write a general transformer for that
08:09:05 <pooya72> HairyDude: so no other ideas for this?
08:09:19 <favonia> mroman: to make a stack monad out of any state monad
08:09:30 <mhwombat> cheater_: k, thx
08:10:04 <HairyDude> pooya72: not really... would it be any different in perl, for example?
08:10:27 <pooya72> HairyDude: don't know. I'm a noob.
08:10:30 <HairyDude> k :)
08:10:57 <cheater_> mhwombat: yw
08:15:09 <pooya72> HairyDude: i guess perl let's you continue from the previous match: http://www.regular-expressions.info/continue.html
08:16:10 <HairyDude> pooya72: what exactly are you trying to do?
08:17:02 <mroman> :t MonadState
08:17:03 <lambdabot> Not in scope: data constructor `MonadState'
08:17:11 <mroman> :i MonadState
08:17:26 <pooya72> HairyDude: replace some non-standard unicode with standard unicode so replace Ð with ī.
08:18:02 <HairyDude> pooya72: ah, individual characters?
08:18:16 <pooya72> HairyDude: yeah
08:18:39 <HairyDude> pooya72: perl has a special operator for that case, called tr
08:18:59 <rwbarton> why not use map then? or Data.Text.map
08:19:13 <rwbarton> (disclaimer: I haven't actually looked at what you are doing)
08:19:34 <pooya72> rwbarton: just replacing characters
08:19:35 <HairyDude> yes, that's a point
08:19:51 <mroman> newtype (Monad m) => StackMonad m a =  StackMonad { runStack :: m (Stack a) }
08:19:57 <HairyDude> for [Char] (i.e. String) you can use map with a function of type Char -> Char
08:20:00 <mroman> but I need MonadStatem => or something.
08:20:33 <rwbarton> Data.Text also has map :: (Char -> Char) -> Text -> Text
08:20:56 <mroman> or hm.
08:20:58 <HairyDude> this is assuming you only need to substitute individual characters, not combining characters too
08:21:07 <mroman> actually
08:21:42 <pooya72> rwbarton: so how would i use it?
08:22:55 <rwbarton> replacement 'Ð' = 'ī'; replacement x = x
08:23:00 <rwbarton> Data.Text.map replacement
08:23:38 <rwbarton> add more cases to replacement as desired
08:25:32 <HairyDude> pooya72: this doesn't work if you need e.g. e + acute -> e with acute or vice versa
08:25:36 <mroman> I have no idea how to do this :(
08:25:51 <mroman> I need a type that wraps the StateMonad
08:26:10 <mroman> and create a Monad instance for my wrapper type?
08:26:40 <srhb> Is there a builtin tool to strip file extensions from strings?
08:26:53 <srhb> I suppose I can takeWhile /= '.' ...
08:27:05 <rwbarton> @hoogle </>
08:27:05 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
08:27:05 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
08:27:07 <applicative> mroman: leave off the constraint.  write newtype StackMonad m a =  StackMonad { runStack :: m (Stack a) }
08:27:10 <rwbarton> try System.FilePath
08:27:23 <srhb> rwbarton: Thank you
08:27:44 <applicative> mroman, then eg  instance MonadState m => MonadState (StackMonad m) where....
08:28:00 <pooya72> HairyDude: i c...
08:28:35 <rwbarton> mroman, this all looks a bit off
08:28:53 <rwbarton> don't you want a newtype of StateT (Stack s) m a
08:29:30 <HairyDude> http://hackage.haskell.org/packages/archive/unicode-normalization/0.1/doc/html/Text-Unicode-Normalization.html
08:29:39 <HairyDude> if that's what you want
08:29:53 <rwbarton> newtype StackT s m a = StackT { runStackT :: StateT (Stack s) m a }
08:30:23 <applicative> ah that must be whats going on, yes, mroman The Stack is the state
08:30:50 <rwbarton> then push x = StackT $ modify (x:) -- or whatever you do to push something onto a Stack s
08:33:16 <rwbarton> skimming back it's a little hard to tell whether you want a transformer version rather than a simple State (Stack s) monad, I guess you do though because you had a type variable name dm
08:33:41 <rwbarton> but possibly you intended m = State (Stack s)
08:37:54 <basti_> hi people. what is stg_ap_0_fast?
08:38:44 <mroman> I'm not even sure if I want a transformer.
08:39:35 <mroman> I just don't want somebody to call put/get directly.
08:39:48 <mroman> And I don't want them to notice, that there is a State Monad behind it.
08:40:10 <rwbarton> if it's just a State monad, you don't need a transformer, no.
08:40:48 <otters> Is it possible to write a MonadState instance where the state is stored in a TVar and get/put/modify transparently modify the TVar?
08:40:52 <rwbarton> newtype StackMonad s a = StackMonad { runStack :: State (Stack s) a }
08:40:53 <adamt> basti_: Maybe you should give a bit of context? :-)
08:41:32 <rwbarton> before it looked like you were using a type variable m when you actually knew what type you wanted m to be
08:41:38 <rwbarton> which was generally causing confusion
08:42:10 <mroman> I'v never written a monad by myself. So I've no idea what I'm doing ;)
08:42:42 <mroman> So that wraps my Stack inside State?
08:42:42 <wereHamster> the posix sleep function doens't work, it doesn't sleep at all. It returns right away
08:42:49 <wereHamster> am I doing something wrong?
08:42:59 <rwbarton> um
08:43:04 <HairyDude> @hoogle sleep
08:43:04 <lambdabot> System.Posix.Unistd sleep :: Int -> IO Int
08:43:05 <lambdabot> System.Posix.Unistd nanosleep :: Integer -> IO ()
08:43:05 <lambdabot> System.Posix.Unistd usleep :: Int -> IO ()
08:43:25 <rwbarton> how about "a StackMonad is a state monad where the state is a Stack"
08:43:29 <adamt> wereHamster: it uses micro-seconds, not milli-seconds
08:43:45 <mroman> Sounds ok.
08:43:53 <wereHamster> adamt: | Sleep for the specified duration (in seconds).  Returns the time remaining...
08:44:12 <adamt> wereHamster: Oh i was thinking of another sleep function, sorry.
08:44:18 <wereHamster> usleep, right :)
08:44:24 <mroman> No I need to declare a Monad instance for it?
08:44:28 <wereHamster> or nanosleep
08:44:29 <rwbarton> well and also threadDelay
08:44:40 <mroman> *Now
08:44:42 <rwbarton> which is what you probably want to use
08:44:47 <adamt> no, threadDelay was what i was thinking about.
08:44:49 <rwbarton> mroman: yes
08:44:59 <rwbarton> though you can have the compiler produce it for you with GeneralizedNewtypeDeriving
08:45:04 <pooya72> rwbarton: HairyDude: so this works: http://hpaste.org/69810 but do i need to pack and unpack string -> text all the time like that?
08:45:22 <srhb> wereHamster: Works fine, are you wrapping it in something weird that isn't evaluated?
08:45:27 <rwbarton> if you write it manually it will be a boring (but possibly helpful) exercise in newtype wrapping/unwrapping
08:45:34 <HairyDude> pooya72: I believe you can just use Text values directly
08:45:52 <rwbarton> pooya72: I assumed you were using Text because your initial paste was using Text!
08:45:52 <Siod> wxhaskell taskbaricon's linger after the application exit: anyone know how to fix this?
08:45:56 <wereHamster> srhb: my main is essentially: putStrLn "x"; sleep 10000; putStrLn "y";
08:46:00 <mroman> Since I've never done anything like that it's rather confusing and new to me as boring .
08:46:04 <otters> also, class Monad m => MonadState s m | m -> s where
08:46:04 <wereHamster> yet the app exits immediately
08:46:07 <otters> what is the | m -> s for?
08:46:17 <mroman> functional dependency?
08:46:21 <rwbarton> pooya72: you can just not use Text at all, of course.
08:46:38 <mroman> So, I can unwrap the StateMonad out of my newtype?
08:46:39 <rwbarton> delete line 1 and the pack/unpack and change DT.map to regular old map
08:47:18 <otters> oh
08:48:47 <pooya72> rwbarton: awesome. can i do this for string matches as well?
08:49:05 <rwbarton> wereHamster: sleep is working here for me too.  http://hpaste.org/69811
08:49:08 <adamt> wereHamster: _ <- sleep 10000
08:49:09 <rwbarton> pooya72: no
08:49:18 <HairyDude> :t Data.Text.writeFile
08:49:19 <lambdabot> Not in scope: `Data.Text.writeFile'
08:49:22 <HairyDude> hrm
08:49:26 <HairyDude> @hoogle writeFile
08:49:27 <lambdabot> Prelude writeFile :: FilePath -> String -> IO ()
08:49:27 <lambdabot> System.IO writeFile :: FilePath -> String -> IO ()
08:49:27 <lambdabot> Data.ByteString writeFile :: FilePath -> ByteString -> IO ()
08:49:29 <adamt> nvm me
08:49:47 <HairyDude> :t Data.Text.IO.writeFile
08:49:48 <lambdabot> FilePath -> Data.Text.Internal.Text -> IO ()
08:49:50 <pooya72> rwbarton: ok. and what's the advantage of Text over String? I remember reading somewhere that people preferred Text
08:49:51 <HairyDude> there we go
08:49:58 <quicksilver> wereHamster: don't use sleep, use threadDelay
08:50:01 <rwbarton> wereHamster: if you are on linux I suggest strace-ing your program, maybe it is receiving a signal? if you are windows I suggest crying in the corner. :P
08:50:03 <quicksilver> although I don't know why sleep wouldn't work.
08:50:04 <rwbarton> Or, just use threadDelay
08:50:08 <tac-tics> @src Text
08:50:08 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
08:50:11 <HairyDude> pooya72: use Data.Text.IO
08:50:23 <hpaste_> applicative annotated “sleep” with “sleep (annotation)” at http://hpaste.org/69811#a69812
08:50:47 <joeyh> what type of gotchas should I look for when building code that has only been run with the non-threaded runtime with -threaded?
08:50:49 <rwbarton> pooya72: Text is much more efficient in terms of memory usage and time
08:50:50 <applicative> wereHamster: it is doing what one expects ^^
08:51:27 <pooya72> rwbarton: thanks!
08:51:35 <pooya72> HairDude: thanks for your help!
08:51:41 <HairyDude> hth :)
08:51:43 <wereHamster> adamt: is it important that I capture it's return value?
08:52:13 <rwbarton> pooya72: but String is fine when you're starting out or for small things, it has some advantages in terms of convenience.
08:52:21 <pooya72> HairyDude: so I can use Data.Text.IO.writeFile instead of writeFile?
08:52:27 <HairyDude> pooya72: yup
08:52:32 <pooya72> rwbarton: ok, thanks.
08:52:38 <wereHamster> wait. maybe the app is setting up some signals or something. /me shakes first at signals
08:53:12 <srhb> wereHamster: Just use threadDelay :P
08:53:21 <applicative> pooya72: you just import qualified Data.Text as T;  import qualified Data.Text as T  and put T. in front of everything.  ...
08:53:46 <HairyDude> the first of those should be import Data.Text (Text)
08:54:02 <applicative>  import qualified Data.Text as T;  import qualified Data.Text.IO as T is what I was thinking
08:54:10 <hpaste_> mroman pasted “>>=?” at http://hpaste.org/69814
08:54:12 <HairyDude> oh, I didn't know you could do that
08:54:13 <applicative> but yes
08:54:25 <HairyDude> give the same name to multiple modules
08:54:32 <mroman> I'm guessing it should look something like that.
08:54:36 <wereHamster> srhb: roger that
08:54:41 <pooya72> applicative: thanks!
08:55:05 <HairyDude> mroman: or indeed return = StackMonad . return
08:55:17 <wereHamster> srhb: hm, ghc only..
08:55:37 <applicative> pooya72: needless to say there are millions of subtle differences, e.g. you cant pattern match on Text values, as with ByteString. Different things are cheap and exxpensive
08:55:43 <HairyDude> mroman: in fact, with the NewtypeDeriving extension you can do "deriving Monad"
08:56:03 <mroman> I actually don't even know why StackMonad.return works.
08:56:12 <pooya72> applicative: yeah, is there anywhere that explains the differences? or should I just read about them on hackage?
08:56:36 <mroman> StackMonad actually takes a function?
08:57:08 <applicative> i don't  know of a discussion, there must be some pooya72
08:57:47 <applicative> note the difference between Data.Text and Data.Text.Lazy and the relations, parallel with ByteString.
08:57:59 <HairyDude> mroman: a "State foo bar" value is a function, you call it with some initial state using runState (or evalState or execState)
08:58:06 <pooya72> applicative: ok thanks
08:59:01 <applicative> Data.Text uses a system of  'stream fusion' rewrite rules, so it is best to restrict oneself to the combinators exported.  Interleaving conversion to String and then back can break the fused sequence
08:59:24 <HairyDude> translation: it makes it much slower
08:59:35 <otters> I don't understand what a functional dependency expresses
08:59:50 <copumpkin> otters: http://en.wikipedia.org/wiki/Functional_dependency
09:00:23 <mroman> Whats the a for?
09:00:36 <mroman> or "bar" in your example.
09:00:52 <HairyDude> otters: given class Foo a b | a -> b, if you have an instance Foo Bar Baz, you can't also have an instance Foo Bar Quux
09:00:57 <rwbarton> the result type of the monadic computation
09:00:58 <EvanR> Either why you no have Functor instance >_<
09:01:00 <otters> Oh
09:01:02 <otters> That sucks
09:01:23 <rwbarton> if you don't like it you can use some of these: ^H^H^H^H^H^H^H
09:01:30 <copumpkin> > fmap (+1) (Right 5)
09:01:31 <lambdabot>   Right 6
09:01:35 <copumpkin> EvanR: ^
09:02:36 <HairyDude> otters: the point being, if you have a constraint Foo Bar a, you know a = Baz
09:02:39 <geekosaur> isn't it secretly an Error instance or something?
09:02:42 <rwbarton> the reason MonadState has one is that it would be awkward if the same monad could have states of two different types, since you'd potentially need to add type annotations to many uses of get/put/modify
09:02:50 <HairyDude> otters: and so does the type inference engine
09:02:50 <otters> HairyDude: I see
09:02:56 <otters> rwbarton: I got it
09:03:04 <EvanR> copumpkin: doesnt work in ghci
09:03:07 <RichyB> AIUI then it means that when you have a class constraint (Foo Bar x) then you can immediately infer that x is equal to Baz, right?
09:03:16 <copumpkin> EvanR: that's cause some asshole relegated the instance to another module
09:03:17 <RichyB> HairyDude beat me to it.
09:03:20 <copumpkin> EvanR: which is stupid
09:03:38 <Axman6> class Headable a b | a -> b where head :: a -> Maybe b;  instance Headable [a] a where healable = ; instance Headable Text Char where head = ...
09:03:38 <EvanR> rawrg
09:04:04 <otters> so I can't really define a StateT whose state is a certain type
09:04:10 <HairyDude> otters: so we have class MonadState s m | m -> s
09:04:21 <otters> right
09:04:30 <HairyDude> which means any state monad has only one state at a time that you can use get/set with
09:04:39 <otters> yeah
09:05:36 <otters> so I can't define a StateT instance where the state is inside a TVar
09:05:43 <rwbarton> copumpkin: the second paragraph of that wikipedia article is amazingly bad
09:05:54 <copumpkin> rwbarton: I didn't actually read it :)
09:06:02 <copumpkin> I noticed that one of the laws is truncated though
09:06:05 <otters> that's called FOSS help
09:06:21 <rwbarton> ah yes, the Axiom of
09:06:22 <HairyDude> tbh I don't know anything about concurrency, so I can't help you there :)
09:06:35 <otters> well, my get is defined as
09:07:04 <otters> get = StateT $ \s -> liftIO . readTVarIO s >>= \i -> return (s, i)
09:07:12 <EvanR> to understand concurrency, you have to be in the process of understanding concurrency
09:07:18 <EvanR> already
09:07:40 <rwbarton> what is a "StateT instance"
09:07:45 <otters> and which basically requires that I write my instance like MonadState (TVar s) (StateT s m)
09:07:51 <otters> I *think*
09:07:51 <rwbarton> and why did you name your constructor StateT
09:08:00 <otters> err
09:08:03 <otters> MonadState instance*
09:08:05 <otters> my bad
09:08:08 <rwbarton> are you trying to define a new monad?
09:08:13 <otters> uhhh
09:08:15 <otters> sorta
09:08:17 <otters> yes
09:08:24 <rwbarton> and you are calling it StateT?
09:08:27 <otters> no
09:08:31 <otters> I'm using the existing StateT
09:08:37 <rwbarton> ....
09:08:43 <rwbarton> I'm confused
09:08:56 <otters> imported from Control.Monad.State
09:09:05 <rwbarton> how is it new if it's StateT
09:09:24 <otters> okay, so it's now new
09:09:25 <rwbarton> I guess you mean, you are trying to define a second MonadState instance for StateT
09:09:26 <otters> not
09:09:34 <otters> yeah
09:09:39 <MagneticDuck> hey everyone
09:09:44 <rwbarton> well that won't work for various reasons
09:09:50 <rwbarton> well
09:09:57 <rwbarton> mostly it just doesn't seem to be what you want to do
09:10:13 <hpaste_> mroman pasted “>>=?” at http://hpaste.org/69815
09:10:24 <otters> maybe not
09:10:27 <MagneticDuck> I have a little problem that I think has a nice solution, although I'm currently ignorant of said nice solution
09:10:46 <applicative> class IdealGas pressure temperature volume | pressure temperature -> volume,  temperature volume -> pressure, volume pressure -> temperature where
09:10:47 <otters> I think it is what I want to do though
09:10:49 <MagneticDuck> I'm making a very simple system that deals with writing sparse matrices
09:11:00 <mroman> I somehow need to extract StateT?
09:11:16 <MagneticDuck> lol sorry there
09:11:20 <mroman> or liftM?
09:12:20 <HairyDude> otters: if you want to store state in a TVar, you could use a Reader to store it, since I'm guessing you don't need to change the TVar, only its contents
09:12:33 <EvanR> is fmap == liftM for every monad
09:12:45 <rwbarton> yes this sounds more promising
09:12:56 <otters> well, yeah
09:13:08 <rwbarton> newtype TVarStateT s m a = TVarStateT { ReaderT (TVar s) m a }
09:13:17 <rwbarton> er with a record field name in there
09:13:26 <otters> but I had hopes of using get/put/modify as though I was operating on a regular state
09:13:31 <byorgey> EvanR: it should be
09:13:33 <rwbarton> instance MonadState s (TVarStateT s m)
09:13:40 <otters> oh
09:13:42 <otters> okay
09:13:59 <byorgey> EvanR: mathematically, yes.  But technically the standard libraries do not enforce it
09:14:03 <rwbarton> with presumably a (MonadIO m) context
09:15:00 <rwbarton> (also, why TVar?)
09:15:01 <EvanR> byorgey: yeah so is there a monad instance in the wild with a dissenting functor
09:15:20 <HairyDude> there are monads in the wild that don't have a Functor instance
09:15:22 <EvanR> that would be considered an error right, it breaks the laws
09:15:39 <HairyDude> I don't know of any where liftM /= fmap though
09:15:44 <rwbarton> it would mean that either a Functor or a Monad law is broken, yeah
09:15:49 <byorgey> EvanR: it would be considered an error.  I don't know of any.
09:15:53 <EvanR> ok
09:16:21 <EvanR> is pointed a thing now
09:16:28 <byorgey> no
09:16:31 <EvanR> ok
09:17:29 <HairyDude> I believe one of the Monad laws says something equivalent to "If Foo is both a Monad and a Functor, then fmap = liftM"
09:17:39 <HairyDude> I mean one of the laws regarding the Monad class
09:17:44 <quicksilver> it's a bit more fundamental than that
09:18:06 <quicksilver> there can only ever be one implementation of fmap for a given type
09:18:10 <HairyDude> ah
09:18:17 <quicksilver> (ignoring 'daft' implementations which mess around with _|_)
09:18:33 <HairyDude> only one continuous implementation, I guess
09:18:49 <HairyDude> continuous in terms of denotational semantics
09:18:50 <quicksilver> fmap f = _|_ is continuous
09:18:54 <quicksilver> it's just "daft".
09:19:25 <bbrittain> where is the haskell source located?
09:19:27 <HairyDude> continuous and non-trivial, then
09:19:32 <quicksilver> I'm not sure if you can be more precise about what daft means; but for example, the theorems for free stuff will never produce _|_ anywhere.
09:19:58 <quicksilver> bbrittain: source to the libraries, or the compiler?
09:20:04 <bbrittain> the compiler
09:20:15 <bbrittain> quicksilver, ^
09:20:26 * HairyDude stops paying attention to questions in order to get on with the yesod tutorial
09:21:03 <fryguybob> Some people, when confronted with a problem, think "I know, I'll use spoon." Now they have _|_ problems.
09:21:14 <quicksilver> bbrittain: well you can download it; I don't know if it's browsable.
09:21:33 <rwbarton> I don't even know what the Monad laws are that say that liftM must be functorial, I'm so used to being a functor just being part of what it means to be a monad.
09:21:54 <bbrittain> quicksilver, ahh ok.
09:21:59 <quicksilver> rwbarton: you get functoriality for free from parametric polymorphism.
09:22:02 <quicksilver> bbrittain: http://www.haskell.org/ghc/download_ghc_7_4_2#sources
09:22:08 <rwbarton> but not liftM id = id
09:22:22 <quicksilver> bbrittain: or browse a git mirror at https://github.com/ghc/ghc
09:22:37 <bbrittain> quicksilver, aha! thats more like it :)
09:23:04 <rwbarton> I can write a lot of non-identity functions [a] -> [a]. Unless it's suppoesd to follow from having return and (>>=) somehow.
09:23:13 <HairyDude> rwbarton: mathematically, the definition of monad builds on the definition of functor.
09:23:20 <rwbarton> right
09:23:31 <quicksilver> rwbarton: but you can't define liftM id by cases.
09:23:39 <HairyDude> it says "A monad is a functor F with the following natural transformations"
09:23:43 <rwbarton> yes i know
09:23:44 <quicksilver> rwbarton: your definition of liftM has to parmetrict over all f :: a -> b
09:23:54 <quicksilver> and that is what guarantees that liftM id = id.
09:23:55 <rwbarton> quicksilver: not a problem
09:23:56 <rwbarton> no
09:24:15 <rwbarton> @type let mymap f xs = map f xs ++ map f xs in mymap
09:24:16 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:24:19 <rwbarton> tada
09:24:31 <rwbarton> but, not a functor
09:24:42 <quicksilver> hmm yes :)
09:24:59 <rwbarton> somehow you need liftM id = id as well
09:25:11 <HairyDude> let mymap f xs = map f xs ++ map f xs in mymap id "foo"
09:25:14 <HairyDude> > let mymap f xs = map f xs ++ map f xs in mymap id "foo"
09:25:15 <lambdabot>   "foofoo"
09:25:37 <bbrittain> does anyone have recomendations regarding projects a beginner could work on or bug fix? (I at least understand everything in LYAH)
09:25:40 <rwbarton> HairyDude: I am just saying because in Haskell Functor is not a superclass of Monad, I suppose that someone has written down Monad laws that do not mention Functor.
09:26:09 <HairyDude> > let mymap f xs = map f xs ++ map f xs in mymap (++"y") (mymap ("x"++) "foo")
09:26:10 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
09:26:10 <lambdabot>         against inferred ty...
09:26:20 * HairyDude scratches head
09:26:40 <HairyDude> rwbarton: yes, but there is a law that ties them together, as I mentioned.
09:27:17 <rwbarton> right, so what is the traditional (for Haskellers) formulation of that law in terms of (>>=) and return
09:27:38 <centrinia> :t \f xs -> map f xs ++ map f xs
09:27:39 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:27:43 <HairyDude> > let mymap f xs = map f xs ++ map f xs in mymap (succ . succ) (mymap pred "foo")
09:27:45 <lambdabot>   "gppgppgppgpp"
09:27:58 <HairyDude> > let mymap f xs = map f xs ++ map f xs in mymap pred (mymap (succ . succ) "foo")
09:28:00 <lambdabot>   "gppgppgppgpp"
09:28:07 <HairyDude> whoops, wrong test
09:28:14 <rwbarton> yeah it won't satisfy that law, either.
09:28:20 <HairyDude> > let mymap f xs = map f xs ++ map f xs in mymap (succ . succ . pred) "foo"
09:28:22 <lambdabot>   "gppgpp"
09:29:28 <rwbarton> I think that map id = id is sufficient though, because map f . map g = map (f . g) . map id {- by parametricity I guess? -} = map (f . g)
09:29:32 <rwbarton> once map id = id
09:30:08 <rwbarton> @free map
09:30:09 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
09:30:13 <rwbarton> @free fmap
09:30:14 <lambdabot> Expected variable or '.'
09:34:11 <parcs`> @free const
09:34:12 <lambdabot> f . const x = const (f x) . g
09:35:15 <parcs`> @free flip :: (a -> b -> c) -> b -> a -> c
09:35:15 <lambdabot> (forall x. h . k x = p (f x) . g) => h . flip k y = flip p (g y) . f
09:36:57 <hilhil> Is there any way to write this pattern more readably (e.g. with fewer brackets)?
09:36:58 <hilhil> tidy_one (DRS (l@(DRSLine [] rs (Just (Implies (Gen a b) _))):ls))
09:37:36 <HairyDude> f . g  = (f . g) . id => map f . map g = map (f . g) . map id
09:37:42 <strager> I'd probably break that up into a few case statements hilhil
09:37:42 <Siod> how do i do the equivalent on ghc --make main.hs icon.o in a cabal file? (the important part is the icon.o)
09:37:50 <rwbarton> well you don't need parentheses around l@(...)
09:37:58 <rwbarton> so DRS l@(DRSLine...
09:38:11 <rwbarton> unclear whether this is more readable :)
09:38:23 <rwbarton> also, you could write Gen a b `Implies` _
09:38:24 <hilhil> strager: problem is that I have a bunch of other pattern matches and am worried about collision
09:38:29 <hilhil> rwbarton: thanks!
09:38:34 <HairyDude> I'm not sure the free theorem gives rise to fmap id = id, but it does give rise to the other law
09:38:48 <hilhil> I didn't know you could backquote types in pattern matches -- that's *really* useful to know.
09:39:06 <parcs`> @free (a -> a -> b) -> a -> b
09:39:07 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
09:39:07 <HairyDude> isn't that an extension?
09:39:15 <parcs`> @free join :: (a -> a -> b) -> a -> b
09:39:16 <lambdabot> (forall x. g . h x = k (f x) . f) => g . join h = join k . f
09:39:20 <rwbarton> I don't know that I've ever actually tried that, but I don't see why it wouldn't work
09:39:27 <jfischoff> Siod: you want to specify extra objects for linking in cabal correct?
09:39:32 <Siod> jfischoff: yes
09:39:53 <strager> hilhil: The compiler will tell you about collisions
09:40:03 <Siod> jfischoff: i have to compile an icon.rc manually and then i need to link the icon.o with the rest of the problem
09:40:05 <HairyDude> > read "Left 1" :: Int `Either` Bool
09:40:06 <lambdabot>   Left 1
09:40:09 <HairyDude> hmm
09:40:10 <hilhil> Dropping the brackets around l@...:ls doesn't work, though
09:40:11 <parcs`> @free curry
09:40:12 <lambdabot> h . k = p . $map_Pair f g => h . curry k x = curry p (f x) . g
09:40:46 <hilhil> In some sense it definitely can't tell me about all collisions since I have a final clause that catches everything not caught by previous clauses ...
09:40:49 <jfischoff> Siod: I'm just bumping your question, I don't have an answer off hand. have you tried pass it with ghc-options ?
09:40:52 <hilhil> And that clause must collide with everything else
09:41:08 <ion> Huh. I never thought of using the `infix` syntax in types.
09:41:21 <srhb> So, for the first time I've had to split a project into several files. I figure this is the time where I need to learn about cabal and things. Where do I go for the relevant information?
09:41:32 <HairyDude> just tested and indeed, you need -XTypeOperators
09:41:40 <HairyDude> which lambdabot happens to have turned on
09:42:09 <strager> srhb: cabal init.  Then read the cabal manual.
09:42:13 <ion> @type undefined :: (a ->) b
09:42:14 <lambdabot> parse error on input `)'
09:42:15 <geekosaur> "conile an icon.rc manually" may actually be the harder part, since cabal doesn't know how to do that
09:42:25 <ion> I suppose that’s not supported with any extension?
09:42:35 <rwbarton> I was talking about using `` around a data constructor on the LHS of a pattern.
09:42:40 <rwbarton> Which I'm pretty sure is Haskell 98.
09:42:41 <HairyDude> @type undefined :: ((->) a) b
09:42:41 <strager> @type undefined :: ((->) a) b
09:42:42 <lambdabot> forall a b. a -> b
09:42:43 <lambdabot> forall a b. a -> b
09:42:48 <HairyDude> snap :)
09:42:53 <strager> ;P
09:42:55 <hilhil> `` with types is working for me without an extension
09:43:02 <ion> strager: That’s not an extension. :-P
09:43:07 <geekosaur> ion: no, you can't use (->) as a section
09:43:38 <Siod> there should be a way of automatically building and embedding icons for your application in cabal
09:43:38 <rwbarton> hilhil: I think when you say "types" here, you mean "data constructors".
09:43:54 <HairyDude> rwbarton: ahh, *data* constructors, yes. They behave just like functions syntactically so backquoting works
09:43:56 <hilhil> sorry, yes
09:44:09 <hilhil> That makes sense
09:45:07 <srhb> strager: I get the feeling cabal init is broken. After following the instructions it just informs me that some random and irrelevant file is nonexistant. :P
09:45:35 <byorgey> srhb: which file?
09:45:47 <Siod> jfischoff: your suggestion worked
09:45:49 <rwbarton> maybe it literally uses that wording
09:45:51 <srhb> cabal: /Users/sarah/ar.lproj/Resources/Contents/About Stacks.lpdf/Documents:
09:45:51 <srhb> does not exist
09:45:57 <Siod> thanks
09:46:02 <jfischoff> Siod: np
09:46:13 <geekosaur> you have a broken $HOME somehow
09:46:33 <srhb> ~ sarah$ echo $HOME --> /Users/sarah
09:46:35 <srhb> Looks right
09:46:54 <Siod> now i wonder how i'm supposed to access the embedded icon from within my code
09:47:04 <rwbarton> maybe try 'env | grep Stacks'
09:47:17 <Siod> i think i'm stepping into uncharted waters -- not many haskellers are building windows apps
09:47:19 <geekosaur> hrrrrm
09:47:51 <srhb> rwbarton: Nothing. Quirky.
09:48:28 <geekosaur> "pwd"?
09:48:38 <srhb> /Users/sarah
09:48:46 <geekosaur> but that's just ... strange anyway
09:48:51 <srhb> Yeah, it really is
09:48:55 <pnkbst> Siod: they aren't?  how did you find this out?
09:49:10 <byorgey> I wonder if it's related to http://hackage.haskell.org/trac/hackage/ticket/673
09:49:25 <byorgey> I looked into this once but can't reproduce it and can't see what might be causing it
09:49:36 <DMcGill> Arrows are confusing me, is there a function mapMA :: (Arrow a, Monad m) -> a b c -> [b] -> m [c]?
09:49:40 <jfischoff> Siod: Are there haskell bindings to the windows api? On iOS the icon is just a file on disk which makes stuff like that pretty simple
09:49:59 <srhb> byorgey: Could be. I honestly have no idea. Is cabal supposed to use my home dir and not cwd? What if I try to run it from somewhere else?
09:50:05 <Siod> pnkbst: it's been my experience. i don't see many questions or resources related to building windows apps in haskell, nor do i see apps built in haskell, nor do i see windows apps on hackage, and so on.
09:50:19 <byorgey> srhb: cabal init is not supposed to look anywhere other than the cwd.
09:50:19 <hilhil> Are there any other tricks for pattern matching?  An equivalent of $ would be REALLY nice...
09:50:46 <Siod> also, it appears that most haskell users are on linux
09:50:49 <srhb> byorgey: Yep, works fine if I do it from a blank directory somewhere under $home. how strange!
09:51:01 <rwbarton> hilhil: if you get sufficiently desperate, you can use template haskell/quasiquotation.  that's one of the problems it was original designed to solve
09:51:12 <pnkbst> Siod: hmm... I guess that makes sense, now that you mention it
09:51:13 <hilhil> thanks
09:51:13 <Siod> jfischoff: yeah, it's different in windows. you embedd it within the executable
09:51:14 <geekosaur> actually I see another weirdness there:  "Resources/Contents" is backwards
09:51:26 <byorgey> srhb: well, you shouldn't be running cabal init from your $HOME directory anyway
09:51:27 <rwbarton> maybe the whole thing is backwards!
09:51:43 <srhb> byorgey: I didn't know that. Thanks. :)
09:51:47 <jfischoff> Siod: my guess is that they put in the same place in the data section then.
09:51:49 <rwbarton> /Users/sarah/Documents/About Stacks.lpdf/Contents/Resources/ar.lproj
09:52:01 <geekosaur> that makes much more sense
09:52:05 <jfischoff> Siod: not that that is helpful ;p
09:52:06 <byorgey> srhb: you should run it from some directory which contains code that you want to make into a cabal package.
09:52:10 <srhb> rwbarton: You're right
09:52:11 <HairyDude> speaking of windows haskell development, can anyone suggest a terminal emulator for use with mingw? (not rxvt, it's ugly as sin)
09:52:17 <rwbarton> haha :)
09:52:18 <rwbarton> so weird.
09:52:21 <geekosaur> and means it's just following a broken symlink
09:52:26 <srhb> byorgey: Ah okay, I assumed it would create a directory to match the project name and not pollute cwd. Thanks :)
09:52:40 <parcs`> HairyDude: putty + openssh
09:52:41 <srhb> geekosaur: Macs.... Jeez. :-)
09:52:45 <byorgey> oh, very strange
09:52:51 <HairyDude> parcs`: huh, I never thought of that
09:52:58 <Siod> jfischoff: nah, it might have pointed me in the right directoin: http://hackage.haskell.org/packages/archive/Win32/2.2.2.0/doc/html/Graphics-Win32-Resource.html
09:53:06 <geekosaur> (About Stacks is part of the documentation for the Dock)
09:53:27 <Siod> (isn't very familiar with windows resources even outside of haskell)
09:53:32 <srhb> geekosaur: Yes, I was referring to the weird reversed path to it. :P
09:53:44 <td123> is cabal-install failing at resolving the dependencies? parsec depends on mtl (no specific version) so I'm not sure why it wants to rebuild for a downgrade of mtl :/ http://pastie.org/4068453
09:53:54 <jfischoff> Siod: yeah that looks promising
09:56:03 <benmachine> td123: probably because it wants everything to be compiled against the same version
09:56:58 <benmachine> td123: probably something *else* depends on mtl < 2.1, so in order to use that with parsec, parsec has to use mtl < 2.1 too
09:57:22 <HairyDude> that's certainly the case with cabal-dev
09:57:43 <HairyDude> (pretty sure parsec doesn't depend on cabal-dev, though)
09:58:02 <benmachine> td123: oh, someone had exactly this issue the other day; it's actually because heist hasn't had a new version released yet
09:58:17 <benmachine> td123: it's already fixed upstream but they haven't released it yet
09:58:22 <benmachine> don't know why
09:58:35 <MagneticDuck> I forgot: how do I impose a class restraint on a type variable in a data type?
09:58:46 <benmachine> MagneticDuck: why do you want to?
09:58:56 <benmachine> MagneticDuck: usually we only put class constraints on the functions which use the data type
09:59:03 <MagneticDuck> hm
09:59:12 <HairyDude> data Foo = C a => MkFoo a
09:59:14 <td123> benmachine: wow, thanks for the explanation and an answer :)
09:59:18 <HairyDude> but also, what benmachine said
09:59:22 <byorgey> DMcGill: no, there isn't.  There's not going to be a way to run an arbitrary Arrow, resulting in an arbitrary Monad.
09:59:28 <MagneticDuck> okay then
09:59:37 <MagneticDuck> wait
10:00:15 <MagneticDuck> not "data (Eq a) => Foo a = MkFoo a"?
10:00:27 <MagneticDuck> that implies that you can post restrictions to the constructors themselves
10:00:37 <MagneticDuck> ...I guess you can?
10:00:46 <HairyDude> having to put the constraint on everything that has Foo in its type signature even if it doesn't use what C provides is really annoying.
10:01:05 <MagneticDuck> hm
10:01:24 <benmachine> MagneticDuck: you *can* do what you said, at least in Haskell98
10:01:40 <benmachine> but it was removed from Haskell2011 because it was generally agreed to be useless
10:01:45 <benmachine> or Haskell2010 or something
10:01:48 <benmachine> I forget the details
10:02:12 <benmachine> it just puts constraints on things
10:02:24 <byorgey> srhb: I added this conversation to the ticket https://github.com/haskell/cabal/issues/665
10:02:34 <benmachine> what HairyDude suggested is actually something different, an existential type
10:02:39 <HairyDude> oh
10:03:03 <benmachine> possibly that's not what he *meant* to suggest :P
10:03:07 <benmachine> also possibly you need a forall in there
10:03:09 <HairyDude> yes
10:03:09 <benmachine> I'm not sure
10:03:36 <HairyDude> forall isn't Haskell '98
10:03:51 <benmachine> no, existential types aren't
10:05:28 <mroman> hm.
10:05:40 <mroman> Damn definition of >>=
10:06:47 <HairyDude> I meant to put a constraint on the type, not introduce an existential.
10:07:10 <benmachine> HairyDude: notice how there is no type variable to the left of the =
10:07:14 <benmachine> in your example
10:07:22 <benmachine> that's what made me assume that you meant an existential, I think
10:07:25 <HairyDude> right
10:07:38 <HairyDude> I think I just got the syntax wrong :)
10:08:19 <HairyDude> parcs`: how do I install openssh then? mingw-get doesn't know openssh or ssh
10:09:48 <HairyDude> ah, it's msys-ssh
10:09:55 <HairyDude> msys-openssh
10:14:29 <HairyDude> oh, damn. it doesn't have a server
10:14:32 <adamt> using GHC on Linux, what is the proper way to execute another program, and detach it from the haskell process in such a way that i can shut down the haskell program?
10:15:01 <adamt> (also, i want to get the pid of the spawned process)
10:16:00 <adamt> oh, bbl, gotta get some food. i'll read any answers when i get back. :-)
10:16:34 <HairyDude> adamt: you could do forkOS followed by executeFile, maybe there's a better way though
10:16:39 <HairyDude> er, forkProcess even
10:17:27 <benmachine> I always forget how child processes work exactly
10:17:33 <benmachine> but there's the whole process package http://hackage.haskell.org/package/process
10:17:59 <parcs`> HairyDude: i have no idea. i never tried putty + openssh on mingw, but that would be my choice if i ever were unfortunate enough to have to develop on windows :P
10:18:05 <HairyDude> heh
10:30:38 <noumena> m
10:33:12 <mm_freak> @tell t7 both dependent sums and dependent products…  as said, it's very similar to pisigma (check out hackage)
10:33:13 <lambdabot> Consider it noted.
10:39:13 <DMcGill> is mapA in one of the arrow packages?
10:39:31 <c_wraith> sounds more like Traversible
10:39:36 <DMcGill> @hoogle mapA
10:39:36 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
10:39:36 <lambdabot> Data.Traversable mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
10:39:37 <lambdabot> Data.List mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
10:39:55 <c_wraith> :t Data.Traversible.mapA
10:39:56 <lambdabot> Couldn't find qualified module.
10:40:01 <c_wraith> :t Data.Traversable.mapA
10:40:02 <lambdabot> Not in scope: `Data.Traversable.mapA'
10:40:04 <c_wraith> hmm
10:40:36 <c_wraith> Interesting.
10:40:45 <c_wraith> there is sequenceA and mapM, but not mapA
10:41:06 <HairyDude> right, I have an ssh server running... now how to make it run bash instead of cmd.exe...
10:42:41 <c_wraith> I really don't understand that class
10:44:02 <benmachine> c_wraith: isn't mapA 'traverse'?
10:44:27 <benmachine> @hoogle traverse
10:44:27 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
10:44:28 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
10:44:28 <lambdabot> Control.Parallel.Strategies parTraverse :: Traversable t => Strategy a -> Strategy (t a)
10:44:32 <c_wraith> oh.  I suppose it is.
10:44:46 <c_wraith> I still don't understand the class, though now it's due to naming
10:44:59 <benmachine> well, mapM is for backward compatibility, I suppose
10:45:14 <benmachine> although I actually think it's a better name, arguably, but whatever :P
10:46:03 <c_wraith> DMcGill: in short, I have no clue where "mapA" is defined. What's its type?
10:46:48 <DMcGill> mapA is defined in http://www.cse.chalmers.se/~rjmh/afp-arrows.pdf
10:47:00 <DMcGill> has type ArrowChoice a => a b c -> a [b] [c]
10:47:21 <DMcGill> why does using a case statement in arrow-notation need ArrowChoice?
10:48:09 <DMcGill> I see now, case inside arrow-notation is not the same as case outside it
10:52:21 <morel> there is (,) for creating tuples. why is there no [,]? (like this:  [,] x y = [x,y])
10:52:27 <adamt> HairyDude ++ benmachine: Thanks for the suggestions.
10:52:50 <adamt> HairyDude: I did kinda expect that would be necessary (double-forking somehow)
10:53:03 <HairyDude> adamt: that's what you do in unix anyway
10:53:15 <HairyDude> adamt: there might be a function that wraps them, though. just dunno what it is
10:53:19 <DMcGill> morel: (:[]) x = [x]
10:53:32 <benmachine> morel: what type would it have?
10:53:47 <HairyDude> adamt: if all you want is to run a program and immediately quit, just don't bother to fork first
10:54:04 <adamt> HairyDude: I'm spawning long-lived processes
10:54:34 <morel> DMcGill: of course -.- but what about \x y z -> [x,y,z] ?
10:54:46 <morel> benmachine: well, sometimes you need it.
10:55:15 <benmachine> morel: huh? that doesn't answer my question
10:55:15 <geekosaur> tuples are real things, [] is a convenience notation for (:)
10:55:15 <morel> oh, you asked for the type, oops.
10:55:20 <DMcGill> this looks like a job for templateHaskell, I don't know of these functions in the prelude
10:55:27 <geekosaur> @pl \x y z -> [x,y,z]
10:55:27 <lambdabot> (. ((. return) . (:))) . (.) . (:)
10:55:35 <adamt> HairyDude: i even considered making a small helper that i would run and then forkProcess from etc., it just feels so clumsy, but i suppose that is what it is.
10:55:37 <geekosaur> ...that may be uglier than necessary
10:55:38 <morel> benmachine: [,] :: a -> a -> [a]
10:55:51 <morel> geekosaur: yup
10:55:59 <benmachine> morel: so it takes exactly two?
10:56:10 <morel> benmachine: [,] takes two, yes.
10:56:13 <geekosaur> (bu thne, that's probably what I deserve fpr dragging @pl into it...)
10:56:14 <HairyDude> adamt: well, that's how it's always worked in unix
10:56:15 <morel> benmachine: [,,] takes three.
10:56:19 <benmachine> morel: oh, I see
10:56:22 <morel> just like (,,)
10:56:30 <benmachine> morel: I guess the answer is that it's not really needed
10:56:43 <benmachine> because lists have the [] and : constructors
10:56:51 <Adeon> @pl \x y -> x y
10:56:51 <lambdabot> id
10:56:57 <benmachine> whereas with tuples, each tuple is a different type, so you need a different constructor for each one
10:57:06 <morel> benmachine: it's just syntactic sugar, of course. it's nicer to write, i mean.
10:57:19 <ksf> quick poll: should, in a GUI api, semantics and layout be two syntaxes or one?
10:57:19 <geekosaur> point being that lists are a recursive data type and tuples are not; so tuples are a bit strange in that regard as you have to build them all at once and they all have different types
10:57:30 <ksf> in principle, both are possible.
10:57:32 <benmachine> morel: right, but it's less often/obviously useful with lists than with tuples, due to the way they are used
10:57:53 <ksf> (and even non-ugly unlike fudgets, if you use first class labels)
10:58:23 <shapr> ksf: examples?
10:58:28 <ksf> uh.
10:58:30 <noumena> trying cabal install encoding
10:58:33 <ksf> gimme a couple of minutes.
10:58:38 <noumena> getting cannot satisfy -package Cabal-1.10.1.0
10:58:45 <noumena> mer?
10:59:10 <morel> benmachine: yea, but that's no real argument, actually. i think it appears often enough. and it's adequat to the (,)-syntax, so it'd be easy to remember. also [,] is invalid haskell at the moment, so the new syntax wouldn't cause incompatibility or so…
10:59:41 <benmachine> morel: it's good to keep the language simple, though
11:00:10 <benmachine> morel: I find the fact that there are a million different tuple constructors kind of tedious, but it's the only way we can have tuples, really
11:00:28 <benmachine> morel: with lists, we don't *need* all those constructors, so let's not have them
11:00:36 <benmachine> morel: it's not like the lambda forms are that upsetting to write
11:00:50 <morel> benmachine: yea, agda's (mixfix) syntax is the best solution here, actually. agda allows very different symbols in function identifiers, e.g.. that'd solve all issue =)
11:00:55 <morel> *issues
11:01:11 <benmachine> agda does have its own problems though, like requiring way more whitespace than haskell
11:01:11 <robinbb> Anyone here know if I should be using the 'thrift' package, or the 'Thrift' package?
11:01:27 <benmachine> and possibly being harder to parse in general
11:01:37 <morel> benmachine: dunno if thats a real problem… whitespaces…
11:01:44 <Siod> what's the best way to do something like `wasJohnExecuted = map (executeIfJohn) names`? so, you're looping through a list, and you look for a specific name. if name found, stop looping, execute, then return success.
11:01:44 <morel> benmachine: yea, that's right…
11:02:12 <benmachine> Siod: the "find" function from Data.List will get you most of the way there
11:02:17 <benmachine> :t find
11:02:18 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
11:02:24 <Siod> benmachine: assume i can't use find
11:02:35 <benmachine> Siod: why would I assume that? :P
11:02:46 <Siod> benmachine: instead of looping through names i'm looping through People
11:03:03 <morel> Siod: how does that matter?
11:03:08 <benmachine> that's not a problem
11:03:28 <Siod> i don't have a way to use find on the list of things i'm mapping through
11:03:50 <benmachine> I don't follow; if you can use map you can use find
11:03:57 <benmachine> maybe a code sample would help?
11:04:11 <Siod> it's complicated
11:04:36 <ksf> shapr, http://hpaste.org/69817
11:04:53 <ksf> (modulo nicer value-level type-literal support)
11:05:30 <ksf> (and monad or not doesn't really matter)
11:05:34 <morel> Siod: maybe write your own find then? (which's kinda senseless…)
11:05:57 <ksf> the thing is, what frame a widget is in *is* part of its semantics.
11:07:34 * MagneticDuck is away: water polo day
11:08:29 * ksf wants first-class bindings.
11:08:35 <hilhil> Siod: can you write a ifJohn predicate of type signature People -> Bool?
11:08:44 <hilhil> *isJohn predicate
11:10:57 <shapr> ksf: neato
11:11:19 <ksf> well, it's examples, they don't actually work
11:13:13 <ksf> hmm. I guess I should take the second approach, basically because a) it's easy to support let-bound references in addition to the label references and b) it'd finally make me care about records.
11:14:46 <shapr> ksf: Right, I just wanted to see a demo of what it would look like
11:16:20 <ksf> and value-level references via syb or similar should probably be possible, too, for the more dynamic stuff.
11:18:37 <ksf> and deep embedding should get me around all that reactive construction monad punk.
11:19:15 <ksf> time to write a GADT.
11:21:43 <pooya72> anyone have experience using readFile on a .docx ?
11:22:04 <c_wraith> why would that be different from using readFile on anything else?
11:22:11 * morel never wrote/needed a real GADT (but used GADT-syntax).
11:22:53 <ksf> they're *very* useful for deeply embedded DSLs
11:23:16 <ksf> as you can have eg. an EDSL AST that's an intstance of applicative.
11:28:11 <morel> what's an AST again?
11:28:54 <ciaranm> an Alternating Spaghetti Twister
11:28:58 * morel . o O ( „Anrufsammeltaxi“ (german) == hailed shared taxi )
11:29:59 <aristid> morel: abstract syntax tree :P
11:30:05 <morel> ah :D
11:33:54 <pooya72> c_wraith the difference is that this one isn't working :). I'm trying a readFile on a .docx with english diacritics and some arabic. I can read and write the file but then I can't open the file with word.
11:34:14 <pooya72> c_wraith: I'm using UTF8 readFile
11:35:21 <c_wraith> well, is the problem in reading the file or writing it?
11:35:24 <rwbarton> i thought a .docx was a bunch of xml files zipped together
11:36:55 <rwbarton> so that in particular it is a binary file, not utf-8 encoded text
11:37:59 <pooya72> c_wraith: yes, that might make the problem in writing it ...
11:38:13 <pooya72> rwbarton: so what should i use...
11:38:40 <pooya72> normal readFile gives me this error: hGetContents: invalid argument (invalid byte sequence)
11:39:06 <rwbarton> well first you should probably try to determine what a .docx file is by more reliable means than what a random person on the internet told you
11:40:21 <ksf> pooya72, if you're on windows you might need to force binary mode.
11:40:33 <pooya72> ksf: no I'm on a mac
11:40:41 <ksf> windows mangles line endings otherwise.
11:41:04 <rwbarton> try opening the .docx file in a text editor to see what's inside
11:41:12 <pooya72> rwbarton: they're not random, they're my irc friends **forever alone**
11:41:16 <pooya72> ;)
11:41:27 <ksf> you shouldn't be using any readFile or writeFile that uses string, anyway.
11:41:36 <fmap> is there a way to know if my type signature isn't the most general?
11:41:57 <ksf> the bytestring versions are your friend, those operate properly on streams of Word8
11:42:11 <ksf> fmap, let ghc infer it.
11:42:16 <pooya72> ksf: okay thanks.
11:42:18 <ksf> it always infers the most general.
11:43:08 <rwbarton> pooya72: so you have a Word document and you want to replace some Unicode characters with other Unicode characters?
11:43:15 <rwbarton> is this still the same program?
11:43:19 <pooya72> rwbarton: yes :)
11:43:35 <ksf> pooya72, I wager your writeFile is truncating all those parsed-as-unicode Chars to Word8 due to locale settings or something.
11:43:43 <fmap> ksf: nice, thanks
11:44:20 <rwbarton> assuming my recollection is correct, you'll want to use some library for reading/writing zip files
11:47:27 <pooya72> ksf: maybe. maybe I should look at pandoc, see what he did.
11:47:30 <rwbarton> of which there appear to be several on hackage
11:47:41 <pooya72> rwbarton: thanks.
11:48:35 <ezyang> Anyone know if Criterion can be used on external data sets?
11:54:05 <pooya72> so far i'm just having word export to html, then changing the html
11:58:42 <importantshock> Under what circumstances should I prefer MonadReader and/or MonadWriter to StateT or MonadState?
11:59:31 <shachaf> Under the circumstances that what you're doing happens to match what they're for.
11:59:45 <copumpkin> MonadReader always reads the same thing
11:59:54 <copumpkin> MonadWriter writes are unobservable within the monad
12:00:05 <copumpkin> MonadState lets earlier writes influence later reads
12:00:25 <copumpkin> that's roughly the distinction
12:00:28 <shachaf> copumpkin: There's also the whole "monoid" thing for MonadWriter.
12:00:42 <shachaf> It's pretty different from writing in MonadState (unless you add a primitive for it, I guess).
12:00:45 <c_wraith> except that read lets you run an action in a modified scope
12:00:51 <c_wraith> err, MonadReader
12:00:57 <copumpkin> I said "later"
12:00:59 <c_wraith> and MonadWriter lets you get the current value
12:01:07 <shachaf> Reader is pretty much just a function.
12:01:20 <importantshock> okay, I'm seeing the similarities now
12:01:27 <shachaf> c_wraith: It does?
12:01:55 <rwbarton> the class probably does
12:02:01 <shachaf> Hey, MonadWriter got writer :: (a,w) -> m a
12:02:22 <rwbarton> the other class
12:02:23 <importantshock> Now to decide whether I want destructive updates or just to run subcomputations with local :: (r -> r) -> m a -> m a
12:02:48 <importantshock> leaning towards the latter, as this is a pretty straightforward state object
12:02:51 <copumpkin> which other class?
12:02:56 <importantshock> err former
12:03:44 <importantshock> thanks copumpkin, shachaf, c_wraith
12:03:48 <copumpkin> :)
12:03:49 <copumpkin> np
12:03:51 <c_wraith> Hmm. listen is what I was thinking of, but it's not quite what I thought.
12:03:56 <c_wraith> pass is *still* confusing as heck
12:04:06 <shachaf> @ty pass
12:04:07 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m (a, w -> w) -> m a
12:04:24 <shachaf> Doesn't it do the obvious thing?
12:04:27 <c_wraith> I mean, I can see what it does
12:04:30 <c_wraith> I can't see *why*
12:04:32 <shachaf> Or is the confusing part "when would you ever want to use it?"?
12:04:41 <shachaf> Ah. Yes.
12:04:50 <c_wraith> Or why it has that particular interface
12:05:42 <shachaf> Well, it's used to implement censor.
12:05:45 <shachaf> @ty censor
12:05:46 <lambdabot> forall w (m :: * -> *) a. (MonadWriter w m) => (w -> w) -> m a -> m a
12:06:02 <joeyh> <weasel> haskell comes with a scanning tunneling microscope?
12:06:07 <c_wraith> :t censor $ const mempty
12:06:09 <lambdabot> forall (m :: * -> *) a a1. (MonadWriter a1 m) => m a -> m a
12:06:32 <shachaf> -- tell is like tell on the MUD's it shouts to monad what you want to be heard. The monad carries this 'packet' upwards, merging it if needed (hence the Monoid requirement)}
12:06:37 <c_wraith> but why isn't censor the interface?  what extra power does pass give you?
12:06:46 <Siod> anyone know how to send text to a text control in wxhaskell?
12:06:52 <Siod> i want to make an output box
12:07:05 <MtBeard> Hay guise.  So Haskell reads ASCII from Stdin and Stdout, and I really want to send it some good ol' unicode.  How about that?
12:08:03 <shachaf> MtBeard: You should ask a question like "I'm doing this. I expect this. I got this instead."
12:08:30 <rwbarton> it should Just Work assuming the conditions are right
12:08:54 <shachaf> As far as I know the Haskell report doesn't say anything about ASCII anywhere.
12:09:23 <shachaf> Well, "However, source programs are currently biased toward the ASCII character set used in earlier versions of Haskell."
12:09:51 <Cale> MtBeard: have you tried reading/writing UTF-8?
12:10:03 <MtBeard> shachaf: I'm sending a UTF16 string to Haskell through Stdin, doing something and returning the result through Stdout
12:10:24 <Cale> MtBeard: I believe what the default behaviour is in GHC is to read/write whatever your current locale dictates is the appropriate encoding
12:10:43 <Cale> On Windows, this might be something derpy like codepage 1252
12:10:53 <MtBeard> indeed
12:11:06 <Cale> But if you're on almost any recent Linux distribution, you can expect it to be UTF-8
12:11:17 <MtBeard> Alas, I work on the .NET stack
12:11:24 <MtBeard> *ducks*
12:11:35 <TheLemonMan> hrm, i have written some simple code using low levels socket but it seems to hang when reading
12:11:50 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#g:23
12:12:09 <Cale> You can use those to set/check the current text encoding
12:12:51 <ksf> on linux it depends on the locale.
12:13:03 <ksf> well, depending where it comes from.
12:13:05 <Cale> ksf: Oh, does it not depend on the locale on Windows?
12:13:11 <ksf> stdin is, by definition, bytes.
12:13:23 <Cale> I mean the default TextEncoding
12:13:46 <ksf> the default for linux is LC_CTYPE=POSIX
12:13:52 <ksf> which is ASCII
12:13:55 <Cale> Is stdin really set to binary mode on Linux?
12:13:58 <Cale> wat
12:14:06 <ksf> there's no non-binary mode in unix
12:14:18 <MtBeard> "Haskell has excellect handling of unicode, the Char type covers all unicode chars. Unfortunatly, there's no possibility to read or write something to the outer world in an encoding other than ascii due to the lack of support for encodings. This library should help with that."
12:14:23 <MtBeard> ^ from the encoding hackage
12:14:32 <rwbarton> that was probably written in like 2003 or something.
12:14:34 <Cale> ksf: I'm not talking about POSIX-standardised crap :)
12:14:36 <geekosaur> MtBeard, that statement is obsolete
12:14:49 <Cale> ksf: I'm talking about the GHC I/O implementation
12:14:50 <ksf> POSIX is the default locale.
12:14:55 <MtBeard> Plus has a mispelled word.
12:15:07 <Cale> GHC does text encoding by default usually
12:15:07 <MtBeard> irony..
12:15:07 <ksf> and the implementation has a look at the locale to decide what it's going to do.
12:15:16 <geekosaur> encoding support was added to ghc in the later 6.x releases
12:15:22 <MtBeard> Good to hear.
12:15:26 <ksf> when it's POSIX, it's going to choke on unicode.
12:15:40 <ksf> ...which is why I have LC_CTYPE=en_GB.utf8
12:15:43 <ksf> (rest POSIX)
12:15:51 <tgeeky> hm
12:16:06 <Cale> lol, there's hSetBinaryMode, but no hGetBinaryMode
12:16:51 <MtBeard> So, the standing suggestion is to try hSetEncoding?
12:16:55 <Cale> yes
12:17:11 <Cale> hSetEncoding stdin utf8
12:17:14 <Cale> hSetEncoding stdout utf8
12:17:51 <ifnspifn> (preface: https://gist.github.com/2910432) I've got a main block that, ideally, reads in a text file with a number of newlines, and performs the lines function on the readFile result. I then pass this to a function which is designed to take parameters of type [String], but I'm getting an error stating that the actual type of the parameters is String. Isn't :t lines = String -> [String]?
12:17:54 <ksf> MtBeard, in general, yes.
12:18:20 <MtBeard> Alright then. Thanks lads and (hopefully) lasses.
12:18:22 <ksf> but there's also a good reason to read bytes and do the decoding yourself, and that's error handling.
12:18:26 <Cale> MtBeard: Note that your terminal emulator is going to also need to understand/produce UTF-8 though.
12:18:30 <TheLemonMan> ill pay a beer to anyone that finds out why this socket wont read http://hpaste.org/69820
12:18:55 <elliott> Cale: It'd be better to set it to utf16 on Windows, I think...
12:19:07 <elliott> Unless cmd.exe actually uses UTF-8.
12:19:08 <MtBeard> I've actually got a C# wrapper
12:19:10 <elliott> That would be weird.
12:19:19 <MtBeard> should work
12:19:29 <MtBeard> *should*
12:19:32 <Cale> or, sure, if it's set to UTF-16, you can use that, though UTF-16 is the worst Unicode encoding ever.
12:19:44 <MtBeard> whoa whoa, let's not point fingers.
12:20:10 <elliott> Well, it is.
12:20:28 <MtBeard> Maybe Bad
12:20:46 <Cale> It has the Latin-1 incompatibility of UTF-32, and the variable character length of UTF-8
12:21:08 <geekosaur> ifnspifn, you have a severely incorrect notion of what "return" does
12:21:09 <elliott> UTF-8 isn't Latin-1-compatible, is it?
12:21:11 <elliott> Just ASCII-compatible.
12:21:17 <ksf> even UTF-32 is variable length.
12:21:21 <elliott> ksf: It is?
12:21:23 <ksf> combining diacritics.
12:21:33 <elliott> ksf: "Variable length" in terms of encoding a single codepoint.
12:21:39 <elliott> A character/glyph/whatever is something else entirely.
12:21:59 <geekosaur> utf32 is also variable length when it comes to characters outside the BMP
12:22:03 <elliott> Actually I think a character is just a valid codepoint, so maybe it's not something else entirely.
12:22:05 <elliott> geekosaur: No.
12:22:15 <elliott> Unicode-with-astral-planes is 22 bits or so.
12:22:22 <Cale> Latin-1 is just the first 256 code points of Unicode.
12:22:24 <elliott> UTF-32 encodes every codepoint in the same amount of space.
12:22:25 <ion> UTF-32 is also variable length when it comes to characters outside UTF-32.
12:22:33 <elliott> Cale: Yes, but UTF-8 does not encode 128 of those in the same manner as Latin-1 does.
12:22:39 <elliott> Because it uses the eighth bit for its own nefarious purposes.
12:22:42 <ifnspifn> geekosaur: would finding out what the hell monads actually do fix this, then?
12:22:47 <elliott> Indeed, if it *was* Latin-1 compatible, there would be no room for the other characters!
12:22:49 <Cale> oh, right
12:22:50 <Cale> yes
12:23:38 <Cale> Well, there would be room, but the encoding would have to go differently and be less efficient
12:23:57 <geekosaur> it would help, but just for starters you should get rid of the semicolon and everything following on lines 2 and 3.
12:24:00 <elliott> Well, it's encoding into bytes. If you use 256 of those bytes to represent a Latin-1 character, you have none left to use for anything.
12:24:08 <elliott> I guess you could use the NUL byte, but that's part of Latin-1 too.
12:24:20 <Cale> Not all 256 bytes are valid Latin-1 though, are they?
12:24:30 <elliott> Aren't they?
12:24:35 <elliott> Hmm.
12:24:38 <elliott> Apparently not.
12:24:42 <elliott> OK then.
12:24:54 <benmachine> iso-8859-1 goes from a0 to ff
12:24:56 <elliott> I guess I'm thinking of the various extensions to Latin-1.
12:25:14 <benmachine> so you've still got 80 to 9f free
12:25:36 <Cale> +7f
12:25:52 <benmachine> 7f is ascii isn't it?
12:26:07 <elliott> > chr 0x7f
12:26:08 <lambdabot>   '\DEL'
12:26:16 <elliott> I believe so.
12:26:17 <Cale> oh, it's \DEL in ASCII
12:26:43 <Cale> are the control characters actually specified by 8859-1?
12:27:21 <elliott> http://en.wikipedia.org/wiki/ISO/IEC_8859-1#Codepage_layout
12:27:27 <ion> The Microsoft™ CP-1252 is a superset of ISO 8859-1 that adds symbols to 0x80–0x9f. It’s usually a good idea to use CP-1252 as a fallback encoding for incoming IRC lines instead of 8859-1 because you’ll decode both 8859-1 *and* what many Windows™ clients output correctly.
12:28:16 <elliott> ion: I think encouraging the extermination of terrible encodings is the one exception to Postel's law.
12:28:19 * Cale just sets it to hard UTF-8
12:28:47 <elliott> You know what's great? XChat's default outgoing encoding.
12:28:55 <elliott> It encodes everything as Latin-1, except when the character isn't in Latin-1.
12:28:57 <elliott> Then it encodes it in UTF-8.
12:29:00 <elliott> I think.
12:29:02 <elliott> It's really awful.
12:29:14 <Phlogistique> elliott: god I thought for one second you were serious
12:29:20 <elliott> Phlogistique: I *am*.
12:29:30 <elliott> It's called "IRC", look at your sever settings and check what the encoding is set to.
12:29:41 <elliott> (That is, it calls the encoding "IRC".)
12:29:44 <Phlogistique> yes; I thought you were serious when you said that it's "great"
12:29:47 <elliott> Ah.
12:29:57 <Phlogistique> elliott: and I was about to unleash a fury of insults
12:30:01 <elliott> Well, I mean... it's certainly original.
12:30:03 <elliott> You can't deny that.
12:30:20 <Iceland_jack> Originality and character encodings...
12:30:31 <Siod> why do wxhaskell text controls beep on enter?
12:30:59 <hpaste_> applicative pasted “readFile ifnspifn” at http://hpaste.org/69821
12:31:36 <applicative> ifnspifn  ^^^ this is made to be as close to what you wrote  as possibe
12:33:09 <applicative> ifnspifn: actually, its still wrong, since were not doing anything in the main do block.
12:34:59 <hpaste_> applicative annotated “readFile ifnspifn” with “readFile ifnspifn (annotation)” at http://hpaste.org/69821#a69822
12:35:29 <Siod> where can i get help with wxhaskell
12:39:47 <kkyqqp> is there a flag for loading ghc that does the same thing as :set +s, so I don't have to set it every time?
12:40:07 <elliott> put set +s in your ~/.ghci
12:40:21 <kkyqqp> oh, right, thanks!
12:41:21 <bindy> Hi everybody! Any Snap framework users around? Please, do you know how to use snaplet-hdbc inside of a Splice?
12:42:51 <applicative> bindy: there is #snapframework  in case no one knows. I think it's not too active though.
12:43:25 <ozataman> applicative: that's not true! we're pretty much always in that channel!
12:43:30 <saiko-ch_> bindy: applicative: it is too active :P
12:43:42 <ozataman> bindy: come on over to #snapframework
12:43:50 * applicative covers himself with shame and ashes
12:43:53 <saiko-ch_> hahah
12:43:56 <ozataman> :-)
12:44:54 <bindy> oh, thanks guys, i will try that channel!
12:45:51 <adamt> i'm sure you're welcome to join #yesod as well when you come to your senses >:)
12:46:04 <saiko-ch_> hah
12:54:58 <shapr> This is cool if you haven't seen it: http://apfelmus.nfshost.com/blog/2012/06/07-forklift.html
12:55:20 <shapr> apfelmus says the most general MVar message type is "m a".
13:00:04 <srhb> Can I make cabal add the build-depends files automatically to the .cabal file? It seems to be able to warn about them just fine..
13:04:00 <byorgey> srhb: not yet, sadly
13:04:10 <byorgey> though that is definitely on the list of features to add
13:04:28 <adamt> Can anybody figure out how to actually create a ManagerSettings based on the documentation here?: http://hackage.haskell.org/packages/archive/http-conduit/1.4.1.8/doc/html/Network-HTTP-Conduit.html#t:ManagerSettings
13:04:36 <srhb> byorgey: Ok :) Does seem like it would be useful
13:04:43 <byorgey> srhb: it would indeed.
13:05:51 <byorgey> adamt: probably something like  def { managerConnCount = 3, managerCheckCerts = foo }
13:06:04 <applicative> adamt use def { blah = ...
13:06:09 <applicative> like byorgey said
13:06:38 <byorgey> adamt: the confusing part is because the ManagerSettings constructor is not exported but the field names are
13:06:44 <byorgey> but that means Haddock lists them separately
13:07:11 <byorgey> so I am just guessing that managerConnCount and managerCheckCerts are actually fields of ManagerSettings, from their types and the fact that they're listed right next to it
13:07:15 <byorgey> but you could look at the source to be sure
13:07:59 <byorgey> adamt: note, if you just want the default ManagerSettings, then you can just write   def
13:08:13 <byorgey> or def { managerConnCount = 214 } if you only want to override the connection count, etc.
13:08:40 <adamt> hmm, ok, great guys, hopefully that'll make it work.
13:09:24 * applicative had  not noticed this data-default package before.  somehow he opposes it
13:09:35 * hackagebot testing-feat 0.2 - Functional enumeration for systematic and random testing  http://hackage.haskell.org/package/testing-feat-0.2 (JonasDuregard)
13:10:35 <adamt> hey it seems to work, thanks.
13:11:31 <byorgey> applicative: why?
13:11:37 * byorgey uses it too
13:11:42 <ion> Speaking of IRC charsets, i wrote this snippet for a friend who wanted to convert mixed-charset IRC logs into UTF-8. It’s a bit of a quick hack (see the turbl use of “error” in “convert”), but it did the trick. Perhaps i’ll make it a bit prettier the next time i need it (if ever). https://github.com/ion1/lineconv/blob/master/LineConv.hs
13:12:09 <applicative> byorgey: maybe i take it back, but why is e.g. def::Int 0?
13:12:24 <byorgey> what else should it be?
13:12:25 <applicative> I demand that it be 1
13:12:32 <byorgey> then make a newtype
13:13:04 <benmachine> byorgey: I dislike data-default too
13:13:18 <benmachine> I don't feel there is any really coherent notion of a "default" value
13:13:46 <benmachine> like, is Nothing or Just def more default?
13:13:51 <applicative> okay.  No, it was this that surprised me, how is any work saved by making a class instance instead of defining defaultManagerSettings as usual for this kind of record
13:13:52 <byorgey> I also don't think there is any coherent notion of a "default" value *in general*.
13:13:59 <byorgey> but that's not how it is generally used.
13:14:15 <copumpkin> NULL!!!
13:14:15 <benmachine> byorgey: but I think it's a fair point that 0 isn't a particularly default Int
13:14:26 <benmachine> and that instance comes with the package
13:14:27 <byorgey> applicative: because you (and your users) don't have to remember the name "defaultManagerSettings".  That's all.
13:14:30 <benmachine> anyway, how do you use it?
13:14:38 <byorgey> benmachine: I agree with you.
13:14:45 <applicative> it seems like it was originally intended to be  something like a class Pointed a where...
13:14:57 <byorgey> I use it in the same way http-conduit does, for records representing some sort of configuration
13:15:09 <benmachine> applicative: I don't like Pointed, either
13:15:38 <benmachine> byorgey: that makes a *sort* of sense. but on the other hand, defaultManagerSettings is easier for *readers* than just def
13:16:29 <byorgey> benmachine: I suppose.  But in a terrible hack which I nonetheless am quite fond of, I define  with = def, so you can write   someFunction with { blah = foo, bar = baz }
13:16:38 <byorgey> that's not hard to read.
13:16:44 <byorgey> once you are used to the idiom.
13:16:51 <benmachine> byorgey: heh, cute
13:17:24 <benmachine> okay, I'll accept that Default has some legitimate uses, but I maintain that it is often used in non-legitimate ways
13:17:46 <byorgey> benmachine: that may be.  Do you have any specific examples in mind?
13:18:11 <applicative> byorgey: I'm not following this hack, you mean you define lots of functions :: MyRecord -> x  by means of def
13:18:16 <benmachine> byorgey: I'll go look up some reverse deps, sec
13:18:40 <byorgey> applicative: no, the entire hack is defining    with = def
13:19:09 <byorgey> then when you have   someFunction :: Foo -> Blah  where Foo is an instance of Default, you can call it like so:    someFunction with { ... }
13:19:11 <applicative> ah, somehow it is so perverse it was hard to read
13:19:16 <byorgey> hehehe
13:19:44 <benmachine> byorgey: http://hackage.haskell.org/packages/archive/pointed/2.1.0.2/doc/html/Data-Pointed.html I don't think the way Default is used here is very helpful
13:20:07 <benmachine> (in fact, I don't think Pointed is a useful abstraction, so possibly I'm pointing the finger wrong here)
13:20:08 <byorgey> benmachine: I agree, but then, no one really likes Pointed anyway.
13:20:24 <benmachine> okay, fair enough, I'll try to find a different example
13:20:26 <byorgey> even its author,
13:23:54 <benmachine> byorgey: http://hackage.haskell.org/package/hack2 the way this uses Default is sort of questionable, at least
13:24:04 <benmachine> imo
13:24:19 <benmachine> well
13:24:22 <benmachine> maybe, maybe not
13:24:30 <benmachine> I'm not convinced it adds to the usability of the library
13:24:38 <benmachine> what it does add to is the dependency list
13:24:43 <byorgey> benmachine: I think the instance for Env makes sense
13:25:00 <benmachine> okay, granted
13:25:07 <benmachine> but RequestMethod?
13:25:12 * MagneticDuck is back (gone 02:17:37)
13:25:19 <byorgey> but it seems the instance for Env is defined in terms of instances for its component types
13:25:29 <byorgey> like RequestMethod and HackUrlScheme
13:25:30 <benmachine> it doesn't *need* to be
13:25:36 <byorgey> right, I think it shouldn't be
13:26:06 <byorgey> those types have sensible default values *only* in the context of an Env record
13:26:26 <byorgey> by themselves it doesn't make all that much sense,
13:26:38 <byorgey> anyway, I think we are in agreement.
13:27:40 <benmachine> I think we're at least in not-disagreement about what the correct usage of Default is
13:27:52 <benmachine> (how intuitionistic of me :P)
13:28:08 <benmachine> but what I was trying to show was that it was often not used in the way that we... don't-disagree on
13:28:26 <byorgey> haha, fair enough =)
13:29:00 <byorgey> I'm willing to believe you, I just haven't seen many such uses myself
13:29:17 <byorgey> but I really haven't seen that many uses period.
13:29:23 <benmachine> heh, sure
13:29:46 <benmachine> I think if we agree that point doesn't have one, I'm happy
13:30:18 <byorgey> "if we agree that point doesn't have one" -- ?
13:30:40 <benmachine> sorry, I was being silly
13:30:45 <benmachine> I meant wrt Pointed
13:30:52 <byorgey> oh, right =)
13:30:58 <benmachine> I tried to permute the phrase such that it had a pun in it but then it didn't make any sense anymore
13:31:02 <benmachine> but then I said it anyway
13:31:07 <byorgey> ohhh, hehe, I get it now =)
13:31:19 <kane77> I feel very stupid.. I have function [a] -> Int -> Int -> Bool and I want to find if for all x from [1,2,3] and y from [4,5,6] f xs x y is true.. (so f xs 1 4 && f xs 2 5 && f 3 6)
13:31:30 <byorgey> Pointed has no point.  right.  we agree. =)
13:32:24 <benmachine> woo
13:32:25 <Clint> kane77: just those three, not permuted?
13:32:27 <tgeeky> byorgey: noesss!
13:32:30 <merijn> kane77: zipWith? But maybe I understand it wrong?
13:32:35 <merijn> :t zipWith
13:32:36 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
13:32:49 <tommd> so... and [f xs x y | x <- [1..3], y <- [4..6]] ??
13:32:52 <tgeeky> byorgey: pointed has a point if you want a different pure than you'd normally expect
13:33:06 <luite> > read "()"
13:33:07 <lambdabot>   ()
13:33:12 <luite> ah
13:33:19 <byorgey> tgeeky: example?
13:33:20 <tgeeky> luite: everything about () is ()
13:33:21 <tommd> Depends on your answer to Clint, tough.
13:33:32 <merijn> "zipWith (f xs) x y" or something?
13:33:46 <merijn> Although, I guess that doesn't check they're all true
13:33:50 <merijn> :t all
13:33:51 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
13:33:51 <kane77> Clint, nope, just zip of those lists..
13:33:52 <luite> tgeeky: in ghci read "()" is ambiguous, show (read "()") does work though
13:33:59 <tommd> merijn: see 'and'
13:34:03 <merijn> :t and
13:34:04 <lambdabot> [Bool] -> Bool
13:34:10 <tgeeky> byorgey: pure x = fmap (\_ _ _ -> (x,x,x)) ()
13:34:18 <luite> tgeeky: at least with the default settings, i guess lambdabot is configured slightly different
13:34:37 <merijn> kane77: Something like this? "and . zipWith (f xs) xs ys"
13:34:58 <kane77> merijn, yes I guess zipWith would work!
13:35:10 <kane77> and and
13:35:13 <byorgey> tgeeky: eh? that doesn't even type check
13:35:42 <ksf> ...it doesn't even kindcheck.
13:36:18 <kane77> that's why I feel so stupid when using haskell, I knew about zipWith, but it would not pop up..
13:36:26 <tgeeky> byorgey: whoops.
13:36:51 <merijn> kane77: Practice and hoogle are your friends :)
13:37:37 <benmachine> kane77: I think when you are a novice it's fine to write out the recursive longhand way of doing it in your code
13:37:57 <benmachine> kane77: as you get more experience and read more code by other people, you'll start spotting the patterns and replacing them
13:38:24 <benmachine> but that's just rote learning, it's not really what haskell is All About
13:39:19 <kane77> ben, yes, it's learning, but I guess with procedural languages things are more straightforward, although much less elegant
13:39:50 <merijn> kane77: I think it's more that haskell's abstraction lends itself to much more code reuse than most imperative languages I've encountered
13:40:00 <byorgey> tgeeky: I'm still not sure exactly what you're getting at, but I suspect the real answer is "make a newtype", not "use Pointed"
13:40:16 <benmachine> yeah, that's what I love about it so much, I never have to repeat myself
13:40:17 <merijn> Which means that to write actual idiomatic haskell you need to know a significant fraction of the stdlib and some libraries
13:40:49 <benmachine> kane77: I'm just saying, don't beat yourself up for not thinking of zipWith :P
13:40:56 <tgeeky> byorgey: I'm messing around with lambdabot right now trying to figure it out
13:40:58 <merijn> I actually get sort of annoyed when I have to write code in haskell, often times you can just pillage generic parts from monad-loops and things :p
13:41:44 <byorgey> tgeeky: I've got to leave to go pick up my son, so if you figure it out write it down somewhere and tell me later =)
13:41:55 <tgeeky> byorgey: okay thanks
13:42:24 <kane77> sure, I kind of like "inventing" ways of doing things different way.. it's like when I first saw the product [1..n] version of factorial :)
13:44:22 <merijn> kane77: Are you familiar with Hoogle yet? That's a great way to learn all these things in the Prelude and libraries?
13:44:23 <HairyDude> great. yesod doesn't work in cygwin.
13:44:40 <HairyDude> (that is, mingw yesod)
13:44:51 <kane77> merijn, yes, but sometimes I don't even know what to search for..
13:45:58 <merijn> kane77: Yeah, that's usually when I use @hoogle in here so someone will point out what I actually want ;)
13:46:11 <kane77> :)
13:48:23 <statusfailed> Is there a way to get quickcheck to generate arbitrary "Integral" values?
13:48:38 <kane77> is there actually much demand for haskell on "profesional" level?
13:48:42 <statusfailed> it's complaining about ambiguous types, I guess that's because it doesn't know which type to pick: can it be made to try lots of types?
13:48:54 <merijn> kane77: Just don't tell people you're using Haskell :>
13:49:05 <merijn> Although whether that flies depends on your job
13:50:07 <benmachine> kane77: I've used it for generic data processing before
13:50:08 <kane77> if I was starting some project I would seriously consider haskell..
13:50:10 <tac-tics> kane77: compared to Java or Python, not really.
13:50:30 <benmachine> someone gave me a mysql database for a website and said "find all the pages with inappropriate HTML tags"
13:50:34 <tac-tics> kane77: Haskell is pretty darn stable, though, and well-suited for many kinds of real-world projects
13:50:40 <benmachine> so I wrote me a little haskell app to do that
13:50:42 <merijn> kane77: I've never really liked calling/considering myself an "X programmer" (regardless of the value of X). I'm working on a simulator which is written in haskell, mostly because I wanted to write some non-trivial haskell and no one cares about the language I use :p
13:50:46 <benmachine> which was fine because no-one else had to deal with it :p
13:51:55 <merijn> kane77: So it depends a bit on the job you have/want to have :)
13:52:27 <kane77> yes, I learn about haskell and i find it great.. it's stable, testable, relatively fast and memory efficient.. I just don't see why it's not that commercially successfull as it ought to be..
13:53:07 <merijn> Because popularity is no correlated with quality, unfortunately
13:53:09 <tac-tics> kane77: "commercially successful" does not depend so heavily on those factors
13:53:21 <merijn> And java code monkeys are cheaper/easier to replace
13:53:26 <nk_> has functional programming become more mainstream yet or is it still considered 'the future'?
13:53:29 <tac-tics> stability, yes... but PHP is not fast, not well suited for testing, and not memory efficient -- but it's still very popular
13:53:35 <tac-tics> Most "popular languages" are accidents of history
13:53:48 <mikeplus64> kane77: needs more documentation / more people need to know about hoogle / hackage
13:54:50 <merijn> It's the difference between a job described as "X programmer" or "problem solving", where the last one usually ends up having fancy complicated names and better pay
13:55:55 <tac-tics> merijn: add on a "consultant" and your salary increases by an order of magnitude :)
13:56:01 <mikeplus64> if anyone here doesn't have documentation enabled in their cabal config then you're missing out on a wonderful world of local documentation btw
13:56:16 * kane77 is java code monkey
13:56:25 <ashashwat> Does reverse on a list ( which is singly linked list ) works in-place.  How can we find out time and space complexity.  ( reverse = foldl (flip (:)) [] as defined in Prelude, gave me no idea. )
13:56:29 <dcoutts> mikeplus64: glad it's working nicely for you
13:56:39 <Phlogistique> why do we have hackage where we could use nix for everything?
13:56:51 <c_wraith> ashashwat: in-place seems exceptionally unlikely for an immutable data structure
13:57:00 <dcoutts> Phlogistique: they are not alternatives to each other
13:57:37 <ksf> hmmm can I have typeclass instances for a type family?
13:57:39 <dcoutts> Phlogistique: you can use hackage with nix, with hackage as the archive of source packages, and nix as the way to manage installed instances and multiple environments
13:57:51 <Phlogistique> dcoutts: oh, that's nice
13:58:04 <kane77> actually i remember when we learned about haskell on university and I thought "what a wierd language".. but that was very early in my programming career so I could not appreciate all the niceness..
13:58:08 <tommd> ksf yes.
13:58:15 <dcoutts> Phlogistique: you might say that cabal and nix are alternatives, which is more true.
13:58:21 <Phlogistique> I was actually trying to setup a new GHC on an old Ubuntu
13:58:31 <merijn> ashashwat: Depending on the circumstance it might even be amortized O(1), I guess? due to laziness
13:58:35 <Phlogistique> so I figured out Nix sounds like the easiest way
13:59:01 <ksf> tommd, those instances being those of the result type, without writing tons of boilerplate?
13:59:06 <dcoutts> Phlogistique: the main thing that makes it not a complete solution is that nix is only for unix systems
13:59:10 <ashashwat> merijn: How ?
13:59:14 <merijn> ashashwat: Not in place, though. (Actually, on second thought I doubt my previous amortised remark)
13:59:15 <Phlogistique> dcoutts: oh, indeed
13:59:29 <kane77> and now I switched to xmonad and discovered haskell and started to learn it and I once again I find joy programming :)
13:59:45 <ashashwat> kane77:  Exactly same thing happened to me.  :)
13:59:52 <ksf> I have data Expr ty = Foo (Name ty); type family Name ty :: *
14:00:02 <dcoutts> ashashwat: no it's not inplace, and it is always O(n) space and time.
14:00:20 <ksf> what I can't write is type family Show ty => Name ty :: *
14:00:22 <tommd> ksf: Ahh, not so sure about it being for the result type.
14:00:31 <dcoutts> reverse is lazy in the list elements, but strict in the list spine
14:00:34 <ashashwat> dcoutts: thanks.
14:00:36 <ksf> and polymorphic.
14:01:14 <ksf> fundeps can probably do it
14:01:19 <merijn> The reversal messes you up, because you have to traverse the end to produce the first item in the list. I was momentarily thinking of things like map (which can be amortised O(1) when fused with another loop over the list)
14:01:52 <dcoutts> ashashwat: it's somewhat easier to see the operational behaviour of reverse if you look at the usual recursive definition rather than foldl (unless you already understand about the properties of foldl)
14:03:11 <ashashwat> dcoutts: I know how fold works (at least I think so), though got confused with flip(:).
14:03:28 <benmachine> reverse xs = go [] xs where go acc [] = acc; go acc (x:xs) = go (x:acc) xs
14:03:28 <ashashwat> dcoutts: s/fold/foldl
14:03:53 <benmachine> if you expand the foldl that's basically what you get
14:07:36 <ashashwat> Can we refer the docs in ghci, something like python does with its .__doc__ thing ?
14:08:43 <merijn> I don't think so, but I suspect haskell-mode in emacs supports something like that
14:09:27 <ksf> ...fundeps + gadts + standalone deriving do the trick.
14:24:43 * hackagebot xmonad-extras 0.10.1.1 - Third party extensions for xmonad with wacky dependencies  http://hackage.haskell.org/package/xmonad-extras-0.10.1.1 (DanielWagner)
14:28:09 <illissius> I seem to be having trouble thinking: are MPTC instances in overlap if all their parameters overlap or if any of them do?
14:29:33 <hpc> any
14:30:19 <hpc> consider the hypothetical overlapping parsec instances
14:30:42 <hpc> instance isString s => Stream s m Char
14:30:51 <hpc> instance Stream [a] m a
14:31:01 <hpc> overlapping on s = String
14:31:25 <hpc> and... actually that's a bad example, because they do all overlap
14:31:29 <hpc> but you get the point
14:31:48 <tac-tics> Is there a reason Haskell is designed such that instances can overlap at all?
14:32:06 <hpc> instances can't overlap by default
14:32:34 <tac-tics> Is that not expressive enough for every day use?
14:32:38 <hpc> because the language spec is overly conservative about what it allows, to make sure you can always resolve a class method to an implementation
14:32:56 <hpc> it's enough for my daily use, at least
14:33:21 <hpc> overlapping can lead to incoherence
14:33:45 <hpc> which, very roughly, is where a class method being instantiated with the same type in two different places
14:33:50 <hpc> picks two different implementations
14:34:09 <tac-tics> Yeah. But the design is such that you can have two modules which -- while either compiles safely alone, the combination creates an overlap, and thus an error
14:35:01 <hpc> that's not a bad thing
14:35:12 <illissius> hpc: okay, thanks. hrmpf :\
14:35:14 <hpc> try importing Category.. and Prelude.. at the same time
14:35:28 <ksf> type family applications can't have instances, data family applications can.
14:35:33 <hpc> they compile safely alone, but the combination doesn't
14:37:49 <hpc> tac-tics: arguably, what's missing to solve that particular issue is the ability to hide instances from imports
14:41:08 <favonia> hpc: agree on the hiding issue. is there any workaround for that now?
14:41:16 <HairyDude> .t (<>)
14:41:19 <HairyDude> :t (<>)
14:41:20 <lambdabot> Doc -> Doc -> Doc
14:41:27 <HairyDude> @hoogle (<>)
14:41:27 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
14:41:27 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
14:41:27 <lambdabot> Text.PrettyPrint (<>) :: Doc -> Doc -> Doc
14:41:55 <benmachine> HairyDude: in very recent GHCs there's a <> in Data.Monoid, I think
14:41:57 <HairyDude> I'm following a yesod tutorial that seems to be using (<>) :: Text -> Text -> Text
14:41:58 <HairyDude> ahh
14:42:47 <stepcut> <> is now an alias for Data.Monoid.mappend I think
14:42:55 <benmachine> yes
14:42:56 <stepcut> after years of debate
14:43:03 <stepcut> *YEARS*
14:43:44 <benmachine> :P
14:43:47 <HairyDude> is it a method or just a function?
14:44:23 <stepcut> ?info (<>)
14:44:23 <lambdabot> (<>)
14:44:31 <benmachine> lambdabot doesn't do info
14:44:33 <HairyDude> looks like just a function
14:44:33 <stepcut> ?src (<>)
14:44:33 <lambdabot> Source not found.
14:44:41 <geekosaur> just a function that aliases a method
14:44:41 <stepcut> probably
14:44:42 <aristid> @hoogle <>
14:44:42 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
14:44:42 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
14:44:42 <lambdabot> Text.PrettyPrint (<>) :: Doc -> Doc -> Doc
14:44:43 <benmachine> yes, looks like that to me too
14:45:05 <stepcut> I assumed it was just, (<>) = mappend
14:45:18 <benmachine> yeah
14:45:19 <stepcut> the Monoid class still defines mappend since that is what is in H98 H2010
14:45:23 <benmachine> plus infixr 6 <>
14:45:54 <benmachine> stepcut: well, we're not required to stick pedantically to the standard wrt libraries
14:45:59 <benmachine> (that's what the haskell2010 package is for)
14:46:08 <ksf> http://hpaste.org/69823
14:46:12 <ksf> it compiles.
14:46:21 <ksf> now I have to try whether I can actually use it
14:46:29 <HairyDude> right, Import.hs doesn't import (<>), though this tutorial seems to expect it to
14:47:07 <ksf> do note the rather awkward fact that Typeable is only derived once, otherwise there'd be two Typeable1 instances.
14:47:08 <stepcut> benmachine: sure. But given the fight for getting <> in at all, change the Monoid class sounds even less likely. Especially if mappend was removed from Data.Monoid in favor of (<>) as that would break code
14:47:27 <benmachine> stepcut: oh, yeah, the latter is not likely
14:47:27 <stepcut> and putting them both in Data.Monoid.Monoid and making one have a default implementation seems pointless as well
14:47:33 <benmachine> stepcut: but there's a nonstandard method in Functor, for example
14:55:33 <hilhil> @src mappend
14:55:33 <lambdabot> Source not found. Maybe if you used more than just two fingers...
14:56:22 <geekosaur> @src [] mappend
14:56:22 <lambdabot> Source not found. Maybe you made a typo?
14:56:37 <hilhil> It is defined for a type class -- I was being stupid.
14:56:51 <benmachine> the thing to remember about @src is that it's mostly lies
14:56:55 <hilhil> i.e. you specify the source when you make something an instance of Monoid
14:57:07 <geekosaur> yes, and I gave the form for typeclass ones --- but it's incomplete and refers mostly to someone's reference definitions
14:57:14 <ksf> the problem is, I need to replace *all* different data family instances when wanting to change a single one.
14:57:16 <hilhil> ah
14:57:51 <hilhil> I didn't know you could do that with type classes...
14:57:56 <hilhil> @src String show
14:57:56 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
14:58:19 <hilhil> Why is @src mostly lies?
14:58:29 <ksf> because it's hand-fed
14:58:32 <benmachine> hilhil: well, it doesn't actually genuinely fetch the source of anything
14:58:41 <benmachine> it's just a text file in lambdabot's home directory
14:58:53 <hilhil> Compared to things that a lot of the plugins do, fetching the source of something seems quite easy
14:59:08 <benmachine> hilhil: yeah, but lambdabot is a bit old and arcane
14:59:10 <hilhil> Is it just that no one has compiled a sufficiently large text file...
14:59:15 <benmachine> no-one really wants to go digging in her insides
14:59:19 <hilhil> ok
14:59:36 <hilhil> i see
15:01:15 <HairyDude> @src String Show
15:01:16 <lambdabot> Source not found. Just try something else.
15:01:20 <HairyDude> @src Show String
15:01:20 <lambdabot> Source not found. Just what do you think you're doing Dave?
15:01:22 <benmachine> @src Maybe return
15:01:22 <lambdabot> return              = Just
15:01:37 <HairyDude> lambdabot: why do you call me Dave?
15:01:48 <c_wraith> 2001 reference
15:02:03 <HairyDude> and I followed up with an Only Fools & Horses reference...
15:02:50 <HairyDude> oh I see
15:02:56 <HairyDude> @src Monoid mappend
15:02:56 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
15:03:16 <HairyDude> @src String mappend
15:03:16 <lambdabot> Source not found. Where did you learn to type?
15:03:20 <HairyDude> -_-
15:03:22 <c_wraith> @src Monoid
15:03:22 <lambdabot> class Monoid a where
15:03:23 <lambdabot>     mempty  :: a
15:03:23 <lambdabot>     mappend :: a -> a -> a
15:03:23 <lambdabot>     mconcat :: [a] -> a
15:03:27 <mauke> @src [] mappend
15:03:27 <lambdabot> Source not found. Just try something else.
15:03:29 <mauke> aww
15:03:51 <HairyDude> [] is not an instance of Monoid
15:03:54 <HairyDude> @src [a] mappend
15:03:55 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
15:03:59 <HairyDude> huh
15:04:08 <HairyDude> so @src is pretty useless then
15:04:17 <HairyDude> src @unfoldr
15:04:17 <benmachine> yeah, more or less :P
15:04:20 <HairyDude> oops
15:04:25 <HairyDude> @src unfoldr
15:04:25 <lambdabot> unfoldr f b  = case f b of
15:04:25 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
15:04:25 <lambdabot>    Nothing        -> []
15:04:38 <HairyDude> @src Foldable
15:04:39 <lambdabot> Source not found. My brain just exploded
15:04:56 <hilhil> @hoogle mappend
15:04:56 <lambdabot> Data.Monoid mappend :: Monoid a => a -> a -> a
15:05:11 <HairyDude> otoh @hoogle is very handy
15:06:07 <HairyDude> seems like it works for stuff in the H'98 libraries and nothing else
15:06:25 <HairyDude> @src MonadTrans
15:06:25 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
15:14:03 <dmwit> HairyDude: \bot's hoogle database is small, but the web version has a larger database. Don't forget to add +foo if you want to search package foo.
15:14:31 <HairyDude> ah, I didn't know about +
15:18:09 <dmwit> a well-hidden feature, yes
15:18:27 <DMcGill> how do I lift a function (a -> IO b) to it's Kleisli IO arrow?
15:18:35 <dmwit> Arguably it should just always search all databases and require an explicit -foo t oblock some out instead. =)
15:18:36 <DMcGill> @type arr
15:18:41 <DMcGill> :t arr
15:19:05 <dmwit> DMcGill: via Kleisli's constructor, if it's exported, or something similar if not (maybe "kleisli"?)
15:19:11 <DMcGill> arr :: (a -> b) -> Kleisli IO a b -- doesn't work due to the monad
15:19:23 <dmwit> Yes, the constructor is exported.
15:19:31 <DMcGill> I see now, thanks
15:20:29 <kopi> My brain hurts.:P
15:20:35 <benmachine> @quote ghc
15:20:47 <HairyDude> :t Kleisli
15:20:52 <dmwit> Cale: \bot =(
15:20:58 * HairyDude kicks lambdabot
15:21:45 <shachaf> @help
15:21:50 <shachaf> @botsnake
15:21:56 <HairyDude> @botsnack
15:22:00 <hilhil> Is it alright to use a guard that looks like this?
15:22:01 <hilhil>   | Just r' <- f r = return r'
15:22:18 <HairyDude> hilhil: if your compiler supports Haskell 2010, yes
15:22:20 <benmachine> hilhil: yes, that's a pattern guard
15:22:23 <hilhil> I'm getting a warning, but I can't see why it is dangerous...
15:22:27 <benmachine> ah
15:22:31 <HairyDude> hilhil: oh, it's partial
15:22:38 <hilhil> (I want the 'Nothing' case to fall through to the next handler)
15:22:48 <HairyDude> mmm, that should be fine...
15:22:50 <benmachine> hilhil: hmm, interesting
15:22:52 <hilhil> is that bad practice?
15:23:01 <benmachine> no
15:23:26 <hilhil> cf. http://hpaste.org/69825
15:23:58 <hilhil> (thanks!)
15:25:39 <HairyDude> hilhil: let me guess, the warning is "overlapping patterns"?
15:27:17 <benmachine> hilhil: I tried to make an example like yours and didn't get a warning off it, could you provide more details so I can check if GHC is being naughty?
15:27:33 <hilhil> one sec... I'm just making my code compile again
15:27:59 <hilhil> (+ It told me to switch on PatternGuards, which I did -- I'm now taking that out again)
15:28:06 <benmachine> ah
15:28:09 <benmachine> which GHC is it
15:28:27 <hilhil> 7.0.3
15:28:46 <hilhil> Warning: accepting non-standard pattern guards
15:28:52 <hilhil> (use ... to suppress this behaviour)
15:29:03 <hilhil> *suppress this message
15:29:09 <benmachine> huh, I don't get that
15:29:27 <benmachine> unless I say -XNoPatternGuards
15:29:36 <hilhil> weird
15:29:40 * benmachine wonders how it is being turned on
15:30:04 <hilhil> Let me try and construct a minimum example...
15:30:07 <hilhil> *minimal
15:30:19 <shachaf> @help
15:30:19 <kappabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:30:24 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:30:32 <shachaf> @quit forever
15:30:38 <lambdabot> Not enough privileges
15:32:07 <hilhil> This line on its own is enough to cause the message:
15:32:08 <hilhil> rename' f r | Just r' <- f r = r'
15:32:09 <HairyDude> The Num class no longer has Eq or Show superclasses. A number of other classes and functions have therefore gained explicit Eq or Show constraints, rather than relying on a Num constraint to provide them.
15:32:12 <HairyDude> huh
15:32:27 <hilhil> I can cut-and-paste the exact message if it would be useful (it's nontrivial because I'm working through Leksah, but it's doable)
15:32:33 <dmwit> hilhil: That line on its own is a legitimate warning.
15:32:48 <dmwit> It's only in the context of the other lines that giving a warning should be considered bad behavior by GHC.
15:33:19 <hilhil> Adding
15:33:19 <hilhil> rename' f r = r
15:33:27 <hilhil> Does not make the error go away.
15:33:41 <dmwit> And what command line do you use to compile? What GHC version are you using?
15:33:52 <hilhil> GHC 7.0.3, via Leksah
15:34:00 <hilhil> Ah... I suspect I know what's going on.
15:34:14 <HairyDude> leksah specifies -XHaskell98 ?
15:34:15 <hilhil> When there are no errors, Leksah will sometimes not clear the Error pane
15:34:32 <hilhil> So you can sometimes see a type error and have the code compile at the same time.
15:34:36 <hilhil> I'm sure that's what's happening here;
15:34:45 <hilhil> The error message came up when I typed the first line, and didn't disappear when I typed the second
15:35:32 <hilhil> Confirmed.
15:35:37 <benmachine> hilhil: oh, interesting
15:35:56 <benmachine> glad we sorted it out :)
15:36:03 <benmachine> er, glad you sorted it out :p
15:36:37 <hilhil> If I hadn't been talking to you I would have left PatternGuards switched on unnecessarily, so I'm glad you poked me into looking into it!
15:37:33 <HairyDude> what are constraint kinds for? is it just for making type signatures with constraints more concise?
15:38:35 <hpc> HairyDude: you can also parameterize over constraints
15:38:43 <HairyDude> oh, nice
15:39:05 <hpc> data Polylist c = Poly [forall a. c a => a]
15:39:26 <hpc> or newtype, or whatever
15:39:28 <HairyDude> so you could finally get a Functor instance for Set ? by defining class c a => Functor a or the like
15:39:39 <hpc> yes
15:39:47 <HairyDude> sweet
15:39:52 <hpc> it would be a different Functor though
15:40:02 <hpc> Functor c f where ...
15:40:10 <HairyDude> ah, right
15:40:28 <hpc> type Functor' = Functor EmptyConstraint
15:40:28 <HairyDude> class Functor c f | f -> c probably
15:40:33 <hpc> yeah
15:40:58 <tgeeky> that's opfunctor?
15:41:17 <hilhil> Hmmm.. that pattern guard error now seems to be coming back stochastically even if I leave the second line in place. So maybe I was wrong about Leksah.
15:41:19 <HairyDude> tgeeky: we're talking about constraint kinds http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/constraint-kind.html
15:41:34 <hilhil> (Something as simple as hitting 'build' again makes it go away.)
15:43:54 <Peaker> hpc, [forall a. ..] is not valid, I think
15:44:33 <shachaf> Peaker: Not valid in what?
15:44:35 <hpc> might need some higher rank stuff
15:45:12 <benmachine> that looks impredicative
15:45:29 <benmachine> I'd say Poly (forall a. c a => [a])
15:45:33 <HairyDude> hm, datatypes as kinds
15:45:34 <benmachine> that looks less nasty
15:47:08 <donri> so i have a case matching locales to Maybe Language... is there a nicer way to do that than writing "Just" for every match and ending with a _ -> Nothing, and a saner way than the spoon package?
15:47:15 <Peaker> shachaf, oh, impredicative eats it
15:47:57 <ksf_> http://hpaste.org/69826
15:47:58 <ksf_> comments?
15:48:18 <Peaker> ksf_, hlint has some apparently :)
15:48:39 <ksf_> that's what happens when you refactor a lot.
15:48:49 <benmachine> donri: hmmm, can you write it as a lookup in a list rather than a case?
15:49:33 <donri> i could, but not sure that's nicer, and probably adds some overhead?
15:50:47 <dmwit> It seems much nicer to me. As for the overhead, that depends on how the locales are stored.
15:50:57 <S11001001> Optimization?
15:51:13 <dmwit> If they're a (dense) enum, you can use an Array + bounds check to have low overhead.
15:51:20 <dmwit> Otherwise, you can use a Map to have low overhead.
15:51:24 <ksf_> donri, that is not the bottleneck you're looking for.
15:51:37 <donri> true :)
15:51:37 <gislik_> ?
15:51:54 <dmwit> You will not get (asymptotically) more efficient than a Map: even pattern matches are compiled to decision trees in GHC.
15:52:31 <dmwit> (except pattern matches on dense enums, which are jump tables, and hence you won't do asymptotically better than an Array =)
15:53:36 <ksf_> some TH for the type instances would be nice, so that long and wide transformations can be written as a matrix.
15:54:25 <donri> i somewhat wish there was a nicer syntax for "Map literals"
15:55:18 <benmachine> donri: yeah, maybe
15:56:12 <donri> i guess with the map i also gained a list of locales for whenever i need that
15:56:20 <donri> thanks!
15:57:07 <ifnspifn> I'd like to store a large list of words (upwards of a few thousand) in such a way that I could quickly look up a word by prefix. Does anyone know of a built-in way of storing a [String] in such a way?
15:57:24 <ksf_> any trie.
15:57:38 <ksf_> http://hackage.haskell.org/package/bytestring-trie
15:58:31 <ifnspifn> wow, that's pretty much perfect. Thanks, ksf_
15:58:53 <donri> are you sure you want prefix and not stem?
15:59:17 <ifnspifn> that depends, what's a steM?
15:59:44 <dmwit> donri: That doesn't significantly change the answer to the question. You still use a trie, you just stick a stemmer in front of the lookup.
15:59:53 <dmwit> ifnspifn: like, linguistic stem
16:00:03 <dmwit> ifnspifn: e.g. stem "cacti" = "cactus"
16:00:13 <dmwit> stem "ifnspifns" = "ifnspifn"
16:00:21 <ifnspifn> ah, a prefix then :]
16:00:24 <dmwit> stem "frobnosticating" = "frobnosticate"
16:00:25 <dmwit> etc.
16:00:54 <dmwit> ifnspifn: No, not always a prefix. Only one of the three examples so far have been a prefix.
16:01:05 <ifnspifn> no no, I mean, I need a prefix
16:01:08 <donri> dmwit: i admit i don't much know what a "trie" is, but i imagine with stemming you could use a normal Map or HashMap?
16:01:42 <ksf_> trie, aka radix or prefix tree.
16:01:43 <dmwit> ifnspifn: aha
16:01:55 <dmwit> donri: tries are normal and I resent your implication otherwise =)
16:02:14 <donri> haha
16:02:21 <ksf_> it saves ["foobar", "foobaz"] as one node "foo" and two children "bar" and "baz"
16:02:35 <dmwit> eh, one node "fooba" and two children "r" and "z" =)
16:02:41 <ksf_> oh.
16:02:42 <ksf_> yep.
16:03:44 <ksf_> like a non-loopy FSA would do.
16:04:05 <dmwit> non-loopy isn't enough
16:04:14 <dmwit> There are also DAWGs; these are non-loopy FSAs.
16:04:29 <ksf_> DAWGs?
16:04:34 <donri> yo dawg
16:04:36 <ksf_> as in yo dawg?
16:04:41 <dmwit> Yes, directed, acyclic word-graph
16:04:52 <ksf_> what's the "word" for?
16:05:00 <dmwit> The difference is that tries never share suffixes, but DAWGs do.
16:05:10 <dmwit> ksf_: for storing words =)
16:05:14 <ksf_> yep.
16:05:21 <dmwit> in the CS sense of the word: sequences of letters from some particular alphabet
16:05:38 <dmwit> s/but DAWGs do/but DAWGs can/
16:05:40 <ksf_> it's all isomorphic to binary naturals, anyway.
16:05:50 <dmwit> heh
16:09:36 <ifnspifn> dmwit: So, tries seem to use ByteStrings instead of Strings. I've found Data.ByteString.Char8 which has pack/unpack functions, but does it make sense to read in this large file of Strings and then convert them all?
16:10:06 <ifnspifn> then, after finding what I want in the trie, unpacking the ByteString?
16:10:37 <ifnspifn> Oops, nevermind, google answered my question: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/bytestring-0.9.1.6/Data-ByteString.html#28
16:12:30 <hpaste_> m3ga pasted “Is there a library function that does this?” at http://hpaste.org/69827
16:13:35 <benmachine> m3ga: I think scanl or scanr may be interesting to you, but I don't remember which
16:13:52 <benmachine> play about with them, but throw a "take 30" in there, I think they produce infinite lists
16:14:14 <m3ga> will to do take. i like infinite lists
16:15:21 <m3ga> benmachine: thanks. scanl1 was what i wanted.
16:15:44 <m3ga> > take 15 $ scanl1 (+) [1,1..]
16:15:45 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
16:15:52 <m3ga> yay!
16:16:53 <fmap> m3ga: you don't want Integral constraint btw
16:17:35 <m3ga> fmap: yes, probably not
16:28:55 <dmwit> ifnspifn: You should probably just use one of the non-ByteString-based tries if you are really working with text.
16:29:25 <dmwit> ByteString is for strings of bytes, not strings of Char.
16:30:03 <Culio> Hi guys , what does it mean actually !! symbol in a  Haskell function ?
16:30:34 <dmwit> ?src (!!)
16:30:34 <lambdabot> xs     !! n | n < 0 = undefined
16:30:34 <lambdabot> []     !! _         = undefined
16:30:34 <lambdabot> (x:_)  !! 0         = x
16:30:34 <lambdabot> (_:xs) !! n         = xs !! (n-1)
16:30:35 <ksf_> @hoogle (!!)
16:30:35 <lambdabot> Prelude (!!) :: [a] -> Int -> a
16:30:36 <lambdabot> Data.List (!!) :: [a] -> Int -> a
16:30:38 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
16:30:45 <c_wraith> Culio: !! isn't special. It's just a library-defined operator
16:31:23 <Culio> Ohright then, thx for the explanation )
16:31:25 <hilhil> > [3,4] !! 5
16:31:26 <lambdabot>   *Exception: Prelude.(!!): index too large
16:31:47 <hilhil> If the source says 'undefined', where does that error message come from?
16:32:08 <dmwit> > ([3 4 5] !! 0, [3 4 5] !! 1] -- somebody put this on the list of confusing examples to keep away from newbies ;-)
16:32:09 <lambdabot>   <no location info>: parse error on input `]'
16:32:10 <shachaf> Somewhere. :-(
16:32:17 <dmwit> > ([3 4 5] !! 0, [3 4 5] !! 1) -- somebody put this on the list of confusing examples to keep away from newbies ;-)
16:32:18 <lambdabot>   (3,*Exception: Prelude.(!!): index too large
16:33:19 <dmwit> Someday we'll have a magical assert that throws an error with file and line number and knows exactly how far to inline itself to give a useful error message.
16:33:29 <teneen> how to remove all packages downloaded by cabal for old ghc versions which have been removed?
16:33:31 <favonia> hilhil: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-List.html#!!
16:33:44 <dmwit> teneen: Look in ~/.ghc
16:34:06 <dmwit> teneen: remove the directory associated with the version you removed
16:34:20 <dmwit> teneen: If you install your cabal packages globally, look in the directory indicated by ~/.cabal/config instead.
16:34:41 <hilhil> So the lambdabot source is not quite the same as the 'real' source...
16:34:48 <teneen> dmwit: but aren't the cabal packages installed in .cabal/lib?
16:35:16 <dmwit> oh
16:35:18 <dmwit> yes =)
16:35:24 <teneen> dmwit: I want to remove the files themselves to free up space
16:35:37 <dmwit> Yes, I just forgot that things got installed in both places.
16:36:04 <teneen> dmwit: Is there some magical way to do this? Instead of deleting each folder manually
16:36:22 <dmwit> The nuclear option is to just remove ~/.cabal and ~/.ghc when you upgrade. If you prefer a more tactical strike, perhaps rm -r .cabal/lib/*/ghc-7.2.2 or similar will suit your needs?
16:36:53 <hpc> if you really care what you're blowing up, tree -d ~/.cabal ~/.ghc
16:37:51 <dmwit> hpc: apt-cache search tree gives about 6.3e16 hits...
16:38:18 <teneen> hpc: what does this do?
16:38:22 * dmwit apt-get install tree
16:38:49 <teneen> dmwit: I think your command suits me yes, thanks!
16:39:28 <dmwit> hpc: It's a bit too much output here to be very useful, though.
16:39:49 <dmwit> teneen: It seems to be a crappier command-line version of nautilus. =)
16:41:02 <teneen> dmwit: yeah I just tried it out :)
16:43:15 <ifnspifn> dmwit: I'm beginning to see your point about using string tries, but I cannot find any.. I did "cabal list trie", but I don't believe any of these are what I'm looking for
16:44:06 <dmwit> ifnspifn: Try grepping for trie on Hackage's list of packages.
16:44:34 <dmwit> There's several that are parameterized by the content type, and I think at least one Text-based one.
16:45:00 <dmwit> Though thank you for teaching me about "cabal list".
16:45:44 <ifnspifn> haha, it's the least I could do :P
16:46:03 <dmwit> Actually, I'm a bit surprised: I was going to suggest list-tries, and it's in the output of cabal list trie.
16:47:33 <dmwit> or, hm
16:48:29 <dmwit> Yes, that one seems pretty complete.
16:49:47 <dmwit> pfft, cabal list is amazing
16:49:57 <dmwit> cabal-install++
16:52:19 <ifnspifn> bleh, perhaps I'm misunderstanding list-trie, but it doesn't seem very applicable to a simple list of strings; it appears that it's more meant for mappings from keys -> values
16:53:38 <Johnb> Hello everyone.
16:53:51 <dmwit> ifnspifn: A set is just a map from keys to (). ;-)
16:54:58 <dmwit> ifnspifn: (and a bag is just a map from keys to Integer)
16:55:10 <dmwit> Johnb: howdy
16:55:47 <Johnb> I'm entirely new to coding. What language should I start with? Any suggestions?
16:56:07 <dmwit> Johnb: You're asking a very, very biased crowd.
16:56:18 <dmwit> We all think you should start with Haskell, of course.
16:56:35 <Johnb> Are you implying it's good for beginners too?
16:56:51 <ion> dmwit: We’re not biased at all, we’re clearly objectively right.
16:57:12 <dmwit> Johnb: Absolutely! =D
16:57:15 <ion> johnb: I don’t see why not.
16:57:37 <ion> johnb: http://learnyouahaskell.com/ http://tryhaskell.org/
16:57:39 <Johnb> I was looking at Ruby and Python as well. A lot of people seem to start with Java.
16:58:03 <Johnb> I'm currently playing with the tryhaskell thing.
16:58:08 <dmwit> Ruby and Python would also be fine choices.
16:58:29 <barrucadu> Python and Scheme tend to be my usual first language suggestions, but Haskell would also work well
16:58:44 <dmwit> Start with brainfuck.
16:58:57 <dmwit> Then you'll appreciate the facilities of all these modern languages that much more. =D
16:58:59 <barrucadu> Then move on to Befunge and Malbolge.
16:59:01 <barrucadu> :P
16:59:02 <hilhil> I second Python
16:59:24 <ion> barrucadu: And when you find them too restricting (not having COME FROM etc), INTERCAL.
16:59:49 <luite_> not having goto is pretty annoying :(
16:59:56 <hilhil> I spent a while looking through Python books for a friend who wanted to learn to code; I couldn't find anything amazing, but this is pretty good:
16:59:58 <hilhil> http://www.amazon.co.uk/Python-Software-Design-Computer-Scientist/dp/0521725968/ref=sr_1_3?s=books&ie=UTF8&qid=1326818972&sr=1-3
17:00:11 <Draconx> but INTERCAL doesn't have call/cc, so one should clearly use unlambda instead.
17:00:28 <Johnb> Yeah, I keep hearing python is nice to start with.
17:00:40 <hilhil> Haskell is beautiful, but (IMO) significantly harder than most mainstream languages.
17:01:01 <hilhil> And the error messages can be cryptic.
17:01:13 <dmwit> My wife recommends "How to Think Like a Computer Scientist: Learning with Python" if you want to start with the snake.
17:01:22 <dmwit> (It was a wedding gift from me to her. =D)
17:01:34 <hilhil> That's the one I linked to.
17:01:53 <hilhil> So it's doubly recommended.
17:02:11 <hilhil> [ My code works now -- I should go and sleep! Goodnight all.]
17:02:31 <dmwit> Oh, there seem to be several versions of that book with slight title variations.
17:02:37 <Johnb> I'm going to check these books out.
17:02:38 <barrucadu> Of course, there's also SICP which is helpful no matter what language you use
17:04:27 <dmwit> ?where LYAH
17:04:27 <lambdabot> http://www.learnyouahaskell.com/
17:04:29 <dmwit> ?where RWH
17:04:29 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
17:04:40 <dmwit> I think, in this case, even *I* won't recommend the Gentle Intro.
17:06:15 <hpc> all i remember of the gentle intro is that the way it introduced monads was with a table
17:06:20 <hpc> listing Reader, State, etc
17:06:52 <hpc> oh, i am misremembering
17:16:33 <AfC> hilhil: that doesn't happen very often. Even less often are occasions when you realize it. Definitely call it a night, but more to the point, take a moment to savor the feeling of accomplishment.
17:16:52 <AfC> hilhil: (I'm not being sarcastic)
17:20:58 <arbn> Any tips on how to troubleshoot the configure step of wxc? The "Setup: failed" output is less than helpful.
17:22:44 <arbn> Or is it just not possible to build wxc on GHC 7.4?
17:23:23 <hpc> arbn: there's no helpful output further up?
17:23:33 <hpc> sometimes it can continue a ways before it realizes it should crap out
17:24:32 <arbn> I do "runhaskell Setup configure" and immediately get "Setup: failed". The verbose flag reveals nothing that looks like an error.
17:31:16 <Siod> http://www.reddit.com/r/dailyprogrammer/comments/uw14f/6112012_challenge_63_easy/c4z4wiv < "For this particular problem, using haskell is a bad choice." is this right?
17:32:57 <shachaf> Siod: You could write an in-place reverse in Haskell.
17:33:15 <shachaf> It just wouldn't work on regular lists.
17:33:28 <shachaf> It's perfectly able to do mutation, though.
17:33:30 <Siod> what's the complexity of that that answer? is it O(log32 n)?
17:33:47 <shachaf> You could say that Haskell makes the problem a bad choice, rather than the problem making Haskell a bad choice. :-)
17:34:41 <hpc> you could also say he didn't require mutation, and write some {-# RULES #-} to fuse the function once you have a good definition
17:34:42 <Enigmagic> Siod: the question says 'Array' and there are mutable arrays.
17:35:01 <shachaf> Oh, right, it says Array.
17:35:15 <shachaf> It's a completely different thing, then. :-)
17:35:50 <Siod> still is "I thought space complexity in Haskell is O(log32 n) because of the 32bit tries?" correct?
17:36:11 <shachaf> However the people in that comment thread seem to be saying a bit of nonsense. :-)
17:36:43 <shachaf> Siod: How should we know whether that person thought it or not?
17:36:56 <shachaf> Tries don't really have anything to do with this, though.
17:37:14 <Siod> shachaf: what does think thinking it have to do with anything?
17:37:20 <hpc> Siod: you could also say it's O(1) because you can only address a couple of petabytes of memory...
17:37:35 <hpc> (maybe exabytes, i cba to calculate)
17:37:36 <Siod> s/what does think thinking/ what does their thinking
17:37:54 <Siod> hpc: i don't follow
17:37:59 <shachaf> Siod: It's impossible to say whether it's correct without knowing what it means.
17:38:19 <hpc> Siod: just being obnoxious about implementation details
17:38:45 <Siod> "I understand that it's basically a tree of the calculations that are being done to some value in memory in different places. It's kind of like the 'history' of a value, and that history branches in places where the value changes more than once. Haskell knows how to reach into this tree and pull out the right value that you need, pulling the value from the root of the tree up and through all the various calculations along the path
17:38:46 <Siod>  to the node that you selected. With this, lists (and other forms of data that use this feature) are effectively memoized automatically, because a node will remember the result of a calculation after the first time. The compiler can do that because it can see whether or not your code can change state." -> results in lower complexity for seemingly higher complexity operations?
17:39:02 <shachaf> Zamarok there (are you Zamarok?) seems to have the "Haskell compiler = voodoo" attitude that people sometimes have when they don't really understand what's going on.
17:39:15 <Siod> i'm not zamarok
17:39:22 <Siod> or ashawhatever
17:39:30 <hpc> Siod: that quote you pasted is total nonsense, if i am reading it right
17:39:59 <shachaf> Siod: If you're learning Haskell, there are much better resources for it than reddit.com/r/dailyprogrammer
17:40:27 <Siod> it's not a resource for learning haskell shachaf; it's a bunch of problems for you to solve using any language
17:40:38 <hpc> i think there's better sources for everything dailyprogrammer offers, if that's the quality of comments they come up with
17:40:47 <shachaf> Siod: Exactly!
17:41:00 <Siod> exercises like that are good practice shachaf
17:41:26 <Siod> moreover, it brought me here with a question that helped clarify my understanding of haskell
17:41:36 <shachaf> Siod: OK, but those comments are nonsense as far as I can tell.
17:43:07 <ifnspifn> I'm getting a weird parse error.. what's wrong with the foo line in https://gist.github.com/2913685 ?
17:43:21 <ifnspifn> I'm getting "parse error on input '='"
17:43:30 <mauke> ifnspifn: the indentation makes no sense
17:43:48 <shachaf> ifnspifn: Just look at that page in your browser rather than your editor.
17:44:15 <ifnspifn> ah... how odd. Alright, so how should the let look?
17:44:32 <ifnspifn> it lines up in my editor just fine :[
17:44:47 <shachaf> ifnspifn: That's because you're using tabs.
17:45:06 <shachaf> Your editor is showing them as 4 spaces or something; it should show them as 8.
17:45:13 <shachaf> Better yet, you should indent with spaces instead of tabs.
17:45:17 <sipa> the first rule of haskell is to not use tabs
17:45:32 <ifnspifn> a useful thing to learn. alright, thanks
17:45:42 <benmachine> the second rule of haskell is to not use tabs
17:45:50 <benmachine> the third rule of haskell is, no shirts, no shoes
17:45:59 <ifnspifn> I'm 1/3 of the way there, then
17:46:16 <benmachine> :P
17:50:36 <arbn> ifnspifn: You should be using an editor that converts the 'tab' key into spaces.
17:55:01 <parcs`> > map (logBase 32) [1..5]
17:55:02 <lambdabot>   [0.0,0.19999999999999998,0.31699250014423125,0.39999999999999997,0.46438561...
17:57:15 <tertl3> hehe
17:57:39 <ifnspifn> blegh. Another question: I'm trying to use Data.ListTrie to create a trie which represents a dictionary, so I can have fast dictionary lookups given a String. When I try "Data.ListTrie.Set.member word dictionaryTrie", I get the following error:
17:57:41 <tertl3> > map (logbase 64) [1..5]
17:57:42 <lambdabot>   Not in scope: `logbase'
17:57:50 <tertl3> > map (logBase 64) [1..5]
17:57:51 <lambdabot>   [0.0,0.16666666666666669,0.2641604167868594,0.33333333333333337,0.386988015...
17:58:11 <ifnspifn> "No instance for (Data.ListTrie.Base.Map.Map map0 Char) arising from a use of "Data.ListTrie.Set.member"
17:58:41 <arbn> What exactly does it mean when a Hackage page has a line like this: "Build failure  ghc-7.4"?
17:58:53 <ifnspifn> I'm still pretty bad at grokking ghci errors, but I imagine this is because Char isn't an accepted instance of this type class?
18:02:22 <XexonixXexillion> Is using unboxed variables with the FFI as easy as "foreign import ccall "foo"" and "foo :: Double# -> Double#" ?
18:08:27 <dcoutts_> XexonixXexillion: it needs some extension, but why would you need to use unboxed types anyway?
18:09:17 <benmachine> you'll certainly need at least MagicHash to even refer to unboxed types
18:10:11 <dcoutts_> and GHCForeignImportPrim
18:10:22 <dcoutts_> oh, hmm, perhaps not
18:11:04 <XexonixXexillion> dcoutts_: I had some code that needed to run faster, so I rewrote it with unboxed types. That still wasn't fast enough so I rewrote it in Ada. Now I'm wondering if I can send and receive unboxed types to my Ada code
18:11:37 <Enigmagic> XexonixXexillion: yes, you can just turn on MagicHash and deal with the unboxed types in the ffi import
18:11:48 <dcoutts_> XexonixXexillion: it will not make your FFI any faster
18:12:06 <Enigmagic> obviously the types in FFI land are all unboxed
18:13:46 <XexonixXexillion> dcoutts_: It's not to make my FFI faster, it's just so my two versions of the code share the same types
18:14:27 <nand`> benmachine: excellent. I like how the num instance's signum is bugged (doesn't output 0 on 0)
18:15:09 <benmachine> nand`: that's really the worst crime you could find? :P
18:15:19 <nand`> benmachine: so far, I'm still reading the rest
18:15:26 <nand`> pi = "3.14" is amusing as well
18:15:32 <benmachine> :D
18:16:00 <benmachine> cos x = sin (x + 90)?
18:16:12 <nand`> hahaha
18:16:33 <whittle> Is there a name for the trivial function with type :: (a -> b) -> (a -> c) -> a -> (b, c)?
18:16:47 <nand`> quotRem x y = (quot x y, rem x y) -- instead of read x `quotRem` read y
18:16:52 <c_wraith> :t (&&&)
18:16:54 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
18:17:19 <c_wraith> yeah, it's a little more general, but..  it does what you were looking for
18:17:24 <yayMe> How do I divide two ints and get a float?
18:17:36 <yayMe> some int / some int complains about fractional int or something
18:17:39 <benmachine> nand`: those ought to be the same, shouldn't they?
18:17:44 <whittle> c_wraith: Interesting.
18:17:50 <c_wraith> yayMe: fromIntegral a / fromIntegral b
18:17:51 <alang> :t (/)
18:17:52 <lambdabot> forall a. (Fractional a) => a -> a -> a
18:17:59 <yayMe> c_wraith: thanks!
18:18:05 <parcs`> :t (/) `on` fromIntegral
18:18:06 <lambdabot> forall b a. (Fractional b, Integral a) => a -> a -> b
18:18:14 <nand`> benmachine: I'd guess the integer's quotRem calculates both in one step (eg. on platforms that have it as a machine operation)
18:18:38 <benmachine> nand`: ah. but the calculation is at least *correct* even if also perverse?
18:18:50 <nand`> indeed :)
18:19:17 <XexonixXexillion> Enigmagic: I'm getting "Unacceptable argument type in foreign declaration: Double#". How can I get rid of that?
18:19:46 <whittle> c_wraith: That doesn’t generalize up to triples, etc., does it?
18:19:50 <c_wraith> nope
18:19:58 <whittle> Okay.
18:20:12 <c_wraith> :t join . join $ (,,)
18:20:13 <Enigmagic> XexonixXexillion: -XUnliftedFFITypes
18:20:14 <lambdabot> forall a. a -> (a, a, a)
18:20:27 <c_wraith> that's a silly pattern that does generalize
18:20:30 <benmachine> @pl \f g x -> (f x, g x)
18:20:30 <lambdabot> liftM2 (,)
18:20:46 <benmachine> :t liftM3 (,,)
18:20:47 <lambdabot> forall a1 a2 a3 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m a3 -> m (a1, a2, a3)
18:20:57 <nand`> :t \f -> fmap (f &&&) . (&&&)
18:20:58 <lambdabot> forall (a :: * -> * -> *) b c c1 c'. (Arrow a) => a b c -> a b c1 -> a b c' -> a b (c, (c1, c'))
18:20:59 <nand`> not quite the same thing
18:21:15 <nand`> oh, benmachine's answer is better
18:21:29 <benmachine> nand`: I think lambdabot ought to take credit for this one :P
18:22:12 <nand`> c_wraith did hint at it as well
18:22:38 <benmachine> I guess so
18:22:41 <ifnspifn> is anyone fluent with the Data.ListTrie module? I'm having trouble getting much of anything going in it
18:23:09 <whittle> I’m glad I solved the problem before letting you guys make my head spin. :)
18:23:57 <whittle> Now I have several hours of research to do so that I can solve the problem _better_.
18:24:20 <ifnspifn> To pose the problem as a question, how can I use fromList (from http://hackage.haskell.org/packages/archive/list-tries/0.4.2/doc/html/Data-ListTrie-Set.html) on a [String] to construct a Trie? I'm getting errors like "No instance for (Data.ListTrie.Base.Map.Map map0 Char) arising from a use of 'fromList')"
18:25:22 <nand`> benmachine: foldl and foldl' are funny as well. I'm sure sortBy is too, but I still haven't managed to figure out how it works :P
18:25:36 <nand`> let's not forget subtract = (-)
18:26:00 <benmachine> nand`: well, for starters, it compares 'compare x y' against GT, then EQ, then LT, then has an else clause...
18:26:26 <nand`> benmachine: yeah, those bits are funny :)
18:26:57 <benmachine> oh, and the lack of type signature in combination with ExtendedDefaulting gives it a type of [()] -> [()]
18:27:19 <benmachine> so yeah
18:27:21 <benmachine> basically
18:27:23 <benmachine> the module is inspired
18:27:27 <nand`> actually sortBy has the correct signature
18:27:34 <benmachine> oh right
18:27:37 <benmachine> well, sort, anyway
18:27:40 <nand`> yeah
18:27:53 <benmachine> (the Eq constraint is superfluous, mind)
18:28:16 <benmachine> (well, it's not actually, but also it is... you know what I mean)
18:28:35 <nand`> indeed
18:28:47 <nand`> notElem is hilarious
18:28:55 <benmachine> :P
18:37:54 <nand`> http://hackage.haskell.org/package/acme-now
18:42:45 <yayMe> I cannot get my division to work.. constant complaints of no instance of fractional int
18:43:06 <benmachine> yayMe: needs more fromIntegral
18:43:31 <benmachine> yayMe: or possibly the problem is you are trying to use the result of the division where an int is expected
18:44:07 <yayMe> aye ok, will have to follow the tree
18:44:35 <strager> !pl do { c <- mkc e t ; return (RS (Just c) t') }
18:44:40 <strager> @pl do { c <- mkc e t ; return (RS (Just c) t') }
18:44:40 <lambdabot> (line 1, column 4):
18:44:40 <lambdabot> unexpected "{"
18:44:40 <lambdabot> expecting variable, "(", operator or end of input
18:44:56 <strager> @pl  mkc e t >>= \c -> return (RS (Just c) t') }
18:44:57 <lambdabot> (line 1, column 43):
18:44:57 <lambdabot> unexpected "}"
18:44:57 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
18:45:11 <strager> @pl  mkc e t >>= \c -> return (RS (Just c) t')
18:45:12 <lambdabot> (flip RS t' . Just) `fmap` mkc e t
18:45:49 <hpaste_> applicative pasted “Data.ListTrie” at http://hpaste.org/69829
18:46:07 <applicative> ifnspifn: did you figure  this out ^^^
18:47:29 <ifnspifn> applicative: I didn't,  though I can't say I quite understand what's going on in that code
18:47:53 <yayMe> is it bad practice to break things up into separate 1 or 2 line functions instead of composing it altogether into a couple larger ones?
18:47:55 <applicative> ifnspifn: you have to give fromList a type signature
18:48:24 <yayMe> In haskell I find I can do so much in 1 or 2 lines, it's the amount of work I would do in a 10 or 15 line function in my native C#
18:48:27 <ifnspifn> can type signatures be given to variables inside of functions?
18:48:47 <Ralith> yayMe: generally splitting things up into self-contained functions is good
18:48:52 <applicative> ifnspifn: it has to include something that falls in the special 'Map' class of the package.  The instances are in Data.ListTrie.Base.Map
18:48:53 <Ralith> it can be done so as to be bad, though
18:49:16 <applicative> ifnspifn: you mean where I wrote 1::Int ?
18:49:21 <ifnspifn> yes
18:49:31 <mapreduce> yayMe: You might not be taking full advantage of C# then.
18:49:40 <Ralith> hah
18:49:48 <mapreduce> except for defining types, it's pretty verbose for that.
18:49:59 <applicative> you can do that in many contexts. It wasnt necessary there.  I was trying to make sure nothing irrelevant got in the way, so I specified Int
18:50:25 <yayMe> mapreduce what are you talking about? I'm pretty decent in C#
18:51:02 <hpaste_> applicative annotated “Data.ListTrie” with “Data.ListTrie (annotation)” at http://hpaste.org/69829#a69830
18:51:15 <applicative> ifnspifn: so this works as well ^^^
18:51:26 <yayMe> I'm just saying, I'm finding in haskell because the syntax is so terse one or two lines does a lot more than in C#, short of verbose linq statements that my colleagues complain about as being hard to understand
18:51:35 <mapreduce> yayMe: Well, it has LINQ and if you use whatever Mono.Rocks became there's pretty much the whole Haskell Prelude ported.
18:51:48 <Rotaerk> yayMe, your colleagues need to learn LINQ
18:51:51 <yayMe> plus overuse of fluent linq in C# is killer on performance
18:52:02 <Rotaerk> they can't read it because they haven't learned it
18:52:07 <yayMe> I know, I've tried teaching them over the past couple years
18:52:11 <Rotaerk> but LINQ is more readable than loops
18:52:17 <yayMe> I agree completely
18:52:30 <nand`> if I remember correctly, isn't Linq based on runtime reflection / special semantics because the type system itself can't actually support monads (no higher-kind polymorphism)
18:53:38 <yayMe> That doesn't sound right to me
18:53:52 <yayMe> Linq isn't reflection based
18:54:09 <Rotaerk> nand`, well the LINQ syntax is kind of like do-notation, in that it works on any type that supports a certain set of methods
18:54:32 <nand`> well, it uses the magic “SelectMany” extension methods instead of actually providing an interface or something
18:54:40 <mapreduce> LINQ gets converted to ordinary method calls.
18:54:49 <yayMe> in haskell the lazy evaluation ensures you can chain together list iterations and it will only iterate as many times as you request elements
18:54:57 <mapreduce> Whether they're extension methods or not depends on the types you're using them on, I think.
18:54:58 <nand`> oh right, it isn't runtime reflection at all
18:55:07 <nand`> it's just hard-coded to de-sugar to “SelectMany” etc. calls
18:55:12 <Rotaerk> yep
18:55:30 <yayMe> linq however will do complete iterations most of the time, so when you chain you end up causing multiple iterations to cause multiple evaluations
18:55:34 <nand`> not unlike ‘do’ notation in that regard, I will admit. :)
18:55:56 <ifnspifn> applicative: Alright, so I have to explicitly define my stuff so that the constructor knows it's got the functions it needs. But how can I use the function "member" on those? Shouldn't I be able to test the resulting TrieSet for containing strings?
18:56:00 <applicative> ifnspifn: here's another http://hpaste.org/raw/69831
18:56:07 <yayMe> and end up with crap performance where a hand written for loop would do better which sucks
18:56:12 <mapreduce> LINQ's a bit smart in that it can take Expr<Func<A, B>>, where an Expr is an expression that can be analysed.
18:56:15 <Rotaerk> yayMe, LINQ on IEnumerables (i.e. using the System.Linq.Enumerable methods) will only iterate over the sequence as much as it needs...
18:56:38 <yayMe> that depends on whether or not people are using yield return
18:56:41 <mapreduce> So technically it should always be able to be about as good as loops (better where it can be lazier) but that depends on the backend.
18:56:52 <Rotaerk> someEnumerable.Where(f).Select(g) will do no iteration
18:57:14 <yayMe> the where iterates the entire enumerable actually
18:57:17 <yayMe> looking for matches
18:57:18 <Rotaerk> nope
18:57:32 <applicative> ifnspifn: it's just that 'fromList' is underdetermined.  You can write specialized version like my fromListW and fromListA and it wont have a problem.  Note they put different constraints on the things
18:57:44 <Rotaerk> yayMe, no iteration occurs in that until you do .ToList() or something else that forces it to actually execute
18:57:50 <yayMe> oh right
18:57:51 <yayMe> I know
18:57:52 <yayMe> but
18:58:16 <ifnspifn> applicative: Wow, okay, so that works like a charm. My only problem, then was leaving the type as something that isn't explicitly in Data.ListTrie.Base.Map?
18:58:38 <yayMe> .ToList() will iterate the entire thing, so the .Where().Select() will 1 complete iteration of the first enumerable, then 1 complete iteration of the returned one
18:58:59 <yayMe> a .where().select() could be written to use only one loop which is how haskell does it (I believe?)
18:59:39 <Rotaerk> yayMe, alternatively you could do .First(), in which case it will iterate only up to the first result that matches the Where filter
18:59:45 <yayMe> .select().where().select() means you're iterating the full original list twice, then once more on a subset of the list
18:59:52 <applicative> ifnspifn: you can define your own Map instances, the methods are explained there.  I just looked for the instances derived there.  I assume  they have different properties, best for different cases
19:00:14 <mapreduce> yayMe: I'm reasonably sure it will be one loop but I don't have C# around to attempt to prove it.
19:00:29 <applicative> ifnspifn: but yeah, there needed to be something to specify the kind of 'Map' (in this sense) that you are using
19:00:42 <ifnspifn> applicative: so, were I to implement all of the "minimal complete implementation" functions, my own types would work?
19:01:03 <applicative> ifnspifn: member "hello" a and member "hello" b both make sense, since "member" knows what kind of Trie it is dealing with
19:01:49 <applicative> ifnspifn: yes, your substitutes for "AList" and "WrappedIntMap" .  Somehow it sounds like it will be ugly....
19:02:16 <ifnspifn> applicative: this has been enormously helpful, thanks :]
19:02:55 <applicative> ifnspifn: oh sure
19:03:23 <yayMe> mapreduce: I would tack something together to make my point but I sit at work writing and profiling C# all day, I'm just not interested to.
19:04:13 <Rotaerk> you'd have to dig through the CIL to determine if it compiles to one loop
19:04:48 <yayMe> taking an enumerable, and doing .select().where().select() will give you an expression, when it is evaluated with .tolist() or .toarray() it will commit 3 loops, and unfortunately if you later do .tolist() or .toarray() on that same variable, it will again commit those 3 iterations
19:05:24 <Rotaerk> I suspect it could, because the IEnumerable-implementing class that is used by Select, and the class used by Where, etc... would not need to contain loops
19:05:34 <yayMe> You don't have to dig through the IL, all you need to do is put break points in a function that you put into the select()/where()/select() clause and you can watch it execute
19:05:39 <nand`> uhc -tjs is hilarious: https://paste.lugons.org/show/2130/
19:05:40 <mapreduce> Rotaerk: You could work it out by adding a side effect.
19:05:47 <nand`> yet strangely awesome
19:06:04 <yayMe> give it a shot:
19:09:10 <yayMe> public class bla { public bool hoy1(int a) { return true; } public bool hoy2(int a) { return true; } public bool hoy3(int a) { return true; } public void exec() { Enumerable.Range(1,4).Select(a => hoy1(a)).Where(a => hoy2(1)).Select(a => hoy3(1)); } }
19:09:11 <nand`> mapreduce: ah, the wonders of impure code
19:09:24 <yayMe> put break points on each of the 3 returns
19:09:32 <yayMe> oh and add a .ToArray() at the end of that
19:09:35 <yayMe> and call exec
19:09:59 <nand`> .Select(a => hoy1(a)) // what, can't write .Select(hoy1)?
19:10:02 <yayMe> You'll see 9 iterations, where haskell would do 3
19:10:10 <otters> so case True of { foo == bar -> baz } doesn't work
19:10:14 * hackagebot parsec 3.1.3 - Monadic parser combinators  http://hackage.haskell.org/package/parsec-3.1.3 (AntoineLatter)
19:10:16 <mapreduce> nand`: Yes, you can.
19:10:21 <yayMe> nand`: I don't remember if that works without a static method or not, I don't think it does
19:11:33 <mapreduce> Enumerable.Range(1, 4).Select(a => 1 / (4 - a)).Where(a => { Console.WriteLine(a); return true; }).ToList();
19:11:37 <otters> is there any replacement for that?
19:11:57 <nand`> otters: guards?
19:12:17 <nand`> | foo == bar = -- compares against True
19:12:30 <mapreduce> If I'm right, that will print 1, 2, 3 and then give whatever C# does with a division by zero.  If yayMe's right it will only do a division by zero.
19:12:51 <mapreduce> and I'll buy him a pint next time I see him
19:13:30 <otters> nand`: yeah, but I want to test different conditions
19:13:43 <nand`> otters: but you want to compare them all to True, right?
19:13:46 <otters> yeah
19:13:53 <nand`> yeah, that's what guards do
19:14:10 <otters> right
19:14:11 <nand`> f | foo == bar = baz | someothercond = baz' | otherwise = frob
19:14:26 <otters> so say I'm already in a case statement
19:14:46 <nand`> I don't know if you can do inline guards, but you can definitely define a helper function to do it
19:16:21 <otters> right
19:16:39 <joeyh> you can use guards in a case statement
19:16:57 <ben> What's everybody's favorite X11 bindings package these days?
19:17:04 <otters> you can?
19:17:07 <nand`> joeyh: oh? how does this work? eg. case | foo = bar | frob = bat -- ?
19:17:10 <geekosaur> where exactly are you trying to use them?  function definitions are secretly case statements if you use patterns or guards in them
19:17:50 <tgeeky> so, in pointfree-style programming, the only way you can do case evaluation is with guards?
19:17:56 <joeyh> Just x | test x-> blah
19:17:57 <geekosaur> ben:  I dont know if anyone uses xhb offhand; X11 is used heavily by xmonad
19:18:22 <geekosaur> (probably something *does* use xhb, I'm just not aware of them)
19:18:26 <ben> I basically wanna fire a bunch of XSendEvent events, xhb looked a bit gross for that until I missed some wrapper
19:18:31 <ben> err, unless
19:19:53 <geekosaur> X11 may look worse in that case, it's very low level.
19:21:00 <hpaste_> joeyh pasted “case guards” at http://hpaste.org/69833
19:21:11 <c_wraith> tgeeky: in point-free style, the only way to do case evaluation is with destructors - things like maybe, either, and foldr
19:23:53 <geekosaur> ben:  example of using sendEvent from X11 bindings:  http://xmonad.org/xmonad-docs/xmonad-contrib/src/XMonad-Config-Gnome.html#gnomeRun
19:24:15 <ben> Ah, that's great
19:25:08 <ben> I saw gnomeRun :: X () and was about to ask "where's the X monad from", then i thought better of it
19:25:42 <ben> Looks like xmonad comes with a lot of X11 boilerplate, I suppose
19:29:56 <aristid> ben: it _is_ an X11 window manager :)
19:30:24 <ben> It would be more useful to me right now if it was an X11 boilerplate library :)
19:30:40 <nand`> http://hackage.haskell.org/packages/archive/AES/0.2.8/doc/html/Codec-Crypto-AES.html <- does anybody know how these functions behave on failure? Is there an interface that will get me a Maybe ByteString ?
19:31:46 <nand`> or will they produce gibberish on decode failure
19:32:34 <geekosaur> xmonad is very close to the Xlib level, it's intended to be lightweight.  it does have some abstractions but they're mostly useful for window management, go figure
19:39:48 <mapreduce> yayMe: I was right, you finally gave me a reason to try the VS2012 beta I'd installed.
19:47:39 <ben> If I have, simplified, a list [IO [IO a]] and a function a -> IO Bool, is there a cleverer way to get the first matching a without doing more IO than necessary than doing my own recursion?
19:47:52 <ben> It kinda looks like a bit of folding but the monadic bits are throwing me off
19:48:03 <jfischoff>  If I remember correctly Store is the dual of the State monad, so what is the dual of the Reader monad?
19:49:38 <edwardk> store isn't technically dual to state. its the adjunction composed in the opposite order
19:50:59 <edwardk> now if you look at reader its just have of the (,) e -| (->) e adjunction, so if you use the other half you get a comonad.
19:51:24 <edwardk> if you look at writer it uses the other half of the (,) e -| (->) e adjunction with a monoid, if you use the other half (and a monoid), you get a comonad
19:51:57 <edwardk> instance Comonad ((,) e) where extract (e,a) = a; extend f w@(e,_) = (e,f w)
19:52:51 <edwardk> the concept of a comonad is dual to the concept of a monad, but the individual comonads we talk about aren't directly dual to their monadic analogues
19:53:06 <edwardk> they are related, but not in such a simple way
19:53:33 <edwardk> this is why i don't like the name CoState, CoReader, CoWriter, etc. aside from not giving good intuition, they are just wrong
19:53:47 <tgeeky> edwardk: hmm.
19:54:19 <jfischoff> is there a analog to 'local' for Reader? For instance I used reader to collapse transforms, but I realize now I want to "push" transforms up a simple branch in scene graph.
19:54:37 <edwardk> local is kind of a bolted on addition, but lets look
19:54:56 <edwardk> :t local
19:54:56 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
19:55:14 <edwardk> so you want (e -> e) -> (e, a) -> (e, a) -- sounds tough ;)
19:55:45 <edwardk> @djinn (e -> e) -> (e, a) -> (e, a)
19:55:45 <lambdabot> f a (b, c) = (a b, c)
19:56:46 <edwardk> there are analogues to listen, censor, etc. for Traced as well: http://hackage.haskell.org/packages/archive/comonad-transformers/2.1.1.1/doc/html/Control-Comonad-Trans-Traced.html
19:57:17 <jfischoff> why is it called traced?
19:57:19 <edwardk> which is the comonadic construction analogous to the writer monad
19:58:01 <edwardk> a.) because as mentioned it isn't really a co-writer at all, but b.) because when you start looking at how it works, the 'log' is attached to a value, and you can forget the trace of things you've 'told' the value
19:58:07 <edwardk> extract is getting the value without the trace
19:58:29 <jfischoff> ah so it is similar to Debug.Traced package in fact
19:58:35 <edwardk> yep
19:58:59 <edwardk> now, compare the intuition from that to trying to figure out what cowriter has to do with m -> a
19:59:13 <edwardk> ;)
19:59:33 <edwardk> i think a large part of the problem with comonads comes from the vocabulary, people using 'co-' where it really isn't appropriate
19:59:45 <djahandarie> ben, it depends on the specific IO action.
19:59:56 <jfischoff> we should tell rconnor to update his lenses paper
20:00:01 <edwardk> yes, its not nice that we use 'costate comonad coalgebras' in all earnestness, but still ;)
20:00:07 <edwardk> well, he uses store
20:00:22 <jfischoff> right, but he says it is the dual of State
20:00:26 <edwardk> we bounced names around until that one rose to the top of the pile
20:00:27 <edwardk> fair nuff
20:00:36 <jfischoff> not that I care ;)
20:00:56 <jfischoff> dinner time! thanks!
20:01:01 <edwardk> there may be some deep way in which it is, but i sure as hell am not smart enough to spot it
20:01:12 <djahandarie> ben, if you're using lazy IO, it will do just that. Except it'll probably also space leak if you're not careful.
20:04:53 <applicative> ben are you really sure you needed to build a [IO [IO a]]? ...
20:05:41 <Ralith> how do you even end up with one of those
20:05:55 <ben> No, but I figured that was a nice reduction of the problem where I have an IO b that lets me build a [c] and I also have a c -> IO a or something
20:06:10 <ben> give or take a few levels of lists
20:06:15 <jmcarthur> sounds like somebody wants ListT or something
20:06:48 <ben> I only need one of the inner values so I might as well throw an exception
20:08:03 <applicative> from the IO b, you presumably get an IO [c], then have a function c-> IO a  ... is that it?
20:08:33 <ben> yeah
20:13:11 <applicative> ListT seems like overkill, no?
20:13:16 <ifnspifn> How can I debug a runtime error like: "Exception: No match in record selector ..."? As in, is there a way to indicate the line on which the exception occurs?
20:13:34 <applicative> @unmtl ListT IO a
20:13:35 <lambdabot> IO [a]
20:15:05 <applicative> ifnspifn: we condemn ourselves for incomplete pattern matching and resolve to do better....
20:19:03 <ifnspifn> applicative: consider me enlightened :] thanks, twas but a rookie mistake
20:19:54 <applicative> ifnspifn: just kidding, of course.  I'm not an expert on the various forms of debugging, apart from the ultraprimitive Debug.Trace
20:21:21 <applicative> @quote oasis
20:21:21 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
20:21:56 * applicative never tires of @quote oasis.
20:23:53 * shapr agrees
20:26:57 <applicative> ifnspifn: if you compile with -Wall you are likely to hear about some of them, e.g -fwarn-incomplete-record-updates or whatever
20:29:02 <applicative> ifnspifn: you can write {-#OPTIONS -Wall #-} if you are opening in ghci .  Of course it can be too informative
20:32:08 <nand`> Any Gentoo users in here ever think about writing a Haskell API to portage? I'm thinking something like portage :: IO PortageTree which can then be accessed in a pure fashion
20:37:18 <applicative> ifnspifn: in fact there is a cool debugging mechanism inside ghci, but it's a little hard to learn; at least this was my experience
20:41:43 <applicative> ifnspifn: here is a cool use of the debugger for a different purpose http://stackoverflow.com/questions/9987739/what-is-the-best-way-to-test-and-interact-with-inner-functions-defined-inside-a
21:17:04 <shoerain> applicative: refreshing desert in the oasis? Shouldn't it like, be the other way around? hm...
21:17:21 <shoerain> or is that some sort of joke i'm missin'
21:19:18 <shachaf> shoerain: It's a joke you're missing.
21:19:43 <shoerain> i can dig that, i guess.
21:21:16 <shoerain> Oh I see, "ultraprimitive Debug.Trace" quote directly above
21:45:15 <fragamus> ld: warning: could not create compact unwind for _ffi_call_unix64: does not use RBP or RSP based frame
21:45:40 <fragamus> WTF
21:46:44 <mzero> don't worry about that
21:46:58 <mzero> you are using GHC 7.0.4 on Mac OS 10.6 or 10.7
21:47:05 <mzero> the warning couldn't be helped
21:47:14 <mzero> it is fixed as of 7.4.1
21:47:18 <fragamus> you are some kind of psychic
21:47:23 <mzero> but in the end - it is a totally ignorable warning
21:47:30 <mzero> :-)
21:47:52 <nand`> @hoogle (String -> IO ()) -> IO ()
21:47:53 <lambdabot> No results found
21:47:59 <mzero> your exe will still run no problem
21:48:59 * mzero wonders what nand` could possibly expect such a function to do.... apply the given function the name of each user account? 
21:49:11 <nand`> :t forever . (>>=) getLine -- mzero
21:49:11 <lambdabot> forall a b. (String -> IO a) -> IO b
21:49:17 * mzero apply it to all the texts written by British mystery writers?
21:50:25 * mzero thinks he'd write that     forever . (getLine >>=)      
21:50:31 <mzero> but that's just a quibble
21:51:14 <nand`> not using it as a combinator either way if it doesn't already exist; so I'll be using forever $ getLine >>= process
21:51:21 <nand`> arguably the cleanest :)
21:54:50 <dmwit> nand`: also possible: getContents >>= mapM_ process . lines
21:55:20 <nand`> actually, I'm using forever . handle $ getLine >>= process -- where handle catches some errors I want to display to the user instead of throwing upwards
22:34:14 <TheRedMood> Hey
22:34:23 <TheRedMood> What is haskell good for?
22:34:29 <TheRedMood> What sort of applications?
22:34:40 <MasseR> ~Everything
22:35:03 <TheRedMood> o.o
22:35:04 <TheRedMood> Well
22:35:09 <TheRedMood> Why eveyrhing then?
22:35:19 <TheRedMood> And why is it then not used everywhere
22:35:28 <MasseR> It's a nice general purpose language
22:35:56 <MasseR> And the latter question is a difficult question with probably no real answers
22:36:14 <TheRedMood> Okey
22:36:26 <TheRedMood> Somebody is going to send me a "let me google that for you lin"
22:36:28 <TheRedMood> link
22:36:31 <TheRedMood> but im short on time here
22:36:36 <TheRedMood> It is functional
22:36:36 <MasseR> I could throw from the top of my hat that companies are afraid to take on languages where programmers aren't everywhere
22:36:40 <TheRedMood> What does that mean?
22:36:45 <TheRedMood> Yeah
22:36:47 <TheRedMood> And also
22:37:00 <TheRedMood> Is it easy to integreate it with what i know from java, C#?
22:37:03 <MasseR> TheRedMood: Wherein imperative languages you describe how something happens
22:37:11 <mzero> your "short on time"? what is this? research for a paper due in an hour?
22:37:12 <TheRedMood> okey
22:37:13 <MasseR> With functional you describe what something is
22:37:18 <TheRedMood> No
22:37:27 <TheRedMood> I have to go in some time
22:37:35 <TheRedMood> and i just want to get a quick overview
22:37:39 <TheRedMood> and thanks MasseR
22:37:42 <TheRedMood> :D
22:38:00 <mzero> ah - Haskell is a general purpose language good for a very large variety of things - much in the same way Java, C++, Python, or Ruby are general purpose languages
22:38:38 <mzero> it is not used everywhere because it has really only blossomed in the last few years -
22:38:44 <TheRedMood> okey
22:39:02 <mzero> that is - getting the compiler, tools, and libraries to a point where those things aren't an impedement to doing what you need to get done
22:39:02 <TheRedMood> Can i ask if it has a way to make GUIs?
22:39:24 <MasseR> TheRedMood: Sure you can ask ;)
22:39:29 <MasseR> But yes, it has bindings for gtk and wx
22:39:29 <mzero> that is a library question, really - as with any language, it depends on what GUI libraries are available for your environment
22:39:57 <TheRedMood> wow, i might start using it because i've not seen one "just google it" message
22:39:59 <mzero> and you can of course build your UI out of HTML - as it is easy to embed a small server in your app
22:40:02 <TheRedMood> it seems like a nice community
22:40:03 <mzero> (I do this all the time)
22:40:12 <TheRedMood> Yeah
22:40:16 <TheRedMood> I kind of heard :D
22:40:19 <TheRedMood> BUt still
22:40:28 <TheRedMood> When you are used to the slackware IRC
22:40:35 <TheRedMood> This is heaven <3
22:40:38 <mzero> also - I believe there is a group that has got it bridged to iOS so you can write GUI apps there as well
22:41:00 <mzero> this channel has a reputation for being helpful for newcomers
22:41:13 <TheRedMood> The thing is
22:41:16 <mzero> have you found "Learn You A Haskell for Great Good" yet?
22:41:20 <mzero> @where LYAH
22:41:20 <lambdabot> http://www.learnyouahaskell.com/
22:41:39 <TheRedMood> I found it haskell
22:41:50 <TheRedMood> i have known there was a laungeuge with the name
22:41:52 <TheRedMood> for some time
22:41:54 <TheRedMood> but now
22:41:54 <solarus> laway away
22:42:01 <TheRedMood> i found the site for the first time
22:42:38 <mzero> a not so short, but easy to follow quick intro to the flavor of Haskell can be found on YouTube: https://www.youtube.com/watch?v=b9FagOVqxmI
22:42:47 <mzero> (disclaimer - that's me in that video!)
22:43:01 <mzero> slides here: http://www.ozonehouse.com/mark/haskell-amuse-bouche/slides.html#(1)
22:43:14 <TheRedMood> Ww
22:43:16 <TheRedMood> okey
22:43:17 <mzero> but they are not so useful without the patter in the video
22:43:17 <TheRedMood> BUT!
22:43:25 <TheRedMood> I actuly have to go now
22:43:32 <TheRedMood> I will be coming back here when im back
22:43:34 <mzero> well- come back another day
22:43:40 <TheRedMood> And i will defently try it
22:43:44 <mzero> enjoy
22:43:47 <TheRedMood> but give me one last thing
22:44:10 <mzero> > replicateM 2 [1..6] -- all possible throws of two dice
22:44:11 <lambdabot>   [[1,1],[1,2],[1,3],[1,4],[1,5],[1,6],[2,1],[2,2],[2,3],[2,4],[2,5],[2,6],[3...
22:44:16 <mzero> like that?
22:44:18 <TheRedMood> what do you think is the greatest thing about haskell compered to lets say java looking away from functional programming
22:44:20 <mzero> (yes, you can run Haskell in this channel!)
22:44:49 <mzero> That the type system actually helps you design and write your program - rather than just make your fingers hurt
22:45:20 <mzero> You can be more certain that your program does what you think it does than in imperative programs like Java or C++
22:45:28 <mzero> and that freedom, knowing it does what you think it does
22:45:47 <mzero> enables you to write very powerful, reusable code that you wouldn't attempt in those langauges
22:47:51 <mzero> Like - here's a run length encoder, that works generically for all types that support equality: http://www.ozonehouse.com/mark/haskell-amuse-bouche/slides.html#(48)
22:48:26 <mzero> I can be *certain* that that works for all such types, with no worries about edge cases, assumptions about NULLs, or other cruft
22:49:02 <mzero> essentially, when we program, we all wish for our code to mean what we think it means
22:49:27 <mzero> in functional programming in general, and Haskell in particular, your code is much more likely to have this property
22:49:57 <mzero> (This is known as "The Princess Bride Property" .... )
22:50:23 * mzero wonders if TheRedMood left....
23:05:17 <TheRedMood> okey
23:05:33 <TheRedMood> I left it on here to watch your explanation :3
23:05:54 <TheRedMood> Sorry
23:06:02 <TheRedMood> I can make much out of that snippet
23:06:17 <TheRedMood> since I'm not used to this syntax
23:06:20 <TheRedMood> Buti got the book
23:06:23 <TheRedMood> you senyt
23:06:27 <TheRedMood> and the video
23:06:51 <mzero> yeah - ignore my snippet above - that'll come laters
23:07:15 <mzero> did you get my explaination of what is better about it than Java?
23:07:16 <TheRedMood> So i will check it out later
23:07:23 <TheRedMood> Kind of
23:07:39 <TheRedMood> But you switched to the principle of functional programming rather fast
23:07:48 <TheRedMood> so im not getting the feel of why HASKELL
23:07:52 <TheRedMood> is better
23:08:02 <TheRedMood> but now i really need to go
23:08:04 <TheRedMood> X3
23:08:11 <mzero> just remember: it isn't the geeky mathish parts of functional programming that make it important --- it is that it lets you right better, more correct programs, easier.
23:08:15 <TheRedMood> So i can't actully wait for your good ansver
23:08:20 <TheRedMood> OKEY
23:08:26 <TheRedMood> SEE YOU LATER MZERO :D
23:08:29 <mzero> laters
23:34:11 <cizra> mzero: Why "The Princess Bride Property"? You know you're getting a princess and princesses must be good?
23:35:19 <mzero> In "The Princess Bride", Inigo Montoya says: "You keep using that word. I do not think it means what you think it means."
23:35:56 <mzero> (this is after Vizzini misapplies "Inconceivable!" for the zillionth time)
23:36:33 <cizra> Oh, is that a movie? OK.
23:36:35 <mzero> So, we say a fragment of code is "inconceivable" if you can't be sure it means what you think it means
23:36:59 <cizra> Whew, that was convoluted.
23:37:01 <mzero> and a fragment of code is "not inconceivable" if you can be sure of it's meaning
23:37:27 * shachaf sighs. Those intuitionists.
23:37:34 <mzero> in functional programing, (avoiding IO), most fragments are "not inconceivable"
23:37:37 <mzero> which is good
23:38:03 <mzero> we call this "The Princess Bride Property"
23:38:18 <cizra> OK, thanks for the thorough answer.
23:38:20 <mzero> the move is: http://www.imdb.com/title/tt0093779/
23:38:23 <mzero> it is hilarious
23:38:31 <mzero> movie, that is
23:45:34 <OceanSpray> okay
23:45:35 <OceanSpray> so
23:46:12 <OceanSpray> my program won't compile and I'm VERY SURE that it's because I need to give it rank-2 type signatures
23:46:23 <OceanSpray> unfortunately, I am too dumb to figure out what those signatures need to be
23:46:58 <shachaf> OceanSpray: Oh, just put a "forall r." inside the parentheses on column 12 of line 68.
23:47:46 <OceanSpray> :|
23:48:12 <OceanSpray> I heard that rank-2 type inference is possible
23:48:21 <OceanSpray> is there a tool to do that on my haskell program?
23:54:10 <lpvb> how do you split a string across multiple lines in haskell?
23:54:19 <shachaf> You can use \
23:54:49 <shachaf> \<whitespace> in a string ignores all whitespace until the next \
23:54:55 <shachaf> > "abc\      \def"
23:54:57 <lambdabot>   "abcdef"
23:55:57 <lpvb> thanks shachaf
23:57:12 <shachaf> @where+ multiline_string "abc\   <newlines or other whitespace go here>   \def"
23:57:12 <lambdabot> Nice!
