00:09:37 <zzo38> Is there a case where the right and left Yoneda are equivalent when f is not a Functor?
00:28:02 <mekeor> i want to extract the definition of a function out of a Idris source-code. the syntax of Idris is very similar to Haskells but not equal. (e.g. it uses "\x=>" instead of "\x->" and ":" instead of "::".) so, how do i best write such a parser-function? i mean, how do i have to design it? how should it work?
00:28:29 <mauke> a bunch of regexes
00:29:02 <Ralith> lol
00:29:23 <darkniobe> You could take a look at the parser Idris actually uses
00:29:32 <mekeor> mauke: wouldn't that be a really HUGE and difficult bunch?
00:29:52 <mekeor> darkniobe: oh, right.
00:30:34 <otters> mekeor: if it's only that different, why not a text replace
00:30:57 <mekeor> otters: how do you mean?
00:31:18 <mekeor> otters: "text replace"?
00:31:20 <darkniobe> The syntax of Idris is more different than simply lambda expressions
00:31:22 <yywi> replace : with :: and \x= with \x->
00:31:36 <darkniobe> err when compared with haskell syntax
00:31:50 <darkniobe> let's all pretend that was part of the statement I made prior
00:32:00 <Ralith> the sane thing to do here is just use idris' parser
00:32:14 <darkniobe> That way you're guaranteed it's correct
00:32:17 <mekeor> otters: ah, so you say, i should convert it to haskell and then parse it? no, that's not what i want.
00:32:19 <ClaudiusMaximus> i want a 2D spatial index with arbitrary RealFrac coordinates, but Data.PKTree starts with   type Point = [Float]   - suppose i could fork it, generalize it, send a patch upstream...
00:33:38 <mekeor> thanks guys.
00:34:04 <darkniobe> mekeor: https://github.com/edwinb/Idris-dev/blob/master/src/Idris/Parser.hs
00:34:33 <mekeor> thanks :)
00:34:54 <darkniobe> Happy to help :)
00:35:24 <mekeor> that's quite long though…
00:36:16 <darkniobe> It's worth the read, if only to at least have a good understanding of how Idris syntax truly relates to haskell syntax
00:36:36 <danr> and it's 1337 lines long too
00:36:50 <darkniobe> Just be thankful it's not in Visual Basic ;-)
00:38:04 <darkniobe> mekeor: parseExpr looks like a good place to start if you're looking to extract function definitions
00:38:15 <darkniobe> line 138
00:38:17 <mekeor> OK
00:38:42 <darkniobe> Also line 329 pFunDecl
00:39:34 <mekeor> ah, it uses Parsec.
00:40:41 <darkniobe> Yup, so if you're familiar with it, makes it a bite easier ;-)
00:40:57 <mekeor> i'm not familiar with Parsec.
00:42:22 <darkniobe> It's a good, flexible library. Very much worth getting to know. I'm guessing that you're looking for a means to look at type signatures extracted via ctags?
00:42:57 <otters> What should I use for converting a ISO-8859-1-encoded ByteString into a Text?
00:43:50 <mekeor> darkniobe: i'm working on sort of hoogle/hayoo for Idris.
00:44:04 <darkniobe> ahh, definitely learn Parsec then
00:44:23 <mekeor> hm, okay. thanks, man!
00:44:29 <mekeor> darkniobe++
00:45:05 <darkniobe> Yw :-)
00:50:52 <kallisti> hm, why is MaybeT not part of mtl?
01:02:56 * hackagebot webdriver 0.3.3 - a Haskell client for the Selenium WebDriver protocol  http://hackage.haskell.org/package/webdriver-0.3.3 (AdamCurtis)
01:09:28 <Jay> Hello
01:09:47 <Guest88305> Is anyone in the chat?
01:09:53 <kallisti> changelogs are surprisingly rare in Haskell packages.
01:09:57 <kallisti> Guest88305: yes
01:10:17 <Guest88305> Ahh hi, I'm curious about learning Haskell, so I'm trying out this tutorial.
01:11:19 <kallisti> Guest88305: which
01:12:56 <mroman> Usage of demonstrative pronouns without context considered confusing ;)
01:13:35 <shachaf> Guest88305: This is a general-purpose Haskell-talking place, not just for tryhaskell.org
01:13:47 <shachaf> But if you have some questions people will probably be happy to answer. :-)
01:13:58 <Guest88305> oh sorry :P.
01:14:02 <Guest88305> Thanks :).
01:14:34 <fmap> kallisti: not very surprisingly if you consider using git log
01:15:24 <osfameron> well, changelogs are different to git log
01:15:24 <kallisti> fmap: but a change log is a nice way to communicate important API changes, bug fixes, etc that get lost in large commit logs.
01:15:25 <Guest88305> I do have one question, I heard Haskell is a programming language for "super smart math geniuses". So do you fit that category and if not, what made you interested in learning Haskell?
01:15:55 <osfameron> yeah, they summarize over *releases* rather than single changes
01:16:07 <shachaf> Guest88305: That's a silly rumour.
01:16:09 <kallisti> Guest88305: I'm not super, smart, or a math genius.
01:16:10 <darkniobe> I'm not a super smart math genius, but I love haskell
01:16:14 <shachaf> Guest88305: You should read the FAQ:
01:16:15 <mauke> Guest88305: I think perl6/pugs pulled me in
01:16:15 <shachaf> @where faq
01:16:15 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
01:16:34 <darkniobe> I got pulled in by its elegance and conciseness
01:16:40 <Guest88305> reading it now :).
01:17:50 <kallisti> so, I'm decided that adding a PVP-compliant constraint  for my data-default dependency is a complete waste of time. Does that make me a bad person?
01:18:06 <Veinor> not really
01:18:11 <mauke> what's a PvP?
01:18:34 <darkniobe> I'm immediately thinking player vs player..
01:18:43 <kallisti> I mean... it's literally a package the exports one typeclass. The only thing that's going to change is new instances (that will never affect my usage)
01:18:43 <darkniobe> <-- mmorpg goon
01:18:53 <kallisti> package version policy
01:19:43 * mauke promptly uploads an incompatible version
01:21:29 <kallisti> I guess I could include a pretty lenient constraint...
01:22:57 * hackagebot hlint 1.8.29 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.29 (NeilMitchell)
01:26:35 <kallisti> there. now all 24 dependencies have upper and lower constraints
01:46:47 <womb> Hi all!!!
01:47:02 <frerich> Peaker recently discussed bottle ( https://github.com/Peaker/bottle ) here, a shot at coming up with a clever editor for Haskell programs. Does anybody here happen to have a build of it around? I'd like to have a screenshot or two (for a little prsentation) but I can't build it here in the office. :-/
01:51:00 <irene-knapp1> oh, cool, he implemented it
01:51:06 <irene-knapp1> no, I haven't built it, sorry
01:53:21 <mekeor> hi womb.
01:54:55 <mekeor> frerich: how did you try to build it?
01:55:29 <frerich> mekeor: I'm on Windows 7 here; stopped trying at that point. I did manage to get it build at home on the Mac after a lot of tinkering.
01:55:48 <mekeor> so, the editor works?!?
02:00:17 <frerich> It has rough edges but it's getting there, yeah.
02:45:53 <saep> good morning
02:46:02 <mekeor> good morning, saep!
02:46:05 <mekeor> @time saep
02:46:06 <lambdabot> Local time for saep is Fri Jun  1 11:45:44 2012
02:46:12 <mekeor> same time here.
02:47:52 <yywi> @time yywi
02:47:56 <lambdabot> Local time for yywi is Fri Jun  1 11:47:34 2012
02:51:08 <adamt> @time adamt
02:51:09 <lambdabot> Local time for adamt is Fri Jun  1 11:51:02
02:51:15 <adamt> Oh, it's cheating!
02:51:50 <adamt> I half expected it to lookup tz data based on geoip, and wanted to see it fail on a cloaked host. :P
02:51:56 <mekeor> you can type "@time" (without a nick) if you want to get your local time.
02:52:11 <mekeor> adamt: :D
02:52:25 <adamt> i can see my local time in the top of my screen. hehe.
02:52:42 <yywi> > "@time"
02:52:43 <lambdabot>   "@time"
02:53:33 <mekeor> @time lambdabot
02:53:34 <lambdabot> I live on the internet, do you expect me to have a local time?
02:53:48 <saep> @utc lambdabot
02:53:48 <lambdabot> Maybe you meant: ft ghc rc src url
02:53:50 <saep> :S
02:54:01 <yywi> lol
02:58:48 <KaneTW> @time kanetw
02:58:51 <lambdabot> Local time for KaneTW is Fri Jun  1 11:58:21 2012
03:01:25 <yywi> #pl \x->x
03:01:29 <yywi> @pl \x->x
03:01:30 <lambdabot> id
03:01:41 <mroman> @pf (.)f
03:01:42 <lambdabot> Maybe you meant: bf pl
03:01:58 <yywi> bf pl
03:02:12 <mroman> Oh. No pointful :(
03:02:26 <mekeor> hehe :D
03:02:37 <yywi> do you mean @unpl?
03:02:41 <yywi> @unpl id
03:02:41 <lambdabot> (\ a -> a)
03:02:43 <mroman> @unpl (.).f
03:02:43 <lambdabot> (\ g b c -> f g (b c))
03:03:08 <mekeor> cool
03:03:20 <yywi> > [1..]
03:03:21 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
03:03:40 <mekeor> what does djinn actually do? i still don't understand it…
03:03:55 <mikeplus64> try to make a function from a type
03:04:07 <mikeplus64> @djinn a -> a
03:04:07 <lambdabot> f a = a
03:04:22 <yywi> @djinn (a -> b) -> a
03:04:22 <lambdabot> -- f cannot be realized.
03:04:27 <mroman> @djinn (a -> b) -> c -> (c -> a -> b)
03:04:28 <lambdabot> f a _ _ b = a b
03:04:43 <mekeor> @djinn a -> b
03:04:43 <lambdabot> -- f cannot be realized.
03:04:46 <mekeor> hehehe
03:05:12 <mroman> @djinn a -> b -> c -> (c -> a -> b)
03:05:12 <lambdabot> f _ a _ _ _ = a
03:05:27 <mroman> that doesn't seem right.
03:05:28 <yywi> @djinn ((a -> b) -> c) -> (a -> b) -> c
03:05:29 <lambdabot> f a = a
03:05:37 <mekeor> mroman: it is.
03:06:01 <mekeor> (a -> (b -> c)) is the same as (a -> b -> c)
03:06:16 <yywi> -> is left associative
03:06:19 <mikeplus64> @djinn Maybe a -> a
03:06:19 <lambdabot> -- f cannot be realized.
03:06:48 <mroman> @djinn a -> b -> c -> c -> a -> b
03:06:48 <lambdabot> f _ a _ _ _ = a
03:07:13 <mroman> Yeah ok.
03:07:17 <mroman> It satisfies the type.
03:07:25 <mroman> But it's not really the function I was expecting :)
03:07:38 <merijn> mroman: Picky, picky :p
03:07:49 <merijn> What were you expecting, then?
03:08:21 <frerich> mroman: I think that without any type class qualifiers the function actually cannot have any other possible implementation.
03:08:23 <mroman> f a b c = (\c a -> b)
03:08:29 <mroman> something like that.
03:09:08 <mroman> frerich: There are plenty of possible implementations.
03:09:12 <merijn> That's not right with the unparenthesised a -> b
03:09:12 <mroman> @djinn a -> b
03:09:12 <lambdabot> -- f cannot be realized.
03:09:32 <yywi> @djinn help
03:09:32 <lambdabot> -- f cannot be realized.
03:09:38 <merijn> @djinn (a -> b) -> c -> c -> a -> b
03:09:39 <lambdabot> f a _ _ b = a b
03:09:46 <merijn> See, that's what you expecte
03:09:57 <mroman> Yeah.
03:10:10 <mikeplus64> @djinn Monad m => a -> m a
03:10:10 <lambdabot> f = return
03:10:14 <mroman> Not really :)
03:10:15 <merijn> Actually, no
03:10:19 <merijn> wat
03:10:41 <mroman> (a -> b) -> c is not the same as a -> (b -> c)
03:10:41 <merijn> oh, still makes sense, though
03:11:04 <yywi> @djinn Functor f => (a -> b) -> f a -> f b
03:11:05 <lambdabot> Error: Class not found: Functor
03:11:29 <yywi> hmm
03:11:31 <mikeplus64> @djinn Monad m => (a -> b) -> m a -> m b
03:11:31 <lambdabot> -- f cannot be realized.
03:11:42 <yywi> liftM?
03:11:46 <mikeplus64> @djinn Monad m => (a -> m b) -> m a -> m b
03:11:46 <lambdabot> f a b = b >>= a
03:11:48 <mroman> @djinn (Eq a) => a -> a -> Bool
03:11:48 <lambdabot> f = (==)
03:11:57 <mroman> Still pretty good though @djinn
03:12:18 <hpc> @djinn (Eq a) => a -> a -> a -> Bool
03:12:18 <lambdabot> f a b _ = a == b
03:12:28 <mroman> @djinn (Eq a, Monad m) => m a -> m a -> m Bool
03:12:29 <lambdabot> -- f cannot be realized.
03:12:45 <mroman> @djinn (Eq a, Monad m) => a -> a -> m Bool
03:12:45 <lambdabot> -- f cannot be realized.
03:12:57 <hpc> looks like it just doesn't know how (>>=) and inner lambdas work
03:12:58 <sipa> djinn doesn't know about type classes, afaik
03:13:28 <mroman> @djinn (Eq a, Monad m) => m a -> m Bool
03:13:28 <lambdabot> -- f cannot be realized.
03:13:34 <mroman> hm.
03:13:48 <hpc> @djinn a -> ((b -> a) -> a) -> a
03:13:48 <lambdabot> f a b = b (\ _ -> a)
03:13:53 <hpc> hmm
03:13:59 <mroman> @djinn (Monad m) => m a -> a
03:13:59 <lambdabot> -- f cannot be realized.
03:14:02 <yywi> @djinn Monoid m => m -> m -> m
03:14:02 <lambdabot> Error: Class not found: Monoid
03:14:07 <frerich> sipa: To some degree it does; it knows 'Eq'
03:14:24 <mroman> @djinn (Monad m) => a -> m a
03:14:24 <lambdabot> f = return
03:14:32 <mroman> and Monad to some degree.
03:15:15 <mroman> @djinn Maybe a -> a
03:15:15 <lambdabot> -- f cannot be realized.
03:15:40 <mroman> @djinn a -> Maybe a -> a
03:15:40 <lambdabot> f a b =
03:15:40 <lambdabot>     case b of
03:15:40 <lambdabot>     Nothing -> a
03:15:40 <lambdabot>     Just c -> c
03:16:20 <mroman> @djinn (Monad m) => a -> m a -> a
03:16:21 <lambdabot> f a _ = a
03:16:32 <mroman> :D
03:16:54 <yywi> @djinn a -> b -> a
03:16:54 <lambdabot> f a _ = a
03:17:08 <mroman> djinn likes doing nothing.
03:17:16 <mekeor> why do i get this error?
03:17:17 <hpaste> mekeor pasted “compile error: unknown symbol atexit” at http://hpaste.org/69366
03:17:35 <frerich> mroman: what would you have expected for '(Monad m) => a -> m a -> a'?
03:17:50 <mekeor> i get "unknown symbol `atexit'".
03:18:48 <mroman> Something like fromMaybe :)
03:18:51 <mroman> fromMonad :D
03:19:10 <frerich> mroman: Well see? You don't know much about the type other that it implements 'Monad' (which has no 'fromMonad' ;-).
03:19:11 <sipa> fromMonad is not generally possible
03:19:18 <mroman> frerich: I knowp.
03:19:23 <mroman> You can't match against m
03:19:24 <mroman> like
03:19:33 <mroman> f :: (Monad m) => m a -> a
03:19:36 <mroman> f (m a) = a
03:19:56 <frerich> mroman: So it's notlike djinn likes doing nothing. There's plain not more which the possible can possibly do. That's actually a really nice feature IMHO :)
03:20:09 <frerich> Being able to predict what a function can (or can not) do based ont he signature.
03:20:10 <mroman> frerich: I was referring to a -> b
03:20:17 <mroman> @djinn a -> b
03:20:17 <lambdabot> -- f cannot be realized.
03:20:21 <mroman> or what was it
03:20:29 <mroman> @djinn a -> b -> a
03:20:29 <lambdabot> f a _ = a
03:20:42 <yywi> const
03:20:44 <frerich> mroman: Yeah, same thing: what else should the function do? :)
03:21:05 <mroman> Hm.
03:21:09 <yywi> its result doesn't depend on b, and a doesnt have any typeclass constraints
03:21:16 <mroman> Without typeclasses probably there is really nothing else to do
03:21:28 <frerich> mroman: Right
03:21:54 <plat0> Do Haskell developers generally install ghc from source rather than use their distro's package?  And what do they do about libraries?  Use cabal?
03:21:55 <mroman> Didn't see that right away :(
03:22:38 <xraycat> plat0: at least I use the haskell platform + cabal
03:22:40 <mekeor> plat0: use cabal for libraries.
03:22:57 <mekeor> (or more precisely, cabal-install.)
03:23:14 <mikeplus64> plat0: i use binary ghc from my distro (7.4.1) and it's binary cabal package too
03:23:20 <mikeplus64> and install everything else via cabal
03:23:32 <mekeor> plat0: you can use GHC from source or distro. that doesn't matter much. but if you want a recent GHC, download/compile it yourself.
03:23:40 <mekeor> personally, i use GHC from distro.
03:23:41 <mroman> I always compile haskell platfrom from source.
03:24:06 <plat0> If I use my distro's ghc, and then I update it, will i have to rebuild all my cabal too?
03:24:09 <mikeplus64> arch dropped the HP recently because it was too old and crusty for an arch user's taste :)
03:24:11 <mekeor> mikeplus64 does the best.
03:24:14 <merijn> plat0: Step 1) Download+install Haskell Platform Step 2) Let Cabal handle the rest
03:24:47 <merijn> mikeplus64: Yes, but the result is the 90% of the linux users I hear complaining about broken stuff are Arch users >.>
03:24:47 <plat0> merijn: why would I use haskell platform rather than getting all those libs from cabal?
03:25:04 <mikeplus64> i recommend using the latest ghc rather than the HP, the HP updates way too slowly, breaking compatibility a lot
03:25:16 <mroman> plat0: As far as I remember packages are seperate per ghc version.
03:25:27 <mekeor> mikeplus64: what's HP?
03:25:30 <plat0> I'm using debian, if there's any specific advice for that
03:25:34 <plat0> mekeor: Haskell Platform
03:25:35 <adamt> mekeor: haskell platform
03:25:38 <mekeor> ah ok
03:25:48 <merijn> plat0: Haskell Platform makes sure all major libraries build with eachother
03:26:03 <merijn> Getting the latest GHC tends to result in packages not building and that sorta nonsense
03:26:08 <plat0> merijn: sort of like a pretested collection, that is known good?
03:26:33 <mikeplus64> yes, but i contest that in my experience using the HP has lead to a lot more packages not building than the other way around
03:26:38 <merijn> plat0: Yes, many (most?) people just upgrade GHC when HP moves to a newer version
03:27:03 <merijn> mikeplus64: I think you might just be an outlier then?
03:27:06 <mcstar> Due May 2012.
03:27:13 <xraycat> :-)
03:27:21 <mikeplus64> merijn: i dunno, what packages are broken if you *don't* use the HP?
03:28:23 <merijn> I had issues with Parsec, and some other libraries (I forgot which, this was early 2011), but haven't run into any broken packages using HP yet
03:28:36 <plat0> So I guess library providers should be making sure their packages work with all recent versions of platform?
03:29:00 <mikeplus64> unfortunately i don't think such as thing exists outside of haskell libs your distro may provide
03:29:03 <mikeplus64> plat0:
03:29:36 <plat0> I think I'll go with the ghc + cabal-install route and get everything else from cabal
03:29:45 <adamt> plat0: on my debian box i chose to get the newest binary ghc, install it, and then use the cabal-install bootstrap script to get cabal install running as well.
03:29:47 <plat0> since I am pulling forward ghc7 into debian stable 6.0 anyway
03:30:10 <plat0> adamt: does that install cabal-install as a binary packages?
03:30:16 <plat0> s/packages/package/
03:30:32 <adamt> plat0: it installs everything cabal-install related into your ~/.cabal by default
03:30:33 <plat0> there is a cabal-install package in debian
03:30:40 <plat0> is that what you mean?
03:30:59 <adamt> no, i mean actually building cabal-install from source (using their bootstrap-script)
03:31:21 <plat0> oh right
03:31:25 <plat0> so you don't even use the debian version of that
03:31:28 <adamt> no
03:31:46 <plat0> Why not build ghc from source too?
03:31:52 <adamt> ghc 7.4.1 comes with cabal 1.14 (i think) which matches cabal-install 0.14, i don't know whether it'll work if you use cabal-instrall from the repos.
03:31:53 <plat0> Is it  because it takes a long time?
03:32:04 <adamt> plat0: You need the binary ghc to build ghc from source.
03:32:18 <plat0> Oh ok
03:32:30 <adamt> (if i remember correctly)
03:32:43 <plat0> Well I think I'll get cabal-install from debian too
03:32:53 <plat0> since it ought to be matched correctly to the ghc version
03:33:02 <plat0> and then use cabal-install to get everything else from source
03:43:03 <answer_42> 6/part
03:43:13 <answer_42> 6/part
03:50:11 <mekeor> do you know a nice library for drawing points, lines and circles and other simple shapes in a window?  i know of HGL/SOE but that's quite outdated; it doesn't build with current GHC.
03:50:51 <yywi> SDL?
03:51:28 <ClaudiusMaximus> gloss?
03:51:50 <yywi> ah nevermind, i think SDL only has rectangles
03:52:14 <mekeor> gloss sounds nice.
03:52:20 <hpc> cairo specializes in vector graphics
03:53:02 <mekeor> i want to draw into a window. can gloss do that?
03:53:33 <ClaudiusMaximus> mekeor: a new window, or an existing window?
03:53:39 <mekeor> new window.
03:53:55 <mgsloan> I'm partial to my library: https://github.com/mgsloan/gtk-toy/blob/master/src/Graphics/UI/Gtk/Toy.hs
03:53:55 <lambdabot> mgsloan: You have 1 new message. '/msg lambdabot @messages' to read it.
03:54:06 <mgsloan> just gives you a GTK canvas
03:54:40 <ClaudiusMaximus> mgsloan: thanks for the reminder about gtk-toy! was meaning to try that a couple of weeks ago
03:54:44 <mgsloan> this one isn't exactly "nice", as it's WIP, but: https://github.com/mgsloan/gtk-toy-diagrams
03:54:50 <ClaudiusMaximus> and got distracted by shiny things
03:55:02 <mekeor> ClaudiusMaximus: so, the answer to "i want to draw into a window. can gloss do that?" is "yes"?
03:55:14 <mgsloan> ClaudiusMaximus: Cool!
03:55:18 <ClaudiusMaximus> mekeor: looks like it - http://hackage.haskell.org/packages/archive/gloss/1.7.4.1/doc/html/Graphics-Gloss.html
03:55:25 <mgsloan> I think it's a pretty straightforward way of slicing things
03:55:59 <mgsloan> gtk-toy-diagrams does a decent job, I think, of generalizing UI buttons and sliders to N-D, and working that into the diagrams layout system
03:56:27 <mekeor> http://www.mgsloan.com/ ← cool!
03:56:49 <mekeor> ClaudiusMaximus: thank you!
03:56:52 <mekeor> ClaudiusMaximus++
03:59:47 <mgsloan> mekeor: thanks!  I can't wait to write about this: https://github.com/mgsloan/quasi-extras/blob/master/examples/Example2.hs
04:00:39 <timthelion> cabal install yessod-platform doesn't work on ghc7.4.1 :(
04:01:37 <mekeor> mgsloan: you're a TH-geek?
04:02:05 <mekeor> mgsloan: wow! the code is awesome!
04:02:21 <mgsloan> mekeor: increasingly so, yes.  This does Haskell AST-literal pattern matches as quasi-quoters :)
04:02:31 <mekeor> what a bummer that only +, -, and * work.
04:03:08 <mgsloan> Well, you can use these as convenience to write any code transformation you care to
04:04:17 <covi> mgsloan: are you an undergrad, grad, or prof?
04:04:19 <mgsloan> Here's a string interpolator + string parser quasi-quoter in 55 lines: https://github.com/mgsloan/quasi-extras/blob/master/src/Language/Quasi/StringSub.hs
04:04:36 <mgsloan> covi - undergrad, actually going to graduate a few days from now
04:05:07 <timthelion> mgsloan: congradulations
04:05:20 <mgsloan> timthelion: thanks!!
04:05:34 <covi> mgsloan: cool and congrats, I am about to enter college this fall, but I am so n00b on everything.
04:06:00 <mroman> What is a college exactly?
04:06:06 <mroman> I never got the US education system :)
04:06:16 <timthelion> covi: I started writing haskell about your age(presuming you are indeed a young un, and not an old un who's just going to college now)
04:06:18 <adamt> Neither did i. It seems really messy. ;)
04:06:21 <AfC> mroman: it's what Americans call "university" (specifically, undergraduate level)
04:06:45 <adamt> so by going to college, people get what, bsc's?
04:06:48 <AfC> [ironically, Canadians tend to refer to it as "school"]
04:06:52 <mgsloan> timthelion: I really like the look of the code for your gridhaskell-haskarrow, btw! (haven't tried it) but it's along some ideas I've tried to mess with a little
04:07:08 <covi> adamt: universities offer different types of degrees
04:07:10 <merijn> covi: Dude, when I started university for my bsc I could write like 10 lines of python (and I was already ahead of the curve)
04:07:18 <sipa> right, i always wondered about the difference between college and university
04:07:19 <adamt> *bsc or equivalent.
04:07:26 <mroman> and what is an undergraduate?
04:07:29 <covi> timthelion: I see, have you been happy with haskell ever since?
04:07:41 <merijn> covi: Being a n00b at haskell puts you ahead of most BSc graduates (and even MSc!) that I know
04:07:43 <mroman> Some kind of "bachelor" in Europe but more american?
04:07:44 <AfC> adamt: no no, it's degree granting university. Like I said. In the US they tend to refer to such places as "colleges" (no relation whatsoever to Oxford / Cambridge colleges)
04:07:50 <timthelion> mgsloan: Unfortunately the code isn't done yet, so there is not much to see.  I'll ping you once I'm "self hosting"
04:08:03 <covi> merijn: thanks buddy, I am learning as much as I can now
04:08:04 <AfC> adamt: [c.f. "College Football" and "College Basketball"]
04:08:12 <merijn> mroman: Undergraduate just means "below graduate school" which is master's/phd in the US, I think
04:08:23 <mroman> Ok.
04:08:31 <AfC> merijn: yes
04:08:54 <mroman> so below master.
04:09:02 <sipa> so bachelor+master = undergrad?
04:09:02 <AfC> mroman: yes
04:09:06 <AfC> sipa: no
04:09:06 <sipa> phd = grad?
04:09:08 <sipa> ah
04:09:11 <AfC> sipa: no
04:09:14 <AfC> (I feel like a bot)
04:09:16 <mroman> We call that bachelor.
04:09:44 <mcstar> a college is someone you work with
04:09:45 <merijn> I thought master was also grad school
04:10:03 <sipa> here, first 3 years of university are called bachelor, next 2 years are called master, then additional master or phd, ...
04:10:12 <covi> sipa: bachelor = undergrad, master&phd = graduate student
04:10:13 <mroman> Is it hard to get into college in the US?
04:10:13 <AfC> in a few places PhD is refered to as "post grad" (as in post [masters level] graduate school) but not in North America
04:10:24 <merijn> sipa: In the US it is commond to skip the master
04:10:32 <AfC> in North America, post grad is something you do after you get a PhD (ie, post-doctoral fellowship)
04:10:34 <sipa> i see
04:10:46 <merijn> sipa: They just do bachelor -> phd (and if they fail their defense you get your master, something like that)
04:11:16 <sipa> hmmm, ok
04:11:18 <merijn> That's why US phd's are 6 years and include 2 years of class vs European phd's which are commonly 4 years (or even 3 in some places in the UK)
04:11:24 <AfC> merijn: [if you're lucky; in such circumstances you're likely already up against a hostile supervisor, and getting a Masters as they kick you out the door is fortunate]
04:11:46 <mgsloan> I'm not sure what I think of school.  Someone needs to set up a proper school of Haskell :D
04:12:03 <timthelion> covi: At first, I didn't *get* haskell.  And whent back to programming in C/Python.  But I ran into lots of bugs in one C project lately, and I had a kind of epiphany. And went back to haskell.
04:12:38 <mroman> Me too ;)
04:12:51 <covi> timthelion: I don't think I will even partly get haskell in years. There's just a tremendous hole of math, cs, math, and cs.
04:12:51 <mroman> Except that I made a stop at CLISP ;)
04:13:08 <mroman> and I still don't fully get it of course.
04:13:20 <timthelion> covi: oh, be quiet, I'm studying pedagogy.  So math can't be that vital to haskell.
04:13:38 <timthelion> of course I too don't fully get it.
04:13:52 <yywi> @djinn Monad m => (a -> m Bool) -> [a] -> m [a]
04:13:53 <lambdabot> Error: Undefined type []
04:13:56 <mroman> timthelion: It's not that vital ;)
04:14:09 <covi> timthelion: I mean you can *utilize* haskell of course. But if to *understand* and even *extend* a little bit, the theorectical foundation seems unevitable.
04:14:11 <mgsloan> covi: naah, Haskell's almost kinda simpler than some popular languages.  People write a lot of complicated mathematical stuff with Haskell, but the language itself is not so arcane as it seems
04:14:33 <timthelion> indeed, there are only like 3 people in the world who "fully get haskell" and they're all working for standard chardered bank ;)
04:14:45 <mcstar> uh
04:14:54 <covi> lol
04:15:01 <mgsloan> dons is 3 people?!
04:15:14 <Philippa_> enough theoretical foundation to "understand" everything but the type system is also rather easy though
04:15:23 <hpc> SPJ works for standard chartered?
04:15:26 <Philippa_> and it's so much easier to do Haskell work with pen and paper
04:15:34 <mroman> When I learnt haskell I didn't even have a graduation from apprenticeship :)
04:15:35 <timthelion> mgsloan: I've seen him at IRC saying something, and had a patch come through for Xmonad simultaniously, so he must be at least 2
04:16:02 <Philippa_> there are -3 people in the world who "fully get" C++
04:16:27 <timthelion> Philippa_: seems you've suffered some integer overflow
04:16:27 <ClaudiusMaximus> yywi: http://hackage.haskell.org/packages/archive/monad-loops/0.3.3.0/doc/html/Control-Monad-Loops.html#v:dropWhileM perhaps?
04:16:30 <hpc> Philippa_: there's more than that
04:16:30 <mgsloan> hehe, probably capable of that /because/ of xmonad
04:16:36 <povman> Philippa_: I'm -1 of those
04:16:44 <hpc> Philippa_: you can tell because there exist groups of people who know C++ and choose not to use it
04:16:49 <Philippa_> hpc: in magnitude, perhaps :-)
04:16:58 <Philippa_> you don't have to /fully/ get C++ to know to make that choice :-)
04:17:17 <yywi> ClaudiusMaximus: nah, filterM :)
04:17:26 <sipa> i want C++ with a decent module system, type inference, type classes, abstract data types, ... :(
04:17:36 <mroman> sipa: You mean D?
04:17:54 <Nafai> sipa: that doesn't sound much like C++
04:18:08 <ClaudiusMaximus> yywi: aha :)
04:18:38 <yywi> it *looks* like djinn is far from complete, or is it...
04:19:04 <hpc> i just want perl with a stronger type system and formal semantics
04:19:09 <mgsloan> I'm thinking of doing a series of quasi-quoters that incrementally move from a pythonic dialect of haskell to regular syntax haskell
04:19:37 <hpc> sounds terrifying
04:19:39 <mgsloan> if errors are handled well, could be a good way of teaching, especially if you have auto-port
04:20:15 <mgsloan> terrifying, yes, but handy for ceasing the avoidance of success
04:21:13 <mgsloan> I for one think that a pythonic Haskell that actually used Dynamic would be pretty nifty
04:22:48 <osfameron> hpc: I'm sure all of that's fixed in Six ;-)
04:24:50 <hpc> yeah, ive been meaning to learn perl6 but i don't really feel up to the challenge
04:25:03 <hpc> ridiculously abstract CT nonsense i can deal with, but perl? :D
04:30:28 <covi> Guys I am a complete n00b. Do you think Pandoc is a good project for me to learn from or contribute to?
04:32:32 <RichyB> If it does something that is useful to you then probably yes.
04:32:45 <RichyB> (Not knowing anything about Pandoc specifically.)
04:33:08 <covi> I see
04:37:29 <byorgey> covi: I think so, yes
04:39:16 <merijn> covi: I think the most important thing is just finding a project you like/find interesting. Difficulty is secondary
04:43:32 <mcstar> im thinking about writing a theorem prover
04:44:14 <mcstar> john harrisons book seems adequate
04:44:30 <mcstar> but its in ocaml(not that its bad or anything)
04:49:50 <teneen> can someone tell me a case where Control.Monad.State.Lazy and Control.Monad.State.Strict will return different results?
04:51:50 <mekeor> teneen: i don't think that's possible at all. why should they return different results?
04:52:15 <hpaste> aforemny pasted “poppler-0.12.2 build” at http://hpaste.org/69368
04:52:19 <mekeor> aren't they just lazy and strict? i mean, there's no other difference, is there?
04:52:31 <teneen> mekeor: maybe not different results, maybe one will work and the other will not?
04:52:34 <Phlogistique> mekeor: that's still a semantical difference, isn't it?
04:52:48 <aforemny> Hello. I am trying to install poppler-0.12.2 and I am getting errors related to Pango. Any suggestions what would cause this?
04:53:11 <mekeor> teneen: yea, that'd be possible, i think. -- but hey, i'm a noob.
04:54:48 <aforemny> Errors can be seen in the paste above. (http://hpaste.org/69368)
04:55:37 <teneen> when will the lazy pattern matching in Control.Monad.State.Lazy make a difference?
04:56:47 <hpc> > let (x, y) = undefined in 15 -- strict state could bottom out in cases similar to this
04:56:48 <lambdabot>   15
04:56:51 <hpc> er
04:57:05 <hpc> > case undefined of (x,y) -> 15 -- this one
04:57:06 <lambdabot>   *Exception: Prelude.undefined
04:57:20 <hpc> > case undefined of ~(x,y) -> 15 -- lazy state would work
04:57:21 <lambdabot>   15
04:57:54 <hpc> that wouldn't likely matter in real code
04:58:13 <ceii_> evalState (forever (return ()) >> return ()) () terminates with lazy state
04:58:26 <teneen> hpc: but the patter matching is not against state, it's against the pair of the state and the return value (a,s)
04:59:14 <hpc> teneen: that's what i mean; different ways of matching on a tuple yield different results
04:59:25 <hpc> and strict/lazy state differ only in how they match on their tuple
04:59:29 <hpc> (iirc)
05:03:28 * hackagebot fb 0.9.1 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.9.1 (FelipeLessa)
05:03:38 <hpc> whoa
05:04:15 * FreeHero Your country need you http://www.erepublik.com/en/referrer/FreeHero
05:16:09 <deggis> uh, let's see. i'm using GHC API to compile code dynamically, which works as intended. i'm using cabal-dev, and i'd like to point GHC API to use sandboxed package-conf (like ghc -package-conf=...)
05:16:41 <deggis> there's http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/GHC.html extraPkgConfs dynflag, but it doesn't seem to be enough
05:18:00 <deggis> is there something else to do other than set extraPkgConfs = ["... /packages-7.4.1.conf/"] in dynflags to use sandboxed package conf?
05:18:11 <sopvop> what function splits list in two with predicate, like ([satisfying], [others])?
05:18:46 <yywi> break, span
05:18:51 <fmap> > partition (>5) [1..10]
05:18:52 <lambdabot>   ([6,7,8,9,10],[1,2,3,4,5])
05:18:57 <sopvop> nay, span is wrong
05:19:16 <sopvop> oh, thanks
05:19:42 <fmap> @src partition
05:19:43 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
05:19:43 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
05:19:43 <lambdabot>                               | otherwise = (ts, x:fs)
05:21:39 <sopvop> what does `~` mean in ~(ts,fs) ?
05:21:58 <hpc> sopvop: irrefutable pattern
05:22:13 <hpc> sopvop: basically, it says "always match this pattern, but don't evaluate anything right away"
05:22:30 <hpc> "if it's not a match and we try to evaluate on it, runtime error"
05:23:01 <hpc> > case Nothing of ~(Just x) -> 5
05:23:02 <lambdabot>   5
05:23:05 <hpc> > case Nothing of ~(Just x) -> x
05:23:06 <lambdabot>   *Exception: <interactive>:(3,0)-(4,21): Irrefutable pattern failed for patt...
05:23:14 <sopvop> Oh
05:23:31 <hpc> > case Nothing of ~(Just x) -> 5; Nothing -> 100 -- irrefutable patterns always match
05:23:31 <lambdabot>   5
05:23:39 <mekeor> > case Nothing of (Just x) -> 5
05:23:40 <lambdabot>   *Exception: <interactive>:(3,0)-(4,21): Non-exhaustive patterns in case
05:26:19 <sopvop> I don't get it. Haskell should be lazy anyway.
05:26:46 <Botje> pattern matching is one of the places where you need to be strict.
05:26:55 <Botje> well, strict on whatever is matched.
05:27:56 <sopvop> so, in case of partition,  it does not evaluate tuple if there is no match with predicate?
05:28:42 <sopvop> No, it does. I'd rather not use what I don't understand anyway.
05:29:10 <Botje> shrug. partition works
05:29:15 <Botje> you don't have to know *how* it works
05:29:26 <jaxtr> ahh it's a wonderful day!
05:29:28 <Botje> and the ~ just makes it a bit faster
05:30:26 <sopvop> I mean, I won't use it in my code.
05:32:13 <sopvop> Otherwise I'd never start using haskell, because you can't use it without monads (IO, atleast). And monads are hard to understand, even after blogging monads tutorial :)
05:34:03 <zomg> The IO monad is easy.. I mean you just need to know that in order to do IO you need to put IO Something into the return type :P
05:34:10 <zomg> Well, for the basic stuff anyway
05:34:24 <zomg> Best way to learn monads imo is to just go and use them
05:34:57 <taylorgb> Or just ignore them and do what you need to do to make things work, then discover in what wild and wonderful ways you're using them without realising it
05:36:03 <zomg> Yep
05:37:12 <taylorgb> It's not really any different than learning any other programming language, certainly in my first C++ lecture I was told to "ignore" a lot of the more complicated syntax.
05:37:58 <zomg> From my biased perspective I'd argue that haskell has a pretty steep learning curve in order to be able to do anything useful
05:38:05 <zomg> But as said, I might be biased =)
05:38:53 <zomg> I started using Clojure the other day and was worried I wouldn't be able to do anything but it was a piece of cake, despite being a weird lisp-language
05:39:11 <taylorgb> :)
05:39:20 <zomg> It took ages with Haskell to learn it enough to do stuff besides some basic things
05:39:27 <sopvop> haskell is not hard, you just need to learn more
05:39:39 <zomg> Learning is hard, let's go shopping!
05:39:44 <sopvop> yay1
05:40:17 <taylorgb> Many people starting to program using imperative languages seem to take a few years to extend much beyond parsing csv's, and making sheep "baa" to the console via a reference to an animal base class.
05:40:28 <cozachk> haskell is kind hard if you do not already know how to do some of the things in other languages
05:41:14 <zomg> taylorgb: yeah it's sort of difficult to say how it would be if you started from scratch with Haskell vs. some other language
05:41:26 <zomg> Maybe I should get my brain fried so I forget everything about programming and find out!
05:44:06 <ClaudiusMaximus> what's the fastest 2D spatial index with RealFrac coordinates ?  i need to build an index from ~4M samples, combining with an approxEq, with maybe 1k distinct equivalence classes; then i need to look up in that index for each sample
05:45:46 <pseudoprime> Hi guys, I am fairly new to haskell and I am having some troubles with cabal. I was hoping I could get a little guidance.
05:46:17 <pseudoprime> I need to install named-formlet, which depends on blazehtml >4 && <5. blaze-html fails to build.
05:46:41 <ClaudiusMaximus> so far i tried a modified version of the 'pktree' package, but it was slower than my list-based thingy using something like   build = nubBy approxEq  ; lookup = listToMaybe . filter approxEq
05:46:48 <hpaste> pseudoprime pasted “failed build” at http://hpaste.org/69370
05:48:04 <mekeor> pseudoprime: wait. >4 && <5 ??
05:48:31 <pseudoprime> mekeor: yes. http://hackage.haskell.org/packages/archive/named-formlet/0.1/named-formlet.cabal
05:50:00 <sopvop> Looks like -XOverloadedStrings is ommited from blaze-html
05:51:43 <pseudoprime> I think I am fine with that, I just install 0.4.3.2 instead
05:52:44 <sopvop> well you could have cabal unpack, add one line and cabal install it. does not take long :)
05:53:29 <pseudoprime> one last question though - a dependancy is pgsql-simple >=0.1.1, which doesnt appear to be in cabal.
05:53:44 <pseudoprime> do i need to use the git source for that?
05:53:55 <sopvop> you could try
05:54:08 <pseudoprime> is there another way?
05:56:05 <sopvop> Cabal can't make package out of thin air. hackage is just a file server with archives and docs.
05:57:49 <medhu> can haskel be started as a first programming language to learn?
05:58:18 <Axman6> yes
05:58:36 <Axman6> for many of the first years I teach, it is their first language
05:59:20 <copumpkin> "first years" = people
05:59:20 <d-snp> Axman6: where do you teach?
05:59:49 <medhu> first years as in some engineering/computer science degree?
05:59:58 <Axman6> the ANU
05:59:59 <medhu> or high school?
06:00:02 <d-snp> I hadn't heard of a univ. where their introduction to programming course is in a functional language :D
06:00:05 <Axman6> university
06:00:19 <d-snp> ANU..?
06:00:19 <Botje> d-snp: our uni teaches Scheme.
06:00:31 <d-snp> Botje: are you dutch? which uni is that?
06:00:32 <fmap> the danger is haskell can be the last language to learn
06:00:33 <Axman6> the Australian National University
06:00:36 <d-snp> ah
06:00:42 <Botje> vub.ac.be
06:00:48 <d-snp> ah
06:00:57 <medhu> even iiit.ac.in teaches scheme :)
06:01:01 <dmwit> UPenn teaches OCaml.
06:01:17 <copumpkin> as a first language?
06:01:21 <dmwit> yep
06:01:23 <copumpkin> nice
06:01:25 <d-snp> god, nvm I guess our university just sucks, teaching Java :P
06:01:37 <dmwit> The PL group got a hold of the intro class. =D
06:01:51 <Botje> d-snp: rebel! start a course based on SICP!
06:01:51 <pseudoprime> haskell just broke aptitude :/
06:01:52 <copumpkin> my school has two required intro courses: one java and one haskell :P
06:01:53 <Axman6> we used to teach java in the last third of this course, but that changed this year
06:01:58 <Botje> hold it in the parking lot if you have to :)
06:02:10 <copumpkin> that happened after I left though
06:02:35 <d-snp> Botje: I'm not qualified yet :P
06:02:38 <medhu> Axman6: is comp3610 you teach?
06:02:58 <Axman6> COMP1100. what's the title of 3610?
06:03:35 <Axman6> programming languages?
06:03:52 <Axman6> yeah, I took that last year (as a student)
06:04:10 <Axman6> I should also note that when I say teach, I mean I'm one of the course tutors
06:05:53 <depy> what do you guys are using haskell for right now? your current projects..
06:06:16 <d-snp> I'm implementing a transport layer protocol :P
06:11:49 <mekeor> I'm implementing a program drawing sierpinskis triangle with sort of random points.
06:12:13 <Ptival> dmwit: I guess it's Ben Pierce?
06:12:42 <dmwit> I think it was taught by Steve Zdancewic most recently, and Stephanie Weirich before that.
06:12:47 <Ptival> ok
06:12:54 <dmwit> A lot of the work of developing the course was Benjamin and Steve, though.
06:13:04 <Ptival> contamination :)
06:13:25 <Axman6> mekeor:  you're not at ANU are you? that was this week's lab...
06:14:10 <mekeor> i'm not at university at all.
06:14:12 <mekeor> hehe
06:14:24 <mekeor> i'm at -- how do you call that? highschool?
06:15:23 <mekeor> Axman6: which graphics-library did you use?
06:15:47 <Axman6> gloss
06:16:00 <mekeor> i use gloss, too.
06:16:03 <Axman6> (which was originally written at ANU)
06:16:08 <mekeor> but i'm having trouble with it…
06:16:14 <Axman6> yeah?
06:16:18 <mekeor> Axman6: ah, yes. it's a fork… i read that.
06:16:55 <mekeor> Axman6: you wanna see the code? it's ugly.. and doesn't work really yet.
06:17:20 <Axman6> sure
06:17:24 <mekeor> Axman6: i want that the user has to press a key to get the next point.
06:17:35 <Axman6> ah ok
06:17:51 <hpaste> mekeor pasted “Axman6: here it is” at http://hpaste.org/69373
06:17:53 <Axman6> hmm, isn't there a game play function, which lets you react to key actions?
06:18:04 <mekeor> yea, i use playIO
06:18:33 * hackagebot cabal-debian 1.23 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-1.23 (DavidFox)
06:19:43 <mekeor> Axman6: never mind. i'll try to debug it myself.
06:20:01 <Axman6> righto
06:20:12 <mekeor> just say: is it normal that when i press ESC i get "<interactive>: interrupted" "<interactive>: warning: too many hs_exit()s" "Process haskell exited abnormally with code 252" ?
06:20:12 <mekeor>  
06:20:49 <mekeor> i load it in GHCI and type "main" and then i type ESC in the Gloss-window and then i get this error.
06:21:03 <mekeor> and GHCi exists.
06:21:06 <Axman6> try compiling it and seeing if you get the same thing
06:21:16 <mekeor> ok
06:23:17 <mekeor> no. compiled, it exits with code 0 (zero).
06:23:28 <pseudoprime> http://hpaste.org/69374
06:23:33 <mekeor> (i tested with "echo $?".)
06:23:45 <pseudoprime> do you guys have any idea why cabal seems to not notice the package it just installed
06:24:18 <mekeor> pseudoprime: replace "cabal build" with "cabal install".
06:24:58 <mparodi> @src splitAt
06:24:58 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
06:25:08 <pseudoprime> thank you mekeor :)
06:25:21 <mekeor> i'm glad to help you :)
06:25:38 <fmap> cabal build only makes package ready for installation
06:25:40 <mekeor> mparodi: just for your information: you can PM lambdabot, too ;)
06:26:03 <mparodi> ok, I'll consider that
06:26:16 <mekeor> in, PMs :t doesn't work though… you have to use @type, AFAIK.
06:26:25 <mparodi> hmn, let me see
06:26:44 <mparodi> yep
06:26:47 <mekeor> :)
06:36:37 <HugoDaniel> is there something similar to graphite in haskell? http://graphite.wikidot.com/
06:46:39 <Axman6> mekeor: I think I got working what you were trying to do with your sierpinski triangles code, you interested in seeing what I've done?
06:46:54 <mekeor> yes!!
06:47:28 <mekeor> Axman6: paste pls
06:47:57 <Axman6> one sec, cleaning it uo a bit
06:48:04 <mekeor> ok
06:49:21 <hpaste> Axman6 pasted “Triangles for mekeor” at http://hpaste.org/69376
06:50:10 <mekeor> that short? oO
06:50:42 <Axman6> does it do what you're after?
06:51:21 <mekeor> how to use it?
06:51:30 <mekeor> space, okay.
06:51:35 <Axman6> yeah
06:51:41 <mekeor> Axman6: er, no.
06:51:47 <mekeor> i did that once, too.
06:51:58 <mekeor> but i wanted to draw the triangle another way.
06:52:44 <mekeor> here is the code with which i did that, btw: https://github.com/MekeorMelire/Sierpinski-Triangle/blob/master/Sierpinski.hs
06:52:46 <Axman6> righto
06:52:46 <mekeor> anyway.
06:53:05 <mekeor> Axman6: so, you have the three edges of the triangle, right?
06:53:12 <mekeor> then you take another point.
06:53:32 <mekeor> you draw this point.
06:54:28 <mekeor> your next point (which you draw next) is the middle of the current point and of one randomly chosen edge of the triangle.
06:54:30 <mparodi> > Could not find module `Graphics.Gloss.Interface.Game'
06:54:31 <lambdabot>   <no location info>: parse error on input `module'
06:54:34 <mparodi> yes, I'm curious >_>
06:54:37 <mekeor> that's what i wanted to do.
06:54:49 <dmwit> mparodi: cabal install gloss
06:54:52 <mekeor> mparodi: Graphics.Gloss.Interface.Pure.Game
06:54:59 <mekeor> insert "Pure."
06:55:04 <mekeor> then it works.
06:55:12 <mparodi> installing :>
06:55:18 <mparodi> thanks dmwit
06:55:35 * Axman6 is using an old gloss
06:56:17 <Axman6> the update functions should really return a tuple with a bool that says that the image has actually been changed. it's really annoying how gloss tries to constantly redraw the image
06:56:37 <parcs`> i think it would be easier to draw a sierpinski triangle with opengl
06:56:56 <Axman6> it is being drawn using OpenGL...
06:57:04 <mekeor> Axman6: i want to do this: http://www.cut-the-knot.org/Curriculum/Geometry/SierpinskiChaosGame.shtml
06:57:08 <parcs`> i mean using opengl directly
06:57:45 <parcs`> after all triangles are the primitive to opengl
06:57:57 <mekeor> but i dont wanna make it with triangles!
06:58:08 <parcs`> with points it's easy too
06:58:08 <mekeor> that's the point. i want to do it as chaos game.
06:58:13 <mekeor> ah, ok then ;)
06:58:34 <mekeor> parcs`: but also need to keys.
06:58:57 <parcs`> use GLFW-b
06:59:03 <mekeor> i wanna do one more point with each pressed key or so.
07:01:54 <mekeor> parcs`: can i draw rectangles with openGL directly, too?
07:02:21 <mekeor> parcs`: is there anything which i can't do with openGL directly but with Gloss?
07:02:30 <mekeor> (apart from keys.)
07:02:42 <parcs`> dunno, i have never used gloss ;)
07:02:49 <mekeor> :)
07:02:50 * Axman6 is really annoyed that OS X does;t support OpenGL > 3.2
07:02:55 <Axman6> doesn't*
07:03:38 <parcs`> yeah you can draw rectangles in opengl, either directly (which is deprecated but it doesn't matter) or with two triangles
07:03:53 <mekeor> why deprecated?
07:04:03 <parcs`> i'm not sure
07:04:28 <Axman6> because programmable GPUs are the way of the future
07:04:39 <mekeor> howbeit.
07:04:40 <Axman6> and the now, and near past
07:04:49 <womb> Axman6: will support in Mountain Lion 10.8
07:04:55 <Axman6> do ALL the things using shaders!
07:05:13 <Axman6> womb: which version though? I'm hoping for 4.0+
07:05:40 <womb> Axman6: i'm not sure because 10.8 is still in dev
07:05:47 <aristid> Axman6: what does 4.0 bring?
07:05:56 <mekeor> does the game "frag" still work/compile/build (with current ghc)?
07:06:08 <Axman6> aristid: well, not a lot over 3.3 afaict
07:06:39 <aristid> Axman6: and what does 3.3 bring over 3.2?
07:06:44 <Siod> what are some examples of dependent types?
07:06:51 <Axman6> it's just annoying to have a GPU which is so powerful, and not being able to really harness it for graphics to its full potential
07:06:56 <aristid> it seems like my linux laptop is stuck on 2.1, but that might be due to using an ancient intel igp
07:07:02 <Axman6> aristid: more powerful shaders i believe
07:07:20 <aristid> Axman6: the OpenCL shit is independent from the OpenGL version, is it?
07:07:21 <mekeor> Siod: vectors
07:07:45 <Siod> mekeor: which kind of vector
07:07:46 <Jeanne-Kamikaze> Siod, template <int d> class vector
07:07:54 <Axman6> currently, I haven;t been able to get any shader example code I've seen to compile on OS X, since I think the syntax has changed quite a bit
07:08:03 <Siod> mekeor: dynamic arrays or the vectors from lin algebra
07:08:10 <mekeor> Siod: i mean, lists with a certain size. the size is the value which is stored in the dep-type.
07:08:18 <burbul> I can find a string replacement function for Text, but not String itself... am I missing something?
07:08:32 <aristid> Axman6: changed in 4? surely they wouldn't drastically change the syntax in a minor release
07:09:07 <mekeor> Siod: look at http://idris-lang.org/example to see the definition of Vector in Idris.
07:09:26 <mm_freak> how many packages are there on hackage?
07:09:32 <mekeor> (it uses GADT-syntax there…)
07:09:35 <Siod> mekeor: would a python or C++ string be an example of a dependent type, because it carries with it the size of the string?
07:09:42 <burbul> (nothing for lists either)
07:09:46 <Axman6> aristid: I'm not sure, I'm not an expert in the area. just trying to remember from the tutorials I've been looking at
07:09:56 <mm_freak> Siod: no
07:10:02 <Axman6> Siod: no, the type isn't part of its type
07:10:09 <Axman6> uh, the size isn't*
07:10:21 <aristid> Axman6: heh ok
07:10:29 <Axman6> you'd need vector<7,int>
07:10:31 <mm_freak> Siod: dependent types require the compiler to be an interpreter as well…  dependent type means /parameterized/ by a value
07:10:32 <sipa> the static type is by definition something known at compile time
07:10:35 <Siod> how about haskell types because they have an implicit bottom
07:11:17 <mekeor> what do you mean by "implicit bottom"?
07:11:30 <Siod> haskell types are boxed with _|_
07:11:39 <Axman6> also, if you had vector<7,int> foo; foo.push_back(3);, the type of foo would now have to be vector<8,int>
07:11:39 <mm_freak> Siod: a simple way to understand dependent types is to look at the dependent sum type:  a dependent sum is a tuple where the type of the second component depends on the value of the first
07:13:39 * hackagebot shelly 0.9.4.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.9.4.1 (GregWeber)
07:14:09 <Siod> so GADTs create dependent types?
07:14:36 <Axman6> in haskell, you might have Nil :: Vector Z a, Cons x Nil :: Vector (S Z) a, Cons x (Cons y Nil) :: Vector (S (S Z)) a. and you might have a cons function with type cons :: a -> Vector n a -> Vector (S n) a
07:14:48 <Axman6> you can use GADTs for dependant types I think
07:14:59 <byorgey> well, sort of kind of.
07:15:05 <byorgey> only in conjunction with other features.
07:15:18 <byorgey> GADTs themselves do not create dependent types.
07:17:32 <Siod> ok, so how about this: dependent types are any normal type composed with another type to generate a new type
07:18:00 <parcs`> no, dependent types are types that depend on values
07:18:13 <Siod> is that what composition does?
07:18:21 <Siod> s/is/isnt
07:18:32 <parcs`> what is composition?
07:18:41 <mekeor> function compisition? no!
07:18:59 <Siod> like in the vector example, you have two types: the vector and the constant size
07:19:15 <Siod> you combine/compose those two properties to make a new type
07:19:27 <Siod> for which they're obviously dependent on eachother
07:19:27 <aristid> no, that's not dependent types
07:19:38 <parcs`> a simple dependent type is 'f :: (a :: Int) -> (if a == 5 then Bool else String)' this says f is a function that returns a value of type Bool if its first argument is equal to 5, otherwise it returns a value of type String
07:20:59 <Siod> now i'm confused
07:21:08 <Siod> oh wait
07:21:20 <parcs`> do you see how the type of f depends on the value of its first parameter?
07:21:32 <Siod> yeah, i think understand now
07:21:48 <Siod> i was thinking of types at the level of the language not at compile time
07:21:54 <mekeor> Siod: consider 'Maybe'. 'Maybe' get's a type and makes a type of it, right?
07:21:54 <mekeor> @kind Maybe
07:21:55 <lambdabot> * -> *
07:22:03 <ski> Siod : btw, to support dependent types fully, you not only have to allow having types like `vector<7,int>', but it also as to be possible to store (in a `struct', say), or pass (to a function) both `int n' and `vector<n,int> v'
07:22:09 * mekeor is lagging.
07:22:26 <ski> Siod : where `n' is unknown at compile-time, but it *is* known at compile-time that the number `n' passed, and the `n' in the type of `v' are the *same*
07:22:53 <ski> (s/it also as to be possible/it also ought to be possible/)
07:24:39 <Siod> so dependent types aren't known at compile time; they're known at runtime?
07:26:15 <parcs`> what do you mean "aren't known"
07:26:43 <Siod> i suppose the possibilities of the dependent type are known, but it isn't known which possibility will be executed
07:26:46 <mekeor> Siod: In Haskell, when you write "data Foo bar = …", "bar" is necessarily a *type*. In dependently-typed programming languages, however, it can be a *value*, too. That's it, so easy.
07:27:09 <Siod> like in parcs example
07:28:38 <sipa> i'd say that c++ templates with int parameters are dependent types, but one where there is need for the compiler to iterate and know all values that will potentially be used at run time
07:28:59 <Siod> just int parameters?
07:29:27 <sipa> well, not type parameters obviously
07:29:39 <mcstar> 'bar' is a type variable
07:30:12 <Siod> could it be a string, float, ect parameter?
07:30:43 <sipa> i don't think you can use non-int types as template arguments in C++
07:30:57 <mm_freak> Siod: part of the confusion is that haskell does /not/ have dependent types =)
07:30:57 <ski> Siod : consider `f x = x * x' -- here the value of `x' isn't known at compile-time, but it's still known that all the occurances of `x' there refers to the same value, and the compiler can still reason about it, by knowing the *address* (relative to the stack pointer, say) of `x' at compile-time
07:31:21 <Siod> mm_freak: weird i only came to wonder about dependent types because http://permalink.gmane.org/gmane.comp.lang.haskell.cafe/98574
07:31:34 <Siod> mm_freak: look at the GADTs section
07:32:08 <mm_freak> yes, it's wrong to say that GADTs introduce dependent types
07:32:09 <Siod> sipa: you can
07:32:16 <mparodi> why sometimes lambdabot can't find a source?
07:32:25 <mm_freak> GADTs come close to dependent types, but don't quite reach them
07:32:31 <ski> mparodi : using `@src' ?
07:32:35 <mparodi> yep
07:33:02 <sipa> lambdabot doesn't know everything
07:33:05 <mparodi> for instance, @src lines
07:33:08 <mparodi> @src lines
07:33:08 <lambdabot> Source not found. stty: unknown mode: doofus
07:33:10 <ski> mparodi : because it's just looking at <http://code.haskell.org/lambdabot/State/source>
07:33:15 <mparodi> ah, good
07:33:17 <mm_freak> Siod: in a dependently typed language you could write this (contrived):  f :: (x :: Int) -> (if x == 3 then Bool else String)
07:33:19 <ski> @index lines
07:33:19 <lambdabot> Data.List, Prelude
07:33:24 <ski> @source Prelude
07:33:24 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
07:33:47 <mm_freak> Siod: notice how the /value/ of the argument determines the /type/ of the result
07:34:06 <Siod> and that's all a dependent type is then
07:34:24 <mcstar> mm_freak: but this can be emulated with unions
07:34:39 <mm_freak> that's where the border is:  haskell can't do that…  there are ways to achieve the same in haskell, but you're not using dependent types then
07:34:57 <Siod> it's hard to break away from an initial misconception in learning
07:35:03 <mm_freak> one particular thing you absolutely can't do in haskell:  require the argument to be in the codomain of a function
07:36:00 <mm_freak> like you have one function that squares numbers and another function that takes squares as its argument
07:36:14 <mparodi> @index sort
07:36:14 <lambdabot> Data.List
07:36:41 <mparodi> ski, but for example it can find the src of sort
07:37:01 <mparodi> and it's in the same module as lines
07:37:05 <ski> mparodi : because noone has bothered to put it into that file
07:37:17 <mparodi> alright :P
07:37:17 <ski> did you look at the file i pointed you to ?
07:37:21 <mparodi> yes
07:38:08 <ski> mparodi : except with unions, you wouldn't get type safety
07:38:10 <mparodi> I thought it was like a merge of different modules
07:38:31 <ski> mparodi : however, variant records, as present in Ada (and also Pascal), is a limited kind of dependent typing
07:38:34 <ski> er
07:38:37 <ski> mcstar ^
07:39:06 <ski> mparodi : no, it's just a manual list of (more or less) newbie-friendly versions of some common types and operations
07:39:53 <mparodi> do you mean it's not how it's really implemented?
07:40:22 <mcstar> actually im having trouble imagining how this dependent type would work, if it werent a union type behind it
07:40:34 <mparodi> well, there're differences in some definitions, I guess
07:40:57 <mcstar> in mm_freak's example, f wouldnt have a static return type, so i dont see how type inference could operate
07:45:16 <t7_> how can i represent subtypes with z3 ?
07:45:33 <t7_> like a is a sub of b but  d is not a sub of c
07:45:54 <t7_> (or any constraint solver)
07:48:49 <mm_freak> in the world of dynamic languages there is this buzzword called "test-driven development"
07:49:14 <mm_freak> is there a similar term for what i would call "specify-and-prove development" as you do it in haskell?
07:50:58 <mm_freak> mcstar: yes, f has a static type as does everything else…  in a depedently typed language just like in haskell typing information disappears entirely after compilation
07:51:02 <hpaste> bbrittain pasted “Hakyll Problem” at http://hpaste.org/69378
07:51:16 <dmwit> mm_freak: "type-driven development" for the kind where you prove it to the compiler; "fuzz testing" for the kind where you prove it to QuickCheck
07:51:22 <bbrittain> I'm having a problem with hakyll http://hpaste.org/69378
07:51:36 <bbrittain> oh woah... it posted for me!
07:51:40 <t7_> can i represent OOP subtyping as logic?
07:52:12 <mm_freak> dmwit: that sounds good
07:52:12 <dmwit> bbrittain: Check that your locale matches the encoding of whatever file it's trying to read.
07:52:41 <dmwit> bbrittain: Try the "locale" command.
07:52:59 <bbrittain> I checked my locale was UTF-8.... how do I know the locale of the file?
07:52:59 <mcstar> mm_freak: whoa, that goes against my common sense
07:52:59 <dmwit> If you're not in a UTF8 locale, probably getting into one is the easiest first thing to try.
07:53:22 <dmwit> bbrittain: No way to know what encoding the file is in except by inspecting it.
07:53:38 <dmwit> Try opening it with a few different encodings and see what works/what looks semantically correct.
07:53:56 <dmwit> There's a few ways to make educated guesses, and many text editors implement those, so try opening it in vim/emacs for a start.
07:54:10 <dmwit> In vim, you can find out what encoding it guessed with :set encoding?
07:54:36 <dmwit> The "file" command may give you a guess, too.
07:55:07 <mauke> no, :set encoding is vim's internal encoding
07:55:11 <mauke> try :set fenc?
07:55:24 <dmwit> huh, didn't know that
07:55:29 <dmwit> dmwit--
07:58:44 * hackagebot splot 0.3.3 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.3.3 (EugeneKirpichov)
07:59:09 <mm_freak> mcstar: think in haskell of a type that must be guaranteed to be nonzero if used as a divisor
07:59:35 <mm_freak> this can be done statically using a GADT and higher-rank types
07:59:42 <mm_freak> (or an existential type)
07:59:55 <mm_freak> dependent types is this on steroids =)
08:04:16 <mcstar> wiki GADT didnt help much :(
08:04:29 <hpaste> ClaudiusMaximus pasted “2D spatial index” at http://hpaste.org/69381
08:04:44 <Axman6> urgh, why does Repa have to be so complicated >_<
08:05:06 <ClaudiusMaximus> ^^ still not quite as fast as nubBy approxEq and list lookup, at least for small periods...
08:06:24 <mm_freak> mcstar: in a GADT the type arguments can be specified by the constructor
08:06:36 <mm_freak> data Zero; data NonZero
08:06:39 <mm_freak> data Nat where
08:06:46 <mm_freak>   Z :: Nat Zero
08:06:55 <mm_freak>   S :: Nat z -> Nat NonZero
08:07:47 <mm_freak> then Z :: Nat Zero, S Z :: Nat NonZero, S (S Z) :: Nat NonZero, etc.
08:08:25 <mm_freak> a non-G ADT can't do that
08:09:18 <mm_freak> in a regular ADT the type arguments are always specified by the user of the type, not by the type itself
08:09:20 <mekeor> did you mean "data Nat a where" ?
08:09:40 <mm_freak> mekeor: that's optional…  i tend to write:  data Nat :: * -> * where
08:10:17 <mekeor> oh, okay… i didn't know that's optional…
08:10:26 <mm_freak> mekeor: the names are meaningless, because they aren't referred to in the constructors
08:11:09 <mekeor> true. but it's a little confusing like that though, imo. howbeit.
08:11:43 <mm_freak> well, just don't write type arguments after the type name in a GADT =)
08:11:55 <mm_freak> if you want to specify the kind, give a kind signature
08:12:04 <mekeor> *nod*
08:12:48 <mm_freak> alternatively you can write:  data MyType (a :: * -> *) (b :: *) :: *
08:12:58 * nand` always specifies the kind signature, for the same reason he always specifies top-level type signatures
08:13:00 <mm_freak> that's equivalent to:  data MyType :: (* -> *) -> * -> *
08:13:08 <mekeor> oh, yea.
08:13:13 <mcstar> mm_freak: so your previous 'f' function, could return Nat Zero, or Not NonZero, depending on run time value of some thing, i dont see how could another function accept this return type as an argument
08:14:16 <mm_freak> mcstar: imagine (now in haskell) a Nat type that encodes in the type whether it's zero or not
08:14:27 <mm_freak> Z :: Nat Zero, S x :: Nat NonZero
08:14:39 <mm_freak> now you are reading such a number from the user
08:14:47 <mm_freak> at run-time
08:15:15 <mm_freak> the type of the reading action is:  (forall z. Nat z -> IO a) -> IO a
08:15:39 <mm_freak> you pass a function to it that can't handle zero values (e.g. because it divides)
08:15:46 <mm_freak> that's a type error
08:16:19 <mm_freak> you can read it literally:  the type of the argument is:  "forall z. Nat z -> IO a"
08:16:32 <mm_freak> so you must pass a function that can handle /all/ z
08:16:36 <mm_freak> including Zero
08:17:28 <mm_freak> so if your function has a type like Nat NonZero -> IO a, then you can't pass it, because it can't hold to the "for all" promise
08:17:31 <nand`> alternatively; read' :: IO a -> (Nat NonZero -> IO a) -> IO a -- would type check again, presumably the first argument is a “default action” for when it's 0
08:17:55 <mm_freak> nand`: that's an unfortunate way to deal with it
08:18:13 <mm_freak> one way is to either have this in the 'divide' function or have a 'nonZero' checking function
08:18:27 <nand`> what about (forall z. Nat z -> Maybe (IO a))
08:18:44 <mm_freak> nand`: how would that work?
08:18:45 <nand`> alternatively IO (Maybe a)
08:19:29 <nand`> mm_freak: ie.  reading :: (forall z. Nat z -> Maybe (IO a)) -> IO (); where for the case of Nothing a return () is returned
08:19:45 <mm_freak> just have:  nonZero :: b -> (Nat NonZero -> b) -> Nat z -> b
08:19:58 <nand`> or that
08:20:17 <mm_freak> nand`: i don't see how that would work
08:20:39 <mm_freak> or what difference it makes…  i think you're lost on the value level =)
08:20:53 <nand`> reading f = do ....; case f of Nothing -> return (); Just a -> void a
08:21:02 <nand`> case f n*
08:21:14 <mm_freak> f is a function
08:21:22 <mm_freak> not a Maybe
08:21:27 <nand`> f n
08:21:32 <mm_freak> and n is?
08:21:43 <nand`> n is the Nat something that was read from user input or whatever
08:21:55 <mm_freak> so what's the point of that? ;)
08:22:20 <nand`> huh?
08:22:35 <mm_freak> i don't see what you gain from the Maybe there
08:23:05 <mm_freak> it's a function that still promises to handle every Nat…  you just add some weird additional semantics
08:23:07 <nand`> it's a wrapper type for a function that only works on nonzero nats
08:23:19 <mm_freak> how?
08:23:37 <nand`> wrap :: (Nat NonZero -> a) -> Nat z -> Maybe a
08:24:00 <mm_freak> then why have that Maybe in 'reading'?
08:24:57 <nand`> hmm, good question; reading could easily be changed to (forall z. Nat z -> IO a) -> IO a
08:25:01 <mm_freak> seems like an arbitrary restriction with arbitrary semantics
08:25:14 <nand`> used with ‘wrap’ it would simply be :: IO (Maybe a) at the end then
08:25:54 <mm_freak> i wouldn't use Maybe at all
08:26:18 <mm_freak> reading (nonZero (putStrLn "Sorry, can't handle your number") (\x -> …))
08:26:46 <nand`> hmm
08:27:31 <nand`> that works; even if you do end up using Maybe for other purposes it could be used with reading (nonZero Nothing (\x -> Just ...))
08:27:57 <mm_freak> huh?
08:28:21 <mm_freak> either that's a type error or you are introducing a useless Maybe layer again
08:28:57 <mm_freak> a sensible way would be:  reading (maybe (putStrLn "Sorry, can't handle your number") (\nz -> …) . nonZero)
08:29:09 <mm_freak> then:  nonZero :: Nat z -> Maybe (Nat NonZero)
08:29:43 <mm_freak> don't have Maybe in 'reading', because that requires you to encode arbitrary semantics
08:31:20 <mcstar> arbitrary semantics =~ boolean blindness?
08:31:33 <mm_freak> if anything have this instead:  readingNonZero :: (Nat NonZero -> IO a) -> IO a
08:32:12 <mm_freak> mcstar: arbitrary semantics = the user of 'reading' either has no control over what happens on error or decides to never have an error (always returning Just)
08:32:39 <mm_freak> a good example of arbitrary semantics is 'head'
08:32:50 <mm_freak> for an empty list it just results in bottom…  that's arbitrary
08:33:53 <mcstar> mm_freak: as i understand, head is rarely used
08:34:25 <mcstar> so with GADT you can make a safe list?
08:34:33 <mm_freak> yeah…  'head' is a convenience function for the cases where you are sure that the list is nonempty
08:34:37 <mm_freak> yes
08:35:08 <mm_freak> in the simplest case you encode the length
08:35:29 <mm_freak> let me take 'tail' as an example
08:35:38 <mm_freak> tail :: List (S n) a -> List n a
08:36:00 <mm_freak> in a less simple case you encode only whether the list is empty, which requires some more type machinery
08:36:24 <mm_freak> tail :: (forall e. List e a -> b) -> List NonEmpty a -> b
08:37:50 <mm_freak> you have to pass a function that promises that it can handle every 'e', because 'e' could now be Empty or NonEmpty
08:38:11 <HugoDaniel> anyone here has worked with postgresql-simple ?
08:38:20 <HugoDaniel> im trying to add new type
08:43:07 <copumpkin> lpsmith has
08:45:25 <lpsmith> HugoDaniel, it sounds like you want FromField/ToField.  And if you are talking postgresql types,   are you dealing with a built-in or user defined?   If built in,  it has a stable OID and so you can go by OID alone.   If you want to support a user-defined type,  you need to go by the typename instead.
08:48:40 <HugoDaniel> lpsmith: i want it to support the extension ltree
08:52:07 <HugoDaniel> i dont think it has a stable OID
08:53:30 <lpsmith> HugoDaniel, well,  the ltree isn't going to have a stable OID,  and it looks like most of the magic happens in terms of indexing and search operators,  so basic support would be very simple.   As a first draft create something like newtype LTree = LTree ByteString,   instance FromField LTtree where ...  (use the typename for type checking,  and wrap the bytestring...)
08:54:20 <HugoDaniel> oh nice
08:54:23 <HugoDaniel> yes, cool :)
08:54:41 <HugoDaniel> i was already on my way patching the postgresql-simple repo
08:54:52 <lpsmith> yeah, you don't have to do that :)
08:54:55 <HugoDaniel> i changed the tool that generates the BuiltinTypes
08:54:58 <HugoDaniel> ok, nicely :)
08:55:21 <HugoDaniel> yes, FromField and ToField are great typeclasses
08:55:51 <lpsmith> oh, you really don't want to do that,  as your clients wouldn't necessarily work on multiple databases,  or continue working between database dumps,  wipes, and reloads.
08:56:19 <lpsmith> because the OID can change
08:56:30 <HugoDaniel> yes yes true
08:56:32 <HugoDaniel> good point yes
08:57:45 <HugoDaniel> amazing, ok, im going to do this quick and dirty
08:58:17 <HugoDaniel> and then maybe write about it to help if someone else needs to do something similar
08:58:51 <lpsmith> HugoDaniel, that would be awesome,  as I end up answering this sort of question often :)
09:03:48 * hackagebot random-fu 0.2.3.0 - Random number generation  http://hackage.haskell.org/package/random-fu-0.2.3.0 (JamesCook)
09:07:11 <mparodi> is there any difference between, for instance, "foo x = let bar y z = y+z in bar x 5" and "foo x = bar x 5 where bar y z = y+z"?
09:07:42 <mparodi> in other words, where is it a good idea to use "let ... in"?
09:08:24 <adamt> http://www.haskell.org/haskellwiki/Let_vs._Where
09:08:36 <mparodi> oh, someone else already asked that :P
09:08:39 <mparodi> thank you adamt
09:08:49 * adamt is reading it himself as well :)
09:17:19 <Cale> mparodi: Basically, 'let' is an expression form, while 'where' is part of the syntax of declarations and case expressions. The main distinction is that 'where' scopes over multiple guards (and can be used to define things used inside the guards). Apart from that, it's a matter of taste.
09:19:08 <YaZko> Hello
09:19:42 <YaZko> I'm dealing with a stupid problem of imports and don't manage to fix it T_T
09:20:31 <YaZko> It's very simple : I have two files which both import Data.Map, and a third file which import them
09:21:11 <YaZko> And when I compile, I have an ambigous definition
09:21:28 <taylorgb> Either qualify the imports or hide the colliding names
09:21:32 <YaZko> So I would Like to do something like "import file1 hiding (Map.*)"
09:22:03 <YaZko> But how can I hide like a whole "sub-module" ?
09:24:15 <YaZko> Mmh I'm stupid, I did a hiding (Map.*) but a simple hiding (Map) was what I needed...
09:24:28 <YaZko> Thanks btw
09:27:31 <taylorgb> Are abbreviations for qualified modules exported? As that might be the less fishy solution of exporting modules you don't intend to, and then hiding the extras when it is imported.
09:27:44 <taylorgb> If you don't want to explicitly export names
09:29:00 <otters> > "\97"
09:29:01 <lambdabot>   "a"
09:29:08 <otters> oh, character escapes are in decimal?
09:29:11 <otters> how bizarrely intuitive
09:30:15 <taylorgb> Aren't they in most languages unless you use the octal or hex prefixes?
09:30:36 <nand`> > "\x97"
09:30:37 <lambdabot>   "\151"
09:30:42 <nand`> > "\097"
09:30:43 <lambdabot>   "a"
09:30:45 <nand`> ..
09:30:49 <nand`> how would that one even work
09:30:57 <mcstar> > "\0x97"
09:30:58 <lambdabot>   "\NULx97"
09:31:08 <mcstar> weird
09:31:15 <nand`> > "\x97 3"
09:31:16 <mcstar> \x should work
09:31:16 <lambdabot>   "\151 3"
09:31:30 <nand`> > "\x97"++"3" -- any way to simplify this?
09:31:32 <lambdabot>   "\151\&3"
09:31:39 <nand`> there we go
09:31:59 <Cale> > '\o141'
09:32:00 <lambdabot>   'a'
09:32:00 <nand`> > "\&" -- is this just a convenient escape for.. nothing?
09:32:01 <lambdabot>   ""
09:32:10 <nand`> seems like it
09:32:23 <Cale> It's because of \SOH and \SO
09:32:36 <otters> taylorgb: in ruby they're hex by default
09:32:37 <Cale> If you want to have a string with '\SO' followed by 'H'
09:32:38 <otters> no wait
09:32:40 <otters> octal
09:32:40 <Cale> you need a separator
09:32:46 <Cale> > "
09:32:47 <lambdabot>   <no location info>:
09:32:48 <lambdabot>      lexical error in string/character literal at end o...
09:32:48 <Cale> oops
09:32:51 <geekosaur> and because there's no length limit on \NNN so you couldn't follow one withan actual digit without some kind of anti-escape
09:32:52 <otters> which is the least intuitive
09:32:54 <Cale> > length "\SOH"
09:32:55 <lambdabot>   1
09:32:58 <nand`> Cale: yes, or a string with '\o141' followed by '3' as in my case
09:33:04 <Cale> > length "\SO\&H"
09:33:05 <lambdabot>   2
09:33:26 <geekosaur> C introduced octal escapes; various later languages added hex
09:33:28 <Cale> oh, that too, yes :)
09:33:45 <geekosaur> so the octal escapes tend to be defaults for historical reasons
09:33:52 * hackagebot mime 0.3.3.2 - Working with MIME types.  http://hackage.haskell.org/package/mime-0.3.3.2 (IavorDiatchki)
09:33:57 <Cale> The lexical syntax of strings in Haskell is remarkably well-thought-out
09:34:19 <nand`> "{--"--}
09:34:32 <nand`> {- even
09:36:11 <mcstar> oh, \x works, its just that \151 is non printable, silly me
09:38:54 <mauke> Cale: allow me to scoff and laugh at that
09:39:25 <Cale> mauke: What, my comment about strings?
09:39:28 <mauke> yes
09:39:33 <Cale> mauke: What don'
09:39:39 <Cale> What don't you like about it?
09:40:01 <mauke> if Perl had decimal escapes, it would be like 100% superior
09:40:08 <tromp_> or what language do tyou prefer for string syntax?
09:40:31 <tromp_> what language gas decimal escapes?
09:40:34 <mauke> Haskell
09:40:34 <tromp_> has
09:40:57 <mauke> Haskell doesn't allow newlines in strings
09:41:06 <mauke> the delimiter is fixed at "
09:41:17 <Cale> string gaps
09:41:21 <mauke> there's no way to write a "raw" string
09:41:35 <mauke> Cale: gaps remove what's in them
09:41:40 <Cale> correct
09:41:46 <mauke> you'd have to write \n\ ... \
09:41:55 <Cale> you can write \n if you want an actual newline in your string, sure
09:41:59 <mauke> gaps are a kludge
09:42:07 <Cale> I don't think so
09:42:19 <Cale> gaps let you preserve indentation
09:42:21 <mauke> how is \ ... \ better than " ++ " ?
09:42:59 <Cale> whereas if you just allow newlines in the middle of your string, the spacing in the source file gets all messed up by it
09:43:20 <mauke> false dichotomy
09:43:39 <mauke> Haskell allows both spaces and \ \ in strings
09:43:43 <Cale> Well, maybe. I suppose you could do something like allow continuing the string on the same column as it began in
09:43:47 <mauke> it could easily allow newlines and \ <newline> \
09:43:59 <Cale> So you could write
09:44:02 <Cale> x = "foo
09:44:06 <Cale>      bar"
09:44:17 <Cale> and that string wouldn't have any ' ' characters in it
09:44:25 <Cale> (just the newline)
09:44:52 <mauke> here-docs would be good for that
09:45:25 <Cale> Yeah, the only complaint I have about here-docs is the way in which they usually mess with the offside rule.
09:45:31 <nand`> I didn't even know about grap strings; I've always used " ++ "
09:46:25 <Cale> Yeah, tbh, I usually just write unlines [ ... ]
09:46:46 <nand`> does GHC precompute that?
09:47:03 <shachaf> Do you care?
09:47:51 <nand`> shachaf: well, for example I know GHC precomputes ByteString.pack; or at least I've been led to believe it does. It would be interesting to know if GHC precomputes “ByteString.pack $ unlines [ ... ]” as well
09:48:23 <shachaf> Ah.
10:13:37 <agoenkjr> !help
10:13:41 <agoenkjr> !cmd
10:13:53 <mauke> hmm?
10:14:07 <agoenkjr> have bot here bro..?
10:14:21 <mauke> I'm not a bot, I'm a real boy!
10:14:38 <c_wraith> mauke: you're totally an hpaste bot
10:14:49 <mauke> no, a cyborg
10:15:01 <c_wraith> http://pastebin.com/89NRUEVH
10:15:03 <adamt> I'm not sure "bro" is the correct way of addressing people.
10:15:03 <mauke> The paste 89NRUEVH has been copied to http://hpaste.org/69385
10:15:04 <geekosaur> if you don't know how to use a particular bot, perhaps you shouldn't be using it
10:17:43 <mekeor> the haskell-community is great.
10:18:03 <mauke> oh yeah? well, your FACE is great!
10:18:32 <mekeor> what did i do wrong?
10:18:41 <mauke> ... wrong?
10:18:44 <c_wraith> you had a great face, apparently
10:18:47 <c_wraith> Unforgivable
10:20:45 <mekeor> i'm a typeTheoryGeek now!! look:  data Zero; data One = One; data Sum = Foo | Bar; data Product = Product Lorem Ipsum;
10:21:38 <mekeor> actually, sums are like disjunctions. and products are like conjunctions.
10:21:55 <c_wraith> sum is disjunction.  product *is* conjunction
10:22:23 <c_wraith> when you are working in N mod 2, and assume 1 = True, 0 = False
10:22:36 <c_wraith> except sum is actually exclusive or
10:22:40 <c_wraith> eh, whatever
10:22:57 <mekeor> oh, true.
10:23:05 <danr> c_wraith: confusingly, you can also view dependent products as dependent sums ;)
10:23:23 <mekeor> danr: Xplain.
10:23:30 <ClaudiusMaximus> @pl \o x y -> toEnum (fromEnum x `o` fromEnum y)
10:23:30 <lambdabot> ((toEnum .) .) . flip flip fromEnum . ((.) .) . (. fromEnum)
10:23:36 <Cale> Better correspondence is by looking at it in terms of categories.
10:23:39 <ClaudiusMaximus> urg
10:23:41 <mekeor> danr: e.g. with an Xample…
10:24:17 <mekeor> Cale: nonono, don't come with CT. i don't know anything of CT…
10:25:02 <Cale> The key property of the disjunction "A or B" is that A -> (A or B) and B -> (A or B), and whenever A -> Z and B -> Z, we can infer (A or B) -> Z
10:26:53 <Cale> The key property of disjoint union of sets is that there are inclusion maps i_A: A -> (A + B) and i_B: B -> (A + B), and whenever we have functions f: A -> Z and g: B -> Z, there is a unique function [f,g]: A + B -> Z such that [f,g] . i_A = f and [f,g] . i_B = g
10:26:53 <danr> mekeor: non-dependent products (a,b) correspond to the sigma type Σ (_ : a) b, but a sigma type Σ (i : a) (b i) corresponds to b i₀ ∨ b i₁ ∨ ... where i₀, i₁ are the inhabitants of a
10:27:08 <danr> i.e. a disjuction/sum
10:27:27 <Cale> Both of these give examples of a coproduct in some category.
10:27:59 <HugoDaniel> lpsmith: ive skimmed through the code, and have done this: http://hpaste.org/69386
10:27:59 <Cale> and of course when you take the disjoint union of two sets, you end up with a set whose size is the sum of the sizes of the original sets
10:28:09 <HugoDaniel> its simple, but should be enough for now
10:28:12 <Cale> Similarly for the product
10:28:32 <Cale> If you turn all the arrows around there, you get a description of the Cartesian product of sets
10:28:38 <Cale> or the conjunction of statements
10:28:59 <mekeor> Cale: whom are you talking to? to me? i don't understand anything…
10:29:01 <HugoDaniel> is there a simple n-ary tree datatype in haskell ?
10:29:09 <Cale> mekeor: I'm happy to try to explain :)
10:29:16 <mekeor> heh :)
10:30:04 <ClaudiusMaximus> HugoDaniel: Data.Tree is n-ary where n is potentially different at each node, if that's what you mean?
10:30:08 <mekeor> HugoDaniel: there's a general data-type for trees..
10:30:23 <parcs`> danr: b would have to be a function 'a -> Set' there?
10:30:35 <HugoDaniel> cool, thanks :)
10:30:43 <Cale> HugoDaniel: It is far more common when you need a tree datatype to just write your own, because it's so easy.
10:30:55 <danr> parcs`: sounds suitable yes ;)
10:30:56 <Cale> But Data.Tree does exist :)
10:31:04 <parcs`> danr: cool
10:31:28 <danr> parcs`: p
10:31:31 <HugoDaniel> Cale: yes
10:31:36 <HugoDaniel> i should be doing that
10:31:47 <HugoDaniel> i need the merge function
10:31:53 <Cale> (well, because it's not just so easy, but also because there are lots of variations of exactly how you might want to express your tree)
10:32:12 <HugoDaniel> haskell is amazing at trees :D
10:32:22 <mekeor> how do you actuall call tree which only have fruits at the end of their limbs?
10:32:27 <mekeor> *trees
10:32:49 <mekeor> *actually
10:33:24 <mekeor> like:   data Tree a = End a | Limbs [Tree a]
10:33:25 <mekeor> or so.
10:33:41 <Cale> good question, I don't know if that property has a name
10:33:57 * hackagebot sifflet-lib 1.2.5 - Library of modules shared by sifflet and its  tests and its exporters.  http://hackage.haskell.org/package/sifflet-lib-1.2.5 (GregoryWeber)
10:33:59 * hackagebot sifflet 1.2.5 - A simple, visual, functional programming language.  http://hackage.haskell.org/package/sifflet-1.2.5 (GregoryWeber)
10:34:01 <Cale> It makes it much easier to define a valid Monad instance
10:34:18 <HugoDaniel> :)
10:34:23 <mekeor> Cale: Xplain.
10:34:35 <Cale> return x = End x
10:34:42 <mekeor> oh, okay, right.
10:34:43 <Cale> End x >>= f = f x
10:34:49 <mekeor> return = End -- :P
10:35:06 <mekeor> cool, nice.
10:35:37 <Cale> Limbs ts >>= f = Limbs (map (>>= f) ts)
10:35:42 <meiji11> hey folks. I'm curious, if I know a List is a monad, say, and I want to look up the implementation of the Monad typeclass in ghci, how would I go about doing that, supposing it's possible?
10:36:00 <meiji11> I should've said, look up the implementation of the Monad typeclass for List in ghci
10:36:01 <Cale> :info Monad
10:36:05 <Cale> oh
10:36:05 <mekeor> merijn /= meiji11
10:36:22 <meiji11> sorry :P
10:36:23 <Cale> I don't think you can do that
10:36:26 <meiji11> I see.
10:36:43 <Cale> You might be able to get to it awkwardly from the Haddock documentation
10:36:45 <mekeor> @src [] Monad
10:36:45 <lambdabot> Source not found. Maybe if you used more than just two fingers...
10:36:50 <Cale> @src Monad []
10:36:51 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
10:36:53 <Cale> hmm
10:37:02 <mekeor> @src [] Functor
10:37:02 <lambdabot> Source not found. Just what do you think you're doing Dave?
10:37:03 <Cale> @src [] return
10:37:04 <lambdabot> return x    = [x]
10:37:08 <Cale> @src [] (>>=)
10:37:08 <mekeor> ah nice
10:37:09 <lambdabot> xs >>= f     = concatMap f xs
10:37:22 <Cale> Just have to remember our own conventions :D
10:37:34 <mekeor> meiji11: you can't do it within GHCI. you have to join #haskell and ask lambdabot ;)
10:37:43 <meiji11> haha, ok.
10:38:06 <mekeor> (private-messages work, too.)
10:38:18 <meiji11> that's part of what makes learning haskell seem really daunting.. having to memorize all kinds of specific instances of behavior, never mind grokking what a monad is/does..
10:38:19 <Cale> Those are just taken from a text file
10:38:31 <meiji11> speaking personally, of course.
10:38:52 <Cale> and the text file has an odd (non Haskell) convention for implementations of methods of typeclasses
10:39:24 <Cale> Basically, the text file is split into paragraphs whose first line is a name for looking up the rest of the paragraph :P
10:39:50 <Cale> meiji11: It's just a pattern which shows up in a lot of libraries
10:40:28 <Cale> meiji11: so we give it a name, so that various things which can be written in terms of that "shape" can be obtained automatically once you recognise that something is a monad.
10:40:46 <Cale> (You'll find a bunch of stuff in Control.Monad, for one)
10:40:47 <mroman> meiji11: http://hackage.haskell.org/packages/archive/base/3.0.3.2/doc/html/src/GHC-Base.html#line-292
10:41:17 <Cale> For example, using the fact that list is a monad, we get sequence :: [[a]] -> [[a]] for free
10:41:24 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
10:41:25 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
10:41:43 <Cale> In a parsing monad, sequence :: [Parser a] -> Parser [a]
10:41:59 <Cale> and it would form the concatenation of the list of parsers, giving a parser which results in a list
10:42:20 <Cale> In the IO monad, we have  sequence :: [IO a] -> IO [a]
10:42:32 <jfischoff> meiji11: I can't speak for everyone here, but was I was using monads in a productive way, before I really understood them. I wouldn't worry about it.
10:42:38 <Cale> taking a list of IO actions, and producing an IO action which executes them all, giving a list of the results
10:43:23 <jfischoff> meiji11: although I would listen to Cale
10:43:32 <Cale> sequence itself can be written in terms of return and (>>=), and the implementations of those things for these various libraries will determine what it does in each case
10:44:08 <Cale> So in the end, it's like any other abstraction in programming -- we notice a pattern and factor it out so that we don't have to write the same programs over and over with small changes.
10:45:25 <meiji11> right. it's anticipating what it does when invoked with different types that worries me.
10:46:40 <c_wraith> meiji11: fortunately, the laws that proper implementations of return and (>>=) follow greatly restrict the behavior of functions built from them.
10:46:56 <dmwit> If your complaint is that you need to memorize what each function does at each type, well, you'd have the same problem if the API used different names for each type.
10:47:18 <Cale> meiji11: Well, in order to do that, you basically just need to look at a handful of examples to kind of get a feel for it, and understand how either do-notation or (>>=) works in your specific library.
10:47:18 <c_wraith> meiji11: You build an intuition for what they do, just based on type signatures, pretty quickly.
10:47:49 <meiji11> c_wraith: I would imagine that'd be so, just by looking at the identities monads must satisfy.
10:48:04 <meiji11> I'm wondering how those identities are enforced in code, if at all, but that's probably jumping the gun.
10:48:13 <Cale> For example, in the list monad, xs >>= f = concat (map f xs), and you can think of this as picking an element from xs in all possible ways, applying f to it to get a list of results, and concatenating those results together
10:48:31 <Cale> So in essence, (>>=) in the list monad is all about making selections in all possible ways
10:48:39 <S11001001> @pl \f -> flip foldr (pure []) (liftA2 (:) . f)
10:48:39 <lambdabot> flip foldr (pure []) . (liftA2 (:) .)
10:48:39 <c_wraith> meiji11: the only enforcement is social. People call it a bug if you implement a class without following the rules for it.
10:48:56 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
10:48:57 <lambdabot>   [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2...
10:49:08 <Cale> here, we 'pick' x from [1,2,3] in all possible ways
10:49:15 <Cale> and then y from [4,5] in all possible ways
10:49:18 <Cale> and so on
10:49:31 <tac-tics> > do x <- [1,2,3]; y <- [1,2,3]; guard (x == y); return (x, y)
10:49:32 <lambdabot>   [(1,1),(2,2),(3,3)]
10:49:35 <Cale> and so 'running' a list in the list monad means picking an element from it in all possible ways
10:50:23 <Cale> What sequence does in general is to run all the things you give it, and give you a computation which produces a list of the results (when run)
10:50:49 <teneen> is there a condition which allows to check a monadic condition within guards? MonadicGuards maybe?
10:51:03 <Cale> So sequence in the case of lists will run each of the lists you give it, and give (a list of) the list of choices made
10:51:22 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
10:51:23 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
10:51:27 <c_wraith> teneen: no..  That would have bizarre consequences in terms of effects
10:51:29 <Cale> is the same as
10:51:33 <tac-tics> I always think of the List monad as the "query" monad, since it looks very much like a SQL query.
10:51:46 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return [x,y,z]
10:51:47 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
10:51:49 <meiji11> in general, then.. monads give you a way of doing stateful, non-deterministic computations?
10:51:55 <teneen> c_wraith: Why it would just return (), what's the problem?
10:52:00 <meiji11> I was going to follow that with 'over a set of elements' but that's probably not abstract enough..
10:52:00 <Cale> meiji11: In particular they do
10:52:32 <Cale> meiji11: There are monads for stateful computations, and monads for nondeterminism, and monads for first class continuations, ...
10:52:33 <Cale> and so on
10:52:35 <c_wraith> teneen: foo | actionThatHasIrreversibleEffects bar -> ...
10:53:28 <Cale> meiji11: There are a lot of various cases where this pattern makes sense for a "class of computations" of some kind, and Monad captures that pattern of
10:53:44 <tac-tics> > do person <- [(1, "Mike"), (2, "Tim"), (3, "Jen")]; iceCream <- [(1, "Chocolate"), (2, "Vanilla")]; favorites <- [(1, 1), (2, 1), (3, 2)]; guard (fst favorites == fst person); guard (snd favorites == fst iceCream); return (snd person, snd iceCream);
10:53:45 <lambdabot>   [("Mike","Chocolate"),("Tim","Chocolate"),("Jen","Vanilla")]
10:53:45 <teneen> c_wraith: But I'm anyways doing these side-effects to get the boolean and then make a choice with an if-statement
10:53:46 <Cale> 1) being able to have a computation which "does nothing" and produces a result (which is return)
10:54:05 <c_wraith> teneen: oh, you mean the guard function.  The condition on that is in the type signature.
10:54:08 <c_wraith> :t guard
10:54:09 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
10:54:13 <Cale> 2) being able to perform some computation, and apply a function to its result in order to be able to determine what computation to do next (which is (>>=))
10:54:49 <Cale> What "computation" and "next" actually mean depends on the specific monad
10:55:13 <Cale> in fact, this is more a definition of "computation" and "next" than it is a useful description of what monads are, but it still might help with intuition a little
10:55:17 <Siod> @spell tset
10:55:30 <teneen> c_wraith: No, what I'm trying to do is what you understood first. Actually something like "foo x y = get >>= \env -> if member x env then ...."
10:55:52 <geekosaur> view patterns?
10:56:00 <Siod> @fortune
10:56:00 <lambdabot> Couldn't find fortune file
10:56:02 <c_wraith> view patterns won't execution actuions
10:56:04 <c_wraith> err, actions
10:56:06 <Siod> @b52s
10:56:06 <lambdabot> Watch out for that piranha. There goes a narwhale. HERE COMES A BIKINI WHALE!
10:57:10 <teneen> c_wraith: Wouldn't it be simpler if something like guards allowed what I'm trying to do?
10:57:30 <c_wraith> teneen: the problem preventing that is mostly structural.  At the moment, any effects that are bound happen explicitly, via functions or do notation.  Adding in an implicit way to bind effects would make it easier to hide them.
10:58:09 <Cale> meiji11: So, in the case of a parsing monad, we have some type constructor Parser (which is our monad itself), together with the operations  return :: a -> Parser a  which will give us a parser which doesn't consume any of the input, but succeeds and produces the given value as its result
10:58:11 <teneen> c_wraith: I see, this makes sense.
10:59:01 <Cale> meiji11: and we have a function (>>=) :: Parser a -> (a -> Parser b) -> Parser b, which takes a parser for parsing the initial part of the input, and a function from results of that first parser to parsers for parsing the rest of the input
10:59:22 <Cale> and joins them together in the natural way, giving the result of the second parser, whatever it turns out to be
10:59:30 <Siod> how does lambdabot's module system work?
10:59:51 <Siod> s/module/plugin
11:00:10 <Cale> Depending on the exact implementation of parsers, this might involve nondeterminism, and it might allow for additional state beyond the input string
11:00:34 <c_wraith> it's not very flexible.  You just write code to work with its interface, then in the lambdabot source, import your code and add it to the list of plugins to load.
11:00:53 <Siod> c_wraith: could it be more flexible?
11:01:24 <Siod> and how?
11:01:26 <c_wraith> Siod: potentially, but it's a big design problem.  Everyone agrees lambdabot isn't designed very well, internally.  No one really wants to spend the time redoing it.
11:02:45 <Siod> is there something like lambdabot that's more well designed--so i can learn from
11:02:47 <nand`> > sequence ["fmt", "ao", "pt"]
11:02:48 <lambdabot>   ["fap","fat","fop","fot","map","mat","mop","mot","tap","tat","top","tot"]
11:02:51 <nand`> pop quiz: how many of those are English words?
11:03:22 <Cale> answer: as many of them as you can think of a meaning for
11:03:57 <lpsmith> HugoDaniel:  this is closer to what I would have done:  http://hpaste.org/69386  but other than that, looks good
11:06:55 <meiji11> Cale: I see. still seems like a lot to take in..
11:07:14 <meiji11> I'll keep playing with it, and a pattern will emerge. Yes.
11:07:32 <Cale> meiji11: Yeah, basically the key is just to look at a bunch of examples.
11:08:26 <Cale> meiji11: http://www.haskell.org/haskellwiki/Monads_as_computation explains a bit more of the computational perspective, and explains the laws in those terms
11:08:29 <syntaxfree> ok, how excited should I be about hmatrix?
11:08:45 <jfischoff> syntaxfree: it works
11:09:02 <syntaxfree> my partners are getting a bit fed up with Octave, which we use on the server because I'm so used to prototype in Matlab.
11:09:23 <syntaxfree> but I refuse to use Python. Between NumericalPython, NumPy and SciPy, that shit's a mess.
11:09:37 <syntaxfree> I was seriously looking into Incanter.
11:10:06 <syntaxfree> but thought I'd dip in and write a fast k-neighbour search to replace the slow one in the big Matlab/Octave program, and found out about hmatrix.
11:10:39 <jfischoff> syntaxfree: I can't speak to the performance
11:10:41 <syntaxfree> should I let out the fireworks? Is it clunky for someone coming from Matlab (that knows basic Haskell)?
11:11:24 <syntaxfree> jfischoff: yeah, I was going to write my knnsearch with lists. It has to beat Octave, if only because knnsearch is naturally lazy.
11:12:04 <ymasory> hi. is there a monad or abstraction to make a time-dependent method like Java's File.deleteOnExit referentailly transparent?
11:12:38 <fmap> what this method does?
11:13:05 <ymasory> fmap: deletes a file on exit of the JVM, or in this case on exit of the haskell program
11:13:43 <ymasory> lets just pretend for a second there was a shutdown hook available in ghc
11:13:50 <ymasory> i'm wondering about the semantics of using such a hook
11:13:57 <nand`> just a thought - maybe you could so something with a Writer and a special main that executes the writer's output afterwards
11:14:08 <nand`> if your only intent is to delay something to the end of execution
11:14:40 <jfischoff> maybe bracket would work
11:14:46 <meiji11> Cale: thanks, reading it now.
11:14:50 <ymasory> interesting, i'll have to look those up
11:15:08 <syntaxfree> is there a freenode channel for machine learning-ey stuff?
11:17:13 <armlesshobo> syntaxfree: #machinelearning
11:17:20 <armlesshobo> syntaxfree: #ml-class if you're taking the class
11:17:29 <syntaxfree> there's a class?
11:17:33 <armlesshobo> yes
11:17:35 <ClaudiusMaximus> syntaxfree: i have had bus errors / aborts  with hmatrix in ghci at some point - possibly they are fixed now
11:17:42 <armlesshobo> taught by Andrew Ng I believe
11:18:04 <ClaudiusMaximus> syntaxfree: other than that, i've had good experiences (implemented interpolation between affine transformations with it)
11:18:59 <ClaudiusMaximus> syntaxfree: what's your dimension?  i knocked up this for nearest neighbour in 2D today: http://hpaste.org/69381
11:28:22 <mekeor> so, lenses make it easier to handle records in records, right? okay… cool…
11:28:41 <parcs`> they make records easier in general
11:28:57 <parcs`> modifying, accessing, setting, etc
11:29:01 <mekeor> great stuff.
11:31:29 <jfischoff> speaking of lenses has anyone tried out yall? http://hackage.haskell.org/package/yall
11:33:24 <jfischoff> additionally has anyone thought about a type class for lenses? Its seems like that might make sense. We do have laws….
11:38:13 <mcstar> im doing week 11 ml stuff
11:38:59 <mcstar> armlesshobo: #ml-class is for udacity right? i dont know about coursera's having a channel
11:39:48 <mcstar> (uh, thats not week11, but lecture set 11)
11:42:33 <mcstar> syntaxfree is gone, nice
11:42:41 <mekeor> nice?
11:42:52 <mcstar> i just wanted to recommend Julia for him
11:43:01 <mekeor> ah. that prog-lang?
11:43:20 <mcstar> much like matlab and numpy but better
11:43:24 <mekeor> yup
11:43:31 <mcstar> (in a certain sense)
11:44:03 * hackagebot shelly 0.9.4.2 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.9.4.2 (GregWeber)
11:44:05 <armlesshobo> mcstar: I don't know. I simply did a google search for "machine learning freenode" and listed the two channels that popped up :)
11:44:17 <armlesshobo> mcstar: I wasn't that invested in the issue lol
11:44:44 <mcstar> armlesshobo: i didnt go as far as seeking a channel out, or discussion group, cause the addignments are pieace of cake
11:44:48 <mcstar> ss*
11:46:21 <armlesshobo> mcstar: lol. i plan on taking the discrete math course on udacity to refresh my memory
11:46:30 <mcstar> i was wondering how convenient some matrix algebra bindings are in haskell
11:47:19 <mcstar> armlesshobo: i wanted to do logic, but i simple have no time
11:47:39 <mcstar> i had to drop algo class, at previous offering
11:47:39 <armlesshobo> mcstar: that's what I'm worried about with this course
11:47:50 <mekeor> mcstar: does julia support endless big Integers like haskells Integer?
11:48:16 <mcstar> this far, i did crypto(final exams are hanging over my head), and am doing ml now
11:48:28 <mcstar> mekeor: im almost sure
11:48:36 <mekeor> almost…
11:48:42 <mekeor> that's not enough.
11:50:09 <armlesshobo> mcstar: i was taking the compilers with Alex Aiken, but wound up lagging behind
11:54:00 <mcstar> mekeor: perusing the manual it seems it doesnt support big ints yet
11:54:26 <mekeor> mcstar: asking in #julia, it does.
11:54:35 <mekeor> :P
11:54:38 <mcstar> oh
11:54:45 <mcstar> maybe the manual is lagging behind
11:55:01 <mcstar> i didnt find it in its numeric hierarchy
11:55:26 <mekeor> "<loladiro> yes, [julia does support infinite big integers,] though you have to make it explicit by loading extras/bingint.jl and then using e.g. BigInt(500000)"
11:55:45 <mcstar> mekeor: i didnt know about extras
11:56:02 <mcstar> and it doesnt support a module system so far afaik
11:56:37 <mekeor> idk. i just heard of julia once and liked it. since then, i auto-join the channel… =)
12:32:23 <danderson> Hi.
12:32:35 <Taneb> Hello
12:32:44 <danderson> I'm currently the maintainer of a package on hackage, and I no longer have time to take care of it. I have a volunteer to take over.
12:32:54 <danderson> How do I transfer upload rights to him on hackage?
12:33:02 <Clint> you tell him to upload
12:33:27 <danderson> Oh. I seemed to recall some procedure that involved emailing someone to twiddle an ACL. I guess I was wrong :-).
12:33:34 <Clint> there isn't one to twiddle
12:33:47 <Taneb> Hackage is simpler than it looks
12:34:24 <geekosaur> danderson, that might be code.haskell.org repos?
12:35:11 <geekosaur> in which case an easy solution is for the new maintainer to upload their version to patch-tag or github
12:42:13 <navaati> mm_freak: hi. where's netwire git/darcs ? i'd like to take a look at what will be the next version
12:43:03 <mekeor> @package netwire
12:43:03 <lambdabot> http://hackage.haskell.org/package/netwire
12:45:40 <navaati> well yeah but i don't see any git/darcs indication in the cabal file
12:53:43 <mekeor> yep. idk where it is.
12:55:11 <lpsmith> is there a fast, accurate "  floor . logBase 10 . fromIntegral " function available on hackage?
13:01:59 <lpsmith> > logBase 10 (fromIntegral (10^3))
13:02:00 <lambdabot>   2.9999999999999996
13:03:53 <lpsmith> > floor (logBase 10 (fromIntegral (10^3)))
13:03:58 <lambdabot>   2
13:05:19 <fmap> > floor . logBase 10 $ (1000 :: CReal)
13:05:21 <lambdabot>   3
13:06:04 <fmap> have no idea how fast it is
13:06:13 <navaati> :t logBase 10 $ (1000 :: CReal)
13:06:15 <lambdabot> CReal
13:06:19 <navaati> logBase 10 $ (1000 :: CReal)
13:06:24 <navaati> > logBase 10 $ (1000 :: CReal)
13:06:25 <lambdabot>   3.0
13:06:43 <navaati> > pi :: CReal
13:06:43 <lambdabot>   3.1415926535897932384626433832795028841972
13:07:14 <jaca> 5+7
13:07:17 <jaca> ?
13:07:19 <jaca> :|
13:07:21 <jaca> =|
13:07:23 <Taneb> 12, jaca
13:07:30 <jaca> =<-------------<|
13:07:47 <navaati> hahaha, you need to prefix with "> "
13:07:50 <jaca> JacaBoy
13:07:58 <jaca> =P
13:07:59 <mcstar> CReal?
13:08:03 <mcstar> cereal?
13:08:11 <mcstar> CRealKiller
13:08:13 <mauke> computable reals
13:08:16 <mcstar> ah
13:08:17 <uniquenick> what's the correct way to convert a bytestring into a string in an encoding-aware way?
13:08:20 <navaati> yeah, i was wondering too if there was a pun intended
13:08:32 <navaati> :t encode
13:08:33 <lambdabot> Not in scope: `encode'
13:08:42 <navaati> @hoogle encode
13:08:42 <lambdabot> Prelude encodeFloat :: RealFloat a => Integer -> Int -> a
13:08:42 <lambdabot> package Encode
13:08:42 <lambdabot> GHC.IO.Encoding.Types encode :: BufferCodec from to state -> Buffer from -> Buffer to -> IO (Buffer from, Buffer to)
13:08:59 <jaca> ...
13:09:01 <jaca> =/
13:09:13 * hackagebot BoundedChan 1.0.1.0 - Implementation of bounded channels.  http://hackage.haskell.org/package/BoundedChan-1.0.1.0 (AdamWick)
13:09:23 <navaati> ah no, it is decode that you want…
13:09:50 <mcstar> mauke: noob here, what are they?
13:10:08 <uniquenick> am I supposed to go bytestring -> Text -> String?
13:10:28 <mauke> mcstar: numbers you can compute :-)
13:11:13 <mcstar> mauke: like they are represented with rationals, until you evaluate the whole computation?
13:11:54 <mauke> I think they're represented with computations
13:12:14 <jaca> Who know Monad? =P
13:12:15 <mauke> > showCReal
13:12:16 <lambdabot>   Overlapping instances for GHC.Show.Show
13:12:17 <lambdabot>                              (GHC.T...
13:12:21 <mauke> > showCReal 2 pi
13:12:22 <lambdabot>   "3.14"
13:12:25 <mauke> > showCReal 200 pi
13:12:26 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
13:12:30 <jaca> =|
13:12:36 <mauke> I know Monad
13:13:00 <lpsmith> CReal isn't necessarily exact,  but it might be exact enough for the range I care about
13:14:04 <jaca> I don't know how use 'fail'... can you help me? =P
13:14:12 <navaati> don't use fail
13:14:14 <navaati> it's evil
13:14:15 <tac-tics> @type fail
13:14:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
13:14:18 <ClaudiusMaximus> lpsmith: http://www.haskell.org/ghc/docs/7.4.1/html/libraries/integer-gmp-0.4.0.0/GHC-Integer-Logarithms.html
13:14:18 <navaati> it's shit
13:14:20 <navaati> forget about it
13:14:22 <jaca> I don't know how to use 'fail'... can you help me? =P
13:14:30 <jaca> =/
13:14:33 <jaca> whay?
13:14:34 <tac-tics> > fail "Hello" :: [Int]
13:14:35 <lambdabot>   []
13:14:37 <jaca> **why?
13:14:56 <lpsmith> > map (logBase 10 . fromIntegral ) [ 10 ^ i  |  i <- [1..20] ] :: [CReal]
13:14:58 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17....
13:15:06 <lpsmith> yeah, probably exact enough :)
13:15:14 <navaati> well, it has nothing to do about monads, it's just an old hack that we are stuck with. better ignore it
13:15:33 <lpsmith> ClaudiusMaximus, thanks
13:15:36 <tac-tics> what was the original intention of fail again?
13:15:52 <navaati> pattern matching in do notation…
13:15:55 <tac-tics> What design issue did it do a crummy job solving?
13:15:56 <tac-tics> ah yes
13:15:57 <ClaudiusMaximus> lpsmith: note that it doesn't exist in previous versions of integer-gmp
13:16:02 <mcstar> integer logarith and 'exact real logarith' are totally different
13:16:07 <mcstar> mm
13:16:22 <jaca> ok...
13:16:29 <tac-tics> > do Just x <- Nothing : map Just [0..]; return x
13:16:30 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
13:17:01 <tac-tics> yeah.... someone mentioned pattern-matched list comprehension the other day, and I was like "don't use that", thinking it relied on fail, and I was vetoed in the discussion
13:17:12 <tac-tics> but seriously, don't use partial pattern matching :P
13:20:17 <applicative> uniquenick: yes, that's the straightforward way, i.e. T.unpack . T.decodeUtf8  or whatever is appropriate from http://hackage.haskell.org/packages/archive/text/0.11.2.1/doc/html/Data-Text-Encoding.html if anything is
13:22:46 <navaati> damn, there is no way to decode/encode non-unicode charset in haskell oO
13:23:52 <Clint> that doesn't seem true
13:23:58 <applicative> navaati: what about eg http://hackage.haskell.org/packages/archive/text-icu/0.6.3.4/doc/html/Data-Text-ICU-Convert.html or is that icky or am i not understanding
13:25:20 * applicative considers http://hackage.haskell.org/package/iconv icky because of his irrational hatred of libiconv
13:25:36 <navaati> ah, yeah, there is this… fcking heavyweight tho : the interface is rather unconvenient
13:26:27 <navaati> ah, yeah, this too… well, my hackage searching skills seem very bad
13:27:05 <applicative> check out that easy type safe illustration at the top http://hackage.haskell.org/packages/archive/iconv/0.4.1.0/doc/html/Codec-Text-IConv.html
13:29:10 <chrisdone> evening
13:29:53 <applicative> evening?
13:29:57 <chrisdone> any emacs users who aren't using the new inferior haskell mode?
13:30:09 <mekeor> me
13:30:12 <applicative> > filter even [2..22]
13:30:13 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22]
13:30:28 <mekeor> chrisdone: me. how can i help you, sir?
13:30:29 <chrisdone> mekeor: why not? :-)
13:30:34 <luite> applicative: evening!
13:30:45 <timthelion> Do I understand correctly, that with data Foo a = Foo (a,a), I cannot make a list of [Foo a] which contains both Foo Int s and Foo String s?
13:30:49 <applicative> luite exactly
13:31:10 <tommd> No instance 'Applicative Evening'.
13:31:10 <mcstar> @time
13:31:12 <lambdabot> Local time for mcstar is Fri Jun  1 23:20:45 2012
13:31:17 <chrisdone> timthelion: that's right
13:31:30 <mekeor> chrisdone: i just use haskellMode. is this the same as inferiorHaskellMode?
13:31:34 <mekeor> @time chrisdone
13:31:39 <mcstar> argh, my pc clock is way off
13:31:41 <timthelion> Is the only way arround this to make a superType data Bar = FooInt (Foo Int) | FooString (Foo String) and then [Bar]?
13:31:45 <applicative> navaati: yeah, i'm not finding anything easier than those c-bindings
13:31:48 <mcstar> it drifts enormously
13:31:49 <geekosaur> mekeor, inferior Haskell mode means there's a ghci running inside emacs
13:31:59 <mekeor> oh, oh, oh. oops.
13:32:11 <mekeor> chrisdone: i'm running inferior Haskell-mode then.
13:32:12 <chrisdone> timthelion: that's one approach, another is to use existentials which are like data Bar = forall a. Bar a
13:32:17 * mekeor is sorry.
13:32:34 <timthelion> chrisdone: how does that work?
13:32:37 <chrisdone> mekeor: i mean your REPL is inferior-haskell-mode?
13:32:40 <mekeor> does lambdabot have a lag?
13:32:55 <mekeor> chrisdone: *nod*
13:33:03 <geekosaur> often, yes
13:33:11 <mcstar> chrisdone: is there a better haskell repl mode? in the one im not using, there is no completion, and that sucks
13:33:14 <mekeor> the bottom-bar shows "Inf-Haskell"
13:33:27 <navaati> chrisdone: ah, hi, i have bug reports for you \o/
13:33:30 <mekeor> mcstar: chrisdone is hacking on a new REPL-mode.
13:33:38 <mcstar> great
13:33:43 <mekeor> mcstar: see the haskellMode-ML for more info.
13:34:15 <timthelion> chrisdone: actually, thinking about it, my thought process doesn't even make sense in Haskell...  So used to Python's interesting type system...
13:34:22 <chrisdone> timthelion: usually you have some class constraint on it which allows you to convert the polymorphic value back to a monomorphic one. Typeable is an example: http://chrisdone.com/posts/2011-12-05-generic-map.html
13:34:39 <timthelion> chrisdone: thanks
13:34:40 <mekeor> mcstar: https://github.com/haskell/haskell-mode#setup-for-new-interactive-mode
13:34:52 <chrisdone> navaati: \o/!
13:35:17 <chrisdone> navaati: pop them in the github issues per favore
13:35:31 <navaati> ah, ok
13:35:52 <chrisdone> explain here if you like, but i'll forget if you don't put them in an issue
13:36:24 <mcstar> haskell-mode killed my firefox http://imgur.com/0v7Cx
13:36:38 <chrisdone> zalgo, he comes
13:37:12 <chrisdone> mcstar: git clone git@github.com:haskell/haskell-mode.git -- checkout examples/init.el
13:37:29 <chrisdone> (or README.md)
13:37:39 <mekeor> see my link
13:37:46 <chrisdone> mekeor: any reason for now trying the new one?
13:37:56 <mekeor> *not
13:38:04 <mekeor> chrisdone: i'm a haskeller, you know.
13:38:06 <mekeor> lazy
13:38:08 <mekeor> ;)
13:38:14 <mekeor> heheheh
13:38:18 * chrisdone forces mekeor's thunk
13:38:24 <mekeor> :D
13:38:27 <mekeor> !mekeor
13:38:29 <chrisdone> if you know what i mean
13:38:50 * chrisdone never realised the innuendo potential ;)
13:38:58 <chrisdone> @vixen can i force your thunks?
13:38:59 <lambdabot> The press is the enemy.
13:39:14 <mekeor> chrisdone: ok, i'll try it out. i think, i tried it out once though...
13:39:20 <uniquenick> if I have a function that takes a Bytestring, but I actually have a Maybe Bytestring, I want to use fmap right?
13:39:50 <chrisdone> mekeor: perhaps last time it was a whole different package… now it's normal haskell-mode with extra stuff/replacement for inferior-haskell mode
13:40:00 <applicative> uniquenick: you can
13:40:20 <applicative> then you get Maybe whatever-the-function-returns
13:40:31 <mekeor> chrisdone: which distro do you use actually?
13:40:37 <applicative> uniquenick: or you can divide cases
13:40:43 <uniquenick> right.  I figured this was reasonable: id <- (T.unpack . T.decodeUtf8) `fmap` getParam "id"
13:40:46 <chrisdone> > reverse "utnubu"
13:40:47 <lambdabot>   "ubuntu"
13:40:54 <mekeor> ah, i see.
13:40:58 <copumpkin> ryant5000: you're alive!!!!!!
13:40:59 * copumpkin faints
13:41:07 <chrisdone> uniquenick: needs more fmaps
13:41:23 <uniquenick> where does it need them?
13:41:24 <chrisdone> fmap for the Snap monad, fmap for the Maybe
13:41:38 <chrisdone> fmap (fmap (T.unpack . T.decodeUtf8)) (getParam "id")
13:41:40 <applicative> @type getParam --hopeless
13:41:41 <lambdabot> Not in scope: `getParam'
13:41:57 <chrisdone> it's basically MonadSnap m => ByteString -> m (Maybe ByteString) or w/e
13:42:05 <chrisdone> <_<
13:42:43 <lpsmith> ClaudiusMaximus, speaking of matrix-y stuff, I think it might be worth considering trying to do some of that in Haskell itself instead of calling out to C or Fortran.   Especially if you could come up with a good matrix-deforestation algorithms.
13:42:49 <chrisdone> uniquenick: i tend to define a function for getting strings… the unpacking can get tedious
13:43:34 <chrisdone> like getString :: MonadSnap m = ByteString -> String -> m String
13:43:44 <chrisdone> mekeor: does it work then?
13:43:59 <mcstar> mekeor: i saw your link, the imgur screenshot is firefox trying to display readme.md
13:44:58 <mekeor> chrisdone: does the new REPL require a cabal-file?
13:45:08 <mekeor> i just want to load a usual .hs-file.
13:45:16 <applicative> mcstar: does firefox purport to render markdown?
13:45:32 <chrisdone> mekeor: only if you have  '(haskell-process-type 'cabal-dev). if you change it to 'ghci it doesn't
13:45:36 <mekeor> when i press <f5> it talks of projects… i dont want projects. i want to just load the file…
13:45:45 <mekeor> chrisdone: ah.
13:46:04 <mcstar> applicative: it must be some error in my graphics subsystem
13:46:19 <mcstar> or not
13:46:20 <chrisdone> mekeor: oh, it always does that. it's not a big deal, just hitting ret a couple times for the cabal dir/load dir
13:47:23 <mekeor> chrisdone: ok.
13:47:32 <mekeor> chris, done.
13:47:36 <mekeor> hehe.
13:47:39 <mekeor> it works.
13:48:09 <mekeor> are there any really big differenes to the old REPL?
13:48:20 <mekeor> i mean, differences which i will notice very fast?
13:49:17 * hackagebot secure-sockets 1.2.5 - Secure point-to-point connectivity library  http://hackage.haskell.org/package/secure-sockets-1.2.5 (IavorDiatchki)
13:50:41 <applicative> uniquenick: as long as you have OverloadedStrings on why not ViewPatterns put into my head by perverse examples yesterday
13:50:57 <applicative> do {(fmap (T.unpack . T.decodeUtf8) -> id' ) <- getParam "id"; return id'}
13:51:21 <uniquenick> mainly because I have no idea what ViewPatterns is
13:51:37 <mekeor> an extension
13:51:45 <mekeor> @wiki ViewPatterns
13:51:45 <lambdabot> http://www.haskell.org/haskellwiki/ViewPatterns
13:51:46 * applicative had forgotten about it
13:52:02 <mekeor> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
13:52:12 <chrisdone> mekeor: ermm, error messages/warnings are collapsed
13:53:33 <applicative> > > foldr1 ($$) [text x | (show -> x) <- [1,2,3]
13:53:34 <lambdabot>   <no location info>: parse error on input `>'
13:53:37 <applicative> > > foldr1 ($$) [text x | (show -> x) <- [1,2,3]]
13:53:38 <lambdabot>   <no location info>: parse error on input `>'
13:53:49 <mekeor> chrisdone: actually, i only tried the mode now. i mean, with "--load example/init.el". how do i really *install* it? -- i'm sorry for asking nooby emacs-questions.
13:53:52 <applicative> cutting and pasting is too hard
13:54:00 <applicative> >  foldr1 ($$) [text x | (show -> x) <- [1,2,3]]
13:54:01 <lambdabot>   1
13:54:02 <lambdabot>  2
13:54:02 <lambdabot>  3
13:54:20 <chrisdone> mekeor: it's kind of focused on making developing actual projects easier, esp. with cabal integration and it has definition jumping via etags (that's what hasktags is for)
13:54:39 <mekeor> nice.
13:55:00 <chrisdone> mekeor: well you can just pop that init.el file in your .emacs if you don't have preferences for organizing your elisp config
13:55:10 <applicative> ahh, uniquenick see the (show -> x) bit applies show before returning so to say.  JoeyA was actually praising it for certain purposes.
13:55:56 <mekeor> chrisdone: oh, right. i could also do (load "~/e/haskell-mode/examples/init.el") right?
13:55:59 <applicative> > let foo (show -> x) = toUpper x in foo 1
13:56:00 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
13:56:00 <lambdabot>         against inferred type...
13:56:02 <chrisdone> mekeor: sure
13:56:04 <applicative> grrrr
13:56:19 <applicative> > let foo (show -> x) = map toUpper x in foo 1
13:56:20 <lambdabot>   "1"
13:56:37 <applicative> > let foo (show -> x) = map toUpper x in foo (Just 2)
13:56:38 <lambdabot>   "JUST 2"
13:56:43 <uniquenick> I'm still confused enough with the basics, I think I'll skip viewpatterns for now
13:57:05 <Raydiation> pretty clever idea to provide the book online :) ive already bought real world haskell and learn you a haskell only from reading a bit into it
13:57:42 <chrisdone> uniquenick: yeah ViewPatterns are leavable. they're completely trivial to understand and are just syntactic sugar, so once you are comfortable with Haskell basics you can look again and it'll be like "oh, nice"
13:57:42 <applicative> uniquenick: youre six monads deep in snap!
13:58:13 <chrisdone> deep monading
13:58:24 <uniquenick> I'm somewhere in some monads, just kinda lost in there though
13:58:29 <darkniobe> I know there's an innuendo in that somewhere..
13:58:41 <applicative> uniquenick: yes, something about your example and the extra lifting needed put me in mind of it. pay no attention!
13:59:01 <tac-tics> Are viewpatterns just McBride's concept of a view ported to Haskell?
13:59:18 <uniquenick> so now lets say I have a Maybe Foo, and a function that takes a Foo and returns a Maybe Foo, now I want something applicative?
13:59:29 <uniquenick> instead of fmap I mean
13:59:46 <applicative> somehow the bytestring-madness of snap is tougher for me than "MonadSnap m => ..."
14:00:24 <applicative> uniquenick: you have a Maybe (Foo -> Bar) for example?
14:00:54 <Cale> uniquenick: that sounds like you want (>>=) specifically
14:00:57 <uniquenick> lets take what I already did and try to parse an int from it now using readMay
14:01:00 <applicative> uniquenick: what you described is the monadic bind case
14:01:17 <applicative> uniquenick: like Cale said!
14:01:37 <chrisdone> i think uniquenick is implementing some functions i wrote again
14:02:02 <hpaste> chrisdone pasted “funcs” at http://hpaste.org/69390
14:02:33 <uniquenick> chrisdone: pretty much that yeah
14:02:47 <crdueck> what type of sort is the sort defined in Data.List?
14:02:49 <chrisdone> yeah… without them the bytestring stuff is a chore
14:02:56 <crdueck> @src sort
14:02:57 <lambdabot> sort = sortBy compare
14:03:03 <uniquenick> so, do is hiding some (>>=) already right?
14:03:05 <crdueck> @src sortBy
14:03:05 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
14:03:20 <chrisdone> uniquenick: yeah, all do is syntactic sugar for >>= and >>
14:03:29 <crdueck> @src insertBy
14:03:29 <lambdabot> insertBy _   x [] = [x]
14:03:30 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
14:03:30 <lambdabot>                                  GT -> y : insertBy cmp x ys'
14:03:30 <lambdabot>                                  _  -> x : ys
14:03:57 <navaati> :t insertBy
14:03:58 <lambdabot> forall a. (a -> a -> Ordering) -> a -> [a] -> [a]
14:04:14 <nand`> crdueck: you might be interested in the comments at http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html#sortBy
14:04:18 <applicative> uniquenick: yes of course
14:05:12 <applicative> it just moves the >>= \lambdas -> from right to left
14:06:33 <crdueck> i want to compare two numbers to see if they are permutations of each other, my two approaches are to convert both numbers to strings with show, and then a) see if each element in each string is an elem of the other string, O(n+m) where n,m are the lengths of the strings or b) to see if sort(n) == sort(m) and I'm wondering which would be faster
14:06:59 <uniquenick> chrisdone: why are those functions wrapping the result in a Controller?
14:07:30 <tromp_> a fails on 112 and 122
14:07:39 <nand`> crdueck: I would pick b)
14:07:47 <chrisdone> uniquenick: just because that was the type of my app. probably MonadSnap m is better, more generic
14:08:01 <nand`> crdueck: comparing each element to each element of the other string would be quadratic
14:08:10 <sepp2k> crdueck: How would the first option be O(n+m)?
14:08:12 <uniquenick> can't I just return it as a plain old Int?
14:08:25 <chrisdone> uniquenick: sure
14:08:30 <crdueck> sepp2k, nand`: no you're right, it would be quadratic
14:08:50 <applicative> crdueck: by 'the numbers are permutations of each other' you mean their names in decimal notation are permutations, I guess
14:09:03 <tromp_> it's linear if u use a bitmap to store the digitset
14:09:07 <nand`> applicative: yeah; the numbers themselves clearly aren't permutations :P
14:09:23 <mekeor> chrisdone: importing that example/init.el has also (negative) effects on my edit-mode.
14:09:23 <chrisdone> uniquenick: just change the type to Int
14:09:29 <crdueck> applicative: thats why i'm using show, so yes :)
14:09:45 <mekeor> chrisdone: i though it only effects the REPL, but it changed my edit-mode, too.
14:10:03 <nand`> crdueck: depending on the type of number involved “show” alone may have unintended consequences
14:10:19 <chrisdone> mekeor: ah, good point. probably better to cp it somewherre and just comment out the bindings you don't want
14:10:43 <nand`> you may want to convert it to a standardized number type first where you can predict the behavior of “show”, eg. Integer
14:11:19 <chrisdone> mekeor: i.e. all the ones in haskell-hook. they're all commented of what they do
14:11:19 <mekeor> chrisdone: also, when i type C-x C-s, it removes the source code and replaces it with "/bin/bash: stylish-haskell: command not found".
14:11:23 <crdueck> nand': i know that the numbers will be Integers
14:12:13 <chrisdone> mekeor: lol, yeah. two reasons: (1) C-x C-s is in the binding list, haskell-stylish-on-save is enabled which runs the stylish-haskell program on your source when saving
14:12:33 <chrisdone> mekeor: just comment out all the bindings and just uncomment the ones you want
14:13:14 <chrisdone> > read "10e10000000000000000000" :: Integer
14:13:20 <lambdabot>   mueval: ExitFailure 1
14:13:20 <lambdabot>  mueval: Prelude.undefined
14:13:25 <navaati> oO
14:13:28 <navaati> funny
14:13:41 <chrisdone> yeah. don't use read in your web apps :)
14:14:04 <RichyB> > read "10e1000000000000000000000000" :: Word64
14:14:09 <lambdabot>   mueval: ExitFailure 1
14:14:09 <lambdabot>  mueval: Prelude.undefined
14:14:13 <RichyB> Fun!
14:14:27 <navaati> (i'd say "don't use read. period.", this stuff seems pretty unsafe)
14:14:43 <navaati> read "10e1000000" :: Integer
14:14:53 <navaati> > read "10e1000000" :: Integer
14:14:54 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
14:14:56 <nand`> for SPECIALIZE pragmas, can I actually provide my own alternate body? eg specializing toInteger :: Integer -> Integer as ‘id’
14:15:09 <nand`> or would GHC reduce that to “id” already?
14:15:29 <chrisdone> nand`: i think you can check the core for the latter question?
14:15:49 <mekeor> chrisdone: why does that init.el load simple-indent at all? wouldn't it be nicer if it wouldn't?
14:16:48 <chrisdone> mekeor: it's just an example. :-) it's my personal configuration. until i've finished documenting emacs on the wiki this is a quick way to get people up and running
14:17:06 <chrisdone> i updated/reorganized the emacs pages http://www.haskell.org/haskellwiki/Emacs
14:17:47 <mekeor> ah, you did that? someone said that on the ML… yea, it's better now.
14:17:51 <Cale> Back when I used the Haskell stuff for emacs, I remember preferring the simple indent configuration because it didn't require me to press tab *after* typing the first few characters in a line to do something sensible :P
14:18:17 <taylorgb> What do you use now?
14:18:20 <Cale> vim
14:18:34 <mekeor> why?
14:18:53 <nand`> Cale: do you use the haskell mode or other flashy stuff for vim or just basic stuff like syntax highlighting and auto-indent?
14:19:03 <Cale> Just basic stuff
14:19:22 <Cale> I honestly don't really care much about text editor features and vim loads quickly.
14:19:36 <chrisdone> Cale: i also prefer the simple indent mode just because it's simple and predictable. the other ones always have edge cases and become distracting
14:20:05 <Cale> chrisdone: exactly :)
14:20:19 <luite> hm i still want to try the haskell mode things for easier import block handling
14:20:36 <nand`> I prefer my vim's indent configuration as well: it's set to “just preserve the previous line's indentation”. I make the calls when to indent or unindent myself, and it works best that way
14:20:46 <chrisdone> luite: yeah with jasper's stylish-haskell on C-x C-s it's pretty nice now
14:20:58 <luite> chrisdone: oh you've integrated support for that? cool
14:21:08 <nand`> luite: you might be interested in https://github.com/jaspervdj/stylish-haskell/blob/master/README.markdown which was recommended to me not too long ago
14:21:14 <chrisdone> aye. it's better than my regex crap
14:21:22 * mekeor is installing stylish-haskell…
14:21:23 <nand`> since you can run programs like that easily in vim using :! without needing extra vim plugins for it
14:21:43 <Cale> The one thing which no editor I've used does correctly is to understand and handle the offside rule really correctly, by which I mean any edit which causes the first non-whitespace character after a layout keyword to move should cause the entire block starting from that character to move accordingly.
14:21:44 <nand`> drat, chrisdone was faster than me this time
14:22:05 <RichyB> The fact that you call it the offside rule makes me smile.
14:22:29 <RichyB> It's apt. :)
14:22:30 <Cale> For example, if I have   f x y z = do ...  and I put the cursor before the do, and press enter and tap space a few times, the entire do-block should move
14:22:35 * mekeor is considering using irssi+vim instead of erc+emacs.
14:22:46 <chrisdone> Cale: sure. i remember the Yi guys started doing that stuff, but i don't know what came of it
14:22:48 <Cale> and I should end up with something like
14:22:51 <nand`> Cale: that sounds interesting and useful, I personally just make heavy usage of vim's block selection mode with < or > to achieve block moving effects
14:22:52 <Cale> f x y z =
14:22:54 <Cale>   do ...
14:23:15 <nand`> but it would be a quality of life improvement to have an editor that knows how I want to layout my code
14:23:26 <Cale> chrisdone: Their implementation was hacky and didn't quite work as solidly as I'd have liked.
14:23:30 <nand`> as long as the editor doesn't make false assumptions or indent things the way I *don't* want them indented
14:23:37 <chrisdone> I use C-<left>/C-<right> to move the whole block left or right, based on the column start of the lines
14:23:39 <nand`> if that's ever the case I'd prefer doing it manually every time
14:23:46 <nand`> an editor working against you is one of the most annoying things in existence
14:24:00 <Cale> It *did* handle the case of adding characters on the same line before a block began, but as soon as you pressed enter or did something more complicated, it fell over.
14:24:15 <chrisdone> Cale: ah, lame
14:24:55 <Cale> It would also be really nice if the editor would show grey lines "between characters" indicating where the layout blocks were.
14:25:10 <jaspervdj> chrisdone: BTW, I'm adding a config file for stylish-haskell, not sure how well that would integrate with haskell-mode
14:25:18 <chrisdone> i'm working on an editor that sits somewhere between AST and concrete
14:25:20 <Cale> (or I guess in terminal mode, one character before the block level)
14:26:15 <chrisdone> jaspervdj: shouldn't be a problem
14:26:33 <Cale> But yeah, apart from those things which no editor does, syntax highlighting, and the ability to convert tabs to spaces, I don't really care much :)
14:26:44 <chrisdone> Cale: you mean like dreamweaver/ultraedit, those kind of editors?
14:26:53 <Cale> I'm a vim user who makes hardcore vim users angry with me for using the arrow keys :)
14:27:09 <nand`> Cale: I also find the ability to display an 80col line to be crucial; I'm an avid fan of strict 80col compliance :)
14:27:10 <chrisdone> e.g. http://notepad-plus.sourceforge.net/commun/screenshots/scrsh_lexerJava.gif
14:27:22 <mcstar> i cant indent code in vim
14:27:30 <hpc> Cale: i use the arrow keys, but it doesn't get my crowd of hardcore users angry
14:27:32 <bitonic> in the end for me these changes are all marginal compared to flymake & tags. I don't think they save you that much time
14:27:37 <nand`> (mainly because my secondary monitor, when opening two terminals side by side, is basically exactly 80 columns wide per temrinal)
14:27:44 <nand`> terminal*
14:27:45 <Cale> nand`: I almost always end up breaking that. I'm not the worst when it comes to long lines, but I need at least 100 characters
14:28:24 <nand`> if I need more than 80cols, I break it up into separate lines, and if it's still impossible (without unindenting), I refactor into separate functions
14:28:26 * applicative favors about sixty but this leads to lots of dubious wheres
14:28:30 <Cale> Well, I can squish, but eventually it feels like I'm wasting time figuring out how to break my lines which would be better spent doing something else :)
14:28:51 <nand`> it mostly comes natural to me; I don't prefer long lines
14:29:20 <nand`> then again, I do use a lot of short variable names such as single letters
14:29:29 <Cale> Who doesn't? :D
14:29:30 <Cale> hehe
14:29:33 <nand`> so that's probably one negative consequence of 80col compliance
14:29:34 <chrisdone> i tend to always have a split screen, so <80-100 columns is ideal, otherwise i'm obstructing myself
14:29:43 <nand`> chrisdone: exactly
14:29:43 <bgamari> Hmmm, I guess there's no mapM on Repa arrays, eh?
14:29:51 <bgamari> Or any other monadic operations for that matter
14:30:23 <chrisdone> Cale: have you used the CSS entering mode in Firebug/Chrome developer pane?
14:30:26 <bgamari> Is there any way to do parallel RVar operations on an Array?
14:30:43 <Cale> I can fit maybe (2 + 4/5) 80 column terminals on my display
14:30:57 <Cale> at a comfortable size font
14:31:37 <Cale> I find you can usually tell how wide someone's display is based on the length of the lines in their code
14:31:50 <Cale> People with multi-monitor setups end up with crazy long lines :)
14:31:51 <nand`> I use xmonad's standard Tall configuration so I end up with two terminals side by side in my normal configuration; although I could probably fit three 80cols on my primary monitor. I do end up with a lot of wasted space that way, but it fits perfectly on my secondary monitor
14:32:19 <Cale> chrisdone: I haven't really used Firebug much
14:32:29 <nand`> Cale: I've yet to see a person use multiple monitors set up as one large display
14:32:45 <Luke> chrisdone: you around?
14:32:52 <Cale> chrisdone: Installed it and fiddled around a bit, but I don't do any web development stuff, so there's limited uses for me :)
14:32:57 * chrisdone pretends not to be here
14:33:00 <Luke> ha
14:33:00 <chrisdone> Luke: what's up? :p
14:33:04 <nand`> Cale: oh never mind, I think I understand what you meant
14:33:12 <Luke> I'm looking for someone with some insight into what's going on with haskell-mode
14:33:25 <Luke> chrisdone: it looks like all three indentation modes are on at once (i'm running off head)
14:33:26 <chrisdone> Luke: er, maybe. what part of haskell-mode?
14:33:28 <Cale> I do however have a bookmark which zaps the colours on a page and sets the text to black and background to white :)
14:33:35 <Luke> chrisdone: the main stuff
14:33:44 <nand`> Cale: in Firefox there's an option to force that globally
14:33:50 <chrisdone> Luke: oh, what's your configuration like?
14:34:07 <Cale> Well, I don't use it all the time, just when sites are annoying and put grey text on a grey background
14:34:13 <nand`> it's called “Allow web pages to choose their own fonts and colors” and if disabled will ignore most useless styling rules, serving for a greatly enhanced web experience (at least for me)
14:34:15 <applicative> I never counted before, it looks like I use up to 80 columns.  Need to reduce!
14:34:16 <nand`> I have it on permanently
14:34:23 <nand`> oh
14:34:27 <Cale> I hate the popularity of low contrast design
14:34:49 <Luke> chrisdone: I have a haskell-mode hook to (haskell-ident-mode t) and (haskell-indentation-mode nil)
14:34:50 <nand`> I use #ddccbb on #0e1112 personally, for basically every single program; including in my .gtkrc
14:34:59 <nand`> it works well
14:35:16 <nand`> but you may not like the bright-on-black
14:35:23 <timthelion> nand`: I usually go to View-page style-no style
14:35:43 <nand`> timthelion: interesting; I didn't know that option existed. Does that ignore all CSS though or just colors?
14:35:43 <timthelion> in firefox
14:35:49 <timthelion> all CSS
14:35:49 <Cale> I remember even reading an article claiming to be showcasing 10 "high contrast" web designs, but in 7/10 cases the contrast between anything that mattered was obnoxiously low.
14:35:57 <chrisdone> Cale: i was just wondering because the way you enter CSS in that is kind of cool. it's basically a structured editor. you write free-form text in a text box and then either hit : or tab and that replaces the text box with the CSS property, and then you write the value on the right hand side. you hit ; or tab and it starts a new property. if any of what you entered was wrong, it just removes the whole line. web devs are using structured
14:35:58 <chrisdone> editors without knowing it ;)
14:36:06 <nand`> (I should note that the “allow pages to...” also disables background images, which reduces memory load and network bandwidth consumption quite considerably)
14:36:16 <timthelion> it's usefull for those news sites with ads on the side.  Usually, I get a plain block of text ad free. And I can zoom in without breaking the css crap.
14:36:25 <chrisdone> Luke: hmm, ok. let me check that
14:36:56 <nand`> timthelion: interesting. I don't see advertisements either way due to strictly configured ad blocking plugins; which extends to many text ads as well
14:37:00 <Cale> I just have adblock plus
14:37:07 <Cale> (for Chrome)
14:37:40 <nand`> I use AdBlock Plus too, but I should note that in newer versions they made a deal to selectively allow some advertisements that they get paid for; which goes against my morals somewhat. I still use it though, but you should make sure to *disable* that option
14:37:42 <chrisdone> Luke: yeah, i think that you can't just use haskell-indent-mode. you should remove those and look for turn-on-* in your config and comment them out
14:37:50 <Cale> Yes, I do.
14:37:58 <Cale> I've gotten way too used to not seeing ads on the web to start letting some through now.
14:37:58 <Luke> chrisdone: I know a lot of this isn't your code but I know you also know a little more about what the hell's going on there than I do =)
14:38:07 <chrisdone> Luke: if you start haskell-mode fresh with no indentation enabled, and hit tab, i got it to pop up a buffer to explain how to enable indentation modes
14:38:22 <Luke> chrisdone: let me try that
14:39:03 <Cale> The ability to block ads in object subrequests (e.g. from flash) was the bug I was waiting on for years before I would switch to Chrome from Firefox.
14:39:04 <chrisdone> nand`: your morals of using expensive services for free? :p
14:39:40 <nand`> chrisdone: my morals of misleading users while getting bribed behind their backs :)
14:39:49 <Luke> chrisdone: yeah I'm doing what #3 from the popup says
14:40:00 <Cale> and it was recently fixed, so ABP actually works properly for things like video ads now.
14:40:15 <nand`> I don't have flash installed. I couldn't care less about video ads :)
14:40:24 <Cale> I also download all my TV shows with ads removed from them :)
14:40:33 <nand`> Cale: who doesn't?
14:40:37 * applicative prefers reading webpages in a terminal with pandoc -r html -w plain --columns=60   http://webpage
14:40:44 <Eiler> how can i determine how many parameters a function takes?
14:40:50 <Cale> Eiler: it takes one :)
14:41:00 <Eiler> Cale: i know, but you know what i mean
14:41:03 <Cale> :)
14:41:09 <Cale> Well, you can ask for its type from ghci
14:41:12 <chrisdone> define a class Arity or something
14:41:15 <Cale> and just stare at that
14:41:19 <td123> Eiler: in ghci, :i funcname or :t funcname
14:41:25 <darkniobe> Eiler: > :t print
14:41:27 <Eiler> Cale: hmm preferably at runtime in the program
14:41:30 <nand`> Eiler: count the number of top-level arrows
14:41:55 <Cale> Eiler: The function at runtime will have had a type, and so no other type of function will be possible to occur at that point in the code
14:41:57 <Eiler> or at compile time
14:42:00 <nand`> s/top-level/top-level with respect to right associativity/
14:42:14 <applicative> Eiler: ask ghci for the type signature
14:42:26 <Cale> (apart from polymorphically, in which case the answer isn't well-defined)
14:42:32 <applicative> @type foldr
14:42:33 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:42:40 <Eiler> applicative: can i do that inside the program?
14:43:03 <fmap> > id id id id id id id id id 7
14:43:04 <lambdabot>   7
14:43:04 <nand`> Eiler: for all intents and purposes the type disappears after compilation
14:43:07 <nand`> it's static
14:43:12 <tuxit> evening all
14:43:15 <fmap> Eiler:  how many parameters does id take?
14:43:21 <tuxit> rather new here
14:43:30 <applicative> Eiler, what are you doing exactly? This is seeming increasingly theoretical
14:43:38 <tuxit> trying to find my way around in tutorials
14:43:43 <Cale> tuxit: hello! Feel free to ask any questions you might have about Haskell :)
14:43:47 <tuxit> any hints ?
14:43:49 <Cale> Beginners are always welcome :)
14:43:50 <nand`> :t id `asAppliedTo` id
14:43:51 <lambdabot> forall a. (a -> a) -> a -> a
14:44:02 <nand`> tuxit: here's a hint: LYAH
14:44:04 <Cale> tuxit: Maybe try "Learn You A Haskell"?
14:44:09 <tuxit> thx Cale
14:44:18 <applicative> tuxit excellent
14:44:21 <tuxit> ooh I started that, looked nice
14:44:22 <geekosaur> the question sounded liek it was heading toward some kind of eval mechanism, which is an even bigger rat's nest for someone used to languages where an interpreter is available at runtime
14:44:34 <darkniobe> tuxit: Or "Real World Haskell"
14:44:44 <tuxit> thye oreilly book ?
14:44:45 <applicative> @where LYAH
14:44:46 <lambdabot> http://www.learnyouahaskell.com/
14:44:46 <Eiler> in c++ i could use templates to to determine how many parameters a function takes, that is at compile time of course, so it might be some way in haskell as well
14:45:02 <darkniobe> @where RWH
14:45:02 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
14:45:06 <nand`> “LYAH” is like a newcomer friendly version of “RTFM”
14:45:18 <tuxit> uh oh
14:45:20 <tuxit> hehe
14:45:40 <nand`> tuxit: (not really, it was just an observation that probably nobody else shares)
14:45:47 <darkniobe> tuxit: except that it also exists as a book ;-)
14:45:55 <tuxit> aaah
14:45:55 <Cale> Eiler: Well... you can do some typeclass hackery to count the parameters to a function basically by making an instance for functions with a result type that is an arbitrary instance of the typeclass.
14:46:04 <nand`> tuxit: (don't take it the wrong way)
14:46:10 <Cale> Eiler: and then defining it for some base types like Integer, etc.
14:46:12 <tauIsSonOfEuler4> marienz_is_autist_txopm_fails_untwisted_rocka
14:46:16 <Eiler> Cale: ok
14:46:17 <Cale> Eiler: for example, see Text.Printf
14:46:23 <timthelion> geekosaur: I have been thinking, that there is really no reason why we cannot do run time interpretation in haskell.  Launch new thread from GHC, and then, when we want to interpret some code, we return an MVar to GHC, pipe the code we want to interpret, place it in the MVar, and recurse.
14:46:31 <tuxit> nand`: no
14:46:38 <chrisdone> class Arity a where arity :: a -> Integer; instance Arity b => Arity (a -> b) where arity f = 1 + arity (f undefined); instance Arity Int where arity _ = 0
14:46:38 <chrisdone> λ> arity (undefined :: Int) → 0
14:46:38 <chrisdone> λ> arity (undefined :: Int -> Int) → 1
14:46:38 <chrisdone> λ> arity (undefined :: Int -> Int -> Int) →  2
14:46:39 <timthelion> geekosaur: sorry, ghci I mean
14:46:42 <chrisdone> :p
14:46:46 <timthelion> s/GHC/ghci/
14:46:51 <bgamari> Is there any way to parallelize "safe" monadic actions on Repa arrays?
14:47:11 <Cale> Eiler: Typically, an application of your typeclass method will be ambiguously typed, and so you'll ironically have to specify the type of its result, or set things up in such a way that it's monomorphic and can be inferred.
14:47:11 <geekosaur> timthelion, it's not enormously difficult if you have ghc-lib around, but it's not a stock service and not generally wrapped for easy use like eval mechanisms in interpreters
14:47:23 <nand`> timthelion: except in the majority of scenarios call for the question of “why would you want to do that?” being asked instead. I can really only think of a select few cases where you'd really want runtime running of Haskell code
14:47:48 <Cale> timthelion: do you know about hint?
14:47:51 <timthelion> geekosaur: I looked at ghc-lib and it doesn't do what you want,since it cannot easilly handle type errors.
14:47:51 <tuxit> does haskell run on a true JIT like java ?
14:48:07 <nand`> no
14:48:08 <timthelion> Cale: no
14:48:21 <Cale> tuxit: Not usually?
14:48:26 <geekosaur> timthelion, yet ghc-lib is how all of them do it currently, *including ghci*, and somehow they manage
14:48:34 <Cale> tuxit: GHC does static compilation to native code
14:48:46 <Cale> tuxit: as well as bytecode interpretation (GHCi)
14:48:47 <nand`> tuxit: GHC, the most popular haskell implementation, is a compiler that produces more or less native code that runs in a VM offering garbage collection and thread switching, among other things
14:48:55 <timthelion> tuxit: so long as you have the source code to haskell, we can prevent anything unexpected from happening using type safety.  So no JIT is needed.
14:49:00 <nand`> tuxit: but there's no compiling going on *during* runtime
14:49:05 <nand`> like a JIT would suggest
14:49:11 <Cale> The VM is just a bunch of supporting library code, pretty much
14:49:17 <tuxit> so you are close to real assembler ?
14:49:18 <nand`> Cale: isn't any VM?
14:49:24 <chrisdone> no
14:49:31 <Cale> It's not a virtual machine really
14:49:37 <Cale> We call it a runtime system
14:49:38 <chrisdone> it's just a runtime like libc
14:49:38 <nand`> yeah, the term “VM” is used lightly
14:49:49 <nand`> and probably incorrectly, by me
14:50:11 <chrisdone> possibly hugs has a bytecode interpreter that you could call a vm?
14:50:25 <Cale> However, I guess the bytecode interpreter used in GHCi is kind of a virtual machine? I don't really know how that works in detail.
14:50:27 <geekosaur> the only thing that's vm-like is the interpreted path used by runghc and ghci
14:50:33 <timthelion> nand`: VM implies "translation" and that doesn't mean we translate every bite, but it kind of means run time behavioral checking.
14:50:39 <nand`> what about “runhaskell”? Does that work like GHCi or does it statically compile and link a temporary executable and then fork into it normally?
14:50:43 <nand`> s/fork/exec/
14:50:53 <tuxit> so the compiler compiles to native assembler code ?
14:50:55 <Cale> nand`: I *think* runhaskell works like ghci
14:51:00 <Cale> tuxit: right
14:51:08 <tuxit> just my geeky curiosity
14:51:10 <b_jonas> chrisdone: ghc has a bytecode interpreter too, but uses it only in ghci (etc), not in normal compilation, right?
14:51:10 <jfischoff> runhaskell works like ghci
14:51:21 <Cale> tuxit: and there's increasingly good support for cross compilation to stuff like ARM.
14:51:22 <b_jonas> ah, Cale already said that
14:51:29 <nand`> tuxit: you don't need a “Haskell framework” present on the target machine to run an executable compiled with GHC
14:51:30 <timthelion> How do we *prove* that ghci has the SAME behavior as GHC's static compiling?
14:51:32 <nand`> if that's what you're curious about
14:51:41 <ben> you might need gmp though~
14:51:41 <jfischoff> Cale: do you know if ghci works on ARM?
14:51:44 <Cale> (which should get into future versions of GHC)
14:51:47 <nand`> like you need a JVM or the .NET framework or a python interpreter to run any of those respective languages
14:51:48 <tuxit> Cale that is nice
14:52:33 <Cale> jfischoff: I think it *might*... I haven't actually run GHC on an ARM machine myself.
14:52:39 <nand`> you just need the stuff GHC executables link against, like libgmp, libffi, libc, libpthread and so on
14:52:58 <b_jonas> right, and the haskell runtime and haskell modules if you link dynamically
14:53:10 <nand`> yeah, the default is static though
14:53:25 <nand`> so if you're shipping something to customers that don't necessarily have any haskell runtime installed you'll want to leave it at that
14:53:26 <darkniobe> Anyone here familiar with the Nsis package on hackage?
14:53:29 <Clint> jfischoff: didn't last time i checked, but that might be different with the llvm backend
14:53:34 <b_jonas> libpthread you need only if you compile for multiple os threads, which you won't do on a typical embedded device I think
14:53:40 <b_jonas> not that it matters much
14:54:03 <b_jonas> libpthread isn't really an obstacle anyway
14:54:09 <nand`> b_jonas: I see, I just listed some names from the output of “ldd <latest haskell program I compiled>”, which does involve threading
14:54:18 <b_jonas> right
14:54:24 * hackagebot Decimal 0.2.3 - Decimal numbers with variable precision  http://hackage.haskell.org/package/Decimal-0.2.3 (PaulJohnson)
14:54:31 <Cale> darkniobe: I wasn't, but that looks really cute for windows users :)
14:54:51 <darkniobe> I'm trying to use Nsis as it's used in the examples in the haddocks, and it works fine so long as I use string literals. If I use parameters though, it coughs up type errors
14:55:27 <Cale> darkniobe: ah, that would be because it has this Exp type which is an instance of IsString
14:55:30 <darkniobe> Namely: Expected type: Exp String Actual type: String
14:55:37 <Cale> darkniobe: So your string literals aren't Strings
14:55:37 <Cale> right
14:56:11 <darkniobe> Is there a function to lift a String into the Exp typeclass?
14:56:12 <Cale> darkniobe: You should be able to apply fromString
14:56:27 <Cale> Exp is just a normal type, not a class
14:56:50 <darkniobe> Ahh
14:57:12 <darkniobe> Cale: just tried fromString, not in scope
14:57:24 <Cale> import Data.String
14:57:25 <nand`> import Data.String (fromString)
14:57:29 <darkniobe> kk
14:57:50 <Cale> http://hackage.haskell.org/packages/archive/nsis/0.1.2/doc/html/Development-NSIS.html#t:Exp -- might want to read this bit of the docs
14:58:09 <darkniobe> Yay!
14:58:24 <darkniobe> Cale, nand`: that did it
14:59:55 <darkniobe> Cale: I actually did read that, and it threw me off a bit. Gave me the impression that fromString was used explicitly to give $VARs to the nsis script; as opposed to wrapping a string
15:00:24 <Cale> Yeah, it's a bit of a funny extension to GHC which allows string constants to be polymorphic
15:00:37 <darkniobe> Cale: i.e. like #INSTDIR or $TEMP
15:00:42 <Cale> This is a borderline abusive use of it ;)
15:00:44 <nand`> Cale: oh?
15:00:47 <darkniobe> s/$/#
15:00:53 <darkniobe> hehe
15:01:00 <nand`> Cale: wait so, I can just use "" literals for stuff like Data.Text without needing “fromString” there?
15:01:03 <Cale> It's normally used in order to make Data.Text or Data.ByteString.Char8 more pleasant
15:01:11 <Cale> yes
15:01:23 <nand`> This is interesting; did not know that. So they're like fromInteger. What other literals get this treatment?
15:01:36 <Cale> That's about it
15:01:55 <Cale> I don't think there's one for character literals
15:02:11 <Cale> (nobody's complained that they needed one)
15:02:14 <hpaste> Luke pasted “haskell-mode” at http://hpaste.org/69394
15:02:21 <tuxit> well thx for the pointers, I will spend some time learning haskell, you might see me back in the near future with some stupid noob questions ;-)
15:02:33 <Cale> tuxit: Yeah, don't be afraid to ask :)
15:02:37 <Luke> chrisdone: http://hpaste.org/69394
15:02:59 <nand`> Cale: how are fractional literals treated again? fromRatio or whatever the Integer/Integer type is called?
15:03:09 <geekosaur> hm, don't you need an extension for strings to be handled that way?
15:03:09 <Luke> chrisdone: for some reason, if I have more than just turn-on-haskell-indent in the quoted list, it doesn't detect it (and shows that popup)
15:03:10 <jfischoff> nand`: Overloaded strings is controversial. It can bite you in the ass.
15:03:10 <Cale> yeah, fromRational actually
15:03:13 <applicative> tuxit: yes ask here
15:04:00 <nand`> ah, Rational = Ratio Integer. I always mix those two up
15:04:01 <Cale> nand`: Which has some funny effects when trying to convert fractional constants with large denominators
15:04:01 <applicative> the strange bit is the appearance with OverloadedStrings that you are pattern matching
15:04:24 <Cale> (but mostly is a decent way to do things)
15:04:57 <nand`> do the ratios get reduced or do they get stuck at % 100000000000 or however many decimals you used?
15:05:05 <Cale> > 1.5e-437128904731843712890423704371894272318074238990473 :: Double
15:05:10 <lambdabot>   mueval: ExitFailure 1
15:05:10 <lambdabot>  mueval: Prelude.undefined
15:05:21 <Cale> ^^ that takes a long time
15:05:41 <Cale> (and a lot of space)
15:05:54 <nand`> Cale: amusing, memory usage at 36% and growing
15:06:23 <Cale> If you think about why it would, you'll probably find that your machine isn't large enough.
15:06:44 <nand`> gigantic exponents
15:07:00 <Cale> yeah, resulting in an Integer which is proportionally long
15:07:29 <Cale> 437128904731843712890423704371894272318074238990473 decimal digits or so :)
15:07:38 <Cale> (more in binary)
15:09:17 <nand`> Is there a module containing a collection of mathematically significant numbers? I know ‘pi’ is in Floating, but what about stuff like ‘e’?
15:10:30 <chrisdone> i think there is actually
15:10:35 <chrisdone> maybe Numeric.something…
15:10:52 <Cale> > exp 1
15:10:53 <lambdabot>   2.718281828459045
15:10:58 <Cale> ^^ prelude function
15:11:12 <Cale> Note also:
15:11:15 <Cale> > log (exp 1)
15:11:16 <lambdabot>   1.0
15:11:23 <Cale> Haskell gets the base of log right ;)
15:11:26 <nand`> right
15:11:29 <nand`> I did notice that already :)
15:11:42 <nand`> what about, say, phi (the golden ratio)
15:12:06 <nand`> I *could* just use (1 + sqrt 5)/2
15:12:44 <dmwit> Haskell++ for giving a useful error message on stack overflows instead of just segfaulting
15:12:54 <applicative> nand`: surely you want the limit of fib (n+1)/fib n
15:13:31 <dmwit> > (1 + sqrt 5)/2
15:13:32 <lambdabot>   1.618033988749895
15:13:34 <nand`> applicative: a bit troublesome to express as code, that one
15:13:41 <dmwit> ?oeis 1 6 1 8 0 3 3 9 8 8
15:13:43 <lambdabot>  Decimal expansion of golden ratio phi (or tau) = (1 + sqrt(5))/2.
15:13:43 <lambdabot>  [1,6,1,8,0,3,3,9,8,8,7,4,9,8,9,4,8,4,8,2,0,4,5,8,6,8,3,4,3,6,5,6,3,8,1,1,7,7...
15:13:52 <nand`> amusing command
15:14:04 <dmwit> nand`: There you go. The OEIS package gives you mathematically significant numbers.
15:14:11 <dmwit> ...like phi =)
15:14:27 <nand`> oh my
15:14:33 <nand`> you weren't kidding; it has [Integer] -> IO [Integer]
15:14:39 <dmwit> =)
15:14:52 <tgeeky> nand`: and my 'rivers' package gives you lots of examples from OEIS, as Streams
15:14:54 <jfischoff> ?oeis 12 12 19 80
15:14:55 <lambdabot>  Sequence not found.
15:15:05 <tgeeky> ?oeis 1 2 1 2 1 9 8 0
15:15:08 <jfischoff> ?oeis 12 12 1980
15:15:10 <lambdabot>  Sequence not found.
15:15:10 <lambdabot>  Sequence not found.
15:15:21 <jfischoff> well I guess I'm not important
15:15:27 <tgeeky> nope!
15:15:33 <jfischoff> wah wah
15:15:42 <dmwit> Aha! Now I just need your credit card number and I can pose as you...
15:15:52 <tgeeky> jfischoff: will you grab 'centered' from my github, see if you can build it (with or without tests), and see if the documentation looks right?
15:16:02 <jfischoff> all part of my plan to escape my booky
15:16:24 <jfischoff> tgeeky: I was just looked at that! on it
15:16:45 <tgeeky> jfischoff: Sections 01,02,03, parts of 05, and Ref should be complete and working
15:17:01 <tgeeky> jfischoff: screenshots or descriptions of problems would be appreciated
15:17:14 <tgeeky> it's a lot of work to turn a research paper into a hackage package :o
15:17:21 <jfischoff> tgeeky: did you see this? https://github.com/alanz/Blobs
15:17:30 <tgeeky> nope, not yet
15:17:31 <jfischoff> looks promising
15:17:42 <jfischoff> dmwit ^ if you haven't seen it
15:17:56 <nand`> ?oeis 1992 1996 2000 2004 2008 2012
15:17:57 <lambdabot>  Sequence not found.
15:17:59 <tgeeky> looks pretty so far
15:18:36 <jfischoff> yeah, not sure if it builds yet…I'll check it out this weekend. slowing hacking together a shellac for us too..
15:19:51 * jfischoff is building
15:20:06 <applicative> > let step (x,y) = (y,x+y) ; pairs = iterate step (0,1) ; phis = map (\(x,y) -> y/x) pairs in phis !! 100
15:20:07 <lambdabot>   1.618033988749895
15:20:32 <applicative> not too bad for a phi approximator...
15:21:47 <kallisti> shapr: atually Shelly probably has an easier interface for simple stuff.
15:21:56 <kallisti> regarding filesystem manipulation.
15:22:19 <jfischoff> tgeeky: how do you run doctest?
15:23:29 <jfischoff> tgeeky: ah
15:25:05 <acowley> Does anyone happen to know if emacs (aquamacs in particular) can be setup to display in-line typeset previews of a document that needs lhs2tex processing?
15:25:25 <acowley> Basically I want a literate haskell file that is pretty to look at.
15:39:14 <bitonic> acowley: you can open the pdf in emacs and compile on save. I don't think there is a WYSIWYG mode... texmacs does that for latex
15:40:03 <acowley> bitonic: LaTeX mode lets me preview equations in-line, it would be neat to extend that to more general usage
15:41:44 <jfischoff> tgeeky: section 4 seems wrong. Just has test04 a -> a ….
15:42:01 <bitonic> acowley: http://www.gnu.org/software/auctex/ this looks promising
15:42:18 <acowley> bitonic: Yeah, that's what I use
15:42:51 <acowley> But I fear that I would need to hack some elisp to pipe things through lhs2tex
15:49:30 * peropaal is wondering about the ()
15:50:11 <mauke> @src ()
15:50:11 <lambdabot> data () = ()
15:50:49 <peropaal> is it just a syntactical construct? like a helper?
15:51:11 <kallisti> the () sytnax is a syntactic construct, but semantically it's identical to any other type or constructor.
15:51:16 <kallisti> () is the name of type, as well as a constructor of that type.
15:51:19 <kallisti> *of a type
15:51:58 <kallisti> it's called the empty tuple type, or the unit type. It's the type with only one inhabitant.
15:52:09 <c_wraith> it's special syntax for a value identical to data Nil = Nil
15:52:15 <c_wraith> value and type
15:52:20 <peropaal> but I observe that it's used when you don't care about the result
15:52:25 <kallisti> thus, it conveys very little information, and mostly indicates that the result of a computation isn't important.
15:52:26 <shachaf> Only one inhabitant...
15:52:26 <geekosaur> since everything is an expression, everything has to have a type.  but if you have something that is useful only for side effects (like output) you need some kind of type/value to produce anyway
15:52:28 <kallisti> yes.
15:52:32 <shachaf> Except for the *other* inhabitant.
15:52:37 <kallisti> shapr: shhhhh
15:52:42 <c_wraith> shachaf: we ignore that other one in polite company
15:52:42 <peropaal> ah, NIL, right
15:52:51 <kallisti> er  shachaf: ^
15:53:04 <c_wraith> shachaf: there's even a paper telling us it's morally correct to do so!
15:53:47 <shachaf> c_wraith: If only Haskell was a moral language!
15:54:29 <peropaal> I encountered Nothing and thought of Nil, but clearly thats another type... or?
15:55:09 <S11001001> nothing isn't a type
15:55:39 <peropaal> Nothing is something that belongs to the Maybe
15:55:52 <shachaf> peropaal: You should probably read an introduction to how algebraic data types work in general. :-)
15:56:15 <shachaf> A lot of these special cases make much more sense once you've figured that out.
15:56:19 <peropaal> shachaf: ok
15:56:22 <peropaal> :-)
15:56:22 <int-e> peropaal: an important difference is that Nothing and Just Nothing can be distinguished, while the trick of using a nil pointer can not be nested like that.
15:57:08 <peropaal> but, quickly, what is the classification of Nothing? The terminology?
15:57:25 <mauke> (data) constructor
15:57:26 <int-e> data constructor
15:57:29 <peropaal> okay
15:58:01 <shachaf> It's also a value.
15:59:34 <kallisti> it's also more specifically a nullary constructor, like True, False, LT, GT, EQ, and ().
15:59:39 <ninegrid> will haskell ever have active patterns?
15:59:59 <dmwit> What the heck is an active pattern?
16:00:10 <ninegrid> matching on function application and not just constructors
16:00:52 <dmwit> With backtracking, Prolog-style you mean?
16:00:55 <mauke> is that like view patterns?
16:00:59 <dmwit> If so, then never.
16:01:06 <dmwit> Otherwise, view patterns as mauke said.
16:01:21 <dmwit> However, we do have the wonderful LogicT monad transformer for all your Prolog needs.
16:01:25 <shachaf> I wish you could make nicer-syntaxed view patterns.
16:01:47 <Peaker> Don't view patterns destroy the ability to statically infer completion of the pattern matchers?
16:01:56 <bitonic> dmwit: except unification :)
16:02:18 <mauke> > let mep _ [] = []; mep f (f -> x : mep f -> xs) = x : xs in mep show [1,2,3]
16:02:18 <bitonic> which is half of prolog
16:02:19 <lambdabot>   <no location info>: parse error on input `->'
16:02:30 <dmwit> bitonic: Ah, well, as for that, we've got a variety of unification monads. =)
16:02:33 <dmwit> ?hackage unification-fd
16:02:33 <lambdabot> http://hackage.haskell.org/package/unification-fd
16:02:34 <mauke> > let mep _ [] = []; mep f ((f -> x) : (mep f -> xs)) = x : xs in mep show [1,2,3]
16:02:35 <lambdabot>   ["1","2","3"]
16:02:38 <ninegrid> dmwit: i'm not familiar with the prolog mechanism you're referring too, but active patterns exist in F# as well as partial active patterns...
16:03:01 <dmwit> ninegrid: Telling me where they exist doesn't help me much. You'll have to tell me what they do, instead.
16:03:03 <ninegrid> mauke: I'll look into this view patterns thing, is it in GHC now or do I have to do something special?
16:03:10 <bitonic> dmwit: yeah, but unification is still fairly annoying in haskell, in my experience
16:03:33 <mauke> ninegrid: both
16:03:44 <ninegrid> dmwit: consider a function like this: let (|Even|Odd|) x = if x % 2 = 0 then Even else Odd;; that may be used in pattern matching
16:04:11 <int-e> Peaker: you can still require that all possible return values of the view (per its data type) are matched in the function definition.
16:04:39 <dmwit> ninegrid: Help me parse that: is |Even|Odd| all one name?
16:04:45 <Peaker> int-e, ah, it's just nice syntactic sugar for doing a (. someFunc) on that parameter?
16:04:58 <int-e> Peaker: precisely
16:05:02 <ninegrid> dmwit: it is, and correlates to the return values of the pattern
16:05:12 <int-e> Peaker: (which is the same kind of overapproximation that pattern completeness already is: rather than checking which values the function is actually called on)
16:05:38 <ninegrid> dmwit: a partial active pattern would be like:  (|Foo|_|) x = if fooable x then Just x else Nothing
16:05:40 <Peaker> int-e, I just write the function and a little wrapper like:   funcI x y z = ...  and then:  func = foo ~> bar ~> baz $ funcI
16:05:40 <int-e> Peaker: (... one checks that all data constructors are matched)
16:06:11 <dmwit> um
16:06:22 <Peaker> if you write func = foo ~> bar ~> baz $ \x y z -> ...        you almost get the desired notation :)
16:06:26 <dmwit> ninegrid: Can you show what the case expression that would use such a thing looks like?
16:06:40 <dmwit> ninegrid: case 2 of |Even|Odd| -> ...?
16:06:50 <Peaker> where infixr 2 ~> ; (f ~> g) x = g . x . f
16:07:07 <Peaker> @let infixr 2 ~> ; (f ~> g) x = g . x . f
16:07:08 <lambdabot>  Defined.
16:07:25 <ninegrid> dmwit: only in ML-ish syntax;  match x with Even x -> "even" | Odd x -> "odd"
16:07:44 <int-e> ninegrid: views are the closest we have for that.
16:08:11 <ninegrid> dmwit: the reason i bring it up, is i am reading a paper by Erwig on FGL and it uses a function in pattern matching, which *is* an active pattern, but that functionality is not available in GHC
16:08:32 <ninegrid> int-e: thank you, i'll read up on them
16:08:41 <tommd> ninegrid: You mean ViewPatterns?
16:08:45 <tommd> GHC has those.
16:09:09 <ninegrid> tommd: good to hear
16:09:17 <dmwit> According to wikibooks, active patterns are for defining new data types, not for defining functions.
16:09:37 <dmwit> Though I'm having a heck of a time deciphering their examples.
16:09:47 <kallisti> I don't particularly like the idea of conflating pattern matching with function application. view patterns have the syntactic conciseness, without the semantics (which I'm not too clear on. it looks like you're automatially converting to some Even/Odd type)
16:10:11 <ninegrid> dmwit: semantically those patterns i gave as example are returning types, where then name of the type is in the name of the function, which as a whole is applicative and usable from pattern matching constructions
16:11:18 <mauke> this could also be done with normal functions and pattern guards
16:11:58 <ninegrid> dmwit: probably best to look at this if you are interested http://dl.acm.org/citation.cfm?id=1291159
16:12:54 <ninegrid> dmwit: if you search for that papers title on scholar.google.com you will find a pdf
16:13:17 <dmwit> Oh, yuck. Active patterns define a new type, and then associate that type with an implicit call to a conversion function.
16:13:55 * dmwit likes explicit better than implicit for most things
16:21:05 <ninegrid> dmwit: "an active pattern is a pattern defined without reference to a discriminated union type declaration. at a basic level an active pattern is just a regular function, but it is defined using a new syntactic element called a 'structural name' which gives it special significance in the language. patterns are used to decompose data into a number of subcases"
16:21:36 <ninegrid> no matter though I believe that I will find something just as (if not more so) elegant in the haskell way
16:22:28 <kallisti> ninegrid: I would rather have "smart constructors" that are defined for existing types, as a sort of abstract constructor
16:24:06 <dmwit> huh
16:25:11 <dmwit> I thought +RTS -N controlled the number of OS threads.
16:25:21 <tgeeky> jfischoff: just run cabal test to run doctests
16:25:34 <tgeeky> jfischoff: and section 4 isn't complete, it just has a empty doctest so it is couted
16:25:38 <tgeeky> counted*
16:25:39 <jfischoff> tgeeky: cool
16:25:47 <tgeeky> jfischoff: otherwise, looks ok?
16:25:56 <jfischoff> yeah looks awesome
16:26:18 <tgeeky> just 1.5 sections to go
16:26:53 <tgeeky> ok; bbl
16:27:53 <kallisti> ninegrid: check out Data.Sequence for an example of viewpatterns
16:28:10 <kallisti> the ViewR and ViewL types
16:28:56 <kallisti> f (viewl seq -> x :< xs) = ...
16:29:36 <kallisti> allows you to do list-like pattern matching on a type without a cons-like constructor.
16:30:29 <shachaf> dmwit: I think active patterns sound pretty nice.
16:30:59 <shachaf> I don't like the view pattern syntax at all.
16:32:07 <dmwit> I'm beyond confused.
16:32:12 <dmwit> Does threading do that to other people, too?
16:32:30 <shachaf> Ugh, I can't stand those mailing lists posts where everyone replies to each other.
16:32:34 <shachaf> I lose track immediately.
16:33:28 <ninegrid> kallisti: thank you
16:34:04 <dmwit> Ah, maybe I do understand what's going on...
16:34:43 <ninegrid> has anyone here made use of FGL?
16:36:09 <tommd> yep
16:36:20 <morel> so, with cabal i don't necessarily need a Setup.hs? (when i have "built-type: simple"?)
16:36:56 <dmwit> morel: If you want to distribute your package on Hackage, you still need it. =)
16:37:06 <morel> ah, okay.
16:37:10 <morel> dmwit: thanks
16:37:12 <morel> @time dmwit
16:37:13 <lambdabot> Local time for dmwit is Fri Jun  1 19:36:51 2012
16:37:19 <ion> dmwit: Oh, good to know.
16:37:33 <morel> how do i distribute my package on hackage, btw?
16:37:56 <dmwit> rm dist/*.tar.gz && cabal sdist && cabal upload dist/*.tar.gz
16:38:05 <dmwit> That first && should probably be a ;
16:38:30 <morel> nice
16:39:29 <applicative> morel, cabal init makes a setup hs or maybe you know that.
16:40:22 <kallisti> dmwit: oh...
16:40:39 <kallisti> I didn't know about cabal upload. I always use the web interface. :P
16:41:06 <dmwit> Yep. If you trust your file system to protect your password, you can even put it in ~/.cabal/config
16:41:21 <dmwit> So, what does -N really control?
16:41:39 <dmwit> How many non-FFI threads are in use, maybe?
16:42:15 <morel> applicative: i didnt.
16:44:38 * morel joined cabal-world today.
16:48:39 <morel> what's the best way to launch a program which is installed localled in ~/.cabal/bin/ with root-priviledges?
16:49:52 <morel> sudo /home/user/.cabal/bin/executable isn't that elegant…
16:50:00 <morel> but acceptable.
16:50:03 <morel> hi coppro
16:50:08 <morel> i mean copumpkin.
16:50:19 <morel> sorry
16:50:22 <copumpkin> hi
16:50:31 <copumpkin> oh, it's the guy whose name is an anagram
16:51:09 <morel> hehe =)
16:51:23 <copumpkin> are you secretive about your identity or are you really called that? :P
16:52:13 <strager> morel: export PATH="$HOME/.cabal/bin:$PATH" ; sudo executable
16:53:30 <morel> strager: er… does sudo use that PATH-variable then?
16:53:59 <Cale> morel: Make sure that it's in your path?
16:54:04 <Cale> yeah
16:54:13 <morel> Cale: it's in my path.
16:54:20 <morel> but not in the path of root.
16:54:25 <Cale> What I do is to just put ~/bin in my path and make ~/.cabal/bin a symlink to ~/bin
16:54:33 <Cale> ah
16:54:57 <morel> 01:49 <morel> what's the best way to launch a program which is installed localled in ~/.cabal/bin/ with root-priviledges?
16:55:24 <morel> s/localled/locally/g
16:56:17 <morel> strager: it IS already in my path…
16:56:57 <Cale> Yeah, I hadn't actually fully noticed that about sudo, it does use root's PATH instead.
16:57:01 <mauke> sudo `which executable`
16:57:32 <morel> mauke: yea, that's nice
16:57:54 <morel> i'll use that.
16:58:07 <morel> thanks
16:58:15 <morel> @time mauke -- oO
16:58:16 <lambdabot> Local time for mauke is running out
16:58:22 <morel> heheheh
16:58:40 <mauke> (try again)
16:59:37 <morel> @time mauke -- oO
16:59:39 <lambdabot> Local time for mauke is running out
16:59:49 * mauke kicks his RNG
16:59:56 <Cale> @time mauke
17:00:04 <morel> lol
17:00:07 <mauke> ah, better
17:00:12 <morel> do i have a lag?
17:00:18 <mauke> that one exploits a bug in lambdabot
17:00:23 <mauke> it triggers with the next @time
17:00:30 <Cale> hah
17:00:33 <Cale> @time
17:00:34 <lambdabot> Local time for Cale is Fri Jun  1 20:00:12
17:00:38 <mauke> er, @time mauke
17:00:46 <Cale> @time mauke
17:00:47 <lambdabot> Local time for mauke is an illusion
17:00:47 <lambdabot> Local time for mauke is an illusion
17:00:52 <morel> hehe
17:01:31 <mauke> @time
17:01:35 <lambdabot> Local time for mauke is approximately 02:01
17:02:18 <c_wraith> doubly so?  must be lunch time for mauke
17:03:40 <morel> i'm becoming awesome.
17:03:53 <morel> mauke is already… ;(
17:04:55 <morel> Cale! come back, pls! =( where are you, bro? why did you left us, dude?
17:07:06 <morel> byorgey! come back, pls! =( where are you, bro? why did you left us, dude?
17:08:40 <strager> morel: Odd; I thought sudo looked through the current user's path.
17:08:51 <strager> and used the current session's env vars in general.
17:09:30 <geekosaur> for security reasons it is often configured not to do so.  for example, OS X uses the calling user's env by default, debian/ubuntu do not
17:10:08 <morel> geekosaur isn't called geekosaur without a reason.
17:10:59 <strager> geekosaur: I see; didn't know.
17:11:06 <strager> The More You Know!
17:16:54 <morel> Do function *have to* have a type-signature in correct Haskell2010?
17:17:04 <kallisti> of course.
17:17:12 <kallisti> or, well
17:17:19 <kallisti> not explicitly annotated, no.
17:18:01 <paczesiowa> can HTTP download large files (and how large is 'large')?
17:18:01 <kallisti> though I'm not sure where you got the impression that Haskell 2010 no longer infers types.
17:18:19 <mapreduce> @quote alsup
17:18:20 <lambdabot> No quotes match. Just try something else.
17:18:29 <Ralith> functions needing a type signature wouldn't mean it didn't infer types.
17:18:37 <morel> kallisti: no. i was just wondering…
17:24:36 * hackagebot happstack-yui 7351.4.0 - Utilities for using YUI3 with Happstack.  http://hackage.haskell.org/package/happstack-yui-7351.4.0 (DagOdenhall)
17:24:39 <Cale> Even in Haskell 98, there are definitions which require explicit type signatures
17:24:59 <Cale> Typeclasses introduce the potential for ambiguity
17:26:16 <acowley> How can I see the result of applying a type family?
17:26:43 <acowley> I really want to see what it gives me for something like T (Foo Bar)
17:27:04 <acowley> But I don't know how to ask the type checker such a question.
17:27:06 <morel> Cale: "there are definitions which require explicit type signatures" -- isn't that obvious. (i mean, because of monomorphism-restriction.) did you want to say that there are definitions which require the lack of their type-signatures?
17:27:30 <Cale> morel: No, if it's obvious, that's good :)
17:27:38 <morel> :)
17:27:57 <Cale> morel: Plain Hindley-Milner though gives everything a principal type
17:28:08 <Cale> Typeclasses ruin that
17:28:19 <morel> and dep-types ruin it even more…
17:28:37 <morel> don't they? they do. right?
17:31:06 <parcs`> acfoltzer: :t undefined :: T (Foo Bar)
17:31:10 <parcs`> acowley: ^
17:38:18 <nand`> morel: there are definitions which would require GHC extensions to give them type signatures
17:38:23 <nand`> but are inferred correctly
17:38:42 <morel> nand`: Xample, pls.
17:40:00 <nand`> morel: scoped type variables; sortImage :: Ord b => (a -> b) -> [a] -> [a]; sortImage f = sortBy cmp where cmp x y = compare (f x) (f y) -- trying to give a type signature here requires ScopedTypeVariables
17:41:18 <nand`> the type of cmp would be :: a -> a -> Ordering -- but the ‘a’ here really refers to the ‘a’ from sortImage, not forall a.
17:41:44 <edwardk> preflex: xseen dolio
17:41:44 <preflex>  dolio was last seen on freenode/#haskell-blah 1 day, 13 minutes and 42 seconds ago, saying: Might take a while before enough of your cells start blowing up due to that to notice.
17:42:03 <edwardk> @tell dolio no faster :(
17:42:03 <lambdabot> Consider it noted.
17:42:19 <morel> nand`: got it. nice, thanks.
17:42:38 <nand`> morel: there's probably some other example involving RankNTypes
17:42:42 <morel> nand`: but that's not in top-level, you know…
17:42:49 <nand`> indeed
17:43:05 <nand`> I wasn't sure whether top level was implied; so I just said “there are definitions”
17:43:14 <morel> ah, ok.
17:43:36 <dolio> edwardk: I heard.
17:43:38 <morel> nand`: tell me, if you stumble upon such a phenomenon in top-level ;)
17:45:31 <nand`> ah, I was thinking of an example but it doesn't get inferred correctly (indeed errors)
17:45:48 <nand`> so in this case you actually need the type signature as well; in addition to a GHC extension
17:47:59 <nand`> :t (\f -> [f 1, f 'a']) :: (forall a. a -> b) -> [b] -- to clarify
17:48:00 <lambdabot> forall b. (forall a. a -> b) -> [b]
17:48:13 <edwardk> :)
17:48:23 <nand`> drop the type signature and it'll complain about how 'a' isn't a number
17:49:38 * hackagebot happstack-yui 7351.4.1 - Utilities for using YUI3 with Happstack.  http://hackage.haskell.org/package/happstack-yui-7351.4.1 (DagOdenhall)
18:34:22 <mm_freak> @tell navaati currently there is no online repository, sorry
18:34:22 <lambdabot> Consider it noted.
18:42:39 <kallisti> hm I actually saw git annex assistant on kickstarter
18:42:45 <kallisti> I didn't realize it was a Haskell project.
18:47:41 <applicative> kallisti: have you used it?
18:49:16 <kallisti> applicative: nope
18:50:46 <applicative> oh http://hackage.factisresearch.com/ is up again, awesome
18:53:59 <Clint> yay reverse deps
18:54:32 <ymasory> is there a particular reason haskell doesn't provide a shortcut for printing to stderr? is it considered bad form or something?
18:55:32 <kallisti> ymasory: hPutStr stderr is pretty reasonably short.
18:55:53 <kallisti> ...but, no, I don't actually have an answer. :P
18:56:49 <ymasory> kallisti: thanks :)
18:57:08 <geekosaur> Debug.Trace.trace, sort of.
18:57:19 <applicative> Clint, yeah, it  is really helpful comprehending hackageland
18:57:23 <kallisti> now /that/ would be bad form. :P
18:57:48 <Clint> why doesn't real hackage do that?
18:58:05 <geekosaur> I believe that's the prototype for hackage v2
18:58:10 <applicative> Clint, it didn't but this is supposed to
18:58:13 <applicative> like geekosaur said
18:58:23 <Clint> ah
18:58:29 * kallisti thinks a download count would be nice.
18:58:47 <kallisti> currently I have no clue if anyone actually uses my software. So I assume they don't and make huge breaking changes to my code.
18:58:47 <geekosaur> they're working on it, as they have time; nobody being paid to manage it, and round tuits are at a premium
18:59:42 * kallisti is perfectly happy with the existing hackage.
18:59:45 <kallisti> no complaints here.
18:59:45 <applicative> my impression was there had been a pile of wild ideas, more than reverse dependencies, which had been separately implemented I thought.
19:01:22 <applicative> i mean there was a reverse dependency mechanism at 'bifunctor.homelinux.something' for some time
19:05:23 <applicative> one good thing about showing reverse dependencies is you might hit on something that could show you how actually to use some libraries
19:06:45 <applicative> it occurred to me that if there was some simple registry of unpretentious executables, then if this too were somehow tracked, it would have immense tutorial value
19:10:13 <applicative> i mean if competent people just uploaded, to some annex of hackage,  any simple scripts they had written for real purposes -- but cabalized so that the dependencies could be tracked.
19:10:43 * Clint nods.
19:11:33 <applicative> then they would be generating little tutorials for whatever they were using, without actually thinking about it.  I guess this is obvious
19:18:16 <otters> has anybody here used Text.Regex
19:18:32 <Clint> probably
19:18:53 <hpc> otters: the real question is, has anybody here ever used it twice?
19:18:56 <hpc> :D
19:19:03 <otters> "(\\w+)" won't match "foo"
19:19:06 <otters> and I'm not sure why
19:19:14 <Clint> are you using pcre?
19:19:31 <otters> yeah
19:19:41 <otters> but afaict that syntax is valid under egrep rules
19:20:33 <Clint> + is, \w isn't
19:21:10 <otters> huh
19:21:21 <otters> http://www.gnu.org/software/findutils/manual/html_node/find_html/egrep-regular-expression-syntax.html
19:21:21 <geekosaur> right.  use the pcre version if you want \w
19:21:22 <otters> is misleading me
19:21:51 <geekosaur> gnu regex is not quite the same as POSIX EREs
19:22:21 <geekosaur> (there are too many regex variants in existence)
19:22:58 <otters> yes
19:30:10 <applicative> why is my ghci so frequently suffering when I open it, thus Loading package base ... linking ... done. //Segmentation fault
19:30:39 <hpc> applicative: you only import stuff from base?
19:30:44 <hpc> no other files and things?
19:31:34 <tgeeky>  .ghci has numeric literals in it for some reason, and evaluating them causes segfault?
19:31:59 <applicative> it doesn't seem to matter, it happens if i just type ghci  it is obviously something to do with my system, since it was the same before I replaced my old ghc with a new one the other day
19:32:18 <applicative> tgeeky interesting, I suppose it is about when its reading .ghci
19:33:42 <applicative> no, the empty .ghci does it just as well
19:34:01 <applicative> tgeeky is playing with poor applicative
19:34:08 <tgeeky> hehe
19:34:25 <tgeeky> i love me some applicative functors, but I would buck the trend and rename you idiom :O
19:34:27 <hpc> is there a test suite somewhere you can run on ghc/ghci?
19:34:28 <Zenith77> If you're receiving this automated message, you moderate at least one popular reddit community. Thanks for your contribution to the site, and congratulations on your success. Please subscribe to /r/modnews, a place we've set up for announcements of interest to moderators. Only the reddit admins can post links there, so it shouldn't clutter up your front page too much.
19:34:29 <Zenith77> err
19:34:31 <Zenith77> wrong channel
19:34:44 <hpc> lol
19:34:57 <applicative> hpc, it never happens with ghc , its during ghci's startup
19:35:06 <S11001001> everyone in #haskell now has mod on /r/pics
19:36:44 <tgeeky> down with pictures of cats, up with pictures of lambdas!
19:37:21 <applicative> tgeeky but what about lambda cats or whatever theyre called
19:39:34 <tgeeky> they get as many upvotes as downvotes, resulting in only heat
19:39:43 <applicative> of which the greatest was indisputably http://smu.gs/K0tCUH
19:40:07 <applicative> well, downvote it if you like
19:40:19 <tgeeky> hopefully none of the things in the fridge are unwrapped
19:42:15 <applicative> conal i am just reading conal on beautiful folding
19:42:25 <RylandAlmanza> I have a couple questions again
19:42:36 <RylandAlmanza> First, what does $ do in haskell
19:42:42 <applicative> RylandAlmanza: nothing
19:42:55 <conal> applicative: cool. enjoy.
19:42:56 <tgeeky> RylandAlmanza: the same thing as " ", but with a different prcedence
19:43:44 <applicative> someone mentioned the post of Max Rabkin, then i got carried away thinking about it, in trivial ways, then they pointed out your consequent posts
19:43:49 <RylandAlmanza> And, I need a list of things I can access by their keys. Is there something like a hashmap in haskell? Or a more purely functional alternative?
19:44:04 <tgeeky> RylandAlmanza: Data.Map
19:44:48 <applicative> conal, it was a rather sensible question on stackoverflow http://stackoverflow.com/questions/10803221/haskell-can-i-perform-several-folds-over-the-same-lazy-list-without-keeping-lis
19:46:06 <RylandAlmanza> Thanks :)
19:46:25 <conal> applicative: i love it when a practical problem has a beautiful theoretical solution.
19:46:42 <tgeeky> since working on this (dualising and generalising) the (third list homomoprhism) pearl, I'm beginning to think that the notion of strictness being implied for foldr/foldl isn't quite so obvious as it seems (at least when you weaken your equations to relations instead of functions)
19:46:47 <conal> "There is nothing so practical as a good theory" - Phil Wadler
19:47:01 <applicative> conal: in this case the question was really perfect, yes
19:50:33 <applicative> anyway I am looking at the ZipFold library which I also hadnt seen.
19:51:40 <nand`> “next-generation sequencing” is this one of those cases where the usage of a hip and modern word is actually justified?
19:52:46 <applicative> conal, what surprised me most though its totally obvious is that the same Fold s can be folded over anything sequential, e.g. the word8s of a bytestring or some unpacked vector thing
19:53:39 <nand`> “sum . map fromEnum . map isBotEntry” <- is there any difference or advantage between this and “length . filter isBotEntry”?
19:54:29 <nand`> or is that just to demonstrate the folding
19:55:16 <conal> applicative: oh, yeah. and maybe generalized nicely to the more general notions like Foldable
19:59:30 <NemesisD> anyone know how to make ghc look in cabal-dev for preprocessors?
20:01:20 <NemesisD> i'm using https://github.com/sol/hspec-discover to auto generate my test main file, i have hspec-discover as a dependency for the test suite with cabal-dev but it complains that it can't run hspec-discover unless its installed globally
20:01:54 <NemesisD> i'm assuming OPTIONS_GHC -F -pgmF hspec-discover means its a preprocessor
20:10:58 <nand`> applicative: an interesting read, that link
20:15:46 <otters> for fuck's sake
20:16:00 <otters> why does Text.Regex.PCRE have the IO monad in its compile function
20:19:41 <aristid> otters: because it uses an unsafe C function, i guess?
20:20:45 <geekosaur> yeh, PCRE's compile function can't be considered safe since it does allocation (and a pessimal regex could cause it to allocate very large amounts of memory)
20:27:38 <parcs`> geekosaur: do you  have an example of a regex that allocates a large amount of memory?
20:28:47 <geekosaur> not off the top of my head, but perl has historically had some pathological regexes; the known ones have been fixed as they've been found, I don't know whether pcre has kept up though
20:29:19 <geekosaur> the {m,n} syntax for repeats is one that sued to be particularly nasty
20:29:30 <geekosaur> used to be
20:29:52 * hackagebot gnome-keyring 0.2.3 - Bindings for libgnome-keyring  http://hackage.haskell.org/package/gnome-keyring-0.2.3 (JohnMillikin)
20:31:27 <otters> fuck it
20:31:30 <otters> unsafePerformIO
20:31:51 <dmwit> otters: Don't do it.
20:32:11 <dmwit> Be strong!
20:32:17 <ion> geekosaur: What *doesn’t* do allocation? :-P
20:32:24 <otters> dmwit: I'm too weak
20:32:51 <ion> Btw: http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Foreign-Marshal-Unsafe.html
20:33:05 <nand`> isn't the setting for most regex-related stuff going to be in some form of real world interaction either way? It seems to me for pure parsing you would prefer to use some combinatorial parsing library instead of a string-based regex
20:33:29 <ion> Using that function displays the intent better than using unsafePerformIO directly. Its very point is a situation like that: a FFI operation whose only impurity is memory allocation.
20:33:38 <nand`> perhaps even a direct, pure / statically typed analog to regular expressions themselves
20:33:51 <otters> Oh
20:33:53 <otters> Okay
20:34:36 <geekosaur> just plain memory allocation is fine, but the pathological cases mean it can take your whole program out...
20:34:39 <otters> Hm
20:34:47 <otters> despite the fact that I'm using base >= 4 I don't have that module
20:34:55 <ion> Naturally, the library should use that internally and not make users use it. Could the action have some additional side effects,?
20:35:14 <otters> oh no it's in 4.5
20:35:17 <otters> I have 4.3
20:35:36 <otters> ion: suggestions?
20:35:44 <ion> Upgrade.
20:35:54 <otters> What version of haskell is that?
20:36:24 <ion> I have GHC 7.4.1, i seem to have Foreign.Marshal.Unsafe.unsafeLocalState.
20:36:38 <Axman6> what's the type of that?
20:36:48 <ion> The same as unsafePerformIO
20:36:52 <Clint> unsafeLocalState :: IO a -> a
20:36:53 <otters> 7.4?
20:36:58 <otters> I thought 7.4 was a no-no
20:37:03 <Axman6> hmm. what's it used for?
20:37:26 <ion> “The only IO operations allowed in the IO action passed to unsafeLocalState are (a) local allocation (alloca, allocaBytes and derived operations such as withArray and withCString), and (b) pointer operations (Foreign.Storable and Foreign.Ptr) on the pointers to local storage, and (c) foreign functions whose only observable effect is to read and/or write the locally allocated memory. Passing an IO operation
20:37:28 <ion> that does not obey these rules results in undefined behaviour.”
20:37:29 <otters> same thing as unsafePerformIO
20:37:32 <otters> oh
20:37:43 <nand`> unsafeLocalState = unsafeDupablePerformIO
20:37:50 <nand`> maybe you have the latter function somewhere
20:37:54 <Clint> It is expected that this operation will be replaced in a future revision of Haskell.
20:37:55 <nand`> it seems to be in GHC.IO
20:38:55 <dmwit> Are you guys serious?
20:39:19 <dmwit> Upgrade GHC so you can use unsafeLocalState (which in its own documentation says it will disappear in the future) which is a rename of a function that's already available?
20:40:00 <ion> Upgrade GHC so you’ll have all the awesome new stuff. :-P
20:40:05 <edwardk> unsafeDupablePerformIO is a much more stable dependency than this unsafeLocalState thing ;)
20:40:11 <dmwit> I mean, I don't think unsafePerformIO is the right answer, but it's not so much more wrong that it warrants a lot of work...
20:40:41 * edwardk will never feel clean again after what he has done.
20:42:40 <Axman6> did edwardk just kill himself?
20:42:58 <nand`> nah, that would have been a ping timeout
20:43:43 <dmwit> His quit message is very clear: he didn't kill himself, he was killed by his peer.
20:44:05 <nand`> It says “reset”, not “terminated”
20:44:10 <nand`> I assume amnesiacs are involved
20:44:13 <Axman6> but that was the message from the server
20:44:27 <Clint> we'll never know
20:44:37 <nand`> If only edwardk was here to elaborate
20:44:39 <nand`> ..oh
20:44:40 <edwardk> ?
20:44:42 <edwardk> =P
20:44:59 <Axman6>  * edwardk will never feel clean again after what he has done.
20:44:59 <Axman6>  * edwardk will never feel clean again after what he has done.
20:45:04 <Axman6>  * edwardk has quit (Read error: Connection reset by peer)
20:45:10 <Axman6>  <Axman6> did edwardk just kill himself?
20:45:11 <edwardk> Hah, I take it my comment made it through before my client decided to choose a suitably epic time to disconnect
20:45:49 <Axman6> urgh, double paste, sorry
20:45:51 <aristid> edwardk: it was the best of times
20:45:51 <edwardk> I've been recanting my backward functional ways and embracing mutable state and awkward control flow
20:46:36 <nand`> as long as it was still pure and statically typed there's nothing to regret
20:46:40 <edwardk> but the code that made me do that: https://github.com/ekmett/dysfunctional/blob/master/src/main/scala/dysfunctional/State.scala
20:46:48 <edwardk> nand`: no, the problem is it is decided unpure
20:46:52 <edwardk> er decidedly
20:46:53 <nand`> ah
20:47:06 <edwardk> but at least statically typed
20:47:29 <nand`> “package dysfunctional”
20:48:00 <nand`> I once again feel exceedingly compelled to link to https://github.com/mmirman/ImperativeHaskell/blob/master/Main.hs
20:48:32 <edwardk> basically monads in scala are a way of saying 'crash me' or 'run slow', so, i decided to explore ways to make monads fast, while getting scala to implicitly plumb all the state for me
20:48:50 <edwardk> and sadly, its a lot faster =(
20:49:16 <Axman6> I've just been watching a video from the LLVM EU Dev meeting, and was surprised to see a group of researches using (a form of) continuations in their OpenCL compiler for CPUs, so they could implement synchronisation barriers
20:49:17 <nand`> edwardk: then it is for a noble cause; your sacrifice is a means for the greater good
20:50:02 <nand`> edwardk: I'm sure I'll come round to thanking you in person when I inevitably learn Scala for JVM compatibility
20:50:13 <ion> axman6: URL please.
20:50:15 <nand`> s/in person/personally/
20:50:27 <Axman6> http://llvm.org/devmtg/2012-04-12/
20:50:27 <edwardk> well, after my dignity and sanity, the first casualty was our type checker, which started picking up all sorts of odd bits of state
20:50:31 <Axman6> the last talk
20:50:32 <ion> Thanks
20:51:25 <edwardk> sadly almost all the remaining time is spent in the only thing i can't transform into this pattern very easily: the parser
20:54:12 <edwardk> i did find it particularly funny that as a consequence we have comonads in the type checker now, but no monads
20:55:16 <RichyB> edwardk, ...yyyeah, that is genuinely funny.
20:56:14 * edwardk 's sarcasm meter is on the fritz again
20:56:57 <mauke> so I had a look at Data.Reflection
20:57:10 <edwardk> mauke: =)
20:57:21 <mauke> is it building a fake class dictionary by hand?
20:57:22 <nand`> edwardk: unfortunately; not knowing Scala in any way, shape or form; in addition to exceedingly little contact with comonads as opposed to their more popular cousins (hehe, co-), I am completely unable to understand the joke. I'm sure that it's hilarious, though!
20:57:26 <edwardk> mauke: yep
20:57:34 <mauke> black magic indeed
20:58:12 <edwardk> mauke: its passing 'const a' as the dictionary for 'class Reifies s a | s -> a where reflect :: proxy s -> a'
20:58:40 <edwardk> because 'const a' :: b -> a  and 'reflect :: proxy s -> a' have interchangeable representations
20:59:09 <edwardk> mauke: its also about 3 orders of magnitude faster than the old implementation =/
20:59:31 <mauke> and thus a 14-page paper is reduced to 4 lines of code
20:59:53 <edwardk> mauke: yep
21:00:10 <edwardk> mauke: even better, that code is hugs compatible as well
21:00:39 <edwardk> though it has an alternate implementation for other compilers who aren't so silly with their dictionary representations ;)
21:00:45 <mauke> is Magic necessary?
21:00:51 <edwardk> yeah
21:00:58 <edwardk> i tried just putting the signature there
21:01:11 <edwardk> it is smart enough to figure out it doesn't know what 's' is if Magic isn't there
21:01:34 <edwardk> the first version we got to work used a separate combinator
21:01:41 <edwardk> but Magic resulted in less code
21:02:14 <nand`> looking at https://github.com/ekmett/reflection/blob/b7afdc4035b0d4576d916577f3f05ae7348acfda/slow/Data/Reflection.hs I'm honestly not sure which version I prefer
21:03:28 <mauke> edwardk: did removing $! make any difference?
21:03:50 <edwardk> just saved an attempt to force a function
21:04:33 <edwardk> and made the code a couple characters shorter
21:08:34 <edwardk> plus at that point it is pretty obvious that there isn't anything you can do to make that code faster, because its literally turning it into a direct function call
21:09:36 <edwardk> the dysfunctional stuff i was talking about above is a similar trick scala side, make up a type path, stuff a value into it, but add combinators to massage it
21:18:44 <nand`> “(Semigroup m, Monoid m) => ” isn't that redundant?
21:19:14 <edwardk> it would be, if Semigroup was a superclass of Monoid
21:19:18 <edwardk> alas, we're not in that world
21:19:43 <shachaf> "(Functor m, MOnad m) =>" isn't that redundant?
21:19:59 <nand`> indeed
21:20:21 <nand`> oh, I figured it out
21:21:21 <edwardk> i can always fall back on using the constraints package to fabricate a Semigroup dictionary out of a Monoid, but thats silly ;)
21:21:37 <nand`> (I was confused by the fact that the Comonad instance for Monoid m => (m ->) needed Semigroup as well, it's because of the the Extend constraint on the Comonad class
21:21:42 <edwardk> plus it leads to some pretty heavy dependencies
21:21:45 <edwardk> yeah
21:22:36 <strager> data D = A { thing :: Maybe Int } | B String
21:22:55 <strager> Can I define 'thing' to return Nothing when given a D constructed with B?
21:23:03 <shachaf> Nope.
21:23:05 <strager> Or, is there a mostly-automatic way to define a new function?
21:23:10 <shachaf> Well, you can define "thing" yourself.
21:23:14 <shachaf> But not with record syntax.
21:23:18 <strager> k
21:23:26 <shachaf> How mostly-automatic do you want it?
21:23:52 <shachaf> Note that the "thing" you're asking for loses information.
21:24:21 <strager> Loses what information?
21:24:35 <shachaf> A Nothing vs. B anything
21:24:36 <nand`> strager: if “thing” returns “Nothing” it could either be a B _ or an A Nothing
21:25:01 <strager> Yes, I understand that
21:25:09 <strager> I'm fine with defining a new function
21:25:18 <strager> I was just looking for a mostly-automated way of defining it
21:25:31 <strager> I understand that B "" { thing = Just 42 } would also be weird
21:25:36 <nand`> hmm
21:25:44 <nand`> @djinn Either (Maybe Int) String -> Maybe Int
21:25:45 <lambdabot> Error: Undefined type Int
21:25:51 <nand`> @djinn Either (Maybe Integer) String -> Maybe Integer
21:25:52 <lambdabot> Error: Undefined type Integer
21:25:54 <nand`> shame
21:25:59 <strager> I only have a few constructors so I can match manually
21:26:04 <nand`> @djinn Either (Maybe a) String -> Maybe a
21:26:04 <lambdabot> Error: Undefined type String
21:26:21 <nand`> before I embarrass myself further; does djinn even know about Maybe and Either?
21:26:25 <shachaf> Yes.
21:26:32 <nand`> @djinn Either (Maybe a) b -> Maybe a
21:26:32 <lambdabot> f a =
21:26:33 <lambdabot>     case a of
21:26:33 <lambdabot>     Left b -> b
21:26:33 <lambdabot>     Right _ -> Nothing
21:26:33 <shachaf> nand`: The type you're asking for is completely uninteresting as a proposition, though, so there's not much point to this.
21:26:44 <shachaf> foo _ = Nothing is a perfectly valid implementation of your function.
21:26:48 <dmwit> B "" { thing = Just 42 } would be especially weird because "" isn't a record.
21:27:04 <nand`> shachaf: I know; I was just interested to see what djinn would come up with
21:27:20 <strager> dmwit: ;P  You know what I meant
21:27:24 <dmwit> yep =)
21:27:38 <dmwit> just showing off
21:27:42 <shachaf> Record syntax. :-(
21:28:11 <nand`> shachaf: does djinn try to make it so the inferred type of its function matches the type you gave it as well? If so, “foo _ = Nothing” would be a mismatch
21:28:22 <nand`> ie. matching the type exactly, not just somehow
21:28:46 <shachaf> nand`: No, pretty much nothing in Haskell does that.
21:28:50 <mauke> I think it tries to make use of all values
21:28:58 <shachaf> It's all about the unification, man.
21:29:06 <shachaf> What mauke says is true.
21:29:11 <mauke> @djinn a -> () -> a
21:29:12 <lambdabot> f a _ = a
21:29:22 <nand`> ah
21:29:24 <shachaf> But it's still not useful for writing complicated functions like that.
21:29:53 <shachaf> If you want to be sure that Djinn will give you the "right" answer, narrow down the question (by adding polymorphism) until there's only one answer. :-)
21:30:46 <dmwit> ?djinn (forall a. a -> a -> b) -> a -> a -> b
21:30:46 <lambdabot> -- f cannot be realized.
21:30:56 <dmwit> your advice didn't work =(
21:31:25 <mauke> how is that unique?
21:31:34 <dmwit> oh, fine
21:31:43 <dmwit> ?djinn (forall a. a -> b) -> a -> b
21:31:43 <lambdabot> -- f cannot be realized.
21:31:45 <mauke> f a _ _ = f () ()
21:31:55 <dmwit> ah, quite
21:32:21 <shachaf> f a _ _ = a () ()
21:32:39 <mauke> quite
21:33:50 <nand`> f a b = f a b
21:34:00 <shachaf> f = f
21:34:09 <shachaf> Superdjinn!
21:34:20 <nand`> heh
21:34:21 <shachaf> @let superdjinn _ = text "f = f"
21:34:22 <lambdabot>  Defined.
21:34:40 <shachaf> > superdjinn "forall a. ((a -> forall b. b) -> a) -> a"
21:34:42 <lambdabot>   f = f
21:35:03 <Ralith> lol
21:35:08 <nand`> f = unsafeCoerce undefined
21:35:13 * Axman6 thinks that should be called define, so you can use define (undefined :: a -> b -> c -> (a,c))
21:35:26 <dmwit> nand`: f = undefined -- omgptimized
21:36:05 <mauke> Axman6: that exists
21:36:13 <nand`> dmwit: nice, O(1) too
22:17:57 <miller> "No instance for (Eq int) ... arising from the literal `0' ... In the pattern: 0 ... In a case alternative: 0 -> acc" -- Please tell me I did something completely retarded as this makes no sense.
22:18:31 <shachaf> Typing in the error message by hand is kind of silly.
22:18:37 <shachaf> Unless "int" is actually lower-case "int"?
22:18:42 <shachaf> In which case you probably want "Int".
22:20:06 <miller> hrrrrrrrrrg. X_X
22:21:24 <geekosaur> making it lowercase means it's using it as a type variable, and in the presence of numeric literals that does make for somewhat confusing errors...
22:22:29 <miller> Yeah, as soon as shachaf pointed that out, I started going "WHY ISN'T THERE ANY SORT OF WARNING FOR THIS?!" then realized exactly that. >_>
22:23:15 <miller> Thanks shachaf. :)
22:29:20 <geekosaur> haskell tries perhaps a bit too hard to make numerics play the way people expect them to
23:17:01 <pharaun> what do you mean by that ^ - i haven't done heavy numberics in haskell yet
23:28:48 <unnali> wow, i'm an idiot
23:29:11 <unnali> i was doing: uncurry MyDataCons `fmap` liftM2 (,) actA actB -- names changed to protect the innocent
23:29:19 <unnali> and just realised I can do liftM2 MyDataCons actA actB
23:29:20 <unnali> -_-
23:32:36 <mzero> then there's    MyDataCons <$> actA <*> actB
23:34:20 <unnali> that's .. also not bad.
23:34:33 <unnali> :D
23:34:40 <unnali> i seemed to have skipped applicative functors :\
23:35:41 <unnali> btw, I don't suppose there's a way to point-free a record field assignment?
23:36:25 <mgsloan> the best way is probably http://hackage.haskell.org/packages/archive/fclabels/1.1.3/doc/html/Data-Label.html
23:37:23 <mzero> unnali: alas, nope
23:37:58 <lpsmith> is there a way to get ghci to load a package from a dist directory,  without installing it,  instead of from the user/global package directory?
23:38:17 <unnali> mgsloan, mzero: thanks! I might avoid it, then.
23:39:01 <mzero> lpsmith: do you mean load from source, or load the built one?
23:39:10 <lpsmith> mzero, the built one
23:39:24 <lpsmith> hmm
23:39:38 <lpsmith> n/m,  ghc-7.4.1 seems to do that automatically already
23:40:12 <lpsmith> err, never mind
23:40:35 <lpsmith> I can import random modules and it doesn't give me an error message if it doesn't find it
23:40:50 <lpsmith> so rather,  my question is still relevant
23:42:15 <mzero> I don't know - I use the -src option all the time for source, but I never try to load build modules
23:42:31 <plat0> Can someone tell me what {..} does
23:42:32 <plat0> in this
23:42:33 <plat0> let ServerConfig{..} = fromMaybe defaultServerConfig mServerConf in S.simpleHTTP (S.nullConf { S.port = port }) $
23:42:36 <plat0> ...
23:42:45 <lpsmith> I load compiled modules all the time.
23:42:53 <lpsmith> plat0, that's a record wild card
23:43:03 <plat0> It binds the names in the record to the local namespace/
23:43:04 <lpsmith> it brings all the fields of the record into scope
23:43:04 <plat0> ?
23:43:08 <lpsmith> right
23:43:14 <plat0> As values, rather than selectors?
23:43:18 <lpsmith> exactly
23:43:33 <plat0> Sounds extremely naughty to me.  Is this a controversial extension?
23:43:34 <lpsmith> kind of a name shadowing you don't get a warning about
23:43:40 <lpsmith> not that controversial
23:43:48 <plat0> Oh ok
23:44:00 <lpsmith> (of course,  I think compiler warnings about name shadowing are bogus)
23:44:38 <lpsmith> Compilers shouldn't warn you of shadowing.   In fact,  sometimes the most elegant code in my opinion uses shadowing
23:44:46 <lpsmith> intentionally
23:44:50 <plat0> Basically it provides a bit more convenience than "let c = fromMaybe defaultServerConfig mServerConf in ... (port s) ... (other_selector s) ..."
23:45:06 <plat0> err s/c/s
23:45:17 <lpsmith> yeah,  you can also construct records that way too...
23:45:19 <plat0> Anyway you get to write "port" rather than "port varname"
23:45:45 <lpsmith> and then do something like return ServerConfig{..}
23:46:04 <plat0> I don't get that
23:46:07 <plat0> what do you mean?
23:47:05 <lpsmith> like,  something like      do { hostnameSelector <- getHostName;  timeoutInterval <- ...,    return ServerConfig{..} )
23:47:17 <plat0> Oh really?
23:47:20 <plat0> Do it the opposite way!
23:47:25 <lpsmith> yup :)
23:47:30 <plat0> This is strange syntax to me
23:47:35 <plat0> Too implicit IMHO.
23:47:42 <lpsmith> yeah,  but it's syntax,  not semantics
23:47:54 <lpsmith> so it's far less dangerous than you think
23:48:20 <plat0> OK
23:48:38 <lpsmith> And if you construct a record that way,  the compiler will warn you that you didn't get all the fields filled in
23:49:28 <plat0> Why just a warning?
23:49:33 <lpsmith> record wildcards are a sanity saver sometimes,  I use them pretty often for certain kinds of code
23:49:56 <plat0> If you didn't fill in all the fields surely that's an error?
23:50:30 <lpsmith> plat0,  that's the way records work, for better or worse :-/
23:51:04 <plat0> I'm confused then.
23:51:11 <lpsmith> > data Point = Point { x :: Float, y :: Float } deriving (Show)
23:51:12 <lambdabot>   <no location info>: parse error on input `data'
23:51:18 <lpsmith> > Point { x = 3 }
23:51:19 <lambdabot>   Not in scope: data constructor `Point'
23:51:29 <lpsmith> plat0, try that in a recent ghci ;-)
23:51:29 <plat0> What does that do for y?
23:51:36 <lpsmith> initializes it to an error
23:51:53 <AfC> [you can construct records using do syntax?!?]
23:52:38 <plat0> lpsmith: isn't this extremely bad?
23:52:40 <lpsmith> AfC, it is completely orthogonal to do syntax,  though it's when I'm writing imperative network code that I find record wildcards the most useful
23:52:52 <lpsmith> plat0, well, it does warn you
23:52:52 <plat0> It's something that can't be caught at compile time
23:52:58 <plat0> I see
23:53:05 <plat0> I suppose there's always undefined, which is just as bad
23:53:10 <lpsmith> yeah
23:53:17 <plat0> Naughty haskell
23:53:18 <lpsmith> I don't know why it's that way
23:53:32 <lpsmith> I agree,  I'd prefer it to be an outright error myself
23:53:40 <lpsmith> of course, there is always -Werror
23:53:50 <adamt> can undefined pop up out of nowhere, or only from one's own code and crappy libraries?
23:54:15 <lpsmith> but if I go -Wall -Werror,  I almost always turn off certain errors, such as name shadowing
23:54:32 <plat0> Hehe yes, you love shadowing :)
23:54:35 <lpsmith> adamt, I'm not sure what you mean :)
23:55:12 <adamt> lpsmith: nevermind :P
23:55:18 <lpsmith> in some sense  (fix id) is undefined
23:55:23 <lpsmith> but it doesn't throw an exception
23:55:31 <lpsmith> actually I think that does
23:55:44 <lpsmith> err, not
23:56:03 <lpsmith> GHC's loop detection is not very good,  I've not investigated it closely
23:56:17 <lpsmith> of course,  it *can't* be all that good.
23:58:01 <lpsmith> plat0, in my opinion,  warning about shadowing should be the job of the Version Control system,  one that understands the lexical structure of your program.   If it detects that a new binding interferes with an existing reference,  *then* I want to know.   The problem is that the compiler just doesn't have the information available to detect when shadowing is likely a real problem and when it's likely harmless.
23:59:29 <lpsmith> and warning about shadowing otherwise is just asinine.
