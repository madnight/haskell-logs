00:01:51 <Cale> The important thing, in my eyes, is that fst, snd, assocL, assocR, and swap are lifted into the arrow, and the library author has control over them. They let you replace the use of arr in desugaring the arrow syntax.
00:02:19 <Cale> (except in the case where more complicated expressions occur to the right of -< in which case you really want arr)
00:02:21 <zzo38> dmwit: I wanted to know that too; what is the condition? For applicatives we would use   zip = liftA2 (,)   where I have used    liftPair = uncurry $ liftA2 (,)    as a definition for applicatives
00:03:30 <Cale> (and well, this extend/retract/forget business is a refinement of that)
00:04:48 <Cale> Also note that there can be Arrows in this system which are incapable of duplicating results (so each result is used at most once) or forgetting information (so everything produced needs to be consumed by something else)
00:08:27 <orzo> is there a haskell library for parsing STL 3d mesh files?
00:11:07 <dmwit> orzo: We have the same package-searching tools available that you do...
00:11:45 <dmwit> Bleh, "same" is not symmetric. You have the same package-searching tools available that we do.
00:22:37 <zzo38> Is (pure mempty) and (liftA2 mappend) forming a monoid a sufficient applicative law?
00:22:51 <zzo38> (together with the functor laws)
00:28:21 <zzo38> (and the parametricity laws)
00:29:58 <zzo38> I would like to instead define the tensor categories and those things using http://hackage.haskell.org/packages/archive/data-lens/2.10.0/doc/html/Control-Category-Product.html and then have another class   class Tensor c => Fanout c where { fanout :: c x (x, x); }; f &&& g = (f *** g) . fanout;    but then I like to add your extend and retract as well
00:34:01 <Pseudonym> OK.
00:34:13 <Pseudonym> After much mucking around, I've finally got the free theorem for (***).
00:34:29 <Pseudonym>   x >>> (arr f) = (arr g) >>> y
00:34:29 <Pseudonym> =>
00:34:29 <Pseudonym>   z >>> (arr h) = (arr k) >>> u
00:34:29 <Pseudonym> =>
00:34:29 <Pseudonym>   (x *** z) >>> (arr ($map_Pair f h)) = (arr ($map_Pair g k)) >>> (y *** u)
00:34:43 <Pseudonym> Note that $map_Pair f g (a,b) = (f a,g b)
00:35:05 <zzo38> Have you also think of categories having objects of kinds other than * kind?
00:35:19 <Pseudonym> It's left as an exercise to see if any of the axioms involving (***) can be derived from that.
00:35:59 <Pseudonym> On that no0te, I'm off.
00:36:02 <Pseudonym> Nytol!
00:58:50 <sopvop> There is old-locale module, but where is locale module?
00:59:00 <sopvop> package
00:59:11 <gienah> sopvop: does not exist, there is only old-locale
00:59:59 <sopvop> Oh, locale was prematurely deprecated? :)
01:00:23 <gienah> sopvop: yeah, no one has got around to writing locale yet :-)
01:00:38 <sopvop> what is wrong with old one?
01:02:03 <gienah> sopvop: I'm not sure (although personally I think its silly because it only has one locale for the entire process, not separate locale for separate threads)
01:03:24 <gienah> sopvop: actually I'm not sure about that
01:03:24 <sopvop> http://hackage.haskell.org/packages/archive/old-locale/1.0.0.4/doc/html/System-Locale.html there is just a datatype and default constructor there. It does not do anything.
01:09:29 <mietek> vty-ui has some of the best library documentation I've ever seen
01:12:27 <ion> Was it made by edwardk?
01:13:34 <x26s> Hello people
01:13:48 <Blkt> hi
01:13:49 <x26s> anyone willing to advise a newcomer?
01:13:57 <x26s> Hi Blkt
01:13:58 <zzo38> Why is the left Yoneda called contravariant?
01:14:28 <x26s> Dunno anything about programming
01:14:45 <x26s> but have to learn a language for scientific computations
01:15:03 <x26s> and maybe build softwares for that purpose
01:15:17 <zzo38> x26s: Then you must learn.
01:15:18 <x26s> Is Haskell a good solution?
01:15:36 <x26s> I have been learning matlab by myself
01:15:40 <x26s> c too
01:15:54 <zzo38> Any of these programming languages will work
01:16:00 <x26s> but i thght of asking some experts which is the best
01:16:16 <x26s> work fine.... but hassles
01:16:21 <x26s> i want the least one
01:16:38 <x26s> zzo38.... whats your opinion
01:16:48 <x26s> want to hear
01:16:52 <x26s> anything is fine
01:16:55 <zzo38> x26s: It depends much on exactly what you are doing. Such as, what kind of scientific computations?
01:17:17 <x26s> i am trying to track cells on 2D and 3D surfaces
01:17:31 <x26s> i have co-ordinates of cell tracks now
01:17:45 <x26s> got to calculate parameters
01:17:55 <x26s> thats one example
01:18:07 <x26s> say tracking particles
01:19:01 <x26s> will haskell be equal to matlab? or better even?
01:19:16 <x26s> i have to stop using matlab soon
01:19:28 <x26s> license issues
01:19:43 <x26s> zz038 u still there?
01:19:46 <zzo38> Not knowing much about these things, I do not know. However, I do not recommend matlib simply due to nature of proprietary software, such as license issues, like you said.
01:20:01 <x26s> replacement?
01:20:07 <ehamberg> x26s: you should probably start using what your peers are using, at least to begin with.
01:20:11 <mm_freak> x26s: haskell has some performance impact on numerical computations…  it does reach near C speeds, but doesn't quite outperform C
01:20:15 <zzo38> To me those license issues are good enough reason not to use it
01:20:42 <mm_freak> x26s: most of haskell is BSD-licensed
01:20:43 <x26s> Thnx friends!
01:20:43 <ehamberg> x26s: you could also have a look at octave which is highly matlab-compatible.
01:20:46 <mm_freak> i.e. free
01:20:52 <mietek> itemad: Stefan O'Rear, Corey O'Connor
01:20:58 <x26s> which is the best replacement opensource for matlab
01:21:05 <mietek> Oops
01:21:07 <mietek> Actually
01:21:07 <ehamberg> x26s: probably octave.
01:21:12 <mietek> ion: Jonathan Daugherty
01:21:51 <zzo38> There is also FORTRAN for scientific computations
01:21:57 <x26s> thnx ehamberg! i was looking for octave. couldnt figure out how to install for win
01:22:14 <x26s> mietek: ion and itemad?
01:22:20 <t7> is uninstalling the haskell platform gonna remove all the cabal bins?
01:22:33 <x26s> zz038: is fortran good?
01:24:02 <t7> it didnt!
01:24:06 <zzo38> x26s: I have never used it myself. You can find some information on Wikipedia.
01:24:43 <x26s> :). thats my next step zzo38.
01:24:47 <x26s> OK ppl! thanks a lot for the reco.
01:24:49 <t7> x26s: FORTRAN is very good
01:25:48 <x26s> thnx t7
01:25:56 <yitz> t7: never thought i'd hear anyone recommending a 1950s imperative programming language in this channel (i know, not the same as then, but still...)
01:26:32 <hpaste> teneen pasted “test” at http://hpaste.org/69581
01:26:36 <teneen> Why does this simple function never terminate?
01:26:41 <x26s> yitz, is it still used?
01:26:48 <yitz> x26s: yes
01:28:07 <t7> any type theory wizards in here?
01:28:30 <zzo38> t7: Just ask your question, if you have one
01:29:34 <t7> can I infer type application (specification?) in system F when using application
01:29:55 <t7> i feel like i should be able to, but its a hunch
01:30:09 <merijn> yitz: Really? I would expect an unusually high concentration of Lisp hackers in here :p
01:30:35 <t7> merijn: bravo
01:31:27 <merijn> As for FORTRAN still being used, I happen to know at least one nuclear power plant here is still running on FORTRAN77 >.>
01:31:40 <x26s> is this chat available only on browser?
01:31:44 <zzo38> Looking at the Type-Indexed Records proposal, it looks similar to something I have implemented in the "extensible-data" package; it allows records where the keys are arbitrary types (although my implementation requires the keys to also be Typeable).
01:31:50 <zzo38> x26s: No, it is IRC
01:31:56 <Axman6> x26s: no, this is IRC, you just need an IRC client
01:32:02 <merijn> (And I believe Mathematica, MatLab and A LOT of scientific research is done using Fortran)
01:32:11 <yitz> merijn: haha
01:32:42 <orzo> i'm trying to do simple stuff with parsec and i have the sense that i can describe a parser while letting a lexer ignore unimportant whitespace for me, but I can't seem to see how to do that without adopting "haskellDef" entirely, whatever that is.
01:32:48 <x26s> Does haskell installation include an irc client?
01:32:48 <t7> zzo38: did my question make sense?
01:33:15 <Axman6> no
01:33:24 <zzo38> t7: I do not understand it, so I don't know
01:33:37 <merijn> x26s: No, IRC is a very well-known and old (for given values of old) chat system. You can find out more by just googling for IRC or going to http://freenode.net/faq.shtml
01:33:52 <merijn> x26s: There should be a bunch of free IRC clients for any OS you can think of
01:34:14 <x26s> how do i come to this room again?
01:34:25 <x26s> from the client
01:34:34 <x26s> very helpful people here
01:34:44 <xraycat> irc.freenode.net #haskell
01:34:52 <x26s> ok thnx
01:34:53 <merijn> x26s: You join the #haskell channel on the freenode network. The servers for freenode are listed on the link I just gave you. How to join the channel depends on your IRC client
01:35:05 <zzo38> You need the port number as well; there is more than one port number available to choose from
01:35:27 <zzo38> (For example, I am currently connected on port 6666)
01:35:29 <quicksilver> in general, you do not need to choose the port number.
01:35:42 <quicksilver> freenode uses the same port number as every other IRC server I have ever used
01:35:54 <quicksilver> and in 20 years of IRC I've never had to configure a port number on an irc client.
01:36:21 <x26s> best irc client reco please
01:36:26 <x26s> recommendation
01:36:28 <zzo38> quicksilver: Freenode supports many port numbers, but not the standard
01:36:37 <xraycat> x26s: I always liked irssi
01:36:37 <dmwit> "best" is subjective
01:36:48 <zzo38> x26s: I use one I wrote myself but it might not be best for you
01:36:56 <x26s> :)..its ok... i value all your opinion
01:37:02 <x26s> dmwit
01:37:28 <zzo38> I happen to like PHIRC, but there are many IRC clients available choose what best for you
01:37:32 <dmwit> I use irssi. But if you're on Windows, or just want something that's beginner-friendly, that's not going to cut it.
01:37:46 <teneen> Can some one help me with this function http://hpaste.org/69581? Why do unboxed arrays don't work in such situation and boxed arrays work just fine?
01:37:57 <quicksilver> zzo38: not the IANA standard, perhaps, but the de-factor standard which all the clients I've ever used have had pre-configured.
01:38:01 <x26s> ok thnx
01:38:51 <dmwit> teneen: You're making essential use of laziness in that algorithm.
01:38:59 <merijn> x26s: Depends on your OS, although something like Xchat runs on all the big ones (I think?) and should be fairly newbie friendly
01:38:59 <dmwit> Boxes and laziness don't go together.
01:39:17 <zzo38> My IRC client allows both the host name and the port number to be omitted but it doesn't always work
01:39:58 <zzo38> But it works if you are running a IRC server on your own computer listening on port 194, which I do have, so it works for me
01:40:19 <teneen> dmwit: Should the array be computed sequentially? by the time it demands cell n, cell (n-1) is already computed?
01:40:37 <teneen> dmwit: shouldn't **
01:40:50 <dmwit> I very much doubt that's a promise of the UArray interface.
01:41:02 <dmwit> You could look at the implementation and see for yourself what it does, though.
01:41:09 <x26s> ok thnx
01:42:26 <womb> Hi!
01:44:27 <dmwit> teneen: It seems to be using the strict ST monad.
01:45:29 <teneen> dmwit: I wonder why the ST monad is used at all
01:45:56 <zzo38> : Have you seen PHIRC? It is the IRC client I use.
01:46:19 <dmwit> teneen: How would you implement it?
01:48:24 <x26s> zz038 link please
01:48:59 <x26s> btw what is this servers address? xchat requires me to input
01:49:24 <miogaruna> x26s: irc.freenode.net
01:49:50 <x26s> is that enough to come to this room?
01:49:53 <x26s> haskell?
01:50:11 <dmwit> No, you will also need to join the #haskell channel after that.
01:50:11 <zzo38> x26s: You also need  JOIN #haskell
01:50:14 <merijn> x26s: Once you connect you probably have to type "/join #haskell" to join
01:51:31 <teneen> dmwit: is GHC.ST strict?
01:51:57 <x26sss> ok.. i think i did it
01:52:04 <x26sss> yeah!
01:52:05 <miogaruna> x26sss: you made it.
01:52:08 <x26sss> Thanks friends
01:52:14 <x26sss> had to add an extra s
01:52:15 <x26sss> lol
01:52:22 <dmwit> teneen: yes =)
01:52:59 <x26sss> Ok..... From now I am a regular here
01:53:09 <x26sss> can we get a permanent id?
01:53:14 <yitz> > "x26" ++ repeat 's'
01:53:16 <lambdabot>   "x26sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss...
01:53:17 <teneen> dmwit: I see
01:53:20 <x26sss> :)
01:53:31 <x26sss> actually i am 26s
01:53:40 <teneen> dmwit: But would it have worked if the lazy ST monad was used instead?
01:53:41 <x26sss> thought numbers would be rejected
01:53:50 <ion> “/msg nickserv help” to reigster your nick.
01:53:54 <dmwit> teneen: No, because then you would get a boxed array. =)
01:53:54 <ion> +typos
01:54:01 <merijn> x26s: The freenode.net site has details on how to register your nickname and assorted other information
01:54:49 <zzo38> For register your nick you use   NS REGISTER   command, read    NS HELP REGISTER   for information.
01:54:56 <dmwit> teneen: Laziness happens by having a pointer to some code.
01:55:01 <dmwit> teneen: That pointer is called a box.
01:55:29 <x26s> Here I am
01:55:38 <x26s> back with my id
01:56:07 <dzhus> what is the best way to have two-dimensional mutable arrays in Haskell?
01:56:08 <ion> You can change your nick with the /nick command.
01:56:41 <dmwit> dzhus: Use {IO/ST}[U]Array (a,b)
01:56:47 <dmwit> where a and b are the types of your two dimensions.
01:56:58 <dmwit> Typically (Int, Int), though of course that's up to you mostly.
01:57:15 <zzo38> There are many other commands in IRC. Issuing the HELP command to the server will list some of them.
01:57:21 <x26s> where to enter it?
01:57:37 <dca`> dmwit: and what's the storage of elements? row order?
01:58:05 <zzo38> x26s: I don't know much about that IRC client
01:58:06 <x26s> NICK <26s>
01:58:12 <teneen> dmwit: What if I want the values in the array to be computed sequentially, but without pointers?
01:58:35 <dmwit> dca`: I'm not sure. If it's important to you, perhaps you could look at the source of the (Ix a, Ix b) => Ix (a,b) instance.
01:58:36 <x26s> later maybe
01:58:52 <x26s> ok back to programming version
01:59:00 <hpaste> merijn pasted “when, lenses and StateT” at http://hpaste.org/69583
01:59:03 <zzo38> x26s: I don't know XChat
01:59:03 <dmwit> teneen: You should probably create an STArray manually, then.
01:59:14 <x26s> whats this ctcp version?
01:59:15 <dmwit> teneen: And then freeze it.
01:59:45 <teneen> dmwit: I'll have to use mutation then?
01:59:46 <zzo38> x26s: It is a command to ask a remote client what client program it is using
01:59:47 <merijn> Style question, best way to write 1 line when in the example I just pasted?
02:00:04 <zzo38> It isn't a server command, so it won't be mentioned in the server help file
02:00:07 <dmwit> teneen: Correct.
02:00:23 <x26s> zz038 want to try PHIRC... cant find it online
02:00:49 <dmwit> merijn: I guess there's "void" or "ignore" or whatever it's called.
02:00:58 <dmwit> oh, you already have that
02:01:11 <x26s> is it for windows?
02:01:12 <merijn> dmwit: Yeah, that's what I just had as second example. I was just asking about opinions on readability
02:01:54 <merijn> I don't really like the bogus "return ()", but I'm not sure the void one is more readable like that
02:01:58 <dmwit> It's a bit annoying that when is so monomorphic, isn't it?
02:02:02 <zzo38> x26s: You need to install PHP first, and then http://zzo38computer.cjb.net/prog/PHIRC/phirc.zip
02:02:10 <zzo38> You also need to install PuTTY
02:02:11 <dmwit> I think it's possible I might write when_ and use that instead. =)
02:02:23 <merijn> dmwit: Actually, probably a good idea
02:02:31 <merijn> zzo38: Now I'm sad...
02:02:33 <dmwit> or modify += to not return anything
02:02:42 <dmwit> merijn: (What is it returning, anyway?)
02:02:48 <merijn> dmwit: Yeah, but += is a built in of data-lens
02:03:06 <zzo38> merijn: Then be happy.
02:03:10 <merijn> It updates the value of the lens on the left and returns the result
02:03:55 <merijn> Which is nice (in a general purpose sense), just inconvenient in my specific when example
02:04:04 <dmwit> right
02:04:26 <zzo38> x26s: It might be difficult to understand though
02:04:49 <navaati> :t when
02:04:50 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
02:05:02 <x26s> hmmm....
02:05:04 <zzo38> x26s: O, you also need  http://zzo38computer.cjb.net/prog/PHIRC/help.txt
02:07:01 <merijn> I think I'll just go with: when_ b = when b . (>> return ())
02:07:16 <dzhus> I assume Array is for regular arrays? What if I have a fixed-length dim1-list of *growable* dim1-lists and I want to efficiently add a new element to k-th growable list in my fixed 1-dimensional array?
02:07:46 <zzo38> merijn: I prefer   (() <$)
02:07:55 <merijn> :t (<$)
02:07:56 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
02:08:18 <merijn> zzo38: Yeah, but then I need to put both a Monad and Functor restriction on it
02:08:44 <x26s> zz038... downloaded. will check it later. thanx
02:09:02 <zzo38> merijn: I know. I always put both Monad and Applicative on most things that use Monad
02:13:35 <zzo38> Can you make a monad from (f x -> x) when f is contravariant?
02:15:05 * hackagebot generic-deriving 1.2.1 - Generic programming library for generalised deriving.  http://hackage.haskell.org/package/generic-deriving-1.2.1 (JosePedroMagalhaes)
02:17:28 <zzo38> Does   data LeftCoT m f x = forall z. LeftCo (f (m z) -> x) (f z);    makes a comonad?
02:22:05 <t7> which glfw package is best?
02:26:35 <hpaste> merijn pasted “Another style question” at http://hpaste.org/69584
02:26:46 <merijn> More useless style questions :>
02:32:04 <hpaste> mgsloan annotated “Another style question” with “Another style question (annotation)” at http://hpaste.org/69584#a69585
02:40:39 <miogaruna> #haskell, a quick question,
02:40:45 <miogaruna> how I would implement a function that takes a list of strings of varying length, and returns a list of strings that all the same length, with the shorter strings left-padded with spaces?
02:40:59 <t7> type it in vim
02:41:08 <t7> miogaruna: loop through and get the max length
02:41:15 <t7> then loop again and pad
02:42:12 <ion> > (maximum . map length) [ "foo", "barbaz", "quux" ]
02:42:14 <lambdabot>   6
02:42:33 <miogaruna> t7: guess there's no elegant once-pass recursive method then. This'll do, though, thanks!
02:43:10 <t7> not without quantum computers
02:48:02 <blackdog> i think i'm missing something obvious. if i'm wrapping a native C library, how do i bake the path to that .so into the cabal config?
02:48:53 <blackdog> extra-libraries lets me tell cabal that i need libfoo, but what if libfoo.so is somewhere silly?
02:50:58 <Lemmih> Give linker options?
02:52:47 <blackdog> to answer my own question: --ghc-option=-optl-Wl,-rpath=/usr/local/lib
02:54:09 <navaati> what is the trick to make "type lambdas" ? Making a type synonym doesnt work… I want to create an instance for a type that would look like "\b -> A a (C b)"
02:55:32 <Saizan> newtype
02:55:50 <navaati> eh…
02:56:13 <navaati> no way without newtypes ? i absolutely don't want to wrap my arrows
02:56:24 <blackdog> Lemmih: yeah, i just thought there might be a less punctuation-heavy method.
02:56:42 <Saizan> blackdog: --extra-lib-dirs ?
02:57:00 <Saizan> navaati: nope
02:57:15 <navaati> huge big shit…
02:57:58 <navaati> not even some ancient dark sorcery secret trick ?
02:57:58 <navaati> /me still has hope…
03:01:02 <navaati> hum, sometimes haskell is even more frustrating than java…
03:05:10 * hackagebot digestive-functors-snap 0.4.1.0 - Snap backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-snap-0.4.1.0 (JasperVanDerJeugt)
03:05:11 <quicksilver> navaati: there are good reasons for needing to use a newtype like that.
03:05:35 <quicksilver> you need the explicit wrap/unwrap too keep sensible notions of principal type and inference.
03:06:58 <donri> typeclassopedia says io monad is magical, but is that really true?
03:07:30 <Kashyap_> Hi folk .... can someone please point me to a good resource to understand the power of lazy evaluation in a real world setting ... I've gone over John Huges paper ..... What I am looking for is something that a regular Java/CPP programmer would appreciate . ... Something in the lines of parsing, making your own control structures - EDSLs
03:08:33 <ocharles> Kashyap_: tbh, I think to really "get" it, you need to have first hand experience
03:09:05 <donri> Kashyap_: imagine if operators didn't short-circuit in java/cpp
03:09:24 <donri> boolean ones, i mean
03:11:31 <Kashyap_> ocharles ... I agree ... I have tried the standard examples of primes, square root etc and struggling to conjure somethig real .. this could be because I've not fundamentally got the idea....would you have ideas what I could try
03:12:20 <Kashyap_> dnori -- okay ... you mean .. if both operands would be evaluated nevertheless?
03:12:33 <donri> yep
03:13:56 <Kashyap_> dnori ... right, so ... what if I say that I can get around it by passing function pointers .....
03:15:21 <donri> sure, but which version will be more succinct and readable? maintainable and friendly to refactoring?
03:15:33 <HugoDaniel> hello
03:15:56 <merijn> Kashyap_: I think laziness can make a lot of sense in the context of first class IO/error handling
03:16:50 <Kashyap_> donri ... clearly without the function pointer :)
03:17:07 <Kashyap_> merijn ... could you give an example please
03:18:01 <donri> laziness doesn't magically make things possible otherwise impossible... you can simulate the effect of infinite lists with simple C structs
03:18:35 <donri> but it does tend to allow for writing things succinctly and encourages modular code
03:19:14 <Kashyap_> dnori .. which is extremely valuable .... considering the cost (in terms of dollars and pain) of maintenance of software
03:19:47 <donri> it does come at a cost though, in particular it can make it harder to reason about performance
03:21:12 <Kashyap_> dnori ... hmmm ... so  can I have a couple of examples that can illustrate the clean implementation with laziness vs not so clean due to lack of in built support for it
03:21:54 <donri> i don't really have such examples handy :) just talking from personal experience
03:22:09 <donri> and from what i've heard others say
03:23:12 <Kashyap_> clearly, the short circuiting behaviour of operators is a strong plus ... that is ofcourse already there in C etc ...
03:23:56 <Kashyap_> Thanks donri ... this was helpful
03:24:14 <donri> ruby folk like to show examples like "5.times do puts "hi" end", in haskell due to laziness and first-class IO we can do "replicateM_ 5 (putStrLn "hi")" without the need to wrap it in a "block" or function or whatever
03:24:22 <merijn> Kashyap_: Yes, but it does mean you cannot implement your own new operators in C
03:24:31 <merijn> Kashyap_: Where as this *is* possible in haskell
03:25:16 <donri> Kashyap_: in deed; the point is, that applies to the whole of haskell... and once you get used to it, writing in an eager language feels like having to write the code you suggested with function pointers
03:25:46 <merijn> Kashyap_: One thing that I've seen a bunch of times is that instead of needing to pass a file handle throughout your code and calling "read" on that you can just pass "IO String" values around and use those, ignoring what the IO actions reading the string actually does
03:26:40 <merijn> So if you want to suddenly support sockets or some other abstraction, that's no problem. Just pass the IO String around as normal
03:27:10 <merijn> In other languages you have to implement a wrapper object that replaces the file descriptor with something that hides whether there is a file, socket or whatever
03:28:03 <Kashyap_> merijn - hmmm, on Unixs wouldn't a fd with read/write achieve that abstraction?
03:28:05 <donri> typically some kind of iterator interface, which in haskell is just a list (and strings are lists of chars)
03:28:29 <merijn> Kashyap_: No, sockets aren't file descriptors and it certainly wouldn't work on windows
03:28:50 <merijn> Kashyap_: You can partially use them the same, but the setup is different
03:29:05 <sipa> sockets are file descriptors on unix...
03:29:13 <merijn> (Actually, they might be implemented as file descriptors in the sense that they share numbers in the file des table
03:29:25 <sipa> not every file descriptor is a socket, but all sockets are file descriptors
03:29:26 <merijn> I guess I meant sockets aren't files
03:29:43 <Kashyap_> right ... merjin ... I get what you are saying
03:29:44 <sipa> file descriptors are also used for pipes, devices, ...
03:30:05 <donri> again, laziness just makes things neater, not "suddenly possible"
03:30:12 <Kashyap_> and donri .... I get the idea your ruby example
03:30:45 <Kashyap_> donri ... I had a recent email thread on the cafe where I realized that aspect - of laziness making things neater
03:31:47 <Kashyap_> My boss has asked me to make a presentation to the rest of the folks about Haskell ... so I want some compelling real world examples of "really neat" codes that would look really convoluted in your regular languages
03:32:29 <donri> it is also said that laziness "keeps you honest" about referential transparency where order of execution/evaluation shouldn't matter
03:32:42 <merijn> Kashyap_: If they know python it might help to draw a parallel between lists being lazy and for example generators
03:32:48 <donri> but that's mostly only relevant to functional programming
03:33:00 <Kashyap_> donri - that's a good point
03:33:16 <donri> Kashyap_: well if you're talking about haskell in general... there's much more to haskell than laziness
03:33:17 <Kashyap_> merjin ... I want to be able to contrast C and Haskell
03:33:38 <donri> needs moar qsort comparisons ;)
03:33:50 <t7> seems a bit overkill using sha1 just to get pseudo  random colours, but im doing it
03:34:14 <Kashyap_> donri :) that's the kind of examples I want to avoid ... I mean, fibonacci, factorial etc
03:34:51 <t7> i can seed haskell random right...
03:34:53 <donri> but the fib function is critical to any application!
03:34:54 <t7> i should just do that
03:35:18 <Kashyap_> donri - are you serious?
03:35:42 <Kashyap_> donri ... I am talking about - run of the mill software development
03:36:09 <donri> i'm joking
03:36:27 <Kashyap_> :)
03:37:32 <donri> i think the origin of the joke was people writing fib in node.js for benchmarking purposes and someone noting that fibonacci generating web applications are ever so common
03:37:54 <gaoyc> this site is amazing
03:38:00 <Kashyap_> oh okay
03:38:14 <donri> gaoyc: tryhaskell?
03:38:32 <Kashyap_> merijin : could you please elaborate on your python list thing
03:38:36 <gaoyc> yes, just see it
03:38:58 <donri> gaoyc: :) most people in this chat are not connected via that site
03:41:25 <Kashyap_> okay .. donri, merijin ... I am going to scoot now ... in case there is something that you can think of more - please do shoot me an email at ckkashyap@gmail.com
03:41:52 <gaoyc> the tutorial is great, i know java and python, some guy say function programming is future, :-)
03:42:27 <Axman6> functional programming* ;)
03:42:45 <conor_f> learnyouahaskell.com?
03:43:31 <gaoyc> oh, sorry, i'm chinese, has other know chinese
03:44:04 <fmap> future?
03:44:10 <fmap> i thought fp is already here
03:44:48 <donri> well, the free lunch is over; that's why fp is the future
03:45:06 <gaoyc> but there are few people can write program in haskell
03:46:06 <donri> yet this is one of the biggest channels on this chat network
03:49:45 <conor_f> bleh
03:49:51 <conor_f> haskell is hard
03:50:06 <merijn> Kashyap_: In Python you (or at least me and the people I know) you many generator expressions instead of lists. The reason behind this is that generator generate values on demand, so they take up a small (fixed) amount of space
03:50:20 * hackagebot snap-blaze 0.2.1.0 - blaze-html integration for Snap  http://hackage.haskell.org/package/snap-blaze-0.2.1.0 (JasperVanDerJeugt)
03:50:22 <conor_f> No problem specifically, just need to learn more. I'll be back at some stage :P
03:51:05 <merijn> Kashyap_: As a result you consume a fixed amount of memory rather than obscene amount when working with long lists. This behaviour is similar to haskell's lists being generated/computed on demand
03:51:46 <Kashyap_> Thanks Merijn
03:56:28 <hiptobecubic> j/ #python
03:56:47 <hiptobecubic> DISREGARD THAT. NOTHING TO SEE HERE
03:57:08 <HugoDaniel> lol
03:57:13 <kstt> hi, can map lenses of data-lens be used to update deep maps (maps of maps ...) please ? I tried a naive '(mapLens foo >>> mapLens bar) ^= foobar' but that does not seem to be the way
03:57:14 <HugoDaniel> infidel!
03:57:50 <donri> kstt: i think you'd need to use PartialLens
03:58:11 <hiptobecubic> i thought the point of lenses as arrows were that they were composable?
03:58:19 <donri> since a key may be missing, mapLens is a lens into Maybe
03:58:23 <HugoDaniel> i wish i could understand arrows
03:58:33 <HugoDaniel> but my little mind is too small for arrows
03:58:34 <donri> which doesn't compose with non-Maybe lenses
03:59:13 <kstt> indeed
03:59:19 <merijn> Don't you want (.) for composing lenses?
03:59:20 <hiptobecubic> but the whole thing will be a maybe in the end
03:59:23 <donri> but this is exactly what partial lenses are for
03:59:59 <donri> hiptobecubic: yes but the "input" will be a Maybe x rather than an x
04:00:01 <merijn> I actually made my own map lens with a default value
04:00:07 <kstt> f >>> g = g . f
04:00:09 <merijn> To avoid this problem :p
04:00:29 <donri> HugoDaniel: lenses aren't arrows AFAIK
04:00:45 <HugoDaniel> hmm ok
04:00:50 <HugoDaniel> i also don't know what lenses are
04:01:14 <merijn> HugoDaniel: Lenses are a nifty way to have composable updates (getters/setters)
04:01:18 <kstt> merijn: could you show me what you did please ?
04:02:14 <hpaste> merijn pasted “mapLens with default” at http://hpaste.org/69586
04:02:50 <donri> kstt: without partial lenses you'd need to do something like, mapLens foo ^%= fmap (mapLens bar ^= foobar)
04:02:52 <merijn> Basically, since it uses "findWithDefault" it will return that default value when a case isn't there, which means you avoid the need for Maybe
04:02:58 <kstt> thx
04:03:20 <merijn> Which may not be suitable in all usecases, but for me it works very well
04:03:32 <donri> sadly data-lens-fd doesn't support partial lenses yet, and i'm guessing you're using this with acid-state
04:03:39 <kstt> ah, indeed
04:04:05 <kstt> Haddock partial lens is just a bunch of signatures
04:04:07 <merijn> HugoDaniel: One of the problems with record syntax is that if I have a record data type within a record datatype there is not convenient way to update a field on that inner value
04:05:03 <HugoDaniel> yeah true
04:05:04 <HugoDaniel> :/
04:05:12 <merijn> HugoDaniel: So a "Lens a b" provides a getter+setter that will set a field of type b in datatype a. With the nifty addition that you can compose "Lens a b" and "Lens b c" to create a "Lens a c" letting you get/set on the inner value without all the hassle
04:05:17 <kstt> So I can't really figure the point behind that. I could certainly medidate on the types, but I don't feel motivated enough at the moment, so I will certainly take the easy way :)
04:05:28 <donri> kstt: well you'd use totalLens to turn a mapLens into a PLens
04:07:05 <donri> do st <- get; put $ totalLens (mapLens foo) >>> totalLens (mapLens bar) ^= foobar
04:07:07 <donri> something like that
04:07:17 <donri> do st <- get; put $ totalLens (mapLens foo) >>> totalLens (mapLens bar) ^= foobar $ st
04:07:20 <donri> more like.
04:07:29 <kstt> ok thank you
04:08:08 <donri> mapPLens = totalLens . mapLens -- might clean that up a bit
04:09:57 <donri> get >>= put $ totalLens (mapLens foo) >>> totalLens (mapLens bar) ^= foobar  -- do-notation is over-rated
04:10:25 <ocharles> If I have something like Foo { bar = Bar { baz } }, and I want baz to actually be the result of a monadic action, can that be done in applicative manner, or is this a lens thing too?
04:10:30 <ocharles> or is this in fact exactly what you're talking about? :)
04:11:21 <merijn> ocharles: You can definitly do that with a lens in an applicative manner
04:11:26 <donri> Foo <$> (Bar <$> baz)
04:11:33 <donri> duno if parens are needed
04:11:40 <merijn> fmap (setL myLens val) foo
04:11:54 <merijn> donri: Doesn't work if he has multiple named fields
04:12:00 <merijn> I think?
04:12:05 <ocharles> donri: yea, i was hoping for record syntax
04:12:06 <ocharles>  
04:12:17 <ocharles> it's annoying having to remember the order of initialization
04:12:33 <donri> if you want record syntax, you can't have applicative or lenses
04:12:33 <ocharles> but that's the only way applicative can work anyway I guess
04:12:40 <merijn> ocharles: data-lens has a functional API, so I don't see why you couldn't fmap that
04:12:51 <merijn> donri: uh what?
04:12:51 <donri> though with lenses you can still get the sense of "named fields"
04:13:07 <merijn> You can still use record syntax just fine with lenses
04:13:22 <donri> not really, you're just "not using the lenses" then
04:13:30 <merijn> Sure
04:14:17 <merijn> Anyhoo, I was assuming "I was hoping for record syntax" just meant "I want named fields" in which lenses are mostly the same as record syntax
04:14:31 <donri> also i'm not sure if my example with <$> works there... wouldn't that mean that "bar" is also a functor?
04:14:55 <donri> merijn: sure
04:15:28 <donri> well. can't really use lenses to construct new values like you can with record syntax...
04:15:31 <merijn> And fmapping the setL will work fine for doing an update on a named field inside Applicative
04:15:43 <donri> unless you use something like undefined or data-default
04:15:52 <donri> but then you're not really constructing "new" either
04:17:02 <ocharles> Can you do Foo{..} - does that create a Foo without initializing any of its fields?
04:17:06 <ocharles> or can you not even set the fields then?
04:17:08 <merijn> donri: I just use record syntax for constructing new values from scratch
04:17:20 <donri> ocharles: i think then they're just initialized to something like undefined?
04:18:07 <donri> > fromJust Just{}
04:18:08 <lambdabot>   *Exception: <interactive>:3:9-14: Missing field in record construction
04:18:54 <ocharles> well you wouldn't use it, you need something that has fields and would initialize the fields first
04:20:12 <donri> ocharles: point is, then you're back to "not new"
04:20:45 <donri> lenses are great for setting/modifying, not constructing
04:22:13 <donri> streampunk?
05:06:47 <lrojas> hi all, hope this question is not too "obvious" to be asked here, Are there any frameworks based on Hasckel, kind of like Rails for Ruby, and any tutorial on "Serving" Applications in said framework ( even if there is no framework, is haskell suitable to build web apps? )
05:09:04 <sopvop> major web frameworks are snap, happstack, yesod. Any can be used for serving apps
05:10:19 <lrojas> sopvop: how do they compare to rails/django ?
05:10:38 <S11001001> lrojas: thank you for including an "even if there is no framework" case; you reaffirm my faith in the future of the art of programming
05:11:01 <lrojas> S11001001: :D
05:13:49 <lrojas> I'm coming from having just enough knowledge in Ruby/Python to be able to pass myself as knowledgable...  but i am intrigued by the Functional Programming Languages... and since i am learning still..
05:14:26 <fmap> @google yesod tutorials
05:14:27 <lambdabot> http://yannesposito.com/Scratch/en/blog/Yesod-tutorial-for-newbies/
05:14:28 <lambdabot> Title: Haskell web programming
05:14:33 <fmap> lrojas: ^
05:14:47 <lrojas> thanks :D
05:16:47 <hpc> lrojas: if all you need is CGI, there's a neat trick that makes writing the html easy
05:16:53 <hpc> wrap open close body = do
05:16:56 <hpc>   putStrLn open
05:16:57 <hpc>   body
05:17:00 <hpc>   putStrLn close
05:17:08 <hpc> html = wrap "<html>" "</html>"
05:17:09 <hpc> ...
05:17:34 <hpc> then your scripts start to look less like an execution from top to bottom and more like
05:17:36 <donri> @hackage blaze-html
05:17:36 <lambdabot> http://hackage.haskell.org/package/blaze-html
05:17:45 <hpc> foo = p $ do
05:17:47 <hpc>   blah >> br
05:17:48 <hpc> ...
05:17:56 <hpc> yeah, also look at blaze
05:18:03 <donri> @where web
05:18:04 <lambdabot> http://happstack.com/ http://snapframework.com/ http://yesodweb.com/
05:18:10 <hpc> imo, blaze tries to do too much though
05:18:14 <donri> those are the main ones for web programming
05:18:28 <donri> hpc: or too little?
05:18:31 <donri> i prefer hsp
05:19:05 <hpc> i like my approach, because it makes "expanding the vocabulary" extremely easy
05:19:20 <hpc> and still lets you write raw html
05:19:35 <frerich> hpc: Hm, that's a neat little trick (the 'wrap' idiom which takes the body argument last, so you can write 'wrap pre post $ do ..'). Thanks for sharing! :-)
05:19:36 <lambdabot> frerich: You have 1 new message. '/msg lambdabot @messages' to read it.
05:19:47 <donri> hpc: blaze-markup? :p
05:19:58 * hpc looks at hsp
05:20:51 <donri> well, docs suck for hsp
05:21:02 <hpc> frerich: yeah, i use it on my website, slightly uglified by exception handling though
05:21:11 <donri> http://www.happstack.com/docs/crashcourse/Templates.html#hello-hsp
05:21:27 <sopvop> lrojas: http://softwaresimply.blogspot.com/2012/04/hopefully-fair-and-useful-comparison-of.html good comparision
05:21:46 <hpc> @isdown happstack.com
05:21:46 <lambdabot> Unknown command, try @list
05:21:51 <hpc> :(
05:21:57 <lrojas> thanks all for the input, much appreciated it... lots of stuff to read
05:22:02 <hpc> oh, it's just huge
05:23:56 <donri> lrojas: if you want something like rails or django (rapid app dev) you're probably interested in yesod. if you want something practical (designer-friendly templates, plugins, sysadmin-friendly configuration) you might want snap. if you want something different and "true to haskell" i say happstack.
05:31:56 <merijn> Isn't Yesod also pretty true to haskell in the "we even type check our generated JS" kind of way?
05:33:01 <donri> no, because they don't really check their generated JS at all: julius is just string interpolation
05:33:23 <merijn> Maybe I'm confusing frameworks then
05:33:39 <donri> well, yesod wants type safety to be their thing but i disagree :)
05:35:25 <donri> happstack prefers jmacro which is at least syntax-checked at compile-time and supports splicing at the AST-level for arbitrary types
05:35:58 <donri> but while there has been some work to add type checking to jmacro it's not usable yet
05:43:33 <Peaker> a bit of a bummer I can't instantiate a type family with a polymorphic type
05:43:44 <Peaker> similarly to instantiating a MPTC with a polymorphic instance
05:45:05 <Peaker> class C e where type TheMonad e ; ... ; getX :: e -> Maybe (TheMonad e)           and I have an instance that can't provide getX, and it doesn't even really have "TheMonad" (but other instances do)
05:54:52 <Peaker> MultiParamTypeClasses are quite more succint than type families, and apparently a bit less restrictive.  I wonder if they're supposed to be phased out in favor of type-families (extra restrictions have their benefits)
05:55:39 <quicksilver> MPTCs on their own are weak.
05:55:52 <quicksilver> you need either FDs or ATs/TFs to make them genuinely useful.
05:56:41 <quicksilver> but I don't think that people would argue for MPTCs to be removed.
05:56:54 <quicksilver> State would be a pain if it wasn't allowed to be multi-parameter.
05:57:09 <illissius> MPTCs and TFs are complementary
05:57:30 <Peaker> MPTC+Fundeps, yeah
05:57:42 <Peaker> illissius, they seem to have huge overlap
05:58:01 <quicksilver> I don't really see them as overlapping.
05:58:01 <Peaker> I take "complementary" to imply little to no overlap
05:58:05 <illissius> Peaker: TFs replace FDs (in theory), but not MPTCs
05:58:13 <illissius> Peaker: where do you see overlap?
05:58:26 <quicksilver> sometimes, with an associated type, you can remove one parameter from the class
05:58:28 <quicksilver> but not always.
05:58:40 <quicksilver> State seems to be a good example of a class with two parameters and you wouldn't want to remove one.
05:58:57 <quicksilver> sorry, MonadState.
05:59:15 <Peaker> illissius, class C a b c    vs.   class C a where type/data B a ; type/data C a ?
05:59:15 <quicksilver> hmm, actually, not such a good example. Maybe you could remove that one.
05:59:17 <frerich> Peaker: I recently saw your message (you were asking about what kind of presentation I was doing for which I'm looking for a screenshot of 'bottle'). I was doing a small internal presentation to a few colleagues about functional programming in general and Haskell in particular, also touching a bit of the tool-ecosystem (profiling, quickcheck, editor support).
05:59:36 <quicksilver> Peaker: but only if a determines b and c
05:59:48 <quicksilver> Peaker: it's quite reasonable to have class C a b c where a does not determine b and c.
05:59:56 <illissius> ...what quicksilver said
06:00:00 <Peaker> frerich, we're very preliminary, not useful yet :)
06:00:32 <Peaker> quicksilver, only when all types are used in every method?
06:00:38 <frerich> Peaker: Understood, but the momentum in Haskell land is quite nice (a lot of innovation as far as I can tell), I wanted to illustrate that :)
06:00:46 <quicksilver> Peaker: yes, indeed.
06:00:47 <illissius> plain MPTCs when none of the parameters necessary determine any of the others, TFs if they do (exactly when you would use FDs)
06:00:52 <illissius> *necessarily
06:00:56 <Peaker> quicksilver, illissius: I am not sure, but I think I stumbled on a case where I can use FD's but not TF/AT's
06:01:09 <quicksilver> it's not really a relation between types if the methods don't mention all the types.
06:01:19 <Peaker> frerich, cool :)  We are devoting about 60-80% of our time to this project for the foreseeable future
06:02:06 <Peaker> illissius, here I use an FD with a flexible instance like:   instance SomeType m where ...    the "m" is polymorphic. I can't do this with AT's
06:02:34 <Peaker> oops, instance Class SomeType m where ...
06:02:42 <Peaker> class Class t m | t -> m where ....
06:04:04 <Peaker> If I could say:  instance ATClass t where type ATMonad t = m    ("m" is polymorphic and never used)   I wouldn't need FD's
06:04:07 <navaati> does repa (hey, this repa 3 seems GREAT !) use llvm's vectorization (or another way of using SIMD instructions sets) ?
06:04:29 <illissius> Peaker: that seems to violate the FD... there should only be one type 'm' for any given 't'
06:05:03 <quicksilver> Peaker: if m is polymorphic and never used, why is it in the class header?
06:05:05 <Peaker> illissius, there is one given m -- the polymorphic "m"
06:05:09 <quicksilver> can't it be left polymorphic
06:05:26 <quicksilver> "the polymorphic m" is not one given m, I don't think
06:05:32 <illissius> Peaker: a bunch of threads on this have coincidentally sprung up at the same time on the mailing lists recently, have you seen them?
06:05:35 <quicksilver> is this a case of using typeclasses to smuggle in higher-rank?
06:06:10 <Peaker> quicksilver, in one instance, it is a specific m, in another, it is not...  the class is used to take 2 similar types and make them both usable by a big bunch of code.  The features not available in one of the types use Maybe/Nothing in the methods they don't support
06:07:04 <Peaker> quicksilver, basically I have a description of a typed PL.  I have a TypedExpression tree,  and each node in the tree has an InferredTypeExpression which is also an expression tree
06:07:28 <Peaker> TypedExpression is a tree of TypedExpressions.  InferredTypeExpression is a tree of InferredTypeExpression.   The former tree nodes each contain a latter tree root
06:07:42 <t7> can i add an IO thing in a list comprehension ?
06:07:58 <t7> like [ (x, random) | x <- [1..20]]
06:08:04 <Peaker> TypedExpression's have features than InferredTypeExpression's doesn't, but I want code that walks both trees similarly, but does not use the features not available in the latter
06:08:28 <dzhus> is there Data.Sequence or any other container with O(1) insertions with mutable interface?
06:08:32 <Peaker> t7, You can make a list comprehension that results in actions that you later "sequence"
06:08:37 <ocharles> t7: look into 'traverse'
06:08:42 <ocharles> (Data.Traversable)
06:08:51 <ocharles> :t traverse
06:08:52 <lambdabot> Not in scope: `traverse'
06:08:57 <ocharles> :t Data.Traversable.traverse
06:08:58 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
06:09:21 <ocharles> so, (a -> IO b) -> [a] -> IO [a]
06:09:27 <ocharles> erm, IO [b]
06:10:54 <Peaker> quicksilver, I'll try to apply your first law of Type Classes and see where it gets me :)
06:11:13 <illissius> Peaker: anyway, there's a big debate or confusion about whether FDs should be used to select types or instances. in the stronger (and I think more theoretically sound) formulation if you have a class C a b | a -> b and you know that C a b and C a c, you should be able to deduce that b ~ c. in other words foo :: (C a b, C a c) => a -> b -> c; foo _ = id should type-check
06:11:54 <t7> @hoogle m a -> m [a]
06:11:54 <lambdabot> Control.Applicative many :: Alternative f => f a -> f [a]
06:11:54 <lambdabot> Control.Applicative some :: Alternative f => f a -> f [a]
06:11:54 <lambdabot> Test.QuickCheck.Gen listOf :: Gen a -> Gen [a]
06:12:01 <t7> @hoogle Int -> m a -> m [a]
06:12:02 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
06:12:02 <lambdabot> Test.QuickCheck.Gen vectorOf :: Int -> Gen a -> Gen [a]
06:12:02 <lambdabot> Test.QuickCheck vectorOf :: Int -> Gen a -> Gen [a]
06:12:06 <illissius> and that's basically how TFs work, which is why the functionality of the two isn't entirely equivalent right now
06:12:06 <Peaker> illissius, I think that's true even if you allow "b" to be polymorphic there, because you can only really have one    instance C a <anything>
06:12:06 <Peaker> (for any given a)
06:13:00 <applicative> > [(x,r) | x <- [1..10] | r <- randoms (mkStdGen 10) :: [Word8]]
06:13:01 <lambdabot>   [(1,15),(2,215),(3,65),(4,220),(5,5),(6,141),(7,7),(8,142),(9,6),(10,6)]
06:13:20 <applicative> t7 ^^ like so?
06:13:24 <illissius> Peaker: going by the above if you have instance C SomeType m, you can deduce C SomeType Int and C SomeType Char, and from there Int ~ Char
06:13:59 <Peaker> illissius, I don't think you can deduce    C SomeType <concrete type>   because <concrete type> /= <polymorphic m>
06:15:33 <illissius> Peaker: if I write class Meaningless a where meaningless :: a -> a; instance Meaningless a where meaningless = id, I can use that with any type I want, can't I? Not just fully polymorphic types.
06:19:03 <Peaker> illissius, yeah, maybe it is more correct to say that the instance is existential than polymorphic
06:19:22 <Peaker> illissius, when you write instance C Concrete a where ..    the instance code cannot assume anything about "a"
06:19:32 <t7> applicative: yes that is ideal :D
06:21:20 <illissius> Peaker: that's true, but that's precisely what lets clients use the instance with any 'a' (because this instance didn't assume anything about it)
06:21:21 <Peaker> evidently, I can do class A a b | a -> b where f :: a -> b  ;;  instance A Int anything where ...                I just have no way of writing "f"
06:21:27 <illissius> Peaker: what do you mean by existential?
06:21:45 <illissius> (I know what existentials are just not in this context :)
06:22:17 <Peaker> illissius, what GHC sometimes calls a "rigid type variable"
06:23:24 <Peaker> I see the difference between universal/existential as the difference between a positive/negative position of the type...   f :: (a : *) -> ...         inside f, "a" is in a positive position, so it is "rigid" (or I would (incorrectly?) say "existential").  Outside of "f", "a" is in a negative position, so it is "polymorphic"/"universal"
06:23:54 <Peaker> f :: (a : *) ->     is a SystemF-like notation for     f :: forall a. ...
06:25:08 <illissius> Peaker: right, the caller of the function chooses the type, the function itself has be able to work with anything it gets
06:25:47 <illissius> *to
06:29:02 <Peaker> illissius, so the instance with "m" is really:   forall m. instance C ConcreteType m where ...  can't use m usefully here ...    So I guess you could say the law you mentioned above is broken, because there are many instances with differing types. I am not sure it causes any trouble, though
06:30:35 <illissius> Peaker: currently it maybe doesn't, because GHC doesn't actually do that kind of deducing
06:32:34 <hpaste> dzhus pasted “How to implement sparse matrices with mutable access to avoid too much GC?” at http://hpaste.org/69592
06:41:19 <mgsloan> Peaker: when you run bottle, do you get anti-aliased fonts?  I don't.  I fixed this by changing the graphics library, here https://github.com/mgsloan/graphics-drawingcombinators/commit/084c78b62f7c20b2eb59ec5bdedaf957bae1b819
06:41:45 <mgsloan> however, for some reason this changed the behavior of the focus widget
06:41:50 <Peaker> mgsloan, cool! I don't have commit rights there, though -- maybe you can send a pull request to luqui/sinelaw?
06:41:52 <illissius> Peaker: I would direct you to https://groups.google.com/forum/#!topic/haskell-cafe/I38UV4B0QVw , in particular starting from Iavor's message
06:41:57 <mgsloan> and the cursor would vanish after a couple of moves
06:42:08 <Peaker> mgsloan, this probably made the font sizes wrong
06:42:09 <Peaker> mgsloan, (the only thing I can think of)
06:42:24 <Peaker> illissius, thanks, will read soon (in the middle of solving the problem I talked about earlier...)
06:42:25 <illissius> Peaker: they're basically debating the same things as we were just now, but are more knowledgeable about it. :)
06:42:29 <mgsloan> Peaker: Thing is, is that it's not really clear that it's a 100% good change
06:42:56 <mgsloan> it makes things look 10x better, but clearly changed its behavior in some way
06:43:53 <Peaker> mgsloan, again, it probably should come along with fixes to the same lib's font size calculations
06:44:06 <mgsloan> ah
06:44:08 <Peaker> mgsloan, I'm guessing the different font types have different size properties, and graphics-drawingcombinators hard-coded its assumptions about the font sizes
06:44:15 <mgsloan> yup
06:44:34 <Peaker> if you can look into the documentation of FTGL regarding how the font sizes behave, you could probably fix it easily.. the drawingcombinators lib is very small
06:46:47 <kqr_> is there a reason functions which can raise exceptions doesn't have their own type? i would feel safer if i knew no function i call can crash the program without the compiler letting me know
06:47:27 <mwcampbell> What is the best way to install a recent version of the Haskell Platform (one with GHC 7.x) on Ubuntu 10.04?
06:47:38 <Peaker> kqr_, you mean "error" exceptions?
06:48:16 <Peaker> kqr_, Basically totality is a difficult problem, and Haskell doesn't try to tackle it.   Getting rid of pure exceptions is not enough -- you'd have to worry about diverging computations and out-of-resource exceptions too
06:48:26 <mgsloan> Peaker: Yeah, I looked into it.  I didn't see any drastic change in the text width info reported while executing bottle
06:48:37 <mgsloan> but for some reason it seemed possible to "kill" the cursor
06:48:39 <kqr_> Peaker, i'm not very well versed with the exception handling of haskell, but the kind of exceptions thrown by, say, division by zero, read, head or !!
06:48:46 <Peaker> kqr_, and to avoid those you have to add significant features to the language to prevent those things, and you end up with a very different language (definitely interesting to research)
06:49:00 <mgsloan> e.g. as if entering one invalid state of the cursor prevented it from ever showing up again
06:49:14 <Peaker> kqr_, yeah, those are "pure exceptions", like the ones from "error"... they are there not because it is a good thing, but because it is very difficult to remove them
06:49:25 <illissius> kqr_: as Peaker said... you can't stop a function from going into an infinite loop, and at that point whether it freezes forever or exits with an error message doesn't make so much difference
06:49:43 <Peaker> kqr_, Code that might fail with an exception like that is said to have "partiality" (it doesn't always have a valid output) and code that doesn't is "total".  Haskell only encourages totality by convention
06:50:02 <kqr_> Peaker, yeah, and i was silently musing to myself it would be nice with enforced totality
06:50:08 <Peaker> mgsloan, Hmm.. that is unlikely -- probably it disappeared
06:50:14 <Peaker> mgsloan, because it was on 0-sized text or so
06:50:28 <mgsloan> yeah, exactly!
06:50:28 <Peaker> mgsloan, and you can bring it back
06:50:32 <kqr_> Peaker, i was thinking it could be as simple as having something similar to the io monad but for functions which can throw exceptions, but i guess it isn't that easy
06:51:02 <Peaker> kqr_, Agda and Epigram are languages that try to tackle totality (among other things) -- but they are not ready for general purpose use yet
06:51:11 <mgsloan> so something that ends up with a width of 0 can't end up animating back up to a larger scale? oh no!
06:51:16 <illissius> kqr_: there are languages like that, but it involves having to prove to the compiler that your function terminates, which is not always so enjoyable
06:51:16 <Peaker> kqr_, what is the type of:   f = f  ?
06:51:34 <Peaker> mgsloan, that shouldn't be the case :)
06:51:44 <Peaker> mgsloan, but maybe there's a bug
06:51:49 <lrojas> hi, another question, i'm about to install the haskell platform for OS X, i'm running Lion and my machine is 64 bits, but on the download page it says that 32 bit haskell is faster in general and only install 64 bits if specific reason to do so... can someone explain?
06:52:11 <kqr_> illissius, right, i didn't realise nontermination counts as partiality
06:52:17 <mwcampbell> I'll rephrase my question: What's the easiest way to install a version of the Haskell Platform with GHC 7.x on Ubuntu 10.04?
06:52:33 <kqr_> Peaker, i would like to say infinite
06:52:45 <kqr_> Peaker, or just any type at all
06:52:58 <cozachk> either sudo apt-get insatll haskell-platform or google haskell platform and download the package from there
06:53:01 <kqr_> Peaker, beacause if you try to evaluate it it can go anywhere
06:53:06 <cozachk> mwcampbell:
06:53:09 <mikeplus64> lrojas: pointers are bigger on 64 bit
06:53:41 <mikeplus64> more stuff to read = slower
06:53:47 <lrojas> mikeplus64: so, even tho my machines is 64bit i should use the 32bit?
06:53:53 <merijn> lrojas: Simple, 64bit pointers are twice as big as 32bit pointers, so you fill your cache faster
06:53:53 <illissius> lrojas: 64 bit pointers take more cache than 32 bit pointers and make haskell run slower; on the plus side they let you address more than 4GB of memory. ergo you should use the 64 bit version if you need to address more than 4GB of memory and the 32bit version otherwise.
06:54:22 <illissius> I honestly have no idea what the situation is wrt compatibility between 32bit and 64bit on OSX though
06:54:32 <lrojas> illissius: cool
06:54:40 <mzero> what's the question on OSX?
06:54:40 <lambdabot> mzero: You have 1 new message. '/msg lambdabot @messages' to read it.
06:54:58 <lrojas> mzero: just wondering wich version should i install on Lion
06:55:14 <mzero> do you have need to work with in-memory data sets greater than 2GB?
06:55:29 <merijn> lrojas: Oh, btw, minor slip up on Lion the path in the ghc script is incorrect
06:55:30 <lrojas> mzero: just learning haskell
06:55:36 <mzero> then install the 32-bit
06:55:49 <lrojas> merijn: what do you mean?
06:55:52 <illissius> lrojas: don't think it matters at all, in that case
06:56:02 <mzero> merijn: which path is incorrect?
06:56:22 <merijn> lrojas: When you install platform it installs a shell script in /usr/bin/ghc which points to /usr/local/bin/gcc (or something), but since Lion gcc is located elsewhere
06:56:37 <merijn> On Lion you should edit that path to point to /usr/bin/gcc
06:56:40 <mzero> MacOS X supports 32-bit architecture programs on all devices and all OS versions
06:57:02 <mzero> merijn: really? which one?
06:57:18 <lrojas> this: http://lambda.haskell.org/platform/download/2012.2.0.0/Haskell%20Platform%202012.2.0.0%2032bit.pkg ?
06:57:44 <merijn> lrojas: It shouldn't really matter (as a beginner) whether you grab 32 or 64bit
06:58:32 <mzero> lrojas: - yes install that
06:58:56 <merijn> lrojas: Do you have Xcode installed already?
06:59:07 <lrojas> yes, and the command line tools
06:59:27 <merijn> ok, then you just install that pkg and edit the path I just mentioned and you should be set
07:00:26 * mzero notes that all you need these days is the command line tools, Xcode is actually unneeded for Haskell Platform (even though it is named "Command Line Tools for Xcode")
07:00:56 <mzero> merijn: I've grepped all the scripts installed in /usr/bin in my master image for Haskell Platform and I don't find reference to /usr/local
07:01:16 <mzero> can you tell me which script on your system ended up with a reference to /usr/local/bin?
07:01:23 <mzero> this would be a major flaw
07:01:29 <mzero> and I'd like to fix it ASAP
07:03:09 <donri> mzero: hey, platform schedule is kind of badly synced with linux distros, any plans there?
07:03:32 <mzero> no one has ever mentioned that before, donri
07:03:42 <merijn> mzero: /usr/bin/ghc, which is correct for everything pre-Lion
07:04:14 <mzero> merijn: perhaps you have the wrong Haskell Platform installed?
07:04:30 <mzero> current HP doesn't mention the location of gcc in /usr/bin/ghc
07:04:47 <donri> mzero: well, we're having some issues with it in fedora because we release a few days before platform so we either have to release a 6 months old platform or ship upgrades post-release
07:04:49 <merijn> mzero: Oh, not sure whether I have the latest yet
07:04:56 <donri> ubuntu should have similar issues, they ship a month before fedora
07:05:17 <mzero> The older HP, 2011.4.0.0 was developed prior to Xcode 4.3 --- note that the locatin of gcc is not controlled by the OS release, but by the Xcode release
07:06:12 <mzero> donri - are you on the HP mailing list? The best thing to do there would be to start a thread about dates vis-a-vis the Linux distros
07:06:19 <illissius> if you have a type 'f g'... you can call them "constructor" and "argument", or maybe "outer" and "inner"; is there anything else you could call them?
07:06:30 <donri> ah, i'm not, perhaps i'll join
07:06:36 <illissius> (or maybe 'f a', rather)
07:06:37 <mzero> if moving the 2012.4.0.0 date earlier by two weeks would help - there is no reason we couldn't agree to do that
07:06:46 <mzero> the current dates were pulled out of thin-air by me
07:06:51 <donri> two weeks would help fedora, but not ubuntu
07:07:26 <mzero> well, let's get that discussion going, and we can see
07:07:27 <donri> next ubuntu is scheduled for late october
07:07:31 <donri> aye
07:07:47 <mzero> and yes, if you are involved in packaging haskell in any way for a distro - you should be on that list - it is low volume except around releases
07:08:21 <donri> i'm not very closely involved, mostly just hang out in #fedora-haskell and chat with the guy who is most active in packaging
07:08:28 <donri> aka. juhp
07:11:41 <statusfailed> Is anyone familiar with the CmdArgs library?
07:12:12 <statusfailed> I recall seeing a module which allowed specification in a sort of 'fluent' style, in between [| and |], but I can't find it
07:12:29 <statusfailed> What do the '[|' brackets mean?
07:12:43 <illissius> template haskell quotes
07:13:23 <statusfailed> And what goes between them? Is it possible to have potentially anything?
07:13:34 <illissius> they take the haskell code between the brackets and turn it into a syntax tree at compile time, which presumably the library then does something with
07:13:48 <statusfailed> So the stuff in between has to be valid haskell?
07:14:02 <illissius> I think it's possible to have any legal haskell expression in there but I haven't played with it much.
07:14:10 <statusfailed> ok, cheers!
07:14:39 <statusfailed> Ah, here's what I was looking for: https://github.com/gregwebs/ParseHelp.hs
07:15:54 <MrMc>  I have 3 functions f g and h and a variable x. They are related such that f takes two parameters (g x) (h x) is there a way of factoring the x
07:16:05 <MrMc> and creating a section?
07:16:31 <statusfailed> MrMc: What's a section?
07:16:57 <ocharles> statusfailed: like (5 +)
07:17:30 <ocharles> MrMc: (g &&& h) x might be right
07:17:33 <ocharles> my arrow-fu is weak
07:17:43 <mzero> @pl \f g h x = f (g x) (h x)
07:17:43 <lambdabot> (line 1, column 10):
07:17:44 <lambdabot> unexpected "="
07:17:44 <lambdabot> expecting pattern or "->"
07:17:56 <mzero> @pl \f g h x -> f (g x) (h x)
07:17:56 <lambdabot> liftM2
07:18:11 <statusfailed> haha :D
07:18:18 <mzero> MrMc: that is you can just write     liftM2 f g h x
07:18:21 <utdemir> Hi. Very newbie here (15 min :)). I'm just trying to write a simple prime checker(just to see, I know it is very inefficient). Here is my pathetic trials: isPrime n = all (\i -> (n mod i) /= 0) (filter isPrime [2..(n div 2)]), but it fails, I think the reason is the n variable in all's first argument. I know I'm not (yet) allowed to write non-pure functions, but how can I achieve this?
07:18:35 <t7> and opengl guys in here?
07:18:40 <t7> i cant get lighting to work :(
07:18:43 <statusfailed> mzero: that's awesome
07:18:49 <MrMc> thanks mzero
07:18:56 <mzero> > liftM2 * (+ 7) (+3) 1
07:18:57 <lambdabot>   Overlapping instances for GHC.Show.Show
07:18:57 <lambdabot>                              ((a1 -...
07:19:03 <otters> (->) monad is full of light magic
07:19:04 <mzero> > liftM2 (*) (+ 7) (+3) 1
07:19:05 <lambdabot>   32
07:19:07 <otters> err, white magic
07:19:41 <merijn> utdemir: Did you put backticks around mod and div?
07:20:21 <utdemir> merijn, no i didn't. trying. and i assume backtick isn't these guy: '
07:20:23 <merijn> utdemir: Right now your passing the function "mod" as argument to the function 'n', which is not what you intended, I think
07:20:29 <merijn> utdemir: backtick is `
07:20:38 <merijn> Left of the 1 on standard US keyboards
07:20:52 <merijn> Surrounding a function name with backticks makes it infix
07:21:01 <merijn> > mod 2 3 == 2 `mod` 3
07:21:02 <lambdabot>   True
07:21:43 <merijn> Similarly surrounding an operator with parentheses will turn it into a prefix function
07:21:46 <utdemir> merijn, turkish keyboard here, i'm copying now, but i'll ask
07:21:56 <merijn> > 2 + 3 == (+) 2 3
07:21:57 <lambdabot>   True
07:22:45 <utdemir> merijn, it works :). thank you. And can I apply that to any function which takes two arguments? like f `all` xs ?
07:23:13 <merijn> utdemir: Wikipedia suggest backtick should be on the key with , and ; on Turkish keyboards
07:23:43 <merijn> utdemir: Yes
07:24:00 <merijn> Actually it also works for functions taking more than one argument, but I need to think of an example for that
07:24:05 <merijn> eh, more than two
07:24:06 <utdemir> merijn, oh, it's there. thanks again.
07:24:28 <MagneticDuck> hey guys, I have a question: is there any easier way to write for instance "map ((\c -> read [c])::Char -> Int) "1234""
07:24:35 <MagneticDuck> because that looks terribly ugly
07:24:49 <quicksilver> > map digitToInt "1234"
07:24:50 <lambdabot>   [1,2,3,4]
07:24:57 <ocharles> ((+5) &&& (*2)) 5
07:25:01 <MagneticDuck> @src digitToInt
07:25:01 <utdemir> merijn, and one more question, i know i can partial apply a function, like f = div 3, but how can I partial apply to second parameter?
07:25:01 <lambdabot> Source not found. Just what do you think you're doing Dave?
07:25:01 <merijn> > let if' x y z = if x then y else z in (True `if'` 2) 3
07:25:02 <lambdabot>   2
07:25:04 <ocharles> > ((+5) &&& (*2)) 5
07:25:05 <lambdabot>   (10,10)
07:25:19 <ocharles> > ((+1) &&& (*1)) 5
07:25:20 <lambdabot>   (6,5)
07:25:20 <merijn> utdemir: Either using flip or by doing (`div` 3)
07:25:23 <ocharles> interesting
07:25:32 <merijn> flip reverse the first two arguments of a function
07:25:36 <merijn> :t Prelude.flip
07:25:37 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
07:25:44 <MagneticDuck> quicksilver: but it's defined just about like that?
07:25:47 <utdemir> merijn, thank you. have a nice day
07:26:01 <ocharles> :t liftM2
07:26:02 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
07:26:10 <utdemir> merijn, i'll mess around with first project euler problems
07:26:21 <merijn> utdemir: Good luck :)
07:26:30 <MagneticDuck> or "map (\c -> read [c]) "1234" :: [Int]"
07:26:32 <MagneticDuck> looks better
07:26:34 <MagneticDuck> but still
07:26:40 <MagneticDuck> that "(\c -> read [c])"
07:26:45 <MagneticDuck> there must be something
07:26:56 <merijn> utdemir: You could also partially apply using "\x -> div x 3" of course, but flip and (`div` 3) are probably nicer to read
07:27:20 <MagneticDuck> the many definitions of flip always got to me
07:27:25 <MagneticDuck> ._.
07:27:28 <quicksilver> MagneticDuck: I don't really understand what the point of your question is.
07:27:40 <quicksilver> MagneticDuck: I imagine digitToInt is just defined as a 'case' of some kind
07:27:48 <quicksilver> but why does it matter how it's defined?
07:27:50 <utdemir> merijn, do you suggest me to read prelude library's functions first?
07:28:12 <MagneticDuck> quicksilver: I was just wondering if there was any prettier way to write it. Sometimes there is. That's all.
07:28:17 <quicksilver> MagneticDuck: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-Char.html#digitToInt
07:28:20 <MagneticDuck> I understand
07:28:31 <merijn> utdemir: You can certainly learn a lot from them, depends on what you feel like doing. I also don't really like Project Euler as practice, but I'm not sure what would be better
07:28:31 <MagneticDuck> no, it's the (\c -> read [c]) I'm interested in
07:28:45 <quicksilver> MagneticDuck: well, I think digitToInt is prettier than read.(:[]), certainly.
07:28:46 <merijn> MagneticDuck: "read . (:[])"?
07:28:52 <MagneticDuck> ah
07:28:57 <MagneticDuck> yes
07:29:06 <MagneticDuck> ty
07:29:09 <DrSyzygy> :t (.(:[]))
07:29:10 <lambdabot> forall b a. ([a] -> b) -> a -> b
07:29:11 <MagneticDuck> that's what I was looking for
07:29:17 <merijn> Or, even more confusing: "read . pure" and "read . return" (which might not work without a type annotation)
07:29:27 <MagneticDuck> not realy
07:29:30 <MagneticDuck> *really
07:29:35 <MagneticDuck> that looks better to me actually
07:29:49 <MagneticDuck> those are monoids right?
07:29:53 <merijn> MagneticDuck: Yes, but doesn't tell you that their lists
07:30:02 <MagneticDuck> yeah
07:30:06 <merijn> pure is for functor (I thought?) and return for monad
07:30:08 <MagneticDuck> well I need a type annotation anyway
07:30:13 <utdemir> merijn, I actually bored from one year of Java lessons and trying to learn something funny.
07:30:13 <MagneticDuck> functor?
07:30:25 <merijn> :t pure
07:30:26 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
07:30:28 <MagneticDuck> functors are just fmap
07:30:31 <MagneticDuck> Applicative??
07:30:32 <merijn> Oh, Applicative functors
07:30:34 <MagneticDuck> rr
07:31:00 <MagneticDuck> being a monoid implies being Applicative though right?
07:31:07 <Peaker> I miss the fish operators in the prelude <=< >=> ...
07:31:10 <merijn> utdemir: Reading the prelude is probably more interesting than most Java tutorials I read :p
07:31:22 <MagneticDuck> lol
07:31:30 <Peaker> and Control.Applicative and some of Data.Maybe
07:31:31 <Peaker> the Prelude is so arbitrary
07:31:32 <merijn> Monoid was MonadZero, no?
07:31:44 <MagneticDuck> MonadPlus...
07:31:47 <merijn> That would imply yes, since Monads are usually applicative
07:31:48 <MagneticDuck> not sure
07:31:50 <ocharles> MagneticDuck: do you mean monad? Any monad is an applicative functor, but not monoids
07:32:09 <quicksilver> Monoid and MonadZero are different kind.
07:32:28 <quicksilver> Monads (and MonadZeros) are * -> * , Monoids are just *
07:32:31 <MagneticDuck> a monoid has mappend and mempty
07:32:32 <MagneticDuck> only
07:32:35 <MagneticDuck> yeah
07:32:41 <MagneticDuck> okay
07:33:34 <MagneticDuck> @src charToDigit
07:33:34 <lambdabot> Source not found. The more you drive -- the dumber you get.
07:33:42 <MagneticDuck> dat lambdabot
07:33:54 <quicksilver> MagneticDuck: @src is a waste of space, don't use it.
07:33:59 <quicksilver> learn how to use the better tools.
07:34:05 <MagneticDuck> like hoogle?
07:34:12 <quicksilver> hoogling for digitToInt and then clicking through to the source link works.
07:34:18 <merijn> MagneticDuck: @src is filled with lies :p
07:34:32 <quicksilver> so does just having the library doc open in a browser window
07:34:38 <MagneticDuck> all I was looking for was the module
07:34:39 <MagneticDuck> xD
07:34:59 <MagneticDuck> btw nobody just "import Data" in a program?
07:35:27 <shapr> oh boy! Another day of code!
07:35:36 <MagneticDuck> wait
07:36:04 <MagneticDuck> I thought if you had some packages A.B and A.C you could just say "import A" and get B and C..?
07:36:46 <quicksilver> nope.
07:36:53 <quicksilver> A.B is entirely unrelated to A
07:37:22 <illissius> the dots in package names don't really have any semantic meaning, they're just there to make people feel better
07:37:38 <quicksilver> they have the same relationship as the identifier 'filtercoffee' has to the identifier 'filter'.
07:37:38 <ocharles> well, they do map to file system hierarchy
07:37:51 <MagneticDuck> okay
07:37:57 <quicksilver> ocharles: no, they don't.
07:38:05 <MagneticDuck> gosh, it seems I'm right back at "haskell newbie"
07:38:08 <quicksilver> ocharles: they might be in entirely different packages (which are in different directories)
07:38:09 <illissius> *module names
07:38:25 <ocharles> quicksilver: Foo.Bar is going to map to Foo/Bar.hs somewhere though, no?
07:38:41 <quicksilver> sure
07:38:46 <ocharles> that's all I meant
07:38:49 <quicksilver> but not necessarily the same Foo/ as Foo.Baz
07:38:52 <Peaker> quicksilver, btw, I think the record solution is working out nicer than the type class :)
07:38:59 <ocharles> quicksilver: no, but i didn't say that :)
07:39:05 <ocharles> but thanks for clarifying, that's important
07:39:24 <illissius> JHC iirc lets you do Foo.Bar.hs instead if you want, which would be nice. annoying to have these deep directory structures just for 1-2 files
07:46:21 * hackagebot aws 0.5.0 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.5.0 (AristidBreitkreuz)
07:51:25 <Peaker> nice.. changed deeply about 500 lines.. when it compiles, it all works. I love Haskell :)
07:52:09 <ocharles> Peaker: I changed 1500 lines yesterday and the only bug could have been solved by me reading the documentation (types changed, I made a bad assumption about what it meant)
07:52:36 <Peaker> illissius, quicksilver:  the records approach didn't require any GHC extensions, which is lovely...
07:52:55 <Peaker> ocharles, cool! :)
07:54:28 <dzhus> if my functions are strict on tuple arguments, then no boxing should happend, right?
07:54:41 <dzhus> (tuples come from Vector.Unboxed)
07:55:40 <applicative> dzuz, yes, basically; there might be grounds for caution
07:56:30 <applicative> a vector  of (Int,Word8) is really two vectors, so its kind of an illusion
07:56:59 <ocharles> Peaker: and now that i'm back to working on my haskell project I forgot how green the grass is. it's just so stress-free programming in haskell
07:57:06 <applicative> dzhus: but i guess this isnt news
07:59:18 <Peaker> ocharles, yeah, it's much more productive
07:59:32 <Peaker> can experimentally change everything and let the types guide me...  It's funny how people think that *dynamic typing* makes experimental programming easy. It is so much harder to experiment without the help of types
08:00:11 <hpaste> MagneticDuck pasted “I'm stumped ._.” at http://hpaste.org/69594
08:00:34 <MagneticDuck> maybe I'm tired
08:00:44 <MagneticDuck> but I can't figure out what's going wrong
08:00:45 <otters> are there any standard library time functions
08:00:53 <MagneticDuck> project euler... problem 8
08:00:54 <MagneticDuck> ._.
08:01:09 <c_wraith> Peaker: I completely agree. and think that this means that the mainstream statically typed languages must be the worst of both worlds, if people reach that conclusion
08:01:20 <c_wraith> otters: the time package is a standard library
08:01:23 <otters> MagneticDuck: the warning?
08:01:40 <ocharles> Peaker: amen. people think I'm crazy when I prototype in haskell
08:01:42 <MagneticDuck> no, try compiling it
08:02:15 <ocharles> I'm like "but... I don't know how everything will interact. How can you even start writing code if you don't know how systems will interact?" and then I write my data types and mock out functions with 'undefined' until I'm happy, and then start implementing code
08:04:15 <pcapriotti> MagneticDuck: I think you mean: maximumBy (comparing sum) $ ...
08:04:21 <MagneticDuck> well yes
08:04:42 <MagneticDuck> maximumBy $ comparing sum is the exact same thing as maximumBy (comparing sum)
08:04:55 <MagneticDuck> just I hate parenthesis
08:04:59 <MagneticDuck> no just kidding
08:05:02 <MagneticDuck> but I don't love them
08:05:07 <pcapriotti> it's not the same thing
08:05:14 <MagneticDuck> no?
08:05:25 <MagneticDuck> f $ x == f (x)
08:05:33 <Peaker> ocharles, I just write something, decide it's all wrong, change everything, and then fix it via following ghc errors :)
08:05:37 <pcapriotti> no, what you wrote means: maximumBy (comparing sum (...))
08:05:44 <MagneticDuck> yes
08:05:47 <nand`> Say; would it make sense to split Monad into classes “Bind” (or “Join” or maybe “Retract”) as dual of “Extend” with functions join :: m (m a) -> m a  and bind :: (a -> m b) -> m a -> m b;  and then a class “Monad” as dual of “Comonad” with return :: a -> m a
08:05:52 <pcapriotti> vs: maximumBy (comparing sum) (...)
08:05:56 <pcapriotti> which is what you want
08:05:59 <Peaker> I don't use "undefined" much, I like to run intermediate implementations
08:05:59 <Peaker> (sometimes use it to debug type errors)
08:06:13 <nand`> alternatively even get rid of Monad and Comonad's functions entirely and make them equivalent to Bind+Pointed / Extend+Copointed respectively
08:06:16 <MagneticDuck> aaaaahhhh
08:06:22 <nand`> but I'm not too sure how Pointed/Copointed relate to Monad/Comonad
08:07:02 <MagneticDuck> lol okay ty
08:07:09 <pcapriotti> np :)
08:07:17 <MagneticDuck> xD
08:07:21 <MagneticDuck> I'm relearning haskell
08:07:22 <MagneticDuck> it seems
08:08:10 <vn971> I'm from Scala and new to haskell. Is haskell really good at GUI ?
08:08:10 <Peaker> MagneticDuck, in a subexpression: (x) = x   so f (x)  is f x
08:08:32 <Peaker> (Haskell doesn't use () for function call syntax)
08:08:36 <vn971> with scala there is a problem that it runs on JVM, which is propriatary and ugly for windows-users.
08:08:37 <MagneticDuck> I know that
08:08:47 <hpaste> applicative annotated “I'm stumped ._.” with “I'm stumped ._. (annotation)” at http://hpaste.org/69594#a69595
08:09:09 <MagneticDuck> the problem is organizing the syntax for f $ g $ x as opposed to f (g) $ x
08:09:36 <RichyB> vn971, there's a *nice* binding for GTK for Haskell, which is a cross-platform GUI kit that looks pretty reasonable on just about every platform.
08:10:03 <nand`> depending on how you use ‘x’ here that may or may not be true; if ‘x’ is a metavariable (as opposed to a name), then in f (x)  x has a higher priority <- which relates to this scenario, where ‘x’ was not just a variable but an expression
08:10:08 <hpaste> MagneticDuck annotated “I'm stumped ._.” with “I'm stumped ._. (annotation) (annotation)” at http://hpaste.org/69594#a69596
08:10:09 <applicative> MagneticDuck: It is a little confusing, since it seemed like slidebreak was missing the Int arg?
08:10:24 <MagneticDuck> no
08:10:28 <Peaker> vn971, Haskell has Gtk/wx bindings
08:10:29 <vn971> RichyB: does it use system L&F or completely cross-platform?
08:10:31 <MagneticDuck> I'm working with project euler
08:10:38 <MagneticDuck> so p8 is problem 8
08:10:40 <MagneticDuck> the solution
08:12:34 <RichyB> vn971, I think so? Mostly.
08:13:02 <RichyB> vn971, it's very good on Linux, mostly right on Windows, just about acceptable on OS X.
08:13:16 <applicative> vn971: I'm pleased to say that on os x the wx bindings  are amazingly easy with the new haskell platform
08:13:27 <applicative> vn971: i mean easy to install
08:13:33 <vn971> )
08:13:35 <vn971> for the user?
08:14:01 <applicative> for a user you generate an .App
08:14:13 <RichyB> On Windows, you seriously want to bundle the dlls. :)
08:14:20 <RichyB> Regardless of what you use.
08:14:54 <RichyB> vn971, compare screenshots here for wx: http://www.wxwidgets.org/about/screensh.htm
08:15:05 <RichyB> vn971, and for GTK, here: http://www.gtk.org/screenshots/index.php
08:15:06 <applicative> RichyB: right, the cabal-macosx package basically does that; there are various degrees to which you can include libraries
08:15:07 <vn971> RichyB: applicative: Peaker:  thanks! I thing I got some picture in overall
08:15:11 <vn971> :)
08:16:06 <applicative> vn971: people here can help you with installation subtleties; if you haven't used cabal-install and so on it can seem confusing
08:17:39 <Peaker> vn971, btw, I don't like Gtk/wx, so I wrote my own little GUI toolkit in Haskell :)
08:18:09 <Peaker> but it's not really a comprehensive one - wouldn't use it for real things (yet)
08:18:55 <RichyB> Worst comes to the worst, you could write a *lot* of FFI import statements...
08:19:10 <RichyB> I don't really recommend that course of action for any reason other than for fun. :)
08:20:34 <vn971> thanks!
08:30:27 <Peaker> nominolo, hey, I see you put up a union-find package.. if I make an ST variant, will you upload it?
08:33:24 <Peaker> oh actually I have a base monad already.. Can't compose that with ST..
08:35:44 <Peaker> hmm.. actually I could get rid of the base monad..
08:35:44 <Peaker> is there a package with an abstraction of IO+IORef/ST+STRef to a type-class?
08:37:20 <illissius> Peaker: there is, at least one but maybe more
08:37:52 <illissius> Peaker: http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=MonadRef
08:42:07 <Siod> for circular dependencies (hs-boot) how are you supposed to define types that require imports?
08:42:29 <c_wraith> most people just avoid circular dependencies
08:42:38 <Siod> eg. i have a type in an hs-boot file that uses statet
08:42:42 <c_wraith> and restructure their code to avoid it
08:43:02 <Siod> c_wraith: i don't see how i can, and i see lots of hs-boots in well known projects
08:43:30 <applicative> Peaker, the 'fun with type families' paper gives that as an illustration; i see MonadRef is using functional dependencies and the usual
08:43:30 <Siod> yi has 6 of them
08:44:13 <Siod> darcs doesn't have any
08:44:26 <c_wraith> Most packages don't have any
08:44:34 <c_wraith> They're generally more trouble than they're worth
08:44:39 <c_wraith> and you can always get rid of them.
08:45:07 <c_wraith> The extreme case (useful only as a reasoning technique, never in practice) of that is putting everything in one module
08:45:43 <c_wraith> the standard technique is more like calculating the strongly connected components of the dependency graph, and using that as a basis for the module divisions
08:46:25 <Siod> how would you restructure module MyProg (GlobalState, StateMonad) -> Plugin (PluginData) where Plugin needs StateMonad and GlobalState needs PluginData and where StateMonad needs GlobalState
08:46:32 * hackagebot acid-state 0.6.4 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.6.4 (DavidHimmelstrup)
08:47:42 <c_wraith> I'm not sure that question makes any sense. what does -> mean for a module?
08:48:09 <applicative> Peaker, I mentioned above the STRef/IORef class in the 'fun with type families' paper.  I dont know if there's a version on hackage
08:50:21 <Siod> c_wraith: http://ideone.com/eUDWx
08:51:33 * hackagebot thrist 0.2.2 - Type-threaded list  http://hackage.haskell.org/package/thrist-0.2.2 (GaborGreif)
08:52:09 <joeyh> Siod: I've used parameterized types in this situation. Not entirely happy with it.
08:52:34 <Siod> joeyh: i don't understand
08:53:05 <joeyh> ie, data MyProgGlobalState p = MyProgGlobalState { getPlugins :: [p] }
08:53:23 <Siod> ah
08:53:46 <joeyh> or the other way around, in MyProgPlugin .. whichever makes more sense
08:53:50 <Siod> ty at least that's a solution
08:54:00 <Siod> i couldn't get hs-boot to work
08:56:25 <upio_> I need help finding a suitable array type. It should be unboxed and mutable. Used as a fixed-size container for my custom type A, instead of lists. Also, I would like the operations to be pure. Is STUArray "the right" choice?
08:57:28 <upio_> There is also MutableByteArray#, on which STUArray depends (ghc)
08:59:05 <applicative> What is the 'custom type' like? upio_
08:59:06 <upio_> My type A is also Storable
08:59:12 <applicative> oh i see
08:59:55 <upio_> can I use Storable a with STUArray's?
09:01:18 <upio_> my custom type A only consists of basic types (Int16, Int8).
09:03:18 <applicative> upio_: have you looked at the vector package Data.Vector.Storable Data.Vector.Storable.Mutable
09:03:44 * applicative concede  he prefers `vector` because it's more familiar
09:04:54 <upio_> applicative: I found them now.
09:05:21 <upio_> but it is not easy to get an overview of the haskell Array-jungle!
09:06:08 <applicative> upio_: I'm no expert.  Theres a little tutorial for the vector package http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial
09:06:31 <jmcarthur> upio_: it's not even always clear when you actually need mutability
09:06:39 <applicative> the vector package uses the fancy method of stream fusion.
09:07:25 <jmcarthur> applicative: at least the immutable vectors do
09:07:48 <jmcarthur> and there is some "recycling" for the operations on immutable vectors that use mutation under the hood
09:07:50 <upio_> well, I don't need a fancy array, only read/write access at indices (I think).
09:08:07 <applicative> jmcarthur: all the vectors are mutable.  the functions fused are all monadic
09:08:10 <upio_> therefore, I asked for help
09:08:39 <jmcarthur> applicative: they are only monadic in order to support mutable operations, not because all of them perform mutation
09:08:49 <applicative> jmcarthur: I mean the 'actual vector' is the same of course in either library Vector.X and Vector.X.Mutable
09:08:53 <jmcarthur> yes
09:09:19 * applicative is thinking 
09:09:41 <jmcarthur> well, not strictly the same, but at least all the vectors included in the package are that way
09:09:53 <upio_> therefore, I might just use MutableByteArray#? Or a thin wrapper, like STUArray.
09:10:10 <jmcarthur> upio_: if you need to use Storable, neither of those will work for you
09:10:28 <Peaker> My ISP decided I've had enough IRC for today, I think. It keeps connecting, getting no messages, and timing out :-(
09:10:59 <jmcarthur> upio_: i see no great reason to not just use vector
09:11:06 <upio_> jmcarthur: is it not possible to use Storable as elements?
09:11:19 <jmcarthur> and using vector also means compatibility with the growing number of other libraries that use vector
09:11:27 <jmcarthur> upio_: not with those array types
09:12:22 <jmcarthur> may i ask what the application is?
09:12:34 <upio_> Well, that was the main reason I went into IRC, since I did not know how to use Storable inside STUArray.
09:13:38 <upio_> jmcarthur: the array shall hold values in a real-time OpenGL program.
09:14:11 <applicative> upio_: MutableByteArray# is what Data.Vector.Primitive and thus Data.Vector.Unbox are 'really about'
09:14:21 <jmcarthur> upio_: "hold values"?
09:16:23 <upio_> jmcarthur: the program uses a set of values to define a GL world
09:17:00 <upio_> ok, so Data.Vector.Primitive is probably what I want (?).
09:17:00 <jmcarthur> upio_: could you be more specific? what are these values and how are they manipulated?
09:17:05 <jmcarthur> no
09:17:09 <jmcarthur> definitely not
09:17:12 <applicative> upio_ is this similar http://stackoverflow.com/questions/10468845/juicypixels-texture-loading-in-haskell-opengl
09:17:55 <jmcarthur> if you have to use Storable and mutation, you will want Data.Vector.Storable.Mutable, but i'm still doubtful you really need mutation at all given only what you've explained so far
09:20:08 <upio_> I am not holding GL-values, I define my world objects in haskell (and I use GL to draw my world). So GL is actually not related.
09:21:17 <jmcarthur> then i really still don't know what you are doing
09:21:45 <jmcarthur> i mean i get that these values somehow define the world, but i have no clear explanation of how they are used and manipulated
09:21:59 <eacameron> how do I return Infinity in my function like (1/0) does?
09:22:19 <jmcarthur> eacameron: by returning (1/0)
09:22:44 <eacameron> jmcarthur: There's no way to construct Infinity myself?
09:22:52 <elliott> Is (Writer Builder) (with Builder from blaze-builder) a useful thing to use, or does the fact that the Writer monad doesn't associate mappends and mappends pointless memptys and so on hurt performance?
09:22:53 <jmcarthur> eacameron: that *is* how your construct infinity yourself
09:23:11 <eacameron> hmmm...how does Fractional / do it?
09:23:19 <jmcarthur> elliott: maybe it could be worth it when combinaed with codensity?
09:23:30 <elliott> jmcarthur: indeed, perhaps
09:23:46 <jmcarthur> elliott: i don't recall how blaze works though. maybe it already reassociates?
09:23:49 <elliott> (Builder b1) `mappend` (Builder b2) = Builder $ b1 . b2
09:23:52 <elliott> and mempty is just Builder id
09:23:59 <jmcarthur> eacameron: depends on the type, i'm sure
09:23:59 <eacameron> jmcarthur: how does Fractional / do it?
09:24:01 <elliott> so I suspect the extra memptys aren't really a problem
09:24:07 <ocharles> (1/0) is not infinity either, it's undefined
09:24:13 <elliott> ocharles: it is in ieee floating point
09:24:18 <elliott> eacameron: by appealing to the hardware
09:24:23 <jmcarthur> ocharles: it's infinity in ieee
09:24:36 <elliott> jmcarthur: I would think that the associativity of (.) wouldn't matter much, but I'm not sure
09:24:37 <jmcarthur> > 1/0
09:24:38 <lambdabot>   Infinity
09:24:46 * ocharles stands somewhat corrected then
09:24:55 <jmcarthur> elliott: (.) effectively reassociates for you
09:24:56 <ocharles> though is not entirely happy to stand corrected, but I can't argue with the ieee :)
09:25:02 <elliott> jmcarthur: right
09:25:17 <elliott> seems like Writer Builder should be fine, then
09:25:19 <elliott> that's good :)
09:25:56 * eacameron begrudgingly writes `return (-1/0)` in his function...
09:25:57 <jmcarthur> ocharles: not much about floating point makes me happy
09:26:05 <akosch> > Infinity / Infinity
09:26:15 <quicksilver> you probably shouldn't use Infinity, unless you have some specific clever approach in mind, eacameron
09:26:22 <quicksilver> IEEE Infinity is pretty much useless
09:26:24 <nand`> > (1/0) / (1/0)
09:26:29 <lambdabot>   can't find file: L.hs
09:26:29 <lambdabot>   can't find file: L.hs
09:26:32 <nand`> :(
09:26:36 * hackagebot kure 2.0.0 - Combinators for Strategic Programming  http://hackage.haskell.org/package/kure-2.0.0 (NeilSculthorpe)
09:26:39 <tac-tics> > 1 / 0
09:26:40 <lambdabot>   Infinity
09:26:46 <quicksilver> doesn't have any of the properties you'd want for a sensible Real line + Infinity kind of structure.
09:26:47 <jmcarthur> > (1/0) > 999
09:26:48 <nand`> > (1/0) / (1/0)
09:26:48 <lambdabot>   True
09:26:48 <akosch> > (1/0) - (1/0)
09:26:49 <lambdabot>   NaN
09:26:49 <lambdabot>   can't find file: L.hs
09:26:53 <eacameron> quicksilver: I have a bunch of bayesian classification scores and, in this case, I want the score to sort last always and forever
09:26:54 <applicative> @type Infinity
09:26:55 <lambdabot> Not in scope: data constructor `Infinity'
09:26:58 <jmcarthur> quicksilver: Infinity is okay for Ord at least
09:27:00 <applicative> haha
09:27:20 <quicksilver> jmcarthur: if you're happy for your haskell program to depend on implementation-specific behaviour, perhaps.
09:27:35 <jmcarthur> quicksilver: are haskell floats not specified to be ieee?
09:27:51 <quicksilver> I'd rather use data TopBounded a = Actually a | Top deriving Ord
09:27:54 <quicksilver> jmcarthur: nope.
09:27:57 <jmcarthur> ah
09:28:00 <applicative> > 1/0
09:28:00 <quicksilver> jmcarthur: although you can check, if you like.
09:28:01 <lambdabot>   Infinity
09:28:05 <eacameron> > (1/0) < 0
09:28:05 <quicksilver> @hoogle isIEEE
09:28:06 <lambdabot> Prelude isIEEE :: RealFloat a => a -> Bool
09:28:06 <lambdabot>   False
09:28:10 <elliott_> floats not being guaranteed to be ieee is really a bit silly
09:28:15 <applicative> > sort [2/2,2/1,1/2,1/0] --  rather
09:28:16 <lambdabot>   [0.5,1.0,2.0,Infinity]
09:28:21 <eacameron> quicksilver: I guess that won't work anyway!
09:28:22 <elliott_> otoh it lets us fix Eq for floats :)
09:28:34 <quicksilver> eacameron: which won't work?
09:28:35 <akosch> > (1/0) == (1/0)
09:28:36 <nand`> > (1/0) - (1/0)
09:28:36 <lambdabot>   True
09:28:37 <lambdabot>   NaN
09:28:37 <eacameron> looks like Infinity doesn't compare sensibly to anything else
09:28:56 <akosch> eacameron: to infinity it does :)
09:29:00 <applicative> > sort [2/2,2/1,1/2,1/0, (negate 1)/0] --  rather
09:29:01 <lambdabot>   [-Infinity,0.5,1.0,2.0,Infinity]
09:29:11 <akosch> > (10/0) == (1000/0)
09:29:12 <lambdabot>   True
09:29:13 <eacameron> quicksilver: Infinity > 0 is False?? it won't sort
09:29:28 <quicksilver> I'm not sure that Ord promises to follow IEEE rules even if your Double type isIEEE.
09:29:34 <quicksilver> I certaily don't remember it being written down.
09:29:37 <quicksilver> eacameron: you just got it backwards.
09:29:40 <quicksilver> it does DTRT.
09:29:45 <quicksilver> but I'm not sure I'd choose to rely on it
09:29:47 <nand`> I'm trying to construct a pseudo-random Double from a CryptoRandomGen instance, which has genBytes that gives me a ByteString of a length I choose. What's a good way to write :: ByteString -> Double in a way that will preserve the pseudo-randomness well?
09:29:48 <jmcarthur> quicksilver: this is the isIEEE function at least
09:29:49 <applicative> > 0/0 == (negate 0/0)
09:29:50 <upio_> jmcarthur: I only wanted a fixed-size array, with Read/Write possibility at custom indices.
09:29:50 <lambdabot>   False
09:29:56 <jmcarthur> ah you already mentioned it
09:29:56 <nand`> ie. if I sample it a bunch of times, it should be reasonably distributed
09:29:57 <quicksilver> unless you're convinced thi is a performance issue.
09:29:58 <jmcarthur> you may be right
09:29:59 <nand`> between 0 and 1, ideally
09:30:00 * eacameron is overwhelmed by all the Infinities flying around
09:30:05 <applicative> > 0/0 == (- 0)/0
09:30:06 <lambdabot>   False
09:30:35 <applicative> what a madhouse. i'm sticking to the peano numbers
09:30:46 <jmcarthur> upio_: i understand that, but i think you are probably overspecifying the problem at such a low level. if you explain *how* you will be manipulating it then i may be able to recommend something nicer
09:30:54 <akosch> > -1 * (0/0)
09:30:55 <lambdabot>   NaN
09:31:00 <akosch> > -1 * (1/0)
09:31:01 <lambdabot>   -Infinity
09:31:21 <nand`> x/0 should be _|_
09:31:26 <upio_> jmcarthur: for example, points which are modified by time.
09:31:38 <ocharles> nand`: i already said that :)
09:31:39 <upio_> so I only wanted a container instead of lists
09:31:43 <elliott_> upio_: A fixed-size array is often not what you want in Haskell.
09:31:51 <elliott_> Functional structures are often more efficient.
09:32:00 <elliott_> For instance, you might wish to use an associative map of some sort.
09:32:01 <nand`> ocharles: I wasn't paying attention :)
09:32:04 <eacameron> looks like Infinity does compare, I was wrong
09:32:06 <elliott_> Or another tree structure, such as Seq.
09:32:12 <ocharles> nand`: i'm glad i'm not the only person who screamed "argh, that's not correct!"
09:32:12 <eacameron> so why not use it for a sort?
09:32:17 <fmap> > sort [3,0/0,2,0/0,0/0,1]
09:32:18 <lambdabot>   [1.0,NaN,NaN,2.0,NaN,3.0]
09:32:20 <jmcarthur> eacameron: http://hackage.haskell.org/packages/archive/ieee754/0.7.3/doc/html/Numeric-IEEE.html
09:32:20 <elliott_> The problem with arrays is that they have to be fully copied on each modification.
09:32:28 <nand`> ocharles: I don't think anybody likes IEEE floats. They're.. a “necessary evil”
09:32:59 <jmcarthur> nand`: i have a coworker that likes them
09:33:06 <applicative> fmap it seems some NaN s are more equal than others
09:33:09 <nand`> I stand corrected
09:33:23 <upio_> elliott_, jmcarthur: I need random access possibility, therefore I wanted arrays
09:33:32 <nand`> applicative: I think that's just an artifact of NaN always comparing negatively, thus the sorting algorithm breaking
09:33:34 <jmcarthur> nand`: and it's not just the he's ignorant about them either. he knows more about floating point than basically anyone else i can think of
09:33:36 <nand`> or something like that
09:33:40 <elliott_> upio_: You probably don't need O(1) random access.
09:33:55 <elliott_> upio_: There are functional structures with access better than O(idx).
09:34:04 <tommd> No, you need O(1/n) random access.  Access that speeds up as you get more data.
09:34:15 <jmcarthur> upio_: you can still get random access reads in O(1) with immutable arrays
09:34:21 <applicative> nand` i see that it would turn on how sort is defined
09:34:27 <jmcarthur> upio_: for writes... it's more complicated without knowing your usage patterns
09:34:31 <elliott_> jmcarthur: right, as long as you rarely update
09:34:36 <elliott_> (but usually you update quite a lot!)
09:34:42 <akosch> (0/0 < 1/0) || (0/0 > 1/0)
09:34:46 <akosch> > (0/0 < 1/0) || (0/0 > 1/0)
09:34:47 <lambdabot>   False
09:34:51 <jmcarthur> elliott_: or if your updates take certain patterns (like if you always update all at once or many at once)
09:34:52 <elliott_> tommd: I prefer O(a(n)).
09:34:55 <elliott_> jmcarthur: right
09:35:01 <nand`> I'll ask again, how to implement f :: ByteString -> Double where the codomain is the range (0,1) in a way that if the input is evenly distributed over a sample size, the output will be too?
09:35:05 <elliott_> tommd: (where a is the inverse of the Ackermann function, naturally)
09:35:31 <nand`> (within reason)
09:36:09 <tommd> elliott_: That makes sense - good idea.
09:37:12 <upio_> Ok, what I want is an array (with random read/write access). This might not be optimal, but this works!
09:37:40 <jmcarthur> upio_: Data.Vector.Storable.Mutable is what i recommend given that low level spec then :\
09:37:57 <applicative> nand`: how are bytestrings ordered, as closer and farther? lexically, as by sort . map unpack ?
09:38:21 <nand`> applicative: they're randomly generated with no order
09:38:26 <nand`> but I can specify a length when generating
09:38:29 <nand`> if that helps
09:38:33 <nand`> oh
09:38:41 <upio_> jmcarhur, applicative: thank you, I did not know about the vector package
09:38:43 <nand`> I could simply generate a singleton bytestring and divide that by 256
09:39:13 <nand`> works for me, less complicated is good, and the precision I would get from that is fine; maybe I could generalize it though so the second byte specifies the sub-256 precision, etc.
09:39:13 <jmcarthur> upio_: also check out vector-algorithms for some common operations on mutable arrays
09:39:25 <jmcarthur> upio_: more complex operations than those included in vector, that is
09:39:38 <applicative> nand`: but when you speak of how the bytestrings themselves are distributed; you need ameasure of distance, or the like, no?
09:40:31 <applicative> upio_: you should certainly know about it, even if it ends up not fitting.  Data.Vector.Unboxed is my favorite module
09:40:33 <nand`> applicative: oh, I completely misinterpreted your question; I have no clue about statistics so I don't know what that means
09:41:10 <upio_> the reason I thought about an array, is because I want to sync OpenGL(vertex array buffer) with Haskell (container).
09:41:16 <nand`> I was just trying to express the property that “if the ByteStrings are pseudo-random, the Doubles should be pseudo-random within the range (0,1) as well”
09:43:40 <applicative> nand`: there is a different ambiguity, do you mean the succession of Word8 in the individual bytestring is random?
09:44:19 <nand`> applicative: they should be, each Word8 is independent of the others
09:44:48 <jmcarthur> upio_: ah! then you *might* want a mutable array ;) still depends on how you are modifying it though
09:45:06 <applicative> it would be crazy, but suppose you just accumulated the average, then normalized by dividing by 2 ^ 8 or whatever
09:45:54 <kani> Is there a function that determines if a given string can be parsed to an integer? "read" throws an exception if the string can't be parsed.
09:45:59 <applicative> but then every long bytestring will be near .5
09:46:27 <upio_> kani: readP or something
09:46:38 * hackagebot tskiplist 0.1.0 - A Skip List Implementation in STM  http://hackage.haskell.org/package/tskiplist-0.1.0 (PeterRobinson)
09:46:49 <kani> upio_: Thank you
09:47:00 <upio_> kani: reads maybe?
09:47:30 <applicative> kani, use reads?
09:47:59 <kani> upio_: I need to do some extra works with reads, so i was wondering if there's one.
09:48:00 <upio_> jmcarthur: and I had problem understanding you question about usage...
09:49:19 <applicative> > reads "1" :: [(Int,String)]
09:49:20 <lambdabot>   [(1,"")]
09:49:30 <applicative> > reads "hi, kani" :: [(Int,String)]
09:49:31 <lambdabot>   []
09:49:46 <jmcarthur> upio_: the question is about whether you *really* need random access writes or whether you just think you do because you aren't familiar with stream usion and array recycling
09:49:52 <jmcarthur> *stream fusion
09:49:55 <DrSyzygy> > reads "25 hi kani" :: [(Int, String)]
09:49:56 <lambdabot>   [(25," hi kani")]
09:50:24 <kani> Thank you all. I'll study more. Haskell's hard
09:50:25 <jmcarthur> upio_: i'm not trying to keep pressing or anything though
09:50:26 <upio_> kani: don't use my advice about readP. I am not sure which function i  was thinking about (i think it was reads)
09:50:44 <applicative> @type fmap fst . listToMaybe . reads
09:50:45 <lambdabot> forall a. (Read a) => String -> Maybe a
09:51:26 <jmcarthur> upio_: array recycling gives you many kinds of operations one might normally think require mutably arrays, but with a pure interface
09:51:33 <jmcarthur> *mutable
09:51:47 <applicative> > let kaniread = fmap fst . listToMaybe . reads in map kaniread ["1","2","hi"] :: [Maybe Int]
09:51:49 <lambdabot>   [Just 1,Just 2,Nothing]
09:52:29 <upio_> jmcarthur: ok, but if there is a problem, this will show up when profiling.
09:53:34 <jmcarthur> upio_: for example, check out the functions under http://hackage.haskell.org/packages/archive/vector/0.9.1/doc/html/Data-Vector-Storable.html#g:14. using just one will normally result in a copy of the original, but composing several of them won't result in even more unnecessary copies
09:54:06 <jmcarthur> upio_: so if by the end you expect to have modified most elements of the vector anyway then this is just as good as a mutable one
09:54:41 <jmcarthur> upio_: that link should take you to the "Modifying Vectors" section, in case it didn't
09:55:37 <upio_> jmcarthur: thank you
09:55:39 <upio_> :)
09:59:29 <applicative> jmcarthur: i meant to say up above that I just meant that the basic Stream type used throughout is 'monadic' data Stream m a = forall s. Stream (s -> m (Step s a)) s Size
09:59:55 <applicative> unlike other 'stream fusion' applications e.g. Text
10:01:39 <jmcarthur> applicative: right, i understood
10:08:51 <andares> hey, I'm trying to download the FG GUI toolkit, but I can't find it on cabal, nor can I a download link on http://kevin.atkinson.dhs.org/fg/doc/FG.html
10:08:57 <andares> does anyone know how I can get it?
10:10:27 <applicative> http://kevin.atkinson.dhs.org/fg/FG.hs  ?
10:10:48 <andares> d'oh, thanks. did I miss a link?
10:11:35 <applicative> i wonder it will compile.  2005 is a while ago
10:15:10 <applicative> import List hiding (init)   import Monad hiding (guard) will need help, andares, with new ghcs
10:16:51 <kkyqqp> I'm implementing a fraction system using data, and I want to tell haskell how to compare using them ord (>, <, <= etc)- how do I do this?
10:17:34 <sipa> kkyqqp: what does your type look like?
10:17:48 <Ralith> kkyqqp: why not just use Rational?
10:18:09 <kkyqqp> it'shttp://pastebin.com/wK4mTsB6
10:18:11 <JamesRustle> The paste wK4mTsB6 has been copied to http://hpaste.org/69601
10:18:40 <kkyqqp> it's for continued fractions, I can't use rational
10:18:41 <andares> applicative: ah, code rot?
10:19:08 <stepcut> what is the best way to syntax highlight Haskell code in a LaTeX document?
10:21:32 <applicative> andares the options at the top might need to be reformulated, I would try it but I dont  have gtk2hs.  Things from much farther back are sound.
10:24:08 <andares> hm, is there a way to make cabal list a manifest of installed files for a package? I'm having trouble with gtk2hs-buildtools.
10:28:40 <applicative> stepcut: cant you ask tex to run it  through a highlighter?
10:29:08 <stepcut> applicative: I have used lhs2TeX before.. but now I am thinking I should try pandoc
10:29:57 <stepcut> pandoc would probably be one of my favorite Haskell libraries/executables if it wasn't infected with the GPL :(
10:30:14 <stepcut> I would like to have an input document and generate reasonable HTML, PDF, and ebook formats.. which is exactly what pandoc is supposed to do
10:30:19 <applicative> stepcut: that would be easier of course.  there's an independent executable that you could instruct the latex machinery to call
10:30:45 <applicative> stepcut: yes.
10:31:17 <applicative> stepcut: it has highlighting built in
10:31:29 <stepcut> right
10:31:50 <stepcut> and since I am just using pandoc to process documents the GPL doesn't matter here
10:33:47 <applicative> Oh here's the executable that you can call apart from that, i guess it just does html and latex https://github.com/jgm/highlighting-kate/blob/master/Highlight.hs
10:38:04 <elliott_> stepcut: you could ask the author to relicense?
10:38:39 <stepcut> elliott_: https://github.com/jgm/pandoc/issues/180
10:39:26 <burbul> I have a load of parsec parsers that are collectively taking up a huge amount of space (maybe 600 lines of code or more).
10:39:39 <burbul> I've pasted a few examples at http://hpaste.org/69607
10:39:48 <burbul> Could anyone give me any ideas on how to express these more compactly?
10:39:54 <burbul> (Without completely losing readability)
10:41:29 <elliott_> stepcut: fair enough
10:41:39 <applicative> stepcut: I hadn't seen that discussion, but  i notice it's much older than it seems, from google code 2009
10:42:14 <elliott_> applicative: comments stretch later
10:42:23 <elliott_> the highlighting-kate issue seems fairly decisive, anyway
10:42:54 <stepcut> elliott_: well, pandoc is still useful with out highlighting-kate
10:43:08 <stepcut> elliott_: like.. for writing novels and stuff :)
10:43:18 <elliott_> stepcut: you want pandoc to be gpl licensed when it uses highlighting-kate and bsd licensed when not?
10:43:27 <elliott_> and then other packages to depend on this package, whose license changes by a build flag?
10:43:32 <elliott_> sounds "awesome"
10:43:46 <elliott_> if the highlighting-kate-depending stuff could be separated into another package that would be better, eys
10:43:48 <elliott_> *yes
10:43:57 <applicative> ah I see the more recent bits   I can't tell who's saying what since most of it is copied over in the transition to git
10:44:38 <applicative> I think a lot of users actually like its gpl-ness.
10:44:45 <stepcut> elliott_: well. this is one of this unclear areas of copyright stuff. I believe pandoc can always be BSD3, since APIs are not copyrighted. But, when you build an executable that uses hightlighting-kate, that executable would be GPL infected
10:44:51 <elliott_> applicative: it has authorship info in the footer of each comment
10:45:12 <elliott_> stepcut: if pandoc can be BSD3 and depend on Pandoc, you can be BSD3 and depend on Pandoc
10:45:14 <elliott_> erm
10:45:18 <elliott_> *and depend on highlighting-kate
10:45:39 <elliott_> but anyway, sure, the linking part was implicit in what I said
10:45:45 <elliott_> it's still a very confusing situation to create
10:45:54 <applicative> elliott_: I'm getting it now
10:45:58 <stepcut> yes, but in order to build a BSD3 version of the exectuable, I would have to disable the pandoc support -- which would likely render it useless
10:46:08 <stepcut> where-as pandoc minus highlighting is still useful
10:46:16 <elliott_> stepcut: my point is not that it is impossible
10:46:27 <elliott_> my point is that the licensing of an executable that links with Pandoc depending on its build flags is VERY confusing
10:46:34 <elliott_> especially as you cannot depend on a certain build configuration of a package with Cabal
10:46:47 <stepcut> elliott_: yes, would be better if kate was BSD3 as well
10:46:59 <elliott_> you'd have to track down the author of each individual XML file for that
10:47:09 <elliott_> since only some of them are GPL, it appears
10:47:28 <parcs`> burbul: incorporate the Text.Parsec.Token module into your code
10:47:35 <stepcut> elliott_: anyway, the solution for pandoc would be two different package names, pandoc and pandoc-bsd3
10:47:58 <elliott_> stepcut: ew
10:48:10 <stepcut> elliott_: that way they can have different APIs and you can explicit depend on the kate version if you require it
10:48:36 <elliott_> stepcut: better the highlighting-kate stuff just be split into a separate add-on package rather than silly duplication like that
10:48:46 <elliott_> especially since you cannot use a pandoc installation to satisfy a pandoc-bsd3 dependency
10:48:52 <stepcut> elliott_: well, I didn't design cabal -- that is the official solution AFAIK. Build flags can not change the API, so you have to provide different package names for different APIs
10:49:13 <stepcut> elliott_: splitting it out would be better -- just not sure if it is feasible
10:49:31 <stepcut> elliott_: I guess with enough refactoring it could be though..
10:49:51 <stepcut> elliott_: the highlighter could be an callback function, and you could supply whatever highlighting library you want
10:50:05 <ahwan> any 1 thr??? any female?? 4 frndship..?
10:50:21 <applicative> i wonder if the middle path for haskelly types to plead for to get the libraries BSD'd or some of them.  One for example contains the de facto specification of the markdown variant it employs
10:51:03 <stepcut> anyway, I need an extensible markdown parser.. so I will make mine BSD3 :)
10:51:42 <elliott_> ahwan: this channel is about the haskell programming language.
10:51:51 <burbul> parcs`: thanks for the advice. I just looked at it and I'm not sure how it is meant to help. I have already got equivalents of 'parens', 'whiteSpace' and such like defined...
10:51:58 <elliott_> stepcut: more library fragmentation :(
10:52:11 <stepcut> elliott_: I blame it on the GPL :p
10:52:29 <applicative> well, it's inevitable given the....
10:52:33 <elliott_> stepcut: well, the github issue is still pretty stale... you could leave a comment and ask whether the highlighting-kate stuff could be split out
10:52:33 <applicative> like stepcut said
10:52:49 <elliott_> easier than rewriting the thing
10:53:29 <burbul> What I'm after is more compact ways of writing things like
10:53:31 <burbul> fact_union = do {string "%FACT_UNION("; whites; f <- fact; punct ","; f' <- fact; punct ")"; return $ FactUnion f f'}
10:53:45 <applicative> stepcut: i will join your team if you come up with some really cool theoretical idea about it :)
10:53:46 <stepcut> elliott_: yeah. But in my case, I want a markdown parser that you can add arbitrary extensions too
10:54:16 <applicative> stepcut: I take it you've seen https://github.com/jgm/pandoc2
10:54:18 <stepcut> applicative: the cool theoretical idea would be about how to make it so that you can add additional parsers
10:54:18 <elliott_> applicative: interestingly enough, markdown parsing is comonadic, and the extensions form a category
10:54:41 <applicative> elliott_: awesome! i'm in!
10:54:42 <stepcut> applicative: nope.. what should I be seeing?
10:55:27 <stepcut> i note that pandoc2 is still GPL
10:55:38 <otters> is a comonad like a reverse monad?
10:55:42 <shapr> coGPL
10:55:51 <applicative> i think the monadicness of the type is meant to help with that
10:56:45 <fmap> burbul: applicative style?
10:56:55 <fmap> not sure if it'll be more compact though
10:57:32 <burbul> fmap: is that the operators like <* ?
10:57:39 <fmap> yes
10:58:06 <applicative> stepcut: maybe its not that interesting, more oriented toward potential inclusion of io etc https://github.com/jgm/pandoc2/blob/master/Text/Pandoc2/Parsing/PMonad.hs
10:58:09 <burbul> I keep meaning to learn about data.Applicative and data.functor
10:58:14 <applicative> stepcut: forget it
10:58:35 <burbul> There is just much less about them than about monads on the web
10:58:54 <Siod> is there a better way of doing this: http://ideone.com/2ED8c
10:58:54 <burbul> Should I just look straight at the source?
10:59:19 <burbul> Or are there conceptual things to pick up?
10:59:33 <fmap> burbul: there were some nice tutorials on applicative parsers
11:00:14 <burbul> Google -> http://www.cs.tufts.edu/~nr/cs257/archive/doaitse-swierstra/combinator-parsing-tutorial.pdf
11:00:18 <burbul> Thanks!!
11:02:05 <fmap> burbul: i'd recomment this post http://www.serpentine.com/blog/2008/02/06/the-basics-of-applicative-functors-put-to-practical-work/
11:02:10 <applicative> stepcut: if you have an idea about easy extensibility it would interest me, I've thought about frequently just because it comes up so often
11:02:11 <fmap> but it's rather outdated
11:02:38 <stepcut> applicative: k. I won't have any ideas until I actually start work
11:03:02 <fmap> since Applicative instance for GenParser is built-in nowadays
11:03:03 <applicative> stepcut, yes i figured ...
11:03:27 <burbul> thanks!
11:03:38 <burbul> Regarding the outdatedness, presumably I just skip the instance declarations.
11:04:42 <Siod> how do i update a record using existential quantification
11:05:20 <Siod> i want to update one field and i get "Record update for insufficiently polymorphic field"
11:05:37 <applicative> with a polymorphic function
11:05:46 <Siod> that's if i use an already defined record; it works with a new record constructor
11:06:29 <lazyfinn> hey, guys, I was here yesterday asking for nested foreach loops in haskell, I got the idea when I return a list, but what if I want to update a record inside a nested loop? I'll post the example
11:06:33 <hpaste> lazyfinn pasted “nested foreach” at http://hpaste.org/69609
11:06:38 <Siod> applicative: how do you mean?
11:06:52 <Siod> updateState p s = p { pluginState = s}
11:06:58 <Siod> has the same problem
11:07:09 <parcs`> burbul: the Text.Parsec.Token module automatically tokenizes the input so you don't need explicit 'whites' calls. it also provides a 'parens' combinator that parses parens around a given parser
11:09:19 <gwern> @quote
11:09:20 <lambdabot> v_ says: C++ is a pitfall-based language
11:11:04 <hpaste> fmap annotated “nested foreach” with “nested foreach (annotation)” at http://hpaste.org/69609#a69610
11:11:44 <smithw> @type ap
11:11:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
11:12:51 <lazyfinn> wow, a nested map
11:13:12 <lazyfinn> didn't know I can do that
11:13:21 <lazyfinn> thanks
11:13:26 <mekeor> how can i check whether a string is readable as a Double? i'm using this at the moment but it doesn't work correctly:   \s -> not (null (reads s :: [(Double,String)]))
11:14:50 <mekeor> @let f s = not (null (reads s :: [(Double,String)]))
11:14:52 <lambdabot>  Defined.
11:14:56 <mekeor> > f "123x123"
11:14:57 <lambdabot>   Ambiguous occurrence `f'
11:14:57 <lambdabot>  It could refer to either `L.f', defined at <local...
11:14:58 <bitonic> Siod: http://hackage.haskell.org/trac/ghc/ticket/2595
11:15:09 <mekeor> @let readable s = not (null (reads s :: [(Double,String)]))
11:15:10 <lambdabot>  Defined.
11:15:14 <mekeor> > readable "123x123"
11:15:16 <lambdabot>   True
11:15:28 <mekeor> lambdabot: why??!
11:15:45 <fmap> > reads "123x123" :: [(Double, String)]
11:15:46 <lambdabot>   [(123.0,"x123")]
11:15:48 <dmwit> mekeor: Because it reads a bit and returns both the read value and the unread bits.
11:15:51 <bitonic> Siod: specifically:
11:15:53 <bitonic>   The restriction is that
11:15:54 <bitonic>     The types of the updated fields may mention only the
11:15:57 <bitonic>     universally-quantified type variables of the data constructor
11:16:13 <mekeor> dmwit, fmap: so what can i do?
11:16:28 <dmwit> > let readable s = any (null . snd) (reads s :: [(Double, String)]) in readable "123x123"
11:16:31 <lambdabot>   False
11:16:37 <hpaste> applicative pasted “oleg+spj class Mutation” at http://hpaste.org/69611
11:16:50 <dmwit> mekeor: Or just use reads directly instead of read. =)
11:17:07 <mekeor> dmwit: thank you, dude! thanks, really, man!
11:17:34 <applicative> Siod there is some peculiarity about record update i guess.  this works ^^^ though mislabelled
11:18:10 <Siod> mother of god
11:18:13 <Siod> :)
11:18:27 <Siod> thanks for your help guys
11:22:28 <burbul> parcs`: breaking input into tokens sounds  interesting, if it doesn't slow things down too much. (THough I thought that Parsec was meant to be a scannerless parser...). I'll look into it; thanks!
11:23:02 <parcs`> burbul: behind the scenes it just does exactly what you're doing, calling 'whites' after every token
11:24:07 <otters> How do you upgrade cabal itself
11:26:02 <burbul> ah, ok
11:26:08 <dmwit> otters: cabal install cabal-install --reinstall
11:26:18 <otters> oh what a fun line
11:26:20 <dmwit> otters: or did you mean Cabal the library?
11:27:06 <otters> dmwit: sorry, I did mean the library
11:27:18 <otters> that would just be cabal install cabal I assume
11:27:39 <dmwit> I think cabal-install is case sensitive, so then
11:27:42 <dmwit> cabal install Cabal --reinstall
11:27:50 <otters> it isn't
11:28:35 <geekosaur> cabal-the-library is a bootlib; reinstalling it is likely to break the compiler
11:28:47 <dcoutts_> dmwit: it's not case sensitive unless there's a name clash
11:29:35 <dmwit> That's really nice.
11:29:44 <Peaker> I really wish GHC could tell me "Your type signature isn't the most general one"
11:29:52 <otters> the new version of cabal-install requires unix-2.4.2 which requires base < 4.4
11:29:57 <otters> but I have base 4.5
11:29:58 <dmwit> I guess downloading everything Hackage knows about each package is what enables that, not any support from Hackage.
11:29:58 <otters> hmmmmm
11:30:12 <dmwit> otters: Well, you definitely don't want to reinstall unix or base.
11:30:22 <dmwit> Maybe upgrade GHC?
11:30:32 <otters> ghc is version 7.4.`
11:30:35 <otters> 7.4.1*
11:30:53 <lazyfinn> fmap: in response to this: http://hpaste.org/69609#a69610 ghc gives the error: "Couldn't match expected type `Passenger' with actual type `[b0]' In the return type of a call of `map'" tha's about the inner map
11:31:22 <Peaker> cabal install cabal-install ?
11:32:07 <otters> the funny thing is
11:32:26 <otters> cabal-install 0.14 requires unix >= 1.0 && < 2.6
11:32:35 <otters> nowhere on hackage does it say it requires < 2.4
11:32:36 <otters> and I have 2.5
11:33:01 <hayashi> Say I've got a list of [IO (Maybe a)] and I want to perform those IO operations left-to-right but stop as soon as I hit a Just.  Is there any nice way of doing this?
11:33:11 <fmap> lazyfinn: I'd guess your need to wrap the result of second map into Passenger again
11:33:25 <hayashi> (I've tried playing with msum/mplus etc, but that causes _all_ of those IO operations to be evaluated before returning the first one to hit Just)
11:33:35 <c_wraith> otters: it probably depends on an already-installed version of a package that depends on <2.4
11:33:39 <lazyfinn> fmap: what if I want to return [Passenger]?
11:34:24 <hayashi> *stop and return the IO-wrapped value of the first Just
11:36:00 <hpaste> fmap annotated “nested foreach” with “nested foreach (annotation) (annotation)” at http://hpaste.org/69609#a69612
11:36:20 <barrucadu> hayashi: head/filter, maybe?
11:36:29 <barrucadu> Wait, no
11:37:14 <fmap> lazyfinn: I guess data Vehicle = Vehicle { passengers :: [Passenger] } here
11:37:41 <startling> can I use record syntax to satisfy a typeclass?
11:37:46 <lazyfinn> fmap: yes
11:38:51 <barrucadu> hayashi: getFirstJust (x:xs) = do { thex <- x; case thex of { Nothing -> getFirstJust xs ; _ -> return thex }} - does this work?
11:39:20 <startling> e.g, could I have "data Something = {show :: String}" and then make Something an instance of Showable?
11:39:42 <startling> that's a simplification, but you know.
11:39:46 <hayashi> I suppose that would work, I was just wondering if there was a nice existing way of doing it ._.
11:41:53 * hackagebot scotty 0.4.3 - Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp  http://hackage.haskell.org/package/scotty-0.4.3 (AndrewFarmer)
11:42:52 <lazyfinn> fmap: but i meant I want to return [Passenger], the "passengers" list in pseudocode, not the field passengers inside Vehicle record
11:43:38 <barrucadu> @@ @pl @undo getFirstJust (x:xs) = do { x' <- x ; if isJust x then return x else getFirstJust xs}
11:43:38 <lambdabot>  getFirstJust = fix ((`ap` tail) . (. head) . liftM2 (.) (>>=) . ((const .) .) . flip ((.) . liftM2 if' isJust return))
11:43:47 <barrucadu> hayashi: Woo, obfuscation!
11:44:04 <lazyfinn> fmap: or.. wait, I'm confused here :)
11:44:21 <ocharles> barrucadu: wow :)
11:50:21 <fmap> lazyfinn: It might be helpful to start function definition with its type
11:50:32 <fmap> and yes, nested maps are certainly confusing
11:51:53 <Peaker> nested maps like  (map . map . map) ?
11:52:15 <c_wraith> yeah, like that
11:52:31 <startling> so I've got a typeclass and another one extending it. Can I make the extending typeclass provide a default for a function that the superclass requires?
11:52:49 <c_wraith> not generally
11:52:58 <burbul> There's something a bit unpleasant about having to break symmetry and choose between these two options...
11:53:03 <burbul> fixed_flow1    = liftA2 FixedFlow pform (punct "=" *> rule_exp)
11:53:03 <burbul> fixed_flow2    = liftA2 FixedFlow (pform <* punct "=") rule_exp
11:53:10 <startling> c_wraith: darn. :/
11:53:11 <burbul> Is there a nice 'neutral' option?
11:54:16 <burbul> I want to be able to write something like 'fn [pform, ignore $ punct "=", rule_exp]'
11:54:44 <burbul> Or really anything that doesn't force me to  artificially bracket the punctuation with one argument or the other.
11:58:51 * mekeor is hacking on a project for which functional programming fits perfectly! YAY!
12:01:51 <hpaste> lazyfinn pasted “nested foreach” at http://hpaste.org/69613
12:01:59 <lazyfinn> fmap: here is what I meant
12:02:30 <JamesRustle> what is line 15 supposed to do?
12:02:33 <lazyfinn> got alittle confused with all these records and fields
12:02:43 <burbul> @src (<*>)
12:02:44 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
12:02:57 <dmwit> barrucadu: getFirstJust = catMaybes
12:03:05 <lazyfinn> JamesRustle: talking to me?
12:03:08 <JamesRustle> lazyfinn: yes
12:03:40 <lazyfinn> JamesRustle: update field "inVehicle" in list "passengers"
12:03:46 <Eduard_Munteanu> mekeor: what would that be?
12:03:51 <lazyfinn> JamesRustle: set to -1
12:03:57 <JamesRustle> lazyfinn: but you can't modify fields
12:03:59 <Taneb> Is there a place where I can ask questions about Haddock without annoying everyone in the channel?
12:04:16 <byorgey> burbul: (<*>) is a method of the Applicative type class.
12:04:39 <lazyfinn> JamesRustle: sure I can, that's why I want to return updated version
12:04:45 <JamesRustle> lazyfinn: no, you can't
12:05:08 <lazyfinn> JamesRustle: I've dove that before
12:05:12 <lazyfinn> done*
12:05:32 <JamesRustle> unlikely
12:06:34 <parcs`> why does it take 30 seconds to read 100000 unique TVars in a single transaction vs 0.02 seconds to read a unique TVar in 100000 separate transactions?
12:06:38 <lazyfinn> what stops me from modifying fields? there is a syntax for that
12:07:09 <burbul> byorgey: thanks. I've picked up what I need from hoogle.
12:08:05 <Eduard_Munteanu> parcs`: contention > locking overhead perhaps?
12:08:22 <JamesRustle> lazyfinn: no, there isn't
12:08:41 <dmwit> no locking in STM; the overhead is from checking logs
12:08:50 <Taneb> lazyfinn, I'm probably missing something, do you mean Record syntax?
12:09:02 <lazyfinn> Taneb: yes
12:09:08 <lazyfinn> it's in the code
12:09:08 <Taneb> lazyfinn, as in, Foo {bar = 10; baz = True}
12:09:15 <Taneb> Isn't strictly modifying
12:09:31 <parcs`> Eduard_Munteanu: no concurrency, just a single thread reading the vars
12:09:45 <Taneb> It gives you a new thing with those values
12:09:46 <dmwit> parcs`: You might want to look at the paper. I vaguely recall that there's something or other that's O(n^2) in the length of the access log.
12:10:47 <byorgey> yeah, the first one is going to generate a monstrously large log.
12:11:04 <lazyfinn> Taneb: that's what I mean, that's why I'm returning it
12:11:05 <byorgey> which is not a typical scenario for STM.
12:11:20 <JamesRustle> lazyfinn: you're not returning things
12:11:25 <dmwit> parcs`: Or as a quick test try reading a tenth as many TVars in a single transaction and see if it's 100x faster, then you'll know. =)
12:11:30 <lazyfinn> Taneb: just need a little help translating this http://hpaste.org/69613 to haskell :)
12:11:56 <lazyfinn> JamesRustle: please, stop this demagogy
12:12:25 <JamesRustle> but that's the core of your problem
12:12:59 <parcs`> reading 100k TVars @ 10k TVars per transaction takes 1s
12:13:18 <dmwit> That's even more than 100x faster, then.
12:13:23 <burbul> Is there a way to write this without the (outer) brackets?
12:13:24 <burbul> InheritPForms <$> (string "✱" *> punct "←" *> sepBy int (punct ","))
12:13:52 <parcs`> dmwit: oh right, because you divide by 10
12:13:57 <dmwit> right =)
12:14:14 <Taneb> lazyfinn, I have no idea what that code does
12:15:28 <parcs`> dmwit: thanks :)
12:17:56 <Taneb> But yeah, I came here because I'm having a spot of bother with Haskell
12:18:01 <Taneb> By which I mean Haddock
12:18:24 <dmwit> I think haddock questions are on-topic here.
12:18:32 <Taneb> Okay, I'll ask
12:18:42 <startling> question: I have a data type which should have a parameter that is an instance of a certain typeclass. how do I show this in the type declaration?
12:18:43 <Taneb> I'm writing the docs for a module someone else has written
12:19:28 <geekosaur> SomeClass a => Maybe a
12:19:29 <dmwit> startling: Best practice is to put that restriction on functions using the data, not on the type itself.
12:19:35 * hayashi eventually ends up with foldl (\a b -> a >>= (maybe b (return . Just))) (return Nothing) as the answer to his question of earlier.
12:19:40 <Taneb> In his coding style, with braces and semicolons everywhere, I can't get it to work for Class documentation, possibly others, but if I restyle it so it doesn't have so many braces and semicolons, it works fine
12:19:47 <dmwit> Or even non-functional values, as geekosaur rightly points out.
12:19:48 <geekosaur> but ==dmwit that's on the function, not the type declaration
12:19:50 <Clint> startling: you need a ghc extension for that
12:20:38 <startling> dmwit, not sure what you mean
12:20:40 <dmwit> :t foldl (\a b -> a >>= maybe b (return . Just)) (return Nothing)
12:20:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m (Maybe a)] -> m (Maybe a)
12:21:20 <startling> oh, i see what you mean I think
12:21:29 <Taneb> :t foldlM
12:21:30 <lambdabot> Not in scope: `foldlM'
12:21:36 <Taneb> :t Data.Foldable.foldlM
12:21:38 <lambdabot> forall a b (m :: * -> *) (t :: * -> *). (Data.Foldable.Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
12:24:45 <dmwit> :t let f [] = return Nothing; f (m:ms) = do { v <- m; case v of { Nothing -> f ms; Just _ -> return v } } in f
12:24:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m (Maybe a)] -> m (Maybe a)
12:25:56 <hpaste> Taneb pasted “Haddock probs” at http://hpaste.org/69615
12:26:14 <dmwit> :t foldr
12:26:15 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
12:26:17 <Taneb> Can someone who's better at Haddock than me look at that, please?
12:26:30 <startling> alright, i still don't think I understand. how would I do something like this, for example? https://gist.github.com/42f2fa385b35c4e7ffa5
12:27:27 <JamesRustle> Taneb: error message?
12:28:02 <dmwit> startling: Is that second one supposed to be a "data" instead of a "class"?
12:28:12 <startling> dmwit: er yes
12:28:17 <dmwit> startling: If so, "data Container a = Container { contained :: Contained a }" seems fine.
12:28:32 <dmwit> startling: Or just "data Container = Container Int" if you want to forget what the "a" was.
12:28:37 <Taneb> JamesRustle, "parse error on input 'class'"
12:28:55 <JamesRustle> dmwit: Contained a doesn't seem fine to me
12:29:00 <JamesRustle> dmwit: Contained is not a type
12:29:05 <dmwit> Yes, I am an idiot.
12:29:07 <startling> dmwit: yeah, Not in scope: type variable `a'
12:29:15 <dmwit> "data Container a = Container a" is what I really meant.
12:29:24 <startling> oh hmmm
12:29:27 <startling> interesting
12:29:31 <dmwit> "data Container a = Container { contained :: a }"
12:30:10 <startling> yep, that's what I want. I'm just terrible at expressing it. thanks!
12:30:41 <Taneb> JamesRustle, any ideas?
12:30:45 <dmwit> or possibly just "type Contained a = a". ;-)
12:31:02 <JamesRustle> Taneb: no
12:31:05 <Taneb> :/
12:31:08 <dave404e> hi
12:31:11 <startling> well, I have a handful more parameters in ym actual code
12:31:17 <Taneb> Hello
12:31:26 <dave404e> :)
12:31:37 <dmwit> startling: okay, right
12:35:16 <ocharles> hrm, is there anything that will take Maybe (Maybe a) -> Maybe a, but also Maybe a -> Maybe a?
12:37:45 <dave404e> guys please help me take decision , which to start learning haskell , or erlang .. does they make the same object? which is cleaner ,refined, easier ,productive , "better " ? please .. ? :)
12:37:59 <ocharles> dave404e: we can't answer that without knowing what you want to do
12:38:14 <dave404e> just answer :)
12:38:18 <dave404e> please .
12:38:25 <Clint> yes
12:38:26 <ocharles> dave404e: there is no answer to that
12:38:28 <Taneb> I don't really know Erlang at all, so I'm saying Haskell
12:38:37 <Taneb> Devil you know, you know
12:38:46 <dave404e> ok
12:38:47 <S11001001> dave404e: look where you're asking
12:38:53 <ocharles> dave404e: if one was all around better, the other wouldn't existing
12:38:58 <ocharles> exist*
12:39:06 <S11001001> ocharles: you're assuming perfect information
12:39:08 <dmwit> ocharles: nuh-uh, brainfuck exists
12:39:20 <dave404e> im just a beginner .. where should i ask it ?
12:39:21 <S11001001> not an economist by any chance?
12:39:34 <ocharles> S11001001: mathematician, i assume nothing but perfect!
12:39:35 <ocharles> :)
12:39:40 <ocharles> aspiring*
12:39:56 <Taneb> dmwit, brainfuck is very good for making derivatives of, apparently.
12:40:05 <dave404e> lol
12:40:09 <Taneb> (yeah, I'm a native of #esoteric)
12:40:37 <mwcampbell> I'm new to Haskell. Do I understand correctly that one can determine whether a function has side effects simply by looking at its type?
12:40:49 <dmwit> mwcampbell: correct
12:41:02 <Taneb> mwcampbell, if its type mentions IO, it has side effects.
12:41:02 <S11001001> dave404e: probably you should research both until one more strongly strikes your fancy, then go with that 'til you get bored, and then do the other
12:41:33 <ocharles> dave404e: imo, haskell is better suited for 'general' programming, while erlang's strength is in servers and long running/stable stuff
12:41:42 <ocharles> but i have no erlang experience, only haskell
12:41:43 <mwcampbell> And conversely, if a function's type does not mention IO, it doesn't have side effects?
12:41:52 <dmwit> mwcampbell: (In fact, some might argue that one can determine whether a function has side effects without even looking at its type by simply answering "no".)
12:42:09 <ocharles> dmwit: or always "yes" because the cpu gets a little bit hot :)
12:42:10 <coppro> ocharles: Erlang is also good for any sort of program that is modeled easily as lots of small components communicating with each other
12:42:11 <Taneb> mwcampbell, if it does, it was written by a nasty person
12:42:20 <coppro> ocharles: like GUI
12:42:22 <S11001001> dmwit: I would be one of those :)
12:42:24 <coppro> each control is its own thread
12:42:28 <coppro> (well, Erlang process)
12:42:29 <dmwit> S11001001: So would I. =)
12:42:30 <dave404e> i know .. i thing i will find it  in haskell :)
12:42:38 <Taneb> mwcampbell, a nasty person who was nasty
12:43:02 <scooty-puff> i'm having a lot of trouble using haskeline to create a password prompt on windows
12:43:03 <ocharles> coppro: ah, good to know. it's on my list of "dabbles", but no spare tuits atm
12:43:13 <dmwit> mwcampbell: I think Taneb is being a little bit misleading.
12:43:23 <Taneb> Yeah, I almost certainly am
12:43:31 <dmwit> mwcampbell: You can form larger types that contain IO in them, but don't contain the text "IO". These can have side effects, too.
12:43:35 <coppro> ocharles: I recommend LYSE
12:43:45 <dmwit> mwcampbell: (In at least the same sense that IO types can have side effects, that is to say... not really.)
12:44:11 <dmwit> mwcampbell: It's a bit tricky at first, but here's the distinction I'm trying to make:
12:44:30 <dmwit> mwcampbell: A value of type "IO a" should be thought of as a list of steps to perform to compute a value of type "a".
12:44:56 <dave404e> i have the book learn you a haskle its cool :)
12:44:59 <dmwit> mwcampbell: This list is created without actually performing those steps.
12:45:21 <dmwit> mwcampbell: Then, there is one special list (named "main") which, after constructing the list of steps, actually goes ahead and performs those steps, too.
12:45:36 <dmwit> mwcampbell: As a quick example, take "putStrLn :: String -> IO ()".
12:46:19 <dmwit> mwcampbell: You should not think of this as taking a string and doing some IO; you should think of this as taking a string and making the list of steps that contains a call to put the string on the console.
12:46:53 <dmwit> mwcampbell: Every time you call putStrLn "foo", it always returns exactly the same list of steps to take, with no side effects.
12:47:05 <dmwit> mwcampbell: BUT if that list appears somewhere in "main", then the side effects finally happen.
12:47:25 <dave404e> guys can u use haskell for web?
12:47:25 <dmwit> mwcampbell: One of the benefits of thinking this way is that it means you can make even more exciting types, like
12:47:39 <barrucadu> Yes. Yesod, Snap, and Happstack are some popular frameworks
12:47:46 <dmwit> type X = StateT StateOfTheXServer IO
12:48:12 <dmwit> mwcampbell: Then a value of type "X ()" is a recipe for communicating with the X server (and possibly taking some IO actions in the recipe).
12:48:43 <dmwit> (specifically, some non-X-server-related IO actions)
12:48:56 <dave404e> thanks
12:49:24 <mwcampbell> dwmit: Thanks for the explanation.
12:49:25 * Clint blinks.
12:49:37 <barrucadu> Exciting
12:49:50 <dmwit> irccloud seems to be having some problems =)
12:51:28 <mwcampbell> dmwit: So if a function's return type is "String", then it doesn't provide any instructions for doing I/O, and therefore won't directly result in any I/O being done if called from main
12:51:34 <dave404e> thnx barrucadu :) . bye guys
12:51:36 <startling> alright, hmm, why do lines 15 - 18 error? https://gist.github.com/941ffb43648dbe683127
12:51:38 <dmwit> ...*anyway*, the upshot of all this is that anything that wishes it could do side effects has to return a recipe instead and hope main asks them to actually take those steps. So anything that could eventually have side effects will say so in its type. =)
12:51:45 <dmwit> mwcampbell: right
12:53:15 <dmwit> startling: Perhaps you need something like instance Windowable f => Windowable (Framed f)
12:53:45 <shirt> > round (1/0)
12:53:46 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
12:53:49 <shirt> > round (1/0) :: Int
12:53:50 <lambdabot>   0
12:54:23 <dmwit> shirt: the source of some confusing bugs... I hope this isn't the end of a long chain of investigation for you
12:54:39 <deggis> understanding what's side effects and what's laziness and what's both requires a moment of one's time :)
12:54:41 <mwcampbell> I hope lambdabot is using some kind of safe Haskell subset
12:54:52 <dmwit> mwcampbell: We invite you to try to crash it. =)
12:55:08 <dmwit> > let loop = loop in loop
12:55:12 <shirt> dmwit: no, i checked this before going down a path that might have potentially led to a long chain of investigation :)
12:55:12 <barrucadu> > 1/0
12:55:12 <lambdabot>   mueval-core: Time limit exceeded
12:55:13 <lambdabot>   Infinity
12:55:22 <startling> dmwit: weird. mind explaining why that works?
12:55:24 <dmwit> shirt++ for foresight
12:55:26 <barrucadu> Ok, so rounding infinity gives a big number >.>
12:55:51 <startling> a pointer to relevant docs is just as good, too
12:55:56 <shirt> > 1/0 :: Double
12:55:57 <lambdabot>   Infinity
12:56:03 <barrucadu> Wait, surely 1/0 should be undefined, not infinity
12:56:11 <dmwit> startling: Well, you're calling "atPosition" (and friends) on a value of type "f". For that to work, you need to know that "f" is Windowable.
12:56:17 <dmwit> startling: end of explanation (?)
12:56:27 <shachaf> > 1/0 :: Rational
12:56:28 <lambdabot>   *Exception: Ratio.%: zero denominator
12:56:29 <startling> oh, alright
12:56:44 <Taneb> Infinity < 10^310
12:56:45 <startling> I'm not really sure how the => denotes that, though
12:57:00 * hackagebot wai-middleware-static 0.1.1 - WAI middleware that intercepts requests to static files.  http://hackage.haskell.org/package/wai-middleware-static-0.1.1 (AndrewFarmer)
12:57:22 <dmwit> startling: Alternate explanation: you're trying to build a Windowable typeclass dictionary for Framed f values. To construct it, you need to have access to a Windowable dictionary for f values to call out to.
12:57:52 <startling> ah
12:58:03 <startling> I think I understand. maybe
12:58:04 <dmwit> startling: Oh, that's just syntax. "instance cxt => Class head" says that "head" can be made an instance of class "Class" whenever the constraints in "cxt" are satisfied.
12:58:45 <dmwit> Before you put the context in, you were claiming you could *always* implement the "Windowable" functions for "Framed f", which wasn't true. =)
12:58:59 <startling> ah, right
12:59:06 <startling> makes sense, thanks!
12:59:16 <startling> could I alternatively put a constraint on Framed?
12:59:49 <Taneb> How does Haddock play with fixity declarations for class methods?
12:59:49 <Taneb> (I bet that's a sentence not often uttered)
12:59:49 <dmwit> Yes, but you'd have to use GADTs (and wouldn't be able to use record syntax).
13:00:15 <startling> dmwit: i suppose that's an adventure for another day, then
13:01:14 <hayashi> @pl (\x -> (f . map ($ x)))
13:01:14 <lambdabot> (f .) . map . flip id
13:01:40 <hayashi> another classic pl I suspect
13:02:05 <mwcampbell> So Haskell's approach to containing side effects looks very useful. For example, I'm looking at an open-source document converter called Pandoc, which is written in Haskell. If I look at Pandoc's writeHtmlString function, the return type is String, so I know, without digging into the implementation, that this function has no side effects.
13:02:21 <dmwit> Yes indeed!
13:02:23 <dmwit> We like it a lot. =)
13:05:24 <mwcampbell> Now, let me see if I understand how this combines with lazy evaluation. Taking Pandoc again as an example, the type of the readMarkdown function is ParserState -> String -> Pandoc, where ParserState and Pandoc are simply data structures...
13:05:40 <mwcampbell> In a language with strict evaluation, this would require that the whole file be read at once into a string, then passed into the readMarkdown function...
13:05:58 <mwcampbell> and on the output side, writeHtmlString would do all of its work at once before returning a String
13:06:17 <jfischoff> Has anyone had any luck tracking down <<loop>> with  -fbreak-on-exception un ghci?
13:06:45 <mwcampbell> But if I understand lazy evaluation correctly, it means that the whole string doesn't have to be built up at once in memory
13:07:55 <dmwit> mwcampbell: That's the idea, yeah. Strictness is not as easy to tell just by looking at types, though.
13:08:53 <dmwit> err
13:08:59 <dmwit> laziness isn't really the right term here
13:09:06 <dmwit> strictness neither
13:09:31 <dmwit> Right, so, to explain a bit more:
13:10:07 <dmwit> Reading the file lazily is well and good, provided that you can proceed through the lazy String that's produced one character (or a few characters) at a time.
13:10:39 <dmwit> If you can do that, you're in good shape, because the file reader can lazily produce more characters as you need them and the garbage collector can collect early parts of the string that you no longer need.
13:11:20 <dmwit> Parsec (the parsing library that pandoc uses) tries to be a good citizen in this sense, throwing away as much of the early parts of the string as possible.
13:11:49 <dmwit> But sometimes it's hard. =)
13:12:02 * hackagebot wai-middleware-static 0.1.2 - WAI middleware that intercepts requests to static files.  http://hackage.haskell.org/package/wai-middleware-static-0.1.2 (AndrewFarmer)
13:12:16 <dmwit> That said, I think John MacFarlane is a pretty savvy programmer, so he did probably try to avoid the Parsec features that don't interact well with garbage collection.
13:13:47 <dmwit> Even so, the *parsed* value certainly won't be lazy: Parsec needs finish traversing the whole file before it can produce the first bit (namely, whether there was a parse error or parsing succeeded).
13:22:03 * hackagebot bkr 0.1.1 - Backup utility for backing up to cloud storage services (S3 only right now)  http://hackage.haskell.org/package/bkr-0.1.1 (MichaelSmietana)
13:25:06 <eacameron> what's the easiest way to round a Double to two places after the decimal?
13:25:38 <Siod> anyone here really familiar with wxhaskell?
13:25:39 <yrlnry> floor(d*100)/100 perhaps?
13:25:49 <startling> eacameron, one doesn't really round floats
13:26:00 <yrlnry> That rounds down; for rounding to nearest, use floor(d*100+0.5)/100
13:26:17 <dmwit> yrlnry: or just use "round" instead of "floor" =)
13:26:23 <Siod> how would i create a winghci-like console in wxhaskell
13:26:33 <yrlnry> I couldn't remember if there was a "round".
13:26:37 <Siod> or IDLE-like
13:26:44 <yrlnry> At least my advice was better than starlings.
13:26:50 <dmwit> agreed
13:26:53 <startling> heh
13:27:00 <eacameron> startling: truncate then?
13:27:06 <startling> eacameron, why do you want to do this? for displaying?
13:27:15 <eacameron> startling: exactly!
13:27:20 <dmwit> If it's for display, you might like the Numeric module.
13:27:28 <startling> eacameron, rounding isn't really what you want then
13:27:30 <dmwit> It provides Double -> String conversions with a variety of knobs to twiddle.
13:27:38 <startling> yeah, you probably want that
13:27:42 <JamesRustle> eacameron: printf
13:27:44 <yrlnry> use FFI to connect to sprintf...
13:27:59 <dmwit> > printf "%0.2f" 32.555 :: String
13:28:00 <lambdabot>   "32.56"
13:28:19 <dmwit> printf calls out to Numeric for you. =)
13:28:22 <JamesRustle> s/%0/%/
13:30:06 <dzhus> If I mark a function f1 defined inside another function g with INLINE pragma and then return f1 as g's result, will it be inlinable?
13:31:33 <dmwit> I am not an expert but: no, mark g with INLINE.
13:31:39 <dzhus> like this http://hpaste.org/69616
13:32:05 <dmwit> You probably have to mark both, actually.
13:32:59 <dmwit> You could -ddump-simpl or whatever and check whether it's inlined. =)
13:53:45 <Siod> in wxhaskell, how do i add a line of text to a textcontrol?
14:00:01 <hpaste> dmwit pasted “Gnome keyrind” at http://hpaste.org/69617
14:01:03 <dmwit> Sorry, mischan.
14:03:37 <burbul> Is there a list somewhere of what characters you're allowed to use in user-defined operators?
14:04:00 <dmwit> Yes, the report specifies.
14:04:23 <burbul> Thanks
14:05:41 <fmap> @where report
14:05:41 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
14:06:07 <burbul> I found it -- and it looks like it has a lot of other interesting things -- thank you.
14:06:18 <startling> how do I install some source code with cabal?
14:06:19 <dmwit> > let ascSymbol = "!#$%&*+./<=>?@\\^|-~:"; uniSymbol = filter (\x -> isSymbol x || isPunctuation x) \\ special \\ "_\"'"; special = "(),;[]`{}"; symbol = ascSymbol ++ uniSymbol in symbol
14:06:20 <lambdabot>   Precedence parsing error
14:06:20 <lambdabot>      cannot mix `Data.List.\\' [infix 5] and `Data...
14:06:28 <dmwit> whoops
14:06:30 <strager> I'm deriving Data and Typeable using DeriveDataTypeable and StandaloneDeriving, and I'm getting the error: foo.hs: Data.Data.fromConstr
14:06:33 <dmwit> whoopsanyway
14:06:49 <strager> startling: runhaskell Setup.hs configure/build/install ?
14:07:00 <dmwit> startling: "cabal install" should do it
14:07:05 <startling> dmwit: thanks
14:07:06 <strager> Or use cabal-install and do the same; cabal configure/build/install
14:07:13 <startling> strager: oh nice
14:07:31 <startling> yeah, I just want to make sure it's cabal-installable
14:07:40 <dmwit> "cabal install" is preferable to "cabal configure/build/install"
14:07:55 <dmwit> "cabal install" will ignore any configuration options sent to "cabal configure"
14:08:38 <strager> Oh really?  =[
14:08:45 <dmwit> yarly
14:09:05 <strager> startling: If there's Setup.hs and/or? a foo.cabal file somewhere, cabal-intall can install it
14:09:13 <strager> (or try to)
14:09:34 <dcoutts> dmwit: mm, that is annoying isn't it
14:09:58 <dmwit> a bit =)
14:11:08 <startling> um, "cabal: There is no installed version of base"
14:11:08 <dmwit> cabal configure/build/register seems pretty similar to cabal install (but without the constraint-solving bit), though
14:11:21 <startling> what does that tell me?
14:12:08 <dmwit> startling: Strange, I haven't seen that one before. Is that the whole error?
14:12:27 <startling> it says "Resolving dependencies..." first. that's it
14:13:00 <strager> startling: ghc-pkg list; anything appear there?
14:13:01 <dmwit> What does "ghc-pkg list base" say?
14:13:09 <dmwit> Possibly also "ghc-pkg check" may be worth looking at.
14:14:00 <mgsloan> sclv: Alright, I'm going to take the stackoverflow comments and reddit post down
14:14:17 <mgsloan> I should have known better than to get in to sleep-deprived comment fights
14:14:18 <startling> looks like it's in there: http://bpaste.net/show/RS5axKiPH6ibmzlDmudz/
14:14:36 <startling> check doesn't say anything
14:14:58 <mgsloan>  but, screw stackoverflow conventions - these sorts of discussions are interesting, and their markup format doesn't do a bad job at it
14:22:19 <startling> other stuff from cabal seems to compile fine. isn't that really odd?
14:23:43 <dmwit> I've got to run, but your next step should probably be to post your .cabal file on hpaste or similar.
14:26:09 <startling> here's my .cabal file: http://bpaste.net/show/3xwTolYGnFqe5FwvR77V/
14:30:45 <burbul> Is there a way to write
14:30:46 <burbul> string "✱" *> punct "←" *> string "?" *> return Forgive
14:31:05 <burbul> With the constructor (Forgive) on the left, so it looks more like a
14:31:19 <burbul> a application of <$>, as in     AllFromChildren <$> (string "✱" *> punct "←" *> int `sepBy` punct ",")
14:33:11 <dmwit> string "a" *> punct "b" *> Forgive <$> int `sepBy` punct "," -- ?
14:33:18 <parcs`> Forgive <$ (string "*" *> ... *> ...)
14:33:40 <burbul> thanks!
14:33:50 <dmwit> startling: I dunno, that cabal file works fine for me once I make an empty Blessings/Core.hs (with just the "module" line) and Setup.hs.
14:33:57 <parcs`> actually you don't need the paren
14:33:59 <burbul> @src (<$)
14:33:59 <lambdabot> (<$) = (<$>) . const
14:39:29 <startling> meh, i should upgrade to the latest haskell-platform anyway. maybe it'll magically fix it
14:57:38 <nand`> What's the difference between (*>) and (>>) other than the type class?
14:58:04 <hpc> compatability with do-notation
14:58:31 <hpc> also, their definitions change if you don't write legal instances
14:58:36 <nand`> right
14:58:44 <nand`> but I meant sane instances
14:58:45 <hpc> aaaaaand, that's it
14:58:49 <nand`> fair enough
15:00:07 <rwbarton> they have different precedence too :)
15:00:14 <augur> man
15:00:15 <startling> ah, found it: http://hackage.haskell.org/trac/hackage/ticket/571
15:00:18 <startling> weird
15:00:33 <augur> ever since someone told me about <- in guards, my haskell code has looked so much better
15:00:49 <hpc> augur: pattern guards?
15:00:55 <augur> hpaste: i guess, yeah
15:01:02 <hpc> yeah, those are awesome
15:01:02 <augur> i never knew about them before. they're so great
15:01:21 <hpc> they're pretty much view patterns on steroids
15:01:31 <nand`> what is this all about?
15:01:42 <augur> im not sure they're view patterns on steroids
15:01:45 <augur> just view patterns
15:01:46 <augur> :p
15:02:17 <augur> nand`: you can do pattern matching in guards
15:02:31 <startling> do you guys have an example?
15:02:38 <augur> so like,    foo x | Just y <- doSomethingTo x = blah
15:02:50 <hpc> augur: view patterns replace parameters with f(param)
15:03:00 <hpc> pattern guards can match on arbitrary expressions
15:03:06 <augur> hpc: maybe we're thinking of different views then
15:03:15 <hpc> maybe
15:03:25 <augur> im just thinking of views as in wadler
15:03:36 * hpc is thinking -XViewPatterns
15:04:03 <parcs`> view patterns eliminate a temporary name that you would otherwise have to provide
15:04:14 <parcs`> and i'm pretty sure view patterns are as powerful as guards
15:04:14 <hpc> yes, that
15:04:58 <parcs`> with boolean guards you can just create a view pattern that creates a tuple and pattern match on True
15:05:07 <parcs`> with pattern guards create a tuple and pattern match on the value
15:05:15 <hpc> parcs`: view patterns can't do foo x y | Nothing <- frobnicate x y
15:05:16 <parcs`> er, s/with/to emulate/
15:05:35 <parcs`> oh right, multiple parameters :(
15:05:52 <hpc> if you mean "create a tuple" as in "uncurry", you are right
15:05:54 <hpc> i think
15:06:06 <hpc> but ew
15:06:31 <parcs`> well if you have foo (x,y) then with view patterns that becomes 'foo ((,) <*> uncurry frobnicate -> ((x,y),Nothing))
15:07:11 * hackagebot not-gloss 0.2.0 - Painless 3D graphics, no affiliation with gloss  http://hackage.haskell.org/package/not-gloss-0.2.0 (GregHorn)
15:07:13 * hackagebot shelly 0.9.7.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.9.7.1 (GregWeber)
15:07:24 <Siod_> how do i get todays date using data.time?
15:07:34 <hpc> getCurrentTime?
15:07:34 <parcs`> > let f x (const x -> y) = (x,y) in f 3 4
15:07:35 <lambdabot>   (3,3)
15:07:38 <parcs`> ooo!
15:07:41 <parcs`> you can do that?
15:07:50 <alpounet> not-gloss? uh
15:07:54 <Siod_> toGregorian :: Day -> (Integer, Int, Int)
15:07:55 <parcs`> therefore viewpatterns _are_ as powerful as guards
15:08:03 <hpc> wait what
15:08:06 <Siod_> and getCurrenTime returns UTCTime
15:08:29 <hpc> oh wow
15:08:41 <alpounet> why isn't that package called "vis"
15:08:44 <Siod_> the old-time library shown in real world haskell made a lot more sense
15:08:46 <alpounet> like the module namespace it uses
15:08:56 <Siod_> the docs are terrible for data.time
15:08:59 <hpc> @hoogle UTCTime -> Day
15:08:59 <lambdabot> Data.Time.Clock utctDay :: UTCTime -> Day
15:08:59 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
15:09:00 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
15:09:15 <c_wraith> Siod_: the docs are fine. You just need to learn to pay attention to the instance lists
15:09:15 <Siod_> ah
15:09:22 <hpc> yeah... i hate working with times no matter the language
15:09:32 <Siod_> instance lists?
15:09:48 <Siod_> the docs are terrible; there should be some examples
15:09:49 <parcs`> > let f (True,Nothing) = () in f (False,undefined)
15:09:50 <lambdabot>   *Exception: <interactive>:3:4-24: Non-exhaustive patterns in function f
15:09:58 <hpc> Siod_: the "this is an instance of Num, this is an instance of ..." things
15:10:00 <parcs`> > let f (True,Nothing) = () in f (undefined,Just ())
15:10:01 <lambdabot>   *Exception: Prelude.undefined
15:10:20 <c_wraith> I've never understood people's obsession with examples.
15:10:55 <Siod_> i think that makes you very strange
15:11:03 <c_wraith> The only times I've wanted examples are when the API makes no sense at all. Good types and clear names are far more useful than examples.
15:11:09 <nand`> examples are good for odd imperative/FFI stuff that expect you to, say, call some initialization functions in a certain order before doing certain things a certain way
15:11:15 <hpc> c_wraith: ideally, people would write the modules themselves from the assumption that people will read the source instead of the docs
15:11:17 <nand`> where the docs don't help much alone with lots of IO () flying around
15:11:37 <c_wraith> nand`: yeah, that's my problem with the ghc api.  worst haskell api I've ever seen :(
15:13:03 <DrPete> that's a little worrying given I just started learning with ghc
15:13:32 <hpc> :t let const (id -> id) = id in const
15:13:35 <c_wraith> DrPete: the ghc api is the library ghc exposes that implements the compiler itself.
15:13:44 <DrPete> ahh, i see
15:13:45 <lambdabot>     Illegal view pattern:  (id -> id)
15:13:48 <c_wraith> DrPete: that's probably not something you'll run into any time soon
15:13:58 <lambdabot>     Use -XViewPatterns to enable view patterns
15:14:00 <DrPete> noted
15:14:09 <hpc> :(
15:15:08 <burbul> Using control operative has made my parsers look much nicer, as well as being way more compact. Thank you all very much!
15:15:22 <burbul> *Control.Applicative   (gah, dictation software)
15:15:49 <burbul> @pl flip ($)
15:15:49 <lambdabot> flip id
15:16:00 <burbul> @pl fold (flip ($))
15:16:00 <lambdabot> fold (flip id)
15:16:31 <hpc> @pl not'in'scope'fold (flip ($))
15:16:31 <lambdabot> not'in'scope'fold (flip id)
15:17:38 <burbul> ah
15:18:01 <burbul> Is there a more idiomatic way of writing 'fold (flip ($))'?
15:18:03 <illissius> c_wraith: I don't really like GHC's code either. though I don't have another Haskell-implemented compiler to compare it to... it's full of un-type-enforced invariants and partial record fields and things like that.
15:18:12 <burbul> @type fold (flip id)
15:18:13 <lambdabot> Not in scope: `fold'
15:18:18 <burbul> d'oh
15:18:24 <burbul> @type foldl (flip id)
15:18:26 <lambdabot> forall a. a -> [a -> a] -> a
15:18:34 <burbul> @pl foldl (flip ($))
15:18:34 <lambdabot> foldl (flip id)
15:19:02 <dropdrive> @type const ()
15:19:03 <lambdabot> forall b. b -> ()
15:22:12 * hackagebot relation 0.2 - A data structure representing Relations on Sets.  http://hackage.haskell.org/package/relation-0.2 (DrewDay)
15:22:19 <otters> const () - the most valuable function ever
15:22:32 <startling> If I have a class deriving Enum, what's the best way to get the position of a certain element? find ((==) whatever) [first .. second]?
15:23:27 <ulidtko> hey, should I use Text.Parsec or Text.ParserCombinators.Parsec ?
15:23:44 <nand`> startling: fromEnum?
15:24:18 <startling> nand`: lovely, thanks
15:24:37 <nand`> why is fromEnum :: Enum a => a -> Int and not Integer or even Integral b => b
15:24:51 <nand`> in general, I see lots of usage of “Int” where it seems inappropriate
15:24:51 <hpc> premature monomorphism
15:24:58 <fmap> ulidtko: the former. the latter is for compatibility with parsec2
15:25:31 <nand`> is there a big performance difference between Int and Integer?
15:25:34 <hpc> that, or a smart move to reduce ambiguous instance errors
15:25:42 <hpc> nand`: depends
15:25:44 <hpc> @src Integer
15:25:44 <lambdabot> data Integer = S# Int#
15:25:45 <lambdabot>              | J# Int# ByteArray#
15:25:49 <nand`> oh
15:25:55 <startling> where are ord and chr again?
15:25:59 <otters> @src Char
15:25:59 <lambdabot> data Char = C# Char#
15:26:07 <hpc> > ord 'b'
15:26:07 <pqmodn> Data.Char.ord etc
15:26:08 <lambdabot>   98
15:26:13 <hpc> > chr 15
15:26:14 <lambdabot>   '\SI'
15:26:14 <otters> @src []
15:26:14 <lambdabot> data [] a = [] | a : [a]
15:26:19 <hpc> oh, where
15:26:21 <ulidtko> fmap: ok, I had exactly this feeling of legacy and choose the former
15:26:44 <nand`> hpc: so there's no reason to use Int instead of Integer if I can?
15:26:48 <ulidtko> why then this doesn't work? type TextIOStream = Stream Text IO Char
15:27:04 <hpc> Int can be optimized more
15:27:27 <hpc> you have a static guarantee that you don't have to resort to GMP to compute a number
15:27:37 <ulidtko> what is "Illegal tuple constraint" anyway?
15:27:43 <hpc> plus, Int can already get pretty damn big
15:27:48 <hpc> > maxBound :: Int
15:27:49 <lambdabot>   9223372036854775807
15:27:57 <otters> > maxBound :: Integer
15:27:58 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
15:27:58 <lambdabot>    arising from...
15:28:01 <otters> oh, silly me
15:28:30 <burbul> Are <$>, <*>, etc. more idiomatic than liftMm/liftAn ?
15:28:40 <parcs`> no
15:28:57 <nand`> liftA* can be useful if you want to eta reduce lots
15:28:58 <startling> otters, pqmodn: thanks
15:29:01 <parcs`> which to use depends on context and aesthetics
15:29:10 <nand`> eg. f = liftA2 foo  vs f x y = foo <$> x <*> y
15:29:45 <otters> startling: what did I do?
15:30:04 <burbul> If you didn't want to eta-reduce, would you tend to favour <$>, <*>?
15:30:29 <startling> otters: @src Char
15:30:36 <otters> oh
15:30:42 <burbul> They seem somewhat more readable to me... I have this urge to go through and rewrite all my old code to use them. But I'm can't decide whether that sensible.
15:30:56 <burbul> *that's sensible
15:31:09 <nand`> burbul: I tend to; especially if I can avoid parentheses that way eg. foo 1 <$> pure 3 <*> bat bar  vs liftA2 (foo 1) (pure 3) (bat bar)
15:31:17 <burbul> thanks!
15:31:42 <nand`> I also prefer <$> over ‘fmap’ most of the time, especially in do notation eg. foo <- bar <$> someAction
15:32:11 <otters> the only thing stopping me from using that is that it's not in prelude
15:32:39 <nand`> yeah; I'll think twice if I don't want to pull in Control.Applicative
15:32:41 <burbul> otters: why does that matter? Surely you are importing lots of other things anyway...
15:32:48 <nand`> eg. for short demos
15:32:56 <burbul> ok
15:33:07 <burbul> Thanks again!
15:33:16 <otters> burbul: not always
15:33:24 <burbul> ok
15:33:28 <otters> but yeah, I might as well go and replace fmap with <$> in my big project
15:33:59 <burbul> I've skipped straight from monads to <$> without understanding 'fmap'... all I know is its equivalent to liftM and liftA
15:34:09 <otters> <$> /is/ fmap
15:34:17 <nand`> > fmap (+1) [1,2,3]
15:34:18 <lambdabot>   [2,3,4]
15:34:19 <burbul> not liftA? ok.
15:34:23 <otters> no
15:34:30 <otters> <$> is just infix fmap, they're equivalent
15:34:34 <burbul> ok
15:34:36 <nand`> liftA and liftM have different constraints on them
15:34:42 <nand`> liftA has Applicative, liftM has Monad
15:34:45 <nand`> <$> and fmap both have Functor
15:34:47 <burbul> if they exist, they're guaranteed to be equal to fmap, right?
15:34:57 <nand`> burbul: they *should* be
15:35:00 <burbul> :)
15:35:16 <rwbarton> guaranteed or your money back
15:37:34 <ulidtko> guys, how do I treat an "Illegal tuple constraint" error?
15:37:38 <hpaste> ulidtko pasted “"illegal tuple constraint" with Parsec ” at http://hpaste.org/69619
15:38:23 <ulidtko> why is that definition illegal?
15:39:26 <ulidtko> or anyway, how to form a simple Stream?
15:39:36 <nand`> what Stream type is that anyway
15:39:43 <ulidtko> that's from Parsec
15:39:54 <nand`> oh
15:39:54 <c_wraith> looks like Stream is a class, not a type
15:39:58 <c_wraith> based on the error message
15:40:07 <ulidtko> oh.
15:40:08 <ulidtko> indeed
15:40:20 <geekosaur> great, so the type messages are weirder now...
15:40:40 <nand`> just needs more (~) and “My brain just exploded”
15:40:41 <c_wraith> what? the error message is saying "you *could* do this now, but you need an extension"
15:41:11 <startling> is there a typeclass to make a thing act like a string?
15:41:17 <hpc> startling: yes
15:41:20 <hpc> startling: you don't want it
15:41:23 <startling> hpc: aww
15:41:25 <nand`> If you ask me, it should print a warning that this may not be at all what you want; if you *don't* have the extension enabled
15:41:34 <startling> hpc, what's wrong with it?
15:41:45 <startling> specifically I have a type for colored strings
15:41:47 <nand`> (ie. by telling you that Stream is a class and not a type in a warning)
15:42:14 * hackagebot shelly 0.9.7.2 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.9.7.2 (GregWeber)
15:42:27 <startling> it'd be cool if I could transparently pass them to putStr et al. or is there a standard thing to coerce a thing to a string? (not Show)
15:42:28 <hpc> startling: the instances of that class aren't really "string-like"
15:42:37 <hpc> namely, the various ByteStrings
15:42:46 <startling> ah, yeah, that's different
15:43:12 <c_wraith> oh.  Show is basically the class for things that can be converted *to* strings
15:43:40 <startling> c_wraith, is it? I thought it was more "things that you can see as strings for nicer debugging and error messages"
15:43:55 <c_wraith> it's both, unfortunately
15:44:20 <startling> hrm. well, for these string-like things, the appropriate "show" would have quotes around it, right?
15:44:25 <ulidtko> well, uhh. So this Stream class has an instance: instance Monad m => Stream [tok] m tok; how do I spell the type which belongs to the Stream class and where m is IO?
15:44:49 <c_wraith> > show (pack "hello" :: T.Text)
15:44:50 <lambdabot>   Not in scope: type constructor or class `T.Text'
15:44:54 <c_wraith> > show (pack "hello" :: Text)
15:44:55 <lambdabot>   Not in scope: type constructor or class `Text'
15:45:05 <c_wraith> ...  what does lambdabot have Text imported as?
15:45:16 <nand`> > show (Data.Text.pack "hello")
15:45:17 <lambdabot>   Not in scope: `Data.Text.pack'
15:45:27 <startling> oh, is typeable what I want?
15:45:39 <ion> @type Text.pack
15:45:40 <lambdabot> Couldn't find qualified module.
15:45:42 <nand`> c_wraith: seems like it doesn't have it
15:45:47 <nand`> based on stock L.hs
15:46:05 <c_wraith> startling: no, Typeable is not at all what you want
15:46:15 <angstrom> is there a GHC extension for polymorphic kinds?
15:46:29 <startling> hm. so there's not a toString typeclass or anything. darn
15:46:41 <nand`> hmm
15:46:46 <geekosaur> er, someone is confused somewhere; that sauys Stream is a type whichis an instance of Monad
15:46:51 <geekosaur> not that it is a class
15:47:01 <c_wraith> angstrom: as of 7.4, yes
15:47:15 * hackagebot graphviz 2999.13.0.3 - Bindings to Graphviz for graph visualisation.  http://hackage.haskell.org/package/graphviz-2999.13.0.3 (IvanMiljenovic)
15:47:21 <angstrom> meh. running 7.0.4 :\
15:47:31 <nand`> > let toString = read . show :: Show a => a -> String in toString (BSC.pack "hello")
15:47:33 <lambdabot>   "hello"
15:47:35 * nand` runs
15:47:36 <ion> angstrom: Why not upgrade?
15:47:49 <startling> man, concatMap is handy
15:48:10 <angstrom> ion: it isn't provided via my package-manager, afaics
15:48:24 <ion> startling: a.k.a. (=<<) :-)
15:48:37 <c_wraith> an out-of-date package manager is no reason to handicap yourself.
15:48:43 <ulidtko> geekosaur: no, Stream is a class, that's fine. But it defines an instance for any Monad, right? And instances are types...
15:48:52 <ion> angstrom: https://gist.github.com/2815423#file_install_ghc_cabal.md
15:48:58 <startling> ion: o rly. huh
15:49:23 <nand`> angstrom: depending on your distro/package manager there may be some non-official haskell repository which has GHC 7.4.1
15:50:53 <burbul> Am I right in thinking that the compiler doesn't 'understand' that a Monad is a Functor?
15:51:15 <burbul> (I tried to use <$> on a monad and it went horribly wrong... .)
15:51:42 <nand`> if Monad were defined as Applicative m => Monad m like it should be, the compiler would
15:52:16 <burbul> Hmm... Google shows various proposals to that effect. Presumably none of them have got anywhere?
15:52:38 <nand`> no idea
15:52:54 <nand`> also where's edwardk when you need him; I still haven't been able to ask him my question about Pointed/Copointed
15:53:13 <ion> @summon edwardk
15:53:13 <lambdabot> Unknown command, try @list
15:53:43 <augur> anyone have a reference for how to make command-line programs that take parameters
15:53:44 <augur> ?
15:54:51 <nand`> augur: there are a few modules for it
15:54:55 <alpounet> augur, there are a few libraries that handle arguments to your program, if that's what you're talking about
15:54:59 <alpounet> like CmdArgs, options
15:55:01 <startling> is there an uncurry for three-tuples?
15:55:05 <angstrom> ion: thanks
15:55:13 <nand`> augur: System.Console.GetOpt is probably the simplest (in my opinion)
15:55:18 <nand`> there's also a package “options”
15:55:19 <augur> hmm. ill get a look
15:55:29 <taylorgb> As I understood it the applicative dependancy wasn't always desired because there are monads where the applicative instance is implemented in terms of monad.
15:56:16 <pooya72> Hello Everybody!
15:56:19 <ion> taylorgb: That doesn’t prevent the dependency, does it?
15:57:26 <nand`> taylorgb: I'm not sure how that's a problem
15:57:47 <taylorgb> I could be mistaken, it was from a long time ago :)
15:57:59 <hpaste> nand` pasted “test” at http://hpaste.org/69620
15:58:29 <nand`> ^ compiles
15:59:03 <taylorgb> Hm, that's true. Must have been something else
15:59:50 <nand`> I think it's just backwards compatibility with monads that don't have an applicative instance
15:59:53 <hpaste> ion annotated “test” with “test (annotation)” at http://hpaste.org/69620#a69621
16:01:38 <nand`> ion: but in the Monad/Applicative example, you wouldn't have to implement either <*> or ap yourself; given the Monad instance
16:02:01 <ion> yep
16:02:17 <fmap> startling: yes, http://hackage.haskell.org/package/tuple-0.2.0.1
16:02:29 <nand`> (doesn't matter either way, since it *does* work)
16:02:36 <ion> yep :-)
16:05:18 <ifnspifn> Heya. If I wanted to make a tree whose children are represented as a list of some data type called Node, and are generated by applying some function to the current Node, how might I go about traversing/representing this?
16:06:11 <nand`> class (Pointed f, Functor f) => Applicative f where ap; class Functor f => Bind f where bind :: (a -> f b) -> f a -> f b; class (Applicative f, Bind f) => Monad f;
16:06:12 <ifnspifn> or perhaps better phrased, is there some built in way of managing a tree whose leaves are determined by applying a function to their parent?
16:06:18 * nand` wonders if this would make any sense
16:07:15 * hackagebot testing-feat 0.1 - Functional enumeration for systematic and random testing  http://hackage.haskell.org/package/testing-feat-0.1 (JonasDuregard)
16:08:19 <startling> damn, I can't even make a list of other types specifically showable, can't I
16:08:26 <startling> *instances of another type
16:13:33 <alpounet> ifnspifn, maybe unfoldTree can help
16:13:43 <alpounet> (from Data.Tree, in the containers package)
16:14:07 <DrPete> hm, what's best practice for if you have to do a lot of string concatenations? e.g. if I have some function that takes data and outputs a giant HTML page
16:14:23 <startling> DrPete: concatMap?
16:14:27 <startling> can I pattern match against a range?
16:14:48 <startling> i could do "| a `elem` [A..B]" but meh
16:15:21 <DrPete> startling: thanks
16:15:22 <Siod_> how do you make `newtype Day = ModifiedJulianDay {toModifiedJulianDay :: Integer} deriving (Eq,Ord)` and instance of FromJSON and ToJSON for aeson?
16:15:35 <Siod_> s/and/an
16:15:54 <nand`> startling: looks like a >= A && a <= B  would be more suited, if you have an Ord instance
16:16:03 <startling> nand`: yeah, that's true
16:16:11 <startling> still kind of clumsy, though
16:16:36 <nand`> so define your own helper function
16:16:51 <nand`> isIn x a b = x >= a && x <= b;   | a `isIn` A B
16:16:59 <startling> I have to do predicates no matter what, though?
16:22:13 <ifnspifn> alpounet: thanks, that's exactly what I was looking for
16:22:39 <alpounet> cool heh
16:23:56 <Siod_> is there a way to make a newtype derive something outside of where it's defined
16:26:13 <Clint> Siod_: how do you want it rendered?
16:26:20 <c_wraith> Siod_: yes, the StandaloneDeriving extension can do that
16:36:38 <startling> I have an operator that where I want "a <x> b c" to be the same as "(<x>) a b c". I can't seem to get the fixity right. Anyone care to help?
16:38:13 <JamesRustle> impossible
16:38:15 <startling> oh, i want really really low precedence. never mind, got it!
16:38:27 <startling> JamesRustle: o rly. infix 0 seems to do it
16:38:33 <JamesRustle> no
16:38:46 <startling> JamesRustle, no?
16:38:49 <JamesRustle> yes
16:38:57 <startling> JamesRustle, care to elaborate?
16:39:06 <JamesRustle> what's unclear?
16:39:09 <c_wraith> function application (whitespace) always takes precedence over infix operations.
16:39:15 <c_wraith> err, infix operators
16:39:53 <c_wraith> (<>) a b c will always parse as (((<>) a) b) c
16:40:15 <c_wraith> a (<>) b c will always parse as ((<>) a (b c))
16:40:19 <startling> so why does it work when I do "infix 0"?
16:40:23 <c_wraith> it doesn't
16:40:25 <JamesRustle> it doesn't
16:40:40 <JamesRustle> c_wraith: your second example is wrong
16:40:43 <JamesRustle> you meant a <> b c
16:40:55 <c_wraith> oh, yes I did
16:41:33 <c_wraith> startling: it's likely you're using some other infix operator in your expression, and that's making it appear to work
16:42:41 <startling> oh hm, works in ghci but nowhere else
16:42:47 <tew88> Is there some place I can go to read Haskell source? In particular, I'm interested to see how types have been made instances of some class(es)
16:42:52 <JamesRustle> it doesn't work in ghci
16:43:12 <JamesRustle> tew88: the documentation usually links to the source
16:47:24 <tew88> JamesRustle: Got it. Thanks.
16:48:16 <strager> tew88: All along Hoogle, there's a "Source" link at the top.  You can also download GHC's source code and see how some things are implemented there.
17:00:42 <mkscrg> what's the defacto package for arbitrary precision reals?
17:02:29 <shachaf> mkscrg: CReal?
17:02:55 <hpc> CReal is the type
17:02:58 <shachaf> That is, "numbers".
17:03:31 <mkscrg> got it
17:03:32 <mkscrg> thanks
17:03:33 <hpc> oh, numbers
17:03:41 <shachaf> Why is DanBurton "maintaining" the package?
17:05:02 <Ike> Who is DanBurton?
17:10:09 <dmwit> shachaf: He isn't. He's just the most recent uploader.
17:10:40 <dmwit> shachaf: "numbers" is the closest thing to a community-maintained package that we've got
17:31:12 <antonv> hello
17:31:41 <dmwit> howdy
17:32:29 <antonv> could anyone recomend the best book on logic, not very thick, so that after reading it I would understand logic, predicate calculus, decution, prolog, type systems and web3.0?
17:32:42 <antonv> around 400 pages desirable
17:32:54 <nand`> How did “web 3.0” slip in there?
17:33:01 <c_wraith> trolling, I'm sure
17:33:03 <antonv> via prolog
17:33:16 <antonv> no trhollign! honestly!
17:33:27 <antonv> the best book on logic?
17:34:29 <antonv> I saw Kleene's book, is there anything better?
17:35:19 <dmwit> not all jokes are trolls =)
17:35:27 <antonv> right!
17:36:11 <antonv> and leavng jokes alone I would appreciate good recomendation
17:36:44 <antonv> maybe not so perfect as i described, but something clean, and easy to read for not a profeccional
17:37:59 <dmwit> I don't know what to recommend, unfortunately. I only took one logic course in college, and the book was horrible. =)
17:38:15 <gienah> antonv: A Logical Approach to Discrete Maths - Gries
17:38:47 <joeyh> huh, my old prof.
17:38:59 <joeyh> I've never seen that recommended in anger before :)
17:39:31 <gienah> joeyh: I really like this book :-)
17:39:39 <Pseudonym> The idea of recommending something in anger sounds passive-aggressive.
17:40:02 <joeyh> I've been meaning to reread it.. rather odd notation though
17:44:05 <shergill> where is the database which is generated by running 'hoogle data' stored?
17:44:33 <hpc> shergill: updatedb && locate hoogle in a shell
17:44:37 <hpc> and it'll be one of those
17:44:55 <c_wraith> it's probably in .cabal/share somewhere
17:45:13 <antonv> gienah: 497 pages, almost my preffered size
17:45:19 <antonv> all 3 reviews are good
17:45:27 <antonv> )
17:45:37 <antonv> starts right from textual substitution
17:45:40 <antonv> thank you!
17:45:50 <amatsu> Is there any danger in using Floating? There's an instance declared for Floating Double, how can I use this over Floating Float?
17:46:05 <gienah> antonv: its an introductory book which is really good on proving stuff, and has some stuff on proving the correctness of programs
17:46:32 <shergill> c_wraith: hpc: thanks
17:46:53 <antonv> gienah: so you know logic? does it give any insights on OOP and classification?
17:47:11 <gienah> antonv: a more mathematical text is Introduct to Mathematical Logic by Mendelson (I haven't read it though)
17:48:25 <gienah> antonv: I'm learning logic, on OOP there is Type Theory
17:48:57 <dzhus> how to beep PC speaker from haskell?
17:49:08 <antonv> good question
17:49:32 <hpc> > text "\BEL"
17:49:43 <hpc> λbot?
17:49:57 <Cale> @bot
17:49:57 <lambdabot> :)
17:52:10 <Cale> amatsu: Double is the default fractional type in the case of ambiguity, so you shouldn't have to do anything special, but if you're worried about it, just add an explicit type signature somewhere
17:52:22 <c_wraith> > 1
17:52:23 <lambdabot>   1
17:52:31 <c_wraith> lambdabot just hates hpc
17:52:39 <amatsu> Cale: thanks for clearing that up!
17:56:57 <dabblego> @kind []
17:56:58 <lambdabot> * -> *
17:57:03 <dabblego> @kind [Int]
17:57:04 <lambdabot> *
17:57:11 <dabblego> @kind [a]
17:57:12 <lambdabot> Not in scope: type variable `a'
17:57:18 <dabblego> @kind forall a. [a]
17:57:19 <lambdabot> *
18:06:40 <nand`> “A ternary relation is a set of unordered triples” <- wait what? Wouldn't it be ordered triples? A binary relation is a set of ordered pairs, after all
18:13:14 <Cale> nand`: Yeah, that's got to be an unfortunate typo
18:13:52 <nand`> odd, this is supposed to be a third edition; nobody picked that up?
18:18:13 <Pseudonym> They could have mean "unordered set".
18:18:31 <nand`> is there any other kind?
18:18:42 <Pseudonym> No, but sometimes it's worth emphasising that.
18:18:55 <Pseudonym> They could also be using nonstandard terminology.
18:19:06 <Pseudonym> Like an undirected 3-graph.
18:19:40 <Pseudonym> An undirected 2-graph (what you know as an "undirected graph") has a set of "unordered pairs" for edges.
18:20:00 <Pseudonym> I agree it's confusing, though.
18:20:32 <dmwit> I would guess the "unordered" refers to the collection of triples not being ordered, as opposed to referring to an individual triple being unordered.
18:20:33 <Eduard_Munteanu> Would that make them "symmetric" ternary relations?
18:20:40 <Pseudonym> Or something, yes.
18:20:59 <nand`> dmwit: that could be it
18:21:26 <nand`> I would have written “a set of unordered ordered triples”, if anything, in that case
18:21:39 <dmwit> heh
18:21:40 <Pseudonym> Because that's far less confusing. :-)
18:21:47 <dmwit> kind of like "non-threaded threads" in my gtk2hs article =)
18:24:45 <otters> what is >-
18:25:04 <otters> -XUnicodeSyntax has a replacement for it and I don't know what it means
18:25:26 <nand`> my guess is “nothing until you define it somewhere”
18:25:49 <dmwit> Something to do with arrows, perhaps?
18:26:02 <otters> huh
18:26:09 <otters> I know -<-
18:26:43 <dmwit> It's not listed in the GHC manual, though -< is.
18:26:55 <otters> what is -<?
18:27:34 <otters> oh, arrow syntax
18:28:01 <nand`> does -XUnicodeSyntax *only* apply to special/reserved Haskell syntax like :: ?
18:28:27 <rwbarton> as opposed to...? Syntax means syntax
18:29:03 <NemesisD> anyone know how i can point ghc at my local cabal-dev directory without having to go through cabal to do it
18:29:03 <nand`> actually, I don't really know what that flag does; let me look it up
18:29:17 <rwbarton> Unicode in identifiers is plain old Haskell 98 (though there are no predefined identifiers containing non-ASCII of course)
18:29:26 <NemesisD> i want to run a quick test program, don't want to install its dependencies globally, don't want to write a package spec for it
18:29:44 <Eduard_Munteanu> nand`: it gives you stuff like → for ->
18:29:52 <Eduard_Munteanu> I mean, it lets you use the former symbol.
18:31:01 <nand`> well, for example; let forall = id in ∀ 5   -- with -XUnicodeSyntax, does this evaluate to ‘5’ as expected?
18:31:35 <nand`> or does it only allow ∀ where “forall” would have special meaning in type signatures already?
18:32:00 <rwbarton> well if you have one of the extensions that makes 'forall' a keyword, it's a syntax error of course
18:32:21 <nand`> really?
18:32:33 <rwbarton> > let forall = id in forall 5
18:32:34 <lambdabot>   5
18:32:37 <rwbarton> hm
18:32:49 <rwbarton> > let t :: forall a. a -> a; t = id in t 5
18:32:50 <lambdabot>   5
18:32:53 <rwbarton> I guess not
18:33:08 <rwbarton> anyways, I would be appalled if your sample program evaluated to 5
18:33:15 <nand`> time to try it
18:33:29 <rwbarton> > let t :: ∀ a. a -> a; t = id in t 5
18:33:30 <lambdabot>   5
18:33:36 <rwbarton> > let forall = id in ∀ 5
18:33:37 <lambdabot>   5
18:33:39 <nand`> haha
18:33:40 * rwbarton dies inside
18:33:59 <nand`> so; if some module exports ∀, that function is impossible to reference? (except maybe with a qualified name)
18:34:03 <rwbarton> > generalCategory '∀'
18:34:04 <lambdabot>   MathSymbol
18:34:32 <nand`> hmm
18:34:38 <rwbarton> i don't really know what that means
18:34:48 <nand`> > let forall = 3; ∀ = 4 in ∀
18:34:49 <NemesisD> or maybe more specifically, how can i tell cabal to look in a specific place for libs
18:34:49 <lambdabot>   Conflicting definitions for `forall'
18:34:50 <lambdabot>  Bound at: <interactive>:1:4-9
18:34:50 <lambdabot>        ...
18:35:09 <rwbarton> apparently it is a valid punctuation-type identifier character
18:35:24 <rwbarton> > let ∀ = 3; ∀ = 4 in ∀
18:35:25 <lambdabot>   Conflicting definitions for `forall'
18:35:25 <lambdabot>  Bound at: <interactive>:1:4
18:35:26 <lambdabot>          ...
18:35:42 <rwbarton> though not with UnicodeSyntax apparently
18:36:20 <rwbarton> Looks like it basically just does a s/∀/forall/g on your source
18:36:30 <nand`> oh, I meant if the module you're importing that other module into has -XUnicodeSyntax enabled during compilation
18:36:39 <nand`> rwbarton: yeah looks like it
18:36:45 <nand`> > show "∀"
18:36:46 <lambdabot>   "\"\\8704\""
18:36:48 <nand`> phew
18:37:03 <rwbarton> > let forallb = id in ∀b 5
18:37:04 <lambdabot>   Not in scope: `forall'
18:37:12 <nand`> ah
18:37:17 <nand`> it inserts a space
18:37:30 * hackagebot lz4 0.1.0.0 - Haskell bindings to the lz4 compression library  http://hackage.haskell.org/package/lz4-0.1.0.0 (MarkWotton)
18:37:35 <nand`> (or at least keeps them distinct as if there was a space)
18:37:37 <rwbarton> > let forallb = id in ∀∀ 5
18:37:38 <lambdabot>   <no location info>: parse error on input `
18:38:05 <rwbarton> i guess it tokenizes and then renames ∀
18:38:29 <nand`> > let forall = id in ∀ ∀ 3
18:38:30 <lambdabot>   3
18:38:37 <nand`> > let forall = id in ∀ ∀3
18:38:38 <lambdabot>   3
18:38:41 <nand`> > let forall = id in ∀∀3
18:38:42 <lambdabot>   <no location info>: parse error on input `
18:39:15 <rwbarton> @let forall = id
18:39:16 <lambdabot>  Defined.
18:39:20 <rwbarton> > L.∀ 3
18:39:21 <lambdabot>   <no location info>: parse error on input `L.
18:39:52 <rwbarton> i guess you can use a qualified name then to refer to an identifier (∀)
18:40:06 * nand` tests
18:41:01 <Eduard_Munteanu> > let ∀∀ = 3; ∀∀ = 4 in ∀∀
18:41:02 <lambdabot>   <no location info>: parse error on input `
18:41:18 <Eduard_Munteanu> So I guess it's not dumb preprocessing.
18:41:22 <rwbarton> that's like writing "let + = 3; ..."
18:41:23 <rwbarton> yeah
18:42:05 <Eduard_Munteanu> > let ∀∀ = 3; ∀∀
18:42:06 <lambdabot>   <no location info>: parse error on input `
18:42:25 <dmwit> That seems like a bug.
18:42:37 <otters> > let (∀∀) = 3; (∀∀)
18:42:38 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
18:43:04 <otters> > let f ∀ b = f b in succ ∀ 3
18:43:05 <lambdabot>   Occurs check: cannot construct the infinite type: t = t1 -> t
18:43:11 <Eduard_Munteanu> > let (∀∀) = (+); 2 ∀∀ 3
18:43:13 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
18:43:15 <hpaste> nand` pasted “UnicodeSyntax” at http://hpaste.org/69625
18:43:21 <rwbarton> you have all forgotten how to haskell :P
18:43:27 <Eduard_Munteanu> Erm.
18:43:30 <Eduard_Munteanu> > let (∀∀) = (+) in 2 ∀∀ 3
18:43:31 <lambdabot>   5
18:43:41 <rwbarton> thanks to our nonsense
18:43:44 <Eduard_Munteanu> > let ∀∀ = 3 in ∀∀
18:43:45 <lambdabot>   <no location info>: parse error on input `
18:43:48 <nand`> my hpaste.org compiles and runs
18:43:49 <otters> oh yeah I totally forgot that ; is wrong
18:43:51 <otters> everybody else was doing it :P
18:43:53 <nand`> hpaste.org paste*
18:43:55 <Eduard_Munteanu> :)
18:44:02 <dmwit> rwbarton: Well, it's only fair. GHC forgot how to Haskell when I told it UnicodeSyntaxLOL
18:44:12 <rwbarton> i'm surprised it doesn't just extend the grammar of type signatures to allow ∀ as an alternative to forall
18:44:18 <dmwit> yeah
18:44:24 <nand`> rwbarton: that was my question in the first place :P
18:44:28 <rwbarton> but maybe this is tricky because ∀ -> forall changes the category
18:44:37 <dmwit> Probably if you brought this to the attention of the Guys In Charge, they'd change it. =)
18:44:48 <Eduard_Munteanu> It's probably using the same, generated lexer?
18:45:12 <Eduard_Munteanu> Although maybe not generated, we're not 'flex'-ing here.
18:45:16 <otters> is it a poor idea to convert my project to unicode syntax just for the sake of beauty?
18:45:30 <dmwit> Eduard_Munteanu: It's generated; we may not be flexing, but we're alexing.
18:45:55 <nand`> rwbarton: if it did that for all UnicodeSyntax rules, there would be no reason for the existence of the >- rule
18:47:30 <rwbarton> It seems possible to me that there is in fact no reason for the >- rule...?
18:47:34 <nand`> oh, in my hpaste earlier I forgot to enable RankNTypes as well; the symbol doesn't seem to be replaced if that isn't active
18:48:06 <nand`> A.∀ still works, but just ∀ generates “not in scope: forall”; so you *can* refer to ∀ using a fully qualified name without it br eaking
18:48:10 <nand`> breaking*
18:49:15 <nand`> rwbarton: there is a reason for it (sort of) with the current logic though; since you can define (>-) yourself and then use the pretty unicode syntax for it
18:49:33 <rwbarton> You could also just define a function named [whatever the unicode "syntax" for >- is]
18:49:37 <nand`> hmm
18:49:43 <rwbarton> or define (>-) and then define that as a synonym
18:49:48 <nand`> yes, but then people would be forced to use the silly unicode syntax :)
18:49:52 <nand`> or that
18:50:01 <nand`> that last one is probably the only reasonable “solution”
18:50:26 <nand`> you're totally right then, there's no reason for the existence of the >- rule
18:50:35 <nand`> somebody needs to complain about this to somebody
18:50:56 <rwbarton> my guess is that >- used to exist or might exist in the future or just the person who designed UnicodeSyntax thought it existed
18:51:29 <nand`> or maybe, just maybe, it's there so people don't ask themselves why there's a rule for -< but not >-
18:51:34 <rwbarton> not that any of those are good reasons for the >- rule to exist currently
18:52:11 <Eduard_Munteanu> Or just couldn't help himself add >- for symmetry. :P
18:52:31 <Eduard_Munteanu> Look, ∀ has A and ∃ has E  :P
18:52:33 <rwbarton> if i have UnicodeSyntax but not Arrows, does the unicode for -< still get replaced by -<?
18:53:27 <rwbarton> > let x = proc v -< v in x 3
18:53:28 <lambdabot>   Not in scope: `proc'Not in scope: `-<'
18:53:29 <nand`> Eduard_Munteanu: then A would have to be an alias for ןןɐɹoɟ
18:53:31 <nand`> clearly
18:53:39 <Eduard_Munteanu> Heh :)
18:54:00 <rwbarton> I don't even know exactly what Arrow syntax is supposed to look like but I guess lambdabot doesn't have it
18:54:20 <nand`> (ɟoɹɐןן rather)
18:54:22 <Eduard_Munteanu> nand`: how do you type that, though?
18:54:24 <dmwit> > let x = proc v -> v in x 3
18:54:25 <lambdabot>   <no location info>: parse error on input `->'
18:54:41 <c_wraith> nand`: llarof?
18:54:42 <nand`> Eduard_Munteanu: I used the first DDG result for “upside down text”
18:55:01 <nand`> c_wraith: ah, the letters are incorrect for that to work as intended
18:55:17 <c_wraith> just need to reverse it
18:55:27 <nand`> c_wraith: the intent was to mirror “forall” vertically
18:55:33 <c_wraith> oh
18:55:55 <Eduard_Munteanu> I guess 180 deg rotation does it too.
18:56:02 <nand`> then again, A is horizontally symmetric so rotating it 180° and mirroring it vertically is the same operation
18:56:03 <dmwit> Eh, if you're continuing the pattern Eduard_Munteanu started, you have to do a rotation by pi.
18:56:10 <rwbarton> nand`: for bonus points, try to name a module Forall and import it using ∀
18:56:22 <nand`> rwbarton: I doubt that would work, F ≠ f
18:56:25 <Eduard_Munteanu> Is there a capital forall? :D
18:56:27 <rwbarton> yes :(
18:56:43 <gwern> > (90*79 + 93*80) / (90 + 93)
18:56:44 <lambdabot>   79.50819672131148
18:57:38 <gwern> > (((90-1)*10) + ((93-1)*8)) / (90 + 93 - 2)
18:57:39 <lambdabot>   8.98342541436464
18:57:50 <nand`> dmwit is right, ∃ is not E flipped upside down either; so ןןɐɹoɟ was totally appropriate for A <-> ∀
18:58:55 <gwern> (looks like I did the standard deviation right)
18:59:18 <nand`> I found a silly precedence conflict the other day
18:59:33 <nand`> > (-2 + 4, -2 ** 4)
18:59:34 <lambdabot>   (2,-16.0)
18:59:36 <gwern> nand`: the queen always goes first, nothing hard about it
18:59:57 <nand`> the former is clearly (-2) + 4 but the latter is -(2 ** 4)
19:00:14 <strager> Poor negative prefix operator.  ;_;
19:00:27 <nand`> goes for (^) as well, for that matter
19:00:36 <nand`> has the potential to be misleading imo
19:00:55 <dmwit> > (0 - 2 + 4, 0 - 2 ** 4) -- easy to explain and remember! =D
19:00:56 <lambdabot>   (2,-16.0)
19:02:16 <nand`> that one plays well with (*) too
19:02:32 <dmwit> > (-2 * 4, 0 - 2 * 4)
19:02:33 <lambdabot>   (-8,-8)
19:02:37 <nand`> but only because -(a*b) = (-a) * b :P
19:03:25 <strager> > (-2 * (1/0), 0-2 * (1/0))
19:03:26 <lambdabot>   (-Infinity,-Infinity)
19:03:31 <nand`> Is there a word for that relation between (negate) and (*), btw?
19:03:41 <dmwit> > ((-2)*4,-(2*4),-2*4) :: (Expr,Expr,Expr)
19:03:42 <lambdabot>   (negate 2 * 4,negate (2 * 4),negate (2 * 4))
19:04:30 <dmwit> nand`: It plays well with (*), but not because of the equality you stated.
19:04:32 <nand`> ie. f (a×b) = (f a)×b = a×(f b)
19:04:35 <nand`> dmwit: oh?
19:05:03 <dmwit> As you can see above, -2*4 parses as -(2*4)
19:05:16 <otters> > 1 2
19:05:17 <lambdabot>   1
19:05:30 <strager> > [] [] []
19:05:32 <lambdabot>   Couldn't match expected type `[a] -> [a1] -> t'
19:05:32 <lambdabot>         against inferred ty...
19:05:43 <otters> > 1 2 3
19:05:44 <dmwit> so 0-2*4 and -2*4 are the same because 0-x = 0+-x, no properties of (*) necessary
19:05:45 <lambdabot>   1
19:05:48 <otters> :t 1
19:05:49 <lambdabot> forall t. (Num t) => t
19:05:52 <otters> huh
19:05:58 <otters> why isn't forall t redundant?
19:06:04 <dmwit> it is
19:06:12 <otters> okay
19:06:14 <otters> phew
19:06:17 <nand`> dmwit: what I meant to say is “(*) can be misleading in that regard too”, similar to (+)
19:06:55 <nand`> since -2*4 actually parses as -(2*4) but since that's equal to (-2)*4, and -2+4 is equal to (-2)+4, it can be misleading
19:06:57 <dmwit> nand`: I don't get it. What I'm proposing is an easy way to remember the precedence of unary "-"; namely, replace it with binary "0-".
19:07:31 <nand`> dmwit: right; I'm just talking about when you don't know that mnemonic
19:08:05 <dmwit> aaaah, now I understand what you're saying.
19:08:18 <nand`> a naive mistake would be to see that -2+4 = (-2)+4 and -2*4 seems to be (-2)*4, and then assume -2^4 = (-2)^4
19:08:23 <dmwit> You're saying that -2*4 is confusing because if you think that it parses as (-2)*4 you'll never spot your mistake.
19:08:28 <nand`> exactly
19:08:33 <dmwit> got it =)
19:09:16 <dmwit> I'm sure there's a name for that property, by the way, though I don't know what it is off the top of my head.
19:09:50 <nand`> the way I would try to describe it is that * is “symmetric”, with negate “mirroring” everything
19:09:59 <NemesisD> hi all. i want to fork off many threads and wait for them all to finish. each thread returns an mvar which will have a value in it when the thread is done, but how can i "take" from those mvars without forcing the order?
19:10:16 <nand`> and it making no difference whether you do something, then mirror; or mirror first and then do something; ie negate . (*2) = (*2) . negate
19:10:21 <NemesisD> right now i mapM takeMVar but that sequentializes them and only lets a few run at a time
19:10:26 <dmwit> I guess you would normally say (a*) is an odd function (as is (*b)).
19:10:54 <dmwit> NemesisD: You sound confused.
19:11:03 <dmwit> NemesisD: Waiting on the MVars in order does not make the threads run in order.
19:11:19 <dmwit> The threads run whether you're waiting on their MVar or not.
19:11:34 <NemesisD> this may be something with lazy evaluation
19:11:48 <nand`> dmwit: that actually summarizes it pretty well; but only works for “negate” due to the definition of odd as exactly that
19:11:49 <dmwit> If you have some code that's not behaving the way you expect, you should show it to us.
19:11:55 <dmwit> nand`: yes =)
19:11:57 <hpaste> NemesisD pasted “mvar wait” at http://hpaste.org/69626
19:12:07 <packingtown> i am brand new to haskell, and my first program is hanging. anyonoe have any idea? http://pastie.org/private/nwj5kpjlqz3pednbfznw
19:12:20 <packingtown> hello btw
19:13:16 <gwern> > ((60.6 * 9) + (65.6 * 20)) / (9 + 20)
19:13:17 <lambdabot>   64.04827586206896
19:13:23 <nand`> packingtown: appending to a (long) list is fairly inefficient, not sure if this is what's causing your hang or not
19:14:04 <packingtown> nand`: where am i appending?
19:14:13 <nand`> packingtown: line 3
19:14:20 <dmwit> NemesisD: Okay, you know the next two questions. What do you expect to happen? What happens instead?
19:14:44 <gwern> > (((9-1) * 2.3) + ((20-1) * 1.7)) / (9 + 20 - 2)
19:14:45 <lambdabot>   1.8777777777777775
19:14:53 <packingtown> nand`: oh right. gotcha. does the recursive problem206 function look like it will successfully quit if it gets to that middle guard?
19:14:55 <nand`> packingtown: also I haven't got time to fathom your problem fully but all of this re-generating ‘digs’ with different steps seems inefficient; are you sure you can't re-use calculations more?
19:14:55 <NemesisD> dmwit: i expect 100 "fork" messages at once, i get 3, which wait for a bit, then 3 more
19:15:22 <nand`> packingtown: I would put the middle guard above the first
19:15:51 <nand`> packingtown: since it seems to be an escape condition; but I don't know the specifics of your problem so that may break it
19:15:55 <gwern> > ((10*63.4) + (12*64.4)) / (10+12)
19:15:55 <dmwit> NemesisD: Are you using the threaded runtime? If not, all FFI calls block all Haskell threads from executing.
19:15:56 <lambdabot>   63.94545454545455
19:16:17 <dmwit> NemesisD: So what gets printed is basically a race condition.
19:16:25 <packingtown> nand`: i have to find the integer n, where its square matches the pattern 1_2_3_4_5_6_7_8_9_0 where _ is any integer
19:16:32 <dmwit> NemesisD: (Of course, even with the threaded runtime what gets printed is basically a race condition.)
19:16:46 <gwern> > (((10-1)*2.6) + ((12-1)*2.6)) / (10 + 12 - 2)
19:16:46 <dmwit> NemesisD: (It's just a fairer race.)
19:16:47 <lambdabot>   2.6
19:16:52 <nand`> packingtown: oh, I see what you're doing; you're converting a number to decimal representation?
19:16:53 <packingtown> nand`: so digs breaks a number into an array of digits and then i just check each one
19:17:04 <NemesisD> dmwit: yeah i didn't expect the output to be pretty, just wanted to have an idea somehow how many threads were running concurrently
19:17:13 <gwern> (d'oh. I should have been able to figure that one - if the standard deviations are both 2.6 how can they differ?)
19:17:20 <NemesisD> dmwit: compiled with ghc --make -threaded Main.hs
19:18:06 <nand`> packingtown: you should be able to make line 10 a lot cleaner, probably be 1. writing a function to drop every other element, 2. comparing with [1..9] ++ [0]
19:18:16 <nand`> s/be/by/
19:18:33 <packingtown> nand`: you're right that sounds better
19:19:14 <packingtown> nand`: can i put like a print at the top to make sure it's actually running?
19:19:28 <nand`> packingtown: you can re-use the existing “show” function to convert a number to decimal form, for what it's worth :P
19:19:36 <nand`> packingtown: you could use the “trace” function to monitor code flow
19:19:40 <nand`> which is part of .. some package
19:20:11 <packingtown> nand`: thanks, i have some things to try out. appreciate it
19:20:56 <dmwit> NemesisD: Hm, I'm not totally sure.
19:21:02 <dmwit> NemesisD: How is "query" implemented?
19:21:10 <andares> did >>> used to be part of Control.Arrow?
19:21:16 <dmwit> Is it an FFI call or does it do network access, or what?
19:21:56 <Clint> andares: did it stop?
19:22:19 <andares> it seems to have: FG.hs:192:5: `>>>' is not a (visible) method of class `Arrow'
19:22:26 <dmwit> It's part of Category now.
19:22:44 <dmwit> :t (>>>)
19:22:45 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
19:23:09 <andares> so I should update old code that specifies a definition of (>>>) to do that in its instance of Category?
19:23:10 <NemesisD> dmwit: implemented with bindings to the C mysqlclient api, so probably ffi?
19:23:16 <dmwit> right
19:23:35 <dmwit> to both of you =)
19:24:00 <dmwit> NemesisD: One last question: is the FFI import specified safe or unsafe? (if neither, the default is safe)
19:24:12 <NemesisD> dmwit: how can i tell?
19:24:39 <andares> FG.hs:196:5: `>>>' is not a (visible) method of class `Category'
19:24:47 <dmwit> Look at the "foreign import" line; if it says "foreign import ccall unsafe" or similar, it's unsafe; otherwise it's safe.
19:25:01 <dmwit> uh
19:25:03 <dmwit> ?src Category
19:25:03 <lambdabot> Source not found. :(
19:25:24 <dmwit> Hoogle says Category has id and (.), and (>>>) = flip (.)
19:25:54 <andares> ahh, makes sense then.
19:26:08 <andares> but does that mean that I don't need to specify my class as an instance of Category anymore?
19:26:47 <NemesisD> dmwit: the only unsafe i see is from bytestring, but i also don't really know what i'm doing
19:27:10 <dmwit> NemesisD: Strange. I'm a bit surprised, then.
19:27:48 <NemesisD> dmwit: unsafe actually, found it
19:27:51 <dmwit> andares: I think you still do, right? I mean, the definition of (.) has to come from somewhere.
19:27:59 <dmwit> NemesisD: Ah, you should complain about that, then.
19:28:10 <NemesisD> foreign import ccall "mysql_signals.h _hs_mysql_real_query" mysql_real_query
19:28:14 <dmwit> NemesisD: And point them at the crash course in GHC's runtime that I just wrote. =D
19:28:17 <NemesisD> ccall unsafe*
19:28:42 <NemesisD> dmwit: brian o'sullivan wrote it so i'm fairly sure he knows what he's doing
19:28:58 <andares> dmwit: so if I have some code that used to define an instance of Arrow in terms of arr, (>>>), and first, and now I need to make it an instance of Category, there should be a pretty trivial way to do that, right?
19:29:11 <andares> like maybe (.) = flip (>>>)?
19:29:21 <dmwit> NemesisD: Well, that's not really fair. He may know what he's doing, but he may be optimizing for a different use case than the one you're using.
19:29:47 <dmwit> If you think that's an accurate assessment, you should bug him to provide both unsafe and safe variants to cover both use cases.
19:29:48 <NemesisD> dmwit: so am i dead in the water then? i won't be able to execute more than 3 concurrent queries?
19:30:21 <dmwit> NemesisD: No, just change the "unsafe" to "safe" and you can execute as many concurrent queries as your little heart desires (or until the OS stops handing you new threads).
19:30:37 <dmwit> NemesisD: Read the "Foreign Imports" section of http://dmwit.com/gtk2hs to learn more. =)
19:31:02 <dmwit> Maybe the "Why Threading is Hard" and "Conventions" sections, too.
19:31:23 <byorgey> andares: yep
19:31:25 <NemesisD> dmwit: bummer. glad i tested this first before implementing the real thing
19:31:54 <byorgey> andares: well, don't literally define  (.) = flip (>>>), because (>>>) is defined as  flip (.)  =)
19:32:08 <andares> of course :p
19:32:09 <byorgey> just take whatever definition you used to have for (>>>) and flip it.
19:32:51 <otters> (.) = flip (flip (>>>))
19:32:53 <otters> no problem
19:32:57 <andares> I'm not even sure what to do for id.
19:33:03 <dmwit> NemesisD: Let me encourage you (again) to complain, perhaps with a patch, to Brian. Don't be intimidated by your perception of his expertise.
19:33:33 <byorgey> andares: if you have defined arr then it should be  id = arr id
19:34:02 <andares> I fail to understand.
19:34:31 <byorgey> andares: the first id has type   YourArrow a a, the second id has type  (a -> a)
19:34:36 <byorgey> is that what was confusing you?
19:34:50 <dmwit> There's (at least) two possibilities: 1. it's a mistake, because even Brian is human, and he changes the library 2. he knows the tradeoffs and chose to make the import unsafe to optimize for single-threaded use rather than multi-threaded use, in which case your need for multi-threaded use motivates the need for the addition of a safe variant
19:35:05 <dmwit> Either way, you win.
19:35:53 <andares> not quite, I'm more confused about the types involved here.
19:36:31 <byorgey> andares: ok, which types are you confused about?
19:36:34 <NemesisD> dmwit: thanks. ill open an issue on his tracker
19:37:31 <andares> so the kind of anything that could be an instance of Category must be * -> * -> *, right?
19:37:35 * hackagebot ImperativeHaskell 2.0.0.0 - A library for writing Imperative style haskell.  http://hackage.haskell.org/package/ImperativeHaskell-2.0.0.0 (MatthewMirman)
19:38:17 <byorgey> yes
19:40:05 <byorgey> andares: sorry, I have to go, hopefully someone else can continue explaining
19:40:37 <andares> which is the same kind as Arrow, I see. and since (\a -> a) is the identity function, and arr :: Arrow r (a -> b) -> r a b,  so arr takes (\a -> a) to r a a, which is the same type as category's id.
19:40:39 <andares> I understand.
19:40:59 <andares> and on a conceptual level, it's just "arrowifying" the identity function.
19:41:13 <andares> to make it the right type, since we're making the arrow be a category. cool.
19:42:38 <andares> instance Functor ((,) Event) where fmap = fmap
19:43:41 <andares> hm, this seems like an odd line of code. would it be trying to use the instance definition of ((,) a) and failing, since it sees itself as a candidate?
19:44:44 <dmwit> That looks like a bug to me.
19:44:57 <andares> this stuff all theoretically compiled at one point though.
19:45:05 <dmwit> Oh, it will compile.
19:45:14 <andares> it won't! it refuses! says it overlaps.
19:45:14 <dmwit> It will just loop infinitely if you try to call fmap at that type.
19:45:28 <andares> since there's also a matching fmap defined in Control.Monad.Instances.
19:45:34 <dmwit> Yeah, I don't know if it was always true, but there is certainly now an instance of Functor for (,) a
19:45:44 <hpaste> nand` pasted “Project Euler #206” at http://hpaste.org/69627
19:45:51 <nand`> ^- improvements?
19:47:36 <dmwit> > maxBound :: Int
19:47:37 <lambdabot>   9223372036854775807
19:48:15 <dmwit> nand`: You're going to have a hard time representing 20-digit numbers in a 19-digit Int. =D
19:49:19 <dmwit> everyOther = map head . chunk 2
19:49:31 <dmwit> everyOther = chunk 2 >=> take 1 -- if you feel paranoid
19:50:22 <dmwit> > (length "fromJust $ find", length "head $ filter")
19:50:24 <lambdabot>   (15,13)
19:50:49 <nand`> dmwit: the solution is 19 digits long :P
19:51:01 <nand`> so it just *baaarely* makes it
19:51:49 <nand`> :t chunk
19:51:50 <lambdabot> Not in scope: `chunk'
19:52:20 <shapr> :t blow
19:52:21 <lambdabot> Not in scope: `blow'
19:52:22 <nand`> where's that defined?
19:52:22 <shapr> @hoogle blow
19:52:23 <lambdabot> No results found
19:52:23 <dmwit> It's in Data.List.Split
19:52:27 <dmwit> ?hackage split
19:52:27 <lambdabot> http://hackage.haskell.org/package/split
19:52:49 <nand`> thanks
19:52:56 <nand`> odd how hoogle doesn't pick it up under that name
19:55:11 <nand`> chunk 2 >=> take 1 -- slowed it down by about 5 seconds compared to the version with pattern matching :P
19:57:26 <nand`> seems to be due to the implementation of ‘chunk’
19:59:24 <nand`> changing “Int” to “Integer” slowed it down approximately 3 seconds (17.5 vs 20.5)
19:59:38 <nand`> I was wondering how much of a difference that would make
19:59:52 <dmwit> Wow, I would have expected more.
20:00:06 <nand`> dmwit: I'm not sure where the bottleneck is, it may as well be in the implementation of ‘show’
20:00:06 <dmwit> I'm not surprised that switch to chunk/take slowed it down, though. =D
20:00:26 <nand`> fwiw, map head . chunk 2 was the same as chunk 2 >=> take 1
20:00:35 <nand`> efficient monads :)
20:00:50 <dmwit> Is this all with -O2?
20:00:52 <nand`> yes
20:01:11 <nand`> let me try -O0
20:01:17 <dmwit> no no
20:01:20 <dmwit> O2 is much better =)
20:01:31 <nand`> wow
20:01:35 <nand`> only 2s more
20:01:53 <nand`> it didn't eat up all of my system memory instantly either
20:01:54 <nand`> that's a good sign
20:02:09 <nand`> hate when that happens, the swapping makes it nearly impossible to kill the program :P
20:06:26 <dmwit> :t buildr
20:06:27 <lambdabot> Not in scope: `buildr'
20:06:48 <copumpkin> @hoogle build
20:06:49 <lambdabot> GHC.Exts build :: (forall b. (a -> b -> b) -> b -> b) -> [a]
20:06:49 <lambdabot> Data.Graph.Inductive.Internal.Heap build :: Ord a => [(a, b)] -> Heap a b
20:06:49 <lambdabot> Graphics.Rendering.OpenGL.GLU.Mipmapping build1DMipmaps :: TextureTarget -> PixelInternalFormat -> GLsizei -> PixelData a -> IO ()
20:07:13 <dmwit> Huh, I wonder why Data.List.Split defines its own build.
20:07:34 <dmwit> Seems like that sort of ruins any chances at foldr/build fusion.
20:07:36 <copumpkin> to avoid depending on GHC.*?
20:07:48 <dmwit> (and is probably why nand`'s program slowed down when he used "chunk")
20:08:09 <dmwit> copumpkin: #if __GHC__ it?
20:08:14 <copumpkin> I guess :)
20:09:11 <dmwit> nand`: If you copy the source text of "splitEvery" into your program, but import GHC.Exts instead of copying the source text of "build", is it still slow?
20:09:29 <nand`> “We leave the proof to the reader. ∎” lovely
20:09:46 <nand`> dmwit: let me try
20:12:04 <nand`> dmwit: 1.4 seconds slower :)
20:12:30 <nand`> so it seems GHC.Exts (build) is an improvement
20:12:47 <nand`> of course my testing procedure is by no means scientific :P
20:35:55 <dmwit> nand`: cool =)
20:36:51 <shapr> Having scotty run hint in another thread eats all my signals!
20:39:40 <dmwit> shapr: What's scotty?
20:39:45 <shapr> @hackage scotty
20:39:45 <lambdabot> http://hackage.haskell.org/package/scotty
20:39:59 <dmwit> Oh no!
20:40:04 <shapr> Andy Gill et al at KU wrote scotty.
20:40:44 <nav_> when toional programming use funct
20:40:52 <shapr> At least, I heard about it from his sunroof paper.
20:40:59 <nav_> ?
20:41:14 <shapr> nav_: talar du svenska?
20:41:52 <shapr> dmwit: Have you seen http://www.ittc.ku.edu/csdlblog/?p=88 ?
20:42:21 <shapr> nav_: I don't understand your question. It doesn't parse as English.
20:42:46 * hackagebot authenticate-oauth 1.3.0.2 - Library to authenticate with OAuth for Haskell web applications.  http://hackage.haskell.org/package/authenticate-oauth-1.3.0.2 (HiromiIshii)
20:42:56 <dmwit> "toional" looks especially suspicious
20:43:22 * shapr shrugs, continues coding
20:43:31 <shapr> Hm, I don't have a web-accessible box handy...
20:45:03 <dmwit> shapr: I hadn't seen it, but I'm seeing it now.
20:45:08 <dmwit> neato!
20:46:40 <dmwit> It gets a bit over my head before too long, though.
20:47:20 <shapr> mine too
20:47:46 <shapr> But compiling haskell to javascript and executing it on the client side would solve lots of security worries.
20:48:22 <dmwit> Hm, really?
20:48:39 <ahkurtz> except for the javascript security concerns
20:49:01 <ahkurtz> sorry, I don't know why I said anything. kneejerk reaction.
20:49:56 <shapr> dmwit: Well yah... if the Haskell code is executing in YOUR browser and not on the server, I'd only have to worry about Template Haskell problems, right?
20:51:40 <dmwit> oh
20:52:20 <dmwit> Yes, I forgot that you're working on a project which involves executing a stranger's Haskell code for them. =)
20:52:31 <shapr> Want to see a quick demo?
20:52:35 <dmwit> yes =)
20:52:42 <Nafai> shapr: Me too! :)
20:52:53 <shapr> http://c-71-207-252-122.hsd1.al.comcast.net:3000/
20:53:28 <nand`> "WontCompile [GhcError {errMsg = \"<hint>:3:22: parse error on input `;'\"}]"
20:53:31 <nand`> :(
20:53:31 <shapr> It's super-basic stuff, I just ripped off http://haskell.handcraft.com/ and put hint behind scotty instead of calling tryhaskell.
20:53:34 <nand`> using your example
20:54:14 <shapr> ?
20:54:20 <shapr> nand`: Did you change the input any?
20:54:26 <nand`> I seem to get the same error regardless of what input contains
20:54:32 <shapr> weirdness
20:54:33 <dmwit> I don't get any response at all. =)
20:54:36 <dmwit> =( I mean
20:54:43 <shapr> It's working for me :-/
20:55:00 <shapr> oh right, I made some obvious mistakes ...
20:55:01 * shapr fixes
20:55:08 <shapr> I'm getting lots of requests at least :-)
20:56:05 <luite> shapr: you'd still need some resource limits at the very least
20:56:08 <shapr> nand`: works?
20:56:17 <shapr> nand`: shift-f5 first
20:56:20 <nand`> shapr: yes :)
20:56:28 <nand`> shapr: so is this running in my browser?
20:56:31 <nand`> or what
20:56:36 <shapr> Nope, this is running on my desktop here.
20:56:39 <nand`> oh
20:56:43 * shapr turns off the port forwarding
20:56:58 <nand`> I executed “undefined” which hasn't returned btw
20:57:07 <nand`> s/executed/evaluatewd/
20:57:09 <nand`> -w
20:57:41 <shapr> Next few feature is to add error output, it currently swallows them silently.
20:58:13 <shapr> One neat and scary thing is that any source file put into the "file to load" box is downloaded from the web and loaded via hint.
20:58:22 <nand`> So has anybody implemented homomorphic encryption algorithms + a way to lift arbitrary computations to them in Haskell yet?
20:58:22 <shapr> I want to display the file in the top left pane.
20:58:31 <shapr> nand`: That would be cool.
20:59:16 <shapr> If you want to test this code yourself, it's in the ghclive repo, at https://github.com/shapr/ghclive/tree/master/prototypes/hintpostexecute
20:59:36 <shapr> runghc HintAjax.hs # then http://localhost:3000/
20:59:47 * dmwit puts a 3 gigabyte file in the URL box
20:59:51 <dmwit> just kidding =)
20:59:53 <shapr> :-P
20:59:59 <shapr> That is the sort of thing I'm worried about.
21:00:08 <nand`> + things that could put you in jail for downloading them
21:00:12 <shapr> As luite said, some resource limits :-)
21:01:17 <shapr> luite: I'm thinking any other users in the same session can load a module into the browse/edit pane, but only the host can 'execute' code?
21:02:01 <luite> oh i haven't seen your user interface
21:02:36 <shapr> It looks like http://haskell.handcraft.com/ at the moment
21:02:57 <shapr> with an extra field for the http url to the module to load
21:02:58 <luite> ah
21:03:44 <shapr> I think hint is eating my signals though, so I can no longer C-c out of scotty :-(
21:03:51 <shapr> Any ideas how to fix that?
21:04:43 <luite> install the original signal handlers again i guess. but you'll probably need to run hint in a different process anyway so then it won't matter anymore
21:07:46 <luite> (unless it's no problem that infinite computations or things that overflow the stack will require you to restart the whole web server)
21:07:53 <shapr> ha
21:08:07 <shapr> luite: How to setup limits?
21:09:02 <luite> shapr: mueval does this with some setrlimit calls
21:12:37 <luite> shapr: you could use mueval directly (if you modify it to let it load your own module), but you wouldn't be able to have interactive sessions, and it would be slow. i think i'd do something like letting an interpreter process run with those rlimits. then for every thing that's evaluated read the result (limit the output size to something sensible), kill the process if it hasn't returned within some time limit, then restart (and print a message to the clients that 
21:13:03 <darkf> Are moands similar to continuations? I'm aware that (>>=) takes a continuation
21:13:40 <strager> darkf: Not necessarily; see the list monad.
21:13:47 <luite> shapr: since the only reliable way to stop evaluation is to kill the process
21:13:47 <strager> Or exceptions in the IO monad.
21:14:18 <shapr> luite: If you can assume that the session host is directly interacting with the process, couldn't they just kill it?
21:14:38 <shapr> If they had a button like "kill the interpreter" or "send C-c to the interactive session" ?
21:14:49 <luite> shapr: yeah that would also work
21:15:26 <shapr> That would allow user control and long-running computations both.
21:17:00 <nus> shapr, then you'd have to limit kill rate, too
21:17:17 <shapr> nus: Huh?
21:17:31 <nus> re "If they had a button"
21:18:12 <luite> shapr: but do limit the size of the messages, it's easy to make an infinite result or exception message
21:18:26 <shapr> Good point, that would kill the browser
21:22:19 <nand`> “Time remaining: Infinity days NaN hours” <- gotta love those IEEE floats
21:25:21 <luite> shapr: unless you can chunk the response somehow, but i think javascript can't really handle incremental results well, you either have to do multiple http requests or use your own websockets protocol
21:28:20 <jdavis> dumb question: I am doing "ghc -fext-core t.hs" and I don't get a .hcr file. I also tried "ghc -ddump-simple t.hs" and I still don't get it. What am I doing wrong?
21:29:22 <dmwit> jdavis: Dunno about -fext-core, but -ddump-simpl dumps to stdout (maybe stderr, I never checked) not a file.
21:29:41 <dmwit> darkf: The continuation monad is the mother of all monads.
21:29:52 <dmwit> darkf: All other monads can be implemented in terms of Cont.
21:30:03 <ion> IO?
21:30:12 <darkf> dmwit: How does it work?
21:30:16 <dmwit> ?google mother of all monads cont
21:30:18 <lambdabot> http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
21:30:28 <darkf> dmwit: Thanks
21:30:47 <jdavis> dmwit: I don't get any output at all. It's just a test file with "main = putStrLn "hi"" in it -- could that be the problem?
21:32:02 <dmwit> jdavis: perhaps --force-recompilation or whatever that flag is
21:32:27 <dmwit> -fforce-recomp
21:32:33 <PhearTheCeal> All right guys
21:32:39 <PhearTheCeal> I'm gonna learn Haskell!
21:32:49 <jdavis> dmwit: oh, that did it. Thanks.
21:32:52 <nand`> that had better be “I'm gonna learn me a Haskell!”
21:32:55 <nand`> :)
21:32:59 <DrKillPatient> For great good!
21:33:06 <PhearTheCeal> nand`: Yup, it was highly recommended
21:33:09 <PhearTheCeal> Have you read it?
21:33:12 <nand`> I have
21:33:18 <PhearTheCeal> was it good?
21:33:25 <nand`> 'twas my introduction to Haskell too
21:33:25 <DrKillPatient> I'm just starting it now, it's good so far
21:33:27 <nand`> verily
21:33:55 <PhearTheCeal> Will it give me exercises or do I need to go to Project Euler for that?
21:34:58 <nand`> PhearTheCeal: I don't remember
21:35:30 <nand`> but I wouldn't really recommend project euler, it's not in the spirit of Haskell nor is it an adequate platform for learning a language, much less solving some form of numerical puzzle
21:35:39 <nand`> s/much less/rather/
21:36:19 <Eduard_Munteanu> There were some exercises on the wiki. You might also want to check out RWH and Wikibooks.
21:37:26 <Eduard_Munteanu> @google haskell exercises
21:37:28 <lambdabot> http://www.haskell.org/haskellwiki/99_questions
21:37:28 <lambdabot> Title: H-99: Ninety-Nine Haskell Problems - HaskellWiki
21:37:44 <nand`> there's “99 haskell problems” but it's a translation of a translation and some examples feel far more lisp-y than haskell-y
21:37:49 <nand`> ..
21:37:54 * nand` is too slow
21:38:35 <PhearTheCeal> looks all right. I think I'll try it. Plus I've done a little bit of Clojure before :P
21:39:24 <copumpkin> I got 99 problems but haskell aint one of them
21:39:50 <dmwit> if you got a fear o' monads I feel bad for you, son
21:40:14 <nand`> I got 99 problems but a monoid in the cate.. wait
21:41:12 <boccato> http://www.haskell.org/haskellwiki/Video_presentations
21:41:21 <boccato> There are some nice video tutorials here.
21:41:24 <otters> I got 99 problems but a Cont ain't one
21:41:55 <nand`> otters: ..close
21:42:11 <otters> it's the best monad
21:42:14 <PhearTheCeal> boccato: thanks. I like videos
21:42:32 <dmwit> wow, that one is especially good because...
21:43:51 <boccato> PhearTheCeal: The Functional Programming Fundamentals by Erik Meijer, on that page are very nice.
21:45:39 <PhearTheCeal> boccato: I shall check out that one first. Thanks again for videos, I've always been a slow reader
21:45:59 <Axman6> PhearTheCeal: you're not alone!
21:45:59 <lambdabot> Axman6: You have 1 new message. '/msg lambdabot @messages' to read it.
21:48:44 <PhearTheCeal> Axman6: woot! Luckily it doesn't seem to be a hinderance in college where the norm is to not buy a textbook
21:50:03 <boccato> PhearTheCeal: I am starting myself, have done the first 7 of the 99 probs and was thinking about creating unit tests for them. Do you think it would help you if that existed?
21:50:52 <PhearTheCeal> boccato: If you did that you could probably set up your own website where people went to try the problems like at 4clojure.com
21:51:18 <boccato> Yeah, was thinking about something like that.
21:51:19 <PhearTheCeal> ((which seems to never be up ;_; ))
21:51:34 <PhearTheCeal> It's a good idea. I'd use it
21:51:35 <Axman6> PhearTheCeal: heh, indeed. sucks when you have to mark assignments though :P
21:53:04 <boccato> That's great to know. I'll create a github repo for starting it. I already have the first ones, but not very organized :)
21:54:17 <PhearTheCeal> boccato: After I learn Haskell I can totally help you with that.
21:54:40 <boccato> That's a deal!
21:55:00 <nand`> “unit tests” heh
21:55:12 <nand`> use QuickCheck :)
21:55:15 <Axman6> unit tests are so primitive
21:55:18 <boccato> btw, I havent't learnt it yet... lol... still in the process, so if you want to help you are welcome.
21:55:52 <nand`> I haven't actually learned to use QuickCheck for programs either, I just use it with lambdabot's @check command
21:56:00 <boccato> I was thinking of starting with HUnit by just transforming the examples into unit tests.
21:56:16 <tgeeky> boccato: A little bird told me that there are some big advances in the pipes with QuickCheck
21:56:16 <nand`> @check \x -> x == reverse x
21:56:17 <lambdabot>   "OK, passed 500 tests."
21:56:21 <boccato> But adding Quick Check would be nice.
21:56:48 <ion> tgeeky: Can you elaborate?
21:56:54 <boccato> tgeeky: which bird? which pipes?
21:57:00 <tgeeky> ion: no, I shot and killed the bird.
21:57:11 <boccato> you bastard
21:57:14 <tgeeky> Something about a paper being written with some extentions
21:57:18 <tgeeky> I don't remember the details
21:57:21 <nand`> wait
21:57:25 <nand`> I meant to write reverse (reverse x)
21:57:30 <nand`> how did what I right even pass 500 tests
21:57:33 <nand`> ..
21:57:35 <nand`> what I wrote*
21:57:51 <ion> nand: reverse [(),(),(),()] == [(),(),(),()]
21:57:55 <boccato> Any tip on what should I google for to find that paper?
21:58:03 <Axman6> QhickCheck should really be part of GHC. so all packages can guarantee they'll have access to testing features. and it would need to always maintain backwards compatibility
21:58:07 <ion> @check \x -> (x == reverse x) `const` (x :: [Integer])
21:58:08 <lambdabot>   "Falsifiable, after 3 tests:\n[-2,1]\n"
21:58:09 <tgeeky> boccato: no, I think it's being written and hasn't been published.
21:58:10 <nand`> @check (\x -> (x :: [Int]) == reverse x
21:58:10 <lambdabot>  Unbalanced parentheses
21:58:15 <nand`> oops
21:58:17 <nand`> @check \x -> (x :: [Int]) == reverse x
21:58:18 <lambdabot>   "Falsifiable, after 0 tests:\n[0,-3,-2]\n"
21:58:26 <andares> wait, how does check work?
21:58:30 <tgeeky> anyway, quickcheck is pretty awesome already
21:58:50 <boccato> I agree, but I am taking baby steps :)
21:58:53 <ion> Too bad lambdabot is still not running a version of QuickCheck that does shrinking.
21:59:02 <otters> @check \x -> (x :: [()]) == reverse x
21:59:03 <lambdabot>   "OK, passed 500 tests."
21:59:06 <otters> sweet
21:59:28 <nand`> ion: elaborate
22:00:04 <tgeeky> nand`: http://stackoverflow.com/questions/1933283/whats-new-in-quickcheck-2
22:00:12 <ion> λ> quickCheck $ \(xs :: [Integer]) -> reverse xs == xs
22:00:14 <tgeeky> among other google results for quickcheck shrinking
22:00:21 <ion> *** Failed! Falsifiable (after 3 tests and 3 shrinks): [0,1]
22:00:24 <andares> hm.. is it true that some finite set of rewrite rules allow two equivalent formulations of a function to be transformed into each other?
22:01:36 <nand`> ion: oh neat
22:01:41 <tgeeky> nand`: it sounds like shrinking lets you find simpler things to mess up your code
22:01:58 <dmwit> andares: Define equivalent.
22:02:05 <Axman6> QC will try and find the smallest input that fails
22:02:28 <Axman6> rather than giving you some huge input that happened to fail.
22:02:54 <andares> dmwit: f(a) == g(a) for all a in the functions' domain.
22:04:22 <dmwit> andares: I suppose you want them to coterminate as well?
22:04:44 <andares> oh, I hadn't thought about termination. yes.
22:05:30 <andares> huh, although I guess cotermination might not be able to coexist with the other requirements.
22:06:29 <dmwit> not decidably, but decidability wasn't part of your question =)
22:06:37 <dmwit> Anyway, this is the sort of thing I'm probably supposed to know.
22:06:38 <PhearTheCeal> Got a test tomorrow. G'night guys!
22:06:58 <dmwit> I would expect that beta-eta equivalence is just what you're talking about, in which case there's a finite set of rewrite rules (namely two).
22:07:49 <andares> I'm not familiar with beta-eta equivalence.
22:08:21 <dmwit> Are you familiar with beta reduction?
22:08:40 <dmwit> It's (\x. e) m -> e[x |-> m]
22:09:06 <dmwit> eta reduction is (\x. f x) -> f (provided x does not appear in f)
22:09:36 <andares> I'm not sure how to parse that syntax.
22:09:53 <nand`> in Haskell: \x -> f x  is the same as  f
22:10:00 <dmwit> That syntax was just a reminder for people who've seen it. If you haven't seen it, I'll explain a bit more. =)
22:10:47 <andares> thanks. :) I haven't really done much lambda calculus.
22:11:13 <dmwit> Beta reduction is function application, basically. When I write "(\x. e) m -> e[x |-> m]" I mean the term "(\x. e) m" can be reduced to just the "e" part, but with all references to "x" replaced by "m".
22:11:39 <dmwit> Good so far?
22:12:12 <andares> all references to "x" where?
22:12:20 <andares> on the lhs?
22:12:25 <dmwit> all references to "x" in "e"
22:13:09 <dmwit> for example, "(\x. x + x) 3" could be reduced to "3 + 3"
22:13:21 <andares> ahhhhh, okay, I see how this syntax works.
22:13:40 <andares> got it.
22:13:47 <dmwit> or "(\x. x x) (\x. x x)" could be reduced to "(\x. x x) (\x. x x)" =)
22:14:14 <dmwit> Okay, that's beta reduction.
22:14:38 <dmwit> Eta reduction says that if all your lambda abstraction does is apply a function to the variable it takes, you might as well not have a lambda at all.
22:14:58 <dmwit> A term of the form "\x. f x" can be rewritten to just "f".
22:15:07 <andares> wait, wouldn't the references to "x" in "x x" get replaced with (\x. x x)?
22:15:07 <dmwit> (This is only allowed when "f" doesn't refer to "x", though!)
22:15:29 <dmwit> andares: Yep! What happens when you do that?
22:15:29 <andares> so it'd rewrite (\x. x x) as (\x. (\x. x x) (\x. x x)), no?
22:15:45 <dmwit> andares: Ah, nope, the lambda part disappears.
22:15:46 <andares> and then..
22:15:53 <andares> right. my mind is blown.
22:15:56 <andares> :p
22:16:07 <andares> it's like a quine!
22:16:12 <dmwit> yes =)
22:16:34 <andares> okay, got eta reduction now.
22:16:44 <dmwit> It's famous for blowing the minds of many people -- e.g. Turing, Godel, Church... =)
22:17:54 <dmwit> Alright, so two terms are beta-eta equivalent when there's a chain of applications of the beta or eta rewrite rules (in either direction) that transforms one to the other.
22:18:04 <dmwit> And it's a famously complicated equivalence relation.
22:18:28 <andares> right.
22:19:29 <andares> so is beta-eta equivalence strong enough to transform between any two equal terms?
22:19:42 <nand`> is there an example of two total functions f,g such that forall x. f(x) = g(x)  but f and g are *not* beta-eta equivalent?
22:20:04 <andares> exactly
22:21:07 <dmwit> I'm looking for a reference now.
22:21:22 <dmwit> I *think* beta-eta is as big as contextual equivalence, but I'm not sure.
22:22:28 <dmwit> (Two terms are contextually equivalent if whenever you have a term with a "hole" in it C, filling in the hole with either f or g are beta equivalent.)
22:23:10 <dmwit> (which is just what you're asking about, basically)
22:23:14 <nand`> just looked up the meaning of that term as well :) https://en.wikipedia.org/wiki/Contextual_equivalence
22:23:16 <nand`> indeed
22:23:59 <dmwit> sorry, I meant C[f] and C[g] coterminate
22:24:43 <dmwit> Hm, I guess beta-eta is not the same as contextual equivalence.
22:25:23 <andares> oh?
22:26:34 <andares> wait, actually I think the decidability problem is important.
22:27:18 <andares> say your functions have the range {TRUE,FALSE}, and you're trying to determine whether a term will terminate when applied to a given input.
22:28:05 <andares> you'd first substitute that input into the term everywhere, then if there were a sequence of eta and beta reductions that would turn it into the unit TRUE or FALSE functions, a computable function would find it by enumeration, right?
22:28:40 <andares> say, a bfs of eta and beta reductions, since eventually it'll cover every possible sequence of finite length.
22:28:45 <nand`> what if this sequence of eta/beta reductions is infinite?
22:28:52 <dmwit> We're doing maths here, not computations!
22:29:14 <andares> could an infinite sequence of eta/beta reductions ever transform a function while a finite sequence wouldn't?
22:29:31 <andares> I'm having trouble thinking about an infinite sequence of reductions leading to somewhere :p
22:30:03 <nand`> wait, does this model include recursion?
22:30:22 <dmwit> andares: I think it's common to consider only finite sequences.
22:31:04 <andares> hmm.. nand` shot a hole in my argument. if it's recursive, you'd have to beta-reduce an infinite number of terms.
22:31:21 <nand`> but can lambdas refer to themselves in this model
22:31:54 <dmwit> nand`: That's what the Y combinator is all about. =)
22:32:19 <nand`> is that the one that isn't type safe?
22:32:33 <Eduard_Munteanu> Presumably you'd consider only total functions?
22:32:33 <nand`> s/type safe/well-typed/
22:32:40 <andares> ohhh, that's what you showed me dmwit, isn't it?
22:32:46 <nand`> Eduard_Munteanu: that was in my question, yeah
22:33:43 <dmwit> Darn it, I feel like I'm supposed to know this.
22:33:53 <dmwit> andares: Well, that was omega, but the Y combinator is very closely related.
22:34:04 <andares> supposed to? why?
22:34:18 <dmwit> I'm doing a Ph.D. in programming languages. =)
22:35:28 <nand`> “Fixed-point combinators do not necessarily exist in more restrictive models of computation. For instance, they do not exist in simply typed lambda calculus.”
22:35:51 <andares> fun times!
22:37:10 <dmwit> This chapter has three equivalence relations, and none of them are beta-eta equivalence. >_<
22:37:28 <luca> hm, any idea why having: alias hlint='hlint -c' in my bashrc didn't... work
22:37:34 <luca> aka hlint x.hs doesn't use colour
22:39:28 <andares> there's no helpful diagram of spaces or anything by chance? :p
22:40:31 <nand`> “This is incorrect because the actual Y combinator is rejected by the Haskell type checker” <- thought so
22:40:32 <dmwit> I'm going to crash pretty soon. Unfortunately, I don't know the answer to your question.
22:40:45 <andares> it's cool. it's been a pretty excellent discussion.
22:40:51 <andares> night dmwit!
22:41:00 <dmwit> g'night
22:41:01 * nand` is on the verge of falling asleep as well
22:41:21 * andares would if he could summon the strength of will to pry the headphones from his ears.
22:42:58 <c_wraith> oleg once wrote about 3 different ways to implement the Y combinator
22:43:08 <nand`> ..in the type system
22:43:10 <nand`> ba dum tsh
22:43:21 <c_wraith> the only one I remember offhand was using a newtype to hide the infinite recursion
22:43:32 <c_wraith> err, the infinite type
22:43:40 <nand`> newtype Rec a = In { out :: Rec a -> a }  -- this one?
22:43:53 <c_wraith> I don't remember.
22:44:04 <c_wraith> At the point I saw that, I didn't understand the significance
22:44:08 <nand`> because with that y = \f -> (\x -> f (out x x)) (In (\x -> f (out x x)))
22:44:58 * nand` is just copying from Wikipedia, har har
22:45:40 <andares> does the Y combinator mess Haskell up?
22:45:48 <dmwit> ?src fix
22:45:48 <lambdabot> fix f = let x = f x in x
22:46:02 <dmwit> ^ the Haskell version of Y
22:46:31 <nand`> why is that not fix f = f (fix f)
22:46:36 <dmwit> for sharing
22:46:38 <otters> let is lazy
22:46:47 <nand`> ah
22:46:57 <andares> hm
22:47:01 <c_wraith> dmwit: well. that implementation uses general recursion to implement general recursion. it's a bit cheating.
22:47:02 <dmwit> fix f = f (fix f) is sufficiently lazy, but inefficient
22:47:12 <dmwit> c_wraith: I know. =)
22:47:15 <Cale> Well, more importantly, you're defining the fixed point as a single variable, which will only be evaluated once
22:47:49 <otters> > fix (1:)
22:47:50 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
22:47:51 <andares> so what does one do with fix?
22:47:56 <dmwit> andares: recursion
22:48:07 <c_wraith> andares: mostly confuse people who haven't seen it before
22:48:08 <Cale> andares: It's sort of a primitive which recursion can be implemented in terms of
22:48:19 <c_wraith> > fix $ (0:) . scanl (+) 1
22:48:21 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
22:48:22 <andares> ah, I see. it's a lazy way to say f(f(f(f(…f(x)))))
22:48:22 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
22:48:24 <lambdabot>   3628800
22:48:53 <Cale> ^^ you can use recursive functions anonymously like that
22:49:10 <Cale> In practical terms, it's often handy in, say, the IO monad for looping
22:50:10 <luca> in terms of the typing algorithm, let (and so fix) let's the function have a different type in each instance of it's use
22:50:11 <Cale> fix $ \loop -> do <a bunch of stuff>; when (something) loop
22:51:10 <Cale> luca: Are you saying that there's a typing difference between the definitions of fix?
22:51:47 <luca> well that's the point of let in terms of typing, at each use you can take a fresh instance of the principal type?
22:52:06 <dmwit> There's only one use.
22:52:07 <Cale> Well, but here the thing being defined in the let is only used once
22:52:28 <Cale> So the difference in the typing rule isn't such a big deal here
22:52:40 <dmwit> Depends how you count uses, I guess -- could count two.
22:53:00 <dmwit> fix f = let x = f {- here -} x in {- and here -} x
22:53:16 <dmwit> But they're used at the same type in both places. =)
22:54:03 <andares> huh, crazy.
22:54:29 <nand`> > let iterate = fix (\it f x -> x : it f (f x)) in iterate (+1) 0
22:54:29 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
22:55:05 <andares> crazy. the lambda expression is having itself passed in as an argument to itself.
22:55:23 <nand`> contrast
22:55:26 <nand`> @src iterate
22:55:26 <lambdabot> iterate f x =  x : iterate f (f x)
22:56:50 <nand`> s/contrast/compare/
22:57:08 <luca> example where let lets f be typed two ways:
22:57:10 <andares> makes sense., kinda.
22:57:31 <luca> let f = \a b -> a + b in (f 1 2, f 1.0 2.0)
22:57:48 <dmwit> andares: Somewhere in the software stack between your keyboard and your IRC client, backspaces are getting misinterpreted.
22:57:59 <luca> with type inference, f 1 2 would be typed Int -> Int -> Int, and f 1.0 2.0 as f Float -> Float -> Float or whatever floating ponit type is in haskell (can't remember)
22:58:28 <andares> dmwit: how so?
22:58:48 <dmwit> andares: literal backspace characters are being sent to the IRC server, rather than an edited text
22:59:09 <andares> dmwit: I never typed backspace in this sentence, though.
22:59:26 <dmwit> makes sense.<backspace>, kinda. <- this is what came through here
22:59:28 <flux> andares, those sequences are typical of using irssi and its pastep rotection
22:59:34 <nand`> fixed point combinators are also useful when reasoning about strictness of recursive functions; by considering them as the limit of a chain of functions
22:59:51 <andares> huh, weird. I'm using Colloquy though.
22:59:56 <dmwit> ah,<backspace> I see. it's a lazy way to say f(f... <- and here
23:01:57 <luca> @pl \x -> map transf (map snd x)
23:01:57 <lambdabot> map (transf . snd)
23:02:46 <dmwit> wow
23:02:50 <andares> ah, dmwit, apparently it's a bug in OS X. bummer. :/
23:02:52 <dmwit> ?pl map foo . map bar
23:02:52 <lambdabot> map (foo . bar)
23:03:06 <dmwit> andares: =/
23:03:08 <nand`> hey, that reminds me
23:03:13 <andares> I could probably modify colloquy to erase the backspace characters. before it sends them.
23:03:53 <nand`> can fmap id = id  be inferred from fmap f . fmap g = fmap (f.g)? I'm thinking fmap id . fmap g = fmap (id . g) = fmap g = fmap g . fmap id
23:04:08 <nand`> but does the property of f . g = g = g . f  mean f = id?
23:04:50 <nand`> hmm
23:05:05 <nand`> I think I can construct a trivial functor instance where fmap f . fmap g = fmap (f.g) holds but fmap id = id does not
23:05:34 <luca> sure f . g = g = g . f necessarigly means f is id?
23:05:38 <luca> surely*
23:05:51 <nand`> luca: this is not “for all g”
23:06:07 <luca> ah well then no
23:06:19 <nand`> right, that's what I feared; indeed fmap _ _ = <Constant> can break it
23:06:33 <luca> g = f = \x -> 0 then f . g = g = g . f :P
23:06:52 <nand`> luca: exactly :)
23:07:43 <luca> hmm i wish there was a way to highlight an expression and have ghc tell me it's type based on the context :P
23:08:01 <dmwit> The Typeclassopedia teaches us that fmap id = id implies fmap f . fmap g = fmap (f . g) (but not vice versa).
23:08:10 <nand`> luca: you might like some of the Haskell super-editors aiming to do just that
23:08:30 <luca> it'd help when i get a type error and i could just highlight sub expression and check it has type i expect etc
23:08:48 <nand`> dmwit: I'm not sure how the forward construction goes; surely fmap id . fmap f = fmap (id . f), but how does it generalize to all g?
23:09:53 <dmwit> ?free fmap
23:09:53 <lambdabot> Expected variable or '.'
23:10:03 <dmwit> ?free fmap :: (a -> b) -> (f a -> f b)
23:10:03 <lambdabot> Plugin `free' failed with: Plugin/Free/Type.hs:(152,16)-(160,44): Non-exhaustive patterns in case
23:10:16 <dmwit> ?free fmap :: (a -> b) -> f a -> f b
23:10:16 <lambdabot> Extra stuff at end of line
23:10:25 <Pseudonym> ?free fmap :: (a -> b) -> F a -> F b
23:10:25 <lambdabot> g . h = k . f => $map_F g . fmap h = fmap k . $map_F f
23:10:26 <dmwit> come on
23:10:36 <Pseudonym> It can't handle variables with higher kinds.
23:10:43 <Pseudonym> But assumes that F, G etc are functors.
23:10:50 <dmwit> haha
23:11:06 <luca> right. cs :: [(Expr,[Expr])], transf :: Expr -> State ([Expr],Int) [Expr], and trying to write (liftM concat) (map (transf . snd) cs). map (transf. snd) cs 'should' have type State ([Int],Int) [[Expr]], but doesn't type
23:11:21 <Pseudonym> Not in the lambdabot version, but implemented in my version:
23:11:25 <Pseudonym> *Test> putStrLn $ tIdA
23:11:25 <Pseudonym> idA :: forall a. A a a
23:11:25 <Pseudonym> *Test> putStrLn . freeTheoremStr $ tIdA
23:11:25 <Pseudonym> idA >>> $arr f = $arr f >>> idA
23:12:51 <Pseudonym> It assumes that a constructor of kind * -> * -> * is an Arrow. Except for (,) and Either.
23:13:09 <Pseudonym> ?free injl :: a -> Either a b
23:13:10 <lambdabot> $map_Either f g . injl = injl . f
23:13:41 <Pseudonym> Actually, I guess it assumes it's a Category.
23:13:45 * Pseudonym should change $arr to $pure
23:14:07 <Pseudonym> Or something.
23:15:54 <luca> :t map . map
23:15:55 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
23:16:10 <luca> :t mapM . map
23:16:11 <lambdabot> forall b a. (a -> b) -> [[a]] -> [[b]]
23:16:15 <Pseudonym> ?free mapmap :: forall a b. (a -> b) -> [[a]] -> [[b]]
23:16:15 <lambdabot> g . h = k . f => $map ($map g) . mapmap h = mapmap k . $map ($map f)
23:16:18 <luca> :t map . mapM
23:16:19 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [[a]] -> [m [b]]
23:16:42 <luca> :t mapM . mapM
23:16:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [[a]] -> m [[b]]
23:18:06 <dmwit> Anyway, the upshot of that law is that fmap = $map_F
23:18:19 <Pseudonym> Not exactly.
23:18:51 <luca> @pl \xs -> let xs' = map snd xs in ((mapM . mapM) transf) xs'
23:18:51 <lambdabot> mapM (mapM transf) . fix . const . map snd
23:18:52 <Pseudonym> fmap f xs = []
23:18:59 <Pseudonym> That satisfies the free theorem.
23:19:29 <dmwit> Sorry, the upshot of that law *and* the condition that fmap id = id is that fmap = $map_F.
23:19:33 <luca> @unpl mapM (mapM transf) . fix . const . map snd
23:19:33 <lambdabot> (\ d -> mapM (mapM transf) (fix (\ _ -> map snd d)))
23:19:35 <Pseudonym> Yes.
23:19:44 <Pseudonym> I think.
23:19:52 <Pseudonym> Hmm.
23:19:54 <Pseudonym> Actually, no.
23:20:02 <dmwit> Because we can take g = k and h = f = id.
23:20:18 <Pseudonym> myFmapIO f m = launchMissiles >> fmap f m
23:20:28 <luca> is there a nicer way to write mapM . mapM ?
23:20:45 <dmwit> Pseudonym: This does not satisfy myFmapIO id = id.
23:20:50 <Pseudonym> Ah, true.
23:21:44 <Pseudonym> *Test> putStrLn tPure
23:21:44 <Pseudonym> pure :: (a -> b) -> A a b
23:21:44 <Pseudonym> *Test> putStrLn . freeTheoremStr $ tPure
23:21:44 <Pseudonym> g . h = k . f
23:21:44 <Pseudonym> =>
23:21:45 <Pseudonym> pure h >>> $arr f = $arr g >>> pure k
23:21:48 <Pseudonym> Yup, as expected.
23:22:31 <dmwit> And the upshot of fmap = $map_F is that fmap (a . b) = fmap a . fmap b, because we can take g = a . b, h = id, k = a, and f = b.
23:22:42 <dmwit> nand`: did you get that? =)
23:23:05 <nand`> dmwit: wasn't reading; let me catch up
23:24:54 <nand`> dmwit: fair enough
23:26:27 <dmwit> Anyway, it's specific to Hask.
23:27:22 <nand`> why?
23:27:35 <dmwit> The free theorem is a result of parametricity.
23:27:46 <dmwit> Parametricity is not available in all categories.
23:28:02 <nand`> oh
23:28:09 <luca> @pl mapM (liftM concat . mapM transf)
23:28:09 <lambdabot> mapM (fmap join . mapM transf)
23:28:32 <dmwit> :t \f -> mapM (fmap join . mapM f)
23:28:33 <lambdabot> forall a (m :: * -> *) a1. (Functor m, Monad m) => (a1 -> m [a]) -> [[a1]] -> m [[a]]
23:28:35 <Saizan> to be fair, most of the time parametricity just saves you from having to prove some naturality condition
23:28:39 <Pseudonym> ?free naturalTransformation :: forall a. F a -> G a
23:28:39 <lambdabot> $map_G f . naturalTransformation = naturalTransformation . $map_F f
23:28:43 <Pseudonym> Like that.
23:29:17 <luca> dmwit, is there a better way to write that?
23:29:40 <luca> take a -> m b and produce [[a]] -> m [[b]]
23:29:50 <dmwit> luca: That's not what the function you wrote does.
23:30:00 <luca> a -> m [b] *
23:30:50 <dmwit> probably not
23:31:07 <dmwit> Not one so shockingly better that it's worth the effort, anyway.
23:32:49 <luca> @pl mapM ((liftM concat . mapM transf) . snd)
23:32:49 <lambdabot> mapM (fmap join . mapM transf . snd)
23:33:24 <luca> :t join
23:33:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
23:33:55 <luca> why does pl always give fmap instead of liftM ?
23:34:54 <luca> @pl liftM (Just . concat) . mapM f
23:34:55 <lambdabot> fmap (Just . join) . mapM f
23:35:11 <luca> ah i see, join and concat have same type
23:35:35 <nand`> :t (sequence . fmap sequence) .: (.:)
23:35:37 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [[a1]] -> m [[a]]
23:35:38 <luca> (if monad is list)
23:35:52 <luca> .: (.:) wtf
23:36:01 <luca> oh write, . :
23:36:02 <luca> haha
23:36:08 <luca> right*
23:36:10 <nand`> pop quiz: how many of Cale's silly generalizations did that use?
23:36:25 <nand`> wait, I can make it more obfuscated
23:36:50 <geekosaur> liftM is more or less an artifact of Monad not actually requiring Functor like it should, I think
23:37:15 <nand`> :t (sequence . (sequence .)) .: (.:)
23:37:16 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [[a1]] -> m [[a]]
23:38:08 <dmwit> What is liftA an artifact of, then?
23:40:01 * geekosaur has never understood why liftA exists, tbh
23:45:05 <Saizan> liftM would be useful as a fmapDefault anyway
23:46:00 <andares> hey, I have a typeclass with two parameters and it's messing things up.
23:46:45 <andares> basically I have class Active a v where active :: v -> a.
23:46:55 <Cale> nand`: 0
23:47:07 <Pseudonym> The real answer is to make Functor a superclass of Monad, and let liftM be a default implementation.
23:47:12 <Pseudonym> But Haskell doesn't support that yet.
23:47:27 <andares> then I have a newtype Test = Test (forall a. Foo a => a -> IO ())
23:47:36 <andares> and I'm trying to make Test an instance of Active.
23:47:42 <andares> but the typechecker complains.
23:47:46 <nand`> Cale: I'm quite sure it relies on (.) = fmap; or is that not of your doing?
23:48:08 <Cale> nand`: Oh, the second version at least does
23:48:27 <nand`> Cale: the first one does too; the latter (.:) is actually fmap . fmap (in the non-Cale version)
23:49:03 <Cale> I didn't know there was a Cale version of .:
23:49:04 <dmwit> andares: insufficient data for meaningful answer
23:49:05 <andares> so I think it's ambiguous. I'm not sure what to do though.
23:49:20 <andares> the last question :p
23:49:59 <andares> so I have instance Active  ToggleButtonP Bool where active p  = ToggleButtonP (toggleButtonSetActive p) as the instance definition.
23:50:12 <andares> where ToggleButtonP is defined as newtype ToggleButtonP = ToggleButtonP (forall w. ToggleButtonClass w => w -> IO ())
23:50:17 <shachaf> @ty fmap (fmap (fmap (fmap fmap (fmap fmap fmap sequence fmap) sequence))) fmap fmap fmap
23:50:18 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [[a1]] -> m [[a]]
23:50:21 <shachaf> Add fmap to taste.
23:50:59 <andares> but I think it interprets ToggleButtonP Bool as * -> *, rather than * -> * and *
23:51:11 <andares> er, * -> * -> * and *
23:51:21 <dmwit> You're very confused.
23:51:44 <andares> er.. I mean, interprets ToggleButton Bool as kind *, rather than as two parameters of kinds * -> * and *
23:51:47 <dmwit> Both ToggleButtonP :: * and Bool :: *, and it's not misinterpreting them.
23:52:25 <dmwit> However, there are real errors later, and here I'm assuming you actually wrote the class Active incorrectly above.
23:52:42 <shachaf> @ty fmap fmap fmap fmap fmap fmap fmap fmap (fmap fmap (fmap fmap fmap sequence fmap) sequence) fmap fmap fmap
23:52:43 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [[a1]] -> m [[a]]
23:52:45 <shachaf> Much clearer.
23:53:02 <andares> class Active a v where active :: v -> a
23:53:10 <andares> verbatim from the code, minus some line breaks
23:53:27 <nand`> Cale: (.:) = (.) . (.) so with Caleskell's (.) = fmap it's actually fmap fmap fmap
23:53:36 <andares> the error is that it can't deduce w ~ Bool.
23:53:36 <shachaf> andares: What are you trying to do?
23:53:40 <nand`> my example wouldn't work with Prelude..
23:53:48 <andares> fix some broken code beyond my comprehension.
23:53:55 <andares> well, first comprehend the broken code, then fix it.
23:53:57 <nand`> hmm
23:54:07 <dmwit> andares: Yes, the first argument to toggleButtonSetActive is the widget, not the Bool. =)
23:54:14 <nand`> for some reason my lambdabot seems to have Prelude.. in scope for some reason; even though it's explicitly hidden in the import in L.hs
23:54:22 <dmwit> andares: use flip or sections+infix ticks
23:54:36 <andares> oh, wow. I'm beginning to wonder whether this ever compiled.
23:54:37 <dmwit> (`toggleButtonSetActive` p)
23:55:03 <nand`> oh, it's not in scope; just for @type
23:57:05 <amatsu> Can anybody recommend a good starting point for learning algorithms?
