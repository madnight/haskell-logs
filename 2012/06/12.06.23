00:00:46 <c_wraith> both are possible
00:01:43 <solrize> i tried memoizing with an array instead of an infinite tree, and the array is very fast too
00:04:43 <solrize> i was saying earlier, this memoization stuff is beautiful but seems like horrible hackery at the same time, subverting the evaluator to run fiendish imperative code behind the scenes
00:05:10 <b_> :[
00:07:29 <dmwit> memo-combinators? imperative?
00:07:39 * dmwit wants to live in solrize's world
00:09:16 <solrize> yeah, imperative in the sense that it's concocted to overwrite thunks in memory at just the right moments
00:15:02 <solrize> conal's MemoTrie library is also fast
00:15:07 <solrize> something is wrong with my version
00:32:37 <solrize> memo1.hs:5:18:
00:32:38 <solrize>     Could not find module `Data.MemoTrie':
00:32:38 <solrize>       Perhaps you haven't installed the profiling libraries for package `MemoTrie-0.5'?
00:32:38 <solrize>       Use -v to see a list of the files searched for.
00:33:11 <solrize> is there a cabal thing to get a profiling version?
00:37:31 <solrize> got it
00:38:03 <solrize> > fix error
00:38:04 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
00:59:19 <cesc> Hi! I'm starting to play with haskell and have the following n00b question:  why does "min 1 max 2 3" produce a compile error whereas "min 1 (max 2 3)" doesn't?    (just a little example trying to get the min out of 1 and whatever comes out of max 2 3, namely 3)
01:00:01 <xraycat> min expects 2 arguments, you passed 4
01:00:19 <jrw> cesc, the compiler assumes each space separates another argument to min unless you say otherwise
01:00:19 <shergill> cesc: operator precedence. it thinks min is being applied to 4 arguments. alternatively try min 1 $ max 2 3
01:00:39 <cesc> oh! thanks a bunch for the feedback. Understood
01:00:48 <cesc> I still don't know what the hell the $ does though :))
01:01:12 <jrw> it basically means take everything as far right as possible and make it a single argument
01:01:19 <shergill> it forces computation to the right of it, and then that value gets passed to the function to its left
01:01:28 <shergill> *as far right
01:01:35 <jrw> it absolutely does not force any computation
01:01:55 <shergill> sorry, jrw is right, bad choice of words
01:01:59 <cesc> thanks for clarifying that, jrw and shergill
01:02:18 <edwardk> preflex: xseen tgeeky
01:02:19 <preflex>  tgeeky was last seen on freenode/#haskell-blah 1 hour, 53 minutes and 24 seconds ago, saying: what does erlang do?
01:05:29 <roconnor_> edwardk: Hi edward, have you seen polymorphic van laarhoven lenses?
01:05:49 <edwardk> polymorphic van laarhoven'?
01:05:56 <edwardk> i saw the original van laarhoven ones
01:06:00 <edwardk> is this something new?
01:06:02 <roconnor_> polymorphic (van laarhoven - lenses)
01:06:10 <roconnor_> > let { x ^. l = getConst $ l Const x; l ^= nv = \x -> runIdentity $ l (Identity . const nv) x; fst h (a,b) = (\x -> (x,b)) <$> (h a); snd h (a,b) = (\x -> (a,x)) <$> (h b)} in ((fst ^= "hi") . (snd ^= [])) ('a',3)
01:06:12 <lambdabot>   ("hi",[])
01:06:38 <roconnor_> lets you do simple polymorphic updates ... for free.
01:06:38 <edwardk> roconnor_: whats different?
01:06:51 <roconnor_> the type of ('a',3) has changed
01:06:58 <roconnor_> maybe it isn't new
01:07:08 <roconnor_> since the code is unchanged :D
01:07:16 <dmwit> Peaker will be interested
01:07:33 <edwardk> is there a link?
01:07:40 <roconnor_> a link?
01:07:46 <dmwit> :t Const
01:07:47 <lambdabot> forall a b. a -> Const a b
01:07:48 <edwardk> to a discussion, post, etc
01:07:56 <roconnor_> nope
01:08:33 <roconnor_> I guess I wanted to check with you to see if it was obvious and you already knew this was possible.
01:08:34 <edwardk> what is the type of fst in that?
01:08:47 <roconnor_> @type let { x ^. l = getConst $ l Const x; l ^= nv = \x -> runIdentity $ l (Identity . const nv) x; fst h (a,b) = (\x -> (x,b)) <$> (h a); snd h (a,b) = (\x -> (a,x)) <$> (h b)} in fst
01:08:48 <lambdabot> forall t (f :: * -> *) a t1. (Functor f) => (t -> f a) -> (t, t1) -> f (a, t1)
01:09:01 <edwardk> how do they compose?
01:09:26 <dmwit> oh, what
01:09:46 <roconnor_> > let { x ^. l = getConst $ l Const x; l ^= nv = \x -> runIdentity $ l (Identity . const nv) x; fst h (a,b) = (\x -> (x,b)) <$> (h a); snd h (a,b) = (\x -> (a,x)) <$> (h b)} in (('a',7.7),3) .^ fst .^ snd
01:09:47 <dmwit> You're composing updates, there, not lenses!
01:09:48 <lambdabot>   Not in scope: `.^'Not in scope: `.^'
01:09:59 <roconnor_> > let { x ^. l = getConst $ l Const x; l ^= nv = \x -> runIdentity $ l (Identity . const nv) x; fst h (a,b) = (\x -> (x,b)) <$> (h a); snd h (a,b) = (\x -> (a,x)) <$> (h b)} in (('a',7.7),3) ^. fst ^. snd
01:10:01 <lambdabot>   7.7
01:10:10 <roconnor_> > let { x ^. l = getConst $ l Const x; l ^= nv = \x -> runIdentity $ l (Identity . const nv) x; fst h (a,b) = (\x -> (x,b)) <$> (h a); snd h (a,b) = (\x -> (a,x)) <$> (h b)} in (('a',7.7),3) ^. (fst . snd)
01:10:12 <lambdabot>   7.7
01:10:31 <roconnor_> edwardk: composition is as usual: . is compisition and id is the identity lens
01:10:34 <edwardk> :t let { x ^. l = getConst $ l Const x; l ^= nv = \x -> runIdentity $ l (Identity . const nv) x; fst h (a,b) = (\x -> (x,b)) <$> (h a); snd h (a,b) = (\x -> (a,x)) <$> (h b)} in (fst . snd)
01:10:35 <lambdabot> forall (f :: * -> *) t t1 a t2. (Functor f) => (t1 -> f a) -> ((t2, t1), t) -> f ((t2, a), t)
01:10:36 <dmwit> ?let x ^. l = getConst $ l Const x
01:10:38 <lambdabot>  Defined.
01:10:50 <dmwit> ?let l ^= nv = \x -> runIdentity $ l (Identity . const nv) x
01:10:51 <lambdabot>  Defined.
01:11:14 <dmwit> ?let fstLens h (a,b) = (\x -> (x,b)) <$> h a
01:11:15 <edwardk> interesting
01:11:15 <lambdabot>  Defined.
01:11:27 <dmwit> ?let sndLens h (a,b) = (\x -> (a,x)) <$> h b
01:11:28 <lambdabot>  Defined.
01:11:36 <dmwit> :t (^=)
01:11:37 <lambdabot> forall b a1 t a. ((b -> Identity a1) -> t -> Identity a) -> a1 -> t -> a
01:11:42 <edwardk> its also 4 am, so i may not be in the best shape to evaluate this ;)
01:11:42 <roconnor_> > let { x ^. l = getConst $ l Const x; l ^= nv = \x -> runIdentity $ l (Identity . const nv) x; fst h (a,b) = (\x -> (x,b)) <$> (h a); snd h (a,b) = (\x -> (a,x)) <$> (h b)} in  ((fst . snd) ^= "edwardk") (('a',7.7),3)
01:11:45 <lambdabot>   (('a',"edwardk"),3)
01:11:58 <roconnor_> edwardk: ah okay
01:12:03 <dmwit> I'm quite impressed. What's the price?
01:12:05 <roconnor_> edwardk: but at least it sounds unfamilar to you :D
01:12:16 <dmwit> Also, you shouldn't need so darn much of a prelude now...
01:12:19 <roconnor_> and to dmwit
01:12:31 <dmwit> > ((fstLens . sndLens) ^= "edwardk") (('a',7.7),3)
01:12:33 <lambdabot>   (('a',"edwardk"),3)
01:13:07 <edwardk> :t fstLens
01:13:08 <lambdabot> forall t (f :: * -> *) a t1. (Functor f) => (t -> f a) -> (t, t1) -> f (a, t1)
01:13:45 <edwardk> :t fstLens . fstLens
01:13:46 <lambdabot> forall (f :: * -> *) t1 t a t11. (Functor f) => (t -> f a) -> ((t, t11), t1) -> f ((a, t11), t1)
01:13:54 <edwardk> thats cute
01:13:58 <dmwit> very cute
01:14:21 <edwardk> the fact that its good old fashioned . is kinda scary
01:14:33 <edwardk> why did i hate these again?
01:15:02 <roconnor_> edwardk: you said they were less efficent
01:15:07 <dmwit> :t fstLens Prelude.. fstLens
01:15:07 <lambdabot> forall (f :: * -> *) t1 t a t11. (Functor f) => (t -> f a) -> ((t, t11), t1) -> f ((a, t11), t1)
01:15:09 <edwardk> oh yeah
01:15:36 <edwardk> not _that_ bad in practice though
01:15:48 <roconnor_> we might be able to have both worlds
01:15:52 <edwardk> i must have missed the memo where these allowed for polymorphic updates though
01:16:10 <roconnor_> use store coalgebra for most things, and van laarhoven lenses when you want polymorphic updates.
01:16:21 <roconnor_> edwardk: I only realized it 2 days ago.
01:16:30 <edwardk> hrmm
01:16:47 <roconnor_> I couldn't tell if it was so obvious that no one had mentioned it, or if it was unknown
01:17:01 <edwardk> i overlooked it
01:17:15 <roconnor_> the horrible bit is that the code is unchanged.
01:17:18 <edwardk> and my major complaint about lenses is we couldn't do polymorphic updates!
01:17:25 <dmwit> Until now, I thought it was sort of folklore that lenses and polymorphic updates were incompatible.
01:17:36 <edwardk> yeah
01:17:37 <roconnor_> well, it still cannot do complex polymorphic updates
01:17:40 <edwardk> thats why i'm impressed
01:17:45 <edwardk> hrmm
01:17:51 <edwardk> define complex?
01:17:53 <dmwit> What's a complex polymorphic update?
01:17:55 <roconnor_> like data Foo a = Foo {  f1 : a, f2 : a }
01:18:05 <roconnor_> well
01:18:24 <roconnor_> like data Foo a b = Foo {  f1 :: a, f2 :: a , f3 :: b} -- less trivial
01:18:30 <edwardk> well, you have to update both simultaneously, and you can't take a product of two lenses anyways, so that can be updated, but you have to fight for it ;)
01:18:54 <roconnor_> in haskell you can updates f1 and f2 together so long as they move to the same type
01:19:00 <edwardk> yep
01:19:12 <dmwit> Presumably you could still write one of these polymorphic lenses with codomain (a,a)?
01:19:16 <dmwit> ah
01:19:16 <roconnor_> with polymorphic lenses, you have to hand craft a f1_plus_f2 lens
01:19:27 <dmwit> hm
01:19:29 <roconnor_> but couldn't compose it ... AFAIK
01:20:35 <roconnor_> I guess I should write a blog post :D
01:20:50 <dmwit> roconnor++ on faith
01:20:57 <edwardk> roconnor++
01:20:58 <b_> how'd I write: "f >>= g h" with unix pipes?
01:21:23 <dmwit> f | g h
01:21:42 <b_> like "cat cakes.txt | runghc x.hs arg1"
01:21:58 <dmwit> what
01:22:07 <dmwit> Can you be more specific about what you want?
01:22:26 <b_> runghc x.hs arg1 foobar should output foobar
01:23:05 <b_> and it does, but how do I pipe the output of "cat cakes.txt" to "runghc x.hs args1"
01:23:26 <dmwit> Do you want the contents of cakes.txt to be command-line arguments to runghc?
01:23:35 <b_> yeah
01:23:38 <dmwit> If so, runghc x.hs args1 `cat cakes.txt`
01:24:03 <b_> muchas gracias
01:25:23 <dmwit> ?tell Peaker > let { x ^. l = getConst $ l Const x; l ^= nv = \x -> runIdentity $ l (Identity . const nv) x; fst h (a,b) = (\x -> (x,b)) <$> (h a); snd h (a,b) = (\x -> (a,x)) <$> (h b)} in  ((fst . snd) ^= "omg polymorphic") (('a',7.7),3)
01:25:23 <lambdabot> Consider it noted.
01:26:12 <edwardk> i'll have to give those a shot in scala
01:26:27 <edwardk> erf, guess they work less well there
01:47:14 * hackagebot syb 0.3.6.2 - Scrap Your Boilerplate  http://hackage.haskell.org/package/syb-0.3.6.2 (JosePedroMagalhaes)
01:53:13 <roconnor_> I guess i can replace \x -> runIdentity $ l (Identity . const nv) x with simply runIdentity . l (Identity . const nv)
01:53:40 <roconnor_> > let { x ^. l = getConst $ l Const x; l ^= nv = runIdentity . l (Identity . const nv); fst h (a,b) = (\x -> (x,b)) <$> (h a); snd h (a,b) = (\x -> (a,x)) <$> (h b)} in  ((fst . snd) ^= "omg polymorphic") (('a',7.7),3)
01:53:43 <lambdabot>   (('a',"omg polymorphic"),3)
01:57:32 <Wooga> hi, is there any bindings for POSIX tcgetattr() and tcsetattr() functions for haskell, or any other way to control terminal state?
02:02:24 <Wooga> oh, found it: http://hackage.haskell.org/packages/archive/unix/2.5.0.0/doc/html/src/System-Posix-Terminal.html
02:02:30 <roconnor_> :)
02:13:04 <ttt--> > let foo a = 4 in foo _
02:13:05 <lambdabot>   Pattern syntax in expression context: _
02:13:13 <ttt--> > let foo = 4 in foo
02:13:14 <lambdabot>   4
02:13:27 <ttt--> > let foo _ = 4 in foo()
02:13:29 <lambdabot>   4
02:13:50 <ttt--> > let foo _ = 4 in foo ()
02:13:51 <lambdabot>   4
02:20:09 <mikeplus64> why does () have Bounded and Enum instances?
02:20:14 <mikeplus64> > succ ()
02:20:15 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
02:20:20 <mikeplus64> > pred ()
02:20:21 <lambdabot>   *Exception: Prelude.Enum.().pred: bad argument
02:20:31 <mauke> > [minBound .. maxBound]
02:20:33 <lambdabot>   [()]
02:20:44 <sipa> the values of its type are certainly bounded and enumeratable :)
02:21:06 <sipa> :t succ
02:21:07 <lambdabot> forall a. (Enum a) => a -> a
02:21:28 <sipa> enumerable, i supppose
02:22:26 <solrize> @where evaluate
02:22:26 <lambdabot> I know nothing about evaluate.
02:22:48 <sipa> bad bot, bad
02:40:31 <kallisti> @pl (\x y -> [x,y]) 'a' 'b'
02:40:31 <lambdabot> "ab"
02:40:36 <kallisti> @pl (\x y -> [x,y])
02:40:36 <lambdabot> (. return) . (:)
02:41:22 <bigblack> ** BLACK CAVIAR - Racing Today for 22 WINS from 22 Races - Show your support! - JOIN @ http://www.BlackCaviarForum.com **
02:45:45 <DexterLB> what's the best way to convert a function "f :: a -> b -> c -> d" into "f :: (a, b, c) -> d"? I looked into uncurry, but it only works with 2-tuples
02:46:47 <yert> Hello, I am getting this errror "<stdin>: hGetLine: illegal operation (handle is closed)", while attempting to call liftIO $ getLine. I cannot find what does it mean
02:46:54 <kallisti> it would be fun if [,] were equivalent to (\x y -> [x,y])
02:46:57 <Taneb> yert, restart ghci
02:47:15 <yert> Taneb: this is after compilation with ghc
02:47:19 <Taneb> !!!
02:47:39 <Taneb> Hmm
02:47:45 <Taneb> Paste your code somewhere?
02:48:10 <yert> sure
02:50:34 <yert> http://hpaste.org/70336
02:50:41 <mekeor> kallisti: yea, i suggested that once, too. but other people in #haskell didn't like that suggestion‚Ä¶ ;(
02:52:59 <james-ubc> if i import say Graphics.Gloss, do i still need to import Graphics.Gloss.Interface?
02:53:08 <DexterLB> is there a way to flatten nested tuples?
02:53:08 <mekeor> DexterLB: g f (x,y,z) = f x y z
02:53:27 <Taneb> yert, I'm afraid I don't know
02:53:39 <DexterLB> mekeor: well yeah, that would work
02:53:42 <Taneb> It looks like stdin has been closed
02:54:00 <mekeor> DexterLB: just do it manually‚Ä¶ at least, i'd do so.
02:54:27 <mekeor> DexterLB: h (x,(y,z)) = (x,y,z) -- i'd just define it like this.
02:55:01 <DexterLB> mekeor: that would work too, again manual :D
02:55:24 <mekeor> yup =)
02:55:53 <kallisti> mekeor: I don't see anything wrong with it other than it's not needed.
02:56:17 <mekeor> kallisti: yea, that was their main argument‚Ä¶ "not needed"‚Ä¶
02:56:33 <mekeor> kallisti: i like its analogy to (,), anyway.
02:56:35 <yert> Taneb: Yeah, but thanks for taking a look anyway :)
02:57:16 <roconnor_> what is the predicence of . ?
02:57:20 <kallisti> mekeor: there are plenty of conviences in Haskell that aren't strictly needed
02:57:30 <mekeor> roconnor_: infixr 9 .
02:57:34 <kallisti> but many of them arise out of it being an extremely common thing to do.
02:58:02 <roconnor_> boo
02:58:36 <mekeor> roconnor_?
02:58:46 <roconnor_> I want to make an operator bind more tightly than .
02:59:31 <mekeor> fixity-numbers should just be floating point‚Ä¶ or at least between 0 and 100‚Ä¶
03:00:56 <mekeor> roconnor_: btw, you can do "ghci> :info (.)" for fixity declarations‚Ä¶
03:01:03 <roconnor_> ah thanks
03:05:09 <yert> Can someone tell me what is the correct way of using ErrorT and IO? Because it seems I cannot figure out the right way
03:13:55 <DexterLB> what's wrong with this pattern? _:[a, b, c]
03:14:06 <DexterLB> what I want it to match is the last 3 elements of a list
03:14:17 <mekeor> DexterLB: you can't.
03:14:24 <roconnor_> DexterLB: it isn't possible.
03:14:30 <DexterLB> ok
03:14:37 <DexterLB> but why? :)
03:14:48 <mekeor> @type (:) -- DexterLB, remember this:
03:14:49 <lambdabot> forall a. a -> [a] -> [a]
03:14:57 <roconnor_> because you can only match on the outer most layers of a recursive data type.
03:15:23 <roconnor_> DexterLB: if you reall want, you can use views to fake it
03:15:34 <mekeor> actually‚Ä¶ ignore me‚Ä¶
03:15:49 <DexterLB> that makes sense
03:15:50 <roconnor_> DexterLB: foo ((x,[a,b,c]) <- splitAtLast 3) = ...
03:16:53 <mekeor> > let f (_:[x,y,z]) = x+y+z in f [1,2,3,4]
03:16:55 <lambdabot>   9
03:17:43 <mekeor> DexterLB: this only works if the lists length is 4, of course‚Ä¶
03:20:32 <hpaste> cesc pasted ‚ÄúStupid question: why [x] ?‚Äù at http://hpaste.org/70337
03:20:57 <cesc> hey, I just pasted this example at http://hpaste.org/70337 where a function writes out the first character of a string capitalized
03:21:10 <cesc> why must "x" at the third line stand between brackets, e.g. [x]  ?
03:21:16 <nand`> cesc: because x has type ‚ÄòChar‚Äô
03:21:19 <cesc> (n00b question, I'm just confused)
03:21:21 <nand`> but the expression you're appending it to has type String
03:21:25 <nand`> (++) :: String -> String -> String
03:21:32 <nand`> String is [Char]
03:21:47 <cesc> where is x specified as Char?
03:21:49 <mekeor> cesc: the type of x is Char. (++) wants a String.
03:22:09 <nand`> cesc: you're pattern matching all@(x:xs), the (:) constructor has type a -> [a] -> [a] or in this case Char -> String -> String
03:22:22 <nand`> so consequently the x has type Char and the xs has type String
03:22:32 <cesc> ah!!!!
03:22:33 <cesc> thanks a lot
03:22:40 <nand`> it might help to intuitize what the (:) match does: matching on x:xs extracts the first element of the list (string) and binds it to x
03:22:42 <cesc> actually ":t (:)" gives the info.
03:22:58 <nand`> that it does :)
03:23:00 <cesc> nand`, mekeor:  thanks a bunch :)))
03:23:07 <mekeor> :)
03:25:28 <ttt--> hi, is anyone familiar with Graphics.Blank?
03:25:32 <ttt--> http://hpaste.org/70338
03:25:52 <ttt--> i try to draw some lines (to make a 100x100 grid) and firefox just hangs
03:26:03 <ttt--> it works ok for a 10x10
03:29:33 <ttt--> any ideas what im doing wrong?
03:32:20 * hackagebot time-lens 0.3 - Lens-based interface to Data.Time data structures  http://hackage.haskell.org/package/time-lens-0.3 (RomanCheplyaka)
03:45:51 <Wooga> hi, how do i posixcly set terminal size with haskell?
03:46:16 <Wooga> pseudo terminal, i mean
03:54:25 <danr> Wooga: What if you are using a WM like xmonad that ignores windows' intended sizes?
03:54:58 <Wooga> eh?
03:55:07 <ttt--> i found my error, i shouldve only called stroke() once
03:55:16 <Wooga> danr: what do you mean?
03:55:38 <danr> Hmm, why don't you try to explain what you meant in the first place?
03:55:50 <danr> Are you running a terminal emulator program in a window, which you want to resize?
03:56:01 <palmfrond> does haskell have the concept of parameters? or like, data that you pass with your statement or command or w/e
03:56:28 <Wooga> danr: want resize not the window itself, but slave/master pseudo-terminal pair inside of it
03:56:36 <zomg> palmfrond: how else would you send values into functions if not via parameters? :)
03:56:47 <palmfrond> zomg, no clue :P
03:56:51 * nand` is tempted to say ‚Äúno, all haskell functions are constants‚Äù
03:56:55 <palmfrond> so what are they called in haskell?
03:57:03 <nand`> palmfrond: ‚Äòparameters‚Äô?
03:57:03 <zomg> Parameters
03:57:03 <danr> Wooga: ok. Then I do not know
03:57:04 <palmfrond> arguments? parameters? ..?
03:57:17 <palmfrond> ok
03:57:18 <zomg> Arguments is probably also acceptable
03:57:31 <palmfrond> i don't like the negative connotation argument carries now
03:57:37 <mauke> parameters are the variables arguments get bound to
03:57:42 <palmfrond> yes
03:57:43 <nand`> palmfrond: argument carries negative connotations?
03:57:53 <palmfrond> yes, say to argue with a person
03:57:56 <mauke> let foo x = x + 1 in foo 41
03:58:01 <nand`> oh
03:58:03 <mauke> x is a parameter, 41 is an argument
03:58:20 <nand`> mauke: is this just your personal opinion or is that terminology widely accepted?
03:58:27 <palmfrond> mauke is correct
03:58:29 <nand`> it sounds non-obvious to me. I would call them both ‚Äòparameter‚Äô
03:58:30 <palmfrond> those are the terms
03:58:37 <zomg> Heh
03:58:49 <palmfrond> i was just curious if this concept in haskell was named for the term, or the value, and mauke answered that for me :)
03:58:53 <zomg> First time in my 12 or so years in programming that I'm told that there's a difference between parameters and arguments...
03:58:56 <zomg> :P
03:58:59 <mauke> nand`: http://en.wikipedia.org/wiki/Parameter_(computer_programming)#Parameters_and_arguments
03:59:03 <palmfrond> yea, not many know this
03:59:14 <nand`> mauke: I see
03:59:21 <zomg> palmfrond: this is why I hang around here
03:59:26 <zomg> smarter people than me
03:59:26 <palmfrond> mauke, so in haskell, you'd say "what did you pass for foo's parameter?" ?
03:59:26 <zomg> lol
03:59:29 <palmfrond> yep
03:59:38 <mauke> palmfrond: sure
03:59:58 <nand`> I'm not sure I'll go around chastising anybody for using ‚Äúargument‚Äù where ‚Äúparameter‚Äù would have been appropriate or vice versa :P
04:06:04 <shachaf> mauke: x is also an argument.
04:06:37 <mauke> to (+)?
04:06:41 <shachaf> Yes.
04:07:17 <AnalDialate> Anybody here sick and tired of fucking niggers?
04:07:19 <AnalDialate> I am!
04:07:28 <AnalDialate> That is why I am a member of a forum called Chimpout!
04:07:40 <AnalDialate> The link is right here shachaf! http://www.chimpout.com/forum
04:07:50 <AnalDialate> Chimpout is NOT a white supremacist forum!
04:07:54 <AnalDialate> I myself am a Mexican!
04:07:55 <shachaf> mauke: ‚òù
04:08:10 <AnalDialate> Pretty much, if you are not a NIGGER and you hate NIGGERS we welcome you with open arms!
04:08:17 <AnalDialate> Please join our Chimpout Forum today right now!
04:08:28 <AnalDialate> The link is right here mauke  http://www.chimpout.com/forum
04:08:49 --- mode: ChanServ set +o mauke
04:08:49 --- kick: AnalDialate was kicked by mauke (AnalDialate)
04:08:50 --- mode: mauke set +b *!*@128.204.196.111
04:09:45 <Botje> yawn
04:09:46 <Wooga> hi, back to my question about setting terminal size with haskell; how do i do ioctl(0,TIOCGWINSZ,&w) or ioctl(0,TIOCSWINSZ,&w) here?
04:09:58 <shachaf> Write a C function and bind to it.
04:10:03 <Botje> the GNAA used to be more entertaining.
04:10:06 <shachaf> Or maybe you can bind to ioctl directly.
04:10:08 <Wooga> there is no bindings for ioctl already?
04:10:26 <shachaf> There probably is.
04:10:33 <mauke> http://hackage.haskell.org/packages/archive/ioctl/0.0.1/doc/html/System-Posix-IOCtl.html
04:10:49 --- mode: mauke set -o mauke
04:13:37 <Wooga> thanks, but how do i use it? what is "req" there?
04:14:03 <mauke> it might actually be easier to write a C function here
04:14:45 <mauke> I think you're supposed to define a new data type for each kind of request
04:14:57 <mauke> then make it an instance of IOControl
04:15:04 <Wooga> oh
04:15:51 <mauke> the instance will associate your type req with a data parameter d
04:16:15 <shachaf> What's the type class for?
04:16:32 <mauke> you can then call „Äåioctl fd req d„Äç, which will use ioctlReq to determine the ioctl code
04:17:17 <mauke> and 'with' to allocate memory, serialize d to it, call ioctl with the result, then deserialize again
04:17:34 <shachaf> Ah.
04:17:58 <Wooga> oh, i kinda get it. thanks!
04:18:06 <mauke> wait, this can't work
04:19:17 <mauke> yeah, he imports ioctl at type CInt -> CInt -> Ptr () -> IO CInt
04:19:28 <mauke> enjoy your crashes
04:21:06 <Wooga> hmm, i don't know anything about C <-> Haskell interfaces. why would it crash?
04:21:27 <mauke> because ioctl is actually a vararg function
04:21:55 <mauke> the haskell ffi can't bind to that
04:22:18 <Wooga> so this IOCtl support entirely broken?
04:22:21 <mauke> and the C standard allows vararg function to have a totally different calling convention that normal functions
04:22:26 <mauke> depends!
04:22:56 <mauke> I'm pretty sure it will work perfectly on x86 systems with ioctls that take pointers
04:23:00 <nand`> there's ‚Äòderiv‚Äô for automated derivations, but has anything similar been attempted for integration?
04:23:17 <mauke> those that take ints ... you're screwed
04:23:22 <mauke> and I don't know about 64-bit systems
04:23:33 <navaati1> mauke: i've already had problems with using the bare ioctl call even with pointers
04:23:50 <navaati> ah, maybe i was on amd64 yeah‚Ä¶
04:24:10 <navaati> anyway, the easy workaround is to write a dumb c wrapper
04:24:26 <shachaf> mauke: In practice there's either 2 arguments or 3 arguments where the 3rd is a pointer, right?
04:24:40 <mauke> shachaf: the third one can be an int
04:24:51 <shachaf> Ah, yes.
04:24:51 <navaati> quit rare tho, isn't it ?
04:24:57 <navaati> s/quit/quiet/
04:25:35 <mauke> 41 of those in my 'man ioctl_list'
04:26:53 <mauke> for maximum theoretical portability you'd have to write a C wrapper for each possible type
04:27:40 <mauke> in practice you want at least three different variants
04:27:42 <navaati> hum, this list seems incomplete, for example i don't see any of the DRM ioctls
04:27:55 <roconnor_> ?tell Peaker http://r6.ca/blog/20120623T104901Z.html
04:27:56 <lambdabot> Consider it noted.
04:28:00 <navaati> btw, doesn't GHC.* give access to the syscalls without usinc FFI ?
04:28:02 <roconnor_> ?tell dmwit http://r6.ca/blog/20120623T104901Z.html
04:28:03 <lambdabot> Consider it noted.
04:28:08 <roconnor_> ?tell edwardk http://r6.ca/blog/20120623T104901Z.html
04:28:08 <lambdabot> Consider it noted.
04:28:21 <mauke> all of which can be done in one wrapper function, but you really want three different calls to ioctl() in there
04:28:45 <mauke> navaati: "This list is very incomplete."
04:28:47 <DexterLB> how do I break very long lines of code?
04:28:59 <mauke> navaati: and the version number is "kernel 1.3.27"
04:29:37 <navaati> mauke: haha, waow 1.3.27‚Ä¶
04:29:56 <navaati> DexterLB: you use the return key
04:30:03 <navaati> (and use proper indentation)
04:30:09 <mauke> I wonder ...
04:30:34 <navaati> for example "func1 arg1
04:30:38 <ski> roconnor_ : interesting, ty :)
04:30:38 <navaati>                                 arg2" is valid haskell
04:31:18 * ski has wondered about this before
04:31:46 <mauke> http://mauke.hopto.org/stuff/haskell/hell.hs - this is how you machine code
04:32:15 <srhb> What.
04:32:48 <hpc> oh god, why
04:32:51 <mauke> problem, officer?
04:33:51 <DexterLB> wtf
04:33:53 <hpc> is that 64-bit?
04:34:03 <hpc> it does nothing for me
04:34:04 * ski . o O ( "and we can do useless things with the identity lens." :)
04:35:15 <mauke> hpc: 32-bit x86 linux
04:35:20 <hpc> huh
04:35:53 <palmfrond> what's identity lense?
04:35:55 <palmfrond> lens
04:36:31 <roconnor_> palmfrond: Lens a a -- views a as a substructure of itself
04:36:40 <ski> the useless lens which marks the whole structure
04:36:46 <DexterLB> mauke: 32 bit linux here, doesn't work :)
04:36:49 <palmfrond> ahhh
04:36:52 <palmfrond> like a scope
04:36:58 <palmfrond> well, not in haskell
04:37:05 <ski> roconnor_ : s/aand/and/
04:37:18 <roconnor_> thanks\
04:37:45 <mauke> DexterLB: what commands did you use, what happened?
04:38:54 <DexterLB> mauke: ghc foo.hs && ./foo
04:38:58 <DexterLB> and blank output
04:40:38 <mauke> DexterLB: ./foo; echo $?
04:41:03 <DexterLB> 0
04:41:30 <mauke> DexterLB: ./foo | xxd
04:41:48 <DexterLB> blank
04:41:59 <mauke> DexterLB: strace -o foo.log ./foo
04:42:13 <mauke> and paste foo.log somewhere because I want to figure out what's going wrong :-)
04:43:13 <DexterLB> http://bpaste.net/show/BXwqBH1fUPAcZSSYH0vW/
04:44:12 <hpc> roconnor_: that lens post is cool
04:44:26 <mauke> wtf
04:44:54 <roconnor_> hpc: thanks.  When I first realized this I wasn't sure if it was new, or just that it was so obvious to everyone else.
04:46:09 <hpc> i especially like the fact that it is able to run on top of the record system
04:46:15 <mauke> DexterLB: can you try http://hpaste.org/70339 ?
04:47:14 <DexterLB> A\nB\n
04:47:22 <mauke> er, with strace I mean
04:47:29 * hackagebot epub 0.0.7 - EPUB E-Book construction support library  http://hackage.haskell.org/package/epub-0.0.7 (RadoslavDorcik)
04:47:47 <hpc> mauke: heh, icwydt with those warns
04:48:10 <mauke> huh?
04:48:19 <DexterLB> mauke: http://bpaste.net/show/Y6eVavueeydrRzANj210/
04:48:32 <hpc> separating the RTS init/deinit messages from the actual main functino
04:48:47 <DexterLB> line 100 --> that's strange
04:49:03 <mauke> line 100 looks normal to me
04:50:25 <mauke> DexterLB: what I get: http://codepad.org/QoSydGUb
04:50:26 <hpc> it looks like it is completely ignoring your makeshift assembly
04:50:45 <mauke> yeah
04:51:07 <mauke> I would've at least expected a segfault
04:51:56 <mauke> also, I have some mmaps with PROT_EXEC in my log
04:52:02 <mekeor> where's the difference between those two pastes?
04:52:11 <hpc> maybe something in the kernel sees you trying to execute instructions in the data section and skips it
04:52:55 <hpc> or a change in GHC's generated assembly breaks it, or something
04:53:08 * hpc was using 7.4.1 when it did nothing
04:53:16 <mauke> 7.0.4 here
04:53:43 <hpc> don't have that on this box
04:54:05 <mauke> does http://mauke.hopto.org/stuff/c/hell.c work?
04:54:31 <hpc> yep
04:54:41 <DexterLB> 7.4.2
04:55:14 <mekeor> what is http://hpaste.org/70339 actually supposed to do?
04:55:46 <hpc> mekeor: printf("Hello, World!\n");
04:55:54 <mauke> mekeor: write "A\n" to stderr, "Hello, world!\n" to stdout, "B\n" to stderr, exit
04:55:58 <DexterLB> print A\nHello World\nB\n
04:56:04 <DexterLB> oh right
04:56:09 <mekeor> mauke: ah. so what should i see in the terminal?
04:56:31 <mauke> o_O
04:56:32 <nand`> ‚ÄúA\nHello, world!\nB\n‚Äù /me guesses
04:56:33 <mekeor> "A\nHello, world!\nB\n" right?
04:56:37 <mauke> yes
04:56:38 <mekeor> ok
04:56:46 <nand`> unless you redirect stdout/stderr :P
04:56:53 <mekeor> yea :)
04:56:58 <hpaste> mekeor pasted ‚Äúmy strace output‚Äù at http://hpaste.org/70340
04:57:31 <mauke> same symptoms then
04:57:40 <hpc> mekeor: ghc -V?
04:57:51 <mekeor> 7.4.1
04:58:14 <hpc> i think we have our answer
04:58:23 <mekeor> btw, 7.4.2 supports GHCI on ARM, right??? yay!
04:58:33 <hpc> :D :D :D
05:01:04 * nand` just realized commit diffs can be represented as a groupoid
05:02:23 * theadmin doesn't get how to install GHC on ARM apart from repositories -- you need GHC to build GHC, right?
05:02:44 <nand`> diff composition is associative, there exists identity diffs (empty ones) and each diff can be reversed by flipping + and -
05:08:39 <mekeor> roconnor_ is cool.
05:09:10 <hpc> theadmin: you use C to bootstrap
05:09:34 <theadmin> Oh... Okay. Well there's some guide on that on the wiki anyway
05:10:35 <mekeor> theadmin: but why do you want to compile it yourself? aren't there binaries for ARM? i installed ghc just with "apt-get install ghc" on my arm-machine‚Ä¶
05:11:31 <theadmin> mekeor: Uh, that depends on the distro honestly. For example, ArchLinux ARM has GHC 6.12.3, and only for ARMv5. I'm not sure what distro you use :P
05:12:00 <mekeor> ah ok.
05:13:54 <theadmin> I don't have any ARM hardware except my Android phone yet though, thinking to get a raspberry pi when the hype finally goes down (the stores keep being "sold out", the thing is too damn popular right now)
05:14:22 <sipa> theadmin: i received mine yesterday!
05:14:39 <mekeor> O/
05:14:58 <theadmin> sipa: Cool
05:15:15 <sipa> and i haven't even connected it yet :(
05:15:23 <mekeor> how does that smiley look again?‚Ä¶ "o/" or "\o/" or \o" or ‚Ä¶?
05:15:38 <mekeor> sipa: is it that version with lan?
05:15:43 <sipa> mekeor: of course
05:15:55 <theadmin> o/ or \o or... I've never seen the one in the middle tho, looks like an AIM icon xD
05:16:03 <sipa> or \\o and o//
05:16:09 <theadmin> mekeor: They don't sell the one without LAN yet
05:16:14 <sipa> and |o|
05:16:37 <sipa> they got 2 million orders or so
05:17:07 <mekeor> theadmin: oh okay‚Ä¶ didn't know that‚Ä¶
05:18:10 <theadmin> mekeor: Yeah. The one with LAN (model B) is $10 more expensive. When they make enough money to launch full scale production, both models will be around
05:18:36 <theadmin> Well I s'pose that's what they're waiting for anyway
05:20:28 <mekeor> > [(++"/"),('\\':),((++"/").('\\':))] <*> ["o","O"] -- just trying -- does it work? -- oO
05:20:30 <lambdabot>   ["o/","O/","\\o","\\O","\\o/","\\O/"]
05:24:43 <ksf> concatMapM :: Monad m => (a -> m [b]) -> [a] -> m [b] that's *so* close to bind it's annoying.
05:25:00 <hpc> oh god my brain
05:25:51 <hpc> i wonder if that generalizes for s/[]/n
05:25:52 <ksf> well, I have lots and lots and lots of foo -> m [bar] functions. but the list monad isn't a match for my patterns, at all.
05:26:07 <danr> well it's (Monad n,Monad m) => (a -> m (n b)) -> n a > m (n b), right? I have a feeling this probably exists, but with say, Traversable
05:26:18 <danr> @hoogle (a -> m (n b)) -> n a > m (n b)
05:26:18 <lambdabot> Warning: Unknown type >
05:26:19 <lambdabot> No results found
05:26:19 <hpc> yeah
05:26:23 <danr> @hoogle (a -> m (n b)) -> n a -> m (n b)
05:26:24 <lambdabot> Language.Haskell.TH.Quote dataToExpQ :: Data a => (forall b. Data b => b -> Maybe (Q Exp)) -> a -> Q Exp
05:26:24 <lambdabot> Language.Haskell.TH.Quote dataToPatQ :: Data a => (forall b. Data b => b -> Maybe (Q Pat)) -> a -> Q Pat
05:26:30 <danr> :(
05:26:45 <ksf> :t ListT Identity
05:26:46 <lambdabot> Not in scope: data constructor `ListT'
05:27:09 <hpc> fleeting thought: it's really easy to make a fast website with happstack
05:27:13 <hpc> and much harder to benchmark
05:27:24 <hpc> ab is inexplicably broken
05:27:33 <ski> @type Data.Traversable.traverse
05:27:34 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
05:27:36 <ski> @type Data.Traversable.mapM
05:27:37 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
05:27:39 <hpc> and i had to resort to some freaky forkIO and Network.HTTP
05:27:43 <ski> hpc ^
05:27:56 <hpc> ski: yay
05:28:04 <hpc> wait no
05:28:17 <hpc> that should be (a -> m (t b)) -> ...
05:28:21 <ski> oh, righht
05:28:22 <danr> yeah...
05:28:50 <ksf> mapM :: Monad m => (a -> m b) -> t a -> m (t b)
05:29:09 <ksf> :t mapM
05:29:10 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
05:30:44 <rwbarton> :t (.:)
05:30:45 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
05:30:46 <ksf> danr, not sure whether there's a monad for n.
05:30:56 <ksf> as said, ListT is not the one I'm looking for.
05:30:58 <rwbarton> :t fmap join .: Data.Traversable.mapM
05:30:59 <lambdabot> forall (m :: * -> *) a (f :: * -> *) a1. (Monad m, Functor f, Data.Traversable.Traversable m, Monad f) => (a1 -> f (m a)) -> m a1 -> f (m a)
05:31:01 <nand`> :t fmap join . Data.Traversable.sequenceA .: fmap
05:31:02 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Data.Traversable.Traversable m, Applicative m) => (a1 -> m a) -> m a1 -> m a
05:31:07 <nand`> oh
05:31:10 <nand`> blast, rwbarton was faster
05:31:19 <rwbarton> these type variable names are so confusing :P
05:31:34 <nand`> wait
05:31:38 <nand`> my type looks incorrect
05:31:49 <ski> @type \amtb -> liftM concat . Data.Traversable.sequence . fmap amtb
05:31:50 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> m [a]) -> [a1] -> m [a]
05:32:00 <nand`> :t \f -> fmap join . Data.Traversable.sequenceA . fmap f
05:32:01 <lambdabot> forall (m :: * -> *) a (f :: * -> *) a1. (Monad m, Applicative f, Data.Traversable.Traversable m) => (a1 -> f (m a)) -> m a1 -> f (m a)
05:32:12 <nand`> :t (fmap join . Data.Traversable.sequenceA) .: fmap
05:32:14 <lambdabot> forall (m :: * -> *) a (f :: * -> *) a1. (Monad m, Applicative f, Data.Traversable.Traversable m) => (a1 -> f (m a)) -> m a1 -> f (m a)
05:32:16 <ksf> ski, that's a slightly more general definition as the one I use.
05:32:43 <ski> ? mine is not more general
05:32:43 <ksf> concatMapM ::  Monad m => (a -> m [b]) -> [a] -> m [b]
05:32:43 <ksf> concatMapM f xs = liftM concat $ mapM f xs
05:33:13 <rwbarton> is there a mapA?
05:33:15 <ski> i suppose we need a `join'
05:33:16 <theadmin> What are we doing? Searching for crazy types?
05:33:23 <ski> @type Data.Traversable.mapA
05:33:24 <lambdabot> Not in scope: `Data.Traversable.mapA'
05:33:25 <nand`> theadmin: generalizing concatMapM
05:33:26 <danr> nand`: yours are right, aren't they?
05:33:30 <ski> @type Data.Applicative.mapA
05:33:31 <lambdabot> Couldn't find qualified module.
05:33:33 <ski> bah
05:33:33 <nand`> danr: I think so
05:33:45 <nand`> danr: there was just a precedence mixup in the first implementation I provided
05:33:56 <danr> right :)
05:34:24 * ski thought he saw it somewhere ..
05:34:27 <nand`> rwbarton's looks neatest though
05:34:30 <ksf> @djinn Monad m => (a -> m [b]) -> [a] -> m [b]
05:34:30 <lambdabot> Error: Undefined type []
05:35:01 <rwbarton> but with an unnecessary Monad constraint
05:35:08 <ksf> what I was actually trying to do was get rid of all those mentions of concatMapM.
05:35:23 <ski> rwbarton : not sure it's unnecessary
05:35:30 <ski> you need something `join'-like
05:35:36 <nand`> ski: he means on f
05:35:39 <rwbarton> i need join for what has unfortunately been called 'm'
05:35:40 <rwbarton> yeah
05:35:40 <nand`> mine only has the applicative constraint
05:35:48 <ski> maybe you can get away with something weaker, which relates it to the monad
05:36:06 <rwbarton> hmm wait
05:36:22 <rwbarton> oh ok
05:36:24 <rwbarton> @type sequenceA
05:36:25 <lambdabot> Not in scope: `sequenceA'
05:36:27 <nand`> wait
05:36:30 <rwbarton> @type Data.Traversable.sequenceA
05:36:31 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
05:36:36 <nand`> :t fmap join .: Data.Traversable.traverse
05:36:37 <lambdabot> forall (m :: * -> *) a (f :: * -> *) a1. (Monad m, Applicative f, Data.Traversable.Traversable m) => (a1 -> f (m a)) -> m a1 -> f (m a)
05:36:42 <rwbarton> aha
05:36:48 <rwbarton> i knew it just had some funny name
05:37:25 <ksf> http://hpaste.org/70341
05:37:33 <ksf> see, I'm scattering those all over the place.
05:38:36 <nand`> :t join .:: Data.Traversable.traverse
05:38:37 <lambdabot> forall (m :: * -> *) a a1 (g :: * -> *). (Monad m, Data.Traversable.Traversable m, Applicative g) => (a1 -> g (m a)) -> m a1 -> g (m a)
05:38:59 <nand`> Caleskell to the rescue
05:39:23 <rwbarton> ksf, what's with all the Identity monad?
05:39:34 <ksf> that's a placeholder for the real one.
05:40:11 <rwbarton> i see
05:40:36 <rwbarton> you don't really have "dataDecl :: Monad m => Decl Name -> m [Hask.Decl]" then i hope
05:40:57 <PaulV_> Hey, I haven¥t been in the Haskell scene for a couple of years now, but getting back into it
05:41:19 <mekeor> yay
05:41:37 * mekeor wonders what can make people leave haskell‚Ä¶
05:41:46 <ksf> rwbarton, well, actually, I do.
05:41:52 <PaulV_> mekeor: depression can
05:42:09 <mekeor> depression caused by haskell?? oO
05:42:13 <nand`> no
05:42:18 <nand`> depression caused by all of the other languages
05:42:21 <ksf> at the moment I tend to write monadic code in anticipation of the monadic features I *am* going to need.
05:42:21 <nand`> making you give up programming entirely
05:42:26 <ksf> like generating identifiers.
05:42:36 <mekeor> nand`: a i c.
05:44:23 <PaulV_> I¥ve been fiddling around with vectors with type-level length indicators using GADTs
05:44:50 <PaulV_> but wondered if I missed any amazing language extensions while I was away
05:45:34 <resure> Good day. Is Haskell good as first functional language to learn? Don't know, what to choose, Haskell or Erlang.
05:46:03 <PaulV_> one particular question of note is that I want to define a repeat function that doesn¥t require a context, is that possible now?
05:46:07 <nand`> resure: as good as any
05:46:13 <sipa> resure: you expect an unbiased answer here? ;)
05:46:28 <nand`> imo Haskell is the best first functional language (indeed the best first programming language) to learn because it makes the most sense :)
05:46:32 <nand`> (except when it doesn't)
05:46:52 <zomg> I think it sort of depends
05:47:00 <zomg> Learning Haskell takes time, compared to say some Lisp language
05:47:03 <nand`> I see erlang as more domain specific
05:47:17 <srhb> resure: If it's between Erlang and Haskell, do Haskell since it's way more general purpose
05:47:23 <mekeor> resure: learn Haskell because the it's very exciting and you can't stop wanting to learn more of it and also because the community and all those tools for developing haskell-programs are great!
05:47:26 <zomg> But Haskell is awesome for sure
05:47:26 <zomg> =)
05:47:30 <srhb> resure: (But you're asking this question in #haskell)
05:48:09 <resure> srhb: I asked the same question in #erlang
05:48:40 <nand`> resure: did they all tell you erlang is the greatest programmer language since the dawn of creation?
05:48:44 <nand`> programming*
05:48:45 <srhb> :-)
05:48:53 <mekeor> resure: erlang's syntax is kinda‚Ä¶ bad.
05:48:57 <theadmin> resure: Haskell is great. Just one hint though. Forget. Every. Freaking. Thing. you learned about programming before. That is, imperative. Unlearn. Don't try to do stuff the imperative way either.
05:49:42 <theadmin> I never even looked at Erlang though, haven't heard that name in ages
05:50:02 <mekeor> resure: haskell's syntax is lovely =)
05:50:32 <mekeor> anyway. resure said in #erlang that he will start with haskell and move to erlang afterwards! YAY.
05:50:42 <mekeor> resure, welcome to our brotherhood.
05:50:55 <resure> Thanks)
05:51:04 <nand`> Haskell is easy to learn at first because it synergizes with the mathematical intuition most people developed at school :P
05:51:13 <hpaste> PaulV pasted ‚ÄúRepeat for vector type‚Äù at http://hpaste.org/70342
05:51:25 <nand`> the concepts of ‚Äúfunctions‚Äù in the pure sense are not an unfamiliar one
05:52:02 <PaulV_> I pasted something, does anyone know if I can define repeat on my (or similar) vector type without using type classes?
05:52:09 <nand`> (then you get to stuff like ‚Äúsum [x | x <- [0..], x < 10]‚Äù and it gets more complicated :)
05:52:18 <mekeor> resure: already looking for a haskell-book? there are great free, online haskell-books on the web. particulary, "learn you a haskell for great good" and "real world haskell"‚Ä¶
05:52:33 <theadmin> nand`: Why do that... Isn't that the same as sum [0..10]?
05:52:46 <nand`> theadmin: it isn't
05:52:47 <theadmin> Err, 0..9 rather since <
05:53:09 <nand`> the point is that sum [x | x <- [0..], x < 10] never terminates
05:53:12 <mauke> takeWhile /= filter
05:53:16 <resure> mekeor: I'll start from "learn you a haskell for great good", thanks
05:53:17 <nand`> but yeah, you're right; it's a silly example
05:53:39 <Philippa> it's a potentially scary one, even, but yeah
05:53:52 <nand`> mauke hits the nail on the head
05:54:16 <mekeor> sum [x^3 | x <- [0..100], x `mod` 2 == 0] -- is probably a better example‚Ä¶
05:54:19 <Philippa> resure: personally I'd say don't /forget/ everything, but push it to one side. It turns out there are useful bridges to be built later on, especially if you like playing with different languages anyway
05:54:45 <rwbarton> Prelude> length ([0..] :: [Int])
05:54:45 <rwbarton> -2147483648
05:54:58 <mekeor> > maxBound :: Int
05:55:00 <lambdabot>   9223372036854775807
05:55:10 <nand`> mekeor: except that one terminates
05:55:17 <mekeor> > (maxBound :: Int) + 1
05:55:19 <lambdabot>   -9223372036854775808
05:55:48 <mekeor> nand`: true
05:55:52 <mauke> > complement 0 :: Word
05:55:53 <lambdabot>   18446744073709551615
05:56:07 <mekeor> nand`: could you make it terminate in agda, for example?
05:56:16 <nand`> mekeor: I don't know Agda, sorry
05:56:17 <hpaste> b pasted ‚Äúa‚Äù at http://hpaste.org/70343
05:56:20 <mekeor> oh, in agda everything terminates‚Ä¶ right‚Ä¶
05:56:49 <kallisti> mekeor: using Peano naturals you can potentially have it terminate if you don't evaluate the entire thing.
05:57:07 <kallisti> say you want to compare a finite number with it.
05:57:11 <XWNH> http://hpaste.org/70343
05:57:28 <XWNH> in the rotate90Helper function, when I use tailOfAll' it never terminates
05:57:32 <XWNH> but tailOfAll works fine
05:57:46 <kallisti> mekeor: data Nat = Z | S Nat
05:57:49 <resure> Philippa: I'll pause programming using non-functional languages for a week or two to learn paradigms well.
05:57:51 <XWNH> I thought they where exactly the same...
05:58:09 * nand` is thinking there might be some contrived way to prove the transitivity of (<) and use that to infer that filter (<10) . iterate succ = takeWhile (<10) . iterate succ
05:58:11 <nand`> or something
05:58:12 <theadmin> mekeor: To get the confusion out, you can rewrite that as sum . map (^3) $ filter (\x -> x `mod` 2 == 0) [0..100] -- point is, you don't *have* to write in confusing manners :P
05:58:38 <srhb> XWNH: One bails out on a failed pattern match, the other does not
05:58:39 <theadmin> ...Though I'm not sure which is more confusing here
06:00:14 <kallisti> mekeor: using a Peano natural is also useful to efficiently compare finite list lengths.  (genericLength xs :: Nat) > genericLength ys
06:00:34 <nand`> what isn't Nat in Prelude yet?
06:00:43 <kallisti> mekeor: that will short circuit on the smaller list instead of traversing both lists.
06:00:45 <nand`> and where are our Nat-based n+k patterns? :P
06:00:53 <nand`> why*
06:00:59 <hpaste> mekeor annotated ‚Äúa‚Äù with ‚Äúa (annotation)‚Äù at http://hpaste.org/70343#a70344
06:02:25 <mekeor> XWNH: tailOfAll' and tailOfAll are equal. tailOfAll is better.
06:02:30 <srhb> I also thought Nat was supposed to be in Prelude with ghc 7.4
06:03:18 <hpaste> mekeor annotated ‚Äúa‚Äù with ‚Äúa (annotation) (annotation)‚Äù at http://hpaste.org/70343#a70345
06:04:12 <rwbarton> "tailOfAll" is actually longer than its implementation
06:04:55 <XWNH> srhb: what? I see that there are stray empty lines in the result when I use tailOfAll, but why should tailOfAll' fail on empty lines?
06:04:57 <rwbarton> oh wait no, because of what you were just talking about
06:05:25 <mekeor> isn't: [ t | (_:t) <- l ] == map tail l -- ?
06:05:37 <nand`> what are the semantics of ‚Äòrotate90‚Äô? rotate a picture by 90¬∞ to the right?
06:05:39 <srhb> mekeor: Modulo error, yes
06:05:42 <nand`> (in that hpaste)
06:05:48 <mekeor> srhb: huh?!
06:05:54 <XWNH> Nand' yeah
06:05:57 <srhb> > map tail [[]]
06:05:59 <lambdabot>   [*Exception: Prelude.tail: empty list
06:06:06 <kallisti> mekeor: when the pattern match fails in list comprehensions it'll just discard that elmenet
06:06:07 <mekeor> ah
06:06:08 <srhb> > [ t | (_:t) <- [[]]]
06:06:09 <lambdabot>   []
06:06:12 <mekeor> of course!
06:06:13 <nand`> then rotate90 = flipV . transpose
06:06:17 <nand`> or map reverse . transpose
06:06:50 <Maxdamantus> @undo [ t | (_:t) <- [[]]]
06:06:51 <lambdabot> concatMap (\ a -> case a of { (_ : t) -> [t]; _ -> []}) [[]]
06:07:42 <Maxdamantus> @undo [ t | (t, u) <- [[]]]
06:07:43 <lambdabot> concatMap (\ (t, u) -> [t]) [[]]
06:08:03 <XWNH> agh, still confused. People are saying tailOfAll == tailOfAll', but within the rotate90Helper function they exhibit different behaviour
06:08:14 <rwbarton> they aren't the same
06:08:41 <rwbarton> consider what happens when l is not itself empty, but every element of l is an empty list
06:09:03 <rwbarton> which is what you will eventually reach when removing the head of each element of l
06:09:57 <hpaste> mekeor annotated ‚Äúa‚Äù with ‚Äúa (annotation) (annotation) (annotation)‚Äù at http://hpaste.org/70343#a70346
06:11:18 <mekeor> @undo [ tail t | t <- l]
06:11:19 <lambdabot> concatMap (\ t -> [tail t]) l
06:11:22 <srhb> OK, I can't really figure out why it doesn't terminate though. In my mind it should except out.
06:11:41 <mekeor> @undo [ t | (_:t) <- l]
06:11:42 <lambdabot> concatMap (\ a -> case a of { (_ : t) -> [t]; _ -> []}) l
06:12:26 <maybefbi> What kind of practical problems are available which if solved will help me learn about the typeclasses in Typeclassopedia?
06:12:30 <srhb> If I add >trace (show l)< in front of tailOfAll' it does indeed die with an exception, as I think it should in any case
06:12:47 <nand`> maybefbi: well, which one in particular are you looking at?
06:12:53 <nand`> I'd say they all have their own example applications
06:13:12 <maybefbi> nand`, I like the first one there: Functor
06:14:03 <XWNH> rwbarton: right, thanks.
06:14:27 <srhb> rwbarton: Can you explain the lack of termination?
06:14:34 <XWNH> mekeor: thanks as well
06:15:16 <rwbarton> the lack of error you mean?
06:15:44 <srhb> rwbarton: with tailOfAll' it never terminates. Just keeps running. Unless I add a trace (show l) in front - then it dies with exception empty list as it should
06:15:48 <rwbarton> oh
06:15:49 <mekeor> XWNH: =)
06:15:50 <rwbarton> odd
06:15:53 <srhb> rwbarton: Yes, very.
06:16:58 <mekeor> XWNH: btw, do you know hlint? it gives you suggestions how to write things better. http://community.haskell.org/~ndm/hlint/
06:18:33 <XWNH> mekeor: new to me, sounds good. thanks.
06:19:23 <mekeor> XWNH: cabal install hlint; hlint Code.hs # outputs suggestions‚Ä¶
06:33:23 <theadmin> mekeor: Thanks for that one! Shows me a ton of redundant $ and () in my code..
06:34:52 <rwbarton> now you will start to see them everywhere
06:35:07 <rwbarton> the curse of fine taste
06:35:13 <akamaus> Hi, I have the following data type:  data Chord a = Chord [a]; Can I somehow it make an instance of Functor?
06:35:58 <rwbarton> akamaus, yes
06:36:14 <rwbarton> do you mean other than by writing a Functor instance manually?
06:36:32 <akamaus> rwbarton, I get type error
06:36:44 <sipa> akamaus: paste code at hpaste.org
06:36:55 <akamaus> a second
06:38:59 <akamaus> http://hpaste.org/70347
06:39:36 <hpc> akamaus: if you feel like making it a newtype, you can use GeneralizedNewtypeDeriving
06:40:16 <rwbarton> akamaus: think about the type of fmap for Chord
06:40:19 <rwbarton> @type fmap
06:40:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:40:25 <akamaus> ok, but still I want to understand what's precisely wrong with my approach
06:40:28 <rwbarton> so (a -> b) -> Chord a -> Chord b
06:41:08 <rwbarton> so on line 4, if f :: a -> b, then Chord tones :: Chord a which means tones :: [a]
06:41:25 <PaulVisschers> akamaus: Chord (map f tones)
06:41:31 <akamaus> oh..
06:41:38 <sipa> akamaus: you're trying to apply f to a single element
06:41:43 <PaulVisschers> akamaus: is what you want instead of Chord (f tones)
06:41:44 <sipa> akamaus: while Chord holds a list
06:41:56 <srhb> echo echo echo.
06:43:15 <akamaus> Yeah, it would work. But the motivating example was the need to apply 'drop 2' to the list inside the Chord
06:43:24 <akamaus> so I need quite a different semantics
06:43:41 <srhb> Either your Chord type is wrong then or you're not looking for Functor.
06:43:53 <akamaus> I guess it's the second
06:43:59 <srhb> I think so too. :)
06:44:31 <srhb> Wait, do you mean dropping _all_ the notes by two?
06:44:41 <srhb> Because in that case, Functor is still right.
06:44:51 <srhb> > map (subtract 2) [1,2,3]
06:44:52 <lambdabot>   [-1,0,1]
06:45:08 <akamaus> I wrote a separate function at first, then realized it's similar to fmap. I guess similarity was very  shallow
06:45:24 <rwbarton> I would recommend you just pattern match anywhere that needs to know the definition of Chord
06:45:36 <rwbarton> and not write a function like ([a] -> [b]) -> Chord a -> Chord b
06:46:03 <akamaus> srhb, In this particular case, yes, by two. But it's quite a narrow example.
06:46:28 <rwbarton> wait i assumed you meant 'drop 2' as in the Prelude function drop
06:46:37 <akamaus> rwbarton, Aren't this go against good practices?
06:46:38 <srhb> akamaus: If you are always changing _all_ the notes by the same, I do think you are in the right spot with Functor
06:46:39 <rwbarton> f (Chord xs) = Chord (drop 2 xs)
06:46:55 <srhb> rwbarton: Yes, I thought the same and then I thought "oh wait, music" :
06:46:56 <srhb> :P
06:47:19 <akamaus> :))
06:47:24 <matthiasgorgens> How do I automatically derive MonadTrans for: newtype Test e m a = Test ((ErrorT e m) a)
06:47:29 <rwbarton> maybe he just doesn't like the bottom notes of chords :P
06:47:37 <matthiasgorgens> I know how to do it for ReaderT.
06:47:42 <srhb> rwbarton: Yeah, too polyphonic.
06:48:01 <matthiasgorgens> oops, I know how to do it for a fixed e, I mean.
06:48:05 <rwbarton> akamaus: I don't think so.
06:48:07 <srhb> akamaus: I think what you should start by doing is eliminating that 'a' and making it Note
06:48:15 <akamaus> nope, I'm just playing with Haskore and writing a small dsl while coding Bach's Prelude in C-dur :) It has that patter all over the piece
06:48:16 <srhb> akamaus: your code will become much clearer, as will what to do next.
06:49:02 <rwbarton> In my opinion it promotes implementation abstraction by making the places where you use that implementation more explicit
06:50:02 <rwbarton> if you don't care about implementation abstraction, then it doesn't really matter one way or the other
06:50:33 <rwbarton> but if you find yourself using ([a] -> [b]) -> Chord a -> Chord b very frequently, at some point you may as well just use a type synonym
06:51:09 <akamaus> actually I already use that Chords for two things, for representing relative and absolute pitches, It was the reason I introduced that 'a'
06:52:21 <srhb> Chord Rel Note | Chord Abs Note? I may be out of my league here.. :-)
06:52:26 <akamaus> http://hpaste.org/70349
06:52:31 <srhb> oops, [Note]
06:52:43 <rwbarton> if you want to eventually convert relative pitch to absolute pitch, that would be a good use for Functor potentially
06:52:52 <theadmin> Does Cabal write stuff anywhere apart from ~/.cabal and ~/.ghc?
06:53:01 <srhb> theadmin: Depends on the platform
06:53:04 <akamaus> srhb, there is no need to intermix them, so two constructors are redundant.
06:53:11 <theadmin> srhb: Arch Linux
06:53:20 <akamaus> rwbarton, yeah, that's the point
06:53:33 <srhb> theadmin: Ah, I only know that on Mac it just scatters things all over the place, alternating between .cabal and Library/Haskell. :-)
06:53:56 <srhb> theadmin: On Arch I think the answer is "no"
06:54:07 <theadmin> srhb: Good then
07:02:48 <BigOne> Is Haskell used in any product ?
07:03:28 <BigOne> I feel Haskell is very smart.
07:04:23 <BigOne> But as I know Erlang is popular than Haskell, isn't it?
07:04:45 <nand`> I don't know much about this but http://www.haskell.org/haskellwiki/Haskell_in_industry might be relevant
07:05:52 <BigOne> thank you nand`
07:09:51 <akamaus> wow, It plays at last :)) thanks for the suggestions
07:17:35 <merijn> Is there something like maybeRead or should I make it myself using reads?
07:18:11 <hpc> make it yourself
07:20:18 <merijn> And entirely unrelated: Is there a total Map-like data structure that only accepts keys from a finite set and ensures there is always a value for all keys?
07:20:38 <merijn> Or should I just use Data.Map combined with fromJust and manually enforce the invariant?
07:23:27 <sipa> merijn: an array?
07:25:54 <merijn> Actually, I guess that makes sense if I can get my keys to be suitable for arrays...
07:26:57 <aristid> merijn: a function? :D
07:27:22 <ksf> what's the best way to pad with blaze-builder?
07:27:39 <ksf> serialize a [Word8] ? a bytestring?
07:28:31 <merijn> aristid: Functions are out because I want to persist the data structure (which I guess is theoretically also possible with functions, but probably more hassle)
07:29:33 <merijn> And while asking seemingly unrelated questions, someone told me Semantic Editor Combinators were a nicer alternative to lenses. But after reading conal's blog post I'm not sure how I'd nicely use them with records
07:33:39 <nand`> ‚Äúonly accepts keys from a finite set‚Äù <- sounds like you have a bijection from your key to a finite subset of Integer
07:35:12 <merijn> nand`: Yes, but as sipa points out it's probably nicest to use that idea to provide a Data.Ix instance and use an array
07:36:42 <nand`> merijn: yeah that sounds nice
07:36:58 <nand`> I would have suggested a Vec (or even a tuple) as a trivial example :)
07:39:52 <nand`> hmm
07:40:23 * nand` casually suggests the syntax ‚Äúclass X a b | a <-> b‚Äù for ‚Äúclass X a b | a -> b, b -> a‚Äù
07:41:51 <sipa> and a <-> b <->c for "| a -> b, a -> c, b -> a, b -> c, c -> a, c -> b" ?
07:42:15 <otters> no, that would have to be a <-> b, b <-> c, a <-> c
07:42:23 <nand`> what otters said
07:42:29 <nand`> though isn't a <-> c redundant in that case?
07:42:40 <otters> because a <-> b <-> c would mean (b -> c) -> a, a -> (b -> c), (c -> b) -> a, etc.
07:42:44 <rwbarton> one would hope so
07:43:12 <nand`> is a -> b -> c even a valid fundep?
07:43:41 <nand`> well, is ‚Äú| a -> b, b -> c‚Äù the same as ‚Äú| a -> b, b -> c, a -> c‚Äù?
07:44:00 <rwbarton> it should be, and i would expect ghc to get it right
07:44:07 <merijn> No comments on my semantic editor combinator question?
07:45:11 <matthiasgorgens> merijn: what's your question?
07:46:07 <merijn> I got told semantic editor combinators were a nicer alternative to lenses, but after reading conal's post on them I'm not sure how they'd replace lenses when using records, although this is probably due to a lack of examples
07:46:25 <hpc> merijn: they would replace the getter side of lenses
07:46:26 <rwbarton> i'm not 100% sure ghc would get it right though, there are also more complicated cases like a -> b, a -> c, b c -> d implying a -> d
07:46:39 <hpc> though really, they're just useful for writing complicated compositions
07:47:20 <merijn> hpc: whoever it was said the setter side too. Otherwise what's the point (also, why call them editors if you can't update...)
07:48:49 <ksf> the "update" part is where you fmap over things.
07:49:12 <ksf> iirc conal just provided ways of nicely fmapping you to the functor you wish to mangle.
07:49:51 <merijn> Right, so I'm better of forgetting that notion and just keeping my lenses
07:51:22 <ksf> it's not like lenses would be incoherent, theory-wise.
07:51:29 <ksf> they're full of nice isomorphisms.
07:52:38 * hackagebot language-glsl 0.0.0 - GLSL abstract syntax tree, parser, and pretty-printer  http://hackage.haskell.org/package/language-glsl-0.0.0 (VoMinhThu)
07:52:44 <wingie> FP seems to much more simple and efficient than OOP
07:52:48 <wingie> so much
07:52:58 <ksf> no.
07:53:10 <ksf> it doesn't *seem*, it *is* =)
07:53:15 <wingie> :)
07:53:38 <wingie> everything is IO .. data in, data out
07:53:41 <wingie> that is the basic right
07:53:55 <wingie> everything HAS to be an expression since something needs to come out right?
07:54:13 <nand`> except when what comes out is ‚ä•
07:54:19 <ksf> well, everything is an expression because statements are just special cases of those.
07:54:59 <wingie> how about frontend UI
07:55:27 <wingie> almost every ui framework out there (Ext, GWT, Dojo) is using OOP (model, view, controller)
07:55:29 <ksf> I think about it as an actor, or a collection of actors.
07:55:37 <wingie> how could that be done in FP?
07:55:47 <ksf> that's a *good* question.
07:55:48 <nand`> wingie: I don't know, but I think FRP is related
07:55:51 <ksf> a very good question.
07:55:51 <merijn> You can't mix normal record and normal syntax for constructors, right? i.e. I need one field to be named for each constructor, but naming all the other makes no sense
07:55:58 <wingie> doesn't oop fit in UI development, since you want to have a window. so you create new Window
07:56:15 <ksf> merijn, maybe you want to nest a bit.
07:56:16 <merijn> Although I could just manually provide a function to get/set that one field for each constructor...
07:56:16 <nand`> merijn: I'm not sure if you can in the definition but you definitely can when actually using the constructor
07:56:29 <wingie> nand`: what is FRP
07:56:40 <nand`> wingie: Functional Reactive Programming, and that's about all I know about it
07:57:09 <ksf> when it comes to UI you're certainly going to use some kind of objects, that is stuff representing individual widgets, the question is whether you have to use oop to abstract the rest of your code.
07:57:34 <nand`> ksf: aka ‚Äúvalues‚Äù
07:57:37 <ksf> yep.
07:57:38 * hackagebot shelly-extra 0.2.2.1 - shelly features that require extra dependencies  http://hackage.haskell.org/package/shelly-extra-0.2.2.1 (GregWeber)
07:58:20 <merijn> And since I'm playing the lots of questions game today: Is there some sort of canonical name for a module that contains all data declarations within a package or should I just call it Internal?
07:58:44 <ksf> you should call it "Types"
07:58:55 <ksf> or maybe Internal.Types, it depends.
07:59:20 * nand` votes .Types
07:59:24 <ksf> Internal is reserved for "I'm not going to hide those, but don't complain if they change without notice and your program breaks horribly"
07:59:34 <wingie> ksf: so classes and objects is not replacable for UI?
07:59:49 <ksf> objects no, classes yes, I'd say.
07:59:53 <wingie> at the moment im using FP in backend where it is a perfect match
07:59:59 <wingie> in the frontend OOP
08:00:07 <nand`> wingie: I've done a bit of UI programming in Haskell and not once have I dreamed of using OOP
08:00:20 <wingie> or at least that is what the style the frameworks are using
08:00:51 <wingie> nand`: how do you create a window in pure FP then?
08:00:56 <ksf> most UI libraries for haskell are OOPish, because they wrap eg. gtk directly.
08:01:01 <wingie> create-window()? :)
08:01:11 <wingie> then how do you change the title of it
08:01:14 <nand`> you don't ‚Äúcreate‚Äù a window. you define a window, then define a function :: Window -> Output
08:01:31 <ksf> wingie, http://hackage.haskell.org/packages/archive/grapefruit-examples/0.1.0.2/doc/html/src/Examples-Grapefruit-Simple.html#mainCircuit
08:01:35 <ksf> that's one possibility
08:01:59 <nand`> wingie: I'd probably use some State abstraction
08:02:32 <ksf> that's actually only the *description* of the UI.
08:02:54 <ksf> you then feed it to runCircuit or similar, which is going to do the black IO magic behind the scenes.
08:03:03 <wingie> can you say that FP and OOP should/could be mixed together for the best result?
08:03:13 <hpaste> srhb pasted ‚ÄúCorrect use of MVars?‚Äù at http://hpaste.org/70351
08:03:23 <ksf> depends. I wouldn't go the scala way, that is.
08:03:30 <wingie> eg. OOP as usual as bigger structures .. then FP in the background handling things
08:03:32 <nand`> I think I would avoid OOP entirely, personally
08:03:45 <nand`> if the ‚ÄúUI libraries‚Äù use OOP, they obviously need to be redesigned
08:03:46 <srhb> I'm curious, am I using modifyMVar correctly here? Or can another thread read afterwards? It shouldn't be possible while using MVars, right?
08:03:50 <nand`> I don't think OOP is the best solution to anything
08:03:53 <ksf> wingie, you'll like this: http://homepages.cwi.nl/~ralf/OOHaskell/
08:03:58 <nand`> values shouldn't be associated with functions that operate on them
08:04:04 <wingie> nand`: pragmatically that isnt possible today for a lot of devs due to frontend UI frameworks
08:04:11 <nand`> unless the values themselves are the functions
08:04:25 <Philippa> I find message passing is still useful in Haskell, it depends a lot on whose idea of 'OOP' you're using though
08:04:39 <ksf> actors are nice.
08:04:48 <Philippa> (despite some outright religious-level disagreements, I get on better with Kay than many for example)
08:04:57 <nand`> wingie: for wrongdoers like those the canonical approach is to create a lightweight, ugly IO wrapper; and then provide a higher level functional abstraction around it
08:05:03 <mauke> my definition of "message passing" is lambda calculus, does that count?
08:05:15 <wingie> i c
08:05:17 <nand`> so people that haven't lost their sanity yet can stay in the pure world
08:05:19 * Philippa hands mauke a slice of pi
08:05:26 <nand`> see: OpenGL and gloss (does gloss even use OpenGL?)
08:05:34 <ksf> mauke, depends, is your lambda calculus explicitely multithreaded?
08:05:40 <mauke> no
08:05:51 <ksf> see GLSL and gpipe.
08:06:00 <ksf> or cuda and dph
08:06:01 <mauke> 'o m' sends the message m to the object o
08:06:07 <mauke> m is of course another object
08:06:18 <ksf> argh.
08:06:19 <merijn> srhb: What do you mean by "read afterwards"?
08:06:25 <ksf> no you're not supposed to send actors.
08:06:32 <ksf> channels, yes, actors, no.
08:06:36 <mauke> objects are defined by writing \m. ...
08:06:50 <Philippa> mauke: we get the gag, possibly not the best timing though?
08:06:50 <mauke> where m is the incoming message and ... describes the response
08:07:03 <Philippa> \_."GO AWAY"
08:07:11 <ksf> if you do you lose the capability to distribute actors transparently over multiple machines, as you'd have to start sending code.
08:07:15 <merijn> srhb: modifyMVar is equal to "takeMVar; do stuff; putMVar" (and in this case returning the other tuple value as result. So other threads can't touch the counter while updating
08:09:07 <srhb> merijn: Cool, thanks. :-)
08:09:50 <merijn> srhb: It occurs to me I could have just said that the argument to modifyMVar happens atomically and saved a lot of words...
08:10:02 <execc_13> What is recommended for beginers book about lambda calculus and theory behind FP at all?
08:10:33 <srhb> merijn: I appreciate the expliciteness. :-)
08:12:14 <Philippa> execc_13: It depends a bit on what angle you want to cover. I got a lot out of Pierce's Types and Programming Languages myself, but I was looking to design type systems to start with
08:12:39 * hackagebot vector-clock 0.2.0 - Vector clocks for versioning message flows  http://hackage.haskell.org/package/vector-clock-0.2.0 (AlexandruScvortov)
08:12:54 <Philippa> there are a number of different traditions involved, and you get different approaches from each
08:13:14 <Philippa> (it's a little like if you asked for a recommended book on OOP, or on procedural programming?)
08:13:42 <PaulVisschers> I have a question about algebraic structures: I have encoded matrices as nested vectors and those vectors have their lengths encoded in their type. Normally matrix multiplication can be expressed as a ring, but that won¥t work for me, as each matrix can have a different size (although limitation apply). What do I call the new algebraic ring-like structure that I need?
08:14:26 <execc_13> Philippa: Well, I'm not event knowing where shoul i start :)
08:15:16 <srhb> How can I make my program not echo keypresses? Is that even on Haskell's end, or the terminal?
08:15:52 <tobiassjosten> Is there a specific module I need to import to be able to use the nub function?
08:16:02 <srhb> @index nub
08:16:02 <lambdabot> Data.List
08:16:10 <srhb> tobiassjosten: Data.List. :-)
08:16:38 <tobiassjosten> Oh. Thanks!
08:16:42 <srhb> tobiassjosten: hoogle or lambdabot will be able to tell you these things, or hayoo if it's a hackage thing
08:18:23 <tobiassjosten> srhb: Great to know that. Thanks again.
08:18:31 <Philippa> execc_13: what can you do practically so far?
08:19:16 <Philippa> PaulVisschers: I suspect the new structure is a family of matrices from which you can build a family of rings?
08:20:04 <PaulVisschers> Philippa: I don¥t know, my knowledge of algebra is limited
08:20:25 <rwbarton> a category :)
08:20:48 <orzofk> srhb: on unix, the command "stty -echo" might be of interest
08:21:09 <matthiasgorgens> I have this stack of monad transformers.  how do I automatically derive MonadBaseControl instances for it?
08:21:11 <srhb> orzo: Thanks, turns out there's a hSetEcho stdin False in System.IO. :-)
08:21:19 <Philippa> execc_13: are you happy to be recommended multiple books, where no single book is necessarily 'enough'?
08:21:20 <orzo> neet
08:21:33 <rwbarton> specifically an additive category, also known as a "ring with many objects"
08:21:51 <execc_13> Philippa: I'm a Java programmer, currently, with quite a bit of experience in OOP and data - structures. I'm trying learning haskell now, but i feel like understanding a theory and mathematics behind the Haskell is quite important.
08:21:56 <mm_freak> matthiasgorgens: you shouldn't have to
08:22:21 <mm_freak> matthiasgorgens: if you wrap the stack in a newtype you can use GeneralizedNewtypeDeriving
08:22:34 <Philippa> execc_13: ah, okay. Did you ever cover basic set theory somewhere?
08:22:39 * hackagebot dbus 0.10 - A client library for the D-Bus IPC system.  http://hackage.haskell.org/package/dbus-0.10 (JohnMillikin)
08:23:24 <PaulVisschers> Philippa: http://hpaste.org/70352 this is basically what I want, but I¥m not sure what I should call the class and whether there are better ways of encoding it
08:23:25 <Philippa> (anybody about to mention things like the difficulty of set-theoretic models for System F is asked to leave me be, btw)
08:23:33 <execc_13> Philippa: Learn you a haskell mostly. I've got it to the point of Applicative functors and monad.
08:24:04 <Philippa> execc_13: ah, and that's what's making you want theory? :-)
08:24:59 <execc_13> Philippa: Math behind lambda functions and all the rules of Functors and Monads, as well as references to group theory, which is a black box for me as well.
08:25:47 <execc_13> Philippa: So i felt like i need to understand the theory. In fact I want to learn some theory as i've bored a bit with practical and engeneering books, and want to bend my mind of comething theoretical and abstract.
08:25:52 <execc_13> *on
08:25:54 * nand` started gaining knowledge by skimming through wikipedia
08:25:57 <nand`> you might want to do the same
08:26:02 <nand`> but beware of traps
08:26:22 <Philippa> execc_13: cool. So category theory has an awesome introduction in the form of Conceptual Mathematics, though it's not particularly about using it for computing?
08:26:52 <nand`> execc_13: you've definitely come to the right place
08:26:59 <Philippa> lambda functions are "just" mathematical functions, if you'd like to wander into #haskell-overflow I'd be happy to give you a tutorial from naive set theory onwards
08:27:38 <srhb> Are guards possible in case expressions?
08:27:39 * hackagebot silently 1.2 - Prevent or capture writing to stdout and other handles.  http://hackage.haskell.org/package/silently-1.2 (TrystanSpangler)
08:27:52 <monochrom> yes
08:28:56 <PaulVisschers> Philippa: to answer your question: I don¥t think they make up a family of rings, because rings require closure, which is not the case here
08:29:21 <Philippa> PaulVisschers: point. Indexed rings?
08:31:20 <ski> wingie : FP languages often tend to be good at the "innards" of systems -- i'm not sure to what extent OO langs tends to be good at the "surface" of systems, but it at least seems plausible given that OO arise partly out of UI and partly out of simulation (where observation is important) ..
08:31:49 <PaulVisschers> Philippa: I can¥t find any information on those
08:32:26 <rwbarton> they're called rings with many objects or additive categories
08:32:41 * hackagebot shelly 0.12 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.12 (GregWeber)
08:33:03 <PaulVisschers> rwbarton: alright, I¥ll look into those, thanks
08:33:12 <srhb> I can't believe threading is this easy. I feel like I'm cheating somehow.
08:33:22 <ski> execc_13 : a simple basic understanding of what a monoid (and possibly also a group) is, and some examples (including simple constructions, like product, coproduct, free monoid/group, sub-m/g,qoutient facto m/g) e.g. related to computing, would be helpful -- but i don't really think you need to learn that much about it for computing/programming purposes
08:35:14 <ski> wingie : many FP languages tend to rely on disjoint/discriminated union / sum/variant types (and algebraic data types are closely related); while OO languages tend to rely on record types -- these two kinds of types are *dual* to each other
08:37:28 <ski> wingie : if you implement a type with a few variants/alternatives/constructors (classes in OO) to instantiate them, and a few operations/methods to query them : then it's easier to add a new alternative (/ class) than a new operation : you just have to define a new class (inheriting from or implementing the abstract thing) -- while adding a new operation is tricker : you have to *modify* existing classes
08:38:28 <nand`> srhb: why, do you mean forkIO?
08:38:38 <srhb> nand`: Yeah :)
08:38:45 <nand`> yeah, I was amused too
08:38:51 <ski> wingie : otoh if you do this with a variant type instead, then it's easy to add another operation : you just define a new pattern-matching function) -- while adding a new alternative is tricker : you have to *modify* existing pattern-matching functions
08:38:55 <srhb> nand`: It's pretty amazing :P
08:39:02 <nand`> it is
08:39:38 <ski> wingie : in some types of problems it's more important to be flexible in easily adding new operations -- in others, it's more important to be flexible in easily adding new alternatives
08:45:50 <kallisti> what might cause me to get a 400 Bad Request response when using http conduit?
08:45:52 <kallisti> missing headers perhaps?
08:49:54 <hpc> kallisti: conduit isn't sending nicely formed headers
08:51:12 <ski> wingie : however, there's other common aspects of FP and OO that don't compare as nicely as variant types vs. record types -- e.g. (implementation) inheritance in several OO languages, recursion and propensity for lack of side-effects in FP (there's probably more one can state here)
08:52:40 * hackagebot dbus-core 0.9.3 - Low-level D-Bus protocol implementation  http://hackage.haskell.org/package/dbus-core-0.9.3 (JohnMillikin)
08:55:14 <kallisti> hpc: so, a library bug?
08:55:20 <kallisti> that seems unlikel..
08:55:23 <kallisti> +y
08:57:49 <hpaste> kallisti pasted ‚Äúhttp headers‚Äù at http://hpaste.org/70355
08:57:58 <kallisti> hpc: ^  here's my headers
08:58:46 <kallisti> I'm using Network.HTTP.Conduit.Browser to send the request.
09:04:56 <PaulVisschers> rwbarton: I¥m not sure I fully understand those additive categories
09:06:41 <scooty-puff> is it possible to have xmonad recompile/use a different ghc than the first on the path?
09:07:06 <scooty-puff> i tried modified the sh script responsible for startup to change the path, but this seemed ineffective
09:10:50 <squidz> I come from a java EE background where I am used to using an ORM like hibernate together with JPA in order to seperate and deal with data from databases. What would be the best way in haskell to deal with data, be it big scalables websites to private projects for fun?
09:11:41 <merijn> squidz: Depending on the type of data you can either use one of the various database bindings or something like acid-state
09:12:11 <squidz> merijn: is acid-state different compared to other approaches?
09:12:36 <merijn> The former is mostly identical to dealing with databases in any language, acid-state is for transparent persisting of haskell data structures (i.e. not like a database at all)
09:12:50 <favonia> hpc: turns out GHC extensions CPP + Safe work as expected. I must've screwed up something. :P
09:13:51 <squidz> hmm. If i were to make a web application using haskell and acid-state, is it very easy/safe to keep the backend and frontend from mixing?
09:15:14 <merijn> squidz: Sure, not more or less difficult than otherwise. The main difference is the usecases for which it is suited. If you want querying data you probably want a database. If you want to just persist haskell data structures acid-state might make more sense
09:15:52 <squidz> merijn: so acid-state might not be suitable for persisting large amounts of data like I would use a DB for?
09:16:19 <merijn> squidz: Yeah
09:17:08 <squidz> merijn: okay, so what would be the best solution for such a case where I do want to store/retrieve large amounts of data
09:17:41 * hackagebot dbus-client 0.4.1 - Monadic and object-oriented interfaces to DBus  http://hackage.haskell.org/package/dbus-client-0.4.1 (JohnMillikin)
09:17:45 <merijn> squidz: I'd say just use whatever database you're familiar with and the haskell bindings for it. I assume most common database have haskell bindings
09:18:10 <hpc> hdbc is good
09:18:25 <hpc> it does oracle, postgres, mysql, and possibly ms-sql
09:18:27 <squidz> would i be able to switch databases with hdbc?
09:20:23 <merijn> Hmm, would it be possible to reify a data type at runtime? i.e. I mentioned earlier I wanted to use a total map (array seems like a good plan), but considering the number of keys and the fact I might want to use different ones means I don't want to provide an exhaustive list with the data type declaration
09:21:03 <merijn> I would want to (at program start) read in a list of strings and then use those as indices for my array. Is this remotely feasible? If so, how?
09:22:37 <hpc> the horrible way would be to make a wrapper script that takes those strings and then compiles the actual program with them and runs it
09:22:39 <merijn> (Or is this an insane idea)
09:22:51 <hpc> the less horrible way is to just make a Set String
09:24:14 <merijn> hpc: Yeah, but in that case I couldn't provide the Ix instance I'd need for an array, right?
09:24:38 <aristid> @hackage reflection
09:24:39 <lambdabot> http://hackage.haskell.org/package/reflection
09:25:16 <aristid> merijn: you can't reify types with that, but you can do things like typeclass instances that depend on a runtime value identified only by a type parameter
09:26:37 <merijn> aristid: Ah, so it'd be possible to reify an Ix instance for String using that?
09:26:42 <applicative> does MonadPlus let you do any special tricks with do notation, besides (guard blah)
09:26:50 <aristid> merijn: if i understand it right, yes
09:27:12 <aristid> merijn: look at examples/Monoid.hs (as it happens i was only looking at the source code yesterday :D)
09:27:12 <merijn> aristid: ok, neat. I'll check it out
09:28:41 <aristid> it's funny how haskellers are hacking the system to provide the maximum of dependent typing possible :D
09:30:07 <srhb> I guess quite a few people hope Haskell turns into a dependently typed language.
09:30:08 <hpc> applicative: you can kinda use mplus like (<|>)
09:30:27 <hpc> though it's gross imo
09:30:52 <applicative> hpc, yeah thats the natural way of implementing it.
09:31:05 <applicative> hpc, I was really thinking about 'monad comprehensions'
09:31:21 <hpc> oh, that you can do
09:31:34 <applicative> which you will find even more gross maybe :)
09:31:35 <hpc> Bools in monad comprehensions desugar to guard
09:31:50 <hpc> nah, monad comprehensions are cool
09:32:00 <merijn> aristid: That might just be a seen that dependent types might actually work someday if we can find a good implementation :p
09:32:03 <applicative> yeah, i was wondering it there was anything besides that, but I'm just in a muddle
09:32:08 <aristid> hpc: oh, so monad comprehensions have a feature that do notation doesn't :D
09:32:09 <merijn> That's a Good Thing(TM), no?
09:32:35 <hpc> aristid: no, list comprehensions have it too
09:32:44 * hackagebot prolog-graph-lib 0.2.0.1 - Generating images of resolution trees for Prolog queries.  http://hackage.haskell.org/package/prolog-graph-lib-0.2.0.1 (DanielSeidel)
09:32:51 <hpc> > [x | x <- [1..10], x < 5]
09:32:52 <lambdabot>   [1,2,3,4]
09:32:53 <aristid> hpc: i was comparing to do notation, not list comprehensions.
09:33:01 <hpc> er, oh
09:33:09 <hpc> yeah, they do
09:33:12 <shapr> I love making useful little snippets like: listmatch a b = and $ zipWith (==) a b
09:34:13 <aristid> shapr: i.e. equality with the tails cut off?
09:34:28 <applicative> hpc I was looking at https://gist.github.com/2926572 and realized he was making a
09:34:39 <applicative> MonadZip  instance for IO
09:35:08 <shapr> aristid: Yup, I've most recently used that to find 'music' files based on extensions.
09:35:22 <shapr> extensions = ["flac","mp3","ogg","m4a","midi","mid"]
09:35:25 <applicative> so that you could use 'ParallelListComp' + 'MonadComprehensions' for some of his examples in main
09:35:33 <shapr> isMusic fp = any (listmatch $ reverse fp) $ map reverse extensions
09:35:39 <shapr> aristid: and that's it!
09:36:12 <shapr> Assuming you have a list of filepaths, of course.
09:36:16 <shapr> aka, a list of strings
09:36:22 <aristid> :t break
09:36:23 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
09:36:52 <shapr> aristid: Is there a cuter way to do that?
09:37:18 <aristid> > break (== '.') (reverse "foobar.tar.gz")
09:37:19 <lambdabot>   ("zg",".rat.raboof")
09:37:31 <shapr> oh
09:37:35 <aristid> > break (== '.') "foobar.tar.gz"
09:37:36 <lambdabot>   ("foobar",".tar.gz")
09:37:38 <merijn> aristid: oh, reflection is by edwardk :(
09:37:43 <shapr> Yah, that is simpler.
09:37:45 <merijn> There goes my hope of documentation :p
09:37:49 <shapr> heh
09:38:00 <srhb> How does one get monad comprehensions then?
09:38:00 <applicative> hpc, so  here is the same with parallel monad comprehensions for some of them but not the ones using alternative https://gist.github.com/2978944
09:38:02 <aristid> merijn: he links a paper by oleg and some other guy to explain the motivation :)
09:38:17 <aristid> shapr: does a different thing though
09:38:23 <merijn> Oleg and ccshan, that's not helping :p
09:38:26 <applicative> {-#LANGUAGE MonadComprehensions#-}
09:38:35 <applicative> ^^ srhb
09:38:41 <shapr> {-#LANGUAGE InComprehension#-}
09:38:43 <merijn> I think I'm gonna need a brain transplant to get this shit working :p
09:38:46 <srhb> Oh, it's an extension
09:38:51 <aristid> merijn: but there's an examples directory and the API is really simple, so don't despair :)
09:39:09 <aristid> merijn: you just won't stand a chance of understanding the implementation. or at least i sure don't
09:39:24 <shapr> brain failing... just need one more bit of code to get this working...
09:39:27 * shapr cranks up brain
09:39:33 <applicative> srhb, yes, but famously comprehensions were restricted to lists; they used to be for any monad
09:39:48 <merijn> aristid: I'll for now just program under the assumption I have an Ix instance and worry about implementing it later :p
09:39:50 <srhb> applicative: How odd.
09:40:17 <applicative> srhb, they got rid of it because the others were too confusing
09:40:31 <ocharles> hmm, I seem to be misunderstanding applicative a bit
09:40:40 <ocharles> With <*, that should run the action, but discard the result, right?
09:40:50 <srhb> Alright, I suppose it doens't matter as long as they're there as an extension.. It just feels.. Dirty. :-)
09:40:51 <ocharles> https://gist.github.com/159abfed52176b8f8b89 -- I expected an exception from this, but I don't get one
09:41:08 <ocharles> Is that just because the value isn't used, so that lifted function (error . show) isn't evaluated?
09:41:28 <applicative> sorry, I'm not putting it well. MonadComprehensions makes comprehension syntax work in any monad; so it was ages ago, but then they restricted comprehensions to lists
09:41:56 <applicative> srhb, because it was too confusing for beginners
09:42:18 <srhb> applicative: Yes, I think I understood you the first time around. :) Maybe we could have a ghc_with_training_wheels. :-)
09:43:04 <applicative> srhb, yeah... I'd rather have it understand some things like MonadComprehension implicitly, it's tiresome to declare.
09:43:18 <srhb> applicative: That's my thought..
09:44:21 <applicative> it does this for some things that are actually extensions, eg GADT syntax
09:44:38 <applicative> when they are used to introduce Haskell 98 types
09:45:27 <applicative> woops I take that back
09:45:56 <aristid> applicative: isn't MonadComprehensions by default dangerous because it would break existing code?
09:46:30 <geekosaur> is there something that would actually typecheck differently as a result?
09:46:36 <aristid> applicative: at least in conjunction with the MonomorphismRestriction?
09:46:44 <applicative> aristid: It must be really yeah
09:46:47 <aristid> geekosaur: ^ i think
09:47:06 <aristid> applicative: no such risk for GADTs of course
09:47:20 <applicative> oh, gadt syntax is accepted by ghc 7.4 , rejected by 7.5
09:47:28 <aristid> applicative: but i just add the extensions that GHC wants to every source file :D
09:47:42 <otters> at least put them in the cabal file
09:48:01 <applicative> yeah, it is getting awfully tiresome, but I guess -fglasgow-exts was untenable
09:49:49 <applicative> I guess I could figure out a way for my editor to include them automatically by calling ghci and looking for "blahblah -Xblahblah ..."
09:50:05 <shapr> w00t! branch merged!
09:50:06 * shapr cheers
09:51:56 <applicative> maybe it would be good if there were a way to import a module together with the languages it uses.
09:52:07 <applicative> and then to hide some
09:52:22 <applicative> maybe that would be a worse headache
09:55:43 <aristid> otters: i would put them in the cabal file, but then i can't so easily use ghci
09:55:59 <otters> cabal-dev ghci
09:56:28 <aristid> otters: good idea, totally should install cabal-dev :P
09:56:35 <otters> yes
10:04:50 <ocharles> <3 cabal-meta
10:14:25 <ski> hpc : why gross ?
10:15:23 <squidz> does anybody know any disadvantages to 'Takusen'?
10:26:00 <adnauseam> is it possible to use do in a recursive manner ?
10:26:17 <donri> -XDoRec
10:26:21 <monochrom> yes
10:26:35 <monochrom> (without understanding the question)
10:26:38 <donri> or, what do you mean by recursive
10:26:52 <tobiassjosten> I'm trying to split my program up into modules, with the main file at src/Main.hs. But doing "import Something" complains about Something not existing, though I have the file in src/Something.hs.
10:26:52 <mauke> > do do do do do do ()
10:26:53 <lambdabot>   ()
10:27:15 <DMcGill> is there a better way of doing some kind of `findWith :: (a -> Bool) -> [a] -> Maybe a' then `listToMaybe .: filter'?
10:27:17 <mauke> ghc -isrc
10:27:36 <DMcGill> (I mean "than" of course)
10:27:48 <mauke> :t find
10:27:49 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
10:28:09 <DMcGill> Thanks. What about for Data.Set?
10:28:14 <tobiassjosten> mauke: Thanks. But I also have "hs-source-dirs: src" in my project's cabal file. Shouldn't that do the trick?
10:28:38 <monochrom> ghc doesn't read project.cabal. cabal-install does
10:28:45 <mauke> tobiassjosten: how are you compiling?
10:29:11 <adnauseam> i'll look into -XDoRec
10:29:20 <tobiassjosten> mauke: cabal build
10:29:34 <DMcGill> although I suppose `find prec . toList' would be fine
10:29:48 <monochrom> have you gone through "cabal configure"?
10:29:55 <donri> adnauseam: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns#recursive-do-notation but note that it might not be required for what you mean
10:30:23 <tobiassjosten> monochrom: Yes. Actually, I have a Makefile which does cabal configure and then cabal build.
10:30:29 <donri> tobiassjosten: are you listing Something in exposed-modules or other-modules?
10:30:50 <tobiassjosten> donri: No. Maybe I should read up on those?
10:30:56 <donri> yes
10:30:56 <adnauseam> donri: i'm trying to take a list of doubles, generate out of that a list of reciprocals (1\x), then present the summation of them
10:31:13 <adnauseam> donri: i've written the reciprocal function to return a Maybe Double
10:31:24 <adnauseam> currently thinking of how to implement this
10:32:06 <mauke> donri: I don't think that should be necessary
10:32:39 <donri> mauke: hm, somewhat sure it is?
10:32:51 <mauke> works without it here
10:33:27 <mauke> I have a project that builds a single executable (from many modules)
10:33:33 <donri> well i think without it, the module won't be included in an sdist
10:33:49 <mauke> it doesn't use exposed-modules, other-modules, or hs-source-dirs
10:33:50 <donri> it might work from a checkout
10:34:04 <mauke> yeah, I've never packed it up for distribution
10:34:11 <mauke> all I'm saying is, the build succeeds
10:34:22 <donri> it might also matter if it's an executable or library
10:34:41 <mauke> I didn't need hs-source-dirs because all my files are in .
10:34:51 <donri> sure, that doesn't matter AFAIK
10:34:56 <mauke> now I've done mkdir src; mv Plugins.hs src
10:35:03 <mauke> that made the build fail
10:35:05 <deech> Hi all, I'm been looking into delimited continuations and am wondering where the names "shift", "control" etc come from. Are there any sources on this?
10:35:22 <navaati> hi
10:35:24 <mauke> then I added 'hs-source-dirs: src' to the .cabal file
10:35:34 <mauke> it still failed because now it couldn't find Main.hs
10:35:39 <navaati> is there a type to represent ASCII strings ?
10:35:46 <mauke> then I changed it to 'hs-source-dirs: . src' and everything worked
10:36:06 <donri> i vaguely recall it being different for executables and libraries, but not sure
10:36:20 <donri> @hackage bytestring
10:36:20 <lambdabot> http://hackage.haskell.org/package/bytestring
10:36:22 <mauke> (this is a single executable)
10:36:31 <donri> navaati: ^
10:36:31 <monochrom> if your Main.hs is also in src, "hs-source-dirs: src" should work
10:37:01 <mauke> yes, which is why I don't understand why it doesn't work for tobiassjosten
10:37:12 <mauke> I don't think I've done anything special here
10:37:19 <beefcube> I know neither quickcheck 1 or 2, should I start digging with quickcheck 2? or is the former similar enough as to not cause significant pain when moving to 2? I ask this because I can't find a meaningful new useres doc on how to use 2.
10:37:22 <navaati> donri: ah, yeah‚Ä¶ thanks :)
10:37:57 <donri> adnauseam: not exactly sure but sounds like you might want something like sequence or similar
10:39:22 <donri> adnauseam: possibly foldM
10:40:45 <donri> or maybe foldM doesn't do what i think it does... fmap some fold over the sequence of your list of maybes?
10:44:06 <spobat> Can I define functions here? http://tryhaskell.org/
10:44:13 <spobat> like "avg a = 2*a"
10:44:20 <spobat> It complains about the "=" sign.
10:44:35 <irene-knapp> let avg a = 2 * a in avg 4
10:44:37 <mauke> doesn't look like it
10:44:38 <monochrom> put it in a file. load that file.
10:44:40 <mauke> expressions only
10:44:57 <srhb> spobat: You can declare a function in a let if you use it immediately afterwards.. let foo ... = ... in foo ...
10:45:08 <srhb> spobat: (Which is just an expression)
10:45:10 <monochrom> nevermind, no file.
10:45:21 <spobat> okay, thanks!
10:45:37 <dispyfree> Hi
10:45:40 <srhb> spobat: Otherwise it won't take long to get a Haskell Platform on a decent internet connection and get going with the ghci repl :)
10:45:48 <dispyfree> avg a = (/) (fromIntegral (summe a))  ( fromIntegral(len a) ) << why doesn't this work without the braces around the / ?
10:46:09 <monochrom> why is the name "avg" suddenly so hot? :)
10:46:18 <donri> adnauseam: fmap sum (mapM reciprocal doubles) -- does that do what you want?
10:46:44 <adnauseam> donri: not sure yet
10:46:49 <monochrom> you can write (fromIntegral (summe a)) / (fromIntegral (len a)) to save one pair of braces
10:46:50 <adnauseam> i'll test it out
10:47:17 <Azel> dispyfree: Because (/) is an operator, you need the braces to use it as a normal function
10:47:35 <donri> adnauseam: it depends on how you want to treat the Nothing case... do you ignore those, or fail the whole computation?
10:47:43 <srhb> dispyfree: without the parens, / is infix. foo / bar, not / foo bar, but (/) foo bar
10:47:58 <dispyfree> ah. so / is an operator and (/) a function. Thank you :)
10:48:13 <Azel> You can use backticks to use a function as an operator(that is, infix)
10:48:38 <donri> `(/)`, infix /! yay!
10:48:43 * donri ducks
10:48:47 <srhb> donri: <_<
10:48:51 <Azel> Like in the following
10:48:54 <Azel> > 'a' `elem` "hello"
10:48:55 <lambdabot>   False
10:49:00 <adnauseam> donri: that solution is actually better than the one i need, since i am forced to use do notation for academic purposes
10:49:05 <monochrom> > 5 `(/)` 4
10:49:05 <mauke> f x y  =  x `f` y
10:49:06 <lambdabot>   <no location info>: parse error on input `('
10:49:13 <mauke> backticks only work on identifiers
10:49:14 <monochrom> no goal
10:49:27 <donri> adnauseam: aha, homework?
10:49:30 * monochrom ticks
10:49:37 <dispyfree> ok thanks guys :)
10:49:47 <adnauseam> donri: i'll figure out a way to "do" this, probably look at the implementation of mapM
10:49:50 <adnauseam> donri: yes
10:49:53 <dispyfree> how can I use functions as infix with more than two arguments? ;P
10:50:05 <srhb> dispyfree: What does infix mean for more than two arguments?
10:50:32 <srhb> You can do some fairly contrived things..
10:50:45 <srhb> > let foo a b c = a + b + c in 1 `foo` 2 $ 3
10:50:46 <lambdabot>   6
10:50:54 <dispyfree> sum 1 2 3 => 1 `sum` 2 ... and the third one?
10:50:55 <srhb> > let foo a b c = a + b + c in (1 `foo` 2) 3
10:50:55 <monochrom> "f x y z" = "(x `f` y) z"
10:50:56 <lambdabot>   6
10:51:04 <dispyfree> in this case I could use another sum okay
10:51:15 <dispyfree> but what's with functions who really need all three arguments at the same time?
10:51:26 <srhb> dispyfree: No function does.
10:51:32 <srhb> (I think)
10:51:55 <monochrom> right, even (+) needs 0 arguments
10:51:57 <dispyfree> would it be possible if one did :)
10:52:00 <monochrom> @let hi = (+)
10:52:01 <lambdabot>  Defined.
10:52:09 <monochrom> 0 arguments needed. no error
10:52:10 <srhb> dispyfree: I'm not sure what you're asking
10:52:23 <dispyfree> how I could use a function infix if it requires 3 arguments
10:52:35 <srhb> dispyfree: As you saw in my example, the first infix application (two arguments) just takes a third argument
10:52:36 <rwbarton> exactly as srhb demonstrated
10:52:40 <monochrom> you can infix the first two arguments, as shown
10:52:52 <srhb> > let foo a b c = a + b + c in (1 `foo` 2) 3
10:52:52 <donri> dispyfree: multi-argument functions are actually single-argument functions returning new functions
10:52:53 <lambdabot>   6
10:53:15 <dispyfree> yes, that's the lambda theory
10:53:34 <donri> dispyfree: the way to "require" arguments "at once" is to take tuples as arguments, which no longer works sanely infix
10:53:39 <srhb> dispyfree: Yes. How would you infix it otherwise? How do you put one name between three arguments?
10:53:51 <dispyfree> so in fact I could do: ((threeOnes 1) 2 ) 3 @donri?
10:54:03 <monochrom> you can also design a 2D notation like how chemists draw out ammonia (NH3) so the operator is surrounded by 3 arguments like N is surrounded by 3 H's
10:54:04 <donri> yep
10:54:05 <JEntrep> Happy Alan Turing Day everyone! :D
10:54:10 <dispyfree> ok, nice idea, thanks
10:54:30 <srhb> dispyfree: Or just not infix it... :-) It'll probably be clearer
10:55:05 <monochrom> > (((+) id) sin) 1
10:55:05 <lambdabot>   1.8414709848078965
10:55:14 <monochrom> > (id + sin) 1
10:55:15 <lambdabot>   1.8414709848078965
10:55:21 <dispyfree> yeah. I'm just looking  for ways to screw up concepts @srhb ;D
10:55:28 <srhb> dispyfree: Alright :)
10:56:00 <srhb> monochrom: What, how does that work.
10:56:53 <navaati> what lib is recommended to do simple parsing stuff (fd.o desktop files) ? isn't parsec too complicated ?
10:57:00 <monochrom> someone loaded a functional Num instance into lambdabot.
10:57:12 <srhb> monochrom: Ah. That's cheating.
10:57:24 <Adeon> nothing prevents you from using parsec for simple stuff
10:58:07 <monochrom> normally I hate that. but great way to demo "3-argument infix +" and/or how there is no fixed number of arguments
10:58:15 <monochrom> @quote monochrom -ary
10:58:15 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
10:59:01 <donri> see also: printf
10:59:09 <navaati> Adeon: yeah but i'd need to learn it and am a bit lazy, so if there was a simpler lib‚Ä¶ :)
10:59:55 <donri> if you feel you must, rex is a nice package for regex
11:00:05 <donri> but, learning parsec is worth it
11:00:24 <monochrom> hmm, rex? I should take a look
11:01:44 <monochrom> ooohhh, it looks really nice. quasi-quoting regexs to yield well-typed well-defined things
11:01:49 <donri> yep :)
11:01:51 <dylukes> monochrom: Do you have any recommendations with respect to module naming for the main implementation of something
11:01:52 <navaati> hum‚Ä¶ i'm even more lazy to write regex than to learn parsec, let's go for parsec ^^
11:01:56 <monochrom> i.e. more compile-time checks
11:01:57 <donri> the sort of thing where qq makes sense
11:01:58 <dylukes> i.e., Foo.Bar.Core/Foo.Bar.Common
11:02:16 <dylukes> navaati: Write a TextMate bundle. You will become more comfortable with regex than is humanly safe.
11:02:26 <dylukes> And you will wish for macros. Oh god will you wish for macros.
11:02:34 <donri> try vimscripting
11:02:41 <dylukes> Or just composability in general.
11:02:44 <donri> regex *all* the things!
11:02:50 <monochrom> I don't have recommendations, but comparing "Core" with "Common", I seem to prefer Core
11:02:56 <dylukes> mm
11:03:04 <navaati> regex are‚Ä¶ let's say "not very nice"
11:03:11 <donri> dylukes: why not "Foo.Bar"?
11:05:33 <monochrom> yeah I have used "core" in my code too. I have two functions, fast fourier transform and inverse fast fourier transform, they are both wrappers over the Cooley-Tukey algorithm "ctcore"
11:10:55 <chrisdone> is there already a class defined somewhere like class URIQuery a where toQuery :: a -> [(String,String)]? defining one in my library, don't want to duplicate
11:12:17 <chrisdone> hm. maybe i'll abstract it later
11:12:26 <aristid> chrisdone: which types would be instances of that class? if this is a good usecase i might add it to http-types
11:12:34 <aristid> damn
11:13:06 <aristid> well, leaving 2 minutes after asking a question is impolite anyways :P
11:16:06 <wingie> im in love with fp
11:16:35 <srhb> wingie: :)
11:24:29 <shapr> dangit, I just missed chrisdone :-(
11:32:16 <applicative> man almost a hundred comments on 'Haskell's cruel record system' http://www.reddit.com/r/haskell/comments/vdg55/haskells_record_system_is_a_cruel_joke/
11:32:23 * applicative refuses to read them
11:34:50 <monochrom> every generation needs something to vent on
11:35:23 <shapr> monochrom: we have n00bs
11:36:02 <monochrom> I don't vent on n00bs! :)
11:36:16 <shapr> Oh, that's good to hear. It rarely helps them improve.
11:36:30 <shapr> hej wingy!
11:36:36 <Taneb> The only problem I have with records is the lack of shortcut for foo {bar = f (bar foo)}
11:36:49 <srhb> Namespacing.. herpderp.
11:37:02 <hpc> . o O (RecordKinds + automatic class/instance for every record/field)
11:37:09 <donri> setters being neither composable nor first-class
11:37:22 <Taneb> But other than that... I think lenses etc have a very different purpose
11:37:43 <monochrom> I don't have a reddit account. maybe I should create one just so I can add a couple of "me too" to that thread to show them what they are doing
11:37:50 <DexterLB> what's the best way to store and compare time and time intervals? UTCTime/Difftime?
11:37:57 <DexterLB> or something else
11:37:59 <Taneb> monochrom, won't help?
11:38:16 <monochrom> won't help what?
11:38:35 <Taneb> It won't show them what they are doing
11:38:42 <Taneb> It'll show them they have people who agree with them
11:39:34 <monochrom> for the very stupid minority of them, sure
11:39:53 <Taneb> Now you're assuming the very stupid ones are in the minority
11:40:20 <monochrom> yes. please don't burst my charitable assumption! :)
11:41:17 <monochrom> I'm actually pretty sure that most of them are aware of "AOLers full of 'me too' "
11:41:35 <roconnor_> DexterLB: UTCTime and Difftime yes
11:42:00 <Taneb> monochrom, yeah, but if you'd just had a rant and saw someone agreeing with you, you wouldn't think
11:42:24 <liborw> hi, how to make type foo = (String, Double) instance of Eq comparing only the String? Doing instance Eq Foo where a == b = (fst a) == (fst b) I have got Ambiguous occurrence of '=='? thanks
11:42:34 <monochrom> maybe "me 2" and/or "+1" will make it very obvious
11:42:48 <Taneb> monochrom, maybe, probably not
11:43:27 <scopedTV> liborw: there is an instance Eq a, Eq b => Eq (a,b) already
11:43:30 <matthiasgorgens> oleg's Iteratee paper is really readable.
11:43:31 <scopedTV> liborw: use a newtype.
11:43:35 <matthiasgorgens> (called describe.pdf)
11:43:35 <monochrom> grading student work is more fun that reddit anyway
11:43:54 <Taneb> Man, I wish I had enough students to grade their work
11:44:02 <Taneb> I wish I had enough experience to get students
11:44:09 <Taneb> I wish for a lot of things
11:44:21 <Taneb> Into the Woods is a good musical
11:45:33 <liborw> scopedTV: I will try, thanks.
11:46:03 * ski read "stupid minority" as "stupid majority", thinking monochrom wanted to alert a non-stupid minority to the stupidness of the discourse ..
11:49:34 <lebedev> liborw: is equal ("Hi", 5) and ("Hi, 6)?
11:50:48 <liborw> lebedev: yes
11:51:44 <Azel> liborw: You should use a newtype and not a type synonym if you want to do that, because tuples already have Eq instances
11:52:11 <monochrom> > ("hi", 5) == ("hi", 6)
11:52:12 <lambdabot>   False
11:53:18 <monochrom> in fact use "data Mine = MineCtor String Double"
11:54:48 <liborw> monochrom: ok, thanks
11:57:04 <lebedev> liborw : This is not a good idea, because if A == B, then A and B are the same objects. You can create new operator ===.
11:57:16 <scopedTV> ?? This is a fine idea.
11:57:16 <lambdabot>  This is a fine idea.
11:57:39 <scopedTV> (==) should be an equivalence relation really, and this is one
11:58:33 <scopedTV> for example, data Groupification a = Group (a,a) ...
11:58:36 <applicative> matthiasgorgens: which oleg paper is this?
11:59:44 <scopedTV> Group (x,y) == Group (a,b) = x*b == y*a
12:01:30 <Eduard_Munteanu> Why Group?
12:01:42 <scopedTV> this turns any monoid into a group
12:01:43 <Eduard_Munteanu> That looks a bit like fractions.
12:01:50 <scopedTV> Yes! Exactly.
12:02:13 <scopedTV> that turns the (Z\{0},*)-monoid into a group
12:02:16 <Eduard_Munteanu> Mm, if 'a' is a monoid, you get a group (a,a) ?
12:02:38 <scopedTV> yes
12:02:43 <monochrom> "Group (a,a)" is redundant. "Group a a"
12:02:48 <scopedTV> Right, that's better.
12:03:21 <Eduard_Munteanu> Erm, wait, what's the operation on the 'a' monoid?
12:03:37 <Eduard_Munteanu> (and on the resulting group)
12:03:44 <scopedTV> * is the operation on the monoid
12:04:32 <Eduard_Munteanu> I'm not sure how this works.
12:05:00 <scopedTV> (a,b) * (c,d) = (a*c, b*d) I think.
12:05:07 <scopedTV> invert (a,b) = (b,a)
12:05:13 <Eduard_Munteanu> Oh, hm.
12:05:34 <scopedTV> inject x = (x,1)
12:06:21 <monochrom> recall how to use integers to build rationals
12:06:30 <scopedTV> Hmm, I'm lying, this is of course not necessarily a group.
12:06:52 <scopedTV> you need the absense of certain elements as well
12:06:55 <tobiassjosten> I don't understand what's wrong with this code. Could someone please help me? map putStrLn (lines "asdf")
12:07:17 <srhb> tobiassjosten: lines does not produce a string.
12:07:17 <scopedTV> tobiassjosten: nothing wrong with it, it's just not the type you expected
12:07:27 <srhb> scopedTV: Eh?
12:07:31 <monochrom> mapM_ putStrLn (lines "asdf")
12:07:41 <scopedTV> :t map putStrLn (lines "asdf")
12:07:43 <lambdabot> [IO ()]
12:07:48 <scopedTV> this is "a list of IO actions"
12:07:51 <srhb> Blurgh, I missed tha map.
12:07:54 <srhb> the*
12:07:56 <scopedTV> you can execute then with sequence
12:08:07 <scopedTV> so sequence (map putStrLn (lines "asdf"))
12:08:18 <scopedTV> or use mapM f, which is sequence . map f
12:08:19 <monochrom> seqeuence_ is better for this
12:08:23 <scopedTV> yes, it is.
12:08:35 <tobiassjosten> So the return value from putStr (being IO ()) is what makes map not able to use it?
12:08:35 <scopedTV> otherwise, you'd build up a list of emtpy tuples
12:09:07 <scopedTV> tobiassjosten: no, map can use it, you just get a list of IO actions (i.e. [IO ()])
12:09:16 <scopedTV> but this is a list of IO actions, not an IO action itself
12:09:44 <scopedTV> sequence turns a list of IO actions into an IO action that (when performed) executes the IO actions in sequence.
12:10:00 <scopedTV> so sequence [m1, m2, m3] = do { m1; m2; m3 }
12:10:00 <Wooga> hi, how Fd is defined in haskell?
12:10:04 <Wooga> is it regular Int ?
12:10:10 <tobiassjosten> Ohh, I see. Kind of. :)
12:10:13 <scopedTV> (basically. it also collects the results of the IO actions.)
12:10:27 <monochrom> Fd is probably internally Int, but you shouldn't need to know
12:10:43 <tobiassjosten> Thanks a lot, it's compiling now.
12:10:44 <Wooga> i am trying to bind C library retirning Fds
12:10:51 <Wooga> so i need to know
12:11:00 <tobiassjosten> I really like this channel's patience with us noobs. ;)
12:11:00 <Wooga> returning*
12:11:09 <monochrom> ah, right
12:11:19 <geekosaur> Wooga, you don't work with fds directly in haskell for the most part
12:11:34 <Wooga> geekosaur: not true when you're recording tty
12:11:34 <scopedTV> Fd is a newtype of CInt according to System.Posix.Types
12:11:36 <geekosaur> I am aware of at least two ways that C fds get mapped into Haskell
12:11:52 <geekosaur> Wooga, you missed my point
12:11:52 <Wooga> scopedTV: thank you!
12:12:06 <monochrom> System.Posix.Types has it. newtype Fd = Fd CInt. so, even better.
12:12:17 <scopedTV> so you can just unsafeCoerce it, if the constructor is not exported
12:12:18 <Wooga> thanks! that what i needed to know
12:12:24 <geekosaur> (that is one of them.  gtk2hs uses a different one)
12:18:22 <applicative> > length $ map putStrLn (lines "asdf")
12:18:23 <lambdabot>   1
12:20:11 <Cale> Wooga: yeah, you should just be able to foreign import things using the Fd type directly
12:20:53 <navaati> (in ghc 7.4, you'd need to have the constructor in scope, tho)
12:21:16 <Cale> Oh, really? That's interesting.
12:21:27 <Cale> I guess it makes a certain amount of sense.
12:21:47 <Cale> Usually FFI stuff is not as concerned with safety.
12:22:27 <navaati> yeah, because without that i think you could forge a value of every newtype without the constructor using cId :: a -> IO a and it'd be Safe in the SafeHaskell sense
12:25:55 <monochrom> a Haskell 2010 requirement
12:29:05 <ski> scopedTV : <http://en.wikipedia.org/wiki/Grothendieck_group>
12:33:58 <tobiassjosten> I am trying to break up the incoming text (telnet client) into lines, so that I may pattern match them later. But I'm not groking it. Coule someone please advise me on this? http://pastebin.com/ZeetC7R9
12:34:04 <mauke> The paste ZeetC7R9 has been copied to http://hpaste.org/70359
12:34:16 <tobiassjosten> Mainly line 21 and the asdf function.
12:35:06 <scopedTV> tobiassjosten: line 25 seems wrong
12:35:15 <monochrom> did you know that asdf is the 2nd most popular password? :)
12:35:15 <nand`> ‚Äúcommutative monoid‚Äù <- can ‚ÄúAbelian monoid‚Äù be used here or am I misjudging what the word ‚ÄúAbelian‚Äù means?
12:35:19 <scopedTV> asdf = mapM_ putStr . lines
12:35:30 <scopedTV> nand`: abelian is only used for groups.
12:35:35 <srhb> tobiassjosten: You probably want asdf' $ lines str and mapM_ instead of mapM
12:35:45 <scopedTV> nand`: but an abelian group is exactly the same as a commutative group.
12:36:34 <timthelion> OK, I've read the entire wikibook article on "Array" I still don't understand how to USE the darned type though.  Where to look next?
12:36:35 <scopedTV> nand`: this is just a weird convention.
12:37:04 <srhb> tobiassjosten: The type of mapM putStr is [String] -> IO [()] but in the line above, you have return () - so that's a type error.
12:37:26 <srhb> tobiassjosten: The type of mapM_ putStr on the other hand is [String] -> IO () -- which is what you seem to want
12:37:41 <monochrom> asdf str = mapM_ putStrLn (lines str). Please keep it simple stupid and screw asdf'
12:38:19 <srhb> That's true as well. :-)
12:38:31 <monochrom> unless you say you want to learn recursion, in which case you shouldn't even mention mapM or whatever
12:38:32 <tobiassjosten> scopedTV, srhb: Let me try that again. I'll never be friends with this type hinting notation it seems.
12:39:00 <scopedTV> we call it "type annotation" :)
12:40:09 <tobiassjosten> Ah.
12:40:17 <tobiassjosten> Well, that worked perfectly!
12:40:24 <srhb> :)
12:40:47 <tobiassjosten> Now to figure out why, exactly. :)
12:41:23 <monochrom> if you want to learn recursion, firstly it is asdf str = asdf' (lines str), you need parentheses
12:41:51 <srhb> tobiassjosten: First off, "asdf' lines str" was wrong because asdf' did not take two arguments.
12:41:56 <monochrom> secondly it is asdf' (x:y) = putStrLn x >> asdf' y
12:42:53 <tobiassjosten> >> is a new operator to me. What does that do?
12:43:01 <tobiassjosten> Or perhaps it's a function? :)
12:43:13 <scopedTV> tobiassjosten: m >> m' is the action that, when performed, executes m, and then m'
12:43:16 <mauke> operators are just functions with funny names
12:43:22 <scopedTV> tobiassjosten: operators are the same as functions really
12:43:45 <monochrom> do { putStrLn x; asdf' y }. you can also use indentation
12:43:50 <ksf> how would you guys write a fold that, in one of its cases, walks down a second list, too?
12:43:50 <scopedTV> tobiassjosten: so putStrLn "Hello" >> putStrLn "World" is the action that, when performed, prints "Hello" and then prints "World"
12:44:07 <tobiassjosten> Sweet.
12:44:46 <scopedTV> it's the same as do { putStrLn "Hello"; putStrLn "World" }
12:45:09 <tobiassjosten> Because I want to take this incoming text, parse it against a list of patterns and have the matches' trigger a lambda and then finally I want to print the text. I guess >> would be useful for that?
12:45:15 <ksf> I could use state, but the right thing would probably be a dual to reader a la a random monad.
12:45:36 <srhb> tobiassjosten: "trigger a lambda" is a little unclear. What will you do if they don't match?
12:46:08 <ski> nand`,scopedTV : "A monoid whose operation is commutative is called a commutative monoid (or, less commonly, an abelian monoid)."
12:46:10 <tobiassjosten> If they don't match I want nothing to happen, just carry on and print the text.
12:46:33 <nand`> I like ‚Äúabelian monoid‚Äù. More ominous-sounding
12:46:35 <Eduard_Munteanu> I've only heard abelian used for groups.
12:46:45 <srhb> tobiassjosten: Okay, then it matters what the "something lambda" does. :-)
12:46:56 <scopedTV> ski: ugh really? never seen it though.
12:47:04 <srhb> tobiassjosten: Probably you would want to accumulate the matches and throw the rest away?
12:47:13 <ski> scopedTV : i don't recall if i've seen it
12:47:28 <ski> (in a paper, i mean)
12:48:06 <Eduard_Munteanu> Though "abelian" is quite useless considering we're using commutative in every other instance.
12:48:15 <tobiassjosten> srhb: They should return a state change. This is for a game, so one change could be "decrease health by 10".
12:48:19 <scopedTV> the name is useless, sure.
12:48:26 <scopedTV> we just want to honour Nils Abel
12:48:31 <Eduard_Munteanu> Yeah :)
12:49:21 <Taneb> What's a cool but underused library that everyone should know about?
12:49:39 <irene-knapp> Taneb: anything written by me :D
12:49:54 <parcs`> lifted-base
12:50:00 <Eduard_Munteanu> Mm... vector?
12:50:00 <irene-knapp> yeah, lifted-base is pretty awesome
12:50:24 * Eduard_Munteanu looks that up
12:50:35 <scopedTV> vector is pretty well-known isn't it?
12:50:45 <irene-knapp> it's part of the system of packages that monad-base is also part of
12:51:00 <Taneb> That reminds me, I need to learn how to use threading and concurrency
12:51:09 <irene-knapp> forkIO
12:51:13 <irene-knapp> Control.Concurrent
12:51:21 <parcs`> i guess 'async' can also be considered cool and underused
12:51:29 <parcs`> but that's because it's brand new
12:51:55 <Taneb> Unfortunately, the only library I wrote is a) pretty niche and b) not very good
12:51:59 <irene-knapp> parcs: by the way, did you ever have a chance to dig into my emulator code?  I'd have been surprised if you managed to improve the performance issue, but I'm curious how you found it readability-wise and all that.
12:52:00 <Eduard_Munteanu> Also, edwardk's stuff is quite cool.
12:52:10 <nand`> edwardk's stuff is always cool
12:52:10 <Taneb> (family-tree, if anyone cares)
12:52:10 <scopedTV> data-lens?
12:52:25 <irene-knapp> yeah, edwardk's stuff is generally pretty awesome, although it frequently uses things like three layers of Template Haskell and unsafePerformIO under the hood :D
12:52:42 <Eduard_Munteanu> Ah, I mean the categories stuff.
12:52:48 * irene-knapp nods
12:53:36 <adnauseam> donri: do you think there's a way of writing a function with do nation and have it recursive ? my signature is f :: [Double] -> Maybe Double. i'm finding it puzzling to think about a way to implement something like f (x:xs) = do a <- g x : f xs
12:54:07 <Eduard_Munteanu> adnauseam: sure there is
12:54:12 <adnauseam> i could go for helper functions, though then f itself wouldn't be recursive. just trying to stick to instructions
12:54:21 <adnauseam> Eduard_Munteanu: can you show me an example ?
12:54:27 <scopedTV> adnauseam: not sure what you want there?
12:54:50 <mauke> adnauseam: f (x : xs) = do { y <- g x; ys <- f xs; return (y : ys) }
12:55:09 <ocharles> :t foldM
12:55:10 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
12:56:14 <Eduard_Munteanu> f [] acc = return acc; f (x:xs) acc = do { acc' <- return (x + acc); f xs acc' }
12:57:42 <adnauseam> scopedTV: i've got this function http://pastebin.com/gpqw2Qrm , and i'm supposed to write the recursive function sumrecip using do notation
12:57:44 <mauke> The paste gpqw2Qrm has been copied to http://hpaste.org/70362
12:57:47 <adnauseam> mauke; looking into it
12:58:17 <Eduard_Munteanu> adnauseam: mauke has a bot that copies pastebin.com pastes to hpaste
12:59:00 <Eduard_Munteanu> adnauseam: heh, I just gave you a way to sum things up
12:59:41 <adnauseam> Eduard_Munteanu: my signature restricts me to only having one argument for f :/
12:59:52 <adnauseam> an accumlator would have made this task very easy
13:00:12 <applicative> adnauseam: the definition of reciprocal shouldnt use an equality test, no?; just reciprocal 0 = Nothing; reciprocal r = 1 / r or whatever
13:00:42 <adnauseam> applicative: shouldn't it ? hmm, let me look at it
13:00:42 <scopedTV> that's the same thing, isn't it?
13:00:46 <applicative> Just (1/r) rather
13:00:52 <adnauseam> hm
13:01:07 <adnauseam> my definition is "if 0 then nothing, else 1\x"
13:01:19 <adnauseam> otherwise iget 1\0
13:01:21 <applicative> it's not a mistake just an unnecessary layer
13:01:34 <scopedTV> it desguars into the same thing
13:01:40 <adnauseam> oh
13:02:04 <Eduard_Munteanu> adnauseam: then you don't have to use one... f [] = 0; f (x:xs) = { r <- f xs; return (x + r) }   though that could blow the stack on large lists
13:02:06 <timthelion> array (0,4) [(a,a)|a<-[0..10]]
13:02:07 <timthelion> array *** Exception: Ix{Integer}.index: Index (5) out of range ((0,4))
13:02:24 <timthelion> MY GOD!  why doesn't it just stop reading the darned list, if it's run out of space in the array?
13:02:30 <Eduard_Munteanu> erm *do
13:02:39 <applicative> the other desugars to a case statement, thats why I think it preferable, I guess the if 0 then ... one comes to the same
13:02:58 <scopedTV> timthelion: int A[37]; A[37] = 3; // why is this undefined or throws an exception?
13:03:11 <adnauseam> hrm, with reciprocal 0 i get Just Infinity
13:03:20 <adnauseam> wait,
13:03:48 <timthelion> scopedTV: Yes, but Haskell is supposed to be smarter than that :)
13:04:00 <mauke> timthelion: because it doesn't know which part is incorrect, the dimensions or the initializer
13:04:02 <scopedTV> timthelion: by silently failing/doing nothing on undefined input? not thanks
13:04:10 <scopedTV> invlaid*
13:04:19 <scopedTV> ugh, i cannot type today
13:04:25 <mauke> timthelion: but see listArray
13:05:26 <adnauseam> applicative: i see what you mean now
13:05:32 <timthelion> >array (0,1) [(0,0),(1,1),(0,3)] ! 0
13:05:37 <timthelion> > array (0,1) [(0,0),(1,1),(0,3)] ! 0
13:05:38 <lambdabot>   3
13:05:41 <applicative> > listArray (0,4) [0..10]
13:05:42 <lambdabot>   array (0,4) [(0,0),(1,1),(2,2),(3,3),(4,4)]
13:05:50 <applicative> > listArray (0,4) [0..10]  ! 0
13:05:51 <lambdabot>   0
13:06:00 <timthelion> mauke: ah, thanks! :)
13:06:18 <timthelion> it's weird, that array, lets you define the same element twice...
13:06:27 <timthelion> wow, too many commas
13:06:27 <applicative> > listArray (0,4) [(a,a) |a  <- [0..10]]  ! 0
13:06:28 <lambdabot>   (0,0)
13:06:31 <scopedTV> timthelion: it doesn't, I thought it was undefined.
13:06:41 <timthelion> scopedTV: look above
13:06:45 <timthelion> > array (0,1) [(0,0),(1,1),(0,3)] ! 0
13:06:46 <lambdabot>   3
13:06:51 <timthelion> or bellow
13:06:57 <scopedTV> timthelion: I know it behaves like that in GHC
13:07:39 <ClaudiusMaximus> hugs says "Program error: undefined array element"  with that last example
13:08:23 <timthelion> :(
13:08:35 * timthelion doesn't like it when different compilers act differently.
13:09:05 <scopedTV> it's docuemnted that this behavior is not specified
13:09:38 * roconnor_ decides to call (a -> f b) and f-algebroid
13:09:42 <timthelion> scopedTV: That doesn't mean, that any behavior shoud ever be unspecified :)
13:09:48 <timthelion> *should
13:09:49 <roconnor_> *an
13:10:32 <applicative> what are you going to do with (a -> f b)
13:11:56 <roconnor_> applicative: "compose" it with a (b -> g c)
13:14:58 <Saizan> shouldn't it be an f-coalgebroid?
13:15:27 <roconnor_> oh right
13:15:35 <applicative> > let comp :: (Functor f, Functor g) => (b -> g c) ->  (a -> f b) -> a -> f (g c) ; comp oid1 oid2 a = fmap oid1 $ oid2 a
13:15:36 <lambdabot>   not an expression: `let comp :: (Functor f, Functor g) => (b -> g c) ->  (a...
13:15:51 <applicative> i was wondering why it wasnt f b -> a
13:16:32 <applicative> > let comp :: (Functor f, Functor g) => (b -> g c) ->  (a -> f b) -> a -> f (g c) ; comp oid1 oid2 a = fmap oid1 $ oid2 a in comp show show 1
13:16:33 <lambdabot>   ["'1'"]
13:16:51 <asdf__> pl (liftM2 . liftM2)
13:17:28 <DMcGill> @pl (liftM2 . liftM2)
13:17:29 <lambdabot> liftM2 . liftM2
13:17:32 <asdf__> @pl (liftM2 . liftM2)
13:17:32 <lambdabot> liftM2 . liftM2
13:17:47 <applicative> @unpl (liftM2 . liftM2)
13:17:47 <lambdabot> (\ l d e -> d >>= \ b -> e >>= \ a -> return (b >>= \ g -> a >>= \ h -> return (l g l)))
13:18:05 <DMcGill> :t liftM2 . liftM2
13:18:06 <lambdabot> forall (m :: * -> *) a1 a2 r (m1 :: * -> *). (Monad m, Monad m1) => (a1 -> a2 -> r) -> m (m1 a1) -> m (m1 a2) -> m (m1 r)
13:18:08 <applicative> wow too pointy
13:24:10 <roconnor_> oh man, an algebroid is a real word
13:24:44 <scopedTV> really? i thought it was quite complex
13:26:48 <`Jake`> > let f as bs = find (\(a,b) -> b >= a) $ zip (as `par` bs `seq` as) bs
13:26:49 <lambdabot>   not an expression: `let f as bs = find (\(a,b) -> b >= a) $ zip (as `par` b...
13:26:55 <`Jake`> > f as bs = find (\(a,b) -> b >= a) $ zip (as `par` bs `seq` as) bs
13:26:56 <lambdabot>   <no location info>: parse error on input `='
13:27:17 <`Jake`> > let f as bs = find (\(a,b) -> b >= a) $ zip (as `par` bs `seq` as) bs in f [1000..] [1.0,2.1]
13:27:19 <lambdabot>   Nothing
13:27:40 <badkins> I just downloaded ghc-7.4.1-i386-unknown-linux.tar.bz2 to an Ubuntu 11.10 system. Running ./configure returns the following error:
13:27:41 <badkins> checking for path to top of build tree... ./configure: line 2113: utils/ghc-pwd/dist-install/build/tmp/ghc-pwd: No such file or directory
13:27:41 <badkins> configure: error: cannot determine current directory
13:27:41 <badkins>  
13:27:49 <badkins> the file in question does exist
13:27:55 <badkins> Any thoughts?
13:28:35 <`Jake`> I can't really help you, but I suppose you know that you can always just install it via apt-get
13:28:51 <badkins> I did that first, but then the haskell platform complained about an old ghc
13:28:58 <badkins> I think it was 7.0...
13:29:17 <`Jake`> weird, I did it and got 7.4.1...
13:29:31 <badkins> Not exactly sure what the haskell platform buys me, but I figured I'd try it out.
13:29:39 <badkins> Are you on Ubuntu 11.10 ?
13:29:42 <`Jake`> no, 12.04
13:29:58 <badkins> that's probably why :(
13:30:06 <`Jake`> might be :/
13:30:38 <`Jake`> tried apt-get update already?
13:30:46 <`Jake`> before installing
13:32:22 <adnauseam> Eduard_Munteanu: http://pastebin.com/gpqw2Qrm i'm doing something wrong here
13:32:22 <mauke> The paste gpqw2Qrm has been copied to http://hpaste.org/70362
13:32:28 <badkins> `Jake`: I'll try that
13:33:14 <Eduard_Munteanu> adnauseam: yeah, why are you using those maps?
13:33:34 <Eduard_Munteanu> And why Just [0]?
13:33:50 <Eduard_Munteanu> I'd expect f :: [Double] -> Maybe Double
13:33:51 <adnauseam> stated in the exercise
13:33:52 <badkins> nope, still get ghc 7.0.3
13:34:05 <adnauseam> and yeah that is my sig
13:34:18 <`Jake`> badkins: that's strange.
13:34:27 <Eduard_Munteanu> Well, it's not that, it's   f :: [Double] -> Maybe [Double]
13:34:32 <badkins> probably tied to my distro
13:34:36 <adnauseam> hm
13:34:40 <badkins> different repo maybe
13:34:42 <adnauseam> damn
13:35:09 <adnauseam> i've overseen that in my confusion
13:35:53 <Eduard_Munteanu> adnauseam: just do the summing like I did, and call reciprocal like you do
13:37:00 <adnauseam> do i need the inbetween list?
13:37:46 <Eduard_Munteanu> Yeah.
13:37:56 <Dtgr> badkins: stupid question, but: did you untar the package correctly? :p
13:38:05 <adnauseam> Eduard_Munteanu: woah, it works
13:38:20 <adnauseam> Eduard_Munteanu: it was much simple than i thought it is
13:38:25 <adnauseam> thanks for this
13:38:34 <Eduard_Munteanu> Thanks to the Maybe monad :)
13:38:38 <badkins> Dtgr: yes :)
13:39:04 <badkins> I just did sudo apt-get install haskell-platform and it seemed to have installed. Still ghc 7.0.3, but at least I have the platform now.
13:40:46 <Eduard_Munteanu> adnauseam: now that's not a really great way to do it, it'll probably blow the stack for large lists.
13:42:31 <Eduard_Munteanu> (since (+) is strict for numbers and you're effectively building a large computation)
13:42:33 <`Jake`> badkins: I suppose you didn't change your repo mirrors?
13:42:42 <badkins> correct
13:42:55 <badkins> it's no big deal, I'm just starting out, I can upgrade it later
13:43:03 <`Jake`> badkins: apt-get update didn't give you any error?
13:43:10 <badkins> no error
13:43:23 <badkins> I expect the 11.10 repos are different than 12
13:43:53 <`Jake`> badkins: Yeah, probably, but I'm pretty sure that 7.4.1 was there before precise pangolin
13:45:03 <adnauseam> Eduard_Munteanu: how can i protect the stack ?
13:45:35 <Eduard_Munteanu> adnauseam: a strict accumulator
13:45:45 <Dtgr> badkins: what does your /etc/apt/sources.list contain?
13:46:20 <`Jake`> Dtgr: No mirror should be THAT far behind
13:46:21 <Eduard_Munteanu> adnauseam: if you can define a helper function, you can wrap that and still have an  f :: [Double] -> Maybe Double
13:46:26 <adnauseam> Eduard_Munteanu: heh, ironically that'd get me 0 points in the exercise :p
13:46:34 <adnauseam> hrm
13:47:09 <Eduard_Munteanu> g :: [Double] -> Double -> Maybe Double    f xs = g xs 0
13:48:02 * adnauseam gets implementing 
13:48:34 <`Jake`> > let f as bs = find (\(a,b) -> b >= a) $ zip (as `par` bs `seq` as) bs in f [1000..] [1.0,2.1..]
13:48:36 <lambdabot>   Just (10991.0,10991.099999997741)
13:49:03 <`Jake`> Shouldn't that be an infinite loop because I evaluate an infinite list without laziness?
13:49:21 <Dtgr> `Jake`: well, debian stable mirror has ghc 6.12.1 :D
13:49:29 <`Jake`> Dtgr: ouch
13:50:05 * applicative found  ghc 6.12 to be pretty stable; 7.0.3 too
13:50:43 * `Jake` has never had an unstable situation with 7.4.1
13:51:02 <donri> do `Jake` we need to talk to you in infix form?
13:51:37 <`Jake`> donri: you can omit the `s and talk to me in prefix form
13:52:12 <mauke> Peyton `Simon` Jones
13:53:00 <donri> Jack O prime Neil
13:54:26 <`Jake`> > let f as bs = find (\(a,b) -> b >= a) $ zip (as `par` bs `seq` as) bs in f (map id [1000..]) (map id [1.0,2.1..])
13:54:27 <lambdabot>   Just (10991.0,10991.099999997741)
13:54:39 <`Jake`> > let f as bs = find (\(a,b) -> b >= a) $ zip (as `par` bs `seq` as) bs in f (map (*1) [1000..]) (map (*1) [1.0,2.1..])
13:54:40 <lambdabot>   Just (10991.0,10991.099999997741)
13:54:47 <badkins> Dtgr: http://pastie.org/private/l7nz8o7ar3cokxo21p0pa   sources
13:54:53 <`Jake`> seriously, shouldn't this produce an infinite loop?
13:56:05 <`Jake`> > let f as bs = find (\(a,b) -> b >= a) $ zip (as `par` bs `seq` as) bs in f (map (*2) [1000..]) (map (*2) [1.0,2.1..])
13:56:07 <lambdabot>   Just (21982.0,21982.199999995482)
13:56:10 <ique> tobiassjosten: and you have "module Something where" at the top of that file? and are sure that case is correct?
13:56:31 <`Jake`> > let f as bs = find (\(a,b) -> b >= a) $ zip (bs `seq` as) bs in f (map (*2) [1000..]) (map (*2) [1.0,2.1..])
13:56:32 <lambdabot>   Just (21982.0,21982.199999995482)
13:57:03 <`Jake`> So strictly evaluating infinite lists doesn't cause an infinite loop?
13:59:15 <tobiassjosten> ique: Turned out my file was named with lowercase something.hs‚Ä¶
14:00:01 <ique> tobiassjosten: i've made that mistake several times as well :)
14:00:42 <`Jake`> badkins: well, I can't even find rackspace on my mirror list
14:01:02 <`Jake`> badkins: which is not necessarily a bad thing for you
14:01:14 <badkins> I'm running a Rackspace cloud VPS
14:01:22 <badkins> they probalby insert their own mirror for efficiency
14:01:56 <`Jake`> i see
14:02:01 <adnauseam> Eduard_Munteanu: http://pastebin.com/gpqw2Qrm what am i missing there man ?
14:02:02 <mauke> The paste gpqw2Qrm has been copied to http://hpaste.org/70362
14:02:57 <adnauseam> hmm, maybe it's the list names..
14:03:41 <adnauseam> not the list names
14:04:05 <`Jake`> badkins: Well, I don't know too much about this, but it could be that another mirror would give you ghc 7.4.1 or 7.4.2
14:04:39 <badkins> yes, I'm just not sure how that would affect the rest of the packages/dependencies, etc.
14:04:58 <badkins> I'm not concerned about it now. I can spin up a newer VPS later and get the latest GHC
14:05:14 <badkins> thanks for the help
14:05:35 <`Jake`> no problem
14:07:17 <`Jake`> oh, and because I just noticed potential for a misunderstanding, "my mirror list" doesn't mean my sources.list, but this website: https://launchpad.net/ubuntu/+archivemirrors
14:07:25 <ique> `Jake`: I don't think bs `seq` as is seq'ing the whole list
14:07:45 <`Jake`> ique: ok..
14:08:15 <ique> on a finite list it would only seq the "spine" of the list, not the elements.. so on an infinite list it's possible that it's only evaluating the structure of the infinite list, in either case it wouldn't be evaluating the elements
14:08:33 <mauke> seq will force the first constructor
14:08:39 <mauke> i.e. (:) or []
14:08:41 <`Jake`> ok, I see... thanks
14:08:41 <mauke> that's all
14:08:57 <ique> ah, right
14:09:15 <Eduard_Munteanu> adnauseam: the accumulator shouldn't be Maybe something
14:09:16 <mauke> > (undefined : undefined) `seq` ()
14:09:17 <lambdabot>   ()
14:11:24 <Eduard_Munteanu> adnauseam: you also want  z `seq` safeSumrecip xs (z + a)
14:11:30 <nand`> map (join seq) [0, 1, 2, undefined, 3]
14:11:32 <nand`> > map (join seq) [0, 1, 2, undefined, 3]
14:11:33 <lambdabot>   [0,1,2,*Exception: Prelude.undefined
14:12:22 <adnauseam> Eduard_Munteanu: got it
14:12:28 <`Jake`> [0, 1, 2, undefined, 3]
14:12:32 <`Jake`> > [0, 1, 2, undefined, 3]
14:12:33 <lambdabot>   [0,1,2,*Exception: Prelude.undefined
14:12:56 * hackagebot shelly 0.12.0.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.12.0.1 (GregWeber)
14:12:58 <nand`> hmm, map (join seq) won't actually force the elements until the map is evaluated though, right?
14:13:13 <`Jake`> > head (map (join seq) [0, 1, 2, undefined, 3])
14:13:14 <lambdabot>   0
14:13:17 <MostAwesomeDude> > [0..] ++ [undefined]
14:13:19 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
14:13:21 <Eduard_Munteanu> (so z is forced when safeSumrecip ... is evaluated)
14:13:37 <Eduard_Munteanu> (therefore, at every step)
14:13:38 <`Jake`> > last (map (join seq) [0, 1, 2, undefined, 3])
14:13:39 <lambdabot>   3
14:17:58 * hackagebot persistent-mongoDB 0.9.0.3 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-0.9.0.3 (GregWeber)
14:18:00 * hackagebot shelly 0.12.0.2 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.12.0.2 (GregWeber)
14:20:21 <adnauseam> Eduard_Munteanu: understood, it's working beautifully now
14:20:32 <adnauseam> i tried to look at the implementation of seq, but didn't get much from it
14:20:40 <nand`> > let seqList :: [a] -> b -> b; seqList [] b = b; seqList (x:xs) = (x `seq` seqList xs ()) `seq` b; l = [0, 1, undefined, 3] in l `seqList` head l
14:20:42 <lambdabot>   Equations for `seqList' have different numbers of arguments
14:20:42 <lambdabot>    <interactive...
14:20:50 <adnauseam> just say seq = ... -- primitive in the prelude code
14:20:52 <nand`> > let seqList :: [a] -> b -> b; seqList [] b = b; seqList (x:xs) b = (x `seq` seqList xs ()) `seq` b; l = [0, 1, undefined, 3] in l `seqList` head l
14:20:53 <adnauseam> says*
14:20:53 <lambdabot>   *Exception: Prelude.undefined
14:22:33 <nand`> ‚Äúxs `seqList` x `seq` b‚Äù works too
14:22:39 <cesc> jem777  <--- must also play the electric guitar
14:22:57 <`Jake`> > let seqList :: [a] -> b -> b; seqList [] b = b; seqList (x:xs) b = (x `seq` seqList xs ()) `seq` b; l = [0..] in l `seqList` head l
14:22:58 <lambdabot>   *Exception: stack overflow
14:23:01 <`Jake`> ok
14:23:35 <nand`> > let l = [0, 1, undefined, 3] in l `deepseq` head l
14:23:36 <lambdabot>   Not in scope: `deepseq'
14:23:50 <tgeeky> does anyone remember the name of a hackage package which had cyclic or round lists? The documentation had a nice  description with a   circular arrangement of letters, with a focus on one of the letters at the bottom?
14:23:59 <nand`> (^ more or less the same thing, but deepseq evaluates the list's contents completely too, whereas seqList only evaluates the list content's constructors)
14:24:25 <`Jake`> @hoogle deepseq
14:24:26 <lambdabot> Control.DeepSeq module Control.DeepSeq
14:24:26 <lambdabot> Control.DeepSeq deepseq :: NFData a => a -> b -> b
14:24:26 <lambdabot> package deepseq
14:25:03 <`Jake`> what happens if you use seq with list comprehensions?
14:25:24 <`Jake`> I guess it will again only evaluate the first element?
14:25:30 <`Jake`> or constructor
14:27:27 <Cale> Well, it does nothing special in any case. I'm not sure what you mean by "with" though.
14:28:23 <`Jake`> {list comprehension} `seq` {something else}
14:28:53 <scopedTV> first constructor
14:28:56 <`Jake`> ok
14:29:17 <scopedTV> > [undefined | x <- [1..]] `seq` ()
14:29:18 <lambdabot>   ()
14:29:31 <scopedTV> > [() | x <- undefined] `seq` ()
14:29:32 <lambdabot>   *Exception: Prelude.undefined
14:29:38 <nand`> in effect, it will evaluate the first constructor of [1..]
14:29:38 <ique> if you wanted to evaluate all constructors of a list before returning something else you could do ((length bs) `seq` as), if bs is infinite list then it will loop infinitely
14:31:25 <`Jake`> It feels like that would cause some overhead, but I guess it doesn't
14:31:48 <MostAwesomeDude> Hey, has anybody done uniplate? I'm slightly hung up on para.
14:34:03 <`Jake`> If anyone is interested, I just calculated that in 2081, we will be able to store the information of the entire internet on a single HDD.
14:34:08 <roconnor_> preflex: seen ddarius
14:34:09 <preflex>  ddarius was last seen on #haskell 106 days, 19 hours, 26 minutes and 36 seconds ago, saying: BMeph: No.
14:34:17 <roconnor_> hmm
14:34:23 <roconnor_> that seems like a long time ago
14:35:16 <ique> `Jake`: you mean the information of the entire 2012 internet :P
14:35:25 <`Jake`> ique: No, I don't.
14:36:04 <`Jake`> ique: the capacity of an HDD doubles every two years, the information in the internet doubles every 5 years.
14:37:09 <ique> `Jake`: well.. the capacity of an HDD doubles every two years because of scientific factors, the internet doubles every five years currently because of social factors, it seems unlikely that the internet follows a linear curve
14:37:24 <`Jake`> ique: yeah, well, it's a theoretical cimputation
14:37:32 <`Jake`> computation*
14:37:35 <ique> with the expanse of broadband and social factors like wealth (the entirety of china and india getting computers) would surely increase that factor
14:37:57 <`Jake`> ique: that is probably true.
14:37:59 <`Jake`> ique: BUT:
14:38:09 <MostAwesomeDude> Okay, so I'm trying to grok paramorphism.
14:38:25 <MostAwesomeDude> I'm dealing with a type (a -> [b] -> b) -> a -> b
14:38:25 <`Jake`> ique: Just like the articles on wikipedia, the growth will slow down at some point
14:38:32 <`Jake`> the number of articles
14:38:51 <MostAwesomeDude> And I get that I provide the first function, but I'm not sure exactly how all of the [b] are gathered.
14:39:51 <MostAwesomeDude> Oh, nevermind, I get it now.
14:40:13 <ique> hmm.. interesting thought.. could it theoretically keep growing forever? i guess if every person would start streaming their lives with increasingly higher resolution cameras, the growth would continue with population increase and camera tech increase :P but you're probably right ^^
14:40:48 <`Jake`> ique: Or maybe I'm wrong... chances are, we will never know
14:41:18 <ique> hehe‚Ä¶ well.. if it's decided by 2081 we probably (hopefully) will :P
14:42:23 <`Jake`> Yeah, we will know that... But not if the internet will ever top growing ;-)
14:42:28 <`Jake`> stop*
14:42:40 <ique> hehe true
14:44:23 <DMcGill> that's like asking people to stop talking
14:44:37 <ocharles> "woah, the internet is full"
14:44:47 <ocharles> better delete myspace
14:44:50 * roconnor_ hopes ddarius is okay
14:45:07 <DMcGill> see: http://www.bradarchibald.com/wp-content/uploads/dilbert-internet-full.jpg
14:45:16 <geekosaur> lazy garbage collection.  it took a long time to get around to geocities...
14:45:33 <`Jake`> well, soon, there won't be any ip-adresses left, that's why there is ipv6, I believe
14:45:48 <DMcGill> then in a few million years we'll have to move to ipv7
14:46:03 <`Jake`> oh yeah...
14:46:55 <`Jake`> roconnor_: https://www.facebook.com/djddarius?sk=wall
14:47:02 <`Jake`> I don't know if that's him
14:47:35 <Urchin> actually, most of ipv4 adresses are unused
14:47:46 <`Jake`> but looks like he has a BSc CS
14:47:52 <Urchin> there just isn't any unclaimed
14:48:13 <`Jake`> Urchin: because of dynamic IPs?
14:48:46 <Urchin> no
14:48:56 <Urchin> some are just plain unused
14:49:02 <Urchin> most, in fact
14:49:05 <DMcGill> isn't it because only 1-255 are valid
14:49:54 <Urchin> the organisation that hosts this server I'm using to run my irc client on has 12 IPs assigned to it, but only uses 4
14:50:04 <Urchin> iirc
14:50:32 <`Jake`> is there a reason for that?
14:50:59 <Urchin> we don't have more servers than that that need to be connected
14:51:04 <Urchin> plain and simple
14:51:14 <Urchin> but we can always expand
14:51:33 <`Jake`> I see
14:51:43 <james-ubc> lol
14:52:04 <james-ubc> no the last few blocks
14:52:08 <james-ubc> of ipv4 are local
14:52:14 <cesc> Reading "Learn you a Haskell":     ""There must be a better way, you say! Well no, there isn't. Just kidding, there is. Hahaha!"    :are you kidding me:    xD
14:52:28 <james-ubc> or rather unassinged
14:52:34 <`Jake`> cesc: that really got me when I read it the first time
14:52:57 * hackagebot parsers 0.1 - Simple parsing combinators  http://hackage.haskell.org/package/parsers-0.1 (EdwardKmett)
14:53:12 <Urchin> those 12 IPs were assigned by a major accademic isp in my country
14:53:15 <cesc> `Jake`, it's a nice book though :)
14:53:40 <ocharles> edwardk: more parsers ey?
14:53:44 <hanDerPeder> hey, im trying to make sense of the code for lambdabot which uses a function called runWebReq which I cant seem to track down the definition of, how can I find it?
14:53:45 <`Jake`> cesc: the humor is part of that ;)
14:54:09 <DMcGill> hanDerPeder: have you tried hayoo?
14:54:12 <edwardk> ocharles: this basically packages up the combinators that are in trifecta for parsing that don't need all the trifecta guts
14:54:13 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
14:54:43 <MostAwesomeDude> edwardk: Am I about to have to rewrite all my trifecta code/ :3
14:54:49 <edwardk> MostAwesomeDude: soon =)
14:54:56 <edwardk> MostAwesomeDude: do you use the syntax highlighting functionality?
14:55:22 <hanDerPeder> DMcGill: thanks! can i infer from this that hayoo is more comprehensive than hoogle?
14:55:38 <DMcGill> it seems to cover more packages by default
14:56:00 <ocharles> edwardk: oh huh, i'd never heard of trifecta. looks neat
14:56:10 <hanDerPeder> ok, thanks a lot
14:56:31 <Philippa> ocharles: edwardk is one of the people I trust to have a good excuse to write another parsing lib :-)
14:56:41 <MostAwesomeDude> edwardk: Not yet, but at some point, I will.
14:56:45 <ocharles> Philippa: sure, was just curious about it
14:56:59 <MostAwesomeDude> I don't do the highlighting and language stuff because my language doesn't have traditional linguistic constructs.
14:57:13 <edwardk> i'm actually debating about if i want to port all the highlight tags into 'parsers' is why i ask
14:57:35 <Philippa> how does the highlighting stuff work currently?
14:57:43 <MostAwesomeDude> Whatever you feel would work best.
14:58:04 <Philippa> (it's the sort of thing that might help shift me into actually using the lib, but you know I mostly produce vapourware so take that for what it's worth)
14:58:22 <edwardk> Philippa: basically i have a highlight :: Highlight -> m a -> m a combinator in the MonadParser class that all the primitive parsers trifecta provides use
14:58:35 <edwardk> if your parser doesnt support it you can ignore it
14:58:48 <Philippa> *nod* - defaults to doing nowt, I assume
14:59:00 <edwardk> but the idea is that in the default parser trifecta provides it can build an interval map as it goes
14:59:08 <Philippa> *nod* cool
14:59:11 <edwardk> then i supported generating highlighted HTML off of that
14:59:29 <Philippa> how much work to port?
14:59:38 <edwardk> i just got done stripping that functionality out in parsers, but i'm willing to add it back in (or take a patch that does) =)
14:59:47 <edwardk> mostly just accepting the larger API
14:59:59 <Philippa> I *think* I still want a separate lexer, but it'd be enough to make me think twice about it
15:00:02 <edwardk> and copying about two dozen 'highlight Foo' tags
15:00:19 <edwardk> well, the nice thing is that 'parsers' doesn't prejudge how you lex, unlike trifecta
15:00:33 <edwardk> it doesn't give you any diagnostic support though
15:01:18 <edwardk> my thought was that by porting all the combinators out of trifecta into parsers, which is almost haskell 98 (it has existential quantification in the permutation parsers), i could simplify trifecta's api considerably
15:01:44 <edwardk> leaving it with just the job of dealing with diagnostics, preprocessing, layout, etc.
15:02:10 <edwardk> and enabling folks who just want a bunch of combinators for a different parsing backend to avoid bringing in the kitchen sink
15:04:05 <ocharles> hmm, I have a list of IO [a] actions ([IO [a]]) and I want an IO [a]. Is there a standard function for that? I thought msum, but there's MonadPlus IO instance
15:04:26 <mauke> :t liftM concat . sequence
15:04:27 <lambdabot> forall a (m :: * -> *). (Monad m) => [m [a]] -> m [a]
15:04:47 <ocharles> sure, i could write it myself by composing things
15:04:57 <ocharles> just wondered if there was a function in base that already did that
15:05:57 <mauke> @hoogle (Monad m) => [m [a]] -> m [a]
15:05:58 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
15:05:58 <lambdabot> Data.Foldable concat :: Foldable t => t [a] -> [a]
15:05:58 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
15:06:13 <mauke> that would be a no
15:06:18 <ocharles> yea, i searched there too
15:06:23 <ocharles> ok, onwards with actually doing something!
15:08:08 <MostAwesomeDude> Ugh, uniplate doesn't have peepholes.
15:08:31 <roconnor_> what's a peephole?
15:08:59 <MostAwesomeDude> It's a compiler thing. You have a list of expressions, and you want to find a certain pattern in the list and modify just that subsection of the list.
15:09:35 <MostAwesomeDude> So, say you had ADD X, 1; ADD X, 2; you might peephole that to ADD X, 3;
15:09:52 <MostAwesomeDude> And you'd do it by pattern-matching on ADD X i or something like that.
15:10:18 <roconnor_> MostAwesomeDude: why doesn't traverse let you do this?
15:10:21 <MostAwesomeDude> Uniplate doesn't appear to be super-skilled at dealing with data Expr = Expr [Expr] kind of types.
15:10:35 <roconnor_> er
15:10:40 * roconnor_ reviews uniplate
15:11:28 <MostAwesomeDude> There doesn't appear to be a traverse-ish function in uniplate. :c
15:16:10 <roconnor_> ya I see the problem
15:17:22 <MostAwesomeDude> I suppose I could write a thing that lets me slice out bits of lists, with a type like [Expr] -> [Expr], and then transform based on that.
15:17:56 <roconnor_> I guess you want to consider a Uniplate [Expr] and tranform f where f (Add X n:Add X m:tl) = (Add X (n + m) : tl) ; f x = x
15:17:59 * MostAwesomeDude wonders if ndm is secrely in here
15:18:06 <roconnor_> which is what you just said
15:18:21 <MostAwesomeDude> Yeah.
15:18:41 <MostAwesomeDude> I mean, uniplate *does* correctly see that I have [Expr]s in my types, and recurses into them correctly.
15:19:00 <roconnor_> right, but it won't normally let you see across the list
15:19:05 <MostAwesomeDude> But I suppose that special-casing list for recursive examination is just a little bit on the tough side for a generics library.
15:19:46 <JoeyA> mtl's functional dependencies mean I can't write two MonadState instances for the same monad (e.g. StateT S1 (State S2) a).  Is there a monad transformer library similar to mtl that doesn't have this restriction?
15:19:52 <MostAwesomeDude> I might just write a applyPeephole :: ([Expr] -> [Expr]) -> [Expr] -> [Expr]
15:19:57 <MostAwesomeDude> I did this in Python the same way.
15:19:59 <sipa> JoeyA: monatron
15:20:04 <JoeyA> Or should I just use plain transformers and write my own instance?
15:20:10 <JoeyA> sipa: Thanks, I'll look.
15:20:32 <sipa> it's not particularly easy to use, though :)
15:21:24 <JoeyA> I think I'll just write my own MonadState.  Thanks.
15:22:01 <Philippa> JoeyA: you can use tagging or similar?
15:22:20 <JoeyA> Philippa: What do you mean?
15:23:02 <Philippa> someone wrote a blog post and eventually a lib on hackage for attaching type-level tags to transformer layers and then addressing them via those tags
15:23:21 <Philippa> (I tend to just wrap the operations manually myself, but I don't claim to be doing large-scale engineering or anything)
15:25:05 <MostAwesomeDude> Waaaait. I'm over-thinking this.
15:25:26 <MostAwesomeDude> I could just foldr across the list, generating a new list behind me, and pattern-match out the peepholes.
15:25:49 <Philippa> heh. That sort of thing happens a lot
15:25:51 <roconnor_> I don't think foldr natively gives you this.
15:26:47 <roconnor_> Indeed, I also always wrap up my transformer stack as a new type and export a set of primitive operations.
15:26:51 <MostAwesomeDude> Hmm. Yeah, you're right. I'd have to write out the recursion myself.
15:26:59 <roconnor_> which is why I never understand all these monad transformer problems.
15:27:12 <roconnor_> ... and then I tend to delete the monad stack and hand fuse my own.
15:27:21 <roconnor_> once I'm happy with it
15:27:51 <roconnor_> http://r6.ca/blog/20071028T162529Z.html
15:28:03 <roconnor_> Hmm
15:28:04 <mauke> .oO( type-level rewrite rules? )
15:28:22 <roconnor_> looks like this was back when Ubuntu shipped MTL will optimizations off
15:28:43 <roconnor_> I guess things have changed in the last 5 years
15:29:42 <Dtgr> j27
15:29:54 <JoeyA> It's for a tiny little program.  I guess I'll just write separate classes for each of the two or three types of state I want to track.
15:30:19 <Eduard_Munteanu> adnauseam: yeah, you can't implement seq on your own, at least not without extra features, think of it as a language feature
15:31:05 <Eduard_Munteanu> adnauseam: it's like 'flip const' with additional semantics
15:39:51 <mparodi> Hello
15:39:57 <mparodi> what's the problem of http://paste.kde.org/506594 in Hugs?
15:40:57 <mauke> no extended defaulting
15:41:01 <mauke> try (1 :: Integer)
15:41:26 <mparodi> you're right
15:41:27 <mparodi> thank you
15:42:01 <geekosaur> it would be better not to use hugs; it's rather behind the curve on a lot of stuff these days, and ghci / winghci have long since caught up in terms of simple usability
15:43:38 <mauke> as evidenced by the above "friendly" error message
15:44:00 <edwardk> roconnor_: good writeup
15:44:57 <mparodi> I know but I don't have choice, it's an assignment supposed to be implemented using Hugs
15:51:47 <enko> is /= in haskell what != is in c?
15:52:20 <dschoepe> enko: Yes, but more polymorphic.
15:53:51 <enko> thx, i will research what u mean by more polymorphic later
15:53:54 <enko> :P
15:54:43 <S11001001> > Just 3 /= Just 5
15:54:44 <lambdabot>   True
15:55:25 <S11001001> > Just (const 3) /= Just (const 5)
15:55:27 <lambdabot>   *Exception: (==): No overloading for function
15:55:28 <dschoepe> enko: /= behaves differently for each type, according the type's Eq instance. (If you already know about type classes)
15:56:18 <S11001001> which is a compile-time thing, not sure why that hit bottom
15:56:33 <enko> > max 7 9
15:56:34 <lambdabot>   9
15:56:42 <S11001001> > max False True
15:56:43 <lambdabot>   True
15:56:53 <enko> :]
15:57:03 <S11001001> > max Nothing (Just "hi")
15:57:04 <lambdabot>   Just "hi"
15:57:19 <S11001001> yippee
15:57:30 <S11001001> from our trials
15:57:35 <S11001001> it's clear that max is a function
15:57:41 <S11001001> that answers its second argument
15:57:50 <MostAwesomeDude> > (fmap (+)) Nothing (Just "hi")
15:57:51 <lambdabot>   Couldn't match expected type `t -> a'
15:57:52 <lambdabot>         against inferred type `Data.M...
15:58:01 <MostAwesomeDude> Oh fine, be that way.
15:58:07 <MostAwesomeDude> > (fmap (++)) Nothing (Just "hi")
15:58:07 <lambdabot>   Couldn't match expected type `t -> a'
15:58:08 <lambdabot>         against inferred type `Data.M...
15:58:22 <S11001001> Nothing `mappend` Just "hi"
15:58:23 <S11001001> > Nothing `mappend` Just "hi"
15:58:25 <lambdabot>   Just "hi"
15:58:44 <MostAwesomeDude> Oh right, MonadPlus.
15:58:48 <S11001001> monoid
15:59:12 <S11001001> that wouldn't fit monadplus
15:59:16 <S11001001> > Nothing `mplus` Just "hi"
15:59:17 <lambdabot>   Just "hi"
15:59:19 <S11001001> what
15:59:28 <S11001001> oh, right
15:59:32 <S11001001> it's about >>=, not mplus
15:59:42 <MostAwesomeDude> Oh, I'm thinking of mplus, not mappend.
15:59:55 <S11001001> they are the same except when they're different
15:59:56 <MostAwesomeDude> But it doesn't matter because Maybe has all the instances.
16:00:16 <S11001001> the thing is that there are at least 3 ways you can get a monoid out of maybe
16:00:53 <S11001001> well, two
16:01:05 <MostAwesomeDude> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
16:01:30 <S11001001> > Sum 3 `mappend` Sum 65
16:01:31 <lambdabot>   Sum {getSum = 68}
16:03:23 <navaati> is it possible to write this :
16:03:23 <navaati> :t many1 $ satisfy $ \c ‚Üí all ($ c) [isAscii,isPrint,(`notElem` "[]")]
16:03:23 <navaati> in a prettyer way ?
16:03:25 <lambdabot> parse error (possibly incorrect indentation)
16:03:37 <navaati> :t many1 $ satisfy $ \c -> all ($ c) [isAscii,isPrint,(`notElem` "[]")]
16:03:39 <lambdabot> Not in scope: `many1'
16:03:39 <lambdabot> Not in scope: `satisfy'
16:04:15 <navaati> (no parsec in lambdabot ?)
16:08:59 <dzhus> what is the best way to log run time of different functions from inside of haskell code?
16:09:11 <hpc> dzhus: is this for debugging?
16:09:26 <dzhus> hpc: for benchmarking how long it takes to calculate each value
16:09:37 <hpc> ah, dunno
16:09:59 <hpc> if you feel like doing a massive breach of referential transparency, you can do
16:10:00 <aavogt> dzhus: you've looked into what ghc offers for profiling?
16:10:02 <hpc> @hoogle trace
16:10:02 <lambdabot> Debug.Trace module Debug.Trace
16:10:02 <lambdabot> Debug.Trace trace :: String -> a -> a
16:10:02 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
16:10:06 <hpc> @hoogle acme-now
16:10:06 <lambdabot> package acme-now
16:10:10 <dzhus> hpc: Assume I have v1, v2, v3 each calculated by f1(w1), f2(w2) and f3(w3). I want to know which of f1, f2, f3 takes most of time
16:10:13 <hpc> trace (show now) expr
16:10:24 <dzhus> hpc: yes, that's what I use now
16:10:40 <geekosaur> is criterion no longer the preferred benchmarking package?
16:11:15 <aavogt> with just a couple flags running your program will tell you what fraction of time was spent on f1, f2 etc.
16:11:53 <aavogt> but I don't think it's necessarily that clear about whether the time goes to evaluating f1(w1) or just evaluating w1
16:14:30 <hanDerPeder> anyway I can use JSON.Generic when the keys are not strings?
16:14:38 <dzhus> aavogt: is there difference when you're all strict?
16:19:21 <edwardk> Philippa: almost done adding highlighting support back into parsers turned out a little more elegant than in trifecta
16:19:27 <edwardk> not much but a little
16:22:16 <geekosaur> hanDerPeder, could you expand your question a bit?  the only thing I see tat is forced to String is JSON itself, being a serialization to strings
16:23:03 <hanDerPeder> geekosaur: sure, ill make a quick gist showing the problem
16:24:13 <geekosaur> oh, I see, alists have Strings hidden in them.  I think you'd have to recursively apply JSON encoding/decoding to the keys
16:24:35 <geekosaur> (since they *are* String and not JSString, this would appeatr to be implied)
16:25:21 <geekosaur> I would also suspect that generics figure into that somewhere
16:26:57 <hanDerPeder> https://gist.github.com/2980522
16:27:10 <hanDerPeder> hope that makes sense
16:27:45 <hanDerPeder> im getting a response that looks like 'what_is_returned'
16:27:58 <hanDerPeder> and since the keys are not strings, an exception is thrown
16:28:44 <hanDerPeder> I could just parse it myself, but hoping its a common enough problem that there is a widely used solution
16:30:43 <aavogt> dzhus: I dunno how profiling actually works. But the timings you get can still be useful
16:31:09 <loopt> Is GreenCard defunct?
16:31:17 <loopt> If yes, is there a replacement for it?
16:34:45 <hanDerPeder> geekosaur: any ideas?
16:42:16 <navaati> in Parsec, <|> enables to say OR, but how do i say AND ?
16:42:23 <coppro> >>=
16:42:53 <navaati> i tried it, but it consumes the input, which is no longer available for check by the next parser
16:43:50 <navaati> for example if i want a "satisfy isAscii" and "letter" at the same time
16:44:18 <donri> lookAhead
16:46:51 <donri> or, satisfy (\c -> isAscii c && isLetter c)
16:47:10 <geekosaur> hanDerPeder, how about you state your actual problem.   although, I can see this is going to take me out of my depth fairly quckly because I'm not very good at generics
16:47:48 <geekosaur> (The name "what_is_returned" suggests you got that from something else that you haven't shown)
16:49:23 <navaati> donri: thanks
16:49:26 <donri> actually, letter = satisfy isAlpha
16:49:54 <hanDerPeder> geekosaur: im trying to parse some json I get from a webservice (http://www.google.com/ig/calculator?hl=en&q=<somequery>) and it returns json where the keys are not strings
16:55:59 <donri> weird, that's not valid JSON
16:56:02 <donri> google should know better?
16:56:24 <iSIEMENS> :) ? what is the language on this site ---> IMPIRAT.COM
17:02:15 <geekosaur> donri, I'm not familiar enough with JSON to say for certain but I think it may be an oddity of the way that JSON package represents things; it's in line with the stuff in Text.JSON about JSObjects
17:02:19 <zachk> try adding this to your .ghci file, for a c interpreter from ghci, using the tiny c compiler:     :def c \x-> return $ ":!echo '" ++ x ++ "' | tcc -run -"
17:02:30 <geekosaur> there's a separate encoding mechanism for JSKey-s
17:03:45 <geekosaur> but, since I don't know what exactly is going on...
17:05:42 <nobdraisentone> http://hpaste.org/70364 I have some problem with scope of if's. Why `maybeNewTrack' is not in scope?
17:06:28 <adnauseam> for the maybe monad, would defining return as  return _ = Nothing, impact the monadic laws ?
17:06:32 <Cale> nobdraisentone: It's bound in the do-block, but you're trying to use it inside the 'where', which is outside the scope of that expression
17:07:12 <adnauseam> since for Just z >>= return i now get Nothing, rather than Just z, though it still holds for Nohting >>= return
17:07:25 <Cale> nobdraisentone: The 'where' is part of the declaration of 'servePlayer', and lies outside the scope of any guards on the lhs of the equations for it (but inside the scope of the pattern match)
17:07:56 <Cale> In this case, you have only one pattern and no guards, so it just scopes over the entire definition
17:08:13 <Cale> but that's still too broad in order to capture the value of maybeNewTrack
17:08:22 <nobdraisentone> Well, ok.
17:08:42 <nobdraisentone> Question is where should I put this `where'.
17:08:56 <Cale> You could use let inside the do-block
17:09:05 <Cale> fromJust is usually a bit scary though
17:09:16 <Cale> Probably what you really want is a case expression
17:09:17 <nobdraisentone> I remember
17:09:28 <Cale> to pattern match on the possible values of maybeNewTrack
17:09:39 <nobdraisentone> I use it only after check that is `isJust'
17:09:53 <Cale> Yeah, but pattern matching will make that more apparent
17:09:55 <shachaf> nobdraisentone: Don't do that. :-(
17:10:52 <navaati> is there somewhere a Map with an insert that fails when the jey already exist ?
17:10:59 <Cale> case maybeNewTrack of
17:11:01 <navaati> s/j/k/
17:11:07 <nobdraisentone> Uguu, that will be better
17:11:14 <nobdraisentone> Thanks for kinda review
17:11:22 <Cale>   Just new | old == new -> servePlayer c getPlayerInfo maybeNewTrack
17:11:38 <Cale>   _ -> do ...
17:12:21 <Cale> Also, this code will fail when maybeOldTrack = Nothing
17:12:40 <Cale> So you *really* ought to pattern match
17:13:01 <Cale> If you used pattern matching...
17:13:14 <Cale> servePlayer c getPlayerInfo (Just old) = do ...
17:13:25 <Cale> Then it would be more obvious that there's a missing case here
17:13:54 <shachaf> navaati: You can write it with Data.Map.alter
17:13:57 <Cale> It also makes the code shorter :)
17:14:17 <HugoDaniel> i want to do an ffi binding of a C++ library
17:14:20 <shachaf> Hmm, well, it won't fail.
17:14:21 <HugoDaniel> where can i read about that ?
17:14:57 <Cale> shachaf: What won't fail?
17:15:16 <navaati> :t alter
17:15:17 <shachaf> HugoDaniel: Step 1: Write a C binding for the C++ library. Step 2: Write a Haskell binding for the C library.
17:15:18 <lambdabot> Not in scope: `alter'
17:15:42 <shachaf> Cale: alter, when updating a Map where the key already exists.
17:15:48 <ghartshaw_> :pl ('(':) . f c t . (')':)
17:16:00 <HugoDaniel> shachaf: so extern C ?
17:16:06 <HugoDaniel> export
17:16:07 <HugoDaniel> *
17:16:08 <HugoDaniel> sorry
17:16:43 <shachaf> HugoDaniel: C++ is a complicated language that very few things other than C++ can directly interface with.
17:17:00 <navaati> is "very few" actually non-null ?
17:17:02 <shachaf> Fortunately it has a C FFI, and almost everything can interface with that.
17:17:07 <shachaf> navaati: Yes.
17:17:13 <shachaf> For example, C++ can directly interface with C++.
17:17:24 <shachaf> Er.
17:17:26 <navaati> ‚Ä¶ indeed
17:17:32 * shachaf is forgetful.
17:17:36 <shachaf> OK, D can interface with C++.
17:17:42 <navaati> non-null except C and C++ ?
17:17:53 <navaati> oh, D can do that ? cool
17:18:34 <HugoDaniel> yeah, cool
17:18:35 <HugoDaniel> thanks
17:18:59 <Optimight_> hi..I am here through webchat interface ...  this is my second visit
17:19:32 <Optimight_> Is there any way to reach here except webchat interface?
17:19:39 <HugoDaniel> ahah http://www.haskell.org/haskellwiki/IO_inside
17:19:42 <HugoDaniel> this seems really cool
17:19:53 <HugoDaniel> "After reading this text, you will receive a "Master of Haskell I/O" degree that is equal to a Bachelor in Computer Science and Mathematics, simultaneously. "
17:19:56 <HugoDaniel> :D
17:20:04 <parcs`> Optimight_: yes, with an irc client
17:20:25 <parcs`> that is not webchat :)
17:21:09 <Optimight_> parcs : which are the popular irc client ... I am using Ubuntu 12.04 LTS
17:21:20 <Azel> navaati: I beleive Java can interface with C++...and c
17:21:33 <Azel> err...I was saying C #
17:22:09 <shachaf> @google what irc client should i use in ubuntu?
17:22:13 <lambdabot> https://wiki.ubuntu.com/InternetRelayChat
17:22:25 <parcs`> Optimight_: xchat
17:22:44 <parcs`> or weechat if you like the console
17:23:13 <navaati> also, pidgin do IRC pretty well
17:23:35 <HugoDaniel> irssi is cool
17:23:55 <parcs`> weechat is better than irssi ;)
17:24:08 <nobdraisentone> Why?
17:24:57 <Optimight_> right now I am on xchat page    looking for how to install it on Ubuntu 12.4.LTS
17:25:02 <donri> Optimight_: smuxi, if you want something that integrates into the ubuntu desktop
17:25:24 <donri> Optimight_: to install any of these, open "Ubuntu Software Center"
17:26:14 <donri> you should see a "bag" icon to your left, normally
17:26:27 <Optimight_> donri : yes     looking there
17:27:34 <Optimight_> donri : a lot of names there at software center
17:27:57 <donri> Optimight_: it has a search field
17:28:42 <Optimight_> donri : I mean many irc clients ..
17:29:21 <donri> Optimight_: yes, i recommend smuxi
17:29:55 <Optimight_> donri : okay
17:30:20 <Optimight_> donri: let me check ..if it is available there
17:31:30 <Optimight_> donri: I am installing smuxi
17:33:46 <dmwit> ?messages
17:33:46 <lambdabot> roconnor_ said 13h 5m 43s ago: http://r6.ca/blog/20120623T104901Z.html
17:34:03 <dmwit> nice!
17:34:11 <Optimight_> donri : It is installed ...    wondering    how to start #haskel there?
17:35:17 <Optimight_> #haskell
17:35:49 <donri> Optimight_: I don't know and I don't have smuxi available... Look around the settings and menus?
17:39:20 <Optimight_> #haskell, #smuxi   are irc channels , right?
17:39:54 <hiptobecubic> Optimight_, You are talking on #haskell right now.
17:40:19 <hiptobecubic> Optimight_, or are you asking about the structure of IRC in general
17:41:17 <Optimight_> hiptobecubic_, I reached here from a webchat interface...    want to reach here through irc  client ..so it can be a permanent set up on my desktop
17:41:31 <hiptobecubic> Optimight_, ah ok
17:42:26 <geekosaur> not familiar with smuxi
17:42:26 <hiptobecubic> Optimight_, server is Freenode  (chat.freenode.net)  channel is #haskell
17:43:20 <Optimight_> hiptobecubic_, trying to find the way
17:43:42 <donri> Optimight_: I think by default it connects you to #smuxi on OFTC. that's a different network from this one.
17:44:12 <donri> perhaps you could ask in #smuxi that it connected you to, for help setting it up to join here
17:45:01 <YayMe> I might be misunderstanding attoparsec, but in my thought, a parser is the right thing for doing something like taking the string "/2.0/4.0" and returning me 2 floats
17:45:38 <YayMe> Is that not what a "parser" does so much as find fixed values?
17:45:44 <Optimight_> donri_  joined #haskell from there
17:46:01 <levi> That is generally the sort of thing parsers do, but you may not need a full-fledged parser for a simple task like that.
17:46:15 <donri> Optimight_: you might be on #haskell on OFTC, then. that's a different channel from this one
17:46:43 <donri> Optimight_: try /server chat.freenode.net, then /join #haskell
17:46:53 <donri> oh, i guess optim524 is you
17:46:57 <YayMe> levi: I could do it without a parser obviously, however it's partially because I'm new to this language and attoparsec appears to be an important portion of it
17:46:59 <donri> congrats then :)
17:47:13 <optim524> donri_, yes ...
17:47:17 <YayMe> so I'm trying to learn to use attoparsec, starting with what should be a simple task I believe
17:47:26 <optim524> donri_, thanks
17:47:30 <donri> actually there's two of you (well, three)
17:47:44 <donri> optim677 too
17:48:58 <donri> YayMe: why attoparsec and not parsec? anyway they are similar
17:49:03 <YayMe> so attoparsec can do it levi? and it should be a simplistic use of it, no?
17:49:31 <YayMe> donri: attoparsec I understand has basically replaced parsec due to performance from what I read, but I guess using either should be most similar to me as a developer
17:49:39 <br1> Criterion says "found 2 outliers among 1 samples (200.0%)" when running with cfgSamples = 1.  Is this a bug?
17:50:00 <donri> YayMe: attoparsec is also less powerful and produces less informative error messages
17:50:17 <donri> and parsec works with text/bytestring and applicative these days
17:50:57 <YayMe> donri: So perhaps doing development in parsec makes sense to get it stable and then doing a refactor to attoparsec after I get it doing what I want?
17:51:50 <donri> duno about that
17:52:36 <donri> for starters, do you actually need the performance of attoparsec vs parsec?
17:52:46 <donri> parsec is probably fast enough, for a lot of cases
17:53:09 <optimight> donri_, thanks for the guidance
17:53:20 <donri> people tend to overestimate their need for sheer performance, often at the cost of other important properties
17:53:25 <donri> optimight: no problem
17:54:03 <YayMe> The reason I'm learning haskell is the side-effectless manner making it capable of scaling like crazy and allowing continuations under the covers to do async IO without difficulty to me, moral of the story- largely I want haskell for performance reasons, so if everything I read says attoparsec vastly outperforms parsec, that's what I'll pay attention to
17:54:25 <optimight> donri_, my motive to come here is .. I begining to learn Functional Programming paradigm .. and in particular Haskell programming
17:54:42 <donri> optimight: aha, reading "learn you a haskell"?
17:54:59 <blackdog> YayMe: do you have a particular application area in mind, out of curiosity?
17:55:06 <donri> YayMe: aye. well, attoparsec should certainly be powerful enough to parse your example.
17:55:20 <optimight> donri_  yes ..haskell programming
17:55:32 <donri> @where lyah
17:55:33 <lambdabot> http://www.learnyouahaskell.com/
17:55:36 <donri> optimight: ^ that
17:56:21 <optimight> lambadabot_, thanks for the link
17:56:30 <YayMe> granted if performance was my only concern I would go to C or some such, but having been a developer in C# for the past hand full of years, I believe strongly in the benefits of rapid SAFE development that you will never find in a language where you must comb through every other line carefully to ensure you aren't trashing memory
17:56:38 <donri> YayMe: if you're parsing binary data however, you might want to look at "cereal" instead
17:57:27 <donri> although your example certainly looked textual or byte-oriented
17:58:33 <YayMe> blackdog: web services eventually. what I've learned has so far lead me to believe in reality all logic should live with a network interface to it which a UI can fiddle with. Even if it's instantiated directly without the service boundary, the service boundary adds immediate scalability to any properly stateless code
17:59:08 <YayMe> donri: actually, for the moment I'm parsing a URI which is in a Text format, but thanks for mentioning cereal, I haven't heard of it- I'll have to take a gander
17:59:55 <donri> YayMe: for that use case maybe look at web-routes
18:00:11 <blackdog> YayMe: well, perhaps not _every_ piece of logic - if every function call had to be a network access, you'd bog down pretty quickly :) but at the right level of granularity it makes sense.
18:00:35 <blackdog> i've been sort of thinking about writing a haskell binding for zerorpc - it would have been very helpful for my last startup
18:03:09 <donri> YayMe: in any case, your example should be something like, replicateM 2 (char '/' >> double)
18:03:14 <YayMe> blackdog: surely not every piece, but yes- you understand my sense here. I have studied SOLID for a good while now and found service boundaries, protocol irrelevant (memory mapped file, tcp with protobuf, whatever) is great at enforcing modularity. But the more I poke around at haskell the more I realize how exhausting OO can be in comparison..
18:03:17 <coppro> @hoogle <|>
18:03:18 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
18:03:18 <lambdabot> Text.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
18:03:18 <lambdabot> Text.ParserCombinators.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
18:04:25 <blackdog> YayMe: you're going to end up with some mutable state somewhere, but at least with haskell it's restricted to higher-level interfaces
18:04:49 <blackdog> YayMe: btw, is this a personal project for learning, or a commercial gig, or a startup... ?
18:04:55 <YayMe> learning
18:05:22 <mparodi> @hoogle Ordering
18:05:22 <lambdabot> Prelude data Ordering :: *
18:05:22 <lambdabot> Data.Ord data Ordering :: *
18:05:22 <lambdabot> package COrdering
18:05:27 <YayMe> like I said, I been doing C# for years and working hard to use SOLID right, and haskell just seems like the logical next step from what I've seen
18:05:36 <hanDerPeder> soo, parsec parser won't compile if you have combinators that aren't referenced.. thats quite the gotcha
18:05:46 <coppro> I have a parser which returns (Maybe (Either Foo Bar)); is there a better way to express this?
18:05:57 <donri> hanDerPeder: "referenced"? do you mean imported?
18:06:24 <hanDerPeder> no, I mean only defined, not used
18:06:45 <hanDerPeder> or am I missing something?
18:06:48 <blackdog> coppro: well, what semantics do you want? Is it a sane result to get Nothing out of that?
18:07:08 <donri> hanDerPeder: it should compile fine without using them. but if you need them to be used in parsing, you need to make your top parser alternate them
18:07:21 <YayMe> blackdog: yeah, mutable somewhere- but haskell makes it ultra clear where. Moreover, am I wrong to understand as I'm learning the functional paradigm, the big idea is that your mutability and state is just stack bound most the time
18:07:48 <navaati> isn't there a parser that has only an Applicative expressive power, not a Monadic one, but that would be more efficient than parsec/attoparsec ?
18:07:58 <YayMe> the accumulator pattern gives me this idea that you just walk up and down your stack transform the parameters to functions to express state
18:08:03 * hackagebot Homology 0.1 - Compute the homology of a chain complex  http://hackage.haskell.org/package/Homology-0.1 (DamekDavis)
18:08:21 <mparodi> can I use patters in lambdas?
18:08:25 <YayMe> is that a somewhat accurate understanding of good functional design, or is that bad functional design?
18:08:32 <Eduard_Munteanu> mparodi: yes
18:08:33 <blackdog> YayMe: yeah, that's prett much it - your state is scoped as tightly as possible.
18:08:37 <mparodi> \x | x == 1 = '1' | otherwise = 'a'
18:08:39 <mparodi> ?
18:08:41 <coppro> blackdog: Well really it returns a Foo, a Bar, or nothing
18:08:42 <navaati> mparodi: yeah, but beware of partial functions it may give you
18:08:50 <Eduard_Munteanu> mparodi: nah, that doesn't work
18:08:53 <blackdog> and because it can't escape, it can't screw you on concurrent access
18:08:54 <coppro> I'm just wondering if Maybe (Either) is the best expression of this
18:08:56 <mparodi> Eduard_Munteanu, then how?
18:08:59 <coppro> (I could create a custom datatype too)
18:09:03 <navaati> mparodi: this is a guard, not a pattern
18:09:09 <Eduard_Munteanu> > (\(Just x) -> x + 1) Just 5
18:09:10 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe (t -> t1)'
18:09:10 <lambdabot>         against i...
18:09:10 <mparodi> ahm, ok, I meant a guard :P
18:09:12 <hanDerPeder> donri: example, https://gist.github.com/2980866
18:09:19 <Eduard_Munteanu> > (\(Just x) -> x + 1) (Just 5)
18:09:19 <lambdabot>   6
18:09:35 <mparodi> can I use guards in lambdas?
18:09:37 <Eduard_Munteanu> Then no.
18:09:41 <blackdog> coppro: if they're all reasonable results, then that structure is fine. you'll get a few helpful things from casting it in Maybe and Either like monad instances & convenience functions etc
18:09:56 <Eduard_Munteanu> You can add a case expression though.
18:10:01 <mparodi> how?
18:10:02 <coppro> blackdog: yeah
18:10:11 <coppro> I may end up with my own type anyway
18:10:28 <Eduard_Munteanu> case () of () | x == 1 ...
18:10:47 <mparodi> but I need to compare two parameters actually
18:11:02 <Eduard_Munteanu> \x y -> ...
18:11:23 <Eduard_Munteanu> You could use a proper case then.
18:11:31 <mparodi> \x y -> case (...) of | x < y -> ... | x > y -> ... | otherwise -> ...
18:11:38 <blackdog> YayMe: you may find it instructive to go through the xmonad paper - it's a good example for how you can restrict IO and mutable update to the very outer shell of your program, and use functional verification techniques for testing your business logic.
18:11:38 <mparodi> I don't think it's possible
18:11:43 <ion> handerpeder: You can just import Text.Parsec. Also, mah = char '{' *> li <* char '}'
18:12:06 <Eduard_Munteanu> mparodi: case compare x y
18:12:28 <hanDerPeder> ion: thanks, but thats a bit above my level of comprehension atm
18:12:39 <mparodi> ah, nice
18:12:41 <mparodi> thanks
18:12:44 <hanDerPeder> just started learning parsec a few hours ago
18:12:51 <Eduard_Munteanu> :t compare
18:12:52 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
18:12:55 <Eduard_Munteanu> @src Ordering
18:12:55 <lambdabot> data Ordering = LT | EQ | GT
18:13:41 <ion> handerpeder: That applies to all code. ‚Äúdo foo; a <- bar; baz; return a‚Äù is equivalent to ‚Äúfoo *> bar <* baz‚Äù.
18:14:23 <hanDerPeder> ion: nice! where is it defined?
18:14:35 <ion> handerpeder: Control.Applicative
18:15:25 <donri> hanDerPeder: not sure why the eol definition makes it not compile though, could be the lack of type signatures
18:16:13 <solrize> Data.MemoTrie is about 2x faster than Data.MemoCombinators
18:16:45 <coppro> @hoogle (Monad m) => m [a] -> m [a] -> m [a]
18:16:46 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
18:16:46 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
18:16:46 <lambdabot> Control.Concurrent mergeIO :: [a] -> [a] -> IO [a]
18:17:03 <coppro> ... that last one doesn't even match
18:17:08 <hanDerPeder> donri: probably something like that, thanks for taking a look!
18:17:36 <donri> coppro: sure it does, [] is a Monad m
18:17:48 <donri> and [a] is an a
18:17:55 <rwbarton> none of them match
18:18:03 * hackagebot Homology 0.1.1 - Compute the homology of a chain complex  http://hackage.haskell.org/package/Homology-0.1.1 (DamekDavis)
18:18:24 <YayMe> blackdog: yeah, I kind of figured that's the idea- keep the mutability to the absolute exterior layer, in my OO designs I tend to design a thin boundary layer to each section of a system which usually acts as a simplistic flat translation between customized internal data types and the contract agreed upon data objects, I'm guessing in functional that's where I would do my mutability
18:18:29 <donri> well ok, it doesn't match because IO and [] are different m's
18:18:46 <donri> but hoogle isn't very strict in its matching, i think?
18:19:20 <hanDerPeder> in parsec, how can I 'throw away' a character?
18:19:44 <rwbarton> char, i think?
18:20:04 <coppro> donri: sure
18:20:08 <donri> hanDerPeder: char combined with >> or <* or *>
18:20:14 <coppro> donri: yeah, IO and [] are different
18:20:22 <ion> coppro: liftA2 (++)?
18:20:31 <coppro> ion: probably
18:20:57 <YayMe> Can someone walk me through this: replicateM 2 (char '/' >> double)
18:21:04 <YayMe> namely, what precisely is the >> doing?
18:21:09 <donri> YayMe: "and"
18:21:20 <YayMe> what is "double" ? a function?
18:21:29 <donri> a combinator parsing a double
18:21:33 <hanDerPeder> donri: but then I need to know exactly when and where its coming right? is there a way to make it optional?
18:21:40 <blackdog> YayMe: yes, exactly. http://www.scribd.com/doc/19503176/The-Design-and-Implementation-of-xmonad goes into a bit more depth.
18:21:43 <Eduard_Munteanu> YayMe: f >> g = f >>= \_ -> g
18:22:11 <hanDerPeder> nevermind, <|>..
18:22:20 <strager> I'm writing a Parsec lexer/parser combo.  I have the problem of parsing '>>' (and some other cases) differently in different situations.  E.g. a<b<c>> should be parsed as [a, <, b, <, c, >, >], but a>>b should be parsed as [a, >>, b].
18:22:30 <donri> parsing without knowing where things goes sounds like fun
18:22:52 <hanDerPeder> donri: lol, indeed
18:23:10 <strager> I have considered the approach of, in the parser, if I see '>>' where I expect '>', I can read the '>>' and push '>' back into the stream.  It doesn't seem Parsec allows this; am I looking in the wrong direction?
18:23:15 <ion> yayme: That‚Äôs equal to do _ <- char '/'; a <- double; _ <- char '/'; b <- double; return [a, b]
18:23:24 <Eduard_Munteanu> YayMe: are you familiar to monads?
18:23:47 <donri> strager: maybe lookAhead or notFollowedBy
18:24:15 <Eduard_Munteanu> s/to/with/
18:24:15 <YayMe> Eduard_Munteanu: Unfortunately I have been partially avoiding the details of them, I understand that you need to bind to them to pull out their value, but details beyond that I have been procrastinating reading
18:24:20 <coppro> @hoogle symbol
18:24:20 <lambdabot> Text.Read.Lex Symbol :: String -> Lexeme
18:24:21 <lambdabot> Text.Read Symbol :: String -> Lexeme
18:24:21 <lambdabot> Text.Parsec.Token symbol :: GenTokenParser s u m -> String -> ParsecT s u m String
18:24:27 <coppro> ah, I see
18:24:35 * coppro smacks attoparsec
18:25:02 <Eduard_Munteanu> :t (>>=)
18:25:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:25:04 <Eduard_Munteanu> :t (>>)
18:25:05 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
18:25:32 <strager> donri: I have a separate lexer pass, which treats >> as >.  Maybe I can always parse > separately, and when I want '>>' I just say I want two '>'s?  Then I'd need to keep track of whitespace...  (This is a C++-like language I'm parsing.)
18:25:39 <YayMe> Eduard_Munteanu: I'm trying to put off monad's because I feel like they're the big reveal, and the more I try to learn without them the more I will learn the ins and outs what not using them which is what you want to do more of anyway (I believe?)
18:26:06 <ion> ‡≤†_‡≤†
18:26:14 <YayMe> shutup ion :)
18:26:20 <YayMe> heh
18:26:33 <donri> strager: not sure you should lex those at all?
18:26:46 <donri> looks like they're structural
18:27:01 <blackdog> YayMe: probably learnyouahaskell does the best job there - you can see the tower of abstraction from Functor to Applicative to Monad
18:27:10 <strager> Wait, why did I say 'treats >> as >' ?
18:27:18 <donri> @where lyah
18:27:18 <lambdabot> http://www.learnyouahaskell.com/
18:27:20 <donri> @where typeclassopedia
18:27:21 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
18:27:25 <donri> YayMe: ^ starting points
18:27:26 <YayMe> blackdog: yeah, I'm basically at the monad chapter in it having read everything else, but like I said- procrastinating reading that chapter
18:27:27 <strager> That makes no sense...  My lexer treats >> as one token.
18:27:45 <donri> @where rwh
18:27:46 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
18:27:51 <strager> YayMe: You should learn monads and procrastinate on arrows.
18:27:55 <donri> YayMe: ^ also has a chapter on parsec, which is very similar to attoparsec
18:28:40 <Eduard_Munteanu> YayMe: it's not that bad really. You can treat monads as some sort of general API, and perhaps if you use them for a while it will get easier to grok the internals when you study them.
18:29:30 <Eduard_Munteanu> YayMe: play with e.g. State for a bit, then try implementing your own.
18:29:41 <YayMe> Eduard_Munteanu: I have no concern with the difficulty of understanding them, I'm rather procrastinating because if I learn monads without practicing no-monads more I'll overuse monads, which I think can be very bad practice since they're the interface to side effects (I think?)
18:30:08 <ion> ‡≤†_‡≤†
18:30:14 <blackdog> ion smash!
18:30:16 <Eduard_Munteanu> Not really.
18:30:32 <strager> There's some truth to that, but it all comes down to experience, not exposure, I think.
18:30:57 <Eduard_Munteanu> Apart from IO and ST, they don't really give you any real side effects.
18:31:07 <YayMe> strager: and I have ~3 weeks exposure to haskell so my experience level will be slight heh
18:31:12 <donri> remember that what happens with "x" in (x >>= y) depends both on the "y" and the monad instance of "x" (aka., the definition of (>>=) for the type of "x")
18:31:31 <Eduard_Munteanu> And the inconvenience of overusing them will be quite apparent when you could do with a normal function, for example.
18:31:38 <donri> at least personally, i kept neglecting to consider that which made me confused about how certain monads "could even work"
18:32:30 <ion> > do n <- [3,4,5]; [n, -n]
18:32:31 <lambdabot>   [3,-3,4,-4,5,-5]
18:33:00 <YayMe> ok yeah wtf on that
18:33:12 <donri> wtf on what?
18:33:25 <strager> > [3,4,5] >>= \n -> [n, -n]
18:33:26 <lambdabot>   [3,-3,4,-4,5,-5]
18:33:32 <dmwit> > concatMap (\x -> [x, -x]) [3,4,5]
18:33:33 <lambdabot>   [3,-3,4,-4,5,-5]
18:33:34 <strager> @pl [3,4,5] >>= \n -> [n, -n]
18:33:35 <lambdabot> (line 1, column 19):
18:33:35 <lambdabot> unexpected "["
18:33:35 <lambdabot> expecting lambda abstraction or expression
18:33:41 <strager> @pl ([3,4,5] >>= \n -> [n, -n])
18:33:42 <lambdabot> (line 1, column 20):
18:33:42 <lambdabot> unexpected "["
18:33:42 <lambdabot> expecting lambda abstraction or expression
18:33:48 <Eduard_Munteanu> @undo do {n <- [3,4,5]; [n, -n]}
18:33:48 <lambdabot> [3, 4, 5] >>= \ n -> [n, - n]
18:33:54 <dmwit> > concat (map (\x -> [x, -x]) [3,4,5]) -- stop me when we've erased enough abstraction layers that you understand the code
18:33:55 <lambdabot>   [3,-3,4,-4,5,-5]
18:33:58 <ion> > map (\n -> [n, -n]) [3,4,5]
18:33:59 <lambdabot>   [[3,-3],[4,-4],[5,-5]]
18:34:07 <donri> > concat [[n,-n] | n <- [3,4,5]]
18:34:09 <lambdabot>   [3,-3,4,-4,5,-5]
18:34:26 <dmwit> Don't use concat with list comprehensions.
18:34:26 <strager> > [3,-3,4,-4,5,-6]
18:34:27 <lambdabot>   [3,-3,4,-4,5,-6]
18:34:33 <YayMe> strager: your way makes more sense. I see why people use >>= instead of <- in the code I've been reading
18:34:50 <dmwit> > [x | n <- [3,4,5], x <- [-n, n]] -- donri
18:34:51 <lambdabot>   [-3,3,-4,4,-5,5]
18:34:53 <strager> YayMe: Yeah; for a one-liner, do often is confusing.
18:34:54 <blackdog> YayMe: syntactic sugar gives you cancer of the semicolon...
18:34:59 <donri> ah yea
18:35:05 <Eduard_Munteanu> @undo do { x <- f a; g x }
18:35:05 <lambdabot> f a >>= \ x -> g x
18:35:30 <donri> @where do
18:35:30 <lambdabot> http://www.haskell.org/haskellwiki/Do_notation_considered_harmful
18:36:08 <YayMe> blackdog: iduno, honestly- the pattern matching which is sugar for a case, seems so much cleaner to my eyes having spent years digging through nested ifs and cases and such in C#
18:36:48 <donri> 'case' does pattern matching too
18:36:52 <YayMe> blackdog: every time I want to do a case I have half a mind to write a new function altogether just to use a pattern match instead of an in function case
18:36:58 <dmwit> Haskell has very tasteful sugar, I think.
18:37:04 <blackdog> YayMe: yes, that's true. I think you eventually end up not using a heap of explicit patternmatching, though - more about combinators
18:37:08 <donri> dmwit: it tastes like sugar?
18:37:16 <dmwit> yes =)
18:37:48 <donri> whereas c# tastes somewhat like coffee
18:38:22 <strager> Nah; C# is orange juice.
18:38:26 <YayMe> donri: sounds about right considering the amount of effing coffee all of us who write it drink heh
18:38:55 <donri> also, mathematicians are machines for converting coffee into theorems
18:39:05 <donri> (but my joke was in reference to its java heritage)
18:39:08 <YayMe> don't get me wrong, I have loved C# for years now, but haskell is actively seducing me right now
18:39:14 <strager> YayMe: For parsers, don't think monads, think alternatives and applicatives.
18:39:39 <donri> YayMe: http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044101.html
18:40:40 <dmwit> For parsers, think parsers, and recognize in them monads, alternatives, applicatives, monoidal functors, etc. when they are such things.
18:40:42 <YayMe> strager: yeah, for parser stuff I imagine there's only necessity for monads on the absolute boundary where you stream the data in, functional design from what I see is great for doing all the types of things like algorithms to parse data as soon as you get it out of it's impure state
18:40:53 <dmwit> Monads are never necessary.
18:41:13 <dmwit> Monads are a shorthand for saying that a particular data structure has a particular set of operations.
18:42:05 <YayMe> ironically at work I got a lesson from a fellow who I've been tutoring in .net for the past 2 years on monad's because he has an math degree
18:42:13 <YayMe> his explanation really helped surprisingly
18:42:16 <dmwit> Such shorthand is critical for experts: the brain can only hold a few chunks at a time, so bigger chunks are better for experts.
18:42:18 <YayMe> even though he knew nothing about the language
18:42:25 <Eduard_Munteanu> Heh.
18:42:39 <YayMe> the type system makes a lot more sense after what he explained to me (granted it took him about 2 hours to go over the subject matter)
18:43:31 <ion> For some operations in parsers applicatives aren‚Äôt enough and you do need monads (say, parse a number n followed by a number of characters dictated by n), but mostly applicatives are powerful enough.
18:43:46 <blackdog> 'sfunny - i know a few mathematicians who program, and in general they seem to think about code as something you just kind of grind away on - it's not really meant to be a one-to-one mapping from thought to code.
18:43:50 <blackdog> admittedly they hack C.
18:43:54 <Eduard_Munteanu> Though I do wonder how much category theory is involved in a normal math degree.
18:44:53 <strager> ion: pssh; just write one parser per combination.
18:45:08 <YayMe> everywhere I read about haskell stuff that mentions monads or the type system tends to say "it's based on complex math theorems that you don't need to know" and skips over giving the actual math explanations- but from what I got out of the fella I work with, I think the math concepts shouldn't have been skipped
18:45:21 <strager> string "1 " *> a ;  string "2 " *> a *> a ;  ...
18:45:27 <ion> yayme: Monads don‚Äôt intrinsically have anything to do with impurity and they‚Äôre not the opposite of ‚Äúfunctional‚Äù.
18:45:50 <donri> YayMe: read the typeclassopedia and do the exercises
18:45:54 <YayMe> ion: are they not the method which haskell uses to be mutable?
18:46:11 <donri> nope
18:46:23 <strager> IO makes Haskell have side effects, not monads
18:46:27 <YayMe> ah
18:46:31 <YayMe> is it IO alone?
18:46:39 <donri> i just realized your name is likely "jamie"
18:46:40 <YayMe> (and ST someone mentioned)
18:46:58 <YayMe> no, it's more like "Happy birthday to me!" :)
18:47:12 <strager> IO's the only one I know of
18:47:25 <strager> And IO happens to be a monad because that's convenient.
18:47:27 <YayMe> also, what is it called, FFI ? the interop layer
18:47:33 <donri> YayMe: it's more that the monad instance for IO can be used to describe how to sequence IO actions, and then the runtime can interpret that definition
18:47:37 <donri> @where io
18:47:38 <lambdabot> Raphael L. Levien's language with continuations as fundamental structure, described in his paper "Io: a new programming notation" (1989-09-10) at <http://dl.acm.org/citation.cfm?id=70931.70934> and
18:47:38 <lambdabot> in chapter 2 of Raphael A. Finkel's book `APLD', implementations `Amalthea',`Ganymede'
18:47:38 <dmwit> FFI code is marked with IO.
18:47:50 <donri> @where io-introduction
18:47:50 <lambdabot> I know nothing about io-introduction.
18:47:54 <dmwit> Any monad transformer stack with IO at the bottom can have side effects.
18:47:57 <Eduard_Munteanu> You get true side-effects only in IO. ST gets you mutable cells, which are kinda side-effects.
18:47:58 <donri> @where io-intro
18:47:58 <lambdabot> I know nothing about io-intro.
18:48:04 <dmwit> So, no, not only IO.
18:48:04 <donri> i'm sure i added that somewhere
18:48:28 <YayMe> Well that clears that up
18:48:29 <donri> @where+ io http://www.haskell.org/haskellwiki/Introduction_to_IO
18:48:29 <lambdabot> It is stored.
18:48:31 <strager> dmwit: That doesn't make it *not* IO; that's just wrapping it.
18:48:40 <YayMe> then I do need to really learn monads
18:49:01 <ion> But learn functors and applicative functors first.
18:49:37 <YayMe> yeah, I made it through the functors chapter in LYAH
18:49:44 <YayMe> I'm halfway through the applicative functors chapter
18:49:45 <donri> YayMe: also note that while IO is a monad, it's not *just* a monad. for example, you can do some IO with applicative
18:50:06 <ion> IO is also a functor.
18:50:16 <donri> implied by being applicative ;)
18:50:37 <ion> ‚Ä¶and by being a monad, except that the typeclasses are broken. ;-)
18:51:09 <strager> ;P
18:51:21 <dmwit> This kind of discussion is why I distinguish between functor and Functor.
18:51:22 <YayMe> the one pain point I'm having in learning haskell is that there are a lot of things which are extremely similar
18:51:33 <YayMe> and can be used in place of eachother for lots of places
18:51:45 <dmwit> IO is a functor, and this is implied by the statement "IO is a monad".
18:51:55 <YayMe> coming from .NET which has an extremely rich definition of best practices
18:51:59 <dmwit> IO is a Functor, even though this is not implied by the statement "IO is a Monad".
18:52:04 <YayMe> but whatever, I'll just have to get over that with practice
18:52:35 <donri> ion: well, http://www.haskell.org/pipermail/haskell-prime/2011-January/003312.html
18:53:40 <ion> yayme: Can you give an example of which similar things are a pain?
18:54:00 <YayMe> not a pain, just as someone learning it makes it hard to know which to use
18:54:20 <YayMe> let vs where is the first one- like I said though; similar, not the same.
18:54:37 <YayMe> I recognize the difference between them, but often scenarios I can use either
18:54:59 <YayMe> the scenario where I'm cornered into one vs the other is the minority
18:55:31 <dmwit> Use where unless you can't use where.
18:55:33 <dmwit> That's what I do.
18:55:42 <YayMe> but there are other things like that, often times you can use $ or .
18:55:44 <ion> donri: Well‚Ä¶ you can have the correct dependency *and* define fmap in terms of the monad.
18:55:53 <dmwit> Use . unless you can't use .. That's what I do.
18:55:54 <donri> YayMe: http://www.haskell.org/haskellwiki/Expression_style
18:55:57 <YayMe> dmwit: though I read somewhere let may actually be more performant
18:56:11 <dmwit> This is my skeptical face.
18:56:13 <YayMe> because it's got a tighter scope
18:56:39 <blackdog> any let can be translated into an exactly equivalent where.
18:56:55 <YayMe> blackdog: but the opposite isn't always the case, no?
18:57:04 <dmwit> blackdog: that doesn't sound right
18:57:06 <shachaf> blackdog: No, the other way around, I think.
18:57:23 <shachaf> Well, even that isn't quite right.
18:57:26 <dmwit> > if True then let x = 5 in x else 6
18:57:27 <lambdabot>   5
18:57:28 <YayMe> where has access to a larger scope of variables than let
18:57:33 <YayMe> no?
18:57:38 <dmwit> blackdog: translate that, please
18:57:57 <blackdog> really? how are they not equivalent? you can have local where definitions too..
18:57:57 <dmwit> YayMe: Scope is not related to the difference between let and where.
18:58:19 <shachaf> blackdog: "let ... in ..." is an expression.
18:58:20 <ion> How many things you have in scope also doesn‚Äôt affect performance.
18:58:23 <dmwit> YayMe: "let ... in ..." is an expression; "where" may only be attached to definitions.
18:58:28 <shachaf> You can only use "where" when you have an "=".
18:59:15 <shachaf> dmwit: whoa, dude
18:59:22 * dmwit high fives shachaf
18:59:37 <blackdog> dmwit: i've learned something :) cheers!
18:59:38 <YayMe> right, my point is, they are different but when to use which isn't made clear. that's relatively trivial though as I believe most times people probably go with exactly what was said here, just use where (except perhaps inside of do statements sometimes)
18:59:43 <ion> shachaf only has four fingers, you insensitive clod!
18:59:55 <shachaf> ion: I have eight fingers. :-(
19:00:08 * ion high eights shachaf
19:00:12 <Eduard_Munteanu> 'where' is nicer sometimes, stays out of the way
19:00:26 <shachaf> ion: You're such a h8r.
19:00:32 <Eduard_Munteanu> e.g. f x = g x 2   where g = ...
19:01:02 <shachaf> YayMe: "where is more efficient" is silly -- it's just a syntax thing.
19:01:09 <donri> let's not talk about (=<<), or how liftM is kinda-sorta liftA is kinda-sorta fmap or how the last one is also (<$>)
19:01:20 <shachaf> But some cases where you use "where" might end up being more efficient because of scope things.
19:01:32 <YayMe> shachaf: I'll dig up the reference that gave me belief let may sometimes be more efficient...
19:01:36 <blackdog> shachaf: i'd love to see an example
19:01:45 <shachaf> foo x = \y -> y + z where z = expensive x
19:01:59 <shachaf> Of course, you could do that with "let" too.
19:02:10 <donri> YayMe: sounds like that programmer who wrote code without any whitespace (including no newlines) claiming it was "more efficient"
19:02:27 <YayMe> @Roman: No, GHC's escape analysis only applies to local let-bindings. There is no interprocedural analysis going on. For your example, you'd need to statically ensure that there is no other pointer anywhere in the heap that points to x or any of its successors. You'd need linear or uniqueness types to prove something like that. ‚Äì nominolo Feb 27 '11 at 14:00
19:02:28 <lambdabot> Unknown command, try @list
19:02:32 <ion> A where clause attached to a definition is also shared across guards in the definition.
19:02:34 <YayMe> from: http://stackoverflow.com/questions/5132350/how-do-haskell-compilers-decide-whether-to-allocate-on-the-heap-or-the-stack
19:02:44 <shachaf> ion: Oh, guards, yes, that's the example I was thinking of a little while ago.
19:03:14 <YayMe> ion: that's what I was referring to regarding scope, and in that fact the let mechanism allows a more guaranteed scope to the compiler
19:03:25 <blackdog> YayMe: in that context, "let-bindings" includes where statements.
19:03:38 <YayMe> blackdog: oh, interesting.
19:03:57 <shachaf> That question's URL doesn't look promisin.g
19:04:06 <blackdog> YayMe: if you're interested in the nitty gritty of it, it may be instructive to come up with a toy example and see what Core gets created
19:05:29 <ion> > let f x  | x == 0 = y  | otherwise = z  where { y = "zero"; z = "nonzero" } in (f 0, f 42)
19:05:30 <lambdabot>   ("zero","nonzero")
19:05:44 <coppro> is there an automatic source code formatter?
19:06:13 <ion> coppro: stylish-haskell does some formatting.
19:06:40 <ion> coppro: And hlint can give nice hints.
19:07:03 <donri> and haskell-src-exts can pretty-print, although often it's less pretty than the source
19:07:56 <YayMe> blackdog: I am, eventually though. I've been profiling and digging at the nitty gritty (much as my untrained brain can) in C# for past few years, and have a hard time ignoring these things now even though I don't understand haskell anywhere near at such a level
19:08:40 <coppro> ion: thanks
19:08:52 <blackdog> YayMe: definitely check out the profiling chapter in RWH, then. while it may not usually be tremendously important, it does give a pleasant jolt when you work out exactly what's going on.
19:09:52 <dmwit> YayMe: I don't see anything on that page that talks about let and where being different at all, let alone suggesting one is more efficient than the other.
19:10:24 <dmwit> It does say that let can be more efficient than having no let, but then, where can be more efficient than having no where.
19:10:30 <YayMe> dmwit: they refer to let bindings, I didn't realize they could have meant both let and where as was pointed out to me. I'm just in over my head on haskell regarding these topics.
19:13:18 <coppro> @hoogle [Char -> Bool] -> Char -> Bool
19:13:18 <lambdabot> Data.Foldable all :: Foldable t => (a -> Bool) -> t a -> Bool
19:13:18 <lambdabot> Data.Foldable any :: Foldable t => (a -> Bool) -> t a -> Bool
19:13:18 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
19:13:42 <coppro> ...
19:13:50 <coppro> those are all simply /wrong/
19:14:30 <YayMe> blackdog: yeah, same thing happened to me in C# learning what is actually happening really changed the way I go about some of it. Made me wish I had studied a lot of the guts earlier in C# than I did, and now I have a hard time not noticing those things in haskell even though I don't understand the haskell terminology even yet
19:14:40 <coppro> am I a bad person to do (||) <$> isDigit <*> isLetter ?
19:14:52 <YayMe> The terminology I see throughout haskell stuff is soooo far removed from what I'm familiar with
19:16:20 <jaredc> coppro why not, isDigit <^(||)^> isLetter instead ;)
19:18:14 <Veinor> coppro: myFunc preds x = all ($ x) preds
19:18:22 <Veinor> @type \preds x -> all ($ x) preds
19:18:23 <lambdabot> forall a. [a -> Bool] -> a -> Bool
19:18:29 <dmwit> ?hoogle Monoid m => [a -> m] -> a -> m
19:18:30 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
19:18:30 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
19:18:30 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
19:18:57 <dmwit> anyway... mconcat
19:19:23 <Veinor> dmyeah, but then you've got to faff around with wrapping/unwrapping the Bool in Any/All
19:19:42 <dmwit> > mconcat [Any . isDigit, Any . isSpace] '2'
19:19:44 <lambdabot>   Any {getAny = True}
19:19:51 <dmwit> yep
19:20:01 <donri> edwardk: is "parsers" meant as a future dependency of trifecta?
19:20:10 <dmwit> :t getAny . mconcat . map (Any .)
19:20:11 <lambdabot>     Couldn't match expected type `Any' against inferred type `f Any'
19:20:11 <lambdabot>     In the first argument of `map', namely `(Any .)'
19:20:11 <lambdabot>     In the second argument of `(.)', namely `map (Any .)'
19:20:14 <blackdog> YayMe: the thing to remember is that while we've got a bit of a monoculture in practice with GHC, the semantics of Haskell are not defined by GHC's behaviour
19:20:23 <dmwit> oh
19:20:31 <dmwit> :t (getAny .) . mconcat . map (Any .)
19:20:32 <lambdabot> forall (f :: * -> *). (Functor f, Monoid (f Any)) => [f Bool] -> f Bool
19:20:41 <blackdog> so it may not always make sense to talk about what's "really" happening
19:21:19 <dmwit> :t \fs -> any . sequences fs
19:21:19 <lambdabot> Not in scope: `sequences'
19:21:24 <dmwit> :t \fs -> any . sequence fs
19:21:25 <lambdabot>     Couldn't match expected type `a -> Bool'
19:21:25 <lambdabot>            against inferred type `[a1]'
19:21:25 <lambdabot>       Expected type: f (a -> Bool)
19:21:34 <dmwit> :t \fs -> or . sequence fs
19:21:35 <lambdabot> forall (f :: * -> *). (Monad f, Functor f) => [f Bool] -> f Bool
19:22:20 <rpglover64> I'm trying to understand buildExpressionParser and write something similar to it that better suits my needs if necessary.
19:23:25 <rpglover64> I'm getting "ambiguous use of a left associative operator", but I don't see how it's ambiguous (or left associative, but that's different)
19:24:40 <optimight> donri : thanks for the guidance - leanyouahaskell -   started learning
19:24:47 <donri> \o/
19:24:48 <donri> have fun
19:24:56 <optimight> thanks
19:26:30 <optimight> donri : How to leave the room? Any set etiquette?
19:27:15 <dmwit> just /part #haskell, I guess
19:27:45 <dmwit> No offense, but nobody really cares if you leave.
19:28:05 <optimight> donri_ Is it okay , if I am just watching the room and remain idle?
19:28:37 <dmwit> Yes, of course.
19:28:46 <dmwit> The flip side of nobody caring if you leave is that nobody cares if you stay. =)
19:29:22 <optimight> dmwit : thanks
19:29:23 <donri> optimight: there are more than 800 people in here, but fortunately they're not all active at once
19:29:43 <optimight> donri: thanks
19:30:13 <otters> you kidding? that would be awesome
19:30:42 <YayMe> blackdog: that's another thing I've been curious about, the difference between compilers- are there other compilers that parse the same haskell language that the ghc does in a 1 to 1?
19:31:07 <dmwit> YayMe: There are other compilers that implement Haskell98.
19:31:16 <blackdog> YayMe: well, you have haskell98 and haskell2010
19:31:21 <dmwit> I think by now there are probably other compilers that implement Haskell2010.
19:31:30 <blackdog> usually the ghc-specific stuff is nicely fenced off with LANGUAGE pragmas
19:31:41 <dmwit> But I am pretty confident that there are no other compilers that implement all the extensions that GHC does.
19:32:01 <blackdog> the more practical difficulty is that cabal is not terribly friendly to non-ghc compilers in practice
19:32:12 <YayMe> dmwit: my question was regarding ghc compatibility- like blackdog mentioned, I see a monoculture regarding ghc being the relevant compatibility- are there any others that have complete compatiblity with the language as ghc reads it?
19:32:13 <donri> there are also extensions not implemented by ghc, but others
19:32:22 <blackdog> so you can write your code to be compiled by whatever, but if you need lots of libraries, it'll be a real pain to get them going
19:32:24 <donri> like HereDocs or what's-its-name
19:32:37 <dmwit> YayMe: I believe I've answered that question. Do you believe otherwise?
19:32:51 <blackdog> it's a pity - i'm still working on getting haskell on heroku, and the size of GHC is a bit of a problem.
19:32:55 <YayMe> sorry- I didn't read your second response
19:33:37 <YayMe> Don't mean to be rude :)
19:33:52 <dmwit> blackdog: Wait, really? I thought compatibility with other implementations was one of cabal's big design goals.
19:33:55 <YayMe> does each compiler have it's own independent prelude?
19:34:00 <dmwit> What implementation does it not play well with?
19:34:09 <dmwit> YayMe: No, the Prelude is specified in the Report.
19:34:16 <blackdog> dmwit: i had a long chat to john meacham the other day about getting jhc working with cabal.
19:34:21 <blackdog> he was not hopeful.
19:34:26 <dmwit> Or rather, yes, the implementations are all separate, but the behavior is specified in the Report.
19:34:32 <YayMe> dmwit: the functionality yes, but do they have different implementations?
19:34:39 <YayMe> Ok
19:34:51 <YayMe> but that's transparent because they all meet that implementation, that's cool
19:35:19 <YayMe> so if prelude has separate implementations, I'm assuming many other libs have different implementations
19:35:26 <blackdog> dmwit: i think it was one of the goals. i don't think it really met it - possibly because there was the de facto monoculture already.
19:35:45 <dmwit> blackdog: Bad (but strange) news. I bet dcoutts would like to hear a bit about it.
19:36:41 <blackdog> i think duncan knows, i'm sure john was in communication with him
19:36:59 <YayMe> are there any overarching explicit differences between the compilers? Large reasons the GHC blew up and others didn't other than userbase?
19:38:05 <arbn> YayMe: The main reason is that many of the people who write the standard are GHC developers.
19:38:18 <donri> YayMe: as for your "network all the things" idea, maybe look at the remote package / aka. "cloud haskell" for erlang-style cluster computing
19:38:23 <dmwit> I think GHC was one of the earliest implementations, and it enjoys the patronage of the Simons, who are truly beastly researchers.
19:38:34 <blackdog> YayMe: they've all got different focuses. GHC is about completeness and performance. I think HUGS was aimed at education, as was Helium.
19:38:40 <Eduard_Munteanu> YayMe: there are differences wrt performance and features (extensions etc.). Most likely you want to use GHC.
19:38:59 <Eduard_Munteanu> Hugs is just old and rotten :)
19:39:22 <blackdog> nhc & jhc are aimed at creating smaller code, embedded devices etc
19:39:26 <blackdog> (among other things)
19:39:33 <YayMe> Eduard_Munteanu: I presumse I do want to stick with GHC, I was just curious
19:39:49 <donri> wasn't some compiler about whole-program analysis stuff
19:40:01 <donri> also uhc has gotten some fame lately for its javascript backend
19:40:18 <YayMe> donri: whoa? what? explain?
19:40:20 <blackdog> donri: jhc does some of that, i think. based on the GRIN model
19:40:35 <YayMe> donri: it doesn't compile down to javascript does it? You just mean it's backend was written in javascript?
19:40:45 <blackdog> no, it compiles to javascript
19:40:47 <Eduard_Munteanu> YayMe: actually it does
19:40:57 <YayMe> whoa
19:40:59 <blackdog> don't get too excited, though -there's a fairly beasty runtime needed
19:41:00 <YayMe> cool
19:41:07 <Eduard_Munteanu> Agda has a JS backend too, btw.
19:41:16 <donri> YayMe: there's also ghcjs and haste for ghc
19:41:20 <blackdog> perhaps look at Roy if you're interested in running HM-typed code in javascript.
19:41:20 <YayMe> realtime haskell string to dynamic function parser kind of thing?
19:42:16 <Eduard_Munteanu> YayMe: I'm not sure what you mean, it compiles Haskell to JS statically / ahead of time.
19:42:25 <YayMe> ah
19:42:32 <YayMe> but it needs a big runtime?
19:43:03 <Eduard_Munteanu> Dunno about that. I guess some stuff requires quite a bit of supporting code.
19:43:10 <dmwit> Have you ever checked the size of a GHC-compiled hello-world?
19:43:10 <blackdog> yeah. it's just javascript, no special plugin, but you'd have to assume that you're going to need to download that every time
19:43:16 <YayMe> If it compiles to static JS, I would wonder what the large runtime is mentioned if it doesn't parse the haskell in realtime
19:43:40 <Eduard_Munteanu> YayMe: the RTS is rather large, even for native code.
19:44:09 <donri> you can get rid of some amount of dead code with the closure compiler, and lazy-load code on-demand with xhr... but yea, these js compilers aren't optimal for simple scripting
19:44:36 <blackdog> it might make sense if you were building a complex one-page app you expected your users to stay in all day
19:45:57 <AHemlocksLie> I'm interested in learning Haskell. Are there any guides that are considered particularly useful for beginners? I've worked through the beginnings of Yet Another Haskell Tutorial before, so I'm inclined to use it again
19:46:04 <Eduard_Munteanu> @where lyah
19:46:05 <lambdabot> http://www.learnyouahaskell.com/
19:46:08 <Eduard_Munteanu> AHemlocksLie: ^^
19:46:11 <dmwit> ?where gentle
19:46:11 <lambdabot> http://www.haskell.org/tutorial/
19:46:17 <dmwit> ?where rwh
19:46:18 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
19:46:25 <Eduard_Munteanu> dmwit: no, really, the gentle introduction? :)
19:46:35 <dmwit> Yes. I recommend it every time, and I mean it every time.
19:46:38 <YayMe> blackdog: at the end of the day, I tend to want the thinnest possible UI available. just presentation of the state as calculated by a server layer. Given my goal of an absolutely minimal UI layer, I would probably stick to hand rolled js/jquery
19:46:41 <Eduard_Munteanu> Although I don't feel bad about it.
19:46:49 <blackdog> YayMe: that's a sane approach.
19:46:57 <Eduard_Munteanu> Others do, seemingly.
19:47:05 <dmwit> It doesn't get a lot of love from other people these days, but it was the one I used and it sold me hook, line, and sinker, and got me up and running quite quickly.
19:47:05 <YayMe> blackdog: but haskell to JS is an interesting concept all the same
19:47:18 <Eduard_Munteanu> dmwit: yeah, it's quite succint
19:47:43 <dmwit> It was so good, I chose which grad schools to apply to based on whether they had a good PL program. =)
19:47:46 <blackdog> YayMe: I tend to think a hybrid approach makes more sense.
19:47:59 <Eduard_Munteanu> Heh, nice.
19:48:13 <blackdog> you have fairly heavy constraints already, given you have to run on JS, so it makes sense to tailor it a bit to those constraints
19:48:29 <blackdog> as soon as Roy gets a little more mature, i'd be seriously looking at it.
19:48:31 <donri> chrisdone's also working on a haskell source to js translator using haskell-src-exts... should result in much smaller output code
19:49:08 <AHemlocksLie> Thanks for the suggestions, Eduard_Munteanu and dmwit
19:51:15 <YayMe> blackdog: yeah, absolutely. I can't imagine haskell to JS being a preferable way in a real world system, just thinking it's a neat toy and am always curious how client/server communication can be represented when both client and server are written in the same language
19:52:39 <YayMe> blackdog: Roy?
19:54:52 <YayMe> Has anyone here played with any jsonml style server/client template systems like duel or etc?
20:04:02 <hamishmack> dmwit: ghcjs hello world is not not very big. http://ghcjs.github.com/ghcjs-hello-js.jsexe
20:04:25 <coppro> Why do I get "unknown symbol `Some_Mangled_Name_closure`
20:04:31 <coppro> Is there a way to force GHC to emit this?
20:10:44 <rwbarton> we would probably be able to guess better if you gave the actual name
20:15:45 <coppro> rwbarton: IRCziCommon_zdfShowServer_closure
20:16:02 <coppro> rwbarton: I'm using show on Server inside trace
20:16:06 <yongliang> Is there any way to test whether a String constitutes a correctly formatted UNIX path?
20:16:08 <coppro> (which I believe has unsafePerformIO on the inside)
20:17:16 <rwbarton> are you using an old GHC?
20:17:19 <rwbarton> what are you trying to do generally?
20:17:32 <coppro> possibly
20:17:40 <coppro> 7.4.1
20:17:50 <rwbarton> that isn't old
20:17:53 <coppro> I'm trying to trace input going through a Data.Conduit
20:18:06 <rwbarton> you're not trying to do some FFI stuff?
20:18:18 <coppro> no
20:19:23 <donri> yongliang: there's isValid in filepath
20:19:33 <yongliang> donri: Thanks. :)
20:20:11 <YayMe> what's a clean way to define the cast of a read in a function composition place
20:20:34 <YayMe> Can it be done? I have read(unpack x) :: Float
20:20:34 <coppro> rwbarton: actually here's the funny thing
20:20:41 <coppro> rwbarton: I'm /not/ using show on Server inside the trace
20:20:42 <hanDerPeder> any good resources to the 'new' exception system?
20:20:43 <YayMe> but that's not using composition
20:20:49 <donri> YayMe: often you won't need it because the type can be inferred
20:20:57 <hanDerPeder> ive sort of got the hang of OldException
20:21:03 <coppro> in fact I don't think I'm using that anywhere
20:21:21 <rwbarton> can you hpaste the command line and full output of whatever produces that error
20:21:23 <YayMe> donri: actually I'm using reads for a mayberead that forces allowance of only one type
20:21:33 <YayMe> so inferrence wouldn't work for me
20:21:37 <coppro> rwbarton: it's in GHCI with only -XOverloadedStrings
20:21:43 <rwbarton> oh
20:21:45 <coppro> <interactive>: ./IRC/Command/In.o: unknown symbol `IRCziCommon_zdfShowServer_closure'
20:22:13 <rwbarton> well that is mildly less surprising
20:22:15 <donri> YayMe: http://hackage.haskell.org/packages/archive/safe/0.3.3/doc/html/Safe.html#v:readMay
20:22:19 <coppro> rwbarton: what's the difference?
20:22:30 <donri> YayMe: not sure how that prevents inferrence
20:22:33 <rwbarton> well ghc the compiler doesn't generally produce errors like that
20:22:44 <rwbarton> ghci is doing more dynamic loading magic
20:22:50 <coppro> ah
20:22:56 <coppro> I guess I'll try this manually then
20:23:00 <rwbarton> can you just blow away all your .o and .hi files
20:23:01 <YayMe> donri: oh n/m I see how it could infer it
20:23:15 <YayMe> I forget how robust the inferrence is in haskell
20:23:19 <donri> :)
20:23:40 <YayMe> so used to C#'s sometimes-maybe-i'll-infer-it inferrence
20:24:52 <coppro> rwbarton: no help
20:24:55 <coppro> also trace isn't working :(
20:25:03 <coppro> ... or I'm stupid, possibly
20:25:08 <rwbarton> maybe you are asking ghci to show a Server
20:25:08 <coppro> and it's never getting hit
20:25:10 <djahandarie> Hey. Currently trying to build a static binary with -optl-static, and the code uses the hsopenssl library -- ld is giving me all sorts of errors on the compile. Does anyone know how to resolve this?
20:25:17 <coppro> rwbarton: I don't think I am, and why would that cause an issue?
20:25:22 <rwbarton> beats me
20:25:32 <rwbarton> your problem is "it's broken"
20:25:35 <coppro> oh wait, I am
20:25:36 <rwbarton> not a lot to say about it
20:25:38 <coppro> still
20:25:49 <rwbarton> so many things could be wrong
20:25:54 <rwbarton> this isn't a normal circumstance
20:26:46 <coppro> wait, wtf
20:26:54 <rwbarton> do you have a .ghci with -fset-object-code or something
20:27:36 <coppro> why is ghci interpreting one of the modules?
20:27:40 <coppro> that is the problem, I think
20:27:43 <coppro> nm shows the symbol
20:27:58 <rwbarton> it looks like you have some weird mix of compiled and interpreted stuff
20:28:13 <coppro> how do I force ghci to use the compiled version?
20:28:16 <coppro> or explain why it isn't?
20:28:54 <rwbarton> of what
20:29:09 <coppro> of IRC.Common
20:29:11 <YayMe> Assuming inferrence won't work for my scenario, syntactically how do i fit the explicit cast into this and do composition instead of application: reads(unpack x) :: [(Float, String)]
20:29:29 <rwbarton> is that something you are importing, or the module you have loaded in ghci
20:29:33 <rwbarton> work with me here :P
20:29:36 <YayMe> or can I not fit the type definition in with composition
20:29:51 <rwbarton> there's some special syntax for loading a compiled version
20:30:02 <coppro> rwbarton: I have IRC/Common.o and IRC/Command/In.o
20:30:07 <donri> YayMe: cast is the wrong word, it's just type annotations... you can put them anywhere in an expression, basically. (read "5" :: Int) + 3 == 8
20:30:09 <coppro> I ask GHC to load them both
20:30:15 <rwbarton> :load *MyModule
20:30:22 <coppro> it decides to interpret IRC/Common.hs but not IRC/Command/In.hs
20:30:25 <YayMe> donri: I know it's the wrong word, but I don't know the words for these things in haskell
20:30:31 <donri> sure
20:30:52 <coppro> rwbarton: * seems to just force interpretation, which is the opposite of what I want
20:30:55 <rwbarton> http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/ghci-compiled.html may be relevant
20:31:00 <rwbarton> oh i have it backwards
20:31:03 <donri> bedtime
20:31:38 <rwbarton> anyways it would be super helpful to have like a ghci transcript
20:32:37 <YayMe> is there no way to do this with composition? reads(unpack x) :: [(Float, String)]
20:32:41 <coppro> rwbarton: thanks for that doc
20:33:34 <coppro> rwbarton: if I set -fobject-code it works
20:33:44 <donri> YayMe: reads . unpack :: a -> [(Float,String)], where a is the type unpack takes
20:33:46 <rwbarton> hmm i never knew about :show modules
20:36:08 <YayMe> donri: thanks! that is a new syntactic structure to me..
20:36:26 <YayMe> oh I getting
20:36:50 <YayMe> since the composition is the definition, composition can take on the same syntax as new function definition
20:36:56 <YayMe> that makes sense
20:37:12 <YayMe> s/getting/get it/g
20:41:25 <mparodi> do I have to create modules in order to separate a big application into different files?
20:41:34 <byorgey> yes
20:41:45 <mparodi> hmn :|
20:41:55 <byorgey> what's wrong with modules?
20:42:18 <byorgey> modules in Haskell are quite simple actually.
20:42:37 <mparodi> yeah, but these files aren't modules
20:42:40 <blackdog> it'd sometimes be nice to go the other way and have multiple modules in the same file, but it's a minor carp
20:42:43 <byorgey> a module named Foo.Bar.Baz goes in Foo/Bar/Baz.hs, and you just put  module Foo.Bar.Baz at the top
20:42:56 <mparodi> I mean, I just have a few functions in each
20:43:06 <byorgey> and why aren't those modules?
20:43:20 <mparodi> I mean, obviously you can call them modules
20:43:30 <mparodi> but they don't do anything useful unless they're all together
20:43:32 <rpglover64> I just posted a question to SO about my tricky use of buildExpressionParser.
20:43:36 <rpglover64> http://stackoverflow.com/questions/11174775
20:43:43 <mparodi> however it's too long to put in just one file
20:43:48 <rpglover64> If anyone has some time to take a look.
20:43:53 <byorgey> mparodi: you have a strange idea of what 'module' means.  No one said modules need to be useful on their own.
20:44:07 <mparodi> alright, /me is creating modules
20:44:11 <byorgey> =)
20:44:55 <YayMe> can you do a pattern match in an otherwise?
20:44:57 <byorgey> the smallest unit of standalone usefulness in the Haskell world is usually the package.
20:46:02 <byorgey> YayMe: I'm not sure I understand.  If you did pattern match then it wouldn't be an 'otherwise'.
20:46:03 <YayMe> something like otherwise (x:xs) = show x
20:46:59 <byorgey> otherwise is used in a guard to mean 'in any other case'.  If you are pattern matching then it is handling a specific case.
20:47:02 <YayMe> no such mechanism is there?
20:47:08 <YayMe> I know, I'm in a guard
20:47:22 <byorgey> no, because it doesn't really make sense.  Can you give a better sense of what you are trying to accomplish?
20:47:32 <YayMe> I'm just wondering if I can decompose the list on the line or would have to do a let for it
20:47:56 <byorgey> do you *know* that the list will always be a cons in the 'otherwise' case?
20:49:27 <byorgey> YayMe: do you have some code you can show?
20:49:45 <YayMe> nah, it's bad and done wrong- I'll keep it to myself :) hehe
20:50:00 <byorgey> YayMe: the answer to your specific question is 'no', but the question is strange so I am trying to help you figure out a better way to do whatever you are trying to do
20:50:05 <YayMe> my questions are more to understand what is capable, not trying to do anything right
20:50:12 <byorgey> ok.
20:50:32 <YayMe> as I'm learning I'm doing lots of things wrong just to see what I can and can't do
20:51:54 <dpsht> YayMe: you could just have (x:xs) as the last clause
20:52:20 <YayMe> dpsht: ah yeah, that makes sense
20:59:44 <coppro> @hoogle ([a -> b]) -> a -> b
20:59:44 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
20:59:45 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
20:59:45 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
20:59:57 <coppro> @hoogle f (a -> b) -> a -> b
20:59:58 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
20:59:58 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
20:59:58 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
21:00:03 <coppro> this is the worst
21:00:05 <coppro> I swear
21:00:39 <blackdog> coppro: does that type signature make any sense anyway?
21:00:50 <blackdog> if i give you an empty list and an a, can you give me a b?
21:01:09 <byorgey> you can do   [a -> a] -> a -> a.
21:01:16 <byorgey> that is  foldr (.) id
21:01:27 <MostAwesomeDude> @hoogle ([m a -> m b]) -> m a -> m b
21:01:27 <lambdabot> Test.QuickCheck.Arbitrary (><) :: (Gen a -> Gen a) -> (Gen a -> Gen a) -> (Gen a -> Gen a)
21:01:28 <lambdabot> Test.QuickCheck (><) :: (Gen a -> Gen a) -> (Gen a -> Gen a) -> (Gen a -> Gen a)
21:01:28 <lambdabot> Data.Generics.Aliases ext1T :: (Data d, Typeable1 t) => (forall e. Data e => e -> e) -> (forall f. Data f => t f -> t f) -> d -> d
21:01:29 <byorgey> or  ala Endo foldMap
21:01:34 <MostAwesomeDude> Yeah, that's what I thought.
21:01:36 <blackdog> ah, right. so it constrains it to id, more or less
21:01:51 <MostAwesomeDude> I'm trying to figure out exactly how you could get one single b out.
21:02:02 <blackdog> it means b has to be a
21:02:08 <parcs`> YayMe: otherwise is just a value that evaluates to True
21:02:18 <MostAwesomeDude> @hoogle ([a -> b]) -> a -> [b]
21:02:19 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
21:02:19 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
21:02:19 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
21:02:31 <parcs`> :t otherwise
21:02:32 <lambdabot> Bool
21:02:34 <YayMe> parcs`: yeah a little more thougt and it makes sense that I can't do that, doesn't make any sense
21:02:41 <MostAwesomeDude> coppro: What are you trying to do?
21:03:10 <byorgey> @type  Data.Foldable.sequence  :: [a -> b] -> a -> [b]
21:03:11 <lambdabot> Not in scope: `Data.Foldable.sequence'
21:03:20 <byorgey> @type  Data.Traversable.sequence  :: [a -> b] -> a -> [b]
21:03:21 <lambdabot> forall a b. [a -> b] -> a -> [b]
21:03:22 <coppro> found it
21:03:33 <MostAwesomeDude> coppro: ?
21:05:10 <YayMe> can I put a do in where?
21:05:19 <YayMe> no that wouldn't make sense would it
21:05:40 <blackdog> YayMe: why not?
21:06:08 <YayMe> well I guess if you use return maybe?
21:06:17 <blackdog> sure. or anything, really.
21:06:25 <coppro> trying to experiment to find the most concise way to apply a set of predicates and work if any of them matches
21:06:45 <blackdog> coppro: any
21:06:50 <blackdog> @type any
21:06:51 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
21:07:05 <coppro> blackdog: that takes a predicate and applies it to each element of a list
21:07:07 <coppro> I want the reverse
21:07:08 <dpsht> Yayme: do you mean like where do <foo>? cause you're right you can't do that
21:07:28 <blackdog> oh, a set of predicates. sorry, didn't read properly.
21:07:40 <coppro> one option is getAny $ mconcat $ map (Any .) []
21:08:09 <YayMe> dpsht: I mean like so I can have the something <- something block in a where to avoid having the lines in function
21:08:44 <coppro> (\c -> any (\f -> f c) []) works too
21:08:52 <YayMe> but if it's in a do block it has to end with an expression returning a data type I think..
21:09:08 <dpsht> you can use do syntax in any variable binding
21:09:16 <coppro> and that simplifies to \c -> any ($c) []
21:09:24 <dpsht> eg, where bar = do a <- baz ...
21:09:30 <coppro> that's probably good enough
21:09:41 <shachaf> > any ($undefined) []
21:09:42 <lambdabot>   False
21:10:01 <edwardk> donri: yes
21:10:30 <edwardk> donri: its my attempt to factor out most of the combinators and let trifecta proper only deal with diagnostics and parser transformers
21:11:34 <edwardk> i'll probably move the completion combinator hints into parsers as well
21:11:45 <edwardk> so you can mark up your parsers with tab completion hints
21:12:03 <djahandarie> God damn this static linking bullshit
21:12:34 <djahandarie> I don't know if parameter order is getting messed up when it's getting passed to ld or what, but GHC is refusing to build this properly
21:12:35 <edwardk> roconnor_: the only problem i see with van laarhoven lenses is that . composes backwards ;)
21:13:02 <edwardk> otoh foo.bar.baz i guess does what you'd expect if you come from an OO background
21:13:29 <MostAwesomeDude> edwardk: Pretty much.
21:13:37 <blackdog> coppro: omg, i've never seen $ used in a section before. it's all so obvious now.
21:13:57 <coppro> blackdog: haha
21:14:23 <edwardk> @tell roconnor a -> (b, c -> d) should give you the same effect with traditional lenses, using the indexed store comonad
21:14:23 <lambdabot> Consider it noted.
21:15:40 <blackdog> coppro: i thought it was a perlism until i twigged
21:16:12 <edwardk> MostAwesomeDude: i added the highlighting support back into parsers so when trifecta switches to it, you won't lose functionality
21:20:09 <MostAwesomeDude> edwardk: Okay. Very cool.
21:20:22 <MostAwesomeDude> edwardk: So the main reason for this split was just to clean up the backend stuff in trifecta?
21:20:28 <edwardk> somewhat
21:20:41 <edwardk> i also have another parsing combinator library i've been playing with that i wanted these combinators for
21:20:53 <edwardk> and they work with things like parsec, etc.
21:21:04 <edwardk> so you can use them when you want the combinators in parsec, attoparsec, etc.
21:21:14 <edwardk> you can write code that is polymorphic in the parsing combinator library
21:21:46 <MostAwesomeDude> That's...slightly head-hurting, but I can totally see the reasoning.
21:21:57 <edwardk> being able to quotient over parsec and attoparsec and trifecta is nice because you can choose tradition vs speed vs error reporting
21:22:09 <MostAwesomeDude> So this is mostly about operations in MonadParser right?
21:22:25 <edwardk> yeah, MonadParser became split into Parsing, CharParsing and TokenParsing
21:22:39 <edwardk> and it contains a few extras for providing position info
21:23:03 <edwardk> so trifecta will contain the positioning/slicing class
21:23:13 <edwardk> and the diagnostic code
21:23:34 <edwardk> but will lose most of its actual parsing combinators
21:23:34 <edwardk> since they are implemented nicer and fully documented in parsers
21:24:15 <edwardk> and if you just want the combinators you only have to accept a couple of minor extensions over haskell 98 and a small import list, not the kitchen sink
21:24:30 <MostAwesomeDude> Okay. So will I eventually import the combinators directly from parsers instead of trifecta?
21:24:35 <edwardk> yeah
21:24:39 <MostAwesomeDude> Nifty.
21:24:54 <edwardk> import Text.Trifecta will become import Text.Trifecta; import Text.Parser
21:25:27 <edwardk> all of the general purpose combinators are already ported
21:26:02 <MostAwesomeDude> I really dig this plan.
21:30:02 <enko> > add 1
21:30:03 <lambdabot>   Not in scope: `add'
21:30:17 <edwardk> the combinators were the part of trifecta people couldn't figure out, so putting them all in one place in an easy to read package i hope will solve that problem
21:30:20 <edwardk> and ease people in
21:30:20 <MostAwesomeDude> enko: What's up?
21:30:32 <enko> just learning the basics
21:30:46 <enko> using your channel compiler :P hope thats ok
21:30:51 <MostAwesomeDude> edwardk: That's kinda weird, 'cause they were really straightforward to me. But I suppose that knowing parsec, attoparsec, frisby, and also parsers in other languages... :3
21:31:08 <edwardk> i think it was more trying to figure out what to import from where
21:31:30 <edwardk> do you use any of the parser transformers?
21:31:31 <MostAwesomeDude> Oh, yeah, *that* was confusing as hell.
21:31:47 <MostAwesomeDude> I don't think I use any transformers; my stuff's still pretty simple.
21:31:50 <edwardk> k
21:32:03 <enko> > add max((min 7 4) 5 6) 10
21:32:04 <lambdabot>   Not in scope: `add'
21:32:11 <edwardk> also, if i simplify the Diagnostic code to make it less polymorphic, will you be adversely affected?
21:32:15 <enko> > add 1 2
21:32:16 <lambdabot>   Not in scope: `add'
21:32:16 <MostAwesomeDude> Nah.
21:32:25 <edwardk> basically i want to make it easier to make Diagnostic messages, and for them to do the right thing
21:32:29 <MostAwesomeDude> > 1 + 2
21:32:30 <lambdabot>   3
21:32:49 <edwardk> but that is going to cost the ability to have custom user-distinguishable diagnostic levels, etc.
21:32:54 <edwardk> but nobody ever used that
21:33:03 <MostAwesomeDude> edwardk: I think my main complaint is that this is missing: lexstr = lexeme . string
21:33:12 <edwardk> hah
21:33:14 <MostAwesomeDude> With type MonadParser m => String -> m String
21:33:30 <edwardk> well, that one is tricky because it would highlight wrong
21:33:31 <MostAwesomeDude> Also is <$!> actually defined anywhere? I saw it in a couple of your examples and just redefined it in my parser.
21:33:35 <edwardk> thats what the identifier parsers are for
21:33:40 <enko> map 1 2
21:33:45 <MostAwesomeDude> Oh, really? I learned something today.
21:33:47 <enko> > map 1 2
21:33:48 <lambdabot>   No instance for (GHC.Num.Num [a])
21:33:48 <lambdabot>    arising from the literal `2' at <inter...
21:34:03 <MostAwesomeDude> > map (+) [1, 2]
21:34:04 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
21:34:04 <lambdabot>    arising from a use of `...
21:34:12 <edwardk> the idea is you make an IdentifierStyle for the things you want to parse that way, including the characters that you want to cover
21:34:16 <MostAwesomeDude> > map (+ 1) [1, 2]
21:34:17 <lambdabot>   [2,3]
21:34:28 <edwardk> then you use reserve and ident to match particular strings or any string in that style
21:35:05 <MostAwesomeDude> Okay. So if I had tokens, instead of doing lexstr "\\token", I'd build real identifiers.
21:35:06 <edwardk> this way those get highlighted as reserved keywords or operators in the interval map
21:35:12 <MostAwesomeDude> Aha.
21:35:30 <edwardk> yep
21:35:44 <edwardk> you can do it by hand by invoking highlight with an appropriate tag
21:35:58 <edwardk> but those are what the identifier style stuff is for
21:36:09 <edwardk> thats basically factored of the token parsers in parsec
21:36:11 <MostAwesomeDude> Okay. I'll have to go back and hack on that at some point.
21:36:26 <enko> > 5 :: integer
21:36:27 <lambdabot>   Could not deduce (GHC.Num.Num integer) from the context ()
21:36:27 <lambdabot>    arising from ...
21:36:41 <edwardk> <$!> is in Text.Trifecta.Util.Combinators
21:36:44 <enko> >'a'::Char
21:36:45 <edwardk> but i don't expose it
21:36:48 <MostAwesomeDude> Tonight I am trying to get all my AST->AST transformations ported from Python. If I can get it all done by tomorrow, then I can demo the Haskell version on Thursday.
21:36:52 <edwardk> it really belongs in Control.Monad
21:36:59 <MostAwesomeDude> Yeah, it's pretty darn useful.
21:37:04 <enko> > 'a'::Char
21:37:05 <lambdabot>   'a'
21:37:09 <MostAwesomeDude> > 5 :: Integer
21:37:10 <lambdabot>   5
21:37:20 <MostAwesomeDude> enko: In Haskell, types are always capitalized.
21:37:25 <enko> thx
21:37:30 <edwardk> put in a libraries@ proposal to add it, i'd vote yes =)
21:37:44 <shachaf> How do libraries@ proposals work?
21:37:47 <MostAwesomeDude> edwardk: I don't think I've got the clout for it, but it just seems so darn obvious.
21:38:24 <edwardk> shachaf: someone emails the list, saying, hey i'd like to propose adding this thing to this module, or changing this property and sets a discussion window (2 weeks or more)
21:38:28 <edwardk> and folks vote it up or down
21:38:33 <MostAwesomeDude> :t f <$!> ma = do { a <- ma; return $! f a }
21:38:33 <lambdabot> parse error on input `='
21:38:40 <edwardk> yep
21:38:41 <MostAwesomeDude> :t { a <- ma; return $! f a }
21:38:42 <lambdabot> parse error on input `{'
21:38:44 <MostAwesomeDude> :t do { a <- ma; return $! f a }
21:38:45 <lambdabot> Not in scope: `ma'
21:38:53 <MostAwesomeDude> Clearly I fail at lambdabot this evening.
21:38:55 <shachaf> edwardk: Has anyone proposed something :: Read a => String -> Maybe a?
21:39:09 <enko> > ::
21:39:10 <lambdabot>   <no location info>: parse error on input `::'
21:39:23 <edwardk> :t \ f m -> do { a <- m; return $! f a }
21:39:24 <lambdabot> forall t a (m :: * -> *). (Monad m) => (t -> a) -> m t -> m a
21:39:34 <MostAwesomeDude> Look about right.
21:39:39 <enko> > blah x = x + 2
21:39:40 <lambdabot>   <no location info>: parse error on input `='
21:39:42 <edwardk> thats what i have in trifecta
21:39:56 <edwardk> it winds up in most of my executable haskell projects somewhere
21:40:19 <MostAwesomeDude> It still weirds me out slightly how that strictness can matter in that one spot so much.
21:40:42 <shachaf> use strict;
21:40:46 <enko> is haskell newline dependent?
21:40:59 <yongliang> Hello, is there any way to make lambdabot join another channel (maybe hosting it on my own)?
21:41:12 <shachaf> yongliang: Yes. cabal install lambdabot
21:41:14 <edwardk> enko: we have layout rules for where, of, let and do that makes indentation matter
21:41:19 <MostAwesomeDude> > let blah x = x + 2 in blah 5
21:41:20 <lambdabot>   7
21:41:36 <ghartshaw> @unpl flip ((.:).(.)) # flip (.)
21:41:37 <lambdabot> ((\ b c -> (\ e f -> c (e f)) .: b) # \ h i l -> i (h l))
21:41:37 <enko> thx dude
21:41:42 <shachaf> Or: cabal unpack lambdabot && cd lambdabot && ...whatever... && vi online.rc && lambdabot # type rc online.rc
21:41:53 <ghartshaw> @unpl flip ((.:).(.)) $ flip (.)
21:41:54 <lambdabot> (\ c -> (\ e f -> c (e f)) .: \ h i l -> i (h l))
21:42:15 <edwardk> enko: basically the indentation of whatever token follows those keywords sets a 'scope' and indenting to exactly that level gets a virtual ; inserted and outdenting closes the scope
21:42:15 <yongliang> shachaf: :) Thank you.
21:42:35 <enko> gotcha ed
21:42:43 <ghartshaw> @unpl flip (((.).(.)).(.)) $ flip (.)
21:42:43 <lambdabot> (\ c f i l -> c (i (f l)))
21:43:22 <ghartshaw> @pl (\c f i  -> c . i . f
21:43:23 <lambdabot> (line 1, column 22):
21:43:23 <lambdabot> unexpected end of input
21:43:23 <lambdabot> expecting letter or digit, variable, "(", ".", "`", "!!", operator or ")"
21:43:25 <enko> 'a' + 'x'
21:43:27 <ghartshaw> @pl (\c f i  -> c . i . f )
21:43:28 <lambdabot> (. flip (.)) . (.) . (.)
21:43:30 <enko> > 'a' + 'x'
21:43:31 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
21:43:31 <lambdabot>    arising from a use of `GHC....
21:43:32 <edwardk> MostAwesomeDude: looks like switching to parsers rips about 11 modules out of trifecta
21:43:48 <edwardk> more if i kill the Char8 parsers as well
21:43:49 <MostAwesomeDude> edwardk: Woot!
21:44:02 <ghartshaw> @pl (\c f i l -> c . i . f $ l)
21:44:03 <lambdabot> (. flip (.)) . (.) . (.)
21:44:18 <MostAwesomeDude> > "a" ++ "x" -- Strings are double-quoted, chars are single-quoted
21:44:19 <edwardk> it may come at a slight speed impact because the ones in parsers don't have all the fancy 'do this if everything is '< 0x7f' checks that trifecta had
21:44:20 <lambdabot>   "ax"
21:44:44 <MostAwesomeDude> It seems weird to me that the upper bit check would actually impact speed.
21:44:47 <djahandarie> Really annoying that the Haskell Platform requires x11
21:45:06 <djahandarie> Trying to run this on a server, don't want a damn x11
21:45:13 <edwardk> MostAwesomeDude: well, trifecta assumes the input is utf-8 encoded, so it takes fast paths which are often enabled outside of the monad
21:45:26 <MostAwesomeDude> edwardk: Aha.
21:45:37 <enko> A Gentle Introduction to Haskell is not at all gentle
21:45:38 <edwardk> so when it takes a 'oneOf' itll scan the symbols and figure out if it should use satisfy or satisfy8
21:45:53 <edwardk> satisfy has to decode a utf-8 symbol, satisfy8 just looks at a byte
21:46:18 <wagle> whats the fastest way again to read 100000 numbers from a file?
21:46:21 <edwardk> this is done when returning the parser combinator so subsequent uses of the same oneOf ‚Ä¶ get the benefits
21:46:24 <MostAwesomeDude> @where lyah
21:46:24 <lambdabot> http://www.learnyouahaskell.com/
21:46:29 <MostAwesomeDude> enko: ^^ is how I started.
21:46:33 <enko> k
21:46:36 <MostAwesomeDude> And it's not too uncomfy.
21:46:40 <enko> i'll try that
21:46:49 <MostAwesomeDude> edwardk: That's pretty tricky.
21:47:33 <edwardk> MostAwesomeDude: i was more concerned with making trifecta competitive than i was with maintainability in my first pass ;)
21:47:41 <edwardk> now that i have to maintain it i want to be able to read the code ;)
21:48:45 <MostAwesomeDude> edwardk: Yeah, that's a common problem. :3
21:49:18 <rpglover64> Is there a standard way to recommend a quote to HWN?
21:49:44 <edwardk> i also want to integrate all the little tests i've done using the trifecta combinators but they are strewn over old versions of the code base in branches
21:50:20 <edwardk> i'd really like to have the CPP parser transformer working and the tab-completion monad in the main distribution
21:50:58 <edwardk> right now Delta is made more complicated by the need to support the c preprocessor transformer, but i don't actually give you access to it ;)
21:51:38 <enko> > "A" == "a"
21:51:39 <lambdabot>   False
21:51:44 <enko> > "A" /= "a"
21:51:45 <lambdabot>   True
21:51:52 <enko> > "A" != "a"
21:51:53 <lambdabot>   Not in scope: `!='
21:52:20 <edwardk> > let (!=) = (/=) in "A" != "a"
21:52:21 <lambdabot>   True
21:52:32 <enko> thats cool
21:52:56 <shachaf> > (pi :: CReal) /= pi
21:52:58 <lambdabot>   False
21:53:10 <enko> > let (++) = (add 1)
21:53:11 <edwardk> shachaf: =P
21:53:11 <lambdabot>   not an expression: `let (++) = (add 1)'
21:53:26 <shachaf> edwardk: Clearly I underestimated CReal!
21:53:36 <edwardk> enko: that doesn't work, postfix and prefix operators don't exist/work lie you'd expect
21:53:38 <edwardk> er like
21:53:48 <enko> gotcha
21:53:50 <edwardk> we trade them in for 'sectioning'
21:53:54 <shachaf> > let (++) = (+1) in (5++)
21:53:56 <lambdabot>   6
21:54:26 <edwardk> shachaf: i was going to leave out mentioning of that kinda borked ghc extension
21:54:46 <shachaf> edwardk: Sorry. :-(
21:54:56 * shachaf should get into the habit of not senselessly confusing people.
21:55:02 <ghartshaw> @pl \l r -> (l.).(.r)
21:55:03 <lambdabot> (. flip (.)) . (.) . (.)
21:55:13 <edwardk> clearly we should just write code in ermine, where you can define postfix ++ ;)
21:55:18 <yongliang> wth
21:56:03 <edwardk> > 1 - - 1
21:56:04 <lambdabot>   Precedence parsing error
21:56:04 <lambdabot>      cannot mix `GHC.Num.-' [infixl 6] and prefix ...
21:56:12 <edwardk> we at least parse that correctly ;)
21:56:22 <maybefbi> hi, why do people write Either t sometimes? shouldn't it be Either t u ?
21:56:49 <edwardk> maybefbi: (Either t) is the type of kind * -> * that can accept any other type as its last argument
21:57:10 <edwardk> when you write instance Monad (Either t) -- you are leaving off the last one so that the body of the instance can fill them in
21:57:15 <shachaf> maybefbi: For the same reason they write (map f) instead of (map f xs)
21:57:17 <edwardk> :t (>>=)
21:57:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
21:57:26 <edwardk> m = Either t
21:57:27 <edwardk> then
21:57:42 <edwardk> Either t a -> (a -> Either t b) -> Either t b
21:58:07 <maybefbi> woah..
21:58:17 * shachaf wonders whether giving a Monad instance as an example to help understand partially applying types isn't a bit backwards.
21:58:17 <maybefbi> gimme a min to digest that
21:58:20 <edwardk> if m = Either t u, then you wind up talking about Either t u a -> ‚Ä¶ and give it the wrong number of arguments
21:59:39 <MostAwesomeDude> Hm. What is worse, having a constructor MyType (Maybe MyNestedType), or allowing MyNestedType to have a sentinel value? Pretend I've got data MyNestedType = MyNestedType Integer and so I could have MyNestedType 0 to signal empty.
22:00:11 <edwardk> MostAwesomeDude: will you ever have MyNestedType on its own outside of the Maybe?
22:00:14 <rpglover64> The sentinel value is horrible.
22:00:21 <edwardk> if so then you probably don't want the sentinel
22:00:35 <edwardk> data Kind = Star | Constraint | ErrNope
22:00:41 <MostAwesomeDude> edwardk: Not likely.
22:01:08 <MostAwesomeDude> But right now, concretely, I'm thinking about data Expr = ParsedExpr (Maybe SomeData) | Expr SomeData
22:01:09 <edwardk> MostAwesomeDude: well, in that very limited situation then you might get away with it
22:01:25 <MostAwesomeDude> And I'm writing a stateful traversal (yay?) to transform from the first to the second.
22:01:40 <edwardk> well, then you have to dea with the case where Expr contains your shiny new sentinel
22:01:45 <MostAwesomeDude> Right.
22:02:06 <edwardk> i kind of like avoiding hidden invariants
22:02:11 <MostAwesomeDude> It'd be really cool if I could simply *say* that all the ParsedExprs were transformed away, but since they're still part of the type, I can't be sure. :T
22:02:13 <edwardk> and a sentinel is a hidden invariant
22:02:17 <MostAwesomeDude> True.
22:02:23 <edwardk> you can do it another way
22:02:40 <edwardk> data SomeData a = Var a | YourOtherSomeData cases
22:02:45 <edwardk> then
22:03:02 <edwardk> data Expr = ParsedExpr (SomeData ()) | Expr (SomeData Void)
22:03:12 <maybefbi> edwardk, hey thanks. i get it now
22:03:28 <edwardk> and then you can know that Var can't occur in Expr without shenanigans on your part
22:04:03 <MostAwesomeDude> Yeah, see, I'm *full* of shenanigans.
22:04:06 <edwardk> and if SomeData contains references to SomeData, you make SomeData into a free monad which can have other uses
22:04:37 <MostAwesomeDude> I think that creating my own monad just for this would be more trouble than it's worth; I'm nearly always operating either in MonadParser or State here.
22:05:04 <edwardk> well, i'm just talking about the type of SomeData, the fact that its a monad is an accident ;)
22:05:12 <edwardk> its like Either being a monad
22:05:25 <edwardk> maybefbi: happy to help
22:05:27 <MostAwesomeDude> Hey, Either a is a *great* monad. :3
22:05:51 <edwardk> then why do i always wind up writing special case types to replace it? =)
22:05:59 <edwardk> well, to be fair thats mostly for unboxing
22:06:05 <shachaf> edwardk: Cont r is a *great* monad!
22:06:17 <edwardk> shachaf: Codensity is better =P
22:06:32 <yongliang> MostAwesomeDude: ErrorT is an even greater monad! :)
22:06:38 <yongliang> well, monad transformer
22:06:44 <edwardk> EitherT beats ErrorT ;)
22:06:51 <edwardk> silly Error class
22:06:51 <MostAwesomeDude> ErrorT makes me sad.
22:06:58 <yongliang> Why?
22:07:02 <shachaf> Codensity is (a -> t r) -> t r, right?
22:07:11 <edwardk> why the heck was the class named Error, it breaks the convention, that you have Foo and FooT?
22:07:12 <MostAwesomeDude> Well, partially because of Either T, and partially because of WriterT.
22:07:22 <edwardk> also there are perfectly good uses for EitherT without the constraint
22:07:33 <shachaf> Like early return!
22:07:37 <shachaf> either id id
22:08:12 <shachaf> Why is Codensity better than Cont?
22:08:15 <edwardk> you can find that apomorphisms are dual to paramorphisms, the former using Either (Mu f) the latter using (,) (Mu f). this works now that we've ripped the Error constraint off Either
22:08:17 <edwardk> but it didn't before
22:08:32 <yongliang> edwardk: Well, I never knew EitherT existed, I wanted a monad transformer like MaybeT, but with an error description tag, and the first thing I stumbled upon was ErrorT.
22:08:36 <edwardk> shachaf: because it subsumes it to start with. Codensity (Const r) = Cont r
22:08:48 <yongliang> edwardk: I must admit that the name EitherT makes much more sense.
22:09:10 <shachaf> edwardk: OK, and Cont (m r) = Codensity m r?
22:09:12 <edwardk> shachaf: also, because you can use it with any return type you want ;)
22:09:15 <shachaf> Oh, no, the forall is different.
22:09:22 <edwardk> shachaf: no, Codensity (Const (m r))
22:09:23 <shachaf> I see, Codensity is polymorphic in the r
22:09:38 <edwardk> Codensity is more powerful than Cont
22:10:20 <edwardk> you can't callCC with it in its general form, but you can let the user change out the r type which is surprisingly powerful
22:10:56 <edwardk> (you can write a callCC for the Codensity (Const r) -- like variants, but you have access to a polymorphic variable you lose with just Cont
22:13:06 <shachaf> Hmm.
22:15:13 <edwardk> wow, if i break up trifecta into parts the core trifecta parser stuff and diagnostic handling becomes very small
22:15:37 <edwardk> with the combinators gone the bulk of the remainder is code to deal with layout, literate parsing and language selection
22:15:57 <shachaf> The worst part about trifecta is how the whole thing is one big monolithic package with no dependencies. :-)
22:16:06 <edwardk> if those move into separate packages, and i peel off highlighting into another package
22:16:33 <edwardk> then i wind up with about 15 modules, that focus on diagnostics, ropes and building the parser itself
22:16:41 <shachaf> (Recently I went through the "rm ~/.ghc ~/.cabal" dance and the first thing I did in order to get a bunch of packages was `cabal install trifecta`.)
22:16:49 <edwardk> shachaf: well, its both a monolithic package AND has a huge set of dependencies ;)
22:16:59 <edwardk> shachaf: =) i used to do the same
22:17:10 <edwardk> i removed the dependency on kan-extensions which cut its import list in half ;)
22:17:37 <edwardk> parsers is pretty minimal. importing about 5-6 packages
22:18:04 <edwardk> i'm trying to see if i can make 'Highlighted' into a parser transformer
22:18:12 <edwardk> then i can remove the support from the prim parser
22:18:26 <edwardk> so you can just work with the highlighter monad or monad transformer when you want it
22:18:54 <shachaf> How's the error slice thing going, by the way?
22:19:38 <edwardk> i have taken the time to refactor the code that i had that was using it to use bound, but i haven't added the slicing back in yet
22:19:45 <edwardk> did you see bound?
22:21:05 <shachaf> I only looked at that one file you posted in here.
22:21:16 <edwardk> oh yeah i guess i did
22:21:36 <edwardk> it cleanedup nicely
22:21:38 <edwardk> https://github.com/ekmett/bound
22:21:42 * shachaf looks.
22:22:47 <edwardk> i've been switching both compiler projects i work on over to this approach
22:22:54 <edwardk> its been great for squashing bugs
22:23:45 <edwardk> because i can't screw up the handling of instantiation/abtraction without trying hard ;)
22:24:41 <edwardk> it has had a few consequences our term type in scala went from 0 parameters to 4, but overall the amount of code is down a lot, and i'm much more confident in it
22:25:46 <edwardk> i also think i can repeat one of the tricks to make the error slicer nicer
22:26:27 <edwardk> the main reason i started working on parsers/trifecta again was because i was fiddling with parsing stuff for turbohaskell again
22:27:02 <edwardk> now that i don't hate the internal AST representation any more
22:27:13 <enko> > 5:[1,2,3,4,5]
22:27:14 <lambdabot>   [5,1,2,3,4,5]
22:28:15 * hackagebot TBC 0.0.3 - Testing By Convention  http://hackage.haskell.org/package/TBC-0.0.3 (PeterGammie)
22:28:46 <hpaste> wagle pasted ‚Äúwhat's not exhastive about the patterns?‚Äù at http://hpaste.org/70369
22:28:48 <enko> > "enko" !! 0
22:28:50 <lambdabot>   'e'
22:29:11 <edwardk> wagle [] [1,2,3]
22:29:22 <wagle> diuhhhhhh
22:29:26 <wagle> right, sorry
22:30:01 <enko> > length "monkey"
22:30:02 <lambdabot>   6
22:30:15 <MostAwesomeDude> Man, State is so much more reasonable when not done as do -spaghetti.
22:30:35 <enko> > "monkey" !! (length "monkey")-1
22:30:37 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
22:30:37 <lambdabot>    arising from the literal `1...
22:30:46 <edwardk> > last "monkey"
22:30:46 <enko> > "monkey" !! (length "monkey" -1)
22:30:47 <lambdabot>   'y'
22:30:47 <lambdabot>   can't find file: L.hs
22:31:17 <enko> thx
22:31:26 <edwardk> > init "monkey"
22:31:27 <lambdabot>   "monke"
22:31:31 <MostAwesomeDude> enko: It's useful to remember that (!!) can, and will, blow up in your face.
22:31:38 <wagle> edwardk: msort worked after that, thanks
22:31:40 <MostAwesomeDude> > [1,2,3] !! 4
22:31:40 <lambdabot>   *Exception: Prelude.(!!): index too large
22:31:49 <edwardk> wagle: happy to help
22:31:49 <enko> > "monkey" !! (length "monkey")
22:31:50 <lambdabot>   *Exception: Prelude.(!!): index too large
22:32:16 <solrize> bah i tried to put haskell code into the <code> tag in my advogato blog and it messed up the indentation.
22:32:19 <edwardk> > "monkey" !! (length "monkey" - 1) -- was correct
22:32:20 <lambdabot>   'y'
22:32:47 <enko> last "ab"
22:32:52 <enko> > last "ab"
22:32:52 <lambdabot>   'b'
22:32:57 <enko> k
22:33:13 <edwardk> > last ""
22:33:14 <lambdabot>   *Exception: Prelude.last: empty list
22:33:33 <enko> right now this is easier than dealing with leksah
22:33:37 <enko> sorry for spam
22:33:48 <edwardk> note you can also /msg lambdabot
22:33:52 <enko> ah
22:34:58 <MostAwesomeDude> Hm, for sanity, I should always import State from Control.Monad.State, right?
22:35:28 <MostAwesomeDude> enko: No worries; this *is* a teaching and learning channel. (And yes, if you're worried about spamming, then /msg lambdabot.)
22:38:15 * hackagebot hBDD 0.0.2 - An abstraction layer for BDD libraries  http://hackage.haskell.org/package/hBDD-0.0.2 (PeterGammie)
22:38:59 <enko> so let is a global assignment?
22:39:24 <enko> will do dude
22:39:45 <MostAwesomeDude> enko: "let" creates names inside the "in" of the let.
22:40:47 <edwardk> i usually advocate puling it from Control.Monad.Trans.State unless you need the MonadState class
22:43:15 * hackagebot hBDD-CUDD 0.0.2 - An FFI binding to the CUDD library  http://hackage.haskell.org/package/hBDD-CUDD-0.0.2 (PeterGammie)
22:44:04 <enko> i let used inside .hs?
22:44:15 <geekosaur> enko: as a special case, ghci allows a sort of top-level "let"
22:44:20 <geekosaur> for local bindings, yes
22:44:27 <geekosaur> top level bindings don't use let
22:44:31 <enko> ok
23:00:02 <blackdog> I've been thinking about a fix for ghc-mod for a while.
23:03:42 <blackdog> the current situation is that it just autosaves every few seconds, which is a bit of a pain -  it screws with things like autotest, whitespace-mode, all that
23:04:49 <blackdog> but the only way i can think to do it is to create a shadow directory in /tmp, symlinking the tree, and run the checker in there
23:04:53 <blackdog> any better ideas?
23:18:28 <Gracenotes> is there a name for a minimal-size set of paths whose union is a given graph?
23:19:01 <Gracenotes> hm, not exactly haskell-related. just tangentially. >.>
23:20:52 <ghartshaw> @pl \x. f x x
23:20:53 <lambdabot> (line 1, column 3):
23:20:53 <lambdabot> unexpected "."
23:20:53 <lambdabot> expecting letter or digit, operator, pattern or "->"
23:21:04 <ghartshaw> @pl \x -> f x x
23:21:05 <lambdabot> join f
23:25:29 <ghartshaw> @pl \x y z -> x z (y z)
23:25:29 <lambdabot> ap
23:27:33 <enko> what does 'list comprehension operator' <- do?
23:28:21 <shachaf> enko: What does the letter 'a' in "map" do?
23:28:54 <enko> indicates a sound?
23:29:18 <shachaf> I don't think the identifier "map" has anything to do with sound. -)
23:30:00 <enko> is that supposed to answer my question?
23:30:12 <shachaf> More or less.
23:30:19 <shachaf> OK, "<-" isn't an operator. It's syntax.
23:30:19 <enko> thx
23:30:28 <enko> thx i
23:30:34 <enko> i'll just use google
23:30:39 <enko> long it may be
23:33:00 <enko> www.imada.sdu.dk/~rolf/Edu/DM22/F06/haskell-operatorer.pdf
23:33:17 <enko> <- List comprehension generator
23:33:17 <enko> Single assignment operator in do-constr.
23:34:13 <shachaf> <- isn't an operator and it doesn't do assignment.
23:34:50 <enko> who said anything about assignment?
23:35:10 <shachaf> 23:32 <enko> Single assignment operator in do-constr.
23:35:36 <enko> thats from that pdf
23:35:48 <shachaf> OK, so that PDF said it.
23:44:53 <Goatflakes> hi
23:47:40 <Eduard_Munteanu> Goatflakes: hi
23:48:46 <Goatflakes> explain briefly what "in" does? I found it while looking at http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html and couldn't find it in the index or standard prequel from Hutton. And just try and do a google search for haskell in and see what useless crap you get :<
23:49:39 <Goatflakes> There are a lot of uses of it in LYAH but haven't yet found where it is defined
23:49:59 <shachaf> Goatflakes: It's part of "let".
23:50:05 <shachaf> let a = b in c
23:50:10 <shachaf> > let a = 5 in a + 3
23:50:10 <geekosaur> huh?  "in" doesn't do anything, it's just syntax.  let BINDINGS in EXPRESSION
23:50:11 <lambdabot>   8
23:50:18 <Goatflakes> o i feel so stupid now :p
23:50:21 <Goatflakes> thanks
23:50:46 <Goatflakes> gtg dinner time :l
23:51:01 <geekosaur> haskell makes eveyone feel stupid initially
23:51:27 <shachaf> What, everyone?
23:51:33 * enko is still looking to find wtf <- does
23:51:59 <enko> ungooglable language
23:52:00 <shachaf> enko: In the context of list comprehensions? You're better off looking up how list comprehensions work in general.
23:52:25 <shachaf> enko: You *told* us that <- is coming from list comprehensions. You clearly know it's part of that.
23:52:40 <shachaf> And I told you it's syntax, not an operator, so you should look up list comprehension syntax.
23:53:08 <dmwit> hamishmack: Yes, main.js is smallish (only 3.5k of minified JS), but it also includes rts.js, which is a further 20k of minified JS.
23:55:13 <enko> trying to get through first page of that book, thx for you help shachaf, i clearly know very little right now, ambiguity in your answers doesnt help
23:55:48 <shachaf> enko: If you have specific questions people will be happy to answer them.
23:55:50 <dmwit> For comparison, all of jquery (which offers significantly more features than that demo, it seems) is only 12k of minified JS.
23:56:38 <enko> looking forward to it
23:57:21 <dmwit> enko: The Haskell Report tells how to translate list comprehensions into concatMap and friends.
23:57:24 <dmwit> ?where report
23:57:25 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
23:58:02 <dmwit> specifically, http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11
23:58:46 <dmwit> "[ e | p <- l, Q ] = let ok p = [ e | Q ]; ok _ = [] in concatMap ok l"
23:58:55 <dmwit> Does this answer your question?
23:59:28 <enko> yes it does
23:59:31 <enko> thank you
