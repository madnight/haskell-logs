00:00:18 <mauke> Rational is nothing like CReal
00:00:18 <theadmin> mauke: The thing is a rational (or sometimes irrational?) number...
00:00:18 <SegFaultAX> Cale: Does f have an expected type there?
00:00:28 <Cale> f :: a -> [b]
00:00:30 <Cale> xs :: [a]
00:00:36 <Cale> xs >>= f :: [b]
00:00:41 <theadmin> Oh, I see, Rational is a fraction thing
00:01:05 <mauke> theadmin: Rational is rational numbers. Double is some rationals, represented as floating point numbers. CReal is computable numbers
00:01:06 <SegFaultAX> Cale: Why would you want f to return a list if you're just going to flatten it? Wouldn't a -> b be better?
00:01:09 <dmwit> Yes, and it enjoys many things that CReal doesn't -- like decidable equality, for instance.
00:01:23 <Cale> theadmin: Thinking they're the same thing has probably resulted in at least a handful of explosions over the years...
00:01:30 <mauke> SegFaultAX: then (>>=) would be fmap
00:01:51 <mauke> SegFaultAX: and that limits you to exactly one return value per input
00:01:51 <theadmin> Cale: Well, now that I played around in ghci I see the difference between Rational and all those others at least :D
00:01:55 <Cale> SegFaultAX: because that gives f extra abilities
00:02:00 <SegFaultAX> mauke: So it just gives us the ability to map any member in xs to multiple values?
00:02:05 <dmwit> SegFaultAX: That's a good question! What if you sometimes wanted to return a b and sometimes didn't, though?
00:02:07 <mauke> SegFaultAX: if f can return a list, that also means it can "drop" values by returning []
00:02:07 <Cale> SegFaultAX: it's allowed to produce no elements
00:02:12 <Cale> SegFaultAX: or many
00:02:15 <Cale> at a time
00:02:35 <dmwit> Phew, many cooks here. I'll let the others have fun with this stew. =)
00:02:35 <theadmin> Hm... Where is CReal defined? GHCi can't find it
00:02:36 <mauke> this is where knowing Perl would help :-)
00:02:40 <Cale> > [1,2,3,4,5] >>= \x -> if even x then [x, 10*x] else []
00:02:41 <lambdabot>   [2,20,4,40]
00:02:44 <SegFaultAX> I'm starting to see how this could be used to implement list comprehensions.
00:02:58 <dmwit> ?hackage numbers <- in here, theadmin
00:02:58 <lambdabot> http://hackage.haskell.org/package/numbers <- in here, theadmin
00:03:13 <mauke> ooh, Dif
00:03:19 <mauke> that one's cool
00:03:30 <Cale> SegFaultAX: Let's take a quick look at another example
00:03:43 <Cale> I could do it in detail, but I feel like at least mentioning parsers
00:03:49 <dmwit> mauke: I think edwardk has a few automatic differentiation packages, too.
00:04:03 <dmwit> if that's the kind of thing that gets your engine revving
00:04:05 <SegFaultAX> Cale: Go for it.
00:04:24 <SegFaultAX> Cale: But after this one I should probably hit the sack. At some point, it became midnight. ;)
00:04:31 <Cale> There are a bunch of parsing libraries which define a type constructor Parser, such that a value of type (Parser t) is something which (perhaps nondeterministically) eats the initial part of a string and parses it into a value of type t
00:04:53 <SegFaultAX> Sure, that makes sense.
00:05:00 <theadmin> dmwit: I see
00:05:09 <Cale> (there might internally be a list of parses, each consisting of some value of type t, along with a depleted string)
00:05:41 <Cale> If we have any value v, we can make a parser which does nothing (eats no input) and simply produces the result v every time
00:05:49 <Cale> and that's what return v will do
00:06:00 <SegFaultAX> Cale: So each one in turn gets a whack at taking the input and converting it to the type it's responsible for?
00:06:02 <Cale> (it'll produce just one parse, in the nondeterministic case)
00:06:14 <Cale> yeah, well, let's look at >>= now :)
00:06:25 <Cale> (>>=) :: Parser a -> (a -> Parser b) -> Parser b
00:06:30 <Cale> x >>= f
00:06:35 <Cale> where x is some Parser a
00:06:55 <Cale> will be a parser which parses the initial part of the input with x, say, getting some parsed result v
00:07:07 <Cale> and then parse the remainder of the input with the parser (f v)
00:07:31 <Cale> (and under the covers, it might do this in all possible ways, backtracking and all)
00:07:49 <SegFaultAX> But how would that given parser say "I can't parse what you've given me, move on to the next one"
00:08:04 <SegFaultAX> How would I represent that with type Parser b?
00:08:12 <Cale> well, there might be a Parser which produces an empty list of parses internally
00:08:13 <SegFaultAX> Some sentinel value or something?
00:08:23 <Cale> The Monad interface won't give that to you, but it would be part of the library
00:08:37 <Cale> (MonadPlus will give it to you though :)
00:08:54 <Cale> (along with a way to do alternation between parsers :)
00:09:24 <Cale> So there will be lots of non-Monad-related stuff in our parsing library
00:09:36 <Cale> But amongst all the other stuff, we can implement these Monad operations
00:09:36 <dmwit> Cale: It might help to give a concrete definition of the Parser type.
00:09:46 <Cale> yeah, I probably should just write the code :)
00:10:01 <dmwit> newtype Parser a = Parser (String -> [(a, String)]) -- perhaps something like this is what you're thinking about?
00:10:22 <Cale> I'm going to change it up just slightly :)
00:10:27 <Cale> newtype Parser a = P (String -> [(String, a)])
00:10:27 <SegFaultAX> Is (a, String) some sort of tagged union?
00:10:34 <Cale> That's a pair type
00:10:42 <Cale> (tuple)
00:10:48 <dmwit> > (3, "hey") -- has type (Integer, String)
00:10:49 <lambdabot>   (3,"hey")
00:10:52 <Cale> newtype is the same as data
00:10:59 <Cale> roughly
00:11:15 <dmwit> values of the type (foo, bar) have both a foo and a bar in them
00:11:23 <Cale> (there are some semantic differences, and you're only allowed one data constructor with one field)
00:11:33 <SegFaultAX> Oh I see, duh.
00:11:37 <Cale> So, we have:
00:11:49 <Cale> P :: (String -> [(String, a)]) -> Parser a
00:11:52 <Cale> and
00:12:06 <Cale> runParser :: Parser a -> String -> [(String, a)]
00:12:12 <Cale> runParser (P f) s = f s
00:12:17 <SegFaultAX> What kind of concrete type of Parser might we expect in our lib?
00:12:35 <Cale> Well, I'm going to start defining a bunch of them
00:12:39 <dmwit> SegFaultAX: Cale gave the concrete type above. newtype Parser a = P (String -> [(String, a)])
00:12:55 <Cale> but for example, there might be a parser which tries to match a single character
00:13:16 <SegFaultAX> So we might have a Parser Char or something.
00:13:19 <Cale> yeah
00:13:42 <Cale> char c = P (\s -> case s of [] -> []; (x:xs) | x == c -> [(c,xs)]  | otherwise -> [])
00:13:56 <Cale> A little hard to read smushed onto one line
00:14:38 <Cale> If the input string is empty, we produce an empty list of parses, c isn't there
00:14:56 <Cale> if the input string is nonempty (x:xs), we check if x == c
00:15:16 <Cale> oh, derp, I messed up my own convention
00:15:23 <Cale> that should be [(xs,c)]
00:15:42 <Cale> So xs is our depleted input string, we eat the x
00:16:02 <Cale> and we return the c (or could use x) as our result
00:16:18 <Cale> and if x and c don't match, then the parse again fails
00:16:24 <SegFaultAX> What is P in this expression again?
00:16:37 <SegFaultAX> I don't see how this lambda is getting called here (or is it not?)
00:16:39 <Cale> P is something which makes Parser t
00:16:42 <Cale> from a function
00:16:48 <Cale> String -> [(String, t)]
00:16:52 <SegFaultAX> Oh oh.
00:16:58 <Cale> So it just wraps up the function :)
00:17:09 <dmwit> P is actually just a bit of fluff. It's only there for technical reasons -- to give the compiler a bit of a hint when it comes time to write a Monad instance.
00:17:35 <SegFaultAX> dmwit: That went right over my head. :D
00:17:53 <dmwit> (P differentiates between functions that happen to have a type that matches the form String -> [(String ,t)] and functions that we really want to think of as being parsers.)
00:18:02 <Cale> In a bit we'll want to write an instance Monad Parser
00:18:11 <Cale> and so we need a type constructor Parser
00:18:21 <Cale> and that type needs a data constructor
00:18:24 <Cale> hence, P
00:18:47 <SegFaultAX> Ohh, I see!
00:18:48 <Cale> (It's conventional to also call the data constructor Parser, but I find this discussion goes better if they have different names)
00:19:24 <SegFaultAX> And here we've just defined one of our possible parsers.
00:19:25 <Cale> Of course in the code, you can always tell which is meant by which side of a :: you're on
00:19:28 <Cale> yea
00:19:35 <Cale> actually a function for making Parsers :)
00:19:39 <Cale> Char -> Parser Char
00:19:55 <SegFaultAX> Right, we need to actually have it the char to create the parser for
00:20:11 <SegFaultAX> char 'a' will create a parser for 'a', for example.
00:20:13 <Cale> but we still need to define ways to compose small parsers together into larger ones, or this is all going to be pretty futile
00:20:17 <Cale> yeah
00:20:29 <theadmin> Can I map something to getArgs? I want to convert the list it returns to [Integer], and creating an intermediate name to hold the list of Strings is kind of... I dunno.
00:20:34 <Cale> It'll try to match 'a' at the beginning of its input, and return 'a' if it succeeds
00:20:47 <srhb> theadmin: map something "to" getArgs?
00:20:53 <Cale> theadmin: fmap (map read)
00:20:55 <SegFaultAX> Cale: But if I don't match, don't consume the 'a'?
00:20:58 <srhb> Ah.
00:20:59 <dmwit> theadmin: sure, use liftM, fmap, or (<$>) as you please
00:21:04 <Cale> fmap (map read) getArgs
00:21:19 <Cale> SegFaultAX: if it doesn't match, the whole parse fails
00:21:21 <theadmin> Hm
00:21:22 <theadmin> @src fmap
00:21:23 <lambdabot> Source not found. Do you think like you type?
00:21:32 <Cale> (and we might backtrack)
00:21:34 <dmwit> ?src Functor
00:21:34 <lambdabot> class  Functor f  where
00:21:34 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
00:21:37 <srhb> theadmin: It's the generalized map, for each functor.
00:21:45 <dmwit> ?src liftM
00:21:45 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
00:21:53 <Cale> But as far as char 'a' is concerned, the whole parse fails anyway :)
00:22:00 <dmwit> and (<$>) = fmap, but I don't think ?src knows about it
00:22:19 <Cale> SegFaultAX: and we represent that by giving an empty list of parses
00:22:24 <SegFaultAX> Cale: So how would we compose the trivial parsers together to make something meaningful?
00:22:27 <raichoo> ?src liftA
00:22:27 <lambdabot> liftA f a = pure f <*> a
00:22:36 <Cale> SegFaultAX: okay, so let's think about how to implement return and (>>=)
00:23:05 <Cale> return is fairly easy
00:23:09 <Cale> return v = ...
00:23:19 <Cale> Well, we only have one way to make parsers for the moment, which is P
00:23:21 <Cale> return v = P ...
00:23:37 <Cale> and P needs a function String -> [(String, a)]
00:23:44 <Cale> so might as well be a lambda
00:23:49 <Cale> return v = P (\s -> ...)
00:24:17 <Cale> and return v is supposed to succeed, and produce the result v, but without doing much
00:24:37 <Cale> so it's just going to return the input string untouched
00:24:44 <Cale> return v = P (\s -> [(s,v)])
00:24:51 <SegFaultAX> I'm with ya.
00:24:54 <Cale> okay
00:24:59 <Cale> So now
00:25:08 <Cale> x >>= f = ...
00:25:13 <Cale> again, might as well use P
00:25:15 <Cale> x >>= f = P ...
00:25:20 <Cale> and might as well be a lambda
00:25:22 <SegFaultAX> Wha'ts x in this case again?
00:25:23 <Cale> x >>= f = P (\s -> ...)
00:25:27 <Cale> x :: Parser a
00:25:38 <Cale> and  f :: a -> Parser b
00:25:44 <Cale> Now our goal is as follows:
00:25:51 <Cale> run x on the initial string
00:25:54 <dmwit> SegFaultAX: We're defining a function named (>>=) that takes two arguments; we're naming those arguments "x" and "f".
00:26:18 <Cale> for each parse (s',v) we want to run (f v) on the depleted string s'
00:26:50 <Cale> So we'll use the list monad!
00:27:09 <Cale> x >>= f = P (\s -> do (s',v) <- runParser x s; ...)
00:27:17 <Cale> we first run x on the initial string s
00:27:24 <Cale> getting some parses (s',v)
00:27:37 <Cale> consisting each of a depleted string s' and a result v
00:28:05 <Cale> (if you prefer, we can write this as a list comprehension)
00:28:25 <SegFaultAX> I was just going to ask, does that have the same meaing as a list comprehension
00:28:28 <Cale> yeah
00:28:44 <SegFaultAX> It unpacks the result of runParser x s into (s', v)?
00:28:44 <Cale> and now, we run (f v) on the depleted string
00:28:50 <Cale> yeah
00:29:03 <Cale> remember  runParser x s  will give us a list of all the parses
00:29:12 <Cale> and the list monad is going to pick one in all possible ways
00:29:18 <SegFaultAX> Because runParser :: Parser a -> String -> ([String, a]), right?
00:29:22 <Cale> yeah
00:29:30 <SegFaultAX> Ok, I'm with ya.
00:29:33 <Cale> okay
00:29:47 <Cale> So, running (f v) on s'...
00:30:16 <Cale> x >>= f = P (\s -> do (s',v) <- runParser x s; runParser (f v) s')
00:30:21 <Cale> this is done
00:30:34 <Cale> if you want though, we could be explicit about the result of the second runParser
00:30:35 <SegFaultAX> Wait, let me make sure I comprehend this.
00:30:52 <Cale> x >>= f = P (\s -> do (s',v) <- runParser x s; (s'',w) <- runParser (f v) s'; return (s'', w))
00:31:15 <Cale> as a list comprehension, this is:
00:31:28 <SegFaultAX> So f is a parser generator, (f v) is returning basically a concrete parser, and runParser (f v) s' is running the parser on our depleted string.
00:31:29 <Cale> x >>= f = P (\s -> [(s'',w) | (s',v) <- runParser x s; (s'',w) <- runParser (f v) s'])
00:31:35 <Cale> yeah
00:32:09 <Cale> So basically, we're parsing the initial part of the input with x, and then f will get to use x's result to determine how to parse the rest of the string
00:32:45 <Cale> For instance, maybe x parses a number on the first line of the string, and then f produces a function which eats up that many lines, and does something with them
00:33:02 <Cale> f produces a parser, rather
00:33:09 <SegFaultAX> So for example, would x be a function to split the input up into single chars, and (f v) would parse all legal single character values?
00:33:28 <SegFaultAX> Oh, I have it backwards, then.
00:33:31 <Cale> mmm... if x ate the entire input
00:33:40 <Cale> then there would be nothing left for (f v) to eat
00:33:59 <Cale> (which might be okay)
00:34:04 <Cale> (but would be unusual)
00:34:29 <Cale> Now, with this monad, we'll be able to write things like:
00:34:42 <Cale> do char 'c'; char 'a'; char 't'; return "meow"
00:35:06 <Cale> This is a parser which looks for the exact characters 'c' followed by 'a' followed by 't'
00:35:13 <Cale> and returns "meow" if it succeeds
00:35:23 <SegFaultAX> What if it doesn't?
00:35:27 <SegFaultAX> Is an exception thrown?
00:35:30 <Cale> then it gives an empty list of parses
00:35:44 <SegFaultAX> Ah.
00:35:47 <Cale> (the list of parses has length 1 on success here)
00:36:13 <Cale> Earlier I mentioned a function called sequence
00:36:26 <Cale> sequence :: (Monad m) => [m a] -> m [a]
00:36:36 <Cale> Let's write that, and see what it does to parsers
00:36:45 <Cale> sequence [] = ...
00:37:11 <Cale> well, it needs to be something of type m [a], but we don't have any values of type a or things we could run
00:37:19 <Cale> so we're basically forced to:
00:37:24 <Cale> sequence [] = return []
00:37:31 <rosie> If I have  "… where myMonad =  a >>= b >> myMonad", does myMonad evaluate itself again when it reaches the end of the block, based on its definition?
00:37:32 <Cale> sequence (x:xs) = ...
00:38:02 <auastro> hi all
00:38:06 <Cale> sequence's job will be to produce an action which will run all the actions in the list in turn and produce a list of their results
00:38:11 <Cale> sequence (x:xs) = do ...
00:38:21 <Cale> so first we run x, getting some result v
00:38:26 <Cale> sequence (x:xs) = do v <- x; ...
00:38:33 <SegFaultAX> So it's like a scanl for monads or something?
00:38:36 <Cale> and then we run the rest of the list, getting some vs
00:38:38 <srhb> rosie: try let foo = putStrLn "foo" >> foo
00:38:42 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; ...
00:38:50 <Cale> and then we stick those together
00:38:55 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
00:39:07 <dmwit> rosie: No, myMonad is shared.
00:39:09 <auastro> qq: I'm trying to run an edge version of haskell, however I'm having trouble setting up a functioning cabal setup
00:39:26 <Cale> SegFaultAX: it's not exactly analogous to any given list function
00:39:44 <auastro> basically cabal refuses to install anything at all because of a dependency on base <4.5
00:39:45 <Cale> (except maybe the identity function, but that's boring)
00:39:46 <rosie> srhb: Thanks! I found infinite recursion.
00:39:54 <SegFaultAX> Cale: :D
00:39:57 <rosie> dmwit: what do you mean by "shared"?
00:40:04 <Cale> Now, *in* the list monad
00:40:05 <srhb> rosie: :-)
00:40:12 <Cale> sequence :: [[a]] -> [[a]]
00:40:19 <Cale> but this isn't the identity function at all
00:40:22 <auastro> *sorry base <4.6
00:40:27 <Cale> remember, it's going to run each of the lists in turn
00:40:51 <dmwit> rosie: I mean "myMonad" points to a thunk, and once that thunk is evaluated, it won't ever get evaluated again.
00:40:52 <srhb> rosie: It is not recomputed, but reused after the first time around
00:41:02 <Cale> and produce (a list of all possibilities for) a list the results
00:41:14 <Cale> So it'll pick one element from each list in all possible ways
00:41:20 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
00:41:21 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
00:41:25 <dmwit> rosie: If myMonad :: IO a for some a, then we will need to carefully distinguish between evaluation and execution, though!
00:41:39 <Cale> SegFaultAX: cool?
00:41:50 <SegFaultAX> Cale: Yup.
00:41:59 <dmwit> rosie: Evaluation is the pure part of Haskell: it turns thunks into values. Execution is the impure part done by the RTS: it turns values of type IO a into a sequence of actual observable events.
00:41:59 <Cale> Okay, so what if we feed it a list of parsers?
00:42:01 <SegFaultAX> Cale: How does that help us with our parser, though?
00:42:16 <srhb> rosie: (you can try something less insane like let foo = getLine >>= putStrLn >> foo -- foundation of a REPL :-))
00:42:22 <Cale> Well, it'll give us a parser which will run each parser in the list, and give a list of their results
00:42:34 <Cale> which is exactly a concatenation of parsers
00:42:35 <SegFaultAX> Ohhhh!
00:42:53 <Cale> Now, if we take some string
00:42:54 <SegFaultAX> Yes, I see!
00:43:00 <Cale> and we map the  char  parser over that string
00:43:06 <Cale> and then sequence the parsers together
00:43:14 <Cale> we get a parser for matching a given string
00:43:26 <SegFaultAX> Holy shit.
00:43:26 <Cale> and this happens to have a name
00:43:32 <silver> hello there, I was wondering if the ghc-on-arm thing went somewhere
00:43:35 <Cale> mapM f xs = sequence (map f xs)
00:43:38 <SegFaultAX> All of the sudden I see it.
00:44:32 <Cale> So we could just define   string = mapM char
00:44:38 <Cale> string :: String -> Parser String
00:45:01 <Cale> Now, just to complete the picture a little more, this has nothing to do with monads...
00:45:01 <SegFaultAX> And we can trivially generate parsers for arbitrary strings?
00:45:06 <Cale> yeah
00:45:11 <SegFaultAX> Wow.
00:45:31 <Cale> We can implement alternation, that is OR for parsers
00:45:36 <SegFaultAX> Seriously, I was struggling to follow the path this was taking until you explain sequence.
00:45:45 <SegFaultAX> Then it hit me like a ton of bricks.
00:45:58 <Cale> (+++) :: Parser a -> Parser a -> Parser a
00:46:17 <Cale> x +++ y = P (\s -> runParser x s ++ runParser y s)
00:46:35 <Cale> We can also write a parser which always fails
00:46:41 <Cale> zero = P (\s -> [])
00:47:23 <Cale> Actually, I can sorta tie this back to at least the stuff in Control.Monad, because there's another class in there called MonadPlus for monads that have operations like this
00:47:33 <Cale> instance MonadPlus Parser where
00:47:37 <Cale>   mzero = zero
00:47:42 <Cale>   mplus = (+++)
00:47:47 <SegFaultAX> Oh neat, +++ makes it so you can build up parsers.
00:47:50 <Cale> yeah
00:47:57 <Cale> making choices between possibilities
00:48:01 <Cale> So we can do
00:48:06 <SegFaultAX> But wouldn't you want Parser a -> Parser a -> Parser b?
00:48:35 <Cale> many p = (do v <- p; vs <- many p; return (v:vs)) +++ (return [])
00:49:01 <rosie> Thank you, dmwit and srhb! If I have a "return" in the sequence that leads up to the >> foo, where foo is the thunk we've been referring to, why does the foo not get evaluated?
00:49:05 <Cale> nope, we want the result to be the same type
00:49:12 <Cale> we're choosing one or the other
00:49:19 <Cale> so the result will have the same type as the one we chose
00:49:35 <SegFaultAX> Ah, so we can alternate between parsers?
00:49:36 <Cale> and since all the results have to go in the same list of parses, the arguments better have the same type
00:49:39 <Cale> yeah
00:49:46 <mauke> 'many' is * in regexes
00:49:49 <Cale> and this 'many' is basically the * in...
00:49:50 <Cale> yes
00:49:55 <SegFaultAX> Parsers of the same type, essentially.
00:50:01 <mauke> sorry, I'll stop reading your mind
00:50:02 <SegFaultAX> Ohh, I see.
00:50:18 <SegFaultAX> Haha, nice.
00:51:13 <SegFaultAX> Actually, it seems now like you could implement a simple regular expression engine pretty simply with some of the primitives we've just discussed.
00:51:21 <Cale> And we can add a bunch of stuff to this and pick a more efficient representation for parsers, and generalise over the type of input stream, and jeopardise our nicely fair alternation operator in the name of efficiency, and so on, and we'll end up with Parsec
00:51:33 <Cale> yep
00:51:47 <Cale> But who needs regexes anymore
00:51:53 <mauke> you can also implement the compiler feeding the engine
00:51:57 <Cale> we can define parsers in Haskell, and they'll actually turn out pretty :)
00:52:04 <mauke> Parser (Parser String)
00:52:08 <Cale> haha
00:52:10 <Cale> yes
00:52:16 <SegFaultAX> Man, I'm starting to fall for Haskell.
00:52:20 <mauke> that's a parser that turns regex strings into parsers
00:52:54 <mauke> Cale: that's why I think regexes are actually a good application
00:52:57 <SegFaultAX> I think this weekend I'll finally switch over to xmonad just so I have a reason to get really down and dirty.
00:53:01 <mauke> it naturally leads to higher order parsers :-)
00:53:04 <Cale> yeah, I have to agree that is really cute
00:53:33 <Cale> SegFaultAX: and so now you can look through the library documentation for Control.Monad
00:53:44 <Cale> and try to imagine what each of the things does in all these various contexts
00:53:55 <Cale> of lists and Parsers and IO actions and Maybe...
00:54:03 <mauke> oh my
00:54:16 <SegFaultAX> I'll have to save that for this weekend.
00:54:37 <SegFaultAX> I'm about to pass out from exhaustion. It's 1am here :D
00:54:40 <Cale> replicateM n x = sequence (replicate n x)
00:54:50 <Cale> > replicateM 5 "01"
00:54:51 <lambdabot>   ["00000","00001","00010","00011","00100","00101","00110","00111","01000","0...
00:54:56 <mauke> @localtime SegFaultAX
00:54:57 <Cale> counting in binary :)
00:54:58 <lambdabot> Local time for SegFaultAX is Fri Jun 22 00:54:45 2012
00:55:04 <Cale> @localtime Cale
00:55:04 <lambdabot> Local time for Cale is Fri Jun 22 03:54:43
00:55:08 <Cale> :D
00:55:14 <mauke> @localtime
00:55:17 <lambdabot> Local time for mauke is Ｆｒｉ Ｊｕｎ ２２ ０９：５４：５３ ２０１２
00:55:17 <Cale> I have to be up at 10am too
00:55:27 <SegFaultAX> Cale: East Coast USA?
00:55:34 <Cale> Ontario, Canada
00:55:40 <SegFaultAX> Ah, cool!
00:55:46 <SegFaultAX> I'm in California.
00:56:24 <SegFaultAX> So one last question, what's the link to your tutorial on Monads you said I should read?
00:56:37 <mauke> @google monads as computations
00:56:39 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_computation
00:56:39 <lambdabot> Title: Monads as computation - HaskellWiki
00:56:42 <shachaf> SegFaultAX: You shouldn't read any tutorial on monads right now.
00:56:45 <AfC> Somebody needs to cut and paste this conversation into a blog post
00:56:49 <shachaf> Seriously. Did you see what the FAQ said?
00:56:57 <Cale> haha
00:57:05 <shachaf> AfC: It wouldn't help because people ignore all the links you give them in this channel.
00:57:06 <Cale> Well, my tutorial is more of a metatutorial anyway
00:57:26 <Cale> I actually wrote Monads as Computation not for the people who are reading monad tutorials
00:57:34 <Cale> I wrote it for the people who were writing them
00:57:41 <mauke> shachaf: you know, monad tutorials don't even faze me now
00:57:55 <Cale> But it should still be good if you're learning :)
00:57:58 <mauke> having wrestled perl internals for days
00:58:32 <rosie> I have a recursive function foo = x y z >>= if yes then return something else modify_state >> foo. Why does the evaluation of the return statement prevent "foo" from getting evaluated?
00:58:38 <Cale> (there was a really big glut of monad tutorials at one point almost all of which were missing the point in various ways)
00:58:56 <mauke> rosie: it doesn't
00:59:21 <mauke> rosie: ... precedence?
00:59:48 <rosie> ahh, I have case d of Nothing -> return Nothing     Just y -> if etc. >> foo
01:00:04 <rosie> So the >> foo only gets evaluated if the Just branch is taken?
01:00:11 <Cale> yes
01:00:20 <Cale> (and executed too)
01:00:22 <mauke> use more parens
01:00:24 <rosie> Thanks mauke and Cale!
01:00:58 <SegFaultAX> Well I'm still working through LYSH so once I get to Monads I'll revisit that link.
01:01:14 <Cale> itym LYAH btw
01:01:22 <SegFaultAX> Anyway, I'm going to crash. Good night all! Cale, thank you so much!
01:01:27 <mauke> have fun
01:01:32 <SegFaultAX> Oh. whoops. Thank you again!
01:02:06 <SegFaultAX> mauke, shachaf: Thanks for the help and guidance as well.
01:03:53 <kallisti> I find the way that the word "executed" is used in the context of monads to be a bit odd.
01:03:55 <rosie> In this line of code: "evalState bfs (enqueue [x] emptyQueue,Set.singleton x)
01:03:56 <rosie>   where bfs = bfsDequeue >>=" does parameter to the bfs monad get evaluated before the definition of bfs?
01:03:57 <donri> Cale: ITYM "ITYM LYAH BTW" BTW
01:04:00 <kallisti> it's not different from any other kind of evaluation.
01:04:09 <donri> gotta upcase them abbreviations
01:04:22 <shachaf> kallisti: It's completely different.
01:04:24 <Cale> I was considering joining them all together too
01:04:26 <shachaf> It has nothing to do with evluation.
01:04:29 <donri> :)
01:04:33 <Cale> ITYMLYAHBTW
01:05:42 <mauke> rosie: no
01:05:49 <mauke> but I don't think that's what you wanted to ask
01:06:00 <kallisti> shachaf: you do not have me convinced, so far. :)
01:06:19 <rosie> mauke: I need a way to initialize the state of the monad before I define it
01:06:35 <mauke> no, you don't
01:06:43 <shachaf> kallisti: Let's use IO as an example because I'm a bad person like that.
01:06:47 <mauke> and bfs is not a monad
01:06:55 <kallisti> shachaf: well yeah, it makes perfect sense now.
01:07:02 <shachaf> Huh?
01:07:24 <rosie> mauke: Please tell me more
01:07:44 <kallisti> the word execute in the context of executing side-effects from IO makes perfect sense.
01:07:45 <mauke> ooh, about what?
01:07:47 * hackagebot buildwrapper 0.6.0 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.6.0 (JeanPhilippeMoresmau)
01:07:49 * hackagebot scion-browser 0.2.9 - Command-line interface for browsing and searching packages documentation  http://hackage.haskell.org/package/scion-browser-0.2.9 (JeanPhilippeMoresmau)
01:07:59 <rosie> mauke: What is bfs if it's not a monad?
01:08:07 <mauke> rosie: a value
01:08:18 <mauke> rosie: a monad is a type constructor
01:08:24 <rosie> ahhh
01:08:26 <rosie> yep
01:08:42 <mauke> so ... Maybe is a monad, but Just 42 is a value
01:08:54 <rosie> so, let's say I have bfs, which is an instance of the Maybe typeclass
01:08:59 <mauke> no
01:09:02 <dmwit> Maybe is not a type class.
01:09:03 <mauke> Maybe is not a typeclass
01:09:16 <mauke> and bfs is not an instance, it's a value
01:09:25 <rosie> ah, sorry, Maybe is a monad
01:09:32 <mauke> Maybe is an instance of a few classes, though
01:09:55 <dmwit> (The term "type class" comes from the math term "class", meaning roughly a really big set.)
01:10:09 <shachaf> dmwit: And the terms "instance" and "method"?
01:10:21 <dmwit> shachaf: unfortunate choices =)
01:11:41 <dmwit> rosie: I think you're asking the wrong questions. But it's a little bit tough to know what questions to suggest for you going only by the questions you've asked so far.
01:12:19 <dmwit> You might consider posting some code that doesn't work and telling how it's broken, or posting some code that works and asking why it works.
01:12:33 <dmwit> (If you're into the "shut up and calculate" version of learning.)
01:12:42 <mauke> hah
01:13:00 <mauke> "help! I've written this program and it works perfectly. WHY?!"
01:13:25 <ciaranm> i know someone who lectures first year programming who loves to ask that question of students' code
01:13:26 <dmwit> =)
01:13:51 <ciaranm> he's of the opinion that it's too easy to just sit down and tinker until something seems to work
01:14:00 <dmwit> Though more likely, the intro to that question is "I found this code on a blog post/monad tutorial/github repository and it works perfectly."
01:14:04 <dmwit> .
01:14:14 <ciaranm> so he makes first years explain their code. it's quite funny to watch.
01:14:19 <mauke> see also: edwardk
01:14:37 <shachaf> edwardk?
01:14:45 <mauke> ciaranm: people tend to get pissed off when I try that on IRC
01:15:08 <mauke> or they don't understand the question
01:15:36 <ciaranm> people who haven't done the pure maths half of a maths degree shouldn't be allowed to program
01:20:05 <hpaste> Rose pasted “breadth first search” at http://hpaste.org/70298
01:21:01 <rosie> I'd like to know when (enqueue [x] emptyQueue,Set.singleton x) gets evaluated, relative to the definition of bfs in the where clause
01:21:17 <mauke> does it make a difference?
01:22:22 <mauke> a monad is not a typeclass. 'Monad' is a typeclass.
01:22:35 <mauke> a monad would be a type constructor that's an instance of Monad
01:23:55 <ciaranm> a monad is just a monoid in the category of endofunctors. what's the problem?
01:26:51 <Ralith_> isn't "it doesn't matter when things get evaluated" rather the point of referential transparency?
01:27:54 <ciaranm> sort of
01:28:02 <ciaranm> unless you start talking about _|_
01:28:40 <Ralith_> let's not talk about _|_
01:28:40 <Ralith_> :D
01:29:41 <rosie> Thanks, mauke. It appears that I have a chicken-and-the-egg problem here. I can't define bfs until I've set its initial value, but I don't know what type bfs is until I define it. Before bfs knows its type, does it just hold on to the first parameter, and then when it needs it later, it uses it?
01:30:25 <mauke> rosie: bfs has no "initial value" or "parameter"
01:30:59 <mauke> I'm confused about what your confusion is
01:35:10 <t7> > read "" :: Int
01:35:11 <lambdabot>   *Exception: Prelude.read: no parse
01:35:44 <rosie> mauke: I'm misunderstanding this line of code: evalState bfs (enqueue [x] emptyQueue,Set.singleton x) . Could you clarify it?
01:36:57 <mauke> this says: execute the "state machine" bfs with an intial state of (enqueue [x] emptyQueue,Set.singleton x), throw the final state away, and return the result of executing bfs
01:39:41 <rosie> mauke: Thanks! How does the bfs know it's a state machine before it has been defined? It seems that if bfs were defined before we give it its initial state, it will need to know the initial state in order to complete its definition.
01:41:03 <ciaranm> rosie: what do you think a state machine is?
01:41:06 <srhb> evalState :: State s a -> s -> a
01:41:41 <mauke> rosie: bfs is defined before you give it an initial state
01:41:44 <mauke> and it's not "its" state
01:42:28 <mauke> rosie: how do functions know they're functions before they're defined? it seems that if a function were defined before we give it its argument, it will need to know the value of the argument in order to complete its definition
01:43:17 <rosie> mauke: I see. Thank yu. I'm still trying to find a good definition of a state machine in the context of haskell
01:43:52 <mauke> well, it's not really a state machine
01:44:14 <rosie> which is?
01:44:14 <mauke> but you can think of bfs as a machine that does some work involving a "current state"
01:44:20 <mauke> bfs
01:44:45 <mauke> 'bfs = ...' just constructs the machine
01:45:03 <mauke> it doesn't need to have access to the materials it's going to work with in the future
01:45:06 <mauke> we're just building the machine
01:45:19 <mauke> later on we can then run the machine with various inputs
01:45:41 <rosie> where a state machine is a sequence of statements that carries with it and may modify a state?
01:46:03 <rosie> mauke: Thanks!
01:46:32 <mauke> yeah
01:46:50 <mauke> keeping in mind that this "machine" is an ordinary haskell value
01:46:59 <mauke> that is, a data structure
01:47:59 <rosie> Thanks so much, mauke!
01:48:43 <shachaf> thauke
01:52:15 <roconnor_> @seen amiller
01:52:15 <lambdabot> Unknown command, try @list
01:52:22 <roconnor_> preflex: seen amiller
01:52:22 <preflex>  amiller was last seen on #haskell 3 hours, 33 minutes and 32 seconds ago, saying: that's totally true
01:52:31 <amiller> 'lo
01:52:48 * hackagebot snaplet-environments 0.1.1 - DEPRECATED! You should use standard Snap >= 0.9 "environments" functionality. It provided ability to easly read configuration based on given app environment given at command line, envs are defined in app configuration file  http://hackage.haskell.org/package/snaplet-environments-0.1.1 (KamilCiemniewski)
01:56:50 <rosie> I'm trying to figure out the return function. Its definition is "Inject a value into the monadic type," as in return :: Monad m => a -> m a. What is the action we're creating if we say, return Nothing?
01:57:30 <donri> rosie: Just Nothing
01:57:46 <shachaf> donri: Huh? Who said anything about Maybe?
01:57:58 <donri> shachaf: "return Nothing"
01:58:09 <shachaf> donri: Has type m (Maybe a)
01:58:11 <shachaf> rosie: You should probably read one of the introductions to Monad listed in the FAQ, if you already understand all the prerequisites for it.
01:58:17 <donri> shachaf: true :)
01:58:24 <rosie> thanks, will do.
01:58:24 <shachaf> @where faq
01:58:25 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
01:58:25 <donri> silly me
01:58:47 <donri> need more coffee
02:00:54 <Botje> rosie: that's an action that yields a Nothing value
02:08:49 <womb> Hi guys!
02:08:52 <womb> :}
02:08:57 <womb> it is my last day in London
02:09:42 <ciaranm> no, you'll be stuck there for another two weeks due to strikes
02:09:53 <Botje> womb: good plan. get out before the olympics start.
02:12:48 * hackagebot hamlet 1.0.1.4 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.0.1.4 (MichaelSnoyman)
02:14:04 <stj> If I try to install anything with cabal, I get this error: cabal: shell-init: error retrieving current directory: getcwd: cannot access parent directories: No such file or directory ghc-pkg: getCurrentDirectory: does not exist (No such file or directory)
02:14:36 <stj> I manually removed xmobar directory in .cabal/packages/*/ and since then I get this annoying error
02:15:43 <Lemmih> stj: 'cabal update' maybe?
02:16:02 <Botje> stj: it looks like you are in a directory that no longer exists.
02:16:08 <Baughn> stj: ..what's your shell's current working directory?
02:16:43 <stj> Lemmih: doesn't help
02:17:14 <stj> Baughn: oh yes, I had to move to a different directory, thanks :)
02:18:40 <Botje> even more fun is removing your user from the system while still logged in.
02:20:52 <Baughn> "You don't exist. Go away."
02:23:54 <Botje> indeed
03:53:05 <mekeor> is yi as an awesome editor as xmonad is an awesome window manager? (i hope the grammer of this question is correct… please correct me if not.)
03:53:28 <ciaranm> xmonad isn't awesome!
03:53:31 <bitonic> mekeor: no
03:53:40 <bitonic> and xmonad isn't that awesome :P
03:54:02 <srhb> mekeor: is Yi as awesome an editor*... :-)
03:54:22 <mekeor> srhb: but that's not grammer :P
03:54:27 <srhb> mekeor: What!
03:54:32 <ciaranm> awesome is better than xmonad
03:54:34 <mekeor> ciaranm: yea, it's even better than awesome.
03:54:37 <srhb> I assumed you meant grammar, and it so is. :P
03:54:50 <mekeor> grammar… oh…
03:55:15 <mekeor> ciaranm: no.
03:55:20 <bitonic> mekeor: I prefer other stuff, but if you want a very extensible wm, xmonad is up there with sawfish and the other common lisp one.
03:55:34 <srhb> Sawfish is CL? O_o I never knew.
03:55:39 <bitonic> isn't it?
03:55:45 <mekeor> bitonic: i am using xmonad. it's great! i love it.
03:55:55 <mekeor> but what about yi? is it that great, too?
03:56:03 <srhb> bitonic: Yes, you are right.
03:56:04 <bitonic> srhb: ah no, it's their own lisp
03:56:20 <srhb> bitonic: Well, a Lisp at any rate :P
03:56:24 <bitonic> but it's pretty similar to CL, iirc.
03:56:28 <bitonic> the other is stumpwm
03:56:42 <bitonic> mekeor: yi is not nearly as mature as xmonad. emacs is the best editor.
03:57:28 <ciaranm> mekeor: YES!
03:57:40 <mekeor> i am using emacs. but i don't really like its GUI… it wastes too much space, IMO. i actually like to open many emacs-windows so…
03:57:57 <bitonic> mekeor: then you're using emacs wrong
03:58:05 <bitonic> you can split the window
03:58:05 <srhb> Will Haskell become dependently typed?
03:58:13 <mekeor> ciaranm: xmonad is awesome (i mean, even better than awesome) because haskell is awesome.
03:58:41 <ciaranm> unfortunately it is possible to write crappy software in haskell
03:58:45 <mekeor> bitonic: with "window" i mean, emacs-windows. not window-manager-windows which are called emacs-frames.
03:59:04 <int-e> mekeor: I disable toolbar and menu bar as a rule. then it has a scrollbar and two lines at the bottom that are wasted ... not so bad.
03:59:40 <int-e> (it's also possible to get rid or reduce the size of the fringes)
03:59:43 <bitonic> mekeor: wait I don't get it. Are you using multiple emacs frames in a single emacs window (as it should be)?
04:00:03 <quicksilver> bitonic: you have those words backwards.
04:00:08 <mekeor> yea, i disable toolbar and scrollbar (but not menubar)…
04:00:12 <srhb> bitonic: multiple Emacs windows* in one Emacs frame*
04:00:31 <bitonic> quicksilver: right, I always do, sorry mekeor, read the other way around
04:00:37 <mekeor> :D
04:00:47 <mekeor> bitonic: yea, i have multiple windows in one frame.
04:00:54 <t7> that feel when you have to write your tutorial in javascript to get a larger target audience :(
04:01:11 <mekeor> t7: :/
04:01:14 <bitonic> mekeor: OK then I think I don't see where emacs wastes space
04:01:16 <srhb> t7: Write it in Haskell and compile to JavaScript, let people sort it out.
04:01:22 <srhb> <_<
04:01:29 <t7> lol
04:01:41 <mekeor> bitonic: well, also, maybe the bigger problem with emacs, imo, is that it uses (emacs-)lisp, not haskell.
04:02:01 <t7> $forcethunk($a($a(deref(x))))
04:02:15 <bitonic> mekeor: that's annoying but hardly a major problem. and emacs lisp just got a lot better with emacs24
04:02:33 <srhb> t7: :-)
04:02:50 <mekeor> bitonic: how did it change?
04:03:08 <bitonic> mekeor: you can enable lexical scoping
04:03:10 <srhb> t7: "This tutorial may or may not be representative of idiomatic Javascript fsv. of idiomatic Javascript"
04:03:37 <flux> mekeor, you only need to write a compiler from haskell to emacs lisp
04:03:43 <bitonic> mekeor: and you have closures (which is a related feature), iirc. those things were, by far, emacs lisp biggest problem
04:03:47 <hpd> mekeor: please make a haskell-compiler that supports image-based-development as well as the various lisps
04:04:19 <mekeor> hpd /= hpd ?
04:04:23 <mekeor> hpc, i mean.
04:04:37 <mekeor> bitonic: hmm…
04:04:55 <hpc> gah, there's an hpd now
04:05:06 <hpc> how will i tell which one is me?
04:05:12 <hpd> hpc: I'm sorry ;)
04:05:16 <hpc> :D
04:05:26 <bitonic> mekeor: and anyway, it's really not that bad.
04:06:54 <bitonic> mekeor: if the language is decent, it does not make that much of a difference if you have to code in that or in your favourite language. at least that's what I found
04:09:48 <mekeor> bitonic: you're probably right…
04:12:26 <quicksilver> bitonic: it may not make much long term direct difference to productivity, but it may affect enjoyment and motivation :)
04:12:44 <quicksilver> (which can certainly affect productivity depending on individuals and circumstances)
04:13:12 <mekeor> yea, i actually don't want to learn a programming language for just one editor… that's kinda waste… it's demotivational.
04:13:45 <srhb> Emacs Lisp does give you a lot of knowledge about Lisps in general though.
04:13:47 <ciaranm> all the good editors have their own programming language
04:13:58 <ciaranm> which is true because vim has its own, and there are no other good editors
04:14:02 <adimit> better emacs-lisp than viml. Talk about demotivational. Not to speak of the horrible haskell-support of vim (which I attribute mostly to viml being such an abomination of a language)
04:14:13 <srhb> ciaranm: Shame it doesn't have a _good_ programming language though. ;)
04:14:22 <ciaranm> there is that
04:14:42 <MostAwesomeDude> Hm. I do Haskell in vim.
04:14:51 <MostAwesomeDude> Granted, I don't care for any features besides syntax highlighting.
04:14:55 <adimit> MostAwesomeDude: as do I.
04:15:02 <adimit> wouldn't you like at least proper indentation?
04:15:09 <MostAwesomeDude> adimit: In Haskell? >:3
04:15:13 <srhb> It's entirely doable. I don't mind doing Haskell in Vim. Then again, Haskell is so much more editor agnostic than many other languages imo.
04:15:24 <MostAwesomeDude> vim ships with indentation for do/let/where blocks; that's enough for me.
04:15:35 <ciaranm> indent-based languages are nasty from an editing perspective anyway
04:15:42 <ciaranm> also they discriminate against blind people
04:15:43 <adimit> MostAwesomeDude: of course. I would also like aligning for brackets and where/case/if statements.
04:15:55 <MostAwesomeDude> ciaranm: Hi, you're in #haskell. Haskell is whitespace-sensitive. :3
04:16:01 <mekeor> ciaranm: haskell is not indent-based anyway.
04:16:14 <srhb> ; and {} should help.
04:16:15 <mekeor> ciaranm: you can use { and } and ;
04:16:42 <MostAwesomeDude> adimit: Aligning for Haskell is tricky and I wouldn't expect a general editor to get it right 100% of the time. Hell, *I* don't get it right most of the time.
04:16:58 <adimit> I considered switching to emacs & evil for haskell development, but emacs has its other drawbacks (like, no fugitive.)
04:17:07 <srhb> adimit: That's what I use.
04:17:07 <osfameron> fugitive?
04:17:12 <MostAwesomeDude> The whole , idiom is still super-annoying to me, although when in Rome, etc.
04:17:16 <ciaranm> fugitive!
04:17:19 <adimit> MostAwesomeDude: not 100%, but 80% would go a long way.
04:17:41 <Adeon> fugitive is a git plugin
04:17:44 <srhb> ciaranm: It's called magit and it eats fugitive for breakfast
04:17:50 <Adeon> for vim
04:17:54 <Adeon> according to first google result
04:17:54 <srhb> Oh, that was adimit
04:18:08 <ciaranm> does emacs have a decent editor plugin yet?
04:18:09 <adimit> srhb: emacs isn't bad, but no way I'm using magit. Magit doesn't seem to have three-way-diffs.
04:18:23 * osfameron doesn't understand editor plugins for git
04:18:24 <adimit> and i couldn't find out how to stage incremental commits.
04:18:45 <ciaranm> osfameron: git add -i in your editor
04:18:49 <adimit> osfameron: you do git add -i on every commit? No thank you, never going back to *those* days.
04:19:00 <MostAwesomeDude> $ git add -p
04:19:09 <osfameron> I use git gui mostly
04:19:15 * srhb thinks we have veered off-topic
04:19:22 <adimit> editor wars!
04:19:39 <mekeor> osfameron: using mouse? no thank you, never going back to *those* days.
04:19:41 <ciaranm> at least no-one's still pretending they use darcs instead of git
04:19:56 <MostAwesomeDude> ciaranm: Hi, welcome to #haskell!
04:20:10 <bitonic> quicksilver: yeah, that's true. but I get over it really quickly. moreover, I really get attached to tools, even if they're warty.
04:20:25 <bitonic> quicksilver: so emacs is beautiful to me!
04:20:45 <osfameron> git gui gave me more context than git add -i... maybe I'll try out fugitive then
04:21:15 <adimit> osfameron: you watch this: http://vimcasts.org/episodes/fugitive-vim-exploring-the-history-of-a-git-repository/ (and now!)
04:21:27 <adimit> wait, not the right episode.
04:21:35 <bitonic> ciaranm, adimit: yeah I think that viml would be too much, for what I've seen
04:21:46 <mekeor> how hard would it be to write your own editor with textual and graphical frontend in haskell?
04:21:47 <hpc> is there a better way to export qualified modules than CPP/#include
04:21:59 <adimit> osfameron: just watch 'em all: http://vimcasts.org/episodes/archive
04:22:08 <adimit> mekeor: look at Yi.
04:23:11 <adimit> bitonic: it is. Believe me. I yearn for a vim that has at least an embedded lua (not like the half-hearted support they've already included, but on a more 'native' level, so that you wouldn't need viml at all.)
04:23:32 <osfameron> viml?
04:23:32 <bitonic> mekeor: reaching the support and maturity and environment and community of emacs/vim is an incredible effort.
04:24:37 <mekeor> adimit: i only want (1) a textual and a (2) graphical user inteface and (3) syntax-highlighting and (4) maybe (later) indentation modes for programming languages.
04:24:45 <bitonic> mekeor: emacs took 3 decades to reach this stage
04:24:55 <mekeor> wtf.
04:25:04 <t7> any regex wizard in here?
04:25:07 <adimit> mekeor: Yi pretty much fits your description.
04:25:15 <mekeor> bitonic: but i won't use C+elisp. i will use Haskell =)
04:25:16 <adimit> but it's pretty immature.
04:25:21 <hpc> t7: depends on the dialect; what's your question?
04:25:38 <MostAwesomeDude> mekeor: You are asking for software which takes decades to mature; it can't possibly be a surprise that only the older software has reached that point.
04:25:42 <mekeor> adimit: anyway. i want to program it myself and i don't want more features.
04:25:51 <bitonic> mekeor: that will probably make it harder - people don't use Haskell
04:25:51 <MostAwesomeDude> It's like trying to make wine in a matter of hours instead of years.
04:26:29 <mekeor> the time has changed. there are lots of haskell-libraries which would help me.
04:26:33 <hpc> MostAwesomeDude: you use a lorentz brewery
04:26:44 <hpc> it accelerates you to nearly the speed of light, leaving the wine stationary
04:26:48 <mekeor> the emacs-hackers had to program everything themselves...
04:26:51 <bitonic> mekeor: Sublime Text and TextMate have managed to get really popular really quickly, but they're still painfully inferior to emacs
04:27:00 <hpc> you come out in a few years experiencing no passage of time, and the wine is ready to drink
04:27:18 <hpc> er, winery
04:27:27 <t7> hpc, i want to parse lambda expression into tokens, eg "(\\x.xx x)" = ["(", "\\", "x", ".", "xx", "x", ")"]. (not how variables can be more than 1 character).  I thought it would be [()\\.]|^[\s()\\.]* but that didnt work
04:27:43 <bitonic> mekeor: but those two started with the wrong premises anyway
04:27:52 <hpc> :t lex
04:27:53 <lambdabot> String -> [(String, String)]
04:27:53 <mekeor> bitonic: i don't want an emacs… just a text editor. not an OS ;)
04:28:20 <quicksilver> t7: that ^ needs to be inside the []
04:28:26 <bitonic> mekeor: it's not about emacs being an "OS", it's about extensibility. people make what they want of emacs
04:28:29 <adimit> sublime text is fancy, and that's that.
04:28:30 <hpc> t7: lex returns a list of lexing matches, (token, remainder)
04:28:37 <quicksilver> t7: and that * probably wants to be a +
04:28:49 <MostAwesomeDude> hpc: Okay. I would accept this as a reasonable way to accelerate software maturity. :3
04:28:58 <hpc> and you can unfold it to get a list
04:29:02 <quicksilver> t7: and currently that will reject whitespace entirely.
04:29:09 <hpc> :t unfoldl
04:29:10 <lambdabot> Not in scope: `unfoldl'
04:29:13 <hpc> @hoogle unfold
04:29:14 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
04:29:14 <lambdabot> Data.Tree unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
04:29:14 <lambdabot> Data.Tree unfoldForestM :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
04:29:34 <hpc> :t unfoldr (listToMaybe . lex)
04:29:35 <lambdabot> String -> [String]
04:29:40 <hpc> voila!
04:29:53 <srhb> @index listToMaybe
04:29:54 <lambdabot> Data.Maybe
04:29:57 <srhb> of course..
04:30:00 <hpc> > unfoldr (listToMaybe . lex) "(\\x.xx x)"
04:30:02 <lambdabot>   ["(","\\","x",".","xx","x",")","","","","","","","","","","","","","","",""...
04:30:20 <t7> too bad im using javascript
04:30:24 <hpc> oh...
04:30:25 <hpc> crap
04:30:53 <hpc> i don't think you can do it with a single regex
04:31:04 <Botje> t7: /(\w+|\S)/ then.
04:31:37 <hpc> but you can have a list of regexes a la alex
04:31:43 <t7> [()\\.]|[^\s()\\.]+
04:31:51 <hpc> and then pull $1 out of all of them (to use perl syntax)
04:31:53 <t7> that seems to work....
04:32:13 <hpc> t7: ooh, nice
04:32:23 <hpc> afaict, that will work
04:32:43 <hpc> you might need to double-escape, \\s, \\\\
04:33:49 <adimit> t7: you could also try fiddling around: http://refiddle.com/
04:49:27 <osfameron> adimit: ok, vimcasts++, I'll play with fugitive at weekend :-)
04:49:29 <t7> i like to fiddle to something a little more erotic
04:49:46 <Botje> I didn't know you played the violin
04:50:33 <adimit> good, another convert.
04:50:38 * t7 genuinely used to play the violin
04:56:50 <tdammers> fugitive is pretty useful
05:00:32 <liborw> :q
05:04:53 <teneen> In the canonical definition of the fibonnaci sequence in terms of zipWith, is the result list something like [0,1,1,2,3,5..] or [0,1,0+1,(0+1)+1,(0+1)+((0+1)+1)..]
05:05:12 <teneen> if it's the latter, then why is it so fast even in ghci?
05:05:30 <quicksilver> that question is not very well formed
05:05:34 <quicksilver> but it's more like
05:05:35 <ciaranm> ghc is magic
05:05:49 <quicksilver> [0,1,(prev+prevprev),(prev+prevprev)....
05:05:57 <Botje> teneen: by forcing parts of the list previously, each new element only needs to add two numbers
05:06:07 <quicksilver> the thunks created refer directly to the previous elements in the list.
05:06:11 <Botje> teneen: that is if you evaluate it one by one
05:06:17 <Botje> teneen: if you do something like fibs !! 5000
05:06:19 <teneen> Botje: where/how is it forced?
05:06:27 <quicksilver> when you demand it
05:06:28 <Botje> teneen: printing stuff forces it.
05:06:29 <quicksilver> and not before.
05:06:48 <Botje> if you ask ghci for fibs it will force the first element, print it, force the second, print it, and so on
05:07:05 <teneen> But I feel like it has to traverse the list to the nth cell first. And then traverse the thunk all the way backwards. Is this correct?
05:07:14 <teneen> fibs!!n
05:07:18 <quicksilver> yes, it does
05:07:26 <quicksilver> if you haven't previously accessed previous elements.
05:07:38 <quicksilver> but it's still only doing them once each
05:07:47 <quicksilver> rather than an exponentially increasing number of times each
05:07:52 <srhb> teneen: It is easier to reason about if you think of it in terms of elem : elem ...
05:08:30 <teneen> quicksilver: So a strict tail recursive form is still more efficient then this?
05:08:55 <quicksilver> in memory, yes
05:09:05 <quicksilver> in computation it is doing the same thing.
05:09:10 <ciaranm> the floating point version is more efficient
05:09:16 <quicksilver> but it is using O(n) memory to materialise the list as it goes along.
05:09:57 <teneen> quicksilver: How is it doing the same thing in computation? a strict tail recursive one will only have to traverse forward, no backwards, isn't it?
05:10:22 <quicksilver> teneen: the lazy one isn't really doing two traversals.
05:10:46 <quicksilver> "skipping down the list" to the nth element doesn't do any work except allocating cons cells
05:11:01 <quicksilver> it's not forcing any of the elements or even allocating space for their thunks
05:11:30 <teneen> quicksilver: But allocating n cons cells is O(n), one traversal?
05:11:39 * quicksilver shrugs
05:11:51 <quicksilver> I think the important thing is that it's O(n) memory
05:11:55 <quicksilver> which I already said.
05:12:10 <quicksilver> the time-cost of the cons cells themselves can be amortized into the cost of the calculation.
05:12:27 <teneen> quicksilver: I see
05:12:36 <quicksilver> if you want to compare the precise evaluation time of the two different evaluation strategies then you have moved away from discussing haskell operational semantics
05:12:43 <quicksilver> and into discussing a *particular* compiler implementation.
05:12:51 <quicksilver> and you will find all kinds of fiddly details :)
05:13:24 <ciaranm> clearly ghc should do fibs !! 20 on the fpu
05:28:09 <t7> writing a parser in javascript. please kill me
05:28:29 <Botje> you seem to be doing a fine job yourself
05:32:36 <hiptobecubic> ZING
05:33:15 <fmap> Is there an easy way to take screen captures in haskell? xlib binding omits `XGetImage' ("i'm not exactly sure when they would be used")
05:36:05 <quicksilver> t7: http://www.google.co.uk/search?client=safari&rls=en&q=javascript+parser+generator
05:37:15 <ksf> monadic view patterns?
05:37:34 <ksf> t7, aren't there combinator libraries for javascript?
05:37:50 <ksf> they leaked out of haskell a lot, and as javascript is, alas, widely used...
05:37:50 <t7> i wanna write the code raw because its gonna be a tutorial
05:38:19 <ksf> also, I want monadic view patterns.
05:38:39 <ksf> c2hs knows about them.
05:38:47 <t7> http://hpaste.org/70299  thats without any error checking
05:39:59 <t7> woops that doesnt handle closing bracket correctly either :|
05:45:05 <t7> who would actually choose to right code in this language :(
05:57:38 <spree> Hello lads, do you know who wrote the Haskell Bittorrent client?
05:59:15 <jaxtr> ahh it's a wonderful day
05:59:17 <companion_cube> http://jlouisramblings.blogspot.fr/2010/03/want-to-hack-haskell-bittorrent.html this guy, maybe?
05:59:28 <bitonic> spree: which one? if this: https://github.com/scvalex/ltorrent , I know the author
06:08:54 <Catnaroek> @hoogle fail
06:08:54 <lambdabot> Prelude fail :: Monad m => String -> m a
06:08:54 <lambdabot> Control.Monad fail :: Monad m => String -> m a
06:08:54 <lambdabot> Control.Monad.Instances fail :: Monad m => String -> m a
06:38:16 * hackagebot operational 0.2.1.2 - Implementation of difficult monads made easy  with operational semantics.  http://hackage.haskell.org/package/operational-0.2.1.2 (HeinrichApfelmus)
06:54:19 <spree> bitonic: doesnt matter which bittorrent client, more interested in knowing how much work it was and his experience level? because i want to write one and i want to know how much work it would be...
06:58:26 <bitonic> spree: I can ask ehe. It shouldn't be too hard, I've got some familiarity with the bittorrent protocol
07:00:33 <t7> i have been using haskell for over a year now :O
07:01:08 <otters> I love haskell
07:01:29 <t7> i need to download all the logs to get the exact date
07:06:52 <Botje> oh, huh
07:06:59 <Botje> i'm coming up on 6 years in october.
07:07:02 <Botje> how time flies :]
07:10:58 <bitonic> <me> how much work was the haskell bittorrent client?
07:10:58 <bitonic> <him> 2000 lines
07:10:58 <bitonic> <him> A month of a few hours a day.
07:10:58 <bitonic> <him> But I was in high school and it was literally my first Haskell programme.
07:11:01 <bitonic> spree: ^^^
07:12:18 <bitonic> spree: he also says that `combinatorrent' is much more complete
07:12:54 <bitonic> but that's erlang.
07:15:23 <osfameron> how do you truncate a real to 1 decimal place?
07:15:31 <osfameron> I tried hoogling: (RealFrac a) => a -> a
07:15:38 <mauke> for display purposes?
07:15:56 <osfameron> yeah, I guess
07:15:59 <osfameron> yes, even
07:16:04 <mauke> printf
07:16:08 <mauke> or showFFloat
07:17:29 <osfameron> > printf "%0.1f" pi
07:17:30 <lambdabot>   Ambiguous type variable `a' in the constraints:
07:17:30 <lambdabot>    `Text.Printf.PrintfType ...
07:17:32 <mauke> > "" ++ printf "%.1f" pi
07:17:34 <lambdabot>   "3.1"
07:17:40 <spree> bitonic: can you do it all in haskell or you have to FFI to C?
07:17:51 <mauke> also, people need to learn printf
07:18:08 <osfameron> ah, why do you have to coerce with "" +  there?
07:18:23 <bitonic> spree: you can do it all in haskell
07:18:35 <DMcGill> > (printf "%0.1f" pi) :: String
07:18:36 <lambdabot>   "3.1"
07:18:51 <DMcGill> :t printf
07:18:52 <lambdabot> forall r. (PrintfType r) => String -> r
07:18:56 <spree> bitonic: no speed issues?
07:19:21 <osfameron> ah, I have the same issue in ghci when trying to do it in a map
07:19:25 <osfameron> so :: [String] makes that better
07:19:40 <bitonic> spree: you can surely write a really fast Haskell bittorrent client.
07:21:02 <mauke> guys, please stop writing "%0.1f" :-(
07:23:52 <osfameron> ah, the 0 prefix is only relevant for integers
07:24:51 <mauke> no
07:25:03 <mauke> the 0 flag means to use '0' instead of ' ' for padding
07:25:48 <otters> but why would there be padding
07:26:14 <osfameron> > printf "%09.1" pi :: String
07:26:15 <lambdabot>   "*Exception: Printf.printf: formatting string ended prematurely
07:26:22 <osfameron> > printf "%09.1f" pi :: String
07:26:24 <lambdabot>   "0000003.1"
07:26:27 <osfameron> otters: ^
07:26:27 <otters> oh yeah
07:26:40 <otters> but how can '0' by itself ever result in padding?
07:26:47 <osfameron> I suspect that is mauke's pooint
07:27:00 <otters> > printf "%0.1f" 0.3
07:27:01 <lambdabot>   Ambiguous type variable `a' in the constraints:
07:27:01 <lambdabot>    `Text.Printf.PrintfType ...
07:27:04 <otters> > printf "%0.1f" 0.3 :: String
07:27:06 <lambdabot>   "0.3"
07:29:44 <mauke> osfameron: yes
07:30:09 <mauke> it makes no sense to customize padding if you haven't actually enabled padding (by specifying a minimum field width)
07:37:55 <td123> error: failed to commit transaction (conflicting files)
07:37:57 <td123> /usr/lib/systemd/scripts/iptables-flush exists in both 'iptables' and 'systemd-arch-units'
07:38:00 <td123> Errors occurred, no packages were upgraded.
07:38:02 <td123> :P
07:38:11 <td123> oops
07:38:19 <td123> (wrong channel)
07:58:48 <pcavs> Can someone give me an example of a type with kind * -> * that you cannot write an instance of Functor for without using undefined? (Question from Typeclassopedia)
07:59:19 <pcavs> I'm having a hard time doing so, and I think I've spent the requisite time (~day) to get the learning experience from it
07:59:37 <mauke> data T a = C (a -> Int)
07:59:52 <pcavs> grr, duh.
07:59:56 <pcavs> thanks mauke
08:01:10 <pcavs> now if only I could wrap my head around the type of "fmap fmap fmap"
08:01:21 <mauke> heh
08:01:26 <armlesshobo> :t fmap
08:01:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:01:33 <armlesshobo> :t fmap fmap fmap
08:01:34 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
08:01:51 <mauke> the first fmap is ... special
08:02:09 <rwbarton> one of these fmaps is not like the others!
08:02:26 <armlesshobo> lol
08:02:31 <armlesshobo> :t fmap fmap
08:02:32 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
08:03:27 <Tinned_Tuna> :t fmap
08:03:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:03:52 <Tinned_Tuna> HDBC.PostgreSQL is so very flakey on my box ... it works, but if you do it in *just* the right ways.
08:04:45 <spree> bitonic: ok cool i should be able to do that then. did he make a GUI or webapp or just a command line program?
08:07:13 <Chat> Hi
08:08:13 <Guest40346> Can I change my  nick name now or I have to start again?
08:08:27 <Guest40346> I am trying Haskell in browser
08:08:44 <zenzike> Tinned_Tuna: I advise people to use HDBC.ODBC if using postgresql
08:08:57 <zenzike> Guest40346: try typing /nick thenickyouwant
08:09:49 <Optimight> Great
08:10:49 <Optimight> So many persons in the chat ..but  where is the dialogues between them
08:11:38 <DMcGill> as usual in irc, lots of people are idling in the channel
08:12:04 <DMcGill> if you have a question or something though, usually you'll get an answer pretty quickly however
08:12:35 <Optimight> This is my first day with haskell  ...rather first hour
08:12:42 <bitonic> spree: http server + web ui
08:13:15 <jfischoff> Optimight: what materials are you using to learn?
08:13:25 <Optimight> come from  Object Oriented Designing and Modeling field .. trying to learn programming... exploring various languages
08:13:54 <Optimight> I came dhere from tryhaskell.org
08:14:06 <DMcGill> have you done the exercises/tutorial on there?
08:14:26 <Optimight> Trying to get grasp of Functional Programming...   impressed
08:14:35 <Optimight> doing ...
08:14:47 <Optimight> like sort [42, 12, 22]
08:14:51 <Optimight> etc
08:15:27 <Optimight> I have been  exploring scala since last 25 days
08:15:34 <DMcGill> seeing the quicksort example in Haskell was what got me interested
08:15:34 <DMcGill> http://www.haskell.org/haskellwiki/Introduction#Quicksort_in_Haskell
08:15:54 <DMcGill> that and list comprehension
08:16:13 <Optimight> yes
08:16:48 <Optimight> How do you address particular person in here?
08:16:56 <DMcGill> just by saying their name
08:16:59 <bitonic> Optimight: like this
08:17:02 <Optimight> okay
08:17:19 <mauke> o mighty bitonic!
08:17:36 <DMcGill> although there is also a private messaging system, I've not really used it
08:17:50 <Optimight> ok
08:18:22 <bitonic> Optimight: if you're addressing me you should imitate mauke
08:18:33 <mauke> haha
08:19:15 <Optimight> mauke
08:19:44 <mauke> yes?
08:20:06 <Optimight> mistakenly I clicked on your name and got your WHOIS details
08:20:16 <Optimight> Am using secure connection or not?
08:20:22 <hpaste> “Jonathan Fischoff” pasted “Golfing Practice” at http://hpaste.org/70302
08:20:56 <jfischoff> ^ I feel like there is a more elegant way to write that with out using the indices
08:21:07 <jfischoff> any ideas?
08:21:10 <mauke> Optimight: users don't get notified when someone else WHOISes them
08:21:20 <Optimight> My WHOIS details does not so secured connection
08:21:25 <mauke> Optimight: you're on webchat
08:21:29 <Optimight> Am I carrying any risk?
08:22:03 <Optimight> yes.. I am on webchat
08:22:30 <mauke> so your connection to freenode is neither "secure" nor "insecure", it's through the website
08:22:39 <mauke> I don't know if the website uses https, though
08:22:54 <Optimight> mauke okay
08:23:12 <mauke> you can ask in #freenode though
08:23:15 <bitonic> Optimight: still, if you're not authenticating, you haven't got much to lose, as long as you don't query credit card numbers.
08:23:15 <mauke> they should know more about this
08:23:28 <Optimight> mauke:  got to go offline  but definitely will be a regular visitor ..now on
08:23:42 <mauke> have fun
08:24:11 <Optimight> mauke : one tech question  , does scala has same functional programming capacity as haskell has?
08:24:18 <mauke> oh, no idea
08:24:22 <mauke> I've never tried scala
08:24:26 <Optimight> okay
08:24:47 <bitonic> Optimight: Scala is a big, complex language. Haskell has more rigid core valus. The thing that stands out compared to Scala are lazyness and type classes
08:24:51 <bitonic> *values
08:24:55 <Optimight> mauke : Can Haskell be used for ERP like software project?
08:25:00 <bitonic> and purity
08:25:04 <jfischoff> ERP?
08:25:04 <mauke> Optimight: probably
08:25:10 <mauke> enterprise resource planning
08:25:23 <mauke> in fact, if PHP can be used for that, Haskell definitely can
08:25:27 <hpaste> DMcGill annotated “Golfing Practice” with “window” at http://hpaste.org/70302#a70303
08:25:33 <bitonic> @faq is Haskell "enterprise ready"?
08:25:33 <lambdabot> The answer is: Yes! Haskell can do that.
08:25:49 <bitonic> @botsnack
08:25:50 <lambdabot> :)
08:25:50 <mauke> it's probably a lot of DB access with entry/query forms
08:25:51 <DMcGill> jfischoff: recursion tends to be the 'nicest' solution to many problems
08:25:58 <jfischoff> DMcGill++
08:26:00 <jfischoff> thanks
08:26:15 <Optimight> lambdabot: I am preparing myself for multi location distributed application
08:27:00 <DMcGill> jfischoff: also, I forgot to remove the "window 2 count xs" from line 3
08:27:07 <DMcGill> it's not needed
08:27:20 <NemesisD> mauke: hey remember me from yesterday? i had the broken pipe issue with some of my code?
08:27:26 <mauke> NemesisD: yes
08:27:39 <Optimight> Okay..people .   Thanks for your warm response...     See you all soon..    Have a great day all  !!!
08:28:16 <NemesisD> mauke: i've got it reproducible, the only error i get is:  <socket: 3>: hPutBuf: resource vanished (Broken pipe)
08:28:30 <Optimight> How to log out from hhere?
08:28:38 <mauke> NemesisD: ok, that's an IO exception
08:28:44 <DMcGill> I would imagine you just close the browser window
08:28:57 <Optimight> okay..
08:29:34 <mauke> NemesisD: it's trying to send something but the receiver has closed their side of the connection
08:30:43 <NemesisD> mauke: could it be that its sending too much data?
08:31:00 <mauke> not by itself
08:31:05 <mauke> that would just block
08:31:11 <NemesisD> this program does some database queries and then stores aggregates in redis. i noticed that when i limit the number of databases it queries this doesn't seem to come up
08:38:50 <spree> spa <- P.many (P.letter P.<|> P.char ',' P.<|> P.space) // been a while since i used Parsec but what does P.<|> mean?
08:39:33 <bitonic> spree: choice
08:39:41 <bitonic> non-backtracking
08:40:02 <mauke> "or"
08:40:07 <bitonic> e.g. if an alternative matches at all, it does not backtrack
08:45:50 <spree> ofc
08:46:50 <spree> wow parsec is really powerful
08:46:53 <spree> it seems
08:47:10 <spree> are there any so easy to use parser libs in java or python?
08:49:19 <Eduard_Munteanu> spree: I suspect you don't get nice EDSL-ish combinators in other languages
08:50:14 <DMcGill> what are some examples of types with a monad instance (for the do-notation) that are unsuited for it (i.e. don't satisfy the axioms)?
08:51:00 <DMcGill> and would that mess up some optimations or something?
08:51:12 <tac-tics> spree: Parsec is one of the "Killer Apps" of Haskell
08:51:15 <tac-tics> IMO
08:51:29 <spree> could quickcheck be used to test parsers in a good way?
08:51:36 <spree> edsl?
08:51:58 <rhapsodhy> hi
08:52:13 <DMcGill> spree: Embedded Domain Specific Language
08:52:29 <rhapsodhy> (\str -> replace " " "+" $ "http://google.com/search?q=" ++ str) how can i turn this lambda into a partial function application?
08:52:53 <DMcGill> like regex or openGL (I think)
08:53:01 <bitonic> spree: you can write a pretty printer, and then an Arbitrary instance for your AST data type, and then you can generate valid syntax and parse it. It's not trivial, but it's doable
08:53:14 <taylorgb_> rhapsodhy: You can just use a section
08:53:55 <parcs`> DMcGill: blaze-html uses a dummy Monad instance
08:54:20 <parcs`> (>>) = mappend; everything else = error
08:54:21 <rhapsodhy> taylorgb_: i've tried it this way, but doesn't quite cut it: (replace " " "+" $ (++) "http://google.com/search?q=")
08:54:30 <ion> parcs: Wow
08:55:30 <rhapsodhy> sry, this way: ((++) "http://google.com/search?q=" $ replace " " "+")
08:55:40 <Ruudjah> "turing complete oop" got my interest in Haskell. So I looked to the wiki page, with mainly examples using shortened var names
08:55:46 <DMcGill> rhapsodhy: try `replace " " "+" . (googleStr ++)'
08:55:56 <Ruudjah> e.g. fibonacci example where "fib" is used
08:56:06 <Ruudjah> putStrLn
08:56:14 <Ruudjah> foldl
08:56:26 <Ruudjah> Is this naming usage a convention/culture in haskell?
08:56:28 <bitonic> DMcGill: various "random monads" do not respect the monad laws
08:56:35 <rhapsodhy> DMcGill: oh, thanks
08:56:48 <spree> if my parser returns (String, String) when it succees and i dont want to return ("","") when it fails then i should stick a maybe-monad in ther eright?
08:56:59 <rhapsodhy> i've already understood what i got wrong
08:57:11 <DMcGill> rhapsody: the brackets there are called a 'section', it's a bit like partial application for infix functions
08:57:15 <bitonic> DMcGill: well, some of them don't anyway
08:57:29 <DMcGill> spree: yup
08:57:47 * ion looks at http://hackage.haskell.org/packages/archive/blaze-markup/0.5.1.0/doc/html/src/Text-Blaze-Internal.html#MarkupM
08:57:59 <ion> fmap _ = unsafeCoerce
08:58:16 <DMcGill> spree: or a list if there are multiple parses (with an empty list being failure)
08:58:35 <bitonic> ion: lol. why that and not `id'?
08:58:42 <bitonic> ah, right.
08:59:20 <bitonic> still, can't they match the constructors and rebuild them manually?
08:59:32 <DMcGill> spree: check out Hutton's simple parser in http://www.cs.nott.ac.uk/~gmh/chapter8.ppt
09:00:24 <DMcGill> it's pretty much `Parser a = Parser (String -> [a,String])'
09:00:44 <DMcGill> (oops, with a pair inside that list)
09:01:19 <ion> dmcgill: Are there video lectures with those slides online?
09:01:25 <DMcGill> yes
09:01:25 <DMcGill> http://www.cs.nott.ac.uk/~gmh/book.html
09:01:42 <ion> Thanks
09:01:58 <Ruudjah> what would you guys recommend to a java/c# writer to get into haskell with?
09:02:10 <DMcGill> I haven't watched them myself however
09:02:12 <ion> ruudjah: The same as anyone else: LYAH.
09:02:14 <ion> @where lyah
09:02:14 <lambdabot> http://www.learnyouahaskell.com/
09:02:37 <DMcGill> Ruudjah: or tryHaskell for something rudimentary
09:02:47 <Ruudjah> with elephants and smiling suns
09:03:18 <WraithM> I did love lyah.
09:03:20 <DMcGill> I bet you can't name a single Java/C# tutorial with those in right? Who needs code shootouts when we have objective measurements of a language like this
09:03:37 <saep> @where rwh
09:03:37 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
09:03:45 <WraithM> That too
09:04:20 <Ruudjah> ghci>
09:04:35 <Ruudjah> max min succ
09:05:19 <Ruudjah> haskell created for kids?
09:05:47 <bitonic> Ruudjah: no
09:06:16 <ion> ruudjah: Is C#?
09:06:24 <DMcGill> note that the functions 'maximum' and 'minimum' also exist (and are slightly different to 'max' and 'min')
09:06:30 <hpaste> spree pasted “parsec error” at http://hpaste.org/70304
09:06:37 <Ruudjah> I dont think this stuff is for me
09:06:42 <Ruudjah> thanks though
09:06:48 <DMcGill> well at least you gave it a good try
09:07:17 <ion> spree: space results in a Char, many letter results in a String.
09:07:22 <fmap> `maximum' isn't near as cool as `AbstractSingletonProxyFactoryBean' or something
09:08:19 <Ruudjah> I mean seriously
09:08:38 <Ruudjah> \troll this is 2012. Why use a commandline?
09:08:59 <ion> or a keyboard
09:09:04 <ion> or text in general
09:09:04 <Ruudjah> the whole book is using the commandline
09:09:07 <DMcGill> feel free to use one of the GUI editors too
09:09:40 <Ruudjah> yeah, checked out some screenshots. Saw some lists there with many more abbreviated function names
09:09:43 <ion> ruudjah: A REPL is a great thing to have. If you haven’t used one in the past, you’re in for a treat.
09:10:49 <bgamari> Ruudjah: Most people who use the command line do it not because they are impoverished with a lack of alternatives but instead because they find it more productive than fumbling around with a GUI
09:11:16 <tac-tics> There's too much opinion that goes into the design of a GUI application.
09:12:40 <Ruudjah> well. Thanks again.
09:13:15 <spree> so how would i get either space and many letters or many letters? i want to parse /MSG text and /MSGtext as ("MSG", text).
09:13:42 <monochrom> you are free to use Eclipse or Visual Studio. both have haskell plugins
09:13:54 <Ruudjah> I like many things about haskell
09:14:09 <Ruudjah> It's the culture around it turning me off
09:14:10 <spree> Ruudjah: haskell takes time getting used to but is really usable for real things as well and very interesting to learn. but it really takes time to get into if you come from OO. A lot of frustration in the beginning.,
09:14:28 <ion> spree: How about many space *> many letter? That would also parse “     text”.
09:14:30 <spree> How could the culture turn you off, thats the best thing about it
09:14:44 <spree> *>?
09:14:47 <DMcGill> spree: throw away the result from parsing spaces
09:15:06 <DMcGill> I think *> might work
09:15:32 <spree> what is *>?
09:15:34 <mauke> *> is identical to >>
09:15:45 <mauke> but <* doesn't have a convenient monad equivalent
09:15:53 <Ruudjah> repl, commandline, abbreviated function names, c-style naming
09:16:06 <Ruudjah> in java/c#/the rest of oop I just have Math.min
09:16:22 <mauke> Ruudjah: ?
09:16:24 <Ruudjah> blergh
09:16:29 <mauke> that's an abbreviated function name
09:16:49 <ion> You wish you had Mathematics.minimum instead?
09:17:06 <mauke> as for "c-style naming", that's pretty hilarious
09:17:07 <DMcGill> it'd solve this "math" vs "maths" issue for good!
09:17:11 <Ruudjah> certainly be better. Math.min is at least improvement over min
09:17:13 <DMcGill> sorry, I meant "versus"
09:17:18 <mauke> C: SIGBUS
09:17:24 <mauke> Haskell: processStatusChanged
09:17:29 <mauke> er
09:17:32 <mauke> C: SIGCHLD
09:17:41 <Ruudjah> putStrLn
09:17:43 <Ruudjah> wtf
09:17:50 <mauke> SIGBUS is busError
09:18:12 <DMcGill> "println"?
09:18:12 <mauke> Ruudjah: what's wrong with that?
09:18:16 <spree> hm,, so P.many P.space parses no spaces but P.space doesnt parse if there are no spaces?
09:18:17 <saep> SIGBUS is 7
09:18:20 <saep> :D
09:18:29 <monochrom> this is a worthless "discussion". look beyond the Prelude already.
09:18:46 <mauke> spree: yeah, P.space parses exactly one space character
09:18:58 <mauke> at least I think it does
09:19:03 <DMcGill> spree: have you thought about not importing qualified and instead hiding the conflicting Preluse functions?
09:19:06 <mauke> I actually have no context here
09:19:12 <DMcGill> a minor point I know
09:20:46 <Tinned_Tuna> Morning, so, I'm using HDBC for some quick n' dirty db access -- is there a more sane way ?
09:21:07 <Ruudjah> what's wrong with showLineInDebug?
09:21:09 <spree> DMcGill: not really
09:21:10 <Tinned_Tuna> i.e. is HDBC a 'low level' util, because I'm finding it surprisingly difficuly to work with
09:21:16 <spree> do i then import Prelude and hide?
09:22:02 <mauke> Ruudjah: 1) that's not what it does  2) that's far too long a name
09:22:26 <DMcGill> you can try a mix of: `import Parser ((<|>, space)' and `import Prelude hiding (fun1, fun2)'
09:22:32 <ion> In debug?
09:22:34 <DMcGill> note that you can import something twice, so doing
09:22:43 <saep> spree: I'm pretty sure there are no name clashes between Prelude and Parsec.
09:23:14 <Ruudjah> Because I only have 640K
09:23:15 <DMcGill> `import Prelude hiding ((++)) \\ import qualified Prelude as P' would work for example
09:23:25 <bgamari> Ruudjah: Yes, the names are different. If you ask many people in this channel about the naming conventions used in Java, they'd tell you similar sorts of objections. Names are just identifiers; you learn them. Haskell has weaknesses, but really, the naming convention used in Prelude isn't one of them
09:23:51 <bitonic> Tinned_Tuna: what DB are you accessing?
09:24:23 <ion> ruudjah: Should System.out.println be named System.out.showLineInDebug?
09:24:47 <DMcGill> ion: "printLineInDebug" obviously
09:24:51 <Ruudjah> I dont want to spend braincycles on learning names. They should be selfexplanatory.  e.g. http://code.google.com/p/guava-libraries/source/browse/#git%2Fguava%2Fsrc%2Fcom%2Fgoogle%2Fcommon%2Fcollect
09:24:53 <Siod> what's a good example of composability
09:25:07 <bitonic> Tinned_Tuna: because for quick and dirty MySQL/Postgres stuff I'd use something *less* abstracted than HDBC, e.g. {mysql, postgres}-simple
09:25:10 <ion> “putStrLn” and “min” aren’t self-explanatory?
09:25:24 <ion> I’m starting to think we’re being trolled. :-)
09:25:32 <mauke> ArrayListMultimap? why, I know *exactly* what this does </sarcasm>
09:25:34 <monochrom> God, are we still arguing over Prelude names?
09:25:36 <Ruudjah> is printLn abbr for printLine, or is it printIn (l/I character ambiguity) etc
09:25:46 <mauke> Ruudjah: get a better font
09:25:49 <bgamari> There is no such thing as One Proper Naming Convention(TM); let's all just acept this and move on with our lives. This is the last you'll be hearing from me about this inane matter
09:26:28 <NemesisD> looking at the docs of HashSet and it says the complexity of converting a list to a set is O(n*min(W,n)), anyone know what W could be?
09:26:34 <Tinned_Tuna> bitonic: postgresql, I basically want a [[SqlString, SqlInteger, SqlInteger]] to be read and stuck in a map String -> [Integer]
09:26:36 <c_wraith> Ruudjah: printLn uses a capital L, so that shouldn't be an issue.  (But yes, it's "print line")
09:27:01 <ion> In Java it uses a small L AFAIU. In Haskell, a capital L.
09:27:17 <monochrom> like, at least step out of Prelude and look at for example Control.Concurrent will you? "isCurrentThreadBound" doesn't look like an abberivation or C-style
09:27:19 <DMcGill> is anybody here familiar with Cabal's internals or am I better off asking in #cabal or their mailing list?
09:27:22 <c_wraith> NemesisD: it's in the docs.  But it's a constant, either 32 or 64, depending on your platform
09:27:24 <spree> is there channels with several # ?
09:27:39 <ion> spree: Yes, and zero #s as well.
09:27:52 <c_wraith> DMcGill: dcoutts is as familiar with it as anyone, but he doesn't appear to be here right now.
09:27:58 <NemesisD> c_wraith: ah, so that should always be faster than Data.List.nub for sets > 64?
09:27:58 <mauke> c_wraith: I don't see it in the docs
09:28:12 <spree> bgamari: what are some of haskells weaknesses?
09:28:21 <mauke> NemesisD: complexity isn't speed
09:28:28 <fryguybob> Siod: What kind of composability are you looking for?
09:28:47 <Siod> fryguybob: a good example to show someone the power of composability in haskell
09:28:49 <Eduard_Munteanu> ion: um, which?
09:28:53 <NemesisD> mauke: sorry, less complex, and i realize they do different things, toList . fromList should be less complex than nub for lists > 64 ?
09:28:55 <bitonic> Tinned_Tuna: take a look at this: http://hackage.haskell.org/packages/archive/postgresql-simple/0.2.0.1/doc/html/Database-PostgreSQL-Simple.html
09:29:02 <Siod> fryguybob: where they don't know haskell
09:29:04 <spree> txt <- (P.char '#' >> (P.many P.letter)) P.<|> P.many P.letter // why does that throw away # in #haskell?
09:29:06 <DMcGill> an example of multiples is "##4eCO"
09:29:11 <mauke> NemesisD: complexity doesn't depend on input size
09:29:18 <mauke> NemesisD: so "for lists > 64" doesn't make sense
09:29:21 <fryguybob> Siod: perhaps http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/beautiful.pdf ?
09:29:24 <Eduard_Munteanu> spree: ## denotes topic channels, e.g. ##electronics
09:29:30 <NemesisD> mauke: does it not when its min(W,n)
09:29:39 <bgamari> spree: I would consider the difficulty of reasoning about memory usage with laziness to be one although this is also part my own deficiency
09:29:41 <NemesisD> thats whatever is smaller 32/64 OR the number of elements right?
09:29:43 <Clint> spree: because you're telling it to?
09:30:04 <bgamari> spree: Mostly debugging related issues but these bite me increasingly rarely
09:30:14 <Siod> fryguybob: i'm looking for a one-liner
09:30:21 <ion> spree: map not being fmap, Monoid not depending on Semigroup, Monad not depending on Applicative etc.
09:30:24 <mauke> NemesisD: yes, but that still doesn't help you how fast it is
09:30:28 <mauke> er, *tell you
09:30:45 <DMcGill> what do you mean by "composability", are you just looking for good one liners to show off?
09:30:56 <dschoepe> spree: records could also have been done better, but there are some proposals on that for Haskell'.
09:30:58 <ion> eduard_munteanu: E.g. &foo, +foo, !foo in IRCnet. Freenode most likely doesn’t have + or ! channels, but perhaps it has & channels.
09:31:02 <parcs`> Peaker: did your 'cabal update' patches get merged?
09:31:16 <Eduard_Munteanu> Ah.
09:31:31 <Siod> i mean combining desparate functions for a specific solution
09:31:49 <NemesisD> mauke: i'm trying to determine which is the better choice
09:31:56 <mauke> NemesisD: benchmark
09:31:57 * ksf still doesn't really get why GHC.Generics is listed under "generics" alongside with syb et all.
09:32:24 <ksf> yes, it's a kind of generic programming, but I don't see how to replace syb with it without an additional library.
09:32:31 <spree> spree hello
09:32:32 <bitonic> ksf: there is a lot of functional overlap
09:32:38 <NemesisD> bah, nm its not that important
09:32:46 <spree> hello
09:33:13 <ksf> bitonic, say I want to replace all occurences of "map" with "fmap" in an AST.
09:33:27 <bitonic> ksf: it's not like every "generics" library is functionally equivalent to the other
09:33:28 <fryguybob> Siod: something like  minimum = head . sort  ?
09:33:29 <ksf> the generic-traversal thing seems to be missing completely.
09:33:33 <Siod> yes
09:33:52 <bitonic> ksf: of course you have the generic-traversal, see the example in the manual
09:33:55 <ksf> well, the others listed there share a huge chunk of functionality with syb.
09:34:37 <bitonic> ksf: it's actually a much better way to generically traverse data types, see: http://www.haskell.org/ghc/docs/latest/html/users_guide/generic-programming.html#id691128
09:34:39 <fryguybob> Siod: you might like kmc's slides: http://mainisusuallyafunction.blogspot.com/2011/10/slides-from-why-learn-haskell.html
09:34:53 <bitonic> ksf: but maybe I'm misunderstanding "generic-traversal"?
09:35:08 <spree> ion: cant those be fixed or it would be a lot of work?
09:35:11 <ksf> syb's everywhere, listify, something, etc.
09:35:42 <Siod> is my usage of composability completely wrong in the context of functional programming?
09:36:11 <DMcGill> Siod: could you mean 'polymorphic' instead?
09:36:25 <Siod> no, modular would be better than that
09:36:26 <bitonic> ksf: yeah but GHC.Generic is a much nicer way of doing thing, most of the times. I'm not sure what missing functionality you're referring to
09:36:39 <ksf> that minimum above *is* polymorphic.
09:36:50 <Siod> what i'm describing is differently some kind of pattern. the unix command line does it with piping
09:36:57 <ksf> bitonic, say I have a big ast.
09:36:58 <fryguybob> Siod: I take composability to mean being able to write reusable components that give few surprises.
09:37:02 <Siod> s/differently/definitely
09:37:13 <ksf> for all Foo expression nodes, I want to evaluate them.
09:37:27 <Siod> fryguybob: that's how i mean it as well. is it unusual to use it in the context of functions?
09:37:31 <ksf> syb takes care of finding those foo nodes for me, I only have to write the transformation itself.
09:37:34 <DMcGill> do you mean using the (.) function?
09:37:43 <DMcGill> i.e. minimum = head . sort
09:37:44 <bitonic> ksf: what's a "Foo" expression node? can you paste example code?
09:37:50 <Siod> DMcGill: yes but not necessarily just .
09:37:54 <monochrom> there are many different compositions
09:38:09 <ksf> it doesn't really matter what it is. it's a single constructor in a big mess of ADTs.
09:38:22 <ion> spree: I hope they’ll get fixed, but that’ll break plenty of code.
09:38:27 <fryguybob> Siod: not at all.  (.) is function composition speicifically, but that is certainly related to composing.
09:38:27 <Clint> Siod: you might want to look at arrows, conduits, pipes, etc.
09:38:28 <bitonic> ksf: oh. so you want to do something with all the occurrences of `Foo'?
09:38:36 <ksf> and the whole tree is gigantic, and there's a gazillion paths that lead you to a foo node.
09:38:39 <ksf> yep.
09:38:47 <ion> spree: Alas, the later they’re fixed, the more code the fix will break.
09:39:22 <ksf> in syb, it's as easy as "everywhere (mkT f)" where f is Foo -> Foo
09:39:28 <jfischoff> is there a way to use environment variables with .cabal extra-lib configurations?
09:39:37 <bitonic> ksf: you can do that with GHC.Generics
09:40:24 <ksf> I'm sure you can, as it provides perfectly fine reflection support, but I don't see any library containing "everywhere".
09:40:58 <bitonic> ksf: because you write function cases as type class instances
09:41:12 <bitonic> so it might be a bit more verbose, bu it's going to be more reusable
09:41:31 <bitonic> again, have you checked the example for GHC.Generics?
09:41:55 <bitonic> it works in a completely different way, but you achieve very different goals
09:41:57 <ksf> yes, I have.
09:42:01 <ksf> I think I even read the paper.
09:42:01 <bitonic> *very similar
09:42:26 <bitonic> ok then I'm not sure I see the inconvenience, apart from a bit of verbosity for simple cases.
09:43:17 <ksf> the thing is, I *don't* want to write the class GSerialize. SYB is doing that for me.
09:44:17 <ksf> well, all I want to write of it is O : and I :
09:44:20 <bitonic> ksf: no, syb is not doing that for you. it's apples and oranges. syb works with plain functions, GHC.Generics works with a uniform representation of datatypes
09:45:21 <ksf> syb is traversing the tree for me, looking for opportunities to apply my function. as far as I see it, in GHC.Generics I have to write that traversal myself.
09:45:40 <ksf> granted, SYB can't do every traversal you can implement by hand, but it's sufficient in 99% of the cases.
09:45:57 <jfischoff> ?tell tgeeky a request for your next transliteration: http://pdf.aminer.org/000/980/906/perfect_trees_and_bit_reversal_permutations.pdf
09:45:57 <lambdabot> Consider it noted.
09:46:19 <Tinned_Tuna> bitonic: can postgresql-simple be used without language extensions?
09:46:35 <t7> bottom is a value, right (or lack of)?
09:46:41 <ksf> actually, what's needed is a GEverywhere, GSomewhere etc. class.
09:47:39 <bitonic> ksf: I'm really not sure what you mean. with `everywhere', you have to take care about a different thing - your function has to be `forall a. Data a => a -> a'. With GHC.Generics you write your function for 1 datatype, which is why it's so convenient
09:47:55 <t7> people are arguing that bottom is like null :O
09:48:03 <bitonic> they are not comparable implementations, they work in completely different way
09:48:14 <ksf> I can derive Data for all my data types.
09:48:40 <bitonic> t7: it is in the sense that everything can be either a value or _|_, just like in some OO langs objects can be objects or null :P
09:48:42 <bitonic> ksf: so?
09:48:56 <ksf> http://hpaste.org/70309
09:48:58 <bitonic> ksf: (and not all data types)
09:49:01 <ksf> so I can write things like that.
09:49:25 <DMcGill> t7: when programming, you should treat Nothing like you were treating null
09:49:33 <ksf> the only remotely annoying thing is that g has to have a fully ground type.
09:49:34 <monochrom> "like" is too flexible. you can reliably test for null but not test for ⊥
09:49:36 <tac-tics> bitonic: Dear god. I never saw it that way.
09:49:38 <DMcGill> I'm not even sure how you would test for nothing
09:49:43 <DMcGill> for bottom I mean
09:49:51 <tac-tics> DMcGill: You can't :)
09:49:58 <ksf> ...and that usually means you have to give an annotation.
09:49:59 <t7> run it through my termination checker
09:50:15 <DMcGill> this isn't #agda
09:50:18 <bitonic> ksf: yes, I understand, but I don't see how GHC.Generics is "worse", apart from being more verbose in that case
09:50:43 <bitonic> ksf: you were complaining of them not being enough "functionally close"
09:51:04 <ksf> I never said it was worse, I just fail to see how it fits with all the other generics libraries, that *can* do it in a very similar way as syb.
09:51:12 <bitonic> monochrom: yeah, but that's the only similarity I could find :)
09:51:23 <ksf> how they do it differs, what kind of data types they support differ, but they all have some kind of everywhere etc. combinators.
09:52:11 <bitonic> ksf: well, what they usually mean with "generics library" is something that lets you perform generic traversal of data types. GHC.Generics can do that very well.
09:52:16 <ksf> the "figure out how to do what I mean"-API.
09:52:30 <bitonic> ksf: imo, the term does not imply anything about the implementation
09:53:12 <ksf> well, what I'm actually saying is that someone ought to implement those combinators for GHC.Generics.
09:53:46 <ksf> it's probably going to outperform syb big time, and not be as restricted as the faster libraries.
09:54:59 <bitonic> ksf: what would the declaration of `GEverywhere' look like? I'd be surprised if you can write something convenient
09:56:04 <bitonic> or write something at all, I don't know.
09:56:26 <ksf> figure out the type of the function you're supposed to apply, search the tree generically for all opportunities to apply it, then apply it.
09:57:46 <bitonic> ksf: well that's easier said then done, you probably need UndecidableInstances to make it work - if it works at all. I'll try later, it might be an interesting idea.
09:58:27 <ksf> you can take the syb approach and make the function Typeable a => a -> a
09:59:03 <ksf> or Generic a => , for that matter, that should give you the concrete type, too.
09:59:36 <bitonic> ksf: well yes, but that's not fun :D
09:59:57 <ksf> most applications are one-shot, and may even have the same type as another transformation, so making instances for each function to apply isn't really the best of ideas.
10:00:07 <theadmin> What kind of a software does the HaskellWiki run on? Can't find it anywhere...
10:00:15 <ksf> mediawiki
10:00:23 <ksf> feel free to port everything to gitit
10:00:28 * bitonic has to go, ksf: I will try something later
10:00:34 <spree> i cant find what >> actually does
10:00:50 <ksf> spree, it depends on the monad you're using it with.
10:00:54 <DMcGill> @src (>>)
10:00:55 <lambdabot> m >> k      = m >>= \_ -> k
10:01:04 <spree> P.char '#' >> P.many P.letter // doesnt parse to #haskell but to haskell
10:01:05 <ksf> well, yes, but >>= differs.
10:01:24 <geekosaur> >> is a slight modification to >>=.  what >>= does is up to each individual monad
10:01:39 <fryguybob> spree: That is matching the '#' but ignoring it.
10:01:44 <ksf> spree, yes, >> is throwing away the result of P.char
10:01:51 <spree> if i dont want that?
10:02:04 <ksf> spree, try "startsWith
10:02:09 <ksf> @hoogle startsWith
10:02:09 <lambdabot> No results found
10:03:07 <spree> is that in parsec?
10:03:12 <ksf> hmmm that combinator doesn't seem to exist.
10:03:14 <ksf> it ought to.
10:03:25 <spree> Parsec.startsWith isnt found
10:03:39 <ksf> (:) <$> char <*> many letter
10:04:18 <ion> (| char : many letter |)
10:04:37 <ion> (spree: Ignore that, it won’t actually work.)
10:04:43 <ksf> https://personal.cis.strath.ac.uk/conor.mcbride/pub/she/idiom.html
10:04:51 <ashashwat> So I need something - an integer T , followed by T test cases.  How do i take input ?
10:04:57 <ion> ksf: yeah
10:05:15 <theadmin> ashashwat: t <- readLn :: Integer
10:05:56 <DMcGill> (make sure to be using do-notation)
10:06:05 <ashashwat> theadmin: But how to stop.  In C we can do while(T--) { scanf(…) }
10:06:12 <ion> The question was ambiguous and theadmin’s answer was wrong in any case. :-P
10:06:35 <ashashwat> ion: input
10:06:37 <ashashwat> 3
10:06:37 <ashashwat> 1
10:06:37 <ashashwat> 2
10:06:38 <ashashwat> 3
10:06:44 <theadmin> Geez, use a pastebin...
10:06:46 <Taneb> I wrote a Collatz program with fix and the Writer monad
10:06:56 <ashashwat> that is it.  First input determines, how many more inputs.
10:07:04 <Taneb> Function, really
10:07:12 <ashashwat> theadmin: sorry.
10:07:48 <obk> Two questions; is it possible to TypeRep -> Name ? is it possible to Dynamic -> Q Exp ? (Doing some non-trivial Template Haskell here...)
10:07:49 <ion> do n <- readLn; replicateM n readLn :: IO [Integer]
10:08:00 <ion> Just guessing what you mean, perhaps this is it.
10:08:06 <ashashwat> ion: http://www.spoj.pl/problems/PALIN/
10:08:21 <DMcGill> ion: nice solution
10:10:38 <DMcGill> also the comments on that site are upsetting
10:10:51 <jfischoff> is there an option to have cabal save the sources of packages it pulls down? Sort of like a recursive unpack?
10:11:59 <Saizan> jfischoff: the tarballs are in under ~/.cabal/
10:12:03 <rwbarton> jfischoff: look in ~/.cabal/packages/hackage.haskell.org/ ?
10:12:47 <jfischoff> maybe they are somewhere else? I just have .config and .config.platform in my ~/.cabal folder
10:13:48 <hpaste> Taneb pasted “Collatz :)” at http://hpaste.org/70311
10:14:12 <Taneb> Damn, got the indentation wrong
10:14:45 <jfischoff> ah in remote-repo-cache:  location
10:14:56 <jfischoff> okay how about with cabal-dev?
10:15:05 <jfischoff> do they go in the same place?
10:15:06 <spree> does >> make it throw away what comes before? so i need to do some passOn here?
10:16:31 <theadmin> spree: "Sequentially compose two actions, discarding any value produced by the first, like sequencing operators (such as the semicolon) in imperative languages." -- from Hoogle's definition of >>
10:16:49 <Taneb> It disgards values, keeps context
10:17:18 <spree> so can i make Parsec parse JOIN and ignore case?
10:18:00 <spree> i solved the previos problem by just doing square <- P.many (P.char '#')
10:19:18 <spree> ¨guess i should lowercase everything first...
10:19:56 <spree> @hoogle lowercase
10:19:57 <lambdabot> Data.Char LowercaseLetter :: GeneralCategory
10:20:23 <tac-tics> spree: You could write your own combinator for parsing a case-insensitive string matcher
10:20:37 <spree> also (++) is terrible right but shouldnt matter for irc posts...
10:20:50 <ksf> do we have a symbolic standard algebra package?
10:21:17 <ksf> refactoring an equation to a certain variable etc.
10:22:28 <theadmin> spree: There is toLower in Data.Char (if you want to apply it to a String, just map) to turn characters to lowercase.
10:24:45 <bitonic> Tinned_Tuna: are you referring to OverloadedStrings? You can use fromString directly
10:24:54 <spree> so i might want to hide prelude functions
10:25:12 <spree> but then it will be a bit messy in main and so on right?
10:26:29 <DMcGill> @hoogle toLower
10:26:30 <lambdabot> Data.Char toLower :: Char -> Char
10:26:30 <lambdabot> Data.Text toLower :: Text -> Text
10:26:30 <lambdabot> Data.Text.Lazy toLower :: Text -> Text
10:26:46 <DMcGill> > map toLower "Test"
10:26:47 <lambdabot>   "test"
10:26:47 <theadmin> spree: Messy? Just hide the functions you don't need imported, write your own definition (or get it from elsewhere) and use that... I don't see what would be "messy"
10:26:50 <Peaker> parcs`, don't think so - though now that it's on github, next time I have time for it I might be able to do more serious work
10:27:00 <DMcGill> ahh, sorry theadmin
10:27:06 <theadmin> DMcGill: ?
10:27:12 <DMcGill> didn't see what you said
10:27:19 <theadmin> DMcGill: Ah, no problems there
10:28:21 <spree> parseIRCLine parser txt = case (P.parse parser txt txt) of  /// why the txt txt in the case? because the my spits out (String, String) ? But it seems illogical to repeat txt
10:30:39 <spree> so naming, would you name an irc command parser to ircCommand or ircCommandParser?
10:32:09 <geekosaur> I'd use -Parser for the parser, since ircCommand seems like it would be a command *processor*
10:32:45 <geekosaur> (meaning, what I would invoke for IRC commands to be invoked from somewhere in the code)
10:33:05 <geekosaur> possibly parseIrcCommand instead
10:37:43 <solrize> is there a word for something that's beautiful and horrifying at the same time?  i'm thinking of memo combinators.
10:37:48 <spree> so how can you write comments in haskell to export them do docs? do anyone use @param and @return like with javadocs or the type declaration and a comment is enough?
10:38:21 <spree> beaurrying
10:38:30 <DMcGill> spree: look at the docs for Haddock
10:38:46 <Peaker> solrize, why horrifying?
10:39:05 <fryguybob> @where haddock
10:39:05 <lambdabot> http://www.haskell.org/haddock/
10:39:16 <DMcGill> comments starting with --| talk about the thing after them and -- ^ refers to the thing before it
10:39:44 <Peaker> does --| work for params as well?
10:39:44 <solrize> peaker just the amount of abstract machinery and delicate reasoning needed to implement the rather simple idea of memoization
10:39:54 <DMcGill> like: foo = bar --^ foo is a function
10:40:01 <Peaker> solrize, conal's?
10:40:25 <lpsmith> solrize, it's not that much.   And it's a lot better than imperative languages, really
10:40:28 <Peaker> solrize, I think it's pretty straightforward (e.g in the Bool->  case)
10:41:30 <solrize> i'm not sure who wrote the one i'm thinking of... i haven't looked at the code, just read through a description and spent a couple hours trying to figure out how to write it.  i'm talking about the one that uses the infinite corecursive trie
10:42:52 <solrize> and this semi-intricate imperative algorithm is going on completely behind the scenes
10:44:09 <solrize> which is a bit cringe-inducing if the idea of haskell is solid mechanisms (type system etc) for tracking the values in a program
10:44:27 <solrize> and being the world's finest imperative language by making sequencing explicit with monads
10:44:37 <ksf> more than that.
10:44:51 <ksf> haskell does monads, imperative languages usually only do arrowchoice.
10:45:05 <DMcGill> Peaker: --^ certainly does work with the params in a type signature
10:45:32 <DMcGill> although I can't find an example at the moment
10:45:46 <solrize> http://hpaste.org/70314   but i figured out how many ways there are to change a 100 euro note, and it was sort of an epiphany
10:46:06 <solrize> that uses an array for memoization
10:46:09 <ksf> ever noticed that CPS creeps in really fast into haskell code that becomes only a bit more complex, control flow-wise?
10:46:12 <solrize> i didn't do it with a trie
10:46:54 <ksf> though half of that is having proper tail calls.
10:47:04 <ksf> I'd love a tail-call enabled C.
10:47:14 <solrize> gcc does tco
10:47:23 <ksf> when you write CPS?
10:47:42 <solrize> well it doesn't have proper continuations
10:47:47 <solrize> that would require copying the stack
10:48:00 <ksf> not pushing the return address would suffice for a start.
10:48:13 <ksf> that is, second-class continuations.
10:48:16 <solrize> that's just ordinary tco and it does that, i think
10:48:39 * theadmin has no idea what everyone's talking about... What's that about C? What's a TCO? What's a CPS...
10:48:51 <solrize> tco = tail call optimization
10:48:56 <solrize> cps = continuation passing style
10:49:02 <ksf> keeping hold of something more first-class, like a function pointer and an arg array, is a thing that should be done by hand in C.
10:49:12 <theadmin> You know... That didn't make any more sense just now :D
10:49:28 <strager> Well now you have Googling terms.  =]
10:49:35 <theadmin> strager: True :D
10:49:53 <ksf> theadmin, CPS: http://c2.com/cgi/wiki?OriginalIoLanguage
10:49:58 <solrize> theadmin      int f(int x) { return 3 + g(x); }
10:50:01 <solrize> no wait
10:50:33 <solrize> int f(int x, int y) { return g(x+y); }
10:50:49 <solrize> compiled straightforwardly would do two levels of function calls
10:51:00 <ksf> void f (int x, cont k) { k (x + 4 }
10:51:00 <taylorgb_> Relying on TCO taking place is far too risky for my liking.
10:51:01 <solrize> with tco the call to g gets compiled into a goto
10:51:07 <ksf> neither f nor k ever return.
10:51:25 <ksf> ...and cont is a typedef for a function pointer.
10:51:32 <solrize> hmm
10:51:46 <theadmin> ksf: http://imgs.xkcd.com/comics/(.png
10:51:46 <solrize> yeah i'd expect tco should handle that
10:52:06 <ksf> hey, that's a contained one.
10:52:13 <S11001001> taylorgb_: scala, at least, has tco-assertions; should be elsewhere
10:52:16 <ksf> it's perfectly unambigious.
10:52:30 <solrize> hedgehog lisp has those assertions too, it seemed like a good idea
10:53:01 <ksf> and scheme has a spec for it.
10:53:24 <solrize> scheme has a spec for tco assertions?  cool
10:54:02 <ksf> no, for tco.
10:54:13 <ksf> if you want to call yourself scheme, you gotta do tco.
10:54:53 <solrize> oh.  by tco assertion i thought you meant compile time flagging of non-tco
10:55:20 <solrize> i.e.  (define (f x) (tailcall (+ (g x) 3)))
10:55:21 <ksf> well, with scheme you can see whether something's a tail call on a quick glance.
10:55:29 <solrize> would raise a compilation error
10:55:37 <S11001001> ksf: I think we don't rely on that sort of thing in #haskell
10:55:53 <ksf> yep.
10:55:59 <S11001001> ksf: particularly as it becomes nonobvious with macroexpansions
10:56:07 <ksf> those foldr/foldl-comparison blew my mind back in the days.
10:56:19 <ksf> and that after believing that scheme itself blew my mind throughoutly.
10:56:43 <solrize> http://stackoverflow.com/questions/4980102/how-does-data-memocombinators-work  ksf, this is great :)
10:56:47 <ksf> "no you don't want that to be a tail call, you want to be lazy"
10:57:07 <S11001001> (let lp () (might-dynamic-wind (if blah (lp)))) ;is (lp) a tail call?
10:57:11 <spree> is String == [Char] ? but cant be used interchangeably?
10:57:26 <solrize> spree yeah type synonym
10:57:48 <ksf> it can be used interchangably.
10:58:13 <ksf> except maybe in instance and class declarations, depending on enabled extensions.
10:59:48 <theadmin> spree: Yes, indeed, they're the same. Though String looks prettier.
11:11:41 <ksf> that was easier than I thought.
11:13:46 <theadmin> ksf: What was?
11:14:28 <ksf> messing with equations. rearranging them to whatever variable.
11:14:57 <ksf> though granted I took the easiest way, I just generate every possible rearrangement and then filter for the one I want.
11:16:25 <b_> what's the easiest way to get a substring of a string so that: f "foo" "bar" "foocakesbar" == "cakes"
11:17:23 <ksf> @hoogle stripPrefix
11:17:23 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
11:17:23 <lambdabot> Data.Text stripPrefix :: Text -> Text -> Maybe Text
11:17:23 <lambdabot> Data.Text.Lazy stripPrefix :: Text -> Text -> Maybe Text
11:17:24 <strager> So, f s e x -- find s in x, then find e in x after s, and return the middle?
11:18:08 <ksf> then isSuffixOf and drop it if it's there.
11:18:31 <ksf> but when you're doing such stuff you're probably doing a bit more of it, and a parser library will be your friend.
11:18:55 <ksf> foo.*bar
11:19:11 <ksf> or rather foo(.*)bar
11:19:40 <strager> string "foo" *> many char <* string "bar" -- with a 'try' in there somewhere probably
11:21:29 <glguy> parseTest (string "foo" >> manyTill anyChar (try (string "bar"))) "foocakesbar"
11:24:14 <spree> should i "always" import qualified?
11:24:58 <fmap> glguy: isn't `(string "foo" >> manyTill anyChar (string "bar"))' enough?
11:25:55 <glguy> fmap: it isn't
11:25:56 <glguy> parseTest (string "foo" >> manyTill anyChar ( (string "bar"))) "foobcakesbar"
11:25:58 <glguy> try that
11:27:05 <glguy> spree: You don't need to import every module qualified
11:27:14 <fmap> glguy: aha. thanks
11:28:44 <spree> cant i finish a do with case x of blah -> print x; gah -> print "hello" ?
11:29:04 <glguy> yes, you can end a do block with a case
11:29:35 <parcs`> spree: you can finish it with any arbitrary expression
11:38:31 * hackagebot cmdtheline 0.1.0.0 - Declaritive command-line option parsing and documentation library.  http://hackage.haskell.org/package/cmdtheline-0.1.0.0 (EliFrey)
11:39:00 <hpaste> spree pasted “case print type error” at http://hpaste.org/70317
11:39:18 <spree> i dont see how it can expect (String, String) ^^
11:40:17 <glguy> Just (com, t)
11:40:28 <glguy> That pattern matches a Maybe (String,String), it seems
11:40:38 <spree> which it should
11:41:42 <spree> com is Maybe (String, String) then how do i pat match if not as i did?
11:41:49 <glguy> Nothing       -> ()
11:41:52 <glguy> this is probably wrong
11:42:12 <glguy> maybe you meant "return ()" ?
11:43:11 <spree> i dont want to return
11:43:19 <spree> i write to a socket in there
11:43:29 <spree> if i coment out hte nothing i get same error
11:43:49 <monochrom> "return ()" means no-op
11:43:50 <geekosaur> spree, return is not a flow of control command
11:44:10 <spree> no-operation?
11:44:13 <geekosaur> it lifts () into the monad
11:44:25 <monochrom> just try it, see what happens, do not opine
11:44:25 <glguy> spree: () is never a valid expression as line in a do-block
11:44:31 <geekosaur> which makes it a properly typed no-op
11:45:02 <spree> i found one error
11:45:13 <spree> Just (c, t) it should be...
11:46:15 <monochrom> what is "_input_" supposed to mean?
11:47:53 <akamaus> hi, is it appropriate place to ask about Haskore?
11:48:33 <monochrom> I think so
11:50:54 <levi> What's Haskore?
11:51:04 <ion> @hackage haskore
11:51:04 <lambdabot> http://hackage.haskell.org/package/haskore
11:51:13 <c_wraith> a music composition system
11:52:29 <spree> monochrom: just a new var_name?
11:54:02 <monochrom> alright, _input_ is allowed, nevermind
11:54:36 <glguy> spree: _names are typically used for named but unused variables
11:55:08 <c_wraith> indeed.  That convention is so baked-in that ghc doesn't warn about unused variables that start with _
11:55:12 <akamaus> ok, I'm trying to render a trivial midi file using Haskore. The following code http://pastebin.com/DUTKLWk0 throws an  *** Exception: InstrumentMap.lookup: Instrument unknown
11:55:15 <mauke> The paste DUTKLWk0 has been copied to http://hpaste.org/70320
11:55:48 <monochrom> I think you use "com" too many times. I don't know which is which in your mind. (oh, I know well what the compiler thinks, that's beside the point)
11:56:08 <akamaus> wow, hpaste really hungry these days :)
11:56:42 <monochrom> the #python people do the same thing to pastebin.com pastes, so it's not just us
11:58:17 <monochrom> haskell people and python people agree on 3 things: use fibonacci early in tutorials; replace pastebin.com pastes; lambda expressions are for expressions only. :)
11:59:07 <theadmin> monochrom: 4) Indentation is cool
11:59:18 <theadmin> Though, Python forces it, Haskell encourages it. But still.
11:59:48 <monochrom> oh, yes, I forgot indentation
12:00:30 <bitonic> ksf: yes, it can be done, without the need for Typeable or UndecidableInstances: https://gist.github.com/2974529
12:00:56 <spree> monochrom: yeah i fixed com and used c but still same error
12:01:11 <bitonic> ksf: ah no wait.
12:01:16 <monochrom> alright then I want to know which is com and which is c
12:01:30 <bitonic> ksf: no scrap that, I need to tweak it more :P
12:01:37 <bitonic> ksf: with Typeable is really simple
12:03:06 <monochrom> oh, I see, "com <- P.parseIRCtext ..." is using the Maybe monad, not the IO monad
12:03:47 <monochrom> > do { x <- Just 3; case x of {Nothing -> undefined; Just y -> undefined}}
12:03:48 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe t))
12:03:48 <lambdabot>    arising from the lite...
12:04:03 <monochrom> you're looking that that kind of type errors
12:04:25 <hpaste> spree annotated “case print type error” with “case print type error (annotation)” at http://hpaste.org/70317#a70321
12:04:41 <monochrom> if the compiler decides that your do-block is using the Maybe monad, then x's type is no longer Maybe Blah, it's just Blah
12:04:43 <spree> http://hpaste.org/70317 <-- updated
12:05:52 <monochrom> you should change it to "let com = P.parseIRCtext ..."
12:08:01 <spree> ok compiles, ty
12:20:42 <Targen> What would be a proper way of suspending a thread until an exception is received?
12:23:04 <monochrom> loop over a prolonged threadDelay. block on an MVar that will never be updated. retry in STM for a change that will never happen.
12:23:20 <ion> Why an exception? Why not a message over a channel instead?
12:23:29 <Targen> ah.
12:23:59 <Targen> I was hoping there was something explicitly designed for that.  I just want to wait for a keyboard interrupt in the main thread, and then clean up and exit.
12:24:33 <ion> s/channel/(T)MVar/
12:25:08 <Targen> It happens anyways when using a compiled executable, of course, but when running it under GHCi only the main thread is interrupted and the rest go on.
12:25:17 <parcs`> i use forever (threadDelay maxBound)
12:25:36 <Targen> That should do it quite nicely.  Thanks! :)
12:26:58 <bitonic> ksf: ok, done! are you there?
12:27:34 <bitonic> ksf: https://gist.github.com/2974627 just GHC.Generic
12:35:03 <bitonic> @tell ksf it's doable with just GHC.Generic, see https://gist.github.com/2974627
12:35:04 <lambdabot> Consider it noted.
12:35:50 <spree> GHC.IO.Handle.Types.Handle how is that type not available if ghci can derive it for a function?
12:38:55 <geekosaur> spree, it's reexported
12:39:29 <ironwaist> Hi I have a haskell noob question can you use a where clause in an if expression ?
12:40:29 <zzo38> One thing I wanted to use in Haskell (or Ibtlfmm) would be closed classes or automatic instances (which are a generalization of closed classes). In Haskell you might have:  auto_instance :: ([Type] -> Q (Maybe [Dec])) -> Q [Dec];  You can use this in a class declaration to make it closed and automatic.
12:40:41 <theadmin> ironwaist: Probably not (not in a way I see anyway), why not let?
12:40:58 <geekosaur> ironwaist, no, it is only valid as part of a binding
12:41:00 <spree> how would I do if when anything happens on a channel then alert the irc-gui? like an listener or observer in java.
12:41:02 <ironwaist> well how would I use let with if
12:41:13 <ironwaist> can you give me an example
12:41:51 <geekosaur> anywhere you can have an expression, you can also have let <bindings> in <expression>
12:42:05 <zzo38> And then, you would be unable to add additional instance declarations although it is possible to do things such as a constraint that asks for the nonexistence of an instance.
12:42:06 <theadmin> ironwaist: let { a = 1; b = 2 } in if a > b then "bad" else "good"
12:42:11 <ironwaist> ok thanks
12:42:11 <theadmin> ironwaist: Something along those lines.
12:42:28 <spree> > let x = 5 in if x > 0 then print "hej" else print "nej"
12:42:30 <lambdabot>   <IO ()>
12:42:44 <spree> > let x = 5 in if x > 0 then 1 else 7
12:42:46 <lambdabot>   1
12:43:10 <fmap> > if let a = 3; b = 4 in a == b then "yes" else "no"
12:43:10 <spree> > let x = 5 in if x > 0 then let a = 7; a else 7
12:43:11 <lambdabot>   "no"
12:43:11 <lambdabot>   can't find file: L.hs
12:43:28 <ironwaist> do I need to use those brackets if I need to bind multiple variables
12:43:59 <S11001001> no use newlines
12:43:59 <geekosaur> only if you're doing it all on one line
12:44:00 <monochrom> my little irc-monitoring program actually does have some kind of listener infrastructure. one thread (and only that thread) directly gets all the irc messages. it then broadcasts to registered listeners. broadcast means sending messages through Chan.
12:44:03 <theadmin> ironwaist: You can also use indentation
12:44:03 <geekosaur> normally we use layout
12:44:07 <zzo38> Using this automatic instances might allow you to implement something like The Trex implementation in Hugs, except that it is user-defined. There are many other things you could do with thist oo.
12:44:27 <geekosaur> spree:  that would be "let a=7 in a"; no semicolon
12:47:18 <zzo38> What would you think of this kind of closed classes/automatic instances?
12:50:23 <spree> > let x = 5 in if x > 0 then let a = 5 in a else 7
12:50:25 <lambdabot>   5
12:50:32 <spree> how would I do if when anything happens on a channel then alert the irc-gui? like an listener or observer in java.
12:51:07 <spree> the roll your own bot uses polling which is quite resource consuming, isnt there some reactive way of solving this or i need to use threads?
12:53:52 <monochrom> I thought I answered
12:58:52 <spree> i see
12:58:56 <spree> now
12:59:07 <spree> not that explicit though. how do you listen?
12:59:32 <roconnor_> I was thinking about polymorphic record updating last night
12:59:52 <roconnor_> the problem is that lenses do not support polymorphic record updating
13:00:25 <roconnor_> however, van laarhoven style lenses can easily be addapted to support polymorphic record updating
13:01:22 <roconnor_> behold:  fstLens :: Functor f => (a -> f a') -> (a,b) -> f (a',b)
13:01:32 <monochrom> to listen: I call one procedure. it gives me the reading end of a channel. I loop over reading from that channel.
13:01:58 <roconnor_> maybe I should make a record proposal supporting polymorphic lens updates with van laarhoven lenses
13:02:01 <zzo38> What are van laarhoven style lenses?
13:02:13 <tgeeky> zzo38: it's one of the definitions of 'well behaved'
13:02:13 <lambdabot> tgeeky: You have 1 new message. '/msg lambdabot @messages' to read it.
13:02:26 <roconnor_> zzo38: Lens a b := Functor f => (b -> f b) -> (a -> f a)
13:02:46 <zzo38> roconnor_: OK.
13:02:52 <spree> hmm, i think ill leave the gui for now, i know how to do it , ill just do a command line irc client first
13:03:01 <ironwaist> Can I pattern match on a specific char in the head of a list like "f '&':cs = ..." ?
13:03:35 <spree> so basically everytime something happens on #channel i want to print to mingw and i want to listen to input from myelf, how do i do that without polling?
13:03:43 <zzo38> I have preferred this style of lenses:  newtype Lens c1 c2 x y = Lens (c1 x (c2 y x, y));  You then get the ordinary lens when c1 and c2 are both (->)
13:04:14 <roconnor_> zzo38: okay now generalize that to support polymorphic updates :D
13:04:36 <zzo38> roconnor_: OK, let's try
13:05:23 <zzo38> Does your lens form a category?
13:05:31 <roconnor_> yes
13:05:37 <zzo38> OK
13:05:37 <monochrom> one thread blocks on stdin. another thread blocks on irc socket. etc.
13:05:43 <roconnor_> zzo38: composition is . and the identity lens is id
13:06:08 <zzo38> Yes, that works
13:06:16 <roconnor_> bbl
13:06:20 <tgeeky> roconnor_: your definition will generalize to any scheme other than (fst,snd), I assume?
13:06:37 <spree> blocks?
13:07:06 <monochrom> for example "getLine" blocks on stdin
13:07:23 <fmap> ironwaist: `f ('&':xs) = …'
13:07:37 <monochrom> you have never heard of "blocking"?
13:08:51 <zzo38> rocommor_: How do you use your lens with other categories?
13:10:03 <zzo38> Perhaps you would know how.
13:10:57 <spree> monochrom: how would i do that? by polling?
13:11:19 <spree> whats all that functional reactive programming, cant i use that?
13:12:40 <monochrom> I don't understand the question. you just call getLine, and magic happens. I don't know what more needs to be done.
13:16:14 <yrlnry> Who's Chung-chieh Shan? I feel I should recognize the name.
13:16:47 <Botje> he's on a similar level as oleg :)
13:16:59 <monochrom> aka Ken Shan
13:17:00 <yrlnry> He's co-published with Oleg too.
13:17:05 <yrlnry> Does he hang out here?
13:17:09 <monochrom> no
13:17:43 <yrlnry> I wonder I've met him.
13:18:06 <hpc> we should try and rope some more phds into irc
13:18:43 <hpc> edwardk needs some competition in the department of abstract nonsense
13:18:53 <monochrom> http://www.cs.rutgers.edu/~ccshan/  but probably you already know
13:20:35 <zzo38> hpc: OK; does Edward Kmett have any PhD?
13:20:38 <cg_morton> what's the correct syntax for a State monad?  I try to run the examples straight from Learn You a Haskell, and ghci says "Not in scope: data constructor 'State'"
13:21:08 <mgsloan> I am actually going to enjoy the final class of a 5 class series taught by Oleg and Chung-chieh, about 2 hrs from now
13:21:20 <parcs`> cg_morton: perhaps you want StateT
13:21:21 <geekosaur> cg_morton, things got rearranged recently, use state instead of State
13:21:28 <mgsloan> it's been an amazing class so far, they really have an awesome lecturing dynamic together
13:21:36 <parcs`> oh right, state
13:21:57 <cg_morton> okay I'll try that, thanks
13:22:50 <mgsloan> By day 2 (1.5hr classes), they'd introduced ADTs, typeclasses, type functions, pattern matching, and rudimentary expressions.  What's amazing, is that people with no programming background "got" it.
13:24:09 <mgsloan> further re-enforcing the theory that if you know semantics / lambda calculus well, then Haskell is pretty straightforward.  Whereas the programmers in the crowd were left a little confused (I later explained to them that classes basically introduce vtables)
13:25:52 <mgsloan> oleg's as impressive in person as on paper!  He weighs in on quite a lot of the more linguistics heavy classes
13:28:21 <aristid> @quote oleg
13:28:21 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
13:28:44 <spree> but i need to repreatedly to getLine...'
13:30:11 <geekosaur> and?  no matter what, you'll need to do that.  it's not inefficient unless you're feeding it thousands of lines persecond.
13:32:10 <geekosaur> and even then, while it's somewhat inefficient it's still more efficient than most of the alternativesd
13:32:15 <geekosaur> as for your comment about FRP as an alternative, no.  it's not a replacement for the runtime's events, it's a way to work *with* those events.  you have a thread which blocks on getLine and injects FRP events, then other things use the FRP framework to listen for those events
13:42:38 <spree> wow forkIO it is that simple and whips i have a thread that listens and i can poll with my normal one
13:49:11 <monochrom> getLine is not polling
13:52:45 <navaati> doesn't it use polling under the hood ?
13:53:05 <spree> getLine is polling if it is done like this:
13:53:11 <wykis> bow
13:53:12 <wykis> wow
13:53:54 <monochrom> "under the hood" is a rabbit hole. how do you know whether there is polling or not at the hardware level? transistor level? and does it matter?
13:54:23 <hpaste> spree pasted “polling” at http://hpaste.org/70322
13:55:09 <spree> getLine itself isnt poll now but forever getLine is...am i using getLine wrong?
13:55:24 <monochrom> to stay real, let's just stay at the API level. when getLine returns, you are guaranteed a line, rather than "oh you get no line, call again". therefore it is not polling. at the API level
13:56:39 <monochrom> you're using "polling" wrong
13:56:48 <spree> so it doesnt return until it gwets a line?
13:56:55 <spree> ok
13:57:14 <monochrom> you don't know already? haven't you tried?
13:57:28 <spree> yes
13:57:32 <spree> i did know
13:57:34 <geekosaur> spree:  somewhere inside the I/O manager, there is a select() or poll() call which blocks on a bunch of file descriptors until one of them indicates that it has either data or an error condition
13:57:50 <geekosaur> despite the name poll(), it is not polling in the sense of looping on a condition
13:58:01 <spree> i see
13:58:28 <spree> but since i need to get a new line again after getLine returns i have to poll...
13:58:49 <navaati> oh, yeah… i was using polling in the sense of "using poll or select", but… polling is something else
13:59:00 <monochrom> I am not talking to you anymore until you stop calling that "polling"
13:59:09 <stephenjudkins> spree: under the hood, i assume it uses epoll (http://en.wikipedia.org/wiki/Epoll) or kqueue
13:59:11 <spree> me?
13:59:19 <geekosaur> and?  I already told you that isn't inefficient, and it also is not really polling in the sense you seem to mean
13:59:52 <monochrom> polling means when the call returns it can say "no answer"
14:00:25 <monochrom> getLine cannot say "no answer"
14:00:33 <geekosaur> you are looping certainly, but it is not a tight loop running constantly unless you are delivering massive amounts of data --- and even then, at some level you are going to loop unless your intent is to read everything all at once and process it as a single huge lump
14:01:11 <monochrom> even select() and poll() could be used so that they won't say "no answer"
14:01:14 <geekosaur> so it is not polling in the sense you are thinking of.  nor is it ever, as noted, looping on "no data yet?  try again"
14:02:11 <rwbarton> it possibly is polling "in the sense spree is thinking of"
14:03:05 <rwbarton> i think that is most likely the source of confusion here
14:04:15 <monochrom> by that sense, every reactive program polls. proof: every reactive program expects infinitely many messages, therefore makes infinitely many calls. that is a useless definition.
14:05:21 <rwbarton> right i think spree thinks "polls" just means "checks for input" without any implication of what happens in the event that there is no available input yet
14:06:21 <spree> i see the difference
14:09:32 <lcfrs> Can someone point me to a resource on using FRP to model hierarchical state machines?
14:09:55 <geekosaur> so, I'm not sure what you are worried about then.
14:11:32 <monochrom> it seems to me, misinformed worry about efficiency, as usual.
14:12:43 <monochrom> informed worry about efficiency is fine, I must emphasize. but misinformed worry, e.g., wrong premises based on wrong labelling...
14:17:57 <Catnaroek> Hello. Is there some syntactic sugar for "f x pred = if pred x then whatever else return ()"?
14:18:07 <Catnaroek> Well, not syntactic sugar.
14:18:10 <Catnaroek> Library sugar
14:18:41 <solrize> when (pred x) whatever
14:18:49 <Catnaroek> Also, s/return ()/(return x)/
14:18:56 <solrize> > when (2 < 3) $ print "hi"
14:18:58 <lambdabot>   <IO ()>
14:19:00 <Catnaroek> Oh.
14:19:01 <tac-tics> Catnaroek:  like a guard?
14:19:06 <Catnaroek> Yes.
14:19:12 <tac-tics> f x pred | pred x = whatever; otherwise = return ()
14:19:31 <Catnaroek> tac-tics: The problem is I cannot use guards inside do blocks.
14:19:37 <solrize> :t Control.Monad.when
14:19:37 <tac-tics> oh
14:19:38 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
14:19:39 <tac-tics> um
14:19:46 <Catnaroek> solrize: I like that "when" thing. :)
14:19:46 <tac-tics> @type guard
14:19:48 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
14:20:05 <Catnaroek> @src when
14:20:06 <lambdabot> when p s = if p then s else return ()
14:20:11 <Catnaroek> Oh!
14:20:18 <tac-tics> yeah, something like that :)
14:20:21 <c_wraith> :t when . ?pred
14:20:21 <lambdabot> forall (m :: * -> *) (f :: * -> *). (Monad m, ?pred::f Bool, Functor f) => f (m () -> m ())
14:20:34 <c_wraith> hmm
14:20:40 <c_wraith> that didn't turn out at all like I expected
14:20:45 <c_wraith> oh, because . is too general
14:20:55 <solrize> whats ?pred   ?
14:20:58 <c_wraith> :t when (Prelude..) ?pred
14:20:59 <lambdabot>     Couldn't match expected type `Bool'
14:20:59 <lambdabot>            against inferred type `(b -> c) -> (a -> b) -> a -> c'
14:20:59 <lambdabot>     In the first argument of `when', namely `(GHC.Base..)'
14:21:08 <rwbarton> no ()
14:21:14 <c_wraith> oh, right
14:21:18 <c_wraith> :t when Prelude.. ?pred
14:21:20 <lambdabot> forall (m :: * -> *) a. (Monad m, ?pred::a -> Bool) => a -> m () -> m ()
14:21:42 <c_wraith> using qualified infix operators just feels wrong
14:21:58 <c_wraith> so, actually, the thing in question
14:22:02 <c_wraith> :t (when .)
14:22:03 <lambdabot> forall (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f Bool -> f (m () -> m ())
14:22:15 <c_wraith> yeah.  something like that.
14:22:25 <c_wraith> :t (when Prelude..)
14:22:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> Bool) -> a -> m () -> m ()
14:27:22 <ksf> has anyone ported the blaze-builder optimisations to binary or cereal, yet?
14:27:22 <lambdabot> ksf: You have 1 new message. '/msg lambdabot @messages' to read it.
14:29:29 <ksf> @msg bitonic cool!
14:29:30 <lambdabot> Not enough privileges
14:29:36 <ksf> @tell bitonic cool!
14:29:37 <lambdabot> Consider it noted.
14:30:56 <tac-tics> @help msg
14:30:56 <lambdabot> msg <nick or channel> <msg>
14:31:00 <tac-tics> ah
14:31:42 <ksf> hmm. I think I should use blaze for building and enumerator for parsing.
14:34:27 <ksf> snap uses attoparsec.
14:34:34 <ksf> I don't trust attoparsec, though, not regular enough.
14:38:34 <lcfrs> bos: pm?
14:39:59 <spree> thread blocked indefinately in an MVar operation
14:40:56 <tac-tics> spree: did you try reading without ever doing a write to it?
14:41:12 <roconnor_> tgeeky: I am hopeful my definition would generalize.
14:41:20 <spree> channel <- newMVar chan //first thing i did
14:42:03 <roconnor_> tgeeky: but I don't know how tricky records can be.
14:42:17 <monochrom> yeah you need 2 threads to make an MVar useful
14:42:19 <bos> lcfrs: ?
14:43:11 <lcfrs> bos: about another tech talk in SF, i can email you if you're busy
14:43:17 <tac-tics> spree: *creating* a channel doesn't *write* to it
14:43:34 <tac-tics> spree: which is kinda weird, but it's the way it is :)
14:43:55 <tac-tics> oh
14:43:57 <tac-tics> sorry
14:44:02 <tac-tics> @type newMVar
14:44:03 <lambdabot> Not in scope: `newMVar'
14:44:11 <tac-tics> gah
14:44:24 <tac-tics> Yeah, you can create an empty one or you can create a pre-filled one
14:44:35 <monochrom> well then someone has to takeMVar
14:44:46 <tac-tics> yeah
14:44:57 <tac-tics> If you try to read from an empty mvar, it will block.
14:45:02 <tac-tics> If you try to write to a full mvar, it will block
14:45:05 <hpaste> erkin pasted “cabal error for ncurses” at http://hpaste.org/70324
14:45:10 <monochrom> if someone takeMVar twice, then someone else has to putMVar somewhere
14:45:28 <erkin> I can't get ncurses to compile.
14:45:34 <monochrom> anyway all these should be elementary
14:45:42 <erkin> And my small brain can't interpret that error.
14:45:45 <geekosaur> the ncurses package really needs to be updated at some point to deal with modern ncurses
14:45:52 <Peaker> I hate ncurses
14:46:03 <jfischoff> it hates you
14:46:07 <erkin> :(
14:46:09 <Peaker> it is a terrible API, partial functionality, and there are better alternatives
14:46:10 <monochrom> you can curse n times :)
14:46:16 <bos> lcfrs: email please
14:46:27 <geekosaur> erkin:  ncurses used to come in two flavors, normal and wide (~= Unicode) characters.  they've been merged for several years now but the Haskell ncurses packages were never updated to match
14:46:38 <erkin> What do I do then?
14:46:43 <monochrom> yikes
14:46:54 <hpaste> erkin pasted “More ncurses errors.” at http://hpaste.org/70325
14:46:59 <geekosaur> so you can get that error from trying to use the old ncursesw (wide character) variant, or another one from a stupid linker trick used by some Linux distributions for backward compatibility
14:47:02 <monochrom> I guess everyone hates ncurses, so no one updates the haskell binding :)
14:47:05 <Peaker> at least back when I used ncurses, it couldn't even do colors properly, and was limited to defining up to 16 silly color pairs you could use, when the underlying terminal had no such limitation iirc
14:47:06 <armlesshobo> :O
14:47:10 <armlesshobo> i like ncurses lol
14:47:12 <Peaker> Why not use vty?
14:47:22 <Peaker> it is so much better than ncurses
14:47:39 <armlesshobo> Peaker: because you didn't have color back then? :P
14:47:41 <geekosaur> aaand there's the stupid linker trick, right on cue
14:47:50 <erkin> Attempting to install lambdabot gives that error.
14:47:56 <erkin> The second one I pasted.
14:48:23 <parcs`> the 16 color pair thing was probably for performance reasons
14:48:30 <erkin> I really don't have anything to do with ncurses, I just want to get lambdabot to work.
14:48:32 <Peaker> parcs`, how so?
14:49:09 <Peaker> erkin, I am guessing you have a broken symlink for the ncurses so
14:49:34 <realitygrill> i keep misreading how . and $ will apply
14:49:36 <geekosaur> Peaker:  no, thats ncurses.so being a linker script pointing to ncursesw.so
14:49:39 <erkin> Where exactly should it be symlinked to?
14:49:41 <realitygrill> is there something that will let me practie that?
14:49:45 <geekosaur> which ghci's linker doesnt understand
14:49:53 <Peaker> geekosaur, oh, that terribleness bit multiple people already
14:49:58 <erkin> $ < /usr/lib/gcc/x86_64-unknown-linux-gnu/4.7.1/../../../../lib/libncurses.so
14:49:58 <erkin> INPUT(-lncursesw)
14:50:03 <geekosaur> the workaround is to replace the linker script with an actual symlink
14:50:05 <erkin> That single line is all it has.
14:50:10 <Peaker> geekosaur, doesn't ghc/i use the ordinary linker?
14:50:24 <geekosaur> ghc does, ghci doesn't
14:50:36 <geekosaur> which is something that is scheduled to be fixed at some point but hasn't been yet
14:50:52 <geekosaur> (it's one of the reasons ghci doesn't work on some architectures)
14:51:21 <parcs`> Peaker: i'm just speculating but you'll need less bits to tell what color something is if you have a predefined color table
14:51:37 <geekosaur> that's part of it, parcs`
14:52:02 <geekosaur> but the real reason is that, back when that API was standardized, most terminals *did* work that way; you had to program colors or colorpairs
14:52:16 <Peaker> geekosaur, oh, so whoever relies on TH cannot link on these systems either
14:52:18 <spree> i can just do putMVar into a nonempty MVar right?
14:52:24 <geekosaur> Peaker, yes, exactly
14:52:33 <Peaker> that's pretty awful :(
14:52:50 <Peaker> spree, that'll block
14:53:14 <erkin> The thing is, I replaced the script with a symlink and now it breaks of different reasons.
14:53:19 <rwbarton> is the ghci linker thing also why ghci doesn't work (or works poorly) with certain libraries like gtk or opengl
14:53:25 <monochrom> you can, it will block
14:53:32 <geekosaur> (n)curses was developed back when there was no standard for terminals, and there were many, many different (physical!) terminals each of which worked in a different way
14:53:33 <rwbarton> or is that a different issue
14:53:42 <hpaste> erkin pasted “cabal install error” at http://hpaste.org/70326
14:54:02 <geekosaur> rwbarton, I think that is related to sandboxing and thread handling in ghci
14:54:58 <monochrom> by default, every ghci command is run in a new unbound thread
14:54:58 <Catnaroek> Is there anything like "when' pred retFun x = if pred x then retFun x else return x"?
14:55:03 <parcs`> rwbarton: the ncurses linking problem is due to libdl not being able to handle linker scripts
14:55:33 <rwbarton> oh i see
14:56:08 <monochrom> there is some talk of changing that default, but I haven't followed on the decision
14:56:56 <geekosaur> yeh, whereas stuff that uses the X server typically has to run in the main thread, and *must* all run in the *same* thread, so a new thread for each command breaks them
14:57:33 <monochrom> -fno-ghci-sandbox will turn off forking threads for your ghci commands
14:57:58 <Catnaroek> @djinn (x -> Bool) -> (x -> y) -> (x -> y) -> x -> y
14:57:58 <lambdabot> f a b c d =
14:57:59 <lambdabot>     case a d of
14:57:59 <lambdabot>     False -> b d
14:57:59 <lambdabot>     True -> c d
14:58:05 <Catnaroek> Is there anything like this?
14:58:19 <Catnaroek> In some library?
14:58:22 <llano> Is it possible to use lambda with guards and pattern matching?
14:58:48 <geekosaur> no
14:58:55 <monochrom> yes but only one pattern and one guard
14:58:56 <Catnaroek> \x -> case f x of ...
14:58:58 <llano> case of
14:58:59 <llano> k
14:59:03 <geekosaur> well.  you can use ... that
14:59:17 <monochrom> > (\ (x:xs) -> x) "hillo"
14:59:18 <lambdabot>   'h'
14:59:20 <geekosaur> there can only be one pattern, although I think you can attach multiple guards to that pattern
14:59:24 <monochrom> > (\ (x:xs) | x=='h' -> x) "hillo"
14:59:25 <lambdabot>   <no location info>: parse error on input `|'
14:59:34 <monochrom> oh, no guard, oh well
15:00:29 <rwbarton> > (\(a,b) -> ()) undefined
15:00:30 <lambdabot>   *Exception: Prelude.undefined
15:00:54 <monochrom> my "one pattern" is ambiguous. (\ (x:xs) (just y) -> ...) is allowed
15:01:12 <monochrom> so, one pattern per parameter
15:01:59 <monochrom> I should help advertise http://www.hck.sk/users/peter/HaskellEx.htm  hyperlinked haskell grammar!
15:16:25 <spree> so i first have to takeMVar then putMVar ?
15:16:58 <shachaf> If you want to take an MVar and then put an MVar, yes.
15:17:29 <rwbarton> @google neil mitchell mvar
15:17:31 <lambdabot> http://neilmitchell.blogspot.com/2012/06/flavours-of-mvar_04.html
15:18:19 <quicksilver> ndm++ # I've been meaning to write that blog post for 5 years
15:18:22 <quicksilver> he actually did.
15:19:32 <projirc> well see now
15:19:49 <projirc> so it works now
15:24:11 <projirc> any germans here?
15:24:30 <geekosaur> probably all drunk and celebrating :p
15:25:02 <cinch> austrian here ;p
15:25:36 <armlesshobo> of german descent here
15:25:37 <spree> Ich bin in Österreich gearbeitet
15:26:04 <hpc> one neat trick ndm misses in that post is MVar as a rate limiter
15:26:13 <sipa> spree: s/bin/habe/ ?
15:26:25 <hpc> fork a thread that puts () into the MVar 60 times a second
15:26:38 <hpc> and wait on that mvar before every screen redraw
15:27:06 <hpc> if your draw time is too long, the put thread will start blocking
15:27:13 <parcs`> i think a SampleVar is better suited for that
15:27:20 <cinch> Ich bin in sterreich gearbeitet, bis sie mich rausgeschmissen habe
15:27:26 <bgamari> was just in germany last week here
15:29:14 <spree> shachaf: i use it as a global and i want to put anew value in it
15:30:22 <roconnor_> > 3 :: (Int,Int)
15:30:24 <lambdabot>   (3,3)
15:31:21 <cinch> what's a good linux distro for haskell, or is there not much difference?
15:31:41 <wingie> what are people using haskell for?
15:31:54 <hpc> if your distro has a package for ghc, it helps
15:32:00 <hpc> but not because you can install ghc from there
15:32:08 <wingie> doesnt seem to be a wide support for it in enterprise space
15:32:10 <MostAwesomeDude> cinch: Distros fall into two categories: Those with broken ghc and haskell-platform, and those with outdated ghc and haskell-platform. :3
15:32:12 <wingie> eg. Heroku, dotcloud etc
15:32:13 <hpc> because you can get the dependency list very easily
15:32:14 <cinch> to bootstrap :p
15:32:21 <monochrom> there are only a few exceptionally poor distro for haskell. centos and/or red hat enterprise, just because very old c libs etc
15:32:28 <MostAwesomeDude> In general, Gentoo and Arch are broken, everybody else does alright.
15:32:50 <pharaun> MostAwesomeDude: hows gentoo broken/
15:32:55 <pharaun> so far i haven't had issue
15:33:15 <MostAwesomeDude> pharaun: Installing a full, up-to-date haskell-platform is occasionally broken.
15:33:22 <monochrom> and oh, I assume you don't actually use the distro's ghc etc
15:33:27 <MostAwesomeDude> Which, TBF, is better than Arch, where it's *always* broken.
15:33:38 <pharaun> MostAwesomeDude: ahh i see, yeah i've ran into that
15:33:51 <pharaun> but on the other hand its pretty easy to fix, tweak ebuild or couple things and i'm done
15:34:11 <pharaun> i guess its a ymmv
15:34:24 <MostAwesomeDude> Well, not all of us can be Gentoo devs. :3
15:34:26 <monochrom> if you use the distro's ghc etc, very few distros are actually satisfactory at all
15:34:41 <hpc> if you insist on using distro everything, your best bet is debian testing
15:34:51 <hpc> or maybe debian unstable, if you live on the wild side
15:35:02 <Clint> unstable will be headachy
15:35:05 <monochrom> (two problems: distro's update cycle not sync with ghc's update cycle. some distros fragment packages wrongly)
15:35:35 <monochrom> but if you get your ghc from ghc's website and build your haskell platform, very few distros are poor
15:36:08 <hpc> it basically comes down to support for C libs, if you do it yourself :P
15:36:43 <pharaun> my problem with using out of package is
15:36:53 <pharaun> i then have to take care of it vs just saying "foo update"
15:37:03 <pharaun> and if i lag behind a bit that's usually fine
15:37:39 <roconnor_> > let { x ^. l = getConst $ l Const x; l ^= nv = \x -> runIdentity $ l (Identity . const nv) x; fst h (a,b) = (\x -> (x,b)) <$> (h a); snd h (a,b) = (\x -> (a,x)) <$> (h b)} in ((fst ^= "hi") . (snd ^= [])) ('a',3)
15:37:40 <monochrom> oh, another problem with distros' ghc: what if you want several ghc versions to co-exist? only nix can do that.
15:37:41 <lambdabot>   ("hi",[])
15:37:42 <spree> is youtube working well on linux now?
15:38:07 <cinch> spree, of you have flash sure
15:38:09 <Clint> always has been, as long as you don't use flash
15:38:18 <monochrom> (why you want several ghc versions to co-exist: you publish a library and you want to support that many ghc versions)
15:38:45 <pharaun> monochrom: ah i haven't needed to do that, but probably would just launch vms for that
15:39:00 <bitonic> monochrom: nix and just using the binaries :P
15:39:01 <lambdabot> bitonic: You have 1 new message. '/msg lambdabot @messages' to read it.
15:39:11 <monochrom> that works but is slower
15:39:11 <cinch> pharaun, vms?
15:39:17 <dmwit> VMs are amazing.
15:39:27 <Clint> chroots are plenty fast
15:39:29 <cinch> oh vm's
15:39:35 <dmwit> If you've never run a VM before, now is the perfect time to make yourself 10x more productive in the future.
15:40:10 <bitonic> monochrom: mah. in the end. in these things, what matters most is support. You might want the bleeding edge or versioning for 2 packages, but that's it
15:40:15 <monochrom> yes bitonic I just that that only nix can do that. if you want distro's ghc, that is. I don't use distro's ghc. disillusioned. now I can enjoy ubuntu's prettiness and still have multiple ghcs
15:40:45 <bitonic> monochrom: same for me.
15:41:03 <bitonic> apart from ubuntu "prettiness". I don't use a DE.
15:41:13 <monochrom> hehe
15:41:23 <monochrom> (yes I actually like the unity shell)
15:41:41 <bitonic> monochrom: it's not bad. it's better than plain GNOME, imo.
15:42:09 <pharaun> i use xmonad
15:42:14 <monochrom> (oh and I also like proportional fonts in irc. I learned that it makes some people scream, like I'm a heretic or something)
15:42:33 <pharaun> haha i don't mind it in irc usually, cos meh you know its plain text
15:42:39 <pharaun> its coding that tends to bother me
15:43:07 <Yarou> i haven't used a tiling wm in years
15:44:05 <monochrom> I am unconvinced of tiling windows on a merely 19" screen. 40" TV sure.
15:44:06 <adimit> use one now. Use xmonad.
15:44:25 * Clint uses xmonad on a 14"
15:44:36 <hpaste> HairyDude pasted “bad style?” at http://hpaste.org/70327
15:44:37 <Yarou> i might check out xmonad for sure, i've heard really good things about it
15:44:50 <monochrom> all examples of usable tiled windows on 19" screen I have seen are just xterms, xterms, and more xterms with like 5-point fonts.
15:44:50 <pharaun> monochrom: yeah on the laptop its not the best (full screen all the apps) but i have multiple huge screen desktops so i just find its nicer to just run xmonad on everything
15:44:52 <HairyDude> ^what do people think of that?
15:44:56 <spree> Parsec: how do i discard until i find what i want? like vnfdjnfvfjnPRIVMSG<text i want> ?
15:45:09 <bitonic> spree: `manyTill'
15:45:30 <pharaun> monochrom: 16pt font and usually terms but i also often have docs, or other stuff, its nice to have it pre-defined -> 80col
15:45:37 <adimit> monochrom: I've a 19" screen. Lot's of urxvts, for sure, but with an 11-point font. And also, who needs anything but terminals to code?
15:45:50 <spree> bitonic: then how do i get everything after that?
15:46:00 <monochrom> I don't just code. that's why.
15:46:27 <Clint> the only thing i don't use a terminal for is a web browser
15:46:52 <pharaun> monochrom: imho so far xmonad seems to work good with my workflow, gimp, various apps, etc
15:46:58 <pharaun> but yeah ymmv :)
15:47:02 <bitonic> spree: `manyTill eof'?
15:47:26 <Targen> What’s xmonad like on a netbook?  Worth trying?
15:47:26 <cinch> what does this cabal error mean? http://snipurl.com/241nooy
15:47:28 <bitonic> spree: `many any'
15:47:33 <bitonic> or something like that
15:47:50 <Clint> Targen: why not?
15:48:06 <Peaker> I don't like xmonad so much.. the config DSL is not very nice (you don't compose extensions, you have to tediously figure out how to use each)
15:48:09 <Targen> Just wondering; I haven’t had the time to try it.
15:48:17 <monochrom> you should try not to have variable names shadowed. I mean the computer is fine with that. but it trips humans.
15:48:52 <Peaker> and you can easily get it wrong, too.. and then it is really hard to prevent focus stealing...
15:49:02 <Ralith_> Targen: tiling wms in general are perfect for netbooks
15:49:30 <HairyDude> it's rather annoying that Hoogle doesn't index Yesod
15:49:48 <adimit> HairyDude: can't you just use +yesod?
15:49:52 <Targen> hm.
15:50:12 <Peaker> except for the devel tools themselves, I don't know of any end-user Haskell program that I like using :(   darcs and xmonad are the main candidates but I think neither is best in its space
15:50:30 <HairyDude> adimit: ah, that does work.
15:50:43 <Clint> not for me
15:50:51 <HairyDude> though you do have to remember precisely which yesod module the thing you want is in
15:50:52 <Clint> i have to give it the specific library
15:51:02 <adimit> with +package, hoogle will only search in that specific package.
15:51:28 <adimit> it's quite limited, admittedly. You could possibly make a list of all yesod-packages and always append that to your queries. Well, that's super-cumbersome.
15:51:42 <adimit> Hayoo tends to be nicer in that regard.
15:51:45 <Peaker> you could index yesod locally and use hoogle locally on your machine
15:53:26 <Peaker> Haskellers don't seem to write much end-user applications
15:53:33 <HairyDude> I think I tried that, but hoogle's dependencies took forever to build, cos they use a lot of memory
15:53:56 <monochrom> we don't have great GUI stories yet. that is an important factor
15:53:57 <otters> Peaker: I've written one
15:54:06 <HairyDude> Peaker: probably because there are no good GUI toolkits :)
15:54:07 <monochrom> oh but have you considered manatee? :)
15:54:27 <Peaker> monochrom, the chinese desktop thing ?:)
15:54:31 <spree> Peaker: I'm writing one, nothing facny though, just an irc client, then maybe a bittorrent client
15:54:36 <Peaker> otters, what is it?
15:54:59 <otters> well it's not really an end-user application, it's a proxy between IRC and another chat protocol
15:55:04 <spree> wxHaskell seems ok but you cant make "custom" GUIs or can u?
15:55:05 <avpx> It's unfortunate that the most robust GUI toolkits for Haskell are just wrappers around C functions in the I/O monad (in my experience)
15:55:07 <quicksilver> Peaker: pandoc is well-respected.
15:55:32 <monochrom> it's not chinese. it's written by a chinese. it has an editor (so you code haskell), a web browser (so you view haddock), an irc window (so you are in #haskell)...
15:55:33 <Peaker> spree, cool, I hate all existing ones... feature request: allow running a proxy daemon you can reconnect to which keeps the connection alive and lets you see what happened when you were gone
15:55:48 <cinch> avpx, of course, might aswell wrap a C library (almost all GUI libaries...)
15:55:51 <HairyDude> oh yeah. while using xmonad, I've noticed that after a while some of my gnome-terminals have an empty box for a cursor instead of a solid block, as if they didn't have focus, even when they do
15:56:05 <Peaker> avpx, I've written a (partial) GUI toolkit in Haskell which involves (almost) no IO
15:56:07 <HairyDude> didn't get this before, so it may be related to virtualbox
15:56:13 <Peaker> monochrom, heh
15:56:23 <geekosaur> I recall that as being a known bug in gnome-terminal
15:56:24 <irene-knapp> Does Michael Snoyman come here?  I wish to discuss a package I'm releasing with him, because of his expertise in web-Haskell matters.
15:56:33 <HairyDude> geekosaur: ah, good to know.
15:56:50 <Peaker> quicksilver, cool! The fact it's in Haskell isn't the main thing in its description :)
15:56:53 * hackagebot direct-http 0.5 - Native webserver that acts as a library.  http://hackage.haskell.org/package/direct-http-0.5 (IreneKnapp)
15:56:55 * hackagebot direct-http 0.5.0.1 - Native webserver that acts as a library.  http://hackage.haskell.org/package/direct-http-0.5.0.1 (IreneKnapp)
15:56:59 <geekosaur> it's actually difficult to get that right; some of the blinking cursor patches for xterm back in the day used to introduce a similar bug
15:56:59 <irene-knapp> yes, that, thank you hackagebot
15:57:21 <HairyDude> good timing :)
15:57:24 <irene-knapp> hehe
15:57:37 <Peaker> monochrom, did he implement the editor, browser, and client?
15:57:44 <monochrom> yes
15:57:53 <HairyDude> why does hackagebot use emotes for those messages?
15:58:02 <irene-knapp> I have no idea
15:58:04 <xpololz> does anyone have any newbie friendly examples of common computations (in the imperative paradigm) expressed by lambda calculus? If this makes sense at all... I'm getting so confused by the whole functional paradigm :-S
15:58:08 <Peaker> implementing a browser is a feat, did he implement just some bare minimum to view hackage?
15:58:32 <barrucadu> xpololz: Have you read LYAH?
15:58:35 <barrucadu> @where LYAH
15:58:36 <lambdabot> http://www.learnyouahaskell.com/
15:58:46 <Peaker> xpololz, the lambda calculus is like the assembler of FP. Not sure it's the easiest way to start learning
15:59:36 <ahkurtz> Peaker: have you ever used znc as an IRC proxy + replay buffer?
15:59:36 <HairyDude> lambda calculus is the assembler of FP and its semantics are specified in category theory
15:59:37 <xpololz> hmm, I wanna learn Haskell and the functional paradigm for sure, but I've ended up studying lambda calculus
15:59:50 <Ralith_> you should study LYAH instead.
15:59:51 <Peaker> ahkurtz, nope, what is that?
15:59:51 <xpololz> and I read the first 2-3 chapters of LYAH
15:59:53 <spree> how do i say to Parsec msg <- rest of the string?
16:00:07 <spree> like ive parsed what i wanted now put the rest in msg
16:00:27 <xpololz> but I really do want to learn lambda calculus, it's very interesting, though it really makes me sweat...
16:00:30 <hpc> many anyChar >> eof
16:00:31 <HairyDude> :t getString
16:00:32 <lambdabot> Not in scope: `getString'
16:00:45 <ahkurtz> it's an IRC daemon that you proxy through that stores a buffer of what you missed and on reconnect plays it back into your client with timestamps
16:00:46 <hpc> or something like that
16:00:57 <HairyDude> spree: I noticed a parser that does that...
16:00:59 * HairyDude looks
16:01:06 <quicksilver> Peaker: and of course http://www.kickstarter.com/projects/joeyh/git-annex-assistant-like-dropbox-but-with-your-own looks promising, but isn't done.
16:01:07 <ahkurtz> it's not graceful, and setting it up is kind of painful, but it definitely works and basically never crashes
16:01:14 <HairyDude> :t takeText
16:01:15 <lambdabot> Not in scope: `takeText'
16:01:22 <HairyDude> :t takeString
16:01:24 <lambdabot> Not in scope: `takeString'
16:01:57 <HairyDude> ah, this is attoparsec... vanilla parsec may be different
16:02:51 <xpololz> is it a bad idea learning lambda calculus first? I need to nest up in this stuff before I can move on, can't get it out of my head.
16:03:09 <Peaker> quicksilver, it's a bit weird. I'd expect Haskell to have more prominent desktop-side successes.  I wonder if it's because of the relatively recent availability of usable crucial libs, or just the real-world-using Haskell crowd is much smaller than it seems
16:03:15 <Yarou> xpololz: it depends on what you want
16:03:26 <adimit> xpololz: learning lambda-calc is pretty much an open-ended endeavour.
16:03:29 <ahkurtz> can someone point me to what makes category theory different than set theory? I am super noob at math and trying to make sense of it all, which it turns out IS necessary to get anything done in Haskell that I actually care about
16:03:56 <Peaker> xpololz, you could learn the basics of LC directly, it's very small, should take a few hours to a few days depending on prior background
16:04:03 <adimit> xpololz: it might suit you right to just learn the basics of lambda-calc, then move on. Explain alpha-conversion, beta-reduction, eta-reduction, and then some exercises.
16:04:07 <adimit> then go to LYAH.
16:04:13 <HairyDude> I suppose you could do "many (satisfy (const True))" but I suspect that would cause an infinite loop
16:04:18 <hpc> ahkurtz: very roughly speaking, set theory is the study of containers of things
16:04:25 <hpc> category theory is the study of functions that compute things
16:04:48 <xpololz> alright, thanks guys
16:04:51 <quicksilver> Peaker: perhaps it's because interesting smart programmers are statistically unlikely to write desktop apps?
16:04:55 <Peaker> quicksilver, If I had not used Haskell myself and tasted the awesomeness, the trollish conclusion would seem reasonable
16:05:04 <ozataman> anyone know if there's a way to implement the State monad without using CPS with the state?
16:05:22 <HairyDude> @src State
16:05:23 <lambdabot> Source not found. You untyped fool!
16:05:25 <HairyDude> @src StateT
16:05:25 <lambdabot> Source not found. My mind is going. I can feel it.
16:05:27 <HairyDude> hm
16:05:41 <HairyDude> of course @src is useless.
16:05:44 <ozataman> I tried, but got stuck right at the beginning when implementing the Monad instance for the type - how would you even write "return"
16:05:47 <Peaker> quicksilver, so Haskell attracts the "backend" / "tooling" guys?  Perhaps..
16:06:03 <tgeeky> HairyDude: those things are in 'transformers', not base, I think?
16:06:39 <ahkurtz> hpc: but a Category is analagous to a domain or codomain of a function? Which is just a container of things and a description of what's in the container?
16:06:40 <HairyDude> return x = State (\s -> (x,s))
16:06:51 <tgeeky> actually it's in mtl
16:06:58 <hpc> ahkurtz: i did say "roughly"
16:07:02 <quicksilver> Peaker: desktop apps tend to be written by teams, tend to come out of desktop environment projects, etc.
16:07:05 <Peaker> tgeeky, I don't think it is anymore
16:07:07 <HairyDude> where newtype State s a = State { runState :: s -> (a,s) }
16:07:10 <quicksilver> Peaker: also you *are* right about GUI library maturity.
16:07:11 <ozataman> HairyDude: right, I want to do it without the \s (CPS) part in there
16:07:39 <HairyDude> ozataman: I'm not sure CPS is the right term for that.
16:07:46 <Peaker> quicksilver, that Gtk/wx became actually usable relatively recently?
16:07:48 <HairyDude> ozataman: it's just a closure
16:07:56 <tgeeky> Peaker: it's in both. *shrug*
16:08:06 <Peaker> (and I'm not sure about wx)
16:08:07 <xpololz> adimit, what I wanted to look a bit closer on type systems and language theory as well while learning the functional paradigm, this is also one of the reasons why I ended up starting with LC
16:08:21 <quicksilver> Peaker: well, at least, they previously required a lot of tweaking and source diving and secret knowledge to use well.
16:08:28 <Peaker> tgeeky, I thought they consolidated them in transformers such that mtl re-exports and does the N^2 class explosion thing
16:08:30 <quicksilver> Peaker: (maybe that's what you mean by 'usable' in which case, yes)
16:08:40 <xpololz> Ignore the first "what" in that sentence
16:08:57 <HairyDude> xpololz: see if you can get hold of Henk Barendregt's book on lambda calculus
16:09:03 <ahkurtz> hpc: I read all LYAH, I'm several chapters into RWH, I'm reading the pierce book on types and programming, I have the okasaki book on FP data structures, and I still have not seen what Category theory is, and everyone just talks about sets
16:09:25 <Peaker> xpololz, there's untyped LC, simply-typed LC, System F ... it's easier after learning practically-motivated language side like Haskell
16:09:25 <ahkurtz> oh and also I can't reason about laziness at all still
16:09:40 <ahkurtz> maybe I'm just too stupid for this.
16:09:49 <tgeeky> Peaker: sure enough.
16:09:55 <hpc> ahkurtz: hardly; it takes a lot of time to work up to it
16:10:09 <hpc> many layers of abstraction, and some of them don't seem to have any motivation at first
16:10:13 <xpololz> Peaker okay
16:10:26 <ozataman> HairyDude: in any case, I'm not arguing pedantics - was just wondering if there's a way to implement State without the closure in there
16:10:28 <Peaker> ahkurtz, I think it takes some getting used to.. for me it helped to think about func args as thunks rather than values to grok laziness
16:10:49 <HairyDude> ozataman: closures are just the natural way to do it.
16:10:59 <ozataman> HairyDude: I don't dispute that :)
16:11:23 <Peaker> ozataman, instead of   s -> (s, a)      you want a representation without any (->) ?
16:11:23 <ozataman> HairyDude: Again, I'm just wondering if there's a way to do it without them
16:11:29 <HairyDude> xpololz: I think this is the one I had in mind http://www.cs.ru.nl/~henk/book.pdf
16:11:37 <ozataman> Peaker: Yep, exactly. It's just a thought experiment.
16:11:53 <ahkurtz> but there is a point you get to where it makes enough sense I can reasonably say to an employer or myself, "yes, I am likely to be able to write you that program"
16:12:04 <Peaker> ozataman, a stateful computation is inherently a function from old state to new state. If it wasn't (->) you'd have some other reification of a function in there
16:12:10 <xpololz> HairyDude, thanks, I'll have a look at that :)
16:12:17 <ahkurtz> it's not just this comprehension of turtles infinitely until I end up writing white papers right?
16:12:46 <Peaker> ahkurtz, how long have you been writing actual programs?
16:13:00 <HairyDude> xpololz: btw, the name of the guy in the second photo may sound familiar :)
16:13:14 <ozataman> Peaker: Yeah, that's what I thought. Thanks
16:13:40 <HairyDude> ah, no, that's not it. I was thinking of the one describing the lambda cube
16:13:51 <xpololz> HairyDude, yeah :) but I assume this book would be better to move on to later for me
16:14:35 <ahkurtz> Peaker: I've been writing small apps along with my learning material for maybe 7 months? I have not embarked on anything huge, mostly cause I'm super busy and always get baffled by things that are simple in OO or LISP within about 10 minutes
16:15:14 <ahkurtz> just like a few small programs a month probably
16:16:01 <Peaker> ahkurtz, what kind of things are simple in OO but are still baffling?
16:16:04 <ahkurtz> trying out STM, web servers, backtracking algos, junk like this
16:16:40 <Peaker> ahkurtz, I think after 7 months I was comfortable with writing code but also had trouble reasoning about lazy code space use/etc..
16:17:56 <ahkurtz> I was trying to make something that would calculate palindromes, and was totally stumped
16:18:23 <ahkurtz> I wanted to read the unix dictionary, virtual memory mapped basically, and then lazily consume random permutations
16:18:28 <HairyDude> A man, a plan. a canal, Panama!
16:19:00 <tgeeky> Teddy Roosevelt?
16:19:20 <HairyDude> dunno, it's just a famous palindrome to me :)
16:19:26 <spree> P.manyTill (P.string "PRIVMSG) //P = Parsec// doesnt work
16:20:15 <ahkurtz> I got stuck trying to get a list of indexes into the data at word boundaries, that I could randomly index into
16:20:40 <donri> spree: are you doing this for learning? there are irc parsers and frameworks on hackage
16:21:43 <ahkurtz> I try to read lots of peoples code and the community is huge on language extensions, which also really throw me
16:22:05 <ahkurtz> template haskell, n-rank types or whatehaveyou
16:22:08 <ahkurtz> so forth and so on
16:22:53 <donri> lines . readFile $ "/usr/share/dict/words"
16:23:15 <yert> I am trying to use IO inside an Error Monad (I am using fail to throw errors). I can print anything I want, but I cannot read (I get a handle error). What I should do to be able to read from stdin?
16:23:20 <HairyDude> the only thing I know of that uses rank-N types is the ST monad
16:23:57 <ahkurtz> yes, but then I am holding the whole dictionary in memory, and using the basic [Char] which is mad slow in my experience
16:24:01 <ahkurtz> I did try that naively
16:24:02 <HairyDude> yert: the handle for stdin is called stdin :)
16:24:04 <ahkurtz> I got that far
16:24:06 <HairyDude> :t stdin
16:24:07 <lambdabot> Not in scope: `stdin'
16:24:13 <HairyDude> ... I think
16:24:27 <HairyDude> :t System.IO.stdin
16:24:29 <lambdabot> GHC.IO.Handle.Types.Handle
16:24:39 <yert> HairyDude: Yes, but my problem is different. I think I need to use monad transformers, but I would like to go without them
16:24:53 <HairyDude> oh, I see
16:24:58 <donri> ahkurtz: it's 5mb...
16:25:03 <monochrom> http://hackage.haskell.org/package/bytestring-mmap takes care of the memory-mapped part. you can use Bytestring's "lines" to divide into words.
16:25:10 <ahkurtz> the unix dictionary is not my actual target
16:25:13 <yert> I am trying to use fail and IO
16:25:16 <ahkurtz> it's just boostrapping for the rest of the program
16:25:26 <yert> But I don't know why printing works, while reading does not
16:25:43 <monochrom> throw in Data.Map or Data.Set or something similar for searching
16:26:08 <ahkurtz> I want to be able to use an external database of character strings, maybe not even english words, that may eventually contain several gigs of data etc
16:26:54 <quicksilver> ByteString is not a bad abstraction of indices into a buffer
16:26:59 <quicksilver> that is how bytestring is implemented.
16:27:40 <donri> yert: how do you print?
16:27:45 <ahkurtz> yeah, I was trying to use Bytestring, that was the part where I ended up stuck
16:27:51 <yert> donri: putStrLn
16:27:56 <monochrom> hmm, that works too, but you will write your own word-breaking routine that notes indices, which is just 5 minutes
16:28:09 <donri> yert: in a monad other than IO? that's a type error
16:28:09 <yert> But I can read at the begining, at least it seems so ...
16:28:26 <donri> show code
16:28:46 <monochrom> and 5 minutes because I'm the slowest programmer around. other people here needs only 1 minute
16:29:19 <yert> I have IO monad, but I use Error for errors
16:30:10 <donri> yert: but i doubt you're printing from the error monad
16:30:24 <yert> http://hpaste.org/70329
16:30:40 <monochrom> actually, Bytestring's lines may be what you want afterall. internally it's indicing into the mmap region again
16:31:04 <donri> yert: that code has no putStrLn
16:31:17 <yert> Oh you wanted putStrLn, I am sorry
16:31:20 <koal> hello
16:31:28 <koal> I have a mess with variables.
16:31:34 <koal> desperately need to use variables
16:31:45 <koal> need to be keeping something of the type [Bool]
16:31:46 <monochrom> once again, a lot of getting stuck is just due to misinformed worry about efficiency. emphasis on misinformed. informed worry about efficiency is fine.
16:31:54 <koal> I need a function to "add" you pass a bool and ADD to the list
16:31:54 <yert> http://hpaste.org/70330
16:32:00 <koal> example add true
16:32:04 <koal> and also some kind
16:32:09 <koal> getBoolList ..... return (foldr (| |) False (value list))
16:32:16 <koal> help please
16:32:32 <donri> yert: that code uses no error monad
16:32:54 <yert> But it's the same function
16:33:05 <yert> Like I have a big case of
16:33:11 <ahkurtz> monochrom: yeah, I saw documentation that claimed that, that's how I ended up there. I'm really sorry I don't have that code on this machine. I'll dig it up some other time and bother people again :)
16:33:24 <yert> I totally can be wrong, I am very new to Haskell
16:33:37 <koal> help please
16:34:41 <donri> yert: well, you can use monad transformers and liftIO to use IO from arbitrary monads... although it's difficult to tell if that's the best way to do what you're trying
16:34:45 <ahkurtz> monochrom: as to efficiency, the program I wrote took all my CPU, like 300mb of ram, and never produced any results :) which obviously could just be a mistake I made somewhere
16:35:07 <koal> :(
16:35:33 <monochrom> koal, I think no one understands the question. at least I don't understand and I don't want to.
16:36:44 <yert> donri: I am reading about it, I just don't know if the change would be easy enough, I really don't want to refactor all the code
16:37:22 <monochrom> why I don't want to: because beyond a certain threshold, certain poorly expressed questions aren't worth saving
16:38:13 <quicksilver> koal: (:) is the function to add an element to a list, perhaps.
16:38:24 <quicksilver> > True : [True,False,False]
16:38:26 <lambdabot>   [True,True,False,False]
16:39:00 <ahkurtz> monochrom: I'm not just interested in Haskell for learning, though I am very interested in the topics it involves in and of themselves. there are many FP langs with variations on what's in Haskell I find interesting, but specifically I am hoping that I will someday be able to write Haskell code that compares favorably to code I might write in C, so focusing on efficiency and my ability to be confident that I can achieve efficiency before embarking on a large p
16:42:33 <ahkurtz> it's a hard life, I know :)
16:42:46 <MostAwesomeDude> The answer is "yes."
16:42:55 <MostAwesomeDude> lambdabot: Can Haskell be fast?
16:43:04 <MostAwesomeDude> Oh, maybe that's disabled.
16:43:12 <monochrom> you can try the @faq command
16:43:12 <donri> @faq speed?
16:43:12 <lambdabot> The answer is: Yes! Haskell can do that.
16:43:33 <MostAwesomeDude> @faq Can Haskell be faster than C?
16:43:33 <lambdabot> The answer is: Yes! Haskell can do that.
16:43:41 <monochrom> @quote monochrom faster
16:43:41 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
16:43:51 <ahkurtz> no no, not can it be fast, can I, as an individual with a finite intelligence and aptitude, and only so much formal training, write fast Haskell code. I absolutely believe and have seen amazing programs others have written
16:44:09 <koal> ok, but that's not what I need. I need to have memory
16:44:20 <koal> [((i,j), otherfunction (getList(add )) (f!(i,j)) )| i <- [1..9], j <- [1..9]]
16:44:33 <MostAwesomeDude> ahkurtz: Ah. Well, yes. You just have to learn how to profile; Haskell profiles differently from C.
16:44:48 <MostAwesomeDude> But the general workflow for profiling's the same: Find a hotspot, fix it.
16:44:54 <quicksilver> koal: are you trying to change the value of a variable?
16:45:15 <S11001001> I thought it was guess which bits are slow and rewrite in C
16:45:22 <koal> yes!
16:45:26 <monochrom> I don't know how much effort you have to spend to get your code fast enough. but I know the least-effort path, though it may still be too much effort. use the scientific method, not the opinionative method.
16:45:44 <S11001001> /asm
16:45:47 <ahkurtz> monochrom: fair enough. thanks for listening to me.
16:45:52 <quicksilver> koal: you can't.
16:45:56 <quicksilver> koal: haskell variables are immutable.
16:46:00 <MostAwesomeDude> S11001001: Rewriting in C should be a last resort for certain languages, and Haskell is among those languages.
16:46:05 <monochrom> empirical evidence: so far, all success stories of fast haskell code use the scientific method only
16:46:10 <quicksilver> koal: you need to step back and think about what you really want to do.
16:46:24 <koal> I know, why should aid
16:46:56 <quicksilver> koal: are you using an automatic translation program?
16:49:35 <S11001001> guess which bits are slow and rewrite imperatively
16:49:47 <koal> yes!
16:49:50 <koal> and I do not understand haskell and I hate and I'm in a terrible mess
16:49:58 <spree> P.parse ircMsgParser txt txt // why have i put the same arg twice as argument?
16:50:25 <glguy> spree: Parsec wants a "source name" and the contents
16:50:33 <glguy> you don't have to use the contents as the source name
16:50:39 <quicksilver> koal: OK, well I'm making an attempt to help but you have not realised that haskell variables cannot just be changed, then you really need to read some haskell basics.
16:51:04 <MostAwesomeDude> S11001001: Why guess when you could be profiling? :3
16:52:03 <S11001001> no thanks, I am way better at modelling performance than some machine
16:53:51 <koal> I know, but I did something in a way ... with a much code and I have to change now, and the only maera easy is to use a variable (memory) that is [Bool]
16:55:39 <quicksilver> koal: well, that's not going to be the way to solve it.
16:55:52 <quicksilver> perhaps a function which takes a [Bool] and returns a different one
16:55:59 <quicksilver> possibly recursively
16:56:19 <MostAwesomeDude> S11001001: IYSS.
16:56:20 <quicksilver> replacing mutation with a parameter which you then return a "modified version of" is a common idiom.
16:57:12 <S11001001> :t All
16:57:13 <lambdabot> Bool -> All
16:57:49 <S11001001> > foldMap All [True, False, True]
16:57:51 <lambdabot>   Not in scope: `foldMap'
16:57:59 <S11001001> wee
16:58:29 <quicksilver> > F.foldMap
16:58:30 <lambdabot>   Not in scope: `F.foldMap'
16:58:37 <quicksilver> > Data.Foldable.foldMap
16:58:39 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> m) -> t a -> m)
16:58:39 <lambdabot>    arising f...
16:58:48 <quicksilver> > Data.Foldable.foldMap All [True, False, True]
16:58:50 <lambdabot>   All {getAll = False}
17:00:56 <koal> we returned ...
17:01:05 <koal> to see ...
17:01:13 <koal> as solucionarias this
17:01:18 <koal> *a function f which gives a result
17:01:24 <koal> * From a result of f do not want to apply more f
17:01:30 <koal> *and there are things like [((i,j), (f!(i,j)) )| i <- [1..9], j <- [1..9]]
17:02:01 <koal> **and there are things like [((i,j), f(m!(i,j)) )| i <- [1..9], j <- [1..9]]
17:02:27 <Eduard_Munteanu> Google translate?
17:04:18 <koal> yes I'm a creep
17:04:19 <koal> aaaaa
17:05:08 <donri> maybe if you explain in spanish someone who speaks it will understand
17:05:34 <MostAwesomeDude> No hay #haskell-es ? :c
17:05:52 <koal> no
17:05:57 <koal> va...yes
17:06:05 <MostAwesomeDude> That's too bad. :c
17:08:05 <irene-knapp> Is there any way to get haddock to tell you WHICH symbol doesn't have documentation?  I have 98% coverage (55/56 symbols) and it's driving me nuts. :)
17:08:28 <donri> irene-knapp: perhaps the module itself
17:08:31 <irene-knapp> hmm
17:08:47 <irene-knapp> right, I think that may be it.  uhhhhh where does that one go in the source? :)
17:08:53 <copumpkin> > ala All Data.Foldable.foldMap [True, False, True]
17:08:55 <lambdabot>   False
17:08:58 <donri> -- | foo\nmodule Bla where
17:09:20 <copumpkin> :t ala All Data.Foldable.foldMap
17:09:22 <lambdabot> forall (t :: * -> *). (Data.Foldable.Foldable t) => t Bool -> Bool
17:09:57 <irene-knapp> ah, thanks
17:10:00 <S11001001> copumpkin: you and your flipping dollars
17:11:07 <koal> I went to commit suicide
17:11:28 <glguy> copumpkin: What's this ala/Newtype business?
17:11:36 <MostAwesomeDude> @src ala
17:11:36 <lambdabot> Source not found. You type like i drive.
17:11:39 <MostAwesomeDude> @ty ala
17:11:41 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
17:11:44 <irene-knapp> donri: that was it!  excellent, thanks
17:11:52 <copumpkin> glguy: from conor's "adverbial programming"
17:12:05 <copumpkin> glguy: it basically takes care of wrapping and unwrapping newtypes automatically
17:12:13 <copumpkin> so you can just use their constructors as "tags" telling you what instance to use
17:12:32 <bitonic> :t ala
17:12:34 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
17:12:37 <S11001001> Freaky
17:12:48 <copumpkin> it's clearer as a type family
17:12:53 <HairyDude> :t ala
17:12:54 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
17:13:13 <HairyDude> I'd do @src Newtype but...
17:13:19 <bitonic> :k Newtype
17:13:20 <lambdabot>     Class `Newtype' used as a type
17:13:21 <lambdabot>     In the type `Newtype'
17:13:25 <bitonic> oh
17:13:27 <copumpkin> it just has functions to wrap and unwrap a newtype
17:13:30 <bitonic> @info Newtype
17:13:31 <lambdabot> Newtype
17:13:35 <bitonic> @src Newtype
17:13:36 <lambdabot> Source not found. Take a stress pill and think things over.
17:13:37 <copumpkin> of course, you can't make instances for higher-rank newtypes and such
17:13:41 <HairyDude> newtype is newtype
17:13:47 <HairyDude> lambdabot: +1, Informative
17:14:36 <HairyDude> anyway, bedtime
17:15:22 <spree> @hoogle (+)
17:15:23 <lambdabot> Prelude (+) :: Num a => a -> a -> a
17:15:23 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
17:15:23 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
17:15:38 <spree> ök goodnight
17:17:27 <Targen> Is there a way to ask the RTS for the ThreadIds of all active threads, or somesuch?
17:18:18 <spree> so how can you write comments in haskell to export them do docs? do anyone use @param and @return like with javadocs or the type declaration and a comment is enough?
17:18:50 <irene-knapp> spree: look into haddock
17:20:59 <spree> how do i remove all the pings from the channel (depends on client i guess no msg i can send?)? and joins etc, i just want msgs
17:25:57 <xpololz> why is this channel so crowded compared to other programming language channels around Freenode?
17:26:22 <MostAwesomeDude> xpololz: It's not; ever been to #python?
17:26:24 <irene-knapp> this is where the party is
17:26:34 <xpololz> never been to #python nope :)
17:27:51 <llano> @hoogle (.:)
17:27:51 <lambdabot> No results found
17:27:56 <llano> @hoogle (.:.)
17:27:57 <lambdabot> No results found
17:28:00 <llano> hmmm
17:30:09 <llano> @hoogle (.|.)
17:30:10 <lambdabot> Data.Bits (.|.) :: Bits a => a -> a -> a
17:30:57 <hpc> spree: depends on the client; look for "conference mode" or similar
17:31:02 <MostAwesomeDude> Q: I have a thing I'm doing next week where I'm showing off a thing in a Twisted Python shell. This is a live Python shell that is doing stuff in the background, treating stdio like a network client and not blocking for anything.
17:31:25 <MostAwesomeDude> If I were to do things in Haskell, what would my options be? Does ghci allow concurrent operations to happen in the "background?"
17:32:03 <hpc> :t forkIO -- meet your new best friend
17:32:03 <lambdabot> Not in scope: `forkIO'
17:32:09 <llano> Are you the MostAwesomeDude who programmed Bravo?
17:32:26 <MostAwesomeDude> llano: Yes.
17:32:44 <MostAwesomeDude> hpc: I'm acquainted already. Does this actually work in an interactive shell?
17:33:21 <llano> Nice, you switching over to haskell now? :)
17:33:22 <hpc> MostAwesomeDude: yes; in fact, ghci even uses the threaded runtime
17:33:36 <hpc> (which unrelatedly can cause trouble when you try and test gtk code, for instance)
17:33:52 <hpc> you can give RTS options to it
17:35:09 <hpc> MostAwesomeDude: if you want to do something particularly gamorous, how about something like
17:35:23 <hpc> type Progress a = MVar (Either Double a)
17:35:47 <hpc> background :: IO a -> IO (Progress a)
17:35:59 <hpc> progress :: Progress a -> IO Double
17:36:30 <hpc> result :: Progress a -> IO a
17:36:47 <hpc> now you can have a haskell computation run in the background
17:36:56 <hpc> you can block on the result
17:37:02 <hpc> and you can see how far along you are
17:37:50 <hpc> definitions are an exercise for the reader
17:54:13 <spree> So if I want to parse a string and it can become different things like JOIN , PRIVMSG, QUIT etc. id like to parse then if something happens, branch, can i do that?
17:54:30 <spree> or do i have to parse the same thing for each?
17:55:01 <aristid> spree: i'm not sure what you mean, but the answer is probably yes
17:57:53 <sipa> it's probably even the advised way of doing it
17:58:47 <llano> @hoogle <$>
17:58:48 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
17:58:48 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
17:59:18 <llano> @hoogle fmap
17:59:19 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
17:59:19 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
17:59:19 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
17:59:44 <llano> @hoogle <*>
17:59:44 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
18:06:58 * hackagebot union-find 0.2 - Efficient union and equivalence testing of sets.  http://hackage.haskell.org/package/union-find-0.2 (ThomasSchilling)
18:16:59 * hackagebot cmdtheline 0.1.0.1 - Declaritive command-line option parsing and documentation library.  http://hackage.haskell.org/package/cmdtheline-0.1.0.1 (EliFrey)
18:22:13 <spree> glguy: contents and sourcename?
18:23:11 <spree> if you know a string can be parsed in 3ways why not parse it once and do some tree-thing instead of parse once for each possible fit?
18:34:21 <lordvishal> Hey folks, I have a beginner question: http://learnyouahaskell.com/starting-out <-- I'm following this and wrote the following line> cubeMe x = x*x*x   ... and got an error: parse error on input '='
18:34:42 <bitonic> lordvishal: in the ghci REPL you need a `let'
18:34:51 <bitonic> e.g. `let cubeMe x = x * x * x'
18:35:00 <lordvishal> ah, thanks bitonic =)
18:35:36 <bitonic> yw
18:36:08 <lordvishal> bitonic++
18:37:49 <MostAwesomeDude> hpc: Hm. Okay, so if I were to, say, bind some C stuff, I could have it run in the background with ghci?
18:43:56 <SegFaultAX> Is there an existing function like headtail :: [a] -> (a, [a])? Eg, that returns the had and tail of a list as a pair.
18:44:09 <otters> let (x:xs) = list
18:44:20 <SegFaultAX> otters: Right, other than that, though.
18:44:27 <otters> let (x:xs) = list in (x, xs)
18:44:31 <SegFaultAX> Basically I'm wondering what the inverse of cons is.
18:44:40 <SegFaultAX> Other than just using pattern matching.
18:44:59 <otters> lambdabot says liftM2 (,) head tail
18:45:32 <otters> There's no library function, but it should be easy to define
18:55:03 <shachaf> SegFaultAX: You actually want [a] -> Maybe (a,[a])
18:55:12 <MostAwesomeDude> SegFaultAX: Besides pattern matching, not really.
18:55:15 <MostAwesomeDude> Also what shachaf said.
18:55:18 <shachaf> Which is the dual of cons :: Maybe (a,[a]) -> [a]
18:55:33 <shachaf> Well, not quite "cons" -- but the full list constructor.
18:55:39 <MostAwesomeDude> Is there a snoc :: [a] -> Maybe (a, [a]) -- ?
18:55:48 <SegFaultAX> Oh, right. In case the list is empty.
18:55:50 <shachaf> @ty unfoldr
18:55:51 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
18:55:57 <MostAwesomeDude> @hoogle [a] -> Maybe (a, [a])
18:55:58 <lambdabot> Language.Haskell.TH.Ppr split :: Type -> (Type, [Type])
18:55:58 <lambdabot> Data.Generics.Twins gmapAccumQ :: Data d => (forall e. Data e => a -> e -> (a, q)) -> a -> d -> (a, [q])
18:55:58 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
18:56:05 <shachaf> MostAwesomeDude: No.
18:56:17 <MostAwesomeDude> Oh well. Easy enough to write.
18:56:50 <shachaf> "cons" is actually a good name for it, given the data type.
18:56:54 <shachaf> Just unusual.
18:57:11 <applicative> @type Data.ByteString.Char8.uncons
18:57:12 <lambdabot> BSC.ByteString -> Maybe (Char, BSC.ByteString)
18:57:41 <SegFaultAX> I was thinking uncons or decons sounded alright.
18:58:03 <shachaf> Anyway there's "foldr".
18:58:13 <shachaf> Which is a more principled version of that function, kind of.
19:02:35 <tgeeky> shachaf: yep, he just wants uncurried foldr
19:02:50 <shachaf> tgeeky: No, he wants a "one-level" foldr.
19:03:04 <shachaf> That would be a nice function to have but it's not in the standard library.
19:03:06 <SegFaultAX> Actually, he doesn't.
19:03:18 <tgeeky> what does he want?
19:03:41 <SegFaultAX> He wants to implement this concept in another language that lacks pattern matching, and just wanted to know if that pattern was already named.
19:03:47 <dmwit> :t head &&& tail
19:03:48 <lambdabot> forall c. [c] -> (c, [c])
19:03:56 <shachaf> dmwit: :-(
19:04:03 <shachaf> Please don't encourage partiality in new functions.
19:04:06 <SegFaultAX> dmwit: That's exactly what I started with :D
19:04:08 <dmwit> :t splitAt
19:04:09 <lambdabot> forall a. Int -> [a] -> ([a], [a])
19:04:13 <dmwit> eh
19:04:16 <dmwit> :t splitAt 1
19:04:17 <lambdabot> forall a. [a] -> ([a], [a])
19:04:43 <dmwit> uncons is a good name, if you must write this function.
19:04:46 <SegFaultAX> dmwit: But I want the pair [a] -> (a, [a]), just wondering if that's named.
19:04:49 <dmwit> It has precedent in other list-like libraries.
19:04:58 <shachaf> SegFaultAX: No, you want [a] -> Maybe (a, [a])
19:05:08 <dmwit> No, you want [a] -> ([a], [a])
19:05:10 <SegFaultAX> dmwit: I must write. The target language doesn't have cons cells.
19:05:11 <tgeeky> hehe
19:05:14 <shachaf> dmwit: You do?
19:05:18 <tgeeky> foldlr :: ((b,a) -> b) -> ( b , [a]) -> b
19:05:18 <tgeeky> foldlr (||>) ( e   ,  []              ) = e
19:05:18 <tgeeky> foldlr (||>) ( e   , unsnoc -> (xs,x) ) = (||>) ( foldlr (||>) (e,xs)  ,  x  )
19:05:18 <dmwit> I do.
19:05:26 <tgeeky> that's the unsnoc version, for someone who asked
19:05:38 <shachaf> tgeeky: foldr's type should be dual to unfoldr's type, if anything.
19:05:40 <shachaf> @ty unfoldr
19:05:41 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
19:05:48 <shachaf> foldr :: (Maybe (a,b) -> b) -> [a] -> b
19:06:20 <SegFaultAX> shachaf: Again, you're right in correcting me, I do want Maybe (a, [a]) but my target language doesn't have that concept. I'll have to account for it some other way.
19:06:23 <tgeeky> shachaf: I think there are four possibilities: foldr (on lists), foldl (on snoclists), unfoldr (on ... ?), unfoldl (on ... ?)
19:06:45 <tgeeky> SegFaultAX: does the target language have the concept of non-empty lists?
19:06:49 <shachaf> SegFaultAX: Accounting for it by passing a default value is at least principled.
19:06:59 <SegFaultAX> tgeeky: Yes.
19:07:06 <tgeeky> SegFaultAX: then you don't need the maybe
19:07:07 <shachaf> tgeeky: foldr and unfoldr are much more fundamental than foldl and unfoldl.
19:07:19 <tgeeky> shachaf: I don't like to use the word fundamental.
19:07:24 <SegFaultAX> tgeeky: I already know how I'll represent it. :)
19:07:27 <tgeeky> but sure, I suppose that's correct.
19:07:31 <SegFaultAX> shachaf: Agreed.
19:07:57 <shachaf> Why are you agreeing with me?
19:08:08 <tgeeky> shachaf: but I'm saying, on DLists, isn't "foldl" the natural concept and "foldr" the unnatural one?
19:08:13 <SegFaultAX> shachaf: In my case, the Nothing data constructor will actually just be nil.
19:08:20 <tgeeky> shachaf: where the original distinction is the confusingly-named leftwards and rightwards functions?
19:08:27 <shachaf> tgeeky: Not really?
19:08:49 <shachaf> SegFaultAX: That's actually not good because you can't distinguish Nothing from Just Nothing.
19:09:32 <SegFaultAX> shachaf: Hmm, then some other sentinel value. I was agreeing that passing a default was a good idea.
19:09:46 <tgeeky> shachaf:
19:09:47 <tgeeky> unfoldl :: (b -> (b,a)) -> (b -> Bool) -> b -> [a]
19:09:47 <tgeeky> unfoldl (<||)    p v
19:09:47 <tgeeky>                | p v                    = []
19:09:47 <tgeeky>                | (v', x) <- (<||) v     = unfoldl (<||) p v' ++ [x]
19:09:59 <SegFaultAX> Actually, no. Just Nothing isn't an option. This won't deal with sparse lists.
19:10:06 <tgeeky> (that's from http://www.iis.sinica.edu.tw/~scm/pub/icfp055fp-mu.pdf)
19:10:28 <shachaf> What are sparse lists?
19:10:58 <tgeeky> A sparse array is an array with lots of 0's...
19:11:04 <tgeeky> a sparse list is one with lots of nils?
19:11:07 <SegFaultAX> Or in this case, a lot of nils.
19:12:07 <tgeeky> shachaf: actually, I'm a bit confused about all of this myself. I once sat down and wrote out a shorthand for the types of all of the definitions of fold/unfold that I could see, and I'm not confident in those from that paper
19:12:17 <SegFaultAX> Let me be concrete. I'm porting some Haskell features to Lua. In that language, there are very specific implications of having a list with nils interspersed with non-nil values.
19:12:45 <SegFaultAX> (In a list, specifically)
19:12:57 <tgeeky> is Lua used by... the HL2 engine?
19:13:15 <SegFaultAX> tgeeky: Perhaps, did they use Lua? If they did, TIL.
19:14:13 <tgeeky> SegFaultAX: evidently it's not native, but that is the choice of open source modders
19:14:31 <SegFaultAX> tgeeky: Oh, awesome!
19:15:09 <SegFaultAX> Anyway, a list such as { 1, 2, nil, 4, nil, 6 } has very particular implications for iteration.
19:15:25 <tgeeky> dmwit: the guy who wrote union-find just re-wrote it... in case this interests you: https://github.com/nominolo/union-find
19:15:42 <Ralith_> Source has open-source mods?
19:15:44 <Ralith_> is that legal?
19:15:51 <tgeeky> yes, and encouraged
19:16:02 <Ralith_> under what license?
19:16:24 <tgeeky> under the Valve-won't-do-anything-about-it license
19:16:33 <tgeeky> oh, I see what you're saying
19:16:35 <SegFaultAX> tgeeky: :D
19:16:56 <tgeeky> Ralith_: yeah, they aren't OSS in that sense.
19:17:05 <Ralith_> thought so.
19:17:14 <tgeeky> Ralith_: Garry's Mod, etc, and all kinds of CSS mods
19:17:16 <tgeeky> TF2 mods
19:17:25 <tgeeky> they don't have access to the source engine, just the API thereof
19:17:58 <Ralith_> I'm aware
19:18:02 <SegFaultAX> tgeeky: But modes for those aren't open source, are they?
19:18:05 <Ralith_> have worked in that domain in the past
19:18:07 <SegFaultAX> Gmod isn't.
19:18:15 <SegFaultAX> Mods*
19:18:37 <tgeeky> dunno. As far as I can tell, GM has actually reverted and has become in perpetual closed beta
19:19:09 <dmwit> tgeeky: Hm. When will github get integrated haddocks? =)
20:11:49 <edwardk> can someone running ghc head cabal update and check to see if mtl 2.1.2 builds cleanly?
20:12:05 * hackagebot mtl 2.1.2 - Monad classes, using functional dependencies  http://hackage.haskell.org/package/mtl-2.1.2 (EdwardKmett)
20:22:57 <parcs`> edwardk: worked here
20:23:03 <edwardk> thanks
20:23:14 <edwardk> apparently catch vanished out of Prelude?
20:23:39 <parcs`> it did?
20:24:01 <parcs`> oh, it's deprecated
20:32:32 <parcs`> it was removed on 6/19, my ghc head is from 6/14 :(
21:12:45 <theadmin> How are priorities defined? That is, how does GHC (for example) know that (*) comes before (+)?
21:13:42 <rwbarton> via the infixl/infixr/infix declarations
21:13:53 <rwbarton> which specify precedence and associativity
21:15:40 <theadmin> Ah, found it, thanks.
21:23:33 <Mortchek> Does Haskell have an operator like $ but with its operands reversed?
21:24:10 <BMeph> Mortchek: It will if you make one... ;)
21:24:18 <Mortchek> Yeah, was considering. :)
21:29:09 <theadmin> Mortchek: (<$) = flip ($) -- all done
21:29:43 <theadmin> Mortchek: But most of the time you can get around with using (.), no?
21:30:43 <Mortchek> theadmin, sure, I was just interested in playing with it because it is a slightly different way of thinking about sequencing a computation.
21:34:22 <jaredc> where is the instance for 2-ples as functors? i don't really know how to find it. hoogle data.functor says functor ((,) a) but ghc says no instance
21:34:39 <tgeeky> edwardk: can you please move the examples in Bound to Bound.Examples, and export them?
21:36:02 <edwardk> tgeeky: i'd rather not
21:36:10 <edwardk> tgeeky: if i export them then i need all their extensions
21:36:30 <edwardk> and the package without them is haskell 98/2010
21:36:47 <tgeeky> will your users really want to use the package, but not the extensions?
21:36:51 <edwardk> yes
21:37:14 <edwardk> in particular "Overkill" requires every extension known to man
21:37:15 <edwardk> ;)
21:37:29 <edwardk> so it only builds cleanly on 7.4.1 or later
21:37:39 <edwardk> while the others work pretty far back in GHC history
21:37:41 <tgeeky> in this case, then I would argue for a "examples" header in cabal files, in which you can require those extensions but not for the main library
21:37:45 <tgeeky> which I want anyway
21:37:58 <tgeeky> like tests, but... examples
21:38:20 <edwardk> i've been having a blast for the last week or so rewriting our compiler to use the approach from Bound. its night and day better
21:38:52 <tgeeky> is it? good.
21:39:11 <tgeeky> i'm still waiting to hear from brent :o
21:39:15 <edwardk> now i just need to work on getting us to open source it ;)
21:39:42 <tgeeky> what is the "source language" if that's right? some typed lambda calculus?
21:40:24 <edwardk> basically haskell extended with row types, primitive database support, some syntactic differences and polymorphic kinds that runs on the jvm
21:41:14 <tgeeky> are you one of the people who said that they disliked the SQL-like Haskell extension? I forget
21:41:26 <edwardk> SQL-like haskell extension?
21:41:33 <edwardk> the ones in comprehensions?
21:41:40 <tgeeky> yeah
21:41:47 <edwardk> i think its kind of poorly thought out and ad hoc compared to the rest of the language
21:41:55 <edwardk> but i've used it here and there
21:42:27 <edwardk> not sure its ever paid its way in terms of complexity in my code though
21:42:58 <tgeeky> okay. just curious.
21:43:27 <tgeeky> I recentely made a template .ghci file which has all of the GHC extensions, a description of what they do, an example (if useful to have)
21:43:38 <tgeeky> I have that extension off by default :o
21:43:43 <edwardk> heh
21:45:39 <tgeeky> edwardk: you never got doctest working (though I had no trouble!) but I was wondering if you think this is a swell idea:  for some of the rookies at HacPhi, get a bunch of people together and find code in the Haskell Report and in the docs which come with GHC -- and make sure that all of the docs do what they say (by convering them to doctests)
21:45:49 <tgeeky> I'm sure this could be automated somewhat, so maybe that approach would be best
21:46:10 <edwardk> not my cup of tea, but i'm sure you'll get someone to go for it
21:46:22 <tgeeky> yeah, you don't fall under rookie :)
21:46:30 <edwardk> i still need to book the flight. its a lot more expensive this year for some reason
21:46:42 <tgeeky> because they can, man, because they can
21:47:30 <tgeeky> edwardk: it would be nice if this resulted in the aforementioned docs having code boxes with syntax highlighting and a little check mark on them
21:47:49 <tgeeky> i'm sure SimonM would go along with it
21:52:37 <blackdog> tgeeky: kind of wondering what to hack on this year at AusHac
21:52:59 <tgeeky> blackdog: docs always need work, always
21:53:00 <blackdog> could take the safe approach and just wrap whatever library takes my fancy on the day, i suppose...
21:53:04 <tgeeky> hehe
21:53:17 <edwardk> blackdog: thats pretty much what i do at hackathons
21:53:19 <blackdog> i do like the idea of doctests
21:53:25 <edwardk> that and talk to folks about how to solve their problems
21:53:36 <edwardk> i rarely walk out with much progress on my own issues
21:53:49 <blackdog> you're probably always going to need more extensive tests that aren't terribly illuminating
21:53:54 <blackdog> yeah, me too
21:54:09 <blackdog> i go to railscamps pretty often, but i just end up talknig to people about haskell
21:56:15 <blackdog> it's a good thing rails hackers are so tolerant :)
21:57:10 <shachaf> blackdog: Don't worry, you're just a type error. They'll never catch you.
21:57:18 <mm_freak> a --reconfigure flag would be very useful for 'cabal build', such that it automatically reconfigures whenever necessary
21:57:20 <tgeeky> hahaha
21:57:28 <tgeeky> shachaf: they will, but only if he floats
22:04:49 <tgeeky> i'm confused. I'm writing list homomorphism examples, and I get: (min,max,any,all,concat,sum,product)
22:05:02 <tgeeky> but the original Gibbons paper says that head is a list homomoprhism?
22:09:42 <edwardk> tgeeky: safe head e.g. => Maybe a?
22:14:57 <enko> webdevs what are your opinions on snap?
22:20:01 <AfC> enko: um, it works?
22:20:47 <enko> what did you build with it AfC?
22:24:24 <palmfrond> hello, does haskell have a concept of null value?
22:24:47 <AfC> enko: we've been quite happy using it for data servers in a RESTful environment.
22:25:04 <enko> k
22:25:26 <tgeeky> edwardk: hm. Gibbons says: "For example, head is <<-homomorphic where a << b = a, but because << has no unit, head [] is undefined.
22:25:29 <tgeeky> "
22:26:01 <edwardk> tgeeky: so its a non-empty list homomorphism
22:26:09 <edwardk> not a list homomorphism ;)
22:26:13 <tgeeky> hehe
22:26:23 <tgeeky> your thing worked
22:26:29 <hpaste> tgeeky pasted “homs” at http://hpaste.org/70332
22:26:31 <edwardk> which?
22:26:33 <tgeeky> headH
22:26:36 <tgeeky> works as expected
22:26:47 <edwardk> oh the safe one
22:26:48 <edwardk> sure
22:27:19 <edwardk> "Pearl.GaDtTLHT.Internal.Hom"
22:27:25 <tgeeky> yep
22:27:26 <edwardk> easy to remember acronym in the middle there
22:27:33 <edwardk> i'm sure i'll get that capitalization right every time ;)
22:27:35 <tgeeky> not supposed to be remembered, it's a title :)
22:27:41 <palmfrond> uh
22:27:42 <tgeeky> (it's a functional pearl, not a library)
22:27:49 <palmfrond> hello, does haskell have a concept of null value?
22:27:54 <tgeeky> @src Nothing
22:27:54 <lambdabot> Source not found. You untyped fool!
22:27:56 <tgeeky> @src Maybe
22:27:56 <lambdabot> data Maybe a = Nothing | Just a
22:28:21 <palmfrond> ?
22:28:27 <edwardk> palmfrond: the short answer is no
22:28:38 <tgeeky> edwardk: it used to be: Pearl.Generalizing_and_Dualizing_the_Third_List_Homomoprhism_Theorem...
22:28:46 <tgeeky> so be thankful I decided never to publish that version :O
22:28:48 <palmfrond> ok then what happens if you try to work with some value which has not been set edwardk ?
22:28:50 <edwardk> the long answer is you can make 'undefined' or bottom inhabit every type, but there is no sane way to test for it
22:29:00 <MostAwesomeDude> If I'm doing AST->AST transformations, and I plan to completely change all of a certain constructor to another constructor, does it make sense for them both to still be of the same type?
22:29:03 <edwardk> palmfrond: well, then you can exploit laziness to tie the knot, or work with Maybe
22:29:08 <MostAwesomeDude> Or is there a more reasonable way to express that?
22:29:17 <edwardk> many usecases for null involve things like making circular lists, etc.
22:29:29 <edwardk> but we can make infinite structures or circular lists without null due to laziness
22:29:39 <edwardk> > let ones = 1 : ones in ones
22:29:40 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
22:29:48 <palmfrond> whoa
22:29:59 <palmfrond> wtf just happened aside from my mind exploding
22:30:02 * tgeeky wipes up palmfrond's brain from the wall, and stuffs it back in
22:30:02 <edwardk> the c version of that would make the list node, set the next pointer to null, then point it to itself
22:30:44 <edwardk> but in haskell we make a 'thunk' for ones, and when it evaluates it it points it to itself for you. thunk evaluation is a limited form of pointer manipulation, which happens to encompass the 'use null to initialize a circular list' use case
22:31:34 <palmfrond> edwardk, do you think null being present in a language is a shortcoming/failure?
22:31:48 <edwardk> palmfrond: anyways, this is why we don't have null ;)
22:31:48 <edwardk> i think haskell is better off not having to deal with it
22:31:57 <edwardk> because when it is present you always have to worry about someone using it
22:32:04 <edwardk> here you are free from a class of errors
22:32:10 <palmfrond> hrmm
22:32:16 <edwardk> if you explicitly _want_ null, use Maybe
22:32:22 <edwardk> this is better than having null
22:32:25 <palmfrond> but how do you represent the logic of something not having an answer on a question?
22:32:38 <edwardk> because a.) when you test to see that something isn't Nothing, you get the safety to use that knowledge
22:32:41 <edwardk> :t Maybe
22:32:42 <lambdabot> Not in scope: data constructor `Maybe'
22:32:46 <edwardk> er
22:32:50 <edwardk> @source Maybe
22:32:50 <lambdabot> Maybe not available
22:32:55 <edwardk> :t Just
22:32:56 <lambdabot> forall a. a -> Maybe a
22:32:57 <shachaf> @src Maybe
22:32:57 <edwardk> :t Nothing
22:32:57 <lambdabot> data Maybe a = Nothing | Just a
22:32:58 <lambdabot> forall a. Maybe a
22:33:07 <edwardk> > Nothing
22:33:08 <lambdabot>   Nothing
22:33:10 <edwardk> > Just 12
22:33:11 <lambdabot>   Just 12
22:33:26 <edwardk> > do x <- Just 12; y <- Just 13; return (x + y)
22:33:27 <lambdabot>   Just 25
22:33:32 <edwardk> > do x <- Just 12; y <- Nothing; return (x + y)
22:33:33 <shachaf> Another advantage of Maybe is that you can have Just Nothing.
22:33:33 <lambdabot>   Nothing
22:33:39 <shachaf> That's a really nice thing.
22:33:52 <palmfrond> dang
22:34:03 <palmfrond> give me some time to think about this please. and thank you
22:34:03 <edwardk> now, consider what happens when you look up something in an assoc list in a lisp like language. they use #f or null to represent the absence of something
22:34:10 <edwardk> how do you STORE a null value in such a list?
22:34:19 <palmfrond> hm
22:34:24 <palmfrond> you just treat the lack of a value as null
22:34:31 <edwardk> yes
22:34:44 <edwardk> so you can't 'find' a null. you have a container that can hold anything so long as it isn't null!
22:34:53 <edwardk> the java containers crap all over this as well
22:35:05 <edwardk> but in haskell
22:35:11 <edwardk> :t lookup
22:35:12 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
22:35:18 <edwardk> see the Maybe in the result?
22:35:24 <palmfrond> yea
22:35:42 <edwardk> so if you want to store things that may be null in there you can. and then b itself becomes Maybe
22:35:43 <palmfrond> i don't follow high level what's going on though fully
22:35:47 <shachaf> Is there any language other than Haskell that unifies (or tries to, at least) exceptions and error return values?
22:35:48 <edwardk> because Maybe (Maybe a) makes sense in haskell
22:35:52 <edwardk> > Just 1
22:35:52 <palmfrond> hmm
22:35:53 <lambdabot>   Just 1
22:35:56 <edwardk> > Just (Just 1)
22:35:57 <lambdabot>   Just (Just 1)
22:36:00 <edwardk> > Just Nothing
22:36:01 <lambdabot>   Just Nothing
22:36:29 <Adeon> Maybe (Maybe a) makes sense but is there a whole lot of reason to do that
22:36:35 <palmfrond> haskell unifies those? i'm also mystified as to what a language/platform *should* return when you give it say, an impossible command/statement/etc
22:36:37 <edwardk> we can distinguish between Just (Just x), Just Nothing and Nothing
22:36:50 <palmfrond> is it a return value? if so, is it 'False' constant? or?
22:36:54 <edwardk> palmfrond: the real answer? a _type_ error =P
22:37:06 <palmfrond> huh?
22:37:10 <edwardk> it shouldn't let you _get_ to runtime with such a thing
22:37:29 <palmfrond> like let's say you give some identifier which hasn't been created/defined/declared yet
22:37:39 <edwardk> thats a type error =)
22:37:52 <edwardk> > foo
22:37:53 <lambdabot>   Not in scope: `foo'
22:38:00 <palmfrond> so does the bork come back as a return value? or some special exception deal
22:38:00 <edwardk> that doesn't compile unless i define foo
22:38:15 <edwardk> no, it doesn't make it to evaluation. attempting to compile it fails
22:38:23 <palmfrond> what if it did make it to evaluation?
22:38:33 <Adeon> you can't make it to evaluation
22:38:41 <palmfrond> oh
22:38:52 <edwardk> that expression foo has no value, it has no type, and haskell terms need types to make sense, because we're a language a la church not curry
22:39:27 <palmfrond> ok
22:39:34 <palmfrond> man you guys really know your tool. i respect that
22:39:46 <palmfrond> i'm new to low level/language design
22:39:52 <palmfrond> runtime, etc
22:39:55 <edwardk> palmfrond: in general though, you often program in some monad tat knows how to give back errors to the user in haskell
22:40:15 <palmfrond> what are some ways one may choose to get errors back?
22:40:20 <edwardk> i.e. i might write a type checker that works in 'Either TypeError a' as my monad
22:41:02 <edwardk> > do x <- Right 12; y <- Right 13; z <- Left "Oh Crap!"; return (x + y * z)
22:41:04 <lambdabot>   Left "Oh Crap!"
22:41:08 <Adeon> you use data types that have error information in them in case something happens
22:41:23 <edwardk> now envision those Left and Rights were generated by calls into various functions
22:41:35 <edwardk> > do x <- Right 12; y <- Right 13; z <- Right 8; return (x + y * z)
22:41:36 <lambdabot>   Right 116
22:41:42 <Adeon> actual exceptions happen if something undefined was attempted to be evaluated
22:42:00 <edwardk> there are also places where the compiler will catch infinite loops and tell you
22:42:03 <edwardk> > let x = x in x
22:42:07 <lambdabot>   mueval-core: Time limit exceeded
22:42:15 <edwardk> well, not so much on lambdabot ;)
22:42:21 <shachaf> That's a different kind of exception.
22:42:25 <shachaf> And not the nice kind.
22:42:42 <tgeeky> > let x = error "whoops" in x
22:42:43 <lambdabot>   *Exception: whoops
22:42:44 <edwardk> > error "um, i didn't plan on this happening"
22:42:45 <lambdabot>   *Exception: um, i didn't plan on this happening
22:42:51 <DexterLB> how do I serialise data whose type is subclass of Show as a string? simply putting the data in a place where a String is expected doesn't work
22:42:57 <edwardk> is another way to yell at the user
22:43:06 <shachaf> DexterLB: s/subclass/instance/
22:43:12 <shachaf> DexterLB: Do you know how typeclasses work?
22:43:12 <DexterLB> (complete noob in haskell here, writing my first app)
22:43:19 <edwardk> > and in haskell the doesn't happen until you 'look at it'
22:43:19 <DexterLB> shachaf: sort of
22:43:20 <lambdabot>   <no location info>: parse error on input `in'
22:43:24 <shachaf> DexterLB: First rule: Typeclasses are nothing like OO classes at all.
22:43:34 <edwardk> > head (1 : undefined)
22:43:35 <DexterLB> shachaf: I get that, yeah
22:43:35 <lambdabot>   1
22:43:40 <edwardk> > head undefined
22:43:41 <lambdabot>   *Exception: Prelude.undefined
22:43:50 <tgeeky> edwardk: once we get ghci-in-the-browser, we'll make undefined = error [I don't know what i'm doing dog.jpg]
22:44:10 <edwardk> tgeeky: i'm sure shapr has placed that at the top of his priority queue ;)
22:45:15 <DexterLB> shachaf: from what I get, typeclasses are types that contain other types, and a function of type SomeClass accepts all types that are instances of it
22:46:05 <Cale> DexterLB: Typeclasses aren't themselves types
22:46:19 <shachaf> DexterLB: Nope, that's completely not the case. :-)
22:46:37 <Khorvo> and the rabbit hole goes deeper
22:47:04 <DexterLB> ah well :)
22:47:45 <shachaf> DexterLB: You can probably find a good introduction to this somewhere -- this IRC client input field might be a bit too narrow to contain an explanation.
22:48:03 <Cale> You can think of typeclasses as collections of types in a way, but predicates on types are a better way to think of it.
22:48:13 <shachaf> The general idea is that a type class is a *constraint* on a polymorphic type.
22:48:26 <shachaf> So reverse :: [a] -> [a], but sort :: (Ord a) => [a] -> [a]
22:48:42 <shachaf> Ord (a type class) is a constraint on the "a" that says that if you have two "a"s, you can compare them.
22:49:29 <DexterLB> that makes sense
22:50:23 <DexterLB> so only comparable types are instances of Ord?
22:52:58 <Adeon> yes
22:54:13 <Adeon> some other common typeclasses are Eq which means you can check two "a"s for equality and non-equality and Show which means you can get a string representation of the type using the "show" function
22:54:17 <hpaste> solrize pasted “you could have invented memo combinators” at http://hpaste.org/70333
22:55:51 <shachaf> DexterLB: Types that are instances of Show can be "shown" with the function "show".
22:55:55 <shachaf> @ty show
22:55:56 <lambdabot> forall a. (Show a) => a -> String
22:55:57 <shachaf> > show 5
22:55:58 <lambdabot>   "5"
22:56:00 <shachaf> > show True
22:56:01 <lambdabot>   "True"
22:56:17 <DexterLB> shachaf: thanks!
22:57:01 <DexterLB> let me guess: show :: Show a -> String
22:57:36 <Adeon> show :: (Show a) => a -> String
22:57:44 <DexterLB> hmm prelude says show :: (Show a) => a -> String
22:57:46 <DexterLB> yeah
22:57:51 <Adeon> see the =>? before that are the constraints
22:58:07 <DexterLB> right
22:58:25 <DexterLB> and I can constrain both to types and typeclasses?
22:59:00 <mauke> no
22:59:13 <Adeon> types themselves go to right of =>
22:59:16 <mauke> <constraings> => <type>
22:59:19 <mauke> er, constraints
22:59:41 <Adeon> String is a type, not a typeclass so its written a -> String
22:59:44 <Boney> DexterLB: typeclasses are used to constrain types.
22:59:49 <mauke> and constraints look like (<class> <type>, <class> <type>, ...)
23:00:12 <solrize> can anyone see obvious errors in my paste?  it "works" in that it must be memoizing something since it can compute fib 12345, but it takes several seconds while the conventional linear way is almost instant
23:00:14 <Boney> in this case, a is constrained such that it must be a member of Show.
23:00:23 <mauke> :t \x -> x < 0
23:00:25 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
23:00:43 <DexterLB> right
23:01:20 <mark2> hello
23:01:58 <solrize> hi mark2
23:02:22 <mark2> hi
23:02:26 <mark2> I have a problem
23:02:49 <mark2> I have call need to create a function that is a kind of state machine with 3 states (eg 1, 2 and 3) must be able to initialize and change the states
23:03:33 <mark2> must havemust have "memory", I mean it's going to be called by other functions to know its current state
23:03:46 <solrize> mark2 is this homework?  usually in haskell we try to avoid state
23:03:48 <mark2> any help?
23:06:07 <mark2> I have no other option
23:06:36 <Khorvo> The idea in Haskell is that functions stay stateless and pure
23:07:30 <Khorvo> If you describe what you are trying to solve maybe we can help you think of something that makes more sense in Haskell
23:09:27 <mark2> no solution to the state machine? :(
23:09:44 <Adeon> in haskell, any function that modifies a state would have to take a state as an argument and return a new state as part of its output
23:10:51 <Adeon> that process may be hidden with monads to some extent but if this is homework then you probably shouldn't worry about those yet
23:12:35 <Adeon> for example, the type signature of some function that modifies a state to have a new integer could look something like modifyIntegerState :: Int -> MyState -> MyState
23:13:11 <Adeon> it takes an integer and a state and returns a new state where the integer has been stored inside it
23:15:50 <Khorvo> Adeon: I think mark2 is talking about having a function that retains a state throughout a given runtime and having different things ask for it.
23:16:10 <Adeon> but they can't retain a state
23:16:23 <Adeon> at least, not if you play nice
23:16:34 <MostAwesomeDude> Well, you can't retain state, period; there's no place to put it.
23:16:37 <Khorvo> :-) Yeah thats what I was figuring
23:16:58 <Khorvo> And honestly, Haskell wasn't designed to be that impure
23:17:08 <MostAwesomeDude> mark2: Is this homework?
23:17:44 <mark2> :(
23:19:01 <mark2> :(
23:19:03 <mark2> there is no solution then
23:19:07 <mark2> ?
23:19:19 <Khorvo> mark2: If you would just describe what you are trying to accomplish, It's likely there is an actual way to do this with Haskell as it was meant to be coded
23:19:36 <Khorvo> and we could conceivably help with that
23:20:39 <MostAwesomeDude> mark2: Anything's possible. Chill a bit.
23:21:01 <Adeon> I think he mentioned he needs a state machine with 3 states
23:21:51 <Adeon> you can make a state machine in haskell. you just have to carry it as a value to functions and return it from them
23:22:55 <Adeon> it sounds like homework but I wouldn't know
23:23:20 <MostAwesomeDude> Sounds quite like homework.
23:26:32 <solrize> @faq can haskell make a state machine with 3 states ?
23:26:32 <lambdabot> The answer is: Yes! Haskell can do that.
23:27:40 <mark2> and invent something using readIORef writeIORef?
23:29:07 <mark2> haha, I want the solution
23:29:19 <MostAwesomeDude> mark2: What?
23:29:38 <MostAwesomeDude> mark2: You just make new states each time, and pass those states around.
23:34:45 <mark2> thanks, I went to kill myself. bye
23:36:47 <Khorvo> mark2: well that's unfortunate
23:37:54 <Adeon> what?
23:39:26 <Khorvo> Adeon: I think mark2 is not going to be finishing his homework tonight
23:39:37 <Adeon> :-(
23:40:34 <MostAwesomeDude> mark2: So, you *are* doing homework?
23:41:20 <Adeon> clearly our solution was inadequate
23:41:26 <Khorvo> MostAwesomeDude: Well he never admitted to it, but his non-answers to that question expose his guilt
23:42:11 <Adeon> I don't think there's anything wrong with asking help for homework as long as ready-made solution isn't handed right over
23:43:02 <mark2> with IORefs could not solve?
23:43:47 <akamaus> mark2, it's better to stay away from them :)
23:44:44 <shergill> mark2 why not use a state monad?
23:44:44 <Adeon> you can store and fetch values from IORefs
23:45:00 <Adeon> but I think in an abstract problem like this, staying away from IO is for the best
23:45:03 <mauke> shergill: doing it manually first might be easier to understand
23:45:16 <shergill> mauke: oh right, true
23:45:30 <Catnaroek> mark2: What are you trying to do exactly?
23:45:44 <Adeon> a state machine with 3 states
23:46:05 <mauke> True, False, and FileNotFound
23:46:27 <Catnaroek> Well, data SMS = A | B | C
23:46:35 <Catnaroek> Where SMS obviously stands for State Machine State. :P
23:46:42 <dmwit> Nothing, Just Nothing, and Just (Just ()) are the canonical three states.
23:46:53 <mauke> :t (`mod` 3) . succ
23:46:54 <lambdabot> forall a. (Integral a) => a -> a
23:46:58 <Catnaroek> dmwit: lol :P
23:47:19 <Catnaroek> Then make some State SMS a, where a is whatever.
23:47:55 <Khorvo> 'night #haskell
23:48:03 <Catnaroek> And finally "flip runState initialState theStateMachine"
23:48:13 <Catnaroek> s/run/exec/
23:56:37 <solrize> does anyone here use memo combinators?  is there a huge speed hit from them?  or maybe i'm just doing something wrong
