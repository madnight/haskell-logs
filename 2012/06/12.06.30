00:13:34 <alienpilgrim> anyone able to help me speed up an 8 line function?
00:13:47 <shachaf> Who knows?
00:13:53 <alienpilgrim> well let's see :)
00:13:56 <alienpilgrim> squaredDeviation :: A.Array Int Double -> [Int] -> Double squaredDeviation doubleColumn indices = 	let ys = map ((A.!) doubleColumn) indices in 	let numerator = sum' ys in 	let denominator = (fromIntegral . length) indices in 	let average = numerator/denominator in 	let devSq = map (\x -> let d = average - x in d*d) ys in 	sum' devSq
00:13:59 <alienpilgrim> argh
00:14:09 <alienpilgrim> squaredDeviation :: A.Array Int Double -> [Int] -> Double
00:14:13 <alienpilgrim> squaredDeviation doubleColumn indices =
00:14:18 <alienpilgrim> 	let ys = map ((A.!) doubleColumn) indices in
00:14:22 <alienpilgrim> 	let numerator = sum' ys in
00:14:27 <alienpilgrim> 	let denominator = (fromIntegral . length) indices in
00:14:31 <alienpilgrim> 	let average = numerator/denominator in
00:14:35 <alienpilgrim> 	let devSq = map (\x -> let d = average - x in d*d) ys in
00:14:37 <shachaf> alienpilgrim: Please don't paste in here!
00:14:38 <shachaf> Use hpaste.org
00:14:43 <alienpilgrim> ah
00:15:09 <hpaste> AlienPilgrim pasted “SquaredDeviation” at http://hpaste.org/70621
00:15:17 <alienpilgrim> my apologies
00:15:32 <alienpilgrim> the array is unboxed, and sum' is a strict version of sum
00:15:56 <alienpilgrim> I've run it through the profiler but am not great at interpreting the results
00:16:19 <danr> alienpilgrim: you should check the
00:17:29 <danr> So you're only calculating the sqdev for the given indices?
00:17:36 <alienpilgrim> yes
00:17:57 <alienpilgrim> for a randomForest implementation
00:34:58 <blackdog> anyone looking for an ICFP team? Sean Seefried and I are thinking of having a crack
00:37:30 <shachaf> Hmm, the ICFPC is coming up.
00:37:47 * shachaf might well be busy during the time it's scheduled...
00:38:15 <blackdog> shachaf: yeah, it's hard getting that much time off
00:38:25 <blackdog> and good hackers tend to be booked up
00:45:29 <JuanDaugherty> boy why is it so hard to get a buildout of haskell platform?
00:45:43 <JuanDaugherty> makes it look like a lot of clueless academics that can't cut the production cheese
00:47:31 <blackdog> JuanDaugherty: can you be more specific? what are you finding difficult?
00:48:29 <JuanDaugherty> every path I take ends in failed builds due to no ability to disable GL and other packages that don't build
00:49:06 <JuanDaugherty> ghc seems to build OK, but after that it goes south
00:49:43 <JuanDaugherty> 7.4.1
00:51:24 <JuanDaugherty> i don't want' GUI at all, I can't understand why they pile all that shit in there with no ability to select
00:52:14 <JuanDaugherty> but a path that would result in a working cabal install would be good too, that also fails for similar reasons
00:52:42 <Kakadu> Can you give me a tip how to use download library in ghci ? paste.in.ua/4453/raw/
00:52:57 * shachaf suspects that going into a channel and insulting random people and things isn't the best way to get help on IRC.
00:52:57 <JuanDaugherty> i'm trynna build on stock linux servers, not desktop hosts
00:53:49 <JuanDaugherty> well random means nobody right? So unless you identify as a clueless academic no offense should be taken :)
00:54:04 <shachaf> I don't think that's how it works.
00:54:21 <JuanDaugherty> mehbe not
00:55:28 <JuanDaugherty> perhaps a more politic expression of this distinction of haskell from other computing cultures could have been found
00:56:15 <blackdog> JuanDaugherty: i think it's a reasonable complaint. I'm honestly not completely convinced that the Haskell Platform has been an unqualified success.
00:56:29 <MostAwesomeDude> JuanDaugherty: I am insulted.
00:56:46 <blackdog> do you need it for a particular reason? could you just cabal install the top level stuff you need?
00:57:03 <shachaf> Oh, the complaint itself isn't that unreasonable.
00:57:07 <JuanDaugherty> sure could if I could get cabal install built
00:57:18 <shachaf> If you don't want GL etc. I think your main option is not to use the Haskell platform.
00:57:27 <JuanDaugherty> which I no doubt will, have before
00:57:28 <shachaf> Just download GHC and cabal-install packages yourself.
00:58:02 <blackdog> shachaf: yeah, i know it's not nice to hear in that way, but generally when people get to the point of complaining in the channel, they've spent a fair amount of time bashing their collective heads against the wall.
00:58:06 <JuanDaugherty> the thing is, in every other computing culture known to me, not having your platform install pkg would be flat unacceptable
00:58:35 <blackdog> JuanDaugherty: what platform are you installing on?
00:58:41 <JuanDaugherty> *install pkg just work
00:59:06 <MostAwesomeDude> JuanDaugherty: Well, cabal *does* Just Work.
00:59:07 <JuanDaugherty> blackdog, centos, debian, and redhat
00:59:24 <MostAwesomeDude> JuanDaugherty: What *you* are doing is probably either Doin' It Wrong or willfully ignoring instructions.
00:59:40 <JuanDaugherty> by centos I mean the AWS version
01:00:16 <JuanDaugherty> MAD, I'm doing neither.
01:00:25 <MostAwesomeDude> Did you consider just installing GHC and cabal and then installing things as-needed?
01:00:30 <blackdog> MostAwesomeDude: come on. have you never managed to get cabal into a broken situation?
01:00:42 <JuanDaugherty> MAD, yes and tried that.
01:00:47 <blackdog> JuanDaugherty: at least on debian, cabal-install and ghc are packaged
01:00:51 <MostAwesomeDude> blackdog: No, but then again I am typically only using cabal to install and update Haskell packages.
01:01:03 <JuanDaugherty> yeah but they're ancient
01:01:08 <shachaf> blackdog: I'm not particularly personally offended or anything, I just think the channel is worse off for it (and JuanDaugherty would be too, if the people in here weren't so nice).
01:01:22 <JuanDaugherty> debian production anyway, don't know what's in sid
01:01:24 <blackdog> MostAwesomeDude: well, yeah. that's what it's for, right?
01:01:32 <blackdog> JuanDaugherty: ah, yeah. unstable is bang up to date
01:01:50 <shachaf> This is probably a metadiscussion topic for #haskell-blah or something. Or for nowhere at all. :-)
01:02:35 <MostAwesomeDude> The problem, as phrased, is that haskell-platform isn't in centos.
01:02:57 <MostAwesomeDude> JuanDaugherty: Do you *need* this year's haskell-platform?
01:03:25 <JuanDaugherty> yes, the end package I want to use is current, uses yesod, etc.
01:03:32 <shachaf> JuanDaugherty: You probably don't need haskell-platform at all.
01:03:39 <shachaf> All it is is a bunch of packages that you can install by hand too.
01:04:01 <JuanDaugherty> yeah I could if I could get cabal install to build
01:04:06 <JuanDaugherty> maybe
01:04:22 <blackdog> JuanDaugherty: ok, let's break that down. why can't you build cabal-install?
01:04:42 <blackdog> you should be able to get just ghc installed, then run the cabal bootstrap script
01:05:13 <JuanDaugherty> yes I know but the facts are different from tha expectation whence my kvetch
01:05:59 <blackdog> JuanDaugherty: I don't mind that you kvetch. as i made abundantly clear in http://mwotton.github.com/hs_gbu i think cabal is a real pain point for app developers.
01:06:24 * blackdog inserts standard disclaimer that it's much better than nothing, and that it's enabled the current ecosystem, etc etc etc
01:06:34 <JuanDaugherty> it's fairly well known although some seem to wanna go all Lady Bracknell about it
01:06:47 <blackdog> but if you're used to ruby infrastructure, it's gonna seem a bit rough.
01:07:26 <blackdog> JuanDaugherty: do you want to get your situation fixed? Happy to help for a bit, but if you just wanted to have a bit of a bitch, then that's ok too.
01:07:47 <JuanDaugherty> no I'm not a rubyist, why would you assume that, didn't mention it did I?
01:08:08 <blackdog> JuanDaugherty: no - i didn't mean "you" specifically
01:08:11 <JuanDaugherty> no, I can fix it myself. I just wanna vent.
01:08:21 <blackdog> I would have said "one" if it didn't sound so precious
01:08:52 <JuanDaugherty> One needn't be so ... so
01:09:51 <blackdog> what is your background, out of curiosity?
01:10:04 <JuanDaugherty> in computing?
01:10:27 <blackdog> i think part of the problem is that haskellers compare things to the way it used to be, and people coming from other languages compare it to the facilities they have there
01:10:30 <blackdog> ya
01:10:31 <JuanDaugherty> <= real name.
01:11:34 <JuanDaugherty> i have four year degree in math/cs and 30+ years professional experience
01:12:33 <JuanDaugherty> <= juan@acm.org
01:14:24 <shergill> does cabal's config file (located at ~/.cabal/config) support setting ghc-options?
01:14:25 <ski> zeiris : ok
01:15:17 <shergill> alternatively could someone point out to the documentation for what's supported by the config file? my google-fu is running low
01:17:20 <nand`> blackdog: hey, I do the same. I compare Haskell to everything I was using before. I have since stopped using everything I was using before, incidentally
01:18:10 <nand`> (then again, I also don't use cabal-install)
01:18:22 <Penetrator> @where forkIO
01:18:22 <lambdabot> I know nothing about forkio.
01:18:43 <fmap> @hoogle forkIO
01:18:44 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
01:18:44 <lambdabot> GHC.Conc.Sync forkIO :: IO () -> IO ThreadId
01:18:44 <lambdabot> GHC.Conc forkIO :: IO () -> IO ThreadId
01:18:54 * Ducklings cums in fmap's face
01:19:14 <Penetrator> fmap: thanks
01:19:20 <blackdog> nand`: heh. yeah, the actual coding experience is leaps and bounds above.
01:19:23 <Ducklings> Penetrator: ur welcome
01:19:35 * Ducklings cums in blackdog's face
01:19:46 <JuanDaugherty> nand' so what do you do? Inspect and build each pkg manually with ghc alone?
01:19:59 * Ducklings punches penetrator in the face with a large dildo
01:20:00 <Axman6> @where ops
01:20:00 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
01:20:44 <nand`> JuanDaugherty: if I really have to build a package manually I use “runhaskell Setup.lhs configure” and “runhaskell Setup.lhs build” which is pretty much the same thing cabal-install does; but I install them manually. The vast majority of the time, however, I'll by using my system-wide package manager to do the haskell building/installing
01:20:46 <nand`> I'll be*
01:21:16 <nand`> which, being a package manager, is much more sophisticated than cabal-install when it comes to dependencies and stuff
01:21:40 <blackdog> nand`: that can work when you've got an active haskell team for the OS
01:21:47 <JuanDaugherty> and you've not released this boon to mankind?
01:21:58 <ksf> it's actually pretty hard to be more sophisticated than cabal-install
01:22:16 <ksf> ...the main difference is that usual package manegers can remove stuff.
01:22:20 <nand`> blackdog: 1. there is; 2. there's a script that converts .cabal files to packages for my distro fully automatically; if something hasn't been ported already I type one command “hackport merge <name>” and it'll download it from haddock etc. automatically
01:22:38 <ksf> but unless you're using nix, updates and removes are always problematic.
01:22:56 <nand`> ksf: speaking of which, does Haskell cover non-haskell runtime dependencies?
01:22:58 <nand`> err
01:22:59 <nand`> does cabal*
01:23:18 <ksf> not cabal configure does, and ghc-pkg.
01:23:36 <JuanDaugherty> don't get me started on the situation in nix with haskell
01:23:36 <ksf> that is, they record linker flags
01:23:46 <ksf> nix has first-system syndrome
01:24:06 <nand`> JuanDaugherty: what's wrong with nix and Haskell? I'm genuinely curious
01:24:08 <ksf> the configuration is *way* too first-class.
01:24:32 <mel-> morning :)
01:25:40 <JuanDaugherty> about 20% of nix pkgs in my experience are flat broken, either don't build at all or the built thing doesn't work
01:25:59 <JuanDaugherty> maybe higher or lower depending on how you judge
01:26:21 <JuanDaugherty> there were warring pkg collections at one point
01:26:59 <JuanDaugherty> but what is "your platoform", nand, and have you released your pkg mgr?
01:28:08 <nand`> JuanDaugherty: “my platform” is not really mine; it's just the one I'm using and it's a system called “Gentoo Linux”. The package manager I use for it is called “Portage”, and the hackage utility I use for it is called “app-portage/hackport” and can be found in the “gentoo-haskell” overlay (sort of like a user repository), along with everything else haskell related
01:28:15 <nand`> they are all free and open source
01:29:09 <JuanDaugherty> i c
01:29:11 <nand`> I also use “app-admin/haskell-updater” to automatically rebuild broken packages after upstream updates (which are quite common, being a rolling release repository)
01:29:58 <ksf> I just downgraded ghc to 6.12 because portage was keen on overwriting the binary package, breaking ghc.
01:30:10 <JuanDaugherty> nand, so what level of ghc are you at or do you support multiple?
01:30:59 <Taneb> Hey #haskell
01:30:59 <ksf> 80% of those problems are the haskell ebuilds and eclass not being as nice as they could be, though.
01:31:21 <nand`> JuanDaugherty: gentoo-haskell has: 6.10.4, 6.12.3, 7.0.4, 7.4.1, 7.4.2, 7.5.20120608, 7.5.20120615 and 9999 (live)
01:31:28 <nand`> I use 7.4.2, which is the latest marked “testing”
01:31:37 <Taneb> Can someone explain the advantages of Vector compared to Array, and vice-versa?
01:31:51 <ksf> first thing, slot ghc, and slot the packages both themselves and against their ghc.
01:31:56 <nand`> ksf: I've noticed some issues with the cabal eclass myself, but nothing major. Examples? (This is probably getting off-topic, maybe take it to #gentoo-haskell or something)
01:32:11 <nand`> ah yes, slotted packages would be a huge improvement
01:32:26 <ksf> well, like that it's even possible that it overwrites the binary lib ghc came with.
01:33:06 <ksf> the ebuild itself should look at whether it is already registered, right now the ebuilds come with a list that lists what ghc they come with.
01:33:25 <ksf> I installed a ghc my binary ebuild knew nothing about.
01:33:31 <nand`> I see
01:34:19 <ksf> otoh, having 6.12 system-wide is fine, I've got 7.4.2 installed in $HOM
01:34:21 <ksf> E
01:34:39 <nand`> I have 7.4.2 system-wide, but this is a single-user system
01:34:44 <ksf> mine, too.
01:35:03 <roconnor__> @check (m * d <= n)  == (m <= n `div` d)
01:35:05 <lambdabot>   "OK, passed 500 tests."
01:35:18 <roconnor__> @check \m d n -> (m * d <= n)  == (m <= n `div` d)
01:35:20 <lambdabot>   "Falsifiable, after 0 tests:\n1\n-2\n0\n"
01:35:50 <roconnor__> @check \m d n -> (0 < d) ==> (m * d <= n)  == (m <= n `div` d)
01:35:51 <lambdabot>   Not in scope: `==>'
01:35:56 <roconnor__> ?
01:36:15 <ksf> default to Natural?
01:36:33 <roconnor__> @check \m d n -> (0 < d) <= ( (m * d <= n)  == (m <= n `div` d) )
01:36:34 <lambdabot>   "*Exception: divide by zero
01:36:41 <roconnor__> I could use ==> about now
01:37:14 <roconnor__> @ask Cale why does @check not allow ==> ?
01:37:15 <lambdabot> Consider it noted.
01:37:56 <ksf> how well does ghc compile gigantic cases?
01:38:38 <ksf> ...computable, iff you match into classes first.
01:40:17 <roconnor__> @check \m d n -> ( (m * (abs d + 1) <= n)  == (m <= n `div` (abs d + 1)) )
01:40:19 <lambdabot>   "OK, passed 500 tests."
01:41:53 <dmwit> ksf: GHC compiles large cases very well.
01:42:48 <dmwit> Up to about 10 cases, it uses a decision tree; above that, a jump table.
01:42:54 <Kakadu> http://paste.in.ua/4454/ Can you help me with linking?
01:47:13 <ksf> dmwit, 2095?
02:03:35 <Taneb> I'm possibly the only person who'd ever want Word3
02:03:37 <ksf> oh, if you guys want to bulid a distribution, please do the package store like nix, but with FUSE
02:07:50 <MostAwesomeDude> Hm. I suppose I should look at Conduits for my next networking project.
02:22:47 <Jeanne-Kamikaze> does forkIO create a thread, or does it fork ?
02:22:57 <c_wraith> green thread
02:23:17 <Jeanne-Kamikaze> so how do I fork ?
02:23:35 <dmwit> What does "fork" mean?
02:23:45 <Jeanne-Kamikaze> it duplicates the process
02:23:55 <solrize> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/unix-2.4.2.0/System-Posix-Process.html
02:23:55 <dmwit> You want a new process?
02:23:58 <Jeanne-Kamikaze> yes
02:24:04 <Jeanne-Kamikaze> ok thanks
02:24:32 <Ke> there is a fork, but ghc runtime requires more than it provides
02:25:05 <Ke> ie. it's only good for exec, not for running ghc haskell
02:28:27 <MostAwesomeDude> Jeanne-Kamikaze: What are you working on, exactly?
02:28:45 <Jeanne-Kamikaze> I wanna start the happstack app in the background
02:28:48 <Jeanne-Kamikaze> so I just fork it
02:28:55 <Jeanne-Kamikaze> it's working now
02:34:24 <ksf> how the hell am I supposed to generate documentation with haskell-src-exts?
02:34:47 <ksf> generate artificial srclocs that are a thousand lines apart?
02:38:04 <mgsloan> ksf: hmm?
02:38:54 <ksf> the ast itself doesn't take comments, the unly unparser there is that accepts comments does so as a parameter beside the ast.
02:39:00 <ClaudiusMaximus> ksf: maybe a multipass process: pretty print without documentation, reparse, use srclocs of reparsed output to insert into raw text of pretty-printed output
02:39:01 <ksf> http://hackage.haskell.org/packages/archive/haskell-src-exts/1.9.0/doc/html/Language-Haskell-Exts-Annotated-ExactPrint.html
02:39:39 <ksf> reparse as often as I insert a comment.
02:39:49 <ksf> but yes, that would work.
02:40:19 <solrize> ddddddd
02:40:22 <solrize> sorry
02:40:34 <ksf> well, I could only generate -- ^ comments, -- | would offset srcloc.
02:40:37 <hpaste> Kakadu pasted “Error” at http://hpaste.org/70623
02:40:45 <ksf> but then I can probably keep them to one line.
02:40:51 <Kakadu> Can you hep me to fix compilation?
02:40:54 <Kakadu> help*
02:41:22 <ksf> I'm not bound to haskell-src-exts, though, there *must* be an AST that supports comments.
02:41:57 <mgsloan> holy cow, I'm surprised by that
02:42:07 <mgsloan> I guess it's because Haskell modules are treated as unordered
02:43:45 <mgsloan> you could also pretty print per top-level declaration, and intersperse comments that way
02:44:29 <ksf> ghc seems to strip comments. too.
02:45:01 <mgsloan> yeah, it only needs to preserve pragmas
02:46:27 <mgsloan> out of curiosity, what're you working on?
02:47:20 <ksf> x bindings
02:48:19 <mgsloan> X11?
02:48:22 <ksf> yep
02:48:50 <mgsloan> cool stuff, best off luck!
02:48:55 <ksf> the second take on xcb-like bindings, the current ones (xhb) have issues
02:49:16 <mgsloan> s/off/of
02:49:53 <ksf> I think printing per decl is the best idea.
02:58:47 <hpaste> “Ren Juan” pasted “hledfer-web 0.18.1 build problem” at http://hpaste.org/70624
03:01:29 <linduxed> hey guys, i'm looking for some help withe this issue http://codereview.stackexchange.com/questions/13195/is-there-a-way-to-avoid-unnecessary-recursion
03:02:18 <linduxed> basically, i don't want to go down recursive paths that i most likely won't use at all
03:10:06 <Botje> can you prune branches halfway through?
03:11:29 <Botje> as you go, keep the best score and stop following branches that will not improve on that score
03:12:35 <linduxed> well... the thing is that i'm looking for the path that has the most of a certain value in the end
03:12:49 <linduxed> you only get to know that value at the very end of the run
03:13:15 <linduxed> at that point, yeah you could discard the path if it's smaller than the most valueable path so far
03:13:29 <linduxed> but by that time you've already made the expensive computations
03:14:28 <linduxed> i guess it could work if i was looking for the _lowest_ value, but this is the opposite
03:14:58 <blackdog> linduxed: perhaps look into A* search?
03:15:23 <Baughn> "Could not deduce (b ~ c) from.. well, it's not important. Fix your program."
03:15:30 <blackdog> the idea there is to get a pessimistic estimate that lets you get rid of branches once they're really bad.
03:15:38 <Baughn> Okay, but why is it tilde instead of an equals sign?
03:16:31 <MostAwesomeDude> Baughn: Type equality.
03:16:41 <Baughn> MostAwesomeDude: Exactly my point.
03:17:02 <MostAwesomeDude> Baughn: Oh, types aren't values, they don't use the same operators for comparison.
03:17:40 <Baughn> MostAwesomeDude: I get that, I'm wondering why they don't. It's obvious that it's a type..
03:17:55 <linduxed> blackdog: that could be an idea
03:18:18 <Baughn> MostAwesomeDude: Maybe it could use ⋍
03:18:41 <linduxed> blackdog: i haven't got the slightest clue how to implement it and, more importantly, adjust it to this problem
03:19:24 <MostAwesomeDude> Baughn: I can't see your Unicode character, but at any rate, ~ is the syntax. There's not gonna be any change to it. (I gather it has to do with maths.)
03:19:33 <Baughn> ..ah. Maths.
03:19:37 <Baughn> Say no more.
03:20:51 <bitonic> Baughn: GHC uses = with types for other messages anyway
03:21:05 <bitonic> > let t x = x x in t
03:21:07 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
03:21:17 <Baughn> That's a point.
03:21:23 <Baughn> I'm unsure of what the difference is.
03:21:32 <irene-knapp> okay, so
03:21:34 <irene-knapp> I am
03:21:38 <bitonic> Baughn: ~ refers to type families
03:21:39 <irene-knapp> in the occurs-check one
03:21:43 <shachaf> bitonic: Not really.
03:21:46 <irene-knapp> it's "is defined as"
03:21:51 <Baughn> bitonic: I'm not using any. They're not even turned on.
03:21:52 <ksf> why does haddock choke on \< ?
03:21:59 <ksf> the docs say I should escape the <
03:22:02 <irene-knapp> in the "could not deduce", it's "does not unify with"
03:22:07 <shachaf> > let x :: forall a. (a ~ Int) => a; x = 5 in x
03:22:08 <lambdabot>   5
03:22:12 <Baughn> bitonic: The problem I'm looking at is a simple monomorphism restriction thing.
03:22:26 <bitonic> shachaf, Baughn: as far as I know, ~ was introduced with type families. You can use it for other puposes
03:22:33 <shachaf> > let x :: forall a b. (a ~ (a -> b)) => a; x = undefined in x
03:22:35 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> bOccurs check: c...
03:22:37 <kylemcgill> Hi Haskell, if i was to distribute an application that i would want compiled on host computer, is there any smaller implementation of GHC, Stackoverflow have suggested a smaller 5MB GHC Compiler, but no recommendation as to who to get there...
03:23:07 <irene-knapp> right, so when it appears in an error message, ~ connects two types which GHC knows are equivalent (are to be unified) but which it can't actually unify yet
03:23:10 <kylemcgill> how** to get there**
03:23:10 <bitonic> kylemcgill: Hugs is very small
03:23:17 <Baughn> > let x :: forall a b c. (a ~ (b -> c)) => a; x = id in x 2
03:23:19 <lambdabot>   Couldn't match expected type `c' against inferred type `b'
03:23:19 <lambdabot>    `c' is a rigi...
03:23:38 <kylemcgill> bitonic: trusted by the haskell community?
03:23:53 <shachaf> kylemcgill: Why do you want it compiled on the host computer?
03:23:56 <kylemcgill> i am still new, but any recommendations are appreciated
03:24:00 <bitonic> kylemcgill: yeah, but it's an interpreter, and it's dead. but it works well
03:24:54 <kylemcgill> shachaf: lets say i build on 64 bit, and their host computer is 32bit, im under the assumption they will need to compile it
03:25:12 <Baughn> > let x :: forall a b c. (a ~ (b -> b)) => a; x = id in x 2
03:25:13 <shachaf> kylemcgill: Just provide a 32-bit build?
03:25:13 <lambdabot>   2
03:25:14 <kylemcgill> and for differing glib (or w/e) files
03:25:18 <Baughn> ..forall bites again.
03:25:28 <bitonic> kylemcgill: you can distribute various binaries, but yeah glib is a problem
03:25:37 <Baughn> > let x :: exists a b c. (a ~ (b -> c)) => a; x = id in x 2
03:25:38 <lambdabot>   <no location info>:
03:25:39 <lambdabot>      Illegal symbol '.' in type
03:25:39 <lambdabot>      Perhaps you intend...
03:25:43 <shachaf> kylemcgill: Every one of the problems you mentioned is going to be more complicated if you have to distribute GHC *along with* your program.
03:25:47 <ksf> haddock really ought to learn some proper markup like markdown
03:26:08 <Jeanne-Kamikaze> impressive, I misspell a variable and ghc suggests the correction
03:26:27 <irene-knapp> Jeanne-Kamikaze: yeah, I love that feature
03:26:50 <ksf> I once filed a feature request for it, just to be told that it's a duplicate.
03:27:00 <kylemcgill> Well my train of thought was that, if i build a package for lets say Archlinux on AUR, potentially, they will need to build it, but instead of listing GHC as a dep' maybe listing a smaller Compiler (such as Hugs)
03:27:06 <shachaf> I once filed a GHC bug.
03:27:11 <shachaf> A few hours ago.
03:27:19 <shachaf> It turned out that I already had an account but I'm not sure how.
03:27:28 <irene-knapp> I once found a bug in the type checker :D
03:27:31 <irene-knapp> I was pleased with myself
03:27:52 <irene-knapp> "My program doesn't work.  Maybe it's the compiler's fault.  OH WOW IT REALLY WAS."
03:28:00 * ksf crashed the RTS with insanely low stack sizes
03:28:08 <irene-knapp> hah, interesting
03:38:40 <ksf> haddock escaping seems completely broken
03:42:09 <stas_> 7ping haskell
03:42:13 <stas_> argh
03:43:59 * irene-knapp spent a good three seconds trying to figure out what a 7ping did differently than a normal ping
03:44:29 <cesip> hehe. joined a channel for the first time... immediate fail
03:45:05 <irene-knapp> hehe no worries
03:46:29 <morel> can i use guards everywhere where i can also use if-then-else? or just at the beginning of function definitions?
03:46:34 <irene-knapp> the latter
03:46:45 <irene-knapp> also you can use them in case expressions
03:47:01 <morel> irene-knapp: how can i use them in case-expr?
03:47:21 <irene-knapp> so an idiom that I don't actually like is:  case () of { () | foo -> doFoo ; | bar -> doBar }
03:47:26 <irene-knapp> note that as usual, semicolons are newlines
03:47:44 <irene-knapp> and the { } are similarly unneeded except to write things on one line for terseness
03:47:51 <morel> irene-knapp: thanks. i'll try that :)
03:47:54 <irene-knapp> np :)
03:52:50 <morel> irene-knapp: works =)
03:53:08 <morel> hi copumpkin :)
04:20:53 <cesip> i cannot seem to post to haskell-beginners for some reason
04:21:13 <shachaf> Are you subscribed?
04:21:21 <cesip> i checked to see if i needed specific rights to do so, but i couldn't find anything
04:21:25 <cesip> yes i receive all the emails
04:21:36 <shachaf> Are you sending email from the same address you used to subscribe?
04:21:41 <cesip> yes
04:21:44 <cesip> ah wait
04:22:05 <cesip> yup, that's it. in germany, gmail is sending from @googlemail by default
04:22:10 <cesip> probably the reason
04:22:20 <shachaf> Probably. :-)
04:23:19 <cesip> thanks, gave me the right idea : )
04:31:44 * hackagebot monad-control 0.3.1.4 - Lift control operations, like exception catching, through monad transformers  http://hackage.haskell.org/package/monad-control-0.3.1.4 (BasVanDijk)
04:41:44 * hackagebot lifted-base 0.1.1.1 - lifted IO operations from the base library  http://hackage.haskell.org/package/lifted-base-0.1.1.1 (BasVanDijk)
04:55:37 <ksf> is there a way to give haddock an import directory? --help doesn't list any.
05:01:29 <mel-> I have a question regarding indentation of if-then-else. Say, i have 'if condition' on the first line, 'then foo' on the second line and 'else bar' on the third line -- everything indented by the same amount of whitespacs. I read in several introductory texts that in has to indent the 'then' and the 'else' part with more spaces then the 'if' part. otherwise the 'if'-part would be parsed as an (incomplete!) expression on it's own and parsing would therefore fail. b
05:02:04 <irene-knapp> that is correct, as I understand it
05:02:16 <irene-knapp> I usually put "then" and "else" with exactly two spaces more than the "if" has
05:02:21 <mcstar> no
05:02:33 <mcstar> then and else can be indented just as much as if
05:02:34 <ksf> not anymore in Haskell2010
05:02:37 <irene-knapp> oh, okay
05:02:50 <mel-> so that has been a change in Haskell2010?
05:02:56 <ksf> 12 years to fix that bug ;)
05:03:49 <ksf> mel-, http://hackage.haskell.org/trac/haskell-prime/wiki/DoAndIfThenElse
05:05:56 <mel-> i see, thanks. :)
05:08:24 <t7> i wish there was tab complete on every word
05:08:35 <t7> using the context and some naive AI
05:10:39 <mcstar> learn to touchtype
05:12:04 <osfameron> context + Mechanical Turk
05:12:54 <t7> i remember seeing a video about a spell check that used context to improve accuracy
05:13:04 <t7> re-use that in my tab completion thing
05:15:15 <pooya72> so a noob question: what is literate haskell?
05:15:35 <t7> haskell with documentation
05:15:40 <t7> in latex format i think
05:15:41 <blackdog> pooya72: it's a way of writing haskell that emphasises comments
05:15:45 <mcstar> documentation with code rather
05:15:47 <t7> the haskell code starts with a >
05:15:49 <PatrickRobotham> pooya72: Literate haskell is a way of writing haskell where the comments are the text, and the code has to be explicitly marked.
05:15:50 <blackdog> basically, all code starts with "> "
05:15:59 <mcstar> and it isnt haskell specific
05:16:19 <blackdog> ... i always forget how quick you have to be with an answer in this channel. carry on.
05:16:20 <pooya72> oh ok, so that way people write a lot of comments?
05:16:41 <mcstar> a prose salted with code
05:16:47 <blackdog> pooya72: yes. the idea is that you'd write the program like an essay, with actual code in there to illustrate the point
05:17:03 <blackdog> there aren't a lot of programs that meet that lofty standard, though.
05:17:21 <applicative> pooya72: for example blog posts are often in .lhs
05:17:47 <pooya72> so is it only for teaching/blogs or are large programs written in .lhs?
05:18:12 <pooya72> and thanks for your help everyone.
05:18:29 <applicative> pooya so if you cut and paste this, save it as sigfpe.lhs etc  http://blog.sigfpe.com/
05:18:30 <mcstar> it isnt haskell, but i'd note that Axiom is a huge programi written in literate style
05:18:38 <mcstar> the code is the documentation and vice versa
05:19:00 <applicative> pooya72: no, whole books have been written in lhs
05:20:19 <pooya72> so this actually interesting. so should i be writing my noob apps in .lhs just so I know what I'm doing?
05:20:43 <applicative> a huge amount of the ghc is in lhs
05:20:51 <cesip_away> .lhs is great because it keeps you from not commenting your code
05:21:09 <cesip_away> you automatically write everything out in natural language before defining the functions
05:21:20 <cesip_away> this leading to a better understanding
05:21:33 <cesip_away> plus you can revisit your programs and spend less time figuring out what you did
05:21:54 <mcstar> has it been decided that literate programming is superior to non-literate one?
05:22:19 <blackdog> mcstar: it's a matter of taste, really
05:22:25 <cesip_away> sorry, on the run so did not read everything posted above
05:22:43 <blackdog> you aren't going to immediately improve your code just by switching the formatting
05:22:51 <applicative> pooya72: it's a bit of a pain without good editor support.  note that withpandoc you can write markdown there is a markdown+lhs reader
05:24:22 <pooya72> blackdog: yeah I don't want better code, but I want to reference why i did things for later use. I'm actually a philosophy major with an emphasis on hermeneutics, so any topic of "communication" is of interest.
05:24:42 <pooya72> applicative: I'm on vim. Don't know if that helps.
05:25:44 <mcstar> applicative: what is a good blog service provider that lets you insert code and latex the most natural way?
05:26:10 <blackdog> pooya72: i go back and forth on .lhs. i do like the argument that minimal commenting means you go for more descriptive function names, and split things up so it's self-evident
05:26:22 <irene-knapp> I think "Beware of philosophers who code" should be a proverb.  Along the lines of the old "Beware of programmers who carry screwdrivers."
05:26:31 <pooya72> blackdog: that's a good point.
05:26:38 <pooya72> irene-knapp: haha!
05:26:59 <blackdog> irene-knapp: not as scary as programmers with soldering irons
05:27:07 <blackdog> or worse, hardware engineers with editors...
05:27:15 <pooya72> so I like the \begin{code} latex style!
05:27:58 <mcstar> my question is in fact open, feel free to answer, anyone
05:28:36 <applicative> mcstar I don't know which is supposed  to be best these days. things are changing so fast with mathjax  and so on
05:29:17 <mcstar> some pointers pls? im new to the scene of scientific blogging
05:30:25 <mcstar> e.g. does wordpress provide these tools? or do i have to mess with the blog post much offline to make it palatable for wordpress?
05:30:35 <applicative> http://knowledgeblog.org/mathjax-latex-wordpress-plugin
05:31:05 <applicative> you may have to write something ridiculous with that plugin.
05:31:39 <mcstar> deja vu
05:31:48 <mcstar> a strong one
05:31:56 <mcstar> applicative: did you link this before?
05:32:37 <applicative> don't think so
05:33:01 <mcstar> well, thx
06:11:14 <OnceKnown> Hi
06:11:55 <OnceKnown> Does anyone know of a good alternative to The Algebra of Programming from Bird?
06:14:21 <rtharper> OnceKnown: for what purpose?
06:14:23 <rtharper> as in
06:14:28 <rtharper> what sort of material did you want to get out of it
06:15:36 <OnceKnown> As in, the book right now is very expensive, can't get a peek at it in my local libraries, and I enjoyed Pearl of Functional Algorithm design, but I sure need to learn more about equational reasoning in FP
06:15:41 <OnceKnown> :-)
06:18:23 <OnceKnown> rtharper: ideas?
06:18:47 <rtharper> Hrm, Introduction to Functional Programming has some of that
06:18:55 <rtharper> it's quite equational-reasoning heavy
06:19:02 <rtharper> but might be too basic, depending on what you're looking for
06:19:15 <OnceKnown> that one is too basic, yeah..
06:19:23 <rtharper> AoP is rather old, though=)
06:19:48 <OnceKnown> rtharper: anything similar to it but more recent?
06:20:17 <rtharper> not that I know of, I'm afraid
06:20:38 <OnceKnown> birds papers are quite advanced, though i still need a kind of "thread line" to guide me...
06:21:08 <rtharper> http://lambda-the-ultimate.org/node/1117
06:21:14 <rtharper> that might help you get some similar material?
06:22:07 <OnceKnown> yeah, known thread complaining about the same thing :)
06:23:00 <OnceKnown> thanks anyway...
06:25:04 <Brofessional> I have a question.
06:25:11 <Brofessional> Should the composition of two foldables
06:25:15 <Brofessional> be in itself another foldable?
06:25:24 <OnceKnown> Brofessional: depends
06:25:44 <OnceKnown> Brofessional: look at the universality of fold
06:25:57 <OnceKnown> fusion
06:26:07 <Brofessional> OnceKnown: What do you mean by the universality of fold?
06:26:14 <OnceKnown> paper
06:26:22 <Brofessional> Okay, let me google.
06:26:35 <OnceKnown> tutorial on the universality and expressiveness of fold
06:26:56 * hackagebot prof2pretty 0.1.0.0 - generate pretty source from time/allocation profiles  http://hackage.haskell.org/package/prof2pretty-0.1.0.0 (ClaudeHeilandAllen)
06:27:19 <OnceKnown> there ar some situations where you can fuse two folds...
06:27:56 <merijn> It's a pretty interesting (and relatively easy!) paper
06:28:34 <OnceKnown> merijn: a great paper actually :)
06:28:34 <Brofessional> What I want to know is if the composition of two fmaps (for different Foldable instances) can be considered another fmap.
06:28:52 <Brofessional> No, wait, I am not even making sense.
06:29:43 <merijn> I can recommend reading it even if it's not relevant to your question :p
06:29:54 <merijn> Unless you're allergic to/not interested in theory
06:30:25 <Brofessional> I am certainly not *allergic* to theory. Unfortunately I have no background in CS, but I can make an effort.
06:30:51 <merijn> Brofessional: A reasonable understanding of haskell's type system should be enough to get you through
06:30:57 <OnceKnown> Brofessional: easily readable, really
06:31:04 <hpaste> ksf pasted “Categorical Fold/Traversable” at http://hpaste.org/70630
06:31:18 <OnceKnown> seldom papers are so well written
06:31:19 <merijn> If you get function type signatures and recursion that's all you really need I think
06:31:38 <ksf> those two work fine sofar, but I'm lost on how to compose non-(->) argument functions so I can have a default implementation for mapM etc.
06:32:29 * ksf has the nasty feeling that it might not make much sense to ask before edwardk is here.
06:33:15 <merijn> There's no way to derive an IsString when newtyping String, I guess?
06:33:34 <merijn> (not that writing the instance is any effort, I'm just VERY lazy :p)
06:33:37 <ksf> unless with genericderiving, probably no.
06:33:58 <merijn> Ok, I'll just provide a manual instance then
06:34:23 <Brofessional> merijn, OnceKnown: Thank you!
06:34:36 * Brofessional promptly downloads a PDF viewer. :P
06:35:02 * ksf recommends okular
06:35:13 <ksf> one of the rare kde programs that are actually very good.
06:35:19 <ksf> (the other one is konsole)
06:35:54 <mcstar> ksf: ditto
06:36:46 <ksf> it's famous for not stalling programs that keep and keep on barfing things to it.
06:37:09 <ksf> by the simple, but sadly widely unimplemented trick of not displaying everything.
07:13:07 <kallisti> :)
07:22:57 <shirt> does Data.Foldable work on a 2D array?
07:28:33 <harrison> eep
07:31:54 <ksf> @hoogle unionWith
07:31:55 <lambdabot> Data.IntMap unionWith :: (a -> a -> a) -> IntMap a -> IntMap a -> IntMap a
07:31:55 <lambdabot> Data.Map unionWith :: Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a
07:31:55 <lambdabot> Data.IntMap unionWithKey :: (Key -> a -> a -> a) -> IntMap a -> IntMap a -> IntMap a
07:35:20 <applicative> > Data.Foldable.foldMap (Any . even ) $ listArray ((0,0),(5,5)) [1..]
07:35:23 <lambdabot>   Any {getAny = True}
07:35:54 <applicative> > Data.Foldable.foldMap (Any . (> 10) ) $ listArray ((0,0),(5,5)) [1..]
07:35:56 <lambdabot>   Any {getAny = True}
07:36:31 <applicative> shirt: ^^^  there is an instance for Data.Array
07:36:47 <DMcGill> it's located in Data.Foldable
07:38:22 <merijn> Is there a convenient way to take a [Foo] and keep only values of Foo that use a specified constructor?
07:38:25 <DMcGill> and the order of traversal is the order of the indicies
07:39:36 <DMcGill> > filter (\x -> case x of {Right _ -> True; _ -> False}) [Left "gone", Right "stay]
07:39:38 <lambdabot>   <no location info>:
07:39:38 <lambdabot>      lexical error in string/character literal at end o...
07:39:51 <DMcGill> > filter (\x -> case x of {Right _ -> True; _ -> False}) [Left "gone", Right "stay"]
07:39:52 <lambdabot>   [Right "stay"]
07:40:32 <DMcGill> but to do it automatically?
07:40:42 <DMcGill> TH is probably your best bet
07:49:22 <ssbr> Is there an operator like a backwards $? Like "x |> y" == "y x" ?
07:49:34 <illissius> merijn: [a | Foo a <- foos] ?
07:49:43 <mcstar> you just defined it ssbr
07:49:44 <illissius> though that also strips the constructor
07:49:55 <ssbr> mcstar: I just defined it, but does it already exist? :(
07:50:03 <ssbr> (obviously not by the name |> )
07:50:13 <mcstar>  brought up this before
07:50:17 <mcstar> and i dont remember
07:50:20 <illissius> @hoogle a -> (a -> b) -> b
07:50:20 <mcstar> i*
07:50:21 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
07:50:21 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
07:50:21 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
07:50:38 <mcstar> ssbr: i know i defined it for myself
07:50:51 <ssbr> illissius: Nice, I didn't know you could do that.
07:51:01 <ssbr> mcstar: what symbol do you use / is there a normal symbol to use?
07:51:10 <pooya72> just curious, how many people hear prefer to write in literate haskell compared to normal haskell?
07:51:12 <ssbr> ocaml users (sometimes) use |>
07:51:13 <mcstar> illissius: thats not the same operator
07:51:19 <kvasir> hi people
07:51:21 <Draconx> ssbr, you could call it `flip id` :P
07:51:57 <Draconx> er, that doesn't work.  Sad.
07:52:09 <illissius> ssbr: I've seen it proposed as ($.) iirc, to mimic dot-notation from OO languages
07:52:17 <illissius> I don't think I've seen it in a package before
07:53:40 <ssbr> @hoogle (a -> b) -> [a] -> [b]
07:53:40 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
07:53:40 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
07:53:41 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
07:53:54 <ssbr> This is amazing. Is there a way to use this without cluttering up #haskell ?
07:54:16 <mcstar> http://www.haskell.org/hoogle/
07:54:26 <ssbr> Thanks!
07:54:34 <illissius> that's the obvious one... you can also /msg lambdabot
07:54:44 <barrucadu> Also, cabal install hoogle
07:56:05 <illissius> I wonder how much time/space it would take to install all of Hackage (that compiles)...
07:56:06 <kallisti> wasn't there a CMS library uploaded to Hackage recently?
07:56:09 <kallisti> should probably update the wiki.
07:58:55 <stepcut> kallisti: clckwrks ?
07:59:10 <stepcut> kallisti: http://clckwrks.com/ ?
07:59:15 <kallisti> that's the one
08:02:02 * hackagebot phasechange 0.1 - Freezing, thawing, and copy elision  http://hackage.haskell.org/package/phasechange-0.1 (GaborLehel)
08:08:26 <Saizan> cool package name
08:09:46 <illissius> (danke)
08:14:32 <shirt> applicative, DMcGill: thanks. unfortunately there is no instance for UArray :(
08:15:33 <applicative> shirt: yes, I was thinking  it was a dubious instance anyway, since it converts to a list?
08:15:34 <DMcGill> well the defn for Array is `Prelude.foldr f z . elems'
08:16:38 <applicative> shirt: particularly dubious  for a UArray Id guess
08:16:42 <DMcGill> although I guess it wouldn't be that hard to write your own (using (!) if you don't want to convert to a list)
08:17:03 <mcstar> illissius: koszonom, you mean? :)
08:17:48 <merijn> @hoogle (a,b,c) -> c
08:17:48 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
08:17:48 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
08:18:46 <illissius> mcstar, good point
08:18:51 <illissius> german is a silly language
08:18:59 <DMcGill> merijn: if you want to do a general tuple-n then that's the classic TH example
08:19:01 * illissius >>= shower
08:21:41 <merijn> DMcGill: Nah, I really just need a convenient way to access a bunch of different datatypes in the State monad, so I might just write a state lens for my case or add a datatype instead
08:25:51 <applicative> shirt: repa has a zillion builtin folds, it would be surprising in uarrays dont have them somewhere
08:28:39 <applicative> shirt http://twanvl.nl/blog/haskell/four-ways-to-fold discusses 1D but makes interesting points about right v left etc
08:32:04 * hackagebot test-simple 0.1 - Simple Perl inspired testing  http://hackage.haskell.org/package/test-simple-0.1 (BorisSukholitko)
08:34:30 <Penetrator> @list
08:34:31 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
08:34:59 <Penetrator> @hoogle printf
08:34:59 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
08:34:59 <lambdabot> Text.Printf class PrintfArg a
08:34:59 <lambdabot> Text.Printf class PrintfType t
08:36:48 <DMcGill> printf is really weird, although I've never seen it's approach to a varied number of arguments used anywhere else
08:40:14 <jmcarthur> Taneb: i don't want Word3. i want (Word 3)
08:40:43 <Taneb> :)
08:48:49 <copumpkin> jmcarthur: we have that in agda!
08:50:07 <SimonJF> i need to make something which sends me some sort of shock every time I do a liftIO and put text in there, without writing putStrLn
08:50:15 <SimonJF> maybe then, I'd stop doing it <_<
08:55:29 <applicative> SimonJF: putStrLn is  a really ugly name any why not define:  write = liftIO . putStrLn or whatever
09:01:33 <SimonJF> applicative, that's a good idea, I should probably do that :P thanks
09:04:09 <jmcarthur> copumpkin: indeed :)
09:04:43 <Taneb> I'll insert Agda in my list of languages to learn
09:05:37 <Taneb> It's [Haskell, C, Java, Agda, Perl] now
09:06:20 <nand`> better hope learning Haskell isn't non-terminating
09:06:30 <Taneb> Unfortunately, it may be
09:06:39 <Taneb> :(
09:07:04 <shirt> applicative: interesting
09:07:11 <Taneb> In a year and a bit, Scala may be forcibly inserted just after Haskell
09:07:44 <nand`> I hear there's a Haskell-like language for the JVM
09:07:53 <nand`> I'm not too keen on learning Scala either
09:07:57 <shergill> applicative: i don't know about ugly, but it served a purpose. when i saw it for the first time i knew that it worked on strings and that it inserted a newline
09:31:29 <arbn> nand`: Frege.
09:35:34 <ksf> shergill, applicative, the moment I saw "putStrLn" I mentally put pascal into the list of ancestors of haskell
09:36:07 <ksf> the algol syntax did dispell the doubts.
09:36:51 <nand`> arbn: neat
09:37:06 * hackagebot xml-picklers 0.1 - XML picklers based on xml-types, ported from hexpat-pickle  http://hackage.haskell.org/package/xml-picklers-0.1 (PhilippBalzarek)
09:37:51 <MostAwesomeDude> So is it okay to use conduits yet? :3
09:39:02 <Philonous> MostAwesomeDude:  Why wouldn't it be?
09:39:56 <MostAwesomeDude> Philonous: The author still has it listed as a PoC and people seem to be split on whether it's Doin' It Right.
09:40:04 <MostAwesomeDude> A lot of people are also talking about pipes.
09:41:15 <Philonous> Didn't snoyberg reimplement them as pipes?
09:41:20 <applicative> conduits 0.5 is very pipified
09:41:25 * shapr boings cheerfully
09:41:33 <timthelion> @seen cheater_
09:41:34 <lambdabot> Unknown command, try @list
09:42:08 <MostAwesomeDude> No, I mean, the pipes package.
09:42:15 <shergill> applicative: it's evolving. but it seems to be converging
09:42:24 <shergill> regd conduit
09:44:00 <timthelion> Hm, why doesn't seen work, it's in the list of comands given by @list...
09:44:39 <applicative> @seen timthelion
09:44:40 <lambdabot> Unknown command, try @list
09:44:57 <applicative> oh what it need a prefix
09:45:41 <Philonous> MostAwesomeDude:  Nobody seems to be using pipes, yet. At least the reverse dependency search doesn't show it.
09:45:59 <ksf> preflex, seen cheater
09:45:59 <preflex>  cheater was last seen on #irssi 2 days, 7 hours, 32 minutes and 12 seconds ago, saying: oh just /bind. ok thanks :)
09:46:26 <timthelion> thanks
09:46:34 <MostAwesomeDude> Philonous: Yeah, sure, but I'm wondering about more practical usage. I got *real* hung up with iteratees last time, trying to get everything working.
09:46:38 <monochrom> usually, @list is outdated
09:46:44 <applicative> preflex timthelion right
09:47:01 <MostAwesomeDude> There's no good way, AFAICT, to have some sort of infinite state machine doing network traffic.
09:47:28 <ksf> "infinite" and state machine is almost always a horrendeously bad idea.
09:47:46 <monochrom> with unbounded network buffers, you don't need infinite-state machines :)
09:47:48 <ksf> if, then make your automaton more powerful.
09:47:51 <parcs`> anyone know how to send POST form data with http-conduit?
09:48:05 <MostAwesomeDude> ksf: Network protocols that work on an unbounded number of packets and send back an unbounded number of packets?
09:48:12 <parcs`> i am unfamiliar with how POST form data is sent at all via HTTP
09:48:16 <MostAwesomeDude> ksf: Say, a server for a multiplayer video game?
09:48:44 <ksf> that's not infinite states.
09:48:49 <ksf> that's infinite input.
09:49:03 <MostAwesomeDude> Oh, fine, I used the wrong words.
09:49:23 <timthelion> ksf: infinite paralel states, or infinite states in the same train of state?
09:50:12 <applicative> parcs`: It uses the types from http://hackage.haskell.org/packages/archive/http-types/0.3.0/doc/html/Network-HTTP-Types.html
09:50:13 <ksf> infinite states in general.
09:50:20 <MostAwesomeDude> ksf: Anyway, I'm just fine with runASingleClient :: Monad m => m [Packet] -> m [Packet] but apparently nobody's built a networking library that directly does this.
09:50:29 <ksf> it just blows away all theory known about automata.
09:51:15 <ksf> game networking is *complex*. well, not really complex, but specific.
09:51:41 <ksf> all game networking code I ever saw built directly on udp
09:52:11 <applicative> parcs`: oh heres a straightforward post example, in the docs,  http://hackage.haskell.org/packages/archive/http-conduit/1.4.1.10/doc/html/Network-HTTP-Conduit.html#t:Request
09:52:15 <MostAwesomeDude> Well, let's say that I'm not a masochist and also that I'm using TCP.
09:52:47 <parcs`> applicative: that example doesn't send any form data with the request
09:52:50 <ksf> well, two possibilities: you have no need for anything resembling realtime, or you never want to grow beyond LAN games.
09:52:54 <parcs`> it just does a post request
09:53:29 <applicative> parcs` no, you just have to fit the types together, i've done it ...
09:53:37 <applicative> oh wait
09:54:31 <MostAwesomeDude> ksf: I didn't design this protocol and have zero interest in arguing about its practicality. It's *known* to be unpractical, this is an experiment.
09:54:41 <cheater_> hi timthelion
09:54:53 <timthelion> cheater_: hi!
09:55:07 <timthelion> cheater_: Did you get my message?
09:55:14 <cheater_> i think so
09:55:23 <cheater_> you had some code you wanted to use right?
09:55:27 <timthelion> Yes.
09:55:45 <cheater_> what license do you want to release it under?
09:55:52 <timthelion> GPL 3.0.
09:56:00 <cheater_> ok, that's fine with me
09:56:06 <timthelion> thank you :)
10:02:34 <MostAwesomeDude> Clearly I just want Twisted for Haskell. :T
10:02:43 <zzing> Is there any way to move code from within a do block such as hasCache <- doesFileExist cachedFile    and put it in a where clause such that I can use it in an if expression inside the do block?
10:03:32 <mroman> zzing: where foo = do stuff <- bar; baz $ stuff ?
10:03:56 <mroman> zzing: Although if requires Bool
10:04:01 <mroman> and not IO Bool.
10:04:03 <MostAwesomeDude> :t when
10:04:04 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
10:04:09 <MostAwesomeDude> zzing: ^^ Does this help?
10:04:10 <mroman> which is...
10:04:17 <zzing> It is ultimately an IO Bool that I have to work with
10:04:24 <zzing> I am just trying to make my code look nicer
10:04:33 <mroman> then you have to use a helper function like when.
10:04:35 <zzing> MostAwesomeDude, only if it were whenIO :-)
10:04:47 <zzing> hmm
10:04:53 <zzing> @src when
10:04:54 <lambdabot> when p s = if p then s else return ()
10:05:09 <zzing> ok, I need more info about this when
10:05:52 <zzing> How might you use it with doesFileExist :: FilePath -> IO Bool   for example?
10:05:58 <MostAwesomeDude> zzing: What type do you need? IO Bool -> IO a -> IO a ?
10:05:58 <byorgey> zzing: the IfElse package may have some useful things for you  http://hackage.haskell.org/package/IfElse
10:06:31 <zzing> I am dealing with an IO Bool and I am proceeding to do more actions based on the result
10:06:34 <MostAwesomeDude> zzing: You can have if/else/then inside a monad, just draw from the IO Bool to get a Bool and then check it.
10:06:43 <zzing> ok, shall do
10:06:56 <zzing> When my code is done, i will show it for improvement
10:07:01 <MostAwesomeDude> do { a_bool <- yourBoolMakingFunction; if a_bool then ... else ... }
10:07:44 <byorgey> and of course you can easily make a helper function  ifM :: Monad m => m Bool -> m a -> m a -> m a  if it makes your code nicer
10:07:55 <mroman> http://codepad.org/JcbVXQiF
10:07:59 <mroman> ^- does that help?
10:08:27 <MostAwesomeDude> @hoogle Monad m => m Bool -> m a -> m a
10:08:28 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
10:08:28 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
10:08:28 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
10:08:36 <MostAwesomeDude> Er.
10:08:39 <MostAwesomeDude> @hoogle Monad m => m Bool -> m a -> m a -> m a
10:08:40 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
10:08:40 <lambdabot> Control.Exception.Base bracket_ :: IO a -> IO b -> IO c -> IO c
10:08:40 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
10:08:52 <zzing> mroman, that looks pretty close
10:20:00 <applicative> byorgey: the name of that combinator is 'miffy' http://www.haskell.org/pipermail/haskell-cafe/2009-May/060951.html
10:20:26 <Attic[0]> Hello! could someone explain or send me a link about why you define the procedure of a function? (e.g. myFunction :: [a] -> Int) for converting an array to an Int?
10:20:44 <applicative> "Remember folks: Missiles need miffy! "
10:21:03 <MostAwesomeDude> Attic[0]: "Procedure?" You mean, the type?
10:21:07 <applicative> Attic[0]: you mean converting a list  to an int?
10:21:17 <Attic[0]> Yeah, that's what i meant
10:21:24 <hpaste> mel pasted “compile error” at http://hpaste.org/70632
10:21:31 <applicative> what relation do you want the into bear to the array or the list?
10:21:42 <mel-> Hi. I have a problem. my first (!) haskell programs works fine on my first system (freebsd 9), it compiles fine with ghc. but i copied it onto a debian stable system and there it fails to compile. the message is http://hpaste.org/70632
10:21:49 <applicative> @type length
10:21:50 <lambdabot> forall a. [a] -> Int
10:21:54 <MostAwesomeDude> Attic[0]: The reason for providing the type is largely for readability.
10:22:28 <applicative> mel-: what happens if you add "import Control.Monad.Instances"
10:22:33 <Attic[0]> MostAwesomeDude: Is there no other reason for it?
10:23:11 <mel-> applicative: i have that already
10:23:19 <applicative> oh I see, Attic[0] wants to know why we add type signatures
10:23:20 <MostAwesomeDude> Attic[0]: Sometimes types need to be clarified.
10:24:15 <Attic[0]> Yeah, next to readability I'm not sure what they're for
10:24:30 <strager> mel-: What's the GHC version on each box?
10:24:33 <MostAwesomeDude> Sometimes you want a more specific type than would otherwise be inferred.
10:24:40 <strager> $ ghc --version
10:24:48 <applicative> Attic[0]: for basic 'haskell98' they are in theory never necessary
10:25:04 <MostAwesomeDude> Attic[0]: Don't discount readability, BTW.
10:25:16 <Attic[0]> MostAwesomeDude: I would never.
10:25:37 <applicative> Attic[0]: but you can also restrict the inferred signature. This can for example give information for optimization
10:26:15 <Attic[0]> ahh
10:26:23 <applicative> Attic[0]: for integer literals, you should instruct the compiler you want Int if it's machine numbers you want for example
10:26:35 <Attic[0]> If you define the type, if the function doesn't output what you want it'll show an error?
10:26:48 <applicative> > maxBound :: Int
10:26:49 <lambdabot>   9223372036854775807
10:26:53 <Attic[0]> So I guess it's more type safe?
10:27:00 <mel-> strager: it's 7.0.4 on the system where the code compiles and 6.12.1 on the other one.
10:27:04 <applicative> Attic[0]: oh yes
10:27:24 <strager> mel-: Pick up a Haskell Platform from 2012
10:27:28 <strager> e.g. the latest
10:27:30 <applicative> Attic[0]: yes, the dimmer among us use the typechecker to instruct us what to write next :)
10:27:47 <mel-> strager: mhhh, thanks.
10:27:53 * applicative cant wait for -XHoles 
10:28:08 <mel-> strager: instead i might look into cross compiling the program. seems simpler to me. :)
10:28:24 <Attic[0]> applicative: What do you mean with typechecker?
10:28:30 <SimonJF> -XHoles is the one SPJ was talking about in the latest digest of ghc-users?
10:28:42 <applicative> it's what complains when you write 'a' + 2
10:28:45 <strager> mel-: =]  If it's the same arch, the default binary produced by GHC is portable (as it's statically linked).
10:29:12 <Attic[0]> Oh ok, that makes sense :)
10:29:22 <Attic[0]> Ok then I know more than enough! Thanks!
10:29:27 <mel-> strager: thanks
10:29:32 <applicative> oh was he SimonJF  .  I just read a wiki page.  It is  of a piece with the extension that gets rid of typechecking
10:29:48 <applicative> I tried that one :(
10:30:03 <SimonJF> maybe something different
10:30:21 <SimonJF> which was the wiki page, if you have it handy?
10:30:22 <nand`> Does GHC support MIPS?
10:30:30 <nand`> Or is there any Haskell compiler that does?
10:30:42 <SimonJF> i think so, there was a port of it
10:31:37 <sm> strager, mel: for some value of "statically". Not 100%
10:32:13 <SimonJF> http://hackage.haskell.org/trac/ghc/wiki/Platforms --- there's mips on there
10:33:00 <strager> sm: Certainly =]  For basic programs I'm sure it won't be problematic
10:34:09 <nand`> SimonJF: interesting. “GHCi: No” :(
10:34:45 <nand`> the platform I am interesting in particular is the Lemote Yeeloong, running a Loongson 2F MIPS processor; I would need to be able to use GHCi 7.4.2
10:35:03 <applicative> SimonJF:   http://hackage.haskell.org/trac/ghc/wiki/Holes  http://hackage.haskell.org/trac/ghc/wiki/DeferErrorsToRuntime
10:36:26 <applicative> SimonJF: I had a version of ghc -head that accepted  -fdefer-type-errors but  the one i have now seems not to. Maybe the changed the name or removed it
10:36:58 <SimonJF> thanks for the link, looks like it fits very much in with a research project i'm helping with
10:38:08 <SimonJF> also, nand`, are you doing embedded systems programming?
10:39:33 <SimonJF> alright i'd better go, bye all
10:40:14 <nand`> @tell SimonJF No, I'm just interested in the Yeeloong netbook
10:40:14 <lambdabot> Consider it noted.
10:45:24 <shapr> Is there a list of most common datatypes by popularity?
10:45:25 <roconnor_> do type synonymes need to be eta-expanded?
10:45:53 <shapr> Like, Data.Map, etc? I'm trying to think of what datatypes would benefit most from having rich HTML display types in my ghclive GSoC project.
10:46:18 <roconnor_> shapr: ContT
10:46:30 <shapr> roconnor_: eta expansion hurt my head when I was a newbie, but is actually easier now, so consider your audience :-)
10:46:43 <shapr> roconnor_: You come up with that Display instance, I'll put it in :-P
10:46:52 <cheater_> timthelion: cool yw :)
10:47:17 <roconnor_> oh wait, I can't really eta contract this even if I wanted.
10:47:34 <ksf> does anyone know of a haskell AST that lets me generate comments?
10:48:48 <shapr> ksf: HaRe must have such a thing, right?
10:48:59 <shapr> refactoring requires keeping track of comments in an AST.
10:49:22 <ksf> yes... but then hare is as incompatible as it gets.
10:49:36 <ksf> I'm fine with generating haskell98, though, I think.
10:49:43 <ksf> at least for the parts where I need comments.
10:51:35 <cocon> hi! i'm trying to build ghc 7.4.1 from source and get:
10:51:35 <cocon> Configuring integer-gmp-0.4.0.0...
10:51:35 <cocon> make[1]: *** [libraries/integer-gmp/dist-install/package-data.mk]
10:51:35 <cocon> Error 127
10:51:38 <cocon> make: *** [all] Error 2
10:51:41 <cocon>  
10:52:10 <ksf> ...and the whole thing isn't on hackage.
10:53:44 <monochrom> you need libgmp3-dev (if ubuntu) or something
10:57:24 <ksf> this source is a *mess*.
10:57:39 <ksf> a gazillion directories, each containing non-hierarchical modules.
10:57:47 <monochrom> haha
10:58:05 <applicative> monochrom: do you need to direct  ./configure to which libgmp to use then?
10:58:50 <monochrom> I believe not. I just had "./configure --prefix=what_I_wanted" last time I built ghc
10:59:17 <monochrom> libgmp3-dev counts as "can be found in standard places" afterall
11:09:35 <cocon> I believe gmp is installed, i.e. /usr/include/gmp.h /usr/lib/libgmp.so.3 exist (this is on Gentoo)
11:11:33 <ksf> argh. forget it. I'm not going to use an ast.
11:11:51 <ksf> ...I'm just going to pretty print my own ast into haskell.
11:14:23 <applicative> monochrom, oh thanks
11:36:29 <ben> so wyh does the list of instances of a given class not link to the instance declarations in haddock?
11:36:30 <ben> :|
11:36:51 <hiptobecubic> you haven't patched it yet i guess
11:37:59 <ksf> while you're at it, write the haskell ast to rule them all.
11:40:34 <palmfrond> abstract syntax tree?
11:42:05 <ksf> yep.
11:42:39 <ksf> one that both compilers, refactorers and code generators like.
11:50:10 <spree> does hpaste only send to #haskell? it seems it doesnt send to python. oh bc of authentication ofc!
11:51:24 <ksf> edwardk!
11:51:29 <ksf> http://hpaste.org/70630
11:51:42 <ksf> those are bloody useful.
11:51:53 <edwardk> ?
11:51:56 <ksf> (though the given instance is rather trivial)
11:52:08 <ksf> foldable/traversable in the spirit of categorical.functor
11:52:15 <edwardk> eep
11:52:16 <edwardk> =)
11:52:18 <nobdraisentone> Suppose I have many process that I wanna run in parallel with forkIO. It is how I could do it manually: http://pastebin.com/raw.php?i=3E7tRGBt  . How can I do it for list of arguments like [first, second ... last]?
11:52:23 <mauke> The paste 3E7tRGBt has been copied to http://hpaste.org/70638
11:52:43 <edwardk> i'd be happier with more Category instance constraints sprinkled throughout
11:52:52 <ksf> they work just fine, but I'm lost on how to combine non-(->) arguments to have default implementations for mapM etc.
11:53:04 <edwardk> also the Monoid involved may change meaning in other categories
11:53:25 <edwardk> which is a large part of why they arent in categories
11:53:29 <ksf> well, foldMap isn't the only primitive fold.
11:54:22 <monochrom> mapM_ (forkIO . process) [first, second, ...]
11:54:36 <hpaste> ksf annotated “Categorical Fold/Traversable” with “Categorical Fold/Traversable (annotation)” at http://hpaste.org/70630#a70639
11:54:45 <edwardk> also you should be able to make Foldable f r t | f r -> t, f t -> r and  instance (Functor f r t, Foldable f r t) => Traversable f r t | f r -> t, f t -> r
11:54:53 <ksf> that module was ~200 lines longer before.
11:55:01 <ksf> (or would have been if I had'nt been lazy enough)
11:55:33 <edwardk> PureHyloF = Kleisli no?
11:55:40 <ksf> I took a guess.
11:55:51 <byorgey> does anyone know if Network.HTML.simpleHTTP might result in a prematurely closed connection in the case of a large POST request?
11:56:06 <hpaste> ksf annotated “Categorical Fold/Traversable” with “Categorical Fold/Traversable (annotation) (annotation)” at http://hpaste.org/70630#a70640
11:56:12 <ksf> that's the corresponding types.
11:56:20 <byorgey> I am using haxr to upload images via XML-RPC, and it works with small images, but with large ones I get "user error (ErrorClosed)"
11:56:53 <edwardk> i see your descent into madness is complete
11:56:55 <edwardk> ;)
11:57:19 <ksf> I wouldn't have survived those instances with any other editor :)
11:58:58 <ksf> case in point, though, I added another data family quite late, and it was a 2-3 minute thing.
11:59:17 <ksf> would've been less without all that explicit pattern matching.
12:00:31 <ksf> ohoh, I have no idea whatsoever what to use that stuff for except generalised N-Functors/Foldables/Traversables.
12:02:48 <ksf> edwardk, ideally I'd like to implement only traversable.
12:03:02 <ksf> ...or even derive it, when TH has enough access to data families.
12:03:19 <edwardk> ksf: well just like with Traversable in Haskell you should be able to make Foldable have a foldMapDefault defined using Traversable
12:03:27 <edwardk> its just a matter of setting up the appropriate Functor
12:03:35 <edwardk> er Applicative
12:03:38 <ksf> ...and then a generic deriving clause.
12:03:57 <ksf> and *that's* where I noticed that my category-foo is nonexistant.
12:06:49 <spree> Methods (10):
12:06:49 <spree>             GetAllProjects(xs:string key, )
12:06:49 <spree>             GetAllSystems(xs:string key, )
12:06:54 <spree> anyone know soap?
12:07:30 <MostAwesomeDude> spree: I'm confused. Why are you doing this in both #python and #haskell?
12:09:56 <parcs`> i use soap every week
12:13:00 <zzing> When I have a do    x <- y;  z <-j; …    is it still done lazily?
12:13:17 <parcs`> is what done lazily?
12:13:18 <spree> #haskell is smarter than python
12:13:30 <MostAwesomeDude> spree: Uh-*huh*.
12:13:51 <parcs`> please don't PM me
12:14:08 <zzing> who pms you
12:14:18 <spree> the devil
12:14:51 <zzing> Say for example I do,   fileExists <- doesFileExist markdownFile;  cacheExists <- doesFileExist cachedFile;    doAction fileExists cacheExists       where doAction is setup that if fileExists is false, it doesn't use the cacheExists. Will the cacheExists still be performed?
12:15:38 <copumpkin> yes
12:15:49 <zzing> Is there a way I can set it up so it won't be?
12:16:31 <copumpkin> make the control flow more explicit
12:16:40 <copumpkin> we don't generally like effects happening lazy
12:16:41 <hiptobecubic> Is anyone working with vim2hs?
12:16:42 <copumpkin> lazily
12:17:02 <hiptobecubic> it looks like it might actually be good, although I'm having trouble accepting that.
12:17:24 <zzing> I noticed that my function here can be expressed very simply in a boolean table with a lot don't cares in it, with that laziness would go well
12:17:39 <zzing> I am almost done, so I can show off the code in a moment for suggestions
12:27:11 * hackagebot yesod-test 0.2.1 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-0.2.1 (MichaelSnoyman)
12:28:35 <t7> dubstep intro to google IO... oh my days
12:29:01 <Nimatek> That was just the janitor vacuuming the stage.
12:32:13 * hackagebot json2yaml 0.3.2 - Utility to convert a file from JSON to YAML format.  http://hackage.haskell.org/package/json2yaml-0.3.2 (MichaelSnoyman)
12:32:15 * hackagebot notcpp 0.1.0.1 - Avoiding the C preprocessor via cunning use of Template Haskell  http://hackage.haskell.org/package/notcpp-0.1.0.1 (BenMillwood)
12:32:36 <MostAwesomeDude> Huh, conduits are easy. Curious.
12:32:37 <hpaste> zzing pasted “markDown cacher” at http://hpaste.org/70643
12:32:56 <zzing> What might be a better way to deal with lines 46 to 50?
12:33:15 <zzing> Where there are dependencies that I just want to not be evaluated unless the previous succeeds
12:37:12 * hackagebot yesod-platform 1.0.5 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.0.5 (MichaelSnoyman)
12:39:56 <Cale> zzing: What do you want to happen when one of the operations fails?
12:39:56 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:41:18 <zzing> Cale, a false value should work. Because it is really a don't care scenario, it just can't be true :-)
12:41:27 <zzing> ok, that was worded badly
12:41:54 <Cale> Well, this function is supposed to produce an IO String, right?
12:42:01 <zzing> yes
12:43:03 <Cale> So you can either throw an exception (which is what will happen anyway if the file doesn't exist), or you could use Maybe or Either String
12:44:31 <zzing> I haven't done much yet with exceptions
12:44:38 <Cale> The difference between those options is mainly in how you intend to handle the exceptional case.
12:44:52 <Cale> If you use IO exceptions, you obviously have to catch them in IO
12:44:54 <spree> is REST making SOAP obsolete?
12:45:05 <Cale> spree: Is this a Haskell question? :)
12:45:09 <MostAwesomeDude> spree: What.
12:45:23 <Cale> REST is just a buzzword for HTTP
12:45:31 <Cale> as far as I can tell
12:45:57 <zzing> I really just want the exceptional case to be treated as false i think as the easiest way to deal with it, but it really don't matter what the value is, it just as to have a value because it is Bool
12:46:05 <zzing> Adding Maybe I think is a little too much
12:46:34 <zzing> Would it make sense for me to change readDocument to take IO Bool and just stick in (IO True) or (IO False) in the right spot to get laziness?
12:46:36 <Cale> Oh, I see
12:47:03 <Cale> you want the value in place of  cacheTime < fileTime  to be false
12:47:13 * hackagebot hdm 0.0 - a small display manager.  http://hackage.haskell.org/package/hdm-0.0 (TimothyHobbs)
12:48:13 <Cale> It doesn't really make sense to give readDocument the IO Bool
12:49:12 <zzing> Cale, I think that would essentially be correct
12:49:37 <parcs`> you can use unsafeInterleaveIO or you can combine readDocument and readDocumentCache
12:50:52 <Cale> I guess you could do stuff like that. I think it makes more sense in this case just to write the logic down for when to run each action.
12:52:55 <Cale> You might be able to write some combinators to make that easier to do...
12:52:57 <shapr> Is there an irc channel for blaze?
12:53:19 <Cale> (<&&>) :: IO Bool -> IO Bool -> IO Bool
12:53:29 <shapr> jaspervdj: Is there an irc channel specifically for Blaze?
12:54:04 <Cale> x <&&> y = do b <- x; if b then y else return False
12:54:41 <zzing> The documentation for whenM says "A if with no else for unit returning thunks."   I am not sure what this talking about.
12:55:03 <mroman> () is unit.
12:55:05 <Cale> What, thunks?
12:55:12 <zzing> :t whenM
12:55:13 <lambdabot> Not in scope: `whenM'
12:55:16 <Cale> Where is this documentation?
12:55:20 <zzing> http://hackage.haskell.org/packages/archive/IfElse/0.85/doc/html/src/Control-Monad-IfElse.html#whenM
12:55:25 <zzing> first function
12:55:44 <zzing> I don't know if it is supposed to be talking about 'A' or if 'A' should be 'An'
12:55:55 <mroman> Probably An
12:56:05 <mroman> The point is, that action must return m ()
12:56:13 <mroman> and () is called the unit type afaik.
12:56:24 <mroman> so
12:56:30 <ksf> zzing, "An".
12:56:34 <ksf> there's a vowel.
12:56:36 <Cale> That comment is less helpful than just reading the code
12:56:37 <Cale> :P
12:56:39 <mroman> whenM (return True) (getLine) is NOT valid.
12:56:47 <mroman> because getLine is not m()
12:56:51 <Cale> Also, nothing here has anything to do with thunks
12:56:52 <parcs`> is it possible to make applicative combinators that "preserve" the laziness of the function being lifted?
12:56:55 <Cale> So just ignore that
12:57:02 <Cale> I think they meant to say actions
12:57:04 <zzing> I can decode do better than >>= right now :-)
12:57:11 <mroman> I think he should have said functions ;)
12:57:24 <mroman> zzing: its
12:57:25 <Cale> do t <- test; if t then action else return ()
12:57:37 <mroman> see cale. He's too fast for me :)
12:57:37 <Cale> mroman: surely not functions.
12:57:50 <mroman> Why not?
12:57:59 <Cale> Because there are no function parameters here
12:58:18 <Cale> A value of type m () is not a function
12:58:31 <daniel_-> does haskell have a equivalent for pythons subprocess.Popen where you can start processes and pipe the stdout, stdin and stderr as you choose?
12:58:34 <Cale> Except in the special case of the function monad
12:59:00 <Cale> daniel_-: See System.Process
12:59:10 <daniel_-> thanks, will look into it
12:59:16 <Expez> http://hpaste.org/70646 <- Why does this never terminate?
12:59:21 <mroman> I'm not sure if it allows you to actually pipe it at will.
12:59:41 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/process-1.1.0.1/System-Process.html
12:59:42 <mroman> but System.Process has functions to capture stdout, stderr.
13:00:29 <Cale> You can do whatever you like with them
13:00:32 <sirtophat> yes is " B C D". 'A':yes shows "A B C D" as expected but 'no':yes gets Syntax error on 'no'\nPerhaps you intended to use -XTemplateHaskell
13:00:36 <zzing> Expez, if you perform induction on the second parameter, you should see it
13:00:43 <sirtophat> is something special about 'no'
13:01:05 <Expez> zzing: Is the where clause only evaluated once?
13:01:12 <Cale> For each of the handles, you can tell the process to inherit it from the parent, to use a supplied Handle, or to create a new pipe.
13:01:16 <zzing> Expez, your n parameter is never reducing
13:01:41 <Cale> sirtophat: 'no' isn't a Char
13:01:47 <zzing> Also, you have no ending condition
13:01:50 <Expez> zzing: it's not supposed to. The function is supposed to drop every nth item.
13:03:07 <zzing> Expez, in that case, Expez, add a condition for xs to be []
13:03:49 <zzing> :t take
13:03:51 <lambdabot> forall a. Int -> [a] -> [a]
13:04:01 <zzing> @src take
13:04:01 <lambdabot> take n _      | n <= 0 =  []
13:04:01 <lambdabot> take _ []              =  []
13:04:01 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
13:04:05 <Cale> sirtophat: There's an extension which allows things starting with ' and which wouldn't otherwise be valid Char values to be used as quoted versions of names for metaprogramming.
13:04:18 <Cale> oh, he left
13:04:31 <Cale> :(
13:04:35 <zzing> Expez, I expect that what your thing is doing is just operating on empty lists ad infinitum
13:05:16 <Expez> zzing: I added dropEvery [] n = [] and it still printed "aaaaa..." when I try to evaluate dropEvery "abcdef" 4
13:05:36 <zzing> I will take a closer look at it
13:06:58 <zzing> Just add dropEvery [] _ = []   as the second line and it will work
13:07:28 <zzing> dropEvery "abcdef" 4  >> "abcef"
13:08:42 <Expez> zzing: When I try to run the test case in HUnit it says expected "abcef" but got "aaaaaaaaaaaaaaaaaaaa" and off it goes endlessly.
13:09:09 <Peaker> > let dropEvery n k = concatMap (drop k) . takeWhile (not . null) . iterate (drop n) in dropEvery 4 1 "abcdef"
13:09:11 <lambdabot>   "bcdeff"
13:09:19 <morel> Expez: also take a look at splitAt, btw.
13:09:22 <coppro> !hoogle Functor f => f a -> (a -> b) -> f b
13:09:27 <coppro> @hoogle Functor f => f a -> (a -> b) -> f b
13:09:28 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
13:09:28 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
13:09:28 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
13:09:41 <Expez> zzing: It works fine when I load it in ghci. Super weird. Thanks for your help though!
13:09:54 <Expez> morel: thansk for the tip :)
13:10:16 <coppro> hoogle, you are terrible
13:10:46 <morel> coppro: did you try the webinterface http://www.haskell.org/hoogle/ ?  did you try hayoo?
13:11:26 <zzing> Expez, welcome :-). This is the type of thing they would ask us to do in my Miranda class
13:11:30 <zzing> @src splitAt
13:11:31 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
13:12:00 <zzing> Miranda is one amazing language!
13:12:14 * hackagebot wizards 1.0 - High level, generic library for interrogative user interfaces  http://hackage.haskell.org/package/wizards-1.0 (LiamOConnorDavis)
13:13:51 <Expez> zzing: Looks a lot like Haskell, judging by the wikipedia page
13:15:01 <zzing> Expez, Miranda could have been Haskell once upon a time
13:15:06 <morel> yea, haskell was especially syntactically hardly influenced by miranda, afaik. but miranda doesn't have monads, right?
13:15:31 <mroman> Monads are not just Haskell.
13:15:38 <zzing> morel, no, it is basically useless truth be told :-)
13:15:43 <morel> mroman: did i say so?
13:15:56 <zzing> The one thing that it is very good at is teaching functional programming
13:16:06 <ptrf> hmm, so I'm working on the exercises from typeclassopedia again. and I'm a bit in doubt about specifying bind for the data Free f a = Var a | Node (f (Free f a))
13:16:09 <zzing> But its errors are too light on details, just like ghc sometimes gives too much
13:16:35 <ptrf> i have instance Functor f => Monad (Free f) where return x = Var x
13:16:37 <mroman> morel: No. I just flinched at "$Language has no monads"
13:17:06 <ptrf> and the trivial part of bind, (Var a) >>= g = g a
13:17:11 <copumpkin> yeah
13:17:21 <copumpkin> now what can you do with the (f (Free f a)) you get in Node?
13:17:27 <ptrf> but I don't really know how to do it for Node (f x) or Node f
13:17:28 <copumpkin> there aren't many things to do with an f
13:17:34 <Saizan> don't make yourself look like a bot by writing non-contextualized remarks :)
13:17:35 <ptrf> well
13:17:50 <ptrf> my guess is you need something like fmap
13:17:59 <copumpkin> yep, only thing you can do with an f of something
13:18:02 <copumpkin> if you don't know what f is
13:18:05 <ptrf> yes
13:18:15 <copumpkin> so what type do you need to pass into fmap?
13:18:24 <ptrf> oh
13:18:38 <ptrf> it takes a pure function and lifts it to the functor context
13:18:59 <coppro> morel: what I want is <$$>
13:19:10 <coppro> @hoogle (<$$>)
13:19:10 <lambdabot> Text.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
13:19:10 <lambdabot> Text.ParserCombinators.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
13:19:16 <copumpkin> ptrf: so you have your function g of type (a -> Free f b), right?
13:19:19 <coppro> except both of those are wrong :P
13:19:22 <ptrf> yes copumpkin
13:19:23 <copumpkin> ptrf: and you have an (f (Free f a))
13:19:53 <ptrf> yes
13:19:55 <morel> coppro: why not use (flip fmap)?
13:20:04 <ptrf> copumpkin: give me a sec
13:20:09 <coppro> morel: not infix
13:20:10 <ptrf> i'll try to use your reasoning
13:20:14 <copumpkin> okay :)
13:20:25 <copumpkin> ptrf: you'll find that you don't have many options, if you follow the types carefully
13:20:28 <coppro> morel: I'm used to monadic binds is all; <$> is fine
13:20:29 <morel> coppro: define (<$$>) = flip fmap :P
13:20:33 <coppro> morel: lazy
13:20:35 <coppro> :P
13:20:37 <morel> :)
13:20:54 <coppro> (really, >>= is the backwards one)
13:21:21 <coppro> it ought to be <<=
13:23:30 <ptrf> copumpkin: Node (M (Free f a)) -> (a -> Node (M (Free f b))) -> Node (M (Free f b))
13:23:50 <ptrf> I tried to type it out
13:23:57 <copumpkin> your big M is just f
13:24:01 <ptrf> yes
13:24:03 <copumpkin> and the notation is a little wonky
13:24:08 <ptrf> yeah
13:24:08 <copumpkin> how about this
13:24:28 <copumpkin> let's assume that you're gonna spit out a Node if you get a Node into your bind
13:24:30 <copumpkin> alright?
13:24:41 <ptrf> yes
13:24:52 <ptrf> I mean, I assume that that's what g would do
13:25:02 <copumpkin> okay
13:25:31 <copumpkin> so you have (f (Free f a)) and (a -> Free f b), and you need (f (Free f b)), and we've established that you want to use fmap
13:26:07 <copumpkin> so you have (f (Free f a)) and need to get to (f (Free f b)) and are using fmap, so the function you pass to fmap needs to be (Free f a -> Free f b), right?
13:26:15 <moebius_eye> Anyone up for a OpenArena game?
13:26:16 <ahf> fedt nok mand
13:26:32 <apfelmus> edwardk: ping
13:26:32 <ptrf> copumpkin: yes
13:26:50 <zzing> :t liftM2
13:26:51 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:27:06 <copumpkin> ptrf: okay, so now your goal is (Free f a -> Free f b) and you have (a -> Free f b)
13:27:09 <copumpkin> ptrf: does that look familiar?
13:27:29 <copumpkin> to put it differently, let's say you have Free f a and (a -> Free f b), and you want Free f b
13:27:36 <copumpkin> (which is what you have)
13:27:41 <zzing> Do we have an if that is like in logic, such that if p then q  only return true if p and q?  It is essential that it short circuits so that if p is false, it just returns false
13:28:08 <ptrf> copumpkin: I need to reboot my brain, just a minute
13:28:18 <copumpkin> okay :)
13:32:26 <zzing> Is there a function that can take something like    a -> a -> Bool   and turn it into m a -> m a -> Bool or m a -> m a -> m Bool?
13:32:50 <jedai|2> zzing: liftM2
13:32:56 <jedai|2> @type liftM2
13:32:57 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:33:16 <barrucadu> @src liftM2
13:33:17 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
13:34:16 <zzing> So then I should be able to do something like   liftM2 (<) cacheTime fileTime
13:34:49 <ion> liftA2 preferably
13:35:01 <zzing> :t liftA2
13:35:02 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
13:35:09 <zzing> ion, why
13:35:24 <copumpkin> zzing: do as much as possible with as little as possible
13:35:27 <ion> More types can implement Applicative.
13:35:39 <ion> liftM2 shouldn’t exist, it’s a historical accident.
13:35:55 <zzing> copumpkin, what does that actually mean?
13:36:04 <zzing> ion, same way I feel about map vs fmap
13:36:08 <jedai|2> ion: That doesn't import much for his case, he obviously need IO
13:36:21 <copumpkin> zzing: you don't need the full power of monad to implement liftM2, so liftA2 only needs Applicative
13:37:01 <ion> jedai: One can always strive for elegant code.
13:38:19 <MostAwesomeDude> Hm.
13:39:29 <MostAwesomeDude> So, let's say I've got a function [Packet] -> [Packet]. Inside that function, I'm gonna have some stateful adventures, and I want to consume Packets one at a time, outputting Packets as I go in a highly stateful manner. What's the best monad to do this kind of work? ST?
13:39:45 <noteventime> Is there some good way to get a lazy string from a TChan?
13:39:54 <coppro> my code is horrible :(
13:41:07 <noteventime> Err, I mean a lazy list, obviously
13:43:41 <zzing> Is there any reason why I would get a openFile: resource busy (file is locked)  when I haven't opened it before now?
13:44:11 <monochrom> some other program is holding it
13:44:30 <zzing> monochrom, I can run it through less just fine
13:45:02 <noteventime> zzing: Have you never opened it before (in the program lifetime)?
13:45:07 <noteventime> Otherwise it could be a lazyness issue
13:45:28 <zzing> There is only one place I read it in
13:45:38 <hpaste> zzing pasted “web1.hs part 2” at http://hpaste.org/70647
13:45:46 <zzing> line 29
13:46:52 <shapr> Wow, nice list of sponsors: http://icfpconference.org/icfp2012/
13:48:24 <yazz> i am getting a compile error (infinite type). can someone help? http://pastebin.com/zJXYTFHQ
13:48:26 <mauke> The paste zJXYTFHQ has been copied to http://hpaste.org/70648
13:49:15 <monochrom> badNeighbors l = findNeighbors l. don't use [l]
13:49:23 <mauke> what
13:49:25 <monochrom> err, wait, no
13:49:35 <yazz> i want it to match against a list with one member
13:49:43 <mauke> (findNeighbors l) :
13:49:48 <monochrom> badNeighbors (l:ls) = (findNeighbors [l]) : (badNeighbors ls)
13:49:57 <monochrom> sorry, no
13:50:05 <mauke> ++
13:50:31 <Taneb> mauke, are you an android account?
13:50:38 <Taneb> That is, partially a bot, partially human
13:50:42 <mauke> equation 1 should be badNeighbors [] = []
13:50:46 <mauke> Taneb: cyborg
13:50:57 <Taneb> That's the one
13:51:01 <yazz> change to ++ made it compile. why?
13:51:06 <mauke> :t (:)
13:51:07 <Taneb> I'm not having a good evening
13:51:08 <lambdabot> forall a. a -> [a] -> [a]
13:51:12 <mauke> :t (Prelude.++)
13:51:13 <lambdabot> forall a. [a] -> [a] -> [a]
13:51:21 <mroman> findNeighbors returns [a]
13:51:23 <Adeon> @hoogle the
13:51:23 <lambdabot> GHC.Exts the :: Eq a => [a] -> a
13:51:23 <lambdabot> Text.XHtml.Strict thead :: Html -> Html
13:51:24 <lambdabot> Text.XHtml.Frameset thead :: Html -> Html
13:51:32 <Taneb> I referred to the landscape gardener Cakeability Brown
13:51:39 <mauke> badNeighbors = concatMap findNeighbors
13:51:51 <noteventime> zzing: Isn't that problem that you write to the same file?
13:52:02 <noteventime> i.e. readFile then writeFile
13:52:04 <mroman> and : is not happy with with lists as its first argument.
13:52:05 <morel> Adeon: you can also /msg lambdabot, btw.
13:52:18 <zzing> noteventime, nice catch, wrong function call
13:52:21 <noteventime> zzing: Trying opening it and use hGetContents instead
13:52:35 <mroman> ok... scratch that.
13:52:36 <noteventime> Though that could lead to issues too
13:52:47 <mroman> or rephrase it :)
13:52:51 <zzing> there that works
13:53:19 <zzing> Is it possible that I should be using bytestrings or something like it? I do need performance, but I am pumping things through pandoc and heist
13:53:27 <zzing> and I need UTF8
13:53:43 <yazz> thanks for the help
13:54:13 <applicative> noteventime:  let x = let b = newTChan :: STM (TChan [Int]) in b  >>= \chan -> writeTChan chan [1..] >> readTChan chan  -- I can't believe that's rational....
13:54:43 <applicative> noteventime:  but somehow it works ...
13:58:15 <noteventime> applicative: Thanks, give me a sec to understand it :)
13:58:46 <applicative> noteventime: i was just amusing myself with the 'lazy list in a TChan question'
13:59:07 <noteventime> applicative: Oh, that's not quite what I meant though
13:59:32 <noteventime> What I need is to create a (lazy) [a] from a TChan a
13:59:33 <applicative> noteventime: yes, i wasn't sure what you meant,  I was trying to think
13:59:36 <noteventime> (if possible)
13:59:57 <noteventime> I don't actually need it, but it would make this code nicer
14:13:26 <noteventime> applicative: Something like sequence . repeat wouldn't work (due to strictness) or am I wrong?
14:13:47 <Peaker> > sequence . repeat Nothing
14:13:48 <lambdabot>   Couldn't match expected type `[m a]'
14:13:48 <lambdabot>         against inferred type `Data.Ma...
14:13:58 <Peaker> > (sequence . repeat) Nothing
14:14:00 <lambdabot>   Nothing
14:14:46 <Nereid> > (sequence . repeat) (Nothing :: Maybe ())
14:14:48 <lambdabot>   Nothing
14:14:59 <Nereid> > (sequence . repeat) (Just ())
14:15:01 <Peaker> I can't think of a non-trivial monad where (sequence . repeat) is a total function though
14:15:02 <lambdabot>   *Exception: stack overflow
14:15:24 <noteventime> Hmm
14:15:43 <Nereid> mhm
14:16:15 <Peaker> > sequence . repeat $ State (const (1, ()))
14:16:16 <lambdabot>   Not in scope: data constructor `State'
14:16:40 <Peaker> > sequence . repeat $ (return 1 :: State () Int)
14:16:41 <lambdabot>   No instance for (GHC.Show.Show
14:16:41 <lambdabot>                     (Control.Monad.Trans.Sta...
14:16:50 <Peaker> > (sequence . repeat $ (return 1 :: State () Int)) ()
14:16:51 <lambdabot>   Couldn't match expected type `t1 -> t'
14:16:51 <lambdabot>         against inferred type `Contr...
14:16:59 <Peaker> > runState (sequence . repeat $ (return 1 :: State () Int)) ()
14:17:01 <lambdabot>   ([1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:17:09 <noteventime> Hmm
14:17:44 <Peaker> > (sequence . repeat) (return 1 :: (() -> Int)) ()
14:17:46 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:17:52 <Peaker> okay, so there are a few monads like that :)
14:18:14 <Nereid> those uses are kind of trivial though
14:20:04 <Peaker> well, State, Reader, Writer will all yield some non-bottom result for that function
14:20:47 <Peaker> btw, in IO it is quite like "forever" (though maybe it leaks memory...)
14:22:04 <noteventime> Peaker: If you could use the result as a lazy list it would just be a forever that could yield values, right?
14:22:27 <noteventime> Hmm, how would you do that though
14:22:39 <noteventime> At first I thought you migth be able to forkIO it, but that won't work either
14:23:16 <ksf> you pattern match it
14:23:22 <ksf> thus forcing result after result.
14:24:11 <noteventime> ksf: Would it actually yield a lazy list though?
14:24:17 <noteventime> Or would you just get stuck?
14:25:11 <noteventime> > do { xs <- sequence . repeat $ return 1 ; print . take 10 $ xs}
14:25:13 <lambdabot>   <IO ()>
14:25:36 <noteventime> > print [1, 2, 3]
14:25:37 <lambdabot>   <IO ()>
14:25:46 <noteventime> Hmm, you can't do any IO in lambdabot?
14:26:38 <ksf> > launchMissiles
14:26:39 <lambdabot>   Not in scope: `launchMissiles'
14:28:08 <byorgey> noteventime: for security reasons, lambdabot does not execute any expressions with an IO type.
14:28:25 <noteventime> Hmm, I'll try it locally then
14:28:36 <noteventime> Gives a stack overflow
14:28:44 <noteventime> Figured
14:29:10 <byorgey> yeah, if you want to interleave generation of a lazy list with I/O operations, you have to use unsafeInterleaveIO
14:29:27 <noteventime> Right
14:29:53 <noteventime> Would something like this be a kosher use of unsafeInterleaveIO?
14:30:58 <byorgey> noteventime: I am not sure.
14:31:31 <noteventime> I'll just leave it, it's just to make a quickcheck code prettier anyway
14:37:29 <MostAwesomeDude> Aha! I could do Conduit Derp (StateT DerpState IO) Derp, and then transform that back down to IO, still doing MonadIO inside.
14:44:40 <noteventime> You actually have a data type called Derp?
14:45:08 <MostAwesomeDude> It's called Packet.
14:45:17 <MostAwesomeDude> But that's not important today. :3
14:45:42 <edwardk> aw.. i was hoping for a MonadDerp class
14:46:01 <applicative> noteventime: there is a derp package, but unfortunately no Derp  or MonadDerp
14:46:06 <applicative> is exported
14:46:18 <applicative> @hackage derp
14:46:18 <lambdabot> http://hackage.haskell.org/package/derp
14:47:13 <danr> edwardk: I know you have a good intution of comonads, so, in the type signature for cobind :: w a -> (w a -> b) -> w b, isn't a bit weird to have two copies of w a around? What's the intuiton you want to have that it matters which one you use?
14:48:35 <edwardk> one is in negative position there
14:49:16 <danr> Say you have cobind x (\ y -> e), then in e, you have both x and y around
14:49:18 <edwardk> you don't have it you're asked to take the 'w a' that you have and for every 'a' inside of it, to come up with a 'w a' to feed the function
14:49:25 <noteventime> applicative: I was expecting it to be some kind of joke package :)
14:49:44 <edwardk> then to stitch those together into a wb
14:50:08 <applicative> strangely  no noteventime; there is the Records Proposal by the same name though
14:50:12 <Tomsik> Has anyone played with Elm yet?
14:50:24 <Tomsik> I just ran elm-server and tried to load an .elm file, but I'm getting a blank page.
14:50:29 <edwardk> you can extract from a comonad, but that only gets you one value, extend gives you it from 'all perspectives'
14:50:34 <Tomsik> I'm on windows and know almost nothing about JS.
14:50:38 <applicative> noteventime: http://www.haskell.org/pipermail/haskell-cafe/2012-April/100527.html
14:50:43 <edwardk> have you worked through any comonads?
14:50:45 <danr> edwardk: extend=duplicate?
14:50:58 <edwardk> extend f = fmap f . duplicate
14:51:08 <danr> edwardk: yeah, nonempty lists, streams, coreader/cowriter and const void
14:52:00 <edwardk> lets take an example, and see how you could fool yourself into thinking you have the right definition for duplicate
14:52:11 <edwardk> but that that would fail the laws
14:52:18 <edwardk> lets work with store
14:52:26 <edwardk> data Store s a = Store (s -> a) s
14:52:42 <edwardk> now, extract is obvious
14:52:55 <danr> yes its application
14:52:57 <edwardk> duplicate gives us a couple of options
14:53:05 <edwardk> but only one satisfies the laws
14:53:07 <byorgey> danr: in  cobind x (\ y -> e),   x is not in scope in e.  only y is.
14:53:38 <danr> byorgey: well, it's just there, right? it's x.
14:54:02 <edwardk> byorgey: was kind of assuming he meant from the \x -> cobind x (\y -> e) there x is in scope and can be freely used inside his particular e
14:54:10 <byorgey> well, ok, that's true.
14:54:12 <edwardk> which is fine
14:54:13 <danr> yeah, exactly
14:54:25 <edwardk> you're allowed to extract from a comonad multiple times in multiple contexts
14:54:49 <edwardk> but you only get the one answer
14:54:49 <edwardk> extending gives you a way to redecorate a whole structure with a comonadic action
14:55:11 <edwardk> if we use Store to describe an image with s = (Int, Int) as our pixel position
14:55:20 <edwardk> then Store (Int,Int) Color is a picture
14:55:47 <edwardk> we can make blur :: Store (Int,Int) Color -> Color   be an action that looks at the neighboring pixels and averages them
14:56:14 <danr> duplicate (Store f s) = Store (\ s' -> Store (f s1) s2) s, where s1 and s2 can be either s/s'
14:56:46 <edwardk> blur (Store f x y) = (f (x, y + 1) + f (x, y - 1) + f (x + 1, y) + f (x - 1, y)) / 4
14:56:59 <edwardk> then extend blur gives you a new image where every pixel was blurred
14:57:14 <edwardk> danr: the only one that satisfies the laws is
14:57:21 <edwardk> duplicate (Store f s) = Store (Store f) s
14:57:58 <danr> seems reasonable :)
14:58:03 <edwardk> he comonad laws force a lot of structure on how you implement it
14:58:18 <edwardk> now given a Store (Int,Int) Color -- you can extract from it
14:58:22 <danr> can't you get something similar to the backwards State monad though?
14:58:26 <edwardk> its basically an image with a chosen coordinate
14:58:36 <edwardk> you can extract from it multiple times, but that is different than extending
14:59:12 <edwardk> well, store is the comonad you get when you compose the adjunction for state the other way around, backwards state is a different beast ;)
14:59:36 <ptrf> coppro: ok, I tried to take a break and do some chores and now I am back at it, but not getting any further... i can't really make sense of anything else than (Node f) >>= g = fmap g f, but that gives an elaborate type error
14:59:44 <edwardk> i never checked if there is a backwards store come to think of it
15:00:27 <ptrf> oh
15:00:37 <ptrf> coppro: sorry for highligh, meant for copumpkin  :-)
15:00:53 <danr> edwardk: I guess I should reread the chapters about adjunctions that might clear this up really
15:00:58 <ptrf> copumpkin: https://gist.github.com/3025693 - basically that's what I'm stuck at. can't really wrap my head around the type error
15:01:11 <danr> but thanks, it's a lot more intutive to put the arguments as you have in extend than I proposed for cobind above
15:01:57 <ptrf> copumpkin: (it's called NodeF because I have another type (or is value?) constructor, called Node earlier in that file
15:02:02 <palmfrond> i'm making a portable C library named "Number Machine". i think i've decided to prefix my library's public api with "numbermachine_" and prefix the private external api as "nm_". RFC? (it's a long public api prefix, but it'll avoid conflicts)
15:02:20 <palmfrond> C/library question, but there's a lot of brain trust in here
15:40:31 <hpaste> hiptobecubic pasted “Classy” at http://hpaste.org/70651
15:41:02 <hiptobecubic> So I think I understand how type classes work, but how do you know when it's too far?
15:41:28 <startling> hiptobecubic: when you only have one instance. :)
15:42:31 <hiptobecubic> startling, but if you expect to have more than one but don't yet?
15:42:56 <hiptobecubic> startling, is it best to write it without the typeclass and add it when it becomes a necessity?
15:43:16 <startling> oh, I guess I meant "when your finished code only has one instance"
15:43:25 <S11001001> hiptobecubic: Identity exists already, I assume you are just exercising?
15:43:37 <hiptobecubic> S11001001, yes
15:43:47 <startling> hiptobecubic: on second thought, I agree with "best to write it without the typeclass and add it when it becomes a necessity
15:44:41 <hiptobecubic> startling, wouldn't that require a lot of rewriting?
15:45:32 <startling> hiptobecubic, wouldn't a search and replace be able to fix all of the type declarations?
15:45:47 <hiptobecubic> startling, I've never had to do it so I don't know.
15:46:05 <startling> hiptobecubic: me neither. :)
15:46:30 <startling> hm, question: why isn't (/) :: Int -> Int -> Maybe Int?
15:46:32 <hiptobecubic> in this code though. Take for example the "solvable" class. It feels pretty lame to me, but how else would one uniformly express that some options have analytic solutions and some don't?
15:46:36 <startling> or Num, rahter
15:46:59 <hiptobecubic> startling, because a lot of prelude isn't safe and now it's just tradition?
15:47:03 <S11001001> designer felt that people weren't putting enough things in IO
15:47:09 <S11001001> like error handlers
15:47:58 <hiptobecubic> startling, why would by Int anyway?
15:48:03 <hiptobecubic> would it be*
15:48:11 <hiptobecubic> Muscle memory is a strange beast.
15:48:24 <S11001001> :t guard
15:48:25 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
15:48:27 <startling> hiptobecubic: it would be Num, right?
15:48:57 <startling> also, n / 0 == Infinity is pretty weird, IMO
15:49:05 <hiptobecubic> but does the existence of a product imply the existence of a quotient?
15:49:34 <hiptobecubic> num only requires (+) (*) (-) and some unary stuff
15:50:04 <startling> :t (/)
15:50:05 <lambdabot> forall a. (Fractional a) => a -> a -> a
15:50:08 <startling> oh huh
15:51:09 <hiptobecubic> startling, what were you expecting to see?
15:51:16 <hiptobecubic> startling, Nums i guess?
15:51:56 <startling> hiptobecubic, i've nver encountered Fractional, so I didn't know it was athing
15:52:17 <hiptobecubic> oh
15:52:23 <kuhrt> is http://hackage.haskell.org/platform/ the preferred way to install haskell? on a mac, preferrable to brew?
15:52:40 <startling> kuhrt: I use brew on os x
15:52:46 <hiptobecubic> I guess it's just float and double
15:52:49 <kallisti> @hoogle ShowQ
15:52:49 <lambdabot> No results found
15:52:54 <hiptobecubic> @info Fractional
15:52:55 <lambdabot> Fractional
15:52:59 <kuhrt> startling: any reason?
15:53:02 <hiptobecubic> .... thanks lambdabot
15:53:28 <startling> kuhrt, becasue it's really handy to know what things are installed and where they are and how to uninstall them. :)
15:53:53 <kallisti> hm, linear-maps is pretty far behind on its containers dependency.
15:54:05 <kallisti> I currently can't install it.
15:54:24 <kuhrt> startling: and I guess its parity with the fancy site download
15:54:52 <kuhrt> just because I noticed that the platform download was quite new (2012, and not there last time I visited, so thought maybe it was special somehow)
15:56:04 <startling> kuhrt: yep! 7.4 is new
15:56:29 <startling> kuhrt: (p.s., make sure you use the 32-bit option if you're on snow leopard or older)
15:59:36 <hiptobecubic> I know this horse has already been beaten to a pulp, but the record syntax / namespace issue is shockingly bad.
15:59:45 <irene-knapp> yes
16:00:35 <hiptobecubic> It's hard to understand honestly. Haskell is so thoroughly torn apart by smart people like spj before something is taken into the standard, no? How did everyone decide that this was a good way to do it?
16:02:19 <hiptobecubic> in that thing i pasted, it just used a prefix for each data type and then hid it with type class, but that seems like an awful solution given the "don't write your own typeclasses" rule-of-thumb
16:02:33 <hiptobecubic> s/it/I/
16:03:22 <orzo> if you want to spin off haskell, i'd be interested in a scheme srfi like approach
16:03:37 <orzo> very small core language
16:03:53 <applicative> kuhrt: I use the installer; note that it comes with an uninstaller if you dont like  it
16:04:50 <hiptobecubic> orzo, srfi?
16:05:02 <blackdog> hiptobecubic: it's a tricky problem, in some ways. you don't have implicit dispatch off the first parameter like you do with OO languages, which gets around namespacing
16:05:04 <hiptobecubic> Oh i see.
16:05:26 <orzo> yeah, instead of a large hierarchical library, scheme has a bunch of SRFI doccuments standardizing various extensions
16:05:54 <hiptobecubic> Can't the compiler do that though? It can choose the right function when using typeclass-based overloading
16:09:28 <ptrf> copumpkin: ok, i cheated and looked in the source of control monad free
16:09:37 <ptrf> and what I saw made sense :)
16:14:07 <rwbarton> hiptobecubic, how about data Option a = Option { inception :: Double, maturity :: Double, strike :: Double, underlying :: Stock, extra :: a }; data Vanilla = Vanilla; data Asian = Asian { averaging :: Average, periods :: Int }; type VanillaOption = Option Vanilla; type AsianOption = Option Asian
16:18:23 <rwbarton> if you like, make the averaging and periods fields "internal" and compose them with extra (or compose the lenses, if you're using lenses)
16:20:24 <orzo> maybe a string-like symbol type where records are lookups on the symbols that the compiler optimizes away
16:21:18 <orzo> so field names are just names and can be mapped to differient values by different records
16:21:52 <orzo> then the names can be in the global namespace without much issue, right?
16:22:20 <shergill> is there a way to globally set the maximum heap size ghc uses for compilation?
16:23:26 <hiptobecubic> rwbarton, hmmm
16:23:41 <hiptobecubic> rwbarton, i'm still figuring out your thing there...
16:24:12 <parcs`> shergill: alias ghc='ghc +RTS -M1G -RTS' :)
16:24:38 <hiptobecubic> rwbarton, oh i see...    `extra . periods $ myAsian`  ?
16:24:44 <rwbarton> yes
16:24:49 <rwbarton> no
16:24:50 <shergill> parcs`: hah. i was about to do something similar, but was hoping there was something cleaner
16:24:51 <rwbarton> periods . extra
16:24:55 <rwbarton> probably you want to write that only once
16:25:19 <hiptobecubic> rwbarton, oops. yes    periods . extra
16:26:22 <hiptobecubic> rwbarton, then i guess uses lenses to deal with the nesting? I haven't used them before but I've come to understand that that is their raison d'être?
16:26:40 <rwbarton> if you want record update
16:27:01 <rwbarton> (your type classes don't give you record update either though)
16:27:42 <hiptobecubic> rwbarton, no. just  newOption = myAsian { periods = 10 }   or something.
16:27:53 <hiptobecubic> Although now i'm forgetting what the syntax actually is.
16:28:02 <edwardk> prtf: you can also use data Free f a = Return a | forall b. Bind (f b) (b -> Free f a)   -- the Monad instance is rather easy after that ;)
16:28:43 <edwardk> back to fiddling with asian options again?
16:29:29 <hiptobecubic> edwardk, same code from before. Dug it up and thought i'd use it to practice writing things that don't run slower than php
16:30:32 <hiptobecubic> and in passing i thought, "this looks kind of stupid."
16:31:29 <hiptobecubic> most of it seems to be just instantiating classes for overloading things like spot price
16:31:43 <ClaudiusMaximus> shergill: environment variable GHCRTS maybe?
16:32:03 <ClaudiusMaximus> (but that's for all ghc compiled programs, i guess)
16:33:04 <shergill> ClaudiusMaximus: that suffices for my case, and i prefer it over an alias. thanks!
16:34:39 <coppro> ptrf: I'm pretty sure that the only consequence of applying duality to a pumpkin is that I steal its highlights
16:36:56 <hiptobecubic> edwardk, did you ever work out your hybrid monte carlo idea?
16:37:19 <edwardk> i did. /msging
16:43:03 <ptrf> lol coppro
16:47:20 * hackagebot shelly 0.12.2 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.12.2 (GregWeber)
16:48:33 <hiptobecubic> edwardk, is your current employer the one asking you not to release?
16:48:59 <edwardk> no
16:49:59 <edwardk> clarifi/s&p capital iq has been very friendly to my open source efforts actually
16:51:49 <edwardk> coppro: actually turning a pumpkin inside out makes a terrible mess. the day pumpkin became copumpkin was something out of a horror story
16:58:09 <palmfrond> edwardk, halloween 42?
16:59:27 <edwardk>  palmfrond: wasn't there an arthur c clark story where a guy gets rotated through the 4th dimension and winds up with all of his molecules having the opposite isomers, etc?
16:59:32 <edwardk> something like that
16:59:40 <edwardk> would explain why copumpkin is so skinny
17:00:09 <palmfrond> yea
17:01:35 <edwardk>  http://en.wikipedia.org/wiki/Technical_Error
17:01:38 <edwardk> found it =)
17:05:32 <coppro> edwardk: that was a really good story
17:09:52 <noteventime> applicative: Haha (excuse the lag), I love the line "Homotopy Type"
17:09:52 <noteventime> Theory is so sound and well understood that it has even been
17:09:55 <noteventime> formalized in Coq.
17:10:05 <noteventime> Opps, excuse the line breaks
17:11:25 <coppro> ooh, new conduit
17:12:40 <alienpilgrim> anyone willing to give me performance tips for an 8 line function?
17:12:56 <blackdog> alienpilgrim: hpaste it
17:13:04 <alienpilgrim> http://hpaste.org/70621
17:13:16 <blackdog> (and what have you tried? profiling options on? memory usage going up, or is it just slow?)
17:13:45 <alienpilgrim> (array is unboxed, and sum' is strict sum)
17:13:52 <alienpilgrim> I tried a few variations (eg separate maps for the two sums) but they were slower
17:14:48 <alienpilgrim> a large portion of my program's time and allocation occurs in this function
17:15:04 <alienpilgrim> (let me check the profiling flags)
17:16:55 <alienpilgrim> vanilla profiling options: ghc -prof -auto-all -rtsopts for compilation and +RTS -p for execution
17:17:15 <blackdog> and where's it spending most of the time?
17:17:55 <alienpilgrim> time in the d in the lambda
17:18:09 <alienpilgrim> allocation in the ys
17:19:04 <hpaste> AlienPilgrim pasted “SquareDeviation Profile” at http://hpaste.org/70654
17:19:28 <gienah> alienpilgrim: maybe try a bang pattern to force eval of d in the lambda
17:20:19 <blackdog> also might be worth collapsing the map & the sum into a fold - might not be getting deforested.
17:21:09 <alienpilgrim> thanks, I'll try it right now :)
17:23:07 <shergill> how do veteran haskellers cope with the lack of docstring support in haskell? types are good for somethings, but they leave me wanting at times. haddock is ok-ish, but without ghci support it may as well not be there (for me). any solution better than having a browser open on one side of the screen?
17:23:15 <shergill> *some things
17:24:29 <gienah> shergill: I don't know what "docstring support" is (I guess since its not there I don't notice it missing)
17:25:05 <blackdog> shergill: a lot of the time, the type gives you a lot of the info you need
17:25:41 <gienah> shergill: if you mean trying to find things like functions, data, then I find looking up stuff in a local hoogle database of all the packages I have installed is very useful
17:26:01 <shergill> gienah: http://en.wikipedia.org/wiki/Docstring . basically the documentation metadata is part of the function/symbol definition (which can be optionally discarded at times)
17:26:26 <gienah> shergill: thanks (me learning new stuff)
17:26:39 <parcs`> shergill: you can build and browse documentation locally
17:27:11 <shergill> parcs`: right, but it's not integrated within ghci. i like to avoid context switching as much as possible
17:27:56 <gienah> shergill: you can call hoogle from ghci
17:28:17 <shergill> gienah: i have used hoogle for the 'default' set of packages, i should look into generating stuff for other packages as well. thanks for reminding me
17:29:00 <gienah> shergill: with emacs you can run ghci in emacs and look at haddock docs with emacs-w3m
17:29:06 <parcs`> it's not really context switching unless you go off to browse reddit instead or something
17:29:55 <shergill> gienah: yeah i do that currently
17:31:01 <shergill> parcs`: bad choice of words. um. window switching? except in emacs it'd be buffer-switching. it's been a minor inconvenience. over time it could go away or it could exacerbate, i'm not sure
17:31:16 <gienah> shergill: I wrote a script to build the hoogle databases (for Gentoo): https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/hoogle/files/hoogle-build-localdb
17:31:39 <shergill> gienah: thanks
17:32:48 <gienah> shergill: you won't have fquery (if you are not on gentoo, it is written in haskell), what fquery does is looks up gentoo packages, maybe you could write something similar using ghc-pkg list or something
17:34:00 <shergill> gienah: noted. any other gentoo specific stuff in there? otherwise i am going to have a closer look at it later, but if you've got something off the top of your head
17:34:16 <gienah> shergill: the fquery ff option is listing all the files in the package, so its looking for the pkg-name.hoo file that was built by the haddock --hoogle option
17:40:10 <gienah> shergill: it would be easiest to build the default.hoo database in whatever the default directory is for hoogle (but what I do on Gentoo instead is patch hoogle to change the default location). This just avoids needing to specify the "search --database=/var/lib/hoogle/databases" option to every hoogle search
17:41:40 <shergill> gienah: yeah i'm going have to give it some thought. currently i have a few projects using hsenv/virthualenv. i'd rather build a single hoogle db for the packages installed in all (to save space, this is on my vps)
17:46:55 <gienah> shergill: on gentoo we hack the cabal files and patch the breakage to obtain a consistent set of hundreds of packages
17:48:48 <shergill> hah, that sounds like gentoo
17:49:53 <gienah> shergill: yeah like lots of packages on hackage assume you have an old ghc version, like 7.4.2, when I have 7.5.20120621 :-)
17:50:13 <shergill> heh
17:51:30 <shergill> i'm still on 7.0.4. upgraded once to 7.4.1, ran into the annoying exitfailure 11 problem. it was only after i downgraded that i found the solution was to limit ghc's memory. will upgrade again, but waiting for 7.4.2 to get added to debian sid/wheezy
17:54:12 <gienah> shergill: I don't know about that problem, I'm sure the debian devs could fix it or ask ghc hq to
17:54:35 <gienah> shergill: or upgrade it to 7.4.2
17:55:19 * gienah goes to get something to eat
17:55:23 <shergill> it's not really a ghc bug, ghc compilation (or well, linking) takes up too much memory. which on resource limited vps's can be a problem
17:57:40 <blackdog> shergill: it'd be really nice to have a better solution than compiling on the server.
18:12:44 <alienpilgrim> seems like the original implementation is pretty close to the version with bang pattern foldl' instead of sum...
18:12:55 <alienpilgrim> the dual use of ys is probably the culprit
18:19:17 <alienpilgrim> separating the uses of ys and using strict foldl' s makes it slower...
18:19:25 <gienah> alienpilgrim: maybe a bang pattern in front of the ys on lines 4 and 7 might help
18:23:07 <alienpilgrim> bangs have to be on the left side of an equals don't they?
18:23:22 <alienpilgrim> I tried adding a ! to the let ys =
18:23:34 <alienpilgrim> seems to slow it down...
18:24:13 <alienpilgrim> I guess this is close to as good as it gets without the compiler doing heavy lifting
18:25:09 <alienpilgrim> thanks for the help
18:25:48 <gienah> alienpilgrim: I wonder what the Array is like, there are probably other alternatives you could try
18:27:06 <alienpilgrim> I'm using an unboxed array
18:27:14 <alienpilgrim> I suspect that the problem is that ys is a list
18:27:25 * hackagebot multiarg 0.4.0.0 - Combinators to build command line parsers  http://hackage.haskell.org/package/multiarg-0.4.0.0 (OmariNorman)
18:28:10 <alienpilgrim> if I were able to create ys as an unboxed array immediately, that would eliminate part of the space usage, and maybe list node traversal during the folds
18:29:00 <alienpilgrim> might give that a go
18:29:45 <shirt> anyone familiar with vacuum?
18:52:20 <palmfrond> hey guys, i'm building a hardware system simulator, is there any other architecture than von neumann i should look at?
18:55:34 <hiptobecubic> palmfrond, something concurrent?
18:55:52 <palmfrond> just any examples i can plug into google images and see diagrams of
18:55:54 <palmfrond> high level
18:56:12 <palmfrond> harvard architecture eg, which i've looked at too
19:00:31 <mikeplus64> is there a reason that when you make main :: IO Int that the Int doesn't dictate the exitcode (or even better, IO ExitCode)?
19:00:59 <shachaf> That kind of overloading seems vaguely evil to me.
19:02:59 <blackdog> i think it makes a lot of sense
19:03:08 <solrize> palmfrond  http://greenarrays.com
19:03:47 <solrize> also http://www.cs.york.ac.uk/fp/reduceron/
19:03:54 <solrize> and fpga's in general
19:07:26 * hackagebot network-protocol-xmpp 0.4.3 - Client library for the XMPP protocol.  http://hackage.haskell.org/package/network-protocol-xmpp-0.4.3 (JohnMillikin)
19:11:13 <jellybaby1> @pl (\x y->f $ g x y)
19:11:13 <lambdabot> (f .) . g
19:22:40 <palmfrond> solrize, thank you. looking them over now
19:26:32 <jellybaby1> @pl (\v->f v $ g v 2)
19:26:32 <lambdabot> ap f (flip g 2)
19:32:15 <arbn> Does anyone here use haskellmode for vim?
19:36:45 <BMeph> arbn: Yes.
19:37:04 <BMeph> I don't, because I don't use vim, but I know that someone here does. ;)
19:42:40 <arbn> Oh, OK. Well, I was wondering about the mappings like "_op". I'm not sure how to enter in that command...
20:02:56 <gwern> @quote
20:02:57 <lambdabot> hobophobe says: So, I can only conclude that Haskell is a memetic virus, and monads are the eggs it lays out in innocent programming forums to entice others to become infected.
20:03:47 <shachaf> preflex: quote
20:03:52 <preflex>  <lament> and facing a choice between perl and mircscript, i'd gladly shoot myself
20:04:53 <edwardk> hah
20:15:48 <coppro> snoyman isn't around here, is he?
20:16:43 <djahandarie> IRC isn't too good for efficiency
20:31:23 <strager> @quote
20:31:24 <lambdabot> dcoutts says: monad transformers are not known for their blistering speed
20:33:00 <parcs`> @quote
20:33:01 <lambdabot> DRMacIver: says: I dread to think what category theory would look like after the software engineering world had got their grubby paws on it. Enterprise variant functors. Commutative UML diagrams.
20:33:48 <parcs`> @djinn-env
20:33:49 <lambdabot> data () = ()
20:33:49 <lambdabot> data Either a b = Left a | Right b
20:33:49 <lambdabot> data Maybe a = Nothing | Just a
20:33:49 <lambdabot> data Bool = False | True
20:33:49 <lambdabot> data Void
20:33:51 <lambdabot> type Not x = x -> Void
20:33:53 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
20:33:55 <lambdabot> class Eq a where (==) :: a -> a -> Bool
20:35:24 <coppro> @quote
20:35:24 <lambdabot> <ksf> says: duh, we can't run out of energy, as there's a fixed amount of it.
20:36:09 <strager> heh; what about matter?
20:41:29 <coppro> that we can run out of
20:41:38 <coppro> since we could turn it all into light
20:42:19 * Axman6 punches scoped type variables in the face for not working with type families or something
20:44:22 <shachaf> Axman6: They don't?
20:45:06 <Axman6> well, I think that's the problem anyway. I've got (sig ~ Signal c) in the context of my function, but when I use sig inside the function, it's telling me it's a different sig (sig1)
20:46:08 <shachaf> λ> let foo :: forall a. (a ~ Int) => a; foo = (5 :: a) in foo
20:46:08 <shachaf> 5
20:46:24 <shachaf> Doesn't work with NoScopedTypeVariables.
20:46:39 <shachaf> Well, I guess that's just a ~ constraint, not a type family.
20:46:41 <shachaf> But still.
20:46:56 <rwbarton> are you using forall sig. and/or not making some other error?
20:47:00 <Axman6> ah ha, I got it working!
20:47:12 <shachaf> "and/or not making some other error"
20:47:28 <rwbarton> um
20:47:31 <rwbarton> nand?
20:47:33 <Axman6> rwbarton: i probably was, but I managed to make all the types get infered anyway
20:47:51 <shachaf> The funny bit is asking someone whether they're making an error.
21:16:10 <palmfrond> http://www.greenarraychips.com/ is a cool project, but i don't want to go searching for documentation. i'm looking for computing architecture block diagrams; high level, not a 'web page'
21:26:42 <solrize> palmfrond yeah there is something like that
21:27:18 <solrize> http://www.greenarraychips.com/home/documents/greg/PB002-100822-GA-Arch.pdf
21:28:34 <palmfrond> solrize, Contrast this with a Multi-Core CPU, which is not a computing system until other devices such as crystals, memory controllers, memories, and bus controllers have been added. <-- what does it mean by "crystals" ?
21:29:54 <solrize> crystal = mechanical resonator that generates the clock frequency
21:30:10 <solrize> http://en.wikipedia.org/wiki/Crystal_oscillator
21:32:03 <palmfrond> ahh
21:32:19 <palmfrond> it's amazing we still use 'rocks' in our computers hehe
21:32:26 <palmfrond> i forgot all about timing crystals
21:32:29 <palmfrond> they're used in radios too
21:32:43 <palmfrond> solrize, that pdf doesn't show a block diagram of their architecture :( only application of it
21:33:45 <geekosaur> some cheap machines used to use ceramic oscillators.  they aren't so accurate...
21:34:06 <palmfrond> it looks great, and like stuff i've thought about
21:34:10 <gaze__> Hey guys. What'd be the proper way to set up a wxhaskell program such that it connects to some server in a background thread and sits around until a packet comes in, and then changes the color of the background of the window or something. I just don't understand the event system
21:34:11 <palmfrond> glad to see ppl are building systems like this
21:34:18 <solrize> http://www.greenarraychips.com/home/documents/greg/PB003-110412-F18A.pdf
21:34:45 <palmfrond> i love the actual size image, lol
21:34:46 <gaze__> is there a way to generate an event on having a semaphore unlock or something?
21:34:51 <solrize> it's neat the way the nodes in the chip communicate through what amounts to haskell mvars
21:35:29 <solrize> gaze__, what do you mean about event?  have a thread waiting on the semaphore and signal something?
21:35:42 <palmfrond> We are able to build customers’ application code into ROM for purposes such as creation of ASICs or barriers to competition.
21:35:43 <solrize> if that gets messy maybe you want to use stm
21:35:49 <palmfrond> barriers to competition? wtf?
21:36:12 <palmfrond> solrize, do you mean the nodes on the chip communicate that way?
21:36:33 <geekosaur> wx events aren't as general as haskell events, you nay find it easiest to use a loopback pipe
21:37:03 <solrize> palmfrond, yeah, there's a rectangular grid of cpu's and an mvar on each edge of each cpu, sort of
21:37:17 <palmfrond> what's an mvar? memory variable?
21:37:23 <geekosaur> thread sleeps on semaphore/mvar/whatever, writes a byte to a pipe that's registered with the wx event manager
21:37:32 <solrize> barrier to competition = other guy has to get a custom chip made to copy your device
21:37:46 <solrize> palmfrond, do you use haskell?  mvars are a haskell concurrency thing
21:37:53 <palmfrond> nah i don't
21:37:54 <palmfrond> yet anyway
21:37:57 <solrize> basically like a 1-element synchronized fifo
21:37:59 <solrize> brb
21:38:02 <palmfrond> i'm building a system like it tho
21:38:03 <geekosaur> mutex cars, roughly
21:38:08 <palmfrond> ahhh
21:38:12 <geekosaur> vars
22:03:41 <Axman6> success! I finally have a (hopefully working) 64 bit adder circuit in kansas-lava!
22:23:57 <cads> hey guys, I'd like to use haskell to do chess game analysis
22:25:32 <cads> not as an analysis engine, but more like a tool for controlling an engine like crafty or stockfish, and for writing the game annotation
22:30:53 <cads> You'd give the program a game notation file, and it would start an engine process, feed it parameters, and read its output
22:32:37 <solrize> Axman6, congrats :)  is lava like a zillion times more tedious than verilog/vhdl?
22:33:00 <solrize> cads well i guess you could do that... subprocess control is a little bit cumbersome but doable
22:33:55 <cads> could I do something like, say,   map (evaluate 10) (parse pgn), where the evaluate x pos function takes a game position pos and calculates its game value and best move for ten seconds?
22:34:13 <cads> or would I have to do some IO magic even at that level
22:34:59 <cads> solrize, it's something I'd feel comfortable doing in ruby, or even shell script, but doing it in haskell is intimidating :)
22:35:47 <solrize> yeah, there is code around you can start with if you're new to haskell
22:35:59 <solrize> like dons' blog post about shell scripting in haskell
22:36:40 <solrize> http://donsbot.wordpress.com/2010/08/17/practical-haskell/
22:37:36 <zzing> Can I get any last suggestions on the code that I have produced? This is really my first haskell project that could actually finish and I understand a good amount of what I am doing.   http://hpaste.org/70660      Line 38 has the main function that will be exported, and readDocument on line 52 implements the table found on 72. 40 to 44 is about setting up the state for that.
22:38:59 <cads> thanks, solrize!
22:40:10 <solrize> zzing that function looks overcomplicated and it looks weird to check the timestamps of files you don't know exist
22:40:48 <zzing> solrize, is there an alternative that doesn't involve an ugly set of if thens or otherwise insane levels of nesting?
22:41:04 <zzing> To me this looks elegant :-)
22:42:14 <solrize> @hoogle getModificationTime
22:42:15 <lambdabot> System.Directory getModificationTime :: FilePath -> IO ClockTime
22:42:24 <solrize> that looks like it fails if file doesn't exist
22:42:25 <startling> any suggestions for an efficient queue data structure, preferably in the prelude or the haskell platform?
22:43:55 <zzing> solrize, I believe so. I am not so good on the exceptions in IO at this point, so I didn't use them
22:44:20 <solrize> i see
22:44:22 <solrize> just a sec
22:45:03 <zzing> There is one thing I am curious about - a property of this sequence - fileExists, CacheExists, cacheOlder is that if any of the ones before it are false, the effects don't matter
22:47:46 <solrize> yeah i see that is ok. i'm just trying to factor the code a little
22:48:39 <zzing> This is going to eventually be on a production server (not exactly mission critical - student group website), so I want to learn more about error handling too :_)
22:52:43 <startling> alright, I found Data.Sequence. Now say I have a sequence of sequences -- is there a simple way to "modify" such a structure by saying which part changes, getting a new copy of that structure? Are Views or Lenses related to this?
22:53:46 <startling> or am I just going to need to write a million helper functions?
22:54:40 <eigenpumpkin> a lens would certainly work
22:54:51 <eigenpumpkin> you'd need to make your own though, since I don't think there are any premade ones
22:55:25 <zzing> What is a lens?
22:55:27 <startling> is this the problem that lenses (try to?) solve?
22:57:06 <yitz> startling: lenses are one way to think about that kind of problem, yes.
22:57:25 <startling> interesting. guess I'll do some reading. thanks!
22:59:04 <yitz> zzing: here is one introduction: http://twanvl.nl/blog/news/2011-05-19-lenses-talk
22:59:19 <yitz> zzing: it's only the slides from the talk though, unfortunately
23:00:35 <yitz> zzing: there have been many attempts to solve that problem. here is slightly old summary of them: http://brandon.si/code/haskell-state-of-the-lens/
23:01:50 <yitz> zzing: i think data-lens has been gaining more traction since then
23:02:30 <zzing> So in general are lenses one of those things that will be a topic of discussion into the future?
23:02:38 <yitz> i think so yes
23:03:27 <zzing> My school doesn't do much functional programming classes beyond an introductory in miranda, so all of the good stuff I have to do on my own. Little bits like this helps.
23:04:35 <yitz> it's good that they have that introduction in miranda. though miranda is a very obsolete language AFAIK.
23:04:54 <zzing> yitz, they want to change it to haskell. It has been miranda for 20 years
23:05:03 <zzing> I think miranda is a great language for what they use it for
23:05:34 <yitz> zzing: yes miranda was interesting 20 years ago. i don't think anyone has touched it since then.
23:05:48 <zzing> yitz, only minor updates. Last update was 1989
23:06:31 <zzing> If I have a function, such as new :: FilePath -> FilePath -> IO Cache    that is a essentially a constructor for a datatype that checks to make sure the values given exist, what would be the ideal means of signifying failure while providing reasons?
23:07:08 <startling> IO (Maybe Cache) is one way
23:07:19 <startling> oh, you want to provide a reason
23:07:22 <zzing> Maybe doesn't provide a reason, and Either is rather limiting
23:07:31 <startling> yeah. I know what what you mean
23:07:51 <zzing> Are exceptions worth looking into?
23:07:53 <yitz> zzing: why is Either limiting to you?
23:08:24 <zzing> yitz, a string isn't something as easy to have the program respond to
23:08:31 <yitz> zzing: so don
23:08:39 <yitz> zzing: so don't use a string then
23:08:52 <zzing> @src Either
23:08:52 <lambdabot> Source not found. Just what do you think you're doing Dave?
23:08:56 <startling> yeah, you could do "data Error = ErrorA | ErrorB"
23:09:03 <yitz> zzing: use a data type that represents "reasons" whatever that means to you
23:09:13 <startling> and then "type Failable = Either Error"
23:09:29 <zzing> ok obviously I was missing the definition of either :-)
23:10:01 <yitz> zzing: Either is the fundamental sum type. it is the dual to tuples, the fundamental product type.
23:10:30 <zzing> I get what a product type is, I am forgetting exactly what a sum type is
23:10:31 <yitz> data Either a b = Left a | Right b
23:10:43 <startling> zzing: == union type
23:10:49 <zzing> ok
23:10:54 <yitz> zzing: disjoint union
23:11:14 <startling> @src Either
23:11:14 <lambdabot> Source not found. Maybe you made a typo?
23:11:20 <startling> oh heh
23:11:35 <zzing> Is this about right?   new :: FilePath -> FilePath -> IO (Either Error Cache)
23:11:42 <startling> i imagine it's something like "data Either a b = Left a | Right b"
23:11:53 <yitz> startling: it's exactly that
23:11:56 <zzing> It is
23:12:16 <startling> zzing: looks right to me
23:13:32 <zzing> ok, say that I have three conditions I want to care about - rootExist and cacheExist,  root does not exist, root does exist and cache does not exist -  would a case function be the best way to handle it?
23:14:31 <zzing> case rootExist : cacheExist : [] of  …    ok that is ugly, so there must be a constructor that is nice for this
23:15:40 <startling> []?
23:15:46 <startling> (,) even
23:16:06 <zzing> I don't know the comma
23:16:08 <zzing> :t (,)
23:16:10 <lambdabot> forall a b. a -> b -> (a, b)
23:16:13 <zzing> @src (,)
23:16:14 <lambdabot> Source not found. Maybe you made a typo?
23:16:16 <startling> zzing: the tuple constructor!
23:16:22 <startling> "case (rootExist, cacheExist) of ..."
23:16:24 <zzing> oh that will so work
23:16:28 <zzing> thank you
23:16:48 <startling> zzing: are rootExist and cacheExist IO monads?
23:17:01 <zzing> They are bools inside a do, so yes
23:17:11 <zzing>     rootExist <- doesDirectoryExist root
23:17:38 <startling> oh, never mind! was gonna warn you that you might need to <- before using case
23:18:01 <zzing> Certain elegencies I am decent with
23:18:12 <zzing> I need more on exceptions, should look it up tomorrow
23:18:27 <zzing> I am redoing some of the web cache system above, adding in some stuff that makes it more reusable as a module
23:18:55 <cads> what is an existential type?  In these lens slides (http://www.twanvl.nl/files/lenses-talk-2011-05-17.pdf) on page 16, there's a function residual whose type is "exists r. (a -> (b, r), (b, r) -> a),
23:19:21 <zzing> cads, is it possible it is referring to an existential typeclass?
23:19:26 <zzing> (love those!)
23:19:53 * cads jogs on over to the google
23:25:55 <startling> hm, is there a
23:26:08 <startling> "rough equality" for strings somewhere?
23:27:29 <cads> like minimum edit distance?
23:29:00 <startling> cads: something like that would be great. i was thinking more like case-insensitivity, though, but I probably want that, too
23:29:32 <cads> hm, you could slap everything into lower case first
23:29:41 <startling> yeah, I was thinking about that
23:29:42 <zzing> Dear Father, forgive me for I have sinned - Twice. First by importing Debug.Trace, and Secondly running traceIO for what turned out to be a typo. Please forgive my impurity Father.
23:32:35 <AfC> heh
23:34:32 <hpaste> zzing pasted “FileCache Module” at http://hpaste.org/70661
23:34:41 <zzing> Is this a reasonable way to start this module off?
23:40:11 <Enigmagic> zzing: do you have at least three unsafeCoerces?
23:40:24 <zzing> There are no unsafe anythings
23:40:50 <Enigmagic> needs more work then
23:41:04 <zzing> Why would I want to do anything sunafe?
23:41:25 <Enigmagic> it adds excitement to an otherwise boring day.
23:41:35 <zzing> I thought so :-)
23:46:35 <hpaste> solrize annotated “markDown cacher” with “markDown cacher (annotation)” at http://hpaste.org/70660#a70662
23:47:17 <solrize> wait that's wrong
23:48:49 <zzing> It is quite compact
23:50:20 <hpaste> solrize annotated “markDown cacher” with “markDown cacher (annotation) (annotation)” at http://hpaste.org/70660#a70663
23:50:44 <mewalz> is there a standard combinator that can compose a function,f, with its self x times (like apply f 3 === f . f . f)?
23:51:02 <solrize> :t iterate
23:51:03 <lambdabot> forall a. (a -> a) -> a -> [a]
23:51:12 <mewalz> thanks
23:51:32 <solrize> > iterate (* 2) 1
23:51:33 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
23:51:44 <napping> > (!!3) . iterate (*2) 1
23:51:46 <lambdabot>   No instance for (GHC.Num.Num [a])
23:51:46 <lambdabot>    arising from a use of `e_1321' at <int...
23:51:46 <solrize> > iterate (* 2) 1 !! 3
23:51:47 <lambdabot>   8
23:52:15 <napping> does that actually optimize nicely?
23:52:25 <solrize> shrug
23:52:38 <solrize> probably
23:52:55 <zzing> solrize, I have to take a look at it in the morning. Thank you for this. It should help with my new module that makes it reusable.
23:52:58 <zzing> @src maximum
23:52:58 <lambdabot> maximum [] = undefined
23:52:58 <lambdabot> maximum xs = foldl1 max xs
23:53:48 <solrize> > maximum [Just 3, Just 5, Nothing]
23:53:49 <lambdabot>   Just 5
23:54:25 <startling> oh weird
23:54:31 <zzing> @src max
23:54:32 <lambdabot> max x y = if x <= y then y else x
23:54:35 <startling> > Just 0 > Nothing
23:54:36 <lambdabot>   True
23:54:41 <zzing> very nice
23:54:45 <startling> > Just -1 > Nothing
23:54:46 <lambdabot>   Couldn't match expected type `a -> Data.Maybe.Maybe a'
23:54:46 <lambdabot>         against infe...
23:54:48 <zzing> A few nice things in there
23:54:54 <zzing> > Just (-1) > Nothing
23:54:56 <lambdabot>   True
23:55:05 <startling> weird
23:55:06 <zzing> startling, don't forget - is an operator
23:55:08 <startling> not sure I like that
23:55:21 <startling> zzing: yeah, that always gets me
23:55:29 <zzing> @src (>)
23:55:30 <lambdabot> x >  y = case compare x y of { GT -> True;  _other -> False }
23:55:35 <zzing> :t (>)
23:55:37 <lambdabot> forall a. (Ord a) => a -> a -> Bool
23:55:59 <startling> Maybe is evidently an Ord, such that everything is greater than Nothing
23:56:10 <startling> > Nothing > Nothing
23:56:11 <lambdabot>   False
23:56:22 <solrize> oh what did i do there, I forgot to get rid of that extra nothing when i refactored
23:56:26 <startling> > Just Nothing > Nothing
23:56:27 <zzing> How does Maybe just derive an Ord for this without specifying one?
23:56:27 <lambdabot>   True
23:56:36 <zzing> data  Maybe a  =  Nothing | Just a
23:56:37 <zzing>   deriving (Eq, Ord, Generic)
23:56:48 <startling> zzing: Nothing is before Just
23:57:01 <zzing> oh it is an assumption…
23:57:22 <startling> > Just Nothing > Just Just Nothing
23:57:23 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a1
23:57:24 <lambdabot>                          ...
23:57:38 <startling> > (Just Nothing) > (Just Just Nothing)
23:57:39 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a1
23:57:39 <lambdabot>                          ...
23:57:42 <zzing> > Just Nothing > Just (Just Nothing)
23:57:43 <lambdabot>   False
23:57:53 <zzing> > Just Nothing > Just $ Just Nothing
23:57:55 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe
23:57:55 <lambdabot>                             ...
23:57:59 <hpaste> solrize annotated “markDown cacher” with “markDown cacher (annotation) (annotation) (annotation)” at http://hpaste.org/70660#a70664
23:59:22 <zzing> This is rather nice :-)
23:59:26 <zzing> Thank you so much
23:59:59 <solrize> i think it's possible to keep refining it
