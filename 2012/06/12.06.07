00:03:56 <isson> can i have a question ? if i write a recursive function in haskell, is it possible  stack overflow ? does haskell function is implemented using stack ?l
00:04:51 <dmwit> ?wiki stack overflow
00:04:51 <lambdabot> http://www.haskell.org/haskellwiki/stack_overflow
00:05:57 <isson> good ~. thanks a ton . dmwit
00:06:04 <isson> ?wiki stack overflow
00:06:04 <lambdabot> http://www.haskell.org/haskellwiki/stack_overflow
00:06:18 <isson> ah~~..good lambdabot ~
00:07:07 <Ptival> amatsu: The "Cormen" Introduction to algorithms is very praised around me
00:07:42 <augur> hmm
00:08:01 <nand`> OH
00:08:21 <augur> so i have a list of filenames that i want to process but im not sure how to do so. like, if i have a list of strings and i wanted to putStr them in order, how would i do this?
00:08:31 <nand`> no wonder my @type is going crazy, @type works by actually piping the command into ghci, and my .ghci already defines (.) so they overlap with L.hs's
00:08:46 <augur> ahh sequence_
00:09:03 <Axman6> for mapM_ putStrLn (i assume you want one per line)
00:09:08 <Axman6> or*
00:09:16 <augur> Axman6: yeah, mapM_ also looks useful
00:09:28 <Axman6> @src mapM_
00:09:29 <lambdabot> mapM_ f as = sequence_ (map f as)
00:09:43 <amatsu> Ptival: Thanks, will look into it!
00:09:53 <luca> man this is horrid
00:10:01 <augur> ive never understood sequence_ but maybe i will now :)
00:10:19 <luca> maybe (return ([],Nothing)) ((liftM (\(x,xs) -> (xs, Just (unliftB x))) . uncomplicate . liftB)) def
00:10:20 <luca> hahah
00:10:32 <Axman6> augur: haven't you been here for years?
00:10:51 <Ptival> sequence_ ms     =  foldr (>>) (return ()) ms
00:10:58 <Ptival> that doesn't look too daunting :)
00:11:18 <luca> @pl \(xs,x) -> (xs, Just (unliftB x))
00:11:18 <lambdabot> second (Just . unliftB)
00:11:37 <Ptival> luca: I guess it's complicated if they need to "uncomplicate" it :D
00:12:24 <luca> :p uncomplicate is taking an expression, and converting it into a set of statements and trivial expression
00:12:32 <luca> (translating from language where everything is expression, to c#)
00:13:45 <augur> Axman6: yes, but that doesnt mean i understand sequence_ :)
00:13:56 <Axman6> heh =)
00:14:04 <luca> liftB unliftB going back and forth between list of expressions and a block expression
00:17:31 <dmwit> ?unmtl RWST r w s Maybe a
00:17:32 <lambdabot> r -> s -> Maybe (a, s, w)
00:17:58 <nand`> ?mtl r -> s -> Maybe (a, s, w)
00:17:58 <lambdabot> Maybe you meant: ft map msg pl unmtl url
00:18:00 <nand`> shame
00:18:04 <dmwit> ?unmtl MaybeT (RWS r w s) a
00:18:05 <lambdabot> r -> s -> (Maybe a, s, w)
00:18:44 <dmwit> oh, strange
00:18:53 <dmwit> For some reason I thought Reader and State commuted.
00:19:03 <dmwit> ?unmtl ReaderT r (State s) a
00:19:03 <lambdabot> r -> s -> (a, s)
00:19:11 <dmwit> ?unmtl StateT s (Reader r) a
00:19:11 <lambdabot> s -> r -> (a, s)
00:19:12 <augur> whats mtl mean
00:19:19 <dmwit> augur: monad transformer library
00:19:21 <augur> o
00:19:46 <dmwit> Oh, they do commute, and neither of them is s -> (r -> a, s)
00:19:48 <dmwit> interesting
00:20:24 <megajosh2> Is anybody familliar with the tls package? I can't figure out why I constantly get "ConnectionNotEstablished" when I try to send data over the socket http://hpaste.org/69577
00:20:37 <Veinor> ?mtl s -> (r -> a, s)
00:20:38 <lambdabot> Maybe you meant: ft map msg pl unmtl url
00:20:43 <megajosh2> I tried modelling the code after an example I saw by the library author
00:21:03 <dmwit> I wonder how good unmtl is.
00:21:10 <dmwit> ?unmtl State s (Reader r a)
00:21:10 <lambdabot> s -> (r -> a, s)
00:21:15 <dmwit> pretty good =D
00:21:48 <Veinor> so what's the difference between State s (Reader r a) and StateT s (Reader r) a
00:21:53 <Veinor> at a conceptual level
00:22:08 <dmwit> State s (Reader r a) can't use the r to decide what state to go to next
00:22:24 <Veinor> ah
00:22:35 <luca> aka you can only do the reading inside of an 'inner' do block (if i'm correct), whereas the StateT one you can mix state and read stuff etc
00:22:53 <luca> and that inner do block can't do state
00:22:58 <nand`> no need for a do block
00:23:00 <nand`> but basically yeah
00:23:12 <nand`> StateT s (Reader r a) produces Reader actions statefully
00:23:14 <nand`> err
00:23:16 <nand`> State*
00:23:42 <nand`> StateT s (Reader r) a is an action that is both like a reader and stateful
00:24:47 <Veinor> ah ok
00:41:14 * Axman6 would love it if someone updated ghc-core so it could display LLVM textual representation after optimisation
00:52:55 <talin> hello
00:53:18 <talin> i read an article where john carmack advocates functional programming (and haskell)
00:53:25 <dmwit> howdy
00:53:32 <talin> and i'm interested in learning haskell, but there's one thing i don't understand
00:53:58 <talin> why is all the software i use, written in C? freebsd, postfix, apache, postgresql, etc
00:54:18 <talin> i think he makes valid points why it's a good idea to write functional programs
00:54:55 <talin> but i don't think i use any software written in functional programming languages on a daily basis (except perhaps the addons for emacs?)
00:55:41 <nand`> talin: because C is more popular than Haskell
00:56:08 <Saizan> talin: a lot of it historical of course
00:56:12 <Saizan> *is
00:56:27 <Axman6> because C is old, and most systems support C very well (especially *nix systems) as well as being written in it. And it hasn't been until recently that there's been much of a push in the non academic world towards functional languages
00:56:27 <talin> nand`: hmm, that is true. but for example python is very popular, and very little software is written in python
00:56:35 <nand`> I use lots of programs written in Haskell on a daily basis, for that matter - some have become indispensible parts of my life
00:57:02 <dmwit> Plenty of software is written in Python.
00:57:14 * applicative got into Haskell by using a program every day that was written in  it
00:57:26 <nand`> me too, it's called GHC
00:57:31 <nand`> :P
00:57:54 <talin> i can't think of anything written in python or haskell. perhaps i can think of software that uses python for extensions
00:58:12 <dmwit> Caffeine for Linux, Anki are my every-day Python apps; ghc, xmonad, bacteria, yeganesh are my every-day Haskell apps
00:58:25 <raichoo> talin: mercurial is written in python
00:58:27 <talin> i hope that the multiple core concept forces people away from C and over to haskell
00:58:35 * applicative thinks, bacteria?
00:58:43 <dmwit> http://dmwit.com/bacteria =)
00:58:57 <nand`> some haskell programs I use regularly: xmonad, xmobar, vimus, ghci, darcs, yeganesh, lambdabot, hint, stylish-haskell
00:59:16 <talin> hmm, mercurial is a pretty big one
00:59:17 <applicative> ah i see it
01:00:08 <nand`> s/hint/hlint/
01:01:06 <applicative> talin http://johnmacfarlane.net/pandoc/  https://groups.google.com/group/pandoc-discuss
01:01:06 <dmwit> http://en.wikipedia.org/wiki/List_of_Python_software#Applications has a lot of high-exposure applications
01:01:19 <dmwit> Pandoc is wonderful, yes! and darcs
01:01:57 <nand`> talin: also, lots of Haskell code is “hidden”, for example industrial back-ends that the end user will never run on their computer
01:03:17 <nand`> the world doesn't revolve around “apps”, regardless of what mobile phone vendors would have you believe :)
01:04:17 <womb> hi
01:04:22 <dmwit> Well, I can think of worse metrics for popularity than "what languages are my favorite apps written in". =)
01:05:03 <applicative> hi womb
01:05:17 <talin> dmwit: hmm, that's true. some of those are on the list only because the software can be extended with python though (blender, for example)
01:05:53 * dmwit nods
01:07:49 <applicative> python is as they say an interpreted language, there will be chunks of C everywhere of course
01:09:18 <applicative> if it wouldn't exist without the python machinery on top, its a perfectly typical python program even if some gruesome C or whatever had to be written
01:09:30 <nand`> portage is written in python, that's a piece of software I would consider vital :)
01:11:57 <applicative> talin a lot of the important haskell libraries are bindings to C programs too, but the relationship is different since the ghc is a compiler
01:15:46 <applicative> bindings to C libraries  rather, of course
01:29:12 <nand`> does it matter what language the library was written in when linking, as long as it's CDECL?
01:29:20 <nand`> (I don't know an awful lot about this)
01:29:54 <dmwit> I don't know what CDECL means, but there are bindings to other languages' libraries; they all go via the other language's C FFI.
01:30:27 <Ralith> nand`: the only thing that matters is the ABI.
01:30:33 <nand`> CDECL is the x86 calling convention used by C, and presumably, every C FFI
01:30:35 <Ralith> if the ABI is C, then any C FFI can handle it.
01:31:03 <dmwit> Right, then the answer to your question is "no".
01:31:04 <Ralith> thus extern "C" being used for C bindings of C++
01:31:35 <shachaf> C doesn't have a calling conventtion.
01:31:35 <dmwit> It could conceivably matter -- early GHC's required C headers, for examples.
01:32:13 <dmwit> Actually I don't know if that's true.
01:32:19 <nand`> shachaf: allow me to correct myself: the x86 calling convention used by some (most?) C implementations for x86
01:32:20 <dmwit> But the FFI spec talks about C headers. =)
01:32:23 <Ralith> :P
01:32:37 <Ralith> nand`: probably you want to say "The ABI used by C on the current platform."
01:32:44 <Ralith> well, no
01:32:56 <nand`> Ralith: the ABI is more than just the calling convention, judging by https://en.wikipedia.org/wiki/Application_binary_interface
01:32:57 <Ralith> "The ABI generated by the C compiler which produced the binaries of interest on the current platform."
01:33:19 <shachaf> nand`: There are lots of C implementations for x86 and several different popular calling conventions. :-)
01:33:20 <nand`> I guess this includes the libc + the primitive data types
01:33:25 <Ralith> nand`: you want to be able to send data to and get data from the functions, yes? :P
01:34:05 <nand`> shachaf: yeah, and with this newfangled 64-bit stuff CDECL has fallen into obscurity either way :P
01:34:14 <nand`> Ralith: presumably
01:34:18 <Ralith> thus ABI.
01:34:36 <talin> cool. i hope to see more haskell software soon
01:36:09 <applicative> talin I think it will mostly be invisible.  for exampe the new mania is web servers, frameworks etc
01:37:29 <nand`> oh and let's not forget “guided missile systems”
01:38:01 <nand`> talin: you may or may not be interested in http://www.haskell.org/haskellwiki/Haskell_in_industry
01:38:13 * hackagebot msgpack-rpc 0.7.1.2 - A MessagePack-RPC Implementation  http://hackage.haskell.org/package/msgpack-rpc-0.7.1.2 (HideyukiTanaka)
01:38:29 <applicative> yeah, you experience them by their effects, like banking catastophes
01:39:06 <nand`> :)
01:39:08 <talin> guided missile systems? that's pretty cool
01:39:12 <absence> is the "on" function i see in gtk2hs tutorials (e.g. widget `on` event $ handler) the regular Data.Function one?
01:39:30 <nand`> talin: I don't know if Haskell is actually being used for that; but I know that some “defense contractors” working with “artificial intelligence systems” use Haskell :)
01:39:33 <dmwit> absence: no
01:39:40 <dmwit> absence: It's a gtk2hs-specific one.
01:40:03 <dmwit> absence: http://hackage.haskell.org/packages/archive/glib/latest/doc/html/System-Glib-Signals.html#v:on
01:40:40 <dmwit> absence: There used to be onFoo and afterFoo for every signal; now there is just foo and you choose to apply on or after. =)
01:41:39 <absence> good good. i was having trouble mentally shoehorning the type signatures into the Data.Function one ;)
01:41:53 <talin> nand`: aah, okay
01:44:02 <applicative> talin there is a recurring joke in haskell-land  about the IO action 'launchMissiles'
01:45:11 <nand`> applicative: I totally didn't even realize that; in hindsight it makes my joke actually funny
01:46:37 <applicative> oh i see, you haven't seen it?
01:46:43 <nand`> I have :)
01:46:48 <nand`> It just didn't occur to me when writing that line
01:47:02 <nand`> talin: http://hackage.haskell.org/package/acme-missiles
01:47:12 <applicative> http://hackage.haskell.org/package/acme-missiles alludes to the antecedenly existing meme, in simon pj etc
01:47:17 <nand`> “Causes serious international side effects.” hehe
01:47:19 <applicative> haha
01:48:51 <applicative> oh look a learned enquiry into the history  http://stackoverflow.com/questions/2773004/what-is-the-origin-of-launch-the-missiles
01:50:18 <nand`> “There are software apps out there which do indeed manage the launching of ICBMs, so there must be projects whose Risk Assessment must cover the accidental triggering of nuclear annihilation.” <- there's a fun debug session
01:51:22 <applicative> heres a typical use, after a complex discussion of conditionals http://www.haskell.org/pipermail/haskell-cafe/2009-May/060951.html
01:52:02 <applicative> distinguishing iffy and miffy mcb concludes  iffy askPresident launchMissiles seekUNResolution  is to ask the President, then launch the missiles, then lobby the UN, then decide that the result of seeking a UN resolution is preferable.  Remember folks: Missiles need miffy!  Cheers
01:54:55 <nand`> applicative: an interesting post
01:55:48 <nand`> that's a good way to distinguish between applicative and monad; I wonder if it can be carried over to the various Arrow classes
01:57:10 <dmwit> I'm surprised you hadn't heard that before. It's the standard way to explain the difference between Monad and Applicative.
01:58:12 <nand`> dmwit: maybe I have and I'm too tired to recall right now
02:00:03 <nand`> I guess I've just never seen it put into words; it does somewhat follow from the types of <*>/>>=
02:00:36 * nand` off
02:21:28 <hpaste> kstt pasted “typeclass simple question” at http://hpaste.org/69635
02:21:46 <kstt> hi, above is a simple question regarding type classes
02:22:41 <kstt> for some reasons, probably bad reasons, I wanted this typeclass interface to provide two functions
02:23:03 <kstt> one for the base path of the URI, the other for constructing a resource identifier
02:23:19 <Saizan> restBasePath is not usable because the type parameter doesn't appear in its type
02:23:27 <geekosaur> you aren't using any of the type variables, which (a) means it can never be given a type when used (b) usually indicate syou're trying to use it for OOP
02:23:42 <Lemmih> kstt: If someone types in 'restBasePath', which instance should it use?
02:24:27 <kstt> I see that. What I am asking is more : what is the usggested design in this case ? Coupling the two together so that a single function parametrized by the type will provide both the base path and the id generator ?
02:24:57 <dmwit> kstt: How about just using a record instead of a class?
02:25:00 <kstt> (I should probably mention that I understand the problem technically)
02:25:24 <dmwit> data RestRoutable a = RestRoutable { base :: String, resource :: a -> String }
02:25:34 <geekosaur> ^^ that
02:26:16 <kstt> well, that's a possibility indeed
02:28:26 <augur> dmwit: so an explicit class!
02:29:14 <kstt> it would however be slightly less convenient, because it would require to provide both the Record holding the routing logic for the resource, and the resource itself
02:29:40 <augur> the problem, kstt, is that the types cant be inferred given those methods
02:29:49 <kstt> sure
02:30:04 <dmwit> data RestRoutable = RestRoutable { base :: String, resource :: String } -- ;-)
02:30:10 <kstt> that's why I would like if there is a common design in this case, with typeclasses
02:30:21 <augur> if you use restBasePath, how would the program know which class instance to use?
02:30:36 <kstt> I understand that augur
02:30:51 <kstt> I have done a very bad job at asking this question :)
02:31:08 <dmwit> Yes, it's very difficult to give good advice with such a narrow question. =)
02:31:36 <kstt> the question is not "why can't that typecheck ?". The question is "how would you solve this problem, preferably with typeclasses ?"
02:31:44 <augur> whats the problem!
02:32:14 <kstt> associating a value to a type
02:32:14 <moj> Hi! I'm trying to install xmonad-extras via cabal, but am getting the same error as this chap: http://pastebin.com/1RiVKV1f
02:32:17 <JamesRustle> The paste 1RiVKV1f has been copied to http://hpaste.org/69637
02:32:21 <augur> ahh
02:32:25 <moj> Is it a known issue?
02:32:34 <augur> that is a good question
02:32:49 <augur> i wonder if the Typeable class has an answer
02:32:58 <dmwit> moj: yep, compile with --flag -with_hlist
02:33:12 <kstt> using a dummy phantom type could certainly help as well
02:33:22 <moj> dmwit: Great, that got it! Thanks :)
02:33:36 <augur> it seems typeable makes use of dummy args for type purposes only
02:33:45 <kstt> ok
02:34:23 <kstt> that's a bit beyond my scope for this problem, so I'll take an easy path here
02:34:28 <augur> class Typeable a where typeOf :: a -> TypeRep
02:34:52 <augur> you'd have to throw in an argument just to tell the type checker whats what
02:34:53 <dmwit> data Proxy a = Proxy
02:35:04 <kstt> either grouping the two functions together, or using a dummy parameter, or using explicit records
02:35:10 <dmwit> class RestRoutable a where restBase :: Proxy a -> String; restResource :: a -> String
02:35:31 <augur> how many instances were you planning on having, kstt?
02:35:45 <kstt> I'd say 10 to 20
02:36:03 <augur> go with the class+Proxy solution
02:36:09 <augur> so you dont have to thread things around manually
02:36:10 <dmwit> kstt: Here's another option.
02:36:33 <augur> i suspect that this shouldnt be an issue tho, for the type checker i mean
02:36:51 <augur> there might be cases where it couldnt resolve
02:36:58 <dmwit> kstt: Instead of "instance Rest Page", "instance Rest Blah", "instance Rest Foo", you could write data Rest = Page | Blah | Foo and two functions resource, base :: Rest -> String
02:36:59 <augur> but..
02:37:34 <augur> mm no, it would still be a problem, yes. hmm
02:37:41 <augur> what are the example usages you want to have, kstt
02:37:53 <augur> that might help find an elegant solution
02:38:11 <augur> like, what are two examples with different instances
02:40:08 <kstt> http://hpaste.org/edit/69635
02:41:10 <kstt> sorry, I missed something, hang on a minute
02:42:04 <augur> edwardk!
02:42:09 * edwardk hides
02:42:23 <augur> :D
02:42:34 <edwardk> how goes?
02:42:38 <augur> pretty good
02:42:51 <augur> almost done with a literate agda to html convertor
02:42:52 <augur> you?
02:42:54 <hpaste> kstt annotated “typeclass simple question” with “typeclass simple question (annotation)” at http://hpaste.org/69635#a69638
02:43:00 <edwardk> pushing a new version of my lca package
02:43:20 <augur> LCA?
02:43:49 <edwardk> found a nice way to compute online lowest common ancestor searches that improves their asymptotics
02:44:20 <edwardk> given a tree, and two nodes in the tree, find the lowest node in the tree that is their common ancestor
02:44:25 <kstt> augur: the annotated paste contains my plan
02:44:42 <edwardk> can be calculated in log(height) time if you store the paths in a novel way
02:45:14 <augur> kstt: no i mean, show me two difference uses of the restBasePath value that would give different results
02:45:17 <snhmib> is that with the encode the paths as bits where you go right and then take the common prefix of 2 paths?
02:45:27 * snhmib forgot
02:45:35 <augur> edwardk: interesting! link to something i can read?
02:45:50 <edwardk> snhmib: that requires preprocessing, plus the fanout on the trees can be arbitrary
02:46:07 <edwardk> github.com/ekmett/lca is the working code. i have slides here somewhere, one sec
02:46:11 <snhmib> oh ok
02:46:24 <augur> edwardk: they better be fun slides!
02:46:32 <edwardk> https://docs.google.com/open?id=0ByK3AAy5ubqaZE1lblpwNjF0VlU
02:46:49 <noor_> Hello one and all. I am interested in Haskore.
02:46:54 <edwardk> snhmib: to be fair, there is an optimal offline algorithm that uses that approach
02:47:42 <snhmib> offline is without updates and online is with?
02:47:45 <edwardk> but the offline version of the problem requires O(n) preprocessing to get subsequent O(1) lookups in a tree of n nodes. I do no preprocessing to get O(log height) lookups, where height is obviously <= n.
02:48:06 <edwardk> yeah, i can keep growing my trees, but if you grow one of those offline trees, you have to start all over.
02:48:29 <edwardk> when you consider problems like version control which use LCAs on long trees that they keep growing it becomes annoying ;)
02:48:57 <edwardk> Is Haskore still around?
02:49:17 <edwardk> I don't mean that in a denigrating sense, I just honestly don't know the status of it
02:49:47 <edwardk> warning the google docs link i gave is probably 28 megs ;)
02:49:52 <noor_> The code specifically. A working version would be dandy though.
02:50:11 <noor_> *edwardk
02:51:13 <noor_> I was wanting to look over how haskore was built what do I need to do to view and understand its construction? I am on OS 10.7 with the latest version of The Haskell Platform and Leksah. I also would like to see the current state of interface What files are important and where do I get them?
02:51:50 <edwardk> snhmib, augur: its not much code actually https://github.com/ekmett/lca/blob/master/src/Data/LCA/Online.hs
02:53:19 * hackagebot GTALib 0.0.5 - A library for GTA programming  http://hackage.haskell.org/package/GTALib-0.0.5 (KentoEmoto)
02:53:21 * hackagebot lca 0.2 - O(log n) persistent on-line lowest common ancestor calculation without preprocessing with optional monoidal annotations  http://hackage.haskell.org/package/lca-0.2 (EdwardKmett)
02:54:26 <sopvop> Am I the only one who first thought of Grand Theft Auto?
02:54:38 <edwardk> sopvop: =)
02:54:45 <noor_> Also if anyone knows what ln(pi) in base 12 is that would also be helpful
02:54:45 <snhmib> no :(
02:55:38 <alpounet> Cale, ping
02:56:04 <edwardk> preflex: xseen Cale
02:56:04 <preflex>  Cale was last seen on freenode/#haskell 3 hours and 7 minutes ago, saying: I didn't know there was a Cale version of .:
02:58:13 <Taneb> Haskell is almost Turing-Complete with the Applicative instance for functions
02:59:28 <edwardk> you mean how its very S combinator like?
02:59:41 <Taneb> Yeah, and pure is K
03:04:44 <danr> @type (<*>) id id ((<*>) id id)
03:04:45 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
03:04:45 <lambdabot>     Probable cause: `id' is applied to too few arguments
03:04:45 <lambdabot>     In the second argument of `(<*>)', namely `id'
03:04:59 <otters> is there a tool that can convert a recursive function to a call to fix
03:05:16 <potapov> Hi. Is anybody here using Euterpea library? I can't figure out how to use several instruments sinultaneously.
03:11:43 <edwardk> danr: hence 'almost' ;)
03:11:56 <edwardk> all you need is unsafeCoerce
03:11:58 <edwardk> ;)
03:14:25 <edwardk> :t (unsafeCoerce <*> unsafeCoerce) (unsafeCoerce <*> unsafeCoerce)
03:14:26 <lambdabot> Not in scope: `unsafeCoerce'
03:14:26 <lambdabot> Not in scope: `unsafeCoerce'
03:14:26 <lambdabot> Not in scope: `unsafeCoerce'
03:14:59 <edwardk> actulaly i suppose the ones after the <*>'s can be ids if you want
03:15:37 <edwardk> it bottoms out properly
03:16:58 <Taneb> How many languages are Turing-Complete with three instructions that are all in the standard library?
03:17:05 <Taneb> *serious languages
03:18:01 <edwardk> i look forward to reading your code comprised of pure, <*> and unsafeCoerce ;)
03:18:30 <Taneb> It'd be real-world useless, just how you need IO and main to make real-world useful Haskell programs
03:18:44 <Taneb> But I'll give it a go :P
03:19:52 <edwardk> meh, you just need to write a few combinators to read out your ints
03:20:03 <edwardk> and then you can do all your serious work in the SKI calculus
03:23:30 <danr> edwardk: lca-ski, next, then :)
03:25:23 <edwardk> danr: sounds rocking fast
03:25:49 <Taneb> Y combinator: ((pure (<*>) <*> pure) <*> pure (unsafeCoerce <*> unsafeCoerce)) <*> ((pure (<*>) <*> pure) <*> pure (unsafeCoerce <*> unsafeCoerce))
03:26:38 <Taneb> Where Y f == f (Y f)
03:26:51 <danr> Taneb: sweet unsafeCoerces
03:27:04 <Taneb> Note: I haven't tested this
03:28:11 <Taneb> unsafeCoerce <*> unsafeCoerce, if unsafeCoerce is taken to be equivalent to id, applies something to itself
03:28:45 <Taneb> fmap ($ 1) (unsafeCoerce <*> id $ (:[]) :: [Int -> [Int]]) ===[[1]]
03:30:53 <MagneticDuck> yo everyone. Little question: is there a better way to write (\x y -> [x, y])?
03:30:58 <MagneticDuck> I kind of imagine there should be one
03:31:21 <MagneticDuck> maybe something along the lines of "(:) . (:[])"?
03:31:28 <DrSyzygy> @pl (\x y -> [x,y])
03:31:28 <lambdabot> (. return) . (:)
03:31:35 <MagneticDuck> ah
03:31:41 <Taneb> MagneticDuck, pointless /= better
03:31:43 <MagneticDuck> the other way around
03:31:46 <MagneticDuck> well yes
03:31:47 <byorgey> MagneticDuck: there are other ways to write it.  I don't know of any better ones.
03:31:52 <Taneb> readable == better
03:31:59 <Taneb> I think what you have is perfectly readable
03:32:06 <sipa> :t (.[]).(:)
03:32:07 <lambdabot> forall a. a -> [[a]]
03:32:26 <MagneticDuck> > ((:[]) . (:)) 1 2
03:32:27 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
03:32:37 <MagneticDuck> > ((:) . (:[])) 1 2
03:32:38 <lambdabot>   No instance for (GHC.Num.Num [[a]])
03:32:38 <lambdabot>    arising from a use of `e_112' at <in...
03:32:52 <MagneticDuck> I have no idea what I'm doing. xD
03:33:07 <sipa> > ((.[]).(:)) 1 w
03:33:08 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[b]'
03:33:12 <sipa> > ((.[]).(:)) 1 2
03:33:13 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[b]'
03:33:21 <MagneticDuck> that's what I did
03:33:27 <MagneticDuck> > (:[]) 2
03:33:28 <lambdabot>   [2]
03:33:45 <MagneticDuck> > 1 : ((:[]) 2)
03:33:46 <lambdabot>   [1,2]
03:33:49 <sipa> > ((return []).(:)) 1 2
03:33:50 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
03:33:56 <MagneticDuck> same problem
03:34:07 <MagneticDuck> wait.. return []?
03:34:11 <MagneticDuck> that just gives [[]]
03:34:17 <sipa> yeah, typo
03:34:18 <MagneticDuck> > return []
03:34:19 <lambdabot>   No instance for (GHC.Show.Show (m [a]))
03:34:19 <lambdabot>    arising from a use of `M10276503...
03:34:23 <MagneticDuck> -_-
03:34:30 <sipa> > ((.return).(:)) 1 2
03:34:32 <lambdabot>   [1,2]
03:34:55 <sipa> unsure whether that's an improvement, though
03:34:59 <MagneticDuck> we need a kind of "ghcibot" here too. Not sure if that's easy to do though...
03:35:06 <MagneticDuck> yeah ty
03:35:16 <MagneticDuck> wait, let me work this out
03:35:24 <sipa> ghcibot? what is lambdabot doing wrong?
03:35:37 <MagneticDuck> well lambdabot is different
03:35:38 <MagneticDuck> that's all
03:35:43 <MagneticDuck> lambdabot is cool usually
03:36:25 <sipa> no, what would you like it to do in addition?
03:36:54 <MagneticDuck> ((.return).(:)) 1 2 == ((.return) ((:) 1)) 2
03:37:02 <MagneticDuck> oh great I'm stuck...
03:37:17 <MagneticDuck> I've done this type of thing before with for instance (const . (+1))
03:37:50 <MagneticDuck> well that's wrong...
03:38:55 <sipa> @unpl ((.return).(:))
03:38:55 <lambdabot> (\ d g -> ((:)) d (return g))
03:38:56 <MagneticDuck> 1 : (:[]) 2 == ((.return).(:)) 1 2
03:39:12 <MagneticDuck> which is 1 : (return) 2...
03:39:45 <MagneticDuck> 1 : ((return) 2)
03:39:53 <MagneticDuck> I don't see how I get to the pl
03:40:36 <MagneticDuck> btw I just need to understand this now, not giving a care to the utility of it
03:41:22 <MagneticDuck> let's try this again..
03:41:42 <MagneticDuck> ((.return).(:)) 1 2
03:41:50 <DrSyzygy> > ((.pure).(:)) 1 2
03:41:52 <lambdabot>   [1,2]
03:41:59 <MagneticDuck> I know
03:42:04 <MagneticDuck> I'm trying to work it out in my head
03:42:16 <MagneticDuck> how that's equal to 1 : ((pure 2))
03:42:16 <otters> :t (. pure)
03:42:17 <lambdabot> forall b a (f :: * -> *). (Applicative f) => (f a -> b) -> a -> b
03:42:23 <otters> :t (. pure) . (:)
03:42:24 <lambdabot> forall a. a -> a -> [a]
03:43:36 <MagneticDuck> oh
03:44:22 <MagneticDuck> and b (in our case) :: a -> f a
03:44:35 <MagneticDuck> so that's going to be what (. pure) . (:) returns
03:44:51 <MagneticDuck> interesting
03:45:49 <noor_> Hey guys what if I'm not a robot at all but a fractal wave function
03:45:56 <noor_> important
03:46:04 <adamt> I have a list of [TVar ChildApp], where ChildApp is a record with a field i want to _filter_ on (i want to preserve the original TVar's and end up with [TVar ChildApp] as result). Any ideas?
03:46:56 <simukis> Hello everyone, If I have type declaration `data Shape = Ellipse Point Float Float deriving (Show)`, how should I make Circle type which should return `Ellipse Point r r`?
03:47:06 <danr> adamt: filterM ?
03:47:23 <adamt> danr: Doesn't that only deal with a monadic filter function?
03:47:34 <adamt> or.. wait..
03:47:43 <adamt> i think that was just an epiphany right there. :-)
03:47:48 <danr> adamt: ok ;)
03:48:13 <adamt> danr: Thanks, i'll look at filterM once again :-)
03:48:54 <MagneticDuck> simukis: I'd make a circle function (:: Point -> Shape)
03:50:12 <MagneticDuck> making a "Circle" type might be useful if circles acted slightly different from just any Ellipse.
03:50:23 <MagneticDuck> I mean a Circle data constructor
03:50:24 <MagneticDuck> sry
03:51:29 <simukis> MagneticDuck, Thanks, going to try that.
03:51:34 <MagneticDuck> and btw "Point Float Float" is pretty silly if you ask me
03:51:47 <MagneticDuck> either (Float, Float) or Point Float
03:51:49 <MagneticDuck> or a vector
03:52:12 <simukis> MagneticDuck, Just learning from http://learnyouahaskell.com/making-our-own-types-and-typeclasses
03:52:24 <MagneticDuck> data Point a = Point a a
03:52:27 <MagneticDuck> ah
03:52:49 <MagneticDuck> it's a good tutorial
03:52:50 <MagneticDuck> ^^
03:54:39 <MagneticDuck> btw it really bothers me that "www.hoogle.com" was taken by a squatter site
03:54:55 <otters> same
03:55:17 <MagneticDuck> well actually it redirects to another squatter site "hypocrisy.com"
03:55:18 <MagneticDuck> -_-
03:55:34 <MagneticDuck> well actually it's not a squatter site
03:56:05 <fmap> simukis: types don't "return"
03:56:27 <MagneticDuck> well a data constructor can be thought of as a kind of function
03:56:35 <MagneticDuck> in fact, it is a function
03:56:39 <MagneticDuck> except that it's not
03:56:59 <MagneticDuck> it can be pattern matched
03:57:48 <MagneticDuck> btw we seem to have forgotten about noor_
03:58:02 <MagneticDuck> "Hey guys what if I'm not a robot at all but a fractal wave function"
03:58:06 <noor_> Hello
03:58:09 <noor_> :)
03:58:13 <MagneticDuck> :D
03:58:24 <MagneticDuck> I'd like to know what you mean by that. :P
03:58:36 <noor_> Not sure
03:58:39 <MagneticDuck> wait, you're human right?
03:58:49 <simukis> fmap, Just Circle is an Ellipse with only one radius parameter (unlike Ellipse), so I just want to make Circle same as Ellipse with two equal radiuses.
03:58:54 <osfameron> on the internet, nobody knows you're a fractal wave function
03:59:06 <MagneticDuck> or a duck
03:59:09 <MagneticDuck> I'm actually a duck
03:59:11 <MagneticDuck> no joke
03:59:17 <MagneticDuck> but I don't usually tell people
03:59:20 <osfameron> a magnetic duck, presumably
03:59:31 <MagneticDuck> I'm a duck who likes zen magnets
03:59:38 <noor_> Hello magnetic duck
03:59:49 <simukis> fmap, so calling `Circle (Point 0 0) 5` should return `Ellipse (Point 0 0) 5 5`
03:59:55 <MagneticDuck> magnetized ducks are quite a spectacle
03:59:56 <MagneticDuck> :x
04:00:21 <MagneticDuck> um, a data constructor doesn't work like that
04:00:33 <MagneticDuck> anything made with "circle" is a circle
04:00:37 <fmap> simukis: I'd make a function `circle' rather than another type
04:00:45 <MagneticDuck> that was my advice
04:00:48 <simukis> Now I understand that. Thanks.
04:00:53 <MagneticDuck> btw the function has to have a lowercase letter
04:01:03 <MagneticDuck> you probably know
04:01:10 <simukis> MagneticDuck, figured that out already
04:01:17 <MagneticDuck> coolo
04:01:24 <merijn> MagneticDuck: Do you have any clue how valuable hoogle.com probably is? People have suggested buying it, but it is probably ridiculously expensive
04:01:38 <MagneticDuck> really?
04:01:48 <merijn> h is right next to g
04:01:52 <MagneticDuck> xD
04:01:55 <MagneticDuck> LOL
04:02:08 <osfameron> yeah, and everyone knows how popular hoohle.com is
04:02:09 <merijn> Pageviews from typos most likely earn several k a month
04:02:23 <MagneticDuck> all the grandmas out there thinking, "hm, this doesn't seem like google. the internet is weird"
04:03:04 <MagneticDuck> hoohle.com?
04:03:26 <merijn> MagneticDuck: He's being funny by performing the wrong substitution for amusement :p
04:03:41 <MagneticDuck> oh
04:03:49 <MagneticDuck> this thing you call "humour"
04:03:51 <merijn> Or, at least trying to be funny
04:04:02 <MagneticDuck> heh
04:04:20 <MagneticDuck> although if you touchtype it's almost impossible to substitute the g for a h
04:04:46 <adamt> MagneticDuck: For some definitions of touch typing.
04:05:11 <MagneticDuck> well I'm not sure about non-qwerty keyboards
04:05:31 <sipa> at least azerty and qwerty also have g and h next to eachother
04:05:36 <sipa> and qwertz
04:05:49 <adamt> There's also 1-handed keyboards. :P
04:06:06 <MagneticDuck> heh
04:06:16 <danr> g and h are next to each other on dvorak, but on different rows
04:06:28 <MagneticDuck> nothing annoys me more then secretaries that only type with one hand
04:06:28 <sipa> what do you mean by touch-type, by the way?
04:06:43 <MagneticDuck> I mean being able to type faster then 60 wpm without looking down
04:06:52 <adamt> blind typing i hope. :)
04:06:54 <danr> sipa: having your fingers on asdf and jkl; (if using qwerty)
04:06:54 <MagneticDuck> that's my definition of someone who knows how to touchtype
04:07:24 <sipa> MagneticDuck: so that's over 5 keys per second?
04:07:33 <adamt> MagneticDuck: wikipedia agrees on your choice of words.
04:07:37 <sipa> i think i can do that with 2 fingers without looking at my keyboard
04:07:51 <Twisol> So Haskell just blew my mind yet again. Given a tuple of (String, Maybe a, [b]), I can turn it into a Maybe (String, a) like this: (\(x, y, _) -> (,) x <$> y)
04:07:53 <sipa> (which does have a risk for mixing g with h)
04:07:57 <Twisol> the bit that blew my mind is "(,) x <$> y"
04:08:05 <MagneticDuck> adamt: huh?
04:08:18 <MagneticDuck> sipa: 60 wpm is a "moderate geek"
04:08:42 <danr> you can try your typing speeds at for instance typeracer.com and typera.tk
04:08:53 <sipa> i believe i can do some 5-6 keys per second with two fingers
04:09:10 <MagneticDuck> sipa: I don't know anybody who can type at over 60 wpm with two fingers
04:09:14 <MagneticDuck> go and try it
04:09:30 <byorgey> Twisol: nice =)
04:09:37 <sipa> MagneticDuck: gotta go now; i'll try it later
04:10:12 <MagneticDuck> Twisol: Here's a few more that I've seen: "(const . (+1))" and just today "((.return).(:))"
04:10:23 <MagneticDuck> dat . operator is quite fun
04:10:29 <MagneticDuck> I like working them out on paper
04:10:34 <MagneticDuck> simplify them
04:10:43 <MagneticDuck> > (const . (+1)) 1 2
04:10:45 <lambdabot>   2
04:10:57 <MagneticDuck> > ((.return).(:)) 1 2
04:10:59 <lambdabot>   [1,2]
04:11:08 <MagneticDuck> note that they are both pl
04:12:12 <MagneticDuck> I'll add "(,) x <$> y" to the pile
04:12:39 <danr> @type fmap (x,)
04:12:40 <lambdabot> Illegal tuple section: use -XTupleSections
04:12:40 <lambdabot>     Ambiguous occurrence `x'
04:12:40 <lambdabot>     It could refer to either `L.x', defined at <local>:3:0
04:12:54 <MagneticDuck> @type (x, )
04:12:55 <lambdabot> Illegal tuple section: use -XTupleSections
04:12:55 <lambdabot>     Ambiguous occurrence `x'
04:12:55 <lambdabot>     It could refer to either `L.x', defined at <local>:3:0
04:13:08 <MagneticDuck> I'm using it like lisp again
04:13:09 <MagneticDuck> -_-
04:13:09 <Twisol> MagneticDuck: I'm going to have to figure those ones out. :S
04:13:17 <MagneticDuck> Twisol: They're pretty fun
04:13:19 <MagneticDuck> ^^
04:13:37 <Twisol> The one I came up with was a simplified version of something using >>=
04:13:39 <MagneticDuck> I love doing exercise like that
04:13:50 <MagneticDuck> want to work them out here?
04:13:51 <Twisol> it looked ugly so I put it in do notation, and noticed the possibility of <$>
04:13:53 <Twisol> Sure.
04:14:08 <MagneticDuck> again, I'm still a beginner
04:14:14 <hpaste> edwardk annotated “braun tree” with “Okasaki-style Braun Trees (annotation)” at http://hpaste.org/69640#a69644
04:14:23 <danr> this is my fav pointfree:
04:14:25 <danr> @type takeWhile (not . null) .: liftM2 (.) (map . take) (iterate . drop)
04:14:26 <lambdabot> forall a. Int -> [a] -> [[a]]
04:14:26 <MagneticDuck> going to really get back to haskell though this summer
04:14:30 <edwardk> er didn't mean to link that
04:14:39 <MagneticDuck> btw I have yet to understand (.).(.)
04:14:40 <MagneticDuck> :x
04:14:46 <MagneticDuck> I worked out the type
04:14:54 <MagneticDuck> but I don't quite see how to use it...
04:15:16 <Twisol> MagneticDuck: There's a StackOverflow question on it, though I admit I still don't fully get it. :P
04:16:30 <Twisol> my mind is bending trying to understand the second one you pasted
04:16:35 <theadmin> I apologize in advance for being stupid, but I'm new to the language and it's very different from any language I know... so is it just me or does Haskell really have no "variables" as such?
04:16:46 <Twisol> I admire point-free but it's not something I really strive for. More clarity really. :/
04:17:26 <cheater> theadmin: haskell has variables, technically they're immutable, but to change the value your code will see in a variable you just use a let block.
04:17:39 <Twisol> theadmin: Names bind more to expressions than to "values".
04:17:56 <cheater> > let x = 2 in let x = 3 in print x
04:17:57 <lambdabot>   <IO ()>
04:17:59 <cheater> erm.
04:18:06 <cheater> > let x = 2 in let x = 3 in x
04:18:07 <lambdabot>   3
04:18:07 <MagneticDuck> *cof cof cof*
04:18:11 <Twey> MagneticDuck: ((.) . (.)) f g h x = (.) (f .) g h x = ((f .) .) g h x = ((f .) . g) h x = (f .) (g h) x = (f . g h) x = f (g h x)
04:18:22 <theadmin> I see, hm... Kind of confusing since I don't see how any sort of loops will work then
04:18:24 <MagneticDuck> Twey: I'll add that to my pile!! ty
04:18:26 <Twey> (.) has this sort of ‘stacking effect’
04:18:31 <MagneticDuck> theadmin: recursion
04:18:47 <MagneticDuck> theadmin: functional languages are way different
04:18:58 <Twey> I think of it as the argument to the right sort of pushing itself back across the dots until it hits something free, then popping up on top of it — like if you try to push a bundle of straws together :þ
04:19:08 <MagneticDuck> heh
04:19:12 <MagneticDuck> nice
04:19:12 <theadmin> MagneticDuck: I noticed that already :) So I'm trying to understand this and it makes my head hurt
04:19:14 <cheater> Twey: i think there should be a tutorial, or guide, to combinations that use . and $ in a point-free manner.
04:19:18 <Twey> Probably
04:19:26 <Twisol> theadmin: Coming at it from an imperative viewpoint is hard. Try not to think of it as "this only works if you have that" - there are other ways to do it :)
04:19:34 <cheater> Twey: at least a master list.
04:19:48 <Twey> theadmin: Haskell has ‘variables’ in the sense of things that vary between function calls
04:19:48 <theadmin> Twisol: tmtowtdi, heh, I know that one.
04:20:01 <Twisol> No clue what that stands for :)
04:20:19 <theadmin> Twisol: There's more than one way to do it (that's the perl motto, sorry, that's just where I'm coming from)
04:20:23 <Twisol> ah, gotcha.
04:20:46 <Twey> theadmin: f x = let y = x + 2 in …; if you call ‘f 3’ then y is 5, but if you call f 5 then y is 7 — it varies
04:21:03 <Twisol> theadmin: Two of the fundamental "loop-ish" operations are fold and map. A fold takes a list and an initial value, and a function (think "loop body") that operates on the current value and an accumulator
04:21:24 <Twey> theadmin: Haskell (or rather, Haskell's IO and STM languages) also has ‘variables’ in the imperative sense of mutable cells that can have their values changed
04:21:47 <cheater> theadmin: using fold is like using a "foreach" in other languages
04:21:59 <Twey> cheater: ITYM s/fold/map/
04:22:02 <MagneticDuck> umm..
04:22:05 <adamt> cheater: isn't that a stretch? :P
04:22:11 <Twey> Well… I guess it depends what you do in the loop body
04:22:12 <cheater> theadmin: whereas using "map" us like using foreach while building a new array
04:22:14 <Twisol> A map basically applies a function to every element of a list.
04:22:16 <cheater> adamt: no.
04:22:28 <theadmin> cheater: I know "map" (Perl has that and I use it now and then), but I see
04:22:31 <cheater> Twisol: yes, but it builds a new list.
04:22:32 <Twisol> [1, 2, 3], mapped over (*2), gives [2, 4, 6]
04:22:37 <adamt> cheater: i see what you did there.
04:22:56 <Twey> I don't like this
04:22:59 <Twisol> cheater: I'm not really involved in that half of the discussion :)
04:23:06 <Twey> theadmin: A fold is a fold and a map is a map
04:23:08 <Twisol> cheater: just introducing a couple things
04:23:11 <adamt> they obviously don't map 1:1
04:23:14 <theadmin> Twey: ok...
04:23:24 <MagneticDuck> and then fmap... applies a function that changes the data inside some box! In the case of a list, it applies that function to all the elements in the box, in the case of maybe it maybe applies them to the value...
04:23:25 <adamt> so what a fold and map reminds about, depends on the context..
04:23:38 <theadmin> Well, guess I just have to grasp new concepts and forget all I know about programming so far
04:23:44 <MagneticDuck> theadmin: heh
04:23:45 <Twisol> MagneticDuck: aww, now don't throw functors at a newcomer :)
04:23:49 <theadmin> This stuff is confusing as hell I have to admit >.<
04:23:56 <MagneticDuck> Twisol: Yeah, sorry. ^^
04:24:04 <Twisol> theadmin: Have you read any Haskell material?
04:24:09 <Twisol> Like "Learn You A Haskell"?
04:24:15 <MagneticDuck> I'd start with that
04:24:19 <MagneticDuck> it's very easy to follow
04:24:22 <Twisol> I bought the book, but it's online also. :)
04:24:23 <Twey> theadmin: Recursion is equivalent to loops.  Once you understand how to use recursion as a looping structure, you'll notice that a lot of the time you write certain patterns (where you're combining all the elements of a list into a new value one by one, or transforming each element of the list into something else) and two of those patterns (the examples, respectively) are fold and map.
04:24:24 <theadmin> So currently I had ghc complain about "indentation" at me now and then, so indentation matters in haskell? No one liners then?
04:24:25 <MagneticDuck> and has lots of... *ahem* images
04:24:36 <MagneticDuck> in fact, loops are recursion
04:24:38 <Twisol> theadmin: Oneliners are possible if you know where to add {} and ;
04:24:42 <Twey> theadmin: Indentation matters optionally
04:24:44 <Twisol> theadmin: but yes, in general layout is 2D
04:25:08 <MagneticDuck> well it's not as bad as python I don't think
04:25:09 <cheater> theadmin: you can have oneliners as long as you want, but indentation is important if you use multiple lines. the simplest way to handle indentation that i have found is to use banner style indent.
04:25:09 <MagneticDuck> ^^
04:25:15 <Twey> theadmin: You can write Haskell with braces and semicolons, which is useful for IRC.  If you don't add braces and semicolons, the compiler will use indentation to figure out where to add them for you.
04:25:18 <osfameron> haskell indentation rules are nice
04:25:24 <Twisol> MagneticDuck: Any iterative process can be reformulated as a recursive process. :D
04:25:26 <osfameron> I like that you have the optional getout with {;;;}
04:25:33 <MagneticDuck> Twisol: My point
04:25:34 <theadmin> Ah, I see, kind of a mix between Python and C-style then, Twey
04:25:40 <Twey> In practice, most people writing Haskell to files use the indentation rules, because as a rule we don't like to clutter our code
04:25:43 <cheater> hey guys, is there a good place where i could learn how to use enumerator?
04:25:52 <cheater> i need basic use help
04:26:03 <Twey> cheater: AIUI enumerators are effectively superseded by conduits
04:26:13 <Twisol> and/or pipes
04:26:15 <theadmin> So can anyone suggesta  good tutorial? I'm trying to find some but they all stick to ghci and don't tell me anything about real source code for a long time >.<
04:26:27 <Twisol> theadmin: http://learnyouahaskell.com/
04:26:27 <MagneticDuck> theadmin: lyahfgg
04:26:28 <Twey> theadmin: GHCi is a good place to start
04:26:35 <cheater> Twey: i want to use snap framework which uses enumerators and not conduits.
04:26:38 <Twisol> Twey: GHCi has a tutorial?
04:26:43 <MagneticDuck> well yes, you should learn the basics of GHCi first
04:26:49 <theadmin> Twisol: Tried that one
04:26:49 <MagneticDuck> yes, they have a bit thing on how to use ghci
04:27:01 <MagneticDuck> theadmin: what was the problem>
04:27:02 <Twisol> theadmin: Was there a particular problem with LYAH?
04:27:03 <MagneticDuck> ?
04:27:11 <MagneticDuck> I liked it
04:27:14 <Twey> theadmin: If you want to jump straight into coding actual programs, you can try RWH ( http://book.realworldhaskell.org/ ) — but even so I recommend playing around in GHCi too.
04:27:22 <theadmin> Twisol: Well, I want to learn how to write real source, interactive shells aren't really my kinda thing
04:27:36 <cheater> Twey: speaking of conduits, do you know if it's possible to make conduits stream through a file while ensuring the max memory usage by a conduit does not reach a certain amount?
04:27:37 <simukis> Where in haskell source I can find definition of `pi`? What actually interests me is how accurate pi in haskell is.
04:27:43 <Twisol> theadmin: LYAH is largely unrestricted to a single method of running things.
04:27:43 <Twey> theadmin: GHCi is integral to most Haskell development workflows
04:27:47 <MagneticDuck> um, well you should at least go through LYAH first
04:27:52 <MagneticDuck> *ahem*
04:27:54 <MagneticDuck> that is, GHC
04:27:56 <Twisol> theadmin: It is a good idea to use ghci to run small snippets, play around
04:28:00 <Twey> cheater: No.  Garbage collection.
04:28:08 <Twisol> theadmin: but you can always put Haskell in a file and use the `runhaskell` program to execute it
04:28:16 <cheater> Twey: i was told an enumerator could do that, do you know anything about this?
04:28:34 <theadmin> Twisol: I see, well, I'll play around and will come back when I try to figure out how to ask... sane questions
04:28:38 <Twisol> theadmin: biggest issue in my opinion is mindset. :)
04:28:41 <MagneticDuck> btw RWH if you ask me goes a little too fast for someone who has no experience in haskell...
04:28:46 <Twey> cheater: It can guarantee that no references are kept around (so can conduits) but there are no guarantees on when the GC will run
04:28:46 <cheater> theadmin: just start your script with #!/usr/bin/env runhaskell
04:29:01 <cheater> theadmin: there are some more advanced things that don't work in this way though
04:29:03 <Twisol> theadmin: and LYAH is excellent for nurturing a Haskell mindset, even if you don't necessarily do a lot in ghci with it
04:29:05 <fmap> simukis: `pi' is a typeclass method
04:29:11 <cheater> Twey: how does conduits guarantee that?
04:29:13 <fmap> so accuracy depends on type
04:29:29 <theadmin> Twisol: I see, well, I'll look around that as well then
04:29:38 <fmap> simukis: http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/src/GHC-Float.html#Floating
04:29:41 <Twey> theadmin: My usual approach to coding big or complicated Haskell functions is to formulate my functions iteratively in GHCi, then copy/paste them into my source file (and reformat them nicely, obviously).
04:29:43 <MagneticDuck> lol this is moving fast
04:29:51 <Twisol> I think we overwhelmed him a bit :P
04:29:55 <MagneticDuck> heh
04:29:59 <MagneticDuck> usually it's not this crazy
04:30:06 <MagneticDuck> well I'm going for a walk
04:30:13 <Twisol> really easy to confuse people when they have no idea how haskell even works :D
04:30:16 <Twisol> I'm going to bed ;P
04:30:18 <Twisol> night
04:30:20 <MagneticDuck> cyall later
04:30:24 <MagneticDuck> gnight Twisol
04:30:32 <fmap> > pi :: Double
04:30:34 <lambdabot>   3.141592653589793
04:30:35 <fmap> > pi :: CReal
04:30:36 <lambdabot>   3.1415926535897932384626433832795028841972
04:31:10 <MagneticDuck> yes, theAdmin, don't get discouraged. Also, I'd reccomend working through H99 and / or project euler to get your haskell skills sharp
04:31:19 <simukis> fmap, thanks again.
04:31:19 <cheater> he's gone
04:31:23 <MagneticDuck> and along the way you're sure to learn something
04:31:30 <cheater> Twey: any idea how conduits ensure no refs are left behind?
04:31:41 <cheater> Twey: (i think my previous comment got buried)
04:31:53 <cheater> MagneticDuck: he's been gone for several minutes.
04:31:57 <Twey> cheater: Uhh, I don't know the concrete implementation details of conduits, but I will make a guess that conduits internally looks a lot like iteratee — a sink collects data from the source until it has enough to do whatever computation it wants to do, then drops it all.  The source then doesn't have to keep track of the data it's read.
04:32:09 <cheater> Twey: mhm
04:32:34 <Twey> (‘all’ modulo the excess, if any)
04:33:37 <Twey> That's how you get deterministic resource freeing, too (in the opposite direction) — when the sink returns a value indicating it's finished with the data, the source can finalize the input resource
04:34:02 <Twey> It's just that in the case of Haskell types, there's no explicit finalization: finalizing it just means removing the reference to it and letting the GC do its thing
04:34:30 <Twey> You could call the GC manually, but that's probably not what you want (it'll keep the memory low at the cost of making your program dog-slow and CPU-hungry)
04:34:40 <hpaste> Taneb pasted “S, K, I” at http://hpaste.org/69645
04:35:01 <Twey> In a GC language, you basically just have to trust that the GC will do the right thing so long as you don't leave references lying around
04:35:18 <Taneb> Damn, edwardk left
04:35:33 <Taneb> But any fans of obfuscation, look at that
04:35:37 <Twey> Probably got offended by my talking out of my arse about conduits ;)
04:35:39 <MagneticDuck> I saw that Taneb
04:35:42 <MagneticDuck> I'm going for a walk now
04:35:50 <Taneb> :)
04:36:04 <MagneticDuck> but I'm going to print it out first
04:36:10 <Taneb> It's sillily simple
04:36:17 <MagneticDuck> ah
04:36:21 <MagneticDuck> I haven't looked really yet
04:36:23 <Taneb> All it does is reads 2 numbers and prints x^y
04:36:37 <Twey> Taneb: HLint thinks you should replace those lambdas with sections.  :þ
04:36:41 <Taneb> I know
04:36:51 <Taneb> No, it's not the lambdas
04:36:57 <Twey> Oh, is it not?
04:37:08 <Taneb> ((<*>) (pure (<*>) <*> pure)) isn't a lambda
04:37:12 <Twey> Oh, yeah, just saw that
04:37:20 <povman> does anyone here use homebrew?
04:37:25 <Twey> I guess it wants ((pure <*> <*> pure) <*>)
04:37:28 <Twey> Not sure how that's better
04:37:36 <Twey> I guess you save one set of brackets
04:38:04 <Twey> Er
04:38:29 <Twey> By which I meant ((pure (<*>) <*> pure) <*>), of course
04:39:14 <Taneb> :t ((pure (<*>) <*> pure) <*>)
04:39:15 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => ((a -> b) -> f a) -> (a -> b) -> f b
04:39:28 <Taneb> :t (pure (<*>) <*> pure <*>)
04:39:29 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => ((a -> b) -> f a) -> (a -> b) -> f b
04:39:58 <Taneb> Two sets of brackets :)
04:40:59 <cheater> anyone know of any good examples explaining enumerator?
04:41:38 <Taneb> I don't even know what enumerator is
04:41:46 <Twey> cheater: http://www.mew.org/~kazu/proj/enumerator/ maybe
04:42:12 <cheater> interesting, i haven't stumbled across this link when googling
04:43:31 <Twey> First one off Google ;)  Looks pretty good.
04:46:33 <Maerten> povman: yes i do
04:47:36 <Taneb> I'll try to make a pure-(<*>)-unsafeCoerce program to print fibonacci numbers
04:51:05 <povman> Maerten: I was wondering how you specify library paths for dylibs
04:51:16 <navaati> … hahahahaha, arriving on the chan an seeing Taneb's last message is, well… source of good mood
04:51:16 <navaati> /me loves #haskell
04:51:50 <unnali> :D
04:52:06 <Taneb> navaati, Haskell is turing complete with just pure, (<*>), and unsafeCoerce
04:52:09 <povman> Maerten: it seems a bit much to need to add all the /usr/local/Cellar/blah/lib
04:52:42 <Maerten> povman: sorry i have no idea, all i do is 'brew install' and it works ;p although i think i installed haskell by compiling it myself
04:52:49 <povman> heh ok
04:55:39 <hpaste> edwardk annotated “braun tree” with “Okasaki-style Braun Trees (annotation) (annotation)” at http://hpaste.org/69640#a69647
05:03:43 * hackagebot lca 0.2.1 - O(log n) persistent on-line lowest common ancestor calculation without preprocessing with optional monoidal annotations  http://hackage.haskell.org/package/lca-0.2.1 (EdwardKmett)
05:04:02 <hpc> is it acceptable to put ghc-related tools that aren't ghc into the GHC.* module heirarchy?
05:04:37 <povman> oh my gosh, the factor GUI tools are amazing. we need them for haskell.
05:06:31 <povman> you can type code in and click c-h to view the help for whatever word the cursor is on, and it automatically imports libraries for you
05:07:56 <povman> makes ghci look stone-age
05:09:17 <povman> except that language is impossible to read or write
05:14:49 <danr> povman: there is such functionality when using haskell in emacs, i presume
05:22:07 <unnali> povman: bi bi dup bi * + concat <array> bi* nip
05:23:26 <povman> unnali: that is a very complex function
05:24:13 <unnali> probably "id" or something
05:24:33 <povman> so much irony
05:24:48 <adamt> :t (==)
05:24:49 <lambdabot> forall a. (Eq a) => a -> a -> Bool
05:24:58 <adamt> d'oh of course.
05:36:18 <Felixz> Hi all
05:36:25 <MagneticDuck> yo
05:36:47 <Felixz> I'm new to Haskell
05:37:04 <byorgey> Felixz: welcome!  feel free to ask questions here
05:37:08 <Felixz> Hi magne
05:37:33 <Felixz> Thanks boy
05:37:43 <Felixz> Thanks byo
05:41:30 <theadmin> Allright, I'm sort of back... Can anyone help me figure out how to convert indentation to braces-and-semicolons? I'm confused because my typical ideas don't work again.
05:42:21 <unnali> theadmin: can you give us an example of what you're trying to convert?
05:43:16 <Botje> give in to indentation.
05:43:22 <Botje> it wants to love and cherisch you
05:44:39 <hpaste> theadmin pasted “Indentation mess” at http://hpaste.org/69648
05:44:46 <theadmin> unnali: ^
05:44:56 <theadmin> I don't just understand how it works >.<
05:46:02 <unnali> theadmin: you're very close.
05:46:10 <unnali> The only thing missing is that 'let' expects a layout block.
05:46:26 <theadmin> unnali: Ah, so I should do something along the lines of let { x = 5; } ?
05:46:30 <unnali> so try adding braces like 'let { x = 5 };' or 'let { x = 5; };'
05:46:52 <Taneb> Okay, this style of programming is nigh-impossible to debug
05:47:05 <Taneb> I've got a program which should print the fibonacci sequence
05:47:20 <Taneb> Instead it prints 33554697 and then hangs
05:48:27 <theadmin> unnali: Makes sense, thanks, gee I wish ghc's errors would make any sense
05:49:09 <Taneb> This is the problem with obfuscation
05:49:45 <unnali> theadmin: ;) they're not 100% helpful in this case
05:50:01 <unnali> I find its errors about things other than syntax pretty good
05:50:13 <unnali> but I would recommend Botje's advice re: indentation wanting to love you.
05:50:19 <mm|swarm> theoretical question: (==) is overloaded or polimorphic?
05:50:23 <mm|swarm> *polymorphic
05:50:38 <theadmin> unnali: That's how I'll do it with files indeed, but if I want to share code over IM or something that just doesn't always work
05:50:40 <hpaste> stj pasted “playing with monad transformers -- how to plug in this function? I'm doing something wrong” at http://hpaste.org/69649
05:51:10 <unnali> theadmin: true; that said, for anything decently long, there's always hpaste. (or writing in a uh, layout-agnostic fashion >__>)
05:51:51 <theadmin> unnali: Well, I'm not really into Haskell yet, I just started, it's confusing the heck out of me
05:52:45 <S11001001> mm|swarm: it's polymorphic but constrained
05:53:19 <unnali> theadmin: I know the feeling. :3
05:53:56 <S11001001> mm|swarm: overloaded would mean that you didn't have to follow the basic a -> a -> Bool pattern, but you do, so it's not
05:53:57 <theadmin> unnali: Might have been easier to start if I didn't know other programming languages already
05:54:04 <adamt> theadmin: GHC 7.4.1 gives really really good error messages, maybe you should upgrade.
05:54:16 <mm|swarm> S11001001: thanks
05:54:29 <theadmin> adamt: I'm on Arch :P (meaning: I already have 7.4.1)
05:54:39 <unnali> theadmin: probably, but in the end the extra experience will help.
05:55:32 <pooya72> when is the haskell-platfor going to be on homebrew (mac)?
05:55:47 <pooya72> the new haskell-platform that is...
05:56:01 <unnali> pooya72: whenever someone updates it, I guess :)
05:56:20 <unnali> pooya72: oh! It looks like it's already there.
05:56:31 <unnali> https://github.com/mxcl/homebrew/commit/550a2fa83098dd037d9e847a04fb7a939baf6e1d#Library/Formula/haskell-platform.rb
05:56:40 <unnali> pooya72:  brew update
05:57:59 <pooya72> brew upgrade haskell-platform FTW!!!
05:58:13 <pooya72> unnali: thanks! didn't notice it was upgraded!
05:58:49 <unnali> no probs! Neither did I 'til I thought it might've been!
05:59:15 <fmap> stj: type State s = StateT s Identity
05:59:51 <stj> fmap: I realize that, but can you suggest what should I modify to make this function "roll" fit in?
06:00:23 <stj> I'm still building my intuition for monads and monad transformers
06:03:39 <unnali> stj: http://stackoverflow.com/questions/4138671/combining-statet-and-state-monads
06:03:43 <unnali> In short: it cannot be done generally.
06:04:46 <unnali> stj: nasty hack: use "state <- get" "let a = evalState roll state"
06:05:27 <unnali> (or in short: "evalState roll `liftM` get")
06:05:39 <unnali> blah, a <- evalState roll `liftM` get
06:06:45 <fmap> and btw m >>= return ≡ m
06:07:17 <fmap> (should be)
06:07:44 <stj> thanks, I'll look into this
06:07:58 <unnali> stj: an alternative is to type roll like this: "roll :: Monad m => StateT StdGen m Int"
06:08:12 <unnali> then you can use it without modification, i.e. "a <- roll"
06:08:18 <unnali> as long as you're using it in a StateT.
06:08:39 <unnali> (replace Int for whatever you're wanting from `random')
06:08:40 <quicksilver> am I missing context? Why not MonadState m StdGen => m Int ?
06:08:58 <unnali> whups, best. ^^
06:09:43 <quicksilver> some people have suggested "hoist" for the name of the combinator which lets you run a State action in an abitrary MonadState.
06:09:52 <quicksilver> unnali's unrolled version looks buggy, it doesn't update the rng state.
06:10:00 <deggis> uh. linker errors and cabal-dev: any ideas on why compiling this as cabal executable works like a charm but fails with linker errors when compiled using ghc -package-conf=[cabal-dev sandbox] http://hpaste.org/69652 ?
06:10:07 <dolio> useAPulleySystem
06:10:32 <osfameron> or an archimedes screw
06:11:11 <quicksilver> ( http://www.haskell.org/pipermail/haskell-cafe/2008-March/040892.html and the thread around it )
06:11:14 <Taneb> So yeah, in my attempt to write programs where all the computation was done by pure, (<*>), and unsafeCoerce, I've written a program which does exactly what it shouldn't
06:11:49 <unnali> Taneb: why does this not surprise?
06:12:03 <Taneb> Oh, it doesn't surprise me at all
06:12:45 <unnali> :)
06:12:56 <Taneb> And I've just realised my mistake
06:13:56 <quicksilver> ( a further note to stj, and unnali, if you have lots of randomnes which might not *necessarily* be as simple as a StdGen in a StateT, a more abstract class like 'MonadRandom' is advised )
06:14:28 <unnali> quicksilver: ta. :)
06:15:30 <Taneb> I wrote left l instead of l left
06:15:33 <stj> quicksilver: okay :)
06:15:36 <Taneb> Which makes a lot of difference
06:15:49 <stj> oh my, I've been learning haskell for months and I'm still a total noob
06:16:33 <unnali> stj: if that feeling never changes, you're probably doing something right.
06:19:09 <mwcampbell> I want to install a recent version of the Haskell Platform (with GHC 7) on Ubuntu 10.04. It's looking like the only way to do that is to install GHC 7 from a generic Linux binary package, then install the Haskell Platform from source. Anyone know an easier way?
06:19:12 <mwcampbell> on Ubuntu 10.04
06:21:08 <hughfdjackson> iii upgraded
06:21:17 <hughfdjackson> almost exclusively to run haskell
06:21:25 <cheater> mwcampbell: no, that is the only way to do this
06:21:35 <quicksilver> cheater, mwcampbell: well there are prerelease haskell-platforms in the other ubuntu repos, aren't there?
06:21:54 <geekosaur> for 10.04?
06:21:57 <cheater> i don't care about other ubuntu versions because i only use 10.04 thererfore i can't answer the question
06:22:17 <geekosaur> although I suppose a backport is possible
06:22:25 <quicksilver> oh, 10.04
06:22:50 <quicksilver> yes I imagine you'll have to install from source on ubuntus that old
06:22:58 <quicksilver> unless someone decides to backport
06:23:50 <quicksilver> ( nothing in lucid-backports : http://packages.ubuntu.com/search?suite=lucid-backports&keywords=haskell-platform )
06:24:33 <mwcampbell> oh well, my current 10.04 install is old and crufty enough that I guess I'm better off starting fresh with 12.04 anyway
06:25:11 <Taneb> Well, it's done it again
06:25:23 <Taneb> It prints 33554697 and segfaultws
06:25:41 <quicksilver> the day people began starting again and reinstalling is the day Linux lost its way
06:26:00 <quicksilver> I've a linux machine upgraded since 1998 and it's not needed a reinstall.
06:26:29 <k-zed> quicksilver: is it running udev, pulseaudio or gnome3? ;)
06:26:47 <quicksilver> of those three, only udev.
06:27:00 <unnali> anyone have any idea why haddock's "ignore-exports" doesn't do what I want? It generates documentation headers for non-exported top-level declarations, but doesn't actually include the documentation itself for them! :|
06:27:02 <Taneb> Which means I have an erroneous unsafeCoerce somewhere
06:27:39 <unnali> and --internal to cabal haddock seems to do nothing at all.
06:31:02 <unnali> seems to happen whether I call haddock directly or via cabal, though.
06:33:10 <lazyfinn> hey, I was here yesterday askin about nested foreach loops, got something here, but I'm not sure if this is correct, can someone check, please?
06:33:13 <hpaste> lazyfinn annotated “nested foreach” with “nested foreach (annotation)” at http://hpaste.org/69613#a69653
06:33:32 <merijn> quicksilver: Ironically Windows 7 has reached the point where I don't really feel compelled to reinstall it :p
06:34:16 <merijn> lazyfinn: Needs more list comprehension/list monad :>
06:34:30 <lazyfinn> the part before 'head' returns a list of lists for some reason
06:34:35 <lazyfinn> I don't need that
06:34:54 <flux> ah, the foreach code is pseudo-haskell?
06:34:56 <merijn> Also, could probably use some line breaks
06:35:00 <flux> or actual haskell?-o
06:35:06 <lazyfinn> merijn: more? I barely handle it already)
06:35:20 <lazyfinn> flux: pseudo code
06:35:24 <lazyfinn> not even haskell :)
06:36:00 <merijn> Lemme see what I can make of it
06:36:37 <hpaste> “Haddock not playing ball” pasted “unnali” at http://hpaste.org/69654
06:37:34 <byorgey> lazyfinn: what does the (-1) mean
06:37:35 <byorgey> ?
06:37:56 <lazyfinn> byorgey: nothing, just an integer
06:38:02 <WraithM> @pl (\t -> exp (-t))
06:38:02 <lambdabot> exp . negate
06:38:22 <byorgey> lazyfinn: I know, I meant, does it indicate something special? Like, the passenger is not in a bus?
06:38:38 <lazyfinn> byorgey: yep
06:38:40 <byorgey> lazyfinn: if so, you should use  Maybe Int  instead of  Int
06:39:00 <byorgey> Then use Nothing to indicate that someone is not in a bus
06:39:47 <byorgey> though perhaps you are trying to port the code from Java as literally as possible, but I don't think that's a good idea =)
06:44:43 <Peaker> pretty annoying that "unused variable 'x'" is only issued when no type errors
06:44:54 <Peaker> so many types I have type errors because I forgot to remove the parameter after eta reduce, or such stuff
06:44:55 <merijn> lazyfinn: What is the output type supposed to be?
06:45:33 <WraithM> @pl (\t -> exp (-t) :+ 0)
06:45:33 <lambdabot> (:+ 0) . exp . negate
06:45:35 <hpaste> merijn annotated “nested foreach” with “nested foreach (annotation) (annotation)” at http://hpaste.org/69613#a69655
06:45:37 <lazyfinn> merijn: [Passenger]
06:45:45 <merijn> lazyfinn: This is still not very haskelly
06:45:52 <merijn> But much better than the original one
06:46:02 <merijn> (mind you, I transcoded from the pseudocode, not the haskell)
06:46:27 <merijn> But it should give you an idea of what you could do
06:46:58 <lazyfinn> merijn: emm.. no maps, no loops?
06:47:02 <lazyfinn> just like that?
06:47:02 <Peaker> could also be nice if you could ask a newtype to derive Show via GeneralizedNewtypeDeriving rather than via the ordinary Show that's so verbose
06:47:13 <merijn> lazyfinn: It uses map, but it is hidden
06:47:21 <merijn> lazyfinn: I'm using the List monad
06:47:27 <merijn> (hence the do notation)
06:47:32 <lazyfinn> oh
06:47:39 <merijn> The behaviour of the list monad is pretty much foreach
06:47:59 <merijn> The code unsugars as follows:
06:48:20 <merijn> @undo do {v <- vehicles; p <- passengers; foo v p }
06:48:20 <lambdabot> vehicles >>= \ v -> passengers >>= \ p -> foo v p
06:48:43 <merijn> The type of (>>=) is
06:48:46 <merijn> :t (>>=)
06:48:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
06:49:37 <merijn> Given an "m a" and a function "a -> m b" give me an "m b", translated to lists specifically it is "[a] -> (a -> [b]) -> [b]", which should look suspiciously like foreach
06:49:44 <Nimatek> :t concatMap
06:49:45 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
06:50:43 <lazyfinn> merijn: ok, thanks
06:50:46 <merijn> lazyfinn: Basically in the list monad the behaviour of "<-" is identical to "execute the below block for each value", nested them like this is thus identical to your original nested foreach
06:50:49 <unnali> @src [] (>>=)
06:50:49 <lambdabot> xs >>= f     = concatMap f xs
06:51:09 <unnali> indeed, list's (>>=) is defined in terms of concatMap.
06:51:15 <lazyfinn> mm I see
06:51:32 <Peaker> :t asTypeOf
06:51:33 <lambdabot> forall a. a -> a -> a
06:51:59 <merijn> lazyfinn: Studying and playing with the list and Maybe instance of Monad can drastically simplify this sort of code as you see :)
06:52:34 <Peaker> @type (fmap . fmap) (`asTypeOf` [])  (=<<)
06:52:35 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
06:53:12 <merijn> Peaker: And here I'm trying to make all this stuff look accessible... :p
06:53:21 <Peaker> heh
06:53:38 <Peaker> @type [(=<<), concatMap]
06:53:39 <lambdabot> forall a b. [(a -> [b]) -> [a] -> [b]]
06:53:47 <Peaker> Easier way of getting to what I wanted :)
06:54:06 <unnali> Peaker: woah.
06:54:29 <Peaker> unnali, shows that Haskell can unify the types of those -- that the types match
06:54:34 <Peaker> @type (=<<)
06:54:35 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
06:55:04 <Peaker> unnali:   in the type of (=<<) which is (ignoring the constraints part)     "(a -> m b) -> m a -> m b"    replace every "m a"  with [a]
06:55:20 <Peaker> @src (=<<)
06:55:20 <lambdabot> f =<< x = x >>= f
06:55:26 <Peaker> pallindrome!
06:55:31 <merijn> Well, having sufficiently blown minds it is time to get back to work :p
06:56:41 <unnali> Peaker: yup, I just hadn't thought of using a list like that to do it; but it's indeed illustrative.
07:06:38 <stepkut> how do I actually get my monads for Free? if I have a function like, data Ask question a = forall x. Ask (question x) (x -> a), what do I do next? Do I just do, type Prompt a = Free (Ask question) L
07:06:51 <stepkut> s/ L / ? /
07:07:05 <shapr> a s l?
07:07:13 <Gurragchaa> TANSTAAFM
07:07:14 <stepkut> :)
07:07:24 <WraithM> No such thing as a free monad?
07:07:30 <WraithM> Yes.
07:07:31 <Gurragchaa> I kid
07:09:21 <Saizan> stepkut: question is out of scope in Prompt, but yes otherwise
07:09:36 <danr> also Free, but yes
07:10:15 <Saizan> type Prompt q a = Free (Ask q) a
07:10:21 <stepkut> Saizan: oops. I meant, type Prompt question a = Free (Ask question)
07:11:36 <stepkut> oo, no that is wrong too
07:11:47 <stepkut> type Prompt question = Free (Ask question)
07:12:18 <stepkut> or, I could use a newtype and derive Monad
07:13:55 <S11001001> if it was really free I wouldn't have to write functor
07:15:08 <Saizan> use Yoneda to get Functor for free :)
07:16:09 <merijn> Monads for Large Discounts?
07:23:00 <stepkut> How do I actually get rid of the 'Free' later and get back the 'a' from 'Prompt q a' ?
07:23:20 <stepkut> I have a function like, runAsk :: (Functor q) => Ask q a -> q a
07:24:42 <d-snp> I master liftM! :P
07:25:13 <byorgey> stepkut: use 'iter' perhaps?
07:25:25 <byorgey> iter :: Functor f => (f a -> a) -> Free f a -> a
07:25:34 <stepkut> ah
07:25:43 <byorgey> hmm, maybe that's not quite what you want?
07:27:06 <Saizan> cata for Free f a would be (f r -> r) -> (a -> r) -> r
07:27:51 <stepkut> iter is almost right
07:28:00 * stepkut has to run, bbl
07:28:26 <byorgey> well, I guess iter will work if you compose runAsk with something else that eliminates the q
07:29:47 <Saizan> stepkut: you should check the posts on comonad.com
07:30:36 <stepkut> Saizan: i'll look again. Many of those posts define the Free monad, but never show how to actually use it
07:31:02 <stepkut> i'm trying to figure that out and then I'll make a blog post :)
07:32:19 <stepkut> "How to actually get those Free monads" or something
07:33:01 <Saizan> http://comonad.com/reader/2011/free-monads-for-less-3/ <- mh, i thought this had some more examples
07:33:54 <Saizan> http://apfelmus.nfshost.com/articles/operational-monad.html <- this one has a bunch for Prompt specifically
07:35:24 <Saizan> stepcut: ^^^^ -- so you see it later
07:36:14 <stepkut> the free monads one shows how to make 'foo', but i am not sure if it shows how to actually 'execute' it
07:36:16 <stepkut> bbl.
07:37:57 <Saizan> yeah, the operational one has them
07:39:55 <merijn> I'm importing Data.Map but GHC complains that it cannot find foldr, any suggestions?
07:40:46 <merijn> (I'm hiding the one from Prelude, hence the out of scope error rather than confusion between the two)
07:41:22 <fmap> containers version?
07:41:22 <rwbarton> are you importing Data.Map unqualified?
07:42:16 <rwbarton> ah yes fmap is probably right, it seems that Data.Map.foldr was formerly named fold
07:42:56 <merijn> fmap, rwbarton: Excellent, that works
07:43:00 <merijn> Or rather, compiles
08:00:06 <Siod> what's the right way to do sprintf in haskell? eg. "My string " ++ show myInt ++ "blah blah"
08:01:15 <fmap> > printf $ "My string " ++ show 3 ++ "blah blah" :: String
08:01:17 <lambdabot>   "My string 3blah blah"
08:01:38 <Siod> but that's printf
08:02:03 <fmap> polymorhic printf
08:02:17 <Siod> how are you supposed to do sprintf
08:03:05 <fmap> i've shown
08:03:22 <osfameron> that doesn't look anything like sprintf
08:03:36 <Siod> the `"My string " ++ show 3 ++ "blah blah" :: String` part?
08:04:01 <fmap> isn't sprintf a printf that prints to string?
08:04:02 * hackagebot fb 0.9.4 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.9.4 (FelipeLessa)
08:04:09 <osfameron> fmap: well, that isn't a printf
08:04:12 <osfameron> that's string concatenation
08:04:20 <fmap> ah, sure
08:04:21 <osfameron> that's the opposite of the convenience of a sprintf
08:04:23 <Siod> sprintf creates a string like printf but it doesn't print
08:04:46 <Siod> http://www.cplusplus.com/reference/clibrary/cstdio/sprintf/
08:04:48 <osfameron> sprintf ('My string %d blah blah', 3);  would be the equivalnt
08:05:16 <osfameron> I'm sure there is a library to do it
08:05:17 <fmap> > (printf "My string %d blah blah" 3) :: String
08:05:18 <lambdabot>   "My string 3 blah blah"
08:05:38 <osfameron> ah cool
08:05:45 <osfameron> what library is that in?
08:06:03 <Siod> from the docs on printf `Format a variable number of arguments with the C-style formatting string. The return value is either String or (IO a). `
08:06:03 <geekosaur> I expect it's part of Text.Printf
08:06:03 <fmap> base
08:06:17 <Siod> that's surprising; how are they doing that with the return value?
08:06:36 <geekosaur> mid-level Oleg type hackery
08:06:38 <rwbarton> same way it is doing variadic printf magic in the first place
08:06:52 <quicksilver> no, not hackery
08:06:53 <osfameron> base?
08:06:56 <quicksilver> that's plain boring overloading.
08:07:03 <quicksilver> the variadic stuff is (very mildy) hackery I suppose
08:07:18 <quicksilver> but being polymorphic between IO () and String is just typeclass 101.
08:07:32 <quicksilver> (although it does require FlexibleInstances)
08:08:08 <osfameron> it's variadic plus able to take arguments of different types depending on the format
08:08:36 <osfameron> how is it implemented?
08:08:50 <geekosaur> well, the return type is intertwined with the variadic typeclass hackery, and I was under the impression it was thereby complicated a bit
08:08:57 <quicksilver> it doesn't check the types depending on the format, though, osfameron
08:08:59 <geekosaur> also, yes, definitely part of base
08:09:13 <osfameron> > printf "foo%d %s \n" 3 4
08:09:14 <lambdabot>   Ambiguous type variable `a' in the constraints:
08:09:15 <quicksilver> geekosaur: intertwined in implementation, certainly, but orthogonal conceptually.
08:09:15 <lambdabot>    `Text.Printf.PrintfType ...
08:09:24 <rwbarton> it checks that the format string matches the types of the arguments it has been passed
08:09:27 <osfameron> > printf "foo%d %d \n" 3 4
08:09:28 <lambdabot>   Ambiguous type variable `a' in the constraints:
08:09:28 <lambdabot>    `Text.Printf.PrintfType ...
08:09:31 <quicksilver> osfameron: the errors you get are runtime.
08:09:37 <osfameron> oh.  the latter worked in ghci
08:09:44 <quicksilver> rwbarton: at runtime not at compile-time, though
08:09:47 <osfameron> ah ok
08:09:47 <rwbarton> yes
08:09:52 <quicksilver> so it's not type system related.
08:10:02 <quicksilver> it's just "if you get an Int argument, look for %d, otherwise barf"
08:10:07 <rwbarton> indeed
08:10:18 <osfameron> so the "only" trick is getting a haskell function to accept a number of arbitrary arguments of any type
08:10:23 <quicksilver> yes
08:10:30 <kkyqqp> haskell beginners question: how do I sum the list [Just 1, Just 2, Just 3]?
08:10:32 <quicksilver> which is by including a -> r in the list of overloads
08:11:08 <osfameron> quicksilver: hmm?
08:11:10 <byorgey> kkyqqp: fmap sum . catMaybes, or fmap sum . msum
08:11:18 <kkyqqp> cool, thanks!
08:11:23 <byorgey> depending on whether you want Nothing to get filtered out or cause the whole thing to fail, respectively
08:11:32 <quicksilver> osfameron: a printf expression is either IO () or String or (a -> PrintfExpression)
08:11:38 <companion_cube> :t fmap sum . sequence
08:11:39 <lambdabot> forall a (f :: * -> *). (Num a, Functor f, Monad f) => [f a] -> f a
08:11:45 <rwbarton> don't you mean sequence not msum, yeah
08:11:48 <quicksilver> osfameron: meaning either printf, or sprintf, or get another argument.
08:11:53 <byorgey> man, ignore me, those are both wrong
08:13:16 <byorgey> kkyqqp: the first one should be   sum . catMaybes, the second should be  fmap sum . sequence
08:13:17 <covi> How does Haskell infer kinds? I'm leaded by the Tofu example here http://learnyouahaskell.com/making-our-own-types-and-typeclasses
08:13:32 <osfameron> quicksilver: oh. so it's (((printf "%d %d %d" 1) 2) 3) for example?
08:13:36 <byorgey> > sum . catMaybes $ [Just 1, Just 2, Just 3]
08:13:38 <lambdabot>   6
08:13:43 <quicksilver> osfameron: well yes certainly
08:13:50 <byorgey> > fmap sum . sequence $ [Just 1, Just 2, Just 3]
08:13:50 <quicksilver> osfameron: that's how all functions work?
08:13:52 <lambdabot>   Just 6
08:14:04 <kkyqqp> sum . catMaybes $ [Just 1, Just 2, Just 3,Nothing]
08:14:16 <kkyqqp> lamdbabot didn't like mine :(
08:14:18 <byorgey> kkyqqp: you need to put a >  in front of it
08:14:23 <kkyqqp> > sum . catMaybes $ [Just 1, Just 2, Just 3,Nothing]
08:14:25 <lambdabot>   6
08:14:29 <geekosaur> ...or @run
08:14:34 <quicksilver> > let foo a b c = a + b + c in (((foo 10) 11) 12)
08:14:35 <lambdabot>   33
08:14:37 <quicksilver> osfameron: ^^
08:14:38 <kkyqqp> > fmap sum . sequence $ [Just 1, Just 2, Just 3, Nothing]
08:14:40 <lambdabot>   Nothing
08:14:46 <kkyqqp> ok, thanks a lot!
08:15:43 <quicksilver> covi: kind inference is simplistic and conservative
08:16:10 <quicksilver> covi: it infers the "simplest possible kind" - that is, * if it is never seen taking a paramtere, * -> * if it is seen taking one parameter, * -> * -> * if it is seen taking two, etc.
08:16:21 <quicksilver> covi: did you have a particular example?
08:16:32 <noor_> btw wolfram had no problem telling me 1/ln(pi) in base 12 mad props
08:16:34 <osfameron> quicksilver: yeah, except that printf isn't declared printf s a b c; but rather printf s a (which may or may not return another function dynamically, rather than decided by the type system)
08:16:44 <noor_> I know you were all on pins and needles..
08:17:05 <quicksilver> osfameron: it's decided by context
08:17:11 <quicksilver> osfameron: it's not really "dynamically"
08:17:30 <quicksilver> although it certainly could be "polymorphically" that would be impractical in practice
08:17:43 <quicksilver> (since the format string would be incorrect for all but one variation of that)
08:17:56 <covi> quicksilver: http://learnyouahaskell.com/making-our-own-types-and-typeclasses
08:18:02 <quicksilver> covi: it's a long page :)
08:18:03 <covi> quicksilver: the Tofu typeclass here
08:18:12 <quicksilver> covi: ah.
08:18:28 <quicksilver> covi: well the words explain it, no?
08:18:42 <quicksilver> covi: a :: * because it's never seen taking a parameter.
08:18:42 <covi> quicksilver: I am wondering, how many passes does kind inference take?
08:19:02 <quicksilver> j :: * -> * because it's seen with a as a parameter (only)
08:19:03 <covi> quicksilver: sure, I understand the explanation there. I am just trying to learn a bit about kind inference
08:19:33 <osfameron> quicksilver: I was imagining the format string would get chopped off bit by bit, until all the parameters were used up
08:19:39 <quicksilver> osfameron: no.
08:19:40 <rwbarton> covi: kind inference uses essentially the same algorithm as type inference
08:19:51 <quicksilver> osfameron: the type is decided at compile time; the format string is parsed at runtime
08:19:58 <Siod> is there a way of doing: case myInt of 2,3 ->
08:20:05 <quicksilver> osfameron: if the format string turns out to be incompatible with the type you get a runtime error.
08:20:08 <Siod> or fallthroughs
08:20:26 <Siod> case myInt of 2 -> 3 -> print "blah"
08:20:28 <quicksilver> rwbarton: I'm not sure that's true.
08:20:35 <rwbarton> one difference is that because Haskell has no kind polymorphism (aside from recent GHC extensions), if a kind variable is unconstrained, it "defaults" to *
08:20:45 <quicksilver> rwbarton: and that's why it's not true :)
08:20:49 <rwbarton> ...
08:21:10 <quicksilver> unconstrained kinds going to * is quite different in feel from full H-M.
08:21:13 <rwbarton> good thing i did not say "literally the same" then
08:21:16 <quicksilver> :)
08:21:19 <osfameron> hmmm, my ghci doesn't have Text.Printf in it.  Perhaps I need to upgrade...
08:21:38 <osfameron> quicksilver: ok.  I'm still confused ;-)  I'll have a look at the implementation later and see if it makes any more sense
08:23:23 <theadmin> Okay, now a serious question... How can I read an Int from stdin?
08:23:35 <rwbarton> osfameron: I think printf is pretty ancient, are you sure?
08:24:06 <theadmin> read getLine::Int ain't working >.<
08:24:18 <Clint> :t getLine
08:24:19 <lambdabot> IO String
08:24:20 <Clint> :t read
08:24:21 <lambdabot> forall a. (Read a) => String -> a
08:24:31 <osfameron> rwbarton: "The Glorious Glasgow Haskell Compilation System, version 7.0.2"
08:25:31 <osfameron> I may have got it from brew install
08:25:54 * osfameron downloads a haskell platform
08:26:00 <quicksilver> http://www.haskell.org/ghc/docs/7.0.1/html/libraries/base-4.3.0.0/Text-Printf.html
08:26:07 <quicksilver> ^^ text.printf was in 7.0.1
08:26:11 <quicksilver> in base
08:26:14 <quicksilver> and you can't not have base :P
08:26:33 <Phlogistique> btw, are people still working on Haskell prime?
08:26:36 <osfameron> <interactive>:1:1: Not in scope: `printf'
08:26:48 <osfameron> unless I :m +Text.Printf
08:27:07 <quicksilver> but it works if you :m +Text.Printf ?
08:27:16 <osfameron> yeah
08:27:18 <quicksilver> good
08:27:21 <quicksilver> that is as expected.
08:27:28 <quicksilver> identifier in not visible until imported shocker.
08:28:20 <osfameron> oki
08:28:26 <quicksilver> :)
08:28:34 * Clint chuckles.
08:28:47 <rwbarton> oh, i assumed "my ghci doesn't have Text.Printf in it" meant ":m +Text.Printf" failed
08:28:48 <osfameron> I read the "it's in base" as "you don't need to care what library it's in, it's exposed by default"
08:29:19 <theadmin> Well, basically my point is read a few Ints from STDIN, do some math on them and output them back out... Trying to learn the basics here (coming from the imperative land so might be approaching it wrongly altogether)
08:29:40 <rwbarton> it is in the base package but not the Prelude module, which is the only thing imported by default -- "library" is ambiguous/not really a term that's used
08:31:08 <quicksilver> osfameron: have a glance at http://www.haskell.org/ghc/docs/7.0.1/html/libraries/
08:31:24 <quicksilver> osfameron: base is a "package" - the things in base have base in the right-most column
08:31:41 <fmap> :t readLn
08:31:42 <lambdabot> forall a. (Read a) => IO a
08:31:50 <quicksilver> osfameron: base is the package which is guaranteed to come with GHC and a perticular version of GHC is 'hardcoded' to a fixed version of base.
08:31:53 <fmap> theadmin: the simplest way ^
08:32:13 <theadmin> fmap: So, how exactly do I use it? I really am new >.<
08:32:20 <quicksilver> osfameron: a few other small packages also come with GHC, that page shows you the other packages which came with GHC 7.0.1
08:32:48 <quicksilver> osfameron: the set of packages coming with GHC tends to remain constant or decrease a bit, since the trend is for "not absolutely essential" packages to come instead with the haskell platform.
08:33:17 <pooya72> so anyone getting this error when trying to install cabal-dev on haskell-platform-2012? http://hpaste.org/69660
08:34:06 <osfameron> quicksilver: cool, ta
08:34:17 <geekosaur> sounds like cabal-dev has not had its dependencies checked against the new HP
08:34:27 <parcs`> theadmin: have you read LYAH?
08:34:42 <pooya72> geekosaur: oh no. what do i do now?
08:34:45 <fmap> theadmin: just like any other IO function. what are you trying to do?
08:34:58 <theadmin> fmap: Never mind, figured it out
08:35:11 <geekosaur> easiest is probably to wait and/or prod the cabal-dev maintainer
08:36:01 <geekosaur> https://github.com/creswick/cabal-dev/pull/55 already exists, so shouldn't be too long hopefully
08:36:54 <pooya72> geekosaur: actually cabal-dev was working fine when i installed haskell-platform-2012 on top of haskell-platform 2011
08:37:36 <geekosaur> yes, it's a program, it would continue to use the existing HP2011 as long as it's still installed and functional
08:38:12 <pooya72> geekosaur: i c.
08:38:36 <geekosaur> but building it under HP2012 does not work because its dependencies don't allow for the HP2012 version of HTTP etc.
08:39:36 <pooya72> geekosaur: so HP2012 was that big of a change?
08:40:19 <geekosaur> no, just that programs set strict upper version limits because there is worse breakage when they don't and a new version turns out to be incompatible
08:40:43 <pooya72> and how am i supposed to work done without cabal-dev?!
08:41:02 <geekosaur> the comment on the pull request indicates that the only change is adjusting those upper limits
08:41:17 <pooya72> yeah, saw that...
08:41:58 <geekosaur> you could consider following that link I pasted, and via that get the necessary patch.  or possibly just edit cabal-dev.cabal to specify the versions of packages in HP2012
08:42:35 <pooya72> geekosaur: thanks. I'm a bit of a noob so I might just as well just wait.
08:43:04 <geekosaur> it's 2 lines
08:43:51 <geekosaur> or even just download https://raw.github.com/dysinger/cabal-dev/80d7bc3c3ceef9deb9189cea87fb1fe3e50d6b4f/cabal-dev.cabal and copy it on top of cabal-dev.cabal
08:44:07 * hackagebot stylish-haskell 0.2.0.0 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.2.0.0 (JasperVanDerJeugt)
08:44:38 <pooya72> geekosaur: yeah..
08:45:36 <srhb> Arrows confuse me.. Do functions automatically lift (am I using that right?) to arrows?
08:46:29 <pooya72> geekosaur: where would I find cabal-dev.cabal if i haven't installed it locally?
08:47:23 <hpaste> braun pasted “braun” at http://hpaste.org/69661
08:47:30 <geekosaur> use "cabal unpack cabal-dev" to have cabal-install set up a source build area (directory/"folder")
08:48:24 <S11001001> srhb: depends on the particular arrow you mean
08:48:27 <geekosaur> the directory will have cabal-dev.cabal in it; you should be able to copy the one in that last URL I sent, then while in that directory say "cabal install" (without a package name)
08:48:49 <geekosaur> and it should build and install with the modified cabal-dev.cabal
08:49:00 <martin223> http://hpaste.org/69661, could this work :P
08:49:26 <nobdraisentone> How can I apply catMaybe to second elements of each list's tuple? I use `map (\(f,s) -> (f, fromJust s)) . filter (isJust . snd) :: [(t, Maybe a)] -> [(t, a)]'. How could it be simplified?
08:52:49 <quicksilver> nobdraisentone: it should be catMaybes . sequenceA
08:52:58 <quicksilver> nobdraisentone: but there is no Traversable instance for (,)
08:53:33 <pooya72> geekosaur: ok thanks!
08:54:17 <quicksilver> :t let seqComma (a, Just b) = Just (a,b); seqComma _ = Nothing in catMaybes . map seqComma
08:54:18 <lambdabot> forall t t1. [(t, Maybe t1)] -> [(t, t1)]
08:54:26 <quicksilver> nobdraisentone: ^^
08:54:42 <quicksilver> correction "it should be catMaybe . (map sequenceA)"
08:54:54 <quicksilver> correction^2 "it should be catMaybes . (map sequenceA)"
09:13:52 <burbul> @find naruto 266
09:13:53 <lambdabot> Not in scope: type variable `naruto'
09:13:53 <lambdabot> Only unit numeric type pattern is valid
09:14:00 <burbul> aargh
09:14:01 <burbul> soprry
09:14:07 <burbul> wrong channel
09:14:11 <burbul> so sorry
09:14:59 <Siod> is this a good way of handling arguments to a command: create a list of Maybe Strings for maximum expected arguments, and then use an applicative style for handling cases where the arguments don't exist. example command: eat apple <number of apples -- if no given arg here then assume 1 apple>
09:17:34 <Siod> in an imperative style you would simply nest a bunch of ifs, but i want to use the optimal functional style
09:18:58 <Siod> or maybe i should be using monadplus
09:21:40 <S11001001> Siod: (flip maybe id) <$> ZipList [default1, default2] <*> optionalArglist, which can also be written using zipWith
09:22:21 <Siod> nice
09:22:44 <Siod> getting used to a functional style is going to take a while, i think
09:29:10 * hackagebot ImperativeHaskell 2.0.0.1 - A library for writing Imperative style haskell.  http://hackage.haskell.org/package/ImperativeHaskell-2.0.0.1 (MatthewMirman)
09:30:30 <Siod> could this be a rule of thumb in haskell: if you're using control structures like ifs, whens, or cases, then you're using haskell in a suboptimal way
09:32:32 <otters> Is there a tool that un-list-comprehensions a list comprehension
09:33:09 <jfischoff> otters: to monadic do notation?
09:34:25 <otters> right
09:36:30 <jfischoff> i'm waiting for other people to answer, but I would look at some of the -ddump-* flags. The compiler might desugar it for you.
09:48:44 <rwbarton> @undo [ x + z | x <- [1..3], y <- [4..6], let z = y^2 ]
09:48:44 <lambdabot> concatMap (\ x -> concatMap (\ y -> let { z = y ^ 2} in [x + z]) [4 .. 6]) [1 .. 3]
09:49:14 <rwbarton> otters: ^ that converts to list functions
09:51:47 <otters> I see
09:51:51 <otters> thank you
10:09:47 <kashyap_> Is there a good tutorial on using Data.Graph?
10:38:28 <TheShrub> what does haskell do really well compared to say... Python or C++
10:39:19 <c_wraith> TheShrub: help you change your code and be sure you got it right.
10:39:47 <TheShrub> c_wraith: Im sorry,i dont understand
10:39:59 <strager> TheShrub: Safe, stable development and refactoring.
10:40:15 <c_wraith> I've never used another language that gives me more support when I decide to change half of an existing system.
10:40:20 <Cale> TheShrub: Haskell's type system is much more effective than C++'s (or of course, Python's, which is nonexistent)
10:40:21 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
10:40:45 <Cale> It helps a lot when you change something, and want to track down all the things which it affects
10:41:02 <c_wraith> This is a combination of the type system and rejecting implicit behavior.
10:41:17 <Cale> For a lot of types of changes, you can basically just make the change and run the compiler over it repeatedly to find everything which is affected.
10:41:17 <TheShrub> Cale: Object oriented?
10:41:45 <Cale> Haskell isn't an object oriented language, but you can write OOP code in it which is much truer to the spirit of OO than C++ code is.
10:42:01 <Cale> (at least in my opinion)
10:42:02 <c_wraith> usually you don't want to though.
10:42:18 <Cale> OO has its place, but yeah, it's not for everything
10:42:27 <TheShrub> Cale: How is it "true-er" to the OO spirit thatn C++
10:42:43 <c_wraith> OO is useful sometimes.  The big project at my company has one module set that uses OO, and it works very well there.
10:43:00 <c_wraith> But that's one spot, out of hundreds of things it does
10:43:20 <Cale> Well, in my mind, OOP is really about values whose identity is determined by the way in which they respond to messages (or their implementations of methods, to say the same thing another way)
10:43:54 <Cale> Because C++ doesn't have first class procedures it has to tie the implementations of methods to the class definitions.
10:44:12 <Cale> That is, you can't just have all abstract classes.
10:44:19 <Cale> (with implementations in the objects)
10:44:42 <TheShrub> Cale: What about pythons classes and oop structures (i havent delved to deep into python oop)
10:45:09 <Philippa> TheShrub: given how appallingly far C++ is from the spirit of OOP, it's not actually that hard for a language with first class functions to let you come closer
10:45:44 <Philippa> Python's a lot closer, to the point where it's far more a matter of taste
10:45:49 <Cale> Python gets it closer to right, if I recall correctly. It's been at least a few years since I really looked at any Python code.
10:46:14 <Philippa> but Python also tries to make it harder to write code in certain ways, or at least doesn't bother to make it easy when it could/should be
10:46:47 <Philippa> (to be fair: that's a charge you could easily level at Haskell - it's worth understanding how Haskell is different though)
10:47:33 <Philippa> c_wraith: type system, rejecting implicit behaviour and enabling a level of abstraction that makes most languages run screaming? That last one is so, so much my friend when I want to /really/ warp some existing code
10:47:46 <Philippa> (the trick is remembering to specialise back down again when appropriate!)
10:47:52 <TheShrub> Philippa: "There should be one, and preferably one way to do something" -Guido Vas Ronum, not sure if i agree though, but i guess thats the way they designed the language to be
10:48:25 <Cale> Yeah, it's easy to get carried up defining typeclasses and end up with all these classes where you only have one instance written :)
10:48:25 <otters> and the only way to write lambdas is on one line
10:48:35 <Philippa> TheShrub: quite
10:49:02 <Philippa> I'm waiting for the language that allows one way up to isomorphism :p
10:49:23 <c_wraith> Guido says some terrifying things about programming language design though.  It's clear he's never really studied it.
10:49:27 <Cale> There will almost never be one and only one way to do pretty much anything, unless your language is horribly boring and isn't capable of expressing many computations.
10:49:48 <c_wraith> The most terrifying example I can think of is "It's not a real functional language if you can implement map or filter in a library".
10:49:56 <Cale> LOL
10:50:32 <amatsu> c_wraith: wow, when did he say that?
10:50:45 <Cale> Easy way to check how much a language is concerned with functional style: how many (additional) characters does it take to compose two functions and get another function?
10:50:46 <otters> I can't understand that quote
10:51:12 <Cale> (that's a bit of a cheap shot at a lot of them though :)
10:51:22 <otters> why wouldn't you be able to implement map or filter in a library
10:51:23 <TheShrub> otters: a=lambda x:do_something();print('something');exit() that should do it
10:52:58 <Philippa> c_wraith: that wasn't a sign error typo?
10:53:12 <jmcarthur> otters: you don't understand the quote because it is nonsense
10:53:23 <otters> oh, so that was sort of the point
10:53:26 <c_wraith> Philippa: it might have been. It's a pretty ridiculous statement. I can't find the reference now.
10:53:38 <Philippa> it makes sense if you make it "if you can't..."
10:54:04 <otters> I guess it depends on the definition of "in a library"
10:54:24 <Philippa> and of map, filter
10:54:34 <Philippa> given that it's not that hard to church encode lists and booleans
10:54:39 <Philippa> (tedious, sure)
11:06:16 <amatsu> Where's local documentation stored if we enabled documentation: True in ~/.cabal/config?
11:06:46 <ion> find ~/.cabal -name index.html
11:06:59 <jmcarthur> amatsu: ~/.cabal/share/doc
11:09:12 <amatsu> ion: jmcarthur: there doesn't seem to be any documentation files, is there anything special I need to do to Haddock?
11:10:31 <tlockney> compactness, performance and type safety at the protocol level
11:11:33 <tlockney> if you don't need those things or have other solutions to those problems, it's probably not worth it
11:11:42 <ion> amatsu: documentation: True only affects packages installed after enabling the setting.
11:12:02 <tlockney> damn, wrong channel :-/
11:12:50 <hpaste> adz_ pasted “couchdb-conduit view” at http://hpaste.org/69669
11:12:52 <amatsu> ion: Ok, got it; thanks for the help!
11:13:07 <adz_> Hi all. Anyone worked with couchdb-conduit? Problem with views. http://hpaste.org/69669
11:13:46 <adz_> couchViewPost throw *** Exception: CouchHttpError 415 "Unsupported Media Type: Content-Type must be application/json"
11:15:20 <c_wraith> adz_: sounds like some error is happening in your query that's causing the couchdb server to respond with a non-json response
11:16:10 <adz_> bug in couchdb-conduit?
11:23:05 <moebius_eye> Why doesn't it work? zipWith div 1 [0..10]
11:23:08 <moebius_eye> > zipWith div 1 [0..10]
11:23:19 <c_wraith> 1 isn't a list
11:23:36 <c_wraith> @botsnack
11:23:41 <moebius_eye> So, how do I do this?
11:23:49 <c_wraith> Cale: feel like waking up your bot?
11:23:55 <moebius_eye> I want a [Bool]
11:24:06 <c_wraith> div doesn't even return a bool
11:24:16 <c_wraith> What do you actually want?
11:24:25 <moebius_eye> Yeah, sorry. A [Int]
11:24:36 <k-zed> you're gonna get a divide by zero :D
11:24:44 <c_wraith> map (div 1) [0..10]
11:24:45 <moebius_eye> yes. I know.
11:24:46 <k-zed> (well, if you force the head)
11:24:55 <moebius_eye> thanks c_wraith
11:24:57 <c_wraith> but yes, you'll get exception, 1, and then a bunch of 0s
11:25:15 <k-zed> moebius_eye: there's also [1,1..]
11:25:21 <moebius_eye> c_wraith: that was just a test on my console.
11:25:30 <k-zed> but the curried map is nicer i guess
11:25:34 <moebius_eye> k-zed: isn't it [1,2..] ?
11:25:39 <moebius_eye> Oh, I see. Nevermind.
11:25:44 <k-zed> i thought you wanted 1/1, 1/2, 1/3, etc
11:32:32 <luca> :t traverse
11:33:00 <Cale> oh, lambdabot is down?
11:33:01 <dmwit> traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
11:33:30 <luca> dmwitbot lol
11:33:33 <dmwitbot> =D
11:33:45 <tac-tics> > "are you ok lambdabot??"
11:33:54 <luca> @pl lambdabot
11:33:54 <dmwitbot> "are you ok lambdabot??"
11:33:57 <Cale> lambdabot's machine is lagging badly
11:33:58 <dmwitbot> lambdabot
11:34:09 <luca> @pl \f -> f f
11:34:16 <c_wraith> \bot are you ok? are you ok? are you ok, \bot?
11:34:21 <dmwitbot> optimization suspend, use ?pl-resume to resume
11:34:21 * Clint shudders.
11:34:26 * hackagebot gitit 0.10.0.1 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.10.0.1 (JohnMacFarlane)
11:34:28 <luca> ?pl-resume
11:34:38 <dmwitbot> optimization suspended, use ?pl-resume to resume
11:34:41 <luca> ?pl-resume
11:34:51 <S11001001> very nice dmwitbot
11:34:54 <S11001001> but
11:34:58 <dmwitbot> join ($)
11:34:59 <S11001001> @pl \f g -> liftM f `on` [g]
11:35:10 <luca> @unpl join ($)
11:36:03 <dmwitbot> flip (.) (:[]) . on . liftM
11:36:06 <dmwitbot> join ($)
11:36:35 <dmwitbot> Oh, crap, I misread ?unpl as ?pl.
11:36:43 <Clint> ((\ a b -> a b) >>= \ c -> c)
11:36:44 <luca> dmwitbot, i got pointfree "\f -> f f" as join id
11:36:58 <dmwitbot> luca: ($) = id
11:37:04 <luca> ahah
11:37:14 <S11001001> dmwitbot: botsnack
11:37:21 <dmwitbot> Actually, I might have gotten the ?unpl one right by accident. =P
11:37:22 <shergill> lol
11:37:23 <dmwitbot> =D
11:37:33 <luca> @pl \f -> (f f) f (f f)
11:37:35 <dmwit> ?unpl join ($)
11:37:48 <luca> \f -> (f f) f (f f) == join (join id) `ap` join id
11:38:08 <lambdabot> join (join id) `ap` join id
11:38:09 <lambdabot> Plugin `pointful' failed with: thread killed
11:38:14 <luca> yaay
11:38:17 <luca> @pl <3
11:38:23 <dmwit> ?unpl join ($)
11:38:36 <luca> or not
11:39:43 <Clint> poor lambdabot
11:40:59 <dmwit> ?botsnack
11:41:05 <lambdabot> Plugin `pl' failed with: thread killed
11:41:05 <lambdabot> :)
11:41:22 <otters> @unpl join ($)
11:41:22 <lambdabot> ((\ a b -> a b) >>= \ c -> c)
11:41:39 <otters> id >>= id?
11:41:43 <otters> join id
11:41:46 <otters> :t join id
11:41:47 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
11:41:47 <lambdabot>     Probable cause: `id' is applied to too few arguments
11:41:47 <lambdabot>     In the first argument of `join', namely `id'
11:41:52 <otters> oh, figured
11:41:52 <luca> :t traverse
11:41:53 <lambdabot> Not in scope: `traverse'
11:42:01 <dmwit> :t Data.Traversable.traverse
11:42:02 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
11:42:08 <tac-tics> @type Identity
11:42:12 <lambdabot> forall a. a -> Identity a
11:42:15 <dmwit> Just like good ol' dmwitbot told you ages ago. ;-)
11:42:18 <tac-tics> @kind Identity
11:42:22 <lambdabot> * -> *
11:42:26 <luca> just checking dmwit ;)
11:42:31 <copumpkin> dmwitbot!
11:42:36 <copumpkin> dmwit: @botsnack
11:42:38 <dmwit> =D
11:42:41 <luca> @pl \x -> x x
11:42:41 <lambdabot> join id
11:42:42 <tac-tics> :t join Identity
11:42:44 <lambdabot>     Couldn't match expected type `a -> a'
11:42:56 <luca> @pl \x -> x x x x x x x (x x x x) x x (x x x x) x (x x x x x)
11:43:18 <luca> yay :D
11:43:39 <lambdabot>            against inferred type `Identity a'
11:43:39 <lambdabot>     Probable cause: `Identity' is applied to too many arguments
11:44:31 <lambdabot> join (join (join (join (join (join (join (join (join id))))) `ap` join (join (join id)))) `ap` join (join (join id))) `ap` join (join (join (join id)))
11:44:38 <luca> yaay
11:44:57 <luca> :t ap
11:44:58 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
11:45:26 <luca> :t liftM .
11:45:38 <lambdabot> parse error (possibly incorrect indentation)
11:45:42 <luca> :t liftM (.
11:45:43 <luca> :t liftM (.)
11:45:51 <jfischoff> I have a bunch of cabal projects and I want to create a haddock index page that has a tree listing all of them, what's the best way to do that?
11:46:00 <lambdabot> forall a b (f :: * -> *) (m :: * -> *). (Functor f, Monad m) => m (a -> b) -> m (f a -> f b)
11:46:01 <otters> :t ((\a b -> a b) >>= (\c -> c))
11:46:07 <lambdabot> parse error (possibly incorrect indentation)
11:46:08 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
11:46:09 <lambdabot>       Expected type: (t -> t1) -> b
11:46:09 <lambdabot>       Inferred type: t -> t1
11:46:28 <dmwit> jfischoff: Turn documentation: True in ~/.cabal/config and install them all, then look in ~/.cabal/share/doc
11:50:03 <otters> :t id id id
11:50:04 <lambdabot> forall a. a -> a
11:51:00 <tac-tics> @type undefined
11:51:01 <lambdabot> forall a. a
11:51:12 <tac-tics> @type error undefined
11:51:16 <lambdabot> forall a. a
11:51:28 <tac-tics> > error undefined
11:51:29 <lambdabot>   *Exception: *Exception: Prelude.undefined
11:51:37 <tac-tics> > error ['a'..]
11:51:43 <otters> it's really satisfying to condense a program into one massive statement using pl and undo
11:51:44 <otters> I don't know why
11:52:07 <lambdabot>   *Exception: abcdefghijklmnopqrstuvwxyz{|}~
11:58:44 <dmwit> mmm, exceptions whose messages throw more exceptions
11:59:50 <tac-tics> > (\x -> error "Inside") (error "Outside")
11:59:51 <lambdabot>   *Exception: Inside
11:59:56 <tac-tics> GASP!
12:00:27 <navaati> tac-tics: that's perfectly normal lazy-evaluation behaviour
12:00:41 <dmwit> > (\x -> error $ "Inside" ++ x) (error "Outside")
12:00:58 * dmwit pokes lambdabot
12:01:09 <navaati> hum, interesting one…
12:01:23 <navaati> i'd say "Outside"
12:01:34 <dmwitbot> * Exception: Inside*Exception: Outside
12:01:40 <lambdabot>   *Exception: Inside*Exception: Outside
12:01:48 <navaati> oh…
12:02:03 <dmwit> It's an exception for which retrieving the error message throws another exception. =)
12:02:11 <dmwit> Just like the one above,
12:02:14 <dmwit> > error undefined
12:02:36 <lambdabot>   *Exception: *Exception: Prelude.undefined
12:03:27 <dmwit> > error ("slightly less obscured" ++ undefined)
12:03:29 <lambdabot>   *Exception: slightly less obscured*Exception: Prelude.undefined
12:03:55 <dmwit> > error ("*Exception: slightly more obscured" ++ undefined)
12:04:13 <lambdabot>   *Exception: *Exception: slightly more obscured*Exception: Prelude.undefined
12:04:40 <fmap> > let x = error x in x
12:04:41 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
12:05:01 <otters> > fix error
12:05:01 <dmwit> It's exceptions all the way down!
12:05:04 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
12:05:22 <otters> I type fix error but it tell "Exception", pls help?
12:05:53 <dmwit> =)
12:10:33 <byorgey> > fix (error . ("Turtle "++))
12:10:35 <lambdabot>   "*Exception: Turtle *Exception: Turtle *Exception: Turtle *Exception: Turtl...
12:11:02 <jfischoff> dmwit: thanks for the help. For some reason cabal-dev recreates index.html with only the most recently built project contents.
12:12:16 <nand`> Is there a predefined zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]; zipWithM = sequence .:: zipWith   anywhere?
12:12:46 <nand`> oh, there is
12:12:49 <mekeor> Which package/library/module do you recommend for parsing HTML?
12:12:57 <nand`> Control.Monad.zipWithM
12:13:01 <Clint> tagsoup?
12:13:45 <nand`> otters: lambdabot is lazy and doesn't like fixing errors
12:13:58 <otters> dumb
12:14:20 <tgeeky> nah. Haskell just isn't smart enough to fix its own errors.
12:14:24 <c_wraith> it's exception turtles all the way down?
12:14:25 <tgeeky> It can often fix your errors!
12:14:33 <otters> but not its own
12:14:37 <tgeeky> nope
12:14:37 <mekeor> Clint: hm ok… well, it converts HTML-code into its own data-type right? and i have to use haskell-function on it then, right?
12:14:54 <Clint> i dunno, it's been ages since i used it
12:15:04 <mekeor> OK.
12:15:23 <mekeor> i just wasn't sure if tagSoup is a good decision, actually…
12:15:39 <Clint> i think it worked
12:15:51 <byorgey> tagsoup just gives you a list of tags
12:16:09 <byorgey> so it's nice when you don't really care too much about the actual structure of the HTML
12:16:16 <byorgey> but not really good for parsing HTML in general.
12:16:48 <byorgey> i.e. it's good for writing a quick-and-dirty script to grab some information from a web page
12:17:03 <mekeor> i just want the content of divs with a certain class.
12:17:13 <byorgey> then tagsoup should work great.
12:17:23 <byorgey> it has a bunch of combinators for filtering etc.
12:17:26 <mekeor> great! thanks, byorgey and Clint.
12:17:36 <mekeor> byorgey: excellent, yay!
12:17:40 * mekeor is looking forward.
12:18:15 <mekeor> BTW, i used pattern guards the first time today. it's great!
12:18:27 <byorgey> yay!
12:18:37 <Sgeo> :t const
12:18:39 <lambdabot> forall a b. a -> b -> a
12:19:01 <byorgey> mekeor: btw, if you use tagsoup, don't miss http://community.haskell.org/~ndm/tagsoup/ , which has a link to a tutorial
12:19:29 <mekeor> ah, nice. didn't see that… thanks once more =)
12:19:32 * hackagebot shelly 0.9.7.3 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.9.7.3 (GregWeber)
12:19:45 <Cale> Pattern guards are a really cute way of discharging typeclass or other type equality constraints by unpacking GADT constructors, when you have a lot of that sort of thing to do
12:20:12 <byorgey> Hackage packages often have a link to a "homepage", but often there's not much there
12:20:22 <byorgey> in the case of Neil Mitchell's packages, however, you should ALWAYS look at the homepage
12:20:29 <byorgey> because there is usually lots of useful information.
12:20:43 <mekeor> byorgey: i can't see the link to a tutorial.
12:21:00 <byorgey> mekeor: "Drinking TagSoup by Example"
12:21:05 <otters> @pl f >>= \x -> g >>= \y -> h >>= \z -> return [x,y,z]
12:21:06 <lambdabot> (g >>=) . (((h >>=) . (return .)) .) . (. ((. return) . (:))) . (.) . (:) =<< f
12:21:11 <mekeor> ah, okay.
12:21:11 <otters> beautiful
12:21:32 <mekeor> otters: :D
12:21:39 <Cale> otters: sequence [f,g,h]
12:21:39 <otters> @pl f >>= \x -> g >>= \y -> h >>= \z -> return (x,y,z)
12:21:40 <lambdabot> (g >>=) . (((h >>=) . (return .)) .) . (,,) =<< f
12:21:48 <otters> oh, that's much nicer
12:21:51 <mekeor> hehehe
12:21:52 <Cale> liftM3 (,,)
12:22:33 <luca> @pl \x -> return [f x]
12:22:33 <lambdabot> return . return . f
12:22:45 <otters> I wrote a scrabble solver, shoved it into one statement, then put it through pl
12:22:57 <byorgey> hahaha what
12:23:11 <strager> Oh god.
12:23:13 <otters> https://raw.github.com/gist/2890950/01ed5687fcdb117d217635bade35437453840402/gistfile1.hs
12:23:17 <otters> enjoy
12:23:32 <otters> it's not *exactly* a scrabble solver, it's for a similar game
12:23:51 <strager> o_o
12:24:09 <strager> Code obfuscation made easy!
12:24:12 <otters> Exactly
12:24:13 <nand`> bonus points: shove the definition if' in there as well using let .. in
12:24:13 <luca> @pl return . Just . f
12:24:14 <lambdabot> return . Just . f
12:24:17 <luca> ah oaky
12:24:21 <otters> I especially like the bits where (.) gets composed with itself twice and then (:)
12:24:28 <strager> IT already has no points, luca
12:24:29 <otters> :t (.).(.).(:)
12:24:30 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a. (Functor f, Functor f1) => a -> f (f1 [a]) -> f (f1 [a])
12:24:33 <luca> @pl maybe (return Nothing) (return . Just . f)
12:24:33 <lambdabot> maybe (return Nothing) (return . Just . f)
12:24:38 <byorgey> I like the random occurrence of the number 8 towards the end
12:24:39 <luca> yeh, but @pl sometimes makes it nicer too :P
12:24:41 <strager> It*
12:24:58 <otters> yeah, I'll see if I can figure out where that came from
12:25:11 <otters> oh, that's the max word length
12:25:29 <nand`> @pl const 1
12:25:29 <lambdabot> const 1
12:25:31 <nand`> shame
12:25:38 <nand`> it doesn't know about NumInstances :(
12:25:39 <byorgey> otters: oh, of course, I see it all now
12:25:45 <luca> :t maybe (return Nothing) (return . Just . f)
12:25:46 <lambdabot>     Ambiguous occurrence `f'
12:25:46 <lambdabot>     It could refer to either `L.f', defined at <local>:16:0
12:25:46 <lambdabot>                           or `SimpleReflect.f', imported from SimpleReflect at State/L.hs:73:0-32
12:25:51 <otters> byorgey: lrn2program, n00b
12:26:01 <luca> :t \f -> maybe (return Nothing) (return . Just . f)
12:26:02 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> a) -> Maybe a1 -> m (Maybe a)
12:26:09 <nand`> so has anybody made ASCII art with Haskell source code yet?
12:26:13 <nand`> (without cheating and using strings)
12:26:28 <otters> I'm sure somebody has
12:26:29 <luca> :t \f -> liftM f
12:26:30 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:26:33 <otters> let's see what I can do with this beast
12:26:48 <byorgey> luca: note that  \f -> liftM f   is the same as just   liftM
12:27:13 <luca> trying to simplify maybe (return Nothing) (return . Just . f) because it must be able to be written better :P
12:27:25 <strager> luca: You want fmap
12:27:41 <luca> thought so
12:28:11 <strager> fmap f x; or f <$> x
12:28:23 <luca> x?
12:28:23 <strager> @src (<$>)
12:28:24 <lambdabot> f <$> a = fmap f a
12:28:24 <nand`> return . fmap f
12:28:38 <strager> x is your maybe thing
12:28:44 <otters> :t ((,) =<<)
12:28:45 <lambdabot> forall a b. (b -> a) -> b -> (a, b)
12:28:58 <luca> maybe is a library function
12:29:02 <strager> > (+ 1) <$> Just 4
12:29:04 <lambdabot>   Just 5
12:29:05 <byorgey> @type  maybe (return Nothing) (return . Just . f)
12:29:06 <lambdabot>     Ambiguous occurrence `f'
12:29:07 <lambdabot>     It could refer to either `L.f', defined at <local>:16:0
12:29:07 <lambdabot>                           or `SimpleReflect.f', imported from SimpleReflect at State/L.hs:73:0-32
12:29:15 <byorgey> @type  \f -> maybe (return Nothing) (return . Just . f)
12:29:16 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> a) -> Maybe a1 -> m (Maybe a)
12:29:29 <nand`> :t return .: fmap
12:29:30 <byorgey> luca: looks like you want  return . fmap f
12:29:30 <lambdabot> forall (m :: * -> *) a b (f :: * -> *). (Monad m, Functor f) => (a -> b) -> f a -> m (f b)
12:29:53 <otters> :t L.f
12:29:54 <lambdabot> String -> Bool
12:29:56 <EvanR> return .: fmap
12:30:00 <otters> > L.f "word"
12:30:02 <lambdabot>   False
12:30:07 <luca> nope heh
12:30:07 <otters> I can't imagine what that does
12:30:15 <otters> @src L.f
12:30:15 <nand`> @check \x -> L.f x == False
12:30:16 <lambdabot> Source not found. I've seen penguins that can type better than that.
12:30:17 <lambdabot>   "OK, passed 500 tests."
12:30:31 <otters> @pl \x -> L.f x == False
12:30:32 <lambdabot> (False ==) . L.f
12:30:36 <otters> @check (False ==) . L.f
12:30:39 <lambdabot>   "OK, passed 500 tests."
12:30:42 <otters> Neat.
12:30:57 <strager> @check const (2 + 2 == 4)
12:30:58 <lambdabot>   "OK, passed 500 tests."
12:31:04 <strager> Great, math works!
12:31:12 <luca> infact, i just wanted liftM f, and use let instead of <-
12:31:29 <luca> ife <- maybe (return Nothing) (return . Just . f) x  === let ife = liftM f $ x
12:31:30 <nand`> @check 2+2 == 4
12:31:31 <lambdabot>   "OK, passed 500 tests."
12:31:32 <byorgey> luca: ah, indeed
12:31:47 <luca> just feels weird since f in this case is monadic action
12:31:48 <strager> luca: Yup
12:31:54 <luca> feels weird using monadic actions without <-
12:32:20 <strager> f is a -> m b, right?
12:32:22 <nand`> if ‘f’ is a monadic action then why is “return . Just . f” there in the first place? Looks like it isn't going to be bound in that statement either way
12:32:30 <luca> f in this case is Expr -> State ([String],Int) Expr
12:32:57 <strager> So why not: do { expr <- f <$> x ; ... }
12:33:10 <luca> because x is Maybe a
12:33:20 <byorgey> there's nothing wrong with defining actions that you are going to "run" later
12:33:28 <strager> :t \f -> do { expr <- f <$> x ; return expr }
12:33:30 <lambdabot>     Ambiguous occurrence `x'
12:33:30 <luca> wanted to do a = Nothing -> Nothing, a = Just x -> Just (f x)
12:33:30 <lambdabot>     It could refer to either `L.x', defined at <local>:3:0
12:33:30 <lambdabot>                           or `SimpleReflect.x', imported from SimpleReflect at State/L.hs:73:0-32
12:33:35 <strager> :t \f x -> do { expr <- f <$> x ; return expr }
12:33:36 <lambdabot> forall a b (f :: * -> *). (Functor f, Monad f) => (a -> b) -> f a -> f b
12:33:37 <byorgey> luca's code sounds fine to me.
12:34:13 <strager> Sure
12:34:20 <strager> But maybe it's not necessary.
12:34:26 <nand`> byorgey: I was confused because luca said it “feels weird using monadic actions without <-” when he wasn't using it (in that line) even with the “<-” there
12:35:24 <luca> ghci shows :t liftM f in this case to be: Monad m => m Expr -> m (State ([String,Int) Expr)
12:35:41 <luca> specifically m = Maybe
12:35:57 <nand`> Is that what you want? Or do you want State ([String,Int) (Maybe Expr)?
12:36:03 <luca> the second 8D
12:37:14 <luca> seems traverse f is fine
12:37:15 <byorgey> let me make sure I have this right. You have  x :: Maybe Expr  and  f :: Expr -> State ([String],Int) Expr  ?
12:37:31 <luca> yeh
12:37:49 <byorgey> ah, yes, you want traverse =)
12:38:10 <nand`> :t \f x -> case x of Nothing -> return Nothing; Just x' -> Just <$> f x'
12:38:11 <lambdabot> forall t a (f :: * -> *). (Monad f, Functor f) => (t -> f a) -> Maybe t -> f (Maybe a)
12:38:25 <luca> :t \f -> traverse f
12:38:26 <lambdabot> Not in scope: `traverse'
12:38:30 <nand`> which I'm sure can be optimized
12:38:35 <byorgey> :t Data.Traversable.traverse
12:38:37 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:38:43 <luca> :t \f -> Data.Traversable.traverse f
12:38:44 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:38:45 <nand`> oh neat
12:38:46 <byorgey> f = State ..., t = Maybe
12:39:22 <luca> traverse sounds so wrong haha
12:39:23 <luca> but it works.
12:39:51 <byorgey> what do you mean it sounds wrong? =)
12:39:59 <luca> what is it traversing? :P
12:40:12 <byorgey> @wn traverse
12:40:13 <lambdabot> *** "traverse" wn "WordNet (r) 3.0 (2006)"
12:40:13 <lambdabot> traverse
12:40:13 <lambdabot>     n 1: a horizontal beam that extends across something [syn:
12:40:13 <lambdabot>          {trave}, {traverse}, {crossbeam}, {crosspiece}]
12:40:13 <lambdabot>     2: a horizontal crosspiece across a window or separating a door
12:40:15 <lambdabot> [13 @more lines]
12:40:35 <nand`> :t Data.Traversable.traverse `asAppliedTo` (undefined :: expr -> State s expr)
12:40:36 <lambdabot> forall b (t :: * -> *) s. (Data.Traversable.Traversable t) => (b -> StateT s Identity b) -> t b -> StateT s Identity (t b)
12:40:42 <luca> lol bad definition
12:40:47 <luca> traverse = travel across
12:40:56 <byorgey> yeah, "to go or travel across or over"
12:40:56 <nand`> oh wait, lambdabot knows Expr too
12:41:01 <nand`> :t Data.Traversable.traverse `asAppliedTo` (undefined :: Expr -> State s Expr)
12:41:02 <lambdabot> forall (t :: * -> *) s. (Data.Traversable.Traversable t) => (Expr -> StateT s Identity Expr) -> t Expr -> StateT s Identity (t Expr)
12:41:14 <luca> don't know what Expr lambdabot is using
12:41:17 <luca> not mine ;p
12:41:20 <nand`> the one from SimpleReflect :P
12:41:26 <nand`> and I know :)
12:41:27 <byorgey> > 3 + 5 :: Expr
12:41:29 <lambdabot>   3 + 5
12:41:41 <byorgey> the magical one
12:41:47 <luca> yeh, my Expr is data type in my parser's AST
12:42:01 <byorgey> > scanl (+) 0 [a,b,c]
12:42:02 <lambdabot>   [0,0 + a,0 + a + b,0 + a + b + c]
12:43:17 <nand`> > fmap (foldl (+) 0) $ inits [a,b,c]
12:43:18 <lambdabot>   [0,0 + a,0 + a + b,0 + a + b + c]
12:43:22 <nand`> hooray
12:43:40 <nand`> does HLint reduce that one?
12:43:54 <byorgey> dunno, try it =)
12:44:32 <luca> btw, wtf. I installed hlint (through apt) at home, and at work through apt also... but they give different results on same set of source files
12:44:54 <nand`> it doesn't :(
12:44:58 <moebius_eye> Anyone using Hugs.Observe ?
12:44:58 <nand`> it picks up foldl (+) 0 as sum though
12:45:06 <luca> at work, i get various (that i consider erroneous) suggestions on avoiding duplication
12:45:12 <moebius_eye> I have issues importing it.
12:45:15 <luca> erroneous because in the places it suggests it'd just make the code confusing
12:48:33 <moebius_eye> > import Hugs.Observe
12:48:35 <lambdabot>   <no location info>: parse error on input `import'
12:49:59 <dmwit> luca: You probably have different versions installed.
12:52:47 <geoman> .who
12:53:34 <ratzes> hi, does anybody know if there is something weird going on with ghc 7.4.1 and ffi namely stub.o files are no longer generated?
13:06:09 <ClaudiusMaximus> moebius_eye: works in my hugs with :also Hugs.Observe
13:06:24 <ClaudiusMaximus> moebius_eye: not actually used it, but it loads
13:07:34 <ratzes> hmm
13:08:35 <ratzes> can anyone get this to work with ghc 7.4.1? http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
13:10:47 <adamt> Maybe i just fail at googling, but is there anything like sortByM?
13:11:49 <hpc> adamt: you don't want it, i don't think
13:12:25 <adamt> hpc: I don't? Aww.
13:12:53 <hpc> well, you cant technically predict the side effects
13:12:58 <adamt> oh wait, i'm stupid, i don't need it at all.
13:13:27 <hpc> :D
13:13:57 <adamt> i have [STM Foo] but i'm already turning it into [Foo] before handing it to hamlet, so i can just sort on [Foo] instead, lol.
13:15:44 <moebius_eye> ClaudiusMaximus: it's in the hood package, right?
13:15:58 <moebius_eye> I installed the hood package.
13:16:11 <nand`> > take -1 "foo"
13:16:11 <lambdabot>   Overlapping instances for GHC.Show.Show
13:16:12 <lambdabot>                              (GHC.T...
13:16:15 <nand`> > take (-1) "foo"
13:16:16 <lambdabot>   ""
13:16:37 <ClaudiusMaximus> moebius_eye: i don't know which package it's in - didn't try it in ghci
13:23:20 <osa1> what is the easiest way to draw some images/lines/circles etc. to the screen with haskell? I tried hSDL and gloss but none of them was easy to use to me(I'm new to haskell)
13:24:38 <nand`> as far as I know gloss is the easiest, but I haven't used many (or gloss much, for that matter)
13:25:30 <c_wraith> gloss-web, running on someone else's machine
13:25:31 <c_wraith> :)
13:25:31 <Cale> osa1: What trouble did you have with gloss?
13:26:35 <c_wraith> http://dac4.designacourse.com:8000/draw gloss-web running somewhere else :)
13:26:36 <osa1> Cale: it was too complex for my needs. all I need is a function for creating a blank screen, and then putting some lines between point (x1, y1) and point (x2, y2).
13:28:05 <Cale> c_wraith: The funny thing about gloss-web the last time I looked at it was that it encoded a bunch of drawing commands in a PNG and then decoded that into an SVG on the client
13:28:06 <Cale> or perhaps it was a bunch of canvas instructions rather
13:28:19 <c_wraith> yeah, it's something like that
13:28:47 <Cale> osa1: isn't that basically what gloss gives you?
13:29:26 <rwbarton> echo 'newpath x1 y1 moveto x2 y2 lineto stroke' > foo.ps
13:31:13 <byorgey> osa1: I suggest you give gloss another try, and ask more specific questions about it here if you get stuck
13:31:21 <byorgey> I don't think you're going to find anything simpler than that
13:32:12 <otters> @unpl flip flip flip
13:32:12 <lambdabot> (\ c f -> c f (\ g h i -> g i h))
13:32:25 <otters> @unpl flip flip flip flip flip
13:32:26 <lambdabot> (\ l o -> l o (\ g h i -> g i h))
13:32:48 <osa1> ok, thanks
13:33:48 <benmachine> Cale: hey, I have this vague idea that you are a person who knows about GHC on iPhone, how's that coming along? is it at all related to GHC on android?
13:33:55 <nand`> display ... $ Line [(x1, y1), (x2, y3)]  -- doesn't get much simpler
13:34:08 <nand`> y2*
13:34:51 <Cale> benmachine: It works, and much of our stuff related to it is going into a future GHC. You should talk to blackh (Stephen Blackheath) though, because he knows the details much better than I do.
13:35:22 <benmachine> Cale: I'm not really looking for technical details, just interested in general progress :)
13:36:01 <benmachine> (I'm considering doing some android development this summer, looking for a way to avoid learning java >_>)
13:36:29 <Cale> benmachine: Yeah, he's got a cross-compiling "toolchain" mode for GHC so that you can compile ARM binaries on a machine of a different architecture.
13:36:37 <benmachine> oh, neat
13:38:41 <benmachine> any idea how far in the future said future GHC is? :P
13:38:52 <benmachine> (or can I get my hands on it before it becomes official?)
13:39:39 * hackagebot wai-middleware-static 0.2.0 - WAI middleware that intercepts requests to static files.  http://hackage.haskell.org/package/wai-middleware-static-0.2.0 (AndrewFarmer)
13:41:56 <Cale> Trying to recall if it was 7.6 or 7.8, probably the former?
13:42:00 <Cale> I'll check my mail
13:44:39 * hackagebot relation 0.2.1 - A data structure representing Relations on Sets.  http://hackage.haskell.org/package/relation-0.2.1 (DrewDay)
13:45:15 <Twisol> I had a thought about Haskell's laziness. Is it fair to say that instead of the program "pushing" from start to finish, it's more being "pulled" from the opposite end of execution?
13:45:30 <Cale> Yeah, that's reasonable to say.
13:45:36 <Cale> It's driven by pattern matching
13:46:16 <Cale> At some level (specifically, in core), the only reason anything is ever evaluated is that it's the scrutinee of some case expression.
13:46:24 <Twisol> Interesting
13:47:07 <Twisol> also, what's a good way to get someone who thinks very little of functional programming to try Haskell? :P
13:47:43 <Minoru> solve their problems in a minute using Haskell, and they'll either hire you or run to learn it themselves
13:48:09 <dmwit> ?quote back.away
13:48:09 <lambdabot> No quotes match. It can only be attributed to human error.
13:48:11 <Cale> Well, there's no reason to force people to use it.
13:48:13 <parcs`> "thinks very little of fp" as in thinks it's useless or is not interested in it?
13:48:30 <Twisol> parcs`: Mostly the former, but the latter comes as a consequence.
13:48:45 <Cale> Just keep it to yourself and be more successful because of it?
13:49:23 <dmwit> ?quote explain.this.shit
13:49:23 <lambdabot> cjs says: I have to explain this shit to people. I mean, I start out right, "Hey, you know how you always have these bugs because what you thought was in the variable is not there?" And I get all of
13:49:23 <lambdabot> these nods of agreement. "Well, I've found a new language that solves that problem." Audience: "Ooooh! How?" Me: "There's no variables!" And then they all start moving away from me slowly....
13:49:30 <Twisol> Cale: well, I don't necessarily want him to use it, but I think it would be good for him to learn because of how it makes you look at program design.
13:49:44 <Twisol> Cale: so I'm trying to come up with arguments that might make him reconsider
13:50:08 <Adeon> you could threaten him with violence
13:50:12 <parcs`> why does he thinks it's useless?
13:50:43 <Twisol> I'm pretty sure it comes down to Paul Graham's ladder of abstraction.
13:51:08 <adamt> Twisol: Don't waste your time trying to change what people believe. ;-)
13:51:21 <parcs`> Twisol: what's that?
13:51:50 <Twisol> parcs`: http://www.paulgraham.com/avg.html - scroll down to The Blub Paradox
13:52:47 <zzo38> How to make a constraint for the lack of an instance?
13:53:37 <dmwit> zzo38: Use a type-level Bool and make instances for True and False
13:53:42 <Twisol> adamt: fair enough!
13:54:03 <dmwit> zzo38: Oleg has a writeup about it somewhere on his website.
13:54:29 <zzo38> There is no type-level case construct
13:54:44 <dmwit> there is (a ~ False) => ...
13:54:55 <parcs`> hmm with ConstraintKinds you can totally make a HasConstraint type function
13:56:13 <adamt> Twisol: Best case you'll end up being the persons haskell supported, forced to listen to unlimited whining about how it's not like any other language, how he doesn't like the colour of the logo, and end up quitting before getting to "Hello, world!".. :-)
13:56:25 <Twisol> XD
13:56:26 <adamt> *supporter
13:56:44 <byorgey> zzo38: http://okmij.org/ftp/Haskell/TypeClass.html#class-based-overloading  -- some of the stuff here may be useful
13:56:49 <adamt> Also, he'll go shout about how much it sucks because he couldn't invest time enough for a proper trial. :P
13:57:05 <byorgey> zzo38: the fact that there is no type-level case construct is a feature.  That's what gives us parametriciy.
13:57:11 <parcs`> what is the module that exports the Constraint kind again?
13:57:12 <byorgey> *ity
13:57:30 <dmwit> Hey byorgey, why doesn't split use GHC.Exts.build?
13:57:31 <Twisol> adamt: Yeah, fair enough. I guess I'll just keep going the passive route.
13:57:38 <byorgey> Constraint comes from a module?
13:57:47 <byorgey> I thought it was just built-in
13:57:49 <dmwit> Yeah, Constraint is in GHC.Exts, I think.
13:57:51 <Twisol> adamt: Pretty hard when stuff "(,) x <$> y" blows my mind every other day.
13:58:00 <byorgey> orly? interesting
13:58:01 <Twisol> *stuff like
13:58:09 <byorgey> dmwit: dunno, good question.  Should it?
13:58:17 <byorgey> I got that code from someone else
13:58:26 <adamt> Twisol: I understand the part before the first ", and the part after the second ". :-)
13:58:45 <dmwit> byorgey: Yeah, it sped up somebody's code from 20s to 17.5s yesterday. numbers are rough and from memory
13:59:04 <Twisol> adamt: given x as an Int and y as a Maybe Int, the result is a Maybe (Int, Int)
13:59:04 <dmwit> byorgey: (There's a bunch of rewrite rules for GHC.Exts.build that won't fire if you define build yourself.)
13:59:10 <byorgey> aha!
13:59:13 <byorgey> cool
13:59:40 * hackagebot fb 0.9.5 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.9.5 (FelipeLessa)
13:59:53 <Twisol> adamt: y >>= (\y' -> (x, y')) I think
14:00:13 <benmachine> Twisol: I think advocacy comes easier the more you know about haskell. the reasons I really like it is that it lets you abstract the heck out of everything, and it's mostly pretty consistent/coherent in its design
14:00:29 <benmachine> because it actually had a committee design it, instead of just some guy (looking at you, PHP)
14:00:54 <benmachine> that last point isn't that glamorous though :P
14:01:02 <dmwit> more importantly: a committee of programming language exports, instead of just some guy who had never designed a language before
14:01:10 <benmachine> yeah, that too
14:01:16 <dmwit> exports, haha
14:01:17 <dmwit> experts
14:01:32 <benmachine> but like, when I find *any* duplication in my haskell code, I can factor it out into a little helper function
14:01:46 <benmachine> I get really bored of writing the same stuff every day in C or whatever
14:01:53 <benmachine> oh great, another for loop
14:02:12 <dmwit> Hey, that's some great advocacy right there. "Why write in Haskell? Because C is *boring*."
14:02:14 <benmachine> oh yay, another file allocation that if it fails prints an error involving the filename and gives up
14:02:18 <dmwit> (not joking)
14:02:23 <benmachine> it's true :P
14:02:32 <Twisol> Haha.
14:02:34 <nand`> Twisol: no, that's not quite the same thing
14:02:56 <benmachine> oh yeah, you want a return in there
14:02:56 <Twisol> Mm, you're right, forgot a return before the tuple. Or was that not the only thing?
14:03:02 <nand`> Twisol: that should be it
14:03:05 <Twisol> Okay!
14:03:12 <nand`> but note that y >>= return . f is the same as fmap f y
14:03:22 <dmwit> ...which is the same as f <$> y
14:03:25 <Twisol> XD
14:03:28 <dmwit> and congratulations, we're back at the original code sample
14:03:32 <nand`> indeed :)
14:03:45 <nand`> but if the point was to make it easier to understand, I think “fmap” would be the least contrived way to formulate it
14:03:51 <benmachine> liftM f y is the version that appeases the gods of untidy class design
14:03:52 <nand`> for those who don't know that <$> = fmap, for example
14:04:03 <Twisol> The brevity and - amazingly - clarity of (,) x <$> y just amazes me.
14:04:10 <nand`> (x,) <$> y -- works too
14:04:16 <benmachine> nand`: -XTupleSections
14:04:21 <Twisol> oh, so it does
14:04:34 <benmachine> it's not standard haskell
14:04:38 <benmachine> it should be :P but it isn't yet
14:04:42 <adamt> :t (,) x <$> y
14:04:43 <lambdabot>     Ambiguous occurrence `x'
14:04:44 <lambdabot>     It could refer to either `L.x', defined at <local>:3:0
14:04:44 <lambdabot>                           or `SimpleReflect.x', imported from SimpleReflect at State/L.hs:73:0-32
14:04:44 <Twisol> Ahh.
14:04:52 <Twisol> :t (,) 1 <$> Just 4
14:04:52 <lambdabot> forall t a. (Num t, Num a) => Maybe (t, a)
14:04:59 <nand`> :t (,) ?x <$> ?y
14:05:00 <lambdabot> forall a a1 (f :: * -> *). (?x::a, ?y::f a1, Functor f) => f (a, a1)
14:05:20 <byorgey> dmwit: I suppose one argument against using GHC.Exts is so that other compilers can build it
14:05:36 <byorgey> dmwit: but it wouldn't be hard to put in some CPP to conditionally import it
14:05:37 <dmwit> byorgey: yes, I was afraid that was the real reason =)
14:05:43 <Twisol> > 1 <$> Just 4
14:05:44 <lambdabot>   Just 1
14:05:48 <Twisol> oops
14:05:53 <Twisol> (,) 1 <$> Just 4
14:05:58 <dmwit> Twisol, nand`, and all other golfers: the short name for this function is "strength"
14:05:58 <donri> I misread that as (,) <$> x <*> y
14:06:02 <byorgey> dmwit: it was using Rank2Types and GADTs anyway... though it turns out Rank2Types was unnecessary
14:06:02 <Twisol> > (,) 1 <$> Just 4
14:06:03 <lambdabot>   Just (1,4)
14:06:09 <Twisol> > (,) 1 <$> Nothing
14:06:10 <lambdabot>   Nothing
14:06:13 <nand`> dmwit: huh?
14:06:23 <Twisol> smwit: Strength?
14:06:51 <dmwit> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Strong.html
14:06:51 <benmachine> it's not a widely-used name but I've heard that one before
14:07:01 <nand`> oh neat
14:07:07 <dmwit> don't think it exists in the New World Order of category stuff, though
14:07:26 <Twisol> in context, this is how I'm using (,) x <$> y
14:07:29 <Twisol> mapMaybe (\(x, y, _) -> (,) x <$> y) list
14:07:40 <nand`> there's one to remember, costrength could be useful as well
14:07:47 <dmwit> All Hask endofunctors have it, but not all actual functors have it (and indeed you can define a Haskell class that generalizes Functor where not all instances have it).
14:08:32 <benmachine> nand`: costrength is Data.Traversable.sequence, apparently
14:08:58 <benmachine> except I'm not sure where the either instance is
14:09:04 <nand`> benmachine: yeah, I figured it'd be something from Traversible based on the type signature
14:09:23 <nand`> import Control.Monad.Either (Either(..))
14:09:24 <benmachine> nand`: sure, but I didn't realise 'til I looked at the code that it's literally just one of the functions from there :P
14:09:27 <benmachine> eyah
14:09:28 <benmachine> oh well
14:09:39 <benmachine> there really ought to be more traversable instances
14:10:48 <nand`> http://hackage.haskell.org/packages/archive/neither/0.3.1.1/doc/html/Data-Neither.html#t:Neither <- funny
14:11:28 <benmachine> that's kinda a little bit silly :P
14:11:41 <nand`> at first I thought it was something like acme-dont
14:12:00 <benmachine> heh yes
14:13:05 <nand`> data Neither a b = Neither
14:14:09 <dmwit> Neither seems like a bad name for this.
14:14:23 <dmwit> Coproduct or Sum would be more familiar...
14:14:33 <dmwit> (Sum especially so, even for non-CT experts)
14:14:40 <benmachine> or maybe Either?
14:14:43 <benmachine> maybe we could call it that?
14:14:51 <dmwit> benmachine: That name is already taken. =)
14:15:06 <mekeor> @src Either
14:15:07 <lambdabot> Source not found. I feel much better now.
14:15:09 <nand`> import Prelude hiding (Either) -- where's the problem? :)
14:15:39 <benmachine> nand`: we also need a complement to Maybe, data Definitely a = DefinitelyJust a
14:15:50 <benmachine> dmwit: newtype it!
14:15:53 <luca> lol.. why
14:16:14 <nand`> data Probably a = Perhaps a | MostLikely
14:16:29 <dmwit> I actually have a FuzzyBool in one of my projects...
14:16:30 <jfischoff> my haddock doc is building, but there is no "source" links for to get to the definitions. Is some configuration I need to set to make haddock link to the source?
14:16:47 <dmwit> data FuzzyBool = Possibly | Definitely
14:16:52 <dmwit> there is no False =)
14:16:54 <nand`> wait, that should be Data Unlikely a
14:17:05 <nand`> *data
14:17:16 <nand`> dmwit: hehe
14:17:32 <hpc> data BOOL = TRUE | FALSE | FILE_NOT_FOUND
14:17:41 <benmachine> jfischoff: are you building with cabal?
14:17:45 <nand`> “FuzzyBool” would have be thinking data FuzzyBool = True | False | Neither <- but that's covered by Maybe Bool and _|_ as well
14:17:50 <dmwit> http://www.red-bean.com/sgf/properties.html#KO <- the most useless of all annotations in the SGF file format
14:18:19 <jfischoff> benmachine: yeah through cabal-dev
14:18:19 <nand`> hpc: programming languages were once like that :(
14:18:35 <benmachine> jfischoff: hmm. I don't remember whether cabal supports that in normal builds yet
14:18:36 <cdsmith> Is there a common way to compose two monad transformers on the fly?  Or should I just write my own newtype for it?
14:18:52 <benmachine> cabal haddock --hyperlink-source does it, but I can't remember if you can tell it to always hyperlink-source
14:18:55 <dmwit> cdsmith: "on the fly"?
14:19:06 <nand`> I just do type MyMonad = StateT s (Reader r) -- or whatever
14:19:17 <benmachine> cdsmith: newtypes are cheap :P
14:19:19 <cdsmith> Ah right... type synonyms... duh, I'm an idiot
14:19:22 <jfischoff> benmachine: ah thanks
14:19:33 <cdsmith> Oh wait, no that doesn't work... lift is wrong then
14:19:42 * hackagebot fb 0.9.5.1 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.9.5.1 (FelipeLessa)
14:19:44 * hackagebot split 0.1.4.3 - Combinator library for splitting lists.  http://hackage.haskell.org/package/split-0.1.4.3 (BrentYorgey)
14:19:55 <byorgey> dmwit: ^^^
14:19:58 <dmwit> byorgey: well that was fast!
14:20:01 <dmwit> byorgey++
14:21:04 <byorgey> and actually, 6 minutes elapsed from the time of upload to hackagebot's report ;)
14:21:17 <dmwit> =D
14:21:28 <byorgey> oh, maybe just 4
14:21:46 <elliottt> does anyone know why alex-3 chose to do utf-8 decoding internally?
14:22:00 <elliottt> it makes writing a lexer that uses the text library a somewhat silly prospect :)
14:22:02 <byorgey> anyway, procrastinating does wonders to my productivity on other things
14:22:08 <cdsmith> dmwit: Yes, to simplify a bit, suppose I have a runFoo :: (Monad m, MonadTrans t) => Foo m a -> t m a.  But I need a Bar (Baz m) a, where Bar and Baz are monad transformers.  So I just need a type with a MonadTrans instance such that lift will wrap it in both
14:22:36 <benmachine> cdsmith: you don't have, like, MonadBar, or something, to do that automatically?
14:22:42 <cdsmith> I did it with my own newtype... just wondering if there was a library or something for it
14:23:00 <Metaluim> sup
14:23:06 <cdsmith> benmachine: Not sure I understand...
14:23:07 <dmwit> cdsmith: Yes, there's a type-level composition somewhere on Hackage.
14:23:11 <dmwit> let's see if we can find it...
14:23:41 <benmachine> cdsmith: I mean, if you were using ReaderT r (StateT s IO) a, then you could use put, get, ask, liftIO directly
14:23:43 <elliottt> dmwit: http://hackage.haskell.org/package/TypeCompose
14:23:47 <benmachine> on account of MonadState, MonadReader, and MonadIO
14:24:12 <benmachine> transformers has a Data.Functor.Compose these days
14:24:20 <cdsmith> banmachine: Ah, no, the point is I need to use a generic combinator that relies on lift.
14:24:29 <dmwit> That doesn't have an instance for MonadTrans, but it easily could be added.
14:25:03 <cdsmith> dmwit: Okay, thanks.  I have my own newtype, so I was just wondering if I could clean it up... I'll take a look at that
14:25:32 <dmwit> I think it probably should have one. =)
14:29:43 * hackagebot fb 0.9.6 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.9.6 (FelipeLessa)
14:30:36 <nurpax> hi, I realize this may be a controversial topic..  but is there an idiomatic way to deal with haskell record name spaces?  I have two records, both which carry a "project" field.  So I named the other one "project" and the other "lmProject" to prefix with ListenMask.
14:31:44 <dmwit> For now, the best practice is to put them in different modules.
14:31:59 <dmwit> Some will recommend prefixing all fields in both types as an alternative.
14:32:15 <cdsmith> nurpax: Yep, that's pretty much what we do now.  Overlong names, or different modules with qualified imports.
14:32:34 <dmwit> The advantage of prefixing is that it's low overhead for the person writing the types; the advantage of different modules is that the client gets to choose the prefix (or none at all).
14:34:08 <nurpax> Thanks!  I somehow overlooked the qualified imports option.  That may suit my style better
14:34:44 * hackagebot wai-middleware-static 0.2.1 - WAI middleware that intercepts requests to static files.  http://hackage.haskell.org/package/wai-middleware-static-0.2.1 (AndrewFarmer)
14:36:08 <nurpax> I suppose the design discussion about improving record name spaces will go on and on still? :)
14:37:54 <strager> @dijin e -> Maybe a -> Either e (Maybe a)
14:37:55 <lambdabot> f a b =
14:37:55 <lambdabot>     case b of
14:37:55 <lambdabot>     Nothing -> Left a
14:37:55 <lambdabot>     Just c -> Right (Just c)
14:38:07 <strager> Good dijin.
14:38:36 <adamt> is there something like netty for haskell, suitible for writing a http reverse proxy?
14:41:31 <tazjin> adamt: Happstack.Server.Proxy
14:44:29 <adamt> tazjin: how does it perform?
14:46:32 <tazjin> adamt: Pretty good, I think Warp is a bit faster at the moment but the Happstack team is working on catching up. As for alternatives, there's mighthttpd which is based on WAI/Warp
14:46:42 <tazjin> I can't tell you any benchmark scores, you'd have to check for yourself ;-)
14:48:29 <zzo38> You could have classes for the record names but that doesn't work with record update syntax.
14:48:29 <adamt> tazjin: warp can't proxy on it's own, can it?
14:49:43 <luca> yaaay haskell is starting to click more! needed to make a function a->a into [a]->[a] and instantly thought 'oh yeh, liftM f' :D
14:49:57 <Botje> map not good enough? ;)
14:50:06 <zzo38> luca: You can also use map, fmap, or <$>
14:50:14 <S11001001> :t (.)
14:50:16 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:50:16 <tazjin> adamt: I'm not sure if it can, don't think so though. For reverse proxying I'm using nginx at work
14:50:41 <luca> liftM is more general though :P
14:50:47 <S11001001> au contraire
14:50:59 <andares> :t liftM
14:51:01 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
14:51:02 <luca> i meant than map
14:51:04 <zzo38> luca: fmap is the same as liftM except that liftM is for monads only, fmap is any functor
14:51:10 <tazjin> adamt: As for Happstack performance, I'm sure stepkut would answer your questions on #happs :-)
14:51:17 <zzo38> (Monads are also endofunctors)
14:51:19 <andares> why does liftM exist?
14:51:32 <S11001001> because Functor f =/> Monad f
14:51:48 <donri> andares: it allows you to easily define a Functor from a Monad and allows you to fmap without a Functor constraint
14:52:45 <andares> oh, wow. I thought all monads were functors for some reason.
14:52:52 <zzo38> I think it is stupid way to define those classes. Better would be something like:  class Functor m => Monad m where { return :: x -> m x; join :: m (m x) -> m x; };
14:53:05 <donri> they are, but that's not reflected in the class definition for monad for historical reasons
14:53:08 <zzo38> andares: They are supposed to be, but the standard class doesn't define them like that and cause problem
14:53:28 <adamt> tazjin: Thank you for the suggestions :-)
14:53:41 <donri> zzo38: or rather Applicative m => Monad m and get rid of return :)
14:54:07 <S11001001> lots of weird stuff to jump that barrier; for example, Data.Traversable defines Applicative and Monad variants that are otherwise the same
14:54:21 <zzo38> donri: That works too, but I wanted to be able to generalize it to categories where monads are not necessarily applicative
14:54:37 <donri> monads are supposed to be applicative always
14:54:37 <S11001001> zzo38: which ones?
14:55:49 <Stalafin> I am confused... what's the point of having (=<<) and (>>=) ?
14:56:35 <donri> =<< feels more like function application (e.g. like ($)) and is sometimes preferred stylistically
14:56:38 <otters> to sequence monadic actions
14:56:50 <ion> (=<<) matches better with (<$>), (.) etc, but (>>=) fits sequentially executed stuff like IO better.
14:57:11 <Stalafin> donri, ion: okay, great, thanks
14:57:12 <zzo38> donri: But I wanted to generalize it (perhaps in ways which Haskell simply doesn't do, but Ibtlfmm would) so that you have (MonadC :: (k -> k -> *) -> (k -> *) -> &) to generalize to other categories
14:57:24 <Stalafin> My grasp on those monads is still kinda shaky
14:57:27 <hpaste> fragamus pasted “GOLF ANYONE?” at http://hpaste.org/69676
14:57:45 <zzo38> Actually not quite the type I gave, but that is the idea
14:58:02 <ion> > (f =<< g) x
14:58:03 <lambdabot>   Ambiguous occurrence `f'
14:58:04 <lambdabot>  It could refer to either `L.f', defined at <local...
14:58:06 <donri> ok, i didn't follow the discussion for that long :)
14:58:07 <ion> > (f =<< g) x :: Expr
14:58:09 <lambdabot>   Ambiguous occurrence `f'
14:58:09 <lambdabot>  It could refer to either `L.f', defined at <local...
14:58:21 <ion> Wait… there are two fs in scope?
14:58:28 <zzo38> It should be (k -> k) in there rather than (k -> *) I think
14:58:30 <parcs`> @undefine
14:58:35 <ion> > (f =<< g) x :: Expr
14:58:36 <lambdabot>   Ambiguous type variable `a' in the constraints:
14:58:36 <lambdabot>    `SimpleReflect.FromExpr ...
14:58:56 <luca> :t =<<
14:58:57 <lambdabot> parse error on input `=<<'
14:59:01 <luca> :t (=<<)
14:59:02 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
14:59:04 <fragamus> I have a lot of monadic functions like that one in my paste. Is there any way to make it more terse
15:00:15 <ion> > ((f :: Expr -> Expr -> Expr) =<< g) x
15:00:16 <lambdabot>   f (g x) x
15:00:20 <ion> > ((f :: Expr -> Expr -> Expr) <*> g) x
15:00:21 <lambdabot>   f x (g x)
15:00:26 <Stalafin> Woah, where's that "forall (m :: * -> *)b." coming from?
15:00:44 <Stalafin> That stuff after it I know from prelude
15:00:47 <ion> stalafin: -fprint-explicit-foralls
15:00:50 <hpc> Stalafin: extra lambdabot flags
15:01:01 <zzo38> type Category = CategoryR ();     (in Ibtlfmm; obviously won't work in Haskell)
15:02:22 <jfischoff> benmachine: grabbed head everything works, even with cabal-dev. Thanks!
15:02:24 <zzo38> And the kind of CategoryR should be ((k -> &) -> (k -> k -> *) -> &)
15:03:51 <fragamus> ok so no golfers...
15:04:34 <parcs`> fragamus: hlint
15:04:55 <fragamus> is there anyone who can tell me why hint wants me to use camel case
15:05:07 <fragamus> what's so great about camel case
15:05:15 <jfischoff> its just a convention
15:05:24 <fragamus> the Japanese coders don't like it and it is confusing to them
15:06:03 <zzo38> Japanese people hate camel case?
15:06:11 <luca> japanese just generally hate camels
15:06:22 <jfischoff> I think a lot of Haskellers like _underscores_ but they use what ever is being used.
15:06:40 <luca> i went camel case just to shut hlint up on it :P
15:06:45 <cdsmith> Hmm... let me back up a bit on my previous problem... is there such a thing as a general innerLift :: (MonadTrans t, MonadTrans s, Monad m) => t m a -> t (s m) a?  Or anything similar?  Maybe my weird Foo m a -> t m a combinator was unnecessary.
15:06:56 <ion> I do dislike theHaskellStyleOfNamingThings, but not enough to go against the convention.
15:06:56 <zzo38> In Haskell only the first letter uppercase/lowercase is important the rest you can use the whatever you want to define them as
15:07:30 <fragamus> upper and lower case is just alien to some cultures
15:07:59 <zzo38> fragamus: It is important in Haskell the first letter uppercase/lowercase, though
15:08:12 <bungley> could someone please show me the right way to write this line (without do notation): return (getLine >>= (++ "foo"))
15:08:15 <fragamus> I understand
15:08:19 <Stalafin> That's a problem if you are using English as a "base language" for programming (no idea how you would call that linguistically)
15:08:23 <Cale> I hate underscores
15:08:29 <cdsmith> Yes, Haskell (GHC extensions, anyway) even inviented upper and lower case punctuation
15:08:31 <zzo38> bungley: What are you trying to do?
15:08:47 <zzo38> Perhaps ((++ "foo") <$> getLine) is what you want?
15:08:48 <bungley> append foo to a line of input
15:08:52 <Stalafin> fragamus: can't you program in Japanese?
15:09:02 <zzo38> bungley: Then,   ((++ "foo") <$> getLine)   is what you want
15:09:02 <Stalafin> :D
15:09:14 <bungley> zzo38: could you do it with only >>= and return?
15:09:20 <fragamus> no :P
15:09:28 <zzo38> bungley: Yes:   getLine >>= return . (++ "foo")
15:09:44 <Cale> I can't really explain why I dislike underscores, but I consider them way uglier typographically than CamelCase is.
15:09:48 <bungley> where the blethering hell did that dot come from!
15:09:51 <bungley> (thanks!)
15:09:57 <zzo38> bungley: But I consider that a bad way to do it and   ((++ "foo") <$> getLine)   is better in my opinion
15:10:07 <fragamus> but rubyists know that some cultures are confused by it and so we adopted a convention not to use it
15:10:15 <Cale> Hyphens would be ideal, if it weren't for the fact that hyphen is being used for subtraction and negation.
15:10:27 <rwbarton> even more low-level would be getLine >>= \x -> return (x ++ "foo")
15:10:49 <bungley> rwbarton: ooh thanks
15:10:52 <Stalafin> Cale: talking about typography in a pure text monospace display is kinda... funny :D
15:11:17 <cdsmith> bungley: . is function composition: (f . g) x = f (g x)
15:11:21 <Cale> If only keyboards had separate − and - keys.
15:11:25 <zzo38> join . fmap return = id    so that would work but there isn't much reason to explicitly write   (>>= return)
15:11:55 <bungley> i'd like to learn the language before i learned the sugar
15:12:06 <parcs`> the sugar is the language
15:12:08 <zzo38> Cale: There are a separate hyphen and subtraction key but they are far away and represent the same ASCII character anyways
15:12:08 <cdsmith> Cale: That would be awful!  You cannot tell the difference without holding a ruler up agaist the monitor
15:12:08 <luca> isn't >>= return completely pointless?
15:12:35 <ion> luca: It *should* be… except http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Exception-Base.html#v:evaluate :-P
15:12:41 <luca> :t (>>= return)
15:12:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
15:12:51 <Cale> cdsmith: depends on the typeface, usually minus is significantly longer than a hyphen
15:12:59 <zzo38> luca: Yes, because   join . return = join . fmap return = id   is a monad law so   (>>= return) = id   is same as that
15:13:10 <Cale> (to the extent that you shouldn't need a ruler)
15:14:06 <Cale> also, people would tend to put spaces around minus
15:14:31 <saep> which is a waste of character space!
15:14:37 <Stalafin> Cale: hyphens, en-, and em-dashes, and a minus are all completely different hings
15:14:45 <Cale> Stalafin: I agree
15:14:54 <Stalafin> especially since a minus is a binary operator
15:15:08 <Stalafin> Cale: and as you mentioned, therefore requires space before and after
15:15:18 <ion> (return $! undefined :: IO ()) `seq` putStrLn "foo"
15:15:20 <ion> ((return $! undefined) >>= return :: IO ()) `seq` putStrLn "foo"
15:15:24 <zzo38> You could, if you wanted to, program the computer for the subtraction key to do something different than the hyphen key, but I do not think this is necessary
15:15:26 <fragamus> HeyIHaveAnIdeaWhyDontYouTryToReadThisAndSeeWhichOneYouEndUpLookingAtWhichOneCale?Which????
15:15:27 <fragamus> Hey_I_have_an_idea_Why_dont_you_try_to_read_this_and_see_which_one_you_end_up_looking_at_Which_one_Cale?_Which????
15:15:47 <Cale> fragamus: Neither of those are reasonable identifiers
15:15:51 <cdsmith> Stalafin: different characters, yes.  Sensiblie to use them all as different legal syntax in a programming language? No.
15:16:33 <Stalafin> cdsmith: true, especially if you want to stick to ascii
15:16:45 <Stalafin> cdsmith: I guess using unicode would mess stuff up :)
15:16:47 <zzo38> And I do want to stick to ASCII
15:17:00 <Cale> But I think it would be nice if minus had been an ASCII character separate from the hyphen
15:18:37 <Cale> window-width − button-width
15:18:43 <luca> isss there a function :: (a -> m b) -> n a -> m (n a)
15:19:06 <Cale> luca: depends on n and m
15:19:07 <rwbarton> multiple such functions
15:19:09 <zzo38> luca: Depends on the types; that is not possible with all types
15:19:10 <Stalafin> Cale: but is that really necessary on a computer? Typographically this all makes sense, but for that you'd rather use LaTeX or something similar, i.e. if you want to prepare a document.
15:19:20 <luca> m is monad, n is constructor
15:19:36 <Veinor> luca: i assume you meant m (n b)?
15:19:38 <Cale> Stalafin: I mean, it would be nice because hyphen wouldn't be stolen for subtraction, and we could then use it inside of identifiers.
15:19:40 <rwbarton> lucaFun _ x = return x
15:19:57 <parcs`> f _ _ = mezore
15:20:01 <parcs`> mzero :(
15:20:03 <Cale> Stalafin: They do this in scheme, because it's unambiguous in scheme's syntax.
15:20:06 <Stalafin> Cale: ah, now i see what you mean :D
15:20:07 <rwbarton> lucaFun f x = f x >> return x
15:20:09 <rwbarton> etc.
15:20:14 <rwbarton> oh wait, not that
15:20:20 <luca> have method t :: forall a. (a -> a) -> N a -> N a
15:20:36 <luca> and f :: Expr -> m Expr for monad M
15:20:38 <zzo38> I mean, if I want typesetting then yes I will use TeX, where $-$ means subtraction, - means hyphen, -- means en-dash, --- means em-dash (these are using the Plain TeX definitions; if they are redefined they differ)
15:20:39 <luca> m*
15:20:45 <rwbarton> I will probably get crucified for this but you should think less in terms of types and more in terms of what you actually want to do
15:20:53 <luca> want to get: N Expr -> m (N Expr)
15:20:54 <fragamus> so back to my original question. I'm still a rookie at using the state monad and I want to know what a good haskeller would do with this:
15:20:56 <fragamus> fragamus pasted “GOLF ANYONE?” at http://hpaste.org/69676
15:22:00 <luca> though i dunno, maybe i need a seperate method for it, like map vs mapM etc
15:22:40 <cdsmith> fragamus: That looks fine to me.  You could use modify instead of get/put... but what you write is perfectly good.
15:23:13 <dmwit> I'd use splitAt to traverse the center list only once, as well.
15:23:21 <dmwit> Well, only twice instead of four times, rather. =)
15:23:41 <fragamus> ok I shall try to incorporate modify and splitAt
15:25:15 <hpaste> dmwit annotated “GOLF ANYONE?” with “GOLF ANYONE? (annotation)” at http://hpaste.org/69676#a69677
15:25:23 <dmwit> Not shorter, but this is probably how I would write it.
15:26:38 <luca> oh lol
15:26:42 <luca> traverse.... again
15:26:46 <luca> always traverse i swear
15:27:00 <luca> :t Data.Traversable.treverse
15:27:02 <lambdabot> Not in scope: `Data.Traversable.treverse'
15:27:08 <luca> :t Data.Traversable.traverse
15:27:09 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
15:27:13 <cdsmith> so something like: cut_in_half = modify foo where foo (_, center, _) = let n = length center `div` 2 ; (a,b) = splitAt n center in (a, [], b) -- except with better formatting
15:27:27 <fragamus> nice
15:27:47 <dmwit> cdsmith: Yeah, that looks fairly reasonable, too.
15:29:12 <dmwit> I guess in my annotation I'd use the names "top,center,bottom" instead of "frst,scnd,thrd", too.
15:31:45 <dzhus> should I use StateT from transformers or mtl (even knowing that the latter is implemented using the former)?
15:32:00 <dzhus> consider it a poll
15:32:30 <strager> Use package imports and mix the two.
15:36:23 <dmwit> dzhus: Uh, aren't they the same StateT?
15:37:04 <dmwit> dzhus: mtl just re-exports transformers' StateT
15:39:56 <dzhus> dmwit: yes, that's the problem
15:40:26 <dzhus> do you know what it feels like when you can't pick between two identical things...
15:40:29 <zzo38> What is code for file exist or not?
15:40:50 <cdsmith> zzo: System.Directory.doesFileExist, right?
15:41:07 <cdsmith> In the directory package
15:41:40 <zzo38> OK
15:46:58 <hpaste> luca pasted “need a combinator!” at http://hpaste.org/69678
15:47:04 <luca> help please :D
15:47:47 <luca> (PreExpr, b1, [(PreExpr, b1)], Maybe b1) == Pre b1
15:51:37 <strager> luca: What's the type of uncomplicate?
15:51:52 <luca> it's at top, Expr -> State Int Expr
15:51:59 <strager> ah, didn't see it
15:52:34 <strager> uncomplicate (EPre pre) = return $ EPre $ transpre uncomplicate pre
15:52:53 <strager> It doesn't seem that you're using the state, so you do'nt need to use >>= with transpre
15:53:15 <strager> Or, you can just replace "pre' <-" with "let pre' ="
15:53:31 <luca> uncomplicate uses state in other places
15:54:10 <strager> oh, then just rewrite it to 'let' instead of '<-'
15:54:23 <strager> since transpre is not monadic
15:54:56 <luca> but if transpre is making calls to uncomplicate which is monadic?
15:55:39 <luca> do i need to write a related transpre, like transpreM to take (a -> m b) -> Pre a -> m (Pre b)
15:55:39 <luca> ?
15:55:51 <strager> Oh, I see
15:56:16 <luca> essentially that's what i'm trying to avoid, use some combinator to turn transpre into transpreM :P
15:56:19 <strager> I'd think so, yes; you need to make transpreM
15:56:36 <strager> I don't think you can (generally), because b is wrapped in Pre
15:56:54 <luca> is it the same with things like liftM, mapM, concatM etc?
15:56:54 <luca> :P
15:56:58 <strager> if it was (a -> b) -> Pre a -> b, and b :: m c, it'd magically turn into a monad
16:00:14 <luca> :t liftM2
16:00:15 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
16:00:20 <luca> okay no
16:00:27 <luca> :t liftM . liftM
16:00:28 <lambdabot> forall (m :: * -> *) a1 r (m1 :: * -> *). (Monad m, Monad m1) => (a1 -> r) -> m (m1 a1) -> m (m1 r)
16:03:18 <strager> luca: Maybe work backwards; find the function which matches the type you want
16:05:58 <luca> there's traverse, which has the right 'shape' but not type matchable
16:06:44 <hpaste> stj pasted “this has blown my mind, my jaw has dropped, i'm puzzled and amazed” at http://hpaste.org/69679
16:07:01 <stj> just some code I took from Haskell wiki, this program is very fast and consumes almost no memory :O
16:08:12 <dmwit> > 10^9 `div` 2 `div` 8
16:08:13 <lambdabot>   62500000
16:08:27 <dmwit> I expect it to consume about 62500000 bytes. =)
16:08:36 <dmwit> > 62500000 `div` 1024
16:08:37 <lambdabot>   61035
16:08:42 <strager> 21MB
16:08:44 <dmwit> 60 megs
16:08:45 <strager> 61MB
16:08:54 <stj> awesome, so UArray Int Bool is automatically implemented with bitmasks
16:09:15 <Guest49485> what is the point of using the $ symbol? is it really only to get rid of one set of parenthesis?
16:09:25 <luca> pretty much
16:10:01 <parcs`> consider 'forkIO $ do {- 10 line do expression -}' vs 'forkIO (do {- 10 line do expression -})'
16:10:05 <rwbarton> Sometimes it gets rid of two sets of parentheses :)
16:10:06 <stj> besides, I don't get what's the fuss about about sieve of Erathostenes in Haskell... I find this code neat, clean, nice and cool
16:10:07 <Cale> Guest49485: yeah, basically it's just function application with really low precedence
16:10:20 <rwbarton> f . g $ x + y
16:10:44 <Cale> Guest49485: function composition has higher precedence, so you can compose a chain of functions and then use $ to apply the composed function to an argument
16:11:23 <Guest3812> Cale: does that mean that the function is then called later rather than sooner?
16:12:11 <otters> no
16:12:20 <otters> it means f $ ... is the same as f (...)
16:12:22 <otters> and if ... is really long
16:12:25 <otters> you'll thank $
16:13:03 <Guest3812> so it is really mostly used for readability
16:13:10 <otters> yes
16:13:15 <Guest3812> okay thanks
16:13:59 <zzo38> How sufficient are applicative laws in terms of (pure mempty) and (liftA2 mappend)?
16:14:22 <parcs`> Guest3812: it's also used as an argument to a higher order function
16:14:37 <parcs`> > zipWith ($) [sin,cos] [0,pi]
16:14:38 <lambdabot>   [0.0,-1.0]
16:14:39 <zzo38> But ($) = id
16:14:51 <zzo38> So you should use   zipWith id
16:14:55 <parcs`> but id = \x -> x
16:15:44 <parcs`> so you should use zipWith (\x -> x) ?
16:15:45 <cdsmith> parcs`: ($) is a type-restricted id:  id :: a -> a, and ($) :: (a -> b) -> (a -> b)
16:15:57 <zzo38> cdsmith: Yes
16:16:07 <luca> > zipWith id [sin,cos] [0,pi]
16:16:08 <lambdabot>   [0.0,-1.0]
16:16:11 <parcs`> cdsmith: i know but i think zzo38 is wrong with his reasoning
16:16:12 <nand`> :t id `asAppliedTo` unsafeCoerce
16:16:14 <lambdabot> Not in scope: `unsafeCoerce'
16:16:18 <nand`> :(
16:16:31 <zzo38> parcs`: Why is it wrong?
16:16:47 <nand`> > zipWith id [sin,cos] [0,pi]
16:16:48 <lambdabot>   [0.0,-1.0]
16:16:51 <Guest3812> didnt mean to start a flame war, just wanted to know what it is used for
16:16:58 <nand`> > [sin,cos] <*> [0,pi]
16:16:59 <lambdabot>   [0.0,1.2246467991473532e-16,1.0,-1.0]
16:17:03 <nand`> oh
16:17:09 <nand`> > ZipList [sin,cos] <*> ZipList [0,pi]
16:17:10 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList a))
16:17:10 <lambdabot>    arising ...
16:17:18 <luca> <*> works like a set product haha
16:17:18 <Cale> Guest3812: You didn't :)
16:17:21 <luca> :t <*>
16:17:21 <lambdabot> parse error on input `<*>'
16:17:25 <nand`> ZipList has no Show instance?
16:17:26 <luca> :t (<*>)
16:17:27 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:17:37 * nand` is baffled
16:17:56 <parcs`> zzo38: why suggest zipWith id instead of zipWith (\x -> x)?
16:17:58 <Cale> Guest3812: also,  f . g . h $ x + y + z is the same as  (f . g . h) (x + y + z), so you can save two sets of parens sometimes. :)
16:18:02 <luca> > [const 1, id, ^2] [1..]
16:18:03 <lambdabot>   A section must be enclosed in parentheses thus: (^ 2)
16:18:08 <luca> > [const 1, id, ^2] <*> [1..]
16:18:09 <lambdabot>   A section must be enclosed in parentheses thus: (^ 2)
16:18:14 <luca> > [const 1, id, (^2)] <*> [1..]
16:18:15 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:18:22 <luca> > [const 1, id, (^2)] <*> [1,2,3]
16:18:22 <zzo38> parcs`: It is shorter, and in my opinion is more reasonable
16:18:23 <lambdabot>   [1,1,1,1,2,3,1,4,9]
16:18:27 <cdsmith> parcs`: I don't understand the conversation, I guess... they are the same thing
16:18:31 <Guest3812> Cale: thanks
16:18:32 <luca> > [const 1, id, (^2)] <*> [1..10]
16:18:32 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,2,3,4,5,6,7,8,9,10,1,4,9,16,25,36,49,64,81,100]
16:19:12 <luca> > [(^n) | n <- [1..10]] <*> [1..10]
16:19:13 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,1,4,9,16,25,36,49,64,81,100,1,8,27,64,125,216,343,512...
16:19:20 <parcs`> zipWith ($) is not shorter, but to the majority of people more reasonable than zipWith id
16:19:46 <zzo38> Well, to me, the ($) is just the infix id
16:19:46 <luca> :t id
16:19:47 <lambdabot> forall a. a -> a
16:19:54 <cdsmith> I agree... I'd normally write zipWith ($) versus zipWith id
16:20:14 <luca> ($) has type a -> b so there are places where you cannot use id ?
16:20:41 <luca> zipWith id [\x -> show x, id] [1.0, 2.0]
16:20:43 <nand`> ($) does not have type a -> b
16:20:50 <cdsmith> luca: But zipWith isn't one.  zipWith id already constrains the type of id to that of ($).  It's just a little more confusing
16:20:51 <sipa> :t ($)
16:20:53 <lambdabot> forall a b. (a -> b) -> a -> b
16:22:24 <luca> > zipWith id [\x -> show x, id] [1.0, 2.0]
16:22:24 <luca> wait obvs fail
16:22:24 <luca> > zipWith id [\x -> show x, const "x"] [1.0, 2.0]
16:22:24 <luca> lambdabot? :(
16:22:25 <luca> well gchi doesn't complain
16:22:25 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Base.String)
16:22:25 <luca> *confused*
16:22:25 <lambdabot>    arising from the l...
16:22:25 <lambdabot>   can't find file: L.hs
16:22:26 <luca> aahh
16:22:27 <luca> okay
16:22:33 <luca> i thought ($) was a -> b
16:22:36 <luca> not (a -> b) -> (a -> b)
16:22:41 <nand`> that would be a type error
16:22:44 <luca> so id is more general :D
16:22:50 <nand`> well, it would make the type system unsound
16:22:59 <nand`> id is indeed more general than ($)
16:23:06 <nand`> but zipWith id and zipWith ($) have the same type
16:23:11 <luca> yeh
16:23:21 <geekosaur> if yoiy think about it, nothing can meaningfully be (a -> b) except _|_ (unsafeCoerce doesn't count)
16:23:58 <luca> i guess
16:25:58 <luca> wtf
16:26:12 <luca> ghci, :l module.hs, :t func  (where func is exported by module)... error not in scope
16:26:26 <nand`> luca: you need to import the module too I think
16:26:29 <nand`> could be mistaken
16:26:37 <luca> never needed to before :P
16:27:12 <luca> how do you import module in ghci?
16:27:23 <nand`> never mind, you don't have to import it manually
16:27:30 <nand`> but if you did, “import <module name here>”
16:27:33 <luca> well :t Module.func is working
16:31:02 <luca> :t second
16:31:03 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
16:31:38 <luca> :t second const 1
16:31:39 <lambdabot> forall b b1 d. (Num d, Num b) => (d, b1 -> b)
16:31:51 <luca> :t second (const 1)
16:31:52 <lambdabot> forall t b d. (Num t) => (d, b) -> (d, t)
16:32:11 <luca> :t liftM second (const 1)
16:32:12 <lambdabot> forall (a :: * -> * -> *) b c d b1. (Arrow a, Num (a b c)) => b1 -> a (d, b) (d, c)
16:32:24 <luca> :t (liftM second) (const 1)
16:32:25 <lambdabot> forall (a :: * -> * -> *) b c d b1. (Arrow a, Num (a b c)) => b1 -> a (d, b) (d, c)
16:32:40 <luca> :t second (liftM (const 1))
16:32:41 <lambdabot> forall t a1 (m :: * -> *) d. (Num t, Monad m) => (d, m a1) -> (d, m t)
16:33:33 <dmwit> :t second (>> return 1)
16:33:34 <lambdabot> forall (m :: * -> *) a t d. (Num t, Monad m) => (d, m a) -> (d, m t)
16:33:58 <dmwit> :t second (liftM 1)
16:33:58 <lambdabot> forall a1 r (m :: * -> *) d. (Num r, Monad m) => (d, m a1) -> (d, m r)
16:34:12 <dmwit> =)
16:34:15 <luca> heh
16:34:17 <luca> not that it's what i need
16:34:27 <nand`> :t second (1 <$>)
16:34:28 <lambdabot> forall a b (f :: * -> *) d. (Num b, Functor f) => (d, f a) -> (d, f b)
16:34:31 <nand`> generalized!
16:35:12 <nand`> :t fmap (fmap 1)
16:35:13 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Num b, Functor f, Functor f1) => f1 (f a) -> f1 (f b)
16:35:37 <luca> so far, for transpreM i have taken: let ife' = xf ife  =>  ife' <- xf ife,  let e' = liftM xf e  =>  e' <- traverse xf e
16:35:49 <luca> now stuck on transforming let s' = map (second xf) s
16:35:50 <dmwit> > fmap (fmap 1) ("a", "b")
16:35:50 <lambdabot>   ("a",[1])
16:35:51 <luca> to monadic version
16:36:01 <nand`> :)
16:36:27 <dmwit> luca: Sorry, I must have missed something. Why aren't you writing a Traversable instance for Pre?
16:36:52 <luca> that would help?
16:37:05 <dmwit> Didn't you say traverse was the type you wanted?
16:37:12 <luca> wait, if i did that I could just use traverse straight up
16:37:26 <luca> since Pre would be instance of Traverse
16:37:30 <luca> bah :P
16:38:22 <luca> so need to define traverse
16:38:24 <luca> for Pre
16:38:36 <shachaf> > fmap fmap fmap 1 ("a","b")
16:38:37 <lambdabot>   ("a",[1])
16:38:57 <luca> the thing is, to do that i still need to solve the problem right now
16:38:59 <luca> since it's the same problem
16:39:03 <nand`> > 1 .: ("a", "b")
16:39:05 <lambdabot>   ("a",[1])
16:39:06 <nand`> what do I win?
16:39:09 <dmwit> luca: yes
16:39:15 <luca> only instancing Traversable would be more general, but i don't need more general here
16:39:46 <otters> :t (.:)
16:39:47 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
16:40:20 <hpaste> luca annotated “need a combinator!” with “need a combinator! (annotation)” at http://hpaste.org/69678#a69680
16:42:01 <hpaste> luca annotated “need a combinator!” with “need a combinator! (annotation) (annotation)” at http://hpaste.org/69678#a69681
16:42:03 <luca> *even
16:42:13 <luca> one line left to fill in haha
16:42:50 <luca> :t return . traverse
16:42:51 <lambdabot> Not in scope: `traverse'
16:42:59 <luca> :t return . Data.Traversable.traverse
16:43:00 <lambdabot> forall (m :: * -> *) a (f :: * -> *) b (t :: * -> *). (Monad m, Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> m (t a -> f (t b))
16:43:15 <luca> hah
16:54:43 <luca> nand` :)
16:59:15 <luca> baaah
16:59:16 <luca> nearly got it
16:59:29 <luca> i have transpreM :: (a -> [b]) -> Pre a -> [Pre b]
16:59:41 <luca> not sure why it constrains to List instead of general monad
16:59:57 <otters> how would I go about splitting a list of Strings into chunks with a total length of n
17:00:12 <nand`> otters: “chunk”
17:00:26 <luca> as in ["ab","cdef"] -> ["abc","def"]  ?
17:00:44 <otters> no
17:00:59 <luca> :t chunk
17:01:00 <lambdabot> Not in scope: `chunk'
17:01:09 <nand`> :t Data.List.Split.chunk
17:01:10 <lambdabot> Couldn't find qualified module.
17:01:15 <luca> nand`, can you think why it would be constraining to List monad?
17:01:28 <otters> as in f 7 ["abc", "foobar", "baz", "qux"] == [["abc"], ["foobar"], ["baz", "qux"]]
17:01:36 <otters> kind of a groupBy
17:01:54 <nand`> luca: I have no idea what the body of transpreM is
17:02:01 <luca> i'll update hpaste
17:02:30 <nand`> otters: I'm not sure I understand the logic behind that ‘f’
17:02:41 <otters> nand`: f is the name of the function
17:02:46 <otters> the hypothetical function
17:02:59 <nand`> otters: that's not what I meant
17:03:01 <tazjin> otters: Yes, but what exactly does it do? I find your example result a bit confusing
17:03:09 <nand`> here's my guess:
17:03:26 <nand`> keeps concatenating until the new string would be >7, if so, starts a new group
17:03:30 <otters> right
17:03:44 <otters> so it would have type Int -> [String] -> [[String]]
17:03:49 <nand`> (of course that naive definition would fail on a single substring >7)
17:03:54 <hpaste> luca annotated “need a combinator!” with “need a combinator! (annotation) (annotation) (annotation)” at http://hpaste.org/69678#a69682
17:04:17 <otters> and f n xs would return a list of strings ys so that all (< n) $ map length ys is true
17:04:46 <otters> err
17:04:48 <otters> <= n
17:04:50 <nand`> otters: so it breaks off substrings that are >n in length?
17:04:55 <nand`> or omits them?
17:05:03 <otters> yeah
17:05:08 <nand`> which one is it? :P
17:05:13 <otters> oh, sorry
17:05:15 <otters> it omits
17:05:22 <otters> but in practice, n is way bigger than the length of any of the input strings
17:05:26 <otters> so I'm not worried about that
17:06:03 <luca> nand` if i give a type for it, i just get an error that it cannot deduce m ~ []
17:06:03 <luca> heh
17:07:30 <startling> hi. is there something for joining a list of strings into a FilePath in a cross-platform way?
17:07:47 <nand`> luca where is ‘Pre’ defined?
17:08:00 <luca> Pre is (PreExpr, b1, [(PreExpr, b1)], Maybe b1)
17:08:01 <nand`> startling: are you thinking about </> maybe?
17:08:15 <startling> nand`, what does </> do?
17:08:32 <startling> and where do i find it?
17:08:36 <otters> this is proving to be rather more complicated than I expected
17:08:39 <nand`> startling: works like a ++ "/" ++ b but instead of / it uses a cross-platform way of combining paths
17:08:55 <startling> nand`: lovely. where do i find it?
17:09:23 <nand`> System.FilePath.Windows or System.FilePath.Posix
17:09:38 <nand`> I thought it was inherently cross platform, guess not; you need to import the right version
17:09:53 <startling> that's a little annoying. :/
17:10:09 <startling> I guess it'd need to be an IO if it were system-dependent
17:10:16 <startling> or decided at compile-time
17:10:21 <nand`> startling: the latter, I suppose
17:10:52 <startling> oh well
17:11:03 <startling> screw you, windows!
17:11:06 <nand`> I'm not too sure about cross-platform programming myself (I stick to POSIX :) but since they seem to have the same type you can probably just import the right version with some #conditional
17:11:16 <luca> that i'm aware windows will translate / in paths to \
17:11:24 <nand`> yes, that too
17:11:28 <startling> oh, http://www.haskell.org/ghc/docs/6.12.2/html/libraries/filepath-1.1.0.4/System-FilePath.html
17:11:31 <luca> so / 'should' be relatively cross platform for at least windows/*nix
17:11:38 <startling> "A library for FilePath manipulations, using Posix or Windows filepaths depending on the platform."
17:11:42 <startling> neat
17:13:10 <nand`> startling: oh, neat
17:14:28 <nand`> hoogle didn't pick up “System.FilePath”, just the two platform-specific ones :P
17:20:08 <luca> YES
17:20:18 <luca> playing in ghci, managed to get it finally
17:20:32 <luca> though i cannot restrict to just Monad m. if i let type inference do it's job it works okay
17:21:20 <luca> type comes out from ghci inferred as: (Data.Traversable.Traversable t, Control.Applicative.Applicative m, Monad m) => (a1 -> m t2) -> (t1, a1, [(a, a1)], t a1) -> m (t1, t2, [(a, t2)], t t2)
17:22:24 <blackdog> So, i'm thinking of wrapping a few APIs for Haskell, just to keep my hand in. Anyone got any recommendations for a good base to build on?
17:22:35 <blackdog> something like restclient, i suppose
17:25:50 <aristid> blackdog: http-conduit :)
17:26:25 <blackdog> aristid: was hoping for something a bit higher level :) maybe i can extract it when i'm finished.
17:26:40 <luca> @pl \x -> return $ P x
17:26:40 <lambdabot> return . P
17:26:58 <aristid> blackdog: well higher-level things tend to be specific to the API
17:27:09 <aristid> blackdog: which service/API do you want to wrap, if i may ask?
17:29:56 <blackdog> aristid: having a hack at veritable
17:30:39 <blackdog> aristid: usually you can abstract away stuff like auth etc
17:31:12 <aristid> blackdog: not if the auth is done as quirky as AWS... :D
17:33:06 <otters> @pl \f -> 1:1:zipWith (+) f (tail f)
17:33:07 <lambdabot> (1 :) . (1 :) . ap (zipWith (+)) tail
17:33:16 <blackdog> aristid: well, you might have to write a different module, but it's nice to have a structure to place it in
17:35:57 <hpaste> fragamus pasted “HOWS THIS FOR GOLFING?” at http://hpaste.org/69683
17:37:02 <fragamus> pardon the do do
17:38:20 <ratzes> does anybody know why ghc 7.4.1 would stop producing stub.o files?
17:39:04 <ratzes> from this example http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
17:40:28 <ratzes> for some reason on ghc 7.4.1 its not producing the Safe_stub.o file
17:40:46 <ratzes> but on ghc 7.0.3 it does
17:41:42 <otters> @pl \f g (a,b) -> (f a, f b, g a, g b)
17:41:43 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . join . ((flip . (ap .)) .) . ap . (flip .) . (flip =<< (((.) . (,,,)) .))
17:41:51 <otters> oh good I was worried it would be complicated
17:42:03 <geekosaur> *snrk*
17:42:16 <otters> @pl \f g (a,b) -> ((f a, f b), (g a, g b))
17:42:17 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (flip =<< (((.) . (,)) .))) . ap . (liftM2 (,) .) . (flip =<< (((.) . (,)) .))
17:42:27 <otters> *sigh*
17:42:53 <geekosaur> ratzes, the doucmentation says it should still be doing so; either this is a bug or the files were redirected somewhere else (are you using cabal?)
17:42:55 * overlapi joined
17:43:30 <ratzes> just apt install haskell platform ubuntu 12.04
17:43:59 <ratzes> it outputs Safe_stub.h and c
17:45:17 <otters> > undefined == undefined
17:45:18 <lambdabot>   *Exception: Prelude.undefined
17:47:38 <S11001001> it's not the same, I miss dmwitbot
17:49:14 <ratzes> is anybody else using ghc 7.4.1?
17:51:55 <ratzes> geekosaur, i also don't think it's getting redirected because Safe.o is present
17:52:17 <geekosaur> stubs are redirected separately, as I understand it
17:52:37 <geekosaur> in any case, lots of people use ghc 7.4.1; very few use foreign export though, I suspect.
17:53:05 <ratzes> do you know where they might be redirected to?
18:01:09 <geekosaur> I asked if you were using cabal because that's the usual way they'd have been redirected; if you're just typing ghc at a command line, they're not
18:01:44 <ratzes> oh, yeah, just ghc
18:02:06 <ratzes> so weird
18:29:38 <zzo38> I made up a program for type fo stack, so that you have such things as   s_add :: Num x => x :- x :- y -> x :- y; s_add (x :- y :- z) = (x + y) :- z;
18:30:02 * hackagebot iproute 1.2.6 - IP Routing Table  http://hackage.haskell.org/package/iproute-1.2.6 (KazuYamamoto)
18:33:01 <zzo38> data End = End; data x :- y where { (:-) :: Stack y => x -> y -> x :- y; }; infixr 5 :-;
18:37:53 <zzo38> Do you like this?
19:27:02 <zzo38> OK
19:41:06 <zzo38> Do you know what some monads are which are the codensity of something and/or the free monad of something?
19:41:37 <startlin1> any recommendations toward a library for manipulating git objects? git-object keeps failing with a cryptic *** Exception: ZlibException (-3)
19:42:01 <zzo38> startlin1: I don't know
19:44:56 <startling> zzo38: Okay
19:48:55 <hughfdjackson> at risk of opening a mares nest here
19:49:02 <hughfdjackson> :p if that's not mixing metaphors
19:49:27 <hughfdjackson> is dealing with memory usage significantly harder in haskell than in non-lazy languages?
19:51:06 <stepkut> hughfdjackson: not usually. Depends on what you are doing, but I don't spend much time dealing with it (as in.. I don't remember the last time I did)
19:51:18 <hughfdjackson> :D okay
19:51:46 <stepkut> that said.. I do plan to investigate some performance and memory related issues next week :p
19:52:18 <stepkut> but.. it is not something I deal with on a daily basis by any means
19:52:26 <hughfdjackson> that's basically what i was asking
19:52:46 <startling> hughfdjackson, I think the common complaint is that it's hard to reason about memory usage
19:52:59 <stepkut> not using foldl is a good way to start
19:53:04 <startling> heh
19:53:11 <hughfdjackson> Data.List + foldl'
19:53:17 <hughfdjackson> :p i read somewhere
19:53:26 <hughfdjackson> rwh, i suspect
19:53:27 <stepkut> yeah, or foldr sometimes
19:54:05 <stepkut> I probably do write code that uses more RAM than required.. but not more RAM than I have, so I don't notice :p
19:54:17 <hughfdjackson> haha, quite so
19:56:52 <zzo38> Do you know if   data LeftCoT m f x = forall z. LeftCo (f (m z) -> x) (f z);   is a comonad? Do you know if it is a comonad transformer?
20:05:42 <startling> hm, question about libraries: multiple librarys (git-object and hit) provide Data.Git; is this normal? how does that work?
20:07:21 <geekosaur> usually you use something like cabal to distinguish, and the libraries are mutually incompatible (e.g. use incompatible data structures to represent the same resources)
20:08:17 <geekosaur> if for some reason you need to use such a library without cabal, you can use -package on the ghc command line or use the PackageImports extension
20:08:26 <startling> geekosaur: oh, so haskell magically knows which one I want by build-depends?
20:08:28 <startling> neat
20:08:53 <geekosaur> erm?  no, when you use cabal you explicitly state your dependencies
20:09:11 <startling> geekosaur, with the build-depends field, right?
20:09:49 <geekosaur> yes
20:12:00 <startling> geekosaur: got it, thanks!
20:18:08 <startling> does cabal not come with an uninstall?
20:18:21 <geekosaur> no
20:19:00 <geekosaur> there is ghc-pkg unregister, but uninstall is ... problematic.  http://ivanmiljenovic.wordpress.com/2010/03/15/repeat-after-me-cabal-is-not-a-package-manager/
20:19:01 <startling> how do I specify which library to import in ghci?
20:19:23 <geekosaur> it's a wrapper for ghc's package manageement, which is not in any sense like an OS's package manager, it just knows how to find and link stuff
20:19:25 <dmwit> read back a bit =)
20:20:05 <startling> oh oops
20:20:12 <startling> geekosaur: thanks in hindsight!
20:23:38 <startling> so if i use -package with ghci, how do I import something from that package? it gets loaded at the beginning but it still gets me a "Ambiguous module name `Data.Git'"
20:23:48 <startling> (when I try to import it)
20:26:40 <unnali> startling: how about -hide-package THE_OTHER_ONE ?
20:26:53 <unnali> just scanning ghc(1) here
20:31:40 <startling> unnali: that works, thanks!
20:31:53 <startling> is it safe just to remove a directory from ~/.cabal/packages?
20:31:56 <unnali> great!
20:34:37 <geekosaur> safe but doesn't do anything useful; it's just cache.  the stuff that matters is under ~/.ghc
20:34:59 <geekosaur> and just removing stuff from there is not entirely safe (you'd need to rehash the package database)
20:35:13 <startling> darn
20:46:59 <zzo38> Do you know if   data LeftCoT m f x = forall z. LeftCo (f (m z) -> x) (f z);   is a comonad? Do you know if it is a comonad transformer?
20:47:57 <zzo38> Would anyone be able to answer anything like this?
20:50:14 <unnali> zzo38: suggest asking on StackOverflow? It'll get seen by more people over a long period of time :)
20:50:25 <zzo38> I don't want to
20:50:36 <unnali> then why poll here?
20:53:00 <startling> man, every haskell library for git sucks and/or is undocumented
20:54:04 <etpace_> good reason to start your own?
20:54:11 <etpace_> or patch another
20:58:00 <startling> etpace_, looks like it
21:06:22 <startling> hm, when I install http://hackage.haskell.org/packages/archive/filestore/0.4.0.4/doc/html/Data-FileStore.html I can't import Data.FileStore for the life of me
21:06:34 <startling> installed with cabal install filestore, by the way
21:06:39 <startling> any ideas?
21:07:56 <deadrabbit> is anyone using vim for haskell editing?
21:07:59 <unnali> yes.
21:08:21 <unnali> startling: what happens when you try?
21:08:23 <deadrabbit> does 'where' indent for you?
21:08:49 <deadrabbit> i can not get 'where' to indent from the rest of the code automatically
21:08:51 <unnali> startling: on further review of the doc you've linked, Data.FileStore has no exports. try importing a submodule.
21:09:04 <startling> unnali:  Could not find module `Data.FileStore'
21:09:09 <unnali> deadrabbit: guess it depends on how you want it to look, but I don't think I rely on auto-indenting so much, I just tab it how I want.
21:09:24 <unnali> startling: hm.
21:09:35 <deadrabbit> unnali: isnt that really tedious?
21:09:42 <unnali> deadrabbit: not overly ..
21:09:51 <unnali> startling: hold on, let me try myself.
21:10:14 <unnali> works for me.
21:10:32 <unnali> λ> :t gitFileStore
21:10:32 <unnali> gitFileStore :: FilePath -> FileStore
21:10:43 <unnali> how are you invoking ghc/ghci?
21:11:03 <AfC> deadrabbit: I used vim to hack .hs files for a while, but didn't use autoindent.
21:17:01 <walter_> isk
21:19:12 <deadrabbit> AfC: you just did the indentation manualy?
21:23:29 <startling> unnali: sorry, network died
21:23:39 <startling> unnali: I'm just doing "ghci" and then "import Data.FileStore"
21:25:20 <unnali> startling: hm, I can't understand why it would work for me and not you, then, assuming in intsalled without issue.
21:25:35 <startling> unnali: yeah, the install lob is clean. very odd
21:25:40 <startling> *log
21:25:57 <startling> unnali: thanks for your help, though
21:26:48 <unnali> np, sorry I couldn't work it out.
21:27:04 <startling> maybe upgrading to the newest ghc will magically fix it
21:28:37 <unnali> :D one can hope
21:31:10 <startling> unnali: out of curiousity, what are your ghc and cabal versions?
21:32:54 <unnali> startling: 7.4.1, 0.14.0
21:39:03 <startling> yep, holding out hope that upgrading will fix it. I don't have decent internet at the moment though, so no more haskell until tomorrow. :/
21:39:13 <unnali> hoh. :|
21:42:56 <nand`> deadrabbit: I use an auto-indent logic where the same indentation level would be preserved if I enter a new line. It's very handy, since this way I don't have to keep manually re-indenting but at the same time I can control when to indent/unindent without having to deal with some silly algorithm that thinks it knows better than me how to format my code :)
21:45:51 <AfC> deadrabbit: yes
21:46:16 <AfC> nand`: that makes good sense
21:51:23 <nand`> in my .vimrc, I have “set autoindent” and “set backspace=indent”
21:51:38 <nand`> which (should) give you the behavior I described
21:52:21 <nand`> (I should note that, in addition to this, I use “setlocal expandtab”, “setlocal shiftwidth=2” and “setlocal softtabstop=2” in my haskell.vim)
21:54:26 <zzo38> What kind of monad is (Codensity (Warbler (Kleisli IO)))?
21:55:12 <zzing> If I wanted to do web development with Haskell, what should I look at? There were a few things I recall coming out in the last few years.
21:55:33 <startling> zzing: happstack, snap, and yesod are the big things apparently
21:56:19 <startling> I can't offer any recommendations (haven't dived in yet) but those are the three on my list
21:59:43 <zzing> happstack sounds interesting
22:00:01 <zzing> Right now building ghc 7.4.1 on the server, it is a beast taking a long time :-)
22:06:44 <mzero> zzing: they all have their charms
22:07:18 <zzing> I notice happstack has a -lite that jumps in easily. It looks like a good place to start. It might be a good idea to do a basic thing in each
22:07:23 <mzero> yesod has a big book
22:07:56 <mzero> and an get going mode too --- yesod focuses pretty strong on supporting web sites more than web services
22:08:13 <mzero> insofar as it has special mini-languages for templated html / css / javascript
22:08:30 <zzing> interesting
22:09:00 <zzo38> Is there a library for servers with multiple clients such as online games with telnet?
22:09:05 <mzero> snap and happstack have their approachs to that too, though somewhat more modularly - as in if you are producing just a json web service (say), you might find it easier in snap
22:09:17 <zzing> I am thinking about doing something that would be similar to having documents in markdown that are filled into certain templates. That is pretty basic.
22:09:49 <mzero> I think that is covered as a sample in the Yesod book
22:10:12 <startling> zzing, i'd use yesod only because it has an embedded templating language
22:10:24 <startling> and none of the other templating languages for haskell seem to be any good
22:10:32 <zzing> How does an embedded templating language work?
22:10:43 <mzero> if the site is static - you could use Hakyll
22:11:03 <mzero> does exactly that - pile o' markdown -> web site with nice formatting control
22:11:31 <startling> zzing: dunno exactly. it's called "hamlet", fwiw
22:11:51 <zzing> I think I would like to add some kind of editing support
22:11:55 <mzero> zzing: look here: http://www.yesodweb.com/book/shakespearean-templates
22:12:35 <zzing> mzero, not bad at all
22:13:48 <zzing> If I wanted to provide some kind of editing support in the browser, but didn't want to deal with users and such, would it be reasonable to have a command on the server ssh that generates a key that you can paste into a webpage that would enable editing mode for a certain session with a timeout?
22:15:51 <nand`> It took me until now to realize that the letter ‘w’ often used in place of a Comonad is nearly an ‘m’ upside down
22:16:07 <startling> ha!
22:16:37 <otters> ohohohoho
22:23:15 <zzo38> zzing: Why wouldn't you make it just use the SSH directly to allow editing?
22:23:45 <zzing> I suppose that is a good question
22:23:55 <startling> zzing, or you could allow editing from localhost and tunnel through that
22:28:08 <startling> tunnel your browser through ssh, I mean
22:31:55 <zzing> startling, I didn't think that would work
22:32:19 <startling> zzing, I don't see why it wouldn't
22:33:23 <zzing> I might just not be imaging things well enough. It is late. I must bed. Thank you all.
22:57:30 <mzero> zzing: oddly enough - enabling authorized actions without users or accounts is exactly what my day job research is about
23:00:40 <startling> mzero, do you mean things like browserid, or weirder than that?
23:00:51 <mzero> weirder!!!!
23:01:24 <mzero> (actually, I think the system is by far simpler and easier to understand and code, but it is certainly uncommon which makes people think it is weird)
23:01:38 <mzero> https://sites.google.com/site/belayresearchproject/
23:01:40 <startling> mzero, got any interesting reads? :)
23:02:01 <mzero> project is open research, and open source
23:02:08 <startling> and yeah, i meant "weird" in the "uncommon" sense
23:02:12 <notdmwit> ?tell dmwit https://sites.google.com/site/belayresearchproject/
23:02:12 <lambdabot> Consider it noted.
23:02:23 <mzero> start at the blog: https://sites.google.com/site/belayresearchproject/team-blog
23:02:29 <mzero> and look at the short demo video and then the slides
23:03:03 <startling> mzero: will do, thanks!
23:03:13 <mzero> welcome - glad someone is interested!
23:03:52 <startling> mzero: it's hard not to be interested. passwords are terrible terrible things
23:05:21 <mzero> ah - well, check out the demo video: we create accounts for users, without user names or passwords!
23:06:16 <startling> mzero: hmm, isn't this essentially a long-lasting cookie?
23:07:37 <mzero> yes and no - a cookie is a token for full authority, ambiently sent with every request to a site
23:07:52 <mzero> so- it is both all powerful, and used indiscrimanently
23:08:44 <startling> mhm
23:08:59 <mzero> our "launch" BCAPs are all powerfull, but are only used when the user opens the page first
23:09:03 <startling> so you have an alternate channel for passing this thing
23:09:05 <mzero> from then on, they aren't around or sent
23:09:20 <startling> how do you associate users with requests?
23:10:12 <mzero> check out the poster here: https://sites.google.com/site/belayresearchproject/team-blog/newmaterialandaposter
23:10:24 <mzero> essentially, when you "get an account" at a site, it gives you a membership card
23:10:39 <mzero> you present that card on entry - but then tuck it back in your wallet as you navigate the site
23:10:53 <startling> mzero, okay, so what does that mean?
23:11:00 <startling> how does the server know that I continue to be me?
23:11:18 <mzero> during a session, or between sessions?
23:11:26 <startling> during a session
23:12:17 <mzero> ah - in exchange for seeing the memebrship card, the site produces the HTML page, and a small JSON bundle of further credentials - but limited (in time) and scope (function) credentials for things like "your account name" "your history" etc...
23:12:40 <mzero> these credentials are just URLs held in JavaScript (usually in closures) in the page - and so aren't ambeint powerful tokens, like cookies
23:13:23 <mzero> the javascript on then page, then uses only the credentials it needs, to get the info it needs.
23:14:18 <mzero> those credentials are never available to, say, other pages, or even other accounts on the same server!
23:14:29 <startling> two observations: a) so you need https? b) so urls are generated on-the-fly and you go to them?
23:14:40 <mzero> sounds complex, I suppose, but we've built frameworks for the server side that make it clean
23:15:36 <mzero> a) yes - though we are working on a stage two that doesn't need https all the time, b) URLs for AJAX are indeed generated as large crypto strings --- users's never see them and then never land in the URL bar (or therefore referer logs)
23:16:39 <startling> mzero: yep. very interesting
23:17:02 <startling> are those urls invalidated as soon as you use them, or do they exist for the whole session?
23:17:12 <mzero> up to each server
23:17:52 <startling> mzero: interesting. thanks for your time! I'm sure I'll have more questions once I'm finished reading about this
23:18:08 <mzero> you know where to find me
23:24:05 <hpaste> fragamus pasted “GOLF!!!” at http://hpaste.org/69688
23:25:29 <fragamus> ok I have golfed this function, but I want the opinion of some experienced persons to see if it can be improved
23:35:06 <mzero> fragamus: why the awkward type signature ([a],[a],[a]) -> ([a],[a],[a])????
23:36:00 <mzero> why not   ([a],([a],[a])) ->  ([a],([a],[a]))
23:36:53 <Yrogirg> hi! How do you call the language property of having forall in types? That is the fact that I can declare functions like f :: a -> Constructor a ?
23:37:26 <Yrogirg> what? where is my message? Just posted it and can't see it in the window.
23:37:48 <mzero> ?
23:37:50 <mzero> I see it
23:38:10 <mzero> are you looking for the term "polymorphic"
23:38:11 <mzero> ?
23:38:12 <Yrogirg> now see it too
23:38:14 <startling> Yrogirg: i see it also. get a better client and/or connection
23:39:01 <Ralith> Yrogirg: that's called parametric polymorphism.
23:40:15 <Yrogirg> Ralith, thanks
23:41:53 <hpaste> mzero annotated “GOLF!!!” with “GOLF!!! (annotation)” at http://hpaste.org/69688#a69690
23:42:04 <mzero> can't resist codegolf
23:42:50 <nand`> “The generated HTML uses stylesheets, so you need a fairly up-to-date browser to view it properly (Mozilla, Konqueror, Opera, and IE 6 should all be ok).” hehe
23:45:16 <startling> ha
23:50:59 <amatsu> Yo, #haskell, I'm working through LYAH at the moment,
23:51:10 <amatsu> just got up to Functors and Applicatives,
23:51:18 <hvr> amatsu: good for you
23:51:36 <amatsu> horribly confused at the moment, what's a real world use of these things?
23:51:50 <hvr> amatsu: applicative parsers
23:52:19 <hvr> amatsu: e.g. http://www.haskell.org/haskellwiki/Parsec
23:52:19 <nand`> amatsu: real world use of functors? <- basically everything
23:52:46 <startling> amatsu, lists are functors
23:53:06 <amatsu> what's an applicative functor then?
23:53:19 <nand`> (functors are components of many other higher level constructions such as monads, which themselves have many, many real world applications; for that matter)
23:53:36 <nand`> amatsu: lists are applicative functors too :P
23:53:51 <startling> amatsu, a functor is just a nice thing you can map (fmap) over
23:53:58 <ion> amatsu: They just provide a common interface for functionality you’d have for a bunch of types anyway. Without functors, everyone would just implement it with different APIs.
23:54:08 <startling> amatsu, lists are special because their fmap is also called "map"
23:54:57 <amatsu> These are generalisations from category theory, right?
23:55:05 <nand`> yeah
23:55:50 <amatsu> OK, makes more sense now, thanks for the help guys!
23:58:27 <Twisol> If I have a definition with type IO (), that means it's a monad action with a result of (), correct? But to actually evaluate, it needs a monadic value to act from?
23:58:49 <nand`> to actually evaluate you need to define ‘main’ as it
23:59:12 <Twisol> lets say Maybe () instead of IO () then
23:59:58 <nand`> then I don't quite understand your question
