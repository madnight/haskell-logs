00:01:32 <srhb> Aside from any * -> * type that uses the type parameter in a function argument, are there any other obvious nonfunctors?
00:02:00 <dmwit> srhb: type families
00:02:15 <srhb> Right.
00:02:29 <dmwit> GADTs (really just type families in disguise)
00:04:56 <serialhex> closer, but not quite: foo (\px -> fmap (\(y,py) -> (y+1,px*py) )  (d 2) ) (d 2)
00:05:26 <dmwit> fmap doesn't have access to the probabilities
00:05:28 <dmwit> only the values
00:05:37 <dmwit> (And I agree that it's closer.)
00:06:11 <dmwit> Also, that \px -> is possibly a misleading name...?
00:06:22 <dmwit> It's not the probability of x, it's the actual value x sampled from the d 2.
00:07:05 <serialhex> thats what i thought... but this: `foo (\x -> fmap (\y -> ("foo",x) )  (d 2) ) (d 2)` gives: `[("foo",1 % 2),("foo",1 % 2),("foo",1 % 1),("foo",1 % 1)]`
00:07:21 <serialhex> which i thought *really* bizzare!!!
00:08:16 <serialhex> ...or maybe i'm thinking wrong.......
00:08:21 <dmwit> That's because you're using fmap, not fmap'. ^_^
00:08:38 <dmwit> If you use fmap', it's a type error, like it oughta be.
00:08:45 <serialhex> :D  der!!! thanks!!!
00:11:57 <dean> do you people really program in haskell or are you a bunch of bots? :)
00:12:12 <srhb> Human detected. Abort.
00:12:24 <dean> hehe
00:12:37 <MostAwesomeDude> dean: Why not both?
00:12:44 * serialhex is learning to be a bot :P
00:13:01 <serialhex> foo (\x -> fmap' (\y -> x+y ) (d 2) ) (d 2)
00:13:06 <Eduard_Munteanu> I think some people in here self-identify as non-human.
00:13:16 <dmwit> serialhex: looks good!
00:13:22 <ahkurtz> if you can't beat em, leave em
00:13:26 <Eduard_Munteanu> @botsnack
00:13:27 <lambdabot> :)
00:13:35 <srhb> @faq Can Haskell disguise robots as humans?
00:13:35 <lambdabot> The answer is: Yes! Haskell can do that.
00:13:44 <serialhex> and i can extend that to `dn n = foo (\x -> fmap' (\y -> x+y ) (d n) ) (d n)` (i think....)
00:14:11 <serialhex> no....
00:14:21 <dmwit> Sure, why not?
00:14:52 <serialhex> just tried `dn 6` and it dosn't look right....
00:15:21 <serialhex> no, no....
00:15:28 <serialhex> ok, i'm sorry it is
00:15:39 <serialhex> yes!
00:15:41 <dmwit> Right!
00:15:50 <dmwit> And, maybe, now you see the need for a normalization phase...
00:16:05 <serialhex> 3:15am  and i'm still kind of awake!!!
00:16:06 <dmwit> norm :: Eq a => Density a -> Density a
00:16:25 <dmwit> It doesn't do anything except group together equal values and add up their probabilities, merging them into one entry in the list.
00:16:33 <serialhex> yes
00:16:35 <dmwit> (It can be much more efficient with an Ord constraint instead of an Eq constraint.)
00:16:37 <serialhex> okay
00:17:00 <ahkurtz> when people were mentioning type families before I went and looked and am super confused why you would want them. in an example you make a type that is either a list containing Char or a single integer. So if I write a program that calls head what happens? It's my duty to write functions for the instance for each possible type it might have been parameterized to?
00:17:34 <ahkurtz> but it claims it's useful because it allows overloading?
00:17:38 <serialhex> (now he wants me to write functions with funky constraint thingys....)
00:18:08 <MostAwesomeDude> serialhex: (Map could eventually be a useful type here, but has an Ord constraint.)
00:18:40 <dmwit> serialhex: Here's a hint:
00:18:41 <dmwit> :t sort
00:18:43 <lambdabot> forall a. (Ord a) => [a] -> [a]
00:18:45 <dmwit> ;-)
00:18:48 <serialhex> ahkurtz: you get the head of the list....  but if you need to add the head & the head+1 then of course it's going to need - in your example - an integer instead of a string
00:19:09 <dmwit> ahkurtz: type families are basically type-level functions
00:19:19 <dmwit> ahkurtz: You need them whenever you start doing type-level programming.
00:19:26 <serialhex> cause + only works on integers (and other number-like things)
00:19:57 <dmwit> I'm not sure I understood your question about head, though.
00:22:22 <ahkurtz> sorry, the context is that you might both [Char] and [()], but that because () isn't anything it suffices to just store the list len as an integer
00:22:43 <ahkurtz> and then they are both in the same type family.
00:24:02 <ahkurtz> I'll go try them out and leave you alone. Sorry.
00:25:17 <DexterLB> is there a way to see how many times a function is evaluated? for debugging purposes
00:26:28 <Axman6> look into the HPC stuff in GHC (Haskell Program Coverage)
00:26:36 <serialhex> :t sort
00:26:38 <lambdabot> forall a. (Ord a) => [a] -> [a]
00:37:31 <Eduard_Munteanu> DexterLB: Debug.Trace might also help, I'm unsure
00:40:26 <DexterLB> Eduard_Munteanu: thanks, that's perfect
00:47:58 <solrize> any idea how much it costs to compare an Integer to 0, when the number is big (1000's of digits)?  Is it O(n) in the number of digits?
00:49:23 <silver> blind guess: it's O(1)
00:49:39 <solrize> i would have expected so too
00:49:43 <dmwit> O(log n) would be my guess
00:49:49 <dmwit> oh
00:49:53 <dmwit> oh
00:50:49 <solrize> but O(n) would be one explanation of that speed anomaly i pasted further up
00:51:26 <solrize>  http://hpaste.org/70506  STArray2 is 2x slower than STArray
00:51:31 <dmwit> (Two "oh"s for: "n" is the number of digits, not the number, and O(1) actually makes a lot of sense with even a naive implementation of comparison.)
00:51:44 <solrize> it's possible i did something dumb with laziness or some such
00:54:15 <dmwit> Well, you can try let x = 2^100000000; x `seq` (); x == 0 in ghci
00:54:17 <dmwit> seems pretty fast
00:54:44 <dmwit> then again, x == x seems pretty fast, too.
00:54:54 <serialhex> okay, this is uglificated, but it's what i've got so far: https://gist.github.com/3008792 (way at the bottom)
00:55:31 <dmwit> serialhex: Looks good!
00:55:41 <serialhex> i'm trying to a) find a better way &&/|| b) find exhaustove patterns for it
00:55:56 <dmwit> There's lots of extra parentheses, and you renamed fst/snd, but otherwise it seems perfectly cromulent.
00:56:00 <serialhex> feh!! spelling iz fer sukkaz!!!
00:56:09 <dmwit> There's a better way, yes.
00:56:12 <dmwit> You might like
00:56:13 <dmwit> :t groupBy
00:56:15 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
00:56:23 <dmwit> As for completing the patterns, well, why not
00:56:28 <dmwit> merge anythingelse = anythingelse -- ?
00:56:43 <serialhex> -_-
00:58:57 <Ptival> is there a way to force the type class instance in a request to lambdabot?
00:59:03 <serialhex> ok cool!!!
00:59:07 <Ptival> I'd like is to spit the arrow instance when I do :t (.)
00:59:10 <Ptival> :t (.)
00:59:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:59:16 <Ptival> ^ not beginner-friendly
00:59:42 <serialhex> dmwit: https://gist.github.com/3008792  next!!! :D
00:59:51 <Taneb> What lambdabot does isn't strictly speaking Haskell.
01:00:08 <dmwit> serialhex: lol
01:00:12 <dmwit> serialhex: I meant this:
01:00:14 <dmwit> ?src fst
01:00:15 <lambdabot> fst (x,_) =  x
01:00:18 <dmwit> compare
01:00:21 <dmwit> n (a, pa) = a
01:00:29 <serialhex> oh, yeah
01:00:31 <serialhex> derr...
01:00:34 <dmwit> serialhex: Anyway. Next up: your actual problem!
01:00:42 <serialhex> oh sweet!!!!
01:00:53 <serialhex> and it's only 4am!!!! :D
01:01:02 <dmwit> You have everything you need now (except the "variance" computation, but that's easy, right??).
01:01:10 <serialhex> mostly.... ish
01:01:57 <serialhex> i probably also need an nDx function....  which would be a variation on the twoDn func
01:02:10 <dmwit> Oh, sure, that would be handy.
01:02:24 <dmwit> Yes, I even used it above and forgot I had.
01:02:32 <dmwit> Okay, so replicateM is your next job.
01:02:42 * serialhex rolls eyes
01:02:43 <dmwit> replicateM :: [Density a] -> Density [a]
01:03:19 <dmwit> um
01:03:20 <serialhex> okay
01:03:25 <dmwit> sequence :: [Density a] -> Density [a]
01:03:34 <dmwit> replicateM :: Int -> Density a -> Density [a]
01:03:49 <dmwit> replicateM n m = sequence (replicate n m) -- give you this one for free =)
01:04:02 <serialhex> heh heh, okay :)
01:05:39 <serialhex> so a list of densities... and i get this list from where?
01:06:02 * serialhex is trying to understand where it comes from so i know where it goes to
01:07:01 <dmwit> Hm... you get it from...
01:07:04 <dmwit> me =)
01:07:38 <serialhex> HAHAHAHAHAHA!!!! okay... i'm just trying to understand the motivation....
01:07:39 <dmwit> It's a bunch of different random distributions over the same type; say, a list of die rolls, all of different sided-ness.
01:07:51 <dmwit> like you might have [d 5, d 7, d 17] or something
01:07:57 <dmwit> and you want a list of just the samples
01:08:09 <dmwit> or rather, you want a distribution over the possible lists of samples
01:09:32 <dmwit> Or, in your case, maybe it's a list all of the same element, but of some unknown length, like one of
01:09:48 <serialhex> i'm not sure if i want it over *all* the samples... for instance:  i'm not sure i want to directly merge the P's of the 2d6 & 3d6 rolls...
01:09:49 <dmwit> [d 6, d 6, d 6] or [d 6, d 6] or [d 6, d 6, d 6, d 6, d 6, d 6, d 6]
01:10:08 <serialhex> ahh, okay, i see now
01:10:34 <serialhex> sorry, i was getting ahead of myself, we're doing the nDx thing right?
01:10:50 <dmwit> Well, we're doing a slightly abstracted version of it.
01:10:54 <serialhex> okay
01:11:14 <serialhex> my brain got sidetracked
01:11:40 <dmwit> No worries. This stuff is never easy the first time you see it. =)
01:12:11 <MostAwesomeDude> serialhex: I'd figure out an operation for combining two dice rolls.
01:12:31 <MostAwesomeDude> And then note that e.g. 3d6 == 1d6 + 2d6 over the same operation as 2d6 == 1d6 + 1d6.
01:12:38 <serialhex> yeah, and i'd like to know why we are doing some things... typing characters is easy, figuring out why *those* characters is hard...
01:12:42 <MostAwesomeDude> (Maybe that list comprehension I posted earlier? >:3 )
01:13:07 <serialhex> MostAwesomeDude: i have something like that for 2dN: twoDn n = foo (\x -> fmap' (\y -> x+y ) (d n) ) (d n)
01:13:13 <dmwit> MostAwesomeDude: Yes, using liftM2 (+) is another way to do that.
01:13:18 <dmwit> MostAwesomeDude: But it's a bit lower level.
01:13:33 <dmwit> liftM sum (replicateM n (d 6)) is much better. =)
01:13:44 <dmwit> sorry, fmap' sum (...)
01:13:45 <MostAwesomeDude> dmwit: Yeah, that'd be a thing as well.
01:14:49 <serialhex> okay, so sequence does what exactly?  it takes a list of densities and makes one big density like my twoDn func?
01:15:15 <dmwit> Yes, it takes a list of densities, samples from each in turn, and returns a density over the list of samples.
01:15:56 <serialhex> so `(sequence [ d 6, d 6]) == twoDn (d 6)` ???
01:16:11 <serialhex> okay
01:16:21 <dmwit> No, not quite.
01:16:41 <dmwit> sequence returns both the samples; twoDn only returns their sum.
01:17:06 <dmwit> It's more like fmap' (\[x,y] -> x+y) (sequence [d 6, d 6]) == twoDn 6
01:19:31 <solrize> hmm in the c++ version of the program there's no speed difference between the maybe and sentinel functions
01:19:40 <solrize> is dons ever around any more?
01:20:34 <serialhex> so `sequence [ d 2, d 2]` should give...
01:23:15 <dmwit> [([1,1],1 % 4),([1,2],1 % 4),([2,1],1 % 4),([2,2],1 % 4)]
01:23:49 <serialhex> okay, excellent!
01:24:01 <dmwit> (or some permutation of this would be fine, too)
01:24:12 <serialhex> yeah, i understand :D
01:31:32 <solrize> man g++ error diagnostics are really not very good.  are other c++ compilers better?
01:32:50 <Dtgr> how come
01:32:53 * hackagebot semigroupoids 1.3.3 - Haskell 98 semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-1.3.3 (EdwardKmett)
01:33:18 <t7> solrize: thats the whole reason for clang
01:33:25 <t7> (and modularity)
01:33:32 <MostAwesomeDude> t7: (And licensing.)
01:38:15 <Ralith> (and llvm)
01:38:29 <Ralith> (yes, llvm counts as a discrete reason)
01:41:42 <serialhex> dmwit: you going to be on later today?  i dont know what timezone you are in....
01:41:53 <Cheery> Peaker: https://github.com/cheery/essence/issues/milestones?with_issues=no
01:45:01 <serialhex> ...or tomorrow, however the time is where you are
01:48:28 <serialhex> dmwit: i'm headed to bed... i'll catch up with you later here is what i have so far: https://gist.github.com/3008792 feel free to msg me!  g'nite and thanks!!!
01:57:53 * hackagebot egison 1.2.3 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-1.2.3 (SatoshiEgi)
02:25:20 <Catnaroek> Hello. I have the following definition: make cons = do { a <- gets cons ; modify succ ; return a }. Is there any way to make this definition look less clumsy?
02:25:39 <mellum> is there a better way to test in constant time whether an IntMap has at most one element than IntMap.null g || IntMap.null (IntMap.deleteMax g)
02:37:18 <fmap> Catnaroek: maybe `state (\s -> (s, succ s))'?
02:38:10 <fmap> iirc `modify' is `state (\s -> ((), f s))'
02:38:15 <Catnaroek> Yes.
02:38:44 <Catnaroek> Well, thanks!
02:44:25 <Catnaroek> @pl f g = sequence_ $ liftM2 g
02:44:25 <lambdabot> f = sequence_ . liftM2
02:44:33 <Catnaroek> Oh, durr.
02:44:57 <Catnaroek> @pl f g x y = sequence_ $ liftM2 g x y
02:44:58 <lambdabot> f = ((sequence_ .) .) . liftM2
02:47:06 <DexterLB> I'm doing a simple web app, and I can't decide between using templates and generating the HTML with Text.XHTML or similar
02:47:16 <DexterLB> what are the pros and cons of the two methods?
02:49:55 <fmap> mellum: isn't `take 2 . elems' constant time due to laziness?
02:50:19 <shachaf> fmap: whoa, dude
02:52:33 <mellum> fmap: I don't know, I'm a beginner
02:52:59 <Taneb> :t elems
02:53:00 <lambdabot> forall i e. (Ix i) => Array i e -> [e]
02:53:50 <mellum> fmap: also, how can I use this for just checking if there's more than 1 element?
02:54:59 <Taneb> :t rangeSize . bounds
02:55:00 <lambdabot> forall a e. (Ix a) => Array a e -> Int
02:55:14 <Taneb> :t (> 1) . rangeSize . bounds
02:55:15 <lambdabot> forall a e. (Ix a) => Array a e -> Bool
02:56:15 <Taneb> :)
02:56:16 <totimkopf> is it difficult to write pretty haskell code with predictable memory usage?
02:56:32 <Taneb> If you want pretty code, use Piet.
02:56:37 <Taneb> (that's a joke, btw)
02:56:42 <totimkopf> :o
02:57:21 <savask> Hello. How do I match any type of exception with new exceptions (use of Control.OldException is deprecated)?
02:58:24 <fmap> shachaf: should i interpret this as "No"?
02:58:40 <fmap> anyway that was a pure guess
02:59:11 <shachaf> fmap: No, don't interpret it at all. Forget I said it.
03:00:11 <fmap> mellum: well, if it's constant time you can use pattern matching to check if there's more than 1 element in intmap
03:00:41 <mellum> fmap: I see
03:00:52 <fmap> `case (take 2 $ elems intmap) of [x] -> {- good -}; _ -> {- bad -}'
03:01:07 <mellum> fmap: I suppose the compiler is not smart enough to optimize something like "length list >= 2" to a pattern matching?
03:01:46 <fmap> no
03:02:01 <shachaf> mellum: genericLength with Nat would do it.
03:02:08 <shachaf> ("but...")
03:03:13 <mellum> shachaf: "but" meaning it's not a good idea to rely on it?
03:04:24 <twanvl> savask: catch SomeException
03:04:58 <savask> twanvl: So that will match IO, error, /0 and so on?
03:05:11 <twanvl> that matches everything
03:05:16 <savask> Thanks.
03:07:34 <MostAwesomeDude> Hey, out of curiosity, is there a prettier Show instance available?
03:07:57 <hiptobecubic> for?
03:09:47 <MostAwesomeDude> Like, the builtin Show instance works fine for debugging, but it'd be nice if it were a pretty-printer.
03:16:58 <DexterLB> are there any tutorials/docs on HaXML?
03:42:50 <mrky> hello. how can I swap argument places in this partial function?  (^2)
03:43:58 <sipa> (2^) ?
03:43:59 <ehamberg> what do you mean? you want (2^)?
03:44:04 <sipa> flip (^2)
03:44:38 <mrky> i could swear i tried (2^) earlier
03:44:45 <ehamberg> :-)
03:46:43 <sipa> > (2^) 5
03:46:45 <lambdabot>   32
03:46:49 <sipa> > (^2) 5
03:46:51 <lambdabot>   25
03:46:54 <fmap> mrky: note that (^2) is `partial application' not a `partial function'
03:47:04 <sipa> > (flip (^2)) 5
03:47:05 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> b) -> b)
03:47:06 <lambdabot>    arising from a u...
03:47:14 <sipa> :t flip
03:47:15 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
03:47:42 <however> > (flip (^)) 2 5 -- sipa
03:47:44 <lambdabot>   25
03:48:26 <however> but yes, that ":t flip" output is somewhat baffling
03:48:43 <Catnaroek> sipa: When a function has been partially applied, you cannot already change what argument has been applied.
03:49:23 <twanvl> however: lambdabot usees generalized versions of some functions such as (.) and flip
03:49:24 <Catnaroek> sipa: If you already applied the second argument of (^), you cannot say "Oh, sorry, I meant to apply the first argument instead".
03:50:11 <sipa> Catnaroek: right, i'm not yet awake it seems :)
04:06:43 <kallisti> maybe I don't actually understand how throwTo works...
04:07:01 <kallisti> it seems that whenever I attempt to use throwTo none of my exception handlers are triggered in the target thread.
04:30:09 <EnglishGent> hello
04:30:28 <Taneb> Hey
04:31:17 <EnglishGent> hi Taneb :)
04:38:07 * hackagebot paragon 0.1.20 - Paragon  http://hackage.haskell.org/package/paragon-0.1.20 (NiklasBroberg)
04:46:26 <b52> what is MVar ß
04:48:01 <fmap> b52: any context?
04:48:03 <twanvl_> b52: it is a type. β is just a type variable, you could replace it by b if you prefer
04:48:22 <b52> ß was a mistyped ? ;)
04:48:27 <b52> german keyboard
04:48:33 <twanvl_> ah
04:48:35 <however> b52: check this out http://www.haskell.org/ghc/docs/7.4.1/html/libraries/base/Control-Concurrent-MVar.html
04:48:54 <hpc> MVar is a threadsafe mutable variable that can be empty
04:49:21 <hpc> it is important to note that (MVar a) /= IORef (Maybe a)
04:51:29 <fmap> b52: you can use unicode symbols as type variables (some guys like greek letters for example)
04:53:03 <however> b52, one thread puts something in (if it's full it blocks until empty), another thread can take something (blocking until something is available). it's slightly like a Maybe, it can be empty or contain one thing. pretty simple really. in other languages it might be called a channel or a queue of length 1
04:53:38 <twanvl_> fmap: 'ß' ≠ 'β', the former is a ligature for "sz" or a typo for '?', the latter is a greek 'b'
04:53:53 <tdammers> yeah, kind of an atomic 1-element queue
04:54:06 <b52> what about a blocking put . modify . take ?
04:55:17 <tdammers> as long as all your puts are preceded by a take from the same thread, you should be fine
04:55:34 <b52> how come?
04:55:57 <twanvl_> there is also a modifyMVar function for this purpose
04:55:59 <b52> ah my bad
04:56:01 <tdammers> if all your threads adhere to put . modify . take, then any thread can only start processing once the mvar is full
04:56:13 <fenris_kcf> is it possible to create an algebraic data-type with a concrete value (instead of a type) as parameter?
04:56:15 <b52> tdammers: yeah it just made clockl
04:56:16 <b52> click
04:56:17 <tdammers> which is only the case while no other thread is processing
04:56:22 <tdammers> mkay
04:56:35 <mrky> how can i find position of some element in a list?
04:56:48 <fmap> twanvl_: well, it still can be a type variable (and no context was provided)
04:57:19 <tdammers> mrky: !!
04:57:28 <b52> mrky: elemIndex
04:57:41 <fenris_kcf> for example if i want to create a type for the finite field F_p (where p is prime)
04:57:41 <b52> http://www.haskell.org/hoogle/?hoogle=a+-%3E+[a]+-%3E+Int
04:57:46 <tdammers> forget what I said
04:58:01 <tdammers> I read your question as "get an element by index"
04:59:14 <unnali> @hoogle a -> [a] -> Int
04:59:15 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
04:59:15 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
04:59:15 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
04:59:49 <mrky> thanks
05:00:26 <b52> youre welcome
05:03:32 <xplat> > let fibs = 0:1:(zipWith (+) `ap` tail) fibs in elemIndex 89 fibs
05:03:33 <lambdabot>   Just 11
05:04:06 <fenris_kcf> sry, i-net-connection broke up ...
05:04:10 <xplat> > let fibs = 0:1:(zipWith (+) `ap` tail) fibs in take 12 fibs
05:04:12 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89]
05:05:20 <twanvl> > let o :: (о -> ο -> o) -> (ο -> о -> o); o o о ο = o ο о in o map [0] succ  -- o_O
05:05:22 <lambdabot>   [1]
05:06:11 <opqdonut> :o
05:06:14 <however> twanvl: um, thanks for the clarification :)
05:06:23 <opqdonut> are those different o's?
05:06:46 <jaxtr> ahh it's a wonderful day
05:06:54 <xplat> yes, they are
05:07:32 <_oggy> fenris_kcf: i think the phrase you're looking for is "dependent types". in general, no, you can't have them in haskell, but see the wiki
05:09:11 <opqdonut> ah latin, cyrillic, greek
05:09:41 <xplat> technically the greek one is an omicron
05:10:03 <LaughingMan> in the type xxx:Type what is xxx?
05:10:39 <xplat> LaughingMan: dunno, what language is that in?
05:13:09 <LaughingMan> haskell
05:13:24 <LaughingMan> SimTrOS-0.6:SimTrOS.Simulator.Computation.Time.Time
05:13:46 <LaughingMan> why is there the version of the library in front?
05:14:33 <xplat> @hackage SimTrOS
05:14:33 <lambdabot> http://hackage.haskell.org/package/SimTrOS
05:15:15 <xplat> ... does not seem to exist
05:15:31 <LaughingMan> not in hackage, but locally here
05:15:55 <kallisti> LaughingMan: to indicate the version of the library.
05:15:56 <kallisti> >_>
05:16:07 <LaughingMan> but it normally does not do that
05:16:27 <kallisti> perhaps you have multiple versions installed.
05:16:32 <kallisti> I don't know when GHC decides to do that.
05:18:14 * hackagebot paragon 0.1.21 - Paragon  http://hackage.haskell.org/package/paragon-0.1.21 (NiklasBroberg)
05:19:46 <xplat> the clarity of paragon's package description leaves something to be desired
05:20:42 <kallisti> not to mention its documentation
05:21:56 <mellum> in Ocaml there's a shortcut for "\x -> case x of ...", is there something like that in Haskell?
05:22:13 <xplat> yeah, i had a brief hopeful thought that it could be because it was new and hackage didnt build the docs yet, but it turns out earlier versions don't have any either
05:22:14 <kallisti> unfortunately no.
05:23:23 <xplat> mellum: there are language proposals for it, but they have not yet been included in mainline GHC (or even any of the less popular compilers) nor been accepted for future standard inclusion
05:23:54 <kallisti> mellum: I think including "case lambdas" into Haskell syntax would fix several inconveniences with less general proposed fixes.
05:24:21 <kallisti> things like "if<-" and "case<-"
05:24:50 <xplat> kallisti: what the heck are those?
05:25:08 <kallisti> syntax sugar for a bind and an if statement, and a bind and a case expression
05:25:11 <kallisti> in do notation
05:25:48 <kallisti> as a workaround for a lack of a convenient way to do conditionals in monadic code, I use this:
05:25:52 <kallisti> @hackage cond
05:25:53 <lambdabot> http://hackage.haskell.org/package/cond
05:27:01 <kallisti> which lets you write things like:  ifM (pred1 <||> pred2) action1 action2
05:27:57 <xplat> where the conditions short-circuit on the monadic level
05:28:05 <kallisti> yes
05:28:09 <kallisti> unlike liftM (||)
05:29:25 <kallisti> though I'm likely the only person using this library, since I wrote it. :P
05:29:40 <opqdonut> :)
05:29:51 <Eduard_Munteanu> At least you're eating your own dog food :P
05:30:11 <xplat> a lot of it does look handy, although it's not obvious when some of it would be used
05:30:32 <aristid> kallisti: heh, i wrote something similar: http://hackage.haskell.org/packages/archive/shortcircuit/0.1/doc/html/Control-Shortcircuit.html
05:30:43 <aristid> kallisti: except i stopped using it :/
05:31:14 <xplat> ... although the individual function docs seem to do a decent job of explaining it
05:31:19 <fabrydrunk> hi guys. Is someone of you joined in #xmonad channel? I asked a question but that channel seems to be empty..
05:31:19 <xplat> wow
05:31:59 <kallisti> xplat: documentation and examples are always helpful.
05:32:31 <kallisti> aristid: yeah there's a lot of these kinds of libraries out there.
05:32:35 <LaughingMan> changing the version number fixed it, weird
05:33:21 <aristid> kallisti: stuff like that needs to be in the base to be used
05:34:50 <xplat> also: lol condM, because i'm 12
05:35:39 <aristid> xplat: ??
05:36:09 <hpaste> haskell_newbie pasted “Confusion regarding Class ” at http://hpaste.org/70569
05:36:22 <kallisti> heh.
05:36:34 <kallisti> xplat: so far I've only really used ifM and the lifted boolean operators
05:36:39 <haskell_newbie> I am bit confused with this class definition
05:36:45 <haskell_newbie> http://hpaste.org/70569
05:36:52 <kallisti> much of the other junk just lets you write code with a different syntax.
05:37:45 <Saizan> haskell_newbie: you want the (Measure a) type to be a monoid, not the type baing measured
05:37:49 <Saizan> *being
05:38:00 <xplat> aristid: conditional includes a function called 'condM', which sounds like 'condom', which amused me because i can still be amused by things that amuse a 12-year-old, causing me to non-literally claim that age by way of preemptive notpology
05:38:45 <aristid> xplat: oO
05:39:11 <xplat> *cond includes
05:39:20 <aristid> xplat: i would've pegged you more around 30 or so ;)
05:39:52 <haskell_newbie> Saizan: So what ever the type of Measure a , it should be member of Monoid class ?
05:40:14 <however> "preemptive notpology" is an excellent name for either a band or a hackage package
05:40:26 <aristid> however: well it's a bit long for a hackage package
05:40:33 <aristid> maybe just notpology? :)
05:41:11 <kallisti> aristid: so it looks like you just define ShortCircuit for each monad/whatever in question?
05:41:29 <aristid> kallisti: no, look at the bottom, there are _M versions
05:41:35 <haskell_newbie> Saizan: Is this related to type family (  To avoid functional dependency  ) ?
05:41:38 <aristid> no ifM though, because i didn't need that :D
05:41:51 <Saizan> haskell_newbie: (Measure a) is a type, and itself has to be an instance of Monoid
05:42:05 <aristid> kallisti: i ended up removing the dependency because not using it meant just 5 more lines or code :D
05:42:09 <Saizan> haskell_newbie: Measure is a type family
05:42:35 <kallisti> ha. our (??) even does the same thing.
05:43:24 <kallisti> firstTrueOf could probably be called or
05:43:26 <kallisti> :t or
05:43:27 <lambdabot> [Bool] -> Bool
05:44:31 <kallisti> ah nevermind
05:44:33 <haskell_newbie> Saizan: ( Measure a ) is concrete type and by writing Monoid ( Measure a )  , we are putting monoid constraint.
05:44:45 <haskell_newbie> Saizan: Thank you
05:44:45 <kallisti> it's different because of the HasFalse and HasTrue constraints
05:44:46 <aristid> kallisti: i guess it could
05:45:40 <aristid> kallisti: no it's not really, the concept is the same
05:45:41 * kallisti didn't consider having a seperate typeclass for true and false.
05:45:50 <kallisti> where Maybe is part of HasFalse
05:45:55 <aristid> yea
05:46:15 <aristid> that arised because i wanted to add ALL THE TYPES to my typeclasses
05:46:21 <aristid> *arose
05:46:35 <Saizan> haskell_newbie: np
05:48:50 <kallisti> aristid: you could also have lists be HasFalse, but then you're creeping into PHP-land
05:49:04 <deech> Hi all, does anyone know of any recent work on automated refactoring and renaming in Haskell source. Hare (http://www.cs.kent.ac.uk/projects/refactor-fp/hare.html) seems to only support Haskell98
05:49:05 <kallisti> like the "Truthy" type I wanted to create via cond.
05:49:46 <aristid> kallisti: and || on [] is ++?
05:50:19 <aristid> kallisti: somehow i'm not sure if that "belongs" in there
05:50:31 <kallisti> in your code? it would be join if'
05:50:52 <Peaker> Can anyone think of a way to build a memoizer-of-last-IO-result:  Eq a => (a -> IO b) -> IO (a -> IO b)      from a simple IO action memoizer:  IO a -> IO (IO a)  ?
05:51:16 <Peaker> or rather, what are the best IO memo combinators to write to be compose-able/generalizable to all these cases?
05:52:57 <aristid> kallisti: yes, but does that really make sense for lists?
05:54:31 <kallisti> aristid: no. I was talking about HasFalse specifically.
05:54:48 <kallisti> it does however
05:54:51 <kallisti> make sense with a list newtype
05:54:57 <kallisti> with boolean semantics.
05:55:09 <aristid> how would that look?
05:56:14 <kallisti> newtype TruthyList a = TruthyList [a]; instance ShortCircuit (TruthyList a) where isTrue [] = False; isTrue _ = True
05:56:26 <kallisti> s/ShortCircuit/ToBool/ for cond.
05:57:35 <kallisti> it makes more sense in cond though, because ToBool isn't tied to boolean operators
05:57:38 <kallisti> just conditionals
05:57:50 <kallisti> I wouldn't make an instance of Boolean for TruthyList, which is the cond boolean algebra class.
05:58:41 <Taneb> class Consable c where cons :: a -> c a -> c a; instance Consable [] where cons = (:); instance Applicative f => Consable (Cofree f) where cons a b = a :< pure b
06:00:28 <kallisti> the problem would be that you can't really define not for TruthyLists
06:00:36 <kallisti> you could make "reasonable" definitions for || and &&
06:00:41 <Taneb> Is there anything like that anywhere?
06:01:50 <Taneb> Seq has two instances
06:02:11 <kallisti> Taneb: MonadLogic implements cons-like operators
06:02:23 <kallisti> http://hackage.haskell.org/packages/archive/logict/0.5.0.1/doc/html/Control-Monad-Logic-Class.html
06:02:32 <kallisti> reflect is like cons
06:02:43 <kallisti> sort of...
06:02:56 <Taneb> Not quite what I'm thinking of; that requires MonadPlus
06:03:10 <Taneb> There's a really easy way to do it for any Alternative:
06:03:17 <Taneb> cons a b = pure a <|> b
06:05:05 <kallisti> hmm, if I split Boolean up and include a Heyting class, I could probably have a newtype wrapper that adapts MonadLogic instances to my typeclasses.
06:05:24 <Taneb> WrappedMonad
06:06:03 <kallisti> no, it would be better to use my own newtype.
06:06:47 <kallisti> because I'd want it to be an instance of MonadLogic
06:06:56 <kallisti> which would require an orphan instance for WrappedMonad.
06:07:50 <Taneb> Hmm, yeah
06:08:07 <Taneb> I'd like it if WrappedMonad was the standard Newtype for WrappedMonad
06:08:25 <Taneb> s/r WrappedMonad/r wrapped monads/
06:10:45 <aristid> Taneb: it isn't?
06:11:00 <Taneb> By standard I really mean only
06:14:02 <kallisti> I wish typeclass instances weren't incomplete and tedious feeling.
06:15:59 <illissius> what do you mean by that?
06:17:17 <kallisti> I mean that there is no coherent way to define instances based on existing instances, without overlappinginstances, newtype wrappers, or a superclass constraint.
06:18:30 <hpaste> d-snp pasted “Recursive do loop” at http://hpaste.org/70574
06:18:32 <illissius> right, that's annoying.
06:18:46 <kallisti> want to define your own monad typeclass? have fun writing instances for every type in mtl/transformers.
06:19:03 <d-snp> hey, anyone know why this recursive do crashes with the error streamio_2.hs: <<loop>>?
06:19:28 <d-snp> it crashes as soon as I enter a line and press enter
06:19:35 <d-snp> (without echoing the line)
06:22:39 <kallisti> not to mention any /other/ monad library out there. if you don't accomodate every existing typeclass, you've now made your library incompatible with them unless the user defines orphan instances.
06:23:02 <illissius> kallisti: I wonder to what extent DefaultSignatures could be used to alleviate that... i.e. give a default definition for when you have MonadTrans. and then you would only have to write instance MonadWhatever (FooT m), but not the methods.
06:23:38 <kallisti> it would remove the tedium, but the fundamental compatibility issue is still there.
06:24:23 <kallisti> in my own library code, I use CPP to define instances for monad transformers.
06:24:32 <Dtgr> d-snp: i think it detects infinite loop and jumps out of it to inform you
06:25:39 <Dtgr> don't ask how it is able to do so. that's just an explanation to that question that i've seen before
06:26:54 <illissius> kallisti, do you have any ideas about how to solve it?
06:27:38 <d-snp> I've found some stupidities in my code I'll fix them first
06:29:32 <illissius> the idea I've had for a while is that it should be possible for packages to have "optional dependencies" and "optional parts", i.o.w. some parts of your package depend on another package, and they're available if and only if the other package is also available (installed), but don't prevent the rest of the package from being used if it's not
06:30:11 <kallisti> illissius: I would like to see this code as viable:  instance Monad m => Class m where ...
06:30:15 <kallisti> but I'm unsure how to make it so.
06:30:54 <kallisti>  I feel you would need some way to annotate instances, in the same way that you can annotate types with ::
06:31:19 <kallisti> so that if the choice of instance became ambiguous, you would be required to annotate in some way.
06:31:28 <kallisti> but otherwise it would work implicitly.
06:31:28 <illissius> but the logistics of that are a bit hard, because it's not enough to do it on the module level, because then you would still need to have orphan instances in the optional modules. but once you have optional parts *within* modules you probably need GHC support for that. and you would have to rebuild them whenever the optional dependency is installed/removed...
06:32:08 <illissius> kallisti: I saw a paper about extending Haskell with named instances once, but I haven't read it yet. I don't know if that would help..
06:32:16 <kallisti> well, the fix for orphan instances is to allow them to be hidden/explicitly exports/explicitly imported   in the module syntax.
06:32:35 <kallisti> open-world principle be damned.
06:36:35 <kallisti> illissius: I feel like naming would become problematic
06:36:48 <kallisti> there's not really a convenient shorthand for most instances that would make sense.
06:38:03 <kallisti> also I feel that instances should, in export lists, be implicitly exported, and explicitly hidden
06:38:14 <kallisti> whereas other names are explicitly exported, and implicitly hidden.
06:39:07 <Peaker> hiding instances could cause a world of pain
06:39:21 <Peaker> I think one of the primary benefits of instances is their globality -- giving guarantees
06:39:28 <aristid> kallisti: sometimes closed world classes would be nice :D
06:43:49 <kallisti> one way to go about it would be to have orphan instances treated specially.
06:44:05 <nand`> byorgey: the other day I asked about whether I can give Either String a separate Monad instance separate from the other Either e instance; turns out I can with -XOverlappingInstances, which picks the Either String instance for cases in which it's applicable, and Either e otherwise
06:44:43 <kallisti> so orphan instances can't be created with an "orphan" keyword, and the orphan keyword can't be used with non-orphan instances. Similarly, instance hiding can only be used with orphan instances, and non-orphan instances must be open.
06:44:49 <kallisti> that's... odd, though.
06:58:37 * hackagebot shelly 0.12.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.12.1 (GregWeber)
07:03:37 * hackagebot cpsa 2.2.10 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-2.2.10 (JohnRamsdell)
07:04:12 <mellum> can I get a stack trace on an uncaught error with ghc?
07:05:30 <EvanR> not really
07:05:42 <mellum> how do people debug this, then?
07:06:00 <EvanR> what kind of error
07:06:09 <mellum> IntMap.find: key 0 is not an element of the map
07:06:19 <mellum> and I am not sure which map, where
07:06:28 <nand`> you can use trace
07:06:29 <ciaranm> replace all finds with lookups
07:06:39 <nand`> or that
07:06:49 <nand`> usually the best answer is “by avoiding error in the first place”
07:06:51 <mellum> I don't actually call find
07:06:53 <EvanR> thats why you should use Maybe instead of exceptions to handle stuff
07:07:02 <EvanR> in IntMap
07:07:13 <ciaranm> the prelude is full of terrible examples of not doing that
07:07:21 <EvanR> yeah
07:07:31 <ciaranm> "head" is retarded
07:07:39 <gienah> there's safe on hackage for those
07:08:14 <EvanR> fromJust ;)
07:08:37 <EvanR> safeFromJust :: Maybe a -> Maybe a ;)
07:08:45 <Onnedwarf> lol
07:09:56 <Peaker> hehe
07:20:56 <EvanR> so IntMap operations like O(min(n,W)) are constant time when theres more than 32 or 64 elements/
07:21:10 * ski . o O ( `betterSafeThanSorryFromJust  Nothing  = Nothing; betterSafeThanSorryFromJust (Just _ ) = Nothing' )
07:21:22 <Peaker> heh
07:21:31 <HugoDaniel> :D
07:21:37 <Peaker> const Nothing is a useful function, I use it all the time :)
07:21:46 <ciaranm> not the same!
07:22:12 <Peaker> const $! Nothing is less useful :)
07:22:18 <ciaranm> also, "const Nothing" is spelled "mzero"
07:22:59 <Peaker> ciaranm, I prefer using monomorphic functions when they exist and match the types.. until my IDE shows the types of the polymorphic ones usefully
07:23:08 <ciaranm> heretic
07:23:34 <Peaker> (const Nothing $!) is what I meant above..
07:24:05 <Peaker> ($!) is so much more convenient than "seq"
07:24:09 <ski> .. next thing you'll say you prefer `map' to `fmap' when applicable, and endorse the H98 split there
07:24:27 * ski hickups
07:24:42 <EvanR> > fmap sqrt [1,2,3]
07:24:43 <lambdabot>   [1.0,1.4142135623730951,1.7320508075688772]
07:25:07 <ciaranm> i hear some of those filthy nonbelievers even think (.) should just be function composition
07:25:22 <S11001001> you mean a multiplication of all the ways you could fulfill typeclass constraints, Peaker?
07:25:56 <HugoDaniel> Peaker: what ide are you using ?
07:26:17 <EvanR> > [sqrt] <*>[1,2,3]
07:26:18 <lambdabot>   [1.0,1.4142135623730951,1.7320508075688772]
07:26:36 <EvanR> > [sqrt, (**2)] <*>[1,2,3]
07:26:36 <Peaker> S11001001, not sure what you mean
07:26:37 <lambdabot>   [1.0,1.4142135623730951,1.7320508075688772,1.0,4.0,9.0]
07:26:44 <Peaker> HugoDaniel, emacs, until my own one becomes usable :)
07:26:46 <ciaranm> > sqrt . [1, 2, 3]
07:26:48 <lambdabot>  Terminated
07:26:53 <parcs`> EvanR: yeah but log n is better unless you have 2^64 elements ;)
07:27:17 <EvanR> log n is better than 64?
07:27:24 <S11001001> :t traverse
07:27:25 <lambdabot> Not in scope: `traverse'
07:27:26 <EvanR> is this a very large value of 64 or something
07:27:40 <Peaker> HugoDaniel, in the IDE I'm working on, lots of type information is available adjacent to the values (in a smaller font, and slightly greyed out), as you edit. But it's very preliminary
07:27:44 <S11001001> :t Data.Traversable.traverse
07:27:45 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
07:27:53 <ciaranm> hey, i have code where 3^(n/3) is better than n^2
07:28:01 <S11001001> okay, here are your options for t: ... and here are your options for f: ...
07:28:04 <HugoDaniel> :)
07:28:16 <S11001001> or multiply them and show the concrete sig of traverse that results from each combination
07:29:01 * ski . o O ( "'Are you a believer or an unbeliever?" <http://www.projectaon.org/en/xhtml/lw/06tkot/sect151.htm> )
07:29:45 <ciaranm> i still want to know why sqrt . [1, 2, 3] makes the bot barf
07:30:07 <EvanR> > [1,2,3] >>= \x -> [x]
07:30:08 <lambdabot>   [1,2,3]
07:30:25 <ski> > sqrt . [1,2,3]
07:30:25 <twanvl> ?type sqrt . [1,2,3]
07:30:27 <lambdabot> forall a. (Floating a) => [a]
07:30:28 <lambdabot>   [1.0,1.4142135623730951,1.7320508075688772]
07:30:32 <EvanR> is there a combinator for \x -> [x]
07:30:39 <ciaranm> pure
07:30:39 <ski> @type (: [])
07:30:41 <lambdabot> forall a. a -> [a]
07:30:48 <EvanR> ah
07:30:49 <ski> and `return'
07:31:14 <EvanR> > [1,2,3] >>= (:[])
07:31:14 <nand`> and ‘point’ :P
07:31:15 <lambdabot>   [1,2,3]
07:31:22 <EvanR> the number cruncher operator
07:31:31 <nand`> but return is the one I'd use if I haven't imported Applicative already
07:31:42 <EvanR> heh, point?
07:31:46 <EvanR> :t point
07:31:48 <lambdabot> Not in scope: `point'
07:31:52 <nand`> EvanR: Control.Pointed iirc
07:31:59 <ciaranm> it doesn't call it "pure"?
07:32:01 <nand`> EvanR: basically Applicative without <*>
07:32:04 <EvanR> > pure 5
07:32:06 <lambdabot>   No instance for (GHC.Show.Show (f t))
07:32:06 <lambdabot>    arising from a use of `M3421527090...
07:32:13 <EvanR> > pure 5 :: [Int]
07:32:15 <lambdabot>   [5]
07:32:20 <ski> (.. or `Monad' without `(>>=)')
07:33:55 <EvanR> is applicative somehow related to functor
07:33:55 <applicative> do the binary or partly binary packages for 'unknown linux' on the ghc website  work fairly easily? I mean, could someone make a local install of ghc-7.4 without to much trouble on a somewhat old ubuntu
07:34:02 <EvanR> like with laws or
07:34:11 * applicative is a functor
07:34:12 <ciaranm> an applicative is a functor with certain extra special magic
07:34:23 * applicative has extra special magic
07:34:47 <ciaranm> but really applicative is just monad's retarded stepchild
07:34:48 <opqdonut> an applicative functor is kinda half way between a functor and a monad
07:34:56 <applicative> or do people with out of date ghc's in their package managers build ghc from source?
07:34:56 <ski> @type liftA
07:34:58 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
07:35:14 <EvanR> ah liftA is fmap for applicative?
07:35:19 <ski> yes
07:35:33 <EvanR> fmap .: pure or something?
07:35:47 <kallisti> @src liftA
07:35:47 <lambdabot> liftA f a = pure f <*> a
07:35:49 <ski> if you already have an `Applicative i' constraint, you can use `liftA'
07:35:56 <kallisti> EvanR: it's not defined in terms of Functor
07:35:57 <applicative> why fmap .: pure and not fmap
07:36:01 <EvanR> oh
07:36:05 <ski> but since that implies `Functor i', you may use `fmap' instead if you wish
07:36:11 <kallisti> EvanR: if it were
07:36:12 <kallisti> it would just be
07:36:14 <kallisti> liftA = fmap
07:36:28 <EvanR> i figured you need to convert the (a -> b) into f (a -> b)
07:36:38 <EvanR> first
07:36:41 <kallisti> yep, you do.
07:36:50 <EvanR> so pure
07:36:52 <kallisti> but then fmap is the wrong function.
07:36:53 <ski> @. pl src liftA
07:36:53 <lambdabot> (line 1, column 1):
07:36:53 <lambdabot> unexpected end of input
07:36:53 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
07:36:56 <kallisti> you want <*>
07:37:22 <ski>   liftA = (<*>) . pure
07:37:23 <applicative> I wonder why they define liftA that way
07:37:36 <EvanR> yeah i got it
07:37:48 <EvanR> <*> not fmap
07:37:58 <ski> @src liftM
07:37:59 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
07:38:08 <kallisti> perhaps to account for the possibility that fmap could differ from pure f <*> a
07:38:12 <kallisti> though it typically shouldn't
07:38:23 <EvanR> kallisti: that would be against the law, right
07:38:26 <ski>   liftM f ma = return . f =<< ma
07:38:42 <kallisti> ah yes.
07:38:43 <ski>   liftM = (=<<) . (return .)
07:38:47 <kallisti> I suppose so.
07:38:51 <xarch> do you have any idea why I can't load the llvm-base package with ubuntu and LLVM 2.9?
07:39:11 <xarch> GHCi complains that "HSllvm-base-3.0.1.0.o: unknown symbol `LLVMInitializePIC16TargetInfo'
07:39:41 <applicative> does  the llvm package require an older llvm?
07:39:49 <xarch> nope
07:39:53 <xarch> I checked on hackage
07:39:59 <xarch> http://hackage.haskell.org/package/llvm-base-3.0.1.0
07:40:09 <applicative> nope i see
07:40:11 <xarch> the package is said to be compatible with LLVM 3.0 and 2.9
07:40:33 <xarch> and I have correctly installed llvm and llvm-dev
07:40:36 <applicative> and you only have one LLVM it could be looking for?
07:40:43 <xarch> yes
07:40:52 <EvanR> who invited all this Functor, Applicative, Pointed, Monad nonsense?
07:40:55 <EvanR> invented
07:41:21 * applicative was invited; he's on the A list
07:41:22 <EvanR> and how did it become somehow associated with computer programming
07:41:49 <Taneb> EvanR, Monads and Functors date back to the murky origins of Haskell
07:42:05 <xarch> you can read Applicative programming with effects for applicative functors
07:42:10 <applicative> EvanR the Monad type class has been around forever; Functor almost forever; Applicative is a bit recent.
07:42:12 <Taneb> Applicatives were added later and I don't think anyone's ever really needed Pointed
07:42:13 <xarch> and Monads for functional programming for monads
07:42:27 <xarch> and for functor, I don't know
07:42:39 <applicative> EvanR: the paper xarch mentions is awesome, it occasioned my stupid nick
07:42:50 <applicative> when I was first using Haskell
07:42:53 <EvanR> applicative programming with effects
07:43:12 <xarch> Monads for functional programming is also very good
07:43:15 <applicative> @google  "applicative programming with effects"
07:43:17 <lambdabot> http://www.soi.city.ac.uk/~ross/papers/Applicative.html
07:43:17 <lambdabot> Title: Applicative Programming with Effects
07:43:46 <Taneb> I guess we just take Functors for granted
07:43:57 <EvanR> <*> is literally the name for the special magic?
07:44:08 <EvanR> is there english for it?
07:44:39 <ski> you might pronounce it "ap", i suppose
07:44:48 <applicative> dunno, `ap` is the Monad version
07:44:51 <ski> @type (<*>)
07:44:51 <ski> @type ap
07:44:52 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
07:44:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
07:45:14 <EvanR> liftA, liftM, ap ;)
07:45:15 <applicative> ski sorry, I am using browser-freenode, which doesn't update while I type
07:45:17 <EvanR> funny
07:45:27 <applicative> ap is different
07:45:37 <ski> it's basically the same concept
07:45:41 <applicative> liftA = liftM = fmap = <$>
07:45:43 <EvanR> they are all equivalent to something else but with different types
07:45:51 <ski> just as `fmap','liftA',`liftM' is basically the same idea
07:45:52 <applicative> (if the instances are lined up)
07:46:04 <applicative> in the case of list they are map
07:46:21 <applicative> <*> = ap
07:46:23 <EvanR> <*> and >>= are the same for list?
07:46:28 <EvanR> er
07:46:36 <EvanR> <*> and ap
07:46:38 <applicative> which is zipWith ($) for lists
07:46:46 <mroman> why is there no generalization for lift actually?
07:46:55 <mroman> :t liftM
07:46:56 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
07:46:59 <mroman> :t liftA
07:47:00 <applicative> yes EvanR
07:47:01 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
07:47:16 <mroman> It's pretty much the same.
07:47:28 <applicative> > [(+1),(+2)] `ap` [1,2]
07:47:29 <lambdabot>   [2,3,3,4]
07:47:38 <kallisti> mroman: because no one has found a need for it, I would imagine.
07:48:02 <applicative> wait, I made a wrong statement of course it's not zipWith ($)
07:48:09 <kallisti> applicative: that would be ZipList
07:48:14 <mroman> (Liftable l) => (a -> b) -> l a -> l b should be possible?
07:48:21 <applicative> > [(+1),(+2)] <*> [1,2]
07:48:22 <lambdabot>   [2,3,3,4]
07:48:23 <mroman> And then one could make them instances of Liftable
07:48:33 <Taneb> @djinn [a -> b] -> a -> [b]
07:48:33 <lambdabot> Error: Undefined type []
07:48:34 <kallisti> mroman: make what instances of Liftable?
07:48:43 <EvanR> mroman: but they are already instances of Functor
07:48:45 <mroman> Whatever has a lift*
07:48:46 <Taneb> :t \a -> map ($ a)
07:48:47 <lambdabot> forall a b. a -> [a -> b] -> [b]
07:48:53 <aristid> @hoogle [b -> c] -> [b] -> [c]
07:48:53 <kallisti> mroman: such as?
07:48:54 <EvanR> which is why everyone says use fmap
07:48:54 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
07:48:54 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
07:48:54 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
07:49:03 <applicative> so ap = <*> = [f x | f <- fs, x <- xs]
07:49:18 <mroman> kallisti: Monads?
07:49:18 <applicative> so ap = <*> = \fs xs -> [f x | f <- fs, x <- xs]
07:49:31 <EvanR> mroman: Monads are supposed to have Functor instances
07:49:31 <kallisti> mroman: you'll wind up with overlapping instances if you do it that way
07:49:46 <mroman> instance (Monad m) => Liftable m where lift = ...
07:49:52 <aristid> @src ap
07:49:52 <lambdabot> ap = liftM2 id
07:50:02 <kallisti> mroman: if you define an equivalent Applicative-based instances
07:50:04 <ski> mroman : the generalization is called `fmap'
07:50:04 <kallisti> they'll overlap
07:50:19 <mroman> :t fmap
07:50:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:50:27 * applicative would have defined liftM2 in terms of ap
07:50:32 <mroman> :t lift
07:50:34 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
07:50:46 <applicative> @src liftA2
07:50:46 <lambdabot> liftA2 f a b = f <$> a <*> b
07:50:58 <EvanR> lift is something else
07:51:02 <mroman> :t liftM
07:51:03 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
07:51:13 <EvanR> same word different idea
07:51:13 <kallisti> mroman: with overlapping instances turned off, you can effectively ignore the class constraint entirely when determining the uniqueness of instances.
07:51:29 <EvanR> :t liftIO
07:51:31 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
07:51:36 <kallisti> mroman: so GHC will see 2 instances for "a"  and complain that they overlap.
07:51:51 <nobdraisentone> @pl (\x -> if x == 3 then 5 else x)
07:51:51 <lambdabot> flip if' 5 =<< (3 ==)
07:51:56 <kallisti> "Liftable" would have to define an instance for each individual Monad and Applicative. Which, as it turns out, is exactly what Functor is.
07:52:00 <nobdraisentone> How can I rewrite it?
07:52:00 <applicative> it would have been better if fmap had been called lift
07:52:10 <kallisti> or map. ;)
07:52:15 <EvanR> yeah map
07:52:21 <applicative> nobdraisentone: pattern  match with case
07:52:40 <EvanR> its not lifting anything, its applying a function
07:52:42 <applicative> oh you want it point free nobdraisentone
07:52:59 <applicative> EvanR: what isn't lifting anything
07:53:03 <EvanR> fmap
07:53:13 <kallisti> you can view it as lifting.
07:53:16 <EvanR> >_>
07:53:21 <kallisti> fmap (+1)  lifts a function
07:53:29 <nobdraisentone> applicative: point free, yeah
07:53:33 <EvanR> only for applicative
07:53:38 <kallisti> EvanR: hm? no.
07:53:40 <applicative> its a metaphor of course, but it lifts an ordinary function into the space of the functor/applicative/monad
07:53:41 <EvanR> er
07:53:43 <kallisti> why only applicative?
07:54:00 <kallisti> :t fmap
07:54:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:54:05 <applicative> lift doesn't lift either
07:54:15 <kallisti> read as:   Functor f => (a -> b) -> (f a -> f b)
07:54:20 <kallisti> the lifting viewpoint makes sense
07:54:23 <EvanR> i saw it as fmap f x as application
07:54:32 <EvanR> i guess fmap f is 'lifting'
07:54:35 * applicative is with kallisti
07:54:39 <mroman> nobdraisentone: f x = [x,5]!!(fromEnum$x==3)
07:54:49 <EvanR> but now every partial application is called 'lifting'
07:54:58 <EvanR> now were in hipster terminology land
07:55:02 <mroman> @pl (\x -> [x,5]!!(fromEnum$x==3))
07:55:02 <lambdabot> liftM2 (!!) (: [5]) (fromEnum . (3 ==))
07:55:08 <kallisti> EvanR: no, only this particular one.
07:55:13 <EvanR> why?
07:55:15 <applicative> EvanR: similarly, in applicative, one might speak of <*> as lifted application, or as lifted whitespace :)
07:55:37 <kallisti> EvanR: because it takes a function and promotes its argument and return type to the Functor in question.
07:55:41 <kallisti> not every function does this.
07:55:44 <aristid> i wish there was a function for zipWith id, optimally in operator syntax.
07:55:54 <EvanR> oh (a -> b) -> (f a -> f b)
07:56:01 <kallisti> yes
07:56:43 <applicative> EvanR f started out acting in the 'real' world, but fmap puts it in the f world
07:56:59 <applicative> which is part of the real world, but never mind
07:57:12 <applicative> where real world = the type system
07:57:57 <mroman> nobdraisentone: Or: let f x = 5*(fromEnum$x==3)+(x*(1-(fromEnum$x==3)))
07:58:13 <nobdraisentone> mroman: awesome
07:58:15 <mroman> @pl (\x -> 5*(fromEnum$x==3)+(x*(1-(fromEnum$x==3))))
07:58:15 <lambdabot> ap ((+) . (5 *) . fromEnum . (3 ==)) (ap (*) ((-) 1 . fromEnum . (3 ==)))
07:58:24 <mroman> but it does not get any better than using if' ;)
07:58:38 <kallisti> which is why you should totally check out:
07:58:40 <kallisti> @hackage cond
07:58:41 <lambdabot> http://hackage.haskell.org/package/cond
07:58:44 * kallisti shamelessly self-promotes.
07:59:12 <EvanR> kallisti invented the if statement
07:59:16 <EvanR> can i haz goto?
07:59:33 <kallisti> yes I have proof that this statement is factual.
07:59:34 <EvanR> that would make haskell more powerful
07:59:36 <kallisti> I am the Al Gore of if.
07:59:49 <applicative> EvanR: there are plenty of  gotos on hackage I think
07:59:54 <mroman> Either (\x -> [x,5]!!(fromEnum$x==3)) or (\x -> 5*(fromEnum$x==3)+(x*(1-(fromEnum$x==3)))) if you just don't want to use if/case
08:00:00 <mroman> and not using patterns ;)
08:00:27 <kallisti> there are so many reasons why you shouldn't do what mroman is suggesting.
08:00:38 <EvanR> GotoT
08:00:39 <mroman> I can't think of one . ;P
08:00:46 <mroman> They both totally work.
08:00:54 <nobdraisentone> Like COMMON SENSE
08:01:24 <mroman> That's how we program in da hood.
08:01:29 <applicative> EvanR: http://hackage.haskell.org/package/GotoT-transformers-1.0 for example, but the greatest is
08:01:46 <kallisti> nobdraisentone: use cond, it will make your life better.
08:01:56 <kallisti> you will wonder why these things aren't in base somewhere.
08:02:09 <nobdraisentone> Okay
08:02:23 <applicative> EvanR: have you seen this program :)  I think the library doesn't build these days http://augustss.blogspot.com/2009/02/more-basic-not-that-anybody-should-care.html
08:02:31 <kallisti> oh? that actually worked? okay.
08:03:18 <EvanR> applicative: hahaha
08:03:55 <xarch> ok, so I tried reinstalling LLVM, and then installing LLVM 3.0, and reinstalling llvm-base
08:03:59 <xarch> but it still doesn't work
08:04:09 <EvanR> applicative: it uses polymorphic number literals ?
08:04:11 <xarch> with exactly the same error
08:04:48 <applicative> xarch, and there was no linking problem?  can you build and executable or is it just ghci
08:05:04 <applicative> EvanR: very polymorphic
08:05:47 <xarch> I'll try
08:05:59 <EvanR> applicative: so you can bust into a basic program at any time
08:06:04 <EvanR> priceless
08:06:09 <EvanR> use the right tool for the job!
08:06:25 <xarch> it seems to work if I compile it
08:06:34 <xarch> well, I guess it'll be ok like that
08:08:12 <hpaste> applicative pasted “BASIC Num Show instances” at http://hpaste.org/70575
08:08:30 <applicative> ^^^ EvanR check out these revolting instances
08:09:09 <EvanR> lol
08:09:14 <applicative> instance (Integral t) => Num (GOTO -> t -> Expr a)
08:09:33 <kallisti> s/revolting/beautiful/
08:09:45 <EvanR> why do the Eq and Show instances have no body
08:11:47 <EvanR> i use ruby at work, and i feel like its basic without goto
08:11:51 <EvanR> lol
08:12:06 <kallisti> I've never gotten that impression from Ruby.
08:12:09 <kallisti> but I don't know basic very well.
08:12:41 <mroman> oh
08:12:50 <mroman> nobdraisentone: (\x -> 5*(1-abs(signum$(x-3)))+x*(abs(signum$(x-3))))
08:13:19 <mroman> @pl (\x -> 5*(1-abs(signum$(x-3)))+x*(abs(signum$(x-3))))
08:13:19 <lambdabot> ap ((+) . (5 *) . (-) 1 . abs . signum . subtract 3) (ap (*) (abs . signum . subtract 3))
08:13:20 <kallisti> Ruby to me feels like a Python/Perl/Smalltalk hybrid of sorts.
08:13:28 <mroman> That's pretty cool too.
08:13:38 <mroman> No booleans involved = extra points
08:16:23 <mroman> You don't like abs: use (\x->5*(1-(((signum(x-3)`mod`2))))+x*(((signum(x-3))`mod`2)))
08:16:56 <kallisti> if you don't like whitespace, you're in good company.
08:17:13 <merijn> kallisti: I remember a discussion coming up in #python (or somewhere anyway) where someone said that Ruby was trying to out-Python Python
08:17:27 <merijn> kallisti: To which the response was "Nah, it's trying to out-Smalltalk Perl"
08:17:35 <kallisti> no one can out-Python Python.
08:17:43 <kallisti> it's a special, unique snowflake.
08:18:05 <companion_cube> slowflake*
08:18:59 <kallisti> I think Perl 6 is trying to out-Perl 6 itself.
08:19:14 <kallisti> which is why we don't have a stable release.
08:20:02 <nand`> Haskell is the fixed point of out-Haskelling
08:20:22 <mroman> Don't like signum use (-1 * fromEnum((x<0))) + (1 * fromEnum((x>0)))
08:20:31 <mroman> kallisti: I like whitespace.
08:20:37 <mroman> But I also like weird programs ;)
08:21:23 <hqm42> what is the equvalent to 'fromConstr' from syb in GHC.Generics?
08:21:38 <kallisti> mroman: fromEnum(x<0) is not the same as abs(signum(x-3))
08:22:11 <mroman> > (\x -> (-1 * fromEnum((x<0))) + (1 * fromEnum((x>0)))) 9
08:22:12 <lambdabot>   1
08:22:15 <mroman> > (\x -> (-1 * fromEnum((x<0))) + (1 * fromEnum((x>0)))) (-9)
08:22:16 <lambdabot>   -1
08:22:19 <mroman> > (\x -> (-1 * fromEnum((x<0))) + (1 * fromEnum((x>0)))) 0
08:22:20 <lambdabot>   0
08:23:31 <mroman> > (\x->5*(1-((((\z->(-1*fromEnum((z<0)))+(1*fromEnum((z>0))))(x-3)`mod`2))))+x*((((\z->(-1*fromEnum((z<0)))+(1*fromEnum((z>0))))(x-3))`mod`2))) 3
08:23:33 <lambdabot>   5
08:23:35 <mroman> > (\x->5*(1-((((\z->(-1*fromEnum((z<0)))+(1*fromEnum((z>0))))(x-3)`mod`2))))+x*((((\z->(-1*fromEnum((z<0)))+(1*fromEnum((z>0))))(x-3))`mod`2))) 2
08:23:36 <lambdabot>   2
08:23:38 <mroman> > (\x->5*(1-((((\z->(-1*fromEnum((z<0)))+(1*fromEnum((z>0))))(x-3)`mod`2))))+x*((((\z->(-1*fromEnum((z<0)))+(1*fromEnum((z>0))))(x-3))`mod`2))) 7
08:23:39 <lambdabot>   7
08:23:44 <mroman> see. no problem ;)
08:25:30 <mroman> I'm probably the biggest abuser of haskell, I know.
08:26:14 <mroman> @pl (\x->5*(1-((((\z->(-1*fromEnum((z<0)))+(1*fromEnum((z>0))))(x-3)`mod`2))))+x*((((\z->(-1*fromEnum((z<0)))+(1*fromEnum((z>0))))(x-3))`mod`2)))
08:26:15 <lambdabot> ap ((+) . (5 *) . (-) 1 . (`mod` 2) . ap ((+) . negate . fromEnum . (< 0)) (fromEnum . (> 0)) . subtract 3) (ap (*) ((`mod` 2) . ap ((+) . negate . fromEnum . (< 0)) (fromEnum . (> 0)) . subtract 3))
08:29:25 <matthiasgorgens> Is there a standard library to parse configuration files?
08:30:05 <matthiasgorgens> I.e. in my program there'll be a file with URLs to look up.  one url per line, but I want to allow blank lines and comments after #.
08:30:13 <matthiasgorgens> it's easy enough to do ad-hoc.
08:30:27 <nobdraisentone> How can I apply function Key → Value → Value to each pair (key,value) of map?
08:30:35 <nobdraisentone> of Map*
08:30:44 <matthiasgorgens> nobdraisentone: mapWithKey or s.
08:30:52 <matthiasgorgens> or so.
08:31:08 <mroman> Data.Ini maybe?
08:31:48 <matthiasgorgens> mroman: thanks, seems worth a look.
08:32:29 <mroman> or just readFile >>= return.filter(p).lines and p which filters blank lines and lines starting with #
08:32:31 <kallisti> matthiasgorgens: parsec isn't a bad choice
08:32:37 <kallisti> especially if you have a marginally complex configuration file format.
08:32:46 <kallisti> parsec will make it easier to extend later, as well.
08:33:16 <matthiasgorgens> kallisti: yeah, but parsec is too general.
08:33:34 <kallisti> well, sure. if you just want to parse a standard conf format.
08:33:36 <matthiasgorgens> kallisti: I wanted to stay with a default style.  but yeah,
08:33:38 <mroman> Although Data.Ini may require foo=bar entries instead of just plain lines.
08:33:45 <matthiasgorgens> once it gets complicated, a full blown parser would be the way to go.
08:33:57 <kallisti> you make parsec sound complicated.
08:34:01 <matthiasgorgens> mroman: yeah, that seems likely.
08:34:11 <matthiasgorgens> kallisti: parsec is not complicated.  it's just overkill.
08:34:52 <matthiasgorgens> ok, I'm going with an adhoc version now, but added a commen to the code, that when ever we have more complicated requirements, we should switch to Data.Ini, or if it gets even more complicated, parsec.
08:34:55 <kallisti> barring the existence of a library that automatically handles the format you want to parse, it's going to be less time and effort than any ad-hoc method. and less error-prone than regex.
08:35:14 <matthiasgorgens> the format at the moment is completely defined as:
08:35:18 <matthiasgorgens>     filter (not . isblank) . map stripComments . lines <$> fileContents xcReleasesInfosPath
08:35:18 <matthiasgorgens>   where stripComments = takeWhile (/= '#')
08:35:18 <matthiasgorgens>         isBlank = all isSpace
08:35:27 <matthiasgorgens> and really, we don't even need that complexity.
08:35:38 <matthiasgorgens> just `lines' would have been enough.
08:35:51 <mroman> matthiasgorgens: http://codepad.org/uumRfqzH
08:36:18 <mroman> If you want to keep it simple.
08:36:31 <matthiasgorgens> mroman: that's slightly less powerful than what I have.
08:36:43 <mroman> Yes.
08:36:47 <mroman> takeWhile (/= '#')
08:36:54 <kallisti> stripComments = takeWhile (/='#')   assuming no quotation syntax
08:36:56 <kallisti> yes
08:36:57 <matthiasgorgens> I thought of that approach, but only allowing comments at the beginning of a line seemed to avoid the principle of least surprise to me.
08:37:04 <mroman> I thought he only had # at the start of a line.
08:37:05 <matthiasgorgens> yes, I assume no quotation syntax.
08:37:09 <matthiasgorgens> (or rather, url-encoding,
08:37:14 <matthiasgorgens> it's a list of url.
08:37:16 <matthiasgorgens> urls.
08:37:21 <mroman> urls may contain #
08:37:21 <matthiasgorgens> and url-encoding doesn't use #.
08:37:33 <kallisti> if you want quotes, there are existing formats you can use. for example, Data.Aeson has a JSON string attoparsec parser.
08:37:35 <c_wraith> # is valid in URLs, though
08:37:44 <kallisti> which I use to parse Firefox profile preference files.
08:37:59 <matthiasgorgens> ok, I'll disallow comments.
08:38:21 <matthiasgorgens> filter (not . all isSpace) . lines <$> fileContents xcReleasesInfosPath
08:38:25 <matthiasgorgens> no need to quote then.
08:38:36 <matthiasgorgens> (and we don't allow all blank URLs.)
08:39:18 <mroman> matthiasgorgens: You could use filter (isURI) from Network.URI too.
08:39:53 <matthiasgorgens> mroman: that might be useful to throw meaningful error messages.
08:39:58 <kallisti> assuming either isURI doesn't follow the standard or you don't expect non-standard URIs.
08:40:13 <mroman> kallisti: ?
08:40:29 <matthiasgorgens> kallisti: ?
08:40:54 <mroman> I really *hope* it does follow standard @isURI
08:41:02 <mroman> Else I would consider that a Bug in Network.URI
08:41:19 <kallisti> right, perhaps I should have re-arranged my conditions in order of importance. :P
08:41:47 <kallisti> if you're expecting non-standard URIs, then, assuming isURI follows the standard, you won't get the results you want
08:41:56 <kallisti> basically.
08:42:15 <matthiasgorgens> hmm, I wouldn't expect non-standard uris.
08:42:37 <kallisti> okay. hopefully no one else does either.
08:42:45 <kallisti> (they really shouldn't)
08:43:03 <matthiasgorgens> or rather: I'd rather throw an error when getting a non-standard uri, than accepting garbage,
08:43:11 <matthiasgorgens> better to fail early.
08:45:09 <hqm42> Hi. I have been working with SYB for a while now and i am trying to switch to GHC.Generics. How do i reconstruct a value from its constructor in GHC.Generics
08:45:13 <hqm42> ß
08:45:14 <hqm42> ?
08:45:19 <kallisti> looks like creating a working FFI to GraphicsMagick will be pretty challenging (or at least tedious)
08:46:00 <hqm42> In SYB i used fromConstr/fromConstrM for this job
08:50:12 <KSkrzet> what is the best emacs mode for cabal files?
09:19:13 <EvanR> :t \x -> x x :: (a -> a) -> a
09:19:15 <lambdabot>     Occurs check: cannot construct the infinite type:
09:19:15 <lambdabot>       t = t -> (a -> a) -> a
09:19:15 <lambdabot>     Probable cause: `x' is applied to too many arguments
09:19:32 <EvanR> :t \x -> x x :: (a -> a) -> (a -> a)
09:19:34 <lambdabot>     Occurs check: cannot construct the infinite type:
09:19:34 <lambdabot>       t = t -> (a -> a) -> a -> a
09:19:34 <lambdabot>     Probable cause: `x' is applied to too many arguments
09:19:51 <Eduard_Munteanu> You can't type the omega combinator in Haskell.
09:19:59 <EvanR> blawg
09:20:16 <Eduard_Munteanu> You can't even type Y or Z, btw.
09:20:26 <EvanR> not familiar with Z
09:20:36 <Eduard_Munteanu> Z is the strict variant of Y.
09:20:45 <Eduard_Munteanu> (for strict languages I mean)
09:21:12 <EvanR> how does fix work then
09:21:17 <EvanR> :t fix
09:21:18 <lambdabot> forall a. (a -> a) -> a
09:21:22 <Eduard_Munteanu> @src fix
09:21:23 <lambdabot> fix f = let x = f x in x
09:21:27 <parcs`> @where y
09:21:28 <lambdabot> \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x)))
09:21:54 <Eduard_Munteanu> parcs`: not *quite* Y, though
09:22:01 <parcs`> what would be the inferred type of \x -> x x with rank-2 type inference?
09:22:23 <Eduard_Munteanu> I don't think it's a question of rank-2/n types.
09:22:47 <ski> Eduard_Munteanu : "Y Combinator in Haskell" <http://r6.ca/blog/20060919T084800Z.html>
09:22:57 <ski> EvanR ^
09:23:26 <ski> parcs` : no, it's a matter of not allowing cyclic types -- in `ocaml -rectypes', it works
09:23:43 <Eduard_Munteanu> EvanR: you don't need fix in Haskell, btw, the language allows arbitrary recursion anyway
09:23:46 <parcs`> what is a cyclic type?
09:23:59 <Eduard_Munteanu> Equirecursive types, I take it.
09:24:09 <Eduard_Munteanu> ski: yeah, though not really Y.
09:24:24 <EvanR> Eduard_Munteanu: yeah but i like fix to eliminate an unnecessary variable
09:24:35 <EvanR> when i need a explicitly recursive loop
09:24:40 <ski> @type let f [] ys = ys; f xs [] = xs; f (x:xs) (y:ys) = x in f
09:24:41 <lambdabot>     Occurs check: cannot construct the infinite type: t = [t]
09:24:41 <lambdabot>       Expected type: [t]
09:24:42 <lambdabot>       Inferred type: t
09:24:44 <ski> e.g.
09:24:50 <ski> parcs` ^
09:26:07 <parcs`> how would that ever typecheck?
09:26:20 <Eduard_Munteanu> Isorecursive types say List A ~ 1 + A * List A, while equirecursive types say that "~" is actually an equality.
09:26:31 <parcs`> ie what is valid type of f
09:26:58 <Eduard_Munteanu> parcs`: it's a type such that t = [t]
09:27:04 <Eduard_Munteanu> *type t
09:27:26 <Eduard_Munteanu> And you could unroll that as much as you'd wish.
09:27:27 <ski> parcs` : `f :: a -> a -> a where a = [a]'
09:28:24 <Eduard_Munteanu> ski: btw, do you know any theorem prover / dependent type system / fun thing that gives you equirecursive types?
09:28:39 <Eduard_Munteanu> They seem pretty rare :/
09:28:50 * hackagebot hspec-expectations 0.3.0.1 - Catchy combinators for HUnit  http://hackage.haskell.org/package/hspec-expectations-0.3.0.1 (SimonHengel)
09:29:57 <ski> $ ocaml -rectypes
09:29:58 <ski> # let f xs ys = match    xs,   ys with | [   ],_     -> ys | _    ,[   ] -> xs | x::xs,y::ys -> x;;
09:30:01 <ski> val f : ('a list as 'a) -> 'a -> 'a = <fun>
09:30:53 <Eduard_Munteanu> Mm, yeah, though Ocaml isn't that much of a fun typesystem :D
09:31:01 <ski> Eduard_Munteanu : to give them in general would be unsounds (seen as a logic) -- i suppose it might work to give them when the cycle is positive, or strictly positive
09:31:29 <Eduard_Munteanu> ski: same restriction applies to isorecursive types too, though
09:31:39 <Eduard_Munteanu> e.g. Agda checks for strict positivity.
09:31:44 * ski nods
09:32:07 <nonefool> SugarHaskell seems awesome http://sugarj.org/sugarhaskell.pdf
09:32:44 <nonefool> now somebody can finally implement a C-to-haskell desugar module that removes all the burden of functional thinking!
09:32:59 <ski> another possibility is to make `mu r. (..r..)[x |-> r]' equal to `mu. (..r..)[x |-> mu r. (..r..)[x |-> r]]'
09:33:45 <matthiasgorgens> nonefool: do you want to use haskell as an intermediate language when compiling your c code?
09:34:01 <nonefool> matthiasgorgens: of course I was just joking
09:34:33 <EvanR> id like a C Monad for haskell
09:35:07 <parcs`> Eduard_Munteanu: if ghc had rank 2 type inference than \x -> x x could have the type (forall a. a -> a) -> b -> b
09:35:34 <nonefool> but apart from arrow/codo etc notation, I can imagine some embedded imperative language that has no more syntactic overhead than necessary
09:36:10 <xarch> why not (forall a. a -> a) -> (forall a. a -> a) ?
09:36:36 <Eduard_Munteanu> parcs`: um, does it work if you provide that type yourself? :/
09:37:19 <Eduard_Munteanu> :t (\x -> x x) :: (forall a. a -> a) -> b -> b
09:37:20 <lambdabot> forall b. (forall a. a -> a) -> b -> b
09:37:26 <nonefool> something that makes the first post on http://augustss.blogspot.nl/ seem a lot more natural
09:37:47 <nonefool> why I would need this? just because I can!
09:37:51 <ski> preflex: xseen augustss
09:37:51 <preflex>  augustss was last seen on freenode/#haskell 232 days, 16 hours, 5 minutes and 44 seconds ago, saying: > div (-1) 2
09:37:53 <jamiltron> Has anyone else had problems on OSX with System.Random? Specifically, when I try to import it, it says there is no such module, but when I try to cabal install random it tells me its already the latest.
09:38:26 <parcs`> Eduard_Munteanu: but i'm wondering if that's the most general type
09:39:39 <nonefool> general sugar for some EDSL would also come in handy some times, easy notation for filling matrices etc
09:39:40 <Eduard_Munteanu> xarch: that's the same thing, btw
09:40:04 <xarch> yeah
09:42:38 <Eduard_Munteanu> Ooops, wait, that's not quite omega :/
09:44:20 <xarch> that's delta, actually
09:44:24 <xarch> omega is delta delta
09:45:37 <Wooga> hmm, why ((>>=) xs f) isn't defined as (mconcat (fmap f xs)) by default ?
09:45:58 <tgeeky_> @src (>>=)
09:45:58 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
09:46:10 <Wooga> it has no default implementation
09:46:19 <ski> xarch : `\x. x x' is `omega' and `omega omega' is `Omega'
09:46:42 <Wooga> i wonder why
09:47:23 <ski> "To Dissect a Mockingbird: A Graphical Notation for the Lambda Calculus with Animated Reduction" by David C. Keenan in 1996-08-27 (-- 2009-11-20) at <http://dkeenan.com/Lambda/>
09:48:21 <ski> @type mconcat
09:48:22 <lambdabot> forall a. (Monoid a) => [a] -> a
09:48:45 <Wooga> ah, mconcat takes only lists
09:48:54 <ski> @type join
09:48:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
09:49:06 <ski> @type \f xs -> mconcat (fmap f xs)
09:49:07 <lambdabot> forall a a1. (Monoid a1) => (a -> a1) -> [a] -> a1
09:49:17 <ski> @type \f ma -> join (fmap f ma)
09:49:18 <lambdabot> forall a (m :: * -> *) a1. (Functor m, Monad m) => (a -> m a1) -> m a -> m a1
09:49:34 <EvanR> :t msum
09:49:36 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
09:50:41 <ski> Wooga : `ma >>= amb = join (fmap amb ma)' would be a correct default (it already has to hold as a law), if `join' was a part of the `Monad' class (and if `Functor' was a superclass of it)
09:53:02 <Wooga> ski: i see, thanks.
09:54:13 <keseldude> I think I would like that more
09:54:22 <keseldude> join is probably easier to define than >>=
09:54:45 <keseldude> when making an instance of Monad, I mean
09:55:05 <ski> depends on the monad
09:55:21 <EvanR> m (m a) would seem to require a lot more patterns
09:55:30 <ski> sometimes `(>>=)' is more natural
09:56:14 <ski> EvanR : for e.g. `data Tree var = Var var | Lit Integer | Add (Tree var) (Tree var) | Mult (Tree var) (Tree var)', `join' is simpler
09:56:39 <keseldude> join (Just a) = a; join Nothing = Nothing. join l = concat. other examples
09:57:31 <EvanR> Just (Just x), Just Nothing, Nothing
09:57:52 <donri> EvanR: Just a = a covers the second case there
09:58:00 <EvanR> ok
09:58:10 <ski> keseldude : now try `State s' and `StateT s m'
09:58:37 <donri> if join was moved to the class, bind and join could have default implementations in terms of each other
09:58:39 <rwbarton> or Cont r
09:58:54 <ski> donri : .. provided `Functor' was made a superclass as well
09:59:04 <donri> ah, yea
09:59:20 <donri> and then we're back at the issue of code reuse
09:59:29 <ski> we are ?
10:00:13 <donri> http://www.haskell.org/pipermail/haskell-prime/2011-January/003312.html
10:04:20 <Peaker> it would be error-prone (if you define fmap = liftM, then you must define (>>=) and not join)
10:04:41 <nand`> How do I reduce this? do { s <- get; let (a, s') = f s; put s'; return a } -- I was certain there was a combinator for this, something like :: MonadState s m => (s -> (a, s)) -> m a
10:04:45 <nalssi> Does hackage.haskell.org block a certain IP? I can' access it at home while there's no problem at work
10:05:02 <nand`> oh there is, it's called ‘state’
10:05:23 <nand`> I was just confused because the ‘state’ I looked at first was :: -> State s a -- instead of MonadState
10:08:01 <nand`> oh, no wonder; I seem to have an older version of the mtl on my system for some reason, which apparently still has -> State s a
10:09:52 <byorgey> MonadState is a type class
10:10:12 <byorgey> oh, you mean   MonadState m => .... -> m a
10:11:10 <byorgey> nalssi: I don't think so.
10:12:20 <nalssi> byorgey:  I've seen others complaining the same.
10:14:12 <Taneb> nalssi, maybe it's an ISP problem?
10:14:52 <nalssi> Taneb: Hmm...maybe you are right.
10:19:19 <Taneb> Bye!
10:21:10 <ski> Peaker : you mean in the same sense as having `(==)' and `(/=)' defined in terms of each other ?
10:21:21 <applicative> nalssi: I don't think so; what are you trying to do with hackage?
10:21:21 <joeyh> I understand child threads terminate when the main thread exits .. do child threads also terminate when their parent thread exits?
10:21:48 <nalssi> applicative: I can't cabal install
10:22:13 <nalssi> applicative: Maybe I should give a call to my local ISP
10:22:17 <ski> @hoogle (s -> (a,s)) -> m a
10:22:18 <lambdabot> System.Random getStdRandom :: (StdGen -> (a, StdGen)) -> IO a
10:22:18 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
10:22:29 <ski> @type modify
10:22:30 <applicative> strange. Someone in China had this problem a week or so ago, I expect for a different reason
10:22:30 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
10:22:55 <nalssi> applicate: I'm in Korea, and some others here are complaining the same
10:23:05 <applicative> nalssi: ah
10:23:33 <ski> @type Data.IORef.modifyIORef
10:23:35 <lambdabot> forall a. GHC.IORef.IORef a -> (a -> a) -> IO ()
10:23:37 <applicative> nalssi: the cure, at least temporarily  was to replace this  line in ~/.cabal/configremote-repo: hackage.haskell.org:http://hackage.haskell.org/packages/archive
10:23:43 <applicative> this line rather remote-repo: hackage.haskell.org:http://hackage.haskell.org/packages/archive
10:24:25 <applicative> with the corresponding one for factisresearch.com substituted for haskell.org
10:24:30 <nalssi> applicative: Thank you, I'll try. And also I can't read documents from hackage.
10:24:47 <ski> nand` : yes, `MonadState s m => (s -> (a,s)) -> m a' could be useful
10:25:15 <applicative> nalssi: I've used factisresearch for a week or so without incident, having set it up when I was trying to help him
10:26:42 <applicative> nalssi can you read the webpages at hackage.factisresearch.com?
10:27:25 <nalssi> applicative: Yes, no problem
10:27:51 <applicative> oh so maybe replacing that line in your $HOME/.cabal/config will work too
10:27:52 <mroman> How does modify data in-place using acid-state?
10:27:54 <mroman> *one
10:28:16 <keseldude> ski: I think this is it? join s = StateT $ \st ->│                                                                                                let (x, st') = runState s st in Identity $ runState x st'
10:28:25 <keseldude> well that didn't paste well
10:28:51 <nalssi> applicative: Oh,...so this one almost completely replace the one I was trying to access but failed.
10:28:52 <bitonic> mroman: would you call writing data to a database "modifying data in place"? I'm not sure what you are asking for
10:29:00 <keseldude> join s = StateT $ \st -> let (x, st') = runState s st in Identity $ runState x st'
10:29:03 <ski> (`MonadBase' might alternatively work)
10:29:06 <nalssi> applicative: Thank you.
10:29:48 <mroman> Well.
10:30:03 <mroman> If you store a list.
10:30:04 <ski> keseldude : yes, though you can use `state' instead of `StateT' : that way you can skip the `Identity' part
10:30:07 <applicative> nalssi: so it works?
10:30:11 <mroman> You'd have to retreive the whole list, add an element, and store the list.
10:30:26 <mroman> the same if you store a tree or something like that.
10:30:34 <keseldude> ski: for some reason I don't have a constructor State. only type State s = StateT s Identity
10:30:37 <keseldude> or something like that
10:30:45 <nalssi> applicative: I did't try it to cabal yet but it looks promissing
10:30:46 <mroman> http://flygdynamikern.blogspot.ch/2011/06/toy-url-shortener-with-yesod-and-acid.html
10:30:57 <mroman> ^- or like that.
10:31:42 <ski> keseldude : yes, before `State s a' was a separate type, and you had a data constructor `State' for it. now it is defined as `StateT s Identity a', and you can use `state' instead of the data constructor (for constructing. for matching you need `runState')
10:31:42 <keseldude> oh you meant a function 'state'
10:31:46 <ski> yes
10:31:47 <keseldude> I didn't think to look it up
10:31:48 <keseldude> haha
10:31:50 <ski> @type state
10:31:52 <lambdabot> forall s a. (s -> (a, s)) -> State s a
10:31:55 <ski> @type runState
10:31:56 <lambdabot> forall s a. State s a -> s -> (a, s)
10:32:01 <ski> @type StateT
10:32:02 <lambdabot> forall s (m :: * -> *) a. (s -> m (a, s)) -> StateT s m a
10:32:04 <ski> @type runStateT
10:32:06 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
10:32:07 <keseldude> well thank you for telling me about it
10:32:26 <bitonic> mroman: pure data structures can share all common parts
10:32:52 <bitonic> mroman: but I think you're misunderstanding what acid-state does
10:33:12 <bitonic> it replicates an haskell data structure on disc, with very strong guarantees
10:33:52 <mroman> do Database entries <- get; put $ Database (new:entries)
10:34:04 <mroman> ^- it looks very time and memory consuming.
10:34:08 <bitonic> mroman: it isn't.
10:34:16 <mroman> like it has to populate the whole list first
10:34:19 <mroman> then modify it
10:34:23 <mroman> putting it back
10:34:25 <mroman> store it on the disc.
10:34:26 <bitonic> mroman: no
10:34:51 <mroman> laziness does its thing?
10:35:07 <applicative> mroman, have you tried the examples in the examples directory?
10:35:07 <bitonic> let's start with the simple example: `cons x xs = x : xs'. xs is not copied. a new list is created with `x' as head and `xs' as tail
10:35:24 <applicative> mroman: I think it is more purity doing its thing
10:35:41 <bitonic> applicative, mroman: yeah, it doesn't have to do with lazyness
10:35:48 <mroman> so
10:36:09 <mroman> data Node a = Empty | Leaf a (Node a) (Node a) deriving Show
10:36:15 <bitonic> mroman: for what regards "writing to db", it just writes down to a log as most db do, so it won't be that bad
10:36:21 <bitonic> but that's a separate issue
10:36:24 <mroman> I can just modify that without having to worry about it?
10:36:49 <bitonic> mroman: well if the "modified" tree points to another tree, that tree won't be copied
10:36:49 <mroman> that'd be
10:36:49 <Taneb> If I were ever to write a serious website in Haskell, I'd probably end up using a bizarre mix of Happstack, Snap, Yesod, XSLT, JavaScript, and god knows what else
10:36:56 <applicative> mroman: you cant modify your type!
10:37:51 <mroman> http://codepad.org/qeJOhbD0
10:38:11 <Taneb> Is there a word for trees where data is only in leaves rather than in branches?
10:38:22 <mroman> I was worried about the performance of insert
10:38:38 <ski> Taneb : maybe "leaf tree" or "fringe tree" ?
10:38:42 <Taneb> (leafy tree is a monad, branchy tree is a comonad)
10:38:46 <byorgey> Taneb: I've heard them called many things: leafy trees, parenthesizations
10:38:58 <Taneb> Actually, branchy tree is a monad too
10:39:28 <mroman> I want to store such a data structure with acid state.
10:39:37 <mroman> Which I know how to do.
10:40:12 <bitonic> mroman: read the first chapters of "Purely functional data structures" if you want to understand well how you can share data. For what concerns the acid-state persistor performance, it's a classic db log - you're writing to a file and fsyncing
10:40:15 <mroman> But wasn't sure how acid-state would handle it.
10:40:37 <mroman> bitonic: Thanks.
10:40:50 <squidz> can anybody tell me why acid-state isn't suitible for big data?
10:41:11 <bitonic> squidz: who told you that?
10:41:12 <hpaste> tgeeky pasted “failed examples” at http://hpaste.org/70578
10:41:34 <bitonic> squidz: anyway, one issue is that all the data has to fit in memory at once
10:41:47 <mroman> bitonic: acid-state is in-memory
10:41:55 <bitonic> mroman: yes.
10:41:55 <mroman> which is a very serious limitation
10:42:16 <bitonic> mroman: that's what I said
10:42:24 <mroman> I can't have a database bigger than 50MB with acid-state because my vserver does not have enough ram for it :)
10:42:39 <bitonic> mroman: agreed.
10:42:49 <shapr> acid-state was designed for servers with lots of ram.
10:42:59 <applicative> mroman: the webpage suggests: buy more ram
10:43:04 <mroman> Well.
10:43:07 <shapr> alexj put together a bunch of really great ideas with HAppS
10:43:10 <mroman> The webpage claims RAM is cheap.
10:43:11 <mroman> It's not.
10:43:12 <mroman> ;)
10:43:16 <bitonic> applicative, shapr: that's still a limitation
10:43:19 <mroman> Not if you're renting a v-server.
10:43:42 <applicative> facebook does it mroman :)
10:43:46 <bitonic> mroman: acid-state is not a replacement for e.g. postgres.
10:43:59 <bitonic> it does different things in a different way
10:44:18 <tgeeky> < hpaste> tgeeky pasted “failed examples” at http://hpaste.org/70578 <-- can someone let me know what I should do, other than comment out the examples? :O
10:44:22 <shapr> So the real solution is to rent a blade in a bladeserver, give it 64gb of ram, and then for a small amount of money, rent out user accounts for happstack dev!
10:44:29 <squidz> bitonic: in which way is it different
10:44:32 * shapr digs around
10:45:19 <bitonic> squidz: you can probably list the similarities more easily... e.g. ACID transactions
10:45:22 <bitonic> that's about it really
10:45:41 <shapr> Looks like an 8-core blade with 256gb of RAM would make everybody happy.
10:46:43 * tgeeky will consume all the memory running particle physics simulations with happstack
10:47:20 <shapr> It's actually pretty affordable at $20k us
10:47:40 <mroman> 20k is definetily not affordable ;)
10:47:49 <applicative> tgeeky: hlist = I (3) ::: (I (\x -> x) ::: (I False ::: TNil))
10:48:08 <mroman> That's like Infinity times as much as I earn.
10:48:29 <applicative> tgeeky: I think you just have the association of ::: wrong
10:50:29 <squidz> will it be possible to use acid-state on multiple machines
10:50:39 <applicative> tgeeky: add infixr 2 ::: or something by the declaration of TList
10:50:50 <mroman> squidz: There is Acid.Remote
10:51:01 <mroman> so you can access an acid store on another machine.
10:51:55 <squidz> so distributing the machines might eliminate the memory problem, but not sure how it would perfom in the end
10:56:57 <applicative> squidz: I would think there is room for development; the .Remote module was only added a few months ago.
11:01:29 <t7> why is there no haskell talk at google io 2012
11:01:34 <t7> comon guys!
11:03:59 <silver> t7, that's actually a good thing
11:05:58 --- mode: holmes.freenode.net set +o ChanServ
11:11:17 <t7> too well known?
11:13:17 * shapr boings cheerfully
11:13:20 <shapr> yay working code!
11:13:24 <byorgey> =D
11:14:14 * applicative is trying to think up some use he can make of acid-state, which is seeming more awesome than he remembered
11:14:46 <illissius> working code would be so awesome
11:15:45 <adimit> So, ever since upgrading to the new Haskell platform, cabal-install has been constantly nagging me that any install I do is going to break stuff, and ghc-pkg check is constantly complaining about stuff being broken. I can't seem to find much about this on the 'net… is there anything I'm doing wrong?
11:16:29 <Taneb> adimit, upgrading old packages, it seems
11:16:30 <silver> no
11:16:35 <silver> it's totally alright
11:16:36 <Taneb> And before I can clarify, I'm gonna leave
11:16:43 <silver> just run the haskell-updater
11:16:53 <adimit> silver: what's the haskell-updater?
11:17:02 <silver> what OS do you have?
11:17:13 <adimit> (also, the packages that ghc-pkg check complains about being broken work fine. Hoogle for example.)
11:17:18 <adimit> silver: Linux.
11:17:42 <applicative> adimit, the confusions are all in your local installs?
11:17:43 <adimit> so, haskell-updater is a cabal package. ok, downloading it and giving it a try.
11:17:50 <silver> can you check if you distribution have the app named haskell-updater?
11:17:50 <adimit> applicative: yes.
11:18:09 <applicative> adimit: hoogle the executable  might work though the libraries are broken
11:18:18 <adimit> I don't use distribution-provided haskell packages because those are always sorely outdated on Debian stable.
11:18:26 <silver> oh
11:18:42 <shapr> Yay! I can correctly display Strings, SVG output from the diagrams lib and various other goodness!
11:18:43 <applicative> adimit: why don't you just unregister the broken stuff?
11:19:01 <shapr> adimit: debian/testing has ghc 7.4.1, that's what I'm using.
11:19:15 <silver> never used haskell-updater installed by cabal, so not sure if it'll work, but give it a try
11:19:59 <adimit> applicative: it breaks all the time. I install something and then I install another thing and then it always complains.
11:20:34 <applicative> i see that is strange.  did you have the same version of ghc before? i am just considering some obvious things
11:20:35 <byorgey> shapr: yay!
11:20:54 <applicative> shapr what does debian stable have?
11:20:55 <shapr> byorgey: Requires explicit type sig, but works!
11:21:01 <shapr> applicative: Um, 7.0.x
11:21:11 <adimit> applicative: I rm -rf'ed ~/.ghc and ~/.cabal after the upgrade.
11:21:12 <applicative> oh really. hm.
11:21:33 <shapr> adimit: That should have fixed any warnings, unless you have system-wide libs installed as well.
11:21:58 <adimit> shapr: I don't have any system-wide stuff installed :-(
11:22:03 <byorgey> shapr++
11:22:11 <shapr> adimit: I dunno then :-(
11:23:10 <applicative> adimit what happens if you mv .ghc and .cabal to x.ghc and x.cabal  and install acme-php or whatever? you are saying it says things are broken?
11:23:53 <Guest97575> lol @ acme-php
11:24:40 <Peaker> why does ghci let wrong imports go without any error message? (But with lack of change in prompt)
11:25:27 <adimit> applicative: sorry, had the phone ring. So I just removed ~/.ghc, but should I also rm ~/.cabal? That'd require me to reintsall haskell-platform to get cabal-install back.
11:26:04 <illissius> I have a new appreciation for people who read GHC's Core output. It's totally and utterly unpenetrable.
11:26:10 <applicative> adimit, I was thinking of just hiding it, for an experiment.  But no you should have got cabal with ghc from your package manager
11:26:40 <adimit> applicative: I installed ghc from the binary that is on the ghc web page.
11:26:42 <silver> Peaker, it was fixed in 7.4.2 AFAIR
11:26:46 <applicative> adimit: the cabal executable is in /usr/local/bin or wherever  ghc is, unless you did cabal install cabal-install
11:26:47 <adimit> (i.e. locally.)
11:26:50 <Peaker> silver, ah, cool
11:27:38 <shapr> Oh hey! My Raspberry Pi returned yesterday, I can try debian/testing's ghc7.4.1 on armel!
11:27:40 <adimit> yeah, I just found it in my local directory.
11:28:54 <applicative> adimit, so it should survive deleting or renaming the .cabal folder
11:28:58 <applicative> ?
11:29:00 <byorgey> @remember shapr If I were to do this in Python, it would be done by now. and it would be full of bugs.
11:29:00 <lambdabot> It is stored.
11:29:01 <adimit> yeah, I removed everything now.
11:29:23 <applicative> cabal will now make a new .cabal and .ghc if you install something
11:29:30 <shapr> byorgey: ha
11:30:18 <applicative> adimit, just wondering, what os are you using?
11:30:29 <silver> debian stable
11:30:39 <newsham> I have a local "foo.cabal" file and I cant "cabal configure" because it has missing dependencies.  how do I tell cabal to download, build and install all the deps and then build the local cabal ?
11:30:57 <hpaste> adimit pasted “cabal.” at http://hpaste.org/70580
11:30:58 <adimit> well, first I gotta run cabal update. So I run this: cabal update && cabal install cabal-install; then I get the above output
11:31:07 <adimit> applicative: I run Debian linux
11:31:27 <adimit> (that's on a clean ~/.cabal and ~/.ghc directory.)
11:31:49 <applicative> adimit: what  does ghc-pkg list print?
11:32:17 <hpaste> adimit pasted “ghc-pkg list” at http://hpaste.org/70581
11:32:22 <adimit> applicative: ^^
11:32:45 <adimit> ($HOME/local/haskell) is the ./configure --prefix for both ghc and haskell-platform on my system.
11:33:13 <applicative> adimit: wait, why are you installing cabal-install?
11:33:26 <newsham> ahh "cabal install foo.cabal" is doing the right thing
11:33:42 <adimit> applicative: to update it, no?
11:33:58 <applicative> adimit: yes I do this with my copy of ghc-head.
11:34:09 <applicative> adimit  what does cabal --version say
11:34:51 <applicative> adimit, I think you are trying to install an older cabal than the one you have
11:34:54 <adimit> cabal-install version 0.14.0; using version 1.14.0 of the Cabal library. This is *before* updating it (i.e. I haven't used the --force-reinstalls on this prefix yet.
11:35:08 <applicative> you are backdating it, don't do it
11:35:24 <adimit> applicative: yes, that is true, I just did cabal list cabal-install.
11:35:43 <applicative> it was installing an earlier cabal, to avoid a catastrophe that is the mirror of the one you were about to make  :)
11:35:44 <adimit> it seems that the one on hackage is older than the one distributed in the newest haskell-platform.
11:35:48 <applicative> yes
11:36:11 <adimit> curious. I just assumed that couldn't be the case. Well, I hope that was the root of the matter. Thanks applicative!
11:36:19 <applicative> adimit really you should stick with the cabal exec you get with the platform associated with your ghc
11:36:56 <adimit> applicative: I didn't know that. I just naturally assumed I'd get a better cabal when I check out the one from the "central repository" Hackage.
11:38:23 <applicative> adimit the new one, which you have, needs to be requested explicitly by version number
11:39:17 <applicative> adimit: but by the way, was it easy to install ghc with the binary thing on the ghc site?  I was trying to help someone build pandocwho has ghc6 on an old ubuntu
11:39:19 <adimit> applicative: interesting. Though if everything works now, I'll stick to "never change a winning team," I guess.
11:39:27 <adimit> applicative: it's super-easy.
11:39:45 <adimit> you just download it, ./configure --prefix=/some/path and make install.
11:39:50 <applicative> do you just do configure --prefix
11:39:51 <adimit> Then you do the same with haskell platform.
11:39:53 <applicative> hah yes
11:40:26 <applicative> hm maybe I will advise him to do it.
11:40:26 <adimit> I've even done it on remote servers where I didn't have access to the package manager. Though one needs to be careful with the libgmp2 linkage.
11:41:04 <Palmik> Hi guys, would code like this http://hpaste.org/70582 be safe? That is, am I guaranteed that the someAction is truly only invoked if the mvfoo is empty and that it will be empty after I run someAction?
11:41:25 <applicative> adimit: so he should make sure he has libgmp2 for example?
11:41:53 <adimit> applicative: he should make sure he's got the *right* libgmp2, because I think that the current debian stable (or the last debian stable? dunno) ships with one that is too old.
11:42:26 <monochrom> no, Palmik, another thread could do putMVar in-between
11:43:08 <Palmik> monochrom, that's what I feared, do you know of some nice way to achieve the described goal?
11:43:14 <savask> Hello, again. Can errors "leak" through handle, if IO code is lazy?
11:43:34 <applicative> oh, he's on some 2 yr old ubuntu hm.  monochrom mentions gmp	libgmp3-dev	gmp.h
11:43:38 <applicative> oh here is monochrom
11:44:46 <monochrom> I don't know debian. but ubuntu has been with libgmp3-dev for a long time
11:45:02 <adimit> applicative: here's one more question though: I now try to install cabal-dev, which gives me similar errors. How do I fix that?
11:45:29 <applicative> what version of cabal-dev is it building
11:45:51 <adimit> monochrom: that's not the problem. It's there in older debians, but the linking breaks, because it's not the right version.
11:46:32 <adimit> applicative: 0.9.1
11:48:03 <apfelmus> @seen ekmett
11:48:04 <lambdabot> Unknown command, try @list
11:49:15 <applicative> adimit see the github one, seems not to be on hackage https://github.com/creswick/cabal-dev
11:49:31 <adimit> applicative: yup, on it. Had another telephone ring. poo.
11:49:40 <applicative> adimit: the only recent seems to be to the .cabal file addressing this
11:49:49 <applicative> the only recent change rahter
11:50:35 <adimit> welp, the git version does install.
11:50:41 <adimit> (without complaining)
11:52:23 <nalssi> applicative: I'm sorry but I'm the one who asked about the failure of cabal install...the thing  is.. I have no idea what exactly to type in for remote-repo.
11:57:46 <byorgey> apfelmus: he goes by edwardk
11:57:58 <edwardk> oh heya
11:58:05 <apfelmus> byorgey: oh, thanks!
11:58:07 <edwardk> apfelmus: sorry, i need to call you =)
11:58:14 <apfelmus> edwardk: hehe
11:58:20 <edwardk> been having a problem with the wireless and my laptop
11:58:30 <edwardk> so skype may suck right now =/
12:01:32 <stepkut> Is GHC working on Android based ARM systems yet? I know ARM support works
12:01:47 <silver> oh really?
12:01:53 <silver> how do you know
12:02:13 <silver> I was wondering about GHC on android too recently
12:03:03 <silver> http://packages.gentoo.org/package/dev-lang/ghc
12:03:06 <silver> no arm here :(
12:03:25 <newsham> my "ghc-pkg check" reports several broken packages.
12:03:28 <newsham> what do I do to purge them?
12:03:38 <stepkut> newsham: ghc-pkg unregister
12:03:59 <stepkut> newsham: though that does not purge the related binaries (.o, .hi, etc) from the disk
12:05:55 <newsham> stepkut: so whats the proper way?
12:06:25 <newsham> one of the reported packages whas ghc-7.0.4
12:06:32 <newsham> which is the version of ghc i'm using.
12:06:38 <newsham> that doesnt sound good
12:07:10 <newsham> i unregistered it, i wonder if anything bad will happen
12:08:50 <cwraith> newsham: try running ghci.  find out!
12:09:07 <newsham> ghci works fine
12:09:14 <newsham> i should prob update ghc anyway
12:09:15 <c_wraith> oh, running it won't matter, since it's not dynamically linked
12:09:31 <jfischoff> stepkut: I know ipwn is working on an android cross compiler
12:10:04 <jfischoff> I think one issue is GHC doesn't support cross compilation in general
12:10:15 <stepkut> newsham: unregister is the proper way.. it just doesn't delete the files. 'tis a short-coming of cabal etc
12:10:16 <jfischoff> so you can build arm on arm but not otherwise
12:21:58 <newsham> cabal dependency hell
12:25:09 <newsham> so i have a cabal file i wrote 1 or 2 yrs ago,  it has dependencies in it that mention specific versions.  when i run cabal install on it, it cant find suitable dependencies for some of the libs
12:25:25 <newsham> i thought this is what the version constraints were supposed to prevent?
12:26:30 <jfischoff> the libraries you depend on most likely did not follow that practice
12:26:37 <hpaste> applicative pasted “factisresearch db” at http://hpaste.org/70587
12:26:42 <applicative> nalssi: lines 28 - 9 of my ~/.cabal/conf look so ^^^
12:27:19 <ksf> what's a functor (Foo a -> Foo b) -> (Bar a -> Bar b) -> Baz a -> Baz b called?
12:27:20 <newsham> most of them are pretty prominent packages.
12:27:26 <ksf> ...where Foo and Bar are type functions.
12:27:50 <ksf> it's a bifunctor, but unlike normal bifunctors you can't apply only one of the two functions, you always need both.
12:28:08 <ksf> (because Baz uses Foo and Bar in its definition)
12:28:10 <jfischoff> which tend not to use strict versions...
12:28:41 <newsham> *sigh* i even removed all the version constraints and it still cant find matches
12:28:44 <newsham> wtf
12:29:21 <jfischoff> are you cleaning everything?
12:29:36 <newsham> no
12:29:38 <newsham> how do i do that?
12:29:45 <jfischoff> cabal clean?
12:30:01 <applicative> newsham: maybe you should try it in some environment like cabaldev
12:30:57 <applicative> oh i see, yes, cabal clean between attempts
12:31:33 <dmwit> ksf: It's a functor with a different source category than Hask
12:31:56 <dmwit> namely, the source category has Haskell types as objects and (Foo a -> Foo b, Bar a -> Bar b) function pairs as arrows.
12:32:27 <newsham> there's nothing to clean in this dir
12:32:47 <jrw> ksf, reminds me of (***)
12:32:59 <ksf> are you saying that I should implement a category for my data families?
12:33:00 <newsham> i'm gonna just manually install the main deps and try to write a new cabal file for the project
12:33:09 <ksf> jrw, it's actually three parameters.
12:33:13 <ksf> well, up to three.
12:33:25 <dmwit> newsham: That is quite odd. Perhaps it never built...?
12:33:38 <newsham> it built just fine.  i used to build it many times a day
12:33:44 <dmwit> unf unf
12:33:59 <newsham> with an older ghc
12:34:07 <newsham> in jan 2011
12:34:12 <dmwit> Is it also depending on a specific version of base?
12:34:14 * applicative isn't surprised at all
12:34:23 <dmwit> If so, that would explain why you can't install it.
12:34:34 <dmwit> If not, that would also explain why you can't install it.
12:34:36 <newsham> i took off the base constraint
12:34:42 <applicative> or if it has a dependency that hasn't been kept up
12:34:46 <newsham> but it did originally have a constraint listed
12:34:48 <jfischoff> you mean the version right?
12:34:51 <dmwit> Right, but it's possible some of the other dependencies depended on your old base.
12:34:54 <newsham>     base >= 4,
12:34:55 <dmwit> You see what I'm saying?
12:34:59 <jfischoff> yeah
12:35:05 <dmwit> Since you're depending on specific versions of those...
12:35:49 <newsham> so i should have avoided depending on a specific version of base, and i should have definitely not done that?
12:35:52 <newsham> to avoid this problem?
12:35:53 <applicative> newsham: are you sure all the deps have been maintained?
12:35:55 <newsham> *throws hands in air*
12:36:22 <applicative> what is the dependency list?
12:36:23 <dmwit> newsham: No, you should have depended on a specific version of base, and then REALIZED what that meant when you upgraded GHC.
12:36:40 <dmwit> newsham: That means, if you still want to build it, you must use the same version of base: the same version of GHC.
12:36:50 <dmwit> Otherwise, it's up to you to work out how to properly relax the constraints.
12:37:01 <applicative> newsham: there is also the possibility that something in your local setup is interfering with cabal-install's reasoning  ....
12:37:03 <dmwit> It's not cabal's fault that you don't have the right version of base installed to build that package.
12:37:03 <jfischoff> dmwit: can you not use an old version of base with a new version of ghc?
12:37:08 <dmwit> jfischoff: Correct.
12:37:12 <thoughtpolice> jfischoff: you can't
12:37:18 <thoughtpolice> base is very, very closely tied to GHC itself
12:37:23 <newsham> nothing in my code should be specific to a version of base.
12:37:25 <thoughtpolice> they're basically in lockstep for all practical purposes
12:37:30 <thoughtpolice> (internally speaking)
12:37:34 <dmwit> newsham: irrelevant
12:37:49 <newsham> this is unproductive..
12:37:52 <dmwit> newsham: Because you didn't write all the code you're using.
12:37:56 <applicative> yes
12:38:15 <applicative> base is irrelevant unless you are using an old ghc
12:38:38 <dmwit> It's productive if you're learning what depending on specific versions of libraries really means. =)
12:39:15 <dmwit> It means depending on specific versions of libraries, and in the case of "base" and a handful of other libraries, that also means depending on a specific version of GHC.
12:39:22 <applicative> my impression was that newsham knows this, but is irritated at the moment
12:40:15 <jfischoff> What I have done at work, which I would like others thoughts on, is to have all libraries (outside of base) that my product depends on, checked as source with specific version attached, and I use cabal-dev and add-source to ensure that the right version is used.
12:40:15 <dmwit> Alright. My impression was that he was actually baffled that a cabal file could build with precise constraints at one time and not another (which baffled me at first, too, until I realized).
12:40:33 <jfischoff> this stuff is new to me, and I am not clear on what the right way to ensure reliable builds is
12:40:40 <applicative> newsham: can  you paste the dependency list?
12:41:21 <applicative> jfischoff: it sounds like you a sensible method
12:41:43 <jfischoff> okay, so I guess the next step would be to automate it
12:41:49 <jfischoff> if that is the preferred method
12:42:14 <jfischoff> because it was a bitch to setup
12:42:20 <newsham> app: i'm just starting over with a new .cabal file and manually installing dependencies one by one
12:42:31 <newsham> prob some of the deps in the old file were false
12:42:43 <newsham> i think the old file was autogenerated by some tool.. i dont remember which
12:44:03 * hackagebot family-tree 0.1.2 - Family trees with lenses  http://hackage.haskell.org/package/family-tree-0.1.2 (NathanVanDoorn)
12:44:04 <newsham> at least this way if something goes worng i'll know which dep is to blame
12:44:39 <Taneb> family-tree: now with actual documentation
12:45:54 <newsham> I love haskell, but building old code in haskell is like installing an ISA card in an old PC or trying to get the right .dll to load in win95.
12:46:03 * ksf thinks he just reached another level of haskell-foo
12:46:19 <ksf> dmwit, you're right, Control.Categorical.Functor is the solution.
12:46:22 <EvanR> lol haskell foo
12:46:34 <Taneb> I've just reached another level of generic-code-foo; I've successfully written comments
12:46:48 <Peaker> Yay, fixed my performance problems
12:47:06 <Taneb> (not a thing I'm best at: if I can't understand my code, I generally find it better to completely rewrite)
12:47:19 <ksf> that's a very good approach.
12:47:35 <EvanR> yeah, better not comment ;)
12:47:42 <EvanR> that way youll rewrite it
12:47:58 <Taneb> But I've written the documentation for Data.FamilyTree now
12:48:03 <Taneb> Terse as it may be, it's a lot for me
12:49:10 <Peaker> Sometimes rewriting code is easier than comprehending it :)  If you have a good architecture then your components have clear external interfaces, so are easy to rewrite
12:49:10 <mroman> I'm tempted to create Beamjoust :)
12:49:15 <mroman> oh
12:49:18 <mroman> wrong channel.
12:49:39 <Taneb> It's confusing because I'm everywhere
12:49:49 <Taneb> Talking about the same thing
12:50:18 <dmwit> Booo, one ID type for three different kinds of IDs.
12:51:05 <Taneb> dmwit, that's... a fair point
12:52:03 <Taneb> Creating a family tree application has been my goal ever since I started programming
12:52:35 <mroman> but...?
12:52:47 <Taneb> Looking at older, unreleased versions are funny in an "oh god I can't believe I was so stupid. That was only four months ago"
12:53:12 <EvanR> have you seen the open source software 'gramps'
12:53:12 <jfischoff> I'm scared to look my old code :(
12:53:28 <EvanR> for family treets
12:53:30 <EvanR> trees
12:53:38 <Taneb> EvanR, I unfortunately greatly prefer the proprietary Family Tree Maker
12:53:54 <EvanR> in either case you really want to go through the pain of writing a program like that yourself?
12:54:09 <Taneb> a) it'll help me learn the language
12:54:14 <Taneb> b) I get exactly what I want
12:54:19 <Taneb> c) it's fun
12:54:23 <Taneb> d) yes
12:54:37 <EvanR> complex gui program to manage complex database data, yeah
12:54:42 <EvanR> FUN
12:54:50 <Taneb> I play dwarf fortress.
12:54:53 <Taneb> Yes it is.
12:54:55 <EvanR> you play it
12:54:56 <dmwit> Oh, don't go poo-poo'ing other people's fun.
12:55:18 <applicative> wasn't there a post on  r/haskell or wherever in the last week about using haskell in production; it mentioned e.g. the need for something like the ruby gem.lock file.
12:55:21 <dmwit> I think the library looks darn neat.
12:55:22 <ksf> dwarven computing just got revolutionised by minecarts, btw.
12:55:24 <EvanR> just saying microsoft cant even handle this sort of application
12:55:43 <mroman> Ironycally my dream when I started programming was to create a better programming language as the one I'm currently using ;)
12:55:44 <applicative> i was thinking jfischoff should find the guy.
12:56:00 <Taneb> EvanR, I don't ever imagine mine is going to be used in any real sense
12:56:17 <mroman> The fact that I'm now at haskell shines a very bright light on it :D
12:56:20 <Taneb> It's just fun, educational, and I learn I don't create arbitrary graphs with lists of IORefs
12:56:29 <nobdraisentone> Is there some monadic analogue of `until'? Like until' :: (a -> Bool) -> (a -> IO a) -> a -> IO a
12:56:35 <mroman> :t untilM
12:56:36 <lambdabot> Not in scope: `untilM'
12:56:43 <dmwit> ?hackage monad-loops
12:56:44 <lambdabot> http://hackage.haskell.org/package/monad-loops
12:56:45 <mroman> worth a shot :)
12:56:47 <jfischoff> applicative: do have a link?
12:57:01 <EvanR> everyone wants a different kind of untilM
12:57:07 <applicative> jfischoff: thats what i'm looking for.
12:57:07 <EvanR> so write it yourself!
12:58:55 <applicative> jfischoff: maybe it was google+ just a sec
13:00:18 <applicative> jfischoff: here it is http://mwotton.github.com/hs_gbu/
13:00:43 <jfischoff> yeah blackdog (mwotton) showed that to me
13:01:00 <jfischoff> I agree there are problems, but I am not sure what the solution is
13:01:21 <meiji11> I'm curious, does it help to know category theory to use haskell effectively? I feel like I have this conceptual gap preventing me from understanding the various abstractions haskell uses, and how to employ them in an idiomatic way..
13:01:23 <jfischoff> Some way to strictify your packages and packages up the sources?
13:01:37 <Peaker> meiji11, I'm using Haskell effectively, and I don't know any CT
13:02:04 <meiji11> Peaker: ok. I guess my question has more to do with closing a conceptual gap.
13:02:20 <jfischoff> meiji11 what are you struggling with?
13:02:24 <mel-> hi
13:02:27 <Peaker> meiji11, I grasp Applicatives, Monads, Arrows in the sense they're used in the language and not in the CT sense
13:02:38 <meiji11> just a certain conceptual gap.
13:03:14 <meiji11> that's preventing me from seeing how to use things in the 'right' way, I guess. how certain constructs are useful in a broader sense, beyond the context of the few examples I've seen.
13:03:15 <EvanR> meiji11: did you try all these things in the console to see how they work
13:03:25 <meiji11> definitely my biggest hurdle in learning haskell so far..
13:04:00 <meiji11> EvanR: sure. that's helped. I feel like I'm missing out on some bigger picture, though.
13:04:05 <applicative> jfischoff: I see, yes, my advice was going to be , maybe you should talk to blackdog :)
13:04:06 <meiji11> it feels incomplete..
13:04:13 <Peaker> meiji11, I don't think the idiomatic way to use Monad stems from CT.. You catch the idioms from reading code, getting feedback on your code, and writing lots of code
13:04:15 <shapr> meiji11: How so?
13:04:32 <EvanR> meiji11: so the next step is to just write some code (tm)
13:04:34 <Peaker> like all languages, to get good you just code, code, code...
13:04:39 <meiji11> it's hard to explain.. take the Continuation monad. I know about continuation passing style, that part is fine.
13:04:53 <applicative> meiji11: actually, haskell casts a flood of light on elementary category theory...
13:04:57 <EvanR> good luck using continuation monad for anything useful xD
13:05:12 <Peaker> EvanR, It's nice for Python-like generators :)
13:05:15 <meiji11> in the context of how one would use or think about a monad, though.. that should imply a strict implementaton of CPS as a monad, no?
13:05:19 <Peaker> EvanR, and for Bracket composition
13:05:28 <edwardk> preflex: xseen luite
13:05:29 <preflex>  luite was last seen on freenode/#haskell-blah 21 hours and 23 minutes ago, saying: oh ok, i think the problem wasn't related to the ghc version
13:05:37 <applicative> meiji11: the continuation monad is a total nightmare; except for certain people with twisted minds
13:05:40 <meiji11> as in, there's only one right way of doing it..
13:05:51 <jfischoff> meiji11: I am going to say the same thing that Peaker EvanR said. After many times using concrete examples, you will understand the shared pattern
13:06:01 <meiji11> haha, yeah, the article said as much. this is just one example, though.
13:06:04 <meiji11> the State monad, say..
13:06:15 <meiji11> I have the same basic concern.
13:07:07 <applicative> meiji11: I think our friends are right.  If you use them you will comprehend them.  I remember think 'monad transformers' were hopelessly fancy, forget it, etc.
13:07:16 <applicative> Then  I used one.
13:07:32 <EvanR> i still dont like transformers :(
13:07:42 * applicative cant get enough lifts
13:07:55 <meiji11> I see. I guess there's no need to axiomatize everything, then.
13:07:56 * EvanR lifts applicative's monads
13:07:59 <meiji11> I'm a math guy, it's what I do..
13:09:14 <applicative> meiji11: good, i think  that just means you will quickly come to a better comprehension than many of us have, but you still can't avoid the necessity of finding the abstraction in practice
13:09:29 <ksf>         k f = fmap (bimap (fmap f) ((fmap.fmap) f))   ಠ_ಠ
13:09:32 <Peaker> EvanR, If you want two kinds of effects in the same computation, what do you do?
13:09:44 <nand`> I looked at continuations twice in my life. Both times I went on to absolutely never use them and consequently have forgotten everything about them. Their use cases must be very remote from what I do all day
13:09:49 <Peaker> ksf, Perfectly readable to me :)
13:10:12 <EvanR> Peaker: write your own monad!
13:10:27 <Peaker> EvanR, which re-uses existing monads or duplicates them?
13:10:27 <EvanR> because the transformer version is too hairy
13:10:35 <Peaker> EvanR, what's "hairy" in this context?
13:11:23 <EvanR> i just end up feeling like im getting too deep in more complex semantics, language extensions, etc
13:11:48 <Peaker> (Functor f, Bifunctor g, Functor h, Functor i, Functor j) => (a -> b) -> f (g (h a) (i (j a))) -> f (g (h b) (i (j b)))
13:11:53 <EvanR> like i cant identify any code that is not complicated anymore, when you use a library theres supposed to be some code somewhere that is simplified
13:12:02 <Peaker> EvanR, transformers are H98, aren't they?
13:12:17 <EvanR> are they?
13:12:23 <applicative> monad transformers are haskell98
13:12:32 <Peaker> I mean most of the transformers package
13:12:38 <EvanR> multiparameter type classes?
13:12:40 <Peaker> mtl uses MPTC that isn't H98
13:12:47 <Peaker> EvanR, tranformers doesn't use that
13:13:02 <EvanR> maybe im thinking of mtl then
13:13:33 <EvanR> i like a subset of haskell that is simple and straight forward
13:13:35 <applicative> mtl is another subject
13:13:44 <EvanR> easy to explain and feel confident to recommend
13:14:24 <EvanR> i dont want to be like the one guy in the last five years who can accurately explain c++ semantics
13:14:27 <Peaker> EvanR, class MonadTrans t where lift :: Monad m => m a -> t m a   is not really hard :P
13:14:43 <nand`> Reinventing the wheel a bunch of times instead of using a complicated wheel-building-factory is nice and simple too
13:15:16 <EvanR> the fact that its technically reusable doesnt mean its a good idea or warm and fuzzy in practice
13:15:19 <Peaker> EvanR, t :: (* -> *) -> (* -> *)      where "t" combines effects of the input monad (which are "lift"ed) with its own effects... that's mostly all there is to it
13:15:24 <tac-tics> nand`: I'm going to build a factory that bulds wheel-building factories.
13:15:38 <EvanR> i mean OOP loves to describe itself as making code more reusable, when thats a red herring
13:15:40 <Peaker> EvanR, I use transformers all the time, I don't find them complicated...
13:16:14 <Peaker> I don't use mtl though
13:16:16 <nand`> tac-tics: Java must be the right tool for the job; on a more serious note, it's always a trade-off: complexity vs redundancy
13:17:14 <EvanR> Peaker: im finding it more often less of a good idea to use monads at all
13:17:16 <Peaker> If you have some monadic computation and you want to add some state-passing into it, you just throw a (`runStateT` initState) on the top, and "lift"s on the effects you have, and bam, you get the threaded state
13:17:38 <EvanR> yes i know
13:18:23 <Peaker> EvanR, if you don't need the power of monads, then sure don't use them.. But if your computation is naturally monadic, you don't have much alternatives
13:18:54 <nand`> the only time I explicitly avoid monads and other generalizations is when the newtype wrapping/unwrapping is more costly than the benefit
13:19:24 <EvanR> when its at the point where im talking about 'a computation' rather than a whole application, then often times the whole monad thing isnt worth it
13:19:37 <Taneb> .seen elliott
13:19:38 <EvanR> or it takes up so little room i can just use a where
13:19:46 <Taneb> preflex: seen elliott
13:19:46 <preflex>  elliott was last seen on #haskell 15 days, 19 hours, 53 minutes and 15 seconds ago, saying: teneen: That doesn't really clarify to me.
13:20:30 <EvanR> then if it takes up a whole application, i probably want a totally different monad or one thats a huge wrapper around State
13:21:58 <EvanR> and im convinced any GUI or game is going to need something like FRP, both the imperative and basic functional stuff is just not dignified
13:22:06 <EvanR> monads or not
13:25:34 <Peaker> EvanR, I'm working on a GUI application, and I don't use FRP
13:25:50 <hiptobecubic> \
13:25:55 <EvanR> its interative?
13:25:57 <Peaker> EvanR, And for a computation, you're sometimes forced to use a monad (e.g: IO or ST)
13:26:03 <Peaker> EvanR, yeah, it's interactive
13:26:08 * hiptobecubic wanders away..
13:26:10 <EvanR> main and IO is different
13:26:23 <EvanR> you do whatever it takes to get out of IO if possible
13:27:02 <Peaker> EvanR, The GUI is mostly functional (Functor, Applicative are involved, not Monads). But the use of the GUI is in a "Transaction" monad that can read/write to a key/value store
13:27:20 <Peaker> EvanR, a very tiny part of the whole thing is in IO
13:28:09 <EvanR> read/write in response to events?
13:28:20 <EvanR> and writes can trigger events?
13:30:35 <MostAwesomeDude> So, maybe there's better luck during the day... Is there a pretty-printing relative of Show?
13:31:15 <byorgey> MostAwesomeDude: not a standard one
13:31:41 <EvanR> put all your data in Data.Data ;)
13:31:42 <MostAwesomeDude> byorgey: Non-standard would be fine if it's de facto.
13:32:08 <byorgey> Not even a de facto standard, at least not that I'm aware of
13:32:21 <Peaker> EvanR, widgets have event maps that map to any applicative.  that applicative is Transaction.. the main wrapper does a "runTransaction" on it to convert it to IO, and then the mainloop executed a Widget IO
13:32:27 <crdueck> could someone correct this instance declaration for me? i know the signature is all wrong, but its just to show what i'm trying to do: http://sprunge.us/dZFZ
13:33:06 <mroman> :t <
13:33:08 <Peaker> EvanR, so the majority of the program is in an "OTransaction" monad and it generates UI widgets that are in the ITransaction monad  (OTransactions are read-only, and have access to a reader of font,style,etc)
13:33:08 <lambdabot> parse error on input `<'
13:33:16 <mroman> :t (<)
13:33:18 <lambdabot> forall a. (Ord a) => a -> a -> Bool
13:33:24 <Peaker> the widgets generate ITransactions (read/write transactions that are responses to UI events)
13:33:40 <mroman> :t (<=)
13:33:42 <lambdabot> forall a. (Ord a) => a -> a -> Bool
13:35:23 <EvanR> Peaker: id like to understand this more
13:35:28 <mroman> crdueck: What's not correct about it?
13:38:00 <mroman> oh. I see.
13:38:23 <crdueck> mroman: i dont know how to declare an instance declaration for a newtype, i get a non type-variable argument in the constraint Ord(Point)
13:38:23 <mroman> instance (Ord Point) => Ord (Point) makes no sense.
13:38:36 <crdueck> i know its incorrect, i was just trying to convey intent
13:38:42 <mroman> instance (Num Point) => Ord (Point) should work
13:38:52 <mroman> if you provide an instance Num (Point)
13:39:21 <nand`> what sort of semantics is compare :: Point -> Point -> Ordering supposed to have?
13:39:36 <shapr> :t compare
13:39:37 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
13:39:41 <shapr> :i Ordering
13:39:45 <shapr> :-|
13:39:47 <shapr> @info Ordering
13:39:47 <lambdabot> Ordering
13:39:52 <shapr> oh c'mon!
13:39:55 <shapr> :t LT
13:39:56 <lambdabot> Ordering
13:39:59 <shapr> psh
13:40:01 <mroman> crdueck: http://codepad.org/DAlzJUD8
13:40:03 <mroman> like that.
13:40:56 <nand`> mroman: that instance still won't work properly; comparison is ⊥
13:41:39 <mroman> nand`: I can't follow that?
13:41:45 <mroman> Because < is not defined?
13:42:23 <nand`> mroman: (<) is defaulted in terms of (<=)
13:42:28 <crdueck> nand`: compare should return LT if the cross product < 0, EQ if cross product == 0, and GT if cross product > 0
13:42:42 <crdueck> s/0/(0,0,0)
13:42:54 <nand`> crdueck: that's a recursive definition
13:43:09 <mroman> where a <= b = vCross a b < 0 is recursive?
13:43:33 <nand`> vCross a b returns a vector, and 0 is (0,0,0). so you're again comparing two vectors, which again uses <=
13:43:43 <nand`> s/vector/Point/
13:43:55 <mroman> then it would not return False
13:44:06 <nand`> it would never return anything at all is what I'm getting at
13:44:08 <crdueck> okay, is there a way to do what i'm trying to do?
13:44:12 <mroman> nand`: But it does
13:44:16 <mroman> at least on codepad hugs
13:44:46 <nand`> hmm
13:44:49 <nand`> wait, now I'm confused
13:45:09 <mroman> Is there a default (<)?
13:45:14 <mroman> if no (<) is provided?
13:45:25 <mroman> which would compare (Rational, Rational, Rational) ?
13:45:52 <mroman> :i (<)
13:45:59 <mroman> @info (<)
13:46:00 <lambdabot> (<)
13:46:21 <mroman> http://codepad.org/gWyc4e1R
13:46:29 <mroman> if you define (<) in the instance it is used
13:47:12 <EvanR> mroman:
13:47:16 <twanvl> you only need to defined (<=) or compare, the rest of the functions in Ord have defaults
13:47:18 <EvanR> > (1,2,3) < (3,2,1)
13:47:22 <lambdabot>   True
13:48:20 <nand`> hmm
13:48:42 <nand`> I think the additional logic in (<) vs (<=) is what makes it terminate
13:51:06 <nand`> the instance seems flawed though: a < b == True but b > a == False; with a = (1,2,3) and b = (4,5,6)
13:51:15 <nand`> compare seems to always be ‘GT’ or ‘EQ’
13:52:08 <MostAwesomeDude> nand`: Cannot reproduce; works fine for me.
13:53:53 <nand`> MostAwesomeDude: https://paste.lugons.org/show/vr03oSSQzZkT46hDmA2F/
13:54:10 <nand`> note I needed -XFlexibleInstances, -XFlexibleContexts and -XUndecidableInstances because of an error in line 7 (the constraint shouldn't be there)
13:55:52 <Peaker> EvanR, This is the core of the UI: https://github.com/Peaker/bottle/blob/master/bottlelib/Graphics/UI/Bottle/Widget.hs
14:00:10 <MostAwesomeDude> nand`: http://pastebin.osuosl.org/39041
14:00:16 <newsham> is there anything like this in a std lib?
14:00:17 <newsham> whileM_ :: (Monad m) => m Bool -> m ()
14:00:17 <newsham> whileM_ a = a >>= (\b -> when b $ whileM_ a)
14:00:17 <MostAwesomeDude> nand`: So your Point has issues.
14:00:30 <Peaker> EvanR, A Widget is (isFocused :: Bool, requested size range, size -> (how to enter/focus, what to draw, event map, ...))
14:00:38 <zzing> If I wanted to make a utility that had menus such as pine or alpine (eg. http://en.wikipedia.org/wiki/File:PineScreenShot.png ), would 'vty' be an appropriate library to use? The application can be expected to be used remotely over ssh and on a freebsd terminal.
14:00:41 <Peaker> EvanR, note the distinct lack of monads/IO in there
14:00:50 <Peaker> zzing, yeah
14:00:59 <Peaker> zzing, vty is pretty good IMO
14:01:15 <zzing> I shall go ahead an attempt its use then
14:01:21 <Peaker> (I wrapped its picture type in my own to support overlapping images, if you might need that)
14:01:30 <zzing> picture type?
14:01:37 <zzing> It supports displaying of images?
14:01:55 <Peaker> zzing, no, it has a type that describes the character setup on screen
14:02:26 <Peaker> zzing, you don't say: "goto (5,6) ; print "hi" "   you compose pictures together to form larger pictures and eventually it draws the composed picture
14:02:44 <zzing> hmm
14:02:44 <parcs`> there's also vty-ui
14:02:54 <MostAwesomeDude> newsham: Not AFAIK.
14:03:22 <newsham> danke
14:03:30 <EvanR> Peaker: reading
14:04:09 <EvanR> Peaker: looks normal, but its not demonstrating how the application is written with it
14:04:46 <Peaker> vty-ui seems to be all in IO
14:04:49 <zzing> Peaker, I like the idea of composing things together at least :P
14:05:01 <Peaker> EvanR, it's just the base widget type
14:05:04 <nobdraisentone> How can I run IO a action N times and get list of N relusts?
14:05:13 <shachaf> @ty replicateM
14:05:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
14:05:22 <Peaker> EvanR, you compose widgets with grids/boxes and other widget combinators
14:05:24 <EvanR> Peaker: right so it makes sense that theres no IO
14:05:47 <Peaker> EvanR, there's MainLoop.hs in there which is the point where most of the IO is at
14:06:10 <Peaker> (The application Main.hs and MainLoop.hs have almost all the IO)
14:06:32 <EvanR> Peaker: is this a gui lib or a gui app
14:06:47 <Peaker> EvanR, both
14:07:19 <Peaker> https://github.com/Peaker/bottle/tree/master/bottlelib <-- the libs part..    https://github.com/Peaker/bottle/tree/master/codeedit <--- the app
14:07:29 <EvanR> composing graphics makes sense, but what about the interactive stuff
14:08:34 <Peaker> EvanR, the EventMap in the widget is a map from input events to actions in some functor/applicative (as far as the Widget is concerned)
14:08:47 <Peaker> EvanR, the application actually puts Transaction actions in the EventMap
14:09:15 <Peaker> EvanR, and the Main converts the EventMap actions to be IO actions. Then the MainLoop takes a Widget with IO actions in the EventMap and executes them interactively
14:09:25 <zzing> Does haskell have any triplestore database library? I haven't found yet, just curious.
14:09:29 <EvanR> Peaker: ok
14:09:41 <EvanR> triplestore?
14:09:53 <Peaker> EvanR, it's nice because the application can display the EventMap to the user at all times, exposing the actual input handlers
14:10:07 <Peaker> EvanR, rather than having separate documentation that may go out of date
14:10:24 <zzing> http://en.wikipedia.org/wiki/Triplestore   A triplestore is a purpose-built database for the storage and retrieval of triples,[1] a triple being a data entity composed of subject-predicate-object, like "Bob is 35" or "Bob knows Fred".
14:10:51 <EvanR> interesting
14:11:10 <Peaker> EvanR, and it does.. you can run bottle and see it, it's pretty cool :)
14:11:24 <EvanR> its a text editor?
14:11:24 <zzing> There is a library for C, but I would be very interested in considering making a haskell implementation.
14:11:47 <EvanR> what does it use for actual graphical output, gtk?
14:11:48 <zzing> I was thinking the predicate could store datatypes for the object entry, so that every relation is typesafe
14:12:14 <EvanR> typesafe english?
14:12:34 <EvanR> Windows is awesome  TYPE ERROR!!!!
14:13:29 <zzing> EvanR, not quite, imagine 'Bob' hasAge: 35  where hasAge is defined for the triplestore as int, so 'Jerry' hasAge: 'Tilbury'  would be a type error and would never be allowed to in the database
14:13:36 <Peaker> EvanR, it's a structural editor
14:13:40 <Peaker> EvanR, it uses OpenGL
14:13:45 <nobdraisentone> shachaf: thanks
14:13:45 <EvanR> oh?
14:13:49 <Peaker> EvanR, Gtk/etc really suck, IMO
14:13:51 <EvanR> what structure
14:14:01 <EvanR> yeah i was thinking of using just opengl from now on
14:14:02 <Peaker> EvanR, A functional language (eventually Haskell or Agda)
14:14:13 <EvanR> how do you get input events though
14:14:19 <Peaker> from GLFW-b
14:14:29 <Peaker> EvanR, for now it's just a slight System F variant
14:14:46 <EvanR> does it work on mac?
14:15:01 <Peaker> EvanR, yeah
14:15:12 <Peaker> EvanR, building it is a bit of a bitch, because of BerkeleyDB
14:15:31 <EvanR> zzing: age is not a great piece of data... since it changes with time ;)
14:15:43 <Peaker> EvanR, need to install the C library of bdb 4.7 or 4.8 and not newer
14:15:48 <EvanR> urg
14:16:00 <zzing> EvanR: good for properties though in general :h
14:18:09 <Peaker> EvanR, it's preliminary but the interactive UI already shows lots of promise.. much nicer than Gtk/wx/qt :)
14:19:08 <EvanR> nice
14:19:36 <EvanR> Peaker: cairo would be nice
14:21:35 <Peaker> EvanR, is cairo not just a canvas?
14:21:43 <Peaker> EvanR, what's the advantage over OpenGL?
14:21:59 <EvanR> not literally cairo, but the drawing api
14:22:05 <Peaker> I suspect best drawing performance is to be had with OpenGL?
14:22:17 <EvanR> opengl is lower level for graphical description
14:22:33 <EvanR> not talking about performance just graphics drawing api
14:23:53 <EvanR> pango would be good for text layout
14:24:10 <RichyB> OpenGL exposes an API (particularly OpenGL 3.1 core) that maps pretty closely to what the underlying GPU does. It's very low-level as a result.
14:25:04 <EvanR> i agree opengl is a better platform, but, especially gl3, not that nice for end result graphic description
14:25:07 <Peaker> EvanR, well, graphics-drawingcombinators gives a nice high-level API over OpenGL
14:25:08 <EvanR> cairo is like postscript
14:25:25 <Peaker> and it's very tiny
14:25:28 <EvanR> i need to review drawing combinators
14:25:33 <Peaker> I don't need the fancy 3d stuff
14:25:39 <EvanR> yeah im just talking about 2d
14:25:56 <zzing> The FreeBSD console is not UTF8 aware, and sometimes I might need to be physically there. Is there any reason to think that this will not be a problem for vty?
14:25:56 <RichyB> Whereas libraries like Cairo and Pango are geared towards being convenient for writing applications with. :)
14:26:02 <Peaker> drawing combinators just has basic shapes, affine transforms (rotate, translate, scale), composition, color tinting
14:26:07 <Peaker> (and text)
14:26:16 <Peaker> so pretty trivial to use
14:26:22 <EvanR> yeah
14:26:48 <EvanR> i only even need rectangles and line segments
14:26:50 <EvanR> ever*
14:26:53 <Peaker> Draw.clearRender . Draw.tint (Draw.Color 1 0 0 1) $ Draw.scale 0.2 0.2 %% Draw.circle
14:27:05 <Peaker> Red circle with 1/5 diameter of screen
14:27:15 <Peaker> (drawn to GL color buffer)
14:27:59 <Peaker> So your main loop just needs to do a gl buffer swap around clearRender calls -- and you just mappend your shapes together. Very easy to use
14:28:34 <EvanR> sounds good
14:28:46 <Peaker> It doesn't do cropping though, GL really sucks at that
14:29:04 <EvanR> well painters algorithm takes care of that
14:29:09 <EvanR> back to front
14:29:12 <Peaker> painters?
14:29:16 <EvanR> painter's
14:29:43 <EvanR> you can emulate cropping with higher level paint ;)
14:29:49 <Peaker> you mean, utilize the z-buffer?
14:30:01 <EvanR> no, i would disable depth test
14:30:21 <EvanR> for 2d graphics
14:30:30 <EvanR> anyway what about text?
14:30:34 <Peaker> say you want to crop a rectangular area around a shape
14:30:41 <Peaker> and then you rotate the whole thing
14:30:47 <Peaker> how do you GL draw it?
14:31:19 <EvanR> doing that by itself would require a higher level thing
14:31:28 <Peaker> what do you mean?
14:31:41 <EvanR> but in a gui app you often can crop naturally by overdrawing the rest of the gui thats supposed to be on top
14:32:10 <Peaker> but the overdrawn gui is partially transparent
14:33:00 <EvanR> then i dont understand the goal
14:33:00 <Peaker> I think this kind of method can't interact well with transparency in general
14:33:23 <Peaker> the goal is to be able to add a cropping operation to graphics-drawingcombinators, ideally compositionally
14:33:49 <Peaker> it would be nice if you could create an ordinary image that serves as a "mask" for another image, even
14:34:01 <EvanR> there is stencil buffer
14:34:03 <EvanR> but
14:34:06 <Peaker> but all the GL features that allow this kind of stuff are not always available
14:34:11 <Peaker> (e.g: stencil buffer)
14:34:16 <EvanR> just wanting the goal of cropping sounds pointless without a goal
14:34:27 <Peaker> EvanR, imagine you want a "scroller widget"
14:34:37 <EvanR> thats the example i brought up earlier
14:34:46 <Peaker> that shows a small rectangular window view into another image
14:34:59 <EvanR> you dont need cropping for that
14:35:21 <Peaker> you do if you have: A) multiple of these on screen, B) want to support transparency in your drawings
14:36:01 <EvanR> not really
14:36:08 <Peaker> say you draw a whole-screen-sized image in order  to overdraw any of it that's not in (0,0)-(0.2,0,2)  and another such drawing from (0.8,0.8)-(1,1)
14:36:10 <EvanR> and i still dont get what youre saying about transparency
14:36:33 <Peaker> the latter draw operation will draw into the other
14:36:58 <Peaker> and the rest of the screen being drawed may not have an opaque color for every pixel
14:37:21 <EvanR> when you overdraw, just alpha blend like normal
14:37:24 <Peaker> so the "overdraw" doesn't actually cover all the pixels out of the designated zone
14:37:53 <Peaker> but I thought you said you want to overwrite all the pixels that were drawn outside of the designated (0,0)-(0.2,0.2)
14:38:10 <EvanR> you have to draw all pixels anyway
14:38:23 <Peaker> I don't really draw pixels, I draw GL primitives
14:38:32 <EvanR> the end result all pixels must have a color
14:38:35 <EvanR> R G B
14:38:37 <Peaker> (in the drawingcombinators library)
14:38:48 <kylemcgill> Hi Haskell, ok so haskell will be a new language to me, and it will be my first 'compiled language', my history is Ruby, Python, PHP, NodeJS, Lua, and the basic HTML, JS, CSS stuff, what i want to know about Haskell or more to the point compiled languages is if i compile something on my computer can i share that with a friend and he will be able to run it? or does it not quite work that way?
14:38:53 <Peaker> OpenGL doesn't really expose pixels that way, though
14:39:03 <EvanR> i know that
14:39:05 <RichyB> kylemcgill, it depends.
14:39:17 <EvanR> im talking about the semantics of the model -> screen
14:39:29 <Peaker> kylemcgill, if you statically compile it, the executable will depend on a few shared libs that your friend must have
14:39:30 <EvanR> and my model is simpler for normal applications
14:39:49 <Peaker> EvanR, But I'm wondering about getting this cropping semantics in GL
14:39:59 <RichyB> kylemcgill, if your compiler produces a static binary, then your friend's computer will be able to run it provided that they have the right kind of kernel. Almost certainly yes.
14:40:05 <mgsloan> you could probably do it in a shader
14:40:18 <Peaker> EvanR, I was told drawing into textures isn't even reliably supported
14:40:18 <kylemcgill> ricky: Peaker ok so an installer will still be needed etc, but its not like Java where you need JRE in order to run it
14:40:23 <parcs`> right kind of kernel and right kind of libc and right kind of gmp...
14:40:28 <RichyB> kylemcgill, if you set your compiler to produce a dynamically-linked binary, then your friend will need the libraries that you've linked against in order to run your program.
14:40:30 <mgsloan> might actually be somewhat more efficient than using the stencil buffer, if you have hardware that actually supports it, that is
14:40:48 <Eduard_Munteanu> You can make a fully-static-linked executable, can't you?
14:40:51 <Peaker> kylemcgill, you could just send a single executable if you know the shared lib versions
14:41:05 <Peaker> Eduard_Munteanu, libgmp/libc are always dynamic, I think?
14:41:12 <EvanR> Peaker: im not talking about drawing onto textures
14:41:14 <mgsloan> that is the most terrible thing about modern graphics programming - you need to do everything three different ways in order to have performance across a spectrum of platforms
14:41:18 <RichyB> No, libc does not need to be dynamic.
14:41:22 <Eduard_Munteanu> Peaker: I don't think so
14:41:38 <Eduard_Munteanu> Unless you mean for legal reasons, IDK.
14:41:49 <Philippa> RichyB: "right kind of kernel" isn't too meaningful to windows or macos users, FWIW
14:42:03 <kylemcgill> Peaker: ok so what about if he was on Windows, im assuming the same goes there, but am i correct in thinking that they wont have to download a Haskell pkg/exe in order to run my program
14:42:04 <Peaker> EvanR, I know - your suggestion of overdrawing, iiuc, doesn't work if the rest of the drawing doesn't give an opaque color to every pixel out of the area
14:42:07 <EvanR> Peaker: mgsloan the higher level thing im talking about is over drawing black or whatever as a initial stage of the full composite
14:42:16 <EvanR> Peaker: sure it does
14:42:20 <RichyB> Philippa, oops. Well-spotted.
14:42:42 <RichyB> kylemcgill, static binaries will usually be usable by anyone running the same operating system as you.
14:42:46 <Philippa> kylemcgill: yeah, you can run GHC-built .exes on other windows systems
14:43:03 <Peaker> EvanR, any pixel that isn't given a new opaque color will still have the old color which exposes the original drawing?
14:43:08 <RichyB> GHC still defaults to building static binaries by default, right?
14:43:12 <Peaker> EvanR, (out of the bounds it was supposed to be drawn in?)
14:43:18 <EvanR> Peaker: im assuming each 'frame' of the graphics was started from scratch
14:43:25 <Philippa> it does, yeah
14:43:32 <RichyB> Ta.
14:43:35 <EvanR> then you have to take care of that phenomenon somehow
14:43:52 <EvanR> for two scrolly regions and the rest some other gui elements:
14:43:52 <mgsloan> Peaker: If you're just drawing quads, and you're not doing any fancy vertex buffer kind of stuff, then wouldn't it be possible to just crop the quads, and adjust UVs accordingly?
14:44:05 <Eduard_Munteanu> RichyB: it doesn't statically link to libc and other non-Haskell libs by default though.
14:44:06 <EvanR> draw the two scrolly regions by drawing one at a time then blanking the rest out
14:44:10 <EvanR> then draw the gui elements
14:44:13 <Eduard_Munteanu> Just Haskell stuff.
14:44:18 <EvanR> done
14:44:18 <kylemcgill> Thanks guys! im still tossing and turning between Haskell and Java, (Yes i know the difference behind them, but i dont know what is required to 'run' them) again Ta! i think i will continue through some tuts :)
14:44:22 <Peaker> EvanR, it is.. the two scrolly regions being drawn will each be drawn outside the designated area, and even in each other's areas
14:44:32 <EvanR> no stencil, no shaders, no cropping support
14:44:42 <EvanR> Peaker: no, you missed what i said
14:44:52 <Peaker> mgsloan, I'm drawing GL lines, curves, polygons, FTGL text, ..
14:44:53 <RichyB> Eduard_Munteanu, didn't know that, ta.
14:44:55 <EvanR> draw the scrolly regions one at a time, at the beginning
14:45:05 <EvanR> then fill in the rest
14:45:06 <Peaker> EvanR, on the same color buffer?
14:45:10 <EvanR> yes
14:45:21 <Peaker> EvanR, what makes the second scrolly draw not overwrite the first?
14:45:36 <EvanR> youre right
14:45:39 <EvanR> impossible
14:45:48 <Peaker> top-left scrolly drawn.  bottom-right scrolly drawn, but its image is huge and overwrites the first one?
14:46:04 <Peaker> EvanR, are you being sarcastic, am I being dense? I really don't understand
14:46:10 <EvanR> no im not
14:46:36 <EvanR> heres my next suggestion, if all you have is rectangles, you can emulate cropping pretty easily
14:46:38 <Peaker> I think depth buffer trickery could probably work though
14:46:50 <EvanR> cairo / pango text rendering can be told to crop
14:46:50 <Peaker> yeah to crop just rectangles I could use glViewport
14:47:02 <EvanR> before you apply them
14:47:11 <Peaker> but that's not compositional (i.e: you can't rotate a cropped image)
14:47:18 <EvanR> and textured quad applications can be cropped
14:47:35 <EvanR> yes, ive been describing the painters algorithm
14:47:57 <EvanR> you can rotate anything
14:47:59 <dcoutts> EvanR: cairo text rendering can I believe, be cropped to an arbitrary mask
14:48:02 <Peaker> but using depth buffer trickery, I could draw any mask into the depth buffer, and then draw
14:48:04 <EvanR> you cant rotate anything
14:48:08 <EvanR> dcoutts: yes
14:48:14 <Peaker> how does that work?
14:48:19 <Peaker> if it uses GL?
14:48:26 <EvanR> Peaker: painters algorithm, first disable the depth buffer, i havent been talking about depth buffers
14:48:41 <EvanR> you cant paint behind stuf
14:48:41 <dcoutts> or you can render text to an temp surface and then compose that onto the final surface
14:48:43 <Peaker> EvanR, I know, I think depth buffer trickery can work though :)
14:48:48 <EvanR> blah
14:48:52 <Peaker> EvanR, using it for masking, rather than actual depths
14:49:08 <EvanR> dcoutts: would have to, cairo cant go direct to gl
14:49:10 <Peaker> dcoutts, with GL, that feature isn't always available, afaik?
14:49:17 <EvanR> Peaker: yes it is
14:49:34 <EvanR> you can convert any data to a texture
14:49:43 <EvanR> if the text doesnt update very fast, presto
14:49:45 <mgsloan> What's wrong with clipping the quads that have the text texture?
14:49:47 <dcoutts> EvanR, Peaker: honestly I'm not sure about the state of cairo's gl backend
14:50:01 <EvanR> mgsloan: you cant clip quads in GL
14:50:14 <mgsloan> EvanR: Sure, but you can in your own code
14:50:31 <mgsloan> and it's even fairly efficient if they're axially aligned
14:50:32 <EvanR> mgsloan: yes, in general if you are just doing rectangular graphics clipping is easy to be done in the library
14:50:33 <Peaker> EvanR, how do you draw into a texture? draw into color buffer, then convert it to texture?
14:50:56 <EvanR> Peaker: we were only talking about converting data to a texture, not using drawing primitives to produce a texture
14:51:15 <EvanR> example pango text -> texture
14:51:20 <Peaker> EvanR, ah, but I don't have the data.. I only have drawing primitives
14:51:27 <EvanR> it would be from another lib
14:51:31 <mgsloan> graphics-drawingcombinators used to be using polygons for text, but I think now it's using textures, at least for bottle, no?  So that should be fine
14:51:38 <Peaker> and it might be slow to generate the data
14:51:56 <EvanR> thats why i said its good for not updating much text
14:52:16 <jfischoff> Peaker: depending on the OpenGL you can set the render target to be a texture instead of the frame buffer
14:52:19 <Peaker> mgsloan, the text is internally on textures, but I don't think ftgl exposes that
14:52:31 <Peaker> jfischoff, I need it to be portable/reliably work everywhere
14:52:54 <mgsloan> Peaker: Yeah.  I wonder if it does one quad per letter.  This'd probably be most efficient memorywise
14:52:55 <jfischoff> Peaker: "everywhere" your not going to get any way
14:52:58 <Peaker> the subset of OpenGL you can rely on is pretty lame, I must say
14:53:01 <EvanR> Peaker: which is becoming a joke in GL world
14:53:09 <EvanR> nothing works everywhere anymore
14:53:21 <EvanR> even based gl
14:53:21 <Peaker> jfischoff, well, I don't even have a stencil buffer in my own machine in windowed mode
14:53:23 <EvanR> basic
14:53:36 <EvanR> yeah, stencil buffer is old old
14:53:40 <Adeon> what about the scissor test
14:53:59 <Peaker> Adeon, what does it do?
14:54:17 <Adeon> you define a rectangle where you want stuff to go and anything not going inside the rectangle does not get drawn
14:54:17 <mgsloan> Maybe it's time to write our own GL font rendering engine? :D
14:54:21 <Adeon> not sure if this was what you were looking for
14:54:53 <mel-> Hey. I'm a totally beginner! my problem is this: i have a function F which returns Either String or Foo. It returns a String in case of an error. now, I call this function with map to iterate over a list. But... actually I want to say: "Stop iterating when one call to F returns an error string and return string. If no call to F returns a string, then return the list of Foo values.'.
14:55:05 <mel-> I need a pointer into the right direction please. :)
14:55:09 <Peaker> mgsloan, at worst I'd dig into ftgl to expose more.. but it's not really my issue.. I need some way to draw my gl primitives to a texture that I can later crop-blit or color-tint, etc.
14:55:41 <Peaker> mel-, you want   mapM  over the (Either String) monad
14:55:59 <mel-> Peaker: mapM... thanks, will look that up!
14:56:17 <Peaker> > mapM (\x -> if even x then Right x else Left "odd!") [2,4,6]
14:56:18 <lambdabot>   Right [2,4,6]
14:56:22 <Peaker> > mapM (\x -> if even x then Right x else Left "odd!") [2,5,6]
14:56:24 <lambdabot>   Left "odd!"
14:57:18 <Peaker> mel-, the (Either e) monad has exactly this behavior (short-circuit the Left value out when encountered.. like an exception)
14:57:52 <ksf> someone in need of something to hack on?
14:57:54 <Peaker> mel-, and mapM is just a "map" followed by a "sequence" that does monadic composition (actually applicative) of all the values in the list
14:58:35 <ksf> a generic-deriving show-like thing that behaves just like show but ignores accessor names would be cool.
14:58:43 <mel-> Peaker: thanks a lot. i still need to get friends with monads. :(
14:58:53 <ksf> oh, and ideally it should pretty-print like ipprint, by default.
14:58:56 <Peaker> mel-, do you know Functor?
14:59:13 <jfischoff> Peaker: GL_EXT_framebuffer_object very well supported according to this: http://feedback.wildfiregames.com/report/opengl/
14:59:15 <Peaker> mel-, mapM/sequence are really just Applicative, not Monad
14:59:19 <mel-> Peaker: a bit. mostly from my math courses. :)
14:59:31 <Peaker> @src Functor
14:59:31 <lambdabot> class  Functor f  where
14:59:31 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
14:59:37 <Peaker> mel-, I'm referring to this ^^
14:59:40 <ksf> FBOs are supported on virtuall all cards that you want to run stuff on.
14:59:46 <DMcGill> mel- Typeclassopedia is a good resource
14:59:51 <DMcGill> @where typeclassopedia
14:59:51 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
14:59:56 <ksf> that might not include intel, but then noone wants to use intel cards.
15:00:00 <mel-> thank you guys
15:00:23 <jfischoff> Peaker: its part of core OpenGL 3.0 also
15:00:45 <Peaker> jfischoff, what does it do?
15:01:05 <jfischoff> lets render into a texture
15:01:12 <jfischoff> I'm pretty sure
15:01:17 <Peaker> jfischoff, I wonder if I have opengl3 at all
15:01:28 <jfischoff> I bet you have the extension
15:02:54 <Peaker> jfischoff, http://hackage.haskell.org/packages/archive/OpenGL/2.5.0.0/doc/html/Graphics-Rendering-OpenGL-GL-Framebuffer.html   I think reported 0 color bits on my machine :(
15:03:10 <jfischoff> oh well :(
15:04:13 <Peaker> I'll check again
15:04:28 <jfischoff> Peaker: I did see on a forum that even when a graphic card/driver supported old extensions, it would report that it didn't
15:04:53 <jfischoff> because so typical I guess
15:10:55 <Peaker> jfischoff, ok, rgbabits reports Color4 8 8 8 0
15:11:07 <Peaker> in FrameBuffer
15:13:03 <shirt> instance X Y where f=...
15:13:14 <shirt> why can't I use a where clause with f?
15:13:41 <startling> shirt, you'll need to be more specific
15:14:16 <shirt> instance X Y where { f=foo where foo=2 }
15:16:16 <jfischoff> Peaker: I thing you want to look at this perhaps http://hackage.haskell.org/packages/archive/OpenGL/2.4.0.1/doc/html/Graphics-Rendering-OpenGL-GL-BufferObjects.html ?
15:17:17 <Peaker> jfischoff, what is that for?
15:17:58 <jfischoff> Peaker: http://www.gamedev.net/page/resources/_/technical/opengl/opengl-frame-buffer-object-101-r2331
15:20:25 <Peaker> jfischoff, opengl is so clumsy
15:20:49 <jfischoff> Peaker: yes I can barely remember how to do anything I have done in the past
15:21:05 <jfischoff> its a constant relearning forgetting process
15:21:29 <Peaker> yeah, terrible API
15:22:18 <Peaker> jfischoff, the page you linked mentions extensions, I don't know how any of it maps to the GL.BufferObjects stuff.. how portable it is, etc.
15:22:23 <fmap> shirt: this should work, can you paste actual code?
15:23:34 <shirt> fmap: woops, you are right, it does work! thanks
15:24:08 <mel-> Peaker: when I try that mapM thing I get 'No instance for (Monad (Either [Char])) arising from a use of `mapM'' -- my function F returns 'Either String Integer' and I'm calling mapM like: mapM f [2,4,6]. i must be missing some insight :)
15:24:23 <Peaker> jfischoff, does it allocate cpu-side memory or gpu-side? (mentions allocating)
15:24:52 <jfischoff> Peaker: I think it goes like the this. The frame buffer object extension is very common and old. As more and more buffer extensions were added there was a push in OpenGL to make a unified buffer api. I'm not sure how Haskell libraries expose this stuff. I saw something on github that pointed me there to do frame buffer object stuff
15:24:52 <Peaker> mel-, need to import Control.Monad.Instances
15:24:53 <parcs`> mel-: import Control.Applicative
15:24:55 <jfischoff> GPU
15:25:32 <jfischoff> Peaker: you are going to allocated the memory and then bind it as location to render into
15:26:11 <mel-> ah, cool. :)
15:26:37 <mel-> just gimme two more days and i've written my first haskell program 8-)
15:27:57 <edwardk> preflex: xseen luite
15:27:58 <preflex>  luite was last seen on freenode/#haskell-blah 1 hour, 53 minutes and 41 seconds ago, saying: hehe tnx
15:29:47 <Peaker> jfischoff, hmm.. interesting. I need to try it sometime.. can fix a bug and add cropping with that functionality, possibly
15:30:03 <Peaker> jfischoff, though it sounds like it's going to be difficult
15:31:11 <jfischoff> Peaker: could be
15:31:11 <Peaker> and I hope it doesn't mean I'm losing a lot of potential machines :(
15:31:28 <jfischoff> jfischoff: yeah I don't know
15:31:38 <palmfrond> i read that if a language has loop construct, you can synthesize choice/conditional (if (…), then, else). is this correct?
15:32:37 <shachaf> It's too vague to be correct or incorrect.
15:34:19 <palmfrond> ?
15:34:40 <palmfrond> what i'm trying to ask is if simple while loops can be composed to create any other programming construct
15:35:18 <jfischoff> while loops are already compound in a way. A test and a jump
15:35:40 <palmfrond> jump being a branch? the same as a conditional would employ?
15:36:04 <shachaf> @where bf
15:36:04 <lambdabot> http://en.wikipedia.org/wiki/Brainfuck
15:36:15 <shachaf> palmfrond: All your questions answered.
15:40:35 <palmfrond> aha
15:40:45 <palmfrond> [command is how else is implemented
15:43:22 <palmfrond> cool
15:43:34 <SimonJF> you'd do another while loop afterwards, with the opposite condition, right?
15:46:11 <ksf> fgl's hasLoop doesn't seem to do what I think it does.
15:46:17 <ksf> I thought it would detect loops.
15:50:27 <ksf> ...hasloop only detects edges from a node to itself, I can't seem to find one that checks whether a tree is acyclic.
15:52:45 <Peaker> just do a dfs with already-visited param?
15:53:05 <ksf> I have *no* idea about graph algorithms.
15:54:56 <jfischoff> ksf: nmap hasloop ?
15:54:59 <Peaker> ksf, do you know dfs?
15:55:12 <jfischoff> I guess all id . nmap hasloop
15:55:15 <ksf> yep.
15:55:15 <jfischoff> p
15:55:18 <shirt> i'm using Data.Array for a 2D array. Is the convention to use (row, column) or (column, row) ?
15:55:34 <Peaker> ksf, so dfs+visited-set-check will detect loops
15:55:36 <ksf> hasloop already checks all nodes.
15:55:41 <irene-knapp> shirt: generally it's (x, y)
15:55:54 <irene-knapp> shirt: ie don't call them rows and columns if you can avoid it, because of precisely that lack of convention
15:56:01 <edwardk> shirt: whatever is convenient for your data
15:56:13 <Peaker> shirt, (slow-change, fast-change) is a convention I think
15:56:15 * ksf is intimidated by the wealth of functions in http://hackage.haskell.org/packages/archive/fgl/5.4.2.4/doc/html/Data-Graph-Inductive-Query-DFS.html
15:56:47 <ksf> wait, dfsWith' looks like a fold if I squint.
15:57:05 <edwardk> ksf: you can always embrace my more minimalist approach: https://github.com/ekmett/graphs/blob/master/Data/Graph/Algorithm/DepthFirstSearch.hs ;)
15:57:12 <shirt> Peaker: in my case it's data describing a grid, kind of like an image, so there is no slow-change/fast-change
15:57:59 <ksf> edwardk, well, I need at least topsort, too, and then graphviz would be nice.
15:58:19 <ksf> ...debugging anything graph-related without graphviz is hell.
15:59:09 <Peaker> shirt, there's probably the memory layout -- where the stuff that's condensed together is fast-change (for locality's sake)
15:59:36 <edwardk> ksf; i have a topsort in 'ad' somewhere ;)
15:59:36 <Peaker> shirt, if you iterate over chunks of data, it's best to iterate using the locality-preserving order
16:00:18 <edwardk> https://github.com/ekmett/ad/blob/master/src/Numeric/AD/Internal/Reverse.hs#L168 is a topSort for acyclic data that unlike the code in data.graph doesn't just crap out
16:00:26 <spree> > split "hey there" 't'
16:00:28 <lambdabot>   Couldn't match expected type `GHC.Types.Char -> t'
16:00:28 <lambdabot>         against inferred...
16:00:35 <spree> > split 't' "hey there"
16:00:36 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t'
16:00:36 <lambdabot>         against inferr...
16:00:45 <spree> > split "t" "hey there"
16:00:47 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t'
16:00:47 <lambdabot>         against inferr...
16:00:50 <spree> > split "hey there" "t"
16:00:51 <edwardk> it needs some extensions for cyclic data
16:00:52 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t'
16:00:52 <lambdabot>         against inferr...
16:01:02 <spree> no split in haskell?
16:01:15 <shirt> Peaker: good point. thanks
16:01:21 <cjay> :t split
16:01:23 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
16:01:32 <gienah> edwardk: sent you a trivial semigroupoids patch: https://github.com/ekmett/semigroupoids/pull/5
16:01:33 <DMcGill> :t Prelude.split
16:01:34 <lambdabot> Not in scope: `Prelude.split'
16:02:11 <shirt> Peaker: so Array will arrange the memory such that the "fast-change" data will be adjacent?
16:02:19 <edwardk> spree: there is a split in Data.Text for Text but not for String
16:02:26 <Peaker> shirt, I think so
16:02:30 <edwardk> > unwords "hello there"
16:02:31 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
16:02:31 <lambdabot>         against inferred ty...
16:02:34 <edwardk> > words "hello there"
16:02:36 <lambdabot>   ["hello","there"]
16:02:46 <edwardk> gienah: checking
16:02:55 <Peaker> shirt, Ix class lets you see what changes fast..
16:02:59 <spree> :t words
16:03:00 <lambdabot> String -> [String]
16:03:01 <Peaker> @src Ix
16:03:01 <lambdabot> class (Ord a) => Ix a where
16:03:01 <lambdabot>     range           :: (a,a) -> [a]
16:03:01 <lambdabot>     index           :: (a,a) -> a -> Int
16:03:01 <lambdabot>     inRange         :: (a,a) -> a -> Bool
16:03:02 <lambdabot>     rangeSize       :: (a,a) -> Int
16:03:09 <edwardk> gienah: ah, i just put that patch together myself ;)
16:03:12 <spree> @hoogle String -> [String]
16:03:12 <lambdabot> Prelude lines :: String -> [String]
16:03:12 <lambdabot> Data.List lines :: String -> [String]
16:03:13 <lambdabot> Data.String lines :: String -> [String]
16:03:15 <Peaker> > range ((1,1),(2,2))
16:03:16 <lambdabot>   [(1,1),(1,2),(2,1),(2,2)]
16:03:23 <spree> @hoogle String -> Char -> [String]
16:03:24 <lambdabot> Text.XHtml.Strict renderHtmlWithLanguage :: HTML html => String -> html -> String
16:03:24 <Peaker> yeah, (slow,fast)
16:03:24 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
16:03:24 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
16:03:24 <gienah> edwardk: with https://github.com/markwright/semigroupoids/commit/e73374d2ec5b623d740b8ee799dc439e558e7410 I hope its ok that I used SomeException on 101, as maybe that is slightly different semantics to the old catch which may have only caught IOException
16:03:32 <spree> @hoogle Char -> String -> [String]
16:03:32 <lambdabot> Text.XHtml.Strict renderHtmlWithLanguage :: HTML html => String -> html -> String
16:03:33 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
16:03:33 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
16:03:39 <edwardk> i fixed it slightly to remove the need for extensions
16:03:40 <spree> @hoogle String -> String -> [String]
16:03:41 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
16:03:41 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
16:03:41 <lambdabot> System.FilePath.Windows addExtension :: FilePath -> String -> FilePath
16:03:47 <edwardk> but kept the logic
16:03:50 <spree> sorry dont mean to spam
16:03:55 <ksf> dfsWith' doesn't work, it visits each node only once.
16:04:05 <gienah> edwardk: oh, ok, then can just close mine :-)
16:04:12 <edwardk> instance Alt IO where m <!> n = catch m (go n) where go :: x -> SomeException -> x; go = const
16:04:25 <edwardk> that avoids the need for FlexibleContexts and ScopedTypeVariables
16:04:32 <edwardk> and returns the package to extensionlessness
16:04:39 <gienah> edwardk: neat, thanks :-)
16:04:40 <edwardk> also i explicitly enumerated the dependencies from base
16:04:43 <edwardk> eliminating the need for CPP
16:05:20 <gienah> edwardk: yeah I was wondering about that alternative of specifying the module name in front of catch
16:05:21 <edwardk> er s/base/Prelude/
16:06:49 <ksf> same goes for dff
16:06:55 <edwardk> gienah: check the current version now
16:07:02 * ksf decides it's not worth the bother
16:08:14 <edwardk> er well I didnt mean that to come across quite so order like ;)
16:08:45 <gienah> edwardk: neat, thanks, looks great, if there are any other of your pkgs that need tweaks for ghc head I'll do them like you just did :-)
16:08:53 <edwardk> much obliged
16:08:57 <edwardk> i patched a couple already
16:09:04 <edwardk> i don't use catch much
16:09:25 <gienah> edwardk: great, I'll compile more of them with ghc head
16:09:36 <edwardk> cabal install kan-extensions should get most
16:09:43 <edwardk> cabal install trifecta should get most of the rest
16:10:24 <edwardk> other than that there is just bound, parsers and a few orphans
16:11:31 <gienah> edwardk: I'll try it (but have to fix breakage in other deps, like stm, that aren't your packages first)
16:13:28 <clsmith> hey all. is there a recommended way to deal with acyclic graph structures in haskell? seems it might be a can of worms.
16:14:11 <clsmith> oops, i mean *cyclic*, not acyclic :p
16:14:17 * hackagebot semigroupoids 1.3.4 - Haskell 98 semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-1.3.4 (EdwardKmett)
16:15:31 <edwardk>  clsmith: honestly? i work with it as normal data until i can't any more then i switch it all over using data-reify
16:17:06 <jfischoff> edwardk: data-reify?
16:18:13 <edwardk> andy gill's much-nicer-than-what-i-came-up-with way to deal with reifying data from terms with sharing into a graph structure
16:18:45 <edwardk> https://github.com/ekmett/ad/blob/master/src/Numeric/AD/Internal/Reverse.hs#L75 is how you make an instance
16:19:03 <edwardk> https://github.com/ekmett/ad/blob/master/src/Numeric/AD/Internal/Reverse.hs#L186 is me invoking it
16:20:06 <jfischoff> do you loss some type safety when you reify values?
16:20:22 <edwardk> reifyGraph :: MuRef s => s -> IO (Graph (DeRef s))    -- where data Graph e = Graph [(Int, e Int)] Int
16:20:24 <edwardk> no
16:20:38 <edwardk> type safety is preserved, you just can observe the sharing information, so it is an IO effect
16:21:09 <edwardk> in ad its a pure optimization, and any combination of sharing would yield the same answer so its safe to unsafePerformIO
16:21:46 <edwardk> elsewhere i use it to define circuits, sat problems, a DSL for compiling to the GPU, etc.
16:21:55 <jfischoff> interesting
16:22:07 <edwardk> where you aren't crammed in some awful monadic dsl
16:22:11 <jfischoff> okay one more thing to try out :)
16:23:25 <ksf> edwardk, I just used Control.Categorical.Functor, btw.
16:23:29 <edwardk> of course i occasionally use data-reify with reflection, which just gets silly
16:23:30 <kylemcgill> Sorry im going to be a huge pain in the a** but i have searched google for a couple of hours now, and so far i must be missing something.... Compiled a simple Hello World example, Worked on the same machine (to be expected i guess) then transferred it on to my Mac and tried running it and got a exec format error on the file, passed it to a mate with Ubutnu, similar thing, coulnt open bin file, is there something im missing during t
16:23:33 <edwardk> ksf: my condolences ;)
16:24:19 <ksf> for something like data Foo a =  Foo (Bar a) (Baz a) where Bar and Baz are data families
16:24:59 <edwardk> *nods*
16:25:07 <jfischoff> kylemcgill: sounds like you are trying to run an executable built for one OS on totally different one. Is that correct?
16:25:08 <ksf> ...to get rid of having to pass around a gazillion type parameters to my ast.
16:25:12 <Eduard_Munteanu> kylemcgill: what OS?
16:25:18 <edwardk> aha
16:25:20 <edwardk> thats not a bad idea
16:25:42 <Eduard_Munteanu> BTW, GHC does dynamic linking by default on Windows IIRC.
16:25:48 <kylemcgill> Archlinux (where it is compiled), Mac OSX 10.7, and Ubuntu 12.?? were the test machines
16:25:48 <edwardk> you can actually do something a little nicer with data kinds
16:25:49 <ksf> now if only I knew of a good way to have extensible sums things'd be perfect.
16:26:07 <kylemcgill> jfischoff: Well yes thats correct
16:26:24 <jfischoff> and that's your problem
16:26:25 <Eduard_Munteanu> kylemcgill: what arch? x86-32/64?
16:26:27 <edwardk> but i haven't got a usable 'upgraded' categories' library yet
16:26:35 <kylemcgill> jfischoff: so i will need to recompile it for mac and then try it again on mac?
16:26:39 <edwardk> i'm waiting for the rest of the polykind stuff to work properly
16:26:46 <Eduard_Munteanu> That might be a problem too.
16:26:53 <kylemcgill> Eduard_Munteanu: all 64
16:27:40 <kylemcgill> If possiable, i would like to see the Application Hello World work on a unix machine that doesnt have GHC
16:27:56 <ksf> ghc links statically by default
16:28:03 <kylemcgill> so i would need to compile it on Mac, and then get someone else with a mac to run it and pray to the gods?
16:28:30 <Eduard_Munteanu> kylemcgill: try   ghc --make -static -optc-static -optl-static foo.hs
16:29:11 <Eduard_Munteanu> That should also get you the static system libs in.
16:31:05 <kylemcgill> hmmm i have a lot of pthread errors, ld returned 1 exit status
16:31:22 <parcs`> kylemcgill: add -threaded to that
16:32:21 <kylemcgill> Warning using dlopen in statically link applicastions requires at runtime the shared libraries from the glibc version used for linking
16:32:24 <kylemcgill> lol
16:32:41 <kylemcgill> would it be better for me to carrying on without something else and come back to this in future?
16:33:00 <parcs`> kylemcgill: you should forget about portability issues and learn the language :)
16:33:02 <jfischoff> How on earth can one compile on linux and expect it to work on OSX
16:33:11 <kylemcgill> excuse the ignorance, but is Multi-comp apps starting to get a little more advance?
16:33:12 <Eduard_Munteanu> kylemcgill: mind building generic, statically-linked apps can be a problem even with C apps.
16:33:13 <jfischoff> that has nothing to do with haskell
16:33:22 <jfischoff> yes
16:33:27 <dcoutts> cross compilation?
16:33:30 <jfischoff> sure
16:33:40 <jfischoff> but not build once run everywhere
16:33:55 <dcoutts> no indeed
16:34:26 <kylemcgill> thanks everyone, you guys are great, even with my dumb questions
16:34:27 <kylemcgill> :)
16:34:28 <Eduard_Munteanu> Oh, right, I'm not sure if OS X even runs Linux apps.
16:34:59 <Eduard_Munteanu> But it should've worked on Ubuntu.
16:35:10 <jfischoff> not necessarily
16:35:32 <Eduard_Munteanu> Why not? The kernel ABI is stable.
16:35:57 <Eduard_Munteanu> Assuming he gets all libs linked in statically, that is.
16:36:15 <jfischoff> I don't enough about linux to say for sure
16:36:21 <jfischoff> actually
16:36:24 <jfischoff> so you might be right
16:36:32 <popl> you  a word
16:36:36 <popl> :)
16:36:48 <Eduard_Munteanu> Yeah, he accidentally it.
16:37:03 <irene-knapp> But what did he to it?  I to know!
16:37:13 <kylemcgill> tbh i actually know alot about Unix systems, however Haskell is my first compiled language, and simple binary files can work cross unix platforms, granted you have the basics and the same arch
16:37:38 <irene-knapp> the short answer is that the ABI is different on the Mac than on Linux
16:37:45 <irene-knapp> as well as the executable format (Mach-O vs ELF)
16:37:54 <Eduard_Munteanu> And the same syscalls etc.
16:38:10 <kylemcgill> hence i was sort of expecting the same result, irene-knapp that is true... <-- Hopeful :)
16:39:10 <cheater_> itym the binary format is different
16:42:19 <Eduard_Munteanu> kylemcgill: in any case, it should be possible to make a binary that runs on different Linuces, though that's not the usual way to distribute binaries. Any particular reason you're doing it that way?
16:42:47 <Eduard_Munteanu> Perhaps you can at least make runhaskell scripts and assume the target machine has GHC/HP installed.
16:44:16 <kylemcgill> Eduard_Munteanu: what i was trying to do was create a self contained bin file that echo'd Hello World where GHC wasnt present
16:44:41 <ksf> other unixes usually have some linux ABI compatibility layer
16:44:54 <ksf> at least *bsd and solaris have those.
16:46:38 <Eduard_Munteanu> kylemcgill: yeah, I know, but I wondered if you could do without that requirement
16:47:05 <kylemcgill> the concept was sound in my head, implementation was not :) was hoping there was some magic in the command line that could help :)
16:47:15 <kylemcgill> Yeah i can get around it
16:47:20 <kylemcgill> not a biggie
16:48:21 <kylemcgill> if i was to build anything i wouldnt want the application to be exclusive to Haskell Developers, or people with GHC
16:48:23 <jfischoff> I had no problem running OSX haskell executables on other OSX machines
16:48:39 <jfischoff> not sure about the lack of GHC requirement
16:48:53 <kylemcgill> jfischoff: hmm i see
16:49:12 <jfischoff> I'll know on monday for sure
16:49:14 <jfischoff> :)
16:50:14 <kylemcgill> there are a couple of people in the office with Mac, so maybe i might repeat all of this inside Mac (Compile it there) and give it a go :)
16:52:03 <jfischoff> let me know if it works!
16:52:50 <kylemcgill> jfischoff: thanks will do
17:23:48 <kylemcgill> hey
17:24:15 <kylemcgill> so i compiled the Hello World file in Mac OSX, then gave it to a mate who didnt even know what Haskell was, and it ran!!!
17:24:23 * hackagebot csv-conduit 0.2.1.1 - A flexible, fast, conduit-based CSV parser library for Haskell.  http://hackage.haskell.org/package/csv-conduit-0.2.1.1 (OzgunAtaman)
17:24:25 <kylemcgill> highlight of my day :D
17:24:44 <kylemcgill> jfischoff: so to confirm it works perfectly
17:25:04 <jfischoff> yay!
17:27:29 <enko> is there a way to prevent infinite patterns? (aside from not making the mistake in the first place) like a compiler switch?
17:28:37 <monochrom> I don't understand the question.
17:29:29 <enko> when i miss a 'take x' myinfinitelist my system near crashes
17:30:03 <enko> is there a way to limit its run?
17:31:56 <monochrom> oh, that can be done with the OS, no compiler support necessary. if linux or macos etc, check out "ulimit". if windows, run linux or macos etc in a virtual machine, recurse.
17:32:14 <enko> its linux, will do thanks!
17:32:54 <shachaf> enko: You can probably use an RTS option like -M too.
17:33:21 <enko> k
17:51:42 <parcs`> isn't ulimit obsolete or something?
17:52:01 <Clint> what?
17:52:12 <parcs`> i think it is superseded by selinux, at least that's what #archlinux says
17:52:36 <Clint> ulimit not meaning the bash builtin?
17:53:20 <parcs`> oh, i meant /etc/security/limits.conf
17:53:42 <parcs`> where you can set the maximum rss of a process
17:54:44 <ricky>  /ll ricky
18:09:24 * hackagebot intern 0.9.1 - Efficient hash-consing for arbitrary data types  http://hackage.haskell.org/package/intern-0.9.1 (EdwardKmett)
18:31:49 <fragamus> hi I have a question
18:32:18 <totimkopf> they say that with haskell you can play with boobs all day :D
18:32:29 <totimkopf> (.).(.)
18:34:18 <fragamus> if i have two functions can I test them for equality
18:34:37 <dmwit> Maybe.
18:34:47 <dmwit> Are their domains finite?
18:34:58 <fragamus> I only need to know if it is the exact same function
18:35:03 <fragamus> yes
18:35:10 <fragamus> finite
18:35:29 <dmwit> If their domains are finite and their codomains can be compared for equality, then you can test them for equality by running them on all inputs.
18:35:35 <fragamus> oh I see you are saying I could sample them
18:35:46 <dmwit> f == g = all (\x -> f x == g x) universe
18:36:00 <vitno> dmwit, that sounds computationally expensive... there isn't an easier way?
18:36:02 <startling> is there a ghc extension that lets me have a type like "integers from 0 to 100"? I seem to remember something but I can't find it
18:36:06 <dmwit> vitno: no
18:36:07 <fragamus> yeah i just really want to see if its the same exact function
18:36:25 <startling> fragamus: haskell doesn't work like that
18:36:26 <startling> sorry
18:36:37 <fragamus> but I guess we live in the world of referential transparency so
18:36:41 <fragamus> yeah
18:37:06 <dmwit> startling: Yes, data ZeroToOneHundred = Zero | One | Two | ... | OneHundred -- ;-)
18:37:15 <dmwit> You can automate it a bit more if you enable enough extensions.
18:37:18 <startling> dmwit: >:(
18:37:24 <dmwit> There's half a dozen type-level natural packages on Hackage.
18:37:24 <fragamus> in c I could just test equality on two pointers
18:37:55 <dmwit> They should provide a Fin type or similar which you can instantiate at, e.g., Fin (Succ (Succ (Succ (... (Succ Zero)...))))
18:38:30 <startling> dmwit: i think i'll just go with a comment
18:38:35 <dmwit> fragamus: Pointers change. You don't want to give up GC.
18:38:40 <vitno> fragamus, After thinking about the problem, I agree with dmwit. There is never going to be a way. I'm pretty sure it can be mathematically proved as well
18:39:18 <startling> fragamus: yeah, moving garbage collectors are a thing that could ruin that
18:41:19 <dmwit> For what it's worth, IORef and MVar both provide an Eq instance that doesn't result in an Eq constraint on the contained type.
18:43:21 <zzo38> Say you have something like this:  (forall z. c z => (x -> z) -> z)
18:44:40 <zzo38> Or have this:  (forall z. c z => (z -> x, z))
18:46:12 <kylemcgill> Quick question, running GHC on a 64bit machine, how do i compile for 32 bit?
18:46:34 <kylemcgill> i have found -m32 as an arg, but it didnt work well
18:47:03 <parcs`> you can't, directly
18:47:18 <joeyh> dmwit: hmm, interesting point.
18:47:46 <kylemcgill> Ok, so how would it be best to go about compiling for 32-bit static libs?
18:48:19 <dmwit> Get a 32-bit GHC.
18:49:09 <kylemcgill> so the assumption is that i should by default run with a 32bit installation anyway, as a 64-bit OS can read 32 bit libs anyway?
18:50:45 <parcs`> no, use a 32-bit vm instead
18:51:02 <kylemcgill> vagrant it is then
18:51:03 <kylemcgill> thanks
18:54:28 <zzo38> Has anyone know about the kind of things I am writing about? Including not only a class c methods but also the mathematical laws if follows.
19:04:27 * hackagebot cypher 0.2 - Haskell bindings for the neo4j "cypher" query language  http://hackage.haskell.org/package/cypher-0.2 (SamAnklesaria)
19:19:04 <cads> @type fmap
19:19:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:45:49 <edwardk> preflex: xseen shapr
19:45:49 <preflex>  shapr was last seen on freenode/#haskell-blah 5 hours, 1 minute and 52 seconds ago, saying: Hello Mr Cat!
19:55:58 <captain_rat> haskelll !!
19:56:00 <captain_rat> oh yeaheahh!!
19:56:09 <captain_rat> oh yeahhaheah!!
19:56:41 <serialhex> you okay captain_rat???
19:57:32 <edwardk> clearly, it was a seizure
19:57:47 <serialhex> i guess so
19:58:09 <captain_rat> I dream of learning happstack and selling my website for 100mil
19:58:23 <edwardk> give him a minute, after the refractory period he'll start talking again
19:58:36 <serialhex> ^
19:58:44 <edwardk> yeah i was too slow =)
19:59:09 <edwardk> captain_rat: worked for alex i guess
19:59:10 <serialhex> yeah, i think he has something there: learn happstack; well site for 100mil
19:59:15 <serialhex> alex?
19:59:29 * hackagebot wl-pprint-terminfo 0.8.4 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-0.8.4 (EdwardKmett)
19:59:38 <serialhex> grr, spelling!  sell
20:00:11 <edwardk> jacobson http://www.crunchbase.com/person/alex-jacobson started happs
20:00:49 <serialhex> hmm... cool!
20:02:12 <edwardk> i think he only walked away with like 15 million though ;)
20:02:42 <jmcarthur> beats 14 million
20:03:04 <edwardk> true
20:03:25 <edwardk> and unlike my efforts, he actually got to keep money in the end ;)
20:03:34 <jmcarthur> money shmoney
20:03:47 <edwardk> having both had it and not had it, its better having it ;)
20:04:03 <serialhex> i would assume so =D
20:04:49 <serialhex> dmwit: around??
20:05:24 <captain_rat> alex sonuds like a guy who had a rich dad
20:05:28 <captain_rat> and did well with it
20:05:44 <Cale> edwardk: So is the secret plan for Haskell to take over the world by quietly seizing control of the banking system? Avoid success at all costs, they're on to us?
20:06:08 <edwardk> captain_rat: well, having money helps
20:06:23 <edwardk> cale: i'm pretty sure we already have
20:06:35 <Wooga> hi, may someone check my LYAH homework; about possible moves of knight on chess board? here is my solution: http://codepad.org/RQS2YSPk . it is working, but i am not sure about efficency and correctness. is there anything that could be done better?
20:06:42 <captain_rat> I think it could 1 replace jira and confuence 2 replace sharepoint 3 replace wordpress 4 replace sugarCRM  as a start to ending some evils
20:07:11 <captain_rat> is haskell hard to learn for someone not compsci major?
20:07:15 <NietzschesBalls> omg   i have jock itch
20:07:16 <NietzschesBalls> help me
20:07:17 <captain_rat> and not perl etc programmer
20:07:25 <captain_rat> lotramin man
20:07:26 <NietzschesBalls> can I rape your rectum captain_rat ?
20:07:28 --- mode: ChanServ set +o edwardk
20:07:29 <captain_rat> nop
20:07:30 <NietzschesBalls> I want to shove my cock into your ass
20:07:33 <NietzschesBalls> and make you ableed
20:07:33 --- mode: edwardk set +b *!Nietzsches@you.want.to.fuck.with.us.to
20:07:33 --- kick: NietzschesBalls was kicked by edwardk (Your behavior is not conducive to the desired environment.)
20:07:38 <captain_rat> no thaks
20:07:38 <zachk> edwardk: in your humble opinion is ok to have epileptic fits to jungle music from the late 90's if one moves like a robot to cover the fact and it is in sync with the beat?
20:07:38 <lambdabot> zachk: You have 1 new message. '/msg lambdabot @messages' to read it.
20:08:24 <edwardk> captain_rat: plenty of folks in here have learned haskell without a CS backgroun
20:08:33 <edwardk> @where LYAH
20:08:34 <lambdabot> http://www.learnyouahaskell.com/
20:08:46 <edwardk> learn you a haskell is a very gentle introduction and not at all math/cs oriented
20:09:39 <captain_rat> awesome
20:09:47 <captain_rat> now is ghc enuf?
20:09:54 <captain_rat> or do i need this hakell platform thing
20:10:02 <edwardk> grab the platform
20:10:02 <captain_rat> I dont know if I can get that here on linux going
20:10:07 <edwardk> it comes with all the stuff you'l want to get started
20:10:41 <edwardk> you can just sit there and install whatever packages get you ghc and cabal, and then do the rest from 'cabal install', but the platform is convenient
20:10:55 <serialhex> captain_rat: uhmm.... what distro you using?  you should be able to apt-get/yum/pacman your way into haskelly-goodness!!
20:11:15 <startling> captain_rat, I don't have a CS background and I've learned (some) haskell
20:11:25 <captain_rat> archlinux
20:11:35 <edwardk> re: computer science background. the guy who started the channel here is still plugged into the haskell community and he's only now gone back to do a CS degree ;)
20:11:36 <jmcarthur> archlinux is like the best distro for haskell :)
20:11:37 <captain_rat> trying find it now.....
20:11:41 <serialhex> captain_rat: sudo pacman -S haskell-platform
20:11:45 <edwardk> that was seven/eight years ago ;)
20:11:45 <startling> captain_rat: you can't pacman -S haskell-platform?
20:12:05 <captain_rat> ]# pacman -S haskell-platform error: target not found: haskell-platform
20:12:29 <serialhex> uhm... pacman -Syy ??
20:12:42 <serialhex> then try that, though it should be there...
20:12:57 <jmcarthur> i don't think there is actually a platform package, is there?
20:13:05 <captain_rat> I used it last year
20:13:05 <jmcarthur> just a ton of haskell packages
20:13:10 <captain_rat> but then it stopped working this year
20:13:11 <kylemcgill> sudo pacman -Ss haskell
20:13:20 <kylemcgill> will search pacman for the haskell packages
20:13:34 <kylemcgill> from there you will be bale to select your packages
20:13:41 <serialhex> there is no platfor package!!  :'(  http://www.archlinux.org/packages/2/?q=haskell
20:13:47 <jmcarthur> the important parts are ghc and cabal-install
20:13:59 <jmcarthur> with cabal-install you can basically get anything else
20:14:20 <captain_rat> ok
20:14:31 <jmcarthur> the haskell-platform is on aur, at least
20:14:32 * hackagebot plot 0.1.4 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  http://hackage.haskell.org/package/plot-0.1.4 (VivianMcPhail)
20:14:49 <captain_rat> crap no cabal
20:14:53 <jmcarthur> but i don't use the platform, so i can't attest to it being any good. i just use cabal-install on demand
20:14:55 <captain_rat> oh aur?
20:14:55 <captain_rat> ok
20:14:59 <jmcarthur> cabal-install is definitely there
20:15:00 <kylemcgill> ah i t is
20:15:12 <captain_rat>  pacman -Ss haskell|grep -i cabal
20:15:12 <kylemcgill> yaourt haskell-platform returns one result
20:15:14 <serialhex> hmm...  i thought i got mine from the official
20:15:15 <jmcarthur>  pacman -Ss cabal-install   # shows it for me
20:15:35 <serialhex> there is also a haskell repo
20:15:41 <captain_rat> ah ha!!
20:15:44 * serialhex goes and looks for repo
20:15:45 <captain_rat> ok
20:15:51 <captain_rat> cabal-install on the way down
20:15:59 <kylemcgill> pacman -S ghc cabal-install
20:16:03 <jmcarthur> when bauerbill was around it actually supported packaged straight from hackage
20:16:04 <kylemcgill> is all you should need dude
20:16:08 <jmcarthur> *packages
20:16:11 <serialhex> https://wiki.archlinux.org/index.php/Haskell_Package_Guidelines#.5Bhaskell.5D
20:19:39 <captain_rat> I wish arch would let haskell just cabal-install
20:19:41 <hpaste> mkramer pasted “formatting help - change making” at http://hpaste.org/70599
20:19:46 <captain_rat> not have this cabal to arch shit
20:20:07 <captain_rat> I can just use cabal-install eh?
20:20:08 <captain_rat> ok
20:20:10 <captain_rat> wow
20:20:13 <captain_rat> haskell!!
20:20:17 <captain_rat> I am like ratbert
20:20:23 <captain_rat> dont know much about programming
20:20:32 <captain_rat> but confident I can learn something and something cool!!
20:20:46 <captain_rat> my linux knowhow should not hamper too much
20:20:47 <mkramer> Hey guys, can you help me understand how to format if/then/else in combination with nested lets and wheres?
20:21:08 <edwardk> mkramer: paste what you're trying to fix up to hpaste.org
20:21:09 <mkramer> I'm sitting here with Real World Haskell and I'm not finding the answer to my question
20:21:14 <mkramer> I have here - http://hpaste.org/70599
20:21:51 <captain_rat> http://learnyouahaskell.com/introduction#about-this-tutorial
20:21:53 <edwardk> are you looking for the most idiomatic way to write it or to just get it to compile?
20:22:03 <rwbarton> mkramer: well those backslashes don't belong
20:22:11 <mkramer> the most idiomatic way sure
20:22:28 <mkramer> that's preferable to the most idiotic way ;)
20:22:32 <captain_rat> lol
20:22:57 <rwbarton> lines 21-24 are indented one space too far
20:23:10 <rwbarton> probably because you are using tabs (don't use tabs)
20:23:35 <dmwit> (or use tabs, but don't suck at it)
20:23:43 <hpaste> edwardk annotated “formatting help - change making” with “formatting help - change making (annotation)” at http://hpaste.org/70599#a70600
20:23:56 <serialhex> dmwit: YAY!!!  how are you this evening?
20:24:16 <hpaste> edwardk annotated “formatting help - change making” with “formatting help - change making (annotation) (annotation)” at http://hpaste.org/70599#a70601
20:24:30 <edwardk> as a point of advice, don't let tabs leak into your code like that
20:24:53 <shachaf> dmwit, tab champion of #haskell
20:25:09 <shachaf> Providing "the other point of view" since 2006.
20:25:39 <mkramer> I'm looking at my editor with invisibles shown, and there are no spaces
20:25:49 <serialhex> mkramer: most good editors allow one to use tab & have it insert N spaces instead of a tab...
20:25:51 <edwardk> hah, i beat dmwit's registration by a few months ;)
20:26:08 <rwbarton> yes. no spaces is the problem. you should use spaces not tabs
20:26:20 <mkramer> so, thanks for showing me how to do this using guards edwardk
20:26:26 <shachaf> edwardk: Oh, dmwit actually registered in 2006.
20:26:32 <dmwit> serialhex: hi
20:26:40 <edwardk> 5 years, 50 weeks and 5 days ago i took upon myself a new nick and joined the haskell community.
20:26:44 * edwardk gets a tear in his eye
20:26:50 <shachaf> I just picked a year semi-arbitrarily, knowing that he'd been around for a while.
20:26:51 <mkramer> could you demonstrate how to keep it with if/then/else and the let/in/where?
20:26:53 <edwardk> shachaf: =)
20:27:01 <edwardk> shachaf: good guess. you should become a carnie
20:27:09 <shachaf> 20:26 -NickServ(NickServ@services.)- Registered : Jul 03 22:30:48 2004 (7 years, 51 weeks, 5 days, 04:55:52 ago)
20:27:11 <mkramer> that would really help me understand how these different expressions are composed
20:27:35 <edwardk> mkramer: the problem is you can't use the thing you bind with 'let' in the 'where'
20:27:45 <edwardk> the where is over the entire statement, but the let is local to the expression
20:27:49 <serialhex> dmwit: it's not working yet, but replacing the 'a' & 'b' at the end with d N gives me what i want
20:27:53 <serialhex> sequence a:b:bs = foo (\x -> fmap' (\y -> [y,x] ) a ) b
20:28:00 <edwardk> so i moved the maxSize out to the where clause where it could be referenced
20:28:16 <dmwit> hm
20:28:23 <edwardk> you can replace the |'s with the if then else you had, just keep the where
20:28:38 <dmwit> Is there a reason you're demanding the list be of length at least two?
20:28:49 <dmwit> You should use the usual [] and (x:xs) patterns.
20:28:57 <dmwit> Or a foldr, if you think you feel up to it. ^_^
20:29:20 <serialhex> -_- you know, that would be the *smart* thing to do... but who on earth would do that?!?!?!
20:29:26 <serialhex> :P
20:29:55 <serialhex> teach me foldr...  so i may become wise in the ways of folding
20:30:02 <dmwit> um
20:30:23 <serialhex> or should i try this more myself
20:30:34 <dmwit> Any function that you would write as "foo [] = z; foo (x:xs) = bar x (foo xs)" can just be "foo = foldr bar z" instead.
20:30:39 <dmwit> That's all there is to it.
20:31:12 <serialhex> hmm, okay
20:32:12 <mkramer> dmwit: I don't understand your question - I don't see where I'm checking the length of the list
20:32:28 <dmwit> mkramer: I'm not talking to you.
20:32:33 <mkramer> oh ;)
20:32:45 <dmwit> Or rather, the previous sentences weren't aimed at you. I'm not mad at you or anything. =P
20:37:26 <zzo38> edwardk: Do you know what I was writing about above? Maybe you know, nobody else responded and neither did you
20:37:44 <edwardk> zzo38: i didn't see anything
20:37:52 <edwardk> zzo38: been working on stuff in another window
20:38:02 <zztw> do people here do much graph based data management here?
20:38:15 <zztw> context: i'm at a neo4j meetup
20:38:22 <zzo38> Things like (forall z. c z => (x -> z) -> z) and (forall z. c z => (z -> x, z))
20:38:27 <edwardk> zztw: yes, though graphs kind of suck in all languages
20:38:43 <edwardk> zzo38: did you see sjoerd vissher's version of that?
20:39:02 <zztw> edwardk: it could be argued that everything sucks in all languages in varying degrees
20:39:29 <edwardk> zztw: ok, well, in addition to sucking in general they kind of particularly suck in haskell ;)
20:39:44 <zzo38> edwardk: No I did not. But I did think about it. (Here using not only the class methods of c but also the mathematical laws)
20:39:48 <zztw> ah :(
20:40:12 <edwardk> https://gist.github.com/2965235
20:40:22 <edwardk> have fun mining that for a few minutes ;)
20:41:06 <zztw> edwardk: care to elaborate about graph suckage? or have any code I can mine for a few minutes?
20:41:18 <zzo38> For the right (the first) version, it seem if c is monoid then it will be like a foldable list, and with the left version c can be Copeanoid for a non-empty list. Or, something like that, anyways.
20:42:08 <edwardk> zztw: well there is Data.Graph in containers, I have a 'graphs' package which is far from idiomatic haskell but gives you some basic boost graph library algorithms in haskell
20:42:19 <edwardk> zztw: there is fgl but fgl is a pretty bad performance pig
20:42:32 <zzo38> It seems to makea non-empty list comonad from that!
20:43:03 <edwardk> zzo38: figured it'd make you happy ;)
20:43:19 <edwardk> zzo38: he's posted about it somewhere i think, or at least chatted about it on google+
20:43:43 <zzo38> edwardk: O, now I looked at the link you posted and yes it is like the same things I have thought about (I have not looked at it until now)
20:44:12 <zztw> edwardk: could you point me at your 'graphs'?
20:44:50 <zztw> i found the other two
20:44:51 <edwardk> github.com/ekmett/graphs or hackage.haskell.org/package/graphs
20:45:15 <zztw> thanks :)
20:45:16 <edwardk> mine is more of a sketch of how one can build such an api by making monad transformers into graph transformers
20:45:23 <zzo38> Except that in mine it is a monad for the right and comonad for the left in the similar way of Codensity and Density
20:45:35 <edwardk> ivanm was going to fill in some parts but it kind of fizzled
20:46:24 <SrPx> So guys, I have been thinking. In a pure, mathematical standpoint,,, are functions tied to types?
20:47:09 <rwbarton> that depends on which pure, mathematical standpoint you adpot
20:47:12 <rwbarton> *adopt
20:47:47 <Yarou> depends on what you mean by "tied to"
20:47:59 <startling> depends on what you mean by "functions"
20:48:12 <startling> ;)
20:48:12 <edwardk> well, these came about from a slightly more principled observation that many monads/comonads arise as free constructions where the adjunction is to a more interesting category (the interesting parts are represented by the constraint)
20:48:16 <SrPx> Functions are just a mapping of some kind of 'data' to another kind, right.
20:48:17 <Yarou> semantics are always fun startling, i agree
20:48:21 <SrPx> Or even better, rules to manipulate 'things' in a certain way
20:48:34 <SrPx> startling: hmm
20:48:34 <startling> SrPx, what's a "kind"?
20:48:41 <zzo38> edwardk: Does that work how I have described it? (Copeanoid is a class in the "prelude-generalize" package)
20:48:57 <SrPx> startling: I ask you
20:49:02 <edwardk> zzo38: no idea. i pasted it and went back to work on code ;)
20:49:09 <Yarou> btw i'm not sure if category theory is considered purely "mathematical"...
20:49:16 <edwardk> i just observed you had the constraint in there
20:49:27 <edwardk> and figured you'd get something out of his take on it
20:49:36 <startling> SrPx, math is a game where you get to pick the rules and see what happens
20:49:50 <startling> SrPx: there are a bunch of different things you can do.
20:50:41 <SrPx> startling: hm
20:51:13 --- mode: edwardk set -o edwardk
20:51:28 <Yarou> maybe some haskell gurus have some insight
20:51:37 <zzo38> edwardk: His is similar. And he did make the list when the constraint is the Monoid. But can't it always make the monad (for the right) and comonad (for the left) the way that Codensity and Density works? Do you know my Copeanoid class?
20:52:17 <edwardk> i confess i've forgotten your class and haven't spent much time thinking about the ramifications of his trick
20:52:22 <startling> SrPx, anyway, there's typed lambda calculus and untyped lambda calculus
20:52:34 <startling> which are sort of what you're asking
20:52:40 <edwardk> Yarou: if category theory isn't math i'm not quite sure what is =P
20:53:53 <Yarou> edwardk: that's a valid point i suppose
20:54:11 <Yarou> i don't have sufficient knowledge in either category theory or mathematics to comment
20:54:44 <zzo38> edwardk: When I thought about it (earlier today), for the left version, if the class is Copeanoid (class Copeanoid x where { predP :: x -> Maybe x; }) it seems to make something like a non-empty list comonad from what I can tell
20:54:48 <edwardk> category theory, like set theory can be used as an axiomatic starting point to describe mathematics, and set and category theory can be defined in terms of each other
20:56:56 <Yarou> edwardk: huh, i hadn't thought of it that way
20:57:04 <startling> edwardk, where does group theory fall into that? can groups be a kind of category?
20:57:08 <edwardk> it provides a useful set of abstractions and laws for reasoning about them, you can tie it to mathematical logic, set theory, you can work with topology, just about anything in mathematics with it
20:57:31 <edwardk> take a category, give it one object, give every arrow an inverse, you have a group
20:57:38 <Yarou> i know sufficiently enough about set theory to conclude that yes, set theory can be used axiomatically to describe mathematics
20:57:58 <Yarou> and from propositional logic to FoL to set theory etcf
20:57:59 <edwardk> now thats a boring way to work with groups in category theory, and not how it is typically done, but that is a category ;)
20:57:59 <Yarou> *etc
20:58:21 <startling> edwardk: very interesting
20:58:29 <startling> I ought to learn some category theory
20:58:41 <edwardk> startling: when you start withing with enriched categories you can start talking about rings as categories, etc.
20:58:53 <edwardk> er s/withing/working with
20:59:07 <zzo38> edwardk: Now I described to you what Copeanoid is, so can you answer my question by now?
20:59:34 <edwardk> zzo38: no, because then i have to go off and spend 20 minutes studying his code and its not at the top of my reading list yet ;)
21:00:39 <SrPx> startling: there is?
21:01:45 <zzo38> edwardk: I think you don't need to study his code, isn't it? Simply it is like Density except that instead of putting the forall variable in some container like (f z) and so on, you give it a constraint, I think
21:02:26 <zzo38> That code doesn't do it that way, but I don't know why
21:02:33 <edwardk> yes, but i also don't want to just make a glib assertion about it that i haven't checked
21:03:02 <zzo38> OK
21:04:18 <edwardk> zzo38: http://www.reddit.com/r/haskell/comments/v6ik6/a_notation_for_comonads_orchard_mycroft_pdf/ is where i first encountered sjoerd's code. i mentioned that you could derive lower for any comonad transformer using only extend and he showed a hand wavy analogy of why using that code
21:04:20 <startling> SrPx: mhm.
21:04:53 <edwardk> http://www.reddit.com/r/haskell/comments/v6ik6/a_notation_for_comonads_orchard_mycroft_pdf/c53lv0r
21:05:00 <edwardk> is the exact comment
21:05:31 <edwardk> type List = Free Monoid is still pretty sexy
21:07:08 <Cale> edwardk: ahaha, that is really cute
21:07:36 <edwardk> cale: i've been meaning to package it up in constraints somewhere
21:09:27 <edwardk> zzo38:  (forall z. c z => (x -> z) -> z)  is exactly what he wrote.
21:10:12 <edwardk> zzo38: and yes you should be able to define Monad and Comonad once for that type
21:10:16 <edwardk> er those types
21:10:22 <edwardk> now that i parse your statement
21:10:31 <zzo38> edwardk: That is also exactly what I wrote, for the right version of this. But then there is the left version (which is called Cofree in the code you linked, although I thought about it independently)
21:16:51 <edwardk> zzo38: well, here cofree is really just that, its a cofree comonad, just in terms of a forgetful functor that is forgetting a class constraint ;)
21:17:17 <edwardk> zzo38: so if nothing else your intuition is sending you in a productive direction
21:18:36 <startling> edwardk: oh, weird, can I think of a category as a group of morphisms (with composition as its binary operation) and some other stuff?
21:19:21 <edwardk> startling: if you don't use 'group' too formally in that statement
21:20:53 <edwardk> startling: a monoid is just a category with exactly one object, a groupoid is a category where the arrows are invertible, a group is just a monoid that is a groupoid
21:21:36 <startling> edwardk: oh, morphisms don't necessarily have inverses under composition, do they
21:21:43 <edwardk> correct
21:21:50 <edwardk> think Int -> Bool
21:21:55 <edwardk> can you invert every such arrow?
21:21:57 <startling> so not strictly a group. got it
21:22:15 <edwardk> and its not a monoid either, because there are some arrows you can't stick together
21:22:26 <edwardk> a monoid has one object, so you can always connect any two arrows
21:22:33 <startling> edwardk: what's the one object in a group, then?
21:22:45 <startling> the set of elements?
21:22:56 <edwardk> but a category can have multiple objects, and you can only connect the ones that match up on the same object from head to tail
21:23:04 <edwardk> startling: its really just a place holder
21:23:32 <zzo38> edwardk: O, my intuition is sending me in a productive direction? I have thought of different names since they are not the ordinary kind of free monad, they are like a kind of right and left Kan extension, so RCK (Right Constrained Kan extension) and LCK are what I would have used, but same idea otherwise
21:23:43 <edwardk> it doesn't have to 'be' anything. in many presentations of category theory the objects of a category are just sort of largely secondary indices used to track what arrows can connect to what
21:23:56 <edwardk> you can describe an object just by its identity arrow and then never talk about them again
21:24:12 <edwardk> well, it really is 'Free' and 'Cofree' in the categorical sense
21:24:16 <startling> yeah, i need to read up on this stuff. any especially good books?
21:24:29 <edwardk> startling: depends on your math background
21:24:38 * hackagebot attoparsec-conduit 0.5.0 - Consume attoparsec parsers via conduit.  http://hackage.haskell.org/package/attoparsec-conduit-0.5.0 (MichaelSnoyman)
21:24:47 <edwardk> startling: a lot of folks in here recommend awodey as a universal starting point -- and its pretty good
21:25:04 <edwardk> i really really like categories for the working mathematician, but it is a very slow slog
21:25:30 <edwardk> lawvere and schanuel are painfully slow at times, but the few things they reach are useful
21:25:41 <startling> edwardk: I've read books on set theory, graph theory, and group theory, if that tells you anything. I jump around in math a lot
21:25:41 <edwardk> and if you need drill, they are good
21:26:14 <edwardk> serge lang's algebra gives you a lot of category theory as it goes through other stuff, its a bit less dense than CftWM, but its a lot thicker, so you get a lot of practice
21:26:17 <startling> er, s/group theory/abstract algebra/, i guess
21:28:29 <Yarou> i'm sort of like startling, although i don't jump around in math
21:28:33 <Yarou> i really enjoy logic though
21:28:43 <edwardk> if you want to build up intuition you might come at it from order theory. there is a book 'introduction to lattices and order' by davey and priestley that gives a lot of drill on working up lattices, partial orders, distributive lattices, etc. and then gives you a good section on galois connections to sink your teeth into
21:28:59 <edwardk> since galois connections are just adjunctions that helps give intuition for adjunctions which can be in relative short supply
21:29:38 * hackagebot blaze-builder-conduit 0.5.0 - Convert streams of builders to streams of bytestrings.  http://hackage.haskell.org/package/blaze-builder-conduit-0.5.0 (MichaelSnoyman)
21:29:40 * hackagebot conduit 0.5.0 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-0.5.0 (MichaelSnoyman)
21:29:42 * hackagebot filesystem-conduit 0.5.0 - Use system-filepath data types with conduits.  http://hackage.haskell.org/package/filesystem-conduit-0.5.0 (MichaelSnoyman)
21:30:34 <edwardk> Yarou: you may want to start from the curry-howard-lambek correspondence then, and come at it from the standpoint that you can talk about types and propositions or as objects in a category of types, and then arrows are either functions, proofs of the proposition, or arrows in the category depending on the perspective you take
21:30:35 <tgeeky> edwardk: search your collection for the huge book 'The Connectives'
21:30:41 <edwardk> tgeeky_: will do
21:30:49 <tgeeky> edwardk: it goes from relations -> posets -> galois theory in 5 pages
21:30:52 <tgeeky> (clearly)
21:30:53 <edwardk> hah
21:31:02 <Yarou> edwardk: i see
21:31:08 <tgeeky> (in the first five pages, that is!)
21:31:09 <edwardk> oh, another good one is the barr and wells summer school writeup, thats available online
21:31:44 <edwardk> http://www.ling.ohio-state.edu/~plummer/courses/winter09/ling681/barrwells.pdf
21:31:45 <zzo38> Other names I would use are ClassCodensity and ClassDensity
21:31:50 <edwardk> that is really good
21:32:04 <wagle> i'm doing the coursera algorithms course..  i want to implement datastructures destructively as well as functionally..  how would/could I do that in haskell..  I was thinking about using this as an excuse to learn clean, but its pretty much windows only
21:32:12 <edwardk> i have to admit i rather like Free/Cofree for them
21:32:31 <edwardk> as inconvenient as it is for them to have the same name
21:32:34 <zzo38> edwardk: But there is also the other kind of free monads
21:33:02 <wagle> (ie, use this as an excuse to work through okasaki)
21:33:10 <edwardk> are there? =) if you make the class constrained on something of other kind then you can force them all into this framework
21:33:35 <edwardk> a free monad is defined in terms of its relation to a forgetful functor
21:33:56 <wagle> i think davey and priestley is online
21:34:17 <zzo38> These things are really like a kind of codensity monads and density comonads, it seem to me
21:34:21 <startling> is there a "transaction" thing I can use for having a bunch of things modify an array and then sort out the conflicts?
21:34:38 <edwardk> zzo38: that should tell you something fundamental about free monads, shouldn't it? ;)
21:35:17 <edwardk> startling: you can use revisions
21:35:28 <edwardk> startling: its on my github but not on hackage yet
21:36:14 <startling> edwardk, where's your github? :)
21:36:27 <edwardk> github.com/ekmett
21:36:32 <wagle> hmm..  guessnot..  i seem to be thinking of coalgebraic methods
21:36:44 <edwardk> wagle: shame
21:37:02 <wagle> new edition though
21:37:06 <edwardk> wagle: i don't recall objectively how good the davey/priestley book was, but it helped me get started
21:37:15 <startling> edwardk: interesting. thanks!
21:37:25 <edwardk> startling: there are papers, one sec.
21:39:20 <edwardk> http://research.microsoft.com/en-us/projects/revisions/
21:39:38 * hackagebot imagesize-conduit 0.5.0 - Determine the size of some common image formats.  http://hackage.haskell.org/package/imagesize-conduit-0.5.0 (MichaelSnoyman)
21:39:39 <edwardk> startling: the two for the price of one paper is quite compelling
21:39:41 * hackagebot network-conduit 0.5.0 - Stream socket data using conduits.  http://hackage.haskell.org/package/network-conduit-0.5.0 (MichaelSnoyman)
21:39:42 * hackagebot resourcet 0.3.3.1 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-0.3.3.1 (MichaelSnoyman)
21:39:45 * hackagebot zlib-conduit 0.5.0 - Streaming compression/decompression via conduits.  http://hackage.haskell.org/package/zlib-conduit-0.5.0 (MichaelSnoyman)
21:40:03 <wagle> i guess i was thinking of the chapter in http://www.informatik.uni-trier.de/~ley/db/conf/acmmpc/acmmpc2000.html
21:40:05 <shergill> i'm looking for some motivation to read up on category theory and related concepts. good examples of motivation would be examples where knowledge of those principles helps in an 'applied' sense eg., coming up with abstractions either for efficiency or elegance which would otherwise have been unfeasible
21:40:39 <wagle> ... by priestley
21:41:53 <srhb> The SugerHaskell paper looks neat. Wonder if it could be integrated.
21:42:01 <edwardk> shergill: right kan extensions generalize continuation passing style, codensity monads can be used to right associate >>='s and can asymptotically improve the efficiency of code, yoneda gives you a type that forces fmap fusion
21:42:06 <srhb> Sugar*
21:42:23 <edwardk> shergill: that means you enforce in the type of a functor that all maps should be done at the same time, which can be quite powerful
21:42:25 <wagle> you talking about hinze's Kan paper?
21:42:41 <zzo38> data Restrict c x where { Restrict :: c x => x -> Restrict c x; };
21:42:52 <edwardk> wagle: well, i have a 4 year old blog post on the topic, but yes, he just wrote it up in a paper ;)
21:43:00 <zzo38> Does it work?
21:43:01 <wagle> hehehe
21:43:24 <edwardk> zzo38: wassat?
21:44:06 <edwardk> wagle: i did learn something from his paper though, so i'm very happy =)
21:44:13 <zzo38> data IsInstance c x where { IsInstance :: c x => IsInstance c x; };
21:44:52 <edwardk> zzo38: oh, just parsed that, yes
21:45:00 <edwardk> zzo38: i have it in 'constraints'
21:45:04 <edwardk> well, close to it
21:45:25 <edwardk> https://github.com/ekmett/constraints/blob/master/Data/Constraint.hs#L53
21:45:46 <edwardk> there i just take something of kind Constraint, rather than * -> Constraint and a *
21:45:54 <shergill> edwardk: oh wow (regd yoneda). thanks for the concrete examples. and were the applications of these ideas, once someone is knowledgeable of the concepts, 'easy' to come up with. by 'easy' i mean something which doesn't seem like in the realm of deep magic like some algorithms at times do
21:45:58 <edwardk> zzo38: you can compose constraints, they form a category, etc.
21:46:14 <shergill> i.e., you can understand it, but you're left with a sense of wtf as to how someone came up with it
21:46:54 <edwardk> shergill: by now i'm pretty comfortable with them and they don't seem that magical at all. they are just a clear application of general principles from category theory to the category of types
21:47:10 <edwardk> now, that said, kan extensions in general are a bit magical at first
21:47:15 <edwardk> but they appear _everywhere_
21:47:25 <edwardk> so once you get an intuition for them its a very powerful thing
21:48:13 <edwardk> shergill: that said, i confess, my intuition is sometimes blunted by the fact that i only really ever apply these things in this one fairly rich category
21:48:51 <shergill> i skimmed some of the links you posted earlier, any specifically for kan extensions? if you can tell, i'm trying to kickstart a positive feedback/reward loop which would help in the learning process
21:49:38 <edwardk> well, i blogged on them, one sec.
21:49:50 <edwardk> https://github.com/ekmett/kan-extensions is a package of them
21:50:42 <edwardk> http://comonad.com/reader/2008/kan-extensions/ http://comonad.com/reader/2008/kan-extensions-ii/ http://comonad.com/reader/2008/kan-extension-iii/
21:50:49 <edwardk> those cover their use in haskell
21:51:21 <edwardk> of the books i mentioned the last chapter in categories for the working mathematician (well, next to last if you get the later edition that added some stuff on 2 categories i think)
21:51:30 <edwardk> is all about kan extensions
21:51:32 <startling> is there an efficient-ish type for keeping different versions of strings? something like cords or ropes or whatever
21:51:41 <shergill> coolio :) thanks!
21:52:06 <edwardk> startling: you can make them out of fingertrees of strings/bytestrings
21:52:21 <edwardk> startling: gives you O(1) access to either end and O(log chunkCount) access to the middle
21:52:22 <startling> yeah
21:52:49 <edwardk> plus cheap concatenation, etc.
21:54:12 <startling> yep. I was wondering if there was something I don't need to write myself, though. :)
21:54:36 <edwardk> startling: i had thought i'd pushed a package of annotated ropes to hackage
21:54:38 <edwardk> can't find it ;)
21:54:56 <edwardk> http://hackage.haskell.org/packages/archive/rope/0.3/doc/html/Data-Rope.html
21:55:04 <edwardk> i didn't use my usual plural, thats why
21:55:28 <Yarou> i have a bit of a noob question, so bear with me everyone
21:55:30 <edwardk> i welcome patches/a maintainer for that, its languished for a couple of years
21:55:34 <edwardk> Yarou: shoot
21:55:36 <Yarou> how does haskell work
21:55:44 <edwardk> in what sense?
21:55:46 <startling> edwardk: I'll take a look. thanks!
21:55:50 <edwardk> you mean how does the compiler work?
21:55:54 <Yarou> i know gcc and ld are involved
21:55:55 <Yarou> yeah
21:55:56 <edwardk> or how does the language fit together?
21:56:05 <Yarou> how does the compiler work
21:56:20 <wagle> one possible question is "what is laziness?"
21:56:21 <edwardk> well, there are lots of pieces to ghc, which is what i presume you mean when you say 'haskell' in this sense
21:56:29 <Yarou> yeah, mainly ghc
21:56:35 <Yarou> but i suppose the question applies to HUGS as well
21:57:09 <edwardk> so from a very mechanical perspective, ghc takes your program, desugars it into a core language without so many features, then generates spineless tagless g-machine code, and spews it through c--/llvm, etc. to an object file
21:57:22 <Yarou> i see
21:57:28 <edwardk> hugs on the other hand goes through its own intermediate representation stages
21:57:47 <Yarou> how was ghc first compiled?
21:57:53 <edwardk> jhc goes through grin rather than core and has a little bit of a funny dependent typing thing with how they desugar dictionaries
21:58:04 <Yarou> because subsequent versions are compiled with ghc as well :P
21:58:11 <edwardk> probably by running in someone else's haskell interpreter
21:58:17 <Yarou> ahh, i see
21:58:18 <edwardk> hugs itself was written in c as i recall
21:58:33 <edwardk> bootstrapping ghc on a new platform is quite a chore
21:59:04 <Yarou> edwardk: thanks
21:59:11 <Yarou> do you guys have that awk bot thingy where i get to do ++
21:59:16 <edwardk> now, the main thing to know about how haskell itself works in the abstract is how to evaluate lazy code on a virtual machine
21:59:29 <edwardk> lambdabot will respond to ++'s after nicks
21:59:33 <Yarou> ok
21:59:37 <edwardk> c/c++
21:59:39 <edwardk> @karma c/c
21:59:39 <lambdabot> c/c has a karma of 154
21:59:39 <Yarou> edwardk++
22:00:19 <wagle> @karma edwardk
22:00:19 <lambdabot> edwardk has a karma of 8
22:00:22 <edwardk> a good paper to understand that is the original spineless tagless g-machine paper
22:00:22 <startling> c/c++++
22:00:28 <startling> @karma c/c++
22:00:28 <lambdabot> c/c++ has a karma of 1
22:00:37 <edwardk> cute =)
22:00:54 <edwardk> wagle: lambdabot is a bit of an amnesiac where karma is concerned
22:00:54 <wagle> title?
22:01:12 <edwardk> http://research.microsoft.com/apps/pubs/default.aspx?id=67083
22:01:18 <edwardk> Implementing Lazy Functional Languages on Stock Hardware: The Spineless Tagless G-machine
22:01:52 <edwardk> http://research.microsoft.com/en-us/um/people/simonpj/papers/ptr-tag/index.htm describes a very important optimization to it
22:01:57 <Yarou> edwardk: can haskell itself be thought of as a DSL (domain-specific language) for untyped or typed lambda calculus
22:02:13 <edwardk> which is dynamic pointer tagging (using the least significant bits of the pointer to add tags to a tagless representation)
22:02:16 <edwardk> not really
22:02:55 <Yarou> let me read these two
22:02:57 <edwardk> the meaning of a haskell program is defined 'a la church' in the sense that the types change the meaning of your code.
22:03:18 <edwardk> the instances the type checker pick can make the same syntactic code mean different things
22:03:44 <edwardk> so while yes you can ultimately pretend everything runs on a turing machine or in the lambda calculus
22:03:51 <edwardk> its not a very useful intuition
22:03:59 <Yarou> edwardk: i see, thanks for clarifying
22:04:07 <edwardk> brb
22:04:49 <startling> Yarou, similarly, haskell can be thought of as a dsl for brainfuck
22:05:18 <Yarou> startling: haha
22:05:25 <Yarou> bf is quite fun
22:06:41 <zzo38> You could try something without constraint kind:   data Monoid_ x where { Monoid_ :: Monoid x => Monoid_ x; }; data Functor_ x where { Functor_ :: Functor x => Functor_ x; }; type Restrict c x = (c x, x);
22:07:03 <zzo38> Not quite, but something like that.
22:09:39 <zzo38> Now, for example, (Monoid_) is of type (Monoid_ x) if you have the instance (Monoid x) otherwise it is a type mismatch.
22:10:17 <wagle> i had a question about what to use instead of uniqueness types to do imperative datastructures in an interesting way
22:11:21 <wagle> i want to try implementing datastructures both ways and compare and contrast
22:11:45 <copumpkin> ST?
22:11:58 <wagle> is that what I want?  ok
22:13:41 <wagle> i'm afraid of doing it wrong and having haskell (ghc) decide to make copies instead of destructive mods, and not being  told
22:14:51 <Ralith> wagle: profile, then optimize.
22:15:22 <wagle> darn, i was hoping it'd have any obvious-to-experts answer in the type system or something
22:15:40 <wagle> darn, i was hoping it'd have *an* obvious-to-experts answer in the type system or something
22:16:24 <Ralith> I'm no expert, but imo you have better things to do than look for one in lieu of a real-world performance problem.
22:16:24 <wagle> Ralith: ok, thanks..  i'll have to figure out how to do both those anyway
22:17:16 <wagle> its more curiousity..  i have the feeling that the two methods interconvert in an interesting way
22:18:24 <Ralith> well, best of luck finding an expert, then!
22:18:37 <wagle> i scared em off
22:20:42 <wagle> the idea i have is that you tell the type system you want single threaded states (or something), and it balks if it can't do it, instead of just copying
22:21:55 <wagle> because i heard that ghc cana optimize susceptible code to destructive mods..  i want to insist it try-or-fail
22:22:16 <wagle> i hate this keyboard
22:23:33 <startling> can I convince cabal to build and install an executable in a certain place?
22:23:45 <startling> *to a certain place
22:24:05 <wagle> once off, or all the time?
22:24:16 <startling> just once
22:24:39 <wagle> cabal --global or whatever might have a prefix argument
22:25:08 <startling> I have a C project with a helper executable written in haskell. I just want cabal to build and install to the C project's top level directory, preferably with a makefile rule
22:26:27 <wagle> cabal install --help
22:26:27 <wagle> gives you lots of knobs to frob
22:27:00 <edwardk> zzo38: i have done that monomorphic version, its just awfully tedious
22:27:01 <wagle> including --dry-run
22:35:18 <zzo38> edwardk: OK
22:38:53 <wagle> startling: did that help/work?
22:44:04 <RebelBunny> How did Haskell become so popular on freenode?
22:44:27 <tgeeky> because it's useful
22:44:45 <Axman6> and because we're all really helpful
22:48:04 <Axman6> RebelBunny: do you think this channel shouldn't be so big?
22:48:07 <edwardk> RebelBunny: because the community went out of its way to be helpful and nice
22:49:34 <startling> wagle, I just decided to use ghc and skip cabal altogether.
22:49:40 * hackagebot bzlib-conduit 0.2.0.0 - Streaming compression/decompression via conduits.  http://hackage.haskell.org/package/bzlib-conduit-0.2.0.0 (HideyukiTanaka)
22:50:07 <wagle> startling: ahh..  that works
22:50:28 <startling> wagle: yeah. would be nice if I could specify dependencies, but I can just stick that in the README
22:52:25 <wagle> might be able to use cabal to detect dependencies without using it to build
22:52:32 <wagle> startling: ^^^
22:53:19 <startling> s'true
23:12:27 <palmfrond> what is it called when a system outputs something to console which *is not* output of an input command/statement? so when you're ssh'd into a server and some text shows up in your shell, what's that mechanic called? system message or? say, the motd, some network link going down or coming up, etc
23:13:17 <startling> palmfrond, it is the input of a command/statement
23:13:25 <srhb> > foldl (+) 0 [a,b,c]
23:13:27 <startling> s/input/output, i mean
23:13:28 <lambdabot>   0 + a + b + c
23:13:28 <srhb> lambdabot: ?
23:13:28 <lambdabot> Maybe you meant: . ? @ activity activity-full admin all-dicts arr ask b52s babel bf bid botsnack brain bug check choice-add choose clear-messages compose devils dice dict dict-help djinn djinn-add
23:13:29 <lambdabot> djinn-clr djinn-del djinn-env djinn-names djinn-ver do docs dummy easton echo elements elite eval fact fact-cons fact-delete fact-set fact-snoc fact-update faq farber flush foldoc forget fortune
23:13:29 <lambdabot> fptools free freshname ft gazetteer get-shapr ghc girl19 google googleit gsite gwiki hackage help hitchcock hoogle hoogle+ id ignore index instances instances-importing irc-connect jargon join karma
23:13:29 <lambdabot> karma+ karma- karma-all keal kind learn leave let list listall listchans listmodules listservers localtime localtime-reply lojban map messages messages? more msg nazi-off nazi-on nixon oeis offline
23:13:29 <lambdabot> oldwiki palomer part paste ping pl pl-resume pointful pointless pointy poll-add poll-close poll-list poll-remove poll-result poll-show pretty print-notices protontorpedo purge-notices quit quote rc
23:13:31 <lambdabot> read reconnect remember repoint run shootout show slap smack source spell spell-all src tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc
23:13:33 <lambdabot> topic-tail topic-tell type undefine undo unlambda unmtl unpf unpl unpointless uptime url v vera version vote web1913 what where where+ wiki wn world02 yarr yhjulwwiefzojcbxybbruweejw yow
23:13:38 <srhb> holy..
23:13:46 <otters> @web1913
23:13:51 <Dtgr> :D
23:13:55 <palmfrond> startling, i said IS NOT
23:13:56 <startling> lambdabot: yhjulwwiefzojcbxybbruweejw
23:14:16 <startling> palmfrond, yes. you're wrong, though
23:14:17 <nameless_> yarr
23:14:46 <startling> palmfrond, the motd is part of some script your shell runs on startup
23:14:59 <wagle> palmfrond: "out of band"?
23:15:18 <palmfrond> how am i wrong?
23:15:24 <palmfrond> ah
23:15:36 <Dtgr> palmfrond: motd is probably just an output of echo
23:15:51 <Dtgr> or cat or whatever
23:16:25 <startling> usually cat /etc/motd
23:16:42 <wagle> http://en.wikipedia.org/wiki/Out-of-band
23:17:27 <startling> wagle, hm, that sort of implies control characters and the like, though
23:18:11 <wagle> maybe, depends
23:18:39 <wagle> i dunno..  just suggesting a phrase that might be what he's looking for
23:20:38 <palmfrond> wagle, out of band has me leaning towards "system signal"
23:20:45 <palmfrond> because of signal control mentioned in it
23:21:02 <palmfrond> system signal vs user message?
23:21:16 <palmfrond> seems like a good distinction
23:22:37 <wagle> hmm.. dunno..  i havent heard it phrased that way, but...
23:23:10 <palmfrond> hm
23:23:48 <startling> wow, haskell is so nice for parsing
23:24:00 <wagle> i'm only heard "out of band (OOB) signal"
23:24:07 <wagle> i've
23:25:35 <startling> 10 lines in parsec ftw
23:27:01 <palmfrond> http://en.wikipedia.org/wiki/Control_signal
23:27:26 <palmfrond> the 3 points seem similar to when an OS would shit a text message into your shell notifying of a network flap
23:27:28 <palmfrond> link up/down
23:27:38 <startling> palmfrond, maybe "line noise"? that has a negative connotation, though
23:32:29 <palmfrond> yea
23:32:44 <palmfrond> it's gotta be something like console message, system message, etc
23:33:04 <palmfrond> it's a broadcast of the style UDP is, no response expected
23:33:20 <solrize> i think i'd describe that as text interspersed from two different sources
23:33:30 <solrize> i.e. not such a good situation
23:35:43 <palmfrond> it has its place
23:36:13 <palmfrond> my program supports controlling the program, as well as interacting with the program's context
23:36:27 <palmfrond> 2 different types of interaction, and therefore 2 diff kinds of communication
23:37:24 <palmfrond> user interaction follows input/output model. program control follows both input/output (control commands) and broadcast/messaging (network interface went down)
23:40:53 <palmfrond> yea so output, and message
23:41:12 <palmfrond> that seems to be the 2 kinds of data a system can issue to a console
23:50:40 <Nensha> hello!
23:50:43 <Nensha> where is Paths_cabal_install ?
23:52:05 <Nensha> is it internal thing in cabal?
23:52:36 <ksf> can someone help me make an instance of foldable?
23:52:50 <ksf> foldable from recursion-schemes, that is
23:52:54 <ksf> http://hpaste.org/70603
23:54:21 <wnoise> I have some Haskell 98 code from 2005.  Current ghc chokes on it, as the "haskell98" package is hidden so as to not conflict with base.  Adding -package haskell98 means ghc chokes on the conflict.  What's the recommended way to deal with this?
23:54:41 <ksf> hide base
23:55:08 <ksf> (-hide-package base)
23:55:27 <ksf> oh, and don't forget -XHaskell98
23:56:15 <wnoise> Thanks.  Why doesn't -XHaskell98 hide base, and unhide haskell98?
23:56:33 <ksf> because it's a language pragma only.
23:56:48 <ksf> it would be the only language pragma to mess with packages, and that'd be surprising.
23:56:53 <ksf> and surprises aren't good.
23:58:02 <wnoise> I find it surprising that that flag isn't enough to compile haskell98.  But I can see that argument.
23:58:26 * Nensha is looking for personal haskell teacher >_<
23:59:06 <wnoise> (Argh.  The code is acutally an odd mix of Haskell98 and later with qualified module names.  Looks like I'll convert to 2010 then.)
23:59:44 <ksf> get sed ready.
